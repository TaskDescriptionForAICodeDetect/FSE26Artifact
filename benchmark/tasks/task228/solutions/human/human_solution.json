[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport scala.collection.mutable\nimport scala.io.StdIn._\nobject Main extends App {\n\n  solve()\n  @tailrec def solve(): Unit = {\n    val Array(h, w) = readLine.trim.split(' ').map(_.toInt)\n    if (h == 0 && w == 0) return\n    val rooms = Array.fill(h){Array.fill(w){Nil: List[Door]}}\n    var doorCount = 0\n    for (i ← 0 until 2 * h - 1) {\n      val states = readLine.trim.split(' ').filter(_.nonEmpty).map{_ == \"0\"}\n      i % 2 match {\n        case 0 ⇒ for (j ← states.indices if states(j))  {\n          rooms(i / 2)(j) ::= Door(Room(i / 2, j + 1), doorCount)\n          rooms(i / 2)(j + 1) ::= Door(Room(i / 2, j), doorCount)\n          doorCount += 1\n        }\n        case 1 ⇒ for (j ← states.indices if states(j)) {\n          rooms(i / 2)(j) ::= Door(Room(i / 2 + 1, j), doorCount)\n          rooms(i / 2 + 1)(j) ::= Door(Room(i / 2, j), doorCount)\n          doorCount += 1\n        }\n      }\n    }\n    val byBrokenDoor = (0 until doorCount).map{id ⇒ countMinCost(rooms, id)}.toArray\n    val worst = Array.tabulate(h){i ⇒ Array.tabulate(w){j ⇒ byBrokenDoor.map{_(i)(j)}.max}}\n    if (byBrokenDoor.exists(a ⇒ a(0)(0) == Int.MaxValue)) {\n      println(-1)\n      solve()\n    }else {\n      var left = 0\n      var right = h * w * 2\n      while (left < right){\n        val mid = (left + right) / 2\n        if (canPass(rooms, worst, mid)) right = mid\n        else left = mid + 1\n      }\n      println(right)\n      solve()\n    }\n  }\n  def canPass(rooms: Array[Array[List[Door]]], worst: Array[Array[Int]], k: Int): Boolean = {\n    val count = Array.fill(rooms.length){Array.fill(rooms.head.length){Int.MaxValue}}\n    val queue = mutable.Queue(Room(0, 0))\n    count(0)(0) = 0\n    while(queue.nonEmpty) {\n      val current = queue.dequeue()\n      for (Door(next, _) ← rooms(current.h)(current.w) if count(next.h)(next.w) == Int.MaxValue) {\n        if (worst(next.h)(next.w) + count(current.h)(current.w) + 1 <= k) {\n          count(next.h)(next.w) = count(current.h)(current.w) + 1\n          queue.enqueue(next)\n        }\n      }\n    }\n    count.last.last <= k\n  }\n  def countMinCost(rooms: Array[Array[List[Door]]], invalid: Int): Array[Array[Int]] = {\n    val count = Array.fill(rooms.length){Array.fill(rooms.head.length){Int.MaxValue}}\n    val queue = mutable.Queue(Room(rooms.length - 1, rooms.head.length - 1))\n    count(rooms.length - 1)(rooms.head.length - 1) = 0\n    while (queue.nonEmpty) {\n      val current = queue.dequeue()\n      for (next ← rooms(current.h)(current.w) if next.id != invalid && count(next.to.h)(next.to.w) == Int.MaxValue) {\n        count(next.to.h)(next.to.w) = count(current.h)(current.w) + 1\n        queue.enqueue(next.to)\n      }\n    }\n    count\n  }\n}\ncase class Door(to: Room, id: Int)\ncase class Room(h: Int, w: Int)\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n,m;\nvvi H,W;\nvvi dp,T;\n\nint main(){\n\twhile(cin>>n>>m,n){\n\t\tH=vvi(n-1,vi(m));\n\t\tW=vvi(n,vi(m-1));\n\t\trep(k,n-1){\n\t\t\trep(i,m-1)cin>>W[k][i];\n\t\t\trep(i,m)cin>>H[k][i];\n\t\t}\n\t\trep(i,m-1)cin>>W[n-1][i];\n\t\tT=dp=vvi(n,vi(m));\n\t\trep(i,n-1)rep(j,m)if(H[i][j]==0){\n\t\t\tH[i][j]=1;\n\t\t\t\n\t\t\trep(x,n)rep(y,m)T[x][y]=inf;\n\t\t\tT[n-1][m-1]=0;\n\t\t\tqueue<pii>q;\n\t\t\tq.push({n-1,m-1});\n\t\t\twhile(!q.empty()){\n\t\t\t\tpii t=q.front();\n\t\t\t\tq.pop();\n\t\t\t\trep(w,4){\n\t\t\t\t\tint x=t.first+dx[w];\n\t\t\t\t\tint y=t.second+dy[w];\n\t\t\t\t\tif(x<0||y<0||x>=n||y>=m)continue;\n\t\t\t\t\tif(w==0&&W[t.first][t.second])continue;\n\t\t\t\t\tif(w==1&&H[t.first][t.second])continue;\n\t\t\t\t\tif(w==2&&W[t.first][t.second-1])continue;\n\t\t\t\t\tif(w==3&&H[t.first-1][t.second])continue;\n\t\t\t\t\tif(T[x][y]>T[t.first][t.second]+1){\n\t\t\t\t\t\tT[x][y]=T[t.first][t.second]+1;\n\t\t\t\t\t\tq.push({x,y});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(x,n)rep(y,m)dp[x][y]=max(dp[x][y],T[x][y]);\n\t\t\tH[i][j]=0;\n\t\t}\n\t\trep(i,n)rep(j,m-1)if(W[i][j]==0){\n\t\t\tW[i][j]=1;\n\t\t\t\n\t\t\trep(x,n)rep(y,m)T[x][y]=inf;\n\t\t\tT[n-1][m-1]=0;\n\t\t\tqueue<pii>q;\n\t\t\tq.push({n-1,m-1});\n\t\t\twhile(!q.empty()){\n\t\t\t\tpii t=q.front();\n\t\t\t\tq.pop();\n\t\t\t\trep(w,4){\n\t\t\t\t\tint x=t.first+dx[w];\n\t\t\t\t\tint y=t.second+dy[w];\n\t\t\t\t\tif(x<0||y<0||x>=n||y>=m)continue;\n\t\t\t\t\tif(w==0&&W[t.first][t.second])continue;\n\t\t\t\t\tif(w==1&&H[t.first][t.second])continue;\n\t\t\t\t\tif(w==2&&W[t.first][t.second-1])continue;\n\t\t\t\t\tif(w==3&&H[t.first-1][t.second])continue;\n\t\t\t\t\tif(T[x][y]>T[t.first][t.second]+1){\n\t\t\t\t\t\tT[x][y]=T[t.first][t.second]+1;\n\t\t\t\t\t\tq.push({x,y});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(x,n)rep(y,m)dp[x][y]=max(dp[x][y],T[x][y]);\n\t\t\tW[i][j]=0;\n\t\t}\n\t\trep(i,n)rep(j,m)T[i][j]=inf;\n\t\tT[0][0]=dp[0][0];\n\t\tpriority_queue<tp>q;\n\t\tq.push(tp(0,0,0));\n\t\twhile(!q.empty()){\n\t\t\tint x,y,cost;\n\t\t\ttie(cost,x,y)=q.top();\n\t\t\tcost*=-1;\n\t\t\tq.pop();\n\t\t\trep(w,4){\n\t\t\t\tint nx=x+dx[w];\n\t\t\t\tint ny=y+dy[w];\n\t\t\t\tif(nx<0||ny<0||nx>=n||ny>=m)continue;\n\t\t\t\tif(w==0&&W[x][y])continue;\n\t\t\t\tif(w==1&&H[x][y])continue;\n\t\t\t\tif(w==2&&W[x][y-1])continue;\n\t\t\t\tif(w==3&&H[x-1][y])continue;\n\t\t\t\tint ncost=max(T[x][y],cost+1+dp[nx][ny]);\n\t\t\t\tif(T[nx][ny]>ncost){\n\t\t\t\t\tT[nx][ny]=ncost;\n\t\t\t\t\tq.push(tp(-cost-1,nx,ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tshow2d(dp);\n//\t\tshow2d(T);\n\t\tif(T[n-1][m-1]==inf)T[n-1][m-1]=-1;\n\t\tcout<<T[n-1][m-1]<<endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reps(i,a,b) for(int i=(a); i<(b); ++i)\n#define rep(i,n) reps(i,0,n)\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nstruct UnionFind{\n\tstd::vector<int> data;\n\tUnionFind(int size): data(size, -1) {}\n\n\tbool unite(int x, int y){\n\t\tx=root(x);\n\t\ty=root(y);\n\t\tif( x != y ){\n\t\t\tif( data[y] < data[x] ) std::swap(x, y);\n\t\t\tdata[x] += data[y];\n\t\t\tdata[y] = x;\n\t\t}\n\t\treturn x!=y;\n\t}\n\n\tbool find(int x, int y){\n\t\treturn root(x) == root(y);\n\t}\n\n\tint root(int x){\n\t\treturn (data[x] < 0)? x : data[x]=root(data[x]);\n\t}\n\n\tint size(int x){\n\t\treturn -data[ root(x) ];\n\t}\n};\n\n// R, U, L, D\nconst int vx[]={1,0,-1,0}, vy[]={0,1,0,-1};\n\nconst int INF = 1e9;\n\nint h, w;\nint ans;\nmap<pii,int> cost;\nint tb[50][50];\nvoid solve(map<pii,int> &mp, int x, int y, int d){\n\tqueue<pair<pii,int>> que;\n\tque.push( {pii(x,y), d} );\n\ttb[x][y] = d;\n\twhile(!que.empty()){\n\t\tauto cur = que.front().X;\n\t\tint x = cur.X;\n\t\tint y = cur.Y;\n\t\tint d = que.front().Y;\n\t\tque.pop();\n\t\trep(k,4){\n\t\t\tint nx = x + vx[k];\n\t\t\tint ny = y + vy[k];\n\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n\t\t\tif( mp[cur] & (1<<k) ) continue;\n\t\t\tif( tb[nx][ny] > d + 1 ){\n\t\t\t\ttb[nx][ny] = d + 1;\n\t\t\t\tque.push( {pii(nx,ny), d+1} );\n\t\t\t}\n\t\t}\n\t}\n\t//if( !tb.count(pii(w-1,h-1)) ) tb[pii(w-1,h-1)] = INF;\n\tcost[pii(x,y)] = max(cost[pii(x,y)], tb[w-1][h-1]);\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\twhile(cin >> h >> w, h|w){\n\t\tcost.clear();\n\t\tmap<pii,int> mp;\n\t\tint d;\n\t\trep(i,h-1){\n\t\t\trep(j,w-1){\n\t\t\t\tcin >> d;\n\t\t\t\tif( d == 1 ){\n\t\t\t\t\tmp[pii(j,i)]   |= (1<<0);\n\t\t\t\t\tmp[pii(j+1,i)] |= (1<<2);\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,w){\n\t\t\t\tcin >> d;\n\t\t\t\tif( d == 1 ){\n\t\t\t\t\tmp[pii(j,i)]   |= (1<<1);\n\t\t\t\t\tmp[pii(j,i+1)] |= (1<<3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint i = h-1;\n\t\trep(j,w-1){\n\t\t\tcin >> d;\n\t\t\tif( d == 1 ){\n\t\t\t\tmp[pii(j,i)]   |= (1<<0);\n\t\t\t\tmp[pii(j+1,i)] |= (1<<2);\n\t\t\t}\n\t\t}\n\t\trep(i,h) mp[pii(0,i)]   |= (1<<2);\n\t\trep(i,h) mp[pii(w-1,i)] |= (1<<0);\n\t\trep(i,w) mp[pii(i,0)]   |= (1<<3);\n\t\trep(i,w) mp[pii(i,h-1)] |= (1<<1);\n\n\t\tfill( tb[0], tb[0]+50*50, INF );\n\t\tmap<pii,int> tb_s;\n\t\tsolve(mp, 0, 0, 0);\n\t\trep(y,h) rep(x,w) tb_s[pii(x,y)] = tb[x][y];\n\t\tans = 0;\n//\t\trep(i,h){\n//\t\t\trep(j,w) cout << tb_s[pii(j,i)] << \" \";\n//\t\t\tcout << endl;\n//\t\t}\n\n\t\tauto mp1 = mp;\n\t\trep(y,h) rep(x,w) rep(k,4){\n\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n\t\t\tif( cost[pii(x,y)] >= INF ) continue;\n\t\t\tint nx = x + vx[k];\n\t\t\tint ny = y + vy[k];\n\t\t\tmp1[pii(x,y)]   |= (1<<k);\n\t\t\tmp1[pii(nx,ny)] |= (1<<((k+2)%4));\n\t\t\tfill( tb[0], tb[0]+50*50, INF );\n\t\t\t//solve(mp1, tb, x, y, tb_s[pii(x,y)]);\n\t\t\tsolve(mp1, x, y, 0);\n\t\t\tmp1[pii(x,y)]   ^= (1<<k);\n\t\t\tmp1[pii(nx,ny)] ^= (1<<((k+2)%4));\n\t\t\t//cout << \"solve: \" << x << \" \" << y << \" k=\" << k << endl;\n\t\t\t//rep(i,h){\n\t\t\t//\trep(j,w) cout << tb[pii(j,i)] << \" \";\n\t\t\t//\tcout << endl;\n\t\t\t//}\n\t\t}\n\n//\t\tcout << \"cost:\" << endl;\n//\t\trep(i,h){\n//\t\t\trep(j,w) cout << (cost[pii(j,i)]==INF ? 99 : cost[pii(j,i)]) << \" \";\n//\t\t\tcout << endl;\n//\t\t}\n\n\t\tint l=0, r=1000;\n\t\twhile(r-l>1){\n\t\t\tint limit = (l+r)/2;\n\t\t\ttypedef pair<pii,pii> PII;\n\t\t\tpriority_queue<PII, vector<PII>, greater<PII>> que;\n\t\t\tpii memo[50][50];\n\t\t\tfill( memo[0], memo[0]+50*50, pii(INF,INF) );\n\t\t\tque.push({{cost[pii(0,0)],0},pii(0,0)});\n\t\t\twhile(!que.empty()){\n\t\t\t\tint c = que.top().X.X;\n\t\t\t\tint d = que.top().X.Y;\n\t\t\t\tint x = que.top().Y.X;\n\t\t\t\tint y = que.top().Y.Y;\n\t\t\t\tque.pop();\n\t\t\t\tif( memo[x][y] < pii(c,d) ) continue;\n\t\t\t\t//if( memo.count(pii(x,y)) ) continue;\n\t\t\t\t//if( c > limit ) continue;\n\t\t\t\t//memo[pii(x,y)] = pii(c,d);\n\t\t\t\t//ans = max(ans, c);\n\t\t\t\tif( pii(x,y) == pii(w-1,h-1) ) break;\n\t\t\t\trep(k,4){\n\t\t\t\t\tint nx = x + vx[k];\n\t\t\t\t\tint ny = y + vy[k];\n\t\t\t\t\tint nc = d + 1 + cost[pii(nx,ny)];\n\t\t\t\t\tnc = min(nc, INF);\n\t\t\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n\t\t\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n\t\t\t\t\tif( memo[nx][ny] > pii(nc,d+1) ){\n\t\t\t\t\t\tif( nc <= limit ){\n\t\t\t\t\t\t\tmemo[nx][ny] = pii(nc, d+1);\n\t\t\t\t\t\t\tque.push( {pii(nc, d+1), pii(nx, ny)} );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( memo[w-1][h-1].X < INF ){\n\t\t\t\tr = limit;\n\t\t\t}else{\n\t\t\t\tl = limit;\n\t\t\t}\n\t\t}\n\t\tans = (r<1000 ? r : -1);\n//\t\tpii pos = {w-1,h-1};\n//\t\tans = max(ans, memo[pos].X);\n//\t\twhile( pos != pii(0,0) ){\n//\t\t\tint x = pos.X;\n//\t\t\tint y = pos.Y;\n//\t\t\trep(k,4){\n//\t\t\t\tint nx = x + vx[k];\n//\t\t\t\tint ny = y + vy[k];\n//\t\t\t\tint nc = d + 1 + cost[pii(nx,ny)];\n//\t\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n//\t\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n//\t\t\t\tif( memo.count(pii(nx,ny)) && memo[pii(nx,ny)].Y < memo[pos].Y ){\n//\t\t\t\t\tpos = pii(nx,ny);\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tans = max(ans, memo[pos].X);\n//\t\t}\n\n//\t\tmultimap<int, pii> order;\n//\t\tfor(auto t: memo) order.insert({ t.Y.X, t.X });\n//\t\tUnionFind uf(1000);\n//\t\tfor(auto t: order){\n//\t\t\tint x = t.Y.X;\n//\t\t\tint y = t.Y.Y;\n//\t\t\trep(k,4){\n//\t\t\t\tint nx = x + vx[k];\n//\t\t\t\tint ny = y + vy[k];\n//\t\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n//\t\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n//\t\t\t\tif( memo[pii(nx,ny)].X <= t.X ){\n//\t\t\t\t\tuf.unite( nx+ny*w, x+y*w );\n//\t\t\t\t}\n//\t\t\t}\n////\t\t\tcout << \"order: \" << x << \" \" << y << \" \" << t.X << endl;\n//\t\t\tif( uf.find(0, (w-1)+(h-1)*w ) ){\n//\t\t\t\tans = t.X;\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t}\n\n\t\tcout << (ans >= INF ? -1 : ans) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);++i)\n#define rep(i,n) REP(i, 0, n)\ntypedef pair<int, int> pint;\n\nint H, W;\nstruct Edge { int num, to; Edge(int n, int t) : num(n), to(t) {}};\nvector<vector<Edge>> edges;\nbool bfs(int broken_edge, vector<int>& dist, const vector<vector<Edge>>& edges) {\n    dist[(H - 1) * W + W - 1] = 0;\n    queue<int> que; que.push((H - 1) * W + W - 1);\n    while(!que.empty()) {\n        int cur = que.front(); que.pop();\n        for(const Edge& e : edges[cur]) {\n            if(e.num == broken_edge || dist[e.to] != INF) continue;\n            dist[e.to] = dist[cur] + 1;\n            que.push(e.to);\n        }\n    }\n    return dist[0] == INF;\n}\n\nint solve(const vector<vector<int>>& wdist, const vector<vector<Edge>>& edges) {\n    vector<int> dist(H * W, INF);\n    priority_queue<pint, vector<pint>, greater<pint>> que;\n    dist[(H - 1) * W + W - 1] = 0; que.emplace(0, (H - 1) * W + W - 1);\n    auto upd = [](int& a, int b) { return a > b ? (a = b, true) : false;};\n    while(!que.empty()) {\n        int cos, node;\n        tie(cos, node) = que.top(); que.pop();\n        if(dist[node] < cos) continue;\n        for(const Edge& e : edges[node]) {\n            int ncos = max(cos + 1, wdist[e.num][e.to]);\n            if(upd(dist[e.to], ncos)) que.emplace(ncos, e.to);\n        }\n    }\n    return dist[0];\n}\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    while(cin >> H >> W && H) {\n        int t_, edgenum = 0;\n        vector<vector<Edge>> edges(H * W);\n        rep(i, H) {\n            rep(j, W - 1) {\n                cin >> t_;\n                if(t_ == 0) {\n                    edges[i * W + j].emplace_back(edgenum, i * W + j + 1);\n                    edges[i * W + j + 1].emplace_back(edgenum, i * W + j);\n                    ++edgenum;\n                }\n            }\n            if(i == H - 1) continue;\n            rep(j, W) {\n                cin >> t_;\n                if(t_ == 0) {\n                    edges[i * W + j].emplace_back(edgenum, (i + 1) * W + j);\n                    edges[(i + 1) * W + j].emplace_back(edgenum, i * W + j);\n                    ++edgenum;\n                }\n            }\n        }\n        vector<vector<int>> wdist(edgenum, vector<int>(H * W, INF));\n        rep(i, edgenum) if(bfs(i, wdist[i], edges)) goto fail;\n        cout << solve(wdist, edges) << endl;\n        continue;\n      fail:\n        cout << \"-1\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstdio>\n#include <cstring>\n#include <climits>\nusing namespace std;\n\nconst int dx[] = {0, 1, 0, -1}; //上右下左\nconst int dy[] = {-1, 0, 1, 0};\nconst int inf = 1<<20;\n\nint w,h;\nint block[32][32][4];\nint path[4][32][32]; // 未処理の場合は -1, ゴールできないときは inf\nint dp[900][32][32]; // [step][y][x] 最悪でも500は越えないだろう…\nstring field[70];\n\nstruct state{\n    int x,y;\n    int step;\n    int worstStep;\n    state(int _x, int _y, int s, int w){\n        x = _x;\n        y = _y;\n        step = s;\n        worstStep = w;\n    }\n    bool operator<(const state& a)const{\n        if( worstStep == a.worstStep ) return step > a.step;\n        return worstStep > a.worstStep;\n    }\n};\n\n\ninline bool inside(int x, int y){\n    return !( x < 0 || x >= 2*w-1 || y >= 2*h-1 || y < 0 );\n}\n\n\nint bfs(int sx, int sy, int gx, int gy){\n    int k;\n    char memo[32][32];\n    queue<pair<int,int> > q;\n\n    memset(memo, -1, sizeof(memo));\n    q.push(make_pair(sx,sy));\n    memo[sy][sx] = 0;\n\n    if( sx == gx && sy == gy ) return 0;\n\n    while( !q.empty() ){\n        int x = q.front().first;\n        int y = q.front().second;\n        int s = memo[y][x];\n        q.pop();\n\n        for(k=0; k<4; k++){\n            int nx = x + dx[k], ny = y + dy[k];\n            if( !block[y][x][k] && memo[ny][nx] == -1 ){\n                memo[ny][nx] = s + 1;\n                if( gy == ny && gx == nx ){\n                    return s + 1;\n                }\n                q.push(make_pair(nx, ny));\n            }\n        }\n    }\n    \n    return inf;\n}\n\nbool isCut(int step, int x, int y, int nextWorstStep){\n    int i;\n    for(i=0; i<=step; i++) if( dp[i][y][x] <= nextWorstStep ) break;\n    return (i > step);\n}\n\nint solve(){\n    int i,k;\n    int cutOff = inf; // 枝刈り用\n    priority_queue<state> q;\n    q.push(state(0,0,0,0));\n\n    while( !q.empty() ){\n        int x = q.top().x;\n        int y = q.top().y;\n        int step = q.top().step;\n        int wstep = q.top().worstStep;\n        q.pop();\n\n        if( step > 900 ) break;\n\n        if( dp[step][y][x] <= wstep ) continue;\n        dp[step][y][x] = wstep;\n\n        if( y == h-1 && x == w-1 ) return dp[step][h-1][w-1];\n\n        \n        if( cutOff <= wstep ) continue;\n\n        for(k=0; k<4; k++){\n            if( block[y][x][k] ) continue;\n                \n            // ドアが壊れてたときの計算\n            int nextWorstStep = inf;\n\n            // まだBFSで調べてないので調べる\n            if( path[k][y][x] == -1 ){\n                block[y][x][k] = 1;\n                path[k][y][x] = bfs(x, y, w-1, h-1);\n                block[y][x][k] = 0;\n            }\n\n            if( path[k][y][x] == inf ) continue; // ゴールできない\n\n            nextWorstStep = max(wstep, step + path[k][y][x]);\n\n            // step + 1以下の最小値管理をうまくしないと、上で枝刈りしても、ここでキューに突っ込んでるからlogn時間遅くなる\n            // ここをO(1)にしたい、むきー\n            if( isCut(step + 1, x + dx[k], y + dy[k], nextWorstStep) ){\n                q.push(state(x + dx[k], y + dy[k], step + 1, nextWorstStep));\n\n                \n                // 仮に移動先がゴールだった場合、枝狩り変数を持つことができる\n                if( y + dy[k] == h-1 && x + dx[k] == w-1 ){\n                    cutOff = min(cutOff, nextWorstStep);\n                }\n            }\n        }\n    }\n    return -1;\n}\n\n\n\nint main(){\n    int i,j,k;\n\n    while( cin >> h >> w, h|w ){\n        cin.ignore();\n\n        // input\n        for(i=0; i<2*h-1; i++){\n            getline(cin, field[i]);\n            if( i % 2 == 0 ) field[i] += \" \";\n        }\n        fill(&dp[0][0][0], &dp[0][0][0] + 900*32*32, inf);\n        memset(path, -1, sizeof(path));\n\n        // 通れない場所を予め調べておく\n        for(i=0; i<h; i++){\n            for(j=0; j<w; j++){\n                for(k=0; k<4; k++){\n                    int tx = 2*j + dx[k];\n                    int ty = 2*i + dy[k];\n                    if( !inside(tx, ty) || field[ty][tx] == '1' ){\n                        block[i][j][k] = 1;\n                    }\n                    else{\n                        block[i][j][k] = 0;\n                    }\n                }\n            }\n        }\n        cout << solve() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef tuple<int,int,int> tpl;\n\nint H, W;\nint A[2][31][31];\n\nconst int dy[] = {-1, 0, 0, 1};\nconst int dx[] = {0, -1, 1, 0};\nint from_goal_distance[2][31][31][31][31];\nint ans[31][31];\nconst int INF = 1 << 29;\n\n// cy,cx??????ang????§????????????¨????????????????£????index????¨????\ntpl get_index(int cy, int cx, int ang){\n  int ny = dy[ang] + cy;\n  int nx = dx[ang] + cx;\n  if(ny >= 0 && nx >= 0 && ny < H && nx < W){\n    if(dx[ang] > 0) return make_tuple(0, cy, cx);\n    else if(dx[ang] < 0) return make_tuple(0, cy, cx-1);\n    else if(dy[ang] > 0) return make_tuple(1, cy, cx);\n    else return make_tuple(1, cy-1, cx);\n  }\n  return make_tuple(-1,-1,-1);\n}\n\n// ?§??????????????????????\nbool is_move(int cy, int cx, int k){\n  tpl t = get_index(cy,cx,k);\n  if(get<0>(t)==-1)return false;\n  // ?£???????\n  return !(A[get<0>(t)][get<1>(t)][get<2>(t)]);\n}\n\nvoid bfs(int sy, int sx, int d[31][31]){\n  for(int i = 0; i < H; i++)\n    for(int j = 0; j < W; j++)\n      d[i][j] = INF;\n  queue<pii> q;\n  q.push(pii(sy, sx));\n  d[sy][sx] = 0;\n  while(q.size()){\n    pii p = q.front(); q.pop();\n    int cy = p.first;\n    int cx = p.second;\n    int ccost = d[cy][cx];\n    for(int i = 0; i < 4; i++){\n      if(is_move(cy, cx, i)){\n        int ny = cy + dy[i];\n        int nx = cx + dx[i];\n        if(d[ny][nx] == INF){\n          q.push(pii(ny,nx));\n          d[ny][nx] = ccost + 1;\n        }\n      }\n    }\n  }\n}\n\nvoid dijkstra(int sy, int sx, int d[31][31]){\n  for(int i = 0; i < H; i++)\n    for(int j = 0; j < W; j++)\n      d[i][j] = INF;\n  priority_queue<pair<int, pii>, vector<pair<int, pii> >, greater<pair<int, pii> > > pq;\n  d[sy][sx] = 0;\n  pq.push(make_pair(0, pii(sy, sx)));\n  while(pq.size()){\n    pair<int, pii> p = pq.top(); pq.pop();\n    int ccost = p.first;\n    int cy = p.second.first;\n    int cx = p.second.second;\n    if(d[cy][cx] < ccost) continue;\n    for(int i = 0; i < 4; i++){\n      if(is_move(cy, cx, i)){\n        int ny = cy + dy[i];\n        int nx = cx + dx[i];\n        // ?????¨?????´?????????1?????????????????????????????¨, (ny,nx)??????goal?????§????????????????????§????????????\n        tpl t = get_index(cy, cx, i);\n        int ncost = max(ccost + 1, from_goal_distance[get<0>(t)][get<1>(t)][get<2>(t)][ny][nx]);\n        if(d[ny][nx] > ncost){\n          d[ny][nx] = ncost;\n          pq.push(make_pair(ncost, pii(ny, nx)));\n        }\n      }\n    }\n  }\n}\n\nint main(){\n\n  while(cin>>H>>W && (H|W)){\n    for(int i = 0; i < 2 * H - 1; i++){\n      int *ary = A[i%2][i/2];\n      for(int j = 0; j < W - ((i % 2) == 0); j++) cin>>ary[j];\n    }\n    // ?????´???????£???????????????????????????????????¨????\n    for(int i = 0; i < 2 * H - 1; i++){\n      for(int j = 0; j < W - ((i % 2) == 0); j++){\n        // ?£????????????´???, ?£????switching\n        if(A[i%2][i/2][j] == 0){\n          A[i%2][i/2][j] ^= 1;\n          bfs(H-1, W-1, from_goal_distance[i%2][i/2][j]);\n          A[i%2][i/2][j] ^= 1;\n        }\n        else{\n          bfs(H-1, W-1, from_goal_distance[i%2][i/2][j]);\n        }\n      }\n    }\n    // ??´????????????dijkstra?????????????§£????¨????\n    dijkstra(H-1, W-1, ans); \n    if(ans[0][0] == INF)cout<<-1<<endl;\n    else cout<<ans[0][0]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n\n#define MAXN 30\n#define MAXNN 900\n#define INF 999999999\n\nusing namespace std;\n\nint minDis2(int array[MAXNN][MAXNN],int s, int t){\n\t\n\tint min[MAXNN][MAXNN];\n\tfor(int i=0;i<MAXNN;i++){\n\t\tfor(int j=0;j<MAXNN;j++){\n\t\t\tmin[i][j]=INF;\n\t\t}\n\t}\n\tint count;\n\tint parent[MAXNN];\n\tbool flg[MAXNN];\n\tqueue<int> st;\n\tparent[s]=-1;\n\tst.push(s);\n\tflg[s]=true;\n\tint p;\n\tfor(int i=0;i<MAXNN;i++) flg[i]=false;\n\twhile(!st.empty()){\n\t\tp=st.front();\n\t\tst.pop();\n\t\tmin[s][p]=(parent[p]+1);\n\t\tfor(int i=0;i<MAXNN;i++){\n\t\t\tif(array[p][i]==1 && !flg[i]){\n\t\t\t\tflg[i]=true;\n\t\t\t\tst.push(i);\n\t\t\t\tparent[i]=parent[p]+1;\n\t\t\t}\n\t\t}\n\t}\n\treturn min[s][t];\n}\n/*void minDis(int array[MAXNN][MAXNN],int mins[MAXNN][MAXNN],int s){\n\tint count;\n\tint parent[MAXNN];\n\tbool flg[MAXNN];\n\tqueue<int> st;\n\tparent[s]=-1;\n\tst.push(s);\n\tflg[s]=true;\n\tint p;\n\tfor(int i=0;i<MAXNN;i++) flg[i]=false;\n\twhile(!st.empty()){\n\t\tp=st.front();\n\t\tst.pop();\n\t\tmins[s][p]=(parent[p]+1);\n\t\tfor(int i=0;i<MAXNN;i++){\n\t\t\tif(array[p][i]==1 && !flg[i]){\n\t\t\t\tflg[i]=true;\n\t\t\t\tst.push(i);\n\t\t\t\tparent[i]=parent[p]+1;\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\n*/\nint solve(int array[MAXNN][MAXNN],int s,int t){\n\tint res=0;\n\tint mx=0;\n\tint mmx=0;\n\tint tmp,d,g;\n\tint f_mx,s_mx;\n\tint f_mmx,s_mmx;\n\tint qt[2];\n\tint dqt[2][2];\n\tint resres=INF;\n\tint deg[MAXNN];\n\n\tvector< pair<int,int> > p;\n\tpair<int,int> pp;\n\t\n\tdqt[0][0]=s;\n\tdqt[0][1]=t;\n\n\tres=INF;\n\twhile(mmx<INF){\n\t\tmmx=0;\n\t\tf_mmx=0;\n\t\ts_mmx=0;\n\t\tfor(int i=0;i<MAXNN;i++){\n\t\t\tdeg[i]=0;\n\t\t\tfor(int j=0;j<MAXNN;j++){\n\t\t\t\tdeg[i]+=array[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor(int m=0;m<MAXNN;m++){\n\t\t\tif(s==m || t==m && deg[m]<=1) d=INF;//sがmかtがmならs->mの最短路をINFにする\n\t\t\telse d=minDis2(array,s,m); //s->mの最短路\n\n\t\t\tif(d<INF){//s->mの最短路があるとき\n\t\t\t\tmx=0;//s->mに行き，どこか一箇所通れない場合にm->tで迂回した場合の最短路の最大\n\t\t\t\tf_mx=0;\n\t\t\t\ts_mx=0;\n\t\t\t\tfor(int j=0;j<MAXNN;j++){//隣接行列を操作\n\t\t\t\t\tif(j!=s && array[m][j]==1){//jが始点でなく，mとjが隣接するなら\n\t\t\t\t\t\tarray[m][j]=0; \t\tarray[j][m]=0;//一旦jまで到達するドアを壊す\n\t\t\t\t\t\tg=minDis2(array,m,t);//ドアを壊した上でのmからtまでの最短距離を求める\n\t\t\t\t\t\tarray[m][j]=1;\t\tarray[j][m]=1;//一旦壊したドアを戻す\n\t\n\t\t\t\t\t\tif(d+g>mx){//d+gが暫定の最短路の最大よりも大きいなら\n\t\t\t\t\t\t\tmx=d+g;//最大値を更新\n\t\t\t\t\t\t\tf_mx=m;//最大値になるようなPairを定義する．\n\t\t\t\t\t\t\ts_mx=j;\n\t//\t\t\t\t\t\tprintf(\"mx=%d,[%d][%d]\\n\",mx,f_mx,s_mx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//あるmでの最大値が mx\n\t\t\t\t//その時の f_m,s_m がm経由時の最大値のときの\n\t\t\t\tif(mx>mmx){\n\t\t\t\t\tmmx=mx;\n\t\t\t\t\tf_mmx=f_mx;\n\t\t\t\t\ts_mmx=s_mx;\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n//\t\tprintf(\"mmx=%d,array[%d][%d]=%d\\n\",mmx,f_mmx,s_mmx,array[f_mmx][s_mmx]);\n\n\t\tpp.first=f_mmx;\n\t\tpp.second=s_mmx;\n\n\t\tarray[f_mmx][s_mmx]=0;\n\t\tarray[s_mmx][f_mmx]=0;\n\t\tp.push_back(pp);\n\n\t\tres=min(res,mmx);\n\t}\n\n\tmx=INF;\n\tfor(int i=0;i<p.size();i++){\n\t\tarray[p[i].first][p[i].second]=1;\n\t\tarray[p[i].second][p[i].first]=1;\n\t}\n\tfor(int i=0;i<p.size();i++){\n\t\tarray[p[i].first][p[i].second]=0;\n\t\tarray[p[i].second][p[i].first]=0;\n\n\t\tmx=min(mx,minDis2(array,s,p[i].first)+minDis2(array,p[i].first,t));\n\n\t\tarray[p[i].first][p[i].second]=1;\n\t\tarray[p[i].second][p[i].first]=1;\n\t}\n\tif(mx==INF) mx=-1;\n\t\n\treturn mx;\n}\n\nint main(void){\n\tint h,w;\n\tint array[MAXNN][MAXNN];\n//\tint minss[MAXNN][MAXNN];\n\tint deg[MAXNN];\n\tint fx[4] = {-1,1,0,0};\n\tint fy[4] = {0,0,-1,1};\n\tint p;\n\n\twhile(true){\n\t\tfor(int i=0;i<MAXNN;i++){\n\t\t\tfor(int j=0;j<MAXNN;j++){\n//\t\t\t\tminss[i][j]=-1;\n\t\t\t\tarray[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tcin >> h;\n\t\tif(h==0) return 0;\n\t\tcin >> w;\n\t\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\n\t\t\t\tfor(int a=0;a<4;a++){\n\t\t\t\t\tif((x+fx[a])>=0 && (x+fx[a])<w && (y+fy[a])>=0 && (y+fy[a])<h){\n\t\t\t\t\t\tarray[(30*y+x)][30*(y+fy[a])+(x+fx[a])]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(int y=0;y<h*2-1;y++){\n\t\t\tfor(int x=0;x<w-((y+1)%2);x++){\n\t\t\t\tcin >> p;\n\t\t\t\tif(p==1){\n\t\t\t\t\tif(y%2==0){\n\t\t\t\t\t\tarray[((y/2)*30+x)][((y/2)*30+x+1)]=0;\n\t\t\t\t\t\tarray[((y/2)*30+x+1)][((y/2)*30+x)]=0;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tarray[((y/2)*30+x)][(((y/2)+1)*30+x)]=0;\n\t\t\t\t\t\tarray[(((y/2)+1)*30+x)][((y/2)*30+x)]=0;\n\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<MAXNN;i++){\n\t\t\tdeg[i]=0;\n\t\t\tfor(int j=0;j<MAXNN;j++){\n\t\t\t\tdeg[i]+=array[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<MAXNN;i++){\n\t\t\tif(deg[i]==1 && i!=(h-1)*MAXN+(w-1)){\n\t\t\t\tfor(int j=0;j<MAXNN;j++){\n\t\t\t\t\tif(array[i][j]==1){\n\t\t\t\t\t\tdeg[i]--;\n\t\t\t\t\t\tdeg[j]--;\n\t\t\t\t\t\tarray[i][j]=0;\n\t\t\t\t\t\tarray[j][i]=0;\n\t\t\t\t\t\tif(i>j){\n\t\t\t\t\t\t\ti=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(deg[(h-1)*MAXN+(w-1)]==1) cout << -1 << endl;\n\t\telse cout << solve(array,0,(h-1)*MAXN+(w-1)) << endl;\n\t\t/*\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(deg[i*MAXN+j]==2) cout << \"*\";\n\t\t\t\telse cout << \" \";\n\t\t\t\tprintf(\"%2d \",mins[0][i*(MAXN)+j]);\n\t\t\t}cout << endl;\n\t\t}\n\t\t*/\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <utility>\n#define INF 2000\nusing namespace std;\ntypedef pair<int,int> P;\n\nstruct data{\n\tint x,y,c,dc;\n\tdata(int xx,int yy,int cc,int dd){\n\t\tx=xx;\n\t\ty=yy;\n\t\tc=cc;\n\t\tdc=dd;\n\t}\n\n\tbool operator<(const data& d1)const{\n\t\treturn d1.c<c;\n\t}\n};\n\nint h,w;\n\nint fie[61][61];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint dp[61][61][901];\nint cost[61][61][4];\nint used[61][61];\n\nint bfs(int sx,int sy){\n\tqueue<P> que;\n\tque.push(P(sx,sy));\n\tmemset(used,-1,sizeof(used));\n\tused[sx][sy]=0;\n\twhile(que.size()){\n\t\tP q=que.front();\n\t\tque.pop();\n\t\tint x=q.first,y=q.second;\n\t\tif(x==(w-1)*2 && y==(h-1)*2)return used[x][y];\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\tif(nx>=0 && nx<w*2-1 && ny>=0 && ny<h*2-1){\n\t\t\t\tif(fie[nx][ny]==1)continue;\n\t\t\t\tnx+=dx[i];\n\t\t\t\tny+=dy[i];\n\t\t\t\tif(used[nx][ny]==-1){\n\t\t\t\t\tused[nx][ny]=used[x][y]+1;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn INF;\n}\n\nint dijk(){\n\tpriority_queue<data> que;\n\tque.push(data(0,0,0,0));\n\tfor(int i=0;i<=60;i++){\n\t\tfor(int j=0;j<=60;j++){\n\t\t\tfor(int k=0;k<=900;k++){\n\t\t\t\tdp[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tque.push(data(0,0,0,0));\n\tdp[0][0][0]=0;\n\twhile(que.size()){\n\t\tdata d=que.top();\n\t\tque.pop();\n\t\tif(dp[d.x][d.y][d.c]!=d.dc)continue;\n\t\tif(d.x==(w-1)*2 && d.y==(h-1)*2)return d.dc;\n\t\t//printf(\"%d %d %d %d\\n\",d.x,d.y,d.c,d.dc);\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(cost[d.x][d.y][i]==INF)continue;\n\t\t\tint nx=d.x+dx[i]*2,ny=d.y+dy[i]*2;\n\t\t\tif(nx>=0 && nx<w*2-1 && ny>=0 && ny<h*2-1){\n\t\t\t\tint ndc=max(d.dc,cost[d.x][d.y][i]+d.c);\n\t\t\t\tndc=max(ndc,d.c+1);\n\t\t\t\tif(dp[nx][ny][d.c+1]>ndc && d.c<900){\n\t\t\t\t\tdp[nx][ny][d.c+1]=ndc;\n\t\t\t\t\tque.push(data(nx,ny,d.c+1,ndc));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tif(h==0 && w==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<2*h-1;i++){\n\t\t\tif(i%2==0){\n\t\t\t\tfor(int j=0;j<w-1;j++){\n\t\t\t\t\tscanf(\"%d\",&fie[j*2+1][i]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tscanf(\"%d\",&fie[j*2][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<2*h-1;i+=2){\n\t\t\tfor(int j=0;j<w*2;j+=2){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint x=j+dx[k],y=i+dy[k];\n\t\t\t\t\tif(x>=0 && x<w*2-1 && y>=0 && y<w*2-1){\n\t\t\t\t\t\tif(fie[x][y]==0){\n\t\t\t\t\t\t\tfie[x][y]=1;\n\t\t\t\t\t\t\tcost[j][i][k]=bfs(j,i);\n\t\t\t\t\t\t\tfie[x][y]=0;\n\t\t\t\t\t\t}else cost[j][i][k]=INF;\n\t\t\t\t\t}else cost[j][i][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n#define mp make_pair\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nstruct node {\n    int w, x, y;\n    node(int w, int x, int y) : w(w), x(x), y(y) {}\n};\ninline bool operator<(const node& l, const node& r) {\n    return l.w!=r.w ? l.w<r.w : l.x!=r.x ? l.x<r.x : l.y<r.y;\n}\n\nint H, W;\nint m, wall[32][32][4], bcost[2000][32][32], dp[2000][32][32];\n\nvoid dfs(int sx, int sy, int br) {\n    memset(bcost[br], -1, sizeof(bcost[br]));\n    queue<node> q;\n    q.push(node(0, sx, sy));\n    bcost[br][sx][sy] = 0;\n    while(!q.empty()) {\n        const node v(q.front());\n        q.pop();\n        rep(d, 4) if(wall[v.x][v.y][d]>=0 && wall[v.x][v.y][d]!=br) {\n            const int nx = v.x+dx[d], ny = v.y+dy[d];\n            if(bcost[br][nx][ny]!=-1) continue;\n            q.push(node(v.w+1, nx, ny));\n            bcost[br][nx][ny] = v.w+1;\n        }\n    }\n}\n\nint solve() {\n    memset(dp, -1, sizeof(dp));\n    priority_queue<pair<int, node> > q;\n    q.push(mp(0, node(0, 0, 0)));\n    while(!q.empty()) {\n        const pair<int, node> vv(q.top());\n        q.pop();\n        const int c = -vv.first;\n        const int w = vv.second.w, x = vv.second.x, y = vv.second.y;\n        if(dp[w][x][y]!=-1) continue;\n        dp[w][x][y] = c;\n        if(x==H-1 && y==W-1) return c;\n        rep(d, 4) if(wall[x][y][d]>=0) {\n            const int nx = x+dx[d], ny = y+dy[d];\n            if(dp[w+1][nx][ny]!=-1) continue;\n            const int wk = wall[x][y][d];\n            if(bcost[wk][x][y]!=-1) {\n                const int nc = max(c, w+bcost[wk][x][y]);\n                q.push(mp(-nc, node(w+1, nx, ny)));\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    for(;;) {\n        scanf(\"%d%d\", &H, &W);\n        if(H==0 && W==0) return 0;\n        memset(wall, -1, sizeof(wall));\n        m = 0;\n        rep(i, 2*H-1) {\n            int ex;\n            if(i%2==0) rep(j, W-1) {\n                scanf(\"%d\", &ex);\n                wall[i/2][j][1] = wall[i/2][j+1][3] = ex ? -1 : m;\n                if(ex==0) m++;\n            }\n            else rep(j, W) {\n                scanf(\"%d\", &ex);\n                wall[i/2][j][0] = wall[i/2+1][j][2] = ex ? -1 : m;\n                if(ex==0) m++;\n            }\n        }\n        rep(i, m) dfs(H-1, W-1, i);\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint dist[128][128], dist2[128][128], cost[128][128];\nint dy[] = {0, 1, 0, -1}, dx[] = {1, 0, -1, 0};\nint mp[128][128];\n\nvoid bfs(int sy, int sx, int dist[][128])\n{\n    queue<pair<int, int>> q;\n    q.push(make_pair(sy, sx));\n\n    for (int i = 0; i < 128; i++){\n        fill(dist[i], dist[i] + 128, 1000000000);\n    }\n\n    dist[sy][sx] = 0;\n\n    while (q.size()){\n        pair<int, int> x = q.front(); q.pop();\n\n        for (int i = 0; i < 4; i++){\n            pair<int, int> nx = make_pair(x.first + dy[i], x.second + dx[i]);\n            if (nx == make_pair(sy, sx) || dist[nx.first][nx.second] != 1000000000) continue;\n            if (!mp[nx.first][nx.second]){\n                dist[nx.first][nx.second] = dist[x.first][x.second] + 1;\n                q.push(nx);\n            }\n        }\n    }\n}\n\nbool ok(int m, int h, int w)\n{\n    int c[128][128];\n\n    for (int i = 0; i < 128; i++) fill(c[i], c[i] + 128, 1000000000);\n\n    queue<pair<int, int>> q;\n    q.push(make_pair(1, 1));\n    c[1][1] = 0;\n\n    while (q.size()){\n        pair<int, int> x = q.front(); q.pop();\n\n        for (int i = 0; i < 4; i++){\n            pair<int, int> nx = make_pair(x.first + dy[i], x.second + dx[i]);\n            if (mp[nx.first][nx.second]) continue;\n            if (nx == make_pair(1, 1) || c[nx.first][nx.second] != 1000000000) continue;\n            if (c[x.first][x.second] + 1 + cost[nx.first][nx.second] <= 2 * m){\n                c[nx.first][nx.second] = c[x.first][x.second] + 1;\n                q.push(nx);\n            }\n        }\n    }\n\n    return (c[2 * h - 1][2 * w - 1] <= 2 * m);\n}\n\nint main()\n{\n    int h, w;\n\n    while (scanf(\"%d %d\", &h, &w) && h){\n        memset(mp, 0, sizeof(mp));\n        for (int i = 0; i < 2 * h + 1; i++){\n            for (int j = 0; j < 2 * w + 1; j++){\n                mp[i][j] = !((i % 2) && (j % 2));\n            }\n        }\n\n        for (int i = 1; i < 2 * h; i++){\n            for (int j = 0; j < w - (i % 2); j++){\n                scanf(\"%d\", &mp[i][2 * j + 1 + (i % 2)]);\n            }\n        }\n\n        bfs(1, 1, dist);\n\n        if (dist[2 * h - 1][2 * w - 1] == 0){\n            printf(\"-1\\n\");\n            continue;\n        }\n\n        memset(cost, 0, sizeof(cost));\n\n        for (int i = 1; i < 2 * h; i++){\n            for (int j = 0; j < w - (i % 2); j++){\n                int ny = i, nx = 2 * j + 1 + (i % 2);\n                if (mp[ny][nx]) continue;\n                mp[ny][nx] = 1;\n                if (i % 2){\n                    bfs(ny, nx - 1, dist2);\n                    cost[ny][nx - 1] = max(cost[ny][nx - 1], dist2[2 * h - 1][2 * w - 1]);\n                    bfs(ny, nx + 1, dist2);\n                    cost[ny][nx + 1] = max(cost[ny][nx + 1], dist2[2 * h - 1][2 * w - 1]);\n                }\n                else {\n                    bfs(ny - 1, nx, dist2);\n                    cost[ny - 1][nx] = max(cost[ny - 1][nx], dist2[2 * h - 1][2 * w - 1]);\n                    bfs(ny + 1, nx, dist2);\n                    cost[ny + 1][nx] = max(cost[ny + 1][nx], dist2[2 * h - 1][2 * w - 1]);\n                }\n                mp[ny][nx] = 0;\n            }\n        }\n\n        int l = 0, r = 2 * h * w + 1;\n\n        while (l != r){\n            int mid = (l + r) / 2;\n\n            if (ok(mid, h, w)) r = mid;\n            else l = mid + 1;\n        }\n\n        printf(\"%d\\n\", l > 2 * h * w ? -1 : l);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 100000000;\n\nint h, w;\nvector<int> e[1000];\nvector<int> c[1000];\nint dis[1000];\n\nvoid dfs (int v, int ev, int ed) {\n    fill(dis, dis+h*w, INF);\n    queue<int> que;\n    que.push(v);\n    dis[v] = 0;\n    while (!que.empty()) {\n        int q = que.front(); que.pop();\n        rep(i,e[q].size()) {\n            if (q == ev && i == ed) continue;\n            if (dis[e[q][i]] != INF) continue;\n            dis[e[q][i]] = dis[q]+1;\n            que.push(e[q][i]);\n        }\n    }\n}\n\nvoid dfs2 (int v, int x) {\n    fill(dis, dis+h*w, INF);\n    queue<int> que;\n    que.push(v);\n    dis[v] = 0;\n    while (!que.empty()) {\n        int q = que.front(); que.pop();\n        rep(i,e[q].size()) {\n            if (dis[e[q][i]] != INF) continue;\n            if (dis[q]+c[q][i] > x) continue;\n            dis[e[q][i]] = dis[q]+1;\n            que.push(e[q][i]);\n        }\n    }\n}\n\nvoid solve() {\n    rep(i,h) {\n        int b;\n        rep(j,w-1) {\n            cin >> b;\n            if (b == 0) {\n                e[i*w+j].push_back(i*w+j+1);\n                e[i*w+j+1].push_back(i*w+j);\n            }\n        }\n        if (i == h-1) break;\n        rep(j,w) {\n            cin >> b;\n            if (b == 0) {\n                e[i*w+j].push_back((i+1)*w+j);\n                e[(i+1)*w+j].push_back(i*w+j);\n            }\n        }\n    }\n    rep(i,h*w) {\n        rep(j,e[i].size()) {\n            dfs(i, i, j);\n            c[i].push_back(dis[h*w-1]);\n        }\n    }\n    int st = 0, en = 10000, mid;\n    while (en-st > 1) {\n        mid = (st + en) / 2;\n        dfs2(0, mid);\n        if (dis[h*w-1] == INF) {\n            st = mid;\n        } else {\n            en = mid;\n        }\n    }\n    if (en == 10000) en = -1;\n    cout << en << endl;\n}\n\nint main() {\n    while (cin >> h >> w) {\n        if (h == 0 && w == 0) break;\n        rep(i,h) rep(j,w) e[i*w+j].clear();\n        rep(i,h) rep(j,w) c[i*w+j].clear();\n        solve();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,m;\nbool ok[35][35][4];\nint d[35][35][4];\nint main(){\n\twhile(1){\n\t\tmemset(ok,0,sizeof(ok));\n\t\tcin >> n >> m; if(n==0) return 0;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tok[1][i][0] = 0;\n\t\t\tok[n][i][2] = 0;\n\t\t}\n\t\tok[1][1][0] = ok[n][m][2] = 1;\n\t\t\n\t\tfor(int i=1;i<=2*n-1;i++){\n\t\t\tif(i%2 == 1){\n\t\t\t\tok[i/2+1][1][3] = 0;\n\t\t\t\tfor(int j=1;j<m;j++){\n\t\t\t\t\tint x; cin >> x;\n\t\t\t\t\tok[i/2+1][j][1] = ok[i/2+1][j+1][3] = 1-x;\n\t\t\t\t}\n\t\t\t\tok[i/2+1][m][1] = 0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\t\tint x; cin >> x;\n\t\t\t\t\tok[i/2][j][2] = ok[i/2+1][j][0] = 1-x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(1<=i+dx[k]&&i+dx[k]<=n&&1<=j+dy[k]&&j+dy[k]<=m&&ok[i][j][k]);\n\t\t\t\t\telse{\n\t\t\t\t\t\td[i][j][k] = -1; continue;\n\t\t\t\t\t}//cout << i << \" \" << j  << \" \" << k << endl;\n\t\t\t\t\tqueue<P>que; bool used[35][35]={}; int dist[35][35];\n\t\t\t\t\t//(i,j)-(i+dx[k],j+dy[k]) is forbid\n\t\t\t\t\tfor(int i=0;i<35;i++) for(int j=0;j<35;j++) dist[i][j] = INF;\n\t\t\t\t\tque.push(mp(i,j)); dist[i][j] = 0;\n\t\t\t\t\twhile(!que.empty()){\n\t\t\t\t\t\tP p = que.front(); que.pop();\n\t\t\t\t\t\tif(used[p.fi][p.sc]) continue;\n\t\t\t\t\t\tused[p.fi][p.sc] = 1;\n\t\t\t\t\t\tfor(int q=0;q<4;q++){\n\t\t\t\t\t\t\tif(1<=p.fi+dx[q]&&p.fi+dx[q]<=n&&1<=p.sc+dy[q]&&p.sc+dy[q]<=m&&ok[p.fi][p.sc][q]){\n\t\t\t\t\t\t\t    //cout << p.fi+dx[q] << \" \" << p.sc+dy[q] << \"g \" << k << endl;\n\t\t\t\t\t\t\t\tif(p == mp(i,j) && q == k) continue;\n\t\t\t\t\t\t\t\tif(p == mp(i+dx[k],j+dy[k]) && (q^2) == k) continue;\n\t\t\t\t\t\t\t\tif(used[p.fi+dx[q]][p.sc+dy[q]]) continue;\n\t\t\t\t\t\t\t\tdist[p.fi+dx[q]][p.sc+dy[q]] = min(dist[p.fi+dx[q]][p.sc+dy[q]],dist[p.fi][p.sc]+1);\n\t\t\t\t\t\t\t\tque.push(mp(p.fi+dx[q],p.sc+dy[q]));\n\t\t\t\t\t\t\t\t//cout << p.fi+dx[q] << \" \" << p.sc+dy[q] << endl;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\td[i][j][k] = (dist[n][m]>1e8?-1:dist[n][m]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint lb = 0,ub = 2000;\n\t\twhile(ub-lb > 1){\n\t\t\tint mid = (lb+ub)/2;\n\t\t\tint D[35][35];\n\t\t\tfor(int i=0;i<35;i++) for(int j=0;j<35;j++) D[i][j] = INF;\n\t\t\tD[1][1] = 0;\n\t\t\tqueue<P>que; bool used[35][35]={};\n\t\t\tque.push(mp(1,1));\n\t\t\twhile(!que.empty()){\n\t\t\t\tP p = que.front(); que.pop();\n\t\t\t\tif(used[p.fi][p.sc]) continue;\n\t\t\t\tused[p.fi][p.sc] = 1;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(d[p.fi][p.sc][k] == -1) continue;\n\t\t\t\t\tif(D[p.fi][p.sc]+d[p.fi][p.sc][k] > mid) continue;\n\t\t\t\t\tint X = p.fi+dx[k],Y = p.sc+dy[k];\n\t\t\t\t\tif(used[X][Y]) continue;\n\t\t\t\t\tD[X][Y] = min(D[X][Y],D[p.fi][p.sc]+1);\n\t\t\t\t\tque.push(mp(X,Y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(D[n][m] <= mid) ub = mid;\n\t\t\telse lb = mid;\n\t\t}\n\t\tcout << (ub>1900?-1:ub) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n#include <valarray>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++)\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nint popcnt(unsigned long long a) {\n#ifndef _MSC_VER\n\treturn __builtin_popcountll(a);\n#else\n\treturn _mm_popcnt_u32(a >> 32) + _mm_popcnt_u32(a);\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n#endif\n}\nint bitscanf(unsigned long a) {\n#ifndef _MSC_VER\n\treturn __builtin_ctz(a);\n#else\n\t_BitScanForward(&a, a);\n\treturn a;\n#endif\n}\ntemplate<class T>\nclass matrix {\npublic:\n\tvector<valarray<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, valarray<T>(e, m == -1 ? n : m)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)ret[i] += obj[i][j] * p.obj[j];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tbool operator==(const matrix&p) {\n\t\tif (s != p.s)return 0;\n\t\trep(i, s.first)rep(j, s.second)if (obj[i][j] != p.obj[i][j])return 0;\n\t\treturn 1;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\tvalarray<T>& operator[](int t) {\n\t\treturn obj[t];\n\t}\n\tvoid gauss() {\n\t\tif (size().first + 1 != size().second)return;\n\t\trep(i, size().first) {\n\t\t\tint p = i;\n\t\t\trepi(j, i, size().first)if (abs(obj[j][i]) > abs(obj[p][i]))p = j;\n\t\t\tswap(obj[i], obj[p]);\n\t\t\tif (abs(obj[i][i]) < 1e-8)return;//contniue;\n\t\t\trepi(j, i + 1, size().second)obj[i][j] /= obj[i][i];\n\t\t\trep(j, size().first) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\trepi(k, i + 1, size().second)obj[j][k] -= obj[j][i] * obj[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned long long exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (res.obj[0].size() > 100) {\n\t\t\tint a=0;\n\t\t}\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned long long exp, ll m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (res.obj[0].size() > 100) {\n\t\t\tint a = 0;\n\t\t}\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint h, w;\n\twhile (cin >> h >> w, h) {\n\t\tvector<vi> x(w - 1, vi(h)), y(w, vi(h - 1));\n\t\trep(j, h) {\n\t\t\trep(i, w - 1)cin >> x[i][j];\n\t\t\tif (j == h - 1)break;\n\t\t\trep(i, w)cin >> y[i][j];\n\t\t}\n\t\tvector<vi> dp0(w, vi(h, 1e9)), dp1(w, vi(h, 1e9)), dp2(w, vi(h)), dp3(w, vi(h, 1e9));\n\t\tdp3[0][0] = 0;\n\t\t{\n\t\t\tqueue<pii> q;\n\t\t\tq.push(pii(0,0));\n\t\t\twhile (!q.empty()) {\n\t\t\t\tauto a = q.front(); q.pop();\n\t\t\t\tif (a.first > 0 && x[a.first - 1][a.second] == 0 && dp3[a.first][a.second] + 1 < dp3[a.first - 1][a.second]) {\n\t\t\t\t\tdp3[a.first - 1][a.second] = dp3[a.first][a.second] + 1;\n\t\t\t\t\tq.emplace(a.first - 1, a.second);\n\t\t\t\t}\n\t\t\t\tif (a.first < w - 1 && x[a.first][a.second] == 0 && dp3[a.first][a.second] + 1 < dp3[a.first + 1][a.second]) {\n\t\t\t\t\tdp3[a.first + 1][a.second] = dp3[a.first][a.second] + 1;\n\t\t\t\t\tq.emplace(a.first + 1, a.second);\n\t\t\t\t}\n\t\t\t\tif (a.second > 0 && y[a.first][a.second - 1] == 0 && dp3[a.first][a.second] + 1 < dp3[a.first][a.second - 1]) {\n\t\t\t\t\tdp3[a.first][a.second - 1] = dp3[a.first][a.second] + 1;\n\t\t\t\t\tq.emplace(a.first, a.second - 1);\n\t\t\t\t}\n\t\t\t\tif (a.second < h - 1 && y[a.first][a.second] == 0 && dp3[a.first][a.second] + 1 < dp3[a.first][a.second + 1]) {\n\t\t\t\t\tdp3[a.first][a.second + 1] = dp3[a.first][a.second] + 1;\n\t\t\t\t\tq.emplace(a.first, a.second + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, w)rep(j, h) {\n\t\t\trep(k, w)fill(ALL(dp2[k]), 1e9);\n\t\t\tdp2[w - 1][h - 1] = 0;\n\t\t\tqueue<pii> q;\n\t\t\tq.push(pii(w - 1, h - 1));\n\t\t\twhile (!q.empty()) {\n\t\t\t\tauto a = q.front();q.pop();\n\t\t\t\tif (a.first == i&&a.second == j)continue;\n\t\t\t\tif (a.first > 0 && x[a.first - 1][a.second] == 0 && dp2[a.first][a.second] + 1 < dp2[a.first - 1][a.second]) {\n\t\t\t\t\tdp2[a.first - 1][a.second] = dp2[a.first][a.second] + 1;\n\t\t\t\t\tq.emplace(a.first - 1, a.second);\n\t\t\t\t}\n\t\t\t\tif (a.first < w - 1 && x[a.first][a.second] == 0 && dp2[a.first][a.second] + 1 < dp2[a.first + 1][a.second]) {\n\t\t\t\t\tdp2[a.first + 1][a.second] = dp2[a.first][a.second] + 1;\n\t\t\t\t\tq.emplace(a.first + 1, a.second);\n\t\t\t\t}\n\t\t\t\tif (a.second > 0 && y[a.first][a.second - 1] == 0 && dp2[a.first][a.second] + 1 < dp2[a.first][a.second - 1]) {\n\t\t\t\t\tdp2[a.first][a.second - 1] = dp2[a.first][a.second] + 1;\n\t\t\t\t\tq.emplace(a.first, a.second - 1);\n\t\t\t\t}\n\t\t\t\tif (a.second < h - 1 && y[a.first][a.second] == 0 && dp2[a.first][a.second] + 1 < dp2[a.first][a.second + 1]) {\n\t\t\t\t\tdp2[a.first][a.second + 1] = dp2[a.first][a.second] + 1;\n\t\t\t\t\tq.emplace(a.first, a.second + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvi ans(2,1e9);\n\t\t\tif (i > 0 && x[i - 1][j] == 0) ans.push_back(dp2[i - 1][j]);\n\t\t\tif (i < w - 1 && x[i][j] == 0) ans.push_back(dp2[i + 1][j]);\n\t\t\tif (j > 0 && y[i][j - 1] == 0) ans.push_back(dp2[i][j - 1]);\n\t\t\tif (j < h - 1 &&y[i][j] == 0) ans.push_back(dp2[i][j + 1]);\n\t\t\tsort(ALL(ans));\n\t\t\tdp1[i][j] = ans[1];\n\t\t}\n\t\tdp1[w - 1][h - 1] = -1;\n\t\tpriority_queue<pair<int,pii>> q;\n\t\tdp0[w - 1][h - 1] = 0;\n\t\tq.emplace(0, pii(w - 1, h - 1));\n\t\twhile (!q.empty()) {\n\t\t\tauto a = q.top(); q.pop();\n\t\t\tif (a.second.first > 0 && x[a.second.first - 1][a.second.second] == 0 && max(dp0[a.second.first][a.second.second], dp1[a.second.first][a.second.second]) + 1 < dp0[a.second.first - 1][a.second.second]) {\n\t\t\t\tdp0[a.second.first - 1][a.second.second] = max(dp0[a.second.first][a.second.second], dp1[a.second.first][a.second.second]) + 1;\n\t\t\t\tq.emplace(dp0[a.second.first][a.second.second], pii{ a.second.first - 1, a.second.second });\n\t\t\t}\n\t\t\tif (a.second.first < w - 1 && x[a.second.first][a.second.second] == 0 && max(dp0[a.second.first][a.second.second], dp1[a.second.first][a.second.second]) + 1 < dp0[a.second.first + 1][a.second.second]) {\n\t\t\t\tdp0[a.second.first + 1][a.second.second] = max(dp0[a.second.first][a.second.second], dp1[a.second.first][a.second.second]) + 1;\n\t\t\t\tq.emplace(dp0[a.second.first][a.second.second], pii{ a.second.first + 1, a.second.second });\n\t\t\t}\n\t\t\tif (a.second.second > 0 && y[a.second.first][a.second.second - 1] == 0 && max(dp0[a.second.first][a.second.second], dp1[a.second.first][a.second.second]) + 1 < dp0[a.second.first][a.second.second - 1]) {\n\t\t\t\tdp0[a.second.first][a.second.second - 1] = max(dp0[a.second.first][a.second.second], dp1[a.second.first][a.second.second]) + 1;\n\t\t\t\tq.emplace(dp0[a.second.first][a.second.second], pii{ a.second.first, a.second.second - 1 });\n\t\t\t}\n\t\t\tif (a.second.second < h - 1 && y[a.second.first][a.second.second] == 0 && max(dp0[a.second.first][a.second.second], dp1[a.second.first][a.second.second]) + 1 < dp0[a.second.first][a.second.second + 1]) {\n\t\t\t\tdp0[a.second.first][a.second.second + 1] = max(dp0[a.second.first][a.second.second], dp1[a.second.first][a.second.second]) + 1;\n\t\t\t\tq.emplace(dp0[a.second.first][a.second.second], pii{ a.second.first, a.second.second + 1 });\n\t\t\t}\n\n\t\t}\n\t\tcout << (dp0[0][0] >= 1e9 ? -1 : dp0[0][0] + 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<pair<int,int>,int> P;\nint h,w;\nint dp[33*33];\nint dist[33*33];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nvector<vector<int>> v(33*33);\n\nint fun(int a,int b){\n\tREP(i,33*33)dist[i] = INF;\n\tdist[a] = 0;\n\tqueue<pair<int,int>> q;\n\tq.push(MP(a,0));\n\twhile(!q.empty()){\n\t\tpair<int,int> now = q.front();q.pop();\n\t\tint node = now.FI;\n\t\tint kyo = now.SE;\n\t\tif(kyo > dist[node])continue;\n\t\tREP(i,v[node].size()){\n\t\t\tint aite = v[node][i];\n\t\t\tif((node == a && aite == b) || (node == b && aite == a))continue;\n\t\t\tif(dist[aite] > kyo + 1){\n\t\t\t\tdist[aite] = kyo + 1;\n\t\t\t\tq.push(MP(aite,kyo+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[h*w-1];\n}\n\nint main()\n{\n\twhile(cin >> h >> w,h|w){\n\t\t//初期化\n\t\tREP(i,33*33)dp[i] = INF;\n\t\tREP(i,33*33){v[i].clear();}\n\t\tdp[0] = 0;\n\t\t\n\t\t//入力\n\t\tREP(i,h){\n\t\t\tREP(j,w-1){\n\t\t\t\tint tmp;cin >> tmp;\n\t\t\t\tif(tmp == 0){\n\t\t\t\t\tv[i*w+j].PB(i*w+j+1);\n\t\t\t\t\tv[i*w+j+1].PB(i*w+j);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tif(i != h-1)REP(j,w){\n\t\t\t\tint tmp;cin >> tmp;\n\t\t\t\tif(tmp == 0){\n\t\t\t\t\tv[i*w+j].PB((i+1)*w+j);\n\t\t\t\t\tv[(i+1)*w+j].PB(i*w+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tpriority_queue<P,vector<P>,greater<P>> q;\n\t\tq.push(MP(MP(0,-1),0));\n\t\twhile(!q.empty()){\n\t\t\tDBG(\n\t\t\tcout << \"DP TABLE\" << endl;\n\t\t\tREP(i,h){\n\t\t\t\tREP(j,w){\n\t\t\t\t\tcout << dp[i*w+j] << ' ';\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\t)\n\t\t\tP now = q.top();q.pop();\n\t\t\tint node = now.SE;\n\t\t\tpair<int,int> kyori = now.FI;\n\t\t\tkyori.SE++;\n\t\t\tif(dp[node] < kyori.FI)continue;\n\t\t\tREP(i,v[node].size()){\n\t\t\t\tint aite = v[node][i];\n\t\t\t\tint score = fun(node,aite) + kyori.SE;\n\t\t\t\tif(dp[aite] > max(dp[node],score)){\n\t\t\t\t\tdp[aite] = max(dp[node],score);\n\t\t\t\t\tq.push(MP(MP(dp[aite],kyori.SE),aite));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tDBG(\n\t\tcout << \"DP TABLE\" << endl;\n\t\tREP(i,h){\n\t\t\tREP(j,w){\n\t\t\t\tcout << dp[i*w+j] << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t)\n\t\t\n\t\tDBG(cout << \"ANS IS \";);\n\t\t\n\t\tif(dp[h*w-1] == INF){\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << dp[h*w-1] << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\ntypedef int Weight;\nWeight INF = 1000000000;\nstruct Edge{\n  int src, dest; Weight weight;\n  bool operator < (const Edge &rhs) const {return weight > rhs.weight;}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid add_edge(Graph &g, int src, int dest, Weight weight) {\n  g[src].push_back((Edge){src, dest, weight});\n}\nvoid bellman_ford(const Edges &es, Array &d, int s) {\n  fill(ALL(d), INF);\n  d[s] = 0;\n  REP(i, es.size()) {\n    Edge e = es[i];\n    if (d[e.dest] > d[e.src] + 1) {\n      d[e.dest] = d[e.src] + 1;\n      i = -1;\n    }\n  }\n}\nvoid bellman_ford2(const Edges &es, Array &d, int s) {\n  fill(ALL(d), INF);\n  d[s] = 0;\n  REP(i, es.size()) {\n    Edge e = es[i];\n    if (d[e.dest] > max(d[e.src], e.weight)) {\n      d[e.dest] = max(d[e.src], e.weight);\n      i = -1;\n    }\n  }\n}\n\nint main() {\n  while(1) {\n    int h,w;\n    cin>>h>>w;\n    if(!h) break;\n    Edges ve;\n    REP(i,h-1) {\n      REP(j,w-1) {\n        int b;\n        cin>>b;\n        if (b == 0) {\n          int s=i*w+j;\n          ve.push_back((Edge){s, s+1, 0});\n          ve.push_back((Edge){s+1, s, 0});\n        }\n      }\n      REP(j,w) {\n        int b;\n        cin>>b;\n        if (b == 0) {\n          int s=i*w+j;\n          ve.push_back((Edge){s, s+w, 0});\n          ve.push_back((Edge){s+w, s, 0});\n        }\n      }\n    }\n    REP(i,w-1) {\n      int b;\n      cin>>b;\n      if (b == 0) {\n        int s=(h-1)*w+i;\n        ve.push_back((Edge){s, s+1, 0});\n        ve.push_back((Edge){s+1, s, 0});\n      }\n    }\n    int n = ve.size();\n    Array d(h*w);\n    REP(i,n) {\n      auto tmp = ve;\n      int s = tmp[i].src;\n      tmp.erase(begin(tmp)+i);\n      bellman_ford(tmp, d, s);\n      ve[i].weight = d[h*w-1];\n    }\n    bellman_ford(ve, d, 0);\n    int res = INF;\n    Array d2(h*w);\n    FOR(i,d[h*w-1],2*h*w+1) {\n      Edges valid;\n      REP(j,n) {\n        if (d[ve[j].src] + ve[j].weight <= i) {\n          valid.push_back(ve[j]);\n          valid.back().weight = d[ve[j].src] + ve[j].weight;\n        }\n      }\n      bellman_ford2(valid, d2, 0);\n      if (d2[h*w-1] < INF) {\n        res = i;\n        break;\n      }\n    }\n    if (res < INF) {\n      cout << res << endl;\n    } else {\n      cout << -1 << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\nclass State {\npublic:\n  int x;\n  int y;\n  int cost;\n  State(int x,int y,int cost)\n    : x(x), y(y), cost(cost) {}\n  bool operator<(const State& s) const {\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const {\n    return cost > s.cost;\n  }\n};\n\nbool walls[51][51][51][51];\nint mid2goal_cost[51][51][4];\n\nvoid compute_mid2goal_cost(int H,int W){\n\n  memset(mid2goal_cost,0x3f,sizeof(mid2goal_cost));\n\n  for(int sy = 0; sy < H; sy++){\n    for(int sx = 0; sx < W; sx++){\n      for(int dir = 0; dir < 4; dir++){\n        int tmp_mid2goal_cost[51][51];\n        memset(tmp_mid2goal_cost,0x3f,sizeof(tmp_mid2goal_cost));\n        priority_queue<State,vector<State>,greater<State> > que;\n        que.push(State(sx,sy,0));\n        tmp_mid2goal_cost[sy][sx] = 0;\n        while(!que.empty()){\n          State s = que.top();\n          que.pop();\n          \n          for(int i = 0; i < 4; i++){\n            int dx = tx[i] + s.x;\n            int dy = ty[i] + s.y;\n            if(dx >= W || dy >= H || dx < 0 || dy < 0) continue;\n            if(walls[s.y][s.x][dy][dx]) continue;\n            if(s.x == sx && s.y == sy && dir == i) continue;\n            if(tmp_mid2goal_cost[dy][dx] <= s.cost + 1) continue;\n            tmp_mid2goal_cost[dy][dx] = s.cost + 1;\n            que.push(State(dx,dy,s.cost + 1));\n          }\n        }\n\n        mid2goal_cost[sy][sx][dir] = tmp_mid2goal_cost[H-1][W-1];\n      }\n    }\n  } \n}\n\n\nint compute_goal2start_cost(int H,int W){\n  compute_mid2goal_cost(H,W);\n\n  int goal2start_cost[51][51];\n  memset(goal2start_cost,0x3f,sizeof(goal2start_cost));\n\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(W-1,H-1,0));\n  goal2start_cost[H-1][W-1] = 0;\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    for(int i = 0; i < 4; i++){\n      int dx = tx[i] + s.x;\n      int dy = ty[i] + s.y;\n      if(dx >= W || dy >= H || dx < 0 || dy < 0) continue;\n      if(walls[s.y][s.x][dy][dx]) continue;\n      if(goal2start_cost[dy][dx] <= max(s.cost + 1,mid2goal_cost[dy][dx][(i+2)%4])) continue;\n      goal2start_cost[dy][dx] = max(s.cost + 1,mid2goal_cost[dy][dx][(i+2)%4]);\n      que.push(State(dx,dy,max(s.cost + 1,mid2goal_cost[dy][dx][(i+2)%4])));\n    }\n  }\n  return (goal2start_cost[0][0] >= INF ? -1 : goal2start_cost[0][0]);\n}\n\nint main(){\n  int H,W;\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    if(H == 0 && W == 0) break;\n    memset(walls,false,sizeof(walls));\n\n    int patterns[] = {W - 1, W};\n    int accumulate[61] = {};\n    for(int i = 0; i < 60; i++){\n      accumulate[i + 1] = patterns[i % 2] + accumulate[i];\n    }\n\n    int pos = 0;\n    while(pos < ((H - 1) * W) + (H * (W - 1))){\n      int flag;\n      scanf(\"%d\",&flag);\n      int depth = (lower_bound(accumulate,accumulate + 61,pos+1) - accumulate);\n      int type = (depth-1) % 2;\n      if(type == 0){\n        int from_y = (depth - 1)/2;\n        int from_x = pos - accumulate[depth - 1];\n        int to_y = (depth - 1)/2;\n        int to_x = pos - accumulate[depth - 1] + 1;\n        walls[from_y][from_x][to_y][to_x] = (flag == 1 ? true : false);\n        walls[to_y][to_x][from_y][from_x] = (flag == 1 ? true : false);\n      }\n      else{\n        int from_y = (depth-1)/2;\n        int from_x = pos - accumulate[depth - 1];\n        int to_y = (depth-1)/2 + 1;\n        int to_x = pos - accumulate[depth - 1];\n        walls[from_y][from_x][to_y][to_x] = (flag == 1 ? true : false);\n        walls[to_y][to_x][from_y][from_x] = (flag == 1 ? true : false);\n      }\n      pos++;\n    }\n    printf(\"%d\\n\",compute_goal2start_cost(H,W));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 100000\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\nstruct edge{\n    int x, y;\n};\n\nint h, w;\nvector<edge> E[32][32];\n\nbool input(){\n    cin >> h >> w;\n    if(!h and !w) return 0;\n    rep(i,32)rep(j,32) E[i][j].clear();\n    rep(y,h){\n        rep(x,w-1){\n            int t; cin >> t;\n            if(!t){\n                E[x][y].pb((edge){x+1,y});\n                E[x+1][y].pb((edge){x,y});\n            }\n        }\n        if(y == h-1) continue;\n        rep(x,w){\n            int t; cin >> t;\n            if(!t){\n                E[x][y].pb((edge){x,y+1});\n                E[x][y+1].pb((edge){x,y});\n            }\n        }\n    }\n    return 1;\n}\n\nint doorCost[32][32][4];\nstruct node {\n    int x, y, cst;\n};\nint calcCost(int sx, int sy, int gx, int gy, int tx, int ty) {\n    queue<node> q;\n    q.push((node){sx, sy, 0});\n    int done[32][32] = {0};\n    while(q.size()) {\n        int x = q.front().x;\n        int y = q.front().y;\n        int cst = q.front().cst; q.pop();\n        if(done[x][y]) continue;\n        done[x][y] = true;\n        if(x == gx and y == gy) {\n            return cst;\n        }\n        rep(i, E[x][y].size()) {\n            edge &e = E[x][y][i];\n            if(x == sx and y == sy and e.x == tx and e.y == ty) continue;\n            if(e.x == sx and e.y == sy and x == tx and y == ty) continue;\n            q.push((node){e.x, e.y, cst+1});\n        }\n    }\n    return INF;\n}\n\nvoid calcDoorCost() {\n    rep(y, h) rep(x, w) rep(i, 4) doorCost[x][y][i] = INF;\n    rep(y, h) rep(x, w) {\n        rep(i, E[x][y].size()) {\n            edge &e = E[x][y][i];\n            doorCost[x][y][i] = calcCost(x, y, w-1, h-1, e.x, e.y);\n        }\n    }\n}\n\nstruct nd {\n    int x, y, cst, step;\n    vector<pair<int, int> > route;\n    bool operator<(const nd &o) const {\n        return cst > o.cst;\n    }\n};\nint solve() {\n    calcDoorCost();\n    priority_queue<nd> pq;\n    pq.push((nd){0, 0, 0, 0,vector<pair<int, int> >()});\n    const int lim = 512;\n    int done[32][32][lim] = {0};\n    int ret = INF;\n    while(pq.size()) {\n        int x = pq.top().x;\n        int y = pq.top().y;\n        int cst = pq.top().cst;\n        int step = pq.top().step;\n        vector<pair<int, int> > route = pq.top().route;\n        pq.pop();\n        if(step > lim) continue;\n        if(done[x][y][step]) continue;\n        done[x][y][step] = true;\n        if(x == w-1 and y == h-1) {\n            /*\n            cout << route.size() << endl;\n            rep(i, route.size()) {\n                cout << route[i].first << \" \" << route[i].second << endl;\n            }\n            cout << endl;*/\n            ret = min(ret, cst);\n            return ret;\n        }\n        rep(i, E[x][y].size()) {\n            edge &e = E[x][y][i];\n            vector<pair<int, int> > tv = route;\n            tv.pb(mp(x, cst));\n            pq.push((nd){e.x, e.y, max(cst, step + doorCost[x][y][i]),step+1, tv});\n        }\n    }\n    return ret;\n}\n\nint main()\n{\n    while(input()){\n        int ans = solve();\n        if(ans < INF) cout << ans << endl;\n        else cout << -1 << endl;\n    } \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\n//#define DEBUG\n#define MAX_H 30\n#define MAX_W 30\n#define MAP_H (MAX_H * 2 - 1)\n#define MAP_W (MAX_W * 2 - 1)\n\n#define T 100000\n#define U -10\n#define D -20\n#define L -30\n#define R -40\n\ntypedef struct _point { // show map[y][x];\n\tint x;\n\tint y;\n} P;\n\ntypedef struct _pair {\n\tint cost;\n\tP point;\n} Pair;\n\nint H, W;\nint **MAP, **tmpMAP;\n\nvoid setTO(int **map, P p, int val) {\n//\tif (map[p.y][p.x] == U) {\n//\t\tmap[p.y - 1][p.x] = val;\n//\t} else if (map[p.y][p.x] == D) {\n//\t\tmap[p.y + 1][p.x] = val;\n//\t} else if (map[p.y][p.x] == L) {\n//\t\tmap[p.y][p.x - 1] = val;\n//\t} else if (map[p.y][p.x] == R) {\n//\t\tmap[p.y][p.x + 1] = val;\n//\t} //else\n\tmap[p.y][p.x] = val;\n\treturn;\n}\n\nvoid closeDoor(int **map, P p) {\n\tsetTO(map, p, T);\n}\nvoid openDoor(int **map, P p) {\n\tsetTO(map, p, 0);\n}\nvoid refreshMap(int **map) {\n\tfor (int y = 0; y < 2 * H - 1; y++) {\n\t\tif (y % 2 != 0) continue;\n\t\tfor (int x = 0; x < 2 * W - 1; x++) {\n\t\t\tif (x % 2 != 0) continue;\n\t\t\tmap[y][x] = 0;\n\t\t}\n\t}\n}\n\nbool judgeAll(int i, int k) {\n\t//cout << \"fuga\" << endl;\n\treturn i == 0;\n}\n\nbool judgeOnly(int i, int k) {\n\t//cout << \"fuga\" << endl;\n\treturn !(i == 1 || i == T || i == k);\n}\n\nint route(int **map, P start, P goal, int k, bool useall) {\n\t//cout << \"??????????????????\" << endl;\n\tbool (*judge)(int, int);\n\tif (useall) judge = judgeAll;\n\telse        judge = judgeOnly;\n\tqueue < Pair > que;\n\trefreshMap(map);\n\tPair pair;\n\tP p = start;\n\t//p.x = 0;\n\t//p.y = 0;\n\tpair.cost = 0;\n\tpair.point = p;\n\tque.push(pair);\n\tmap[p.y][p.x] = -1;\n\twhile (!que.empty()) {\n\t\t//cout << \"hoge\" << endl;\n\t\tpair = que.front();\n\t\tque.pop();\n\t\t//cout << pair.point.y << \"<>\" << pair.point.x << endl;\n\t\tif (pair.point.x == goal.x && pair.point.y == goal.y) return pair.cost;\n\t\t//cout << \"hoge2\" << endl;\n\t\t// UP\n\t\tif (pair.point.y - 2 >= 0 &&\n\t\t\tjudge(map[pair.point.y - 1][pair.point.x], k) &&\n\t\t\tmap[pair.point.y - 2][pair.point.x] == 0\n\t\t) {\n\t\t\t//cout << \"fooU\" << endl;\n\t\t\tPair npair;\n\t\t\tP pp = pair.point;\n\t\t\tpp.y -= 2;\n\t\t//cout << pp.y << \"<**>\" << pp.x << endl;\n\t\t\tnpair.cost = pair.cost + 1;\n\t\t\tnpair.point = pp;\n\t\t\tque.push(npair);\n\t\t\tmap[pp.y][pp.x] = D;\n\t\t}\n\t\t//cout << \"hoge3\" << endl;\n\t\t// DOWN\n\t\tif (pair.point.y + 2 < 2 * H - 1 &&\n\t\t\tjudge(map[pair.point.y + 1][pair.point.x], k) &&\n\t\t\tmap[pair.point.y + 2][pair.point.x] == 0\n\t\t) {\n\t\t\t//cout << \"foo\" << endl;\n\t\t\tPair npair;\n\t\t\tP pp = pair.point;\n\t\t\tpp.y += 2;\n\t\t//cout << pp.y << \"<**>\" << pp.x << endl;\n\t\t\tnpair.cost = pair.cost + 1;\n\t\t\tnpair.point = pp;\n\t\t\tque.push(npair);\n\t\t\tmap[pp.y][pp.x] = U;\n\t\t}\n\t\t//cout << \"hoge4\" << endl;\n\t\t// LEFT\n\t\tif (pair.point.x - 2 >= 0 &&\n\t\t\tjudge(map[pair.point.y][pair.point.x - 1], k) &&\n\t\t\tmap[pair.point.y][pair.point.x - 2] == 0\n\t\t) {\n\t\t\tPair npair;\n\t\t\tP pp = pair.point;\n\t\t\tpp.x -= 2;\n\t\t//cout << pp.y << \"<**>\" << pp.x << endl;\n\t\t\tnpair.cost = pair.cost + 1;\n\t\t\tnpair.point = pp;\n\t\t\tque.push(npair);\n\t\t\tmap[pp.y][pp.x] = R;\n\t\t}\n\t\t//cout << \"hoge5\" << endl;\n\t\t// RIGHT\n\t\tif (pair.point.x + 2 < 2 * W - 1 &&\n\t\t\tjudge(map[pair.point.y][pair.point.x + 1], k) &&\n\t\t\tmap[pair.point.y][pair.point.x + 2] == 0\n\t\t) {\n\t\t\tPair npair;\n\t\t\tP pp = pair.point;\n\t\t\tpp.x += 2;\n\t\t//cout << pp.y << \"<**>\" << pp.x << endl;\n\t\t\tnpair.cost = pair.cost + 1;\n\t\t\tnpair.point = pp;\n\t\t\tque.push(npair);\n\t\t\tmap[pp.y][pp.x] = L;\n\t\t}\n\t}\n\t\n\treturn -1;\n}\n\nvoid cp2(int **dst, int **map) {\n\tfor (int y = 0; y < 2 * H - 1; y++) {\n\t\tif (y % 2 != 0) continue;\n\t\tfor (int x = 0; x < 2 * W - 1; x++) {\n\t\t\tif (x % 2 != 0) continue;\n\t\t\tdst[y][x] = map[y][x];\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tint maxx = 100000;\n\tP start, goal;\n\tstart.x = 0;\n\tstart.y = 0;\n\tgoal.y = 2 * H - 2;\n\tgoal.x = 2 * W - 2;\n\tint t;\n\tbool first = true;\n\tfor (int k = 2; (t = route(MAP, start, goal, k, true)) != -1; k++) {\n\t\tint badest = 0;\n\t\tP badp;\n\t\tP now = goal;\n\t\tfor (int i = t - 1; i >= 1; i--) {\n\t\t\tcp2(tmpMAP, MAP);\n\t\t\tP tnow = now;\n\t\t\tif (MAP[now.y][now.x] == U) {\n\t\t\t\tnow.y -= 2;\n\t\t\t\ttnow.y -= 1;\n\t\t\t\tcloseDoor(tmpMAP, tnow);\n\t\t\t} else if (MAP[now.y][now.x] == D) {\n\t\t\t\tnow.y += 2;\n\t\t\t\ttnow.y += 1;\n\t\t\t\tcloseDoor(tmpMAP, tnow);\n\t\t\t} else if (MAP[now.y][now.x] == L) {\n\t\t\t\tnow.x -= 2;\n\t\t\t\ttnow.x -= 1;\n\t\t\t\tcloseDoor(tmpMAP, tnow);\n\t\t\t} else if (MAP[now.y][now.x] == R) {\n\t\t\t\tnow.x += 2;\n\t\t\t\ttnow.x += 1;\n\t\t\t\tcloseDoor(tmpMAP, tnow);\n\t\t\t}\n\t\t\tint l = route(tmpMAP, now, goal, k, false);\n\t\t\tif (first && l == -1) {\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (badest < i + l) {\n\t\t\t\tbadp = tnow;\n\t\t\t\tbadest = i + l;\n\t\t\t}\n\t\t\topenDoor(tmpMAP, tnow);\n\t\t}\n\t\tsetTO(MAP, badp, k);\n#ifdef DEBUG\n\t\tfor (int y = 0; y < 2 * H - 1; y++) {\n\t\t\t//if (y % 2 != 0) continue;\n\t\t\tfor (int x = 0; x < 2 * W - 1; x++) {\n\t\t\t\t//if (x % 2 != 0) continue;\n\t\t\t\tcout << MAP[y][x] << \"\\t\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n#endif\n\t\tif (maxx > badest) maxx = badest;\n\t\tfirst = false;\n\t}\n\tcout << maxx << endl;\n}\n\nint main(void) {\n\tMAP = new int*[MAP_H];\n\ttmpMAP = new int*[MAP_H];\n\tfor (int i = 0; i < MAP_H; i++) {\n\t\tMAP[i] = new int[MAP_W];\n\t\ttmpMAP[i] = new int[MAP_W];\n\t\tfor (int j = 0; j < MAP_W; j++) {\n\t\t\tMAP[i][j] = 0;\n\t\t\ttmpMAP[i][j] = 0;\n\t\t}\n\t}\n\n\tcin >> H >> W;\n\twhile (H != 0 && W != 0) {\n\t\tfor (int y = 0; y < 2 * H - 1; y++) {\n\t\t\tfor (int x = 0; x < 2 * W - 1; x++) {\n\t\t\t\tint k = 0;\n\t\t\t\tif ((x + y) % 2 != 0) cin >> k;\n\t\t\t\tMAP[y][x] = tmpMAP[y][x] = k;\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t\t//cout << endl;\n\t\tcin >> H >> W;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nconst int di[4]={-1,1,0,0};\nconst int dj[4]={0,0,-1,1};\nconst int oo=1073741819;\nusing namespace std;\nint d[2000],id[200][200],c[1005][1005],D[2][2000];\nint n,m,tot;\nstruct point{\n    int i,j;\n}lot[2000];\nstruct sta{\n    int x,y;\n}st[200000];\nint bfs(int sx,int sy,int tx,int ty)\n{\n    int h,r;\n    h=r=0;\n    for (int i=1;i<=tot;i++) d[i]=oo;\n    st[r=1].x=id[sx][sy],st[r=1].y=1,d[st[1].x]=0;\n    for (;h<r;) {\n        point ne=lot[st[++h].x];\n        for (int i=0;i<=3;i++) {\n            int ni=ne.i+di[i],nj=ne.j+dj[i];\n            if (1<=ni && ni<=n && 1<=nj && nj<=m) {\n                point na=lot[id[ni][nj]];\n                if (!c[id[ne.i][ne.j]][id[na.i][na.j]]) continue;\n                if (1==c[id[ne.i][ne.j]][id[na.i][na.j]]) {\n                    if (d[id[ne.i][ne.j]]+1<d[id[na.i][na.j]]) {\n                        d[id[na.i][na.j]]=d[id[ne.i][ne.j]]+1;\n                        st[++r].x=id[ni][nj];\n                    }\n                }\n            }\n        }\n    }\n    return d[id[tx][ty]];\n}\nint P[1000][2000],cost[1005][1005];\nint getans()\n{\n    int h,r;\n    h=r=0;\n    for (int i=1;i<=tot;i++) \n        for (int k=0;k<=tot*2;k++)\n            P[i][k]=oo;\n    st[r=1].x=id[1][1],st[r].y=0,P[st[1].x][st[1].y]=0;\n\tfor (;h<r;) {\n        point ne=lot[st[++h].x];\n        int p=st[h].y;\n        for (int i=0;i<=3;i++) {\n            int ni=ne.i+di[i],nj=ne.j+dj[i];\n            if (1<=ni && ni<=n && 1<=nj && nj<=m) {\n                point na=lot[id[ni][nj]];\n                int cos=max(cost[id[ne.i][ne.j]][id[na.i][na.j]],p);\n                if (!c[id[ne.i][ne.j]][id[na.i][na.j]] || cos>tot*2) continue;\n                if (1==c[id[ne.i][ne.j]][id[na.i][na.j]]) {\n                    int cc=D[0][id[ne.i][ne.j]]+cos;\n                    if (max(P[id[ne.i][ne.j]][p],cc)<P[id[na.i][na.j]][cos]) {\n                        P[id[na.i][na.j]][cos]=max(P[id[ne.i][ne.j]][p],cc);\n                        st[++r].x=id[ni][nj];\n                        st[r].y=p+cos;\n                    }\n                }\n            }\n        }\n    }\n//    cout<<r<<endl;\n    int sum=oo;\n//    cout<<cost[1][2]<<' '<<cost[1][3]<<' '<<cost[2][4]<<' '<<cost[3][4]<<endl;\n    for (int i=0;i<=tot*2;i++)\n        sum=min(sum,P[id[n][m]][i]);\n    return sum;\n}\nint main()\n{\n    for (;scanf(\"%d%d\",&n,&m)==2;) {\n        if (!n && !m) break;\n        tot=0;\n        for (int i=1;i<=n;i++)\n            for (int j=1;j<=m;j++) \n                id[i][j]=++tot,lot[tot].i=i,lot[tot].j=j;\n        for (int i=1;i<=tot;i++)\n            for (int j=1;j<=tot;j++)\n                c[i][j]=0,cost[i][j]=oo; \n        for (int i=1;i<=n;i++) {\n            int x;\n            for (int j=1;j<=m-1;j++) {\n                scanf(\"%d\",&x);\n                if (!x) {\n                    int p=id[i][j],q=id[i][j+1];\n                    c[p][q]=c[q][p]=1;\n                }\n            }\n            if (i==n) break;\n            for (int j=1;j<=m;j++) {\n                scanf(\"%d\",&x);\n                if (!x) {\n                    int p=id[i][j],q=id[i+1][j];\n                    c[p][q]=c[q][p]=1;\n                }\n            }\n        }\n        bfs(1,1,n,m);\n        for (int i=1;i<=tot;i++) D[0][i]=d[i];\n        bfs(n,m,1,1);\n        for (int i=1;i<=tot;i++) D[1][i]=d[i];\n  //      int ans=D[0][id[n][m]];\n        int ans=oo;\n        for (int i=1;i<=tot;i++)\n            for (int j=i+1;j<=tot;j++)\n                if (c[i][j]) {\n//                    if (D[0][i]+1+D[1][j]!=D[0][id[n][m]]) continue;\n//                    cout<<lot[i].i<<' '<<lot[i].j<<' '<<lot[j].i<<' '<<lot[j].j<<endl;\n                    if (D[0][i]<D[0][j]) {\n                        c[i][j]=c[j][i]=0;\n                        int sum=bfs(lot[i].i,lot[i].j,n,m);\n//                        ans=min(ans,sum+D[0][i]);\n                        c[i][j]=c[j][i]=1;\n                        cost[i][j]=sum;\n                    }\n                    else {\n                        c[i][j]=c[j][i]=0;\n                        int sum=bfs(lot[j].i,lot[j].j,n,m);\n//                        ans=min(ans,sum+D[0][j]);\n                        cost[j][i]=sum;\n                        c[i][j]=c[j][i]=1;\n                    }\n//                    cout<<ans<<endl;\n                }\n        ans=getans();\n        if (ans<oo) printf(\"%d\\n\",ans);\n        else printf(\"%d\\n\",-1);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\nclass State {\npublic:\n  int x;\n  int y;\n  int cost;\n  State(int x,int y,int cost)\n    : x(x), y(y), cost(cost) {}\n  bool operator<(const State& s) const {\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const {\n    return cost > s.cost;\n  }\n};\n\nbool walls[51][51][51][51];\nint mid2goal_cost[51][51][4];\n\nvoid compute_mid2goal_cost(int H,int W){\n\n  memset(mid2goal_cost,0x3f,sizeof(mid2goal_cost));\n\n  for(int sy = 0; sy < H; sy++){\n    for(int sx = 0; sx < W; sx++){\n      for(int dir = 0; dir < 4; dir++){\n        int tmp_mid2goal_cost[51][51];\n        memset(tmp_mid2goal_cost,0x3f,sizeof(tmp_mid2goal_cost));\n        priority_queue<State,vector<State>,greater<State> > que;\n        que.push(State(sx,sy,0));\n        tmp_mid2goal_cost[sy][sx] = 0;\n        while(!que.empty()){\n          State s = que.top();\n          que.pop();\n          \n          for(int i = 0; i < 4; i++){\n            int dx = tx[i] + s.x;\n            int dy = ty[i] + s.y;\n            if(dx >= W || dy >= H || dx < 0 || dy < 0) continue;\n            if(walls[s.y][s.x][dy][dx]) continue;\n            if(s.x == sx && s.y == sy && dir == i) continue;\n            if(tmp_mid2goal_cost[dy][dx] <= s.cost + 1) continue;\n            tmp_mid2goal_cost[dy][dx] = s.cost + 1;\n            que.push(State(dx,dy,s.cost + 1));\n          }\n        }\n\n        mid2goal_cost[sy][sx][dir] = tmp_mid2goal_cost[H-1][W-1];\n      }\n    }\n  } \n}\n\n\nint compute_start2goal_cost(int H,int W){\n  compute_mid2goal_cost(H,W);\n\n  int goal2start_cost[51][51];\n  memset(goal2start_cost,0x3f,sizeof(goal2start_cost));\n\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(W-1,H-1,0));\n  goal2start_cost[H-1][W-1] = 0;\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    for(int i = 0; i < 4; i++){\n      int dx = tx[i] + s.x;\n      int dy = ty[i] + s.y;\n      if(dx >= W || dy >= H || dx < 0 || dy < 0) continue;\n      if(walls[s.y][s.x][dy][dx]) continue;\n      if(goal2start_cost[dy][dx] <= max(s.cost + 1,mid2goal_cost[dy][dx][(i+2)%4])) continue;\n      goal2start_cost[dy][dx] = max(s.cost + 1,mid2goal_cost[dy][dx][(i+2)%4]);\n      que.push(State(dx,dy,max(s.cost + 1,mid2goal_cost[dy][dx][(i+2)%4])));\n    }\n  }\n  return goal2start_cost[0][0];\n}\n\nint main(){\n  int H,W;\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    if(H == 0 && W == 0) break;\n    memset(walls,false,sizeof(walls));\n\n    int patterns[] = {W - 1, W};\n    int accumulate[61] = {};\n    for(int i = 0; i < 60; i++){\n      accumulate[i + 1] = patterns[i % 2] + accumulate[i];\n    }\n\n    int pos = 0;\n    while(pos < ((H - 1) * W) + (H * (W - 1))){\n      int flag;\n      scanf(\"%d\",&flag);\n      int depth = (lower_bound(accumulate,accumulate + 61,pos+1) - accumulate);\n      int type = (depth-1) % 2;\n      if(type == 0){\n        int from_y = (depth - 1)/2;\n        int from_x = pos - accumulate[depth - 1];\n        int to_y = (depth - 1)/2;\n        int to_x = pos - accumulate[depth - 1] + 1;\n        walls[from_y][from_x][to_y][to_x] = (flag == 1 ? true : false);\n        walls[to_y][to_x][from_y][from_x] = (flag == 1 ? true : false);\n      }\n      else{\n        int from_y = (depth-1)/2;\n        int from_x = pos - accumulate[depth - 1];\n        int to_y = (depth-1)/2 + 1;\n        int to_x = pos - accumulate[depth - 1];\n        walls[from_y][from_x][to_y][to_x] = (flag == 1 ? true : false);\n        walls[to_y][to_x][from_y][from_x] = (flag == 1 ? true : false);\n      }\n      pos++;\n    }\n    printf(\"%d\\n\",compute_start2goal_cost(H,W));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nconst int INF = 10000;\n\nint main(){\n\twhile(1){\n\t\tint h,w;\n\t\tscanf(\"%d%d\",&h,&w);\n\t\tif(h == 0 && w == 0)break;\n\t\t\n\t\tvector<int> G[1100];\n\t\tint a;\n\t\tfor(int i = 1 ; i <= h ; i ++){\n\t\t\tfor(int j = 1 ; j <= w-1 ; j ++){\n\t\t\t\tscanf(\"%d\",&a);\n\t\t\t\tif(a == 0){\n\t\t\t\t\tG[i*(w+2)+j].push_back(i*(w+2)+j+1);\n\t\t\t\t\tG[i*(w+2)+j+1].push_back(i*(w+2)+j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i == h)break;\n\t\t\tfor(int j = 1 ; j <= w ; j ++){\n\t\t\t\tscanf(\"%d\",&a);\n\t\t\t\tif(a == 0){\n\t\t\t\t\tG[i*(w+2)+j].push_back((i+1)*(w+2)+j);\n\t\t\t\t\tG[(i+1)*(w+2)+j].push_back(i*(w+2)+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*for(int i = 1 ; i <= h ; i ++){\n\t\t\tfor(int j = 1 ; j <= w ; j ++){\n\t\t\t\tprintf(\"%d,%d:%d\\n\",i,j,G[i*(w+2)+j].size());\n\t\t\t\tfor(int k = 0 ; k < G[i*(w+2)+j].size() ; k ++){\n\t\t\t\t\tprintf(\"%d \",G[i*(w+2)+j][k]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}*/\n\t\t\n\t\tint memo[1100][2];\n\t\tfor(int xi = 1 ; xi <= h ; xi ++){\n\t\t\tfor(int xj = 1 ; xj <= w ; xj ++){\n\t\t\t\tint x = xi*(w+2)+xj;\n\t\t\t\tint cost[1100];\n\t\t\t\tfor(int i = 0 ; i < 1100 ; i ++)cost[i] = INF;\n\t\t\t\tqueue<int> que;\n\t\t\t\tcost[h*(w+2)+w] = 0;\n\t\t\t\tque.push(h*(w+2)+w);\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tint q = que.front(); que.pop();\n\t\t\t\t\tif(q == x)continue;\n\t\t\t\t\tfor(int i = 0 ; i < G[q].size() ; i ++){\n\t\t\t\t\t\tif(cost[G[q][i]] > cost[q]+1){\n\t\t\t\t\t\t\tcost[G[q][i]] = cost[q]+1;\n\t\t\t\t\t\t\tque.push(G[q][i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmemo[x][0] = INF;\n\t\t\t\tmemo[x][1] = INF;\n\t\t\t\tfor(int i = 0 ; i < G[x].size() ; i ++){\n\t\t\t\t\tif(memo[x][1] > cost[G[x][i]]){\n\t\t\t\t\t\tmemo[x][1] = cost[G[x][i]];\n\t\t\t\t\t\tif(memo[x][0] > memo[x][1]){\n\t\t\t\t\t\t\tswap(memo[x][0],memo[x][1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(xi == h && xj == w){\n\t\t\t\t\tmemo[x][0] = 0;\n\t\t\t\t\tmemo[x][1] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*for(int i = 1 ; i <= h ; i ++){\n\t\t\tfor(int j = 1 ; j <= w ; j ++){\n\t\t\t\tprintf(\"%d,%d:%d %d\\n\",i,j,memo[i*(w+2)+j][0],memo[i*(w+2)+j][1]);\n\t\t\t}\n\t\t}*/\n\t\t\n\t\tint l = memo[w+3][1] , r = INF;\n\t\twhile(l < r){\n\t\t\tint m = (l+r)/2;\n\t\t\tint cost[1100];\n\t\t\tfor(int i = 0 ; i < 1100 ; i ++)cost[i] = INF;\n\t\t\tqueue<int> que;\n\t\t\tcost[w+3] = 0;\n\t\t\tque.push((w+2)+1);\n\t\t\twhile(!que.empty()){\n\t\t\t\tint q = que.front(); que.pop();\n\t\t\t\tfor(int i = 0 ; i < G[q].size() ; i ++){\n\t\t\t\t\tif(memo[G[q][i]][1]+2+cost[q] <= m && cost[G[q][i]] > cost[q]+1){\n\t\t\t\t\t\tcost[G[q][i]] = cost[q]+1;\n\t\t\t\t\t\tque.push(G[q][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cost[h*(w+2)+w] < INF)r = m;\n\t\t\telse l = m+1;\n\t\t}\n\t\t\n\t\tif(l < INF)printf(\"%d\\n\",l);\n\t\telse puts(\"-1\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef tuple<int,int,int> tpl;\n\nint H, W;\nint A[2][31][31];\n\nconst int dy[] = {-1, 0, 0, 1};\nconst int dx[] = {0, -1, 1, 0};\nint from_goal_distance[2][31][31][31][31];\nint ans[31][31];\nconst int INF = 1 << 29;\n\n// cy,cx??????ang????§????????????¨????????????????£????index????¨????\ntpl get_index(int cy, int cx, int ang){\n  int ny = dy[ang] + cy;\n  int nx = dx[ang] + cx;\n  if(ny >= 0 && nx >= 0 && ny < H && nx < W){\n    if(dx[ang] > 0) return make_tuple(0, cy, cx);\n    else if(dx[ang] < 0) return make_tuple(0, cy, cx-1);\n    else if(dy[ang] > 0) return make_tuple(1, cy, cx);\n    else return make_tuple(1, cy-1, cx);\n  }\n  return make_tuple(-1,-1,-1);\n}\n\n// ?§??????????????????????\nbool is_move(int cy, int cx, int k){\n  tpl t = get_index(cy,cx,k);\n  if(get<0>(t)==-1)return false;\n  // ?£???????\n  return !(A[get<0>(t)][get<1>(t)][get<2>(t)]);\n}\n\nvoid bfs(int sy, int sx, int d[31][31]){\n  for(int i = 0; i < H; i++)\n    for(int j = 0; j < W; j++)\n      d[i][j] = INF;\n  queue<pii> q;\n  q.push(pii(sy, sx));\n  d[sy][sx] = 0;\n  while(q.size()){\n    pii p = q.front(); q.pop();\n    int cy = p.first;\n    int cx = p.second;\n    int ccost = d[cy][cx];\n    for(int i = 0; i < 4; i++){\n      if(is_move(cy, cx, i)){\n        int ny = cy + dy[i];\n        int nx = cx + dx[i];\n        if(d[ny][nx] == INF){\n          q.push(pii(ny,nx));\n          d[ny][nx] = ccost + 1;\n        }\n      }\n    }\n  }\n}\n\nvoid dijkstra(int sy, int sx, int d[31][31]){\n  for(int i = 0; i < H; i++)\n    for(int j = 0; j < W; j++)\n      d[i][j] = INF;\n  priority_queue<pair<int, pii>, vector<pair<int, pii> >, greater<pair<int, pii> > > pq;\n  d[sy][sx] = 0;\n  pq.push(make_pair(0, pii(sy, sx)));\n  while(pq.size()){\n    pair<int, pii> p = pq.top(); pq.pop();\n    int ccost = p.first;\n    int cy = p.second.first;\n    int cx = p.second.second;\n    if(d[cy][cx] < ccost) continue;\n    for(int i = 0; i < 4; i++){\n      if(is_move(cy, cx, i)){\n        int ny = cy + dy[i];\n        int nx = cx + dx[i];\n        // ?????¨?????´?????????1?????????????????????????????¨, (ny,nx)??????goal?????§????????????????????§????????????\n        tpl t = get_index(cy, cx, i);\n        int ncost = max(ccost + 1, from_goal_distance[get<0>(t)][get<1>(t)][get<2>(t)][ny][nx]);\n        if(d[ny][nx] > ncost){\n          d[ny][nx] = ncost;\n          pq.push(make_pair(ncost, pii(ny, nx)));\n        }\n      }\n    }\n  }\n}\n\nint main(){\n\n  while(cin>>H>>W && (H|W)){\n    for(int i = 0; i < 2 * H - 1; i++){\n      int *ary = A[i%2][i/2];\n      for(int j = 0; j < W - ((i % 2) == 0); j++) cin>>ary[j];\n    }\n    // ?????´???????£???????????????????????????????????¨????\n    for(int i = 0; i < 2 * H - 1; i++){\n      for(int j = 0; j < W - ((i % 2) == 0); j++){\n        // ?£????????????´???, ?£????switching\n        if(A[i%2][i/2][j] == 0){\n          A[i%2][i/2][j] ^= 1;\n          bfs(H-1, W-1, from_goal_distance[i%2][i/2][j]);\n          A[i%2][i/2][j] ^= 1;\n        }\n        else{\n          bfs(H-1, W-1, from_goal_distance[i%2][i/2][j]);\n        }\n      }\n    }\n    // ??´????????????dijkstra?????????????§£????¨????\n    dijkstra(H-1, W-1, ans); \n    if(ans[0][0] == INF)cout<<-1<<endl;\n    else cout<<ans[0][0]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int N = 30;\nconst int inf = 1<<20;\n\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\nint rev[]={1,0,3,2};\nbool edge[N][N][4];\n\nint cost[N][N];\nint bfs(int r,int c,int sy,int sx){\n  rep(i,r)rep(j,c)cost[i][j]=inf;\n  cost[sy][sx]=0;\n  queue<int> Q;\n  Q.push(sy*c+sx);\n  while(!Q.empty()){\n    int y=Q.front()/c,x=Q.front()%c;Q.pop();\n    if (y == r-1 && x == c-1)return cost[r-1][c-1];\n    rep(i,4){\n      int nex=x+dx[i],ney=y+dy[i];\n      if (nex == -1 || ney == -1 || nex == c || ney == r || !edge[y][x][i] || cost[ney][nex] != inf)continue;\n      cost[ney][nex] = cost[y][x] + 1;\n      Q.push(ney*c+nex);\n    }\n  }\n  return inf;\n}\n\nbool vis[N][N];\n\nint opt[N][N];\nint solve(int r,int c){\n  rep(i,r)rep(j,c)opt[i][j]=inf,vis[i][j]=false;\n  opt[r-1][c-1]=0;\n  while(true){\n    bool fg=false;\n    rep(i,r){\n      rep(j,c){\n\tint tmp = opt[i][j];\n\trep(k,4){\n\t  int nex=j+dx[k],ney=i+dy[k];\n\t  if (ney == -1 || nex == -1 || ney == r || nex == c || !edge[i][j][k] || opt[ney][nex] >= opt[i][j])continue;\n\t  edge[i][j][k]=false;\n\t  int a=bfs(r,c,i,j);\n\t  edge[i][j][k]=true;\n\t  //cout << ney <<\" \" << nex <<\" \" << 1+opt[ney][nex] <<\" \" << a << endl;\n\t  if (i == 0 && j == 1){\n\t    //cout <<i <<\" \" << j <<\" \" << ney <<\" \" << nex <<\" \" <<  k <<\" \" << 1+opt[ney][nex] <<\" \"<< a << endl;\n\t  }\n\t  opt[i][j]=min(opt[i][j],max(1+opt[ney][nex],a));\n\t}\n\t//cout << i <<\" \" << j <<\" \" << opt[i][j] <<\" \" <<  endl;\n\tif (opt[i][j] != tmp)fg=true;\n      }\n    }\n    if (!fg)break;\n  }\n  rep(i,r){\n    //rep(j,c)cout << opt[i][j] <<\" \" ;cout << endl;\n  }\n  return opt[0][0]==inf?-1:opt[0][0];\n}\n\nmain(){\n  int r,c;\n  while(cin>>r>>c && r){\n    rep(i,r)rep(j,c)rep(k,4)edge[i][j][k]=true;\n    rep(i,r){\n      rep(j,c-1){\n\tcin>>edge[i][j][0];edge[i][j][0]=1-edge[i][j][0];edge[i][j+1][1]=edge[i][j][0];\n      }\n      if (i == r-1)break;\n      rep(j,c){\n\tcin>>edge[i][j][2];edge[i][j][2]=1-edge[i][j][2];edge[i+1][j][3]=edge[i][j][2];\n      }\n    }\n    \n\n\n    cout << solve(r,c) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\nconst int di[]={1,0,-1,0},dj[]={0,1,0,-1};\nconst int inf=2000;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nbool exi[33][33][4];\nint dis[33][33][4][33][33];\nint ans[33][33];\nint W,H;\n\ninline bool isin(P p){\n\tint i=p.first,j=p.second;\n\treturn i>=0&&j>=0&&i<H&&j<W;\n}\ninline P mv(P p,int dir){\n\treturn P(p.first+di[dir],p.second+dj[dir]);\n}\n\nqueue<P> que;\nvoid bfs(P st,int dir){\n\tint si=st.first,sj=st.second;\n\twhile(!que.empty()) que.pop();\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++) dis[si][sj][dir][i][j]=inf;\n\tdis[si][sj][dir][si][sj]=0;\n\tif(isin(mv(st,dir))==false) return;\n\tif(exi[si][sj][dir]==false) return;\n\texi[si][sj][dir]=false;\n\tP tmp=mv(st,dir);\n\texi[tmp.first][tmp.second][(dir+2)%4]=false;\n\tque.push(st);\n\twhile(!que.empty()){\n\t\tP cur=que.front();\n\t\tque.pop();\n\t\tint cd=dis[si][sj][dir][cur.first][cur.second];\n\t\tfor(int d=0;d<4;d++){\n\t\t\tif(exi[cur.first][cur.second][d]==false) continue;\n\t\t\tP nxt=mv(cur,d);\n\t\t\tif(isin(nxt)==false) continue;\n\t\t\tif(dis[si][sj][dir][nxt.first][nxt.second]<=cd+1) continue;\n\t\t\tdis[si][sj][dir][nxt.first][nxt.second]=cd+1;\n\t\t\tque.push(nxt);\n\t\t}\n\t}\n\texi[si][sj][dir]=true;\n\texi[tmp.first][tmp.second][(dir+2)%4]=true;\n}\n\nvoid input(){\n\tscanf(\"%d%d\",&H,&W);\n\tif(H==0&&W==0) exit(0);\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W-1;j++){\n\t\t\tint in;\n\t\t\tscanf(\"%d\",&in);\n\t\t\tbool flg=(in==0);\n\t\t\texi[i][j][1]=flg;\n\t\t\texi[i][j+1][3]=flg;\n\t\t}\n\t\tif(i==H-1) break;\n\t\tfor(int j=0;j<W;j++){\n\t\t\tint in;\n\t\t\tscanf(\"%d\",&in);\n\t\t\tbool flg=(in==0);\n\t\t\texi[i][j][0]=flg;\n\t\t\texi[i+1][j][2]=flg;\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tfor(int k=0;k<4;k++){\n\t\t\tbfs(P(i,j),k);\n\t\t\tif(isin(mv(P(i,j),k))==false) continue;\n\t\t\t//if(exi[i][j][k]==true&&dis[i][j][k][H-1][W-1]==inf){\n\t\t\t//\tprintf(\"-1\\n\");\n\t\t\t\t/*printf(\"%d %d %d\\n\",i,j,k);\n\t\t\t\tfor(int ii=0;ii<H;ii++){\n\t\t\t\t\tfor(int jj=0;jj<W;jj++){\n\t\t\t\t\t\tprintf(\"%d \",dis[i][j][k][ii][jj]);\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t}*/\n\t\t//\t\texit(0);\n\t\t\t//\treturn;\n\t\t\t//}\n\t\t}\n\t}\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tans[i][j]=inf;\n\t}\n\tans[H-1][W-1]=0;\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tque.push(PP(0,P(H-1,W-1)));\n\twhile(!que.empty()){\n\t\tPP pp=que.top();\n\t\tque.pop();\n\t\tint cd=pp.first;\n\t\tP p=pp.second;\n\t\tif(ans[p.first][p.second]<cd) continue;\n\t\tfor(int d=0;d<4;d++){\n\t\t\tP nxt=mv(p,d);\n\t\t\tif(isin(nxt)==false) continue;\n\t\t\tif(exi[p.first][p.second][d]==false) continue;\n\t\t\tint d1=dis[nxt.first][nxt.second][(d+2)%4][H-1][W-1];\n\t\t\tint d2=cd+1;\n\t\t\tint nd=max(d1,d2);\n\t\t\tif(ans[nxt.first][nxt.second]<=nd) continue;\n\t\t\tans[nxt.first][nxt.second]=nd;\n\t\t\tque.push(PP(nd,nxt));\n\t\t}\n\t}\n\tint res=ans[0][0];\n\tif(res==inf) res=-1;\n\tprintf(\"%d\\n\",res);\n}\n\nint main(){\n\twhile(true){\n\t\tinput();\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstdio>\n#include <cstring>\n#include <climits>\nusing namespace std;\n\nconst int dx[] = {0, 1, 0, -1}; //上右下左\nconst int dy[] = {-1, 0, 1, 0};\nconst int inf = 1<<20;\n\nint w,h;\nint path[4][33][33];\nint dp[2000][33][33]; // [step][y][x] 最悪でも2000は越えないだろう…\nstring field[70];\n\nstruct state{\n    int x,y;\n    int step;\n    int worstStep;\n    state(int _x, int _y, int s, int w){\n        x = _x;\n        y = _y;\n        step = s;\n        worstStep = w;\n    }\n    bool operator<(const state& a)const{\n        if( worstStep == a.worstStep ) return step > a.step;\n        return worstStep > a.worstStep;\n    }\n};\n\n\nint bfs(int sx, int sy){\n    int k;\n    int memo[33][33];\n    queue<pair<int,int> > q;\n\n    memset(memo, -1, sizeof(memo));\n    q.push(make_pair(sx,sy));\n    memo[sy][sx] = 0;\n\n    while( !q.empty() ){\n        int x = q.front().first;\n        int y = q.front().second;\n        int s = memo[y][x];\n        q.pop();\n\n        for(k=0; k<4; k++){\n            int tx = 2*x + dx[k];\n            int ty = 2*y + dy[k];\n            if( tx < 0 || tx >= 2*w-1 || ty >= 2*h-1 || ty < 0 ) continue;\n            if( field[ty][tx] == '1' ) continue;\n\n            if( memo[y + dy[k]][x + dx[k]] == -1 ){\n                memo[y + dy[k]][x + dx[k]] = s + 1;\n                q.push(make_pair(x + dx[k], y + dy[k]));\n            }\n        }\n    }\n\n    return memo[h-1][w-1];\n}\n\n\nvoid setBrokenDoorToAllShortestPath(){\n    int i,j,k;\n\n    // 通れなかった場所からの最短距離を全て記録する\n    for(i=0; i<h; i++){\n        for(j=0; j<w; j++){\n            for(k=0; k<4; k++){\n                int tx = 2*j + dx[k];\n                int ty = 2*i + dy[k];\n                if( tx < 0 || tx >= 2*w-1 || ty >= 2*h-1 || ty < 0 ) continue;\n                if( field[ty][tx] == '1' ) continue;\n                field[ty][tx] = '1';\n                path[k][i][j] = bfs(j, i);\n                field[ty][tx] = '0';\n            }\n        }\n    }\n}\n\n\n\nint main(){\n    int i,j,k;\n\n    while( cin >> h >> w, h|w ){\n        cin.ignore();\n\n        // input\n        for(i=0; i<2*h-1; i++){\n            getline(cin, field[i]);\n            if( i % 2 == 0 ) field[i] += \" \";\n        }\n\n        // init\n        for(k=0; k<500; k++){\n            for(i=0; i<33; i++){\n                for(j=0; j<33; j++){\n                    dp[k][i][j] = inf;\n                }\n            }\n        }\n        memset(path, -1, sizeof(path));\n\n        setBrokenDoorToAllShortestPath();\n\n        priority_queue<state> q;\n        q.push(state(0,0,0,0));\n\n        while( !q.empty() ){\n            int x = q.top().x;\n            int y = q.top().y;\n            int step = q.top().step;\n            int wstep = q.top().worstStep;\n            q.pop();\n\n            if( wstep == inf || step > 500 ) break;\n\n            if( dp[step][y][x] <= wstep ) continue;\n            dp[step][y][x] = wstep;\n\n            if( y == h-1 && x == w-1 ) break;\n\n            //cout << \"step = \" << step << \", q.size = \" << q.size() << endl;\n\n            for(k=0; k<4; k++){\n                int tx = 2*x + dx[k];\n                int ty = 2*y + dy[k];\n                if( tx < 0 || tx >= 2*w-1 || ty >= 2*h-1 || ty < 0 ) continue;\n                if( field[ty][tx] == '1' ) continue;\n                \n                // ドアが壊れてたときの計算\n                int nextWorstStep = inf;\n                if( path[k][y][x] != -1 ){\n                    nextWorstStep = step + path[k][y][x];\n                }\n                nextWorstStep = max(wstep, nextWorstStep);\n\n                if( dp[step + 1][y + dy[k]][x + dx[k]] > nextWorstStep ){\n                    q.push(state(x + dx[k], y + dy[k], step + 1, nextWorstStep));\n                }\n\n            }\n        }\n\n        int ans = inf;\n        for(k=0; k<500; k++) ans = min(ans, dp[k][h-1][w-1]);\n\n        cout << (ans == inf ? -1 : ans) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#ifdef DEBUG_MODE\n    #define DBG(n) n;\n#else\n    #define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n \ntypedef long long ll;\ntypedef pair<pair<int,int>,int> P;\nint h,w;\npair<int,int> dp[33*33];\nint dist[33*33];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nvector<vector<int>> v(33*33);\n \nint fun(int a,int b){\n    REP(i,33*33)dist[i] = INF;\n    dist[a] = 0;\n    queue<pair<int,int>> q;\n    q.push(MP(a,0));\n    while(!q.empty()){\n        pair<int,int> now = q.front();q.pop();\n        int node = now.FI;\n        int kyo = now.SE;\n        if(kyo > dist[node])continue;\n        REP(i,v[node].size()){\n            int aite = v[node][i];\n            if((node == a && aite == b) || (node == b && aite == a))continue;\n            if(dist[aite] > kyo + 1){\n                dist[aite] = kyo + 1;\n                q.push(MP(aite,kyo+1));\n            }\n        }\n    }\n    return dist[h*w-1];\n}\n \nint main()\n{\n    while(cin >> h >> w,h|w){\n        //初期化\n        REP(i,33*33)dp[i] = MP(INF,INF);\n        REP(i,33*33){v[i].clear();}\n        dp[0] = MP(0,0);\n         \n        //入力\n        REP(i,h){\n            REP(j,w-1){\n                int tmp;cin >> tmp;\n                if(tmp == 0){\n                    v[i*w+j].PB(i*w+j+1);\n                    v[i*w+j+1].PB(i*w+j);\n                }\n                 \n            }\n            if(i != h-1)REP(j,w){\n                int tmp;cin >> tmp;\n                if(tmp == 0){\n                    v[i*w+j].PB((i+1)*w+j);\n                    v[(i+1)*w+j].PB(i*w+j);\n                }\n            }\n        }\n                 \n        priority_queue<P,vector<P>,greater<P>> q;\n        q.push(MP(MP(0,-1),0));\n        DBG(cout << \"!\" << endl;);\n        while(!q.empty()){\n            DBG(\n            cout << \"DP TABLE\" << endl;\n            REP(i,h){\n                REP(j,w){\n                    cout << dp[i*w+j].FI << ' ';\n                }\n                cout << endl;\n            }\n            )\n            P now = q.top();q.pop();\n            int node = now.SE;\n            pair<int,int> kyori = now.FI;\n            DBG(cout << kyori.FI << ' ' << kyori.SE << endl;)\n            DBG(cout << dp[node].FI << ' ' << dp[node].SE << endl;)\n            if(dp[node].FI < kyori.FI && dp[node].SE < kyori.SE)continue;\n            DBG(cout << \"IN\" << endl;)\n            kyori.SE++;\n            REP(i,v[node].size()){\n                int aite = v[node][i];\n                pair<int,int> score = MP(fun(node,aite)+kyori.SE,kyori.SE);\n                score = MP(max(dp[node].FI,score.FI),score.SE);\n                if(dp[aite].FI > score.FI || dp[aite].SE > score.SE){\n                    dp[aite].FI = min(dp[aite].FI,score.FI);\n                    dp[aite].SE = min(dp[aite].SE,score.SE);\n                    q.push(MP(score,aite));\n                }\n            }\n        }\n         \n        DBG(\n        cout << \"DP TABLE\" << endl;\n        REP(i,h){\n            REP(j,w){\n                cout << dp[i*w+j].FI << ' ';\n            }\n            cout << endl;\n        }\n        )\n         \n        DBG(cout << \"ANS IS \";);\n         \n        if(dp[h*w-1].FI == INF){\n            cout << -1 << endl;\n        }\n        else{\n            cout << dp[h*w-1].FI << endl;\n        }\n    }\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\nvector<string> line;\n\nstruct NODE{\n\tint id,cost,maximum;\n\tNODE(int id,int cost,int maximum) : id(id),cost(cost),maximum(maximum){}\n};\n\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.maximum > b.maximum;\n}\n\nmap< pair<int,int> , int> tmp;\nmap<int,int> XX,YY;\n\nint id(int x,int y){\n\tif( tmp.count(make_pair(x,y)) ) return tmp[make_pair(x,y)];\n\tint c = tmp.size();\n\tXX[c] = x;\n\tYY[c] = y;\n\treturn tmp[make_pair(x,y)] = c;\n}\n\nint X(int id){ return XX[id]; }\nint Y(int id){ return YY[id]; }\n\nint dx[] = { 0, 1, 0,-1};\nint dy[] = { 1, 0,-1, 0};\n\n\nint done[910][910]={};\n\nint main(){\n\tint H,W;\n\twhile(cin >> H >> W && H){\n\t\tint s = id(0,0);\n\t\tint g = id(2*W-2,2*H-2);\n\t\t\n\t\tline = vector<string>(H*2-1);\n\t\tgetline(cin,line[0]); //dummy\n\t\tfor(int i = 0 ; i < H*2-1 ; i++){\n\t\t\tgetline(cin,line[i]);\n\t\t\tif(!(i&1))line[i] += \" \";\n\t\t}\n\t\t\n\t\tint dir[62][62][2];\n\t\tfor(int i = 0 ; i < 62 ; i++)\n\t\t\tfor(int j = 0 ; j < 62 ; j++)\n\t\t\t\tfor(int k = 0 ; k < 2 ; k++)\n\t\t\t\t\tdir[i][j][k] = 1e9;\n\t\n\t\tint maximum = 0;\n\t\tfor(int y = 0 ; y < 2*H-1 ; y++){\n\t\t\tfor(int x = 0 ; x < 2*W ; x++){\n\t\t\t\tif( line[y][x] != '0' ) continue;\n\t\t\t\tline[y][x] = '1';\n\t\t\t\tint c1,c2;\n\t\t\t\tif( y % 2 == 0 ){\n\t\t\t\t\tc1 = id(x-1,y);\n\t\t\t\t\tc2 = id(x+1,y);\n\t\t\t\t}else{\n\t\t\t\t\tc1 = id(x,y-1);\n\t\t\t\t\tc2 = id(x,y+1);\n\t\t\t\t}\n\t\t\t\tfor(int k = 0 ; k < 2 ; k++){\n\t\t\t\t\t// test\n\t\t\t\t\tint tmp[2000];\n\t\t\t\t\tmemset(tmp,-1,sizeof(tmp));\n\t\t\t\t\tqueue<int> Q;\n\t\t\t\t\ttmp[c1] = 0;\n\t\t\t\t\tQ.push(c1);\n\t\t\t\t\twhile(Q.size()){\n\t\t\t\t\t\tint q = Q.front(); Q.pop();\n\t\t\t\t\t\tfor(int i = 0 ; i < 4 ; i++){\n\t\t\t\t\t\t\tint tx = X(q) + dx[i];\n\t\t\t\t\t\t\tint ty = Y(q) + dy[i];\n\t\t\t\t\t\t\tif( tx < 0 || tx >= line[0].size() || ty < 0 || ty >= line.size() || line[ty][tx] == '1') continue;\n\t\t\t\t\t\t\tint next = id(tx+dx[i],ty+dy[i]);\n\t\t\t\t\t\t\tif( tmp[next] == -1 ){\n\t\t\t\t\t\t\t\ttmp[next]=tmp[q]+1;\n\t\t\t\t\t\t\t\tQ.push(next);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif( tmp[g] != -1 ) \n\t\t\t\t\t\tdir[y][x][k] = tmp[g];\n\t\t\t\t\tswap(c1,c2);\n\t\t\t\t}\n\t\t\t\tline[y][x] = '0';\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(done,0,sizeof(done));\n\t\t\n\t\tpriority_queue<NODE> Q;\n\t\tQ.push(NODE(s,0,0));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\t\n\t\t\tif( q.cost > 905 ){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( done[q.id][q.cost]++ ) continue;\n\t\t\t\n\t\t\tif( q.maximum > 1e8 ) continue;\n\t\t\tif( q.id == g ){\n\t\t\t\tcout << q.maximum << endl;\n\t\t\t\tgoto veryok;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < 4 ; i++){\n\t\t\t\tint tx = X(q.id) + dx[i];\n\t\t\t\tint ty = Y(q.id) + dy[i];\n\t\t\t\tif( tx < 0 || tx >= line[0].size() || ty < 0 || ty >= line.size() || line[ty][tx] == '1') continue;\n\t\t\t\tint next = id(tx+dx[i],ty+dy[i]);\n\t\t\t\tint cost = q.cost + 1;\n\t\t\t\tint maximum = q.cost;\n\t\t\t\tif( ty % 2 == 0 ){\n\t\t\t\t\tif( dx[i] == 1 ) maximum += dir[ty][tx][0];\n\t\t\t\t\telse \t\t\t maximum += dir[ty][tx][1];\n\t\t\t\t}else{\n\t\t\t\t\tif( dy[i] == 1 ) maximum += dir[ty][tx][0];\n\t\t\t\t\telse \t\t\t maximum += dir[ty][tx][1];\n\t\t\t\t}\n\t\t\t\tQ.push(NODE(next,cost,max(q.maximum,maximum)));\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\tveryok:;\n\t\t/*\n\t\tcout << 2*H-1 << \" \" << 2*W-1 << endl;\n\t\tcout << shortest[id(2*H-1,2*W-1)] << endl;\n\t\t\n\t\tfor(int i = 0 ; i < 2*H-1 ; i++){\n\t\t\tfor(int j = 0 ; j < 2*W ; j++){\n\t\t\t\tif( shortest[id(j,i)] == -1 ) printf(\"     \");\n\t\t\t\telse  printf(\"%5d(%d,%d)\",shortest[id(j,i)],j,i);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nint h,w;\nint dp[33*33];\nint dist[33*33];\nint memo[33*33];\nbool used[33*33];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nvector<vector<int>> v(33*33);\n\nint fun(int a,int b){\n\tREP(i,33*33)dist[i] = INF;\n\tdist[a] = 0;\n\tqueue<pair<int,int>> q;\n\tq.push(MP(a,0));\n\twhile(!q.empty()){\n\t\tpair<int,int> now = q.front();q.pop();\n\t\tint node = now.FI;\n\t\tint kyo = now.SE;\n\t\tif(kyo > dist[node])continue;\n\t\tREP(i,v[node].size()){\n\t\t\tint aite = v[node][i];\n\t\t\tif((node == a && aite == b) || (node == b && aite == a))continue;\n\t\t\tif(dist[aite] > kyo + 1){\n\t\t\t\tdist[aite] = kyo + 1;\n\t\t\t\tq.push(MP(aite,kyo+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[h*w-1];\n}\n\nint main()\n{\n\twhile(cin >> h >> w,h|w){\n\t\t//初期化\n\t\tREP(i,33*33)dp[i] = INF;\n\t\tREP(i,33*33){v[i].clear();used[i] = false;}\n\t\tdp[0] = 0;\n\t\t\n\t\t//入力\n\t\tREP(i,h){\n\t\t\tREP(j,w-1){\n\t\t\t\tint tmp;cin >> tmp;\n\t\t\t\tif(tmp == 0){\n\t\t\t\t\tv[i*w+j].PB(i*w+j+1);\n\t\t\t\t\tv[i*w+j+1].PB(i*w+j);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tif(i != h-1)REP(j,w){\n\t\t\t\tint tmp;cin >> tmp;\n\t\t\t\tif(tmp == 0){\n\t\t\t\t\tv[i*w+j].PB((i+1)*w+j);\n\t\t\t\t\tv[(i+1)*w+j].PB(i*w+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfun(0,-1);\n\t\tREP(i,33*33)memo[i] = dist[i];\n\t\t\n\t\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\n\t\tq.push(MP(0,0));\n\t\t\n\t\twhile(!q.empty()){\n\t\t\tpair<int,int> now = q.top();q.pop();\n\t\t\tint node = now.SE;\n\t\t\tint kyori = now.FI;\n\t\t\tif(dp[node] < kyori)continue;\n\t\t\tused[node] = true;\n\t\t\t\n\t\t\tREP(i,v[node].size()){\n\t\t\t\tint aite = v[node][i];\n\t\t\t\tint score = fun(node,aite) + memo[node];\n\t\t\t\tif(dp[aite] > max(dp[node],score)){\n\t\t\t\t\tdp[aite] = max(dp[node],score);\n\t\t\t\t\tq.push(MP(dp[aite],aite));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tDBG(\n\t\tcout << \"DP TABLE\" << endl;\n\t\tREP(i,h){\n\t\t\tREP(j,w){\n\t\t\t\tcout << dp[i*w+j] << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t)\n\t\t\n\t\t\n\t\tDBG(cout << \"ANS IS \";);\n\t\tif(dp[h*w-1] == INF){\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << dp[h*w-1] << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nbool tate[32][32], yoko[32][32], v[32][32];\nint h, w;\n\nint calc(int y, int x){\n\t//return 0;\n\t\n\tbool v[32][32] = {};\n\tqueue<pi> q;\n\tq.push(mp(0, y * w + x));\n\twhile(!q.empty()){\n\t\ty = q.front().second / w, x = q.front().second % w;\n\t\tint c = q.front().first;\n\t\tq.pop();\n\t\tif(v[y][x]) continue;\n\t\tv[y][x] = 1;\n\t\t\n\t\tif(y == h - 1 && x == w - 1) return c;\n\t\trep(d, 4){\n\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\tif(d % 2 && tate[ny][max(nx, x)] || d % 2 == 0 && yoko[max(ny, y)][nx]) continue;\n\t\t\tif(!v[ny][nx]) q.push(mp(c + 1, ny * w + nx));\n\t\t}\n\t}\n\treturn inf;\n}\n\nint main(){\n\twhile(cin >> h >> w, h){\n\t\tmemset(tate, 1, sizeof(tate));\n\t\tmemset(yoko, 1, sizeof(yoko));\n\t\tmemset(v, 0, sizeof(v));\n\t\t\n\t\trep(i, h){\n\t\t\trep(j, w - 1) cin >> tate[i][j + 1];\n\t\t\tif(i < h - 1) rep(j, w) cin >> yoko[i + 1][j];\n\t\t}\n\t\tpriority_queue<pair<pi, int> > q;\n\t\tq.push(mp(mp(0, 0), 0));\n\t\twhile(!q.empty()){\n\t\t\tint cost = q.top().first.first, step = q.top().first.second;\n\t\t\tint y = q.top().second / w, x = q.top().second % w;\n\t\t\tq.pop();\n\t\t\t\n\t\t\tif(v[y][x]) continue;\n\t\t\tv[y][x] = 1;\n\t\t\tif(y == h - 1 && x == w - 1){\n\t\t\t\tcout << -cost << endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t\trep(d, 4){\n\t\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\t\t\n\t\t\t\tbool &k = d % 2 ? tate[ny][max(x, nx)] : yoko[max(ny, y)][nx];\n\t\t\t\tif(k) continue;\n\t\t\t\tk = 1;\n\t\t\t\tint nc = min(cost, min(step - calc(y, x), step - 1));\n\t\t\t\tif(!v[ny][nx] && nc > -inf) q.push(mp(mp(nc, step - 1), ny * w + nx));\n\t\t\t\tk = 0;\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\tEND:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<bitset>\n#include<queue>\n#include<tuple>\n#include<functional>\n#include<algorithm>\nusing namespace std;\n\nenum {N, E, S, W};\nconst unsigned long ALL = 1 + 2 + 4 + 8;\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\n\nconst int INF = 1000000000;\n\nenum {Y, X, STEP};\ntypedef tuple<int, int, int> Node;\n\nenum {DWORST, DSTEP, DY, DX};\ntypedef tuple<int, int, int, int> DNode;\n\nvector<vector<vector<int>>> memo;\n\nint h, w;\nvector<vector<bitset<4>>> wall;\n\nint bfs(int by, int bx, int bd) {\n    queue<Node> q;\n    vector<vector<int>> visited(h, vector<int>(w, 0));\n    q.push(Node(by, bx, 0));\n    while(!q.empty()) {\n        int y = get<Y>(q.front());\n        int x = get<X>(q.front());\n        int step = get<STEP>(q.front());\n        q.pop();\n        if(y == h - 1 && x == w - 1) return step;\n        if(visited[y][x]) continue;\n        visited[y][x] = 1;\n        for(int d = 0; d < 4; ++d) {\n            if(wall[y][x][d]) continue;\n            if(y == by && x == bx && d == bd) continue;\n            int ny = y + dy[d];\n            int nx = x + dx[d];\n            if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            q.push(Node(ny, nx, step + 1));\n        }\n    }\n    return INF;\n}\n\nint Dijkstra() {\n    priority_queue<DNode, vector<DNode>, greater<DNode>> q;\n    q.push(DNode(0, 0, 0, 0));\n    vector<vector<vector<int>>> visited(h, vector<vector<int>>(w, vector<int>(h * w * 2, 0)));\n    while(!q.empty()) {\n        int y = get<DY>(q.top());\n        int x = get<DX>(q.top());\n        int step = get<DSTEP>(q.top());\n        int worst = get<DWORST>(q.top());\n        q.pop();\n//         cout<<y<<\",\"<<x<<\" - \"<<step<<\" - \"<<worst<<endl;\n        if(y == h - 1 && x == w - 1) return worst;\n        if(visited[y][x][step]) continue;\n        visited[y][x][step] = 1;\n        for(int d = 0; d < 4; ++d) {\n            if(wall[y][x][d]) continue;\n            int ny = y + dy[d];\n            int nx = x + dx[d];\n            if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            int nworst = max({step + 1, worst, step + memo[y][x][d]});\n            q.push(DNode(nworst, step + 1, ny, nx));\n        }\n    }\n    return INF;\n}\n\nint main() {\n    while(cin >> h >> w, h | w) {\n        wall = vector<vector<bitset<4>>>(h, vector<bitset<4>>(w, bitset<4>(ALL)));\n        for(int i = 0; i < h - 1; ++i) {\n            for(int j = 0; j < w - 1; ++j) {\n                int is_wall;\n                cin >> is_wall;\n                if(is_wall) continue;\n                wall[i][j].reset(E);\n                wall[i][j + 1].reset(W);\n            }\n            for(int j = 0; j < w; ++j) {\n                int is_wall;\n                cin >> is_wall;\n                if(is_wall) continue;\n                wall[i][j].reset(S);\n                wall[i + 1][j].reset(N);\n            }\n        }\n        for(int j = 0; j < w - 1; ++j) {\n            int is_wall;\n            cin >> is_wall;\n            if(is_wall) continue;\n            wall[h - 1][j].reset(E);\n            wall[h - 1][j + 1].reset(W);\n        }\n\n        memo = vector<vector<vector<int>>>(h, vector<vector<int>>(w, vector<int>(4, INF)));\n        for(int i = 0; i < h; ++i) for(int j = 0; j < w; ++j) for(int d = 0; d < 4; ++d) memo[i][j][d] = bfs(i, j, d);\n\n        int answer = Dijkstra();\n        cout << (answer == INF ? -1 : answer) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);++i)\n#define rep(i,n) REP(i, 0, n)\ntypedef pair<int, int> pint;\n\nint H, W;\nstruct Edge { int num, to; Edge(int n, int t) : num(n), to(t) {}};\nvector<vector<Edge>> edges;\nbool bfs(int broken_edge, vector<int>& dist) {\n    dist[(H - 1) * W + W - 1] = 0;\n    queue<int> que; que.push((H - 1) * W + W - 1);\n    while(!que.empty()) {\n        int cur = que.front(); que.pop();\n        for(const Edge& e : edges[cur]) {\n            if(e.num == broken_edge || dist[e.to] != INF) continue;\n            dist[e.to] = dist[cur] + 1;\n            que.push(e.to);\n        }\n    }\n    return dist[0] == INF;\n}\n\nint solve(const vector<vector<int>>& wdist) {\n    vector<int> dist(H * W, INF);\n    priority_queue<pint, vector<pint>, greater<pint>> que;\n    dist[(H - 1) * W + W - 1] = 0; que.emplace(0, (H - 1) * W + W - 1);\n    auto upd = [](int& a, int b) { return a > b ? (a = b, true) : false;};\n    while(!que.empty()) {\n        int cos, node;\n        tie(cos, node) = que.top(); que.pop();\n        if(dist[node] < cos) continue;\n        for(const Edge& e : edges[node]) {\n            int ncos = max(cos + 1, wdist[e.num][e.to]);\n            if(upd(dist[e.to], ncos)) que.emplace(ncos, e.to);\n        }\n    }\n    return dist[0];\n}\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    while(cin >> H >> W && H) {\n        int t_, edgenum = 0;\n        edges.assign(H * W);\n        rep(i, H) {\n            rep(j, W - 1) {\n                cin >> t_;\n                if(t_ == 0) {\n                    edges[i * W + j].emplace_back(edgenum, i * W + j + 1);\n                    edges[i * W + j + 1].emplace_back(edgenum, i * W + j);\n                    ++edgenum;\n                }\n            }\n            if(i == H - 1) continue;\n            rep(j, W) {\n                cin >> t_;\n                if(t_ == 0) {\n                    edges[i * W + j].emplace_back(edgenum, (i + 1) * W + j);\n                    edges[(i + 1) * W + j].emplace_back(edgenum, i * W + j);\n                    ++edgenum;\n                }\n            }\n        }\n        vector<vector<int>> wdist(edgenum, vector<int>(H * W, INF));\n        rep(i, edgenum) if(bfs(i, wdist[i])) goto fail;\n        cout << solve(wdist) << endl;\n        continue;\n      fail:\n        cout << \"-1\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint t[50][50];\nint y[50][50];\nint bfs[40][40][4][40][40];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint v[50][50];\nint dir[50][50][4];\n\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\t//printf(\"%d %d\\n\",a,b);\n\t\tfor(int i=0;i<a*2-1;i++){\n\t\t\tif(i%2==0){\n\t\t\t\tfor(int j=0;j<b-1;j++)scanf(\"%d\",&y[i/2][j]);\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<b;j++)scanf(\"%d\",&t[i/2][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)for(int k=0;k<4;k++)dir[i][j][k]=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tif(i<a-1&&!t[i][j])dir[i][j][0]=1;\n\t\t\tif(j<b-1&&!y[i][j])dir[i][j][1]=1;\n\t\t\tif(i&&!t[i-1][j])dir[i][j][2]=1;\n\t\t\tif(j&&!y[i][j-1])dir[i][j][3]=1;\n\t\t}\n\t\tint left=0;\n\t\tint right=10000;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)for(int k=0;k<4;k++){\n\t\t\tif(!dir[i][j][k])continue;\n\t\t\tqueue<pair<int,int> >Q;\n\t\t\tfor(int l=0;l<a;l++)for(int m=0;m<b;m++)bfs[i][j][k][l][m]=-1;\n\t\t\tbfs[i][j][k][a-1][b-1]=0;\n\t\t\tQ.push(make_pair(a-1,b-1));\n\t\t\twhile(Q.size()){\n\t\t\t\tint row=Q.front().first;int col=Q.front().second;\n\t\t\t\tQ.pop();\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tif(row+dx[l]<0||row+dx[l]>=a||col+dy[l]<0||col+dy[l]>=b||~bfs[i][j][k][row+dx[l]][col+dy[l]])continue;\n\t\t\t\t\tif(!dir[row][col][l])continue;\n\t\t\t\t\tif(row+dx[l]==i&&col+dy[l]==j&&(l^2)==k)continue;\n\t\t\t\t\tif(row==i&&col==j&&l==k)continue;\n\t\t\t\t\tbfs[i][j][k][row+dx[l]][col+dy[l]]=bfs[i][j][k][row][col]+1;\n\t\t\t\t\tQ.push(make_pair(row+dx[l],col+dy[l]));\n\t\t\t\t}\n\t\t\t}\n\t/*\t\tprintf(\"%d %d %d\\n\",i,j,k);\n\t\t\tfor(int l=0;l<a;l++){\n\t\t\t\tfor(int m=0;m<b;m++)printf(\"%d \",bfs[i][j][k][l][m]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t*/\t}\n\t\twhile(left+1<right){\n\t\t\tint M=(left+right)/2;\n\t\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)v[i][j]=-1;\n\t\t\tqueue<pair<pair<int,int>,int> >Q2;\n\t\t\tQ2.push(make_pair(make_pair(0,0),0));\n\t\t\twhile(Q2.size()){\n\t\t\t\tint row=Q2.front().first.first;\n\t\t\t\tint col=Q2.front().first.second;\n\t\t\t\tint cost=Q2.front().second;\n\t\t\t\tQ2.pop();\n\t\t\t\tint val=0;\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tif(!dir[row][col][i])continue;\n\t\t\t\t\tif(!~bfs[row][col][i][row][col])val=999999999;\n\t\t\t\t\tval=max(val,bfs[row][col][i][row][col]);\n\t\t\t\t}\n\t\t\t//\tprintf(\"%d %d %d: %d %d %d\\n\",M,row,col,val,bfs[row][col],cost);\n\t\t\t\tif(val+cost<=M){\n\t\t\t\t\tv[row][col]=cost;\n\t\t\t\t}else continue;\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tif(row+dx[i]<0||row+dx[i]>=a||col+dy[i]<0||col+dy[i]>=b||~v[row+dx[i]][col+dy[i]])continue;\n\t\t\t\t\tif(i==0&&t[row][col])continue;\n\t\t\t\t\tif(i==1&&y[row][col])continue;\n\t\t\t\t\tif(i==2&&t[row-1][col])continue;\n\t\t\t\t\tif(i==3&&y[row][col-1])continue;\n\t\t\t\t///\tif(<=M){\n\t\t\t\t\tv[row+dx[i]][col+dy[i]]=-2;\n\t\t\t\t\t\tQ2.push(make_pair(make_pair(row+dx[i],col+dy[i]),cost+1));\n\t\t\t\t\t//}\n\t\t\t\t}\n\t\t\t}\n\t\t//\tprintf(\"\\n\");\n\t\t\tif(~v[a-1][b-1])right=M;\n\t\t\telse left=M;\n\t\t}\n\t\tif(right>9000)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",right);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n,m;\nvvi H,W;\nvvi dp,T;\n\nint main(){\n\twhile(cin>>n>>m,n){\n\t\tH=vvi(n-1,vi(m));\n\t\tW=vvi(n,vi(m-1));\n\t\trep(k,n-1){\n\t\t\trep(i,m-1)cin>>W[k][i];\n\t\t\trep(i,m)cin>>H[k][i];\n\t\t}\n\t\trep(i,m-1)cin>>W[n-1][i];\n\t\tT=dp=vvi(n,vi(m));\n\t\trep(i,n-1)rep(j,m)if(H[i][j]==0){\n\t\t\tH[i][j]=1;\n\t\t\t\n\t\t\trep(x,n)rep(y,m)T[x][y]=inf;\n\t\t\tT[n-1][m-1]=0;\n\t\t\tqueue<pii>q;\n\t\t\tq.push({n-1,m-1});\n\t\t\twhile(!q.empty()){\n\t\t\t\tpii t=q.front();\n\t\t\t\tq.pop();\n\t\t\t\trep(w,4){\n\t\t\t\t\tint x=t.first+dx[w];\n\t\t\t\t\tint y=t.second+dy[w];\n\t\t\t\t\tif(x<0||y<0||x>=n||y>=m)continue;\n\t\t\t\t\tif(w==0&&W[t.first][t.second])continue;\n\t\t\t\t\tif(w==1&&H[t.first][t.second])continue;\n\t\t\t\t\tif(w==2&&W[t.first][t.second-1])continue;\n\t\t\t\t\tif(w==3&&H[t.first-1][t.second])continue;\n\t\t\t\t\tif(T[x][y]>T[t.first][t.second]+1){\n\t\t\t\t\t\tT[x][y]=T[t.first][t.second]+1;\n\t\t\t\t\t\tq.push({x,y});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(x,n)rep(y,m)dp[x][y]=max(dp[x][y],T[x][y]);\n\t\t\tH[i][j]=0;\n\t\t}\n\t\trep(i,n)rep(j,m-1)if(W[i][j]==0){\n\t\t\tW[i][j]=1;\n\t\t\t\n\t\t\trep(x,n)rep(y,m)T[x][y]=inf;\n\t\t\tT[n-1][m-1]=0;\n\t\t\tqueue<pii>q;\n\t\t\tq.push({n-1,m-1});\n\t\t\twhile(!q.empty()){\n\t\t\t\tpii t=q.front();\n\t\t\t\tq.pop();\n\t\t\t\trep(w,4){\n\t\t\t\t\tint x=t.first+dx[w];\n\t\t\t\t\tint y=t.second+dy[w];\n\t\t\t\t\tif(x<0||y<0||x>=n||y>=m)continue;\n\t\t\t\t\tif(w==0&&W[t.first][t.second])continue;\n\t\t\t\t\tif(w==1&&H[t.first][t.second])continue;\n\t\t\t\t\tif(w==2&&W[t.first][t.second-1])continue;\n\t\t\t\t\tif(w==3&&H[t.first-1][t.second])continue;\n\t\t\t\t\tif(T[x][y]>T[t.first][t.second]+1){\n\t\t\t\t\t\tT[x][y]=T[t.first][t.second]+1;\n\t\t\t\t\t\tq.push({x,y});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(x,n)rep(y,m)dp[x][y]=max(dp[x][y],T[x][y]);\n\t\t\tW[i][j]=0;\n\t\t}\n\t\trep(i,n)rep(j,m)T[i][j]=inf;\n\t\tT[0][0]=dp[0][0];\n\t\tpriority_queue<tp>q;\n\t\tq.push(tp(-0,0,0));\n\t\twhile(!q.empty()){\n\t\t\tint x,y,cost;\n\t\t\ttie(cost,x,y)=q.top();\n\t\t\tcost*=-1;\n\t\t\tq.pop();\n\t\t\tif(T[x][y]<cost)continue;\n\t\t\trep(w,4){\n\t\t\t\tint nx=x+dx[w];\n\t\t\t\tint ny=y+dy[w];\n\t\t\t\tif(nx<0||ny<0||nx>=n||ny>=m)continue;\n\t\t\t\tif(w==0&&W[x][y])continue;\n\t\t\t\tif(w==1&&H[x][y])continue;\n\t\t\t\tif(w==2&&W[x][y-1])continue;\n\t\t\t\tif(w==3&&H[x-1][y])continue;\n\t\t\t\tint ncost=max(T[x][y],cost+1+dp[nx][ny]);\n\t\t\t\tif(T[nx][ny]>ncost){\n\t\t\t\t\tT[nx][ny]=ncost;\n\t\t\t\t\tq.push(tp(-cost-1,nx,ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tshow2d(dp);\n//\t\tshow2d(T);\n\t\tif(T[n-1][m-1]==inf)T[n-1][m-1]=-1;\n\t\tcout<<T[n-1][m-1]<<endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#ifdef DEBUG_MODE\n    #define DBG(n) n;\n#else\n    #define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n \ntypedef long long ll;\ntypedef pair<pair<int,int>,int> P;\nint h,w;\npair<int,int> dp[33*33];\nint dist[33*33];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nvector<vector<int>> v(33*33);\n \nint fun(int a,int b){\n    REP(i,33*33)dist[i] = INF;\n    dist[a] = 0;\n    queue<pair<int,int>> q;\n    q.push(MP(a,0));\n    while(!q.empty()){\n        pair<int,int> now = q.front();q.pop();\n        int node = now.FI;\n        int kyo = now.SE;\n        if(kyo > dist[node])continue;\n        REP(i,v[node].size()){\n            int aite = v[node][i];\n            if((node == a && aite == b) || (node == b && aite == a))continue;\n            if(dist[aite] > kyo + 1){\n                dist[aite] = kyo + 1;\n                q.push(MP(aite,kyo+1));\n            }\n        }\n    }\n    return dist[h*w-1];\n}\n \nint main()\n{\n    while(cin >> h >> w,h|w){\n        //初期化\n        REP(i,33*33)dp[i] = MP(INF,INF);\n        REP(i,33*33){v[i].clear();}\n        dp[0] = MP(0,0);\n         \n        //入力\n        REP(i,h){\n            REP(j,w-1){\n                int tmp;cin >> tmp;\n                if(tmp == 0){\n                    v[i*w+j].PB(i*w+j+1);\n                    v[i*w+j+1].PB(i*w+j);\n                }\n                 \n            }\n            if(i != h-1)REP(j,w){\n                int tmp;cin >> tmp;\n                if(tmp == 0){\n                    v[i*w+j].PB((i+1)*w+j);\n                    v[(i+1)*w+j].PB(i*w+j);\n                }\n            }\n        }\n                 \n        priority_queue<P,vector<P>,greater<P>> q;\n        q.push(MP(MP(0,-1),0));\n        DBG(cout << \"!\" << endl;);\n        while(!q.empty()){\n            DBG(\n            cout << \"DP TABLE\" << endl;\n            REP(i,h){\n                REP(j,w){\n                    cout << dp[i*w+j].FI << ' ';\n                }\n                cout << endl;\n            }\n            )\n            P now = q.top();q.pop();\n            int node = now.SE;\n            pair<int,int> kyori = now.FI;\n            DBG(cout << kyori.FI << ' ' << kyori.SE << endl;)\n            DBG(cout << dp[node].FI << ' ' << dp[node].SE << endl;)\n            if(dp[node].FI < kyori.FI && dp[node].SE < kyori.SE)continue;\n            DBG(cout << \"IN\" << endl;)\n            kyori.SE++;\n            REP(i,v[node].size()){\n                int aite = v[node][i];\n                pair<int,int> score = MP(fun(node,aite)+kyori.SE,kyori.SE);\n                score = MP(max(dp[node].FI,score.FI),score.SE);\n                if(dp[aite].FI > score.FI || dp[aite].SE > score.SE){\n                    dp[aite].FI = min(dp[aite].FI,score.FI);\n                    dp[aite].SE = min(dp[aite].SE,score.SE);\n                    q.push(MP(score,aite));\n                }\n            }\n        }\n         \n        DBG(\n        cout << \"DP TABLE\" << endl;\n        REP(i,h){\n            REP(j,w){\n                cout << dp[i*w+j].FI << ' ';\n            }\n            cout << endl;\n        }\n        )\n         \n        DBG(cout << \"ANS IS \";);\n         \n        if(dp[h*w-1].FI == INF){\n            cout << -1 << endl;\n        }\n        else{\n            cout << dp[h*w-1].FI << endl;\n        }\n    }\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 31;\n\nint h,w;\nint tate[MAX_N][MAX_N];\nint yoko[MAX_N][MAX_N];\nint tt[MAX_N][MAX_N][2];\nint yk[MAX_N][MAX_N][2];\nint d[MAX_N*MAX_N];\n\nbool possible(int cri)\n{\n    rep(i,h){\n        rep(j,w){\n            d[i*w+j] = INF;\n        }\n    }\n    queue<int> que;\n    que.push(0);\n    d[0] = 0;\n    while(!que.empty()){\n        int p = que.front();\n        que.pop();\n        int x = p / w, y = p % w;\n        if(y < w-1 && !yoko[x][y] && d[x*w+y+1] > d[p] + 1 && d[p] + yk[x][y][0] <= cri){\n            d[x*w+y+1] = d[p] + 1;\n            que.push(x*w+y+1);\n        }\n        if(y > 0 && !yoko[x][y-1] && d[x*w+y-1] > d[p] + 1 && d[p] + yk[x][y-1][1] <= cri){\n            d[x*w+y-1] = d[p] + 1;\n            que.push(x*w+y-1);\n        }\n        if(x < h-1 && !tate[x][y] && d[(x+1)*w+y] > d[p] + 1 && d[p] + tt[x][y][0] <= cri){\n            d[(x+1)*w+y] = d[p] + 1;\n            que.push((x+1)*w+y);\n        }\n        if(x > 0 && !tate[x-1][y] && d[(x-1)*w+y] > d[p] + 1 && d[p] + tt[x-1][y][1] <= cri){\n            d[(x-1)*w+y] = d[p] + 1;\n            que.push((x-1)*w+y);\n        }\n    }\n    return (d[h*w-1] != INF);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        cin >> h >> w;\n        if(h == 0 && w == 0){\n            break;\n        }\n        rep(i,2*h-1){\n            if(i % 2){\n                rep(j,w){\n                    cin >> tate[i/2][j];\n                }\n            }else{\n                rep(j,w-1){\n                    cin >> yoko[i/2][j];\n                }\n            }\n        }\n        rep(i,h){\n            rep(j,w-1){\n                if(!yoko[i][j]){\n                    yoko[i][j] = 1;\n                    rep(k,2){\n                        int pos = w*i+j+k;\n                        rep(l,h){\n                            rep(r,w){\n                                d[l*w+r] = INF;\n                            }\n                        }\n                        queue<int> que;\n                        d[pos] = 0;\n                        que.push(pos);\n                        while(!que.empty()){\n                            int p = que.front();\n                            que.pop();\n                            int x = p / w, y = p % w;\n                            if(y < w-1 && !yoko[x][y] && d[x*w+y+1] > d[p] + 1){\n                                d[x*w+y+1] = d[p] + 1;\n                                que.push(x*w+y+1);\n                            }\n                            if(y > 0 && !yoko[x][y-1] && d[x*w+y-1] > d[p] + 1){\n                                d[x*w+y-1] = d[p] + 1;\n                                que.push(x*w+y-1);\n                            }\n                            if(x < h-1 && !tate[x][y] && d[(x+1)*w+y] > d[p] + 1){\n                                d[(x+1)*w+y] = d[p] + 1;\n                                que.push((x+1)*w+y);\n                            }\n                            if(x > 0 && !tate[x-1][y] && d[(x-1)*w+y] > d[p] + 1){\n                                d[(x-1)*w+y] = d[p] + 1;\n                                que.push((x-1)*w+y);\n                            }\n                        }\n                        yk[i][j][k] = d[h*w-1];\n                    }\n                    yoko[i][j] = 0;\n                }\n            }\n        }\n        rep(i,h-1){\n            rep(j,w){\n                if(!tate[i][j]){\n                    tate[i][j] = 1;\n                    rep(k,2){\n                        int pos = (w+k)*i+j;\n                        rep(l,h){\n                            rep(r,w){\n                                d[l*w+r] = INF;\n                            }\n                        }\n                        queue<int> que;\n                        d[pos] = 0;\n                        que.push(pos);\n                        while(!que.empty()){\n                            int p = que.front();\n                            que.pop();\n                            int x = p / w, y = p % w;\n                            if(y < w-1 && !yoko[x][y] && d[x*w+y+1] > d[p] + 1){\n                                d[x*w+y+1] = d[p] + 1;\n                                que.push(x*w+y+1);\n                            }\n                            if(y > 0 && !yoko[x][y-1] && d[x*w+y-1] > d[p] + 1){\n                                d[x*w+y-1] = d[p] + 1;\n                                que.push(x*w+y-1);\n                            }\n                            if(x < h-1 && !tate[x][y] && d[(x+1)*w+y] > d[p] + 1){\n                                d[(x+1)*w+y] = d[p] + 1;\n                                que.push((x+1)*w+y);\n                            }\n                            if(x > 0 && !tate[x-1][y] && d[(x-1)*w+y] > d[p] + 1){\n                                d[(x-1)*w+y] = d[p] + 1;\n                                que.push((x-1)*w+y);\n                            }\n                        }\n                        tt[i][j][k] = d[h*w-1];\n                    }\n                    tate[i][j] = 0;\n                }\n            }\n        }\n        int l = 0, r = 2*w*h-h-w;\n        if(!possible(r)){\n            cout << \"-1\\n\";\n            continue;\n        }\n        while(r-l>1){\n            int mid = (l+r)/2;\n            if(possible(mid)){\n                r = mid;\n            }else{\n                l = mid;\n            }\n        }\n        cout << r << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n, m, bak, cl, qx[909], qy[909], dis[33][33], pas[77][77], x, y, dx[4], dy[4], mn[33][33], ans[77][77][2];\nint main()\n{\n\tdx[0] = -1; dy[0] = 0;\n\tdx[1] = 0; dy[1] = -1;\n\tdx[2] = +1; dy[2] = 0;\n\tdx[3] = 0; dy[3] = +1;\n\t\tfor(;;)\n\t{\n\tfor(int i = 0; i < 77; i++) for(int j = 0; j < 77; j++) pas[i][j] = 1;\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(!n or !m)\n\t\t\tbreak;\n\t\t//printf(\"%d %d\\n\", n, m);\n\t\tfor(int i = 1; i <= 2 * n - 1; i++)\n\t\t{\n\t\t\tif(i & 1)\n\t\t\t{\n\t\t\t\tfor(int j = 1; j < m; j++)\n\t\t\t\t{\n\t\t\t\t\tscanf(\"%d\", &pas[i + 1][j * 2 + 1]);\n\t\t\t\t}\n\t\t\t}else\n\t\t\t{\n\t\t\t\tfor(int j = 1; j <= m; j++)\n\t\t\t\t{\n\t\t\t\t\tscanf(\"%d\", &pas[i + 1][j * 2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag = true;\n\t\tfor(int i = 2; i <= 2 * n; i++) for(int j = 2; j <= 2 * m; j++) if(i % 2 == 1 xor j % 2 == 1)\n\t\t{\n\t\t\t//\tprintf(\"%d %d\\n\", i,j);\n\t\t\tbak = pas[i][j];\n\t\t\tpas[i][j] = 1;\n\n\t\t\tqx[cl = 1] = n;\n\t\t\tqy[1] = m;\n\t\t\tfor(int i1 = 1; i1 <= n; i1++) for(int j1 = 1; j1 <= m; j1++) dis[i1][j1] = -1;\n\t\t\tdis[n][m] = 0;\n\t\t\tfor(int op = 1; op <= cl; op++)\n\t\t\t{\n\t\t\t//\tprintf(\"%d\\n\", op);\n\t\t\t\tx = qx[op]; y = qy[op];\n\t\t\t\tfor(int d = 0; d < 4; d++)\n\t\t\t\t{\n\t\t\t\t//\tprintf(\"%d %d\\n\", x + dx[d], y + dy[d]);\n\t\t\t\t\tif(!pas[2 * x + dx[d]][2 * y + dy[d]] and dis[x + dx[d]][y + dy[d]] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdis[x + dx[d]][y + dy[d]] = dis[x][y] + 1;\n\t\t\t\t\t\tqx[++cl] = x + dx[d];\n\t\t\t\t\t\tqy[cl] = y + dy[d];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dis[1][1] == -1) {flag = false; break;}\n\t\t\tans[i][j][0] = dis[i / 2][j / 2];\n\t\t\tans[i][j][1] = dis[(i + 1) / 2][(j + 1) / 2];\n\t\t//\tprintf(\"ans[%d][%d][%d] = %d, ans[%d][%d][%d] = %d, \\n\", i, j,0, ans[i][j][0], i, j, 1, ans[i][j][1]);\n\t\t\tpas[i][j] = bak;\n\t\t}\n\t\tif(!flag) {printf(\"-1\\n\"); continue;}\n\t\tfor(int i = 1; i <= n; i++) for(int j = 1; j <= m; j++) mn[i][j] = 0x3fffffff;\n\t\tmn[n][m] = 0;\n\t\tqx[cl = 1] = n;\n\t\tqy[1] = m;\n\t\tfor(int op = 1; op <= cl; op++)\n\t\t{\n\t\t\tx = qx[op]; y = qy[op];\n\t\t\tfor(int d = 0; d < 4; d++)if(!pas[x * 2 + dx[d]][y * 2 + dy[d]])\n\t\t\t{\n\t\t\t\tint tmp = max(1 + mn[x][y], ans[x * 2 + dx[d]][y * 2 + dy[d]][(dx[d] + dy[d]) == 1?1:0]);\n\t\t\t\t//printf(\"%d %d %d\\n\", x, y, tmp);\n\t\t\t\tif(mn[x + dx[d]][y + dy[d]] > tmp)\n\t\t\t\t{\n\t\t\t\t\tmn[x + dx[d]][y + dy[d]] = tmp;\n\t\t\t\t\tqx[++cl] = x + dx[d];\n\t\t\t\t\tqy[cl] = y + dy[d];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", mn[1][1]);\n\t}\n\tfclose(stdin);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 30;\n\nint h,w;\nbool maze[30][30][4];\n\nstruct state{\n\tint x;\n\tint y;\n\tint cost;\n\tbool operator <(const state& a)const{ return cost < a.cost; }\n\tbool operator >(const state& a)const{ return cost > a.cost; }\n};\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint bfs(int sx,int sy){\n\tbool visited[30][30];\n\trep(i,w)rep(j,h) visited[i][j]=false;\n\tstate init;\n\tinit.x=sx;init.y=sy;init.cost=0;\n\tvisited[sx][sy]=true;\n\tqueue<state> q;\n\tq.push(init);\n\n\twhile(!q.empty()){\n\t\tstate cur=q.front();q.pop();\n\t\tif(cur.x==w-1 && cur.y==h-1)\n\t\t\treturn cur.cost;\n\n\t\t//cout << cur.x << \" \" << cur.y << \" \" << cur.cost<< endl;\n\n\t\trep(i,4){\n\t\t\tstate next;\n\t\t\tnext=cur;\n\t\t\tnext.x+=dx[i];\n\t\t\tnext.y+=dy[i];\n\t\t\tnext.cost++;\n\t\t\n\t\t\tif(0<=next.x&&next.x<w && 0<=next.y && next.y<h && maze[cur.x][cur.y][i]){\n\t\t\t\tif(!visited[next.x][next.y]){\n\t\t\t\t\tvisited[next.x][next.y]=true;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\t//cout << \"here ?\" << endl;\n\treturn inf;\n}\n\nint dijkstra(void){\n\tint dp[30][30];\n\trep(i,w)rep(j,h) dp[i][j]=inf;\n\tdp[w-1][h-1]=0;\n\tstate init;\n\tinit.x=w-1;init.y=h-1;init.cost=0;\n\tpriority_queue< state,vector<state>, greater<state> > q;\n\tq.push(init);\n\twhile(!q.empty()){\n\t\tstate cur=q.top(); q.pop();\n\t\tif(cur.cost > dp[cur.x][cur.y])\n\t\t\tcontinue;\n\t\t\n\t\tif(cur.x==0 && cur.y==0)\n\t\t\treturn cur.cost;\n\n\t\trep(i,4){\n\t\t//\tcout << cur.x << \" \" << cur.y  << \" \" << i << endl;\n\t\t\tstate next=cur;\n\t\t\tnext.x+=dx[i];\n\t\t\tnext.y+=dy[i];\n\n\t\t\tif(0<=next.x&&next.x<w && 0<=next.y && next.y<h && maze[cur.x][cur.y][i]){\n\t\t\t\tmaze[cur.x][cur.y][i]=false;\n\t\t\t\tmaze[next.x][next.y][(i+2)%4]=false;\n\t\t\t\n\t\t\t\tnext.cost=max(cur.cost+1,bfs(next.x,next.y));\n\t\t\t\t\n\t\t\t\tif(next.cost < dp[next.x][next.y]){\n\t\t\t\t\tdp[next.x][next.y]=next.cost;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\n\t\t\t\tmaze[cur.x][cur.y][i]=true;\n\t\t\t\tmaze[next.x][next.y][(i+2)%4]=true;\n\t\t\t}\n\t\t}\n\t}\n\treturn inf;\n}\nint main(void){\n\t\n\twhile(cin >> h >> w,h|w){\n\t\trep(i,2*h-1){\n\t\t\tif(i&1){\n\t\t\t\trep(j,w){  //ud\n\t\t\t\t\tint tmp;\t\n\t\t\t\t\tcin >> tmp;\n\t\t\t\t\ttmp=1-tmp;\n\t\t\t\t\tmaze[j][i/2][1]=tmp;\n\t\t\t\t\tmaze[j][i/2+1][3]=tmp;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\trep(j,w-1){ //lr\n\t\t\t\t\tint tmp;\n\t\t\t\t\tcin >> tmp;\n\t\t\t\t\ttmp=1-tmp;\n\t\t\t\t\tmaze[j][i/2][0]=tmp;\n\t\t\t\t\tmaze[j+1][i/2][2]=tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=dijkstra();\n\t\tif(ans==inf)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 31;\n\nint h,w;\nint tate[MAX_N][MAX_N];\nint yoko[MAX_N][MAX_N];\nint tt[MAX_N][MAX_N][2];\nint yk[MAX_N][MAX_N][2];\nint d[MAX_N*MAX_N];\n\nbool possible(int cri)\n{\n    rep(i,h){\n        rep(j,w){\n            d[i*w+j] = INF;\n        }\n    }\n    queue<int> que;\n    que.push(0);\n    d[0] = 0;\n    while(!que.empty()){\n        int p = que.front();\n        que.pop();\n        int x = p / w, y = p % w;\n        if(y < w-1 && !yoko[x][y] && d[x*w+y+1] > d[p] + 1 && d[p] + yk[x][y][0] <= cri){\n            d[x*w+y+1] = d[p] + 1;\n            que.push(x*w+y+1);\n        }\n        if(y > 0 && !yoko[x][y-1] && d[x*w+y-1] > d[p] + 1 && d[p] + yk[x][y-1][1] <= cri){\n            d[x*w+y-1] = d[p] + 1;\n            que.push(x*w+y-1);\n        }\n        if(x < h-1 && !tate[x][y] && d[(x+1)*w+y] > d[p] + 1 && d[p] + tt[x][y][0] <= cri){\n            d[(x+1)*w+y] = d[p] + 1;\n            que.push((x+1)*w+y);\n        }\n        if(x > 0 && !tate[x-1][y] && d[(x-1)*w+y] > d[p] + 1 && d[p] + tt[x-1][y][1] <= cri){\n            d[(x-1)*w+y] = d[p] + 1;\n            que.push((x-1)*w+y);\n        }\n    }\n    return (d[h*w-1] != INF);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        cin >> h >> w;\n        if(h == 0 && w == 0){\n            break;\n        }\n        rep(i,2*h-1){\n            if(i % 2){\n                rep(j,w){\n                    cin >> tate[i/2][j];\n                }\n            }else{\n                rep(j,w-1){\n                    cin >> yoko[i/2][j];\n                }\n            }\n        }\n        rep(i,h){\n            rep(j,w-1){\n                if(!yoko[i][j]){\n                    yoko[i][j] = 1;\n                    rep(k,2){\n                        int pos = w*i+j+k;\n                        rep(l,h){\n                            rep(r,w){\n                                d[l*w+r] = INF;\n                            }\n                        }\n                        queue<int> que;\n                        d[pos] = 0;\n                        que.push(pos);\n                        while(!que.empty()){\n                            int p = que.front();\n                            que.pop();\n                            int x = p / w, y = p % w;\n                            if(y < w-1 && !yoko[x][y] && d[x*w+y+1] > d[p] + 1){\n                                d[x*w+y+1] = d[p] + 1;\n                                que.push(x*w+y+1);\n                            }\n                            if(y > 0 && !yoko[x][y-1] && d[x*w+y-1] > d[p] + 1){\n                                d[x*w+y-1] = d[p] + 1;\n                                que.push(x*w+y-1);\n                            }\n                            if(x < h-1 && !tate[x][y] && d[(x+1)*w+y] > d[p] + 1){\n                                d[(x+1)*w+y] = d[p] + 1;\n                                que.push((x+1)*w+y);\n                            }\n                            if(x > 0 && !tate[x-1][y] && d[(x-1)*w+y] > d[p] + 1){\n                                d[(x-1)*w+y] = d[p] + 1;\n                                que.push((x-1)*w+y);\n                            }\n                        }\n                        yk[i][j][k] = d[h*w-1];\n                    }\n                    yoko[i][j] = 0;\n                }\n            }\n        }\n        rep(i,h-1){\n            rep(j,w){\n                if(!tate[i][j]){\n                    tate[i][j] = 1;\n                    rep(k,2){\n                        int pos = (w+k)*i+j;\n                        rep(l,h){\n                            rep(r,w){\n                                d[l*w+r] = INF;\n                            }\n                        }\n                        queue<int> que;\n                        d[pos] = 0;\n                        que.push(pos);\n                        while(!que.empty()){\n                            int p = que.front();\n                            que.pop();\n                            int x = p / w, y = p % w;\n                            if(y < w-1 && !yoko[x][y] && d[x*w+y+1] > d[p] + 1){\n                                d[x*w+y+1] = d[p] + 1;\n                                que.push(x*w+y+1);\n                            }\n                            if(y > 0 && !yoko[x][y-1] && d[x*w+y-1] > d[p] + 1){\n                                d[x*w+y-1] = d[p] + 1;\n                                que.push(x*w+y-1);\n                            }\n                            if(x < h-1 && !tate[x][y] && d[(x+1)*w+y] > d[p] + 1){\n                                d[(x+1)*w+y] = d[p] + 1;\n                                que.push((x+1)*w+y);\n                            }\n                            if(x > 0 && !tate[x-1][y] && d[(x-1)*w+y] > d[p] + 1){\n                                d[(x-1)*w+y] = d[p] + 1;\n                                que.push((x-1)*w+y);\n                            }\n                        }\n                        tt[i][j][k] = d[h*w-1];\n                    }\n                    tate[i][j] = 0;\n                }\n            }\n        }\n        int l = 0, r = 10000;\n        if(!possible(r)){\n            cout << \"-1\\n\";\n            continue;\n        }\n        while(r-l>1){\n            int mid = (l+r)/2;\n            if(possible(mid)){\n                r = mid;\n            }else{\n                l = mid;\n            }\n        }\n        cout << r << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<int,P>P2;\n \nint dist[30][30][30][30][4];\nint used[30][30],h,w;\nbool v[30][30][4];\n\nint ans[33][33];\n\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\n\nstring s[303];\n\nvoid bfs(int Y,int X,int K){\n    dist[h-1][w-1][Y][X][K]=0;\n    queue<int>q;\n    q.push((h-1)*1000+(w-1));\n    while(!q.empty()){\n        int now=q.front();q.pop();\n        int y=now/1000;\n        int x=now%1000;\n        r(i,4){\n            int ny=y+dy[i];\n            int nx=x+dx[i];\n            if(ny<0||nx<0||h<=ny||w<=nx)continue;\n           // cout<<y<<' '<<x<<' '<<i<<endl;\n            if(!v[y][x][i])continue;\n            if(dist[ny][nx][Y][X][K]!=1e9)continue;\n\n            dist[ny][nx][Y][X][K] = dist[y][x][Y][X][K]+1;\n            q.push(ny*1000+nx);\n        }\n    }\n    //cout<<dist[0][1][Y][X][K]<<endl;\n}\n\nint bfs2(){\n    r(i,33)r(j,33)ans[i][j]=1e9;\n    memset(used,-1,sizeof(used));\n    priority_queue<P2,vector<P2>,greater<P2> >q;\n    q.push(P2(0,P(h-1,w-1)));\n    ans[h-1][w-1]=0;;\n    while(!q.empty()){\n        P2 now=q.top();q.pop();\n        int cost=now.first;\n        int y=now.second.first;\n        int x=now.second.second;\n        if(ans[y][x] < cost)continue;\n        r(i,4){\n            int ny=y+dy[i];\n            int nx=x+dx[i];\n            if(ny<0||nx<0||h<=ny||w<=nx)continue;\n            if(!v[y][x][i])continue;\n            int ncos=max(cost+1,dist[ny][nx][y][x][i]);\n            if(ans[ny][nx] <= ncos)continue;\n            ans[ny][nx] = ncos;\n            q.push(P2(ncos,P(ny,nx)));\n        }\n    }\n    return ans[0][0];\n}\n\nsigned main(){\n    while(cin>>h>>w,h){\n        getline(cin,s[0]);\n        r(i,h*2-1){\n            getline(cin,s[i]);\n        }\n        r(a,30)r(b,30)r(c,30)r(d,30)r(e,4)dist[a][b][c][d][e]=1e9;\n        memset(v,0,sizeof(v));\n        for(int i=0;i<h*2-1;i+=2){\n            for(int j=0;j<w*2-1;j+=2){\n                for(int k=0;k<4;k++){\n                    int y=i+dy[k];\n                    int x=j+dx[k];\n                    if(y<0||x<0|| h*2-1<=y || w*2-1<=x)continue;\n                    if(s[y][x]=='0'){\n                        v[i/2][j/2][k]=1;\n                    }\n                }\n            }\n        }\n        r(i,h)r(j,w)r(k,4){\n            if(!v[i][j][k])continue;\n            v[i][j][k]=0;\n            //exit(0);\n            bfs(i,j,k);\n            v[i][j][k]=1;\n        }\n        int ANS=bfs2();\n        if(ANS==1e9)cout<<-1<<endl;\n        else cout<<ANS<<endl;\n\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nconstexpr int inf = 1e9;\nconstexpr int dx[4] = {0, 1, 0, -1};\nconstexpr int dy[4] = {1, 0, -1, 0};\n\nint main() {\n    int h, w;\n    while(cin >> h >> w, h) {\n        vector<vector<int>> horz(h - 1, vector<int>(w)), vert(h, vector<int>(w - 1));\n        for(int i = 0; i < 2 * h - 1; ++i) {\n            auto& v = (i & 1 ? horz : vert);\n            for(int j = 0; j < w - 1 + (i & 1); ++j) {\n                cin >> v[i / 2][j];\n            }\n        }\n\n        auto in_range = [&] (int y, int x) {\n            return 0 <= y && y < h && 0 <= x && x < w;\n        };\n        auto get_wall = [&] (int ny, int nx, int d) {\n            if(d == 0) return &horz[ny - 1][nx];\n            if(d == 1) return &vert[ny][nx - 1];\n            if(d == 2) return &horz[ny][nx];\n            if(d == 3) return &vert[ny][nx];\n            assert(false);\n        };\n        std::function<int(int, int)> bfs = [&] (int sy, int sx) {\n            queue<pii> que;\n            vector<vector<int>> dist(h, vector<int>(w, inf));\n            dist[sy][sx] = 0;\n            que.emplace(sy, sx);\n            while(!que.empty()) {\n                auto p = que.front();\n                const int y = p.first, x = p.second;\n                que.pop();\n                for(int i = 0; i < 4; ++i) {\n                    int ny = y + dy[i], nx = x + dx[i];\n                    if(!in_range(ny, nx) || *get_wall(ny, nx, i) == 1 || dist[ny][nx] != inf) continue;\n                    dist[ny][nx] = dist[y][x] + 1;\n                    que.emplace(ny, nx);\n                }\n            }\n            return dist[h - 1][w - 1];\n        };\n        vector<vector<int>> broken_dist(h, vector<int>(w));\n        for(int i = 0; i < h; ++i) {\n            for(int j = 0; j < w; ++j) {\n                for(int d = 0; d < 4; ++d) {\n                    int ny = i + dy[d], nx = j + dx[d];\n                    if(!in_range(ny, nx) || *get_wall(ny, nx, d) == 1) continue;\n                    *get_wall(ny, nx, d) = 1;\n                    broken_dist[i][j] = max(broken_dist[i][j], bfs(i, j));\n                    *get_wall(ny, nx, d) = 0;\n                }\n            }\n        }\n\n        using state = tuple<int, int, int, int>;\n        vector<vector<vector<int>>> d(h, vector<vector<int>>(w, vector<int>(h * w, inf)));\n        priority_queue<state, vector<state>, greater<state>> que;\n        d[0][0][0] = broken_dist[0][0];\n        que.emplace(broken_dist[0][0], 0, 0, 0);\n        while(!que.empty()) {\n            int cur_d, step, y, x;\n            tie(cur_d, step, y, x) = que.top();\n            que.pop();\n            if(cur_d > d[y][x][step] || step + 1 >= h * w) continue;\n            for(int i = 0; i < 4; ++i) {\n                int ny = y + dy[i], nx = x + dx[i];\n                if(!in_range(ny, nx) || *get_wall(ny, nx, i) == 1) continue;\n                int nxt_d = max(cur_d, broken_dist[ny][nx] + step + 1);\n                if(d[ny][nx][step + 1] > nxt_d) {\n                    que.emplace(nxt_d, step + 1, ny, nx);\n                    d[ny][nx][step + 1] = nxt_d;\n                }\n            }\n        }\n\n        const int ans = *min_element(begin(d[h - 1][w - 1]), end(d[h - 1][w - 1]));\n        cout << (ans == inf ? -1 : ans) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Node {\n  int x;\n  int y;\n  int cost;\n  Node(int x, int y, int cost) : x(x), y(y), cost(cost) {;}\n};\n\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\nint h, w;\nint field[100][100][4];\nint memo[2000][32][32];\nint dist[32][32][4];\nbool visit[32][32];\n\nint d(int sx, int sy , int dir) {\n  if (dist[sy][sx][dir] != -1) { return dist[sy][sx][dir]; }\n  MEMSET(visit, false);\n  int ret = 20000;\n  field[sy][sx][dir] = 1;\n  queue<Node> que;\n  que.push(Node(sx, sy, 0));\n  while (!que.empty()) {\n    Node p = que.front();\n    que.pop();\n    if (visit[p.y][p.x]) { continue; }\n    visit[p.y][p.x] = true;\n    if (p.x == w - 1 && p.y == h - 1) {\n      ret = p.cost;\n      break;\n    }\n    REP(dir, 4) {\n      if (field[p.y][p.x][dir] != 0) { continue; }\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      int ncost = p.cost + 1;\n      que.push(Node(nx, ny, ncost));\n    }\n  }\n  field[sy][sx][dir] = 0;\n  return dist[sy][sx][dir] = ret;\n}\n\nint calc(int depth, int x, int y) {\n  if (memo[depth][y][x] != -1) { return memo[depth][y][x]; }\n  if (depth == 1999) { return 20000; }\n  if (x == w - 1 && y == h - 1) { return 0; }\n  int ret = 20000;\n  REP(dir, 4) {\n    if (field[y][x][dir] != 0) { continue; }\n    int nx = x + dx[dir];\n    int ny = y + dy[dir];\n    int cost = max(d(x, y, dir), 1 + calc(depth + 1, nx, ny));\n    ret = min(ret, cost);\n  }\n  return memo[depth][y][x] = ret;\n}\n\nint main() {\n  while (scanf(\"%d %d\", &h, &w), h|w) {\n    MEMSET(memo, -1);\n    MEMSET(dist, -1);\n    REP(y, 100) REP(x, 100) REP(dir, 4) { field[y][x][dir] = 1; }\n    REP(i, h * 2 - 1) {\n      if (i % 2 == 0) {\n        int y = i / 2;\n        REP(j, w - 1) {\n          int v;\n          int fx = j;\n          int tx = fx + 1;\n          scanf(\"%d\", &v);\n          field[y][fx][0] = v;\n          field[y][tx][2] = v;\n        }\n      } else {\n        int fy = i / 2;;\n        int ty = fy + 1;\n        REP(x, w) {\n          int v;\n          scanf(\"%d\", &v);\n          field[fy][x][1] = v;\n          field[ty][x][3] = v;\n        }\n      }\n    }\n    int ans = calc(0, 0, 0);\n    printf(\"%d\\n\", ans < 2000 ? ans : -1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <vector>\nusing namespace std;\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) REP(i, 0, n)\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nconstexpr int MAX_SIZE = 30;\nconstexpr int MAX_N = MAX_SIZE * MAX_SIZE;\nconstexpr int INF = (1 << 29);\n\nint bfs_memo[MAX_N][MAX_N];\n\nint get_index(int x, int y, int w) {\n\treturn x + y * w;\n}\n\nvoid add_edge(int a, int b, vector<vector<int>> &G) {\n\tbool not_door;\n\tcin >> not_door;\n\n\tif(!not_door) {\n\t\tG[a].emplace_back(b);\n\t\tG[b].emplace_back(a);\n\t}\n}\n\nint bfs(int s, int no, const vector<vector<int>> &G) {\n\tif(bfs_memo[s][no] != -1) return bfs_memo[s][no];\n\n\tconst int n = G.size();\n\tvector<int> dist(n, INF);\n\tqueue<int> que;\n\tdist[s] = 0;\n\tque.push(s);\n\n\twhile(!que.empty()) {\n\t\tconst int v = que.front();\n\t\tque.pop();\n\n\t\tif(v == n - 1) break;\n\n\t\tfor(const auto &to : G[v]) {\n\t\t\tif(v == s && to == no) continue;\n\n\t\t\tif(dist[to] == INF) {\n\t\t\t\tdist[to] = dist[v] + 1;\n\t\t\t\tque.push(to);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn bfs_memo[s][no] = dist[n - 1];\n}\n\nint dfs(int v, int card, vector<vector<int>> &memo, const vector<vector<int>> &G) {\n\tconst int n = G.size();\n\tif(v == n - 1) return card;\n\tif(card > n) return INF;\n\n\tint &res = memo[v][card];\n\tif(res != -1) return res;\n\n\tint min_select = INF;\n\tfor(const auto &to : G[v]) {\n\t\tchmax(res, bfs(v, to, G) + card);\n\t\tchmin(min_select, dfs(to, card + 1, memo, G));\n\t}\n\n\tchmax(res, min_select);\n\treturn res;\n}\n\nint solve(const vector<vector<int>> &G) {\n\tconst int n = G.size();\n\tmemset(bfs_memo, -1, sizeof(bfs_memo));\n\tvector<vector<int>> memo(n, vector<int>(n, -1));\n\tconst int ans = dfs(0, 0, memo, G);\n\treturn ans == INF ? -1 : ans;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int h, w; cin >> h >> w && h;) {\n\t\tconst int n = h * w;\n\t\tvector<vector<int>> G(n);\n\n\t\trep(y, h) {\n\t\t\trep(x, w - 1) {\n\t\t\t\tadd_edge(get_index(x, y, w), get_index(x + 1, y, w), G);\n\t\t\t}\n\n\t\t\tif(y < h - 1) {\n\t\t\t\trep(x, w) {\n\t\t\t\t\tadd_edge(get_index(x, y, w), get_index(x, y + 1, w), G);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << solve(G) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint h,w,wall[33][33][4],dist_broken[33][33][4];\nint dy[]={-1,0,1,0},dx[]={0,-1,0,1};\n// 0\n//1 3\n// 2\n\nint bfs(int Y,int X){\n\tint d[33][33];\n\trep(i,h+1)rep(j,w+1)d[i][j]=INF;\n\td[Y][X]=0;\n\tqueue<pi> Q;\n\tQ.push(pi(Y,X));\n\twhile(Q.sz){\n\t\tpi p=Q.front();\n\t\tint y=p.fir,x=p.sec;\n\t\tif(y==h && x==w)return d[h][w];\n\t\tQ.pop();\n\t\trep(i,4)if(!wall[y][x][i]){\n\t\t\tint ny=y+dy[i],nx=x+dx[i];\n\t\t\tif(d[y][x]+1 < d[ny][nx]){\n\t\t\t\td[ny][nx]=d[y][x]+1;\n\t\t\t\tQ.push(pi(ny,nx));\n\t\t\t}\n\t\t}\n\t}\n\treturn INF;\n}\n\ntypedef pair<int,pi> tri;\n\nint shortest(){\n\tint d[33][33];\n\trep(i,h+1)rep(j,w+1)d[i][j]=INF;\n\td[h][w]=0;\n\tpriority_queue<tri,vector<tri>,greater<tri> > Q;\n\tQ.push(tri(0,pi(h,w)));\n\twhile(Q.sz){\n\t\ttri t=Q.top();\n\t\tint dist=t.fir,y=t.sec.fir,x=t.sec.sec;\n\t\tif(y==1 && x==1)return dist;\n\t\tQ.pop();\n\t\tif(dist > d[y][x])continue;\n\t\trep(i,4)if(!wall[y][x][i]){\n\t\t\tint ny=y+dy[i],nx=x+dx[i];\n\t\t\tint nc=max(dist+1,dist_broken[ny][nx][(i+2)%4]);\n\t\t\tif(nc < d[ny][nx]){\n\t\t\t\td[ny][nx]=nc;\n\t\t\t\tQ.push(tri(nc,pi(ny,nx)));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\twhile(cin>>h>>w && h){\n\t\trep(i,h+1)rep(j,w+1)rep(k,4)wall[i][j][k]=1;\n\t\trep2(i,1,h+1){\n\t\t\trep2(j,1,w)cin>>wall[i][j][3];\n\t\t\tif(i<h)rep2(j,1,w+1)cin>>wall[i][j][2];\n\t\t}\n\t\trep2(i,1,h+1)rep2(j,1,w+1){\n\t\t\twall[i][j][1]=wall[i][j-1][3];\n\t\t\twall[i][j][0]=wall[i-1][j][2];\n\t\t}\n\t\trep2(i,1,h+1)rep2(j,1,w+1)rep(k,4){\n\t\t\tif(wall[i][j][k])dist_broken[i][j][k]=INF;\n\t\t\telse{\n\t\t\t\twall[i][j][k]=1;\n\t\t\t\tdist_broken[i][j][k]=bfs(i,j);\n\t\t\t\twall[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t\tcout<<shortest()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<int,P>P2;\n \nint dist[30][30][30][30][4];\nint used[30][30],h,w;\nbool v[30][30][4];\n\nint ans[33][33];\n\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\n\nstring s[33];\n\nvoid bfs(int Y,int X,int K){\n    dist[h-1][w-1][Y][X][K]=0;\n    queue<int>q;\n    q.push((h-1)*1000+(w-1));\n    while(!q.empty()){\n        int now=q.front();q.pop();\n        int y=now/1000;\n        int x=now%1000;\n        r(i,4){\n            int ny=y+dy[i];\n            int nx=x+dx[i];\n            if(ny<0||nx<0||h<=ny||w<=nx)continue;\n           // cout<<y<<' '<<x<<' '<<i<<endl;\n            if(!v[y][x][i])continue;\n            if(dist[ny][nx][Y][X][K]!=-1)continue;\n\n            dist[ny][nx][Y][X][K] = dist[y][x][Y][X][K]+1;\n            q.push(ny*1000+nx);\n        }\n    }\n    //cout<<dist[0][1][Y][X][K]<<endl;\n}\n\nint bfs2(){\n    r(i,33)r(j,33)ans[i][j]=1e9;\n    memset(used,-1,sizeof(used));\n    priority_queue<P2,vector<P2>,greater<P2> >q;\n    q.push(P2(0,P(h-1,w-1)));\n    ans[h-1][w-1]=0;;\n    while(!q.empty()){\n        P2 now=q.top();q.pop();\n        int cost=now.first;\n        int y=now.second.first;\n        int x=now.second.second;\n        if(ans[y][x] < cost)continue;\n        r(i,4){\n            int ny=y+dy[i];\n            int nx=x+dx[i];\n            if(ny<0||nx<0||h<=ny||w<=nx)continue;\n            if(!v[y][x][i])continue;\n            int ncos=max(cost+1,dist[ny][nx][y][x][i]);\n            if(ans[ny][nx] <= ncos)continue;\n            ans[ny][nx] = ncos;\n            q.push(P2(ncos,P(ny,nx)));\n        }\n    }\n    return ans[0][0];\n}\n\nsigned main(){\n    while(cin>>h>>w,h){\n        getline(cin,s[0]);\n        r(i,h*2-1){\n            getline(cin,s[i]);\n        }\n        memset(dist,-1,sizeof(dist));\n        memset(v,0,sizeof(v));\n        for(int i=0;i<h*2-1;i+=2){\n            for(int j=0;j<w*2-1;j+=2){\n                for(int k=0;k<4;k++){\n                    int y=i+dy[k];\n                    int x=j+dx[k];\n                    if(y<0||x<0|| h*2-1<=y || w*2-1<=x)continue;\n                    if(s[y][x]=='0'){\n                        v[i/2][j/2][k]=1;\n                    }\n                }\n            }\n        }\n        r(i,h)r(j,w)r(k,4){\n            if(!v[i][j][k])continue;\n            v[i][j][k]=0;\n            //exit(0);\n            bfs(i,j,k);\n            v[i][j][k]=1;\n        }\n        int ANS=bfs2();\n        if(ANS==1e9)cout<<-1<<endl;\n        else cout<<ANS<<endl;\n\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dy[] = {0, 0, -1, 1}, dx[] = {-1, 1, 0, 0};\ntypedef pair< int, int > Pi;\nconst int INF = 1 << 30;\n\nint H, W;\nbool DONT[30][30][30][30];\nint COST[30][30][30][30];\nint min_cost[30][30];\n\nint bfs(int sy, int sx)\n{\n  queue< Pi > que;\n  fill_n(*min_cost, 30 * 30, INF);\n  que.push(Pi(sy, sx));\n  min_cost[sy][sx] = 0;\n  while(!que.empty()) {\n    Pi p = que.front(); que.pop();\n    if(p == Pi(H - 1, W - 1)) return(min_cost[H - 1][W - 1]);\n    for(int i = 0; i < 4; i++) {\n      int nx = p.second + dx[i], ny = p.first + dy[i];\n      if(nx < 0 || ny < 0 || nx >= W || ny >= H) continue;\n      if(DONT[p.first][p.second][ny][nx]) continue;\n      if(min_cost[ny][nx] < INF) continue;\n      min_cost[ny][nx] = min_cost[p.first][p.second] + 1;\n      que.push(Pi(ny, nx));\n    }\n  }\n  return(INF);\n}\nbool Check(int value)\n{\n  queue< Pi > que;\n  fill_n(*min_cost, 30 * 30, -1);\n  min_cost[0][0] = 0;\n  que.push(Pi(0, 0));\n  while(!que.empty()) {\n    Pi p = que.front(); que.pop();\n    if(p == Pi(H - 1, W - 1)) return(true);\n    for(int i = 0; i < 4; i++) {\n      int ny = dy[i] + p.first, nx = dx[i] + p.second;\n      if(ny < 0 || nx < 0 || ny >= H || nx >= W) continue;\n      if(DONT[p.first][p.second][ny][nx]) continue;\n      if(~min_cost[ny][nx]) continue;\n      if(min_cost[p.first][p.second] + COST[p.first][p.second][ny][nx] > value) continue;\n      min_cost[ny][nx] = min_cost[p.first][p.second] + 1;\n      que.push(Pi(ny, nx));\n    }\n  }\n  return(false);\n}\n\nint Solve()\n{\n  for(int i = 0; i < 4; i++) {\n    for(int y = 0; y < H; y++) {\n      for(int x = 0; x < W; x++) {\n        int ny = y + dy[i], nx = x + dx[i];\n        if(ny < 0 || nx < 0 || ny >= H || nx >= W) continue;\n        if(DONT[y][x][ny][nx]) continue;\n        DONT[y][x][ny][nx] = true;\n        COST[y][x][ny][nx] = bfs(y, x);\n        DONT[y][x][ny][nx] = false;\n      }\n    }\n  }\n  int low = 0, high = W * H * 2;\n  if(!Check(high)) return(-1);\n  while(high - low > 0) {\n    int mid = (low + high) >> 1;\n    if(Check(mid)) high = mid;\n    else low = mid + 1;\n  }\n  return(low);\n}\n\n\nint main()\n{\n  while(cin >> H >> W, H) {\n    for(int i = 0; i < 2 * H - 1; i++) {\n      if(i & 1) {\n        for(int j = 0; j < W; j++) {\n          int digit;\n          cin >> digit;\n          DONT[i / 2][j][i / 2 + 1][j] = digit;\n          DONT[i / 2 + 1][j][i / 2][j] = digit;\n        }\n      } else {\n        for(int j = 0; j < W - 1; j++) {\n          int digit;\n          cin >> digit;\n          DONT[i / 2][j][i / 2][j + 1] = digit;\n          DONT[i / 2][j + 1][i / 2][j] = digit;\n        }\n      }\n    }\n    cout << Solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl;\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl;\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl;\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl;\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl;\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl;\n#define int long long\n#define double long double\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\nconst int N = 50;\nint h,w;\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\nint G[N][N][4];\nint in(int x,int y){return !(x < 0 || y < 0 || x >= w || y >= h);}\n\nint dis[N][N][N][N][4]; //goalからの距離\nvoid bfs(int sy,int sx){\n  memset(dis,-1,sizeof(dis));\n  typedef tuple<int,int,int,int,int,int> T; // y, x, by, bx, dir, cost\n  queue<T> Q;\n  \n  //broken door\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<4;k++){\n        dis[sy][sx][i][j][k] = 0;\n        Q.push(T(sy,sx,i,j,k,0));\n      }\n  \n  while(!Q.empty()){\n    int y, x, by, bx, dir, cost;\n    tie(y, x, by, bx, dir, cost) = Q.front(); Q.pop();\n    \n    for(int i=0;i<4;i++){\n      int ny = y + dy[i];\n      int nx = x + dx[i];\n      int ncost = cost + 1;\n      if(!in(nx,ny) || G[y][x][i] == 0 || dis[ny][nx][by][bx][dir] != -1) continue;\n      if(x == bx && y == by && i == dir) continue;\n      if(nx == bx && ny == by && i == (dir+2)%4) continue;\n      dis[ny][nx][by][bx][dir] = ncost;\n      Q.push(T(ny,nx,by,bx,dir,ncost));\n    }\n  }\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<h;k++)\n        for(int l=0;l<w;l++)\n          for(int m=0;m<4;m++) if(dis[i][j][k][l][m] == -1) dis[i][j][k][l][m] = INF;\n}\n\nint calcCost(int y,int x,int d,int dir){\n  if(!in(x,y)) return INF;\n  int res = INF;\n  Min(res, d + dis[y][x][y][x][dir]);\n  return res;\n}\n\nint D[N][N][N*N], visited[N][N][N*N];\nint dijkstra(int sy,int sx){\n  typedef tuple<int,int,int,int> T; //cost, y, x, distance;\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<=h*w;k++) D[i][j][k] = INF, visited[i][j][k] = 0;\n  \n  priority_queue<T,vector<T>,greater<T> > Q;\n  Q.push(T(0,sy,sx,0));\n  D[sy][sx][0] = 0;\n\n  int res = INF;\n  while(!Q.empty()){\n    int cost, y, x, d;\n    tie(cost,y, x, d) = Q.top(); Q.pop();\n    if(visited[y][x][d]++) continue;\n    if(x == w-1 && y == h-1) {\n      Min(res, max(cost, d));\n      continue;\n    }\n\n    for(int i=0;i<4;i++){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      int nd = d + 1;\n      int a = cost;\n      int b = calcCost(y, x, d, i);\n      int ncost = max(a, b);\n      if(!in(nx,ny) || G[y][x][i] == 0 || D[ny][nx][nd] <= ncost) continue;\n      D[ny][nx][nd] = ncost;\n      Q.push(T(ncost,ny,nx,nd));\n    }\n  }\n  if(res == INF) return -1;\n  return res;\n}\n\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(1){\n    cin>>h>>w;\n    if(h == 0 && w == 0) break;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++)\n        for(int k=0;k<4;k++) G[i][j][k] = 1;\n\n    for(int i=0;i<h*2-1;i++){\n      for(int j=0;j<w - !(i%2);j++){\n        int ng;\n        cin>>ng;\n        int x = j, y = i/2;\n        if(i%2 == 0 && ng) G[y][x][1] = G[y][x+1][3] = 0;\n        if(i%2 == 1 && ng) G[y][x][2] = G[y+1][x][0] = 0;\n      }\n    }\n\n    bfs(h-1, w-1);\n    \n    int ans = dijkstra(0, 0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<bitset>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<functional>\n#include<algorithm>\nusing namespace std;\n\nenum {N, E, S, W};\nconst unsigned long ALL = 1 + 2 + 4 + 8;\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\n\nconst int INF = 10000;\n\n// for bfs\nenum {Y, X, STEP};\ntypedef tuple<int, int, int> Node;\ntypedef tuple<int, int> Vertex;\n\n// for Dijkstra\nenum {DWORST, DSTEP, DY, DX};\ntypedef tuple<int, int, int, int> DNode;\n\nint h, w;\nvector<vector<bitset<4>>> wall;\n\n// int bfs(int by, int bx, int bd, int init_step) {\nint bfs(int by1, int bx1, int bd1, int by2, int bx2, int bd2, int init_step) {\n// cout<<\"bfs\"<<endl;\n    queue<Node> q;\n//     q.push(Node(by, bx, init_step));\n    q.push(Node(by1, bx1, init_step));\n    set<Vertex> visited;\n    while(!q.empty()) {\n        int y = get<Y>(q.front());\n        int x = get<X>(q.front());\n        int step = get<STEP>(q.front());\n        q.pop();\n        if(y == h - 1 && x == w - 1) return step;\n        if(visited.count(Vertex(y, x))) continue;\n        visited.insert(Vertex(y, x));\n// cout<<y<<\",\"<<x<<\"; \"<<step<<endl;\n        for(const auto& d: {N, E, S, W}) {\n            if(wall[y][x][d]) continue;\n//             if(y == by && x == bx && d == bd) continue;\n            if(y == by1 && x == bx1 && d == bd1) continue;\n            if(y == by2 && x == bx2 && d == bd2) continue;\n            int ny = y + dy[d];\n            int nx = x + dx[d];\n            if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            q.push(Node(ny, nx, step + 1));\n        }\n    }\n    return INF;\n}\n\nint Dijkstra() {\n    priority_queue<DNode, vector<DNode>, greater<DNode>> q;\n    q.push(DNode(0, 0, 0, 0));\n    set<Vertex> visited;\n    while(!q.empty()) {\n        int worst = get<DWORST>(q.top());\n        int y = get<DY>(q.top());\n        int x = get<DX>(q.top());\n        int step = get<DSTEP>(q.top());\n        q.pop();\n        if(y == h - 1 && x == w - 1) return worst;\n        if(visited.count(Vertex(y, x))) continue;\n        visited.insert(Vertex(y, x));\n// cout<<y<<\",\"<<x<<\"; \"<<step<<\" ; \"<<worst<<endl;\n        for(const auto& d: {N, E, S, W}) {\n            if(wall[y][x][d]) continue;\n            int ny = y + dy[d];\n            int nx = x + dx[d];\n            if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            if(visited.count(Vertex(ny, nx))) continue;\n// cout<<ny<<\",\"<<nx<<\";\"<<d<<\":\";\n//             int nworst = max(worst, bfs(y, x, d, step));\n            int nworst = max(worst, bfs(y, x, d, ny, nx, (d + 2) % 2, step));\n            if(nworst == INF) continue;\n            q.push(DNode(nworst, step + 1, ny, nx));\n        }\n    }\n    return INF;\n}\n\nint main() {\n    while(cin >> h >> w, h | w) {\n        wall = vector<vector<bitset<4>>>(h, vector<bitset<4>>(w, bitset<4>(ALL)));\n        for(int i = 0; i < h - 1; ++i) {\n            for(int j = 0; j < w - 1; ++j) {\n                int is_wall;\n                cin >> is_wall;\n                if(is_wall) continue;\n                wall[i][j].reset(E);\n                wall[i][j + 1].reset(W);\n            }\n            for(int j = 0; j < w; ++j) {\n                int is_wall;\n                cin >> is_wall;\n                if(is_wall) continue;\n                wall[i][j].reset(S);\n                wall[i + 1][j].reset(N);\n            }\n        }\n        for(int j = 0; j < w - 1; ++j) {\n            int is_wall;\n            cin >> is_wall;\n            if(is_wall) continue;\n            wall[h - 1][j].reset(E);\n            wall[h - 1][j + 1].reset(W);\n        }\n\n        int answer = Dijkstra();\n        cout << (answer == INF ? -1 : answer) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nint H, W;\nconst int INF = 1000000000;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nbool valid(int x, int w) {\n    return 0 <= x && x < w;\n}\nint bfs(int sx, int sy, int gx, int gy, const vector<vector<int>>& ver, const vector<vector<int>>& hol) {\n    int dist[50][50] = {};\n    REP(y, H) REP(x, W) dist[y][x] = INF;\n    dist[sy][sx] = 0;\n    queue<int> qx, qy;\n    qx.push(sx);\n    qy.push(sy);\n    while(!qx.empty()){\n        int x = qx.front(); qx.pop();\n        int y = qy.front(); qy.pop();\n        REP(r, 4) {\n            int nx = x + dx[r];\n            int ny = y + dy[r];\n            if(!valid(nx, W)) continue;\n            if(!valid(ny, H)) continue;\n            if(r % 2 == 0 && hol[y][x + (r == 0 ? 0 : -1)] == 1) continue;\n            if(r % 2 == 1 && ver[y + (r == 1 ? 0 : -1)][x] == 1) continue;\n            if(dist[ny][nx] > dist[y][x] + 1) {\n                dist[ny][nx] = dist[y][x] + 1;\n                qx.push(nx);\n                qy.push(ny);\n            }\n        }\n    }\n    return dist[gy][gx];\n}\n\nint main(){\n    while(cin >> H >> W && H > 0) {\n        vector<vector<int>> ver(H - 1, vector<int>(W));\n        vector<vector<int>> hol(H, vector<int>(W - 1));\n        REP(y, H) {\n            REP(x, W - 1) cin >> hol[y][x];\n            if(y < H - 1) {\n                REP(x, W) cin >> ver[y][x];\n            }\n        }\n\n        int lb = 0, ub = 1000;\n\n        while(ub - lb > 1) {\n            int L = (lb + ub) / 2;\n\n            queue<int> qx, qy;\n            qx.push(0); qy.push(0);\n\n            int dist[50][50] = {};\n            REP(y, H) REP(x, W) dist[y][x] = INF;\n\n            dist[0][0] = 0;\n            while(!qx.empty()){\n                int x = qx.front(); qx.pop();\n                int y = qy.front(); qy.pop();\n                REP(r, 4) {\n                    int nx = x + dx[r];\n                    int ny = y + dy[r];\n                    if(!valid(nx, W)) continue;\n                    if(!valid(ny, H)) continue;\n\n                    int& target = (r % 2 == 0 ? hol[y][x + (r == 0 ? 0 : -1)] : ver[y + (r == 1 ? 0 : -1)][x]);\n                    if(r % 2 == 0 && hol[y][x + (r == 0 ? 0 : -1)] == 1){\n                        assert(target == 1);\n                        continue;\n                    }\n                    if(r % 2 == 1 && ver[y + (r == 1 ? 0 : -1)][x] == 1){\n                        assert(target == 1);\n                        continue;\n                    }\n\n                    target = 1;\n                    int res = bfs(x, y, W - 1, H - 1, ver, hol);\n                    target = 0;\n\n                    if(res + dist[y][x] > L) continue;\n\n                    if(dist[ny][nx] > dist[y][x] + 1) {\n                        dist[ny][nx] = dist[y][x] + 1;\n                        qx.push(nx);\n                        qy.push(ny);\n                    }\n                }\n            }\n\n\n            if(dist[H - 1][W - 1] <= L) {\n                ub = L;\n            } else {\n                lb = L;\n            }\n        }\n\n        if(ub == 1000) ub = -1;\n\n        cout << ub << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<pair<int,int>,int> P;\nint h,w;\npair<int,int> dp[33*33];\nint dist[33*33];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nvector<vector<int>> v(33*33);\n\nint fun(int a,int b){\n\tREP(i,33*33)dist[i] = INF;\n\tdist[a] = 0;\n\tqueue<pair<int,int>> q;\n\tq.push(MP(a,0));\n\twhile(!q.empty()){\n\t\tpair<int,int> now = q.front();q.pop();\n\t\tint node = now.FI;\n\t\tint kyo = now.SE;\n\t\tif(kyo > dist[node])continue;\n\t\tREP(i,v[node].size()){\n\t\t\tint aite = v[node][i];\n\t\t\tif((node == a && aite == b) || (node == b && aite == a))continue;\n\t\t\tif(dist[aite] > kyo + 1){\n\t\t\t\tdist[aite] = kyo + 1;\n\t\t\t\tq.push(MP(aite,kyo+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[h*w-1];\n}\n\nint main()\n{\n\twhile(cin >> h >> w,h|w){\n\t\t//初期化\n\t\tREP(i,33*33)dp[i] = MP(INF,INF);\n\t\tREP(i,33*33){v[i].clear();}\n\t\tdp[0] = MP(0,0);\n\t\t\n\t\t//入力\n\t\tREP(i,h){\n\t\t\tREP(j,w-1){\n\t\t\t\tint tmp;cin >> tmp;\n\t\t\t\tif(tmp == 0){\n\t\t\t\t\tv[i*w+j].PB(i*w+j+1);\n\t\t\t\t\tv[i*w+j+1].PB(i*w+j);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tif(i != h-1)REP(j,w){\n\t\t\t\tint tmp;cin >> tmp;\n\t\t\t\tif(tmp == 0){\n\t\t\t\t\tv[i*w+j].PB((i+1)*w+j);\n\t\t\t\t\tv[(i+1)*w+j].PB(i*w+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tpriority_queue<P,vector<P>,greater<P>> q;\n\t\tq.push(MP(MP(0,-1),0));\n\t\tDBG(cout << \"!\" << endl;);\n\t\twhile(!q.empty()){\n\t\t\tDBG(\n\t\t\tcout << \"DP TABLE\" << endl;\n\t\t\tREP(i,h){\n\t\t\t\tREP(j,w){\n\t\t\t\t\tcout << dp[i*w+j].FI << ' ';\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\t)\n\t\t\tP now = q.top();q.pop();\n\t\t\tint node = now.SE;\n\t\t\tpair<int,int> kyori = now.FI;\n\t\t\tDBG(cout << kyori.FI << ' ' << kyori.SE << endl;)\n\t\t\tDBG(cout << dp[node].FI << ' ' << dp[node].SE << endl;)\n\t\t\tif(dp[node].FI < kyori.FI)continue;\n\t\t\tDBG(cout << \"IN\" << endl;)\n\t\t\tkyori.SE++;\n\t\t\tREP(i,v[node].size()){\n\t\t\t\tint aite = v[node][i];\n\t\t\t\tpair<int,int> score = MP(fun(node,aite)+kyori.SE,kyori.SE);\n\t\t\t\tif(dp[aite] > max(dp[node],score)){\n\t\t\t\t\tdp[aite] = max(dp[node],score);\n\t\t\t\t\tq.push(MP(MP(max(dp[aite].FI,score.FI),score.SE),aite));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tDBG(\n\t\tcout << \"DP TABLE\" << endl;\n\t\tREP(i,h){\n\t\t\tREP(j,w){\n\t\t\t\tcout << dp[i*w+j].FI << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t)\n\t\t\n\t\tDBG(cout << \"ANS IS \";);\n\t\t\n\t\tif(dp[h*w-1].FI == INF){\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << dp[h*w-1].FI << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reps(i,a,b) for(int i=(a); i<(b); ++i)\n#define rep(i,n) reps(i,0,n)\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nstruct UnionFind{\n\tstd::vector<int> data;\n\tUnionFind(int size): data(size, -1) {}\n\n\tbool unite(int x, int y){\n\t\tx=root(x);\n\t\ty=root(y);\n\t\tif( x != y ){\n\t\t\tif( data[y] < data[x] ) std::swap(x, y);\n\t\t\tdata[x] += data[y];\n\t\t\tdata[y] = x;\n\t\t}\n\t\treturn x!=y;\n\t}\n\n\tbool find(int x, int y){\n\t\treturn root(x) == root(y);\n\t}\n\n\tint root(int x){\n\t\treturn (data[x] < 0)? x : data[x]=root(data[x]);\n\t}\n\n\tint size(int x){\n\t\treturn -data[ root(x) ];\n\t}\n};\n\n// R, U, L, D\nconst int vx[]={1,0,-1,0}, vy[]={0,1,0,-1};\n\nconst int INF = 1e9;\n\nint h, w;\nint ans;\nmap<pii,int> cost;\nvoid solve(map<pii,int> &mp, map<pii,int> &tb, int x, int y, int d){\n\tqueue<pair<pii,int>> que;\n\tque.push( {pii(x,y), d} );\n\ttb[pii(x,y)] = d;\n\twhile(!que.empty()){\n\t\tauto cur = que.front().X;\n\t\tint x = cur.X;\n\t\tint y = cur.Y;\n\t\tint d = que.front().Y;\n\t\tque.pop();\n\t\trep(k,4){\n\t\t\tint nx = x + vx[k];\n\t\t\tint ny = y + vy[k];\n\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n\t\t\tif( mp[cur] & (1<<k) ) continue;\n\t\t\tif( !tb.count(pii(nx,ny)) || tb[pii(nx,ny)] > d + 1 ){\n\t\t\t\ttb[pii(nx,ny)] = d + 1;\n\t\t\t\tque.push( {pii(nx,ny), d+1} );\n\t\t\t}\n\t\t}\n\t}\n\tif( !tb.count(pii(w-1,h-1)) ) tb[pii(w-1,h-1)] = INF;\n\tcost[pii(x,y)] = max(cost[pii(x,y)], tb[pii(w-1,h-1)]);\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\twhile(cin >> h >> w, h|w){\n\t\tcost.clear();\n\t\tmap<pii,int> mp;\n\t\tint d;\n\t\trep(i,h-1){\n\t\t\trep(j,w-1){\n\t\t\t\tcin >> d;\n\t\t\t\tif( d == 1 ){\n\t\t\t\t\tmp[pii(j,i)]   |= (1<<0);\n\t\t\t\t\tmp[pii(j+1,i)] |= (1<<2);\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,w){\n\t\t\t\tcin >> d;\n\t\t\t\tif( d == 1 ){\n\t\t\t\t\tmp[pii(j,i)]   |= (1<<1);\n\t\t\t\t\tmp[pii(j,i+1)] |= (1<<3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint i = h-1;\n\t\trep(j,w-1){\n\t\t\tcin >> d;\n\t\t\tif( d == 1 ){\n\t\t\t\tmp[pii(j,i)]   |= (1<<0);\n\t\t\t\tmp[pii(j+1,i)] |= (1<<2);\n\t\t\t}\n\t\t}\n\t\trep(i,h) mp[pii(0,i)]   |= (1<<2);\n\t\trep(i,h) mp[pii(w-1,i)] |= (1<<0);\n\t\trep(i,w) mp[pii(i,0)]   |= (1<<3);\n\t\trep(i,w) mp[pii(i,h-1)] |= (1<<1);\n\n\t\tmap<pii,int> tb_s;\n\t\tsolve(mp, tb_s, 0, 0, 0);\n\t\tans = 0;\n//\t\trep(i,h){\n//\t\t\trep(j,w) cout << tb_s[pii(j,i)] << \" \";\n//\t\t\tcout << endl;\n//\t\t}\n\n\t\trep(y,h) rep(x,w) rep(k,4){\n\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n\t\t\tif( cost[pii(x,y)] >= INF ) continue;\n\t\t\tint nx = x + vx[k];\n\t\t\tint ny = y + vy[k];\n\t\t\tauto mp1 = mp;\n\t\t\tmp1[pii(x,y)]   |= (1<<k);\n\t\t\tmp1[pii(nx,ny)] |= (1<<((k+2)%4));\n\t\t\tmap<pii,int> tb;\n\t\t\t//solve(mp1, tb, x, y, tb_s[pii(x,y)]);\n\t\t\tsolve(mp1, tb, x, y, 0);\n\t\t\t//cout << \"solve: \" << x << \" \" << y << \" k=\" << k << endl;\n\t\t\t//rep(i,h){\n\t\t\t//\trep(j,w) cout << tb[pii(j,i)] << \" \";\n\t\t\t//\tcout << endl;\n\t\t\t//}\n\t\t}\n\n//\t\tcout << \"cost:\" << endl;\n//\t\trep(i,h){\n//\t\t\trep(j,w) cout << (cost[pii(j,i)]==INF ? 99 : cost[pii(j,i)]) << \" \";\n//\t\t\tcout << endl;\n//\t\t}\n\n\t\tint l=0, r=1000;\n\t\twhile(r-l>1){\n\t\t\tint limit = (l+r)/2;\n\t\t\ttypedef pair<pii,pii> PII;\n\t\t\tpriority_queue<PII, vector<PII>, greater<PII>> que;\n\t\t\tmap<pii,pii> memo;\n\t\t\tque.push({{cost[pii(0,0)],0},pii(0,0)});\n\t\t\twhile(!que.empty()){\n\t\t\t\tint c = que.top().X.X;\n\t\t\t\tint d = que.top().X.Y;\n\t\t\t\tint x = que.top().Y.X;\n\t\t\t\tint y = que.top().Y.Y;\n\t\t\t\tque.pop();\n\t\t\t\tif( memo.count(pii(x,y)) && memo[pii(x,y)] < pii(c,d) ) continue;\n\t\t\t\t//if( memo.count(pii(x,y)) ) continue;\n\t\t\t\tif( c > limit ) continue;\n\t\t\t\t//memo[pii(x,y)] = pii(c,d);\n\t\t\t\t//ans = max(ans, c);\n\t\t\t\tif( pii(x,y) == pii(w-1,h-1) ) break;\n\t\t\t\trep(k,4){\n\t\t\t\t\tint nx = x + vx[k];\n\t\t\t\t\tint ny = y + vy[k];\n\t\t\t\t\tint nc = d + 1 + cost[pii(nx,ny)];\n\t\t\t\t\tnc = min(nc, INF);\n\t\t\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n\t\t\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n\t\t\t\t\tif( !memo.count(pii(nx,ny)) || memo[pii(nx,ny)] > pii(nc,d+1) ){\n\t\t\t\t\t\tif( nc <= limit ){\n\t\t\t\t\t\t\tmemo[pii(nx,ny)] = pii(nc, d+1);\n\t\t\t\t\t\t\tque.push( {pii(nc, d+1), pii(nx, ny)} );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( memo.count(pii(w-1,h-1)) ){\n\t\t\t\tr = limit;\n\t\t\t}else{\n\t\t\t\tl = limit;\n\t\t\t}\n\t\t}\n\t\tans = (r<1000 ? r : -1);\n//\t\tpii pos = {w-1,h-1};\n//\t\tans = max(ans, memo[pos].X);\n//\t\twhile( pos != pii(0,0) ){\n//\t\t\tint x = pos.X;\n//\t\t\tint y = pos.Y;\n//\t\t\trep(k,4){\n//\t\t\t\tint nx = x + vx[k];\n//\t\t\t\tint ny = y + vy[k];\n//\t\t\t\tint nc = d + 1 + cost[pii(nx,ny)];\n//\t\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n//\t\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n//\t\t\t\tif( memo.count(pii(nx,ny)) && memo[pii(nx,ny)].Y < memo[pos].Y ){\n//\t\t\t\t\tpos = pii(nx,ny);\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tans = max(ans, memo[pos].X);\n//\t\t}\n\n//\t\tmultimap<int, pii> order;\n//\t\tfor(auto t: memo) order.insert({ t.Y.X, t.X });\n//\t\tUnionFind uf(1000);\n//\t\tfor(auto t: order){\n//\t\t\tint x = t.Y.X;\n//\t\t\tint y = t.Y.Y;\n//\t\t\trep(k,4){\n//\t\t\t\tint nx = x + vx[k];\n//\t\t\t\tint ny = y + vy[k];\n//\t\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n//\t\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n//\t\t\t\tif( memo[pii(nx,ny)].X <= t.X ){\n//\t\t\t\t\tuf.unite( nx+ny*w, x+y*w );\n//\t\t\t\t}\n//\t\t\t}\n////\t\t\tcout << \"order: \" << x << \" \" << y << \" \" << t.X << endl;\n//\t\t\tif( uf.find(0, (w-1)+(h-1)*w ) ){\n//\t\t\t\tans = t.X;\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t}\n\n\t\tcout << (ans >= INF ? -1 : ans) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <utility>\n#define INF 2000\nusing namespace std;\ntypedef pair<int,int> P;\n\nstruct data{\n\tint x,y,c,dc;\n\tdata(int xx,int yy,int cc,int dd){\n\t\tx=xx;\n\t\ty=yy;\n\t\tc=cc;\n\t\tdc=dd;\n\t}\n\n\tbool operator<(const data& d1)const{\n\t\treturn d1.dc<dc;\n\t}\n};\n\nint h,w;\n\nint fie[61][61];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint dp[61][61][901];\nint cost[61][61][4];\nint used[61][61];\n\nint bfs(int sx,int sy){\n\tqueue<P> que;\n\tque.push(P(sx,sy));\n\tmemset(used,-1,sizeof(used));\n\tused[sx][sy]=0;\n\twhile(que.size()){\n\t\tP q=que.front();\n\t\tque.pop();\n\t\tint x=q.first,y=q.second;\n\t\tif(x==(w-1)*2 && y==(h-1)*2)return used[x][y];\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\tif(nx>=0 && nx<w*2-1 && ny>=0 && ny<h*2-1){\n\t\t\t\tif(fie[nx][ny]==1)continue;\n\t\t\t\tnx+=dx[i];\n\t\t\t\tny+=dy[i];\n\t\t\t\tif(used[nx][ny]==-1){\n\t\t\t\t\tused[nx][ny]=used[x][y]+1;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn INF;\n}\n\nint dijk(){\n\tpriority_queue<data> que;\n\tque.push(data(0,0,0,0));\n\tfor(int i=0;i<=60;i++){\n\t\tfor(int j=0;j<=60;j++){\n\t\t\tfor(int k=0;k<=900;k++){\n\t\t\t\tdp[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tque.push(data(0,0,0,0));\n\tdp[0][0][0]=0;\n\twhile(que.size()){\n\t\tdata d=que.top();\n\t\tque.pop();\n\t\tif(dp[d.x][d.y][d.c]!=d.dc)continue;\n\t\tif(d.x==(w-1)*2 && d.y==(h-1)*2)return d.dc;\n\t\t//printf(\"%d %d %d %d\\n\",d.x,d.y,d.c,d.dc);\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(cost[d.x][d.y][i]==INF)continue;\n\t\t\tint nx=d.x+dx[i]*2,ny=d.y+dy[i]*2;\n\t\t\tif(nx>=0 && nx<w*2-1 && ny>=0 && ny<h*2-1){\n\t\t\t\tif(fie[nx-dx[i]][ny-dy[i]]==1)continue;\n\t\t\t\tint ndc=max(d.dc,cost[d.x][d.y][i]+d.c);\n\t\t\t\tndc=max(ndc,d.c+1);\n\t\t\t\tif(dp[nx][ny][d.c+1]>ndc && d.c<900){\n\t\t\t\t\tdp[nx][ny][d.c+1]=ndc;\n\t\t\t\t\tque.push(data(nx,ny,d.c+1,ndc));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tif(h==0 && w==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<2*h-1;i++){\n\t\t\tif(i%2==0){\n\t\t\t\tfor(int j=0;j<w-1;j++){\n\t\t\t\t\tscanf(\"%d\",&fie[j*2+1][i]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tscanf(\"%d\",&fie[j*2][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<2*h-1;i+=2){\n\t\t\tfor(int j=0;j<w*2;j+=2){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint x=j+dx[k],y=i+dy[k];\n\t\t\t\t\tif(x>=0 && x<w*2-1 && y>=0 && y<w*2-1){\n\t\t\t\t\t\tif(fie[x][y]==0){\n\t\t\t\t\t\t\tfie[x][y]=1;\n\t\t\t\t\t\t\tcost[j][i][k]=bfs(j,i);\n\t\t\t\t\t\t\tfie[x][y]=0;\n\t\t\t\t\t\t}else cost[j][i][k]=INF;\n\t\t\t\t\t}else cost[j][i][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<bitset>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<functional>\n#include<algorithm>\nusing namespace std;\n\nenum {N, E, S, W};\nconst unsigned long ALL = 1 + 2 + 4 + 8;\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\n\nconst int INF = 10000;\n\n// for bfs\nenum {Y, X, STEP};\ntypedef tuple<int, int, int> Node;\ntypedef tuple<int, int> Vertex;\n\n// for Dijkstra\nenum {DWORST, DSTEP, DY, DX};\ntypedef tuple<int, int, int, int> DNode;\n\nint h, w;\nvector<vector<bitset<4>>> wall;\n\nint bfs(int by, int bx, int bd, int init_step) {\n    queue<Node> q;\n    q.push(Node(by, bx, init_step));\n    set<Vertex> visited;\n    while(!q.empty()) {\n        int y = get<Y>(q.front());\n        int x = get<X>(q.front());\n        int step = get<STEP>(q.front());\n        q.pop();\n        if(y == h - 1 && x == w - 1) return step;\n        if(visited.count(Vertex(y, x))) continue;\n        visited.insert(Vertex(y, x));\n\n        for(const auto& d: {N, E, S, W}) {\n            if(wall[y][x][d]) continue;\n            if(y == by && x == bx && d == bd) continue;\n            int ny = y + dy[d];\n            int nx = x + dx[d];\n            if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            q.push(Node(ny, nx, step + 1));\n        }\n    }\n    return INF;\n}\n\nint Dijkstra() {\n    priority_queue<DNode, vector<DNode>, greater<DNode>> q;\n    q.push(DNode(-1, 0, 0, 0));\n    set<Vertex> visited;\n    while(!q.empty()) {\n        int worst = get<DWORST>(q.top());\n        int y = get<DY>(q.top());\n        int x = get<DX>(q.top());\n        int step = get<DSTEP>(q.top());\n        q.pop();\n        if(y == h - 1 && x == w - 1) return worst;\n        if(visited.count(Vertex(y, x))) continue;\n        visited.insert(Vertex(y, x));\n        for(const auto& d: {N, E, S, W}) {\n            if(wall[y][x][d]) continue;\n            int ny = y + dy[d];\n            int nx = x + dx[d];\n            if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            if(visited.count(Vertex(ny, nx))) continue;\n            int nworst = max(worst, bfs(y, x, d, step));\n            q.push(DNode(nworst, step + 1, ny, nx));\n        }\n    }\n    return INF;\n}\n\nint main() {\n    while(cin >> h >> w, h | w) {\n        wall = vector<vector<bitset<4>>>(h, vector<bitset<4>>(w, bitset<4>(ALL)));\n        for(int i = 0; i < h - 1; ++i) {\n            for(int j = 0; j < w - 1; ++j) {\n                int is_wall;\n                cin >> is_wall;\n                if(is_wall) continue;\n                wall[i][j].reset(E);\n                wall[i][j + 1].reset(W);\n            }\n            for(int j = 0; j < w; ++j) {\n                int is_wall;\n                cin >> is_wall;\n                if(is_wall) continue;\n                wall[i][j].reset(S);\n                wall[i + 1][j].reset(N);\n            }\n        }\n        for(int j = 0; j < w - 1; ++j) {\n            int is_wall;\n            cin >> is_wall;\n            if(is_wall) continue;\n            wall[h - 1][j].reset(E);\n            wall[h - 1][j + 1].reset(W);\n        }\n\n        int answer = Dijkstra();\n        cout << (answer == INF ? -1 : answer) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nstruct state {\n    P p;\n    int c, d;\n};\nbool operator<(const state &a, const state &b) {\n    if (a.c != b.c) return a.c > b.c;\n    return a.d > b.d;\n}\n\nint h, w;\nint wall[30][30][30][30];\nint dist[4][30][30][30][30];\nint dp[30][30][1800];\nint dd[] = {-1, 0, 1, 0, -1};\n\nbool range(int y, int x) {\n    return 0 <= y && y < h && 0 <= x && x < w;\n}\n\nvoid bfs(int d[30][30], int si, int sj) {\n    rep(i, 30)rep(j, 30) d[i][j] = INF;\n\n    queue<PIP> q;\n    q.push(PIP(0, P(si, sj)));\n    while(q.size()) {\n        PIP p = q.front(); q.pop();\n        int i = p.se.fi, j = p.se.se, c = p.fi;\n        if (d[i][j] < INF) continue;\n        d[i][j] = c;\n        rep(dir, 4) {\n            int ni = i + dd[dir], nj = j + dd[dir + 1];\n            if (range(ni, nj) && !wall[i][j][ni][nj] && d[ni][nj] == INF) {\n                q.push(PIP(c + 1, P(ni, nj)));\n            }\n        }\n    }\n}\n\nint main(){\n    cin.sync_with_stdio(false);\n    while(cin >> h >> w, h | w) {\n        rep(i, 2 * h - 1) {\n            int ii = i / 2, t;\n            if (i % 2) {\n                rep(j, w) {\n                    cin >> t;\n                    wall[ii][j][ii + 1][j] = wall[ii + 1][j][ii][j] = t;\n                }\n            } else {\n                rep(j, w - 1) {\n                    cin >> t;\n                    wall[ii][j][ii][j + 1] = wall[ii][j + 1][ii][j] = t;\n                }\n            }\n        }\n\n        bool ok = true;\n        rep(i, h)rep(j, w) {\n            rep(dir, 4) {\n                int ni = i + dd[dir], nj = j + dd[dir + 1];\n                if (range(ni, nj) && !wall[i][j][ni][nj]) {\n                    wall[i][j][ni][nj] = wall[ni][nj][i][j] = 1;\n                    bfs(dist[dir][i][j], h - 1, w - 1);\n                    if (dist[dir][i][j][i][j] == INF) ok = false;\n                    wall[i][j][ni][nj] = wall[ni][nj][i][j] = 0;\n                }\n            }\n        }\n\n        int ans = -1;\n        priority_queue<state> q;\n        q.push((state){P(0, 0), 0, 0});\n        rep(i, h)rep(j, w)rep(k, h * w * 2) dp[i][j][k] = INF;\n        while(q.size()) {\n            state s = q.top(); q.pop();\n            int i = s.p.fi, j = s.p.se;\n            if (dp[i][j][s.d] < INF || s.d == h * w * 2 - 1) continue;\n            if (i == h - 1 && j == w - 1) {\n                ans = s.c;\n                break;\n            }\n            dp[i][j][s.d] = s.c;\n            rep(dir, 4) {\n                int ni = i + dd[dir], nj = j + dd[dir + 1];\n                if (range(ni, nj) && !wall[i][j][ni][nj] && dp[ni][nj][s.d + 1] == INF && dist[dir][i][j][i][j] < INF) {\n                    q.push((state){P(ni, nj), max(s.c, s.d + dist[dir][i][j][i][j]), s.d + 1});\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint h,w;\nbool B[59][59];\n\nint bfs(int i0,int j0){\n\tint d[30][30];\n\trep(i,h) rep(j,w) d[i][j]=INF;\n\td[i0][j0]=0;\n\tpair<int,int> Q[900];\n\tint head=0,tail=0; Q[tail++]=make_pair(i0,j0);\n\twhile(head<tail){\n\t\tint i=Q[head].first,j=Q[head].second; head++;\n\t\trep(k,4){\n\t\t\tint ii=i+dy[k],jj=j+dx[k];\n\t\t\tif(0<=ii && ii<h && 0<=jj && jj<w && B[2*i+dy[k]][2*j+dx[k]]==0\n\t\t\t&& d[ii][jj]>d[i][j]+1){\n\t\t\t\td[ii][jj]=d[i][j]+1;\n\t\t\t\tQ[tail++]=make_pair(ii,jj);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[h-1][w-1];\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&h,&w),h;){\n\t\trep(i,2*h-1) rep(j,2*w-1) B[i][j]=false;\n\t\trep(i,2*h-1){\n\t\t\tif(i%2==0){\n\t\t\t\trep(j,w-1){\n\t\t\t\t\tint b; scanf(\"%d\",&b);\n\t\t\t\t\tB[i][2*j+1]=b;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\trep(j,w){\n\t\t\t\t\tint b; scanf(\"%d\",&b);\n\t\t\t\t\tB[i][2*j]=b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// cost[i][j][k] := ( (i,j) から出発して, (i,j) の方向 k にあるドアが使えないときの, ゴールまでの最短距離 )\n\t\tint cost[30][30][4];\n\t\trep(i,h) rep(j,w) rep(k,4) {\n\t\t\tint y=2*i+dy[k],x=2*j+dx[k];\n\t\t\tif(0<=y && y<2*h-1 && 0<=x && x<2*w-1){\n\t\t\t\tint tmp=B[y][x];\n\t\t\t\tB[y][x]=1;\n\t\t\t\tcost[i][j][k]=bfs(i,j);\n\t\t\t\tB[y][x]=tmp;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcost[i][j][k]=bfs(i,j);\n\t\t\t}\n\t\t}\n\n\t\tint dp[30][30]; // dp[i][j] := ( (i,j) から出発したときの解 )\n\t\trep(i,h) rep(j,w) dp[i][j]=INF;\n\t\tdp[h-1][w-1]=0;\n\t\twhile(1){ // トポロジカル順序がよくわからんので Bellman-Ford っぽく緩和する\n\t\t\tbool changed=false;\n\t\t\trep(i,h) rep(j,w) {\n\t\t\t\tint tmp1=0;\n\t\t\t\trep(k,4){\n\t\t\t\t\ttmp1=max(tmp1,cost[i][j][k]); // (i,j) に隣接するドアが使えなかったとき\n\t\t\t\t}\n\t\t\t\tint tmp2=INF;\n\t\t\t\trep(k,4){\n\t\t\t\t\tint ii=i+dy[k],jj=j+dx[k];\n\t\t\t\t\tif(0<=ii && ii<h && 0<=jj && jj<w && B[2*i+dy[k]][2*j+dx[k]]==0){\n\t\t\t\t\t\ttmp2=min(tmp2,dp[ii][jj]+1); // (i,j) と隣接しないどこか他のドアが使えなかったとき\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp1=max(tmp1,tmp2);\n\n\t\t\t\tif(dp[i][j]>tmp1){\n\t\t\t\t\tdp[i][j]=tmp1;\n\t\t\t\t\tchanged=true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!changed) break;\n\t\t}\n\n\t\tprintf(\"%d\\n\",dp[0][0]<INF?dp[0][0]:-1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reps(i,a,b) for(int i=(a); i<(b); ++i)\n#define rep(i,n) reps(i,0,n)\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nstruct UnionFind{\n\tstd::vector<int> data;\n\tUnionFind(int size): data(size, -1) {}\n\n\tbool unite(int x, int y){\n\t\tx=root(x);\n\t\ty=root(y);\n\t\tif( x != y ){\n\t\t\tif( data[y] < data[x] ) std::swap(x, y);\n\t\t\tdata[x] += data[y];\n\t\t\tdata[y] = x;\n\t\t}\n\t\treturn x!=y;\n\t}\n\n\tbool find(int x, int y){\n\t\treturn root(x) == root(y);\n\t}\n\n\tint root(int x){\n\t\treturn (data[x] < 0)? x : data[x]=root(data[x]);\n\t}\n\n\tint size(int x){\n\t\treturn -data[ root(x) ];\n\t}\n};\n\n// R, U, L, D\nconst int vx[]={1,0,-1,0}, vy[]={0,1,0,-1};\n\nconst int INF = 1e9;\n\nint h, w;\nint ans;\nmap<pii,int> cost;\nvoid solve(map<pii,int> &mp, map<pii,int> &tb, int x, int y, int d){\n\tqueue<pair<pii,int>> que;\n\tque.push( {pii(x,y), d} );\n\ttb[pii(x,y)] = d;\n\twhile(!que.empty()){\n\t\tauto cur = que.front().X;\n\t\tint x = cur.X;\n\t\tint y = cur.Y;\n\t\tint d = que.front().Y;\n\t\tque.pop();\n\t\trep(k,4){\n\t\t\tint nx = x + vx[k];\n\t\t\tint ny = y + vy[k];\n\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n\t\t\tif( mp[cur] & (1<<k) ) continue;\n\t\t\tif( !tb.count(pii(nx,ny)) || tb[pii(nx,ny)] > d + 1 ){\n\t\t\t\ttb[pii(nx,ny)] = d + 1;\n\t\t\t\tque.push( {pii(nx,ny), d+1} );\n\t\t\t}\n\t\t}\n\t}\n\tif( !tb.count(pii(w-1,h-1)) ) tb[pii(w-1,h-1)] = INF;\n\tcost[pii(x,y)] = max(cost[pii(x,y)], tb[pii(w-1,h-1)]);\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\twhile(cin >> h >> w, h|w){\n\t\tcost.clear();\n\t\tmap<pii,int> mp;\n\t\tint d;\n\t\trep(i,h-1){\n\t\t\trep(j,w-1){\n\t\t\t\tcin >> d;\n\t\t\t\tif( d == 1 ){\n\t\t\t\t\tmp[pii(j,i)]   |= (1<<0);\n\t\t\t\t\tmp[pii(j+1,i)] |= (1<<2);\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,w){\n\t\t\t\tcin >> d;\n\t\t\t\tif( d == 1 ){\n\t\t\t\t\tmp[pii(j,i)]   |= (1<<1);\n\t\t\t\t\tmp[pii(j,i+1)] |= (1<<3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint i = h-1;\n\t\trep(j,w-1){\n\t\t\tcin >> d;\n\t\t\tif( d == 1 ){\n\t\t\t\tmp[pii(j,i)]   |= (1<<0);\n\t\t\t\tmp[pii(j+1,i)] |= (1<<2);\n\t\t\t}\n\t\t}\n\t\trep(i,h) mp[pii(0,i)]   |= (1<<2);\n\t\trep(i,h) mp[pii(w-1,i)] |= (1<<0);\n\t\trep(i,w) mp[pii(i,0)]   |= (1<<3);\n\t\trep(i,w) mp[pii(i,h-1)] |= (1<<1);\n\n\t\tmap<pii,int> tb_s;\n\t\tsolve(mp, tb_s, 0, 0, 0);\n\t\tans = 0;\n//\t\trep(i,h){\n//\t\t\trep(j,w) cout << tb_s[pii(j,i)] << \" \";\n//\t\t\tcout << endl;\n//\t\t}\n\n\t\trep(y,h) rep(x,w) rep(k,4){\n\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n\t\t\tif( cost[pii(x,y)] >= INF ) continue;\n\t\t\tint nx = x + vx[k];\n\t\t\tint ny = y + vy[k];\n\t\t\tauto mp1 = mp;\n\t\t\tmp1[pii(x,y)]   |= (1<<k);\n\t\t\tmp1[pii(nx,ny)] |= (1<<((k+2)%4));\n\t\t\tmap<pii,int> tb;\n\t\t\t//solve(mp1, tb, x, y, tb_s[pii(x,y)]);\n\t\t\tsolve(mp1, tb, x, y, 0);\n\t\t\t//cout << \"solve: \" << x << \" \" << y << \" k=\" << k << endl;\n\t\t\t//rep(i,h){\n\t\t\t//\trep(j,w) cout << tb[pii(j,i)] << \" \";\n\t\t\t//\tcout << endl;\n\t\t\t//}\n\t\t}\n\n//\t\tcout << \"cost:\" << endl;\n//\t\trep(i,h){\n//\t\t\trep(j,w) cout << (cost[pii(j,i)]==INF ? 99 : cost[pii(j,i)]) << \" \";\n//\t\t\tcout << endl;\n//\t\t}\n\n\t\tint l=0, r=1000;\n\t\twhile(r-l>1){\n\t\t\tint limit = (l+r)/2;\n\t\t\ttypedef pair<pii,pii> PII;\n\t\t\tpriority_queue<PII, vector<PII>, greater<PII>> que;\n\t\t\tpii memo[50][50];\n\t\t\tfill( memo[0], memo[0]+50*50, pii(INF,INF) );\n\t\t\tque.push({{cost[pii(0,0)],0},pii(0,0)});\n\t\t\twhile(!que.empty()){\n\t\t\t\tint c = que.top().X.X;\n\t\t\t\tint d = que.top().X.Y;\n\t\t\t\tint x = que.top().Y.X;\n\t\t\t\tint y = que.top().Y.Y;\n\t\t\t\tque.pop();\n\t\t\t\tif( memo[x][y] < pii(c,d) ) continue;\n\t\t\t\t//if( memo.count(pii(x,y)) ) continue;\n\t\t\t\t//if( c > limit ) continue;\n\t\t\t\t//memo[pii(x,y)] = pii(c,d);\n\t\t\t\t//ans = max(ans, c);\n\t\t\t\tif( pii(x,y) == pii(w-1,h-1) ) break;\n\t\t\t\trep(k,4){\n\t\t\t\t\tint nx = x + vx[k];\n\t\t\t\t\tint ny = y + vy[k];\n\t\t\t\t\tint nc = d + 1 + cost[pii(nx,ny)];\n\t\t\t\t\tnc = min(nc, INF);\n\t\t\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n\t\t\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n\t\t\t\t\tif( memo[nx][ny] > pii(nc,d+1) ){\n\t\t\t\t\t\tif( nc <= limit ){\n\t\t\t\t\t\t\tmemo[nx][ny] = pii(nc, d+1);\n\t\t\t\t\t\t\tque.push( {pii(nc, d+1), pii(nx, ny)} );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( memo[w-1][h-1].X < INF ){\n\t\t\t\tr = limit;\n\t\t\t}else{\n\t\t\t\tl = limit;\n\t\t\t}\n\t\t}\n\t\tans = (r<1000 ? r : -1);\n//\t\tpii pos = {w-1,h-1};\n//\t\tans = max(ans, memo[pos].X);\n//\t\twhile( pos != pii(0,0) ){\n//\t\t\tint x = pos.X;\n//\t\t\tint y = pos.Y;\n//\t\t\trep(k,4){\n//\t\t\t\tint nx = x + vx[k];\n//\t\t\t\tint ny = y + vy[k];\n//\t\t\t\tint nc = d + 1 + cost[pii(nx,ny)];\n//\t\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n//\t\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n//\t\t\t\tif( memo.count(pii(nx,ny)) && memo[pii(nx,ny)].Y < memo[pos].Y ){\n//\t\t\t\t\tpos = pii(nx,ny);\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tans = max(ans, memo[pos].X);\n//\t\t}\n\n//\t\tmultimap<int, pii> order;\n//\t\tfor(auto t: memo) order.insert({ t.Y.X, t.X });\n//\t\tUnionFind uf(1000);\n//\t\tfor(auto t: order){\n//\t\t\tint x = t.Y.X;\n//\t\t\tint y = t.Y.Y;\n//\t\t\trep(k,4){\n//\t\t\t\tint nx = x + vx[k];\n//\t\t\t\tint ny = y + vy[k];\n//\t\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n//\t\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n//\t\t\t\tif( memo[pii(nx,ny)].X <= t.X ){\n//\t\t\t\t\tuf.unite( nx+ny*w, x+y*w );\n//\t\t\t\t}\n//\t\t\t}\n////\t\t\tcout << \"order: \" << x << \" \" << y << \" \" << t.X << endl;\n//\t\t\tif( uf.find(0, (w-1)+(h-1)*w ) ){\n//\t\t\t\tans = t.X;\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t}\n\n\t\tcout << (ans >= INF ? -1 : ans) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <ctime>\n#include <sstream>\n#include <fstream>\n#include <bitset>\n#include <iomanip>\n#include <assert.h>\n\nusing namespace std;\ntypedef long long LL;\ntypedef long double LD;\n\n#define PII pair<int, int>\n#define sz(X) ((int)((X).size()))\n\ntemplate<class T> T abs(T x){return x < 0 ? -x : x;}\n\nconst int dx[4] = {0, 0, 1, -1};\nconst int dy[4] = {1, -1, 0, 0};\n\nconst int maxn = 31, maxs = 100000;\nint d[maxn][maxn][4][maxn][maxn], ans[maxn][maxn];\nbool b[maxn][maxn];\nbool g[maxn][maxn][4];\nint x[maxs], y[maxs], s[maxs];\nint n, m;\n\nvoid bfs(int tx, int ty, int tk){\n\tint l = 1, r = 1;\n\tx[l] = n; y[r] = m;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= m; ++j)\n\t\t\td[tx][ty][tk][i][j] = -1;\n\td[tx][ty][tk][n][m] = 0;\n\twhile (l <= r){\n\t\tfor (int k = 0; k < 4; ++k)\n\t\t\tif (g[x[l]][y[l]][k]){\n\t\t\t\tint u = x[l] + dx[k], v = y[l] + dy[k];\n\t\t\t\tif (u == 0 || v == 0 || u > n || v > m) continue;\n\t\t\t\tif (d[tx][ty][tk][u][v] != -1) continue;\n\t\t\t\td[tx][ty][tk][u][v] = d[tx][ty][tk][x[l]][y[l]] + 1;\n\t\t\t\tx[++r] = u;\n\t\t\t\ty[r] = v;\n\t\t\t}\n\t\t++l;\n\t}\n}\n\nvoid spfa(){\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= m; ++j){\n\t\t\tb[i][j] = false;\n\t\t\tans[i][j] = -1;\n\t\t}\n\tint l = 1, r = 1;\n\tb[1][1] = true;\n\tans[1][1] = 0;\n\tx[l] = 1; y[l] = 1; s[l] = 0;\n\twhile (l <= r){\n\t\tint i = x[l], j = y[l];\n\t\tfor (int k = 0; k < 4; ++k)\n\t\t\tif (g[i][j][k]){\n\t\t\t\tint u = i + dx[k], v = j + dy[k];\n\t\t\t\tif (d[i][j][k][i][j] == -1) continue;\n\t\t\t\tint tmp = max(ans[i][j], s[l] + d[i][j][k][i][j]);\n\t\t\t\tif (ans[u][v] == -1 || tmp < ans[u][v]){\n\t\t\t\t\tans[u][v] = tmp;\n\t\t\t\t\tif (!b[u][v]){\n\t\t\t\t\t\tb[u][v] = true;\n\t\t\t\t\t\tx[++r] = u;\n\t\t\t\t\t\ty[r] = v;\n\t\t\t\t\t\ts[r] = s[l] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tb[i][j] = false;\n\t\t++l;\n\t}\n\tprintf(\"%d\\n\", ans[n][m]);\n}\n\nint main(){\n\twhile (scanf(\"%d%d\", &n, &m)){\n\t\tif (n == 0) break;\n\t\tmemset(g, false, sizeof(g));\n\t\tfor (int i = 1; i <= n; ++i){\n\n\t\t\tfor (int j = 1; j <= m - 1; ++j){\n\t\t\t\tint x;\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tif (x == 0){\n\t\t\t\t\tg[i][j][0] = true;\n\t\t\t\t\tg[i][j + 1][1] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i != n){\n\t\t\t\tfor (int j = 1; j <= m; ++j){\n\t\t\t\t\tint x;\n\t\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\t\tif (x == 0){\n\t\t\t\t\t\tg[i][j][2] = true;\n\t\t\t\t\t\tg[i + 1][j][3] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool ok = true;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tfor (int j = 1; j <= m; ++j)\n\t\t\t\tfor (int k = 0; k < 4; ++k)\n\t\t\t\t\tif (g[i][j][k]){\n\t\t\t\t\t\tint t, u = i + dx[k], v = j + dy[k];\n\t\t\t\t\t\tif (k <= 1) t = 1 - k; else t = 5 - k;\n\t\t\t\t\t\tg[i][j][k] = false;\n\t\t\t\t\t\tg[u][v][t] = false;\n\t\t\t\t\t\tbfs(i, j, k);\n\t\t\t\t\t\tif (d[i][j][k][1][1] == -1){\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tg[i][j][k] = true;\n\t\t\t\t\t\tg[u][v][t] = true;\n\t\t\t\t\t}\n\t\tif (!ok){\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\tspfa();\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst int INF = INT_MAX / 2;\nint dy[] = {1, -1, 0, 0};\nint dx[] = {0, 0, -1, 1};\n\nint h, w;\nvector<vector<bool> > wall;\n\nint minDist(int sy, int sx)\n{\n    vector<vector<bool> > check(2*h+1, vector<bool>(2*w+1, false));\n    check[2*h-1][2*w-1] = true;\n    queue<pair<int, int> > q;\n    q.push(make_pair(2*h-1, 2*w-1));\n\n    int ret = 0;\n    while(!q.empty()){\n        int m = q.size();\n        while(--m >= 0){\n            int y1 = q.front().first;\n            int x1 = q.front().second;\n            q.pop();\n            if(y1 == sy && x1 == sx)\n                return ret;\n\n            for(int i=0; i<4; ++i){\n                int y2 = y1 + dy[i];\n                int x2 = x1 + dx[i];\n                if(wall[y2][x2])\n                    continue;\n                y2 += dy[i];\n                x2 += dx[i];\n                if(check[y2][x2])\n                    continue;\n                check[y2][x2] = true;\n                q.push(make_pair(y2, x2));\n            }\n        }\n        ++ ret;\n    }\n    return INF;\n}\n\nint solve()\n{\n    vector<vector<int> > dp(2*h+1, vector<int>(2*w+1, INF));\n    dp[2*h-1][2*w-1] = 0;\n    multimap<int, pair<int, int> > mm;\n    mm.insert(make_pair(0, make_pair(2*h-1, 2*w-1)));\n\n    while(!mm.empty()){\n        int cost = mm.begin()->first;\n        int y = mm.begin()->second.first;\n        int x = mm.begin()->second.second;\n        mm.erase(mm.begin());\n        if(cost > dp[y][x])\n            continue;\n        if(y == 1 && x == 1)\n            return cost;\n\n        for(int i=0; i<4; ++i){\n            int y2 = y + dy[i];\n            int x2 = x + dx[i];\n            if(wall[y2][x2])\n                continue;\n\n            wall[y2][x2] = true;\n            y2 += dy[i];\n            x2 += dx[i];\n\n            int cost2 = max(cost + 1, minDist(y2, x2));\n            if(cost2 < dp[y2][x2]){\n                dp[y2][x2] = cost2;\n                mm.insert(make_pair(cost2, make_pair(y2, x2)));\n            }\n\n            y2 -= dy[i];\n            x2 -= dx[i];\n            wall[y2][x2] = false;\n        }\n    }\n\n    return INF;\n}\n\nint main()\n{\n    for(;;){\n        cin >> h >> w;\n        if(h == 0)\n            return 0;\n\n        wall.assign(2*h+1, vector<bool>(2*w+1, false));\n        for(int i=0; i<2*h+1; ++i)\n            wall[i][0] = wall[i][2*w] = true;\n        for(int i=0; i<2*w+1; ++i)\n            wall[0][i] = wall[2*h][i] = true;\n\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w-1; ++j){\n                int tmp;\n                cin >> tmp;\n                wall[2*i+1][2*j+2] = (tmp == 1);\n            }\n            if(i != h-1){\n                for(int j=0; j<w; ++j){\n                    int tmp;\n                    cin >> tmp;\n                    wall[2*i+2][2*j+1] = (tmp == 1);\n                }\n            }\n        }\n\n        int ret = solve();\n        if(ret < INF)\n            cout << ret << endl;\n        else\n            cout << -1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct S {\n\tint x, y, cost;\n\tbool operator <(const S& x) const {\n\t\treturn cost > x.cost;\n\t}\n};\n\nstruct P {\n\tint x, y;\n};\n\nconst int INF = 1 << 28;\nint H, W;\nint ng[31][31][4];\nint d[31][31];\nint gcost[31][31][4][31][31];\n\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nvoid bfs(int x, int y, int k) {\n\tqueue<P> q;\n\tq.push({ W - 1, H - 1 });\n\tgcost[y][x][k][H - 1][W - 1] = 0;\n\twhile(q.size()) {\n\t\tint X = q.front().x, Y = q.front().y;\n\t\tq.pop();\n\t\tint d = gcost[y][x][k][Y][X];\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tint NX = X + dx[i], NY = Y + dy[i];\n\t\t\tif(!in(NX, NY)) continue;\n\t\t\tif(ng[Y][X][i]) continue;\n\t\t\tif(gcost[y][x][k][NY][NX] > d + 1) {\n\t\t\t\tgcost[y][x][k][NY][NX] = d + 1;\n\t\t\t\tq.push({ NX, NY });\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> H >> W, H) {\n\t\tmemset(ng, 0, sizeof ng);\n\t\tfor(int i = 0; i < 2 * H - 1; i++) {\n\t\t\tint h = i / 2;\n\t\t\tif(i % 2 == 0) {\n\t\t\t\tfor(int j = 0; j < W - 1; j++) {\n\t\t\t\t\tint a;\n\t\t\t\t\tcin >> a;\n\t\t\t\t\tif(a) {\n\t\t\t\t\t\tint w = j;\n\t\t\t\t\t\tng[h][w][0] = ng[h][w + 1][2] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\t\tint a;\n\t\t\t\t\tcin >> a;\n\t\t\t\t\tif(a) {\n\t\t\t\t\t\tint w = j;\n\t\t\t\t\t\tng[h][w][1] = ng[h + 1][w][3] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfill((int*)begin(gcost), (int*)end(gcost), INF);\n\t\tfor(int y = 0; y < H; y++) {\n\t\t\tfor(int x = 0; x < W; x++) {\n\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\tif(ng[y][x][k]) continue;\n\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\tng[y][x][k] = 1;\n\t\t\t\t\tif(in(nx, ny)) ng[ny][nx][(k + 2) % 4] = 1;\n\t\t\t\t\tbfs(x, y, k);\n\t\t\t\t\tng[y][x][k] = 0;\n\t\t\t\t\tif(in(nx, ny)) ng[ny][nx][(k + 2) % 4] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<S> q;\n\t\tq.push({ W - 1,H - 1, 0 });\n\t\tfill((int*)begin(d), (int*)end(d), INF);\n\t\td[H - 1][W - 1] = 0;\n\n\t\twhile(q.size()) {\n\t\t\tint X = q.top().x, Y = q.top().y;\n\t\t\tint cost = q.top().cost;\n\t\t\tq.pop();\n\t\t\tif(d[Y][X] < cost) continue;\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tint NX = X + dx[k], NY = Y + dy[k];\n\t\t\t\tif(!in(NX, NY)) continue;\n\t\t\t\tint ncost = max(cost + 1, gcost[NY][NX][(k + 2) % 4][NY][NX]);\n\t\t\t\tif(d[NY][NX] > ncost) {\n\t\t\t\t\td[NY][NX] = ncost;\n\t\t\t\t\tq.push({ NX, NY, ncost });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(d[0][0] == INF) cout << -1 << endl;\n\t\telse cout << d[0][0] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int inf = 1<<20;\nconst int dxs[] = {-1, 0, 1, 0};\nconst int dys[] = {0, 1, 0, -1};\n\nvoid calc_memo(vector<vector<int> > &wall, vector<int> &memo)\n{\n\tconst int h = wall.size();\n\tconst int w = wall[0].size();\n\n\tfor(int sx = 0; sx < h; ++sx) {\n\t\tfor(int sy = 0; sy < w; ++sy) {\n\t\t\tfor(int wd = 0; wd < 4; ++wd) {\n\n\t\t\t\tvector<int> dist(h * w, inf);\n\t\t\t\tqueue<pair<int, int> > q;\n\n\t\t\t\tq.push(make_pair(sx, sy));\n\t\t\t\tdist[sx * w + sy] = 0;\n\n\t\t\t\twhile(!q.empty()) {\n\n\t\t\t\t\tint x = q.front().first;\n\t\t\t\t\tint y = q.front().second;\n\t\t\t\t\tq.pop();\n\n\t\t\t\t\tfor(int dir = 0; dir < 4; ++dir) {\n\n\t\t\t\t\t\tint dx = dxs[dir], dy = dys[dir];\n\t\t\t\t\t\tint nx = dx + x, ny = dy + y;\n\t\t\t\t\t\tbool ok = ((1 << dir) & wall[x][y]) == 0;\n\t\t\t\t\t\tif(x == sx && y == sy && wd == dir)\n\t\t\t\t\t\t\tok = false;\n\n\t\t\t\t\t\tif(!ok)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif(nx < 0 || nx >= h || ny < 0 || ny >= w)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif(dist[nx * w + ny] < inf)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tdist[nx * w + ny] = dist[x * w + y] + 1;\n\t\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmemo[(sx * w + sy) * 4 + wd] = dist[w * h - 1];\n\t\t\t\t//printf(\"debug calc_memo: %d %d %d -> %d (%d)\\n\", sx, sy, wd, dist[w * h - 1], wall[sx][sy] & (1<<wd));\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool check(int card, vector<vector<int> > &wall, vector<int> &memo)\n{\n\tconst int h = wall.size();\n\tconst int w = wall[0].size();\n\tvector<int> dist(h * w, inf);\n\tqueue<pair<int, int> > q;\n\n\tq.push(make_pair(0, 0));\n\tdist[0] = 0;\n\n\t//printf(\"debug: check %d\\n\", card);\n\n\twhile(!q.empty()) {\n\n\t\tint x = q.front().first;\n\t\tint y = q.front().second;\n\t\tq.pop();\n\t\tint d = dist[x * w + y];\n\n\t\tfor(int dir = 0; dir < 4; ++dir) {\n\n\t\t\tint nx = x + dxs[dir], ny = y + dys[dir];\n\t\t\tbool ok = ((1 << dir) & wall[x][y]) == 0;\n\n\t\t\tif(!ok)\n\t\t\t\tcontinue;\n\t\t\tif(nx < 0 || nx >= h || ny < 0 || ny >= w)\n\t\t\t\tcontinue;\n\t\t\tif(d + memo[(x * w + y) * 4 + dir] > card)\n\t\t\t\tcontinue;\n\t\t\tif(dist[nx * w + ny] < inf)\n\t\t\t\tcontinue;\n\n\t\t\t//printf(\"debug: %d %d %d -> %d %d\\n\", x, y, dir, d, memo[(x*w+y)*4+dir]);\n\t\t\tdist[nx * w + ny] = d + 1;\n\t\t\tq.push(make_pair(nx, ny));\n\t\t}\n\t}\n\n\n\treturn dist[w * h - 1] < inf;\n}\n\nint main()\n{\n\twhile(true) {\n\n\t\tint h, w;\n\t\tvector<vector<int> > wall;\n\n\t\tscanf(\"%d%d\", &h, &w);\n\t\tif(h == 0)\n\t\t\tbreak;\n\n\t\twall.resize(h);\n\t\tfor(int i = 0; i < h; ++i)\n\t\t\twall[i].resize(w, 15);\n\n\t\tfor(int i = 0; i < h * 2 - 1; ++i) {\n\t\t\tfor(int j = 0; j < (i % 2 == 0 ? w - 1 : w); ++j) {\n\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\n\t\t\t\tif(t == 1)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif(i % 2 == 0)\n\t\t\t\t\twall[i / 2][j] ^= 2, wall[i / 2][j + 1] ^= 8;\n\t\t\t\tif(i % 2 == 1)\n\t\t\t\t\twall[i / 2][j] ^= 4, wall[i / 2 + 1][j] ^= 1;\n\t\t\t}\n\t\t}\n\n\t\tvector<int> memo(w*h*4);\n\n\t\tcalc_memo(wall, memo);\n\n\t\tint lb = 0, ub = inf;\n\n\t\twhile(ub - lb > 1) {\n\t\t\tint mid = (lb + ub) / 2;\n\t\t\tif(check(mid, wall, memo))\n\t\t\t\tub = mid;\n\t\t\telse\n\t\t\t\tlb = mid;\n\t\t}\n\n\t\tint ans = ub < inf ? ub : -1;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#ifdef DEBUG_MODE\n    #define DBG(n) n;\n#else\n    #define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n \ntypedef long long ll;\ntypedef pair<pair<int,int>,int> P;\nint h,w;\npair<int,int> dp[33*33];\nint dist[33*33];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nvector<vector<int>> v(33*33);\n \nint fun(int a,int b){\n    REP(i,33*33)dist[i] = INF;\n    dist[a] = 0;\n    queue<pair<int,int>> q;\n    q.push(MP(a,0));\n    while(!q.empty()){\n        pair<int,int> now = q.front();q.pop();\n        int node = now.FI;\n        int kyo = now.SE;\n        if(kyo > dist[node])continue;\n        REP(i,v[node].size()){\n            int aite = v[node][i];\n            if((node == a && aite == b) || (node == b && aite == a))continue;\n            if(dist[aite] > kyo + 1){\n                dist[aite] = kyo + 1;\n                q.push(MP(aite,kyo+1));\n            }\n        }\n    }\n    return dist[h*w-1];\n}\n \nint main()\n{\n    while(cin >> h >> w,h|w){\n        //初期化\n        REP(i,33*33)dp[i] = MP(INF,INF);\n        REP(i,33*33){v[i].clear();}\n        dp[0] = MP(0,0);\n         \n        //入力\n        REP(i,h){\n            REP(j,w-1){\n                int tmp;cin >> tmp;\n                if(tmp == 0){\n                    v[i*w+j].PB(i*w+j+1);\n                    v[i*w+j+1].PB(i*w+j);\n                }\n                 \n            }\n            if(i != h-1)REP(j,w){\n                int tmp;cin >> tmp;\n                if(tmp == 0){\n                    v[i*w+j].PB((i+1)*w+j);\n                    v[(i+1)*w+j].PB(i*w+j);\n                }\n            }\n        }\n                 \n        priority_queue<P,vector<P>,greater<P>> q;\n        q.push(MP(MP(0,-1),0));\n        DBG(cout << \"!\" << endl;);\n        while(!q.empty()){\n            DBG(\n            cout << \"DP TABLE\" << endl;\n            REP(i,h){\n                REP(j,w){\n                    cout << dp[i*w+j].FI << ' ';\n                }\n                cout << endl;\n            }\n            )\n            P now = q.top();q.pop();\n            int node = now.SE;\n            pair<int,int> kyori = now.FI;\n            DBG(cout << kyori.FI << ' ' << kyori.SE << endl;)\n            DBG(cout << dp[node].FI << ' ' << dp[node].SE << endl;)\n            if(dp[node].FI < kyori.FI && dp[node].SE < kyori.SE)continue;\n            DBG(cout << \"IN\" << endl;)\n            kyori.SE++;\n            REP(i,v[node].size()){\n                int aite = v[node][i];\n                pair<int,int> score = MP(fun(node,aite)+kyori.SE,kyori.SE);\n                pair<int,int> seica = MP(max(dp[node].FI,score.FI),max(dp[node].SE,score.SE));\n                if(dp[aite].FI > seica.FI || dp[aite].SE > seica.SE){\n\t\t\t\t\tif(dp[aite] > seica)dp[aite] = seica;\n                    q.push(MP(MP(score.FI,kyori.SE),aite));\n                }\n            }\n        }\n         \n        DBG(\n        cout << \"DP TABLE\" << endl;\n        REP(i,h){\n            REP(j,w){\n                cout << dp[i*w+j].FI << ' ';\n            }\n            cout << endl;\n        }\n        )\n         \n        DBG(cout << \"ANS IS \";);\n         \n        if(dp[h*w-1].FI == INF){\n            cout << -1 << endl;\n        }\n        else{\n            cout << dp[h*w-1].FI << endl;\n        }\n    }\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reps(i,a,b) for(int i=(a); i<(b); ++i)\n#define rep(i,n) reps(i,0,n)\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nstruct UnionFind{\n\tstd::vector<int> data;\n\tUnionFind(int size): data(size, -1) {}\n\n\tbool unite(int x, int y){\n\t\tx=root(x);\n\t\ty=root(y);\n\t\tif( x != y ){\n\t\t\tif( data[y] < data[x] ) std::swap(x, y);\n\t\t\tdata[x] += data[y];\n\t\t\tdata[y] = x;\n\t\t}\n\t\treturn x!=y;\n\t}\n\n\tbool find(int x, int y){\n\t\treturn root(x) == root(y);\n\t}\n\n\tint root(int x){\n\t\treturn (data[x] < 0)? x : data[x]=root(data[x]);\n\t}\n\n\tint size(int x){\n\t\treturn -data[ root(x) ];\n\t}\n};\n\n// R, U, L, D\nconst int vx[]={1,0,-1,0}, vy[]={0,1,0,-1};\n\nconst ll INF = 1e9;\n\nint h, w;\nint ans;\nmap<pii,int> cost;\nvoid solve(map<pii,int> &mp, map<pii,int> &tb, int x, int y, int d){\n\tqueue<pair<pii,int>> que;\n\tque.push( {pii(x,y), d} );\n\ttb[pii(x,y)] = d;\n\twhile(!que.empty()){\n\t\tauto cur = que.front().X;\n\t\tint x = cur.X;\n\t\tint y = cur.Y;\n\t\tint d = que.front().Y;\n\t\tque.pop();\n\t\trep(k,4){\n\t\t\tint nx = x + vx[k];\n\t\t\tint ny = y + vy[k];\n\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n\t\t\tif( mp[cur] & (1<<k) ) continue;\n\t\t\tif( !tb.count(pii(nx,ny)) || tb[pii(nx,ny)] > d + 1 ){\n\t\t\t\ttb[pii(nx,ny)] = d + 1;\n\t\t\t\tque.push( {pii(nx,ny), d+1} );\n\t\t\t}\n\t\t}\n\t}\n\tif( !tb.count(pii(w-1,h-1)) ) tb[pii(w-1,h-1)] = INF;\n\tcost[pii(x,y)] = max(cost[pii(x,y)], tb[pii(w-1,h-1)]);\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\twhile(cin >> h >> w, h|w){\n\t\tcost.clear();\n\t\tmap<pii,int> mp;\n\t\tint d;\n\t\trep(i,h-1){\n\t\t\trep(j,w-1){\n\t\t\t\tcin >> d;\n\t\t\t\tif( d == 1 ){\n\t\t\t\t\tmp[pii(j,i)]   |= (1<<0);\n\t\t\t\t\tmp[pii(j+1,i)] |= (1<<2);\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,w){\n\t\t\t\tcin >> d;\n\t\t\t\tif( d == 1 ){\n\t\t\t\t\tmp[pii(j,i)]   |= (1<<1);\n\t\t\t\t\tmp[pii(j,i+1)] |= (1<<3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint i = h-1;\n\t\trep(j,w-1){\n\t\t\tcin >> d;\n\t\t\tif( d == 1 ){\n\t\t\t\tmp[pii(j,i)]   |= (1<<0);\n\t\t\t\tmp[pii(j+1,i)] |= (1<<2);\n\t\t\t}\n\t\t}\n\t\trep(i,h) mp[pii(0,i)]   |= (1<<2);\n\t\trep(i,h) mp[pii(w-1,i)] |= (1<<0);\n\t\trep(i,w) mp[pii(i,0)]   |= (1<<3);\n\t\trep(i,w) mp[pii(i,h-1)] |= (1<<1);\n\n\t\tmap<pii,int> tb_s;\n\t\tsolve(mp, tb_s, 0, 0, 0);\n\t\tans = 0;\n//\t\trep(i,h){\n//\t\t\trep(j,w) cout << tb_s[pii(j,i)] << \" \";\n//\t\t\tcout << endl;\n//\t\t}\n\n\t\trep(y,h) rep(x,w) rep(k,4){\n\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n\t\t\tif( cost[pii(x,y)] >= INF ) continue;\n\t\t\tint nx = x + vx[k];\n\t\t\tint ny = y + vy[k];\n\t\t\tauto mp1 = mp;\n\t\t\tmp1[pii(x,y)]   |= (1<<k);\n\t\t\tmp1[pii(nx,ny)] |= (1<<((k+2)%4));\n\t\t\tmap<pii,int> tb;\n\t\t\t//solve(mp1, tb, x, y, tb_s[pii(x,y)]);\n\t\t\tsolve(mp1, tb, x, y, 0);\n\t\t\t//cout << \"solve: \" << x << \" \" << y << \" k=\" << k << endl;\n\t\t\t//rep(i,h){\n\t\t\t//\trep(j,w) cout << tb[pii(j,i)] << \" \";\n\t\t\t//\tcout << endl;\n\t\t\t//}\n\t\t}\n\n//\t\tcout << \"cost:\" << endl;\n//\t\trep(i,h){\n//\t\t\trep(j,w) cout << (cost[pii(j,i)]==INF ? 99 : cost[pii(j,i)]) << \" \";\n//\t\t\tcout << endl;\n//\t\t}\n\n\t\ttypedef pair<pii,pii> PII;\n\t\tpriority_queue<PII, vector<PII>, greater<PII>> que;\n\t\tmap<pii,pii> memo;\n\t\tque.push({{cost[pii(0,0)],0},pii(0,0)});\n\t\twhile(!que.empty()){\n\t\t\tint c = que.top().X.X;\n\t\t\tint d = que.top().X.Y;\n\t\t\tint x = que.top().Y.X;\n\t\t\tint y = que.top().Y.Y;\n\t\t\tque.pop();\n\t\t\t//if( memo.count(pii(x,y)) && memo[pii(x,y)] < pii(c,d) ) continue;\n\t\t\tif( memo.count(pii(x,y)) ) continue;\n\t\t\tmemo[pii(x,y)] = pii(c,d);\n\t\t\trep(k,4){\n\t\t\t\tint nx = x + vx[k];\n\t\t\t\tint ny = y + vy[k];\n\t\t\t\tint nc = d + 1 + cost[pii(nx,ny)];\n\t\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n\t\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n\t\t\t\tif( !memo.count(pii(nx,ny)) || memo[pii(nx,ny)] > pii(nc,d+1) ){\n\t\t\t\t\t//memo[pii(nx,ny)] = pii(nc, d+1);\n\t\t\t\t\tque.push( {pii(nc, d+1), pii(nx, ny)} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tpii pos = {w-1,h-1};\n//\t\tans = max(ans, memo[pos].X);\n//\t\twhile( pos != pii(0,0) ){\n//\t\t\tint x = pos.X;\n//\t\t\tint y = pos.Y;\n//\t\t\trep(k,4){\n//\t\t\t\tint nx = x + vx[k];\n//\t\t\t\tint ny = y + vy[k];\n//\t\t\t\tint nc = d + 1 + cost[pii(nx,ny)];\n//\t\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n//\t\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n//\t\t\t\tif( memo.count(pii(nx,ny)) && memo[pii(nx,ny)].Y < memo[pos].Y ){\n//\t\t\t\t\tpos = pii(nx,ny);\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tans = max(ans, memo[pos].X);\n//\t\t}\n\n\t\tmultimap<int, pii> order;\n\t\tfor(auto t: memo) order.insert({ t.Y.X, t.X });\n\t\tUnionFind uf(1000);\n\t\tfor(auto t: order){\n\t\t\tint x = t.Y.X;\n\t\t\tint y = t.Y.Y;\n\t\t\trep(k,4){\n\t\t\t\tint nx = x + vx[k];\n\t\t\t\tint ny = y + vy[k];\n\t\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n\t\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n\t\t\t\tif( memo[pii(nx,ny)].X <= t.X ){\n\t\t\t\t\tuf.unite( nx+ny*w, x+y*w );\n\t\t\t\t}\n\t\t\t}\n//\t\t\tcout << \"order: \" << x << \" \" << y << \" \" << t.X << endl;\n\t\t\tif( uf.find(0, (w-1)+(h-1)*w ) ){\n\t\t\t\tans = t.X;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcout << (ans >= INF ? -1 : ans) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstdio>\n#include <cstring>\n#include <climits>\nusing namespace std;\n\nconst int dx[] = {0, 1, 0, -1}; //上右下左\nconst int dy[] = {-1, 0, 1, 0};\nconst int inf = 1<<20;\n\nint w,h;\nint path[4][33][33]; // 未処理の場合は -1, ゴールできないときは inf\nint dp[1000][33][33]; // [step][y][x] 最悪でも1000は越えないだろう…\nstring field[70];\n\nstruct state{\n    int x,y;\n    int step;\n    int worstStep;\n    state(int _x, int _y, int s, int w){\n        x = _x;\n        y = _y;\n        step = s;\n        worstStep = w;\n    }\n    bool operator<(const state& a)const{\n        if( worstStep == a.worstStep ) return step > a.step;\n        return worstStep > a.worstStep;\n    }\n};\n\n\nbool inside(int x, int y){\n    return !( x < 0 || x >= 2*w-1 || y >= 2*h-1 || y < 0 );\n}\n\n\nint bfs(int sx, int sy, int gx, int gy){\n    int k;\n    int memo[33][33];\n    queue<pair<int,int> > q;\n\n    memset(memo, -1, sizeof(memo));\n    q.push(make_pair(sx,sy));\n    memo[sy][sx] = 0;\n\n    if( sx == gx && sy == gy ) return 0;\n\n    while( !q.empty() ){\n        int x = q.front().first;\n        int y = q.front().second;\n        int s = memo[y][x];\n        q.pop();\n\n        for(k=0; k<4; k++){\n            int tx = 2*x + dx[k];\n            int ty = 2*y + dy[k];\n            if( !inside(tx, ty) || field[ty][tx] == '1' ) continue;\n\n            if( memo[y + dy[k]][x + dx[k]] == -1 ){\n                memo[y + dy[k]][x + dx[k]] = s + 1;\n                if( gy == y + dy[k] && gx == x + dx[k] ) return s + 1;\n                q.push(make_pair(x + dx[k], y + dy[k]));\n            }\n        }\n    }\n\n    return inf;\n}\n\nbool isCut(int step, int x, int y, int nextWorstStep){\n    int i;\n    for(i=0; i<=step; i++) if( dp[i][y][x] <= nextWorstStep ) break;\n    return (i > step);\n}\n\nint solve(){\n    int i,k;\n    int cutOff = inf; // 枝刈り用\n    priority_queue<state> q;\n    q.push(state(0,0,0,0));\n\n    while( !q.empty() ){\n        int x = q.top().x;\n        int y = q.top().y;\n        int step = q.top().step;\n        int wstep = q.top().worstStep;\n        q.pop();\n\n        if( wstep == inf || step > 500 ) break;\n\n        if( dp[step][y][x] <= wstep ) continue;\n        dp[step][y][x] = wstep;\n\n        if( y == h-1 && x == w-1 ) return dp[step][h-1][w-1];\n\n        if( cutOff <= wstep ){\n            //cutCount++;\n            continue;\n        }\n\n        for(k=0; k<4; k++){\n            int tx = 2*x + dx[k];\n            int ty = 2*y + dy[k];\n            if( !inside(tx,ty) || field[ty][tx] == '1' ) continue;\n                \n            // ドアが壊れてたときの計算\n            int nextWorstStep = inf;\n\n            // まだBFSで調べてないので調べる\n            if( path[k][y][x] == -1 ){\n                field[ty][tx] = '1';\n                path[k][y][x] = bfs(x, y, w-1, h-1);\n                field[ty][tx] = '0';\n            }\n\n            if( path[k][y][x] == inf ) continue; // ゴールできない\n\n            nextWorstStep = max(wstep, step + path[k][y][x]);\n\n            // step + 1以下の最小値管理をうまくしないと、上で枝刈りしても、ここでキューに突っ込んでるからlogn時間遅くなる\n            // ここをO(1)にしたい、むきー\n            if( isCut(step + 1, x + dx[k], y + dy[k], nextWorstStep) ){\n                q.push(state(x + dx[k], y + dy[k], step + 1, nextWorstStep));\n\n                // 仮に移動先がゴールだった場合、枝狩り変数を持つことができる\n                if( y + dy[k] == h-1 && x + dx[k] == w-1 ){\n                    cutOff = min(cutOff, nextWorstStep);\n                }\n            }\n        }\n    }\n    return -1;\n}\n\n\n\nint main(){\n    int i,j,k;\n\n    while( cin >> h >> w, h|w ){\n        cin.ignore();\n\n        // input\n        for(i=0; i<2*h-1; i++){\n            getline(cin, field[i]);\n            if( i % 2 == 0 ) field[i] += \" \";\n        }\n\n        // init\n        for(k=0; k<500; k++){\n            for(i=0; i<33; i++){\n                for(j=0; j<33; j++){\n                    dp[k][i][j] = inf;\n                }\n            }\n        }\n        memset(path, -1, sizeof(path));\n\n        cout << solve() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <utility>\n#define INF 2000\nusing namespace std;\ntypedef pair<int,int> P;\n\nstruct data{\n\tint x,y,c,dc;\n\tdata(int xx,int yy,int cc,int dd){\n\t\tx=xx;\n\t\ty=yy;\n\t\tc=cc;\n\t\tdc=dd;\n\t}\n\n\tbool operator<(const data& d1)const{\n\t\treturn d1.c<c;\n\t}\n};\n\nint h,w;\n\nint fie[61][61];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint dp[61][61][901];\nint cost[61][61][4];\nint used[61][61];\n\nint bfs(int sx,int sy){\n\tqueue<P> que;\n\tque.push(P(sx,sy));\n\tmemset(used,-1,sizeof(used));\n\tused[sx][sy]=0;\n\twhile(que.size()){\n\t\tP q=que.front();\n\t\tque.pop();\n\t\tint x=q.first,y=q.second;\n\t\tif(x==(w-1)*2 && y==(h-1)*2)return used[x][y];\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\tif(nx>=0 && nx<w*2-1 && ny>=0 && ny<h*2-1){\n\t\t\t\tif(fie[nx][ny]==1)continue;\n\t\t\t\tnx+=dx[i];\n\t\t\t\tny+=dy[i];\n\t\t\t\tif(used[nx][ny]==-1){\n\t\t\t\t\tused[nx][ny]=used[x][y]+1;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn INF;\n}\n\nint dijk(){\n\tpriority_queue<data> que;\n\tque.push(data(0,0,0,0));\n\tfor(int i=0;i<=60;i++){\n\t\tfor(int j=0;j<=60;j++){\n\t\t\tfor(int k=0;k<=900;k++){\n\t\t\t\tdp[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tque.push(data(0,0,0,0));\n\tdp[0][0][0]=0;\n\twhile(que.size()){\n\t\tdata d=que.top();\n\t\tque.pop();\n\t\tif(dp[d.x][d.y][d.c]!=d.dc)continue;\n\t\t//printf(\"%d %d %d %d\\n\",d.x,d.y,d.c,d.dc);\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(cost[d.x][d.y][i]==INF)continue;\n\t\t\tint nx=d.x+dx[i]*2,ny=d.y+dy[i]*2;\n\t\t\tif(nx>=0 && nx<w*2-1 && ny>=0 && ny<h*2-1){\n\t\t\t\tint ndc=max(d.dc,cost[d.x][d.y][i]+d.c);\n\t\t\t\tif(dp[nx][ny][d.c+1]>ndc && d.c<900){\n\t\t\t\t\tdp[nx][ny][d.c+1]=ndc;\n\t\t\t\t\tque.push(data(nx,ny,d.c+1,ndc));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res=INF;\n\tfor(int i=0;i<=900;i++){\n\t\tres=min(res,dp[(w-1)*2][(h-1)*2][i]);\n\t}\n\tif(res==INF)return -1;\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tif(h==0 && w==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<2*h-1;i++){\n\t\t\tif(i%2==0){\n\t\t\t\tfor(int j=0;j<w-1;j++){\n\t\t\t\t\tscanf(\"%d\",&fie[j*2+1][i]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tscanf(\"%d\",&fie[j*2][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<2*h-1;i+=2){\n\t\t\tfor(int j=0;j<w*2;j+=2){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint x=j+dx[k],y=i+dy[k];\n\t\t\t\t\tif(x>=0 && x<w*2-1 && y>=0 && y<w*2-1){\n\t\t\t\t\t\tif(fie[x][y]==0){\n\t\t\t\t\t\t\tfie[x][y]=1;\n\t\t\t\t\t\t\tcost[j][i][k]=bfs(j,i);\n\t\t\t\t\t\t\tfie[x][y]=0;\n\t\t\t\t\t\t}else cost[j][i][k]=INF;\n\t\t\t\t\t}else cost[j][i][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<bitset>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<functional>\n#include<algorithm>\nusing namespace std;\n\nenum {N, E, S, W};\nconst unsigned long ALL = 1 + 2 + 4 + 8;\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\n\nconst int INF = 10000;\n\n// for bfs\nenum {Y, X, STEP};\ntypedef tuple<int, int, int> Node;\ntypedef tuple<int, int> Vertex;\n\n// for Dijkstra\nenum {DWORST, DSTEP, DY, DX};\ntypedef tuple<int, int, int, int> DNode;\n\nint h, w;\nvector<vector<bitset<4>>> wall;\n\nint bfs(int by, int bx, int bd, int init_step) {\n    queue<Node> q;\n    q.push(Node(by, bx, init_step));\n    set<Vertex> visited;\n    while(!q.empty()) {\n        int y = get<Y>(q.front());\n        int x = get<X>(q.front());\n        int step = get<STEP>(q.front());\n        q.pop();\n        if(y == h - 1 && x == w - 1) return step;\n        if(visited.count(Vertex(y, x))) continue;\n        visited.insert(Vertex(y, x));\n\n        for(const auto& d: {N, E, S, W}) {\n            if(wall[y][x][d]) continue;\n            if(y == by && x == bx && d == bd) continue;\n            int ny = y + dy[d];\n            int nx = x + dx[d];\n            if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            q.push(Node(ny, nx, step + 1));\n        }\n    }\n    return INF;\n}\n\nint Dijkstra() {\n    priority_queue<DNode, vector<DNode>, greater<DNode>> q;\n    q.push(DNode(0, 0, 0, 0));\n    set<Vertex> visited;\n    while(!q.empty()) {\n        int worst = get<DWORST>(q.top());\n        int y = get<DY>(q.top());\n        int x = get<DX>(q.top());\n        int step = get<DSTEP>(q.top());\n        q.pop();\n        if(y == h - 1 && x == w - 1) return worst;\n        if(visited.count(Vertex(y, x))) continue;\n        visited.insert(Vertex(y, x));\n        for(const auto& d: {N, E, S, W}) {\n            if(wall[y][x][d]) continue;\n            int ny = y + dy[d];\n            int nx = x + dx[d];\n            if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            if(visited.count(Vertex(ny, nx))) continue;\n            int nworst = max(worst, bfs(y, x, d, step));\n            q.push(DNode(nworst, step + 1, ny, nx));\n        }\n    }\n    return INF;\n}\n\nint main() {\n    while(cin >> h >> w, h | w) {\n        wall = vector<vector<bitset<4>>>(h, vector<bitset<4>>(w, bitset<4>(ALL)));\n        for(int i = 0; i < h - 1; ++i) {\n            for(int j = 0; j < w - 1; ++j) {\n                int is_wall;\n                cin >> is_wall;\n                if(is_wall) continue;\n                wall[i][j].reset(E);\n                wall[i][j + 1].reset(W);\n            }\n            for(int j = 0; j < w; ++j) {\n                int is_wall;\n                cin >> is_wall;\n                if(is_wall) continue;\n                wall[i][j].reset(S);\n                wall[i + 1][j].reset(N);\n            }\n        }\n        for(int j = 0; j < w - 1; ++j) {\n            int is_wall;\n            cin >> is_wall;\n            if(is_wall) continue;\n            wall[h - 1][j].reset(E);\n            wall[h - 1][j + 1].reset(W);\n        }\n\n        int answer = Dijkstra();\n        cout << (answer == INF ? -1 : answer) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 31;\n\nint h,w;\nint tate[MAX_N][MAX_N];\nint yoko[MAX_N][MAX_N];\nint tt[MAX_N][MAX_N][2];\nint yk[MAX_N][MAX_N][2];\nint d[MAX_N*MAX_N];\n\nbool possible(int cri)\n{\n    rep(i,h){\n        rep(j,w){\n            d[i*w+j] = INF;\n        }\n    }\n    queue<int> que;\n    que.push(0);\n    d[0] = 0;\n    while(!que.empty()){\n        int p = que.front();\n        que.pop();\n        int x = p / w, y = p % w;\n        if(y < w-1 && !yoko[x][y] && d[x*w+y+1] > d[p] + 1 && d[p] + yk[x][y][0] <= cri){\n            d[x*w+y+1] = d[p] + 1;\n            que.push(x*w+y+1);\n        }\n        if(y > 0 && !yoko[x][y-1] && d[x*w+y-1] > d[p] + 1 && d[p] + yk[x][y-1][1] <= cri){\n            d[x*w+y-1] = d[p] + 1;\n            que.push(x*w+y-1);\n        }\n        if(x < h-1 && !tate[x][y] && d[(x+1)*w+y] > d[p] + 1 && d[p] + tt[x][y][0] <= cri){\n            d[(x+1)*w+y] = d[p] + 1;\n            que.push((x+1)*w+y);\n        }\n        if(x > 0 && !tate[x-1][y] && d[(x-1)*w+y] > d[p] + 1 && d[p] + tt[x-1][y][1] <= cri){\n            d[(x-1)*w+y] = d[p] + 1;\n            que.push((x-1)*w+y);\n        }\n    }\n    return (d[h*w-1] != INF);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        cin >> h >> w;\n        if(h == 0 && w == 0){\n            break;\n        }\n        rep(i,2*h-1){\n            if(i % 2){\n                rep(j,w){\n                    cin >> tate[i/2][j];\n                }\n            }else{\n                rep(j,w-1){\n                    cin >> yoko[i/2][j];\n                }\n            }\n        }\n        rep(i,h){\n            rep(j,w-1){\n                if(!yoko[i][j]){\n                    yoko[i][j] = 1;\n                    rep(k,2){\n                        int pos = w*i+j+k;\n                        rep(l,h){\n                            rep(r,w){\n                                d[l*w+r] = INF;\n                            }\n                        }\n                        queue<int> que;\n                        d[pos] = 0;\n                        que.push(pos);\n                        while(!que.empty()){\n                            int p = que.front();\n                            que.pop();\n                            int x = p / w, y = p % w;\n                            if(y < w-1 && !yoko[x][y] && d[x*w+y+1] > d[p] + 1){\n                                d[x*w+y+1] = d[p] + 1;\n                                que.push(x*w+y+1);\n                            }\n                            if(y > 0 && !yoko[x][y-1] && d[x*w+y-1] > d[p] + 1){\n                                d[x*w+y-1] = d[p] + 1;\n                                que.push(x*w+y-1);\n                            }\n                            if(x < h-1 && !tate[x][y] && d[(x+1)*w+y] > d[p] + 1){\n                                d[(x+1)*w+y] = d[p] + 1;\n                                que.push((x+1)*w+y);\n                            }\n                            if(x > 0 && !tate[x-1][y] && d[(x-1)*w+y] > d[p] + 1){\n                                d[(x-1)*w+y] = d[p] + 1;\n                                que.push((x-1)*w+y);\n                            }\n                        }\n                        yk[i][j][k] = d[h*w-1];\n                    }\n                    yoko[i][j] = 0;\n                }\n            }\n        }\n        rep(i,h-1){\n            rep(j,w){\n                if(!tate[i][j]){\n                    tate[i][j] = 1;\n                    rep(k,2){\n                        int pos = w*(i+k)+j;\n                        rep(l,h){\n                            rep(r,w){\n                                d[l*w+r] = INF;\n                            }\n                        }\n                        queue<int> que;\n                        d[pos] = 0;\n                        que.push(pos);\n                        while(!que.empty()){\n                            int p = que.front();\n                            que.pop();\n                            int x = p / w, y = p % w;\n                            if(y < w-1 && !yoko[x][y] && d[x*w+y+1] > d[p] + 1){\n                                d[x*w+y+1] = d[p] + 1;\n                                que.push(x*w+y+1);\n                            }\n                            if(y > 0 && !yoko[x][y-1] && d[x*w+y-1] > d[p] + 1){\n                                d[x*w+y-1] = d[p] + 1;\n                                que.push(x*w+y-1);\n                            }\n                            if(x < h-1 && !tate[x][y] && d[(x+1)*w+y] > d[p] + 1){\n                                d[(x+1)*w+y] = d[p] + 1;\n                                que.push((x+1)*w+y);\n                            }\n                            if(x > 0 && !tate[x-1][y] && d[(x-1)*w+y] > d[p] + 1){\n                                d[(x-1)*w+y] = d[p] + 1;\n                                que.push((x-1)*w+y);\n                            }\n                        }\n                        tt[i][j][k] = d[h*w-1];\n                    }\n                    tate[i][j] = 0;\n                }\n            }\n        }\n        int l = 0, r = 2*w*h-h-w;\n        if(!possible(r)){\n            cout << \"-1\\n\";\n            continue;\n        }\n        while(r-l>1){\n            int mid = (l+r)/2;\n            if(possible(mid)){\n                r = mid;\n            }else{\n                l = mid;\n            }\n        }\n        cout << r << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <utility>\n#define INF 2000\nusing namespace std;\ntypedef pair<int,int> P;\n\nstruct data{\n\tint x,y,c,dc;\n\tdata(int xx,int yy,int cc,int dd){\n\t\tx=xx;\n\t\ty=yy;\n\t\tc=cc;\n\t\tdc=dd;\n\t}\n\n\tbool operator<(const data& d1)const{\n\t\treturn d1.dc<dc;\n\t}\n};\n\nint h,w;\n\nint fie[61][61];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint dp[61][61][901];\nint cost[61][61][4];\nint used[61][61];\n\nint bfs(int sx,int sy){\n\tqueue<P> que;\n\tque.push(P(sx,sy));\n\tmemset(used,-1,sizeof(used));\n\tused[sx][sy]=0;\n\twhile(que.size()){\n\t\tP q=que.front();\n\t\tque.pop();\n\t\tint x=q.first,y=q.second;\n\t\tif(x==(w-1)*2 && y==(h-1)*2)return used[x][y];\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\tif(nx>=0 && nx<w*2-1 && ny>=0 && ny<h*2-1){\n\t\t\t\tif(fie[nx][ny]==1)continue;\n\t\t\t\tnx+=dx[i];\n\t\t\t\tny+=dy[i];\n\t\t\t\tif(used[nx][ny]==-1){\n\t\t\t\t\tused[nx][ny]=used[x][y]+1;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn INF;\n}\n\nint dijk(){\n\tpriority_queue<data> que;\n\tque.push(data(0,0,0,0));\n\tfor(int i=0;i<=60;i++){\n\t\tfor(int j=0;j<=60;j++){\n\t\t\tfor(int k=0;k<=900;k++){\n\t\t\t\tdp[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tque.push(data(0,0,0,0));\n\tdp[0][0][0]=0;\n\twhile(que.size()){\n\t\tdata d=que.top();\n\t\tque.pop();\n\t\tif(dp[d.x][d.y][d.c]!=d.dc)continue;\n\t\tif(d.x==(w-1)*2 && d.y==(h-1)*2)return d.dc;\n\t\t//printf(\"%d %d %d %d\\n\",d.x,d.y,d.c,d.dc);\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(cost[d.x][d.y][i]==INF)continue;\n\t\t\tint nx=d.x+dx[i]*2,ny=d.y+dy[i]*2;\n\t\t\tif(nx>=0 && nx<w*2-1 && ny>=0 && ny<h*2-1){\n\t\t\t\tif(fie[nx-dx[i]][ny-dy[i]]==1)continue;\n\t\t\t\tint ndc=max(d.dc,cost[d.x][d.y][i]+d.c);\n\t\t\t\tif(dp[nx][ny][d.c+1]>ndc && d.c<900){\n\t\t\t\t\tdp[nx][ny][d.c+1]=ndc;\n\t\t\t\t\tque.push(data(nx,ny,d.c+1,ndc));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tif(h==0 && w==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<2*h-1;i++){\n\t\t\tif(i%2==0){\n\t\t\t\tfor(int j=0;j<w-1;j++){\n\t\t\t\t\tscanf(\"%d\",&fie[j*2+1][i]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tscanf(\"%d\",&fie[j*2][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<2*h-1;i+=2){\n\t\t\tfor(int j=0;j<w*2-1;j+=2){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint x=j+dx[k],y=i+dy[k];\n\t\t\t\t\tif(x>=0 && x<w*2-1 && y>=0 && y<h*2-1){\n\t\t\t\t\t\tif(fie[x][y]==0){\n\t\t\t\t\t\t\tfie[x][y]=1;\n\t\t\t\t\t\t\tcost[j][i][k]=bfs(j,i);\n\t\t\t\t\t\t\tfie[x][y]=0;\n\t\t\t\t\t\t}else cost[j][i][k]=INF;\n\t\t\t\t\t}else cost[j][i][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\nint dx[] = {-1, 0, 1, 0};\nint dy[] = { 0, 1, 0,-1};\nint h, w;\nvector<string> wall;\n\nstruct node{\n    int y, x, cst;\n};\nbool inrange(int y, int x){\n    return y >= 0 & x >= 0 && y < h && x < w;\n}\n\nint cst[31][31];\nint cst2[31][31];\n\nint main() {\n    while(cin >> h >> w, h){\n\twall.resize(2*h-1);\n\tcin.ignore();\n\trep(i, h*2-1) getline(cin, wall[i]);\n\tmemset(cst, 0, sizeof(cst));\n/*\n\tqueue<node> q;\n\tint done[31][31] = {0};\n\tq.push((node){0, 0, 0});\n\twhile(!q.empty()){\n\t    int y = q.front().y;\n\t    int x = q.front().x;\n\t    int cs = q.front().cst;\n\t    q.pop();\n\t    if(done[y][x]) continue;\n\t    done[y][x] = 1;\n\t    cst2[y][x] = cs;\n\t    rep(k, 4){\n\t\tint wy = 2*y + dy[k];\n\t\tint wx = 2*x + dx[k];\n\t\tif(inrange(y + dy[k], x + dx[k]) && wall[wy][wx] == '0'){\n\t\t    q.push((node){y+dy[k], x+dx[k], cs + 1});\n\t\t}\n\t    }\n\t}\n*/\n\tbool reachable = true;\n\trep(a, h*2-1) rep(b, wall[a].size()) if(wall[a][b] == '0') {\n\t    queue<node> q;\n\t    int done[31][31] = {0};\n\t    q.push((node){0, 0, 0});\n\t    bool flag = true;\n\t    wall[a][b] = '1';\n\t    while(!q.empty()){\n\t\tint y = q.front().y;\n\t\tint x = q.front().x;\n\t\tint cs = q.front().cst;\n\t\tq.pop();\n\t\tif(done[y][x]) continue;\n\t\tdone[y][x] = 1;\n\t\tif(y == h-1 && x == w-1) {\n\t\t    flag = false;\n\t\t    break;\n\t\t}\n\t\trep(k, 4){\n\t\t    int wy = 2*y + dy[k];\n\t\t    int wx = 2*x + dx[k];\n\t\t    if(inrange(y + dy[k], x + dx[k]) && wall[wy][wx] == '0'){\n\t\t\tq.push((node){y+dy[k], x+dx[k], cs + 1});\n\t\t    }\n\t\t}\n\t    }\n\t    wall[a][b] = '0';\n\t    if(flag) reachable = false;\n\t}\n\t\n\tif(!reachable){\n\t    cout << -1 << endl;\n\t    continue;\n\t}\n\trep(a, h*2-1) for(int b = 1-a%2; b < wall[a].size(); b+=2) {\n\t    if(wall[a][b] == '0') {\n\t\twall[a][b] = '1';\n\t\tint c1, c2;\n\t\tqueue<node> q;\n\t\tint done[31][31] = {0};\n\t\tq.push((node){h-1, w-1, 0});\n\t\twhile(!q.empty()){\n\t\t    int y = q.front().y;\n\t\t    int x = q.front().x;\n\t\t    int cs = q.front().cst;\n\t\t    q.pop();\n\t\t    if(done[y][x]) continue;\n\t\t    done[y][x] = 1;\n\t\t    cst[y][x] = max(cst[y][x], cs);\n\t\t    rep(k, 4){\n\t\t\tint wy = 2*y + dy[k];\n\t\t\tint wx = 2*x + dx[k];\n\t\t\tif(inrange(y + dy[k], x + dx[k]) && wall[wy][wx] == '0'){\n\t\t\t    q.push((node){y+dy[k], x+dx[k], cs + 1});\n\t\t\t}\n\t\t    }\n\t\t}\n\t\twall[a][b] = '0';\n\t    }\n\t}\n//\trep(i, h) rep(j, w) cout << cst2[i][j] << (j < w-1?\" \":\"\\n\");\n\tint lower = 0;\n\tint upper = 30*30+1;\n\tint mid;\n\twhile(upper - lower > 1){\n\t    bool flag = false;\n\t    mid = (lower + upper) / 2;\n\t    queue<node> q;\n\t    int done[31][31] = {0};\n\t    q.push((node){0, 0, 0});\n\t    while(!q.empty()){\n\t\tint y = q.front().y;\n\t\tint x = q.front().x;\n\t\tint cs = q.front().cst;\n\t\tq.pop();\n\t\tif(done[y][x]) continue;\n\t\tdone[y][x] = 1;\n\t\tif(y == h-1 && x == w-1) {\n\t\t    flag = true;\n\t\t    break;\n\t\t}\n\t\trep(k, 4){\n\t\t    int wy = 2*y + dy[k];\n\t\t    int wx = 2*x + dx[k];\n\t\t    if(inrange(y + dy[k], x + dx[k]) && wall[wy][wx] == '0' && cst[y+dy[k]][x+dx[k]] + cs + 1 <= mid){\n\t\t\tq.push((node){y+dy[k], x+dx[k], cs + 1});\n\t\t    }\n\t\t}\n\t    }\n\t    if(!flag) lower = mid;\n\t    else upper = mid;\n\t}\n\tcout << upper << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<pair<int,int>,int> P;\nint h,w;\nint dp[33*33];\nint dist[33*33];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nvector<vector<int>> v(33*33);\n\nint fun(int a,int b){\n\tREP(i,33*33)dist[i] = INF;\n\tdist[a] = 0;\n\tqueue<pair<int,int>> q;\n\tq.push(MP(a,0));\n\twhile(!q.empty()){\n\t\tpair<int,int> now = q.front();q.pop();\n\t\tint node = now.FI;\n\t\tint kyo = now.SE;\n\t\tif(kyo > dist[node])continue;\n\t\tREP(i,v[node].size()){\n\t\t\tint aite = v[node][i];\n\t\t\tif((node == a && aite == b) || (node == b && aite == a))continue;\n\t\t\tif(dist[aite] > kyo + 1){\n\t\t\t\tdist[aite] = kyo + 1;\n\t\t\t\tq.push(MP(aite,kyo+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[h*w-1];\n}\n\nint main()\n{\n\twhile(cin >> h >> w,h|w){\n\t\t//初期化\n\t\tREP(i,33*33)dp[i] = INF;\n\t\tREP(i,33*33){v[i].clear();}\n\t\tdp[0] = 0;\n\t\t\n\t\t//入力\n\t\tREP(i,h){\n\t\t\tREP(j,w-1){\n\t\t\t\tint tmp;cin >> tmp;\n\t\t\t\tif(tmp == 0){\n\t\t\t\t\tv[i*w+j].PB(i*w+j+1);\n\t\t\t\t\tv[i*w+j+1].PB(i*w+j);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tif(i != h-1)REP(j,w){\n\t\t\t\tint tmp;cin >> tmp;\n\t\t\t\tif(tmp == 0){\n\t\t\t\t\tv[i*w+j].PB((i+1)*w+j);\n\t\t\t\t\tv[(i+1)*w+j].PB(i*w+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tpriority_queue<P,vector<P>,greater<P>> q;\n\t\tq.push(MP(MP(0,-1),0));\n\t\twhile(!q.empty()){\n\t\t\tDBG(\n\t\t\tcout << \"DP TABLE\" << endl;\n\t\t\tREP(i,h){\n\t\t\t\tREP(j,w){\n\t\t\t\t\tcout << dp[i*w+j] << ' ';\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\t)\n\t\t\tP now = q.top();q.pop();\n\t\t\tint node = now.SE;\n\t\t\tpair<int,int> kyori = now.FI;\n\t\t\tkyori.SE++;\n\t\t\tif(dp[node] < kyori.FI)continue;\n\t\t\tREP(i,v[node].size()){\n\t\t\t\tint aite = v[node][i];\n\t\t\t\tint score = fun(node,aite) + kyori.SE;\n\t\t\t\tif(dp[aite] >= max(dp[node],score)){\n\t\t\t\t\tdp[aite] = max(dp[node],score);\n\t\t\t\t\tq.push(MP(MP(dp[aite],kyori.SE),aite));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tDBG(\n\t\tcout << \"DP TABLE\" << endl;\n\t\tREP(i,h){\n\t\t\tREP(j,w){\n\t\t\t\tcout << dp[i*w+j] << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t)\n\t\t\n\t\tDBG(cout << \"ANS IS \";);\n\t\t\n\t\tif(dp[h*w-1] == INF){\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << dp[h*w-1] << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <limits>\n#include <array>\n#include <algorithm>\n#include <queue>\n#include <tuple>\n\nconstexpr int Inf = std::numeric_limits<int>::max();\n\ntemplate <typename T>\nusing VecArr = std::vector<std::array<T, 4>>;\n\nint main() {\n\tint h, w;\n\t\n\twhile (true) {\n\t\tstd::cin >> h >> w;\n\t\tif (h == 0 && w == 0)\n\t\t\tbreak;\n\n\t\tstd::vector<VecArr<bool>> isWall(h, VecArr<bool>(w));\n\t\tfor (int i = 0; i < w; ++i)\n\t\t\tisWall[0][i][0] = true;\n\t\tfor (int i = 0; i < h; ++i)\n\t\t\tisWall[i][w - 1][1] = true;\n\t\tfor (int i = 0; i < w; ++i)\n\t\t\tisWall[h - 1][i][2] = true;\n\t\tfor (int i = 0; i < h; ++i)\n\t\t\tisWall[i][0][3] = true;\n\t\t\n\n\t\tfor (int i = 0; i < 2 * h - 1; ++i) {\n\t\t\tfor (int j = 0; j < (i % 2 == 0 ? w - 1 : w); ++j) {\n\t\t\t\tint d;\n\t\t\t\tstd::cin >> d;\n\n\t\t\t\tif (i % 2 == 0)\n\t\t\t\t\tisWall[i / 2][j][1] = isWall[i / 2][j + 1][3] = d;\n\t\t\t\telse\n\t\t\t\t\tisWall[i / 2][j][2] = isWall[i / 2 + 1][j][0] = d;\n\t\t\t}\n\t\t}\n\n\t\tstd::vector<VecArr<int>> costs(h, VecArr<int>(w, {Inf, Inf, Inf, Inf}));\n\n\t\tbool possible = true;\n\t\tfor (int i = 0; i < h && possible; ++i) {\n\t\t\tfor (int j = 0; j < w && possible; ++j) {\n\t\t\t\tauto calcCost = [&](int dir) {\n\t\t\t\t\tisWall[i][j][dir] = true;\n\n\t\t\t\t\tint ret = [&]() {\n\t\t\t\t\t\tstd::queue<std::tuple<int, int, int>> que;\n\t\t\t\t\t\tstd::vector<std::vector<bool>> visited(h, std::vector<bool>(w));\n\n\t\t\t\t\t\tque.emplace(i, j, 0);\n\t\t\t\t\t\tvisited[i][j] = true;\n\t\t\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\t\t\tint y, x, depth;\n\t\t\t\t\t\t\tstd::tie(y, x, depth) = que.front();\n\t\t\t\t\t\t\tque.pop();\n\n\t\t\t\t\t\t\tif (y == h - 1 && x == w - 1)\n\t\t\t\t\t\t\t\treturn depth;\n\n\t\t\t\t\t\t\tconst int dy[4] = { -1, 0, 1, 0 }, dx[4] = { 0, 1, 0, -1 };\n\t\t\t\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\t\t\t\tif (isWall[y][x][k])\n\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t\tconst int ny = y + dy[k], nx = x + dx[k];\n\t\t\t\t\t\t\t\tif (visited[ny][nx])\n\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t\t\t\t\tque.emplace(ny, nx, depth + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (visited[0][0])\n\t\t\t\t\t\t\treturn Inf;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treturn Inf / 2;\n\t\t\t\t\t}();\n\n\t\t\t\t\tisWall[i][j][dir] = false;\n\n\t\t\t\t\treturn ret;\n\t\t\t\t};\n\n\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\tif (isWall[i][j][dir])\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcosts[i][j][dir] = calcCost(dir);\n\n\t\t\t\t\tif (costs[i][j][dir] == Inf) {\n\t\t\t\t\t\tstd::cout << -1 << std::endl;\n\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!possible)\n\t\t\tcontinue;\n\n\t\tauto isOK = [&](int threshold) {\n\t\t\tstd::queue<std::tuple<int, int, int>> que;\n\t\t\tstd::vector<std::vector<bool>> visited(h, std::vector<bool>(w));\n\n\t\t\tque.emplace(0, 0, 0);\n\t\t\tvisited[0][0] = true;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tint y, x, c;\n\t\t\t\tstd::tie(y, x, c) = que.front();\n\t\t\t\tque.pop();\n\n\t\t\t\tif (y == h - 1 && x == w - 1)\n\t\t\t\t\treturn true;\n\n\t\t\t\tconst int dy[4] = { -1, 0, 1, 0 }, dx[4] = { 0, 1, 0, -1 };\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\tif (isWall[y][x][k])\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tconst int ny = y + dy[k], nx = x + dx[k];\n\t\t\t\t\tif (visited[ny][nx] || c + costs[y][x][k] > threshold)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t\tque.emplace(ny, nx, c + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t};\n\n\t\tint l = 0, r = 2 * h * w;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (isOK(mid))\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\n\t\tstd::cout << r << std::endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nstruct edge {\n    P s, e;\n    int c;\n};\n\nstruct state {\n    P p;\n    int c, d;\n};\nbool operator<(const state &a, const state &b) {\n    if (a.c != b.c) return a.c > b.c;\n    return a.d > b.d;\n}\n\nint h, w;\nint wall[30][30][30][30];\nint dist[4][30][30][30][30];\nint dd[] = {-1, 0, 1, 0, -1};\n\nbool range(int y, int x) {\n    return 0 <= y && y < h && 0 <= x && x < w;\n}\n\nvoid bfs(int d[30][30], int si, int sj) {\n    rep(i, 30)rep(j, 30) d[i][j] = INF;\n\n    queue<PIP> q;\n    q.push(PIP(0, P(si, sj)));\n    while(q.size()) {\n        PIP p = q.front(); q.pop();\n        int i = p.se.fi, j = p.se.se, c = p.fi;\n        if (d[i][j] < INF) continue;\n        d[i][j] = c;\n        rep(dir, 4) {\n            int ni = i + dd[dir], nj = j + dd[dir + 1];\n            if (range(ni, nj) && !wall[i][j][ni][nj] && d[ni][nj] == INF) {\n                q.push(PIP(c + 1, P(ni, nj)));\n            }\n        }\n    }\n}\n\nint main(){\n    cin.sync_with_stdio(false);\n    while(cin >> h >> w, h | w) {\n        rep(i, 2 * h - 1) {\n            int ii = i / 2, t;\n            if (i % 2) {\n                rep(j, w) {\n                    cin >> t;\n                    wall[ii][j][ii + 1][j] = wall[ii + 1][j][ii][j] = t;\n                }\n            } else {\n                rep(j, w - 1) {\n                    cin >> t;\n                    wall[ii][j][ii][j + 1] = wall[ii][j + 1][ii][j] = t;\n                }\n            }\n        }\n\n        bool ok = true;\n        rep(i, h)rep(j, w) {\n            rep(dir, 4) {\n                int ni = i + dd[dir], nj = j + dd[dir + 1];\n                if (range(ni, nj) && !wall[i][j][ni][nj]) {\n                    wall[i][j][ni][nj] = wall[ni][nj][i][j] = 1;\n                    bfs(dist[dir][i][j], h - 1, w - 1);\n                    if (dist[dir][i][j][i][j] == INF) ok = false;\n                    wall[i][j][ni][nj] = wall[ni][nj][i][j] = 0;\n                }\n            }\n        }\n\n        int ans = -1;\n        priority_queue<state> q;\n        q.push((state){P(0, 0), 0, 0});\n        int dp[h][w];\n        rep(i, h)rep(j, w) dp[i][j] = INF;\n        while(q.size()) {\n            state s = q.top(); q.pop();\n            int i = s.p.fi, j = s.p.se;\n            if (dp[i][j] < INF) continue;\n            if (i == h - 1 && j == w - 1) {\n                ans = s.c;\n                break;\n            }\n            dp[i][j] = s.c;\n            rep(dir, 4) {\n                int ni = i + dd[dir], nj = j + dd[dir + 1];\n                if (range(ni, nj) && !wall[i][j][ni][nj] && dp[ni][nj] == INF && dist[dir][i][j][i][j] != INF) {\n                    q.push((state){P(ni, nj), max(dp[i][j], s.d + dist[dir][i][j][i][j]), s.d + 1});\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAX = 33;\nconst int INF = 1e9;\nbool ok[MAX][MAX][4];\nvector<vi> d[MAX][MAX][4];\n\nvector<vi> bfs(int H, int W) {\n    vector<vi> d(H, vi(W, INF));\n    queue<pii> que;\n    que.push(pii(H-1, W-1));\n    d[H-1][W-1] = 0;\n    while (!que.empty()) {\n        auto p = que.front(); que.pop();\n        int y = p.first, x = p.second;\n        for (int i = 0; i < 4; i++) {\n            if (!ok[y][x][i]) continue;\n            int ny = y+dy[i], nx = x+dx[i];\n            if (d[ny][nx] > d[y][x]+1) {\n                d[ny][nx] = d[y][x]+1;\n                que.push(pii(ny, nx));\n            }\n        }\n    }\n    return d;\n}\n\nvector<vi> dijkstra(int H, int W) {\n    vector<vi> ret(H, vi(W, INF));\n    ret[H-1][W-1] = 0;\n    priority_queue<pair<int, pii> > que;\n    que.push(make_pair(0, pii(H-1, W-1)));\n    while (!que.empty()) {\n        auto p = que.top(); que.pop();\n        int dist = -p.first;\n        int y = p.second.first, x = p.second.second;\n        if (dist > ret[y][x]) continue;\n        for (int i = 0; i < 4; i++) {\n            if (!ok[y][x][i]) continue;\n            int ny = y+dy[i], nx = x+dx[i];\n            int tmp = max(dist+1, d[y][x][i][ny][nx]);\n            if (ret[ny][nx] > tmp) {\n                ret[ny][nx] = tmp;\n                que.push(make_pair(-ret[ny][nx], pii(ny, nx)));\n            }\n        }\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int H, W;\n    while (cin >> H >> W) {\n        if (H==0 && W==0) break;\n        memset(ok, false, sizeof(ok));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W-1; j++) {\n                int b;\n                cin >> b;\n                if (b == 0) {\n                    ok[i][j][0] = true;\n                    ok[i][j+1][2] = true;\n                }\n            }\n            if (i < H-1) {\n                for (int j = 0; j < W; j++) {\n                    int b;\n                    cin >> b;\n                    if (b == 0) {\n                        ok[i][j][1] = true;\n                        ok[i+1][j][3] = true;\n                    }\n                }\n            }\n        }\n        vector<vi> d0 = bfs(H, W);\n        for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) {\n            for (int k = 0; k < 4; k++) {\n                if (ok[i][j][k]) {\n                    ok[i][j][k] = false;\n                    d[i][j][k] = bfs(H, W);\n                    ok[i][j][k] = true;\n                }\n            }\n        }\n        vector<vi> ans = dijkstra(H, W);\n        int out = ans[0][0];\n        if (out >= INF) out = -1;\n        cout << out << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\nconst int inf  = (1<<24);\nconst int dx[] = {+1, 0,-1, 0};\nconst int dy[] = { 0,+1, 0,-1};\n\nint  H,W;\nint  dist [30][30];\nint  cost[30][30][4];\nbool graph[30][30][4];\n\nclass Data\n{\npublic:\n\tint x,y,dist,cost;\n\tData(int x, int y, int d, int c)\n\t: x(x), y(y), dist(d), cost(c) {}\n\tbool operator<(const Data &d) const\n\t{\n\t\tif(cost!=d.cost) return cost>d.cost;\n\t\tif(dist!=d.dist) return dist>d.dist;\n\t\treturn (x!=x ? x<d.x : y<d.y);\n\t}\n};\n\nvoid bfs(int sx, int sy)\n{\n\tqueue<Data> q;\n\tbool visited[30][30]={0};\n\n\tq.push( Data(sx, sy, 0, 0) );\n\tvisited[sx][sy] = 1;\n\n\tfor(int y=0; y<H; y++)\n\tfor(int x=0; x<W; x++)\n\t{\n\t\tdist[x][y]=inf;\n\t}\n\n\twhile(!q.empty())\n\t{\n\t\tData t=q.front(); q.pop();\n\t\tdist[t.x][t.y] = t.cost;\n\n\t\tfor(int i=0; i<4; i++)\n\t\t{\n\t\t\tif(!graph[t.x][t.y][i]) continue;\n\t\t\tint nx = t.x + dx[i];\n\t\t\tint ny = t.y + dy[i];\n\n\t\t\tif(visited[nx][ny]) continue;\n\t\t\tq.push( Data(nx, ny, 0, t.cost+1) );\n\t\t\tvisited[nx][ny] = 1;\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(cin>>H>>W, H||W)\n\t{\n\t\tmemset(graph, 0, sizeof(graph));\n\n\t\tfor(int y=0; y<H; y++)\n\t\t{\n\t\t\tint t;\n\t\t\tfor(int x=0; x<W-1; x++)\n\t\t\t{\n\t\t\t\tif(cin >> t, t==0)\n\t\t\t\t{\n\t\t\t\t\tgraph[x  ][y][0] = 1;\n\t\t\t\t\tgraph[x+1][y][2] = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(y==H-1) break;\n\t\t\tfor(int x=0; x<W; x++)\n\t\t\t{\n\t\t\t\tif(cin >> t, t==0)\n\t\t\t\t{\n\t\t\t\t\tgraph[x][y  ][1] = 1;\n\t\t\t\t\tgraph[x][y+1][3] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(cost, 0, sizeof(cost));\n\n\t\tfor(int x1=0; x1<W; x1++)\n\t\tfor(int y1=0; y1<H; y1++)\n\t\tfor(int  d=0;  d<2;  d++)\n\t\t{\n\t\t\tint x2 = x1 + dx[d];\n\t\t\tint y2 = y1 + dy[d];\n\n\t\t\tif(W<=x2) continue;\n\t\t\tif(H<=y2) continue;\n\n\t\t\tbool g = graph[x1][y1][d];\n\n\t\t\tgraph[x1][y1][d  ]=0;\n\t\t\tgraph[x2][y2][d+2]=0;\n\n\t\t\tbfs(W-1, H-1);\n\t\t\tcost[x1][y1][d  ]=dist[x1][y1];\n\t\t\tcost[x2][y2][d+2]=dist[x2][y2];\n\n\t\t\tgraph[x1][y1][d  ]=g;\n\t\t\tgraph[x2][y2][d+2]=g;\n\t\t}\n\n\t\tint  ans=inf;\n\t\tbool visited[30][30]={0};\n\t\tpriority_queue<Data> q;\n\t\tq.push( Data(0, 0, 0, 0) );\n\t\t\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tData t=q.top(); q.pop();\n\t\t\tif(t.x==W-1 && t.y==H-1)\n\t\t\t{\n\t\t\t\tans=t.cost; break;\n\t\t\t}\n\n\t\t\tif(visited[t.x][t.y]) continue;\n\t\t\tvisited[t.x][t.y]=1;\n\n\t\t\tfor(int i=0; i<4; i++)\n\t\t\t{\n\t\t\t\tif(!graph[t.x][t.y][i]) continue;\n\t\t\t\tint nx = t.x+dx[i];\n\t\t\t\tint ny = t.y+dy[i];\n\t\t\t\tif(visited[nx][ny]) continue;\n\t\t\t\tq.push( Data(nx, ny, t.dist+1, max(t.cost, t.dist+cost[t.x][t.y][i])) );\n\t\t\t}\n\t\t}\n\n\t\tif(inf<=ans) ans=-1;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<bitset>\n#include<queue>\n#include<tuple>\n#include<functional>\n#include<algorithm>\nusing namespace std;\n\nenum {N, E, S, W};\nconst unsigned long ALL = 1 + 2 + 4 + 8;\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\n\nconst int INF = 1000000;\n\nenum {Y, X, STEP};\ntypedef tuple<int, int, int> Node;\n\nenum {DWORST, DSTEP, DY, DX};\ntypedef tuple<int, int, int, int> DNode;\n\nvector<vector<vector<int>>> memo;\n\nint h, w;\nvector<vector<bitset<4>>> wall;\n\nint bfs(int by, int bx, int bd) {\n    queue<Node> q;\n    vector<vector<int>> visited(h, vector<int>(w, 0));\n    q.push(Node(by, bx, 0));\n    while(!q.empty()) {\n        int y = get<Y>(q.front());\n        int x = get<X>(q.front());\n        int step = get<STEP>(q.front());\n        q.pop();\n        if(y == h - 1 && x == w - 1) return step;\n        if(visited[y][x]) continue;\n        visited[y][x] = 1;\n        for(int d = 0; d < 4; ++d) {\n            if(wall[y][x][d]) continue;\n            if(y == by && x == bx && d == bd) continue;\n            int ny = y + dy[d];\n            int nx = x + dx[d];\n            if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            q.push(Node(ny, nx, step + 1));\n        }\n    }\n    return INF;\n}\n\nint Dijkstra() {\n    priority_queue<DNode, vector<DNode>, greater<DNode>> q;\n    q.push(DNode(0, 0, 0, 0));\n    vector<vector<vector<int>>> visited(h, vector<vector<int>>(w, vector<int>(h * w * 2, 0)));\n    while(!q.empty()) {\n        int y = get<DY>(q.top());\n        int x = get<DX>(q.top());\n        int step = get<DSTEP>(q.top());\n        int worst = get<DWORST>(q.top());\n        q.pop();\n        if(y == h - 1 && x == w - 1) return worst;\n        if(visited[y][x][step]) continue;\n        visited[y][x][step] = 1;\n        for(int d = 0; d < 4; ++d) {\n            if(wall[y][x][d]) continue;\n            int ny = y + dy[d];\n            int nx = x + dx[d];\n            if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            int nworst = max({step + 1, worst, step + memo[y][x][d]});\n            q.push(DNode(nworst, step + 1, ny, nx));\n        }\n    }\n    return INF;\n}\n\nint main() {\n    while(cin >> h >> w, h | w) {\n        wall = vector<vector<bitset<4>>>(h, vector<bitset<4>>(w, bitset<4>(ALL)));\n        for(int i = 0; i < h - 1; ++i) {\n            for(int j = 0; j < w - 1; ++j) {\n                int is_wall;\n                cin >> is_wall;\n                if(is_wall) continue;\n                wall[i][j].reset(E);\n                wall[i][j + 1].reset(W);\n            }\n            for(int j = 0; j < w; ++j) {\n                int is_wall;\n                cin >> is_wall;\n                if(is_wall) continue;\n                wall[i][j].reset(S);\n                wall[i + 1][j].reset(N);\n            }\n        }\n        for(int j = 0; j < w - 1; ++j) {\n            int is_wall;\n            cin >> is_wall;\n            if(is_wall) continue;\n            wall[h - 1][j].reset(E);\n            wall[h - 1][j + 1].reset(W);\n        }\n\n        memo = vector<vector<vector<int>>>(h, vector<vector<int>>(w, vector<int>(4, INF)));\n        for(int i = 0; i < h; ++i) for(int j = 0; j < w; ++j) for(int d = 0; d < 4; ++d) memo[i][j][d] = bfs(i, j, d);\n\n        int answer = Dijkstra();\n        cout << (answer < INF ? answer : -1) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <iostream>\nusing namespace std;\n \nvector<string> line;\n\nstruct NODE{\n    int id,cost,maximum;\n    NODE(int id,int cost,int maximum) : id(id),cost(cost),maximum(maximum){}\n};\n \nbool operator < (const NODE &a,const NODE &b){\n    return a.maximum > b.maximum;\n}\n \n\nint tmp[100][100];\nint XX[1000],YY[1000];\nint sz = 0;\nint id(int x,int y){\n\tif( tmp[x][y] != -1 ) return tmp[x][y];\n\tXX[sz] = x;\n\tYY[sz] = y;\n\treturn tmp[x][y] = sz++;\n}\n\nint X(int id){ return XX[id]; }\nint Y(int id){ return YY[id]; }\n\nint dx[] = { 0, 1, 0,-1};\nint dy[] = { 1, 0,-1, 0};\n\n\nint done[910][910]={};\n\nint main(){\n\tmemset(tmp,-1,sizeof(tmp));\n    int H,W;\n    while(cin >> H >> W && H){\n        int s = id(0,0);\n        int g = id(2*W-2,2*H-2);\n         \n        line = vector<string>(H*2-1);\n        getline(cin,line[0]); //dummy\n        for(int i = 0 ; i < H*2-1 ; i++){\n            getline(cin,line[i]);\n            if(!(i&1))line[i] += \" \";\n        }\n         \n        int dir[62][62][2];\n        for(int i = 0 ; i < 62 ; i++)\n            for(int j = 0 ; j < 62 ; j++)\n                for(int k = 0 ; k < 2 ; k++)\n                    dir[i][j][k] = 1e9;\n     \n        int maximum = 0;\n        for(int y = 0 ; y < 2*H-1 ; y++){\n            for(int x = 0 ; x < 2*W ; x++){\n                if( line[y][x] != '0' ) continue;\n                line[y][x] = '1';\n                int c1,c2;\n                if( y % 2 == 0 ){\n                    c1 = id(x-1,y);\n                    c2 = id(x+1,y);\n                }else{\n                    c1 = id(x,y-1);\n                    c2 = id(x,y+1);\n                }\n                for(int k = 0 ; k < 2 ; k++){\n                    // test\n                    int tmp[2000];\n                    memset(tmp,-1,sizeof(tmp));\n                    queue<int> Q;\n                    tmp[c1] = 0;\n                    Q.push(c1);\n                    while(Q.size()){\n                        int q = Q.front(); Q.pop();\n                        for(int i = 0 ; i < 4 ; i++){\n                            int tx = X(q) + dx[i];\n                            int ty = Y(q) + dy[i];\n                            if( tx < 0 || tx >= line[0].size() || ty < 0 || ty >= line.size() || line[ty][tx] == '1') continue;\n                            int next = id(tx+dx[i],ty+dy[i]);\n                            if( tmp[next] == -1 ){\n                                tmp[next]=tmp[q]+1;\n                                Q.push(next);\n                            }\n                        }\n                    }\n                     \n                    if( tmp[g] != -1 ) \n                        dir[y][x][k] = tmp[g];\n                    swap(c1,c2);\n                }\n                line[y][x] = '0';\n            }\n        }\n         \n        memset(done,0,sizeof(done));\n         \n        priority_queue<NODE> Q;\n        Q.push(NODE(s,0,0));\n        while(Q.size()){\n            NODE q = Q.top(); Q.pop();\n             \n            if( q.cost > 905 ){\n                break;\n            }\n            if( done[q.id][q.cost]++ ) continue;\n             \n            if( q.maximum > 1e8 ) continue;\n            if( q.id == g ){\n                cout << q.maximum << endl;\n                goto veryok;\n            }\n            for(int i = 0 ; i < 4 ; i++){\n                int tx = X(q.id) + dx[i];\n                int ty = Y(q.id) + dy[i];\n                if( tx < 0 || tx >= line[0].size() || ty < 0 || ty >= line.size() || line[ty][tx] == '1') continue;\n                int next = id(tx+dx[i],ty+dy[i]);\n                int cost = q.cost + 1;\n                int maximum = q.cost;\n                if( ty % 2 == 0 ){\n                    if( dx[i] == 1 ) maximum += dir[ty][tx][0];\n                    else             maximum += dir[ty][tx][1];\n                }else{\n                    if( dy[i] == 1 ) maximum += dir[ty][tx][0];\n                    else             maximum += dir[ty][tx][1];\n                }\n                Q.push(NODE(next,cost,max(q.maximum,maximum)));\n            }\n        }\n        cout << -1 << endl;\n        veryok:;\n        /*\n        cout << 2*H-1 << \" \" << 2*W-1 << endl;\n        cout << shortest[id(2*H-1,2*W-1)] << endl;\n         \n        for(int i = 0 ; i < 2*H-1 ; i++){\n            for(int j = 0 ; j < 2*W ; j++){\n                if( shortest[id(j,i)] == -1 ) printf(\"     \");\n                else  printf(\"%5d(%d,%d)\",shortest[id(j,i)],j,i);\n            }\n            cout << endl;\n        }\n        */\n \n    }\n     \n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<bitset>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<functional>\n#include<algorithm>\nusing namespace std;\n\nenum {N, E, S, W};\nconst unsigned long ALL = 1 + 2 + 4 + 8;\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\n\nconst int INF = 1000000000;\n\n// for bfs\nenum {Y, X, STEP};\ntypedef tuple<int, int, int> Node;\ntypedef tuple<int, int> Vertex;\n\n// for Dijkstra\nenum {DWORST, DSTEP, DY, DX};\ntypedef tuple<int, int, int, int> DNode;\n\nint h, w;\nvector<vector<bitset<4>>> wall;\n\nint bfs(int by, int bx, int bd, int init_step) {\n    queue<Node> q;\n    q.push(Node(by, bx, init_step));\n    set<Vertex> visited;\n    while(!q.empty()) {\n        int y = get<Y>(q.front());\n        int x = get<X>(q.front());\n        int step = get<STEP>(q.front());\n        q.pop();\n        if(y == h - 1 && x == w - 1) return step;\n        if(visited.count(Vertex(y, x))) continue;\n        visited.insert(Vertex(y, x));\n        for(const auto& d: {N, E, S, W}) {\n            if(wall[y][x][d]) continue;\n            if(y == by && x == bx && d == bd) continue;\n            int ny = y + dy[d];\n            int nx = x + dx[d];\n            if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            q.push(Node(ny, nx, step + 1));\n        }\n    }\n    return INF;\n}\n\nint Dijkstra() {\n    priority_queue<DNode, vector<DNode>, greater<DNode>> q;\n    q.push(DNode(0, 0, 0, 0));\n    set<Vertex> visited;\n    while(!q.empty()) {\n        int worst = get<DWORST>(q.top());\n        int y = get<DY>(q.top());\n        int x = get<DX>(q.top());\n        int step = get<DSTEP>(q.top());\n        q.pop();\n        if(y == h - 1 && x == w - 1) return worst;\n        if(visited.count(Vertex(y, x))) continue;\n        visited.insert(Vertex(y, x));\n        for(const auto& d: {N, E, S, W}) {\n            if(wall[y][x][d]) continue;\n            int ny = y + dy[d];\n            int nx = x + dx[d];\n            if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            if(visited.count(Vertex(ny, nx))) continue;\n            int nworst = max(worst, bfs(y, x, d, step));\n            if(nworst == INF) continue;\n            q.push(DNode(nworst, step + 1, ny, nx));\n        }\n    }\n    return INF;\n}\n\nint main() {\n    while(cin >> h >> w, h | w) {\n        wall = vector<vector<bitset<4>>>(h, vector<bitset<4>>(w, bitset<4>(ALL)));\n        for(int i = 0; i < h - 1; ++i) {\n            for(int j = 0; j < w - 1; ++j) {\n                int is_wall;\n                cin >> is_wall;\n                if(is_wall) continue;\n                wall[i][j].reset(E);\n                wall[i][j + 1].reset(W);\n            }\n            for(int j = 0; j < w; ++j) {\n                int is_wall;\n                cin >> is_wall;\n                if(is_wall) continue;\n                wall[i][j].reset(S);\n                wall[i + 1][j].reset(N);\n            }\n        }\n        for(int j = 0; j < w - 1; ++j) {\n            int is_wall;\n            cin >> is_wall;\n            if(is_wall) continue;\n            wall[h - 1][j].reset(E);\n            wall[h - 1][j + 1].reset(W);\n        }\n\n        int answer = Dijkstra();\n        cout << (answer == INF ? -1 : answer) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\n\n\nint H, W;\nstruct aa {\n\tint x;\n\tint y;\n\tint time;\n};\nclass Compare {\npublic:\n\t//aaが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\nint memo[32][32][2][32][32];\nint normalcheck(const int sx,const int sy,const vector<vector<int>>&tatedoors,const vector<vector<int>>&yokodoors, const bool tclose,const int closex, const int closey) {\n\tif (memo[sx][sy][tclose][closex][closey] >= 0)return memo[sx][sy][tclose][closex][closey];\n\tvector<vector<int>>times(H, vector<int>(W, 99999));\n\ttimes[sy][sx] = 0;\n\tpriority_queue<aa, vector<aa>, Compare>que;\n\tque.push(aa{ sx,sy,0 });\n\twhile (!que.empty()) {\n\t\taa atop(que.top());\n\t\tque.pop();\n\t\tconst int nx = atop.x;\n\t\tconst int ny = atop.y;\n\t\tif (nx == W-1&&ny == H - 1)return memo[sx][sy][tclose][closex][closey]=atop.time;\n\n\t\tif (yokodoors[ny][nx]) {\n\t\t\tif (times[ny - 1][nx]  > atop.time + 1) {\n\t\t\t\ttimes[ny - 1][nx] = atop.time + 1;\n\t\t\t\tque.push(aa{ nx,ny - 1,atop.time + 1 });\n\t\t\t}\n\t\t}\n\t\tif (yokodoors[ny+1][nx]) {\n\t\t\tif (times[ny + 1][nx]  > atop.time + 1) {\n\t\t\t\ttimes[ny + 1][nx] = atop.time + 1;\n\t\t\t\tque.push(aa{ nx,ny + 1,atop.time + 1 });\n\t\t\t}\n\t\t}\n\t\tif (tatedoors[ny][nx]) {\n\t\t\tif (times[ny ][nx - 1]  > atop.time + 1) {\n\t\t\t\ttimes[ny ][nx - 1] = atop.time + 1;\n\t\t\t\tque.push(aa{ nx - 1,ny,atop.time + 1 });\n\t\t\t}\n\t\t}\n\t\tif (tatedoors[ny][nx+1]) {\n\t\t\tif (times[ny][nx + 1]  > atop.time + 1) {\n\t\t\t\ttimes[ny][nx + 1] = atop.time + 1;\n\t\t\t\tque.push(aa{ nx + 1,ny,atop.time + 1 });\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[sx][sy][tclose][closex][closey]= 99999999;\n}\nbool check(const int needtime, vector<vector<int>>tatedoors, vector<vector<int>>yokodoors) {\n\tvector<vector<int>>times(H, vector<int>(W, 99999));\n\ttimes[0][0] = 0;\n\tpriority_queue<aa, vector<aa>, Compare>que;\n\tque.push(aa{ 0,0,0 });\n\twhile (!que.empty()) {\n\t\taa atop(que.top());\n\t\tque.pop();\n\t\tconst int nx = atop.x;\n\t\tconst int ny = atop.y;\n\t\tif (nx == W - 1 &&ny == H - 1)return true;\n\n\t\tif (yokodoors[ny][nx]) {\n\t\t\tif (times[ny - 1][nx]  > atop.time + 1) {\n\t\t\t\tint closetime;\n\t\t\t\t{\n\t\t\t\t\tyokodoors[ny][nx] = false;\n\t\t\t\t\tclosetime=normalcheck(nx, ny, tatedoors, yokodoors,false,nx,ny);\n\t\t\t\t\tyokodoors[ny][nx] = true;\n\t\t\t\t}\n\t\t\t\tif (atop.time + closetime <= needtime) {\n\t\t\t\t\ttimes[ny - 1][nx] = atop.time + 1;\n\t\t\t\t\tque.push(aa{ nx,ny - 1,atop.time + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (yokodoors[ny + 1][nx]) {\n\t\t\tif (times[ny + 1][nx]  > atop.time + 1) {\n\t\t\t\tint closetime;\n\t\t\t\t{\n\t\t\t\t\tyokodoors[ny + 1][nx] = false;\n\t\t\t\t\tclosetime = normalcheck(nx, ny, tatedoors, yokodoors,false,nx, ny + 1);\n\t\t\t\t\tyokodoors[ny + 1][nx] = true;\n\t\t\t\t}\n\t\t\t\tif (atop.time + closetime <= needtime) {\n\t\t\t\t\ttimes[ny+ 1][nx] = atop.time + 1;\n\t\t\t\t\tque.push(aa{ nx,ny + 1,atop.time + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (tatedoors[ny][nx]) {\n\t\t\tif (times[ny][nx - 1] > atop.time + 1) {\n\t\t\t\tint closetime;\n\t\t\t\t{\n\t\t\t\t\ttatedoors[ny][nx] = false;\n\t\t\t\t\tclosetime = normalcheck(nx, ny, tatedoors, yokodoors,true,nx,ny);\n\t\t\t\t\ttatedoors[ny][nx] = true;\n\t\t\t\t}\n\t\t\t\tif (atop.time + closetime <= needtime) {\n\t\t\t\t\ttimes[ny][nx - 1] = atop.time + 1;\n\t\t\t\t\tque.push(aa{ nx - 1,ny,atop.time + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (tatedoors[ny][nx + 1]) {\n\t\t\tif (times[ny][nx + 1]  > atop.time + 1) {\n\t\t\t\tint closetime;\n\t\t\t\t{\n\t\t\t\t\ttatedoors[ny][nx+1] = false;\n\t\t\t\t\tclosetime = normalcheck(nx, ny, tatedoors, yokodoors,true,nx+1,ny);\n\t\t\t\t\ttatedoors[ny][nx+1] = true;\n\t\t\t\t}\n\t\t\t\tif (atop.time + closetime <= needtime) {\n\t\t\t\t\ttimes[ny][nx + 1] = atop.time + 1;\n\t\t\t\t\tque.push(aa{ nx + 1,ny,atop.time + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main() { \n\twhile (1) {\n\t\tmemset(memo, -1, sizeof(memo));\n\n\t\tcin >> H >> W;\n\t\tif (!H)break;\n\t\tvector<vector<int>>yokodoors;\n\t\tvector<vector<int>>tatedoors;\n\t\tyokodoors.resize(H+1);\n\t\ttatedoors.resize(H);\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tbool open = false;\n\t\t\tyokodoors[0].push_back(open);\n\t\t\tyokodoors[H].push_back(open);\n\t\t}\n\n\t\tfor (int i = 0; i < 2 * H -1; ++i) {\n\t\t\tif (i % 2) {\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tbool open; cin >> open;\n\t\t\t\t\topen = !open;\n\t\t\t\t\tyokodoors[i / 2 + 1].push_back(open);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttatedoors[i / 2].push_back(false);\n\t\t\t\tfor (int j = 0; j < W - 1; ++j) {\n\t\t\t\t\tbool open; cin >> open;\n\t\t\t\t\topen = !open;\n\t\t\t\t\ttatedoors[i / 2].push_back(open);\n\t\t\t\t}\n\t\t\t\ttatedoors[i / 2].push_back(false);\n\t\t\t}\n\t\t}\n\n\t\tif (!check(1000000,tatedoors,yokodoors)) {\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tint amin = 0;\n\t\t\tint amax = 1000;\n\t\t\twhile (amin + 1 != amax) {\n\t\t\t\tint amid = (amin + amax) / 2;\n\t\t\t\tif (check(amid,tatedoors,yokodoors)) {\n\t\t\t\t\tamax = amid;\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamin = amid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << amax << endl;\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define fi first\n#define se second\ntypedef pair<int,int> P;\ntypedef pair<P,int> PPI;\n\nstruct state {\n  int i,j,dist,cost;\n};\nbool operator<(const state& a,const state& b){\n  return a.cost>b.cost;\n}\n\nint h,w;\nbool wall[33][33][33][33];\nint dd[]={-1,0,1,0,-1};\n\nint fail[33][33][5];\nint dp[33][33][2000];\n\nint bfs(int y,int x){\n  int dist[33][33];\n  rep(i,33)rep(j,33)dist[i][j]=INF;\n\n  queue<PPI> que;\n  que.push(PPI(P(h-1,w-1),0));\n  while(que.size()){\n    PPI p=que.front(); que.pop();\n    int i=p.fi.fi,j=p.fi.se; int nd=p.se;\n    if(dist[i][j]!=INF)continue;\n    dist[i][j]=nd;\n    rep(dir,4){\n      int ni=i+dd[dir],nj=j+dd[dir+1];\n      if(ni>=0&&ni<h&&nj>=0&&nj<w&&!wall[i][j][ni][nj]){\n        que.push(PPI(P(ni,nj),nd+1));\n      }\n    }\n  }\n  return dist[y][x];\n}\n\nint main(void) {\n  while(1) {\n    cin>>h>>w;\n    if(h==0)break;\n    memset(wall,0,sizeof(wall));\n    rep(i,2*h-1){\n      int ii=i/2;\n      if(i%2==0){\n        rep(j,w-1){\n          cin>>wall[ii][j][ii][j+1];\n          wall[ii][j+1][ii][j]=wall[ii][j][ii][j+1];\n        }\n      }else{\n        rep(j,w){\n          cin>>wall[ii][j][ii+1][j];\n          wall[ii+1][j][ii][j]=wall[ii][j][ii+1][j];\n        }\n      }\n    }\n\n    rep(i,33)rep(j,33)rep(dir,4)fail[i][j][dir]=INF;\n    rep(i,h)rep(j,w){\n      rep(dir,4){\n        int ni=i+dd[dir],nj=j+dd[dir+1];\n        if(ni>=0&&ni<h&&nj>=0&&nj<w&&!wall[i][j][ni][nj]){\n          wall[i][j][ni][nj]=wall[ni][nj][i][j]=true;\n          fail[i][j][dir]=bfs(i,j);\n          wall[i][j][ni][nj]=wall[ni][nj][i][j]=false;\n        }\n      }\n    }\n\n    int ans=-1;\n    priority_queue<state> que;\n    que.push((state){0,0,0,0});\n    rep(i,33)rep(j,33)rep(k,2000)dp[i][j][k]=INF;\n    while(que.size()) {\n      state s=que.top(); que.pop();\n      int i=s.i,j=s.j,dist=s.dist,cost=s.cost;\n      if(i==h-1&&j==w-1){\n        ans=cost;\n        break;\n      }\n      if(dp[i][j][dist]!=INF)continue;\n      dp[i][j][dist]=cost;\n      rep(dir,4) {\n        int ni=i+dd[dir],nj=j+dd[dir+1];\n        if(ni>=0&&ni<h&&nj>=0&&nj<w&&!wall[i][j][ni][nj]&&dist+1<2*h*w&&fail[i][j][dir]!=INF) {\n          que.push((state){ni,nj,dist+1,max(dist+fail[i][j][dir],cost)});\n        }\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstdio>\n#include <cstring>\n#include <climits>\nusing namespace std;\n\nconst int dx[] = {0, 1, 0, -1}; //上右下左\nconst int dy[] = {-1, 0, 1, 0};\nconst int inf = 1<<20;\n\nint w,h;\nint DP[32][32], usedCard[32][32];\nint block[32][32][4];\nint path[4][32][32]; // 未処理の場合は -1, ゴールできないときは inf\nstring field[70];\n\nstruct state{\n    int x,y;\n    int step;\n    int worstStep;\n    state(int _x, int _y, int s, int w){\n        x = _x;\n        y = _y;\n        step = s;\n        worstStep = w;\n    }\n    bool operator<(const state& a)const{\n        if( worstStep == a.worstStep ) return step > a.step;\n        return worstStep > a.worstStep;\n    }\n};\n\n\ninline bool inside(int x, int y){\n    return !( x < 0 || x >= 2*w-1 || y >= 2*h-1 || y < 0 );\n}\n\n\nint bfs(int sx, int sy, int gx, int gy){\n    int k;\n    char memo[32][32];\n    queue<pair<int,int> > q;\n\n    memset(memo, -1, sizeof(memo));\n    q.push(make_pair(sx,sy));\n    memo[sy][sx] = 0;\n\n    if( sx == gx && sy == gy ) return 0;\n\n    while( !q.empty() ){\n        int x = q.front().first;\n        int y = q.front().second;\n        int s = memo[y][x];\n        q.pop();\n\n        for(k=0; k<4; k++){\n            int nx = x + dx[k], ny = y + dy[k];\n            if( !block[y][x][k] && memo[ny][nx] == -1 ){\n                memo[ny][nx] = s + 1;\n                if( gy == ny && gx == nx ){\n                    return s + 1;\n                }\n                q.push(make_pair(nx, ny));\n            }\n        }\n    }\n    \n    return inf;\n}\n\n\nint solve(){\n    int i,k;\n    priority_queue<state> q;\n    q.push(state(0,0,0,0));\n\n    while( !q.empty() ){\n        int x = q.top().x;\n        int y = q.top().y;\n        int step = q.top().step;\n        int wstep = q.top().worstStep;\n        q.pop();\n\n        if( step > 200 ) break;\n\n        if( y == h-1 && x == w-1 ) return wstep;\n\n        for(k=0; k<4; k++){\n            if( block[y][x][k] ) continue;\n                \n            // ドアが壊れてたときの計算\n            int nextWorstStep = inf;\n\n            // まだBFSで調べてないので調べる\n            if( path[k][y][x] == -1 ){\n                block[y][x][k] = 1;\n                path[k][y][x] = bfs(x, y, w-1, h-1);\n                block[y][x][k] = 0;\n            }\n\n            if( path[k][y][x] == inf ) continue; // ゴールできない\n\n            nextWorstStep = max(wstep, step + path[k][y][x]);\n\n            int nx = x + dx[k], ny = y + dy[k];\n\n            if( DP[ny][nx] > nextWorstStep ){\n                DP[ny][nx] = nextWorstStep;\n                usedCard[ny][nx] = step + 1;\n                q.push(state(nx, ny, step + 1, nextWorstStep));\n            }\n            else if( step + 1 < usedCard[ny][nx] ){\n                // nextWorstStepが最も小さいものから処理されるから、2度目以降のnextWorstStepは必ず大きい。よって、\n                usedCard[ny][nx] = step + 1;\n                q.push(state(nx, ny, step + 1, nextWorstStep));\n            }\n        }\n    }\n    return -1;\n}\n\n\n\nint main(){\n    int i,j,k;\n\n    while( cin >> h >> w, h|w ){\n        cin.ignore();\n\n        // input\n        for(i=0; i<2*h-1; i++){\n            getline(cin, field[i]);\n            if( i % 2 == 0 ) field[i] += \" \";\n        }\n        fill(&DP[0][0], &DP[0][0] + 32*32, inf);\n        fill(&usedCard[0][0], &usedCard[0][0] + 32*32, inf);\n        memset(path, -1, sizeof(path));\n\n        // 通れない場所を予め調べておく\n        for(i=0; i<h; i++){\n            for(j=0; j<w; j++){\n                for(k=0; k<4; k++){\n                    int tx = 2*j + dx[k];\n                    int ty = 2*i + dy[k];\n                    if( !inside(tx, ty) || field[ty][tx] == '1' ){\n                        block[i][j][k] = 1;\n                    }\n                    else{\n                        block[i][j][k] = 0;\n                    }\n                }\n            }\n        }\n        cout << solve() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int N = 30;\nconst int inf = 1<<20;\n\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\nint rev[]={1,0,3,2};\nbool edge[N][N][4];\n\nint cost[N][N];\nint bfs(int r,int c,int sy,int sx){\n  rep(i,r)rep(j,c)cost[i][j]=inf;\n  cost[sy][sx]=0;\n  queue<int> Q;\n  Q.push(sy*c+sx);\n  while(!Q.empty()){\n    int y=Q.front()/c,x=Q.front()%c;Q.pop();\n    if (y == r-1 && x == c-1)return cost[r-1][c-1];\n    rep(i,4){\n      int nex=x+dx[i],ney=y+dy[i];\n      if (nex == -1 || ney == -1 || nex == c || ney == r || !edge[y][x][i] || cost[ney][nex] != inf)continue;\n      cost[ney][nex] = cost[y][x] + 1;\n      Q.push(ney*c+nex);\n    }\n  }\n  return inf;\n}\n\nbool vis[N][N];\nint opt[N][N];\nint solve(int r,int c){\n  rep(i,r)rep(j,c)opt[i][j]=inf,vis[i][j]=false;\n  opt[r-1][c-1]=0;\n  while(true){\n    bool fg=false;\n    rep(i,r){\n      rep(j,c){\n\tint tmp = opt[i][j];\n\trep(k,4){\n\t  int nex=j+dx[k],ney=i+dy[k];\n\t  if (ney == -1 || nex == -1 || ney == r || nex == c || !edge[i][j][k] || opt[ney][nex] >= opt[i][j])continue;\n\t  edge[i][j][k]=false;\n\t  int a=bfs(r,c,i,j);\n\t  edge[i][j][k]=true;\n\t  opt[i][j]=min(opt[i][j],max(1+opt[ney][nex],a));\n\t}\n\tif (opt[i][j] != tmp)fg=true;\n      }\n    }\n    if (!fg)break;\n  }\n  return opt[0][0]==inf?-1:opt[0][0];\n}\n\nmain(){\n  int r,c;\n  while(cin>>r>>c && r){\n    rep(i,r)rep(j,c)rep(k,4)edge[i][j][k]=true;\n    rep(i,r){\n      rep(j,c-1){\n\tcin>>edge[i][j][0];edge[i][j][0]=1-edge[i][j][0];edge[i][j+1][1]=edge[i][j][0];\n      }\n      if (i == r-1)break;\n      rep(j,c){\n\tcin>>edge[i][j][2];edge[i][j][2]=1-edge[i][j][2];edge[i+1][j][3]=edge[i][j][2];\n      }\n    }\n    cout << solve(r,c) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#ifdef DEBUG_MODE\n    #define DBG(n) n;\n#else\n    #define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n \ntypedef long long ll;\ntypedef pair<pair<int,int>,int> P;\nint h,w;\npair<int,int> dp[33*33];\nint dist[33*33];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nvector<vector<int>> v(33*33);\n \nint fun(int a,int b){\n    REP(i,33*33)dist[i] = INF;\n    dist[a] = 0;\n    queue<pair<int,int>> q;\n    q.push(MP(a,0));\n    while(!q.empty()){\n        pair<int,int> now = q.front();q.pop();\n        int node = now.FI;\n        int kyo = now.SE;\n        if(kyo > dist[node])continue;\n        REP(i,v[node].size()){\n            int aite = v[node][i];\n            if((node == a && aite == b) || (node == b && aite == a))continue;\n            if(dist[aite] > kyo + 1){\n                dist[aite] = kyo + 1;\n                q.push(MP(aite,kyo+1));\n            }\n        }\n    }\n    return dist[h*w-1];\n}\n \nint main()\n{\n    while(cin >> h >> w,h|w){\n        //初期化\n        REP(i,33*33)dp[i] = MP(INF,INF);\n        REP(i,33*33){v[i].clear();}\n        dp[0] = MP(0,0);\n         \n        //入力\n        REP(i,h){\n            REP(j,w-1){\n                int tmp;cin >> tmp;\n                if(tmp == 0){\n                    v[i*w+j].PB(i*w+j+1);\n                    v[i*w+j+1].PB(i*w+j);\n                }\n                 \n            }\n            if(i != h-1)REP(j,w){\n                int tmp;cin >> tmp;\n                if(tmp == 0){\n                    v[i*w+j].PB((i+1)*w+j);\n                    v[(i+1)*w+j].PB(i*w+j);\n                }\n            }\n        }\n                 \n        priority_queue<P,vector<P>,greater<P>> q;\n        q.push(MP(MP(0,-1),0));\n        DBG(cout << \"!\" << endl;);\n        while(!q.empty()){\n            DBG(\n            cout << \"DP TABLE\" << endl;\n            REP(i,h){\n                REP(j,w){\n                    cout << dp[i*w+j].FI << ' ';\n                }\n                cout << endl;\n            }\n            )\n            P now = q.top();q.pop();\n            int node = now.SE;\n            pair<int,int> kyori = now.FI;\n            DBG(cout << kyori.FI << ' ' << kyori.SE << endl;)\n            DBG(cout << dp[node].FI << ' ' << dp[node].SE << endl;)\n            if(dp[node].FI < kyori.FI && dp[node].SE < kyori.SE)continue;\n            DBG(cout << \"IN\" << endl;)\n            kyori.SE++;\n            REP(i,v[node].size()){\n                int aite = v[node][i];\n                pair<int,int> score = MP(fun(node,aite)+kyori.SE,kyori.SE);\n                score = MP(max(dp[node].FI,score.FI),score.SE);\n                if(dp[aite].FI > score.FI || dp[aite].SE > score.SE){\n                    dp[aite].FI = min(dp[aite].FI,score.FI);\n                    dp[aite].SE = min(dp[aite].SE,score.SE);\n                    q.push(MP(score,aite));\n                }\n            }\n        }\n         \n        DBG(\n        cout << \"DP TABLE\" << endl;\n        REP(i,h){\n            REP(j,w){\n                cout << dp[i*w+j].FI << ' ';\n            }\n            cout << endl;\n        }\n        )\n         \n        DBG(cout << \"ANS IS \";);\n         \n        if(dp[h*w-1].FI == INF){\n            cout << -1 << endl;\n        }\n        else{\n            cout << dp[h*w-1].FI << endl;\n        }\n    }\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 32;\n\nint h,w;\nint tate[MAX_N][MAX_N];\nint yoko[MAX_N][MAX_N];\nint tt[MAX_N][MAX_N][2];\nint yk[MAX_N][MAX_N][2];\nint d[MAX_N*MAX_N];\n\nbool possible(int cri)\n{\n    rep(i,h){\n        rep(j,w){\n            d[i*w+j] = INF;\n        }\n    }\n    queue<int> que;\n    que.push(0);\n    d[0] = 0;\n    while(!que.empty()){\n        int p = que.front();\n        que.pop();\n        int x = p / w, y = p % w;\n        if(y < w-1 && !yoko[x][y] && d[x*w+y+1] > d[p] + 1 && d[p] + yk[x][y][0] <= cri){\n            d[x*w+y+1] = d[p] + 1;\n            que.push(x*w+y+1);\n        }\n        if(y > 0 && !yoko[x][y-1] && d[x*w+y-1] > d[p] + 1 && d[p] + yk[x][y-1][1] <= cri){\n            d[x*w+y-1] = d[p] + 1;\n            que.push(x*w+y-1);\n        }\n        if(x < h-1 && !tate[x][y] && d[(x+1)*w+y] > d[p] + 1 && d[p] + tt[x][y][0] <= cri){\n            d[(x+1)*w+y] = d[p] + 1;\n            que.push((x+1)*w+y);\n        }\n        if(x > 0 && !tate[x-1][y] && d[(x-1)*w+y] > d[p] + 1 && d[p] + tt[x-1][y][1] <= cri){\n            d[(x-1)*w+y] = d[p] + 1;\n            que.push((x-1)*w+y);\n        }\n    }\n    return (d[h*w-1] != INF);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        cin >> h >> w;\n        if(h == 0 && w == 0){\n            break;\n        }\n        rep(i,2*h-1){\n            if(i % 2){\n                rep(j,w){\n                    cin >> tate[i/2][j];\n                }\n            }else{\n                rep(j,w-1){\n                    cin >> yoko[i/2][j];\n                }\n            }\n        }\n        rep(i,h){\n            rep(j,w-1){\n                if(!yoko[i][j]){\n                    yoko[i][j] = 1;\n                    rep(k,2){\n                        int pos = w*i+j+k;\n                        rep(l,h){\n                            rep(r,w){\n                                d[l*w+r] = INF;\n                            }\n                        }\n                        queue<int> que;\n                        d[pos] = 0;\n                        que.push(pos);\n                        while(!que.empty()){\n                            int p = que.front();\n                            que.pop();\n                            int x = p / w, y = p % w;\n                            if(y < w-1 && !yoko[x][y] && d[x*w+y+1] > d[p] + 1){\n                                d[x*w+y+1] = d[p] + 1;\n                                que.push(x*w+y+1);\n                            }\n                            if(y > 0 && !yoko[x][y-1] && d[x*w+y-1] > d[p] + 1){\n                                d[x*w+y-1] = d[p] + 1;\n                                que.push(x*w+y-1);\n                            }\n                            if(x < h-1 && !tate[x][y] && d[(x+1)*w+y] > d[p] + 1){\n                                d[(x+1)*w+y] = d[p] + 1;\n                                que.push((x+1)*w+y);\n                            }\n                            if(x > 0 && !tate[x-1][y] && d[(x-1)*w+y] > d[p] + 1){\n                                d[(x-1)*w+y] = d[p] + 1;\n                                que.push((x-1)*w+y);\n                            }\n                        }\n                        yk[i][j][k] = d[h*w-1];\n                    }\n                    yoko[i][j] = 0;\n                }\n            }\n        }\n        rep(i,h-1){\n            rep(j,w){\n                if(!tate[i][j]){\n                    tate[i][j] = 1;\n                    rep(k,2){\n                        int pos = (w+k)*i+j;\n                        rep(l,h){\n                            rep(r,w){\n                                d[l*w+r] = INF;\n                            }\n                        }\n                        queue<int> que;\n                        d[pos] = 0;\n                        que.push(pos);\n                        while(!que.empty()){\n                            int p = que.front();\n                            que.pop();\n                            int x = p / w, y = p % w;\n                            if(y < w-1 && !yoko[x][y] && d[x*w+y+1] > d[p] + 1){\n                                d[x*w+y+1] = d[p] + 1;\n                                que.push(x*w+y+1);\n                            }\n                            if(y > 0 && !yoko[x][y-1] && d[x*w+y-1] > d[p] + 1){\n                                d[x*w+y-1] = d[p] + 1;\n                                que.push(x*w+y-1);\n                            }\n                            if(x < h-1 && !tate[x][y] && d[(x+1)*w+y] > d[p] + 1){\n                                d[(x+1)*w+y] = d[p] + 1;\n                                que.push((x+1)*w+y);\n                            }\n                            if(x > 0 && !tate[x-1][y] && d[(x-1)*w+y] > d[p] + 1){\n                                d[(x-1)*w+y] = d[p] + 1;\n                                que.push((x-1)*w+y);\n                            }\n                        }\n                        tt[i][j][k] = d[h*w-1];\n                    }\n                    tate[i][j] = 0;\n                }\n            }\n        }\n        int l = 0, r = 2*w*h-h-w;\n        if(!possible(r)){\n            cout << \"-1\\n\";\n            continue;\n        }\n        while(r-l>1){\n            int mid = (l+r)/2;\n            if(possible(mid)){\n                r = mid;\n            }else{\n                l = mid;\n            }\n        }\n        cout << r << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#define INF 1000000000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> Pint;\n\nint main()\n{\n\twhile(1){\n      int h, w;\n      cin>>h>>w;\n      if(h==0 && w==0) break;\n      int yk[30][30], tt[30][30];\n      for(int i=0; i<h; i++){\n        for(int j=0; j<w-1; j++){\n          cin>>yk[i][j];\n        }\n        if(i==h-1) break;\n        for(int j=0; j<w; j++){\n          cin>>tt[i][j];\n        }\n      }\n      int d[2][30][30][30][30];\n      for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++){\n\t\t\tfor(int k=0; k<h; k++){\n\t\t\t\tfor(int l=0; l<w-1; l++){\n\t\t\t\t\td[0][k][l][i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k=0; k<h-1; k++){\n\t\t\t\tfor(int l=0; l<w; l++){\n\t\t\t\t\td[1][k][l][i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n      }\n\t  for(int k=0; k<h; k++){\n\t\t  for(int l=0; l<w-1; l++){\n\t\t\t  if(yk[k][l]==1) continue;\n\t\t\t  d[0][k][l][h-1][w-1]=0;\n\t\t\t  queue<P> que;\n\t\t\t  que.push(P(h-1, w-1));\n\t\t\t  while(!que.empty()){\n\t\t\t\tP p=que.front();\n\t\t\t\tque.pop();\n\t\t\t\tint x=p.first;\n\t\t\t\tint y=p.second;\n\t\t\t\tif(x-1>=0){\n\t\t\t\t\tif(tt[x-1][y]==0 && d[0][k][l][x-1][y]>d[0][k][l][x][y]+1){\n\t\t\t\t\t\td[0][k][l][x-1][y]=d[0][k][l][x][y]+1;\n\t\t\t\t\t\tque.push(P(x-1, y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(x+1<h){\n\t\t\t\t\tif(tt[x][y]==0 && d[0][k][l][x+1][y]>d[0][k][l][x][y]+1){\n\t\t\t\t\t\td[0][k][l][x+1][y]=d[0][k][l][x][y]+1;\n\t\t\t\t\t\tque.push(P(x+1, y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(y-1>=0){\n\t\t\t\t\tif(yk[x][y-1]==0 && (!(x==k && y-1==l)) && d[0][k][l][x][y-1]>d[0][k][l][x][y]+1){\n\t\t\t\t\t\td[0][k][l][x][y-1]=d[0][k][l][x][y]+1;\n\t\t\t\t\t\tque.push(P(x, y-1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(y+1<w){\n\t\t\t\t\tif(yk[x][y]==0 && (!(x==k && y==l)) && d[0][k][l][x][y+1]>d[0][k][l][x][y]+1){\n\t\t\t\t\t\td[0][k][l][x][y+1]=d[0][k][l][x][y]+1;\n\t\t\t\t\t\tque.push(P(x, y+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t  }\n\t\t  }\n      }\n\t  for(int k=0; k<h-1; k++){\n\t\t  for(int l=0; l<w; l++){\n\t\t\t  if(tt[k][l]==1) continue;\n\t\t\t  d[1][k][l][h-1][w-1]=0;\n\t\t\t  queue<P> que;\n\t\t\t  que.push(P(h-1, w-1));\n\t\t\t  while(!que.empty()){\n\t\t\t\tP p=que.front();\n\t\t\t\tque.pop();\n\t\t\t\tint x=p.first;\n\t\t\t\tint y=p.second;\n\t\t\t\tif(x-1>=0){\n\t\t\t\t\tif(tt[x-1][y]==0 && (!(x-1==k && y==l)) && d[1][k][l][x-1][y]>d[1][k][l][x][y]+1){\n\t\t\t\t\t\td[1][k][l][x-1][y]=d[1][k][l][x][y]+1;\n\t\t\t\t\t\tque.push(P(x-1, y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(x+1<h){\n\t\t\t\t\tif(tt[x][y]==0 && (!(x==k && y==l)) && d[1][k][l][x+1][y]>d[1][k][l][x][y]+1){\n\t\t\t\t\t\td[1][k][l][x+1][y]=d[1][k][l][x][y]+1;\n\t\t\t\t\t\tque.push(P(x+1, y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(y-1>=0){\n\t\t\t\t\tif(yk[x][y-1]==0 && d[1][k][l][x][y-1]>d[1][k][l][x][y]+1){\n\t\t\t\t\t\td[1][k][l][x][y-1]=d[1][k][l][x][y]+1;\n\t\t\t\t\t\tque.push(P(x, y-1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(y+1<w){\n\t\t\t\t\tif(yk[x][y]==0 && d[1][k][l][x][y+1]>d[1][k][l][x][y]+1){\n\t\t\t\t\t\td[1][k][l][x][y+1]=d[1][k][l][x][y]+1;\n\t\t\t\t\t\tque.push(P(x, y+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t  }\n\t\t  }\n      }\n\t  bool no=0;\n\t  for(int k=0; k<h; k++){\n\t\t  for(int l=0; l<w-1; l++){\n\t\t\t  if(yk[k][l]==0 && d[0][k][l][0][0]==INF){\n\t\t\t\t  no=1;\n\t\t\t\t  break;\n\t\t\t  }\n\t\t  }\n\t\t  if(no) break;\n\t  }\n\t  if(no){\n\t\t  cout<<-1<<endl;\n\t\t  continue;\n\t  }\n\t  for(int k=0; k<h-1; k++){\n\t\t  for(int l=0; l<w; l++){\n\t\t\t  if(tt[k][l]==0 && d[1][k][l][0][0]==INF){\n\t\t\t\t  no=1;\n\t\t\t\t  break;\n\t\t\t  }\n\t\t  }\n\t\t  if(no) break;\n\t  }\n\t  if(no){\n\t\t  cout<<-1<<endl;\n\t\t  continue;\n\t  }\n      priority_queue<Pint, vector<Pint>, greater<Pint> > que2;\n      int d2[30][30];\n      for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++){\n          d2[i][j]=INF;\n        }\n      }\n      d2[h-1][w-1]=0;\n      que2.push(Pint(0, P(h-1, w-1)));\n      while(!que2.empty()){\n        Pint p=que2.top();\n        que2.pop();\n        int x=p.second.first, y=p.second.second;\n        if(d2[x][y]<p.first) continue;\n\t\tif(y-1>=0){\n\t\t\tif(yk[x][y-1]==0 && d2[x][y-1]>max(d2[x][y]+1, d[0][x][y-1][x][y-1])){\n\t\t\t\td2[x][y-1]=max(d2[x][y]+1, d[0][x][y-1][x][y-1]);\n\t\t\t\tque2.push(Pint(d2[x][y-1], P(x, y-1)));\n\t\t\t}\n\t\t}\n\t\tif(y+1<w){\n\t\t\tif(yk[x][y]==0 && d2[x][y+1]>max(d2[x][y]+1, d[0][x][y][x][y+1])){\n\t\t\t\td2[x][y+1]=max(d2[x][y]+1, d[0][x][y][x][y+1]);\n\t\t\t\tque2.push(Pint(d2[x][y+1], P(x, y+1)));\n\t\t\t}\n\t\t}\n\t\tif(x-1>=0){\n\t\t\tif(tt[x-1][y]==0 && d2[x-1][y]>max(d2[x][y]+1, d[1][x-1][y][x-1][y])){\n\t\t\t\td2[x-1][y]=max(d2[x][y]+1, d[1][x-1][y][x-1][y]);\n\t\t\t\tque2.push(Pint(d2[x-1][y], P(x-1, y)));\n\t\t\t}\n\t\t}\n\t\tif(x+1<h){\n\t\t\tif(tt[x][y]==0 && d2[x+1][y]>max(d2[x][y]+1, d[1][x][y][x+1][y])){\n\t\t\t\td2[x+1][y]=max(d2[x][y]+1, d[1][x][y][x+1][y]);\n\t\t\t\tque2.push(Pint(d2[x+1][y], P(x+1, y)));\n\t\t\t}\n\t\t}\n\t  }\n\t  cout<<d2[0][0]<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reps(i,a,b) for(int i=(a); i<(b); ++i)\n#define rep(i,n) reps(i,0,n)\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nstruct UnionFind{\n\tstd::vector<int> data;\n\tUnionFind(int size): data(size, -1) {}\n\n\tbool unite(int x, int y){\n\t\tx=root(x);\n\t\ty=root(y);\n\t\tif( x != y ){\n\t\t\tif( data[y] < data[x] ) std::swap(x, y);\n\t\t\tdata[x] += data[y];\n\t\t\tdata[y] = x;\n\t\t}\n\t\treturn x!=y;\n\t}\n\n\tbool find(int x, int y){\n\t\treturn root(x) == root(y);\n\t}\n\n\tint root(int x){\n\t\treturn (data[x] < 0)? x : data[x]=root(data[x]);\n\t}\n\n\tint size(int x){\n\t\treturn -data[ root(x) ];\n\t}\n};\n\n// R, U, L, D\nconst int vx[]={1,0,-1,0}, vy[]={0,1,0,-1};\n\nconst int INF = 1e9;\n\nint h, w;\nint ans;\nmap<pii,int> cost;\nvoid solve(map<pii,int> &mp, map<pii,int> &tb, int x, int y, int d){\n\tqueue<pair<pii,int>> que;\n\tque.push( {pii(x,y), d} );\n\ttb[pii(x,y)] = d;\n\twhile(!que.empty()){\n\t\tauto cur = que.front().X;\n\t\tint x = cur.X;\n\t\tint y = cur.Y;\n\t\tint d = que.front().Y;\n\t\tque.pop();\n\t\trep(k,4){\n\t\t\tint nx = x + vx[k];\n\t\t\tint ny = y + vy[k];\n\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n\t\t\tif( mp[cur] & (1<<k) ) continue;\n\t\t\tif( !tb.count(pii(nx,ny)) || tb[pii(nx,ny)] > d + 1 ){\n\t\t\t\ttb[pii(nx,ny)] = d + 1;\n\t\t\t\tque.push( {pii(nx,ny), d+1} );\n\t\t\t}\n\t\t}\n\t}\n\tif( !tb.count(pii(w-1,h-1)) ) tb[pii(w-1,h-1)] = INF;\n\tcost[pii(x,y)] = max(cost[pii(x,y)], tb[pii(w-1,h-1)]);\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\twhile(cin >> h >> w, h|w){\n\t\tcost.clear();\n\t\tmap<pii,int> mp;\n\t\tint d;\n\t\trep(i,h-1){\n\t\t\trep(j,w-1){\n\t\t\t\tcin >> d;\n\t\t\t\tif( d == 1 ){\n\t\t\t\t\tmp[pii(j,i)]   |= (1<<0);\n\t\t\t\t\tmp[pii(j+1,i)] |= (1<<2);\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,w){\n\t\t\t\tcin >> d;\n\t\t\t\tif( d == 1 ){\n\t\t\t\t\tmp[pii(j,i)]   |= (1<<1);\n\t\t\t\t\tmp[pii(j,i+1)] |= (1<<3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint i = h-1;\n\t\trep(j,w-1){\n\t\t\tcin >> d;\n\t\t\tif( d == 1 ){\n\t\t\t\tmp[pii(j,i)]   |= (1<<0);\n\t\t\t\tmp[pii(j+1,i)] |= (1<<2);\n\t\t\t}\n\t\t}\n\t\trep(i,h) mp[pii(0,i)]   |= (1<<2);\n\t\trep(i,h) mp[pii(w-1,i)] |= (1<<0);\n\t\trep(i,w) mp[pii(i,0)]   |= (1<<3);\n\t\trep(i,w) mp[pii(i,h-1)] |= (1<<1);\n\n\t\tmap<pii,int> tb_s;\n\t\tsolve(mp, tb_s, 0, 0, 0);\n\t\tans = 0;\n//\t\trep(i,h){\n//\t\t\trep(j,w) cout << tb_s[pii(j,i)] << \" \";\n//\t\t\tcout << endl;\n//\t\t}\n\n\t\trep(y,h) rep(x,w) rep(k,4){\n\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n\t\t\tif( cost[pii(x,y)] >= INF ) continue;\n\t\t\tint nx = x + vx[k];\n\t\t\tint ny = y + vy[k];\n\t\t\tauto mp1 = mp;\n\t\t\tmp1[pii(x,y)]   |= (1<<k);\n\t\t\tmp1[pii(nx,ny)] |= (1<<((k+2)%4));\n\t\t\tmap<pii,int> tb;\n\t\t\t//solve(mp1, tb, x, y, tb_s[pii(x,y)]);\n\t\t\tsolve(mp1, tb, x, y, 0);\n\t\t\t//cout << \"solve: \" << x << \" \" << y << \" k=\" << k << endl;\n\t\t\t//rep(i,h){\n\t\t\t//\trep(j,w) cout << tb[pii(j,i)] << \" \";\n\t\t\t//\tcout << endl;\n\t\t\t//}\n\t\t}\n\n//\t\tcout << \"cost:\" << endl;\n//\t\trep(i,h){\n//\t\t\trep(j,w) cout << (cost[pii(j,i)]==INF ? 99 : cost[pii(j,i)]) << \" \";\n//\t\t\tcout << endl;\n//\t\t}\n\n\t\ttypedef pair<pii,pii> PII;\n\t\tpriority_queue<PII, vector<PII>, greater<PII>> que;\n\t\tmap<pii,pii> memo;\n\t\tque.push({{cost[pii(0,0)],0},pii(0,0)});\n\t\twhile(!que.empty()){\n\t\t\tint c = que.top().X.X;\n\t\t\tint d = que.top().X.Y;\n\t\t\tint x = que.top().Y.X;\n\t\t\tint y = que.top().Y.Y;\n\t\t\tque.pop();\n\t\t\t//if( memo.count(pii(x,y)) && memo[pii(x,y)] < pii(c,d) ) continue;\n\t\t\tif( memo.count(pii(x,y)) ) continue;\n\t\t\tmemo[pii(x,y)] = pii(c,d);\n\t\t\tans = max(ans, c);\n\t\t\tif( pii(x,y) == pii(w-1,h-1) ) break;\n\t\t\trep(k,4){\n\t\t\t\tint nx = x + vx[k];\n\t\t\t\tint ny = y + vy[k];\n\t\t\t\tint nc = d + 1 + cost[pii(nx,ny)];\n\t\t\t\tnc = min(nc, INF);\n\t\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n\t\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n\t\t\t\tif( !memo.count(pii(nx,ny)) || memo[pii(nx,ny)] > pii(nc,d+1) ){\n\t\t\t\t\t//memo[pii(nx,ny)] = pii(nc, d+1);\n\t\t\t\t\tque.push( {pii(nc, d+1), pii(nx, ny)} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tpii pos = {w-1,h-1};\n//\t\tans = max(ans, memo[pos].X);\n//\t\twhile( pos != pii(0,0) ){\n//\t\t\tint x = pos.X;\n//\t\t\tint y = pos.Y;\n//\t\t\trep(k,4){\n//\t\t\t\tint nx = x + vx[k];\n//\t\t\t\tint ny = y + vy[k];\n//\t\t\t\tint nc = d + 1 + cost[pii(nx,ny)];\n//\t\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n//\t\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n//\t\t\t\tif( memo.count(pii(nx,ny)) && memo[pii(nx,ny)].Y < memo[pos].Y ){\n//\t\t\t\t\tpos = pii(nx,ny);\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tans = max(ans, memo[pos].X);\n//\t\t}\n\n//\t\tmultimap<int, pii> order;\n//\t\tfor(auto t: memo) order.insert({ t.Y.X, t.X });\n//\t\tUnionFind uf(1000);\n//\t\tfor(auto t: order){\n//\t\t\tint x = t.Y.X;\n//\t\t\tint y = t.Y.Y;\n//\t\t\trep(k,4){\n//\t\t\t\tint nx = x + vx[k];\n//\t\t\t\tint ny = y + vy[k];\n//\t\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n//\t\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n//\t\t\t\tif( memo[pii(nx,ny)].X <= t.X ){\n//\t\t\t\t\tuf.unite( nx+ny*w, x+y*w );\n//\t\t\t\t}\n//\t\t\t}\n////\t\t\tcout << \"order: \" << x << \" \" << y << \" \" << t.X << endl;\n//\t\t\tif( uf.find(0, (w-1)+(h-1)*w ) ){\n//\t\t\t\tans = t.X;\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t}\n\n\t\tcout << (ans >= INF ? -1 : ans) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n,m;\nvvi H,W;\nvvi dp,T;\n\nint main(){\n\twhile(cin>>n>>m,n){\n\t\tH=vvi(n-1,vi(m));\n\t\tW=vvi(n,vi(m-1));\n\t\trep(k,n-1){\n\t\t\trep(i,m-1)cin>>W[k][i];\n\t\t\trep(i,m)cin>>H[k][i];\n\t\t}\n\t\trep(i,m-1)cin>>W[n-1][i];\n\t\tT=dp=vvi(n,vi(m));\n\t\trep(i,n-1)rep(j,m)if(H[i][j]==0){\n\t\t\tH[i][j]=1;\n\t\t\t\n\t\t\trep(x,n)rep(y,m)T[x][y]=inf;\n\t\t\tT[n-1][m-1]=0;\n\t\t\tqueue<pii>q;\n\t\t\tq.push({n-1,m-1});\n\t\t\twhile(!q.empty()){\n\t\t\t\tpii t=q.front();\n\t\t\t\tq.pop();\n\t\t\t\trep(w,4){\n\t\t\t\t\tint x=t.first+dx[w];\n\t\t\t\t\tint y=t.second+dy[w];\n\t\t\t\t\tif(x<0||y<0||x>=n||y>=m)continue;\n\t\t\t\t\tif(w==0&&W[t.first][t.second])continue;\n\t\t\t\t\tif(w==1&&H[t.first][t.second])continue;\n\t\t\t\t\tif(w==2&&W[t.first][t.second-1])continue;\n\t\t\t\t\tif(w==3&&H[t.first-1][t.second])continue;\n\t\t\t\t\tif(T[x][y]>T[t.first][t.second]+1){\n\t\t\t\t\t\tT[x][y]=T[t.first][t.second]+1;\n\t\t\t\t\t\tq.push({x,y});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(x,n)rep(y,m)dp[x][y]=max(dp[x][y],T[x][y]);\n\t\t\tH[i][j]=0;\n\t\t}\n\t\trep(i,n)rep(j,m-1)if(W[i][j]==0){\n\t\t\tW[i][j]=1;\n\t\t\t\n\t\t\trep(x,n)rep(y,m)T[x][y]=inf;\n\t\t\tT[n-1][m-1]=0;\n\t\t\tqueue<pii>q;\n\t\t\tq.push({n-1,m-1});\n\t\t\twhile(!q.empty()){\n\t\t\t\tpii t=q.front();\n\t\t\t\tq.pop();\n\t\t\t\trep(w,4){\n\t\t\t\t\tint x=t.first+dx[w];\n\t\t\t\t\tint y=t.second+dy[w];\n\t\t\t\t\tif(x<0||y<0||x>=n||y>=m)continue;\n\t\t\t\t\tif(w==0&&W[t.first][t.second])continue;\n\t\t\t\t\tif(w==1&&H[t.first][t.second])continue;\n\t\t\t\t\tif(w==2&&W[t.first][t.second-1])continue;\n\t\t\t\t\tif(w==3&&H[t.first-1][t.second])continue;\n\t\t\t\t\tif(T[x][y]>T[t.first][t.second]+1){\n\t\t\t\t\t\tT[x][y]=T[t.first][t.second]+1;\n\t\t\t\t\t\tq.push({x,y});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(x,n)rep(y,m)dp[x][y]=max(dp[x][y],T[x][y]);\n\t\t\tW[i][j]=0;\n\t\t}\n\t\trep(i,n)rep(j,m)T[i][j]=inf;\n\t\tT[0][0]=dp[0][0];\n\t\tpriority_queue<tp>q;\n\t\tq.push(tp(0,0,0));\n\t\twhile(!q.empty()){\n\t\t\tint x,y,cost;\n\t\t\ttie(cost,x,y)=q.top();\n\t\t\tq.pop();\n\t\t\trep(w,4){\n\t\t\t\tint nx=x+dx[w];\n\t\t\t\tint ny=y+dy[w];\n\t\t\t\tif(nx<0||ny<0||nx>=n||ny>=m)continue;\n\t\t\t\tif(w==0&&W[x][y])continue;\n\t\t\t\tif(w==1&&H[x][y])continue;\n\t\t\t\tif(w==2&&W[x][y-1])continue;\n\t\t\t\tif(w==3&&H[x-1][y])continue;\n\t\t\t\tint ncost=max(T[x][y],cost+1+dp[nx][ny]);\n\t\t\t\tif(T[nx][ny]>ncost){\n\t\t\t\t\tT[nx][ny]=ncost;\n\t\t\t\t\tq.push(tp(cost+1,nx,ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tshow2d(dp);\n//\t\tshow2d(T);\n\t\tif(T[n-1][m-1]==inf)T[n-1][m-1]=-1;\n\t\tcout<<T[n-1][m-1]<<endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstdio>\n#include <cstring>\n#include <climits>\nusing namespace std;\n\nconst int dx[] = {0, 1, 0, -1}; //上右下左\nconst int dy[] = {-1, 0, 1, 0};\nconst int inf = 1<<20;\n\nint w,h;\nint path[4][33][33];\nint dp[2000][33][33]; // [step][y][x] 最悪でも2000は越えないだろう…\nstring field[70];\n\nstruct state{\n    int x,y;\n    int step;\n    int worstStep;\n    state(int _x, int _y, int s, int w){\n        x = _x;\n        y = _y;\n        step = s;\n        worstStep = w;\n    }\n    bool operator<(const state& a)const{\n        if( worstStep == a.worstStep ) return step > a.step;\n        return worstStep > a.worstStep;\n    }\n};\n\n\nint bfs(int sx, int sy){\n    int k;\n    int memo[33][33];\n    queue<pair<int,int> > q;\n\n    memset(memo, -1, sizeof(memo));\n    q.push(make_pair(sx,sy));\n    memo[sy][sx] = 0;\n\n    while( !q.empty() ){\n        int x = q.front().first;\n        int y = q.front().second;\n        int s = memo[y][x];\n        q.pop();\n\n        for(k=0; k<4; k++){\n            int tx = 2*x + dx[k];\n            int ty = 2*y + dy[k];\n            if( tx < 0 || tx >= 2*w-1 || ty >= 2*h-1 || ty < 0 ) continue;\n            if( field[ty][tx] == '1' ) continue;\n\n            if( memo[y + dy[k]][x + dx[k]] == -1 ){\n                memo[y + dy[k]][x + dx[k]] = s + 1;\n                q.push(make_pair(x + dx[k], y + dy[k]));\n            }\n        }\n    }\n\n    return memo[h-1][w-1];\n}\n\n\nvoid setBrokenDoorToAllShortestPath(){\n    int i,j,k;\n\n    // 通れなかった場所からの最短距離を全て記録する\n    for(i=0; i<h; i++){\n        for(j=0; j<w; j++){\n            for(k=0; k<4; k++){\n                int tx = 2*j + dx[k];\n                int ty = 2*i + dy[k];\n                if( tx < 0 || tx >= 2*w-1 || ty >= 2*h-1 || ty < 0 ) continue;\n                if( field[ty][tx] == '1' ) continue;\n                field[ty][tx] = '1';\n                path[k][i][j] = bfs(j, i);\n                field[ty][tx] = '0';\n            }\n        }\n    }\n}\n\n\n\nint main(){\n    int i,j,k;\n\n    while( cin >> h >> w, h|w ){\n        cin.ignore();\n\n        // input\n        for(i=0; i<2*h-1; i++){\n            getline(cin, field[i]);\n            if( i % 2 == 0 ) field[i] += \" \";\n        }\n\n        // init\n        for(k=0; k<2000; k++){\n            for(i=0; i<33; i++){\n                for(j=0; j<33; j++){\n                    dp[k][i][j] = inf;\n                }\n            }\n        }\n        memset(path, -1, sizeof(path));\n\n        setBrokenDoorToAllShortestPath();\n\n        priority_queue<state> q;\n        q.push(state(0,0,0,0));\n\n        while( !q.empty() ){\n            int x = q.top().x;\n            int y = q.top().y;\n            int step = q.top().step;\n            int wstep = q.top().worstStep;\n            q.pop();\n\n            if( wstep == inf || step > 1800 ) break;\n\n            if( dp[step][y][x] <= wstep ) continue;\n            dp[step][y][x] = wstep;\n\n            if( y == h-1 && x == w-1 ) break;\n\n            //cout << \"step = \" << step << \", q.size = \" << q.size() << endl;\n\n            for(k=0; k<4; k++){\n                int tx = 2*x + dx[k];\n                int ty = 2*y + dy[k];\n                if( tx < 0 || tx >= 2*w-1 || ty >= 2*h-1 || ty < 0 ) continue;\n                if( field[ty][tx] == '1' ) continue;\n                \n                // ドアが壊れてたときの計算\n                int nextWorstStep = inf;\n                if( path[k][y][x] != -1 ){\n                    nextWorstStep = step + path[k][y][x];\n                }\n                nextWorstStep = max(wstep, nextWorstStep);\n\n                if( dp[step + 1][y + dy[k]][x + dx[k]] > nextWorstStep ){\n                    q.push(state(x + dx[k], y + dy[k], step + 1, nextWorstStep));\n                }\n\n            }\n        }\n\n        int ans = inf;\n        for(k=0; k<2000; k++) ans = min(ans, dp[k][h-1][w-1]);\n\n        cout << (ans == inf ? -1 : ans) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reps(i,a,b) for(int i=(a); i<(b); ++i)\n#define rep(i,n) reps(i,0,n)\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nstruct UnionFind{\n\tstd::vector<int> data;\n\tUnionFind(int size): data(size, -1) {}\n\n\tbool unite(int x, int y){\n\t\tx=root(x);\n\t\ty=root(y);\n\t\tif( x != y ){\n\t\t\tif( data[y] < data[x] ) std::swap(x, y);\n\t\t\tdata[x] += data[y];\n\t\t\tdata[y] = x;\n\t\t}\n\t\treturn x!=y;\n\t}\n\n\tbool find(int x, int y){\n\t\treturn root(x) == root(y);\n\t}\n\n\tint root(int x){\n\t\treturn (data[x] < 0)? x : data[x]=root(data[x]);\n\t}\n\n\tint size(int x){\n\t\treturn -data[ root(x) ];\n\t}\n};\n\n// R, U, L, D\nconst int vx[]={1,0,-1,0}, vy[]={0,1,0,-1};\n\nconst ll INF = 1e9;\n\nint h, w;\nint ans;\nmap<pii,int> cost;\nvoid solve(map<pii,int> &mp, map<pii,int> &tb, int x, int y, int d){\n\tqueue<pair<pii,int>> que;\n\tque.push( {pii(x,y), d} );\n\ttb[pii(x,y)] = d;\n\twhile(!que.empty()){\n\t\tauto cur = que.front().X;\n\t\tint x = cur.X;\n\t\tint y = cur.Y;\n\t\tint d = que.front().Y;\n\t\tque.pop();\n\t\trep(k,4){\n\t\t\tint nx = x + vx[k];\n\t\t\tint ny = y + vy[k];\n\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n\t\t\tif( mp[cur] & (1<<k) ) continue;\n\t\t\tif( !tb.count(pii(nx,ny)) || tb[pii(nx,ny)] > d + 1 ){\n\t\t\t\ttb[pii(nx,ny)] = d + 1;\n\t\t\t\tque.push( {pii(nx,ny), d+1} );\n\t\t\t}\n\t\t}\n\t}\n\tif( !tb.count(pii(w-1,h-1)) ) tb[pii(w-1,h-1)] = INF;\n\tcost[pii(x,y)] = max(cost[pii(x,y)], tb[pii(w-1,h-1)]);\n}\n\nint main(){\n\twhile(cin >> h >> w, h|w){\n\t\tcost.clear();\n\t\tmap<pii,int> mp;\n\t\tint d;\n\t\trep(i,h-1){\n\t\t\trep(j,w-1){\n\t\t\t\tcin >> d;\n\t\t\t\tif( d == 1 ){\n\t\t\t\t\tmp[pii(j,i)]   |= (1<<0);\n\t\t\t\t\tmp[pii(j+1,i)] |= (1<<2);\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,w){\n\t\t\t\tcin >> d;\n\t\t\t\tif( d == 1 ){\n\t\t\t\t\tmp[pii(j,i)]   |= (1<<1);\n\t\t\t\t\tmp[pii(j,i+1)] |= (1<<3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint i = h-1;\n\t\trep(j,w-1){\n\t\t\tcin >> d;\n\t\t\tif( d == 1 ){\n\t\t\t\tmp[pii(j,i)]   |= (1<<0);\n\t\t\t\tmp[pii(j+1,i)] |= (1<<2);\n\t\t\t}\n\t\t}\n\t\trep(i,h) mp[pii(0,i)]   |= (1<<2);\n\t\trep(i,h) mp[pii(w-1,i)] |= (1<<0);\n\t\trep(i,w) mp[pii(i,0)]   |= (1<<3);\n\t\trep(i,w) mp[pii(i,h-1)] |= (1<<1);\n\n\t\tmap<pii,int> tb_s;\n\t\tsolve(mp, tb_s, 0, 0, 0);\n\t\tans = 0;\n//\t\trep(i,h){\n//\t\t\trep(j,w) cout << tb_s[pii(j,i)] << \" \";\n//\t\t\tcout << endl;\n//\t\t}\n\n\t\trep(k,4) rep(y,h) rep(x,w){\n\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n\t\t\tint nx = x + vx[k];\n\t\t\tint ny = y + vy[k];\n\t\t\tauto mp1 = mp;\n\t\t\tmp1[pii(x,y)]   |= (1<<k);\n\t\t\tmp1[pii(nx,ny)] |= (1<<((k+2)%4));\n\t\t\tmap<pii,int> tb;\n\t\t\t//solve(mp1, tb, x, y, tb_s[pii(x,y)]);\n\t\t\tsolve(mp1, tb, x, y, 0);\n\t\t\t//cout << \"solve: \" << x << \" \" << y << \" k=\" << k << endl;\n\t\t\t//rep(i,h){\n\t\t\t//\trep(j,w) cout << tb[pii(j,i)] << \" \";\n\t\t\t//\tcout << endl;\n\t\t\t//}\n\t\t}\n\n//\t\tcout << \"cost:\" << endl;\n//\t\trep(i,h){\n//\t\t\trep(j,w) cout << (cost[pii(j,i)]==INF ? 99 : cost[pii(j,i)]) << \" \";\n//\t\t\tcout << endl;\n//\t\t}\n\n\t\ttypedef pair<pii,pii> PII;\n\t\tpriority_queue<PII, vector<PII>, greater<PII>> que;\n\t\tmap<pii,pii> memo;\n\t\tque.push({{cost[pii(0,0)],0},pii(0,0)});\n\t\twhile(!que.empty()){\n\t\t\tint c = que.top().X.X;\n\t\t\tint d = que.top().X.Y;\n\t\t\tint x = que.top().Y.X;\n\t\t\tint y = que.top().Y.Y;\n\t\t\tque.pop();\n\t\t\t//if( memo.count(pii(x,y)) && memo[pii(x,y)] < pii(c,d) ) continue;\n\t\t\tif( memo.count(pii(x,y)) ) continue;\n\t\t\tmemo[pii(x,y)] = pii(c,d);\n\t\t\trep(k,4){\n\t\t\t\tint nx = x + vx[k];\n\t\t\t\tint ny = y + vy[k];\n\t\t\t\tint nc = d + 1 + cost[pii(nx,ny)];\n\t\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n\t\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n\t\t\t\tif( !memo.count(pii(nx,ny)) || memo[pii(nx,ny)] > pii(nc,d+1) ){\n\t\t\t\t\t//memo[pii(nx,ny)] = pii(nc, d+1);\n\t\t\t\t\tque.push( {pii(nc, d+1), pii(nx, ny)} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tpii pos = {w-1,h-1};\n//\t\tans = max(ans, memo[pos].X);\n//\t\twhile( pos != pii(0,0) ){\n//\t\t\tint x = pos.X;\n//\t\t\tint y = pos.Y;\n//\t\t\trep(k,4){\n//\t\t\t\tint nx = x + vx[k];\n//\t\t\t\tint ny = y + vy[k];\n//\t\t\t\tint nc = d + 1 + cost[pii(nx,ny)];\n//\t\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n//\t\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n//\t\t\t\tif( memo.count(pii(nx,ny)) && memo[pii(nx,ny)].Y < memo[pos].Y ){\n//\t\t\t\t\tpos = pii(nx,ny);\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tans = max(ans, memo[pos].X);\n//\t\t}\n\n\t\tmultimap<int, pii> order;\n\t\tfor(auto t: memo) order.insert({ t.Y.X, t.X });\n\t\tUnionFind uf(3000);\n\t\tfor(auto t: order){\n\t\t\tint x = t.Y.X;\n\t\t\tint y = t.Y.Y;\n\t\t\trep(k,4){\n\t\t\t\tint nx = x + vx[k];\n\t\t\t\tint ny = y + vy[k];\n\t\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n\t\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n\t\t\t\tif( memo[pii(nx,ny)].X <= t.X ){\n\t\t\t\t\tuf.unite( nx+ny*w, x+y*w );\n\t\t\t\t}\n\t\t\t}\n//\t\t\tcout << \"order: \" << x << \" \" << y << \" \" << t.X << endl;\n\t\t\tif( uf.find(0, (w-1)+(h-1)*w ) ){\n\t\t\t\tans = t.X;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcout << (ans >= INF ? -1 : ans) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl;\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl;\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl;\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl;\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl;\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl;\n#define double long double\nusing namespace std;\nconst int INF = 1e9;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\nconst int N = 50;\nint h,w;\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\nint G[N][N][4];\nint in(int x,int y){return !(x < 0 || y < 0 || x >= w || y >= h);}\n\nint dis[N][N][N][N][4]; //goalからの距離\nvoid bfs(int sy,int sx){\n  memset(dis,-1,sizeof(dis));\n  typedef tuple<int,int,int,int,int,int> T; // y, x, by, bx, dir, cost\n  queue<T> Q;\n  \n  //broken door\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<4;k++){\n        dis[sy][sx][i][j][k] = 0;\n        Q.push(T(sy,sx,i,j,k,0));\n      }\n  \n  while(!Q.empty()){\n    int y, x, by, bx, dir, cost;\n    tie(y, x, by, bx, dir, cost) = Q.front(); Q.pop();\n    \n    for(int i=0;i<4;i++){\n      int ny = y + dy[i];\n      int nx = x + dx[i];\n      int ncost = cost + 1;\n      if(!in(nx,ny) || G[y][x][i] == 0 || dis[ny][nx][by][bx][dir] != -1) continue;\n      if(x == bx && y == by && i == dir) continue;\n      if(nx == bx && ny == by && i == (dir+2)%4) continue;\n      dis[ny][nx][by][bx][dir] = ncost;\n      Q.push(T(ny,nx,by,bx,dir,ncost));\n    }\n  }\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<h;k++)\n        for(int l=0;l<w;l++)\n          for(int m=0;m<4;m++) if(dis[i][j][k][l][m] == -1) dis[i][j][k][l][m] = INF;\n}\n\nint calcCost(int y,int x,int d,int dir){\n  if(!in(x,y)) return INF;\n  int res = INF;\n  Min(res, d + dis[y][x][y][x][dir]);\n  return res;\n}\n\nint D[N][N][N*N], visited[N][N][N*N];\nint dijkstra(int sy,int sx){\n  typedef tuple<int,int,int,int> T; //cost, y, x, distance;\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<=h*w;k++) D[i][j][k] = INF, visited[i][j][k] = 0;\n  \n  priority_queue<T,vector<T>,greater<T> > Q;\n  Q.push(T(0,sy,sx,0));\n  D[sy][sx][0] = 0;\n\n  int res = INF;\n  while(!Q.empty()){\n    int cost, y, x, d;\n    tie(cost,y, x, d) = Q.top(); Q.pop();\n    if(visited[y][x][d]++) continue;\n    if(x == w-1 && y == h-1) {\n      Min(res, max(cost, d));\n      continue;\n    }\n\n    for(int i=0;i<4;i++){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      int nd = d + 1;\n      int a = cost;\n      int b = calcCost(y, x, d, i);\n      int ncost = max(a, b);\n      if(!in(nx,ny) || G[y][x][i] == 0 || D[ny][nx][nd] <= ncost) continue;\n      D[ny][nx][nd] = ncost;\n      Q.push(T(ncost,ny,nx,nd));\n    }\n  }\n  if(res == INF) return -1;\n  return res;\n}\n\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(1){\n    cin>>h>>w;\n    if(h == 0 && w == 0) break;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++)\n        for(int k=0;k<4;k++) G[i][j][k] = 1;\n\n    for(int i=0;i<h*2-1;i++){\n      for(int j=0;j<w - !(i%2);j++){\n        int ng;\n        cin>>ng;\n        int x = j, y = i/2;\n        if(i%2 == 0 && ng) G[y][x][1] = G[y][x+1][3] = 0;\n        if(i%2 == 1 && ng) G[y][x][2] = G[y+1][x][0] = 0;\n      }\n    }\n\n    bfs(h-1, w-1);\n    \n    int ans = dijkstra(0, 0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\nvector<string> line;\n\nstruct NODE{\n\tint id,cost,maximum;\n\tNODE(int id,int cost,int maximum) : id(id),cost(cost),maximum(maximum){}\n};\n\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.maximum > b.maximum;\n}\n\nint tmp[100][100];\nint XX[1000],YY[1000];\nint sz = 0;\nint id(int x,int y){\n\tif( tmp[x][y] != -1 ) return tmp[x][y];\n\tXX[sz] = x;\n\tYY[sz] = y;\n\treturn tmp[x][y] = sz++;\n}\n\nint X(int id){ return XX[id]; }\nint Y(int id){ return YY[id]; }\n\nint dx[] = { 0, 1, 0,-1};\nint dy[] = { 1, 0,-1, 0};\n\n\nint done[910]={};\n\nint main(){\n\tmemset(tmp,-1,sizeof(tmp));\n\tint H,W;\n\twhile(cin >> H >> W && H){\n\t\tint s = id(0,0);\n\t\tint g = id(2*W-2,2*H-2);\n\t\t\n\t\tline = vector<string>(H*2-1);\n\t\tgetline(cin,line[0]); //dummy\n\t\tfor(int i = 0 ; i < H*2-1 ; i++){\n\t\t\tgetline(cin,line[i]);\n\t\t\tif(!(i&1))line[i] += \" \";\n\t\t}\n\t\t\n\t\tint dir[62][62][2];\n\t\tfor(int i = 0 ; i < 62 ; i++)\n\t\t\tfor(int j = 0 ; j < 62 ; j++)\n\t\t\t\tfor(int k = 0 ; k < 2 ; k++)\n\t\t\t\t\tdir[i][j][k] = 1e9;\n\t\n\t\tint maximum = 0;\n\t\tfor(int y = 0 ; y < 2*H-1 ; y++){\n\t\t\tfor(int x = 0 ; x < 2*W ; x++){\n\t\t\t\tif( line[y][x] != '0' ) continue;\n\t\t\t\tline[y][x] = '1';\n\t\t\t\tint c1,c2;\n\t\t\t\tif( y % 2 == 0 ){\n\t\t\t\t\tc1 = id(x-1,y);\n\t\t\t\t\tc2 = id(x+1,y);\n\t\t\t\t}else{\n\t\t\t\t\tc1 = id(x,y-1);\n\t\t\t\t\tc2 = id(x,y+1);\n\t\t\t\t}\n\t\t\t\tfor(int k = 0 ; k < 2 ; k++){\n\t\t\t\t\t// test\n\t\t\t\t\tint tmp[910];\n\t\t\t\t\tmemset(tmp,-1,sizeof(tmp));\n\t\t\t\t\tqueue<int> Q;\n\t\t\t\t\ttmp[c1] = 0;\n\t\t\t\t\tQ.push(c1);\n\t\t\t\t\twhile(Q.size()){\n\t\t\t\t\t\tint q = Q.front(); Q.pop();\n\t\t\t\t\t\tfor(int i = 0 ; i < 4 ; i++){\n\t\t\t\t\t\t\tint tx = X(q) + dx[i];\n\t\t\t\t\t\t\tint ty = Y(q) + dy[i];\n\t\t\t\t\t\t\tif( tx < 0 || tx >= line[0].size() || ty < 0 || ty >= line.size() || line[ty][tx] == '1') continue;\n\t\t\t\t\t\t\tint next = id(tx+dx[i],ty+dy[i]);\n\t\t\t\t\t\t\tif( tmp[next] == -1 ){\n\t\t\t\t\t\t\t\ttmp[next]=tmp[q]+1;\n\t\t\t\t\t\t\t\tQ.push(next);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif( tmp[g] != -1 ) \n\t\t\t\t\t\tdir[y][x][k] = tmp[g];\n\t\t\t\t\tswap(c1,c2);\n\t\t\t\t}\n\t\t\t\tline[y][x] = '0';\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < 910 ; i++)\n\t\t\tdone[i] = 1e9;\n\t\t\n\t\tpriority_queue<NODE> Q;\n\t\t\n\t\tQ.push(NODE(s,0,0));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\t\n\t\t\t\n\t\t\tif( q.cost > 905 ){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( done[q.id] < q.cost+q.maximum ) continue;\n\t\t\tdone[q.id] = q.cost+q.maximum;\n\t\t\t\n\t\t\tif( q.maximum > 1e8 ) continue;\n\t\t\tif( q.id == g ){\n\t\t\t\tcout << q.maximum << endl;\n\t\t\t\tgoto veryok;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < 4 ; i++){\n\t\t\t\tint tx = X(q.id) + dx[i];\n\t\t\t\tint ty = Y(q.id) + dy[i];\n\t\t\t\tif( tx < 0 || tx >= line[0].size() || ty < 0 || ty >= line.size() || line[ty][tx] == '1') continue;\n\t\t\t\tint next = id(tx+dx[i],ty+dy[i]);\n\t\t\t\tint cost = q.cost + 1;\n\t\t\t\tint maximum = q.cost;\n\t\t\t\tif( ty % 2 == 0 ){\n\t\t\t\t\tif( dx[i] == 1 ) maximum += dir[ty][tx][0];\n\t\t\t\t\telse \t\t\t maximum += dir[ty][tx][1];\n\t\t\t\t}else{\n\t\t\t\t\tif( dy[i] == 1 ) maximum += dir[ty][tx][0];\n\t\t\t\t\telse \t\t\t maximum += dir[ty][tx][1];\n\t\t\t\t}\n\t\t\t\tif( cost+max(q.maximum,maximum) >= done[next] ) continue;\n\t\t\t\tdone[next] = cost+max(q.maximum,maximum);\n\t\t\t\tQ.push(NODE(next,cost,max(q.maximum,maximum)));\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\tveryok:;\n\t\t/*\n\t\tcout << 2*H-1 << \" \" << 2*W-1 << endl;\n\t\tcout << shortest[id(2*H-1,2*W-1)] << endl;\n\t\t\n\t\tfor(int i = 0 ; i < 2*H-1 ; i++){\n\t\t\tfor(int j = 0 ; j < 2*W ; j++){\n\t\t\t\tif( shortest[id(j,i)] == -1 ) printf(\"     \");\n\t\t\t\telse  printf(\"%5d(%d,%d)\",shortest[id(j,i)],j,i);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <utility>\n#define INF 2000\nusing namespace std;\ntypedef pair<int,int> P;\n\nstruct data{\n\tint x,y,c,dc;\n\tdata(int xx,int yy,int cc,int dd){\n\t\tx=xx;\n\t\ty=yy;\n\t\tc=cc;\n\t\tdc=dd;\n\t}\n\n\tbool operator<(const data& d1)const{\n\t\treturn d1.dc<dc;\n\t}\n};\n\nint h,w;\n\nint fie[61][61];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint dp[61][61][901];\nint cost[61][61][4];\nint used[61][61];\n\nint bfs(int sx,int sy){\n\tqueue<P> que;\n\tque.push(P(sx,sy));\n\tmemset(used,-1,sizeof(used));\n\tused[sx][sy]=0;\n\twhile(que.size()){\n\t\tP q=que.front();\n\t\tque.pop();\n\t\tint x=q.first,y=q.second;\n\t\tif(x==(w-1)*2 && y==(h-1)*2)return used[x][y];\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\tif(nx>=0 && nx<w*2-1 && ny>=0 && ny<h*2-1){\n\t\t\t\tif(fie[nx][ny]==1)continue;\n\t\t\t\tnx+=dx[i];\n\t\t\t\tny+=dy[i];\n\t\t\t\tif(used[nx][ny]==-1){\n\t\t\t\t\tused[nx][ny]=used[x][y]+1;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn INF;\n}\n\nint dijk(){\n\tpriority_queue<data> que;\n\tque.push(data(0,0,0,0));\n\tfor(int i=0;i<=60;i++){\n\t\tfor(int j=0;j<=60;j++){\n\t\t\tfor(int k=0;k<=900;k++){\n\t\t\t\tdp[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tque.push(data(0,0,0,0));\n\tdp[0][0][0]=0;\n\twhile(que.size()){\n\t\tdata d=que.top();\n\t\tque.pop();\n\t\tif(dp[d.x][d.y][d.c]!=d.dc)continue;\n\t\tif(d.x==(w-1)*2 && d.y==(h-1)*2)return d.dc;\n\t\t//printf(\"%d %d %d %d\\n\",d.x,d.y,d.c,d.dc);\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(cost[d.x][d.y][i]==INF)continue;\n\t\t\tint nx=d.x+dx[i]*2,ny=d.y+dy[i]*2;\n\t\t\tif(nx>=0 && nx<w*2-1 && ny>=0 && ny<h*2-1){\n\t\t\t\tif(fie[nx-dx[i]][ny-dy[i]]==1)continue;\n\t\t\t\tint ndc=max(d.dc,cost[d.x][d.y][i]+d.c);\n\t\t\t\tif(dp[nx][ny][d.c+1]>ndc && d.c<900){\n\t\t\t\t\tdp[nx][ny][d.c+1]=ndc;\n\t\t\t\t\tque.push(data(nx,ny,d.c+1,ndc));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tif(h==0 && w==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<2*h-1;i++){\n\t\t\tif(i%2==0){\n\t\t\t\tfor(int j=0;j<w-1;j++){\n\t\t\t\t\tscanf(\"%d\",&fie[j*2+1][i]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tscanf(\"%d\",&fie[j*2][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<2*h-1;i+=2){\n\t\t\tfor(int j=0;j<w*2-1;j+=2){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint x=j+dx[k],y=i+dy[k];\n\t\t\t\t\tif(x>=0 && x<w*2-1 && y>=0 && y<w*2-1){\n\t\t\t\t\t\tif(fie[x][y]==0){\n\t\t\t\t\t\t\tfie[x][y]=1;\n\t\t\t\t\t\t\tcost[j][i][k]=bfs(j,i);\n\t\t\t\t\t\t\tfie[x][y]=0;\n\t\t\t\t\t\t}else cost[j][i][k]=INF;\n\t\t\t\t\t}else cost[j][i][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<tuple>\n#include<map>\n#include<vector>\n\nusing namespace std;\n\nstruct S{\n  int y,x,c,s;\n  bool operator<(S p)const{\n    return c>p.c;\n  }\n};\n\nint h,w;\n\nbool valid(int y,int x){\n  return 0<=y&&y<h&&0<=x&&x<w;\n}\n\nmap<tuple<int,int,int,int>,int> mem;\n\nint bfs(int sy,int sx,int ty,int tx,map<tuple<int,int,int,int>,int> m){\n  auto t=make_tuple(sy,sx,ty,tx);\n  if(mem.count(t))return mem[t];\n  m[make_tuple(sy,sx,ty,tx)]=1;\n  m[make_tuple(ty,tx,sy,sx)]=1;\n  bool p[30][30]={};\n  vector<tuple<int,int> > v[1000];\n  v[0].emplace_back(sy,sx);\n  for(int i=0;i<1000;i++){\n    for(auto &f:v[i]){\n      int y=get<0>(f);\n      int x=get<1>(f);\n      if(y==h-1&&x==w-1)return mem[t]=i;\n      if(p[y][x]++)continue;\n      for(int j=0;j<4;j++){\n\tstatic int d[]={0,-1,0,1,0};\n\tint ny=y+d[j];\n\tint nx=x+d[j+1];\n\tif(valid(ny,nx)&&m[make_tuple(y,x,ny,nx)]==0){\n\t  v[i+1].emplace_back(ny,nx);\n\t}\n      }\n    }\n  }\n  return mem[t]=-1;\n}\n\nint main(){\n  while(cin>>h>>w,h){\n    mem.clear();\n    map<tuple<int,int,int,int>,int> m;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w-1;j++){\n\tint d;\n\tcin>>d;\n\tm[make_tuple(i,j,i,j+1)]=d;\n\tm[make_tuple(i,j+1,i,j)]=d;\n      }\n      if(i<h-1){\n\tfor(int j=0;j<w;j++){\n\t  int d;\n\t  cin>>d;\n\t  m[make_tuple(i,j,i+1,j)]=d;\n\t  m[make_tuple(i+1,j,i,j)]=d;\n\t}\n      }\n    }\n    int p[30][30];\n    const int INF=1<<29;\n    fill(p[0],p[30],INF);\n    priority_queue<S> que;\n    que.push({0,0,0,0});\n    while(!que.empty()){\n      S cs=que.top();\n      que.pop();\n      if(p[cs.y][cs.x]<=cs.s)continue;\n      p[cs.y][cs.x]=cs.s;\n      for(int i=0;i<4;i++){\n\tstatic int d[]={0,-1,0,1,0};\n\tint ny=cs.y+d[i];\n\tint nx=cs.x+d[i+1];\n\tif(valid(ny,nx)&&m[make_tuple(cs.y,cs.x,ny,nx)]==0){\n\t  int r=bfs(cs.y,cs.x,ny,nx,m);\n\t  if(r>0){\n\t    que.push({ny,nx,cs.c+1,max(cs.c+r,cs.s)});\n\t  }\n\t}\n      }\n    }\n    cout<<((p[h-1][w-1]==INF)?-1:p[h-1][w-1])<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#ifdef DEBUG_MODE\n    #define DBG(n) n;\n#else\n    #define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n \ntypedef long long ll;\ntypedef pair<pair<int,int>,int> P;\nint h,w;\npair<int,int> dp[33*33];\nint dist[33*33];\nint memo[33*33];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nvector<vector<int>> v(33*33);\n \nint fun(int a,int b){\n    REP(i,33*33)dist[i] = INF;\n    dist[a] = 0;\n    queue<pair<int,int>> q;\n    q.push(MP(a,0));\n    while(!q.empty()){\n        pair<int,int> now = q.front();q.pop();\n        int node = now.FI;\n        int kyo = now.SE;\n        if(kyo > dist[node])continue;\n        REP(i,v[node].size()){\n            int aite = v[node][i];\n            if((node == a && aite == b) || (node == b && aite == a))continue;\n            if(dist[aite] > kyo + 1){\n                dist[aite] = kyo + 1;\n                q.push(MP(aite,kyo+1));\n            }\n        }\n    }\n    return dist[h*w-1];\n}\n \nint main()\n{\n    while(cin >> h >> w,h|w){\n        //初期化\n        REP(i,33*33)dp[i] = MP(INF,INF);\n        REP(i,33*33){v[i].clear();}\n        dp[0] = MP(0,0);\n         \n        //入力\n        REP(i,h){\n            REP(j,w-1){\n                int tmp;cin >> tmp;\n                if(tmp == 0){\n                    v[i*w+j].PB(i*w+j+1);\n                    v[i*w+j+1].PB(i*w+j);\n                }\n                 \n            }\n            if(i != h-1)REP(j,w){\n                int tmp;cin >> tmp;\n                if(tmp == 0){\n                    v[i*w+j].PB((i+1)*w+j);\n                    v[(i+1)*w+j].PB(i*w+j);\n                }\n            }\n        }\n        fun(0,-1);\n\t\tREP(i,33*33)memo[i] = dist[i];\n        priority_queue<P,vector<P>,greater<P>> q;\n        q.push(MP(MP(0,-1),0));\n        DBG(cout << \"!\" << endl;);\n        while(!q.empty()){\n            DBG(\n            cout << \"DP TABLE\" << endl;\n            REP(i,h){\n                REP(j,w){\n                    cout << dp[i*w+j].FI << ' ';\n                }\n                cout << endl;\n            }\n            )\n            P now = q.top();q.pop();\n            int node = now.SE;\n            pair<int,int> kyori = now.FI;\n\t\t\tDBG(cout << \"STATUS\" << endl;)\n            DBG(cout << kyori.FI << ' ' << kyori.SE << endl;)\n            kyori.SE++;\n            DBG(cout << dp[node].FI << ' ' << dp[node].SE << endl;)\n            if(dp[node].FI < kyori.FI && memo[node] < kyori.SE)continue;\n            REP(i,v[node].size()){\n                int aite = v[node][i];\n                pair<int,int> score = MP(fun(node,aite)+kyori.SE,kyori.SE);\n                pair<int,int> seica = max(dp[node],score);\n                if(dp[aite] > seica || dp[aite].SE > score.SE){\n\t\t\t\t\tif(dp[aite] > seica)dp[aite] = seica;\n                    q.push(MP(score,aite));\n                }\n            }\n        }\n         \n        DBG(\n        cout << \"DP TABLE\" << endl;\n        REP(i,h){\n            REP(j,w){\n                cout << dp[i*w+j].FI << ' ';\n            }\n            cout << endl;\n        }\n        )\n         \n        DBG(cout << \"ANS IS \";);\n         \n        if(dp[h*w-1].FI == INF){\n            cout << -1 << endl;\n        }\n        else{\n            cout << dp[h*w-1].FI << endl;\n        }\n    }\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing graph = vector<set<int>>;\n\nconst int INF = 1e9;\n\nvector<int> bfs(const graph& G, int s) {\n\tconst int n = G.size();\n\tvector<int> d(n, INF);\n\tqueue<int> q;\n\td[s] = 0;\n\tq.push(s);\n\twhile (!q.empty()) {\n\t\tauto v = q.front(); q.pop();\n\t\tfor (auto to : G[v]) if (d[to] == INF) {\n\t\t\td[to] = d[v] + 1;\n\t\t\tq.push(to);\n\t\t}\n\t}\n\treturn d;\n}\n\nstruct edge {\n\tint to, cost;\n\tedge(int t, int c) : to(t), cost(c) {}\n};\n\nvector<int> dijkstra(const vector<vector<edge>>& G, int s, vector<int>& pre) {\n\tconst int n = G.size();\n\tvector<int> d(n, INF);\n\tusing pii = tuple<int, int, int>;\n\tpriority_queue<pii, vector<pii>, greater<pii>> pq;\n\tpq.emplace(0, s, -1);\n\twhile (!pq.empty()) {\n\t\tint dist, v, pv;\n\t\ttie(dist, v, pv) = pq.top(); pq.pop();\n\t\tif (d[v] != INF) continue;\n\t\tpre[v] = pv;\n\t\td[v] = dist;\n\t\tfor (auto& e : G[v]) if (d[e.to] == INF) {\n\t\t\tpq.emplace(max(dist, e.cost), e.to, v);\n\t\t}\n\t}\n\treturn d;\n}\n\nint main()\n{\n\tint h, w;\n\twhile (cin >> h >> w, h | w) {\n\t\tint s = 0, g = h * w - 1;\n\t\tgraph G(h * w);\n\t\tvector<vector<int>> gg(h * w);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 1; j < w; j++) {\n\t\t\t\tint b;\n\t\t\t\tcin >> b;\n\t\t\t\tif (!b) {\n\t\t\t\t\tint u = i * w + j - 1, v = i * w + j;\n\t\t\t\t\tG[u].insert(v);\n\t\t\t\t\tG[v].insert(u);\n\t\t\t\t\tgg[u].push_back(v);\n\t\t\t\t\tgg[v].push_back(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == h - 1) continue;\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tint b;\n\t\t\t\tcin >> b;\n\t\t\t\tif (!b) {\n\t\t\t\t\tint u = i * w + j, v = (i + 1) * w + j;\n\t\t\t\t\tG[u].insert(v);\n\t\t\t\t\tG[v].insert(u);\n\t\t\t\t\tgg[u].push_back(v);\n\t\t\t\t\tgg[v].push_back(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> d(h * w, INF);\n\t\tvector<int> dist(h * w, INF);\n\t\tusing pii = tuple<int, int, int>;\n\t\tpriority_queue<pii, vector<pii>, greater<pii>> pq;\n\t\tpq.emplace(0, 0, s);\n\t\twhile (!pq.empty()) {\n\t\t\tint td1, td2, v;\n\t\t\ttie(td1, td2, v) = pq.top(); pq.pop();\n\t\t\tif (d[v] != INF) continue;\n\t\t\td[v] = td1;\n\t\t\tdist[v] = td2;\n\t\t\tfor (auto& u : gg[v]) if (d[u] == INF) {\n\t\t\t\tG[u].erase(v);\n\t\t\t\tG[v].erase(u);\n\t\t\t\tauto d1 = bfs(G, g);\n\t\t\t\tif (d1[u] != INF) {\n\t\t\t\t\tpq.emplace(max(d[v], dist[v] + d1[v]), dist[v] + 1, u);\n\t\t\t\t}\n\t\t\t\tG[u].insert(v);\n\t\t\t\tG[v].insert(u);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcout << d[i * w + j] << \" \\n\"[j + 1 == w];\n\t\t\t}\n\t\t}\n\t\tcout << (d[g] < INF ? d[g] : -1) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\nclass State {\npublic:\n  int x;\n  int y;\n  int cost;\n  State(int x,int y,int cost)\n    : x(x), y(y), cost(cost) {}\n  bool operator<(const State& s) const {\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const {\n    return cost > s.cost;\n  }\n};\n\nbool walls[51][51][51][51];\nint mid2goal_cost[51][51][4];\n\nvoid compute_mid2goal_cost(int H,int W){\n\n  memset(mid2goal_cost,0x3f,sizeof(mid2goal_cost));\n\n  for(int sy = 0; sy < H; sy++){\n    for(int sx = 0; sx < W; sx++){\n      for(int dir = 0; dir < 4; dir++){\n        int tmp_mid2goal_cost[51][51];\n        memset(tmp_mid2goal_cost,0x3f,sizeof(tmp_mid2goal_cost));\n        priority_queue<State,vector<State>,greater<State> > que;\n        que.push(State(sx,sy,0));\n        tmp_mid2goal_cost[sy][sx] = 0;\n        while(!que.empty()){\n          State s = que.top();\n          que.pop();\n          \n          for(int i = 0; i < 4; i++){\n            int dx = tx[i] + s.x;\n            int dy = ty[i] + s.y;\n            if(dx >= W || dy >= H || dx < 0 || dy < 0) continue;\n            if(walls[s.y][s.x][dy][dx]) continue;\n            if(s.x == sx && s.y == sy && dir == i) continue;\n            if(tmp_mid2goal_cost[dy][dx] <= s.cost + 1) continue;\n            tmp_mid2goal_cost[dy][dx] = s.cost + 1;\n            que.push(State(dx,dy,s.cost + 1));\n          }\n        }\n\n        mid2goal_cost[sy][sx][dir] = tmp_mid2goal_cost[H-1][W-1];\n      }\n    }\n  } \n}\n\n\nint compute_start2goal_cost(int H,int W){\n  compute_mid2goal_cost(H,W);\n\n  int goal2start_cost[51][51];\n  memset(goal2start_cost,0x3f,sizeof(goal2start_cost));\n\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(W-1,H-1,0));\n  goal2start_cost[H-1][W-1] = 0;\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    for(int i = 0; i < 4; i++){\n      int dx = tx[i] + s.x;\n      int dy = ty[i] + s.y;\n      if(dx >= W || dy >= H || dx < 0 || dy < 0) continue;\n      if(walls[s.y][s.x][dy][dx]) continue;\n      if(goal2start_cost[dy][dx] <= max(s.cost + 1,mid2goal_cost[dy][dx][(i+2)%4])) continue;\n      goal2start_cost[dy][dx] = max(s.cost + 1,mid2goal_cost[dy][dx][(i+2)%4]);\n      que.push(State(dx,dy,max(s.cost + 1,mid2goal_cost[dy][dx][(i+2)%4])));\n    }\n  }\n  return (goal2start_cost[0][0] >= INF ? -1 : goal2start_cost[0][0]);\n}\n\nint main(){\n  int H,W;\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    if(H == 0 && W == 0) break;\n    memset(walls,false,sizeof(walls));\n\n    int patterns[] = {W - 1, W};\n    int accumulate[61] = {};\n    for(int i = 0; i < 60; i++){\n      accumulate[i + 1] = patterns[i % 2] + accumulate[i];\n    }\n\n    int pos = 0;\n    while(pos < ((H - 1) * W) + (H * (W - 1))){\n      int flag;\n      scanf(\"%d\",&flag);\n      int depth = (lower_bound(accumulate,accumulate + 61,pos+1) - accumulate);\n      int type = (depth-1) % 2;\n      if(type == 0){\n        int from_y = (depth - 1)/2;\n        int from_x = pos - accumulate[depth - 1];\n        int to_y = (depth - 1)/2;\n        int to_x = pos - accumulate[depth - 1] + 1;\n        walls[from_y][from_x][to_y][to_x] = (flag == 1 ? true : false);\n        walls[to_y][to_x][from_y][from_x] = (flag == 1 ? true : false);\n      }\n      else{\n        int from_y = (depth-1)/2;\n        int from_x = pos - accumulate[depth - 1];\n        int to_y = (depth-1)/2 + 1;\n        int to_x = pos - accumulate[depth - 1];\n        walls[from_y][from_x][to_y][to_x] = (flag == 1 ? true : false);\n        walls[to_y][to_x][from_y][from_x] = (flag == 1 ? true : false);\n      }\n      pos++;\n    }\n    printf(\"%d\\n\",compute_start2goal_cost(H,W));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <set>\n#include <map>\n#include <stack>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n \nusing namespace std;\n \n#define ll long long\n#define pi pair<int,int>\n#define pll pair<ll,ll>\n#define pii pair<int,pi>\n#define X first\n#define Y second\n#define pb push_back\n#define ab(x) ((x)<0?(-(x)):(x))\n#define xx(x) ((x)*(x))\n#define mp make_pair\n#define vi vector<int>\n#define vll vector<ll>\n#define vs vector<string>\n#define vpi vector<pi>\n#define vpll vector<pll>\n#define ALL(x) (x).begin(),(x).end()\n#define Max (1<<30)\n#define LLMax (1ll<<60)\ntemplate<class T>string ToString(T t){stringstream s;s<<t;return s.str();}\ntemplate<class T>void ToOther(T&t,string a){stringstream s(a);s>>t;}\n \n\nint h,w;\nvi v[1005];\nvi c[1005];\nint wh[55][55];\nint E=0;\nvpi ed;\nint d[1005];\nint tt[2][2005];\nint ttt[3005];\nint dis[1005];\n\nvoid add(int x,int y){\n\tv[x].pb(y);v[y].pb(x);\n\t\n\tc[x].pb(ed.size());\n\tc[y].pb(ed.size());\n\n\ted.pb( pi(x,y) );\n}\n\n\n\nvoid di(int st,int no,int d[1005]){\n\tif(no==3){\n\t\tst=st;\n\t}\n\tpriority_queue< pi , vector<pi> , greater<pi> > q;\n\tq.push( pi(0,st) );\n\td[st]=0;\n\n\twhile(q.size()){\n\t\tint k=q.top().Y;\n\t\tint dis=q.top().X; q.pop();\n\n\t\tif(d[k]<dis)continue;\n\n\t\tfor(int i=0;i<v[k].size();i++)if(c[k][i]!=no){\n\t\t\tint t=v[k][i];\n\n\t\t\tif(d[t]>dis+1){\n\t\t\t\td[t]=dis+1;\n\t\t\t\tq.push( pi(d[t],t) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\t//freopen(\"input.txt\",\"r\",stdin);\n\twhile(cin>>h>>w,h){\n\t\tE=0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)wh[i][j]=E++;\n\n\t\tfor(int i=0;i<h*2-1;i++){\n\t\t\tint y=i/2;\n\t\t\tif(i%2==0){\n\t\t\t\tfor(int j=0;j<w-1;j++){\n\t\t\t\t\tint k;cin>>k;\n\t\t\t\t\tif(k==0)add(wh[y][j],wh[y][j+1]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tint k;cin>>k;\n\t\t\t\t\tif(k==0)add(wh[y][j],wh[y+1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tmemset(ttt,-1,sizeof(ttt));\n\n\t\tfor(int i=0;i<ed.size();i++){\n\t\t\tmemset(dis,63,sizeof(dis));\n\t\t\t\n\t\t\tif(ed[i].X==5){\n\t\t\t\ti=i;\n\t\t\t}\n\n\t\t\tdi(ed[i].X,i,dis);\n\t\t\tttt[ed[i].X]=max(ttt[ed[i].X],dis[E-1]);\n\n\t\t\tif(ed[i].Y==5){\n\t\t\t\ti=i;\n\t\t\t}\n\n\t\t\tmemset(dis,63,sizeof(dis));\n\t\t\tdi(ed[i].Y,i,dis);\n\t\t\tttt[ed[i].Y]=max(ttt[ed[i].Y],dis[E-1]);\n\t\t}\n\t\t\n\n\t\tmemset(d,63,sizeof(d));\n\t\td[E-1]=0;\n\t\t//for(int i=0;i<E;i++)d[i]=ttt[i];\n\t\tfor(int C=0;C<E;C++)for(int i=0;i<ed.size();i++){\n\t\t\tint s=ed[i].X;\n\t\t\tint e=ed[i].Y;\n\n\t\t\td[e]=min(d[e],max(d[s]+1,ttt[e]));\n\t\t\td[s]=min(d[s],max(d[e]+1,ttt[s]));\n\t\t\tcontinue;\n\t\t\t\n\t\t\tint r1=max(d[s]+1,tt[0][i]);\n\t\t\tint r2=max(d[e]+1,tt[1][i]);\n\t\t\t\n\t\t\tif(s==E-1)r2=tt[1][i];\n\t\t\tif(e==E-1)r1=tt[0][i];\n\n\t\t\tif(d[s]<1000)d[e]=min(d[e],r1);\n\t\t\tif(d[e]<1000)d[s]=min(d[s],r2);\n\t\t}\n\t\tif(d[0]>10000)d[0]=-1;\n\t\tcout<<d[0]<<endl;\n\n\t\ted.clear();\n\t\tfor(int i=0;i<1000;i++)v[i].clear(),c[i].clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\n\n\nint H, W;\nstruct aa {\n\tint x;\n\tint y;\n\tint time;\n};\nclass Compare {\npublic:\n\t//aaが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\nint memo[32][32][2][32][32];\nint normalcheck(const int sx,const int sy,const vector<vector<int>>&tatedoors,const vector<vector<int>>&yokodoors, const bool tclose,const int closex, const int closey) {\n\t//if (memo[sx][sy][tclose][closex][closey] >= 0)return memo[sx][sy][tclose][closex][closey];\n\tvector<vector<int>>times(H, vector<int>(W, 99999));\n\ttimes[sy][sx] = 0;\n\tpriority_queue<aa, vector<aa>, Compare>que;\n\tque.push(aa{ sx,sy,0 });\n\twhile (!que.empty()) {\n\t\taa atop(que.top());\n\t\tque.pop();\n\t\tconst int nx = atop.x;\n\t\tconst int ny = atop.y;\n\t\tif (nx == W-1&&ny == H - 1)return memo[sx][sy][tclose][closex][closey]=atop.time;\n\n\t\tif (yokodoors[ny][nx]) {\n\t\t\tif (times[ny - 1][nx]  > atop.time + 1) {\n\t\t\t\ttimes[ny - 1][nx] = atop.time + 1;\n\t\t\t\tque.push(aa{ nx,ny - 1,atop.time + 1 });\n\t\t\t}\n\t\t}\n\t\tif (yokodoors[ny+1][nx]) {\n\t\t\tif (times[ny + 1][nx]  > atop.time + 1) {\n\t\t\t\ttimes[ny + 1][nx] = atop.time + 1;\n\t\t\t\tque.push(aa{ nx,ny + 1,atop.time + 1 });\n\t\t\t}\n\t\t}\n\t\tif (tatedoors[ny][nx]) {\n\t\t\tif (times[ny ][nx - 1]  > atop.time + 1) {\n\t\t\t\ttimes[ny ][nx - 1] = atop.time + 1;\n\t\t\t\tque.push(aa{ nx - 1,ny,atop.time + 1 });\n\t\t\t}\n\t\t}\n\t\tif (tatedoors[ny][nx+1]) {\n\t\t\tif (times[ny][nx + 1]  > atop.time + 1) {\n\t\t\t\ttimes[ny][nx + 1] = atop.time + 1;\n\t\t\t\tque.push(aa{ nx + 1,ny,atop.time + 1 });\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[sx][sy][tclose][closex][closey]= 99999999;\n}\nbool check(const int needtime, vector<vector<int>>tatedoors, vector<vector<int>>yokodoors) {\n\tvector<vector<int>>times(H, vector<int>(W, 99999));\n\ttimes[0][0] = 0;\n\tpriority_queue<aa, vector<aa>, Compare>que;\n\tque.push(aa{ 0,0,0 });\n\twhile (!que.empty()) {\n\t\taa atop(que.top());\n\t\tque.pop();\n\t\tconst int nx = atop.x;\n\t\tconst int ny = atop.y;\n\t\tif (nx == W - 1 &&ny == H - 1)return true;\n\n\t\tif (yokodoors[ny][nx]) {\n\t\t\tif (times[ny - 1][nx]  > atop.time + 1) {\n\t\t\t\tint closetime;\n\t\t\t\t{\n\t\t\t\t\tyokodoors[ny][nx] = false;\n\t\t\t\t\tclosetime=normalcheck(nx, ny, tatedoors, yokodoors,false,nx,ny);\n\t\t\t\t\tyokodoors[ny][nx] = true;\n\t\t\t\t}\n\t\t\t\tif (atop.time + closetime <= needtime) {\n\t\t\t\t\ttimes[ny - 1][nx] = atop.time + 1;\n\t\t\t\t\tque.push(aa{ nx,ny - 1,atop.time + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (yokodoors[ny + 1][nx]) {\n\t\t\tif (times[ny + 1][nx]  > atop.time + 1) {\n\t\t\t\tint closetime;\n\t\t\t\t{\n\t\t\t\t\tyokodoors[ny + 1][nx] = false;\n\t\t\t\t\tclosetime = normalcheck(nx, ny, tatedoors, yokodoors,false,nx, ny + 1);\n\t\t\t\t\tyokodoors[ny + 1][nx] = true;\n\t\t\t\t}\n\t\t\t\tif (atop.time + closetime <= needtime) {\n\t\t\t\t\ttimes[ny+ 1][nx] = atop.time + 1;\n\t\t\t\t\tque.push(aa{ nx,ny + 1,atop.time + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (tatedoors[ny][nx]) {\n\t\t\tif (times[ny][nx - 1] > atop.time + 1) {\n\t\t\t\tint closetime;\n\t\t\t\t{\n\t\t\t\t\ttatedoors[ny][nx] = false;\n\t\t\t\t\tclosetime = normalcheck(nx, ny, tatedoors, yokodoors,true,nx,ny);\n\t\t\t\t\ttatedoors[ny][nx] = true;\n\t\t\t\t}\n\t\t\t\tif (atop.time + closetime <= needtime) {\n\t\t\t\t\ttimes[ny][nx - 1] = atop.time + 1;\n\t\t\t\t\tque.push(aa{ nx - 1,ny,atop.time + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (tatedoors[ny][nx + 1]) {\n\t\t\tif (times[ny][nx + 1]  > atop.time + 1) {\n\t\t\t\tint closetime;\n\t\t\t\t{\n\t\t\t\t\ttatedoors[ny][nx+1] = false;\n\t\t\t\t\tclosetime = normalcheck(nx, ny, tatedoors, yokodoors,true,nx+1,ny);\n\t\t\t\t\ttatedoors[ny][nx+1] = true;\n\t\t\t\t}\n\t\t\t\tif (atop.time + closetime <= needtime) {\n\t\t\t\t\ttimes[ny][nx + 1] = atop.time + 1;\n\t\t\t\t\tque.push(aa{ nx + 1,ny,atop.time + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main() { \n\twhile (1) {\n\t\tmemset(memo, -1, sizeof(memo));\n\n\t\tcin >> H >> W;\n\t\tif (!H)break;\n\t\tvector<vector<int>>yokodoors;\n\t\tvector<vector<int>>tatedoors;\n\t\tyokodoors.resize(H+1);\n\t\ttatedoors.resize(H);\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tbool open = false;\n\t\t\tyokodoors[0].push_back(open);\n\t\t\tyokodoors[H].push_back(open);\n\t\t}\n\n\t\tfor (int i = 0; i < 2 * H -1; ++i) {\n\t\t\tif (i % 2) {\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tbool open; cin >> open;\n\t\t\t\t\topen = !open;\n\t\t\t\t\tyokodoors[i / 2 + 1].push_back(open);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttatedoors[i / 2].push_back(false);\n\t\t\t\tfor (int j = 0; j < W - 1; ++j) {\n\t\t\t\t\tbool open; cin >> open;\n\t\t\t\t\topen = !open;\n\t\t\t\t\ttatedoors[i / 2].push_back(open);\n\t\t\t\t}\n\t\t\t\ttatedoors[i / 2].push_back(false);\n\t\t\t}\n\t\t}\n\n\t\tif (!check(1000000,tatedoors,yokodoors)) {\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tint amin = 0;\n\t\t\tint amax = 1000;\n\t\t\twhile (amin + 1 != amax) {\n\t\t\t\tint amid = (amin + amax) / 2;\n\t\t\t\tif (check(amid,tatedoors,yokodoors)) {\n\t\t\t\t\tamax = amid;\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamin = amid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << amax << endl;\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<bitset>\n#include<queue>\n#include<tuple>\n#include<functional>\n#include<algorithm>\nusing namespace std;\n\nenum {N, E, S, W};\nconst unsigned long ALL = 1 + 2 + 4 + 8;\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\n\nconst int INF = 10000;\n\nenum {Y, X, STEP};\ntypedef tuple<int, int, int> Node;\n\nenum {DWORST, DSTEP, DY, DX};\ntypedef tuple<int, int, int, int> DNode;\n\nvector<vector<vector<int>>> memo;\n\nint h, w;\nvector<vector<bitset<4>>> wall;\n\nint bfs(int by, int bx, int bd) {\n    queue<Node> q;\n    vector<vector<int>> visited(h, vector<int>(w, 0));\n    q.push(Node(by, bx, 0));\n    while(!q.empty()) {\n        int y = get<Y>(q.front());\n        int x = get<X>(q.front());\n        int step = get<STEP>(q.front());\n        q.pop();\n        if(y == h - 1 && x == w - 1) return step;\n        if(visited[y][x]) continue;\n        visited[y][x] = 1;\n        for(int d = 0; d < 4; ++d) {\n            if(wall[y][x][d]) continue;\n            if(y == by && x == bx && d == bd) continue;\n            int ny = y + dy[d];\n            int nx = x + dx[d];\n            if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            q.push(Node(ny, nx, step + 1));\n        }\n    }\n    return INF;\n}\n\nint Dijkstra() {\n    priority_queue<DNode, vector<DNode>, greater<DNode>> q;\n    q.push(DNode(0, 0, 0, 0));\n    vector<vector<vector<int>>> visited(h, vector<vector<int>>(w, vector<int>(h * w * 2, 0)));\n    while(!q.empty()) {\n        int y = get<DY>(q.top());\n        int x = get<DX>(q.top());\n        int step = get<DSTEP>(q.top());\n        int worst = get<DWORST>(q.top());\n        q.pop();\n//         cout<<y<<\",\"<<x<<\" - \"<<step<<\" - \"<<worst<<endl;\n        if(y == h - 1 && x == w - 1) return worst;\n        if(visited[y][x][step]) continue;\n        visited[y][x][step] = 1;\n        for(int d = 0; d < 4; ++d) {\n            if(wall[y][x][d]) continue;\n            int ny = y + dy[d];\n            int nx = x + dx[d];\n            if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            int nworst = max({step + 1, worst, step + memo[y][x][d]});\n            q.push(DNode(nworst, step + 1, ny, nx));\n        }\n    }\n    return INF;\n}\n\nint main() {\n    while(cin >> h >> w, h | w) {\n        wall = vector<vector<bitset<4>>>(h, vector<bitset<4>>(w, bitset<4>(ALL)));\n        for(int i = 0; i < h - 1; ++i) {\n            for(int j = 0; j < w - 1; ++j) {\n                int is_wall;\n                cin >> is_wall;\n                if(is_wall) continue;\n                wall[i][j].reset(E);\n                wall[i][j + 1].reset(W);\n            }\n            for(int j = 0; j < w; ++j) {\n                int is_wall;\n                cin >> is_wall;\n                if(is_wall) continue;\n                wall[i][j].reset(S);\n                wall[i + 1][j].reset(N);\n            }\n        }\n        for(int j = 0; j < w - 1; ++j) {\n            int is_wall;\n            cin >> is_wall;\n            if(is_wall) continue;\n            wall[h - 1][j].reset(E);\n            wall[h - 1][j + 1].reset(W);\n        }\n\n        memo = vector<vector<vector<int>>>(h, vector<vector<int>>(w, vector<int>(4, INF)));\n        for(int i = 0; i < h; ++i) for(int j = 0; j < w; ++j) for(int d = 0; d < 4; ++d) memo[i][j][d] = bfs(i, j, d);\n\n        int answer = Dijkstra();\n        cout << (answer == INF ? -1 : answer) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nint h,w;\nint dp[33*33];\nint dist[33*33];\nint memo[33*33];\nint seica[33*33];\nbool used[33*33];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nvector<vector<int>> v(33*33);\n\nint fun(int a,int b){\n\tREP(i,33*33)dist[i] = INF;\n\tdist[a] = 0;\n\tqueue<pair<int,int>> q;\n\tq.push(MP(a,0));\n\twhile(!q.empty()){\n\t\tpair<int,int> now = q.front();q.pop();\n\t\tint node = now.FI;\n\t\tint kyo = now.SE;\n\t\tif(kyo > dist[node])continue;\n\t\tREP(i,v[node].size()){\n\t\t\tint aite = v[node][i];\n\t\t\tif((node == a && aite == b) || (node == b && aite == a))continue;\n\t\t\tif(dist[aite] > kyo + 1){\n\t\t\t\tdist[aite] = kyo + 1;\n\t\t\t\tq.push(MP(aite,kyo+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn seica[a] = dist[h*w-1];\n}\n\nint main()\n{\n\twhile(cin >> h >> w,h|w){\n\t\t//初期化\n\t\tREP(i,33*33)dp[i] = INF;\n\t\tREP(i,33*33){v[i].clear();used[i] = false;}\n\t\tdp[0] = 0;\n\t\t\n\t\t//入力\n\t\tREP(i,h){\n\t\t\tREP(j,w-1){\n\t\t\t\tint tmp;cin >> tmp;\n\t\t\t\tif(tmp == 0){\n\t\t\t\t\tv[i*w+j].PB(i*w+j+1);\n\t\t\t\t\tv[i*w+j+1].PB(i*w+j);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tif(i != h-1)REP(j,w){\n\t\t\t\tint tmp;cin >> tmp;\n\t\t\t\tif(tmp == 0){\n\t\t\t\t\tv[i*w+j].PB((i+1)*w+j);\n\t\t\t\t\tv[(i+1)*w+j].PB(i*w+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfun(0,-1);\n\t\tREP(i,33*33)memo[i] = dist[i];\n\t\tfun(h*w-1,-1);\n\t\tREP(i,33*33)seica[i] = dist[i];\t\t\n\t\t\n\t\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\n\t\tq.push(MP(0,0));\n\t\t\n\t\twhile(!q.empty()){\n\t\t\t\n\t\t\tDBG(\n\t\t\tcout << \"DP TABLE\" << endl;\n\t\t\tREP(i,h){\n\t\t\t\tREP(j,w){\n\t\t\t\t\tcout << dp[i*w+j] << ' ';\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\t)\n\t\t\tpair<int,int> now = q.top();q.pop();\n\t\t\tint node = now.SE;\n\t\t\tint kyori = now.FI;\n\t\t\tif(dp[node] < kyori)continue;\n\t\t\tused[node] = true;\n\t\t\t\n\t\t\tREP(i,v[node].size()){\n\t\t\t\tint aite = v[node][i];\n\t\t\t\tint score = fun(node,aite) + memo[node];\n\t\t\t\tif((memo[node] < memo[aite] || aite == h*w-1)&& dp[aite] > max(dp[node],score)){\n\t\t\t\t\tdp[aite] = max(dp[node],score);\n\t\t\t\t\tq.push(MP(dp[aite],aite));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tDBG(\n\t\tcout << \"DP TABLE\" << endl;\n\t\tREP(i,h){\n\t\t\tREP(j,w){\n\t\t\t\tcout << dp[i*w+j] << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t)\n\t\t\n\t\tDBG(\n\t\tcout << \"MEMO TABLE\" << endl;\n\t\tREP(i,h){\n\t\t\tREP(j,w){\n\t\t\t\tcout << memo[i*w+j] << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t)\n\t\tDBG(cout << \"ANS IS \";);\n\t\tif(dp[h*w-1] == INF){\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << dp[h*w-1] << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <utility>\n#define INF 2000\nusing namespace std;\ntypedef pair<int,int> P;\n\nstruct data{\n\tint x,y,c,dc;\n\tdata(int xx,int yy,int cc,int dd){\n\t\tx=xx;\n\t\ty=yy;\n\t\tc=cc;\n\t\tdc=dd;\n\t}\n\n\tbool operator<(const data& d1)const{\n\t\treturn d1.dc<dc;\n\t}\n};\n\nint h,w;\n\nint fie[61][61];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint dp[61][61][901];\nint cost[61][61][4];\nint used[61][61];\n\nint bfs(int sx,int sy){\n\tqueue<P> que;\n\tque.push(P(sx,sy));\n\tmemset(used,-1,sizeof(used));\n\tused[sx][sy]=0;\n\twhile(que.size()){\n\t\tP q=que.front();\n\t\tque.pop();\n\t\tint x=q.first,y=q.second;\n\t\tif(x==(w-1)*2 && y==(h-1)*2)return used[x][y];\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\tif(nx>=0 && nx<w*2-1 && ny>=0 && ny<h*2-1){\n\t\t\t\tif(fie[nx][ny]==1)continue;\n\t\t\t\tnx+=dx[i];\n\t\t\t\tny+=dy[i];\n\t\t\t\tif(used[nx][ny]==-1){\n\t\t\t\t\tused[nx][ny]=used[x][y]+1;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn INF;\n}\n\nint dijk(){\n\tpriority_queue<data> que;\n\tque.push(data(0,0,0,0));\n\tfor(int i=0;i<=60;i++){\n\t\tfor(int j=0;j<=60;j++){\n\t\t\tfor(int k=0;k<=900;k++){\n\t\t\t\tdp[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tque.push(data(0,0,0,0));\n\tdp[0][0][0]=0;\n\twhile(que.size()){\n\t\tdata d=que.top();\n\t\tque.pop();\n\t\tif(dp[d.x][d.y][d.c]!=d.dc)continue;\n\t\tif(d.x==(w-1)*2 && d.y==(h-1)*2)return d.dc;\n\t\t//printf(\"%d %d %d %d\\n\",d.x,d.y,d.c,d.dc);\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(cost[d.x][d.y][i]==INF)continue;\n\t\t\tint nx=d.x+dx[i]*2,ny=d.y+dy[i]*2;\n\t\t\tif(nx>=0 && nx<w*2-1 && ny>=0 && ny<h*2-1){\n\t\t\t\tint ndc=max(d.dc,cost[d.x][d.y][i]+d.c);\n\t\t\t\tndc=max(ndc,d.c+1);\n\t\t\t\tif(dp[nx][ny][d.c+1]>ndc && d.c<900){\n\t\t\t\t\tdp[nx][ny][d.c+1]=ndc;\n\t\t\t\t\tque.push(data(nx,ny,d.c+1,ndc));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tif(h==0 && w==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<2*h-1;i++){\n\t\t\tif(i%2==0){\n\t\t\t\tfor(int j=0;j<w-1;j++){\n\t\t\t\t\tscanf(\"%d\",&fie[j*2+1][i]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tscanf(\"%d\",&fie[j*2][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<2*h-1;i+=2){\n\t\t\tfor(int j=0;j<w*2;j+=2){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint x=j+dx[k],y=i+dy[k];\n\t\t\t\t\tif(x>=0 && x<w*2-1 && y>=0 && y<w*2-1){\n\t\t\t\t\t\tif(fie[x][y]==0){\n\t\t\t\t\t\t\tfie[x][y]=1;\n\t\t\t\t\t\t\tcost[j][i][k]=bfs(j,i);\n\t\t\t\t\t\t\tfie[x][y]=0;\n\t\t\t\t\t\t}else cost[j][i][k]=INF;\n\t\t\t\t\t}else cost[j][i][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\n#define chmin(x,y) x=min(x,y)\ntypedef pair<int,int> P;\nint H,W,dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};//d,r,u,l\nbool can[30][30][4];\nint d[30][30][4][30][30];//(a,b)<-x->(a+,b+)\nint dp[901][30][30],inf=1e9;\nvoid bfs(int xx,int yy,int dd){\n\tqueue<P> que;\n\td[xx][yy][dd][H-1][W-1]=0;\n\tque.push(P(H-1,W-1));\n\twhile(!que.empty()){\n\t\tP p=que.front();\n\t\tint x=p.fs,y=p.sc;\n\t\tque.pop();\n\t\trep(di,4){\n\t\t\tif(!can[x][y][di]) continue;\n\t\t\tint nx=x+dx[di],ny=y+dy[di];\n\t\t\tif(d[xx][yy][dd][nx][ny]!=inf) continue;\n\t\t\td[xx][yy][dd][nx][ny]=d[xx][yy][dd][x][y]+1;\n\t\t\tque.push(P(nx,ny));\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin>>H>>W;\n\t\tif(H==0) break;\n\t\trep(i,H) rep(j,W) rep(di,4) can[i][j][di]=0;\n\t\trep(i,H) rep(j,W) rep(k,H*W+1) dp[k][i][j]=inf;\n\t\trep(i,H) rep(j,W) rep(di,4) rep(x,H) rep(y,W) d[i][j][di][x][y]=inf;\n\t\trep(i,H){\n\t\t\trep(j,W-1){\n\t\t\t\tint x;\n\t\t\t\tcin>>x;\n\t\t\t\tif(x==0){\n\t\t\t\t\tcan[i][j][1]=1;\n\t\t\t\t\tcan[i][j+1][3]=1;\n\t\t\t\t} \n\t\t\t}\n\t\t\tif(i==H-1) break;\n\t\t\trep(j,W){\n\t\t\t\tint x;\n\t\t\t\tcin>>x;\n\t\t\t\tif(x==0){\n\t\t\t\t\tcan[i][j][0]=1;\n\t\t\t\t\tcan[i+1][j][2]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(xx,H) rep(yy,W) rep(dd,4){\n\t\t\tif(!can[xx][yy][dd]) continue;\n\t\t\tcan[xx][yy][dd]=0;\n\t\t\tcan[xx+dx[dd]][yy+dy[dd]][(dd+2)%4]=0;\n\t\t\tbfs(xx,yy,dd);\n\t\t\tcan[xx][yy][dd]=1;\n\t\t\tcan[xx+dx[dd]][yy+dy[dd]][(dd+2)%4]=1;\n\t\t}\n\t\tdp[0][0][0]=0;\n\t\tint ans=inf;\n\t\trep(i,H*W){\n//\t\t\tshow(i);\n\t\t\trep(x,H) rep(y,W){\n\t\t\t\tif(dp[i][x][y]==inf) continue;\n\t\t\t\trep(di,4){\n\t\t\t\t\tif(!can[x][y][di]) continue;\n\t\t\t\t\tint nx=x+dx[di],ny=y+dy[di];\n\t\t\t\t\tchmin(dp[i+1][nx][ny],max(dp[i][x][y],i+d[x][y][di][x][y]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,H*W+1){\n//\t\t\tshow(dp[i][H-1][W-1]);\n\t\t\tchmin(ans,dp[i][H-1][W-1]);\n\t\t}\n\t\tif(ans==inf) ans=-1;\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nconst int dy[] = {-1, 0, 1, 0};\nconst int dx[] = {0, -1, 0, 1};\n\nint h, w;\nbool wall[4][33][33];\n\nbool in(int y, int x) {\n  return 0<=y&&y<h&&0<=x&&x<w;\n}\n\nint brokenPath[4][33][33][33][33];\n\nvoid bfs(int d, int sy, int sx) {\n  queue<Pi> que;\n  que.emplace(h-1, w-1);\n  rep(i, 33) rep(j, 33) brokenPath[d][sy][sx][i][j] = inf;\n  brokenPath[d][sy][sx][h-1][w-1] = 0;\n  while(!que.empty()) {\n    int y, x; tie(y, x) = que.front(); que.pop();\n    rep(i, 4) {\n      int ny = y+dy[i], nx = x+dx[i];\n      if(!in(ny, nx) || wall[i][y][x]) continue;\n      if(brokenPath[d][sy][sx][y][x]+1 < brokenPath[d][sy][sx][ny][nx]) {\n\tbrokenPath[d][sy][sx][ny][nx] = brokenPath[d][sy][sx][y][x]+1;\n\tque.emplace(ny, nx);\n      }\n    }\n  }\n}\n\nint mincost[33][33];\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> h >> w, h || w) {\n    rep(i, 4) rep(j, 33) rep(k, 33) wall[i][j][k] = true;\n\n    rep(i, 2*h-1) {\n      if(i&1) {\n\trep(j, w) {\n\t  bool f;\n\t  cin >> f;\n\t  wall[2][i/2][j] = f;\n\t  wall[0][i/2+1][j] = f;\n\t}\n      } else {\n\trep(j, w-1) {\n\t  bool f;\n\t  cin >> f;\n\t  wall[3][i/2][j] = f;\n\t  wall[1][i/2][j+1] = f;\n\t}\n      }\n    }\n\n    rep(k, 4) rep(i, h) rep(j, w) {\n      if(wall[k][i][j]) continue;\n      wall[k][i][j] = true;\n      bfs(k, i, j);\n      wall[k][i][j] = false;\n    }\n\n    priority_queue<Tapris, vector<Tapris>, greater<Tapris> > que;\n    rep(i, 33) rep(j, 33) mincost[i][j] = inf;\n    mincost[h-1][w-1] = 0;\n    que.emplace(0, h-1, w-1);\n    while(!que.empty()) {\n      int cost, y, x;\n      tie(cost, y, x) = que.top(); que.pop();\n      if(mincost[y][x] < cost) continue;\n      rep(i, 4) {\n\tint ny = y+dy[i], nx = x+dx[i];\n\tif(!in(ny, nx) || wall[i][y][x]) continue;\n\tint nc = max(cost+1, brokenPath[i][y][x][ny][nx]);\n\tif(nc < mincost[ny][nx]) {\n\t  mincost[ny][nx] = nc;\n\t  que.emplace(nc, ny, nx);\n\t}\n      }\n    }\n\n    cout << (mincost[0][0] == inf ? -1 : mincost[0][0]) << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 32\n#define SHORT_NUM 32000\n\nenum Type{\n\tUNDER,\n\tRIGHT,\n};\n\nstruct Door{\n\tDoor(int arg_row,int arg_col,Type arg_type){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttype = arg_type;\n\t}\n\tint row,col;\n\tType type;\n};\n\nstruct Wall{\n\tvoid set(bool arg_under_wall,bool arg_right_wall){\n\t\tunder_wall = arg_under_wall;\n\t\tright_wall = arg_right_wall;\n\t}\n\tbool under_wall,right_wall;\n\tint under_index,right_index;\n};\n\nstruct Info{\n\tInfo(int arg_row,int arg_col,short arg_sum_cost){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\tbool operator<(const struct Info &arg) const{ //★総コストの昇順(PQ)★\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint row,col;\n\tshort sum_cost;\n};\n\nint H,W;\nint num_door;\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\nshort min_dist[1740][NUM][NUM],final_min_dist[NUM][NUM];\nvector<Door> DOOR;\nWall wall[NUM][NUM];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 1 && row <= H && col >= 1 && col <= W){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nvoid dijkstra(int door_index){\n\n\tfor(int row = 1; row <= H; row++){\n\t\tfor(int col = 1; col <= W; col++){\n\t\t\tmin_dist[door_index][row][col] = SHORT_NUM;\n\t\t}\n\t}\n\n\tmin_dist[door_index][H][W] = 0;\n\tpriority_queue<Info> Q;\n\n\tQ.push(Info(H,W,0));\n\n\tint adj_row,adj_col;\n\tshort next_cost;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().sum_cost > min_dist[door_index][Q.top().row][Q.top().col]){\n\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\n\t\t\t\tadj_row = Q.top().row+diff_row[i];\n\t\t\t\tadj_col = Q.top().col+diff_col[i];\n\n\t\t\t\tif(!rangeCheck(adj_row,adj_col))continue;\n\n\t\t\t\tnext_cost = Q.top().sum_cost+1;\n\n\t\t\t\tswitch(i){\n\t\t\t\tcase 0: //上へ移動\n\t\t\t\t\tif(wall[adj_row][adj_col].under_wall){\n\t\t\t\t\t\tnext_cost = -1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1: //左へ移動\n\t\t\t\t\tif(wall[adj_row][adj_col].right_wall){\n\t\t\t\t\t\tnext_cost = -1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2: //右\n\t\t\t\t\tif(wall[Q.top().row][Q.top().col].right_wall){\n\t\t\t\t\t\tnext_cost = -1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3: //下\n\t\t\t\t\tif(wall[Q.top().row][Q.top().col].under_wall){\n\t\t\t\t\t\tnext_cost = -1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(next_cost == -1)continue;\n\n\t\t\t\tif(min_dist[door_index][adj_row][adj_col] > next_cost){\n\t\t\t\t\tmin_dist[door_index][adj_row][adj_col] = next_cost;\n\t\t\t\t\tQ.push(Info(adj_row,adj_col,next_cost));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n}\n\nvoid func(){\n\n\tDOOR.clear();\n\tnum_door = 0;\n\n\t//マップの左の壁\n\tfor(int row = 0; row <= H; row++){\n\t\twall[row][0].right_wall = true;\n\t}\n\n\t//マップの下の壁\n\tfor(int col = 1; col <= W; col++){\n\t\twall[H][col].under_wall = true;\n\t}\n\n\t//マップの右の壁\n\tfor(int row = 1; row <= H; row++){\n\t\twall[row][W].right_wall = true;\n\t}\n\n\t//マップの上の壁\n\tfor(int col = 1; col <= W; col++){\n\t\twall[0][col].under_wall = true;\n\t}\n\n\twall[0][1].under_wall = false; //入口\n\twall[H][W].under_wall = false; //出口\n\n\tint tmp;\n\n\tfor(int row = 1; row <= H; row++){\n\n\t\t//第row行の、垂直方向の壁情報\n\t\tfor(int col = 1; col <= W-1; col++){\n\t\t\tscanf(\"%d\",&tmp);\n\n\t\t\tif(tmp == 1){\n\t\t\t\twall[row][col].right_wall = true; //★ドアがないなら壁\n\t\t\t}else{\n\t\t\t\twall[row][col].right_wall = false; //★★ドア有り★★\n\t\t\t\twall[row][col].right_index = num_door; //★このドアが壊れた時の、min_distのインデックスを記録★\n\t\t\t\tDOOR.push_back(Door(row,col,RIGHT));\n\t\t\t\tnum_door++;\n\t\t\t}\n\t\t}\n\n\t\tif(row == H)break;\n\n\t\t//第row行の、部屋の下の壁情報\n\t\tfor(int col = 1; col <= W; col++){\n\t\t\tscanf(\"%d\",&tmp);\n\n\t\t\tif(tmp == 1){\n\t\t\t\twall[row][col].under_wall = true; //★ドアがないなら壁\n\t\t\t}else{\n\t\t\t\twall[row][col].under_wall = false;\n\t\t\t\twall[row][col].under_index = num_door;\n\t\t\t\tDOOR.push_back(Door(row,col,UNDER));\n\t\t\t\tnum_door++;\n\t\t\t}\n\t\t}\n\t}\n\n\t//★★あるドアが壊れている時の、ゴールからの最小距離を全探索\n\tfor(int loop = 0; loop < num_door; loop++){\n\n\t\tif(DOOR[loop].type == RIGHT){\n\t\t\twall[DOOR[loop].row][DOOR[loop].col].right_wall = true;\n\t\t}else{\n\t\t\twall[DOOR[loop].row][DOOR[loop].col].under_wall = true;\n\t\t}\n\n\t\tdijkstra(loop);\n\n\t\tif(DOOR[loop].type == RIGHT){\n\t\t\twall[DOOR[loop].row][DOOR[loop].col].right_wall = false;\n\t\t}else{\n\t\t\twall[DOOR[loop].row][DOOR[loop].col].under_wall = false;\n\t\t}\n\t}\n\n\t//総まとめのダイクストラ\n\tfor(int row = 1; row <= H; row++){\n\t\tfor(int col = 1; col <= W; col++){\n\t\t\tfinal_min_dist[row][col] = SHORT_NUM;\n\t\t}\n\t}\n\n\tpriority_queue<Info> Q;\n\tfinal_min_dist[H][W] = 0;\n\tQ.push(Info(H,W,0));\n\n\tint adj_row,adj_col,tmp_index;\n\tshort next_cost;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().sum_cost > final_min_dist[Q.top().row][Q.top().col]){\n\n\t\t\tQ.pop();\n\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\n\t\t\t\tadj_row = Q.top().row+diff_row[i];\n\t\t\t\tadj_col = Q.top().col+diff_col[i];\n\n\t\t\t\tif(!rangeCheck(adj_row,adj_col))continue;\n\n\t\t\t\tnext_cost = Q.top().sum_cost+1;\n\n\t\t\t\tswitch(i){\n\t\t\t\tcase 0: //上へ移動\n\t\t\t\t\tif(wall[adj_row][adj_col].under_wall){\n\n\t\t\t\t\t\tnext_cost = -1;\n\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_index = wall[adj_row][adj_col].under_index;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1: //左へ移動\n\t\t\t\t\tif(wall[adj_row][adj_col].right_wall){\n\n\t\t\t\t\t\tnext_cost = -1;\n\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_index = wall[adj_row][adj_col].right_index;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2: //右\n\t\t\t\t\tif(wall[Q.top().row][Q.top().col].right_wall){\n\n\t\t\t\t\t\tnext_cost = -1;\n\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_index = wall[Q.top().row][Q.top().col].right_index;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3: //下\n\t\t\t\t\tif(wall[Q.top().row][Q.top().col].under_wall){\n\n\t\t\t\t\t\tnext_cost = -1;\n\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\ttmp_index = wall[Q.top().row][Q.top().col].under_index;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(next_cost == -1)continue;\n\n\t\t\t\t/*★ある場所にゴールから到達するコストにおいて、任意の壁が壊れている場合と、そうでない場合の大きいコストを採用★*/\n\t\t\t\tnext_cost = max(next_cost,min_dist[tmp_index][adj_row][adj_col]);\n\n\t\t\t\tif(final_min_dist[adj_row][adj_col] > next_cost){\n\t\t\t\t\tfinal_min_dist[adj_row][adj_col] = next_cost;\n\t\t\t\t\tQ.push(Info(adj_row,adj_col,next_cost));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tif(final_min_dist[1][1] == SHORT_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tint ans = (int)final_min_dist[1][1];\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tif(H == 0 && W == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl;\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl;\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl;\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl;\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl;\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl;\n#define int long long\n#define double long double\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\nconst int N = 50;\nint h,w;\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\nint G[N][N][4];\nint in(int x,int y){return !(x < 0 || y < 0 || x >= w || y >= h);}\n\nint dis[N][N][N][N][4]; //goalからの距離\nvoid bfs(int sy,int sx){\n  memset(dis,-1,sizeof(dis));\n  typedef tuple<int,int,int,int,int,int> T; // y, x, by, bx, dir, cost\n  queue<T> Q;\n  \n  //broken door\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<4;k++){\n        dis[sy][sx][i][j][k] = 0;\n        Q.push(T(sy,sx,i,j,k,0));\n      }\n  \n  while(!Q.empty()){\n    int y, x, by, bx, dir, cost;\n    tie(y, x, by, bx, dir, cost) = Q.front(); Q.pop();\n    \n    for(int i=0;i<4;i++){\n      int ny = y + dy[i];\n      int nx = x + dx[i];\n      int ncost = cost + 1;\n      if(!in(nx,ny) || G[y][x][i] == 0 || dis[ny][nx][by][bx][dir] != -1) continue;\n      if(x == bx && y == by && i == dir) continue;\n      if(nx == bx && ny == by && i == (dir+2)%4) continue;\n      dis[ny][nx][by][bx][dir] = ncost;\n      Q.push(T(ny,nx,by,bx,dir,ncost));\n    }\n  }\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<h;k++)\n        for(int l=0;l<w;l++)\n          for(int m=0;m<4;m++) if(dis[i][j][k][l][m] == -1) dis[i][j][k][l][m] = INF;\n}\n\nint calcCost(int y,int x,int d,int dir){\n  if(!in(x,y)) return INF;\n  int res = INF;\n  Min(res, d + dis[y][x][y][x][dir]);\n  return res;\n}\n\nint D[N][N][N*N], visited[N][N][N*N];\nint dijkstra(int sy,int sx){\n  typedef tuple<int,int,int,int> T; //cost, y, x, distance;\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<=h*w;k++) D[i][j][k] = INF, visited[i][j][k] = 0;\n  \n  priority_queue<T,vector<T>,greater<T> > Q;\n  Q.push(T(0,sy,sx,0));\n  D[sy][sx][0] = 0;\n\n  int res = INF;\n  while(!Q.empty()){\n    int cost, y, x, d;\n    tie(cost,y, x, d) = Q.top(); Q.pop();\n    if(visited[y][x][d]++) continue;\n    if(x == w-1 && y == h-1) {\n      Min(res, max(cost, d));\n      continue;\n    }\n\n    for(int i=0;i<4;i++){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      int nd = d + 1;\n      int a = cost;\n      int b = calcCost(y, x, d, i);\n      int ncost = max(a, b);\n      if(!in(nx,ny) || G[y][x][i] == 0 || D[ny][nx][nd] <= ncost) continue;\n      D[ny][nx][nd] = ncost;\n      Q.push(T(ncost,ny,nx,nd));\n    }\n  }\n  if(res == INF) return -1;\n  return res;\n}\n\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(1){\n    cin>>h>>w;\n    if(h == 0 && w == 0) break;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++)\n        for(int k=0;k<4;k++) G[i][j][k] = 1;\n\n    for(int i=0;i<h*2-1;i++){\n      for(int j=0;j<w - !(i%2);j++){\n        int ng;\n        cin>>ng;\n        int x = j, y = i/2;\n        if(i%2 == 0 && ng) G[y][x][1] = G[y][x+1][3] = 0;\n        if(i%2 == 1 && ng) G[y][x][2] = G[y+1][x][0] = 0;\n      }\n    }\n\n    bfs(h-1, w-1);\n    \n    int ans = dijkstra(0, 0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#ifdef DEBUG_MODE\n    #define DBG(n) n;\n#else\n    #define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n \ntypedef long long ll;\ntypedef pair<pair<int,int>,int> P;\nint h,w;\npair<int,int> dp[33*33];\nint dist[33*33];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nvector<vector<int>> v(33*33);\n \nint fun(int a,int b){\n    REP(i,33*33)dist[i] = INF;\n    dist[a] = 0;\n    queue<pair<int,int>> q;\n    q.push(MP(a,0));\n    while(!q.empty()){\n        pair<int,int> now = q.front();q.pop();\n        int node = now.FI;\n        int kyo = now.SE;\n        if(kyo > dist[node])continue;\n        REP(i,v[node].size()){\n            int aite = v[node][i];\n            if((node == a && aite == b) || (node == b && aite == a))continue;\n            if(dist[aite] > kyo + 1){\n                dist[aite] = kyo + 1;\n                q.push(MP(aite,kyo+1));\n            }\n        }\n    }\n    return dist[h*w-1];\n}\n \nint main()\n{\n    while(cin >> h >> w,h|w){\n        //初期化\n        REP(i,33*33)dp[i] = MP(INF,INF);\n        REP(i,33*33){v[i].clear();}\n        dp[0] = MP(0,0);\n         \n        //入力\n        REP(i,h){\n            REP(j,w-1){\n                int tmp;cin >> tmp;\n                if(tmp == 0){\n                    v[i*w+j].PB(i*w+j+1);\n                    v[i*w+j+1].PB(i*w+j);\n                }\n                 \n            }\n            if(i != h-1)REP(j,w){\n                int tmp;cin >> tmp;\n                if(tmp == 0){\n                    v[i*w+j].PB((i+1)*w+j);\n                    v[(i+1)*w+j].PB(i*w+j);\n                }\n            }\n        }\n                 \n        priority_queue<P,vector<P>,greater<P>> q;\n        q.push(MP(MP(0,-1),0));\n        DBG(cout << \"!\" << endl;);\n        while(!q.empty()){\n            DBG(\n            cout << \"DP TABLE\" << endl;\n            REP(i,h){\n                REP(j,w){\n                    cout << dp[i*w+j].FI << ' ';\n                }\n                cout << endl;\n            }\n            )\n            P now = q.top();q.pop();\n            int node = now.SE;\n            pair<int,int> kyori = now.FI;\n            DBG(cout << kyori.FI << ' ' << kyori.SE << endl;)\n            DBG(cout << dp[node].FI << ' ' << dp[node].SE << endl;)\n            if(dp[node].FI < kyori.FI && dp[node].SE < kyori.SE)continue;\n            DBG(cout << \"IN\" << endl;)\n            kyori.SE++;\n            REP(i,v[node].size()){\n                int aite = v[node][i];\n                pair<int,int> score = MP(fun(node,aite)+kyori.SE,kyori.SE);\n                score = MP(max(dp[node].FI,score.FI),max(dp[node].SE,score.SE));\n                if(dp[aite].FI > score.FI || dp[aite].SE > score.SE){\n\t\t\t\t\tif(dp[aite] > score)dp[aite] = score;\n                    q.push(MP(score,aite));\n                }\n            }\n        }\n         \n        DBG(\n        cout << \"DP TABLE\" << endl;\n        REP(i,h){\n            REP(j,w){\n                cout << dp[i*w+j].FI << ' ';\n            }\n            cout << endl;\n        }\n        )\n         \n        DBG(cout << \"ANS IS \";);\n         \n        if(dp[h*w-1].FI == INF){\n            cout << -1 << endl;\n        }\n        else{\n            cout << dp[h*w-1].FI << endl;\n        }\n    }\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);++i)\n#define rep(i,n) REP(i, 0, n)\ntypedef pair<int, int> pint;\n\nint H, W;\nstruct Edge { int num, to; Edge(int n, int t) : num(n), to(t) {}};\nvector<vector<Edge>> edges;\nbool bfs(int broken_edge, vector<int>& dist, const vector<vector<Edge>>& edges) {\n    dist[(H - 1) * W + W - 1] = 0;\n    queue<int> que; que.push((H - 1) * W + W - 1);\n    while(!que.empty()) {\n        int cur = que.front(); que.pop();\n        for(const Edge& e : edges[cur]) {\n            if(e.num == broken_edge || dist[e.to] != INF) continue;\n            dist[e.to] = dist[cur] + 1;\n            que.push(e.to);\n        }\n    }\n    return dist[0] == INF;\n}\n\nint solve(const vector<vector<int>>& wdist, const vector<vector<Edge>>& edges) {\n    vector<int> dist(H * W, INF);\n    priority_queue<pint, vector<pint>, greater<pint>> que;\n    dist[(H - 1) * W + W - 1] = 0; que.emplace(0, (H - 1) * W + W - 1);\n    auto upd = [](int& a, int b) { return a > b ? (a = b, true) : false;};\n    while(!que.empty()) {\n        int cos, node;\n        tie(cos, node) = que.top(); que.pop();\n        if(dist[node] < cos) continue;\n        for(const Edge& e : edges[node]) {\n            int ncos = max(cos + 1, wdist[e.num][e.to]);\n            if(upd(dist[e.to], ncos)) que.emplace(ncos, e.to);\n        }\n    }\n    return dist[0];\n}\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    while(cin >> H >> W) {\n        int t_, edgenum = 0;\n        vector<vector<Edge>> edges(H * W);\n        rep(i, H) {\n            rep(j, W - 1) {\n                cin >> t_;\n                if(t_ == 0) {\n                    edges[i * W + j].emplace_back(edgenum, i * W + j + 1);\n                    edges[i * W + j + 1].emplace_back(edgenum, i * W + j);\n                    ++edgenum;\n                }\n            }\n            if(i == H - 1) continue;\n            rep(j, W) {\n                cin >> t_;\n                if(t_ == 0) {\n                    edges[i * W + j].emplace_back(edgenum, (i + 1) * W + j);\n                    edges[(i + 1) * W + j].emplace_back(edgenum, i * W + j);\n                    ++edgenum;\n                }\n            }\n        }\n        vector<vector<int>> wdist(edgenum, vector<int>(H * W, INF));\n        rep(i, edgenum) if(bfs(i, wdist[i], edges)) goto fail;\n        cout << solve(wdist, edges) << endl;\n        continue;\n      fail:\n        cout << \"-1\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntypedef pair<int, i_i> iii;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n#define down 0\n#define right 1\n#define up 2\n#define left 3\n//const ll mod = 1000000007;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n// down, right, up, left\nint can[4][35][35];\nint dist[2][35][35];\nint H, W;\nint dp[35][35];\nvector<i_i> query;\nvoid initialize(int index) {\n    for(int h = 0; h <= 31; h++) {\n        for(int w = 0; w <= 31; w++) dist[index][h][w] = INF;\n    }\n}\nbool chmax(int &a, int b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nbool chmin(int &a, int b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nvoid BFS(int index, int sh, int sw) {\n    initialize(index);\n    dist[index][sh][sw] = 0;\n    queue<i_i> que;\n    que.push({sh, sw});\n    while(!que.empty()) {\n        i_i now = que.front();\n        que.pop();\n        if(index == 0) query.push_back(now);\n        //cerr << \"SEARCHING: \" << now.first << \" \" << now.second << endl;\n        for(int k = 0; k < 4; k++) {\n            if(can[k][now.first][now.second] == 1) {\n                //cerr << \"CAN'T MOVE TO \" << k << endl;\n                continue;\n            }\n            int newh = now.first + dh[k];\n            int neww = now.second + dw[k];\n            //cerr << newh << \" \" << neww << endl;\n            if(newh <= 0 || newh > H || neww <= 0 || neww > W) continue;\n            if(chmin(dist[index][newh][neww], dist[index][now.first][now.second] + 1)) {\n                que.push({newh, neww});\n            }\n        }\n    }\n    return;\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> H >> W) {\n        if(H == 0) break;\n        for(int h = 1; h <= H; h++) {\n            for(int w = 1; w < W; w++) {\n                cin >> can[right][h][w];\n                can[left][h][w+1] = can[right][h][w];\n            }\n            if(h == H) break;\n            for(int w = 1; w <= W; w++) {\n                cin >> can[down][h][w];\n                can[up][h+1][w] = can[down][h][w];\n            }\n        }\n        /*\n        for(int k = 0; k < 4; k++) {\n            for(int h = 1; h <= H; h++) {\n                for(int w = 1; w <= W; w++) cerr << can[k][h][w] << \" \";\n                cerr << endl;\n            }\n            cerr << endl;\n        }\n        */\n        initialize(0);\n        query.clear();\n        BFS(0, H, W);\n        for(int h = 1; h <= H; h++) {\n            for(int w = 1; w <= W; w++) {\n                dp[h][w] = INF;\n            }\n        }\n        dp[H][W] = 0;\n        priority_queue<iii> que;\n        que.push({0, {H, W}});\n        while(!que.empty()) {\n            //cerr << query[i].first << \" \" << query[i].second << endl;\n            int h = que.top().second.first;\n            int w = que.top().second.second;\n            que.pop();\n            for(int k = 0; k <= 3; k++) {\n                if(can[k][h][w] == 1) continue;\n                int newh = h + dh[k];\n                int neww = w + dw[k];\n                if(newh <= 0 || newh > H || neww <= 0 || neww > W) continue;\n                //if(dist[0][newh][neww] >= dist[0][h][w]) continue;\n                //chmax(dp[h][w], 1 + dp[newh][neww]);\n                int nowcost = dp[h][w] + 1;\n                can[k][h][w] = 1;\n                can[(k+2)%4][newh][neww] = 1;\n                BFS(1, H, W);\n                /*\n                cerr << \"---{\" << h << \", \" << w << \"} {\" << newh << \", \" << neww << \"}---\" << endl;\n                for(int h = 1; h <= H; h++) {\n                    for(int w = 1; w <= W; w++) {\n                        cerr << dist[1][h][w] << \" \";\n                    }\n                    cerr << endl;\n                }\n                */\n                chmax(nowcost, dist[1][newh][neww]);\n                if(chmin(dp[newh][neww], nowcost)) {\n                    que.push({nowcost, {newh, neww}});\n                }\n                //chmax(dp[h][w], dist[1][h][w]);\n                can[k][h][w] = 0;\n                can[(k+2)%4][newh][neww] = 0;\n            }\n            //cerr << h << \" \" << w << \" \" << dp[h][w] << endl;\n        }\n        /*\n        for(int h = 1; h <= H; h++) {\n            for(int w = 1; w <= W; w++) {\n                cerr << dist[0][h][w] << \" \";\n            }\n            cerr << endl;\n        }\n        */\n       if(dp[1][1] == INF) dp[1][1] = -1;\n       cout << dp[1][1] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nclass State\n{\npublic:\n\tint x, y, c,a;\n\tState(int x, int y, int c, int a)\n\t\t:x(x),y(y),c(c),a(a)\n\t{}\n\n\tbool operator<(const State& s) const\n\t{\n\t\treturn c > s.c;\n\t}\n};\n\nconst int INF = (1<<28);\nint W,H;\nint nodeX[32][32][32];\nint nodeY[32][32][32];\n\nint d[32][32][4];\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nint dijkstra(int Sx, int Sy, int Tx, int Ty)\n{\n\tqueue<State> q;\n\tq.push(State(Sx,Sy,0,0));\n\n\tbool visited[32][32] = {0};\n\n\twhile(!q.empty()) {\n\t\tState s = q.front(); q.pop();\n\t\tif(visited[s.x][s.y]) continue;\n\t\tvisited[s.x][s.y] = true;\n\n\t\t if(s.x == Tx && s.y == Ty) return s.c;\n\n\t\tfor(int i=0; i<4; i++) {\n\t\t\tint tx = s.x + dx[i];\n\t\t\tint ty = s.y + dy[i];\n\n\t\t\tif(tx<0 || ty<0 || tx>=W || ty>=H) continue;\n\n\t\t\tif(i<2) {\n\t\t\t\tif(nodeX[s.x][tx][ty]==1) continue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(nodeY[tx][s.y][ty]==1) continue;\n\t\t\t}\n\n\t\t\tif(visited[tx][ty]) continue;\n\n\t\t\tq.push(State(tx, ty, s.c+1,0));\n\t\t}\n\n\t}\n\n\treturn -1;\n}\n\nbool visited[32][32][32*32+5] = {0};\n\nint bfs()\n{\n\tpriority_queue<State> q;\n\tq.push(State(0,0,0,0));\n\n\tmemset(visited, 0, sizeof(visited));\n\n\twhile(!q.empty())\n\t{\n\t\tState s = q.top(); q.pop();\n\t\tint x = s.x, y = s.y;\n\n\t\tif(visited[x][y][s.a]) continue;\n\t\tvisited[x][y][s.a] = true;\n\n\t\tif(x == W-1 && y == H-1) return s.c - 1;\n\n\t\tfor(int i=0; i<4; i++) {\n\t\t\tint tx = x + dx[i];\n\t\t\tint ty = y + dy[i];\n\n\n\t\t\tif(tx<0 || ty<0 || tx>=W || ty>=H) continue;\n\n\t\t\tif(i<2) {\n\t\t\t\tif(nodeX[x][tx][ty]==1) continue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(nodeY[tx][y][ty]==1) continue;\n\t\t\t}\n\t\t\t\n\t\t\tif(s.a+1 > W*H) continue;\n\t\t\tif(visited[tx][ty][s.a+1]) continue;\n\n\t\t\tint blockcst = d[x][y][i]; //(x,y)->(tx,ty)へ向かおうとして壁が壊れる迂回コスト\n\t\t\tint cst = max(s.a + 1 + blockcst, s.c); //max(今回起こるコスト,　今までの迂回コストの最大)\n\t\t\tif(blockcst == -1) cst = -1; //迂回不可能\n\n\n\t\t\tif(cst > 0) q.push(State(tx,ty,cst,s.a+1));\n\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint solve()\n{\n\tfor(int y=0; y<H; y++)\n\tfor(int x=0; x<W; x++)\n\t{\n\t\tfor(int k=0; k<4; k++)\n\t\t{\n\t\t\tint tx = x + dx[k];\n\t\t\tint ty = y + dy[k];\n\n\n\t\t\tif(tx<0 || ty<0 || tx>=W || ty>=H) continue;\n\n\t\t\tif(k<2) {\n\t\t\t\tif(nodeX[x][tx][ty]==1) continue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(nodeY[tx][y][ty]==1) continue;\n\t\t\t}\n\n\t\t\tif(k<2) { nodeX[x][tx][ty]=1; }\n\t\t\telse {    nodeY[tx][y][ty]=1; }\n\n\t\t\td[x][y][k] = dijkstra(x,y,W-1, H-1);\n\n\t\t\tif(k<2) { nodeX[x][tx][ty]=0; }\n\t\t\telse {    nodeY[tx][y][ty]=0; }\n\t\t}\n\t}\n\n\treturn bfs();\n}\n\nint main()\n{\n\twhile(cin >> H >> W, (W||H)) {\n\n\t\tfor(int i=0; i<H; i++) {\n\t\t\tfor(int j=0; j<W-1; j++) {\n\t\t\t\tint t;\n\t\t\t\tcin >> t;\n\t\t\t\tnodeX[j][j+1][i] = t;\n\t\t\t\tnodeX[j+1][j][i] = t;\n\t\t\t}\n\t\t\tif(i!=H-1)\n\t\t\tfor(int j=0; j<W; j++) {\n\t\t\t\tint t;\n\t\t\t\tcin >> t;\n\t\t\t\tnodeY[j][i][i+1] = t;\n\t\t\t\tnodeY[j][i+1][i] = t;\n\t\t\t}\n\t\t}\n\n\t\tcout << solve() << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#ifdef DEBUG_MODE\n    #define DBG(n) n;\n#else\n    #define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n \ntypedef long long ll;\ntypedef pair<pair<int,int>,int> P;\nint h,w;\npair<int,int> dp[33*33];\nint dist[33*33];\nint memo[33*33];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nvector<vector<int>> v(33*33);\n \nint fun(int a,int b){\n    REP(i,33*33)dist[i] = INF;\n    dist[a] = 0;\n    queue<pair<int,int>> q;\n    q.push(MP(a,0));\n    while(!q.empty()){\n        pair<int,int> now = q.front();q.pop();\n        int node = now.FI;\n        int kyo = now.SE;\n        if(kyo > dist[node])continue;\n        REP(i,v[node].size()){\n            int aite = v[node][i];\n            if((node == a && aite == b) || (node == b && aite == a))continue;\n            if(dist[aite] > kyo + 1){\n                dist[aite] = kyo + 1;\n                q.push(MP(aite,kyo+1));\n            }\n        }\n    }\n    return dist[h*w-1];\n}\n \nint main()\n{\n    while(cin >> h >> w,h|w){\n        //初期化\n        REP(i,33*33)dp[i] = MP(INF,INF);\n        REP(i,33*33){v[i].clear();}\n        dp[0] = MP(0,0);\n         \n        //入力\n        REP(i,h){\n            REP(j,w-1){\n                int tmp;cin >> tmp;\n                if(tmp == 0){\n                    v[i*w+j].PB(i*w+j+1);\n                    v[i*w+j+1].PB(i*w+j);\n                }\n                 \n            }\n            if(i != h-1)REP(j,w){\n                int tmp;cin >> tmp;\n                if(tmp == 0){\n                    v[i*w+j].PB((i+1)*w+j);\n                    v[(i+1)*w+j].PB(i*w+j);\n                }\n            }\n        }\n        fun(0,-1);\n\t\tREP(i,33*33)memo[i] = dist[i];\n        priority_queue<P,vector<P>,greater<P>> q;\n        q.push(MP(MP(0,-1),0));\n        DBG(cout << \"!\" << endl;);\n        while(!q.empty()){\n            DBG(\n            cout << \"DP TABLE\" << endl;\n            REP(i,h){\n                REP(j,w){\n                    cout << dp[i*w+j].FI << ' ';\n                }\n                cout << endl;\n            }\n            )\n            P now = q.top();q.pop();\n            int node = now.SE;\n            pair<int,int> kyori = now.FI;\n\t\t\tDBG(cout << \"STATUS\" << endl;)\n            DBG(cout << kyori.FI << ' ' << kyori.SE << endl;)\n            DBG(cout << dp[node].FI << ' ' << dp[node].SE << endl;)\n            if(dp[node].FI < kyori.FI && memo[node] < kyori.SE)continue;\n            kyori.SE++;\n            REP(i,v[node].size()){\n                int aite = v[node][i];\n                pair<int,int> score = MP(fun(node,aite)+kyori.SE,kyori.SE);\n                pair<int,int> seica = max(dp[node],score);\n                if(dp[aite] > seica || dp[aite].SE > score.SE){\n\t\t\t\t\tif(dp[aite] > seica)dp[aite] = seica;\n                    q.push(MP(score,aite));\n                }\n            }\n        }\n         \n        DBG(\n        cout << \"DP TABLE\" << endl;\n        REP(i,h){\n            REP(j,w){\n                cout << dp[i*w+j].FI << ' ';\n            }\n            cout << endl;\n        }\n        )\n         \n        DBG(cout << \"ANS IS \";);\n         \n        if(dp[h*w-1].FI == INF){\n            cout << -1 << endl;\n        }\n        else{\n            cout << dp[h*w-1].FI << endl;\n        }\n    }\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dh[]={0,1,0,-1};\nint dw[]={1,0,-1,0};\nint solve(int h,int w){\n    vector<vector<vector<int>>> wall(h,vector<vector<int>>(w,vector<int>(4,0)));\n    for(int i=0;i<h;i++){\n        wall[i][w-1][0]=true;\n        wall[i][0][2]=true;\n    }\n    for(int i=0;i<w;i++){\n        wall[h-1][i][1]=true;\n        wall[0][i][3]=true;\n    }\n    for(int i=0;i<h;i++){\n        for(int j=0;j+1<w;j++){\n            int w;\n            cin>>w;\n            wall[i][j][0]=w;\n            wall[i][j+1][2]=w;\n        }\n        if(i+1<h){\n            for(int j=0;j<w;j++){\n                int w;\n                cin>>w;\n                wall[i][j][1]=w;\n                wall[i+1][j][3]=w;\n            }\n        }\n    }\n    // for(int i=0;i<h;i++){\n    //     for(int j=0;j<w;j++){\n    //         cerr<<i<<' '<<j;\n    //         for(int k=0;k<4;k++) cerr<<wall[i][j][k];\n    //         cerr<<endl;\n    //     }\n    // }\n    //cerr<<\"Input finished\"<<endl;\n    const int INF=1e9;\n    function<int(int,int)> fromHere=[&](int p,int q){\n        queue<pair<int,int>> que;\n        if(accumulate(wall[p][q].begin(),wall[p][q].end(),0)==4) return INF;\n        int res=0;\n        for(int d=0;d<4;d++){\n            if(!wall[p][q][d]){\n                wall[p][q][d]=true;\n                vector<vector<int>> dist(h,vector<int>(w,INF));\n                dist[p][q]=0;\n                que.push({p,q});\n                while(!que.empty()){\n                    auto tmp=que.front(); que.pop();\n                    int i=tmp.first,j=tmp.second;\n                    for(int k=0;k<4;k++){\n                        if(!wall[i][j][k] && dist[i][j]+1<dist[i+dh[k]][j+dw[k]]){\n                            dist[i+dh[k]][j+dw[k]]=dist[i][j]+1;\n                            que.push({i+dh[k],j+dw[k]});\n                        }\n                    }\n                }\n                res=max(res,dist[h-1][w-1]);\n                wall[p][q][d]=false;\n            }\n        }\n        return res;\n    };\n    \n    vector<vector<int>> f(h,vector<int>(w,INF));\n    for(int i=0;i<h;i++)for(int j=0;j<w;j++) f[i][j]=fromHere(i,j);\n    //cerr<<\"FROM HERE CALCED\"<<endl;\n    priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<>> que;\n    vector<vector<int>> dist(h,vector<int>(w,INF));\n    dist[h-1][w-1]=0;\n    que.push({0,{h-1,w-1}});\n    while(!que.empty()){\n        auto tmp=que.top(); que.pop();\n        int p=tmp.second.first,q=tmp.second.second;\n        if(tmp.first>dist[p][q]) continue;\n        for(int i=0;i<4;i++){\n            if(!wall[p][q][i] && dist[p+dh[i]][q+dw[i]]==INF){\n                dist[p+dh[i]][q+dw[i]]=max(dist[p][q]+1,f[p+dh[i]][q+dw[i]]);\n                que.push({dist[p+dh[i]][q+dw[i]],{p+dh[i],q+dw[i]}});\n            }\n        }\n    }\n    return dist[0][0]>=INF ? -1 : dist[0][0];\n}\nint main(){\n    int h,w;\n    while(cin>>h>>w,h){\n        cout<<solve(h,w)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<bitset>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<functional>\n#include<algorithm>\nusing namespace std;\n\nenum {N, E, S, W};\nconst unsigned long ALL = 1 + 2 + 4 + 8;\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\n\nconst int INF = 10000;\n\n// for bfs\nenum {Y, X, STEP};\ntypedef tuple<int, int, int> Node;\ntypedef tuple<int, int> Vertex;\n\n// for Dijkstra\nenum {DWORST, DSTEP, DY, DX};\ntypedef tuple<int, int, int, int> DNode;\n\nint h, w;\nvector<vector<bitset<4>>> wall;\n\nint bfs(int by, int bx, int bd, int init_step) {\n// int bfs(int by1, int bx1, int bd1, int by2, int bx2, int bd2, int init_step) {\n// cout<<\"bfs\"<<endl;\n    queue<Node> q;\n    q.push(Node(by, bx, init_step));\n//     q.push(Node(by1, bx1, init_step));\n    set<Vertex> visited;\n    while(!q.empty()) {\n        int y = get<Y>(q.front());\n        int x = get<X>(q.front());\n        int step = get<STEP>(q.front());\n        q.pop();\n        if(y == h - 1 && x == w - 1) return step;\n        if(visited.count(Vertex(y, x))) continue;\n        visited.insert(Vertex(y, x));\n// cout<<y<<\",\"<<x<<\"; \"<<step<<endl;\n        for(const auto& d: {N, E, S, W}) {\n            if(wall[y][x][d]) continue;\n            if(y == by && x == bx && d == bd) continue;\n//             if(y == by1 && x == bx1 && d == bd1) continue;\n//             if(y == by2 && x == bx2 && d == bd2) continue;\n            int ny = y + dy[d];\n            int nx = x + dx[d];\n            if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            q.push(Node(ny, nx, step + 1));\n        }\n    }\n    return INF;\n}\n\nint Dijkstra() {\n    priority_queue<DNode, vector<DNode>, greater<DNode>> q;\n    q.push(DNode(0, 0, 0, 0));\n    set<Node> visited;\n    while(!q.empty()) {\n        int worst = get<DWORST>(q.top());\n        int y = get<DY>(q.top());\n        int x = get<DX>(q.top());\n        int step = get<DSTEP>(q.top());\n        q.pop();\n        if(y == h - 1 && x == w - 1) return worst;\n        if(visited.count(Node(y, x, worst))) continue;\n        visited.insert(Node(y, x, worst));\n// cout<<y<<\",\"<<x<<\"; \"<<step<<\" ; \"<<worst<<endl;\n        for(const auto& d: {N, E, S, W}) {\n            if(wall[y][x][d]) continue;\n            int ny = y + dy[d];\n            int nx = x + dx[d];\n            if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            int nworst = max(worst, bfs(y, x, d, step));\n            if(visited.count(Node(ny, nx, nworst))) continue;\n// cout<<ny<<\",\"<<nx<<\";\"<<d<<\":\";\n//             int nworst = max(worst, bfs(y, x, d, ny, nx, (d + 2) % 2, step));\n            if(nworst == INF) continue;\n            q.push(DNode(nworst, step + 1, ny, nx));\n        }\n    }\n    return INF;\n}\n\nint main() {\n    while(cin >> h >> w, h | w) {\n        wall = vector<vector<bitset<4>>>(h, vector<bitset<4>>(w, bitset<4>(ALL)));\n        for(int i = 0; i < h - 1; ++i) {\n            for(int j = 0; j < w - 1; ++j) {\n                int is_wall;\n                cin >> is_wall;\n                if(is_wall) continue;\n                wall[i][j].reset(E);\n                wall[i][j + 1].reset(W);\n            }\n            for(int j = 0; j < w; ++j) {\n                int is_wall;\n                cin >> is_wall;\n                if(is_wall) continue;\n                wall[i][j].reset(S);\n                wall[i + 1][j].reset(N);\n            }\n        }\n        for(int j = 0; j < w - 1; ++j) {\n            int is_wall;\n            cin >> is_wall;\n            if(is_wall) continue;\n            wall[h - 1][j].reset(E);\n            wall[h - 1][j + 1].reset(W);\n        }\n\n        int answer = Dijkstra();\n        cout << (answer == INF ? -1 : answer) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<bitset>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<functional>\n#include<algorithm>\nusing namespace std;\n\nenum {N, E, S, W};\nconst unsigned long ALL = 1 + 2 + 4 + 8;\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\n\nconst int INF = 1000;\n\n// for bfs\nenum {Y, X, STEP};\ntypedef tuple<int, int, int> Node;\ntypedef tuple<int, int> Vertex;\n\n// for Dijkstra\nenum {DWORST, DSTEP, DY, DX};\ntypedef tuple<int, int, int, int> DNode;\n\nint h, w;\nvector<vector<bitset<4>>> wall;\n\nint bfs(int by, int bx, int bd, int init_step) {\n    queue<Node> q;\n    q.push(Node(by, bx, init_step));\n    set<Vertex> visited;\n    while(!q.empty()) {\n        int y = get<Y>(q.front());\n        int x = get<X>(q.front());\n        int step = get<STEP>(q.front());\n        q.pop();\n        if(y == h - 1 && x == w - 1) return step;\n        if(visited.count(Vertex(y, x))) continue;\n        visited.insert(Vertex(y, x));\n\n        for(const auto& d: {N, E, S, W}) {\n            if(wall[y][x][d]) continue;\n            if(y == by && x == bx && d == bd) continue;\n            int ny = y + dy[d];\n            int nx = x + dx[d];\n            if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            q.push(Node(ny, nx, step + 1));\n        }\n    }\n    return INF;\n}\n\nint Dijkstra() {\n    priority_queue<DNode, vector<DNode>, greater<DNode>> q;\n    q.push(DNode(-1, 0, 0, 0));\n    set<Vertex> visited;\n    while(!q.empty()) {\n        int worst = get<DWORST>(q.top());\n        int y = get<DY>(q.top());\n        int x = get<DX>(q.top());\n        int step = get<DSTEP>(q.top());\n        q.pop();\n        if(y == h - 1 && x == w - 1) return worst;\n        if(visited.count(Vertex(y, x))) continue;\n        visited.insert(Vertex(y, x));\n        for(const auto& d: {N, E, S, W}) {\n            if(wall[y][x][d]) continue;\n            int ny = y + dy[d];\n            int nx = x + dx[d];\n            if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            if(visited.count(Vertex(ny, nx))) continue;\n            int nworst = max(worst, bfs(y, x, d, step));\n            q.push(DNode(nworst, step + 1, ny, nx));\n        }\n    }\n    return INF;\n}\n\nint main() {\n    while(cin >> h >> w, h | w) {\n        wall = vector<vector<bitset<4>>>(h, vector<bitset<4>>(w, bitset<4>(ALL)));\n        for(int i = 0; i < h - 1; ++i) {\n            for(int j = 0; j < w - 1; ++j) {\n                int is_wall;\n                cin >> is_wall;\n                if(is_wall) continue;\n                wall[i][j].reset(E);\n                wall[i][j + 1].reset(W);\n            }\n            for(int j = 0; j < w; ++j) {\n                int is_wall;\n                cin >> is_wall;\n                if(is_wall) continue;\n                wall[i][j].reset(S);\n                wall[i + 1][j].reset(N);\n            }\n        }\n        for(int j = 0; j < w - 1; ++j) {\n            int is_wall;\n            cin >> is_wall;\n            if(is_wall) continue;\n            wall[h - 1][j].reset(E);\n            wall[h - 1][j + 1].reset(W);\n        }\n\n        int answer = Dijkstra();\n        cout << (answer == INF ? -1 : answer) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n,m;\nvvi H,W;\nvvi dp,T;\n\nint main(){\n\twhile(cin>>n>>m,n){\n\t\tH=vvi(n-1,vi(m));\n\t\tW=vvi(n,vi(m-1));\n\t\trep(k,n-1){\n\t\t\trep(i,m-1)cin>>W[k][i];\n\t\t\trep(i,m)cin>>H[k][i];\n\t\t}\n\t\trep(i,m-1)cin>>W[n-1][i];\n\t\tT=dp=vvi(n,vi(m));\n\t\trep(i,n-1)rep(j,m)if(H[i][j]==0){\n\t\t\tH[i][j]=1;\n\t\t\t\n\t\t\trep(x,n)rep(y,m)T[x][y]=inf;\n\t\t\tT[n-1][m-1]=0;\n\t\t\tqueue<pii>q;\n\t\t\tq.push({n-1,m-1});\n\t\t\twhile(!q.empty()){\n\t\t\t\tpii t=q.front();\n\t\t\t\tq.pop();\n\t\t\t\trep(w,4){\n\t\t\t\t\tint x=t.first+dx[w];\n\t\t\t\t\tint y=t.second+dy[w];\n\t\t\t\t\tif(x<0||y<0||x>=n||y>=m)continue;\n\t\t\t\t\tif(w==0&&W[t.first][t.second])continue;\n\t\t\t\t\tif(w==1&&H[t.first][t.second])continue;\n\t\t\t\t\tif(w==2&&W[t.first][t.second-1])continue;\n\t\t\t\t\tif(w==3&&H[t.first-1][t.second])continue;\n\t\t\t\t\tif(T[x][y]>T[t.first][t.second]+1){\n\t\t\t\t\t\tT[x][y]=T[t.first][t.second]+1;\n\t\t\t\t\t\tq.push({x,y});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(x,n)rep(y,m)dp[x][y]=max(dp[x][y],T[x][y]);\n\t\t\tH[i][j]=0;\n\t\t}\n\t\trep(i,n)rep(j,m-1)if(W[i][j]==0){\n\t\t\tW[i][j]=1;\n\t\t\t\n\t\t\trep(x,n)rep(y,m)T[x][y]=inf;\n\t\t\tT[n-1][m-1]=0;\n\t\t\tqueue<pii>q;\n\t\t\tq.push({n-1,m-1});\n\t\t\twhile(!q.empty()){\n\t\t\t\tpii t=q.front();\n\t\t\t\tq.pop();\n\t\t\t\trep(w,4){\n\t\t\t\t\tint x=t.first+dx[w];\n\t\t\t\t\tint y=t.second+dy[w];\n\t\t\t\t\tif(x<0||y<0||x>=n||y>=m)continue;\n\t\t\t\t\tif(w==0&&W[t.first][t.second])continue;\n\t\t\t\t\tif(w==1&&H[t.first][t.second])continue;\n\t\t\t\t\tif(w==2&&W[t.first][t.second-1])continue;\n\t\t\t\t\tif(w==3&&H[t.first-1][t.second])continue;\n\t\t\t\t\tif(T[x][y]>T[t.first][t.second]+1){\n\t\t\t\t\t\tT[x][y]=T[t.first][t.second]+1;\n\t\t\t\t\t\tq.push({x,y});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(x,n)rep(y,m)dp[x][y]=max(dp[x][y],T[x][y]);\n\t\t\tW[i][j]=0;\n\t\t}\n\t\trep(i,n)rep(j,m)T[i][j]=inf;\n\t\tT[0][0]=dp[0][0];\n\t\tpriority_queue<tp>q;\n\t\tq.push(tp(0,0,0));\n\t\twhile(!q.empty()){\n\t\t\tint x,y,cost;\n\t\t\ttie(cost,x,y)=q.top();\n\t\t\tcost*=-1;\n\t\t\tq.pop();\n\t\t\trep(w,4){\n\t\t\t\tint nx=x+dx[w];\n\t\t\t\tint ny=y+dy[w];\n\t\t\t\tif(nx<0||ny<0||nx>=n||ny>=m)continue;\n\t\t\t\tif(w==0&&W[x][y])continue;\n\t\t\t\tif(w==1&&H[x][y])continue;\n\t\t\t\tif(w==2&&W[x][y-1])continue;\n\t\t\t\tif(w==3&&H[x-1][y])continue;\n\t\t\t\tint ncost=max(T[x][y],cost+1+dp[nx][ny]);\n\t\t\t\tif(T[nx][ny]>ncost){\n\t\t\t\t\tT[nx][ny]=ncost;\n\t\t\t\t\tq.push(tp(-cost-1,nx,ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tshow2d(dp);\n//\t\tshow2d(T);\n\t\tif(T[n-1][m-1]==inf)T[n-1][m-1]=-1;\n\t\tcout<<T[n-1][m-1]<<endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define REP(i, n) FOR(i, 0, (n))\n\nconst int INF = 0x0f0f0f0f;\n\nint H, W;\nint n_edges;\nvector<int> adj[900];\nvector<int> edges[900];\nint dist[2*29*30][900];\nint dp[900*2][900];\n\nvoid make_edge(int y1, int x1, int y2, int x2) {\n  adj[W*y1 + x1].push_back(W*y2 + x2);\n  adj[W*y2 + x2].push_back(W*y1 + x1);\n  edges[W*y1 + x1].push_back(n_edges);\n  edges[W*y2 + x2].push_back(n_edges);\n  ++n_edges;\n}\n\nint main() {\n  while (scanf(\"%d%d\", &H, &W), H|W) {\n    n_edges = 0;\n    REP(i, H*W) { adj[i].clear(); }\n    REP(i, H*W) { edges[i].clear(); }\n\n    REP(i, 2*H-1) {\n      int l = i%2, y = i/2;\n      REP(x, W+l-1) {\n        int d; scanf(\"%d\", &d);\n        if (d == 0) { make_edge(y, x, y+l, x-l+1); }\n      }\n    }\n\n    memset(dist, INF, sizeof(dist));\n    REP(i, n_edges) {\n      queue<int> Q;\n      Q.push(H*W-1);\n      dist[i][H*W-1] = 0;\n      while (!Q.empty()) {\n        int v = Q.front(); Q.pop();\n        REP(j, adj[v].size()) {\n          int w = adj[v][j], e = edges[v][j];\n          if (e == i || dist[i][w] != INF) { continue; }\n          dist[i][w] = dist[i][v] + 1;\n          Q.push(w);\n        }\n      }\n    }\n\n    memset(dp, INF, sizeof(dp));\n    REP(k, 2*H*W) { dp[k][H*W-1] = 0; }\n    FOR(k, 1, 2*H*W) {\n      REP(v, H*W) {\n        REP(i, adj[v].size()) {\n          int w = adj[v][i], e = edges[v][i];\n          dp[k][v] = min(dp[k][v], max(dist[e][v], dp[k-1][w]+1));\n        }\n      }\n    }\n\n    printf(\"%d\\n\", dp[2*H*W-1][0] < INF ? dp[2*H*W-1][0] : -1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reps(i,a,b) for(int i=(a); i<(b); ++i)\n#define rep(i,n) reps(i,0,n)\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nstruct UnionFind{\n\tstd::vector<int> data;\n\tUnionFind(int size): data(size, -1) {}\n\n\tbool unite(int x, int y){\n\t\tx=root(x);\n\t\ty=root(y);\n\t\tif( x != y ){\n\t\t\tif( data[y] < data[x] ) std::swap(x, y);\n\t\t\tdata[x] += data[y];\n\t\t\tdata[y] = x;\n\t\t}\n\t\treturn x!=y;\n\t}\n\n\tbool find(int x, int y){\n\t\treturn root(x) == root(y);\n\t}\n\n\tint root(int x){\n\t\treturn (data[x] < 0)? x : data[x]=root(data[x]);\n\t}\n\n\tint size(int x){\n\t\treturn -data[ root(x) ];\n\t}\n};\n\n// R, U, L, D\nconst int vx[]={1,0,-1,0}, vy[]={0,1,0,-1};\n\nconst ll INF = 1e9;\n\nint h, w;\nint ans;\nmap<pii,int> cost;\nvoid solve(map<pii,int> &mp, map<pii,int> &tb, int x, int y, int d){\n\tqueue<pair<pii,int>> que;\n\tque.push( {pii(x,y), d} );\n\ttb[pii(x,y)] = d;\n\twhile(!que.empty()){\n\t\tauto cur = que.front().X;\n\t\tint x = cur.X;\n\t\tint y = cur.Y;\n\t\tint d = que.front().Y;\n\t\tque.pop();\n\t\trep(k,4){\n\t\t\tint nx = x + vx[k];\n\t\t\tint ny = y + vy[k];\n\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n\t\t\tif( mp[cur] & (1<<k) ) continue;\n\t\t\tif( !tb.count(pii(nx,ny)) || tb[pii(nx,ny)] > d + 1 ){\n\t\t\t\ttb[pii(nx,ny)] = d + 1;\n\t\t\t\tque.push( {pii(nx,ny), d+1} );\n\t\t\t}\n\t\t}\n\t}\n\tif( !tb.count(pii(w-1,h-1)) ) tb[pii(w-1,h-1)] = INF;\n\tcost[pii(x,y)] = max(cost[pii(x,y)], tb[pii(w-1,h-1)]);\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\twhile(cin >> h >> w, h|w){\n\t\tcost.clear();\n\t\tmap<pii,int> mp;\n\t\tint d;\n\t\trep(i,h-1){\n\t\t\trep(j,w-1){\n\t\t\t\tcin >> d;\n\t\t\t\tif( d == 1 ){\n\t\t\t\t\tmp[pii(j,i)]   |= (1<<0);\n\t\t\t\t\tmp[pii(j+1,i)] |= (1<<2);\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,w){\n\t\t\t\tcin >> d;\n\t\t\t\tif( d == 1 ){\n\t\t\t\t\tmp[pii(j,i)]   |= (1<<1);\n\t\t\t\t\tmp[pii(j,i+1)] |= (1<<3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint i = h-1;\n\t\trep(j,w-1){\n\t\t\tcin >> d;\n\t\t\tif( d == 1 ){\n\t\t\t\tmp[pii(j,i)]   |= (1<<0);\n\t\t\t\tmp[pii(j+1,i)] |= (1<<2);\n\t\t\t}\n\t\t}\n\t\trep(i,h) mp[pii(0,i)]   |= (1<<2);\n\t\trep(i,h) mp[pii(w-1,i)] |= (1<<0);\n\t\trep(i,w) mp[pii(i,0)]   |= (1<<3);\n\t\trep(i,w) mp[pii(i,h-1)] |= (1<<1);\n\n\t\tmap<pii,int> tb_s;\n\t\tsolve(mp, tb_s, 0, 0, 0);\n\t\tans = 0;\n//\t\trep(i,h){\n//\t\t\trep(j,w) cout << tb_s[pii(j,i)] << \" \";\n//\t\t\tcout << endl;\n//\t\t}\n\n\t\trep(y,h) rep(x,w) rep(k,4){\n\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n\t\t\tif( cost[pii(x,y)] >= INF ) continue;\n\t\t\tint nx = x + vx[k];\n\t\t\tint ny = y + vy[k];\n\t\t\tauto mp1 = mp;\n\t\t\tmp1[pii(x,y)]   |= (1<<k);\n\t\t\tmp1[pii(nx,ny)] |= (1<<((k+2)%4));\n\t\t\tmap<pii,int> tb;\n\t\t\t//solve(mp1, tb, x, y, tb_s[pii(x,y)]);\n\t\t\tsolve(mp1, tb, x, y, 0);\n\t\t\t//cout << \"solve: \" << x << \" \" << y << \" k=\" << k << endl;\n\t\t\t//rep(i,h){\n\t\t\t//\trep(j,w) cout << tb[pii(j,i)] << \" \";\n\t\t\t//\tcout << endl;\n\t\t\t//}\n\t\t}\n\n//\t\tcout << \"cost:\" << endl;\n//\t\trep(i,h){\n//\t\t\trep(j,w) cout << (cost[pii(j,i)]==INF ? 99 : cost[pii(j,i)]) << \" \";\n//\t\t\tcout << endl;\n//\t\t}\n\n\t\ttypedef pair<pii,pii> PII;\n\t\tpriority_queue<PII, vector<PII>, greater<PII>> que;\n\t\tmap<pii,pii> memo;\n\t\tque.push({{cost[pii(0,0)],0},pii(0,0)});\n\t\twhile(!que.empty()){\n\t\t\tint c = que.top().X.X;\n\t\t\tint d = que.top().X.Y;\n\t\t\tint x = que.top().Y.X;\n\t\t\tint y = que.top().Y.Y;\n\t\t\tque.pop();\n\t\t\t//if( memo.count(pii(x,y)) && memo[pii(x,y)] < pii(c,d) ) continue;\n\t\t\tif( memo.count(pii(x,y)) ) continue;\n\t\t\tmemo[pii(x,y)] = pii(c,d);\n\t\t\tans = max(ans, c);\n\t\t\tif( pii(x,y) == pii(w-1,h-1) ) break;\n\t\t\trep(k,4){\n\t\t\t\tint nx = x + vx[k];\n\t\t\t\tint ny = y + vy[k];\n\t\t\t\tint nc = d + 1 + cost[pii(nx,ny)];\n\t\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n\t\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n\t\t\t\tif( !memo.count(pii(nx,ny)) || memo[pii(nx,ny)] > pii(nc,d+1) ){\n\t\t\t\t\t//memo[pii(nx,ny)] = pii(nc, d+1);\n\t\t\t\t\tque.push( {pii(nc, d+1), pii(nx, ny)} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tpii pos = {w-1,h-1};\n//\t\tans = max(ans, memo[pos].X);\n//\t\twhile( pos != pii(0,0) ){\n//\t\t\tint x = pos.X;\n//\t\t\tint y = pos.Y;\n//\t\t\trep(k,4){\n//\t\t\t\tint nx = x + vx[k];\n//\t\t\t\tint ny = y + vy[k];\n//\t\t\t\tint nc = d + 1 + cost[pii(nx,ny)];\n//\t\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n//\t\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n//\t\t\t\tif( memo.count(pii(nx,ny)) && memo[pii(nx,ny)].Y < memo[pos].Y ){\n//\t\t\t\t\tpos = pii(nx,ny);\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tans = max(ans, memo[pos].X);\n//\t\t}\n\n//\t\tmultimap<int, pii> order;\n//\t\tfor(auto t: memo) order.insert({ t.Y.X, t.X });\n//\t\tUnionFind uf(1000);\n//\t\tfor(auto t: order){\n//\t\t\tint x = t.Y.X;\n//\t\t\tint y = t.Y.Y;\n//\t\t\trep(k,4){\n//\t\t\t\tint nx = x + vx[k];\n//\t\t\t\tint ny = y + vy[k];\n//\t\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n//\t\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n//\t\t\t\tif( memo[pii(nx,ny)].X <= t.X ){\n//\t\t\t\t\tuf.unite( nx+ny*w, x+y*w );\n//\t\t\t\t}\n//\t\t\t}\n////\t\t\tcout << \"order: \" << x << \" \" << y << \" \" << t.X << endl;\n//\t\t\tif( uf.find(0, (w-1)+(h-1)*w ) ){\n//\t\t\t\tans = t.X;\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t}\n\n\t\tcout << (ans >= INF ? -1 : ans) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<int,P>P2;\n \nint dist[30][30][30][30][4];\nint used[30][30],h,w;\nbool v[30][30][4];\n\nint ans[33][33];\n\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\n\nstring s[33];\n\nvoid bfs(int Y,int X,int K){\n    dist[h-1][w-1][Y][X][K]=0;\n    queue<int>q;\n    q.push((h-1)*1000+(w-1));\n    while(!q.empty()){\n        int now=q.front();q.pop();\n        int y=now/1000;\n        int x=now%1000;\n        r(i,4){\n            int ny=y+dy[i];\n            int nx=x+dx[i];\n            if(ny<0||nx<0||h<=ny||w<=nx)continue;\n           // cout<<y<<' '<<x<<' '<<i<<endl;\n            if(!v[y][x][i])continue;\n            if(dist[ny][nx][Y][X][K]!=-1)continue;\n\n            dist[ny][nx][Y][X][K] = dist[y][x][Y][X][K]+1;\n            q.push(ny*1000+nx);\n        }\n    }\n    //cout<<dist[0][1][Y][X][K]<<endl;\n}\n\nint bfs2(){\n    r(i,33)r(j,33)ans[i][j]=1e9;\n    memset(used,-1,sizeof(used));\n    priority_queue<P2,vector<P2>,greater<P2> >q;\n    q.push(P2(0,P(h-1,w-1)));\n    ans[h-1][w-1]=0;;\n    while(!q.empty()){\n        P2 now=q.top();q.pop();\n        int cost=now.first;\n        int y=now.second.first;\n        int x=now.second.second;\n        if(ans[y][x] < cost)continue;\n        r(i,4){\n            int ny=y+dy[i];\n            int nx=x+dx[i];\n            if(ny<0||nx<0||h<=ny||w<=nx)continue;\n            if(!v[y][x][i])continue;\n            int ncos=max(cost+1,dist[ny][nx][y][x][i]);\n            if(ans[ny][nx] <= ncos)continue;\n            ans[ny][nx] = ncos;\n            q.push(P2(ncos,P(ny,nx)));\n        }\n    }\n    return ans[0][0];\n}\n\nsigned main(){\n    while(cin>>h>>w,h){\n        getline(cin,s[0]);\n        r(i,h*2-1){\n            getline(cin,s[i]);\n        }\n        memset(dist,-1,sizeof(dist));\n        memset(v,0,sizeof(v));\n        for(int i=0;i<h*2-1;i+=2){\n            for(int j=0;j<w*2-1;j+=2){\n                for(int k=0;k<4;k++){\n                    int y=i+dy[k];\n                    int x=j+dx[k];\n                    if(y<0||x<0|| h*2-1<=y || w*2-1<=x)continue;\n                    if(s[y][x]=='0'){\n                        v[i/2][j/2][k]=1;\n                    }\n                }\n            }\n        }\n        r(i,h)r(j,w)r(k,4){\n            if(!v[i][j][k])continue;\n            v[i][j][k]=0;\n            //exit(0);\n            bfs(i,j,k);\n            v[i][j][k]=1;\n        }\n        int ANS=bfs2();\n        if(ANS==1e9)cout<<-1<<endl;\n        else cout<<ANS<<endl;\n\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nclass State\n{\npublic:\n\tint x, y, c,a;\n\tState(int x, int y, int c, int a)\n\t\t:x(x),y(y),c(c),a(a)\n\t{}\n\n\tbool operator<(const State& s) const\n\t{\n\t\treturn c > s.c;\n\t}\n};\n\nconst int INF = (1<<28);\nint W,H;\nint nodeX[32][32][32];\nint nodeY[32][32][32];\n\nint d[32][32];\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nint dijkstra(int Sx, int Sy, int Tx, int Ty)\n{\n\tqueue<State> q;\n\tq.push(State(Sx,Sy,0,0));\n\n\tbool visited[32][32] = {0};\n\n\twhile(!q.empty()) {\n\t\tState s = q.front(); q.pop();\n\t\tif(visited[s.x][s.y]) continue;\n\t\tvisited[s.x][s.y] = true;\n\n\t\t if(s.x == Tx && s.y == Ty) return s.c;\n\n\t\tfor(int i=0; i<4; i++) {\n\t\t\tint tx = s.x + dx[i];\n\t\t\tint ty = s.y + dy[i];\n\n\t\t\tif(tx<0 || ty<0 || tx>=W || ty>=H) continue;\n\n\t\t\tif(i<2) {\n\t\t\t\tif(nodeX[s.x][tx][ty]==1) continue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(nodeY[tx][s.y][ty]==1) continue;\n\t\t\t}\n\n\t\t\tif(visited[tx][ty]) continue;\n\n\t\t\tq.push(State(tx, ty, s.c+1,0));\n\t\t}\n\n\t}\n\n\treturn -1;\n}\n\nbool visited[32][32][32*32] = {0};\n\nint bfs()\n{\n\tpriority_queue<State> q;\n\tq.push(State(0,0,0,0));\n\n\tmemset(visited, 0, sizeof(visited));\n\n\twhile(!q.empty())\n\t{\n\t\tState s = q.top(); q.pop();\n\t\tint x = s.x, y = s.y;\n\n\t\tif(visited[x][y][s.a]) continue;\n\t\tvisited[x][y][s.a] = true;\n\n\t\tif(x == W-1 && y == H-1) return s.c - 1;\n\n\t\tfor(int i=0; i<4; i++) {\n\t\t\tint tx = x + dx[i];\n\t\t\tint ty = y + dy[i];\n\n\n\t\t\tif(tx<0 || ty<0 || tx>=W || ty>=H) continue;\n\n\t\t\tif(i<2) {\n\t\t\t\tif(nodeX[x][tx][ty]==1) continue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(nodeY[tx][y][ty]==1) continue;\n\t\t\t}\n\t\t\t\n\t\t\tif(s.a +1 > W*H) continue;\n\t\t\tif(visited[tx][ty][s.a+1]) continue;\n\n\n\t\t\tif(i<2) { nodeX[x][tx][ty]=1; }\n\t\t\telse {    nodeY[tx][y][ty]=1; }\n\n\t\t\tint blockcst = dijkstra(x,y,W-1,H-1); //(x,y)->(tx,ty)へ向かおうとして壁が壊れる迂回コスト\n\t\t\tint cst = max(s.a + 1 + blockcst, s.c); //max(今回起こるコスト,　今までの迂回コストの最大)\n\t\t\tif(blockcst == -1) cst = -1; //迂回不可能\n\n\t\t\tif(i<2) { nodeX[x][tx][ty]=0; }\n\t\t\telse {    nodeY[tx][y][ty]=0; }\n\n\t\t\tif(cst > 0) q.push(State(tx,ty,cst,s.a+1));\n\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint solve()\n{\n\tfor(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t{\n\t\td[j][i] = dijkstra(0,0,j,i);\n\t}\n\t\n\treturn bfs();\n}\n\nint main()\n{\n\twhile(cin >> H >> W, (W||H)) {\n\n\t\tfor(int i=0; i<H; i++) {\n\t\t\tfor(int j=0; j<W-1; j++) {\n\t\t\t\tint t;\n\t\t\t\tcin >> t;\n\t\t\t\tnodeX[j][j+1][i] = t;\n\t\t\t\tnodeX[j+1][j][i] = t;\n\t\t\t}\n\t\t\tif(i!=H-1)\n\t\t\tfor(int j=0; j<W; j++) {\n\t\t\t\tint t;\n\t\t\t\tcin >> t;\n\t\t\t\tnodeY[j][i][i+1] = t;\n\t\t\t\tnodeY[j][i+1][i] = t;\n\t\t\t}\n\t\t}\n\n\t\tcout << solve() << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\n\nint dp[2000][40][40];\nint ok[40][40][40][40];\nint wt[40][40],wy[40][40];\n\nint dist[40][40];\n\nvoid solve(){\n  int h,w;\n  cin>>h>>w;\n  if(h==0&&w==0) exit(0);\n  memset(ok,0,sizeof(ok));\n  for(int i=0;i<40;i++)\n    for(int j=0;j<40;j++)\n      wt[i][j]=wy[i][j]=1;\n  \n  for(int i=0;i<h;i++){    \n    for(int j=1;j<w;j++) cin>>wy[i][j];\n    if(i+1==h) break;\n    for(int j=0;j<w;j++) cin>>wt[i+1][j];\n  }\n    \n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(!wt[i][j]) ok[i][j][i-1][j]=1;\n      if(!wt[i+1][j]) ok[i][j][i+1][j]=1;\n      \n      if(!wy[i][j]) ok[i][j][i][j-1]=1;\n      if(!wy[i][j+1]) ok[i][j][i][j+1]=1;\n    }\n  }\n\n  auto idx=\n    [](int y,int x,int k){\n      int res=0;\n      if(k>=2) res+=1000;\n      if(k==0) x++;\n      if(k==2) y++;\n      res+=y*32+x;\n      return res;\n    };\n  \n  const int INF = 1e7;\n  int dy[]={0,0,1,-1};\n  int dx[]={1,-1,0,0};\n  auto in=[&](int y,int x){return 0<=y&&y<h&&0<=x&&x<w;};\n\n  using P = pair<int, int>;\n  auto precalc=\n    [&](int val){      \n      for(int i=0;i<h;i++)\n        for(int j=0;j<w;j++)\n          dp[val][i][j]=INF;\n      \n      queue<P> qu;\n      dp[val][h-1][w-1]=0;\n      qu.emplace(h-1,w-1);\n      \n      while(!qu.empty()){\n        int y,x;\n        tie(y,x)=qu.front();qu.pop();\n        for(int k=0;k<4;k++){\n          if(idx(y,x,k)==val) continue;\n          int ny=y+dy[k],nx=x+dx[k];\n          if(!in(ny,nx)) continue;\n          if(!ok[y][x][ny][nx]) continue;          \n          int nd=dp[val][y][x]+1;\n          if(dp[val][ny][nx]<=nd) continue;\n          dp[val][ny][nx]=nd;      \n          qu.emplace(ny,nx);\n        }\n      }\n    };\n\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){      \n      if(!wy[i][j]) precalc(idx(i,j,1));\n      if(!wt[i][j]) precalc(idx(i,j,3));\n    }\n  }      \n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      dist[i][j]=INF;\n  \n  using P = pair<int, int>;\n  using PP = pair<int, P>;\n  priority_queue<PP, vector<PP>, greater<PP> > pq;\n  \n  dist[h-1][w-1]=0;\n  pq.emplace(dist[h-1][w-1],P(h-1,w-1));\n  \n  while(!pq.empty()){\n    int d=pq.top().first;\n    int y,x;\n    tie(y,x)=pq.top().second;\n    pq.pop();\n    if(dist[y][x]<d) continue;\n    for(int k=0;k<4;k++){\n      int ny=y+dy[k],nx=x+dx[k];\n      if(!in(ny,nx)) continue;\n      if(!ok[y][x][ny][nx]) continue;\n      int nd=max(d+1,dp[idx(y,x,k)][ny][nx]);\n      if(dist[ny][nx]<=nd) continue;\n      dist[ny][nx]=nd;      \n      pq.emplace(dist[ny][nx],P(ny,nx));\n    }        \n  }\n  \n  if(dist[0][0]>=INF) dist[0][0]=-1;\n  cout<<dist[0][0]<<endl;\n}\nsigned main(){\n  while(1) solve();  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <vector>\nusing namespace std;\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) REP(i, 0, n)\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nconstexpr int MAX_SIZE = 30;\nconstexpr int MAX_N = MAX_SIZE * MAX_SIZE;\nconstexpr int INF = (1 << 29);\n\nint bfs_memo[MAX_N][MAX_N];\n\nint get_index(int x, int y, int w) {\n\treturn x + y * w;\n}\n\nvoid add_edge(int a, int b, vector<vector<int>> &G) {\n\tbool not_door;\n\tcin >> not_door;\n\n\tif(!not_door) {\n\t\tG[a].emplace_back(b);\n\t\tG[b].emplace_back(a);\n\t}\n}\n\nint bfs(int s, int no, const vector<vector<int>> &G) {\n\tif(bfs_memo[s][no] != -1) return bfs_memo[s][no];\n\n\tconst int n = G.size();\n\tvector<int> dist(n, INF);\n\tqueue<int> que;\n\tdist[s] = 0;\n\tque.push(s);\n\n\twhile(!que.empty()) {\n\t\tconst int v = que.front();\n\t\tque.pop();\n\n\t\tif(v == n - 1) break;\n\n\t\tfor(const auto &to : G[v]) {\n\t\t\tif(v == s && to == no) continue;\n\n\t\t\tif(dist[to] == INF) {\n\t\t\t\tdist[to] = dist[v] + 1;\n\t\t\t\tque.push(to);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn bfs_memo[s][no] = dist[n - 1];\n}\n\nint dfs(int v, int card, vector<vector<int>> &memo, const vector<vector<int>> &G) {\n\tconst int n = G.size();\n\tif(v == n - 1) return card;\n\tif(card >= n) return INF;\n\n\tint &res = memo[v][card];\n\tif(res != -1) return res;\n\n\tint min_select = INF;\n\tfor(const auto &to : G[v]) {\n\t\tchmax(res, bfs(v, to, G) + card);\n\t\tchmin(min_select, dfs(to, card + 1, memo, G));\n\t}\n\n\tchmax(res, min_select);\n\tchmin(res, INF);\n\treturn res;\n}\n\nint solve(const vector<vector<int>> &G) {\n\tconst int n = G.size();\n\tmemset(bfs_memo, -1, sizeof(bfs_memo));\n\tvector<vector<int>> memo(n, vector<int>(n, -1));\n\tconst int ans = dfs(0, 0, memo, G);\n\treturn ans == INF ? -1 : ans;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int h, w; cin >> h >> w && h;) {\n\t\tconst int n = h * w;\n\t\tvector<vector<int>> G(n);\n\n\t\trep(y, h) {\n\t\t\trep(x, w - 1) {\n\t\t\t\tadd_edge(get_index(x, y, w), get_index(x + 1, y, w), G);\n\t\t\t}\n\n\t\t\tif(y < h - 1) {\n\t\t\t\trep(x, w) {\n\t\t\t\t\tadd_edge(get_index(x, y, w), get_index(x, y + 1, w), G);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << solve(G) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\nvector<string> line;\n\nstruct NODE{\n\tint id,cost,maximum;\n\tNODE(int id,int cost,int maximum) : id(id),cost(cost),maximum(maximum){}\n};\n\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.maximum > b.maximum;\n}\n\nmap< pair<int,int> , int> tmp;\nmap<int,int> XX,YY;\n\nint id(int x,int y){\n\tif( tmp.count(make_pair(x,y)) ) return tmp[make_pair(x,y)];\n\tint c = tmp.size();\n\tXX[c] = x;\n\tYY[c] = y;\n\treturn tmp[make_pair(x,y)] = c;\n}\n\nint X(int id){ return XX[id]; }\nint Y(int id){ return YY[id]; }\n\nint dx[] = { 0, 1, 0,-1};\nint dy[] = { 1, 0,-1, 0};\n\n\nint done[910]={};\n\nint main(){\n\tint H,W;\n\twhile(cin >> H >> W && H){\n\t\tint s = id(0,0);\n\t\tint g = id(2*W-2,2*H-2);\n\t\t\n\t\tline = vector<string>(H*2-1);\n\t\tgetline(cin,line[0]); //dummy\n\t\tfor(int i = 0 ; i < H*2-1 ; i++){\n\t\t\tgetline(cin,line[i]);\n\t\t\tif(!(i&1))line[i] += \" \";\n\t\t}\n\t\t\n\t\tint dir[62][62][2];\n\t\tfor(int i = 0 ; i < 62 ; i++)\n\t\t\tfor(int j = 0 ; j < 62 ; j++)\n\t\t\t\tfor(int k = 0 ; k < 2 ; k++)\n\t\t\t\t\tdir[i][j][k] = 1e9;\n\t\n\t\tint maximum = 0;\n\t\tfor(int y = 0 ; y < 2*H-1 ; y++){\n\t\t\tfor(int x = 0 ; x < 2*W ; x++){\n\t\t\t\tif( line[y][x] != '0' ) continue;\n\t\t\t\tline[y][x] = '1';\n\t\t\t\tint c1,c2;\n\t\t\t\tif( y % 2 == 0 ){\n\t\t\t\t\tc1 = id(x-1,y);\n\t\t\t\t\tc2 = id(x+1,y);\n\t\t\t\t}else{\n\t\t\t\t\tc1 = id(x,y-1);\n\t\t\t\t\tc2 = id(x,y+1);\n\t\t\t\t}\n\t\t\t\tfor(int k = 0 ; k < 2 ; k++){\n\t\t\t\t\t// test\n\t\t\t\t\tint tmp[2000];\n\t\t\t\t\tmemset(tmp,-1,sizeof(tmp));\n\t\t\t\t\tqueue<int> Q;\n\t\t\t\t\ttmp[c1] = 0;\n\t\t\t\t\tQ.push(c1);\n\t\t\t\t\twhile(Q.size()){\n\t\t\t\t\t\tint q = Q.front(); Q.pop();\n\t\t\t\t\t\tfor(int i = 0 ; i < 4 ; i++){\n\t\t\t\t\t\t\tint tx = X(q) + dx[i];\n\t\t\t\t\t\t\tint ty = Y(q) + dy[i];\n\t\t\t\t\t\t\tif( tx < 0 || tx >= line[0].size() || ty < 0 || ty >= line.size() || line[ty][tx] == '1') continue;\n\t\t\t\t\t\t\tint next = id(tx+dx[i],ty+dy[i]);\n\t\t\t\t\t\t\tif( tmp[next] == -1 ){\n\t\t\t\t\t\t\t\ttmp[next]=tmp[q]+1;\n\t\t\t\t\t\t\t\tQ.push(next);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif( tmp[g] != -1 ) \n\t\t\t\t\t\tdir[y][x][k] = tmp[g];\n\t\t\t\t\tswap(c1,c2);\n\t\t\t\t}\n\t\t\t\tline[y][x] = '0';\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < 910 ; i++)\n\t\t\tdone[i] = 1e9;\n\t\t\n\t\tpriority_queue<NODE> Q;\n\t\t\n\t\tQ.push(NODE(s,0,0));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\t\n\t\t\t\n\t\t\tif( q.cost > 905 ){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( done[q.id] < q.cost+q.maximum ) continue;\n\t\t\tdone[q.id] = q.cost+q.maximum;\n\t\t\t\n\t\t\tif( q.maximum > 1e8 ) continue;\n\t\t\tif( q.id == g ){\n\t\t\t\tcout << q.maximum << endl;\n\t\t\t\tgoto veryok;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < 4 ; i++){\n\t\t\t\tint tx = X(q.id) + dx[i];\n\t\t\t\tint ty = Y(q.id) + dy[i];\n\t\t\t\tif( tx < 0 || tx >= line[0].size() || ty < 0 || ty >= line.size() || line[ty][tx] == '1') continue;\n\t\t\t\tint next = id(tx+dx[i],ty+dy[i]);\n\t\t\t\tint cost = q.cost + 1;\n\t\t\t\tint maximum = q.cost;\n\t\t\t\tif( ty % 2 == 0 ){\n\t\t\t\t\tif( dx[i] == 1 ) maximum += dir[ty][tx][0];\n\t\t\t\t\telse \t\t\t maximum += dir[ty][tx][1];\n\t\t\t\t}else{\n\t\t\t\t\tif( dy[i] == 1 ) maximum += dir[ty][tx][0];\n\t\t\t\t\telse \t\t\t maximum += dir[ty][tx][1];\n\t\t\t\t}\n\t\t\t\tif( cost+max(q.maximum,maximum) >= done[next] ) continue;\n\t\t\t\tdone[next] = cost+max(q.maximum,maximum);\n\t\t\t\tQ.push(NODE(next,cost,max(q.maximum,maximum)));\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\tveryok:;\n\t\t/*\n\t\tcout << 2*H-1 << \" \" << 2*W-1 << endl;\n\t\tcout << shortest[id(2*H-1,2*W-1)] << endl;\n\t\t\n\t\tfor(int i = 0 ; i < 2*H-1 ; i++){\n\t\t\tfor(int j = 0 ; j < 2*W ; j++){\n\t\t\t\tif( shortest[id(j,i)] == -1 ) printf(\"     \");\n\t\t\t\telse  printf(\"%5d(%d,%d)\",shortest[id(j,i)],j,i);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <utility>\n#define INF 1000\nusing namespace std;\ntypedef pair<int,int> P;\n\nstruct data{\n\tint x,y,c,dc;\n\tdata(int xx,int yy,int cc,int dd){\n\t\tx=xx;\n\t\ty=yy;\n\t\tc=cc;\n\t\tdc=dd;\n\t}\n\n\tbool operator<(const data& d1)const{\n\t\treturn d1.c>c;\n\t}\n};\n\nint h,w;\n\nint fie[61][61];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint dp[61][61][901];\nint cost[61][61][4];\nint used[61][61];\n\nint bfs(int sx,int sy){\n\tqueue<P> que;\n\tque.push(P(sx,sy));\n\tmemset(used,-1,sizeof(used));\n\tused[sx][sy]=0;\n\twhile(que.size()){\n\t\tP q=que.front();\n\t\tque.pop();\n\t\tint x=q.first,y=q.second;\n\t\tif(x==(w-1)*2 && y==(h-1)*2)return used[x][y];\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\tif(nx>=0 && nx<w*2-1 && ny>=0 && ny<h*2-1){\n\t\t\t\tif(fie[nx][ny]==1)continue;\n\t\t\t\tnx+=dx[i];\n\t\t\t\tny+=dy[i];\n\t\t\t\tif(used[nx][ny]==-1){\n\t\t\t\t\tused[nx][ny]=used[x][y]+1;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn INF;\n}\n\nint dijk(){\n\tpriority_queue<data> que;\n\tque.push(data(0,0,0,0));\n\tfor(int i=0;i<=60;i++){\n\t\tfor(int j=0;j<=60;j++){\n\t\t\tfor(int k=0;k<=900;k++){\n\t\t\t\tdp[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tque.push(data(0,0,0,0));\n\tdp[0][0][0]=0;\n\twhile(que.size()){\n\t\tdata d=que.top();\n\t\tque.pop();\n\t\tif(dp[d.x][d.y][d.c]!=d.dc)continue;\n\t\t//printf(\"%d %d %d %d\\n\",d.x,d.y,d.c,d.dc);\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(cost[d.x][d.y][i]==INF)continue;\n\t\t\tint nx=d.x+dx[i]*2,ny=d.y+dy[i]*2;\n\t\t\tif(nx>=0 && nx<w*2-1 && ny>=0 && ny<h*2-1){\n\t\t\t\tint ndc=max(d.dc,cost[d.x][d.y][i]+d.c);\n\t\t\t\tif(dp[nx][ny][d.c+1]>ndc && d.c<900){\n\t\t\t\t\tdp[nx][ny][d.c+1]=ndc;\n\t\t\t\t\tque.push(data(nx,ny,d.c+1,ndc));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res=INF;\n\tfor(int i=0;i<=900;i++){\n\t\tres=min(res,dp[(w-1)*2][(h-1)*2][i]);\n\t}\n\tif(res==INF)return -1;\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tif(h==0 && w==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<2*h-1;i++){\n\t\t\tif(i%2==0){\n\t\t\t\tfor(int j=0;j<w-1;j++){\n\t\t\t\t\tscanf(\"%d\",&fie[j*2+1][i]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tscanf(\"%d\",&fie[j*2][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<2*h-1;i+=2){\n\t\t\tfor(int j=0;j<w*2;j+=2){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint x=j+dx[k],y=i+dy[k];\n\t\t\t\t\tif(x>=0 && x<w*2-1 && y>=0 && y<w*2-1){\n\t\t\t\t\t\tif(fie[x][y]==0){\n\t\t\t\t\t\t\tfie[x][y]=1;\n\t\t\t\t\t\t\tcost[j][i][k]=bfs(j,i);\n\t\t\t\t\t\t\tfie[x][y]=0;\n\t\t\t\t\t\t}else cost[j][i][k]=INF;\n\t\t\t\t\t}else cost[j][i][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\nconstexpr int diry[] = {0, 1, 0, -1};  // >,v,<,^\nconstexpr int dirx[] = {1, 0, -1, 0};  // >,v,<,^\nconstexpr int sx = 0;\nconstexpr int sy = 0;\nconstexpr int INF = 1 << 30;\n\nint main()\n{\n    while (true) {\n        int h, w;\n        cin >> h >> w;\n        if (h == 0 and w == 0) {\n            break;\n        }\n\n\n        const int gy = h - 1;\n        const int gx = w - 1;\n        vector<vector<bool>> yoko(h, vector<bool>(w - 1, false));  // (i,j)->(i,j+1)\n        vector<vector<bool>> tate(h - 1, vector<bool>(w, false));  // (i,j)->(i+1,j)\n        for (int i = 0; i < 2 * h - 1; i++) {\n            for (int j = 0; j < ((i % 2 == 0) ? w - 1 : w); j++) {\n                int c;\n                cin >> c;\n                ((i % 2 == 0) ? yoko : tate)[i / 2][j] = (c == 1);\n            }\n        }\n        auto ok = [&](const int y, const int x, const int dir) -> bool {  // >,v,<,^\n            if (dir == 0) {\n                if (x == w - 1) {\n                    return false;\n                } else {\n                    return not yoko[y][x];\n                }\n            } else if (dir == 1) {\n                if (y == h - 1) {\n                    return false;\n                } else {\n                    return not tate[y][x];\n                }\n\n            } else if (dir == 2) {\n                if (x == 0) {\n                    return false;\n                } else {\n                    return not yoko[y][x - 1];\n                }\n\n            } else {\n                if (y == 0) {\n                    return false;\n                } else {\n                    return not tate[y - 1][x];\n                }\n            }\n        };\n        vector<vector<int>> distance(h, vector<int>(w, INF));\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                int maxi = 0;\n                for (int k = 0; k < 4; k++) {  // >,v,<,^\n                    if (k == 0) {\n                        if (j == w - 1 or yoko[i][j]) {\n                            continue;\n                        }\n                        yoko[i][j] = true;\n                    } else if (k == 1) {\n                        if (i == h - 1 or tate[i][j]) {\n                            continue;\n                        }\n                        tate[i][j] = true;\n                    } else if (k == 2) {\n                        if (j == 0 or yoko[i][j - 1]) {\n                            continue;\n                        }\n                        yoko[i][j - 1] = true;\n                    } else if (k == 3) {\n                        if (i == 0 or tate[i - 1][j]) {\n                            continue;\n                        }\n                        tate[i - 1][j] = true;\n                    }\n                    vector<vector<bool>> used(h, vector<bool>(w, false));\n                    queue<pair<P, int>> q;\n                    q.push(make_pair(make_pair(i, j), 0));\n                    used[i][j] = true;\n                    int ans = INF;\n                    while (not q.empty()) {\n                        const P pos = q.front().first;\n                        const int y = pos.first;\n                        const int x = pos.second;\n                        const int dist = q.front().second;\n                        if (y == gy and x == gx) {\n                            ans = dist;\n                            break;\n                        }\n                        q.pop();\n                        for (int d = 0; d < 4; d++) {\n                            if (ok(y, x, d)) {\n                                const int newy = y + diry[d];\n                                const int newx = x + dirx[d];\n                                if (not used[newy][newx]) {\n                                    used[newy][newx] = true;\n                                    q.push(make_pair(make_pair(newy, newx), dist + 1));\n                                }\n                            }\n                        }\n                    }\n                    maxi = max(maxi, ans);\n\n                    if (k == 0) {\n                        yoko[i][j] = false;\n                    } else if (k == 1) {\n                        tate[i][j] = false;\n                    } else if (k == 2) {\n                        yoko[i][j - 1] = false;\n                    } else if (k == 3) {\n                        tate[i - 1][j] = false;\n                    }\n                }\n                distance[i][j] = maxi;\n            }\n        }\n        // show(distance);\n\n        int inf = 0;\n        int sup = INF;\n        while (inf < sup) {\n            const int mid = (inf + sup) / 2;\n            bool goal = false;\n            vector<vector<bool>> used(h, vector<bool>(w, false));\n            queue<pair<P, int>> q;\n            q.push(make_pair(make_pair(sy, sx), 0));\n            used[sy][sx] = true;\n            while (not q.empty()) {\n                const P pos = q.front().first;\n                const int y = pos.first;\n                const int x = pos.second;\n                if (y == gy and x == gx) {\n                    goal = true;\n                    break;\n                }\n                const int dist = q.front().second;\n                q.pop();\n                for (int d = 0; d < 4; d++) {\n                    if (ok(y, x, d)) {\n                        const int newy = y + diry[d];\n                        const int newx = x + dirx[d];\n                        if (not used[newy][newx] and distance[newy][newx] + dist + 1 <= mid) {\n                            used[newy][newx] = true;\n                            q.push(make_pair(make_pair(newy, newx), dist + 1));\n                        }\n                    }\n                }\n            }\n            if (goal) {\n                sup = mid;\n            } else {\n                if (inf == mid) {\n                    break;\n                }\n                inf = mid;\n            }\n        }\n        if (sup == INF) {\n            cout << -1 << endl;\n        } else {\n            cout << sup << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nbool tate[32][32], yoko[32][32], v[32][32][900];\nint cy[32][32][32][32], ct[32][32][32][32];\nint h, w;\n\nvoid calc(int c[32][32]){\n\tqueue<int> q;\n\tc[h - 1][w - 1] = 0;\n\tq.push(h * w - 1);\n\twhile(!q.empty()){\n\t\tint y = q.front() / w, x = q.front() % w;\n\t\tq.pop();\n\t\trep(d, 4){\n\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\tif(d % 2 && tate[ny][max(nx, x)] || d % 2 == 0 && yoko[max(ny, y)][nx]) continue;\n\t\t\tif(c[ny][nx] <= c[y][x] + 1) continue;\n\t\t\tc[ny][nx] = c[y][x] + 1;\n\t\t\tq.push(ny * w + nx);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> h >> w, h){\n\t\tmemset(tate, 1, sizeof(tate));\n\t\tmemset(yoko, 1, sizeof(yoko));\n\t\tmemset(v, 0, sizeof(v));\n\t\t\n\t\trep(i, h){\n\t\t\trep(j, w - 1) cin >> tate[i][j + 1];\n\t\t\tif(i < h - 1) rep(j, w) cin >> yoko[i + 1][j];\n\t\t}\n\t\trep(i, h) rep(j, w){\n\t\t\trep(k, h) rep(l, w) ct[i][j][k][l] = cy[i][j][k][l] = inf;\n\t\t\tif(!tate[i][j]){\n\t\t\t\ttate[i][j] = 1;\n\t\t\t\tcalc(ct[i][j]);\n\t\t\t\ttate[i][j] = 0;\n\t\t\t}\n\t\t\tif(!yoko[i][j]){\n\t\t\t\tyoko[i][j] = 1;\n\t\t\t\tcalc(cy[i][j]);\n\t\t\t\tyoko[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpriority_queue<pair<pi, int> > q;\n\t\tq.push(mp(mp(0, 0), 0));\n\t\tint ans = inf;\n\t\twhile(!q.empty()){\n\t\t\tint cost = -q.top().first.first, step = -q.top().first.second;\n\t\t\tint y = q.top().second / w, x = q.top().second % w;\n\t\t\tq.pop();\n\t\t\t\n\t\t\tif(v[y][x][step]) continue;\n\t\t\tv[y][x][step] = 1;\n\t\t\tif(y == h - 1 && x == w - 1){\n\t\t\t\tcout << cost << endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t\trep(d, 4){\n\t\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\t\t\n\t\t\t\tint goal = d % 2 ? ct[ny][max(x, nx)][y][x] : cy[max(ny, y)][nx][y][x];\n\t\t\t\tif(goal >= inf) continue;\n\t\t\t\t\n\t\t\t\tint nc = max(step + 1, max(cost, step + goal));\n\t\t\t\tif(!v[ny][nx][step + 1] && nc < inf) q.push(mp(mp(-nc, -step - 1), ny * w + nx));\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\tEND:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nconst int INF=10000000;\nint dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Node{\npublic:\n\tint x,y,cost;\n\tNode(int x,int y,int cost):x(x),y(y),cost(cost){}\n};\n\nbool operator < (Node a,Node b){\n\treturn a.cost>b.cost;\n}\n\n\nint H,W;\n\nvoid bfs(vector<vector<int> > &cost,vector<vector<bool> > right,vector<vector<bool> >upper,int sx,int sy){\n\tcost.clear();\n\tcost.resize(H,vector<int>(W,INF));\n\tqueue<Node> que;\n\tque.push(Node(sx,sy,0));\n\twhile(!que.empty()){\n\t\tNode now=que.front(); que.pop();\n\t\tif(cost[now.y][now.x]<=now.cost) continue;\n\t\tcost[now.y][now.x]=now.cost;\n\t\tif(right[now.y][now.x]) que.push(Node(now.x+1,now.y,now.cost+1));\n\t\tif(now.x-1>=0 && right[now.y][now.x-1]) que.push(Node(now.x-1,now.y,now.cost+1));\n\t\tif(upper[now.y][now.x]) que.push(Node(now.x,now.y-1,now.cost+1));\n\t\tif(now.y+1<H && upper[now.y+1][now.x]) que.push(Node(now.x,now.y+1,now.cost+1));\n\t}\n}\n\nint main()\n{\n\twhile(cin>>H>>W && H!=0){\n\t\tvector<vector<bool> >right(H,vector<bool>(W,false));\n\t\tvector<vector<bool> >upper(H,vector<bool>(W,false));\n\t\tfor(int x=0;x<W-1;x++){\n\t\t\tint t;cin>>t;\n\t\t\tif(t==0) right[0][x]=true;\n\t\t}\n\t\tfor(int y=1;y<H;y++){\n\t\t\tfor(int x=0;x<W;x++){\n\t\t\t\tint t;cin>>t;\n\t\t\t\tif(t==0) upper[y][x]=true;\n\t\t\t}\n\t\t\tfor(int x=0;x<W-1;x++){\n\t\t\t\tint t;cin>>t;\n\t\t\t\tif(t==0) right[y][x]=true;\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int> > first_cost;\n\t\tbfs(first_cost,right,upper,0,0);\n\n\t\tvector<vector<int> > second_cost(H,vector<int>(W,0));\n\t\tfor(int y=0;y<H;y++){\n\t\t\tfor(int x=0;x<W;x++){\n\t\t\t\tif(upper[y][x]){\n\t\t\t\t\tupper[y][x]=false;\n\t\t\t\t\tvector<vector<int> > temp;\n\t\t\t\t\tbfs(temp,right,upper,W-1,H-1);\n\t\t\t\t\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++) second_cost[i][j]=max(second_cost[i][j],temp[i][j]);\n\t\t\t\t\tupper[y][x]=true;\n\t\t\t\t}\n\t\t\t\tif(right[y][x]){\n\t\t\t\t\tright[y][x]=false;\n\t\t\t\t\tvector<vector<int> > temp;\n\t\t\t\t\tbfs(temp,right,upper,W-1,H-1);\n\t\t\t\t\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++) second_cost[i][j]=max(second_cost[i][j],temp[i][j]);\n\n\t\t\t\t\tright[y][x]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int> > cost(H,vector<int>(W,INF));\n\t\tfor(int y=0;y<H;y++)for(int x=0;x<W;x++)cost[y][x]=first_cost[y][x]+second_cost[y][x];\n\n\t\tvector<vector<int> > ans(H,vector<int>(W,INF));\n\t\tpriority_queue<Node> que;\n\t\tque.push(Node(0,0,cost[0][0]));\n\t\twhile(!que.empty()){\n\t\t\tNode now=que.top();\n\t\t\tque.pop();\n\t\t\tnow.cost=max(now.cost,cost[now.y][now.x]);\n\t\t\tif(now.cost>=ans[now.y][now.x]) continue;\n\t\t\tans[now.y][now.x]=now.cost;\n\t\t\tif(right[now.y][now.x]) que.push(Node(now.x+1,now.y,now.cost));\n\t\t\tif(now.x-1>=0 && right[now.y][now.x-1]) que.push(Node(now.x-1,now.y,now.cost));\n\t\t\tif(upper[now.y][now.x]) que.push(Node(now.x,now.y-1,now.cost));\n\t\t\tif(now.y+1<H && upper[now.y+1][now.x]) que.push(Node(now.x,now.y+1,now.cost));\n\t\t}\n\t\tif(ans[H-1][W-1]>=INF) cout<<-1<<endl;\n\t\telse cout<<ans[H-1][W-1]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint W, H;\nint Wall[2][40][40];\nint dist[2][33][33][33][33];\n\nint d[4][2]={{1, 0},{0, 1},{-1, 0},{0, -1}};\nint e[4][2]={{0, 0},{1, 0},{0, 1},{1, 1}};\n\nint memo[33][33];\n\nint bfs(int x, int y){\n\tpriority_queue<pipii, vector<pipii>, greater<pipii> > q;\n\tq.emplace(0, pii(H, W));\n\tmemo[H][W] = 0;\n\twhile(!q.empty()){\n\t\tint x=q.top().second.second;\n\t\tint y=q.top().second.first;\n\t\tq.pop();\n\t\tREP(di, 4){\n\t\t\tint dy = y+d[di][1];\n\t\t\tint dx = x+d[di][0];\n\t\t\tif(!Wall[e[di][0]][y+d[di][1]*e[di][1]][x+d[di][0]*e[di][1]]){\n\t\t\t\tint c = max(memo[y][x]+1, dist[e[di][0]][y+d[di][1]*e[di][1]][x+d[di][0]*e[di][1]][dy][dx]);\n\t\t\t\tif(memo[dy][dx] > c){\n\t\t\t\t\tmemo[dy][dx] = c;\n\t\t\t\t\tq.emplace(c, pii(dy, dx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[1][1];\n}\n\nmain(){\n\twhile(cin >> H >> W, H){\n\t\tmemset(memo, 63, sizeof(memo));\n\t\tmemset(Wall,  -1, sizeof(Wall));\n\t\tmemset(dist, 63, sizeof(dist));\n\t\tint ans;\n\t\tREP(i, H-1){\n\t\t\tREP(j, W-1) cin >> Wall[0][i+1][j+1];\n\t\t\tREP(j, W)   cin >> Wall[1][i+1][j+1];\n\t\t}\n\t\tREP(j, W-1) cin >> Wall[0][H][j+1];\n\t\tREP(i, H+1)REP(j, W+1)REP(k, 2){\n\t\t\tif(Wall[k][i][j] && !(!k&&!i&&!j)) continue;\n\t\t\tWall[k][i][j] = 1;\n\t\t\t\n\t\t\tdist[k][i][j][H][W] = 0;\n\t\t\tqueue<pii> q;\n\t\t\tq.emplace(H, W);\n\t\t\twhile(!q.empty()){\n\t\t\t\tint x=q.front().second;\n\t\t\t\tint y=q.front().first;\n\t\t\t\tq.pop();\n\t\t\t\tREP(di, 4){\n\t\t\t\t\tint dy = y+d[di][1];\n\t\t\t\t\tint dx = x+d[di][0];\n\t\t\t\t\tif(!Wall[e[di][0]][y+d[di][1]*e[di][1]][x+d[di][0]*e[di][1]] && dist[k][i][j][dy][dx] > dist[k][i][j][y][x]+1){\n\t\t\t\t\t\tdist[k][i][j][dy][dx] = dist[k][i][j][y][x]+1;\n\t\t\t\t\t\tq.push(pii(dy, dx));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tWall[k][i][j] = 0;\n\t\t\t\n\t\t}\n\t\tint a, b, c;\n\t\tmemo[W][H] = 0;\n\t\tint res = bfs(W,H);\n\t\tcout << (res>900?-1:res) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * by purple\n * at 12-01-01 13:05:26\n */\n\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define sz(x) ((int)((x).size()))\n#define out(x) printf(#x\" %d\\n\", x)\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repf(i,a,b) for(int i=(a);i<=(b);++i)\n\nconst int maxn = 32;\nconst int inf = 1024;\n\nint c[maxn][maxn][2];\nint dis[maxn][maxn];\nint opt[maxn][maxn];\nint n, m;\n\nint gao(int x, int y) {\n    queue<int> q;\n    memset (dis, -1, sizeof(dis));\n    dis[x][y] = 0;\n    q.push(x), q.push(y);\n    while (!q.empty()) {\n        int x = q.front(); q.pop();\n        int y = q.front(); q.pop();\n        if (x == n - 1 && y == m - 1) {\n            return dis[x][y];\n        }\n        if (x > 0 && !c[x - 1][y][1] && dis[x - 1][y] == -1) {\n            dis[x - 1][y] = dis[x][y] + 1;\n            q.push(x - 1), q.push(y);\n        }\n        if (x < n - 1 && !c[x][y][1] && dis[x + 1][y] == -1) {\n            dis[x + 1][y] = dis[x][y] + 1;\n            q.push(x + 1), q.push(y);\n        }\n        if (y > 0 && !c[x][y - 1][0] && dis[x][y - 1] == -1) {\n            dis[x][y - 1] = dis[x][y] + 1;\n            q.push(x), q.push(y - 1);\n        }\n        if (y < m - 1 && !c[x][y][0] && dis[x][y + 1] == -1) {\n            dis[x][y + 1] = dis[x][y] + 1;\n            q.push(x), q.push(y + 1);\n        }\n    }\n    return inf;\n}\n\nvoid update(int& x, int y) {\n    if (x == -1 || x > y) x = y;\n}\n\nint gao() {\n    rep (i, n) rep (j, m) {\n        opt[i][j] = inf;\n    }\n    opt[n - 1][m - 1] = 0;\n    while (true) {\n        bool f = false;\n        rep (i, n) rep (j, m) {\n            int now = opt[i][j];\n            if (i > 0 && !c[i - 1][j][1] && opt[i - 1][j] + 1 < opt[i][j]) {\n                c[i - 1][j][1] = true;\n                update (now, max(opt[i - 1][j] + 1, gao(i, j)));\n                c[i - 1][j][1] = false;\n            }\n            if (i < n - 1 && !c[i][j][1] && opt[i + 1][j] + 1 < opt[i][j]) {\n                c[i][j][1] = true;\n                update (now, max(opt[i + 1][j] + 1, gao(i, j)));\n                c[i][j][1] = false;\n            }\n            if (j > 0 && !c[i][j - 1][0] && opt[i][j - 1] + 1 < opt[i][j]) {\n                c[i][j - 1][0] = true;\n                update (now, max(opt[i][j - 1] + 1, gao(i, j)));\n                c[i][j - 1][0] = false;\n            }\n            if (j < m - 1 && !c[i][j][0] && opt[i][j + 1] + 1 < opt[i][j]) {\n                c[i][j][0] = true;\n                update (now, max(opt[i][j + 1] + 1, gao(i, j)));\n                c[i][j][0] = false;\n            }\n            if (now != opt[i][j]) {\n                opt[i][j] = now;\n                f = true;\n            } \n        }\n        if (!f) {\n            break;\n        }\n    }\n    return opt[0][0] == inf? -1 : opt[0][0];\n}\n\nint main() {\n    while (scanf (\"%d%d\", &n, &m), n || m) {\n        rep (i, n - 1) {\n            rep (j, m - 1) {\n                scanf (\"%d\", &c[i][j][0]);\n            }\n            rep (j, m) {\n                scanf (\"%d\", &c[i][j][1]);\n            }\n        }\n        rep (j, m - 1) {\n            scanf (\"%d\", &c[n - 1][j][0]);\n        }\n        printf (\"%d\\n\", gao());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 100000\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\nstruct edge{\n    int x, y;\n};\n\nint h, w;\nvector<edge> E[32][32];\n\nbool input(){\n    cin >> h >> w;\n    if(!h and !w) return 0;\n    rep(i,32)rep(j,32) E[i][j].clear();\n    rep(y,h){\n        rep(x,w-1){\n            int t; cin >> t;\n            if(!t){\n                E[x][y].pb((edge){x+1,y});\n                E[x+1][y].pb((edge){x,y});\n            }\n        }\n        if(y == h-1) continue;\n        rep(x,w){\n            int t; cin >> t;\n            if(!t){\n                E[x][y].pb((edge){x,y+1});\n                E[x][y+1].pb((edge){x,y});\n            }\n        }\n    }\n    return 1;\n}\n\nint doorCost[32][32][4];\nstruct node {\n    int x, y, cst;\n};\nint calcCost(int sx, int sy, int gx, int gy, int tx, int ty) {\n    queue<node> q;\n    q.push((node){sx, sy, 0});\n    int done[32][32] = {0};\n    while(q.size()) {\n        int x = q.front().x;\n        int y = q.front().y;\n        int cst = q.front().cst; q.pop();\n        if(done[x][y]) continue;\n        done[x][y] = true;\n        if(x == gx and y == gy) {\n            return cst;\n        }\n        rep(i, E[x][y].size()) {\n            edge &e = E[x][y][i];\n            if(x == sx and y == sy and e.x == tx and e.y == ty) continue;\n            if(e.x == sx and e.y == sy and x == tx and y == ty) continue;\n            q.push((node){e.x, e.y, cst+1});\n        }\n    }\n    return INF;\n}\n\nvoid calcDoorCost() {\n    rep(y, h) rep(x, w) rep(i, 4) doorCost[x][y][i] = INF;\n    rep(y, h) rep(x, w) {\n        rep(i, E[x][y].size()) {\n            edge &e = E[x][y][i];\n            doorCost[x][y][i] = calcCost(x, y, w-1, h-1, e.x, e.y);\n        }\n    }\n}\n\nstruct nd {\n    int x, y, cst, step;\n    vector<pair<int, int> > route;\n    bool operator<(const nd &o) const {\n        return cst > o.cst;\n    }\n};\nint solve() {\n    calcDoorCost();\n    priority_queue<nd> pq;\n    pq.push((nd){0, 0, 0, 0,vector<pair<int, int> >()});\n    const int lim = 256;\n    int done[32][32][lim] = {0};\n    int ret = INF;\n    while(pq.size()) {\n        int x = pq.top().x;\n        int y = pq.top().y;\n        int cst = pq.top().cst;\n        int step = pq.top().step;\n        vector<pair<int, int> > route = pq.top().route;\n        pq.pop();\n        if(step > lim) continue;\n        if(done[x][y][step]) continue;\n        done[x][y][step] = true;\n        if(x == w-1 and y == h-1) {\n            /*\n            cout << route.size() << endl;\n            rep(i, route.size()) {\n                cout << route[i].first << \" \" << route[i].second << endl;\n            }\n            cout << endl;*/\n            ret = min(ret, cst);\n            return ret;\n        }\n        rep(i, E[x][y].size()) {\n            edge &e = E[x][y][i];\n            vector<pair<int, int> > tv = route;\n            tv.pb(mp(x, cst));\n            pq.push((nd){e.x, e.y, max(cst, step + doorCost[x][y][i]),step+1, tv});\n        }\n    }\n    return ret;\n}\n\nint main()\n{\n    while(input()){\n        int ans = solve();\n        if(ans < INF) cout << ans << endl;\n        else cout << -1 << endl;\n    } \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif\n\nusing namespace std;\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<map>\n#include<string.h>\n#include<tuple>\n#include<map>\n#include<queue>\n#include<deque>\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef long long LL;\ntemplate<typename T>\nbool chmin(T &l, T r) {\n\tbool f = l > r; if (f)l = r; return f;\n}\ntemplate<typename T>\nbool chmax(T &l, T r) {\n\tbool f = l < r; if (f)l = r; return f;\n}\n\n\nconst int dr[] = { 1,-1,0,0 };\nconst int dc[] = { 0,0,1,-1 };\nint R, C;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int,int> A;\n#define DCp(r,c,a) int r,c;tie(r,c)=a;\n#define DCa(cost,r,c,w,a) int cost,r,c,w;tie(cost,r,c,w)=a;cost*=-1;\nint g[30][30][4];\nint p[30][30][4];\nbool mindist(int sr, int sc, int k) {\n\tif (g[sr][sc][k] != 0)return true;\n\tVV d(R, V(C, 114514));\n\tg[sr][sc][k] = 1;\n\td[sr][sc] = 0;\n\tqueue<P> que;\n\tque.push(P(sr, sc));\n\twhile (que.size()) {\n\t\tDCp(r, c, que.front()); que.pop();\n\t\tint cost = d[r][c];\n\t\tREP(i, 4)if (g[r][c][i] == 0) {\n\t\t\tint nr = r + dr[i];\n\t\t\tint nc = c + dc[i];\n\t\t\tif (g[r][c][i] == 0) {\n\t\t\t\tif (chmin(d[nr][nc], cost+1))\n\t\t\t\t\tque.push(P(nr, nc));\n\t\t\t}\n\t\t}\n\t}\n\tg[sr][sc][k] = 0;\n\tp[sr][sc][k] = d[R - 1][C - 1];\n\n\tif (d[R - 1][C - 1] == 114514) {\n\t\tif (d[0][0] != 114514) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\twhile (cin >> R >> C, R + C) {\n\t\tREP(i, R)REP(j, C)REP(k, 4)g[i][j][k] = 1;\n\t\tREP(i, R) {\n\t\t\tREP(j, C-1) {\n\t\t\t\tint door;\n\t\t\t\tcin >> door;\n\t\t\t\tg[i][j][2] = g[i][j + 1][3] = door;\n\t\t\t}\n\t\t\tif (i != R - 1) {\n\t\t\t\tREP(j, C) {\n\t\t\t\t\tint door;\n\t\t\t\t\tcin >> door;\n\t\t\t\t\tg[i][j][0] = g[i+1][j][1] = door;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool goal=true;\n\t\tREP(i, R)REP(j, C)REP(k, 4)goal &= mindist(i, j, k);\n\t\tif (goal == false)cout << -1 << endl;\n\t\telse {\n\t\t\tVVV d(R, VV(C, V(1000,2000)));\n\t\t\td[0][0][0] = 0;\n\t\t\tREP(w, 999) {\n\t\t\t\tREP(r, R)REP(c, C) {\n\t\t\t\t\tREP(k,4)if(g[r][c][k]==0){\n\t\t\t\t\t\tint nr = r + dr[k];\n\t\t\t\t\t\tint nc = c + dc[k];\n\t\t\t\t\t\tint nxt_cost = \n\t\t\t\t\t\t\tmax(d[r][c][w],w+p[r][c][k]);\n\t\t\t\t\t\tchmin(d[nr][nc][w + 1],nxt_cost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res = 2000;\n\t\t\tREP(i, 1000)chmin(res,d[R-1][C-1][i]);\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\nconst int inf  = (1<<24);\nconst int dx[] = {+1, 0,-1, 0};\nconst int dy[] = { 0,+1, 0,-1};\n\nint  H,W;\nint  dist [30][30];\nint  cost[30][30][4];\nbool graph[30][30][4];\n\nclass Data\n{\npublic:\n\tint x,y,dist,cost;\n\tData(int x, int y, int d, int c)\n\t: x(x), y(y), dist(d), cost(c) {}\n\tbool operator<(const Data &d) const\n\t{\n\t\tif(cost!=d.cost) return cost>d.cost;\n\t\tif(dist!=d.dist) return dist>d.dist;\n\t\treturn (x!=x ? x<d.x : y<d.y);\n\t}\n};\n\nvoid bfs(int sx, int sy)\n{\n\tqueue<Data> q;\n\tbool visited[30][30]={0};\n\n\tq.push( Data(sx, sy, 0, 0) );\n\tvisited[sx][sy] = 1;\n\n\tfor(int y=0; y<H; y++)\n\tfor(int x=0; x<W; x++)\n\t{\n\t\tdist[x][y]=inf;\n\t}\n\n\twhile(!q.empty())\n\t{\n\t\tData t=q.front(); q.pop();\n\t\tdist[t.x][t.y] = t.cost;\n\n\t\tfor(int i=0; i<4; i++)\n\t\t{\n\t\t\tif(!graph[t.x][t.y][i]) continue;\n\t\t\tint nx = t.x + dx[i];\n\t\t\tint ny = t.y + dy[i];\n\n\t\t\tif(visited[nx][ny]) continue;\n\t\t\tq.push( Data(nx, ny, 0, t.cost+1) );\n\t\t\tvisited[nx][ny] = 1;\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(cin>>H>>W, H||W)\n\t{\n\t\tmemset(graph, 0, sizeof(graph));\n\n\t\tfor(int y=0; y<H; y++)\n\t\t{\n\t\t\tint t;\n\t\t\tfor(int x=0; x<W-1; x++)\n\t\t\t{\n\t\t\t\tif(cin >> t, t==0)\n\t\t\t\t{\n\t\t\t\t\tgraph[x  ][y][0] = 1;\n\t\t\t\t\tgraph[x+1][y][2] = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(y==H-1) break;\n\t\t\tfor(int x=0; x<W; x++)\n\t\t\t{\n\t\t\t\tif(cin >> t, t==0)\n\t\t\t\t{\n\t\t\t\t\tgraph[x][y  ][1] = 1;\n\t\t\t\t\tgraph[x][y+1][3] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(cost, 0, sizeof(cost));\n\n\t\tfor(int x1=0; x1<W; x1++)\n\t\tfor(int y1=0; y1<H; y1++)\n\t\tfor(int  d=0;  d<2;  d++)\n\t\t{\n\t\t\tint x2 = x1 + dx[d];\n\t\t\tint y2 = y1 + dy[d];\n\n\t\t\tif(W<=x2) continue;\n\t\t\tif(H<=y2) continue;\n\n\t\t\tbool g = graph[x1][y1][d];\n\n\t\t\tgraph[x1][y1][d  ]=0;\n\t\t\tgraph[x2][y2][d+2]=0;\n\n\t\t\tbfs(W-1, H-1);\n\t\t\tcost[x1][y1][d  ]=dist[x1][y1];\n\t\t\tcost[x2][y2][d+2]=dist[x2][y2];\n\n\t\t\tgraph[x1][y1][d  ]=g;\n\t\t\tgraph[x2][y2][d+2]=g;\n\t\t}\n\n\t\tint  ans=inf;\n\t\tbool visited[30][30][900]={0};\n\t\tpriority_queue<Data> q;\n\t\tq.push( Data(0, 0, 0, 0) );\n\t\t\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tData t=q.top(); q.pop();\n\t\t\tif(t.x==W-1 && t.y==H-1)\n\t\t\t{\n\t\t\t\tans=t.cost; break;\n\t\t\t}\n\n\t\t\tif(visited[t.x][t.y][t.dist]) continue;\n\t\t\tvisited[t.x][t.y][t.dist]=1;\n\n\t\t\tfor(int i=0; i<4; i++)\n\t\t\t{\n\t\t\t\tif(!graph[t.x][t.y][i]) continue;\n\t\t\t\tint nx = t.x+dx[i];\n\t\t\t\tint ny = t.y+dy[i];\n\t\t\t\tif(visited[nx][ny][t.dist+1]) continue;\n\t\t\t\tq.push( Data(nx, ny, t.dist+1, max(t.cost, t.dist+cost[t.x][t.y][i])) );\n\t\t\t}\n\t\t}\n\n\t\tif(inf<=ans) ans=-1;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint W, H;\nint Wall[2][40][40];\nint dist[2][33][33][33][33];\n\nint d[4][2]={{1, 0},{0, 1},{-1, 0},{0, -1}};\nint e[4][2]={{0, 0},{1, 0},{0, 1},{1, 1}};\n\nint memo[33][33];\n\nint dijk(int x, int y){\n\tpriority_queue<pipii, vector<pipii>, greater<pipii> > q;\n\tq.emplace(0, pii(H, W));\n\tmemo[H][W] = 0;\n\twhile(!q.empty()){\n\t\tint x=q.top().second.second;\n\t\tint y=q.top().second.first;\n\t\tif(x==1 && y==1) return q.top().first;\n\t\tq.pop();\n\t\tREP(di, 4){\n\t\t\tint dy = y+d[di][1];\n\t\t\tint dx = x+d[di][0];\n\t\t\tif(!Wall[e[di][0]][y+d[di][1]*e[di][1]][x+d[di][0]*e[di][1]]){\n\t\t\t\tint c = max(memo[y][x]+1, dist[e[di][0]][y+d[di][1]*e[di][1]][x+d[di][0]*e[di][1]][dy][dx]);\n\t\t\t\tif(memo[dy][dx] > c){\n\t\t\t\t\tmemo[dy][dx] = c;\n\t\t\t\t\tq.emplace(c, pii(dy, dx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nmain(){\n\twhile(scanf(\"%d%d\", &H, &W), H){\n\t\tmemset(memo, 63, sizeof(memo));\n\t\tmemset(Wall,  -1, sizeof(Wall));\n\t\tmemset(dist, 63, sizeof(dist));\n\t\tint ans;\n\t\tREP(i, H-1){\n\t\t\tREP(j, W-1) scanf(\"%d\", &Wall[0][i+1][j+1]);\n\t\t\tREP(j, W)   scanf(\"%d\", &Wall[1][i+1][j+1]);\n\t\t}\n\t\tREP(j, W-1) scanf(\"%d\", &Wall[0][H][j+1]);\n\t\tREP(i, H+1)REP(j, W+1)REP(k, 2){\n\t\t\tif(Wall[k][i][j] && !(!k&&!i&&!j)) continue;\n\t\t\tWall[k][i][j] = 1;\n\t\t\t\n\t\t\tdist[k][i][j][H][W] = 0;\n\t\t\tqueue<pii> q;\n\t\t\tq.emplace(H, W);\n\t\t\twhile(!q.empty()){\n\t\t\t\tint x=q.front().second;\n\t\t\t\tint y=q.front().first;\n\t\t\t\tq.pop();\n\t\t\t\tREP(di, 4){\n\t\t\t\t\tint dy = y+d[di][1];\n\t\t\t\t\tint dx = x+d[di][0];\n\t\t\t\t\tif(!Wall[e[di][0]][y+d[di][1]*e[di][1]][x+d[di][0]*e[di][1]] && dist[k][i][j][dy][dx] > dist[k][i][j][y][x]+1){\n\t\t\t\t\t\tdist[k][i][j][dy][dx] = dist[k][i][j][y][x]+1;\n\t\t\t\t\t\tq.push(pii(dy, dx));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tWall[k][i][j] = 0;\n\t\t\t\n\t\t}\n\t\tcout << dijk(W, H) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#ifdef DEBUG_MODE\n    #define DBG(n) n;\n#else\n    #define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n \ntypedef long long ll;\ntypedef pair<pair<int,int>,int> P;\nint h,w;\npair<int,int> dp[33*33];\nint dist[33*33];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nvector<vector<int>> v(33*33);\n \nint fun(int a,int b){\n    REP(i,33*33)dist[i] = INF;\n    dist[a] = 0;\n    queue<pair<int,int>> q;\n    q.push(MP(a,0));\n    while(!q.empty()){\n        pair<int,int> now = q.front();q.pop();\n        int node = now.FI;\n        int kyo = now.SE;\n        if(kyo > dist[node])continue;\n        REP(i,v[node].size()){\n            int aite = v[node][i];\n            if((node == a && aite == b) || (node == b && aite == a))continue;\n            if(dist[aite] > kyo + 1){\n                dist[aite] = kyo + 1;\n                q.push(MP(aite,kyo+1));\n            }\n        }\n    }\n    return dist[h*w-1];\n}\n \nint main()\n{\n    while(cin >> h >> w,h|w){\n        //初期化\n        REP(i,33*33)dp[i] = MP(INF,INF);\n        REP(i,33*33){v[i].clear();}\n        dp[0] = MP(0,0);\n         \n        //入力\n        REP(i,h){\n            REP(j,w-1){\n                int tmp;cin >> tmp;\n                if(tmp == 0){\n                    v[i*w+j].PB(i*w+j+1);\n                    v[i*w+j+1].PB(i*w+j);\n                }\n                 \n            }\n            if(i != h-1)REP(j,w){\n                int tmp;cin >> tmp;\n                if(tmp == 0){\n                    v[i*w+j].PB((i+1)*w+j);\n                    v[(i+1)*w+j].PB(i*w+j);\n                }\n            }\n        }\n                 \n        priority_queue<P,vector<P>,greater<P>> q;\n        q.push(MP(MP(0,-1),0));\n        DBG(cout << \"!\" << endl;);\n        while(!q.empty()){\n            DBG(\n            cout << \"DP TABLE\" << endl;\n            REP(i,h){\n                REP(j,w){\n                    cout << dp[i*w+j].FI << ' ';\n                }\n                cout << endl;\n            }\n            )\n            P now = q.top();q.pop();\n            int node = now.SE;\n            pair<int,int> kyori = now.FI;\n            DBG(cout << kyori.FI << ' ' << kyori.SE << endl;)\n            DBG(cout << dp[node].FI << ' ' << dp[node].SE << endl;)\n            if(dp[node].FI < kyori.FI)continue;\n            DBG(cout << \"IN\" << endl;)\n            kyori.SE++;\n            REP(i,v[node].size()){\n                int aite = v[node][i];\n                pair<int,int> score = MP(max(fun(node,aite)+kyori.SE,dp[node].FI),max(dp[node].SE,kyori.SE));\n                if(dp[aite] > score){\n                    dp[aite] = score;\n                    q.push(MP(dp[aite],aite));\n                }\n            }\n        }\n         \n        DBG(\n        cout << \"DP TABLE\" << endl;\n        REP(i,h){\n            REP(j,w){\n                cout << dp[i*w+j].FI << ' ';\n            }\n            cout << endl;\n        }\n        )\n         \n        DBG(cout << \"ANS IS \";);\n         \n        if(dp[h*w-1].FI == INF){\n            cout << -1 << endl;\n        }\n        else{\n            cout << dp[h*w-1].FI << endl;\n        }\n    }\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <utility>\n#define INF 2000\nusing namespace std;\ntypedef pair<int,int> P;\n\nstruct data{\n\tint x,y,c,dc;\n\tdata(int xx,int yy,int cc,int dd){\n\t\tx=xx;\n\t\ty=yy;\n\t\tc=cc;\n\t\tdc=dd;\n\t}\n\n\tbool operator<(const data& d1)const{\n\t\treturn d1.c<c;\n\t}\n};\n\nint h,w;\n\nint fie[61][61];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint dp[61][61][901];\nint cost[61][61][4];\nint used[61][61];\n\nint bfs(int sx,int sy){\n\tqueue<P> que;\n\tque.push(P(sx,sy));\n\tmemset(used,-1,sizeof(used));\n\tused[sx][sy]=0;\n\twhile(que.size()){\n\t\tP q=que.front();\n\t\tque.pop();\n\t\tint x=q.first,y=q.second;\n\t\tif(x==(w-1)*2 && y==(h-1)*2)return used[x][y];\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\tif(nx>=0 && nx<w*2-1 && ny>=0 && ny<h*2-1){\n\t\t\t\tif(fie[nx][ny]==1)continue;\n\t\t\t\tnx+=dx[i];\n\t\t\t\tny+=dy[i];\n\t\t\t\tif(used[nx][ny]==-1){\n\t\t\t\t\tused[nx][ny]=used[x][y]+1;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn INF;\n}\n\nint dijk(){\n\tpriority_queue<data> que;\n\tque.push(data(0,0,0,0));\n\tfor(int i=0;i<=60;i++){\n\t\tfor(int j=0;j<=60;j++){\n\t\t\tfor(int k=0;k<=900;k++){\n\t\t\t\tdp[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tque.push(data(0,0,0,0));\n\tdp[0][0][0]=0;\n\twhile(que.size()){\n\t\tdata d=que.top();\n\t\tque.pop();\n\t\tif(dp[d.x][d.y][d.c]!=d.dc)continue;\n\t\t//printf(\"%d %d %d %d\\n\",d.x,d.y,d.c,d.dc);\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(cost[d.x][d.y][i]==INF)continue;\n\t\t\tint nx=d.x+dx[i]*2,ny=d.y+dy[i]*2;\n\t\t\tif(nx>=0 && nx<w*2-1 && ny>=0 && ny<h*2-1){\n\t\t\t\tint ndc=max(d.dc,cost[d.x][d.y][i]+d.c);\n\t\t\t\tndc=max(ndc,d.c+1);\n\t\t\t\tif(dp[nx][ny][d.c+1]>ndc && d.c<900){\n\t\t\t\t\tdp[nx][ny][d.c+1]=ndc;\n\t\t\t\t\tque.push(data(nx,ny,d.c+1,ndc));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res=INF;\n\tfor(int i=0;i<=900;i++){\n\t\tres=min(res,dp[(w-1)*2][(h-1)*2][i]);\n\t}\n\tif(res==INF)return -1;\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tif(h==0 && w==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<2*h-1;i++){\n\t\t\tif(i%2==0){\n\t\t\t\tfor(int j=0;j<w-1;j++){\n\t\t\t\t\tscanf(\"%d\",&fie[j*2+1][i]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tscanf(\"%d\",&fie[j*2][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<2*h-1;i+=2){\n\t\t\tfor(int j=0;j<w*2;j+=2){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint x=j+dx[k],y=i+dy[k];\n\t\t\t\t\tif(x>=0 && x<w*2-1 && y>=0 && y<w*2-1){\n\t\t\t\t\t\tif(fie[x][y]==0){\n\t\t\t\t\t\t\tfie[x][y]=1;\n\t\t\t\t\t\t\tcost[j][i][k]=bfs(j,i);\n\t\t\t\t\t\t\tfie[x][y]=0;\n\t\t\t\t\t\t}else cost[j][i][k]=INF;\n\t\t\t\t\t}else cost[j][i][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\n#define INF 99999\n\nstruct node {\n  int x,y,dir,dis;\n  node(){}\n  node(int _x, int _y,int _dir, int _dis){\n    x = _x;\n    y = _y;\n    dir = _dir;\n    dis = _dis;\n  }\n  bool operator > (const node &a)const {\n    return dis > a.dis;\n  }\n};\n\nint mv[4][2] = {{-1,0},{0,1},{0,-1},{1,0}};\nchar con[35][35][35][35];\nchar use[35][35];\nint dis[35][35];\nint shm[35][35][4][35][35];\nint Q[20000][2];\n\nint x,y;\n\n\nbool chk(int a,int b){\n  return (0<=a && a<x && 0<=b && b<y);\n}\n\nvoid BFS(int sx,int sy,int dir){\n  memset(use,0,sizeof(use));\n\n  use[x-1][y-1] = 1;\n  Q[0][0] = x-1;\n  Q[0][1] = y-1;\n  shm[sx][sy][dir][x-1][y-1] = 0;\n  //if(sx==1&& sy==1)printf(\"sx %d sy %d dir %d\\n\",sx,sy,dir);\n\n  int p,q;\n  int nowX,nowY;\n  int dx,dy;\n  p = 0,q = -1;\n  while(p!=q){\n    ++q;\n    nowX = Q[q][0];\n    nowY = Q[q][1];\n\n\n    for(int k=0;k<4;k++){\n      dx = nowX + mv[k][0];\n      dy = nowY + mv[k][1];\n      if(chk(dx,dy) && con[nowX][nowY][dx][dy] && use[dx][dy]==0){\n        use[dx][dy] = 1;\n        ++p;\n        Q[p][0] = dx;\n        Q[p][1] = dy;\n        shm[sx][sy][dir][dx][dy] = shm[sx][sy][dir][nowX][nowY]+1;\n      }\n    }\n  }\n}\n\nint main(){\n  int i,j,k;\n  int dx,dy;\n  int nowI;\n  int tem;\n  int ans;\n  int nowX,nowY,nowDir,nowDis;\n\n   while(scanf(\"%d%d\",&x,&y)!=EOF){\n    if(!(x+y))break;\n    memset(con,0,sizeof(con));\n    memset(use,0,sizeof(use));\n    fill(&dis[0][0],&dis[34][0],INF);\n    fill(&shm[0][0][0][0][0], &shm[34][0][0][0][0],INF);\n\n\n    for(i=0;i+1<x+x;i++){\n      nowI = i/2;\n      for(j=0;j<y;j++){\n        if((i%2)==0 && j==y-1)break;\n        scanf(\"%d\",&tem);\n        if(i%2)con[nowI][j][nowI+1][j] = con[nowI+1][j][nowI][j] = (1-tem);\n        else con[nowI][j][nowI][j+1] = con[nowI][j+1][nowI][j] = (1-tem);\n      }\n    }\n\n    for(i=0;i<x;i++){\n      for(j=0;j<y;j++){\n        for(k=0;k<4;k++){\n          dx = i + mv[k][0];\n          dy = j + mv[k][1];\n          if(0<=dx && dx<x && 0<=dy && dy<y){\n            tem = con[i][j][dx][dy];\n            con[i][j][dx][dy] = con[dx][dy][i][j] = 0;\n            BFS(i,j,k);\n            con[i][j][dx][dy] = con[dx][dy][i][j] = tem;\n          }\n        }\n      }\n    }\n\n    memset(use,0,sizeof(use));\n    ans = INF;\n    priority_queue< node, vector< node >, greater< node > > tree;\n    while(tree.empty()==false)tree.pop();\n    tree.push(node(x-1, y-1, -1,0));\n\n    while(!tree.empty()){\n      node tNode = tree.top();\n      tree.pop();\n      if(!use[tNode.x][tNode.y]){\n        nowX = tNode.x;\n        nowY = tNode.y;\n        nowDir = tNode.dir;\n\n        use[nowX][nowY] = 1;\n\n        tem = -1;\n        for(int k=0;k<4;k++){\n          if(chk(nowX+mv[k][0],nowY+mv[k][1]))\n            tem = max(tem,shm[nowX][nowY][k][nowX][nowY]);\n        }\n\n        dis[nowX][nowY] = nowDis = max(tNode.dis,tem) ;\n\n        //printf(\"nowX %d nowY %d dis %d\\n\",nowX,nowY,nowDis);\n        if(nowX==0 && nowY==0){\n          ans = nowDis;\n          break;\n        }\n        //if(nowX==0 && nowY == 0)printf(\"nowDis %d\\n\",nowDis);\n\n        for(int k=0;k<4;k++){\n          dx = nowX + mv[k][0];\n          dy = nowY + mv[k][1];\n          if(chk(dx,dy)){\n            //printf(\"dx %d dy %d k %d dis %d, shm %d\\n\",dx,dy, k,nowDis+1,shm[nowX][nowY][k][dx][dy]);\n            //ans = min(ans, nowDis+shm[nowX][nowY][k][dx][dy]);\n\n            //if(nowX==2 && nowY==2)printf(\"dx %d dy %d go %d\\n\",dx,dy,con[nowX][nowY][dx][dy]);\n            if(con[nowX][nowY][dx][dy]&&!use[dx][dy]){\n              tree.push(node(dx,dy,k,nowDis+1));\n            }\n          }\n        }\n      }\n    }\n    if(ans>INF)printf(\"-1\\n\");\n    else printf(\"%d\\n\",ans);\n\n   }\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\nint dx[] = {-1, 0, 1, 0};\nint dy[] = { 0, 1, 0,-1};\nint h, w;\nvector<string> wall;\n\nstruct node{\n    int y, x, cst;\n};\nbool inrange(int y, int x){\n    return y >= 0 & x >= 0 && y < h && x < w;\n}\n\nint cst[31][31];\nint cst2[31][31];\n\nint main() {\n    while(cin >> h >> w, h){\n\twall.resize(2*h-1);\n\tcin.ignore();\n\trep(i, h*2-1) getline(cin, wall[i]);\n\tmemset(cst, 0, sizeof(cst));\n\tqueue<node> q;\n\tint done[31][31] = {0};\n\tq.push((node){0, 0, 0});\n\twhile(!q.empty()){\n\t    int y = q.front().y;\n\t    int x = q.front().x;\n\t    int cs = q.front().cst;\n\t    q.pop();\n\t    if(done[y][x]) continue;\n\t    done[y][x] = 1;\n\t    cst2[y][x] = cs;\n\t    rep(k, 4){\n\t\tint wy = 2*y + dy[k];\n\t\tint wx = 2*x + dx[k];\n\t\tif(inrange(y + dy[k], x + dx[k]) && wall[wy][wx] == '0'){\n\t\t    q.push((node){y+dy[k], x+dx[k], cs + 1});\n\t\t}\n\t    }\n\t}\n\t\n\tbool reachable = true;\n\trep(a, h*2-1) rep(b, wall[a].size()) if(wall[a][b] == '0') {\n\t    queue<node> q;\n\t    int done[31][31] = {0};\n\t    q.push((node){0, 0, 0});\n\t    bool flag = true;\n\t    wall[a][b] = '1';\n\t    while(!q.empty()){\n\t\tint y = q.front().y;\n\t\tint x = q.front().x;\n\t\tint cs = q.front().cst;\n\t\tq.pop();\n\t\tif(done[y][x]) continue;\n\t\tdone[y][x] = 1;\n\t\tif(y == h-1 && x == w-1) {\n\t\t    flag = false;\n\t\t    break;\n\t\t}\n\t\trep(k, 4){\n\t\t    int wy = 2*y + dy[k];\n\t\t    int wx = 2*x + dx[k];\n\t\t    if(inrange(y + dy[k], x + dx[k]) && wall[wy][wx] == '0'){\n\t\t\tq.push((node){y+dy[k], x+dx[k], cs + 1});\n\t\t    }\n\t\t}\n\t    }\n\t    wall[a][b] = '0';\n\t    if(flag) reachable = false;\n\t}\n\t\n\tif(!reachable){\n\t    cout << -1 << endl;\n\t    continue;\n\t}\n\n\trep(i, h) rep(j, w){\n\t    rep(a, h*2-1) rep(b, wall[a].size()) if(wall[a][b] == '0') {\n\t\twall[a][b] = '1';\n\t\tint c1, c2;\n\t\tqueue<node> q;\n\t\tint done[31][31] = {0};\n\t\tq.push((node){i, j, 0});\n\t\twhile(!q.empty()){\n\t\t    int y = q.front().y;\n\t\t    int x = q.front().x;\n\t\t    int cs = q.front().cst;\n\t\t    q.pop();\n\t\t    if(done[y][x]) continue;\n\t\t    done[y][x] = 1;\n\t\t    if(y == h-1 && x == w-1) {\n\t\t\tc2 = cs;\n\t\t\tbreak;\n\t\t    }\n\t\t    rep(k, 4){\n\t\t\tint wy = 2*y + dy[k];\n\t\t\tint wx = 2*x + dx[k];\n\t\t\tif(inrange(y + dy[k], x + dx[k]) && wall[wy][wx] == '0'){\n\t\t\t    q.push((node){y+dy[k], x+dx[k], cs + 1});\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tcst[i][j] = max(cst[i][j], c2);\n\t\twall[a][b] = '0';\n\t    }\n\t}\n//\trep(i, h) rep(j, w) cout << cst2[i][j] << (j < w-1?\" \":\"\\n\");\n\tint lower = 0;\n\tint upper = 30*30+1;\n\tint mid;\n\twhile(upper - lower > 1){\n\t    bool flag = false;\n\t    mid = (lower + upper) / 2;\n\t    queue<node> q;\n\t    int done[31][31] = {0};\n\t    q.push((node){0, 0, 0});\n\t    while(!q.empty()){\n\t\tint y = q.front().y;\n\t\tint x = q.front().x;\n\t\tint cs = q.front().cst;\n\t\tq.pop();\n\t\tif(done[y][x]) continue;\n\t\tdone[y][x] = 1;\n\t\tif(y == h-1 && x == w-1) {\n\t\t    flag = true;\n\t\t    break;\n\t\t}\n\t\trep(k, 4){\n\t\t    int wy = 2*y + dy[k];\n\t\t    int wx = 2*x + dx[k];\n\t\t    if(inrange(y + dy[k], x + dx[k]) && wall[wy][wx] == '0' && cst[y+dy[k]][x+dx[k]] + cs + 1 <= mid){\n\t\t\tq.push((node){y+dy[k], x+dx[k], cs + 1});\n\t\t    }\n\t\t}\n\t    }\n\t    if(!flag) lower = mid;\n\t    else upper = mid;\n\t}\n\tcout << upper << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reps(i,a,b) for(int i=(a); i<(b); ++i)\n#define rep(i,n) reps(i,0,n)\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nstruct UnionFind{\n\tstd::vector<int> data;\n\tUnionFind(int size): data(size, -1) {}\n\n\tbool unite(int x, int y){\n\t\tx=root(x);\n\t\ty=root(y);\n\t\tif( x != y ){\n\t\t\tif( data[y] < data[x] ) std::swap(x, y);\n\t\t\tdata[x] += data[y];\n\t\t\tdata[y] = x;\n\t\t}\n\t\treturn x!=y;\n\t}\n\n\tbool find(int x, int y){\n\t\treturn root(x) == root(y);\n\t}\n\n\tint root(int x){\n\t\treturn (data[x] < 0)? x : data[x]=root(data[x]);\n\t}\n\n\tint size(int x){\n\t\treturn -data[ root(x) ];\n\t}\n};\n\n// R, U, L, D\nconst int vx[]={1,0,-1,0}, vy[]={0,1,0,-1};\n\nconst int INF = 1e9;\n\nint h, w;\nint ans;\nmap<pii,int> cost;\nvoid solve(map<pii,int> &mp, map<pii,int> &tb, int x, int y, int d){\n\tqueue<pair<pii,int>> que;\n\tque.push( {pii(x,y), d} );\n\ttb[pii(x,y)] = d;\n\twhile(!que.empty()){\n\t\tauto cur = que.front().X;\n\t\tint x = cur.X;\n\t\tint y = cur.Y;\n\t\tint d = que.front().Y;\n\t\tque.pop();\n\t\trep(k,4){\n\t\t\tint nx = x + vx[k];\n\t\t\tint ny = y + vy[k];\n\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n\t\t\tif( mp[cur] & (1<<k) ) continue;\n\t\t\tif( !tb.count(pii(nx,ny)) || tb[pii(nx,ny)] > d + 1 ){\n\t\t\t\ttb[pii(nx,ny)] = d + 1;\n\t\t\t\tque.push( {pii(nx,ny), d+1} );\n\t\t\t}\n\t\t}\n\t}\n\tif( !tb.count(pii(w-1,h-1)) ) tb[pii(w-1,h-1)] = INF;\n\tcost[pii(x,y)] = max(cost[pii(x,y)], tb[pii(w-1,h-1)]);\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\twhile(cin >> h >> w, h|w){\n\t\tcost.clear();\n\t\tmap<pii,int> mp;\n\t\tint d;\n\t\trep(i,h-1){\n\t\t\trep(j,w-1){\n\t\t\t\tcin >> d;\n\t\t\t\tif( d == 1 ){\n\t\t\t\t\tmp[pii(j,i)]   |= (1<<0);\n\t\t\t\t\tmp[pii(j+1,i)] |= (1<<2);\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,w){\n\t\t\t\tcin >> d;\n\t\t\t\tif( d == 1 ){\n\t\t\t\t\tmp[pii(j,i)]   |= (1<<1);\n\t\t\t\t\tmp[pii(j,i+1)] |= (1<<3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint i = h-1;\n\t\trep(j,w-1){\n\t\t\tcin >> d;\n\t\t\tif( d == 1 ){\n\t\t\t\tmp[pii(j,i)]   |= (1<<0);\n\t\t\t\tmp[pii(j+1,i)] |= (1<<2);\n\t\t\t}\n\t\t}\n\t\trep(i,h) mp[pii(0,i)]   |= (1<<2);\n\t\trep(i,h) mp[pii(w-1,i)] |= (1<<0);\n\t\trep(i,w) mp[pii(i,0)]   |= (1<<3);\n\t\trep(i,w) mp[pii(i,h-1)] |= (1<<1);\n\n\t\tmap<pii,int> tb_s;\n\t\tsolve(mp, tb_s, 0, 0, 0);\n\t\tans = 0;\n//\t\trep(i,h){\n//\t\t\trep(j,w) cout << tb_s[pii(j,i)] << \" \";\n//\t\t\tcout << endl;\n//\t\t}\n\n\t\trep(y,h) rep(x,w) rep(k,4){\n\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n\t\t\tif( cost[pii(x,y)] >= INF ) continue;\n\t\t\tint nx = x + vx[k];\n\t\t\tint ny = y + vy[k];\n\t\t\tauto mp1 = mp;\n\t\t\tmp1[pii(x,y)]   |= (1<<k);\n\t\t\tmp1[pii(nx,ny)] |= (1<<((k+2)%4));\n\t\t\tmap<pii,int> tb;\n\t\t\t//solve(mp1, tb, x, y, tb_s[pii(x,y)]);\n\t\t\tsolve(mp1, tb, x, y, 0);\n\t\t\t//cout << \"solve: \" << x << \" \" << y << \" k=\" << k << endl;\n\t\t\t//rep(i,h){\n\t\t\t//\trep(j,w) cout << tb[pii(j,i)] << \" \";\n\t\t\t//\tcout << endl;\n\t\t\t//}\n\t\t}\n\n//\t\tcout << \"cost:\" << endl;\n//\t\trep(i,h){\n//\t\t\trep(j,w) cout << (cost[pii(j,i)]==INF ? 99 : cost[pii(j,i)]) << \" \";\n//\t\t\tcout << endl;\n//\t\t}\n\n\t\tint l=0, r=1000;\n\t\twhile(r-l>1){\n\t\t\tint limit = (l+r)/2;\n\t\t\ttypedef pair<pii,pii> PII;\n\t\t\tpriority_queue<PII, vector<PII>, greater<PII>> que;\n\t\t\tmap<pii,pii> memo;\n\t\t\tque.push({{cost[pii(0,0)],0},pii(0,0)});\n\t\t\twhile(!que.empty()){\n\t\t\t\tint c = que.top().X.X;\n\t\t\t\tint d = que.top().X.Y;\n\t\t\t\tint x = que.top().Y.X;\n\t\t\t\tint y = que.top().Y.Y;\n\t\t\t\tque.pop();\n\t\t\t\t//if( memo.count(pii(x,y)) && memo[pii(x,y)] < pii(c,d) ) continue;\n\t\t\t\tif( memo.count(pii(x,y)) ) continue;\n\t\t\t\tif( c > limit ) continue;\n\t\t\t\tmemo[pii(x,y)] = pii(c,d);\n\t\t\t\tans = max(ans, c);\n\t\t\t\tif( pii(x,y) == pii(w-1,h-1) ) break;\n\t\t\t\trep(k,4){\n\t\t\t\t\tint nx = x + vx[k];\n\t\t\t\t\tint ny = y + vy[k];\n\t\t\t\t\tint nc = d + 1 + cost[pii(nx,ny)];\n\t\t\t\t\tnc = min(nc, INF);\n\t\t\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n\t\t\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n\t\t\t\t\tif( !memo.count(pii(nx,ny)) || memo[pii(nx,ny)] > pii(nc,d+1) ){\n\t\t\t\t\t\t//memo[pii(nx,ny)] = pii(nc, d+1);\n\t\t\t\t\t\tque.push( {pii(nc, d+1), pii(nx, ny)} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( memo.count(pii(w-1,h-1)) ){\n\t\t\t\tr = limit;\n\t\t\t}else{\n\t\t\t\tl = limit;\n\t\t\t}\n\t\t}\n\t\tans = (r<1000 ? r : -1);\n//\t\tpii pos = {w-1,h-1};\n//\t\tans = max(ans, memo[pos].X);\n//\t\twhile( pos != pii(0,0) ){\n//\t\t\tint x = pos.X;\n//\t\t\tint y = pos.Y;\n//\t\t\trep(k,4){\n//\t\t\t\tint nx = x + vx[k];\n//\t\t\t\tint ny = y + vy[k];\n//\t\t\t\tint nc = d + 1 + cost[pii(nx,ny)];\n//\t\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n//\t\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n//\t\t\t\tif( memo.count(pii(nx,ny)) && memo[pii(nx,ny)].Y < memo[pos].Y ){\n//\t\t\t\t\tpos = pii(nx,ny);\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tans = max(ans, memo[pos].X);\n//\t\t}\n\n//\t\tmultimap<int, pii> order;\n//\t\tfor(auto t: memo) order.insert({ t.Y.X, t.X });\n//\t\tUnionFind uf(1000);\n//\t\tfor(auto t: order){\n//\t\t\tint x = t.Y.X;\n//\t\t\tint y = t.Y.Y;\n//\t\t\trep(k,4){\n//\t\t\t\tint nx = x + vx[k];\n//\t\t\t\tint ny = y + vy[k];\n//\t\t\t\tif( nx < 0 || nx >= w || ny < 0 || ny >= h ) continue;\n//\t\t\t\tif( mp[pii(x,y)] & (1<<k) ) continue;\n//\t\t\t\tif( memo[pii(nx,ny)].X <= t.X ){\n//\t\t\t\t\tuf.unite( nx+ny*w, x+y*w );\n//\t\t\t\t}\n//\t\t\t}\n////\t\t\tcout << \"order: \" << x << \" \" << y << \" \" << t.X << endl;\n//\t\t\tif( uf.find(0, (w-1)+(h-1)*w ) ){\n//\t\t\t\tans = t.X;\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t}\n\n\t\tcout << (ans >= INF ? -1 : ans) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n,m;\nvvi H,W;\nvvi dp,T;\n\nint main(){\n\twhile(cin>>n>>m,n){\n\t\tH=vvi(n-1,vi(m));\n\t\tW=vvi(n,vi(m-1));\n\t\trep(k,n-1){\n\t\t\trep(i,m-1)cin>>W[k][i];\n\t\t\trep(i,m)cin>>H[k][i];\n\t\t}\n\t\trep(i,m-1)cin>>W[n-1][i];\n\t\tT=dp=vvi(n,vi(m));\n\t\trep(i,n-1)rep(j,m)if(H[i][j]==0){\n\t\t\tH[i][j]=1;\n\t\t\t\n\t\t\trep(x,n)rep(y,m)T[x][y]=inf;\n\t\t\tT[n-1][m-1]=0;\n\t\t\tqueue<pii>q;\n\t\t\tq.push({n-1,m-1});\n\t\t\twhile(!q.empty()){\n\t\t\t\tpii t=q.front();\n\t\t\t\tq.pop();\n\t\t\t\trep(w,4){\n\t\t\t\t\tint x=t.first+dx[w];\n\t\t\t\t\tint y=t.second+dy[w];\n\t\t\t\t\tif(x<0||y<0||x>=n||y>=m)continue;\n\t\t\t\t\tif(w==0&&W[t.first][t.second])continue;\n\t\t\t\t\tif(w==1&&H[t.first][t.second])continue;\n\t\t\t\t\tif(w==2&&W[t.first][t.second-1])continue;\n\t\t\t\t\tif(w==3&&H[t.first-1][t.second])continue;\n\t\t\t\t\tif(T[x][y]>T[t.first][t.second]+1){\n\t\t\t\t\t\tT[x][y]=T[t.first][t.second]+1;\n\t\t\t\t\t\tq.push({x,y});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(x,n)rep(y,m)dp[x][y]=max(dp[x][y],T[x][y]);\n\t\t\tH[i][j]=0;\n\t\t}\n\t\trep(i,n)rep(j,m-1)if(W[i][j]==0){\n\t\t\tW[i][j]=1;\n\t\t\t\n\t\t\trep(x,n)rep(y,m)T[x][y]=inf;\n\t\t\tT[n-1][m-1]=0;\n\t\t\tqueue<pii>q;\n\t\t\tq.push({n-1,m-1});\n\t\t\twhile(!q.empty()){\n\t\t\t\tpii t=q.front();\n\t\t\t\tq.pop();\n\t\t\t\trep(w,4){\n\t\t\t\t\tint x=t.first+dx[w];\n\t\t\t\t\tint y=t.second+dy[w];\n\t\t\t\t\tif(x<0||y<0||x>=n||y>=m)continue;\n\t\t\t\t\tif(w==0&&W[t.first][t.second])continue;\n\t\t\t\t\tif(w==1&&H[t.first][t.second])continue;\n\t\t\t\t\tif(w==2&&W[t.first][t.second-1])continue;\n\t\t\t\t\tif(w==3&&H[t.first-1][t.second])continue;\n\t\t\t\t\tif(T[x][y]>T[t.first][t.second]+1){\n\t\t\t\t\t\tT[x][y]=T[t.first][t.second]+1;\n\t\t\t\t\t\tq.push({x,y});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(x,n)rep(y,m)dp[x][y]=max(dp[x][y],T[x][y]);\n\t\t\tW[i][j]=0;\n\t\t}\n\t\trep(i,n)rep(j,m)T[i][j]=inf;\n\t\tT[0][0]=dp[0][0];\n\t\tpriority_queue<tp>q;\n\t\tq.push(tp(0,0,0));\n\t\twhile(!q.empty()){\n\t\t\tint x,y,cost;\n\t\t\ttie(cost,x,y)=q.top();\n\t\t\tq.pop();\n\t\t\tif(T[x][y]<cost)continue;\n\t\t\trep(w,4){\n\t\t\t\tint nx=x+dx[w];\n\t\t\t\tint ny=y+dy[w];\n\t\t\t\tif(nx<0||ny<0||nx>=n||ny>=m)continue;\n\t\t\t\tif(w==0&&W[x][y])continue;\n\t\t\t\tif(w==1&&H[x][y])continue;\n\t\t\t\tif(w==2&&W[x][y-1])continue;\n\t\t\t\tif(w==3&&H[x-1][y])continue;\n\t\t\t\tint ncost=max(T[x][y],cost+1+dp[nx][ny]);\n\t\t\t\tif(T[nx][ny]>ncost){\n\t\t\t\t\tT[nx][ny]=ncost;\n\t\t\t\t\tq.push(tp(cost+1,nx,ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(T[n-1][m-1]==inf)T[n-1][m-1]=-1;\n\t\tcout<<T[n-1][m-1]<<endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  for(int i=0;i<((int)(v.size()));++i) {\n    if (i) os << \" \";\n    os << v[i];\n  }\n  return os;\n}\nint check(int h, int w, int now1, int to1, const vvi &g) {\n  queue<P> que;\n  vi bfs(h*w, INF);\n  que.push({0, now1});\n  bfs[now1] = 0;\n  while(!que.empty()) {\n    int d, now;\n    tie(d, now) = que.front(); que.pop();\n    for(auto &to: g[now]) {\n      if(now == now1 && to == to1) continue;\n      if(bfs[to] > d + 1) {\n        bfs[to] = d + 1;\n        que.push({d + 1, to});\n      }\n    }\n  }\n  return bfs[h*w - 1];\n}\nbool solve() {\n  int h, w;\n  cin >> h >> w;\n  if (h == 0 && w == 0) return false;\n  vvi g(h*w);\n  for(int i=0;i<(2 * h - 1);++i) {\n    if (i % 2 == 0) {\n      int r = i / 2;\n      for(int j=0;j<(w - 1);++j) {\n        int c; cin >> c;\n        if(c == 0) {\n          g[r * w + j].push_back(r * w + j + 1);\n          g[r * w + j + 1].push_back(r * w + j);\n        }\n      }\n    } else {\n      int r = i / 2;\n      for(int j=0;j<(w);++j) {\n        int c; cin >> c;\n        if(c == 0) {\n          g[r * w + j].push_back((r + 1) * w + j);\n          g[(r + 1) * w + j].push_back(r * w + j);\n        }\n      }\n    }\n  }\n  int l = 0, r = 10000;\n  while(r - l > 1) {\n    int mid = (l + r) / 2;\n    queue<P> que;\n    vi bfs(h * w, INF);\n    que.push({0, 0});\n    bfs[0] = 0;\n    while (!que.empty()) {\n      int d, now;\n      tie(d, now) = que.front();\n      que.pop();\n      for (auto &to: g[now]) {\n        int ch = check(h, w, now, to, g);\n        if(d + ch > mid) continue;\n        if (bfs[to] > d + 1 && d + 1 <= mid) {\n          bfs[to] = d + 1;\n          que.push({d + 1, to});\n        }\n      }\n    }\n    if(bfs[h*w-1] == INF) {\n      l = mid;\n    } else {\n      r = mid;\n    }\n  }\n  cout << (r == 10000 ? -1 : r) << endl;\n  return true;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while (solve()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <utility>\n#define INF 2000\nusing namespace std;\ntypedef pair<int,int> P;\n\nstruct data{\n\tint x,y,c,dc;\n\tdata(int xx,int yy,int cc,int dd){\n\t\tx=xx;\n\t\ty=yy;\n\t\tc=cc;\n\t\tdc=dd;\n\t}\n\n\tbool operator<(const data& d1)const{\n\t\treturn d1.c>c;\n\t}\n};\n\nint h,w;\n\nint fie[61][61];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint dp[61][61][901];\nint cost[61][61][4];\nint used[61][61];\n\nint bfs(int sx,int sy){\n\tqueue<P> que;\n\tque.push(P(sx,sy));\n\tmemset(used,-1,sizeof(used));\n\tused[sx][sy]=0;\n\twhile(que.size()){\n\t\tP q=que.front();\n\t\tque.pop();\n\t\tint x=q.first,y=q.second;\n\t\tif(x==(w-1)*2 && y==(h-1)*2)return used[x][y];\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\tif(nx>=0 && nx<w*2-1 && ny>=0 && ny<h*2-1){\n\t\t\t\tif(fie[nx][ny]==1)continue;\n\t\t\t\tnx+=dx[i];\n\t\t\t\tny+=dy[i];\n\t\t\t\tif(used[nx][ny]==-1){\n\t\t\t\t\tused[nx][ny]=used[x][y]+1;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn INF;\n}\n\nint dijk(){\n\tpriority_queue<data> que;\n\tque.push(data(0,0,0,0));\n\tfor(int i=0;i<=60;i++){\n\t\tfor(int j=0;j<=60;j++){\n\t\t\tfor(int k=0;k<=900;k++){\n\t\t\t\tdp[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tque.push(data(0,0,0,0));\n\tdp[0][0][0]=0;\n\twhile(que.size()){\n\t\tdata d=que.top();\n\t\tque.pop();\n\t\tif(dp[d.x][d.y][d.c]!=d.dc)continue;\n\t\t//printf(\"%d %d %d %d\\n\",d.x,d.y,d.c,d.dc);\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(cost[d.x][d.y][i]==INF)continue;\n\t\t\tint nx=d.x+dx[i]*2,ny=d.y+dy[i]*2;\n\t\t\tif(nx>=0 && nx<w*2-1 && ny>=0 && ny<h*2-1){\n\t\t\t\tint ndc=max(d.dc,cost[d.x][d.y][i]+d.c);\n\t\t\t\tif(dp[nx][ny][d.c+1]>ndc && d.c<900){\n\t\t\t\t\tdp[nx][ny][d.c+1]=ndc;\n\t\t\t\t\tque.push(data(nx,ny,d.c+1,ndc));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res=INF;\n\tfor(int i=0;i<=900;i++){\n\t\tres=min(res,dp[(w-1)*2][(h-1)*2][i]);\n\t}\n\tif(res==INF)return -1;\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tif(h==0 && w==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<2*h-1;i++){\n\t\t\tif(i%2==0){\n\t\t\t\tfor(int j=0;j<w-1;j++){\n\t\t\t\t\tscanf(\"%d\",&fie[j*2+1][i]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tscanf(\"%d\",&fie[j*2][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<2*h-1;i+=2){\n\t\t\tfor(int j=0;j<w*2;j+=2){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint x=j+dx[k],y=i+dy[k];\n\t\t\t\t\tif(x>=0 && x<w*2-1 && y>=0 && y<w*2-1){\n\t\t\t\t\t\tif(fie[x][y]==0){\n\t\t\t\t\t\t\tfie[x][y]=1;\n\t\t\t\t\t\t\tcost[j][i][k]=bfs(j,i);\n\t\t\t\t\t\t\tfie[x][y]=0;\n\t\t\t\t\t\t}else cost[j][i][k]=INF;\n\t\t\t\t\t}else cost[j][i][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<bitset>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<functional>\n#include<algorithm>\nusing namespace std;\n\nenum {N, E, S, W};\nconst unsigned long ALL = 1 + 2 + 4 + 8;\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\n\nconst int INF = 10000;\n\n// for bfs\nenum {Y, X, STEP};\ntypedef tuple<int, int, int> Node;\ntypedef tuple<int, int> Vertex;\n\n// for Dijkstra\nenum {DWORST, DSTEP, DY, DX};\ntypedef tuple<int, int, int, int> DNode;\n\nint h, w;\nvector<vector<bitset<4>>> wall;\n\nint bfs(int by, int bx, int bd, int init_step) {\n    queue<Node> q;\n    q.push(Node(by, bx, init_step));\n    set<Vertex> visited;\n    while(!q.empty()) {\n        int y = get<Y>(q.front());\n        int x = get<X>(q.front());\n        int step = get<STEP>(q.front());\n        q.pop();\n        if(y == h - 1 && x == w - 1) return step;\n        if(visited.count(Vertex(y, x))) continue;\n        visited.insert(Vertex(y, x));\n        for(const auto& d: {N, E, S, W}) {\n            if(wall[y][x][d]) continue;\n            if(y == by && x == bx && d == bd) continue;\n            int ny = y + dy[d];\n            int nx = x + dx[d];\n            if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            q.push(Node(ny, nx, step + 1));\n        }\n    }\n    return INF;\n}\n\nint Dijkstra() {\n    priority_queue<DNode, vector<DNode>, greater<DNode>> q;\n    q.push(DNode(0, 0, 0, 0));\n    set<Node> visited;\n    while(!q.empty()) {\n        int worst = get<DWORST>(q.top());\n        int y = get<DY>(q.top());\n        int x = get<DX>(q.top());\n        int step = get<DSTEP>(q.top());\n        q.pop();\n        if(y == h - 1 && x == w - 1) return worst;\n        if(visited.count(Node(y, x, step))) continue;\n        visited.insert(Node(y, x, step));\n        for(const auto& d: {N, E, S, W}) {\n            if(wall[y][x][d]) continue;\n            int ny = y + dy[d];\n            int nx = x + dx[d];\n            if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n            if(visited.count(Node(ny, nx, step))) continue;\n            int nworst = max(worst, bfs(y, x, d, step));\n            if(nworst == INF) continue;\n            q.push(DNode(nworst, step + 1, ny, nx));\n        }\n    }\n    return INF;\n}\n\nint main() {\n    while(cin >> h >> w, h | w) {\n        wall = vector<vector<bitset<4>>>(h, vector<bitset<4>>(w, bitset<4>(ALL)));\n        for(int i = 0; i < h - 1; ++i) {\n            for(int j = 0; j < w - 1; ++j) {\n                int is_wall;\n                cin >> is_wall;\n                if(is_wall) continue;\n                wall[i][j].reset(E);\n                wall[i][j + 1].reset(W);\n            }\n            for(int j = 0; j < w; ++j) {\n                int is_wall;\n                cin >> is_wall;\n                if(is_wall) continue;\n                wall[i][j].reset(S);\n                wall[i + 1][j].reset(N);\n            }\n        }\n        for(int j = 0; j < w - 1; ++j) {\n            int is_wall;\n            cin >> is_wall;\n            if(is_wall) continue;\n            wall[h - 1][j].reset(E);\n            wall[h - 1][j + 1].reset(W);\n        }\n\n        int answer = Dijkstra();\n        cout << (answer == INF ? -1 : answer) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstdio>\n#include <cstring>\n#include <climits>\nusing namespace std;\n\nconst int dx[] = {0, 1, 0, -1}; //上右下左\nconst int dy[] = {-1, 0, 1, 0};\nconst int inf = 1<<20;\n\nint w,h;\nint DP[32][32], usedCard[32][32];\nint path[4][32][32]; // 未処理の場合は -1, ゴールできないときは inf\nchar field[64][64];\nchar block[32][32][4];\n\nstruct state{\n    int x,y;\n    int prevDir;\n    int step;\n    int worstStep;\n    state(int _x, int _y, int pd, int s, int w){\n        x = _x;\n        y = _y;\n        prevDir = pd;\n        step = s;\n        worstStep = w;\n    }\n    bool operator<(const state& a)const{\n        if( worstStep == a.worstStep ){\n            return step > a.step;\n        }\n        return worstStep > a.worstStep;\n    }\n};\n\n\ninline bool inside(int x, int y){\n    return !( x < 0 || x >= 2*w-1 || y >= 2*h-1 || y < 0 );\n}\n\n\nint bfs(int sx, int sy, int gx, int gy){\n    int k;\n    char memo[32][32];\n    queue<pair<int,int> > q;\n\n    memset(memo, -1, sizeof(memo));\n    q.push(make_pair(sx,sy));\n    memo[sy][sx] = 0;\n\n    if( sx == gx && sy == gy ) return 0;\n\n    while( !q.empty() ){\n        int x = q.front().first;\n        int y = q.front().second;\n        int s = memo[y][x];\n        q.pop();\n\n        for(k=0; k<4; k++){\n            int nx = x + dx[k], ny = y + dy[k];\n            if( !block[y][x][k] && memo[ny][nx] == -1 ){\n                memo[ny][nx] = s + 1;\n                if( gy == ny && gx == nx ){\n                    return s + 1;\n                }\n                q.push(make_pair(nx, ny));\n            }\n        }\n    }\n    \n    return inf;\n}\n\nint solve(){\n    int i,k;\n    priority_queue<state> q;\n    q.push(state(0, 0, 2, 0, 0));\n\n    while( !q.empty() ){\n        int x = q.top().x;\n        int y = q.top().y;\n        int prevDir = q.top().prevDir;\n        int step = q.top().step;\n        int wstep = q.top().worstStep;\n        q.pop();\n\n        if( step > 200 ) break;\n        if( y == h-1 && x == w-1 ) return wstep;\n\n        for(k=0; k<4; k++){\n            if( ((prevDir + 2) & 3) == k ) continue;\n            if( block[y][x][k] ) continue;\n            // ドアが壊れてたときの計算\n            int nextWorstStep = inf;\n\n            // まだBFSで調べてないので調べる\n            if( path[k][y][x] == -1 ){\n                block[y][x][k] = 1;\n                path[k][y][x] = bfs(x, y, w-1, h-1);\n                block[y][x][k] = 0;\n            }\n\n            if( path[k][y][x] == inf ) continue; // ゴールできない\n\n            nextWorstStep = max(wstep, step + path[k][y][x]);\n\n            int nx = x + dx[k], ny = y + dy[k];\n\n            if( DP[ny][nx] > nextWorstStep ){\n                DP[ny][nx] = nextWorstStep;\n                usedCard[ny][nx] = step + 1;\n                q.push(state(nx, ny, k, step + 1, nextWorstStep));\n            }\n            else if( step + 1 < usedCard[ny][nx] ){\n                // nextWorstStepが最も小さいものから処理されるから、2度目以降のnextWorstStepは必ず大きい。よって、\n                usedCard[ny][nx] = step + 1;\n                q.push(state(nx, ny, k, step + 1, nextWorstStep));\n            }\n        } \n    }\n    return -1;\n}\n\n\nint main(){\n    int i,j,k;\n\n    while( cin >> h >> w, h|w ){\n        cin.ignore();\n\n        // input\n        for(i=0; i<2*h-1; i++){\n            fread((void*)field[i], 1, 2*w + (i&1 ? 0 : -1), stdin);\n        }\n\n        fill(&DP[0][0], &DP[0][0] + 32*32, inf);\n        fill(&usedCard[0][0], &usedCard[0][0] + 32*32, inf);\n        memset(path, -1, sizeof(path));\n\n        // 通れない場所を予め調べておく\n        for(i=0; i<h; i++){\n            for(j=0; j<w; j++){\n                for(k=0; k<4; k++){\n                    int tx = 2*j + dx[k];\n                    int ty = 2*i + dy[k];\n                    if( !inside(tx, ty) || field[ty][tx] == '1' ){\n                        block[i][j][k] = 1;\n                    }\n                    else{\n                        block[i][j][k] = 0;\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\",solve());\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\ntypedef pair<int,int> pii;\n\nstruct P {\n  int y, x, d, cost;\n  P(int y, int x, int d, int cost) :\n    y(y),x(x),d(d),cost(cost) {}\n  bool operator<(const P &b) const  {\n    return cost > b.cost;\n  }\n};\n\nbool can[30][30][4];\nint dist[30][30];\nint cost[30][30][4];\nint dist2[30][30][910];\n\nint main() {\n  int h, w;\n  while(cin>>h>>w,h||w) {\n    memset(can,0,sizeof(can));\n    REP(i,2*h-1) {\n      if (i&1) {\n        REP(j,w) {\n          bool f;\n          cin >> f;\n          can[i/2][j][2] = can[i/2+1][j][0] = !f;\n        }\n      } else {\n        REP(j,w-1) {\n          bool f;\n          cin >> f;\n          can[i/2][j][1] = can[i/2][j+1][3] = !f;\n        }\n      }\n    }\n    // REP(i,h) {\n    //   REP(j,w) {\n    //     cout << \"(\";\n    //     REP(k,4) cout << can[i][j][k];\n    //     cout << \")\";\n    //   }\n    //   cout << endl;\n    // }\n    const int dy[] = {-1,0,1,0};\n    const int dx[] = {0,1,0,-1};\n    REP(i,h) {\n      REP(j,w) {\n        REP(k,4) {\n          if (can[i][j][k] == 0) continue;\n          can[i][j][k] = 0;\n          \n          memset(dist,-1,sizeof(dist));\n          dist[i][j] = 0;\n          queue<pii> Q;\n          Q.push(pii(i,j));\n          while(!Q.empty()) {\n            pii p = Q.front(); Q.pop();\n            REP(d,4) {\n              if (can[p.first][p.second][d]) {\n                int yy = p.first + dy[d];\n                int xx = p.second + dx[d];\n                if (dist[yy][xx] == -1) {\n                  dist[yy][xx] = dist[p.first][p.second] + 1;\n                  Q.push(pii(yy,xx));\n                }\n              }\n            }\n          }\n          if (dist[h-1][w-1] == -1) cost[i][j][k] = INF;\n          else cost[i][j][k] = dist[h-1][w-1];\n          can[i][j][k] = 1;\n        }\n      }\n    }\n    // REP(i,h) {\n    //   REP(j,w) {\n    //     cout << \"(\";\n    //     REP(k,4) cout << cost[i][j][k] <<\",\";\n    //     cout << \")\";\n    //   }\n    //   cout << endl;\n    // }    \n    REP(i,h)REP(j,w)REP(k,h*w+10)dist2[i][j][k]=INF;\n    priority_queue<P> Q;\n    Q.push(P(0,0,0,0));\n    int ans = INF;\n    while(!Q.empty()) {\n      P p = Q.top(); Q.pop();\n      if (dist2[p.y][p.x][p.d] < p.cost) continue;\n      // cout << p.y << \" \" << p.x << \" \" << p.d << \" \" << p.cost << endl;\n      if (p.y == h-1 && p.x == w-1) {\n        ans = min(ans, p.cost);\n      }\n      REP(i,4) {\n        if (!can[p.y][p.x][i]) continue;\n        int yy = p.y + dy[i];\n        int xx = p.x + dx[i];\n        int co = cost[p.y][p.x][i];\n        int ncost = max(p.cost, p.d+co);\n        if (dist2[yy][xx][p.d+1] > ncost) {\n          dist2[yy][xx][p.d+1] = ncost;\n          Q.push(P(yy,xx,p.d+1,ncost));\n        }\n      }\n    }\n    if (ans == INF) cout << -1 << endl;\n    else cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint h,w;\nint door_ver[30][29];\nint door_side[29][30];\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,-1,1};\n\nint check( int x_start, int y_start, int x_end, int y_end ) {\n\n  if ( x_start == x_end && y_start == y_end ) return 0;\n\n  int map[30][30] = {0};\n  vector<int> x_old,y_old,x_new,y_new;\n  map[x_start][y_start] = 1;\n  x_old.push_back(x_start);\n  y_old.push_back(y_start);\n\n  while(true) {\n\n    for ( int i = 0; i < x_old.size(); i++ ) {\n      for ( int j = 0; j < 4; j++ ) {\n\n\tint x = x_old[i]+dx[j];\n\tint y = y_old[i]+dy[j];\n\tif ( x < 0 || x >= w || y < 0 || y >= h ) continue;\n\tif ( map[x][y] != 0 ) continue;\n\n\tif ( j == 0 && door_side[x_old[i]-1][y_old[i]] == 1 ) continue;\n\tif ( j == 1 && door_side[x_old[i]][y_old[i]] == 1 ) continue;\n\tif ( j == 2 && door_ver[x_old[i]][y_old[i]-1] == 1 ) continue;\n\tif ( j == 3 && door_ver[x_old[i]][y_old[i]] == 1 ) continue;\n\n\tif ( x == x_end && y == y_end ) return map[x_old[i]][y_old[i]];\n\tmap[x][y] = map[x_old[i]][y_old[i]]+1;\n\tx_new.push_back(x);\n\ty_new.push_back(y);\n\n      }\n    }\n\n    if ( x_new.size() == 0 ) return -1;\n    x_old.clear();\n    y_old.clear();\n    for ( int i = 0; i < x_new.size(); i++ ) {\n      x_old.push_back(x_new[i]);\n      y_old.push_back(y_new[i]);\n    }\n    x_new.clear();\n    y_new.clear();\n\n  }\n  return 0;\n}\n\nint main() {\n\n  while(true) {\n\n    cin >> h >> w;\n    if ( h == 0 ) break;\n\n    for ( int i = 0; i < h; i++ ) {\n      for ( int j = 0; j < w-1; j++ ) {\n\tcin >> door_side[j][i];\n      }\n      if ( i == h-1 ) break;\n      for ( int j = 0; j < w; j++ ) {\n\tcin >> door_ver[j][i];\n      }\n    }\n\n    int map[30][30] = {0};\n    for ( int i = 0; i < h; i++ ) {\n      for ( int j = 0; j < w; j++ ) {\n\n\tif ( check( 0, 0, j, i ) == -1 ) continue;\n\n\tint cnt = 0;\n\tint cnt_max = 0;\n\tif ( j != 0 ) {\n\t  if ( door_side[j-1][i] == 0 ) {\n\t    door_side[j-1][i] = 1;\n\t    cnt = check( j, i, w-1, h-1 );\n\t    door_side[j-1][i] = 0;\n\t    if ( cnt == -1 ) {\n\t      map[j][i] = -1;\n\t      continue;\n\t    }\n\t    cnt_max = max( cnt_max, cnt );\n\t  }\n\t}\n\tif ( j != w-1 ) {\n\t  if ( door_side[j][i] == 0 ) {\n\t    door_side[j][i] = 1;\n\t    cnt = check( j, i, w-1, h-1 );\n\t    door_side[j][i] = 0;\n\t    if ( cnt == -1 ) {\n\t      map[j][i] = -1;\n\t      continue;\n\t    }\n\t    cnt_max = max( cnt_max, cnt );\n\t  }\n\t}\n\tif ( i != 0 ) {\n\t  if ( door_ver[j][i-1] == 0 ) {\n\t    door_ver[j][i-1] = 1;\n\t    cnt = check( j, i, w-1, h-1 );\n\t    door_ver[j][i-1] = 0;\n\t    if ( cnt == -1 ) {\n\t      map[j][i] = -1;\n\t      continue;\n\t    }\n\t    cnt_max = max( cnt_max, cnt );\n\t  }\n\t}\n\tif ( i != h-1 ) {\n\t  if ( door_ver[j][i] == 0 ) {\n\t    door_ver[j][i] = 1;\n\t    cnt = check( j, i, w-1, h-1 );\n\t    door_ver[j][i] = 0;\n\t    if ( cnt == -1 ) {\n\t      map[j][i] = -1;\n\t      continue;\n\t    }\n\t    cnt_max = max( cnt_max, cnt );\n\t  }\n\t}\n\n      \tmap[j][i] = cnt_max;\n\n      }\n    }\n\n    int map2[30][30] = {0};\n    vector<int> x_old,y_old,x_new,y_new;\n    map2[0][0] = map[0][0];\n    x_old.push_back(0);\n    y_old.push_back(0);\n    int cnt = 0;\n\n    while(true) {\n      cnt++;\n\n      for ( int i = 0; i < x_old.size(); i++ ) {\n\tfor ( int j = 0; j < 4; j++ ) {\n\n\t  int x = x_old[i]+dx[j];\n\t  int y = y_old[i]+dy[j];\n\t  if ( x < 0 || x >= w || y < 0 || y >= h ) continue;\n\t  if ( map[x][y] == -1 ) continue;\n\n\t  if ( j == 0 && door_side[x_old[i]-1][y_old[i]] == 1 ) continue;\n\t  if ( j == 1 && door_side[x_old[i]][y_old[i]] == 1 ) continue;\n\t  if ( j == 2 && door_ver[x_old[i]][y_old[i]-1] == 1 ) continue;\n\t  if ( j == 3 && door_ver[x_old[i]][y_old[i]] == 1 ) continue;\n\n\t  bool flag = false;\n\t  if ( map2[x][y] != 0 ) {\n\t    if ( map2[x_old[i]][y_old[i]] < map2[x][y] ) {\n\t      flag = true;\n\t    }\n\t  }else {\n\t    flag = true;\n\t  }\n\t  if ( flag ) {\n\t    map2[x][y] = max( cnt + map[x][y], map2[x_old[i]][y_old[i]] );\n\t    x_new.push_back(x);\n\t    y_new.push_back(y);\n\t  }\n\n\t}\n      }\n\n      if ( x_new.size() == 0 ) break;\n      x_old.clear();\n      y_old.clear();\n      for ( int i = 0; i < x_new.size(); i++ ) {\n\tx_old.push_back(x_new[i]);\n\ty_old.push_back(y_new[i]);\n      }\n      x_new.clear();\n      y_new.clear();\n\n    }\n\n    if ( map2[w-1][h-1] > 0 ) {\n      cout << map2[w-1][h-1] << endl;\n    }else {\n      cout << \"-1\" << endl;\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl;\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl;\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl;\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl;\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl;\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl;\n#define double long double\nusing namespace std;\nconst int INF = 1e9;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\nconst int N = 50;\nint h,w;\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\nint G[N][N][4];\nint in(int x,int y){return !(x < 0 || y < 0 || x >= w || y >= h);}\n\nint dis[N][N][N][N][4]; //goalからの距離\nvoid bfs(int sy,int sx){\n  memset(dis,-1,sizeof(dis));\n  typedef tuple<int,int,int,int,int,int> T; // y, x, by, bx, dir, cost\n  queue<T> Q;\n  \n  //broken door\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<4;k++){\n        dis[sy][sx][i][j][k] = 0;\n        Q.push(T(sy,sx,i,j,k,0));\n      }\n  \n  while(!Q.empty()){\n    int y, x, by, bx, dir, cost;\n    tie(y, x, by, bx, dir, cost) = Q.front(); Q.pop();\n    \n    for(int i=0;i<4;i++){\n      int ny = y + dy[i];\n      int nx = x + dx[i];\n      int ncost = cost + 1;\n      if(!in(nx,ny) || G[y][x][i] == 0 || dis[ny][nx][by][bx][dir] != -1) continue;\n      if(x == bx && y == by && i == dir) continue;\n      if(nx == bx && ny == by && i == (dir+2)%4) continue;\n      dis[ny][nx][by][bx][dir] = ncost;\n      Q.push(T(ny,nx,by,bx,dir,ncost));\n    }\n  }\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<h;k++)\n        for(int l=0;l<w;l++)\n          for(int m=0;m<4;m++) if(dis[i][j][k][l][m] == -1) dis[i][j][k][l][m] = INF;\n}\n\nint calcCost(int y,int x,int d,int dir){\n  if(!in(x,y)) return INF;\n  int res = INF;\n  Min(res, d + dis[y][x][y][x][dir]);\n  return res;\n}\n\nint D[N][N][N*N], visited[N][N][N*N];\nint dijkstra(int sy,int sx){\n  typedef tuple<int,int,int,int> T; //cost, y, x, distance;\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<=h*w;k++) D[i][j][k] = INF, visited[i][j][k] = 0;\n  \n  priority_queue<T,vector<T>,greater<T> > Q;\n  Q.push(T(0,sy,sx,0));\n  D[sy][sx][0] = 0;\n\n  int res = INF;\n  while(!Q.empty()){\n    int cost, y, x, d;\n    tie(cost,y, x, d) = Q.top(); Q.pop();\n    if(visited[y][x][d]++) continue;\n    if(x == w-1 && y == h-1) {\n      Min(res, max(cost, d));\n      continue;\n    }\n\n    for(int i=0;i<4;i++){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      int nd = d + 1;\n      int a = cost;\n      int b = calcCost(y, x, d, i);\n      int ncost = max(a, b);\n      if(!in(nx,ny) || G[y][x][i] == 0 || D[ny][nx][nd] <= ncost) continue;\n      D[ny][nx][nd] = ncost;\n      Q.push(T(ncost,ny,nx,nd));\n    }\n  }\n  if(res == INF) return -1;\n  return res;\n}\n\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(1){\n    cin>>h>>w;\n    if(h == 0 && w == 0) break;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++)\n        for(int k=0;k<4;k++) G[i][j][k] = 1;\n\n    for(int i=0;i<h*2-1;i++){\n      for(int j=0;j<w - !(i%2);j++){\n        int ng;\n        cin>>ng;\n        int x = j, y = i/2;\n        if(i%2 == 0 && ng) G[y][x][1] = G[y][x+1][3] = 0;\n        if(i%2 == 1 && ng) G[y][x][2] = G[y+1][x][0] = 0;\n      }\n    }\n\n    bfs(h-1, w-1);\n    \n    int ans = dijkstra(0, 0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);++i)\n#define rep(i,n) REP(i, 0, n)\ntypedef pair<int, int> pint;\n\nint H, W;\nstruct Edge { int num, to; Edge(int n, int t) : num(n), to(t) {}};\nvector<vector<Edge>> edges;\nbool bfs(int broken_edge, vector<int>& dist) {\n    dist[(H - 1) * W + W - 1] = 0;\n    queue<int> que; que.push((H - 1) * W + W - 1);\n    while(!que.empty()) {\n        int cur = que.front(); que.pop();\n        for(const Edge& e : edges[cur]) {\n            if(e.num == broken_edge || dist[e.to] != INF) continue;\n            dist[e.to] = dist[cur] + 1;\n            que.push(e.to);\n        }\n    }\n    return dist[0] == INF;\n}\n\nint solve(const vector<vector<int>>& wdist) {\n    vector<int> dist(H * W, INF);\n    priority_queue<pint, vector<pint>, greater<pint>> que;\n    dist[(H - 1) * W + W - 1] = 0; que.emplace(0, (H - 1) * W + W - 1);\n    auto upd = [](int& a, int b) { return a > b ? (a = b, true) : false;};\n    while(!que.empty()) {\n        int cos, node;\n        tie(cos, node) = que.top(); que.pop();\n        if(dist[node] < cos) continue;\n        for(const Edge& e : edges[node]) {\n            int ncos = max(cos + 1, wdist[e.num][e.to]);\n            if(upd(dist[e.to], ncos)) que.emplace(ncos, e.to);\n        }\n    }\n    return dist[0];\n}\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    while(cin >> H >> W && H) {\n        int t_, edgenum = 0;\n        edges.assign(H * W, vector<Edge>());\n        rep(i, H) {\n            rep(j, W - 1) {\n                cin >> t_;\n                if(t_ == 0) {\n                    edges[i * W + j].emplace_back(edgenum, i * W + j + 1);\n                    edges[i * W + j + 1].emplace_back(edgenum, i * W + j);\n                    ++edgenum;\n                }\n            }\n            if(i == H - 1) continue;\n            rep(j, W) {\n                cin >> t_;\n                if(t_ == 0) {\n                    edges[i * W + j].emplace_back(edgenum, (i + 1) * W + j);\n                    edges[(i + 1) * W + j].emplace_back(edgenum, i * W + j);\n                    ++edgenum;\n                }\n            }\n        }\n        vector<vector<int>> wdist(edgenum, vector<int>(H * W, INF));\n        rep(i, edgenum) if(bfs(i, wdist[i])) goto fail;\n        cout << solve(wdist) << endl;\n        continue;\n      fail:\n        cout << \"-1\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\nclass State {\npublic:\n  int x;\n  int y;\n  int cost;\n  State(int x,int y,int cost)\n    : x(x), y(y), cost(cost) {}\n  bool operator<(const State& s) const {\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const {\n    return cost > s.cost;\n  }\n};\n\nbool walls[51][51][51][51];\nint mid2goal_cost[51][51][4];\n\nvoid compute_mid2goal_cost(int H,int W){\n\n  memset(mid2goal_cost,0x3f,sizeof(mid2goal_cost));\n\n  for(int sy = 0; sy < H; sy++){\n    for(int sx = 0; sx < W; sx++){\n      for(int dir = 0; dir < 4; dir++){\n        int tmp_mid2goal_cost[51][51];\n        memset(tmp_mid2goal_cost,0x3f,sizeof(tmp_mid2goal_cost));\n        priority_queue<State,vector<State>,greater<State> > que;\n        que.push(State(sx,sy,0));\n        tmp_mid2goal_cost[sy][sx] = 0;\n        while(!que.empty()){\n          State s = que.top();\n          que.pop();\n          \n          for(int i = 0; i < 4; i++){\n            int dx = tx[i] + s.x;\n            int dy = ty[i] + s.y;\n            if(dx >= W || dy >= H || dx < 0 || dy < 0) continue;\n            if(walls[s.y][s.x][dy][dx]) continue;\n            if(s.x == sx && s.y == sy && dir == i) continue;\n            if(tmp_mid2goal_cost[dy][dx] <= s.cost + 1) continue;\n            tmp_mid2goal_cost[dy][dx] = s.cost + 1;\n            que.push(State(dx,dy,s.cost + 1));\n          }\n        }\n\n        mid2goal_cost[sy][sx][dir] = tmp_mid2goal_cost[H-1][W-1];\n      }\n    }\n  } \n}\n\n\nint compute_goal2start_cost(int H,int W){\n  compute_mid2goal_cost(H,W);\n\n  int goal2start_cost[51][51];\n  memset(goal2start_cost,0x3f,sizeof(goal2start_cost));\n\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(W-1,H-1,0));\n  goal2start_cost[H-1][W-1] = 0;\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    for(int i = 0; i < 4; i++){\n      int dx = tx[i] + s.x;\n      int dy = ty[i] + s.y;\n      if(dx >= W || dy >= H || dx < 0 || dy < 0) continue;\n      if(walls[s.y][s.x][dy][dx]) continue;\n\n      int next_cost = max(s.cost + 1,mid2goal_cost[dy][dx][(i+2)%4]);\n      if(goal2start_cost[dy][dx] <= next_cost) continue;\n      goal2start_cost[dy][dx] = next_cost;\n      que.push(State(dx,dy,next_cost));\n    }\n  }\n  return (goal2start_cost[0][0] >= INF ? -1 : goal2start_cost[0][0]);\n}\n\nint main(){\n  int H,W;\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    if(H == 0 && W == 0) break;\n    memset(walls,false,sizeof(walls));\n\n    int patterns[] = {W - 1, W};\n    int accumulate[61] = {};\n    for(int i = 0; i < 60; i++){\n      accumulate[i + 1] = patterns[i % 2] + accumulate[i];\n    }\n\n    int pos = 0;\n    while(pos < ((H - 1) * W) + (H * (W - 1))){\n      int flag;\n      scanf(\"%d\",&flag);\n      int depth = (lower_bound(accumulate,accumulate + 61,pos+1) - accumulate);\n      int type = (depth-1) % 2;\n      if(type == 0){\n        int from_y = (depth - 1)/2;\n        int from_x = pos - accumulate[depth - 1];\n        int to_y = (depth - 1)/2;\n        int to_x = pos - accumulate[depth - 1] + 1;\n        walls[from_y][from_x][to_y][to_x] = (flag == 1 ? true : false);\n        walls[to_y][to_x][from_y][from_x] = (flag == 1 ? true : false);\n      }\n      else{\n        int from_y = (depth-1)/2;\n        int from_x = pos - accumulate[depth - 1];\n        int to_y = (depth-1)/2 + 1;\n        int to_x = pos - accumulate[depth - 1];\n        walls[from_y][from_x][to_y][to_x] = (flag == 1 ? true : false);\n        walls[to_y][to_x][from_y][from_x] = (flag == 1 ? true : false);\n      }\n      pos++;\n    }\n    printf(\"%d\\n\",compute_goal2start_cost(H,W));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\nconst int inf  = 999;\nconst int dx[] = {+1, 0,-1, 0};\nconst int dy[] = { 0,+1, 0,-1};\n\nint  H,W;\nint  dist [30][30];\nint  cost[30][30][4];\nbool graph[30][30][4];\n\nclass Data\n{\npublic:\n\tint x,y,dist,cost;\n\tData(int x, int y, int d, int c)\n\t: x(x), y(y), dist(d), cost(c) {}\n\tbool operator<(const Data &d) const\n\t{\n\t\tif(cost!=d.cost) return cost>d.cost;\n\t\tif(dist!=d.dist) return dist>d.dist;\n\t\treturn (x!=x ? x<d.x : y<d.y);\n\t}\n};\n\nvoid bfs(int sx, int sy)\n{\n\tqueue<Data> q;\n\tbool visited[30][30]={0};\n\n\tq.push( Data(sx, sy, 0, 0) );\n\tvisited[sx][sy] = 1;\n\n\tfor(int y=0; y<H; y++)\n\tfor(int x=0; x<W; x++)\n\t{\n\t\tdist[x][y]=inf;\n\t}\n\n\twhile(!q.empty())\n\t{\n\t\tData t=q.front(); q.pop();\n\t\tdist[t.x][t.y] = t.cost;\n\n\t\tfor(int i=0; i<4; i++)\n\t\t{\n\t\t\tif(!graph[t.x][t.y][i]) continue;\n\t\t\tint nx = t.x + dx[i];\n\t\t\tint ny = t.y + dy[i];\n\n\t\t\tif(visited[nx][ny]) continue;\n\t\t\tq.push( Data(nx, ny, 0, t.cost+1) );\n\t\t\tvisited[nx][ny] = 1;\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(cin>>H>>W, H||W)\n\t{\n\t\tmemset(graph, 0, sizeof(graph));\n\n\t\tfor(int y=0; y<H; y++)\n\t\t{\n\t\t\tint t;\n\t\t\tfor(int x=0; x<W-1; x++)\n\t\t\t{\n\t\t\t\tif(cin >> t, t==0)\n\t\t\t\t{\n\t\t\t\t\tgraph[x  ][y][0] = 1;\n\t\t\t\t\tgraph[x+1][y][2] = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(y==H-1) break;\n\t\t\tfor(int x=0; x<W; x++)\n\t\t\t{\n\t\t\t\tif(cin >> t, t==0)\n\t\t\t\t{\n\t\t\t\t\tgraph[x][y  ][1] = 1;\n\t\t\t\t\tgraph[x][y+1][3] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(cost, 0, sizeof(cost));\n\n\t\tfor(int x1=0; x1<W; x1++)\n\t\tfor(int y1=0; y1<H; y1++)\n\t\tfor(int  d=0;  d<2;  d++)\n\t\t{\n\t\t\tint x2 = x1 + dx[d];\n\t\t\tint y2 = y1 + dy[d];\n\n\t\t\tif(W<=x2) continue;\n\t\t\tif(H<=y2) continue;\n\n\t\t\tbool g = graph[x1][y1][d];\n\n\t\t\tgraph[x1][y1][d  ]=0;\n\t\t\tgraph[x2][y2][d+2]=0;\n\n\t\t\tbfs(W-1, H-1);\n\t\t\tcost[x1][y1][d  ]=dist[x1][y1];\n\t\t\tcost[x2][y2][d+2]=dist[x2][y2];\n\n\t\t\tgraph[x1][y1][d  ]=g;\n\t\t\tgraph[x2][y2][d+2]=g;\n\t\t}\n\n\t\tint  ans=inf;\n\t\tbool visited[30][30]={0};\n\t\tpriority_queue<Data> q;\n\t\tq.push( Data(0, 0, 0, 0) );\n\t\t\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tData t=q.top(); q.pop();\n\t\t\tif(t.x==W-1 && t.y==H-1)\n\t\t\t{\n\t\t\t\tans=t.cost; break;\n\t\t\t}\n\n\t\t\tif(visited[t.x][t.y]) continue;\n\t\t\tvisited[t.x][t.y]=1;\n\n\t\t\tfor(int i=0; i<4; i++)\n\t\t\t{\n\t\t\t\tif(!graph[t.x][t.y][i]) continue;\n\t\t\t\tint nx = t.x+dx[i];\n\t\t\t\tint ny = t.y+dy[i];\n\t\t\t\tif(visited[nx][ny]) continue;\n\t\t\t\tq.push( Data(nx, ny, t.dist+1, max(t.cost, t.dist+cost[t.x][t.y][i])) );\n\t\t\t}\n\t\t}\n\n\t\tif(inf<=ans) ans=-1;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#ifdef DEBUG_MODE\n    #define DBG(n) n;\n#else\n    #define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n \ntypedef long long ll;\ntypedef pair<pair<int,int>,int> P;\nint h,w;\npair<int,int> dp[33*33];\nint dist[33*33];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nvector<vector<int>> v(33*33);\n \nint fun(int a,int b){\n    REP(i,33*33)dist[i] = INF;\n    dist[a] = 0;\n    queue<pair<int,int>> q;\n    q.push(MP(a,0));\n    while(!q.empty()){\n        pair<int,int> now = q.front();q.pop();\n        int node = now.FI;\n        int kyo = now.SE;\n        if(kyo > dist[node])continue;\n        REP(i,v[node].size()){\n            int aite = v[node][i];\n            if((node == a && aite == b) || (node == b && aite == a))continue;\n            if(dist[aite] > kyo + 1){\n                dist[aite] = kyo + 1;\n                q.push(MP(aite,kyo+1));\n            }\n        }\n    }\n    return dist[h*w-1];\n}\n \nint main()\n{\n    while(cin >> h >> w,h|w){\n        //初期化\n        REP(i,33*33)dp[i] = MP(INF,INF);\n        REP(i,33*33){v[i].clear();}\n        dp[0] = MP(0,0);\n         \n        //入力\n        REP(i,h){\n            REP(j,w-1){\n                int tmp;cin >> tmp;\n                if(tmp == 0){\n                    v[i*w+j].PB(i*w+j+1);\n                    v[i*w+j+1].PB(i*w+j);\n                }\n                 \n            }\n            if(i != h-1)REP(j,w){\n                int tmp;cin >> tmp;\n                if(tmp == 0){\n                    v[i*w+j].PB((i+1)*w+j);\n                    v[(i+1)*w+j].PB(i*w+j);\n                }\n            }\n        }\n                 \n        priority_queue<P,vector<P>,greater<P>> q;\n        q.push(MP(MP(0,-1),0));\n        DBG(cout << \"!\" << endl;);\n        while(!q.empty()){\n            DBG(\n            cout << \"DP TABLE\" << endl;\n            REP(i,h){\n                REP(j,w){\n                    cout << dp[i*w+j].FI << ' ';\n                }\n                cout << endl;\n            }\n            )\n            P now = q.top();q.pop();\n            int node = now.SE;\n            pair<int,int> kyori = now.FI;\n            DBG(cout << kyori.FI << ' ' << kyori.SE << endl;)\n            DBG(cout << dp[node].FI << ' ' << dp[node].SE << endl;)\n            if(dp[node].FI < kyori.FI && dp[node].SE < kyori.SE)continue;\n            DBG(cout << \"IN\" << endl;)\n            kyori.SE++;\n            REP(i,v[node].size()){\n                int aite = v[node][i];\n                pair<int,int> score = MP(fun(node,aite)+kyori.SE,kyori.SE);\n                pair<int,int> seica = max(dp[node],score);\n                if(dp[aite].FI > seica.FI || dp[aite].SE > seica.SE){\n\t\t\t\t\tif(dp[aite] > seica)dp[aite] = seica;\n                    q.push(MP(MP(score.FI,kyori.SE),aite));\n                }\n            }\n        }\n         \n        DBG(\n        cout << \"DP TABLE\" << endl;\n        REP(i,h){\n            REP(j,w){\n                cout << dp[i*w+j].FI << ' ';\n            }\n            cout << endl;\n        }\n        )\n         \n        DBG(cout << \"ANS IS \";);\n         \n        if(dp[h*w-1].FI == INF){\n            cout << -1 << endl;\n        }\n        else{\n            cout << dp[h*w-1].FI << endl;\n        }\n    }\n \n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1178 A Broken Door\n// 2018.4.24 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 500\ntypedef struct { int t; int r, c; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int r, int c, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].r = r, que[i].c = c, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n// バッファを経ずstdinから数値を得る\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\twhile (c <= ' ') c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n \n#define INF 0x0101\nint hi[32][32], tr[32][32][4], tc[32][32][4];\nint dist[32][32], cost[32][32], cost2[32][32];\n\nint calc(int h, int w)\n{\n\tint i, r, c, t, nr, nc;\n\tint ll, rr, mi;\n\n\tll = cost[0][0], rr = INF;\n\twhile (ll+1 < rr) {\n\t\tmi = (ll+rr) >> 1;\n\n\t\tmemset(dist, INF, sizeof(dist));\n\t\tqsize = 0;\n\t\tdist[0][0] = 0, enq(0, 0, 0);\n\t\twhile (qsize) {\n\t\t\tr = que[0].r, c = que[0].c, t = que[0].t, deq();\n\t\t\tif (r == h && c == w) break;\n\t\t\tif (dist[r][c] < t) continue;\n\t\t\tfor (i = 0; i < hi[r][c]; i++) {\n\t\t\t\tnr = tr[r][c][i], nc = tc[r][c][i];\n\t\t\t\tif (cost[nr][nc] + t+1 >= mi) continue;\n\t\t\t\tif (dist[nr][nc] > t+1)\tdist[nr][nc] = t+1, enq(nr, nc, t+1);\n\t\t\t}\n\t\t}\n\t\tif (dist[h][w] < INF) rr = mi; else ll = mi;\n\t}\n\tif (rr == INF) rr = -1;\n\treturn rr;\n}\n\nint main()\n{\n\tint h, w, r, c, t, i;\n\tint r0, c0, nr, nc;\n\n\twhile (h = in()) {\n\t\tw = in();\n\t\tmemset(hi, 0, sizeof(hi));\n\n\t\tfor (r = 0; r < h; r++) {\n\t\t\tfor (c = 1; c < w; c++) if (in() == 0) {\n\t\t\t\tt = hi[r][c-1]++, tr[r][c-1][t] = r, tc[r][c-1][t] = c;\n\t\t\t\tt = hi[r][c  ]++, tr[r][c  ][t] = r, tc[r][c  ][t] = c-1;\n\t\t\t}\n\t\t\tif (r == h-1) break;\n\t\t\tfor (c = 0; c < w; c++) if (in() == 0) {\n\t\t\t\tt = hi[r  ][c]++, tr[r  ][c][t] = r+1, tc[r  ][c][t] = c;\n\t\t\t\tt = hi[r+1][c]++, tr[r+1][c][t] = r,   tc[r+1][c][t] = c;\n\t\t\t}\n\t\t}\n\n\t\tmemset(cost,  INF, sizeof(cost));\n\t\tmemset(cost2, INF, sizeof(cost2));\n\t\tfor (r0 = 0; r0 < h; r0++) for (c0 = 0; c0 < w; c0++) {\n\t\t\tmemset(dist, INF, sizeof(dist));\n\t\t\tqsize = 0;\n\t\t\tdist[h-1][w-1] = 0, enq(h-1, w-1, 0);\n\t\t\twhile (qsize) {\n\t\t\t\tr = que[0].r, c = que[0].c, t = que[0].t, deq();\n\t\t\t\tif (r == r0 && c == c0) continue;\n\t\t\t\tif (dist[r][c] < t) continue;\n\t\t\t\tfor (i = 0; i < hi[r][c]; i++) {\n\t\t\t\t\tnr = tr[r][c][i], nc = tc[r][c][i];\n\t\t\t\t\tif (dist[nr][nc] > t+1) dist[nr][nc] = t+1, enq(nr, nc, t+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < hi[r0][c0]; i++) {\n\t\t\t\tnr = tr[r0][c0][i], nc = tc[r0][c0][i];\n\t\t\t\tif (cost[r0][c0] > dist[nr][nc]) {\n\t\t\t\t\tcost[r0][c0] = dist[nr][nc];\n\t\t\t\t\tif (cost[r0][c0] < cost2[r0][c0]) {\n\t\t\t\t\t\tt = cost[r0][c0];\n\t\t\t\t\t\tcost[r0][c0] = cost2[r0][c0];\n\t\t\t\t\t\tcost2[r0][c0] = t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcost[h-1][w-1] = 0;\n\t\tprintf(\"%d\\n\", calc(h-1, w-1));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1178 A Broken Door\n// 2018.4.24 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef unsigned char uchar;\n#define QMAX 500\ntypedef struct { uchar t, r, c; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int r, int c, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].r = r, que[i].c = c, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n// バッファを経ずstdinから数値を得る\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\twhile (c <= ' ') c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n \n#define INF 0xff\nuchar hi[30][30], tr[30][30][4], tc[30][30][4];\nuchar dist[30][30], cost[30][30], cost2[30][30];\n\nint calc(int h, int w)\n{\n\tint i, r, c, t, nr, nc;\n\tint ll, rr, mi;\n\n\tll = cost[0][0], rr = INF;\n\twhile (ll+1 < rr) {\n\t\tmi = (ll+rr) >> 1;\n\n\t\tmemset(dist, INF, sizeof(dist));\n\t\tqsize = 0;\n\t\tdist[0][0] = 0, enq(0, 0, 0);\n\t\twhile (qsize) {\n\t\t\tr = que[0].r, c = que[0].c, t = que[0].t, deq();\n\t\t\tif (r == h && c == w) break;\n\t\t\tif (dist[r][c] < t) continue;\n\t\t\tfor (i = 0; i < hi[r][c]; i++) {\n\t\t\t\tnr = tr[r][c][i], nc = tc[r][c][i];\n\t\t\t\tif (cost[nr][nc] + t+1 >= mi) continue;\n\t\t\t\tif (dist[nr][nc] > t+1)\tdist[nr][nc] = t+1, enq(nr, nc, t+1);\n\t\t\t}\n\t\t}\n\t\tif (dist[h][w] < INF) rr = mi; else ll = mi;\n\t}\n\tif (rr == INF) rr = -1;\n\treturn rr;\n}\n\nint main()\n{\n\tint h, w, r, c, t, i;\n\tint r0, c0, nr, nc;\n\n\twhile (h = in()) {\n\t\tw = in();\n\t\tmemset(hi, 0, sizeof(hi));\n\n\t\tfor (r = 0; r < h; r++) {\n\t\t\tfor (c = 1; c < w; c++) if (in() == 0) {\n\t\t\t\tt = hi[r][c-1]++, tr[r][c-1][t] = r, tc[r][c-1][t] = c;\n\t\t\t\tt = hi[r][c  ]++, tr[r][c  ][t] = r, tc[r][c  ][t] = c-1;\n\t\t\t}\n\t\t\tif (r == h-1) break;\n\t\t\tfor (c = 0; c < w; c++) if (in() == 0) {\n\t\t\t\tt = hi[r  ][c]++, tr[r  ][c][t] = r+1, tc[r  ][c][t] = c;\n\t\t\t\tt = hi[r+1][c]++, tr[r+1][c][t] = r,   tc[r+1][c][t] = c;\n\t\t\t}\n\t\t}\n\n\t\tmemset(cost,  INF, sizeof(cost));\n\t\tmemset(cost2, INF, sizeof(cost2));\n\t\tfor (r0 = 0; r0 < h; r0++) for (c0 = 0; c0 < w; c0++) {\n\t\t\tmemset(dist, INF, sizeof(dist));\n\t\t\tqsize = 0;\n\t\t\tdist[h-1][w-1] = 0, enq(h-1, w-1, 0);\n\t\t\twhile (qsize) {\n\t\t\t\tr = que[0].r, c = que[0].c, t = que[0].t, deq();\n\t\t\t\tif (r == r0 && c == c0) continue;\n\t\t\t\tif (dist[r][c] < t) continue;\n\t\t\t\tfor (i = 0; i < hi[r][c]; i++) {\n\t\t\t\t\tnr = tr[r][c][i], nc = tc[r][c][i];\n\t\t\t\t\tif (dist[nr][nc] > t+1) dist[nr][nc] = t+1, enq(nr, nc, t+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < hi[r0][c0]; i++) {\n\t\t\t\tnr = tr[r0][c0][i], nc = tc[r0][c0][i];\n\t\t\t\tif (cost[r0][c0] > dist[nr][nc]) {\n\t\t\t\t\tcost[r0][c0] = dist[nr][nc];\n\t\t\t\t\tif (cost[r0][c0] < cost2[r0][c0]) {\n\t\t\t\t\t\tt = cost[r0][c0];\n\t\t\t\t\t\tcost[r0][c0] = cost2[r0][c0];\n\t\t\t\t\t\tcost2[r0][c0] = t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcost[h-1][w-1] = 0;\n\t\tprintf(\"%d\\n\", calc(h-1, w-1));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ　1178 A Broken Door\n// 2018.4.24 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 500\ntypedef struct { int t; int r, c; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int r, int c, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].r = r, que[i].c = c, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n// バッファを経ずstdinから数値を得る\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\twhile (c <= ' ') c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n \n#define INF 0x01010101\nint hi[32][32], tr[32][32][4], tc[32][32][4];\nint dist[32][32], cost[32][32][2];\nint q[1000][2], top, end;\n\nvoid calc(int x)\n{\n\tint i, r, c, nr, nc;\n\n\tmemset(dist, INF, sizeof(dist));\n\tdist[0][0] = 0;\n\tq[0][0] = 0, q[0][1] = 0, top = 0, end = 1;\n\twhile (top != end) {\n\t\tr = q[top][0], c = q[top++][1];\n\t\tfor (i = 0; i < hi[r][c]; i++) {\n\t\t\tnr = tr[r][c][i], nc = tc[r][c][i];\n\t\t\tif (cost[nr][nc][1] + 1 + dist[r][c] < x && dist[nr][nc] > dist[r][c]+1) {\n\t\t\t\tdist[nr][nc] = dist[r][c]+1;\n\t\t\t\tq[end][0] = nr, q[end++][1] = nc;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint h, w, r, c, t, i, r0, c0, nr, nc;\n\tint ll, rr, mi, max;\n\n\twhile (h = in()) {\n\t\tw = in();\n\t\tmemset(hi, 0, sizeof(hi));\n\n\t\tfor (r = 0; r < h; r++) {\n\t\t\tfor (c = 1; c < w; c++) if (in() == 0) {\n\t\t\t\tt = hi[r][c-1]++, tr[r][c-1][t] = r, tc[r][c-1][t] = c;\n\t\t\t\tt = hi[r][c  ]++, tr[r][c  ][t] = r, tc[r][c  ][t] = c-1;\n\t\t\t}\n\t\t\tif (r == h-1) break;\n\t\t\tfor (c = 0; c < w; c++) if (in() == 0) {\n\t\t\t\tt = hi[r  ][c]++, tr[r  ][c][t] = r+1, tc[r  ][c][t] = c;\n\t\t\t\tt = hi[r+1][c]++, tr[r+1][c][t] = r,   tc[r+1][c][t] = c;\n\t\t\t}\n\t\t}\n\n\t\tmax = INF;\n\t\tfor (r0 = 0; r0 < h; r0++) for (c0 = 0; c0 < w; c0++) {\n\t\t\tmemset(dist, INF, sizeof(dist));\n\t\t\tqsize = 0;\n\t\t\tdist[h-1][w-1] = 0, enq(h-1, w-1, 0);\n\t\t\twhile (qsize) {\n\t\t\t\tr = que[0].r, c = que[0].c, t = que[0].t, deq();\n\t\t\t\tif (r == r0 && c == c0) continue;\n\t\t\t\tif (dist[r][c] < t) continue;\n\t\t\t\tfor (i = 0; i < hi[r][c]; i++) {\n\t\t\t\t\tnr = tr[r][c][i], nc = tc[r][c][i];\n\t\t\t\t\tif (dist[nr][nc] > t+1) dist[nr][nc] = t+1, enq(nr, nc, t+1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcost[r0][c0][0] = cost[r0][c0][1] = INF;\n\t\t\tfor (i = 0; i < hi[r0][c0]; i++) {\n\t\t\t\tnr = tr[r0][c0][i], nc = tc[r0][c0][i];\n\t\t\t\tif (cost[r0][c0][1] > dist[nr][nc]) {\n\t\t\t\t\tcost[r0][c0][1] = dist[nr][nc];\n\t\t\t\t\tif (cost[r0][c0][0] > cost[r0][c0][1]) {\n\t\t\t\t\t\tt = cost[r0][c0][0];\n\t\t\t\t\t\tcost[r0][c0][0] = cost[r0][c0][1];\n\t\t\t\t\t\tcost[r0][c0][1] = t;\n\t\t\t\t\t}\n\t\t\t\t\tif (cost[r0][c0][1] > max) max = cost[r0][c0][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcost[h-1][w-1][0] = cost[h-1][w-1][1] = 0;\n\n\t\tll = cost[0][0][1], rr = max;\n\t\twhile (ll < rr) {\n\t\t\tmi = (ll+rr) >> 1;\n\t\t\tcalc(mi);\n\t\t\tif (dist[h-1][w-1] < INF) rr = mi; else ll = mi+1;\n\t\t}\n\t\tif (ll < INF) printf(\"%d\\n\", ll);\n\t\telse puts(\"-1\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1178 A Broken Door\n// 2018.4.24 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n// バッファを経ずstdinから数値を得る\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\twhile (c <= ' ') c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n \n#define INF 0xff\ntypedef unsigned char uchar;\n\ntypedef struct { uchar r, c, t; } QUE;\nQUE que[905]; int top, end;\nuchar hi[30][30], tr[30][30][4], tc[30][30][4];\nuchar dist[30][30], cost[30][30], cost2[30][30];\n\nint calc(int h, int w)\n{\n\tint i, r, c, t, nr, nc;\n\tint ll, rr, mi;\n\n\tll = cost[0][0], rr = INF;\n\twhile (ll+1 < rr) {\n\t\tmi = (ll+rr) >> 1;\n\n\t\tmemset(dist, INF, sizeof(dist));\n\t\tdist[0][0] = 0;\n\t\tque[0].r = 0, que[0].c = 0, que[0].t = 0, top = 0, end = 1;\n\t\twhile (top != end) {\n\t\t\tr = que[top].r, c = que[top].c, t = que[top++].t;\n\t\t\tif (r == h && c == w) break;\n\t\t\tif (dist[r][c] < t) continue;\n\t\t\tfor (i = 0; i < hi[r][c]; i++) {\n\t\t\t\tnr = tr[r][c][i], nc = tc[r][c][i];\n\t\t\t\tif (cost[nr][nc] + t+1 >= mi) continue;\n\t\t\t\tif (dist[nr][nc] > t+1)\t{\n\t\t\t\t\tdist[nr][nc] = t+1;\n\t\t\t\t\tque[end].r = nr, que[end].c = nc, que[end++].t = t+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[h][w] < INF) rr = mi; else ll = mi;\n\t}\n\tif (rr == INF) rr = -1;\n\treturn rr;\n}\n\nint main()\n{\n\tint h, w, r, c, t, i;\n\tint r0, c0, nr, nc;\n\n\twhile (h = in()) {\n\t\tw = in();\n\t\tmemset(hi, 0, sizeof(hi));\n\n\t\tfor (r = 0; r < h; r++) {\n\t\t\tfor (c = 1; c < w; c++) if (in() == 0) {\n\t\t\t\tt = hi[r][c-1]++, tr[r][c-1][t] = r, tc[r][c-1][t] = c;\n\t\t\t\tt = hi[r][c  ]++, tr[r][c  ][t] = r, tc[r][c  ][t] = c-1;\n\t\t\t}\n\t\t\tif (r == h-1) break;\n\t\t\tfor (c = 0; c < w; c++) if (in() == 0) {\n\t\t\t\tt = hi[r  ][c]++, tr[r  ][c][t] = r+1, tc[r  ][c][t] = c;\n\t\t\t\tt = hi[r+1][c]++, tr[r+1][c][t] = r,   tc[r+1][c][t] = c;\n\t\t\t}\n\t\t}\n\n\t\tmemset(cost,  INF, sizeof(cost));\n\t\tmemset(cost2, INF, sizeof(cost2));\n\t\tfor (r0 = 0; r0 < h; r0++) for (c0 = 0; c0 < w; c0++) {\n\t\t\tmemset(dist, INF, sizeof(dist));\n\t\t\tdist[h-1][w-1] = 0;\n\t\t\tque[0].r = h-1, que[0].c = w-1, que[0].t = 0, top = 0, end = 1;\n\t\t\twhile (top != end) {\n\t\t\t\tr = que[top].r, c = que[top].c, t = que[top++].t;\n\t\t\t\tif (r == r0 && c == c0) continue;\n\t\t\t\tif (dist[r][c] < t) continue;\n\t\t\t\tfor (i = 0; i < hi[r][c]; i++) {\n\t\t\t\t\tnr = tr[r][c][i], nc = tc[r][c][i];\n\t\t\t\t\tif (dist[nr][nc] > t+1) {\n\t\t\t\t\t\tdist[nr][nc] = t+1;\n\t\t\t\t\t\tque[end].r = nr, que[end].c = nc, que[end++].t = t+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < hi[r0][c0]; i++) {\n\t\t\t\tnr = tr[r0][c0][i], nc = tc[r0][c0][i];\n\t\t\t\tif (cost[r0][c0] > dist[nr][nc]) {\n\t\t\t\t\tcost[r0][c0] = dist[nr][nc];\n\t\t\t\t\tif (cost[r0][c0] < cost2[r0][c0]) {\n\t\t\t\t\t\tt = cost[r0][c0];\n\t\t\t\t\t\tcost[r0][c0] = cost2[r0][c0];\n\t\t\t\t\t\tcost2[r0][c0] = t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcost[h-1][w-1] = 0;\n\t\tprintf(\"%d\\n\", calc(h-1, w-1));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1178 A Broken Door\n// 2018.4.24 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 500\ntypedef struct { short t; char r, c; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int r, int c, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].r = r, que[i].c = c, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n// バッファを経ずstdinから数値を得る\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\twhile (c <= ' ') c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n \n#define INF 0x0303\nchar  hi[32][32], tr[32][32][4], tc[32][32][4];\nshort dist[32][32], cost[32][32][2];\nchar  q[1000][2]; int top, end;\n\nint calc(int h, int w)\n{\n\tint i, r, c, nr, nc;\n\tint ll, rr, mi;\n\n\tll = cost[0][0][1], rr = INF;\n\twhile (ll+1 < rr) {\n\t\tmi = (ll+rr) >> 1;\n\n\t\tmemset(dist, INF, sizeof(dist));\n\t\tdist[0][0] = 0;\n\t\tq[0][0] = 0, q[0][1] = 0, top = 0, end = 1;\n\t\twhile (top != end) {\n\t\t\tr = q[top][0], c = q[top++][1];\n\t\t\tfor (i = 0; i < hi[r][c]; i++) {\n\t\t\t\tnr = tr[r][c][i], nc = tc[r][c][i];\n\t\t\t\tif (cost[nr][nc][1] + 1 + dist[r][c] < mi && dist[nr][nc] > dist[r][c]+1) {\n\t\t\t\t\tdist[nr][nc] = dist[r][c]+1;\n\t\t\t\t\tq[end][0] = nr, q[end++][1] = nc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[h-1][w-1] < INF) rr = mi; else ll = mi;\n\t}\n\tif (rr == INF) rr = -1;\n\treturn rr;\n}\n\nint main()\n{\n\tint h, w, r, c, t, i, r0, c0, nr, nc;\n\n\twhile (h = in()) {\n\t\tw = in();\n\t\tmemset(hi, 0, sizeof(hi));\n\n\t\tfor (r = 0; r < h; r++) {\n\t\t\tfor (c = 1; c < w; c++) if (in() == 0) {\n\t\t\t\tt = hi[r][c-1]++, tr[r][c-1][t] = r, tc[r][c-1][t] = c;\n\t\t\t\tt = hi[r][c  ]++, tr[r][c  ][t] = r, tc[r][c  ][t] = c-1;\n\t\t\t}\n\t\t\tif (r == h-1) break;\n\t\t\tfor (c = 0; c < w; c++) if (in() == 0) {\n\t\t\t\tt = hi[r  ][c]++, tr[r  ][c][t] = r+1, tc[r  ][c][t] = c;\n\t\t\t\tt = hi[r+1][c]++, tr[r+1][c][t] = r,   tc[r+1][c][t] = c;\n\t\t\t}\n\t\t}\n\n\t\tfor (r0 = 0; r0 < h; r0++) for (c0 = 0; c0 < w; c0++) {\n\t\t\tmemset(dist, INF, sizeof(dist));\n\t\t\tqsize = 0;\n\t\t\tdist[h-1][w-1] = 0, enq(h-1, w-1, 0);\n\t\t\twhile (qsize) {\n\t\t\t\tr = que[0].r, c = que[0].c, t = que[0].t, deq();\n\t\t\t\tif (r == r0 && c == c0) continue;\n\t\t\t\tif (dist[r][c] < t) continue;\n\t\t\t\tfor (i = 0; i < hi[r][c]; i++) {\n\t\t\t\t\tnr = tr[r][c][i], nc = tc[r][c][i];\n\t\t\t\t\tif (dist[nr][nc] > t+1) dist[nr][nc] = t+1, enq(nr, nc, t+1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcost[r0][c0][0] = cost[r0][c0][1] = INF;\n\t\t\tfor (i = 0; i < hi[r0][c0]; i++) {\n\t\t\t\tnr = tr[r0][c0][i], nc = tc[r0][c0][i];\n\t\t\t\tif (cost[r0][c0][1] > dist[nr][nc]) {\n\t\t\t\t\tcost[r0][c0][1] = dist[nr][nc];\n\t\t\t\t\tif (cost[r0][c0][0] > cost[r0][c0][1]) {\n\t\t\t\t\t\tt = cost[r0][c0][0];\n\t\t\t\t\t\tcost[r0][c0][0] = cost[r0][c0][1];\n\t\t\t\t\t\tcost[r0][c0][1] = t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcost[h-1][w-1][1] = 0;\n\n\t\tprintf(\"%d\\n\", calc(h, w));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ　1178 A Broken Door\n// 2018.4.24 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 500\ntypedef struct { int t; int r, c; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int r, int c, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].r = r, que[i].c = c, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n// バッファを経ずstdinから数値を得る\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\twhile (c <= ' ') c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n \n#define INF 0x01010101\nint hi[32][32], tr[32][32][4], tc[32][32][4];\nint dist[32][32], cost[32][32][2];\nint q[1000][2], top;\n\nvoid calc(int x)\n{\n\tint i, r, c, nr, nc;\n\n\tmemset(dist, INF, sizeof(dist));\n\tdist[0][0] = 0;\n\tq[0][0] = 0, q[0][1] = 0, top = 1;\n\twhile (top) {\n\t\tr = q[--top][0], c = q[top][1];\n\t\tfor (i = 0; i < hi[r][c]; i++) {\n\t\t\tnr = tr[r][c][i], nc = tc[r][c][i];\n\t\t\tif (cost[nr][nc][1] + 1 + dist[r][c] < x && dist[nr][nc] > dist[r][c]+1) {\n\t\t\t\tdist[nr][nc] = dist[r][c]+1;\n\t\t\t\tq[top][0] = nr, q[top++][1] = nc;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint h, w, r, c, t, i, r0, c0, nr, nc;\n\tint ll, rr, mi, max;\n\n\twhile (h = in()) {\n\t\tw = in();\n\t\tmemset(hi, 0, sizeof(hi));\n\n\t\tfor (r = 0; r < h; r++) {\n\t\t\tfor (c = 1; c < w; c++) if (in() == 0) {\n\t\t\t\tt = hi[r][c-1]++, tr[r][c-1][t] = r, tc[r][c-1][t] = c;\n\t\t\t\tt = hi[r][c  ]++, tr[r][c  ][t] = r, tc[r][c  ][t] = c-1;\n\t\t\t}\n\t\t\tif (r == h-1) break;\n\t\t\tfor (c = 0; c < w; c++) if (in() == 0) {\n\t\t\t\tt = hi[r  ][c]++, tr[r  ][c][t] = r+1, tc[r  ][c][t] = c;\n\t\t\t\tt = hi[r+1][c]++, tr[r+1][c][t] = r,   tc[r+1][c][t] = c;\n\t\t\t}\n\t\t}\n\n\t\tmax = INF;\n\t\tfor (r0 = 0; r0 < h; r0++) for (c0 = 0; c0 < w; c0++) {\n\t\t\tmemset(dist, INF, sizeof(dist));\n\t\t\tqsize = 0;\n\t\t\tdist[h-1][w-1] = 0, enq(h-1, w-1, 0);\n\t\t\twhile (qsize) {\n\t\t\t\tr = que[0].r, c = que[0].c, t = que[0].t, deq();\n\t\t\t\tif (r == r0 && c == c0) continue;\n\t\t\t\tif (dist[r][c] < t) continue;\n\t\t\t\tfor (i = 0; i < hi[r][c]; i++) {\n\t\t\t\t\tnr = tr[r][c][i], nc = tc[r][c][i];\n\t\t\t\t\tif (dist[nr][nc] > t+1) dist[nr][nc] = t+1, enq(nr, nc, t+1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcost[r0][c0][0] = cost[r0][c0][1] = INF;\n\t\t\tfor (i = 0; i < hi[r0][c0]; i++) {\n\t\t\t\tnr = tr[r0][c0][i], nc = tc[r0][c0][i];\n\t\t\t\tif (cost[r0][c0][1] > dist[nr][nc]) {\n\t\t\t\t\tcost[r0][c0][1] = dist[nr][nc];\n\t\t\t\t\tif (cost[r0][c0][0] > cost[r0][c0][1]) {\n\t\t\t\t\t\tt = cost[r0][c0][0];\n\t\t\t\t\t\tcost[r0][c0][0] = cost[r0][c0][1];\n\t\t\t\t\t\tcost[r0][c0][1] = t;\n\t\t\t\t\t}\n\t\t\t\t\tif (cost[r0][c0][1] > max) max = cost[r0][c0][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcost[h-1][w-1][0] = cost[h-1][w-1][1] = 0;\n\n\t\tll = cost[0][0][1], rr = max;\n\t\twhile (ll < rr) {\n\t\t\tmi = (ll+rr) >> 1;\n\t\t\tcalc(mi);\n\t\t\tif (dist[h-1][w-1] < INF) rr = mi; else ll = mi+1;\n\t\t}\n\t\tif (ll < INF) printf(\"%d\\n\", ll);\n\t\telse puts(\"-1\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1178 A Broken Door\n// 2018.4.24 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 500\ntypedef struct { int t; int r, c; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int r, int c, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].r = r, que[i].c = c, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n// バッファを経ずstdinから数値を得る\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\twhile (c <= ' ') c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n \n#define INF 0x01010101\nint hi[32][32], tr[32][32][4], tc[32][32][4];\nint dist[32][32], cost[32][32][2];\nint q[1000][2], top, end;\n\nvoid calc(int x)\n{\n\tint i, r, c, nr, nc;\n\n\tmemset(dist, INF, sizeof(dist));\n\tdist[0][0] = 0;\n\tq[0][0] = 0, q[0][1] = 0, top = 0, end = 1;\n\twhile (top != end) {\n\t\tr = q[top][0], c = q[top++][1];\n\t\tfor (i = 0; i < hi[r][c]; i++) {\n\t\t\tnr = tr[r][c][i], nc = tc[r][c][i];\n\t\t\tif (cost[nr][nc][1] + 1 + dist[r][c] < x && dist[nr][nc] > dist[r][c]+1) {\n\t\t\t\tdist[nr][nc] = dist[r][c]+1;\n\t\t\t\tq[end][0] = nr, q[end++][1] = nc;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint h, w, r, c, t, i, r0, c0, nr, nc;\n\tint ll, rr, mi, max;\n\n\twhile (h = in()) {\n\t\tw = in();\n\t\tmemset(hi, 0, sizeof(hi));\n\n\t\tfor (r = 0; r < h; r++) {\n\t\t\tfor (c = 1; c < w; c++) if (in() == 0) {\n\t\t\t\tt = hi[r][c-1]++, tr[r][c-1][t] = r, tc[r][c-1][t] = c;\n\t\t\t\tt = hi[r][c  ]++, tr[r][c  ][t] = r, tc[r][c  ][t] = c-1;\n\t\t\t}\n\t\t\tif (r == h-1) break;\n\t\t\tfor (c = 0; c < w; c++) if (in() == 0) {\n\t\t\t\tt = hi[r  ][c]++, tr[r  ][c][t] = r+1, tc[r  ][c][t] = c;\n\t\t\t\tt = hi[r+1][c]++, tr[r+1][c][t] = r,   tc[r+1][c][t] = c;\n\t\t\t}\n\t\t}\n\n\t\tmax = INF;\n\t\tfor (r0 = 0; r0 < h; r0++) for (c0 = 0; c0 < w; c0++) {\n\t\t\tmemset(dist, INF, sizeof(dist));\n\t\t\tqsize = 0;\n\t\t\tdist[h-1][w-1] = 0, enq(h-1, w-1, 0);\n\t\t\twhile (qsize) {\n\t\t\t\tr = que[0].r, c = que[0].c, t = que[0].t, deq();\n\t\t\t\tif (r == r0 && c == c0) continue;\n\t\t\t\tif (dist[r][c] < t) continue;\n\t\t\t\tfor (i = 0; i < hi[r][c]; i++) {\n\t\t\t\t\tnr = tr[r][c][i], nc = tc[r][c][i];\n\t\t\t\t\tif (dist[nr][nc] > t+1) dist[nr][nc] = t+1, enq(nr, nc, t+1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcost[r0][c0][0] = cost[r0][c0][1] = INF;\n\t\t\tfor (i = 0; i < hi[r0][c0]; i++) {\n\t\t\t\tnr = tr[r0][c0][i], nc = tc[r0][c0][i];\n\t\t\t\tif (cost[r0][c0][1] > dist[nr][nc]) {\n\t\t\t\t\tcost[r0][c0][1] = dist[nr][nc];\n\t\t\t\t\tif (cost[r0][c0][0] > cost[r0][c0][1]) {\n\t\t\t\t\t\tt = cost[r0][c0][0];\n\t\t\t\t\t\tcost[r0][c0][0] = cost[r0][c0][1];\n\t\t\t\t\t\tcost[r0][c0][1] = t;\n\t\t\t\t\t}\n\t\t\t\t\tif (cost[r0][c0][1] > max) max = cost[r0][c0][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcost[h-1][w-1][1] = 0;\n\n\t\tll = cost[0][0][1], rr = max;\n\t\twhile (ll+1 < rr) {\n\t\t\tmi = (ll+rr) >> 1;\n\t\t\tcalc(mi);\n\t\t\tif (dist[h-1][w-1] < INF) rr = mi; else ll = mi;\n\t\t}\n\t\tif (rr < INF) printf(\"%d\\n\", rr);\n\t\telse puts(\"-1\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1178 A Broken Door\n// 2018.4.24 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 500\ntypedef struct { short t; char r, c; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int r, int c, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].r = r, que[i].c = c, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n// バッファを経ずstdinから数値を得る\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\twhile (c <= ' ') c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n \n#define INF 0x0303\nchar  hi[32][32], tr[32][32][4], tc[32][32][4];\nshort dist[32][32], cost[32][32], cost2[32][32];\n\nint calc(int h, int w)\n{\n\tint i, r, c, t, nr, nc;\n\tint ll, rr, mi;\n\n\tll = cost[0][0], rr = INF;\n\twhile (ll+1 < rr) {\n\t\tmi = (ll+rr) >> 1;\n\n\t\tmemset(dist, INF, sizeof(dist));\n\t\tqsize = 0;\n\t\tdist[0][0] = 0, enq(0, 0, 0);\n\t\twhile (qsize) {\n\t\t\tr = que[0].r, c = que[0].c, t = que[0].t, deq();\n\t\t\tif (r == h && c == w) break;\n\t\t\tif (dist[r][c] < t) continue;\n\t\t\tfor (i = 0; i < hi[r][c]; i++) {\n\t\t\t\tnr = tr[r][c][i], nc = tc[r][c][i];\n\t\t\t\tif (cost[nr][nc] + t+1 < mi) {\n\t\t\t\t\tif (dist[nr][nc] > t+1)\tdist[nr][nc] = t+1, enq(nr, nc, t+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[h][w] < INF) rr = mi; else ll = mi;\n\t}\n\tif (rr == INF) rr = -1;\n\treturn rr;\n}\n\nint main()\n{\n\tint h, w, r, c, t, i;\n\tint r0, c0, nr, nc;\n\n\twhile (h = in()) {\n\t\tw = in();\n\t\tmemset(hi, 0, sizeof(hi));\n\n\t\tfor (r = 0; r < h; r++) {\n\t\t\tfor (c = 1; c < w; c++) if (in() == 0) {\n\t\t\t\tt = hi[r][c-1]++, tr[r][c-1][t] = r, tc[r][c-1][t] = c;\n\t\t\t\tt = hi[r][c  ]++, tr[r][c  ][t] = r, tc[r][c  ][t] = c-1;\n\t\t\t}\n\t\t\tif (r == h-1) break;\n\t\t\tfor (c = 0; c < w; c++) if (in() == 0) {\n\t\t\t\tt = hi[r  ][c]++, tr[r  ][c][t] = r+1, tc[r  ][c][t] = c;\n\t\t\t\tt = hi[r+1][c]++, tr[r+1][c][t] = r,   tc[r+1][c][t] = c;\n\t\t\t}\n\t\t}\n\n\t\tmemset(cost,  INF, sizeof(cost));\n\t\tmemset(cost2, INF, sizeof(cost2));\n\t\tfor (r0 = 0; r0 < h; r0++) for (c0 = 0; c0 < w; c0++) {\n\t\t\tmemset(dist, INF, sizeof(dist));\n\t\t\tqsize = 0;\n\t\t\tdist[h-1][w-1] = 0, enq(h-1, w-1, 0);\n\t\t\twhile (qsize) {\n\t\t\t\tr = que[0].r, c = que[0].c, t = que[0].t, deq();\n\t\t\t\tif (r == r0 && c == c0) continue;\n\t\t\t\tif (dist[r][c] < t) continue;\n\t\t\t\tfor (i = 0; i < hi[r][c]; i++) {\n\t\t\t\t\tnr = tr[r][c][i], nc = tc[r][c][i];\n\t\t\t\t\tif (dist[nr][nc] > t+1) dist[nr][nc] = t+1, enq(nr, nc, t+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < hi[r0][c0]; i++) {\n\t\t\t\tnr = tr[r0][c0][i], nc = tc[r0][c0][i];\n\t\t\t\tif (cost[r0][c0] > dist[nr][nc]) {\n\t\t\t\t\tcost[r0][c0] = dist[nr][nc];\n\t\t\t\t\tif (cost[r0][c0] < cost2[r0][c0]) {\n\t\t\t\t\t\tt = cost[r0][c0];\n\t\t\t\t\t\tcost[r0][c0] = cost2[r0][c0];\n\t\t\t\t\t\tcost2[r0][c0] = t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcost[h-1][w-1] = 0;\n\t\tprintf(\"%d\\n\", calc(h-1, w-1));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\n\t}\n\n\tvoid solve(ArrayList<Integer>[] g, int h, int w) {\n\t\tclass P implements Comparable<P> {\n\t\t\tint e;\n\t\t\tint cur;\n\t\t\tint dist;\n\n\t\t\tpublic P(int cur, int e, int dist) {\n\t\t\t\tthis.cur = cur;\n\t\t\t\tthis.e = e;\n\t\t\t\tthis.dist = dist;\n\t\t\t}\n\n\t\t\tpublic int compareTo(P o) {\n\t\t\t\treturn Integer.compare(e, o.e);\n\t\t\t};\n\n\t\t}\n\t\tint[] d = dist(g, h, w, 0, -1, -1);\n\t\tif (d[h * w - 1] > 1000) {\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t}\n\n\t\tint[] e = new int[h * w];// e[i]:=??????(i)?????°????????????????????????????????????????????§?????°???????°????\n\t\tint[] dist = new int[h * w];\n\t\tArrays.fill(e, Integer.MAX_VALUE / 16);\n\t\tArrays.fill(dist, Integer.MAX_VALUE / 16);\n\t\te[0] = 0;\n\t\tdist[0] = 0;\n\t\tPriorityQueue<P> pq = new PriorityQueue<>();\n\t\tpq.add(new P(0, 0, 0));\n\t\twhile (!pq.isEmpty()) {\n\t\t\tP p = pq.poll();\n\t\t\tif (p.cur == h * w - 1) {\n\t\t\t\tif (p.e < 1000) {\n\t\t\t\t\tSystem.out.println(p.e);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (dist[p.cur] < p.dist)\n\t\t\t\tcontinue;\n\t\t\tfor (int dst : g[p.cur]) {\n\t\t\t\t// ???????????¨?????????????????????????????´???\n\t\t\t\tint ne = Math.max(p.e, p.dist + dist(g, h, w, p.cur, p.cur, dst)[h * w - 1]);\n\t\t\t\t// ???????????´???\n\t\t\t\tne = Math.max(ne, p.dist + 1);\n\t\t\t\tif (e[dst] > ne) {\n\t\t\t\t\te[dst] = ne;\n\t\t\t\t}\n\t\t\t\tif (dist[dst] > p.dist + 1) {\n\t\t\t\t\tpq.add(new P(dst, ne, p.dist + 1));\n\t\t\t\t\tdist[dst] = p.dist + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (e[h * w - 1] > 1000)\n\n\t\t{\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.println(e[h * w - 1]);\n\t}\n\n\t// e=(bs,bd)??????????????????\n\t// ????????????s??????h*w-1???????????????????????\\????????????\n\tint[] dist(ArrayList<Integer>[] g, int h, int w, int s, int bs, int bd) {\n\t\tint[] d = new int[h * w];\n\t\tArrays.fill(d, Integer.MAX_VALUE / 16);\n\t\td[s] = 0;\n\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\tque.add(s);\n\t\twhile (!que.isEmpty()) {\n\t\t\tint v = que.poll();\n\t\t\tfor (int dst : g[v]) {\n\t\t\t\tif (dst == bs && v == bd)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (dst == bd && v == bs)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (d[dst] > d[v] + 1) {\n\t\t\t\t\td[dst] = d[v] + 1;\n\t\t\t\t\tque.add(dst);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tDJSet ds = new DJSet(h * w);\n\t\t\tif (h == 0 && w == 0)\n\t\t\t\tbreak;\n\t\t\tArrayList<Integer>[] g = new ArrayList[h * w];\n\t\t\tfor (int i = 0; i < g.length; ++i) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < 2 * h - 1; ++i) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tint[] a = new int[w - 1];\n\t\t\t\t\t// a[j]=0???????????????(i/2*h+j)?????????(i/2*h+j+1)??¨??\\?¶????\n\t\t\t\t\tfor (int j = 0; j < a.length; ++j) {\n\t\t\t\t\t\ta[j] = sc.nextInt();\n\t\t\t\t\t\tif (a[j] == 0) {\n\t\t\t\t\t\t\tg[i / 2 * w + j].add(i / 2 * w + j + 1);\n\t\t\t\t\t\t\tg[i / 2 * w + j + 1].add(i / 2 * w + j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint[] a = new int[w];\n\t\t\t\t\t// a[j]=0???????????????(i/2*h+j)?????????((i/2+1)*h+j)??¨??\\?¶????\n\t\t\t\t\tfor (int j = 0; j < a.length; ++j) {\n\t\t\t\t\t\ta[j] = sc.nextInt();\n\t\t\t\t\t\tif (a[j] == 0) {\n\t\t\t\t\t\t\tg[i / 2 * w + j].add((i / 2 + 1) * w + j);\n\t\t\t\t\t\t\tg[(i / 2 + 1) * w + j].add(i / 2 * w + j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve(g, h, w);\n\t\t}\n\t}\n\n\tclass DJSet {\n\t\tint n;\n\t\tint[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tthis.n = n;\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tint tmp = x;\n\t\t\t\tx = y;\n\t\t\t\ty = tmp;\n\t\t\t}\n\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int INF = Integer.MAX_VALUE / 2 - 1;\n\t\n\tpublic static final int DIRS  = 4;\n\tpublic static final int UP    = 0;\n\tpublic static final int LEFT  = 1;\n\tpublic static final int DOWN  = 2;\n\tpublic static final int RIGHT = 3;\n\t\n\tpublic static final int[][] move_dir = new int[][]{{0,-1}, {-1, 0}, {0, 1}, {1, 0}};\n\t\n\tpublic static final int MAX_SIZE = 30;\n\tpublic static final int MAX_WALL = 900;\n\t\n\tpublic static boolean is_ok(int x, int y, int w, int h){\n\t\tif(x < 0 || y < 0 || x >= w || y >= h){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static class Walk implements Comparable<Walk>{\n\t\tint x, y;\n\t\tint time;\n\t\tint worth_time;\n\t\t\n\t\tpublic Walk(int x, int y, int time, int worth_time){\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.time = time;\n\t\t\tthis.worth_time = worth_time;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk o) {\n\t\t\tif(this.worth_time != o.worth_time){\n\t\t\t\treturn this.worth_time - o.worth_time;\n\t\t\t}else{\n\t\t\t\treturn this.time - o.time;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static int Dijkstra(int[][][] free_id, int[][][] cost, final int w, final int h){\n\t\tboolean[][][] visited = new boolean[h][w][h * w];\n\t\t\n\t\tPriorityQueue<Walk> queue = new PriorityQueue<Main.Walk>();\n\t\tqueue.add(new Walk(0, 0, 0, cost[0][0][0]));\n\t\t\n\t\tint min = INF;\n\t\t\n\t\twhile(!queue.isEmpty()){\n\t\t\tWalk walk = queue.poll();\n\t\t\t\n\t\t\tif(walk.time >= h * w){\n\t\t\t\tcontinue;\n\t\t\t}else if(visited[walk.y][walk.x][walk.time]){\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tvisited[walk.y][walk.x][walk.time] = true;\n\t\t\t}\n\t\t\t//System.out.println(walk.x + \" \" + walk.y + \" \" + walk.time + \" \" + walk.worth_time);\n\t\t\t\n\t\t\tif(walk.x == w - 1 && walk.y == h - 1){\n\t\t\t\t//System.out.println(walk.time);\n\t\t\t\tmin = Math.min(min, walk.worth_time);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int cur_y = walk.y;\n\t\t\tfinal int cur_x = walk.x;\n\t\t\tfinal int cur_time  = walk.time;\n\t\t\t\n\t\t\tfor(int dir = 0; dir < DIRS; dir++){\n\t\t\t\tif(free_id[cur_y][cur_x][dir] == 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinal int next_x    = cur_x + move_dir[dir][0];\n\t\t\t\tfinal int next_y    = cur_y + move_dir[dir][1];\n\t\t\t\tfinal int next_time = cur_time + 1;\n\t\t\t\tfinal int failer_time = cur_time + cost[free_id[cur_y][cur_x][dir]][cur_y][cur_x];\n\t\t\t\t\n\t\t\t\tfinal int next_worth_time = Math.max(next_time, Math.max(walk.worth_time, failer_time));\n\t\t\t\t\n\t\t\t\tif(!is_ok(next_x, next_y, w, h)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tqueue.add(new Walk(next_x, next_y, next_time, next_worth_time));\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\treturn min == INF ? -1 : min;\n\t}\n\t\n\tpublic static void BFS(int not, int[][][] free_id, int[][][] cost, final int w, final int h){\n\t\tfor(int y = 0; y < h; y++){\n\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\tcost[not][y][x] = INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tLinkedList<Integer> h_pos = new LinkedList<Integer>();\n\t\tLinkedList<Integer> w_pos = new LinkedList<Integer>();\n\t\tLinkedList<Integer> time  = new LinkedList<Integer>();\n\t\t\n\t\tw_pos.add(w - 1);\n\t\th_pos.add(h - 1);\n\t\ttime.add(0);\n\t\tcost[not][h - 1][w - 1] = 0;\n\t\t\n\t\twhile(!time.isEmpty()){\n\t\t\tfinal int cur_x = w_pos.poll();\n\t\t\tfinal int cur_y = h_pos.poll();\n\t\t\tfinal int cur_time = time.poll();\n\t\t\t\n\t\t\tfor(int dir = 0; dir < DIRS; dir++){\n\t\t\t\tif(not != 0 && free_id[cur_y][cur_x][dir] == not){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(free_id[cur_y][cur_x][dir] == 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinal int next_x    = cur_x + move_dir[dir][0];\n\t\t\t\tfinal int next_y    = cur_y + move_dir[dir][1];\n\t\t\t\tfinal int next_time = cur_time + 1;\n\t\t\t\t\n\t\t\t\tif(!is_ok(next_x, next_y, w, h)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(cost[not][next_y][next_x] != INF){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcost[not][next_y][next_x] = next_time;\n\t\t\t\th_pos.add(next_y);\n\t\t\t\tw_pos.add(next_x);\n\t\t\t\ttime.add(next_time);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int h = sc.nextInt();\n\t\t\tfinal int w = sc.nextInt();\n\t\t\t\n\t\t\tif(h == 0 && w == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][][] can_move = new boolean[h][w][DIRS];\n\t\t\t//1-indexed\n\t\t\tint[][][] free_id = new int[h][w][DIRS];\n\t\t\tint free_count = 1;\n\t\t\t\n\t\t\tfor(int i = 0; i < 2 * h - 1; i++){\n\t\t\t\tfinal int cur_h = i / 2;\n\t\t\t\t//System.out.println(i + \" \" + cur_h);\n\t\t\t\t\n\t\t\t\tif(i % 2 == 0){\n\t\t\t\t\t//w\n\t\t\t\t\tfor(int j = 0; j < w - 1; j++){\n\t\t\t\t\t\tboolean is_free = sc.nextInt() == 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(is_free){\n\t\t\t\t\t\t\tcan_move[cur_h][j    ][RIGHT] = true;\n\t\t\t\t\t\t\tfree_id [cur_h][j    ][RIGHT] = free_count;\n\t\t\t\t\t\t\tcan_move[cur_h][j + 1][LEFT ] = true;\n\t\t\t\t\t\t\tfree_id [cur_h][j + 1][LEFT ] = free_count;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tif(j != 0){\n\t\t\t\t\t\t\t\tcan_move[cur_h][j    ][LEFT ] = true;\n\t\t\t\t\t\t\t\tfree_id [cur_h][j    ][LEFT ] = free_count;\n\t\t\t\t\t\t\t\tcan_move[cur_h][j - 1][RIGHT] = true;\n\t\t\t\t\t\t\t\tfree_id [cur_h][j - 1][RIGHT] = free_count;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfree_count++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t//h\n\t\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\t\tboolean is_free = sc.nextInt() == 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(is_free){\n\t\t\t\t\t\t\tcan_move[cur_h    ][j][DOWN] = true;\n\t\t\t\t\t\t\tfree_id [cur_h    ][j][DOWN] = free_count;\n\t\t\t\t\t\t\tcan_move[cur_h + 1][j][UP] = true;\n\t\t\t\t\t\t\tfree_id [cur_h + 1][j][UP] = free_count;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tif(cur_h != 0){\n\t\t\t\t\t\t\t\tcan_move[cur_h    ][j][UP  ] = true;\n\t\t\t\t\t\t\t\tfree_id [cur_h    ][j][UP  ] = free_count;\n\t\t\t\t\t\t\t\tcan_move[cur_h - 1][j][DOWN] = true;\n\t\t\t\t\t\t\t\tfree_id [cur_h - 1][j][DOWN] = free_count;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfree_count++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][][] cost = new int[free_count][h][w];\n\t\t\tfor(int not = 0; not < free_count; not++){\n\t\t\t\tBFS(not, free_id, cost, w, h);\n\t\t\t\t/*\n\t\t\t\tSystem.out.println(\"not use : \" + not);\n\t\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\t\t\tSystem.out.printf(\"%2d \", cost[not][y][x]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\t//System.out.println(\"-----------------------------------------\");\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tSystem.out.println(Dijkstra(free_id, cost, w, h));\n\t\t\t\n\t\t\tSystem.gc();\n\t\t}\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint w, h;\n\tboolean map[][][];\n\tint dp[][][];\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tif( (h|w) == 0 ) break;\n\t\t\t\n\t\t\tmap = new boolean[h][w][4];\n\t\t\tdp = new int[h][w][4];\n\t\t\tfor(int i=0;i<2*h-1;i++) for(int j=0;j<(i%2==0? w-1:w);j++){\n\t\t\t\tmap[i/2][j][i%2==0? 2:3] = sc.nextInt() == 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=1;i<h;i++) for(int j=0;j<w;j++)\n\t\t\t\tmap[i][j][1] = map[i-1][j][3];\n\t\t\t\n\t\t\tfor(int i=0;i<h;i++) for(int j=1;j<w;j++)\n\t\t\t\tmap[i][j][0] = map[i][j-1][2];\n\t\t\t\n//\t\t\tfor(boolean[][] a: map) debug(a);\n\t\t\t\n\t\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) {\n\t\t\t\tfor(int k=0;k<4;k++) if(map[i][j][k]){\n\t\t\t\t\tmap[i][j][k] = false;\n\t\t\t\t\tdp[i][j][k] = bfs(j, i);\n\t\t\t\t\tmap[i][j][k] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(dijkstra());\n\t\t}\n\t}\n\t\n\tint dijkstra() {\n\t\tint[][] c = new int[h][w];\n\t\tfor(int[] a: c) fill(a, INF);\n\t\tc[h-1][w-1] = 0;\n\t\t\n\t\tPriorityQueue<P> que= new PriorityQueue<P>();\n\t\tque.add(new P(w-1, h-1, 0));\n\t\t\n\t\tfor(;!que.isEmpty();) {\n\t\t\tP now = que.remove();\n//\t\t\tdebug(now.x, now.y, now.c);\n\t\t\tif( (now.x|now.y) == 0 ) return now.c;\n\t\t\tif( now.c != c[now.y][now.x] ) continue;\n\t\t\tfor(int i=0;i<4;i++) if(map[now.y][now.x][i]){\n\t\t\t\tint nx = now.x + dx[i];\n\t\t\t\tint ny = now.y + dy[i];\n\t\t\t\tint nc = now.c + 1;\n\t\t\t\tnc = max(nc, dp[ny][nx][(i+2)%4]);\n//\t\t\t\tdebug(dp[ny][nx][(i+2)%4], c[ny][nx]);\n\t\t\t\tif(c[ny][nx] <= nc ) continue;\n\t\t\t\tc[ny][nx] = nc;\n\t\t\t\tque.add(new P(nx, ny, nc));\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tint dx[] = {-1,0,1,0};\n\tint dy[] = {0,-1,0,1};\n\t\n\tint bfs(int x, int y) {\n\t\tboolean visited[][] = new boolean[h][w];\n\t\tLinkedList<P> que = new LinkedList<P>();\n\t\t\n\t\tque.add(new P(x, y, 0));\n\t\tvisited[y][x] = true;\n\t\t\n\t\tfor(;!que.isEmpty();) {\n\t\t\tP now = que.removeFirst();\n\t\t\tif( now.x == w-1 && now.y == h-1 ) return now.c;\n\t\t\tfor(int i=0;i<4;i++) if(map[now.y][now.x][i] && !visited[now.y+dy[i]][now.x+dx[i]]) {\n\t\t\t\tque.addLast(new P(now.x + dx[i], now.y+dy[i], now.c+1));\n\t\t\t\tvisited[now.y+dy[i]][now.x+dx[i]] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn INF;\n\t}\n\t\n\tclass P implements Comparable<P>{\n\t\tint x, y, c;\n\t\tP(int x, int y, int c) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.c = c;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(P o) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\treturn c-o.c;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint w, h;\n\tboolean[][][] map;\n\tint[][][] dp;\n\tboolean visited[][];\n\tLinkedList<P> que;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tif( (h|w) == 0) break;\n\t\t\tmap = new boolean[h][w][4];\n\t\t\tdp = new int[h][w][4];\n\t\t\tvisited = new boolean[h][w];\n\t\t\tque = new LinkedList<P>();\n\t\t\tfor(int i=0;i<2*h-1;i++) for(int j=0;j<((i%2==0)? w-1:w); j++) {\n\t\t\t\tif(i%2==0) map[i/2][j][2] = map[i/2][j+1][0] = ( sc.nextInt() == 0 )? true: false;\n\t\t\t\telse map[(i-1)/2][j][3] = map[(i-1)/2+1][j][1] = ( sc.nextInt() == 0 )? true: false;\n\t\t\t}\n\t\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) for(int k=0;k<4;k++) {\n\t\t\t\tif( !map[i][j][k] ) continue;\n\t\t\t\tmap[i][j][k] = false;\n\t\t\t\tdp[i][j][k] = bfs(j, i);\n\t\t\t\tmap[i][j][k] = true;\n\t\t\t}\n\t\t\tSystem.out.println(dijkstra());\n\t\t}\n\t}\n\tint[] dx = {-1,0,1,0};\n\tint[] dy = {0,-1,0,1};\n\t\n\tint bfs(int x, int y) {\n\t\tfor(boolean[] a: visited)fill(a, false);\n\t\tque.clear();\n\t\tP now = new P(x, y, 0);\n\t\tque.add(now);\n\t\tfor(;!que.isEmpty();) {\n\t\t\tnow = que.removeFirst();\n\t\t\tif( now.x == w-1 && now.y == h-1) return now.c;\n\t\t\tfor(int i=0;i<4;i++) {\n\t\t\t\tif(!map[now.y][now.x][i]) continue;\n\t\t\t\tint nx = now.x + dx[i];\n\t\t\t\tint ny = now.y + dy[i];\n\t\t\t\tif( !visited[ny][nx]) {\n\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t\tque.addLast(new P(nx, ny, now.c+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INF;\n\t}\n\t\n\tint dijkstra() {\n\t\tPriorityQueue<P> que = new PriorityQueue<P>(1, new MyComp());\n\t\tint[][] c = new int[h][w];\n\t\tfor(int[] a: c) fill(a, INF);\n\t\tP now = new P( w-1, h-1, 0 );\n\t\tc[h-1][w-1] = 0;\n\t\tque.add(now);\n\t\t\n\t\tfor(;!que.isEmpty();) {\n\t\t\tnow = que.remove();\n\t\t\tif(now.x == 0 && now.y == 0) return now.c;\n\t\t\tif(now.c != c[now.y][now.x]) continue;\n\t\t\tfor(int i=0;i<4;i++) {\n\t\t\t\tif( !map[now.y][now.x][i] ) continue;\n\t\t\t\tint nx = now.x + dx[i];\n\t\t\t\tint ny = now.y + dy[i];\n\t\t\t\tint nc = now.c + 1;\n\t\t\t\tnc = max(nc, dp[ny][nx][(i+2)%4]);\n\t\t\t\tif( c[ny][nx] <= nc ) continue;\n\t\t\t\tc[ny][nx] = nc;\n\t\t\t\tque.add(new P(nx, ny, nc));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\t\n\tclass MyComp implements Comparator<P> {\n\n\t\t@Override\n\t\tpublic int compare(P p1, P p2) {\n\t\t\t// TODO ツ篠ゥツ督ョツ青カツ青ャツつウツづェツつスツδソツッツドツ・ツスツタツブ\n\t\t\treturn p1.c-p2.c;\n\t\t}\n\t\t\n\t}\n\t\n\tclass P implements Comparable<P>{\n\t\tint x, y, c;\n\t\tP(int x, int y, int c) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.c = c;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(P p) {\n\t\t\t// TODO ツ篠ゥツ督ョツ青カツ青ャツつウツづェツつスツδソツッツドツ・ツスツタツブ\n\t\t\treturn c - p.c;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int INF = Integer.MAX_VALUE / 2 - 1;\n\t\n\tpublic static final int DIRS  = 4;\n\tpublic static final int UP    = 0;\n\tpublic static final int LEFT  = 1;\n\tpublic static final int DOWN  = 2;\n\tpublic static final int RIGHT = 3;\n\t\n\tpublic static final int[][] move_dir = new int[][]{{0,-1}, {-1, 0}, {0, 1}, {1, 0}};\n\t\n\tpublic static final int MAX_SIZE = 30;\n\tpublic static final int MAX_WALL = 900;\n\t\n\tpublic static boolean is_ok(int x, int y, int w, int h){\n\t\tif(x < 0 || y < 0 || x >= w || y >= h){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static class Walk implements Comparable<Walk>{\n\t\tint x, y;\n\t\tint time;\n\t\tint worth_time;\n\t\t\n\t\tpublic Walk(int x, int y, int time, int worth_time){\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.time = time;\n\t\t\tthis.worth_time = worth_time;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk o) {\n\t\t\tif(this.worth_time != o.worth_time){\n\t\t\t\treturn this.worth_time - o.worth_time;\n\t\t\t}else{\n\t\t\t\treturn this.time - o.time;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static int Dijkstra(int[][][] free_id, int[][][] cost, final int w, final int h){\n\t\tboolean[][] visited = new boolean[h][w];\n\t\t\n\t\tPriorityQueue<Walk> queue = new PriorityQueue<Main.Walk>();\n\t\tqueue.add(new Walk(0, 0, 0, cost[0][0][0]));\n\t\t\n\t\tint min = INF;\n\t\t\n\t\twhile(!queue.isEmpty()){\n\t\t\tWalk walk = queue.poll();\n\t\t\t\n\t\t\tif(visited[walk.y][walk.x]){\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tvisited[walk.y][walk.x] = true;\n\t\t\t}\n\t\t\t//System.out.println(walk.x + \" \" + walk.y + \" \" + walk.time + \" \" + walk.worth_time);\n\t\t\t\n\t\t\tif(walk.x == w - 1 && walk.y == h - 1){\n\t\t\t\t//System.out.println(walk.time);\n\t\t\t\tmin = Math.min(min, walk.worth_time);\n\t\t\t}\n\t\t\t\n\t\t\tfinal int cur_y = walk.y;\n\t\t\tfinal int cur_x = walk.x;\n\t\t\tfinal int cur_time  = walk.time;\n\t\t\t\n\t\t\tfor(int dir = 0; dir < DIRS; dir++){\n\t\t\t\tif(free_id[cur_y][cur_x][dir] == 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinal int next_x    = cur_x + move_dir[dir][0];\n\t\t\t\tfinal int next_y    = cur_y + move_dir[dir][1];\n\t\t\t\tfinal int next_time = cur_time + 1;\n\t\t\t\tfinal int failer_time = cur_time + cost[free_id[cur_y][cur_x][dir]][cur_y][cur_x];\n\t\t\t\t\n\t\t\t\tfinal int next_worth_time = Math.max(next_time, Math.max(walk.worth_time, failer_time));\n\t\t\t\t\n\t\t\t\tif(!is_ok(next_x, next_y, w, h)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tqueue.add(new Walk(next_x, next_y, next_time, next_worth_time));\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\treturn min == INF ? -1 : min;\n\t}\n\t\n\tpublic static void BFS(int not, int[][][] free_id, int[][][] cost, final int w, final int h){\n\t\tfor(int y = 0; y < h; y++){\n\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\tcost[not][y][x] = INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tLinkedList<Integer> h_pos = new LinkedList<Integer>();\n\t\tLinkedList<Integer> w_pos = new LinkedList<Integer>();\n\t\tLinkedList<Integer> time  = new LinkedList<Integer>();\n\t\t\n\t\tw_pos.add(w - 1);\n\t\th_pos.add(h - 1);\n\t\ttime.add(0);\n\t\tcost[not][h - 1][w - 1] = 0;\n\t\t\n\t\twhile(!time.isEmpty()){\n\t\t\tfinal int cur_x = w_pos.poll();\n\t\t\tfinal int cur_y = h_pos.poll();\n\t\t\tfinal int cur_time = time.poll();\n\t\t\t\n\t\t\tfor(int dir = 0; dir < DIRS; dir++){\n\t\t\t\tif(not != 0 && free_id[cur_y][cur_x][dir] == not){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(free_id[cur_y][cur_x][dir] == 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinal int next_x    = cur_x + move_dir[dir][0];\n\t\t\t\tfinal int next_y    = cur_y + move_dir[dir][1];\n\t\t\t\tfinal int next_time = cur_time + 1;\n\t\t\t\t\n\t\t\t\tif(!is_ok(next_x, next_y, w, h)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(cost[not][next_y][next_x] != INF){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcost[not][next_y][next_x] = next_time;\n\t\t\t\th_pos.add(next_y);\n\t\t\t\tw_pos.add(next_x);\n\t\t\t\ttime.add(next_time);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int h = sc.nextInt();\n\t\t\tfinal int w = sc.nextInt();\n\t\t\t\n\t\t\tif(h == 0 && w == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][][] can_move = new boolean[h][w][DIRS];\n\t\t\t//1-indexed\n\t\t\tint[][][] free_id = new int[h][w][DIRS];\n\t\t\tint free_count = 1;\n\t\t\t\n\t\t\tfor(int i = 0; i < 2 * h - 1; i++){\n\t\t\t\tfinal int cur_h = i / 2;\n\t\t\t\t//System.out.println(i + \" \" + cur_h);\n\t\t\t\t\n\t\t\t\tif(i % 2 == 0){\n\t\t\t\t\t//w\n\t\t\t\t\tfor(int j = 0; j < w - 1; j++){\n\t\t\t\t\t\tboolean is_free = sc.nextInt() == 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(is_free){\n\t\t\t\t\t\t\tcan_move[cur_h][j    ][RIGHT] = true;\n\t\t\t\t\t\t\tfree_id [cur_h][j    ][RIGHT] = free_count;\n\t\t\t\t\t\t\tcan_move[cur_h][j + 1][LEFT ] = true;\n\t\t\t\t\t\t\tfree_id [cur_h][j + 1][LEFT ] = free_count;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tif(j != 0){\n\t\t\t\t\t\t\t\tcan_move[cur_h][j    ][LEFT ] = true;\n\t\t\t\t\t\t\t\tfree_id [cur_h][j    ][LEFT ] = free_count;\n\t\t\t\t\t\t\t\tcan_move[cur_h][j - 1][RIGHT] = true;\n\t\t\t\t\t\t\t\tfree_id [cur_h][j - 1][RIGHT] = free_count;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfree_count++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t//h\n\t\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\t\tboolean is_free = sc.nextInt() == 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(is_free){\n\t\t\t\t\t\t\tcan_move[cur_h    ][j][DOWN] = true;\n\t\t\t\t\t\t\tfree_id [cur_h    ][j][DOWN] = free_count;\n\t\t\t\t\t\t\tcan_move[cur_h + 1][j][UP] = true;\n\t\t\t\t\t\t\tfree_id [cur_h + 1][j][UP] = free_count;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tif(cur_h != 0){\n\t\t\t\t\t\t\t\tcan_move[cur_h    ][j][UP  ] = true;\n\t\t\t\t\t\t\t\tfree_id [cur_h    ][j][UP  ] = free_count;\n\t\t\t\t\t\t\t\tcan_move[cur_h - 1][j][DOWN] = true;\n\t\t\t\t\t\t\t\tfree_id [cur_h - 1][j][DOWN] = free_count;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfree_count++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][][] cost = new int[free_count][h][w];\n\t\t\tfor(int not = 0; not < free_count; not++){\n\t\t\t\tBFS(not, free_id, cost, w, h);\n\t\t\t\t/*\n\t\t\t\tSystem.out.println(\"not use : \" + not);\n\t\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\t\t\tSystem.out.printf(\"%2d \", cost[not][y][x]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\t//System.out.println(\"-----------------------------------------\");\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tSystem.out.println(Dijkstra(free_id, cost, w, h));\n\t\t\t\n\t\t\tSystem.gc();\n\t\t}\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\nusing Number = System.Int64;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n            for (;;)\n            {\n                var n = sc.Integer();\n                var m = sc.Integer();\n                if (n == 0) return;\n                var G = Enumerate(n * m, x => new List<int>());\n                for (int i = 0; i < n; i++)\n                {\n                    for (int j = 0; j < m - 1; j++)\n                        if (sc.Integer() == 0)\n                        {\n                            G[i * m + j].Add(i * m + j + 1);\n                            G[i * m + j + 1].Add(i * m + j);\n                        }\n                    for (int j = 0; i != n - 1 && j < m; j++)\n                        if (sc.Integer() == 0)\n                        {\n                            G[i * m + j].Add((i + 1) * m + j);\n                            G[(i + 1) * m + j].Add(i * m + j);\n                        }\n                }\n                Func<int, int, int> f = (pos, not) =>\n                {\n                    var dist = Enumerate(n * m, z => 1 << 20);\n                    dist[pos] = 0;\n                    var q = new Queue<int>(); q.Enqueue(pos);\n                    while (q.Count > 0)\n                    {\n                        var p = q.Dequeue();\n                        for (int j = 0; j < G[p].Count; j++)\n                        {\n                            var to = G[p][j];\n                            if (p == pos && to == not) continue;\n                            if (dist[to] > dist[p] + 1) { dist[to] = dist[p] + 1; q.Enqueue(to); }\n                        }\n                    }\n                    return dist[n * m - 1];\n                };\n                var dp = Enumerate(n * m, y => 1 << 20);\n                dp[n * m - 1] = 0;\n                var pq = new PriorityQueue<KeyValuePair<int, int>>((l, r) => l.Value.CompareTo(r.Value));\n                pq.Enqueue(new KeyValuePair<int, int>(n * m - 1, 0));\n                while (pq.Count > 0)\n                {\n                    var p = pq.Dequeue();\n                    //Debug.WriteLine(\"{0} {1} {2}\", p.Key / m, p.Key % m, p.Value);\n                    if (dp[p.Key] < p.Value) continue;\n                    foreach (var to in G[p.Key])\n                    {\n                        var cost = p.Value + 1;\n                        var dost = f(to, p.Key);\n                        cost = Math.Max(cost, dost);\n                        if (dp[to] > cost)\n                        {\n                            dp[to] = cost;\n                            pq.Enqueue(new KeyValuePair<int, int>(to, cost));\n                        }\n                    }\n\n                }\n                if (dp[0] >= 1 << 20) dp[0] = -1;\n                IO.Printer.Out.WriteLine(dp[0]);\n            }\n        }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    //static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n\n#region BinaryHeap\npublic class PriorityQueue<T>\n{\n    readonly List<T> heap = new List<T>();\n    readonly Comparison<T> cmp;\n    public PriorityQueue() : this(Comparer<T>.Default) { }\n    public PriorityQueue(IComparer<T> comparer) : this(comparer.Compare) { }\n    public PriorityQueue(Comparison<T> comparison) { cmp = comparison; }\n    public void Enqueue(T item)\n    {\n\n        var i = heap.Count;\n        heap.Add(item);\n        while (i > 0)\n        {\n            var p = (i - 1) / 2;\n            if (cmp(heap[p], item) <= 0)\n                break;\n            heap[i] = heap[p];\n            i = p;\n        }\n        heap[i] = item;\n\n    }\n    public T Dequeue()\n    {\n        var ret = heap[0];\n        var i = 0;\n        var x = heap[heap.Count - 1];\n\n        while ((i * 2) + 1 < heap.Count - 1)\n        {\n            var a = i * 2 + 1;\n            var b = i * 2 + 2;\n            if (b < heap.Count - 1 && cmp(heap[b], heap[a]) < 0) a = b;\n            if (cmp(heap[a], x) >= 0)\n                break;\n            heap[i] = heap[a];\n            i = a;\n        }\n        heap[i] = x;\n        heap.RemoveAt(heap.Count - 1);\n        return ret;\n\n    }\n    public T Peek() { return heap[0]; }\n    public int Count { get { return heap.Count; } }\n    public bool Any() { return heap.Count > 0; }\n    public T[] Items\n    {\n        get\n        {\n            var ret = heap.ToArray();\n            Array.Sort(ret, cmp);\n            return ret;\n        }\n    }\n}\n#endregion\n"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif (@array[i][1] <=> @array[j][1]) < 0\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if (new_key <=> @array[i][1]) >= 0\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif (@array[i][1] <=> @array[j][1]) > 0\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = ((@array[j][1] <=> @array[k][1]) < 0 ? j : k)\n\t\t\tif (@array[i][1] <=> @array[l][1]) > 0\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\ndef c(i, j)\n\ti * 32 + j\nend\n\ndef dijkstra\n\th = Heap.new\n\ts = c($h-1, $w-1)\n\treached = Set[s]\n\th.add(s, 0)\n\n\tdist = {}\n\tuntil h.empty?\n\t\tu, key = h.del_min\n\t\treturn key if u == 0\n\t\tdist[u] = key\n\t\t$g[u].each do |v|\n\t\t\te = (u < v ? [u, v] : [v, u])\n\t\t\td = [$retry_dist[e][v] || -Float::INFINITY, dist[u] + 1].max\n\t\t\tif reached.include?(v)\n\t\t\t\th.update_key(v, d)\n\t\t\telse\n\t\t\t\th.add(v, d)\n\t\t\t\treached << v\n\t\t\tend\n\t\tend\n\tend\nend\n\nloop do\n\th, w = gets.split.map(&:to_i)\n\tbreak if h == 0\n\tg = {}\n\t(0..h-1).to_a.product((0..w-1).to_a).each do |i, j|\n\t\tg[c(i, j)] = Set.new\n\tend\n\tedges = Set.new\n\th.times do |i|\n\t\tgets.split.map(&:to_i).each_with_index do |x, j|\n\t\t\tif x == 0\n\t\t\t\tu = c(i, j)\n\t\t\t\tv = c(i, j+1)\n\t\t\t\tedges << [u, v]\n\t\t\t\traise if ! [1, 32].include? (u-v).abs\n\t\t\t\tg[u] << v\n\t\t\t\tg[v] << u\n\t\t\tend\n\t\tend\n\n\t\tbreak if i == h-1\n\t\tgets.split.map(&:to_i).each_with_index do |x, j|\n\t\t\tif x == 0\n\t\t\t\tu = c(i, j)\n\t\t\t\tv = c(i+1, j)\n\t\t\t\traise if ! [1, 32].include? (u-v).abs\n\t\t\t\tedges << [u, v]\n\t\t\t\tg[u] << v\n\t\t\t\tg[v] << u\n\t\t\tend\n\t\tend\n\tend\n\n\tdist = {}\n\tedges.each do |e|\n\t\tu0, v0 = e\n\t\tg[u0].delete v0\n\t\tg[v0].delete u0\n\t\ts = c(h-1, w-1)\n\t\td = {s => 0}\n\t\tqueue = [s]\n\t\tuntil queue.empty?\n\t\t\tu = queue.shift\n\t\t\tg[u].each do |v|\n\t\t\t\tnext if d[v]\n\t\t\t\td[v] = d[u] + 1\n\t\t\t\tqueue << v\n\t\t\tend\n\t\tend\n\t\tif !d[0]\n\t\t\tdist = nil\n\t\t\tbreak\n\t\tend\n\t\tdist[e] = d\n\t\tg[u0] << v0\n\t\tg[v0] << u0\n\tend\n\t\n\tif ! dist\n\t\tputs -1\n\t\tnext\n\tend\n\n\t$g = g\n\t$retry_dist = dist\n\t$h = h\n\t$w = w\n\n\tp dijkstra\nend"
  },
  {
    "language": "D",
    "code": "import core.stdc.stdio;\nimport std.traits;\nimport std.algorithm;\nimport std.typecons;\nimport std.stdio;\n\nint[][] wall;\nbool[][][] pass;\nint[][][][] dist;\nint[][][] buf;\n\nint[] dx=[0,-1,0,1];\nint[] dy=[-1,0,1,0];\n\nstatic immutable int inf=114514;\nint w,h;\n\nvoid Clear(T,U)(ref T t,U u){\n\tstatic if(isArray!T)\n\t\tforeach(ref d;t)\n\t\t\td.Clear(u);\n\telse\n\t\tt=u;\n}\n\nvoid SetPass(){\n\tpass.Clear(false);\n\tforeach(i;0..h)\n\t\tforeach(j;0..w){\n\t\t\tif(i>0)\n\t\t\t\tpass[i][j][0]=wall[i*2-1][j]==0;\n\t\t\tif(j>0)\n\t\t\t\tpass[i][j][1]=wall[i*2][j-1]==0;\n\t\t\tif(i<h-1)\n\t\t\t\tpass[i][j][2]=wall[i*2+1][j]==0;\n\t\t\tif(j<w-1)\n\t\t\t\tpass[i][j][3]=wall[i*2][j]==0;\n\t\t}\n}\n\nbool inside(int x,int y){\n\treturn 0<=x&&x<w&&0<=y&&y<h;\n}\n\nint[] qx,qy,qd;\nvoid BFS(int[][] dst){\n\tSetPass;\n\tdst.Clear(inf);\n\tqx[0]=w-1;\n\tqy[0]=h-1;\n\tqd[0]=0;\n\tdst[h-1][w-1]=0;\n\tint q=1;\n\tint i=0;\n\twhile(i<q){\n\t\tint x=qx[i],y=qy[i],d=qd[i];\n\t\ti++;\n\t\tforeach(k;0..4){\n\t\t\tint nx=x+dx[k],ny=y+dy[k];\n\t\t\tif(pass[y][x][k]&&inside(nx,ny)&&dst[ny][nx]==inf){\n\t\t\t\tqx[q]=nx;\n\t\t\t\tqy[q]=ny;\n\t\t\t\tqd[q++]=d+1;\n\t\t\t\tdst[ny][nx]=d+1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool Solve(){\n\tscanf(\"%d%d\",&h,&w);\n\tif(w==0&&h==0)\n\t\treturn false;\n\tforeach(i;0..2*h-1)\n\t\tforeach(j;0..w-1+(i&1))\n\t\t\tscanf(\"%d\",&wall[i][j]);\n\tBFS(dist[0][0]);\n\tif(dist[0][0][0][0]==inf){\n\t\tprintf(\"-1\\n\");\n\t\treturn true;\n\t}\n\tforeach(i;0..2*h-1)\n\t\tforeach(j;0..w-1+(i&1))\n\t\t\tif(wall[i][j]==0){\n\t\t\t\twall[i][j]=1;\n\t\t\t\tBFS(dist[i][j]);\n\t\t\t\twall[i][j]=0;\n\t\t\t\tif(dist[i][j][0][0]==inf){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\tint[][] now=buf[0];\n\tnow.Clear(inf);\n\tint[][] next=buf[1];\n\tint ans=inf;\n\tnow[0][0]=0;\n\tforeach(k;0..h*w){\n\t\tnext.Clear(inf);\n\t\tforeach(i;0..h)\n\t\t\tforeach(j;0..w){\n\t\t\t\tif(pass[i][j][0])\n\t\t\t\t\tnext[i][j]=min(next[i][j],max(now[i-1][j],dist[i*2-1][j][i-1][j]+k));\n\t\t\t\tif(pass[i][j][1])\n\t\t\t\t\tnext[i][j]=min(next[i][j],max(now[i][j-1],dist[i*2][j-1][i][j-1]+k));\n\t\t\t\tif(pass[i][j][2])\n\t\t\t\t\tnext[i][j]=min(next[i][j],max(now[i+1][j],dist[i*2+1][j][i+1][j]+k));\n\t\t\t\tif(pass[i][j][3])\n\t\t\t\t\tnext[i][j]=min(next[i][j],max(now[i][j+1],dist[i*2][j][i][j+1]+k));\n\t\t\t}\n\t\tswap(now,next);\n\t\tans=min(ans,max(k+1,now[h-1][w-1]));\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn true;\n}\n\nvoid main(){\n\twall=new int[][](60,30);\n\tpass=new bool[][][](30,30,4);\n\tdist=new int[][][][](60,30,30,30);\n\tbuf=new int[][][](2,30,30);\n\tqx=new int[1000];\n\tqy=new int[1000];\n\tqd=new int[1000];\n\twhile(Solve){}\n}"
  },
  {
    "language": "D",
    "code": "import core.stdc.stdio;\nimport std.traits;\nimport std.algorithm;\nimport std.typecons;\nimport std.stdio;\n\nint[][] wall;\nbool[][][] pass;\nint[][][][] dist;\nint[][][] buf;\n\nint[] dx=[0,-1,0,1];\nint[] dy=[-1,0,1,0];\n\nstatic immutable int inf=114514;\nint w,h;\n\nvoid Clear(T,U)(ref T t,U u){\n\tstatic if(isArray!T)\n\t\tforeach(ref d;t)\n\t\t\td.Clear(u);\n\telse\n\t\tt=u;\n}\n\nvoid SetPass(){\n\tpass.Clear(false);\n\tforeach(i;0..h)\n\t\tforeach(j;0..w){\n\t\t\tif(i>0)\n\t\t\t\tpass[i][j][0]=wall[i*2-1][j]==0;\n\t\t\tif(j>0)\n\t\t\t\tpass[i][j][1]=wall[i*2][j-1]==0;\n\t\t\tif(i<h-1)\n\t\t\t\tpass[i][j][2]=wall[i*2+1][j]==0;\n\t\t\tif(j<w-1)\n\t\t\t\tpass[i][j][3]=wall[i*2][j]==0;\n\t\t}\n}\n\nbool inside(int x,int y){\n\treturn 0<=x&&x<w&&0<=y&&y<h;\n}\n\nint[] qx,qy,qd;\nvoid BFS(int[][] dst){\n\tSetPass;\n\tdst.Clear(inf);\n\tqx[0]=w-1;\n\tqy[0]=h-1;\n\tqd[0]=0;\n\tdst[h-1][w-1]=0;\n\tint q=1;\n\tint i=0;\n\twhile(i<q){\n\t\tint x=qx[i],y=qy[i],d=qd[i];\n\t\ti++;\n\t\tforeach(k;0..4){\n\t\t\tint nx=x+dx[k],ny=y+dy[k];\n\t\t\tif(pass[y][x][k]&&inside(nx,ny)&&dst[ny][nx]==inf){\n\t\t\t\tqx[q]=nx;\n\t\t\t\tqy[q]=ny;\n\t\t\t\tqd[q++]=d+1;\n\t\t\t\tdst[ny][nx]=d+1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool Solve(){\n\tscanf(\"%d%d\",&h,&w);\n\tif(w==0&&h==0)\n\t\treturn false;\n\tforeach(i;0..2*h-1)\n\t\tforeach(j;0..w-1+(i&1))\n\t\t\tscanf(\"%d\",&wall[i][j]);\n\tBFS(dist[0][0]);\n\tif(dist[0][0][0][0]==inf){\n\t\tprintf(\"-1\\n\");\n\t\treturn true;\n\t}\n\tforeach(i;0..2*h-1)\n\t\tforeach(j;0..w-1+(i&1))\n\t\t\tif(wall[i][j]==0){\n\t\t\t\twall[i][j]=1;\n\t\t\t\tBFS(dist[i][j]);\n\t\t\t\twall[i][j]=0;\n\t\t\t\tif(dist[i][j][0][0]==inf){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\tSetPass;\n\tint[][] now=buf[0];\n\tnow.Clear(inf);\n\tint[][] next=buf[1];\n\tint ans=inf;\n\tnow[0][0]=0;\n\tforeach(k;0..h*w){\n\t\tnext.Clear(inf);\n\t\tforeach(i;0..h)\n\t\t\tforeach(j;0..w){\n\t\t\t\tif(pass[i][j][0])\n\t\t\t\t\tnext[i][j]=min(next[i][j],max(now[i-1][j],dist[i*2-1][j][i-1][j]+k));\n\t\t\t\tif(pass[i][j][1])\n\t\t\t\t\tnext[i][j]=min(next[i][j],max(now[i][j-1],dist[i*2][j-1][i][j-1]+k));\n\t\t\t\tif(pass[i][j][2])\n\t\t\t\t\tnext[i][j]=min(next[i][j],max(now[i+1][j],dist[i*2+1][j][i+1][j]+k));\n\t\t\t\tif(pass[i][j][3])\n\t\t\t\t\tnext[i][j]=min(next[i][j],max(now[i][j+1],dist[i*2][j][i][j+1]+k));\n\t\t\t}\n\t\tswap(now,next);\n\t\tans=min(ans,max(k+1,now[h-1][w-1]));\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn true;\n}\n\nvoid main(){\n\twall=new int[][](60,30);\n\tpass=new bool[][][](30,30,4);\n\tdist=new int[][][][](60,30,30,30);\n\tbuf=new int[][][](2,30,30);\n\tqx=new int[1000];\n\tqy=new int[1000];\n\tqd=new int[1000];\n\twhile(Solve){}\n}"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef bs(f, mi, ma):\n    mm = -1\n    while ma > mi:\n        mm = (ma+mi) // 2\n        if f(mm):\n            mi = mm + 1\n        else:\n            ma = mm\n    if f(mm):\n        return mm + 1\n    return mm\n\ndef main():\n    rr = []\n\n    def f(n,m):\n        a = [LI() for _ in range(n*2-1)]\n        e = collections.defaultdict(set)\n        ds = []\n        for i in range(n):\n            for j in range(m):\n                if i < n - 1 and a[i*2+1][j] == 0:\n                    e[(i,j)].add((i+1,j))\n                    e[(i+1,j)].add((i,j))\n                    ds.append(set([(i,j),(i+1,j)]))\n                if j < m - 1 and a[i*2][j] == 0:\n                    e[(i,j)].add((i,j+1))\n                    e[(i,j+1)].add((i,j))\n                    ds.append(set([(i,j),(i,j+1)]))\n\n        def search(s, ns):\n            d = collections.defaultdict(lambda: inf)\n            d[s] = 0\n            q = []\n            heapq.heappush(q, (0, s))\n            v = collections.defaultdict(bool)\n            while len(q):\n                k, u = heapq.heappop(q)\n                if v[u]:\n                    continue\n                v[u] = True\n\n                for uv in e[u]:\n                    if v[uv]:\n                        continue\n                    if uv in ns and u in ns:\n                        continue\n                    vd = k + 1\n                    if d[uv] > vd:\n                        d[uv] = vd\n                        heapq.heappush(q, (vd, uv))\n\n            return d\n\n        nd = collections.defaultdict(lambda: -1)\n        for ns in ds:\n            td = search((n-1,m-1), ns)\n            for k in ns:\n                if nd[k] < td[k]:\n                    nd[k] = td[k]\n\n        def ff(mx):\n            def search2(s):\n                d = collections.defaultdict(lambda: inf)\n                d[s] = 0\n                q = []\n                heapq.heappush(q, (0, s))\n                v = collections.defaultdict(bool)\n                while len(q):\n                    k, u = heapq.heappop(q)\n                    if v[u]:\n                        continue\n                    v[u] = True\n\n                    for uv in e[u]:\n                        if v[uv]:\n                            continue\n                        vd = k + 1\n                        if vd + nd[uv] >= mx:\n                            continue\n                        if d[uv] > vd:\n                            d[uv] = vd\n                            heapq.heappush(q, (vd, uv))\n\n                return d\n\n            fd = search2((0,0))\n            return fd[(n-1,m-1)] >= mx\n\n        mm = n*m*3\n        r = bs(ff,0,mm)\n\n        if r >= mm:\n            return -1\n\n        return r - 1\n\n    while True:\n        n,m = LI()\n        if n == 0:\n            break\n        rr.append(f(n,m))\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f(n,m):\n        a = [LI() for _ in range(n*2-1)]\n        e = collections.defaultdict(set)\n        ds = []\n        for i in range(n):\n            for j in range(m):\n                if i < n - 1 and a[i*2+1][j] == 0:\n                    e[(i,j)].add((i+1,j))\n                    e[(i+1,j)].add((i,j))\n                    ds.append(set([(i,j),(i+1,j)]))\n                if j < m - 1 and a[i*2][j] == 0:\n                    e[(i,j)].add((i,j+1))\n                    e[(i,j+1)].add((i,j))\n                    ds.append(set([(i,j),(i,j+1)]))\n\n        def search(s, ns):\n            d = collections.defaultdict(lambda: inf)\n            d[s] = 0\n            q = []\n            heapq.heappush(q, (0, s))\n            v = collections.defaultdict(bool)\n            while len(q):\n                k, u = heapq.heappop(q)\n                if v[u]:\n                    continue\n                v[u] = True\n\n                for uv in e[u]:\n                    if v[uv]:\n                        continue\n                    if uv in ns and u in ns:\n                        continue\n                    vd = k + 1\n                    if d[uv] > vd:\n                        d[uv] = vd\n                        heapq.heappush(q, (vd, uv))\n\n            return d\n\n        sd = search((0,0), set())\n\n        nd = collections.defaultdict(lambda: -1)\n        for ns in ds:\n            td = search((n-1,m-1), ns)\n            for k in ns:\n                if nd[k] < td[k]:\n                    nd[k] = td[k]\n\n        # for i in range(n):\n        #     t = []\n        #     u = []\n        #     for j in range(m):\n        #         tr = sd[(i,j)]\n        #         if tr >= inf:\n        #             tr = -1\n        #         t.append(\"{:02d}\".format(tr))\n        #         if (i+1,j) in e[(i,j)]:\n        #             u.append(\" |  \")\n        #         else:\n        #             u.append(\" x  \")\n        #         if (i,j+1) in e[(i,j)]:\n        #             t.append('-')\n        #         else:\n        #             t.append('x')\n        #     print(' '.join(t))\n        #     print(' '.join(u))\n\n        # print(\"\")\n\n        # for i in range(n):\n        #     t = []\n        #     for j in range(m):\n        #         tr = nd[(i,j)]\n        #         if tr >= inf:\n        #             tr = -1\n        #         t.append(tr)\n        #     print(' '.join(map(lambda x: \"{:02d}\".format(x), t)))\n\n        def search2(s):\n            d = collections.defaultdict(lambda: (inf, inf))\n            d[s] = (nd[s], 0)\n            q = []\n            heapq.heappush(q, ((nd[s],0), s))\n            v = collections.defaultdict(bool)\n            while len(q):\n                k, u = heapq.heappop(q)\n                if v[u]:\n                    continue\n                v[u] = True\n\n                for uv in e[u]:\n                    if v[uv]:\n                        continue\n                    if uv in ns and u in ns:\n                        continue\n                    vd = (k[0],k[1]+1)\n                    if k[0] < nd[uv] + vd[1]:\n                        vd = (nd[uv]+vd[1], vd[1])\n                    if d[uv] > vd:\n                        d[uv] = vd\n                        heapq.heappush(q, (vd, uv))\n\n            return d\n\n        rd = search2((0,0))\n\n        r = rd[(n-1,m-1)][0]\n        if r == inf:\n            return -1\n\n        return r\n\n    while True:\n        n,m = LI()\n        if n == 0:\n            break\n        rr.append(f(n,m))\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n"
  }
]