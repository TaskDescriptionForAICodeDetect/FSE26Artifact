[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int x, y;\n    int cards;\n} Node;\n\nint rows, cols;\nint grid[MAX_SIZE][MAX_SIZE][4]; // 0: up, 1: right, 2: down, 3: left\nint dist[MAX_SIZE][MAX_SIZE][2]; // 0: no broken door, 1: one broken door\n\nint minCards(int startX, int startY, int endX, int endY) {\n    Node queue[MAX_SIZE * MAX_SIZE * 2];\n    int front = 0, rear = 0;\n    \n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            dist[i][j][0] = INT_MAX;\n            dist[i][j][1] = INT_MAX;\n        }\n    }\n    \n    dist[startX][startY][0] = 0;\n    queue[rear++] = (Node){startX, startY, 0};\n    \n    int dx[] = {-1, 0, 1, 0};\n    int dy[] = {0, 1, 0, -1};\n    \n    while (front < rear) {\n        Node current = queue[front++];\n        int x = current.x;\n        int y = current.y;\n        int cards = current.cards;\n        \n        for (int dir = 0; dir < 4; dir++) {\n            int nx = x + dx[dir];\n            int ny = y + dy[dir];\n            \n            if (nx < 0 || nx >= rows || ny < 0 || ny >= cols) continue;\n            \n            int door = grid[x][y][dir];\n            if (door == -1) continue; // wall\n            \n            int new_cards = cards + door;\n            int new_broken = (door == 1) ? 1 : 0;\n            \n            if (new_cards < dist[nx][ny][new_broken]) {\n                dist[nx][ny][new_broken] = new_cards;\n                queue[rear++] = (Node){nx, ny, new_cards};\n            }\n        }\n    }\n    \n    int min_dist = dist[endX][endY][1];\n    if (min_dist == INT_MAX) return -1;\n    return min_dist;\n}\n\nint main() {\n    scanf(\"%d %d\", &rows, &cols);\n    \n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            for (int k = 0; k < 4; k++) {\n                scanf(\"%d\", &grid[i][j][k]);\n            }\n        }\n    }\n    \n    int startX, startY, endX, endY;\n    scanf(\"%d %d %d %d\", &startX, &startY, &endX, &endY);\n    \n    int result = minCards(startX, startY, endX, endY);\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:10:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MazeSolver {\n    static int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n    \n    public static int minimumCards(char[][] maze) {\n        int rows = maze.length;\n        int cols = maze[0].length;\n        \n        int startX = -1, startY = -1, endX = -1, endY = -1;\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (maze[i][j] == 'S') {\n                    startX = i;\n                    startY = j;\n                }\n                if (maze[i][j] == 'E') {\n                    endX = i;\n                    endY = j;\n                }\n            }\n        }\n        \n        int minCards = Integer.MAX_VALUE;\n        \n        for (int breakX = 0; breakX < rows; breakX++) {\n            for (int breakY = 0; breakY < cols; breakY++) {\n                if (maze[breakX][breakY] == '1') {\n                    int result = bfs(maze, startX, startY, endX, endY, breakX, breakY);\n                    if (result != -1) {\n                        minCards = Math.min(minCards, result);\n                    }\n                }\n            }\n        }\n        \n        return minCards == Integer.MAX_VALUE ? -1 : minCards;\n    }\n    \n    static int bfs(char[][] maze, int startX, int startY, int endX, int endY, int breakX, int breakY) {\n        int rows = maze.length;\n        int cols = maze[0].length;\n        \n        boolean[][][] visited = new boolean[rows][cols][2];\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{startX, startY, 0, 0});\n        visited[startX][startY][0] = true;\n        \n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0], y = current[1], cards = current[2], broken = current[3];\n            \n            if (x == endX && y == endY) {\n                return cards;\n            }\n            \n            for (int[] dir : directions) {\n                int nx = x + dir[0];\n                int ny = y + dir[1];\n                \n                if (nx < 0 || nx >= rows || ny < 0 || ny >= cols || maze[nx][ny] == '#') {\n                    continue;\n                }\n                \n                if (maze[nx][ny] == '1') {\n                    if (broken == 0 && nx == breakX && ny == breakY) {\n                        if (!visited[nx][ny][1]) {\n                            queue.offer(new int[]{nx, ny, cards + 1, 1});\n                            visited[nx][ny][1] = true;\n                        }\n                    } else if (broken == 0) {\n                        if (!visited[nx][ny][0]) {\n                            queue.offer(new int[]{nx, ny, cards + 1, 0});\n                            visited[nx][ny][0] = true;\n                        }\n                    }\n                } else {\n                    if (!visited[nx][ny][broken]) {\n                        queue.offer(new int[]{nx, ny, cards, broken});\n                        visited[nx][ny][broken] = true;\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    public static void main(String[] args) {\n        char[][] maze = {\n            {'S', '1', '1', '1'},\n            {'0', '0', '0', '1'},\n            {'1', '1', '1', '1'},\n            {'E', '0', '0', '0'}\n        };\n        \n        System.out.println(minimumCards(maze));\n    }\n}",
    "timestamp": "2025-08-05 19:11:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <tuple>\n\nusing namespace std;\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> grid(H);\n    for (int i = 0; i < H; ++i) {\n        cin >> grid[i];\n    }\n\n    int start_x = -1, start_y = -1, end_x = -1, end_y = -1;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (grid[i][j] == 'S') {\n                start_x = i;\n                start_y = j;\n            } else if (grid[i][j] == 'G') {\n                end_x = i;\n                end_y = j;\n            }\n        }\n    }\n\n    vector<vector<int>> dist(H, vector<int>(W, INT_MAX));\n    priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;\n    dist[start_x][start_y] = 0;\n    pq.push({0, start_x, start_y});\n\n    while (!pq.empty()) {\n        auto [d, x, y] = pq.top();\n        pq.pop();\n        if (x == end_x && y == end_y) {\n            cout << d << endl;\n            return 0;\n        }\n        if (d > dist[x][y]) continue;\n        for (int k = 0; k < 4; ++k) {\n            int nx = x + dx[k];\n            int ny = y + dy[k];\n            if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n            if (grid[nx][ny] == '#') continue;\n            int nd = d;\n            if (grid[nx][ny] == 'D') {\n                nd += 1;\n            }\n            if (nd < dist[nx][ny]) {\n                dist[nx][ny] = nd;\n                pq.push({nd, nx, ny});\n            }\n        }\n    }\n\n    vector<vector<int>> dist_broken(H, vector<int>(W, INT_MAX));\n    dist_broken[start_x][start_y] = 0;\n    pq.push({0, start_x, start_y});\n\n    while (!pq.empty()) {\n        auto [d, x, y] = pq.top();\n        pq.pop();\n        if (x == end_x && y == end_y) {\n            cout << -1 << endl;\n            return 0;\n        }\n        if (d > dist_broken[x][y]) continue;\n        for (int k = 0; k < 4; ++k) {\n            int nx = x + dx[k];\n            int ny = y + dy[k];\n            if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n            if (grid[nx][ny] == '#') continue;\n            int nd = d;\n            if (grid[nx][ny] == 'D') {\n                nd = d + 1;\n                if (nd >= dist[nx][ny]) continue;\n            }\n            if (nd < dist_broken[nx][ny]) {\n                dist_broken[nx][ny] = nd;\n                pq.push({nd, nx, ny});\n            }\n        }\n    }\n\n    cout << -1 << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 19:11:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_SIZE 500\n\nint rows, cols;\nchar maze[MAX_SIZE][MAX_SIZE];\nint visited[MAX_SIZE][MAX_SIZE][2];\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\ntypedef struct {\n    int x, y, cards, broken;\n} State;\n\nint is_valid(int x, int y) {\n    return x >= 0 && x < rows && y >= 0 && y < cols;\n}\n\nint bfs(int start_x, int start_y, int end_x, int end_y) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            visited[i][j][0] = visited[i][j][1] = INT_MAX;\n        }\n    }\n\n    State queue[MAX_SIZE * MAX_SIZE];\n    int front = 0, rear = 0;\n\n    queue[rear].x = start_x;\n    queue[rear].y = start_y;\n    queue[rear].cards = 0;\n    queue[rear].broken = 0;\n    visited[start_x][start_y][0] = 0;\n    rear++;\n\n    while (front < rear) {\n        State current = queue[front++];\n\n        if (current.x == end_x && current.y == end_y) {\n            return current.cards;\n        }\n\n        for (int i = 0; i < 4; i++) {\n            int nx = current.x + dx[i];\n            int ny = current.y + dy[i];\n\n            if (!is_valid(nx, ny)) continue;\n\n            if (maze[nx][ny] == '.') {\n                if (current.cards < visited[nx][ny][current.broken]) {\n                    visited[nx][ny][current.broken] = current.cards;\n                    queue[rear].x = nx;\n                    queue[rear].y = ny;\n                    queue[rear].cards = current.cards;\n                    queue[rear].broken = current.broken;\n                    rear++;\n                }\n            } else if (maze[nx][ny] == '#') {\n                if (current.broken == 0) {\n                    if (current.cards + 1 < visited[nx][ny][1]) {\n                        visited[nx][ny][1] = current.cards + 1;\n                        queue[rear].x = nx;\n                        queue[rear].y = ny;\n                        queue[rear].cards = current.cards + 1;\n                        queue[rear].broken = 1;\n                        rear++;\n                    }\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    scanf(\"%d %d\", &rows, &cols);\n\n    int start_x = -1, start_y = -1, end_x = -1, end_y = -1;\n\n    for (int i = 0; i < rows; i++) {\n        scanf(\"%s\", maze[i]);\n        for (int j = 0; j < cols; j++) {\n            if (maze[i][j] == 'S') {\n                start_x = i;\n                start_y = j;\n                maze[i][j] = '.';\n            }\n            if (maze[i][j] == 'E') {\n                end_x = i;\n                end_y = j;\n                maze[i][j] = '.';\n            }\n        }\n    }\n\n    int result = bfs(start_x, start_y, end_x, end_y);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:11:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstruct State {\n    int x, y, cards, broken;\n};\n\nint bfs(vector<vector<char>>& maze, int startX, int startY, int endX, int endY) {\n    int rows = maze.size();\n    int cols = maze[0].size();\n    vector<vector<vector<bool>>> visited(rows, vector<vector<bool>>(cols, vector<bool>(2, false)));\n    \n    queue<State> q;\n    q.push({startX, startY, 0, 0});\n    visited[startX][startY][0] = true;\n    \n    int dx[] = {0, 0, 1, -1};\n    int dy[] = {1, -1, 0, 0};\n    \n    while (!q.empty()) {\n        State curr = q.front();\n        q.pop();\n        \n        if (curr.x == endX && curr.y == endY) {\n            return curr.cards;\n        }\n        \n        for (int k = 0; k < 4; k++) {\n            int nx = curr.x + dx[k];\n            int ny = curr.y + dy[k];\n            \n            if (nx < 0 || nx >= rows || ny < 0 || ny >= cols || maze[nx][ny] == '#') \n                continue;\n            \n            if (maze[nx][ny] == '.' && !visited[nx][ny][curr.broken]) {\n                q.push({nx, ny, curr.cards, curr.broken});\n                visited[nx][ny][curr.broken] = true;\n            }\n            \n            if (maze[nx][ny] == 'D') {\n                if (!visited[nx][ny][curr.broken]) {\n                    q.push({nx, ny, curr.cards + 1, curr.broken});\n                    visited[nx][ny][curr.broken] = true;\n                }\n                \n                if (curr.broken == 0 && !visited[nx][ny][1]) {\n                    q.push({nx, ny, curr.cards + 1, 1});\n                    visited[nx][ny][1] = true;\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int rows, cols;\n    cin >> rows >> cols;\n    \n    vector<vector<char>> maze(rows, vector<char>(cols));\n    int startX = -1, startY = -1, endX = -1, endY = -1;\n    \n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            cin >> maze[i][j];\n            if (maze[i][j] == 'S') {\n                startX = i;\n                startY = j;\n                maze[i][j] = '.';\n            }\n            if (maze[i][j] == 'E') {\n                endX = i;\n                endY = j;\n                maze[i][j] = '.';\n            }\n        }\n    }\n    \n    int result = bfs(maze, startX, startY, endX, endY);\n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:12:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass MazeSolver {\n    private static final int[][] DIRECTIONS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    static class State {\n        int row, col, cardsUsed;\n        boolean doorBroken;\n\n        State(int row, int col, int cardsUsed, boolean doorBroken) {\n            this.row = row;\n            this.col = col;\n            this.cardsUsed = cardsUsed;\n            this.doorBroken = doorBroken;\n        }\n    }\n\n    public static int solveMaze(int[][] maze, int startRow, int startCol, int endRow, int endCol) {\n        int rows = maze.length;\n        int cols = maze[0].length;\n\n        boolean[][][] visited = new boolean[rows][cols][2];\n        PriorityQueue<State> queue = new PriorityQueue<>(Comparator.comparingInt(s -> s.cardsUsed));\n\n        queue.offer(new State(startRow, startCol, 0, false));\n        visited[startRow][startCol][0] = true;\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n\n            if (current.row == endRow && current.col == endCol) {\n                return current.cardsUsed;\n            }\n\n            for (int[] dir : DIRECTIONS) {\n                int newRow = current.row + dir[0];\n                int newCol = current.col + dir[1];\n\n                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {\n                    int cell = maze[newRow][newCol];\n                    int newCardsUsed = current.cardsUsed;\n                    boolean newDoorBroken = current.doorBroken;\n\n                    if (cell == 0) { // Wall\n                        continue;\n                    } else if (cell == 1) { // Passage\n                        // No action needed\n                    } else if (cell == 2) { // Door\n                        if (!newDoorBroken) {\n                            newCardsUsed++;\n                        } else {\n                            continue; // Door is broken\n                        }\n                    }\n\n                    int doorBrokenIndex = newDoorBroken ? 1 : 0;\n                    if (!visited[newRow][newCol][doorBrokenIndex]) {\n                        visited[newRow][newCol][doorBrokenIndex] = true;\n                        queue.offer(new State(newRow, newCol, newCardsUsed, newDoorBroken));\n                    }\n                }\n            }\n\n            // Try breaking a door if not already broken\n            if (!current.doorBroken) {\n                for (int[] dir : DIRECTIONS) {\n                    int newRow = current.row + dir[0];\n                    int newCol = current.col + dir[1];\n\n                    if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {\n                        int cell = maze[newRow][newCol];\n                        if (cell == 2) { // Door\n                            if (!visited[newRow][newCol][1]) {\n                                visited[newRow][newCol][1] = true;\n                                queue.offer(new State(newRow, newCol, current.cardsUsed, true));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int rows = scanner.nextInt();\n        int cols = scanner.nextInt();\n        int[][] maze = new int[rows][cols];\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                maze[i][j] = scanner.nextInt();\n            }\n        }\n\n        int startRow = scanner.nextInt();\n        int startCol = scanner.nextInt();\n        int endRow = scanner.nextInt();\n        int endCol = scanner.nextInt();\n\n        System.out.println(solveMaze(maze, startRow, startCol, endRow, endCol));\n    }\n}",
    "timestamp": "2025-08-05 19:13:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef bfs_search(maze, start, end):\n    rows, cols = len(maze), len(maze[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque([(start[0], start[1], 0)])\n    visited = set()\n    visited.add((start[0], start[1]))\n    \n    while queue:\n        x, y, cards_used = queue.popleft()\n        \n        if (x, y) == end:\n            return cards_used\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited:\n                if maze[nx][ny] == '.':\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, cards_used))\n                elif maze[nx][ny] == 'D':\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, cards_used + 1))\n    \n    return -1\n\ndef minimum_cards_pass_maze(maze, start, end):\n    rows, cols = len(maze), len(maze[0])\n    total_result = bfs_search(maze, start, end)\n\n    if total_result == -1:\n        return -1\n\n    min_cards = total_result\n\n    for x in range(rows):\n        for y in range(cols):\n            if maze[x][y] == 'D':\n                maze_copy = [row[:] for row in maze]\n                maze_copy[x][y] = '.'\n                current_result = bfs_search(maze_copy, start, end)\n                if current_result != -1:\n                    min_cards = min(min_cards, current_result)\n    \n    return min_cards\n\n# Example usage:\nmaze = [\n    ['.', 'D', 'D', '.'],\n    ['.', '#', 'D', '.'],\n    ['.', '.', '.', '.'],\n    ['D', '#', '#', 'E']\n]\nstart = (0, 0)\nend = (3, 3)\n\nprint(minimum_cards_pass_maze(maze, start, end))",
    "timestamp": "2025-08-13 02:54:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class MazeSolver {\n\n    static class Point {\n        int x, y, cards;\n\n        public Point(int x, int y, int cards) {\n            this.x = x;\n            this.y = y;\n            this.cards = cards;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int rows = scanner.nextInt();\n        int cols = scanner.nextInt();\n        int startX = scanner.nextInt();\n        int startY = scanner.nextInt();\n        int endX = scanner.nextInt();\n        int endY = scanner.nextInt();\n\n        char[][] grid = new char[rows][cols];\n        for (int i = 0; i < rows; i++) {\n            String line = scanner.next();\n            for (int j = 0; j < cols; j++) {\n                grid[i][j] = line.charAt(j);\n            }\n        }\n\n        boolean[][][] visited = new boolean[rows][cols][2];\n        Queue<Point> queue = new LinkedList<>();\n        queue.offer(new Point(startX, startY, 0));\n        visited[startX][startY][0] = true;\n\n        int[] dx = {0, 0, 1, -1};\n        int[] dy = {1, -1, 0, 0};\n\n        while (!queue.isEmpty()) {\n            Point current = queue.poll();\n\n            if (current.x == endX && current.y == endY) {\n                System.out.println(current.cards);\n                return;\n            }\n\n            for (int d = 0; d < 4; d++) {\n                int nx = current.x + dx[d];\n                int ny = current.y + dy[d];\n\n                if (nx < 0 || nx >= rows || ny < 0 || ny >= cols || grid[nx][ny] == '#') {\n                    continue;\n                }\n\n                if (grid[nx][ny] == 'D') {\n                    if (!visited[nx][ny][current.cards]) {\n                        queue.offer(new Point(nx, ny, current.cards + 1));\n                        visited[nx][ny][current.cards] = true;\n                    }\n                } else {\n                    if (!visited[nx][ny][current.cards]) {\n                        queue.offer(new Point(nx, ny, current.cards));\n                        visited[nx][ny][current.cards] = true;\n                    }\n                }\n            }\n        }\n        System.out.println(-1);\n    }\n}",
    "timestamp": "2025-08-13 02:54:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_N 100\n#define MAX_C 10\n#define INF INT_MAX\n\nint n, m, c;\nchar maze[MAX_N][MAX_N];\nint door[MAX_N][MAX_N];\nint dist[MAX_N][MAX_N][MAX_C];\nint queue[MAX_N * MAX_N * MAX_C][3];\nint front, rear;\n\nvoid enqueue(int x, int y, int cards) {\n    queue[rear][0] = x;\n    queue[rear][1] = y;\n    queue[rear][2] = cards;\n    rear++;\n}\n\nvoid dequeue(int *x, int *y, int *cards) {\n    *x = queue[front][0];\n    *y = queue[front][1];\n    *cards = queue[front][2];\n    front++;\n}\n\nvoid bfs() {\n    dist[0][0][0] = 0;\n    enqueue(0, 0, 0);\n\n    while (front < rear) {\n        int x, y, cards;\n        dequeue(&x, &y, &cards);\n\n        for (int d = 0; d < 4; d++) {\n            int nx = x + \"0121\"[d] - '1';\n            int ny = y + \"1210\"[d] - '1';\n\n            if (nx >= 0 && ny >= 0 && nx < n && ny < m && maze[nx][ny] != '#') {\n                int new_cards = cards;\n                if (door[nx][ny] == 1) {\n                    if (cards < c) new_cards++;\n                    else new_cards = INF;\n                }\n\n                if (dist[nx][ny][new_cards] > dist[x][y][cards] + 1) {\n                    dist[nx][ny][new_cards] = dist[x][y][cards] + 1;\n                    enqueue(nx, ny, new_cards);\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &n, &m, &c);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", maze[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            door[i][j] = (maze[i][j] == 'D') ? 1 : 0;\n            for (int k = 0; k < MAX_C; k++) dist[i][j][k] = INF;\n        }\n    }\n\n    bfs();\n\n    int min_cards = INF;\n    for (int k = 0; k < c; k++) {\n        if (dist[n-1][m-1][k] < min_cards) {\n            min_cards = dist[n-1][m-1][k];\n        }\n    }\n\n    printf(\"%d\\n\", (min_cards == INF) ? -1 : min_cards);\n    return 0;\n}",
    "timestamp": "2025-08-13 02:54:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef solve_maze(grid):\n    rows, cols = len(grid), len(grid[0])\n    start = (0, 0)\n    end = (rows-1, cols-1)\n    \n    def is_valid(x, y):\n        return 0 <= x < rows and 0 <= y < cols and grid[x][y] != '#'\n    \n    def bfs(broken_door=None):\n        visited = set()\n        queue = deque([(start[0], start[1], 0, 0)])\n        \n        while queue:\n            x, y, cards, dist = queue.popleft()\n            \n            if (x, y) == end:\n                return dist\n            \n            if (x, y, cards) in visited:\n                continue\n            visited.add((x, y, cards))\n            \n            for dx, dy in [(0,1), (1,0), (0,-1), (-1,0)]:\n                nx, ny = x + dx, y + dy\n                \n                if not is_valid(nx, ny):\n                    continue\n                \n                if grid[nx][ny] == '.':\n                    queue.append((nx, ny, cards, dist+1))\n                \n                elif grid[nx][ny] == 'D':\n                    if broken_door and (nx, ny) == broken_door:\n                        queue.append((nx, ny, cards, dist+1))\n                    elif cards < 1:\n                        queue.append((nx, ny, cards+1, dist+1))\n        \n        return -1\n    \n    result = bfs()\n    if result == -1:\n        for x in range(rows):\n            for y in range(cols):\n                if grid[x][y] == 'D':\n                    temp_result = bfs((x, y))\n                    if temp_result != -1:\n                        return temp_result\n    \n    return result\n\n# Example usage\nrows, cols = map(int, input().split())\ngrid = [list(input().strip()) for _ in range(rows)]\nprint(solve_maze(grid))",
    "timestamp": "2025-08-13 02:55:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    H, W = map(int, sys.stdin.readline().split())\n    grid = [sys.stdin.readline().strip() for _ in range(H)]\n    \n    # Directions: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # We'll perform BFS for each possible broken door (and the case with no broken door)\n    min_cards = float('inf')\n    \n    # Check the case where no door is broken\n    visited = [[float('inf')] * W for _ in range(H)]\n    q = deque()\n    q.append((0, 0, 0))\n    visited[0][0] = 0\n    \n    while q:\n        i, j, cards = q.popleft()\n        if i == H-1 and j == W-1:\n            min_cards = min(min_cards, cards)\n            break\n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < H and 0 <= nj < W:\n                if grid[ni][nj] == '#':\n                    continue\n                if grid[ni][nj] == 'D':\n                    new_cards = cards + 1\n                else:\n                    new_cards = cards\n                if new_cards < visited[ni][nj]:\n                    visited[ni][nj] = new_cards\n                    q.append((ni, nj, new_cards))\n    \n    # Now check cases where each 'D' is considered broken\n    doors = []\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'D':\n                doors.append((i, j))\n    \n    for (bi, bj) in doors:\n        visited = [[float('inf')] * W for _ in range(H)]\n        q = deque()\n        q.append((0, 0, 0))\n        visited[0][0] = 0\n        \n        found = False\n        while q:\n            i, j, cards = q.popleft()\n            if i == H-1 and j == W-1:\n                min_cards = min(min_cards, cards)\n                found = True\n                break\n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < H and 0 <= nj < W:\n                    if grid[ni][nj] == '#':\n                        continue\n                    new_cards = cards\n                    if grid[ni][nj] == 'D':\n                        if (ni, nj) == (bi, bj):\n                            # This door is broken, card is returned\n                            pass\n                        else:\n                            new_cards += 1\n                    if new_cards < visited[ni][nj]:\n                        visited[ni][nj] = new_cards\n                        q.append((ni, nj, new_cards))\n        if not found:\n            # Check if it's impossible when this door is broken\n            pass\n    \n    if min_cards != float('inf'):\n        print(min_cards)\n    else:\n        print(-1)\n\nsolve()",
    "timestamp": "2025-08-13 02:55:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits.h>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n};\n\nconst vector<Point> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\nbool isValid(int x, int y, int n, int m) {\n    return x >= 0 && x < n && y >= 0 && y < m;\n}\n\nint minCards(vector<vector<char>> &maze) {\n    int n = maze.size();\n    int m = maze[0].size();\n\n    vector<vector<int>> minSteps(n, vector<int>(m, INT_MAX));\n    queue<Point> q;\n\n    q.push({0, 0});\n    minSteps[0][0] = 0;\n\n    while (!q.empty()) {\n        Point curr = q.front();\n        q.pop();\n\n        for (auto dir : directions) {\n            int nx = curr.x + dir.x;\n            int ny = curr.y + dir.y;\n\n            if (isValid(nx, ny, n, m) && maze[nx][ny] != '#') {\n                int additionalCard = maze[nx][ny] == 'D' ? 1 : 0;\n\n                if (minSteps[curr.x][curr.y] + additionalCard < minSteps[nx][ny]) {\n                    minSteps[nx][ny] = minSteps[curr.x][curr.y] + additionalCard;\n                    q.push({nx, ny});\n                }\n            }\n        }\n    }\n\n    int result = INT_MAX;\n\n    if (minSteps[n - 1][m - 1] != INT_MAX) {\n        result = minSteps[n - 1][m - 1];\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (maze[i][j] == 'D') {\n                vector<vector<int>> tempSteps(n, vector<int>(m, INT_MAX));\n\n                q.push({0, 0});\n                tempSteps[0][0] = 0;\n\n                while (!q.empty()) {\n                    Point curr = q.front();\n                    q.pop();\n\n                    for (auto dir : directions) {\n                        int nx = curr.x + dir.x;\n                        int ny = curr.y + dir.y;\n\n                        if (isValid(nx, ny, n, m) && maze[nx][ny] != '#') {\n                            int additionalCard = (nx == i && ny == j) ? 0 : maze[nx][ny] == 'D' ? 1 : 0;\n\n                            if (tempSteps[curr.x][curr.y] + additionalCard < tempSteps[nx][ny]) {\n                                tempSteps[nx][ny] = tempSteps[curr.x][curr.y] + additionalCard;\n                                q.push({nx, ny});\n                            }\n                        }\n                    }\n                }\n\n                if (tempSteps[n - 1][m - 1] != INT_MAX) {\n                    result = min(result, tempSteps[n - 1][m - 1]);\n                }\n            }\n        }\n    }\n\n    return (result == INT_MAX) ? -1 : result;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<char>> maze(n, vector<char>(m));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            cin >> maze[i][j];\n        }\n    }\n\n    cout << minCards(maze) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:08:21"
  }
]