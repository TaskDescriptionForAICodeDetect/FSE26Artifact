[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nchar shapes[7][4][5] = {\n    {\"1111\", \"0000\", \"0000\", \"0000\"}, // A\n    {\"1000\", \"1000\", \"1000\", \"1000\"}, // B\n    {\"1100\", \"1100\", \"0000\", \"0000\"}, // C\n    {\"1000\", \"1000\", \"1100\", \"0000\"}, // D\n    {\"1110\", \"1000\", \"0000\", \"0000\"}, // E\n    {\"1100\", \"0100\", \"0100\", \"0000\"}, // F\n    {\"0100\", \"1100\", \"0100\", \"0000\"}  // G\n};\n\nvoid extract_shape(int grid[8][8], int shape[4][4]) {\n    int min_row = 8, min_col = 8;\n    int max_row = -1, max_col = -1;\n    \n    for (int i = 0; i < 8; i++) {\n        for (int j = 0; j < 8; j++) {\n            if (grid[i][j] == 1) {\n                if (i < min_row) min_row = i;\n                if (i > max_row) max_row = i;\n                if (j < min_col) min_col = j;\n                if (j > max_col) max_col = j;\n            }\n        }\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            int row = min_row + i;\n            int col = min_col + j;\n            if (row <= max_row && col <= max_col) {\n                shape[i][j] = grid[row][col];\n            } else {\n                shape[i][j] = 0;\n            }\n        }\n    }\n}\n\nint compare_shape(int shape[4][4], char target[4][5]) {\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            int expected = (target[i][j] == '1') ? 1 : 0;\n            if (shape[i][j] != expected) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nchar identify_shape(int shape[4][4]) {\n    for (int k = 0; k < 7; k++) {\n        if (compare_shape(shape, shapes[k])) {\n            return 'A' + k;\n        }\n    }\n    return '?';\n}\n\nint main() {\n    char line[9];\n    int grid[8][8];\n    int first = 1;\n    \n    while (1) {\n        for (int i = 0; i < 8; i++) {\n            if (scanf(\"%8s\", line) != 1) return 0;\n            for (int j = 0; j < 8; j++) {\n                grid[i][j] = (line[j] == '1') ? 1 : 0;\n            }\n        }\n        \n        int shape[4][4] = {0};\n        extract_shape(grid, shape);\n        char result = identify_shape(shape);\n        printf(\"%c\\n\", result);\n        \n        while (getchar() != '\\n'); // consume remaining characters\n        if (getchar() == EOF) break;\n        ungetc('\\n', stdin);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:25:47"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ShapeRecognition {\n    static char[][] grid = new char[8][8];\n    static char[][] shapes = {\n        {'A', new char[][]{\n            {'1', '1', '1'},\n            {'0', '1', '0'},\n            {'0', '1', '0'}\n        }},\n        {'B', new char[][]{\n            {'1', '1', '1'},\n            {'1', '0', '1'},\n            {'1', '1', '1'}\n        }},\n        {'C', new char[][]{\n            {'1', '1', '1'},\n            {'1', '0', '0'},\n            {'1', '1', '1'}\n        }},\n        {'D', new char[][]{\n            {'1', '1', '1'},\n            {'0', '0', '1'},\n            {'1', '1', '1'}\n        }},\n        {'E', new char[][]{\n            {'1', '1', '1'},\n            {'1', '0', '1'},\n            {'0', '0', '0'}\n        }},\n        {'F', new char[][]{\n            {'1', '1', '1'},\n            {'0', '1', '1'},\n            {'0', '0', '1'}\n        }},\n        {'G', new char[][]{\n            {'1', '1', '1'},\n            {'1', '0', '0'},\n            {'0', '0', '1'}\n        }}\n    };\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (scanner.hasNextLine()) {\n            // Read grid\n            for (int i = 0; i < 8; i++) {\n                String line = scanner.nextLine();\n                if (line.trim().isEmpty()) break;\n                grid[i] = line.toCharArray();\n            }\n            \n            // Find shape\n            char shape = findShape();\n            System.out.println(shape);\n        }\n        \n        scanner.close();\n    }\n\n    static char findShape() {\n        for (char[] shapeData : shapes) {\n            char shapeLetter = shapeData[0];\n            char[][] shapePattern = (char[][]) shapeData[1];\n            \n            if (matchShape(shapePattern)) {\n                return shapeLetter;\n            }\n        }\n        return ' ';\n    }\n\n    static boolean matchShape(char[][] pattern) {\n        for (int r = 0; r <= 5; r++) {\n            for (int c = 0; c <= 5; c++) {\n                if (checkPattern(r, c, pattern)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    static boolean checkPattern(int startR, int startC, char[][] pattern) {\n        for (int r = 0; r < 3; r++) {\n            for (int c = 0; c < 3; c++) {\n                if (pattern[r][c] == '1' && grid[startR + r][startC + c] != '1') {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 18:25:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> rotate(const vector<vector<int>>& shape) {\n    int n = shape.size();\n    vector<vector<int>> rotated(n, vector<int>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            rotated[j][n - 1 - i] = shape[i][j];\n        }\n    }\n    return rotated;\n}\n\nvector<vector<int>> reflect(const vector<vector<int>>& shape) {\n    int n = shape.size();\n    vector<vector<int>> reflected(n, vector<int>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            reflected[i][n - 1 - j] = shape[i][j];\n        }\n    }\n    return reflected;\n}\n\nbool isSame(const vector<vector<int>>& a, const vector<vector<int>>& b) {\n    if (a.size() != b.size() || a[0].size() != b[0].size()) return false;\n    for (size_t i = 0; i < a.size(); ++i) {\n        for (size_t j = 0; j < a[i].size(); ++j) {\n            if (a[i][j] != b[i][j]) return false;\n        }\n    }\n    return true;\n}\n\nchar identifyShape(const vector<vector<int>>& grid) {\n    vector<vector<vector<int>>> shapes = {\n        {{1,1,1,1}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}}, // A\n        {{1,1,1,0}, {1,0,0,0}, {0,0,0,0}, {0,0,0,0}}, // B\n        {{1,1,1,0}, {0,1,0,0}, {0,0,0,0}, {0,0,0,0}}, // C\n        {{1,1,0,0}, {1,1,0,0}, {0,0,0,0}, {0,0,0,0}}, // D\n        {{1,1,1,1}, {0,1,0,0}, {0,0,0,0}, {0,0,0,0}}, // E\n        {{1,1,1,0}, {1,1,0,0}, {0,0,0,0}, {0,0,0,0}}, // F\n        {{1,1,0,0}, {1,0,0,0}, {1,0,0,0}, {0,0,0,0}}  // G\n    };\n\n    vector<char> labels = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};\n\n    vector<vector<int>> trimmed;\n    int min_row = 8, max_row = -1, min_col = 8, max_col = -1;\n    for (int i = 0; i < 8; ++i) {\n        for (int j = 0; j < 8; ++j) {\n            if (grid[i][j] == 1) {\n                min_row = min(min_row, i);\n                max_row = max(max_row, i);\n                min_col = min(min_col, j);\n                max_col = max(max_col, j);\n            }\n        }\n    }\n\n    int h = max_row - min_row + 1;\n    int w = max_col - min_col + 1;\n    trimmed.resize(h, vector<int>(w));\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            trimmed[i][j] = grid[min_row + i][min_col + j];\n        }\n    }\n\n    for (int k = 0; k < shapes.size(); ++k) {\n        auto shape = shapes[k];\n        vector<vector<int>> current = shape;\n        for (int flip = 0; flip < 2; ++flip) {\n            for (int rot = 0; rot < 4; ++rot) {\n                if (isSame(trimmed, current)) {\n                    return labels[k];\n                }\n                current = rotate(current);\n            }\n            current = reflect(current);\n        }\n    }\n\n    return '?';\n}\n\nint main() {\n    string line;\n    vector<vector<int>> grid(8, vector<int>(8));\n    bool first = true;\n\n    while (true) {\n        for (int i = 0; i < 8; ++i) {\n            if (!getline(cin, line)) {\n                if (!first) {\n                    char shape = identifyShape(grid);\n                    cout << shape << endl;\n                }\n                return 0;\n            }\n            for (int j = 0; j < 8; ++j) {\n                grid[i][j] = line[j] - '0';\n            }\n        }\n        char shape = identifyShape(grid);\n        cout << shape << endl;\n\n        first = false;\n        if (!getline(cin, line)) break;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:26:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nchar shapes[7][8][8] = {\n    // A\n    {\n        \"11111000\",\n        \"10001000\",\n        \"10001000\",\n        \"11111000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\"\n    },\n    // B\n    {\n        \"11111000\",\n        \"10001000\",\n        \"11110000\",\n        \"10001000\",\n        \"10001000\",\n        \"11111000\",\n        \"00000000\",\n        \"00000000\"\n    },\n    // C\n    {\n        \"01111000\",\n        \"11001000\",\n        \"10001000\",\n        \"10001000\",\n        \"11001000\",\n        \"01111000\",\n        \"00000000\",\n        \"00000000\"\n    },\n    // D\n    {\n        \"11110000\",\n        \"10011000\",\n        \"10001100\",\n        \"10001100\",\n        \"10011000\",\n        \"11110000\",\n        \"00000000\",\n        \"00000000\"\n    },\n    // E\n    {\n        \"11111000\",\n        \"10000000\",\n        \"11110000\",\n        \"10000000\",\n        \"10000000\",\n        \"11111000\",\n        \"00000000\",\n        \"00000000\"\n    },\n    // F\n    {\n        \"11111000\",\n        \"10000000\",\n        \"11110000\",\n        \"10000000\",\n        \"10000000\",\n        \"10000000\",\n        \"00000000\",\n        \"00000000\"\n    },\n    // G\n    {\n        \"01111000\",\n        \"11001000\",\n        \"10001000\",\n        \"10111000\",\n        \"11001000\",\n        \"01111000\",\n        \"00000000\",\n        \"00000000\"\n    }\n};\n\nint compare_grid(char grid[8][8], char shape[8][8]) {\n    for (int i = 0; i < 8; i++) {\n        for (int j = 0; j < 8; j++) {\n            if (grid[i][j] != shape[i][j]) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char grid[8][8];\n    char line[10];\n\n    while (1) {\n        // Read grid\n        for (int i = 0; i < 8; i++) {\n            if (fgets(line, sizeof(line), stdin) == NULL) return 0;\n            strcpy(grid[i], line);\n            grid[i][8] = '\\0';\n        }\n\n        // Check match with each shape\n        for (int s = 0; s < 7; s++) {\n            if (compare_grid(grid, shapes[s])) {\n                printf(\"%c\\n\", 'A' + s);\n                break;\n            }\n        }\n\n        // Check for end of input\n        if (fgets(line, sizeof(line), stdin) == NULL) break;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:26:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nconst std::vector<std::vector<std::string>> shapes = {\n    {\n        \"11100000\",\n        \"10000000\",\n        \"10000000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\"\n    },\n    {\n        \"11110000\",\n        \"10010000\",\n        \"10010000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\"\n    },\n    {\n        \"11100000\",\n        \"00100000\",\n        \"00100000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\"\n    },\n    {\n        \"11110000\",\n        \"10010000\",\n        \"11110000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\"\n    },\n    {\n        \"11100000\",\n        \"10100000\",\n        \"10100000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\"\n    },\n    {\n        \"11110000\",\n        \"10010000\",\n        \"10010000\",\n        \"10010000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\"\n    },\n    {\n        \"11100000\",\n        \"10000000\",\n        \"11100000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\"\n    }\n};\n\nbool match_shape(const std::vector<std::string>& grid, const std::vector<std::string>& shape) {\n    for (int r = 0; r <= 8 - shape.size(); ++r) {\n        for (int c = 0; c <= 8 - shape[0].length(); ++c) {\n            bool matched = true;\n            for (int i = 0; i < shape.size(); ++i) {\n                for (int j = 0; j < shape[0].length(); ++j) {\n                    if (shape[i][j] == '1' && grid[r + i][c + j] == '0') {\n                        matched = false;\n                        break;\n                    }\n                }\n                if (!matched) break;\n            }\n            if (matched) return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    std::string line;\n    while (std::getline(std::cin, line)) {\n        std::vector<std::string> grid(8);\n        grid[0] = line;\n        \n        for (int i = 1; i < 8; ++i) {\n            std::getline(std::cin, grid[i]);\n        }\n        \n        for (int i = 0; i < shapes.size(); ++i) {\n            if (match_shape(grid, shapes[i])) {\n                std::cout << char('A' + i) << std::endl;\n                break;\n            }\n        }\n        \n        std::getline(std::cin, line);\n        if (std::cin.eof()) break;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:27:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ShapeRecognizer {\n    private static final String[] SHAPE_A = {\n        \"00000000\",\n        \"00000000\",\n        \"00000000\",\n        \"00011000\",\n        \"00011000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\"\n    };\n    private static final String[] SHAPE_B = {\n        \"00000000\",\n        \"00000000\",\n        \"00000000\",\n        \"00111100\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\"\n    };\n    private static final String[] SHAPE_C = {\n        \"00000000\",\n        \"00000000\",\n        \"00010000\",\n        \"00010000\",\n        \"00010000\",\n        \"00010000\",\n        \"00000000\",\n        \"00000000\"\n    };\n    private static final String[] SHAPE_D = {\n        \"00000000\",\n        \"00000000\",\n        \"00010000\",\n        \"00010000\",\n        \"00011000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\"\n    };\n    private static final String[] SHAPE_E = {\n        \"00000000\",\n        \"00000000\",\n        \"00011000\",\n        \"00010000\",\n        \"00010000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\"\n    };\n    private static final String[] SHAPE_F = {\n        \"00000000\",\n        \"00000000\",\n        \"00011000\",\n        \"00001000\",\n        \"00001000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\"\n    };\n    private static final String[] SHAPE_G = {\n        \"00000000\",\n        \"00000000\",\n        \"00001000\",\n        \"00001000\",\n        \"00011000\",\n        \"00000000\",\n        \"00000000\",\n        \"00000000\"\n    };\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        List<String[]> datasets = new ArrayList<>();\n        List<String> currentDataset = new ArrayList<>();\n\n        while (scanner.hasNextLine()) {\n            String line = scanner.nextLine();\n            if (line.isEmpty()) {\n                if (!currentDataset.isEmpty()) {\n                    datasets.add(currentDataset.toArray(new String[0]));\n                    currentDataset.clear();\n                }\n            } else {\n                currentDataset.add(line);\n            }\n        }\n        if (!currentDataset.isEmpty()) {\n            datasets.add(currentDataset.toArray(new String[0]));\n        }\n\n        for (String[] dataset : datasets) {\n            if (matchesShape(dataset, SHAPE_A)) {\n                System.out.println(\"A\");\n            } else if (matchesShape(dataset, SHAPE_B)) {\n                System.out.println(\"B\");\n            } else if (matchesShape(dataset, SHAPE_C)) {\n                System.out.println(\"C\");\n            } else if (matchesShape(dataset, SHAPE_D)) {\n                System.out.println(\"D\");\n            } else if (matchesShape(dataset, SHAPE_E)) {\n                System.out.println(\"E\");\n            } else if (matchesShape(dataset, SHAPE_F)) {\n                System.out.println(\"F\");\n            } else if (matchesShape(dataset, SHAPE_G)) {\n                System.out.println(\"G\");\n            }\n        }\n    }\n\n    private static boolean matchesShape(String[] dataset, String[] shape) {\n        for (int i = 0; i < 8; i++) {\n            if (!dataset[i].equals(shape[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 18:28:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def identify_shape(grid):\n    shapes = {\n        'A': ['111', '101', '111'],\n        'B': ['111', '101', '111', '101', '111'],\n        'C': ['111', '100', '100', '100', '111'],\n        'D': ['110', '101', '101', '101', '110'],\n        'E': ['111', '100', '111', '100', '111'],\n        'F': ['111', '100', '111', '100', '100'],\n        'G': ['111', '100', '110', '101', '111']\n    }\n\n    def shape_matches(grid, shape):\n        for r in range(8):\n            for c in range(8):\n                sub_grid = [row[c:c+len(shape[0])] for row in grid[r:r+len(shape)]]\n                if all(sh_row == s_row for sh_row, s_row in zip(sub_grid, shape)):\n                    return True\n        return False\n\n    for label, pattern in shapes.items():\n        if shape_matches(grid, pattern):\n            return label\n\nimport sys\n\ndef main():\n    input_data = sys.stdin.read().strip()\n    datasets = input_data.split('\\n\\n')\n\n    results = []\n    for data in datasets:\n        grid = data.splitlines()\n        result = identify_shape(grid)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-12 23:07:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ShapeRecognition {\n    private static final Map<String, Character> SHAPE_MAP = new HashMap<>();\n\n    static {\n        SHAPE_MAP.put(\"1111111101100000\", 'A');\n        SHAPE_MAP.put(\"1111111101111000\", 'B');\n        SHAPE_MAP.put(\"1111000000111110\", 'C');\n        SHAPE_MAP.put(\"1110000000111110\", 'D');\n        SHAPE_MAP.put(\"1111111100010000\", 'E');\n        SHAPE_MAP.put(\"1111111101110000\", 'F');\n        SHAPE_MAP.put(\"1111000000011110\", 'G');\n    }\n\n    private static String normalizeShape(char[][] grid) {\n        int firstRow = 8, lastRow = -1, firstCol = 8, lastCol = -1;\n        for (int r = 0; r < 8; r++) {\n            for (int c = 0; c < 8; c++) {\n                if (grid[r][c] == '1') {\n                    if (r < firstRow) firstRow = r;\n                    if (r > lastRow) lastRow = r;\n                    if (c < firstCol) firstCol = c;\n                    if (c > lastCol) lastCol = c;\n                }\n            }\n        }\n\n        StringBuilder normalized = new StringBuilder();\n        for (int r = firstRow; r <= lastRow; r++) {\n            for (int c = firstCol; c <= lastCol; c++) {\n                normalized.append(grid[r][c]);\n            }\n        }\n        return normalized.toString();\n    }\n\n    private static char recognizeShape(char[][] grid) {\n        String normalized = normalizeShape(grid);\n        return SHAPE_MAP.getOrDefault(normalized, '?');\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasetCount = 0;\n        char[][] grid = new char[8][8];\n        while (scanner.hasNextLine() && datasetCount++ < 50) {\n            for (int i = 0; i < 8; i++) {\n                grid[i] = scanner.nextLine().trim().toCharArray();\n            }\n            System.out.println(recognizeShape(grid));\n            if (scanner.hasNextLine()) {\n                scanner.nextLine(); // Consume the blank line between datasets\n            }\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-12 23:07:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_DATASETS 50\n\nconst char *types[7] = {\n    // Shape A (T-shape)\n    \"00000000\"\n    \"00100000\"\n    \"00100000\"\n    \"11110000\"\n    \"00000000\"\n    \"00000000\"\n    \"00000000\"\n    \"00000000\",\n  \n    // Shape B (L-shape)\n    \"00000000\"\n    \"00100000\"\n    \"00100000\"\n    \"00110000\"\n    \"00000000\"\n    \"00000000\"\n    \"00000000\"\n    \"00000000\",\n  \n    // Shape C (o-shape)\n    \"00000000\"\n    \"00000000\"\n    \"00011000\"\n    \"00011000\"\n    \"00000000\"\n    \"00000000\"\n    \"00000000\"\n    \"00000000\",\n  \n    // Shape D (Z-shape)\n    \"00000000\"\n    \"00110000\"\n    \"01100000\"\n    \"00000000\"\n    \"00000000\"\n    \"00000000\"\n    \"00000000\"\n    \"00000000\",\n  \n    // Shape E (I-shape)\n    \"00001000\"\n    \"00001000\"\n    \"00001000\"\n    \"00001000\"\n    \"00000000\"\n    \"00000000\"\n    \"00000000\"\n    \"00000000\",\n  \n    // Shape F (S-shape)\n    \"00000000\"\n    \"00011000\"\n    \"00110000\"\n    \"00000000\"\n    \"00000000\"\n    \"00000000\"\n    \"00000000\"\n    \"00000000\",\n  \n    // Shape G (square shape)\n    \"00000000\"\n    \"00000000\"\n    \"00110000\"\n    \"00110000\"\n    \"00000000\"\n    \"00000000\"\n    \"00000000\"\n    \"00000000\"\n};\n\nchar grid[8][9];\nchar type[8 * 8 + 1];\n\nint main() {\n    int datasetCounter = 0;\n    while (datasetCounter < MAX_DATASETS) {\n        for (int i = 0; i < 8; i++) {\n            if (scanf(\"%8s\", grid[i]) != 1) return 0;\n        }\n        getchar();  // To consume the newline after each dataset\n        \n        for (int i = 0, k = 0; i < 8; i++) {\n            for (int j = 0; j < 8; j++) {\n                type[k++] = grid[i][j];\n            }\n        }\n        type[64] = '\\0';\n\n        for (int i = 0; i < 7; i++) {\n            if (strcmp(types[i], type) == 0) {\n                printf(\"%c\\n\", 'A' + i);\n                break;\n            }\n        }\n\n        datasetCounter++;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-12 23:07:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def classify_shape(grid):\n    shapes = {\n        'A': [\n            [1,1,1],\n            [0,1,0],\n            [0,1,0]\n        ],\n        'B': [\n            [1,1,1],\n            [1,0,1],\n            [1,1,1]\n        ],\n        'C': [\n            [1,1,1],\n            [1,0,0],\n            [1,1,1]\n        ],\n        'D': [\n            [1,1,1],\n            [0,0,1],\n            [1,1,1]\n        ],\n        'E': [\n            [1,1,1],\n            [1,0,1],\n            [0,0,0]\n        ],\n        'F': [\n            [1,1,1],\n            [0,1,1],\n            [0,0,0]\n        ],\n        'G': [\n            [1,1,1],\n            [1,1,0],\n            [0,0,0]\n        ]\n    }\n    \n    for shape_name, shape_pattern in shapes.items():\n        if check_shape_match(grid, shape_pattern):\n            return shape_name\n    \n    return None\n\ndef check_shape_match(grid, shape_pattern):\n    for r in range(6):\n        for c in range(6):\n            if match_shape(grid, r, c, shape_pattern):\n                return True\n    return False\n\ndef match_shape(grid, start_r, start_c, shape_pattern):\n    for r in range(3):\n        for c in range(3):\n            if shape_pattern[r][c] == 1 and grid[start_r+r][start_c+c] == '0':\n                return False\n            if shape_pattern[r][c] == 0 and grid[start_r+r][start_c+c] == '1':\n                return False\n    return True\n\ndef main():\n    while True:\n        grid = []\n        try:\n            for _ in range(8):\n                line = input().strip()\n                if not line:\n                    break\n                grid.append(line)\n            \n            if not grid:\n                break\n            \n            result = classify_shape(grid)\n            print(result)\n            \n            # Read blank line\n            input().strip()\n        \n        except EOFError:\n            break\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-12 23:08:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    shapes = {\n        'A': [\n            [1, 1, 1, 1, 1, 1, 1, 1],\n            [1, 1, 1, 1, 1, 1, 1, 1],\n            [1, 1, 1, 1, 1, 1, 1, 1],\n            [1, 1, 1, 1, 1, 1, 1, 1],\n            [1, 1, 1, 1, 1, 1, 1, 1],\n            [1, 1, 1, 1, 1, 1, 1, 1],\n            [1, 1, 1, 1, 1, 1, 1, 1],\n            [1, 1, 1, 1, 1, 1, 1, 1]\n        ],\n        'B': [\n            [1, 0, 0, 0, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0, 0, 0, 0],\n            [1, 1, 1, 1, 1, 1, 1, 1]\n        ],\n        'C': [\n            [1, 1, 1, 1, 1, 1, 1, 1],\n            [0, 0, 0, 0, 0, 0, 0, 1],\n            [0, 0, 0, 0, 0, 0, 0, 1],\n            [0, 0, 0, 0, 0, 0, 0, 1],\n            [0, 0, 0, 0, 0, 0, 0, 1],\n            [0, 0, 0, 0, 0, 0, 0, 1],\n            [0, 0, 0, 0, 0, 0, 0, 1],\n            [1, 1, 1, 1, 1, 1, 1, 1]\n        ],\n        'D': [\n            [1, 1, 1, 1, 1, 1, 1, 1],\n            [1, 0, 0, 0, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0, 0, 0, 0],\n            [1, 1, 1, 1, 1, 1, 1, 1]\n        ],\n        'E': [\n            [1, 1, 1, 1, 1, 1, 1, 1],\n            [1, 1, 1, 1, 1, 1, 1, 1],\n            [1, 1, 0, 0, 0, 0, 0, 0],\n            [1, 1, 0, 0, 0, 0, 0, 0],\n            [1, 1, 0, 0, 0, 0, 0, 0],\n            [1, 1, 0, 0, 0, 0, 0, 0],\n            [1, 1, 1, 1, 1, 1, 1, 1],\n            [1, 1, 1, 1, 1, 1, 1, 1]\n        ],\n        'F': [\n            [1, 1, 1, 1, 1, 1, 1, 1],\n            [1, 1, 1, 1, 1, 1, 1, 1],\n            [0, 0, 0, 0, 0, 0, 1, 1],\n            [0, 0, 0, 0, 0, 0, 1, 1],\n            [0, 0, 0, 0, 0, 0, 1, 1],\n            [0, 0, 0, 0, 0, 0, 1, 1],\n            [1, 1, 1, 1, 1, 1, 1, 1],\n            [1, 1, 1, 1, 1, 1, 1, 1]\n        ],\n        'G': [\n            [1, 1, 0, 0, 0, 0, 1, 1],\n            [1, 1, 0, 0, 0, 0, 1, 1],\n            [1, 1, 0, 0, 0, 0, 1, 1],\n            [1, 1, 0, 0, 0, 0, 1, 1],\n            [1, 1, 0, 0, 0, 0, 1, 1],\n            [1, 1, 0, 0, 0, 0, 1, 1],\n            [1, 1, 0, 0, 0, 0, 1, 1],\n            [1, 1, 0, 0, 0, 0, 1, 1]\n        ]\n    }\n    \n    import sys\n    data = sys.stdin.read().split('\\n')\n    idx = 0\n    while idx < len(data):\n        grid = []\n        while idx < len(data) and data[idx].strip() == '':\n            idx += 1\n        if idx >= len(data):\n            break\n        for _ in range(8):\n            if idx >= len(data):\n                break\n            line = data[idx].strip()\n            if line == '':\n                break\n            row = [int(c) for c in line]\n            grid.append(row)\n            idx += 1\n        for name, shape in shapes.items():\n            match = True\n            for i in range(8):\n                for j in range(8):\n                    if grid[i][j] != shape[i][j]:\n                        match = False\n                        break\n                if not match:\n                    break\n            if match:\n                print(name)\n                break\n\nsolve()",
    "timestamp": "2025-08-12 23:09:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Shapes representation through vectors of strings\nconst vector<pair<char, vector<string>>> shapes = {\n    {'A', {\"1111\", \"1000\", \"1000\", \"1000\"}},\n    {'B', {\"1111\", \"1000\", \"1110\", \"1110\"}},\n    {'C', {\"1100\", \"1100\", \"1111\"}},\n    {'D', {\"1111\", \"1100\"}},\n    {'E', {\"1100\", \"1100\", \"1100\", \"1100\"}},\n    {'F', {\"111\", \"101\", \"101\"}},\n    {'G', {\"110\", \"100\", \"101\"}}\n};\n\n// Function to compare sub grid with a shape\nbool matchShape(const vector<string> &shape, const vector<string> &grid, int startRow, int startCol) {\n    for (size_t i = 0; i < shape.size(); ++i) {\n        for (size_t j = 0; j < shape[i].size(); ++j) {\n            if (shape[i][j] == '1' && grid[startRow + i][startCol + j] == '0') {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nchar detectShape(const vector<string> &grid) {\n    for (const auto &shape : shapes) {\n        for (int row = 0; row <= 8 - shape.second.size(); ++row) {\n            for (int col = 0; col <= 8 - shape.second[0].size(); ++col) {\n                if (matchShape(shape.second, grid, row, col)) {\n                    return shape.first;\n                }\n            }\n        }\n    }\n    return '?';  // If no shape matches\n}\n\nint main() {\n    string line;\n    vector<string> grid;\n    int datasetCounter = 0;\n    \n    while (getline(cin, line)) {\n        if (line.empty() && !grid.empty()) {\n            cout << detectShape(grid) << endl;\n            grid.clear();\n            ++datasetCounter;\n            continue;\n        }\n        \n        grid.push_back(line);\n    }\n    \n    if (!grid.empty()) {\n        cout << detectShape(grid) << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 10:48:54"
  }
]