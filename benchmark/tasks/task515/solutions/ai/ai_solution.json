[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_N 100\n#define MAX_LEN 1000\n\nbool is_substring(char* str, char* password) {\n    int str_len = strlen(str);\n    int pass_len = strlen(password);\n    \n    for (int i = 0; i <= pass_len - str_len; i++) {\n        bool match = true;\n        for (int j = 0; j < str_len; j++) {\n            if (str[j] != password[i+j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) return true;\n    }\n    return false;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    char dangerous_passwords[MAX_N][MAX_LEN];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s\", dangerous_passwords[i]);\n    }\n    \n    char candidate[MAX_LEN] = {0};\n    candidate[0] = 'a';\n    candidate[1] = '\\0';\n    \n    while (1) {\n        bool is_valid = true;\n        \n        for (int i = 0; i < N; i++) {\n            if (is_substring(candidate, dangerous_passwords[i])) {\n                is_valid = false;\n                break;\n            }\n        }\n        \n        if (is_valid) {\n            printf(\"%s\\n\", candidate);\n            break;\n        }\n        \n        // Lexicographically next string generation\n        int len = strlen(candidate);\n        int idx = len - 1;\n        \n        while (idx >= 0 && candidate[idx] == 'z') {\n            candidate[idx] = 'a';\n            idx--;\n        }\n        \n        if (idx < 0) {\n            candidate[len] = 'a';\n            candidate[len+1] = '\\0';\n        } else {\n            candidate[idx]++;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:59:33"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_LEN 100\n\nbool is_substring(const char *str, const char *sub) {\n    int len_str = strlen(str);\n    int len_sub = strlen(sub);\n    for (int i = 0; i <= len_str - len_sub; i++) {\n        bool match = true;\n        for (int j = 0; j < len_sub; j++) {\n            if (str[i + j] != sub[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool is_dangerous(char *password, char dangerous[][MAX_LEN], int N) {\n    for (int i = 0; i < N; i++) {\n        if (is_substring(dangerous[i], password)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid generate_password(int length, char *current, int pos, char dangerous[][MAX_LEN], int N, bool *found, char *result) {\n    if (*found) {\n        return;\n    }\n    if (pos == length) {\n        current[pos] = '\\0';\n        if (!is_dangerous(current, dangerous, N)) {\n            strcpy(result, current);\n            *found = true;\n        }\n        return;\n    }\n    for (char c = 'a'; c <= 'z'; c++) {\n        current[pos] = c;\n        generate_password(length, current, pos + 1, dangerous, N, found, result);\n        if (*found) {\n            return;\n        }\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    char dangerous[N][MAX_LEN];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s\", dangerous[i]);\n    }\n\n    char result[MAX_LEN] = \"\";\n    bool found = false;\n    char current[MAX_LEN];\n\n    for (int length = 1; length <= MAX_LEN; length++) {\n        generate_password(length, current, 0, dangerous, N, &found, result);\n        if (found) {\n            break;\n        }\n    }\n\n    printf(\"%s\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:59:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nstring findStrongPassword(const vector<string>& dangerous) {\n    unordered_set<string> forbidden;\n    for (const string& s : dangerous) {\n        for (int i = 0; i < s.size(); ++i) {\n            for (int j = 1; j <= s.size() - i; ++j) {\n                forbidden.insert(s.substr(i, j));\n            }\n        }\n    }\n\n    queue<string> q;\n    for (char c = 'a'; c <= 'z'; ++c) {\n        string s(1, c);\n        if (forbidden.find(s) == forbidden.end()) {\n            return s;\n        }\n        q.push(s);\n    }\n\n    while (!q.empty()) {\n        string current = q.front();\n        q.pop();\n        for (char c = 'a'; c <= 'z'; ++c) {\n            string next = current + c;\n            if (forbidden.find(next) == forbidden.end()) {\n                return next;\n            }\n            q.push(next);\n        }\n    }\n\n    return \"\";\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<string> dangerous(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> dangerous[i];\n    }\n    cout << findStrongPassword(dangerous) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:00:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class StrongPasswordGenerator {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        scanner.nextLine();\n        Set<String> forbiddenSubstrings = new HashSet<>();\n        for (int i = 0; i < N; i++) {\n            String password = scanner.nextLine();\n            for (int j = 0; j < password.length(); j++) {\n                for (int k = j + 1; k <= password.length(); k++) {\n                    forbiddenSubstrings.add(password.substring(j, k));\n                }\n            }\n        }\n\n        String result = findSmallestPassword(forbiddenSubstrings);\n        System.out.println(result);\n    }\n\n    private static String findSmallestPassword(Set<String> forbiddenSubstrings) {\n        Queue<String> queue = new LinkedList<>();\n        for (char c = 'a'; c <= 'z'; c++) {\n            String s = String.valueOf(c);\n            if (!forbiddenSubstrings.contains(s)) {\n                return s;\n            }\n            queue.add(s);\n        }\n\n        while (!queue.isEmpty()) {\n            String current = queue.poll();\n            for (char c = 'a'; c <= 'z'; c++) {\n                String next = current + c;\n                if (!forbiddenSubstrings.contains(next)) {\n                    return next;\n                }\n                queue.add(next);\n            }\n        }\n        return \"\";\n    }\n}",
    "timestamp": "2025-08-05 22:00:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    public static String generateStrongPassword(String[] dangerousPasswords) {\n        Set<String> substringSet = new HashSet<>();\n        \n        // Collect all substrings of dangerous passwords\n        for (String password : dangerousPasswords) {\n            int n = password.length();\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j <= n; j++) {\n                    substringSet.add(password.substring(i, j));\n                }\n            }\n        }\n        \n        // Start from the lexicographically smallest string\n        String candidate = \"a\";\n        \n        // Check if candidate is a valid password\n        while (substringSet.contains(candidate)) {\n            candidate = incrementString(candidate);\n        }\n        \n        return candidate;\n    }\n    \n    private static String incrementString(String s) {\n        char[] chars = s.toCharArray();\n        int n = chars.length;\n        \n        // Try to increment the last character\n        for (int i = n - 1; i >= 0; i--) {\n            if (chars[i] < 'z') {\n                chars[i]++;\n                return new String(chars);\n            }\n            // If last character is 'z', reset to 'a' and carry over\n            chars[i] = 'a';\n        }\n        \n        // If all characters are 'z', add new 'a' at the beginning\n        return \"a\" + new String(chars);\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // Read number of dangerous passwords\n        int N = scanner.nextInt();\n        scanner.nextLine(); // Consume newline\n        \n        // Read dangerous passwords\n        String[] dangerousPasswords = new String[N];\n        for (int i = 0; i < N; i++) {\n            dangerousPasswords[i] = scanner.nextLine();\n        }\n        \n        // Generate and print strong password\n        System.out.println(generateStrongPassword(dangerousPasswords));\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:01:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool isSubstring(const string& password, const string& dangerous) {\n    return dangerous.find(password) != string::npos;\n}\n\nstring findStrongestPassword(const vector<string>& dangerousPasswords) {\n    string candidate = \"a\";\n    \n    while (true) {\n        bool isValid = true;\n        \n        for (const string& dangerous : dangerousPasswords) {\n            if (isSubstring(candidate, dangerous)) {\n                isValid = false;\n                break;\n            }\n        }\n        \n        if (isValid) {\n            return candidate;\n        }\n        \n        // Lexicographically increment the string\n        int n = candidate.length();\n        int i = n - 1;\n        \n        while (i >= 0 && candidate[i] == 'z') {\n            candidate[i] = 'a';\n            i--;\n        }\n        \n        if (i < 0) {\n            candidate += 'a';\n        } else {\n            candidate[i]++;\n        }\n    }\n}\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<string> dangerousPasswords(N);\n    for (int i = 0; i < N; i++) {\n        cin >> dangerousPasswords[i];\n    }\n    \n    string strongPassword = findStrongestPassword(dangerousPasswords);\n    cout << strongPassword << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:01:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_forbidden(pwd, forbidden_substrings):\n    for substring in forbidden_substrings:\n        if pwd in substring:\n            return True\n    return False\n\ndef generate_password(dangerous_passwords):\n    forbidden_substrings = set()\n    for password in dangerous_passwords:\n        length = len(password)\n        for i in range(length):\n            for j in range(i + 1, length + 1):\n                forbidden_substrings.add(password[i:j])\n    \n    from string import ascii_lowercase\n    for l in range(1, 27):  # Check increasing lengths\n        for letters in itertools.product(ascii_lowercase, repeat=l):\n            candidate = ''.join(letters)\n            if not is_forbidden(candidate, forbidden_substrings):\n                return candidate\n\nimport itertools\n\n# Example usage\ndangerous_passwords = ['abc', 'bca', 'cab']\nprint(generate_password(dangerous_passwords))",
    "timestamp": "2025-08-13 08:26:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class StrongPasswordFinder {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        scanner.nextLine(); // consume the remaining newline\n\n        Set<String> forbiddenSubstrings = new HashSet<>();\n        for (int i = 0; i < N; i++) {\n            String dangerousPassword = scanner.nextLine();\n            for (int j = 1; j <= dangerousPassword.length(); j++) {\n                for (int k = 0; k <= dangerousPassword.length() - j; k++) {\n                    forbiddenSubstrings.add(dangerousPassword.substring(k, k + j));\n                }\n            }\n        }\n        \n        char[] alphabet = \"abcdefghijklmnopqrstuvwxyz\".toCharArray();\n        String result = null;\n        \n        for (char c : alphabet) {\n            String candidate = String.valueOf(c);\n            if (!forbiddenSubstrings.contains(candidate)) {\n                result = candidate;\n                break;\n            }\n        }\n        \n        if (result == null) {\n            // If no single character works, we need to look for a two-char combination.\n            for (char c1 : alphabet) {\n                for (char c2 : alphabet) {\n                    String candidate = \"\" + c1 + c2;\n                    if (!forbiddenSubstrings.contains(candidate)) {\n                        result = candidate;\n                        break;\n                    }\n                }\n                if (result != null) {\n                    break;\n                }\n            }\n        }\n\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-13 08:26:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n// Function to check if a password is a substring of any dangerous password\nbool isSubstring(const char *password, char dangerousPasswords[][101], int n) {\n    for (int i = 0; i < n; i++) {\n        if (strstr(dangerousPasswords[i], password) != NULL) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// Function to generate the smallest valid password\nvoid generatePassword(char dangerousPasswords[][101], int n) {\n    char password[2];\n    password[1] = '\\0'; // Set the end of string\n\n    for (char c = 'a'; c <= 'z'; c++) {\n        password[0] = c;\n        if (!isSubstring(password, dangerousPasswords, n)) {\n            printf(\"%s\\n\", password);\n            return;\n        }\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char dangerousPasswords[n][101];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", dangerousPasswords[i]);\n    }\n\n    generatePassword(dangerousPasswords, n);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 08:26:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_strongest_password(dangerous_passwords):\n    # Find the length of the shortest dangerous password\n    max_length = max(len(password) for password in dangerous_passwords)\n    \n    # Create a set of all substrings from dangerous passwords\n    dangerous_substrings = set()\n    for password in dangerous_passwords:\n        for i in range(len(password)):\n            for j in range(i + 1, len(password) + 1):\n                dangerous_substrings.add(password[i:j])\n    \n    # Find the lexicographically smallest password\n    for length in range(1, max_length + 2):\n        for password in generate_passwords(length):\n            if all(password not in substring for substring in dangerous_substrings):\n                return password\n    \ndef generate_passwords(length):\n    # Generate passwords lexicographically\n    from itertools import product\n    return (''.join(chars) for chars in product('abcdefghijklmnopqrstuvwxyz', repeat=length))\n\n# Example usage\ndef main():\n    N = int(input())\n    dangerous_passwords = [input().strip() for _ in range(N)]\n    result = find_strongest_password(dangerous_passwords)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 08:26:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    N = int(sys.stdin.readline())\n    dangerous = [sys.stdin.readline().strip() for _ in range(N)]\n    \n    # Collect all possible substrings of all dangerous passwords\n    forbidden = set()\n    for s in dangerous:\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                forbidden.add(s[i:j])\n    \n    # BFS to find the shortest password not in forbidden\n    queue = deque()\n    # Start with the smallest character\n    for c in 'abcdefghijklmnopqrstuvwxyz':\n        queue.append(c)\n    \n    visited = set()\n    \n    while queue:\n        current = queue.popleft()\n        if current not in forbidden:\n            print(current)\n            return\n        # Generate next candidates by appending each letter\n        for c in 'abcdefghijklmnopqrstuvwxyz':\n            next_str = current + c\n            if next_str not in visited:\n                visited.add(next_str)\n                queue.append(next_str)\n    \n    # This line is theoretically unreachable because there are infinite possible strings\n    print(\"\")\n\nsolve()",
    "timestamp": "2025-08-13 08:26:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n\nstd::string findStrongPassword(const std::vector<std::string>& dangerousPasswords) {\n    std::set<std::string> forbiddenSubstrings;\n    \n    for (const auto& password : dangerousPasswords) {\n        int len = password.size();\n        for (int i = 0; i < len; ++i) {\n            for (int j = i + 1; j <= len; ++j) {\n                forbiddenSubstrings.insert(password.substr(i, j - i));\n            }\n        }\n    }\n\n    std::string alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    for (char c : alphabet) {\n        std::string candidate(1, c);\n        if (forbiddenSubstrings.find(candidate) == forbiddenSubstrings.end()) {\n            return candidate;\n        }\n    }\n    \n    return \"\";\n}\n\nint main() {\n    int N;\n    std::cin >> N;\n    std::vector<std::string> dangerousPasswords(N);\n    for (int i = 0; i < N; ++i) {\n        std::cin >> dangerousPasswords[i];\n    }\n    \n    std::string strongPassword = findStrongPassword(dangerousPasswords);\n    std::cout << strongPassword << std::endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:45:51"
  }
]