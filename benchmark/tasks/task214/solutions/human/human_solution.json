[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n#define isUruu(y) ((y % 4 || (y % 100 == 0 && y % 400)) ? false : true)\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef unsigned int uint;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<char> Vc;\ntypedef vector<Vc> VVc;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nconst int INF = 1 << 28;\nconst double EPS = 1e-9;\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {1,0,-1,0};\n\nint w, h;\nint ans;\n\nvoid dfs (VVc &field, vector<P> &pp, int sx, int sy, uint b, int sum)\n{\n    if (b == ((1 << pp.size()) - 1)) {\n        if (ans > sum) ans = sum;\n        return ;\n    }\n    if (sum > ans) return ;\n    rep (j, pp.size()) {\n        if (b & (1 << j)) continue;\n        queue<P> q;\n        q.push(P(sx,sy));\n        VV d(h, V(w, INF));\n        d[sx][sy] = 0;\n        int count = 0;\n        while (q.size()) {\n            P p = q.front(); q.pop();\n            int x = p.first, y = p.second;\n            if (x == pp[j].first && y == pp[j].second) {\n                count = d[x][y];\n                break;\n            }\n            \n            rep (i,4) {\n                int nx = x + dx[i], ny = y + dy[i];\n                if (0 <= nx && nx < h && 0 <= ny && ny < w && d[nx][ny] == INF && field[nx][ny] != 'x') {\n                    d[nx][ny] = d[x][y] + 1;\n                    q.push(P(nx,ny));\n                }\n            }\n        }\n        if (count == 0) return ;\n        dfs(field, pp, pp[j].first, pp[j].second, b | (1 << j), sum + count);\n    }\n    \n    return ;\n}\n\nint main()\n{\n    while (cin >> w >> h, h + w) {\n        VVc field(h, Vc(w));\n        vector<P> p;\n        int sx,sy;\n        rep (i,h) rep (j,w) {\n            cin >> field[i][j];\n            if (field[i][j] == 'o') sx = i, sy = j;\n            else if (field[i][j] == '*') p.push_back(P(i,j)); \n        }\n\n        ans = INF;\n        dfs(field, p, sx, sy, 0, 0);\n        \n        cout << (ans == INF ? -1 : ans) << endl;\n    }\n                \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<map>\n#include<cstring>\n#include<iostream>\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint fie[21][21];\nint dp[21][21][1<<10];\nint w,h;\nint rx,ry;\nint sx[4]={1,0,-1,0};\nint sy[4]={0,1,0,-1};\nint dcnt;\n\nint bfs(){\n\tqueue<PP> que;\n\tmemset(dp,-1,sizeof(dp));\n\tdp[rx][ry][0]=0;\n\tque.push(PP(0,P(rx,ry)));\n\twhile(que.size()){\n\t\tPP q=que.front();\n\t\tque.pop();\n\t\tint x=q.second.first,y=q.second.second,bit=q.first;\n\t\tif(bit==(1<<dcnt)-1)return dp[x][y][bit];\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=x+sx[i],ny=y+sy[i];\n\t\t\tif(nx>=0 && nx<w && ny>=0 && ny<h){\n\t\t\t\tif(fie[nx][ny]==0 && dp[nx][ny][bit]==-1){\n\t\t\t\t\tdp[nx][ny][bit]=dp[x][y][bit]+1;\n\t\t\t\t\tque.push(PP(bit,P(nx,ny)));\n\t\t\t\t}\n\t\t\t\tif(fie[nx][ny]>0){\n\t\t\t\t\tint nbit=bit|(1<<(fie[nx][ny]-1));\n\t\t\t\t\tif(dp[nx][ny][nbit]==-1){\n\t\t\t\t\t\tdp[nx][ny][nbit]=dp[x][y][bit]+1;\n\t\t\t\t\t\tque.push(PP(nbit,P(nx,ny)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w+h==0)break;\n\t\tdcnt=0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(str[j]=='o'){\n\t\t\t\t\tfie[j][i]=0;\n\t\t\t\t\trx=j,ry=i;\n\t\t\t\t}\n\t\t\t\tif(str[j]=='.'){\n\t\t\t\t\tfie[j][i]=0;\n\t\t\t\t}\n\t\t\t\tif(str[j]=='*'){\n\t\t\t\t\tdcnt++;\n\t\t\t\t\tfie[j][i]=dcnt;\n\t\t\t\t}\n\t\t\t\tif(str[j]=='x'){\n\t\t\t\t\tfie[j][i]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",bfs());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\nstruct State{\n    int y, x, c, bit, n;\n    State(int y, int x, int c, int bit, int n) : y(y), x(x), c(c), bit(bit), n(n) {}\n};\n\nbool memo[22][22][(1<<11)];\n\nint main(){\n    while(true){\n        int w, h;\n        cin >> w >> h;\n        if(w == 0) break;\n\n        vector<string> field(h);\n        int N = 0, sy = -1, sx = -1;\n        for(int i=0;i<h;i++){\n            cin >> field[i];\n            for(int j=0;j<w;j++){\n                if(field[i][j] == 'o'){\n                    sy = i;\n                    sx = j;\n                }else if(field[i][j] == '*'){\n                    field[i][j] = '0' + N;\n                    N++;\n                }\n            }\n        }\n\n        const int dd[] = {0, 1, 0, -1, 0};\n        queue<State> que;\n        que.emplace(sy, sx, 0, 0, 0);\n        memset(memo, 0, sizeof(memo));\n\n        while(que.size()){\n            State s = que.front();\n            if(s.n == N) break;\n            que.pop();\n\n            for(int k=0;k<4;k++){\n                int ny = s.y + dd[k], nx = s.x + dd[k+1];\n                if(ny < 0 || h <= ny || nx < 0 || w <= nx || field[ny][nx] == 'x') continue;\n                int nbit = s.bit, nn = s.n;\n                if('0' <= field[ny][nx] && field[ny][nx] <= '9'){\n                    if((s.bit&(1 << (field[ny][nx] - '0'))) == 0) nn++;\n                    nbit |= 1 << (field[ny][nx] - '0');\n                }\n                if(!memo[ny][nx][nbit]){\n                    memo[ny][nx][nbit] = true;\n                    que.emplace(ny, nx, s.c + 1, nbit, nn);\n                }\n            }\n        }\n\n        if(que.size() > 0) cout << que.front().c << endl;\n        else cout << -1 << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct status {\n    int x, y;\n    int dist;\n\n    status() {}\n    ~status() {}\n\n    status(int a, int b): x(a), y(b) {}\n    status(int a, int b, int c): x(a), y(b), dist(c) {}\n};\n\nstruct point {\n    int x, y;\n\n    point() {}\n    ~point() {}\n\n    point(int a, int b): x(a), y(b) {}\n    point(status s): x(s.x), y(s.y) {}\n\n    bool operator < (const point& o) const {\n        return x == o.x ? y < o.y : x < o.x;\n    }\n};\n\nconst int INF = 1 << 29;\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nint bit_count(int x) {\n    int ret = 0;\n    while(x > 0) {\n        ret += x % 2;\n        x >>= 1;\n    }\n    return ret;\n}\n\nbool solve() {\n    int w; // 1 <= w <= 20\n    int h; // 1 <= h <= 20\n    cin >> w >> h;\n\n    if (w == 0 && h == 0) {\n        return false;\n    }\n\n    vector<string> c(h);\n    \n    for (int j = 0; j < h; ++j) {\n        cin >> c[j];\n    }\n\n    map<point, int> ind;\n    int N = 1;\n\n    for (int j = 0; j < h; ++j) {\n        for (int k = 0; k < w; ++k) {\n            if (c[j][k] == '*') {\n                ind[point(j, k)] = N++;\n            }\n            if (c[j][k] == 'o') {\n                ind[point(j, k)] = 0;\n            }\n        }\n    }\n\n    vector<vector<int>> g(N, vector<int>(N, INF));\n    for (int j = 0; j < N; ++j) {\n        g[j][j] = 0;\n    }\n\n    for (auto& pp : ind) {\n        vector<vector<int>> dist(h, vector<int>(w, INF));\n        queue<status> que;\n\n        point start = pp.first;\n        int num = pp.second;\n\n        que.push(status(start.x, start.y, 0));\n        dist[start.x][start.y] = 0;\n\n        while (!que.empty()) {\n            status st = que.front(); que.pop();\n            \n            if (dist[st.x][st.y] < st.dist) {\n                continue;\n            }\n\n            if (c[st.x][st.y] == '*' || c[st.x][st.y] == 'o') {\n                g[num][ind[point(st)]] = st.dist;\n                g[ind[point(st)]][num] = st.dist;\n            }\n\n            for (int j = 0; j < 4; ++j) {\n                int nx = st.x + dx[j];\n                int ny = st.y + dy[j];\n                \n                if (nx < 0 || h <= nx) continue;\n                if (ny < 0 || w <= ny) continue;\n                if (c[nx][ny] == 'x') continue;\n\n                if (dist[nx][ny] > st.dist + 1) {\n                    dist[nx][ny] = st.dist + 1;\n                    \n                    que.push(status(nx, ny, dist[nx][ny]));\n                }\n            }\n        }\n    }\n\n    // for (int j = 0; j < N; ++j) {\n    //     for (int k = 0; k < N ; ++k) {\n    //         cout << g[j][k] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n\n    vector<vector<int>> dp(1 << N, vector<int>(N, INF));\n    dp[1][0] = 0;\n\n    for (int b = 1; b < N; ++b) {\n        for (int j = 0; j < (1 << N); ++j) {\n            if(bit_count(j) != b) continue;\n\n            for (int k = 0; k < N; ++k) {\n                if ((j & (1 << k)) == 0) {\n                    int nj = j | (1 << k);\n\n                    for (int l = 0; l < N; ++l) {\n                        dp[nj][k] = min(dp[nj][k], dp[j][l] + g[k][l]);\n                    }\n                }\n            }\n        }\n    }\n\n    int ret = INF;\n    for (int j = 0; j < N; ++j) {\n        ret = min(ret, dp[(1 << N) - 1][j]);\n    }\n\n    // for (int j = 0; j < (1 << N); ++j) {\n    //     for (int k = 0; k < N; ++k) {\n    //         cout << dp[j][k] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n\n    if (ret == INF) {\n        cout << \"-1\" << endl;\n    } else {\n        cout << ret << endl;\n    }\n\n    return true;\n}\n\n\nint main () {\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint W,H,index[20][20],dp[10][1024],fin_state,from_start[10],min_distance[10][10];\nchar table[20][21];\n\nstruct Info{\n\tInfo(){\n\t\trow = 0;\n\t\tcol = 0;\n\t\tstate = 0;\n\t\tcost = 0;\n\t}\n\n\tInfo(int arg_row,int arg_col,int arg_state,int arg_cost){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tstate = arg_state;\n\t\tcost = arg_cost;\n\t}\n\tint row,col,state,cost;\n};\n\nInfo start,Target[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0},target_count,next_state;\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nbool enable_check(int start_row,int start_col){\n\tbool visited[20][20];\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++)visited[i][k] = false;\n\t}\n\n\tqueue<Info> S;\n\tvisited[start_row][start_col] = true;\n\n\tS.push(Info(start_row,start_col,0,0));\n\n\tint to_row,to_col;\n\n\twhile(!S.empty()){\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tto_row = S.front().row + diff_row[i];\n\t\t\tto_col = S.front().col + diff_col[i];\n\n\t\t\tif(rangeCheck(to_row,to_col) == false || visited[to_row][to_col] == true || table[to_row][to_col] == 'x')continue;\n\n\t\t\tvisited[to_row][to_col] = true;\n\t\t\tS.push(Info(to_row,to_col,0,0));\n\t\t}\n\n\t\tS.pop();\n\t}\n\n\tfor(int i = 0; i < target_count; i++){\n\t\tif(visited[Target[i].row][Target[i].col] == false)return false;\n\t}\n\n\treturn true;\n}\n\nint calc_distance(Info calc_start,Info calc_goal){\n\tint ret = BIG_NUM,calc_map[20][20],calc_row,calc_col;\n\n\tqueue<Info> S;\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++)calc_map[i][k] = BIG_NUM;\n\t}\n\n\tInfo first;\n\tfirst.row = calc_start.row;\n\tfirst.col = calc_start.col;\n\tfirst.cost = 0;\n\n\tcalc_map[first.row][first.col] = 0;\n\n\tS.push(first);\n\n\twhile(!S.empty()){\n\n\t\tif(S.front().row == calc_goal.row && S.front().col == calc_goal.col){\n\t\t\tret = S.front().cost;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(S.front().cost != calc_map[S.front().row][S.front().col]){\n\t\t\tS.pop();\n\t\t\tcontinue;\n\t\t}else{\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tcalc_row = S.front().row + diff_row[i];\n\t\t\t\t\tcalc_col = S.front().col + diff_col[i];\n\n\t\t\t\t\tif(rangeCheck(calc_row,calc_col) == false || table[calc_row][calc_col] == 'x' ||\n\t\t\t\t\t\tcalc_map[calc_row][calc_col] <= S.front().cost+1)continue;\n\n\t\t\t\t\tcalc_map[calc_row][calc_col] = S.front().cost+1;\n\t\t\t\t\tS.push(Info(calc_row,calc_col,0,calc_map[calc_row][calc_col]));\n\t\t\t}\n\t\t\tS.pop();\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main(){\n\n\tint ans,tmp,limit;\n\tint POW[14] = {1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192};\n\tqueue<Info> Q;\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\ttarget_count = 0;\n\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tscanf(\"%s\",table[i]);\n\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\tswitch(table[i][k]){\n\t\t\t\tcase '.':\n\t\t\t\t\t//Do nothing\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\tindex[i][k] = target_count;\n\t\t\t\t\tTarget[target_count].row = i;\n\t\t\t\t\tTarget[target_count].col = k;\n\t\t\t\t\ttarget_count++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'x':\n\t\t\t\t\t//Do nothing\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'o':\n\t\t\t\t\tstart.row = i;\n\t\t\t\t\tstart.col = k;\n\t\t\t\t\tstart.state = 0;\n\t\t\t\t\tstart.cost = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!enable_check(start.row,start.col)){\n\t\t\tprintf(\"-1\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i = 0; i < target_count; i++){\n\t\t\tfrom_start[i] = calc_distance(start,Target[i]);\n\t\t}\n\n\t\tfor(int i = 0; i < target_count-1; i++){\n\t\t\tfor(int k = i+1; k < target_count;k++){\n\t\t\t\tif(i == k)continue;\n\t\t\t\ttmp = calc_distance(Target[i],Target[k]);\n\t\t\t\tmin_distance[i][k] = tmp;\n\t\t\t\tmin_distance[k][i] = tmp;\n\t\t\t}\n\t\t}\n\n\t\tlimit = POW[target_count];\n\n\t\tfor(int i = 0; i < target_count;i++){\n\t\t\tfor(int k = 0; k < limit;k++){\n\t\t\t\tdp[i][k] = BIG_NUM;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < target_count; i++){\n\t\t\ttmp = POW[i];\n\t\t\tdp[i][tmp] = from_start[i];\n\t\t}\n\n\n\n\t\tfor(int state = 0; state < limit; state++){\n\t\t\tfor(int k = 0; k < target_count; k++){\n\t\t\t\tif(dp[k][state] == BIG_NUM)continue;\n\t\t\t\tfor(int a = 0; a < target_count; a++){\n\t\t\t\t\tif(state & (1 << a)){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_state = state+POW[a];\n\t\t\t\t\t\tdp[a][next_state] = min(dp[a][next_state],dp[k][state]+min_distance[k][a]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans = BIG_NUM;\n\t\ttmp = POW[target_count]-1;\n\n\t\tfor(int i = 0; i < target_count; i++){\n\t\t\tans = min(ans,dp[i][tmp]);\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<memory>\n#include<functional>\n\nusing namespace std;\n\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define F(i,j,k) fill(i[0],i[0]+j*j,k)\n#define P(p) cout<<(p)<<endl;\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define INF 1<<25\n#define pb push_back\n\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef vector<double> vd;\ntypedef pair<int,int> pii;\ntypedef pair<long,long> pll;\ntypedef long long ll;\n\nusing namespace std;\n\nstruct robot {\n    int x, y, cost, dust;\n\n    bool operator >(const robot& r) const {\n        return cost > r.cost;\n    }\n};\n\nint main()\n{\n    int w, h;\n    while (cin >> w >> h, w|h) {\n        // input\n        vector<string> v;\n        rep(j, h){\n            string input;\n            cin >> input;\n            v.pb(input);\n        }\n\n        // dust map\n        int dust[20][20];\n        fill_n((int *)dust, 20 * 20, 0);\n        int bit = 1;\n\n        // start & goal\n        int sx, sy;\n        int goal = 0;\n        rep(j, h){\n            rep(i, w){\n                if(v[j][i] == 'o') {\n                    sx = i; sy = j;\n                }\n                if(v[j][i] == '*') {\n                    dust[j][i] = bit;\n                    goal += bit;\n                    bit *= 2;\n                }\n            }\n        }\n\n        // bfs\n        int check[20][20][1<<10];\n        fill_n((int *)check, 20*20*(1<<10), INT_MAX);\n        int cost = -1;\n        priority_queue<robot, vector<robot>, greater<robot> > q;\n        q.push((robot){sx, sy, 0, 0});\n        while(!q.empty()){\n            robot p = q.top(); q.pop();\n            // goal\n            if (p.dust == goal) {\n                cost = p.cost;\n                break;\n            }\n            // up\n            if (p.y - 1 >= 0 && v[p.y-1][p.x] != 'x') {\n                if (v[p.y-1][p.x] == '*' && (p.dust & dust[p.y-1][p.x]) != dust[p.y-1][p.x]) {\n                    if (check[p.y-1][p.x][p.dust + dust[p.y-1][p.x]] > p.cost + 1) {\n                        q.push((robot){p.x, p.y-1, p.cost+1, p.dust + dust[p.y-1][p.x]});\n                        check[p.y-1][p.x][p.dust + dust[p.y-1][p.x]] = p.cost + 1;\n                    }\n                } else {\n                    if (check[p.y-1][p.x][p.dust] > p.cost + 1) {\n                        q.push((robot){p.x, p.y-1, p.cost+1, p.dust});\n                        check[p.y-1][p.x][p.dust] = p.cost + 1;\n                    }\n                }\n            }\n            // down\n            if (p.y + 1 < h && v[p.y+1][p.x] != 'x') {\n                if (v[p.y+1][p.x] == '*' && (p.dust & dust[p.y+1][p.x]) != dust[p.y+1][p.x]) {\n                    if (check[p.y+1][p.x][p.dust + dust[p.y+1][p.x]] > p.cost + 1) {\n                        q.push((robot){p.x, p.y+1, p.cost+1, p.dust + dust[p.y+1][p.x]});\n                        check[p.y+1][p.x][p.dust + dust[p.y+1][p.x]] = p.cost + 1;\n                    }\n                } else {\n                    if (check[p.y+1][p.x][p.dust] > p.cost + 1) {\n                        q.push((robot){p.x, p.y+1, p.cost+1, p.dust});\n                        check[p.y+1][p.x][p.dust] = p.cost + 1;\n                    }\n                }\n            }\n            // right\n            if (p.x + 1 < w && v[p.y][p.x+1] != 'x') {\n                if (v[p.y][p.x+1] == '*' && (p.dust & dust[p.y][p.x+1]) != dust[p.y][p.x+1]) {\n                    if (check[p.y][p.x+1][p.dust + dust[p.y][p.x+1]] > p.cost + 1) {\n                        q.push((robot){p.x+1, p.y, p.cost+1, p.dust + dust[p.y][p.x+1]});\n                        check[p.y][p.x+1][p.dust + dust[p.y][p.x+1]] = p.cost + 1;\n                    }\n                } else {\n                    if (check[p.y][p.x+1][p.dust] > p.cost + 1) {\n                        q.push((robot){p.x+1, p.y, p.cost+1, p.dust});\n                        check[p.y][p.x+1][p.dust] = p.cost + 1;\n                    }\n                }\n            }\n            // left\n            if (p.x - 1 >= 0 && v[p.y][p.x-1] != 'x') {\n                if (v[p.y][p.x-1] == '*' && (p.dust & dust[p.y][p.x-1]) != dust[p.y][p.x-1]) {\n                    if (check[p.y][p.x-1][p.dust + dust[p.y][p.x-1]] > p.cost + 1) {\n                        q.push((robot){p.x-1, p.y, p.cost+1, p.dust + dust[p.y][p.x-1]});\n                        check[p.y][p.x-1][p.dust + dust[p.y][p.x-1]] = p.cost + 1;\n                    }\n                } else {\n                    if (check[p.y][p.x-1][p.dust] > p.cost + 1) {\n                        q.push((robot){p.x-1, p.y, p.cost+1, p.dust});\n                        check[p.y][p.x-1][p.dust] = p.cost + 1;\n                    }\n                }\n            }\n        }\n        cout << cost << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-11;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\twhile(1){\n\t\tint w,h;\n\t\tcin>>w>>h;\n\t\tif(h==0) break;\n\t\tvs a(h);\n\t\tfor(auto &i:a) cin>>i;\n\t\tvi x(100,-1),y(100,-1);\n\t\tint id=1;\n\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++){\n\t\t\tif(a[i][j]=='o') x[0]=i,y[0]=j;\n\t\t\tif(a[i][j]=='*'){\n\t\t\t\tx[id]=i,y[id]=j;\n\t\t\t\tid++;\n\t\t\t}\n\t\t}\n\t\tvvi g(id,vi(id));\n\t\tfor(int i=0;i<id;i++){\n\t\t\tqueue<pip> q;\n\t\t\tq.push({0,{x[i],y[i]}});\n\t\t\tvvi b(h,vi(w,inf));\n\t\t\tb[x[i]][y[i]]=0;\n\t\t\twhile(!q.empty()){\n\t\t\t\tpip p=q.front();q.pop();\n\t\t\t\tint sx=p.second.first,sy=p.second.second;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint cx=sx+dx[k],cy=sy+dy[k];\n\t\t\t\t\tif(cx>=0&&cx<h&&cy>=0&&cy<w&&a[cx][cy]!='x'&&b[cx][cy]==inf){\n\t\t\t\t\t\tb[cx][cy]=p.first+1;\n\t\t\t\t\t\tq.push({p.first+1,{cx,cy}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<id;j++) g[i][j]=b[x[j]][y[j]];\n\t\t}\n\t\tint n=id;\n\t\tvvi dp(1<<n,vi(n,inf));\n\t\tdp[0][0]=0;\n\t\tfor(int i=0;i<1<<n;i++) for(int j=0;j<n;j++) if(dp[i][j]<inf){\n\t\t\tfor(int k=0;k<n;k++) if(!(i&1<<k)){\n\t\t\t\tdp[i+(1<<k)][k]=min(dp[i+(1<<k)][k],dp[i][j]+g[j][k]);\n\t\t\t}\n\t\t}\n\t\tint res=inf;\n\t\tfor(int i=1;i<n;i++) res=min(res,dp.back()[i]);\n\t\tif(res==inf) res=-1;\n\t\tcout<<res<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <queue>\n#include <string>\n#include <numeric>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\nint const inf = 1 << 29;\ntypedef int Weight;\nstruct Edge{\n    Edge(int src, int dst, int cost)\n        :src(src), dst(dst), cost(cost){}\n    int src, dst, cost;\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nint W, H;\n\nint dx[] = { 1, 0, -1, 0 };\nint dy[] = { 0, 1, 0, -1 };\n\n// テ」ツ?づ」ツつ甘ヲツ慊ャテ」ツ?ョテ」ツδ?」ツつ、テ」ツつッテ」ツつケテ」ツδ暗」ツδゥテヲツウツ陛」ツつ担pagetti Sourceテ」ツ?ョAPIテ」ツ?ォテ・ツ青暗」ツつ湘」ツ?崚」ツ?淌」ツつづ」ツ?ョ\nstruct State {\n    int v, d;\n    State(int v, int d) : v(v), d(d){}\n    bool operator<(const State& s)const{\n        return d>s.d;\n    }\n};\n\nvoid dijkstra(Graph const &g, int s, vector<Weight> &dist) {\n    priority_queue<State> q;\n    dist.assign(g.size(), inf); dist[s] = 0;\n    q.push(State(s, 0));\n    while (q.size()) {\n        State s = q.top(); q.pop();\n        int v = s.v;\n        if (dist[v] < s.d) continue;\n        rep(i, g[v].size()){\n            const Edge &e = g[v][i];\n            if (dist[e.dst] > dist[v] + e.cost) {\n                dist[e.dst] = dist[v] + e.cost;\n                q.push(State(e.dst, dist[e.dst]));\n            }\n        }\n    }\n}\n\n\ninline bool valid(int x, int y){\n    return 0 <= x && x < W && 0 <= y && y < H;\n}\n\nint solve(vector<string> grid){\n    Graph g(W*H);\n    vector<int> dust;\n    int s;\n    rep(y, H)rep(x, W){\n        rep(i, 4){\n            int tx = x + dx[i];\n            int ty = y + dy[i];\n            if (!valid(tx, ty)) continue;\n            if (grid[ty][tx] == 'x') continue;\n            int src = y*H + x;\n            int dst = ty*H + tx;\n            g[src].push_back(Edge(src, dst, 1));\n        }\n    }\n\n    rep(i, H)rep(j, W){\n        if (grid[i][j] == '*'){\n            dust.push_back(i*H + j);\n        }\n        if (grid[i][j] == 'o'){\n            s = i*H + j;\n        }\n    }\n    dust.push_back(s);\n    int V = dust.size();\n\n    vector<vector<int>> d(V, vector<int>(V, inf));\n\n    rep(i, V){\n        dijkstra(g, dust[i], d[i]);\n    }\n    \n    int idx[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 };\n    int ans = inf;\n    do{\n        long long res = 0;\n        rep(i, V){\n            res += d[idx[i]][idx[i + 1]];\n        }\n        if (res >= inf) continue;\n        ans = min<long long>(ans, res);\n    } while (next_permutation(idx, idx + V - 1));\n    if (ans == inf)ans = -1;\n    return ans;\n}\n\nint main(){\n    while (cin >> W >> H && W | H){\n        vector<string> grid(H);\n        rep(i, H){\n            cin >> grid[i];\n        }\n        cout << solve(grid) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct Point {\n  int x, y;\n  Point(int x, int y) : x(x), y(y) {;}\n};\n\ntypedef pair<int, Point> State;\n\nint W, H, C, INF = (1 << 22);\nvector<Point> pos;\nchar field[20][20];\nint  dist[11][11];\nint dx[4] = {0, 1, 0, -1},\n    dy[4] = {-1, 0, 1, 0};\nint dp[1 << 11][11];\n\nvoid bfs(int src)\n{\n  int d[20][20];\n  for (int i = 0; i < H; i++)\n    for (int j = 0; j < W; j++)\n      d[i][j] = INF;\n\n  Point start = pos[src];\n\n  queue<State> que;\n  que.push(State(0, start));\n\n  while (!que.empty()) {\n    State s = que.front(); que.pop();\n    Point p = s.second;\n    if (d[p.y][p.x] != INF) continue;\n\n    d[p.y][p.x] = s.first; \n    for (int k = 0; k < 4; k++) {\n      int nx = p.x + dx[k], ny = p.y + dy[k];\n      if (nx >= 0 && nx < W && ny >= 0 && ny < H && field[ny][nx] != 'x') {\n        que.push(State(s.first + 1, Point(nx, ny)));\n      }\n    }\n  }\n\n  for (int dst = 0; dst < C; dst++) \n    if (dst != src) \n      dist[src][dst] = d[pos[dst].y][pos[dst].x];\n}\n\nint rec(int S, int v)\n{\n  // 訪問済み\n  if (dp[S][v] >= 0) \n    return dp[S][v];\n\n  // すべての頂点を訪れて戻ってきた\n  if (S == (1 << C) - 1) {\n    return dp[S][v] = 0;\n  }\n\n  int res = INF;\n  for (int u = 0; u < C; u++) {\n    if (!(S >> u & 1)) {\n      // uが未訪問なので、uへ移動\n      res = min(res, rec(S | 1 << u, u) + dist[v][u]);\n    }\n  }\n\n  return dp[S][v] = res;\n}\n\nvoid solve()\n{\n  \n  // 距離テーブルの初期化\n  for (int i = 0; i < C; i++) \n    for (int j = 0; j < C; j++) \n      if (i == j) \n        dist[i][j] = 0;\n      else \n        dist[i][j] = INF;\n\n  // 全点間の距離を求める\n  for (int src = 0; src < C; src++) \n    bfs(src);\n\n  // TSP\n  memset(dp, -1, sizeof(dp));\n  int res = rec(0, 0);\n  if (res >= INF) \n    cout << -1 << endl;\n  else\n    cout << res << endl;\n}\n\nint main()\n{\n  while (cin >> W >> H && (W && H)) {\n\n    // スタート+汚れたタイルの数\n    C = 1;\n    pos.clear();\n    pos.push_back(Point(-1, -1));\n    // read\n    for (int i = 0; i < H; i++) {\n      for (int j = 0; j < W; j++) {\n        cin >> field[i][j];\n        if (field[i][j] == '*') {\n          pos.push_back(Point(j, i));\n          C++;\n        } else if (field[i][j] == 'o') {\n          pos[0].x = j;\n          pos[0].y = i;\n        }\n      }\n    }\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cassert>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int MAX = 21;\nconst int TM = 11;\nconst int INF = (1<<25);\n\nchar F[MAX][MAX];\nint T[(1<<TM)][MAX][MAX];\nint w,h,sx,sy;\nvector<P> Trash;\n\n\nstruct State{\n  int x,y,t,come;\n  \n  State(){}\n  State(int x, int y, int t, int c):x(x),y(y),t(t),come(c){}\n  bool operator < (const State& s) const { return t > s.t;}\n\n};\n\nbool isInside(int x, int y){ return 0<=x&&x<w&&0<=y&&y<h;}\n\nvoid init(){\n  \n  fill(T[0][0],T[0][0]+TM*MAX*MAX,INF);\n  Trash.clear();\n\n}\n\nvoid input(){\n  for(int i = 0; i < h; i++)\n    for(int j = 0; j < w; j++){\n      cin >> F[i][j];\n      if(F[i][j] == 'o'){\n\tsx = j;\n\tsy = i;\n      }\n      if(F[i][j] == '*') Trash.push_back(P(j,i));\n\n    }\n}\n\nint getTrashNum(P p){\n  for(int i = 0; i < Trash.size(); i++)\n    if(Trash[i] == p) return i;\n  \n  cerr << \"not found\" << endl;\n  return -1;\n}\nvoid solve(){\n\n  priority_queue<State> Q;\n  Q.push(State(sx,sy,0,0));\n  T[0][sy][sx] = 0;\n\n  int dx[] = {0,0,1,-1};\n  int dy[] = {1,-1,0,0};\n\n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n\n    if(T[now.come][now.y][now.x] < now.t) continue;\n    \n    for(int i = 0; i < 4; i++){\n      State nex = now;\n      nex.x += dx[i];\n      nex.y += dy[i];\n      nex.t++;\n\n      if(!isInside(nex.x,nex.y)) continue;\n      if(F[nex.y][nex.x] == 'x') continue;\n\n\n      if(F[nex.y][nex.x] == '*'){\n\tint Tnum = getTrashNum(P(nex.x, nex.y));\n\tnex.come = (nex.come|(1<<Tnum));\n      }\n\n      \n      if(T[nex.come][nex.y][nex.x] > nex.t){\n\tT[nex.come][nex.y][nex.x] = nex.t;\n\tQ.push(nex);\n      }\n    }\n  }\n\n  int ans = INF;\n\n  if(Trash.size() == 0) ans = 0;\n\n   for(int i = 0; i < Trash.size(); i++)\n     ans = min(ans,T[(1<<Trash.size())-1][Trash[i].second][Trash[i].first]);\n\n\n  if(ans == INF) cout << \"-1\" << endl;\n  else cout << ans << endl;\n \n}\n  \nint main(){\n\n  while(cin >> w >> h && w+h){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<cctype>\nusing namespace std;\n#define fr first\n#define sc second\ntypedef pair<int,int> Pt;\ntypedef pair<Pt ,int> P;\nPt ST,GL;\nint h,w,c,used[20][20][1 << 10],d[]={0,1,0,-1};\nchar mas[20][20];\nint bfs();\nint main(){\n  while(cin >> w >> h && w){\n    c = 0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> mas[i][j];\n        if(mas[i][j] == 'o') ST = Pt(i,j);\n        else if(mas[i][j] == '*') mas[i][j] = c++;\n      }\n    }\n    cout << bfs() << endl;\n  }\n}\nint bfs(){\n  memset(used,-1,sizeof(used));\n  queue<P> que;\n  que.push(P(ST,0));\n  used[ST.fr][ST.sc][0] = 0;\n  while(!que.empty()){\n    P p = que.front();\n    que.pop();\n    if(p.sc==(1<<c)-1) return used[p.fr.fr][p.fr.sc][p.sc];\n    int log = used[p.fr.fr][p.fr.sc][p.sc];\n    for(int i=0;i<4;i++){\n      int nx = d[i] + p.fr.fr,ny = d[3-i] + p.fr.sc;\n      int bits = p.sc;\n      if(nx>=0&&nx<h&&ny>=0&&ny<w){\n        if(mas[nx][ny] == 'x') continue;\n        if(mas[nx][ny] >= 0 && mas[nx][ny] < 10){\n          bits |= 1<<mas[nx][ny] ;\n        }\n        if(used[nx][ny][bits] != -1) continue;\n        que.push(P(Pt(nx,ny),bits));\n        used[nx][ny][bits] = log + 1;\n      }\n    }\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cassert>\n#include<stdexcept>\n#include<utility>\n#include<functional>\n#include<numeric>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<array>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<complex>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<bitset>\n#include<memory>\nusing namespace std;\nusing ll=long long;\n\nusing Field = vector<string>;\nconst int INF = 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nvoid solve(int h,int w){\n    Field f(h);\n    for(int i=0;i<h;i++) cin>>f[i];\n\n    auto isRange=[&](int i,int j){\n        return 0<=i && i<h && 0<=j && j<w;\n    };\n    auto isMovable=[&](int i,int j){\n        return isRange(i,j) && f[i][j]!='x';\n    };\n    int si=-1,sj=-1;\n    int ndirt = 0;\n    vector<vector<int>> dirt(h,vector<int>(w,-1));\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(f[i][j]=='o') si=i,sj=j;\n            else if(f[i][j]=='*') dirt[i][j] = ndirt++;\n        }\n    }\n    assert(si!=-1 && sj!=-1);\n    vector<vector<vector<int>>> dp(1<<ndirt,vector<vector<int>>(h,vector<int>(w,INF)));\n    struct X{\n        int mask;\n        int i,j;\n    };\n    queue<X> que;\n    auto push=[&](int mask,int i,int j,int score){\n        dp[mask][i][j]=score;\n        que.push({mask,i,j});\n    };\n    push(0,si,sj,0);\n\n    while(!que.empty()){\n        auto tmp = que.front(); que.pop();\n        int i=tmp.i,j = tmp.j,mask = tmp.mask;\n        if(mask==(1<<ndirt)-1){\n            cout<<dp[mask][i][j]<<endl;\n            return;\n        }\n        for(int k=0;k<4;k++){\n            int toi = i+dx[k],toj=j+dy[k];\n            if(isMovable(toi,toj)){\n                int tomask = mask;\n                if(dirt[toi][toj]!=-1){\n                    tomask |= (1<<dirt[toi][toj]);\n                }\n                if(dp[mask][i][j]+1<dp[tomask][toi][toj]){\n                    push(tomask,toi,toj,dp[mask][i][j]+1);\n                }\n            }\n        }\n    }\n    \n    cout<<-1<<endl;\n    return;\n}\nint main(){\n    int w,h;\n    while(cin>>w>>h,!(w==0 && h==0)){\n        solve(h,w);\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <queue>\n#include <cmath>\n#include <tuple>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define all(n)\tn.begin(),n.end()\n#define each(i,n) for(auto &i : n)\n\nconst int INF = 1e9;\n\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\n\nsigned main() {\n\n\tint w, h;\n\twhile (cin >> w >> h && w) {\n\t\ttypedef pair<int, int> p;\n\n\t\tchar d[20][20];\n\t\tp s;\n\t\tint sum = 0;\n\t\trep(y, h)rep(x, w) {\n\t\t\tcin >> d[y][x];\n\t\t\tif (d[y][x] == 'o') {\n\t\t\t\ts.first = y, s.second = x;\n\t\t\t}\n\t\t\tif (d[y][x] == '*') {\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\n\t\tmap<set<p>,int> m[20][20];\n\t\tm[s.first][s.second][set<p>()] = 0;\n\t\ttypedef pair<set<p>, p> sp;\n\t\tqueue<sp> q;\n\t\tq.push(sp(set<p>(), s));\n\t\tint ans = INF;\n\t\twhile (q.size()) {\n\t\t\tp n = q.front().second;\n\t\t\tauto se = q.front().first;\n\t\t\tq.pop();\n\t\t\tint y = n.first;\n\t\t\tint x = n.second;\n\t\t\tauto nse = se;\n\t\t\tif (d[y][x] == '*') {\n\t\t\t\tnse.insert(p(y, x));\n\t\t\t}\n\t\t\tif (nse.size() == sum) {\n\t\t\t\tans = min(ans, m[y][x][se]);\n\t\t\t}\n\t\t\trep(i, 4) {\n\t\t\t\tint ty = y + dy[i];\n\t\t\t\tint tx = x + dx[i];\n\t\t\t\tif (ty >= 0 && tx >= 0 && ty < h && tx < w && d[ty][tx] != 'x') {\n\t\t\t\t\tif (!m[ty][tx].count(nse) || m[ty][tx][nse] > m[y][x][se] + 1) {\n\t\t\t\t\t\tm[ty][tx][nse] = m[y][x][se] + 1;\n\t\t\t\t\t\tq.push(sp(nse, p(ty, tx)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tif (ans == INF)ans = -1;\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <numeric>\n#include <map>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <algorithm>\n#include <memory>\n#include <memory.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<P,P> P2;\nconst int INF = 1 << 30;\nconst double EPS = 1E-9;\n\nint dy[] = {\n\t0, 1, 0, -1\n};\nint dx[] = {\n\t1, 0, -1, 0\n};\nint n;\nint w, h;\nvector<P> ps;\nchar field[30][30];\nint G[11][11];\nint dis[30][30];\nint dp[11][1 << 11];\n\nint main(){\n\twhile(cin >> w >> h && (w || h)){\n\t\tfill(&field[0][0], &field[29][29], 'x');\n\t\tps.clear();\n\t\tint s;\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tif(field[i][j] == 'o'){\n\t\t\t\t\ts = ps.size();\n\t\t\t\t\tps.push_back(P(i,j));\n\t\t\t\t}else if(field[i][j] == '*'){\n\t\t\t\t\tps.push_back(P(i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tn = ps.size();\n\t\tbool ng = false;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfill(&dis[0][0], &dis[29][29], INF);\n\t\t\tint y = ps[i].first;\n\t\t\tint x = ps[i].second;\n\t\t\tdis[y][x] = 0;\n\t\t\tqueue<P> que;\n\t\t\tque.push(ps[i]);\n\t\t\twhile(!que.empty()){\n\t\t\t\tP p = que.front(); que.pop();\n\t\t\t\ty = p.first;\n\t\t\t\tx = p.second;\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tint y2 = y + dy[j];\n\t\t\t\t\tint x2 = x + dx[j];\n\t\t\t\t\tif(field[y2][x2] == 'x') continue;\n\t\t\t\t\tif(dis[y2][x2] > dis[y][x] + 1){\n\t\t\t\t\t\tdis[y2][x2] = dis[y][x] + 1;\n\t\t\t\t\t\tque.push(P(y2, x2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tG[i][j] = dis[ps[j].first][ps[j].second];\n\t\t\t\tif(G[i][j] == INF) ng = true;\n\t\t\t}\n\t\t}\n\t\tif(ng){\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tfill(&dp[0][0], &dp[10][(1 << 11) - 1], INF);\n\t\tdp[s][1 << s] = 0;\n\t\tqueue<P> que;\n\t\tque.push(P(s, 1 << s));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.front(); que.pop();\n\t\t\tint pl = p.first;\n\t\t\tint st = p.second;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(st & ( 1 << i)) continue;\n\t\t\t\tif(dp[i][st | (1 << i)] > dp[pl][st] + G[pl][i]){\n\t\t\t\t\tdp[i][st | (1 << i)] = dp[pl][st] + G[pl][i];\n\t\t\t\t\tque.push(P(i, (st | (1 << i))));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint m = INF;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tm = min(m, dp[i][(1 << n) - 1]);\n\t\t}\n\t\tcout << m << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int w, h; cin >> w >> h&&w;) {\n\t\tstatic char c[21][21];\n\t\tint n = 1;\n\t\tstatic int pi[11], pj[11];\n\t\trep(i, 0, h)rep(j, 0, w) {\n\t\t\tcin >> c[i][j];\n\t\t\tif (c[i][j] == '*') {\n\t\t\t\tpi[n] = i;\n\t\t\t\tpj[n] = j;\n\t\t\t\tn++;\n\t\t\t}\n\t\t\telse if (c[i][j] == 'o')\n\t\t\t\tpi[0] = i, pj[0] = j;\n\t\t}\n\t\tstatic const int di[] = { 1,0,-1,0 };\n\t\tstatic const int dj[] = { 0,1,0,-1 };\n\t\tstatic int d[11][21][21];\n\t\tmemset(d, 0x3f, sizeof(d));\n\t\trep(i, 0, n) {\n\t\t\td[i][pi[i]][pj[i]] = 0;\n\t\t}\n\t\tauto inrange = [&](int i, int j) { return i >= 0 && i < h && j >= 0 && j < w; };\n\t\trep(k, 0, n) {\n\t\t\tusing P = pair<int, int>;\n\t\t\tqueue<P> q;\n\t\t\tq.push(P(pi[k], pj[k]));\n\t\t\tfor (int ci, cj; !q.empty();) {\n\t\t\t\ttie(ci, cj) = q.front(); q.pop();\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint ni = ci + di[i], nj = cj + dj[i];\n\t\t\t\t\tif (!inrange(ni, nj))continue;\n\t\t\t\t\tif (c[ni][nj] == 'x')continue;\n\t\t\t\t\tif (d[k][ni][nj] != INF)continue;\n\t\t\t\t\td[k][ni][nj] = d[k][ci][cj] + 1;\n\t\t\t\t\tq.emplace(ni, nj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstatic int dp[1 << 11][11];\n\t\tmemset(dp, 0x3f, sizeof(dp));\n\t\tdp[1][0] = 0;\n\t\tdump(n);\n\t\tfor (int mask = 0; mask < (1 << n); mask++) {\n\t\t\trep(i, 0, n) {\n\t\t\t\trep(j, 0, n) {\n\t\t\t\t\tif (mask >> j & 1)continue;\n\t\t\t\t\tif (dp[mask][i] == INF || d[i][pi[j]][pj[j]] == INF)continue;\n\t\t\t\t\tdump(mask);\n\t\t\t\t\tchmin(dp[mask | (1 << j)][j], dp[mask][i] + d[i][pi[j]][pj[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(i, 0, n)\n\t\t\tchmin(ans, dp[(1 << n) - 1][i]);\n\t\tcout << (ans == INF ? -1 : ans) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\n\nstruct Point {\n  Point() {\n    x = -1;\n    y = -1;\n  }\n  Point(int px, int py) {\n    x = px;\n    y = py;\n  }\n  int x;\n  int y;\n};\n\nstruct Node {\n  Node() {\n    cost = -1;\n    checked = false;\n  }\n  Point prev;\n  int cost;\n  bool checked;\n};\n\nint SearchOne(const std::vector<std::string>& room, int width, int height, Point sp, Point gp, std::vector<Point>* path) {\n  using namespace std;\n\n  int sx = sp.x, sy = sp.y;\n  int gx = gp.x, gy = gp.y;\n\n  queue<Point> remains;\n  remains.push(Point(sx, sy));\n\n  vector<vector<Node>> nodes(height, vector<Node>(width));\n  nodes[sy][sx].prev = Point(-1, -1);\n  nodes[sy][sx].cost = 0;\n  nodes[sy][sx].checked = true;\n\n  int dx[] = {0, 1, 0, -1};\n  int dy[] = {1, 0, -1, 0};\n  while (!remains.empty()) {\n    Point pt = remains.front(); remains.pop();\n    for (int di = 0; di < 4; ++di) {\n      int destx = pt.x + dx[di];\n      int desty = pt.y + dy[di];\n      if (destx < 0 || destx >= width || desty < 0 || desty >= height) {\n        continue;\n      }\n      if (room[desty][destx] == '.' || room[desty][destx] == '*' || room[desty][destx] == 'o') {\n        int& cost = nodes[desty][destx].cost;\n        const int total_cost = nodes[pt.y][pt.x].cost + 1;\n        if (!nodes[desty][destx].checked || cost > total_cost) {  // update cost\n          cost = total_cost;\n          nodes[desty][destx].prev = Point(pt.x, pt.y);\n        }\n        if (!nodes[desty][destx].checked) {\n          remains.push(Point(destx, desty));\n          nodes[desty][destx].checked = true;\n        }\n      }\n    }\n  }\n\n  // set best path\n  if (nodes[gy][gx].cost != -1) {\n    path->push_back(Point(gx, gy));\n    for (int x = gx, y = gy; !(x == sx && y == sy);) {\n      const int prevx = nodes[y][x].prev.x;\n      const int prevy = nodes[y][x].prev.y;\n      path->push_back(Point(prevx, prevy));\n      x = prevx;\n      y = prevy;\n    }\n    reverse(path->begin(), path->end());\n  }\n\n  return nodes[gy][gx].cost;\n}\n\n// return best number of moves\nint Search(const std::vector<std::string>& room, int width, int height, std::vector<Point>* path) {\n  using namespace std;\n\n  // search start and goals\n  Point start;\n  vector<Point> goals;\n  for (int y = 0; y < height; ++y) {\n    for (int x = 0; x < width; ++x) {\n      if (room[y][x] == 'o') {\n        start.x = x;\n        start.y = y;\n      } else if (room[y][x] == '*') {\n        goals.push_back(Point(x, y));\n      }\n    }\n  }\n\n  int total_cost = 0;\n  while (!goals.empty()) {\n    // search nearest goal\n    int min_cost = -1;\n    vector<Point> min_path;\n    int goal_index = 0;\n    for (int i = 0; i < goals.size(); ++i) {\n      vector<Point> current_path;\n      const int cost = SearchOne(room, width, height, start, goals[i], &current_path);\n      if (cost == -1) {  // cannot reach goal\n        path->clear();\n        return -1;\n      }\n      if (min_cost == -1 || cost < min_cost) {\n        min_cost = cost;\n        min_path = current_path;\n        goal_index = i;\n      }\n    }\n\n    // update total cost and path\n    total_cost += min_cost;\n    auto min_path_begin = (path->empty()) ? min_path.begin()\n                            : (min_path.empty()) ? min_path.begin()\n                            : min_path.begin() + 1;\n    path->insert(path->end(), min_path_begin, min_path.end());\n\n    // prepare for next\n    start = goals[goal_index];\n    goals.erase(goals.begin() + goal_index);\n  }\n\n  return total_cost;\n}\n\n\nint main() {\n  using namespace std;\n\n  /*\n  const int width = 15;\n  const int height = 13;\n  const vector<string> room = {\n    \".......x.......\",\n    \"...o...x....*..\",\n    \".......x.......\",\n    \".......x.......\",\n    \".......x.......\",\n    \"...............\",\n    \"xxxxx.....xxxxx\",\n    \"...............\",\n    \".......x.......\",\n    \".......x.......\",\n    \".......x.......\",\n    \"..*....x....*..\",\n    \".......x.......\"\n  };\n  */\n\n  while (true) {\n    vector<string> room;\n    int width, height;\n    cin >> width >> height; cin.ignore();\n\n    if (width == 0 && height == 0) break;\n\n    for (int i = 0; i < height; ++i) {\n      string line;\n      getline(cin, line);\n      room.push_back(line);\n    }\n\n    vector<Point> path;\n    cout << Search(room, width, height, &path) << endl;\n  }\n\n  /*\n  if (!path.empty()) {\n    for (Point p : path) {\n      cout << \"(\" << p.x << \",\" << p.y << \")\";\n    }\n    cout << endl;\n  }\n  */\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\nconst int MAX_N = 16;\nconst int INF = 100000000;\n\nVVI g;\nVVI dp;\nint n;\n\nint tsp(int visited, int v) {\n  int& res = dp[visited][v];\n  if (res != -1) return res;\n\n  if (visited == (1 << n) - 1) return 0;\n\n  res = INF;\n\n  rep(u, n) {\n    if (visited & (1 << u)) continue;\n    res = min(res,\n      tsp(visited | (1 << u), u) + g[v][u]);\n  }\n  return res;\n}\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\n\nint solve(int w, int h) {\n  vector<string> field(h);\n\n  rep(i, h) cin >> field[i];\n\n  vector<PII> pts;\n  PII start;\n  rep(i, h) rep(j, w) {\n    char c = field[i][j];\n    if (c == 'o') start = PII(j, i);\n    if (c == '*') pts.push_back(PII(j, i));\n  }\n  pts.insert(pts.begin(), start);\n  n = pts.size();\n\n  g  = VVI(n, VI(n, INF));\n  dp = VVI(1 << n, VI(n, -1));\n\n  rep(pi, n) {\n    PII startPt = pts[pi];\n    queue<PII> que;\n    VVI visited(h, VI(w));\n    que.push(startPt);\n\n    for(int d = 0; !que.empty(); d++) {\n      int sz = que.size();\n      rep(qi, sz) {\n        PII pt = que.front();\n        que.pop();\n        int x = pt.first;\n        int y = pt.second;\n        visited[y][x] = true;\n\n        rep(pj, n) {\n          if (pt == pts[pj]) {\n            g[pi][pj] = g[pj][pi] = d;\n            break;\n          }\n        }\n\n        rep(di, 4) {\n          int nx = x + dx[di];\n          int ny = y + dy[di];\n          if (nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n          if (visited[ny][nx]) continue;\n          if (field[ny][nx] == 'x') continue;\n          visited[ny][nx] = true;\n          que.push(PII(nx, ny));\n        }\n      }\n    }\n  }\n\n  int ans = tsp(1, 0);\n  if (ans == INF) ans = -1;\n  return ans;\n}\n\nint main() {\n  int w, h;\n  while(cin >> w >> h, w || h) cout << solve(w, h) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> Pa;\n\nint dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nconst int inf = 99999;\n\nbool bfs(char a[21][21], int w, int h, Pa pa[12], int p, int dis[12][12])\n{\n\tbool f = false;\n\tfor(int k = 0; k < p-1 ; k++){\n\t\tbool vis[21][21];\n\t\tint d[21][21];\n\t\tqueue<Pa> que;\n\t\tPa t;\n\t\tint s = p-k-1;\n\t\t\n\t\tfill(&d[0][0], &d[h][w], 0);\n\t\tfill(&vis[0][0], &vis[h][w], true);\n\t\ta[pa[k].first][pa[k].second] = '.';\n\t\tque.push(pa[k]);\n\t\tvis[t.first][t.second] = false;\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tt = que.front();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tfor(int i = k+1; i < p; i++){\n\t\t\t\tif(pa[i].first == t.first && pa[i].second == t.second){\n\t\t\t\t\tdis[k][i] = dis[i][k] = d[t.first][t.second];\n\t\t\t\t\ts--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s == 0){\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint u = t.second+dx[i], v = t.first+dy[i];\n\t\t\t\tif(0 <= u && u < w && 0 <= v && v < h){\n\t\t\t\t\tif(vis[v][u] && a[v][u] != 'x'){\n\t\t\t\t\t\tque.push(Pa(v, u));\n\t\t\t\t\t\td[v][u] = d[t.first][t.second]+1;\n\t\t\t\t\t\tvis[v][u] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn f;\n}\n\nint shp(int dis[12][12], int p)\n{\n\tint dp[1<<12][12], n = 1<<p;\n\tfill(&dp[0][0], &dp[(1<<12)-1][11], inf);\n\tdp[1<<0][0] = 0;\n\t\n\tfor(int i = 1<<0; i < n; i++){\n\t\tfor(int j = 0; j < p; j++){\n\t\t\tif(i&(1<<j)){\n\t\t\t\tfor(int k = 0; k < p; k++){\n\t\t\t\t\tif(dp[i|(1<<k)][k] > dp[i][j]+dis[j][k]){\n\t\t\t\t\t\tdp[i|(1<<k)][k] = dp[i][j]+dis[j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint t = min_element(dp[n-1], dp[n-1]+p)-dp[n-1];\n\t\n\treturn dp[n-1][t];\n}\n\nint main()\n{\n\tint h, w;\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0){\n\t\t\tbreak;\n\t\t}\n\t\tint p=1, dis[12][12];\n\t\tchar a[21][21];\n\t\tPa pa[12];\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tcin >> a[i];\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(a[i][j] == 'o'){\n\t\t\t\t\tpa[0] = Pa(i, j);\n\t\t\t\t}\n\t\t\t\tif(a[i][j] == '*'){\n\t\t\t\t\tpa[p++] = Pa(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfill(&dis[0][0], &dis[p][p], inf);\t\n\t\tfor(int i = 0; i < p; i++){\n\t\t\tdis[i][i] = 0;\n\t\t}\n\t\tif(p == 1){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif(bfs(a, w, h, pa, p, dis)){\n\t\t\tcout << shp(dis, p) << endl;\n\t\t} else {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <tuple>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nstring table[22];\nint w,h;\nint dist[11][20][20];\nint xs[11];\nint ys[11];\nint cost[11][1<<11];\nvoid exec()\n{\n\tcin >> w >> h;\n\tif(w==0&&h==0)exit(0);\n\tint c=1;\n\tfor(int i=0;i<h;i++){\n\t\tcin >> table[i];\n\t\tfor(int j=0;j<w;j++){\n\t\t\tswitch(table[i][j]){\n\t\t\t\tcase '*':\n\t\t\t\t\txs[c]=i;\n\t\t\t\t\tys[c]=j;\n\t\t\t\t\tc++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'o':\n\t\t\t\t\txs[0]=i;\n\t\t\t\t\tys[0]=j;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfill(dist[0][0],dist[0][0]+11*20*20,10000);\n\tfor(int p=0;p<c;p++){\n\t\tauto ds=dist[p];\n\t\tds[xs[p]][ys[p]]=0;\n\t\tqueue<P> q;\n\t\tq.push(P(xs[p],ys[p]));\n\t\twhile(q.size()){\n\t\t\tint x=q.front().first;\n\t\t\tint y=q.front().second;\n\t\t\tq.pop();\n\t\t\tint d=ds[x][y]+1;\n\t\t\tint dx[]={0,-1,0,1};\n\t\t\tint dy[]={-1,0,1,0};\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint xx=x+dx[i];\n\t\t\t\tint yy=y+dy[i];\n\t\t\t\tif(0<=xx&&xx<h&&0<=yy&&yy<w&&\n\t\t\t\t  table[xx][yy]!='x'&&\n\t\t\t\t  ds[xx][yy]>d){\n\t\t\t\t\tds[xx][yy]=d;\n\t\t\t\t\tq.push(P(xx,yy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfill(cost[0],cost[0]+11*(1<<11),10000);\n\tcost[0][1]=0;\n\tfor(int i=1;i<(1<<c);i+=2){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tfor(int k=0;k<c;k++){\n\t\t\t\tint t=cost[k][i]+dist[k][xs[j]][ys[j]];\n\t\t\t\tcost[j][i|(1<<j)]=min(cost[j][i|(1<<j)],t);\n\t\t\t}\n\t\t}\n\t}\n\tint ret=10000;\n\tfor(int i=0;i<c;i++){\n\t\tret=min(ret,cost[i][(1<<c)-1]);\n\t}\n\tif(ret==10000)\n\t{\n\t\tcout << -1 << endl;\n\t}\n\telse\n\t{\n\t\tcout << ret << endl;\n\t}\n}\nint main() {\n\twhile(1)exec();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint W,H,T;\nchar c[32][32];\nint dist[16][16];\nint dy[]={-1,0,1,0},dx[]={0,-1,0,1};\nmap<P, int>m;\n\nint dfs(int S, int cur){\n  if((1<<T)-1 == S) return 0;\n  int res = INF;\n  rep(i,T){\n    if((S>>i)&1) continue;\n    if(dist[cur][i]!=INF);\n    res = min(res, dfs(S | (1<<i), i)+dist[cur][i]);\n  }\n  return res;\n}\n\nvoid solve(){\n  vector<P>crd;\n  int vis[32][32];\n  int sy, sx;\n  rep(i,16) rep(j,16) dist[i][j] = INF;\n  rep(i,H) rep(j,W){\n    if(c[i][j]=='o'||c[i][j]=='*') crd.push_back(P(i,j));\n    if(c[i][j]=='o') sy = i, sx = j;\n  }\n  T = crd.size();\n  rep(i,T) if(crd[i].first == sy && crd[i].second == sx) swap(crd[0], crd[i]);\n  rep(i,T) m[crd[i]] = i;\n\n  rep(i,T){\n    queue<P>q;\n    memset(vis, -1, sizeof(vis));\n    q.push(crd[i]);\n    vis[crd[i].first][crd[i].second] = 0;\n\n    while(!q.empty()){\n      P p = q.front(); q.pop();\n      int y = p.first, x = p.second;\n      if(c[y][x] == '*'){\n\tdist[i][m[P(y,x)]] = vis[y][x];\n      }\n\n      rep(d,4){\n\tint ny=y+dy[d], nx=x+dx[d];\n\tif(ny<0||ny>=H||nx<0||nx>=W||c[ny][nx]=='x'||vis[ny][nx]!=-1) continue;\n\tvis[ny][nx] = vis[y][x]+1;\n\tq.push(P(ny,nx));\n      }\n    }\n  }\n  int res = dfs(1,0);\n  printf(\"%d\\n\", res!=INF?res:-1);\n}\n\nint main(){\n  while(scanf(\"%d%d\",&W,&H) && W||H){\n    rep(i,H) scanf(\"%s\", c[i]);\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CK(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n#define ll long long;\n\nconst int INF = 1e9;\nconst long long  LLINF = 1e15;\n\nusing namespace std;\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint W,H,sy,sx,dustsNum;\nstring C[25];\n\nint dp[25][25][1050];\nmap<pair<int,int>, int> m;\n\n/*\nvoid dfs(int y, int x, int state, int step){\n  if(dp[y][x][state] <= step) return;\n  dp[y][x][state] = step;\n\n  if(state == 0) return;\n\n  REP(k,0,4){\n    int nextY = y + dy[k], nextX = x + dx[k];\n    if(!CK(nextY,0,H) || !CK(nextX,0,W)) continue;\n    if(C[nextY][nextX] == 'x') continue;\n\n    if(C[nextY][nextX] == '*'){\n      int dust = m[make_pair(nextY,nextX)];\n      dfs(nextY, nextX, state&~(1<<dust), step+1);\n    }else{\n      dfs(nextY, nextX, state, step+1);\n    }\n\n  }\n}\n*/\n\nint main() {\n  while(1){\n      cin>>W>>H;\n      if(W==0&&H==0) break;\n      dustsNum=0;\n      m.clear();\n      REP(i,0,H){\n        cin>>C[i];\n        REP(j,0,W){\n          if(C[i][j] == 'o') sy = i, sx = j;\n          if(C[i][j] == '*'){\n            m[make_pair(i,j)] = dustsNum;\n            dustsNum++;\n          }\n        }\n      }\n      REP(i,0,H)REP(j,0,W){\n        REP(k,0,(1<<dustsNum)){\n          dp[i][j][k] = INF;\n        }\n      }\n\n\n/*\n      dfs(sy, sx, (1<<dustsNum)-1, 0);\n\n      int ans = INF;\n      REP(i,0,H)REP(j,0,W){\n        ans = min(ans, dp[i][j][0]);\n      }\n\n      if(ans == INF) cout<<-1<<endl;\n      else cout<<ans<<endl;\n*/\n\n    priority_queue<pair< pair<int,int>, pair<int,int> > > PQ;  //step, state, Y, X\n    PQ.push(make_pair(make_pair(0,(1<<dustsNum)-1), make_pair(sy, sx)));\n\n    while(!PQ.empty()){\n      int nowStep = (-1)*PQ.top().F.F;\n      int nowState = PQ.top().F.S;\n      int nowY =PQ.top().S.F, nowX = PQ.top().S.S;\n      PQ.pop();\n\n      if(dp[nowY][nowX][nowState] <= nowStep) continue;\n      dp[nowY][nowX][nowState] = nowStep;\n\n      REP(k,0,4){\n        int nextY = nowY + dy[k], nextX = nowX + dx[k];\n        if(!CK(nextY,0,H) || !CK(nextX,0,W)) continue;\n        if(C[nextY][nextX] == 'x') continue;\n\n        if(C[nextY][nextX] == '*'){\n          int dust = m[make_pair(nextY,nextX)];\n          PQ.push(make_pair(make_pair((-1)*(nowStep+1), nowState&~(1<<dust)), make_pair(nextY, nextX)));\n        }else{\n          PQ.push(make_pair(make_pair((-1)*(nowStep+1), nowState), make_pair(nextY, nextX)));\n        }\n      }\n    }\n\n    int ans = INF;\n    REP(i,0,H)REP(j,0,W){\n      ans = min(ans, dp[i][j][0]);\n    }\n\n    if(ans == INF) cout<<-1<<endl;\n    else cout<<ans<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX_V 20\n#define INF 10000000\n#include<queue>\n#include<string>\n#include<map>\n#include<vector>\nusing namespace std;\nstruct edge{\n\tint to,cost;\n};\nint co[MAX_V][MAX_V];\nint h,w,V,dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nstring s[1000];\ntypedef pair<int,int> P;\nmap<P,int> mp;\nint dp[1 << MAX_V][MAX_V];\nint rec(int S,int v){\n\tif(dp[S][v]>=0)\n\t\treturn dp[S][v];\n\tif(S==(1<<V)-2){\n\t\treturn dp[S][v]=0;\n\t}\n\tint res=INF;\n\tfor(int u=0;u<V;u++){\n\t\tif(!(S>>u&1)){\n\t\t\tres=min(res,rec(S|1<<u,u)+co[v][u]);\n\t\t}\n\t}\n\treturn dp[S][v]=res;\n}\nvoid solve(){\n\tmemset(dp,-1,sizeof(dp));\n\tint temp=rec(0,0);\n\tif(temp==INF)\n\tcout<<-1<<endl;\n\telse\n\tcout<<temp<<endl;\n}\nvoid func(int y,int x,int q){\n\tint d[MAX_V][MAX_V];\n\tfor(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\td[i][j]=INF;\n\td[y][x]=0;\n\tqueue<P> box;\n\tbox.push(P(y,x));\n\twhile(!box.empty()){\n\t\tint nx,ny,sx,sy;\n\t\tP pre=box.front();\n\t\tbox.pop();\n\t\tsy=pre.first;\n\t\tsx=pre.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tnx=sx+dx[i];\n\t\t\tny=sy+dy[i];\n\t\t\tif((nx>=0&&ny>=0&&nx<w&&ny<h)&&(s[ny][nx]=='o'||s[ny][nx]=='.'||s[ny][nx]=='*')&&(d[ny][nx]==INF)){\n\t\t\t\tbox.push(P(ny,nx));\n\t\t\t\tif(s[ny][nx]=='*'||s[ny][nx]=='o'){\n\t\t\t\t\tco[mp[P(ny,nx)]][q]=d[sy][sx]+1;\n\t\t\t\t\tco[q][mp[P(ny,nx)]]=d[sy][sx]+1;\n\t\t\t\t}\n\t\t\t\td[ny][nx]=d[sy][sx]+1;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(cin>>w>>h,h||w){\n\t\tV=1;\n\t\tfor(int i=0;i<h;i++)\n\t\tcin>>s[i];\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\tif(s[i][j]=='o')\n\t\t\tmp[P(i,j)]=0;\n\t\telse if(s[i][j]=='*'){\n\t\t\tmp[P(i,j)]=V;\n\t\t\tV++;\n\t\t}\n\t\tfor(int i=0;i<V;i++)\n\t\tfor(int j=0;j<V;j++){\n\t\t\tco[i][j]=INF;\n\t\t\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[i][j]=='o'){\n\t\t\t\tfunc(i,j,0);\n\t\t\t}else if(s[i][j]=='*'){\n\t\t\t\tfunc(i,j,mp[P(i,j)]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nmap<P,int> ids;\ntemplate<class T>\nbool chmin(T &a,const T& b) {\n    if(a>b) {\n        a=b;\n        return true;\n    }\n    return false;\n}\n\nint w,h;\nstring room[21];\nint dist[12][12];\nint to_id(P p) {\n    if(!ids.count(p)) ids[p]=ids.size();\n\n    return ids[p];\n}\n\nvoid bfs(P p) {\n    int d[21][21];\n    rep(i,21) rep(j,21) d[i][j]=INF;\n    int s=to_id(p);\n    queue<P> que;\n    que.push(p);\n    d[p.fr][p.sc]=0;\n\n    while(que.size()) {\n        int y=que.front().fr;\n        int x=que.front().sc;\n        que.pop();\n        rep(i,4) {\n            int ny=y+dy[i];\n            int nx=x+dx[i];\n            if(ny<0||nx<0) continue;\n            if(h<=ny||w<=nx) continue;\n            if(d[ny][nx]!=INF) continue;\n            if(room[ny][nx]=='x') continue;\n\n            if(chmin(d[ny][nx],d[y][x]+1)) {\n                if(room[ny][nx]=='*') {\n                    //printf(\"%d,%d -> %d,%d : %d\\n\",p.fr,p.sc,ny,nx,d[ny][nx]);\n                    dist[s][to_id(P(ny,nx))]=d[ny][nx];\n                    dist[to_id(P(ny,nx))][s]=d[ny][nx];\n                }\n                que.push(P(ny,nx));\n            }\n        }\n    }\n}\n\nvoid solve() {\n    ids.clear();\n    P s;\n    vector<P> vec;\n    rep(i,10) rep(j,10) dist[i][j]=INF;\n    rep(y,h) cin>>room[y];\n    rep(y,h) rep(x,w) {\n        if(room[y][x]=='*') {\n            vec.pb(P(y,x));\n            bfs(P(y,x));\n        }\n        if(room[y][x]=='o') {\n            s=P(y,x);\n            bfs(s);\n        }\n    }\n    sort(all(vec));\n\n    int ans=INF;\n    do {\n        int t=dist[to_id(s)][to_id(vec[0])];\n        rep(i,vec.size()) if(i) t+=dist[to_id(vec[i-1])][to_id(vec[i])];\n        chmin(ans,t);\n    }while(next_permutation(all(vec)));\n\n    if(ans==INF) ans=-1;\n\n    cout<<ans<<endl;\n}\nint main() {\n    while(cin>>w>>h) {\n        if(!w) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF (1 << 29)\n\nconst int dx[4] = { 0, -1, 1, 0 };\nconst int dy[4] = { -1, 0, 0, 1 };\n\nint main()\n{\n\twhile (true)\n\t{\n\t\t// ------ Variable, Input ------ //\n\n\t\tint H, W; vector<string> MAP;\n\n\t\tcin >> W >> H;\n\n\t\tif (W == 0 && H == 0) { break; }\n\n\t\tMAP = vector<string>(H);\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tcin >> MAP[i];\n\t\t}\n\n\n\t\t// ------ Graph Construction ------ //\n\n\t\tvector<pair<int, int> > Location(1);\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (MAP[i][j] == 'o')\n\t\t\t\t{\n\t\t\t\t\tLocation[0] = make_pair(j, i);\n\t\t\t\t}\n\n\t\t\t\tif (MAP[i][j] == '*')\n\t\t\t\t{\n\t\t\t\t\tLocation.push_back(make_pair(j, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int> > Graph(Location.size(), vector<int>(Location.size(), INF));\n\n\t\tfor (int i = 0; i < Location.size(); i++)\n\t\t{\n\t\t\tvector<vector<int> > distance_(H, vector<int>(W, INF)); distance_[Location[i].second][Location[i].first] = 0;\n\n\t\t\tqueue<pair<int, int> > que; que.push(Location[i]);\n\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tpair<int, int> p1 = que.front(); que.pop();\n\n\t\t\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t\t\t{\n\t\t\t\t\tint px = p1.first + dx[dir];\n\t\t\t\t\tint py = p1.second + dy[dir];\n\n\t\t\t\t\tif (0 <= px && px < W && 0 <= py && py < H && MAP[py][px] != 'x' && distance_[py][px] == INF)\n\t\t\t\t\t{\n\t\t\t\t\t\tdistance_[py][px] = distance_[p1.second][p1.first] + 1;\n\n\t\t\t\t\t\tque.push(make_pair(px, py));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < Location.size(); j++)\n\t\t\t{\n\t\t\t\tif (i != j)\n\t\t\t\t{\n\t\t\t\t\tint dist = distance_[Location[j].second][Location[j].first];\n\n\t\t\t\t\tGraph[i][j] = dist;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// ------ Traveling Salesman Problem ------ //\n\n\t\tvector<vector<int> > dp(Graph.size(), vector<int>(1 << Graph.size(), INF));\n\n\t\tdp[0][1] = 0;\n\n\t\tfor (int i = 2; i < (1 << Graph.size()); i++)\n\t\t{\n\t\t\tfor (int j = 0; j < Graph.size(); j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < Graph.size(); k++)\n\t\t\t\t{\n\t\t\t\t\tif (i & (1 << j) && i & (1 << k))\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[k][i] = min(dp[j][i - (1 << k)] + Graph[j][k], dp[k][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint Answer = INF;\n\n\t\tfor (int i = 0; i < Graph.size(); i++)\n\t\t{\n\t\t\tAnswer = min(Answer, dp[i][(1 << Graph.size()) - 1]);\n\t\t}\n\n\t\tcout << (Answer == INF ? -1 : Answer) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#define MAX_V 20\n#define INF 10000000\n#include<queue>\n#include<string>\n#include<map>\n#include<vector>\nusing namespace std;\nstruct edge{\n\tint to,cost;\n};\nint co[MAX_V][MAX_V];\nint h,w,V,dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nstring s[1000];\ntypedef pair<int,int> P;\nmap<P,int> mp;\nint dp[1 << MAX_V][MAX_V];\nint rec(int S,int v){\n\tif(dp[S][v]>=0)\n\t\treturn dp[S][v];\n\tif(S==(1<<V)-2){\n\t\treturn dp[S][v]=0;\n\t}\n\tint res=INF;\n\tfor(int u=0;u<V;u++){\n\t\tif(!(S>>u&1)){\n\t\t\tres=min(res,rec(S|1<<u,u)+co[v][u]);\n\t\t}\n\t}\n\treturn dp[S][v]=res;\n}\nvoid solve(){\n\tmemset(dp,-1,sizeof(dp));\n\tint temp=rec(0,0);\n\tif(temp==INF)\n\tcout<<-1<<endl;\n\telse\n\tcout<<temp<<endl;\n}\nvoid func(int y,int x,int q){\n\tint d[MAX_V][MAX_V];\n\tfor(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\td[i][j]=INF;\n\td[y][x]=0;\n\tqueue<P> box;\n\tbox.push(P(y,x));\n\twhile(!box.empty()){\n\t\tint nx,ny,sx,sy;\n\t\tP pre=box.front();\n\t\tbox.pop();\n\t\tsy=pre.first;\n\t\tsx=pre.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tnx=sx+dx[i];\n\t\t\tny=sy+dy[i];\n\t\t\tif((nx>=0&&ny>=0&&nx<w&&ny<h)&&(s[ny][nx]=='o'||s[ny][nx]=='.'||s[ny][nx]=='*')&&(d[ny][nx]==INF)){\n\t\t\t\tbox.push(P(ny,nx));\n\t\t\t\tif(s[ny][nx]=='*'||s[ny][nx]=='o'){\n\t\t\t\t\tco[mp[P(ny,nx)]][q]=d[sy][sx]+1;\n\t\t\t\t\tco[q][mp[P(ny,nx)]]=d[sy][sx]+1;\n\t\t\t\t}\n\t\t\t\td[ny][nx]=d[sy][sx]+1;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(cin>>w>>h,h||w){\n\t\tV=1;\n\t\tfor(int i=0;i<h;i++)\n\t\tcin>>s[i];\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\tif(s[i][j]=='o')\n\t\t\tmp[P(i,j)]=0;\n\t\telse if(s[i][j]=='*'){\n\t\t\tmp[P(i,j)]=V;\n\t\t\tV++;\n\t\t}\n\t\tfor(int i=0;i<V;i++)\n\t\tfor(int j=0;j<V;j++){\n\t\t\tco[i][j]=INF;\n\t\t\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[i][j]=='o'){\n\t\t\t\tfunc(i,j,0);\n\t\t\t}else if(s[i][j]=='*'){\n\t\t\t\tfunc(i,j,mp[P(i,j)]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e7+1)\n\nusing grid = vector<vector<int>>;\n\nint dy[]={1,0,-1,0};\nint dx[]={0,1,0,-1};\nint w,h;\n\nvoid bfs(int y, int x, vector<string> &vs, grid &gd){\n    gd[y][x] = 0;\n    queue<pii> que;\n    que.push(pii(y,x));\n    \n    while(que.size()){\n        int ty = que.front().first;\n        int tx = que.front().second;\n        rep(k,4){\n            int ddy = ty+dy[k];\n            int ddx = tx+dx[k];\n            if(ddx<0 || ddy<0 || ddx>=w || ddy>=h)continue;\n            if(vs[ddy][ddx]=='x')continue;\n            if(gd[ddy][ddx]!=INF)continue;\n            gd[ddy][ddx] = gd[ty][tx]+1;\n            que.push(pii(ddy,ddx));\n        }\n        que.pop();\n    }\n}\n\nint main(){\n    while(cin>>w>>h&&(w||h)){\n        vector<string> vs(h);\n        rep(i,h)cin>>vs[i];\n        \n        vector<pii> vp;\n        pii st;\n        rep(i,h){\n            rep(j,w){\n                if(vs[i][j]=='*')vp.pb(pii(i,j));\n                else if(vs[i][j]=='o')st = pii(i,j);\n            }\n        }\n        \n        vector<vector<grid>> dist(h,vector<grid>(w,grid(h,vector<int>(w,INF))));\n        rep(i,h){\n            rep(j,w){\n                bfs(i,j,vs,dist[i][j]);\n            }\n        }\n        \n        sort(all(vp));\n        \n        int ans = INF;\n        do{\n            int tmp = 0;\n            tmp += dist[st.first][st.second][vp[0].first][vp[0].second];\n            rep(i,vp.size()-1){\n                tmp += dist[vp[i].first][vp[i].second][vp[i+1].first][vp[i+1].second];\n            }\n            ans = min(ans,tmp);\n        }while(next_permutation(all(vp)));\n        \n        if(ans==INF)cout<<-1<<endl;\n        else cout<<ans<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\n#define int i64\n\nint w,h;\n\nvector<int> ans;\n\nsigned main(){\n\twhile(cin >> w >> h,w || h){\n\t\tvector<vector<int>> fie(h,vector<int>(w,0));\n\t\tvector<P> dust;\n\t\tint sx,sy;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tstring s;\n\t\t\tcin>> s;\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(s[j] == '*'){\n\t\t\t\t\tdust.push_back({i,j});\n\t\t\t\t\tfie[i][j] = dust.size();\n\t\t\t\t}\n\t\t\t\tif(s[j] == 'x'){\n\t\t\t\t\tfie[i][j] = -1;\n\t\t\t\t}\n\t\t\t\tif(s[j] == 'o'){\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusing P2 = pair<int,P>;\n\t\tvector<vector<int>> dist(dust.size(),vector<int>(dust.size() , 1e9));\n\n\t\tint dx[] = {1,-1,0,0};\n\t\tint dy[] = {0,0,1,-1};\n\n\t\tfor(int s = 0;s < dust.size();s++){\n\t\t\tqueue<P2> que;\n\t\t\tque.push({0,dust[s]});\n\t\t\tvector<vector<int>> vis(h,vector<int>(w,0));\n\t\t\tvis[dust[s].first][dust[s].second] = 1;\n\t\t\twhile(!que.empty()){\n\t\t\t\tint d = que.front().first;\n\t\t\t\tP p = que.front().second;\n\t\t\t\tif(fie[p.first][p.second] > 0){\n\t\t\t\t\tdist[s][fie[p.first][p.second] - 1] = d;\n\t\t\t\t}\n\t\t\t\tque.pop();\n\t\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\t\tint nx = p.first + dx[i];\n\t\t\t\t\tint ny = p.second + dy[i];\n\t\t\t\t\tif(0 <= nx && nx < h && 0 <= ny && ny < w && fie[nx][ny] != -1 && vis[nx][ny] == 0){\n\t\t\t\t\t\tvis[nx][ny] = 1;\n\t\t\t\t\t\tque.push({d + 1,{nx,ny}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint dp[1 << dust.size()];\n\t\tfill(dp , dp + (1 << dust.size()),1e9);\n\t\t{\n\t\t\tqueue<P2> que;\n\t\t\tque.push({0,{sx,sy}});\n\t\t\tvector<vector<int>> vis(h,vector<int>(w,0));\n\t\t\tvis[sx][sy] = 1;\n\t\t\twhile(!que.empty()){\n\t\t\t\tint d = que.front().first;\n\t\t\t\tP p = que.front().second;\n\t\t\t\tif(fie[p.first][p.second] > 0){\n\t\t\t\t\tdp[(1 << (fie[p.first][p.second] - 1))] = d;\n\t\t\t\t}\n\t\t\t\tque.pop();\n\t\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\t\tint nx = p.first + dx[i];\n\t\t\t\t\tint ny = p.second + dy[i];\n\t\t\t\t\tif(0 <= nx && nx < h && 0 <= ny && ny < w && fie[nx][ny] != -1 && vis[nx][ny] == 0){\n\t\t\t\t\t\tvis[nx][ny] = 1;\n\t\t\t\t\t\tque.push({d + 1,{nx,ny}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1;i < (1 << dust.size()) - 1;i++){\n\t\t\tfor(int j = 0;j < dust.size();j++){\n\t\t\t\tfor(int k = 0;k < dust.size();k++){\n\t\t\t\t\tif(j == k) continue;\n\t\t\t\t\tif(!(i & (1 << j)) && (i & (1 << k))){\n\t\t\t\t\t\t//j <- k\n\t\t\t\t\t\tdp[i | (1 << j)] = min(dp[i | (1 << j)] , dp[i] + dist[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dp[(1 << dust.size()) - 1] >= 1e9){\n\t\t\tans.push_back(-1);\n\t\t}\n\t\telse{\n\t\t\tans.push_back(dp[(1 << dust.size()) - 1]);\n\t\t}\n\t}\n\tfor(int a : ans){\n\t\tcout << a << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define Y first\n#define X second\n#define fst first\n#define snd second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nconst char NONE = '.';\nconst char BAD = '*';\nconst char WALL = 'x';\nconst char ROBOT = 'o';\n\nint W, H;\nVS ts;\n\nmap<PII, int> p2idx;\nVPII ps;\nint PN;\nint s;\n\nVVI es;\n\nvoid find_ps() {\n\tPN = 0;\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = 0; x < W; x++) {\n\t\t\tif (ts[y][x] == BAD || ts[y][x] == ROBOT) {\n\t\t\t\tif (ts[y][x] == ROBOT) {\n\t\t\t\t\ts = PN;\n\t\t\t\t}\n\t\t\t\tp2idx[MP(y, x)] = PN;\n\t\t\t\tps.EB(y, x);\n\n\t\t\t\t++PN;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid calc_distance(int pi) {\n\tVVB done(H, VB(W));\n\n\tqueue<pair<PII, int>> q;\n\tq.push(MP(ps[pi], 0));\n\n\twhile (q.size()) {\n\t\tPII p = q.front().fst;\n\t\tint cost  =q.front().snd;\n\t\tq.pop();\n\n\t\tif (done[p.Y][p.X]) continue;\n\t\tdone[p.Y][p.X] = true;\n\n\t\tif (p2idx.count(p)) {\n\t\t\tint idx = p2idx[p];\n\t\t\tes[pi][idx] = cost;\n\t\t}\n\n\n\t\tfor (int di = 0; di < 4; di++) {\n\t\t\tPII np(p.Y + DY[di], p.X + DX[di]);\n\t\t\tif (RANGE(np.X, np.Y, W, H) && ts[np.Y][np.X] != WALL) {\n\t\t\t\tq.push(MP(np, cost + 1));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve() {\n\t// ????????§?¨?????????????\n\tp2idx.clear();\n\tps.clear();\n\tfind_ps();\n\n\t// ?????¨???????????¢????????????\n\tes.clear();\n\tes.resize(PN, VI(PN, INF));\n\tfor (int i = 0; i < PN; i++) {\n\t\tcalc_distance(i);\n\t}\n\n\t// ???????????????????????¨??????????????£?????? -1\n\tfor (int i = 0; i < PN; i++) {\n\t\tfor (int j = 0; j < PN; j++) {\n\t\t\tif (es[i][j] == INF) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// ???????????¢????±???????\n\t// dp[pattern][v]\n\tVVI dp(1 << PN, VI(PN, INF));\n\tdp[1 << s][s] = 0;\n\tfor (int pt = 0; pt < 1 << PN; pt++) {\n\t\tfor (int cur = 0; cur < PN; cur++) {\n\t\t\tif (dp[pt][cur] == INF) continue;\n\n\t\t\tfor (int next = 0; next < PN; next++) {\n\t\t\t\tif (1 << next & pt) continue;\n\n\t\t\t\tint npt = pt | (1 << next);\n\t\t\t\tint ncost = dp[pt][cur] + es[cur][next];\n\n\t\t\t\tif (dp[npt][next] > ncost) {\n\t\t\t\t\tdp[npt][next] = ncost;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn *min_element(ALL(dp.back()));\n}\n\nint main(void) {\n\twhile (cin >> W >> H, W) {\n\t\tts.resize(H);\n\t\tfor (auto &l : ts) {\n\t\t\tcin >> l;\n\t\t}\n\t\tcout << solve() << endl;\n\t}\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\n#define endl '\\n'\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing PLL = std::pair<ll, ll>;\nusing TLL = std::tuple<ll, ll, ll>;\ntemplate <typename T> using V = std::vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return V<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\nusing namespace std;\n\n#ifdef DEBUGGING\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\nconst ll inf = 5e15;\n\ntuple<VV<ll>, V<ll>, ll> grid2graph(const V<string> &grid, ll H, ll W) {\n    auto graph = make_v<ll>(inf, H * W, H * W);\n    V<ll> taint;\n    ll robot;\n    ll dh[] = { 1, 0, -1, 0, };\n    ll dw[] = { 0, 1, 0, -1, };\n    \n    auto make_id = [&](ll h, ll w) { return h * W + w; };\n    auto valid = [&](ll h, ll w) { return 0 <= h && h < H && 0 <= w && w < W; };\n\n    for (ll h = 0; h < H; h++) for (ll w = 0; w < W; w++) {\n        ll id = make_id(h, w);\n        char c = grid[h][w];\n        if (c == 'x') continue;\n        if (c == 'o') robot = id;\n        if (c == '*') taint.push_back(id);\n        graph[id][id] = 0;\n        for (ll i = 0; i < 4; i++) {\n            ll nh = h + dh[i], nw = w + dw[i];\n            if (!valid(nh, nw)) continue;\n            if (grid[nh][nw] == 'x') continue;\n            ll nid = make_id(nh, nw);\n            graph[id][nid] = 1;\n        }\n    }\n\n    return make_tuple(move(graph), move(taint), robot);\n}\n\nbool solve() {\n    ll H, W;\n    cin >> W >> H;\n    if (!(H + W)) return false;\n    V<string> grid(H);\n    for (auto &&e : grid) cin >> e;\n    VV<ll> dists;\n    V<ll> taint;\n    ll robot;\n    tie(dists, taint, robot) = grid2graph(grid, H, W);\n    for (ll k = 0; k < dists.size(); k++) for (ll i = 0; i < dists.size(); i++) for (ll j = 0; j < dists.size(); j++) chmin(dists[i][j], dists[i][k] + dists[k][j]);\n    sort(ALL(taint));\n    ll ans = inf;\n    do {\n        ll cur = robot, tmp = 0;\n        for (ll t : taint) {\n            tmp += dists[cur][t];\n            cur = t;\n        }\n        chmin(ans, tmp);\n    } while (next_permutation(ALL(taint)));\n    cout << (inf <= ans ? -1 : ans) << endl;\n    return true;\n}\n\nint main() {\n    while (solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define MAX 12\n#define mk make_pair\n#define INF 1<<28\nstring s[20];\nbool vis[20][20];\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint n,w,h,d[MAX][MAX],c;\nint dp[1<<MAX][MAX];\nint rec(int s,int v){\n  if(dp[s][v]>=0)return dp[s][v];\n  if(s==(1<<n)-1&&v!=0){return dp[s][v]=0;}\n  int res=INF;\n  for(int u=0;u<n;u++) \n    if(!(s>>u&1))\n      res=min(res,rec(s|1<<u,u)+d[v][u]);\n  return dp[s][v]=res;\n}\nvoid bfs(int x2,int y2,int k){\n  r(i,20)r(j,20)vis[i][j]=0;\n  queue<pair<pair<int,int>,int> > q;\n  vis[x2][y2]=1;\n  q.push(mk(mk(x2,y2),0));\n  while(!q.empty()){\n    pair<pair<int,int>,int>p=q.front();q.pop();\n    int p1=p.first.first,p2=p.first.second,p3=p.second;//cout<<p1<<p2<<p3<<endl;\n    r(i,4){\n      int x=dx[i]+p1;\n      int y=dy[i]+p2;\n      if(x>=0&&x<w&&y>=0&&y<h)\n        if(!vis[x][y]&&(s[y][x]!='x')){\n          if(0<=s[y][x]&&s[y][x]<12)\n            d[k][(int)s[y][x]]=p3+1,q.push(mk(mk(x,y),p3+1));\n          else if(k!=0&&s[y][x]=='o')\n            d[k][0]=p3+1,q.push(mk(mk(x,y),p3+1));\n          else q.push(mk(mk(x,y),p3+1));\n          vis[x][y]=1;\n        }\n    }\n  }\n}\nint main(){\n  while(cin>>w>>h,w){c=1;\n    int a,b;\n    vector<pair<int,int> >v;\n    r(i,h)cin>>s[i];\n    r(j,w)r(i,h)if(s[i][j]=='*')s[i][j]=c++,v.push_back(make_pair(j,i));\n  memset(dp,-1,sizeof(dp));\n  n=c;\n  r(i,MAX)r(j,MAX)d[i][j]=INF;\n  r(j,w)r(i,h)if(s[i][j]=='o')a=j,b=i;\n  bfs(a,b,0);\n  r(i,c-1)bfs(v[i].first,v[i].second,i+1);\n  //r(i,c){r(j,c){cout<<d[i][j]<<' ';}cout<<endl;}cout<<d[0][1];\n  int p=rec(1,0);\n  if(p==INF)p=-1;\n  cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <iostream>\n#include <queue>\n#define MAX 20\n#define INF 10000000\n\nusing namespace std;\n\nint w, h;\nint si, sj;\nchar c[MAX][MAX];\nint d[MAX][MAX][1024];\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid change(int a[10], int x){\n\n\tfor(int i = 0 ; i < 10 ; ++i){\n\t\ta[i] = x % 2;\n\t\tx /= 2;\n\t}\n\n}\n\nint change(int a[10]){\n\n\tint res = 0;\n\tfor(int i = 9 ; i >= 0 ; --i){\n\t\tres = res * 2 + a[i];\n\t}\n\treturn res;\n}\n\nint bfs(int sx, int sy, int cnt){\n\n\tqueue<int> qx, qy, qbit;\n\tqy.push(si);\n\tqx.push(sj);\n\tqbit.push(0);\n\n\td[sj][si][0] = 0;\n\n\n\twhile(qbit.empty() == false){\n\n\t\tint y = qy.front();\n\t\tqy.pop();\n\n\t\tint x = qx.front();\n\t\tqx.pop();\n\n\t\tint bit = qbit.front();\n\t\tqbit.pop();\n\n\t\tif( bit + 1 == (1 << cnt) ){\t\t\t\t// ?????§?????¨??????????????????????????????\n\t\t\treturn d[y][x][bit];\n\t\t}\n\n\t\tint a[10];\n\t\tfor(int i = 0 ; i < 4 ; ++i){\n\n\t\t\tchange(a, bit);\n\t\t\tint ny = dy[i] + y;\n\t\t\tint nx = dx[i] + x;\n\n\t\t\tif( ny < 0 || nx < 0 ) continue;\t\t// ?????????\n\t\t\tif( h <= ny || w <= nx) continue;\t\t// ?????????\n\t\t\tif( c[ny][nx] == 'x') continue;\t\t\t// ?§??????§?????????\n\n\t\t\tif( c[ny][nx] != '.'){\t\t\t\t\t// ?±??????????????????§????????´???\n\t\t\t\tint num = c[ny][nx] - '0';\t\t\t// ?±???????????????????ID?????????\n\t\t\t\ta[num] = 1;\n\t\t\t}\n\t\t\tint nbit = change(a);\n\t\t\tint nCost = d[y][x][bit] + 1;\n\n\t\t\tif( nCost < d[ny][nx][nbit] ){\t\t\t// ??????????????£??????????????´??? & ???????§£?????´??°\n\t\t\t\td[ny][nx][nbit] = nCost;\n\t\t\t\tqy.push(ny);\n\t\t\t\tqx.push(nx);\n\t\t\t\tqbit.push(nbit);\n\t\t\t}\n\n\t\t}// end of for\n\n\n\t}// end of while\n\n\n\treturn -1;\n}// end of bfs\n\nvoid init(){\n\n\tfor (int i = 0 ; i < h ; ++i){\n\t\tfor (int j = 0 ; j < w ; ++j){\n\t\t\tfor(int k = 0 ; k < 1024 ; ++k){\n\t\t\t\td[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n\n\n}\n\nint main(void){\n\n\n\twhile( cin >> w >> h ){\n\n\t\tif( w == h && h == 0 ){\n\t\t\tbreak;\n\t\t}\n\t\tinit();\n\t\tint cnt = 0;\n\n\t\tfor(int i = 0 ; i < h ; ++i){\n\t\t\tfor(int j = 0 ; j < w ; ++j){\n\t\t\t\tcin >> c[i][j];\n\t\t\t\tif( c[i][j] == 'o'){\n\t\t\t\t\tsj = j;\n\t\t\t\t\tsi = i;\n\t\t\t\t\tc[i][j] = '.';\n\t\t\t\t}else if( c[i][j] == '*'){\n\t\t\t\t\tc[i][j] = '0' + cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << bfs(si, sj, cnt) << endl;\n\n\t\t// for(int i = 0 ; i < h ; ++i){\n\t\t// \tfor(int j = 0 ; j < w ; ++j ){\n\t\t// \t\tcout << c[i][j];\n\t\t// \t}\n\t\t// \tcout << endl;\n\t\t// }\n\n\t}// end of while\n\n\treturn 0;\n}// end of main"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v){std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\nconst int INF = 1000000000;\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid dfs(pair<int, int> s, vector<string> &M, vector<vector<int>> &dist, int H, int W) {\n    dist[s.first][s.second] = 0;\n    queue<pair<int, int>> Q;\n    Q.push(s);\n\n    while (!Q.empty()) {\n        auto p = Q.front();\n        Q.pop();\n        int y = p.first;\n        int x = p.second;\n        int c = dist[y][x];\n        for (int i = 0; i < 4; i++) {\n            int toY = y + dy[i];\n            int toX = x + dx[i];\n            if (toY < 0 || toY >= H || toX < 0 || toX >= W) continue;\n            if (dist[toY][toX] <= c + 1) continue;\n            if (M[toY][toX] == 'x') continue;\n            dist[toY][toX] = c + 1;\n            Q.push(make_pair(toY, toX));\n        }\n    }\n}\n\nint main() {\n\n    while (true) {\n\n        int W, H;\n        cin >> W >> H;\n\n        if (!(W | H)) break;\n\n        vector<string> M(H);\n        for (int i = 0; i < H; i++) cin >> M[i];\n\n        int dirty = 0;\n        for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) if (M[i][j] == '*') dirty++;\n\n        auto distP = vector<vector<int>>(H, vector<int>(W, INF));\n        auto distG = vector<vector<vector<int>>>(dirty, vector<vector<int>>(H, vector<int>(W, INF)));\n\n        pair<int, int> s;\n\n        vector<pair<int, int>> points;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                auto p = make_pair(i, j);\n                if (M[i][j] == 'o') {\n                    s = p;\n                    dfs(p, M, distP, H, W);\n                }\n                if (M[i][j] == '*') {\n                    points.push_back(p);\n                    dfs(p, M, distG[points.size() - 1], H, W);\n                }\n            }\n        }\n\n        vector<int> a(dirty);\n        for (int i = 0; i < dirty; i++) a[i] = i;\n\n        long long ans = 10000000000000LL;\n        do {\n\n            long long sum = 0;\n            sum += distP[points[a[0]].first][points[a[0]].second];\n\n            for (int i = 0; i < dirty - 1; i++) {\n                sum += distG[a[i]][points[a[i + 1]].first][points[a[i + 1]].second];\n            }\n\n            ans = min(ans, sum);\n\n        } while (next_permutation(a.begin(), a.end()));\n\n        if (ans >= INF) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint W,H,index[20][20],dp[11][10][1024],fin_state,from_start[10],min_distance[10][10];\nchar table[20][21];\n\nstruct Info{\n\tInfo(){\n\t\trow = 0;\n\t\tcol = 0;\n\t\tstate = 0;\n\t\tcost = 0;\n\t}\n\n\tInfo(int arg_row,int arg_col,int arg_state,int arg_cost){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tstate = arg_state;\n\t\tcost = arg_cost;\n\t}\n\tint row,col,state,cost;\n};\n\nInfo start,Target[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0},target_count,next_state;\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nbool enable_check(int start_row,int start_col){\n\tbool visited[20][20];\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++)visited[i][k] = false;\n\t}\n\n\tqueue<Info> S;\n\tvisited[start_row][start_col] = true;\n\n\tS.push(Info(start_row,start_col,0,0));\n\n\tint to_row,to_col;\n\n\twhile(!S.empty()){\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tto_row = S.front().row + diff_row[i];\n\t\t\tto_col = S.front().col + diff_col[i];\n\n\t\t\tif(rangeCheck(to_row,to_col) == false || visited[to_row][to_col] == true || table[to_row][to_col] == 'x')continue;\n\n\t\t\tvisited[to_row][to_col] = true;\n\t\t\tS.push(Info(to_row,to_col,0,0));\n\t\t}\n\n\t\tS.pop();\n\t}\n\n\tfor(int i = 0; i < target_count; i++){\n\t\tif(visited[Target[i].row][Target[i].col] == false)return false;\n\t}\n\n\treturn true;\n}\n\n//2??°??????????????¢????¨??????????\nint calc_distance(Info calc_start,Info calc_goal){\n\tint ret = BIG_NUM,calc_map[20][20],calc_row,calc_col;\n\n\tqueue<Info> S;\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++)calc_map[i][k] = BIG_NUM;\n\t}\n\n\tInfo first;\n\tfirst.row = calc_start.row;\n\tfirst.col = calc_start.col;\n\tfirst.cost = 0;\n\n\tcalc_map[first.row][first.col] = 0;\n\n\tS.push(first);\n\n\twhile(!S.empty()){\n\n\t\tif(S.front().row == calc_goal.row && S.front().col == calc_goal.col){\n\t\t\tret = S.front().cost;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(S.front().cost != calc_map[S.front().row][S.front().col]){\n\t\t\tS.pop();\n\t\t\tcontinue;\n\t\t}else{\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tcalc_row = S.front().row + diff_row[i];\n\t\t\t\t\tcalc_col = S.front().col + diff_col[i];\n\n\t\t\t\t\tif(rangeCheck(calc_row,calc_col) == false || table[calc_row][calc_col] == 'x' ||\n\t\t\t\t\t\tcalc_map[calc_row][calc_col] <= S.front().cost+1)continue;\n\n\t\t\t\t\tcalc_map[calc_row][calc_col] = S.front().cost+1;\n\t\t\t\t\tS.push(Info(calc_row,calc_col,0,calc_map[calc_row][calc_col]));\n\t\t\t}\n\t\t\tS.pop();\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main(){\n\n\tint ans,tmp;\n\tqueue<Info> Q;\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\ttarget_count = 0;\n\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tscanf(\"%s\",table[i]);\n\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\tswitch(table[i][k]){\n\t\t\t\tcase '.':\n\t\t\t\t\t//Do nothing\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\tindex[i][k] = target_count;\n\t\t\t\t\tTarget[target_count].row = i;\n\t\t\t\t\tTarget[target_count].col = k;\n\t\t\t\t\ttarget_count++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'x':\n\t\t\t\t\t//Do nothing\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'o':\n\t\t\t\t\tstart.row = i;\n\t\t\t\t\tstart.col = k;\n\t\t\t\t\tstart.state = 0;\n\t\t\t\t\tstart.cost = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!enable_check(start.row,start.col)){\n\t\t\tprintf(\"-1\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i = 0; i < target_count; i++){\n\t\t\tfrom_start[i] = calc_distance(start,Target[i]);\n\t\t}\n\n\t\tfor(int i = 0; i < target_count-1; i++){\n\t\t\tfor(int k = i+1; k < target_count;k++){\n\t\t\t\tif(i == k)continue;\n\t\t\t\ttmp = calc_distance(Target[i],Target[k]);\n\t\t\t\tmin_distance[i][k] = tmp;\n\t\t\t\tmin_distance[k][i] = tmp;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= target_count;i++){\n\t\t\tfor(int k = 0; k < target_count;k++){\n\t\t\t\tfor(int p = 0; p < pow(2,target_count);p++)dp[i][k][p] = BIG_NUM;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < target_count; i++){\n\t\t\ttmp = pow(2,i);\n\t\t\tdp[1][i][tmp] = from_start[i];\n\t\t}\n\n\t\tfor(int i = 2; i <= target_count; i++){\n\t\t\tfor(int k = 0; k < target_count; k++){\n\t\t\t\tfor(int state = 0; state < pow(2,target_count); state++){\n\t\t\t\t\tif(dp[i-1][k][state] == BIG_NUM)continue;\n\t\t\t\t\tfor(int a = 0; a < target_count; a++){\n\t\t\t\t\t\tif(state & (1 << a)){\n\t\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tnext_state = state+pow(2,a);\n\t\t\t\t\t\t\tdp[i][a][next_state] = min(dp[i][a][next_state],dp[i-1][k][state]+min_distance[k][a]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans = BIG_NUM;\n\t\ttmp = pow(2,target_count)-1;\n\n\t\tfor(int i = 0; i < target_count; i++){\n\t\t\tans = min(ans,dp[target_count][i][tmp]);\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define dbg(x) cout<<#x<<\":\"<<x<<endl\n#define int long long\n#define MOD 1e9+7\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nstruct node{\n  int x,y,z,l;\n};\n\nsigned main(){\n  while(1){\n  int w,h,INF=1LL<<60;\n  cin>>w>>h;\n  if(w==0)break;\n  char c[22][22];\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n\t cin>>c[i][j];\n\n  int sx,sy;\n  int m[22][22];\n  fill_n(*m,22*22,-1);\n  int cnt=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n\t if(c[i][j]=='*'){\n\t   m[i][j]=cnt++;\n\t }\n\t if(c[i][j]=='o'){\n\t   sx=i;\n\t   sy=j;\n\t }\n    }\n  }\n\n  int d[22][22][1<<10];\n  fill_n(**d,22*22*(1<<10),INF);\n  deque<node> que;\n  que.push_back({sx,sy,0,0});\n  int dx[4]={0,0,1,-1};\n  int dy[4]={1,-1,0,0};\n\n  while(que.size()){\n    int x=que.front().x;\n    int y=que.front().y;\n    int z=que.front().z;\n    int l=que.front().l;\n    que.pop_front();\n    if(x<0||h<=x||y<0||w<=y)continue;\n    if(c[x][y]=='x')continue;\n    if(d[x][y][z]!=INF)continue;\n    if(c[x][y]=='*'&&(z>>m[x][y]&1)==0){\n\t int nz=z+(1<<m[x][y]);\n\t que.push_front({x,y,nz,l});\n    }\n    d[x][y][z]=l;\n    for(int i=0;i<4;i++){\n\t que.push_back({x+dx[i],y+dy[i],z,l+1});\n    }\n  }\n  int mi=INF;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n\t mi=min(mi,d[i][j][(1<<cnt)-1]);\n  if(mi==INF)cout<<-1<<endl;\n  else cout<<mi<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <climits>\n#define INF INT_MAX>>1 //要climits#includ\n\nusing namespace std;\n\nint dx[4] ={-1, 0, 0, 1};\nint dy[4] ={0, -1, 1, 0};\n\nint main(void){\n\twhile(1){\n\t\tint w, h; cin >> w >> h;\n\t\tif(!w && !h) break;\n\n\t\tchar c[21][21];\n\t\tpair <int, int> node[11];\n\t\tint count = 1;\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tcin >> c[i][j];\n\t\t\t\tif(c[i][j] == 'o'){\n\t\t\t\t\tnode[0].first = i;\n\t\t\t\t\tnode[0].second = j;\n\t\t\t\t} else if(c[i][j] == '*'){\n\t\t\t\t\tnode[count].first = i;\n\t\t\t\t\tnode[count].second = j;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint adj[11][11] ={0};\n\t\tfor(int i=0; i<count; i++){\n\t\t\tqueue <pair<int, int> > que;\n\t\t\tque.push(make_pair(node[i].first, node[i].second));\n\t\t\tint dist[21][21]={0};\n\t\t\twhile(!que.empty()){\n\t\t\t\tint y = que.front().first;\n\t\t\t\tint x = que.front().second;\n\t\t\t\tque.pop();\n\n\t\t\t\tfor(int j=0; j<4; j++){\n\t\t\t\t\tint ny = y+dy[j];\n\t\t\t\t\tint nx = x+dx[j];\n\t\t\t\t\tif(nx<0 || w<=nx || ny<0 || h<=ny) continue;\n\t\t\t\t\tif(c[ny][nx] == 'x') continue;\n\n\t\t\t\t\tif(dist[ny][nx] == 0 || dist[y][x]+1 < dist[ny][nx]){\n\t\t\t\t\t\tdist[ny][nx] = dist[y][x]+1;\n\t\t\t\t\t\tque.push(make_pair(ny, nx));\n\t\t\t\t\t} else{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(c[ny][nx] == 'o' || c[ny][nx] == '*'){\n\t\t\t\t\t\tfor(int k=0; k<count; k++){\n\t\t\t\t\t\t\tif(ny == node[k].first && nx == node[k].second){\n\t\t\t\t\t\t\t\tadj[i][k] = adj[k][i] = dist[ny][nx];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int k=0; k<count; k++){\n\t\t\tadj[k][k] = INF;\n\t\t}\n\t\t\n\t\tint noFlag = false;\n\t\tfor(int i=0; i<count; i++){\n\t\t\tfor(int j=0; j<count; j++){\n\t\t\t\tif(adj[i][j] == 0) noFlag = true;\n\t\t\t}\n\t\t}\n\t\tif(noFlag){\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ans = INF;\n\t\tvector<int> v(count);\n\t\tfor(int i=0; i<count; i++){\n\t\t\tv[i] = i;\n\t\t}\n\t\tdo{\n\t\t\tint cost = 0;\n\t\t\tfor(int i=0; i<count-1; i++){\n\t\t\t\tcost += adj[v[i]][v[i+1]];\n\t\t\t}\n\t\t\tans = min(ans, cost);\n\t\t} while(next_permutation(v.begin()+1, v.end()));\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<int, int> P;\nint bfs(void);\nint INF=10000000;\nint w,h;\nint sx,sy;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint d[100][100];\nchar mapp[100][100];\nint main(){\n  int kari;\n  while(1){\n    int yogore=0;\n    int ans=0;\n\n    cin>>w>>h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>mapp[i][j];\n\tif(mapp[i][j]=='*'){\n\t  yogore++;\n\t}else if(mapp[i][j]=='o'){\n\t  sy=i;\n\t  sx=j;\n\t}\n      }\n    }\n    for(int i=0;i<yogore;i++){\n      kari=bfs();\n      if(kari==0){\n\tans=-1;\n\tbreak;\n      }else{\n\tans+=kari;\n      }\n      \n    }\n    cout<<ans<<endl;\n  }\n}\nint bfs(void){\n  queue<P> que;\n  que.push(P(sy,sx));\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      d[i][j]=INF;\n    }\n  }\n  d[sy][sx]=0;\n  while(que.size()){\n    P p=que.front();\n    que.pop();\n    if(mapp[p.first][p.second]=='*'){\n      sy=p.first;\n      sx=p.second;\n      mapp[p.first][p.second]='.';\n      break;\n    }\n    for(int i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(0<=nx && nx<w && 0<=ny && ny<h && mapp[ny][nx]!='x' && d[ny][nx]==INF){\n\tque.push(P(ny,nx));\n\td[ny][nx]=d[p.first][p.second]+1;\n      }\n    }\n  }\n  return d[sy][sx];\n}\n\t\n    \n      "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef vector <string> VS;\ntypedef pair <int, int> Position;\ntypedef set <Position> Positions;\n\nconst int size = 21;\nint w, h;\nbool O[size][size];\n\nvoid init() {\n    for ( int i = 0; i < size; i++ ) {\n        for ( int j = 0; j < size; j++ ) {\n            O[i][j] = false;\n        }\n    }\n}\n\ntypedef pair <Positions, Position> PPP;\ntypedef pair <int, PPP> Node;\ntypedef priority_queue <Node, vector<Node>, greater<Node> > Queue;\ntypedef map <PPP, int> MPI;\nconst int dr[4] = { 0, 0, 1, -1 };\nconst int dc[4] = { 1, -1, 0, 0 };\n\nint solve( Positions initDC, int sr, int sc ) {\n    Queue Q;\n    Node start( 0, PPP( initDC, Position( sr, sc ) ) );\n    Q.push( start );\n    MPI M;\n    M[PPP( initDC, Position( sr, sc ) )] = 0;\n\n    while ( !Q.empty() ) {\n        Node node = Q.top();\n        Q.pop();\n\n        int cost = node.first;\n        Positions DC = node.second.first;\n        int r = node.second.second.first;\n        int c = node.second.second.second;\n\n        if ( DC.size() == 0 ) {\n            return cost;\n        }\n\n        for ( int i = 0; i < 4; i++ ) {\n            int nextCost = cost + 1;\n            int nr = r + dr[i];\n            int nc = c + dc[i];\n            if ( nr < 0 || nr >= h || nc < 0 || nc >= w ) {\n                continue;\n            }\n            if ( O[nr][nc] ) {\n                continue;\n            }\n            Position nPos( nr, nc );\n            Positions nextDC = DC;\n            if ( nextDC.count( nPos ) ) {\n                nextDC.erase( nPos );\n            }\n            PPP nodeSecond( nextDC, nPos );\n            if ( M.find(nodeSecond) == M.end() ) {\n                M[nodeSecond] = nextCost;\n            }\n            else if ( nextCost >= M[nodeSecond] ) {\n                continue;\n            }\n            M[nodeSecond] = nextCost;\n            Node nextNode( nextCost, nodeSecond );\n            Q.push( nextNode );\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    while ( cin >> w >> h ) {\n        if ( w == 0 && h == 0 ) break;\n        init();\n\n        VS lines(h);\n        for ( int i = 0; i < h; i++ ) {\n            cin >> lines[i];\n        }\n        for ( int i = 0; i < h; i++ ) {\n            for ( int j = 0; j < w; j++ ) {\n                if ( lines[i][j] == 'x' ) {\n                    O[i][j] = true;\n                }\n            }\n        }\n        Positions DC;\n        for ( int i = 0; i < h; i++ ) {\n            for ( int j = 0; j < w; j++ ) {\n                if ( lines[i][j] == '*' ) {\n                    DC.insert( Position( i, j ) );\n                }\n            }\n        }\n        int sr, sc;\n        for ( int i = 0; i < h; i++ ) {\n            for ( int j = 0; j < w; j++ ) {\n                if ( lines[i][j] == 'o' ) {\n                    sr = i;\n                    sc = j;\n                }\n            }\n        }\n\n        cout << solve( DC, sr, sc ) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<bitset>\nusing namespace std;\nstruct st{\n  int x,y,m,c;\n  st(int x,int y,int m,int c) : x(x),y(y),m(m),c(c) {}\n};\nint W,H;\nchar fie[21][21];\nint gomi[21][21];\nint memo[21][21][(1<<10)];\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint bit_max;\nint solve(int x,int y){\n  queue<st> q;\n  while(!q.empty()) q.pop();\n  q.push(st(x,y,0,0));\n  memo[x][y][0]=0;\n  while(!q.empty()){\n    st p = q.front(); q.pop();\n    x = p.x; y = p.y;\n    for(int i=0;i<4;i++){\n      int nx = x+dx[i];\n      int ny = y+dy[i];\n      if(nx < 0 || ny < 0 || nx>=W || ny>=H) continue;\n      if(fie[nx][ny]=='x') continue;\n      if(fie[nx][ny]=='*'){\n\tif( !((1<<gomi[nx][ny]) & p.m) ){\n\t  int next_m = ((1<<gomi[nx][ny]) | p.m);\n\t  if(memo[nx][ny][next_m]!=-1) continue;\n\t  if(bit_max == next_m) return p.c+1;\n\t  memo[nx][ny][next_m]=p.c+1;\n\t  q.push(st(nx,ny,next_m,p.c+1));\n\t}\n      }else{\n\tif(memo[nx][ny][p.m]!=-1) continue;\n\tmemo[nx][ny][p.m]=p.c+1;\n\tq.push(st(nx,ny,p.m,p.c+1));\n      }\n    }\n  }\n  return -1;\n}\nint main(){\n  while(1){\n    int sx,sy;\n    memset(memo,-1,sizeof(memo));\n    memset(gomi,0,sizeof(gomi));\n    cin >> W >> H;\n    if(!W && !H) break;\n    int co=0;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin >> fie[j][i];\n\tif(fie[j][i]=='o'){\n\t  sx=j; sy=i;\n\t}\n\tif(fie[j][i]=='*'){\n\t  gomi[j][i]=co;\n\t  ++co;\n\t}\n      }\n    }\n    bit_max = (1<<co)-1;\n    //    cout << bitset<16>(bit_max) << \"\\n\";\n    cout << solve(sx,sy) << \"\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <queue>\n#include <algorithm>\n#define INF (1<<21)\nusing namespace std;\n\nclass Point{\npublic:\n  int x,y,c;\n  Point(int x = 0,int y = 0,int c = 0):x(x),y(y),c(c){}\n};\n\nint main(){\n  int i,j,k,l,h,w,sum,ans,gomi[20][20],G[11][11];\n  bool f[20][20],f2[20][20];\n  string str;\n  while(1){\n    Point u,v,g;\n    cin >> w >> h;\n    if(h == 0 && w == 0) break;\n    ans = INF;\n    sum = 0;\n\n    for(i=0;i<h;i++){\n      cin >> str;\n      for(j=0;j<w;j++){\n\tgomi[i][j] = -1;\n\tf[i][j] = false;\n\tif(str[j] == 'o') gomi[i][j] = 0;\n\telse if(str[j] == 'x') f[i][j] = true;\n\telse if(str[j] == '*') gomi[i][j] = ++sum;\n      }\n    }\n    \n    for(i=0;i<sum;i++){\n      for(j=i+1;j<=sum;j++){\n\tfor(k=0;k<h;k++){\n\t  for(l=0;l<w;l++){\n\t    f2[k][l] = f[k][l];\n\t    if(gomi[k][l] == i){\n\t      u.y = k;\n\t      u.x = l;\n\t      f2[k][l] = true;\n\t    }\n\t    else if(gomi[k][l] == j){\n\t      g.y = k;\n\t      g.x = l;\n\t    }\n\t  }\n\t}\n\t\n\tqueue <Point> Q;\n\tbool ff = true;\n\tu.c = 0;\n\tQ.push(u);\n\twhile(!Q.empty()){\n\t  u = Q.front();\n\t  Q.pop();\n\t  if(g.x == u.x && g.y == u.y){\n\t    G[i][j] = G[j][i] = u.c;\n\t    ff = false;\n\t    break;\n\t  }\n\t  u.c++;\n\t  int dx[4] = {1,0,-1,0};\n\t  int dy[4] = {0,1,0,-1};\n\t  for(k=0;k<4;k++){\n\t    v = u;\n\t    v.x += dx[k];\n\t    v.y += dy[k];\n\t    if(v.x >= 0 && v.x < w && v.y >= 0 && v.y < h && !f2[v.y][v.x]){\n\t\tf2[v.y][v.x] = true;\n\t\tQ.push(v);\n\t      }\n\t   }\n\t}\n\t  if(ff){\n\t    ans = -1;\n\t    break;\n\t  }\n      }\n\tif(ans == -1) break;\n    }\n    \n      if(ans != -1){\n\tint a[11],be,af,A;\n\tfor(i=0;i<=sum;i++) a[i] = i;\n\tdo{\n\t  if(a[0] == 0){\n\t    A = 0;\n\t    be = a[0];\n\t    for(i=1;i<=sum;i++){\n\t      af = a[i];\n\t      A += G[be][af];\n\t      be = af;\n\t    }\n\t    ans = min(ans,A);\n\t  }\n\t} while(next_permutation(a,a+sum+1));\n      }\n      cout << ans << endl;\n\t\t\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string.h>\n#define f first\n#define s second\n#define inf 100000001\nusing namespace std;\n \nint w,h,d[20][20],ii,sum,map[20][20],a,dp[1<<12][20];\nint x[4]={1,-1,0,0};\nint y[4]={0,0,1,-1};\nchar c[20][20];\nvector<pair<int,int> > v;\npair<int,int> u;\nqueue<pair<int,int> > q;\n \nbool in(int a,int b)\n{\n  if(a<0 || b<0 || a>=h || b>=w)return false;\n  return true;\n}\n/*\nvoid solve()\n{\n  for(int S=0;S<1<<a;S++){\n    fill(dp[S],dp[S]+a,inf);\n  }\n  dp[(1<<a)-1][0]=0;\n \n  for(int S=(1<<a)-2;S>=0;S--){\n    for(int v=0;v<a;v++){\n      for(int u=0;u<a;u++){\n    if(!(S>>u & 1)){\n      dp[S][v]=min(dp[S][v],dp[S|1<<u][u]+map[v][u]);\n    }\n      }\n    }\n  }\n  int ans=inf;\n  for(int i=1;i<a;i++)ans=min(ans,dp[0][i]);\n  if(ans>=inf)cout<<-1<<endl;\n  cout<<ans<<endl;\n}\n*/\n \nint rec(int S,int v)\n{\n  if(dp[S][v]>=0){\n    return dp[S][v];\n  }\n  if(S==(1<<a)-1 && v==0){\n    return dp[S][v]=0;\n  }\n  int res=inf;\n  for(int i=0;i<a;i++){\n    if(!(S>>i&1)){\n      res=min(res,rec(S|1<<i,i)+map[v][i]);\n    }\n  }\n  return dp[S][v]=res;\n}\n \nint main()\n{\n  while(1){\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    v.clear();\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n    cin>>c[i][j];\n    if(c[i][j]=='o')v.push_back(make_pair(i,j));\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n    if(c[i][j]=='*')v.push_back(make_pair(i,j));\n      }\n    }\n    for(int i=0;i<20;i++){\n      for(int j=0;j<20;j++)map[i][j]=0;\n    }\n    for(int k=0;k<v.size();k++){\n      q.push(make_pair(v[k].f,v[k].s));\n      for(int i=0;i<20;i++){\n    for(int j=0;j<20;j++)d[i][j]=inf;\n      }\n      d[v[k].f][v[k].s]=0;\n      while(!q.empty()){\n    u=q.front();q.pop();\n    for(int i=0;i<4;i++){\n      int xx=u.f+x[i],yy=u.s+y[i];\n      if(in(xx,yy)){\n        if(d[xx][yy]!=inf)continue;\n        if(c[xx][yy]!='x'){\n          q.push(make_pair(xx,yy));\n          d[xx][yy]=d[u.f][u.s]+1;\n        }\n      }\n    }\n      }\n      for(int i=0;i<v.size();i++)map[k][i]=d[v[i].f][v[i].s];\n    }\n    a=v.size();\n    memset(dp,-1,sizeof(dp));\n    int ans=inf;\n    for(int i=1;i<a;i++){\n      ans=min(ans,rec(0,i));\n    }\n    if(ans>=inf)cout<<-1<<endl;\n    else cout<<ans<<endl;\n      //solve();\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <string.h>\nusing namespace std;\n\n#define FOR(i, n) for(int i = 0; i < n; i++)\n#define bit(i) static_cast< bitset<8> >(i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long>PLL;\ntypedef queue<int> QI;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue<int, vector<int>, greater<int> > minpq;\n\nstruct edge{int to, cost;};\n\nvoid begin(){cin.tie(0); ios::sync_with_stdio(false);};\nint gcd(int a, int b){if(a%b==0){return(b);}else{return(gcd(b,a%b));}};\nint lcm(int m, int n){if((0 == m)||(0 == n)){return 0;} return ((m / gcd(m, n)) * n);};\nunsigned long long comb(long n, long m){unsigned long long c = 1; m = (n - m < m ? n - m : m);\n    for(long ns = n - m + 1, ms = 1; ms <= m; ns ++, ms ++){c *= ns; c /= ms;} return c;};\n\nvoid cp(int a1[], int a2[], int l){FOR(i, l) a2[i] = a1[i];};\ndouble sq(double d){return d*d;};\nint sq(int i){return i*i;};\ndouble sqdist(int x1, int y1, int x2, int y2){\n    double dx = x1 - x2, dy = y1 - y2; return dx*dx + dy*dy;\n};\n\n// ワーシャルフロイド法\nvoid warshallFloyd(int d[100][100], int n){\n    for(int k = 0; k < n; ++k)\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                if(d[i][k] != -1 && d[k][j] != -1){\n                    if(d[i][j] == -1){\n                        d[i][j] = d[i][k] + d[k][j];\n                    }else{\n                        d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                    }\n                }\n};\n\n\n// d:隣接行列  n:グラフのサイズ  s:始点  dist:始点からの距離が入る配列\nvoid dijkstra(int d[1000][1000], int n, int s, int dist[1000]){\n    FOR(i, n) dist[i] = -1;\n    dist[s] = 0;\n    priority_queue<PII, vector<PII>, greater<PII> > q;\n    q.push(PII(0, s));\n    while (!q.empty()) {\n        PII p = q.top(); q.pop();\n        int i = p.second;\n        if(dist[i] < p.first) continue;\n        for(int j = 0; j < n; j++){\n            if(d[i][j] == -1) continue;\n            if(dist[j] == -1){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }else if(dist[j] > dist[i] + d[i][j]){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }\n        }\n    }\n};\n\n// 線分の交差判定\nbool isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n    // 並行な場合\n    int m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n    if(m == 0) return false;\n    // 媒介変数の値が0より大きく1以下なら交差する、これは問題の状況によって変わるかも。\n    double r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n    double s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n    return (0 < r && r <= 1 && 0 < s && s <= 1);\n};\n\n// 外積の計算 AB CD の内積を求める\nint crossProdct(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy){\n    int abx = bx - ax; int aby = by - ay;\n    int cdx = dx - cx; int cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble crossProdct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble innerProduct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdx + aby * cdy;\n};\n\n// 三角形の内部判定 ABCの中にPがあるか判定\nbool inTriangle(int ax, int ay, int bx, int by, int cx, int cy, int px, int py){\n    int c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    int c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    int c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\nbool inTriangle(double ax, double ay, double bx, double by, double cx, double cy, double px, double py){\n    double c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    double c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    double c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\n\n// 三角形の外心\nvoid circumcenter(double ax, double ay, double bx, double by, double cx, double cy, double res[3]){\n    // AB AC を求める\n    double abx = bx - ax; double aby = by - ay;\n    double acx = cx - ax; double acy = cy - ay;\n    double m = abx * acy - acx * aby; // 分母 m = 0 となるのは3点が一直線になるとき\n    double s = (abx * acx + aby * acy - sq(acx) - sq(acy)) / m; // 媒介変数s\n    res[0] = abx / 2 + s * aby / 2; res[1] = aby / 2 - s * abx / 2;\n    // cout << res[0] << \" \" << res[1] << endl;\n    res[2] = sqrt(sqdist(0, 0, res[0], res[1]));\n    res[0] += ax; res[1] += ay;\n};\n\n\n\n\n/**\n * start\n * @author yoshikyoto\n */\nint w, h;\nstring tile[20];\nint dist[20][20];\nint g[11][11];\nint sx[11], sy[11];\nint dp[1024][11];\nint vy[4] = {-1, 1, 0, 0}, vx[4] = {0, 0, -1, 1};\n\nint dcount = 1;\nint p[11];\n\nvoid dfs(int hist, int curr){\n    for(int next = 1; next < dcount; next++){\n        if(hist & p[next]) continue; // 既に訪れている\n        // 訪れていない\n        int next_hist = hist | p[next];\n        int cost = dp[hist][curr] + g[curr][next];\n        if(cost < dp[next_hist][next] || dp[next_hist][next] == -1){\n            dp[next_hist][next] = cost;\n            dfs(next_hist, next);\n        }\n    }\n};\n\nvoid solve(){\n    FOR(i, h) cin >> tile[i];\n    \n    // 配列をなめて汚れたタイルの位置を獲得、汚れに番号をつける\n    FOR(i, h) FOR(j, w){\n        if(tile[i][j] == '*'){\n            sy[dcount] = i;\n            sx[dcount] = j;\n            tile[i][j] = (char)('0' + dcount); // 汚れに番号を付ける\n            dcount++;\n        }else if(tile[i][j] == 'o'){\n            // 自分の位置\n            sy[0] = i;\n            sx[0] = j;\n            tile[i][j] = '0';\n        }\n    }\n    // グラフの初期化\n    // FOR(i, h) cout << tile[i] << endl;\n    \n    // まずはbfsしてグラフを生成する\n    FOR(i, dcount){\n        FOR(k, h) FOR(l, w) dist[k][l] = -1;\n        dist[sy[i]][sx[i]] = 0;\n        QI yq, xq;\n        yq.push(sy[i]);\n        xq.push(sx[i]);\n        int checked = 1;\n        while(checked < dcount){\n            int y = yq.front(); yq.pop();\n            int x = xq.front(); xq.pop();\n            \n            // 上下左右を見る\n            FOR(j, 4){\n                int ny = y+vy[j], nx = x+vx[j]; // nexty, nextx;\n                if(dist[ny][nx] > -1) continue; // 既に訪れた場合\n                if(ny < 0 || ny > h-1 || nx < 0 || nx > w-1) continue; // 部屋を出てしまう場合\n                int dnum = (int)tile[ny][nx] - '0';\n                if(tile[ny][nx] != 'x'){\n                    // 障害物でない場合\n                    yq.push(ny);\n                    xq.push(nx);\n                    dist[ny][nx] = dist[y][x] + 1;\n                    // グラフに追加したい場\n                    if(0 <= dnum && dnum < dcount){\n                        g[i][dnum] = dist[ny][nx];\n                        checked++;\n                    }\n                }\n            }\n        }\n    }\n    \n    /*\n    FOR(i, dcount){\n        FOR(j, dcount){\n            cout << g[i][j] << \" \";\n        }\n        cout << endl;\n    }\n     */\n    \n    // 行けないところがあったらダメ\n    for(int i = 1; i < dcount; i++)\n        if(g[0][i] == -1){\n            cout << -1 << endl;\n            return;\n        }\n    \n    // メモ化再帰\n    FOR(i, 1024) FOR(j, 11) dp[i][j] = -1;\n    FOR(i, dcount) p[i] = (int)pow(2, i);\n    dp[1][0] = 0;\n    dfs(1, 0);\n    \n    int final = 1;\n    for(int i = 1; i < dcount; i++) final += p[i];\n    \n    int ans = dp[final][1];\n    for(int i = 2; i < dcount; i++){\n        ans = min(ans, dp[final][i]);\n    }\n    cout << ans << endl;\n};\n\nint main(int argc, const char * argv[]){\n    begin();\n    while(true){\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (int)(999999999/2)\n#define eps 1e-9\n#define MAX_N 5000\nint w,h;\nint fie[30][30];\nstring data[30];\n\n\nvoid bfs(int yy,int xx){\n    int dx[]={0,1,0,-1};\n    int dy[]={1,0,-1,0};\n    queue<pii> que;\n    que.push(pii(yy,xx));\n    \n    bool used[30][30]={};\n    while(que.size()){\n        int y=que.front().first,x=que.front().second;\n        que.pop();\n        used[y][x]=true;\n        rep(i,4){\n            int ddy=y+dy[i],ddx=x+dx[i];\n            if(ddy<0||ddx<0||ddy>=h||ddx>=w||data[ddy][ddx]=='x'||used[ddy][ddx])continue;\n            fie[ddy][ddx]=fie[y][x]+1;\n            que.push(pii(ddy,ddx));\n        }\n    }\n}\n\nint main(){\n    while(cin>>w>>h&&w&&h){\n        int v=0;\n        rep(i,h){\n            cin>>data[i];\n        }\n        \n        vector<pii> p;\n        rep(i,h)rep(j,w)if(data[i][j]=='o'){p.pb(pii(i,j));v++;}\n        rep(i,h)rep(j,w)if(data[i][j]=='*'){p.pb(pii(i,j));v++;}\n\n        map<  pair<pii,pii> , int  > pass;\n        rep(i,p.size()){\n            rep(i,30)rep(j,30)fie[i][j]=INF;\n            fie[p[i].first][p[i].second]=0;\n            bfs(p[i].first,p[i].second);\n            rep(j,p.size()){\n                pass[make_pair(p[i],p[j])]=fie[p[j].first][p[j].second];\n            }\n        }\n        \n        vector<int> num;\n        rep(i,v)num.pb(i);\n        sort(all(num));\n        int mini=INF;\n        do{\n            if(num[0]!=0)continue;\n            int sum=0;\n            rep(i,v-1){\n                sum+=pass[  make_pair(p[num[i]],p[num[i+1]])  ];\n            }\n            mini=min(mini,sum);\n        }while(next_permutation(all(num)));\n        if(mini==INF)cout<<\"-1\"<<endl;\n        else cout<<mini<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\n#define MAX 25\n#define INF (1<<29)\ntypedef pair<int,int> P;\n\nint H,W;\nchar field[MAX][MAX];\nvector<P> vec;\nconst int dx[] = {-1,0,0,1};\nconst int dy[] = {0,-1,1,0};\n\nstruct State{\n  int x,y,S;\n  State() {}\n  State(int x,int y,int S) : x(x),y(y),S(S) {}\n};\n\nbool inField(int y,int x){\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nint bfs(int sx,int sy,int gx,int gy){\n  int res = INF;\n  int dist[MAX][MAX];\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      dist[i][j] = INF;\n    }\n  }\n  dist[sy][sx] = 0;\n  queue<P> Q;\n  Q.push(P(sx,sy));\n\n  while(!Q.empty()){\n    P p = Q.front(); Q.pop();\n    if(p.first == gx && p.second == gy){\n      res = dist[gy][gx];\n      break;\n    }\n    for(int i = 0 ; i < 4 ; i++){\n      int nx = p.first + dx[i];\n      int ny = p.second + dy[i];\n      if(!inField(ny,nx)) continue;\n      if(field[ny][nx] == 'x') continue;\n      if(dist[p.second][p.first] + 1 < dist[ny][nx]){\n        dist[ny][nx] = dist[p.second][p.first] + 1;\n        Q.push(P(nx,ny));\n      } \n    }\n  }\n\n  return res;\n}\n\nvoid solve(int x,int y){\n  int size = vec.size(),ans = INF;\n  int dist[MAX][MAX][1<<10];\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      for(int k = 0 ; k < 1<<size ; k++){\n        dist[i][j][k] = INF;\n      }\n    }\n  }\n  dist[y][x][0] = 0;\n  queue<State> Q;\n  Q.push(State(x,y,0));\n  while(!Q.empty()){\n    State now = Q.front(); Q.pop();\n    if(__builtin_popcount(now.S) == size){\n      ans = min(ans,dist[now.y][now.x][now.S]);\n      continue;\n    }\n\n    for(int i = 0 ; i < size ; i++){\n      int S = now.S;\n      if(now.S >> i & 1) continue;\n      S |= 1<<i;\n      int nx = vec[i].second, ny = vec[i].first;\n      int d = bfs(now.x,now.y,nx,ny);\n      if(dist[now.y][now.x][now.S] + d < dist[ny][nx][S]){\n        dist[ny][nx][S] = d + dist[now.y][now.x][now.S];;\n        Q.push(State(nx,ny,S));\n      } \n    }\n  }\n\n  cout << (ans == INF ? -1 : ans) << endl;\n}\n\nint main(){\n  int sx,sy;\n  while(cin >> W >> H, (W | H)){\n    vec.clear();\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> field[i][j];\n        if(field[i][j] == 'o'){\n          sx = j; sy = i;\n        }else if(field[i][j] == '*'){\n          vec.push_back(P(i,j));\n        }\n      }\n    }\n    solve(sx,sy);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\n\nclass Point{\npublic:\n  short x,y,g,c;\n};\n\nint main(){\n  int i,j,h,w,sum,ans,now;\n  bool gomi[20][20],f[11][20][20];\n  string str;\n  while(1){\n    Point u,v;\n    queue <Point> Q;\n    cin >> w >> h;\n    if(h == 0 && w == 0) break;\n    ans = -1;\n    sum = 0;\n    for(i=0;i<h;i++){\n      cin >> str;\n      for(j=0;j<w;j++){\n\tgomi[i][j] = false;\n\tfor(int k=0;k<11;k++) f[k][i][j] = false;\n\tif(str[j] == 'o'){\n\t  u.y = i;\n\t  u.x = j;\n\t}\n\telse if(str[j] == 'x'){\n\t  for(int k=0;k<11;k++) f[k][i][j] = true;\n\t}\n\telse if(str[j] == '*'){\n\t  gomi[i][j] = true;\n\t  sum++;\n\t}\n      }\n    }\n\n    now = 0;\n    u.g = 0;\n    u.c = 0;\n    Q.push(u);\n    while(!Q.empty()){\n      u = Q.front();\n      Q.pop();\n      if(u.g < now) continue;\n\n      f[u.g][u.y][u.x] = true;\n\n      if(gomi[u.y][u.x]){\n\tgomi[u.y][u.x] = false;\n\tu.g++;\n\tnow++;\n      }\n\n      if(u.g == sum){\n\tans = u.c;\n\tbreak;\n      }\n\n      u.c++;\n      f[u.g][u.y][u.x] = true;\n      int dx[4] = {1,0,-1,0};\n      int dy[4] = {0,1,0,-1};\n      for(i=0;i<4;i++){\n\tv = u;\n\tv.x += dx[i];\n\tv.y += dy[i];\n\tif(!f[v.g][v.y][v.x] && v.x >= 0 && v.x < w && v.y >= 0 && v.y < h){\n\t    Q.push(v);\n\t  }\n       }\n    }\n    cout << ans << endl;\n      \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\n#include <functional>\nusing namespace std;\n\ntypedef int W;\n\nconst int MAX_V = 400 * (1 << 10);\nconst W INF = 1 << 20;\n\nstruct edge {\n\tint to;\n\tW cost;\n};\ntypedef pair<W, int> P;\n\nvector<edge> G[MAX_V];\nW d[MAX_V];\n\n\nvoid dijkstra(int s) {\n\tpriority_queue< P, vector<P>, greater<P> > que;\n\tfill(d, d + MAX_V, INF);\n\td[s] = 0;\n\tque.push(P(0, s));\n\twhile(!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tfor(int i = 0; i < G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint w, h;\nstring b[20];\nint wf[400][400];\n\nstruct point {\n\tint x, y;\n};\n\nint v(int x, int y) {\n\treturn w * y + x;\n}\n\nint v2(int x, int y, int s) {\n\treturn s * (h*w) + v(x, y);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> w >> h, w | h) {\n\t\tmemset(wf, INF, sizeof wf);\n\t\tfor(int i = 0; i < 400; i++) {\n\t\t\tfor(int j = 0; j < 400; j++) {\n\t\t\t\tif(i == j) wf[i][i] = 0;\n\t\t\t\telse wf[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < MAX_V; i++) {\n\t\t\tG[i].clear();\n\t\t}\n\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tcin >> b[i];\n\t\t}\n\t\tvector<point> p;\n\t\tint sx = -1, sy = -1;\n\t\tfor(int y = 0; y < h; y++) {\n\t\t\tfor(int x = 0; x < w; x++) {\n\t\t\t\tif(b[y][x] == 'o') {\n\t\t\t\t\tsx = x, sy = y;\n\t\t\t\t}\n\t\t\t\tif(b[y][x] == '*') {\n\t\t\t\t\tp.push_back(point{ x, y });\n\t\t\t\t}\n\t\t\t\tif(b[y][x] != 'x') {\n\t\t\t\t\tint dx[] = { 1, 0, -1, 0 }, dy[] = { 0, 1, 0, -1 };\n\t\t\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\t\t\tif(0 <= nx && nx < w && 0 <= ny && ny < h && b[ny][nx] != 'x') {\n\t\t\t\t\t\t\twf[v(x, y)][v(nx, ny)] = wf[v(nx, ny)][v(x, y)] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int k = 0; k < h*w; k++) {\n\t\t\tfor(int i = 0; i < h*w; i++) {\n\t\t\t\tfor(int j = 0; j < h*w; j++) {\n\t\t\t\t\twf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tp.push_back(point{ sx, sy });\n\t\tfor(int i = 0; i < p.size(); i++) {\n\t\t\tfor(int j = 0; j < p.size(); j++) {\n\t\t\t\tfor(int k = 0; k < 1 << (p.size() - 1); k++) {\n\t\t\t\t\tif(k & (1 << j)) {\n\t\t\t\t\t\tG[v2(p[i].x, p[i].y, k)].push_back(\n\t\t\t\t\t\t\tedge{ v2(p[j].x, p[j].y, k ^ (1 << j)), wf[v(p[i].x, p[i].y)][v(p[j].x, p[j].y)] }\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdijkstra(v2(sx, sy, (1 << (p.size() - 1)) - 1));\n\t\tint ans = INF;\n\t\tfor(int i = 0; i < p.size() - 1; i++) {\n\t\t\tans = min(ans, d[v2(p[i].x, p[i].y, 0)]);\n\t\t}\n\n\t\tif(ans == INF) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nconst int MAX = 100000000;\n\nstruct P{\n\tint x,y;\n} s;\nint w, h;\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nint to[12][12];\nint cnt[21][21];\nstring f[21];\n\nvoid solve(int x, int y, int cnt_,int from ,vector<struct P>& vc){\n\t\n\tfor(int i=0 ; i<4 ; i++ ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ){\n\t\t\tcontinue;\n\t\t}else if( cnt[my][mx] == -1 ){\n\t\t\tcontinue;\n\t\t}else if( cnt[my][mx] > cnt_ ){\n\t\t\tcnt[my][mx] = cnt_;\n\t\t\tif( f[my][mx] == '.' ){\n\t\t\t\tsolve( mx , my , cnt_+1 , from , vc );\n\t\t\t}else if( f[my][mx] == '*' ){\n\t\t\t\tfor(int j=0 ; j < (int)vc.size() ; j++ ){\n\t\t\t\t\tif( vc[j].x == mx && vc[j].y == my ){\n\t\t\t\t\t\tto[from][j+1] = cnt_;\n\t\t\t\t\t\tto[j+1][from] = cnt_;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile( cin >> w >> h , w||h ){\n\t\tvector<struct P> vc;\n\t\tfor(int y=0 ; y<12 ; y++ ){\n\t\t\tfor(int x=0 ; x<12 ; x++ ){\n\t\t\t\tto[y][x] = MAX;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> f[y];\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tif( f[y][x] == 'o' ){\n\t\t\t\t\ts.x = x, s.y = y;\n\t\t\t\t}else if( f[y][x] == '*' ){\n\t\t\t\t\tstruct P p;\n\t\t\t\t\tp.x = x, p.y = y;\n\t\t\t\t\tvc.push_back( p );\t\t\t\t\n\t\t\t\t}else if( f[y][x] == 'x' ){\n\t\t\t\t\tcnt[y][x] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i <= (int)vc.size() ; i++ ){\n\t\t\tfor(int y=0 ; y<21 ; y++ )\n\t\t\t\tfor(int x=0 ; x<21 ; x++ )\n\t\t\t\t\tif( cnt[y][x] != -1 )\n\t\t\t\t\t\tcnt[y][x] = MAX;\n\t\t\tif( i > 0 ){\n\t\t\t\tcnt[ vc[i-1].y ][ vc[i-1].x ] = 0;\n\t\t\t\tsolve( vc[i-1].x , vc[i-1].y , 1 , i , vc );\n\t\t\t}else{\n\t\t\t\tcnt[ s.y ][ s.x ] = 0;\n\t\t\t\tsolve( s.x , s.y , 1 , i , vc );\n\t\t\t}\n\t\t}\n\n\t\tvector<int> vc_;\n\t\tbool flag = true;\n\t\tint ans = MAX;\n\t\tfor(int i=0 ; i < (int)vc.size() ; i++ )\n\t\t\tvc_.push_back( i+1 );\n\t\tdo{\n\t\t\tint ans_ = 0;\n\t\t\tfor(int i=0 ; i < (int)vc_.size() ; i++ ){\n\t\t\t\tif( to[ ((i==0)? 0 : vc_[i-1]) ][ vc_[i] ] == MAX ){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tans_ += to[ ((i==0)? 0 : vc_[i-1]) ][ vc_[i] ];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = min( ans_ , ans );\n\t\t}while( next_permutation( vc_.begin() , vc_.end() ) && flag );\n\t\tcout << ( (flag)? ans : -1 ) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nchar mp[20][20];\nint dist[20][20];\nbool seen[20][20];\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\nconst int inf = 1<<29;\n\nvoid rec(vector< vector<int> > &Y, int i, int S, vector<int> &path) {\n  if(S != 0) rec(Y, Y[i][S], S& ~(1<<i), path);\n  path.push_back(i);\n}\n\nint tsp(int start,vector< vector<int> > G) {\n  const int n = G.size(), N = 1<<n;\n  int i,j;\n  vector< vector<int> > X(n, vector<int>(N, inf));\n  vector< vector<int> > Y(n, vector<int>(N, -1));\n  vector<int> result;\n  rep(i,n) {\n    X[i][1<<i] = G[start][i];\n    Y[i][1<<i] = start;\n  }\n\n  for(int S = 1; S < N; ++S) {\n    rep(i,n) {\n      if(!(S & (1<<i))) continue;\n      rep(j,n) {\n\tif(S & (1<<j)) continue;\n\tif(X[j][S|(1<<j)] > X[i][S]+G[i][j]) {\n\t  X[j][S|(1<<j)] = X[i][S]+G[i][j];\n\t  Y[j][S|(1<<j)] = i;\n\t}\n      }\n    }\n  }\n  result.clear();\n  if(X[start].back() >= inf) return -1;\n  rec(Y, start, (1<<n)-1, result);\n  //rep(i, result.size()) cout<<result[i]<<\" \";\n  //cout<<endl;\n  int mm = max(G[result[1]][start], G[result[result.size()-2]][start]);\n  return X[start].back() - mm;\n}\n\nint main() {\n  int w,h,i,j,k,l,objnum;\n  string s;\n  while(cin>>w>>h, w|h) {\n    objnum = 1;\n    rep(i,h) {\n      cin>>s;\n      rep(j,w) {\n\tmp[i][j] = s[j];\n\tif(s[j] == 'o') mp[i][j] = 0;\n\tif(s[j] == '*') mp[i][j] = objnum++;\n      }\n    }\n\n    vector<vector<int> > G(objnum, vector<int>(objnum, inf));\n    rep(i,objnum) G[i][i] = 0;\n    rep(i,objnum) {\n      int sx,sy;\n      rep(j,h) rep(k,w) if(mp[j][k] == i) sx = k, sy = j;\n      memset(dist, -1, sizeof(dist));\n      memset(seen, false, sizeof(seen));\n      queue<pair<int,int> > Q;\n      Q.push(make_pair(sy,sx));\n      seen[sy][sx] = true;\n      dist[sy][sx] = 0;\n      while(!Q.empty()) {\n\tint x = Q.front().second,y = Q.front().first; Q.pop();\n\trep(l,4) {\n\t  int nx = x+dx[l],ny = y+dy[l];\n\t  if(nx < 0 || nx >= w || ny < 0 || ny >= h || seen[ny][nx]) continue;\n\t  if(mp[ny][nx] == 'x') continue;\n          if(dist[ny][nx] == -1) dist[ny][nx] = dist[y][x]+1;\n\t  else dist[ny][nx] = min(dist[ny][nx],dist[y][x]+1);\n\t  seen[ny][nx] = true;\n\t  Q.push(make_pair(ny,nx));\n\t}\n      }\n\n      rep(j,h) rep(k,w) {\n\tif(0 <= mp[j][k] && mp[j][k] <= objnum) {\n\t  if(dist[j][k] == -1) continue;\n\t  G[mp[j][k]][i] = G[i][mp[j][k]] = dist[j][k];\n\t}\n      }\n    }\n\n      long long ans = tsp(0,G);\n      if(ans >= inf) cout<<-1<<endl;\n      else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<int, int> P;\nint bfs();\nint INF=1000000;\nint w,h;\nint sx,sy;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint d[100][100];\nchar mapp[100][100];\nint main(){\n  int kari;\n  while(1){\n    int yogore=0;\n    int ans=0;\n\n    cin>>w>>h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>mapp[i][j];\n\tif(mapp[i][j]=='*'){\n\t  yogore++;\n\t}else if(mapp[i][j]=='o'){\n\t  sy=i;\n\t  sx=j;\n\t}\n      }\n    }\n    for(int i=0;i<yogore;i++){\n      kari=bfs();\n      if(kari==0){\n\tans=-1;\n\tbreak;\n      }else{\n\tans+=kari;\n      }\n      \n    }\n    cout<<ans<<endl;\n  }\n}\nint bfs(){\n  queue<P> que;\n  que.push(P(sy,sx));\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      d[i][j]=INF;\n    }\n  }\n  d[sy][sx]=0;\n  while(que.size()){\n    P p=que.front();\n    que.pop();\n    if(mapp[p.first][p.second]=='*'){\n      sy=p.first;\n      sx=p.second;\n      mapp[p.first][p.second]='.';\n      break;\n    }\n    for(int i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(0<=nx && nx<w && 0<=ny && ny<h && mapp[ny][nx]!='x' && d[ny][nx]==INF){\n\tque.push(P(ny,nx));\n\td[ny][nx]=d[p.first][p.second]+1;\n      }\n    }\n  }\n  return d[sy][sx];\n}\n\t\n    \n      "
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\n#define REP(i,a,b) for(i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\n#define ll long long\n#define ull unsigned ll\ntypedef long double ld;\n#define ALL(a) (a).begin(),(a).end()\n#define ifnot(a) if(not a)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\nusing namespace std;\n\nvoid reader(int &a) { scanf(\"%d\", &a); }\nvoid reader(double &a) { scanf(\"%lf\", &a); }\nvoid reader(char a[]) { scanf(\"%s\", a); }\nvoid reader(char &a) { scanf(\" %c\", &a); }\nvoid reader(ll &a) { scanf(\"%lld\", &a); }\nvoid reader(ull &a) { scanf(\"%llu\", &a); }\n// void reader(string& a){cin >> a;};\ntemplate<class T, class U> void reader(T& t, U& u) { reader(t); reader(u); }\ntemplate<class T, class U, class V> void reader(T& t, U& u, V& v) { reader(t); reader(u); reader(v); }\n\nvoid writer(const int a, char c) { printf(\"%d\", a); putchar(c); }\nvoid writer(const ll a, char c) { printf(\"%lld\", a); putchar(c); }\nvoid writer(const ull a, char c) { printf(\"%llu\", a); putchar(c); }\nvoid writer(const double a, char c) { printf(\"%.20lf\", a); putchar(c); }\nvoid writer(const char a[]) { printf(\"%s\", a); };\nvoid writer(const char a[], char c) { printf(\"%s\", a); putchar(c); };\nvoid writer(const char a, char c) { putchar(a); putchar(c); };\ntemplate<class T> void writerLn(T t) { writer(t, '\\n'); }\ntemplate<class T, class U> void writerLn(T t, U u) { writer(t, ' '); writer(u, '\\n'); }\ntemplate<class T, class U, class V> void writerLn(T t, U u, V v) { writer(t, ' '); writer(u, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerVec(vector<T> x) { int n = x.size(); int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\n\nvector<string> split(const string &str, char sep) { vector<string> v; stringstream ss(str); string buffer; while (getline(ss, buffer, sep)) { v.push_back(buffer); }return v; }\n// #define int ll\nbool test = 0;\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n#define INF (1 << 28)\null mod = (int)1e9 + 7;\n//.....................\n#define MAX 22\n\n\n\nstruct Node {\n\tint y, x;\n};\nint w, h;\nchar c[MAX][MAX];\nint dm[MAX][MAX];\nvector<Node> nodes;\nint start;\nbool create_distace_matrix() {\n\tint i, j, k;\n\tint y, x;\n\tint cf[MAX][MAX];\n\trep(i, nodes.size()) {\n\t\trep(y, h) rep(x, w) {\n\t\t\tif (c[y][x] == 'x') cf[y][x] = -2;\n\t\t\telse cf[y][x] = -1;\n\t\t}\n\n\t\tcf[nodes[i].y][nodes[i].x] = 0;\n\t\tbool changed = true;\n\t\tint current = 0;\n\t\tfor (; changed; current += 1) {\n\t\t\tchanged = false;\n\t\t\trep(y, h) rep(x, w) {\n\t\t\t\tif (cf[y][x] == current) {\n\t\t\t\t\trep(j, 4) {\n\t\t\t\t\t\tint ny = y + dy[j];\n\t\t\t\t\t\tint nx = x + dx[j];\n\t\t\t\t\t\tif (ny < 0 || h <= ny) continue;\n\t\t\t\t\t\tif (nx < 0 || w <= nx) continue;\n\t\t\t\t\t\tif (cf[ny][nx] == -1) cf[ny][nx] = current + 1;\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(j, nodes.size()) {\n\t\t\tint distance = cf[nodes[j].y][nodes[j].x];\n\t\t\tif (distance < 0) return false;\n\t\t\tdm[i][j] = distance;\n\t\t}\n\t}\n\treturn true;\n}\nbool done[MAX];\nint ans;\nvoid rec(int n, int idx, int sum) {\n\tint i;\n\tif (sum >= ans) return;\n\tif (n == nodes.size()) {\n\t\tif (sum < ans) ans = sum;\n\t\treturn;\n\t}\n\trep(i, nodes.size()) {\n\t\tif (done[i]) continue;\n\t\tdone[i] = true;\n\t\trec(n + 1, i, sum + dm[idx][i]);\n\t\tdone[i] = false;\n\t}\n}\nsigned main(void)\n{\n\tint i, j, k, l;\n\twhile (1) {\n\t\tcin >> w >> h;\n\t\tif (w == 0) return 0;\n\t\trep(i, h) reader(c[i]);\n\t\tnodes.clear();\n\t\trep(i, h) rep(j, w) {\n\t\t\tif (c[i][j] == 'o') start = nodes.size();\n\t\t\tif (c[i][j] == 'o' || c[i][j] == '*') {\n\t\t\t\tnodes.push_back({ i,j });\n\t\t\t}\n\t\t}\n\t\tif (!create_distace_matrix()) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\tans = INT_MAX;\n\t\tdone[start] = true;\n\t\trec(1, start, 0);\n\t\tcout << ans << endl;\n\t\tdone[start] = false;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m; assert(b>=0); for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nint h, w;\nstring s[20];\n\n// (h,w) <-> (y,x)\nint mn(int sy, int sx, int gy, int gx) {\n\tqueue<pair<int,pii>> q;\n\tq.push({0,{sy,sx}});\n\tint d[20][20];\n\trep(i,h) rep(j,w) d[i][j] = inf;\n\td[sy][sx] = 0;\n\twhile (!q.empty()) {\n\t\tint x = q.front().se.se, y = q.front().se.fi, dis = q.front().fi; q.pop();\n\t\tif (d[y][x]<dis) continue;\n\t\trep(i,4) {\n\t\t\tint xx = x + dx[i], yy = y + dy[i];\n\t\t\tif (xx<0 || xx>=w || yy<0 || yy>=h || d[yy][xx]<=dis+1 || s[yy][xx]=='x') continue;\n\t\t\td[yy][xx] = dis+1;\n\t\t\tq.push({dis+1,{yy,xx}});\n\t\t}\n\t}\n\treturn d[gy][gx];\n}\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> w >> h;\n\t\tif (h==0) break;\n\t\tvi ti, tj;\n\t\t// 0: スタート地点\n\t\tint d[11][11] = {};\n\t\trep(i,11) rep(j,11) if (i!=j) d[i][j] = inf;\n\t\trep(i,h) {\n\t\t\tcin >> s[i];\n\t\t\trep(j,w) if (s[i][j]=='o') ti.pb(i), tj.pb(j);\n\t\t}\n\t\trep(i,h) rep(j,w) if (s[i][j]=='*') ti.pb(i), tj.pb(j);\n\t\tint n = ti.size();\n\t\t\n\t\trep(i,n) reps(j,i+1,n) d[i][j] = d[j][i] = mn(ti[i],tj[i],ti[j],tj[j]);\n\t\tbool fin = 0;\n\t\treps(i,1,n) if (d[0][i]==inf) fin = 1;\n\t\tif (fin) {\n\t\t\tcout << -1 << ln;\n\t\t\tcontinue;\n\t\t}\n\t\trep(k,n) rep(i,n) rep(j,n)\n\t\t    chmin(d[i][j], d[i][k]+d[k][j]);\n\t\t// dp[i][j]: 通過済みの点の集合がjであり今点iにいるような状態の最小移動回数\n\t\tint dp[11][1<<11] = {};\n\t\trep(i,n) rep(j,1<<n) dp[i][j] = inf;\n\t\tdp[0][1] = 0;\n\t\trep(i,n) rep(j,1<<n) if (dp[i][j]!=inf)\n\t\t\trep(k,n) if (!(j>>k&1)) chmin(dp[k][j^(1<<k)], dp[i][j]+d[i][k]);\n\t\tint res = inf;\n\t\trep(i,n) chmin(res, dp[i][(1<<n)-1]);\n\t\tcout << res << ln;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <vector>\n#define MAX_WH 20\n\nusing namespace std;\n\nint w, h;\n\nclass Point {\npublic:\n  int x, y;\n  Point(int x=0, int y=0) : x(x), y(y) {}\n  bool operator <(const Point &p) const {\n    if(y != p.y) return y < p.y;\n    if(x != p.x) return x < p.x;\n    return false;\n  }\n\n};\nchar data[MAX_WH][MAX_WH];\n\nclass State {\npublic:\n  vector<Point> pyogore;\n\n  int x, y;\n  int step;\n  State() {\n    step = 0;\n  }\n  bool operator <(const State &s) const {\n    if(x != s.x) return x < s.x;\n    if(y != s.y) return y < s.y;\n    if(pyogore.size() != s.pyogore.size()) \n      return pyogore.size() < s.pyogore.size();\n    for(int i = 0; i < pyogore.size(); i++) {\n      if(pyogore[i] < s.pyogore[i] || s.pyogore[i] < pyogore[i])\n\treturn pyogore[i] < s.pyogore[i];\n    }\n    return false;\n  }\n\n  void next() {\n    step++;\n    del();\n  }\n\n  void del() {\n    Point p(x,y);\n    for(vector<Point>::iterator it = pyogore.begin();\n\tit != pyogore.end(); it++) {\n      if(!(p < *it || *it < p)) {\n\tpyogore.erase(it);\n\tbreak;\n      }\n    }\n  }\n};\n\nint enableFloor;\nchar data2[MAX_WH][MAX_WH];\n\nvoid rec(int x, int y) {\n  const int dx[4] = {1,0,-1,0};\n  const int dy[4] = {0,1,0,-1};\n\n  for(int i = 0; i < 4; i++) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(nx < 0 || nx >= w) continue;\n    if(ny < 0 || ny >= h) continue;\n    if(data2[ny][nx] == 'x') continue;\n    if(data2[ny][nx] == 'x') continue;\n    if(data2[ny][nx] == '*') enableFloor++;\n    data2[ny][nx] = 'x';\n    rec(nx, ny);\n  }\n}\n\nint yogore;\n\nint solve(State s) {\n  queue<State> Q;\n  set<State> visited;\n  const int dx[4] = {1,0,-1,0};\n  const int dy[4] = {0,1,0,-1};\n  State tmp;\n  char floor;\n  Q.push(s);\n  visited.insert(s);\n  while(!Q.empty()) {\n    s = Q.front();\n    if(s.pyogore.size() == 0) return s.step;\n    Q.pop();\n    for(int i = 0; i < 4; i++) {\n      tmp = s;\n      tmp.x = s.x + dx[i];\n      tmp.y = s.y + dy[i];\n      if(tmp.x < 0) continue;\n      if(tmp.x >= w) continue;\n      if(tmp.y < 0) continue;\n      if(tmp.y >= h) continue;\n      if(data[tmp.y][tmp.x] == 'x') continue;\n      tmp.next();\n      if(visited.find(tmp) != visited.end()) continue;\n\n      Q.push(tmp);\n      visited.insert(tmp);\n    }\n  }\n  return -1;\n}\n\nmain() {\n  while(1) {\n    State s;\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    yogore = 0;\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) {\n\tcin >> data[i][j];\n\tdata2[i][j] = data[i][j];\n\tif(data[i][j] == 'o') {\n\t  s.x = j;\n\t  s.y = i;\n\t  data[i][j] = '.';\n\t  data2[i][j] = '.';\n\t} else if(data[i][j] == '*') {\n\t  yogore++;\n\t  s.pyogore.push_back(Point(j,i));\n\t  data[i][j] = '.';\n\t}\n      }\n    }\n    enableFloor = 0;\n\n    rec(s.x, s.y);\n    if(enableFloor != yogore) cout << -1 << endl;\n    else                      cout << solve(s) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\nstruct Pos { int x, y; };\nstruct State { int d, x, y; };\n\nvector<Pos> Node;\nvector<string> B;\nint dist[11][11];\nconst int INF = 1<<29;\n\nint dirs[] = { -1, 0, 1, 0, -1 };\nvoid bfs(int i)\n{\n    Pos p = Node[i];\n    int vis[21][21] = {};\n\n    queue<State> Q;\n    Q.push({ 0, p.x, p.y });\n    while (Q.size()) {\n        State v = Q.front(); Q.pop();\n        if (vis[v.x][v.y]) continue;\n        vis[v.x][v.y] = 1;\n        char b = B[v.y][v.x];\n        if (b >= '0' && b <= '9') {\n            dist[i][b-'0'] = v.d;\n            dist[b-'0'][i] = v.d;\n        }\n\n        loop (4, i) {\n            int x = v.x + dirs[i], y = v.y + dirs[i+1];\n            if (x >= 0 && x < B[0].size() && y >= 0 && y < B.size()) {\n                if (B[y][x] != 'x' && !vis[x][y]) {\n                    Q.push({ v.d + 1, x, y });\n                }\n            }\n        }\n    }\n}\n\nint memo[11][2000];\nint dfs(int curr, int vis)\n{\n    if (memo[curr][vis] != -1) return memo[curr][vis];\n    int n = Node.size();\n    if (vis == ((1 << n) - 1)) return 0;\n    int ans = INF;\n    loop (n, i) {\n        if (vis >> i & 1) continue;\n        ans = min(ans, dist[curr][i] + dfs(i, vis | 1 << i));\n    }\n    memo[curr][vis] = ans;\n    return ans;\n}\n\nint main()\n{\n    while (1) {\nNG:\n        fill(dist[0], dist[10]+11, INF);\n        int w, h; cin >> w >> h;\n        if (!w) break;\n\n        B = vector<string>(h);\n        loop (h, i) cin >> B[i];\n\n        Node = vector<Pos>(1);\n        loop (h, y) loop (w, x) {\n            if (B[y][x] == 'o') {\n                B[y][x] = '0';\n                Node[0] = { x, y };\n            }\n            if (B[y][x] == '*') {\n                B[y][x] = '0' + Node.size();\n                Node.push_back({ x, y });\n            }\n        }\n\n        loop (Node.size(), i) bfs(i);\n\n        loop (Node.size(), i) {\n            if (dist[0][i] == INF) {\n                cout << -1 << endl;\n                goto NG;\n            }\n        }\n\n        fill(memo[0], memo[10] + 2000, -1);\n        cout << dfs(0, 1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<iomanip>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\n#define MAX 1024\n#define N 10\n#define SIZE 22\n\n#define NONE 0\n#define START 1\n#define DIRTY_TILE 2\n#define FURNITURE 3\n\n#define INFTY 1<<16\n\nvoid bfs(int sti, int stj, int map[SIZE][SIZE], int cost_map[SIZE][SIZE]){\n\tconst int di[] = {-1,0,1,0};\n\tconst int dj[] = {0,1,0,-1};\n\tbool vis[SIZE][SIZE]={{false,},};\n\tqueue< pair<int,int> > q;\n\n\tfor(int i = 0; i < SIZE; ++i){\n\t\tfor(int j = 0; j < SIZE; ++j){\n\t\t\tcost_map[i][j] = INFTY;\n\t\t}\n\t}\n\n\tq.push( make_pair(sti,stj) );\n\tcost_map[sti][stj]=0;\n\tvis[sti][stj]=true;\n\twhile(!q.empty()){\n\t\tpair<int,int> t = q.front();\n\t\tq.pop();\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\tint ti = t.first + di[k];\n\t\t\tint tj = t.second + dj[k];\n\t\t\tif( map[ti][tj] != FURNITURE && !vis[ti][tj] ){\n\t\t\t\tcost_map[ti][tj] = cost_map[t.first][t.second] + 1;\n\t\t\t\tvis[ti][tj]=true;\n\t\t\t\tq.push( make_pair(ti,tj) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dp(int n, int ini_cost[N], int cost[N][N] ){\n\tint ret=INFTY;\n\tint w[MAX][N];\n\n\tfor(int state=0;state<(1<<n);++state){\n\t\tfor(int i=0;i<n;++i){\n\t\t\tw[state][i]=INFTY;\n\t\t}\n\t}\n\n\tfor(int i=0;i<n;++i){\n\t\tw[0][i]=ini_cost[i];\n\t}\n\n\tfor(int state=1;state<(1<<n);++state){\n\t\tfor(int i=0;i<n;++i){\n\t\t\tif(!(state&(1<<i))){\n\t\t\t\tfor(int j=0;j<n;++j){\n\t\t\t\t\tif(state&(1<<j)){\n\t\t\t\t\t\tint pre_state=state^(1<<j);\n\t\t\t\t\t\tw[state][i]=min(w[state][i],w[pre_state][j]+cost[j][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=0;i<n;++i){\n\t\tret=min(ret,w[((1<<n)-1)^(1<<i)][i]);\n\t}\n\n\treturn ret;\n}\n\nint CleaningRobot(int h, int w, int map[SIZE][SIZE]){\n\tint cost[N][N];\n\tint ini_cost[N];\n\tint cost_map[SIZE][SIZE];\n\tvector< pair<int, int> > vtiles;\n\n\tfor(int i = 1; i <= h; ++i){\n\t\tfor(int j = 1; j <= w; ++j){\n\t\t\tif( map[i][j] == DIRTY_TILE ){\n\t\t\t\tvtiles.push_back( make_pair( i, j ) );\n\t\t\t}\n\t\t\tif( map[i][j] == START ){\n\t\t\t\tbfs(i,j,map,cost_map);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(unsigned int i = 0; i < vtiles.size(); ++i){\n\t\tini_cost[i]=cost_map[vtiles[i].first][vtiles[i].second];\n\t}\n\n\tfor(unsigned int i = 0; i < vtiles.size(); ++i){\n\t\tbfs(vtiles[i].first,vtiles[i].second,map,cost_map);\n\t\t\n\t\t/*for(int k = 1; k <= h; ++k){\n\t\t\tfor(int l = 1; l <= w; ++l){\n\t\t\t\tcout << setw(4) << cost_map[k][l];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\n\t\tfor(unsigned int j = 0; j < vtiles.size(); ++j){\n\t\t\tcost[i][j] = cost[j][i] = cost_map[vtiles[j].first][vtiles[j].second];\n\t\t\tif(cost[i][j]>=INFTY)return -1;\n\t\t}\n\t}\n\n\tint ret = dp(vtiles.size(),ini_cost,cost);\n\treturn ret>=INFTY?-1:ret;\n}\n\nint main(){\n\twhile(true){\n\t\tint h,w;\n\t\tint map[SIZE][SIZE];\n\t\tcin>>w>>h;\n\t\tif(h==0&&w==0)break;\n\t\tfor(int i=0;i<SIZE;++i){\n\t\t\tfor(int j=0;j<SIZE;++j){\n\t\t\t\tmap[i][j]=FURNITURE;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=h;++i){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tfor(unsigned int j=0;j<s.length();++j){\n\t\t\t\tswitch(s[j]){\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tmap[i][j+1]=NONE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'x':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'o':\n\t\t\t\t\t\tmap[i][j+1]=START;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\tmap[i][j+1]=DIRTY_TILE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << CleaningRobot(h,w,map) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CK(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n#define ll long long;\n\nconst int INF = 1e9;\nconst long long  LLINF = 1e15;\n\nusing namespace std;\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint W,H,sy,sx,dustsNum;\nstring C[25];\n\nint dp[25][25][1050];\nmap<pair<int,int>, int> m;\n\nvoid dfs(int y, int x, int state, int step){\n  if(dp[y][x][state] <= step) return;\n  dp[y][x][state] = step;\n\n  if(state == 0) return;\n\n  REP(k,0,4){\n    int nextY = y + dy[k], nextX = x + dx[k];\n    if(!CK(nextY,0,H) || !CK(nextX,0,W)) continue;\n    if(C[nextY][nextX] == 'x') continue;\n\n    if(C[nextY][nextX] == '*'){\n      int dust = m[make_pair(nextY,nextX)];\n      dfs(nextY, nextX, state&~(1<<dust), step+1);\n    }else{\n      dfs(nextY, nextX, state, step+1);\n    }\n\n  }\n}\n\nint main() {\n  while(1){\n      cin>>W>>H;\n      if(W==0&&H==0) break;\n      dustsNum=0;\n      m.clear();\n      REP(i,0,H){\n        cin>>C[i];\n        REP(j,0,W){\n          if(C[i][j] == 'o') sy = i, sx = j;\n          if(C[i][j] == '*'){\n            m[make_pair(i,j)] = dustsNum;\n            dustsNum++;\n          }\n        }\n      }\n      REP(i,0,H)REP(j,0,W){\n        REP(k,0,(1<<dustsNum)){\n          dp[i][j][k] = INF;\n        }\n      }\n\n      dfs(sy, sx, (1<<dustsNum)-1, 0);\n\n      int ans = INF;\n      REP(i,0,H)REP(j,0,W){\n        ans = min(ans, dp[i][j][0]);\n      }\n\n      if(ans == INF) cout<<-1<<endl;\n      else cout<<ans<<endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int,int> P;\nint W,H;\nint dx[4] = {-1,1,0,0},dy[4] = {0,0,-1,1};\nint dist[12][12] = {},inf = 1e7;\nint visited[21][21] = {};\nint A[11] = {1,2,3,4,5,6,7,8,9,10,11};\nchar F[21][21];\n\n\nbool in(int x,int y){\n    return 1<=x && x<=H && 1<=y && y<=W;\n}\n\nint main(){\n    while(cin >> W >> H && W>0){\n        int id = 1;\n        map<P,int> m;\n        for(int i=1;i<=H;i++){\n            for(int j=1;j<=W;j++){\n                cin >> F[i][j];\n                if(F[i][j]=='*'){\n                    m[{i,j}] = id+1;\n                    id++;\n                }\n                if(F[i][j]=='o') m[{i,j}] = 1;\n            }\n        }\n        for(int i=1;i<=id;i++) for(int j=1;j<=id;j++){dist[i][j] = inf;}\n        for(auto a:m){\n            queue<P> Q;\n            for(int i=1;i<=H;i++) for(int j=1;j<=W;j++) visited[i][j] = inf;\n            Q.push(a.first);\n            visited[a.first.first][a.first.second] = 0;\n            while(!Q.empty()){\n                int x = Q.front().first,y = Q.front().second;\n                Q.pop();\n                for(int i=0;i<4;i++){\n                    int nx = x+dx[i],ny = y+dy[i];\n                    if(in(nx,ny)&&visited[nx][ny]==inf&&F[nx][ny]!='x'){\n                        visited[nx][ny] = visited[x][y]+1;\n                        Q.push({nx,ny});\n                    }\n                }\n            }\n            for(auto b:m){\n                if(a!=b) dist[a.second][b.second] = visited[b.first.first][b.first.second];\n            }\n        }\n        int ans = inf;\n        do{\n            int now = 0;\n            for(int i=0;i<id-1;i++){\n                now += dist[A[i]][A[i+1]];\n            }\n            ans = min(ans,now);\n        }while(next_permutation(A+1,A+id));\n        cout << (ans!=inf? ans:-1) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nchar data[30][30];\n\nint bfs(int sx,int sy,int gx,int gy){\n\tint dist[30][30]={0};\n\tbool done[30][30]={0};\n\t\n\tqueue<pair<int,int> >Q;\n\tdone[sy][sx] = 1;\n\tQ.push(make_pair(sx,sy));\n\twhile(Q.size()){\n\t\tpair<int,int> q = Q.front(); Q.pop();\n\t\tstatic const int dx[] = {1,-1,0,0},dy[]={0,0,-1,1};\n\t\tif(q.first == gx && q.second == gy) return dist[gy][gx];\n\t\trep(i,4){\n\t\t\tint tx = q.first + dx[i] , ty = q.second + dy[i];\n\t\t\tif(data[ty][tx] == 'x')continue;\n\t\t\tif(done[ty][tx])continue;\n\t\t\tdone[ty][tx] = true;\n\t\t\tdist[ty][tx] = dist[q.second][q.first]+1;\n\t\t\tQ.push(make_pair(tx,ty));\n\t\t}\n\t}\n\treturn (1<<21);\n}\nint main(){\n\tint W,H;\n\twhile(cin >> W >> H , W){\n\t\trep(i,30)rep(j,30)data[i][j] = 'x';\n\t\trep(i,H)rep(j,W)\n\t\t\tcin >> data[i+1][j+1];\n\t\tvector< pair<int,int> > pos;\n\t\tint sx,sy;\n\t\trep(i,30)rep(j,30)\n\t\t\tif(data[i][j] == '*') pos.push_back(make_pair(j,i));\n\t\trep(i,30)rep(j,30)\n\t\t\tif(data[i][j] == 'o')sx = j , sy = i;\n\n\t\tint dp[1<<10][10];\n\t\trep(i,1<<10)rep(j,10)dp[i][j] =(1<<21);\n\t\tint n = pos.size();\n\t\trep(i,n){\n\t\t\tdp[1<<i][i] = bfs(sx,sy,pos[i].first,pos[i].second);\n\t\t}\n\t\tint dist[10][10] = {0};\n\t\trep(i,n)rep(j,n)dist[i][j] = bfs(pos[i].first,pos[i].second,pos[j].first,pos[j].second);\n\t\t\n\t\trep(i,1<<n)rep(j,n)rep(k,n)\n\t\t\tdp[i|(1<<k)][k] = min(dp[i|(1<<k)][k],dp[i][j]+dist[j][k]);\n\t\tint ret = (1<<21);\n\t\trep(i,n)ret = min(ret,dp[(1<<n)-1][i]);\n\t\tcout << (ret<(1<<21)?ret:-1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst static int MAX = 20;\nconst static int DT = 11;\nconst static int INFTY = 4001;\n\nclass Edge{\npublic:\n    int target, cost;\n    Edge(int target = 0, int cost = 0) : target(target), cost(cost) {}\n};\n\nint G[DT][DT];\nconst static int dx[4] = {0, -1, 0, 1};\nconst static int dy[4] = {-1, 0, 1, 0};\nchar map[MAX][MAX];\nint dmap[MAX][MAX];\nint dp[DT][(1 << (DT-1))];\nstd::deque<std::pair<int, int> > dpos;\nstd::vector<int> ridx;\nbool isnoRes, visited[DT];\nint W, H, V, ps, len;\n\nvoid bfs(const std::pair<int, int> &p1, const std::pair<int, int> &p2, const int &idx1,\n         const int &idx2) {\n    for (int i = 0; i < H; i++) { for (int j = 0; j < W; j++) dmap[i][j] = INFTY; }\n    dmap[p1.first][p1.second] = 0;\n    std::queue<std::pair<int, int> > q;\n    q.push(p1);\n    int nx, ny;\n    while( !q.empty() ) {\n        std::pair<int, int> p = q.front(); q.pop();\n        if (p == p2) {\n            //add elem to graph\n            G[idx1][idx2] = G[idx2][idx1] = dmap[p.first][p.second];\n            return;\n\n        }\n        for (int i = 0; i < 4; i++) {\n            nx = p.first + dx[i], ny = p.second + dy[i];\n            if (nx >= 0 && nx < H && ny >= 0 && ny < W && map[nx][ny] != 'x' && dmap[nx][ny] == INFTY) {\n                dmap[nx][ny] = dmap[p.first][p.second] + 1;\n                q.push({nx, ny});\n            }\n        }\n    }\n    isnoRes = true;\n}\n\nint solve(std::vector<int> &seq) {\n    int ans = G[0][seq[0]];\n    for (int i = 1; i < ps-1; i++) {\n        ans+= G[seq[i-1]][seq[i]];\n    }\n    return ans;\n}\n\n\nint main() {\n    while(1) {\n        char tmp[MAX+1];\n        std::scanf(\"%d %d\", &W, &H);\n        if (W == 0 && H == 0) break;\n        ps = 0;\n        for (int i = 0; i < H; i++) {\n            std::scanf(\"%s\", tmp);\n            for (int j = 0; j < W; j++) {\n                if (tmp[j] == 'o') { dpos.push_front({i, j}); ps++; }\n                else if (tmp[j] == '*') { dpos.push_back({i, j}); ps++; }\n                map[i][j] = tmp[j];\n            }\n        }\n        isnoRes = false;\n        for (int i = 1; i < ps; i++) {\n            bfs(dpos[0], dpos[i], 0, i);\n        }\n        if (isnoRes) {\n            std::printf(\"%d\\n\", -1);\n        } else {\n            for (int i = 1; i < ps-1; i++) {\n                for (int j = i+1;  j < ps; j++)\n                bfs(dpos[i], dpos[j], i, j);\n            }\n            len = (1 << ps) - 1;\n            std::memset(dp, 0, sizeof (dp));\n            for (int i = 1; i < ps; i++) {\n                ridx.push_back(i);\n            }\n\n            int ans = INFTY;\n            do {\n                ans = std::min(ans, solve(ridx));\n            } while (std::next_permutation(ridx.begin(), ridx.end()));\n            std::printf(\"%d\\n\", ans);\n        }\n        ridx.clear();\n        dpos.clear();\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Last Change: 06/13/2019 23:03:35.\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\n\nnamespace NS {\nvoid LoopUntilZeroInpput() {\n  int hogegegege = 0;\n  while (cin >> hogegegege && hogegegege != 0) {\n  }\n}\n} // namespace NS\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint GetDist(int h, int w, vector<string> &area, pair<int, int> a,\n            pair<int, int> b) {\n\n  vector<vector<int>> visited(h, vector<int>(w, 0));\n\n  queue<pair<int, pair<int, int>>> q;\n  q.push(make_pair(0, a));\n\n  visited[a.first][a.second] = 1;\n\n  while (!q.empty() and q.front().second != b) {\n    int dist = q.front().first;\n    pair<int, int> cur = q.front().second;\n    for (int i = 0; i < 4; ++i) {\n      int nextX = cur.first + dx[i];\n      int nextY = cur.second + dy[i];\n\n      if (nextX < 0 or nextX >= h or nextY < 0 or nextY > w) {\n        continue;\n      }\n\n      if (visited[nextX][nextY] == 0) {\n        visited[nextX][nextY] = 1;\n        if (area[nextX][nextY] != 'x') {\n          q.push(make_pair(dist + 1, make_pair(nextX, nextY)));\n        }\n      }\n    }\n    q.pop();\n  }\n\n  if (q.front().second == b) {\n    return q.front().first;\n  } else {\n    return -1;\n  }\n}\n\nll Solve(const int h, const int w) {\n  vector<pair<int, int>> yogore;\n  pair<int, int> start;\n\n  vector<string> area(h);\n  for (auto &&e : area) {\n    cin >> e;\n  }\n\n  for (int i = 0; i < h; ++i) {\n    for (int j = 0; j < w; ++j) {\n      if (area[i][j] == '*') {\n        yogore.push_back(make_pair(i, j));\n      } else if (area[i][j] == 'o') {\n        start = make_pair(i, j);\n      }\n    }\n  }\n  int yogoSize = yogore.size();\n\n  vector<int> fromStart(yogoSize);\n  vector<vector<int>> eachDist(yogoSize, vector<int>(yogoSize));\n\n  for (int i = 0; i < yogoSize; ++i) {\n    int dist = GetDist(h, w, area, start, yogore[i]);\n\n    if (dist < 0) {\n      return -1;\n    }\n\n    fromStart[i] = dist;\n  }\n\n  for (int i = 0; i < yogoSize; ++i) {\n    for (int j = i; j < yogoSize; ++j) {\n      if (i != j) {\n        int dist = GetDist(h, w, area, yogore[i], yogore[j]);\n        eachDist[i][j] = dist;\n        eachDist[j][i] = dist;\n      }\n    }\n  }\n\n  vector<int> arr(yogoSize);\n  iota(arr.begin(), arr.end(), 0);\n\n  ll ans = numeric_limits<ll>::max();\n  do {\n    ll tmpAns = fromStart[arr[0]];\n    for (int i = 1; i < yogoSize; ++i) {\n      tmpAns += eachDist[arr[i - 1]][arr[i]];\n    }\n    ans = min(ans, tmpAns);\n  } while (next_permutation(arr.begin(), arr.end()));\n\n  return ans;\n}\n\nint main() {\n  int w, h;\n\n  while (cin >> w >> h and w > 0 and h > 0) {\n    cout << Solve(h, w) << endl;\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\nll d[21][21][21][21];\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\nbool isOutOfRange(int x, int y, int h, int w) {\n\treturn x < 0 || x >= w || y <0 || y >=h;\n}\n\nll dp[11][(1<<11)];\n\nint main(){\n\tint w, h;\n\twhile(cin >> w >> h && w && h) {\n\t\tvector<string> s(h);\n\t\trep(i, h) cin >> s[i];\n\t\trep(i, h) rep(j, w) rep(k, h) rep(l, w) d[i][j][k][l] = ((i == k && j == l)? 0LL : (ll)1e18);\n\t\tint _sx, _sy, n = 0;\n\t\tvi X, Y;\n\t\trep(y, h) rep(x, w) {\n\t\t\tif(s[y][x] == '*') {\n\t\t\t\tn++;\n\t\t\t\tX.pb(x);\n\t\t\t\tY.pb(y);\n\t\t\t\t//continue;\n\t\t\t}\n\t\t\telse if(s[y][x] == 'x') continue;\n\t\t\telse if(s[y][x] == 'o') _sx = x, _sy = y;\n\t\t\trep(i, 4) {\n\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\tif(isOutOfRange(nx, ny, h, w) || s[ny][nx] == 'x') continue;\n\t\t\t\td[y][x][ny][nx] = 1LL;\n\t\t\t}\n\t\t}\n\t\trep(ky, h) rep(kx, w) {\n\t\t\trep(sy, h) rep(sx, w) {\n\t\t\t\trep(gy, h) rep(gx, w) {\n\t\t\t\t\td[sy][sx][gy][gx] = min(d[sy][sx][gy][gx], d[sy][sx][ky][kx] + d[ky][kx][gy][gx]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, n) rep(j, (1<<n)) dp[i][j] = 1e18;\n\t\trep(i, n) dp[i][(1<<i)] = d[_sy][_sx][Y[i]][X[i]];//, cout<<\" i : \"<<i<<\" \"<<d[_sy][_sx][Y[i]][X[i]];\n\t\tREP(mask, 1, (1<<n)) {\n\t\t\trep(i, n) {\n\t\t\t\tif((mask & (1 << i)) == 0) continue;\n\t\t\t\trep(j, n) {\n\t\t\t\t\tif((mask & (1 << j))) continue;\n\t\t\t\t\tint nxt = mask | (1 << j);\n\t\t\t\t\tdp[j][nxt] = min(dp[j][nxt], dp[i][mask] + d[Y[i]][X[i]][Y[j]][X[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = 1e18;\n\t\tint gl = (1<< n) -1;\n\t\trep(i, n) {\n\t\t\tans = min(ans, dp[i][gl]);\n\t\t}\n\t\tcout<<(ans==1e18?-1:ans)<<endl;\n\t\t// cout<<_sx<<\" \"<<_sy<<endl;\n\t\t// rep(i, n) cout << \" \"<<X[i]<<\" \"<<Y[i]<<\" \"<<d[_sy][_sx][Y[i]][X[i]]<<endl;\n\t\t// rep(sy, h) rep(sx, w) {\n\t\t// \trep(gy, h) rep(gx, w) {\n\t\t// \t\tcout<<\" (\"<<sx<<\", \"<<sy<<\") -> (\"<<gx<<\", \"<<gy<<\") \"<<d[sy][sx][gy][gx]<<endl;\n\t\t// \t}\n\t\t// }\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nint save[15][15],vis[25][25],n,m,dust,ct,lp,stx,sty,sum,minn;\nint mov[4][2]= {1,0,0,-1,-1,0,0,1};\nchar plate[25][25];\nint visp[15];\n\nstruct status\n{\n    int cnt;\n    int x,y;\n    status(int a,int b,int c)\n    {\n        x = a, y = b, cnt = c;\n    }\n};\nstruct point\n{\n    int x,y;\n} p[15];\n\nqueue<struct status> q;\n\nvoid maek()\n{\n    while(!q.empty())\n    {\n        if(plate[q.front().x][q.front().y]=='*')\n            save[0][ct+1] = q.front().cnt, p[ct+1].x = q.front().x, p[ct+1].y = q.front().y, ct++;\n\n        for(int i=0; i<4; i++)\n        {\n            int tx = q.front().x + mov[i][0], ty = q.front().y + mov[i][1];\n            if(tx >= 0 && tx < m && ty >=0 && ty < n && plate[tx][ty] != 'x' && !vis[tx][ty])\n            {\n                struct status temp(tx, ty, q.front().cnt + 1);\n                vis[tx][ty] = 1;\n                q.push(temp);\n            }\n        }\n        q.pop();\n    }\n}\n\nvoid play(int x, int y, int ord)\n{\n    int ctt = 0;\n    vis[q.front().x][q.front().y] = 1;\n    while(ctt != ct)\n    {\n        if(plate[q.front().x][q.front().y]=='*')\n        {\n            int r;\n            for(r=0; r<ct; r++)\n                if(p[r].x == q.front().x && p[r].y == q.front().y) break;\n            save[ord][r] = q.front().cnt, ctt++;\n        }\n\n        for(int i=0; i<4; i++)\n        {\n            int tx = q.front().x + mov[i][0], ty = q.front().y + mov[i][1];\n            if(tx >= 0 && tx < m && ty >=0 && ty < n && plate[tx][ty] != 'x' && !vis[tx][ty])\n            {\n                struct status temp(tx, ty, q.front().cnt + 1);\n                vis[tx][ty] = 1;\n                q.push(temp);\n            }\n        }\n        q.pop();\n    }\n}\n\n\nvoid dfs(int x,int y,int ore)\n{\n    if(x==y)\n    {\n        minn = minn > sum ? sum : minn;\n    }\n    for(int i=1; i<=ct; i++)\n    {\n        if(!visp[i])\n        {\n            sum += save[ore][i];\n            if(sum > minn) continue;\n            else\n            {\n                x++;\n                visp[i] = 1;\n                dfs(x,y,i);\n                visp[i] = 0;\n                sum -= save[ore][i];\n                x--;\n            }\n        }\n    }\n}\n\n\nint main()\n{\n    while(~scanf(\"%d%d\",&n,&m),n+m)\n    {\n        memset(plate, 0, sizeof(plate)), memset(vis,0,sizeof(vis));\n        getchar();\n        lp = 0, ct = 0;\n        for(int i=0; i<m; i++)\n        {\n            for(int j=0; j<n; j++)\n            {\n                scanf(\"%c\",&plate[i][j]);\n                if(plate[i][j]=='o') stx = i, sty = j;\n                if(plate[i][j]=='*') lp++;\n            }\n            getchar();\n        }\n\n        struct status tm(stx,sty,0);\n        q.push(tm);\n        maek();\n\n        if(ct != lp) printf(\"-1\\n\");\n        else\n        {\n            for(int i=1; i<=ct; i++)\n            {\n                memset(vis,0,sizeof(vis));\n                struct status temp(p[i].x, p[i].y, 0);\n                q.push(temp);\n                play(p[i].x, p[i].y, i);\n                while(!q.empty()) q.pop();\n            }\n            minn = 99999999;\n\n            for(int i=1; i<=ct; i++)\n            {\n                memset(visp,0,sizeof(visp));\n                sum = save[0][i],visp[i] = 1;\n                dfs(1,ct,i);\n            }\n            printf(\"%d\\n\",minn);\n        }\n    }\n    return 0;\n}\n\n\n/*\n\n7 10\n......x\n*...*.x\n.......\n.......\n....*.*\n.......\n.......\n.o.....\n**.....\n..*....\n\n7 5\n.......\n.o...*.\n.......\n.*...*.\n.......\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define inRange(x,a,b) (a <= x && x < b)\nint di[8] = {0,0,1,-1,1,1,-1,-1};\nint dj[8] = {1,-1,0,0,1,-1,1,-1};\n\nchar mat[20][20];\nint h, w;\nvector<pair<int,int>> g;\n\nvector<vector<int>> bfs(int si, int sj){\n    vector<vector<int>> visit(h, vector<int>(w, 1<<30));\n    queue<pair<int, pair<int,int>>> q;\n    q.push({0, {si, sj}});\n    while(!q.empty()){\n        auto p = q.front(); q.pop();\n        int c = p.first, i = p.second.first, j = p.second.second;\n        if(visit[i][j] <= c)    continue;\n        visit[i][j] = c;\n        for(int k = 0; k < 4; k++){\n            int ni = i+di[k], nj = j+dj[k];\n            if(inRange(ni, 0, h) && inRange(nj, 0, w) && mat[ni][nj] != 'x' && c+1 < visit[ni][nj]){\n                q.push({c+1, {ni, nj}});\n            }\n        }\n    }\n    return visit;\n}\n\nint main(){\n    while(cin >> w >> h, w+h){\n        int ri, rj;\n        g.clear();\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> mat[i][j];\n                if(mat[i][j] == 'o')    ri = i, rj = j;\n                if(mat[i][j] == '*')    g.push_back({i, j});\n            }\n        }\n        int gcnt = g.size();\n        vector<vector<int>> dp(gcnt, vector<int>(1<<gcnt, 1<<30));\n        auto p = bfs(ri, rj);\n        bool valid = true;\n        for(int i = 0; i < gcnt; i++){\n            if(p[g[i].first][g[i].second] == 1<<30){\n                valid = false;\n                break;\n            }\n            dp[i][1<<i] = p[g[i].first][g[i].second];\n        }\n\n        if(!valid){\n            cout << -1 << endl;\n            continue;\n        }\n\n        vector<vector<int>> dist(gcnt, vector<int>(gcnt, 1<<30));\n        for(int i = 0; i < gcnt; i++){\n            auto p = bfs(g[i].first, g[i].second);\n            for(int j = 0; j < gcnt; j++){\n                dist[i][j] = p[g[j].first][g[j].second];\n            }\n        }\n\n        for(int s = 0; s < 1<<gcnt; s++){\n            for(int i = 0; i < gcnt; i++){\n                if(((s>>i)&1)==0 || dp[i][s] == 1<<30) continue;\n                for(int j = 0; j < gcnt; j++){\n                    if((s>>j)&1) continue;\n                    dp[j][s|(1<<j)] = min(dp[j][s|(1<<j)], dp[i][s] + dist[i][j]);\n                }\n            }\n        }\n\n        int ans = 1<<30;\n        for(int i = 0; i < gcnt; i++)   ans = min(ans, dp[i][(1<<gcnt)-1]);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cmath>\n\n\nusing namespace std;\n\nint d[400][400] = {};\nint _d[11][11] = {};\nint dp[1 << 11][11] = {};\nint n;\n\nint rec(int s, int v) {\n    if(dp[s][v] >= 0) {\n        return dp[s][v];\n    }\n\n    if(s == (1<<n) - 1 && v== 0) {\n        return dp[s][v];\n    }\n\n    int res = 500000;\n    for(int u = 0; u < n; u++) {\n        if(!(s >> u & 1)) {\n            res = min(res, rec(s | 1<<u, u) + _d[v][u]);\n        }\n    }\n    return dp[s][v] = res;\n}\n\nint main() {\n    while(true) {\n        string c[20];\n        int w,h;\n        cin >> w >> h;\n        if(w == 0 && h == 0) {\n            break;\n        }\n        for(int i = 0; i < h; i++) {\n            cin >> c[i];\n        }\n\n        int size = w*h;\n\n        for(int i = 0; i < size; i++) {\n            for(int j = 0; j < size; j++) {\n                int ix = i%w, iy = i/w, jx = j%w, jy = j/w;\n                if(i == j) d[i][j] = 0;\n                else if(abs(ix - jx) +abs(iy - jy) == 1 && c[iy][ix] != 'x' && c[jy][jx] != 'x') d[i][j] = 1; \n                else d[i][j] = 50000; \n            }\n        }\n        for(int k = 0; k < size; k++) {\n            for(int i = 0; i < size; i++) {\n                for(int j = 0; j < size; j++) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n\n        vector<int> v;\n        int rob;\n        for(int i = 0; i < h; i++) {\n            for(int j = 0; j < w; j++) {\n                if(c[i][j] == 'o') rob = j + (i*w);\n                if(c[i][j] == '*') v.push_back(j + (i*w));\n            }\n        }\n\n        bool unreached = false;\n\n        for(int i = 0; i < v.size(); i++) {\n            if(d[rob][v[i]] >= 50000) {\n                cout << -1 << endl;\n                unreached = true;\n                break;\n            }\n            _d[0][i+1] = d[rob][v[i]];\n            for(int j = 0; j < v.size(); j++) {\n                _d[i+1][j+1] = d[v[i]][v[j]];\n            }\n        }\n        if(unreached) {\n            continue;\n        }\n\n        n = v.size() + 1;\n        for(int i = 0; i <(1 << n); i++) {\n            for(int j = 0; j < n; j++) {\n                dp[i][j] = -1;\n            }\n        }\n\n        cout << rec(0,0)+1 << endl;\n\n\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n\twhile(1){\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif(w == 0) break;\n\t\tchar c[21][21];\n\t\tvector<pair<int, int > > dirty;\n\t\tint sx, sy;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t// cout << i << j << endl;\n\t\t\t\tcin >> c[i][j];\n\t\t\t\tif(c[i][j] == '*') dirty.push_back(make_pair(i, j));\n\t\t\t\tif(c[i][j] == 'o'){\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint kyori[21][21][21][21];\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tfor(int k = 0; k < h; k++){\n\t\t\t\t\tfor(int l = 0; l < w; l++){\n\t\t\t\t\t\tkyori[i][j][k][l] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tqueue<pair<int, int> > qu;\n\t\t\t\tkyori[i][j][i][j] = 0;\n\t\t\t\tqu.push(make_pair(i, j));\n\t\t\t\twhile(!qu.empty()){\n\t\t\t\t\tint x = (qu.front()).first;\n\t\t\t\t\tint y = (qu.front()).second;\n\t\t\t\t\tqu.pop();\n\t\t\t\t\tint dx[4] = {1, 0, -1, 0};\n\t\t\t\t\tint dy[4] = {0, 1, 0, -1};\n\t\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\t\tif(x + dx[k] >= 0 && x + dx[k] < h && y + dy[k] >= 0 && y + dy[k] < w && c[x + dx[k]][y + dy[k]] != 'x' && kyori[i][j][x + dx[k]][y + dy[k]] < 0){\n\t\t\t\t\t\t\tkyori[i][j][x + dx[k]][y + dy[k]] = kyori[i][j][x][y] + 1;\n\t\t\t\t\t\t\tqu.push(make_pair(x + dx[k], y + dy[k]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<int> > result((1 << 10), vector<int>(10, mod));\n\t\tfor(int i = 0; i < dirty.size(); i++){\n\t\t\tresult[(1 << i)][i] = kyori[sx][sy][dirty[i].first][dirty[i].second];\n\t\t}\n\t\tfor(int i = 1; i < (1 << dirty.size()); i++){\n\t\t\tfor(int j = 0; j < dirty.size(); j++){\n\t\t\t\tif((i & (1 << j)) == 0) continue;\n\t\t\t\tfor(int k = 0; k < dirty.size(); k++){\n\t\t\t\t\tif(j == k || (i & (1 << k)) > 0) continue;\n\t\t\t\t\tresult[i | (1 << k)][k] = min(result[i | (1 << k)][k], result[i][j] + kyori[dirty[j].first][dirty[j].second][dirty[k].first][dirty[k].second]);\n\t\t\t\t\t// cout << k << \" \" << kyori[dirty[j].first][dirty[j].second][dirty[k].first][dirty[k].second] << endl;\n\t\t\t\t}\n\t\t\t\t// cout << i << \" \" << j << \" \" << result[i][j] << endl;\n\t\t\t}\n\t\t}\n\t\tint ans = mod;\n\t\tfor(int i = 0; i < dirty.size(); i++){\n\t\t\tans = min(ans, result[(1 << dirty.size()) - 1][i]);\n\t\t}\n\t\tif(ans == mod) ans = -1;\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cxxabi.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define LINF    ((ll)1ll<60)\n#define INF     ((int)1<<30)\n#define EPS     (1e-9)\n#define MOD     (1000000007)\ntemplate<class S,class T>ostream& operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool b=1;for(auto s:t)os<<(exchange(b,0)||strlen(abi::__cxa_demangle(typeid(S).name(),0,0,0))>20?\"\":\" \")<<s;return os<<endl;}\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\t\n\tint w,h;\n\twhile(cin>>w>>h,w){\n\t\tvvi field(h+2,vi(w+2,-1));\n\t\tvector<pii> coor(2,{0,0});\n\t\tint n=1;\n\t\trange(i,1,h+1)range(j,1,w+1){\n\t\t    char c; cin>>c;\n\t\t    if(c=='.') field[i][j]=0;\n\t\t    if(c=='o') {field[i][j]=1;   coor[1]={i,j};}\n\t\t    if(c=='*') {field[i][j]=++n; coor.emplace_back(i,j);}\n\t\t}\n\t\t\n\t\tvvi dist(n,vi(n,INF));\n\t\trep(i,n){\n\t\t    vvi isVisit(h+2,vi(w+2,-1));\n\t\t    queue<tuple<int,int,int>> q;\n\t\t    q.emplace(0,coor[i+1].first,coor[i+1].second);\n\t\t    while(!q.empty()){\n\t\t        int cost,y,x; tie(cost,y,x)=q.front(); q.pop();\n\t\t        if(isVisit[y][x]!=-1) continue;\n\t\t        isVisit[y][x]=cost;\n\t\t        int v[]={1,0,-1,0};\n\t\t        rep(j,4){\n\t\t            int ny=y+v[j], nx=x+v[j^1];\n\t\t            if(ny%(h+1)==0 or nx%(w+1)==0 or field[ny][nx]==-1) continue;\n\t\t            q.emplace(cost+1,ny,nx);\n\t\t        }\n\t\t    }\n\t\t    rep(j,n){\n\t\t        dist[i][j]=dist[j][i]=isVisit[coor[j+1].first][coor[j+1].second];\n\t\t    }\n\t\t}\n\t\t\n\t\tvvi dp(1<<n, vi(n,INF));\n\t\tdp[1][0]=0;\n\t\t\n\t\trange(s,1,1<<n) {    //集合sに対して\n\t\t    rep(curr,n) if(dp[s][curr]!=INF){  //最後に訪れた頂点に対して\n\t\t        rep(next,n) if((s&(1<<next))==0 and dist[curr][next]!=-1){    //次に行く頂点に対して\n\t\t            dp[s|(1<<next)][next]=min(dp[s|(1<<next)][next], dp[s][curr]+dist[curr][next]);\n\t\t            //cout<<\"dp[\"<<bitset<10>(s|(1<<next)).to_string()<<\"][\"<<next<<\"]=\"<<dp[s|(1<<next)][next]<<endl;\n\t\t        }\n\t\t    }\n\t\t}\n\t\t\n\t\tint ans=*min_element(all(dp[(1<<n)-1]));\n\t\tif(ans==INF) cout<<-1<<endl;\n\t\telse cout<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\nsigned main(){\n    ios::sync_with_stdio(false);\n\tcin.tie(0);\n    cout << fixed << setprecision(20);\n\n    int h,w;\n    while(cin>>w>>h){\n        if(h==0) break;\n        string s[h];\n        for(int i=0;i<h;i++){\n            cin>>s[i];\n        }\n        int n = h*w;\n        int dp[n][n]={};\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(j==i) continue;\n                dp[i][j] = 1e9;\n            }\n        }\n        int dx[4] = {0,1,0,-1};\n        int dy[4] = {1,0,-1,0};\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(s[i][j] == 'x') continue;\n                for(int k=0;k<4;k++){\n                    int x = dx[k] + i , y = dy[k]+j;\n                    if(x<0 || x>=h || y<0 || y>=w) continue;\n                    if(s[x][y] == 'x') continue;\n                    dp[i*w+j][x*w+y]=1;\n                }\n            }\n        }\n        for(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++){\n            dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j]);\n        }\n        vector<int> v;\n        int now = 0;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(s[i][j]=='*'){\n                    v.push_back(i*w+j);\n                }\n                if(s[i][j] == 'o') now = i*w+j;\n            }\n        }\n        sort(v.begin(),v.end());\n        int ans = 1e9;\n        bool pos = true;\n        do{\n            int t = now;\n            int ret = 0;\n            for(int i:v){\n                if(dp[t][i]==1e9){\n                    pos = false;\n                    break;\n                }\n                ret += dp[t][i];\n                t = i;\n            }\n            if(pos == false) break;\n            ans = min(ans,ret);\n        }while(next_permutation(v.begin(),v.end()));\n\n        if(ans == 1e9)ans = -1;\n        cout << ans << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int MAX = 21;\nconst int TM = 11;\nconst int INF = (1<<25);\n\nchar F[MAX][MAX];\nint T[(1<<TM)][MAX][MAX];\nint w,h,sx,sy;\nvector<P> Trash;\n\n\nstruct State{\n  int x,y,t,come;\n  \n  State(){}\n  State(int x, int y, int t, int c):x(x),y(y),t(t),come(c){}\n  bool operator < (const State& s) const { return t > s.t;}\n\n};\n\nbool isInside(int x, int y){ return 0<=x&&x<w&&0<=y&&y<h;}\n\nvoid init(){\n  \n  fill(T[0][0],T[0][0]+TM*MAX*MAX,INF);\n  Trash.clear();\n\n}\n\nvoid input(){\n  for(int i = 0; i < h; i++)\n    for(int j = 0; j < w; j++){\n      cin >> F[i][j];\n      if(F[i][j] == 'o'){\n\tsx = j;\n\tsy = i;\n      }\n      if(F[i][j] == '*') Trash.push_back(P(j,i));\n\n    }\n}\n\nint getTrashNum(P p){\n  for(int i = 0; i < Trash.size(); i++)\n    if(Trash[i] == p) return i;\n  return -1;\n}\nvoid solve(){\n\n  priority_queue<State> Q;\n  Q.push(State(sx,sy,0,0));\n  T[0][sy][sx] = 0;\n\n  int dx[] = {0,0,1,-1};\n  int dy[] = {1,-1,0,0};\n\n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n\n    if(T[now.come][now.y][now.x] < now.t) continue;\n    \n    for(int i = 0; i < 4; i++){\n      State nex = now;\n      nex.x += dx[i];\n      nex.y += dy[i];\n      nex.t++;\n\n      if(!isInside(nex.x,nex.y)) continue;\n      if(F[nex.y][nex.x] == 'x') continue;\n\n\n      if(F[nex.y][nex.x] == '*'){\n\tint Tnum = getTrashNum(P(nex.x, nex.y));\n\tnex.come = (nex.come|(1<<Tnum));\n      }\n\n      \n      if(T[nex.come][nex.y][nex.x] > nex.t){\n\tT[nex.come][nex.y][nex.x] = nex.t;\n\tQ.push(nex);\n      }\n    }\n  }\n\n  int ans = INF;\n\n  for(int i = 0; i < Trash.size(); i++)\n    ans = min(ans,T[(1<<Trash.size())-1][Trash[i].second][Trash[i].first]);\n\n  if(ans == INF) cout << -1 << endl;\n  else cout << ans << endl;\n \n}\n  \nint main(){\n\n  while(cin >> w >> h && w+h){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint w,h;\nvector<string> field;\nint dist(pair<int,int> a,pair<int,int> b){\n\tqueue<pair<pair<int,int>,int> > bfs;\n\tset<pair<int,int> > already;\n\tbfs.push(make_pair(a,0));\n\twhile(!bfs.empty()){\n\t\tpair<int,int> pos;\n\t\tint cost;\n\t\ttie(pos,cost)=bfs.front();\n\t\tbfs.pop();\n\t\tint y,x;\n\t\ttie(y,x)=pos;\n\t\tif(y<0||h<=y||x<0||w<=x) continue;\n\t\tif(field[y][x]=='x') continue;\n\t\tif(!already.insert(pos).second) continue;\n\t\tif(pos==b) return cost;\n\t\tint dy[4]={0,0,-1,1},dx[4]={-1,1,0,0};\n\t\tfor(int i=0;i<4;++i)\n\t\t\tbfs.push(make_pair(make_pair(y+dy[i],x+dx[i]),cost+1));\n\t}\n\treturn 1048576;\n}\nint solve(){\n\tcin >> w >> h;\n\tif(!w&&!h) return 0;\n\tfield.resize(h);\n\tfor(int i=0;i<h;++i)\n\t\tcin >> field[i];\n\tpair<int,int> robot;\n\tvector<pair<int,int> > dirty;\n\tfor(int i=0;i<h;++i)\n\t\tfor(int j=0;j<w;++j){\n\t\t\tif(field[i][j]=='o') robot=make_pair(i,j);\n\t\t\tif(field[i][j]=='*') dirty.push_back(make_pair(i,j));\n\t\t}\n\t//init bitdp[state][lastpos]\n\tvector<vector<int> > bitdp;\n\tbitdp.assign(1<<dirty.size(),vector<int>());\n\tfor(int i=0;i<(1<<dirty.size());++i)\n\t\tbitdp[i].assign(dirty.size(),1048576);\n\tfor(int i=0;i<dirty.size();++i){\n\t\tbitdp[1<<i][i]=dist(robot,dirty[i]);\n\t\tif(bitdp[1<<i][i]>8192) return -1;\n\t}\n\tvector<vector<int> > ecost;\n\tecost.assign(dirty.size(),vector<int>());\n\tfor(int i=0;i<dirty.size();++i)\n\t\tecost[i].assign(dirty.size(),1048576);\n\tfor(int i=0;i<dirty.size();++i)\n\t\tfor(int j=0;j<dirty.size();++j)\n\t\t\tecost[i][j]=dist(dirty[i],dirty[j]);\n\tfor(int i=0;i<(1<<dirty.size());++i)\n\t\tfor(int j=0;j<dirty.size();++j){\n\t\t\tif(i&(1<<j)) continue;\n\t\t\tfor(int k=0;k<dirty.size();++k)\n\t\t\t\tif(i&(1<<k)) bitdp[i|(1<<j)][j]=min(bitdp[i|(1<<j)][j],bitdp[i][k]+ecost[k][j]);\n\t\t}\n\tint answer=1048576;\n\tfor(int i=0;i<dirty.size();++i)\n\t\tanswer=min(answer,bitdp[(1<<dirty.size())-1][i]);\n\tif(answer>65536) answer=-1;\n\treturn answer;\n}\nint main() {\n\tfor(;;){\n\t\tint answer=solve();\n\t\tif(answer) cout << answer << endl;\n\t\telse break;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\n\nstring field[25];\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\nint sh;\nint sw;\nmap<i_i, int> dust;\nint numdust;\nint dist[1050][22][22];\n\nstruct query {\n    int state, h, w;\n    query(int a, int b, int c) {\n        state = a;\n        h = b;\n        w = c;\n    }\n};\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        int H, W;\n        cin >> W >> H;\n        if(W == 0) break;\n        dust.clear();\n        numdust = 0;\n        for(int h = 1; h <= H; h++) {\n            cin >> field[h];\n            field[h] = \"&\" + field[h];\n            for(int w = 1; w <= W; w++) {\n                if(field[h][w] == 'o') {\n                    sh = h;\n                    sw = w;\n                }\n                if(field[h][w] == '*') {\n                    dust[{h, w}] = numdust;\n                    numdust++;\n                }\n            }\n        }\n        for(int h = 0; h <= H; h++) {\n            for(int w = 0; w <= W; w++) {\n                for(int bit = 0; bit < (1 << numdust); bit++) {\n                    dist[bit][h][w] = INF;\n                }\n            }\n        }\n        dist[(1 << numdust) - 1][sh][sw] = 0;\n        queue<query> queries;\n        queries.emplace((1 << numdust)-1, sh, sw);\n        bool clear = false;\n        while(!queries.empty()) {\n            query now = queries.front();\n            queries.pop();\n            if(now.state == 0) {\n                cout << dist[now.state][now.h][now.w] << endl;\n                clear = true;\n                break;\n            }\n            for(int k = 0; k <= 3; k++) {\n                int newh = now.h + dh[k];\n                int neww = now.w + dw[k];\n                int newbit = now.state;\n                int newdist = dist[now.state][now.h][now.w] + 1;\n                if(newh <= 0 || newh > H || neww <= 0 || neww > W) continue;\n                if(field[newh][neww] == 'x') continue;\n                if(field[newh][neww] == '*') {\n                    newbit &= ~(1 << dust[{newh, neww}]);\n                }\n                if(dist[newbit][newh][neww] <= newdist) continue;\n                dist[newbit][newh][neww] = newdist;\n                queries.emplace(newbit, newh, neww);\n            }\n        }\n        if(!clear) cout << -1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n\n\nusing namespace std;\n\nconst int INF = 10000000;\n\n// ツ各ツ可伉づェツタツイツδ仰＋ツスツタツーツトツ地ツ点ツづ個つサツづェツつシツづェツづ個甘板づ個仰猟猟」\nint d[21][21][21][21];\nvector<string> field;\npair<int,int> sp;\nvector<pair<int,int> > dartys;\nint w,h;\n\nbool bfs(int sy,int sx){\n\tqueue<pair<int,int> > *prv = new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *nxt = new queue<pair<int,int> >();\n\n\tbool passed[21][21];\n\tfor(int i = 0; i < 21; i++)\n\t\tfill(passed[i],passed[i]+21,false);\n\n\tprv->push(make_pair(sy,sx));\n\n\tint dy[] = {-1,0,0,1};\n\tint dx[] = {0,-1,1,0};\n\n\tbool no = true;\n\tbool fir = false;\n\tint dist = 0;\n\twhile(prv->size()){\n\t\twhile(prv->size()){\n\t\t\tpair<int,int> cp = prv->front();prv->pop();\n\t\t\tif(passed[cp.first][cp.second])\n\t\t\t\tcontinue;\n\t\t\tpassed[cp.first][cp.second]=true;\n\t\t\td[sy][sx][cp.first][cp.second] = dist;\n\n\n\t\t\tif(fir && field[cp.first][cp.second] == '*'){\n\t\t\t\tno = false;\n\t\t\t}\n\t\t\tfir = true;\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tpair<int,int> np = cp;\n\t\t\t\tnp.first += dy[i];\n\t\t\t\tnp.second += dx[i];\n\t\t\t\tif(np.first >= 0 && np.second >= 0 && np.first < h && np.second < w){\n\t\t\t\t\tif(!passed[np.first][np.second] && field[np.first][np.second] != 'x'){\n\t\t\t\t\t\tnxt->push(np);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdist++;\n\t\tswap(prv,nxt);\n\t}\n\tdelete prv,nxt;\n\tif(no){\n\t\treturn false;\n\t}\n\telse\n\t\treturn true;\n}\n\nint dfs(int s,pair<int,int> prv){\n\tif(s == (1 << (int)(dartys.size()))-1){\n\t\treturn 0;\n\t}\n\n\tint minCost = INF;\n\tfor(int i = 0; i < dartys.size(); i++){\n\t\tif(!((1 & (s >> i)) == 1) && d[prv.first][prv.second][dartys[i].first][dartys[i].second] != INF){\n\t\t\tminCost = min(minCost,dfs(s | (1 << i),make_pair(dartys[i].first,dartys[i].second))\n\t\t\t\t+ d[prv.first][prv.second][dartys[i].first][dartys[i].second]);\n\t\t}\n\t}\n\treturn minCost;\n}\n\nint main(){\n\n\twhile(cin >> w >> h && !(w == 0 && h == 0)){\n\t\tfor(int i = 0; i < 21; i++){\n\t\t\tfor(int j = 0; j < 21; j++){\n\t\t\t\tfor(int k = 0; k < 21; k++){\n\t\t\t\t\tfill(d[i][j][k],d[i][j][k]+21,INF);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfield.clear();\n\t\tdartys.clear();\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfield.push_back(str);\n\t\t\tfor(int j = 0; j < str.size(); j++){\n\t\t\t\tif(str[j] == 'o'){\n\t\t\t\t\tsp.first = i;\n\t\t\t\t\tsp.second = j;\n\t\t\t\t}\n\t\t\t\telse if(str[j] == '*'){\n\t\t\t\t\tdartys.push_back(make_pair(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dartys.size()==0){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// ツ各ツ湘ェツ渉環つゥツづァツ深ツつウツ優ツ静ヲツ探ツ催オツづ、ツつサツづェツつシツづェツづ個湘ェツ渉環づ鳴づ個仰猟猟」ツづーツ仰づ淞づつィツつュ\n\t\tif(!bfs(sp.first,sp.second)){\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tbool fff = false;\n\t\tfor(int i = 0; i < dartys.size(); i++){\n\t\t\tif(!bfs(dartys[i].first,dartys[i].second)){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\tfff = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(fff){\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t// ツ渉嘉アツセツーツδ仰スツマツδ督姪「ツ妥ィツづーツ嘉ーツつュ\n\t\tcout << dfs(0,make_pair(sp.first,sp.second)) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<iomanip>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\n#define MAX 1024\n#define N 10\n#define SIZE 22\n\n#define NONE 0\n#define START 1\n#define DIRTY_TILE 2\n#define FURNITURE 3\n\n#define INFTY 1<<16\n\nvoid bfs(int sti, int stj, int map[SIZE][SIZE], int cost_map[SIZE][SIZE]){\n\tconst int di[] = {-1,0,1,0};\n\tconst int dj[] = {0,1,0,-1};\n\tbool vis[SIZE][SIZE]={{false,},};\n\tqueue< pair<int,int> > q;\n\n\tfor(int i = 0; i < SIZE; ++i){\n\t\tfor(int j = 0; j < SIZE; ++j){\n\t\t\tcost_map[i][j] = INFTY;\n\t\t}\n\t}\n\n\tq.push( make_pair(sti,stj) );\n\tcost_map[sti][stj]=0;\n\tvis[sti][stj]=true;\n\twhile(!q.empty()){\n\t\tpair<int,int> t = q.front();\n\t\tq.pop();\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\tint ti = t.first + di[k];\n\t\t\tint tj = t.second + dj[k];\n\t\t\tif( map[ti][tj] != FURNITURE && !vis[ti][tj] ){\n\t\t\t\tcost_map[ti][tj] = cost_map[t.first][t.second] + 1;\n\t\t\t\tvis[ti][tj]=true;\n\t\t\t\tq.push( make_pair(ti,tj) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dp(int n, int ini_cost[N], int cost[N][N] ){\n\tint w[MAX];\n\tint prev[MAX];\n\tw[0]=0;\n\tfor(int state=1;state<(1<<n);++state){\n\t\tw[state]=INFTY;\n\t}\n\tfor(int state=1;state<(1<<n);++state){\n\t\tfor(int i=0;i<n;++i){\n\t\t\tif(state&(1<<i)){\n\t\t\t\tint t;\n\t\t\t\tint pre_state=state^(1<<i);\n\t\t\t\t\n\t\t\t\tif( pre_state == 0 )\n\t\t\t\t\tt = w[pre_state]+ini_cost[i];\n\t\t\t\telse\n\t\t\t\t\tt = w[pre_state]+cost[prev[pre_state]][i];\n\n\t\t\t\tif( w[state]>t ){\n\t\t\t\t\tw[state]=t;\n\t\t\t\t\tprev[state]=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn w[(1<<n)-1];\n}\n\nint CleaningRobot(int h, int w, int map[SIZE][SIZE]){\n\tint cost[N][N];\n\tint ini_cost[N];\n\tint cost_map[SIZE][SIZE];\n\tvector< pair<int, int> > vtiles;\n\n\tfor(int i = 1; i <= h; ++i){\n\t\tfor(int j = 1; j <= w; ++j){\n\t\t\tif( map[i][j] == DIRTY_TILE ){\n\t\t\t\tvtiles.push_back( make_pair( i, j ) );\n\t\t\t}\n\t\t\tif( map[i][j] == START ){\n\t\t\t\tbfs(i,j,map,cost_map);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(unsigned int i = 0; i < vtiles.size(); ++i){\n\t\tini_cost[i]=cost_map[vtiles[i].first][vtiles[i].second];\n\t}\n\n\tfor(unsigned int i = 0; i < vtiles.size(); ++i){\n\t\tbfs(vtiles[i].first,vtiles[i].second,map,cost_map);\n\t\t\n\t\t/*for(int k = 1; k <= h; ++k){\n\t\t\tfor(int l = 1; l <= w; ++l){\n\t\t\t\tcout << setw(4) << cost_map[k][l];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\n\t\tfor(unsigned int j = 0; j < vtiles.size(); ++j){\n\t\t\tcost[i][j] = cost[j][i] = cost_map[vtiles[j].first][vtiles[j].second];\n\t\t\tif(cost[i][j]>=INFTY)return -1;\n\t\t}\n\t}\n\n\tint ret = dp(vtiles.size(),ini_cost,cost);\n\treturn ret>=INFTY?-1:ret;\n}\n\nint main(){\n\twhile(true){\n\t\tint h,w;\n\t\tint map[SIZE][SIZE];\n\t\tcin>>w>>h;\n\t\tif(h==0&&w==0)break;\n\t\tfor(int i=0;i<SIZE;++i){\n\t\t\tfor(int j=0;j<SIZE;++j){\n\t\t\t\tmap[i][j]=FURNITURE;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=h;++i){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tfor(unsigned int j=0;j<s.length();++j){\n\t\t\t\tswitch(s[j]){\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tmap[i][j+1]=NONE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'x':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'o':\n\t\t\t\t\t\tmap[i][j+1]=START;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\tmap[i][j+1]=DIRTY_TILE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << CleaningRobot(h,w,map) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef long long ll;\n\nint d[20][20][1<<10];\nchar s[40][40];\nint id[40][40];\nint dx[]{1,-1,0,0},dy[]{0,0,1,-1};\nstruct st{int a,b,c;};\n\nint main(){\n\tint w,h;\n\twhile(scanf(\"%d%d\",&w,&h),w){\n\t\tint sx,sy;\n\t\tint cnt=0;\n\t\trep(i,h){\n\t\t\tscanf(\"%s\",s[i]);\n\t\t\trep(j,w){\n\t\t\t\tif(s[i][j]=='o')sx=i,sy=j;\n\t\t\t\tif(s[i][j]=='*'){\n\t\t\t\t\tid[i][j]=cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(d,0x3f,sizeof(d));\n\t\td[sx][sy][0]=0;\n\t\tqueue<st>que;\n\t\tque.push({sx,sy,0});\n\t\twhile(!que.empty()){\n\t\t\tst p=que.front();que.pop();\n\t\t\trep(i,4){\n\t\t\t\tint nx=p.a+dx[i],ny=p.b+dy[i];\n\t\t\t\tif(nx<0||nx>=h||ny<0||ny>=w||s[nx][ny]=='x')continue;\n\t\t\t\tint c=p.c;if(s[nx][ny]=='*')c|=1<<id[nx][ny];\n\t\t\t\tif(d[nx][ny][c]==INF){\n\t\t\t\t\td[nx][ny][c]=d[p.a][p.b][p.c]+1;\n\t\t\t\t\tque.push({nx,ny,c});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint Min=INF;\n\t\trep(i,h)rep(j,w){\n\t\t\tMin=min(Min,d[i][j][(1<<cnt)-1]);\n\t\t}\n\t\tif(Min==INF)Min=-1;\n\t\tprintf(\"%d\\n\",Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\n\nLL dist(pair<int, int> p1, pair<int, int> p2, const vector<string> &f) {\n    vector<vector<LL>> cost(f.size(), vector<LL>(f[0].size(), INF));\n    cost[p1.first][p1.second] = 0;\n\n    queue<pair<int, int>> que;\n    que.push(p1);\n\n    while (not que.empty()) {\n        int y = que.front().first;\n        int x = que.front().second;\n        que.pop();\n\n        FOR(i, 0, 4) {\n            int ny = dy4[i] + y;\n            int nx = dx4[i] + x;\n\n            if (inside(ny, nx, (int)f.size(), (int)f[0].size()) and f[ny][nx] != 'x' and cost[ny][nx] > cost[y][x] + 1) {\n                cost[ny][nx] = cost[y][x] + 1;\n                que.push(make_pair(ny, nx));\n            }\n        }\n    }\n\n    return cost[p2.first][p2.second];\n}\n\nint main() {\n    cin.tie(0);\n\tios::sync_with_stdio(false);\n\n    while (true) {\n        int W, H;\n        cin >> W >> H;\n        if (W == 0 and H == 0) {\n            break;\n        }\n\n        vector<pair<int, int>> v;\n        vector<string> f(H);\n        int sy, sx;\n        FOR(i, 0, H) {\n            cin >> f[i];\n            FOR(j, 0, W) {\n                if (f[i][j] == 'o') {\n                    sy = i;\n                    sx = j;\n                }\n                if (f[i][j] == '*') {\n                    v.emplace_back(make_pair(i, j));\n                }\n            }\n        }\n\n        if (v.size() == 0) {\n            print(0);\n            continue;\n        }\n\n        LL ans = INF;\n        sort(ALL(v));\n        do {\n            LL d = dist(make_pair(sy, sx), v[0], f);\n            FOR(i, 0, v.size() - 1) {\n                d += dist(v[i], v[i + 1], f);\n            }\n            ans = min(ans, d);\n\n        } while(next_permutation(ALL(v)));\n\n        if (ans == INF) {\n            print(-1);\n        }\n        else {\n            print(ans);\n        }\n\n    }\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <complex>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define EPS 1e-8\n#define DEB 0\n\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {-1,0,1,0};\nint w,h,sx,sy;\nchar field[32][32];\nvector<pair<int,int> > t_node;\nint node[16][16],visited[16][16];\nint dp[1<<10][16];\n\nint main(){\n\t\n\twhile(scanf(\" %d%d \",&w,&h),w|h){\n\t\tmemset(node,0,sizeof(node));\n\t\trep(i,1<<10)rep(j,16)dp[i][j]=INT_MAX;\n\t\t\n\t\tt_node.clear();\n\t\trep(i,h){\n\t\t\tscanf(\"%s\",field[i]);\n\t\t\trep(j,w){\n\t\t\t\tif( field[i][j]=='o' ){\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}else if( field[i][j]=='*' ){\n\t\t\t\t\tt_node.push_back(mp(j,i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tt_node.push_back(mp(sx,sy));\n#if DEB\n\t\trep(i,t_node.size()){\n\t\t\tprintf(\"(%d,%d)\\n\",t_node[i].first, t_node[i].second);\n\t\t}\n#endif\t\n\t\t\n\n\t\t// make node (bfs)\n\t\trep(i,t_node.size()){\n\t\t\tmemset(visited,-1,sizeof(visited));\n\t\t\tqueue<pair<int,int> > q;\n\t\t\tq.push(mp(t_node[i].first, t_node[i].second));\n\t\t\tvisited[t_node[i].second][t_node[i].first] = 0;\n\t\t\twhile( !q.empty() ){\n\t\t\t\tint x = q.front().first;\n\t\t\t\tint y = q.front().second;\n\t\t\t\tint c = visited[y][x];\n\t\t\t\tq.pop();\n\t\t\t\trep(k,4){\n\t\t\t\t\tint tx = x + dx[k];\n\t\t\t\t\tint ty = y + dy[k];\n\t\t\t\t\tif( tx<0 || ty<0 || tx>=w || ty>=h || field[ty][tx]=='x' || visited[ty][tx]!=-1 )continue;\n\t\t\t\t\tvisited[ty][tx] = c+1;\n\t\t\t\t\tq.push(mp(tx,ty));\n\t\t\t\t}\n\t\t\t}\n#if DEB\n\t\t\trep(j,h){\n\t\t\t\trep(k,w){\n\t\t\t\t\tprintf(\"%d \",visited[j][k]);\n\t\t\t\t}\n\t\t\t\tputs(\"\");\n\t\t\t}\n\t\t\tputs(\"\");\n#endif\t\t\t\n\t\t\t\n\t\t\trep(j,t_node.size())if( i!=j ){\n\t\t\t\tnode[i][j] = visited[t_node[j].second][t_node[j].first];\n\t\t\t}\n\t\t}\n\n#if DEB\t\t\n\t\trep(i,5){\n\t\t\trep(j,5){\n\t\t\t\tprintf(\"%d \",node[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\tputs(\"\");\n#endif\t\t\n\t\t\t\n\n#if DEB\n\t\trep(i,h){\n\t\t\tputs(field[i]);\n\t\t}puts(\"\");\n#endif\n\n\t\tint n = t_node.size();\n\t\tint ans = INT_MAX;\n\t\tdp[0][n-1] = 0;\n\t\trep(i,n-1){ //kosuu\n\t\t\trep(j,1<<(n-1)){ //bit dp\n\t\t\t\trep(k,n)if( dp[j][k]!=INT_MAX ){ //now node\n\t\t\t\t\trep(l,n-1)if( !((1<<l)&j) && node[k][l] ){\n\t\t\t\t\t\tdp[j|(1<<l)][l] = min(dp[j|(1<<l)][l], dp[j][k]+node[k][l]);\n\t\t\t\t\t\tif( (j|(1<<l))==((1<<(n-1))-1) ){\n\t\t\t\t\t\t\tans = min(ans, dp[(1<<(n-1))-1][l]);\n\t\t\t\t\t\t}\n#if DEB\n\t\t\t\t\t\tprintf(\"bit:%d  , %d --> %d  , cost:%d\\n\",j|(1<<l),k,l,dp[j|(1<<l)][l]);\n#endif\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#if DEB\n\t\tprintf(\"%d\\n\",(1<<(n-1))-1);\n#endif\t\t\n\t\tprintf(\"%d\\n\",ans==INT_MAX ? -1 : ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    while(true){\n        int w,h;\n        cin >> w >> h;\n        if(w==0 and h==0) break;\n        vector<vector<char>> c(h,vector<char>(w));\n        int start,cnt=0;\n        map<int,int> m;\n        rep(i,0,h) rep(j,0,w){\n            cin >> c[i][j];\n            if(c[i][j]=='o'){\n                start=cnt;\n                m[i*w+j]=cnt;\n                ++cnt;\n            }\n            if(c[i][j]=='*'){\n                m[i*w+j]=cnt;\n                ++cnt;\n            }\n        }\n\n        vector<vector<pii>> graph(cnt);\n        rep(i,0,h) rep(j,0,w){\n            if(c[i][j]!='o' and c[i][j]!='*') continue;\n            vector<vector<bool>> done(h,vector<bool>(w,false));\n            queue<pii> que;\n            done[i][j]=true;\n            que.push(make_pair(0,w*i+j));\n            while(!que.empty()){\n                const auto p=que.front();\n                que.pop();\n                const int y=p.second/w,x=p.second%w;\n                if(c[y][x]=='o' or c[y][x]=='*') graph[m[w*i+j]].emplace_back(make_pair(p.first,m[w*y+x]));\n                rep(k,0,4){\n                    const int ny=y+dy[k],nx=x+dx[k];\n                    if(ny<0 or h<=ny or nx<0 or w<=nx or c[ny][nx]=='x' or done[ny][nx]) continue;\n                    que.push(make_pair(p.first+1,w*ny+nx));\n                    done[ny][nx]=true;\n                }\n            }\n        }\n\n        typedef tuple<int,int,int> triple;\n        vector<vector<int>> dist(cnt,vector<int>(1<<cnt,inf));\n        priority_queue<triple,vector<triple>,greater<triple>> que;\n        dist[start][1<<start]=0;\n        que.push(make_tuple(0,start,1<<start));\n        while(!que.empty()){\n            const auto tri=que.top();\n            que.pop();\n            const int d=get<0>(tri),v=get<1>(tri),s=get<2>(tri);\n            if(d>dist[v][s]) continue;\n            for(const auto& e:graph[v]){\n                if((s>>e.second)&1) continue;\n                const int tmp_d=d+e.first;\n                if(tmp_d>dist[e.second][s|(1<<e.second)]) continue;\n                dist[e.second][s|(1<<e.second)]=tmp_d;\n                que.push(make_tuple(tmp_d,e.second,s|(1<<e.second)));\n            }\n        }\n        int ans=inf;\n        rep(i,0,cnt) ans=min(ans,dist[i][(1<<cnt)-1]);\n        if(ans==inf) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<queue>\n#include<algorithm>\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define INF 100000000\nusing namespace std;\ntypedef pair<int,int> P;\nvector<string> s;\nint w,h;\nvector<P> p;\nvector<vector<int> > dist;\nmap<P,int> mp;\nvector<int> dp;\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nbool inf(int y,int x){\n\tif(x>=0&&x<w&&y>=0&&y<h)\n\treturn true;\n\treturn false;\n}\nint TSP(int now,int bit){\n\tif(bit==(1<<p.size())-1){\n\t\treturn 0;\n\t}\n\tif(dp[bit]!=-1)\n\t\treturn dp[bit];\n\tint ret=INF;\n\tfor(int i=1;i<p.size();i++){\n\t\tif( !( (1<<i) &bit ) ){\n\t\t\tret=min(TSP(i,bit|(1<<i))+dist[now][i],ret);\n\t\t}\n\t}\n\t\n\treturn dp[bit]=ret;\n}\nint main(){\n\twhile(cin>>w>>h,w||h){\n\t\tdist=vector<vector<int> >(h,vector<int>(w,INF));\n\t\ts.resize(h);\n\t\tp.resize(1);\n\t\tmp.clear();\n\t\tp[0]=P(0,0);\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>s[i];\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(s[i][j]=='o'){\n\t\t\t\t\tp[0]=P(i,j);\n\t\t\t\t\tmp[P(i,j)]=0;\n\t\t\t\t}else if(s[i][j]=='*'){\n\t\t\t\t\tmp[P(i,j)]=p.size();\n\t\t\t\t\tp.pb(P(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag=true;\n\t\tfor(int i=0;i<p.size();i++){\n\t\t\tqueue<P> que;\n\t\t\tvector<vector<int> > d(h,vector<int>(w,INF));\n\t\t\td[p[i].first][p[i].second]=0;\n\t\t\tque.push(p[i]);\n\t\t\tint cnt=0;\n\t\t\twhile(!que.empty()){\n\t\t\t\tP t=que.front();\n\t\t\t\tque.pop();\n\t\t\t\tif(find(all(p),t)!=p.end()&&dist[i][mp[t]]==INF){\n\t\t\t\t\tdist[i][mp[t]]=d[t.first][t.second];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint nx=dx[i]+t.second,ny=dy[i]+t.first;\n\t\t\t\t\tif(inf(ny,nx)&&d[ny][nx]==INF&&s[ny][nx]!='x'){\n\t\t\t\t\t\tque.push(P(ny,nx));\n\t\t\t\t\t\td[ny][nx]=d[t.first][t.second]+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt!=p.size()){\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag){\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tdp=vector<int>((1<<p.size()),-1);\n\t\tcout<<TSP(0,1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, P> P2;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint DX[4] = {-1, 0, 1, 0};\nint DY[4] = {0, -1, 0, 1};\n\nint K;\nint W, H;\nchar S[20][20];\nint id[20][20];\nint dp[20][20][1<<10];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  while (cin >> W >> H) {\n    if (W == 0 && H == 0) break;\n\n    K = 0;\n    int sx = -1, sy = -1;\n    rep(y, H) {\n      rep(x, W) {\n        cin >> S[x][y];\n        if (S[x][y] == 'o') sx = x, sy = y;\n        if (S[x][y] == '*') id[x][y] = K++;\n      }\n    }\n    rep(i, W) {\n      rep(j, H) {\n        rep(k, 1<<K) {\n          dp[i][j][k] = INF;\n        }\n      }\n    }\n\n    queue<P2> q;\n    q.push(P2(P(sx, sy), P(0, 0)));\n    dp[sx][sy][0] = 0;\n\n    while (!q.empty()) {\n      P2 p = q.front(); q.pop();\n      int x, y, b, d;\n      tie(x, y) = p._1;\n      tie(b, d) = p._2;\n      rep(k, 4) {\n        int nx = x+DX[k], ny = y+DY[k];\n        if (nx<0 || nx>=W || ny<0 || ny>=H) continue;\n        if (S[nx][ny] == 'x') continue;\n        int nb = b;\n        if (S[nx][ny] == '*') nb |= (1<<id[nx][ny]);\n        if (dp[nx][ny][nb] > d+1) {\n          dp[nx][ny][nb] = d+1;\n          q.push(P2(P(nx, ny), P(nb, d+1)));\n        }\n      }\n    }\n\n    int m = INF;\n    rep(i, W) {\n      rep(j, H) {\n        m = min(m, dp[i][j][(1<<K)-1]);\n      }\n    }\n    if (m == INF) cout << -1 << \"\\n\";\n    else cout << m << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cxxabi.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define LINF    ((ll)1ll<60)\n#define INF     ((int)1<<30)\n#define EPS     (1e-9)\n#define MOD     (1000000007)\ntemplate<class S,class T>ostream& operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool b=1;for(auto s:t)os<<(exchange(b,0)||strlen(abi::__cxa_demangle(typeid(S).name(),0,0,0))>20?\"\":\" \")<<s;return os<<endl;}\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\t\n\tint w,h;\n\twhile(cin>>w>>h,w){\n\t\tvvi field(h+2,vi(w+2,-1));\n\t\tvector<pii> coor(2,{0,0});\n\t\tint n=1;\n\t\trange(i,1,h+1)range(j,1,w+1){\n\t\t    char c; cin>>c;\n\t\t    if(c=='.') field[i][j]=0;\n\t\t    if(c=='o') {field[i][j]=1;   coor[1]={i,j};}\n\t\t    if(c=='*') {field[i][j]=++n; coor.emplace_back(i,j);}\n\t\t}\n\t\t\n\t\tvvi dist(n,vi(n));\n\t\trep(i,n){\n\t\t    vvi isVisit(h+2,vi(w+2,-1));\n\t\t    queue<tuple<int,int,int>> q;\n\t\t    q.emplace(0,coor[i+1].first,coor[i+1].second);\n\t\t    while(!q.empty()){\n\t\t        int cost,y,x; tie(cost,y,x)=q.front(); q.pop();\n\t\t        if(isVisit[y][x]!=-1) continue;\n\t\t        isVisit[y][x]=cost;\n\t\t        int v[]={1,0,-1,0};\n\t\t        rep(j,4){\n\t\t            int ny=y+v[j], nx=x+v[j^1];\n\t\t            if(ny%(h+1)==0 or nx%(w+1)==0 or field[ny][nx]==-1) continue;\n\t\t            q.emplace(cost+1,ny,nx);\n\t\t        }\n\t\t    }\n\t\t    rep(j,n){\n\t\t        dist[i][j]=dist[j][i]=isVisit[coor[j+1].first][coor[j+1].second];\n\t\t    }\n\t\t}\n\t\t\n\t\tvvi dp(1<<n, vi(n,INF));\n\t\tdp[1][0]=0;\n\t\t\n\t\trange(s,1,1<<n) {    //集合sに対して\n\t\t    rep(curr,n) if(dp[s][curr]!=INF){  //最後に訪れた頂点に対して\n\t\t        rep(next,n) if((s&(1<<next))==0){    //次に行く頂点に対して\n\t\t            dp[s|(1<<next)][next]=min(dp[s|(1<<next)][next], dp[s][curr]+dist[curr][next]);\n\t\t            //cout<<\"dp[\"<<bitset<10>(s|(1<<next)).to_string()<<\"][\"<<next<<\"]=\"<<dp[s|(1<<next)][next]<<endl;\n\t\t        }\n\t\t    }\n\t\t}\n\t\t\n\t\tint ans=*min_element(all(dp[(1<<n)-1]));\n\t\tif(ans==INF) cout<<-1<<endl;\n\t\telse cout<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint W,H,index[20][20],dp[20][20][1024],fin_state;\nchar table[20][21];\n\nstruct Info{\n\tInfo(){\n\t\trow = 0;\n\t\tcol = 0;\n\t\tstate = 0;\n\t\tcost = 0;\n\t}\n\n\tInfo(int arg_row,int arg_col,int arg_state,int arg_cost){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tstate = arg_state;\n\t\tcost = arg_cost;\n\t}\n\tint row,col,state,cost;\n};\n\nInfo start,Target[10];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0},target_count,next_state;\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nbool enable_check(int start_row,int start_col){\n\tbool visited[20][20];\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++)visited[i][k] = false;\n\t}\n\n\tqueue<Info> S;\n\tvisited[start_row][start_col] = true;\n\n\tS.push(Info(start_row,start_col,0,0));\n\n\tint to_row,to_col;\n\n\twhile(!S.empty()){\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tto_row = S.front().row + diff_row[i];\n\t\t\tto_col = S.front().col + diff_col[i];\n\n\t\t\tif(rangeCheck(to_row,to_col) == false || visited[to_row][to_col] == true || table[to_row][to_col] == 'x')continue; //?????????????????????????????£????????¨???????????????????????????????????????skip\n\n\t\t\tvisited[to_row][to_col] = true;\n\t\t\tS.push(Info(to_row,to_col,0,0));\n\t\t}\n\n\t\tS.pop();\n\t}\n\n\tfor(int i = 0; i < target_count; i++){\n\t\tif(visited[Target[i].row][Target[i].col] == false)return false;\n\t}\n\n\treturn true;\n}\n\nint main(){\n\n\tint ans,next_row,next_col;\n\tqueue<Info> Q;\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\ttarget_count = 0;\n\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tscanf(\"%s\",table[i]);\n\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\tswitch(table[i][k]){\n\t\t\t\tcase '.':\n\t\t\t\t\t//Do nothing\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\tindex[i][k] = target_count;\n\t\t\t\t\tTarget[target_count].row = i;\n\t\t\t\t\tTarget[target_count].col = k;\n\t\t\t\t\ttarget_count++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'x':\n\t\t\t\t\t//Do nothing\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'o':\n\t\t\t\t\tstart.row = i;\n\t\t\t\t\tstart.col = k;\n\t\t\t\t\tstart.state = 0;\n\t\t\t\t\tstart.cost = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!enable_check(start.row,start.col)){\n\t\t\tprintf(\"-1\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\tfor(int p = 0; p < pow(2,target_count);p++)dp[i][k][p] = BIG_NUM;\n\t\t\t}\n\t\t}\n\n\t\tfin_state = pow(2,target_count)-1;\n\n\t\twhile(!Q.empty())Q.pop();\n\n\t\tans = BIG_NUM;\n\n\t\tdp[start.row][start.col][0] = 0;\n\t\tQ.push(start);\n\n\t\twhile(!Q.empty()){\n\n\t\t\tif(Q.front().state == fin_state){\n\t\t\t\tans = Q.front().cost;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(Q.front().cost != dp[Q.front().row][Q.front().col][Q.front().state]){\n\t\t\t\tQ.pop();\n\t\t\t\tcontinue;\n\t\t\t}else{\n\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tnext_row = Q.front().row + diff_row[i];\n\t\t\t\t\tnext_col = Q.front().col + diff_col[i];\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == false || table[next_row][next_col] == 'x')continue;\n\n\t\t\t\t\tif(table[next_row][next_col] == '.' || table[next_row][next_col] == 'o'){\n\t\t\t\t\t\tif(dp[Q.front().row][Q.front().col][Q.front().state] + 1 < dp[next_row][next_col][Q.front().state]){\n\t\t\t\t\t\t\tdp[next_row][next_col][Q.front().state] = dp[Q.front().row][Q.front().col][Q.front().state] + 1;\n\t\t\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().state,dp[next_row][next_col][Q.front().state]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\tif(Q.front().state & (1 << index[next_row][next_col])){\n\n\t\t\t\t\t\t\tif(dp[Q.front().row][Q.front().col][Q.front().state] + 1 < dp[next_row][next_col][Q.front().state]){\n\t\t\t\t\t\t\t\tdp[next_row][next_col][Q.front().state] = dp[Q.front().row][Q.front().col][Q.front().state] + 1;\n\t\t\t\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().state,dp[next_row][next_col][Q.front().state]));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tnext_state = Q.front().state + pow(2,index[next_row][next_col]);\n\t\t\t\t\t\t\tif(dp[Q.front().row][Q.front().col][Q.front().state] + 1 < dp[next_row][next_col][next_state]){\n\t\t\t\t\t\t\t\tdp[next_row][next_col][next_state] = dp[Q.front().row][Q.front().col][Q.front().state] + 1;\n\t\t\t\t\t\t\t\tQ.push(Info(next_row,next_col,next_state,dp[next_row][next_col][next_state]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\n\t\tif(ans == BIG_NUM)printf(\"-1\\n\");\n\t\telse{\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vbb;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst double inf = (int)1e8;\n\ntypedef pair<int, int> P;\n\nchar maze[30][30 + 1]; // 迷路を表す文字列の配列 int N, M;\nvector<pair<int, int> >g;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint n, m;\nint q[30][30];\nint dp[1 << 11][11];\n\nint bfs(int sx, int sy, int gx, int gy){\n    int d[30][30];\n    queue<P> que;\n    rep(i,n)rep(j, m) d[i][j] = inf;\n\n    que.push(P(sx, sy));\n    d[sx][sy] = 0;\n\n    while(que.size()){\n        P p = que.front(); que.pop();\n        if(p.first == gx && p.second == gy) break;\n\n        rep(i, 4){\n            int nx = p.first + dx[i], ny = p.second + dy[i];\n            if (0 <= nx && nx < n && 0 <= ny && ny < m && maze[nx][ny] != 'x' && d[nx][ny] == inf) {\n                que.push(P(nx, ny));\n                d[nx][ny] = d[p.first][p.second] + 1;\n            }\n        }\n    }\n    return d[gx][gy];\n}\n\nint main(){\n    while(cin >> n >> m, n|m){\n        pair<int, int> s;\n        rep(i, 400){\n            rep(j,400)q[i][j] = inf;\n            q[i][i] = 0;\n        }\n        rep(i, m) cin >> maze[i];\n        rep(i, m)rep(j, n){\n            if(maze[i][j] == 'o'){s.first = j, s.second = i;}\n            if(maze[i][j] == '*' || maze[i][j] == 'o'){g.pb(mp(j, i));}\n        }\n        vector<pair<int, int> > gg;\n        gg.pb(s);\n        rep(i, g.size()) gg.pb(g[i]);\n        rep(i, gg.size()){\n            rep(j, gg.size()){\n                if(i == j) continue;\n                int res = bfs(gg[i].first, gg[i].second, gg[j].first, gg[j].second);\n                q[i][j] = res;\n            }\n        }\n        rep(i, 1<<gg.size()) fill(dp[i], dp[i]+gg.size(), inf);\n        dp[(1 << gg.size())-1][0] = 0;\n\n        for(int S = (1 << gg.size())-2; S >= 0; S--){\n            for(int v = 0; v < n; v++){\n                for(int u=0; u < gg.size(); u++){\n                    if(!(S >> u & 1)){\n                        dp[S][v] = min(dp[S][v], dp[S | 1 << u][u] + q[v][u]);\n                    }\n                }\n            }\n        }\n        int ret = inf;\n        rep(i, gg.size()){\n            if(i == 0) continue;\n            ret = min(ret, dp[0][i]);\n        }\n        if(ret != inf) cout << ret << endl;\n        else cout << -1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\nchar map[21][21];\nint path[12][12];\nint dp[4500];\n\nstruct Point {\n\tint x, y;\n\tPoint() : x(0), y(0) {}\n\tPoint(int x, int y) : x(x), y(y) {}\n};\nPoint dirtyTiles[11]; //dirtyTiles[0]ツづ債δ債ボツッツトツ渉可甘コツ暗環置\n\nbool visited[21][21];\n\nint w = 0;\nint h = 0;\n\nint getShortestPathLength(Point from, Point to) {\n\t//memset(visited, 0, sizeof(visited));\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tvisited[i][j] = map[i][j] == 'x';\n\t\t}\n\t}\n\n\tqueue<Point> que;\n\tque.push(from);\n\n\tint length = -1;\n\n\twhile(!que.empty()) {\n\t\tint curLength = que.size();\n\t\tlength++;\n\t\tfor (int i = 0; i < curLength; i++) {\n\t\t\tPoint point = que.front();\n\t\t\tque.pop();\n\n\t\t\tif (visited[point.y][point.x]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvisited[point.y][point.x] = true;\n\t\t\tif(point.x == to.x && point.y == to.y) {\n\t\t\t\t//cout << \"ret:\" << length << endl;\n\t\t\t\treturn length;\n\t\t\t}\n\t\t\tif(point.x > 0) {\n\t\t\t\tPoint left(point.x-1, point.y);\n\t\t\t\tque.push(left);\n\t\t\t}\n\t\t\tif(point.x < w-1) {\n\t\t\t\tPoint right(point.x+1, point.y);\n\t\t\t\tque.push(right);\n\t\t\t}\n\t\t\tif(point.y > 0) {\n\t\t\t\tPoint up(point.x, point.y-1);\n\t\t\t\tque.push(up);\n\t\t\t}\n\t\t\tif(point.y < h-1) {\n\t\t\t\tPoint down(point.x, point.y+1);\n\t\t\t\tque.push(down);\n\t\t\t}\n\t\t}\n\t}\n\t//cout << \"ret:-1\" << endl;\n\treturn -1;\n}\n\nint main() {\n\twhile(cin >> w >> h, w || h) {\n\n\t\tint dirtyTileSize = 1;\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tmap[i][j] = c;\n\t\t\t\tif(c == 'o') {\n\t\t\t\t\tdirtyTiles[0].x = j; dirtyTiles[0].y = i;\n\t\t\t\t}\n\t\t\t\telse if(c == '*') {\n\t\t\t\t\tdirtyTiles[dirtyTileSize].x = j;\n\t\t\t\t\tdirtyTiles[dirtyTileSize++].y = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n//\t\tfor (int i = 0; i < dirtyTileSize; i++) {\n//\t\t\tfor (int j = 0; j < dirtyTileSize; j++) {\n//\t\t\t\tpath[i][j] = 0;\n//\t\t\t}\n//\t\t}\n\n\t\tfor (int i = 0; i < dirtyTileSize; i++) {\n\t\t\tfor (int j = i + 1; j < dirtyTileSize; j++) {\n\t\t\t\tpath[i][j] = path[j][i] = getShortestPathLength(dirtyTiles[i], dirtyTiles[j]);\n\t\t\t\tif(path[i][j] == -1)\n\t\t\t\t\tgoto unreachable;\n\t\t\t}\n\t\t\tpath[i][i] = 0;\n\t\t}\n\n\t\tgoto reachable;\n\t\tunreachable: {\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\treachable:\n\n\t\t//memset(dp, 0, sizeof(dp));\n\n\t\tint bitMax = 1 << dirtyTileSize;\n\t\tint INF = 10000000;\n\t\tfor (int i = 0; i < bitMax; i++) {\n\t\t\tdp[i] = INF;\n\t\t}\n\n\t\tfor (int i = 1; i < dirtyTileSize; i++) {\n\t\t\tdp[1 << i] = path[0][i];\n\t\t}\n\t\tfor (int i = 1; i < dirtyTileSize; i++) {\n\t\t\tfor (int j = 1; j < dirtyTileSize; j++) {\n\t\t\t\tif(path[i][j] == 0) continue;\n\t\t\t\tfor (int k = 0; k < bitMax; k++) {\n\t\t\t\t\tif((k & (1 << i)) > 0 && (k & (1 << j)) == 0) {\n\t\t\t\t\t\tif(dp[k] != INF && (dp[k | (1 << j)] == INF || dp[k] + path[i][j] < dp[k | (1 << j)])) {\n\t\t\t\t\t\t\tdp[k | (1 << j)] = dp[k] + path[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << dp[(1 << dirtyTileSize) - 2] << endl;\n\t\tcontinue;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(y,x,h,w) (0<=y && y<h && 0<=x && x<w)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string str;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1,0,1,0 }; const int dy[] = { 0,1,0,-1 };\nint w, h;\nvvi dis;\nint idx;\nint ans;\nvoid dfs(int cnt,int flag,int d,int now) {\n\tif (cnt == idx - 1) {\n\t\tans = min(ans,d);\n\t\treturn;\n\t}\n\tREP(i, idx - 1) {\n\t\tif (!((flag >> i) & 1)) {\n\t\t\tdfs(cnt + 1, flag | (1 << i), d + dis[now][i], i);\n\t\t}\n\t}\n}\nint main() {\n\twhile (cin >> w >> h, w) {\n\t\tvector<str> cell(h);\n\t\tidx = 0;\n\t\tmap<pii, int> idxd;\n\t\tREP(i, h) {\n\t\t\tcin >> cell[i];\n\t\t\tREP(j, w) {\n\t\t\t\tif (cell[i][j] == '*') {\n\t\t\t\t\tidxd[{i, j}] = idx;\n\t\t\t\t\tidx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif (cell[i][j] == 'o') {\n\t\t\t\t\tidxd[{i, j}] = idx;\n\t\t\t\t\tidx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdis.clear();\n\t\tdis.resize(idx, vi(idx, -1));\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif (cell[i][j] == 'o' || cell[i][j] == '*') {\n\t\t\t\t\tvvb visited(h, vb(w, false));\n\t\t\t\t\tvisited[i][j] = true;\n\t\t\t\t\tqueue<pii> Q;\n\t\t\t\t\tQ.push({ i,j });\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\t\tqueue<pii> Q2;\n\t\t\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\t\t\tpii q = Q.front(); Q.pop();\n\t\t\t\t\t\t\tif (cell[q.first][q.second] == '*') {\n\t\t\t\t\t\t\t\tdis[idxd[{i, j}]][idxd[{q.first, q.second}]] = cnt;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tREP(i, 4) {\n\t\t\t\t\t\t\t\tint ny = q.first + dy[i];\n\t\t\t\t\t\t\t\tint nx = q.second + dx[i];\n\t\t\t\t\t\t\t\tif (WRAP(ny, nx, h, w) && cell[q.first][q.second] != 'x' && !visited[ny][nx]) {\n\t\t\t\t\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t\t\t\t\t\tQ2.push({ ny,nx });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tQ = Q2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool noc=false;\n\t\tREP(i, idx - 1) {\n\t\t\tif (dis[idx - 1][i] == -1) {\n\t\t\t\tnoc = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (noc) {\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tans = 1e9;\n\t\tdfs(0,0,0,idx-1);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#define MAX 20\n#define DMAX 10\nusing namespace std;\n\nclass Point{\n    public:\n    int y, x;\n    Point(){}\n    Point( int y, int x ): y(y), x(x){}\n    bool operator == ( const Point &p ) const{\n        return ( x == p.x && y == p.y );\n    }\n};\n\nint W, H;\nchar G[MAX][MAX];\nPoint start;\nPoint dirty[DMAX];\nint dsize;\nint T[DMAX]; // start to all dirty;\nint M[DMAX][DMAX]; // all dirty to all dirty\n\nint bfs( Point p1, Point p2 ){\n    bool visited[MAX][MAX];\n    int d[MAX][MAX];\n    queue<Point> q;\n    \n    for ( int i = 0; i < H; i++ ){\n        for ( int j = 0; j < W; j++ ){\n            visited[i][j] = false;\n            d[i][j] = INT_MAX;\n        }\n    }\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, -1, 0, 1};\n    \n    q.push( p1 );\n    d[p1.y][p1.x] = 0;\n    \n    Point u;\n    \n    while ( !q.empty() ){\n        u = q.front(); q.pop();\n        \n        if ( u == p2 ) return d[u.y][u.x];\n        \n        int nx, ny;\n        for ( int r = 0; r < 4; r++ ){\n            ny = u.y + dy[r];\n            nx = u.x + dx[r];\n            \n            if ( !( 0 <= nx && 0 <= ny && ny < H && nx < W ) ) continue;\n            \n            if ( !visited[ny][nx] && G[ny][nx] != 'x' ){\n                visited[ny][nx] = true;\n                d[ny][nx] = d[u.y][u.x] + 1;\n                q.push( Point( ny, nx ) );\n            }\n        }\n    }\n    \n    return INT_MAX;\n}\n\nvoid computeDistanceTable(){\n    for ( int i = 0; i < dsize; i++ ){\n        T[i] = bfs( start, dirty[i]);\n    }\n    for ( int i = 0; i < dsize-1; i++ ){\n        for ( int j = i; j < dsize; j++ ){\n            if ( i == j ) M[i][j] = M[j][i] = 0;\n            M[i][j] = M[j][i] = bfs( dirty[i], dirty[j] );\n        }\n    }\n}\n\nint getMinimumMove(){\n    int order[DMAX];\n    for ( int i = 0; i < dsize; i++ ){\n        order[i] = i;\n    }\n    \n    int minMove = INT_MAX;\n    \n    do{\n        int move = T[ order[0] ];\n        \n        for ( int i = 1; i < dsize; i++ ){\n            move += M[ order[i-1] ][ order[i] ];\n        }\n        \n        if ( minMove > move ) minMove = move;\n        \n    } while( next_permutation(order, order + dsize )) ;\n    \n    return minMove;\n}\n\nbool notReachable(){\n    for ( int i = 0; i < dsize; i++ ){\n        if ( T[i] == INT_MAX ) return true;\n    }\n    return false;\n}\n\nvoid compute(){\n    computeDistanceTable();\n    if ( notReachable() ) cout << \"-1\" << endl;\n    else {\n        cout << getMinimumMove() << endl;\n    }\n}\n\nbool read(){\n    cin >> W >> H;\n    if ( W == 0 && H == 0 ) return false;\n    dsize = 0;\n    char ch;\n    for ( int i = 0; i < H; i++ ){\n        for ( int j = 0; j < W; j++ ){\n            cin >> ch;\n            G[i][j] = ch;\n            if ( ch == 'o' ){\n                start = Point(i, j);\n            } else if ( ch == '*' ){\n                dirty[dsize++] = Point(i, j);\n            }\n        }\n    }\n    return true;\n}\n\nmain(){\n    while ( read() ) compute();\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename A, typename B>\ninline bool chmax(A &a, const B &b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate<typename A, typename B>\ninline bool chmin(A &a, const B &b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\nconst int INF = 1e9;\nconst int dy[] = {0, 1, 0, -1};\nconst int dx[] = {1, 0, -1, 0};\n\nint h, w;\nchar c[25][25];\nint sy, sx;\nvector<int> gy, gx;\nint dist[15][15];\n\nint bfs(int fid, int gid) {\n    int d[25][25];\n    for(int i = 0; i < 25; ++i) {\n        for(int j = 0; j < 25; ++j) {\n            d[i][j] = INF;\n        }\n    }\n    queue<pair<int, int>> que;\n    que.push({gy[fid], gx[fid]});\n    d[gy[fid]][gx[fid]] = 0;\n    while(que.size()) {\n        int py, px;\n        tie(py, px) = que.front();\n        que.pop();\n        if(py == gy[gid] and px == gx[gid]) break;\n        for(int i = 0; i < 4; ++i) {\n            int ny = py + dy[i];\n            int nx = px + dx[i];\n            if(d[ny][nx] != INF) continue;\n            if(c[ny][nx] == 'x') continue;\n            if(ny < 0 or h <= ny) continue;\n            if(nx < 0 or w <= nx) continue;\n            d[ny][nx] = d[py][px] + 1;\n            que.push({ny, nx});\n        }\n    }\n    return d[gy[gid]][gx[gid]];\n}\n\nvoid solve() {\n    int n = gy.size();\n    for(int from = 0; from < n; ++from) {\n        for(int to = from + 1; to < n; ++to) {\n            dist[from][to] = dist[to][from] = bfs(from, to);\n        }\n    }\n    n--;\n    int dp[1<<n][n + 1];\n    for(int i = 0; i < (1 << n); ++i) {\n        for(int j = 0; j < n + 1; ++j) {\n            dp[i][j] = INF;\n        }\n    }\n    dp[0][n] = 0;\n    for(int mask = 0; mask < (1 << n); ++mask) {\n        for(int i = 0; i < n; ++i) {\n            if((mask >> i) & 1) {\n                for(int j = 0; j < n + 1; ++j) {\n                    int pre = dp[mask - (1 << i)][j];\n                    if(pre != INF and dist[i][j] != INF) {\n                        chmin(dp[mask][i], pre + dist[i][j]);\n                    }\n                }\n            }\n        }\n    }\n    int ans = INF;\n    for(int i = 0; i < n + 1; ++i) {\n        chmin(ans, dp[(1 << n) - 1][i]);\n    }\n    cout << (ans == INF ? -1 : ans) << endl;\n}\n\nint main() {\n    while(cin >> w >> h and w > 0) {\n        gy = gx = {};\n        for(int y = 0; y < h; ++y) {\n            for(int x = 0; x < w; ++x) {\n                cin >> c[y][x];\n                if(c[y][x] == 'o') {\n                    c[y][x] = '.';\n                    sy = y;\n                    sx = x;\n                }\n                if(c[y][x] == '*') {\n                    c[y][x] = '.';\n                    gy.push_back(y);\n                    gx.push_back(x);\n                }\n            }\n        }\n        gy.push_back(sy);\n        gx.push_back(sx);\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n,N) for(int i=(n);i<(int)(N);i++)\n#define p(s) cout<<(s)<<endl;\n#define ck(n,a,b) ((a)<=(n)&&(n)<(b))\n#define F first\n#define S second\nusing namespace std;\nconst int inf =1e9;\n\nint main(){\n\tint w,h;\n\tint dx[]={1,0,-1,0};\n\tint dy[]={0,1,0,-1};\n\twhile(cin>>w>>h,w){\n\t\tstring field[21];\n\t\tbool yo[21][21];\n\t\tint dp[21][21];\n\t\tREP(i,0,h) cin>>field[i];\n\n\t\tint sx,sy,yogore=0;\n\t\tREP(i,0,h) REP(j,0,w){\n\t\t\tyo[i][j]=false;\n\t\t\tif(field[i][j]=='o'){\n\t\t\t\tsx=j,sy=i;\n\t\t\t}else if(field[i][j]=='*'){\n\t\t\t\tyogore++;\n\t\t\t\tyo[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tint cnt=0;\n\t\twhile(cnt!=yogore){\n\t\t\tqueue<pair<int,int>> q;\n\t\t\tREP(i,0,h) REP(j,0,w) dp[i][j]=inf;\n\t\t\tq.push({sx,sy});\n\t\t\tdp[sy][sx]=0;\n\t\t\tbool flag=false;\n\t\t\twhile(!q.empty()){\n\t\t\t\tauto now=q.front();q.pop();\n\t\t\t\tREP(i,0,4){\n\t\t\t\t\tint nx=now.F+dx[i],ny=now.S+dy[i];\n\t\t\t\t\tif(!ck(nx,0,w)||!ck(ny,0,h)||field[ny][nx]=='x') continue;\n\t\t\t\t\tif(dp[ny][nx]<inf) continue;\n\t\t\t\t\tdp[ny][nx]=dp[now.S][now.F]+1;\n\t\t\t\t\tq.push({nx,ny});\n\t\t\t\t\tif(yo[ny][nx]){\n\t\t\t\t\t\tyo[ny][nx]=false;\n\t\t\t\t\t\tans+=dp[ny][nx];\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tsx=nx;sy=ny;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag) break;\n\t\t\t}\n\t\t\tif(!flag) {\n\t\t\t\tans=-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={-1,0,1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fr first\n#define sc second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nint W,H;\nint D[12][12];\nchar stage[25][25];\nvector < Pii > c;\nint len;\nvoid bfs(int index){\n    int s[25][25];\n    memset(s,-1,sizeof(s));\n    queue < Pii > Q;\n    Q.push(c[index]);\n    s[c[index].fr][c[index].sc] = 0;\n    while(!Q.empty()){\n        Pii p = Q.front();Q.pop();\n        rep(i,4){\n            int ny = p.fr + dy[i];\n            int nx = p.sc + dx[i];\n            if(s[ny][nx] != -1 || stage[ny][nx] == 'x')continue;\n            if(ny < 0 || ny > H-1 || nx < 0 || nx > W-1)continue;\n            s[ny][nx] = s[p.fr][p.sc] + 1;\n            Q.push(Pii(ny,nx));\n        }\n    }\n    rep(i,len){\n        if(i == index)continue;\n        D[index][i] = s[c[i].fr][c[i].sc];\n    }\n    return ;\n}\nint memo[1<<12];\nint getMin(int bit,int prev){\n    if((1<<len)-1 == bit){\n        return 0;\n    }\n    int ret = INF;\n    rep(i,len){\n        if(!(1&bit>>i)){\n            ret = min(ret,D[prev][i]+getMin(bit|1<<i,i));\n        }\n    }\n    return ret;\n}\nint main(){\n    while(scanf(\"%d%d\",&W,&H),(W|H)){\n        int index = 0;\n        int s;\n        c.clear();\n        rep(i,H){\n            scanf(\"%s\",&stage[i]);\n            rep(j,W){\n                if(stage[i][j] == 'o'){\n                    s = index;\n                    stage[i][j] = '.';\n                    c.PB(Pii(i,j));\n                    index++;\n                }\n                if(stage[i][j] == '*'){\n                    c.PB(Pii(i,j));\n                    index++;\n                }\n            }\n        }\n        len = index;\n        memset(D,0,sizeof(D));\n        rep(i,len){\n            bfs(i);\n        }\n        memset(memo,-1,sizeof(memo));\n        int ans = INF;\n        printf(\"%d\\n\",getMin(1<<s,s));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//1518\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cassert>\n#include<sstream>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<cstring>\n\nusing namespace std;\n\ntypedef unsigned uint;\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n\nint INF=1001001001;\nint dx[4] = {0,-1,0,1};\nint dy[4] = {1,0,-1,0};\n\nint main(){\n\tint w,h;\n\twhile(cin >> w >> h){\n\t\tif(w==0 && h==0) break;\n\t\tint i,j,k;\n\t\tint m[22][22];\n\t\tint a[15][15];\n\t\tpint d[14];\n\t\tchar in;\n\t\tint n=1;\n\t\tfor(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tcin >> in;\n\t\t\t\tif(in=='x') m[i][j]=-1000;\n\t\t\t\telse if(in=='.') m[i][j]=INF;\n\t\t\t\telse if(in=='o'){\n\t\t\t\t\tm[i][j]=INF;\n\t\t\t\t\td[0]=pint(i,j);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tm[i][j]=INF;\n\t\t\t\t\td[n]=pint(i,j);\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<n;i++) for(j=0;j<n;j++) a[i][j]=INF;\n\t\t\n\t\tqueue<pair<pint,int> > q;\n\t\tfor(k=0;k<n;k++){\n\t\t\tfor(i=0;i<h;i++){\n\t\t\t\tfor(j=0;j<w;j++){\n\t\t\t\t\tif(m[i][j]!=-1000) m[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.push(pair<pint,int>(d[k],0));\n\t\t\tm[d[k].first][d[k].second]=0;\n\t\t\twhile(!q.empty()){\n\t\t\t\tpair<pint,int> tmp = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tfor(i=0;i<n;i++){\n\t\t\t\t\tif(tmp.first==d[i]){\n\t\t\t\t\t\ta[k][i] = tmp.second;\n\t\t\t\t\t\ta[i][k] = tmp.second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(i=0;i<4;i++){\n\t\t\t\t\tif(tmp.first.first+dx[i]>=0 && tmp.first.first+dx[i]<h && tmp.first.second+dy[i]>=0 && tmp.first.second+dy[i]<w){\n\t\t\t\t\t\tif(m[tmp.first.first+dx[i]][tmp.first.second+dy[i]]==INF){\n\t\t\t\t\t\t\tm[tmp.first.first+dx[i]][tmp.first.second+dy[i]]=0;\n\t\t\t\t\t\t\tq.push(pair<pint,int>(pint(tmp.first.first+dx[i],tmp.first.second+dy[i]),tmp.second+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint f=0;\n\t\tfor(i=0;i<n;i++) for(j=0;j<n;j++) if(a[i][j]==INF) f=1;\n\t\t\n\t\tif(f==1) cout << -1 << endl;\n\t\telse{\n\t\t\tint p[15];\n\t\t\tfor(i=0;i<n-1;i++){\n\t\t\t\tp[i]=i+1;\n\t\t\t}\n\t\t\tint ans=INF;\n\t\t\tdo{\n\t\t\t\tint tmp=a[0][p[0]];\n\t\t\t\tfor(i=0;i<n-2;i++){\n\t\t\t\t\ttmp+=a[p[i]][p[i+1]];\n\t\t\t\t}\n\t\t\t\tans=min(ans,tmp);\n\t\t\t}while(next_permutation(p,p+n-1));\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\t\t\t\n\t\t\t\t\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#define MAX_V 20\n#define INF 10000000\n#include<queue>\n#include<string>\n#include<map>\n#include<vector>\nusing namespace std;\nstruct edge{\n\tint to,cost;\n};\nint co[MAX_V][MAX_V];\nint h,w,V,dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nstring s[30];\ntypedef pair<int,int> P;\nmap<P,int> mp;\nint dp[1 << MAX_V][MAX_V];\nint rec(int S,int v){\n\tif(dp[S][v]>=0)\n\t\treturn dp[S][v];\n\tif(S==(1<<V)-2){\n\t\treturn dp[S][v]=0;\n\t}\n\tint res=INF;\n\tfor(int u=0;u<V;u++){\n\t\tif(!(S>>u&1)){\n\t\t\tres=min(res,rec(S|1<<u,u)+co[v][u]);\n\t\t}\n\t}\n\treturn dp[S][v]=res;\n}\nvoid solve(){\n\tmemset(dp,-1,sizeof(dp));\n\tint temp=rec(0,0);\n\tif(temp==INF)\n\tcout<<-1<<endl;\n\telse\n\tcout<<temp<<endl;\n}\nvoid func(int y,int x,int q){\n\tint d[MAX_V][MAX_V];\n\tfor(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\td[i][j]=INF;\n\td[y][x]=0;\n\tqueue<P> box;\n\tbox.push(P(y,x));\n\twhile(!box.empty()){\n\t\tint nx,ny,sx,sy;\n\t\tP pre=box.front();\n\t\tbox.pop();\n\t\tsy=pre.first;\n\t\tsx=pre.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tnx=sx+dx[i];\n\t\t\tny=sy+dy[i];\n\t\t\tif((nx>=0&&ny>=0&&nx<w&&ny<h)&&(s[ny][nx]=='o'||s[ny][nx]=='.'||s[ny][nx]=='*')&&(d[ny][nx]==INF)){\n\t\t\t\tbox.push(P(ny,nx));\n\t\t\t\tif(s[ny][nx]=='*'||s[ny][nx]=='o'){\n\t\t\t\t\tco[mp[P(ny,nx)]][q]=d[sy][sx]+1;\n\t\t\t\t\tco[q][mp[P(ny,nx)]]=d[sy][sx]+1;\n\t\t\t\t}\n\t\t\t\td[ny][nx]=d[sy][sx]+1;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(cin>>w>>h,h||w){\n\t\tV=1;\n\t\tfor(int i=0;i<h;i++)\n\t\tcin>>s[i];\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\tif(s[i][j]=='o')\n\t\t\tmp[P(i,j)]=0;\n\t\telse if(s[i][j]=='*'){\n\t\t\tmp[P(i,j)]=V;\n\t\t\tV++;\n\t\t}\n\t\tfor(int i=0;i<V;i++)\n\t\tfor(int j=0;j<V;j++){\n\t\t\tco[i][j]=INF;\n\t\t\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[i][j]=='o'){\n\t\t\t\tfunc(i,j,0);\n\t\t\t}else if(s[i][j]=='*'){\n\t\t\t\tfunc(i,j,mp[P(i,j)]);\n\t\t\t}\n\t\t}\n\t\t\n\t\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\nusing P = pair<int, int>;\n\nint w, h, m;\nstring map[20];\nint d[20][20][20][20];\nP dirty[20];\nint diri[] = {-1, 0, 1, 0};\nint dirj[] = {0, -1, 0, 1};\n\nvoid bfs(int si, int sj) {\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            d[si][sj][i][j] = -1;\n        }\n    }\n    d[si][sj][si][sj] = 0;\n\n    queue<P> q;\n    q.push(make_pair(si, sj));\n\n    while (!q.empty()) {\n        P p = q.front();\n        q.pop();\n        int i = p.first;\n        int j = p.second;\n        int cost = d[si][sj][i][j];\n        for (int k = 0; k < 4; ++k) {\n            int ni = i + diri[k];\n            int nj = j + dirj[k];\n            if (ni < 0 || ni >= h || nj < 0 || nj >= w) continue;\n            if (map[ni][nj] == 'x') continue;\n            //cout << ni << nj << \" \"<<d[si][sj][ni][nj]<< endl;\n            if (d[si][sj][ni][nj] != -1) continue;\n            d[si][sj][ni][nj] = cost + 1;\n            q.push(make_pair(ni, nj));\n        }\n    }\n    // for (int i = 0; i < h; ++i) {\n    //     for (int j = 0; j < w; ++j) {\n    //         cout << d[si][sj][i][j] << \"  \";\n    //     }\n    //     cout << endl;\n    // }\n    // cout << endl;\n}\n\nvoid solve() {\n    for (int i = 0; i < h; ++i) {\n        cin >> map[i];\n    }\n\n    m = 0;\n    int ri, rj;\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            if (map[i][j] == '*') {\n                dirty[m] = make_pair(i, j);\n                m++;\n                bfs(i, j);\n            } else if (map[i][j] == 'o') {\n                ri = i;\n                rj = j;\n                bfs(i, j);\n            }\n        }\n    }\n\n    sort(dirty, dirty + m);\n\n    int mincost = 4000;\n    do {\n        int cost = 0;\n        int i = ri;\n        int j = rj;\n        for (int k = 0; k < m; ++k) {\n            int toi = dirty[k].first;\n            int toj = dirty[k].second;\n            cost += d[i][j][toi][toj];\n            if (d[i][j][toi][toj] == -1) {\n                mincost = -1;\n                break;\n            }\n            i = toi;\n            j = toj;\n        }\n        mincost = min(cost, mincost);\n    } while (next_permutation(dirty, dirty + m));\n\n    cout << mincost << endl;\n}\n\nint main() {\n    while (1) {\n        cin >> w >> h;\n        if (w == 0) break;\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nconst int INF=1000100010;\nstring s[21];\nint dp[1<<11][11];\nint x[11],y[11],d[11][11];\nbool used[21][21];\nconst int dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nint w,h,cnt;\nvoid bfs(int sr){\n    memset(used,0,sizeof(used));\n    queue<pair<pint,int> > q;\n    q.push({{x[sr],y[sr]},0});\n    used[y[sr]][x[sr]]=true;\n    while(!q.empty()){\n        pair<pint,int> pi=q.front();q.pop();\n        rep(i,4){\n            int tx=pi.first.first+dx[i],ty=pi.first.second+dy[i];\n            if(tx>=0&&ty>=0&&tx<w&&ty<h&&s[ty][tx]!='x'&&!used[ty][tx]){\n                if(s[ty][tx]=='*'){\n                    rep(j,cnt){\n                        if(ty==y[j]&&tx==x[j]){\n                            d[sr][j]=pi.second+1;\n                            if(sr==0) d[j][sr]=pi.second+1;\n                            break;\n                        }\n                    }\n                }\n                q.push({{tx,ty},pi.second+1});\n                used[ty][tx]=true;\n            }\n        }\n    }\n}\nint main(){  \n    while(cin>>w>>h,w|h){\n        cnt=1;\n        rep(i,h){\n            cin>>s[i];\n            rep(j,w){\n                if(s[i][j]=='o') x[0]=j,y[0]=i;\n                if(s[i][j]=='*') x[cnt]=j,y[cnt]=i,++cnt;\n            }\n        }\n        memset(d,-1,sizeof(d));\n        rep(i,cnt) bfs(i);\n        rep(i,cnt)rep(j,1<<cnt) dp[j][i]=INF;\n        dp[(1<<cnt)-1][0]=0;\n        for(int i=(1<<cnt)-2;i>=0;--i){\n            rep(j,cnt)rep(k,cnt)if(!((i>>k)&1)&&d[j][k]!=-1){\n                dp[i][j]=min(dp[i][j],dp[i|1<<k][k]+d[j][k]);\n            }\n        }\n        int mn=INF;\n        FOR(i,1,cnt) mn=min(mn,dp[1<<i][i]);\n        if(mn!=INF){\n            cout<<mn<<endl;\n        }\n        else cout<<-1<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nclass Point{\npublic:\n  int x;\n  int y;\n};\n\nclass Cost{\npublic:\n  int x;\n  int y;\n  int c;\n};\n\nint w, h, n;\nPoint data[11];\nchar mdata[20][20];\nint cost[11][11];\nbool visited[20][20];\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\n\nint bfs(Point, Point);\n\nmain(){\n  while(1){\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    int k=1;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> mdata[i][j];\n\tif(mdata[i][j]=='o'){\n\t  data[0].y=i;\n\t  data[0].x=j;\n\t}\n\tif(mdata[i][j]=='*'){\n\t  data[k].y=i;\n\t  data[k].x=j;\n\t  k++;\n\t}\n      }\n    }\n    n=k;\n    bool flag=false;\n    for(int i=0;i<n;i++){\n      if(flag) break;\n      for(int j=i;j<n;j++){\n\tif(i==j){\n\t  cost[i][j]=cost[j][i]=0;\n\t}\n\telse{\n\t  for(int a=0;a<h;a++){\n\t    for(int b=0;b<w;b++){\n\t      visited[a][b]=false;\n\t    }\n\t  }\n\t  cost[i][j]=cost[j][i]=bfs(data[i], data[j]);\n\t  if(cost[i][j]==-1){\n\t    flag=true;\n\t    break;\n\t  }\n\t}\n      }\n    }\n    if(flag){\n      cout << -1 << endl;\n      continue;\n    }\n\n    int A[10];\n    for(int i=1;i<n;i++){\n      A[i-1]=i;\n    }\n\n    int ans=-1;\n    do{\n      int tmp=cost[0][A[0]];\n      for(int i=1;i<n-1;i++){\n\ttmp+=cost[A[i-1]][A[i]];\n      }\n      if(ans==-1 || ans>tmp){\n\tans=tmp;\n      }\n    }while(next_permutation(A, A+n-1));\n\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n\nint bfs(Point start, Point goal){\n  queue<Cost> q;\n\n  Cost s;\n  s.x=start.x;\n  s.y=start.y;\n  s.c=0;\n\n  q.push(s);\n  int ans=-1;\n  Cost u, v;\n  while(!q.empty()){\n    u=q.front(), q.pop();\n    if(u.y==goal.y && u.x==goal.x){\n      ans=u.c;\n      break;\n    }\n    for(int i=0;i<4;i++){\n      v.y=u.y+dy[i];\n      v.x=u.x+dx[i];\n      v.c=u.c+1;\n      if(v.y>=0 && v.y<h){\n\tif(v.x>=0 && v.x<w){\n\t  if(mdata[v.y][v.x]!='x'){\n\t    if(!visited[v.y][v.x]){\n\t      visited[v.y][v.x]=true;\t      \n\t      q.push(v);\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  return ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <cmath>\nusing namespace std;\n \n#define MAX 20\nbool is_wall[MAX][MAX];\nint is_dirty[MAX][MAX];\n\n#define BIT_MAX (1 << 10)\n#define INF 1e8\nint smallest_time[MAX][MAX][BIT_MAX];\n\n#define DIRS 4\nint dx[DIRS] = {-1, 0, 0, 1};\nint dy[DIRS] = { 0,-1, 1, 0};\n\nbool is_ok(int x, int y, int w, int h){\n  return 0 <= x && x < w && 0 <= y && y < h;\n}\n\nint main() {\n  \n  int w, h;\n  \n  while(cin >> w >> h, w || h ) {\n    int start_x = -1, start_y = -1;\n    int dirtys = 0;\n    \n    for(int i = 0; i < h; i++){\n      string line;\n      cin >> line;\n      \n      for(int j = 0; j < w; j++){\n\tis_wall[i][j] = false;\n\tis_dirty[i][j] = -1;\n\tfor(int k = 0; k < BIT_MAX; k++){\n\t  smallest_time[i][j][k] = INF;\n\t}\n\t\n\tif(line[j] == 'x'){\n\t  is_wall[i][j] = true;\n\t}else if(line[j] == '*'){\n\t  is_dirty[i][j] = dirtys++;\n\t}else if(line[j] == 'o'){\n\t  start_x = j;\n\t  start_y = i;\n\t}\n      }\n    }\n    \n    queue<int> xq, yq, bq;\n    xq.push(start_x);\n    yq.push(start_y);\n    bq.push(0);\n    smallest_time[start_y][start_x][0] = 0;\n    \n    bool answered = false;\n    while(!bq.empty()){\n      const int x    = xq.front(); xq.pop();\n      const int y    = yq.front(); yq.pop();\n      const int bit  = bq.front(); bq.pop();\n      const int time = smallest_time[y][x][bit];\n      \n      if(bit == (1 << dirtys) - 1){\n\tanswered = true;\n\tcout << time << endl;\n\tbreak;\n      }\n      \n      for(int dir = 0; dir < DIRS; dir++){\n\tconst int nx = x + dx[dir];\n\tconst int ny = y + dy[dir];\n\tconst int n_time = time + 1;\n\t\n\tif(!is_ok(nx, ny, w, h)){\n\t  continue;\n\t}else if(is_wall[ny][nx]){\n\t  continue;\n\t}\n\t\n\tconst int n_bit = bit | (is_dirty[ny][nx] < 0 ? 0 : (1 << is_dirty[ny][nx]));\n\t\n\tif(n_time >= smallest_time[ny][nx][n_bit]){\n\t  continue;\n\t}\n\t\n\tsmallest_time[ny][nx][n_bit] = n_time;\n\txq.push(nx);\n\tyq.push(ny);\n\tbq.push(n_bit);\n      }\n    }\n    \n    if(!answered){\n      cout << -1 << endl;\n    }\n  }\n  \n  return 0;  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\nstruct Data{int x,y,dirty,cost;};\nenum{CLEAN='.',DIRTY='*',FURNITURE='x',ROBOT='o'};\nint main()\n{\n  int w,h;\n  int dx[4]={0,1,0,-1};\n  int dy[4]={1,0,-1,0};\n  while(cin>>w>>h,w|h){\n    queue<Data> q;\n    Data start={0,0,0,0},goal={0,0,0,-1};\n    vector< vector<char> >field(h,vector<char>(w));\n    vector< vector<int> >dirty(h,vector<int>(w,0));\n    int num=1;\n    for(int i=0;i<h;i++)for(int j=0;j<w;j++){\n      cin>>field[i][j];\n      if(field[i][j]==DIRTY){\n\tstart.dirty^=(1<<num);\n\tdirty[i][j]=num;\n\tnum++;\n      }\n      if(field[i][j]==ROBOT){\n\tstart.x=j;\n\tstart.y=i;\n\tfield[i][j]=CLEAN;\n      }\n    }\n\n    vector< vector< vector<int> > >visited(h,vector< vector<int> >(w,vector<int>(1<<10,0)));\n    q.push(start);\n    while(q.size()){\n      Data now=q.front();\n      q.pop();\n      if(visited[now.y][now.x][now.dirty])continue;\n      visited[now.y][now.x][now.dirty]=1;\n      if(field[now.y][now.x]==DIRTY){\n\tif(now.dirty&(1<<dirty[now.y][now.x]))\n\t  now.dirty^=(1<<dirty[now.y][now.x]);\n      }\n      if(now.dirty==0){\n\tgoal=now;\n\tbreak;\n      }\n\n      for(int i=0;i<4;i++){\n\tData next=now;\n\tnext.x+=dx[i];\n\tnext.y+=dy[i];\n\tnext.cost++;\n\tif(next.x<0||w<=next.x)continue;\n\tif(next.y<0||h<=next.y)continue;\n\tif(field[next.y][next.x]==FURNITURE)continue;\n\tq.push(next);\n      }\n    }\n\n    cout<<goal.cost<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<bitset>\nusing namespace std;\nstruct st{\n  int x,y,m,c;\n  st(int x,int y,int m,int c) : x(x),y(y),m(m),c(c) {}\n};\nint W,H;\nchar fie[21][21];\nint gomi[21][21];\nint memo[21][21][(1<<10)];\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint bit_max;\nint solve(int x,int y){\n  queue<st> q;\n  while(!q.empty()) q.pop();\n  q.push(st(x,y,0,0));\n  memo[x][y][0]=0;\n  while(!q.empty()){\n    st p = q.front(); q.pop();\n    x = p.x; y = p.y;\n    for(int i=0;i<4;i++){\n      int nx = x+dx[i];\n      int ny = y+dy[i];\n      if(nx < 0 || ny < 0 || nx>=W || ny>=H) continue;\n      if(fie[nx][ny]=='x') continue;\n      if(fie[nx][ny]=='*'){\n\tif( !((1<<gomi[nx][ny]) & p.m) ){\n\t  int next_m = ((1<<gomi[nx][ny]) | p.m);\n\t  if(memo[nx][ny][next_m]!=-1) continue;\n\t  if(bit_max == next_m) return p.c+1;\n\t  memo[nx][ny][next_m]=p.c+1;\n\t  q.push(st(nx,ny,next_m,p.c+1));\n\t}\n      }else{\n\tif(memo[nx][ny][p.m]!=-1) continue;\n\tmemo[nx][ny][p.m]=p.c+1;\n\tq.push(st(nx,ny,p.m,p.c+1));\n      }\n    }\n  }\n  return -1;\n}\nint main(){\n  while(1){\n    int sx,sy;\n    memset(memo,-1,sizeof(memo));\n    memset(gomi,0,sizeof(gomi));\n    cin >> W >> H;\n    if(!W && !H) break;\n    int co=0;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin >> fie[j][i];\n\tif(fie[j][i]=='o'){\n\t  sx=j; sy=i;\n\t}\n\tif(fie[j][i]=='*'){\n\t  gomi[j][i]=co;\n\t  ++co;\n\t}\n      }\n    }\n    bit_max = (1<<co)-1;\n    //    cout << bitset<16>(bit_max) << \"\\n\";\n    if(bit_max==0) cout << 0 << \"\\n\";\n    else cout << solve(sx,sy) << \"\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*********************\nAOJ_1140\nCleaning Robot\n*********************/\n#include <iostream>\n#include <queue>\n#include <string>\nusing namespace std;\n\n//構造体宣言\nstruct pos{\n\tint x;\t\t//座標\n\tint y;\t\t\n\tint dis;\t//距離\n};\n\nint main(){\n\tint w, h;\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 || h == 0) break;\n\n\t\t//タイルの初期化\n\t\tchar tile[30][30];\n\t\tfor(int i = 0; i < 30; i ++){\n\t\t\tfor(int j = 0; j < 30; j++){\n\t\t\t\ttile[i][j] = 'x';\n\t\t\t}\n\t\t}\n\t\t//タイルの入力\n\t\tint stain = 0;\t//汚れの数\n\t\tqueue<pos> que;\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tstring input;\n\t\t\tcin >> input;\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\ttile[i][j] = input[j-1];\n\t\t\t\tif(tile[i][j] == '*') stain++;\n\t\t\t\tif(tile[i][j] == 'o'){\n\t\t\t\t\tpos p;\n\t\t\t\t\tp.y = i; p.x = j;\n\t\t\t\t\tp.dis = 0;\n\t\t\t\t\tque.push(p);\n\t\t\t\t\ttile[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint count = 0;\n\t\twhile(stain > 0){\n\t\t\tchar bfs[30][30];\n\t\t\tmemcpy(bfs, tile, sizeof(bfs));\n\t\t\tpos p = que.front();\n\t\t\tbfs[p.y][p.x] = 0;\n\t\t\tint x1[] = {-1, 0, 1, 0}, y1[] = {0, -1, 0, 1};\n\t\t\tint f = 1;\n\t\t\twhile(f && !que.empty()){\n\t\t\t\tpos p1 = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tp = p1;\n\t\t\t\t\tp.x += x1[i]; p.y += y1[i];\n \t\t\t\t\tif(bfs[p.y][p.x] == '.'){\n\t\t\t\t\t\tp.dis++;\n\t\t\t\t\t\tbfs[p.y][p.x] = p.dis;\n\t\t\t\t\t\tque.push(p);\n\t\t\t\t\t}else if(bfs[p.y][p.x] == '*'){\n\t\t\t\t\t\tcount += p.dis+1;\n\t\t\t\t\t\tstain--;\n\t\t\t\t\t\ttile[p.y][p.x] == '.';\n\t\t\t\t\t\twhile(!que.empty()) que.pop();\n\t\t\t\t\t\tp.dis = 0;\n\t\t\t\t\t\tque.push(p);\n\t\t\t\t\t\tf = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(que.empty()) break;\n\t\t}\n\n\t\tif(stain > 0) cout << \"-1\" << endl;\n\t\telse cout << count << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\nint n, m;\nint dp[(1<<10)*400+20*20+20];\nint brd[20][20];\nvector<P> e[(1<<10)*400+20*20+20];\n\nvoid solve(){\n\tint cnt = 0;\n\tint st;\n\trep(i,(1<<10)*400+20*20+20){\n\t\tdp[i] = INF;\n\t\te[i].clear();\n\t}\n\trep(i,20*20) e[i].clear();\n\trep(i,m) rep(j,n){\n\t\tchar tmp; cin >> tmp;\n\t\tif(tmp == 'o'){\n\t\t\tst = 20*i+j;\n\t\t\tdp[20*i+j] = 0;\n\t\t\tbrd[i][j] = -1;\n\t\t} else if(tmp == '*'){\n\t\t\tbrd[i][j] = cnt;\n\t\t\tcnt++;\n\t\t} else if(tmp == 'x'){\n\t\t\tbrd[i][j] = INF;\n\t\t} else{\n\t\t\tbrd[i][j] = -1;\n\t\t}\n\t}\n\trep(i,m) rep(j,n){\n\t\tif(brd[i][j] == INF) continue;\n\t\tif(brd[i][j] >= 0){\n\t\t\trep(k,(1<<cnt)){\n\t\t\t\tif(k&(1<<brd[i][j])) continue;\n\t\t\t\te[400*k+20*i+j].push_back(P(400*(k+(1<<brd[i][j]))+20*i+j,0));\n\t\t\t}\n\t\t}\n\t\trep(u,4){\n\t\t\tint x = i+dx[u], y = j+dy[u];\n\t\t\tif(0>x||x>=m||0>y||y>=n) continue;\n\t\t\trep(k,(1<<cnt)){\n\t\t\t\te[400*k+20*i+j].push_back(P(400*k+x*20+y,1));\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<P,vector<P>, greater<P> > que;\n\tque.push(P(0,st));\n\twhile(true){\n\t\tif(que.size() == 0) break;\n\t\tP q = que.top();\n\t\tque.pop();\n\t\tif(q.first > dp[q.second]) continue;\n\t\trep(i,e[q.second].size()){\n\t\t\tP p = e[q.second][i];\n\t\t\tif(dp[p.first] > q.first+p.second){\n\t\t\t\tdp[p.first] = q.first+p.second;\n\t\t\t\tque.push(P(dp[p.first],p.first));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\tint x = 1;\n\tfor(int i = 1; i < cnt; i++) x = x*2+1;\n\trep(i,20) rep(j,20){\n\t\tans = min(ans,dp[x*400+i*20+j]);\n\t}\n\tif(ans == INF) ans = -1;\n\tcout <<  ans << endl;\n}\n\nint main(){\n\twhile(cin >> n >> m){\n\t\tif(n == 0 && m == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF (1<<21)\nstatic const int dx[] = {1,-1,0,0} , dy[]={0,0,-1,1};\nchar data[30][30];\nstruct P{\n\tint x,y;\n\tP(int a,int b){x=a,y=b;}\n\tbool operator ==(const P& a){ return x == a.x && y == a.y; }\n};\n\nint bfs(P s,P g){\n\t// mèm[hú» , ¢KâÈçÎ-1A»¤ÅÈ¯êÎs©çÌÅZ£\n\tint done[30][30];\n\trep(i,30)rep(j,30)done[i][j] = -1;\n\t\n\tqueue<P>Q;\n\tQ.push(s);\n\tdone[s.y][s.x] = 0;\n\t\n\twhile(Q.size()){\n\t\tP q = Q.front(); Q.pop();\n\t\t\n\t\tif(q == g) return done[g.y][g.x];\n\t\t\n\t\trep(i,4){\n\t\t\tP t = P(q.x+dx[i],q.y+dy[i]);\n\t\t\tif(data[t.y][t.x] == 'x' || ~done[t.y][t.x]){\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tdone[t.y][t.x] = done[q.y][q.x]+1;\n\t\t\t\tQ.push(t);\n\t\t\t}\n\t\t}\n\t}\n\treturn INF;\n}\nint main(){\n\tint W,H;\n\twhile(cin >> W >> H , W){\n\t\t// }bvú»\n\t\trep(i,30)rep(j,30)data[i][j] = 'x';\n\t\t\n\t\t//@üÍ\n\t\trep(i,H)rep(j,W)\n\t\t\tcin >> data[i+1][j+1];\n\t\t\n\t\t// {bgEê^CÌÊuEÂæ¾\n\t\tP s(0,0);\n\t\tvector<P> pos;\n\t\trep(i,30)rep(j,30)\n\t\t\tif(data[i][j] == '*') pos.push_back(P(j,i));\n\t\t\telse if(data[i][j] == 'o')s = P(j,i);\n\t\tint n = pos.size();\n\n\t\t// eê^C¯mÌÅZoHðvZµÄ¨­B\n\t\tint dist[10][10] = {0};\n\t\trep(i,n)rep(j,n)dist[i][j] = bfs(pos[i],pos[j]);\n\n\t\t// ñZ[X}ú»\n\t\tint dp[1<<10][10];\n\t\trep(i,1<<10)rep(j,10)dp[i][j] = INF;\n\t\t\n\t\t// ñZ[X}\n\t\trep(i,n) dp[1<<i][i] = bfs(s,pos[i]);\n\t\trep(i,1<<n)rep(j,n)rep(k,n)\n\t\t\tdp[i|(1<<k)][k] = min(dp[i|(1<<k)][k],dp[i][j]+dist[j][k]);\n\t\t\n\t\t// oÍ\n\t\tint ans = INF;\n\t\trep(i,n)ans = min(ans,dp[(1<<n)-1][i]);\n\t\tcout << (ans<INF?ans:-1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nconst int INF = 9999999;\n\nint w, h;\nstring b[20];\nint d[20][20];\n\nchar dx[] = {-1,1,0,0};\nchar dy[] = {0,0,-1,1};\n\nvoid dist(int sx, int sy){\n\tfor(int i=0;i<20;i++)\n\t\tfor(int j=0;j<20;j++)\n\t\t\td[i][j] = INF;\n\tqueue< pair<int,int> > qu;\n\tqu.push(make_pair(sx,sy));\n\td[sy][sx] = 0;\n\twhile(!qu.empty()){\n\t\tpair<int, int> p = qu.front(); qu.pop();\n\t\tint x = p.first, y = p.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif(nx<0||nx>=w||ny<0||ny>=h||b[ny][nx]=='x') continue;\n\t\t\tif(d[ny][nx] != INF) continue;\n\t\t\td[ny][nx] = d[y][x] + 1;\n\t\t\tqu.push(make_pair(nx,ny));\n\t\t}\n\t}\n}\n\nint main(){\n\tint c[11][11];\n\tint x[11], y[11];\n\tint ans[1<<11][11];\n\twhile(cin >> w >> h){\n\t\tif(!(w||h)) break;\n\t\tint num = 1;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin >> b[i];\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(b[i][j]=='o') x[0] = j, y[0] = i;\n\t\t\t\tif(b[i][j]=='*') x[num] = j, y[num++] = i;\n\t\t\t}\n\t\t}\n\t\tbool flag = false;\n\t\tmemset(c,0,sizeof(c));\n\t\tdist(x[0],y[0]);\n\t\tfor(int i=1;i<num;i++){\n\t\t\tc[0][i] = d[y[i]][x[i]];\n\t\t\tif(c[0][i] == INF) flag = true;\n\t\t}\n\t\tif(flag) { cout << -1 << endl; continue; }\n\t\tfor(int i=1;i<num;i++){\n\t\t\tdist(x[i],y[i]);\n\t\t\tfor(int j=0;j<num;j++){\n\t\t\t\tif(i==j) continue;\n\t\t\t\tc[i][j] = d[y[j]][x[j]];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(1<<num);i++) for(int j=0;j<num;j++) ans[i][j] = INF;\n\t\tans[1][0] = 0;\n\t\tfor(int i=0;i<(1<<num);i++){\n\t\t\tfor(int j=0;j<num;j++)\n\t\t\t\tif((i>>j)&1)\n\t\t\t\t\tfor(int k=0;k<num;k++)\n\t\t\t\t\t\tans[i|(1<<k)][k] = min(ans[i|(1<<k)][k],ans[i][j]+c[j][k]);\n\t\t}\n\t\tint cost = INF;\n\t\tfor(int i=1;i<num;i++) cost = min(cost, ans[(1<<num)-1][i]);\n\t\tcout << cost << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nchar stage[20][20];\nint cost[1024][10];\nint dis[10][10];\nint w, h;\n\ntypedef std::tuple<int, int, int> T;\nstd::vector<T> pos_to_num;\n\nlong long unsigned PopCount(long long unsigned x) {\n\tx = (x & 0x5555555555555555ULL) + ((x & 0xAAAAAAAAAAAAAAAAULL) >> 1);\n\tx = (x & 0x3333333333333333ULL) + ((x & 0xCCCCCCCCCCCCCCCCULL) >> 2);\n\tx = (x & 0x0F0F0F0F0F0F0F0FULL) + ((x & 0xF0F0F0F0F0F0F0F0ULL) >> 4);\n\n\tx *= 0x0101010101010101ULL;\n\n\treturn x;\n}\n\nvoid dijkstra(int sx, int sy)\n{\n\tint c[20][20] = {0};\n\tint f[20][20] = {0};\n\tint dx[4] = {1, -1, 0, 0};\n\tint dy[4] = {0, 0, 1, -1};\n\n\tstd::queue<std::tuple<int,int>> q;\n\tq.push(std::make_tuple(sx, sy));\n\tf[sx][sy] = 1;\n\n\twhile(!q.empty()) {\n\t\tauto a = q.front(); q.pop();\n\t\tint x = std::get<0>(a);\n\t\tint y = std::get<1>(a);\n\t\tfor ( int i = 0; i < 4; ++i ) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif ( nx < 0 || nx >= w ) continue;\n\t\t\tif ( ny < 0 || ny >= h ) continue;\n\t\t\tif ( stage[nx][ny] == 'x' ) continue;\n\t\t\tif ( f[nx][ny] == 1 ) continue;\n\n\t\t\tc[nx][ny] = c[x][y] + 1;\n\t\t\tf[nx][ny] = 1;\n\t\t\tq.push(std::make_tuple(nx, ny));\n\t\t}\n\t}\n\n\tif ( stage[sx][sy] == 'o' ) {\n\t\tfor ( int i = 0; i < pos_to_num.size(); ++i ) {\n\t\t\tcost[0][std::get<2>(pos_to_num[i])] = c[std::get<0>(pos_to_num[i])][std::get<1>(pos_to_num[i])];\n\t\t}\n\t} else if ( stage[sx][sy] == '*' ) {\n\t\tint num;\n\t\tfor ( int i = 0; i < pos_to_num.size(); ++i ) {\n\t\t\tif ( sx == std::get<0>(pos_to_num[i]) && sy == std::get<1>(pos_to_num[i]) ) {\n\t\t\t\tnum = std::get<2>(pos_to_num[i]);\n\t\t\t}\n\t\t}\n\t\tfor ( int i = 0; i < pos_to_num.size(); ++i ) {\n\t\t\tdis[num][std::get<2>(pos_to_num[i])] = c[std::get<0>(pos_to_num[i])][std::get<1>(pos_to_num[i])];\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile ( true ) {\n\t\tfor ( int i = 0; i < 1024; ++i ) {\n\t\t\tfor ( int j = 0; j < 10; ++j ) {\n\t\t\t\tcost[i][j] = 0xfffff;\n\t\t\t}\n\t\t}\n\n\t\tstd::cin >> w >> h;\n\t\tif ( w == 0 && h == 0 ) return 0;\n \n\t\tint sx, sy;\n\t\tint k = 0;\n\t\tfor ( int i = 0; i < h; ++i ) {\n\t\t\tfor ( int j = 0; j < w; ++j ) {\n\t\t\t\tstd::cin >> stage[j][i];\n\t\t\t\tif ( stage[j][i] == '*' ) {\n\t\t\t\t\tpos_to_num.push_back(T(j, i, k));\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tif ( stage[j][i] == 'o' ) {\n\t\t\t\t\tsx = j; sy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdijkstra(sx, sy);\n\t\tfor ( auto &v: pos_to_num ) {\n\t\t\tdijkstra(std::get<0>(v), std::get<1>(v));\n\t\t}\n\t\tstd::vector<std::tuple<int, int>> table(1<<k);\n\t\tfor ( int i = 0; i < (1<<k); ++i ) {\n\t\t\ttable[i] = std::make_tuple(PopCount(i), i);\n\t\t}\n\t\tstd::sort(table.begin(), table.end());\n\n\t\tfor ( int i = 1; i < (1<<k); ++i ) {\n\t\t\tint q = std::get<1>(table[i]);\n\t\t\tfor ( int j = 0; j < k; ++j ) {\n\t\t\t\tif ( q & (1<<j) ) {\n\t\t\t\t\tfor ( int l = 0; l < k; ++l ) {\n\t\t\t\t\t\tint c = cost[q^(1<<j)][j] + dis[j][l];\n\t\t\t\t\t\tcost[q][l] = (c < cost[q][l]) ? c : cost[q][l];\n\t\t\t\t\t\t//std::cout << \"state:\" << q << \" to:\" << l << \" cost:\" << cost[q][l] << std::endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min = 0xfffff;\n\t\tfor ( int i = 0; i < k; ++i ) {\n\t\t\tif ( min > cost[(1<<k)-1][i] ) min = cost[(1<<k)-1][i];\n\t\t}\n\t\tif ( min == 0xfffff || min == 0 ) {\n\t\t\tstd::cout << -1 << std::endl;\n\t\t} else {\n\t\t\tstd::cout << min << std::endl;\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\nusing namespace std;\ntypedef long long LL;\n\n#define _CRT_SECURE_NO_WARNINGS\nint N;\nint H, W;\nchar c[21][21];\nqueue<int> qh;\nqueue<int> qw;\nint main() {\n\twhile (1) {\n\t\tscanf(\"%d%d\", &W, &H);\n\t\tif (H == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tint cost[21][21] = {};\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcost[i][j] = 10000;\n\t\t\t}\n\t\t}\n\t\tN = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tscanf(\"%s\", c[i]);\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (c[i][j] == 'o') {\n\t\t\t\t\tqh.push(i);\n\t\t\t\t\tqw.push(j);\n\t\t\t\t\tcost[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse if (c[i][j] == '*') {\n\t\t\t\t\tN++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cleanedNum = 0;\n\t\tint totalcost = 0;\n\t\tbool cleaned[21][21] = {};\n\t\twhile (!qh.empty()) {\n\t\t\tint h = qh.front(),\n\t\t\t\tw = qw.front();\n\t\t\tqh.pop(); qw.pop();\n\t\t\tint dh[4] = { -1,1,0,0 },\n\t\t\t\tdw[4] = { 0,0,-1,1 };\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint th = h + dh[i],\n\t\t\t\t\ttw = w + dw[i];\n\t\t\t\tif (0<= th && th <= H && 0<= tw && tw <= W ) {\n\t\t\t\t\tif (c[th][tw] == '.' && cost[th][tw] > cost[h][w] + 1) {\n\t\t\t\t\t\tqh.push(th); qw.push(tw);\n\t\t\t\t\t\tcost[th][tw] = cost[h][w] + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (c[th][tw] == '*' && !cleaned[th][tw]) {\n\t\t\t\t\t\ttotalcost += cost[h][w] + 1;\n\t\t\t\t\t\tcleaned[th][tw] = true;\n\t\t\t\t\t\tcleanedNum++;\n\t\t\t\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\t\t\t\tcost[i][j] = 10000;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcost[th][tw] = 0;\n\t\t\t\t\t\twhile (!qh.empty()) {\n\t\t\t\t\t\t\tqh.pop(); qw.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqh.push(th); qw.push(tw);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cleanedNum != N) {\n\t\t\tprintf(\"-1\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%d\\n\", totalcost);\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define all(c) (c).begin(), (c).end()\nconst int inf = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\n\nint w, h;\n\ninline bool inrect(int x, int y){\n    return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nint solve(vector<string>& c){\n    vector<int> xs, ys;\n    rep(i, h)rep(j, w){\n        if(c[i][j] == 'o')xs.insert(xs.begin(), i), ys.insert(ys.begin(), j);\n        if(c[i][j] == '*')xs.push_back(i), ys.push_back(j);\n    }\n    int n = (int)xs.size();\n    vector<vector<int> > costs(n, vector<int>(n, inf));\n    rep(i, n){\n        vector<vector<int> > mem(h, vector<int>(w, inf)); mem[xs[i]][ys[i]] = 0;\n        typedef tuple<int, int, int> State;\n        priority_queue<State> q;\n        for(q.emplace(0, xs[i], ys[i]); !q.empty();){\n            int cost, x, y;\n            tie(cost, x, y) = q.top(); q.pop();\n            if(mem[x][y] != -cost)continue;\n            rep(k, 4){\n                int nx = x + dx[k], ny = y + dy[k];\n                if(!inrect(nx, ny) || c[nx][ny] == 'x' || mem[nx][ny] <= 1 - cost)continue;\n                mem[nx][ny] = 1 - cost;\n                q.emplace(-mem[nx][ny], nx, ny);\n            }\n        }\n        rep(j, n)costs[i][j] = mem[xs[j]][ys[j]];\n    }\n    if(find(all(costs[0]), inf) != costs[0].end())return -1;\n    vector<vector<int> > mem(1 << n, vector<int>(n, inf)); mem[1 << 0][0] = 0;\n    typedef tuple<int, int, int> State;\n    priority_queue<State> q;\n    for(q.emplace(0, 1 << 0, 0); !q.empty();){\n        int cost, vis, v;\n        tie(cost, vis, v) = q.top(); q.pop();\n        if(mem[vis][v] != -cost)continue;\n        rep(i, n){\n            if(vis >> i & 1 || mem[vis | 1 << i][i] <= costs[v][i] - cost)continue;\n            mem[vis | 1 << i][i] = costs[v][i] - cost;\n            q.emplace(-mem[vis | 1 << i][i], vis | 1<< i, i);\n        }\n    }\n    return *min_element(all(mem[(1 << n) - 1]));\n}\n\nint main(){\n    while(cin >> w >> h, w|h){\n        vector<string> c(h);\n        rep(i, h)cin >> c[i];\n        cout << solve(c) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\n#include <functional>\nusing namespace std;\n\ntypedef int W;\n\nconst int MAX_V = 400 * (1 << 10);\nconst W INF = 1 << 20;\n\nstruct edge {\n\tint to;\n\tW cost;\n};\ntypedef pair<W, int> P;\n\nvector<edge> G[MAX_V];\nW d[MAX_V];\n\n\nvoid dijkstra(int s) {\n\tpriority_queue< P, vector<P>, greater<P> > que;\n\tfill(d, d + MAX_V, INF);\n\td[s] = 0;\n\tque.push(P(0, s));\n\twhile(!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tfor(int i = 0; i < G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint w, h;\nstring b[20];\nint wf[20][20][20][20];\n\nstruct point {\n\tint x, y;\n};\n\nint v(int x, int y) {\n\treturn w * y + x;\n}\n\nint v2(int x, int y, int s) {\n\treturn s * (h*w) + v(x, y);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> w >> h, w | h) {\n\t\tmemset(wf, INF, sizeof wf);\n\t\tfor(int i = 0; i < 20; i++) {\n\t\t\tfor(int j = 0; j < 20; j++) {\n\t\t\t\tfor(int k = 0; k < 20; k++) {\n\t\t\t\t\tfor(int l = 0; l < 20; l++) {\n\t\t\t\t\t\tif(i == k && j == l) wf[i][j][k][l] = 1;\n\t\t\t\t\t\telse wf[i][j][k][l] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < MAX_V; i++) {\n\t\t\tG[i].clear();\n\t\t}\n\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tcin >> b[i];\n\t\t}\n\t\tvector<point> p;\n\t\tint sx = -1, sy = -1;\n\t\tfor(int y = 0; y < h; y++) {\n\t\t\tfor(int x = 0; x < w; x++) {\n\t\t\t\tif(b[y][x] == 'o') {\n\t\t\t\t\tsx = x, sy = y;\n\t\t\t\t}\n\t\t\t\tif(b[y][x] == '*') {\n\t\t\t\t\tp.push_back(point{ x, y });\n\t\t\t\t}\n\t\t\t\tif(b[y][x] != 'x') {\n\t\t\t\t\tint dx[] = { 1, 0, -1, 0 }, dy[] = { 0, 1, 0, -1 };\n\t\t\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\t\t\tif(0 <= nx && nx < w && 0 <= ny && ny < h && b[ny][nx] != 'x') {\n\t\t\t\t\t\t\twf[x][y][nx][ny] = wf[nx][ny][x][y] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int kx = 0; kx < w; kx++) {\n\t\t\tfor(int ky = 0; ky < h; ky++) {\n\t\t\t\tfor(int ix = 0; ix < w; ix++) {\n\t\t\t\t\tfor(int iy = 0; iy < h; iy++) {\n\t\t\t\t\t\tfor(int jx = 0; jx < w; jx++) {\n\t\t\t\t\t\t\tfor(int jy = 0; jy < h; jy++) {\n\t\t\t\t\t\t\t\twf[ix][iy][jx][jy] = min(wf[ix][iy][jx][jy],\n\t\t\t\t\t\t\t\t\twf[ix][iy][kx][ky] + wf[kx][ky][jx][jy]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tp.push_back(point{ sx, sy });\n\t\tfor(int i = 0; i < p.size(); i++) {\n\t\t\tfor(int j = 0; j < p.size(); j++) {\n\t\t\t\tfor(int k = 0; k < 1 << (p.size() - 1); k++) {\n\t\t\t\t\tif(k & (1 << j)) {\n\t\t\t\t\t\tG[v2(p[i].x, p[i].y, k)].push_back(\n\t\t\t\t\t\t\tedge{ v2(p[j].x, p[j].y, k ^ (1 << j)), wf[p[i].x][p[i].y][p[j].x][p[j].y] }\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdijkstra(v2(sx, sy, (1 << (p.size() - 1)) - 1));\n\t\tint ans = INF;\n\t\tfor(int i = 0; i < p.size() - 1; i++) {\n\t\t\tans = min(ans, d[v2(p[i].x, p[i].y, 0)]);\n\t\t}\n\n\t\tif(ans == INF) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,n1,n2) for(int i=n1;i<n2;i++)\n#define bFOR(i,n1,n2) for(int i=n1;i>=n2;i--)\n#define speed_up    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\ntypedef long long int ll;\ntypedef pair<ll,ll> Pi;\nconst int INF=(ll)(1LL<<30)-1;\nconst double INFd=100000000000.0;\nconst ll INFl=(ll)9223372036854775807;\nconst int MAX=10000;\nconst ll MOD=(ll)1e9+7;\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a, b)*b;}\nint dx[4]={0,-1,0,1},dy[4]={-1,0,1,0};\nint mdx[4]={0,1,0,-1},mdy[4]={-1,0,1,0};\n\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nint w,h;\nchar c[25][25];\nint starty,startx;\nvector<Pi> dirty;\nint dis[11][11];\nint inv[25][25];\nvector<int> aa;\n\nint main(){\n\twhile(1){\n\t\tcin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\tint flag=1;\n\t\tREP(i,11)\n\t\t\tREP(j,11)\n\t\t\t\tdis[i][j]=0;\n\t\tdirty.clear();\n\t\tREP(i,h)\n\t\t\tREP(j,w){\n\t\t\t\tcin>>c[i][j];\n\t\t\t\tif(c[i][j]=='o'){\n\t\t\t\t\tstarty=i;\n\t\t\t\t\tstartx=j;\n\t\t\t\t\tdirty.push_back(Pi(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\tREP(i,h)\n\t\t\tREP(j,w){\n\t\t\t\tif(c[i][j]=='*'){\n\t\t\t\t\tdirty.push_back(Pi(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\tqueue<Pi> qq;\n\t\tfor(int i=0;i<dirty.size();i++){\n\t\t\tREP(k,25)\n\t\t\t\tREP(j,25)\n\t\t\t\t\tinv[k][j]=-1;\n\t\t\tqq.push(dirty[i]);\n\t\t\tinv[dirty[i].first][dirty[i].second]=0;\n\t\t\twhile(qq.size()){\n\t\t\t\tPi q1=qq.front();qq.pop();\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tint ny=q1.first+dy[j];\n\t\t\t\t\tint nx=q1.second+dx[j];\n\t\t\t\t\tif(0<=nx&&nx<w&&0<=ny&&ny<h&&inv[ny][nx]==-1&&c[ny][nx]!='x'){\n\t\t\t\t\t\tinv[ny][nx]=inv[q1.first][q1.second]+1;\n\t\t\t\t\t\tqq.push(Pi(ny,nx));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*REP(j,h){\n\t\t\t\tREP(i,w){\n\t\t\t\t\tcout<<inv[j][i]<<\" \";\n\t\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t\tcout<<endl;*/\n\t\t\tfor(int j=0;j<dirty.size();j++){\n\t\t\t\t\n\t\t\t\tdis[i][j]=inv[dirty[j].first][dirty[j].second];\n\t\t\t\t//printf(\"%3d\",dis[i][j]);\n\t\t\t\tif(dis[i][j]==-1)flag=0;\n\t\t\t}\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t\t\n\t\t/*REP(i,dirty.size()){\n\t\t\tREP(j,dirty.size()){\n\t\t\t\tcout<<dis[i][j]<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t\tvector<int> vv;\n\t\tvv.clear();\n\t\tfor(int i=1;i<dirty.size();i++){\n\t\t\tvv.push_back(i);\n\t\t}\n\t\tif(flag==0){\n\t\t\taa.push_back(-1);\n\t\t\tcontinue;\n\t\t}\n\t\tint ans=1e8;\n\t\tdo{\n\t\t\tint tans=0;\n\t\t\ttans+=dis[0][vv[0]];\n\t\t\tfor(int i=0;i<vv.size()-1;i++){\n\t\t\t\ttans+=dis[vv[i]][vv[i+1]];\n\t\t\t}\n\t\t\tans=min(tans,ans);\n\t\t\t//cout<<vv[0]<<\" \"<<vv[1]<<\" \"<<vv[2]<<endl;\n\t\t}while(next_permutation(vv.begin(),vv.end()));\n\t\taa.push_back(ans);\n\t}\n\tREP(i,aa.size())cout<<aa[i]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\nint cnt[11][11];\nlong long int ans;\n\n#define MAX 20\nbool is_wall[MAX][MAX];\nint is_dirty[MAX][MAX];\n\n#define BIT_MAX (1 << 10)\nbool visited[MAX][MAX][BIT_MAX];\n\n#define DIRS 4\nint dx[DIRS] = {-1, 0, 0, 1};\nint dy[DIRS] = { 0,-1, 1, 0};\n\nbool is_ok(int x, int y, int w, int h){\n  return 0 <= x && x < w && 0 <= y && y < h;\n}\n \nint main() {\n  \n  int w, h;\n  \n  while(cin >> w >> h, w || h ) {\n    int start_x = -1, start_y = -1;\n    int dirtys = 0;\n\n    for(int i = 0; i < h; i++){\n      string line;\n      cin >> line;\n    \n      for(int j = 0; j < w; j++){\n\tis_wall[i][j] = false;\n\tis_dirty[i][j] = -1;\n\tfor(int k = 0; k < BIT_MAX; k++){\n\t  visited[i][j][k] = false;\n\t}\n\n\tif(line[j] == 'x'){\n\t  is_wall[i][j] = true;\n\t}else if(line[j] == '*'){\n\t  is_dirty[i][j] = dirtys++;\n\t}else if(line[j] == 'o'){\n\t  start_x = j;\n\t  start_y = i;\n\t}\n      }\n    }\n    \n    queue<int> xq, yq, tq, bq;\n    xq.push(start_x);\n    yq.push(start_y);\n    tq.push(0);\n    bq.push(0);\n    visited[start_y][start_x][0] = true;\n\n    bool answered = false;\n    while(!tq.empty()){\n      const int x    = xq.front(); xq.pop();\n      const int y    = yq.front(); yq.pop();\n      const int time = tq.front(); tq.pop();\n      const int bit  = bq.front(); bq.pop();\n      \n      if(bit == (1 << dirtys) - 1){\n\tanswered = true;\n\tcout << time << endl;\n\tbreak;\n      }\n \n      for(int dir = 0; dir < DIRS; dir++){\n\tconst int nx = x + dx[dir];\n\tconst int ny = y + dy[dir];\n\tconst int n_time = time + 1;\n\t\n\tif(!is_ok(nx, ny, w, h)){\n\t  continue;\n\t}else if(is_wall[ny][nx]){\n\t  continue;\n\t}\n\n\tconst int n_bit = bit | (is_dirty[ny][nx] < 0 ? 0 : (1 << is_dirty[ny][nx]));\n\t\n\tif(visited[ny][nx][n_bit]){\n\t  continue;\n\t}\n\t\n\tvisited[ny][nx][n_bit] = true;\n\txq.push(nx);\n\tyq.push(ny);\n\ttq.push(n_time);\n\tbq.push(n_bit);\n      }\n    }\n\n    if(!answered){\n      cout << -1 << endl;\n    }\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int, pair<int, int> > pii;\n#define piii(x, y, d) make_pair(x, make_pair(y, d))\n\nint w, h;\nchar c[20][20], cc[20][20];\nint n;\nint gx[11], gy[11];\nint g[11][11];\nint dp[1 << 11][11];\nconst int INF = 10000000;\n\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nint bfs(int sx, int sy, int gx, int gy)\n{\n    queue<pii> q;\n\n    q.push(piii(sx, sy, 0));\n\n    while (!q.empty()) {\n        int x = q.front().first;\n        int y = q.front().second.first;\n        int d = q.front().second.second;\n        q.pop();\n        //printf(\"(%d, %d) = %d\\n\", x, y, d);\n\n        cc[x][y] = 'x';\n        for (int i = 0; i < 4; ++i) {\n            int nx = x + dx[i], ny = y + dy[i];\n            if (nx < 0 || h <= nx || ny < 0 || w <= ny)\n                continue;\n            if (cc[nx][ny] == 'x')\n                continue;\n            if (nx == gx && ny == gy)\n                return d + 1;\n            q.push(piii(nx, ny, d + 1));\n        }\n    }\n    return INF;\n}\n\nint tsp(int visited, int v)\n{\n    if (dp[visited][v] != -1)\n        return dp[visited][v];\n\n    if (visited == (1 << n) - 1)\n        return 0;\n\n    int res = INF;\n    for (int u = 0; u < n; ++u) {\n        if (!(visited & (1 << u))) {\n            res = min(res, tsp(visited | (1 << u), u) + g[v][u]);\n        }\n    }\n    return dp[visited][v] = res;\n}\n\nint main()\n{\n    for (;;) {\n        scanf(\"%d %d\", &w, &h);\n        if (w == 0 && h == 0)\n            break;\n\n        n = 1;\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                scanf(\" %c\", &c[i][j]);\n                if (c[i][j] == 'o') {\n                    gx[0] = i;\n                    gy[0] = j;\n                } else if (c[i][j] == '*') {\n                    gx[n] = i;\n                    gy[n] = j;\n                    ++n;\n                }\n            }\n        }\n        //for (int i = 0; i < n; ++i) printf(\"%d, %d\\n\", gx[i], gy[i]);\n\n        fill(&g[0][0], &g[11][0], INF);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j){\n                copy(&c[0][0], &c[20][0], &cc[0][0]);\n                if (i == j)\n                    g[i][j] = 0;\n                else\n                    g[i][j] = bfs(gx[i], gy[i], gx[j], gy[j]);\n                //printf(\"%d\\t\", g[i][j]);\n            }\n            //printf(\"\\n\");\n        }\n\n        fill(&dp[0][0], &dp[1 << 11][0], -1);\n        int res = tsp(1, 0);\n        if (res == INF)\n            printf(\"-1\\n\");\n        else\n            printf(\"%d\\n\", res);\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nint save[20][20],vis[25][25],n,m,dust,ct,lp,stx,sty,sum,minn;\nint mov[4][2]= {1,0,0,-1,-1,0,0,1};\nchar plate[25][25];\nint visp[20];\n\nstruct status\n{\n    int cnt;\n    int x,y;\n    status(int a,int b,int c)\n    {\n        x = a, y = b, cnt = c;\n    }\n};\nstruct point\n{\n    int x,y;\n}p[20];\n\nqueue<struct status> q;\n\nvoid maek()\n{\n    while(!q.empty())\n    {\n        if(plate[q.front().x][q.front().y]=='*')\n            save[0][ct+1] = q.front().cnt, p[ct+1].x = q.front().x, p[ct+1].y = q.front().y, ct++;\n\n        for(int i=0; i<4; i++)\n        {\n            int tx = q.front().x + mov[i][0], ty = q.front().y + mov[i][1];\n            if(tx >= 0 && tx < m && ty >=0 && ty < n && plate[tx][ty] != 'x' && !vis[tx][ty])\n            {\n                struct status temp(tx, ty, q.front().cnt + 1);\n                vis[tx][ty] = 1;\n                q.push(temp);\n            }\n        }\n        q.pop();\n    }\n}\n\nvoid play(int x, int y, int ord)\n{\n    int ctt = 0;\n    vis[q.front().x][q.front().y] = 1;\n    while(ctt != ct)\n    {\n        if(plate[q.front().x][q.front().y]=='*')\n        {\n            int r;\n            for(r=1; r<=ct; r++)\n                if(p[r].x == q.front().x && p[r].y == q.front().y) break;\n            save[ord][r] = q.front().cnt, ctt++;\n        }\n\n        for(int i=0; i<4; i++)\n        {\n            int tx = q.front().x + mov[i][0], ty = q.front().y + mov[i][1];\n            if(tx >= 0 && tx < m && ty >=0 && ty < n && plate[tx][ty] != 'x' && !vis[tx][ty])\n            {\n                struct status temp(tx, ty, q.front().cnt + 1);\n                vis[tx][ty] = 1;\n                q.push(temp);\n            }\n        }\n        q.pop();\n    }\n}\n\n\nvoid dfs(int x,int y,int ore)\n{\n    //printf(\"%d %d %d %d\\n\",x,y,ore,sum);\n\n    if(x==y)\n    {\n        minn = minn > sum ? sum : minn;\n    }\n\n    for(int i=1; i<=ct; i++)\n    {\n        if(!visp[i])\n        {\n            if(sum + save[ore][i] > minn) continue;\n            else\n            {\n                sum += save[ore][i];\n                x++;\n                visp[i] = 1;\n                dfs(x,y,i);\n                visp[i] = 0;\n                sum -= save[ore][i];\n                x--;\n            }\n        }\n    }\n}\n\n\nint main()\n{\n    //freopen(\"C://1140-input.txt\",\"r\",stdin);\n    //freopen(\"C://zout.txt\",\"w\",stdout);\n\n    while(~scanf(\"%d%d\",&n,&m),n+m)\n    {\n\n        memset(plate, 0, sizeof(plate));\n        memset(vis,0,sizeof(vis));\n        memset(save,0,sizeof(save));\n        memset(visp,0,sizeof(visp));\n        memset(p,0,sizeof(p));\n\n        getchar();\n        lp = 0, ct = 0;\n        for(int i=0; i<m; i++)\n        {\n            for(int j=0; j<n; j++)\n            {\n                scanf(\"%c\",&plate[i][j]);\n                if(plate[i][j]=='o') stx = i, sty = j;\n                if(plate[i][j]=='*') lp++;\n            }\n            getchar();\n        }\n\n        struct status tm(stx,sty,0);\n        q.push(tm);\n        maek();\n\n        if(ct != lp) printf(\"-1\\n\");\n        else\n        {\n            for(int i=1; i<=ct; i++)\n            {\n                memset(vis,0,sizeof(vis));\n                struct status temp(p[i].x, p[i].y, 0);\n                q.push(temp);\n                play(p[i].x, p[i].y, i);\n                while(!q.empty()) q.pop();\n            }\n\n           /* for(int i=0;i<=ct;i++)\n            {\n                for(int j=0;j<=ct;j++)\n                {\n                    printf(\"%3d \",save[i][j]);\n                }\n                printf(\"\\n\");\n            }*/\n            minn = 99999999;\n\n            for(int i=1; i<=ct; i++)\n            {\n                memset(visp,0,sizeof(visp));\n                sum = save[0][i],visp[i] = 1;\n                dfs(1,ct,i);\n            }\n            printf(\"%d\\n\",minn);\n        }\n    }\n    return 0;\n}\n\n\n/*\n\n7 10\n......x\n*...*.x\n.......\n.......\n....*.*\n.......\n.......\n.o.....\n**.....\n..*....\n\n7 5\n.......\n.o...*.\n.......\n.*...*.\n.......\n\n13 17\n............x\n..........x.x\n............x\n.......**....\n.............\n....*.......x\n............x\no..........xx\n...*.*......x\n............x\n.......x.....\n............x\n.....xx*.x.xx\n.....x.....xx\n...xxx....xxx\n.*xxxx...xxxx\n.xxxxxx..xxxx\n\n15 7\n*.o.*..........\n.........**....\n.*.............\n...............\n...............\n...............\nx.......*....*.\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nchar map[100][100]={{0}};\nint check[100][100]={{0}};\nint n,m,robots=0;\nint dist[11][11]={0};\nint pos[11][2]={0};\nint queue[1000][3]={{0}}, st,ed;\nint dp[1024][10]={0};\nvoid clean_check(){\n    int i,j;\n    for(i=0;i<n;i++){\n        for(j=0;j<m;j++) check[i][j] = 0;\n    }\n}\nbool input(){\n    int i,j;\n    scanf(\"%d%d\",&m,&n);\n    robots = 0;\n    if(m==0 || n==0) return false;\n    for(i=0;i<n;i++){\n        scanf(\"%s\",map[i]);\n        for(j=0;j<m;j++){\n            if(map[i][j] == '*'){\n                map[i][j] = robots + '0';\n                robots++;\n                pos[robots][0] = i;\n                pos[robots][1] = j;\n            }\n            else if(map[i][j] == 'o'){\n                pos[0][0] = i;\n                pos[0][1] = j;\n            }\n        }\n    }\n    return true;\n}\nbool bfs(){\n    int i,j;\n    for(i=0;i<=robots;i++){\n        clean_check();\n        queue[0][0] = pos[i][0], queue[0][1] = pos[i][1];\n        check[pos[i][0]][pos[i][1]] = -1;\n        queue[0][2] = 0;\n        st=0,ed=1;\n        while(st<ed){\n            int x = queue[st][0], y = queue[st][1];\n            int go[4][2] = {1,0,-1,0,0,1,0,-1};\n            for(j=0;j<4;j++){\n                if(x+go[j][0]>=0 && x+go[j][0]<n && y+go[j][1]>=0 && y+go[j][1]<m && map[x+go[j][0]][y+go[j][1]] != 'x' && !check[x+go[j][0]][y+go[j][1]]){\n                    queue[ed][0] = x+go[j][0], queue[ed][1] = y+go[j][1];\n                    queue[ed][2] = queue[st][2]+1;\n                    check[queue[ed][0]][queue[ed][1]] = queue[ed][2];\n                    ed++;\n                }\n            }\n            st++;\n        }\n        for(j=0;j<=robots;j++){\n            if(i==j) continue;\n            dist[i][j] = check[pos[j][0]][pos[j][1]];\n            if(dist[i][j] == 0){\n                return false;\n            }\n        }\n    }\n    return true;\n}\nvoid do_dp(int idx){\n    int i,j;\n    for(i=0;i<robots;i++){\n        if((1<<i) & idx){\n            dp[idx][i] = 2147480000;\n            for(j=0;j<robots;j++){\n                if(i==j)continue;\n                if((1<<j) & idx){\n                    dp[idx][i] = min(dp[idx][i], dp[idx^(1<<i)][j] + dist[i+1][j+1]);\n                }\n            }\n        }\n    }\n}\nint main()\n{\n    while(input()){\n        int i,j,ans=2147480000;\n        if(robots == 0){\n            printf(\"0\\n\");\n            continue;\n        }\n        if(!bfs()){\n            printf(\"-1\\n\");\n            continue;\n        }\n        if(robots == 1){\n            printf(\"%d\\n\",dist[0][1]);\n            continue;\n        }\n        for(i=0;i<robots;i++){\n            dp[1<<i][i] = dist[0][i+1];\n        }\n        for(i=3;i<(1<<robots);i = (i<<1)|1){\n            j = i;\n            do{\n                do_dp(j);\n                int temp = j + (j&-j);\n                j = (( ((temp & -temp) / (j & -j)) >> 1 ) - 1) | temp;\n            }while(j<(1<<robots));\n        }\n        for(i=0;i<robots;i++){\n            ans = min(ans, dp[(1<<robots)-1][i]);\n        }\n        printf(\"%d\\n\", ans);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\n\nmap<pair<pair<int, int>,pair<int, int>>, LL> memo;\nLL dist(pair<int, int> p1, pair<int, int> p2, const vector<string> &f) {\n    auto key = make_pair(p1, p2);\n    auto key2 = make_pair(p2, p1);\n    if (memo.find(key) != memo.end()) {\n        return memo[key];\n    }\n    if (memo.find(key2) != memo.end()) {\n        return memo[key2];\n    }\n\n    vector<vector<LL>> cost(f.size(), vector<LL>(f[0].size(), INF));\n    cost[p1.first][p1.second] = 0;\n\n    queue<pair<int, int>> que;\n    que.push(p1);\n\n    while (not que.empty()) {\n        int y = que.front().first;\n        int x = que.front().second;\n        que.pop();\n\n        FOR(i, 0, 4) {\n            int ny = dy4[i] + y;\n            int nx = dx4[i] + x;\n\n            if (inside(ny, nx, (int)f.size(), (int)f[0].size()) and f[ny][nx] != 'x' and cost[ny][nx] > cost[y][x] + 1) {\n                cost[ny][nx] = cost[y][x] + 1;\n                que.push(make_pair(ny, nx));\n            }\n        }\n    }\n\n    return memo[key] = cost[p2.first][p2.second];\n}\n\nint main() {\n    cin.tie(0);\n\tios::sync_with_stdio(false);\n\n    while (true) {\n        memo.clear();\n        int W, H;\n        cin >> W >> H;\n        if (W == 0 and H == 0) {\n            break;\n        }\n\n        vector<pair<int, int>> v;\n        vector<string> f(H);\n        int sy, sx;\n        FOR(i, 0, H) {\n            cin >> f[i];\n            FOR(j, 0, W) {\n                if (f[i][j] == 'o') {\n                    sy = i;\n                    sx = j;\n                }\n                if (f[i][j] == '*') {\n                    v.emplace_back(make_pair(i, j));\n                }\n            }\n        }\n\n        if (v.size() == 0) {\n            print(0);\n            continue;\n        }\n\n        LL ans = INF;\n        sort(ALL(v));\n        do {\n            LL d = dist(make_pair(sy, sx), v[0], f);\n            FOR(i, 0, v.size() - 1) {\n                d += dist(v[i], v[i + 1], f);\n            }\n            ans = min(ans, d);\n\n        } while(next_permutation(ALL(v)));\n\n        if (ans == INF) {\n            print(-1);\n        }\n        else {\n            print(ans);\n        }\n\n    }\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define all(c) (c).begin(), (c).end()\nconst int inf = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\n\nint w, h;\n\ninline bool inrect(int x, int y){\n    return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nint solve(vector<string>& c){\n    vector<int> xs, ys;\n    rep(i, h)rep(j, w){\n        if(c[i][j] == 'o')xs.insert(xs.begin(), i), ys.insert(ys.begin(), j);\n        if(c[i][j] == '*')xs.push_back(i), ys.push_back(j);\n    }\n    int n = (int)xs.size();\n    vector<vector<int> > costs(n, vector<int>(n, inf));\n    rep(i, n){\n        vector<vector<int> > mem(h, vector<int>(w, inf)); mem[xs[i]][ys[i]] = 0;\n        typedef tuple<int, int, int> State;\n        priority_queue<State> q;\n        for(q.emplace(0, xs[i], ys[i]); !q.empty();){\n            int cost, x, y;\n            tie(cost, x, y) = q.top(); q.pop();\n            if(mem[x][y] != -cost)continue;\n            rep(k, 4){\n                int nx = x + dx[k], ny = y + dy[k];\n                if(!inrect(nx, ny) || c[nx][ny] == 'x' || mem[nx][ny] <= 1 - cost)continue;\n                mem[nx][ny] = 1 - cost;\n                q.emplace(-mem[nx][ny], nx, ny);\n            }\n        }\n        rep(j, n)costs[i][j] = mem[xs[j]][ys[j]];\n    }\n    if(find(all(costs[0]), inf) != costs[0].end())return -1;\n    vector<int> mem(1 << n, inf); mem[1 << 0] = 0;\n    typedef tuple<int, int, int> State;\n    priority_queue<State> q;\n    for(q.emplace(0, 1 << 0, 0); !q.empty();){\n        int cost, vis, v;\n        tie(cost, vis, v) = q.top(); q.pop();\n        if(mem[vis] != -cost)continue;\n        if(vis == (1 << n) - 1)return -cost;\n        rep(i, n){\n            if(vis >> i & 1 || mem[vis | 1 << i] <= costs[v][i] - cost)continue;\n            mem[vis | 1 << i] = costs[v][i] - cost;\n            q.emplace(-mem[vis | 1 << i], vis | 1<< i, i);\n        }\n    }\n    return -1;\n}\n\nint main(){\n    while(cin >> w >> h, w|h){\n        vector<string> c(h);\n        rep(i, h)cin >> c[i];\n        cout << solve(c) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <vector>\nusing namespace std;\n#define INF (1<<28)\nstruct NODE{\n\tint x,y,c;\n\tNODE(int x,int y,int c) : x(x) , y(y) , c(c) {}\n};\n\nint dx[] = {-1,0,1,0};\nint dy[] = {0,1,0,-1};\nint w,h;\nchar field[20][20];\nint dist[11][11];\n\nint tsp[11][1<<11];\n\nint bfs(int x,int y,int x2,int y2){\n\tqueue<NODE> Q;\n\tint done[21][21] = {};\n\tQ.push(NODE(x,y,0));\n\twhile(Q.size()){\n\t\tNODE q = Q.front(); Q.pop();\n\t\tif( done[q.y][q.x]++) continue;\n\t\tif( x2 == q.x && y2 == q.y ) return q.c;\n\t\tfor(int i = 0 ; i < 4 ; i++){\n\t\t\tint tx = q.x + dx[i];\n\t\t\tint ty = q.y + dy[i];\n\t\t\tif( tx < 0 || tx >= w || ty < 0 || ty >= h || field[ty][tx] == 'x') continue;\n\t\t\tQ.push(NODE(tx,ty,q.c+1));\n\t\t}\n\t}\n\treturn INF;\n}\n\nint main(){\n\twhile(cin >> w >> h && w){\n\t\tvector<int> x,y;\n\t\tfor(int i = 0 ; i < h ; i++){\n\t\t\tfor(int j = 0 ; j < w ; j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < h ; i++)\n\t\t\tfor(int j = 0 ; j < w ; j++)\n\t\t\t\tif(field[i][j] == 'o') x.push_back(j) , y.push_back(i);\n\t\tfor(int i = 0 ; i < h ; i++)\n\t\t\tfor(int j = 0 ; j < w ; j++)\n\t\t\t\tif(field[i][j] == '*') x.push_back(j) , y.push_back(i);\n\t\tfor(int i = 0 ; i < 11 ; i++)\n\t\t\tfor(int j = 0 ; j < (1<<11) ; j++)\n\t\t\t\ttsp[i][j] = INF;\n\t\tfor(int i = 0 ; i < x.size() ; i++)\n\t\t\tfor(int j = 0 ; j < x.size() ; j++)\n\t\t\t\tdist[i][j] = bfs(x[i],y[i],x[j],y[j]);\n\t\t\n\t\ttsp[0][1] = 0;\n\t\tfor(int i = 0 ; i < (1<<x.size()) ; i++){\n\t\t\tfor(int j = 0 ; j < x.size() ; j++){\n\t\t\t\tfor(int k  = 0 ; k < x.size() ; k++){\n\t\t\t\t\tif(i >> j & 1){\n\t\t\t\t\t\ttsp[k][i|(1<<k)] = min(tsp[j][i]+dist[j][k],tsp[k][i|(1<<k)]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor(int i = 0 ; i < x.size() ; i++){\n\t\t\tans = min(tsp[i][(1<<x.size())-1],ans);\n\t\t}\n\t\tif( ans >= 1000000) cout << -1 << endl;\n\t\telse cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\nusing namespace std;\ntypedef long long LL;\n\n#define _CRT_SECURE_NO_WARNINGS\nint N;\nint H, W;\nchar c[21][21];\nqueue<int> qh;\nqueue<int> qw;\nint main() {\n\twhile (1) {\n\t\tscanf(\"%d%d\", &W, &H);\n\t\tif (H == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tint cost[21][21] = {};\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcost[i][j] = 10000;\n\t\t\t}\n\t\t}\n\t\tN = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tscanf(\"%s\", c[i]);\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (c[i][j] == 'o') {\n\t\t\t\t\tqh.push(i);\n\t\t\t\t\tqw.push(j);\n\t\t\t\t\tcost[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse if (c[i][j] == '*') {\n\t\t\t\t\tN++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cleanedNum = 0;\n\t\tint totalcost = 0;\n\t\tbool cleaned[21][21] = {};\n\t\twhile (!qh.empty()) {\n\t\t\tint h = qh.front(),\n\t\t\t\tw = qw.front();\n\t\t\tqh.pop(); qw.pop();\n\t\t\tint dh[4] = { -1,1,0,0 },\n\t\t\t\tdw[4] = { 0,0,-1,1 };\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint th = h + dh[i],\n\t\t\t\t\ttw = w + dw[i];\n\t\t\t\tif (0<= th && th <= H && 0<= tw && tw <= W ) {\n\t\t\t\t\tif (c[th][tw] == '.' && cost[th][tw] > cost[h][w] + 1) {\n\t\t\t\t\t\tqh.push(th); qw.push(tw);\n\t\t\t\t\t\tcost[th][tw] = cost[h][w] + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (c[th][tw] == '*' && !cleaned[th][tw]) {\n\t\t\t\t\t\ttotalcost += cost[h][w] + 1;\n\t\t\t\t\t\tcleaned[th][tw] = true;\n\t\t\t\t\t\tcleanedNum++;\n\t\t\t\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\t\t\t\tcost[i][j] = 10000;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcost[th][tw] = 0;\n\t\t\t\t\t\twhile (!qh.empty()) {\n\t\t\t\t\t\t\tqh.pop(); qw.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqh.push(th); qw.push(tw);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cleanedNum != N) {\n\t\t\tprintf(\"-1\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%d\\n\", totalcost);\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n\n#define rep(i, a) for (int i = 0; (i) < (int) (a); (i)++)\n#define reps(i, a, b) for (int i = (int) (a); (i) < (int) (b); (i)++)\n#define rrep(i, a) for (int i = (int) a-1; (i) >= 0; (i)--)\n#define rreps(i, a, b) for (int i = (int) (a)-1; (i) >= (int) (b); (i)--)\n#define MP(a, b) make_pair((a), (b))\n#define PB(a) push_back((a))\n#define all(v) (v).begin(), (v).end()\n#define PRINT(f) if((f)){cout << (TRUE__) << endl;}else{cout << FALSE__ << endl;}\n#define TRUE__ \"Yes\"\n#define FALSE__ \"No\"\n#define PERM(v) next_permutation(all(v))\n#define UNIQUE(v) sort(all(v));(v).erase(unique(all(v)), v.end())\n#define CIN(type, x) type x;cin >> x\n\n#ifdef LOCAL\n\t#define lcout(a) cout << a;\n\t#define lcoutln(a) cout << a << endl;\n\t#define lcerr(a) cerr << a;\n\t#define lcerrln(a) cerr << a << endl;\n#else\n\t#define lcout(a) \n\t#define lcoutln(a) \n\t#define lcerr(a) \n\t#define lcerrln(a) \n#endif\n\n#define MOD 1000000007\n#define INF 2000000000\nint w, h;\nint m[22][22];\nint cost[11][11];\nvector<pair<int, int> > v;\nint sr, sc;\n\nint costculc(int r1, int c1, int r2, int c2)\n{\n\tint cmemo[22][22];\n\trep(i, 22) rep(j, 22) cmemo[i][j] = INF;\n\tcmemo[r1][c1] = 0;\n\tqueue<pair<int, int> > q;\n\tq.push(MP(r1, c1));\n\twhile (!q.empty()) {\n\t\tint r, c;\n\t\tr = q.front().first;\n\t\tc = q.front().second;\n\t\tint dr[] = {-1, 0, 1,  0};\n\t\tint dc[] = { 0, 1, 0, -1};\n\t\trep(i, 4) {\n\t\t\tint nr = r + dr[i];\n\t\t\tint nc = c + dc[i];\n\t\t\tif (cmemo[nr][nc] != INF || m[nr][nc] == -1) continue;\n\t\t\tcmemo[nr][nc] = cmemo[r][c] + 1;\n\t\t\tq.push(MP(nr, nc));\n\t\t}\n\t\tq.pop();\n\t}\n\treturn cmemo[r2][c2];\n}\n\nsigned main()\n{\n\tcin >> w >> h;\n\twhile (w) {\n\t\tv.clear();\n\t\trep(i, 22) rep(j, 22) m[i][j] = -1;\n\t\trep(i, 11) rep(j, 11) cost[i][j] = INF;\n\t\trep(i, 11) cost[i][i] = 0;\n\t\treps(i, 1, h+1) reps(j, 1, w+1) {\n\t\t\tCIN(char, c);\n\t\t\tif (c == '.') m[i][j] = 0;\n\t\t\tif (c == 'o') {\n\t\t\t\tm[i][j] = 1;\n\t\t\t\tv.insert(v.begin(), MP(i, j));\n\t\t\t\tsr = i;\n\t\t\t\tsc = j;\n\t\t\t}\n\t\t\tif (c == '*') {\n\t\t\t\tm[i][j] = 2;\n\t\t\t\tv.PB(MP(i, j));\n\t\t\t}\n\t\t\tif (c == 'x') m[i][j] = -1;\n\t\t}\n\t\trep(i, v.size()) reps(j, i+1, v.size()) {\n\t\t\tcost[i][j] = cost[j][i] = costculc(v[i].first, v[i].second, v[j].first, v[j].second);\n\t\t}\n\t\tvector<int> t;\n\t\tint mi = INF;\n\t\trep(i, v.size()-1) t.PB(i+1);\n\t\tdo {\n\t\t\tint be = 0;\n\t\t\tint res = 0;\n\t\t\trep(i, t.size()) {\n\t\t\t\tres += cost[be][t[i]];\n\t\t\t\tbe = t[i];\n\t\t\t}\n\t\t\tmi = min(mi, res);\n\t\t} while (PERM(t));\n\t\tif (mi == INF) cout << -1 << endl;\n\t\telse cout << mi << endl;\n\t\tcin >> w >> h;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nint w,h,n;\nchar tbl[30][30];\nint G[10][10];\nint id[30][30];\nint dist[30];\n\nint x[20],y[20];\ntypedef pair<int,int> P;\nconst int INF = 1<<29;\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {1,0,-1,0};\n\nvoid bfs(int sx,int sy){\n  int f[30][30];\n  for(int i=0;i<h;++i)\n    for(int j=0;j<w;++j)\n      f[i][j]=INF;\n  f[sy][sx]=0;\n  queue<P> Q;\n  Q.push(P(sx,sy));\n  while(Q.size()){\n    P d = Q.front(); Q.pop();\n    for(int i=0;i<4;++i){\n      int mx = d.first+dx[i];\n      int my = d.second+dy[i];\n      if(mx<0 || mx>=w) continue;\n      if(my<0 || my>=h) continue;\n      if(tbl[my][mx]=='x') continue;\n      if(f[my][mx]<=f[d.second][d.first]+1) continue;\n      f[my][mx]=f[d.second][d.first]+1;\n      Q.push(P(mx,my));\n    }\n  }\n  \n  for(int i=0;i<n;++i)\n    dist[i] = f[y[i]][x[i]];\n}\nint main(){\n  while(cin>>w>>h,w||h){\n    for(int i=0;i<h;++i) for(int j=0;j<w;++j) id[i][j]=-1;\n    for(int i=0;i<h;++i) cin >> tbl[i];\n    n=0;\n    for(int i=0;i<h;++i)\n      for(int j=0;j<w;++j)\n\tif(tbl[i][j]=='*'){\n\t  id[i][j]=n;\n\t  x[n]=j;\n\t  y[n]=i;\n\t  ++n;\n\t}\n\n    int homedist[30]={};\n    for(int i=0;i<h;++i)\n      for(int j=0;j<w;++j)\n\tif(tbl[i][j]=='o') bfs(j,i);\n    for(int i=0;i<n;++i) homedist[i] = dist[i];\n    for(int i=0;i<n;++i){\n      bfs(x[i],y[i]);\n      for(int j=0;j<n;++j) G[i][j]=dist[j];\n    }\n    int ord[10];\n    for(int i=0;i<n;++i) ord[i]=i;\n    int ans = INF;\n\n    do{\n      int r = homedist[ord[0]];\n      for(int i=0;i+1<n;++i)\n\tr+=G[ord[i]][ord[i+1]];\n      ans=min(ans,r);\n    }while(next_permutation(ord,ord+n));\n    if(ans==INF) ans=-1;\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m; assert(b>=0); for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nint h, w;\nstring s[20];\n\n// (h,w) <-> (y,x)\nint mn(int sy, int sx, int gy, int gx) {\n\tqueue<pair<int,pii> > q;\n\tq.push({0,{sy,sx}});\n\tint d[20][20];\n\trep(i,h) rep(j,w) d[i][j] = inf;\n\td[sy][sx] = 0;\n\twhile (!q.empty()) {\n\t\tint x = q.front().se.se, y = q.front().se.fi, dis = q.front().fi; q.pop();\n\t\tif (d[y][x]<dis) continue;\n\t\trep(i,4) {\n\t\t\tint xx = x + dx[i], yy = y + dy[i];\n\t\t\tif (xx<0 || xx>=w || yy<0 || yy>=h || d[yy][xx]<=dis+1 || s[yy][xx]=='x') continue;\n\t\t\td[yy][xx] = dis+1;\n\t\t\tq.push({dis+1,{yy,xx}});\n\t\t}\n\t}\n\treturn d[gy][gx];\n}\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> w >> h;\n\t\tif (h==0) break;\n\t\tvi ti, tj;\n\t\t// 0: スタート地点\n\t\tint d[11][11] = {};\n\t\trep(i,11) rep(j,11) if (i!=j) d[i][j] = inf;\n\t\trep(i,h) {\n\t\t\tcin >> s[i];\n\t\t\trep(j,w) if (s[i][j]=='o') ti.pb(i), tj.pb(j);\n\t\t}\n\t\trep(i,h) rep(j,w) if (s[i][j]=='*') ti.pb(i), tj.pb(j);\n\t\tint n = ti.size();\n\t\t\n\t\trep(i,n) reps(j,i+1,n) d[i][j] = d[j][i] = mn(ti[i],tj[i],ti[j],tj[j]);\n\t\tbool fin = 0;\n\t\treps(i,1,n) if (d[0][i]==inf) fin = 1;\n\t\tif (fin) {\n\t\t\tcout << -1 << ln;\n\t\t\tcontinue;\n\t\t}\n\t\trep(k,n) rep(i,n) rep(j,n)\n\t\t    chmin(d[i][j], d[i][k]+d[k][j]);\n\t\t\n\t\t// dp[i][j]: 通過済みの点の集合がjであり今点iにいるような状態の最小移動回数\n\t\tint dp[11][1<<11] = {};\n\t\trep(i,n) rep(j,1<<n) dp[i][j] = inf;\n\t\tdp[0][1] = 0;\n\t\trep(j,1<<n) rep(i,n) if (dp[i][j]!=inf)\n\t\t\trep(k,n) if (!(j>>k&1)) chmin(dp[k][j|(1<<k)], dp[i][j]+d[i][k]);\n\t\tint res = inf;\n\t\trep(i,n) chmin(res, dp[i][(1<<n)-1]);\n\t\tcout << res << ln;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint INF=1e7;\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\nchar t[20][20];\nint d[20][20][1024];\nint h,w;\n\n\nvoid init(){\n  for(int i=0;i<20;i++)\n    for(int j=0;j<20;j++)\n      for(int k=0;k<1024;k++)\n        d[i][j][k]=INF;\n}\n\nint solve(int sy,int sx,int cnt){\n  queue<int> qx,qy,qbit;\n  qy.push(sy);\n  qx.push(sx);\n  qbit.push(0);\n  d[sy][sx][0]=0;\n  while(!qy.empty()){\n    int y=qy.front();qy.pop();\n    int x=qx.front();qx.pop();\n    int bit=qbit.front();qbit.pop();\n    \n    if(bit+1 == (1<<cnt)){\n      return d[y][x][bit];\n    }\n    \n    \n    for(int i=0;i<4;i++){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      int nbit=bit;\n      if(ny<0||nx<0)continue;\n      if(ny>=h||nx>=w)continue;\n      if(t[ny][nx]=='x')continue;\n      if(t[ny][nx]!='.'){\n        int num=t[ny][nx]-'0';\n        nbit=nbit|(1<<num);\n      }\n      int ncost=d[y][x][bit]+1;\n      if(ncost < d[ny][nx][nbit]){\n        d[ny][nx][nbit]=ncost;\n        qy.push(ny);\n        qx.push(nx);\n        qbit.push(nbit);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    init();\n    int cnt=0,si,sj;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin>>t[i][j];\n        if(t[i][j]=='*'){\n          t[i][j]='0'+cnt;\n          cnt++;\n        }\n        if(t[i][j]=='o'){\n          t[i][j]='.';\n          si=i;\n          sj=j;\n        }\n      }\n    }\n    cout<<solve(si,sj,cnt)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing pii = pair<int, int>;\n\nconstexpr int INF = (1 << 12);\nconstexpr int dir[5] = {0, 1, 0, -1, 0};\n\nbool ispower(int n)\n{\n    return n == (pow(2, static_cast<int>(log2(n))));\n}\n\nvoid bfs_dist(const vector<vector<int>>& room, const pii& pos, vector<int>& dist, const vector<pii>& dirty)\n{\n    const int h = room.size();\n    const int w = room[0].size();\n    int rest = dirty.size();\n    vector<vector<bool>> checked(h, vector<bool>(w, false));\n    vector<bool> visited(dirty.size(), false);\n    queue<pair<pii, int>> q;\n    q.push(make_pair(pos, 0));\n    checked[pos.first][pos.second] = true;\n    while (not q.empty()) {\n        const pii p = q.front().first;\n        const int distance = q.front().second;\n        const int pi = p.first;\n        const int pj = p.second;\n        for (int i = 0; i < dirty.size(); i++) {\n            if (p == dirty[i] and (not visited[i])) {\n                dist[i] = distance;\n                visited[i] = true;\n                rest--;\n                if (rest == 0) {\n                    return;\n                }\n            }\n        }\n        q.pop();\n        for (int d = 0; d < 4; d++) {\n            const int newi = pi + dir[d];\n            const int newj = pj + dir[d + 1];\n            if (0 <= newi and newi < h and 0 <= newj and newj < w) {\n                if (room[newi][newj] != -1 and (not checked[newi][newj])) {\n                    checked[newi][newj] = true;\n                    q.push(make_pair(make_pair(newi, newj), distance + 1));\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        int h, w;\n        cin >> w >> h;\n        if (w == 0 and h == 0) {\n            break;\n        }\n        vector<vector<int>> room(h, vector<int>(w));\n\n        pii start;\n        vector<pii> dirty;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                char c;\n                cin >> c;\n                if (c == '.') {\n                    room[i][j] = 0;\n                } else if (c == '*') {\n                    room[i][j] = 1;\n                    dirty.push_back(make_pair(i, j));\n                } else if (c == 'x') {\n                    room[i][j] = -1;\n                } else {\n                    room[i][j] = 0;\n                    start.first = i;\n                    start.second = j;\n                }\n            }\n        }\n\n        const int dirtynum = dirty.size();\n        vector<vector<int>> dist(dirtynum, vector<int>(dirtynum, INF));\n        vector<int> initdist(dirtynum, INF);\n        bfs_dist(room, start, initdist, dirty);\n        for (int i = 0; i < dirtynum; i++) {\n            bfs_dist(room, dirty[i], dist[i], dirty);\n        }\n\n        bool flag = false;\n        for (int i = 0; i < dirtynum; i++) {\n            if (initdist[i] == INF) {\n                cout << -1 << endl;\n                flag = true;\n                break;\n            }\n        }\n        if (flag) {\n            continue;\n        }\n\n        const int maximum = 1 << dirtynum;\n        vector<vector<int>> dp(maximum, vector<int>(dirtynum, INF));  // dp[visited[last]\n        for (int n = 1; n < maximum; n++) {\n            for (int i = 0; i < dirtynum; i++) {\n                if ((n >> i) % 2) {\n                    for (int j = 0; j < dirtynum; j++) {  //i->j\n                        if ((n >> j) % 2) {\n                            if (i == j) {\n                                if (ispower(n)) {\n                                    dp[n][i] = initdist[i];\n                                }\n                                continue;\n                            }\n                            dp[n][j] = min(dp[n][j], dp[n - (1 << j)][i] + dist[i][j]);\n                        }\n                    }\n                }\n            }\n        }\n        int mini = INF;\n        for (int i = 0; i < dirtynum; i++) {\n            mini = min(mini, dp[maximum - 1][i]);\n        }\n        cout << mini << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 21\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h;\nstring mp[N];\nint G[N][N];\nmap<P,int>M;\n\nvoid bfs(P start){\n  int D[N][N];\n  memset(D,-1,sizeof(D));\n  queue<P> Q;\n  Q.push(start);\n  int x=start.first,y=start.second;\n  D[y][x]=0;\n  while(!Q.empty()){\n    P t=Q.front();Q.pop();\n    x=t.first,y=t.second;\n\n    if(mp[y][x]=='*'||mp[y][x]=='o') G[M[start]][M[t]]=D[y][x];\n\n    int dx[]={0,0,-1,1},dy[]={1,-1,0,0};\n    for(int i=0;i<4;i++){\n      int nx=x+dx[i],ny=y+dy[i],cost=D[y][x]+1;\n      if(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx]=='x')continue;\n      if(D[ny][nx]==-1)Q.push(P(nx,ny)),D[ny][nx]=cost;\n    }\n  }\n}\n\nvector<P> p;\nP start;\nint n,num[11];\n\nint calc(){\n  int res=0;\n  for(int i=1;i<n;i++)res+=G[num[i-1]][num[i]];\n  return res;  \n}\n\nint dfs(int idx){\n  if(idx==n) return calc();\n  int res=1e9;\n  for(int i=1;i<n;i++){\n    if(num[i]>=0)continue;\n    num[i]=idx;\n    res=min(res,dfs(idx+1));\n    num[i]=-1;\n  }\n  return res;\n}\n\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h)break;\n    for(int i=0;i<h;i++) cin>>mp[i];\n    M.clear();\n    p.clear();\n    memset(G,-1,sizeof(G));\n    memset(num,-1,sizeof(num));\n    n=0;\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tP t=P(j,i);\n\tif(mp[i][j]=='*'||mp[i][j]=='o') p.push_back(t),M[t]=n++;\n\tif(mp[i][j]=='o') start=t;\n      }\n    for(int i=0;i<n;i++)bfs(p[i]);\n    int flg=1;\n    for(int i=0;i<n;i++)if(G[0][i]==-1)flg=0;\n    num[0]=M[start];\n    cout <<(flg?dfs(1):-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w) {\n\t\tvs field(h);\n\t\tpii s;\n\t\tvector<pii> dirty;\n\t\tREP(i, h) {\n\t\t\tcin >> field[i];\n\t\t\tREP(j, w) {\n\t\t\t\tif(field[i][j] == 'o') {\n\t\t\t\t\ts = make_pair(i, j);\n\t\t\t\t}\n\t\t\t\tif(field[i][j] == '*') {\n\t\t\t\t\tdirty.push_back(make_pair(i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint dnum = dirty.size();\n\t\tvvi ddist(dnum, vi(dnum, INF));\n\t\tqueue<pii> Q;\n\t\tREP(i, dnum) {\n\t\t\tQ.push(dirty[i]);\n\t\t\tvvi visited(h, vi(w));\n\t\t\tvisited[dirty[i].first][dirty[i].second] = 1;\n\t\t\twhile(!Q.empty()) {\n\t\t\t\tpii p = Q.front();\n\t\t\t\tQ.pop();\n\n\t\t\t\tREP(d, 4) {\n\t\t\t\t\tint ny = p.first + dy[d];\n\t\t\t\t\tint nx = p.second + dx[d];\n\t\t\t\t\t\n\t\t\t\t\tif(nx<0 || w<=nx || ny<0 || h<=ny || visited[ny][nx] || field[ny][nx] == 'x') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(field[ny][nx] == '*') {\n\t\t\t\t\t\tFOR(j, i, dnum-1) {\n\t\t\t\t\t\t\tif(dirty[j].first == ny && dirty[j].second == nx) {\n\t\t\t\t\t\t\t\tddist[i][j] = ddist[j][i] = visited[p.first][p.second];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvisited[ny][nx] = visited[p.first][p.second] + 1;\n\t\t\t\t\tQ.push(make_pair(ny, nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t\t\n\t\tvi cdist(dnum, INF);\n\t\tQ.push(s);\n\t\tvvi visited(h, vi(w));\n\t\tvisited[s.first][s.second] = 1;\n\t\twhile(!Q.empty()) {\n\t\t\tpii p = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tREP(d, 4) {\n\t\t\t\tint ny = p.first + dy[d];\n\t\t\t\tint nx = p.second + dx[d];\n\n\t\t\t\tif(nx<0 || w<=nx || ny<0 || h<=ny || visited[ny][nx] || field[ny][nx] == 'x') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(field[ny][nx] == '*') {\n\t\t\t\t\tREP(j, dnum) {\n\t\t\t\t\t\tif(dirty[j].first == ny && dirty[j].second == nx) {\n\t\t\t\t\t\t\tcdist[j] = visited[p.first][p.second];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvisited[ny][nx] = visited[p.first][p.second] + 1;\n\t\t\t\tQ.push(make_pair(ny, nx));\n\t\t\t}\n\t\t}\n\n\t\tvvi dp(1<<dnum, vi(dnum, INF));\n\t\tREP(i, 1<<dnum) {\n\t\t\tREP(j, dnum) {\n\t\t\t\tif(i == 0) {\n\t\t\t\t\tdp[1<<j][j] = cdist[j];\n\t\t\t\t} else {\n\t\t\t\t\tREP(k, dnum) {\n\t\t\t\t\t\tdp[i|(1<<k)][k] = min(dp[i|(1<<k)][k], dp[i][j]+ddist[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tREP(i, dnum) {\n\t\t\tans = min(ans, dp[(1<<dnum)-1][i]);\n\t\t}\n\n\t\tcout << (ans == INF ? -1 : ans) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint W,H,index[20][20],dp[20][20][1024],fin_state; //dp[row][col][??¶???] = ????°??????????\nchar table[20][21];\n\nstruct Info{\n\tInfo(){\n\t\trow = 0;\n\t\tcol = 0;\n\t\tstate = 0;\n\t\tcost = 0;\n\t}\n\n\tInfo(int arg_row,int arg_col,int arg_state,int arg_cost){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tstate = arg_state;\n\t\tcost = arg_cost;\n\t}\n\tint row,col,state,cost;\n};\n\nInfo start;\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0},target_count,next_state;\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint main(){\n\n\tint ans,next_row,next_col;\n\tqueue<Info> Q;\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\ttarget_count = 0;\n\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tscanf(\"%s\",table[i]);\n\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\tswitch(table[i][k]){\n\t\t\t\tcase '.':\n\t\t\t\t\t//Do nothing\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\tindex[i][k] = target_count;\n\t\t\t\t\ttarget_count++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'x':\n\t\t\t\t\t//Do nothing\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'o':\n\t\t\t\t\tstart.row = i;\n\t\t\t\t\tstart.col = k;\n\t\t\t\t\tstart.state = 0;\n\t\t\t\t\tstart.cost = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\tfor(int p = 0; p < pow(2,target_count);p++)dp[i][k][p] = BIG_NUM;\n\t\t\t}\n\t\t}\n\n\t\tfin_state = pow(2,target_count)-1;\n\n\t\twhile(!Q.empty())Q.pop();\n\n\t\tans = BIG_NUM;\n\n\t\tdp[start.row][start.col][0] = 0;\n\t\tQ.push(start);\n\n\t\twhile(!Q.empty()){\n\n\t\t\tif(Q.front().state == fin_state){\n\t\t\t\tans = Q.front().cost;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(Q.front().cost != dp[Q.front().row][Q.front().col][Q.front().state]){\n\t\t\t\tQ.pop();\n\t\t\t\tcontinue;\n\t\t\t}else{\n\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tnext_row = Q.front().row + diff_row[i];\n\t\t\t\t\tnext_col = Q.front().col + diff_col[i];\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == false || table[next_row][next_col] == 'x')continue;\n\n\t\t\t\t\tif(table[next_row][next_col] == '.' || table[next_row][next_col] == 'o'){\n\t\t\t\t\t\tif(dp[Q.front().row][Q.front().col][Q.front().state] + 1 < dp[next_row][next_col][Q.front().state]){\n\t\t\t\t\t\t\tdp[next_row][next_col][Q.front().state] = dp[Q.front().row][Q.front().col][Q.front().state] + 1;\n\t\t\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().state,dp[next_row][next_col][Q.front().state]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\tif(Q.front().state & (1 << index[next_row][next_col])){\n\n\t\t\t\t\t\t\tif(dp[Q.front().row][Q.front().col][Q.front().state] + 1 < dp[next_row][next_col][Q.front().state]){\n\t\t\t\t\t\t\t\tdp[next_row][next_col][Q.front().state] = dp[Q.front().row][Q.front().col][Q.front().state] + 1;\n\t\t\t\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().state,dp[next_row][next_col][Q.front().state]));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tnext_state = Q.front().state + pow(2,index[next_row][next_col]);\n\t\t\t\t\t\t\tif(dp[Q.front().row][Q.front().col][Q.front().state] + 1 < dp[next_row][next_col][next_state]){\n\t\t\t\t\t\t\t\tdp[next_row][next_col][next_state] = dp[Q.front().row][Q.front().col][Q.front().state] + 1;\n\t\t\t\t\t\t\t\tQ.push(Info(next_row,next_col,next_state,dp[next_row][next_col][next_state]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\n\t\tif(ans == BIG_NUM)printf(\"-1\\n\");\n\t\telse{\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1000000007\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n#define ull unsigned long long\n#define vi vector<ll>\n#define vvi vector<vi>\n#define DBG_N(hoge) cerr<<\" \"<<(hoge)<<endl;\n#define DBG cerr<<\"!\"<<endl;\n#define BITLE(n) (1LL<<((ll)n))\n#define BITCNT(n) (__builtin_popcountll(n))\n#define SUBS(s,f,t) ((s).substr((f)-1,(t)-(f)+1))\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\nstruct Grid{\n  ll x,y,t;\n};\nll vx[4] = {1,0,-1,0};\nll vy[4] = {0,1,0,-1};\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n,m;\n  while(cin>>n>>m,n){\n    string s[m+1];\n    ll cnt = 0;\n    pair<ll,ll>start;\n    vi num;\n    vector<pair<ll,ll>>kitanai(33);\n    ll dist[33][33];\n    for(int i=0;i<33;i++)for(int j=0;j<33;j++)dist[i][j] = llINF;\n\n    for(int i=0;i<m;i++){\n      cin>>s[i];\n      for(int j=0;j<n;j++){\n\tif(s[i][j] == 'o'){\n\t  kitanai[0] = mp(i,j);\n\t  s[i][j] = '0';\n\t}else if(s[i][j] == '*'){\n\t  kitanai[cnt+1] = mp(i,j);\n\t  s[i][j] = (char)(cnt+1+'0');\n\t  num.pb(cnt+1);\n\t  cnt++;\n\t}\n      }\n    }\n\n    for(int i=0;i<kitanai.size();i++){\n      queue<Grid>que;\n      que.push({kitanai[i].F,kitanai[i].S,0});\n      bool visited[33][33] = {};\n      visited[kitanai[i].F][kitanai[i].S] = true;\n      while(!que.empty()){\n\tGrid g = que.front();\n\tque.pop();\n\tfor(int k=0;k<4;k++){\n\t  ll x = g.x+vx[k];\n\t  ll y = g.y+vy[k];\n\t  if(x < 0 || x >= m || y < 0|| y >= n ||\n\t     s[x][y] == 'x' || visited[x][y])continue;\n\n\t  visited[x][y] = true;\n\t  if(s[x][y] != '.'){\n\t    dist[i][s[x][y]-'0'] = g.t+1;\n\t    dist[s[x][y]-'0'][i] = g.t+1;\n\t  }\n\t  que.push({x,y,g.t+1});\n\t}\n      }\n    }\n    ll ans = llINF;\n    do{\n      ll sum = 0;\n      sum += dist[0][num[0]];\n      for(int i=1;i<num.size();i++){\n\tsum += dist[num[i-1]][num[i]];\n      }\n      ans = min(ans,sum);\n    }while(next_permutation(ALL(num)));\n    if(ans == llINF)cout<<-1<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//47\n#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nstruct S{\n  int x,y,d,t;\n};\n\nusing namespace std;\n\nint main(){\n  for(int w,h;cin>>w>>h,w|h;){\n    char g[20][20];\n    int d=0;\n    int m[20][20]={{}};\n    int x,y;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>g[i][j];\n\tif(g[i][j]=='o'){\n\t  x=j;\n\t  y=i;\n\t}else if(g[i][j]=='*'){\n\t  m[i][j]=d++;\n\t}\n      }\n    }\n    queue<S> que;\n    S is={x,y,0,0};\n    que.push(is);\n    bool p[20][20][1<<10]={{{}}};\n    while(!que.empty()){\n      if(que.front().d==(1<<d)-1)break;\n      S c=que.front();\n      que.pop();\n      if(p[c.y][c.x][c.d]++)continue;\n      for(int i=0;i<4;i++){\n\tint d[]={0,1,0,-1,0};\n\tint ny=c.y+d[i];\n\tint nx=c.x+d[i+1];\n\tif(0<=ny&&ny<h&&0<=nx&&nx<w&&g[ny][nx]!='x'){\n\t  int nd=c.d;\n\t  if(g[ny][nx]=='*'){\n\t    nd|=1<<m[ny][nx];\n\t  }\n\t  S ns={nx,ny,nd,c.t+1};\n\t  que.push(ns);\n\t}\n      }\n    }\n    cout<<(que.empty()?-1:que.front().t)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstring>\n \nusing namespace std;\n \n#define MAX 25\n#define INF (1<<29)\ntypedef pair<int,int> P;\n \nint H,W;\nchar field[MAX][MAX];\nvector<P> vec;\nconst int dx[] = {-1,0,0,1};\nconst int dy[] = {0,-1,1,0};\n \nstruct State{\n    int x,y,S;\n    State() {}\n    State(int x,int y,int S) : x(x),y(y),S(S) {}\n};\n \nbool inField(int y,int x){\n    return 0 <= y && y < H && 0 <= x && x < W;\n}\n \nint bfs(int sx,int sy,int gx,int gy){\n    int res = INF;\n    int dist[MAX][MAX];\n    for(int i = 0 ; i < H ; i++){\n\tfor(int j = 0 ; j < W ; j++){\n\t    dist[i][j] = INF;\n\t}\n    }\n    dist[sy][sx] = 0;\n    queue<P> Q;\n    Q.push(P(sx,sy));\n \n    while(!Q.empty()){\n\tP p = Q.front(); Q.pop();\n\tif(p.first == gx && p.second == gy){\n\t    res = dist[gy][gx];\n\t    break;\n\t}\n\tfor(int i = 0 ; i < 4 ; i++){\n\t    int nx = p.first + dx[i];\n\t    int ny = p.second + dy[i];\n\t    if(!inField(ny,nx)) continue;\n\t    if(field[ny][nx] == 'x') continue;\n\t    if(dist[p.second][p.first] + 1 < dist[ny][nx]){\n\t\tdist[ny][nx] = dist[p.second][p.first] + 1;\n\t\tQ.push(P(nx,ny));\n\t    } \n\t}\n    }\n \n    return res;\n}\n \nvoid solve(int x,int y){\n    int size = vec.size(),ans = INF;\n    int dist[MAX][MAX][1<<10];\n    for(int i = 0 ; i < H ; i++){\n\tfor(int j = 0 ; j < W ; j++){\n\t    for(int k = 0 ; k < 1<<size ; k++){\n\t\tdist[i][j][k] = INF;\n\t    }\n\t}\n    }\n    dist[y][x][0] = 0;\n    queue<State> Q;\n    Q.push(State(x,y,0));\n    while(!Q.empty()){\n\tState now = Q.front(); Q.pop();\n\tif(__builtin_popcount(now.S) == size){\n\t    ans = min(ans,dist[now.y][now.x][now.S]);\n\t    continue;\n\t}\n \n\tfor(int i = 0 ; i < size ; i++){\n\t    int S = now.S;\n\t    if(now.S >> i & 1) continue;\n\t    S |= 1<<i;\n\t    int nx = vec[i].second, ny = vec[i].first;\n\t    int d = bfs(now.x,now.y,nx,ny);\n\t    if(dist[now.y][now.x][now.S] + d < dist[ny][nx][S]){\n\t\tdist[ny][nx][S] = d + dist[now.y][now.x][now.S];;\n\t\tQ.push(State(nx,ny,S));\n\t    } \n\t}\n    }\n \n    cout << (ans == INF ? -1 : ans) << endl;\n}\n \nint main(){\n    int sx,sy;\n    while(cin >> W >> H, (W | H)){\n\tvec.clear();\n\tfor(int i = 0 ; i < H ; i++){\n\t    for(int j = 0 ; j < W ; j++){\n\t\tcin >> field[i][j];\n\t\tif(field[i][j] == 'o'){\n\t\t    sx = j; sy = i;\n\t\t}else if(field[i][j] == '*'){\n\t\t    vec.push_back(P(i,j));\n\t\t}\n\t    }\n\t}\n\tsolve(sx,sy);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 31\n\nint w, h;\nchar tile_c[31][31];\nint tile[31][31] = {};\nint pos_y[11], pos_x[11];\nint pos_size = 0;\nint dist[11][11];\n\nvoid search(int start){\n  queue<pair<int,int> > que;\n  bool visited[SIZE][SIZE] = {};\n\n  que.push({pos_y[start], pos_x[start]});\n  \n  for(int i=0;que.size();i++){\n    queue<pair<int,int> > q2;\n    while(que.size()){\n      int y = que.front().first;\n      int x = que.front().second;\n      que.pop();\n\n      if(visited[y][x]) continue;\n      visited[y][x] = true;\n\n      if(tile[y][x] == -1) continue;\n      \n      if(tile[y][x] > 0){\n        dist[start][tile[y][x]] = i;\n      }\n\n      int dx[4] = {0,0,1,-1};\n      int dy[4] = {1,-1,0,0};\n      for(int j=0;j<4;j++){\n        int ny = y + dy[j], nx = x + dx[j];\n        if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n        q2.push({ny, nx});\n      }\n    }\n    que = q2;\n  }\n}\n\nint solve(){\n  scanf(\"%d%d\", &w, &h);\n\n  if(w == 0) return false;\n\n  pos_size = 0;\n  \n  for(int i=0;i<h;i++){\n    scanf(\"%s\", tile_c[i]);\n\n    for(int j=0;j<w;j++){\n      tile[i][j] = 0;\n      \n      if(tile_c[i][j] == 'o'){\n        pos_y[0] = i;\n        pos_x[0] = j;\n      }\n      if(tile_c[i][j] == 'x'){\n        tile[i][j] = -1;\n      }\n      if(tile_c[i][j] == '*'){\n        pos_size++;\n        pos_y[pos_size] = i;\n        pos_x[pos_size] = j;\n        tile[i][j] = pos_size;\n      }\n    }\n  }\n\n  for(int i=0;i<=pos_size;i++)\n    for(int j=0;j<=pos_size;j++)\n      dist[i][j] = INF;\n\n  for(int i=0;i<=pos_size;i++)\n    search(i);\n  \n  int dp[1<<11][11];\n\n  for(int i=0;i<(1<<pos_size);i++)\n    for(int j=0;j<pos_size;j++)\n      dp[i][j] = INF;\n\n  for(int i=0;i<pos_size;i++){\n    dp[1<<i][i] = dist[0][i+1];\n  }\n  \n  for(int i=0;i<(1 << pos_size);i++){\n    for(int j=0;j<pos_size;j++){\n      if(dp[i][j] == INF) continue;\n      \n      for(int k=0;k<pos_size;k++){\n        if(i & (1 << k)) continue;\n        dp[i | (1<<k)][k] = min(dp[i | (1<<k)][k],\n                                dp[i][j] + dist[j+1][k+1]);\n      }\n    }\n  }\n  \n  int ans = INF;\n\n  for(int i=0;i<pos_size;i++){\n    ans = min(ans, dp[(1<<pos_size)-1][i]);\n  }\n\n  if(ans == INF) ans = -1;\n\n  printf(\"%d\\n\",ans);\n  \n  return true;\n}\n\nint main(){\n  while(solve());\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint h, w, k[21][21], cnt;\nint cx[11], cy[11], y[11][11], z[11][11], bfs[21][21], a, b, c[10], sum, minx;\nchar p;\n\nvoid BFS(int i) {\n\tqueue<int> Q; \n\tmemset(bfs, 10, sizeof(bfs));\n\tbfs[cy[i]][cx[i]] = 0;\n\tQ.push(cy[i] * 20 + cx[i]);\n\twhile (!Q.empty()) {\n\t\ta = Q.front() / 20;\n\t\tb = Q.front() % 20;\n\t\tif (k[a - 1][b] == 0 && bfs[a - 1][b] >= 1000000) {\n\t\t\tQ.push(Q.front() - 20);\n\t\t\tbfs[a - 1][b] = bfs[a][b] + 1;\n\t\t}\n\t\tif (k[a + 1][b] == 0 && bfs[a + 1][b] >= 1000000) {\n\t\t\tQ.push(Q.front() + 20);\n\t\t\tbfs[a + 1][b] = bfs[a][b] + 1;\n\t\t}\n\t\tif (k[a][b + 1] == 0 && bfs[a][b + 1] >= 1000000) {\n\t\t\tQ.push(Q.front() + 1);\n\t\t\tbfs[a][b + 1] = bfs[a][b] + 1;\n\t\t}\n\t\tif (k[a][b - 1] == 0 && bfs[a][b - 1] >= 1000000) {\n\t\t\tQ.push(Q.front() - 1);\n\t\t\tbfs[a][b - 1] = bfs[a][b] + 1;\n\t\t}\n\t\tQ.pop();\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tmemset(z, 0, sizeof(z));\n\t\tcin >> w >> h; cnt = 1; if (!w) { break; }\n\t\tfor (int i = 0; i < 21; i++) { \n\t\t\tfor (int j = 0; j < 21; j++) { \n\t\t\t\tk[i][j] = 1; \n\t\t\t} \n\t\t}\n\t\tcnt = 1;\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tcin >> p;\n\t\t\t\tif (p != 'x') { k[i][j] = 0; }\n\t\t\t\tif (p == '*') { cx[cnt] = j; cy[cnt] = i; cnt++; }\n\t\t\t\tif (p == 'o') { cx[0] = j; cy[0] = i; }\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\tc[i] = i;\n\t\t\tBFS(i);\n\t\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\t\tz[i][j] = bfs[cy[j]][cx[j]];\n\t\t\t}\n\t\t}\n\t\tminx = 114514;\n\t\tdo\n\t\t{\n\t\t\tsum = z[0][c[0] + 1];\n\t\t\tfor (int i = 0; i < cnt - 1; i++) { sum += z[c[i] + 1][c[i + 1] + 1]; }\n\t\t\tminx = min(minx, sum);\n\t\t} while (next_permutation(c, c + cnt - 1));\n\t\tif (minx == 114514) { minx = -1; }\n\t\tcout << minx << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (int)1e9\nusing namespace std;\n\nstruct data {\n  int x, y, cleaned;\n};\n\nint w, h;\nint dis[25][25][2000] = {0};\nint d[4] = {0, 1, 0, -1};\nvector<string> s;\nvector<vector<int>> memo;\nqueue<data> qu;\n\nint solve();\nbool ch(data &now);\n\nint main() {\n  while(1) {\n    cin >> w >> h;\n    if(h + w == 0) break;\n    s.resize(h);\n    for(int i = 0; i < h; ++i) cin >> s[i];\n    memo.assign(h, vector<int>(w, -1));\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nint solve() {\n  int cnt = 0, ans = inf;\n  for(int i = 0; i < h; ++i)\n    for(int j = 0; j < w; ++j) {\n      if(s[i][j] == 'o') {\n        qu.push({i, j, 0});\n        dis[i][j][0] = 0;\n        s[i][j] = '.';\n      }\n      if(s[i][j] == '*') memo[i][j] = cnt++;\n    }\n  for(int i = 0; i < h; ++i)\n    for(int j = 0; j < w; ++j)\n      for(int k = 0; k < (1 << cnt); ++k)\n        dis[i][j][k] = inf;\n  dis[qu.front().x][qu.front().y][0] = 0;\n  while(qu.size() > 0) {\n    data now = qu.front();\n    qu.pop();\n    for(int i = 0; i < 4; ++i) {\n      data nextp = now;\n      nextp.x += d[i];\n      nextp.y += d[1 ^ i];\n      if(!ch(nextp)) continue;\n      if(s[nextp.x][nextp.y] == '*')\n        nextp.cleaned |= (1 << memo[nextp.x][nextp.y]);\n      if(dis[nextp.x][nextp.y][nextp.cleaned] >\n         dis[now.x][now.y][now.cleaned] + 1) {\n        dis[nextp.x][nextp.y][nextp.cleaned] =\n            dis[now.x][now.y][now.cleaned] + 1;\n        qu.push(nextp);\n      }\n    }\n  }\n  for(int i = 0; i < h; ++i)\n    for(int j = 0; j < w; ++j)\n      ans = min(ans, dis[i][j][(1 << cnt) - 1]);\n  if(ans == inf) return -1;\n  return ans;\n}\n\nbool ch(data &now) {\n  return now.x >= 0 && now.x < h && now.y >= 0 &&\n         now.y < w && s[now.x][now.y] != 'x';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec; typedef pair<int, int> pi;\nint dd[] = { 0, 1, 0, -1, 0 };\n#define all(u) begin(u),end(u)\n#define mp make_pair\n#define pb push_back\n#define MAX 20\nint H, W;\nchar C[MAX][MAX];\nint B[MAX][MAX];\nint D[MAX][MAX];\nvector<pi> G;\nint sy, sx;\n\nint ans;\nvoid dfs(int now, int check, int dis)\n{\n  if(check==(1<<G.size())-1)\n    {\n      ans=min(ans,dis);\n    }\n\n  rep(i,G.size())\n    {\n      if((check>>i) & 1)continue;\n      dfs(i,check|(1<<i),dis+D[now][i]);\n    }\n}\n\nint main()\n{\n  while(true)\n    {\n      cin >> W >> H;\n      if(H==0&&W==0)return 0;\n      G.clear();\n      rep(i,H)\n\t{\n\t  rep(j,W)\n\t    {\n\t      cin >> C[i][j];\n\t      if(C[i][j]=='*')G.pb(pi(i,j));\n\t      else if(C[i][j]=='o')\n\t\t{\n\t\t  sy=i;\n\t\t  sx=j;\n\t\t}\n\t    }\n\t}\n\n      G.pb(pi(sy,sx));\n\n      bool ok=true;\n      //point to point\n      rep(i,G.size())\n\t{\n\t  repi(j,i+1,G.size())\n\t    {\n\t      queue<pi> Q;\n\t      Q.push(G[i]);\n\t      memset(B,-1,sizeof(B));\n\t      B[G[i].first][G[i].second]=0;\n\t      bool flag=false;\n\t      while(!Q.empty())\n\t\t{\n\t\t  int ty = Q.front().first;\n\t\t  int tx = Q.front().second;\n\t\t  Q.pop();\n\t\t  if(ty==G[j].first && tx==G[j].second)\n\t\t    {\n\t\t      flag=true;\n\t\t    }\n\t\t  rep(r,4)\n\t\t    {\n\t\t      int y = ty + dd[r];\n\t\t      int x = tx + dd[r+1];\n\t\t      if(y<0||y>=H||x<0||x>=W)continue;\n\t\t      if(C[y][x]=='x')continue;\n\t\t      if(B[y][x]==-1 || B[ty][tx]+1<B[y][x])\n\t\t\t{\n\t\t\t  B[y][x]=B[ty][tx]+1;\n\t\t\t  Q.push(pi(y,x));\n\t\t\t}\n\t\t    }\n\t\t}\n\t      if(flag)\n\t\t{\n\t\t  D[i][j]=B[G[j].first][G[j].second];\n\t\t  D[j][i]=D[i][j];\n\t\t}\n\t      else\n\t\t{\n\t\t  ok=false;\n\t\t}\n\t    }\n\t  \n\t}\n      if(!ok)\n\t{\n\t  cout << \"-1\" << endl;\n\t  continue;\n\t}\n      /*rep(i,G.size())\n\t{\n\t  rep(j,G.size())\n\t    {\n\t      printf(\"%d \",D[i][j]);\n\t    }\n\t  printf(\"\\n\");\n\t  }*/\n      ans=114154;\n      dfs(G.size()-1, 1<<(G.size()-1), 0);\n\n      cout << ans << endl;\n    }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint w,h;\nint b;\nchar c[33][33];\n\nstruct P{\n  int x,y;\n  P(int x,int y):x(x),y(y){}\n};\n\nvector<P> v;\nint used[33][33];\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nint d[11][11];\nint p;\n\nint dp[1<<11][11];\nint solve(int bit,int a){\n  if(bit == (1<<p)-1) return 0;\n  if(dp[bit][a] >= 0) return dp[bit][a];\n\n  int ret = 1 << 28;\n  for(int i = 1; i < p; i++){\n    if(bit & 1 << i)continue;\n    ret = min(ret,solve(bit | 1<<i,i) + d[a][i]);\n  }\n  return dp[bit][a] = ret;\n}\n\nint main(void){\n  while(cin >> w >> h && w){\n    v.clear();\n    memset(c,-1,sizeof(c));\n    v.push_back(P(0,0));\n    p = 1;\n    for(int i = 1; i <= h; i++){\n      for(int j = 1; j <= w; j++){\n\tcin >> c[j][i];\n\tif(c[j][i] == 'o'){\n\t  c[j][i] = 0;\n\t  v[0].x = j;\n\t  v[0].y = i;\n\t}else if(c[j][i] == '*'){\n\t  c[j][i] = p;\n\t  p++;\n\t  v.push_back(P(j,i));\n\t}else if(c[j][i] == 'x'){\n\t  c[j][i] = -1;\n\t}\n      }\n    }\n\n    memset(d,-1,sizeof(d));\n    bool f = false;\n    for(int i = 0; i < p; i++){\n      memset(used,-1,sizeof(used));\n      queue<P> que;\n      que.push(P(v[i].x,v[i].y));\n      used[v[i].x][v[i].y] = 0;\n      while(!que.empty()){\n\tP a = que.front(); que.pop();\n\tif(c[a.x][a.y] == -1) continue;\n\tif(c[a.x][a.y] != '.'){\n\t  //cout << (int)c[a.x][a.y] << \" : \" << used[a.x][a.y] << endl;\n\t  d[i][(int)c[a.x][a.y]] = used[a.x][a.y];\n\t}\n\tfor(int i = 0; i < 4; i++){\n\t  int nx = a.x + dx[i];\n\t  int ny = a.y + dy[i];\n\t  if(used[nx][ny] == -1){\n\t    que.push(P(nx,ny));\n\t    used[nx][ny] = used[a.x][a.y] + 1;\n\t  }\n\t}\n      }\n\n      for(int j = 0; j < p; j++){\n\t//cout << i << \" > \" << j << \" = \" << d[i][j] << endl;\n\tif(d[i][j] == -1){\n\t  f = true;\n\t  break;\n\t}\n      }\n      if(f) break;\n    }\n    if(f){\n      cout << -1 << endl;\n    }else{\n      memset(dp,-1,sizeof(dp));\n      cout << solve(1,0) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\nusing namespace std;\n\n#define INF 1e9\n\nint dfs(int nowobject, int size, vector<vector<int> > &all_pairs, vector<bool> &used, int dist){\n  used[nowobject] = true;\n  int mindist = INF;\n  bool endflag = true;\n  \n  for(int i = 0; i < size; i++){\n    if(!used[i]){\n      endflag = false;\n      int tmp = dfs(i, size, all_pairs, used, dist + all_pairs[nowobject][i]);\n      if(mindist > tmp){ mindist = tmp; }\n    }\n  }\n\n  if(endflag){ mindist = dist; }\n  used[nowobject] = false;\n  return mindist;\n}\n\n\nint main(void){\n  while(true){\n    int w, h;\n    cin >> w >> h;\n    if(w == 0 && h == 0){ break; }\n\n    // ?????????????????±?????\\???\n    const int C = -1, F = -2;\n    int robot;\n    string s;\n    vector<vector<int> > map(h, vector<int>(w));\n    vector<pair<int, int> > object; \n    for(int i = 0; i < h; i++){\n      cin >> s;\n      for(int j = 0; j < w; j++){\n        if(s[j] == '.'){ map[i][j] = C; }\n        else if(s[j] == 'x'){ map[i][j] = F; }\n        else{\n          if(s[j] == 'o'){ robot = object.size(); }\n          map[i][j] = object.size();\n          object.push_back(make_pair(i, j));\n        }\n      }\n    }\n\n    // ???????????§???????????°??????bfs??????????????¨??????????±???????\n    const int x[4] = {-1, 0, 1, 0};\n    const int y[4] = {0, -1, 0, 1};\n    vector<vector<int> > all_pairs(object.size(), vector<int>(object.size(), INF));\n    for(int i = 0; i < object.size(); i++){ all_pairs[i][i] = 0; }\n    for(int i = 0; i < object.size(); i++){\n      vector<vector<bool> > used(h, vector<bool>(w, false));\n      queue<pair<pair<int, int>, int> > q;\n      used[object[i].first][object[i].second] = true;\n      q.push(make_pair(object[i], 0));\n\n      while(!q.empty()){\n        pair<int, int> now = q.front().first;\n        int dist = q.front().second + 1;\n        q.pop();\n\n        // ??????????????????\n        for(int j = 0; j < 4; j++){\n          pair<int, int> next = make_pair(now.first + x[j], now.second + y[j]);\n          // ?????¢???????£???????????????????????????¶????????¶???????????£??????????????§?????¢?´¢???????????£?????´???????????????\n          if(next.first < 0 || h <= next.first || next.second < 0 || w <= next.second\n             || map[next.first][next.second] == F || used[next.first][next.second]){\n            continue;\n          }\n\n          // ????????´???or?????????????????¶???????????£????????????????????§????????¢????¨????\n          if(0 <= map[next.first][next.second]){ all_pairs[i][map[next.first][next.second]] = dist; }\n\n          // ?????\\????????????\n          q.push(make_pair(next, dist));\n          used[next.first][next.second] = true;\n        }\n      }\n    }\n\n    // 10!???????????????????????¨??¨??????\n    vector<bool> used(object.size(), false);\n    int result = dfs(robot, object.size(), all_pairs, used, 0);\n\n    // ???????????????\n    if(result == INF){ cout << -1 << endl; }\n    else{ cout << result << endl; }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define all(c) (c).begin(), (c).end()\nconst int inf = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\n\nint w, h;\n\ninline bool inrect(int x, int y){\n    return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nint solve(vector<string>& c){\n    vector<int> xs, ys;\n    rep(i, h)rep(j, w){\n        if(c[i][j] == 'o')xs.insert(xs.begin(), i), ys.insert(ys.begin(), j);\n        if(c[i][j] == '*')xs.push_back(i), ys.push_back(j);\n    }\n    int n = (int)xs.size();\n    vector<vector<int> > costs(n, vector<int>(n, inf));\n    rep(i, n){\n        vector<vector<int> > mem(h, vector<int>(w, inf)); mem[xs[i]][ys[i]] = 0;\n        typedef tuple<int, int, int> State;\n        priority_queue<State> q;\n        for(q.emplace(0, xs[i], ys[i]); !q.empty();){\n            int cost, x, y;\n            tie(cost, x, y) = q.top(); q.pop();\n            if(mem[x][y] != -cost)continue;\n            rep(k, 4){\n                int nx = x + dx[k], ny = y + dy[k];\n                if(!inrect(nx, ny) || c[nx][ny] == 'x' || mem[nx][ny] <= 1 - cost)continue;\n                mem[nx][ny] = 1 - cost;\n                q.emplace(-mem[nx][ny], nx, ny);\n            }\n        }\n        rep(j, n)costs[i][j] = mem[xs[j]][ys[j]];\n    }\n    if(find(all(costs[0]), inf) != costs[0].end())return -1;\n    vector<int> mem(1 << n, inf); mem[1 << 0] = 0;\n    typedef tuple<int, int, int> State;\n    priority_queue<State> q;\n    for(q.emplace(0, 1 << 0, 0); !q.empty();){\n        int cost, vis, v;\n        tie(cost, vis, v) = q.top(); q.pop();\n        if(mem[vis] != -cost)continue;\n        rep(i, n){\n            if(vis >> i & 1 || mem[vis | 1 << i] <= costs[v][i] - cost)continue;\n            mem[vis | 1 << i] = costs[v][i] - cost;\n            q.emplace(-mem[vis | 1 << i], vis | 1<< i, i);\n        }\n    }\n    return mem[(1 << n) - 1];\n}\n\nint main(){\n    while(cin >> w >> h, w|h){\n        vector<string> c(h);\n        rep(i, h)cin >> c[i];\n        cout << solve(c) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nint w,h,d[20][20],ii,sum,color[20][20],x,y,map[20][20],a,dp[1<<11][20];\nint xy[4][2]={{-1,0},{1,0},{0,-1},{0,1}};\nchar c[20][20];\nvector<pair<int,int> > v;\npair<int,int> u;\nqueue<pair<int,int> > q;\n\nint rec(int S,int v)\n{\n  if(dp[S][v]>=0){\n    return dp[S][v];\n  }\n  if(S==(1<<a)-1 && v==0){\n    return dp[S][v]=0;\n  }\n  int res=1000000001;\n  for(int i=0;i<a;i++){\n    if(!(S>>i&1)){\n      res=min(res,rec(S|1<<i,i)+map[v][i]);\n    }\n  }\n  return dp[S][v]=res;\n}\n\nint main()\n{\n  while(1){\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    v.clear();\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>c[i][j];\n\tif(c[i][j]=='o'){\n\t  x=i;\n\t  y=j;\n\t  v.push_back(make_pair(i,j));\n\t}\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(c[i][j]=='*'){\n\t  v.push_back(make_pair(i,j));\n\t}\n      }\n    }\n    for(int i=0;i<20;i++){\n      for(int j=0;j<20;j++)map[i][j]=0;\n    }\n    sum=0;a=0;\n    for(int k=0;k<v.size();k++){\n      c[x][y]='.';\n      q.push(make_pair(v[k].first,v[k].second));\n      for(int i=0;i<h;i++){\n\tfor(int j=0;j<w;j++)d[i][j]=500000;\n      }\n      d[v[k].first][v[k].second]=0;\n      while(!q.empty()){\n\tu=q.front();q.pop();\n\tfor(int i=0;i<4;i++){\n\t  if(d[u.first+xy[i][0]][u.second+xy[i][1]]!=500000)continue;\n\t  if(c[u.first+xy[i][0]][u.second+xy[i][1]]!='x'){\n\t    q.push(make_pair(u.first+xy[i][0],u.second+xy[i][1]));\n\t    d[u.first+xy[i][0]][u.second+xy[i][1]]=d[u.first][u.second]+1;\n\t  }\n\t}\n      }\n      for(int i=0;i<v.size();i++){\n\tmap[a][i]=d[v[i].first][v[i].second];\n      }\n      a++;\n      if(a==v.size())break;\n    }\n    memset(dp,-1,sizeof(dp));\n    int ans=100000001;\n    for(int i=1;i<a;i++){\n      ans=min(ans,rec(0,i));\n    }\n    if(ans>=500000)cout<<-1<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <chrono>\n#include <queue>\n#include <functional>\nusing namespace std;\n\n#define INF 1e9\n\n//????????????\nclass Timer {\n\tchrono::high_resolution_clock::time_point start, end;\n\tdouble limit;\n\npublic:\n\tTimer() {\n\t\tstart = chrono::high_resolution_clock::now();\n\t}\n\tTimer(double l) {\n\t\tstart = chrono::high_resolution_clock::now();\n\t\tlimit = l;\n\t}\n\n\tdouble getTime() {\n\t\tend = chrono::high_resolution_clock::now();\n\t\treturn chrono::duration<double>(end - start).count();\n\t}\n\n\tbool Over() {\n\t\tif (getTime() > limit) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid setLimit(double l) {\n\t\tlimit = l;\n\t}\n\tvoid setStart() { start = chrono::high_resolution_clock::now(); }\n};\n\nstruct POINT {\n\tint x, y;\n\n\tPOINT() {}\n\tPOINT(int x_, int y_) { x = x_, y = y_; }\n\n\tbool operator<(const POINT& r)const {\n\t\treturn x + y < r.x + r.y;\n\t}\n\n\tPOINT operator+(const POINT& r)const {\n\t\treturn POINT(x + r.x, y + r.y);\n\t}\n};\n\nstruct STATUS {\n\tint dist;\n\n\tint id;\n\tvector<bool>used;\n\n\tSTATUS() {}\n\tSTATUS(int dist_, int id_, vector<bool>used_) {\n\t\tdist = dist_;\n\t\tid = id_;\n\t\tused = used_;\n\t}\n\n\tbool operator>(const STATUS& r)const {\n\t\treturn dist > r.dist;\n\t}\n};\n\nint W, H;\nvector<vector<int>>MAP;\nint status[20][20];\nint cost[20][20];\nvoid dijkstra(POINT p) {\n\tint v[] = { -1,0,1,0 };\n\tint h[] = { 0,1,0,-1 };\n\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tstatus[i][j] = 0;\n\t\t\tcost[i][j] = INF;\n\t\t}\n\t}\n\tcost[p.x][p.y] = 0;\n\tstatus[p.x][p.y] = 1;\n\n\tpriority_queue<pair<int, POINT>, vector<pair<int, POINT>>, greater<pair<int, POINT>>>U;\n\tU.push(make_pair(cost[p.x][p.y], p));\n\twhile (!U.empty()) {\n\t\t//??¢?´¢???????????£??????????????§?????????????°???????\n\t\tPOINT u = U.top().second; U.pop();\n\n\t\tif (status[u.x][u.y] == -1) continue;\n\n\t\tstatus[u.x][u.y] = -1;\n\n\t\t//?????????????°????????????¢???\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPOINT np = u + POINT(v[i], h[i]);\n\t\t\tif (np.x < 0 || np.x >= H || np.y < 0 || np.y >= W)continue;\n\t\t\tif (MAP[np.x][np.y] == 1)continue;\n\t\t\tif (status[np.x][np.y] != -1) {\n\t\t\t\tif (cost[np.x][np.y] > cost[u.x][u.y] + 1) {\n\t\t\t\t\tcost[np.x][np.y] = cost[u.x][u.y] + 1;\n\t\t\t\t\tstatus[np.x][np.y] = 1;\n\t\t\t\t\tU.push(make_pair(cost[np.x][np.y], np));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (1) {\n\t\tcin >> W >> H;\n\n\t\tif (W == 0 && H == 0)break;\n\n\t\tMAP.assign(H,vector<int>(W,0));\n\n\t\tvector<POINT>pos;\n\t\tint cnt = 0;\n\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tchar c; cin >> c;\n\t\t\t\tif (c == '*') {\n\t\t\t\t\tPOINT p = POINT(i, j);\n\t\t\t\t\tpos.push_back(p);\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\telse if (c == 'x')MAP[i][j] = 1;\n\t\t\t\telse if (c == 'o') {\n\t\t\t\t\tPOINT sp = POINT(i, j);\n\t\t\t\t\tpos.insert(pos.begin(), sp);\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool fin = false;\n\t\tvector<vector<int>>dist(cnt);\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\tdist[i].resize(cnt);\n\t\t\tdijkstra(pos[i]);\n\t\t\tfor (int j = 1; j < cnt; j++) {\n\t\t\t\tint distance = cost[pos[j].x][pos[j].y];\n\t\t\t\tif (distance == INF)fin = true;\n\t\t\t\tdist[i][j] = distance;\n\t\t\t}\n\t\t}\n\n\t\tif (fin) {\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tTimer tmr(0.016);\n\t\tvector<priority_queue<STATUS, vector<STATUS>, greater<STATUS>>>STAT(cnt);\n\t\tSTAT[0].push(STATUS(0,0,vector<bool>(cnt)));\n\t\twhile (1) {\n\t\t\tif (tmr.Over())break;\n\n\t\t\tfor (int i = 0; i < cnt - 1; i++) {\n\t\t\t\tif (STAT[i].empty())continue;\n\n\t\t\t\tSTATUS st = STAT[i].top(); STAT[i].pop();\n\n\t\t\t\tfor (int j = 1; j < cnt; j++) {\n\t\t\t\t\tif (st.used[j])continue;\n\n\t\t\t\t\tst.used[j] = true;\n\t\t\t\t\tSTAT[i + 1].push(STATUS(st.dist + dist[st.id][j], j, st.used));\n\t\t\t\t\tst.used[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSTATUS last = STAT[cnt - 1].top();\n\t\tcout << last.dist << endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing msi = map<string, int>;\nusing mii = map<int, int>;\nusing psi = pair<string, int>;\nusing pii = pair<int, int>;\nusing vlai = valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF (ll)1E9\n#define EPS 1E-9\n#define MOD 1000000007\n#define PI 3.1415926535897932384\n\ntemplate <class T>ostream &operator<<(std::ostream &o, const vector<T> &v)\n{\n\trep(i, v.size()) {\n\t\to << (i > 0 ? \" \" : \"\") << v[i];\n\t}\n\treturn o;\n}\n\n//int dx[]={1,1,1,0,-1,-1,-1,0},dy[8]={1,0,-1,-1,-1,0,1,1,1};\nint dx[] = { 1,0,-1,0 }, dy[] = { 0,1,0,-1 };\n\n//constexpr ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\n\nint H, W;\n\nbool ran(int y, int x) {\n\treturn (0 <= y&&y < H && 0 <= x&&x < W);\n}\n\nvoid solve(int w, int h) {\n\tint dnum = 0;\n\tH = h;\n\tW = w;\n\tchar in;\n\tvector<vector<bool>> room(h, vector<bool>(w));\n\ttuple<int, int> st,loc,goal;\n\tvector<tuple<int, int>> dust;\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tcin >> in;\n\t\t\tif (in== 'o') {\n\t\t\t\tst=make_tuple(i, j);\n\t\t\t}\n\t\t\tif (in == '*') {\n\t\t\t\tgoal = make_tuple(i, j);\n\t\t\t\tdust.push_back(goal);\n\t\t\t\tdnum++;\n\t\t\t}\n\t\t\tif (in == 'x') {\n\t\t\t\troom[i][j] = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\troom[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tdust.push_back(st);\n\tvector<vector<int>> dist(dnum+1, vector<int>(dnum+1,0));\n\trep(i, dnum + 1) {\n\t\trange(j, i + 1, dnum + 1) {\n\t\t\ttuple<int, int> s = dust[i];\n\t\t\ttuple<int, int> e = dust[j];\n\t\t\tvector<vector<int>> tmp(h, vector<int>(w, 40));\n\t\t\trep(ii, h) {\n\t\t\t\trep(jj, w) {\n\t\t\t\t\tif (!room[ii][jj]) {\n\t\t\t\t\t\ttmp[ii][jj] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tqueue <tuple<int, int, int>> q;\n\t\t\ttuple<int, int, int> t = make_tuple(get<0>(s), get<1>(s), 0);\n\t\t\tq.push(t);\n\t\t\tbool sw = true;\n\t\t\tint cost=0;\n\t\t\twhile (!q.empty()&&sw) {\n\t\t\t\tt = q.front(); q.pop();\n\t\t\t\tint y = get<0>(t);\n\t\t\t\tint x = get<1>(t);\n\t\t\t\tint d = get<2>(t);\n\t\t\t\tif (d < tmp[y][x]) {\n\t\t\t\t\ttmp[y][x] = d;\n\t\t\t\t\trep(k, 4) {\n\t\t\t\t\t\tif (ran(y + dy[k], x + dx[k])) {\n\t\t\t\t\t\t\tif (y + dy[k] == get<0>(e)&& x + dx[k] == get<1>(e)) {\n\t\t\t\t\t\t\t\tsw = false;\n\t\t\t\t\t\t\t\tcost = d + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tt = make_tuple(y + dy[k], x + dx[k], d + 1);\n\t\t\t\t\t\t\tq.push(t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cost == 0) {\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdist[i][j] = dist[j][i] = cost;\n\t\t\t}\n\t\t\t//cout << \"i=\" << i << \"    j=\" << j << endl;\n\t\t\t//cout << get<0>(s) << \" \" << get<1>(s)<<\"   \";\n\t\t\t//cout << get<0>(e) << \" \" << get<1>(e)<<endl;\n\t\t\trep(i, tmp.size()) {\n\t\t\t\trep(j, tmp[i].size()) {\n\t\t\t\t\t//cout << tmp[i][j] << \"   \";\n\t\t\t\t}\n\t\t\t\t//cout << endl;\n\t\t\t}\n\t\t\t//cout << endl << endl;\n\t\t}\n\t}\n\n\trep(i, dist.size()) {\n\t\trep(j, dist[i].size()) {\n\t\t\t//cout << dist[i][j] << \"   \";\n\t\t}\n\t\t//cout << endl;\n\t}\n\n\tvector<vector<int>> dp( pow(2, dnum),  vector<int>(dnum,INF));\n\trep(i, dnum) {\n\t\tdp[0][i] = dist[dnum][i];\n\t}\n\trep(i, dp.size()) {\n\t\trep(j, dp[i].size()) {\n\t\t\tif (dp[i][j] != INF) {\n\t\t\t\trep(k, dp[i].size()) {\n\t\t\t\t\tif (!(i&(1 << k))) {\n\t\t\t\t\t\tdp[i + (1 << k)][k] = min(dp[i + (1 << k)][k], dp[i][j] + dist[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i, dp.size()) {\n\t\trep(j, dp[i].size()) {\n\t\t\t//cout << dp[i][j] << \"   \";\n\t\t}\n\t\t//cout << endl;\n\t}\n\tcout << *min_element(all(dp.back())) << endl;\n\t\n}\n\nint main(void) {\n\tint h, w;\n\twhile (cin >> w >> h,h) {\n\t\tsolve(w, h);\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n\nint w,h;\nchar s[25][25];\nint dat[25][25];\n\nint gone[25][25];\nint dd[5]={1,0,-1,0,1};\n\ntypedef pair<int,mp> mmp;\n\nint gd(mp a,mp b){\n\tmemst(gone,-1);\n\tqueue<mmp> que;\n\tque.push(mmp(0,a));\n\twhile(!que.empty()){\n\t\tmmp pa = que.front();\n\t\tque.pop();\n\t\tmp p = pa.sec;\n\t\tint c = pa.fir;\n\t\tif(p==b)return c;\n\t\tif(gone[p.fir][p.sec]!=-1)continue;\n\t\tgone[p.fir][p.sec]=c;\n\t\trep(i,4){\n\t\t\tint ty = p.fir + dd[i],\n\t\t\t\ttx = p.sec + dd[i+1];\n\t\t\tif(dat[ty][tx]==-1)continue;\n\t\t\tif(gone[ty][tx]!=-1)continue;\n\t\t\tque.push(mmp(c+1,mp(ty,tx)));\n\t\t}\n\t}\n\treturn -1;\n}\n\nint d[15][15];\n\nint dp[15][1<<12];\n\nint main(void){\n\tfor(;;){\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(h==0)break;\n\t\tmemst(dat,-1);\n\t\trep(y,h)scanf(\"%s\",s[y]);\n\t\tvector<mp> v;\n\t\tmp st;\n\t\treg(y,1,h)reg(x,1,w){\n\t\t\tchar c = s[y-1][x-1];\n\t\t\tif(c=='*')v.push_back(mp(y,x));\n\t\t\tif(c=='o')st = mp(y,x);\n\t\t\tdat[y][x] = (c=='x')?-1:0;\n\t\t}\n\t\tif(v.size()==0){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tbool ok=true;\n\t\tmemst(d,0);\n\t\t\n\t\tpque(mmp) que;\n\t\t\n\t\trep(i,v.size()){\n\t\t\trep(j,i){\n\t\t\t\td[i][j]=d[j][i]=gd(v[i],v[j]);\n\t\t\t\tif(d[i][j]==-1)ok=false;\n\t\t\t}\n\t\t\tint c = gd(st,v[i]);\n\t\t\tif(c==-1)ok=false;\n\t\t\tque.push(mmp(c,mp(i,1<<i)));\n\t\t}\n\t\t\n\t\tif(!ok){\n\t\t\tprintf(\"-1\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tint ls = v.size();\n\t\t\n\t\tmemst(dp,0);\n\t\tfor(;;){\n\t\t\tmmp pa = que.top();\n\t\t\tque.pop();\n\t\t\tint c = pa.fir,\n\t\t\t\tno = pa.sec.fir,\n\t\t\t\tns = pa.sec.sec;\n\t\t\tif(ns==(1<<ls)-1){\n\t\t\t\tprintf(\"%d\\n\",c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(dp[no][ns])continue;\n\t\t\tdp[no][ns]=1;\n\t\t\trep(i,ls){\n\t\t\t\tif(ns&(1<<i))continue;\n\t\t\t\tint ts = ns | (1<<i);\n\t\t\t\tif(dp[i][ts])continue;\n\t\t\t\tque.push(mmp(c+d[no][i],mp(i,ts)));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\nstruct Point {\n\tint x, y;\n\tbool operator==(const Point &p){ return x == p.x && y == p.y; }\n};\ntypedef pair<int, Point> pip;\n\nint dx[] = { 1, -1, 0, 0 };\nint dy[] = { 0, 0, 1, -1 };\n\nvector<string> field;\n\nint bfs(const Point &from, const Point &to){\n\tqueue<pip> q;\n\tq.push(pip(0, from));\n\tfield[from.y][from.x] = ' ';\n\twhile(!q.empty()){\n\t\tpip p = q.front();\n\t\tq.pop();\n\t\tif(p.second == to){\n\t\t\tfor(int i = 0; i < field.size(); ++i){\n\t\t\t\tfor(int j = 0; j < field[i].size(); ++j){\n\t\t\t\t\tif(field[i][j] == ' '){ field[i][j] = '.'; }\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn p.first;\n\t\t}\n\t\tfor(int i = 0; i < 4; ++i){\n\t\t\tPoint next = { p.second.x + dx[i], p.second.y + dy[i] };\n\t\t\tif(field[next.y][next.x] == '.'){\n\t\t\t\tfield[next.y][next.x] = ' ';\n\t\t\t\tq.push(pip(p.first + 1, next));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < field.size(); ++i){\n\t\tfor(int j = 0; j < field[i].size(); ++j){\n\t\t\tif(field[i][j] == ' '){ field[i][j] = '.'; }\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\twhile(true){\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif(w == 0 || h == 0){ break; }\n\t\tPoint robot;\n\t\tvector<Point> targets;\n\t\tfield.clear();\n\t\tfield.push_back(string(w + 2, '*'));\n\t\tfor(int i = 1; i <= h; ++i){\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\tfield.push_back(\"*\" + line + \"*\");\n\t\t\tfor(int j = 1; j <= w; ++j){\n\t\t\t\tif(field[i][j] == 'o'){\n\t\t\t\t\tfield[i][j] = '.';\n\t\t\t\t\trobot.x = j; robot.y = i;\n\t\t\t\t}else if(field[i][j] == '*'){\n\t\t\t\t\tfield[i][j] = '.';\n\t\t\t\t\tPoint p = { j, i };\n\t\t\t\t\ttargets.push_back(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfield.push_back(string(w + 2, '*'));\n\t\tvector<int> roboDist(targets.size());\n\t\tvector< vector<int> > targetsDist(targets.size(), vector<int>(targets.size()));\n\t\tbool invalid = false;\n\t\tfor(int i = 0; i < targets.size(); ++i){\n\t\t\troboDist[i] = bfs(robot, targets[i]);\n\t\t\tif(roboDist[i] < 0){\n\t\t\t\tinvalid = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int j = i + 1; j < targets.size(); ++j){\n\t\t\t\ttargetsDist[i][j] = targetsDist[j][i] = bfs(targets[i], targets[j]);\n\t\t\t}\n\t\t}\n\t\tif(invalid){\n\t\t\tcout << \"-1\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<int> perm(targets.size());\n\t\tfor(int i = 0; i < targets.size(); ++i){ perm[i] = i; }\n\t\tint answer = INT_MAX;\n\t\tdo {\n\t\t\tint sum = roboDist[perm[0]];\n\t\t\tfor(int i = 1; i < targets.size(); ++i){\n\t\t\t\tsum += targetsDist[perm[i - 1]][perm[i]];\n\t\t\t}\n\t\t\tanswer = min(sum, answer);\n\t\t} while(next_permutation(perm.begin(), perm.end()));\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\n# include <cstdlib>\n# include <tuple>\n# include <array>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2147483647;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr double HDINF = 50000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQUE(c)   sort(ALL((c)));(c).erase(unique(ALL((c))),(c).end())\n# define LOWER(s)    transform(ALL((s)),(s).begin(),TL<char>)\n# define UPPER(s)    transform(ALL((s)),(s).begin(),TU<char>)\n# define FOR(i,a,b)  for(LL i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(LL i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nint w, h;\nint sx, sy;\nmap<int, pair<int, int>> dpos;\nstring maze[22];\nint g[11][11];\nLL dp[1 << 11][11];\n\nint d[1001][1001];\nvoid bfs(int py, int px) {\n\tqueue<pair<int, int>> que;\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\td[i][j] = HINF;\n\t\t}\n\t}\n\tque.push(pair<int, int>(px, py));\n\td[py][px] = 0;\n\twhile (que.size()) {\n\t\tpair<int, int> p = que.front();\n\t\tque.pop();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\tif (0 <= nx&&nx < w && 0 <= ny&&ny < h &&maze[ny][nx] != 'x'&&d[ny][nx] == HINF) {\n\t\t\t\tque.push(pair<int, int>(nx, ny));\n\t\t\t\td[ny][nx] = d[p.second][p.first] + 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\n\twhile (cin >> w >> h  &&w&&h) {\n\t\tREP(i, h)cin >> maze[i];\n\t\tint cnt = 0;\n\t\tREP(i, h)REP(j, w) {\n\t\t\tif (maze[i][j] == 'o') {\n\t\t\t\tdpos[cnt] = make_pair(i, j);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tREP(i, h)REP(j, w) {\n\t\t\tif (maze[i][j] == '*') {\n\t\t\t\tdpos[cnt] = make_pair(i, j);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tREP(i, cnt)REP(j, cnt)g[i][j] = HINF;\n\t\tREP(i, cnt) {\n\t\t\tbfs(dpos[i].first, dpos[i].second);\n\t\t\tREP(j, cnt) {\n\t\t\t\tg[i][j] = min(g[i][j], d[dpos[j].first][dpos[j].second]);\n\t\t\t}\n\t\t}\n\t\tREP(i, (1 << 11))REP(j, 11)dp[i][j] = HINF;\n\t\tREP(i, cnt) dp[(1 << cnt) - 1][i] = g[0][i];\n\t\tfor (int S = (1 << cnt) - 2; S >= 0;S--)REP(v, cnt)REP(u, cnt) {\n\t\t\tif (!(S >> u & 1)) {\n\t\t\t\tdp[S][v] = min(dp[S][v], dp[S | 1 << u][u] + g[v][u]);\n\t\t\t}\n\t\t}\n\t\tLL ans = HINF;\n\t\tREP(i, cnt) ans = min(ans, dp[1 << i][i]);\n\t\tcout << (ans == HINF ? -1 : ans) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nchar stage[20][20];\nint cost[1024][10];\nint dis[10][10];\nint w, h;\n\ntypedef std::tuple<int, int, int> T;\nstd::vector<T> pos_to_num;\n\nlong long unsigned PopCount(long long unsigned x) {\n\tx = (x & 0x5555555555555555ULL) + ((x & 0xAAAAAAAAAAAAAAAAULL) >> 1);\n\tx = (x & 0x3333333333333333ULL) + ((x & 0xCCCCCCCCCCCCCCCCULL) >> 2);\n\tx = (x & 0x0F0F0F0F0F0F0F0FULL) + ((x & 0xF0F0F0F0F0F0F0F0ULL) >> 4);\n\n\tx *= 0x0101010101010101ULL;\n\n\treturn x;\n}\n\nvoid dijkstra(int sx, int sy)\n{\n\tint c[20][20] = {0};\n\tint f[20][20] = {0};\n\tint dx[4] = {1, -1, 0, 0};\n\tint dy[4] = {0, 0, 1, -1};\n\n\tfor ( int i = 0; i < 20; ++i ) {\n\t\tfor ( int j = 0; j < 20; ++j ) {\n\t\t\tc[i][j] = 0xfffff;\n\t\t}\n\t}\n\n\tstd::queue<std::tuple<int,int>> q;\n\tq.push(std::make_tuple(sx, sy));\n\tf[sx][sy] = 1;\n\tc[sx][sy] = 0;\n\n\twhile(!q.empty()) {\n\t\tauto a = q.front(); q.pop();\n\t\tint x = std::get<0>(a);\n\t\tint y = std::get<1>(a);\n\t\tfor ( int i = 0; i < 4; ++i ) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif ( nx < 0 || nx >= w ) continue;\n\t\t\tif ( ny < 0 || ny >= h ) continue;\n\t\t\tif ( stage[nx][ny] == 'x' ) continue;\n\t\t\tif ( f[nx][ny] == 1 ) continue;\n\n\t\t\tc[nx][ny] = c[x][y] + 1;\n\t\t\tf[nx][ny] = 1;\n\t\t\tq.push(std::make_tuple(nx, ny));\n\t\t}\n\t}\n\n\tif ( stage[sx][sy] == 'o' ) {\n\t\tfor ( int i = 0; i < pos_to_num.size(); ++i ) {\n\t\t\tcost[0][std::get<2>(pos_to_num[i])] = c[std::get<0>(pos_to_num[i])][std::get<1>(pos_to_num[i])];\n\t\t}\n\t} else if ( stage[sx][sy] == '*' ) {\n\t\tint num;\n\t\tfor ( int i = 0; i < pos_to_num.size(); ++i ) {\n\t\t\tif ( sx == std::get<0>(pos_to_num[i]) && sy == std::get<1>(pos_to_num[i]) ) {\n\t\t\t\tnum = std::get<2>(pos_to_num[i]);\n\t\t\t}\n\t\t}\n\t\tfor ( int i = 0; i < pos_to_num.size(); ++i ) {\n\t\t\tdis[num][std::get<2>(pos_to_num[i])] = c[std::get<0>(pos_to_num[i])][std::get<1>(pos_to_num[i])];\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile ( true ) {\n\t\tfor ( int i = 0; i < 1024; ++i ) {\n\t\t\tfor ( int j = 0; j < 10; ++j ) {\n\t\t\t\tcost[i][j] = 0xfffff;\n\t\t\t}\n\t\t}\n\t\tfor ( int i = 0; i < 10; ++i ) {\n\t\t\tfor ( int j = 0; j < 10; ++j ) {\n\t\t\t\tdis[i][j] = 0xfffff;\n\t\t\t}\n\t\t}\n\n\t\tstd::cin >> w >> h;\n\t\tif ( w == 0 && h == 0 ) return 0;\n \n\t\tint sx, sy;\n\t\tint k = 0;\n\t\tfor ( int i = 0; i < h; ++i ) {\n\t\t\tfor ( int j = 0; j < w; ++j ) {\n\t\t\t\tstd::cin >> stage[j][i];\n\t\t\t\tif ( stage[j][i] == '*' ) {\n\t\t\t\t\tpos_to_num.push_back(T(j, i, k));\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tif ( stage[j][i] == 'o' ) {\n\t\t\t\t\tsx = j; sy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdijkstra(sx, sy);\n\t\tfor ( auto &v: pos_to_num ) {\n\t\t\tdijkstra(std::get<0>(v), std::get<1>(v));\n\t\t}\n\t\tstd::vector<std::tuple<int, int>> table(1<<k);\n\t\tfor ( int i = 0; i < (1<<k); ++i ) {\n\t\t\ttable[i] = std::make_tuple(PopCount(i), i);\n\t\t}\n\t\tstd::sort(table.begin(), table.end());\n\n\t\tfor ( int i = 1; i < (1<<k); ++i ) {\n\t\t\tint q = std::get<1>(table[i]);\n\t\t\tfor ( int j = 0; j < k; ++j ) {\n\t\t\t\tif ( q & (1<<j) ) {\n\t\t\t\t\tfor ( int l = 0; l < k; ++l ) {\n\t\t\t\t\t\tint c = cost[q^(1<<j)][j] + dis[j][l];\n\t\t\t\t\t\tcost[q][l] = (c < cost[q][l]) ? c : cost[q][l];\n\t\t\t\t\t\t//std::cout << \"state:\" << q << \" to:\" << l << \" cost:\" << cost[q][l] << std::endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min = 0xfffff;\n\t\tfor ( int i = 0; i < k; ++i ) {\n\t\t\tif ( min > cost[(1<<k)-1][i] ) min = cost[(1<<k)-1][i];\n\t\t}\n\t\tif ( min == 0xfffff || min == 0 ) {\n\t\t\tstd::cout << -1 << std::endl;\n\t\t} else {\n\t\t\tstd::cout << min << std::endl;\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\n#define int i64\n\nint w,h;\n\nsigned main(){\n\twhile(cin >> w >> h,w || h){\n\t\tvector<vector<int>> fie(h,vector<int>(w,0));\n\t\tvector<P> dust;\n\t\tint sx,sy;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tstring s;\n\t\t\tcin>> s;\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(s[j] == '*'){\n\t\t\t\t\tdust.push_back({i,j});\n\t\t\t\t\tfie[i][j] = dust.size();\n\t\t\t\t}\n\t\t\t\tif(s[j] == 'x'){\n\t\t\t\t\tfie[i][j] = -1;\n\t\t\t\t}\n\t\t\t\tif(s[j] == 'o'){\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusing P2 = pair<int,P>;\n\t\tvector<vector<int>> dist(dust.size(),vector<int>(dust.size() , 1e9));\n\n\t\tint dx[] = {1,-1,0,0};\n\t\tint dy[] = {0,0,1,-1};\n\n\t\tfor(int s = 0;s < dust.size();s++){\n\t\t\tqueue<P2> que;\n\t\t\tque.push({0,dust[s]});\n\t\t\tvector<vector<int>> vis(h,vector<int>(w,0));\n\t\t\tvis[dust[s].first][dust[s].second] = 1;\n\t\t\twhile(!que.empty()){\n\t\t\t\tint d = que.front().first;\n\t\t\t\tP p = que.front().second;\n\t\t\t\tif(fie[p.first][p.second] > 0){\n\t\t\t\t\tdist[s][fie[p.first][p.second] - 1] = d;\n\t\t\t\t}\n\t\t\t\tque.pop();\n\t\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\t\tint nx = p.first + dx[i];\n\t\t\t\t\tint ny = p.second + dy[i];\n\t\t\t\t\tif(0 <= nx && nx < h && 0 <= ny && ny < w && fie[p.first][p.second] != -1 && vis[nx][ny] == 0){\n\t\t\t\t\t\tvis[nx][ny] = 1;\n\t\t\t\t\t\tque.push({d + 1,{nx,ny}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint dp[1 << dust.size()];\n\t\tfill(dp , dp + (1 << dust.size()),1e9);\n\t\t{\n\t\t\tqueue<P2> que;\n\t\t\tque.push({0,{sx,sy}});\n\t\t\tvector<vector<int>> vis(h,vector<int>(w,0));\n\t\t\tvis[sx][sy] = 0;\n\t\t\twhile(!que.empty()){\n\t\t\t\tint d = que.front().first;\n\t\t\t\tP p = que.front().second;\n\t\t\t\tif(fie[p.first][p.second] > 0){\n\t\t\t\t\tdp[(1 << (fie[p.first][p.second] - 1))] = d;\n\t\t\t\t}\n\t\t\t\tque.pop();\n\t\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\t\tint nx = p.first + dx[i];\n\t\t\t\t\tint ny = p.second + dy[i];\n\t\t\t\t\tif(0 <= nx && nx < h && 0 <= ny && ny < w && fie[p.first][p.second] != -1 && vis[nx][ny] == 0){\n\t\t\t\t\t\tvis[nx][ny] = 1;\n\t\t\t\t\t\tque.push({d + 1,{nx,ny}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1;i < (1 << dust.size());i++){\n\t\t\tif(__builtin_popcount(i) == 1) continue;\n\t\t\tfor(int j = 0;j < dust.size();j++){\n\t\t\t\tfor(int k = 0;k < dust.size();k++){\n\t\t\t\t\tif(j == k) continue;\n\t\t\t\t\tif(i & (1 << j) && i & (1 << k)){\n\t\t\t\t\t\t//j <- k\n\t\t\t\t\t\tint s = i & ~(1 << j);\n\t\t\t\t\t\tdp[i] = min(dp[i] , dp[s] + dist[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dp[(1 << dust.size()) - 1] >= 1e9){\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << dp[(1 << dust.size()) - 1] << endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing Graph = vector<vector<int>>;\n\nint TravelingSalesman(const Graph &g) {\n    const int n = g.size(), INF = n * n * n;\n    vector<vector<int>> dp(1 << n, vector<int>(n, INF));\n    dp[1][0] = 0;\n\n    for (int s = 1; s < 1 << n; ++s) {\n        for (int cur = 0; cur < n; ++cur) {\n            if (!(s >> cur & 1) || INF <= dp[s][cur]) continue;\n\n            for (int dst = 0; dst < n; ++dst) {\n                if (dst != cur && !(s >> dst & 1))\n                    dp[s | 1 << dst][dst] = min(dp[s | 1 << dst][dst], dp[s][cur] + g[cur][dst]);\n            }\n        }\n    }\n\n    return *min_element(dp[(1 << n) - 1].begin(), dp[(1 << n) - 1].end());\n}\n\nconst int dr[] = {-1, 0, 1, 0};\nconst int dc[] = {0, -1, 0, 1};\n\nint Distance(const auto &src, const auto &dst, const int h, const int w, const vector<string> &c) {\n    vector<vector<int>> d(h, vector<int>(w, -1));\n    queue<pair<int, int>> que;\n    que.push(src);\n    d[src.first][src.second] = 0;\n\n    while (!que.empty()) {\n        auto cur = que.front(); que.pop();\n\n        for (int dir = 0; dir < 4; ++dir) {\n            pair<int, int> nxt(cur.first + dr[dir], cur.second + dc[dir]);\n            if (nxt.first < 0 || nxt.second < 0 || h <= nxt.first || w <= nxt.second\n                || d[nxt.first][nxt.second] != -1 || c[nxt.first][nxt.second] == 'x')\n                continue;\n            d[nxt.first][nxt.second] = d[cur.first][cur.second] + 1;\n            que.push(nxt);\n        }\n    }\n\n    return d[dst.first][dst.second];\n}\n\npair<bool, Graph> MakeGraph(const int w, const int h, const vector<string> &c) {\n    vector<pair<int, int>> pos(1);\n    for (int i = 0; i < h; ++i)\n        for (int j = 0; j < w; ++j) {\n            if (c[i][j] == 'o') pos[0] = make_pair(i, j);\n            else if (c[i][j] == '*') pos.emplace_back(make_pair(i, j));\n        }\n\n    const int n = pos.size();\n    Graph d(n, vector<int>(n));\n    for (int i = 0; i < n; ++i)\n        for (int j = i + 1; j < n; ++j) {\n            int d_ij = Distance(pos[i], pos[j], h, w, c);\n            if (d_ij == -1) return make_pair(true, d);\n            d[i][j] = d[j][i] = d_ij;\n        }\n\n    return make_pair(false, d);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int w, h;\n\n    while (cin >> w >> h, (w != 0 || h != 0)) {\n        vector<string> c(h);\n        for (auto &x : c) cin >> x;\n\n        auto res = MakeGraph(w, h, c);\n        if (res.first) cout << -1 << '\\n';\n        else cout << TravelingSalesman(res.second) << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint h, w, k[21][21], cnt;\nint cx[11], cy[11], y[11][11], z[11][11], bfs[21][21], a, b, c[10], sum, minx; bool s[21][21];\nchar p;\n\nvoid BFS(int i) {\n\t\n}\n\nint main() {\n\twhile (true) {\n\t\tmemset(z, 0, sizeof(z));\n\t\tcin >> w >> h; cnt = 1; if (!w) { break; }\n\t\tfor (int i = 0; i < 21; i++) { \n\t\t\tfor (int j = 0; j < 21; j++) { \n\t\t\t\tk[i][j] = 1; \n\t\t\t} \n\t\t}\n\t\tcnt = 1;\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tcin >> p;\n\t\t\t\tif (p != 'x') { k[i][j] = 0; }\n\t\t\t\tif (p == '*') { cx[cnt] = j; cy[cnt] = i; cnt++; }\n\t\t\t\tif (p == 'o') { cx[0] = j; cy[0] = i; }\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 10; i++) { c[i] = i; }\n\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\t//bfs.\n\t\t\tqueue<int> Q;\n\t\t\tmemset(bfs, 10, sizeof(bfs));memset(s, false, sizeof(s));\n\t\t\tbfs[cy[i]][cx[i]] = 0;\n\n\t\t\tQ.push(cy[i] * 30 + cx[i]);\n\t\t\ts[cy[i]][cx[i]] = true;\n\t\t\twhile (!Q.empty()) {\n\t\t\t\ta = Q.front() / 30;\n\t\t\t\tb = Q.front() % 30;\n\t\t\t\tif (k[a - 1][b] == 0 && s[a - 1][b] == false) { \n\t\t\t\t\ts[a - 1][b] = true; Q.push((a - 1) * 30 + b); bfs[a - 1][b] = bfs[a][b] + 1;\n\t\t\t\t}\n\t\t\t\tif (k[a + 1][b] == 0 && s[a + 1][b] == false) {\n\t\t\t\t\ts[a + 1][b] = true; Q.push((a + 1) * 30 + b); bfs[a + 1][b] = bfs[a][b] + 1;\n\t\t\t\t}\n\t\t\t\tif (k[a][b - 1] == 0 && s[a][b - 1] == false) {\n\t\t\t\t\ts[a][b - 1] = true; Q.push(a * 30 + b - 1); bfs[a][b - 1] = bfs[a][b] + 1;\n\t\t\t\t}\n\t\t\t\tif (k[a][b + 1] == 0 && s[a][b + 1] == false) {\n\t\t\t\t\ts[a][b + 1] = true; Q.push(a * 30 + b + 1); bfs[a][b + 1] = bfs[a][b] + 1;\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t\t\n\t\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\t\tz[i][j] = bfs[cy[j]][cx[j]];\n\t\t\t}\n\t\t}\n\t\tminx = 114514;\n\t\tdo\n\t\t{\n\t\t\tsum = z[0][c[0] + 1];\n\t\t\tfor (int i = 0; i < cnt - 1; i++) { sum += z[c[i] + 1][c[i + 1] + 1]; }\n\t\t\tminx = min(minx, sum);\n\t\t} while (next_permutation(c, c + cnt - 1));\n\t\tif (minx == 114514) { minx = -1; }\n\t\tcout << minx << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n    if(w==0) return 0;\n    vector<vector<int>> field(h,vector<int>(w));\n    vector<vector<int>> bango(h,vector<int>(w,-1));\n    int sx,sy;\n    vector<pair<int,int>> gomi(10,{-1,-1});\n    int now=0;\n    char c;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> c;\n        if(c=='.'){\n          field[i][j]=0;\n        }else if(c=='x'){\n          field[i][j]=1;\n        }else if(c=='*'){\n          field[i][j]=0;\n          gomi[now]={j,i};\n          bango[i][j]=now;\n          now++;\n        }else{\n          field[i][j]=0;\n          sx=j,sy=i;\n        }\n      }\n    }\n    vector<vector<int>> dist(now,vector<int>(now,1000000));\n    int nx,ny;\n    int vx[4]={0,1,0,-1},vy[4]={1,0,-1,0};\n    queue<pair<int,pair<int,int>>> bfs;\n    pair<int,pair<int,int>> nnow;\n    for(int i=0;i<now;i++){\n      vector<vector<bool>> mita(h,vector<bool>(w,false));\n      bfs.push({0,gomi[i]});\n      mita[gomi[i].second][gomi[i].first]=true;\n      while(!bfs.empty()){\n        nnow=bfs.front();\n        bfs.pop();\n        if(bango[nnow.second.second][nnow.second.first]>=0){\n          dist[i][bango[nnow.second.second][nnow.second.first]]=nnow.first;\n        }\n        for(int i=0;i<4;i++){\n          nx=nnow.second.first+vx[i];\n          ny=nnow.second.second+vy[i];\n          if(0<=nx&&nx<w&&0<=ny&&ny<h){\n            if(!mita[ny][nx]&&field[ny][nx]==0){\n              mita[ny][nx]=true;\n              bfs.push({nnow.first+1,{nx,ny}});\n            }\n          }\n        }\n      }\n    }\n    vector<vector<int>> dp(1<<(now+1),vector<int>(now+1,1000000));\n    vector<vector<bool>> mita(h,vector<bool>(w,false));\n    bfs.push({0,{sx,sy}});\n    mita[sy][sx]=true;\n    while(!bfs.empty()){\n      nnow=bfs.front();\n      bfs.pop();\n      if(bango[nnow.second.second][nnow.second.first]>=0){\n        dp[1<<bango[nnow.second.second][nnow.second.first]][bango[nnow.second.second][nnow.second.first]]=nnow.first;\n      }\n      for(int i=0;i<4;i++){\n        nx=nnow.second.first+vx[i];\n        ny=nnow.second.second+vy[i];\n        if(0<=nx&&nx<w&&0<=ny&&ny<h){\n          if(!mita[ny][nx]&&field[ny][nx]==0){\n            mita[ny][nx]=true;\n            bfs.push({nnow.first+1,{nx,ny}});\n          }\n        }\n      }\n    }\n    int count=0;\n    for(int i=1;i<1<<now;i++){\n      count=0;\n      for(int j=0;j<now;j++) if(i&(1<<j)) count++;\n      if(count>1){\n        for(int j=0;j<now;j++){\n          if(i&(1<<j)){\n            for(int k=0;k<now;k++){\n              if((i-(1<<j))&(1<<k)){\n                dp[i][j]=min(dp[i][j],dp[i-(1<<j)][k]+dist[j][k]);\n              }\n            }\n          }\n        }\n      }\n    }\n    int mi=100000000;\n    for(int i=0;i<now;i++){\n      mi=min(mi,dp[(1<<now)-1][i]);\n    }\n    if(mi>=1000000) cout << -1 << endl;\n    else cout << mi << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<algorithm>\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n\tfor(int w,h;scanf(\"%d%d\",&w,&h),w;){\n\t\tchar tile[20][21];\n\t\tvector<pii> obj(1);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tscanf(\"%s\",tile[i]);\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(tile[i][j]=='o')\tobj[0]=mp(i,j);\n\t\t\t\tif(tile[i][j]=='*')\tobj.pb(mp(i,j));\n\t\t\t}\n\t\t}\n\n\t\tint m=obj.size(),adj[11][11];\n\n\t\tfor(int k=0;k<m;k++){\n\t\t\tint tmp[20][20];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\ttmp[i][j]=1<<25;\n\t\t\ttmp[obj[k].first][obj[k].second]=0;\n\n\t\t\tqueue< pair<int,pii> > qu;\tqu.push(mp(0,obj[k]));\n\t\t\twhile(!qu.empty()){\n\t\t\t\tpair<int,pii> a=qu.front();\tqu.pop();\n\t\t\t\tint d=a.first,x=a.second.second,y=a.second.first;\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\t\t\t\tif(0<=xx && xx<w && 0<=yy && yy<h && tile[yy][xx]!='x'){\n\t\t\t\t\t\tif(d+1<tmp[yy][xx]){\n\t\t\t\t\t\t\tqu.push(mp(d+1,mp(yy,xx)));\n\t\t\t\t\t\t\ttmp[yy][xx]=d+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=0;i<m;i++)\tadj[k][i]=tmp[obj[i].first][obj[i].second];\n\t\t}\n\n\t\tint ans=1<<25;\n\t\tint route[10]={1,2,3,4,5,6,7,8,9,10};\n\t\tdo{\n\t\t\tint dis=adj[0][route[0]];\n\t\t\tfor(int i=0;i<m-2;i++)\tdis+=adj[route[i]][route[i+1]];\n\t\t\tans=min(ans,dis);\n\t\t}while(next_permutation(route,route+m-1));\n\t\tprintf(\"%d\\n\",ans>=(1<<25)?-1:ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint main() {\n  int w, h;\n  while (cin >> w >> h, w) {\n    vector<string> c(h);\n    for (auto &e : c) {\n      cin >> e;\n    }\n    vector<pair<int, int>> p;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (c[i][j] == '*') {\n          p.push_back({i, j});\n        } else if (c[i][j] == 'o') {\n          p.insert(begin(p), {i, j});\n        }\n      }\n    }\n\n    vector<vector<int>> v(p.size(), vector<int>(p.size(), 1e9));\n    for (int i = 0; i < p.size(); i++) {\n      vector<vector<int>> bfs(h, vector<int>(w, 1e9));\n      bfs[p[i].first][p[i].second] = 0;\n      queue<pair<int, int>> q;\n      q.push(p[i]);\n      while (!q.empty()) {\n        auto t = q.front();\n        q.pop();\n        for (int j = 0; j < 4; j++) {\n          int y = t.first + dy[j], x = t.second + dx[j];\n          if (0 <= y && y < h && 0 <= x && x < w && c[y][x] != 'x' && bfs[y][x] == (int)1e9) {\n            bfs[y][x] = bfs[t.first][t.second] + 1;\n            q.push({y, x});\n          }\n        }\n      }\n      for (int j = 0; j < p.size(); j++) {\n        v[i][j] = bfs[p[j].first][p[j].second];\n      }\n    }\n\n    vector<vector<int>> dp(1 << p.size(), vector<int>(p.size(), 1e9));\n    dp[1 << 0][0] = 0;\n    for (int i = 0; i < 1 << p.size(); i++) {\n      for (int j = 0; j < p.size(); j++) {\n        if (!(i & (1 << j))) {\n          for (int k = 0; k < p.size(); k++) {\n            dp[i | (1 << j)][j] = min(dp[i | (1 << j)][j], dp[i][k] + v[k][j]);\n          }\n        }\n      }\n    }\n\n    int m = 1e9;\n    for (int i = 0; i < p.size(); i++) {\n      m = min(m, dp[(1 << p.size()) - 1][i]);\n    }\n    cout << (m == (int)1e9 ? -1 : m) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\nconst int INF = 100000000;\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n\nbool in_range(int a, int b){ return a >= 0 && a < b;}\n\nvoid bfs(map<int,int> &M, vector<int> &G, vector<string> C, int s){\n  int h = C.size(), w = C[0].length();\n  queue< pair<int,int> > que;\n  que.emplace(s,0);\n  while(!que.empty()){\n    int p = que.front().first, d = que.front().second;\n    que.pop();\n    if(M[p])\n      G[M[p]-1] = min(d,G[M[p]-1]);\n    for(int i = 0; i < 4; ++i){\n      int x = p/w + dx[i], y = p%w + dy[i], p_ = x*w + y;\n      if(in_range(x,h) && in_range(y,w) && C[x][y] != 'x'){\n        que.emplace(p_,d+1);\n        C[x][y] = 'x';\n      }\n    }\n  }\n}\n\nvector< vector<int> > make_graph(vector<string> &C, vector<int> &D){\n  int h = C.size(), w = C[0].length(), n = D.size();\n  map<int,int> M;\n  for(int i = 0; i < n; ++i){\n    M[D[i]] = i+1;\n  }\n  vector< vector<int> > G(n, vector<int>(n,INF));\n  for(int i = 0; i < n; ++i){\n    bfs(M,G[i],C,D[i]);\n  }\n  return G;\n}\n\nint main(){\n  int w, h;\n  while(cin >> w >> h, w){\n    vector<string> C(h);\n    vector<int> D;\n    int s;\n    for(int i = 0; i < h; ++i){\n      cin >> C[i];\n      for(int j = 0; j < w; ++j){\n        if(C[i][j] == 'o') s = i*w+j;\n        if(C[i][j] == '*'){\n          D.push_back(i*w+j);\n        }\n      }\n    }\n    D.push_back(s);\n    vector< vector<int> > G = make_graph(C,D);\n    int n = G.size()-1;\n    vector<int> V(n);\n    for(int i = 0; i < n; ++i) V[i] = i;\n    int ans = INF;\n    do{\n      int t = 0, v = n;\n      for(int i = 0; i < n; ++i){\n        t += G[v][V[i]];\n        v = V[i];\n      }\n      ans = min(ans,t);\n    }while(next_permutation(V.begin(),V.end()));\n    if(ans >= INF) ans = -1;\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint INF=1e7;\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\nchar t[20][20];\nint d[20][20][1024];\nint h,w;\n\nvoid change(int a[10],int x){\n  for(int i=0;i<10;i++){\n    a[i]=x%2;\n    x/=2;\n  }\n}\n\nint change(int a[10]){\n  int res=0;\n  for(int i=9;i>=0;i--){\n    res=res*2+a[i];\n  }\n  return res;\n}\n\nvoid init(){\n  for(int i=0;i<20;i++)\n    for(int j=0;j<20;j++)\n      for(int k=0;k<1024;k++)\n        d[i][j][k]=INF;\n}\n\nint solve(int sy,int sx,int cnt){\n  queue<int> qx,qy,qbit;\n  qy.push(sy);\n  qx.push(sx);\n  qbit.push(0);\n  d[sy][sx][0]=0;\n  while(!qy.empty()){\n    int y=qy.front();qy.pop();\n    int x=qx.front();qx.pop();\n    int bit=qbit.front();qbit.pop();\n    \n    if(bit+1 == (1<<cnt)){\n      return d[y][x][bit];\n    }\n    \n    int a[10];\n    for(int i=0;i<4;i++){\n      change(a,bit);\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      if(ny<0||nx<0)continue;\n      if(ny>=h||nx>=w)continue;\n      if(t[ny][nx]=='x')continue;\n      if(t[ny][nx]!='.'){\n        int num=t[ny][nx]-'0';\n        a[num]=1;\n      }\n      int nbit=change(a);\n      int ncost=d[y][x][bit]+1;\n      if(ncost < d[ny][nx][nbit]){\n        d[ny][nx][nbit]=ncost;\n        qy.push(ny);\n        qx.push(nx);\n        qbit.push(nbit);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    init();\n    int cnt=0,si,sj;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin>>t[i][j];\n        if(t[i][j]=='*'){\n          t[i][j]='0'+cnt;\n          cnt++;\n        }\n        if(t[i][j]=='o'){\n          t[i][j]='.';\n          si=i;\n          sj=j;\n        }\n      }\n    }\n    cout<<solve(si,sj,cnt)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<pair<int,int>,int> State;\n\nint w,h;\nconst int INF=1e8;\n\nbool isrange(pair<int,int> x){\n\treturn (0<=x.first && x.first<h && 0<=x.second && x.second<w);\n}\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\n\nint main(){\n\twhile(cin>>w>>h,w){\n\t\tvector<string> c(h);\n\t\tfor(int i=0;i<h;i++) cin>>c[i];\n\t\tvector<pair<int,int>> dust;\n\t\tpair<int,int> robot;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tauto place=make_pair(i,j);\n\t\t\t\tif(c[i][j]=='o'){\n\t\t\t\t\trobot=place;\n\t\t\t\t}\n\t\t\t\tif(c[i][j]=='*'){\n\t\t\t\t\tdust.push_back(place);\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t\tState tate=make_pair(robot,0);\n\t\tpair<State,int> first_state=make_pair(tate,0);\n\t\tint res=INF;\n\t\tmap<State,int> dp;\n\t\tqueue<pair<State,int>> q;\n\t\tq.push(first_state);\n\t\twhile(!q.empty()&& res==INF){\n\t\t\tauto pstate=q.front();\n\t\t\tq.pop();\n\t\t\tState state=pstate.first;\n\t\t\tauto now=state.first;\n\t\t\tfor(int i=0;i<4;i++){\t\t\n\t\t\t\tpair<int,int> to=make_pair(now.first+dx[i],now.second+dy[i]);\n\t\t\t\tif(isrange(to) && c[to.first][to.second]!='x'){\n\t\t\t\t\tint bit=state.second;\n\t\t\t\t\tif(c[to.first][to.second]=='*'){\n\t\t\t\t\t\tfor(int i=0;i<dust.size();i++){\n\t\t\t\t\t\t\tif(dust[i]==to && ((~bit) & (1<<i))){\n\t\t\t\t\t\t\t\tbit+=(1<<i);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tauto tostate=make_pair(to,bit);\n\t\t\t\t\tif(dp.count(tostate)) continue;\n\t\t\t\t\tdp[tostate]=pstate.second+1;\n\t\t\t\t\tif(bit==(1<<dust.size())-1){\n\t\t\t\t\t\tres=pstate.second+1;\n\t\t\t\t\t}\n\t\t\t\t\tq.push(make_pair(tostate,pstate.second+1));\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t}\n\t\tif(res==INF) res=-1;\n\t\tcout<<res<<endl;\n\t}\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cassert>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int MAX = 21;\nconst int TM = 11;\nconst int INF = (1<<25);\n\nchar F[MAX][MAX];\nint T[(1<<TM)][MAX][MAX];\nint w,h,sx,sy;\nvector<P> Trash;\n\n\nstruct State{\n  int x,y,t,come;\n  \n  State(){}\n  State(int x, int y, int t, int c):x(x),y(y),t(t),come(c){}\n  bool operator < (const State& s) const { return t > s.t;}\n\n};\n\nbool isInside(int x, int y){ return 0<=x&&x<w&&0<=y&&y<h;}\n\nvoid init(){\n  \n  fill(T[0][0],T[0][0]+TM*MAX*MAX,INF);\n  Trash.clear();\n\n}\n\nvoid input(){\n  for(int i = 0; i < h; i++)\n    for(int j = 0; j < w; j++){\n      cin >> F[i][j];\n      if(F[i][j] == 'o'){\n\tsx = j;\n\tsy = i;\n      }\n      if(F[i][j] == '*') Trash.push_back(P(j,i));\n\n    }\n}\n\nint getTrashNum(P p){\n  for(int i = 0; i < Trash.size(); i++)\n    if(Trash[i] == p) return i;\n  \n  cerr << \"not found\" << endl;\n  return -1;\n}\nvoid solve(){\n\n  priority_queue<State> Q;\n  Q.push(State(sx,sy,0,0));\n  T[0][sy][sx] = 0;\n\n  int dx[] = {0,0,1,-1};\n  int dy[] = {1,-1,0,0};\n\n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n\n    if(T[now.come][now.y][now.x] < now.t) continue;\n    \n    for(int i = 0; i < 4; i++){\n      State nex = now;\n      nex.x += dx[i];\n      nex.y += dy[i];\n      nex.t++;\n\n      if(!isInside(nex.x,nex.y)) continue;\n      if(F[nex.y][nex.x] == 'x') continue;\n\n\n      if(F[nex.y][nex.x] == '*'){\n\tint Tnum = getTrashNum(P(nex.x, nex.y));\n\tnex.come = (nex.come|(1<<Tnum));\n      }\n\n      \n      if(T[nex.come][nex.y][nex.x] > nex.t){\n\tT[nex.come][nex.y][nex.x] = nex.t;\n\tQ.push(nex);\n      }\n    }\n  }\n\n  int ans = INF;\n\n  // for(int i = 0; i < Trash.size(); i++)\n  // ans = min(ans,T[(1<<Trash.size())-1][Trash[i].second][Trash[i].first]);\n\n  for(int i = 0; i < h; i++)\n    for(int j = 0; j < w; j++) ans = min(ans,T[(1<<Trash.size())-1][i][j]);\n\n  if(ans == INF) cout << \"-1\" << endl;\n  else cout << ans << endl;\n \n}\n  \nint main(){\n\n  while(cin >> w >> h && w+h){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <queue>\n#include <string>\n#include <numeric>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\nint const inf = 1 << 29;\ntypedef int Weight;\nstruct Edge{\n    Edge(int src, int dst, int cost)\n        :src(src), dst(dst), cost(cost){}\n    int src, dst, cost;\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nint W, H;\n\nint dx[] = { 1, 0, -1, 0 };\nint dy[] = { 0, 1, 0, -1 };\n\nconst int MAXN = 12;\nint n;\nint d[MAXN][MAXN];\n\n// テ」ツ?づ」ツつ甘ヲツ慊ャテ」ツ?ョテ」ツδ?」ツつ、テ」ツつッテ」ツつケテ」ツδ暗」ツδゥテヲツウツ陛」ツつ担pagetti Sourceテ」ツ?ョAPIテ」ツ?ォテ・ツ青暗」ツつ湘」ツ?崚」ツ?淌」ツつづ」ツ?ョ\nstruct State {\n    int v, d;\n    State(int v, int d) : v(v), d(d){}\n    bool operator<(const State& s)const{\n        return d>s.d;\n    }\n};\n\nvoid dijkstra(Graph const &g, int s, vector<Weight> &dist) {\n    priority_queue<State> q;\n    dist.assign(g.size(), inf); dist[s] = 0;\n    q.push(State(s, 0));\n    while (q.size()) {\n        State s = q.top(); q.pop();\n        int v = s.v;\n        if (dist[v] < s.d) continue;\n        rep(i, g[v].size()){\n            const Edge &e = g[v][i];\n            if (dist[e.dst] > dist[v] + e.cost) {\n                dist[e.dst] = dist[v] + e.cost;\n                q.push(State(e.dst, dist[e.dst]));\n            }\n        }\n    }\n}\n\n\ninline bool valid(int x, int y){\n    return 0 <= x && x < W && 0 <= y && y < H;\n}\n\nint solve(vector<string> grid){\n    Graph g(W*H);\n    vector<int> dust;\n    int s;\n    rep(y, H)rep(x, W){\n        rep(i, 4){\n            int tx = x + dx[i];\n            int ty = y + dy[i];\n            if (!valid(tx, ty)) continue;\n            if (grid[ty][tx] == 'x') continue;\n            int src = y*H + x;\n            int dst = ty*H + tx;\n            g[src].push_back(Edge(src, dst, 1));\n        }\n    }\n\n    rep(i, H)rep(j, W){\n        if (grid[i][j] == '*'){\n            dust.push_back(i*H + j);\n        }\n        if (grid[i][j] == 'o'){\n            s = i*H + j;\n        }\n    }\n    dust.push_back(s);\n    int V = dust.size();\n    rep(i, V)rep(j, V){\n        d[i][j] = inf;\n    }\n\n    rep(i, V){\n        vector<int> dist;\n        dijkstra(g, dust[i], dist);\n        rep(j, V){\n            d[i][j] = dist[dust[j]];\n        }\n    }\n    \n    int idx[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 };\n    int ans = inf;\n    do{\n        long long res = 0;\n        rep(i, V){\n            res += d[idx[i]][idx[i + 1]];\n        }\n        if (res >= inf) continue;\n        ans = min<long long>(ans, res);\n    } while (next_permutation(idx, idx + V - 1));\n    if (ans == inf)ans = -1;\n    return ans;\n}\n\nint main(){\n    while (cin >> W >> H && W | H){\n        vector<string> grid(H);\n        rep(i, H){\n            cin >> grid[i];\n        }\n        cout << solve(grid) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint INF = INT_MAX / 4;\n\nint calculateDist(vector<string>& tile, int y1, int x1, int y2, int x2)\n{\n    int h = tile.size();\n    int w = tile[0].size();\n    vector<vector<int> > minDist(h, vector<int>(w, INF));\n\n    int dy[] = {0, 0, 1, -1};\n    int dx[] = {1, -1, 0, 0};\n\n    queue<pair<int, int> > q;\n    q.push(make_pair(y1, x1));\n    minDist[y1][x1] = 0;\n    while(!q.empty()){\n        int y0 = q.front().first;\n        int x0 = q.front().second;\n        q.pop();\n        for(int i=0; i<4; ++i){\n            int y = y0 + dy[i];\n            int x = x0 + dx[i];\n            if(tile[y][x] != 'x' && minDist[y][x] == INF){\n                minDist[y][x] = minDist[y0][x0] + 1;\n                if(y == y2 && x == x2)\n                    return minDist[y][x];\n                q.push(make_pair(y, x));\n            }\n        }\n    }\n    return INF;\n}\n\nint solve(vector<string>& tile)\n{\n    int h = tile.size();\n    int w = tile[0].size();\n\n    int sy, sx;\n    vector<int> y, x;\n    for(int i=0; i<h; ++i){\n        for(int j=0; j<w; ++j){\n            if(tile[i][j] == 'o'){\n                sy = i;\n                sx = j;\n            }\n            if(tile[i][j] == '*'){\n                y.push_back(i);\n                x.push_back(j);\n            }\n        }\n    }\n\n    int n = y.size();\n    vector<vector<int> > dist(n, vector<int>(n, 0));\n    for(int i=0; i<n; ++i){\n        for(int j=i+1; j<n; ++j){\n            dist[i][j] = dist[j][i] = calculateDist(tile, y[i], x[i], y[j], x[j]);\n        }\n    }\n\n    vector<vector<int> > minDist(n, vector<int>(1<<n, INF));\n    for(int i=0; i<n; ++i){\n        minDist[i][1<<i] = calculateDist(tile, sy, sx, y[i], x[i]);\n    }\n    for(int i=0; i<(1<<n); ++i){\n        bitset<10> bs(i);\n        for(int j=0; j<n; ++j){\n            for(int k=0; k<n; ++k){\n                if(bs[k])\n                    continue;\n                bs[k] = true;\n                minDist[k][bs.to_ulong()] = min(minDist[k][bs.to_ulong()], minDist[j][i] + dist[j][k]);\n                bs[k] = false;\n            }\n        }\n    }\n\n    int ret = INF;\n    for(int i=0; i<n; ++i){\n        ret = min(ret, minDist[i][(1<<n)-1]);\n    }\n    if(ret == INF)\n        return -1;\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int w, h;\n        cin >> w >> h;\n        if(w == 0)\n            break;\n\n        vector<string> tile(h+2);\n        tile[0] = tile[h+1] = string(w+2, 'x');\n        for(int i=1; i<=h; ++i){\n            cin >> tile[i];\n            tile[i] = 'x' + tile[i] + 'x';\n        }\n        cout << solve(tile) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1000000000;\n\nint w, h;\nchar c[20][25];\n\nint x[11], y[11];\nint dCounter;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint minlength[20][20];\nbool used[20][20];\n\nvoid bfs(P s) {\n  for (int i = 0; i < h; i++)\n    for (int j = 0; j < w; j++) minlength[i][j] = INF, used[i][j] = false;\n  minlength[s.second][s.first] = 0;\n  queue<P> que;\n  que.push(s);\n  while (!que.empty()) {\n    P p = que.front(); que.pop();\n    int px = p.first, py = p.second;\n    if (used[py][px]) continue;\n    used[py][px] = true;\n    for (int i = 0; i < 4; i++) {\n      int newy = py + dy[i], newx = px + dx[i];\n      if (newy < 0 || newy >= h || newx < 0 || newx >= w) continue;\n      if (c[py + dy[i]][px + dx[i]] != 'x' && !used[newy][newx]) {\n        minlength[py + dy[i]][px + dx[i]] = minlength[py][px] + 1;\n        que.push(P(px + dx[i], py + dy[i]));\n      }\n    }\n  }\n}\n\nint cost[11][11];\nint bitdp[1<<12][11];\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &w, &h);\n    if (w == 0) break;\n    for (int i = 0; i < h; i++) scanf(\"%s\", c[i]);\n    dCounter = 1;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (c[i][j] == '*') x[dCounter] = j, y[dCounter++] = i;\n        if (c[i][j] == 'o') x[0] = j, y[0] = i;\n      }\n    }\n    bool flag = false;\n    for (int i = 0; i < dCounter; i++) {\n      bfs(P(x[i], y[i]));\n      for (int j = 0; j < dCounter; j++) {\n        cost[i][j] = minlength[y[j]][x[j]];\n        if (cost[i][j] == INF) i = j = dCounter, flag = true;\n      }\n    }\n    if (flag) {\n      printf(\"-1\\n\");\n      continue;\n    }\n    int maxbit = (1 << dCounter) - 1;\n    for (int i = 0; i < maxbit - 1; i++)\n      for (int j = 0; j < dCounter; j++) bitdp[i][j] = INF;\n    bitdp[maxbit][0] = 0;\n    for (int s = maxbit - (1 << 0); s >= 0; s--) {\n      for (int from = 0; from < dCounter; from++) {\n        if ((s >> from) & 1) continue;\n        for (int to = 0; to < dCounter; to++) {\n          if (((s >> to) & 1) == 0) continue;\n          if (bitdp[s][from] == INF) continue;\n          //if (to == from) continue;\n          bitdp[s & ~(1 << to)][to] = min(bitdp[s & ~(1 << to)][to], bitdp[s][from] + cost[from][to]);\n        }\n      }\n    }\n    int ans = INF;\n    for (int i = 0; i < dCounter; i++) ans = min(ans, bitdp[0][i]);\n    if (ans == INF) ans = 0;\n    printf(\"%d\\n\", ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <queue>\n#include <string>\n#include <numeric>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\nint const inf = 1 << 29;\ntypedef int Weight;\nstruct Edge{\n    Edge(int src, int dst, int cost)\n        :src(src), dst(dst), cost(cost){}\n    int src, dst, cost;\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nint W, H;\n\nint dx[] = { 1, 0, -1, 0 };\nint dy[] = { 0, 1, 0, -1 };\n\nconst int MAXN = 12;\nint n;\nint d[MAXN][MAXN];\nint dp[1 << MAXN][MAXN];\n\nint rec(int S, int v) {\n    if (dp[S][v] >= 0) return dp[S][v];\n    if (S == (1 << n) - 1 && v == 0) return dp[S][v] = 0;\n    int tmp = inf;\n    rep(u, n) if (!(S >> u & 1)) tmp = min(tmp, rec(S | 1 << u, u) + d[v][u]);\n    return dp[S][v] = tmp;\n}\n\n// テ」ツ?づ」ツつ甘ヲツ慊ャテ」ツ?ョテ」ツδ?」ツつ、テ」ツつッテ」ツつケテ」ツδ暗」ツδゥテヲツウツ陛」ツつ担pagetti Sourceテ」ツ?ョAPIテ」ツ?ォテ・ツ青暗」ツつ湘」ツ?崚」ツ?淌」ツつづ」ツ?ョ\nstruct State {\n    int v, d;\n    State(int v, int d) : v(v), d(d){}\n    bool operator<(const State& s)const{\n        return d>s.d;\n    }\n};\n\nvoid dijkstra(Graph const &g, int s, vector<Weight> &dist) {\n    priority_queue<State> q;\n    dist.assign(g.size(), inf); dist[s] = 0;\n    q.push(State(s, 0));\n    while (q.size()) {\n        State s = q.top(); q.pop();\n        int v = s.v;\n        if (dist[v] < s.d) continue;\n        rep(i, g[v].size()){\n            const Edge &e = g[v][i];\n            if (dist[e.dst] > dist[v] + e.cost) {\n                dist[e.dst] = dist[v] + e.cost;\n                q.push(State(e.dst, dist[e.dst]));\n            }\n        }\n    }\n}\n\n\ninline bool valid(int x, int y){\n    return 0 <= x && x < W && 0 <= y && y < H;\n}\n\nint solve(vector<string> grid){\n    Graph g(W*H);\n    vector<int> dust;\n    int s;\n    rep(y, H)rep(x, W){\n        rep(i, 4){\n            int tx = x + dx[i];\n            int ty = y + dy[i];\n            if (!valid(tx, ty)) continue;\n            if (grid[ty][tx] == 'x') continue;\n            int src = y*H + x;\n            int dst = ty*H + ty;\n            g[src].push_back(Edge(src, dst, 1));\n        }\n    }\n\n    rep(i, H)rep(j, W){\n        if (grid[i][j] == '*'){\n            dust.push_back(i*H + j);\n        }\n        if (grid[i][j] == 'o'){\n            s = i*H + j;\n        }\n    }\n    dust.push_back(s);\n    int V = dust.size();\n    rep(i, V)rep(j, V){\n        d[i][j] = inf;\n    }\n    rep(i, 1 << MAXN)rep(j, MAXN){\n        dp[i][j] = inf;\n    }\n\n    rep(i, V){\n        vector<int> dist;\n        dijkstra(g, dust[i], dist);\n        rep(j, V){\n            d[i][j] = dist[dust[j]];\n        }\n    }\n\n    int res = rec(0, V - 1);\n    if (res == inf) res = -1;\n    return res;\n}\n\nint main(){\n    while (cin >> W >> H && W | H){\n        vector<string> grid(H);\n        rep(i, H){\n            cin >> grid[i];\n        }\n        cout << solve(grid) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nclass P{\npublic:\n\tint x,y,cost;\n\tP(int _x,int _y,int _cost){\n\t\tx = _x;\n\t\ty = _y;\n\t\tcost = _cost;\n\t}\n};\n\nint w,h,cnt;\nint t[22][22]; //-1 : ó«, -2 : Ç, 0 : {bg, 1Èã : ê\nint g[12][12];\nbool closed[22][22];\nint dx[] = {-1,1,0,0};\nint dy[] = {0,0,-1,1};\n\nvoid minDist(int sx,int sy){\n\tqueue<P> q;\n\tq.push(P(sx,sy,0));\n\tmemset(closed,0,sizeof(closed));\n\tclosed[sy][sx] = true;\n\n\twhile(!q.empty()){\n\t\tP p = q.front(); q.pop();\n\n\t\tif(t[p.y][p.x] >= 0){\n\t\t\tg[t[sy][sx]][t[p.y][p.x]] = p.cost;\n\t\t}\n\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx = p.x + dx[i];\n\t\t\tint ny = p.y + dy[i];\n\t\t\tif(nx>=0 && w>nx && ny>=0 && h>ny && t[ny][nx]>=-1 && !closed[ny][nx]){\n\t\t\t\tclosed[ny][nx] = true;\n\t\t\t\tq.push(P(nx,ny,p.cost+1));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tchar buff[22];\n\n\twhile(scanf(\"%d%d\",&w,&h),w||h){\n\t\tcnt = 0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tscanf(\"%s\",buff);\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(buff[j] == '.') t[i][j] = -1;\n\t\t\t\telse if(buff[j] == 'x') t[i][j] = -2;\n\t\t\t\telse if(buff[j] == 'o') t[i][j] = 0;\n\t\t\t\telse t[i][j] = ++cnt;\n\t\t\t}\n\t\t}\n\n\t\tmemset(g,-1,sizeof(g));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(t[i][j] >= 0){\n\t\t\t\t\tminDist(j,i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 999999999;\n\t\tint pass[cnt+1];\n\t\tfor(int i=0;i<=cnt;i++) pass[i] = i;\n\t\tdo{\n\t\t\tint sum = 0;\n\t\t\tint i;\n\t\t\tfor(i=0;i<cnt;i++){\n\t\t\t\tif(g[pass[i]][pass[i+1]] == -1) break;\n\t\t\t\tsum += g[pass[i]][pass[i+1]];\n\t\t\t}\n\t\t\tif(i == cnt && sum < ans) ans = sum;\n\t\t}while(next_permutation(pass+1,pass+1+cnt));\n\n\t\tprintf(\"%d\\n\",ans==999999999 ? -1 : ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint w, h;\nvector<string> tile(20);\nint dist[11][11];\nbool visited[20][20];\nint dd[] = {1, 0, -1, 0, 1};\n\nbool range(int x, int y) {\n  return 0 <= x && x < w && 0 <= y && y < h;\n}\n\nvoid wfs(PIP s, vector<PIP> &v) {\n  rep(i, h)rep(j, w) visited[i][j] = false;\n  visited[s.se.fi][s.se.se] = true;\n\n  priority_queue<PIP, vector<PIP>, greater<PIP>> q;\n  q.push(PIP(0, s.se));\n\n  while(!q.empty()) {\n    PIP p = q.top(); q.pop();\n\n    repl(i, 1, v.size()) {\n      if (p.fi > 0 && p.se == v[i].se) dist[s.fi][i] = p.fi;\n    }\n\n    rep(i, 4) {\n      int y = p.se.fi + dd[i], x = p.se.se + dd[i + 1];\n      if (range(x, y) && !visited[y][x] && tile[y][x] != 'x') {\n        q.push(PIP(p.fi + 1, P(y, x)));\n        visited[y][x] = true;\n      }\n    }\n  }\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  while(cin >> w >> h, w | h) {\n    vector<PIP> v;\n    int num = 1;\n    rep(i, h) {\n      cin >> tile[i];\n      rep(j, w) {\n        if (tile[i][j] == '*') v.pb(PIP(num++, P(i, j)));\n        else if (tile[i][j] == 'o') v.pb(PIP(0, P(i, j)));\n      }\n    }\n    sort(all(v));\n\n    rep(i, num)rep(j, num) dist[i][j] = INF;\n\n    bool ok = true;\n    rep(i, num) {\n      wfs(v[i], v);\n      if (i == 0) {\n        repl(j, 1, num) if (dist[0][j] == INF) ok = false;\n        if (!ok) break;\n      }\n    }\n\n    if (ok) {\n      vector<vector<int>> dp(1 << (num - 1), vector<int>(num - 1, INF));\n      repl(i, 1, num) dp[(1 << (i - 1))][i - 1] = dist[0][i];\n\n      rep(i, dp.size()) {\n        repl(j, 1, num) {\n          if (i & (1 << (j - 1))) {\n            repl(k, 1, num) {\n              if (!(i & (1 << (k - 1)))) minch(dp[i + (1 << (k - 1))][k - 1], dp[i][j - 1] + dist[j][k]);\n            }\n          }\n        }\n      }\n\n      int ans = INF;\n      rep(i, num - 1) minch(ans, dp[dp.size() - 1][i]);\n      cout << ans << endl;\n    } else {\n      cout << -1 << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nmap<P,int> ids;\ntemplate<class T>\nbool chmin(T &a,const T& b) {\n    if(a>b) {\n        a=b;\n        return true;\n    }\n    return false;\n}\n\nint w,h;\nstring room[21];\nint dist[12][12];\nint to_id(P p) {\n    if(!ids.count(p)) ids[p]=ids.size();\n\n    return ids[p];\n}\n\nvoid bfs(P p) {\n    int d[21][21];\n    rep(i,21) rep(j,21) d[i][j]=INF;\n    int s=to_id(p);\n    queue<P> que;\n    que.push(p);\n    d[p.fr][p.sc]=0;\n\n    while(que.size()) {\n        int y=que.front().fr;\n        int x=que.front().sc;\n        que.pop();\n        rep(i,4) {\n            int ny=y+dy[i];\n            int nx=x+dx[i];\n            if(ny<0||nx<0) continue;\n            if(h<=ny||w<=nx) continue;\n            if(d[ny][nx]!=INF) continue;\n            if(room[ny][nx]=='x') continue;\n\n            if(chmin(d[ny][nx],d[y][x]+1)) {\n                if(room[ny][nx]=='*') {\n                    //printf(\"%d,%d -> %d,%d : %d\\n\",p.fr,p.sc,ny,nx,d[ny][nx]);\n                    dist[s][to_id(P(ny,nx))]=d[ny][nx];\n                    dist[to_id(P(ny,nx))][s]=d[ny][nx];\n                }\n                que.push(P(ny,nx));\n            }\n        }\n    }\n}\n\nvoid solve() {\n    ids.clear();\n    P s;\n    vector<P> vec;\n    rep(i,12) rep(j,12) dist[i][j]=INF;\n    rep(y,h) cin>>room[y];\n    rep(y,h) rep(x,w) {\n        if(room[y][x]=='*') {\n            vec.pb(P(y,x));\n            bfs(P(y,x));\n        }\n        if(room[y][x]=='o') {\n            s=P(y,x);\n            bfs(s);\n        }\n    }\n    sort(all(vec));\n\n    int ans=INF;\n    do {\n        int t=dist[to_id(s)][to_id(vec[0])];\n        rep(i,vec.size()) if(i) t+=dist[to_id(vec[i-1])][to_id(vec[i])];\n        chmin(ans,t);\n    }while(next_permutation(all(vec)));\n\n    if(ans==INF) ans=-1;\n\n    cout<<ans<<endl;\n}\nint main() {\n    while(cin>>w>>h) {\n        if(!w) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 123456789;\n\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\nint W, H;\nint tab[30][30];\nint bfs(PII a, PII b){\n  VVI visited(30, VI(30, -1));\n  visited[a.second][a.first] = 0;\n  queue<PII> q;\n  q.push(a);\n\n  while(!q.empty()){\n\tPII p = q.front(); q.pop();\n\tif(p == b) return visited[b.second][b.first];\n\tREP(i,4){\n\t  PII t = p;\n\t  t.first += dx[i];\n\t  t.second += dy[i];\n\t  if(tab[t.second][t.first]!=0 && visited[t.second][t.first]==-1){\n\t\tvisited[t.second][t.first] = visited[p.second][p.first]+1;\n\t\tq.push(t);\n\t  }\n\t}\n  }\n  return INF;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(true){\n\tcin >> W >> H;\n\tif(W == 0) break;\n\tfill((int*)tab, (int*)tab+30*30, 0);\n\n\tvector<PII> node;\n\tint px, py;\n\tfor(int y=1;y<=H;++y) for(int x=1;x<=W;++x){\n\t  char c; cin >> c;\n\t  if(c == 'o'){\n\t\tpx = x, py = y, tab[y][x] = 1;\n\t  }\n\t  else if(c == '*'){\n\t\ttab[y][x] = 1;\n\t\tnode.PB(MP(x,y));\n\t  }\n\t  else if(c == '.')\n\t\ttab[y][x] = 1;\n\t}\n\n\tint sz = SZ(node);\n\tVI path(sz, 0), dist(30*30+1, 0);\n\tfor(int i=0;i<sz;++i)\n\t  path[i] = bfs(MP(px,py), node[i]);\n\n\tVVI G(sz, VI(sz, INF));\n\tfor(int i=0;i<sz;++i){\n\t  G[i][i] = 0;\n\t  for(int j=i+1;j<sz;++j){\n\t\tG[i][j] = G[j][i] = bfs(node[i], node[j]);\n\t  }\n\t}\n\n\tint ans = INF;\n\tint dp[1<<10][10];\n\tREP(i,1<<10) REP(j, 10) dp[i][j] = INF;\n\tREP(i,sz) dp[1<<i][i] = path[i];\n\t\n\tREP(i,1<<sz) REP(j,sz) REP(k,sz)\n\t  dp[i | (1 << k)][k] = min(dp[i | (1 << k)][k], dp[i][j] + G[j][k]);\n\tREP(i,sz) ans = min(ans, dp[(1<<sz)-1][i]);\n\tcout << (ans == INF? -1: ans) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nconst int dy[] = {-1, 0, 0, 1};\nconst int dx[] = {0, -1, 1, 0};\nconst int INF = 1 << 30;\nusing P = pair<int, int>;\nint w, h;\nstring c[20];\nint dis[20][20], d[11][11];\nvector<P> ps;\nint dp[1 << 11][11];\n\nint dfs(int S, int v) {\n    if (dp[S][v] != INF) return dp[S][v];\n    if (S == (1LL << ps.size()) - 1) return dp[S][v] = 0;\n    int res = INF;\n    REP (i, ps.size()) if (!(S >> i & 1)) {\n        res = min(res, dfs(S | (1LL << i), i) + d[v][i]);\n    }\n    return dp[S][v] = res;\n}\n\nvoid bfs(int idx) {\n    REP (i, h) REP (j, w) dis[i][j] = INF;\n    dis[ps[idx].first][ps[idx].second] = 0;\n    queue<P> que;\n    que.emplace(ps[idx]);\n    while (!que.empty()) {\n        int y, x;\n        tie(y, x) = que.front(); que.pop();\n        REP (i, 4) {\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if (ny >= 0 && ny < h && nx >= 0 && nx < w && c[ny][nx] != 'x' && dis[ny][nx] == INF) {\n                dis[ny][nx] = dis[y][x] + 1;\n                que.emplace(ny, nx);\n            }\n        }\n    }\n    REP (i, ps.size()) d[idx][i] = dis[ps[i].first][ps[i].second];\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (cin >> w >> h, w) {\n        P s;\n        ps.clear();\n        REP (i, h) {\n            cin >> c[i];\n            REP (j, w) {\n                if (c[i][j] == 'o') {\n                    s = P(i, j);\n                } else if (c[i][j] == '*') {\n                    ps.emplace_back(i, j);\n                }\n            }\n        }\n        ps.insert(ps.begin(), s);\n        REP (i, ps.size()) bfs(i);\n        REP (i, 1 << 11) REP (j, 11) dp[i][j] = INF;\n        int ans = dfs(1, 0);\n        cout << (ans == INF ? -1 : ans) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n\n\nusing namespace std;\n\n\n// ツ各ツ可伉づェツタツイツδ仰＋ツスツタツーツトツ地ツ点ツづ個つサツづェツつシツづェツづ個甘板づ個仰猟猟」\nint d[21][21][21][21];\nvector<string> field;\npair<int,int> sp;\nvector<pair<int,int> > dartys;\nint w,h;\n\nbool bfs(int sy,int sx){\n\tqueue<pair<int,int> > *prv = new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *nxt = new queue<pair<int,int> >();\n\n\tbool passed[21][21];\n\tfor(int i = 0; i < 21; i++)\n\t\tfill(passed[i],passed[i]+21,false);\n\n\tprv->push(make_pair(sy,sx));\n\n\tint dy[] = {-1,0,0,1};\n\tint dx[] = {0,-1,1,0};\n\n\tbool no = true;\n\tbool fir = false;\n\tint dist = 0;\n\twhile(prv->size()){\n\t\twhile(prv->size()){\n\t\t\tpair<int,int> cp = prv->front();prv->pop();\n\t\t\tif(passed[cp.first][cp.second])\n\t\t\t\tcontinue;\n\t\t\tpassed[cp.first][cp.second]=true;\n\t\t\td[sy][sx][cp.first][cp.second] = dist;\n\n\n\t\t\tif(fir && field[cp.first][cp.second] == '*'){\n\t\t\t\tno = false;\n\t\t\t}\n\t\t\tfir = true;\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tpair<int,int> np = cp;\n\t\t\t\tnp.first += dy[i];\n\t\t\t\tnp.second += dx[i];\n\t\t\t\tif(np.first >= 0 && np.second >= 0 && np.first < h && np.second < w){\n\t\t\t\t\tif(!passed[np.first][np.second] && field[np.first][np.second] != 'x'){\n\t\t\t\t\t\tnxt->push(np);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdist++;\n\t\tswap(prv,nxt);\n\t}\n\tdelete prv,nxt;\n\tif(no){\n\t\treturn false;\n\t}\n\telse\n\t\treturn true;\n}\n\nint dfs(int s,pair<int,int> prv){\n\tif(s == (1 << (int)(dartys.size()))-1){\n\t\treturn 0;\n\t}\n\n\tint minCost = 10000000;\n\tfor(int i = 0; i < dartys.size(); i++){\n\t\tif(!((1 & (s >> i)) == 1)){\n\t\t\tminCost = min(minCost,dfs(s | (1 << i),make_pair(dartys[i].first,dartys[i].second))\n\t\t\t\t+ d[prv.first][prv.second][dartys[i].first][dartys[i].second]);\n\t\t}\n\t}\n\treturn minCost;\n}\n\nint main(){\n\n\twhile(cin >> w >> h && !(w == 0 && h == 0)){\n\t\tfield.clear();\n\t\tdartys.clear();\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfield.push_back(str);\n\t\t\tfor(int j = 0; j < str.size(); j++){\n\t\t\t\tif(str[j] == 'o'){\n\t\t\t\t\tsp.first = i;\n\t\t\t\t\tsp.second = j;\n\t\t\t\t}\n\t\t\t\telse if(str[j] == '*'){\n\t\t\t\t\tdartys.push_back(make_pair(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ツ各ツ湘ェツ渉環つゥツづァツ深ツつウツ優ツ静ヲツ探ツ催オツづ、ツつサツづェツつシツづェツづ個湘ェツ渉環づ鳴づ個仰猟猟」ツづーツ仰づ淞づつィツつュ\n\t\tif(!bfs(sp.first,sp.second)){\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tbool fff = false;\n\t\tfor(int i = 0; i < dartys.size(); i++){\n\t\t\tif(!bfs(dartys[i].first,dartys[i].second)){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\tfff = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(fff){\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t// ツ渉嘉アツセツーツδ仰スツマツδ督姪「ツ妥ィツづーツ嘉ーツつュ\n\t\tcout << dfs(0,make_pair(sp.first,sp.second)) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1000000000;\n\nint w, h;\nchar c[20][25];\n\nint x[11], y[11];\nint dCounter;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint minlength[20][20];\nbool used[20][20];\n\nvoid bfs(P s) {\n  for (int i = 0; i < h; i++)\n    for (int j = 0; j < w; j++) minlength[i][j] = INF, used[i][j] = false;\n  minlength[s.second][s.first] = 0;\n  queue<P> que;\n  que.push(s);\n  while (!que.empty()) {\n    P p = que.front(); que.pop();\n    int px = p.first, py = p.second;\n    if (used[py][px]) continue;\n    used[py][px] = true;\n    for (int i = 0; i < 4; i++) {\n      int newy = py + dy[i], newx = px + dx[i];\n      if (newy < 0 || newy >= h || newx < 0 || newx >= w) continue;\n      if (c[py + dy[i]][px + dx[i]] != 'x' && !used[newy][newx]) {\n        minlength[py + dy[i]][px + dx[i]] = minlength[py][px] + 1;\n        que.push(P(px + dx[i], py + dy[i]));\n      }\n    }\n  }\n}\n\nint cost[11][11];\nint bitdp[1<<12][11];\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &w, &h);\n    if (w == 0) break;\n    for (int i = 0; i < h; i++) scanf(\"%s\", c[i]);\n    dCounter = 1;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (c[i][j] == '*') x[dCounter] = j, y[dCounter++] = i;\n        if (c[i][j] == 'o') x[0] = j, y[0] = i;\n      }\n    }\n    bool flag = false;\n    for (int i = 0; i < dCounter; i++) {\n      bfs(P(x[i], y[i]));\n      for (int j = 0; j < dCounter; j++) {\n        cost[i][j] = minlength[y[j]][x[j]];\n        if (cost[i][j] == INF) i = j = dCounter, flag = true;\n      }\n    }\n    if (flag) {\n      printf(\"-1\\n\");\n      continue;\n    }\n    int maxbit = (1 << dCounter) - 1;\n    for (int i = 0; i < maxbit - 1; i++)\n      for (int j = 0; j < dCounter; j++) bitdp[i][j] = INF;\n    bitdp[maxbit][0] = 0;\n    for (int s = maxbit - (1 << 0); s >= 0; s--) {\n      for (int from = 0; from < dCounter; from++) {\n        if ((s >> from) & 1) continue;\n        for (int to = 0; to < dCounter; to++) {\n          if (((s >> to) & 1) == 0) continue;\n          if (bitdp[s][from] == INF) continue;\n          //if (to == from) continue;\n          bitdp[s & ~(1 << to)][to] = min(bitdp[s & ~(1 << to)][to], bitdp[s][from] + cost[from][to]);\n        }\n      }\n    }\n    int ans = INF;\n    for (int i = 0; i < dCounter; i++) ans = min(ans, bitdp[0][i]);\n    if (ans == INF) ans = 0;\n    printf(\"%d\\n\", ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#define MAX_H 20\n#define MAX_W 20\n#define MAX_G 10\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\n\nstruct S {\n    int y, x, t;\n    S(int y, int x, int t) : y(y), x(x), t(t) {}\n};\n\n#define INF (1<<28)\n\nstring field[MAX_H];\nint number[MAX_H][MAX_W];\nint graph[MAX_G][MAX_G];\nint dp[MAX_G][1<<MAX_G]; \nint h, w;\nint garbage_count;\n\nint solve(int v, int s) {\n    if (dp[v][s] != INF) return dp[v][s];\n    if (s == ((1<<garbage_count)-1)) return 0;\n    int min_cost = INF;\n    for (int i = 0; i < garbage_count; i++) {\n        if (s & (1<<i)) continue;\n        min_cost = min(min_cost, solve(i, (s + (1<<i))) + graph[v][i]);\n    }\n    return dp[v][s] = min_cost;\n}\n\nint main() {\n    while (cin >> w >> h) {\n        if (w == 0 && h == 0) break;\n        memset(graph, -1, sizeof(graph));\n        memset(number, -1, sizeof(number));\n        for (int i = 0; i < MAX_G; i++) for (int j = 0; j < (1<<MAX_G); j++) dp[i][j] = INF;\n        for (int i = 0; i < h; i++) \n            cin >> field[i];\n        \n        int cur = 1;\n        for (int i = 0; i < h; i++) \n            for (int j = 0; j < w; j++) {\n                if (field[i][j] == 'o') number[i][j] = 0;\n                if (field[i][j] == '*') number[i][j] = cur++;\n            }\n        garbage_count = cur;\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (field[i][j] == 'o' || field[i][j] == '*') {\n                    bool visited[h][w]; memset(visited, 0, sizeof(visited));\n                    queue<S> q;\n                    q.push(S(i, j, 0));\n                    while (!q.empty()) {\n                        S s = q.front(); q.pop();\n                        visited[s.y][s.x] = true;\n                        if (field[s.y][s.x] == 'o' || field[s.y][s.x] == '*') \n                            graph[number[i][j]][number[s.y][s.x]] = s.t;\n                        for (int k = 0; k < 4; k++) {\n                            int ny = s.y + dy[k];\n                            int nx = s.x + dx[k];\n                            if (0 <= ny && ny < h && 0 <= nx && nx < w && !visited[ny][nx] && field[ny][nx] != 'x') \n                                q.push(S(ny, nx, s.t+1));\n                        }\n                    }\n                }\n            }\n        }\n\n        bool possible = true;\n        for (int i = 0; i < garbage_count; i++) \n            for (int j = 0; j < garbage_count; j++) \n                if (graph[i][j] == -1) {\n                    possible = false;\n                    break;\n                }\n\n        if (!possible) cout << -1 << endl;\n        else cout << solve(0, 0) << endl;\n   }\n    return 0;\n}\n\n                            \n                        "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <queue>\n#include <cmath>\n#include <tuple>\n#include <unordered_map>\n#include <bitset>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define all(n)\tn.begin(),n.end()\n#define each(i,n) for(auto &i : n)\n\nconst int INF = 1e9;\n\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\n\nsigned main() {\n\n\tint w, h;\n\twhile (cin >> w >> h && w) {\n\t\ttypedef pair<int, int> p;\n\n\t\tchar d[20][20];\n\t\tp s;\n\t\tmap<p, int> tb;\n\t\trep(y, h)rep(x, w) {\n\t\t\tcin >> d[y][x];\n\t\t\tif (d[y][x] == 'o') {\n\t\t\t\ts.first = y, s.second = x;\n\t\t\t}\n\t\t\tif (d[y][x] == '*') {\n\t\t\t\ttb[p(y, x)] = tb.size();\n\t\t\t}\n\t\t}\n\n\t\ttypedef bitset<10> bit;\n\t\tunordered_map<bit ,int> m[20][20];\n\t\tm[s.first][s.second][bit()] = 0;\n\t\ttypedef pair<bit, p> sp;\n\t\tqueue<sp> q;\n\t\tq.push(sp(bit(), s));\n\t\tint ans = INF;\n\t\twhile (q.size()) {\n\t\t\tp n = q.front().second;\n\t\t\tauto se = q.front().first;\n\t\t\tq.pop();\n\t\t\tint y = n.first;\n\t\t\tint x = n.second;\n\t\t\tauto nse = se;\n\t\t\tif (d[y][x] == '*') {\n\t\t\t\tnse[tb[p(y, x)]] = 1;\n\t\t\t}\n\t\t\tif (nse.count() == tb.size()) {\n\t\t\t\tans = min(ans, m[y][x][se]);\n\t\t\t}\n\t\t\trep(i, 4) {\n\t\t\t\tint ty = y + dy[i];\n\t\t\t\tint tx = x + dx[i];\n\t\t\t\tif (ty >= 0 && tx >= 0 && ty < h && tx < w && d[ty][tx] != 'x') {\n\t\t\t\t\tif (!m[ty][tx].count(nse) || m[ty][tx][nse] > m[y][x][se] + 1) {\n\t\t\t\t\t\tm[ty][tx][nse] = m[y][x][se] + 1;\n\t\t\t\t\t\tq.push(sp(nse, p(ty, tx)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tif (ans == INF)ans = -1;\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = {-1,0,1,0}; const int dy[] = {0,1,0,-1};\n\nconst int MAXW = 20 + 2;\nconst int MAXH = 20 + 2;\n\n#define INF 1e9\n\nchar field[MAXH][MAXW];\n\nstruct P{\n    int p, cost, reach;\n\n    bool operator > (const P& p) const {\n        return cost > p.cost;\n    }\n};\n\nstruct Q{\n    int x, y, cost;\n};\n\nstruct Edge{\n    int p, cost;\n};\n\nint main() {\n    int w, h;\n    while(cin >> w >> h, w|h){\n        fill_n((char *)field, (MAXH) * (MAXW), 'X');\n\n        int robot;\n        vector<pii> gb;\n\n        REP(y, h){\n            REP(x, w) {\n                char c;\n                cin >> c;\n                switch(c){\n                    case 'o':\n                        robot = gb.size();\n                    case '*':\n                        gb.push_back({x + 1, y + 1});\n                        break;\n                }\n                field[y + 1][x + 1] = c;\n            }\n        }\n\n        vector<vector<Edge>> E(gb.size() + 1);\n\n        REP(i, gb.size()){\n            pii p = gb[i];\n            queue<Q> que;\n            que.push({p.first, p.second, 0});\n            bool reach[MAXH][MAXW] = {false};\n            while(!que.empty()){\n                Q q = que.front(); que.pop();\n                reach[q.y][q.x] = true;\n\n                REP(j, 4){\n                    int sx = q.x + dx[j];\n                    int sy = q.y + dy[j];\n                    switch(field[sy][sx]){\n                        case '*':\n                            if(!reach[sy][sx]) {\n                                REP(idx, gb.size()) {\n                                    if (gb[idx].first == sx && gb[idx].second == sy) {\n                                        E[i].push_back({idx, q.cost + 1});\n                                        break;\n                                    }\n                                }\n                            }\n                        case '.':\n                            if(!reach[sy][sx]) {\n                                reach[sy][sx] = true;\n                                que.push({sx, sy, q.cost + 1});\n                            }\n                            break;\n                    }\n                }\n            }\n        }\n        if(E[0].size() < gb.size() - 1){\n            cout << -1 << endl;\n            continue;\n        }\n\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push({robot, 0, (1 << robot)});\n        vvi G(gb.size() + 1, vi(1<<gb.size() , INF));\n        G[robot][(1 << robot)] = 0;\n\n        while(!que.empty()){\n            P p = que.top(); que.pop();\n\n//            LOG(\"%d %d, %d\\n\", gb[p.p].first, gb[p.p].second, p.reach);\n\n            if(p.reach == (1 << gb.size()) - 1){\n                cout << p.cost << endl;\n                break;\n            }\n\n            for(Edge e : E[p.p]){\n                int next_cost = p.cost + e.cost;\n                int next_reach = p.reach | (1 << e.p);\n                if (G[e.p][next_reach] > next_cost){\n                    G[e.p][next_reach] = next_cost;\n                    if(p.reach & (1<<e.p)) continue;\n                    que.push({e.p, next_cost, next_reach});\n                }\n            }\n        }\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define MAX 12\n#define mk make_pair\n#define INF 1<<28\nstring s[20];\nbool vis[20][20];\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint n,w,h,d[MAX][MAX],c;\nint dp[1<<MAX][MAX];\nint rec(int s,int v){\n  if(dp[s][v]>=0)return dp[s][v];\n  if(s==(1<<n)-1&&v!=0){return dp[s][v]=0;}\n  int res=INF;\n  for(int u=0;u<n;u++) \n    if(!(s>>u&1))\n      res=min(res,rec(s|1<<u,u)+d[v][u]);\n  return dp[s][v]=res;\n}\nvoid bfs(int x2,int y2,int k){\n  r(i,20)r(j,20)vis[i][j]=0;\n  queue<pair<pair<int,int>,int> > q;\n  vis[x2][y2]=1;\n  q.push(mk(mk(x2,y2),0));\n  while(!q.empty()){\n    pair<pair<int,int>,int>p=q.front();q.pop();\n    int p1=p.first.first,p2=p.first.second,p3=p.second;//cout<<p1<<p2<<p3<<endl;\n    r(i,4){\n      int x=dx[i]+p1;\n      int y=dy[i]+p2;\n      if(x>=0&&x<w&&y>=0&&y<h)\n        if(!vis[x][y]&&(s[y][x]!='#')){\n          if(0<=s[y][x]&&s[y][x]<12)\n            d[k][(int)s[y][x]]=p3+1;\n          else if(k!=0&&s[y][x]=='o')\n            d[k][0]=p3+1;\n          else q.push(mk(mk(x,y),p3+1));\n          vis[x][y]=1;\n        }\n    }\n  }\n}\nint main(){\n  while(cin>>w>>h,w){c=1;\n    int a,b;\n    vector<pair<int,int> >v;\n    r(i,h)cin>>s[i];\n    r(j,w)r(i,h)if(s[i][j]=='*')s[i][j]=c++,v.push_back(make_pair(j,i));\n  memset(dp,-1,sizeof(dp));\n  n=c;\n  r(i,MAX)r(j,MAX)d[i][j]=INF;\n  r(j,w)r(i,h)if(s[i][j]=='o')a=j,b=i;\n  bfs(a,b,0);\n  r(i,c-1)bfs(v[i].first,v[i].second,i+1);\n  //r(i,c){r(j,c){cout<<d[i][j]<<' ';}cout<<endl;}cout<<d[0][1];\n  int p=rec(1,0);\n  if(p==INF)p=-1;\n  cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<deque>\n#include<queue>\n\nusing namespace std;\n\nint main(){\n  int h,w;\n  while(scanf(\"%d%d\\n\",&w,&h),w+h){\n    char board[22][24]={{0}};\n    deque<pair<int,int> > pos;\n    int count=3;\n    for(int i=1;i<=h;i++){\n      fgets(&board[i][1],23,stdin); board[i][w+1]=0;\n      for(int j=1;j<=w;j++){\n\tif(board[i][j]=='x')      board[i][j]=0;\n\telse if(board[i][j]=='.') board[i][j]=1;\n\telse if(board[i][j]=='*'){\n\t  board[i][j]=count++;\n\t  pos.push_back(make_pair(j,i));\n\t}else if(board[i][j]=='o'){\n\t  board[i][j]=2;\n\t  pos.push_front(make_pair(j,i));\n\t}\n      }\n    }\n\n    /*\n    for(int i=0;i<h+2;i++){\n      for(int j=0;j<w+2;j++){\n\tprintf(\"%d \",board[i][j]);\n      }\n      puts(\"\");\n    }\n    */\n\n    //int darty=pos.size()-1;\n    int dist[11][11]={{0}};\n    bool possible=true;\n    for(int i=0;i<pos.size()-1;i++){\n      //dijkstra\n      int flag[22][22]={{0}};\n      int d[22][22];\n      for(int x=0;x<22;x++)\n\tfor(int y=0;y<22;y++)\n\t  d[y][x]=1000;\n      count=0;\n      priority_queue<pair<int,pair<int,int> > > q;\n      q.push(make_pair(0,make_pair(pos[i].first,pos[i].second)));\n      while(!q.empty()){\n\tif(count==pos.size()) break;\n\tint x=q.top().second.first,y=q.top().second.second,hy=q.top().first;\n\tq.pop();\n\t//printf(\"(%d,%d)=%d\\n\",x,y,-hy);\n\tif(flag[y][x]!=0) continue;\n\tflag[y][x]=1;\n\tif(board[y][x]>=2){//darty or initial\n\t  //printf(\"test %d\\n\",board[y][x]-2);\n\t  dist[i][board[y][x]-2]=-hy;\n\t  dist[board[y][x]-2][i]=-hy;\n\t  count++;\n\t}\n\tif(board[y][x-1]!=0 && d[y][x-1]>-hy+1){\n\t  d[y][x-1]=-hy+1;\n\t  q.push(make_pair(hy-1,make_pair(x-1,y)));\n\t}\n\tif(board[y][x+1]!=0 && d[y][x+1]>-hy+1) {\n\t  d[y][x+1]=-hy+1;\n\t  q.push(make_pair(hy-1,make_pair(x+1,y)));\n\t}\n\tif(board[y-1][x]!=0 && d[y-1][x]>-hy+1){\n\t  d[y-1][x]=-hy+1;\n\t  q.push(make_pair(hy-1,make_pair(x,y-1)));\n\t}\n\tif(board[y+1][x]!=0 && d[y+1][x]>-hy+1){\n\t  d[y+1][x]=-hy+1;\n\t  q.push(make_pair(hy-1,make_pair(x,y+1)));\n\t}\n      }\n      if(count!=pos.size()){\n\tpossible=false;\n\tbreak;\n      }\n    }\n    if(!possible){\n      puts(\"-1\");\n      continue;\n    }\n    \n    /*\n    for(int i=0;i<pos.size();i++){\n      for(int j=0;j<pos.size();j++){\n\tprintf(\"%3d\",dist[i][j]);\n      }\n      printf(\"\\n\");\n    }\n    */\n    //traveling salesman problem\n    vector<int> v(pos.size()-1);\n    int ans=100000;\n    for(int i=0;i<pos.size()-1;i++) v[i]=i+1;\n    do{\n      int tmp=dist[0][v[0]];\n      for(int i=0;i<pos.size()-2;i++){\n\ttmp+=dist[v[i]][v[i+1]];\n\tif(tmp>ans){\n\t  sort(&v[i+1],&v[pos.size()-2],greater<int>());\n\t  break;\n\t}\n      }\n      if(ans>tmp) ans=tmp;\n    }while(next_permutation(v.begin(),v.end()));\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int, pair<int, int> > pii;\n#define piii(x, y, d) make_pair(x, make_pair(y, d))\n\nint w, h;\nchar c[20][20], cc[20][20];\nint n;\nint gx[11], gy[11];\nint g[11][11];\nint dp[1 << 11][11];\nconst int INF = 10000000;\n\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nint bfs(int sx, int sy, int gx, int gy)\n{\n    queue<pii> q;\n\n    q.push(piii(sx, sy, 0));\n\n    while (!q.empty()) {\n        int x = q.front().first;\n        int y = q.front().second.first;\n        int d = q.front().second.second;\n        q.pop();\n        //printf(\"(%d, %d) = %d\\n\", x, y, d);\n\n        cc[x][y] = 'x';\n        for (int i = 0; i < 4; ++i) {\n            int nx = x + dx[i], ny = y + dy[i];\n            if (nx < 0 || h <= nx || ny < 0 || w <= ny)\n                continue;\n            if (cc[nx][ny] == 'x')\n                continue;\n            if (nx == gx && ny == gy)\n                return d + 1;\n            q.push(piii(nx, ny, d + 1));\n        }\n    }\n    return INF;\n}\n\nint tsp(int visited, int v)\n{\n    if (dp[visited][v] != -1)\n        return dp[visited][v];\n\n    if (visited == (1 << n) - 1)\n        return 0;\n\n    int res = INF;\n    for (int u = 0; u < n; ++u) {\n        if (!(visited & (1 << u))) {\n            res = min(res, tsp(visited | (1 << u), u) + g[v][u]);\n        }\n    }\n    return dp[visited][v] = res;\n}\n\nint main()\n{\n    for (;;) {\n        scanf(\"%d %d\", &w, &h);\n        if (w == 0 && h == 0)\n            break;\n\n        n = 1;\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                scanf(\" %c\", &c[i][j]);\n                if (c[i][j] == 'o') {\n                    gx[0] = i;\n                    gy[0] = j;\n                } else if (c[i][j] == '*') {\n                    gx[n] = i;\n                    gy[n] = j;\n                    ++n;\n                }\n            }\n        }\n        //for (int i = 0; i < n; ++i) printf(\"%d, %d\\n\", gx[i], gy[i]);\n\n        fill(&g[0][0], &g[11][0], INF);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j){\n                copy(&c[0][0], &c[20][0], &cc[0][0]);\n                if (i == j)\n                    g[i][j] = 0;\n                else\n                    g[i][j] = bfs(gx[i], gy[i], gx[j], gy[j]);\n                //printf(\"%d\\t\", g[i][j]);\n            }\n            //printf(\"\\n\");\n        }\n\n        /*\n        fill(&dp[0][0], &dp[1 << 11][0], -1);\n        int res = tsp(1, 0);\n        if (res == INF)\n            printf(\"-1\\n\");\n        else\n            printf(\"%d\\n\", res);\n        */\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nint w, h;\nstring b[20];\nint step[20][20];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid bfs(int x, int y){\n\tmemset(step, -1, sizeof(step));\n\tqueue< pair<int, int> > qu; qu.push(make_pair(x,y));\n\tstep[x][y] = 0;\n\twhile(!qu.empty()){\n\t\tpair<int, int> pr = qu.front(); qu.pop();\n\t\tint cx = pr.first, cy = pr.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx = cx+dx[i], ny = cy+dy[i];\n\t\t\tif(nx<0||h<=nx||ny<0||w<=ny||b[nx][ny]=='x'||step[nx][ny]!=-1) continue;\n\t\t\tstep[nx][ny] = step[cx][cy]+1;\n\t\t\tqu.push(make_pair(nx,ny));\n\t\t}\n\t}\n}\n\nint main(){\n\tint c[11][11];\n\twhile(cin >> w >> h, w){\n\t\tfor(int i=0;i<h;i++) cin >> b[i];\n\t\tvector<int> x(1), y(1);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(b[i][j]=='o') x[0] = i, y[0] = j;\n\t\t\t\tif(b[i][j]=='*') x.push_back(i), y.push_back(j);\n\t\t\t}\n\t\t}\n\t\tint res = 1000000000;\n\t\tfor(int i=0;i<x.size();i++){\n\t\t\tbfs(x[i], y[i]);\n\t\t\tfor(int j=0;j<x.size();j++){\n\t\t\t\tc[i][j] = step[x[j]][y[j]];\n\t\t\t\tif(c[i][j]==-1) res = -1;\n\t\t\t}\n\t\t}\n\t\tvector<int> a(x.size()-1);\n\t\tfor(int i=0;i<x.size()-1;i++) a[i] = i+1;\n\t\tdo{\n\t\t\tint cur = c[0][a[0]];\n\t\t\tfor(int i=0;i+1<a.size();i++) cur += c[a[i]][a[i+1]];\n\t\t\tres = min(res, cur);\n\t\t}while(next_permutation(a.begin(), a.end()));\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing pii = pair<int, int>;\n\nconstexpr int INF = (1 << 12);\nconstexpr int dir[5] = {0, 1, 0, -1, 0};\n\nbool ispower(int n)\n{\n    return n == (pow(2, static_cast<int>(log2(n))));\n}\n\nvoid bfs_dist(const vector<vector<int>>& room, const pii& pos, vector<int>& dist, const vector<pii>& dirty)\n{\n    const int h = room.size();\n    const int w = room[0].size();\n    vector<vector<bool>> checked(h, vector<bool>(w, false));\n    queue<pair<pii, int>> q;\n    q.push(make_pair(pos, 0));\n    while (not q.empty()) {\n        const pii p = q.front().first;\n        const int distance = q.front().second;\n        const int pi = p.first;\n        const int pj = p.second;\n        for (int i = 0; i < dirty.size(); i++) {\n            if (p == dirty[i] and (not checked[pi][pj])) {\n                dist[i] = distance;\n            }\n        }\n        checked[pi][pj] = true;\n        q.pop();\n        for (int d = 0; d < 4; d++) {\n            const int newi = pi + dir[d];\n            const int newj = pj + dir[d + 1];\n            if (0 <= newi and newi < h and 0 <= newj and newj < w) {\n                if (room[newi][newj] != -1 and (not checked[newi][newj])) {\n                    q.push(make_pair(make_pair(newi, newj), distance + 1));\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        int h, w;\n        cin >> w >> h;\n        if (w == 0 and h == 0) {\n            break;\n        }\n        vector<vector<int>> room(h, vector<int>(w));\n\n        pii start;\n        vector<pii> dirty;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                char c;\n                cin >> c;\n                if (c == '.') {\n                    room[i][j] = 0;\n                } else if (c == '*') {\n                    room[i][j] = 1;\n                    dirty.push_back(make_pair(i, j));\n                } else if (c == 'x') {\n                    room[i][j] = -1;\n                } else {\n                    room[i][j] = 0;\n                    start.first = i;\n                    start.second = j;\n                }\n            }\n        }\n\n        const int dirtynum = dirty.size();\n        vector<vector<int>> dist(dirtynum, vector<int>(dirtynum, INF));\n        vector<int> initdist(dirtynum, INF);\n        bfs_dist(room, start, initdist, dirty);\n        for (int i = 0; i < dirtynum; i++) {\n            bfs_dist(room, dirty[i], dist[i], dirty);\n        }\n\n        for (int i = 0; i < dirtynum; i++) {\n            if (initdist[i] == INF) {\n                cout << -1 << endl;\n                continue;\n            }\n        }\n\n        const int maximum = 1 << dirtynum;\n        vector<vector<int>> dp(maximum, vector<int>(dirtynum, INF));  // dp[visited[last]\n        for (int n = 1; n < maximum; n++) {\n            for (int i = 0; i < dirtynum; i++) {\n                if ((n >> i) % 2) {\n                    for (int j = 0; j < dirtynum; j++) {  //i->j\n                        if ((n >> j) % 2) {\n                            if (i == j) {\n                                if (ispower(n)) {\n                                    dp[n][i] = initdist[i];\n                                }\n                                continue;\n                            }\n                            dp[n][j] = min(dp[n][j], dp[n - (1 << j)][i] + dist[i][j]);\n                        }\n                    }\n                }\n            }\n        }\n        int mini = INF;\n        for (int i = 0; i < dirtynum; i++) {\n            mini = min(mini, dp[maximum - 1][i]);\n        }\n        cout << mini << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <iostream>\n#include <queue>\n#define MAX 20\n#define INF 10000000\n\nusing namespace std;\n\nint w, h;\nint si, sj;\nchar c[MAX][MAX];\nint d[MAX][MAX][1024];\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid change(int a[10], int x){\n\n\tfor(int i = 0 ; i < 10 ; ++i){\n\t\ta[i] = x % 2;\n\t\tx /= 2;\n\t}\n\n}\n\nint change(int a[10]){\n\n\tint res = 0;\n\tfor(int i = 9 ; i >= 0 ; --i){\n\t\tres = res * 2 + a[i];\n\t}\n\treturn res;\n}\n\nint bfs(int sx, int sy, int cnt){\n\n\tqueue<int> qx, qy, qbit;\n\tqy.push(sj);\n\tqx.push(si);\n\tqbit.push(0);\n\n\td[sj][si][0] = 0;\n\n\n\twhile(qbit.empty() == false){\n\n\t\tint y = qy.front();\n\t\tqy.pop();\n\n\t\tint x = qx.front();\n\t\tqx.pop();\n\n\t\tint bit = qbit.front();\n\t\tqbit.pop();\n\n\t\tif( bit + 1 == (1 << cnt) ){\t\t\t\t// ?????§?????¨??????????????????????????????\n\t\t\treturn d[y][x][bit];\n\t\t}\n\n\t\tint a[10];\n\t\tfor(int i = 0 ; i < 4 ; ++i){\n\n\t\t\tchange(a, bit);\n\t\t\tint ny = dy[i] + y;\n\t\t\tint nx = dx[i] + x;\n\n\t\t\tif( ny < 0 || nx < 0 ) continue;\t\t// ?????????\n\t\t\tif( h <= ny || w <= nx) continue;\t\t// ?????????\n\t\t\tif( c[ny][nx] == 'x') continue;\t\t\t// ?§??????§?????????\n\n\t\t\tif( c[ny][nx] != '.'){\t\t\t\t\t// ?±??????????????????§????????´???\n\t\t\t\tint num = c[ny][nx] - '0';\t\t\t// ?±???????????????????ID?????????\n\t\t\t\ta[num] = 1;\n\t\t\t}\n\t\t\tint nbit = change(a);\n\t\t\tint nCost = d[y][x][bit] + 1;\n\n\t\t\tif( nCost < d[ny][nx][nbit] ){\t\t\t// ??????????????£??????????????´??? & ???????§£?????´??°\n\t\t\t\td[ny][nx][nbit] = nCost;\n\t\t\t\tqy.push(ny);\n\t\t\t\tqx.push(nx);\n\t\t\t\tqbit.push(nbit);\n\t\t\t}\n\n\t\t}// end of for\n\n\n\t}// end of while\n\n\n\treturn -1;\n}// end of bfs\n\nvoid init(){\n\n\tfor (int i = 0 ; i < h ; ++i){\n\t\tfor (int j = 0 ; j < w ; ++j){\n\t\t\tfor(int k = 0 ; k < 1024 ; ++k){\n\t\t\t\td[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n\n\n}\n\nint main(void){\n\n\n\twhile( cin >> w >> h ){\n\n\t\tif( w == h && h == 0 ){\n\t\t\tbreak;\n\t\t}\n\t\tinit();\n\t\tint cnt = 0;\n\n\t\tfor(int i = 0 ; i < h ; ++i){\n\t\t\tfor(int j = 0 ; j < w ; ++j){\n\t\t\t\tcin >> c[i][j];\n\t\t\t\tif( c[i][j] == 'o'){\n\t\t\t\t\tsj = j;\n\t\t\t\t\tsi = i;\n\t\t\t\t\tc[i][j] = '.';\n\t\t\t\t}else if( c[i][j] == '*'){\n\t\t\t\t\tc[i][j] = '0' + cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << bfs(si, sj, cnt) << endl;\n\n\t\t// for(int i = 0 ; i < h ; ++i){\n\t\t// \tfor(int j = 0 ; j < w ; ++j ){\n\t\t// \t\tcout << c[i][j];\n\t\t// \t}\n\t\t// \tcout << endl;\n\t\t// }\n\n\t}// end of while\n\n\treturn 0;\n}// end of main"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing Int = ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//ここから編集する\nclass Solve {\npublic:\n    void input() {\n\n    }\n\n    bool solve() {\n        input();\n        Int w, h;\n        cin >> w >> h;\n        if (w == 0) return false;\n\n        vector<string> c(h);\n        rep(i, 0, h) cin >> c[i];\n\n        auto conv = [&](Int r, Int c) {\n            return r * w + c;\n        };\n\n        vector<vector<Int>> dist(w * h, vector<Int>(w * h, INF));\n        for (Int i = 0; i + 1 < h; ++i) {\n            for (Int j = 0; j < w; ++j) {\n                if (c[i][j] != 'x' && c[i + 1][j] != 'x') {\n                    Int f = conv(i, j);\n                    Int t = conv(i + 1, j);\n                    dist[f][t] = dist[t][f] = 1;\n                }\n            }\n        }\n\n        for (Int i = 0; i < h; ++i) {\n            for (Int j = 0; j + 1 < w; ++j) {\n                if (c[i][j] != 'x' && c[i][j + 1] != 'x') {\n                    Int f = conv(i, j);\n                    Int t = conv(i, j + 1);\n                    dist[f][t] = dist[t][f] = 1;\n                }\n            }\n        }\n        for (Int i = 0; i < w * h; ++i) {\n            dist[i][i] = 0;\n        }\n\n        for (int k = 0; k < w * h; ++k) {\n            for (int i = 0; i < w * h; ++i) {\n                for (int j = 0; j < w * h; ++j) {\n                    if (dist[i][k] + dist[k][j] < dist[i][j]) {\n                        dist[i][j] = dist[i][k] + dist[k][j];\n                    }\n                }\n            }\n        }\n\n        Int st;\n        vector<Int> yogore;\n        for (Int i = 0; i < h; ++i) {\n            for (Int j = 0; j < w; ++j) {\n                if (c[i][j] == 'o') st = conv(i, j);\n                else if (c[i][j] == '*') yogore.push_back(conv(i, j));\n            }\n        }\n\n        sort(all(yogore));\n        Int ans = INF;\n        do {\n            vector<Int> arr;\n            arr.push_back(st);\n            for (auto e : yogore) arr.push_back(e);\n            Int tmp = 0;\n            for (int i = 0; i + 1 < arr.size(); ++i) {\n                tmp += dist[arr[i]][arr[i + 1]];\n            }\n            chmin(ans, tmp);\n        } while (next_permutation(all(yogore)));\n\n        if (ans == INF) {\n            cout << -1 << endl;\n        } else {\n            cout << ans << endl;\n        }\n\n        return true;\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    while (Solve().solve());\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\nusing namespace std;\nlong long int ans;\nlong long int cnt[11][11];\n\nvoid check( long long int bit, long long int num, long long int m, long long int l ) {\n  if ( bit == ( 1 << m ) - 1 ) {\n    ans = min( ans, l );\n    return;\n  }\n  for ( long long int i = 0; i < m; i++ ) {\n    if ( ( bit & ( 1 << i ) ) == 0 ) {\n      check( bit + ( 1 << i ), i, m, l + cnt[num][i] );\n    }\n  }\n  return;\n}\n\nint main() {\n\n  int dx[4] = { -1,  0,  0,  1 };\n  int dy[4] = {  0, -1,  1,  0 };\n\n  long long int w, h;\n\n  string input;\n\n  while( cin >> w >> h, w ) {\n\n    vector< long long int > x, y;\n    vector< string > map;\n    map.push_back( \"xxxxxxxxxxxxxxxxxxxxxx\" );\n    for ( long long int i = 0; i < h; i++ ) {\n      cin >> input;\n      map.push_back( \"x\" + input + \"x\" );\n      for ( long long int j = 0; j < w; j++ ) {\n\tif ( map[i+1][j+1] == 'o' ) {\n\t  x.push_back( j+1 );\n\t  y.push_back( i+1 );\n\t  map[i+1][j+1] = 'a';\n\t}\n      }\n    }\n    map.push_back( \"xxxxxxxxxxxxxxxxxxxxxx\" );\n    for ( long long int i = 0; i < h+2; i++ ) {\n      for ( long long int j = 0; j < w+2; j++ ) {\n\tif ( map[i][j] == '*' ) {\n\t  map[i][j] = 'a' + x.size();\n\t  x.push_back( j );\n\t  y.push_back( i );\n\t}\n      }\n    }\n    for ( long long int i = 0; i < x.size(); i++ ) {\n      for ( long long int j = 0; j < x.size(); j++ ) { \n\tcnt[i][j] = -1;\n      }\n    }\n    for ( long long int i = 0; i < x.size(); i++ ) {\n      int flag[22][22] = {0};\n      queue<int> qx, qy;\n      qx.push( x[i] );\n      qy.push( y[i] );\n      flag[x[i]][y[i]] = 1;\n      while( qx.size() > 0 ) {\n\tint k = flag[qx.front()][qy.front()];\n\tfor ( long long int j = 0; j < 4; j++ ) {\n\t  int lx = qx.front() + dx[j];\n\t  int ly = qy.front() + dy[j];\n\t  if ( map[ly][lx] != 'x' && flag[lx][ly] == 0 ) {\n\t    flag[lx][ly] = k + 1;\n\t    qx.push(lx);\n\t    qy.push(ly);\n\t    if ( map[ly][lx] != '.' ) {\n\t      cnt[i][ map[ly][lx] - 'a' ] = k;\n\t    }\n\t  }\n\t}\n\tqx.pop();\n\tqy.pop();\n      }\n    }\n    bool f = false;\n    for ( long long int i = 1; i < x.size(); i++ ) {\n      if ( cnt[0][i] == -1 ) {\n\tcout << \"-1\" << endl;\n\tf = true;\n\tbreak;\n      }\n    }\n    if ( f ) continue;\n    ans = 40*11;\n    check( 1, 0, x.size(), 0 );\n    cout << ans << endl;\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n//#ifdef DEBUG\n#define debug cout\n//#else\n//SS ss;\n//#define debug ss\n//#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nstruct data{\n\tint count,x,y,bit;\n};\n\nint mem[30][30][1<<10];\nmap<pint,int> num;\nqueue<data> que;\n\nint main() {\n\tint w,h;\n\tstring c[30];\n\tIL{\n\t\tcin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\tnum.clear();\n\t\twhile(!que.empty())que.pop();\n\t\tmemset(mem,-1,sizeof(mem));\n\t\trep(i,h)cin>>c[i];\n\t\tint x,y,s=0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(c[i][j]=='o'){\n\t\t\t\tx=j;\n\t\t\t\ty=i;\n\t\t\t}\n\t\t\tif(c[i][j]=='*'){\n\t\t\t\tnum[MP(i,j)]=s++;\n\t\t\t}\n\t\t}\n\t\tdata d;\n\t\td.x=x;\n\t\td.y=y;\n\t\td.count=0;\n\t\td.bit=(1<<s)-1;\n\t\tque.push(d);\n\t\twhile(!que.empty()){\n\t\t\tdata now=que.front();\n\t\t\tque.pop();\n\t\t\tif(now.bit==0){\n\t\t\t\tcout<<now.count<<endl;\n\t\t\t\tgoto aaa;\n\t\t\t}\n\t\t\tif(0<=mem[now.y][now.x][now.bit]&&mem[now.y][now.x][now.bit]<=now.count)continue;\n\t\t\tmem[now.y][now.x][now.bit]=now.count;\n\t\t\trep(i,4){\n\t\t\t\tif(now.x+dx[i]<0||w<=now.x+dx[i]||now.y+dy[i]<0||h<=now.y+dy[i]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdata next=now;\n\t\t\t\tnext.x+=dx[i];\n\t\t\t\tnext.y+=dy[i];\n\t\t\t\tif(c[next.y][next.x]=='x')continue;\n\t\t\t\tif(c[next.y][next.x]=='*')next.bit^=1<<num[MP(next.y,next.x)];\n\t\t\t\t++next.count;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t}\n\t\tcout<<-1<<endl;\n\t\taaa:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint w, h;\nstring b[20];\nint step[20][20];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid bfs(int x, int y){\n\tmemset(step, -1, sizeof(step));\n\tqueue< pair<int, int> > qu; qu.push(make_pair(x,y));\n\tstep[x][y] = 0;\n\twhile(!qu.empty()){\n\t\tpair<int, int> pr = qu.front(); qu.pop();\n\t\tint cx = pr.first, cy = pr.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx = cx+dx[i], ny = cy+dy[i];\n\t\t\tif(nx<0||h<=nx||ny<0||w<=ny||b[nx][ny]=='x'||step[nx][ny]!=-1) continue;\n\t\t\tstep[nx][ny] = step[cx][cy]+1;\n\t\t\tqu.push(make_pair(nx,ny));\n\t\t}\n\t}\n}\n\nint main(){\n\tint c[11][11];\n\twhile(cin >> w >> h, w){\n\t\tfor(int i=0;i<h;i++) cin >> b[i];\n\t\tvector<int> x(1), y(1);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(b[i][j]=='o') x[0] = i, y[0] = j;\n\t\t\t\tif(b[i][j]=='*') x.push_back(i), y.push_back(j);\n\t\t\t}\n\t\t}\n\t\tint res = 1000000000;\n\t\tfor(int i=0;i<x.size();i++){\n\t\t\tbfs(x[i], y[i]);\n\t\t\tfor(int j=0;j<x.size();j++){\n\t\t\t\tc[i][j] = step[x[j]][y[j]];\n\t\t\t\tif(c[i][j]==-1) res = -1;\n\t\t\t}\n\t\t}\n                if(x.size()>1){\n\t\tvector<int> a(x.size()-1);\n\t\tfor(int i=0;i<x.size()-1;i++) a[i] = i+1;\n\t\tdo{\n\t\t\tint cur = c[0][a[0]];\n\t\t\tfor(int i=0;i+1<a.size();i++) cur += c[a[i]][a[i+1]];\n\t\t\tres = min(res, cur);\n\t\t}while(next_permutation(a.begin(), a.end()));\n}\nelse res = 0;\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n#define isUruu(y) ((y % 4 || (y % 100 == 0 && y % 400)) ? false : true)\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef unsigned int uint;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<char> Vc;\ntypedef vector<Vc> VVc;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nconst int INF = 1 << 28;\nconst double EPS = 1e-9;\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {1,0,-1,0};\n\nint main()\n{\n    int w, h;\n    while (cin >> w >> h, h + w) {\n        VVc field(h, Vc(w));\n        int sx,sy;\n        rep (i,h) rep (j,w) {\n            cin >> field[i][j];\n            if (field[i][j] == 'o') sx = i, sy = j;\n        }\n\n        int res = 0;\n        int count = 1;\n        while (count) {\n            queue<P> q;\n            q.push(P(sx,sy));\n            VV d(h, V(w, INF));\n            d[sx][sy] = 0;\n            count = 0;\n            while (q.size()) {\n                P p = q.front(); q.pop();\n                int x = p.first, y = p.second;\n                if (field[x][y] == '*') {\n                    count = d[x][y];\n                    field[x][y] = '.';\n                    sx = x, sy = y;\n                    break;\n                }\n\n                for (int i = 0; i < 4; i++) {\n                    int nx = x + dx[i], ny = y + dy[i];\n                    if (0 <= nx && nx < h && 0 <= ny && ny < w && d[nx][ny] == INF && field[nx][ny] != 'x') {\n                        d[nx][ny] = d[x][y] + 1;\n                        q.push(P(nx,ny));\n                    }\n                }\n            }\n            res += count;\n        }\n\n        bool flag  = true;\n        rep (i,h) rep (j,w) {\n            if (field[i][j] == '*') flag = false;\n        }\n\n        cout << (flag ? res : -1 ) << endl;\n    }\n                \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int, pair<int, int> > pii;\n#define piii(x, y, d) make_pair(x, make_pair(y, d))\n\nint w, h;\nchar c[21][21], cc[21][21];\nint n;\nint gx[11], gy[11];\nint g[11][11];\nint dp[1 << 11][11];\nconst int INF = 10000000;\n\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nint bfs(int sx, int sy, int gx, int gy)\n{\n    queue<pii> q;\n\n    q.push(piii(sx, sy, 0));\n\n    while (!q.empty()) {\n        int x = q.front().first;\n        int y = q.front().second.first;\n        int d = q.front().second.second;\n        q.pop();\n        //printf(\"(%d, %d) = %d\\n\", x, y, d);\n\n        cc[x][y] = 'x';\n        for (int i = 0; i < 4; ++i) {\n            int nx = x + dx[i], ny = y + dy[i];\n            if (nx < 0 || h <= nx || ny < 0 || w <= ny)\n                continue;\n            if (cc[nx][ny] == 'x')\n                continue;\n            if (nx == gx && ny == gy)\n                return d + 1;\n            q.push(piii(nx, ny, d + 1));\n        }\n    }\n    return INF;\n}\n\nint tsp(int visited, int v)\n{\n    if (dp[visited][v] != -1)\n        return dp[visited][v];\n\n    if (visited == (1 << n) - 1)\n        return 0;\n\n    int res = INF;\n    for (int u = 0; u < n; ++u) {\n        if (!(visited & (1 << u))) {\n            res = min(res, tsp(visited | (1 << u), u) + g[v][u]);\n        }\n    }\n    return dp[visited][v] = res;\n}\n\nint main()\n{\n    for (;;) {\n        scanf(\"%d %d\", &w, &h);\n        if (w == 0 && h == 0)\n            break;\n\n        n = 1;\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                scanf(\" %c\", &c[i][j]);\n                if (c[i][j] == 'o') {\n                    gx[0] = i;\n                    gy[0] = j;\n                } else if (c[i][j] == '*') {\n                    gx[n] = i;\n                    gy[n] = j;\n                    ++n;\n                }\n            }\n        }\n        //for (int i = 0; i < n; ++i) printf(\"%d, %d\\n\", gx[i], gy[i]);\n\n        fill(&g[0][0], &g[11][0], INF);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j){\n                copy(&c[0][0], &c[20][0], &cc[0][0]);\n                if (i == j)\n                    g[i][j] = 0;\n                else\n                    g[i][j] = bfs(gx[i], gy[i], gx[j], gy[j]);\n                //printf(\"%d\\t\", g[i][j]);\n            }\n            //printf(\"\\n\");\n        }\n\n        fill(&dp[0][0], &dp[1 << 11][0], -1);\n        int res = tsp(1, 0);\n        if (res == INF)\n            printf(\"-1\\n\");\n        else\n            printf(\"%d\\n\", res);\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <cfloat>\nusing namespace std;\n\nint INF = INT_MAX / 4;\n\nint calculateDist(vector<string>& tile, int y1, int x1, int y2, int x2)\n{\n    int h = tile.size();\n    int w = tile[0].size();\n    vector<vector<int> > minDist(h, vector<int>(w, INF));\n\n    int dy[] = {0, 0, 1, -1};\n    int dx[] = {1, -1, 0, 0};\n\n    queue<pair<int, int> > q;\n    q.push(make_pair(y1, x1));\n    minDist[y1][x1] = 0;\n    while(!q.empty()){\n        int y0 = q.front().first;\n        int x0 = q.front().second;\n        q.pop();\n        for(int i=0; i<4; ++i){\n            int y = y0 + dy[i];\n            int x = x0 + dx[i];\n            if(tile[y][x] != 'x' && minDist[y][x] == INF){\n                minDist[y][x] = minDist[y0][x0] + 1;\n                if(y == y2 && x == x2)\n                    return minDist[y][x];\n                q.push(make_pair(y, x));\n            }\n        }\n    }\n    return INF;\n}\n\nint solve(vector<string>& tile)\n{\n    int h = tile.size();\n    int w = tile[0].size();\n\n    int sy, sx;\n    vector<int> y, x;\n    for(int i=0; i<h; ++i){\n        for(int j=0; j<w; ++j){\n            if(tile[i][j] == 'o'){\n                sy = i;\n                sx = j;\n            }\n            if(tile[i][j] == '*'){\n                y.push_back(i);\n                x.push_back(j);\n            }\n        }\n    }\n\n    int n = y.size();\n    vector<vector<int> > dist(n, vector<int>(n, 0));\n    for(int i=0; i<n; ++i){\n        for(int j=i+1; j<n; ++j){\n            dist[i][j] = dist[j][i] = calculateDist(tile, y[i], x[i], y[j], x[j]);\n        }\n    }\n\n    vector<vector<int> > minDist(n, vector<int>(1<<n, INF));\n    for(int i=0; i<n; ++i){\n        minDist[i][1<<i] = calculateDist(tile, sy, sx, y[i], x[i]);\n    }\n    for(int i=0; i<(1<<n); ++i){\n        bitset<10> bs(i);\n        for(int j=0; j<n; ++j){\n            for(int k=0; k<n; ++k){\n                if(bs[k])\n                    continue;\n                bs[k] = true;\n                minDist[k][bs.to_ulong()] = min(minDist[k][bs.to_ulong()], minDist[j][i] + dist[j][k]);\n                bs[k] = false;\n            }\n        }\n    }\n\n    int ret = INF;\n    for(int i=0; i<n; ++i){\n        ret = min(ret, minDist[i][(1<<n)-1]);\n    }\n    if(ret == INF)\n        return -1;\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int w, h;\n        cin >> w >> h;\n        if(w == 0)\n            break;\n\n        vector<string> tile(h+2);\n        tile[0] = tile[h+1] = string(w+2, 'x');\n        for(int i=1; i<=h; ++i){\n            cin >> tile[i];\n            tile[i] = 'x' + tile[i] + 'x';\n        }\n        cout << solve(tile) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*********************\nAOJ_1140\nCleaning Robot\n*********************/\n#include <iostream>\n#include <queue>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n//構造体宣言\nstruct pos{\n\tint x;\t\t//座標\n\tint y;\t\t\n\tint dis;\t//距離\n};\n\nint main(){\n\tint w, h;\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 || h == 0) break;\n\n\t\t//タイルの初期化\n\t\tchar tile[30][30];\n\t\tfor(int i = 0; i < 30; i ++){\n\t\t\tfor(int j = 0; j < 30; j++){\n\t\t\t\ttile[i][j] = 'x';\n\t\t\t}\n\t\t}\n\t\t//タイルの入力\n\t\tint stain = 0;\t//汚れの数\n\t\tqueue<pos> que;\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tstring input;\n\t\t\tcin >> input;\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\ttile[i][j] = input[j-1];\n\t\t\t\tif(tile[i][j] == '*') stain++;\n\t\t\t\tif(tile[i][j] == 'o'){\n\t\t\t\t\tpos p;\n\t\t\t\t\tp.y = i; p.x = j;\n\t\t\t\t\tp.dis = 0;\n\t\t\t\t\tque.push(p);\n\t\t\t\t\ttile[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint count = 0;\n\t\twhile(stain > 0){\n\t\t\tchar bfs[30][30];\n\t\t\tmemcpy(bfs, tile, sizeof(bfs));\n\t\t\tpos p = que.front();\n\t\t\tbfs[p.y][p.x] = 0;\n\t\t\tint x1[] = {-1, 0, 1, 0}, y1[] = {0, -1, 0, 1};\n\t\t\tint f = 1;\n\t\t\twhile(f && !que.empty()){\n\t\t\t\tpos p1 = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tp = p1;\n\t\t\t\t\tp.x += x1[i]; p.y += y1[i];\n \t\t\t\t\tif(bfs[p.y][p.x] == '.'){\n\t\t\t\t\t\tp.dis++;\n\t\t\t\t\t\tbfs[p.y][p.x] = p.dis;\n\t\t\t\t\t\tque.push(p);\n\t\t\t\t\t}else if(bfs[p.y][p.x] == '*'){\n\t\t\t\t\t\tcount += p.dis+1;\n\t\t\t\t\t\tstain--;\n\t\t\t\t\t\ttile[p.y][p.x] == '.';\n\t\t\t\t\t\twhile(!que.empty()) que.pop();\n\t\t\t\t\t\tp.dis = 0;\n\t\t\t\t\t\tque.push(p);\n\t\t\t\t\t\tf = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(que.empty()) break;\n\t\t}\n\n\t\tif(stain > 0) cout << \"-1\" << endl;\n\t\telse cout << count << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<int,P>PP;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nchar mp[22][22];\n\nint bit[]={1,2,4,8,16,32,64,128,256,512,1024};\nint W,H,X[11],Y[11],cnt,cst[11][11];\n\nvoid cst_cal(){\n\tfor(int i=0;i<=cnt;i++){\n\t\tint tmp[22][22];\n\t\tfor(int j=0;j<22*22;j++)tmp[j/22][j%22]=-1;\n\t\tqueue<P>Q;\n\t\tQ.push(P(X[i],Y[i]));\n\t\ttmp[X[i]][Y[i]]=0;\n\t\twhile(!Q.empty()){\n\t\t\tP p=Q.front();Q.pop();\n\t\t\tint x=p.first,y=p.second;\n\t\t\tif('.'!=mp[x][y])cst[i][mp[x][y]-'0']=tmp[x][y];\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tif(mp[x+dx[j]][y+dy[j]]!='x' && tmp[x+dx[j]][y+dy[j]]<0){\n\t\t\t\t\ttmp[x+dx[j]][y+dy[j]]=tmp[x][y]+1;\n\t\t\t\t\tQ.push(P(x+dx[j],y+dy[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\t\n\twhile(cin>>W>>H,W){\n\t\tcnt=0;\n\t\tfor(int i=0;i<11*11;i++)cst[i/11][i%11]=114514;\n\t\tfor(int i=0;i<22*22;i++)mp[i/22][i%22]='x';\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tcin>>mp[j][i];\n\t\t\t\tif(mp[j][i]=='o'){\n\t\t\t\t\tX[0]=j;\n\t\t\t\t\tY[0]=i;\n\t\t\t\t\tmp[j][i]='0';\n\t\t\t\t}\n\t\t\t\tif(mp[j][i]=='*'){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tX[cnt]=j;\n\t\t\t\t\tY[cnt]=i;\n\t\t\t\t\tmp[j][i]='0'+cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcst_cal();\n\t\t\n\t\tmap<P,int>M;\n\t\tpriority_queue<PP, vector<PP>,greater<PP> >Q;\n\t\tQ.push(PP(1,P(1,0)));//スコア/ビット/場所\n\t\tint ans=0;\n\t\twhile(!Q.empty()){\n\t\t\tPP p=Q.top();Q.pop();\n\t\t\tif(M[p.second]!=0)continue;\n\t\t\tM[p.second]=p.first;\n\t\t\tif(p.second.first==bit[cnt]*2-1){\n\t\t\t\tans=p.first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<=cnt;i++){\n\t\t\t\tif(M[P(bit[i]|p.second.first,i)]==0 && cst[p.second.second][i]!=114514){\n\t\t\t\t\tQ.push(PP(p.first+cst[p.second.second][i],P(bit[i]|p.second.first,i)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans-1<<endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<deque>\n#include<queue>\n\nusing namespace std;\n\nint main(){\n  int h,w;\n  while(scanf(\"%d%d\\n\",&w,&h),w+h){\n    char board[22][22]={{0}};\n    deque<pair<int,int> > pos;\n    int count=3;\n    for(int i=1;i<=h;i++){\n      gets(&board[i][1]);\n      for(int j=1;j<=w;j++){\n\tif(board[i][j]=='x')      board[i][j]=0;\n\telse if(board[i][j]=='.') board[i][j]=1;\n\telse if(board[i][j]=='*'){\n\t  board[i][j]=count++;\n\t  pos.push_back(make_pair(j,i));\n\t}else if(board[i][j]=='o'){\n\t  board[i][j]=2;\n\t  pos.push_front(make_pair(j,i));\n\t}\n      }\n    }\n\n    /*\n    for(int i=0;i<h+2;i++){\n      for(int j=0;j<w+2;j++){\n\tprintf(\"%d \",board[i][j]);\n      }\n      puts(\"\");\n    }\n    */\n\n    //int darty=pos.size()-1;\n    int dist[11][11]={{0}};\n    bool possible=true;\n    for(int i=0;i<pos.size()-1;i++){\n      //dijkstra\n      int flag[22][22]={{0}};\n      int d[22][22];\n      for(int x=0;x<22;x++)\n\tfor(int y=0;y<22;y++)\n\t  d[y][x]=1000;\n      count=0;\n      priority_queue<pair<int,pair<int,int> > > q;\n      q.push(make_pair(0,make_pair(pos[i].first,pos[i].second)));\n      while(!q.empty()){\n\tif(count==pos.size()) break;\n\tint x=q.top().second.first,y=q.top().second.second,hy=q.top().first;\n\tq.pop();\n\t//printf(\"(%d,%d)=%d\\n\",x,y,-hy);\n\tif(flag[y][x]!=0) continue;\n\tflag[y][x]=1;\n\tif(board[y][x]>=2){//darty or initial\n\t  //printf(\"test %d\\n\",board[y][x]-2);\n\t  dist[i][board[y][x]-2]=-hy;\n\t  dist[board[y][x]-2][i]=-hy;\n\t  count++;\n\t}\n\tif(board[y][x-1]!=0 && d[y][x-1]>-hy+1){\n\t  d[y][x-1]=-hy+1;\n\t  q.push(make_pair(hy-1,make_pair(x-1,y)));\n\t}\n\tif(board[y][x+1]!=0 && d[y][x+1]>-hy+1) {\n\t  d[y][x+1]=-hy+1;\n\t  q.push(make_pair(hy-1,make_pair(x+1,y)));\n\t}\n\tif(board[y-1][x]!=0 && d[y-1][x]>-hy+1){\n\t  d[y-1][x]=-hy+1;\n\t  q.push(make_pair(hy-1,make_pair(x,y-1)));\n\t}\n\tif(board[y+1][x]!=0 && d[y+1][x]>-hy+1){\n\t  d[y+1][x]=-hy+1;\n\t  q.push(make_pair(hy-1,make_pair(x,y+1)));\n\t}\n      }\n      if(count!=pos.size()){\n\tpossible=false;\n\tbreak;\n      }\n    }\n    if(!possible){\n      puts(\"-1\");\n      continue;\n    }\n    \n    /*\n    for(int i=0;i<pos.size();i++){\n      for(int j=0;j<pos.size();j++){\n\tprintf(\"%3d\",dist[i][j]);\n      }\n      printf(\"\\n\");\n    }\n    */\n    //traveling salesman problem\n    vector<int> v(pos.size()-1);\n    int ans=100000;\n    for(int i=0;i<pos.size()-1;i++) v[i]=i+1;\n    do{\n      int tmp=dist[0][v[0]];\n      for(int i=0;i<pos.size()-2;i++){\n\ttmp+=dist[v[i]][v[i+1]];\n\tif(tmp>ans){\n\t  sort(&v[i+1],&v[pos.size()-2],greater<int>());\n\t  break;\n\t}\n      }\n      if(ans>tmp) ans=tmp;\n    }while(next_permutation(v.begin(),v.end()));\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nconst int INF = INT_MAX / 2;\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\n\nstruct Solver\n{\n\tconst int H, W;\n\tVS Board;\n\n\tSolver( int h, int w ) : H( h ), W( w )\n\t{\n\t\tBoard.resize( H );\n\t\tFOR( line, Board )\n\t\t{\n\t\t\tcin >> line;\n\t\t}\n\n\t\treturn;\n\t}\n\n\toperator int ()\n\t{\n\t\tvector<PII> posX;\n\t\tREP( i, 0, H )\n\t\t{\n\t\t\tREP( j, 0, W )\n\t\t\t{\n\t\t\t\tif ( Board[i][j] == 'o' )\n\t\t\t\t{\n\t\t\t\t\tposX.PB( MP( i, j ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP( i, 0, H )\n\t\t{\n\t\t\tREP( j, 0, W )\n\t\t\t{\n\t\t\t\tif ( Board[i][j] == '*' )\n\t\t\t\t{\n\t\t\t\t\tposX.PB( MP( i, j ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmap<PII,int> posToIdx;\n\t\tREP( i, 0, posX.size() )\n\t\t{\n\t\t\tposToIdx[ posX[i] ] = i;\n\t\t}\n\n\t\tconst int N = posX.size();\n\t\tVVI G( N, VI( N, INF ) );\n\t\tREP( i, 0, N )\n\t\t{\n\t\t\tG[i][i] = 0;\n\t\t}\n\n\t\tREP( i, 0, posX.size() )\n\t\t{\n\t\t\tmap<PII,int> dists( bfs( Board, posX[i] ) );\n\t\t\tFOR( dist, dists )\n\t\t\t{\n\t\t\t\tG[ posToIdx[ posX[i] ] ][ posToIdx[ dist.fst ] ] = dist.snd;\n\t\t\t}\n\t\t}\n\n\t\tVVI dp( 1 << N, VI( N, INF ) );\n\t\tdp[1][0] = 0;\n\n\t\tREP( mask, 0, 1 << N )\n\t\t{\n\t\t\tREP( i, 0, N )\n\t\t\t{\n\t\t\t\tREP( j, 0, N )\n\t\t\t\t{\n\t\t\t\t\tdp[ mask | 1 << j ][j] = min( dp[ mask | 1 << j ][j], dp[ mask ][i] + G[i][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = *min_element( ALL( dp[ ( 1 << N ) - 1 ] ) );\n\t\treturn res == INF ? -1 : res;\n\t}\n\n\tmap<PII,int> bfs( VS board, PII s )\n\t{\n\t\tVVI dist( H, VI( W, INF ) );\n\t\tdist[ s.fst ][ s.snd ] = 0;\n\n\t\tqueue<PII> que;\n\t\tque.push( s );\n\n\t\tmap<PII,int> res;\n\t\twhile ( !que.empty() )\n\t\t{\n\t\t\tPII cur = que.front();\n\t\t\tque.pop();\n\n\t\t\tif ( board[ cur.fst ][ cur.snd ] == 'x' )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( board[ cur.fst ][ cur.snd ] == '*' )\n\t\t\t{\n\t\t\t\tres[ cur ] = dist[ cur.fst ][ cur.snd ];\n\t\t\t}\n\n\t\t\tboard[ cur.fst ][ cur.snd ] = 'x';\n\n\t\t\tREP( d, 0, 4 )\n\t\t\t{\n\t\t\t\tPII next( cur );\n\t\t\t\tnext.fst += dy[d];\n\t\t\t\tnext.snd += dx[d];\n\n\t\t\t\tif ( !( 0 <= next.fst && next.fst < H && 0 <= next.snd && next.snd < W ) || board[ next.fst ][ next.snd ] == 'x' )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdist[ next.fst ][ next.snd ] = dist[ cur.fst ][ cur.snd ] + 1;\n\t\t\t\tque.push( next );\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint w, h;\n\t\tcin >> w >> h;\n\n\t\tif ( !( w | h ) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tcout << Solver( h, w ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, 1, 0, -1};\nint w, h;\nstring c[22];\nint dist[22][22];\n\nvector<pair<int, int>> G[22];\nvector<pair<int, int>> gomi;\n\n\nvoid solve(pair<int, int> s) {\n\trep(i, 22)rep(j, 22) dist[i][j] = INF;\n\tdist[s.fi][s.se] = 0;\n\tqueue<pair<int, int>> q;\n\tq.push(mp(s.fi, s.se));\n\twhile(!q.empty()){\n\t\tauto y = q.front().fi, x = q.front().se;\n\t\tq.pop();\n\t\trep(k, 4) {\n\t\t\tint ny = y + dy[k], nx = x + dx[k];\n\t\t\tif(!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\t\tif(dist[ny][nx] != INF) continue;\n\t\t\tif(c[ny][nx] == 'x') continue;\n\t\t\tdist[ny][nx] = dist[y][x] + 1;\n\t\t\tq.push(mp(ny, nx));\n\t\t}\n\t}\n}\n\n\nint dp[(1<<22)][22];\nvoid bitdp(int n, int sy, int sx) {\n\trep(i, (1<<n))rep(j, n) dp[i][j] = INF;\n\tsolve(make_pair(sy, sx));\n\trep(i, n){\n\t\tdp[(1<<i)][i] = dist[gomi[i].fi][gomi[i].se];\n\t}\n\n\tfor (int mask = 1; mask < (1<<n); ++mask) {\n\t\tfor (int u = 0; u < n; ++u) {\n\t\t\tfor (auto t : G[u]) {\n\t\t\t\tauto v = t.fi, cost = t.se;\n\t\t\t\tif(dp[mask][u] == INF) continue;\n\t\t\t\tif((mask & (1<<u)) == 0) continue;\n\t\t\t\tif((mask & (1<<v))) continue;\n\t\t\t\tchmin(dp[mask | (1<<v)][v], dp[mask][u] + cost);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(void) {\n\twhile(1) {\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tif(w == 0 && h == 0) break;\n\t\trep(i, h) cin >> c[i];\n\n\t\trep(i, 22) G[i].clear();\n\t\tgomi.clear();\n\t\t\n\t\trep(y, h)rep(x, w) if(c[y][x] == '*') gomi.pb(mp(y, x));\n\t\tint sy, sx;\n\t\trep(y, h) rep(x, w) if(c[y][x] == 'o') sy = y, sx = x;\n\t\tint n = gomi.size();\n\n\t\trep(i, gomi.size()) {\n\t\t\tauto u = gomi[i];\n\t\t\tsolve(u);\n\t\t\treps(j, i + 1, gomi.size()) {\n\t\t\t\tauto v = gomi[j];\n\t\t\t\tauto di = dist[v.fi][v.se];\n\t\t\t\tG[i].pb(mp(j, di)), G[j].pb(mp(i, di));\n\t\t\t}\n\t\t}\n\n\t\tbitdp(n, sy, sx);\n\t\tll ret = INF;\n\t\trep(i, n) chmin(ret, dp[(1<<n) - 1][i]);\n\t\tif(ret != INF) printf(\"%lld\\n\", ret);\n\t\telse printf(\"-1\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint d[] = { 0, 1, 0, -1, 0 };\nbool visited[20][20];\nint w, h;\nchar c[20][20];\n\nbool isin(int y, int x) {\n  return 0 <= y && y < h && 0 <= x && x < w;\n}\n\nvoid wfs(int sy, int sx, int* dist) {\n  queue<int> qy, qx, qd;\n\n  REP(i, 0, h) REP(j, 0, w) visited[i][j] = false;\n  visited[sy][sx] = true;\n  qy.push(sy), qx.push(sx), qd.push(0);\n\n  while(!qd.empty()) {\n    int cy = qy.front(), cx = qx.front(), cd = qd.front();\n    qy.pop(), qx.pop(), qd.pop();\n    if(c[cy][cx] == 'o') dist[0] = cd;\n    if(1 <= c[cy][cx] && c[cy][cx] <= 10) dist[c[cy][cx]] = cd;\n\n    REP(i, 0, 4) {\n      int ny = cy + d[i], nx = cx + d[i + 1], nd = cd + 1;\n      if(isin(ny, nx) && !visited[ny][nx] && c[cy][cx] != 'x') {\n        visited[ny][nx] = true;\n        qy.push(ny), qx.push(nx), qd.push(nd);\n      }\n    }\n  }\n}\n\nint main(void) {\n  while(cin >> w >> h, w != 0 && h != 0) {\n    int di = 1, sy, sx, dy[11], dx[11];\n    REP(i, 0, h) {\n      cin >> c[i];\n      REP(j, 0, w) {\n        if(c[i][j] == '*') {\n          c[i][j] = di;\n          dy[di] = i;\n          dx[di] = j;\n          di++;\n        }\n        if(c[i][j] == 'o') sy = i, sx = j;\n      }\n    }\n\n    int dist[11][11];\n    REP(i, 0, 11) REP(j, 0, 11) dist[i][j] = -1;\n\n    wfs(sy, sx, dist[0]);\n    bool possible = true;\n    REP(i, 1, di) if(dist[0][i] == -1) possible = false;\n\n    if(possible) {\n      REP(i, 1, di) wfs(dy[i], dx[i], dist[i]);\n\n      int ans = 100000;\n      int order[11] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n      do {\n        int move = dist[0][order[1]];\n        REP(i, 1, di - 1) move += dist[order[i]][order[i + 1]];\n        if(move > 0) ans = min(ans, move);\n      } while (next_permutation(order + 1, order + di));\n      cout << ans << endl;\n    } else {\n      cout << -1 << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int, int> P;\nchar tile[20][21];\nbool vis[20][21];\nint d[20][21];\nint dx[] = { 1,0,-1,0 };\nint dy[] = { 0,1,0,-1 };\nint w, h;\nint dist(int sx, int sy, int gx, int gy) {\n\tmemset(vis, 0, sizeof(vis));\n\tmemset(d, -1, sizeof(d));\n\tvis[sy][sx] = 1;\n\td[sy][sx] = 0;\n\tqueue<P> Q;\n\tQ.push(P(sx, sy));\n\twhile (!Q.empty()) {\n\t\tP p = Q.front(); Q.pop();\n\t\tint x = p.first, y = p.second;\n\t\tif (x == gx && y == gy) return d[gy][gx];\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (nx < 0 || nx >= w || ny < 0 || ny >= h||tile[ny][nx]=='x'||vis[ny][nx]) continue;\n\t\t\tvis[ny][nx] = 1;\n\t\t\td[ny][nx] = d[y][x] + 1;\n\t\t\tQ.push(P(nx, ny));\n\t\t}\n\t}\n\treturn -1;\n}\nint main() {\n\twhile (cin >> w >> h, w) {\n\t\tint sx, sy;\n\t\tvector<P> dirty;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tcin >> tile[i];\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (tile[i][j] == 'o') sx = j, sy = i;\n\t\t\t\telse if (tile[i][j] == '*') dirty.emplace_back(j, i);\n\t\t\t}\n\t\t}\n\t\tint perm[10];\n\t\tfor (int i = 0; i < dirty.size(); i++) perm[i] = i;\n\t\tint ans = 1 << 30;\n\t\tdo {\n\t\t\tint sum = 0;\n\t\t\tint x = sx, y = sy;\n\t\t\tbool ok = 1;\n\t\t\tfor (int i = 0; i < dirty.size(); i++) {\n\t\t\t\tint t = dist(x, y, dirty[perm[i]].first, dirty[perm[i]].second);\n\t\t\t\tif (t == -1) {\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsum += t;\n\t\t\t\tx = dirty[perm[i]].first;\n\t\t\t\ty = dirty[perm[i]].second;\n\t\t\t}\n\t\t\tif (!ok) continue;\n\t\t\tans = min(ans, sum);\n\t\t} while (next_permutation(perm, perm + dirty.size()));\n\t\tif (ans == 1 << 30) cout << -1 << endl;\n\t\telse cout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n\n#define ll long long int\n\nusing namespace std;\n\nconst int INF = (1<<25) - 1;\n\nvector<int> bfs(int s, vector<pair<int, int>> &dirtys, vector<string> &field){\n    int dh[] = {1, -1, 0, 0};\n    int dw[] = {0, 0, 1, -1};\n\n    int H = field.size(), W = field[0].size();\n    vector<vector<int>> d(H, vector<int>(W, INF));\n    pair<int, int> start = dirtys[s];\n    \n    queue<pair<int, int>> q;\n    d[start.first][start.second] = 0;\n    q.push(start);\n    while(!q.empty()){\n        pair<int, int> p = q.front(); q.pop();\n        for(int i=0; i<4; i++){\n            int nh = p.first + dh[i];\n            int nw = p.second + dw[i];\n            if(nh<0 || H<=nh || nw<0 || W<=nw || field[nh][nw]=='x' || d[nh][nw]!=INF)\n                continue;\n            d[nh][nw] = d[p.first][p.second] + 1;\n            q.push(make_pair(nh, nw));\n        }\n    }\n    \n    vector<int> res(dirtys.size());\n    for(int i=0; i<dirtys.size(); i++)\n        res[i] = d[dirtys[i].first][dirtys[i].second];\n    return res;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int W, H;\n    while(cin>>W>>H, W|H){\n        vector<string> field(H);\n        for(string &r: field)\n            cin >> r;\n        \n        //start???dirty??¨??????\n        vector<pair<int, int>> dirtys;\n        for(int i=0; i<H; i++)\n            for(int j=0; j<W; j++)\n                if(field[i][j] == 'o')\n                    dirtys.push_back(make_pair(i, j));\n                \n        for(int i=0; i<H; i++)\n            for(int j=0; j<W; j++)\n                if(field[i][j] == '*')\n                    dirtys.push_back(make_pair(i, j));\n        \n        vector<int> order(dirtys.size());\n        for(int i=0; i<dirtys.size(); i++)\n            order[i] = i;\n            \n        sort(order.begin()+1, order.end());\n        \n        vector<vector<int>> table(dirtys.size());\n        for(int i=0; i<dirtys.size(); i++)\n            table[i] = bfs(i, dirtys, field);\n        \n        int ans = INF;\n        do{\n            int tans = 0;\n            for(int i=0; i<order.size()-1; i++)\n                tans += table[order[i]][order[i+1]];\n            ans = min(ans, tans);\n        }while(next_permutation(order.begin(), order.end()));\n        \n        cout << (ans==INF ? -1 : ans) << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<int, int> P;\nint bfs(void);\nint INF=10000000;\nint w,h;\nint sx,sy;\nint dx[4]={-1,0,1,0};\nint dy[4]={0,1,0,-1};\nint d[100][100];\nchar mapp[100][100];\nint main(){\n  int kari;\n  while(1){\n    int yogore=0;\n    int ans=0;\n\n    cin>>w>>h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>mapp[i][j];\n\tif(mapp[i][j]=='*'){\n\t  yogore++;\n\t}else if(mapp[i][j]=='o'){\n\t  sy=i;\n\t  sx=j;\n\t}\n      }\n    }\n    for(int i=0;i<yogore;i++){\n      kari=bfs();\n      if(kari==0){\n\tans=-1;\n\tbreak;\n      }else{\n\tans+=kari;\n      }\n      \n    }\n    cout<<ans<<endl;\n  }\n}\nint bfs(void){\n  queue<P> que;\n  que.push(P(sy,sx));\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      d[i][j]=INF;\n    }\n  }\n  d[sy][sx]=0;\n  while(que.size()){\n    P p=que.front();\n    que.pop();\n    if(mapp[p.first][p.second]=='*'){\n      sy=p.first;\n      sx=p.second;\n      mapp[p.first][p.second]='.';\n      cout<<p.first<<' '<<p.second<<endl;\n      break;\n    }\n    for(int i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(0<=nx && nx<w && 0<=ny && ny<h && mapp[ny][nx]!='x' && d[ny][nx]==INF){\n\tque.push(P(ny,nx));\n\td[ny][nx]=d[p.first][p.second]+1;\n      }\n    }\n  }\n  return d[sy][sx];\n}\n\t\n    \n      "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){std::fill( (T*)array, (T*)(array+N), val );}\n\nusing edge=pair<int,int>;\nusing P=pair<int,pair<pair<int,int>,int>>;\n#define mp(i,j,k,l) make_pair((i),make_pair(make_pair((j),(k)),(l)))\n#define D first\n#define Y second.first.first\n#define X second.first.second\n#define C second.second\nconst int INF=1<<29;\nvector<edge> G={edge(-1,0),edge(0,1),edge(1,0),edge(0,-1)};\nint d[22][22][1024];\nint c[22][22];\nint w,h;\n\nvoid dijkstra(int y,int x,int cnt){\n  cnt-=1;\n  priority_queue<P,vector<P>,greater<P>> que;\n  Fill(d,INF);\n  d[y][x][0]=0;\n  que.push(mp(0,y,x,0));\n  while(!que.empty()){\n    P p=que.top();que.pop();\n    if(p.C==cnt){\n      cout<<p.D<<endl;\n      return;\n    }\n    if(d[p.Y][p.X][p.C]<p.D)continue;\n    for(edge e:G){\n      if(p.Y+e.first<0||p.X+e.second<0||p.Y+e.first>=h||p.X+e.second>=w)continue;\n      if(c[p.Y+e.first][p.X+e.second]==-1)continue;\n      if(d[p.Y+e.first][p.X+e.second][p.C|c[p.Y+e.first][p.X+e.second]]>d[p.Y][p.X][p.C]+1){\n\td[p.Y+e.first][p.X+e.second][p.C|c[p.Y+e.first][p.X+e.second]]=d[p.Y][p.X][p.C]+1;\n\tque.push(mp(d[p.Y+e.first][p.X+e.second][p.C|c[p.Y+e.first][p.X+e.second]],\n\t\t    p.Y+e.first,\n\t\t    p.X+e.second,\n\t\t    p.C|c[p.Y+e.first][p.X+e.second]));\n      }\n    }\n  }\n  cout<<-1<<endl;\n}\n\nint main(){ _;\n  while(cin>>w>>h,(w|h)){\n    int cnt=1,x,y;\n    char ch;\n    REP(i,h)REP(j,w){\n      cin>>ch;\n      if(ch=='x')c[i][j]=-1;\n      else if(ch!='*')c[i][j]=0;\n      else{\n\tc[i][j]=cnt;\n\tcnt<<=1;\n      }\n      if(ch=='o'){\n\ty=i;\n\tx=j;\n      }\n    }\n    dijkstra(y,x,cnt);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstruct P{\n\tint x,y;\n} s;\nint w, h;\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nint to[12][12];\nint cnt[21][21];\nstring f[21];\n\nvoid solve(int x, int y, int cnt_,int from ,vector<struct P>& vc){\n\t\n\tfor(int i=0 ; i<4 ; i++ ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ){\n\t\t\tcontinue;\n\t\t}else if( cnt[my][mx] == -1 ){\n\t\t\tcontinue;\n\t\t}else if( cnt[my][mx] > cnt_ ){\n\t\t\tcnt[my][mx] = cnt_;\n\t\t\tif( f[my][mx] == '.' ){\n\t\t\t\tsolve( mx , my , cnt_+1 , from , vc );\n\t\t\t}else if( f[my][mx] == '*' ){\n\t\t\t\tfor(int j=0 ; j < (int)vc.size() ; j++ ){\n\t\t\t\t\tif( vc[j].x == mx && vc[j].y == my ){\n\t\t\t\t\t\tto[from][j+1] = cnt_;\n\t\t\t\t\t\tto[j+1][from] = cnt_;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\nvoid debug(int x,int y,char c){\n\tcout << c << \":(x,y) = (\" << x << \",\" << y << \")\\n\";\n}*/\n\nint main(){\n\twhile( cin >> w >> h , w||h ){\n\t\tvector<struct P> vc;\n\t\tfor(int y=0 ; y<12 ; y++ ){\n\t\t\tfor(int x=0 ; x<12 ; x++ ){\n\t\t\t\tto[y][x] = 1000;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> f[y];\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tif( f[y][x] == 'o' ){\n\t\t\t\t\tcnt[y][x] = -1;\n\t\t\t\t\ts.x = x, s.y = y;\n\t\t\t\t}else if( f[y][x] == '*' ){\n\t\t\t\t\tstruct P p;\n\t\t\t\t\tp.x = x, p.y = y;\n\t\t\t\t\tvc.push_back( p );\t\t\t\t\n\t\t\t\t}else if( f[y][x] == 'x' ){\n\t\t\t\t\tcnt[y][x] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i <= (int)vc.size() ; i++ ){\n\t\t\tfor(int y=0 ; y<21 ; y++ )\n\t\t\t\tfor(int x=0 ; x<21 ; x++ )\n\t\t\t\t\tif( cnt[y][x] != -1 )\n\t\t\t\t\t\tcnt[y][x] = 1000;\n\t\t\tif( i > 0 ){\n\t\t\t\tcnt[ vc[i-1].y ][ vc[i-1].x ] = -1;\n\t\t\t\tsolve( vc[i-1].x , vc[i-1].y , 1 , i , vc );\n\t\t\t}else{\n\t\t\t\tsolve( s.x , s.y , 1 , i , vc );\n\t\t\t}\n\t\t}\n\n\t\tvector<int> vc_;\n\t\tbool flag = true;\n\t\tint ans = 10000000;\n\t\tfor(int i=0 ; i < (int)vc.size() ; i++ )\n\t\t\tvc_.push_back( i+1 );\n\t\tdo{\n\t\t\tint ans_ = 0;\n\t\t\tfor(int i=0 ; i < (int)vc_.size() ; i++ ){\n\t\t\t\t//cout << \"+ : \" << to[ ((i==0)? 0 : vc_[i-1]) ][ vc_[i] ] << \" \";\n\t\t\t\tif( to[ ((i==0)? 0 : vc_[i-1]) ][ vc_[i] ] == 1000 ){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tans_ += to[ ((i==0)? 0 : vc_[i-1]) ][ vc_[i] ];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = min( ans_ , ans );\n\t\t}while( next_permutation( vc_.begin() , vc_.end() ) && flag );\n\t\t//cout << endl;\n\t\t\n\t\t/*debug( s.x , s.y , 'S' );\n\t\tfor(int i=0 ; i < (int)vc.size() ; i++ ){\n\t\t\tdebug( vc[i].x , vc[i].y , i+'0' );\n\t\t\t//cout << \"start => \" << to[0][i+1] << endl;\n\t\t}\n\t\tfor(int y=0 ; y <= (int)vc.size() ; y++ ){\n\t\t\tfor(int x=0 ; x <= (int)vc.size() ; x++ ){\n\t\t\t\tcout << to[y][x] << \"  \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tcout << ( (flag)? ans : -1 ) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <utility>\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(it,c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); ++it)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\ntypedef pair<int, int> P;\nostream& operator<<(ostream& os, const P& p) {\n    os << \"(y,x) = \" << '(' << p.first << ',' << p.second << ')';\n    return os;\n}\n\nconst int INF = (int)1e9;\n\nint dist[11][11];\nmap<int, int> memo;\n\n// current vertex, bitmask, number of vertex\nint tsp(int v, int b, int N) {\n    if(memo.count(b)) return memo[b];\n    if(b == (1 << N) - 1) return 0;\n    int res = INF;\n    for(int i = 0; i < N; i++) {\n        if(b & (1 << i)) continue;\n        res = min(res, dist[v][i] + tsp(i, b | (1 << i), N));\n    }\n    return memo[b] = res;\n}\n\nint main() {\n    while(true) {\n        int W, H; cin >> W >> H;\n        if(W + H == 0) break;\n        vector<string> inp;\n        REP(i,H) {\n            string s; cin >> s;\n            inp.push_back(s);\n        }\n\n        // y,x\n        vector<P> dst;\n        REP(y,H) REP(x,W) {\n            if(inp[y][x] == 'o') {\n                dst.push_back(P(y,x));\n                inp[y][x] = '.';\n            }\n        }\n\n        REP(y,H) REP(x,W) {\n            if(inp[y][x] == '*') {\n                dst.push_back(P(y,x));\n                inp[y][x] = '.';\n            }\n        }\n\n        REP(i,dst.size()) REP(j,dst.size()) dist[i][j] = INF;\n\n        REP(i,dst.size()) {\n            const int dy[4] = { 0, 1, 0, -1 };\n            const int dx[4] = { 1, 0, -1, 0 };\n\n            static bool vis[20][20];\n            REP(y,H) REP(x,W) vis[y][x] = false;\n\n            static int D[20][20];\n            REP(y,H) REP(x,W) D[y][x] = INF;\n\n            queue<P> Q;\n            Q.push(dst[i]);\n\n            vis[dst[i].first][dst[i].second] = true;\n            D[dst[i].first][dst[i].second] = 0;\n\n            while(!Q.empty()) {\n                P p = Q.front(); Q.pop();\n                REP(j,4) {\n                    int ny = p.first + dy[j];\n                    int nx = p.second + dx[j];\n                    if(0 <= nx && nx < W && 0 <= ny && ny < H && inp[ny][nx] != 'x' && vis[ny][nx] == false) {\n                        vis[ny][nx] = true;\n                        D[ny][nx] = D[p.first][p.second] + 1;\n                        Q.push(P(ny,nx));\n                    }\n                }\n            }\n            REP(j,dst.size()) {\n                dist[i][j] = D[dst[j].first][dst[j].second];\n            }\n        }\n\n#if 0\n        REP(i,dst.size()) REP(j,dst.size()) {\n            DEBUG(dst[i]);\n            DEBUG(dst[j]);\n            DEBUG(dist[i][j]);\n        }\n#endif\n        \n        bool valid = true;\n        for(int i = 1; i < dst.size(); i++) {\n            if(dist[0][i] >= INF) {\n                valid = false;\n                break;\n            }\n        }\n        if(valid == false) {\n            cout << -1 << endl;\n            continue;\n        }\n\n        memo.clear();\n        int ans = tsp(0, 1, dst.size());\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int> p;\n\nchar m[21][21];\nint n,w,h,gx[11],gy[11],d[21][21],dx[]={1,0,-1,0},dy[]={0,1,0,-1},D[11][11],dp[1<<11][11];\n\nvoid bfs(int N){\n\tqueue<p> q;\n\trep(i,h)rep(j,w)d[i][j]=INF;\n\tq.push(p(gx[N],gy[N]));\n\td[gy[N]][gx[N]]=0;\n\twhile(!q.empty()){\n\t\tp c=q.front();q.pop();\n\t\trep(i,n)if(c.first==gx[i]&&c.second==gy[i]){D[N][i]=d[gy[i]][gx[i]];}\n\t\trep(i,4){\n\t\t\tint nx=c.first+dx[i],ny=c.second+dy[i];\n\t\t\tif(nx>=0&&nx<w&&ny>=0&&ny<h&&m[ny][nx]!='x'&&d[ny][nx]==INF){\n\t\t\t\tq.push(p(nx,ny));\n\t\t\t\td[ny][nx]=d[c.second][c.first]+1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>w>>h&&w){\n\t\tn=1;\n\t\trep(i,11)fill(D[i],D[i]+11,INF);\n\t\trep(i,h)rep(j,w){\n\t\t\tcin>>m[i][j];\n\t\t\tif(m[i][j]=='o'){gx[0]=j;gy[0]=i;}\n\t\t\tif(m[i][j]=='*'){gx[n]=j;gy[n++]=i;}\n\t\t}\n\t\trep(i,n)bfs(i);\n\t\trep(s,1<<n)fill(dp[s],dp[s]+n,INF);\n\t\trep(i,n)dp[(1<<n)-2][i]=0;\n\t\tfor(int s=(1<<n)-2;s>=0;s--)rep(v,n)rep(u,n)if(!(s>>u&1))dp[s][v]=min(dp[s][v],dp[s|1<<u][u]+D[v][u]);\n\t\tcout<<(dp[0][0]!=INF?dp[0][0]:-1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) begin(v), end(v)\n#define REV(v) rbegin(v), rend(v)\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef long long ll;\n\nstring field[20];\nint id[20][20];\nint dist[11][11];\nint vis[20][20];\n\nconst int dx[] = { -1, 0, 1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\n\nint dp[11][1<<11];\nint n;\nint rec(int pos, int visit){\n\tif (visit + 1 == 1 << n) return 0;\n\n\tint &res = dp[pos][visit];\n\tif (res >= 0) return res;\n\n\tres = 1<<30;\n\tfor (int i = 1; i < n; ++i){\n\t\tif (visit&(1 << i)) continue;\n\t\tres = min(res, dist[pos][i] + rec(i, visit | (1 << i)));\n\t}\n\n\treturn res;\n}\n\nint main(){\n\tint w, h;\n\twhile (cin >> w >> h, w){\n\t\tvector<string> v(h);\n\t\trep(i, h) cin >> v[i];\n\n\t\tMEMSET(id, -1);\n\t\tn = 1;\n\t\trep(i, h) rep(j, w){\n\t\t\tif (v[i][j] == 'o') id[i][j] = 0, v[i][j] = '*';\n\t\t\telse if (v[i][j] == '*') id[i][j] = n++;\n\t\t}\n\t\tMEMSET(dist, -1);\n\t\trep(i, h) rep(j, w){\n\t\t\tif (v[i][j] != '*') continue;\n\t\t\tP pos = MP(j, i);\n\t\t\tqueue<tuple<int, int, int>> q;\n\t\t\tq.push(MT(j, i, 0));\n\t\t\tMEMSET(vis, 0);\n\t\t\tvis[i][j] = 1;\n\t\t\twhile (!q.empty()){\n\t\t\t\tint x, y, d;\n\t\t\t\ttie(x, y, d) = q.front();\n\t\t\t\tq.pop();\n\n\t\t\t\tif (id[y][x] >= 0) dist[id[i][j]][id[y][x]] = d;\n\n\t\t\t\trep(dir, 4){\n\t\t\t\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\t\t\t\tif (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\t\t\tif (v[ny][nx] == 'x') continue;\n\t\t\t\t\tif (vis[ny][nx]) continue;\n\t\t\t\t\tvis[ny][nx] = 1;\n\t\t\t\t\tq.push(MT(nx, ny, d + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(i, n) rep(j, n){\n\t\t\tif (dist[i][j] < 0) goto NG;\n\t\t}\n\n\t\tMEMSET(dp, -1);\n\t\tcout << rec(0, 1) << endl;\n\n\t\tcontinue;\n\tNG:\n\t\tcout << -1 << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#define MAX_H 20\n#define MAX_W 20\n#define MAX_G 10\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\n\nstruct S {\n    int y, x, t;\n    S(int y, int x, int t) : y(y), x(x), t(t) {}\n};\n\n#define INF (1<<28)\n\nstring field[MAX_H];\nint number[MAX_H][MAX_W];\nint graph[MAX_G][MAX_G];\nint dp[MAX_G][1<<MAX_G]; \nint h, w;\nint garbage_count;\n\nint solve(int v, int s) {\n    if (dp[v][s] != INF) return dp[v][s];\n    if (s == ((1<<garbage_count)-1)) return 0;\n    int min_cost = INF;\n    for (int i = 0; i < garbage_count; i++) {\n        if (s & (1<<i)) continue;\n        min_cost = min(min_cost, solve(i, (s + (1<<i))) + graph[v][i]);\n    }\n    return dp[v][s] = min_cost;\n}\n\nint main() {\n    while (cin >> w >> h) {\n        if (w == 0 && h == 0) break;\n        memset(graph, -1, sizeof(graph));\n        memset(number, -1, sizeof(number));\n        for (int i = 0; i < MAX_G; i++) for (int j = 0; j < (1<<MAX_G); j++) dp[i][j] = INF;\n        for (int i = 0; i < h; i++) \n            cin >> field[i];\n        \n        int cur = 1;\n        for (int i = 0; i < h; i++) \n            for (int j = 0; j < w; j++) {\n                if (field[i][j] == 'o') number[i][j] = 0;\n                if (field[i][j] == '*') number[i][j] = cur++;\n            }\n        garbage_count = cur;\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (field[i][j] == 'o' || field[i][j] == '*') {\n                    bool visited[h][w]; memset(visited, 0, sizeof(visited));\n                    queue<S> q;\n                    q.push(S(i, j, 0)); visited[i][j] = true;\n                    int remain_garbage = garbage_count;\n                    while (!q.empty()) {\n                        S s = q.front(); q.pop();\n                        if (field[s.y][s.x] == 'o' || field[s.y][s.x] == '*') {\n                            graph[number[i][j]][number[s.y][s.x]] = s.t;\n                            remain_garbage--;\n                            //if (remain_garbage == 0) break;\n                        }\n                        for (int k = 0; k < 4; k++) {\n                            int ny = s.y + dy[k];\n                            int nx = s.x + dx[k];\n                            if (0 <= ny && ny < h && 0 <= nx && nx < w && !visited[ny][nx] && field[ny][nx] != 'x') {\n                                visited[ny][nx] = true;\n                                q.push(S(ny, nx, s.t+1));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        bool possible = true;\n        for (int i = 0; i < garbage_count; i++) \n            for (int j = 0; j < garbage_count; j++) \n                if (graph[i][j] == -1) {\n                    possible = false;\n                    break;\n                }\n\n//        for (int i = 0; i < garbage_count; i++) {\n//            for (int j = 0; j < garbage_count; j++) {\n//                cout << graph[i][j] << ' ';\n//            }\n//            cout << endl;\n//        }\n\n        if (!possible) cout << -1 << endl;\n        else cout << solve(0, 0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int,int> P;\nint W,H;\nint dx[4] = {-1,1,0,0},dy[4] = {0,0,-1,1};\nint dist[12][12] = {},inf = 1e5;\nint visited[21][21] = {};\nint A[11] = {1,2,3,4,5,6,7,8,9,10,11};\nchar F[21][21];\n\n\nbool in(int x,int y){\n    return 1<=x && x<=H && 1<=y && y<=W;\n}\n\nint main(){\n    while(cin >> W >> H && W>0){\n        int id = 1;\n        map<P,int> m;\n        for(int i=1;i<=H;i++){\n            for(int j=1;j<=W;j++){\n                cin >> F[i][j];\n                if(F[i][j]=='*'){\n                    m[{i,j}] = id+1;\n                    id++;\n                }\n                if(F[i][j]=='o') m[{i,j}] = 1;\n            }\n        }\n        for(int i=1;i<=id;i++) for(int j=1;j<=id;j++){dist[i][j] = inf; dist[j][i] = inf;}\n        for(auto a:m){\n            queue<P> Q;\n            for(int i=1;i<=H;i++) for(int j=1;j<=W;j++) visited[i][j] = inf;\n            Q.push(a.first);\n            visited[a.first.first][a.first.second] = 0;\n            while(!Q.empty()){\n                int x = Q.front().first,y = Q.front().second;\n                Q.pop();\n                for(int i=0;i<4;i++){\n                    int nx = x+dx[i],ny = y+dy[i];\n                    if(in(nx,ny)&&visited[nx][ny]==inf&&F[nx][ny]!='x'){\n                        visited[nx][ny] = visited[x][y]+1;\n                        Q.push({nx,ny});\n                    }\n                }\n            }\n            for(auto b:m){\n                if(a!=b) dist[a.second][b.second] = visited[b.first.first][b.first.second];\n            }\n        }\n        int ans = inf;\n        do{\n            int now = 0;\n            for(int i=0;i<id;i++){\n                now += dist[A[i]][A[i+1]];\n            }\n            ans = min(ans,now);\n        }while(next_permutation(A+1,A+id));\n        cout << (ans!=inf? ans:-1) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n// using namespace std;\n\n#define fst(t) std::get<0>(t)\n#define snd(t) std::get<1>(t)\n#define thd(t) std::get<2>(t)\n\nusing ll = long long;\nusing P = std::tuple<int,int>;\n\nconst int dx[8] = {-1, 1, 0, 0, -1, -1, 1, 1}, dy[8] = {0, 0, -1, 1, -1, 1, -1, 1};\n\nint W, H;\nstd::string map[50];\nint Xs[15], Ys[15];\nint dist[15][15], d[50][50], dp[12][1<<12];\n\nvoid generateMap(int x0, int y0){\n    std::queue<P> qu;\n    qu.emplace(x0, y0);\n\n    std::fill(&d[0][0], &d[0][0]+50*50, 1001001001);\n    d[x0][y0] = 0;\n    \n    while(!qu.empty()){\n        int x, y;\n        std::tie(x, y) = qu.front();\n        qu.pop();\n\n        for(int i=0;i<4;++i){\n            int nx = x + dx[i], ny = y + dy[i];\n            if(0 <= nx && nx < W &&\n               0 <= ny && ny < H &&\n               map[ny][nx] != 'x' &&\n               d[nx][ny] > d[x][y] + 1){\n                d[nx][ny] = d[x][y] + 1;\n                qu.emplace(nx, ny);\n            }\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n    \n    std::cin >> W >> H;\n\n    int ast_idx = 1;\n    \n    for(int i=0;i<H;++i){\n        std::cin >> map[i];\n\n        for(int j=0;j<W;++j){\n            if(map[i][j] == 'o'){\n                Xs[0] = j;\n                Ys[0] = i;\n            }else if(map[i][j] == '*'){\n                Xs[ast_idx] = j;\n                Ys[ast_idx++] = i;\n            }\n        }\n    }\n\n    for(int i=0;i<ast_idx;++i){\n        generateMap(Xs[i], Ys[i]);\n\n        // printf(\"# %d\\n\", i);\n        // for(int j=0;j<H;++j){\n        //     for(int k=0;k<W;++k){\n        //         printf(\"%2d%c\", d[k][j], \" \\n\"[k+1==W]);\n        //     }\n        // }\n        \n        for(int j=0;j<ast_idx;++j){\n            dist[i][j] = d[Xs[j]][Ys[j]];\n        }\n    }\n\n    std::fill(&dp[0][0], &dp[0][0]+12*(1<<12), 1001001001);\n    dp[0][1] = 0;\n\n    for(int i=0;i<(1<<ast_idx);++i){\n        for(int j=0;j<ast_idx;++j){\n            for(int k=0;k<ast_idx;++k){\n                dp[k][i | (1 << k)]\n                    = std::min(dp[k][i | (1 << k)],\n                               dp[j][i] + dist[j][k]);\n            }\n        }\n    }\n\n    int res = 1001001001;\n    for(int i=0;i<ast_idx;++i){\n        res = std::min(res, dp[i][(1<<ast_idx)-1]);\n    }\n\n    if(res == 1001001001){res = -1;}\n    printf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint w, h;\nvector<string> tile(20);\nint dist[11][11];\nbool visited[20][20];\nint dd[] = {1, 0, -1, 0, 1};\n\nbool range(int x, int y) {\n  return 0 <= x && x < w && 0 <= y && y < h;\n}\n\nvoid wfs(PIP s, vector<PIP> &v) {\n  rep(i, h)rep(j, w) visited[i][j] = false;\n  visited[s.se.fi][s.se.se] = true;\n\n  priority_queue<PIP, vector<PIP>, greater<PIP>> q;\n  q.push(PIP(0, s.se));\n\n  while(!q.empty()) {\n    PIP p = q.top(); q.pop();\n\n    repl(i, 1, v.size()) {\n      if (p.fi > 0 && p.se == v[i].se) dist[s.fi][i] = p.fi;\n    }\n\n    rep(i, 4) {\n      int y = p.se.fi + dd[i], x = p.se.se + dd[i + 1];\n      if (range(x, y) && !visited[y][x] && tile[y][x] != 'x') {\n        q.push(PIP(p.fi + 1, P(y, x)));\n        visited[y][x] = true;\n      }\n    }\n  }\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  while(cin >> w >> h, w | h) {\n    vector<PIP> v;\n    int num = 1;\n    rep(i, h) {\n      cin >> tile[i];\n      rep(j, w) {\n        if (tile[i][j] == '*') v.pb(PIP(num++, P(i, j)));\n        else if (tile[i][j] == 'o') v.pb(PIP(0, P(i, j)));\n      }\n    }\n    sort(all(v));\n\n    int size = v.size();\n    rep(i, size)rep(j, size) dist[i][j] = INF;\n\n    bool ok = true;\n    rep(i, size) {\n      wfs(v[i], v);\n      if (i == 0) {\n        repl(j, 1, size) if (dist[0][j] == INF) ok = false;\n        if (!ok) break;\n      }\n    }\n\n    if (ok) {\n      vector<int> dp(1 << (size - 1), INF);\n      repl(i, 1, size) dp[(1 << i - 1)] = dist[0][i];\n\n      rep(i, 1 << (size - 1)) {\n        repl(j, 1, size) {\n          if (i & (1 << j - 1)) {\n            repl(k, 1, size) {\n              if (!(i & (1 << k - 1))) minch(dp[i + (1 << k - 1)], dp[i] + dist[j][k]);\n            }\n          }\n        }\n      }\n\n      cout << dp[dp.size() - 1] << endl;\n    } else {\n      cout << -1 << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#define INF 1<<30\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h;\nchar cmap[30][30];\nint imap[30][30];\nint bfsd[60][60];\nint d[60][60];\nint dd[60];\nbool ddused[60];\nP pointUsed[60];\nint Iindex;\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,1,0,-1};\nint counter;\nint ssx,ssy;\nint sindex;\n \nvoid bfs(int sf,int ss){\n  queue<P> que;\n  que.push(P(sf,ss));\n  for(int i=0;i<h;i++)for(int j=0;j<w;j++)bfsd[i][j]=INF;\n  bfsd[ss][sf]=0;\n \n  while(que.size()){\n    P p = que.front(); que.pop();\n \n    for(int i=0;i<4;i++){\n      int nx = p.first + dx[i],ny = p.second + dy[i];\n      if(0<= nx && nx < w && 0<= ny && ny < h && bfsd[ny][nx] == INF && cmap[ny][nx] != 'x'){\n    bfsd[ny][nx] = bfsd[p.second][p.first]+1;\n    que.push(P(nx,ny));\n    if(cmap[ny][nx] == '*' || cmap[ny][nx] == 'o'){\n      counter++;\n      //cout << imap[ss][sf]+50 << \"  \" << imap[ny][nx]+50 << endl;\n      d[ imap[ss][sf]+50 ][ imap[ny][nx]+50 ] = bfsd[ny][nx];\n      d[ imap[ny][nx]+50 ][ imap[ss][sf]+50 ] = bfsd[ny][nx];\n    }\n \n      }\n \n    }\n \n \n \n  }\n \n}\n \n \n \n \nint main(){\n  int sx,sy;\n  int dirtyIndex;\n  P dirtyPoint[500]; //let first be x and second be y\n  while(true){\n    cin >> w >> h;\n    if(w + h == 0)break;\n    \n    Iindex=0;\n    dirtyIndex=-50;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n    cin >> cmap[i][j];\n    switch(cmap[i][j]){\n    case '.':\n      imap[i][j]=0;\n      break;\n    case 'o':\n      imap[i][j]=dirtyIndex;\n      dirtyIndex++;\n      pointUsed[Iindex] = P(j,i);\n      sindex=Iindex;\n      ++Iindex;\n      sy=i;\n      sx=j;\n      ssx = sx;\n      ssy = sy;\n      break;\n    case '*':\n      dirtyPoint[Iindex].first = j;\n      dirtyPoint[Iindex].second = i;\n      imap[i][j] = dirtyIndex;\n      dirtyIndex++;\n      pointUsed[Iindex] = P(j,i);\n      ++Iindex;\n      break;\n    case 'x':\n      imap[i][j]=-1;\n      break;\n    default:\n      break;\n    }\n      }\n    }\n    bool fin=false;\n    for(int i=0;i<Iindex;i++){\n      counter=1;\n      bfs(pointUsed[i].first,pointUsed[i].second);\n      if(i == 0 && counter != Iindex){\n    cout << \"-1\" << endl;\n      fin=true;\n      break;\n      }\n \n    }\n \n    if(fin)continue;\n    \n   \n    int dp[1<<Iindex][Iindex];\n    \n    for(int S=0;S< (1<<Iindex);S++){\n      for(int i=0;i<=Iindex+1;i++)dp[S][i] = INF;\n    }\n    dp[(1<<Iindex)-1][0] = 0;\n    for(int S = (1<<Iindex)-2;S>=0;S--){\n      for(int v=0;v<Iindex;v++){\n    for(int u=0;u<Iindex;u++){\n      if(!(S>>u & 1)){\n        dp[S][v] = min(dp[S][v],dp[S|1<<u][u] + d[v][u]);\n      }\n    }\n      }\n    }\n    \n    int Kotae=INF;\n    for(int i=0;i<Iindex;i++)if(Kotae > dp[0][i])Kotae = dp[1<<i][i];\n    cout << Kotae << endl;\n    \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 20\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\nint w,h,num[N*N+N],idlen,sid,ans;\nstring s[N];\nvector<int> id;\nvector<P> edge[11];\n\nint bfs(int sy,int sx,int gy,int gx){\n  int d[N][N];\n  int dy[4]={-1,0,1,0};\n  int dx[4]={0,1,0,-1};\n  queue<P1> q;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)d[i][j]=INF;\n  d[sy][sx]=0;\n  q.push(P1(0,P(sy,sx)));\n  while(!q.empty()){\n    P1 t=q.front(); q.pop();\n    int c=t.first;\n    int y=t.second.first,x=t.second.second;\n    if(d[y][x]<c)continue;\n    for(int i=0;i<4;i++){\n      int ny=y+dy[i],nx=x+dx[i];\n      if(ny<0||nx<0||h<=ny||w<=nx)continue;\n      if(s[ny][nx]=='x')continue;\n      if(d[ny][nx]>c+1){\n\td[ny][nx]=c+1;\n\tq.push(P1(d[ny][nx],P(ny,nx)));\n      }\n    }\n  }\n  return d[gy][gx];\n}\n\nint dijkstra(){\n  int d[(1<<idlen)];\n  priority_queue<P1> q;\n  for(int i=0;i<(1<<idlen);i++)d[i]=INF;\n  d[(1<<sid)]=0;\n  q.push(P1(0,P((1<<sid),sid)));\n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    int S=t.second.first;\n    int c=t.first,u=t.second.second;\n    //    if(d[S]<c)continue;\n    for(int i=0;i<edge[u].size();i++){\n      int nu=edge[u][i].first;\n      int nc=edge[u][i].second;\n      if((S&(1<<nu)))continue;\n      if(d[(S|(1<<nu))]>c+nc){\n\td[(S|(1<<nu))]=c+nc;\n\tq.push(P1(c+nc,P((S|(1<<nu)),nu)));\n      }\n    }\n  }\n  return d[(1<<idlen)-1];\n}\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h)break;\n    for(int i=0;i<h;i++){\n      cin>>s[i];\n      for(int j=0;j<w;j++){\n\tif(s[i][j]=='.'||s[i][j]=='x')continue;\n\tif(s[i][j]=='o')sid=id.size();\n\tid.push_back(w*i+j);\n      }\n    }\n    idlen=id.size();\n    for(int i=0;i<idlen;i++)\n      for(int j=0;j<idlen;j++){\n\tif(i==j)continue;\n\tint y1=id[i]/w,x1=id[i]%w;\n\tint y2=id[j]/w,x2=id[j]%w;\n\tint d=bfs(y1,x1,y2,x2);\n\tedge[i].push_back(P(j,d));\n\tedge[j].push_back(P(i,d));\n      }\n    ans=dijkstra();\n    if(ans!=INF)cout<<ans<<endl;\n    else cout<<-1<<endl;\n    id.clear();\n    for(int i=0;i<11;i++)edge[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<limits.h>\n#define INF 10000000\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h;\nint imap[21][21];\nint djd[20][2]; // 0->x ,1->y\nint mmaapp[20][20];\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\nint bfs(int sp,int gp){\n  int mmap[21][21];\n \n  for(int i=0;i<21;i++)for(int j=0;j<21;j++)mmap[i][j] = INF;\n  queue<P> que;\n  que.push(P(djd[sp][0],djd[sp][1]));\n  mmap[djd[sp][1]][djd[sp][0]]=0;\n\n  while(que.size()){\n    P p = que.front();que.pop();\n\n    if(p.first == djd[gp][0] && p.second == djd[gp][1])return mmap[djd[gp][1]][djd[gp][0]];\n\n    for(int i=0;i<4;i++){\n      int nx = p.first+dx[i],ny = p.second+dy[i];\n      if(0<=nx && nx < w && 0<=ny && ny < h && mmap[ny][nx] == INF && imap[ny][nx] != -1){\n\tque.push(P(nx,ny));\n\tmmap[ny][nx] = mmap[p.second][p.first] + 1;\n      }\n    }\n  }\n}\n\n\n\nint main(){\n  char in;\n  int count;\n  while(true){\n    cin >> w >> h;\n    if(w+h == 0)break;\n    count=1;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> in;\n\tswitch(in){\n\tcase '.':\n\t  imap[i][j]=0;\n\t  break;\n\tcase 'o':\n\t  imap[i][j]=0;\n\t  djd[0][0]=j;\n\t  djd[0][1]=i;\n\t  break;\n\tcase 'x':\n\t  imap[i][j]=-1;\n\t  break;\n\tcase '*':\n\t  imap[i][j]=0;\n\t  djd[count][0]=j;\n\t  djd[count][1]=i;\n\t  count++;\n\t  break;\n\tdefault:\n\t  cout << \"erro\" << endl; \n\t  break;\n\t}\n      }\n    }\n\n    for(int i=0;i<count;i++){\n      for(int j=0;j<count;j++){\n\tmmaapp[i][j] = bfs(i,j);\n\t//\tcout << mmaapp[i][j] << \" \";\n      }\n      //      cout << endl;\n    }\n\n\n\n    int dp[(1<<count)+2][count+2];\n    rep(i,(1<<count)+2)rep(j,count+2)dp[i][j]=INF;\n    dp[(1<<count)-1][0]=0;\n\n    for(int S=(1<<count)-2;S>=0;S--){\n      for(int v=0;v<count;v++){\n\tfor(int u=0;u<count;u++){\n\t  if(!(S>>u & 1)){\n\t    dp[S][v]=min(dp[S][v],dp[S| 1<<u][u] + mmaapp[v][u]);\n\t  }\n\t}\n      }\n    }\n    int ans=INF;\n    for(int i=0;i<count;i++){\n      ans = min(ans,dp[(1<<i)][i]);\n    }\n\n    if(ans < 0)cout << \"-1\" << endl;\n    else cout << ans << endl;\n\n\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nSS ss;\n#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nint w,h;\nstring c[30];\nvpint vp;\nint dis[20][20];\n\nint d(int i,int j){\n\tint d[30][30];\n\trep(a,30)rep(b,30)d[a][b]=INF;\n\tpriority_queue<pair<int,pint>,vector<pair<int,pint> >,greater<pair<int,pint> > > que;\n\tque.push(MP(0,MP(vp[i].first,vp[i].second)));\n\twhile(!que.empty()){\n\t\tpair<int,pint> now=que.top();\n\t\tque.pop();\n\t\tint x=now.second.second;\n\t\tint y=now.second.first;\n//cout<<x<<\" \"<<y<<\" \"<<now.first<<endl;\n\t\tif(x<0)continue;\n\t\tif(x>=w)continue;\n\t\tif(y<0)continue;\n\t\tif(y>=h)continue;\n\t\tif(d[y][x]<=now.first)continue;\n\t\tif(c[y][x]=='x')continue;\n\t\td[y][x]=now.first;\n\t\trep(k,4){\n//cout<<now.first+1<<\" \"<<y+dy[k]<<\" \"<<x+dx[k]<<endl;\n\t\t\tque.push(MP(now.first+1,MP(y+dy[k],x+dx[k])));\n\t\t}\n\t}\n//PUTLINE\n\treturn d[vp[j].first][vp[j].second];\n}\n\nint main() {\n\tIL{\n\t\tcin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\trep(i,h)cin>>c[i];\n\t\tvp.clear();\n\t\trep(i,h)rep(j,w)if(c[i][j]=='o')vp.PB(MP(i,j));\n\t\trep(i,h)rep(j,w)if(c[i][j]=='*')vp.PB(MP(i,j));\n\t\tint n=sz(vp)-1;\n\t\trep(i,n+1)rep(j,n+1){\n\t\t\tdis[i][j]=d(i,j);\n//debug<<i<<\" \"<<j<<\" \"<<dis[i][j]<<endl;\n\t\t}\n\t\tvint per;\n\t\trep(i,n)per.PB(i+1);\n\t\tint res=INF;\n\t\tdo{\n//PUTLINE\n//debug<<n<<endl;\n\t\t\tint m=dis[0][per[0]];\n\t\t\tif(m==INF)continue;\n\t\t\tint i;\n\t\t\trep0(i,n-1){\n\t\t\t\tif(dis[per[i]][per[i+1]]==INF)break;\n\t\t\t\tm+=dis[per[i]][per[i+1]];\n\t\t\t}\n\t\t\tif(i<n-1)continue;\n\t\t\tchmin(res,m);\n\t\t}while(next_permutation(all(per)));\n\t\tif(res<INF)cout<<res<<endl;\n\t\telse cout<<-1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Point {\n  int y;\n  int x;\n  int cost;\n  Point() {;}\n  Point(int y1, int x1, int c) : y(y1), x(x1), cost(c) {;}\n};\n\nint width;\nint height;\n\nchar str[100];\nchar tile[30][30];\nint dist[11][10];\nint dirty_y[10];\nint dirty_x[10];\nint map[30][30];\nbool check[30][30];\nint dirty_tile;\nint memo[1024][10];\n\nint calc(int depth, int visit, int where) {\n  if (memo[visit][where] != -1) { return memo[visit][where]; }\n  if (depth == dirty_tile) { return 0; }\n  int ret = 0x0f0f0f0f;\n  for (int i = 0; i < dirty_tile; i++) {\n    if (visit & (1 << i)) { continue; }\n    int next_visit = visit | (1 << i);\n    ret = min(ret, calc(depth + 1, next_visit, i) + dist[where][i]);\n  }\n  return memo[visit][where] = ret;\n}\n\nint main() {\n  while (scanf(\"%d %d\", &width, &height), width != 0 && height != 0) {\n    fgets(str, 99, stdin);\n    for (int i = 0; i < height; i++) {\n      fgets(tile[i], 29, stdin);\n    }\n    int start_y;\n    int start_x;\n    dirty_tile = 0;\n    for (int y = 0; y < height; y++) {\n      for (int x = 0; x < width; x++) {\n        if (tile[y][x] == '*') {\n          dirty_y[dirty_tile] = y;\n          dirty_x[dirty_tile] = x;\n          map[y][x] = dirty_tile;\n          dirty_tile++;\n        } else if (tile[y][x] == 'o') {\n          start_y = y;\n          start_x = x;\n        }\n      }\n    }\n    dirty_y[dirty_tile] = start_y;\n    dirty_x[dirty_tile] = start_x;\n    map[start_y][start_x] = dirty_tile;\n    memset(dist, -1, sizeof(dist));\n    static const int dy[4] = { 1, -1, 0, 0 };\n    static const int dx[4] = { 0, 0, 1, -1 };\n    for (int i = 0; i < dirty_tile + 1; i++) {\n      queue<Point> que;\n      que.push(Point(dirty_y[i], dirty_x[i], 0));\n      memset(check, false, sizeof(check));\n      while (!que.empty()) {\n        Point now = que.front();\n        que.pop();\n        if (check[now.y][now.x]) { continue; }\n        check[now.y][now.x] = true;\n        if (tile[now.y][now.x] == '*') {\n          dist[i][map[now.y][now.x]] = now.cost;\n        }\n        for (int i = 0; i < 4; i++) {\n          int ny = now.y + dy[i];\n          int nx = now.x + dx[i];\n          if (ny < 0 || ny >= height || nx < 0 || nx >= width || check[ny][nx] || tile[ny][nx] == 'x') { continue; }\n          que.push(Point(ny, nx, now.cost + 1));\n        }\n      }\n    }\n    for (int i = 0; i < dirty_tile; i++) {\n      if (dist[dirty_tile][i] == -1) {\n        puts(\"-1\");\n        goto next_loop;\n      }\n    }\n    memset(memo, -1, sizeof(memo));\n    printf(\"%d\\n\", calc(0, 0, dirty_tile));\nnext_loop:\n    ;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define int long long\n\n#define rep(i, a) for (int i = 0; (i) < (int) (a); (i)++)\n#define reps(i, a, b) for (int i = (int) (a); (i) < (int) (b); (i)++)\n#define rrep(i, a) for (int i = (int) a-1; (i) >= 0; (i)--)\n#define rreps(i, a, b) for (int i = (int) (a)-1; (i) >= (int) (b); (i)--)\n#define MP(a, b) make_pair((a), (b))\n#define PB(a) push_back((a))\n#define all(v) (v).begin(), (v).end()\n#define PRINT(f) if((f)){cout << (TRUE__) << endl;}else{cout << FALSE__ << endl;}\n#define TRUE__ \"Yes\"\n#define FALSE__ \"No\"\n#define PERM(v) next_permutation(all(v))\n#define UNIQUE(v) sort(all(v));(v).erase(unique(all(v)), v.end())\n#define CIN(type, x) type x;cin >> x\n\n#ifdef LOCAL\n\t#define lcout(a) cout << a;\n\t#define lcoutln(a) cout << a << endl;\n\t#define lcerr(a) cerr << a;\n\t#define lcerrln(a) cerr << a << endl;\n#else\n\t#define lcout(a) \n\t#define lcoutln(a) \n\t#define lcerr(a) \n\t#define lcerrln(a) \n#endif\n\n#define MOD 1000000007\n#define INF 2000000000\nint w, h;\nint m[22][22];\nint cost[11][11];\nvector<pair<int, int> > v;\nint sr, sc;\n\nint costculc(int r1, int c1, int r2, int c2)\n{\n\tint cmemo[22][22];\n\trep(i, 22) rep(j, 22) cmemo[i][j] = INF;\n\tcmemo[r1][c1] = 0;\n\tqueue<pair<int, int> > q;\n\tq.push(MP(r1, c1));\n\twhile (!q.empty()) {\n\t\tint r, c;\n\t\tr = q.front().first;\n\t\tc = q.front().second;\n\t\tint dr[] = {-1, 0, 1,  0};\n\t\tint dc[] = { 0, 1, 0, -1};\n\t\trep(i, 4) {\n\t\t\tint nr = r + dr[i];\n\t\t\tint nc = c + dc[i];\n\t\t\tif (cmemo[nr][nc] != INF || m[nr][nc] == -1) continue;\n\t\t\tcmemo[nr][nc] = cmemo[r][c] + 1;\n\t\t\tq.push(MP(nr, nc));\n\t\t}\n\t\tq.pop();\n\t}\n\treturn cmemo[r2][c2];\n}\n\nsigned main()\n{\n\tcin >> w >> h;\n\twhile (w) {\n\t\tv.clear();\n\t\trep(i, 22) rep(j, 22) m[i][j] = -1;\n\t\trep(i, 11) rep(j, 11) cost[i][j] = INF;\n\t\trep(i, 11) cost[i][i] = 0;\n\t\treps(i, 1, h+1) reps(j, 1, w+1) {\n\t\t\tCIN(char, c);\n\t\t\tif (c == '.') m[i][j] = 0;\n\t\t\tif (c == 'o') {\n\t\t\t\tm[i][j] = 1;\n\t\t\t\tv.insert(v.begin(), MP(i, j));\n\t\t\t\tsr = i;\n\t\t\t\tsc = j;\n\t\t\t}\n\t\t\tif (c == '*') {\n\t\t\t\tm[i][j] = 2;\n\t\t\t\tv.PB(MP(i, j));\n\t\t\t}\n\t\t\tif (c == 'x') m[i][j] = -1;\n\t\t}\n\t\trep(i, v.size()) reps(j, i+1, v.size()) {\n\t\t\tcost[i][j] = cost[j][i] = costculc(v[i].first, v[i].second, v[j].first, v[j].second);\n\t\t}\n\t\tvector<int> t;\n\t\tint mi = INF;\n\t\trep(i, v.size()-1) t.PB(i+1);\n\t\tdo {\n\t\t\tint be = 0;\n\t\t\tint res = 0;\n\t\t\trep(i, t.size()) {\n\t\t\t\tres += cost[be][t[i]];\n\t\t\t\tbe = t[i];\n\t\t\t}\n\t\t\tmi = min(mi, res);\n\t\t} while (PERM(t));\n\t\tif (mi == INF) cout << -1 << endl;\n\t\telse cout << mi << endl;\n\t\tcin >> w >> h;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\n#define X first\n#define Y second\n\nconst int INF = 0xfffffff;\nconst int dx[4] = {1, -1, 0, 0};\nconst int dy[4] = {0, 0, 1, -1};\nconst int MAX_N = 10;\n\nint w, h;\nint n;\nvector<vector<int> > mat;\nvector<int> x, y;\nvector<string> field;\nint memo[MAX_N + 1][1 << MAX_N];\n\nint bfs(int from, int to) {\n\tvector<vector<int> > label(h, vector<int>(w, INF));\n\tqueue<pair<int, int> > que;\n\tque.push(make_pair(x[from], y[from]));\n\tlabel[y[from]][x[from]] = 0;\n\n\twhile(!que.empty()) {\n\t\tconst int cx = que.front().X, cy = que.front().Y;\n\t\tque.pop();\n\n\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\tconst int nx = cx + dx[i], ny = cy + dy[i];\n\t\t\tif(nx < 0 || ny < 0 || nx >= w || ny >= h || field[ny][nx] == 'x')\n\t\t\t\tcontinue;\n\n\t\t\tif(label[ny][nx] > label[cy][cx] + 1) {\n\t\t\t\tlabel[ny][nx] = label[cy][cx] + 1;\n\t\t\t\tque.push(make_pair(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn label[y[to]][x[to]];\n}\n\nint dfs(int cur, int visited) {\n\tif(visited == (1 << n) - 1)\n\t\treturn 0;\n\n\tif(memo[cur][visited] != -1)\n\t\treturn memo[cur][visited];\n\n\tint res = INF;\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(visited & (1 << i))\n\t\t\tcontinue;\n\t\t\n\t\tchmin(res, dfs(i, visited | (1 << i)) + mat[cur][i]);\n\t}\n\n\treturn memo[cur][visited] = res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> w >> h, w) {\n\t\tx.clear();\n\t\ty.clear();\n\n\t\tfield.clear();\n\t\tfield.resize(h);\n\t\tfor(int i = 0; i < h; ++i)\n\t\t\tcin >> field[i];\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tif(field[i][j] == '*') {\n\t\t\t\t\tx.push_back(j);\n\t\t\t\t\ty.push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tn = x.size();\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tif(field[i][j] == 'o') {\n\t\t\t\t\tx.push_back(j);\n\t\t\t\t\ty.push_back(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmat.clear();\n\t\tmat.resize(n + 1, vector<int>(n + 1, INF));\n\t\tfor(int i = 0; i <= n; ++i)\n\t\t\tmat[i][i] = 0;\n\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tfor(int j = i + 1; j <= n; ++j)\n\t\t\t\tmat[i][j] = mat[j][i] = bfs(i, j);\n\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tconst int ans = dfs(n, 0);\n\t\tcout << (ans >= INF ? -1 : ans) << endl;\t\t\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\n#define dump(val) cerr << __LINE__ << \":\\t\" << #val << \" = \" << (val) << endl\n\nusing namespace std;\n\ntypedef long long int lli;\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) {\n    return vector<T>(a, b);\n}\n\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\nstruct Data {\n    int tile, x, y, c;\n    Data(int t, int _x, int _y, int _c)\n        : tile(t), x(_x), y(_y), c(_c) {}\n    Data() {}\n};\n\nint main() {\n    int w, h;\n    while (cin >> w >> h, w + h) {\n        vector<vector<char>> mp(h + 2, vector<char>(w + 2, 'x'));\n        queue<Data> q;\n        vector<vector<int>> m(h + 2, vector<int>(w + 2, 0));\n\n        int cnt = 0;\n        REP(i, 1, h + 1) {\n            REP(j, 1, w + 1) {\n                cin >> mp[i][j];\n                if (mp[i][j] == 'o') {\n                    q.emplace(0, j, i, 0);\n                }\n                if (mp[i][j] == '*') {\n                    m[i][j] = 1 << cnt;\n                    cnt++;\n                }\n            }\n        }\n        const int inf = 1 << 29;\n        auto memo = make_v(h + 2, w + 2, 1 << cnt, inf);\n        auto used = make_v(h + 2, w + 2, 1 << cnt, false);\n        int dx[4] = {0, 1, 0, -1};\n        int dy[4] = {1, 0, -1, 0};\n        int ans = -1;\n        while (q.size()) {\n            auto data = q.front();\n            q.pop();\n            if (used[data.y][data.x][data.tile]) continue;\n            used[data.y][data.x][data.tile] = true;\n            //cout << \"!\" << data.x << \" \" << data.y << \" \" << data.tile << \" \" << data.c << endl;\n            if (data.tile == (1 << cnt) - 1) {\n                ans = data.c;\n                break;\n            }\n            REP(k, 0, 4) {\n                int nx = data.x + dx[k];\n                int ny = data.y + dy[k];\n                if (mp[ny][nx] == 'x') continue;\n                int t = data.tile | m[ny][nx];\n                if (memo[ny][nx][t] > data.c + 1) {\n                    memo[ny][nx][t] = data.c + 1;\n                    q.emplace(t, nx, ny, data.c + 1);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<cctype>\nusing namespace std;\n#define fr first\n#define sc second\ntypedef pair<int,int> Pt;\ntypedef pair<Pt ,int> P;\nPt ST,GL;\nint h,w,c,used[20][20][1 << 10],d[]={0,1,0,-1};\nchar mas[20][20];\nint bfs();\nint main(){\n  while(cin >> w >> h && w){\n    c = 0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> mas[i][j];\n        if(mas[i][j] == 'o') ST = Pt(i,j);\n        else if(mas[i][j] == '*') mas[i][j] = c,c++;\n      }\n    }\n    cout << bfs() << endl;\n  }\n}\nint bfs(){\n  memset(used,-1,sizeof(used));\n  queue<P> que;\n  que.push(P(ST,(1<<c)-1));\n  used[ST.fr][ST.sc][(1<<c)-1] = 0;\n  while(!que.empty()){\n    P p = que.front();\n    que.pop();\n    if(!p.sc) return used[p.fr.fr][p.fr.sc][p.sc];\n    int log = used[p.fr.fr][p.fr.sc][p.sc];\n    for(int i=0;i<4;i++){\n      int nx = d[i] + p.fr.fr,ny = d[3-i] + p.fr.sc;\n      int bits = p.sc;\n      if(mas[nx][ny] == 'x') continue;\n      if(mas[nx][ny] >= 0 && mas[nx][ny] <10){\n        if(!(bits>>mas[nx][ny])&1)continue;\n        bits ^= (1<<mas[nx][ny]);\n      }\n      if(nx>=0&&nx<h&&ny>=0&&ny<w&&mas[nx][ny]!='x'&&used[nx][ny][bits]==-1){\n        que.push(P(Pt(nx,ny),bits));\n        used[nx][ny][bits] = log + 1;\n      }\n    }\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define ck(a,b) (0<=(a)&&(a)<b)\n#define INF 1<<30\nusing namespace std;\nint dx[]={-1,1,0,0},dy[]={0,0,-1,1};\nint x[11],y[11],d[11][11],w,h,n; char r[21][21];\nint dfs(int cy,int cx,int gy,int gx,int c[21][21]){\n\tint ans=INF;\n\trep(d,4){\n\t\tint ty=cy+dy[d],tx=cx+dx[d];\n\t\tif(!ck(ty,h)||!ck(tx,w)||r[ty][tx]=='x')continue;\n\t\tif(c[ty][tx]>c[cy][cx]+1){\n\t\t\tc[ty][tx]=c[cy][cx]+1;\n\t\t\tif(ty==gy&&tx==gx)return c[ty][tx];\n\t\t\tans=min(ans,dfs(ty,tx,gy,gx,c));\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\twhile(cin>>w>>h,w){\n\t\tn=1;\n\t\trep(i,h)rep(j,w){\n\t\t\tcin>>r[i][j];\n\t\t\tif(r[i][j]=='o')y[0]=i,x[0]=j;\n\t\t\tif(r[i][j]=='*')y[n]=i,x[n]=j,n++;\n\t\t}\n\t\trep(i,n)rep(j,i){\n\t\t\tint c[21][21]; rep(k,21)rep(l,21)c[k][l]=INF;\n\t\t\tc[y[i]][x[i]]=0;\n\t\t\td[i][j]=d[j][i]=dfs(y[i],x[i],y[j],x[j],c);\n\t\t}\n\t\tqueue<pair<int,int> > F; int cost[1<<n][n];\n\t\tF.push(make_pair(1,0)); rep(i,1<<n)rep(j,n)cost[i][j]=INF;\n\t\tcost[1][0]=0;\n\t\twhile(!F.empty()){\n\t\t\tint cs=F.front().first,ns,ct=F.front().second; F.pop();\n\t\t\trep(i,n){\n\t\t\t\tif(cs&(1<<i))continue;\n\t\t\t\tns=cs|(1<<i);\n\t\t\t\tif(cost[ns][i]>cost[cs][ct]+d[ct][i])\n\t\t\t\tF.push(make_pair(ns,i)),cost[ns][i]=cost[cs][ct]+d[ct][i];\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\trep(i,n)if(ans>cost[(1<<n)-1][i])ans=cost[(1<<n)-1][i];\n\t\tcout<<(ans==INF?-1:ans)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n\nusing namespace std;\n\nint w,h;\nint trush[20][20];\nbool map[20][20];\nbool dp[20][20][1<<10];\nint gomi,ans_bit;\nint dir[4][2]{{1,0},{0,1},{-1,0},{0,-1}};\n\nstruct set{\n  int y,x,bit;\n};\n\nint main() {\n  while(true) {\n    scanf(\"%d%d\",&w,&h);\n    if(w==0) break;\n    int x,y;\n    gomi = 0;\n    for(int i = 0; i < h; i++) {\n      char input[21];\n      scanf(\"%s\",input);\n      for(int j = 0; input[j]!='\\0'; j++) {\n        trush[i][j]=(input[j]=='*')?gomi:-1;\n        if(input[j]=='*') gomi++;\n        map[i][j]=(input[j]=='x');\n        if(input[j]=='o') {\n          x = j;\n          y = i;\n        }\n      }\n    }\n    ans_bit = (1<<gomi)-1;\n\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) {\n        for(int k = 0; k < (1<<gomi); k++) {\n          dp[i][j][k] = false;\n        }\n      }\n    }\n\n    int ans = 0;\n    queue<set> q;\n    q.push(set{y,x,0});\n    dp[y][x][0] = true;\n    bool ans_flag = false;\n    while(!q.empty()&&!ans_flag) {\n      ans++;\n      int size = q.size();\n      for(int loop = 0; loop < size; loop++) {\n        set s = q.front();q.pop();\n        if(s.bit==ans_bit) {\n          ans_flag = true;\n          ans--;\n          break;\n        }\n        for(int d = 0; d < 4; d++) {\n          int next_x = s.x+dir[d][0];\n          int next_y = s.y+dir[d][1];\n          if(next_x<0||next_x>=w) continue;\n          if(next_y<0||next_y>=h) continue;\n          int next_bit = s.bit;\n          if(trush[next_y][next_x]>=0) {\n            next_bit |= (1<<trush[next_y][next_x]);\n          }\n          if(!dp[next_y][next_x][next_bit]) {\n            dp[next_y][next_x][next_bit] = true;\n            if(!map[next_y][next_x]) {\n              q.push(set{next_y,next_x,next_bit});\n            }\n          }\n        }\n      }\n    }\n    printf(\"%d\\n\",(ans_flag)?ans:-1);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<memory>\n#include<functional>\n\nusing namespace std;\n\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define F(i,j,k) fill(i[0],i[0]+j*j,k)\n#define P(p) cout<<(p)<<endl;\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define INF 1<<25\n#define pb push_back\n\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef vector<double> vd;\ntypedef pair<int,int> pii;\ntypedef pair<long,long> pll;\ntypedef long long ll;\n\nusing namespace std;\n\nstruct robot {\n    int x, y, cost, dust;\n\n    bool operator >(const robot& r) const {\n        return cost > r.cost;\n    }\n};\n\nint main()\n{\n    int w, h;\n    while (cin >> w >> h, w|h) {\n        // input\n        vector<string> v;\n        rep(j, h){\n            string input;\n            cin >> input;\n            v.pb(input);\n        }\n\n        // dust map\n        int dust[20][20];\n        fill_n((int *)dust, 20 * 20, 0);\n        int bit = 1;\n\n        // start & goal\n        int sx, sy;\n        int goal = 0;\n        rep(j, h){\n            rep(i, w){\n                if(v[j][i] == 'o') {\n                    sx = i; sy = j;\n                }\n                if(v[j][i] == '*') {\n                    dust[j][i] = bit;\n                    goal += bit;\n                    bit *= 2;\n                }\n            }\n        }\n\n        // bfs\n        int check[20][20][1<<10];\n        fill_n((int *)check, 20*20*(1<<10), INT_MAX);\n        int cost = -1;\n        priority_queue<robot, vector<robot>, greater<robot> > q;\n        q.push((robot){sx, sy, 0, 0});\n        while(!q.empty()){\n            robot p = q.top(); q.pop();\n            // goal\n            if (p.dust == goal) {\n                cost = p.cost;\n                break;\n            }\n            // up\n            if (p.y - 1 >= 0 && v[p.y-1][p.x] != 'x') {\n                if (v[p.y-1][p.x] == '*' && (p.dust & dust[p.y-1][p.x]) != dust[p.y-1][p.x]) {\n                    if (check[p.y-1][p.x][p.dust + dust[p.y-1][p.x]] > p.cost + 1) {\n                        q.push((robot){p.x, p.y-1, p.cost+1, p.dust + dust[p.y-1][p.x]});\n                        check[p.y-1][p.x][p.dust + dust[p.y-1][p.x]] = p.cost + 1;\n                    }\n                } else {\n                    if (check[p.y-1][p.x][p.dust] > p.cost + 1) {\n                        q.push((robot){p.x, p.y-1, p.cost+1, p.dust});\n                        check[p.y-1][p.x][p.dust] = p.cost + 1;\n                    }\n                }\n            }\n            // down\n            if (p.y + 1 < h && v[p.y+1][p.x] != 'x') {\n                if (v[p.y+1][p.x] == '*' && (p.dust & dust[p.y+1][p.x]) != dust[p.y+1][p.x]) {\n                    if (check[p.y+1][p.x][p.dust + dust[p.y+1][p.x]] > p.cost + 1) {\n                        q.push((robot){p.x, p.y+1, p.cost+1, p.dust + dust[p.y+1][p.x]});\n                        check[p.y+1][p.x][p.dust + dust[p.y+1][p.x]] = p.cost + 1;\n                    }\n                } else {\n                    if (check[p.y+1][p.x][p.dust] > p.cost + 1) {\n                        q.push((robot){p.x, p.y+1, p.cost+1, p.dust});\n                        check[p.y+1][p.x][p.dust] = p.cost + 1;\n                    }\n                }\n            }\n            // right\n            if (p.x + 1 < w && v[p.y][p.x+1] != 'x') {\n                if (v[p.y][p.x+1] == '*' && (p.dust & dust[p.y][p.x+1]) != dust[p.y][p.x+1]) {\n                    if (check[p.y][p.x+1][p.dust + dust[p.y][p.x+1]] > p.cost + 1) {\n                        q.push((robot){p.x+1, p.y, p.cost+1, p.dust + dust[p.y][p.x+1]});\n                        check[p.y][p.x+1][p.dust + dust[p.y][p.x+1]] = p.cost + 1;\n                    }\n                } else {\n                    if (check[p.y][p.x+1][p.dust] > p.cost + 1) {\n                        q.push((robot){p.x+1, p.y, p.cost+1, p.dust});\n                        check[p.y][p.x+1][p.dust] = p.cost + 1;\n                    }\n                }\n            }\n            // left\n            if (p.x - 1 >= 0 && v[p.y][p.x-1] != 'x') {\n                if (v[p.y][p.x-1] == '*' && (p.dust & dust[p.y][p.x-1]) != dust[p.y][p.x-1]) {\n                    if (check[p.y][p.x-1][p.dust + dust[p.y][p.x-1]] > p.cost + 1) {\n                        q.push((robot){p.x-1, p.y, p.cost+1, p.dust + dust[p.y][p.x-1]});\n                        check[p.y][p.x-1][p.dust + dust[p.y][p.x-11]] = p.cost + 1;\n                    }\n                } else {\n                    if (check[p.y][p.x-1][p.dust] > p.cost + 1) {\n                        q.push((robot){p.x-1, p.y, p.cost+1, p.dust});\n                        check[p.y][p.x-1][p.dust] = p.cost + 1;\n                    }\n                }\n            }\n        }\n        cout << cost << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <iostream>\n#include <queue>\n#define MAX 20\n#define INF 10000000\n\nusing namespace std;\n\nint w, h;\nint si, sj;\nchar c[MAX][MAX];\nint d[MAX][MAX][1024];\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid change(int a[10], int x){\n\n\tfor(int i = 0 ; i < 10 ; ++i){\n\t\ta[i] = x % 2;\n\t\tx /= 2;\n\t}\n\n}\n\nint change(int a[10]){\n\n\tint res = 0;\n\tfor(int i = 9 ; i >= 0 ; --i){\n\t\tres = res * 2 + a[i];\n\t}\n\treturn res;\n}\n\nint bfs(int sy, int sx, int cnt){\n\n\tqueue<int> qx, qy, qbit;\n\tqy.push(si);\n\tqx.push(sj);\n\tqbit.push(0);\n\n\td[sj][si][0] = 0;\n\n\n\twhile(qbit.empty() == false){\n\n\t\tint y = qy.front();\n\t\tqy.pop();\n\n\t\tint x = qx.front();\n\t\tqx.pop();\n\n\t\tint bit = qbit.front();\n\t\tqbit.pop();\n\n\t\tif( bit + 1 == (1 << cnt) ){\t\t\t\t// ?????§?????¨??????????????????????????????\n\t\t\treturn d[y][x][bit];\n\t\t}\n\n\t\tint a[10];\n\t\tfor(int i = 0 ; i < 4 ; ++i){\n\n\t\t\tchange(a, bit);\n\t\t\tint ny = dy[i] + y;\n\t\t\tint nx = dx[i] + x;\n\n\t\t\tif( ny < 0 || nx < 0 ) continue;\t\t// ?????????\n\t\t\tif( h <= ny || w <= nx) continue;\t\t// ?????????\n\t\t\tif( c[ny][nx] == 'x') continue;\t\t\t// ?§??????§?????????\n\n\t\t\tif( c[ny][nx] != '.'){\t\t\t\t\t// ?±??????????????????§????????´???\n\t\t\t\tint num = c[ny][nx] - '0';\t\t\t// ?±???????????????????ID?????????\n\t\t\t\ta[num] = 1;\n\t\t\t}\n\t\t\tint nbit = change(a);\n\t\t\tint nCost = d[y][x][bit] + 1;\n\n\t\t\tif( nCost < d[ny][nx][nbit] ){\t\t\t// ??????????????£??????????????´??? & ???????§£?????´??°\n\t\t\t\td[ny][nx][nbit] = nCost;\n\t\t\t\tqy.push(ny);\n\t\t\t\tqx.push(nx);\n\t\t\t\tqbit.push(nbit);\n\t\t\t}\n\n\t\t}// end of for\n\n\n\t}// end of while\n\n\n\treturn -1;\n}// end of bfs\n\nvoid init(){\n\n\tfor (int i = 0 ; i < h ; ++i){\n\t\tfor (int j = 0 ; j < w ; ++j){\n\t\t\tfor(int k = 0 ; k < 1024 ; ++k){\n\t\t\t\td[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n\n\n}\n\nint main(void){\n\n\n\twhile( cin >> w >> h ){\n\n\t\tif( w == h && h == 0 ){\n\t\t\tbreak;\n\t\t}\n\t\tinit();\n\t\tint cnt = 0;\n\n\t\tfor(int i = 0 ; i < h ; ++i){\n\t\t\tfor(int j = 0 ; j < w ; ++j){\n\t\t\t\tcin >> c[i][j];\n\t\t\t\tif( c[i][j] == 'o'){\n\t\t\t\t\tsj = j;\n\t\t\t\t\tsi = i;\n\t\t\t\t\tc[i][j] = '.';\n\t\t\t\t}else if( c[i][j] == '*'){\n\t\t\t\t\tc[i][j] = '0' + cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << bfs(si, sj, cnt) << endl;\n\n\t\t// for(int i = 0 ; i < h ; ++i){\n\t\t// \tfor(int j = 0 ; j < w ; ++j ){\n\t\t// \t\tcout << c[i][j];\n\t\t// \t}\n\t\t// \tcout << endl;\n\t\t// }\n\n\t}// end of while\n\n\treturn 0;\n}// end of main"
  },
  {
    "language": "C++",
    "code": "/*********************\nAOJ_1140\nCleaning Robot\n*********************/\n#include <iostream>\n#include <queue>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\n//構造体宣言\nstruct pos{\n\tint x;\t\t//座標\n\tint y;\t\t\n\tint dis;\t//距離\n};\n\nint main(){\n\tint w, h;\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 || h == 0) break;\n\n\t\t//タイルの初期化\n\t\tchar tile[30][30];\n\t\tfor(int i = 0; i < 30; i ++){\n\t\t\tfor(int j = 0; j < 30; j++){\n\t\t\t\ttile[i][j] = 'x';\n\t\t\t}\n\t\t}\n\t\t//タイルの入力\n\t\tint stain = 0;\t//汚れの数\n\t\tqueue<pos> que;\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tstring input;\n\t\t\tcin >> input;\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\ttile[i][j] = input[j-1];\n\t\t\t\tif(tile[i][j] == '*') stain++;\n\t\t\t\tif(tile[i][j] == 'o'){\n\t\t\t\t\tpos p;\n\t\t\t\t\tp.y = i; p.x = j;\n\t\t\t\t\tp.dis = 0;\n\t\t\t\t\tque.push(p);\n\t\t\t\t\ttile[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint count = 0;\n\t\twhile(stain > 0){\n\t\t\tchar bfs[30][30];\n\t\t\tmemcpy(bfs, tile, sizeof(bfs));\n\t\t\tpos p = que.front();\n\t\t\tbfs[p.y][p.x] = 0;\n\t\t\tint x1[] = {-1, 0, 1, 0}, y1[] = {0, -1, 0, 1};\n\t\t\tint f = 1;\n\t\t\twhile(f && !que.empty()){\n\t\t\t\tpos p1 = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tp = p1;\n\t\t\t\t\tp.x += x1[i]; p.y += y1[i];\n \t\t\t\t\tif(bfs[p.y][p.x] == '.'){\n\t\t\t\t\t\tp.dis++;\n\t\t\t\t\t\tbfs[p.y][p.x] = p.dis;\n\t\t\t\t\t\tque.push(p);\n\t\t\t\t\t}else if(bfs[p.y][p.x] == '*'){\n\t\t\t\t\t\tcount += p.dis+1;\n\t\t\t\t\t\tstain--;\n\t\t\t\t\t\ttile[p.y][p.x] == '.';\n\t\t\t\t\t\twhile(!que.empty()) que.pop();\n\t\t\t\t\t\tp.dis = 0;\n\t\t\t\t\t\tque.push(p);\n\t\t\t\t\t\tf = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(que.empty()) break;\n\t\t}\n\n\t\tif(stain > 0) cout << \"-1\" << endl;\n\t\telse cout << count << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<iomanip>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\n#define MAX 1024\n#define N 10\n#define SIZE 22\n\n#define NONE 0\n#define START 1\n#define DIRTY_TILE 2\n#define FURNITURE 3\n\n#define INFTY 1<<29\n\nvoid bfs(int sti, int stj, int map[SIZE][SIZE], int cost_map[SIZE][SIZE]){\n\tconst int di[] = {-1,0,1,0};\n\tconst int dj[] = {0,1,0,-1};\n\tbool vis[SIZE][SIZE]={{false,},};\n\tqueue< pair<int,int> > q;\n\n\tfor(int i = 0; i < SIZE; ++i){\n\t\tfor(int j = 0; j < SIZE; ++j){\n\t\t\tcost_map[i][j] = -1;\n\t\t}\n\t}\n\n\tq.push( make_pair(sti,stj) );\n\tcost_map[sti][stj]=0;\n\tvis[sti][stj]=true;\n\twhile(!q.empty()){\n\t\tpair<int,int> t = q.front();\n\t\tq.pop();\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\tint ti = t.first + di[k];\n\t\t\tint tj = t.second + dj[k];\n\t\t\tif( map[ti][tj] != FURNITURE && !vis[ti][tj] ){\n\t\t\t\tcost_map[ti][tj] = cost_map[t.first][t.second] + 1;\n\t\t\t\tvis[ti][tj]=true;\n\t\t\t\tq.push( make_pair(ti,tj) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dp(int n, int ini_cost[N], int cost[N][N] ){\n\tint w[MAX];\n\tint prev[MAX];\n\tw[0]=0;\n\tfor(int state=1;state<(1<<n);++state){\n\t\tw[state]=INFTY;\n\t}\n\tfor(int state=1;state<(1<<n);++state){\n\t\tfor(int i=0;i<n;++i){\n\t\t\tif(state&(1<<i)){\n\t\t\t\tint t;\n\t\t\t\tint pre_state=state^(1<<i);\n\t\t\t\t\n\t\t\t\tif( pre_state == 0 )\n\t\t\t\t\tt = w[pre_state]+ini_cost[i];\n\t\t\t\telse\n\t\t\t\t\tt = w[pre_state]+cost[prev[pre_state]][i];\n\n\t\t\t\tif( w[state]>t ){\n\t\t\t\t\tw[state]=t;\n\t\t\t\t\tprev[state]=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn w[(1<<n)-1];\n}\n\nint CleaningRobot(int h, int w, int map[SIZE][SIZE]){\n\tint cost[N][N];\n\tint ini_cost[N];\n\tint cost_map[SIZE][SIZE];\n\tvector< pair<int, int> > vtiles;\n\n\tfor(int i = 1; i <= h; ++i){\n\t\tfor(int j = 1; j <= w; ++j){\n\t\t\tif( map[i][j] == DIRTY_TILE ){\n\t\t\t\tvtiles.push_back( make_pair( i, j ) );\n\t\t\t}\n\t\t\tif( map[i][j] == START ){\n\t\t\t\tbfs(i,j,map,cost_map);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(unsigned int i = 0; i < vtiles.size(); ++i){\n\t\tini_cost[i]=cost_map[vtiles[i].first][vtiles[i].second];\n\t}\n\n\tfor(unsigned int i = 0; i < vtiles.size(); ++i){\n\t\tbfs(vtiles[i].first,vtiles[i].second,map,cost_map);\n\t\t\n\t\t/*for(int k = 1; k <= h; ++k){\n\t\t\tfor(int l = 1; l <= w; ++l){\n\t\t\t\tcout << setw(4) << cost_map[k][l];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\n\t\tfor(unsigned int j = 0; j < vtiles.size(); ++j){\n\t\t\tcost[i][j] = cost[j][i] = cost_map[vtiles[j].first][vtiles[j].second];\n\t\t}\n\t}\n\n\treturn dp(vtiles.size(),ini_cost,cost);\n}\n\nint main(){\n\twhile(true){\n\t\tint h,w;\n\t\tint map[SIZE][SIZE];\n\t\tcin>>w>>h;\n\t\tif(h==0&&w==0)break;\n\t\tfor(int i=0;i<SIZE;++i){\n\t\t\tfor(int j=0;j<SIZE;++j){\n\t\t\t\tmap[i][j]=FURNITURE;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=h;++i){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tfor(unsigned int j=0;j<s.length();++j){\n\t\t\t\tswitch(s[j]){\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tmap[i][j+1]=NONE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'x':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'o':\n\t\t\t\t\t\tmap[i][j+1]=START;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\tmap[i][j+1]=DIRTY_TILE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << CleaningRobot(h,w,map) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define mp make_pair\n#define pb push_back\n#define EB emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint w,h;\n\nvoid solve(){\n    char c[32][32];\n    rep(i,h) scanf(\"%s\",c[i]);\n\n    int sx,sy;\n    rep(i,h) rep(j,w) if(c[i][j]=='o'){\n        sx = i;\n        sy = j;\n        break;\n    }\n\n    int g[512][512];\n    rep(i,512) rep(j,512) g[i][j]=INF;\n    rep(i,512) g[i][i]=0;\n\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(c[i][j]=='x') continue;\n            int v = i*w+j;\n            for(int k=0;k<4;k++){\n                int nx=i+dx[k],ny=j+dy[k];\n                if(nx<0||ny<0||nx>=h||ny>=w) continue;\n                if(c[nx][ny]=='x') continue;\n                int nv = nx*w+ny;\n                g[v][nv] = 1;\n                g[nv][v] = 1;\n            }\n        }\n    }\n\n    int V = h*w;\n    for(int k=0;k<V;k++){\n        for(int i=0;i<V;i++){\n            for(int j=0;j<V;j++){\n                g[i][j] = min(g[i][j],g[i][k]+g[k][j]);\n            }\n        }\n    }\n\n    vector<int> as;\n    rep(i,h) rep(j,w){\n        int v = i*w+j;\n        if(c[i][j]=='*') as.pb(v);\n    }\n\n    sort(all(as));\n\n    assert(as.size()<=10);\n    int ans = INF;\n    do{\n        int tmp=0;\n        int now = sx*w+sy;\n        for(int i=0;i<sz(as);i++){\n            tmp += g[now][as[i]];\n            now = as[i];\n        }\n        //if(tmp==0){\n        //    //cerr << \"error\" << endl;\n        //    exit(1);\n        //}\n        ans = min(tmp,ans);\n    }while(next_permutation(all(as)));\n    if(ans==INF) cout << -1 << endl;\n    else cout << ans << endl;\n}\n\nint main(){\n    while(cin>>w>>h){\n        if(w==0 and h==0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<cctype>\nusing namespace std;\n#define fr first\n#define sc second\ntypedef pair<int,int> Pt;\ntypedef pair<Pt ,int> P;\nPt ST,GL;\nint h,w,c,used[20][20][1 << 11],d[]={0,1,0,-1};\nchar mas[20][20];\nint bfs();\nint main(){\n  while(cin >> w >> h && w){\n    c = 0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> mas[i][j];\n        if(mas[i][j] == 'o') ST = Pt(i,j);\n        else if(mas[i][j] == '*') mas[i][j] = c,c++;\n      }\n    }\n    cout << bfs() << endl;\n  }\n}\nint bfs(){\n  memset(used,-1,sizeof(used));\n  queue<P> que;\n  que.push(P(ST,(1<<c)-1));\n  used[ST.fr][ST.sc][(1<<c)-1] = 0;\n  while(!que.empty()){\n    P p = que.front();\n    que.pop();\n    if(!p.sc) return used[p.fr.fr][p.fr.sc][p.sc];\n    int log = used[p.fr.fr][p.fr.sc][p.sc];\n    for(int i=0;i<4;i++){\n      int nx = d[i] + p.fr.fr,ny = d[3-i] + p.fr.sc;\n      int bits = p.sc;\n      if(mas[nx][ny] == 'x') continue;\n      if(mas[nx][ny] >= 0 && mas[nx][ny] <11){\n        if(!((bits>>mas[nx][ny])&1))continue;\n        bits ^= (1<<mas[nx][ny]);\n      }\n      if(nx>=0&&nx<h&&ny>=0&&ny<w&&mas[nx][ny]!='x'&&used[nx][ny][bits]==-1){\n        que.push(P(Pt(nx,ny),bits));\n        used[nx][ny][bits] = log + 1;\n      }\n    }\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n#include <utility>\n#define INF 0x3FFFFFFF\n\nusing namespace std;\n\n\nint main(void){\n\tint n, h, w, i, j, k, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0}, s[11][20][20], d[11][11], a, b, dp[11][1 << 10], min;\n\tpair<int,int> l[11];\n\tqueue<pair<int,int> > que;\n\tchar field[20][21];\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tn = 1;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tfield[i][j] = getchar();\n\t\t\t\tif(field[i][j] == '*') l[n].first = j,l[n++].second = i, field[i][j] = '.';\n\t\t\t\telse if(field[i][j] == 'o') l[0].first = j, l[0].second = i, field[i][j] = '.';\n\t\t\t}\n\t\t\tgetchar();\n\t\t}\n\t\tmemset(s,-1,sizeof(s));\n\t\tfor(i = 0;i < n;i++){\n\t\t\tque.push(l[i]);\n\t\t\ts[i][que.front().second][que.front().first] = 0;\n\t\t\twhile(que.size()){\n\t\t\t\ta = que.front().first, b = que.front().second;\n\t\t\t\tfor(j = 0;j < 4;j++){\n\t\t\t\t\tif(a + dx[j] >= 0 && a + dx[j] < w && b + dy[j] >= 0 && b + dy[j] < h && field[b + dy[j]][a + dx[j]] == '.' && s[i][b + dy[j]][a + dx[j]] == -1){\n\t\t\t\t\t\tque.push(pair<int,int>(a + dx[j],b + dy[j]));\n\t\t\t\t\t\ts[i][b + dy[j]][a + dx[j]] = s[i][b][a] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tque.pop();\n\t\t\t}\n\t\t}\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 1;j < n;j++){\n\t\t\t\td[i][j] = s[i][l[j].second][l[j].first];\n\t\t\t\tif(i != 0){\n\t\t\t\t\td[j][i] = s[i][l[j].second][l[j].first];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 1;j < n;j++) if(d[i][j] == -1) break;\n\t\t\tif(j != n) break;\n\t\t}\n\t\tif(i != n){ // もし汚れを取ることのできないタイルがあるのなら\n\t\t\tprintf(\"-1\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor(i = 0;i < 1 << (n - 1);i++)\n\t\t\tfor(j = 0;j < n;j++) dp[j][i] = INF;\n\t\tdp[0][0] = 0;\n\t\tfor(i = 0;i < 1 << (n - 1);i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tfor(k = 1;k < n;k++){\n\t\t\t\t\tif(~i & (1 << (k - 1)) && dp[k][i | (1 << (k - 1))] > dp[j][i] + d[j][k])\n\t\t\t\t\t\tdp[k][i | (1 << (k - 1))] = dp[j][i] + d[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmin = INF;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tif(min > dp[i][(1 << (n - 1)) - 1]) min = dp[i][(1 << (n - 1)) - 1];\n\t\tprintf(\"%d\\n\",min >= INF ? -1 : min);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <chrono>\n#include <queue>\n#include <functional>\nusing namespace std;\n\n#define INF 1e9\n\n//????????????\nclass Timer {\n\tchrono::high_resolution_clock::time_point start, end;\n\tdouble limit;\n\npublic:\n\tTimer() {\n\t\tstart = chrono::high_resolution_clock::now();\n\t}\n\tTimer(double l) {\n\t\tstart = chrono::high_resolution_clock::now();\n\t\tlimit = l;\n\t}\n\n\tdouble getTime() {\n\t\tend = chrono::high_resolution_clock::now();\n\t\treturn chrono::duration<double>(end - start).count();\n\t}\n\n\tbool Over() {\n\t\tif (getTime() > limit) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid setLimit(double l) {\n\t\tlimit = l;\n\t}\n\tvoid setStart() { start = chrono::high_resolution_clock::now(); }\n};\n\nstruct POINT {\n\tint x, y;\n\n\tPOINT() {}\n\tPOINT(int x_, int y_) { x = x_, y = y_; }\n\n\tbool operator<(const POINT& r)const {\n\t\treturn x + y < r.x + r.y;\n\t}\n\n\tPOINT operator+(const POINT& r)const {\n\t\treturn POINT(x + r.x, y + r.y);\n\t}\n};\n\nstruct STATUS {\n\tint dist;\n\n\tint id;\n\tvector<bool>used;\n\n\tSTATUS() {}\n\tSTATUS(int dist_, int id_, vector<bool>&used_) {\n\t\tdist = dist_;\n\t\tid = id_;\n\t\tused = used_;\n\t}\n\n\tbool operator>(const STATUS& r)const {\n\t\treturn dist > r.dist;\n\t}\n};\n\nint W, H;\nvector<vector<int>>MAP;\nint status[20][20];\nint cost[20][20];\nvoid dijkstra(POINT p) {\n\tint v[] = { -1,0,1,0 };\n\tint h[] = { 0,1,0,-1 };\n\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tstatus[i][j] = 0;\n\t\t\tcost[i][j] = INF;\n\t\t}\n\t}\n\tcost[p.x][p.y] = 0;\n\tstatus[p.x][p.y] = 1;\n\n\tpriority_queue<pair<int, POINT>, vector<pair<int, POINT>>, greater<pair<int, POINT>>>U;\n\tU.push(make_pair(cost[p.x][p.y], p));\n\twhile (!U.empty()) {\n\t\t//??¢?´¢???????????£??????????????§?????????????°???????\n\t\tPOINT u = U.top().second; U.pop();\n\n\t\tif (status[u.x][u.y] == -1) continue;\n\n\t\tstatus[u.x][u.y] = -1;\n\n\t\t//?????????????°????????????¢???\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPOINT np = u + POINT(v[i], h[i]);\n\t\t\tif (np.x < 0 || np.x >= H || np.y < 0 || np.y >= W)continue;\n\t\t\tif (MAP[np.x][np.y] == 1)continue;\n\t\t\tif (status[np.x][np.y] != -1) {\n\t\t\t\tif (cost[np.x][np.y] > cost[u.x][u.y] + 1) {\n\t\t\t\t\tcost[np.x][np.y] = cost[u.x][u.y] + 1;\n\t\t\t\t\tstatus[np.x][np.y] = 1;\n\t\t\t\t\tU.push(make_pair(cost[np.x][np.y], np));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (1) {\n\t\tcin >> W >> H;\n\n\t\tif (W == 0 && H == 0)break;\n\n\t\tMAP.assign(H,vector<int>(W,0));\n\n\t\tvector<POINT>pos;\n\t\tint cnt = 0;\n\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tchar c; cin >> c;\n\t\t\t\tif (c == '*') {\n\t\t\t\t\tPOINT p = POINT(i, j);\n\t\t\t\t\tpos.push_back(p);\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\telse if (c == 'x')MAP[i][j] = 1;\n\t\t\t\telse if (c == 'o') {\n\t\t\t\t\tPOINT sp = POINT(i, j);\n\t\t\t\t\tpos.insert(pos.begin(), sp);\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool fin = false;\n\t\tvector<vector<int>>dist(cnt);\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\tdist[i].resize(cnt);\n\t\t\tdijkstra(pos[i]);\n\t\t\tfor (int j = 1; j < cnt; j++) {\n\t\t\t\tint distance = cost[pos[j].x][pos[j].y];\n\t\t\t\tif (distance == INF)fin = true;\n\t\t\t\tdist[i][j] = distance;\n\t\t\t}\n\t\t}\n\n\t\tif (fin) {\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tTimer tmr(0.5);\n\t\tvector<priority_queue<STATUS, vector<STATUS>, greater<STATUS>>>STAT(cnt);\n\t\tSTAT[0].push(STATUS(0,0,vector<bool>(cnt)));\n\t\twhile (1) {\n\t\t\tif (tmr.Over())break;\n\n\t\t\tfor (int i = 0; i < cnt - 1; i++) {\n\t\t\t\tif (STAT[i].empty())continue;\n\n\t\t\t\tSTATUS st = STAT[i].top(); STAT[i].pop();\n\n\t\t\t\tfor (int j = 1; j < cnt; j++) {\n\t\t\t\t\tif (st.used[j])continue;\n\n\t\t\t\t\tst.used[j] = true;\n\t\t\t\t\tSTAT[i + 1].push(STATUS(st.dist + dist[st.id][j], j, st.used));\n\t\t\t\t\tst.used[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSTATUS last = STAT[cnt - 1].top();\n\t\tcout << last.dist << endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#define MAX_V 13\n#define INF 10000000\n#include<queue>\n#include<string>\n#include<map>\n#include<vector>\nusing namespace std;\nstruct edge{\n\tint to,cost;\n};\nint co[MAX_V][MAX_V];\nint h,w,V,dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nstring s[1000];\ntypedef pair<int,int> P;\nmap<P,int> mp;\nint dp[1 << MAX_V][MAX_V];\nint rec(int S,int v){\n\tif(dp[S][v]>=0)\n\t\treturn dp[S][v];\n\tif(S==(1<<V)-2){\n\t\treturn dp[S][v]=0;\n\t}\n\tint res=INF;\n\tfor(int u=0;u<V;u++){\n\t\tif(!(S>>u&1)){\n\t\t\tres=min(res,rec(S|1<<u,u)+co[v][u]);\n\t\t}\n\t}\n\treturn dp[S][v]=res;\n}\nvoid solve(){\n\tmemset(dp,-1,sizeof(dp));\n\tint temp=rec(0,0);\n\tif(temp==INF)\n\tcout<<-1<<endl;\n\telse\n\tcout<<temp<<endl;\n}\nvoid func(int y,int x,int q){\n\tint d[MAX_V][MAX_V];\n\tfor(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\td[i][j]=INF;\n\td[y][x]=0;\n\tqueue<P> box;\n\tbox.push(P(y,x));\n\twhile(!box.empty()){\n\t\tint nx,ny,sx,sy;\n\t\tP pre=box.front();\n\t\tbox.pop();\n\t\tsy=pre.first;\n\t\tsx=pre.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tnx=sx+dx[i];\n\t\t\tny=sy+dy[i];\n\t\t\tif((nx>=0&&ny>=0&&nx<w&&ny<h)&&(s[ny][nx]=='o'||s[ny][nx]=='.'||s[ny][nx]=='*')&&(d[ny][nx]==INF)){\n\t\t\t\tbox.push(P(ny,nx));\n\t\t\t\tif(s[ny][nx]=='*'||s[ny][nx]=='o'){\n\t\t\t\t\tco[mp[P(ny,nx)]][q]=d[sy][sx]+1;\n\t\t\t\t\tco[q][mp[P(ny,nx)]]=d[sy][sx]+1;\n\t\t\t\t}\n\t\t\t\td[ny][nx]=d[sy][sx]+1;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(cin>>w>>h,h||w){\n\t\tV=1;\n\t\tfor(int i=0;i<h;i++)\n\t\tcin>>s[i];\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\tif(s[i][j]=='o')\n\t\t\tmp[P(i,j)]=0;\n\t\telse if(s[i][j]=='*'){\n\t\t\tmp[P(i,j)]=V;\n\t\t\tV++;\n\t\t}\n\t\tfor(int i=0;i<V;i++)\n\t\tfor(int j=0;j<V;j++){\n\t\t\tco[i][j]=INF;\n\t\t\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[i][j]=='o'){\n\t\t\t\tfunc(i,j,0);\n\t\t\t}else if(s[i][j]=='*'){\n\t\t\t\tfunc(i,j,mp[P(i,j)]);\n\t\t\t}\n\t\t}\n\t\t\n\t\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<limits.h>\n#define INF 100000\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h;\nint imap[21][21];\nint djd[20][2]; // 0->x ,1->y\nint mmaapp[20][20];\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\nint bfs(int sp,int gp){\n  int mmap[21][21];\n \n  for(int i=0;i<21;i++)for(int j=0;j<21;j++)mmap[i][j] = INF;\n  queue<P> que;\n  que.push(P(djd[sp][0],djd[sp][1]));\n  mmap[djd[sp][1]][djd[sp][0]]=0;\n\n  while(que.size()){\n    P p = que.front();que.pop();\n\n    if(p.first == djd[gp][0] && p.second == djd[gp][1])return mmap[djd[gp][1]][djd[gp][0]];\n\n    for(int i=0;i<4;i++){\n      int nx = p.first+dx[i],ny = p.second+dy[i];\n      if(0<=nx && nx < w && 0<=ny && ny < h && mmap[ny][nx] == INF && imap[ny][nx] != -1){\n\tque.push(P(nx,ny));\n\tmmap[ny][nx] = mmap[p.second][p.first] + 1;\n      }\n    }\n  }\n  return -3;\n}\n\n\n\nint main(){\n  char in;\n  int count;\n  while(true){\n    cin >> w >> h;\n    if(w+h == 0)break;\n    count=1;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> in;\n\tswitch(in){\n\tcase '.':\n\t  imap[i][j]=0;\n\t  break;\n\tcase 'o':\n\t  imap[i][j]=0;\n\t  djd[0][0]=j;\n\t  djd[0][1]=i;\n\t  break;\n\tcase 'x':\n\t  imap[i][j]=-1;\n\t  break;\n\tcase '*':\n\t  imap[i][j]=0;\n\t  djd[count][0]=j;\n\t  djd[count][1]=i;\n\t  count++;\n\t  break;\n\tdefault:\n\t  cout << \"erro\" << endl; \n\t  break;\n\t}\n      }\n    }\n\n    for(int i=0;i<count;i++){\n      for(int j=0;j<count;j++){\n\tmmaapp[i][j] = bfs(i,j);\n\t//\tcout << mmaapp[i][j] << \" \";\n      }\n      //      cout << endl;\n    }\n\n\n\n    int dp[(1<<count)+2][count+2];\n    rep(i,(1<<count)+2)rep(j,count+2)dp[i][j]=INF;\n    for(int i=0;i<count;i++)dp[(1<<count)-1][i]=mmaapp[0][i];\n\n    for(int S=(1<<count)-2;S>=0;S--){\n      for(int v=0;v<count;v++){\n\tfor(int u=0;u<count;u++){\n\t  if(!(S>>u & 1)){\n\t    dp[S][v]=min(dp[S][v],dp[S| 1<<u][u] + mmaapp[v][u]);\n\t  }\n\t}\n      }\n    }\n    int ans=INF;\n    for(int i=0;i<count;i++){\n      ans = min(ans,dp[(1<<i)][i]);\n    }\n\n    if(ans <= -3)cout << \"-1\" << endl;\n    else cout << ans << endl;\n\n\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#define INF 1<<30\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h;\nchar cmap[30][30];\nint imap[30][30];\nint bfsd[60][60];\nint d[60][60];\nint dd[60];\nbool ddused[60];\nP pointUsed[60];\nint index;\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,1,0,-1}; \nint counter;\nint ssx,ssy;\nint sindex;\n\nvoid bfs(int sf,int ss){\n  queue<P> que;\n  que.push(P(sf,ss));\n  for(int i=0;i<h;i++)for(int j=0;j<w;j++)bfsd[i][j]=INF;\n  bfsd[ss][sf]=0;\n\n  while(que.size()){\n    P p = que.front(); que.pop();\n\n    for(int i=0;i<4;i++){\n      int nx = p.first + dx[i],ny = p.second + dy[i];\n      if(0<= nx && nx < w && 0<= ny && ny < h && bfsd[ny][nx] == INF && cmap[ny][nx] != 'x'){\n\tbfsd[ny][nx] = bfsd[p.second][p.first]+1;\n\tque.push(P(nx,ny));\n\tif(cmap[ny][nx] == '*' || cmap[ny][nx] == 'o'){\n\t  counter++;\n\t  //cout << imap[ss][sf]+50 << \"  \" << imap[ny][nx]+50 << endl;\n\t  d[ imap[ss][sf]+50 ][ imap[ny][nx]+50 ] = bfsd[ny][nx];\n\t  d[ imap[ny][nx]+50 ][ imap[ss][sf]+50 ] = bfsd[ny][nx];\n\t}\n\n      }\n\n    }\n\n\n\n  }\n\n}\n\nint dijkstra(){ // let dijkstra be prim\n  for(int i=0;i<index;i++){\n    ddused[i]=false;\n    dd[i]=INF;\n  }    \n  for(int i=0;i<index;i++){\n    if(i != sindex){\n      dd[i]=0;\n      break;\n    }\n  }\n  int res=0;\n\n  while(true){\n    int v = -1;\n    for(int u=0;u<index;u++)if(u != sindex && !ddused[u] && ( v == -1 || dd[v] > dd[u]))v=u;\n    if(v == -1)break;\n    ddused[v]=true;\n    res+=dd[v];\n    \n\n    for(int u=0;u<index;u++){\n      if(u!=sindex)dd[u] = min(dd[u],d[v][u]);\n    }\n  }\n  \n  return res;\n\n}\n\n\n\n\nint main(){\n  int sx,sy;\n  int dirtyIndex;\n  P dirtyPoint[500]; //let first be x and second be y\n  while(true){\n    cin >> w >> h;\n    if(w + h == 0)break;\n   \n    index=0;\n    dirtyIndex=-50;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> cmap[i][j];\n\tswitch(cmap[i][j]){\n\tcase '.':\n\t  imap[i][j]=0;\n\t  break;\n\tcase 'o':\n\t  imap[i][j]=dirtyIndex;\n\t  dirtyIndex++;\n\t  pointUsed[index] = P(j,i);\n\t  sindex=index;\n\t  ++index;\n\t  sy=i;\n\t  sx=j;\n\t  ssx = sx;\n\t  ssy = sy;\n\t  break;\n\tcase '*':\n\t  dirtyPoint[index].first = j;\n\t  dirtyPoint[index].second = i;\n\t  imap[i][j] = dirtyIndex;\n\t  dirtyIndex++;\n\t  pointUsed[index] = P(j,i);\n\t  ++index;\n\t  break;\n\tcase 'x':\n\t  imap[i][j]=-1;\n\t  break;\n\tdefault:\n\t  break;\n\t}\n      }\n    }\n    bool fin=false;\n    for(int i=0;i<index;i++){\n      counter=1;\n      bfs(pointUsed[i].first,pointUsed[i].second);\n      if(i == 0 && counter != index){\n\tcout << \"-1\" << endl;\n      fin=true;\n      break;\n      }\n\n    }\n\n    if(fin)continue;\n   \n   int kotae = dijkstra();\n\n    int min=INF;\n    for(int i=0;i<index;i++){\n      if(i == sindex)continue;\n      if(d[sindex][i] < min)min = d[sindex][i];\n    }\n    cout << min+kotae << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (n); i ++)\n\nstruct state {\n        int y;\n        int x;\n        int step;\n};\n\nstatic const int dx[] = { 1, -1, 0, 0 }, dy[] = { 0, 0, 1, -1 };\nstatic const int INF = 0x3f3f3f3f;\n\nvoid dfs(int s, vector<vector<int>>& g, int cnt, int cost, int& ans, int V, vector<int>& used_dfs) {\n        if (cnt == V) {\n                ans = min(ans, cost);\n                return;\n        }\n        used_dfs[s] = true;\n        for (int v = 0; v < V; v ++) {\n                if (g[s][v] != INF && !used_dfs[v]) {\n                        cost += g[s][v];\n                        dfs(v, g, cnt + 1, cost, ans, V, used_dfs);\n                        cost -= g[s][v];\n\n                }\n        }\n        used_dfs[s] = false;\n        return;\n}\n\nint main() {\n        int w, h;\n        while (cin >> w >> h && w) {\n                vector<string> room(h);\n                rep(i, h) cin >> room[i];\n                int V = 0;\n                int sx, sy;\n                vector<pair<int, int>> node;\n                rep(y, h) {\n                        rep(x, w) {\n                                if (room[y][x] == 'o') {\n                                        V ++;\n                                        sy = y;\n                                        sx = x;\n                                }\n                                if (room[y][x] == '*') {\n                                        V ++;\n                                        node.emplace_back(y, x);\n                                }\n                        }\n                }\n                node.emplace_back(sy, sx);\n                reverse(node.begin(), node.end()); //node[0]??????????????????node[1] ~ node[V - 1]????±?????????¨?±?\n                vector<vector<int>> g(V, vector<int> (V, INF));\n                bool cantgo = false;\n                for (int i = 0; i < V; i ++) {\n                        for (int j = i + 1; j < V; j ++) {\n                                int cost = 0;\n                                int starty = node[i].first;\n                                int startx = node[i].second;\n                                int goaly = node[j].first;\n                                int goalx = node[j].second;\n                                queue<state> q;\n                                vector<vector<bool>> used(h, vector<bool> (w, false));\n                                q.push({starty, startx, 0});\n                                used[starty][startx] = true;\n                                while (!q.empty()) {\n                                        state now = q.front(); q.pop();\n                                        if (now.y == goaly && now.x == goalx) {\n                                                cost = now.step;\n                                                break;\n                                        }\n                                        for (int d = 0; d < 4; d ++) {\n                                                state next;\n                                                next.y = now.y + dy[d];\n                                                next.x = now.x + dx[d];\n                                                if (h <= next.y || next.y < 0 || w <= next.x || next.x < 0 ||\n                                                    used[next.y][next.x] || room[next.y][next.x] == 'x') {\n                                                        continue;\n                                                }\n                                                used[next.y][next.x] = true;\n                                                next.step = now.step + 1;\n                                                q.push(next);\n                                        }\n                                }\n                                if (cost == 0) cantgo = true;\n                                g[i][j] = cost;\n                                g[j][i] = cost;\n                        }\n                }\n                if (cantgo) {\n                        cout << -1 << endl;\n                        continue;\n                }\n                int ans = INF;\n                vector<int> used_dfs(V, 0);\n                dfs(0, g, 1, 0, ans, V, used_dfs);\n                cout << ans << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nint dx[] = {0, -1, 1, 0};\nint dy[] = {-1, 0, 0, 1};\n\nclass Pos\n{\npublic:\n\tint x,y,c;\n\tPos(int x, int y, int c)\n\t:x(x), y(y), c(c)\n\t{}\n};\n\nclass Robot\n{\npublic:\n\tint p,c,h;\n\t\n\tRobot(int p, int c, int h)\n\t:p(p),c(c),h(h)\n\t{}\n\t\n\tbool operator<(const Robot& r) const\n\t{\n\t\treturn c>r.c;\n\t}\n};\n\nint main()\n{\n\tint fx,fy;\n\twhile(cin >> fx >> fy, (fx||fy))\n\t{\n\t\tint N=1;\n\t\tint f[21][21],c[12][12];\n\t\t\n\t\tfor(int j=0; j<fy; j++)\n\t\t{\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tfor(int i=0; i<fx; i++)\n\t\t\t{\n\t\t\t\tif(s[i]=='o')\n\t\t\t\t{\n\t\t\t\t\tf[i][j]=0;\n\t\t\t\t}\n\t\t\t\telse if(s[i]=='*')\n\t\t\t\t{\n\t\t\t\t\tf[i][j]=N;\n\t\t\t\t\tN++;\n\t\t\t\t}\n\t\t\t\telse if(s[i]=='x')\n\t\t\t\t{\n\t\t\t\t\tf[i][j]=-2;\n\t\t\t\t}\n\t\t\t\telse f[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int j=0; j<N; j++)\n\t\tfor(int i=0; i<N; i++)\n\t\t\tc[i][j]=-1;\n\t\t\t\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tqueue<Pos> q;\n\t\t\tfor(int x=0; x<fx; x++)\n\t\t\tfor(int y=0; y<fy; y++)\n\t\t\t{\n\t\t\t\tif(f[x][y] == i)\n\t\t\t\t{\n\t\t\t\t\tq.push(Pos(x,y,0));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tbool tf[21][21]={0};\n\t\t\twhile(!q.empty())\n\t\t\t{\n\t\t\t\tPos p=q.front(); q.pop();\n\t\t\t\tif(f[p.x][p.y] >= 0 && f[p.x][p.y] <= 9)\n\t\t\t\t{\n\t\t\t\t\tc[i][f[p.x][p.y]] = p.c;\n\t\t\t\t\tc[f[p.x][p.y]][i] = p.c;\n\t\t\t\t}\n\t\t\t\ttf[p.x][p.y]=1;\n\t\t\t\t\n\t\t\t\tfor(int j=0; j<4; j++)\n\t\t\t\t{\n\t\t\t\t\tint tx=p.x+dx[j], ty=p.y+dy[j];\n\t\t\t\t\tif(tx<0||ty<0||tx>=fx||ty>=fy) continue;\n\t\t\t\t\tif(tf[tx][ty]) continue;\n\t\t\t\t\tif(f[tx][ty]==-2) continue;\n\t\t\t\t\t\n\t\t\t\t\ttf[tx][ty]=1;\n\t\t\t\t\t\n\t\t\t\t\tq.push(Pos(tx,ty,p.c+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpriority_queue<Robot> q;\n\t\tq.push(Robot(0,0,1));\n\t\t\n\t\tbool g=false;\n\t\tbool v[11][1<<11]={0};\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tRobot r=q.top(); q.pop();\n\t\t\tif(v[r.p][r.h]) continue;\n\t\t\tv[r.p][r.h]=1;\n\t\t\tif(r.h==(1<<N)-1)\n\t\t\t{\n\t\t\t\tg=true;\n\t\t\t\tcout << r.c << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=1; i<N; i++)\n\t\t\t{\n\t\t\t\tif(c[r.p][i]==-1) continue;\n\t\t\t\tif(r.h&(1<<i)) continue;\n\t\t\t\tint th=r.h|(1<<i);\n\t\t\t\tif(v[i][th]) continue;\n\t\t\t\t\n\t\t\t\tq.push(Robot(i, r.c+c[r.p][i], th));\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!g) cout << -1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint c[11][11],e[11][2048],n;\nvoid fn(int p,int q,int r,int s){\n  int i;\n  if(q==n){\n    e[p][r]=min(e[p][r],s);\n  }else if(e[p][r]>s){\n    e[p][r]=s;\n    for(i=0;i<n;i++)\n      fn(i,q+1,r|(1<<i),s+c[p][i]);\n  }\n  return;\n}\nint main(){\n  int i,j;\n  int a[22][22],d[22][22],x[11],y[11],p,q,r,w,h;\n  int mn;\n  char s;\n  queue<pair<pair<int,int>,int> > b;\n  while(cin>>w>>h&&w+h){\n    memset(a,-1,sizeof(a));\n    n=1;\n    for(i=1;i<h+1;i++){\n      for(j=1;j<w+1;j++){\n\tcin>>s;\n\tif(0){\n\t}else if(s=='*'){\n\t  a[j][i]=n;\n\t  x[n]=j;\n\t  y[n]=i;\n\t  n++;\n\t}else if(s!='x'){\n\t  a[j][i]=0;\n\t  if(s=='o'){\n\t    x[0]=j;\n\t    y[0]=i;\n\t  }\n\t}\n      }\n    }\n    for(i=0;i<n;i++)\n      for(j=0;j<n;j++)\n\tc[j][i]=512;\n    for(i=0;i<n-1;i++){\n      while(b.empty()==0)\n\tb.pop();\n      b.push(make_pair(make_pair(x[i],y[i]),0));\n      memset(d,-1,sizeof(d));\n      for(j=0;j<n-i-1&&b.empty()==0;){\n\tp=b.front().first.first;\n\tq=b.front().first.second;\n\tr=b.front().second;\n\tb.pop();\n\tif(a[p][q]!=-1&&d[p][q]==-1){\n\t  d[p][q]=1;\n\t  if(i<a[p][q]){\n\t    c[i][a[p][q]]=c[a[p][q]][i]=min(c[i][a[p][q]],r);\n\t    j++;\n\t  }\n\t  b.push(make_pair(make_pair(p-1,q),r+1));\n\t  b.push(make_pair(make_pair(p,q-1),r+1));\n\t  b.push(make_pair(make_pair(p+1,q),r+1));\n\t  b.push(make_pair(make_pair(p,q+1),r+1));\n\t}\n      }\n    }    \n    for(i=0;i<n;i++)\n      for(j=0;j<2048;j++)\n\te[i][j]=512;\n    fn(0,0,1,0);\n    mn=0;\n    for(i=1;i<n;i++){\n      if(e[mn][~((~0)<<n)]>e[i][~((~0)<<n)])\n\tmn=i;\n    }\n    if(e[mn][~((~0)<<n)]==512)\n      cout<<-1<<endl;\n    else\n      cout<<e[mn][~((~0)<<n)]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <queue>\n#include <algorithm>\n#define INF (1<<21)\nusing namespace std;\n\nclass Point{\npublic:\n  int x,y,c;\n  Point(int x = 0,int y = 0,int c = 0):x(x),y(y),c(c){}\n};\n\nint main(){\n  int i,j,k,l,h,w,sum,ans,gomi[20][20],G[11][11];\n  bool f[20][20],f2[20][20];\n  string str;\n  while(1){\n    Point u,v,g;\n    cin >> w >> h;\n    if(h == 0 && w == 0) break;\n    ans = INF;\n    sum = 0;\n\n    for(i=0;i<h;i++){\n      cin >> str;\n      for(j=0;j<w;j++){\n\tgomi[i][j] = -1;\n\tf[i][j] = false;\n\tif(str[j] == 'o') gomi[i][j] = 0;\n\telse if(str[j] == 'x') f[i][j] = true;\n\telse if(str[j] == '*') gomi[i][j] = ++sum;\n      }\n    }\n    \n    for(i=0;i<sum;i++){\n      for(j=i+1;j<=sum;j++){\n\tfor(k=0;k<h;k++){\n\t  for(l=0;l<w;l++){\n\t    f2[k][l] = f[k][l];\n\t    if(gomi[k][l] == i){\n\t      u.y = k;\n\t      u.x = l;\n\t      f2[k][l] = true;\n\t    }\n\t    else if(gomi[k][l] == j){\n\t      g.y = k;\n\t      g.x = l;\n\t    }\n\t  }\n\t}\n\t\n\tqueue <Point> Q;\n\tbool ff = true;\n\tu.c = 0;\n\tQ.push(u);\n\twhile(!Q.empty()){\n\t  u = Q.front();\n\t  Q.pop();\n\t  if(g.x == u.x && g.y == u.y){\n\t    G[i][j] = G[j][i] = u.c;\n\t    ff = false;\n\t    break;\n\t  }\n\t  u.c++;\n\t  int dx[4] = {1,0,-1,0};\n\t  int dy[4] = {0,1,0,-1};\n\t  for(k=0;k<4;k++){\n\t    v = u;\n\t    v.x += dx[k];\n\t    v.y += dy[k];\n\t    if(v.x >= 0 && v.x < w && v.y >= 0 && v.y < h && !f2[v.y][v.x]){\n\t\tf2[v.y][v.x] = true;\n\t\tQ.push(v);\n\t      }\n\t   }\n\t}\n\t  if(ff){\n\t    ans = -1;\n\t    break;\n\t  }\n      }\n\tif(ans == -1) break;\n    }\n    \n      if(ans != -1){\n\tint a[11],be,af,A;\n\tfor(i=0;i<=sum;i++) a[i] = i;\n\tdo{\n\t  if(a[0] != 0) break;\n\t  A = 0;\n\t  be = a[0];\n\t  for(i=1;i<=sum;i++){\n\t    af = a[i];\n\t    A += G[be][af];\n\t    be = af;\n\t  }\n\t  ans = min(ans,A);\n\t} while(next_permutation(a,a+sum+1));\n      }\n      cout << ans << endl;\n\t\t\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n#include <utility>\n#define INF 0x3FFFFFFF\n\nusing namespace std;\n\n\nint main(void){\n\tint n, h, w, i, j, k, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0}, s[11][20][20], d[11][11], a, b, dp[11][1 << 10], min;\n\tpair<int,int> l[11];\n\tqueue<pair<int,int> > que;\n\tchar field[20][21];\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tn = 1;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tfield[i][j] = getchar();\n\t\t\t\tif(field[i][j] == '*') l[n].first = j,l[n++].second = i, field[i][j] = '.';\n\t\t\t\telse if(field[i][j] == 'o') l[0].first = j, l[0].second = i, field[i][j] = '.';\n\t\t\t}\n\t\t\tgetchar();\n\t\t}\n\t\tmemset(s,-1,sizeof(s));\n\t\tfor(i = 0;i < n;i++){\n\t\t\tque.push(l[i]);\n\t\t\ts[i][que.front().second][que.front().first] = 0;\n\t\t\twhile(que.size()){\n\t\t\t\ta = que.front().first, b = que.front().second;\n\t\t\t\tfor(j = 0;j < 4;j++){\n\t\t\t\t\tif(a + dx[j] >= 0 && a + dx[j] < w && b + dy[j] >= 0 && b + dy[j] < h && field[b + dy[j]][a + dx[j]] == '.' && s[i][b + dy[j]][a + dx[j]] == -1){\n\t\t\t\t\t\tque.push(pair<int,int>(a + dx[j],b + dy[j]));\n\t\t\t\t\t\ts[i][b + dy[j]][a + dx[j]] = s[i][b][a] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tque.pop();\n\t\t\t}\n\t\t}\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 1;j < n;j++){\n\t\t\t\td[i][j] = s[i][l[j].second][l[j].first];\n\t\t\t\tif(i != 0){\n\t\t\t\t\td[j][i] = s[i][l[j].second][l[j].first];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i = 0;i < 1 << (n - 1);i++)\n\t\t\tfor(j = 0;j < n;j++) dp[j][i] = INF;\n\t\tdp[0][0] = 0;\n\t\tfor(i = 0;i < 1 << (n - 1);i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tfor(k = 1;k < n;k++){\n\t\t\t\t\tif(~i & (1 << (k - 1)) && dp[k][i | (1 << (k - 1))] > dp[j][i] + d[j][k])\n\t\t\t\t\t\tdp[k][i | (1 << (k - 1))] = dp[j][i] + d[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmin = INF;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tif(min > dp[i][(1 << (n - 1)) - 1]) min = dp[i][(1 << (n - 1)) - 1];\n\t\tprintf(\"%d\\n\",min >= INF - 0x2000000 ? -1 : min);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint w, h;\nvector<string> tile(20);\nint dist[11][11];\nbool visited[20][20];\nint dd[] = {1, 0, -1, 0, 1};\n\nbool range(int x, int y) {\n  return 0 <= x && x < w && 0 <= y && y < h;\n}\n\nvoid wfs(PIP s, vector<PIP> &v) {\n  rep(i, h)rep(j, w) visited[i][j] = false;\n  visited[s.se.fi][s.se.se] = true;\n\n  priority_queue<PIP, vector<PIP>, greater<PIP>> q;\n  q.push(PIP(0, s.se));\n\n  while(!q.empty()) {\n    PIP p = q.top(); q.pop();\n\n    repl(i, 1, v.size()) {\n      if (p.fi > 0 && p.se == v[i].se) dist[s.fi][i] = p.fi;\n    }\n\n    rep(i, 4) {\n      int y = p.se.fi + dd[i], x = p.se.se + dd[i + 1];\n      if (range(x, y) && !visited[y][x] && tile[y][x] != 'x') {\n        q.push(PIP(p.fi + 1, P(y, x)));\n        visited[y][x] = true;\n      }\n    }\n  }\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  while(cin >> w >> h, w | h) {\n    vector<PIP> v;\n    int num = 1;\n    rep(i, h) {\n      cin >> tile[i];\n      rep(j, w) {\n        if (tile[i][j] == '*') v.pb(PIP(num++, P(i, j)));\n        else if (tile[i][j] == 'o') v.pb(PIP(0, P(i, j)));\n      }\n    }\n    sort(all(v));\n\n    int size = v.size();\n    rep(i, size)rep(j, size) dist[i][j] = INF;\n\n    bool ok = true;\n    rep(i, size) {\n      wfs(v[i], v);\n      if (i == 0) {\n        repl(j, 1, size) if (dist[0][j] == INF) ok = false;\n        if (!ok) break;\n      }\n    }\n\n    if (ok) {\n      vector<int> dp(1 << (size - 1), INF);\n      repl(i, 1, size) dp[(1 << i - 1)] = dist[0][i];\n\n      rep(i, 1 << (size - 1)) {\n        repl(j, 1, size) {\n          if (i & (1 << j - 1)) {\n            repl(k, 1, size) {\n              if (!(i & (1 << k - 1))) minch(dp[i + (1 << k - 1)], dp[i] + dist[j][k]);\n            }\n          }\n        }\n      }\n\n      cout << dp[dp.size() - 1] << endl;\n    } else {\n      cout << -1 << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define ll long long\n#define ll1 1ll\n#define ONE 1ll\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\nsizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nusing pii = pair<int, int>;\n// template<class T> ostream &operator<<(ostream &os,T &t){dump(t);return os;}\ntemplate <typename T, typename S>\nistream &operator>>(istream &is, pair<T, S> &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> &p) {\n\tos << p.first << \" \" << p.second;\n\treturn os;\n}\n\ntemplate <typename T> void printvv(const vector<vector<T>> &v) {\n\tcerr << endl;\n\trep(i, 0, v.size()) rep(j, 0, v[i].size()) {\n\t\tif (typeid(v[i][j]).name() == typeid(INF).name() and v[i][j] == INF) {\n\t\t\tcerr << \"INF\";\n\t\t}\n\t\telse\n\t\t\tcerr << v[i][j];\n\t\tcerr << (j == v[i].size() - 1 ? '\\n' : ' ');\n\t}\n\tcerr << endl;\n}\n/*\ntypedef __int128_t Int;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\nstd::ostream::sentry s(dest);\n  if (s) {\n\t__uint128_t tmp = value < 0 ? -value : value;\n\tchar buffer[128];\n\tchar *d = std::end(buffer);\n\tdo {\n\t  --d;\n\t  *d = \"0123456789\"[tmp % 10];\n\t  tmp /= 10;\n\t} while (tmp != 0);\n\tif (value < 0) {\n\t  --d;\n\t  *d = '-';\n\t}\n\tint len = std::end(buffer) - d;\n\tif (dest.rdbuf()->sputn(d, len) != len) {\n\t  dest.setstate(std::ios_base::badbit);\n\t}\n  }\n  return dest;\n}\n\n__int128 parse(string &s) {\n  __int128 ret = 0;\n  for (int i = 0; i < s.length(); i++)\n\tif ('0' <= s[i] && s[i] <= '9')\n\t  ret = 10 * ret + s[i] - '0';\n  return ret;\n}\n*/\n\n#ifndef _DEBUG\n#define printvv(...)\n#endif\nvoid YES(bool f) { cout << (f ? \"YES\" : \"NO\") << endl; }\nvoid Yes(bool f) { cout << (f ? \"Yes\" : \"No\") << endl; }\ntemplate <class T> bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(12);\n\n\tint W, H; \n\twhile (cin >> W >> H, W&&H) {\n\t\tvector<string>v(H); rep(i, 0, H) { cin >> v[i]; }\n\t\tint dx[] = { 1, 0, -1, 0 }, dy[] = { 0, 1, 0, -1 };\n\t\tauto inrange = [&](int x, int y) { return 0 <= x and x < H and 0 <= y and y < W; };\n\t\tvector<vector<int>>cost(W*H, vector<int>(W*H, INF));\n\t\tvector<int>p;\n\t\tint s;\n\t\trep(i, 0, H)rep(j, 0, W) {\n\t\t\tif (v[i][j] == 'x')continue;\n\t\t\tcost[i*W + j][i*W + j] = 0;\n\t\t\tif (v[i][j] == 'o')s = i * W + j;\n\t\t\telse if (v[i][j] == '*')p.eb(i*W + j);\n\t\t\trep(k, 0, 4) {\n\t\t\t\tint x = i + dx[k], y = j + dy[k];\n\t\t\t\tif (not inrange(x, y))continue;\n\t\t\t\tif (v[x][y] != 'x') {\n\t\t\t\t\tcost[i*W + j][x*W + y] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(k, 0, cost.size())rep(i, 0, cost.size())rep(j, 0, cost.size())chmin(cost[i][j], cost[i][k] + cost[k][j]);\n\t\tp.eb(s);\n\t\treverse(all(p));\n\t\tint n = p.size();\n\t\tvector<vector<int>>dp(1 << p.size(), vector<int>(p.size(), INF));\n\t\tdp[1][0] = 0;\n\t\trep(mask, 1, 1 << n) {\n\t\t\trep(i, 0, n) {\n\t\t\t\trep(j, 0, n) {\n\t\t\t\t\tif ((mask >> j) & 1)continue;\n\t\t\t\t\tchmin(dp[mask ^ (1 << j)][j], dp[mask][i] + cost[p[i]][p[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = *min_element(all(dp.back()));\n\t\tdump(ans);\n\t\tif (ans == INF)ans = -1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\n#define INF 1e9\n\nbool isin(int i, int j, int h, int w){\n    return i>=0 && j>=0 && i<h && j<w;\n}\n\nint main() {\n    int w, h;\n\n    while (cin >> w >> h && w) {\n        VVI f(h,VI(w));\n        vector<P> p(1);\n        REP(i,h) {\n            string s;\n            cin >> s;\n            REP(j,w) {\n                if (s[j] == 'o') p[0] = make_pair(i, j);\n                if (s[j] == '*') p.push_back(make_pair(i, j));\n                if (s[j] == 'x') f[i][j] = 1;\n            }\n        }\n        int n = p.size();\n        VVI dist(n, VI(n));\n        REP(x,n){\n            VVI d(h,VI(w));\n            queue<P> que;\n            d[p[x].first][p[x].second] = 1;\n            que.push(make_pair(p[x].first, p[x].second));\n            int dx[] = {1,-1,0,0}, dy[] = {0,0,1,-1};\n            while (!que.empty()){\n                P po = que.front();\n                que.pop();\n                int i = po.first, j = po.second;\n                REP(k,4){\n                    int ii = i+dx[k], jj = j+dy[k];\n                    if (!isin(ii,jj,h,w) || d[ii][jj] > 0 || f[ii][jj]) continue;\n                    d[ii][jj] = d[i][j] + 1;\n                    que.push(make_pair(ii, jj));\n                }\n            }\n            REP(y,n){\n                dist[x][y] = d[p[y].first][p[y].second] - 1;\n            }\n        }\n        bool flag = 0;\n        REP(i,n) REP(j,n) {\n            if (dist[i][j] == -1){\n                flag = 1;\n            }\n        }\n        if (flag) {\n            cout << -1 << endl;\n            continue;\n        }\n\n        VVI dp(1<<n, VI(n, INF));\n        dp[1][0] = 0;\n        REP(i,1<<n) REP(j,n) REP(k,n) {\n            if ((i>>k) & 1) continue;\n            dp[i | (1<<k)][k] = min(dp[i | (1<<k)][k], dp[i][j] + dist[j][k]);\n        }\n\n        int ans = 1e9;\n        REP(j,n) ans = min(ans, dp[(1<<n)-1][j]);\n        cout << ans << endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Ryo Kamoi\n// #define DEBUG\n\n#include<iostream>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<cstring>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\ntypedef pair<int, pii> piii;\n\nint INF = 1000000000;\n\nint w, h;\nint dist[20][20];\nint tile[30][30];\nint tile_dist[30][30];\nvector<pii> points;\nint dirty_num;\n\nint x[4] = {0, 0, -1, 1};\nint y[4] = {-1, 1, 0, 0};\n\nint dp[1 << 12][12];\n\nvoid init_dist() {\n    REP(i, h) {\n        REP(j, w) {\n            tile_dist[i][j] = INF;\n        }\n    }\n}\n\nvoid calc_dist(int idx) {\n    init_dist();\n    queue<piii> que;\n    que.push(piii(0, points[idx]));\n    tile_dist[points[idx].first][points[idx].second] = 0;\n\n    while (!que.empty()) {\n        piii p = que.front(); que.pop();\n        int d = p.first;\n        int ih = p.second.first;\n        int jw = p.second.second;\n        if (tile_dist[ih][jw] != d) continue;\n        \n        REP(i, 4) {\n            int ni = ih + y[i];\n            int nj = jw + x[i];\n\n            if (ni<0 || ni>=h || nj<0 || nj>=w) continue;\n            if (tile[ni][nj] == -1) continue;\n            if (tile_dist[ni][nj] <= d + 1) continue;\n            tile_dist[ni][nj] = d+1;\n            que.push(piii(d + 1, pii(ni, nj)));\n        }\n    }\n\n    REP(i, dirty_num+1) {\n        dist[idx][i] = tile_dist[points[i].first][points[i].second];\n    }\n}\n\n// S: history, v: current state\nint tsp(int S, int v) {\n    if (dp[S][v] >= 0) {\n        return dp[S][v];\n    }\n\n    if (S==(1<<(dirty_num+1))-1) {\n        return dp[S][v] = 0;\n    }\n\n    int res = INF;\n    REP(u, dirty_num+1) {\n        if (!(S>>u & 1)) {\n            res = min(res, tsp(S|1<<u, u) + dist[v][u]);\n        }\n    }\n    return dp[S][v] = res;\n}\n\nint main(){\n    while(1) {\n        cin >> w >> h;\n        if (w==0) break;\n\n        REP(i, h) {\n            REP(j, w) {\n                tile[i][j] = 0;\n            }\n        }\n\n        points = vector<pii>();\n        dirty_num = 0;\n        REP(i, h) {\n            string row;\n            cin >> row;\n            REP(j, w) {\n                if (row[j] == 'o') {\n                    points.insert(points.begin(), pii(i, j));\n                }\n                if (row[j] == '*') {\n                    dirty_num ++;\n                    points.push_back(pii(i, j));\n                }\n                if (row[j] == 'x') {\n                    tile[i][j] = -1;\n                }\n            }\n        }\n\n        REP(i, dirty_num+1) {\n            REP(j, dirty_num+1) {\n                dist[i][j] = INF;\n            }\n        }\n\n        REP(i, dirty_num+1) {\n            calc_dist(i);\n        }\n\n#ifdef DEBUG\n        REP(i, dirty_num+1) {\n            REP(j, dirty_num+1) {\n                cout << dist[i][j] << \" \";\n            }\n            cout << endl;\n        }\n#endif\n\n        bool end = false;\n        REP(i, dirty_num+1) {\n            if (dist[0][i] == INF) {\n                cout << -1 << endl;\n                end = true;\n                break;\n            }\n        }\n        if (end) continue;\n\n        // TSP\n        memset(dp, -1, sizeof(dp));\n        cout << tsp(1, 0) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstruct P{\n\tint x,y;\n} s;\nint w, h;\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nint to[12][12];\nint cnt[21][21];\nstring f[21];\n\nvoid solve(int x, int y, int cnt_,int from ,vector<struct P>& vc){\n\t\n\tfor(int i=0 ; i<4 ; i++ ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ){\n\t\t\tcontinue;\n\t\t}else if( cnt[my][mx] == -1 ){\n\t\t\tcontinue;\n\t\t}else if( cnt[my][mx] > cnt_ ){\n\t\t\tcnt[my][mx] = cnt_;\n\t\t\tif( f[my][mx] == '.' ){\n\t\t\t\tsolve( mx , my , cnt_+1 , from , vc );\n\t\t\t}else if( f[my][mx] == '*' ){\n\t\t\t\tfor(int j=0 ; j < (int)vc.size() ; j++ ){\n\t\t\t\t\tif( vc[j].x == mx && vc[j].y == my ){\n\t\t\t\t\t\tto[from][j+1] = cnt_;\n\t\t\t\t\t\tto[j+1][from] = cnt_;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\nvoid debug(int x,int y,char c){\n\tcout << c << \":(x,y) = (\" << x << \",\" << y << \")\\n\";\n}*/\n\nint main(){\n\twhile( cin >> w >> h , w||h ){\n\t\tvector<struct P> vc;\n\t\tfor(int y=0 ; y<12 ; y++ ){\n\t\t\tfor(int x=0 ; x<12 ; x++ ){\n\t\t\t\tto[y][x] = 1000;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> f[y];\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tif( f[y][x] == 'o' ){\n\t\t\t\t\tcnt[y][x] = -1;\n\t\t\t\t\ts.x = x, s.y = y;\n\t\t\t\t}else if( f[y][x] == '*' ){\n\t\t\t\t\tstruct P p;\n\t\t\t\t\tp.x = x, p.y = y;\n\t\t\t\t\tvc.push_back( p );\t\t\t\t\n\t\t\t\t}else if( f[y][x] == 'x' ){\n\t\t\t\t\tcnt[y][x] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i <= (int)vc.size() ; i++ ){\n\t\t\tfor(int y=0 ; y<21 ; y++ )\n\t\t\t\tfor(int x=0 ; x<21 ; x++ )\n\t\t\t\t\tif( cnt[y][x] != -1 )\n\t\t\t\t\t\tcnt[y][x] = 1000;\n\t\t\tif( i > 0 ){\n\t\t\t\tcnt[ vc[i-1].y ][ vc[i-1].x ] = -1;\n\t\t\t\tsolve( vc[i-1].x , vc[i-1].y , 1 , i , vc );\n\t\t\t}else{\n\t\t\t\tsolve( s.x , s.y , 1 , i , vc );\n\t\t\t}\n\t\t}\n\n\t\tvector<int> vc_;\n\t\tbool flag = true;\n\t\tint ans = 10000000;\n\t\tfor(int i=0 ; i < (int)vc.size() ; i++ )\n\t\t\tvc_.push_back( i+1 );\n\t\tdo{\n\t\t\tint ans_ = 0;\n\t\t\tfor(int i=0 ; i < (int)vc_.size() ; i++ ){\n\t\t\t\t//cout << \"+ : \" << to[ ((i==0)? 0 : vc_[i-1]) ][ vc_[i] ] << \" \";\n\t\t\t\tif( to[ ((i==0)? 0 : vc_[i-1]) ][ vc_[i] ] == 1000 ){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tans_ += to[ ((i==0)? 0 : vc_[i-1]) ][ vc_[i] ];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = min( ans_ , ans );\n\t\t}while( next_permutation( vc_.begin() , vc_.end() ) && flag );\n\t\t//cout << endl;\n\t\t\n\t\t/*debug( s.x , s.y , 'S' );\n\t\tfor(int i=0 ; i < (int)vc.size() ; i++ ){\n\t\t\tdebug( vc[i].x , vc[i].y , i+'0' );\n\t\t\t//cout << \"start => \" << to[0][i+1] << endl;\n\t\t}\n\t\tfor(int y=0 ; y <= (int)vc.size() ; y++ ){\n\t\t\tfor(int x=0 ; x <= (int)vc.size() ; x++ ){\n\t\t\t\tcout << to[y][x] << \"  \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tcout << ( (flag)? ans : -1 ) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\nconst int INF = 100000000;\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n\nbool in_range(int a, int b){ return a >= 0 && a < b;}\n\nvoid bfs(map<int,int> &M, vector<int> &G, vector<string> C, int s){\n  int h = C.size(), w = C[0].length();\n  queue< pair<int,int> > que;\n  que.emplace(s,0);\n  while(!que.empty()){\n    int p = que.front().first, d = que.front().second;\n    que.pop();\n    if(M[p])\n      G[M[p]-1] = min(d,G[M[p]-1]);\n    C[p/w][p%w] = 'x';\n    for(int i = 0; i < 4; ++i){\n      int x = p/w + dx[i], y = p%w + dy[i], p_ = x*w + y;\n      if(in_range(x,h) && in_range(y,w) && C[x][y] != 'x')\n        que.emplace(p_,d+1);\n    }\n  }\n}\n\nvector< vector<int> > make_graph(vector<string> &C, vector<int> &D){\n  int h = C.size(), w = C[0].length(), n = D.size();\n  map<int,int> M;\n  for(int i = 0; i < n; ++i){\n    M[D[i]] = i+1;\n  }\n  vector< vector<int> > G(n, vector<int>(n,INF));\n  for(int i = 0; i < n; ++i){\n    bfs(M,G[i],C,D[i]);\n  }\n  return G;\n}\n\nint main(){\n  int w, h;\n  while(cin >> w >> h, w){\n    vector<string> C(h);\n    vector<int> D;\n    int s;\n    for(int i = 0; i < h; ++i){\n      cin >> C[i];\n      for(int j = 0; j < w; ++j){\n        if(C[i][j] == 'o') s = i*w+j;\n        if(C[i][j] == '*'){\n          D.push_back(i*w+j);\n        }\n      }\n    }\n    D.push_back(s);\n    vector< vector<int> > G = make_graph(C,D);\n    int n = G.size()-1;\n    vector<int> V(n);\n    for(int i = 0; i < n; ++i) V[i] = i;\n    int ans = INF;\n    do{\n      int t = 0, v = n;\n      for(int i = 0; i < n; ++i){\n        t += G[v][V[i]];\n        v = V[i];\n      }\n      ans = min(ans,t);\n    }while(next_permutation(V.begin(),V.end()));\n    if(ans >= INF) ans = -1;\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<iostream>\n#include<cmath>\n#include<map>\n#include<set>\n#include<climits>\n#include<ctime>\n#include<complex>\nusing namespace std;\ntypedef vector<string>vs;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\ntypedef vector<double>vd;\ntypedef pair<int,int>pii;\ntypedef long long ll;\ntypedef pair<ll,ll>pll;\ntypedef vector<ll>vl;\n#define rrep(i,x,n) for(int i=(x);i<(n);++i)\n#define rep(i,x) rrep(i,0,(x))\n#define fi first\n#define se second\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define maxs(a,b) (a)=max(a,b)\n#define mins(a,b) (a)=min(a,b)\n\nint dist[11][11];\nint fld[20][20];\nvector<pii>pos;\nint H,W;\nint N;\n\nconst int dx[]={-1,0,1,0};\nconst int dy[]={0,-1,0,1};\nvoid bfs(int s){\n    queue<pii>Q;\n    Q.push(pii(pos[s-1].fi,pos[s-1].se));\n    int D[20][20];fill_n(*D,400,-1);\n    D[pos[s-1].fi][pos[s-1].se]=0;\n    while(!Q.empty()){\n        pii p=Q.front();Q.pop();\n        for(int i=0;i<4;i++){\n            int ty=p.fi+dy[i];\n            int tx=p.se+dx[i];\n            if(ty<0||ty>=H||tx<0||tx>=W)continue;\n            if(D[ty][tx]!=-1)continue;\n            if(fld[ty][tx]==-1)continue;\n            D[ty][tx]=D[p.fi][p.se]+1;\n            Q.push(pii(ty,tx));\n        }\n    }\n    for(int i=0;i<N;i++){\n        dist[s-1][i]=D[pos[i].fi][pos[i].se];\n    }\n}\nint main(){\n\n    while(scanf(\"%d%d\",&W,&H),W||H){\n        fill_n(*dist,11*11,-1);\n        pos=vector<pii>(1);\n        N=1;\n        for(int i=0;i<H;i++){\n            char str[36];\n            scanf(\"%s\",str);\n            for(int j=0;j<W;j++){\n                if(str[j]=='o'){\n                    pos[0]=pii(i,j);\n                    fld[i][j]=1;\n                }\n                else if(str[j]=='x'){\n                    fld[i][j]=-1;\n                }\n                else if(str[j]=='*'){\n                    N++;\n                    pos.pb(pii(i,j));\n                    fld[i][j]=N;\n                }\n                else fld[i][j]=0;\n            }\n        }\n\n        for(int i=1;i<=N;i++)bfs(i);\n\n        vector<int>perm;\n        for(int i=2;i<=N;i++)perm.pb(i);\n        int mi=INT_MAX;\n        do{\n            int now=1,sum=0;\n            for(int i=0;i<perm.size();i++){\n                if(dist[now-1][perm[i]-1]==-1){\n                    sum=INT_MAX;\n                    break;\n                }\n                sum+=dist[now-1][perm[i]-1];\n                now=perm[i];\n            }\n            mi=min(mi,sum);\n        }while(next_permutation(all(perm)));\n\n        printf(\"%d\\n\",(mi==INT_MAX?-1:mi));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define mp make_pair\n#define pb push_back\n#define EB emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint w,h;\n\nvoid solve(){\n    char c[32][32];\n    rep(i,h) scanf(\"%s\",c[i]);\n\n    int sx,sy;\n    rep(i,h) rep(j,w) if(c[i][j]=='o'){\n        sx = i;\n        sy = j;\n        break;\n    }\n\n    int g[512][512];\n    rep(i,512) rep(j,512) g[i][j]=INF;\n    rep(i,512) g[i][i]=0;\n\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(c[i][j]=='x') continue;\n            int v = i*w+j;\n            for(int k=0;k<4;k++){\n                int nx=i+dx[k],ny=j+dy[k];\n                if(nx<0||ny<0||nx>=h||ny>=w) continue;\n                if(c[nx][ny]=='x') continue;\n                int nv = nx*w+ny;\n                g[v][nv] = 1;\n                g[nv][v] = 1;\n            }\n        }\n    }\n\n    int V = h*w;\n    for(int k=0;k<V;k++){\n        for(int i=0;i<V;i++){\n            for(int j=0;j<V;j++){\n                g[i][j] = min(g[i][j],g[i][k]+g[k][j]);\n            }\n        }\n    }\n\n    vector<int> as;\n    rep(i,h) rep(j,w){\n        int v = i*w+j;\n        if(c[i][j]=='*') as.pb(v);\n    }\n\n    sort(all(as));\n    int ans = INF;\n    do{\n        int tmp=0;\n        int now = sx*w+sy;\n        for(int i=0;i<sz(as);i++){\n            tmp += g[now][as[i]];\n            now = as[i];\n        }\n        if(tmp==0){\n            cerr << \"error\" << endl;\n            exit(1);\n        }\n        if(tmp==12){\n            cout << as << endl;\n        }\n        ans = min(tmp,ans);\n    }while(next_permutation(all(as)));\n    if(ans==INF) cout << -1 << endl;\n    else cout << ans << endl;\n}\n\nint main(){\n    while(cin>>w>>h){\n        if(w==0 and h==0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<limits.h>\n#define INF 100000\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h;\nint imap[21][21];\nint fin;\nint djd[20][2]; // 0->x ,1->y\nint mmaapp[20][20];\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\nint bfs(int sp,int gp){\n  int mmap[21][21];\n \n  for(int i=0;i<21;i++)for(int j=0;j<21;j++)mmap[i][j] = INF;\n  queue<P> que;\n  que.push(P(djd[sp][0],djd[sp][1]));\n  mmap[djd[sp][1]][djd[sp][0]]=0;\n\n  while(que.size()){\n    P p = que.front();que.pop();\n\n    if(p.first == djd[gp][0] && p.second == djd[gp][1])return mmap[djd[gp][1]][djd[gp][0]];\n\n    for(int i=0;i<4;i++){\n      int nx = p.first+dx[i],ny = p.second+dy[i];\n      if(0<=nx && nx < w && 0<=ny && ny < h && mmap[ny][nx] == INF && imap[ny][nx] != -1){\n\tque.push(P(nx,ny));\n\tmmap[ny][nx] = mmap[p.second][p.first] + 1;\n      }\n    }\n  }\n  return -3;\n}\n\n\n\nint main(){\n  char in;\n  int count;\n  while(true){\n    cin >> w >> h;\n    if(w+h == 0)break;\n    count=1;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> in;\n\tswitch(in){\n\tcase '.':\n\t  imap[i][j]=0;\n\t  break;\n\tcase 'o':\n\t  imap[i][j]=0;\n\t  djd[0][0]=j;\n\t  djd[0][1]=i;\n\t  break;\n\tcase 'x':\n\t  imap[i][j]=-1;\n\t  break;\n\tcase '*':\n\t  imap[i][j]=0;\n\t  djd[count][0]=j;\n\t  djd[count][1]=i;\n\t  count++;\n\t  break;\n\tdefault:\n\t  cout << \"erro\" << endl; \n\t  break;\n\t}\n      }\n    }\n\n    for(int i=0;i<count;i++){\n      for(int j=0;j<count;j++){\n\tmmaapp[i][j] = bfs(i,j);\n\tfin = min(fin,mmaapp[i][j]);\n\t//cout << mmaapp[i][j] << \" \";\n      }\n      //cout << endl;\n    }\n\n    int permutationtest[21];\n    rep(i,count-1){\n      permutationtest[i] = i+1;\n      //cout << i+1 << endl;\n    }\n\n    int sum;\n    int ans=INF;\n    while(next_permutation(permutationtest,permutationtest+count-1)){\n      sum=0;\n      sum+=mmaapp[0][permutationtest[0]];\n      //cout << \"mmaapp[0] = \" << sum << endl; \n      for(int i=1;i<count-1;i++){\n\tsum+=mmaapp[permutationtest[i-1]][permutationtest[i]];\n\t//cout << \"i-1 = \" << permutationtest[i-1] << \", i = \" << permutationtest[i] << \", mmaapp =  \" << mmaapp[permutationtest[i-1]][permutationtest[i]]  <<endl;\n      }\n      // cout << \"----\" << endl;\n      ans=min(ans,sum);\n    }\n\n    if(fin < 0)cout << \"-1\" << endl;\n    else cout << ans << endl;\n\n  \n    \n    //if(ans <= -3)cout << \"-1\" << endl;\n    // else cout << ans << endl;\n   \n\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (int)(999999999/2)\n#define eps 1e-9\n#define MAX_N 5000\nint w,h;\nint fie[30][30];\nstring data[30];\n\n\nvoid bfs(int yy,int xx){\n    int dx[]={0,1,0,-1};\n    int dy[]={1,0,-1,0};\n    queue<pii> que;\n    que.push(pii(yy,xx));\n    \n    bool used[30][30]={};\n    used[yy][xx]=true;\n    while(que.size()){\n        int y=que.front().first,x=que.front().second;\n        //        cout<<y<<\" \"<<x<<endl;\n        que.pop();\n        \n        rep(i,4){\n            int ddy=y+dy[i],ddx=x+dx[i];\n            if(ddy<0||ddx<0||ddy>=h||ddx>=w||data[ddy][ddx]=='x'||used[ddy][ddx])continue;\n            fie[ddy][ddx]=fie[y][x]+1;\n            used[ddy][ddx]=true;\n            que.push(pii(ddy,ddx));\n        }\n    }\n}\n\nint solve(vector<int> a){\n    int ret=0;\n    rep(i,a.size()){\n        ret*=2;\n        ret+=a[i];\n    }\n    return ret;\n}\n\nint main(){\n    while(cin>>w>>h&&w&&h){\n        int v=0;\n        rep(i,h){\n            cin>>data[i];\n        }\n        \n        vector<pii> p;\n        rep(i,h)rep(j,w)if(data[i][j]=='o'){p.pb(pii(i,j));v++;}\n        rep(i,h)rep(j,w)if(data[i][j]=='*'){p.pb(pii(i,j));v++;}\n        map<  pair<pii,pii> , int  > pass;\n        rep(i,p.size()){\n            rep(j,30)rep(k,30)fie[j][k]=INF;\n            fie[p[i].first][p[i].second]=0;\n            bfs(p[i].first,p[i].second);\n            rep(j,p.size()){\n                pass[make_pair(p[i],p[j])]=fie[p[j].first][p[j].second];\n            }\n        }\n        vector<int> num;\n        rep(i,v-1)num.pb(i+1);\n        sort(all(num));\n        int mini=INF;\n        int dp[1<<11][11];\n        rep(i,1<<11)rep(j,11)dp[i][j]=INF;\n        dp[1][0]=0;\n//        cout<<(1<<(v-1))<<endl;\n        for(int i=1;i<v;i++){\n            vector<int> num;\n            rep(j,i)num.pb(1);\n            rep(j,v-i)num.pb(0);\n            sort(all(num));\n            do{\n                int b=solve(num);\n                rep(k,v){\n                    if(((1<<k)&b)!=0)continue;\n                    rep(l,v){\n                        if(k==l)continue;\n//                        cout<<\"dp[\"<<(b^(1<<k))<<\"][\"<<k<<\"]=\"<<min(dp[b][l]+pass[make_pair(p[l],p[k])],dp[b^(1<<k)][k])<<endl;\n//                        cout<<dp[b][l]<<endl;\n//                        cout<<b<<\" \"<<l<<endl;\n                        dp[b^(1<<k)][k]=min(dp[b][l]+pass[make_pair(p[l],p[k])],dp[b^(1<<k)][k]);\n                    }\n                }\n            }while(next_permutation(all(num)));\n        }\n        \n        \n//        do{\n//            int sum=0;\n//            sum+=pass[  make_pair(p[0],p[num[0]])  ];\n//            rep(i,v-2){\n//                sum+=pass[  make_pair(p[num[i]],p[num[i+1]])  ];\n//            }\n//            mini=min(mini,sum);\n//        }while(next_permutation(all(num)));\n        rep(i,v){\n            mini=min(dp[(1<<v)-1][i],mini);\n        }\n        if(mini==INF)cout<<\"-1\"<<endl;\n        else cout<<mini<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1140&lang=jp\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nstruct edge {\n\tint from;\n\tint to;\n\tint dist;\n\tedge() {}\n\tedge(int from, int to, int dist) :from(from), to(to), dist(dist) {}\n};\n\nvoid calc_cost(int x, int y,vector<vector<int>>& cost,vector<vector<char>>& masu) {\n\tqueue<pii> q; q.push({ x,y });\n\tcost[x][y] = 0;\n\twhile (!q.empty()) {\n\t\tpii p = q.front(); q.pop();\n\t\tfor (int i = 0; i < 4;i++) {\n\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\tif (masu[nx][ny] == 'x')continue;\n\t\t\tif (cost[nx][ny] > cost[p.first][p.second] + 1) {\n\t\t\t\tcost[nx][ny] = cost[p.first][p.second] + 1;\n\t\t\t\tq.push({ nx,ny });\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint w, h;\n\twhile (cin >> w >> h, w | h) {\n\t\tvector<vector<char>> masu(h + 2, vector<char>(w + 2, 'x'));\n\t\tvector<pii> yogore;\n\t\tint sx, sy;\n\t\tfor (int i = 1; i <= h;i++) {\n\t\t\tfor (int j = 1;j <= w;j++) {\n\t\t\t\tcin >> masu[i][j];\n\t\t\t\tif (masu[i][j] == '*'||masu[i][j] == 'o') {\n\t\t\t\t\tif (masu[i][j] == 'o') { sx = i, sy = j; }\n\t\t\t\t\telse yogore.push_back({ i,j });\n\t\t\t\t\tmasu[i][j] = '.';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint Size = yogore.size();\n\n\t\tqueue<pii> q;\n\t\tvector<vector<int>> dp(Size, vector<int>(1 << Size, INF));\n\n\t\tvector<vector<edge>> G(Size);\n\t\tfor (int i = -1; i < Size;i++) {\n\t\t\tvector<vector<int>> cost(h + 2, vector<int>(w + 2, INF));\n\n\t\t\tif(i == -1) calc_cost(sx, sy, cost, masu);\n\t\t\telse calc_cost(yogore[i].first, yogore[i].second, cost, masu);\n\n\t\t\tfor (int j = 0; j < Size;j++) {\n\t\t\t\tif (i == -1) {\n\t\t\t\t\tdp[j][1 << j] = cost[yogore[j].first][yogore[j].second];\n\t\t\t\t\tq.push({ j, 1 << j });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (i == j)continue;\n\t\t\t\t\tif (cost[yogore[j].first][yogore[j].second] == INF)continue;\n\t\t\t\t\tG[i].push_back(edge(i, j, cost[yogore[j].first][yogore[j].second]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!q.empty()) {\n\t\t\tauto p = q.front(); q.pop();\n\t\t\tint n = p.first, bit = p.second;\n\t\t\tfor (auto e : G[n]) {\n\t\t\t\tif ((1 << e.to)&bit)continue;\n\t\t\t\tif (dp[e.to][(1 << e.to) | bit] > dp[n][bit] + e.dist) {\n\t\t\t\t\tdp[e.to][(1 << e.to) | bit] = dp[n][bit] + e.dist;\n\t\t\t\t\tq.push({ e.to,(1 << e.to) | bit });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < Size;i++) {\n\t\t\tans = min(ans, dp[i][(1 << Size) - 1]);\n\t\t}\n\t\tcout << ((ans != INF) ? ans : -1) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 1000000000\n#define LLINF 1000000000000000ll\n#define sz(x) ((int)(x).size())\n#define sq(x) ((x)*(x))\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n\nint h,w;\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\nvector<string> f;\nvector<int> pos;\nint start;\nint d[402][402];\nint dp[1<<11][11];\nint K;\nint id(int x,int y){\n    return x*w+y;\n}\nstring binary(int a){\n    string ret;\n    for(int i=0;i<4;i++){\n        if((1<<i)&a)ret+=\"1\";\n        else ret+=\"0\";\n    }\n    return ret;\n}\nint rec(int S,int v){\n    if(dp[S][v]!=-1)return dp[S][v];\n    if(S==0)return 0;\n    int ret = INF;\n    for(int i=0;i<K;i++){\n        if((S&(1<<i))!=0)ret = min(ret,rec(S-(1<<i),i)+d[pos[i]][pos[v]]);\n    }\n    //cout << binary(S) << ' ' << v << ' ' << ret << endl; \n    return dp[S][v]=ret;\n}\nint solve(){\n    f.clear();\n    scanf(\"%d %d\",&w,&h);\n    int N = w*h;\n    if(h+w==0)return 1;\n    f.resize(h);\n    for(int i=0;i<h;i++)cin >> f[i];\n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            d[i][j]=INF;\n            if(i==j)d[i][j]=0;\n        }\n    }\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            for(int dir=0;dir<4;dir++){\n                int nx = i+dx[dir];\n                int ny = j+dy[dir];\n                if(nx<0||nx>=h||ny<0||ny>=w)continue;\n                if(f[i][j]=='x'||f[nx][ny]=='x')continue;\n                //cout << id(i,j) << ' ' << id(nx,ny) << endl;\n                d[id(nx,ny)][id(i,j)]=1;\n                d[id(i,j)][id(nx,ny)]=1;\n            }\n        }\n    }\n    for(int k=0;k<N;k++){\n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n            }\n        }\n    }\n\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(f[i][j]=='o')start = pos.size();\n            if(f[i][j]=='o'||f[i][j]=='*')pos.pb(id(i,j));\n        }\n    }\n    K = pos.size();\n    for(int i=0;i<(1<<K);i++){\n        for(int j=0;j<K;j++){\n            dp[i][j]=-1;\n        }\n    }\n    int ans = rec((1<<K)-(1<<start),start);\n    if(ans==INF)ans = -1;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n\nint main(){\n    while(1){\n        if(solve())return 0;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n\n\nusing namespace std;\n\n\n// ツ各ツ可伉づェツタツイツδ仰＋ツスツタツーツトツ地ツ点ツづ個つサツづェツつシツづェツづ個甘板づ個仰猟猟」\nint d[21][21][21][21];\nvector<string> field;\npair<int,int> sp;\nvector<pair<int,int> > dartys;\nint w,h;\n\nbool bfs(int sy,int sx){\n\tqueue<pair<int,int> > *prv = new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *nxt = new queue<pair<int,int> >();\n\n\tbool passed[21][21];\n\tfor(int i = 0; i < 21; i++)\n\t\tfill(passed[i],passed[i]+21,false);\n\n\tprv->push(make_pair(sy,sx));\n\n\tint dy[] = {-1,0,0,1};\n\tint dx[] = {0,-1,1,0};\n\n\tbool no = true;\n\tbool fir = false;\n\tint dist = 0;\n\twhile(prv->size()){\n\t\twhile(prv->size()){\n\t\t\tpair<int,int> cp = prv->front();prv->pop();\n\t\t\tif(passed[cp.first][cp.second])\n\t\t\t\tcontinue;\n\t\t\tpassed[cp.first][cp.second]=true;\n\t\t\td[sy][sx][cp.first][cp.second] = dist;\n\n\n\t\t\tif(fir && field[cp.first][cp.second] == '*'){\n\t\t\t\tno = false;\n\t\t\t}\n\t\t\tfir = true;\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tpair<int,int> np = cp;\n\t\t\t\tnp.first += dy[i];\n\t\t\t\tnp.second += dx[i];\n\t\t\t\tif(np.first >= 0 && np.second >= 0 && np.first < h && np.second < w){\n\t\t\t\t\tif(!passed[np.first][np.second] && field[np.first][np.second] != 'x'){\n\t\t\t\t\t\tnxt->push(np);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdist++;\n\t\tswap(prv,nxt);\n\t}\n\tdelete prv,nxt;\n\tif(no){\n\t\treturn false;\n\t}\n\telse\n\t\treturn true;\n}\n\nint dfs(int s,pair<int,int> prv){\n\tif(s == (1 << (int)(dartys.size()))-1){\n\t\treturn 0;\n\t}\n\n\tint minCost = 10000000;\n\tfor(int i = 0; i < dartys.size(); i++){\n\t\tif(!((1 & (s >> i)) == 1)){\n\t\t\tminCost = min(minCost,dfs(s | (1 << i),make_pair(dartys[i].first,dartys[i].second))\n\t\t\t\t+ d[prv.first][prv.second][dartys[i].first][dartys[i].second]);\n\t\t}\n\t}\n\treturn minCost;\n}\n\nint main(){\n\n\twhile(cin >> w >> h && !(w == 0 && h == 0)){\n\t\tfor(int i = 0; i < 21; i++){\n\t\t\tfor(int j = 0; j < 21; j++){\n\t\t\t\tfor(int k = 0; k < 21; k++){\n\t\t\t\t\tfill(d[i][j][k],d[i][j][k]+21,100000000);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfield.clear();\n\t\tdartys.clear();\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfield.push_back(str);\n\t\t\tfor(int j = 0; j < str.size(); j++){\n\t\t\t\tif(str[j] == 'o'){\n\t\t\t\t\tsp.first = i;\n\t\t\t\t\tsp.second = j;\n\t\t\t\t}\n\t\t\t\telse if(str[j] == '*'){\n\t\t\t\t\tdartys.push_back(make_pair(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ツ各ツ湘ェツ渉環つゥツづァツ深ツつウツ優ツ静ヲツ探ツ催オツづ、ツつサツづェツつシツづェツづ個湘ェツ渉環づ鳴づ個仰猟猟」ツづーツ仰づ淞づつィツつュ\n\t\tif(!bfs(sp.first,sp.second)){\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tbool fff = false;\n\t\tfor(int i = 0; i < dartys.size(); i++){\n\t\t\tif(!bfs(dartys[i].first,dartys[i].second)){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\tfff = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(fff){\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t// ツ渉嘉アツセツーツδ仰スツマツδ督姪「ツ妥ィツづーツ嘉ーツつュ\n\t\tcout << dfs(0,make_pair(sp.first,sp.second)) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nint save[20][20],vis[25][25],n,m,dust,ct,lp,stx,sty,sum,minn;\nint mov[4][2]= {1,0,0,-1,-1,0,0,1};\nchar plate[25][25];\nint visp[20];\n\nstruct status\n{\n    int cnt;\n    int x,y;\n    status(int a,int b,int c)\n    {\n        x = a, y = b, cnt = c;\n    }\n};\nstruct point\n{\n    int x,y;\n}p[20];\n\nqueue<struct status> q;\n\nvoid maek()\n{\n    while(!q.empty())\n    {\n        if(plate[q.front().x][q.front().y]=='*')\n            save[0][ct+1] = q.front().cnt, p[ct+1].x = q.front().x, p[ct+1].y = q.front().y, ct++;\n\n        for(int i=0; i<4; i++)\n        {\n            int tx = q.front().x + mov[i][0], ty = q.front().y + mov[i][1];\n            if(tx >= 0 && tx < m && ty >=0 && ty < n && plate[tx][ty] != 'x' && !vis[tx][ty])\n            {\n                struct status temp(tx, ty, q.front().cnt + 1);\n                vis[tx][ty] = 1;\n                q.push(temp);\n            }\n        }\n        q.pop();\n    }\n}\n\nvoid play(int x, int y, int ord)\n{\n    int ctt = 0;\n    vis[q.front().x][q.front().y] = 1;\n    while(ctt != ct)\n    {\n        if(plate[q.front().x][q.front().y]=='*')\n        {\n            int r;\n            for(r=1; r<=ct; r++)\n                if(p[r].x == q.front().x && p[r].y == q.front().y) break;\n            save[ord][r] = q.front().cnt, ctt++;\n        }\n\n        for(int i=0; i<4; i++)\n        {\n            int tx = q.front().x + mov[i][0], ty = q.front().y + mov[i][1];\n            if(tx >= 0 && tx < m && ty >=0 && ty < n && plate[tx][ty] != 'x' && !vis[tx][ty])\n            {\n                struct status temp(tx, ty, q.front().cnt + 1);\n                vis[tx][ty] = 1;\n                q.push(temp);\n            }\n        }\n        q.pop();\n    }\n}\n\n\nvoid dfs(int x,int y,int ore)\n{\n    //printf(\"%d %d %d %d\\n\",x,y,ore,sum);\n\n    if(x==y)\n    {\n        minn = minn > sum ? sum : minn;\n    }\n\n    for(int i=1; i<=ct; i++)\n    {\n        if(!visp[i])\n        {\n            if(sum + save[ore][i] > minn) continue;\n            else\n            {\n                sum += save[ore][i];\n                x++;\n                visp[i] = 1;\n                dfs(x,y,i);\n                visp[i] = 0;\n                sum -= save[ore][i];\n                x--;\n            }\n        }\n    }\n}\n\n\nint main()\n{\n    //freopen(\"C://1140-input.txt\",\"r\",stdin);\n    //freopen(\"C://zout.txt\",\"w\",stdout);\n\n    while(~scanf(\"%d%d\",&n,&m),n+m)\n    {\n\n        memset(plate, 0, sizeof(plate));\n        memset(vis,0,sizeof(vis));\n        memset(save,0,sizeof(save));\n        memset(visp,0,sizeof(visp));\n        memset(p,0,sizeof(p));\n\n        getchar();\n        lp = 0, ct = 0;\n        for(int i=0; i<m; i++)\n        {\n            for(int j=0; j<n; j++)\n            {\n                scanf(\"%c\",&plate[i][j]);\n                if(plate[i][j]=='o') stx = i, sty = j;\n                if(plate[i][j]=='*') lp++;\n            }\n            getchar();\n        }\n\n        struct status tm(stx,sty,0);\n        q.push(tm);\n        maek();\n\n        if(ct != lp) printf(\"-1\\n\");\n        else\n        {\n            for(int i=1; i<=ct; i++)\n            {\n                memset(vis,0,sizeof(vis));\n                struct status temp(p[i].x, p[i].y, 0);\n                q.push(temp);\n                play(p[i].x, p[i].y, i);\n                while(!q.empty()) q.pop();\n            }\n\n            for(int i=0;i<=ct;i++)\n            {\n                for(int j=0;j<=ct;j++)\n                {\n                    printf(\"%3d \",save[i][j]);\n                }\n                printf(\"\\n\");\n            }\n            minn = 99999999;\n\n            for(int i=1; i<=ct; i++)\n            {\n                memset(visp,0,sizeof(visp));\n                sum = save[0][i],visp[i] = 1;\n                dfs(1,ct,i);\n            }\n            printf(\"%d\\n\",minn);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint W, H;\nvector<string> field;\n\nint main() {\n\twhile (cin >> W >> H, W || H) {\n\t\tfield = vector<string>(H);\n\t\tvector<P> targets;\n\t\tP pos;\n\t\tfor (int i = 0 ; i < H; i++) {\n\t\t\tcin >> field[i];\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (field[i][j] == '*') {\n\t\t\t\t\ttargets.emplace_back(j, i);\n\t\t\t\t}\n\t\t\t\telse if (field[i][j] == 'o') {\n\t\t\t\t\tpos = P(j, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = -1;\n\t\tqueue<pair<P, P>> que;\n\t\tque.push(make_pair(P(0, 0), pos));\n\t\tbool visited[W][H][1<<11];\n\t\tmemset(visited, 0, sizeof(visited));\n\t\twhile (!que.empty()) {\n\t\t\tauto& cur = que.front();\n\t\t\tint step = cur.first.first;\n\t\t\tint bit = cur.first.second;\n\t\t\tint x = cur.second.first;\n\t\t\tint y = cur.second.second;\n\t\t\tque.pop();\n\t\t\tif (visited[x][y][bit]) continue;\n\t\t\tvisited[x][y][bit] = true;\n\t\t\tif (bit == (1 << (targets.size())) - 1) {\n\t\t\t\tans = step;\n\t\t\t\t//cout << bit << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nx = x + dx[i];\n\t\t\t\tint ny = y + dy[i];\n\t\t\t\tif (!(0 <= nx && nx < W && 0 <= ny && ny < H && field[ny][nx] != 'x')) continue;\n\t\t\t\tint nbit = bit;\n\t\t\t\tif (field[ny][nx] == '*') {\n\t\t\t\t\tnbit = nbit | (1 << (find(targets.begin(), targets.end(), P(nx, ny)) - targets.begin()));\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < targets.size(); i++) {\n\t\t\t\t\tque.push(make_pair(P(step + 1, nbit), P(nx, ny)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <cctype>\n#include <vector>\n#include <complex>\n#include <map>\n#include <queue>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\n#ifdef __linux\n#define _U(s) s##_unlocked\n#else\n#define _U(s) _##s##_nolock\n#define _CRT_DISABLE_PERFCRIT_LOCKS\n#endif\n#define gcu _U(getchar)\n#define pcu _U(putchar)\n#define _DEF(r, n, ...) inline r n(__VA_ARGS__) noexcept\n#define _T template <typename T>\n#define _HT template <typename H,typename... T>\n#define _I inline\n#define _OP(t) _I operator t()\nstruct _in {\n#ifdef _GLIBCXX_STRING\n\t_OP(string){string s;char c;while(isspace(c = gcu()));do{s+=c;}while(c=gcu(),c!=' '&&c!='\\n'&&c!=EOF);return s;}\n#define _S\n#endif\n\t_OP(char){char c=gcu();gcu();return c;}\n\t_OP(double){double d; scanf(\"%lf\",&d); gcu();return d;}\n\t_T _OP(T){T n{},m{1},c;while(isspace(c = gcu()));if(c=='-')m=-1,c=gcu();do{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m*n;}\n} in;\n#define _SCAN(...) _DEF(bool,scan,__VA_ARGS__)\n#ifdef _S\n_SCAN(string &o) {int c{gcu()};if(c==EOF)return false;else{ungetc(c,stdin);string t=move(in);o=t;return true;}}\n#endif\n_T _SCAN(T &o) {int c{gcu()};return c==EOF?false:(ungetc(c,stdin),o=in,true);}\n_HT _SCAN(H &h,T&&... t){return scan(h)&&scan(t...);}\n#define _OUT(...) _DEF(void,out,__VA_ARGS__)\n#define _OUTL(...) _DEF(void,outl,__VA_ARGS__)\n_OUT(bool b){pcu('0'+b);}\n_OUT(const char *s){while(*s)pcu(*s++);}\n_OUT(char c){pcu(c);}\n#ifdef _S\n_OUT(string &s){for(char c:s)pcu(c);}\n#endif\n_T _OUT(T n){static char b[20];char *p=b;T m=n<0?pcu('-'),-1:1;\n\tif(!n)*p++='0';else while(n)*p++=(char)(n%10*m+'0'),n/=10;while(p!=b)pcu(*--p);}\n_OUTL(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n\t_T _OUT(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);}\n#endif\n_HT _OUT(H &&h, T... t){out(h);out(t...);}\ntemplate <typename... T> _OUTL(T... t){out(t...);outl();}\n#define dbg(...) fprintf(stderr,__VA_ARGS__)\nstruct range{\n\tint e,b=0,s=1;range(int b,int e,int s):e(e),b(b),s(s){} range(int b,int e): e(e), b(b){} range(int e):e(e){}\n\tstruct it{int v,s; it(int v,int s):v(v),s(s){} operator int()const{return v;} _I operator int&(){return v;}int operator*()const{return v;}\n\t\t_I it& operator++(){v+=s;return *this;} }; it begin(){return {b,s};} it end(){return {e,s};}};\n#define times(i,n) for(int i=n;i;i--)\n\n_T using V = vector<T>;\nusing P = complex<int>;\nusing PP = pair<P, int>;\nint x(P a) {return real(a);};\nint y(P a) {return imag(a);};\ntemplate <typename T, typename U> T x(pair<T, U> a) {return a.first;};\ntemplate <typename T, typename U> U y(pair<T, U> a) {return a.second;};\nnamespace std {\n\tbool operator < (P a, P b) {\n\t\treturn x(a) == x(b) ? y(a) < y(b) : x(a) < x(b);\n\t}\n}\n\nint main() {\n\tfor (P s; s = {in, in}, x(s);) {\n\t\tV<V<char>> m(y(s) + 2, V<char>(x(s) + 2, 'x'));\n\t\tmap<P, int> d;\n\t\tint k {};\n\t\tfor (int i: range(1, y(s) + 1)) {\n\t\t\tfor (int j: range(1, x(s) + 1)) {\n\t\t\t\tint c {gcu()};\n\t\t\t\tm[i][j] = c;\n\t\t\t\tif (c == 'o') {\n\t\t\t\t\tm[i][j] = '*';\n\t\t\t\t\td[{j, i}] = 0;\n\t\t\t\t} else if (c == '*')\n\t\t\t\t\td[{j, i}] = ++k;\n\t\t\t}\n\t\t\tgcu();\n\t\t}\n\t\tint inf {INT_MAX / 2}, n = d.size();\n\t\tV<V<int>> di(n, V<int>(n, inf)), dp(1 << n, V<int>(n, inf));\n\t\tif (![&] {\n\t\t\tint b {};\n\t\t\tfor (PP i: d) {\n\t\t\t\tif (b == n - 1)\n\t\t\t\t\treturn true;\n\t\t\t\tint c {++b};\n\t\t\t\tV<V<bool>> v(y(s) + 2, V<bool>(x(s) + 2));\n\t\t\t\tqueue<PP> q;\n\t\t\t\tq.push({x(i), 0});\n\t\t\t\tv[y(x(i))][x(x(i))] = true;\n\t\t\t\tif (![&] {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tPP a = q.front();\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tP u {x(a)};\n\t\t\t\t\t\tif (y(a) && m[y(u)][x(u)] == '*' && di[y(i)][d[u]] == inf) {\n\t\t\t\t\t\t\tdi[y(i)][d[u]] = y(a);\n\t\t\t\t\t\t\tdi[d[u]][y(i)] = y(a);\n\t\t\t\t\t\t\tif (++c == n)\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tP d {1, 0};\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tP t = u + d;\n\t\t\t\t\t\t\tif (!v[y(t)][x(t)] && m[y(t)][x(t)] != 'x') {\n\t\t\t\t\t\t\t\tv[y(t)][x(t)] = true;\n\t\t\t\t\t\t\t\tq.push({t ,y(a) + 1});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while ((d *= P{0, 1}) != P{1, 0});\n\t\t\t\t\t} while (!q.empty());\n\t\t\t\t\treturn false;\n\t\t\t\t\t}())\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}()) {\n\t\t\toutl(-1);\n\t\t\tcontinue;\n\t\t}\n\t\trange rn(n);\n\t\tint N = 1 << n;\n\t\tfor (int i: rn)\n\t\t\tdp[1 << i][0] = 0;\n\t\tfor (int S: range(1, N)) {\n\t\t\tfor (int v: rn)\n\t\t\t\tif (S & (1 << v))\n\t\t\t\t\tfor (int u: rn)\n\t\t\t\t\t\tdp[S | (1 << u)][u] = min(dp[S | (1 << u)][u], dp[S][v] + di[v][u]);\n\t\t}\n\t\toutl(dp[N - 1][min_element(begin(dp[N - 1]), end(dp[N - 1])) - begin(dp[N - 1])]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main(void) {\n\twhile(true) {\n\tint w, h;\n\tcin>>w>>h;\n\t\tif(w == 0 && h == 0) break;\n\tvector<vector<char> > m(h, vector<char>(w));\n\tvector<P> p;\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tcin>>m[i][j];\n\t\t\tif(m[i][j] == 'o') {\n\t\t\t\tp.pb(P(i, j));\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tif(m[i][j] == '*') {\n\t\t\t\tp.pb(P(i, j));\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<ll> > d(p.size(), vector<ll>(p.size(), INF * INF));\n\tREP(i, p.size()) {\n\t\tP s = p[i];\n\t\tvector<vector<ll> > dir(h, vector<ll>(w, INF * INF));\n\t\tdir[s.first][s.second] = 0;\n\t\tqueue<P> q;\n\t\tq.push(s);\n\t\twhile(!q.empty()) {\n\t\t\tP np = q.front();\n\t\t\tq.pop();\n\t\t\tREP(j, 4) {\n\t\t\t\tll nh = np.first + dx[j];\n\t\t\t\tll nw = np.second + dy[j];\n\t\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w && m[nh][nw] != 'x') {\n\t\t\t\t\tif(dir[nh][nw] == INF * INF) {\n\t\t\t\t\t\tdir[nh][nw] = dir[np.first][np.second] + 1;\n\t\t\t\t\t\tq.push(P(nh, nw));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(j, p.size()) {\n\t\t\tif(i == j) continue;\n\t\t\td[i][j] = dir[p[j].first][p[j].second];\n\t\t}\n\t}\n\tbool det = false;\n\tFOR(i, 1, p.size()) {\n\t\tif(d[0][i] == INF * INF) det = true;\n\t}\n\tif(det) {\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tvector<int> perm;\n\tREP(i, p.size() - 1) {\n\t\tperm.pb((int)(i + 1));\n\t}\n\tll ans = INF * INF;\n\tif(p.size() == 1) {\n\t\tcout<<\"hoge\"<<endl;\n\t\tcout<<0<<endl;\n\t}\n\telse {\n\t\tdo {\n\t\t\tll res = 0;\n\t\t\tres += d[0][perm[0]];\n\t\t\tREP(i, perm.size() - 1) {\n\t\t\t\tres += d[perm[i]][perm[i + 1]];\n\t\t\t}\n\t\t\tans = min(ans, res);\n\t\t} while(next_permutation(ALL(perm)));\n\t\tcout<<ans<<endl;\n\t}\n\t}\n}\n\n//7 5\n//.......\n//.o...*.\n//.......\n//.*...*.\n//.......\n//0 0"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint w, h;\nstring b[20];\nint step[20][20];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid bfs(int x, int y){\n\tmemset(step, -1, sizeof(step));\n\tqueue< pair<int, int> > qu; qu.push(make_pair(x,y));\n\tstep[x][y] = 0;\n\twhile(!qu.empty()){\n\t\tpair<int, int> pr = qu.front(); qu.pop();\n\t\tint cx = pr.first, cy = pr.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx = cx+dx[i], ny = cy+dy[i];\n\t\t\tif(nx<0||h<=nx||ny<0||w<=ny||b[nx][ny]=='x'||step[nx][ny]!=-1) continue;\n\t\t\tstep[nx][ny] = step[cx][cy]+1;\n\t\t\tqu.push(make_pair(nx,ny));\n\t\t}\n\t}\n}\n\nint main(){\n\tint c[11][11];\n\twhile(cin >> w >> h, w){\n\t\tfor(int i=0;i<h;i++) cin >> b[i];\n\t\tvector<int> x(1), y(1);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(b[i][j]=='o') x[0] = i, y[0] = j;\n\t\t\t\tif(b[i][j]=='*') x.push_back(i), y.push_back(j);\n\t\t\t}\n\t\t}\n\t\tint res = 1000000000;\n\t\tfor(int i=0;i<x.size();i++){\n\t\t\tbfs(x[i], y[i]);\n\t\t\tfor(int j=0;j<x.size();j++){\n\t\t\t\tc[i][j] = step[x[j]][y[j]];\n\t\t\t\tif(c[i][j]==-1) res = -1;\n\t\t\t}\n\t\t}\n\t\tvector<int> a(x.size()-1);\n\t\tfor(int i=0;i<x.size()-1;i++) a[i] = i+1;\n\t\tdo{\n\t\t\tint cur = c[0][a[0]];\n\t\t\tfor(int i=0;i+1<a.size();i++) cur += c[a[i]][a[i+1]];\n\t\t\tres = min(res, cur);\n\t\t}while(next_permutation(a.begin(), a.end()));\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1140&lang=jp\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nstruct edge {\n\tint from;\n\tint to;\n\tint dist;\n\tedge() {}\n\tedge(int from, int to, int dist) :from(from), to(to), dist(dist) {}\n};\n\nvoid calc_cost(int x, int y,vector<vector<int>>& cost,vector<vector<char>>& masu) {\n\tqueue<pii> q; q.push({ x,y });\n\tcost[x][y] = 0;\n\twhile (!q.empty()) {\n\t\tpii p = q.front(); q.pop();\n\t\tfor (int i = 0; i < 4;i++) {\n\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\tif (masu[nx][ny] == 'x')continue;\n\t\t\tif (cost[nx][ny] > cost[p.first][p.second] + 1) {\n\t\t\t\tcost[nx][ny] = cost[p.first][p.second] + 1;\n\t\t\t\tq.push({ nx,ny });\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint w, h;\n\twhile (cin >> w >> h, w | h) {\n\t\tvector<vector<char>> masu(h + 2, vector<char>(w + 2, 'x'));\n\t\tvector<pii> yogore;\n\t\tfor (int i = 1; i <= h;i++) {\n\t\t\tfor (int j = 1;j <= w;j++) {\n\t\t\t\tcin >> masu[i][j];\n\t\t\t\tif (masu[i][j] == '*'||masu[i][j] == 'o') {\n\t\t\t\t\tmasu[i][j] = '.';\n\t\t\t\t\tyogore.push_back({ i,j });\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint YOGORE = (int)yogore.size();\n\t\tvector<vector<edge>> dist(YOGORE);\n\t\tfor (int i = 0; i < YOGORE;i++) {\n\t\t\tvector<vector<int>> cost(h + 2, vector<int>(w + 2, INF));\n\t\t\tcalc_cost(yogore[i].first, yogore[i].second,cost, masu);\n\t\t\tfor (int j = 0; j < YOGORE; j++) {\n\t\t\t\tif (cost[yogore[j].first][yogore[j].second] == INF)continue;\n\t\t\t\tdist[i].push_back(edge(i,j,cost[yogore[j].first][yogore[j].second]));\n\t\t\t}\n\t\t}\n\n\t\tint dp[11][1 << 11];\n\t\tfor (int i = 0; i < 11;i++)for (int j = 0; j < (1 << 11);j++)dp[i][j] = INF;\n\t\tdp[0][1 << 0] = 0;\n\t\tfor (int j = 1;j < (1 << YOGORE);j++) {\n\t\t\tfor (int i = 0; i < YOGORE;i++) {\n\t\t\t\tfor (auto e : dist[i]) {\n\t\t\t\t\tif ((1 << e.to) & j) continue;\n\t\t\t\t\tdp[e.to][(1 << e.to) | j] = min(dp[e.to][(1 << e.to) | j], dp[e.from][j] + e.dist);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 1; i < YOGORE;i++) {\n\t\t\tans = min(ans, dp[i][(1 << YOGORE)-1]);\n\t\t}\n\t\tcout << ((ans==INF)?-1:ans) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\nusing namespace std;\n\n#define INF 1e9\n\nint dfs(int nowobject, int size, vector<vector<int> > &all_pairs, vector<bool> &used, int dist){\n  if(dist >= INF){ return INF; }\n  \n  used[nowobject] = true;\n  int mindist = INF;\n  bool endflag = true;\n  \n  for(int i = 0; i < size; i++){\n    if(!used[i]){\n      endflag = false;\n      int tmp = dfs(i, size, all_pairs, used, dist + all_pairs[nowobject][i]);\n      if(mindist > tmp){ mindist = tmp; }\n    }\n  }\n  \n  if(endflag){ mindist = dist; }\n  used[nowobject] = false;\n  return mindist;\n}\n\n\nint main(void){\n  while(true){\n    int w, h;\n    cin >> w >> h;\n    if(w == 0 && h == 0){ break; }\n\n    // ?????????????????±?????\\???\n    const int C = -1, F = -2;\n    int robot;\n    string s;\n    vector<vector<int> > map(h, vector<int>(w));\n    vector<pair<int, int> > object; \n    for(int i = 0; i < h; i++){\n      cin >> s;\n      for(int j = 0; j < w; j++){\n        if(s[j] == '.'){ map[i][j] = C; }\n        else if(s[j] == 'x'){ map[i][j] = F; }\n        else{\n          if(s[j] == 'o'){ robot = object.size(); }\n          map[i][j] = object.size();\n          object.push_back(make_pair(i, j));\n        }\n      }\n    }\n\n    // ???????????§???????????°??????bfs??????????????¨??????????±???????\n    const int x[4] = {-1, 0, 1, 0};\n    const int y[4] = {0, -1, 0, 1};\n    vector<vector<int> > all_pairs(object.size(), vector<int>(object.size(), INF));\n    for(int i = 0; i < object.size(); i++){ all_pairs[i][i] = 0; }\n    for(int i = 0; i < object.size(); i++){\n      vector<vector<bool> > used(h, vector<bool>(w, false));\n      queue<pair<pair<int, int>, int> > q;\n      used[object[i].first][object[i].second] = true;\n      q.push(make_pair(object[i], 0));\n\n      while(!q.empty()){\n        pair<int, int> now = q.front().first;\n        int dist = q.front().second + 1;\n        q.pop();\n\n        // ??????????????????\n        for(int j = 0; j < 4; j++){\n          pair<int, int> next = make_pair(now.first + x[j], now.second + y[j]);\n          // ?????¢???????£???????????????????????????¶????????¶???????????£??????????????§?????¢?´¢???????????£?????´???????????????\n          if(next.first < 0 || h <= next.first || next.second < 0 || w <= next.second\n             || map[next.first][next.second] == F || used[next.first][next.second]){\n            continue;\n          }\n\n          // ????????´???or?????????????????¶???????????£????????????????????§????????¢????¨????\n          if(0 <= map[next.first][next.second]){ all_pairs[i][map[next.first][next.second]] = dist; }\n\n          // ?????\\????????????\n          q.push(make_pair(next, dist));\n          used[next.first][next.second] = true;\n        }\n      }\n    }\n\n    // 10!???????????????????????¨??¨??????\n    vector<bool> used(object.size(), false);\n    int result = dfs(robot, object.size(), all_pairs, used, 0);\n\n    // ???????????????\n    if(result == INF){ cout << -1 << endl; }\n    else{ cout << result << endl; }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(T x, S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-12;\n\nint w, h;\nconst int MAX_H = 30;\nconst int MAX_W = 30;\nconst int MAX_T = 12;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nchar c[MAX_H][MAX_W+1];\nint d[MAX_H][MAX_W][MAX_H][MAX_W];\nint dp[1<<MAX_T][MAX_T];\nint sx, sy;\n\ninline bool check(int hx, int hy){ return 0 <= hx && hx < h && 0 <= hy && hy < w; }\n\nint main()\n{\n  while(cin >> w >> h, h){\n    rep(i, h) rep(j, w) rep(k, h) rep(l, w) d[i][j][k][l] = INF;\n    rep(i, h) rep(j, w) cin >> c[i][j];\n    rep(i, h) rep(j, w) if(c[i][j] == 'o') sx = i,  sy = j;\n\n    rep(i, h) rep(j, w) d[i][j][i][j] = 0;\n    rep(i, h) rep(j, w) rep(k, 4) if(c[i][j] != 'x'){\n      int nx = i + dx[k];\n      int ny = j + dy[k];\n      if(check(nx, ny)){\n        if(c[nx][ny] != 'x') d[i][j][nx][ny] = 1;\n        if(c[nx][ny] == 'x') d[i][j][nx][ny] = INF;\n      }\n    }\n\n    rep(k1, h) rep(k2, w) rep(i1, h) rep(i2, w) rep(j1, h) rep(j2, w) minup(d[i1][i2][j1][j2], d[i1][i2][k1][k2] + d[k1][k2][j1][j2]);\n\n    vii vec;\n    int n = 0;\n    rep(i, h) rep(j, w) if(c[i][j] == '*'){\n      n += 1;\n      vec.pb(mp(i, j));\n    }\n\n    rep(i, 1 << n) rep(j, n) dp[i][j] = INF;\n    rep(i, n) dp[1 << i][i] = d[sx][sy][vec[i].first][vec[i].second];\n\n    rep(S, 1 << n) rep(v, n) rep(u, n) minup(dp[S | 1 << u][u], dp[S][v] + d[vec[v].first][vec[v].second][vec[u].first][vec[u].second]);\n\n    int res = INF;\n    rep(i, n) minup(res, dp[(1 << n) - 1][i]);\n    cout << (res >= INF ? -1 : res) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cstring>\n\n\nusing namespace std;\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n#define all(c) (c).begin(), (c).end()\nint const inf = 1 << 29;\n\nint main(){\n    int w, h;\n    while (cin >> w >> h && w | h){\n        vector<string> grid(h);\n        vector<pair<int,int>> node;\n        rep(i, h){\n            cin >> grid[i];\n            rep(j, grid[i].size())if (grid[i][j] == 'o')node.emplace_back(i, j);\n        }\n        rep(i, h)rep(j, w){\n            if (grid[i][j] == '*')node.emplace_back(i, j);\n        }\n\n        static int d[20][20];\n        rep(i, 20)rep(j, 20)d[i][j] = inf;\n\n        rep(i, node.size()){\n            int dx[] = { 1, 0, -1, 0 }, dy[] = { 0, 1, 0, -1 };\n            queue<pair<int, int>> q;\n            static int dist[25][25];\n            rep(j, h)rep(k, w)dist[j][k] = inf;\n            dist[node[i].first][node[i].second] = 0;\n            q.emplace(node[i]);\n\n            while (q.size()){\n                auto p = q.front(); q.pop();\n                int cx = p.second, cy = p.first;\n                rep(j, 4){\n                    int nx = cx + dx[j], ny = cy + dy[j];\n                    if (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n                    if (grid[ny][nx] == 'x') continue;\n                    if (dist[ny][nx] > dist[cy][cx] + 1){\n                        dist[ny][nx] = dist[cy][cx] + 1;\n                        q.emplace(ny, nx);\n                    }\n                }\n            }\n\n            rep(j, node.size()){\n                d[i][j] = dist[node[j].first][node[j].second];\n            }\n        }\n\n        int idx[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n        long long ans = inf;\n        do{\n            long long t = 0;\n            rep(i, node.size() - 1){\n                t += d[idx[i]][idx[i + 1]];\n            }\n            ans = min(t, ans);\n        } while (next_permutation(idx + 1, idx + node.size()));\n        if (ans >= inf)ans = -1;\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 21\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h,G[N][N];\nstring mp[N];\nmap<P,int>M;\n\nvoid bfs(P s){\n  int D[N][N];\n  memset(D,-1,sizeof(D));\n  queue<P> Q;\n  Q.push(s);\n  int x=s.first,y=s.second;\n  D[y][x]=0;\n  while(!Q.empty()){\n    P t=Q.front();Q.pop();\n    x=t.first,y=t.second;\n    if(mp[y][x]=='*'||mp[y][x]=='o') G[M[s]][M[t]]=D[y][x];\n\n    int dx[]={0,0,-1,1},dy[]={1,-1,0,0};\n    for(int i=0;i<4;i++){\n      int nx=x+dx[i],ny=y+dy[i],cost=D[y][x]+1;\n      if(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx]=='x'||D[ny][nx]!=-1)continue;\n      Q.push(P(nx,ny));\n      D[ny][nx]=cost;\n    }\n  }\n}\n\nint n,num[11];\nvector<P> p;\nint calc(){\n  int res=0;\n  for(int i=1;i<n;i++)res+=G[num[i-1]][num[i]];\n  return res;  \n}\n\nP start;\nint dfs(int idx){\n  if(M[start]==idx)return dfs(idx+1);\n  if(idx==n) return calc();\n  int res=1e9;\n  for(int i=1;i<n;i++){\n    if(num[i]!=-1)continue;\n    num[i]=idx;\n    res=min(res,dfs(idx+1));\n    num[i]=-1;\n  }\n  return res;\n}\n\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h)break;\n    for(int i=0;i<h;i++) cin>>mp[i];\n    M.clear();\n    p.clear();\n    memset(G,-1,sizeof(G));\n    memset(num,-1,sizeof(num));\n    n=0;\n\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tP t=P(j,i);\n\tif(mp[i][j]=='*'||mp[i][j]=='o') p.push_back(t),M[t]=n++;\n\tif(mp[i][j]=='o') start=t;\n      }\n    for(int i=0;i<n;i++)bfs(p[i]);\n    bool flg=1;\n    for(int i=0;i<n;i++)if(G[0][i]==-1)flg=0;\n    num[0]=M[start];\n    cout <<(flg?dfs(1):-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(x) cout << (x) << '\\n'\n#define Int int64_t\n#define fi first\n#define se second\n#define all(x) (x).begin(), (x).end()\n\nInt INF = 1e18;\nint inf = 1e9;\nInt mod = 1e9+7;\n\nint w, h;\nchar field[21][21];\nint s_to[11];\nint dist[11][11];\n\nint bfs(pair<int, int> s, pair<int, int> g) {\n    int d[21][21] = {};\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            d[i][j] = inf;\n        }\n    }\n    d[s.fi][s.se] = 0;\n    queue<pair<int, int>> q;\n    q.push(s);\n    while (not q.empty()) {\n        pair<int, int> p = q.front();\n        q.pop();\n        int dy[] = {1, 0, -1, 0};\n        int dx[] = {0, -1, 0, 1};\n        for (int i = 0; i < 4; i++) {\n            int ny = p.fi + dy[i];\n            int nx = p.se + dx[i];\n            if (ny <  0 or ny == h or nx < 0 or nx == w) continue;\n            if (field[ny][nx] == 'x') continue;\n            if (d[p.fi][p.se] + 1 < d[ny][nx]) {\n                d[ny][nx] = d[p.fi][p.se] + 1;\n                q.push({ny, nx});\n            }\n        }\n    }\n    return d[g.fi][g.se];\n}\n\nint main() {\n    vector<int> res;\n    while (true) {\n        cin >> w >> h;\n        if (w == 0) break;\n        pair<int, int> s;\n        vector<pair<int, int>> v;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> field[i][j];    \n                if (field[i][j] == '*') {\n                    field[i][j] = '.';\n                    v.emplace_back(i, j);\n                }\n                else if (field[i][j] == 'o') {\n                    field[i][j] = '.';\n                    s = {i, j};\n                }\n            }\n        }\n        bool check = false;\n        for (int i = 0; i < (int)v.size(); i++) {\n            s_to[i] = bfs(s, v[i]);\n            if (s_to[i] == inf) {\n                check = true;\n                break;\n            }\n        }\n        if (check) {\n            res.push_back(-1);\n            continue;\n        }\n        for (int i = 0; i < (int)v.size() - 1; i++) {\n            for (int j = i + 1; j < (int)v.size(); j++) {\n                dist[i][j] = dist[j][i] = bfs(v[i], v[j]);\n            }\n        }\n        vector<int> indice(v.size());\n        iota(all(indice), 0);\n        int mi = inf;\n        do {\n            int sum = 0;\n            sum += s_to[indice[0]];\n            for (int i = 0; i < (int)indice.size() - 1; i++) {\n                sum += dist[indice[i]][indice[i + 1]];\n            }\n            mi = min(mi, sum);\n        } while (next_permutation(all(indice)));\n        res.push_back(mi);\n    }\n    for (int i = 0; i < (int)res.size(); i++) {\n        dump(res[i]);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<bitset>\nusing namespace std;\nstruct st{\n  int x,y,m,c;\n  st(int x,int y,int m,int c) : x(x),y(y),m(m),c(c) {}\n};\nint W,H;\nchar fie[21][21];\nint gomi[21][21];\nint memo[21][21][(1<<10)];\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint bit_max;\nint solve(int x,int y){\n  queue<st> q;\n  while(!q.empty()) q.pop();\n  q.push(st(x,y,0,0));\n  memo[x][y][0]=0;\n  while(!q.empty()){\n    st p = q.front(); q.pop();\n    x = p.x; y = p.y;\n    for(int i=0;i<4;i++){\n      int nx = x+dx[i];\n      int ny = y+dy[i];\n      if(nx < 0 || ny < 0 || nx>=W || ny>=H) continue;\n      if(fie[nx][ny]=='x') continue;\n      if(fie[nx][ny]=='*'){\n\tif( !((1<<gomi[nx][ny]) & p.m) ){\n\t  int next_m = ((1<<gomi[nx][ny]) | p.m);\n\t  if(memo[nx][ny][next_m]!=-1) continue;\n\t  if(bit_max == next_m) return p.c+1;\n\t  memo[nx][ny][next_m]=p.c+1;\n\t  q.push(st(nx,ny,next_m,p.c+1));\n\t}else{\n\t  if(memo[nx][ny][p.m]!=-1) continue;\n\t  memo[nx][ny][p.m]=p.c+1;\n\t  q.push(st(nx,ny,p.m,p.c+1));\n\t}\n      }else{\n\tif(memo[nx][ny][p.m]!=-1) continue;\n\tmemo[nx][ny][p.m]=p.c+1;\n\tq.push(st(nx,ny,p.m,p.c+1));\n      }\n    }\n  }\n  return -1;\n}\nint main(){\n  while(1){\n    int sx,sy;\n    memset(memo,-1,sizeof(memo));\n    memset(gomi,-1,sizeof(gomi));\n    cin >> W >> H;\n    if(!W && !H) break;\n    int co=0;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin >> fie[j][i];\n\tif(fie[j][i]=='o'){\n\t  sx=j; sy=i;\n\t} else if(fie[j][i]=='*'){\n\t  gomi[j][i]=co;\n\t  ++co;\n\t}\n      }\n    }\n    bit_max = (1<<co)-1;\n    //    cout << bitset<16>(bit_max) << \"\\n\";\n    if(bit_max==0) cout << 0 << \"\\n\";\n    else cout << solve(sx,sy) << \"\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<string.h>\n#include<map>\n#include<queue>\nusing namespace std;\n\n#define INF 100000\n\n\nint w,h;\nint dist[11][11];\nvector<string> M;\nmap<pair<int,int>,int> Idx;\npair<int,int> point[11];\nbool visit[400][400];\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nvoid calc_dist(int num){\n\tfor(int i=0;i<num;i++){\n\t\tqueue<pair<pair<int,int>,int> > Q;\n\t\tQ.push(make_pair(point[i],0));\n\t\tmemset(visit,false,sizeof(visit));\n\t\twhile(!Q.empty()){\n\t\t\tpair<int,int> now=Q.front().first;\n\t\t\tint cost=Q.front().second;\n\t\t\tQ.pop();\n\t\t\tif(now.first>=w || now.second>=h || now.first<0 || now.second<0) continue;\n\t\t\tif(M[now.second][now.first]=='x') continue;\n\t\t\tif(visit[now.second][now.first]) continue;\n\t\t\tvisit[now.second][now.first]=true;\n\t\t\tif(Idx.count(now))\n\t\t\t\tdist[i][Idx[now]]=cost;\n\n\t\t\tfor(int r=0;r<4;r++)\n\t\t\t\tQ.push(make_pair(make_pair(now.first+dx[r],now.second+dy[r]),cost+1));\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(cin>>w>>h && w!=0){\n\t\tM.clear();\n\t\tint start=0;\n\t\tIdx.clear();\n\t\tint count=1;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tstring s; cin>>s; M.push_back(s);\n\t\t\tfor(int n=0;n<s.size();n++){\n\t\t\t\tif(s[n]=='o'){\n\t\t\t\t\tIdx[make_pair(n,i)]=0;\n\t\t\t\t\tpoint[0]=make_pair(n,i);\n\t\t\t\t}\n\t\t\t\telse if(s[n]=='*'){\n\t\t\t\t\tIdx[make_pair(n,i)]=count;\n\t\t\t\t\tpoint[count]=make_pair(n,i);\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(dist,-1,sizeof(dist));\n\t\tcalc_dist(count);\n\t\tint ans=INF;\n\n\t\tfor(int i=0;i<count;i++){\n\t\t\tfor(int j=0;j<count;j++){\n\t\t\t\tif(dist[i][j]<0){\n\t\t\t\t\tans=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint dp[1<<11][11];\n\t\tfor(int i=0;i<11;i++)\n\t\t\tfor(int b=0;b<(1<<11);b++)\n\t\t\t\tdp[b][i]=INF;\n\n\t\tdp[(1<<count)-1][0]=0;\n\n\t\tif(ans>=0){\n\t\t\tfor(int S=(1<<count)-2;S>=0;S--){\n\t\t\t\tfor(int v=0;v<count;v++){\n\t\t\t\t\tfor(int u=0;u<count;u++){\n\t\t\t\t\t\tif(!(S>>u&1)){//à¤Â¢Äéæ\n\t\t\t\t\t\t\tdp[S][v]=min(dp[S][v],dp[S | 1<<u][u]+dist[v][u]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tfor(int i=0;i<count;i++)\n\t\t\t\tans=min(ans,dp[0][i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <utility>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n#define at(v,p) v[p/100][p%100]\n\nint w, h;\nint len[11][10];\nstring field[22];\n\nint dif[] = { -100, -1, 1, 100 };\n\n\nint fromto(int from, int index){\n\tqueue<pii> q;\n\tq.push( pii( 0, from ) );\n\n\tvector<bitset<22> > visit( 22 );\n\tvisit[from / 100].set( from % 100 );\n\t\n\tint count = 0;\n\twhile( !q.empty() ){\n\t\tpii p = q.front();\n\t\tq.pop();\n\t\tint pos = p.second;\n\n\t\tif( isdigit( at( field, pos ) ) ){\n\t\t\tlen[index][ at( field, pos ) - '0' ] = p.first;\n\t\t\t++count;\n\t\t}\n\n\t\tfor( int i = 0; i < 4; ++i ){\n\t\t\tint newpos = pos + dif[i];\n\t\t\tif(\n\t\t\t\tat( field, newpos ) != 'x' && \n\t\t\t\t!at( visit, newpos )\n\t\t\t){\n\t\t\t\tvisit[newpos / 100].set( newpos % 100 );\n\t\t\t\tq.push( pii( p.first + 1, newpos ) );\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn count;\n}\n\n\nint solve(){\n\tint cnt_dirty = 0;\n\tint start;\n\tvector<int> d_pos(10);\n\n\tfor( int i = 1; i <= h; ++i ){\n\t\tfor( int j = 1; j <= w; ++j ){\n\t\t\tswitch( field[i][j] ){\n\t\t\t\tcase '*':\n\t\t\t\t\tfield[i][j] = cnt_dirty + '0';\n\t\t\t\t\td_pos[cnt_dirty] = i * 100 + j;\n\t\t\t\t\t++cnt_dirty;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'o':\n\t\t\t\t\tstart = i * 100 + j;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif( fromto( start, 10 ) != cnt_dirty ){\n\t\treturn -1;\n\t}\n\n\tfor( int i = 0; i < cnt_dirty; ++i ){\n\t\tfromto( d_pos[i], i );\n\t}\n\n\n\n\tvector<vector<int> > dp( 10, vector<int>( 1 << 10, 10000 ) );\n\tfor( int i = 0; i < cnt_dirty; ++i ){\n\t\tdp[i][1 << i] = len[10][i];\n\t}\n\tint last = (1 << cnt_dirty) - 1;\n\tfor( int S = 1; S < last; ++S ){\n\t\tfor( int i = 0; i < cnt_dirty; ++i ){\n\t\t\tif( S >> i & 1 ){\n\t\t\t\tfor( int j = 0; j < cnt_dirty; ++j ){\n\t\t\t\t\tif( !(S >> j & 1) ){\n\t\t\t\t\t\tdp[j][S | 1 << j] =\n\t\t\t\t\t\t\tmin( dp[j][S | 1 << j], dp[i][S] + len[i][j] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 20000;\n\tfor( int i = 0; i < cnt_dirty; ++i ){\n\t\tret = min( ret, dp[i][last] );\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\tfield[0] = string( 22, 'x' );\n\tstring s;\n\n\twhile( cin >> w >> h, w != 0 ){\n\t\tfor( int i = 1; i <= h; ++i ){\n\t\t\tcin >> s;\n\t\t\tfield[i] = 'x' + s + 'x';\n\t\t}\n\t\tfield[h + 1] = field[0];\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint h, w, k[21][21], cnt;\nint cx[11], cy[11], y[11][11], z[11][11], bfs[21][21], a, b, c[10], sum, minx;\nchar p;\nqueue<int>Q;\n\nvoid BFS() {\n\twhile (!Q.empty()) {\n\t\ta = Q.front() / 20;\n\t\tb = Q.front() % 20;\n\t\tif (k[a - 1][b] == 0 && bfs[a - 1][b] >= 1000000) {\n\t\t\tQ.push(Q.front() - 20);\n\t\t\tbfs[a - 1][b] = bfs[a][b] + 1;\n\t\t}\n\t\tif (k[a + 1][b] == 0 && bfs[a + 1][b] >= 1000000) {\n\t\t\tQ.push(Q.front() + 20);\n\t\t\tbfs[a + 1][b] = bfs[a][b] + 1;\n\t\t}\n\t\tif (k[a][b + 1] == 0 && bfs[a][b + 1] >= 1000000) {\n\t\t\tQ.push(Q.front() + 1);\n\t\t\tbfs[a][b + 1] = bfs[a][b] + 1;\n\t\t}\n\t\tif (k[a][b - 1] == 0 && bfs[a][b - 1] >= 1000000) {\n\t\t\tQ.push(Q.front() - 1);\n\t\t\tbfs[a][b - 1] = bfs[a][b] + 1;\n\t\t}\n\t\tQ.pop();\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tmemset(z, 0, sizeof(z));\n\t\tcin >> w >> h; cnt = 1; if (!w) { break; }\n\t\tfor (int i = 0; i < 21; i++) { \n\t\t\tfor (int j = 0; j < 21; j++) { \n\t\t\t\tk[i][j] = 1; \n\t\t\t} \n\t\t}\n\t\tcnt = 1;\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tcin >> p;\n\t\t\t\tif (p != 'x') { k[i][j] = 0; }\n\t\t\t\tif (p == '*') { cx[cnt] = j; cy[cnt] = i; cnt++; }\n\t\t\t\tif (p == 'o') { cx[0] = j; cy[0] = i; }\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\tc[i] = i;\n\t\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\t\tmemset(bfs, 10, sizeof(bfs));\n\t\t\t\tbfs[cy[i]][cx[i]] = 0;\n\t\t\t\tQ.push(cy[i] * 20 + cx[i]);\n\t\t\t\tBFS();\n\t\t\t\tz[i][j] = bfs[cy[j]][cx[j]];\n\t\t\t}\n\t\t}\n\t\tminx = 114514;\n\t\tdo\n\t\t{\n\t\t\tsum = z[0][c[0] + 1];\n\t\t\tfor (int i = 0; i < cnt; i++) { sum += z[c[i] + 1][c[i + 1] + 1]; }\n\t\t\tminx = min(minx, sum);\n\t\t} while (next_permutation(c, c + cnt - 1));\n\t\tif (minx == 114514) { minx = -1; }\n\t\tcout << minx << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#define MAX_WH 20\n\nusing namespace std;\n\nint w, h;\nclass State {\npublic:\n  char data[MAX_WH][MAX_WH];\n  int x, y;\n  int step;\n  int cnt;\n  State() {\n    step = 0;\n    cnt = 0;\n  }\n  bool operator <(const State &s) const {\n    if(x != s.x) return x < s.x;\n    if(y != s.y) return y < s.y;\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) {\n\tif(data[i][j] != s.data[i][j])\n\t  return data[i][j] < s.data[i][j];\n      }\n    }\n    return false;\n  }\n  char getFloor() {\n    return data[y][x];\n  }\n  void next() {\n    step++;\n    if(getFloor() == '*') {\n      data[y][x] = '.';\n      cnt++;\n    }\n  }\n};\n\nint yogore;\n\nint solve(State s) {\n  queue<State> Q;\n  set<State> visited;\n  const int dx[4] = {1,0,-1,0};\n  const int dy[4] = {0,1,0,-1};\n  State tmp;\n  char floor;\n  Q.push(s);\n  visited.insert(s);\n  while(!Q.empty()) {\n    s = Q.front();\n    if(s.cnt == yogore) return s.step;\n    Q.pop();\n    for(int i = 0; i < 4; i++) {\n      tmp = s;\n      tmp.x = s.x + dx[i];\n      tmp.y = s.y + dy[i];\n      if(tmp.x < 0) continue;\n      if(tmp.x >= w) continue;\n      if(tmp.y < 0) continue;\n      if(tmp.y >= h) continue;\n      floor = tmp.getFloor();\n      if(floor == 'x') continue;\n      tmp.next();\n      if(visited.find(tmp) != visited.end()) continue;\n\n      Q.push(tmp);\n      visited.insert(tmp);\n    }\n  }\n  return -1;\n}\n\nmain() {\n  while(1) {\n    State s;\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    yogore = 0;\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) {\n\tcin >> s.data[i][j];\n\tif(s.data[i][j] == 'o') {\n\t  s.x = j;\n\t  s.y = i;\n\t  s.data[i][j] = '.';\n\t} else if(s.data[i][j] == '*') {\n\t  yogore++;\n\t}\n      }\n    }\n\n    cout << solve(s) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int w,h;\n    while(cin>>w>>h, w||h){\n        vector<string> s(h);\n        for(int i=0;i<h;i++) cin>>s[i];\n        vector<vector<int>> dis(1000,vector<int>(1000,INF));\n        for(int i=0;i<h*w;i++) dis[i][i]=0;\n        vector<P> dirty;\n        int sx,sy;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(s[i][j]=='x') continue;\n                if(s[i][j]=='*') dirty.push_back(P(i,j));\n                if(s[i][j]=='o'){\n                    sx=i;sy=j;\n                }\n\n                for(int k=0;k<4;k++){\n                    int nx=i+dx[k],ny=j+dy[k];\n                    if(nx<0 || h<=nx || ny<0 || w<=ny) continue;\n                    if(s[nx][ny]=='x') continue;\n                    int st=i*w+j,gt=nx*w+ny;\n                    dis[st][gt]=1;\n                }\n            }\n        }\n        for(int k=0;k<h*w;k++){\n            for(int i=0;i<h*w;i++){\n                for(int j=0;j<h*w;j++){\n                    dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n                }\n            }\n        }\n        int sz=dirty.size();\n        ll res=INF;\n        do{\n            int sx2=sx,sy2=sy;\n            ll tmp=0;\n            for(int i=0;i<sz;i++){\n                int nx=dirty[i].first,ny=dirty[i].second;\n                tmp+=dis[sx2*w+sy2][nx*w+ny];\n                sx2=nx;sy2=ny;\n            }\n            res=min(res,tmp);\n        }while(next_permutation(dirty.begin(),dirty.end()));\n        if(res>=INF) cout<<-1<<endl;\n        else cout<<res<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#define MAX_V 15\n#define INF 10000000\n#include<queue>\n#include<string>\n#include<map>\n#include<vector>\nusing namespace std;\nstruct edge{\n\tint to,cost;\n};\nint co[MAX_V][MAX_V];\nint h,w,V,dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nstring s[1000];\ntypedef pair<int,int> P;\nmap<P,int> mp;\nint dp[1 << MAX_V][MAX_V];\nint rec(int S,int v){\n\tif(dp[S][v]>=0)\n\t\treturn dp[S][v];\n\tif(S==(1<<V)-2){\n\t\treturn dp[S][v]=0;\n\t}\n\tint res=INF;\n\tfor(int u=0;u<V;u++){\n\t\tif(!(S>>u&1)){\n\t\t\tres=min(res,rec(S|1<<u,u)+co[v][u]);\n\t\t}\n\t}\n\treturn dp[S][v]=res;\n}\nvoid solve(){\n\tmemset(dp,-1,sizeof(dp));\n\tint temp=rec(0,0);\n\tif(temp==INF)\n\tcout<<-1<<endl;\n\telse\n\tcout<<temp<<endl;\n}\nvoid func(int y,int x,int q){\n\tint d[MAX_V][MAX_V];\n\tfor(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\td[i][j]=INF;\n\td[y][x]=0;\n\tqueue<P> box;\n\tbox.push(P(y,x));\n\twhile(!box.empty()){\n\t\tint nx,ny,sx,sy;\n\t\tP pre=box.front();\n\t\tbox.pop();\n\t\tsy=pre.first;\n\t\tsx=pre.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tnx=sx+dx[i];\n\t\t\tny=sy+dy[i];\n\t\t\tif((nx>=0&&ny>=0&&nx<w&&ny<h)&&(s[ny][nx]=='o'||s[ny][nx]=='.'||s[ny][nx]=='*')&&(d[ny][nx]==INF)){\n\t\t\t\tbox.push(P(ny,nx));\n\t\t\t\tif(s[ny][nx]=='*'||s[ny][nx]=='o'){\n\t\t\t\t\tco[mp[P(ny,nx)]][q]=d[sy][sx]+1;\n\t\t\t\t\tco[q][mp[P(ny,nx)]]=d[sy][sx]+1;\n\t\t\t\t}\n\t\t\t\td[ny][nx]=d[sy][sx]+1;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(cin>>w>>h,h||w){\n\t\tV=1;\n\t\tfor(int i=0;i<h;i++)\n\t\tcin>>s[i];\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\tif(s[i][j]=='o')\n\t\t\tmp[P(i,j)]=0;\n\t\telse if(s[i][j]=='*'){\n\t\t\tmp[P(i,j)]=V;\n\t\t\tV++;\n\t\t}\n\t\tfor(int i=0;i<V;i++)\n\t\tfor(int j=0;j<V;j++){\n\t\t\tco[i][j]=INF;\n\t\t\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[i][j]=='o'){\n\t\t\t\tfunc(i,j,0);\n\t\t\t}else if(s[i][j]=='*'){\n\t\t\t\tfunc(i,j,mp[P(i,j)]);\n\t\t\t}\n\t\t}\n\t\t\n\t\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e9\n\nint di[4] = {0, -1, 0, 1};\nint dj[4] = {1, 0, -1, 0};\n\nint w, h, si, sj, gi, gj, n;\n\nint dist[11][11];\n/* メモ再帰 */\n\nint dp[(1<<20) + 1][21]; // dpテーブルは余裕をもったサイズにする\nint rec(int bit, int v)\n{\n    // すでに探索済みだったらリターン\n    if (dp[bit][v] != -1) return dp[bit][v];\n\n    // 初期値\n    if (bit == (1<<v)) {\n        if(v != 0) return dp[bit][v] = INF;\n        else return dp[bit][v] = 0;\n    }\n\n    // 答えを格納する変数\n    int res = INF;\n\n    // bit の v を除いたもの\n    int prev_bit = bit & ~(1<<v);\n\n    // v の手前のノードとして u を全探索\n    for (int u = 0; u < n; ++u) {\n        if (!(prev_bit & (1<<u))) continue; // u が prev_bit になかったらダメ\n\n        // 再帰的に探索\n        if (res > rec(prev_bit, u) + dist[u][v]) {\n            res = rec(prev_bit, u) + dist[u][v];\n        }\n    }\n\n    return dp[bit][v] = res; // メモしながらリターン\n}\n\n\nint bfs(vector<vector<bool> > canGo){\n\n//まず最初にsの情報をキューに追加して、盤面を埋める\n    queue<pair<int, pair<int, int> > > wait;\n    wait.push(make_pair(0, make_pair(si, sj)));\n    canGo[si][sj] = false;\n\n    //以下、幅優先\n    int ans = -1;   //ansを-1で初期化\n\n    while(!wait.empty()){    //キュー画空になるまで\n        //キューの先頭要素を取り出す\n        int nowcost = wait.front().first;\n        int nowi = wait.front().second.first;\n        int nowj = wait.front().second.second;\n\n        wait.pop();\n\n        //ゴールにたどり着いたらそのコストが答え\n        if(nowi == gi && nowj == gj){\n            ans = nowcost;\n            break;\n        }\n\n        //四方向を探索\n        for(int k = 0; k < 4; k++){\n            int nexti = nowi + di[k];\n            int nextj = nowj + dj[k];\n\n            //その方向に進めるなら\n            if(canGo[nexti][nextj]){\n                //そのマスにキューを追加し\n                //再度検索することのないように壁で埋める\n                wait.push(make_pair(nowcost + 1, make_pair(nexti, nextj)));\n                canGo[nexti][nextj] = false;\n            }\n        }\n    }\n\n    //出力\n    \n    return ans;\n\n}\n\nint main(){\n\n    while(1){\n        cin >> w >> h;\n        if(!w) break;\n\n        vector<pair<int, int> > s;\n        s.push_back({0, 0});\n        vector<vector<bool> > a(h + 2, vector<bool> (w + 2, false));\n        for(int i = 1; i <= h; i++){\n            for(int j = 1; j <= w; j++){\n                char input; cin >> input;\n                if(input == 'x') continue;\n                else{\n                    a[i][j] = true;\n\n                    if(input == 'o'){\n                        s[0].first = i;\n                        s[0].second = j;\n                    }else if(input == '*'){\n                        s.push_back({i, j});\n                    }\n                }\n            }\n        }\n\n        n = s.size();\n        \n        //vector<vector<int> > dist(v, vector<int> (v));\n        for(int k = 0; k < n; k++){\n            for(int l = 0; l <= k; l++){\n\n                //cout << k << \" \" << l << endl;\n                if(k == l) dist[k][l] = 0;\n                else{\n                    si = s[k].first;\n                    sj = s[k].second;\n                    gi = s[l].first;\n                    gj = s[l].second;\n\n                    dist[k][l] = bfs(a);\n                    dist[l][k] = dist[k][l];\n\n                }\n            }\n        }\n    \n\n\n        /*cout << \"ok\"<< endl;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                cout << dist[i][j] << \" \";\n            }\n            cout << endl;\n        }*/\n\n        // テーブルを全部 -1 にしておく (-1 でなかったところは探索済)\n        for (int bit = 0; bit < (1<<n); ++bit) for (int v = 0; v < n; ++v) dp[bit][v] = -1;\n\n        // 探索\n        int res = INF;\n        for (int v = 0; v < n; ++v) {\n            if (res > rec((1<<n)-1, v)) {\n                res = rec((1<<n)-1, v);\n            }\n        }\n\n\n        if(res >= INF) cout << -1 << endl;\n        else cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\n\nclass Point{\npublic:\n  short int x,y,g;\n  int c;\n};\n\nint main(){\n  int i,j,h,w,sum,ans,now;\n  bool gomi[20][20],f[11][20][20];\n  string str;\n  while(1){\n    Point u,v;\n    queue <Point> Q;\n    cin >> w >> h;\n    if(h == 0 && w == 0) break;\n    ans = -1;\n    sum = 0;\n    for(i=0;i<h;i++){\n      cin >> str;\n      for(j=0;j<w;j++){\n\tgomi[i][j] = false;\n\tfor(int k=0;k<11;k++) f[k][i][j] = false;\n\tif(str[j] == 'o'){\n\t  u.y = (short)i;\n\t  u.x = (short)j;\n\t}\n\telse if(str[j] == 'x'){\n\t  for(int k=0;k<11;k++) f[k][i][j] = true;\n\t}\n\telse if(str[j] == '*'){\n\t  gomi[i][j] = true;\n\t  sum++;\n\t}\n      }\n    }\n\n    now = 0;\n    u.g = (short)0;\n    u.c = 0;\n    Q.push(u);\n    while(!Q.empty()){\n      u = Q.front();\n      Q.pop();\n      if(u.g < now) continue;\n\n      f[u.g][u.y][u.x] = true;\n\n      if(gomi[u.y][u.x]){\n\tgomi[u.y][u.x] = false;\n\tu.g++;\n\tnow++;\n      }\n\n      if(u.g == sum){\n\tans = u.c;\n\tbreak;\n      }\n\n      u.c++;\n      f[u.g][u.y][u.x] = true;\n      short int dx[4] = {1,0,-1,0};\n      short int dy[4] = {0,1,0,-1};\n      for(i=0;i<4;i++){\n\tv = u;\n\tv.x += dx[i];\n\tv.y += dy[i];\n\tif(!f[v.g][v.y][v.x] && v.x >= 0 && v.x < w && v.y >= 0 && v.y < h){\n\t    Q.push(v);\n\t  }\n       }\n    }\n    cout << ans << endl;\n      \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing pii = pair<int, int>;\n\nconstexpr int INF = (1 << 12);\nconstexpr int dir[5] = {0, 1, 0, -1, 0};\n\nbool ispower(int n)\n{\n    return n == (pow(2, static_cast<int>(log2(n))));\n}\n\nvoid bfs_dist(const vector<vector<int>>& room, const pii& pos, vector<int>& dist, const vector<pii>& dirty)\n{\n    const int h = room.size();\n    const int w = room[0].size();\n    int rest = dirty.size();\n    vector<vector<bool>> checked(h, vector<bool>(w, false));\n    queue<pair<pii, int>> q;\n    q.push(make_pair(pos, 0));\n    while (not q.empty()) {\n        const pii p = q.front().first;\n        const int distance = q.front().second;\n        const int pi = p.first;\n        const int pj = p.second;\n        for (int i = 0; i < dirty.size(); i++) {\n            if (p == dirty[i] and (not checked[pi][pj])) {\n                dist[i] = distance;\n                rest--;\n                if (rest == 0) {\n                    return;\n                }\n            }\n        }\n        checked[pi][pj] = true;\n        q.pop();\n        for (int d = 0; d < 4; d++) {\n            const int newi = pi + dir[d];\n            const int newj = pj + dir[d + 1];\n            if (0 <= newi and newi < h and 0 <= newj and newj < w) {\n                if (room[newi][newj] != -1 and (not checked[newi][newj])) {\n                    q.push(make_pair(make_pair(newi, newj), distance + 1));\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        int h, w;\n        cin >> w >> h;\n        if (w == 0 and h == 0) {\n            break;\n        }\n        vector<vector<int>> room(h, vector<int>(w));\n\n        pii start;\n        vector<pii> dirty;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                char c;\n                cin >> c;\n                if (c == '.') {\n                    room[i][j] = 0;\n                } else if (c == '*') {\n                    room[i][j] = 1;\n                    dirty.push_back(make_pair(i, j));\n                } else if (c == 'x') {\n                    room[i][j] = -1;\n                } else {\n                    room[i][j] = 0;\n                    start.first = i;\n                    start.second = j;\n                }\n            }\n        }\n\n        const int dirtynum = dirty.size();\n        vector<vector<int>> dist(dirtynum, vector<int>(dirtynum, INF));\n        vector<int> initdist(dirtynum, INF);\n        bfs_dist(room, start, initdist, dirty);\n        for (int i = 0; i < dirtynum; i++) {\n            bfs_dist(room, dirty[i], dist[i], dirty);\n        }\n\n        for (int i = 0; i < dirtynum; i++) {\n            if (initdist[i] == INF) {\n                cout << -1 << endl;\n                continue;\n            }\n        }\n\n        const int maximum = 1 << dirtynum;\n        vector<vector<int>> dp(maximum, vector<int>(dirtynum, INF));  // dp[visited[last]\n        for (int n = 1; n < maximum; n++) {\n            for (int i = 0; i < dirtynum; i++) {\n                if ((n >> i) % 2) {\n                    for (int j = 0; j < dirtynum; j++) {  //i->j\n                        if ((n >> j) % 2) {\n                            if (i == j) {\n                                if (ispower(n)) {\n                                    dp[n][i] = initdist[i];\n                                }\n                                continue;\n                            }\n                            dp[n][j] = min(dp[n][j], dp[n - (1 << j)][i] + dist[i][j]);\n                        }\n                    }\n                }\n            }\n        }\n        int mini = INF;\n        for (int i = 0; i < dirtynum; i++) {\n            mini = min(mini, dp[maximum - 1][i]);\n        }\n        cout << mini << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<cstring>\nusing namespace std;\n#define INF 1 << 29\ntypedef pair< int , int > Pi;\nint h, w;\nchar mas[50][50];\nint graph[11][11];\nint min_cost[50][50];\nPi gomi[11];\nint gomi_size, uoo;\nint memo[12][1 << 11];\nconst int dy[] = { 1, 0, 0, -1}, dx[] = { 0, 1, -1, 0};\n\nint rec(int idx, int used)\n{\n  if(used == (1 << gomi_size) - 1) return 0;\n  if(memo[idx][used]) return memo[idx][used];\n\n  int ret = INF;\n  for(int i = 0; i < gomi_size; i++){\n    if(!(used & (1 << i)) && graph[idx][i] != -1){\n      ret = min(ret, rec(i, used | (1 << i)) + graph[idx][i]);\n    }\n  }\n\n  return memo[idx][used] = ret;\n}\n\n\nint bfs(Pi a, Pi b)\n{\n  memset( min_cost, -1, sizeof(min_cost));\n  queue< Pi > que;\n  que.push(a);\n  min_cost[a.first][a.second] = 0;\n  while(!que.empty()){\n    Pi p = que.front(); que.pop();\n    if(p == b) return min_cost[p.first][p.second];\n    for(int i = 0; i < 4; i++){\n      int ny = p.first + dy[i], nx = p.second + dx[i];\n      if(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n      if(mas[ny][nx] != 'x' && min_cost[ny][nx] == -1){\n        min_cost[ny][nx] = min_cost[p.first][p.second] + 1;\n        que.push( Pi( ny, nx));\n      }\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  while(cin >> w >> h, w){\ngomi_size = 0;\n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++){\n      cin >> mas[i][j];\n      if(mas[i][j] == '*' || mas[i][j] == 'o'){\n        gomi[gomi_size++] = Pi( i, j);\n        if(mas[i][j] == 'o') uoo = gomi_size - 1;\n      }\n    }\n  }\n  for(int i = 0; i < gomi_size; i++){\n    for(int j = i + 1; j < gomi_size; j++){\n      graph[i][j] = graph[j][i] = bfs(gomi[i], gomi[j]);\n    }\n  }\n\n  //巡回セールスマン！！\n  //さのぴーさんよろしく\nmemset( memo, 0, sizeof(memo));\n  int ret = rec( uoo, 1 << uoo);\n\n  if(ret != INF) cout << ret << endl;\n  else cout << -1 << endl;\n}\n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <utility>\n#include <cassert>\nusing namespace std;\n\nint n;\nint h,w;\nint g[444][444];\nchar grid[30][30];\nvector<pair<int,int> > gar;\nvector<vector<pair<int,int> > > adj; // dst, weight\n\nconst int inf = 1e9;\n\nint getId(int i, int j){\n    return i*w + j;\n}\n\nint dp[12][1<<12];\nint rec(int visSet, int v){\n    int res = dp[v][visSet];\n    if(res != -1) return res;\n    visSet |= 1<<v;\n    if(visSet+1 == 1<<n) return res = 0;\n    // printf(\"v:%d\\n\", v);\n    res = inf;\n    for(int i = 0; i < (int)adj[v].size(); i++){\n        int d = adj[v][i].first;\n        int w = adj[v][i].second;\n        // printf(\"%d -> %d : %d\\n\", i,d,w);\n        if(visSet >> d & 1) continue;\n        res = min(res, w + rec(visSet, d));\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> w >> h && w){\n        for(int i = 0; i < 12; i++){\n            for(int j = 0; j < (1<<12); j++){\n                dp[i][j] = -1;\n            }\n        }\n        gar.clear();\n        int sv = -1;\n        int si = -1, sj = -1;\n        for(int i = 0; i < h; i++){\n            cin >> grid[i];\n            // cout << grid[i] << endl;\n            for(int j = 0; j < w; j++){\n                if(grid[i][j] == 'o'){\n                    sv = gar.size();\n                    si = i, sj = j;\n                    gar.push_back(make_pair(i,j));\n                }\n                if(grid[i][j] == '*'){\n                    gar.push_back(make_pair(i,j));\n                }\n            }\n        }\n        assert(si != -1 && sj != -1);\n        n = gar.size();\n        for(int i = 0; i < h*w; i++){\n            for(int j = 0; j < h*w; j++){\n                g[i][j] = inf;\n            }\n        }\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                if(grid[i][j] != 'x'){\n                    if(i+1 != h && grid[i+1][j] != 'x'){\n                        int u = getId(i,j);\n                        int v = getId(i+1,j);\n                        g[u][v] = g[v][u] = 1;\n                    }\n                    if(j+1 != w && grid[i][j+1] != 'x'){\n                        int u = getId(i,j);\n                        int v = getId(i,j+1);\n                        g[u][v] = g[v][u] = 1;\n                    }\n                }\n            }\n        }\n        for(int k = 0; k < h*w; k++){\n            for(int i = 0; i < h*w; i++){\n                for(int j = 0; j < h*w; j++){\n                    g[i][j] = min(g[i][j], g[i][k]+g[k][j]);\n                }\n            }\n        }\n        // for(int i = 0; i < h*w; i++){\n        //     for(int j = 0; j < h*w; j++){\n        //         printf(\"%d \", g[i][j]);\n        //     }\n        //     puts(\"\");\n        // }\n        \n        adj.resize(n);\n        for(int i = 0; i < n; i++) adj[i].clear();\n        for(int i = 0; i < n; i++){\n            int u = getId(gar[i].first, gar[i].second);\n            for(int j = i+1; j < n; j++){\n                int v = getId(gar[j].first, gar[j].second);\n                int d = g[u][v];\n                // printf(\"%d -> %d , %d\\n\", i,j,d);\n                adj[i].push_back(make_pair(j,d));\n                adj[j].push_back(make_pair(i,d));\n            }\n        }\n        // printf(\"sv : %d\\n\", sv);\n        int ans = rec(0,sv);\n        if(ans == inf) ans = -1;\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\n#include<cctype>\n#include<cstdlib>\n#include<map>\n#include<vector>\n#include<complex>\n#include<queue>\n#include<set>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, int>\n#define Y first\n#define X second\nconst int INF = 100000000;\n\n\nclass C{\n    public:\n        int y, x, step;\n        C(int _y, int _x, int _step){\n            y = _y;\n            x = _x;\n            step = _step;\n        }\n};\n\nint dfs(int now, int sum, int cnt, int goal, vector<bool> visited, vector< vector<int> > &v){\n    if(cnt == goal) return sum;\n    int ret = INF;\n    REP(i, v.size()){\n        if(!visited[i]){\n            visited[i] = true;\n            ret = min(ret, dfs(i, sum + v[now][i], cnt + 1, goal, visited, v));\n            visited[i] = false;\n        }\n    }\n    return ret;\n}\n\n\n\n\nint main(){\n    int h, w;\n    while(cin >>w >>h && h){\n        int cnt = 0, firy, firx;\n        vector< vector<char> > v(h, vector<char>(w));\n        vector<P> node;\n        REP(i, h){\n            REP(j, w){\n                cin >>v[i][j];\n                if(v[i][j] == 'o') node.push_back( P(i, j) );\n                if(v[i][j] == '*') cnt++;\n            }\n        }\n        REP(i, h) REP(j, w) if(v[i][j] == '*') node.push_back( P(i, j) );\n        vector< vector<int> > d(cnt + 1, vector<int>(cnt + 1, 0));\n        //debug\n        //cout <<cnt <<endl;\n        //REP(i, h){\n        //    REP(j, w){\n        //        cout <<v[i][j] <<\" \";\n        //    }\n        //    cout <<endl;\n        //}\n        REP(z, node.size()){\n            queue<C> open;\n            open.push( C(node[z].Y, node[z].X, 0) );\n            vector< vector<int> > closed(h, vector<int>(w, INF));\n            while(!open.empty()){\n                C now = open.front();\n                open.pop();\n\n                if(now.step >= closed[now.y][now.x]) continue;\n                closed[now.y][now.x] = now.step;\n\n                int my[] = {0, 0, 1, -1};\n                int mx[] = {1, -1, 0, 0};\n\n                REP(i, 4){\n                    int ny = now.y + my[i];\n                    int nx = now.x + mx[i];\n                    if(ny < 0 || nx < 0 || ny >= h || nx >= w || v[ny][nx] == 'x') continue;\n                    open.push( C(ny, nx, now.step + 1) );\n                }\n            }\n            REP(i, node.size()) d[z][i] = closed[node[i].Y][node[i].X];\n        }\n        //debug\n        //REP(i, d.size()){\n        //    REP(j, d[i].size()){\n        //        cout <<d[i][j] <<\" \";\n        //    }\n        //    cout <<endl;\n        //}\n        vector<bool> tmp(node.size(), false);\n        tmp[0] = true;\n        int ans = dfs(0, 0, 0, cnt, tmp, d);\n        cout <<(ans == INF? -1 : ans) <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint W,H,min_cost[20][20],work[20][20],dp[11][10][1024]; //dp[??????????????´??????][????????°???????????´???][??¶???] = ????°??????????\nchar table[20][21];\n\nstruct Info{\n\tInfo(){\n\t\trow = 0;\n\t\tcol = 0;\n\t}\n\n\tInfo(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\nInfo Target[10],start,target_start,target_goal;\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0},min_distance[10][10],target_count,from_start_min_distance[10],next_state;\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n//????????????????????¢??§????????????????????¢??°\nvoid enable_check(int row,int col){\n\tfor(int i = 0; i < 4; i++){\n\t\tif(rangeCheck(row+diff_row[i],col+diff_col[i]) == true && min_cost[row+diff_row[i]][col+diff_col[i]] > min_cost[row][col] &&\n\t\t\t\ttable[row+diff_row[i]][col+diff_col[i]] != 'x'){ //???????????§???????????£???????????????????????????????§??????????????????????????????????????????§??????\n\t\t\tmin_cost[row+diff_row[i]][col+diff_col[i]] = min_cost[row][col] + 1;\n\t\t\tenable_check(row+diff_row[i],col+diff_col[i]);\n\t\t}\n\t}\n}\n\nvoid calc_min_distance(int row,int col){\n\tfor(int i = 0; i < 4; i++){\n\t\tif(rangeCheck(row+diff_row[i],col+diff_col[i]) == true && work[row+diff_row[i]][col+diff_col[i]] > work[row][col] &&\n\t\t\t\ttable[row+diff_row[i]][col+diff_col[i]] != 'x'){ //???????????§???????????£???????????????????????????????§??????????????????????????????????????????§??????\n\t\t\twork[row+diff_row[i]][col+diff_col[i]] = work[row][col] + 1;\n\t\t\tcalc_min_distance(row+diff_row[i],col+diff_col[i]);\n\t\t}\n\t}\n}\n\nint main(){\n\n\tbool FLG;\n\tint ans,tmp;\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfor(int i = 0; i < H;i++){\n\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\tmin_cost[i][k] = BIG_NUM;\n\t\t\t}\n\t\t}\n\n\t\ttarget_count = 0;\n\n\t\t//?????±???????????????\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tscanf(\"%s\",table[i]);\n\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\tswitch(table[i][k]){\n\t\t\t\tcase '.':\n\t\t\t\t\t//Do nothing\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*': //?±??????????\n\t\t\t\t\tTarget[target_count].row = i;\n\t\t\t\t\tTarget[target_count].col = k;\n\t\t\t\t\ttarget_count++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'x': //?????????\n\t\t\t\t\t//Do nothing\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'o': //??????????????°???\n\t\t\t\t\tstart.row = i;\n\t\t\t\t\tstart.col = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tFLG = true;\n\n\t\t//???????????´????????§?????????????????????\n\t\tmin_cost[start.row][start.col] = 0;\n\t\tenable_check(start.row,start.col);\n\n\t\tfor(int i = 0; i < target_count; i++){\n\t\t\tif(min_cost[Target[i].row][Target[i].col] == BIG_NUM){ //start????????°?????§????????´???????????£????????¢??????\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\n\t\tif(!FLG){\n\t\t\tprintf(\"-1\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//???????????????????????°?????????????????¢????¨????\n\t\tfor(int i = 0; i < target_count; i++){\n\t\t\tfrom_start_min_distance[i] = min_cost[Target[i].row][Target[i].col];\n\t\t}\n\n\t\t//?¬??????´???????£???????????????¢????¨??????????\n\t\tfor(int i = 0; i < target_count; i++){\n\t\t\tfor(int k = 0; k < target_count; k++)min_distance[i][k] = BIG_NUM;\n\t\t}\n\n\t\tfor(int i = 0; i < target_count; i++){\n\t\t\ttarget_start = Target[i]; //??????????????°????????????????¨????\n\n\t\t\tfor(int k = 0; k < H; k++){\n\t\t\t\tfor(int p = 0; p < W;p++)work[k][p] = BIG_NUM;\n\t\t\t}\n\n\t\t\twork[target_start.row][target_start.col] = 0;\n\t\t\tcalc_min_distance(target_start.row,target_start.col);\n\n\t\t\tfor(int k = 0; k < target_count; k++){\n\t\t\t\tmin_distance[i][k] = min(min_distance[i][k],work[Target[k].row][Target[k].col]);\n\t\t\t}\n\t\t}\n\n\t\t//BIt_DP??§???????????¢????±???????\n\t\tfor(int i = 1; i <= target_count; i++){\n\t\t\tfor(int k = 0; k < target_count; k++){\n\t\t\t\tfor(int p = 0; p < pow(2,target_count);p++)dp[i][k][p] = BIG_NUM;\n\t\t\t}\n\t\t}\n\n\t\t//?????????start?????????????????´??????????????¢????¨???? dp[??????????????´??????][????????°???????????´???][??¶???] = ????°??????????\n\t\tfor(int i = 0; i < target_count; i++){\n\t\t\ttmp = pow(2,i);\n\t\t\tdp[1][i][tmp] = from_start_min_distance[i];\n\t\t}\n\n\t\tfor(int i = 2; i <= target_count; i++){ //??????????????´??????????????????\n\t\t\tfor(int k = 0; k < target_count; k++){ //???????????´????????´???????????????\n\t\t\t\tfor(int state = 0; state < pow(2,target_count); state++){ //??¶???????????????\n\t\t\t\t\tif(dp[i-1][k][state] == BIG_NUM)continue;\n\t\t\t\t\tfor(int a = 0; a < target_count; a++){ //?????????????????????\n\t\t\t\t\t\tif(state & (1 << a)){\n\t\t\t\t\t\t\t//??¢???????????´??????????????????????????´?????????????????????\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tnext_state = state+pow(2,a);\n\t\t\t\t\t\t\tdp[i][a][next_state] = min(dp[i][a][next_state],dp[i-1][k][state]+min_distance[k][a]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans = BIG_NUM;\n\t\ttmp = pow(2,target_count)-1;\n\n\t\tfor(int i = 0; i < target_count; i++){\n\t\t\tans = min(ans,dp[target_count][i][tmp]);\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\ntypedef pair<int, int> P;\n\nint INF = 1e+9;\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\nint w, h;\nstring s[20];\nvector<P> tile;\nint startId;\nint distTile[11][11];\nint dp[1 << 11][11];\n\nvoid chmin(int &a, int b) { a = min(a, b); }\nvoid bfs(P start, int dist[20][20]) {\n\tint i, j;\n\tqueue<P> que;\n\t\n\trep(i, h) rep(j, w) dist[i][j] = INF;\n\tdist[start.first][start.second] = 0;\n\tque.push(P(start.first, start.second));\n\t\n\twhile (!que.empty()) {\n\t\tP now = que.front(); que.pop();\n\t\tint y = now.first;\n\t\tint x = now.second;\n\t\t\n\t\trep(i, 4) {\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif (ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\tif (s[ny][nx] == 'x') continue;\n\t\t\tif (dist[ny][nx] > dist[y][x] + 1) {\n\t\t\t\tdist[ny][nx] = dist[y][x] + 1;\n\t\t\t\tque.push(P(ny, nx));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (cin >> w >> h) {\n\t\tif (!w) break;\n\t\tint i, j, k;\n\t\t\n\t\trep(i, h) cin >> s[i];\n\t\t\n\t\ttile.clear();\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tif (s[i][j] == '*') {\n\t\t\t\t\ttile.push_back(P(i, j));\n\t\t\t\t}\n\t\t\t\tif (s[i][j] == 'o') {\n\t\t\t\t\tstartId = tile.size();\n\t\t\t\t\ttile.push_back(P(i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i, tile.size()) {\n\t\t\tint dist[20][20];\n\t\t\tbfs(tile[i], dist);\n\t\t\trep(j, tile.size()) {\n\t\t\t\tdistTile[i][j] = dist[tile[j].first][tile[j].second];\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i, (1 << 11)) rep(j, 11) dp[i][j] = INF;\n\t\t\n\t\tdp[1 << startId][startId] = 0;\n\t\t\n\t\tint sz = tile.size();\n\t\trep(i, (1 << sz)) {\n\t\t\trep(j, sz) {\n\t\t\t\trep(k, sz) {\n\t\t\t\t\tif ((i >> k) & 1) continue;\n\t\t\t\t\tchmin(dp[i + (1 << k)][k], dp[i][j] + distTile[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\trep(i, sz) chmin(ans, dp[(1 << sz) - 1][i]);\n\t\tif (ans == INF) cout << -1 << endl;\n\t\telse cout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef queue<P> Q;\n\n#define _CRT_SECURE_NO_WARNINGS\nint H, W;\nchar c[21][21];\nP n[11];\nint N = 0;\nP s;\nint po[11] = { 1,2,4,8,16,32,64,128,256,512,1024 };\nint dp[1024][11];\n\nbool flag = true;\nint CalcCost(P p1, P p2) {\n\tQ q;\n\tq.push(p1);\n\tint cost[20][20];\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcost[i][j] = 100000;\n\t\t}\n\t}\n\tcost[p1.first][p1.second]=0;\n\twhile (!q.empty()) {\n\t\tint x = q.front().first,\n\t\t\ty = q.front().second; q.pop();\n\t\tint dh[4] = { 1 , -1 , 0 ,  0 };\n\t\tint dw[4] = { 0 ,  0 , 1 , -1 };\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint th = x + dh[i],\n\t\t\t\ttw = y + dw[i];\n\t\t\tif (0 <= th && th < H && 0 <= tw && tw < W) {\n\t\t\t\tif (c[th][tw] != 'x' && cost[th][tw] > cost[x][y] + 1) {\n\t\t\t\t\tif (p2 == make_pair(th, tw)) {\n\t\t\t\t\t\treturn cost[x][y] + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcost[th][tw] = cost[x][y] + 1;\n\t\t\t\t\t\tq.push(make_pair(th, tw));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid CalcStartToPoint() {\n\tQ q;\n\tq.push(s);\n\tint cost[20][20];\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcost[i][j] = 100000;\n\t\t}\n\t}\n\tcost[s.first][s.second] = 0;\n\tint count = 0;\n\twhile (!q.empty()) {\n\t\tint h = q.front().first,\n\t\t\tw = q.front().second; q.pop();\n\t\tif (c[h][w] == '*') {\n\t\t\tcount++;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif (n[i] == make_pair(h, w)) {\n\t\t\t\t\tdp[po[i]][i] = cost[h][w];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint dh[4] = { 1 , -1 , 0 ,  0 };\n\t\tint dw[4] = { 0 ,  0 , 1 , -1 };\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint th = h + dh[i],\n\t\t\t\ttw = w + dw[i];\n\t\t\tif (0 <= th && th < H && 0 <= tw && tw < W) {\n\t\t\t\tif (c[th][tw] != 'x' && cost[th][tw] > cost[h][w] + 1) {\n\t\t\t\t\tcost[th][tw] = cost[h][w] + 1;\n\t\t\t\t\tq.push(make_pair(th, tw));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (count!=N) {\n\t\tflag = false;\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tscanf(\"%d%d\", &W, &H);\n\t\tif (H == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tN = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tscanf(\"%s\", c[i]);\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (c[i][j] == '*') {\n\t\t\t\t\tn[N++] = make_pair(i, j);\n\t\t\t\t}\n\t\t\t\telse if (c[i][j] == 'o') {\n\t\t\t\t\ts = make_pair(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < po[N]; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tdp[i][j] = 1000000;\n\t\t\t}\n\t\t}\n\t\tflag = true;\n\t\tCalcStartToPoint();\n\t\tif (flag == false) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tint cost[11][11] = {};\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\tcost[j][i] = cost[i][j] = CalcCost(n[i], n[j]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < po[N]; i++){\n\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif ((i & po[k]) == 0 && j!=k) {\n\t\t\t\t\t\tdp[i + po[k]][k] = min(dp[i][j] + cost[j][k], dp[i + po[k]][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1000000;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tans = min(ans, dp[po[N]-1][i]);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint W, H;\nvector<string> smap;\nint map[25][25];\nint cpmap[25][25];\n\nstruct Tile {\n\tint x, y;\n\tTile() {};\n\tTile(int _x, int _y) : x(_x), y(_y) {}\n};\n\nstruct State {\n\tint x, y, d;\n\tState() {};\n\tState(int _x, int _y, int _d) : x(_x), y(_y), d(_d) {}\n};\n\nint DX[4] = {-1, 1, 0, 0};\nint DY[4] = {0, 0, -1, 1};\n\nint search(int sx, int sy, int ex, int ey) {\n\t// map copy\n\tmemset(cpmap, 0, sizeof(cpmap));\n\tfor (int i=0; i<H; i++) for (int j=0; j<W; j++) cpmap[i][j] = map[i][j];\n\t\n\t// search start\n\tint res = 1e9;\n\tqueue<State> q;\n\tq.push(State(sx, sy, 0));\n\t\n\twhile (!q.empty()) {\n\t\tState s = q.front(); q.pop();\n\t\t\n\t\tif (s.x == ex && s.y == ey) {\n\t\t\tres = min(res, s.d);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (res <= s.d) continue;\n\t\t\n\t\tfor (int d = 0; d < 4; d++) {\n\t\t\tif (!(0 <= s.x + DX[d] && s.x + DX[d] < W && 0 <= s.y + DY[d] && s.y + DY[d] < H)) continue;\n\t\t\tif (cpmap[s.y + DY[d]][s.x + DX[d]] != -1) {\n\t\t\t\tcpmap[s.y + DY[d]][s.x + DX[d]] = -1;\n\t\t\t\tq.push(State(s.x + DX[d], s.y + DY[d], s.d + 1));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solver() {\n\tmemset(map, 0, sizeof(map));\n\tint yogore = 1;\n\tint sx, sy;\n\tvector< Tile > YG;\n\t\n\tfor (int i=0; i<H; i++) {\n\t\tfor (int j=0; j<W; j++) {\n\t\t\tif (smap[i][j] == '.') map[i][j] = 0;\n\t\t\telse if (smap[i][j] == '*') {\n\t\t\t\tmap[i][j] = yogore++;\n\t\t\t\tYG.push_back(Tile(j, i));\n\t\t\t}\n\t\t\telse if (smap[i][j] == 'x') map[i][j] = -1;\n\t\t\telse if (smap[i][j] == 'o') {\n\t\t\t\tmap[i][j] = 0;\n\t\t\t\tsy = i; sx = j;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// dist matrix    start:0   YG:1~yogore-1\n\tvector< vector<int> > dist(yogore, vector<int>(yogore, 0));\n\t\n\t// start to yogore\n\tfor (int i=1; i<yogore; i++) {\n\t\tdist[0][i] = search(sx, sy, YG[i-1].x, YG[i-1].y);\n\t\tif (dist[0][i] >= 1e9) return -1;\t// 到達できないゴミがある\n\t}\n\t\n\t// 各ゴミから他のゴミへの距離\n\tfor (int i=1; i<yogore; i++) {\n\t\tfor (int j=i+1; j<yogore; j++) {\n\t\t\tdist[i][j] = dist[j][i] = search(YG[i-1].x, YG[i-1].y, YG[j-1].x, YG[j-1].y);\n\t\t}\n\t}\n\t\n\t// dist についてTSPを解く　スタートは　0\n\tint res = 1e9;\n\t\n\tvector<int> order(yogore-1);\n\tfor (int i=0; i<yogore-1; i++) order[i] = i + 1;\n\t\n\tdo {\n\t\t// 現在の訪問順序での総距離を求める\n\t\tint cur = 0;\n\t\tcur += dist[0][order[0]];\n\t\tfor (int i=1; i<yogore-1; i++) {\n\t\t\tcur += dist[order[i-1]][order[i]];\n\t\t}\n\t\t\n\t\tres = min(res, cur);\n\t} while (next_permutation(order.begin(), order.end()));\n\t\n\treturn res;\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> W >> H; if (W==0 && H==0) break;\n\t\tsmap.assign(H, \"\");\n\t\tfor (int i=0; i<H; i++) cin >> smap[i];\n\t\t\n\t\tcout << solver() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint w,h;\nchar c[22][22];\nint dist[444][444];\nint a[22];\nint dd[]={-1,0,1,0,-1};\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>w>>h;\n    if(w==0)break;\n    rep(i,h)cin>>c[i];\n    rep(i,h*w)rep(j,h*w)dist[i][j]=i==j?0:INF;\n    rep(i,h)rep(j,w){\n      if(c[i][j]=='x')continue;\n      rep(d,4){\n        int ni=i+dd[d],nj=j+dd[d+1];\n        if(ni>=0&&ni<h&&nj>=0&&nj<w&&c[ni][nj]!='x'){\n          dist[i*w+j][ni*w+nj]=dist[i*w+j][ni*w+nj]=1;\n        }\n      }\n    }\n    rep(k,h*w)rep(i,h*w)rep(j,h*w)minch(dist[i][j],dist[i][k]+dist[k][j]);\n    //rep(i,h*w)rep(j,h*w)dbg(dist[i][j]);\n    map<int,int> v;\n    int vmax=1;\n    rep(i,h)rep(j,w){\n      if(c[i][j]=='o'){\n        v[0]=i*w+j;\n      }else if(c[i][j]=='*'){\n        v[vmax++]=i*w+j;\n      }\n    }\n    rep(i,vmax)a[i]=i;\n    ll res=INF;\n    do{\n      if(a[0]!=0)continue;\n      ll sum=0;\n      rep(i,vmax-1){\n        sum+=dist[v[a[i]]][v[a[i+1]]];\n      }\n      minch(res,sum);\n    }while(next_permutation(a,a+vmax));\n    if(res==INF)cout<<-1<<endl;\n    else cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint main()\n{\n  int w,h,d[20][20],ii,min,sum,color[20][20],x,y;\n  int xy[4][2]={{-1,0},{1,0},{0,-1},{0,1}};\n  char c[20][20];\n  vector<pair<int,int> > v;\n  pair<int,int> u;\n  queue<pair<int,int> > q;\n  while(1){\n    cin>>w>>h;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>c[i][j];\n\tif(c[i][j]=='o'){\n\t  x=i;\n\t  y=j;\n\t}\n\tif(c[i][j]=='*'){\n\t  v.push_back(make_pair(i,j));\n\t}\n      }\n    }\n    sum=0;\n    while(1){\n      c[x][y]='.';\n      //cout<<x<<y;\n      q.push(make_pair(x,y));\n      for(int i=0;i<h;i++){\n\tfor(int j=0;j<w;j++)d[i][j]=500;\n      }\n      d[x][y]=0;\n      while(!q.empty()){\n\tu=q.front();q.pop();\n\tfor(int i=0;i<4;i++){\n\t  if(d[u.first+xy[i][0]][u.second+xy[i][1]]!=500)continue;\n\t  if(c[u.first+xy[i][0]][u.second+xy[i][1]]!='x'){\n\t    q.push(make_pair(u.first+xy[i][0],u.second+xy[i][1]));\n\t    d[u.first+xy[i][0]][u.second+xy[i][1]]=d[u.first][u.second]+1;\n\t  }\n\t}\n      }\n      min=500;\n      for(int i=0;i<v.size();i++){\n\tif(min>d[v[i].first][v[i].second]){\n\t  min=d[v[i].first][v[i].second];\n\t  x=v[i].first;\n\t  y=v[i].second;\n\t  ii=i;\n\t}\n      }\n      if(min==500)break;\n      sum+=min;\n      v.erase(v.begin()+ii);\n      if(v.empty())break;\n    }\n    if(min==500)cout<<\"-1\"<<endl;\n    else cout<<sum<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <vector>\n#include <queue>\n\nchar stage[20][20];\nint cost[1024][10];\nint dis[10][10];\nint w, h;\n\ntypedef std::tuple<int, int, int> T;\nstd::vector<T> pos_to_num;\n\nlong long unsigned PopCount(long long unsigned x) {\n\tx = (x & 0x5555555555555555ULL) + ((x & 0xAAAAAAAAAAAAAAAAULL) >> 1);\n\tx = (x & 0x3333333333333333ULL) + ((x & 0xCCCCCCCCCCCCCCCCULL) >> 2);\n\tx = (x & 0x0F0F0F0F0F0F0F0FULL) + ((x & 0xF0F0F0F0F0F0F0F0ULL) >> 4);\n\n\tx *= 0x0101010101010101ULL;\n\n\treturn x;\n}\n\nvoid dijkstra(int sx, int sy)\n{\n\tint c[20][20] = {0};\n\tint f[20][20] = {0};\n\tint dx[4] = {1, -1, 0, 0};\n\tint dy[4] = {0, 0, 1, -1};\n\n\tstd::queue<std::tuple<int,int>> q;\n\tq.push(std::make_tuple(sx, sy));\n\tf[sx][sy] = 1;\n\n\twhile(!q.empty()) {\n\t\tauto a = q.front(); q.pop();\n\t\tint x = std::get<0>(a);\n\t\tint y = std::get<1>(a);\n\t\tfor ( int i = 0; i < 4; ++i ) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif ( nx < 0 || nx >= w ) continue;\n\t\t\tif ( ny < 0 || ny >= h ) continue;\n\t\t\tif ( stage[nx][ny] == 'x' ) continue;\n\t\t\tif ( f[nx][ny] == 1 ) continue;\n\n\t\t\tc[nx][ny] = c[x][y] + 1;\n\t\t\tf[nx][ny] = 1;\n\t\t\tq.push(std::make_tuple(nx, ny));\n\t\t}\n\t}\n\n\tif ( stage[sx][sy] == 'o' ) {\n\t\tfor ( int i = 0; i < pos_to_num.size(); ++i ) {\n\t\t\tcost[0][std::get<2>(pos_to_num[i])] = c[std::get<0>(pos_to_num[i])][std::get<1>(pos_to_num[i])];\n\t\t}\n\t} else if ( stage[sx][sy] == '*' ) {\n\t\tint num;\n\t\tfor ( int i = 0; i < pos_to_num.size(); ++i ) {\n\t\t\tif ( sx == std::get<0>(pos_to_num[i]) && sy == std::get<1>(pos_to_num[i]) ) {\n\t\t\t\tnum = std::get<2>(pos_to_num[i]);\n\t\t\t}\n\t\t}\n\t\tfor ( int i = 0; i < pos_to_num.size(); ++i ) {\n\t\t\tdis[num][std::get<2>(pos_to_num[i])] = c[std::get<0>(pos_to_num[i])][std::get<1>(pos_to_num[i])];\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile ( true ) {\n\t\tfor ( int i = 0; i < 1024; ++i ) {\n\t\t\tfor ( int j = 0; j < 10; ++j ) {\n\t\t\t\tcost[i][j] = 0xfffff;\n\t\t\t}\n\t\t}\n\n\t\tstd::cin >> w >> h;\n\t\tif ( w == 0 && h == 0 ) return 0;\n \n\t\tint sx, sy;\n\t\tint k = 0;\n\t\tfor ( int i = 0; i < h; ++i ) {\n\t\t\tfor ( int j = 0; j < w; ++j ) {\n\t\t\t\tstd::cin >> stage[j][i];\n\t\t\t\tif ( stage[j][i] == '*' ) {\n\t\t\t\t\tpos_to_num.push_back(T(j, i, k));\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tif ( stage[j][i] == 'o' ) {\n\t\t\t\t\tsx = j; sy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdijkstra(sx, sy);\n\t\tfor ( auto &v: pos_to_num ) {\n\t\t\tdijkstra(std::get<0>(v), std::get<1>(v));\n\t\t}\n\t\tstd::vector<std::tuple<int, int>> table(1<<k);\n\t\tfor ( int i = 0; i < (1<<k); ++i ) {\n\t\t\ttable[i] = std::make_tuple(PopCount(i), i);\n\t\t}\n\t\tstd::sort(table.begin(), table.end());\n\n\t\tfor ( int i = 1; i < (1<<k); ++i ) {\n\t\t\tint q = std::get<1>(table[i]);\n\t\t\tfor ( int j = 0; j < k; ++j ) {\n\t\t\t\tif ( q & (1<<j) ) {\n\t\t\t\t\tfor ( int l = 0; l < k; ++l ) {\n\t\t\t\t\t\tint c = cost[q^(1<<j)][j] + dis[j][l];\n\t\t\t\t\t\tcost[q][l] = (c < cost[q][l]) ? c : cost[q][l];\n\t\t\t\t\t\t//std::cout << \"state:\" << q << \" to:\" << l << \" cost:\" << cost[q][l] << std::endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min = 0xfffff;\n\t\tfor ( int i = 0; i < k; ++i ) {\n\t\t\tif ( min > cost[(1<<k)-1][i] ) min = cost[(1<<k)-1][i];\n\t\t}\n\t\tif ( min == 0xfffff || min == 0 ) {\n\t\t\tstd::cout << -1 << std::endl;\n\t\t} else {\n\t\t\tstd::cout << min << std::endl;\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e9\n\nint di[4] = {0, -1, 0, 1};\nint dj[4] = {1, 0, -1, 0};\n\nint w, h, si, sj, gi, gj, n;\n\nint dist[11][11];\n/* メモ再帰 */\n\nint dp[(1<<20) + 1][21]; // dpテーブルは余裕をもったサイズにする\nint rec(int bit, int v)\n{\n    // すでに探索済みだったらリターン\n    if (dp[bit][v] != -1) return dp[bit][v];\n\n    // 初期値\n    if (bit == (1<<v)) {\n        if(v != 0) return dp[bit][v] = INF;\n        else return dp[bit][v] = 0;\n    }\n\n    // 答えを格納する変数\n    int res = INF;\n\n    // bit の v を除いたもの\n    int prev_bit = bit & ~(1<<v);\n\n    // v の手前のノードとして u を全探索\n    for (int u = 0; u < n; ++u) {\n        if (!(prev_bit & (1<<u))) continue; // u が prev_bit になかったらダメ\n\n        // 再帰的に探索\n        if (res > rec(prev_bit, u) + dist[u][v]) {\n            res = rec(prev_bit, u) + dist[u][v];\n        }\n    }\n\n    return dp[bit][v] = res; // メモしながらリターン\n}\n\n\nint bfs(vector<vector<bool> > canGo){\n\n//まず最初にsの情報をキューに追加して、盤面を埋める\n    queue<pair<int, pair<int, int> > > wait;\n    wait.push(make_pair(0, make_pair(si, sj)));\n    canGo[si][sj] = false;\n\n    //以下、幅優先\n    int ans = INF;   //ansを-1で初期化\n\n    while(!wait.empty()){    //キュー画空になるまで\n        //キューの先頭要素を取り出す\n        int nowcost = wait.front().first;\n        int nowi = wait.front().second.first;\n        int nowj = wait.front().second.second;\n\n        wait.pop();\n\n        //ゴールにたどり着いたらそのコストが答え\n        if(nowi == gi && nowj == gj){\n            ans = nowcost;\n            break;\n        }\n\n        //四方向を探索\n        for(int k = 0; k < 4; k++){\n            int nexti = nowi + di[k];\n            int nextj = nowj + dj[k];\n\n            //その方向に進めるなら\n            if(canGo[nexti][nextj]){\n                //そのマスにキューを追加し\n                //再度検索することのないように壁で埋める\n                wait.push(make_pair(nowcost + 1, make_pair(nexti, nextj)));\n                canGo[nexti][nextj] = false;\n            }\n        }\n    }\n\n    //出力\n    \n    return ans;\n\n}\n\nint main(){\n\n    while(1){\n        cin >> w >> h;\n        if(!w) break;\n\n        vector<pair<int, int> > s;\n        s.push_back({0, 0});\n        vector<vector<bool> > a(h + 2, vector<bool> (w + 2, false));\n        for(int i = 1; i <= h; i++){\n            for(int j = 1; j <= w; j++){\n                char input; cin >> input;\n                if(input == 'x') continue;\n                else{\n                    a[i][j] = true;\n\n                    if(input == 'o'){\n                        s[0].first = i;\n                        s[0].second = j;\n                    }else if(input == '*'){\n                        s.push_back({i, j});\n                    }\n                }\n            }\n        }\n\n        n = s.size();\n        \n        //vector<vector<int> > dist(v, vector<int> (v));\n        for(int k = 0; k < n; k++){\n            for(int l = 0; l <= k; l++){\n\n                //cout << k << \" \" << l << endl;\n                if(k == l) dist[k][l] = 0;\n                else{\n                    si = s[k].first;\n                    sj = s[k].second;\n                    gi = s[l].first;\n                    gj = s[l].second;\n\n                    dist[k][l] = bfs(a);\n                    dist[l][k] = dist[k][l];\n\n                }\n            }\n        }\n    \n\n\n        /*cout << \"ok\"<< endl;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                cout << dist[i][j] << \" \";\n            }\n            cout << endl;\n        }*/\n\n        // テーブルを全部 -1 にしておく (-1 でなかったところは探索済)\n        for (int bit = 0; bit < (1<<n); ++bit) for (int v = 0; v < n; ++v) dp[bit][v] = -1;\n\n        // 探索\n        int res = INF;\n        for (int v = 0; v < n; ++v) {\n            if (res > rec((1<<n)-1, v)) {\n                res = rec((1<<n)-1, v);\n            }\n        }\n\n\n        if(res >= INF) cout << -1 << endl;\n        else cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n// using namespace std;\n\n#define fst(t) std::get<0>(t)\n#define snd(t) std::get<1>(t)\n#define thd(t) std::get<2>(t)\n\nusing ll = long long;\nusing P = std::tuple<int,int>;\n\nconst int dx[8] = {-1, 1, 0, 0, -1, -1, 1, 1}, dy[8] = {0, 0, -1, 1, -1, 1, -1, 1};\n\nint W, H;\nstd::string map[50];\nint Xs[15], Ys[15];\nint dist[15][15], d[50][50], dp[12][1<<12];\n\nvoid generateMap(int x0, int y0){\n    std::queue<P> qu;\n    qu.emplace(x0, y0);\n\n    std::fill(&d[0][0], &d[0][0]+50*50, 1001001001);\n    d[x0][y0] = 0;\n    \n    while(!qu.empty()){\n        int x, y;\n        std::tie(x, y) = qu.front();\n        qu.pop();\n\n        for(int i=0;i<4;++i){\n            int nx = x + dx[i], ny = y + dy[i];\n            if(0 <= nx && nx < W &&\n               0 <= ny && ny < H &&\n               map[ny][nx] != 'x' &&\n               d[nx][ny] > d[x][y] + 1){\n                d[nx][ny] = d[x][y] + 1;\n                qu.emplace(nx, ny);\n            }\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    while(true){\n        std::cin >> W >> H;\n        if(W == 0){return 0;}\n\n        int ast_idx = 1;\n    \n        for(int i=0;i<H;++i){\n            std::cin >> map[i];\n\n            for(int j=0;j<W;++j){\n                if(map[i][j] == 'o'){\n                    Xs[0] = j;\n                    Ys[0] = i;\n                }else if(map[i][j] == '*'){\n                    Xs[ast_idx] = j;\n                    Ys[ast_idx++] = i;\n                }\n            }\n        }\n\n        for(int i=0;i<ast_idx;++i){\n            generateMap(Xs[i], Ys[i]);\n\n            // printf(\"# %d\\n\", i);\n            // for(int j=0;j<H;++j){\n            //     for(int k=0;k<W;++k){\n            //         printf(\"%2d%c\", d[k][j], \" \\n\"[k+1==W]);\n            //     }\n            // }\n        \n            for(int j=0;j<ast_idx;++j){\n                dist[i][j] = d[Xs[j]][Ys[j]];\n            }\n        }\n\n        std::fill(&dp[0][0], &dp[0][0]+12*(1<<12), 1001001001);\n        dp[0][1] = 0;\n\n        for(int i=0;i<(1<<ast_idx);++i){\n            for(int j=0;j<ast_idx;++j){\n                for(int k=0;k<ast_idx;++k){\n                    dp[k][i | (1 << k)]\n                        = std::min(dp[k][i | (1 << k)],\n                                   dp[j][i] + dist[j][k]);\n                }\n            }\n        }\n\n        int res = 1001001001;\n        for(int i=0;i<ast_idx;++i){\n            res = std::min(res, dp[i][(1<<ast_idx)-1]);\n        }\n\n        if(res == 1001001001){res = -1;}\n        printf(\"%d\\n\", res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cctype>\nusing namespace std;\n\n#define SIZE_MAX 20\n#define N_MAX 11\n#define INF 99999999\n\nint W, H;\nchar M[SIZE_MAX][SIZE_MAX];\nint N;\nint D[N_MAX][N_MAX];\n\nstruct A {\n  int x, y, cost;\n  A(int x, int y, int cost) : x(x), y(y), cost(cost) {}\n};\n\nvoid bfs(int n, int sx, int sy) {\n  const int dx[4] = {1,0,-1,0};\n  const int dy[4] = {0,1,0,-1};\n  bool vsted[SIZE_MAX][SIZE_MAX];\n  queue<A> que;\n  A a(sx, sy, 0);\n\n  que.push(a);\n  for(int i = 0; i < H; ++i) {\n    fill(vsted[i], vsted[i] + W, false);\n  }\n  vsted[sy][sx] = true;\n\n  while(!que.empty()) {\n    a = que.front(); que.pop();\n\n    if(isupper(M[a.y][a.x])) {\n      int t = M[a.y][a.x] - 'A';\n      if(D[n][t] == INF) {\n\tD[n][t] = D[t][n] = a.cost;\n      }\n    }\n\n    for(int i = 0; i < 4; ++i) {\n      int nx = a.x + dx[i];\n      int ny = a.y + dy[i];\n      if(nx < 0 || nx >= W) continue;\n      if(ny < 0 || ny >= H) continue;\n      if(M[ny][nx] == 'x') continue;\n      if(vsted[ny][nx]) continue;\n      vsted[ny][nx] = true;\n      que.push(A(nx, ny, a.cost + 1));\n    }\n  }\n}\n\nvoid show() {\n  for(int i = 0; i < N; ++i) {\n    for(int j = 0; j < N; ++j) {\n      if(D[i][j] == INF) cout << \"IF\" << \"  \";\n      else       cout << D[i][j] << \"  \";\n    }\n    cout << endl;\n  }\n}\n\nvoid makeD(int rx, int ry) {\n  for(int i = 0; i < N; ++i) {\n    for(int j = 0; j < N; ++j) {\n      D[i][j] = i == j ? 0 : INF;\n    }\n  }\n\n  bfs(0, rx, ry);\n  for(int y = 0; y < H; ++y) {\n    for(int x = 0; x < W; ++x) {\n      if(isupper(M[y][x])) bfs(M[y][x]-'A', x, y);\n    }\n  }\n}\n\nvoid solve(int rx, int ry) {\n  makeD(rx, ry);\n  int dp[1 << N_MAX][N_MAX];\n  for(int i = 0; i < 1<<N_MAX; ++i) {\n    fill(dp[i], dp[i] + N_MAX, INF);\n  }\n  dp[1 << 0][0] = 0;\n  for(int s = 1 << 0 + 1; s < (1 << N); ++s) {\n\n  }\n}\n\nint calcCost(int v[]) {\n  int now = 0;\n  int cost = 0;\n  for(int i = 0; i < N-1; ++i) {\n    cost += D[now][v[i]];\n    now = v[i];\n  }\n  return cost;\n}\n\nvoid solve2(int rx, int ry) {\n  makeD(rx, ry);\n  int v[N_MAX];\n  for(int i = 1; i < N; ++i) {\n    v[i-1] = i;\n  }\n  int ans = INF;\n  do {\n    ans = min(ans, calcCost(v));\n  } while(next_permutation(v, v + (N-1)));\n  if(ans == INF) ans = -1;\n  cout << ans << endl;\n}\n\nmain() {\n  while((cin >> W >> H) && (W || H)) {\n    N = 1;\n    int rx, ry;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tcin >> M[i][j];\n\tif(M[i][j] == 'o') { rx = j; ry = i; }\n\tif(M[i][j] == '*') M[i][j] = 'A' + N++;\n      }\n    }\n    solve2(rx, ry);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<queue>\n\n#define INF 100000000\n#define x first\n#define y second\n#define f first\n#define s second\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<P,int>P3;\n\nstring grid[20];\nint g[11][11],cost[21][21],h,w;\nint dx[4]={-1,1,0,0};\nint dy[4]={0,0,-1,1};\nvector<P>v;\n\nvoid bfs(P st,int id){\n\t\n\tqueue<P3>que;\n\tque.push(P3(st,0));\n\twhile(!que.empty()){\n\t\tP3 now=que.front();\n\t\tque.pop();\n\t\tif(cost[now.f.y][now.f.x]<=now.s)continue;\n\t\t\n\t\tcost[now.f.y][now.f.x]=now.s;\n\t\n\t\tif(grid[now.f.y][now.f.x]=='*')\n\t\t\tfor(int i=0;i<v.size();i++)\n\t\t\t\tif(v[i]==now.f)g[id][i]=now.s;\n\t\t\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=now.f.x+dx[i],ny=now.f.y+dy[i];\n\t\t\tif(nx<0 || ny<0 || w<=nx || h<=ny || grid[ny][nx]=='x')continue;\n\t\t\tque.push(P3(P(nx,ny),now.s+1));\n\t\t}\n\t}\n}\n\nint main(void){\n\t\n\twhile(cin >> w >> h,h|w){\n\t\t\n\t\tfor(int i=0;i<h;i++)cin >> grid[i];\n\t\tfill(g[0],g[11],INF);\n\t\tv.clear();\n\t\tP st;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(grid[i][j]=='o')st.x=j,st.y=i,v.push_back(st);\n\t\t\t\tif(grid[i][j]=='*')v.push_back(P(j,i));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tfill(cost[0],cost[21],INF);\n\t\t\tbfs(v[i],i);\n\t\t}\n\t\t\n\t\tvector<P3>tmp;\n\t\tint stid;\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tif(v[i]!=st)tmp.push_back(P3(v[i],i));\n\t\t\telse if(v[i]==st)stid=i;\n\t\t}\n\t\t\n\t\tsort(tmp.begin(),tmp.end());\n\t\tint ans=INF;\n\t\tdo{\n\t\t\tint cnt=0;\n\t\t\tfor(int i=0;i<tmp.size()-1;i++)cnt+=g[tmp[i].s][tmp[i+1].s];\n\t\t\tans=min(ans,g[stid][tmp[0].s]+cnt);\n\t\t}while(next_permutation(tmp.begin(),tmp.end()));\n\t\tif(ans>=INF)cout << -1 << endl;\n\t\telse cout << ans << endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (int)(999999999/2)\n#define eps 1e-9\n#define MAX_N 5000\nint w,h;\nint fie[30][30];\nstring data[30];\n\n\nvoid bfs(int yy,int xx){\n    int dx[]={0,1,0,-1};\n    int dy[]={1,0,-1,0};\n    queue<pii> que;\n    que.push(pii(yy,xx));\n    \n    bool used[30][30]={};\n    used[yy][xx]=true;\n    while(que.size()){\n        int y=que.front().first,x=que.front().second;\n        //        cout<<y<<\" \"<<x<<endl;\n        que.pop();\n        \n        rep(i,4){\n            int ddy=y+dy[i],ddx=x+dx[i];\n            if(ddy<0||ddx<0||ddy>=h||ddx>=w||data[ddy][ddx]=='x'||used[ddy][ddx])continue;\n            fie[ddy][ddx]=fie[y][x]+1;\n            used[ddy][ddx]=true;\n            que.push(pii(ddy,ddx));\n        }\n    }\n}\n\nint main(){\n    while(cin>>w>>h&&w&&h){\n        int v=0;\n        rep(i,h){\n            cin>>data[i];\n        }\n        \n        vector<pii> p;\n        rep(i,h)rep(j,w)if(data[i][j]=='o'){p.pb(pii(i,j));v++;}\n        rep(i,h)rep(j,w)if(data[i][j]=='*'){p.pb(pii(i,j));v++;}\n        map<  pair<pii,pii> , int  > pass;\n        rep(i,p.size()){\n            rep(j,30)rep(k,30)fie[j][k]=INF;\n            fie[p[i].first][p[i].second]=0;\n            bfs(p[i].first,p[i].second);\n            rep(j,p.size()){\n                pass[make_pair(p[i],p[j])]=fie[p[j].first][p[j].second];\n            }\n        }\n        vector<int> num;\n        rep(i,v-1)num.pb(i+1);\n        sort(all(num));\n        int mini=INF;\n        do{\n            int sum=0;\n            sum+=pass[  make_pair(p[0],p[num[0]])  ];\n            rep(i,v-2){\n                sum+=pass[  make_pair(p[num[i]],p[num[i+1]])  ];\n            }\n            mini=min(mini,sum);\n        }while(next_permutation(all(num)));\n        if(mini==INF)cout<<\"-1\"<<endl;\n        else cout<<mini<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<int, int> P;\nint bfs(void);\nint INF=10000000;\nint w,h;\nint sx,sy;\nint dx[4]={-1,0,1,0};\nint dy[4]={0,1,0,-1};\nint d[100][100];\nchar mapp[100][100];\nint main(){\n  int kari;\n  while(1){\n    int yogore=0;\n    int ans=0;\n\n    cin>>w>>h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>mapp[i][j];\n\tif(mapp[i][j]=='*'){\n\t  yogore++;\n\t}else if(mapp[i][j]=='o'){\n\t  sy=i;\n\t  sx=j;\n\t}\n      }\n    }\n    for(int i=0;i<yogore;i++){\n      kari=bfs();\n      if(kari==0){\n\tans=-1;\n\tbreak;\n      }else{\n\tans+=kari;\n      }\n      \n    }\n    cout<<ans<<endl;\n  }\n}\nint bfs(void){\n  queue<P> que;\n  que.push(P(sy,sx));\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      d[i][j]=INF;\n    }\n  }\n  d[sy][sx]=0;\n  while(que.size()){\n    P p=que.front();\n    que.pop();\n    if(mapp[p.first][p.second]=='*'){\n      sy=p.first;\n      sx=p.second;\n      mapp[p.first][p.second]='.';\n      break;\n    }\n    for(int i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(0<=nx && nx<w && 0<=ny && ny<h && mapp[ny][nx]!='x' && d[ny][nx]==INF){\n\tque.push(P(ny,nx));\n\td[ny][nx]=d[p.first][p.second]+1;\n      }\n    }\n  }\n  return d[sy][sx];\n}\n\t\n    "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1000000000;\n\nint w, h;\nchar c[20][25];\n\nint x[11], y[11];\nint dCounter;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint minlength[20][20];\nbool used[20][20];\n\nvoid bfs(P s) {\n  for (int i = 0; i < h; i++)\n    for (int j = 0; j < w; j++) minlength[i][j] = INF, used[i][j] = false;\n  minlength[s.second][s.first] = 0;\n  queue<P> que;\n  que.push(s);\n  while (!que.empty()) {\n    P p = que.front(); que.pop();\n    int px = p.first, py = p.second;\n    if (used[py][px]) continue;\n    used[py][px] = true;\n    for (int i = 0; i < 4; i++) {\n      int newy = py + dy[i], newx = px + dx[i];\n      if (newy < 0 || newy >= h || newx < 0 || newx >= w) continue;\n      if (c[py + dy[i]][px + dx[i]] != 'x' && !used[newy][newx]) {\n        minlength[py + dy[i]][px + dx[i]] = minlength[py][px] + 1;\n        que.push(P(px + dx[i], py + dy[i]));\n      }\n    }\n  }\n}\n\nint cost[11][11];\nint bitdp[1<<12][11];\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &w, &h);\n    if (w == 0) break;\n    for (int i = 0; i < h; i++) scanf(\"%s\", c[i]);\n    dCounter = 1;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (c[i][j] == '*') x[dCounter] = j, y[dCounter++] = i;\n        if (c[i][j] == 'o') x[0] = j, y[0] = i;\n      }\n    }\n    bool flag = false;\n    for (int i = 0; i < dCounter; i++) {\n      bfs(P(x[i], y[i]));\n      for (int j = 0; j < dCounter; j++) {\n        cost[i][j] = minlength[y[j]][x[j]];\n        if (cost[i][j] == INF) i = j = dCounter, flag = true;\n      }\n    }\n    if (flag) {\n      printf(\"-1\\n\");\n      continue;\n    }\n    int maxbit = (1 << dCounter) - 1;\n    for (int i = 0; i < maxbit - 1; i++)\n      for (int j = 0; j < dCounter; j++) bitdp[i][j] = INF;\n    bitdp[maxbit][0] = 0;\n    for (int s = maxbit - (1 << 0); s >= 0; s--) {\n      for (int from = 0; from < dCounter; from++) {\n        for (int to = 0; to < dCounter; to++) {\n          if (((s >> to) & 1) == 0) continue;\n          if (bitdp[s][from] == INF) continue;\n          if (to == from) continue;\n          bitdp[s & ~(1 << to)][to] = min(bitdp[s & ~(1 << to)][to], bitdp[s][from] + cost[from][to]);\n        }\n      }\n    }\n    int ans = INF;\n    for (int i = 0; i < dCounter; i++) ans = min(ans, bitdp[0][i]);\n    printf(\"%d\\n\", ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 21\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h;\nstring mp[N];\nint G[N][N];\nmap<P,int>M;\n\nvoid bfs(P start){\n  int D[N][N];\n  memset(D,-1,sizeof(D));\n  queue<P> Q;\n  Q.push(start);\n  int x=start.first,y=start.second;\n  D[y][x]=0;\n  while(!Q.empty()){\n    P t=Q.front();Q.pop();\n    x=t.first,y=t.second;\n\n    if(mp[y][x]=='*'||mp[y][x]=='o') G[M[start]][M[t]]=D[y][x];\n\n    int dx[]={0,0,-1,1},dy[]={1,-1,0,0};\n    for(int i=0;i<4;i++){\n      int nx=x+dx[i],ny=y+dy[i],cost=D[y][x]+1;\n      if(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx]=='x')continue;\n      if(D[ny][nx]==-1)Q.push(P(nx,ny)),D[ny][nx]=cost;\n    }\n  }\n}\n\nvector<P> p;\nP start;\nint n,num[11];\n\nint calc(){\n  int res=0;\n  for(int i=1;i<n;i++)res+=G[num[i-1]][num[i]];\n  return res;  \n}\n\nint dfs(int idx){\n  if(idx==n) return calc();\n  int res=1e9;\n  for(int i=1;i<n;i++){\n    if(num[i]>=0)continue;\n    num[i]=idx;\n    res=min(res,dfs(idx+1));\n    num[i]=-1;\n  }\n  return res;\n}\n\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    for(int i=0;i<h;i++) cin>>mp[i];\n    M.clear();\n    p.clear();\n    memset(G,-1,sizeof(G));\n    memset(num,-1,sizeof(num));\n    n=0;\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tP t=P(j,i);\n\tif(mp[i][j]=='*'||mp[i][j]=='o') p.push_back(t),M[t]=n++;\n\tif(mp[i][j]=='o') start=t;\n      }\n    for(int i=0;i<n;i++)bfs(p[i]);\n    int flg=1;\n    for(int i=0;i<n;i++)if(G[0][i]==-1)flg=0;\n    num[0]=M[start];\n    cout <<(flg?dfs(1):-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define X first\n#define Y second\n#define INF 100000000\n\nstruct P {\n    int from, cost;\n    int trashes;\n\n    bool operator >(const P& p) const {\n        return cost > p.cost;\n    }\n};\n\nconst int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\n\nint W, H;\nchar field[20][20];\n\nint bfs(pii start, pii goal) {\n    vvb G(H, vb(W));\n    queue<pii> que;\n    pii sentry = {-1, -1};\n    que.push(start);\n    que.push(sentry);\n    int cnt = 0;\n    while (!que.empty()) {\n        pii p = que.front(); que.pop();\n        if (p.X == goal.X && p.Y == goal.Y) {\n            return cnt;\n        }\n        if (p == sentry) {\n            if (que.empty()) break;\n            que.push(sentry);\n            cnt++;\n            continue;\n        }\n\n        REP(i, 4) {\n            int sx = p.X + dx[i], sy = p.Y + dy[i];\n            if (0 <= sx && sx < W && 0 <= sy && sy < H && field[sy][sx] != 'x') {\n                if (!G[sy][sx]) {\n                    G[sy][sx] = true;\n                    que.push({sx, sy});\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nint main() {\n    while (cin >> W >> H, W|H) {\n        pii start;\n        vector<pii> trash;\n        REP(y, H) REP(x, W) {\n            cin >> field[y][x];\n            switch (field[y][x]) {\n            case 'o':\n                start = {x, y};\n                break;\n            case '*':\n                trash.push_back({x, y});\n                break;\n            }\n        }\n\n        vvi G(11, vi(1<<10, INF));\n\n        int n = SZ(trash);\n        vvi E(n+1, vi(n+1));\n        REP(i, n) {\n            E[n][i] = E[i][n] = bfs(start, trash[i]);\n            FOR(j, i+1, n) {\n                E[i][j] = E[j][i] = bfs(trash[i], trash[j]);\n            }\n        }\n\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push({n, 0, (1<<n)-1});\n        G[n][(1<<n)-1] = 0;\n        while (!que.empty()) {\n            P p = que.top(); que.pop();\n            if (p.trashes == 0) {\n                cout << p.cost << endl;\n                goto END;\n            }\n\n            REP(to, SZ(E[p.from])) {\n                if (E[p.from][to] == 0) continue;\n                int cost = p.cost + E[p.from][to];\n                int trashes = p.trashes & ~(1 << to);\n                if (G[to][trashes] > cost) {\n                    G[to][trashes] = cost;\n                    que.push({to, cost, trashes});\n                }\n            }\n        }\n        cout << -1 << endl;\nEND: {}\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  // max, min, sort\n#include <iomanip>    // setprecision\n#include <iostream>\n#include <queue>\n#include <set>\n#include <vector>\n// #include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-10;\n\nstruct Node\n{\n    Node(int X, int Y, int C)\n    {\n        x = X;\n        y = Y;\n        cost = C;\n    }\n\n    int x, y, cost;\n};\n\nvoid findObs(int sobs, vector<string>& map, vector<pair<int, int> >& obs, vector<vector<int> >& costVec)\n{\n    int h = map.size();\n    int w = map[0].length();\n\n    queue<Node> q;  // sx, sy\n    bool visited[h][w];\n    for (int i = 0; i < h; i++)\n        for (int j = 0; j < w; j++) visited[i][j] = false;\n\n    q.push(Node(obs[sobs].first, obs[sobs].second, 0));\n\n    while (q.size() > 0)\n    {\n        Node cur = q.front();\n        int x = cur.x;\n        int y = cur.y;\n        int cost = cur.cost;\n        q.pop();\n\n        if (visited[y][x] || x < 0 || x >= w || y < 0 || y >= h || map[y][x] == 'x') continue;\n        visited[y][x] = true;\n\n        if (map[y][x] == '*')\n        {\n            for (int i = 0; i < obs.size(); i++)\n            {\n                if (x == obs[i].first && y == obs[i].second) costVec[sobs][i] = min(costVec[sobs][i], cost);\n            }\n        }\n\n        q.push(Node(x + 1, y, cost + 1));\n        q.push(Node(x - 1, y, cost + 1));\n        q.push(Node(x, y + 1, cost + 1));\n        q.push(Node(x, y - 1, cost + 1));\n    }\n}\n\nstruct DNode\n{\n    DNode(int i, int c, set<int>& v)\n    {\n        idx = i;\n        cost = c;\n        visited = v;\n    }\n    int idx;\n    int cost;\n    set<int> visited;\n    //long long visited;\n};\n\nstruct CustomCompare\n{\n    bool operator()(const DNode& n1, const DNode& n2)\n    {\n        return n1.cost > n2.cost;\n    }\n};\n\nint dijkstra(vector<string>& map, vector<pair<int, int> >& obs, vector<vector<int> >& costVec)\n{\n    priority_queue<DNode, vector<DNode>, CustomCompare> q;\n    set<int> v;\n    q.push(DNode(0, 0, v));\n\n    set<pair<int, set<int> > > checked;\n\n    while (q.size() > 0)\n    {\n        DNode d = q.top();\n        q.pop();\n\n        if (d.visited.size() == obs.size() - 1) return d.cost;\n        if (checked.find(make_pair(d.idx, d.visited)) != checked.end()) continue;\n        checked.insert(make_pair(d.idx, d.visited));\n\n        for (int i = 1; i < obs.size(); i++)\n        {\n            if (i == d.idx || d.visited.find(i) != d.visited.end() || costVec[d.idx][i] == 9999) continue;\n            set<int> nv = d.visited;\n            nv.insert(i);\n            if (checked.find(make_pair(i, nv)) != checked.end()) continue;\n            q.push(DNode(i, d.cost + costVec[d.idx][i], nv));\n        }\n    }\n\n    return -1;\n}\n\nint main()\n{\n    // n, r　適切な変数名に置き換える\n    int w, h;\n    while (cin >> w >> h, w != 0 && h != 0)\n    {\n        // Global 変数の初期化忘れずに\n\n        vector<string> map(h);\n        vector<pair<int, int> > obs;  // (x, y)\n        int sx, sy;\n        for (int i = 0; i < h; i++)\n        {\n            cin >> map[i];\n            for (int j = 0; j < w; j++)\n            {\n                if (map[i][j] == 'o')\n                {\n                    sx = j;\n                    sy = i;\n                }\n                else if (map[i][j] == '*')\n                {\n                    obs.push_back(make_pair(j, i));\n                }\n            }\n        }\n\n        obs.insert(obs.begin(), make_pair(sx, sy));\n\n        // for (int i = 0; i < obs.size(); i++)\n        // {\n        //     cout << \"{\" << obs[i].first << \", \" << obs[i].second << \"} \";\n        // }\n        // cout << endl;\n\n        vector<vector<int> > cost(obs.size());\n        for (int i = 0; i < obs.size(); i++)\n        {\n            cost[i] = vector<int>(obs.size());\n            for (int j = 0; j < obs.size(); j++) cost[i][j] = 9999;\n        }\n\n        for (int i = 0; i < obs.size(); i++)\n        {\n            findObs(i, map, obs, cost);\n        }\n\n        // for (int i = 0; i < obs.size(); i++)\n        // {\n        //     for (int j = 0; j < obs.size(); j++) cout << cost[i][j] << \" \";\n        //     cout << endl;\n        // }\n\n        int ans = dijkstra(map, obs, cost);\n        if (ans == 9999) ans = -1;\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 21\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h,G[N][N];\nstring mp[N];\nmap<P,int>M;\n\nvoid bfs(P s){\n  int D[N][N];\n  memset(D,-1,sizeof(D));\n  queue<P> Q;\n  Q.push(s);\n  int x=s.first,y=s.second;\n  D[y][x]=0;\n  while(!Q.empty()){\n    P t=Q.front();Q.pop();\n    x=t.first,y=t.second;\n    if(mp[y][x]=='*'||mp[y][x]=='o') G[M[s]][M[t]]=D[y][x];\n\n    int dx[]={0,0,-1,1},dy[]={1,-1,0,0};\n    for(int i=0;i<4;i++){\n      int nx=x+dx[i],ny=y+dy[i],cost=D[y][x]+1;\n      if(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx]=='x'||D[ny][nx]!=-1)continue;\n      Q.push(P(nx,ny));\n      D[ny][nx]=cost;\n    }\n  }\n}\n\nint n,num[11];\nP start;\nint calc(){\n  int res=0;\n  for(int i=1;i<n;i++)res+=G[num[i-1]][num[i]];\n  return res;  \n}\n\nint dfs(int idx){\n  if(idx==M[start]) return dfs(idx+1);\n  if(idx==n) return calc();\n  int res=1e9;\n  for(int i=0;i<n;i++){\n    if(num[i]!=-1)continue;\n    num[i]=idx;\n    res=min(res,dfs(idx+1));\n    num[i]=-1;\n  }\n  return res;\n}\n\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h)break;\n    for(int i=0;i<h;i++) cin>>mp[i];\n    M.clear();\n    memset(G,-1,sizeof(G));\n    memset(num,-1,sizeof(num));\n    n=0;\n    vector<P> p;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tP t=P(j,i);\n\tif(mp[i][j]=='*'||mp[i][j]=='o') p.push_back(t),M[t]=n++;\n\tif(mp[i][j]=='o') start=t;\n      }\n    for(int i=0;i<n;i++)bfs(p[i]);\n\n    bool flg=1;\n    for(int i=0;i<n;i++)if(G[0][i]==-1)flg=0;\n    num[0]=M[start];\n    cout <<(flg?dfs(0):-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\nlong long int MOD = 1000000007;\n\nint main(){\n\twhile(true){\n\t\tint h, w;\n\t\tcin >> w >> h;\n\t\tif(h == 0){\n\t\t\tbreak;\n\t\t}\n\t\tstring str[25];\n\t\tint px[20], py[20];\n\t\tint cnt = 1;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tcin >> str[i];\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(str[i][j] == 'o'){\n\t\t\t\t\tpy[0] = i;\n\t\t\t\t\tpx[0] = j;\n\t\t\t\t}\n\t\t\t\tif(str[i][j] == '*'){\n\t\t\t\t\tpy[cnt] = i;\n\t\t\t\t\tpx[cnt] = j;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cost[15][15];\n\t\tfor(int i = 0; i < cnt; i++){\n\t\t\tfor(int j = 0; j < cnt; j++){\n\t\t\t\tcost[i][j] = 100000;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < cnt; i++){\n\t\t\tfor(int j = i + 1; j < cnt; j++){\n\t\t\t\tbool used[25][25] = {};\n\t\t\t\tP pp = make_pair(py[i], px[i]);\n\t\t\t\tqueue<P> que;\n\t\t\t\tque.push(pp);\n\t\t\t\tfor(int loop = 0; !que.empty(); loop++){\n\t\t\t\t\tint sz = que.size();\n\t\t\t\t\tfor(int k = 0; k < sz; k++){\n\t\t\t\t\t\tP p = que.front();\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t\tif(p.first < 0 || p.second < 0 || p.first >= h || p.second >= w){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(used[p.first][p.second]){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tused[p.first][p.second] = true;\n\t\t\t\t\t\tif(p.first == py[j] && p.second == px[j]){\n\t\t\t\t\t\t\tcost[i][j] = loop;\n\t\t\t\t\t\t\tcost[j][i] = loop;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(str[p.first][p.second] == 'x'){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tP p2 = make_pair(p.first - 1, p.second);\n\t\t\t\t\t\tque.push(p2);\n\t\t\t\t\t\tp2 = make_pair(p.first + 1, p.second);\n\t\t\t\t\t\tque.push(p2);\n\t\t\t\t\t\tp2 = make_pair(p.first, p.second - 1);\n\t\t\t\t\t\tque.push(p2);\n\t\t\t\t\t\tp2 = make_pair(p.first, p.second + 1);\n\t\t\t\t\t\tque.push(p2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cout << cost[i][j] << \" \";\n\t\t\t}\n\t\t}\n\t\t\n\t\tint a[20];\n\t\tfor(int i = 0; i < cnt; i++){\n\t\t\ta[i] = i;\n\t\t}\n\t\t\n\t\tint ans = 100000;\n\t\tdo{\n\t\t\tint ret = 0;\n\t\t\tfor(int i = 0; i < cnt - 1; i++){\n\t\t\t\tret += cost[a[i]][a[i + 1]];\n\t\t\t}\n\t\t\tans = min(ans, ret);\n\t\t}while(next_permutation(a + 1, a + cnt));\n\t\tif(ans < 100000){\n\t\t\tcout << ans << endl;\n\t\t}else{\n\t\t\tcout << \"-1\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n\n#define int long long\n\nusing namespace std;\n\nclass Solver {\n};\nsigned main() {\n\twhile (true) {\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif (w == 0)break;\n\n\t\ttuple<int, int> start;\n\t\tvector<vector<bool>> grid(h, vector<bool>(w, true));\n\t\tmap<tuple<int,int>,int> points;\n\t\tint cnt = 0;\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif (c == '.')continue;\n\t\t\t\tif (c == 'x') {\n\t\t\t\t\tgrid[i][j] = false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (c == 'o')start = make_tuple(i, j);\n\t\t\t\tif (c == '*') {\n\t\t\t\t\tcnt++;\n\t\t\t\t\tpoints.emplace(make_tuple(i, j), points.size() + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpoints.emplace(start, 0);\n\n\t\tvector<map<int, int>> graph(points.size());\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (points.find(make_tuple(i, j)) == points.end())continue;\n\n\t\t\t\tint st_i = points[make_tuple(i, j)];\n\n\t\t\t\tvector<vector<int>> dist(h, vector<int>(w, 1e9));\n\t\t\t\tqueue<tuple<int, int, int>> que;\n\t\t\t\tque.push(make_tuple(i, j, 0));\n\t\t\t\twhile (que.size() > 0) {\n\t\t\t\t\tint y = get<0>(que.front());\n\t\t\t\t\tint x = get<1>(que.front());\n\t\t\t\t\tint d = get<2>(que.front());\n\t\t\t\t\tque.pop();\n\t\t\t\t\tif (dist[y][x] <= d)continue;\n\n\t\t\t\t\tdist[y][x] = d;\n\t\t\t\t\tif (points.find(make_tuple(y,x))!=points.end()\n\t\t\t\t\t\t&& (i != y || j != x)) {\n\t\t\t\t\t\tint index = points[make_tuple(y, x)];\n\t\t\t\t\t\tgraph[st_i].emplace(index, d);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (y > 0 && grid[y - 1][x]) {\n\t\t\t\t\t\tque.emplace(make_tuple(y - 1, x, d + 1));\n\t\t\t\t\t}\n\t\t\t\t\tif (y + 1 < h && grid[y + 1][x]) {\n\t\t\t\t\t\tque.emplace(make_tuple(y + 1, x, d + 1));\n\t\t\t\t\t}\n\t\t\t\t\tif (x > 0 && grid[y][x - 1]) {\n\t\t\t\t\t\tque.emplace(make_tuple(y, x - 1, d + 1));\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < w && grid[y][x + 1]) {\n\t\t\t\t\t\tque.emplace(make_tuple(y, x + 1, d + 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint length = graph[0].size();\n\t\tif (length != cnt) {\n\t\t\tcout << -1<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvector<int> pats;\n\t\tfor (int i = 1; i < points.size(); i++)pats.emplace_back(i);\n\n\t\tint res =1e9;\n\t\tdo {\n\t\t\tint tmp = 0;\n\t\t\tint prev = 0;\n\t\t\tfor (int i = 0; i < pats.size(); i++) {\n\t\t\t\ttmp += graph[prev][pats[i]];\n\t\t\t\tprev = pats[i];\n\t\t\t}\n\t\t\tres = min(res, tmp);\n\t\t} while (next_permutation(pats.begin(), pats.end()));\n\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 9999999;\n\nint w, h;\nstring b[20];\nint d[20][20];\n\nchar dx[] = {-1,1,0,0};\nchar dy[] = {0,0,-1,1};\n\nvoid dist(int sx, int sy){\n\tfor(int i=0;i<20;i++)\n\t\tfor(int j=0;j<20;j++)\n\t\t\td[i][j] = INF;\n\tqueue< pair<int,int> > qu;\n\tqu.push(make_pair(sx,sy));\n\td[sy][sx] = 0;\n\twhile(!qu.empty()){\n\t\tpair<int, int> p = qu.front(); qu.pop();\n\t\tint x = p.first, y = p.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif(nx<0||nx>=w||ny<0||ny>=h||b[ny][nx]=='x') continue;\n\t\t\tif(d[ny][nx] != INF) continue;\n\t\t\td[ny][nx] = d[y][x] + 1;\n\t\t\tqu.push(make_pair(nx,ny));\n\t\t}\n\t}\n}\n\nint main(){\n\tint c[11][11];\n\tint x[11], y[11];\n\tint ans[1<<11][11];\n\twhile(cin >> w >> h){\n\t\tif(!(w||h)) break;\n\t\tint num = 1;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin >> b[i];\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(b[i][j]=='o') x[0] = j, y[0] = i;\n\t\t\t\tif(b[i][j]=='*') x[num] = j, y[num++] = i;\n\t\t\t}\n\t\t}\n\t\tbool flag = false;\n\t\tmemset(c,0,sizeof(c));\n\t\tdist(x[0],y[0]);\n\t\tfor(int i=1;i<num;i++){\n\t\t\tc[0][i] = d[y[i]][x[i]];\n\t\t\tif(c[0][i] == INF) flag = true;\n\t\t}\n\t\tif(flag) { cout << -1 << endl; continue; }\n\t\tfor(int i=1;i<num;i++){\n\t\t\tdist(x[i],y[i]);\n\t\t\tfor(int j=0;j<num;j++){\n\t\t\t\tif(i==j) continue;\n\t\t\t\tc[i][j] = d[y[j]][x[j]];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(1<<num);i++) for(int j=0;j<num;j++) ans[i][j] = INF;\n\t\tans[1][0] = 0;\n\t\tfor(int i=0;i<(1<<num);i++){\n\t\t\tfor(int j=0;j<num;j++)\n\t\t\t\tif((i>>j)&1)\n\t\t\t\t\tfor(int k=0;k<num;k++)\n\t\t\t\t\t\tans[i|(1<<k)][k] = min(ans[i|(1<<k)][k],ans[i][j]+c[j][k]);\n\t\t}\n\t\tint cost = INF;\n\t\tfor(int i=1;i<num;i++) cost = min(cost, ans[(1<<num)-1][i]);\n\t\tcout << cost << endl;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define REP2(i,m,n) for (int i=m;i<(n);i++)\n\n\nconst int INF = 1 << 28;\nint dr[4] = {0, 0, -1, 1};\nint dc[4] = {-1, 1, 0, 0};\nint H, W, start, M;\nchar B[21][21];\nvector<int> dests;\nint dist[401][401];\nint mem[1 << 10][10];\n\n\nint dp(int mask, int from) {\n    if (mask == 0) return dist[start][dests[from]];\n    if (mem[mask][from] >= 0) return mem[mask][from];\n\n    int ret = INF;\n    REP(i, M) {\n        if (mask & (1 << i)) {\n            int tmp = from < M ? dist[dests[from]][dests[i]] : 0;\n            tmp += dp(mask - (1 << i), i);\n            ret = min(ret, tmp);\n        }\n    }\n\n    return mem[mask][from] = ret;\n}\n\n\nint main() {\n    while (true) {\n        cin >> W >> H;\n        if (W == 0) break;\n        REP(i, H) REP(j, W) cin >> B[i][j];\n\n        dests.resize(0);\n        REP(i, H*W) REP(j, H*W) dist[i][j] = i == j ? 0 : INF;\n\n        REP(i, H) REP(j, W) {\n            if (B[i][j] == 'o') start = i * W + j;\n            else if (B[i][j] == '*') dests.push_back(i * W + j);\n            else if (B[i][j] == 'x') continue;\n            REP(k, 4) {\n                int ni = i + dr[k];\n                int nj = j + dc[k];\n                if (ni < 0 || ni >= H || nj < 0 || nj >= W)\n                    continue;\n                if (B[ni][nj] == 'x')\n                    continue;\n                dist[i * W + j][ni * W + nj] = 1;\n            }\n        }\n\n        REP(i, H*W) REP(j, H*W) REP(k, H*W)\n            dist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n\n        M = dests.size();\n        REP(i, 1 << M) REP(j, M+1) mem[i][j] = -1;\n\n        int ans = dp((1 << M) - 1, M);\n        if (ans == INF) cout << -1 << endl;\n        else cout  << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint h, w, k[21][21], cnt;\nint cx[11], cy[11], y[11][11], z[11][11], bfs[21][21], a, b, c[10], sum, minx;\nchar p;\nqueue<int>Q;\n\nvoid BFS() {\n\twhile (!Q.empty()) {\n\t\ta = Q.front() / 20;\n\t\tb = Q.front() % 20;\n\t\tif (k[a - 1][b] == 0 && bfs[a - 1][b] >= 1000000) {\n\t\t\tQ.push(Q.front() - 20);\n\t\t\tbfs[a - 1][b] = bfs[a][b] + 1;\n\t\t}\n\t\tif (k[a + 1][b] == 0 && bfs[a + 1][b] >= 1000000) {\n\t\t\tQ.push(Q.front() + 20);\n\t\t\tbfs[a + 1][b] = bfs[a][b] + 1;\n\t\t}\n\t\tif (k[a][b + 1] == 0 && bfs[a][b + 1] >= 1000000) {\n\t\t\tQ.push(Q.front() + 1);\n\t\t\tbfs[a][b + 1] = bfs[a][b] + 1;\n\t\t}\n\t\tif (k[a][b - 1] == 0 && bfs[a][b - 1] >= 1000000) {\n\t\t\tQ.push(Q.front() - 1);\n\t\t\tbfs[a][b - 1] = bfs[a][b] + 1;\n\t\t}\n\t\tQ.pop();\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tmemset(z, 0, sizeof(z));\n\t\tcin >> w >> h; cnt = 1; if (!w) { break; }\n\t\tfor (int i = 0; i < 21; i++) { \n\t\t\tfor (int j = 0; j < 21; j++) { \n\t\t\t\tk[i][j] = 1; \n\t\t\t} \n\t\t}\n\t\tcnt = 1;\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tcin >> p;\n\t\t\t\tif (p != 'x') { k[i][j] = 0; }\n\t\t\t\tif (p == '*') { cx[cnt] = j; cy[cnt] = i; cnt++; }\n\t\t\t\tif (p == 'o') { cx[0] = j; cy[0] = i; }\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\tc[i] = i;\n\t\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\t\tmemset(bfs, 10, sizeof(bfs));\n\t\t\t\tbfs[cy[i]][cx[i]] = 0;\n\t\t\t\tQ.push(cy[i] * 20 + cx[i]);\n\t\t\t\tBFS();\n\t\t\t\tz[i][j] = bfs[cy[j]][cx[j]];\n\t\t\t}\n\t\t}\n\t\tminx = 114514;\n\t\tdo\n\t\t{\n\t\t\tsum = z[0][c[0] + 1];\n\t\t\tfor (int i = 0; i < cnt - 1; i++) { sum += z[c[i] + 1][c[i + 1] + 1]; }\n\t\t\tminx = min(minx, sum);\n\t\t} while (next_permutation(c, c + cnt - 1));\n\t\tif (minx == 114514) { minx = -1; }\n\t\tcout << minx << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int w,h;\n    while(cin>>w>>h, w||h){\n        vector<string> s(h);\n        for(int i=0;i<h;i++) cin>>s[i];\n        vector<vector<int>> dis(1000,vector<int>(1000,INF));\n        for(int i=0;i<h*w;i++) dis[i][i]=0;\n        vector<P> dirty;\n        int sx,sy;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(s[i][j]=='x') continue;\n                if(s[i][j]=='*') dirty.push_back(P(i,j));\n                if(s[i][j]=='o'){\n                    sx=i;sy=j;\n                }\n\n                for(int k=0;k<4;k++){\n                    int nx=i+dx[k],ny=j+dy[k];\n                    if(nx<0 || h<=nx || ny<0 || w<=ny) continue;\n                    if(s[nx][ny]=='x') continue;\n                    int st=i*w+j,gt=nx*w+ny;\n                    dis[st][gt]=1;\n                }\n            }\n        }\n        for(int k=0;k<h*w;k++){\n            for(int i=0;i<h*w;i++){\n                for(int j=0;j<h*w;j++){\n                    dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n                }\n            }\n        }\n        int sz=dirty.size();\n        int res=INF;\n        do{\n            int sx2=sx,sy2=sy;\n            int tmp=0;\n            for(int i=0;i<sz;i++){\n                int nx=dirty[i].first,ny=dirty[i].second;\n                tmp+=dis[sx2*w+sy2][nx*w+ny];\n                sx2=nx;sy2=ny;\n            }\n            res=min(res,tmp);\n        }while(next_permutation(dirty.begin(),dirty.end()));\n        if(res>=INF) cout<<-1<<endl;\n        else cout<<res<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                     #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,pa>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                  \n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                             double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \nbool parareru(Point a,Point b,Point c,Point d){\n//\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n\treturn abs(cross(a-b,d-c))<EPS;\n}\ndouble distance_ls_p(Point a, Point b, Point c) {\n  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n  return abs(cross(b-a, c-a)) / (b-a).absv();\n}\nbool is_intersected_ls(Segment a,Segment b) {\n\tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n//\t\tcout<<\"sss\"<<endl;\n\t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n\t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n\t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n\t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n\t\treturn false;\n\t}\n  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n}\n\ndouble segment_dis(Segment a,Segment b){\n\tif(is_intersected_ls(a,b))return 0;\n\tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n\tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n\tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n\tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n\treturn r;\n}\n\n\n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\n\n\nint dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\nint q[30][30];\nint n,w,h;\nvector<pa> ve;\n\nint xs,ys;\nbool b;\nint dis(int x1,int y1,int x2,int y2){\n\t\n\tqueue<ppap> st;\n\tint sumi[30][30]={0};\n\tst.push(mp(0,mp(x1,y1)));\n\twhile((st.size())>0){\n\t\tppap z=st.front();\n\t\tst.pop();\n\t\tif(z.second.first==x2 && z.second.second==y2) return z.first;\n\t\tif(sumi[z.second.first][z.second.second]==1) continue;\n\t\tsumi[z.second.first][z.second.second]=1;\n\t\t\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(q[z.second.first+dx[i]][z.second.second+dy[i]]==0) st.push(mp(z.first+1,mp(z.second.first+dx[i],z.second.second+dy[i])));\n\t\t}\t\n\t\t\n\t\t\n\t}\n\tb=false;\n\treturn -1;\n\t\n}\n\n\nsigned main(){\n\n\tint cnt=0;\n\twhile(1){\n\t\t\n\t\tcin>>w>>h;\n\t\tif(w==0) return 0;\n\t\tve.clear();\n\t\tfor(int i=0;i<30;i++)for(int j=0;j<30;j++)q[i][j]=-1;\n\t\t\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(s[j]!='x'){\n\t\t\t\t\tq[i][j+1]=0;\n\t\t\t\t\tif(s[j]=='*')ve.pb(mp(i,j+1));\n\t\t\t\t\tif(s[j]=='o') xs=i,ys=j+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint d[15][15];\n\t\tb=true;\n\t\tfor(int i=0;i<ve.size();i++)for(int j=i+1;j<ve.size();j++){\n\t\t\tint g=dis(ve[i].first,ve[i].second,ve[j].first,ve[j].second);\n\t\t\td[i+1][j+1]=g;\n\t\t\td[j+1][i+1]=g;\n\t\t//\tcout<<i<<\" \"<<j<<\" \"<<g<<endl;\n\t\t}\n\t\tfor(int i=0;i<ve.size();i++){\n\t\t\tint g=dis(xs,ys,ve[i].first,ve[i].second);\n\t\t\td[0][i+1]=g;\n\t\t\td[i+1][0]=g;\n\t\t}\n\t\t\n\t\tif(!b){\n\t\t\tcout<<-1<<endl;\n\t\t}\n\t\telse{\n\t\tvector<int> a;\n\t\tfor(int i=1;i<=ve.size();i++)a.pb(i);\n\t\tint ans=1000000000;\n\t\tdo {\n\t\t\tint y=0;\n\t\t\tfor(int i=0;i<a.size()-1;i++) y+= d[a[i]][a[i+1]];\n\t\t\ty += d[0][a[0]];\n\t\t\tans=min(ans,y);\n \t\t\t  \n  \t\t} while (next_permutation(a.begin(), a.end()));\n\t\t\tcout<<ans<<endl;\n\t\t}\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> Pa;\n\nint dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nconst int inf = 99999;\n\nbool bfs(char a[21][21], int w, int h, Pa pa[12], int p, int dis[12][12])\n{\n\tbool f = false;\n\tfor(int k = 0; k < p-1 ; k++){\n\t\tbool vis[21][21];\n\t\tint d[21][21];\n\t\tqueue<Pa> que;\n\t\tPa t;\n\t\tint s = p-k-1;\n\t\t\n\t\tfill(&d[0][0], &d[h][w], 0);\n\t\tfill(&vis[0][0], &vis[h][w], true);\n\t\ta[pa[k].first][pa[k].second] = '.';\n\t\tque.push(pa[k]);\n\t\tvis[t.first][t.second] = false;\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tt = que.front();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tfor(int i = k+1; i < p; i++){\n\t\t\t\tif(pa[i].first == t.first && pa[i].second == t.second){\n\t\t\t\t\tdis[k][i] = dis[i][k] = d[t.first][t.second];\n\t\t\t\t\ts--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s == 0){\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint u = t.second+dx[i], v = t.first+dy[i];\n\t\t\t\tif(0 <= u && u < w && 0 <= v && v < h){\n\t\t\t\t\tif(vis[v][u] && a[v][u] != 'x'){\n\t\t\t\t\t\tque.push(Pa(v, u));\n\t\t\t\t\t\td[v][u] = d[t.first][t.second]+1;\n\t\t\t\t\t\tvis[v][u] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn f;\n}\n\nint tsp(int dis[12][12], int p)\n{\n\tint dp[1<<12][12];\n\tfill(&dp[0][0], &dp[(1<<12)-1][11], inf);\n\tdp[(1<<p)-1][1] = 0;\n\t\n\tfor(int i = (1<<p)-2; i >= 1; i--){\n\t\tfor(int j = 0; j < p; j++){\n\t\t\tfor(int k = 0; k < p; k++){\n\t\t\t\tif(i>>k & 1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i|1<<k][k]+dis[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn dp[1][0];\n}\n\nint main()\n{\n\tint h, w;\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0){\n\t\t\tbreak;\n\t\t}\n\t\tint p=1, dis[12][12];\n\t\tchar a[21][21];\n\t\tPa pa[12];\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tcin >> a[i];\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(a[i][j] == 'o'){\n\t\t\t\t\tpa[0] = Pa(i, j);\n\t\t\t\t}\n\t\t\t\tif(a[i][j] == '*'){\n\t\t\t\t\tpa[p++] = Pa(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfill(&dis[0][0], &dis[p][p], inf);\t\n\t\tfor(int i = 0; i < p; i++){\n\t\t\tdis[i][i] = 0;\n\t\t}\n\t\t\n\t\tif(bfs(a, w, h, pa, p, dis)){\n\t\t\tcout << tsp(dis, p) << endl;\n\t\t} else {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include <limits.h> \n#define MAX 20\n#define DMAX 10\nusing namespace std;\n\nclass Point{\n    public:\n    int y, x;\n    Point(){}\n    Point( int y, int x ): y(y), x(x){}\n    bool operator == ( const Point &p ) const{\n        return ( x == p.x && y == p.y );\n    }\n};\n\nint W, H;\nchar G[MAX][MAX];\nPoint start;\nPoint dirty[DMAX];\nint dsize;\nint T[DMAX]; // start to all dirty;\nint M[DMAX][DMAX]; // all dirty to all dirty\n\nint bfs( Point p1, Point p2 ){\n    bool visited[MAX][MAX];\n    int d[MAX][MAX];\n    queue<Point> q;\n    \n    for ( int i = 0; i < H; i++ ){\n        for ( int j = 0; j < W; j++ ){\n            visited[i][j] = false;\n            d[i][j] = INT_MAX;\n        }\n    }\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, -1, 0, 1};\n    \n    q.push( p1 );\n    d[p1.y][p1.x] = 0;\n    \n    Point u;\n    \n    while ( !q.empty() ){\n        u = q.front(); q.pop();\n        \n        if ( u == p2 ) return d[u.y][u.x];\n        \n        int nx, ny;\n        for ( int r = 0; r < 4; r++ ){\n            ny = u.y + dy[r];\n            nx = u.x + dx[r];\n            \n            if ( !( 0 <= nx && 0 <= ny && ny < H && nx < W ) ) continue;\n            \n            if ( !visited[ny][nx] && G[ny][nx] != 'x' ){\n                visited[ny][nx] = true;\n                d[ny][nx] = d[u.y][u.x] + 1;\n                q.push( Point( ny, nx ) );\n            }\n        }\n    }\n    \n    return INT_MAX;\n}\n\nvoid computeDistanceTable(){\n    for ( int i = 0; i < dsize; i++ ){\n        T[i] = bfs( start, dirty[i]);\n    }\n    for ( int i = 0; i < dsize-1; i++ ){\n        for ( int j = i; j < dsize; j++ ){\n            if ( i == j ) M[i][j] = M[j][i] = 0;\n            M[i][j] = M[j][i] = bfs( dirty[i], dirty[j] );\n        }\n    }\n}\n\nint getMinimumMove(){\n    int order[DMAX];\n    for ( int i = 0; i < dsize; i++ ){\n        order[i] = i;\n    }\n    \n    int minMove = INT_MAX;\n    \n    do{\n        int move = T[ order[0] ];\n        \n        for ( int i = 1; i < dsize; i++ ){\n            move += M[ order[i-1] ][ order[i] ];\n        }\n        \n        if ( minMove > move ) minMove = move;\n        \n    } while( next_permutation(order, order + dsize )) ;\n    \n    return minMove;\n}\n\nbool notReachable(){\n    for ( int i = 0; i < dsize; i++ ){\n        if ( T[i] == INT_MAX ) return true;\n    }\n    return false;\n}\n\nvoid compute(){\n    computeDistanceTable();\n    if ( notReachable() ) cout << \"-1\" << endl;\n    else {\n        cout << getMinimumMove() << endl;\n    }\n}\n\nbool read(){\n    cin >> W >> H;\n    if ( W == 0 && H == 0 ) return false;\n    dsize = 0;\n    char ch;\n    for ( int i = 0; i < H; i++ ){\n        for ( int j = 0; j < W; j++ ){\n            cin >> ch;\n            G[i][j] = ch;\n            if ( ch == 'o' ){\n                start = Point(i, j);\n            } else if ( ch == '*' ){\n                dirty[dsize++] = Point(i, j);\n            }\n        }\n    }\n    return true;\n}\n\nmain(){\n    while ( read() ) compute();\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <complex>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define EPS 1e-8\n#define DEB 0\n\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {-1,0,1,0};\nint w,h,sx,sy;\nchar field[32][32];\nvector<pair<int,int> > t_node;\nint node[16][16],visited[32][32];\nint dp[1<<10][16];\n\nint main(){\n\t\n\twhile(scanf(\" %d%d \",&w,&h),w|h){\n\t\tmemset(node,0,sizeof(node));\n\t\trep(i,1<<10)rep(j,16)dp[i][j]=INT_MAX;\n\t\t\n\t\tt_node.clear();\n\t\trep(i,h){\n\t\t\tscanf(\"%s\",field[i]);\n\t\t\trep(j,w){\n\t\t\t\tif( field[i][j]=='o' ){\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}else if( field[i][j]=='*' ){\n\t\t\t\t\tt_node.push_back(mp(j,i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( t_node.size()==0 ){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tt_node.push_back(mp(sx,sy));\n#if DEB\n\t\trep(i,t_node.size()){\n\t\t\tprintf(\"(%d,%d)\\n\",t_node[i].first, t_node[i].second);\n\t\t}\n#endif\t\n\t\t\n\n\t\t// make node (bfs)\n\t\trep(i,t_node.size()){\n\t\t\tmemset(visited,-1,sizeof(visited));\n\t\t\tqueue<pair<int,int> > q;\n\t\t\tq.push(mp(t_node[i].first, t_node[i].second));\n\t\t\tvisited[t_node[i].second][t_node[i].first] = 0;\n\t\t\twhile( !q.empty() ){\n\t\t\t\tint x = q.front().first;\n\t\t\t\tint y = q.front().second;\n\t\t\t\tint c = visited[y][x];\n\t\t\t\tq.pop();\n\t\t\t\trep(k,4){\n\t\t\t\t\tint tx = x + dx[k];\n\t\t\t\t\tint ty = y + dy[k];\n\t\t\t\t\tif( tx<0 || ty<0 || tx>=w || ty>=h || field[ty][tx]=='x' || visited[ty][tx]!=-1 )continue;\n\t\t\t\t\tvisited[ty][tx] = c+1;\n\t\t\t\t\tq.push(mp(tx,ty));\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t\t\n\t\t\trep(j,t_node.size())if( i!=j ){\n\t\t\t\tnode[i][j] = visited[t_node[j].second][t_node[j].first];\n\t\t\t}\n\t\t}\n\n#if DEB\t\t\n\t\trep(i,t_node.size()){\n\t\t\trep(j,t_node.size()){\n\t\t\t\tprintf(\"%d \",node[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\tputs(\"\");\n#endif\t\t\n\t\t\t\n\n#if DEB\n\t\trep(i,h){\n\t\t\tputs(field[i]);\n\t\t}puts(\"\");\n#endif\n\t\t\n\t\tint n = t_node.size();\n\t\tint ans = INT_MAX;\n\t\tdp[0][n-1] = 0;\n\t\t\n\t\trep(i,n-1){ //kosuu\n\t\t\tint comb = (1<<i)-1;\n\t\t\twhile( comb < (1<<(n-1)) ){\n\t\t\t\trep(k,n)if( dp[comb][k]!=INT_MAX ){ //now node\n\t\t\t\t\trep(l,n-1)if( !((1<<l)&comb) && node[k][l]>0 ){\n\t\t\t\t\t\tdp[comb|(1<<l)][l] = min(dp[comb|(1<<l)][l], dp[comb][k]+node[k][l]);\n\t\t\t\t\t\tif( (comb|(1<<l))==((1<<(n-1))-1) ){\n\t\t\t\t\t\t\tans = min(ans, dp[(1<<(n-1))-1][l]);\n\t\t\t\t\t\t}\n#if DEB\n\t\t\t\t\t\tprintf(\"bit:%d  , %d --> %d  , cost:%d\\n\",comb|(1<<l),k,l,dp[comb|(1<<l)][l]);\n#endif\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( comb==0 )break;\n\t\t\t\tint x = comb & -comb;\n\t\t\t\tint y = comb + x;\n\t\t\t\tcomb = ((comb&~y)/x>>1)|y;\n\t\t\t}\n\t\t}\n\t   \n#if DEB\n\t\tprintf(\"%d\\n\",(1<<(n-1))-1);\n#endif\t\t\n\t\tprintf(\"%d\\n\",ans==INT_MAX ? -1 : ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <bits/stdc++.h>\nusing namespace std;\nint r, c, sx, sy;\nbool vis[21][21];\nvector<string> grid;\nstring str;\nint dx[] = {0, 0, 1, -1};\nint dy[] = {-1, 1, 0, 0};\nint nn = 0;\nbool in_grid(int x, int y){\n    return x >= 0 && y >= 0 && x < r && y < c;\n}\nint bfs(int x, int y){\n    if(nn == 0)return 0;\n    memset(vis, 0, sizeof(vis));\n    queue<pair<int, int> > q;\n    q.push(make_pair(x, y));\n    vis[x][y] = 1;\n    int sz;\n    int nx, ny, px, py;\n    int dep = 1;\n    while(sz = q.size()){\n    while(sz--){\n        pair<int, int> pr = q.front();px = pr.first;py = pr.second;q.pop();\n        for(int i = 0;i < 4;i++){\n            nx = px + dx[i], ny = py + dy[i];\n            if(!in_grid(nx, ny) || vis[nx][ny] || grid[nx][ny] == 'x')continue;\n            if(grid[nx][ny] == '.'){vis[nx][ny] = 1;q.push(make_pair(nx, ny));}\n            else if(grid[nx][ny] == '*'){nn--;grid[nx][ny] = '.';return dep + bfs(nx, ny);}\n        }\n    }\n    dep++;\n    }\n    return -1;\n}\nint main(){\n//    freopen(\"input.txt\", \"r\", stdin);\n//    freopen(\"output.txt\", \"w\", stdout);\n    while(cin >> c >> r && (c || r)){\n        grid.clear();\n        nn = 0;\n    for(int i = 0;i < r;i++){\n        cin >> str;\n        grid.push_back(str);\n        for(int j = 0;j < c;j++){\n\n            if(grid[i][j] == 'o'){\n                sx = i;\n                sy = j;\n                grid[i][j] = '.';\n            }else if(grid[i][j] == '*')\n                nn++;\n        }\n    }\n\n        cout << bfs(sx, sy) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#ifndef M_PI\n#define M_PI 3.1415926535897932384626433832795\n#endif\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\n\nbool vis[20][20][1<<10];\n\ntypedef struct{\n  int x,y;\n  int vis;\n  int cost;\n}state;\n\nmain(){\n  int w,h;\n  while(cin>>w>>h,w|h){\n    int sx,sy;\n    string in[h];\n    int num=0;\n    map<PI,int> durty;\n    \n    rep(i,h){\n      cin>>in[i];\n      rep(j,w){\n\tif(in[i][j]=='o'){\n\t  sx=i;\n\t  sy=j;\n\t  in[i][j]='.';\n\t}else if(in[i][j]=='*'){\n\t  durty[mp(i,j)]=num++;\n\t}\n      }\n    }\n\n    memset(vis,0,sizeof(vis));\n\n    queue<state> Q;\n    state st={sx,sy,0,0};\n    Q.push(st);\n    int ans=-1;\n\n    while(!Q.empty()){\n      int cx=Q.front().x,cy=Q.front().y,cvis=Q.front().vis,cc=Q.front().cost;\n      Q.pop();\n\n      if(vis[cx][cy][cvis])continue;\n      vis[cx][cy][cvis]=true;\n\n      if(cvis==(1<<num)-1){\n\tans=cc;\n\tbreak;\n      }\n\n      rep(i,4){\n\tint nx=cx+dx[i],ny=cy+dy[i];\n\tif(nx<0 || h<=nx || ny<0 || w<=ny || in[nx][ny]=='x')continue;\n\tint nvis=cvis;\n\tif(in[nx][ny]=='*')nvis|=1<<durty[mp(nx,ny)];\n\tst.x=nx;\n\tst.y=ny;\n\tst.vis=nvis;\n\tst.cost=cc+1;\n\tQ.push(st);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v){std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\nconstexpr int INF = 100000000;\n\nint dy[] = {0, 1, 0, -1};\nint dx[] = {1, 0, -1, 0};\n\nvoid bfs(vector<vector<int>> &I, pair<int, int> s, vector<string> &C, int H, int W) {\n    queue<pair<int, int>> Q;\n    Q.push(s);\n    I[s.first][s.second] = 0;\n    while (!Q.empty()) {\n        auto p = Q.front();\n        Q.pop();\n        int y = p.first;\n        int x = p.second;\n        for (int i = 0; i < 4; i++) {\n            int toY = y + dy[i];\n            int toX = x + dx[i];\n            int cost = I[y][x] + 1;\n            if (toY < 0 || toY >= H || toX < 0 || toX >= W) continue;\n            if (I[toY][toX] != INF) continue;\n            if(C[toY][toX] == 'x') continue;\n            I[toY][toX] = cost;\n            Q.push(make_pair(toY, toX));\n        }\n    }\n}\n\nint main() {\n\n    while (true) {\n\n        int W, H;\n        cin >> W >> H;\n\n        if (!(W | H)) break;\n\n        vector<string> C(H);\n        for (int i = 0; i < H; i++) cin >> C[i];\n\n        pair<int, int> s;\n        for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) if (C[i][j] == 'o') s = make_pair(i, j);\n\n        vector<pair<int, int>> dirty;\n        for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) if (C[i][j] == '*') dirty.push_back(make_pair(i, j));\n\n        vector<vector<int>> s_I(H, vector<int>(W, INF));\n        vector<vector<vector<int>>> D_I(dirty.size(), vector<vector<int>>(H, vector<int>(W, INF)));\n\n        bfs(s_I, s, C, H, W);\n        for (int i = 0; i < D_I.size(); i++) bfs(D_I[i], dirty[i], C, H, W);\n\n        vector<int> order(dirty.size());\n        for (int i = 0; i < order.size(); i++) order[i] = i;\n\n        int ans = INF;\n        do {\n            int sum = s_I[dirty[order[0]].first][dirty[order[0]].second];\n            for(int i = 0;i<order.size() - 1;i++) sum += D_I[order[i]][dirty[order[i+1]].first][dirty[order[i+1]].second];\n            ans = min(ans, sum);\n        } while (next_permutation(order.begin(), order.end()));\n\n\n        if(ans >= INF) cout << -1 << endl;\n        else cout << ans << endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<map>\n#define INF 1000000\nusing namespace std;\ntypedef pair<int,int> P;\nint x[11];\nint y[11];\nbool used[11];\nint dt[20][20];\nbool t[20][20];\nint w,h;\nint dx[4]={1,0,0,-1};\nint dy[4]={0,1,-1,0};\nvoid bfs(int n){\n\tint i,j;\n\tqueue<P> que;\n\tfor(i=0;i<h;i++)for(j=0;j<w;j++)dt[i][j]=INF;\n\tque.push(P(x[n],y[n]));\n\tdt[x[n]][y[n]]=0;\n\twhile(!que.empty()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tfor(i=0;i<4;i++){\n\t\t\tif(p.first+dx[i]>=0&&p.first+dx[i]<h&&p.second+dy[i]>=0&&p.second+dy[i]<w&&dt[p.first+dx[i]][p.second+dy[i]]==INF&&t[p.first+dx[i]][p.second+dy[i]]){\n\t\t\t\tdt[p.first+dx[i]][p.second+dy[i]]=dt[p.first][p.second]+1;\n\t\t\t\tque.push(P(p.first+dx[i],p.second+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n}\nint min(int a,int b){return a<b?a:b;}\nint main(){\n\tint i,j;\n\twhile(1){\n\tint cn=1;\n\tscanf(\"%d %d\",&w,&h);\n\tif(w==0)return 0;\n\tchar c;\n\tfor(i=0;i<h;i++)for(j=0;j<w;j++)t[i][j]=true;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tscanf(\" %c\",&c);\n\t\t\tif(c=='x')t[i][j]=false;\n\t\t\tif(c=='*'){\n\t\t\t\tx[cn]=i;\n\t\t\t\ty[cn]=j;\n\t\t\t\tcn++;\n\t\t\t}\n\t\t\tif(c=='o'){\n\t\t\t\tx[0]=i;\n\t\t\t\ty[0]=j;\n\t\t\t}\n\t\t}\n\t}\n\tint p=0;\n\tint ans=0;\n\tfor(i=0;i<cn;i++)used[i]=false;\n\tfor(i=0;i<cn-1;i++){\n\t\tbfs(p);\n\t\tused[p]=true;\n\t\tp=-1;\n\t\tfor(j=0;j<cn;j++){\n\t\t\tif(i==j)continue;\n\t\t\tif(!used[j]&&(p==-1||dt[x[p]][y[p]]>dt[x[j]][y[j]]))p=j;\n\t\t}\n\t\tif(dt[x[p]][y[p]]==INF)break;\n\t\tans+=dt[x[p]][y[p]];\n\t}\n\tif(i!=cn-1)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ans);\n\t}\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#define INF 1e+9\nusing namespace std;\n\nint dx[] = {0,1,0,-1},dy[] = {1,0,-1,0};\n\ntypedef pair<int,int> P;\n\nint main(){\n\tint h,w;\n\twhile(cin >> w >> h,h){\n\t\tint dirtx[10],dirty[10],sx,sy,cnt = 0,mi = INF;\n\t\tvector<int> perm;\n\t\tstring field[20];\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tcin >> field[i];\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(field[i][j] == 'o'){\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t}\n\t\t\t\telse if(field[i][j] == '*'){\n\t\t\t\t\tdirtx[cnt] = i;\n\t\t\t\t\tdirty[cnt] = j;\n\t\t\t\t\tperm.push_back(cnt++);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdo{\n\t\t\tint tx = sx,ty = sy,ans = 0,d[20][20];\n\t\t\tfor(int nxt : perm){\n\t\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\t\tfor(int j = 0;j < w;j++) d[i][j] = INF;\n\t\t\t\t}\n\t\t\t\tqueue<P> que;\n\t\t\t\tque.push(P(tx,ty));\n\t\t\t\td[tx][ty] = 0;\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP p = que.front();que.pop();\n\t\t\t\t\tint x = p.first,y = p.second;\n\t\t\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\t\t\tint nx = x + dx[i],ny = y + dy[i];\n\t\t\t\t\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && field[nx][ny] != 'x' && d[nx][ny] == INF){\n\t\t\t\t\t\t\td[nx][ny] = d[x][y] + 1;\n\t\t\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += d[dirtx[nxt]][dirty[nxt]];\n\t\t\t\ttx = dirtx[nxt];\n\t\t\t\tty = dirty[nxt];\n\t\t\t}\n\t\t\tmi = min(mi,ans);\n\t\t}while(next_permutation(perm.begin(),perm.end()));\n\t\tif(mi != INF) cout << mi << endl;\n\t\telse cout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint c[11][11],e[11][2048],n;\nvoid fn(int p,int q,int r,int s){\n  int i;\n  if(e[p][r]>s){\n    e[p][r]=s;\n    if(q!=n){\n      for(i=0;i<n;i++){\n\tif(c[p][i]!=1000000)\n\t  fn(i,q+1,r|(1<<i),s+c[p][i]);\n      }\n    }\n  }\n  return;\n}\nint main(){\n  int i,j;\n  int a[22][22],d[22][22],x[11],y[11],p,q,r,w,h;\n  int mn;\n  char s;\n  queue<pair<pair<int,int>,int> > b;\n  while(cin>>w>>h&&w+h){\n    memset(a,-1,sizeof(a));\n    n=1;\n    for(i=1;i<h+1;i++){\n      for(j=1;j<w+1;j++){\n\tcin>>s;\n\tif(0){\n\t}else if(s=='*'){\n\t  a[j][i]=n;\n\t  x[n]=j;\n\t  y[n]=i;\n\t  n++;\n\t}else if(s!='x'){\n\t  a[j][i]=0;\n\t  if(s=='o'){\n\t    x[0]=j;\n\t    y[0]=i;\n\t  }\n\t}\n      }\n    }\n    for(i=0;i<n;i++)\n      for(j=0;j<n;j++)\n\tc[j][i]=1000000;\n    for(i=0;i<n-1;i++){\n      while(b.empty()==0)\n\tb.pop();\n      b.push(make_pair(make_pair(x[i],y[i]),0));\n      memset(d,-1,sizeof(d));\n      for(j=0;j<n-i-1&&b.empty()==0;){\n\tp=b.front().first.first;\n\tq=b.front().first.second;\n\tr=b.front().second;\n\tb.pop();\n\tif(a[p][q]!=-1&&d[p][q]==-1){\n\t  d[p][q]=1;\n\t  if(i<a[p][q]){\n\t    c[i][a[p][q]]=c[a[p][q]][i]=min(c[i][a[p][q]],r);\n\t    j++;\n\t  }\n\t  b.push(make_pair(make_pair(p-1,q),r+1));\n\t  b.push(make_pair(make_pair(p,q-1),r+1));\n\t  b.push(make_pair(make_pair(p+1,q),r+1));\n\t  b.push(make_pair(make_pair(p,q+1),r+1));\n\t}\n      }\n    }    \n    for(i=0;i<n;i++)\n      for(j=0;j<2048;j++)\n\te[i][j]=1000000;\n    fn(0,0,1,0);\n    mn=0;\n    for(i=1;i<n;i++){\n      if(e[mn][~((~0)<<n)]>e[i][~((~0)<<n)])\n\tmn=i;\n    }\n    if(e[mn][~((~0)<<n)]==1000000)\n      cout<<-1<<endl;\n    else\n      cout<<e[mn][~((~0)<<n)]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\n#include<cstring>\n#include<algorithm>\n#include <utility>\n#include<stdio.h>\n#include<climits>\n#include <vector>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\nint p[400][400];\nint d[11][11];\nint w,h,wh;\nint r;\nvector<int> v;\n\nint pd(int s,int n){\n    if(s == 0) return 0;\n    int i,j;\n    int min = 10000000;\n    for(i = 0;i < v.size();i++){\n        if(s & (1<<i)){\n            j = pd(s-(1<<i),i);\n            if(min > d[n][i]+j) min = d[n][i] + j;\n        }\n    }\n    return min;\n}\n\nint main(){\n    int i,j,k;\n    int min = 10000000;\n    char c;\n    while(1){\n        cin >> w >> h;\n        if(!w) break;\n        w ^= h;h ^= w;w ^= h;\n        v.clear();\n        wh = w*h;\n        for(i = 0;i < wh;i++){\n            for(j = 0;j < wh;j++){\n                p[i][j] = 10000;\n            }\n            p[i][i] = 0;\n        }\n        for(i = 0;i < w;i++){\n            for(j = 0;j < h;j++){\n                if(i > 0){\n                    p[i*h+j][(i-1)*h+j] = 1;\n                    p[(i-1)*h+j][i*h+j] = 1;\n                }\n                if(j > 0){\n                    p[i*h+j][i*h+j-1] = 1;\n                    p[i*h+j-1][i*h+j] = 1;\n                }\n                if(i < w-1){\n                    p[i*h+j][(i+1)*h+j] = 1;\n                    p[(i+1)*h+j][i*h+j] = 1;\n                }\n                if(j < h-1){\n                    p[i*h+j][i*h+j+1] = 1;\n                    p[i*h+j+1][i*h+j] = 1;\n                }\n            }\n        }\n        for(i = 0;i < w;i++){\n            for(j = 0;j < h;j++){\n                cin >> c;\n                switch(c){\n                    case 'x':\n                        if (i > 0) {\n                            p[i * h + j][(i - 1) * h + j] = 10000;\n                            p[(i - 1) * h + j][i * h + j] = 10000;\n                        }\n                        if (j > 0) {\n                            p[i * h + j][i * h + j - 1] = 10000;\n                            p[i * h + j - 1][i * h + j] = 10000;\n                        }\n                        if (i < w - 1) {\n                            p[i * h + j][(i + 1) * h + j] = 10000;\n                            p[(i + 1) * h + j][i * h + j] = 10000;\n                        }\n                        if (j < h - 1) {\n                            p[i * h + j][i * h + j + 1] = 10000;\n                            p[i * h + j + 1][i * h + j] = 10000;\n                        }\n                        break;\n                    case 'o':\n                        r = i*h+j;\n                        break;\n                    case '*':\n                        v.push_back(i*h+j);\n                        break;\n                }\n            }\n        }\n        for(k = 0;k < wh;k++){\n            for(i = 0;i < wh;i++){\n                for(j = 0;j < wh;j++){\n                    p[i][j] = (p[i][j]>p[i][k]+p[k][j])?p[i][k]+p[k][j]:p[i][j];\n                }\n            }\n        }\n        k = 0;\n        for(i = 0;i < v.size();i++){\n            for(j = 0;j < v.size();j++){\n                if(p[v[i]][v[j]] >= 10000){\n                    k = 1;\n                }\n                d[i][j] = p[v[i]][v[j]];\n            }\n        }\n        min = 10000000;\n        for(i = 0;i < v.size();i++){\n            if(p[r][v[i]] >= 10000){\n                k = 1;\n            }\n            else{\n                j = pd((1<<v.size())-1-(1<<i),i);\n                j += p[r][v[i]];\n                if(min > j) min = j;\n            }\n        }\n        if(k){\n            cout << -1 << endl;\n        }\n        else{\n            cout << min << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<limits.h>\n#define INF 100000\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h;\nint imap[21][21];\nint djd[20][2]; // 0->x ,1->y\nint mmaapp[20][20];\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\nint bfs(int sp,int gp){\n  int mmap[21][21];\n \n  for(int i=0;i<21;i++)for(int j=0;j<21;j++)mmap[i][j] = INF;\n  queue<P> que;\n  que.push(P(djd[sp][0],djd[sp][1]));\n  mmap[djd[sp][1]][djd[sp][0]]=0;\n\n  while(que.size()){\n    P p = que.front();que.pop();\n\n    if(p.first == djd[gp][0] && p.second == djd[gp][1])return mmap[djd[gp][1]][djd[gp][0]];\n\n    for(int i=0;i<4;i++){\n      int nx = p.first+dx[i],ny = p.second+dy[i];\n      if(0<=nx && nx < w && 0<=ny && ny < h && mmap[ny][nx] == INF && imap[ny][nx] != -1){\n\tque.push(P(nx,ny));\n\tmmap[ny][nx] = mmap[p.second][p.first] + 1;\n      }\n    }\n  }\n  return -3;\n}\n\n\n\nint main(){\n  char in;\n  int count;\n  while(true){\n    cin >> w >> h;\n    if(w+h == 0)break;\n    count=1;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> in;\n\tswitch(in){\n\tcase '.':\n\t  imap[i][j]=0;\n\t  break;\n\tcase 'o':\n\t  imap[i][j]=0;\n\t  djd[0][0]=j;\n\t  djd[0][1]=i;\n\t  break;\n\tcase 'x':\n\t  imap[i][j]=-1;\n\t  break;\n\tcase '*':\n\t  imap[i][j]=0;\n\t  djd[count][0]=j;\n\t  djd[count][1]=i;\n\t  count++;\n\t  break;\n\tdefault:\n\t  cout << \"erro\" << endl; \n\t  break;\n\t}\n      }\n    }\n\n    for(int i=0;i<count;i++){\n      for(int j=0;j<count;j++){\n\tmmaapp[i][j] = bfs(i,j);\n\t//\tcout << mmaapp[i][j] << \" \";\n      }\n      //      cout << endl;\n    }\n\n\n\n    int dp[(1<<11)][11];\n    \n    rep(i,(1<<count))rep(j,count)dp[i][j]=INF;\n    //rep(i,count)dp[(1<<i)][i]=0;\n    dp[(1<<count)-1][0] = 0;\n\n    for(int S=(1<<count)-2;S>=0;S--){\n      for(int v=0;v<count;v++){\n\tfor(int u=0;u<count;u++){\n\t  if(!(S>>u & 1)){\n\t    dp[S][v]=min(dp[S][v],dp[S| 1<<u][u] + mmaapp[v][u]);\n\t  }\n\t}\n      }\n    }\n    int ans=INF;\n    for(int i=0;i<count;i++){\n      ans = min(ans,dp[(1<<i)][i]);\n    }\n    \n    if(ans <= -3)cout << \"-1\" << endl;\n    else cout << ans << endl;\n   \n\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing pii = pair<int, int>;\n\nconstexpr int INF = (1 << 12);\nconstexpr int dir[5] = {0, 1, 0, -1, 0};\n\nbool ispower(int n)\n{\n    return n == (pow(2, static_cast<int>(log2(n))));\n}\n\nvoid bfs_dist(const vector<vector<int>>& room, const pii& pos, vector<int>& dist, const vector<pii>& dirty)\n{\n    const int h = room.size();\n    const int w = room[0].size();\n    int rest = dirty.size();\n    vector<vector<bool>> checked(h, vector<bool>(w, false));\n    vector<bool> visited(dirty.size(), false);\n    queue<pair<pii, int>> q;\n    q.push(make_pair(pos, 0));\n    checked[pos.first][pos.second] = true;\n    while (not q.empty()) {\n        const pii p = q.front().first;\n        const int distance = q.front().second;\n        const int pi = p.first;\n        const int pj = p.second;\n        for (int i = 0; i < dirty.size(); i++) {\n            if (p == dirty[i] and (not visited[i])) {\n                dist[i] = distance;\n                visited[i] = true;\n                rest--;\n                if (rest == 0) {\n                    return;\n                }\n            }\n        }\n        q.pop();\n        for (int d = 0; d < 4; d++) {\n            const int newi = pi + dir[d];\n            const int newj = pj + dir[d + 1];\n            if (0 <= newi and newi < h and 0 <= newj and newj < w) {\n                if (room[newi][newj] != -1 and (not checked[newi][newj])) {\n                    checked[newi][newj] = true;\n                    q.push(make_pair(make_pair(newi, newj), distance + 1));\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        int h, w;\n        cin >> w >> h;\n        if (w == 0 and h == 0) {\n            break;\n        }\n        vector<vector<int>> room(h, vector<int>(w));\n\n        pii start;\n        vector<pii> dirty;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                char c;\n                cin >> c;\n                if (c == '.') {\n                    room[i][j] = 0;\n                } else if (c == '*') {\n                    room[i][j] = 1;\n                    dirty.push_back(make_pair(i, j));\n                } else if (c == 'x') {\n                    room[i][j] = -1;\n                } else {\n                    room[i][j] = 0;\n                    start.first = i;\n                    start.second = j;\n                }\n            }\n        }\n\n        const int dirtynum = dirty.size();\n        vector<vector<int>> dist(dirtynum, vector<int>(dirtynum, INF));\n        vector<int> initdist(dirtynum, INF);\n        bfs_dist(room, start, initdist, dirty);\n        for (int i = 0; i < dirtynum; i++) {\n            bfs_dist(room, dirty[i], dist[i], dirty);\n        }\n\n        for (int i = 0; i < dirtynum; i++) {\n            if (initdist[i] == INF) {\n                cout << -1 << endl;\n                continue;\n            }\n        }\n\n        const int maximum = 1 << dirtynum;\n        vector<vector<int>> dp(maximum, vector<int>(dirtynum, INF));  // dp[visited[last]\n        for (int n = 1; n < maximum; n++) {\n            for (int i = 0; i < dirtynum; i++) {\n                if ((n >> i) % 2) {\n                    for (int j = 0; j < dirtynum; j++) {  //i->j\n                        if ((n >> j) % 2) {\n                            if (i == j) {\n                                if (ispower(n)) {\n                                    dp[n][i] = initdist[i];\n                                }\n                                continue;\n                            }\n                            dp[n][j] = min(dp[n][j], dp[n - (1 << j)][i] + dist[i][j]);\n                        }\n                    }\n                }\n            }\n        }\n        int mini = INF;\n        for (int i = 0; i < dirtynum; i++) {\n            mini = min(mini, dp[maximum - 1][i]);\n        }\n        cout << mini << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <utility>\n#include <map>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nint main(){\n    while(1){\n        int w, h;\n        cin >> w >> h;\n        if(w == 0){\n            return 0;\n        }\n\n        vector<string> c(h);\n        vector<P> s;\n        map<int, P> mp;\n        int sy, sx;\n        int cnt = 1;\n        for (int i = 0; i < h; i++){\n            cin >> c[i];\n            for (int j = 0; j < w; j++){\n                if(c[i][j] == 'o'){\n                    sy = i;\n                    sx = j;\n                    c[i][j] = '.';\n                }\n                if(c[i][j] == '*'){\n                    mp[cnt++] = P(i, j);\n                    s.emplace_back(i, j);\n                }\n            }\n        }\n\n        int dist[20][30][30];\n        for (int i = 0; i < 20; i++){\n            for (int j = 0; j < 30; j++){\n                for (int k = 0; k < 30; k++){\n                    dist[i][j][k] = 1e9;\n                }\n            }\n        }\n\n        int n = s.size();\n        for (int i = 0; i <= n; i++){\n            queue<T> que;\n            if(i == 0){\n                que.emplace(0, sy, sx);\n                dist[0][sy][sx] = 0;\n            }\n            else{\n                que.emplace(0, s[i - 1].first, s[i - 1].second);\n                dist[i][s[i - 1].first][s[i - 1].second] = 0;\n            }\n\n            while(que.size()){\n                int cost, cy, cx;\n                tie(cost, cy, cx) = que.front();\n                que.pop();\n\n                for (int j = 0; j < 4; j++){\n                    int ny = cy + dy[j];\n                    int nx = cx + dx[j];\n\n                    if(0 <= ny && ny < h && 0 <= nx && nx < w){\n                        if(c[ny][nx] == 'x'){\n                            continue;\n                        }\n\n                        if(dist[i][cy][cx] + 1 < dist[i][ny][nx]){\n                            dist[i][ny][nx] = dist[i][cy][cx] + 1;\n                            que.emplace(dist[i][ny][nx], ny, nx);\n                        }\n                    }\n                }\n            }\n        }\n\n        vector<int> v;\n        for (int i = 1; i <= n; i++){\n            v.emplace_back(i);\n        }\n\n        int ans = 1e9;\n        do{\n            int sum = 0;\n            P nv = mp[v[0]];\n\n            if(dist[0][nv.first][nv.second] == 1e9){\n                cout << -1 << endl;\n                goto END;\n            }\n\n            sum += dist[0][nv.first][nv.second];\n\n            for (int i = 1; i < n; i++){\n                nv = mp[v[i]];\n\n                if(dist[v[i-1]][nv.first][nv.second] == 1e9){\n                    cout << -1 << endl;\n                    goto END;\n                }\n\n                sum += dist[v[i - 1]][nv.first][nv.second];\n            }\n\n            ans = min(ans, sum);\n\n        } while (next_permutation(v.begin(), v.end()));\n\n        cout << ans << endl;\n\n        END:;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int, pair<int, int> > pii;\n#define piii(x, y, d) make_pair(x, make_pair(y, d))\n\nint w, h;\nchar c[20][20], cc[20][20];\nint n;\nint gx[11], gy[11];\nint g[11][11];\nint dp[1 << 11][11];\nconst int INF = 10000000;\n\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nint bfs(int sx, int sy, int gx, int gy)\n{\n    queue<pii> q;\n\n    q.push(piii(sx, sy, 0));\n\n    while (!q.empty()) {\n        int x = q.front().first;\n        int y = q.front().second.first;\n        int d = q.front().second.second;\n        q.pop();\n        //printf(\"(%d, %d) = %d\\n\", x, y, d);\n\n        cc[x][y] = 'x';\n        for (int i = 0; i < 4; ++i) {\n            int nx = x + dx[i], ny = y + dy[i];\n            if (nx < 0 || h <= nx || ny < 0 || w <= ny)\n                continue;\n            if (cc[nx][ny] == 'x')\n                continue;\n            if (nx == gx && ny == gy)\n                return d + 1;\n            q.push(piii(nx, ny, d + 1));\n        }\n    }\n    return INF;\n}\n\nint tsp(int visited, int v)\n{\n    if (dp[visited][v] != -1)\n        return dp[visited][v];\n\n    if (visited == (1 << n) - 1)\n        return 0;\n\n    int res = INF;\n    for (int u = 0; u < n; ++u) {\n        if (!(visited & (1 << u))) {\n            res = min(res, tsp(visited | (1 << u), u) + g[v][u]);\n        }\n    }\n    return dp[visited][v] = res;\n}\n\nint main()\n{\n    for (;;) {\n        scanf(\"%d %d\", &w, &h);\n        if (w == 0 && h == 0)\n            break;\n\n        n = 1;\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                scanf(\" %c\", &c[i][j]);\n                if (c[i][j] == 'o') {\n                    gx[0] = i;\n                    gy[0] = j;\n                } else if (c[i][j] == '*') {\n                    gx[n] = i;\n                    gy[n] = j;\n                    ++n;\n                }\n            }\n        }\n        //for (int i = 0; i < n; ++i) printf(\"%d, %d\\n\", gx[i], gy[i]);\n\n        /*\n        fill(&g[0][0], &g[11][0], INF);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j){\n                copy(&c[0][0], &c[20][0], &cc[0][0]);\n                if (i == j)\n                    g[i][j] = 0;\n                else\n                    g[i][j] = bfs(gx[i], gy[i], gx[j], gy[j]);\n                //printf(\"%d\\t\", g[i][j]);\n            }\n            //printf(\"\\n\");\n        }\n\n        fill(&dp[0][0], &dp[1 << 11][0], -1);\n        int res = tsp(1, 0);\n        if (res == INF)\n            printf(\"-1\\n\");\n        else\n            printf(\"%d\\n\", res);\n        */\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> p;\ntypedef pair<int,p> P;\n\nint w,h,used[1<<10][20][20],bt[20][20];;\nchar c[20][20];\nint dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\nint sx,sy,n;\nint bfs(){\n  memset(used,0,sizeof(used));\n  queue<P> q;\n  q.push(P(0,p(sx,sy)));\n  while(!q.empty()){\n    int s=q.front().first,x=q.front().second.first,y=q.front().second.second;\n    q.pop();\n    if(s==n-1)return used[s][y][x];\n    for(int i=0;i<4;i++){\n      int nx=x+dx[i],ny=y+dy[i];\n      if(nx<0||w<=nx||ny<0||h<=ny||c[ny][nx]=='x')continue;\n      int ns=s|bt[ny][nx];\n      if(!used[ns][ny][nx])\n\tq.push(P(ns,p(nx,ny))),used[ns][ny][nx]=used[s][y][x]+1;\n    }\n  }\n  return -1;\n}\n\nint ans(){\n  memset(used,0,sizeof(used));\n  memset(bt,0,sizeof(bt));\n  n=1;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      cin>>c[i][j];\n      if(c[i][j]=='o')sx=j,sy=i;\n      if(c[i][j]=='*')bt[i][j]=n,n*=2;\n    }\n  return bfs();\n}\n\nint main(){\n  while(cin>>w>>h,w)cout<<ans()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint h, w, k[31][31], cnt;\nlong long cx[21], cy[21], y[21][21], z[21][21], bfs[31][31], a, b, c[10], sum, minx, sum2; bool s[31][31];\nchar p;\n\nint main() {\n\twhile (true) {\n\t\tmemset(z, 0, sizeof(z));\n\t\tcin >> w >> h; cnt = 1; if (!w) { break; }\n\t\tfor (int i = 0; i < 22; i++) { \n\t\t\tfor (int j = 0; j < 22; j++) { \n\t\t\t\tk[i][j] = 1; \n\t\t\t} \n\t\t}\n\t\tcnt = 1;\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tcin >> p;\n\t\t\t\tif (p != 'x') { k[i][j] = 0; }\n\t\t\t\tif (p == '*') { cx[cnt] = j; cy[cnt] = i; cnt++; }\n\t\t\t\tif (p == 'o') { cx[0] = j; cy[0] = i; }\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 10; i++) { c[i] = i; }\n\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\t//bfs.\n\t\t\tqueue<int> Q;\n\t\t\tmemset(bfs, 10, sizeof(bfs));memset(s, false, sizeof(s));\n\t\t\tbfs[cy[i]][cx[i]] = 0;\n\n\t\t\tQ.push(cy[i] * 30 + cx[i]);\n\t\t\ts[cy[i]][cx[i]] = true;\n\t\t\twhile (!Q.empty()) {\n\t\t\t\ta = Q.front() / 30;\n\t\t\t\tb = Q.front() % 30;\n\t\t\t\tif (k[a - 1][b] == 0 && s[a - 1][b] == false) { \n\t\t\t\t\ts[a - 1][b] = true; Q.push((a - 1) * 30 + b); bfs[a - 1][b] = bfs[a][b] + 1;\n\t\t\t\t}\n\t\t\t\tif (k[a + 1][b] == 0 && s[a + 1][b] == false) {\n\t\t\t\t\ts[a + 1][b] = true; Q.push((a + 1) * 30 + b); bfs[a + 1][b] = bfs[a][b] + 1;\n\t\t\t\t}\n\t\t\t\tif (k[a][b - 1] == 0 && s[a][b - 1] == false) {\n\t\t\t\t\ts[a][b - 1] = true; Q.push(a * 30 + b - 1); bfs[a][b - 1] = bfs[a][b] + 1;\n\t\t\t\t}\n\t\t\t\tif (k[a][b + 1] == 0 && s[a][b + 1] == false) {\n\t\t\t\t\ts[a][b + 1] = true; Q.push(a * 30 + b + 1); bfs[a][b + 1] = bfs[a][b] + 1;\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t\t\n\t\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\t\tz[i][j] = bfs[cy[j]][cx[j]];\n\t\t\t}\n\t\t}\n\t\tminx = 114514;\n\t\tdo\n\t\t{\n\t\t\tsum = z[0][c[0] + 1];\n\t\t\tfor (int i = 0; i < cnt - 2; i++) { \n\t\t\t\tsum += z[c[i] + 1][c[i + 1] + 1]; \n\t\t\t}\n\t\t\tminx = min(minx, sum);\n\t\t} while (next_permutation(c, c + cnt - 1));\n\t\tif (minx == 114514) { minx = -1; }\n\t\tcout << minx << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint w, h;\nstring b[20];\nint step[20][20];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid bfs(int x, int y){\n\tmemset(step, -1, sizeof(step));\n\tqueue< pair<int, int> > qu; qu.push(make_pair(x,y));\n\tstep[x][y] = 0;\n\twhile(!qu.empty()){\n\t\tpair<int, int> pr = qu.front(); qu.pop();\n\t\tint cx = pr.first, cy = pr.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx = cx+dx[i], ny = cy+dy[i];\n\t\t\tif(nx<0||h<=nx||ny<0||w<=ny||b[nx][ny]=='x'||step[nx][ny]!=-1) continue;\n\t\t\tstep[nx][ny] = step[cx][cy]+1;\n\t\t\tqu.push(make_pair(nx,ny));\n\t\t}\n\t}\n}\n\nint main(){\n\tint c[11][11];\n\twhile(cin >> w >> h, w){\n\t\tfor(int i=0;i<h;i++) cin >> b[i];\n\t\tvector<int> x(1), y(1);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(b[i][j]=='o') x[0] = i, y[0] = j;\n\t\t\t\tif(b[i][j]=='*') x.push_back(i), y.push_back(j);\n\t\t\t}\n\t\t}\n\t\tint res = 1000000000;\n\t\tfor(int i=0;i<x.size();i++){\n\t\t\tbfs(x[i], y[i]);\n\t\t\tfor(int j=0;j<x.size();j++){\n\t\t\t\tc[i][j] = step[x[j]][y[j]];\n\t\t\t\tif(c[i][j]==-1) res = -1;\n\t\t\t}\n\t\t}\n\t\tvector<int> a(x.size()-1);\n\t\tfor(int i=0;i<x.size()-1;i++) a[i] = i+1;\n\t\tdo{\n\t\t\tint cur = c[0][a[0]];\n\t\t\tfor(int i=0;i+1<a.size();i++) cur += c[a[i]][a[i+1]];\n\t\t\tres = min(res, cur);\n\t\t}while(next_permutation(a.begin(), a.end()));\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<limits.h>\n#define INF 100000\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h;\nint imap[21][21];\nint djd[20][2]; // 0->x ,1->y\nint mmaapp[20][20];\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\nint bfs(int sp,int gp){\n  int mmap[21][21];\n \n  for(int i=0;i<21;i++)for(int j=0;j<21;j++)mmap[i][j] = INF;\n  queue<P> que;\n  que.push(P(djd[sp][0],djd[sp][1]));\n  mmap[djd[sp][1]][djd[sp][0]]=0;\n\n  while(que.size()){\n    P p = que.front();que.pop();\n\n    if(p.first == djd[gp][0] && p.second == djd[gp][1])return mmap[djd[gp][1]][djd[gp][0]];\n\n    for(int i=0;i<4;i++){\n      int nx = p.first+dx[i],ny = p.second+dy[i];\n      if(0<=nx && nx < w && 0<=ny && ny < h && mmap[ny][nx] == INF && imap[ny][nx] != -1){\n\tque.push(P(nx,ny));\n\tmmap[ny][nx] = mmap[p.second][p.first] + 1;\n      }\n    }\n  }\n  return -3;\n}\n\n\n\nint main(){\n  char in;\n  int count;\n  while(true){\n    cin >> w >> h;\n    if(w+h == 0)break;\n    count=1;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> in;\n\tswitch(in){\n\tcase '.':\n\t  imap[i][j]=0;\n\t  break;\n\tcase 'o':\n\t  imap[i][j]=0;\n\t  djd[0][0]=j;\n\t  djd[0][1]=i;\n\t  break;\n\tcase 'x':\n\t  imap[i][j]=-1;\n\t  break;\n\tcase '*':\n\t  imap[i][j]=0;\n\t  djd[count][0]=j;\n\t  djd[count][1]=i;\n\t  count++;\n\t  break;\n\tdefault:\n\t  cout << \"erro\" << endl; \n\t  break;\n\t}\n      }\n    }\n\n    for(int i=0;i<count;i++){\n      for(int j=0;j<count;j++){\n\tmmaapp[i][j] = bfs(i,j);\n\t//cout << mmaapp[i][j] << \" \";\n      }\n      // cout << endl;\n    }\n\n\n\n    int dp[(1<<count)+2][count+2];\n    rep(i,(1<<count)+2)rep(j,count+2)dp[i][j]=INF;\n    dp[(1<<count)-1][0]=0;\n\n    for(int S=(1<<count)-2;S>=0;S--){\n      for(int v=0;v<count;v++){\n\tfor(int u=0;u<count;u++){\n\t  if(!(S>>u & 1)){\n\t    dp[S][v]=min(dp[S][v],dp[S| 1<<u][u] + mmaapp[v][u]);\n\t  }\n\t}\n      }\n    }\n    int ans=INF;\n    for(int i=0;i<count;i++){\n      ans = min(ans,dp[(1<<i)][i]);\n    }\n\n    if(ans == -3)cout << \"-1\" << endl;\n    else cout << ans << endl;\n\n\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define MAX 11\n#define mk make_pair\n#define INF 1<<28\nstring s[20];\nbool vis[20][20];\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint n,w,h,d[MAX][MAX],c;\nint dp[1<<MAX][MAX];\nint rec(int s,int v){\n  if(dp[s][v]>=0)return dp[s][v];\n  if(s==(1<<n)-1&&v!=0)return dp[s][v]=0;\n  int res=INF;\n  for(int u=0;u<n;u++) \n    if(!(s>>u&1))\n      res=min(res,rec(s|1<<u,u)+d[v][u]);\n  return dp[s][v]=res;\n}\nvoid bfs(int x2,int y2,int k){\n  r(i,20)r(j,20)vis[i][j]=0;\n  queue<pair<pair<int,int>,int> > q;\n  vis[x2][y2]=1;\n  q.push(mk(mk(x2,y2),0));\n  while(!q.empty()){\n    pair<pair<int,int>,int>p=q.front();q.pop();\n    int p1=p.first.first,p2=p.first.second,p3=p.second;\n    r(i,4){\n      int x=dx[i]+p1;\n      int y=dy[i]+p2;\n      if(x>=0&&x<w&&y>=0&&y<h)\n        if(!vis[x][y]&&(s[y][x]!='x')){\n          if(0<=s[y][x]&&s[y][x]<12)\n            d[k][(int)s[y][x]]=p3+1;\n          else if(k!=0&&s[y][x]=='o')\n            d[k][0]=p3+1;\n          q.push(mk(mk(x,y),p3+1));\n          vis[x][y]=1;\n        }\n    }\n  }\n}\nint main(){\n  while(cin>>w>>h,w){c=1;\n    int a,b;\n    vector<pair<int,int> >v;\n    r(i,h)cin>>s[i];\n    r(j,w)r(i,h)if(s[i][j]=='*')s[i][j]=c++,v.push_back(make_pair(j,i));\n  memset(dp,-1,sizeof(dp));\n  n=c;\n  r(i,MAX)r(j,MAX)d[i][j]=INF;\n  r(j,w)r(i,h)if(s[i][j]=='o')a=j,b=i;\n  bfs(a,b,0);\n  r(i,c-1)bfs(v[i].first,v[i].second,i+1);\n  int p=rec(1,0);\n  if(p==INF)p=-1;\n  cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <bits/stdc++.h>\nusing namespace std;\nint r, c, sx, sy;\nbool vis[21][21];\nvector<string> grid;\nstring str;\nint dx[] = {0, 0, 1, -1};\nint dy[] = {-1, 1, 0, 0};\nint nn = 0;\nbool in_grid(int x, int y){\n    return x >= 0 && y >= 0 && x < r && y < c;\n}\nint bfs(int x, int y){\n    if(nn == 0)return 0;\n    memset(vis, 0, sizeof(vis));\n    queue<pair<int, int> > q;\n    q.push(make_pair(x, y));\n    vis[x][y] = 1;\n    int sz;\n    int nx, ny, px, py;\n    int dep = 1;\n    while(sz = q.size()){\n    while(sz--){\n        pair<int, int> pr = q.front();px = pr.first;py = pr.second;q.pop();\n        for(int i = 0;i < 4;i++){\n            nx = px + dx[i], ny = py + dy[i];\n            if(!in_grid(nx, ny) || vis[nx][ny] || grid[nx][ny] == 'x')continue;\n            if(grid[nx][ny] == '.'){vis[nx][ny] = 1;q.push(make_pair(nx, ny));}\n            else if(grid[nx][ny] == '*'){nn--;grid[nx][ny] = '.';return dep + bfs(nx, ny);}\n        }\n    }\n    dep++;\n    }\n    return -1;\n}\nint main(){\n//    freopen(\"input.txt\", \"r\", stdin);\n//    freopen(\"output.txt\", \"w\", stdout);\n    while(cin >> c >> r && (c || r)){\n        grid.clear();\n        nn = 0;\n    for(int i = 0;i < r;i++){\n        cin >> str;\n        grid.push_back(str);\n        for(int j = 0;j < c;j++){\n\n            if(grid[i][j] == 'o'){\n                sx = i;\n                sy = j;\n                grid[i][j] = '.';\n            }else if(grid[i][j] == '*')\n                nn++;\n        }\n    }\n\n        cout << bfs(sx, sy) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nint main(){\n\twhile(1){\n\t\tint w,h;\n\t\tint xd[11], yd[11];\n\t\tint dc=1;\n\t\tcin>>w>>h;\n\t\tif(w == 0)break;\n\t\tVS board(h+2);\n\t\tREP(i, h){\n\t\t\tcin>>board[i+1];\n\t\t\tboard[i+1] = \"x\" + board[i+1]+\"x\";\n\t\t}\n\t\tboard[0] = board[1];\n\t\tboard[h+1] = board[1];\n\t\tREP(i,w+2){\n\t\t\tboard[0][i] = 'x';\n\t\t\tboard[h+1][i] = 'x';\n\t\t}\n\t\t\n\t\tREP(i, h+2){\n\t\t\tREP(j, w+2){\n\t\t\t\tif(board[i][j] == 'o'){\n\t\t\t\t\txd[0] = j;\n\t\t\t\t\tyd[0] = i;\n\t\t\t\t\tboard[i][j] = 'a';\n\t\t\t\t}\n\t\t\t\tif(board[i][j] == '*'){\n\t\t\t\t\tboard[i][j] = 'a'+dc;\n\t\t\t\t\txd[dc] = j;\n\t\t\t\t\tyd[dc++] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tVVI dist(dc, VI(dc, -1));\n\t\tREP(i,dc)dist[i][i]=0;\n\t\tfor(int d = 0; d<dc; d++){\n\t\t\tVVI visit(h+2, VI(w+2, 0));\n\t\t\tpriority_queue<TIII, vector<TIII>, greater<TIII> > q;\n\t\t\tq.push(MT(0, xd[d], yd[d]));\n\t\t\twhile(!q.empty()){\n\t\t\t\tTIII tmp = q.top();\n\t\t\t\tq.pop();\n\t\t\t\tint tx = tmp.second.first;\n\t\t\t\tint ty = tmp.second.second;\n\t\t\t\tint td = tmp.first;\n\t\t\t\tif(visit[ty][tx]==1)continue;\n\t\t\t\tif(board[ty][tx]!='.')dist[d][board[ty][tx]-'a']=td;\n\t\t\t\tvisit[ty][tx] = 1;\n\t\t\t\tREP(i, 4){\n\t\t\t\t\tswitch(board[ty+dy[i]][tx+dx[i]]){\n\t\t\t\t\tcase 'x':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tq.push(MT(td+1, tx+dx[i], ty+dy[i]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tVI v(dc-1);\n\t\tint flag = 0;\n\t\tREP(i,dc)REP(j,dc)if(dist[i][j]<0)flag = 1;\n\t\tif(flag){\n\t\t\tcout << \"-1\" <<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tREP(i, dc-1)v[i] = i+1;\n\t\tint ret = 1000000000;\n\t\tdo{\n\t\t\tint s = 0;\n\t\t\tint tret = dist[0][v[0]];\n\t\t\tREP(i, dc-2)tret += dist[v[i]][v[i+1]];\n\t\t\tif(tret < ret)ret = tret;\n\t\t}while(next_permutation(ALL(v)));\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 9999999;\n\nint w, h;\nstring b[20];\nint d[20][20];\n\nchar dx[] = {-1,1,0,0};\nchar dy[] = {0,0,-1,1};\n\nvoid dist(int sx, int sy){\n\tfor(int i=0;i<20;i++)\n\t\tfor(int j=0;j<20;j++)\n\t\t\td[i][j] = INF;\n\tqueue< pair<int,int> > qu;\n\tqu.push(make_pair(sx,sy));\n\td[sy][sx] = 0;\n\twhile(!qu.empty()){\n\t\tpair<int, int> p = qu.front(); qu.pop();\n\t\tint x = p.first, y = p.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif(nx<0||nx>=w||ny<0||ny>=h||b[ny][nx]=='x') continue;\n\t\t\tif(d[ny][nx] != INF) continue;\n\t\t\td[ny][nx] = d[y][x] + 1;\n\t\t\tqu.push(make_pair(nx,ny));\n\t\t}\n\t}\n}\n\nint main(){\n\tint c[11][11];\n\tint x[11], y[11];\n\tint ans[1<<11][11];\n\twhile(cin >> w >> h){\n\t\tif(!(w||h)) break;\n\t\tint num = 1;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin >> b[i];\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(b[i][j]=='o') x[0] = j, y[0] = i;\n\t\t\t\tif(b[i][j]=='*') x[num] = j, y[num++] = i;\n\t\t\t}\n\t\t}\n\t\tbool flag = false;\n\t\tmemset(c,0,sizeof(c));\n\t\tdist(x[0],y[0]);\n\t\tfor(int i=1;i<num;i++){\n\t\t\tc[0][i] = d[y[i]][x[i]];\n\t\t\tif(c[0][i] == INF) flag = true;\n\t\t}\n\t\tif(flag) { cout << -1 << endl; continue; }\n\t\tfor(int i=1;i<num;i++){\n\t\t\tdist(x[i],y[i]);\n\t\t\tfor(int j=0;j<num;j++){\n\t\t\t\tif(i==j) continue;\n\t\t\t\tc[i][j] = d[y[j]][x[j]];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(1<<num);i++) for(int j=0;j<num;j++) ans[i][j] = INF;\n\t\tans[1][0] = 0;\n\t\tfor(int i=0;i<(1<<num);i++){\n\t\t\tfor(int j=0;j<num;j++)\n\t\t\t\tif((i>>j)&1)\n\t\t\t\t\tfor(int k=0;k<num;k++)\n\t\t\t\t\t\tans[i|(1<<k)][k] = min(ans[i|(1<<k)][k],ans[i][j]+c[j][k]);\n\t\t}\n\t\tint cost = INF;\n\t\tfor(int i=1;i<num;i++) cost = min(cost, ans[(1<<num)-1][i]);\n\t\tcout << cost << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define INFI 100000\n\nstruct point{\n\tint h,w;\n};\n\nclass sales{\nprivate:\n\tint n;\n\tint **dist;\n\tint **dp;\n\tint ans;\npublic:\n\tsales(int n){\n\t\tthis->n=n;\n\t\tdist=new int*[n];\n\t\tfor(int i=0;i<n;i++) dist[i]=new int[n];\n\t\tdp=new int*[1<<n];\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tdp[i]=new int[n];\n\t\t\tfor(int j=0;j<n;j++) dp[i][j]=-1;\n\t\t}\n\t}\n\tvoid set(int n,int m,int c){\n\t\tdist[n][m]=c;\n\t\tdist[m][n]=c;\n\t}\n\tvoid set(){\n\t\tfor(int i=0;i<n;i++) dist[i][0]=0;\n\t\tans=rec(0,0);\n\t}\n\tint rec(int s,int v){\n\t\tif(dp[s][v]>=0) return dp[s][v];\n\n\t\tif(s==(1<<n)-1 && v==0) return dp[s][v]=0;\n\t\tint res=INFI;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(!(s>>i & 1)){\n\t\t\t\tres=i_min(res,rec(s|(1<<i),i)+dist[v][i]);\n\t\t\t}\n\t\t}\n\t\treturn dp[s][v]=res;\n\t}\n\tvoid show(){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++) cout<<dist[i][j]<<\" \";\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\tint i_min(int p,int q){\n\t\tif(p<q) return p;\n\t\treturn q;\n\t}\n\tint ret(){\n\t\treturn ans;\n\t}\n};\n\n\nint w,h;\nchar p[20][21];\nint dist[20][20];\nint dust;\npoint d[10];\nsales *s;\n\nvoid dec(int ph,int pw,int c){\n\tif(p[ph][pw]=='x') return;\n\tif(ph<0 || ph>=h ||pw<0 || pw>=w) return;\n\tif(dist[ph][pw]<=c) return;\n\tdist[ph][pw]=c;\n\t\n\tdec(ph-1,pw,c+1);\n\tdec(ph+1,pw,c+1);\n\tdec(ph,pw-1,c+1);\n\tdec(ph,pw+1,c+1);\n\treturn;\n}\n\nint main(){\n\tint i,j,k;\n\twhile(cin>>w>>h){\n\t\tif(w==0 && h==0) break;\n\t\tdust=1;\n\t\tfor(i=0;i<h;i++){\n\t\t\tcin>>p[i];\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tif(p[i][j]=='*'){\n\t\t\t\t\td[dust].h=i;\n\t\t\t\t\td[dust++].w=j;\n\t\t\t\t}\n\t\t\t\telse if(p[i][j]=='o'){\n\t\t\t\t\td[0].h=i;\n\t\t\t\t\td[0].w=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts=new sales(dust);\n\t\tint error=0;\n\t\tfor(i=0;i<dust-1;i++){\n\t\t\ts->set(i,i,0);\n\t\t\tfor(j=0;j<h;j++) for(k=0;k<w;k++) dist[j][k]=INFI;\n\t\t\tdec(d[i].h,d[i].w,0);\n\t\t\tfor(j=i+1;j<dust;j++){\n\t\t\t\tif(dist[d[j].h][d[j].w]==INFI){\n\t\t\t\t\terror=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ts->set(i,j,dist[d[j].h][d[j].w]);\n\t\t\t}\n\t\t\tif(error==1) break;\n\t\t}\n\t\tif(error==1){\n\t\t\tcout<<\"-1\"<<endl;\n\t\t}\n\t\telse{\n\t\t\ts->set(dust-1,dust-1,0);\n\t\t\ts->set();\n\t\t\tcout<<s->ret()<<endl;\n\t\t}\n\t\tdelete s;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint w, h;\nstring b[20];\nint step[20][20];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid bfs(int x, int y){\n\tmemset(step, -1, sizeof(step));\n\tqueue< pair<int, int> > qu; qu.push(make_pair(x,y));\n\tstep[x][y] = 0;\n\twhile(!qu.empty()){\n\t\tpair<int, int> pr = qu.front(); qu.pop();\n\t\tint cx = pr.first, cy = pr.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx = cx+dx[i], ny = cy+dy[i];\n\t\t\tif(nx<0||h<=nx||ny<0||w<=ny||b[nx][ny]=='x'||step[nx][ny]!=-1) continue;\n\t\t\tstep[nx][ny] = step[cx][cy]+1;\n\t\t\tqu.push(make_pair(nx,ny));\n\t\t}\n\t}\n}\n\nint main(){\n\tint c[11][11];\n\twhile(cin >> w >> h, w){\n\t\tfor(int i=0;i<h;i++) cin >> b[i];\n\t\tvector<int> x(1), y(1);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(b[i][j]=='o') x[0] = i, y[0] = j;\n\t\t\t\tif(b[i][j]=='*') x.push_back(i), y.push_back(j);\n\t\t\t}\n\t\t}\n\t\tint res = 1000000000;\n\t\tfor(int i=0;i<x.size();i++){\n\t\t\tbfs(x[i], y[i]);\n\t\t\tfor(int j=0;j<x.size();j++){\n\t\t\t\tc[i][j] = step[x[j]][y[j]];\n\t\t\t\tif(c[i][j]==-1) res = -1;\n\t\t\t}\n\t\t}\n\t\tif(res != -1){\n\t\t\tvector<int> a(x.size()-1);\n\t\t\tfor(int i=0;i<x.size()-1;i++) a[i] = i+1;\n\t\t\tdo{\n\t\t\t\tint cur = c[0][a[0]];\n\t\t\t\tfor(int i=0;i+1<a.size();i++) cur += c[a[i]][a[i+1]];\n\t\t\t\tres = min(res, cur);\n\t\t\t}while(next_permutation(a.begin(), a.end()));\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <deque>\n#include <algorithm>\nusing namespace std;\n\nint H, W;\nchar board[25][25];\nint dist[410][410];\nint dp[1 << 11][11];\nconst int INF = 1 << 20;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint get_idx(int x, int y) {\n    return x*W + y;\n}\n\nint main() {\n    while(cin >> W >> H, W || H) {\n        deque<int> stains;\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<W; j++) {\n                scanf(\" %c\", &board[i][j]);\n\n                if(board[i][j] == 'o') {\n                    stains.push_front(get_idx(i, j));\n                }\n                if(board[i][j] == '*') {\n                    stains.push_back(get_idx(i, j));\n                }\n            }\n        }\n\n        fill(dist[0], dist[410], INF);\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<W; j++) {\n                for(int k=0; k<4; k++) {\n                    int nx = i + dx[k], ny = j + dy[k];\n                    if(nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n                    if(board[i][j] == 'x') continue;\n                    if(board[nx][ny] == 'x') continue;\n\n                    int u = get_idx(i, j), v = get_idx(nx, ny);\n                    dist[u][v] = 1;\n                }\n            }\n        }\n\n        int N = H*W;\n        for(int k=0; k<N; k++) {\n            for(int i=0; i<N; i++) {\n                for(int j=0; j<N; j++) {\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n\n        int M = stains.size();\n        fill(dp[0], dp[1 << 11], INF);\n        dp[1][0] = 0;\n\n        for(int bit=0; bit<(1<<M); bit++) {\n            for(int i=0; i<M; i++) {\n                if(!(bit >> i & 1)) continue;\n                for(int k=0; k<M; k++) {\n                    if(bit >> k & 1) continue;\n\n                    int nbit = bit | (1 << k);\n                    int u = stains[i], v = stains[k];\n                    int cost = dist[u][v];\n\n                    dp[nbit][k] = min(dp[nbit][k], dp[bit][i] + cost);\n                }\n            }\n        }\n\n        int ans = INF;\n        for(int i=0; i<M; i++) {\n            ans = min(ans, dp[(1<<M) - 1][i]);\n        }\n\n        if(ans == INF) {\n            cout << -1 << endl;\n        }\n        else {\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\n#define X first\n#define Y second\n\nconst int INF = 0xfffffff;\nconst int dx[4] = {1, -1, 0, 0};\nconst int dy[4] = {0, 0, 1, -1};\nconst int MAX_N = 10;\n\nint w, h;\nint n;\nvector<vector<int> > mat;\nvector<int> x, y;\nvector<string> field;\nint memo[MAX_N + 1][1 << MAX_N];\n\nint bfs(int from, int to) {\n\tvector<vector<int> > label(h, vector<int>(w, INF));\n\tqueue<pair<int, int> > que;\n\tque.push(make_pair(x[from], y[from]));\n\tlabel[y[from]][x[from]] = 0;\n\n\twhile(!que.empty()) {\n\t\tconst int cx = que.front().X, cy = que.front().Y;\n\t\tque.pop();\n\n\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\tconst int nx = cx + dx[i], ny = cy + dy[i];\n\t\t\tif(nx < 0 || ny < 0 || nx >= w || ny >= h || field[ny][nx] == 'x')\n\t\t\t\tcontinue;\n\n\t\t\tif(label[ny][nx] > label[cy][cx] + 1) {\n\t\t\t\tlabel[ny][nx] = label[cy][cx] + 1;\n\t\t\t\tque.push(make_pair(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn label[y[to]][x[to]];\n}\n\nint dfs(int cur, int visited) {\n\tif(visited == (1 << n) - 1)\n\t\treturn 0;\n\n\tif(memo[cur][visited] != -1)\n\t\treturn memo[cur][visited];\n\n\tint res = INF;\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(visited & (1 << i))\n\t\t\tcontinue;\n\t\t\n\t\tchmin(res, dfs(i, visited | (1 << i)) + mat[cur][i]);\n\t}\n\n\treturn memo[cur][visited] = res;\n}\n\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> w >> h, w) {\n\t\tx.clear();\n\t\ty.clear();\n\n\t\tfield.clear();\n\t\tfield.resize(h);\n\t\tfor(int i = 0; i < h; ++i)\n\t\t\tcin >> field[i];\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tif(field[i][j] == '*') {\n\t\t\t\t\tx.push_back(j);\n\t\t\t\t\ty.push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tn = x.size();\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tif(field[i][j] == 'o') {\n\t\t\t\t\tx.push_back(j);\n\t\t\t\t\ty.push_back(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmat.clear();\n\t\tmat.resize(n + 1, vector<int>(n + 1, INF));\n\t\tfor(int i = 0; i <= n; ++i)\n\t\t\tmat[i][i] = 0;\n\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tfor(int j = i + 1; j <= n; ++j)\n\t\t\t\tmat[i][j] = mat[j][i] = bfs(i, j);\n\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tconst int ans = dfs(n, 0);\n\t\tcout << (ans >= INF ? -1 : ans) << endl;\t\t\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct State {\n  int i, j, f;\n};\n\nconst int MAXH = 21;\nconst int MAXW = 21;\nconst int MAXF = 1<<10;\nint w, h, n;\nvector<string> G;\nint cost[MAXH][MAXW][MAXF];\n\nint main() {\n  while(cin >> w >> h && (w|h)) {\n    G.resize(h);\n    for(int i = 0; i < h; ++i) cin >> G[i];\n\n    int si, sj;\n    n = 0;\n    for(int i = 0; i < h; ++i) {\n      for(int j = 0; j < w; ++j) {\n        if(G[i][j] == 'o') {\n          si = i; sj = j;\n        } else if(G[i][j] == '*') {\n          G[i][j] = '0' + n++;\n        }\n      }\n    }\n\n    try {\n      queue<State> que;\n      que.push((State){si, sj, 0});\n      memset(cost, -1, sizeof(cost));\n      cost[si][sj][0] = 0;\n      while(que.size()) {\n        const State s = que.front();\n        que.pop();\n        for(int k = 0; k < 4; ++k) {\n          int di = (2 - k) % 2;\n          int dj = (1 - k) % 2;\n          int ni = s.i + di;\n          int nj = s.j + dj;\n          if(ni < 0 || ni >= h) continue;\n          if(nj < 0 || nj >= w) continue;\n          int nf = s.f;\n          if(G[ni][nj] == 'x') continue;\n          if(isdigit(G[ni][nj])) {\n            nf |= 1 << (G[ni][nj] - '0');\n          }\n          if(~cost[ni][nj][nf]) continue;\n          que.push((State){ni, nj, nf});\n          cost[ni][nj][nf] = cost[s.i][s.j][s.f] + 1;\n          if(nf == (1 << n) - 1) {\n            throw cost[ni][nj][nf];\n          }\n        }\n      }\n      throw -1;\n    } catch(int res) {\n      cout << res << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nclass Point{\npublic:\n  int x;\n  int y;\n};\n\nclass Cost{\npublic:\n  int x;\n  int y;\n  int c;\n};\n\nint w, h, n;\nPoint data[11];\nchar mdata[20][20];\nint cost[11][11];\nbool visited[20][20];\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\n\nint bfs(Point, Point);\n\nmain(){\n  while(1){\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    int k=1;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> mdata[i][j];\n\tif(mdata[i][j]=='o'){\n\t  data[0].y=i;\n\t  data[0].x=j;\n\t}\n\tif(mdata[i][j]=='*'){\n\t  data[k].y=i;\n\t  data[k].x=j;\n\t  k++;\n\t}\n      }\n    }\n    n=k;\n    bool flag=false;\n    for(int i=0;i<n;i++){\n      if(flag) break;\n      for(int j=0;j<n;j++){\n\tif(i==j){\n\t  cost[i][j]=cost[j][i]=0;\n\t}\n\telse{\n\t  for(int a=0;a<h;a++){\n\t    for(int b=0;b<w;b++){\n\t      visited[a][b]=false;\n\t    }\n\t  }\n\t  cost[i][j]=cost[j][i]=bfs(data[i], data[j]);\n\t  if(cost[i][j]==-1){\n\t    flag=true;\n\t    break;\n\t  }\n\t}\n      }\n    }\n    if(flag){\n      cout << -1 << endl;\n      continue;\n    }\n\n    int A[10];\n    for(int i=1;i<n;i++){\n      A[i-1]=i;\n    }\n\n    int ans=-1;\n    do{\n      int tmp=cost[0][A[0]];\n      for(int i=1;i<n-1;i++){\n\ttmp+=cost[A[i-1]][A[i]];\n      }\n      if(ans==-1 || ans>tmp){\n\tans=tmp;\n      }\n    }while(next_permutation(A, A+n-1));\n\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n\nint bfs(Point start, Point goal){\n  queue<Cost> q;\n\n  Cost s;\n  s.x=start.x;\n  s.y=start.y;\n  s.c=0;\n\n  q.push(s);\n  int ans=-1;\n  Cost u, v;\n  while(!q.empty()){\n    u=q.front(), q.pop();\n    if(u.y==goal.y && u.x==goal.x){\n      ans=u.c;\n      break;\n    }\n    visited[u.y][u.x]=true;\n    for(int i=0;i<4;i++){\n      v.y=u.y+dy[i];\n      v.x=u.x+dx[i];\n      v.c=u.c+1;\n      if(v.y>=0 && v.y<h){\n\tif(v.x>=0 && v.x<w){\n\t  if(mdata[v.y][v.x]!='x'){\n\t    if(!visited[v.y][v.x]){\n\t      q.push(v);\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  return ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint dp[21][21][1024];\nbool used[21][21][1024];\nint rev[21][21];\nchar ch[21][21];\nint n,m;\nint main(){\n\twhile(1){\n\t\tcin>>m>>n;\n\t\tif(n==0 && m==0) return 0;\n\t\tfor(int i=0;i<n;i++) scanf(\"%s\",&ch[i]);\n\t\trep(i,21)rep(j,21)rep(k,1024){\n\t\t\tused[i][j][k] = 0;\n\t\t\tdp[i][j][k] = INF;\n\t\t\trev[i][j] = -1;\n\t\t}\n\t\tint cx,cy,nxt=0;\n\t\trep(i,n) rep(j,m){\n\t\t\tif(ch[i][j] == 'o') cx=i,cy=j;\n\t\t\telse if(ch[i][j] == '*'){\n\t\t\t\trev[i][j] = nxt++;\n\t\t\t}\n\t\t}\n\t\tdp[cx][cy][0] = 0;\n\t\tqueue<P1>que; que.push(mp(cx,mp(cy,0)));\n\t\twhile(!que.empty()){\n\t\t\tP1 p = que.front(); que.pop();\n\t\t\tint x = p.fi, y = p.sc.fi, mask = p.sc.sc;\n\t\t\tif(used[x][y][mask]) continue;\n\t\t\tused[x][y][mask] = 1;\n\t\t\tint dx[4]={0,1,0,-1};\n\t\t\tint dy[4]={1,0,-1,0};\n\t\t\trep(k,4){\n\t\t\t\tint nx = x+dx[k];\n\t\t\t\tint ny = y+dy[k];\n\t\t\t\tif(0<=nx&&nx<n&&0<=ny&&ny<m&&ch[nx][ny]!='x'){\n\t\t\t\t\tint M = mask;\n\t\t\t\t\tif(rev[nx][ny] >= 0) M |= 1<<rev[nx][ny];\n\t\t\t\t\tdp[nx][ny][M] = min(dp[nx][ny][M],dp[x][y][mask]+1);\n\t\t\t\t\tif(!used[nx][ny][M]){\n\t\t\t\t\t\tque.push(mp(nx,mp(ny,M)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(x,n)rep(y,m) ans = min(ans,dp[x][y][(1<<nxt)-1]);\n\t\tif(ans == INF) ans=-1;\n\t\tcout<<ans<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define INFI 1000000\n\nstruct point{\n\tint h,w;\n};\n\nclass sales{\nprivate:\n\tint n;\n\tint **dist;\n\tint **dp;\n\tint ans;\npublic:\n\tsales(int n){\n\t\tthis->n=n;\n\t\tdist=new int*[n];\n\t\tfor(int i=0;i<n;i++) dist[i]=new int[n];\n\t\tdp=new int*[1<<n];\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tdp[i]=new int[n];\n\t\t\tfor(int j=0;j<n;j++) dp[i][j]=-1;\n\t\t}\n\t}\n\tvoid set(int n,int m,int c){\n\t\tdist[n][m]=c;\n\t\tdist[m][n]=c;\n\t}\n\tvoid set(){\n\t\tfor(int i=0;i<n;i++) dist[i][0]=0;\n\t\tans=rec(0,0);\n\t}\n\tint rec(int s,int v){\n\t\tif(dp[s][v]>=0) return dp[s][v];\n\n\t\tif(s==(1<<n)-1 && v==0) return dp[s][v]=0;\n\t\tint res=INFI;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(!(s>>i & 1)){\n\t\t\t\tres=i_min(res,rec(s|(1<<i),i)+dist[v][i]);\n\t\t\t}\n\t\t}\n\t\treturn dp[s][v]=res;\n\t}\n\tvoid show(){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++) cout<<dist[i][j]<<\" \";\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\tint i_min(int p,int q){\n\t\tif(p<q) return p;\n\t\treturn q;\n\t}\n\tint ret(){\n\t\treturn ans;\n\t}\n};\n\n\nint w,h;\nchar p[20][21];\nint dist[20][20];\nint dust;\npoint d[10];\nsales *s;\n\nvoid dec(int ph,int pw,int c){\n\tif(p[ph][pw]=='x') return;\n\tif(ph<0 || ph>=h ||pw<0 || pw>=w) return;\n\tif(dist[ph][pw]<=c) return;\n\tdist[ph][pw]=c;\n\t\n\tdec(ph-1,pw,c+1);\n\tdec(ph+1,pw,c+1);\n\tdec(ph,pw-1,c+1);\n\tdec(ph,pw+1,c+1);\n\treturn;\n}\n\nint main(){\n\tint i,j,k;\n\twhile(cin>>w>>h){\n\t\tif(w==0 && h==0) break;\n\t\tdust=0;\n\t\tfor(i=0;i<h;i++){\n\t\t\tcin>>p[i];\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tif(p[i][j]!='.' && p[i][j]!='x'){\n\t\t\t\t\td[dust].h=i;\n\t\t\t\t\td[dust++].w=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts=new sales(dust);\n\t\tint error=0;\n\t\tfor(i=0;i<dust-1;i++){\n\t\t\ts->set(i,i,0);\n\t\t\tfor(j=0;j<h;j++) for(k=0;k<w;k++) dist[j][k]=INFI;\n\t\t\tdec(d[i].h,d[i].w,0);\n\t\t\tfor(j=i+1;j<dust;j++){\n\t\t\t\tif(dist[d[j].h][d[j].w]==INFI){\n\t\t\t\t\terror=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ts->set(i,j,dist[d[j].h][d[j].w]);\n\t\t\t}\n\t\t\tif(error==1) break;\n\t\t}\n\t\tif(error==1){\n\t\t\tcout<<-1<<endl;\n\t\t}\n\t\telse{\n\t\t\ts->set(dust-1,dust-1,0);\n\t\t\ts->set();\n\t\t\tcout<<s->ret()<<endl;\n\t\t}\n\t\tdelete s;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<limits.h>\n#define INF 100000\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h;\nint imap[21][21];\nint fin;\nint djd[20][2]; // 0->x ,1->y\nint mmaapp[20][20];\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\nint bfs(int sp,int gp){\n  int mmap[21][21];\n \n  for(int i=0;i<21;i++)for(int j=0;j<21;j++)mmap[i][j] = INF;\n  queue<P> que;\n  que.push(P(djd[sp][0],djd[sp][1]));\n  mmap[djd[sp][1]][djd[sp][0]]=0;\n\n  while(que.size()){\n    P p = que.front();que.pop();\n\n    if(p.first == djd[gp][0] && p.second == djd[gp][1])return mmap[djd[gp][1]][djd[gp][0]];\n\n    for(int i=0;i<4;i++){\n      int nx = p.first+dx[i],ny = p.second+dy[i];\n      if(0<=nx && nx < w && 0<=ny && ny < h && mmap[ny][nx] == INF && imap[ny][nx] != -1){\n\tque.push(P(nx,ny));\n\tmmap[ny][nx] = mmap[p.second][p.first] + 1;\n      }\n    }\n  }\n  return -1;\n}\n\n\n\nint main(){\n  char in;\n  int count;\n  int permutationtest[66];\n  while(true){\n    cin >> w >> h;\n    if(w+h == 0)break;\n    rep(i,66)permutationtest[i] = 0;  \n    count=1;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> in;\n\tswitch(in){\n\tcase '.':\n\t  imap[i][j]=0;\n\t  break;\n\tcase 'o':\n\t  imap[i][j]=0;\n\t  djd[0][0]=j;\n\t  djd[0][1]=i;\n\t  break;\n\tcase 'x':\n\t  imap[i][j]=-1;\n\t  break;\n\tcase '*':\n\t  imap[i][j]=0;\n\t  djd[count][0]=j;\n\t  djd[count][1]=i;\n\t  count++;\n\t  break;\n\tdefault:\n\n\t  break;\n\t}\n      }\n    }\n    fin=INF;\n    for(int i=0;i<count;i++){\n      for(int j=0;j<count;j++){\n\tmmaapp[i][j] = bfs(i,j);\n\tfin = min(fin,mmaapp[i][j]);\n      }\n   \n    }\n   \n   \n   \n    for(int i=0;i<count-1;i++){\n      permutationtest[i] = i+1;\n   \n    }\n    \n    \n    \n    int sum;\n    int ans=INF;\n    do{\n      sum=0;\n      sum+=mmaapp[0][permutationtest[0]];\n    \n      for(int i=1;i<count-1;i++){\n\tsum+=mmaapp[permutationtest[i-1]][permutationtest[i]];\n      }\n    \n      ans=min(ans,sum);\n    }while(next_permutation(permutationtest,permutationtest+(count-1)));\n\n    if(fin < 0)cout << \"-1\" << endl;// finの初期化忘れてた\n    else cout << ans << endl;\n\n\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ntemplate<class T>\nstruct Edge{\n\tint from,to;\n\tT cost;\n\tEdge(int to,T cost) : to(to),cost(cost){}\n\tEdge(int from,int to,T cost) : from(from),to(to),cost(cost){}\n\toperator int() const noexcept { return to; }\n};\n\ntemplate<class T>\nusing WeightedGraph = vector<vector<Edge<T>>>;\nusing Graph = vector<vector<int>>;\ntemplate<class T>\nusing Matrix = vector<vector<T>>;\n\ntemplate<class T>\nvoid warshallFloyd(Matrix<T> &G){\n\tfor(int k = 0;k < G.size();k++){\n\t\tfor(int i = 0;i < G.size();i++){\n\t\t\tfor(int j = 0;j < G.size();j++){\n\t\t\t\tG[i][j] = min(G[i][j],G[i][k] + G[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint w,h;\n\ninline int ind(int x,int y){\n\treturn x * w + y;\n}\n\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n\nvoid solve(){\n\tconst int INF = 1e9;\n\tstring field[25];\n\tfor(int i = 0;i < h;i++) cin >> field[i];\n\tint pos[20],cnt = 1;\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tif(field[i][j] == 'o') pos[0] = ind(i,j);\n\t\t\telse if(field[i][j] == '*') pos[cnt++] = ind(i,j);\n\t\t}\n\t}\n\tMatrix<int> G(h * w,vector<int>(h * w,INF));\n\tfor(int i = 0;i < h * w;i++) G[i][i] = 0;\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tfor(int k = 0;k < 4;k++){\n\t\t\t\tint nx = i + dx[k],ny = j + dy[k];\n\t\t\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && field[nx][ny] != 'x'){\n\t\t\t\t\tG[ind(i,j)][ind(nx,ny)] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twarshallFloyd(G);\n\tvector<int> vec(cnt);\n\tiota(vec.begin(),vec.end(),0);\n\tint ans = INF;\n\tdo{\n\t\tint sum = 0;\n\t\tfor(int i = 1;i < cnt;i++) sum += G[pos[vec[i - 1]]][pos[vec[i]]];\n\t\tans = min(ans,sum);\n\t}while(next_permutation(vec.begin() + 1,vec.end()));\n\tif(ans == INF) cout << -1 << endl;\n\telse cout << ans << endl;\n}\n\nsigned main(){\n\twhile(cin >> w >> h,w) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint dy[]={-1,0,1,0},dx[]={0,-1,0,1};\nint bfs(vs &c,pii from,pii to,int h,int w){\n\tqueue<pii> q;\n\tq.push(from);\n\tvvi cost(h,vi(w,-1));\n\tcost[from.first][from.second]=0;\n\twhile(!q.empty()){\n\t\tpii p=q.front();q.pop();\n\t\tREP(d,4){\n\t\t\tint y=p.first+dy[d];\n\t\t\tint x=p.second+dx[d];\n\t\t\tif(y>=0&&x>=0&&y<h&&x<w&&c[y][x]!='x'&&cost[y][x]==-1){\n\t\t\t\tq.push(make_pair(y,x));\n\t\t\t\tcost[y][x]=cost[p.first][p.second]+1;\n\t\t\t}\n\t\t}\n\t}\n\treturn cost[to.first][to.second];\n}\n\nconst int MAX=INT_MAX/100;\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h,w|h){\n\t\tvs c(h);\n\t\tvector<pii> targets;\n\t\tpii start;\n\t\tREP(i,h){\n\t\t\tcin>>c[i];\n\t\t\tREP(j,w){\n\t\t\t\tif(c[i][j]=='*'){\n\t\t\t\t\ttargets.push_back(make_pair(i,j));\n\t\t\t\t}else if(c[i][j]=='o'){\n\t\t\t\t\tstart=make_pair(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttargets.push_back(start);\n\t\tint sz=targets.size();\n\t\tvvi cost(sz+1,vi(sz+1));\n\t\tREP(i,sz){\n\t\t\tFOR(j,i+1,sz){\n\t\t\t\tcost[i][j]=bfs(c,targets[i],targets[j],h,w);\n\t\t\t\tcost[j][i]=cost[i][j];\n\t\t\t}\n\t\t}\n\n\t\tvi order(sz-1);\n\t\tREP(i,sz-1){\n\t\t\torder[i]=i;\n\t\t}\n\t\tint ans=MAX;\n\t\tdo {\n\t\t\tint dist=cost[sz-1][order[0]];\n\t\t\tREP(i,sz-2){\n\t\t\t\tdist+=cost[order[i]][order[i+1]];\n\t\t\t}\n\t\t\tans=min(ans,dist);\n\t\t}while(next_permutation(ALL(order)));\n\t\tcout<<(ans==MAX?-1:ans)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int,int> P;\nint W,H;\nint dx[4] = {-1,1,0,0},dy[4] = {0,0,-1,1};\nint dist[11][11] = {},inf = 1e5;\nint visited[21][21] = {};\nint A[11] = {1,2,3,4,5,6,7,8,9,10,11};\nchar F[21][21];\n\n\nbool in(int x,int y){\n    return 1<=x && x<=H && 1<=y && y<=W;\n}\n\nint main(){\n    while(cin >> W >> H && W>0){\n        int id = 1;\n        map<P,int> m;\n        for(int i=1;i<=H;i++){\n            for(int j=1;j<=W;j++){\n                cin >> F[i][j];\n                if(F[i][j]=='*'){\n                    m[{i,j}] = id+1;\n                    id++;\n                }\n                if(F[i][j]=='o') m[{i,j}] = 1;\n            }\n        }\n        for(int i=1;i<=id;i++) for(int j=1;j<=id;j++){dist[i][j] = inf; dist[j][i] = inf;}\n        for(auto a:m){\n            queue<P> Q;\n            for(int i=1;i<=H;i++) for(int j=1;j<=W;j++) visited[i][j] = inf;\n            Q.push(a.first);\n            visited[a.first.first][a.first.second] = 0;\n            while(!Q.empty()){\n                int x = Q.front().first,y = Q.front().second;\n                Q.pop();\n                for(int i=0;i<4;i++){\n                    int nx = x+dx[i],ny = y+dy[i];\n                    if(in(nx,ny)&&visited[nx][ny]==inf&&F[nx][ny]!='x'){\n                        visited[nx][ny] = visited[x][y]+1;\n                        Q.push({nx,ny});\n                    }\n                }\n            }\n            for(auto b:m){\n                if(a!=b) dist[a.second][b.second] = visited[b.first.first][b.first.second];\n            }\n        }\n        int ans = inf;\n        do{\n            int now = 0;\n            for(int i=0;i<id;i++){\n                now += dist[A[i]][A[i+1]];\n            }\n            ans = min(ans,now);\n        }while(next_permutation(A+1,A+id));\n        cout << (ans!=inf? ans:-1) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <unordered_set>\n# include <unordered_map>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define STR(x) string x;cin>>x;\n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl;\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<int> vi;\ntypedef vector<lint> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\ntemplate<class T> void debug(T a) { for (auto i : a)cout << i << endl; }\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint x, y;\n\t\tint a[22][22];\n\t\tpii start; \n\t\tvector<pii> goals;\n\n\t\tcin >> x >> y; if (!x)break;\n\t\tmemset(a, -1, sizeof a);\n\t\t\n\t\tFORI(i, 1, y + 1)\n\t\t{\n\t\t\tFORI(j, 1, x + 1)\n\t\t\t{\n\t\t\t\ta[i][j] = 0;\n\t\t\t\tchar c; cin >> c;\n\t\t\t\tif (c == 'o')start = pii(i, j);\n\t\t\t\tif (c == 'x')a[i][j] = -1;\n\t\t\t\tif (c == '*') { a[i][j] = 1; goals.emplace_back(i, j); }\n\t\t\t}\n\t\t}\n\t\tgoals.push_back(start);\n\n\t\tauto calc_cost=[&a](pii start)->vector<vi> \n\t\t{\n\t\t\tvi line(22, INF);\n\t\t\tvector<vi> ans(22, line);\n\t\t\tans[start.first][start.second] = 0;\n\t\t\tpriority_queue< piii, vector<piii>, greater<piii> >que;\n\t\t\tque.push(piii(0, start));\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tpiii now = que.top(); que.pop();\n\t\t\t\tFOR(i, 4)\n\t\t\t\t{\n\t\t\t\t\tpii p=now.second;\n\t\t\t\t\tp.first += dy[i]; p.second += dx[i];\n\t\t\t\t\tif (ans[p.first][p.second] > now.first + 1 && a[p.first][p.second] != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tpiii next(now.first+1,p);\n\t\t\t\t\t\tans[p.first][p.second] = next.first;\n\t\t\t\t\t\tque.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans;\n\t\t};\n\t\tvector<vi> costs;\n\t\tbool ok = true;\n\n\t\tFOR(i, goals.size())\n\t\t{\n\t\t\tvector<vi> map=calc_cost(goals[i]);\n\t\t\tvi f;\n\t\t\tFOR(j, goals.size())\n\t\t\t{\n\t\t\t\tint cost = map[goals[j].first][goals[j].second];\n\t\t\t\tif (cost >= INF)ok = false;\n\t\t\t\tf.push_back(cost);\n\t\t\t}\n\t\t\tcosts.push_back(f);\n\t\t}\n\t\tif (!ok) { cout << \"-1\" << endl; continue; }\n\t\ttypedef pair< int, pair<int, vi> > P;\n\t\tP s(0, pair<int, vi>(goals.size() - 1, {(int)goals.size()-1}));\n\t\tpriority_queue< P, vector<P>, greater<P> > que;\n\t\tque.push(s);\n\t\t\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tP now = que.top(); que.pop();\n\t\t\tif (now.second.second.size() == goals.size())\n\t\t\t{\n\t\t\t\tcout << now.first << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tFOR(i, costs[now.second.first].size())\n\t\t\t{\n\t\t\t\tif (!count(ALL(now.second.second), i))\n\t\t\t\t{\n\t\t\t\t\tP next = now;\n\t\t\t\t\tnext.first += costs[now.second.first][i];\n\t\t\t\t\tnext.second.first = i;\n\t\t\t\t\tnext.second.second.push_back(i);\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_HW=410,MAX_D=12,INF=1e9,MAX_B=1<<MAX_D;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n\nint w,h,sh,sw,n;\nvector<string> S;\nvector<vector<int>> dist(MAX_HW,vector<int>(MAX_HW))\n                    ,dist0(MAX_D,vector<int>(MAX_D))\n                    ,dp(MAX_B,vector<int>(MAX_D));\nvector<pair<int,int>> dust;\nqueue<pair<int,int>> que;\n\nvoid bfs(int x,int y){\n    for (int i=0;i<h;++i)\n        for (int j=0;j<w;++j)\n            dist[i][j]=INF;\n    dist[x][y]=0;\n    que.emplace(x,y);\n    while(!que.empty()){\n        auto p=que.front(); que.pop();\n        for (int i=0;i<4;++i){\n            int nx=p.first+dx[i],ny=p.second+dy[i];\n            if (nx<0||h<=nx||ny<0||w<=ny) continue;\n            if (S[nx][ny]=='x'||dist[nx][ny]!=INF) continue;\n            dist[nx][ny]=dist[p.first][p.second]+1;\n            que.emplace(nx,ny);\n        }\n    }\n}\n\nint solve(){\n    dust.clear();\n    for (int i=0;i<h;++i){\n        for (int j=0;j<w;++j){\n            if (S[i][j]=='o') sh=i,sw=j;\n            if (S[i][j]=='*') dust.emplace_back(i,j);\n        }\n    }\n    dust.emplace_back(sh,sw);\n    int n=dust.size();\n    for (int i=0;i<n;++i){\n        bfs(dust[i].first,dust[i].second);\n        for (int j=0;j<n;++j)\n            dist0[i][j]=dist[dust[j].first][dust[j].second];\n    }\n    for (int i=0;i<(1<<(n-1));++i)\n        for (int j=0;j<n;++j)\n            dp[i][j]=INF;\n    dp[0][n-1]=0;\n    for (int mask=0;mask<(1<<(n-1));++mask)\n        for (int i=0;i<n;++i)\n            for (int j=0;j<n-1;++j)\n                if (!(mask&1<<j))\n                    dp[mask|1<<j][j]=min(dp[mask|1<<j][j],dp[mask][i]+dist0[i][j]);\n    int ans=INF;\n    for (int i=0;i<n-1;++i) ans=min(ans,dp[(1<<(n-1))-1][i]);\n    return (ans!=INF?ans:-1);\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> w >> h,h){\n        S.resize(h);\n        for (int i=0;i<h;++i) cin >> S[i];\n        cout << solve() << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cassert>\n#include<cstdio>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int MAX = 21;\nconst int TM = 11;\nconst int INF = (1<<25);\n\nchar F[MAX][MAX];\nint T[(1<<TM)][MAX][MAX];\nint w,h,sx,sy;\nvector<P> Trash;\n\n\nstruct State{\n  int x,y,t,come;\n  \n  State(){}\n  State(int x, int y, int t, int c):x(x),y(y),t(t),come(c){}\n  bool operator < (const State& s) const { return t > s.t;}\n\n};\n\nvoid print(){\n  for(int i = 0; i < (1<<Trash.size()); i++){\n    for(int y = 0; y < h; y++){\n      for(int x = 0; x < w; x++)\n\tif(T[i][y][x] != INF){\n\t  printf(\"%3d\",T[i][y][x]);\n\t}else {cout << \" X \";}\n      cout << endl;\n    }\n    cout << endl;\n  }\n}\n\nbool isInside(int x, int y){ return 0<=x&&x<w&&0<=y&&y<h;}\n\nvoid init(){\n\n  fill(T[0][0],T[0][0]+(1<<TM)*MAX*MAX,INF);\n  Trash.clear();\n}\n\nvoid input(){\n  for(int i = 0; i < h; i++)\n    for(int j = 0; j < w; j++){\n      cin >> F[i][j];\n      if(F[i][j] == 'o'){\n\tsx = j;\n\tsy = i;\n      }\n      if(F[i][j] == '*') Trash.push_back(P(j,i));\n\n    }\n}\n\nint getTrashNum(P p){\n  for(int i = 0; i < Trash.size(); i++)\n    if(Trash[i] == p) return i;\n  \n  cerr << \"not found\" << endl;\n  return -1;\n}\nvoid solve(){\n\n  priority_queue<State> Q;\n  Q.push(State(sx,sy,0,0));\n  T[0][sy][sx] = 0;\n\n  int dx[] = {0,0,1,-1};\n  int dy[] = {1,-1,0,0};\n\n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n\n    if(T[now.come][now.y][now.x] < now.t) continue;\n    \n    for(int i = 0; i < 4; i++){\n      State nex = now;\n      nex.x += dx[i];\n      nex.y += dy[i];\n      nex.t++;\n\n      if(!isInside(nex.x,nex.y)) continue;\n      if(F[nex.y][nex.x] == 'x') continue;\n\n\n      if(F[nex.y][nex.x] == '*'){\n\tint Tnum = getTrashNum(P(nex.x, nex.y));\n\tnex.come = (nex.come|(1<<Tnum));\n      }\n\n      \n      if(T[nex.come][nex.y][nex.x] > nex.t){\n\tT[nex.come][nex.y][nex.x] = nex.t;\n\tQ.push(nex);\n      }\n    }\n  }\n\n  int ans = INF;\n\n  // print();\n\n  if(Trash.size() == 0) ans = 0;\n\n   for(int i = 0; i < Trash.size(); i++)\n     ans = min(ans,T[(1<<Trash.size())-1][Trash[i].second][Trash[i].first]);\n\n\n  if(ans == INF) cout << \"-1\" << endl;\n  else cout << ans << endl;\n \n}\n  \nint main(){\n\n  while(cin >> w >> h && w+h){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <string.h>\n\nusing namespace std;\n\nconst int INF = 9999999;\n\nint w, h;\nstring b[20];\nint d[20][20];\n\nchar dx[] = {-1,1,0,0};\nchar dy[] = {0,0,-1,1};\n\nvoid dist(int sx, int sy){\n\tfor(int i=0;i<20;i++)\n\t\tfor(int j=0;j<20;j++)\n\t\t\td[i][j] = INF;\n\tqueue< pair<int,int> > qu;\n\tqu.push(make_pair(sx,sy));\n\td[sy][sx] = 0;\n\twhile(!qu.empty()){\n\t\tpair<int, int> p = qu.front(); qu.pop();\n\t\tint x = p.first, y = p.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif(nx<0||nx>=w||ny<0||ny>=h||b[ny][nx]=='x') continue;\n\t\t\tif(d[ny][nx] != INF) continue;\n\t\t\td[ny][nx] = d[y][x] + 1;\n\t\t\tqu.push(make_pair(nx,ny));\n\t\t}\n\t}\n}\n\nint main(){\n\tint c[11][11];\n\tint x[11], y[11];\n\tint ans[1<<11][11];\n\twhile(cin >> w >> h){\n\t\tif(!(w||h)) break;\n\t\tint num = 1;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin >> b[i];\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(b[i][j]=='o') x[0] = j, y[0] = i;\n\t\t\t\tif(b[i][j]=='*') x[num] = j, y[num++] = i;\n\t\t\t}\n\t\t}\n\t\tbool flag = false;\n\t\tmemset(c,0,sizeof(c));\n\t\tdist(x[0],y[0]);\n\t\tfor(int i=1;i<num;i++){\n\t\t\tc[0][i] = d[y[i]][x[i]];\n\t\t\tif(c[0][i] == INF) flag = true;\n\t\t}\n\t\tif(flag) { cout << -1 << endl; continue; }\n\t\tfor(int i=1;i<num;i++){\n\t\t\tdist(x[i],y[i]);\n\t\t\tfor(int j=0;j<num;j++){\n\t\t\t\tif(i==j) continue;\n\t\t\t\tc[i][j] = d[y[j]][x[j]];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(1<<num);i++) for(int j=0;j<num;j++) ans[i][j] = INF;\n\t\tans[1][0] = 0;\n\t\tfor(int i=0;i<(1<<num);i++){\n\t\t\tfor(int j=0;j<num;j++)\n\t\t\t\tif((i>>j)&1)\n\t\t\t\t\tfor(int k=0;k<num;k++)\n\t\t\t\t\t\tans[i|(1<<k)][k] = min(ans[i|(1<<k)][k],ans[i][j]+c[j][k]);\n\t\t}\n\t\tint cost = INF;\n\t\tfor(int i=1;i<num;i++) cost = min(cost, ans[(1<<num)-1][i]);\n\t\tcout << cost << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int, int> P;\nchar tile[20][21];\nbool vis[20][20];\nint d[20][20];\nint dist[11][11];\nint dx[] = { 1,0,-1,0 };\nint dy[] = { 0,1,0,-1 };\nint w, h;\nvoid calc(int sx, int sy) {\n\tmemset(vis, 0, sizeof(vis));\n\tmemset(d, -1, sizeof(d));\n\tvis[sy][sx] = 1;\n\td[sy][sx] = 0;\n\tqueue<P> Q;\n\tQ.push(P(sx, sy));\n\twhile (!Q.empty()) {\n\t\tP p = Q.front(); Q.pop();\n\t\tint x = p.first, y = p.second;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (nx < 0 || nx >= w || ny < 0 || ny >= h||tile[ny][nx]=='x'||vis[ny][nx]) continue;\n\t\t\tvis[ny][nx] = 1;\n\t\t\td[ny][nx] = d[y][x] + 1;\n\t\t\tQ.push(P(nx, ny));\n\t\t}\n\t}\n}\nint main() {\n\twhile (cin >> w >> h, w) {\n\t\tint sx, sy;\n\t\tvector<P> dirty;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tcin >> tile[i];\n\t\t\tfor (int j = 0; j < w; j++) if (tile[i][j] == 'o') sx = j, sy = i;\n\t\t}\n\t\tdirty.emplace_back(sx, sy);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) if (tile[i][j] == '*') dirty.emplace_back(j, i);\n\t\t}\n\t\tfor (int i = 0; i < dirty.size(); i++) {\n\t\t\tcalc(dirty[i].first, dirty[i].second);\n\t\t\tfor (int j = 0; j < dirty.size(); j++) {\n\t\t\t\tdist[i][j] = d[dirty[j].second][dirty[j].first];\n\t\t\t}\n\t\t}\n\t\tint perm[11];\n\t\tfor (int i = 0; i < dirty.size(); i++) perm[i] = i;\n\t\tint ans = 1 << 30;\n\t\tdo {\n\t\t\tint sum = 0;\n\t\t\tint prev = 0;\n\t\t\tbool ok = 1;\n\t\t\tfor (int i = 1; i < dirty.size(); i++) {\n\t\t\t\tint t = dist[prev][perm[i]];\n\t\t\t\tif (t == -1) {\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsum += t;\n\t\t\t\tprev = perm[i];\n\t\t\t}\n\t\t\tif (!ok) continue;\n\t\t\tans = min(ans, sum);\n\t\t} while (next_permutation(perm + 1, perm + dirty.size()));\n\t\tif (ans == 1 << 30) cout << -1 << endl;\n\t\telse cout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n\n\nusing namespace std;\n\nconst int INF = 10000000;\n\n// ツ各ツ可伉づェツタツイツδ仰＋ツスツタツーツトツ地ツ点ツづ個つサツづェツつシツづェツづ個甘板づ個仰猟猟」\nint d[21][21][21][21];\nvector<string> field;\npair<int,int> sp;\nvector<pair<int,int> > dartys;\nint w,h;\n\nint bfs(int sy,int sx){\n\tqueue<pair<int,int> > *prv = new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *nxt = new queue<pair<int,int> >();\n\n\tbool passed[21][21];\n\tfor(int i = 0; i < 21; i++)\n\t\tfill(passed[i],passed[i]+21,false);\n\n\tprv->push(make_pair(sy,sx));\n\n\tint dy[] = {-1,0,0,1};\n\tint dx[] = {0,-1,1,0};\n\n\tint dist = 0;\n\n\tint cnt = 0;\n\twhile(prv->size()){\n\t\twhile(prv->size()){\n\t\t\tpair<int,int> cp = prv->front();prv->pop();\n\t\t\tif(passed[cp.first][cp.second])\n\t\t\t\tcontinue;\n\t\t\tpassed[cp.first][cp.second]=true;\n\t\t\td[sy][sx][cp.first][cp.second] = dist;\n\n\t\t\tif(field[cp.first][cp.second] == '*'){\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tpair<int,int> np = cp;\n\t\t\t\tnp.first += dy[i];\n\t\t\t\tnp.second += dx[i];\n\t\t\t\tif(np.first >= 0 && np.second >= 0 && np.first < h && np.second < w){\n\t\t\t\t\tif(!passed[np.first][np.second] && field[np.first][np.second] != 'x'){\n\t\t\t\t\t\tnxt->push(np);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdist++;\n\t\tswap(prv,nxt);\n\t}\n\tdelete prv,nxt;\n\treturn cnt;\n}\n\nint dfs(int s,pair<int,int> prv){\n\tif(s == (1 << (int)(dartys.size()))-1){\n\t\treturn 0;\n\t}\n\n\tint minCost = INF;\n\tfor(int i = 0; i < dartys.size(); i++){\n\t\tif(!((1 & (s >> i)) == 1) && d[prv.first][prv.second][dartys[i].first][dartys[i].second] != INF){\n\t\t\tminCost = min(minCost,dfs(s | (1 << i),make_pair(dartys[i].first,dartys[i].second))\n\t\t\t\t+ d[prv.first][prv.second][dartys[i].first][dartys[i].second]);\n\t\t}\n\t}\n\treturn minCost;\n}\n\nint main(){\n\n\twhile(cin >> w >> h && !(w == 0 && h == 0)){\n\t\tfor(int i = 0; i < 21; i++){\n\t\t\tfor(int j = 0; j < 21; j++){\n\t\t\t\tfor(int k = 0; k < 21; k++){\n\t\t\t\t\tfill(d[i][j][k],d[i][j][k]+21,INF);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfield.clear();\n\t\tdartys.clear();\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfield.push_back(str);\n\t\t\tfor(int j = 0; j < str.size(); j++){\n\t\t\t\tif(str[j] == 'o'){\n\t\t\t\t\tsp.first = i;\n\t\t\t\t\tsp.second = j;\n\t\t\t\t}\n\t\t\t\telse if(str[j] == '*'){\n\t\t\t\t\tdartys.push_back(make_pair(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dartys.size()==0){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// ツ各ツ湘ェツ渉環つゥツづァツ深ツつウツ優ツ静ヲツ探ツ催オツづ、ツつサツづェツつシツづェツづ個湘ェツ渉環づ鳴づ個仰猟猟」ツづーツ仰づ淞づつィツつュ\n\t\tif(bfs(sp.first,sp.second) != dartys.size()){\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n//\t\tbool fff = false;\n\t\tfor(int i = 0; i < dartys.size(); i++){\n\t\t\tbfs(dartys[i].first,dartys[i].second);\n\t\t}\n\n\t\t// ツ渉嘉アツセツーツδ仰スツマツδ督姪「ツ妥ィツづーツ嘉ーツつュ\n\t\tcout << dfs(0,make_pair(sp.first,sp.second)) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nint main(){\n\tint w,h;\n\t\twhile(cin >> w >> h&&w!=0){\n\t\tvector<string>v(h);\n\t\trep(i,h){\n\t\t\tcin >> v[i];\n\t\t}\n\t\tvector<int> p;\n\t\tint s;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(v[i][j]=='o'){\n\t\t\t\t\ts = i*w+j;\n\t\t\t\t\tv[i][j] = '.';\n\t\t\t\t}\n\t\t\t\tif(v[i][j]=='*'){\n\t\t\t\t\tp.PB(i*w+j);\n\t\t\t\t\tv[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<long long> > d(h*w,vector<long long>(h*w,inf));\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(i!=0){\n\t\t\t\t\tif(v[i][j]=='.'&&v[i-1][j]=='.'){\n\t\t\t\t\t\td[i*w+j][(i-1)*w+j]=1;\n\t\t\t\t\t\td[(i-1)*w+j][i*w+j]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i!=h-1){\n\t\t\t\t\tif(v[i][j]=='.'&&v[i+1][j]=='.'){\n\t\t\t\t\t\td[i*w+j][(i+1)*w+j]=1;\n\t\t\t\t\t\td[(i+1)*w+j][i*w+j]=1;\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(j!=0){\n\t\t\t\t\tif(v[i][j]=='.'&&v[i][j-1]=='.'){\n\t\t\t\t\t\td[i*w+j][i*w+j-1]=1;\n\t\t\t\t\t\td[i*w+j-1][i*w+j]=1;\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(j!=w-1){\n\t\t\t\t\tif(v[i][j]=='.'&&v[i][j+1]=='.'){\n\t\t\t\t\t\td[i*w+j][i*w+j+1]=1;\n\t\t\t\t\t\td[i*w+j+1][i*w+j]=1;\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(k,h*w){\n\t\t\trep(i,h*w){\n\t\t\t\trep(j,h*w){\n\t\t\t\t\td[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = inf+inf;\n\t\tdo{\n\t\t\tll tmp=0;\n\t\t\ttmp += d[s][p[0]];\n\t\t\tfor(int i=0;i<p.size()-1;i++){\n\t\t\t\ttmp += d[p[i]][p[i+1]];\n\t\t\t}\n\t\t\tans = min(ans,tmp);\n\t\t}while(next_permutation(p.begin(),p.end()));\n\t\tif(ans>=inf)cout << -1 << endl;\n\t\telse cout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\n#define int i64\n\nint w,h;\n\nsigned main(){\n\twhile(cin >> w >> h,w || h){\n\t\tvector<vector<int>> fie(h,vector<int>(w,0));\n\t\tvector<P> dust;\n\t\tint sx,sy;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tstring s;\n\t\t\tcin>> s;\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(s[j] == '*'){\n\t\t\t\t\tdust.push_back({i,j});\n\t\t\t\t\tfie[i][j] = dust.size();\n\t\t\t\t}\n\t\t\t\tif(s[j] == 'x'){\n\t\t\t\t\tfie[i][j] = -1;\n\t\t\t\t}\n\t\t\t\tif(s[j] == 'o'){\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusing P2 = pair<int,P>;\n\t\tvector<vector<int>> dist(dust.size(),vector<int>(dust.size() , 1e9));\n\n\t\tint dx[] = {1,-1,0,0};\n\t\tint dy[] = {0,0,1,-1};\n\n\t\tfor(int s = 0;s < dust.size();s++){\n\t\t\tqueue<P2> que;\n\t\t\tque.push({0,dust[s]});\n\t\t\tvector<vector<int>> vis(h,vector<int>(w,0));\n\t\t\tvis[dust[s].first][dust[s].second] = 1;\n\t\t\twhile(!que.empty()){\n\t\t\t\tint d = que.front().first;\n\t\t\t\tP p = que.front().second;\n\t\t\t\tif(fie[p.first][p.second] > 0){\n\t\t\t\t\tdist[s][fie[p.first][p.second] - 1] = d;\n\t\t\t\t}\n\t\t\t\tque.pop();\n\t\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\t\tint nx = p.first + dx[i];\n\t\t\t\t\tint ny = p.second + dy[i];\n\t\t\t\t\tif(0 <= nx && nx < h && 0 <= ny && ny < w && fie[p.first][p.second] != -1 && vis[nx][ny] == 0){\n\t\t\t\t\t\tvis[nx][ny] = 1;\n\t\t\t\t\t\tque.push({d + 1,{nx,ny}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint dp[1 << dust.size()];\n\t\tfill(dp , dp + (1 << dust.size()),1e9);\n\t\t{\n\t\t\tqueue<P2> que;\n\t\t\tque.push({0,{sx,sy}});\n\t\t\tvector<vector<int>> vis(h,vector<int>(w,0));\n\t\t\tvis[sx][sy] = 0;\n\t\t\twhile(!que.empty()){\n\t\t\t\tint d = que.front().first;\n\t\t\t\tP p = que.front().second;\n\t\t\t\tif(fie[p.first][p.second] > 0){\n\t\t\t\t\tdp[(1 << (fie[p.first][p.second] - 1))] = d;\n\t\t\t\t}\n\t\t\t\tque.pop();\n\t\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\t\tint nx = p.first + dx[i];\n\t\t\t\t\tint ny = p.second + dy[i];\n\t\t\t\t\tif(0 <= nx && nx < h && 0 <= ny && ny < w && fie[p.first][p.second] != -1 && vis[nx][ny] == 0){\n\t\t\t\t\t\tvis[nx][ny] = 1;\n\t\t\t\t\t\tque.push({d + 1,{nx,ny}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1;i < (1 << dust.size());i++){\n\t\t\tif(__builtin_popcount(i) == 1) continue;\n\t\t\tfor(int j = 0;j < dust.size();j++){\n\t\t\t\tfor(int k = 0;k < dust.size();k++){\n\t\t\t\t\tif(j == k) continue;\n\t\t\t\t\tif(i & (1 << j) && i & (1 << k)){\n\t\t\t\t\t\t//j <- k\n\t\t\t\t\t\tint s = i & ~(1 << j);\n\t\t\t\t\t\tdp[i] = min(dp[i] , dp[s] + dist[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dp[(1 << dust.size()) - 1] >= 1e9){\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << dp[(1 << dust.size()) - 1] << endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int, int>;\n\nconstexpr int INF = 1e9;\nconstexpr int dx[4] = {0, 1, 0, -1};\nconstexpr int dy[4] = {1, 0, -1, 0};\n\nvector<vector<int>> bfs(P p, vector<string> const& v) {\n    const int H = v.size();\n    const int W = v[0].size();\n    vector<vector<int>> d(H, vector<int>(W, INF));\n    d[p.first][p.second] = 0;\n    queue<P> que;\n    que.push(p);\n    while(!que.empty()) {\n        P p = que.front();\n        que.pop();\n        for(int i=0; i<4; ++i) {\n            int ny = p.first + dy[i], nx = p.second + dx[i];\n            if(ny < 0 || H <= ny || nx < 0 || W <= nx || v[ny][nx] == 'x' || d[ny][nx] != INF) {\n                continue;\n            }\n            d[ny][nx] = d[p.first][p.second] + 1;\n            que.push(make_pair(ny, nx));\n        }\n    }\n    return d;\n}\n\nint main() {\n    int w, h;\n    while(cin >> w >> h, w) {\n        vector<string> v(h);\n        int sy, sx;\n        vector<P> dirty;\n        for(int i=0; i<h; ++i) {\n            cin >> v[i];\n            for(int j=0; j<w; ++j) {\n                if(v[i][j] == '*') {\n                    dirty.emplace_back(i, j);\n                }\n                if(v[i][j] == 'o') {\n                    sy = i;\n                    sx = j;\n                }\n            }\n        }\n        vector<vector<vector<vector<int>>>> d(h, vector<vector<vector<int>>>(w));\n        for(int i=0; i<h; ++i) {\n            for(int j=0; j<w; ++j) {\n                d[i][j] = bfs(make_pair(i, j), v);\n            }\n        }\n        sort(dirty.begin(), dirty.end());\n        int res = INF;\n        do {\n            int t = 0;\n            if(d[sy][sx][dirty[0].first][dirty[0].second] == INF) {\n                continue;\n            }\n            t += d[sy][sx][dirty[0].first][dirty[0].second];\n            for(int i=0; i<dirty.size()-1; ++i) {\n                if(d[dirty[i].first][dirty[i].second][dirty[i+1].first][dirty[i+1].second] == INF) {\n                    t = INF;\n                    break;\n                } else {\n                    t += d[dirty[i].first][dirty[i].second][dirty[i+1].first][dirty[i+1].second];\n                }\n            }\n            res = min(res, t);\n        } while(next_permutation(dirty.begin(), dirty.end()));\n\n        if(res == INF) {\n            cout << -1 << endl;\n        } else {\n            cout << res << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 21\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h,G[N][N];\nstring mp[N];\nmap<P,int>M;\n\nvoid bfs(P s){\n  int D[N][N];\n  memset(D,-1,sizeof(D));\n  queue<P> Q;\n  Q.push(s);\n  int x=s.first,y=s.second;\n  D[y][x]=0;\n  while(!Q.empty()){\n    P t=Q.front();Q.pop();\n    x=t.first,y=t.second;\n    if(mp[y][x]=='*'||mp[y][x]=='o') G[M[s]][M[t]]=D[y][x];\n\n    int dx[]={0,0,-1,1},dy[]={1,-1,0,0};\n    for(int i=0;i<4;i++){\n      int nx=x+dx[i],ny=y+dy[i],cost=D[y][x]+1;\n      if(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx]=='x'||D[ny][nx]!=-1)continue;\n      Q.push(P(nx,ny));\n      D[ny][nx]=cost;\n    }\n  }\n}\n\nint n,num[11];\nP start;\nint calc(){\n  int res=0;\n  for(int i=1;i<n;i++)res+=G[num[i-1]][num[i]];\n  return res;  \n}\n\nint dfs(int idx){\n  if(idx==M[start]) return dfs(idx+1);\n  if(idx==n) return calc();\n  int res=1e9;\n  for(int i=0;i<n;i++){\n    if(num[i]!=-1)continue;\n    num[i]=idx;\n    res=min(res,dfs(idx+1));\n    num[i]=-1;\n  }\n  return res;\n}\n\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h)break;\n    for(int i=0;i<h;i++) cin>>mp[i];\n    M.clear();\n    memset(G,-1,sizeof(G));\n    memset(num,-1,sizeof(num));\n    n=0;\n    vector<P> p;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tP t=P(j,i);\n\tif(mp[i][j]=='*'||mp[i][j]=='o') p.push_back(t),M[t]=n++;\n\tif(mp[i][j]=='o') start=t;\n      }\n    for(int i=0;i<n;i++)bfs(p[i]);\n\n    bool flg=1;\n    for(int i=0;i<n;i++)if(G[0][i]==-1)flg=0;\n    num[0]=M[start];\n    cout <<(flg?dfs(0):-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdlib>\n\nusing namespace std;\n\nstruct Point {\n  int x, y;\n  Point(int x, int y) : x(x), y(y) {;}\n};\n\ntypedef pair<int, Point> State;\n\nint W, H, C, INF = (1 << 22);\nvector<Point> pos;\nchar field[20][20];\nint  dist[11][11];\nint dx[4] = {0, 1, 0, -1},\n    dy[4] = {-1, 0, 1, 0};\nint dp[1 << 11][11];\n\nvoid bfs(int src)\n{\n  int d[20][20];\n  for (int i = 0; i < H; i++)\n    for (int j = 0; j < W; j++)\n      d[i][j] = INF;\n\n  Point start = pos[src];\n\n  queue<State> que;\n  que.push(State(0, start));\n\n  while (!que.empty()) {\n    State s = que.front(); que.pop();\n    Point p = s.second;\n    if (d[p.y][p.x] != INF) continue;\n\n    d[p.y][p.x] = s.first; \n    for (int k = 0; k < 4; k++) {\n      int nx = p.x + dx[k], ny = p.y + dy[k];\n      if (nx >= 0 && nx < W && ny >= 0 && ny < H && field[ny][nx] != 'x') {\n        que.push(State(s.first + 1, Point(nx, ny)));\n      }\n    }\n  }\n\n  for (int dst = 0; dst < C; dst++) \n    if (dst != src) \n      dist[src][dst] = d[pos[dst].y][pos[dst].x];\n}\n\nint rec(int S, int v)\n{\n  // 訪問済み\n  if (dp[S][v] >= 0) \n    return dp[S][v];\n\n  // すべての頂点を訪れて戻ってきた\n  if (S == (1 << C) - 1) {\n    return dp[S][v] = 0;\n  }\n\n  int res = INF;\n  for (int u = 0; u < C; u++) {\n    if (!(S >> u & 1)) {\n      // uが未訪問なので、uへ移動\n      res = min(res, rec(S | 1 << u, u) + dist[v][u]);\n    }\n  }\n\n  return dp[S][v] = res;\n}\n\nvoid solve()\n{\n  \n  // 距離テーブルの初期化\n  for (int i = 0; i < C; i++) \n    for (int j = 0; j < C; j++) \n      if (i == j) \n        dist[i][j] = 0;\n      else \n        dist[i][j] = INF;\n\n  // 全点間の距離を求める\n  for (int src = 0; src < C; src++) \n    bfs(src);\n\n  // TSP\n  memset(dp, -1, sizeof(dp));\n  int res = rec(0, 0);\n  if (res >= INF) \n    cout << -1 << endl;\n  else\n    cout << res << endl;\n}\n\nint main()\n{\n  while (cin >> W >> H && (W && H)) {\n\n    // スタート+汚れたタイルの数\n    C = 1;\n    pos.clear();\n    pos.push_back(Point(-1, -1));\n    // read\n    for (int i = 0; i < H; i++) {\n      for (int j = 0; j < W; j++) {\n        cin >> field[i][j];\n        if (field[i][j] == '*') {\n          pos.push_back(Point(j, i));\n          C++;\n        } else if (field[i][j] == 'o') {\n          pos[0].x = j;\n          pos[0].y = i;\n        }\n      }\n    }\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nstruct Point {\n  int x, y;\n  Point(int x, int y) : x(x), y(y) {;}\n};\n\ntypedef pair<int, Point> State;\n\nint W, H, C, INF = (1 << 22);\nvector<Point> pos;\nchar field[20][20];\nint  dist[11][11];\nint dx[4] = {0, 1, 0, -1},\n    dy[4] = {-1, 0, 1, 0};\nint dp[1 << 11][11];\n\nvoid bfs(int src)\n{\n  int d[20][20];\n  for (int i = 0; i < H; i++)\n    for (int j = 0; j < W; j++)\n      d[i][j] = INF;\n\n  Point start = pos[src];\n\n  queue<State> que;\n  que.push(State(0, start));\n\n  while (!que.empty()) {\n    State s = que.front(); que.pop();\n    Point p = s.second;\n    if (d[p.y][p.x] != INF) continue;\n\n    d[p.y][p.x] = s.first; \n    for (int k = 0; k < 4; k++) {\n      int nx = p.x + dx[k], ny = p.y + dy[k];\n      if (nx >= 0 && nx < W && ny >= 0 && ny < H && field[ny][nx] != 'x') {\n        que.push(State(s.first + 1, Point(nx, ny)));\n      }\n    }\n  }\n\n  for (int dst = 0; dst < C; dst++) \n    if (dst != src) \n      dist[src][dst] = d[pos[dst].y][pos[dst].x];\n}\n\nint rec(int S, int v)\n{\n  // 訪問済み\n  if (dp[S][v] >= 0) \n    return dp[S][v];\n\n  // すべての頂点を訪れて戻ってきた\n  if (S == (1 << C) - 1) {\n    return dp[S][v] = 0;\n  }\n\n  int res = INF;\n  for (int u = 0; u < C; u++) {\n    if (!(S >> u & 1)) {\n      // uが未訪問なので、uへ移動\n      res = min(res, rec(S | 1 << u, u) + dist[v][u]);\n    }\n  }\n\n  return dp[S][v] = res;\n}\n\nvoid solve()\n{\n  \n  // 距離テーブルの初期化\n  for (int i = 0; i < C; i++) \n    for (int j = 0; j < C; j++) \n      if (i == j) \n        dist[i][j] = 0;\n      else \n        dist[i][j] = INF;\n\n  // 全点間の距離を求める\n  for (int src = 0; src < C; src++) \n    bfs(src);\n\n  // TSP\n  memset(dp, -1, sizeof(dp));\n  int res = rec(0, 0);\n  if (res >= INF) \n    cout << -1 << endl;\n  else\n    cout << res << endl;\n}\n\nint main()\n{\n  while (cin >> W >> H && (W && H)) {\n\n    // スタート+汚れたタイルの数\n    C = 1;\n    pos.clear();\n    pos.push_back(Point(-1, -1));\n    // read\n    for (int i = 0; i < H; i++) {\n      for (int j = 0; j < W; j++) {\n        cin >> field[i][j];\n        if (field[i][j] == '*') {\n          pos.push_back(Point(j, i));\n          C++;\n        } else if (field[i][j] == 'o') {\n          pos[0].x = j;\n          pos[0].y = i;\n        }\n      }\n    }\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define REP(i,n) for(long long i = 0;i < n;++i)    \n#define seg_size 524288\nlong long dijk[21][21][1 << 11] = {};\nint visited[21][21][1 << 11] = {};\nint main() {\n\twhile (true) {\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif (w == 0) return 0;\n\t\tint grid[20][20] = {};\n\t\tint now_cnt = 1;\n\t\tREP(i, 21) {\n\t\t\tREP(q, 21) {\n\t\t\t\tREP(j, 1 << 11) {\n\t\t\t\t\tdijk[i][q][j] = LONG_INF;\n\t\t\t\t\tvisited[i][q][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<tuple<long long, int, int, int>> next;\n\t\tREP(i, h) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tREP(q, s.length()) {\n\t\t\t\tif (s[q] == 'o') {\n\t\t\t\t\tdijk[i][q][0] = 0;\n\t\t\t\t\tnext.push(make_tuple(-0, i, q, 0));\n\t\t\t\t}\n\t\t\t\telse if (s[q] == 'x') {\n\t\t\t\t\tgrid[i][q] = -1;\n\t\t\t\t}\n\t\t\t\telse if (s[q] == '*') {\n\t\t\t\t\tgrid[i][q] = now_cnt;\n\t\t\t\t\tnow_cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (next.empty() == false) {\n\t\t\ttuple<long long, int, int, int> now = next.top();\n\t\t\tnext.pop();\n\t\t\tint now_x = get<1>(now);\n\t\t\tint now_y = get<2>(now);\n\t\t\tint now_cleaned = get<3>(now);\n\t\t\tif (visited[now_x][now_y][now_cleaned] == 1) continue;\n\t\t\tvisited[now_x][now_y][now_cleaned] = 1;\n\t\t\tint xe[4] = { 1,-1,0,0 };\n\t\t\tint ye[4] = { 0,0,1,-1 };\n\t\t\tREP(q, 4) {\n\t\t\t\tint next_x = xe[q] + now_x;\n\t\t\t\tint next_y = ye[q] + now_y;\n\t\t\t\tif (next_x >= 0 && next_x < h && next_y >= 0 && next_y < w) {\n\t\t\t\t\tif (grid[next_x][next_y] == -1) continue;\n\t\t\t\t\tint next_taken = now_cleaned;\n\t\t\t\t\tif (grid[next_x][next_y] != 0) {\n\t\t\t\t\t\tnext_taken |= (1 << (grid[next_x][next_y] - 1));\n\t\t\t\t\t}\n\t\t\t\t\tint next_cost = -get<0>(now) + 1;\n\t\t\t\t\tif (dijk[next_x][next_y][next_taken] > next_cost) {\n\t\t\t\t\t\tdijk[next_x][next_y][next_taken] = next_cost;\n\t\t\t\t\t\tnext.push(make_tuple(-next_cost, next_x, next_y, next_taken));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnow_cnt--;\n\t\tlong long ans = LONG_INF;\n\t\tREP(i, h) {\n\t\t\tREP(q, w) {\n\t\t\t\tans = min(ans, dijk[i][q][(1 << now_cnt) - 1]);\n\t\t\t}\n\t\t}\n\t\tif (ans == LONG_INF) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define all(c) (c).begin(), (c).end()\nconst int inf = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\n\nint w, h;\n\ninline bool inrect(int x, int y){\n    return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nint solve(vector<string>& c){\n    vector<int> xs, ys;\n    rep(i, h)rep(j, w){\n        if(c[i][j] == 'o')xs.insert(xs.begin(), i), ys.insert(ys.begin(), j);\n        if(c[i][j] == '*')xs.push_back(i), ys.push_back(j);\n    }\n    int n = (int)xs.size();\n    vector<vector<int> > costs(n, vector<int>(n, inf));\n    rep(i, n){\n        vector<vector<int> > mem(h, vector<int>(w, inf)); mem[xs[i]][ys[i]] = 0;\n        typedef tuple<int, int, int> State;\n        priority_queue<State> q;\n        for(q.emplace(0, xs[i], ys[i]); !q.empty();){\n            int cost, x, y;\n            tie(cost, x, y) = q.top(); q.pop();\n            if(mem[x][y] != -cost)continue;\n            rep(k, 4){\n                int nx = x + dx[k], ny = y + dy[k];\n                if(!inrect(nx, ny) || c[nx][ny] == 'x' || mem[nx][ny] <= 1 - cost)continue;\n                mem[nx][ny] = 1 - cost;\n                q.emplace(-mem[nx][ny], nx, ny);\n            }\n        }\n        rep(j, n)costs[i][j] = mem[xs[j]][ys[j]];\n    }\n    if(find(all(costs[0]), inf) != costs[0].end())return -1;\n    vector<int> mem(1 << n, inf); mem[1 << 0] = 0;\n    typedef tuple<int, int, int> State;\n    priority_queue<State> q;\n    for(q.emplace(0, 1 << 0, 0); !q.empty();){\n        int cost, vis, v;\n        tie(cost, vis, v) = q.top(); q.pop();\n        if(mem[vis] != -cost)continue;\n        if(vis == (1 << n) - 1)return -cost;\n        rep(i, n){\n            if(vis >> i & 1 || mem[vis | 1 << i] <= costs[v][i] - cost)continue;\n            mem[vis | 1 << i] = costs[v][i] - cost;\n            q.emplace(-mem[vis | 1 << i], vis | 1<< i, i);\n        }\n    }\n    return -1;\n}\n\nint main(){\n    while(cin >> w >> h, w|h){\n        vector<string> c(h);\n        rep(i, h)cin >> c[i];\n        cout << solve(c) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<iomanip>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\n#define MAX 1024\n#define N 10\n#define SIZE 22\n\n#define NONE 0\n#define START 1\n#define DIRTY_TILE 2\n#define FURNITURE 3\n\n#define INFTY 1<<29\n\nvoid bfs(int sti, int stj, int map[SIZE][SIZE], int cost_map[SIZE][SIZE]){\n\tconst int di[] = {-1,0,1,0};\n\tconst int dj[] = {0,1,0,-1};\n\tbool vis[SIZE][SIZE]={{false,},};\n\tqueue< pair<int,int> > q;\n\n\tfor(int i = 0; i < SIZE; ++i){\n\t\tfor(int j = 0; j < SIZE; ++j){\n\t\t\tcost_map[i][j] = INFTY;\n\t\t}\n\t}\n\n\tq.push( make_pair(sti,stj) );\n\tcost_map[sti][stj]=0;\n\tvis[sti][stj]=true;\n\twhile(!q.empty()){\n\t\tpair<int,int> t = q.front();\n\t\tq.pop();\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\tint ti = t.first + di[k];\n\t\t\tint tj = t.second + dj[k];\n\t\t\tif( map[ti][tj] != FURNITURE && !vis[ti][tj] ){\n\t\t\t\tcost_map[ti][tj] = cost_map[t.first][t.second] + 1;\n\t\t\t\tvis[ti][tj]=true;\n\t\t\t\tq.push( make_pair(ti,tj) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dp(int n, int ini_cost[N], int cost[N][N] ){\n\tint w[MAX];\n\tint prev[MAX];\n\tw[0]=0;\n\tfor(int state=1;state<(1<<n);++state){\n\t\tw[state]=INFTY;\n\t}\n\tfor(int state=1;state<(1<<n);++state){\n\t\tfor(int i=0;i<n;++i){\n\t\t\tif(state&(1<<i)){\n\t\t\t\tint t;\n\t\t\t\tint pre_state=state^(1<<i);\n\t\t\t\t\n\t\t\t\tif( pre_state == 0 )\n\t\t\t\t\tt = w[pre_state]+ini_cost[i];\n\t\t\t\telse\n\t\t\t\t\tt = w[pre_state]+cost[prev[pre_state]][i];\n\n\t\t\t\tif( w[state]>t ){\n\t\t\t\t\tw[state]=t;\n\t\t\t\t\tprev[state]=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn w[(1<<n)-1];\n}\n\nint CleaningRobot(int h, int w, int map[SIZE][SIZE]){\n\tint cost[N][N];\n\tint ini_cost[N];\n\tint cost_map[SIZE][SIZE];\n\tvector< pair<int, int> > vtiles;\n\n\tfor(int i = 1; i <= h; ++i){\n\t\tfor(int j = 1; j <= w; ++j){\n\t\t\tif( map[i][j] == DIRTY_TILE ){\n\t\t\t\tvtiles.push_back( make_pair( i, j ) );\n\t\t\t}\n\t\t\tif( map[i][j] == START ){\n\t\t\t\tbfs(i,j,map,cost_map);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(unsigned int i = 0; i < vtiles.size(); ++i){\n\t\tini_cost[i]=cost_map[vtiles[i].first][vtiles[i].second];\n\t}\n\n\tfor(unsigned int i = 0; i < vtiles.size(); ++i){\n\t\tbfs(vtiles[i].first,vtiles[i].second,map,cost_map);\n\t\t\n\t\t/*for(int k = 1; k <= h; ++k){\n\t\t\tfor(int l = 1; l <= w; ++l){\n\t\t\t\tcout << setw(4) << cost_map[k][l];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\n\t\tfor(unsigned int j = 0; j < vtiles.size(); ++j){\n\t\t\tcost[i][j] = cost[j][i] = cost_map[vtiles[j].first][vtiles[j].second];\n\t\t}\n\t}\n\n\tint ret = dp(vtiles.size(),ini_cost,cost);\n\treturn ret>=INFTY?-1:ret;\n}\n\nint main(){\n\twhile(true){\n\t\tint h,w;\n\t\tint map[SIZE][SIZE];\n\t\tcin>>w>>h;\n\t\tif(h==0&&w==0)break;\n\t\tfor(int i=0;i<SIZE;++i){\n\t\t\tfor(int j=0;j<SIZE;++j){\n\t\t\t\tmap[i][j]=FURNITURE;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=h;++i){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tfor(unsigned int j=0;j<s.length();++j){\n\t\t\t\tswitch(s[j]){\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tmap[i][j+1]=NONE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'x':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'o':\n\t\t\t\t\t\tmap[i][j+1]=START;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\tmap[i][j+1]=DIRTY_TILE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << CleaningRobot(h,w,map) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define MAX 12\n#define mk make_pair\n#define INF 1<<28\nstring s[20];\nbool vis[20][20];\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint n,w,h,d[MAX][MAX],c;\nint dp[1<<MAX][MAX];\nint rec(int s,int v){\n  if(dp[s][v]>=0)return dp[s][v];\n  if(s==(1<<n)-1&&v!=0)return dp[s][v]=0;\n  int res=INF;\n  for(int u=0;u<n;u++) \n    if(!(s>>u&1))\n      res=min(res,rec(s|1<<u,u)+d[v][u]);\n  return dp[s][v]=res;\n}\nvoid bfs(int x2,int y2,int k){\n  r(i,20)r(j,20)vis[i][j]=0;\n  queue<pair<pair<int,int>,int> > q;\n  vis[x2][y2]=1;\n  q.push(mk(mk(x2,y2),0));\n  while(!q.empty()){\n    pair<pair<int,int>,int>p=q.front();q.pop();\n    int p1=p.first.first,p2=p.first.second,p3=p.second;\n    r(i,4){\n      int x=dx[i]+p1;\n      int y=dy[i]+p2;\n      if(x>=0&&x<w&&y>=0&&y<h)\n        if(!vis[x][y]&&(s[y][x]!='x')){\n          if(0<=s[y][x]&&s[y][x]<12)\n            d[k][(int)s[y][x]]=p3+1;\n          else if(k!=0&&s[y][x]=='o')\n            d[k][0]=p3+1;\n          q.push(mk(mk(x,y),p3+1));\n          vis[x][y]=1;\n        }\n    }\n  }\n}\nint main(){\n  while(cin>>w>>h,w){c=1;\n    int a,b;\n    vector<pair<int,int> >v;\n    r(i,h)cin>>s[i];\n    r(j,w)r(i,h)if(s[i][j]=='*')s[i][j]=c++,v.push_back(make_pair(j,i));\n  memset(dp,-1,sizeof(dp));\n  n=c;\n  r(i,MAX)r(j,MAX)d[i][j]=INF;\n  r(j,w)r(i,h)if(s[i][j]=='o')a=j,b=i;\n  bfs(a,b,0);\n  r(i,c-1)bfs(v[i].first,v[i].second,i+1);\n  int p=rec(1,0);\n  if(p==INF)p=-1;\n  cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n#include <utility>\n#define INF 0x3FFFFFFF\n\nusing namespace std;\n\n\nint main(void){\n\tint n, h, w, i, j, k, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0}, s[11][20][20], d[11][11], a, b, dp[11][1 << 10], min;\n\tpair<int,int> l[11];\n\tqueue<pair<int,int> > que;\n\tchar field[20][21];\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tn = 1;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tfield[i][j] = getchar();\n\t\t\t\tif(field[i][j] == '*') l[n].first = j,l[n++].second = i, field[i][j] = '.';\n\t\t\t\telse if(field[i][j] == 'o') l[0].first = j, l[0].second = i, field[i][j] = '.';\n\t\t\t}\n\t\t\tgetchar();\n\t\t}\n\t\tmemset(s,-1,sizeof(s));\n\t\tfor(i = 0;i < n;i++){\n\t\t\tque.push(l[i]);\n\t\t\ts[i][que.front().second][que.front().first] = 0;\n\t\t\twhile(que.size()){\n\t\t\t\ta = que.front().first, b = que.front().second;\n\t\t\t\tfor(j = 0;j < 4;j++){\n\t\t\t\t\tif(a + dx[j] >= 0 && a + dx[j] < w && b + dy[j] >= 0 && b + dy[j] < h && field[b + dy[j]][a + dx[j]] == '.' && s[i][b + dy[j]][a + dx[j]] == -1){\n\t\t\t\t\t\tque.push(pair<int,int>(a + dx[j],b + dy[j]));\n\t\t\t\t\t\ts[i][b + dy[j]][a + dx[j]] = s[i][b][a] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tque.pop();\n\t\t\t}\n\t\t}\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 1;j < n;j++){\n\t\t\t\td[i][j] = s[i][l[j].second][l[j].first];\n\t\t\t\tif(i != 0){\n\t\t\t\t\td[j][i] = s[i][l[j].second][l[j].first];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 1;j < n;j++) if(d[i][j] == -1) break;\n\t\t\tif(j != n) break;\n\t\t}\n\t\tif(i != n){\n\t\t\tprintf(\"-1\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor(i = 0;i < 1 << (n - 1);i++)\n\t\t\tfor(j = 0;j < n;j++) dp[j][i] = INF;\n\t\tdp[0][0] = 0;\n\t\tfor(i = 0;i < 1 << (n - 1);i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tfor(k = 1;k < n;k++){\n\t\t\t\t\tif(~i & (1 << (k - 1)) && dp[k][i | (1 << (k - 1))] > dp[j][i] + d[j][k])\n\t\t\t\t\t\tdp[k][i | (1 << (k - 1))] = dp[j][i] + d[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmin = INF;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tif(min > dp[i][(1 << (n - 1)) - 1]) min = dp[i][(1 << (n - 1)) - 1];\n\t\tprintf(\"%d\\n\",min >= INF - 0x2000000 ? -1 : min);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<vector>\n#include<cstring>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nint w,h;\nstring c[22];\nint dis[22][22];\nint t[20][1<<11];\n\nint main(){\n  while(cin >> w >> h, w){\n    for(int i=0;i<h;i++)cin >> c[i];\n\n    vector<pii> gomi;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(c[i][j] == 'o')gomi.push_back(pii(i,j));\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(c[i][j] == '*')gomi.push_back(pii(i,j));\n      }\n    }\n    int num = gomi.size();\n    vector<pii> g[22];\n\n    for(int i=0;i<num;i++){\n      queue<pii> q;\n      q.push(gomi[i]);\n      memset(dis,-1,sizeof(dis));\n      dis[gomi[i].first][gomi[i].second] = 0;\n\n      while(q.size()){\n\tpii p = q.front(); q.pop();\n\tint y = p.first, x = p.second;\n\n\tfor(int d=0;d<4;d++){\n\t  int ny = y+dy[d], nx = x+dx[d];\n\t  if(ny<0 || nx<0 || ny>=h || nx>=w || c[ny][nx] == 'x')continue;\n\t  if(dis[ny][nx]<0){\n\t    dis[ny][nx] = dis[y][x] + 1;\n\t    q.push(pii(ny,nx));\n\t  }\n\t}\n      }\n\n      for(int j=0;j<num;j++){\n\tif(i==j)continue;\n\tif(dis[gomi[j].first][gomi[j].second]<0)continue;\n\tg[i].push_back(pii(dis[gomi[j].first][gomi[j].second],j));\n      }\n    }\n\n    memset(t,-1,sizeof(t));\n    t[0][1] = 0;\n\n    for(int bit=0;bit<(1<<num);bit++){\n      for(int v=0;v<num;v++){\n\tif(t[v][bit]<0)continue;\n\tfor(int i=0;i<(int)g[v].size();i++){\n\t  int u = g[v][i].second, cost = t[v][bit] + g[v][i].first;\n\t  if( (bit>>u) & 1)continue;\n\t  int nb = bit|(1<<u);\n\t  if(t[u][nb]<0 || t[u][nb]>cost)t[u][nb] = cost;\n\t}\n      }\n    }\n\n    int ans = 1e8;\n    for(int i=0;i<num;i++){\n      if(t[i][(1<<num)-1]<0)continue;\n      ans = min(ans, t[i][(1<<num)-1]);\n    }\n    if(ans==1e8)cout << -1 << endl;\n    else cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\n#define REP(i,a,b) for(i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\n#define ll long long\n#define ull unsigned ll\ntypedef long double ld;\n#define ALL(a) (a).begin(),(a).end()\n#define ifnot(a) if(not a)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\nusing namespace std;\n\nvoid reader(int &a) { scanf(\"%d\", &a); }\nvoid reader(double &a) { scanf(\"%lf\", &a); }\nvoid reader(char a[]) { scanf(\"%s\", a); }\nvoid reader(char &a) { scanf(\" %c\", &a); }\nvoid reader(ll &a) { scanf(\"%lld\", &a); }\nvoid reader(ull &a) { scanf(\"%llu\", &a); }\n// void reader(string& a){cin >> a;};\ntemplate<class T, class U> void reader(T& t, U& u) { reader(t); reader(u); }\ntemplate<class T, class U, class V> void reader(T& t, U& u, V& v) { reader(t); reader(u); reader(v); }\n\nvoid writer(const int a, char c) { printf(\"%d\", a); putchar(c); }\nvoid writer(const ll a, char c) { printf(\"%lld\", a); putchar(c); }\nvoid writer(const ull a, char c) { printf(\"%llu\", a); putchar(c); }\nvoid writer(const double a, char c) { printf(\"%.20lf\", a); putchar(c); }\nvoid writer(const char a[]) { printf(\"%s\", a); };\nvoid writer(const char a[], char c) { printf(\"%s\", a); putchar(c); };\nvoid writer(const char a, char c) { putchar(a); putchar(c); };\ntemplate<class T> void writerLn(T t) { writer(t, '\\n'); }\ntemplate<class T, class U> void writerLn(T t, U u) { writer(t, ' '); writer(u, '\\n'); }\ntemplate<class T, class U, class V> void writerLn(T t, U u, V v) { writer(t, ' '); writer(u, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerVec(vector<T> x) { int n = x.size(); int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\n\nvector<string> split(const string &str, char sep) { vector<string> v; stringstream ss(str); string buffer; while (getline(ss, buffer, sep)) { v.push_back(buffer); }return v; }\n// #define int ll\nbool test = 0;\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n#define INF (1 << 28)\null mod = (int)1e9 + 7;\n//.....................\n#define MAX 22\n\n\n\nstruct Node {\n\tint y, x;\n};\nint w, h;\nchar c[MAX][MAX];\nint dm[MAX][MAX];\nvector<Node> nodes;\nint start;\nbool create_distace_matrix() {\n\tint i, j, k;\n\tint y, x;\n\tint cf[MAX][MAX];\n\trep(i, nodes.size()) {\n\t\trep(y, h) rep(x, w) {\n\t\t\tif (c[y][x] == 'x') cf[y][x] = -2;\n\t\t\telse cf[y][x] = -1;\n\t\t}\n\n\t\tcf[nodes[i].y][nodes[i].x] = 0;\n\t\tbool changed = true;\n\t\tint current = 0;\n\t\tfor (; changed; current += 1) {\n\t\t\tchanged = false;\n\t\t\trep(y, h) rep(x, w) {\n\t\t\t\tif (cf[y][x] == current) {\n\t\t\t\t\trep(j, 4) {\n\t\t\t\t\t\tint ny = y + dy[j];\n\t\t\t\t\t\tint nx = x + dx[j];\n\t\t\t\t\t\tif (ny < 0 || h <= ny) continue;\n\t\t\t\t\t\tif (nx < 0 || w <= nx) continue;\n\t\t\t\t\t\tif (cf[ny][nx] == -1) cf[ny][nx] = current + 1;\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(j, nodes.size()) {\n\t\t\tint distance = cf[nodes[j].y][nodes[j].x];\n\t\t\tif (distance < 0) return false;\n\t\t\tdm[i][j] = distance;\n\t\t}\n\t}\n\treturn true;\n}\nbool done[MAX];\nint ans;\nvoid rec(int n, int idx, int sum) {\n\tint i;\n\tif (sum >= ans) return;\n\tif (n == nodes.size()) {\n\t\tif (sum < ans) ans = sum;\n\t\treturn;\n\t}\n\trep(i, nodes.size()) {\n\t\tif (done[i]) continue;\n\t\tdone[i] = true;\n\t\trec(n + 1, i, sum + dm[idx][i]);\n\t\tdone[i] = false;\n\t}\n}\nsigned main(void)\n{\n\tint i, j, k, l;\n\twhile (1) {\n\t\tcin >> w >> h;\n\t\tif (w == 0) return 0;\n\t\trep(i, h) reader(c[i]);\n\t\tnodes.clear();\n\t\trep(i, h) rep(j, w) {\n\t\t\tif (c[i][j] == 'o') start = nodes.size();\n\t\t\tif (c[i][j] == 'o' || c[i][j] == '*') {\n\t\t\t\tnodes.push_back({ i,j });\n\t\t\t}\n\t\t}\n\t\tif (!create_distace_matrix()) {\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tans = INT_MAX;\n\t\tdone[start] = true;\n\t\trec(1, start, 0);\n\t\tcout << ans << endl;\n\t\tdone[start] = false;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int MAX_W = 20;\nconst int MAX_H = 20;\nconst int MAX_N = 10;\nconst int INF  = 1e+8;\n\nint w, h;\nint dx[4] = {0,0,1,-1};\nint dy[4] = {1,-1,0,0};\nint d[MAX_H][MAX_W];\nint g[MAX_N][MAX_N];\n\nvoid debug(int n){\n\tcout << \"[debug]\" << endl;\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\tif( g[i][j] == INF )\n\t\t\t\tcout << -1 << \"  \";\n\t\t\telse\n\t\t\t\tcout << g[i][j] << \"  \";\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\nvoid init(){\n\tfor(int i = 0 ; i < MAX_N ; i++ ){\n\t\tfor(int j = 0 ; j < MAX_N ; j++ ){\n\t\t\tg[i][j] = INF;\n\t\t}\n\t}\n}\n\nvoid clear_d(){\n\tfor(int y=0 ; y < MAX_H ; y++ ){\n\t\tfor(int x= 0 ; x < MAX_W ; x++ ){\n\t\t\td[y][x] = INF;\n\t\t}\n\t}\n}\n\n// 文字 c がある座標の位置を求める\nvoid search(const vector<string>& m, vector<P>& vp, char c){\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( m[y][x] == c ){\n\t\t\t\tvp.push_back( P(x,y) );\n\t\t\t}\n\t\t}\n\t}\n}\n\n// spから汚れたタイルまでの距離を調べる\nvoid bfs(const vector<string>& m, P sp, map<P,int> f){\n\td[sp.second][sp.first] = 0;\n\tqueue<P> q;\n\tq.push( sp );\n\twhile( !q.empty() ){\n\t\tP p = q.front(); q.pop();\n\t\tint cnt = d[p.second][p.first];\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx = p.first + dx[i];\n\t\t\tint my = p.second + dy[i];\n\t\t\tif( mx < 0 || my < 0 || mx >= w || my >= h || m[my][mx] == 'x' ){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( d[my][mx] == INF ){\n\t\t\t\tif( m[my][mx] == '*' ){\n\t\t\t\t\tint u = f[sp];\n\t\t\t\t\tint v = f[P(mx,my)];\n\t\t\t\t\tg[u][v] = g[v][u] = cnt + 1;\n\t\t\t\t} \n\t\t\t\td[my][mx] = cnt + 1;\n\t\t\t\tq.push( P(mx,my) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile( cin >> w >> h , w || h ){\n\t\t// 初期化\n\t\tinit();\n\t\t// m[y][x] := (x,y)の状態\n\t\tvector<string> m(h);\n\t\t// vp[i] := i 番目の汚れたタイルの座標\n\t\tvector<P> vp;\n\t\t// f[p] := 座標 p と対応する i を返す (i番目の汚れたタイル)\n\t\tmap<P,int> f;\n\t\t\n\t\t// 入力\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> m[y];\n\t\t}\n\t\t// スタート地点と汚れたタイルの位置を調べる\n\t\tsearch( m , vp , '*' );\n\t\tsearch( m , vp , 'o' );\n\t\tfor(int i=0 ; i < vp.size() ; i++ ){\n\t\t\tf[ vp[i] ] = i;\n\t\t}\n\t\t// 各汚れたタイル同士の距離を調べる\n\t\tfor(int i=0 ; i < vp.size() ; i++ ){\n\t\t\tclear_d();\n\t\t\tbfs( m , vp[i] , f );\n\t\t}\n\t\t//debug( vp.size() );\n\t\t\t\n\t\t// dp[s][v] := s は訪れたかどうかのbit列, v は最後に訪れたマス\n\t\tint dp[1<<10][10];\n\t\tint N = vp.size() - 1;\n\t\t// 初期化\n\t\tfor(int i=0 ; i < (1<<N) ; i++ ){\n\t\t\tfor(int j=0 ; j < N ; j++ ){\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\t// スタートから i までの距離\n\t\tint start = N;\n\t\tfor(int i=0 ; i < N ; i++ ){\n\t\t\tdp[1<<i][i] = g[N][i];\n\t\t}\n\t\tfor(int s=0 ; s < (1<<N) ; s++ ){\n\t\t\tfor(int u=0 ; u < N ; u++ ){\n\t\t\t\tfor(int v=0 ; v < N ; v++ ){\n\t\t\t\t\tdp[s|1<<v][v] = min( dp[s|1<<v][v] , dp[s][u] + g[u][v]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor(int i=0 ; i < N ; i++ ){\n\t\t\tans = min(ans,dp[(1<<N)-1][i]) ;\n\t\t}\n\t\tif( ans == INF )\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\n\nint w, h;\nint dx[] = {1, 0 ,-1, 0}, dy[] = {0, -1, 0, 1};\n\nvector<vector<int> > make(vector<string> &grid, pii s, vector<pii> &target){\n  target.push_back(s);\n  vector<vector<int> > res(target.size());\n  for(int i = 0;i < target.size(); i++){\n    s = target[i];\n    int minicost[grid.size()][grid[0].size()];\n    bool visited[grid.size()][grid[0].size()];\n    memset(visited, 0, sizeof(visited));\n    for(int i = 0; i < grid.size(); i++){\n      for(int j = 0; j < grid[0].size(); j++){\n\tminicost[i][j] = 1e9;\n      }\n    }\n    queue<piii> que;\n    que.push(mp(0, s));\n    visited[s.second][s.first] = true;\n    minicost[s.second][s.first] = 0;\n    //cout << \"x:\" << s.first << \" y:\" << s.second << endl;\n    while(que.size()){\n      //cout << \"i:\" << i << endl;\n      int c = que.front().first;\n      int x = que.front().second.first;\n      int y = que.front().second.second;\n      que.pop();\n      for(int i = 0; i < 4; i++) {\n\tint nx = x + dx[i], ny = y + dy[i];\n\tif(0 <= nx && nx < w && \n\t   0 <= ny && ny < h && \n\t   !visited[ny][nx] &&\n\t   grid[ny][nx] != 'x' &&\n\t   minicost[ny][nx] > c + 1){\n\t  minicost[ny][nx] = c + 1;\n\t  que.push(mp(c + 1, mp(nx, ny)));\n\t  visited[ny][nx] = true;\n\t}\n      }\n    }\n    // cout << \"minicost:\" << endl;\n    // for(int i = 0; i < h; i++){\n    //   for(int j = 0; j < w; j++){\n    // \tcout << minicost[i][j] << \" \";\n    //   }\n    //   cout << endl;\n    // }\n    for(int j = 0; j < target.size(); j++){\n      res[i].push_back(minicost[target[j].second][target[j].first]);\n    }\n  }\n  return res;\n}\n\n\nint main(){\n  while(cin >> w >> h, h){\n    int n = 1;\n    vector<pii> target;//x, y\n    pii start;\n    vector<string> grid(h);\n    for(int i = 0; i < h; i++){\n      cin >> grid[i];\n      for(int j = 0; j < grid[i].length(); j++){\n\tif(grid[i][j] == '*')target.push_back(mp(j, i)), n++;\n\tif(grid[i][j] == 'o')start = mp(j, i);\n      }\n    }\n    int dp[1<<n][n];\n    for(int i = 0; i < (1<<n); i++){\n      for(int j = 0; j < n; j++){\n\tdp[i][j] = 1e9;\n      }\n    }\n    \n    //cout << w << \" \" << h << endl;\n    vector<vector<int> > g = make(grid, start, target);\n    // for(int i = 0; i < g.size(); i++){\n    //   cout << \"i:\" << i << endl;\n    //   for(int j = 0; j < g[i].size(); j++){\n    // \tcout << g[i][j] << \" \";\n    //   }\n    //   cout << endl;\n    // }\n    priority_queue<piii, vector<piii>, greater<piii> > que;\n    que.push(mp(0, mp((1<<(n - 1)), n - 1)));\n    bool flag = true;\n    while(que.size()){\n      int cost  = que.top().first;\n      int state = que.top().second.first;\n      int v     = que.top().second.second;\n      que.pop();\n      // cout << \"cost :\" << cost  << endl;\n      // cout << \"v    :\" << v     << endl;\n      // cout << \"state:\" << state << endl;\n      if(state == (1<<n) - 1){\n\tcout << cost << endl;\n\tflag = false;\n\t  break;\n      }\n      for(int i = 0; i < g[v].size(); i++){\n\tif(i == v)continue;\n\tint nv = i;\n\t\n\tif(dp[(state | (1<<i))][i] > cost + g[v][i]){\n\t  dp[(state | (1<<i))][i] = cost + g[v][i];\n\t  que.push(mp(cost + g[v][i], mp((state | (1<<i)), i)));\n\t}\n      }\n    }\n    if(flag)cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint h, w, k[21][21], cnt;\nint cx[11], cy[11], y[11][11], z[11][11], bfs[21][21], a, b, c[10], sum, minx;\nchar p;\nqueue<int>Q;\n\nvoid BFS() {\n\twhile (!Q.empty()) {\n\t\ta = Q.front() / 20;\n\t\tb = Q.front() % 20;\n\t\tif (k[a - 1][b] == 0 && bfs[a - 1][b] >= 1000000) {\n\t\t\tQ.push(Q.front() - 20);\n\t\t\tbfs[a - 1][b] = bfs[a][b] + 1;\n\t\t}\n\t\tif (k[a + 1][b] == 0 && bfs[a + 1][b] >= 1000000) {\n\t\t\tQ.push(Q.front() + 20);\n\t\t\tbfs[a + 1][b] = bfs[a][b] + 1;\n\t\t}\n\t\tif (k[a][b + 1] == 0 && bfs[a][b + 1] >= 1000000) {\n\t\t\tQ.push(Q.front() + 1);\n\t\t\tbfs[a][b + 1] = bfs[a][b] + 1;\n\t\t}\n\t\tif (k[a][b - 1] == 0 && bfs[a][b - 1] >= 1000000) {\n\t\t\tQ.push(Q.front() - 1);\n\t\t\tbfs[a][b - 1] = bfs[a][b] + 1;\n\t\t}\n\t\tQ.pop();\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tmemset(z, 0, sizeof(z));\n\t\tcin >> w >> h; cnt = 1; if (!w) { break; }\n\t\tfor (int i = 0; i < 21; i++) { \n\t\t\tfor (int j = 0; j < 21; j++) { \n\t\t\t\tk[i][j] = 1; \n\t\t\t} \n\t\t}\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tcin >> p;\n\t\t\t\tif (p != 'x') { k[i][j] = 0; }\n\t\t\t\tif (p == '*') { cx[cnt] = j; cy[cnt] = i; cnt++; }\n\t\t\t\tif (p == 'o') { cx[0] = j; cy[0] = i; }\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\tc[i] = i;\n\t\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\t\tmemset(bfs, 10, sizeof(bfs));\n\t\t\t\tbfs[cy[i]][cx[i]] = 0;\n\t\t\t\tQ.push(cy[i] * 20 + cx[i]);\n\t\t\t\tBFS();\n\t\t\t\tz[i][j] = bfs[cy[j]][cx[j]];\n\t\t\t}\n\t\t}\n\t\tminx = 114514;\n\t\tdo\n\t\t{\n\t\t\tsum = z[0][c[0] + 1];\n\t\t\tfor (int i = 0; i < cnt; i++) { sum += z[c[i] + 1][c[i + 1] + 1]; }\n\t\t\tminx = min(minx, sum);\n\t\t} while (next_permutation(c, c + cnt - 1));\n\t\tif (minx == 114514) { minx = -1; }\n\t\tcout << minx << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <queue>\n#include <string.h>\n\nusing namespace std;\n\nstruct Point {\n  int y;\n  int x;\n  int cost;\n  Point() {;}\n  Point(int y1, int x1, int c) : y(y1), x(x1), cost(c) {;}\n};\n\nint width;\nint height;\n\nchar str[100];\nchar tile[30][30];\nint dist[11][10];\nint dirty_y[10];\nint dirty_x[10];\nint map[30][30];\nbool check[30][30];\nint dirty_tile;\nint memo[1024][10];\n\nint calc(int depth, int visit, int where) {\n  if (memo[visit][where] != -1) { return memo[visit][where]; }\n  if (depth == dirty_tile) { return 0; }\n  int ret = 0x0f0f0f0f;\n  for (int i = 0; i < dirty_tile; i++) {\n    if (visit & (1 << i)) { continue; }\n    int next_visit = visit | (1 << i);\n    ret = min(ret, calc(depth + 1, next_visit, i) + dist[where][i]);\n  }\n  return memo[visit][where] = ret;\n}\n\nint main() {\n  while (scanf(\"%d %d\", &width, &height), width != 0 && height != 0) {\n    fgets(str, 99, stdin);\n    for (int i = 0; i < height; i++) {\n      fgets(tile[i], 29, stdin);\n    }\n    int start_y;\n    int start_x;\n    dirty_tile = 0;\n    for (int y = 0; y < height; y++) {\n      for (int x = 0; x < width; x++) {\n        if (tile[y][x] == '*') {\n          dirty_y[dirty_tile] = y;\n          dirty_x[dirty_tile] = x;\n          map[y][x] = dirty_tile;\n          dirty_tile++;\n        } else if (tile[y][x] == 'o') {\n          start_y = y;\n          start_x = x;\n        }\n      }\n    }\n    dirty_y[dirty_tile] = start_y;\n    dirty_x[dirty_tile] = start_x;\n    map[start_y][start_x] = dirty_tile;\n    memset(dist, -1, sizeof(dist));\n    static const int dy[4] = { 1, -1, 0, 0 };\n    static const int dx[4] = { 0, 0, 1, -1 };\n    for (int i = 0; i < dirty_tile + 1; i++) {\n      queue<Point> que;\n      que.push(Point(dirty_y[i], dirty_x[i], 0));\n      memset(check, false, sizeof(check));\n      while (!que.empty()) {\n        Point now = que.front();\n        que.pop();\n        if (check[now.y][now.x]) { continue; }\n        check[now.y][now.x] = true;\n        if (tile[now.y][now.x] == '*') {\n          dist[i][map[now.y][now.x]] = now.cost;\n        }\n        for (int i = 0; i < 4; i++) {\n          int ny = now.y + dy[i];\n          int nx = now.x + dx[i];\n          if (ny < 0 || ny >= height || nx < 0 || nx >= width || check[ny][nx] || tile[ny][nx] == 'x') { continue; }\n          que.push(Point(ny, nx, now.cost + 1));\n        }\n      }\n    }\n    for (int i = 0; i < dirty_tile; i++) {\n      if (dist[dirty_tile][i] == -1) {\n        puts(\"-1\");\n        goto next_loop;\n      }\n    }\n    memset(memo, -1, sizeof(memo));\n    printf(\"%d\\n\", calc(0, 0, dirty_tile));\nnext_loop:\n    ;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<queue>\n#include<algorithm>\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define INF 100000000\nusing namespace std;\ntypedef pair<int,int> P;\nvector<string> s;\nint w,h;\nvector<P> p;\nvector<vector<int> > dist;\nmap<P,int> mp;\nvector<vector<int> > dp;\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nbool inf(int y,int x){\n\tif(x>=0&&x<w&&y>=0&&y<h)\n\treturn true;\n\treturn false;\n}\nint TSP(int now,int bit){\n\tif(bit==(1<<p.size())-1){\n\t\treturn 0;\n\t}\n\tif(dp[bit][now]!=-1)\n\t\treturn dp[bit][now];\n\tint ret=INF;\n\tfor(int i=1;i<p.size();i++){\n\t\tif( !( (1<<i) &bit ) ){\n\t\t\tret=min(TSP(i,bit|(1<<i))+dist[now][i],ret);\n\t\t}\n\t}\n\t\n\treturn dp[bit][now]=ret;\n}\nint main(){\n\twhile(cin>>w>>h,w||h){\n\t\t\n\t\ts.resize(h);\n\t\tp.resize(1);\n\t\tmp.clear();\n\t\tp[0]=P(0,0);\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>s[i];\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(s[i][j]=='o'){\n\t\t\t\t\tp[0]=P(i,j);\n\t\t\t\t\tmp[P(i,j)]=0;\n\t\t\t\t}else if(s[i][j]=='*'){\n\t\t\t\t\tmp[P(i,j)]=p.size();\n\t\t\t\t\tp.pb(P(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdist=vector<vector<int> >(p.size(),vector<int>(p.size(),INF));\n\t\tbool flag=true;\n\t\tfor(int i=0;i<p.size();i++){\n\t\t\tqueue<P> que;\n\t\t\tvector<vector<int> > d(h,vector<int>(w,INF));\n\t\t\tvector<vector<bool> > used(h,vector<bool>(w,false));\n\t\t\td[p[i].first][p[i].second]=0;\n\t\t\tque.push(p[i]);\n\t\t\tint cnt=0;\n\t\t\twhile(!que.empty()){\n\t\t\t\tP t=que.front();\n\t\t\t\tque.pop();\n\t\t\t\tif(used[t.first][t.second]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(find(all(p),t)!=p.end()&&dist[i][mp[t]]==INF){\n\t\t\t\t\tdist[i][mp[t]]=d[t.first][t.second];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tused[t.first][t.second]=true;\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint nx=dx[i]+t.second,ny=dy[i]+t.first;\n\t\t\t\t\tif(inf(ny,nx)&&!used[ny][nx]&&d[ny][nx]==INF&&s[ny][nx]!='x'){\n\t\t\t\t\t\tque.push(P(ny,nx));\n\t\t\t\t\t\td[ny][nx]=d[t.first][t.second]+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt!=p.size()){\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag){\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tdp=vector<vector<int> >((1<<p.size()),vector<int>(p.size(),-1));\n\t\tcout<<TSP(0,1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint INF = 100000;\nvector<int> dy = {1, 0, -1, 0};\nvector<int> dx = {0, 1, 0, -1};\nint main(){\n  while (1){\n    int w, h;\n    cin >> w >> h;\n    if (w == 0 && h == 0){\n      break;\n    }\n    vector<vector<char>> c(h + 2, vector<char>(w + 2, 'x'));\n    for (int i = 1; i <= h; i++){\n      for (int j = 1; j <= w; j++){\n        cin >> c[i][j];\n      }\n    }\n    vector<pair<int, int>> T;\n    for (int i = 1; i <= h; i++){\n      for (int j = 1; j <= w; j++){\n        if (c[i][j] == '*'){\n          T.push_back(make_pair(i, j));\n          c[i][j] = '.';\n        }\n        if (c[i][j] == 'o'){\n          T.insert(T.begin(), make_pair(i, j));\n          c[i][j] = '.';\n        }\n      }\n    }\n    int N = T.size();\n    vector<vector<int>> E(N, vector<int>(N));\n    for (int i = 0; i < N; i++){\n      vector<vector<int>> d(h + 2, vector<int>(w + 2, INF));\n      d[T[i].first][T[i].second] = 0;\n      queue<pair<int, int>> Q;\n      Q.push(make_pair(T[i].first, T[i].second));\n      while (!Q.empty()){\n        int y = Q.front().first;\n        int x = Q.front().second;\n        Q.pop();\n        for (int j = 0; j < 4; j++){\n          int y2 = y + dy[j];\n          int x2 = x + dx[j];\n          if (c[y2][x2] == '.' && d[y2][x2] == INF){\n            d[y2][x2] = d[y][x] + 1;\n            Q.push(make_pair(y2, x2));\n          }\n        }\n      }\n      for (int j = 0; j < N; j++){\n        E[i][j] = d[T[j].first][T[j].second];\n      }\n    }\n    bool ok = true;\n    for (int j = 1; j < N; j++){\n      if (E[0][j] == INF){\n        ok = false;\n      }\n    }\n    if (!ok){\n      cout << -1 << endl;\n    } else {\n      vector<int> p(N);\n      for (int j = 0; j < N; j++){\n        p[j] = j;\n      }\n      int ans = INF;\n      while (1){\n        int sum = 0;\n        for (int j = 0; j < N - 1; j++){\n          sum += E[p[j]][p[j + 1]];\n        }\n        ans = min(ans, sum);\n        next_permutation(p.begin(), p.end());\n        if (p[0] > 0){\n          break;\n        }\n      }\n      cout << ans << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={-1,0,1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fr first\n#define sc second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nint W,H;\nint D[12][12];\nchar stage[25][25];\nvector < Pii > c;\nint len;\nvoid bfs(int index){\n    int s[25][25];\n    memset(s,-1,sizeof(s));\n    queue < Pii > Q;\n    Q.push(c[index]);\n    s[c[index].fr][c[index].sc] = 0;\n    while(!Q.empty()){\n        Pii p = Q.front();Q.pop();\n        rep(i,4){\n            int ny = p.fr + dy[i];\n            int nx = p.sc + dx[i];\n            if(s[ny][nx] != -1 || stage[ny][nx] == 'x')continue;\n            if(ny < 0 || ny > H-1 || nx < 0 || nx > W-1)continue;\n            s[ny][nx] = s[p.fr][p.sc] + 1;\n            Q.push(Pii(ny,nx));\n        }\n    }\n    rep(i,len){\n        if(i == index)continue;\n        D[index][i] = s[c[i].fr][c[i].sc];\n    }\n    return ;\n}\nint memo[1<<12];\nint getMin(int bit,int prev){\n    if((1<<len)-1 == bit){\n        return 0;\n    }\n    int ret = INF;\n    rep(i,len){\n        if(!(1&bit>>i)){\n            if(D[prev][i] == -1)continue;\n            ret = min(ret,D[prev][i]+getMin(bit|1<<i,i));\n        }\n    }\n    return ret;\n}\nint main(){\n    while(scanf(\"%d%d\",&W,&H),(W|H)){\n        int index = 0;\n        int s;\n        c.clear();\n        rep(i,H){\n            scanf(\"%s\",&stage[i]);\n            rep(j,W){\n                if(stage[i][j] == 'o'){\n                    s = index;\n                    stage[i][j] = '.';\n                    c.PB(Pii(i,j));\n                    index++;\n                }\n                if(stage[i][j] == '*'){\n                    c.PB(Pii(i,j));\n                    index++;\n                }\n            }\n        }\n        len = index;\n        memset(D,0,sizeof(D));\n        rep(i,len){\n            bfs(i);\n        }\n        memset(memo,-1,sizeof(memo));\n        int ans = getMin(1<<s,s);\n        if(ans == INF)ans = -1;\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ninline double distance(double y1, double x1, double y2, double x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy = { 0, 1, 0, -1 }, dx = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\n\nusing namespace std;\n\n\nint dist(const vector<string> &field, int sy, int sx, int gy, int gx) {\n    VV<int> memo(field.size(), V<int>(field[0].size(), INT_MAX));\n    memo[sy][sx] = 0;\n\n    queue<pair<int, int>> que;\n    que.push(make_pair(sy, sx));\n    while (not que.empty()) {\n        auto now = que.front(); que.pop();\n        int now_cost = memo[now.first][now.second];\n\n        FOR(i, 0, 4) {\n            int ny = dy[i] + now.first;\n            int nx = dx[i] + now.second;\n\n            if (inside(ny, nx, (int)field.size(), (int)field[0].size()) and (field[ny][nx] != 'x')) {\n                if (memo[ny][nx] > now_cost + 1) {\n                    que.push(make_pair(ny, nx));\n                    memo[ny][nx] = now_cost + 1;\n                }\n            }\n        }\n    }\n    return memo[gy][gx];\n}\n\n\nvoid solve(vector<string> &field) {\n    int sy = -1, sx = -1;\n    vector<pair<int, int>> v;\n    FOR(y, 0, field.size()) {\n        FOR(x, 0, field[0].size()) {\n            if (field[y][x] == 'o') {\n                sy = y;\n                sx = x;\n            }\n            if (field[y][x] == '*') {\n                v.emplace_back(make_pair(y, x));\n            }\n        }\n    }\n\n    V<int> first_cost_table(v.size(), INT_MAX);\n    VV<int> cost_table(v.size(), V<int>(v.size(), INT_MAX));\n    FOR(i, 0, v.size()) {\n        first_cost_table[i] = dist(field, sy, sx, v[i].first, v[i].second);\n        FOR(j, i + 1, v.size()) {\n            cost_table[i][j] = dist(field, v[i].first, v[i].second, v[j].first, v[j].second);\n            cost_table[j][i] = cost_table[i][j];\n        }\n    }\n\n    int ans = INT_MAX;\n    vector<int> route(v.size());\n    iota(ALL(route), 0);\n    do {\n\n        int total = first_cost_table[route[0]];\n        FOR(i, 0, route.size() - 1) {\n            total += cost_table[route[i]][route[i + 1]];\n        }\n        ans = min(ans, total);\n\n    } while(next_permutation(ALL(route)));\n\n    if (ans == INT_MAX) {\n        print(-1);\n    }\n    else {\n        print(ans);\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int W, H;\n        cin >> W >> H;\n        if (W == 0 or H == 0) {\n            break;\n        }\n        vector<string> field;\n        FOR(_, 0, H) {\n            string s;\n            cin >> s;\n            field.push_back(s);\n        }\n\n        solve(field);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vbb;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst double inf = (int)1e8;\n\ntypedef pair<int, int> P;\n\nchar maze[30][30 + 1]; // 迷路を表す文字列の配列 int N, M;\nvector<pair<int, int> >g;\n\nint d[30][30];\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint n, m;\nint q[15][15];\nint dp[1 << 12][12];\n\nint bfs(int sx, int sy, int gx, int gy){\n    queue<P> que;\n    rep(i,n)rep(j, m) d[i][j] = inf;\n\n    que.push(P(sx, sy));\n    d[sx][sy] = 0;\n\n    while(que.size()){\n        P p = que.front(); que.pop();\n        if(p.first == gx && p.second == gy) break;\n\n        rep(i, 4){\n            int nx = p.first + dx[i], ny = p.second + dy[i];\n            if (0 <= nx && nx < n && 0 <= ny && ny < m && maze[nx][ny] != 'x' && d[nx][ny] == inf) {\n                que.push(P(nx, ny));\n                d[nx][ny] = d[p.first][p.second] + 1;\n            }\n        }\n    }\n    return d[gx][gy];\n}\n\nint main(){\n    while(cin >> n >> m, n|m){\n        pair<int, int> s;\n        rep(i, 400){\n            rep(j,400)q[i][j] = inf;\n            q[i][i] = 0;\n        }\n        rep(i, m) cin >> maze[i];\n        rep(i, m)rep(j, n){\n            if(maze[i][j] == 'o'){s.first = j, s.second = i;}\n            if(maze[i][j] == '*' || maze[i][j] == 'o'){g.pb(mp(j, i));}\n        }\n        vector<pair<int, int> > gg;\n        gg.pb(s);\n        rep(i, g.size()) gg.pb(g[i]);\n        rep(i, gg.size()){\n            rep(j, gg.size()){\n                if(i == j) continue;\n                int res = bfs(gg[i].first, gg[i].second, gg[j].first, gg[j].second);\n                q[i][j] = res;\n            }\n        }\n        rep(i, 1<<gg.size()) fill(dp[i], dp[i]+gg.size(), inf);\n        dp[(1 << gg.size())-1][0] = 0;\n\n        for(int S = (1 << gg.size())-2; S >= 0; S--){\n            for(int v = 0; v < n; v++){\n                for(int u=0; u < gg.size(); u++){\n                    if(!(S >> u & 1)){\n                        dp[S][v] = min(dp[S][v], dp[S | 1 << u][u] + q[v][u]);\n                    }\n                }\n            }\n        }\n        int ret = inf;\n        rep(i, gg.size()){\n            if(i == 0) continue;\n            ret = min(ret, dp[0][i]);\n        }\n        if(ret != inf) cout << ret << endl;\n        else cout << -1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define MP make_pair\n\nint const SIZE = 20;\nint const MAX_N = 11;\nint const INF = (int)1e8;\nint H, W;\nchar grid[SIZE][SIZE];\ntypedef pair<int, int> Pii;\n\nint cost[SIZE][SIZE][SIZE][SIZE];\nint dist[MAX_N][MAX_N];\nint dp[1<<MAX_N][MAX_N];\nmap<Pii, int> dmap;\n\nint const dx[] = {-1,0,1,0};\nint const dy[] = {0,-1,0,1};\n\ninline bool inF(int x, int y) {\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\nbool bfs(int SX, int SY) {\n\n#define COST(x, y) cost[SY][SX][y][x]\n  \n  fill(&COST(0, 0), &COST(0, 0)+22*22, INF);\n  queue<Pii> Q;\n  Q.push(Pii(SX, SY));\n  COST(SX, SY) = 0;\n  while(!Q.empty()) {\n    Pii pii = Q.front(); Q.pop();\n    int x = pii.first, y = pii.second;\n    for(int i=0; i<4; i++) {\n      int nx = x+dx[i], ny = y+dy[i];\n      if(!inF(nx, ny)) continue;\n      if(COST(nx, ny) != INF) continue;\n      if(grid[ny][nx] == 'x') continue;\n      COST(nx, ny) = COST(x, y) + 1;\n      Q.push(Pii(nx, ny));\n    }\n  }\n  \n  bool ok = true;\n  rep(i, H)rep(j, W) if(grid[i][j] == '*' && COST(j, i) == INF) ok = false;\n  \n  return ok;\n}\n\nint main() {\n  \n  while(cin >> W >> H && (W|H)) {\n    \n    dmap.clear();\n    \n    int dsx, dsy;\n    int dcnt = 1;\n    rep(i, H) rep(j, W){\n      cin>>grid[i][j];\n      if(grid[i][j] == 'o') {\n        dsx = j, dsy = i;\n        dmap[Pii(j, i)] = 0;\n      }\n      if(grid[i][j] == '*') {\n        dmap[Pii(j, i)] = dcnt++;\n      }\n    }\n    \n    bool NA = false;\n    rep(i, H) rep(j, W)\n      if(grid[i][j] == '*' || grid[i][j] == 'o') {\n        if(!bfs(j, i)) { NA = true; i = j = INF; }\n      }\n    if(NA) { cout << -1 << endl; continue; }\n    \n    rep(i, H) rep(j, W) rep(k, H) rep(l, W) {\n      if(i == k && j == l) continue;\n      if((grid[i][j] == '*' && grid[k][l] == '*')\n         ||\n         (grid[i][j] == 'o' && grid[k][l] == '*')) {\n        dist[dmap[Pii(j, i)]][dmap[Pii(l, k)]] = cost[i][j][k][l];\n      }\n    }\n   \n    int V = dcnt;\n    \n    for(int i=0; i<(1<<V); i++) fill(dp[i], dp[i]+MAX_N, INF);\n    dp[(1<<V)-1][0] = 0;\n    \n    for(int st = (1<<V)-2; st >= 0; st--)\n      for(int v=0; v<V; v++)\n        for(int u=0; u<V; u++)\n          if(!((st >> u) & 1)) { dp[st][v] = min(dp[st][v], dp[st|(1<<u)][u]+dist[v][u]); }\n    \n    cout << dp[0][0] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\nconst int INF = 100000;\n\nvector<int> calc(const vector<string>& m, int st) {\n  int h = m.size();\n  int w = m[0].size();\n  queue<pair<int,int>> q;\n  vector<int> dist(h*w,INF);\n  q.push(make_pair(st,0));\n  while(!q.empty()) {\n    int id, d;\n    tie(id, d) = q.front(); q.pop();\n    if (d >= dist[id]) continue;\n    dist[id] = d;\n    int di[] = {-w, -1, 1, w};\n    REP(k,4) {\n      int ni = id + di[k];\n      int i = ni/w;\n      int j = ni%w;\n      if (m[i][j] == 'x') continue;\n      if (dist[ni] > dist[id] + 1)\n        q.push(make_pair(ni, dist[id]+1));\n    }\n  }\n  return dist;\n}\n\nint main() {\n  while(1){\n    int w,h;\n    cin>>w>>h;\n    if(!w)break;\n    vector<string> m(h+2, string(w+2, 'x'));\n    REP(i,h) {\n      string l;\n      cin>>l;\n      m[i+1] = \"x\" + l + \"x\";\n    }\n    h+=2;w+=2;\n    vector<int> xl;\n    int st = 0;\n    REP(i,h)REP(j,w) {\n      switch(m[i][j]) {\n        case '*': xl.push_back(i*w+j); break;\n        case 'o': st = i*w+j; break;\n      }\n    }\n    vector<int> pl;;\n    pl.push_back(st);\n    pl.insert(end(pl),begin(xl),end(xl));\n    int n = pl.size();\n    vector<vector<int>> d(n, vector<int>(n, INF));\n    REP(i,n) {\n      int id = pl[i];\n      auto dl = calc(m, id);\n      REP(j,n)\n        d[i][j] = dl[pl[j]];\n    }\n    vector<vector<int>> dp(1<<n, vector<int>(n, INF));\n    dp[1][0] = 0;\n    REP(i,1<<n) {\n      REP(j,n) {\n        //if (((i>>j)&1) == 0) continue;\n        REP(k,n) {\n          //if ((i>>k)&1) continue;\n          dp[i|1<<k][k] = min(dp[i|1<<k][k], dp[i][j] + d[j][k]);\n        }\n      }\n    }\n    int mind = *min_element(begin(dp[(1<<n)-1]),end(dp[(1<<n)-1]));\n    if (mind < INF)\n      cout << mind << endl;\n    else\n      cout << \"-1\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\nstruct State{\n    int y, x, c, bit, n;\n    State(int y, int x, int c, int bit, int n) : y(y), x(x), c(c), bit(bit), n(n) {}\n};\n\nbool memo[22][22][(1<<11)];\n\nint main(){\n    while(true){\n        int w, h;\n        cin >> w >> h;\n        if(w == 0) break;\n\n        vector<string> field(h);\n        int N = 0, sy = -1, sx = -1;\n        for(int i=0;i<h;i++){\n            cin >> field[i];\n            for(int j=0;j<w;j++){\n                if(field[i][j] == 'o'){\n                    sy = i;\n                    sx = j;\n                }else if(field[i][j] == '*'){\n                    field[i][j] = '0' + N;\n                    N++;\n                }\n            }\n        }\n\n        const int dd[] = {0, 1, 0, -1, 0};\n        queue<State> que;\n        que.emplace(sy, sx, 0, 0, 0);\n        memset(memo, 0, sizeof(memo));\n\n        while(que.size()){\n            State s = que.front();\n            if(s.n == N) break;\n            que.pop();\n\n            for(int k=0;k<4;k++){\n                int ny = s.y + dd[k], nx = s.x + dd[k+1];\n                if(ny < 0 || h <= ny || nx < 0 || w <= nx || field[ny][nx] == 'x') continue;\n                int nbit = s.bit, nn = s.n;\n                if('0' <= field[ny][nx] && field[ny][nx] <= '9'){\n                    if((s.bit&(1 << (field[ny][nx] - '0'))) == 0) nn++;\n                    nbit |= 1 << (field[ny][nx] - '0');\n                }\n                if(!memo[ny][nx][nbit]){\n                    memo[ny][nx][nbit] = true;\n                    que.emplace(ny, nx, s.c + 1, nbit, nn);\n                }\n            }\n        }\n\n        if(que.size() > 0) cout << que.front().c << endl;\n        else cout << -1 << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<limits.h>\n#define INF INT_MAX\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h;\nint imap[21][21];\nint djd[20][2]; // 0->x ,1->y\nint mmaapp[20][20];\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\nint bfs(int sp,int gp){\n  int mmap[21][21];\n  for(int i=0;i<21;i++)for(int j=0;j<21;j++)mmap[i][j] = INF;\n  queue<P> que;\n  que.push(P(djd[sp][0],djd[sp][1]));\n  mmap[djd[sp][1]][djd[sp][0]]=0;\n\n  while(que.size()){\n    P p = que.front();que.pop();\n\n    if(p.first == djd[gp][0] && p.second == djd[gp][1])return mmap[djd[gp][1]][djd[gp][0]];\n\n    for(int i=0;i<4;i++){\n      int nx = p.first+dx[i],ny = p.second+dy[i];\n      if(0<=nx && nx < w && 0<=ny && ny < h && mmap[ny][nx] == INF && imap[ny][nx] != -1){\n\tque.push(P(nx,ny));\n\tmmap[ny][nx] = mmap[p.second][p.first] + 1;\n      }\n    }\n  }\n}\n\n\n\nint main(){\n  char in;\n  int count;\n  while(true){\n    cin >> w >> h;\n    if(w+h == 0)break;\n    count=1;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> in;\n\tswitch(in){\n\tcase '.':\n\t  imap[i][j]=0;\n\t  break;\n\tcase 'o':\n\t  imap[i][j]=0;\n\t  djd[0][0]=j;\n\t  djd[0][1]=i;\n\t  break;\n\tcase 'x':\n\t  imap[i][j]=-1;\n\t  break;\n\tcase '*':\n\t  imap[i][j]=0;\n\t  djd[count][0]=j;\n\t  djd[count][1]=i;\n\t  count++;\n\t  break;\n\tdefault:\n\t  cout << \"erro\" << endl; \n\t  break;\n\t}\n      }\n    }\n\n    for(int i=0;i<count;i++){\n      for(int j=0;j<count;j++){\n\tmmaapp[i][j] = bfs(i,j);\n      }\n    }\n\n\n\n    int dp[(1<<count)+2][count+2];\n    rep(i,(1<<count)+2)rep(j,count+2)dp[i][j]=4000;\n    dp[(1<<count)-1][0]=0;\n\n    for(int S=(1<<count)-2;S>=0;S--){\n      for(int v=0;v<count;v++){\n\tfor(int u=0;u<count;u++){\n\t  if(!(S>>u & 1)){\n\t    dp[S][v]=min(dp[S][v],dp[S| 1<<u][u] + mmaapp[v][u]);\n\t  }\n\t}\n      }\n    }\n    int ans=4000;\n    for(int i=0;i<count;i++){\n      ans = min(ans,dp[(1<<i)][i]);\n    }\n\n    if(ans < 0)cout << \"-1\" << endl;\n    else cout << ans << endl;\n\n\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <queue>\n#include <utility>\nusing namespace std;\n\n#define INF 1 << 28\n\nint w, h;\nstruct state_t {\n    int y, x, time;\n    state_t(int y, int x, int time) : y(y), x(x), time(time) {}\n    bool operator!=(const state_t &o) {\n        return (y != o.y || x != o.x || time != o.time);\n    }\n};\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstate_t bfs(vector<string> &field, state_t p) {\n    bool visited[h][w];\n    memset(visited, 0, sizeof(visited));\n    queue<state_t> q;\n    q.push(p);\n    \n    while (!q.empty()) {\n        state_t s = q.front(); q.pop();\n        if (field[s.y][s.x] == '*') {\n            field[s.y][s.x] = '.';\n            return s;\n        }\n        for (int i = 0; i < 4; i++) {\n            int ny = s.y + dy[i];\n            int nx = s.x + dx[i];\n            if (0 <= nx && nx < w && 0 <= ny && ny < h && !visited[ny][nx] && field[ny][nx] != 'x') {\n                q.push(state_t(ny, nx, s.time+1));\n                visited[ny][nx] = true;\n            }\n        }\n    }\n    \n    return state_t(INF, INF, INF);\n}\n\nint main() {\n    while (cin >> w >> h) {\n        if (w == 0 && h == 0) break;\n        vector<string> field(h);\n        for (int i = 0; i < h; i++) {\n            cin >> field[i];\n        }\n\n        int y, x;\n        int garbage_count = 0;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (field[i][j] == 'o') {\n                    y = i;\n                    x = j;\n                }\n                if (field[i][j] == '*') garbage_count++;\n            }\n        }\n\n        state_t not_found(INF, INF, INF);\n        state_t cur_s = state_t(y, x, 0);\n        while (true) {\n            state_t next_s = bfs(field, cur_s);\n            if (next_s != not_found) {\n                garbage_count--;\n                cur_s = next_s;\n                if (garbage_count == 0) {\n                    cout << cur_s.time << endl;\n                    break;\n                }\n            } else {\n                if (garbage_count != 0) {\n                    cout << -1 << endl;\n                    break;\n                }\n                cout << cur_s.time << endl;\n                break;\n            }\n        }\n    }\n\n    return 0;\n}\n\n\n\n\n        "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<limits.h>\n#define INF 100000\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h;\nint imap[21][21];\nint fin;\nint djd[20][2]; // 0->x ,1->y\nint mmaapp[20][20];\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\nint bfs(int sp,int gp){\n  int mmap[21][21];\n \n  for(int i=0;i<21;i++)for(int j=0;j<21;j++)mmap[i][j] = INF;\n  queue<P> que;\n  que.push(P(djd[sp][0],djd[sp][1]));\n  mmap[djd[sp][1]][djd[sp][0]]=0;\n\n  while(que.size()){\n    P p = que.front();que.pop();\n\n    if(p.first == djd[gp][0] && p.second == djd[gp][1])return mmap[djd[gp][1]][djd[gp][0]];\n\n    for(int i=0;i<4;i++){\n      int nx = p.first+dx[i],ny = p.second+dy[i];\n      if(0<=nx && nx < w && 0<=ny && ny < h && mmap[ny][nx] == INF && imap[ny][nx] != -1){\n\tque.push(P(nx,ny));\n\tmmap[ny][nx] = mmap[p.second][p.first] + 1;\n      }\n    }\n  }\n  return -3;\n}\n\n\n\nint main(){\n  char in;\n  int count;\n  int permutationtest[66];\n    while(true){\n    cin >> w >> h;\n    if(w+h == 0)break;\n    rep(i,66)permutationtest[i] = 0;  \n  count=1;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> in;\n\tswitch(in){\n\tcase '.':\n\t  imap[i][j]=0;\n\t  break;\n\tcase 'o':\n\t  imap[i][j]=0;\n\t  djd[0][0]=j;\n\t  djd[0][1]=i;\n\t  break;\n\tcase 'x':\n\t  imap[i][j]=-1;\n\t  break;\n\tcase '*':\n\t  imap[i][j]=0;\n\t  djd[count][0]=j;\n\t  djd[count][1]=i;\n\t  count++;\n\t  break;\n\tdefault:\n\t  cout << \"erro\" << endl; \n\t  break;\n\t}\n      }\n    }\n\n    for(int i=0;i<count;i++){\n      for(int j=0;j<count;j++){\n\tmmaapp[i][j] = bfs(i,j);\n\tfin = min(fin,mmaapp[i][j]);\n\t//cout << mmaapp[i][j] << \" \";\n      }\n      //cout << endl;\n    }\n    //cout << \"fin = \" << fin << endl;\n   \n   \n    for(int i=0;i<count-1;i++){\n      permutationtest[i] = i+1;\n      //cout << i+1 << endl;\n    }\n    //cout << endl;\n    //cout << \"count-1 = \" << count-1 << endl;\n    //cout << \"----------------------\" << endl;\n    int sum;\n    int ans=INF;\n do{\n      sum=0;\n      sum+=mmaapp[0][permutationtest[0]];\n      //cout << \"mmaapp[0][permutationtest[0]] = \" << sum << endl;\n      for(int i=1;i<count-1;i++){\n\tsum+=mmaapp[permutationtest[i-1]][permutationtest[i]];\n\t//cout << \"mmaapp[permutatintest[i-1]][permutationtest[i]] = \" << mmaapp[permutationtest[i-1]][permutationtest[i]] << \", permutationtest[i-1] = \" << permutationtest[i-1] << \", permutatintest[i] = \" << permutationtest[i] << endl;\n      }\n      //cout << \"----\" << endl;\n      ans=min(ans,sum);\n }while(next_permutation(permutationtest,permutationtest+(count-1)));\n\n    if(fin < 0)cout << \"-1\" << endl;\n    else cout << ans << endl;\n\n  \n    \n    //if(ans < 0)cout << \"-1\" << endl;\n    //else cout << ans << endl;\n   \n\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define fi first\n#define se second\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\nusing pii = pair<int,int>;\nusing ll = long long;\n\n\nint w,h;\n\nint table[30][30];\nint d[30][30];\nll vv[20][20];\n\nint dd[] = {0,1,0,-1,0};\n\nbool inside(pii a){\n\treturn 0<=a.fi&&a.fi<h&&0<=a.se&&a.se<w;\n}\n\nvoid bfs(pii s){\n\trep(i,h) rep(j,w) d[i][j] = INF;\n\td[s.fi][s.se] = 0;\n\tqueue<pii> q;\n\tq.push(s);\n\tint len = 0;\n\twhile(q.size()){\n\t\tlen++;\n\t\tint qs = q.size();\n\t\trep(i,qs){\n\t\t\tpii top = q.front();\n\t\t\tq.pop();\n\t\t\trep(j,4){\n\t\t\t\tpii next = top;\n\t\t\t\tnext.fi += dd[j];\n\t\t\t\tnext.se += dd[j+1];\n\t\t\t\tif(!inside(next) || d[next.fi][next.se]!=INF) continue;\n\t\t\t\tif(table[next.fi][next.se] == 1) continue;\n\t\t\t\td[next.fi][next.se] = len;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>w>>h,w){\n\t\tvector<pii> dirt(1);\n\t\tpii robot;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tchar t;\n\t\t\t\tcin>>t;\n\t\t\t\ttable[i][j] = 0;\n\t\t\t\tif(t=='o'){\n\t\t\t\t\trobot = pii(i,j);\n\t\t\t\t}\n\t\t\t\telse if(t=='*'){\n\t\t\t\t\tdirt.push_back(pii(i,j));\n\t\t\t\t}\n\t\t\t\telse if(t=='x'){\n\t\t\t\t\ttable[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdirt[0] = robot;\n\t\tint n = dirt.size();\n\t\tif(n==1){\n\t\t\tcout<<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tbool ok = true;\n\t\trep(i,n){\n\t\t\tbfs(dirt[i]);\n\t\t\trep(j,h){\n\t\t\t\trep(k,w){\n\t\t\t\t\trep(l,n){\n\t\t\t\t\t\tif(l==i) continue;\n\t\t\t\t\t\tif(dirt[l] == pii(j,k)){\n\t\t\t\t\t\t\tvv[i][l] = d[j][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// rep(i,n){\n\t\t// \trep(j,n){\n\t\t// \t\tcout<<vv[i][j]<<\" \";\n\t\t// \t}\n\t\t// \tcout<<endl;\n\t\t// }\n\t\tll ans = INFL;\n\t\tvector<int> per(n-1);\n\t\trep(i,n-1) per[i] = i+1;\n\t\tdo{\n\t\t\tint p = 0;\n\t\t\tll tmp = 0;\n\t\t\trep(i,n-1){\n\t\t\t\ttmp += vv[p][per[i]];\n\t\t\t\tp = per[i];\n\t\t\t}\n\t\t\tans = min(ans, tmp);\n\t\t}while(next_permutation(per.begin(), per.end()));\n\t\tif(ans >= INF){\n\t\t\tcout<<-1<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<ans<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n\nusing namespace std;\nusing P = pair<int, int>;\n\nint w, h, m;\nstring map[20];\nint d[20][20][20][20];\nP dirty[20];\nint diri[] = {-1, 0, 1, 0};\nint dirj[] = {0, -1, 0, 1};\n\nvoid bfs(int si, int sj) {\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            d[si][sj][i][j] = -1;\n        }\n    }\n    d[si][sj][si][sj] = 0;\n\n    queue<P> q;\n    q.push(make_pair(si, sj));\n\n    while (!q.empty()) {\n        P p = q.front();\n        q.pop();\n        int i = p.first;\n        int j = p.second;\n        int cost = d[si][sj][i][j];\n        for (int k = 0; k < 4; ++k) {\n            int ni = i + diri[k];\n            int nj = j + dirj[k];\n            if (ni < 0 || ni >= h || nj < 0 || nj >= w) continue;\n            if (map[ni][nj] == 'x') continue;\n            //cout << ni << nj << \" \"<<d[si][sj][ni][nj]<< endl;\n            if (d[si][sj][ni][nj] != -1) continue;\n            d[si][sj][ni][nj] = cost + 1;\n            q.push(make_pair(ni, nj));\n        }\n    }\n    // for (int i = 0; i < h; ++i) {\n    //     for (int j = 0; j < w; ++j) {\n    //         cout << d[si][sj][i][j] << \"  \";\n    //     }\n    //     cout << endl;\n    // }\n    // cout << endl;\n}\n\nvoid solve() {\n    for (int i = 0; i < h; ++i) {\n        cin >> map[i];\n    }\n\n    m = 0;\n    int ri, rj;\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            if (map[i][j] == '*') {\n                dirty[m] = make_pair(i, j);\n                m++;\n                bfs(i, j);\n            } else if (map[i][j] == 'o') {\n                ri = i;\n                rj = j;\n                bfs(i, j);\n            }\n        }\n    }\n\n    sort(dirty, dirty + m);\n\n    int mincost = 4000;\n    do {\n        int cost = 0;\n        int i = ri;\n        int j = rj;\n        for (int k = 0; k < m; ++k) {\n            int toi = dirty[k].first;\n            int toj = dirty[k].second;\n            cost += d[i][j][toi][toj];\n            if (d[i][j][toi][toj] == -1) {\n                mincost = -1;\n                break;\n            }\n            i = toi;\n            j = toj;\n        }\n        mincost = min(cost, mincost);\n    } while (next_permutation(dirty, dirty + m));\n\n    cout << mincost << endl;\n}\n\nint main() {\n    while (1) {\n        cin >> w >> h;\n        if (w == 0) break;\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define mp make_pair\n#define pb push_back\n#define EB emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint w,h;\n\nvoid solve(){\n    char c[32][32];\n    rep(i,h) scanf(\"%s\",c[i]);\n\n    int sx,sy;\n    rep(i,h) rep(j,w) if(c[i][j]=='o'){\n        sx = i;\n        sy = j;\n        break;\n    }\n\n    int g[512][512];\n    rep(i,512) rep(j,512) g[i][j]=INF;\n    rep(i,512) g[i][i]=0;\n\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(c[i][j]=='x') continue;\n            int v = i*w+j;\n            for(int k=0;k<4;k++){\n                int nx=i+dx[k],ny=j+dy[k];\n                if(nx<0||ny<0||nx>=h||ny>=w) continue;\n                if(c[nx][ny]=='x') continue;\n                int nv = nx*w+ny;\n                g[v][nv] = 1;\n                g[nv][v] = 1;\n            }\n        }\n    }\n\n    int V = h*w;\n    for(int k=0;k<V;k++){\n        for(int i=0;i<V;i++){\n            for(int j=0;j<V;j++){\n                g[i][j] = min(g[i][j],g[i][k]+g[k][j]);\n            }\n        }\n    }\n\n    vector<int> as;\n    rep(i,h) rep(j,w){\n        int v = i*w+j;\n        if(c[i][j]=='*') as.pb(v);\n    }\n\n    sort(all(as));\n\n    assert(as.size()<=10);\n    int ans = INF;\n    do{\n        int tmp=0;\n        int now = sx*w+sy;\n        for(int i=0;i<sz(as);i++){\n            tmp += g[now][as[i]];\n            now = as[i];\n            if(g[now][as[i]]==INF){\n                cout << -1 << endl;\n                return;\n            }\n        }\n        //if(tmp==0){\n        //    //cerr << \"error\" << endl;\n        //    exit(1);\n        //}\n        ans = min(tmp,ans);\n    }while(next_permutation(all(as)));\n    if(ans==INF) cout << -1 << endl;\n    else cout << ans << endl;\n}\n\nint main(){\n    while(cin>>w>>h){\n        if(w==0 and h==0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iomanip>\n\n#define REP(i,n) for(i=0; i < (n); i++)\n#define REPONE(i, n) for(i=1; i <= (n); i++)\n#define LOOP(n) for(int loopCount=1; loopCount <= (n); loopCount++)\n#define ITER(c) __typeof((c).begin())\n#define EACH(c,it) for(ITER(c) it =(c).begin(); it!=(c).end(); it++)\n#define SZ(c) ((int) (c).size())\n#define ALL(c) c.begin(), c.end()\n#define SUM(c) accumulate(ALL(c), 0)\n#define EXIST(c,v) (find(ALL(c), (v)) != (c).end())\n#define PB push_back\n#define MP make_pair\n#define fs first\n#define sc second\n\nusing namespace std;\nstatic const double EPS = 1e-9;\nstatic const double PI = 3.141592653589793238462643383279;\ntypedef long long ll;\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\ninline int PtoN(int x, int y){\n    return 20*x + y;\n}\n\nint main(){\n    int w, h, i, j, d, st, best, dd, cur;\n    string line;\n    while(scanf(\"%d%d\\n\",&w,&h)){\n        if(!(w||h)) break;\n        vector<string> board;\n        vector< vector<int> > dist(400, vector<int>(400,1<<21));\n        vector<int> ds;\n        d = 0;\n        REP(i,h){\n            getline(cin,line);\n            board.PB(line);\n        }\n        REP(i,h)REP(j,w){\n            if(board[i][j]=='*'){\n                d++;\n                ds.PB(PtoN(j,i));\n            }\n            else if(board[i][j]=='o'){\n                st = PtoN(j,i);\n            }\n        }\n        sort(ALL(ds));\n        ds.PB(st);\n        REP(i,d+1){\n            queue< int > Q;\n            Q.push(1000*ds[i] + 0);\n            while(!Q.empty()){\n                int tp=Q.front();\n                int cd = tp/1000, cx=cd/20, cy=cd%20, dss=tp%1000;\n                REP(j,4){\n                    int x=cx+dx[j], y=cy+dy[j];\n                    if(0<=x && x<w && 0<=y && y<h &&\n                            board[y][x]!='x' &&\n                            dist[ds[i]][PtoN(x,y)]>(1<<20)){\n                        Q.push(1000*PtoN(x,y)+dss+1);\n                        dist[ds[i]][PtoN(x,y)] = dss+1;\n                    }\n                }\n                Q.pop();\n            }\n        }\n        ds.pop_back();\n        best = 1<<21;\n        do{\n            dd = 0;\n            cur = st;\n            REP(i,d){\n                dd += dist[cur][ds[i]];\n                if(dd>=best) goto end;\n                cur = ds[i];\n            }\n            best = dd;\nend:;\n        }while(next_permutation(ALL(ds)));\n        printf(\"%d\\n\",(best>(1<<20))?-1:best);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define all(a) a.begin(),a.end()\n#define INF 1e9\nusing P = pair<int,int>;\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nvector<vector<int>> cost_map(\n    int Y,int X,int sy,int sx,\n    vector<string> &s){\n\n    vector<vector<int>> cost(Y, vector<int>(X,INF));\n    cost[sy][sx] = 0;\n    queue<P> qu;\n    qu.push(P(sy,sx));\n    while(qu.size()){\n        P p = qu.front(); qu.pop();\n        int y = p.first;\n        int x = p.second;\n        rep(i,4){\n            int ny = y+dy[i];\n            int nx = x+dx[i];\n            if(nx<0 || ny<0 || nx>=X || ny>=Y) continue;\n            if(s[ny][nx] == 'x') continue;\n            if( cost[ny][nx] > cost[y][x] + 1){\n                cost[ny][nx] = cost[y][x] + 1;\n                qu.push(P(ny, nx));\n            }\n        }\n    }\n    return cost;\n}\n\nint main(void){\n    int Y,X;\n    while(cin>>X>>Y, Y|X){\n        vector<string> s(Y);\n        rep(y,Y) cin>>s[y];\n        vector<P> pos;\n        rep(y,Y)rep(x,X){\n            if(s[y][x]=='o' || s[y][x]=='*'){\n                pos.push_back(P(y,x));\n            }\n        }\n        int n = pos.size();\n        int d[11][11];\n        bool ng = false;\n        rep(i,n){\n            int y = pos[i].first;\n            int x = pos[i].second;\n            auto cost = cost_map(Y,X,y,x,s);\n            rep(j,n){\n                int ny = pos[j].first;\n                int nx = pos[j].second;\n                d[i][j] = cost[ny][nx];\n                if(d[i][j] == INF) ng = true;\n            }\n        }\n        if(ng){\n            cout<<-1<<endl;\n            continue;\n        }\n        vector<int> perm(n);\n        rep(i,n) perm[i] = i;\n        int res = INF;\n        do{\n            int sy = pos[perm[0]].first;\n            int sx = pos[perm[0]].second;\n            if(s[sy][sx] != 'o') continue;\n            int cost = 0;\n            rep(i,n-1){\n                cost += d[perm[i]][perm[i+1]];\n            }\n            res = min(res, cost);\n        }while(next_permutation(all(perm)));\n        cout<<res<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing pii = pair<int, int>;\n\nconstexpr int INF = (1 << 12);\nconstexpr int dir[5] = {0, 1, 0, -1, 0};\n\nbool ispower(int n)\n{\n    return n == (pow(2, static_cast<int>(log2(n))));\n}\n\nvoid bfs_dist(const vector<vector<int>>& room, const pii& pos, vector<int>& dist, const vector<pii>& dirty)\n{\n    const int h = room.size();\n    const int w = room[0].size();\n    vector<vector<bool>> checked(h, vector<bool>(w, false));\n    queue<pair<pii, int>> q;\n    q.push(make_pair(pos, 0));\n    while (not q.empty()) {\n        const pii p = q.front().first;\n        const int distance = q.front().second;\n        const int pi = p.first;\n        const int pj = p.second;\n        for (int i = 0; i < dirty.size(); i++) {\n            if (p == dirty[i] and (not checked[pi][pj])) {\n                dist[i] = distance;\n            }\n        }\n        checked[pi][pj] = true;\n        q.pop();\n        for (int d = 0; d < 4; d++) {\n            const int newi = pi + dir[d];\n            const int newj = pj + dir[d + 1];\n            if (0 <= newi and newi < h and 0 <= newj and newj < w) {\n                if (room[newi][newj] != -1 and (not checked[newi][newj])) {\n                    q.push(make_pair(make_pair(newi, newj), distance + 1));\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        int h, w;\n        cin >> w >> h;\n        if (w == 0 and h == 0) {\n            break;\n        }\n        vector<vector<int>> room(h, vector<int>(w));\n\n        pii start;\n        vector<pii> dirty;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                char c;\n                cin >> c;\n                if (c == '.') {\n                    room[i][j] = 0;\n                } else if (c == '*') {\n                    room[i][j] = 1;\n                    dirty.push_back(make_pair(i, j));\n                } else if (c == 'x') {\n                    room[i][j] = -1;\n                } else {\n                    room[i][j] = 0;\n                    start.first = i;\n                    start.second = j;\n                }\n            }\n        }\n\n        const int dirtynum = dirty.size();\n        vector<vector<int>> dist(dirtynum, vector<int>(dirtynum, INF));\n        vector<int> initdist(dirtynum, INF);\n        bfs_dist(room, start, initdist, dirty);\n        for (int i = 0; i < dirtynum; i++) {\n            bfs_dist(room, dirty[i], dist[i], dirty);\n        }\n\n        for (int i = 0; i < dirtynum; i++) {\n            if (initdist[i] == INF) {\n                cout << -1 << endl;\n                return 0;\n            }\n        }\n\n        const int maximum = 1 << dirtynum;\n        vector<vector<int>> dp(maximum, vector<int>(dirtynum, INF));  // dp[visited[last]\n        for (int n = 1; n < maximum; n++) {\n            for (int i = 0; i < dirtynum; i++) {\n                if ((n >> i) % 2) {\n                    for (int j = 0; j < dirtynum; j++) {  //i->j\n                        if ((n >> j) % 2) {\n                            if (i == j) {\n                                if (ispower(n)) {\n                                    dp[n][i] = initdist[i];\n                                }\n                                continue;\n                            }\n                            dp[n][j] = min(dp[n][j], dp[n - (1 << j)][i] + dist[i][j]);\n                        }\n                    }\n                }\n            }\n        }\n        int mini = INF;\n        for (int i = 0; i < dirtynum; i++) {\n            mini = min(mini, dp[maximum - 1][i]);\n        }\n        cout << mini << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n\nclass DP{\npublic:\n\tint cost, x, y, bits;\n\t\n\tDP(){}\n\tDP(int xx, int yy, int b, int cc){\n\t\tcost = cc;x=xx;y=yy;bits=b;\n\t}\n\t\n\tbool operator< (const DP &opp) const {\n\t\treturn cost>opp.cost;\n\t}\n};\n\nint dr[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\nunsigned int memo[1<<10][31][31];\nint Map[31][31];\nint W, H;\nmain(){\n\tint i,j;\n\twhile(cin >> W >> H, W){\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tmemset(Map, -1, sizeof(Map));\n\t\tint d = 0;\n\t\tint sx, sy;\n\t\tREP(i, H)REP(j, W){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif(c == '.' || c=='o') Map[i+1][j+1] = 0;\n\t\t\tif(c == '*') Map[i+1][j+1] = ++d;\n\t\t\tif(c == 'o') sx = j+1, sy = i+1;\n\t\t}\n\t\tpriority_queue<DP> dp;\n\t\tDP S;\n\t\tdp.push(DP(sx, sy, 0, 0));\n\t\twhile(!dp.empty()){\n\t\t\tS = dp.top();\n\t\t\tdp.pop();\n\n\t\t\tif(S.bits == (1<<d)-1) break;\n\t\t\tREP(i, 4){\n\t\t\t\tDP T=S;\n\t\t\t\tT.x += dr[i][0];\n\t\t\t\tT.y += dr[i][1];\n\t\t\t\tif(Map[T.y][T.x] == -1) continue;\n\t\t\t\tif(Map[T.y][T.x]) T.bits |= 1 << (Map[T.y][T.x]-1);\n\t\t\t\tT.cost ++;\n\t\t\t\tif(memo[T.bits][T.x][T.y] <= T.cost) continue;\n\t\t\t\tmemo[T.bits][T.x][T.y] = T.cost;\n\t\t\t\tdp.push(T);\n\t\t\t}\n\t\t}\n\t\tif(S.bits == (1<<d)-1) cout << S.cost << endl;\n\t\telse cout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nint vis[25][25],n,m,dust,cnt,mov[4][2]= {1,0,0,-1,-1,0,0,1},stx,sty,cost,tx,ty,visp[25][25],lp;\nchar plate[25][25];\n\nstruct status\n{\n    int cnt;\n    int x,y;\n    status(int a,int b,int c)\n    {\n        x = a, y = b, cnt = c;\n    }\n};\n\nvoid maek(int x,int y)\n{\n    vis[x][y] = 1;\n    if(plate[x][y] == '*') cnt++ ;\n    for(int i=0; i<4; i++)\n        if(x + mov[i][0] >= 0 && x + mov[i][0] < m && y + mov[i][1] >=0 && y + mov[i][1] < n && plate[x + mov[i][0]][y + mov[i][1]] != 'x' && !vis[x + mov[i][0]][y + mov[i][1]])\n            maek(x + mov[i][0],y + mov[i][1]);\n}\n\nqueue<struct status> q;\n\nvoid bfs(int x,int y,int &xx,int &yy)\n{\n    if(plate[x][y]=='*' && !visp[x][y])\n    {\n        cost = q.front().cnt;\n        visp[x][y] = 1, xx = x, yy= y;\n        return ;\n    }\n    for(int i=0; i<4; i++)\n    {\n        int tx = x + mov[i][0], ty = y + mov[i][1];\n        if(tx >= 0 && tx < m && ty >= 0 && ty < n && !vis[tx][ty] && plate[tx][ty] != 'x')\n        {\n            struct status t1 = q.front();\n            struct status t2(tx, ty, t1.cnt+1);\n            q.push(t2);\n            vis[tx][ty] = 1;\n        }\n    }\n    q.pop();\n    bfs(q.front().x, q.front().y, xx, yy);\n}\n\n\nint main()\n{\n    while(~scanf(\"%d%d\",&n,&m),n+m)\n    {\n        memset(vis, 0, sizeof(vis)), memset(visp, 0, sizeof(visp)), memset(plate, 0, sizeof(plate));\n        getchar();\n        lp = 0, cnt = 0;\n\n        for(int i=0; i<m; i++)\n        {\n            for(int j=0; j<n; j++)\n            {\n                scanf(\"%c\",&plate[i][j]);\n                if(plate[i][j]=='o') stx = i, sty = j;\n                if(plate[i][j]=='*') lp++;\n            }\n            getchar();\n        }\n        maek(stx,sty);\n\n        if(cnt != lp) printf(\"-1\\n\");\n        else\n        {\n            int sum = 0,rx,ry;\n            for(int i=0; i<lp; i++)\n            {\n                struct status temp(stx,sty,0);\n                q.push(temp);\n                memset(vis,0,sizeof(vis));\n                vis[stx][sty] = 1;\n                bfs(stx,sty,rx,ry);\n                sum += cost;\n                stx = rx, sty = ry;\n                while(!q.empty()) q.pop();\n            }\n            printf(\"%d\\n\",sum);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct st{\n  int x,y,b,d;\n  st(int x,int y,int b,int d):x(x),y(y),b(b),d(d){}\n};\nint main(){\n  int w,h;\n  while(cin>>w>>h,w||h){\n    char m[h][w];\n    int i,j,k,b,ans=1<<28,x,y;\n    typedef pair<int,int> P;\n    vector<P> v;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tcin >> m[i][j];\n\tif(m[i][j]=='o') x=j,y=i,m[i][j]='.';\n\tif(m[i][j]=='*') v.push_back(P(j,i));\n      }\n    }\n    int n=v.size();\n    bool used[h][w][1<<n];\n    memset(used,0,sizeof(used));\n    queue<st> q;\n    int ax[]={1,-1,0,0};\n    int ay[]={0,0,1,-1};\n    q.push(st(x,y,0,0));\n    while(!q.empty()){\n      st s=q.front();q.pop();\n      if(s.x<0||w<=s.x||s.y<0||h<=s.y) continue;\n      if(m[s.y][s.x]=='x') continue;\n      if(used[s.y][s.x][s.b]) continue;\n      used[s.y][s.x][s.b]=true;\n      if(s.b==(1<<n)-1) {\n\tans=min(ans,s.d);\n\tcontinue;\n      }\n      for(k=0;k<4;k++){\n\tx=s.x+ax[k];y=s.y+ay[k];b=s.b;\n\tfor(i=0;i<n;i++)\n\t  if(x==v[i].first&&y==v[i].second) b|=(1<<i);\n\tq.push(st(x,y,b,s.d+1));\n      }\n    }\n    \n    if(ans==(1<<28)) cout << -1 << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <complex>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define EPS 1e-8\n#define DEB 0\n\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {-1,0,1,0};\nint w,h,sx,sy;\nchar field[32][32];\nvector<pair<int,int> > t_node;\nint node[16][16],visited[16][16];\nint dp[1<<10][16];\n\nint main(){\n\t\n\twhile(scanf(\" %d%d \",&w,&h),w|h){\n\t\tmemset(node,0,sizeof(node));\n\t\trep(i,1<<10)rep(j,16)dp[i][j]=INT_MAX;\n\t\t\n\t\tt_node.clear();\n\t\trep(i,h){\n\t\t\tscanf(\"%s\",field[i]);\n\t\t\trep(j,w){\n\t\t\t\tif( field[i][j]=='o' ){\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}else if( field[i][j]=='*' ){\n\t\t\t\t\tt_node.push_back(mp(j,i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( t_node.size()==0 ){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tt_node.push_back(mp(sx,sy));\n#if DEB\n\t\trep(i,t_node.size()){\n\t\t\tprintf(\"(%d,%d)\\n\",t_node[i].first, t_node[i].second);\n\t\t}\n#endif\t\n\t\t\n\n\t\t// make node (bfs)\n\t\trep(i,t_node.size()){\n\t\t\tmemset(visited,-1,sizeof(visited));\n\t\t\tqueue<pair<int,int> > q;\n\t\t\tq.push(mp(t_node[i].first, t_node[i].second));\n\t\t\tvisited[t_node[i].second][t_node[i].first] = 0;\n\t\t\twhile( !q.empty() ){\n\t\t\t\tint x = q.front().first;\n\t\t\t\tint y = q.front().second;\n\t\t\t\tint c = visited[y][x];\n\t\t\t\tq.pop();\n\t\t\t\trep(k,4){\n\t\t\t\t\tint tx = x + dx[k];\n\t\t\t\t\tint ty = y + dy[k];\n\t\t\t\t\tif( tx<0 || ty<0 || tx>=w || ty>=h || field[ty][tx]=='x' || visited[ty][tx]!=-1 )continue;\n\t\t\t\t\tvisited[ty][tx] = c+1;\n\t\t\t\t\tq.push(mp(tx,ty));\n\t\t\t\t}\n\t\t\t}\n#if DEB\n\t\t\trep(j,h){\n\t\t\t\trep(k,w){\n\t\t\t\t\tprintf(\"%d \",visited[j][k]);\n\t\t\t\t}\n\t\t\t\tputs(\"\");\n\t\t\t}\n\t\t\tputs(\"\");\n#endif\t\t\t\n\t\t\t\n\t\t\trep(j,t_node.size())if( i!=j ){\n\t\t\t\tnode[i][j] = visited[t_node[j].second][t_node[j].first];\n\t\t\t}\n\t\t}\n\n#if DEB\t\t\n\t\trep(i,5){\n\t\t\trep(j,5){\n\t\t\t\tprintf(\"%d \",node[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\tputs(\"\");\n#endif\t\t\n\t\t\t\n\n#if DEB\n\t\trep(i,h){\n\t\t\tputs(field[i]);\n\t\t}puts(\"\");\n#endif\n\n\t\tint n = t_node.size();\n\t\tint ans = INT_MAX;\n\t\tdp[0][n-1] = 0;\n\t\trep(i,n-1){ //kosuu\n\t\t\trep(j,1<<(n-1)){ //bit dp\n\t\t\t\trep(k,n)if( dp[j][k]!=INT_MAX ){ //now node\n\t\t\t\t\trep(l,n-1)if( !((1<<l)&j) && node[k][l] ){\n\t\t\t\t\t\tdp[j|(1<<l)][l] = min(dp[j|(1<<l)][l], dp[j][k]+node[k][l]);\n\t\t\t\t\t\tif( (j|(1<<l))==((1<<(n-1))-1) ){\n\t\t\t\t\t\t\tans = min(ans, dp[(1<<(n-1))-1][l]);\n\t\t\t\t\t\t}\n#if DEB\n\t\t\t\t\t\tprintf(\"bit:%d  , %d --> %d  , cost:%d\\n\",j|(1<<l),k,l,dp[j|(1<<l)][l]);\n#endif\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#if DEB\n\t\tprintf(\"%d\\n\",(1<<(n-1))-1);\n#endif\t\t\n\t\tprintf(\"%d\\n\",ans==INT_MAX ? -1 : ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n#include <bitset>\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = {-1,0,1,0}; const int dy[] = {0,1,0,-1};\n\nconst int MAXW = 20 + 2;\nconst int MAXH = 20 + 2;\n\n#define INF 1e9\n\nchar field[MAXH][MAXW];\n\nstruct P{\n    int p, cost, reach;\n\n    bool operator > (const P& p) const {\n        return cost > p.cost;\n    }\n};\n\nstruct Q{\n    int x, y, cost;\n};\n\nstruct Edge{\n    int p, cost;\n};\n\nint main() {\n    int w, h;\n    while(cin >> w >> h, w|h){\n        fill_n((char *)field, (MAXH) * (MAXW), 'X');\n\n        int robot;\n        vector<pii> gb;\n\n        REP(y, h){\n            REP(x, w) {\n                char c;\n                cin >> c;\n                switch(c){\n                    case 'o':\n                        robot = gb.size();\n                    case '*':\n                        gb.push_back({x + 1, y + 1});\n                        break;\n                }\n                field[y + 1][x + 1] = c;\n            }\n        }\n\n        vector<vector<Edge>> E(gb.size() + 1);\n\n        REP(i, gb.size()){\n            pii p = gb[i];\n            queue<Q> que;\n            que.push({p.first, p.second, 0});\n            bool reach[MAXH][MAXW] = {false};\n            while(!que.empty()){\n                Q q = que.front(); que.pop();\n                reach[q.y][q.x] = true;\n\n                REP(j, 4){\n                    int sx = q.x + dx[j];\n                    int sy = q.y + dy[j];\n                    switch(field[sy][sx]){\n                        case '*':\n                            if(!reach[sy][sx]) {\n                                REP(idx, gb.size()) {\n                                    if (gb[idx].first == sx && gb[idx].second == sy) {\n                                        E[i].push_back({idx, q.cost + 1});\n                                        break;\n                                    }\n                                }\n                            }\n                        case '.':\n                        case 'o':\n                            if(!reach[sy][sx]) {\n                                reach[sy][sx] = true;\n                                que.push({sx, sy, q.cost + 1});\n                            }\n                            break;\n                    }\n                }\n            }\n        }\n        if(E[robot].size() < gb.size() - 1){\n            cout << -1 << endl;\n            continue;\n        }\n\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push({robot, 0, (1 << robot)});\n        vvi G(gb.size() + 1, vi(1<<gb.size() , INF));\n        G[robot][(1 << robot)] = 0;\n\n        while(!que.empty()){\n            P p = que.top(); que.pop();\n\n//            LOG(\"%d, %d|||||| cost:%d reach:\", gb[p.p].first, gb[p.p].second, p.cost);\n//            cout << static_cast<bitset<10>>(p.reach) << endl;\n\n            if(p.reach == (1 << gb.size()) - 1){\n                cout << p.cost << endl;\n                break;\n            }\n\n            for(Edge e : E[p.p]){\n                int next_cost = p.cost + e.cost;\n                int next_reach = p.reach | (1 << e.p);\n                if (G[e.p][next_reach] > next_cost){\n                    G[e.p][next_reach] = next_cost;\n                    if(p.reach & (1<<e.p)) continue;\n                    que.push({e.p, next_cost, next_reach});\n                }\n            }\n        }\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint index(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint main()\n{\n\tint w, h;\n\twhile (cin >> w >> h, w)\n\t{\n\t\tvs fld(h);\n\t\tREP(i, h) cin >> fld[i];\n\t\tint src;\n\t\tvi v;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == 'o') src = index(i, j, w);\n\t\t\tif (fld[i][j] == '*') v.push_back(index(i, j, w));\n\t\t}\n\t\tif (v.size() == 0)\n\t\t{\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\t\tint dis[400][400];\n\t\tint V = h*w;\n\t\tREP(i, V)REP(j, V) dis[i][j] = (i == j ? 0 : INF);\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == 'x') continue;\n\t\t\tREP(k, 4)\n\t\t\t{\n\t\t\t\tint nx = i + dx[k], ny = j + dy[k];\n\t\t\t\tif (valid(nx, ny, h, w) && fld[nx][ny] != 'x') dis[index(i, j, w)][index(nx, ny, w)] = 1;\n\t\t\t}\n\t\t}\n\t\tREP(k, V)REP(i, V)REP(j, V) chmin(dis[i][j], dis[i][k] + dis[k][j]);\n\t\tsort(ALL(v));\n\t\tint ans = INF;\n\t\tdo\n\t\t{\n\t\t\tint cnt = 0;\n\t\t\tint tmp = src;\n\t\t\tint next = v[0];\n\t\t\tREP(i, v.size()-1)\n\t\t\t{\n\t\t\t\tcnt += dis[tmp][next];\n\t\t\t\ttmp = v[i];\n\t\t\t\tnext = v[i + 1];\n\t\t\t}\n\t\t\tcnt += dis[tmp][next];\n\t\t\tchmin(ans, cnt);\n\t\t} while (next_permutation(ALL(v)));\n\t\tcout << (ans == INF ? -1 : ans) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<queue>\n#include<algorithm>\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define INF 100000000\nusing namespace std;\ntypedef pair<int,int> P;\nvector<string> s;\nint w,h;\nvector<P> p;\nvector<vector<int> > dist;\nmap<P,int> mp;\nvector<int> dp;\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nbool inf(int y,int x){\n\tif(x>=0&&x<w&&y>=0&&y<h)\n\treturn true;\n\treturn false;\n}\nint TSP(int now,int bit){\n\tif(bit==(1<<p.size())-1){\n\t\treturn 0;\n\t}\n\tif(dp[bit]!=-1)\n\t\treturn dp[bit];\n\tint ret=INF;\n\tfor(int i=1;i<p.size();i++){\n\t\tif( !( (1<<i) &bit ) ){\n\t\t\tret=min(TSP(i,bit|(1<<i))+dist[now][i],ret);\n\t\t}\n\t}\n\t\n\treturn dp[bit]=ret;\n}\nint main(){\n\twhile(cin>>w>>h,w||h){\n\t\t\n\t\ts.resize(h);\n\t\tp.resize(1);\n\t\tmp.clear();\n\t\tp[0]=P(0,0);\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>s[i];\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(s[i][j]=='o'){\n\t\t\t\t\tp[0]=P(i,j);\n\t\t\t\t\tmp[P(i,j)]=0;\n\t\t\t\t}else if(s[i][j]=='*'){\n\t\t\t\t\tmp[P(i,j)]=p.size();\n\t\t\t\t\tp.pb(P(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdist=vector<vector<int> >(p.size(),vector<int>(p.size(),INF));\n\t\tbool flag=true;\n\t\tfor(int i=0;i<p.size();i++){\n\t\t\tqueue<P> que;\n\t\t\tvector<vector<int> > d(h,vector<int>(w,INF));\n\t\t\tvector<vector<bool> > used(h,vector<bool>(w,false));\n\t\t\td[p[i].first][p[i].second]=0;\n\t\t\tque.push(p[i]);\n\t\t\tint cnt=0;\n\t\t\twhile(!que.empty()){\n\t\t\t\t\n\t\t\t\tP t=que.front();\n\t\t\t\tque.pop();\n\t\t\t\tif(used[t.first][t.second]){\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(find(all(p),t)!=p.end()&&dist[i][mp[t]]==INF){\n\t\t\t\t\tdist[i][mp[t]]=d[t.first][t.second];\n\t\t\t\t\tcnt++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tused[t.first][t.second]=true;\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint nx=dx[i]+t.second,ny=dy[i]+t.first;\n\t\t\t\t\tif(inf(ny,nx)&&!used[ny][nx]&&d[ny][nx]==INF&&s[ny][nx]!='x'){\n\t\t\t\t\t\tque.push(P(ny,nx));\n\t\t\t\t\t\td[ny][nx]=d[t.first][t.second]+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt!=p.size()){\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag){\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tdp=vector<int>((1<<p.size()),-1);\n\t\tcout<<TSP(0,1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint v[5]={0,1,0,-1,0};\nint main()\n{\n\tint w,h;\n\twhile(cin>>w>>h,w)\n\t{\n\t\tstring c[20];\n\t\tfor(int i=0;i<h;i++)cin>>c[i];\n\t\tint d[20][20][20][20]={};\n\t\tfor(int ix=0;ix<h;ix++)for(int iy=0;iy<w;iy++)\n\t\t\tfor(int jx=0;jx<h;jx++)for(int jy=0;jy<w;jy++)\n\t\t\t\tif(ix!=jx||iy!=jy)d[ix][iy][jx][jy]=1<<28;\n\t\tvector<pair<int,int> > a;\n\t\tint sx,sy;\n\t\tfor(int i=0;i<h;i++)\n\t\t{\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t{\n\t\t\t\tif(c[i][j]=='x')continue;\n\t\t\t\telse if(c[i][j]=='*')a.push_back(make_pair(i,j));\n\t\t\t\telse if(c[i][j]=='o')sx=i,sy=j;\n\t\t\t\tint x=i,y=j;\n\t\t\t\tfor(int r=0;r<4;r++)\n\t\t\t\t{\n\t\t\t\t\tint tx=x+v[r];\n\t\t\t\t\tint ty=y+v[r+1];\n\t\t\t\t\tif(tx<0||ty<0||tx>=h||ty>=w||c[tx][ty]=='x')continue;\n\t\t\t\t\td[x][y][tx][ty]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int kx=0;kx<h;kx++)\n\t\t{\n\t\t\tfor(int ky=0;ky<w;ky++)\n\t\t\t{\n\t\t\t\tfor(int ix=0;ix<h;ix++)\n\t\t\t\t{\n\t\t\t\t\tfor(int iy=0;iy<w;iy++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int jx=0;jx<h;jx++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int jy=0;jy<w;jy++)\n\t\t\t\t\t\t\t{\n\t\td[ix][iy][jx][jy]=min(d[ix][iy][jx][jy],d[ix][iy][kx][ky]+d[kx][ky][jx][jy]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint n=a.size();\n\t\tint dis[99][99]={};\n\t\tbool endflag=false;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tdis[0][i+1]=dis[i+1][0]=d[sx][sy][a[i].first][a[i].second];\n\t\t\tif(dis[0][i+1]==1<<28)endflag=true;\n\t\t}\n\t\tif(endflag)\n\t\t{\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint ix=a[i].first,iy=a[i].second;\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(i==j)continue;\n\t\t\t\tint jx=a[j].first,jy=a[j].second;\n\t\t\t\tdis[i+1][j+1]=d[ix][iy][jx][jy];\n\t\t\t}\n\t\t}\n\t\tn++;\n\t\tint dp[99][2050];\n\t\tfor(int j=0;j<n;j++)for(int i=0;i<1<<n;i++)dp[j][i]=1<<28;\n\t\tdp[0][0]=0;\n\t\tfor(int i=0;i<1<<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(!((i>>j)&1))\n\t\t\t\t{\n\t\t\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif((i>>k)&1||i==0)\n\t\t\t\t\tdp[j][i|1<<j]=min(dp[j][i|1<<j],dp[k][i]+dis[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mind=1<<28;\n\t\tfor(int i=0;i<n;i++)mind=min(mind,dp[i][(1<<n)-1]);\n\t\tcout<<(mind==1<<28?-1:mind)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\n#define int i64\n\nint w,h;\n\nvector<int> ans;\n\nsigned main(){\n\twhile(cin >> w >> h,w || h){\n\t\tvector<vector<int>> fie(h,vector<int>(w,0));\n\t\tvector<P> dust;\n\t\tint sx,sy;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tstring s;\n\t\t\tcin>> s;\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(s[j] == '*'){\n\t\t\t\t\tdust.push_back({i,j});\n\t\t\t\t\tfie[i][j] = dust.size();\n\t\t\t\t}\n\t\t\t\tif(s[j] == 'x'){\n\t\t\t\t\tfie[i][j] = -1;\n\t\t\t\t}\n\t\t\t\tif(s[j] == 'o'){\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusing P2 = pair<int,P>;\n\t\tvector<vector<int>> dist(dust.size(),vector<int>(dust.size() , 1e9));\n\n\t\tint dx[] = {1,-1,0,0};\n\t\tint dy[] = {0,0,1,-1};\n\n\t\tfor(int s = 0;s < dust.size();s++){\n\t\t\tqueue<P2> que;\n\t\t\tque.push({0,dust[s]});\n\t\t\tvector<vector<int>> vis(h,vector<int>(w,0));\n\t\t\tvis[dust[s].first][dust[s].second] = 1;\n\t\t\twhile(!que.empty()){\n\t\t\t\tint d = que.front().first;\n\t\t\t\tP p = que.front().second;\n\t\t\t\tif(fie[p.first][p.second] > 0){\n\t\t\t\t\tdist[s][fie[p.first][p.second] - 1] = d;\n\t\t\t\t}\n\t\t\t\tque.pop();\n\t\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\t\tint nx = p.first + dx[i];\n\t\t\t\t\tint ny = p.second + dy[i];\n\t\t\t\t\tif(0 <= nx && nx < h && 0 <= ny && ny < w && fie[nx][ny] != -1 && vis[nx][ny] == 0){\n\t\t\t\t\t\tvis[nx][ny] = 1;\n\t\t\t\t\t\tque.push({d + 1,{nx,ny}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int>> dp(1 << dust.size(),vector<int>(dust.size(),1e9));\n\t\t{\n\t\t\tqueue<P2> que;\n\t\t\tque.push({0,{sx,sy}});\n\t\t\tvector<vector<int>> vis(h,vector<int>(w,0));\n\t\t\tvis[sx][sy] = 1;\n\t\t\twhile(!que.empty()){\n\t\t\t\tint d = que.front().first;\n\t\t\t\tP p = que.front().second;\n\t\t\t\tif(fie[p.first][p.second] > 0){\n\t\t\t\t\tdp[(1 << (fie[p.first][p.second] - 1))][fie[p.first][p.second] - 1] = d;\n\t\t\t\t}\n\t\t\t\tque.pop();\n\t\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\t\tint nx = p.first + dx[i];\n\t\t\t\t\tint ny = p.second + dy[i];\n\t\t\t\t\tif(0 <= nx && nx < h && 0 <= ny && ny < w && fie[nx][ny] != -1 && vis[nx][ny] == 0){\n\t\t\t\t\t\tvis[nx][ny] = 1;\n\t\t\t\t\t\tque.push({d + 1,{nx,ny}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1;i < (1 << dust.size()) - 1;i++){\n\t\t\tfor(int j = 0;j < dust.size();j++){\n\t\t\t\tif(i & (1 << j)) continue;\n\t\t\t\tfor(int k = 0;k < dust.size();k++){\n\t\t\t\t\tif(j == k) continue;\n\t\t\t\t\tif((i & (1 << k))){\n\t\t\t\t\t\t//j <- k\n\t\t\t\t\t\tdp[i | (1 << j)][j] = min(dp[i | (1 << j)][j] , dp[i][k] + dist[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint result = 1e9;\n\t\tfor(int i = 0;i < dust.size();i++){\n\t\t\tresult = min(result , dp[(1 << dust.size()) - 1][i]);\n\t\t}\n\t\tif(result >= 1e9) result = -1;\n\t\tans.push_back(result);\n\t}\n\tfor(int a : ans){\n\t\tcout << a << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\nstruct aa\n{\n\tint y;\n\tint x;\n\tint turn;\n};\nint main() {\n\twhile (1) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (!W)break;\n\t\tvector<vector<int>>field(H + 2, vector<int>(W+2));\n\t\tint sx, sy;\n\t\tvector<pair<int, int>>dirtys;\n\t\tfor (size_t i = 0; i < H; i++)\n\t\t{\n\t\t\tstring st; cin >> st;\n\t\t\tfor (size_t j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (st[j] == 'o') {\n\t\t\t\t\tfield[i + 1][j + 1] = true;\n\t\t\t\t\tsx = j + 1;\n\t\t\t\t\tsy = i + 1;\n\t\t\t\t}\n\t\t\t\telse if (st[j] == '*') {\n\t\t\t\t\tfield[i + 1][j + 1] = true;\n\t\t\t\t\tdirtys.push_back(make_pair(i + 1, j + 1));\n\t\t\t\t}\n\t\t\t\telse if (st[j] == 'x') {\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfield[i + 1][j + 1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdirtys.push_back(make_pair(sy, sx));\n\t\tvector<vector<int>>times(dirtys.size(), vector<int>(dirtys.size(),99999999));\n\t\tfor (int from = 0; from  < dirtys.size(); ++from) {\n\t\t\tqueue<aa>que;\n\t\t\tvector<vector<int>>memo(H + 2, vector<int>(W + 2,9999999));\n\t\t\tque.push(aa{ dirtys[from].first,dirtys[from].second,0 });\n\t\t\twhile (!que.empty()) {\n\t\t\t\taa atop(que.front());\n\t\t\t\tque.pop();\n\t\t\t\tfor (size_t i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\tconst int nx = atop.x + dx[i];\n\t\t\t\t\tconst int ny = atop.y + dy[i];\n\t\t\t\t\tif (field[ny][nx] && memo[ny][nx]>atop.turn + 1) {\n\t\t\t\t\t\tmemo[ny][nx] = atop.turn + 1;\n\t\t\t\t\t\tque.push(aa{ ny,nx,atop.turn + 1 });\n\t\t\t\t\t\tauto it = find(dirtys.begin(), dirtys.end(), make_pair(ny, nx));\n\t\t\t\t\t\tif (it != dirtys.end()) {\n\t\t\t\t\t\t\ttimes[from][it - dirtys.begin()] = atop.turn + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>perms(dirtys.size() - 1);\n\t\tiota(perms.begin(), perms.end(), 0);\n\t\tlong long int ans = 9999999;\n\t\tdo\n\t\t{\n\t\t\tlong long int ntime = 0;\n\t\t\tntime += times[dirtys.size() - 1][perms[0]];\n\t\t\tfor (size_t i = 0; i < perms.size()-1; i++)\n\t\t\t{\n\t\t\t\tntime += times[perms[i]][perms[i + 1]];\n\t\t\t}\n\t\t\tans = min(ans, ntime);\n\t\t} while (next_permutation(perms.begin(),perms.end()));\n\t\tif (ans > 9999998) {\n\t\t\tans = -1;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cctype>\n#include<queue>\n#include<algorithm>\n#include<map>\nusing namespace std;\nint d[11][11],x[11],y[11],V=9999;\nchar m[22][22],*_;\nvoid F(int x,int y)\n{\n\ttypedef pair<int,int>P;\n\tqueue<P>q;\n\tP p;\n\tq.push(P(x,y));\n\tq.push(P(-1,-1));\n\tint r=0,f[22][22]={0},i=m[y][x]-'/',c;\n\twhile(q.size()>1)\n\t{\n\t\tp=q.front();q.pop();\n\t\tx=p.first,y=p.second;\n\t\tif(x<0){++r;q.push(p);continue;\t}\n\t\tif(m[y][x]=='x' || f[y][x]++)continue;\n\t\tif(m[y][x]=='/'||isdigit(m[y][x]))c=m[y][x]-'/',d[i][c]=d[c][i]=r;\n\t\tq.push(P(x+1,y));q.push(P(x-1,y));q.push(P(x,y+1));q.push(P(x,y-1));\n\t}\n}\nint main()\n{\n\tint w,h,i,j,c;\n\twhile(cin>>w>>h,w)\n\t{\n\t\tfor(c=0,i=1;i<=h;++i)\n\t\t{\n\t\t\tcin>>m[i]+1;\n\t\t\tfor(_=m[i]+1;_=strpbrk(_,\"o*\");++_)\n\t\t\t{\n\t\t\t\tif(*_=='o')*_='/';\n\t\t\t\telse *_=c+++'0';\n\t\t\t\tx[*_-'/']=_-m[y[*_-'/']=i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<=h+1;++i)m[i][0]=m[i][w+1]='x';\n\t\tfor(j=0;j<=w+1;++j)m[0][j]=m[h+1][j]='x';\n\t\tfor(i=0;i<=c;++i)for(j=0;j<=c;++j)d[i][j]=V;\n\t\tfor(i=0;i<=c;++i)F(x[i],y[i]);\n\t\tint r=V,s,a[]={0,1,2,3,4,5,6,7,8,9,10};\n\t\tdo\n\t\t{\n\t\t\tfor(s=i=0;i<c;++i)s+=d[a[i]][a[i+1]];\n\t\t\tr=min(r,s);\n\t\t}while(next_permutation(a+1,a+c+1));\n\t\tcout<<(r-V?r:-1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nstruct State{\n    int y,x,dist;\n    State(int y,int x,int dist) : y(y),x(x),dist(dist) {};\n};\nconst int INF = 1<<30;\n\nint main(){\n    while(true){\n        int w,h;\n        cin >> w >> h;\n        if(w == 0 and h == 0) break;\n        vector<string> field(h);\n        vector<pii> duty;\n        map<pii,int> dutymap;\n        pii me;\n\n        for(int i=0;i<h;i++){\n            cin >> field[i];\n            for(int j=0;j<w;j++){\n                if(field[i][j] == '*'){\n                    duty.push_back(pii(i,j));\n                    dutymap[pii(i,j)] = duty.size()-1;\n                }else if(field[i][j] == 'o'){\n                    me.first=i,me.second=j;\n                }\n            }\n        }\n        vector<int> medist(duty.size(),INF);\n        {\n            queue<State> q;\n            q.push(State(me.first,me.second,0));\n            vector<vector<char> > used(h,vector<char>(w,false));\n\n            while(not q.empty()){\n                int y = q.front().y;\n                int x = q.front().x;\n                int dist = q.front().dist;\n                q.pop();\n                if(used[y][x]) continue;\n                used[y][x] = true;\n                if(dutymap.find(pii(y,x)) != dutymap.end()){\n                    medist[dutymap[pii(y,x)]] = dist;\n                }\n                for(int i=0;i<4;i++){\n                    int ny = y + dy[i];\n                    int nx = x + dx[i];\n                    if(ny < 0 or ny >= h or nx < 0 or nx >= w) continue;\n                    if(field[ny][nx] != 'x'){\n                        q.push(State(ny,nx,dist+1));\n                    }\n                }\n            }\n        }\n        vector<vector<int> > D(duty.size(),vector<int>(duty.size(),INF));\n        for(int d=0;d<duty.size();d++){\n            queue<State> q;\n            q.push(State(duty[d].first,duty[d].second,0));\n            vector<vector<char> > used(h,vector<char>(w,false));\n            while(not q.empty()){\n                int y = q.front().y;\n                int x = q.front().x;\n                int dist = q.front().dist;\n                q.pop();\n                if(used[y][x]) continue;\n                used[y][x] = true;\n                if(dutymap.find(pii(y,x)) != dutymap.end()){\n                    D[d][dutymap[pii(y,x)]] = dist;\n                }\n                for(int i=0;i<4;i++){\n                    int ny = y + dy[i];\n                    int nx = x + dx[i];\n                    if(ny < 0 or ny >= h or nx < 0 or nx >= w) continue;\n                    if(field[ny][nx] != 'x'){\n                        q.push(State(ny,nx,dist+1));\n                    }\n                }\n            }\n        }\n        // for(int i=0;i<duty.size();i++) D[i][i] = 0;\n        // for(int k=0;k<duty.size();k++){\n        //     for(int i=0;i<duty.size();i++){\n        //         for(int j=0;j<duty.size();j++){\n        //             D[i][j] = min(D[i][j],D[i][k]+D[k][j]);\n        //         }\n        //     }\n        // }\n        bool ok = true;\n        for(int i=0;i<duty.size();i++){\n            if(medist[i] == INF) ok = false;\n        }\n        for(int i=0;i<duty.size();i++){\n            for(int j=0;j<duty.size();j++){\n                if(D[i][j] == INF) ok = false;\n            }\n        }\n        if(ok){\n            int N = duty.size();\n            vector<vector<int> > DP(1 << N,vector<int>(N,INF));\n            for(int i=0;i<N;i++){\n                DP[1 << i][i] = medist[i];\n            }\n\n            for(int s=0;s < (1 << N);s++){\n                for(int now=0;now<N;now++){\n                    if(DP[s][now] == INF) continue;\n                    for(int k=0;k<N;k++){\n                        if(s & (1 << k))  continue;\n                        DP[s | (1 << k)][k] = min(DP[s | (1 << k)][k],DP[s][now]+D[now][k]);\n                    }\n                }\n            }\n\n            int mini = INF;\n            for(int i=0;i<N;i++){\n                mini = min(mini,DP[(1<<N)-1][i]);\n            }\n            cout << mini << endl;\n        }else{\n            cout << -1 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1e9;\n\nint h, w;\nchar c[21][21];\nint d[21][21];\nint dist[21][21][21][21];\nint dy[4] = {1, -1, 0, 0};\nint dx[4] = {0, 0, 1, -1};\nbool contain(int y, int x){\n   return (0 <= y && y < h && 0 <= x && x < w);\n}\n\nvoid bfs(int sy, int sx){\n    rep(i, 0, h) rep(j, 0, w) d[i][j] = INF;\n    d[sy][sx] = 0;\n    queue<P> q;\n    q.push(P(sy, sx));\n    while(!q.empty()){\n        P p = q.front(); q.pop();\n        rep(i, 0, 4){\n            int ny = p.first + dy[i];\n            int nx = p.second + dx[i];\n            if(!contain(ny, nx) || d[ny][nx] != INF || c[ny][nx] == 'x') continue;\n            d[ny][nx] = d[p.first][p.second] + 1;\n            q.push(P(ny, nx));\n        }\n    }\n}\n\nsigned main(){\n    while(1){\n        cin >> w >> h;\n        if(w + h == 0) break;\n        vector<P> pl;\n        int sy, sx;\n        rep(i, 0, h){\n            rep(j, 0, w){\n                cin >> c[i][j];\n                if(c[i][j] == 'o'){\n                    sy = i; sx = j;\n                }\n                if(c[i][j] == '*'){\n                    pl.push_back(P(i, j));\n                }\n            }\n        }\n        pl.push_back(P(sy, sx));\n        rep(i, 0, pl.size()){\n            bfs(pl[i].first, pl[i].second);\n            rep(j, 0, h){\n                rep(k, 0, w){\n                    dist[pl[i].first][pl[i].second][j][k] = d[j][k];\n                }\n            }\n        }\n        vector<int> perm;\n        perm.push_back(pl.size() - 1);\n        rep(i, 0, pl.size() - 1){\n            perm.push_back(i);\n        }\n        int ans = INF;\n        do{\n            int tmp = 0;\n            rep(i, 0, perm.size() - 1){\n                tmp += dist[pl[perm[i]].first][pl[perm[i]].second][pl[perm[i + 1]].first][pl[perm[i + 1]].second];\n            }\n            ans = min(ans, tmp);\n        }while(next_permutation(perm.begin(), perm.end()));\n        if(ans == INF) ans = -1;\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing pii = pair<int, int>;\n\nconstexpr int INF = (1 << 12);\nconstexpr int dir[5] = {0, 1, 0, -1, 0};\n\nbool ispower(int n)\n{\n    return n == (pow(2, static_cast<int>(log2(n))));\n}\n\nvoid bfs_dist(const vector<vector<int>>& room, const pii& pos, vector<int>& dist, const vector<pii>& dirty)\n{\n    const int h = room.size();\n    const int w = room[0].size();\n    int rest = dirty.size();\n    vector<vector<bool>> checked(h, vector<bool>(w, false));\n    vector<bool> visited(dirty.size(), false);\n    queue<pair<pii, int>> q;\n    q.push(make_pair(pos, 0));\n    checked[pos.first][pos.second] = true;\n    while (not q.empty()) {\n        const pii p = q.front().first;\n        const int distance = q.front().second;\n        const int pi = p.first;\n        const int pj = p.second;\n        for (int i = 0; i < dirty.size(); i++) {\n            if (p == dirty[i] and (not visited[i])) {\n                dist[i] = distance;\n                visited[i] = true;\n                rest--;\n                if (rest == 0) {\n                    return;\n                }\n            }\n        }\n        q.pop();\n        for (int d = 0; d < 4; d++) {\n            const int newi = pi + dir[d];\n            const int newj = pj + dir[d + 1];\n            if (0 <= newi and newi < h and 0 <= newj and newj < w) {\n                if (room[newi][newj] != -1 and (not checked[newi][newj])) {\n                    checked[newi][newj] = true;\n                    q.push(make_pair(make_pair(newi, newj), distance + 1));\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        int h, w;\n        cin >> w >> h;\n        if (w == 0 and h == 0) {\n            break;\n        }\n        vector<vector<int>> room(h, vector<int>(w));\n\n        pii start;\n        vector<pii> dirty;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                char c;\n                cin >> c;\n                if (c == '.') {\n                    room[i][j] = 0;\n                } else if (c == '*') {\n                    room[i][j] = 1;\n                    dirty.push_back(make_pair(i, j));\n                } else if (c == 'x') {\n                    room[i][j] = -1;\n                } else {\n                    room[i][j] = 0;\n                    start.first = i;\n                    start.second = j;\n                }\n            }\n        }\n\n        const int dirtynum = dirty.size();\n        vector<vector<int>> dist(dirtynum, vector<int>(dirtynum, INF));\n        vector<int> initdist(dirtynum, INF);\n        bfs_dist(room, start, initdist, dirty);\n        for (int i = 0; i < dirtynum; i++) {\n            bfs_dist(room, dirty[i], dist[i], dirty);\n        }\n\n        bool flag = false;\n        for (int i = 0; i < dirtynum; i++) {\n            if (initdist[i] == INF) {\n                cout << -1 << endl;\n                flag = true;\n            }\n        }\n        if (flag) {\n            continue;\n        }\n\n        const int maximum = 1 << dirtynum;\n        vector<vector<int>> dp(maximum, vector<int>(dirtynum, INF));  // dp[visited[last]\n        for (int n = 1; n < maximum; n++) {\n            for (int i = 0; i < dirtynum; i++) {\n                if ((n >> i) % 2) {\n                    for (int j = 0; j < dirtynum; j++) {  //i->j\n                        if ((n >> j) % 2) {\n                            if (i == j) {\n                                if (ispower(n)) {\n                                    dp[n][i] = initdist[i];\n                                }\n                                continue;\n                            }\n                            dp[n][j] = min(dp[n][j], dp[n - (1 << j)][i] + dist[i][j]);\n                        }\n                    }\n                }\n            }\n        }\n        int mini = INF;\n        for (int i = 0; i < dirtynum; i++) {\n            mini = min(mini, dp[maximum - 1][i]);\n        }\n        cout << mini << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 24;\n\n// (??´?????????????¢§?\\????????????±????????????idx)\ntypedef pair<pii, int> State;\n\nvi dx = { 1, 0,-1, 0};\nvi dy = { 0,-1, 0, 1};\n\n#define F first\n#define S second\n\nint main(void){\n    for(int w, h; cin >> w >> h, w;){\n        vs field(h);\n        rep(y, h) cin >> field[y];\n\n        pii s;\n        int n_gomi = 0;\n        vvi dic(h, vi(w, -1));\n\n        rep(y, h) rep(x, w){\n            if(field[y][x] == 'o'){\n                s = mp(y, x);\n                field[y][x] = '.';\n            }\n            if(field[y][x] == '*'){\n                dic[y][x] = n_gomi;\n                n_gomi++;\n            }\n        }\n\n        // (cost, State)\n        priority_queue<pair<int, State>, vector<pair<int, State>>, greater<pair<int, State>>> q;\n        q.push(mp(0, mp(s, 0)));\n\n        vector<vvi> minDist(h, vvi(w, vi(1 << n_gomi, inf)));\n\n        int res = -1;\n        while(!q.empty()){\n            int cur_cost = q.top().F;\n            pii cur_pos = q.top().S.F;\n            int cur_d = q.top().S.S;\n            q.pop();\n\n            if(cur_d == (1 << n_gomi) - 1){\n                res = cur_cost;\n                break;\n            }\n\n            if(minDist[cur_pos.F][cur_pos.S][cur_d] != inf) continue;\n            minDist[cur_pos.F][cur_pos.S][cur_d] = cur_cost;\n\n            rep(i, 4){\n                pii next_pos = mp(cur_pos.F + dy[i], cur_pos.S + dx[i]);\n\n                if(next_pos.F < 0 || h <= next_pos.F ||\n                   next_pos.S < 0 || w <= next_pos.S ||\n                   field[next_pos.F][next_pos.S] == 'x') continue;\n\n                int next_d = cur_d;\n                int idx = dic[next_pos.F][next_pos.S];\n                if(idx != -1){\n                    next_d |= (1 << idx);\n                }\n                if(minDist[next_pos.F][next_pos.S][next_d] != inf) continue;\n\n                q.push(mp(cur_cost + 1, mp(next_pos, next_d)));\n            }\n        }\n\n        cout << res << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define clear(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\nstruct Robo\n{\n\tint x, y, clean;\n\tRobo(int x, int y, int clean)\n\t\t: x(x), y(y), clean(clean) { };\n};\nint main()\n{\n\tint w, h;\n\twhile (cin >> w >> h, w)\n\t{\n\t\tstatic char c[32][32];\n\t\tint sx, sy;\n\t\tint kitanai = 0;\n\t\tfor (int y = 0; y < h; ++y)\n\t\t{\n\t\t\tcin >> c[y];\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t{\n\t\t\t\tif (c[y][x] == 'o')\n\t\t\t\t\tsx = x, sy = y;\n\t\t\t\telse if (c[y][x] == '*')\n\t\t\t\t\tc[y][x] = '0' + kitanai++;\n\t\t\t}\n\t\t}\n\n\t\tstatic int d[20][20][1 << 10];\n\t\tconst int INF = 1 << 25;\n\t\tfor (int y = 0; y < h; ++y)\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\tfor (int i = 0; i < 1 << kitanai; ++i)\n\t\t\t\t\td[y][x][i] = INF;\n\n\t\tqueue<Robo> q;\n\t\tq.push(Robo(sx, sy, (1 << kitanai) - 1));\n\t\td[sy][sx][(1 << kitanai) - 1] = 0;\n\t\tint res = -1;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tRobo r = q.front(); q.pop();\n\n\t\t\tint nclean = r.clean;\n\t\t\tif (isdigit(c[r.y][r.x]))\n\t\t\t{\n\t\t\t\tint w = c[r.y][r.x] - '0';\n\t\t\t\tif (r.clean & (1 << w))\n\t\t\t\t{\n\t\t\t\t\tnclean ^= 1 << w;\n\t\t\t\t\tif (!nclean)\n\t\t\t\t\t{\n\t\t\t\t\t\tres = d[r.y][r.x][r.clean];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint nc = d[r.y][r.x][r.clean] + 1;\n\t\t\tfor (int i = 0; i < 4; ++i)\n\t\t\t{\n\t\t\t\tint nx = r.x + dx[i], ny = r.y + dy[i];\n\t\t\t\tif (0 <= nx && nx < w && 0 <= ny && ny < h\n\t\t\t\t\t&& c[ny][nx] != 'x' && nc < d[ny][nx][nclean])\n\t\t\t\t{\n\t\t\t\t\tq.push(Robo(nx, ny, nclean));\n\t\t\t\t\td[ny][nx][nclean] = nc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\nll inf = 1e9;\ntypedef pair<ll,mp> mmp;\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\nvector<ll> bfs(vector<vector<bool> > used,vector<mp> go,int s){\n\tint n = go.size();\n    \tvector<ll> res(n,inf);\n\tint h = used.size();\n\tint w = used[0].size();\n\tvector<vector<ll> > cost(h,vector<ll>(w,inf) );\n\tqueue<mmp> q;\n\tq.push( mmp(0,mp(go[s].first,go[s].second ) ) );\n\twhile(!q.empty() ){\n\t    mmp now = q.front();\n\t    q.pop();\n\t    ll c = now.first;\n\t    //cout<<c<<endl;\n\t    ll x = now.second.first;\n\t    ll y = now.second.second;\n\t    if(!used[x][y] )continue;\n\t    used[x][y] = false;\n\t    cost[x][y] = min(cost[x][y],c);\n\t    for(int i=0;i<4;i++){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(!used[nx][ny] ) continue;\n\t\tq.push( mmp( c + 1,mp(nx,ny) ) );\n\t    }\n\t}\n\tfor(int i=0;i<n;i++) res[i] = min(res[i], cost[ go[i].first ][ go[i].second ] );\n\treturn res;\n}\n\nint main(){\n    while(1){\n\tint w,h;\n\tcin>>w>>h;\n\tif(w==0)break;\n\tvector<vector<bool> > used(h+2,vector<bool>(w+2,false) );\n\tint s;\n\tvector<mp> go;\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tchar tmp ;\n\t\t\tcin>>tmp;\n\t\t\tif(tmp=='o'){\n\t\t\t\ts = go.size();\n\t\t\t\tgo.push_back(mp(i,j) );\n\t\t\t\tused[i][j] = true;\n\t\t\t}else if(tmp=='*'){\n\t\t\t\tgo.push_back(mp(i,j) );\n\t\t\t\tused[i][j] = true;\n\t\t\t}else if(tmp=='.'){\n\t\t\t\tused[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tswap(go[0],go[s]);//\n\ts = 0;\n\tint n = go.size();\n\tif(n >11){\n\t\tcout<<\"error\"<<endl;\n\t\treturn 1;\n\t}\t\n\tvector<vector<ll> > g(n);\n\tfor(int i=0;i<n;i++) g[i] = bfs ( used, go ,i);\n\t//cout<< \"OK\"<<endl;\n\t/*for(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tcout<<g[i][j]<<' ';\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tvector<vector<ll> > dp( (1<<n),vector<ll>(n,inf) ); // [bit][i] bit 1のとき未訪問, 0 のとき訪問済み i は最後に来た場所\n\tdp[(1<<n)-1][0] = 0;\n\tfor(int i= (1<<n)-1;i>=0;i--){//TSP\n\t\tfor(int j = 0;j<n;j++)\n\t\t    for(int k=0;k<n;k++)\n\t\t\tif( !( (i>>k) & 1 ) )dp[i][j] = min(dp[i][j] , dp[ i | (1<<k) ][k] + g[j][k] ) ;  \n\t}\n\tll m  = inf ;\n\tfor(int i=0;i<n;i++){\n\t\tm = min( m, dp[1<<i][i] );\n\t}\n\t//for(int i=0;i<n;i++)for(int j=0;j<n;j++) m = min( m , res[ (1<<n)-1][i][j] );\n\tif( m == inf){\n\t\tcout<<-1<<endl;\n\t}else{\n\t\tcout<<m<<endl;\n\t}\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1020000000\n\nint solve(int w, int h){\n  vector<string> vec(h);\n  rep(i,h) cin>>vec[i];\n\n  int n = w*h;\n  vector<vector<int>> d(n,vector<int>(n, INF));\n  rep(i,n) d[i][i] = 0;\n  rep(i,h)rep(j,w) if(vec[i][j]!='x'){\n    if(j+1<w && vec[i][j+1]!='x') d[i*w+j][i*w+j+1] = d[i*w+j+1][i*w+j] = 1;\n    if(i+1<h && vec[i+1][j]!='x') d[i*w+j][(i+1)*w+j] = d[(i+1)*w+j][i*w+j] = 1;\n  }\n\n  rep(k,n)rep(i,n)rep(j,n) d[i][j] = min(d[i][k]+d[k][j], d[i][j]);\n\n  int m = 0;\n  vector<int> pos;\n  rep(i,h)rep(j,w) if(vec[i][j] == '*'){pos.pb(i*w+j); m++;}\n\n  int s;\n  rep(i,h)rep(j,w) if(vec[i][j] == 'o') s = i*w+j;\n\n  vector<vector<int>> dp(1<<m, vector<int>(m, INF));\n  rep(i,m) dp[1<<i][i] = d[s][pos[i]];\n  rep(mask,1<<m) rep(i,m) if(dp[mask][i]<INF){\n    rep(j,m) if( !(mask & (1<<j) ) ){\n      dp[mask | (1<<j)][j] = min(dp[mask | (1<<j)][j], dp[mask][i] + d[pos[i]][pos[j]]);\n    }\n  }\n\n  int ans = *min_element(all(dp[(1<<m)-1]));\n  if(ans == INF) return -1;\n  return ans;\n}\n\nint main(){\n  int w,h;\n  while(cin>>w>>h, w|h){\n    cout << solve(w,h) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m; assert(b>=0); for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nint h, w;\nstring s[20];\n\n// (h,w) <-> (y,x)\nint mn(int sy, int sx, int gy, int gx) {\n\tqueue<pair<int,pii> > q;\n\tq.push({0,{sy,sx}});\n\tint d[20][20];\n\trep(i,h) rep(j,w) d[i][j] = inf;\n\td[sy][sx] = 0;\n\twhile (!q.empty()) {\n\t\tint x = q.front().se.se, y = q.front().se.fi, dis = q.front().fi; q.pop();\n\t\tif (d[y][x]<dis) continue;\n\t\trep(i,4) {\n\t\t\tint xx = x + dx[i], yy = y + dy[i];\n\t\t\tif (xx<0 || xx>=w || yy<0 || yy>=h || d[yy][xx]<=dis+1 || s[yy][xx]=='x') continue;\n\t\t\td[yy][xx] = dis+1;\n\t\t\tq.push({dis+1,{yy,xx}});\n\t\t}\n\t}\n\treturn d[gy][gx];\n}\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> w >> h;\n\t\tif (h==0) break;\n\t\tvi ti, tj;\n\t\t// 0: スタート地点\n\t\tint d[11][11] = {};\n\t\trep(i,11) rep(j,11) if (i!=j) d[i][j] = inf;\n\t\trep(i,h) {\n\t\t\tcin >> s[i];\n\t\t\trep(j,w) if (s[i][j]=='o') ti.pb(i), tj.pb(j);\n\t\t}\n\t\trep(i,h) rep(j,w) if (s[i][j]=='*') ti.pb(i), tj.pb(j);\n\t\tint n = ti.size();\n\t\t\n\t\trep(i,n) reps(j,i+1,n) d[i][j] = d[j][i] = mn(ti[i],tj[i],ti[j],tj[j]);\n\t\tbool fin = 0;\n\t\treps(i,1,n) if (d[0][i]==inf) fin = 1;\n\t\tif (fin) {\n\t\t\tcout << -1 << ln;\n\t\t\tcontinue;\n\t\t}\n\t\trep(k,n) rep(i,n) rep(j,n)\n\t\t    chmin(d[i][j], d[i][k]+d[k][j]);\n\t\t// dp[i][j]: 通過済みの点の集合がjであり今点iにいるような状態の最小移動回数\n\t\tint dp[11][1<<11] = {};\n\t\trep(i,n) rep(j,1<<n) dp[i][j] = inf;\n\t\tdp[0][1] = 0;\n\t\trep(i,n) rep(j,1<<n) if (dp[i][j]!=inf)\n\t\t\trep(k,n) if (!(j>>k&1)) chmin(dp[k][j^(1<<k)], dp[i][j]+d[i][k]);\n\t\tint res = inf;\n\t\trep(i,n) chmin(res, dp[i][(1<<n)-1]);\n\t\tcout << res << ln;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <chrono>\n#include <queue>\n#include <functional>\nusing namespace std;\n\n#define INF 1e9\n\n//????????????\nclass Timer {\n\tchrono::high_resolution_clock::time_point start, end;\n\tdouble limit;\n\npublic:\n\tTimer() {\n\t\tstart = chrono::high_resolution_clock::now();\n\t}\n\tTimer(double l) {\n\t\tstart = chrono::high_resolution_clock::now();\n\t\tlimit = l;\n\t}\n\n\tdouble getTime() {\n\t\tend = chrono::high_resolution_clock::now();\n\t\treturn chrono::duration<double>(end - start).count();\n\t}\n\n\tbool Over() {\n\t\tif (getTime() > limit) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid setLimit(double l) {\n\t\tlimit = l;\n\t}\n\tvoid setStart() { start = chrono::high_resolution_clock::now(); }\n};\n\nstruct POINT {\n\tint x, y;\n\n\tPOINT() {}\n\tPOINT(int x_, int y_) { x = x_, y = y_; }\n\n\tbool operator<(const POINT& r)const {\n\t\treturn x + y < r.x + r.y;\n\t}\n\n\tPOINT operator+(const POINT& r)const {\n\t\treturn POINT(x + r.x, y + r.y);\n\t}\n};\n\nstruct STATUS {\n\tint dist;\n\n\tint id;\n\tvector<bool>used;\n\n\tSTATUS() {}\n\tSTATUS(int dist_, int id_, vector<bool>used_) {\n\t\tdist = dist_;\n\t\tid = id_;\n\t\tused = used_;\n\t}\n\n\tbool operator>(const STATUS& r)const {\n\t\treturn dist > r.dist;\n\t}\n};\n\nint W, H;\nvector<vector<int>>MAP;\nint status[20][20];\nint cost[20][20];\nvoid dijkstra(POINT p) {\n\tint v[] = { -1,0,1,0 };\n\tint h[] = { 0,1,0,-1 };\n\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tstatus[i][j] = 0;\n\t\t\tcost[i][j] = INF;\n\t\t}\n\t}\n\tcost[p.x][p.y] = 0;\n\tstatus[p.x][p.y] = 1;\n\n\tpriority_queue<pair<int, POINT>, vector<pair<int, POINT>>, greater<pair<int, POINT>>>U;\n\tU.push(make_pair(cost[p.x][p.y], p));\n\twhile (!U.empty()) {\n\t\t//??¢?´¢???????????£??????????????§?????????????°???????\n\t\tPOINT u = U.top().second; U.pop();\n\n\t\tif (status[u.x][u.y] == -1) continue;\n\n\t\tstatus[u.x][u.y] = -1;\n\n\t\t//?????????????°????????????¢???\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPOINT np = u + POINT(v[i], h[i]);\n\t\t\tif (np.x < 0 || np.x >= H || np.y < 0 || np.y >= W)continue;\n\t\t\tif (MAP[np.x][np.y] == 1)continue;\n\t\t\tif (status[np.x][np.y] != -1) {\n\t\t\t\tif (cost[np.x][np.y] > cost[u.x][u.y] + 1) {\n\t\t\t\t\tcost[np.x][np.y] = cost[u.x][u.y] + 1;\n\t\t\t\t\tstatus[np.x][np.y] = 1;\n\t\t\t\t\tU.push(make_pair(cost[np.x][np.y], np));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (1) {\n\t\tcin >> W >> H;\n\n\t\tif (W == 0 && H == 0)break;\n\n\t\tMAP.assign(H,vector<int>(W,0));\n\n\t\tvector<POINT>pos;\n\t\tint cnt = 0;\n\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tchar c; cin >> c;\n\t\t\t\tif (c == '*') {\n\t\t\t\t\tPOINT p = POINT(i, j);\n\t\t\t\t\tpos.push_back(p);\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\telse if (c == 'x')MAP[i][j] = 1;\n\t\t\t\telse if (c == 'o') {\n\t\t\t\t\tPOINT sp = POINT(i, j);\n\t\t\t\t\tpos.insert(pos.begin(), sp);\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool fin = false;\n\t\tvector<vector<int>>dist(cnt);\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\tdist[i].resize(cnt);\n\t\t\tdijkstra(pos[i]);\n\t\t\tfor (int j = 1; j < cnt; j++) {\n\t\t\t\tint distance = cost[pos[j].x][pos[j].y];\n\t\t\t\tif (distance == INF)fin = true;\n\t\t\t\tdist[i][j] = distance;\n\t\t\t}\n\t\t}\n\n\t\tif (fin) {\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tTimer tmr(0.5);\n\t\tvector<priority_queue<STATUS, vector<STATUS>, greater<STATUS>>>STAT(cnt);\n\t\tSTAT[0].push(STATUS(0,0,vector<bool>(cnt)));\n\t\twhile (1) {\n\t\t\tif (tmr.Over())break;\n\n\t\t\tfor (int i = 0; i < cnt - 1; i++) {\n\t\t\t\tif (STAT[i].empty())continue;\n\n\t\t\t\tSTATUS st = STAT[i].top(); STAT[i].pop();\n\n\t\t\t\tfor (int j = 1; j < cnt; j++) {\n\t\t\t\t\tif (st.used[j])continue;\n\n\t\t\t\t\tst.used[j] = true;\n\t\t\t\t\tSTAT[i + 1].push(STATUS(st.dist + dist[st.id][j], j, st.used));\n\t\t\t\t\tst.used[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSTATUS last = STAT[cnt - 1].top();\n\t\tcout << last.dist << endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> Pa;\n\nint dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nconst int inf = 99999;\n\nbool bfs(char a[21][21], int w, int h, Pa pa[12], int p, int dis[12][12])\n{\n\tbool f = false;\n\tfor(int k = 0; k < p-1 ; k++){\n\t\tbool vis[21][21];\n\t\tint d[21][21];\n\t\tqueue<Pa> que;\n\t\tPa t;\n\t\tint s = p-k-1;\n\t\t\n\t\tfill(&d[0][0], &d[h][w], 0);\n\t\tfill(&vis[0][0], &vis[h][w], true);\n\t\ta[pa[k].first][pa[k].second] = '.';\n\t\tque.push(pa[k]);\n\t\tvis[t.first][t.second] = false;\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tt = que.front();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tfor(int i = k+1; i < p; i++){\n\t\t\t\tif(pa[i].first == t.first && pa[i].second == t.second){\n\t\t\t\t\tdis[k][i] = dis[i][k] = d[t.first][t.second];\n\t\t\t\t\ts--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s == 0){\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint u = t.second+dx[i], v = t.first+dy[i];\n\t\t\t\tif(0 <= u && u < w && 0 <= v && v < h){\n\t\t\t\t\tif(vis[v][u] && a[v][u] != 'x'){\n\t\t\t\t\t\tque.push(Pa(v, u));\n\t\t\t\t\t\td[v][u] = d[t.first][t.second]+1;\n\t\t\t\t\t\tvis[v][u] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn f;\n}\n\nint shp(int dis[12][12], int p)\n{\n\tint dp[1<<12][12], n = 1<<p;\n\tfill(&dp[0][0], &dp[(1<<12)-1][11], inf);\n\tdp[1<<0][0] = 0;\n\t\n\tfor(int i = 1<<0; i < n; i++){\n\t\tfor(int j = 0; j < p; j++){\n\t\t\tif(i&(1<<j)){\n\t\t\t\tfor(int k = 0; k < p; k++){\n\t\t\t\t\tif(dp[i|(1<<k)][k] > dp[i][j]+dis[j][k]){\n\t\t\t\t\t\tdp[i|(1<<k)][k] = dp[i][j]+dis[j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint t = min_element(dp[n-1], dp[n-1]+p)-dp[n-1];\n\t\n\treturn dp[n-1][t];\n}\n\nint tsp(int dis[12][12], int p)\n{\n\tint dp[1<<12][12];\n\tfill(&dp[0][0], &dp[(1<<12)-1][11], inf);\n\tdp[(1<<p)-1][1] = 0;\n\t\n\tfor(int i = (1<<p)-2; i >= 1; i--){\n\t\tfor(int j = 0; j < p; j++){\n\t\t\tfor(int k = 0; k < p; k++){\n\t\t\t\tif(i>>k & 1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i|1<<k][k]+dis[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dp[1][0];\n}\n\nint main()\n{\n\tint h, w;\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0){\n\t\t\tbreak;\n\t\t}\n\t\tint p=1, dis[12][12];\n\t\tchar a[21][21];\n\t\tPa pa[12];\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tcin >> a[i];\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(a[i][j] == 'o'){\n\t\t\t\t\tpa[0] = Pa(i, j);\n\t\t\t\t}\n\t\t\t\tif(a[i][j] == '*'){\n\t\t\t\t\tpa[p++] = Pa(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfill(&dis[0][0], &dis[p][p], inf);\t\n\t\tfor(int i = 0; i < p; i++){\n\t\t\tdis[i][i] = 0;\n\t\t}\n\t\t\n\t\tif(bfs(a, w, h, pa, p, dis)){\n\t\t\tcout << shp(dis, p) << endl;\n\t\t} else {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int, int> pii;\nint const dx[] = {1,0,-1,0};\nint const dy[] = {0,1,0,-1};\n\nchar mat[20][20];\nint dis[11][20][20];\nint m;\nvector<int> px, py;\nint done[11];\nint ans;\nint sp;\n\nvoid rec(int n, int np, int len)\n{\n  if (n == m) {\n    \n    ans = min(len, ans);\n    return;\n  }\n  for (int i=0; i<m; i++) {\n    if (!done[i]) {\n      if (len+dis[np][px[i]][py[i]] < ans) {\n        done[i] = 1;\n        rec(n+1, i, len+dis[np][px[i]][py[i]]);\n        done[i] = 0; \n        // cout << ret << endl;;\n      }\n    }\n  }\n  return;\n}\n\nint main()\n{\n  int w, h;\n  while (cin >> w >> h && (w || h)) {\n    int sx, sy, sp;\n    // char mat[w][h];\n    px.clear(); py.clear();\n    string str;\n    m = 0;\n    for (int i=0; i<h; i++) {\n      cin >> str;\n      for (int j=0; j<w; j++) {\n        char x = str[j];\n        if (x == 'o') {\n          sx = j; sy = i;\n          sp = m;\n          x = '*';\n        }\n        if (x == '*') {\n          px.push_back(j);\n          py.push_back(i);\n          m++;\n        }\n        mat[j][i] = x;\n      }\n    }\n    // for (int i=0; i<h; i++) {\n    //   for (int j =0; j<w; j++) {\n    //     cout << mat[j][i];\n    //   }\n    //   cout << endl;\n    // }\n    // cout << endl;\n    // ツ仰猟猟」ツ行ツ療アツづ個催ャツ青ャ\n    // int dis[10][w][h];\n    memset(dis, 0, sizeof(dis));\n    for (int i=0; i<m; i++) {\n      queue<pii> Q;\n      Q.push(pii(px[i],py[i]));\n      while (!Q.empty()) {\n        int x = Q.front().first;\n        int y = Q.front().second;\n        Q.pop();\n        for (int k=0; k<4; k++) {\n          int xx = x + dx[k];\n          int yy = y + dy[k];\n          if ((xx < 0 || xx >= w) || (yy < 0 || yy >= h)) continue;\n          if (mat[xx][yy] == 'x') continue;\n          if (dis[i][xx][yy] != 0 || (xx == px[i] && yy == py[i])) continue;\n          dis[i][xx][yy] = dis[i][x][y] + 1;\n          Q.push(pii(xx,yy));\n        }\n      }\n    }\n    // for (int k = 0; k<m; k++) {\n    //   for (int i=0; i<h; i++) {\n    //     for (int j =0; j<w; j++) {\n    //       cout << dis[k][j][i] << \" \";\n    //     }\n    //     cout << endl;\n    //   }\n    //   cout << endl;\n    // }\n    int f = 0;\n    for (int i = 0; i < m; i++) {\n      if (dis[sp][px[i]][py[i]] == 0 && (i != sp)) {\n        cout << -1 << endl;\n        f = 1;\n        break;\n      }\n    }\n    if (f) continue;\n    \n    memset(done,0,sizeof(done));\n    done[sp] = 1;\n    ans = 10000;\n    rec(1, sp, 0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <queue>\n#include <string>\n#include <numeric>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\nint const inf = 1 << 29;\ntypedef int Weight;\nstruct Edge{\n    Edge(int src, int dst, int cost)\n        :src(src), dst(dst), cost(cost){}\n    int src, dst, cost;\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nint W, H;\n\nint dx[] = { 1, 0, -1, 0 };\nint dy[] = { 0, 1, 0, -1 };\n\nconst int MAXN = 12;\nint n;\nint d[MAXN][MAXN];\nint dp[1 << MAXN][MAXN];\n\nint rec(int S, int v) {\n    if (dp[S][v] >= 0) return dp[S][v];\n    if (S == (1 << n) - 1 && v == 0) return dp[S][v] = 0;\n    int tmp = inf;\n    rep(u, n) if (!(S >> u & 1)) tmp = min(tmp, rec(S | 1 << u, u) + d[v][u]);\n    return dp[S][v] = tmp;\n}\n\n// テ」ツ?づ」ツつ甘ヲツ慊ャテ」ツ?ョテ」ツδ?」ツつ、テ」ツつッテ」ツつケテ」ツδ暗」ツδゥテヲツウツ陛」ツつ担pagetti Sourceテ」ツ?ョAPIテ」ツ?ォテ・ツ青暗」ツつ湘」ツ?崚」ツ?淌」ツつづ」ツ?ョ\nstruct State {\n    int v, d;\n    State(int v, int d) : v(v), d(d){}\n    bool operator<(const State& s)const{\n        return d>s.d;\n    }\n};\n\nvoid dijkstra(Graph const &g, int s, vector<Weight> &dist) {\n    priority_queue<State> q;\n    dist.assign(g.size(), inf); dist[s] = 0;\n    q.push(State(s, 0));\n    while (q.size()) {\n        State s = q.top(); q.pop();\n        int v = s.v;\n        if (dist[v] < s.d) continue;\n        rep(i, g[v].size()){\n            const Edge &e = g[v][i];\n            if (dist[e.dst] > dist[v] + e.cost) {\n                dist[e.dst] = dist[v] + e.cost;\n                q.push(State(e.dst, dist[e.dst]));\n            }\n        }\n    }\n}\n\n\ninline bool valid(int x, int y){\n    return 0 <= x && x < W && 0 <= y && y < H;\n}\n\nint solve(vector<string> grid){\n    Graph g(W*H);\n    vector<int> dust;\n    int s;\n    rep(y, H)rep(x, W){\n        rep(i, 4){\n            int tx = x + dx[i];\n            int ty = y + dy[i];\n            if (!valid(tx, ty)) continue;\n            if (grid[ty][tx] == 'x') continue;\n            int src = y*H + x;\n            int dst = ty*H + tx;\n            g[src].push_back(Edge(src, dst, 1));\n        }\n    }\n\n    rep(i, H)rep(j, W){\n        if (grid[i][j] == '*'){\n            dust.push_back(i*H + j);\n        }\n        if (grid[i][j] == 'o'){\n            s = i*H + j;\n        }\n    }\n    dust.push_back(s);\n    int V = dust.size();\n    rep(i, V)rep(j, V){\n        d[i][j] = inf;\n    }\n    rep(i, 1 << MAXN)rep(j, MAXN){\n        dp[i][j] = -1;\n    }\n\n    rep(i, V){\n        vector<int> dist;\n        dijkstra(g, dust[i], dist);\n        rep(j, V){\n            d[i][j] = dist[dust[j]];\n        }\n    }\n    \n    int idx[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 };\n    int ans = inf;\n    do{\n        long long res = 0;\n        rep(i, V){\n            res += d[idx[i]][idx[i + 1]];\n        }\n        if (res >= inf) continue;\n        ans = min<long long>(ans, res);\n    } while (next_permutation(idx, idx + V - 1));\n    if (ans == inf)ans = -1;\n    return ans;\n}\n\nint main(){\n    while (cin >> W >> H && W | H){\n        vector<string> grid(H);\n        rep(i, H){\n            cin >> grid[i];\n        }\n        cout << solve(grid) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nconst int MAX=INT_MAX/100;\nint dy[]={-1,0,1,0},dx[]={0,-1,0,1};\nint bfs(vs &c,pii from,pii to,int h,int w){\n\tqueue<pii> q;\n\tq.push(from);\n\tvvi cost(h,vi(w,MAX));\n\tcost[from.first][from.second]=0;\n\twhile(!q.empty()){\n\t\tpii p=q.front();q.pop();\n\t\tREP(d,4){\n\t\t\tint y=p.first+dy[d];\n\t\t\tint x=p.second+dx[d];\n\t\t\tif(y>=0&&x>=0&&y<h&&x<w&&c[y][x]!='x'&&cost[y][x]==MAX){\n\t\t\t\tq.push(make_pair(y,x));\n\t\t\t\tcost[y][x]=cost[p.first][p.second]+1;\n\t\t\t}\n\t\t}\n\t}\n\treturn cost[to.first][to.second];\n}\n\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h,w|h){\n\t\tvs c(h);\n\t\tvector<pii> targets;\n\t\tpii start;\n\t\tREP(i,h){\n\t\t\tcin>>c[i];\n\t\t\tREP(j,w){\n\t\t\t\tif(c[i][j]=='*'){\n\t\t\t\t\ttargets.push_back(make_pair(i,j));\n\t\t\t\t}else if(c[i][j]=='o'){\n\t\t\t\t\tstart=make_pair(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttargets.push_back(start);\n\t\tint sz=targets.size();\n\t\tvvi cost(sz+1,vi(sz+1));\n\t\tREP(i,sz){\n\t\t\tFOR(j,i+1,sz){\n\t\t\t\tcost[i][j]=bfs(c,targets[i],targets[j],h,w);\n\t\t\t\tcost[j][i]=cost[i][j];\n\t\t\t}\n\t\t}\n\n\t\tvi order(sz-1);\n\t\tREP(i,sz-1){\n\t\t\torder[i]=i;\n\t\t}\n\t\tint ans=MAX;\n\t\tdo {\n\t\t\tint dist=cost[sz-1][order[0]];\n\t\t\tREP(i,sz-2){\n\t\t\t\tdist+=cost[order[i]][order[i+1]];\n\t\t\t}\n\t\t\tans=min(ans,dist);\n\t\t}while(next_permutation(ALL(order)));\n\t\tcout<<(ans==MAX?-1:ans)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\n#include<cctype>\n#include<cstdlib>\n#include<map>\n#include<vector>\n#include<complex>\n#include<queue>\n#include<set>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, int>\n#define Y first\n#define X second\nconst int INF = 100000000;\n\n\nclass C{\n    public:\n        int y, x, step;\n        C(int _y, int _x, int _step){\n            y = _y;\n            x = _x;\n            step = _step;\n        }\n};\n\nint main(){\n    int h, w, cnt = 0;\n    while(cin >>w >>h && h){\n        int cnt = 0, firy, firx;\n        vector< vector<char> > v(h, vector<char>(w));\n        set<P> s;\n        REP(i, h){\n            REP(j, w){\n                cin >>v[i][j];\n                if(v[i][j] == '*') cnt++;\n                if(v[i][j] == 'o'){ firy = i; firx = j; }\n            }\n        }\n\n        int ans = 0;\n\n        //debug\n        //REP(i, h){\n        //    REP(j, w){\n        //        cout <<v[i][j] <<\" \";\n        //    }\n        //    cout <<endl;\n        //}\n        while(cnt){\n            queue<C> open;\n            open.push( C(firy, firx, 0) );\n            vector< vector<int> > closed(h, vector<int>(w, INF));\n            while(!open.empty()){\n                C now = open.front();\n                open.pop();\n\n                if(now.step >= closed[now.y][now.x]) continue;\n                closed[now.y][now.x] = now.step;\n\n                int my[] = {0, 0, 1, -1};\n                int mx[] = {1, -1, 0, 0};\n\n                REP(i, 4){\n                    int ny = now.y + my[i];\n                    int nx = now.x + mx[i];\n                    if(ny < 0 || nx < 0 || ny >= h || nx >= w || v[ny][nx] == 'x') continue;\n                    open.push( C(ny, nx, now.step + 1) );\n                }\n            }\n            int tmp = INF;\n            REP(i, h){\n                REP(j, w){\n                    if(v[i][j] != '*') continue;\n                    if(closed[i][j] < tmp){\n                        tmp = closed[i][j];\n                        firy = i;\n                        firx = j;\n                    }\n                }\n            }\n            if(tmp == INF){\n                ans = -1;\n                break;\n            }\n            cnt--;\n            ans += tmp;\n            v[firy][firx] = '.';\n        }\n        cout <<ans <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#define MAX_H 20\n#define MAX_W 20\n#define MAX_G 10\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\n\nstruct S {\n    int y, x, t;\n    S(int y, int x, int t) : y(y), x(x), t(t) {}\n};\n\n#define INF (1<<28)\n\nstring field[MAX_H];\nint number[MAX_H][MAX_W];\nint graph[MAX_G][MAX_G];\nint dp[MAX_G][1<<MAX_G]; \nint h, w;\nint garbage_count;\n\ninline int solve(int v, int s) {\n    if (dp[v][s] != INF) return dp[v][s];\n    if (s == ((1<<garbage_count)-1)) return 0;\n    int min_cost = INF;\n    for (int i = 0; i < garbage_count; i++) {\n        if (s & (1<<i)) continue;\n        min_cost = min(min_cost, solve(i, (s + (1<<i))) + graph[v][i]);\n    }\n    return dp[v][s] = min_cost;\n}\n\nint main() {\n    while (cin >> w >> h) {\n        if (w == 0 && h == 0) break;\n        memset(graph, -1, sizeof(graph));\n        memset(number, -1, sizeof(number));\n        for (int i = 0; i < MAX_G; i++) for (int j = 0; j < (1<<MAX_G); j++) dp[i][j] = INF;\n        for (int i = 0; i < h; i++) \n            cin >> field[i];\n        \n        int cur = 1;\n        for (int i = 0; i < h; i++) \n            for (int j = 0; j < w; j++) {\n                if (field[i][j] == 'o') number[i][j] = 0;\n                if (field[i][j] == '*') number[i][j] = cur++;\n            }\n        garbage_count = cur;\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (field[i][j] == 'o' || field[i][j] == '*') {\n                    bool visited[h][w]; memset(visited, 0, sizeof(visited));\n                    queue<S> q;\n                    q.push(S(i, j, 0)); visited[i][j] = true;\n                    while (!q.empty()) {\n                        S s = q.front(); q.pop();\n                        if (field[s.y][s.x] == 'o' || field[s.y][s.x] == '*') {\n                            graph[number[i][j]][number[s.y][s.x]] = s.t;\n                        }\n                        for (int k = 0; k < 4; k++) {\n                            int ny = s.y + dy[k];\n                            int nx = s.x + dx[k];\n                            if (0 <= ny && ny < h && 0 <= nx && nx < w && !visited[ny][nx] && field[ny][nx] != 'x') {\n                                visited[ny][nx] = true;\n                                q.push(S(ny, nx, s.t+1));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        bool possible = true;\n        for (int i = 0; i < garbage_count; i++) \n            for (int j = 0; j < garbage_count; j++) \n                if (graph[i][j] == -1) {\n                    possible = false;\n                    break;\n                }\n\n        if (!possible) cout << -1 << endl;\n        else cout << solve(0, 0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n\n\nusing namespace std;\n\nconst int INF = 10000000;\n\n// ツ各ツ可伉づェツタツイツδ仰＋ツスツタツーツトツ地ツ点ツづ個つサツづェツつシツづェツづ個甘板づ個仰猟猟」\nint d[21][21][21][21];\nvector<string> field;\npair<int,int> sp;\nvector<pair<int,int> > dartys;\nint w,h;\n\nbool bfs(int sy,int sx){\n\tqueue<pair<int,int> > *prv = new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *nxt = new queue<pair<int,int> >();\n\n\tbool passed[21][21];\n\tfor(int i = 0; i < 21; i++)\n\t\tfill(passed[i],passed[i]+21,false);\n\n\tprv->push(make_pair(sy,sx));\n\n\tint dy[] = {-1,0,0,1};\n\tint dx[] = {0,-1,1,0};\n\n\tbool no = true;\n\tbool fir = false;\n\tint dist = 0;\n\twhile(prv->size()){\n\t\twhile(prv->size()){\n\t\t\tpair<int,int> cp = prv->front();prv->pop();\n\t\t\tif(passed[cp.first][cp.second])\n\t\t\t\tcontinue;\n\t\t\tpassed[cp.first][cp.second]=true;\n\t\t\td[sy][sx][cp.first][cp.second] = dist;\n\n\n\t\t\tif(fir && field[cp.first][cp.second] == '*'){\n\t\t\t\tno = false;\n\t\t\t}\n\t\t\tfir = true;\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tpair<int,int> np = cp;\n\t\t\t\tnp.first += dy[i];\n\t\t\t\tnp.second += dx[i];\n\t\t\t\tif(np.first >= 0 && np.second >= 0 && np.first < h && np.second < w){\n\t\t\t\t\tif(!passed[np.first][np.second] && field[np.first][np.second] != 'x'){\n\t\t\t\t\t\tnxt->push(np);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdist++;\n\t\tswap(prv,nxt);\n\t}\n\tdelete prv,nxt;\n\tif(no){\n\t\treturn false;\n\t}\n\telse\n\t\treturn true;\n}\n\nint dfs(int s,pair<int,int> prv){\n\tif(s == (1 << (int)(dartys.size()))-1){\n\t\treturn 0;\n\t}\n\n\tint minCost = INF;\n\tfor(int i = 0; i < dartys.size(); i++){\n\t\tif(!((1 & (s >> i)) == 1) && d[prv.first][prv.second][dartys[i].first][dartys[i].second] != INF){\n\t\t\tminCost = min(minCost,dfs(s | (1 << i),make_pair(dartys[i].first,dartys[i].second))\n\t\t\t\t+ d[prv.first][prv.second][dartys[i].first][dartys[i].second]);\n\t\t}\n\t}\n\treturn minCost;\n}\n\nint main(){\n\n\twhile(cin >> w >> h && !(w == 0 && h == 0)){\n\t\tfor(int i = 0; i < 21; i++){\n\t\t\tfor(int j = 0; j < 21; j++){\n\t\t\t\tfor(int k = 0; k < 21; k++){\n\t\t\t\t\tfill(d[i][j][k],d[i][j][k]+21,INF);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfield.clear();\n\t\tdartys.clear();\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfield.push_back(str);\n\t\t\tfor(int j = 0; j < str.size(); j++){\n\t\t\t\tif(str[j] == 'o'){\n\t\t\t\t\tsp.first = i;\n\t\t\t\t\tsp.second = j;\n\t\t\t\t}\n\t\t\t\telse if(str[j] == '*'){\n\t\t\t\t\tdartys.push_back(make_pair(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ツ各ツ湘ェツ渉環つゥツづァツ深ツつウツ優ツ静ヲツ探ツ催オツづ、ツつサツづェツつシツづェツづ個湘ェツ渉環づ鳴づ個仰猟猟」ツづーツ仰づ淞づつィツつュ\n\t\tif(!bfs(sp.first,sp.second)){\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tbool fff = false;\n\t\tfor(int i = 0; i < dartys.size(); i++){\n\t\t\tif(!bfs(dartys[i].first,dartys[i].second)){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\tfff = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(fff){\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t// ツ渉嘉アツセツーツδ仰スツマツδ督姪「ツ妥ィツづーツ嘉ーツつュ\n\t\tcout << dfs(0,make_pair(sp.first,sp.second)) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int MAX = 21;\nconst int TM = 11;\nconst int INF = (1<<25);\n\nchar F[MAX][MAX];\nint T[(1<<TM)][MAX][MAX];\nint w,h,sx,sy;\nvector<P> Trash;\n\n\nstruct State{\n  int x,y,t,come;\n  \n  State(){}\n  State(int a, int b, int c, int d):x(a),y(b),t(c),come(d){}\n  bool operator < (const State& s) const { return t > s.t;}\n\n};\n\nbool isInside(int x, int y){ return 0<=x&&x<w&&0<=y&&y<h;}\n\nvoid init(){\n  \n  // fill(T[0][0],T[0][0]+TM*MAX*MAX,INF);\n\n  for(int i = 0; i < TM; i++)\n    for(int j = 0; j < MAX; j++)\n      for(int k = 0; k < MAX; k++) T[i][j][k] = INF;\n\n  Trash.clear();\n\n}\n\nvoid input(){\n  for(int i = 0; i < h; i++)\n    for(int j = 0; j < w; j++){\n      cin >> F[i][j];\n      if(F[i][j] == 'o'){\n\tsx = j;\n\tsy = i;\n      }\n      if(F[i][j] == '*') Trash.push_back(P(j,i));\n\n    }\n}\n\nint getTrashNum(P p){\n  for(int i = 0; i < Trash.size(); i++)\n    if(Trash[i] == p) return i;\n  return -1;\n}\nvoid solve(){\n\n  priority_queue<State> Q;\n  Q.push(State(sx,sy,0,0));\n  T[0][sy][sx] = 0;\n\n  int dx[] = {0,0,1,-1};\n  int dy[] = {1,-1,0,0};\n\n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n\n    if(T[now.come][now.y][now.x] < now.t) continue;\n    \n    for(int i = 0; i < 4; i++){\n      State nex = now;\n      nex.x += dx[i];\n      nex.y += dy[i];\n      nex.t++;\n\n      if(!isInside(nex.x,nex.y)) continue;\n      if(F[nex.y][nex.x] == 'x') continue;\n\n\n      if(F[nex.y][nex.x] == '*'){\n\tint Tnum = getTrashNum(P(nex.x, nex.y));\n\tnex.come = (nex.come|(1<<Tnum));\n      }\n\n      \n      if(T[nex.come][nex.y][nex.x] > nex.t){\n\tT[nex.come][nex.y][nex.x] = nex.t;\n\tQ.push(nex);\n      }\n    }\n  }\n\n  int ans = INF;\n\n  for(int i = 0; i < Trash.size(); i++)\n    ans = min(ans,T[(1<<Trash.size())-1][Trash[i].second][Trash[i].first]);\n\n  if(ans == INF) cout << -1 << endl;\n  else cout << ans << endl;\n \n}\n  \nint main(){\n\n  while(cin >> w >> h && w+h){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n\twhile(1){\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif(w == 0) break;\n\t\tchar c[21][21];\n\t\tvector<pair<int, int > > dirty;\n\t\tint sx, sy;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t// cout << i << j << endl;\n\t\t\t\tcin >> c[i][j];\n\t\t\t\tif(c[i][j] == '*') dirty.push_back(make_pair(i, j));\n\t\t\t\tif(c[i][j] == 'o'){\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint kyori[21][21][21][21];\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tfor(int k = 0; k < h; k++){\n\t\t\t\t\tfor(int l = 0; l < w; l++){\n\t\t\t\t\t\tkyori[i][j][k][l] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tqueue<pair<int, int> > qu;\n\t\t\t\tkyori[i][j][i][j] = 0;\n\t\t\t\tqu.push(make_pair(i, j));\n\t\t\t\twhile(!qu.empty()){\n\t\t\t\t\tint x = (qu.front()).first;\n\t\t\t\t\tint y = (qu.front()).second;\n\t\t\t\t\tqu.pop();\n\t\t\t\t\tint dx[4] = {1, 0, -1, 0};\n\t\t\t\t\tint dy[4] = {0, 1, 0, -1};\n\t\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\t\tif(x + dx[k] >= 0 && x + dx[k] < h && y + dy[k] >= 0 && y + dy[k] < w && c[x + dx[k]][y + dy[k]] != 'x' && kyori[i][j][x + dx[k]][y + dy[k]] < 0){\n\t\t\t\t\t\t\tkyori[i][j][x + dx[k]][y + dy[k]] = kyori[i][j][x][y] + 1;\n\t\t\t\t\t\t\tqu.push(make_pair(x + dx[k], y + dy[k]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<int> > result((1 << 10), vector<int>(10, mod));\n\t\tfor(int i = 0; i < dirty.size(); i++){\n\t\t\tresult[(1 << i)][i] = kyori[sx][sy][dirty[i].first][dirty[i].second];\n\t\t}\n\t\tfor(int i = 1; i < (1 << dirty.size()); i++){\n\t\t\tfor(int j = 0; j < dirty.size(); j++){\n\t\t\t\tif((i & (1 << j)) == 0) continue;\n\t\t\t\tfor(int k = 0; k < dirty.size(); k++){\n\t\t\t\t\tif(j == k || (i & (1 << k)) > 0 || kyori[dirty[j].first][dirty[j].second][dirty[k].first][dirty[k].second] < 0) continue;\n\t\t\t\t\tresult[i | (1 << k)][k] = min(result[i | (1 << k)][k], result[i][j] + kyori[dirty[j].first][dirty[j].second][dirty[k].first][dirty[k].second]);\n\t\t\t\t\t// cout << k << \" \" << kyori[dirty[j].first][dirty[j].second][dirty[k].first][dirty[k].second] << endl;\n\t\t\t\t}\n\t\t\t\t// cout << i << \" \" << j << \" \" << result[i][j] << endl;\n\t\t\t}\n\t\t}\n\t\tint ans = mod;\n\t\tfor(int i = 0; i < dirty.size(); i++){\n\t\t\tans = min(ans, result[(1 << dirty.size()) - 1][i]);\n\t\t}\n\t\tif(ans == mod) ans = -1;\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1140&lang=jp\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nstruct edge {\n\tint from;\n\tint to;\n\tint dist;\n\tedge() {}\n\tedge(int from, int to, int dist) :from(from), to(to), dist(dist) {}\n};\n\nvoid calc_cost(int x, int y,vector<vector<int>>& cost,vector<vector<char>>& masu) {\n\tqueue<pii> q; q.push({ x,y });\n\tcost[x][y] = 0;\n\twhile (!q.empty()) {\n\t\tpii p = q.front(); q.pop();\n\t\tfor (int i = 0; i < 4;i++) {\n\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\tif (masu[nx][ny] == 'x')continue;\n\t\t\tif (cost[nx][ny] > cost[p.first][p.second] + 1) {\n\t\t\t\tcost[nx][ny] = cost[p.first][p.second] + 1;\n\t\t\t\tq.push({ nx,ny });\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint w, h;\n\twhile (cin >> w >> h, w | h) {\n\t\tvector<vector<char>> masu(h + 2, vector<char>(w + 2, 'x'));\n\t\tvector<pii> yogore;\n\t\tfor (int i = 1; i <= h;i++) {\n\t\t\tfor (int j = 1;j <= w;j++) {\n\t\t\t\tcin >> masu[i][j];\n\t\t\t\tif (masu[i][j] == '*'||masu[i][j] == 'o') {\n\t\t\t\t\tmasu[i][j] = '.';\n\t\t\t\t\tyogore.push_back({ i,j });\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint YOGORE = (int)yogore.size();\n\t\tvector<vector<edge>> dist(YOGORE);\n\t\tfor (int i = 0; i < YOGORE;i++) {\n\t\t\tvector<vector<int>> cost(h + 2, vector<int>(w + 2, INF));\n\t\t\tcalc_cost(yogore[i].first, yogore[i].second,cost, masu);\n\t\t\tfor (int j = 1; j < YOGORE; j++) {\n\t\t\t\tif (cost[yogore[j].first][yogore[j].second] == INF)continue;\n\t\t\t\tdist[i].push_back(edge(i,j,cost[yogore[j].first][yogore[j].second]));\n\t\t\t}\n\t\t}\n\n\t\tint dp[11][1 << 11];\n\t\tfor (int i = 0; i < 11;i++)for (int j = 0; j < (1 << 11);j++)dp[i][j] = INF;\n\t\tdp[0][1 << 0] = 0;\n\t\tfor (int j = 1;j < (1 << YOGORE);j++) {\n\t\t\tfor (int i = 0; i < YOGORE;i++) {\n\t\t\t\tfor (auto e : dist[i]) {\n\t\t\t\t\tif ((1 << e.to) & j) continue;\n\t\t\t\t\tdp[e.to][(1 << e.to) | j] = min(dp[e.to][(1 << e.to) | j], dp[e.from][j] + e.dist);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 1; i < YOGORE;i++) {\n\t\t\tans = min(ans, dp[i][(1 << YOGORE)-1]);\n\t\t}\n\t\tcout << ((ans==INF)?-1:ans) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <iostream>\n#include <queue>\n#define MAX 20\n#define INF 10000000\n\nusing namespace std;\n\nint w, h;\nchar c[MAX][MAX];\nint d[MAX][MAX][1024];\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid change(int a[10], int x){\n\n\tfor(int i = 0 ; i < 10 ; ++i){\n\t\ta[i] = x % 2;\n\t\tx /= 2;\n\t}\n\n}\n\nint change(int a[10]){\n\n\tint res = 0;\n\tfor(int i = 9 ; i >= 0 ; --i){\n\t\tres = res * 2 + a[i];\n\t}\n\treturn res;\n}\n\nint bfs(int sy, int sx, int cnt){\n\n\tqueue<int> qx, qy, qbit;\n\tqy.push(sy);\n\tqx.push(sx);\n\tqbit.push(0);\n\n\td[sy][sx][0] = 0;\n\n\n\twhile(qbit.empty() == false){\n\n\t\tint y = qy.front();\n\t\tqy.pop();\n\n\t\tint x = qx.front();\n\t\tqx.pop();\n\n\t\tint bit = qbit.front();\n\t\tqbit.pop();\n\n\t\tif( bit + 1 == (1 << cnt) ){\t\t\t\t// ?????§?????¨??????????????????????????????\n\t\t\treturn d[y][x][bit];\n\t\t}\n\n\t\tint a[10];\n\t\tfor(int i = 0 ; i < 4 ; ++i){\n\n\t\t\tchange(a, bit);\n\t\t\tint ny = dy[i] + y;\n\t\t\tint nx = dx[i] + x;\n\n\t\t\tif( ny < 0 || nx < 0 ) continue;\t\t// ?????????\n\t\t\tif( h <= ny || w <= nx) continue;\t\t// ?????????\n\t\t\tif( c[ny][nx] == 'x') continue;\t\t\t// ?§??????§?????????\n\n\t\t\tif( c[ny][nx] != '.'){\t\t\t\t\t// ?±??????????????????§????????´???\n\t\t\t\tint num = c[ny][nx] - '0';\t\t\t// ?±???????????????????ID?????????\n\t\t\t\ta[num] = 1;\n\t\t\t}\n\t\t\tint nbit = change(a);\n\t\t\tint nCost = d[y][x][bit] + 1;\n\n\t\t\tif( nCost < d[ny][nx][nbit] ){\t\t\t// ??????????????£??????????????´??? & ???????§£?????´??°\n\t\t\t\td[ny][nx][nbit] = nCost;\n\t\t\t\tqy.push(ny);\n\t\t\t\tqx.push(nx);\n\t\t\t\tqbit.push(nbit);\n\t\t\t}\n\n\t\t}// end of for\n\n\t}// end of while\n\n\treturn -1;\n}// end of bfs\n\nvoid init(){\n\n\tfor (int i = 0 ; i < h ; ++i){\n\t\tfor (int j = 0 ; j < w ; ++j){\n\t\t\tfor(int k = 0 ; k < 1024 ; ++k){\n\t\t\t\td[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n\n\n}\n\nint main(void){\n\n\n\tint si, sj;\n\twhile( cin >> w >> h ){\n\n\t\tif( w == h && h == 0 ){\n\t\t\tbreak;\n\t\t}\n\t\tinit();\n\t\tint cnt = 0;\n\n\t\tfor(int i = 0 ; i < h ; ++i){\n\t\t\tfor(int j = 0 ; j < w ; ++j){\n\t\t\t\tcin >> c[i][j];\n\t\t\t\tif( c[i][j] == 'o'){\n\t\t\t\t\tsj = j;\n\t\t\t\t\tsi = i;\n\t\t\t\t\tc[i][j] = '.';\n\t\t\t\t}else if( c[i][j] == '*'){\n\t\t\t\t\tc[i][j] = '0' + cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << bfs(si, sj, cnt) << endl;\n\n\t\t// for(int i = 0 ; i < h ; ++i){\n\t\t// \tfor(int j = 0 ; j < w ; ++j ){\n\t\t// \t\tcout << c[i][j];\n\t\t// \t}\n\t\t// \tcout << endl;\n\t\t// }\n\n\t}// end of while\n\n\treturn 0;\n}// end of main"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 20\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\nint w,h,idlen,sid,ans;\nstring s[N];\nvector<int> id;\nvector<P> edge[11];\n\nint bfs(int sy,int sx,int gy,int gx){\n  int d[N][N];\n  int dy[4]={-1,0,1,0};\n  int dx[4]={0,1,0,-1};\n  queue<P1> q;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)d[i][j]=INF;\n  d[sy][sx]=0;\n  q.push(P1(0,P(sy,sx)));\n  while(!q.empty()){\n    P1 t=q.front(); q.pop();\n    int c=t.first;\n    int y=t.second.first,x=t.second.second;\n    if(d[y][x]<c)continue;\n    for(int i=0;i<4;i++){\n      int ny=y+dy[i],nx=x+dx[i];\n      if(ny<0||nx<0||h<=ny||w<=nx)continue;\n      if(s[ny][nx]=='x')continue;\n      if(d[ny][nx]>c+1){\n\td[ny][nx]=c+1;\n\tq.push(P1(d[ny][nx],P(ny,nx)));\n      }\n    }\n  }\n  return d[gy][gx];\n}\n\nint dijkstra(){\n  \n  int d[(1<<idlen)][idlen];\n  \n  priority_queue<P1,vector<P1>,greater<P1> > q;\n  \n  for(int i=0;i<(1<<idlen);i++)\n    for(int j=0;j<idlen;j++)d[i][j]=INF;\n  \n  \n  d[(1<<sid)][sid]=0;\n  \n  q.push(P1(0,P((1<<sid),sid)));\n  \n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    int S=t.second.first;\n    int c=t.first,u=t.second.second;\n    \n    if(d[S][u]<c)continue;\n    \n    if(S==(1<<idlen)-1)return c;\n    \n    for(int i=0;i<(int)edge[u].size();i++){\n      int nu=edge[u][i].first;\n      int nc=edge[u][i].second;\n      if((S&(1<<nu)))continue;\n      if(d[(S|(1<<nu))][nu]>c+nc){\n\td[(S|(1<<nu))][nu]=c+nc;\n\tq.push(P1(c+nc,P((S|(1<<nu)),nu)));\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h)break;\n    for(int i=0;i<h;i++){\n      cin>>s[i];\n      for(int j=0;j<w;j++){\n\tif(s[i][j]=='.'||s[i][j]=='x')continue;\n\tif(s[i][j]=='o')sid=id.size();\n\tid.push_back(w*i+j);\n      }\n    }\n    idlen=id.size();\n    for(int i=0;i<idlen;i++)\n      for(int j=i;j<idlen;j++){\n\tif(i==j)continue;\n\tint y1=id[i]/w,x1=id[i]%w;\n\tint y2=id[j]/w,x2=id[j]%w;\n\tint d=bfs(y1,x1,y2,x2);\n\tedge[i].push_back(P(j,d));\n\tedge[j].push_back(P(i,d));\n      }\n    ans=dijkstra();\n    if(ans!=INF)cout<<ans<<endl;\n    else cout<<-1<<endl;\n    id.clear();\n    for(int i=0;i<idlen;i++)edge[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint h, w, k[21][21], cnt;\nint cx[11], cy[11], y[11][11], z[11][11], bfs[21][21], a, b, c[10], sum, minx; bool s[21][21];\nchar p;\n\nvoid BFS(int i) {\n\t\n}\n\nint main() {\n\twhile (true) {\n\t\tmemset(z, 0, sizeof(z));\n\t\tcin >> w >> h; cnt = 1; if (!w) { break; }\n\t\tfor (int i = 0; i < 21; i++) { \n\t\t\tfor (int j = 0; j < 21; j++) { \n\t\t\t\tk[i][j] = 1; \n\t\t\t} \n\t\t}\n\t\tcnt = 1;\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tcin >> p;\n\t\t\t\tif (p != 'x') { k[i][j] = 0; }\n\t\t\t\tif (p == '*') { cx[cnt] = j; cy[cnt] = i; cnt++; }\n\t\t\t\tif (p == 'o') { cx[0] = j; cy[0] = i; }\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 10; i++) { c[i] = i; }\n\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\t//bfs.\n\t\t\tqueue<int> Q;\n\t\t\tmemset(bfs, 10, sizeof(bfs));memset(s, false, sizeof(s));\n\t\t\tbfs[cy[i]][cx[i]] = 0;\n\n\t\t\tQ.push(cy[i] * 20 + cx[i]);\n\t\t\ts[cy[i]][cx[i]] = true;\n\t\t\twhile (!Q.empty()) {\n\t\t\t\ta = Q.front() / 20;\n\t\t\t\tb = Q.front() % 20;\n\t\t\t\tif (k[a - 1][b] == 0 && s[a - 1][b] == false) { \n\t\t\t\t\ts[a - 1][b] = true; Q.push((a - 1) * 20 + b); bfs[a - 1][b] = bfs[a][b] + 1;\n\t\t\t\t}\n\t\t\t\tif (k[a + 1][b] == 0 && s[a + 1][b] == false) {\n\t\t\t\t\ts[a + 1][b] = true; Q.push((a + 1) * 20 + b); bfs[a + 1][b] = bfs[a][b] + 1;\n\t\t\t\t}\n\t\t\t\tif (k[a][b - 1] == 0 && s[a][b - 1] == false) {\n\t\t\t\t\ts[a][b - 1] = true; Q.push(a * 20 + b - 1); bfs[a][b - 1] = bfs[a][b] + 1;\n\t\t\t\t}\n\t\t\t\tif (k[a][b + 1] == 0 && s[a][b + 1] == false) {\n\t\t\t\t\ts[a][b + 1] = true; Q.push(a * 20 + b + 1); bfs[a][b + 1] = bfs[a][b] + 1;\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t\t\n\t\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\t\tz[i][j] = bfs[cy[j]][cx[j]];\n\t\t\t}\n\t\t}\n\t\tminx = 114514;\n\t\tdo\n\t\t{\n\t\t\tsum = z[0][c[0] + 1];\n\t\t\tfor (int i = 0; i < cnt - 1; i++) { sum += z[c[i] + 1][c[i + 1] + 1]; }\n\t\t\tminx = min(minx, sum);\n\t\t} while (next_permutation(c, c + cnt - 1));\n\t\tif (minx == 114514) { minx = -1; }\n\t\tcout << minx << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vbb;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst double inf = (int)1e8;\n\ntypedef pair<int, int> P;\n\nchar maze[30][30 + 1]; // 迷路を表す文字列の配列 int N, M;\nvector<pair<int, int> >g;\n\nint d[30][30];\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint n, m;\nint q[400][400];\nint dp[400][400];\n\nint bfs(int sx, int sy, int gx, int gy){\n    queue<P> que;\n    rep(i,n)rep(j, m) d[i][j] = inf;\n\n    que.push(P(sx, sy));\n    d[sx][sy] = 0;\n\n    while(que.size()){\n        P p = que.front(); que.pop();\n        if(p.first == gx && p.second == gy) break;\n\n        rep(i, 4){\n            int nx = p.first + dx[i], ny = p.second + dy[i];\n            if (0 <= nx && nx < n && 0 <= ny && ny < m && maze[nx][ny] != 'x' && d[nx][ny] == inf) {\n                que.push(P(nx, ny));\n                d[nx][ny] = d[p.first][p.second] + 1;\n            }\n        }\n    }\n    return d[gx][gy];\n}\n\nint rec(int S, int v) {\n    if (dp[S][v] >= 0) {\n        return dp[S][v];\n    }\n    if (S == (1 << n) - 1 && v == 0) {\n        return dp[S][v] = 0;\n    }\n\n    int res = inf;\n    for (int u = 0; u < n; u++) {\n        if (!(S >> u & 1)) {\n            res = min(res, rec(S | 1 << u, u) + d[v][u]);\n        }\n    }\n\n    return dp[S][v] = res;\n}\n\nint main(){\n    while(cin >> n >> m, n|m){\n        pair<int, int> s;\n        rep(i, 400){\n            rep(j,400)q[i][j] = inf;\n            q[i][i] = 0;\n        }\n        rep(i, m) cin >> maze[i];\n        rep(i, m)rep(j, n){\n            if(maze[i][j] == 'o'){s.first = j, s.second = i;}\n            if(maze[i][j] == '*' || maze[i][j] == 'o'){g.pb(mp(j, i));}\n        }\n        int cu;\n        rep(i, g.size()){\n            rep(j, g.size()){\n                if(i == j) continue;\n                int res = bfs(g[i].first, g[i].second, g[j].first, g[j].second);\n                q[i][j] = res;\n            }\n            if(g[i] == s) cu = i;\n        }\n        memset(dp, -1, sizeof(dp));\n        cout << rec(0, cu) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#define INF 1<<30\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h;\nchar cmap[30][30];\nint imap[30][30];\nint bfsd[60][60];\nint d[60][60];\nint dd[60];\nbool ddused[60];\nP pointUsed[60];\nint index;\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,1,0,-1}; \nint counter;\nint ssx,ssy;\nint sindex;\n\nvoid bfs(int sf,int ss){\n  queue<P> que;\n  que.push(P(sf,ss));\n  for(int i=0;i<h;i++)for(int j=0;j<w;j++)bfsd[i][j]=INF;\n  bfsd[ss][sf]=0;\n\n  while(que.size()){\n    P p = que.front(); que.pop();\n\n    for(int i=0;i<4;i++){\n      int nx = p.first + dx[i],ny = p.second + dy[i];\n      if(0<= nx && nx < w && 0<= ny && ny < h && bfsd[ny][nx] == INF && cmap[ny][nx] != 'x'){\n\tbfsd[ny][nx] = bfsd[p.second][p.first]+1;\n\tque.push(P(nx,ny));\n\tif(cmap[ny][nx] == '*' || cmap[ny][nx] == 'o'){\n\t  counter++;\n\t  //cout << imap[ss][sf]+50 << \"  \" << imap[ny][nx]+50 << endl;\n\t  d[ imap[ss][sf]+50 ][ imap[ny][nx]+50 ] = bfsd[ny][nx];\n\t  d[ imap[ny][nx]+50 ][ imap[ss][sf]+50 ] = bfsd[ny][nx];\n\t}\n\n      }\n\n    }\n\n\n\n  }\n\n}\n\nint dijkstra(){ // let dijkstra be prim\n  for(int i=0;i<index;i++){\n    ddused[i]=false;\n    dd[i]=INF;\n  }    \n  for(int i=0;i<index;i++){\n    if(i != sindex){\n      dd[i]=0;\n      break;\n    }\n  }\n  int res=0;\n\n  while(true){\n    int v = -1;\n    for(int u=0;u<index;u++)if(u != sindex && !ddused[u] && ( v == -1 || dd[v] > dd[u]))v=u;\n    if(v == -1)break;\n    ddused[v]=true;\n    res+=dd[v];\n    \n\n    for(int u=0;u<index;u++){\n      if(u!=sindex)dd[u] = min(dd[u],d[v][u]);\n    }\n  }\n  \n  return res;\n\n}\n\n\n\n\nint main(){\n  int sx,sy;\n  int dirtyIndex;\n  P dirtyPoint[500]; //let first be x and second be y\n  while(true){\n    cin >> w >> h;\n    if(w + h == 0)break;\n   \n    index=0;\n    dirtyIndex=-50;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> cmap[i][j];\n\tswitch(cmap[i][j]){\n\tcase '.':\n\t  imap[i][j]=0;\n\t  break;\n\tcase 'o':\n\t  imap[i][j]=dirtyIndex;\n\t  dirtyIndex++;\n\t  pointUsed[index] = P(j,i);\n\t  sindex=index;\n\t  ++index;\n\t  sy=i;\n\t  sx=j;\n\t  ssx = sx;\n\t  ssy = sy;\n\t  break;\n\tcase '*':\n\t  dirtyPoint[index].first = j;\n\t  dirtyPoint[index].second = i;\n\t  imap[i][j] = dirtyIndex;\n\t  dirtyIndex++;\n\t  pointUsed[index] = P(j,i);\n\t  ++index;\n\t  break;\n\tcase 'x':\n\t  imap[i][j]=-1;\n\t  break;\n\tdefault:\n\t  break;\n\t}\n      }\n    }\n    bool fin=false;\n    for(int i=0;i<index;i++){\n      counter=1;\n      bfs(pointUsed[i].first,pointUsed[i].second);\n      if(i == 0 && counter != index){\n\tcout << \"-1\" << endl;\n      fin=true;\n      break;\n      }\n\n    }\n\n    if(fin)continue;\n   \n    //int kotae = dijkstra();\n\n    //int min=INF;\n    //for(int i=0;i<index;i++){\n    //if(i == sindex)continue;\n    //if(d[sindex][i] < min)min = d[sindex][i];\n    //}\n    //cout << min+kotae << endl;\n\n    int dp[1<<index][index];\n\n    for(int S=0;S< (1<<index);S++){\n      for(int i=0;i<=index+1;i++)dp[S][i] = INF;\n    }\n    dp[(1<<index)-1][0] = 0;\n    for(int S = (1<<index)-2;S>=0;S--){\n      for(int v=0;v<index;v++){\n\tfor(int u=0;u<index;u++){\n\t  if(!(S>>u & 1)){\n\t    dp[S][v] = min(dp[S][v],dp[S|1<<u][u] + d[v][u]);\n\t  }\n\t}\n      }\n    }\n  \n    int Kotae=INF;\n    for(int i=0;i<index;i++)if(Kotae > dp[0][i])Kotae = dp[0][i];\n    cout << Kotae << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <utility>\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(it,c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); ++it)\n#define DEBUG(x) // cerr << #x << \" = \" << x << endl\n\ntypedef pair<int, int> P;\nostream& operator<<(ostream& os, const P& p) {\n    os << \"(y,x) = \" << '(' << p.first << ',' << p.second << ')';\n    return os;\n}\n\nconst int INF = (int)1e9;\n\nint dist[11][11];\nmap<int, int> memo;\n\n// current vertex, bitmask, number of vertex\nint tsp(int v, int b, int N) {\n    if(memo.count(b)) return memo[b];\n    if(b == (1 << N) - 1) return 0;\n    int res = INF;\n    for(int i = 0; i < N; i++) {\n        if(b & (1 << i)) continue;\n        res = min(res, dist[v][i] + tsp(i, b | (1 << i), N));\n    }\n    return memo[b] = res;\n}\n\nint main() {\n    while(true) {\n        int W, H; cin >> W >> H;\n        if(W + H == 0) break;\n        vector<string> inp;\n        REP(i,H) {\n            string s; cin >> s;\n            inp.push_back(s);\n        }\n\n        // y,x\n        vector<P> dst;\n        REP(y,H) REP(x,W) {\n            if(inp[y][x] == 'o') {\n                dst.push_back(P(y,x));\n                inp[y][x] = '.';\n            }\n        }\n\n        REP(y,H) REP(x,W) {\n            if(inp[y][x] == '*') {\n                dst.push_back(P(y,x));\n                inp[y][x] = '.';\n            }\n        }\n\n        REP(i,dst.size()) REP(j,dst.size()) dist[i][j] = INF;\n\n        REP(i,dst.size()) {\n            const int dy[4] = { 0, 1, 0, -1 };\n            const int dx[4] = { 1, 0, -1, 0 };\n\n            static bool vis[20][20];\n            REP(y,H) REP(x,W) vis[y][x] = false;\n\n            static int D[20][20];\n            REP(y,H) REP(x,W) D[y][x] = INF;\n\n            queue<P> Q;\n            Q.push(dst[i]);\n\n            vis[dst[i].first][dst[i].second] = true;\n            D[dst[i].first][dst[i].second] = 0;\n\n            while(!Q.empty()) {\n                P p = Q.front(); Q.pop();\n                REP(j,4) {\n                    int ny = p.first + dy[j];\n                    int nx = p.second + dx[j];\n                    if(0 <= nx && nx < W && 0 <= ny && ny < H && inp[ny][nx] != 'x' && vis[ny][nx] == false) {\n                        vis[ny][nx] = true;\n                        D[ny][nx] = D[p.first][p.second] + 1;\n                        Q.push(P(ny,nx));\n                    }\n                }\n            }\n            REP(j,dst.size()) {\n                dist[i][j] = D[dst[j].first][dst[j].second];\n            }\n        }\n\n        REP(i,dst.size()) REP(j,dst.size()) {\n            DEBUG(dst[i]);\n            DEBUG(dst[j]);\n            DEBUG(dist[i][j]);\n        }\n        \n        bool valid = true;\n        for(int i = 1; i < dst.size(); i++) {\n            if(dist[0][i] >= INF) {\n                valid = false;\n                break;\n            }\n        }\n        if(valid == false) {\n            cout << -1 << endl;\n            continue;\n        }\n\n        memo.clear();\n        int ans = tsp(0, 1, dst.size());\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 25;\nstruct Point{ int x, y; };\n\nint w, h;\nint cost[N][N];\nchar m[N][N];\nvector<Point> t(N);\n\n\nint dy[4] = {0,1,0,-1}, dx[4] = {1,0,-1,0};\n\nint bfs(int h, int w, Point p, Point g){\n\tint dis[N][N];\n\tqueue<Point> q;\n\trep(i,N) rep(j,N) dis[i][j] = INF;\n\n\tdis[p.y][p.x] = 0;\n\tq.push(p);\n\n\tPoint u;\n\twhile(not q.empty()){\n\t\tu = q.front(); q.pop();\n\t\trep(i,4){\n\t\t\tPoint next;\n\t\t\tnext.x = u.x + dx[i];\n\t\t\tnext.y = u.y + dy[i];\n\t\t\tif(next.x < 0 || next.x >= w || next.y < 0 || next.y >= h) continue;\n\t\t\tif(dis[next.y][next.x] == INF && m[next.y][next.x] != 'x'){\n\t\t\t\tdis[next.y][next.x] = dis[u.y][u.x] + 1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[g.y][g.x];\n}\n\nint main(){\n\twhile(cin >> w >> h, w){\n\t\tt.clear();\n\t\tPoint s;\n\t\trep(i,h) rep(j,w){\n\t\t\tcin >> m[i][j];\n\t\t\tif(m[i][j] == 'o') s = Point{j,i};\n\t\t\telse if(m[i][j] == '*') t.emplace_back(Point{j,i});\n\t\t}\n\t\tt.emplace_back(s);\n\n\t\trep(i,t.size()){\n\t\t\trep(j,t.size()){\n\t\t\t\tcost[i][j] = bfs(h, w, t[i], t[j]);\n\t\t\t}\n\t\t}\n\n\t\tvector<int> v(t.size() - 1);\n\t\tiota(all(v),0);\n\n\t\tint ans = INF;\n\t\tdo{\n\t\t\tint cnt = 0;\n\t\t\trep(i,v.size() - 1){\n\t\t\t\tcnt += cost[v[i]][v[i + 1]];\n\t\t\t}\n\t\t\tcnt += cost[t.size() - 1][v[0]];\n\t\t\tans = min(ans, cnt);\n\t\t}while(next_permutation(all(v)));\n\n\t\tcout << (ans == INF ? -1 : ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#define inf 100000000\n\nusing namespace std;\n\nint w, h;\nchar c[25][25];\n\nint N;\nint X[15], Y[15];\nint dist[15][15];\n\nint d[25][25];\n\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n\nvoid bfs(int sx, int sy)\n{\n\tfor(int x = 0; x < w; x++){\n\t\tfor(int y = 0; y < h; y++){\n\t\t\td[x][y] = inf;\n\t\t}\n\t}\n\tqueue<int> Q;\n\tQ.push(sx * 1000 + sy);\n\td[sx][sy] = 0;\n\t\n\tint x, y, nx, ny;\n\twhile(Q.size()){\n\t\tx = Q.front() / 1000;\n\t\ty = Q.front() % 1000;\n\t\tQ.pop();\n\t\t\n\t\tfor(int dir = 0; dir < 4; dir++){\n\t\t\tnx = x + dx[dir];\n\t\t\tny = y + dy[dir];\n\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\tif(d[nx][ny] < inf) continue;\n\t\t\tif(c[nx][ny] == 'x') continue;\n\t\t\tQ.push(nx * 1000 + ny);\n\t\t\td[nx][ny] = d[x][y] + 1;\n\t\t}\n\t}\n}\n\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) break;\n\t\t\n\t\tN = 0;\n\t\tfor(int y = 0; y < h; y++){\n\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\tcin >> c[x][y];\n\t\t\t\tif(c[x][y] == 'o') X[0] = x, Y[0] = y;\n\t\t\t\tif(c[x][y] == '*') X[N+1] = x, Y[N+1] = y, N++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i <= N; i++){\n\t\t\tbfs(X[i], Y[i]);\n\t\t\tfor(int j = 0; j <= N; j++){\n\t\t\t\tdist[i][j] = d[X[j]][Y[j]];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint perm[10], sum, ans = inf;\n\t\tfor(int i = 0; i < N; i++) perm[i] = i+1;\n\t\t\n\t\tdo{\n\t\t\tsum = dist[0][perm[0]];\n\t\t\t\n\t\t\tfor(int i = 0; i < N-1; i++){\n\t\t\t\tsum += dist[perm[i]][perm[i+1]];\n\t\t\t}\n\t\t\tans = min(ans, sum);\n\t\t\t\n\t\t}while(next_permutation(perm, perm+N));\n\t\t\n\t\tif(ans >= inf) ans = -1;\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n#include <utility>\n#define INF 0x3FFFFFFF\n\nusing namespace std;\n\n\nint main(void){\n\tint n, h, w, i, j, k, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0}, s[11][20][20], d[11][11], a, b, dp[11][1 << 10], min;\n\tpair<int,int> l[11];\n\tqueue<pair<int,int> > que;\n\tchar field[20][21];\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tn = 1;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tfield[i][j] = getchar();\n\t\t\t\tif(field[i][j] == '*') l[n].first = j,l[n++].second = i, field[i][j] = '.';\n\t\t\t\telse if(field[i][j] == 'o') l[0].first = j, l[0].second = i, field[i][j] = '.';\n\t\t\t}\n\t\t\tgetchar();\n\t\t}\n\t\tmemset(s,-1,sizeof(s));\n\t\tfor(i = 0;i < n;i++){\n\t\t\tque.push(l[i]);\n\t\t\ts[i][que.front().second][que.front().first] = 0;\n\t\t\twhile(que.size()){\n\t\t\t\ta = que.front().first, b = que.front().second;\n\t\t\t\tfor(j = 0;j < 4;j++){\n\t\t\t\t\tif(a + dx[j] >= 0 && a + dx[j] < w && b + dy[j] >= 0 && b + dy[j] < h && field[b + dy[j]][a + dx[j]] == '.' && s[i][b + dy[j]][a + dx[j]] == -1){\n\t\t\t\t\t\tque.push(pair<int,int>(a + dx[j],b + dy[j]));\n\t\t\t\t\t\ts[i][b + dy[j]][a + dx[j]] = s[i][b][a] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tque.pop();\n\t\t\t}\n\t\t}\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 1;j < n;j++){\n\t\t\t\td[i][j] = s[i][l[j].second][l[j].first];\n\t\t\t\tif(i != 0){\n\t\t\t\t\td[j][i] = s[i][l[j].second][l[j].first];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i = 0;i < 1 << (n - 1);i++)\n\t\t\tfor(j = 0;j < n;j++) dp[j][i] = INF;\n\t\tdp[0][0] = 0;\n\t\tfor(i = 0;i < 1 << (n - 1);i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tfor(k = 1;k < n;k++){\n\t\t\t\t\tif(~i & (1 << (k - 1)) && dp[k][i | (1 << (k - 1))] > dp[j][i] + d[j][k])\n\t\t\t\t\t\tdp[k][i | (1 << (k - 1))] = dp[j][i] + d[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmin = INF;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tif(min > dp[i][(1 << (n - 1)) - 1]) min = dp[i][(1 << (n - 1)) - 1];\n\t\tprintf(\"%d\\n\",min == INF ? -1 : min);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#define MAX 20\n#define DMAX 10\nusing namespace std;\n\nclass Point{\n    public:\n    int y, x;\n    Point(){}\n    Point( int y, int x ): y(y), x(x){}\n    bool operator == ( const Point &p ) const{\n        return ( x == p.x && y == p.y );\n    }\n};\n\nint W, H;\nchar G[MAX][MAX];\nPoint start;\nPoint dirty[DMAX];\nint dsize;\nint T[DMAX]; // start to all dirty;\nint M[DMAX][DMAX]; // all dirty to all dirty\n\nint bfs( Point p1, Point p2 ){\n    bool visited[MAX][MAX];\n    int d[MAX][MAX];\n    queue<Point> q;\n    \n    for ( int i = 0; i < H; i++ ){\n        for ( int j = 0; j < W; j++ ){\n            visited[i][j] = false;\n            d[i][j] = INT_MAX;\n        }\n    }\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, -1, 0, 1};\n    \n    q.push( p1 );\n    d[p1.y][p1.x] = 0;\n    \n    Point u;\n    \n    while ( !q.empty() ){\n        u = q.front(); q.pop();\n        \n        if ( u == p2 ) return d[u.y][u.x];\n        \n        int nx, ny;\n        for ( int r = 0; r < 4; r++ ){\n            ny = u.y + dy[r];\n            nx = u.x + dx[r];\n            \n            if ( !( 0 <= nx && 0 <= ny && ny < H && nx < W ) ) continue;\n            \n            if ( !visited[ny][nx] && G[ny][nx] != 'x' ){\n                visited[ny][nx] = true;\n                d[ny][nx] = d[u.y][u.x] + 1;\n                q.push( Point( ny, nx ) );\n            }\n        }\n    }\n    \n    return INT_MAX;\n}\n\nvoid computeDistanceTable(){\n    for ( int i = 0; i < dsize; i++ ){\n        T[i] = bfs( start, dirty[i]);\n    }\n    for ( int i = 0; i < dsize-1; i++ ){\n        for ( int j = i; j < dsize; j++ ){\n            if ( i == j ) M[i][j] = M[j][i] = 0;\n            M[i][j] = M[j][i] = bfs( dirty[i], dirty[j] );\n        }\n    }\n}\n\nint getMinimumMove(){\n    int order[DMAX];\n    for ( int i = 0; i < dsize; i++ ){\n        order[i] = i;\n    }\n    \n    int minMove = INT_MAX;\n    \n    do{\n        int move = T[ order[0] ];\n        \n        for ( int i = 1; i < dsize; i++ ){\n            move += M[ order[i-1] ][ order[i] ];\n        }\n        \n        if ( minMove > move ) minMove = move;\n        \n    } while( next_permutation(order, order + dsize )) ;\n    \n    return minMove;\n}\n\nbool notReachable(){\n    for ( int i = 0; i < dsize; i++ ){\n        if ( T[i] == INT_MAX ) return true;\n    }\n    return false;\n}\n\nvoid compute(){\n    computeDistanceTable();\n    if ( notReachable() ) cout << \"-1\" << endl;\n    else {\n        cout << getMinimumMove() << endl;\n    }\n}\n\nbool read(){\n    cin >> W >> H;\n    if ( W == 0 && H == 0 ) return false;\n    dsize = 0;\n    char ch;\n    for ( int i = 0; i < H; i++ ){\n        for ( int j = 0; j < W; j++ ){\n            cin >> ch;\n            G[i][j] = ch;\n            if ( ch == 'o' ){\n                start = Point(i, j);\n            } else if ( ch == '*' ){\n                dirty[dsize++] = Point(i, j);\n            }\n        }\n    }\n    return true;\n}\n\nmain(){\n    while ( read() ) compute();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n\n\nusing namespace std;\n\n\n// ツ各ツ可伉づェツタツイツδ仰＋ツスツタツーツトツ地ツ点ツづ個つサツづェツつシツづェツづ個甘板づ個仰猟猟」\nint d[21][21][21][21];\nvector<string> field;\npair<int,int> sp;\nvector<pair<int,int> > dartys;\nint w,h;\n\nbool bfs(int sy,int sx){\n\tqueue<pair<int,int> > *prv = new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *nxt = new queue<pair<int,int> >();\n\n\tbool passed[21][21];\n\tfor(int i = 0; i < 21; i++)\n\t\tfill(passed[i],passed[i]+21,false);\n\n\tprv->push(make_pair(sy,sx));\n\n\tint dy[] = {-1,0,0,1};\n\tint dx[] = {0,-1,1,0};\n\n\tbool no = true;\n\tbool fir = false;\n\tint dist = 0;\n\twhile(prv->size()){\n\t\twhile(prv->size()){\n\t\t\tpair<int,int> cp = prv->front();prv->pop();\n\t\t\tif(passed[cp.first][cp.second])\n\t\t\t\tcontinue;\n\t\t\tpassed[cp.first][cp.second]=true;\n\t\t\td[sy][sx][cp.first][cp.second] = dist;\n\n\n\t\t\tif(fir && field[cp.first][cp.second] == '*'){\n\t\t\t\tno = false;\n\t\t\t}\n\t\t\tfir = true;\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tpair<int,int> np = cp;\n\t\t\t\tnp.first += dy[i];\n\t\t\t\tnp.second += dx[i];\n\t\t\t\tif(np.first >= 0 && np.second >= 0 && np.first < h && np.second < w){\n\t\t\t\t\tif(!passed[np.first][np.second] && field[np.first][np.second] != 'x'){\n\t\t\t\t\t\tnxt->push(np);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdist++;\n\t\tswap(prv,nxt);\n\t}\n\tdelete prv,nxt;\n\tif(no){\n\t\treturn false;\n\t}\n\telse\n\t\treturn true;\n}\n\nint dfs(int s,pair<int,int> prv){\n\tif(s == (1 << (int)(dartys.size()))-1){\n\t\treturn 0;\n\t}\n\n\tint minCost = 10000000;\n\tfor(int i = 0; i < dartys.size(); i++){\n\t\tif(!(1 & (s >> i))){\n\t\t\tminCost = min(minCost,dfs(s | (1 << i),make_pair(dartys[i].first,dartys[i].second))\n\t\t\t\t+ d[prv.first][prv.second][dartys[i].first][dartys[i].second]);\n\t\t}\n\t}\n\treturn minCost;\n}\n\nint main(){\n\n\twhile(cin >> w >> h && !(w == 0 && h == 0)){\n\t\tfield.clear();\n\t\tdartys.clear();\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfield.push_back(str);\n\t\t\tfor(int j = 0; j < str.size(); j++){\n\t\t\t\tif(str[j] == 'o'){\n\t\t\t\t\tsp.first = i;\n\t\t\t\t\tsp.second = j;\n\t\t\t\t}\n\t\t\t\telse if(str[j] == '*'){\n\t\t\t\t\tdartys.push_back(make_pair(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ツ各ツ湘ェツ渉環つゥツづァツ深ツつウツ優ツ静ヲツ探ツ催オツづ、ツつサツづェツつシツづェツづ個湘ェツ渉環づ鳴づ個仰猟猟」ツづーツ仰づ淞づつィツつュ\n\t\tif(!bfs(sp.first,sp.second)){\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tbool fff = false;\n\t\tfor(int i = 0; i < dartys.size(); i++){\n\t\t\tif(!bfs(dartys[i].first,dartys[i].second)){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\tfff = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(fff){\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t// ツ渉嘉アツセツーツδ仰スツマツδ督姪「ツ妥ィツづーツ嘉ーツつュ\n\t\tcout << dfs(0,make_pair(sp.first,sp.second)) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#define MAX_H 20\n#define MAX_W 20\n#define MAX_G 10\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\n\nstruct S {\n    int y, x, t;\n    S(int y, int x, int t) : y(y), x(x), t(t) {}\n};\n\n#define INF (1<<28)\n\nstring field[MAX_H];\nint number[MAX_H][MAX_W];\nint graph[MAX_G][MAX_G];\nint dp[MAX_G][1<<MAX_G]; \nint h, w;\nint garbage_count;\n\nint solve(int v, int s) {\n    if (dp[v][s] != INF) return dp[v][s];\n    if (s == ((1<<garbage_count)-1)) return 0;\n    int min_cost = INF;\n    for (int i = 0; i < garbage_count; i++) {\n        if (s & (1<<i)) continue;\n        min_cost = min(min_cost, solve(i, (s + (1<<i))) + graph[v][i]);\n    }\n    return dp[v][s] = min_cost;\n}\n\nint main() {\n    while (cin >> w >> h) {\n        if (w == 0 && h == 0) break;\n        memset(graph, -1, sizeof(graph));\n        memset(number, -1, sizeof(number));\n        for (int i = 0; i < MAX_G; i++) for (int j = 0; j < (1<<MAX_G); j++) dp[i][j] = INF;\n        for (int i = 0; i < h; i++) \n            cin >> field[i];\n        \n        int cur = 1;\n        for (int i = 0; i < h; i++) \n            for (int j = 0; j < w; j++) {\n                if (field[i][j] == 'o') number[i][j] = 0;\n                if (field[i][j] == '*') number[i][j] = cur++;\n            }\n        garbage_count = cur;\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (field[i][j] == 'o' || field[i][j] == '*') {\n                    bool visited[h][w]; memset(visited, 0, sizeof(visited));\n                    queue<S> q;\n                    q.push(S(i, j, 0)); visited[i][j] = true;\n                    while (!q.empty()) {\n                        S s = q.front(); q.pop();\n                        if (field[s.y][s.x] == 'o' || field[s.y][s.x] == '*') {\n                            graph[number[i][j]][number[s.y][s.x]] = s.t;\n                        }\n                        for (int k = 0; k < 4; k++) {\n                            int ny = s.y + dy[k];\n                            int nx = s.x + dx[k];\n                            if (0 <= ny && ny < h && 0 <= nx && nx < w && !visited[ny][nx] && field[ny][nx] != 'x') {\n                                visited[ny][nx] = true;\n                                q.push(S(ny, nx, s.t+1));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        bool possible = true;\n        for (int i = 0; i < garbage_count; i++) \n            for (int j = 0; j < garbage_count; j++) \n                if (graph[i][j] == -1) {\n                    possible = false;\n                    break;\n                }\n\n        if (!possible) cout << -1 << endl;\n        else cout << solve(0, 0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define rep(i,N) for(ll i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nint w, h;\nll d[100][100];\nstring s[100];\nvector<P> vp;\nll dd[100][100];\n\nll dx[] = { 0,1,0,-1 };\nll dy[] = { 1,0,-1,0 };\n\nvoid solve(P p) {\n\tqueue<P> que;\n\tque.push(P(p.first, p.second));\n\trep(i, 100)rep(j, 100)d[i][j] = INF;\n\td[p.first][p.second] = 0;\n\n\twhile (que.size()) {\n\t\tP p = que.front();\n\t\tque.pop();\n\t\tint y = p.first;\n\t\tint x = p.second;\n\t\trep(i, 4) {\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif (ny >= 0 && ny < h&&nx >= 0 && nx < w) {\n\t\t\t\tif (s[ny][nx] != 'x') {\n\t\t\t\t\tif (d[ny][nx] > d[y][x] + 1) {\n\t\t\t\t\t\td[ny][nx] = d[y][x] + 1;\n\t\t\t\t\t\tque.push(P(ny, nx));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main() {\n\twhile (cin >> w >> h&&w + h) {\n\t\tint cnt = 0;\n\t\trep(i, 100)rep(j, 100)if (i != j)dd[i][j] = INF;\n\t\tvp.clear();\n\t\tP sp;\n\t\trep(i, h) {\n\t\t\tcin >> s[i];\n\t\t\trep(j, w) {\n\t\t\t\tif (s[i][j] == '*') {\n\t\t\t\t\tvp.push_back(P(i, j));\n\t\t\t\t}\n\t\t\t\telse if(s[i][j] == 'o'){\n\t\t\t\t\tsp = { i,j };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvp.push_back(sp);\n\t\treverse(ALL(vp));\n\t\trep(i, vp.size()) {\n\t\t\tsolve(vp[i]);\n\t\t\trep(j, vp.size()) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tdd[i][j] = d[vp[j].first][vp[j].second];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//rep(i, vp.size()) {\n\t\t//\trep(j, vp.size()) {\n\t\t//\t\tif (dd[i][j] == INF)cout << -1 << \" \";\n\t\t//\t\telse cout << dd[i][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\t//cout << endl;\n\t\tll ans = INF;\n\t\tvector<int> vi;\n\t\trep(i, vp.size())vi.push_back(i);\n\t\tsort(ALL(vi));\n\t\tdo {\n\t\t\tif (vi[0] != 0)continue;\n\t\t\tll sum = 0;\n\t\t\trep(i, vi.size() - 1) {\n\t\t\t\tsum += dd[vi[i]][vi[i + 1]];\n\t\t\t}\n\t\t\tans = min(ans, sum);\n\t\t} while (next_permutation(ALL(vi)));\n\t\tif (ans >= INF)cout << -1 << endl;\n\t\telse cout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct P {\n\tint x, y;\n};\n\nstruct Edge {\n\tint to, cost;\n};\n\nconst int inf = 1e9;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint W, H;\nint dist[20][20];\nbool m[20][20];\nbool inRange(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\nvoid bfs(P s) {\n\tfill(dist[0], dist[20], inf);\n\tdist[s.y][s.x] = 0;\n\tqueue<P> Q; Q.push( (P){s.x, s.y} );\n\twhile ( !Q.empty() ) {\n\t\tP p = Q.front(); Q.pop();\n\t\tfor (int d = 0; d < 4; ++d) {\n\t\t\tint nx = p.x+dx[d];\n\t\t\tint ny = p.y+dy[d];\n\t\t\tif (inRange(nx, ny) && !m[ny][nx] && dist[p.y][p.x]+1 < dist[ny][nx]) {\n\t\t\t\tdist[ny][nx] = dist[p.y][p.x]+1;\n\t\t\t\tQ.push((P){nx, ny});\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\twhile (cin >> W >> H, W || H) {\n\t\tfill(m[0], m[20], false);\n\t\tint sx = -1, sy = -1;\n\t\tvector<P> target;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tstring str; cin >> str;\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tswitch (str[x]) {\n\t\t\t\t\tcase '.': break;\n\t\t\t\t\tcase 'o': sx = x, sy = y; break;\n\t\t\t\t\tcase '*': target.push_back( (P){x, y} ); break;\n\t\t\t\t\tcase 'x': m[y][x] = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttarget.push_back((P){sx, sy});\n\t\tint cost[20][20];\n\t\tint N = target.size();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tbfs(target[i]);\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tcost[i][j] = dist[target[j].y][target[j].x];\n//\t\t\t\tcout << i << \" \" << j << \" \" << cost[i][j] << endl;\n\t\t\t}\n\t\t}\n\n\t\tint dp[12][1 << 11]; fill(dp[0], dp[12], inf); dp[N-1][1<<(N-1)] = 0;\n\t\tfor (int w = 1; w <= N; ++w) {\n\t\t\tfor (int i = 0; i < N; ++i) {\n//\t\t\t\tfor (int j = 1; j < (1 << N); ++j) {\n\t\t\t\tint j = (1 << w)-1;\n\t\t\t\twhile (j < 1 << N) {\n\t\t\t\t\tfor (int to = 0; to < N; ++to) {\n\t\t\t\t\t\tif ( (j & (1 << to)) == 0 && dp[i][j] != inf ) {\n//\t\t\t\t\t\t\tcout << i << \" \" << j << \" \" << to << \" \" << dp[i][j] << \" \" << cost[i][to] << endl;\n\t\t\t\t\t\t\tdp[to][j|(1<<to)] = min(dp[to][j|(1<<to)], dp[i][j]+cost[i][to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint x = j & -j, y = j+x;\n\t\t\t\t\tj = ((j&~y)/x>>1) | y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = inf;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tans = min(ans, dp[i][(1<<N)-1]);\n\t\t}\n\t\tif (ans == inf) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#define MAX_WH 20\n\nusing namespace std;\n\nint w, h;\nclass State {\npublic:\n  char data[MAX_WH][MAX_WH];\n  int x, y;\n  int step;\n  int cnt;\n  State() {\n    step = 0;\n    cnt = 0;\n  }\n  bool operator <(const State &s) const {\n    if(x != s.x) return x < s.x;\n    if(y != s.y) return y < s.y;\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) {\n\tif(data[i][j] != s.data[i][j])\n\t  return data[i][j] < s.data[i][j];\n      }\n    }\n    return false;\n  }\n  char getFloor() {\n    return data[y][x];\n  }\n  void next() {\n    step++;\n    if(getFloor() == '*') {\n      data[y][x] = '.';\n      cnt++;\n    }\n  }\n};\n\nint enableFloor;\nState ss;\n\nvoid rec(int x, int y) {\n  const int dx[4] = {1,0,-1,0};\n  const int dy[4] = {0,1,0,-1};\n\n  for(int i = 0; i < 4; i++) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(nx < 0 || nx >= w) continue;\n    if(ny < 0 || ny >= h) continue;\n    if(ss.data[ny][nx] == 'x') continue;\n    if(ss.data[ny][nx] == 'x') continue;\n    if(ss.data[ny][nx] == '*') enableFloor++;\n    ss.data[ny][nx] = 'x';\n    rec(nx, ny);\n  }\n}\n\nint yogore;\n\nint solve(State s) {\n  queue<State> Q;\n  set<State> visited;\n  const int dx[4] = {1,0,-1,0};\n  const int dy[4] = {0,1,0,-1};\n  State tmp;\n  char floor;\n  Q.push(s);\n  visited.insert(s);\n  while(!Q.empty()) {\n    s = Q.front();\n    if(s.cnt == yogore) return s.step;\n    Q.pop();\n    for(int i = 0; i < 4; i++) {\n      tmp = s;\n      tmp.x = s.x + dx[i];\n      tmp.y = s.y + dy[i];\n      if(tmp.x < 0) continue;\n      if(tmp.x >= w) continue;\n      if(tmp.y < 0) continue;\n      if(tmp.y >= h) continue;\n      floor = tmp.getFloor();\n      if(floor == 'x') continue;\n      tmp.next();\n      if(visited.find(tmp) != visited.end()) continue;\n\n      Q.push(tmp);\n      visited.insert(tmp);\n    }\n  }\n  return -1;\n}\n\nmain() {\n  while(1) {\n    State s;\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    yogore = 0;\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) {\n\tcin >> s.data[i][j];\n\tif(s.data[i][j] == 'o') {\n\t  s.x = j;\n\t  s.y = i;\n\t  s.data[i][j] = '.';\n\t} else if(s.data[i][j] == '*') {\n\t  yogore++;\n\t}\n      }\n    }\n    enableFloor = 0;\n    ss = s;\n    ss.data[s.y][s.x] = 'x';\n    rec(s.x, s.y);\n    if(enableFloor != yogore) cout << -1 << endl;\n    else                      cout << solve(s) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing Graph = vector<vector<int>>;\n\nint TravelingSalesman(const Graph &g) {\n    const int n = g.size(), INF = n * n * n;\n    vector<vector<int>> dp(1 << n, vector<int>(n, INF));\n    dp[1][0] = 0;\n\n    for (int s = 1; s < 1 << n; ++s) {\n        for (int cur = 0; cur < n; ++cur) {\n            if (!(s >> cur & 1) || INF <= dp[s][cur]) continue;\n\n            for (int dst = 0; dst < n; ++dst) {\n                if (dst != cur && !(s >> dst & 1))\n                    dp[s | 1 << dst][dst] = min(dp[s | 1 << dst][dst], dp[s][cur] + g[cur][dst]);\n            }\n        }\n    }\n\n    return *min_element(dp[(1 << n) - 1].begin(), dp[(1 << n) - 1].end());\n}\n\nconst int dr[] = {-1, 0, 1, 0};\nconst int dc[] = {0, -1, 0, 1};\n\nint Distance(const auto &src, const auto &dst, const int h, const int w, const vector<string> &c) {\n    vector<vector<int>> d(h, vector<int>(w, -1));\n    queue<pair<int, int>> que;\n    que.push(src);\n    d[src.first][src.second] = 0;\n\n    while (!que.empty()) {\n        auto cur = que.front(); que.pop();\n\n        for (int dir = 0; dir < 4; ++dir) {\n            pair<int, int> nxt(cur.first + dr[dir], cur.second + dc[dir]);\n            if (nxt.first < 0 || nxt.second < 0 || h <= nxt.first || w <= nxt.second\n                || d[nxt.first][nxt.second] != -1 || c[nxt.first][nxt.second] == 'x')\n                continue;\n            d[nxt.first][nxt.second] = d[cur.first][cur.second] + 1;\n            que.push(nxt);\n        }\n    }\n\n    return d[dst.first][dst.second];\n}\n\npair<bool, Graph> MakeGraph(const int w, const int h, const vector<string> &c) {\n    vector<pair<int, int>> pos(1);\n    for (int i = 0; i < h; ++i)\n        for (int j = 0; j < w; ++j) {\n            if (c[i][j] == 'o') pos[0] = make_pair(i, j);\n            else if (c[i][j] == '*') pos.emplace_back(make_pair(i, j));\n        }\n\n    const int n = pos.size();\n    Graph d(n, vector<int>(n));\n    for (int i = 0; i < n; ++i)\n        for (int j = i + 1; j < n; ++j) {\n            int d_ij = Distance(pos[i], pos[j], h, w, c);\n            if (d_ij == -1) return make_pair(true, d);\n            d[i][j] = d[j][i] = d_ij;\n        }\n\n    return make_pair(false, d);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int w, h;\n\n    while (cin >> w >> h, (w != 0 || h != 0)) {\n        vector<string> c(h);\n        for (auto &x : c) cin >> x;\n\n        auto res = MakeGraph(w, h, c);\n        if (res.first) cout << -1 << '\\n';\n        else cout << TravelingSalesman(res.second) << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nconst int INF = INT_MAX / 2;\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\n\nstruct Solver\n{\n\tconst int H, W;\n\tVS Board;\n\n\tSolver( int h, int w ) : H( h ), W( w )\n\t{\n\t\tBoard.resize( H );\n\t\tFOR( line, Board )\n\t\t{\n\t\t\tcin >> line;\n\t\t}\n\n\t\treturn;\n\t}\n\n\toperator int ()\n\t{\n\t\tvector<PII> posX;\n\t\tREP( i, 0, H )\n\t\t{\n\t\t\tREP( j, 0, W )\n\t\t\t{\n\t\t\t\tif ( Board[i][j] == 'o' )\n\t\t\t\t{\n\t\t\t\t\tposX.PB( MP( i, j ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP( i, 0, H )\n\t\t{\n\t\t\tREP( j, 0, W )\n\t\t\t{\n\t\t\t\tif ( Board[i][j] == '*' )\n\t\t\t\t{\n\t\t\t\t\tposX.PB( MP( i, j ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmap<PII,int> posToIdx;\n\t\tREP( i, 0, posX.size() )\n\t\t{\n\t\t\tposToIdx[ posX[i] ] = i;\n\t\t}\n\n\t\tconst int N = posX.size();\n\t\tVVI G( H, VI( H, INF ) );\n\t\tREP( i, 0, N )\n\t\t{\n\t\t\tG[i][i] = 0;\n\t\t}\n\n\t\tREP( i, 0, posX.size() )\n\t\t{\n\t\t\tmap<PII,int> dists( bfs( Board, posX[i] ) );\n\t\t\tFOR( dist, dists )\n\t\t\t{\n\t\t\t\tG[ posToIdx[ posX[i] ] ][ posToIdx[ dist.fst ] ] = dist.snd;\n\t\t\t}\n\t\t}\n\n\t\tVVI dp( 1 << N, VI( N, INF ) );\n\t\tdp[1][0] = 0;\n\n\t\tREP( mask, 0, 1 << N )\n\t\t{\n\t\t\tREP( i, 0, N )\n\t\t\t{\n\t\t\t\tREP( j, 0, N )\n\t\t\t\t{\n\t\t\t\t\tdp[ mask | 1 << j ][j] = min( dp[ mask | 1 << j ][j], dp[ mask ][i] + G[i][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = *min_element( ALL( dp[ ( 1 << N ) - 1 ] ) );\n\t\treturn res == INF ? -1 : res;\n\t}\n\n\tmap<PII,int> bfs( VS board, PII s )\n\t{\n\t\tVVI dist( H, VI( W, INF ) );\n\t\tdist[ s.fst ][ s.snd ] = 0;\n\n\t\tqueue<PII> que;\n\t\tque.push( s );\n\n\t\tmap<PII,int> res;\n\t\twhile ( !que.empty() )\n\t\t{\n\t\t\tPII cur = que.front();\n\t\t\tque.pop();\n\n\t\t\tif ( board[ cur.fst ][ cur.snd ] == 'x' )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( board[ cur.fst ][ cur.snd ] == '*' )\n\t\t\t{\n\t\t\t\tres[ cur ] = dist[ cur.fst ][ cur.snd ];\n\t\t\t}\n\n\t\t\tboard[ cur.fst ][ cur.snd ] = 'x';\n\n\t\t\tREP( d, 0, 4 )\n\t\t\t{\n\t\t\t\tPII next( cur );\n\t\t\t\tnext.fst += dx[d];\n\t\t\t\tnext.snd += dy[d];\n\n\t\t\t\tif ( !( 0 <= next.fst && next.fst < H && 0 <= next.snd && next.snd < W ) || board[ next.fst ][ next.snd ] == 'x' )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdist[ next.fst ][ next.snd ] = dist[ cur.fst ][ cur.snd ] + 1;\n\t\t\t\tque.push( next );\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint w, h;\n\t\tcin >> w >> h;\n\n\t\tif ( !( w | h ) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tcout << Solver( h, w ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ninline double distance(double y1, double x1, double y2, double x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy = { 0, 1, 0, -1 }, dx = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\n\nusing namespace std;\n\n\nint dist(const vector<string> &field, int sy, int sx, int gy, int gx) {\n    VV<int> memo(field.size(), V<int>(field[0].size(), INT_MAX));\n    memo[sy][sx] = 0;\n\n    queue<pair<int, int>> que;\n    que.push(make_pair(sy, sx));\n    while (not que.empty()) {\n        auto now = que.front(); que.pop();\n        int now_cost = memo[now.first][now.second];\n\n        FOR(i, 0, 4) {\n            int ny = dy[i] + now.first;\n            int nx = dx[i] + now.second;\n\n            if (inside(ny, nx, (int)field.size(), (int)field[0].size()) and (field[ny][nx] != 'x')) {\n                if (memo[ny][nx] > now_cost + 1) {\n                    que.push(make_pair(ny, nx));\n                    memo[ny][nx] = now_cost + 1;\n                }\n            }\n        }\n    }\n    return memo[gy][gx];\n}\n\n\nvoid solve(vector<string> &field) {\n    int sy = -1, sx = -1;\n    vector<pair<int, int>> v;\n    FOR(y, 0, field.size()) {\n        FOR(x, 0, field[0].size()) {\n            if (field[y][x] == 'o') {\n                sy = y;\n                sx = x;\n            }\n            if (field[y][x] == '*') {\n                v.emplace_back(make_pair(y, x));\n            }\n        }\n    }\n\n    V<int> first_cost_table(v.size(), INT_MAX);\n    VV<int> cost_table(v.size(), V<int>(v.size(), INT_MAX));\n    FOR(i, 0, v.size()) {\n        first_cost_table[i] = dist(field, sy, sx, v[i].first, v[i].second);\n        if (first_cost_table[i] == INT_MAX) {\n            print(-1);\n            return;\n        }\n        FOR(j, i + 1, v.size()) {\n            cost_table[i][j] = dist(field, v[i].first, v[i].second, v[j].first, v[j].second);\n            cost_table[j][i] = cost_table[i][j];\n            if (cost_table[i][j] == INT_MAX) {\n                print(-1);\n                return;\n            }\n        }\n    }\n\n    int ans = INT_MAX;\n    vector<int> route(v.size());\n    iota(ALL(route), 0);\n    do {\n\n        int total = first_cost_table[route[0]];\n        FOR(i, 0, route.size() - 1) {\n            total += cost_table[route[i]][route[i + 1]];\n        }\n        ans = min(ans, total);\n\n    } while(next_permutation(ALL(route)));\n\n    print(ans);\n    \n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int W, H;\n        cin >> W >> H;\n        if (W == 0 or H == 0) {\n            break;\n        }\n        vector<string> field;\n        FOR(_, 0, H) {\n            string s;\n            cin >> s;\n            field.push_back(s);\n        }\n\n        solve(field);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cassert>\n#include<string>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<tuple>\n#include<numeric>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n// vector\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) {\n    for(const T &t : v) os << \"\\t\" << t; return os << endl;\n}\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) {\n    for(T &a : v) is >> a; return is;\n}\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) {\n    return os << \"<\" << v.first << \" \" << v.second << \">\";\n}\n\n#define mp(x, y) make_pair(x, y)\nconst int INF = 1 << 30;\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\n\nint H, W;\nvector<string> G;\n\n// => s ?????? e ?????§??????????????????????????¢\nint go(pii s, pii e) {\n    queue<pair<pii, int>> que;\n    vector<vector<bool>> visited(H, vector<bool>(W));\n    que.push(mp(s, 0));\n    while(!que.empty()) {\n        auto q = que.front(); que.pop();\n        pii now = q.first;\n        int cost  = q.second;\n        \n        if(visited[now.first][now.second]) continue;\n        visited[now.first][now.second] = true;        \n\n        if(now == e) return cost;\n        rep(i, 4) {\n            int ny = now.first + dy[i];\n            int nx = now.second + dx[i];\n            if(ny < 0 or H <= ny or nx < 0 or W <= nx) continue;\n            if(G[ny][nx] == 'x') continue;\n            if(visited[ny][nx]) continue;            \n            \n            que.push(mp(mp(ny, nx), cost + 1));\n        }\n    }\n    return -1;\n}\n\nbool solve() {\n    G.clear();\n    cin >> W >> H;\n    if(W == 0 and H == 0) return false;\n    G.resize(H); cin >> G;\n    \n    vector<pii> dirty;\n    pii start;\n    // collect dirty cells\n    rep(y, H) {\n        rep(x, W) {\n            if(G[y][x] == '*') {\n                dirty.push_back(mp(y, x));\n            } else if(G[y][x] == 'o') {\n                start = mp(y, x);\n            }\n        }\n    }\n    // calc distance between dirty cells\n    int D = dirty.size();\n    vector<vector<int>> dist(D + 1, vector<int>(D + 1, INF));\n    rep(i, D) {\n        rep(j, i) {\n            dist[i][j] = dist[j][i] = go(dirty[i], dirty[j]);\n            if(dist[i][j] < 0) {\n                cout << -1 << endl;\n                return 1;\n            }\n        }\n        dist[D][i] = dist[i][D] = go(start, dirty[i]);\n    }\n\n    vector<vector<int>> dp(1 << (D + 1), vector<int>(D + 1, INF));\n    int stat = 1 << D;\n    rep(i, D) dp[stat][D] = 0;\n    while(stat < (1 << (D + 1))) {\n        rep(i, D + 1) { \n            if(stat & (1 << i)) {\n                rep(j, D) {\n                    if(i == j or stat & (1 << j)) continue;\n                    // i -> j\n                    dp[stat | (1 << j)][j] = min(dp[stat | (1 << j)][j], dp[stat][i] + dist[i][j]);\n                }\n            }\n        }\n        ++stat;\n    }\n    stat--;\n    int ans = INF;\n    rep(i, D) {\n        ans = min(dp[stat][i], ans);\n    }\n    cout << ans << endl;\n    \n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<P,int>Pi;\n\nstruct edge\n{\n    int to,cost;\n};\n\nconst int MAX_N = 22;\nconst int dx[] = {1,-1,0,0};\nconst int dy[] = {0,0,1,-1};\n\nchar c[MAX_N][MAX_N];\nP robot_dust[12];\nint flag[MAX_N*MAX_N];\nint d[MAX_N][MAX_N];\nint dp[(1 << 11)][MAX_N];\nint w,h;\n\nvoid bfs(P cor)\n{\n    queue<Pi> que;\n    que.push(Pi(cor,0));\n    while(!que.empty()){\n        Pi nw = que.front();\n        que.pop();\n        rep(i,4){\n            int ni = (nw.first).first + dy[i];\n            int nj = (nw.first).second + dx[i];\n            int dir = nw.second;\n            if(c[ni][nj] != 'x' && 0 <= ni && ni < h && 0 <= nj && nj < w){\n                if(flag[ni*w + nj] > dir + 1){\n                    flag[ni*w + nj] = dir + 1;\n                    que.push(Pi(P(ni,nj),dir+1));\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while(1){\n        scanf(\"%d%d\",&w,&h);\n        if(w == 0 && h == 0){\n            break;\n        }\n        int dust_cnt = 1;\n    \trep(i,h){\n            char hoge;\n            scanf(\"%c\",&hoge);\n            rep(j,w){\n                scanf(\"%c\",&c[i][j]);\n                if(c[i][j] == '*'){\n                    robot_dust[dust_cnt++] = P(i,j);\n                }else if(c[i][j] == 'o'){\n                    robot_dust[0] = P(i,j);\n                }\n            }\n    \t}\n        rep(i,dust_cnt){\n            rep(j,dust_cnt){\n                d[i][j] = INF;\n            }\n        }\n        rep(i,dust_cnt){\n            fill(flag,flag+w*h,INF);\n            flag[robot_dust[i].first*w + robot_dust[i].second] = 0;\n            bfs(robot_dust[i]);\n            rep(j,dust_cnt){\n                if(flag[robot_dust[j].first*w + robot_dust[j].second] < INF){\n                    d[i][j] = flag[robot_dust[j].first*w + robot_dust[j].second];\n                }\n            }\n        }\n        rep(i,(1 << (dust_cnt - 1))){\n            rep(j,dust_cnt){\n                dp[i][j] = INF;\n            }\n        }\n        for(int i = 1;i < dust_cnt; i++){\n            dp[(1 << (dust_cnt - 1)) - 1][i] = 0;\n        }\n        for(int i = (1 << (dust_cnt - 1)) - 2 ; i >= 0; i--){\n            for(int j = 1;j < dust_cnt; j++){\n                for(int k = 0;k < dust_cnt - 1; k++){\n                    if(!(i & (1 << k))){\n                        dp[i][j] = min(dp[i][j],dp[i | (1 << k)][k+1] + d[j][k+1]);\n                    }\n                }\n            }\n        }\n        int res = INF;\n        for(int i = 1; i < dust_cnt; i++){\n            res = min(res,dp[0][i] + d[0][i]);\n        }\n        if(res < INF){\n            printf(\"%d\\n\",res);\n        }else{\n            printf(\"-1\\n\");\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint H, W;\nchar grid[22][22];\ntypedef pair<int, int> Pii;\n\nint cost[22][22][22][22];\nint dist[12][12];\nint dp[1<<12][12];\nmap<Pii, int> dmap;\n#define MP make_pair\n\n#define INF ((int)1e8)\n\nint const dx[] = {-1,0,1,0};\nint const dy[] = {0,-1,0,1};\n\ninline bool inF(int x, int y) {\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\nbool bfs(int SX, int SY) {\n\n#define COST(x, y) cost[SY][SX][y][x]\n  \n  fill(&COST(0, 0), &COST(0, 0)+22*22, INF);\n  queue<Pii> Q;\n  Q.push(Pii(SX, SY));\n  COST(SX, SY) = 0;\n  while(!Q.empty()) {\n    Pii pii = Q.front(); Q.pop();\n    int x = pii.first, y = pii.second;\n    for(int i=0; i<4; i++) {\n      int nx = x+dx[i], ny = y+dy[i];\n      if(!inF(nx, ny)) continue;\n      if(COST(nx, ny) != INF) continue;\n      if(grid[ny][nx] == 'x') continue;\n      COST(nx, ny) = COST(x, y) + 1;\n      Q.push(Pii(nx, ny));\n    }\n  }\n  \n  bool ok = true;\n  rep(i, H)rep(j, W) if(grid[i][j] == '*' && COST(j, i) == INF) ok = false;\n  \n  return ok;\n}\n\nint main() {\n  \n  while(cin >> W >> H && (W|H)) {\n    \n    dmap.clear();\n    \n    int dsx, dsy;\n    int dcnt = 1;\n    rep(i, H) rep(j, W){\n      cin>>grid[i][j];\n      if(grid[i][j] == 'o') {\n\tdsx = j, dsy = i;\n\tdmap[Pii(j, i)] = 0;\n      }\n      if(grid[i][j] == '*') {\n\tdmap[Pii(j, i)] = dcnt++;\n      }\n    }\n\n    \n    bool NA = false;\n    rep(i, H) rep(j, W) {\n      if(grid[i][j] == '*' || grid[i][j] == 'o') {\n\tif(!bfs(j, i)) {\n\t  cout << -1 << endl; NA = true;\n\t  i = j = INF;\n\t}\n      }\n    }\n    if(NA) continue;\n    \n    rep(i, H) rep(j, W) rep(k, H) rep(l, W) {\n      if(i == k && j == l) continue;\n      if((grid[i][j] == '*' && grid[k][l] == '*')\n\t ||\n\t (grid[i][j] == 'o' && grid[k][l] == '*')) {\n\tdist[dmap[Pii(j, i)]][dmap[Pii(l, k)]] = cost[i][j][k][l];\n      }\n    }\n   \n    int V = dcnt;\n    \n    for(int i=0; i<(1<<V); i++) fill(dp[i], dp[i]+12, INF);\n    dp[(1<<V)-1][0] = 0;\n    \n    for(int st = (1<<V)-2; st >= 0; st--) {\n      for(int v=0; v<V; v++) {\n\tfor(int u=0; u<V; u++) {\n\t  if(!((st >> u) & 1)) { dp[st][v] = min(dp[st][v], dp[st|(1<<u)][u]+dist[v][u]); }\n\t}\n      }\n    }\n    \n    cout << dp[0][0] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nchar stage[20][20];\nint cost[1024][10];\nint dis[10][10];\nint w, h;\n\ntypedef std::tuple<int, int, int> T;\nstd::vector<T> pos_to_num;\n\nlong long unsigned PopCount(long long unsigned x) {\n\tx = (x & 0x5555555555555555ULL) + ((x & 0xAAAAAAAAAAAAAAAAULL) >> 1);\n\tx = (x & 0x3333333333333333ULL) + ((x & 0xCCCCCCCCCCCCCCCCULL) >> 2);\n\tx = (x & 0x0F0F0F0F0F0F0F0FULL) + ((x & 0xF0F0F0F0F0F0F0F0ULL) >> 4);\n\n\tx *= 0x0101010101010101ULL;\n\n\treturn x;\n}\n\nvoid dijkstra(int sx, int sy)\n{\n\tint c[20][20] = {0};\n\tint f[20][20] = {0};\n\tint dx[4] = {1, -1, 0, 0};\n\tint dy[4] = {0, 0, 1, -1};\n\n\tfor ( int i = 0; i < 20; ++i ) {\n\t\tfor ( int j = 0; j < 20; ++j ) {\n\t\t\tc[i][j] = 0xfffff;\n\t\t}\n\t}\n\n\tstd::queue<std::tuple<int,int>> q;\n\tq.push(std::make_tuple(sx, sy));\n\tf[sx][sy] = 1;\n\tc[sx][sy] = 0;\n\n\twhile(!q.empty()) {\n\t\tauto a = q.front(); q.pop();\n\t\tint x = std::get<0>(a);\n\t\tint y = std::get<1>(a);\n\t\tfor ( int i = 0; i < 4; ++i ) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif ( nx < 0 || nx >= w ) continue;\n\t\t\tif ( ny < 0 || ny >= h ) continue;\n\t\t\tif ( stage[nx][ny] == 'x' ) continue;\n\t\t\tif ( f[nx][ny] == 1 ) continue;\n\n\t\t\tc[nx][ny] = c[x][y] + 1;\n\t\t\tf[nx][ny] = 1;\n\t\t\tq.push(std::make_tuple(nx, ny));\n\t\t}\n\t}\n\n\tif ( stage[sx][sy] == 'o' ) {\n\t\tfor ( int i = 0; i < pos_to_num.size(); ++i ) {\n\t\t\tcost[0][std::get<2>(pos_to_num[i])] = c[std::get<0>(pos_to_num[i])][std::get<1>(pos_to_num[i])];\n\t\t}\n\t} else if ( stage[sx][sy] == '*' ) {\n\t\tint num;\n\t\tfor ( int i = 0; i < pos_to_num.size(); ++i ) {\n\t\t\tif ( sx == std::get<0>(pos_to_num[i]) && sy == std::get<1>(pos_to_num[i]) ) {\n\t\t\t\tnum = std::get<2>(pos_to_num[i]);\n\t\t\t}\n\t\t}\n\t\tfor ( int i = 0; i < pos_to_num.size(); ++i ) {\n\t\t\tdis[num][std::get<2>(pos_to_num[i])] = c[std::get<0>(pos_to_num[i])][std::get<1>(pos_to_num[i])];\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile ( true ) {\n\t\tfor ( int i = 0; i < 1024; ++i ) {\n\t\t\tfor ( int j = 0; j < 10; ++j ) {\n\t\t\t\tcost[i][j] = 0xfffff;\n\t\t\t}\n\t\t}\n\t\tfor ( int i = 0; i < 10; ++i ) {\n\t\t\tfor ( int j = 0; j < 10; ++j ) {\n\t\t\t\tdis[i][j] = 0xfffff;\n\t\t\t}\n\t\t}\n\n\t\tstd::cin >> w >> h;\n\t\tif ( w == 0 && h == 0 ) return 0;\n \n\t\tint sx, sy;\n\t\tint k = 0;\n\t\tfor ( int i = 0; i < h; ++i ) {\n\t\t\tfor ( int j = 0; j < w; ++j ) {\n\t\t\t\tstd::cin >> stage[j][i];\n\t\t\t\tif ( stage[j][i] == '*' ) {\n\t\t\t\t\tpos_to_num.push_back(T(j, i, k));\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tif ( stage[j][i] == 'o' ) {\n\t\t\t\t\tsx = j; sy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdijkstra(sx, sy);\n\t\tfor ( auto &v: pos_to_num ) {\n\t\t\tdijkstra(std::get<0>(v), std::get<1>(v));\n\t\t}\n\t\tstd::vector<std::tuple<int, int>> table(1<<k);\n\t\tfor ( int i = 0; i < (1<<k); ++i ) {\n\t\t\ttable[i] = std::make_tuple(PopCount(i), i);\n\t\t}\n\t\tstd::sort(table.begin(), table.end());\n\n\t\tfor ( int i = 1; i < (1<<k); ++i ) {\n\t\t\tint q = std::get<1>(table[i]);\n\t\t\tfor ( int j = 0; j < k; ++j ) {\n\t\t\t\tif ( q & (1<<j) ) {\n\t\t\t\t\tfor ( int l = 0; l < k; ++l ) {\n\t\t\t\t\t\tint c = cost[q^(1<<j)][j] + dis[j][l];\n\t\t\t\t\t\tcost[q][l] = (c < cost[q][l]) ? c : cost[q][l];\n\t\t\t\t\t\t//std::cout << \"state:\" << q << \" to:\" << l << \" cost:\" << cost[q][l] << std::endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min = 0xfffff;\n\t\tfor ( int i = 0; i < k; ++i ) {\n\t\t\tif ( min > cost[(1<<k)-1][i] ) min = cost[(1<<k)-1][i];\n\t\t}\n\t\tif ( min == 0xfffff || min == 0 ) {\n\t\t\tstd::cout << -1 << std::endl;\n\t\t} else {\n\t\t\tstd::cout << min << std::endl;\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vbb;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst double inf = (int)1e8;\n\ntypedef pair<int, int> P;\n\nchar maze[30][30 + 1]; // 迷路を表す文字列の配列 int N, M;\nvector<pair<int, int> >g;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint n, m;\nint q[30][30];\nint dp[1 << 11][11];\n\nint bfs(int sx, int sy, int gx, int gy){\n    int d[30][30];\n    queue<P> que;\n    rep(i,n)rep(j, m) d[i][j] = inf;\n\n    que.push(P(sx, sy));\n    d[sx][sy] = 0;\n\n    while(que.size()){\n        P p = que.front(); que.pop();\n        if(p.first == gx && p.second == gy) break;\n\n        rep(i, 4){\n            int nx = p.first + dx[i], ny = p.second + dy[i];\n            if (0 <= nx && nx < n && 0 <= ny && ny < m && maze[nx][ny] != 'x' && d[nx][ny] == inf) {\n                que.push(P(nx, ny));\n                d[nx][ny] = d[p.first][p.second] + 1;\n            }\n        }\n    }\n    return d[gx][gy];\n}\n\nint main(){\n    while(cin >> n >> m, n|m){\n        pair<int, int> s;\n        rep(i, 400){\n            rep(j,400)q[i][j] = inf;\n            q[i][i] = 0;\n        }\n        rep(i, m) cin >> maze[i];\n        rep(i, m)rep(j, n){\n            if(maze[i][j] == 'o'){s.first = j, s.second = i;}\n            if(maze[i][j] == '*' || maze[i][j] == 'o'){g.pb(mp(j, i));}\n        }\n        vector<pair<int, int> > gg;\n        gg.pb(s);\n        rep(i, g.size()) gg.pb(g[i]);\n        rep(i, gg.size()){\n            rep(j, gg.size()){\n                if(i == j) continue;\n                int res = bfs(gg[i].first, gg[i].second, gg[j].first, gg[j].second);\n                q[i][j] = res;\n            }\n        }\n        rep(i, 1<<gg.size()) fill(dp[i], dp[i]+gg.size(), inf);\n        dp[(1 << gg.size())-1][0] = 0;\n\n        for(int S = (1 << gg.size())-2; S >= 0; S--){\n            for(int v = 0; v < gg.size(); v++){\n                for(int u=0; u < gg.size(); u++){\n                    if(!(S >> u & 1)){\n                        dp[S][v] = min(dp[S][v], dp[S | 1 << u][u] + q[v][u]);\n                    }\n                }\n            }\n        }\n        int ret = inf;\n        rep(i, gg.size()){\n            if(i == 0) continue;\n            ret = min(ret, dp[0][i]);\n        }\n        if(ret != inf) cout << ret << endl;\n        else cout << -1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n#define isUruu(y) ((y % 4 || (y % 100 == 0 && y % 400)) ? false : true)\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef unsigned int uint;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<char> Vc;\ntypedef vector<Vc> VVc;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nconst int INF = 1 << 28;\nconst double EPS = 1e-9;\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {1,0,-1,0};\n\nint w, h;\n\nint dfs (VVc &field, vector<P> &pp, int sx, int sy, uint b)\n{\n    if (b == ((1 << pp.size()) - 1)) return 0;\n    int res = INF;\n    rep (j, pp.size()) {\n        if (b & (1 << j)) continue;\n        queue<P> q;\n        q.push(P(sx,sy));\n        VV d(h, V(w, INF));\n        d[sx][sy] = 0;\n        int count = 0;\n        while (q.size()) {\n            P p = q.front(); q.pop();\n            int x = p.first, y = p.second;\n            if (x == pp[j].first && y == pp[j].second) {\n                count = d[x][y];\n                break;\n            }\n            \n            rep (i,4) {\n                int nx = x + dx[i], ny = y + dy[i];\n                if (0 <= nx && nx < h && 0 <= ny && ny < w && d[nx][ny] == INF && field[nx][ny] != 'x') {\n                    d[nx][ny] = d[x][y] + 1;\n                    q.push(P(nx,ny));\n                }\n            }\n        }\n        if (count == 0) return INF;\n        res = min(res, count + dfs(field, pp, pp[j].first, pp[j].second, b | (1 << j)));\n    }\n    \n    return res;\n}\n\nint main()\n{\n    while (cin >> w >> h, h + w) {\n        VVc field(h, Vc(w));\n        vector<P> p;\n        int sx,sy;\n        rep (i,h) rep (j,w) {\n            cin >> field[i][j];\n            if (field[i][j] == 'o') sx = i, sy = j;\n            else if (field[i][j] == '*') p.push_back(P(i,j)); \n        }\n\n\n        int res = dfs(field, p, sx, sy, 0);\n        \n        cout << (res == INF ? -1 : res ) << endl;\n    }\n                \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <string.h>\nusing namespace std;\n\n#define FOR(i, n) for(int i = 0; i < n; i++)\n#define bit(i) static_cast< bitset<8> >(i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long>PLL;\ntypedef queue<int> QI;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue<int, vector<int>, greater<int> > minpq;\n\nstruct edge{int to, cost;};\n\nvoid begin(){cin.tie(0); ios::sync_with_stdio(false);};\nint gcd(int a, int b){if(a%b==0){return(b);}else{return(gcd(b,a%b));}};\nint lcm(int m, int n){if((0 == m)||(0 == n)){return 0;} return ((m / gcd(m, n)) * n);};\nunsigned long long comb(long n, long m){unsigned long long c = 1; m = (n - m < m ? n - m : m);\n    for(long ns = n - m + 1, ms = 1; ms <= m; ns ++, ms ++){c *= ns; c /= ms;} return c;};\n\nvoid cp(int a1[], int a2[], int l){FOR(i, l) a2[i] = a1[i];};\ndouble sq(double d){return d*d;};\nint sq(int i){return i*i;};\ndouble sqdist(int x1, int y1, int x2, int y2){\n    double dx = x1 - x2, dy = y1 - y2; return dx*dx + dy*dy;\n};\n\n// ワーシャルフロイド法\nvoid warshallFloyd(int d[100][100], int n){\n    for(int k = 0; k < n; ++k)\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                if(d[i][k] != -1 && d[k][j] != -1){\n                    if(d[i][j] == -1){\n                        d[i][j] = d[i][k] + d[k][j];\n                    }else{\n                        d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                    }\n                }\n};\n\n\n// d:隣接行列  n:グラフのサイズ  s:始点  dist:始点からの距離が入る配列\nvoid dijkstra(int d[1000][1000], int n, int s, int dist[1000]){\n    FOR(i, n) dist[i] = -1;\n    dist[s] = 0;\n    priority_queue<PII, vector<PII>, greater<PII> > q;\n    q.push(PII(0, s));\n    while (!q.empty()) {\n        PII p = q.top(); q.pop();\n        int i = p.second;\n        if(dist[i] < p.first) continue;\n        for(int j = 0; j < n; j++){\n            if(d[i][j] == -1) continue;\n            if(dist[j] == -1){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }else if(dist[j] > dist[i] + d[i][j]){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }\n        }\n    }\n};\n\n// 線分の交差判定\nbool isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n    // 並行な場合\n    int m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n    if(m == 0) return false;\n    // 媒介変数の値が0より大きく1以下なら交差する、これは問題の状況によって変わるかも。\n    double r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n    double s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n    return (0 < r && r <= 1 && 0 < s && s <= 1);\n};\n\n// 外積の計算 AB CD の内積を求める\nint crossProdct(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy){\n    int abx = bx - ax; int aby = by - ay;\n    int cdx = dx - cx; int cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble crossProdct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble innerProduct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdx + aby * cdy;\n};\n\n// 三角形の内部判定 ABCの中にPがあるか判定\nbool inTriangle(int ax, int ay, int bx, int by, int cx, int cy, int px, int py){\n    int c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    int c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    int c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\nbool inTriangle(double ax, double ay, double bx, double by, double cx, double cy, double px, double py){\n    double c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    double c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    double c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\n\n// 三角形の外心\nvoid circumcenter(double ax, double ay, double bx, double by, double cx, double cy, double res[3]){\n    // AB AC を求める\n    double abx = bx - ax; double aby = by - ay;\n    double acx = cx - ax; double acy = cy - ay;\n    double m = abx * acy - acx * aby; // 分母 m = 0 となるのは3点が一直線になるとき\n    double s = (abx * acx + aby * acy - sq(acx) - sq(acy)) / m; // 媒介変数s\n    res[0] = abx / 2 + s * aby / 2; res[1] = aby / 2 - s * abx / 2;\n    // cout << res[0] << \" \" << res[1] << endl;\n    res[2] = sqrt(sqdist(0, 0, res[0], res[1]));\n    res[0] += ax; res[1] += ay;\n};\n\n\n\n\n/**\n * start\n * @author yoshikyoto\n */\nint w, h;\nstring tile[20];\nint dist[20][20];\nint g[11][11];\nint sx[11], sy[11];\nint dp[1024][11];\nint vy[4] = {-1, 1, 0, 0}, vx[4] = {0, 0, -1, 1};\n\nint dcount = 1;\nint p[11];\n\nvoid dfs(int hist, int curr){\n    for(int next = 1; next < dcount; next++){\n        if(hist & p[next]) continue; // 既に訪れている\n        // 訪れていない\n        int next_hist = hist | p[next];\n        int cost = dp[hist][curr] + g[curr][next];\n        if(cost < dp[next_hist][next] || dp[next_hist][next] == -1){\n            dp[next_hist][next] = cost;\n            dfs(next_hist, next);\n        }\n    }\n};\n\nvoid solve(){\n    FOR(i, h) cin >> tile[i];\n    \n    // 配列をなめて汚れたタイルの位置を獲得、汚れに番号をつける\n    FOR(i, h) FOR(j, w){\n        if(tile[i][j] == '*'){\n            sy[dcount] = i;\n            sx[dcount] = j;\n            tile[i][j] = (char)('0' + dcount); // 汚れに番号を付ける\n            dcount++;\n        }else if(tile[i][j] == 'o'){\n            // 自分の位置\n            sy[0] = i;\n            sx[0] = j;\n            tile[i][j] = '0';\n        }\n    }\n    // グラフの初期化\n    FOR(i, dcount) FOR(j, dcount) g[i][j] = -1;\n    // FOR(i, h) cout << tile[i] << endl;\n    \n    // まずはbfsしてグラフを生成する\n    FOR(i, dcount){\n        FOR(k, h) FOR(l, w) dist[k][l] = -1;\n        dist[sy[i]][sx[i]] = 0;\n        QI yq, xq;\n        yq.push(sy[i]);\n        xq.push(sx[i]);\n        int checked = 1;\n        while(checked < dcount && !yq.empty()){\n            int y = yq.front(); yq.pop();\n            int x = xq.front(); xq.pop();\n            \n            // 上下左右を見る\n            FOR(j, 4){\n                int ny = y+vy[j], nx = x+vx[j]; // nexty, nextx;\n                if(dist[ny][nx] > -1) continue; // 既に訪れた場合\n                if(ny < 0 || ny > h-1 || nx < 0 || nx > w-1) continue; // 部屋を出てしまう場合\n                int dnum = (int)tile[ny][nx] - '0';\n                if(tile[ny][nx] != 'x'){\n                    // 障害物でない場合\n                    yq.push(ny);\n                    xq.push(nx);\n                    dist[ny][nx] = dist[y][x] + 1;\n                    // グラフに追加したい場\n                    if(0 <= dnum && dnum < dcount){\n                        g[i][dnum] = dist[ny][nx];\n                        checked++;\n                    }\n                }\n            }\n        }\n    }\n    \n    /*\n    FOR(i, dcount){\n        FOR(j, dcount){\n            cout << g[i][j] << \" \";\n        }\n        cout << endl;\n    }\n     */\n    \n    // 行けないところがあったらダメ\n    for(int i = 1; i < dcount; i++)\n        if(g[0][i] == -1){\n            cout << -1 << endl;\n            return;\n        }\n    \n    // メモ化再帰\n    FOR(i, 1024) FOR(j, 11) dp[i][j] = -1;\n    FOR(i, dcount) p[i] = (int)pow(2, i);\n    dp[1][0] = 0;\n    dfs(1, 0);\n    \n    int final = 1;\n    for(int i = 1; i < dcount; i++) final += p[i];\n    \n    int ans = dp[final][1];\n    for(int i = 2; i < dcount; i++){\n        ans = min(ans, dp[final][i]);\n    }\n    cout << ans << endl;\n};\n\nint main(int argc, const char * argv[]){\n    begin();\n    while(true){\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        dcount = 1;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ntypedef pair<int,int> P;\nint w,h;\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nint calc(vector<string> grid, P p1, P p2){\n  int used[20][20];\n  memset(used, -1, sizeof(used));\n  queue<P> que;\n  que.push(p1);\n  used[p1.first][p1.second] = 0;\n  while(!que.empty()){\n    P st = que.front(); que.pop();\n    if(st == p2) return used[st.first][st.second];\n    REP(r,4){\n      int cost = used[st.first][st.second];\n      int ny = st.first + dy[r];\n      int nx = st.second + dx[r];;\n      if(0<=ny && ny<h && 0<=nx && nx<w){\n        if(used[ny][nx] == -1 && grid[ny][nx] != 'x'){\n          used[ny][nx] = cost + 1;\n          que.push(P(ny,nx));\n        }\n      }\n    }\n  }\n  return INF;\n}\nint main(){\n  while(cin>>w>>h,w){\n    vector<string> grid(h);\n    REP(i,h)cin>>grid[i];\n    P start;\n    vector<P> target;\n    REP(y,h)REP(x,w){\n      if(grid[y][x]=='o'){\n        start = P(y,x);\n      }else if(grid[y][x] == '*'){\n        target.push_back(P(y,x));\n      }\n    }\n    int n = target.size();\n    int d[10][10] = {};\n    REP(i,n)REP(j,n){\n      d[i][j] = (i!=j)?(calc(grid,target[i],target[j])):0;\n    }\n    int dp[1<<10][10];\n    REP(i,1<<n)REP(j,n)dp[i][j] = INF;\n    REP(i,n)dp[1<<i][i] = calc(grid, start, target[i]);\n    REP(s,1<<n)REP(from,n){\n      REP(to,n){\n        dp[s|1<<to][to] = min(dp[s|1<<to][to], dp[s][from] + d[from][to]);\n      }\n    }\n    int ans = INF;\n    REP(i,n)ans = min(ans, dp[(1<<n)-1][i]);\n    if(ans == INF) ans = -1;\n    cout<<ans<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\n#define fs first\n#define sc second\n\nconst LL MOD = 1e9+7;\nconst double EPS = 1e-10;\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>bool chmin(T &a, const T &b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a,make_vector<T>(b,ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) {\n        is >> e;\n    }\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n\n    operator int() const { return to; }\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\ntemplate<typename T>\nusing Edges = vector<edge<T>>;\ntemplate<typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate<typename T>\nusing MatrixGraph = vector<vector<T>>;\n\n\ntemplate<typename T>\nvoid dijkstra(\n        const WeightedGraph<T> &g,\n        vector<T> &dist,\n        int s)\n{\n    const auto INF = numeric_limits<T>::max();\n    dist.assign(g.size(), INF);\n\n    using Pi = pair< T, int >;\n    priority_queue<Pi, vector<Pi>, greater<Pi>> que;\n    dist[s] = 0;\n    que.emplace(dist[s], s);\n    while(!que.empty()) {\n        T cost;\n        int idx;\n        tie(cost, idx) = que.top();\n        que.pop();\n        if(dist[idx] < cost) continue;\n        for(auto &e : g[idx]) {\n            auto next_cost = cost + e.cost;\n            if(dist[e.to] <= next_cost) continue;\n            dist[e.to] = next_cost;\n            que.emplace(dist[e.to], e.to);\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        int w, h; cin >> w >> h;\n        if (w == 0 && h == 0) {\n            break;\n        }\n\n        vector<pair<int,int>> dirty;\n        pair<int,int> start;\n        vector<string> c(h);\n        for (int i = 0; i < h; ++i) {\n            cin >> c[i];\n            for (int j = 0; j < w; ++j) {\n                if (c[i][j] == '*') {\n                    dirty.emplace_back(i, j);\n                }\n                if (c[i][j] == 'o') {\n                    start = {i, j};\n                }\n            }\n        }\n\n        int m = dirty.size();\n        WeightedGraph<int> G(h*w*(1<<m));\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                int k = distance(\n                        dirty.begin(),\n                        find(dirty.begin(), dirty.end(), make_pair(i, j)));\n                for (int s = 0; s < 1<<m; ++s) {\n                    if (k < m) {\n                        G[i*w*(1<<m) + j*(1<<m) + s].emplace_back(\n                                i*w*(1<<m) + j*(1<<m) + (s | (1<<k)), 0);\n                    }\n\n                    int dx[4] = {0, 1, 0, -1},\n                        dy[4] = {1, 0, -1, 0};\n                    for (int u = 0; u < 4; ++u) {\n                        int y = i + dy[u],\n                            x = j + dx[u];\n                        if (y < 0 || h <= y || x < 0 || w <= x) {\n                            continue;\n                        }\n                        if (c[y][x] == 'x') continue;\n                        G[i*w*(1<<m) + j*(1<<m) + s].emplace_back(\n                                y*w*(1<<m) + x*(1<<m) + s, 1);\n                    }\n                }\n            }\n        }\n\n        vector<int> dist;\n        int s = start.fs*w*(1<<m) + start.sc*(1<<m);\n        dijkstra(G, dist, s);\n\n        int ans = numeric_limits<int>::max();\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                chmin(ans, dist[i*w*(1<<m) + j*(1<<m) + (1<<m)-1]);\n            }\n        }\n\n        if (ans == numeric_limits<int>::max()) {\n            ans = -1;\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int inf = 999999;\n\nstruct St{\n\tP p;\n\tint c;\n};\n\nint xdir[4] = {0, 1, 0, -1}, ydir[4] = {1, 0, -1, 0};\nbool bfs(char a[20][20], int d[11][11], vector<P> vec, int w, int h, P srt)\n{\n\tbool vis[20][20], f = true;\n\tint c = 1, num[20][20];\n\tqueue<St> que;\n\tSt s, t;\n\t\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tif(a[i][j] == '*'){\n\t\t\t\tnum[i][j] = c++;\n\t\t\t} else {\n\t\t\t\tnum[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\ts.p = srt;\n\ts.c = c = 0;\n\tque.push(s);\n\tfill(&vis[0][0], &vis[19][19], true);\n\tvis[s.p.first][s.p.second] = false;\n\twhile(!que.empty()){\n\t\ts = que.front();\n\t\tque.pop();\n\t\tif(a[s.p.first][s.p.second] == '*'){\n\t\t\tc++;\n\t\t\td[0][num[s.p.first][s.p.second]] = s.c;\n\t\t\tif(c == vec.size()){\n\t\t\t\tf = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint dy = s.p.first+ydir[i], dx = s.p.second+xdir[i];\n\t\t\tif(0 <= dy && dy < h && 0 <= dx && dx < w && vis[dy][dx] && a[dy][dx] != 'x'){\n\t\t\t\tvis[dy][dx] = false;\n\t\t\t\tt.p = P(dy, dx);\n\t\t\t\tt.c = s.c+1;\n\t\t\t\tque.push(t);\n\t\t\t}\n\t\t}\n\t}\n\tif(f){\n\t\treturn false;\n\t}\n\t\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tqueue<St> qu;\n\t\tfill(&vis[0][0], &vis[19][19], true);\n\t\ts.p = vec[i];\n\t\ts.c = c = 0;\n\t\tqu.push(s);\n\t\tvis[s.p.first][s.p.second] = false;\n\t\t\n\t\twhile(!qu.empty()){\n\t\t\ts = qu.front();\n\t\t\tqu.pop();\n\t\t\t\n\t\t\tif(a[s.p.first][s.p.second] == '*'){\n\t\t\t\tc++;\n\t\t\t\td[num[vec[i].first][vec[i].second]][num[s.p.first][s.p.second]] = s.c;\n\t\t\t\tif(c == vec.size()){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint dy = s.p.first+ydir[i], dx = s.p.second+xdir[i];\n\t\t\t\tif(0 <= dy && dy < h && 0 <= dx && dx < w && vis[dy][dx] && a[dy][dx] != 'x'){\n\t\t\t\t\tvis[dy][dx] = false;\n\t\t\t\t\tt.p = P(dy, dx);\n\t\t\t\t\tt.c = s.c+1;\n\t\t\t\t\tqu.push(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn true;\n}\n\nint main()\n{\n\tint w, h, d[11][11], num[11];\n\tchar a[20][20];\n\tP s;\n\t\n\twhile(cin>>w>>h && (w+h)){\n\t\tvector<P> vec;\n\t\ts = P(-1,-1);\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tif(a[i][j] == 'o'){\n\t\t\t\t\ts = P(i, j);\n\t\t\t\t} else if(a[i][j] == '*'){\n\t\t\t\t\tvec.push_back(P(i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(s.first == -1 && s.second == -1){\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t} else if(vec.size() == 0){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tfill(&d[0][0], &d[10][10], inf);\n\t\tfor(int i = 0; i < 11; i++){\n\t\t\td[i][i] = 0;\n\t\t}\n\t\tif(bfs(a, d, vec, w, h, s)){\n\t\t\tint n = vec.size()+1, t = inf, u;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tnum[i] = i;\n\t\t\t}\n\t\t\tdo{\n\t\t\t\tu = 0;\n\t\t\t\tfor(int i = 0; i < n-1; i++){\n\t\t\t\t\tu += d[num[i]][num[i+1]];\n\t\t\t\t}\n\t\t\t\tt = min(t, u);\n\t\t\t} while(next_permutation(num, num+n));\n\t\t\tcout << t << endl;\n\t\t} else {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 21\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h,G[N][N];\nstring mp[N];\nmap<P,int>M;\n\nvoid bfs(P s){\n  int D[N][N];\n  memset(D,-1,sizeof(D));\n  queue<P> Q;\n  Q.push(s);\n  int x=s.first,y=s.second;\n  D[y][x]=0;\n  while(!Q.empty()){\n    P t=Q.front();Q.pop();\n    x=t.first,y=t.second;\n    if(mp[y][x]=='*'||mp[y][x]=='o') G[M[s]][M[t]]=D[y][x];\n\n    int dx[]={0,0,-1,1},dy[]={1,-1,0,0};\n    for(int i=0;i<4;i++){\n      int nx=x+dx[i],ny=y+dy[i],cost=D[y][x]+1;\n      if(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx]=='x'||D[ny][nx]!=-1)continue;\n      Q.push(P(nx,ny));\n      D[ny][nx]=cost;\n    }\n  }\n}\n\nint n,num[11];\nP start;\nint calc(){\n  if(M[start]!=num[0])return 1e9;\n  int res=0;\n  for(int i=1;i<n;i++)res+=G[num[i-1]][num[i]];\n  return res;  \n}\n\nint dfs(int idx){\n  if(idx==n) return calc();\n  int res=1e9;\n  for(int i=0;i<n;i++){\n    if(num[i]!=-1)continue;\n    num[i]=idx;\n    res=min(res,dfs(idx+1));\n    num[i]=-1;\n  }\n  return res;\n}\n\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h)break;\n    for(int i=0;i<h;i++) cin>>mp[i];\n    M.clear();\n    memset(G,-1,sizeof(G));\n    memset(num,-1,sizeof(num));\n    n=0;\n    vector<P> p;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tP t=P(j,i);\n\tif(mp[i][j]=='*'||mp[i][j]=='o') p.push_back(t),M[t]=n++;\n\tif(mp[i][j]=='o') start=t;\n      }\n    for(int i=0;i<n;i++)bfs(p[i]);\n\n    bool flg=1;\n    for(int i=0;i<n;i++)if(G[0][i]==-1)flg=0;\n    cout <<(flg?dfs(0):-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\nchar map[21][21];\nint path[12][12];\nint dp[8900];\n\nstruct Point {\n\tint x, y;\n\tPoint() : x(0), y(0) {}\n\tPoint(int x, int y) : x(x), y(y) {}\n};\nPoint dirtyTiles[12]; //dirtyTiles[0]ツづ債δ債ボツッツトツ渉可甘コツ暗環置\n\nbool visited[21][21];\n\nint w = 0;\nint h = 0;\n\nint getShortestPathLength(Point from, Point to) {\n\t//memset(visited, 0, sizeof(visited));\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tvisited[i][j] = map[i][j] == 'x';\n\t\t}\n\t}\n\n\tqueue<Point> que;\n\tque.push(from);\n\n\tint length = -1;\n\n\twhile(!que.empty()) {\n\t\tint curLength = que.size();\n\t\tlength++;\n\t\tfor (int i = 0; i < curLength; i++) {\n\t\t\tPoint point = que.front();\n\t\t\tque.pop();\n\n\t\t\tif (visited[point.y][point.x]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvisited[point.y][point.x] = true;\n\t\t\tif(point.x == to.x && point.y == to.y) {\n\t\t\t\t//cout << \"ret:\" << length << endl;\n\t\t\t\treturn length;\n\t\t\t}\n\t\t\tif(point.x > 0) {\n\t\t\t\tPoint left(point.x-1, point.y);\n\t\t\t\tque.push(left);\n\t\t\t}\n\t\t\tif(point.x < w-1) {\n\t\t\t\tPoint right(point.x+1, point.y);\n\t\t\t\tque.push(right);\n\t\t\t}\n\t\t\tif(point.y > 0) {\n\t\t\t\tPoint up(point.x, point.y-1);\n\t\t\t\tque.push(up);\n\t\t\t}\n\t\t\tif(point.y < h-1) {\n\t\t\t\tPoint down(point.x, point.y+1);\n\t\t\t\tque.push(down);\n\t\t\t}\n\t\t}\n\t}\n\t//cout << \"ret:-1\" << endl;\n\treturn -1;\n}\n\nint main() {\n\twhile(cin >> w >> h, w || h) {\n\n\t\tint dirtyTileSize = 1;\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tmap[i][j] = c;\n\t\t\t\tif(c == 'o') {\n\t\t\t\t\tdirtyTiles[0].x = j; dirtyTiles[0].y = i;\n\t\t\t\t}\n\t\t\t\telse if(c == '*') {\n\t\t\t\t\tdirtyTiles[dirtyTileSize].x = j;\n\t\t\t\t\tdirtyTiles[dirtyTileSize++].y = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n//\t\tfor (int i = 0; i < dirtyTileSize; i++) {\n//\t\t\tfor (int j = 0; j < dirtyTileSize; j++) {\n//\t\t\t\tpath[i][j] = 0;\n//\t\t\t}\n//\t\t}\n\n\t\tfor (int i = 0; i < dirtyTileSize; i++) {\n\t\t\tfor (int j = i + 1; j < dirtyTileSize; j++) {\n\t\t\t\tpath[i][j] = path[j][i] = getShortestPathLength(dirtyTiles[i], dirtyTiles[j]);\n\t\t\t\tif(path[i][j] == -1)\n\t\t\t\t\tgoto unreachable;\n\t\t\t}\n\t\t\tpath[i][i] = 0;\n\t\t}\n\n\t\tgoto reachable;\n\t\tunreachable: {\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\treachable:\n\n\t\t//memset(dp, 0, sizeof(dp));\n\n\t\tint bitMax = 1 << dirtyTileSize;\n\t\tint INF = 10000000;\n\t\tfor (int i = 0; i < bitMax; i++) {\n\t\t\tdp[i] = INF;\n\t\t}\n\n\t\tfor (int i = 1; i < dirtyTileSize; i++) {\n\t\t\tdp[1 << i] = path[0][i];\n\t\t}\n\t\tfor (int i = 1; i < dirtyTileSize; i++) {\n\t\t\tfor (int j = 1; j < dirtyTileSize; j++) {\n\t\t\t\tif(path[i][j] == 0) continue;\n\t\t\t\tfor (int k = 0; k < bitMax; k+=2) {\n\t\t\t\t\tif((k & (1 << i)) > 0 && (k & (1 << j)) == 0) {\n\t\t\t\t\t\tif(dp[k] != INF && (dp[k | (1 << j)] == INF || dp[k] + path[i][j] < dp[k | (1 << j)])) {\n\t\t\t\t\t\t\tdp[k | (1 << j)] = dp[k] + path[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << dp[(1 << dirtyTileSize) - 2] << endl;\n\t\tcontinue;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<cstdlib>\n#include<cmath>\n#include<map>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n#define reep(i,n) reps(i,1,n+1)\n\n#define INF 1000000000\n\nclass T{\n\tpublic:\n\tint y,x,num;\n\tT(int y,int x,int num):y(y),x(x),num(num){}\n\tT(pair<int,int> yx,int num):y(yx.first),x(yx.second),num(num){}\n};\n\nint w,h;\nstring masu[20];\nint cnum[20][20];\nint graph[20][20];\n\nbool cvisit(int visit, int num){\n\tif(visit&(1<<num))return true;\n\treturn false;\n}\n\nbool allvisit(int n, int visit){\n\treps(i,1,n)if(cvisit(visit,i)==false)return false;\n\treturn true;\n}\n\nint memo[(1<<15)];\n\nint saiki(int n, int now, int visit){\n\t\n\tint key = visit + (now<<10);\n\t\n\tif(visit==1){\n\t\treturn 0;\n\t}\n\t\n\tif(memo[key]!=-1) return memo[key];\n\t\n\tint ans = INF;\n\treps(i,1,n){\n\t\tif(cvisit(visit,i)==true){\n\t\t\tint nextvisit = visit - (1<<i);\n\t\t\tans = min(ans, graph[now][i] + saiki(n, i, nextvisit));\n\t\t}\n\t}\n\t\n\t/*\n\tprintf(\"%d %d \",n,now);\n\trep(i,n)printf(\"%d\",cvisit(visit, i));\n\tprintf(\"  = %d\\n\",ans);*/\n\treturn memo[key]=ans;\n}\n\nint main(){\n\t\n\twhile(1){\n\t\tcin>>w>>h;\n\t\tif(w==0)break;\n\t\tvector<pair<int,int> > st(1);\n\t\trep(i,20)rep(j,20)cnum[i][j]=-1;\n\t\trep(i,(1<<15))memo[i]=-1;\n\t\t\n\t\tint n = 1;\n\t\trep(i,h){\n\t\t\tcin>>masu[i];\n\t\t\trep(j,w){\n\t\t\t\tif(masu[i][j]=='*'){\n\t\t\t\t\tcnum[i][j] = n++;\n\t\t\t\t\tst.push_back(make_pair(i,j));\n\t\t\t\t}\n\t\t\t\tif(masu[i][j]=='o'){\n\t\t\t\t\tcnum[i][j] = 0;\n\t\t\t\t\tst[0] = make_pair(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,20)rep(j,20)graph[i][j]=INF;\n\t\t\n\t\trep(i,n){\n\t\t\tqueue<T> que;\n\t\t\tque.push(T(st[i],0));\n\t\t\t\n\t\t\tint visit[20][20]={0};\n\t\t\twhile(1){\n\t\t\t\tif(que.empty())break;\n\t\t\t\t\n\t\t\t\tT u = que.front();\n\t\t\t\tque.pop();\n\t\t\t\t\n\t\t\t\tint y = u.y;\n\t\t\t\tint x = u.x;\n\t\t\t\t\n\t\t\t\tif(x<0 || y<0 || x>=w || y>=h)continue;\n\t\t\t\tif(masu[y][x]=='x')continue;\n\t\t\t\tif(visit[y][x]==1)continue;\n\t\t\t\tvisit[y][x]=1;\n\t\t\t\t\n\t\t\t\tif(cnum[y][x]!=-1 && cnum[y][x]!=i){\n\t\t\t\t\tgraph[i][cnum[y][x]]=u.num;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint dy[] = {1,0,-1,0};\n\t\t\t\tint dx[] = {0,1,0,-1};\n\t\t\t\t\n\t\t\t\trep(p,4){\n\t\t\t\t\tque.push(T(y+dy[p], x+dx[p], u.num+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tprintf(\"%d \",graph[i][j]);\n\t\t\t}puts(\"\");\n\t\t}*/\n\t\t\n\t\tint ans = saiki(n, 0 ,(1<<n)-1);\n\t\tif(ans == INF) puts(\"-1\");\n\t\telse printf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define INFI 100000\n\nstruct point{\n\tint h,w;\n};\n\nclass sales{\nprivate:\n\tint n;\n\tint **dist;\n\tint **dp;\n\tint ans;\npublic:\n\tsales(int n){\n\t\tthis->n=n;\n\t\tdist=new int*[n];\n\t\tfor(int i=0;i<n;i++) dist[i]=new int[n];\n\t\tdp=new int*[1<<n];\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tdp[i]=new int[n];\n\t\t\tfor(int j=0;j<n;j++) dp[i][j]=-1;\n\t\t}\n\t}\n\tvoid set(int n,int m,int c){\n\t\tdist[n][m]=c;\n\t\tdist[m][n]=c;\n\t}\n\tvoid set(){\n\t\tfor(int i=0;i<n;i++) dist[i][0]=0;\n\t\tans=rec(0,0);\n\t}\n\tint rec(int s,int v){\n\t\tif(dp[s][v]>=0) return dp[s][v];\n\n\t\tif(s==(1<<n)-1 && v==0) return dp[s][v]=0;\n\t\tint res=INFI;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(!(s>>i & 1)){\n\t\t\t\tres=i_min(res,rec(s|(1<<i),i)+dist[v][i]);\n\t\t\t}\n\t\t}\n\t\treturn dp[s][v]=res;\n\t}\n\tvoid show(){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++) cout<<dist[i][j]<<\" \";\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\tint i_min(int p,int q){\n\t\tif(p<q) return p;\n\t\treturn q;\n\t}\n\tint ret(){\n\t\treturn ans;\n\t}\n};\n\n\nint w,h;\nchar p[20][21];\nint dist[20][20];\nint dust;\npoint d[10];\nsales *s;\n\nvoid dec(int ph,int pw,int c){\n\tif(p[ph][pw]=='x') return;\n\tif(ph<0 || ph>=h ||pw<0 || pw>=w) return;\n\tif(dist[ph][pw]<=c) return;\n\tdist[ph][pw]=c;\n\t\n\tdec(ph-1,pw,c+1);\n\tdec(ph+1,pw,c+1);\n\tdec(ph,pw-1,c+1);\n\tdec(ph,pw+1,c+1);\n\treturn;\n}\n\nint main(){\n\tint i,j,k;\n\twhile(cin>>w>>h){\n\t\tif(w==0 && h==0) break;\n\t\tdust=0;\n\t\tfor(i=0;i<h;i++){\n\t\t\tcin>>p[i];\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tif(p[i][j]!='.' && p[i][j]!='x'){\n\t\t\t\t\td[dust].h=i;\n\t\t\t\t\td[dust++].w=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts=new sales(dust);\n\t\tint error=0;\n\t\tfor(i=0;i<dust-1;i++){\n\t\t\ts->set(i,i,0);\n\t\t\tfor(j=0;j<h;j++) for(k=0;k<w;k++) dist[j][k]=INFI;\n\t\t\tdec(d[i].h,d[i].w,0);\n\t\t\tfor(j=i+1;j<dust;j++){\n\t\t\t\tif(dist[d[j].h][d[j].w]==INFI){\n\t\t\t\t\terror=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ts->set(i,j,dist[d[j].h][d[j].w]);\n\t\t\t}\n\t\t\tif(error==1) break;\n\t\t}\n\t\tif(error==1){\n\t\t\tcout<<\"-1\"<<endl;\n\t\t}\n\t\telse{\n\t\t\ts->set(dust-1,dust-1,0);\n\t\t\ts->set();\n\t\t\tcout<<s->ret()<<endl;\n\t\t}\n\t\tdelete s;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> Pa;\n\nint dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nconst int inf = 99999;\n\nbool bfs(char a[21][21], int w, int h, Pa pa[12], int p, int dis[12][12])\n{\n\tbool f = false;\n\tfor(int k = 0; k < p-1 ; k++){\n\t\tbool vis[21][21];\n\t\tint d[21][21];\n\t\tqueue<Pa> que;\n\t\tPa t;\n\t\tint s = p-k-1;\n\t\t\n\t\tfill(&d[0][0], &d[h][w], 0);\n\t\tfill(&vis[0][0], &vis[h][w], true);\n\t\ta[pa[k].first][pa[k].second] = '.';\n\t\tque.push(pa[k]);\n\t\tvis[t.first][t.second] = false;\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tt = que.front();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tfor(int i = k+1; i < p; i++){\n\t\t\t\tif(pa[i].first == t.first && pa[i].second == t.second){\n\t\t\t\t\tdis[k][i] = dis[i][k] = d[t.first][t.second];\n\t\t\t\t\ts--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s == 0){\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint u = t.second+dx[i], v = t.first+dy[i];\n\t\t\t\tif(0 <= u && u < w && 0 <= v && v < h){\n\t\t\t\t\tif(vis[v][u] && a[v][u] != 'x'){\n\t\t\t\t\t\tque.push(Pa(v, u));\n\t\t\t\t\t\td[v][u] = d[t.first][t.second]+1;\n\t\t\t\t\t\tvis[v][u] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn f;\n}\n\nint shp(int dis[12][12], int p)\n{\n\tint dp[1<<12][12], n = 1<<p;\n\tfill(&dp[0][0], &dp[(1<<12)-1][11], inf);\n\tdp[1<<0][0] = 0;\n\t\n\tfor(int i = 1<<0; i < n; i++){\n\t\tfor(int j = 0; j < p; j++){\n\t\t\tif(i&(1<<j)){\n\t\t\t\tfor(int k = 0; k < p; k++){\n\t\t\t\t\tif(dp[i|(1<<k)][k] > dp[i][j]+dis[j][k]){\n\t\t\t\t\t\tdp[i|(1<<k)][k] = dp[i][j]+dis[j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint t = inf;\n\tfor(int i = 0; i < p; i++){\n\t\tt = min(t, dp[n-1][i]);\n\t}\n\t\n\treturn t;\n}\n\nint tsp(int dis[12][12], int p)\n{\n\tint dp[1<<12][12];\n\tfill(&dp[0][0], &dp[(1<<12)-1][11], inf);\n\tdp[(1<<p)-1][1] = 0;\n\t\n\tfor(int i = (1<<p)-2; i >= 1; i--){\n\t\tfor(int j = 0; j < p; j++){\n\t\t\tfor(int k = 0; k < p; k++){\n\t\t\t\tif(i>>k & 1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i|1<<k][k]+dis[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < p; i++){\n\t\tfor(int j = 0; j < p; j++){\n\t\t\tcout << dis[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\tfor(int i = 0; i < 1<<p; i++){\n\t\tfor(int j = 0; j < p; j++){\n\t\t\tprintf(\"%6d\", dp[i][j]);\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn dp[1][0];\n}\n\nint main()\n{\n\tint h, w;\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0){\n\t\t\tbreak;\n\t\t}\n\t\tint p=1, dis[12][12];\n\t\tchar a[21][21];\n\t\tPa pa[12];\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tcin >> a[i];\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(a[i][j] == 'o'){\n\t\t\t\t\tpa[0] = Pa(i, j);\n\t\t\t\t}\n\t\t\t\tif(a[i][j] == '*'){\n\t\t\t\t\tpa[p++] = Pa(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfill(&dis[0][0], &dis[p][p], inf);\t\n\t\tfor(int i = 0; i < p; i++){\n\t\t\tdis[i][i] = 0;\n\t\t}\n\t\t\n\t\tif(bfs(a, w, h, pa, p, dis)){\n\t\t\t// cout << tsp(dis, p) << endl;\n\t\t\tcout << shp(dis, p) << endl;\n\t\t} else {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<deque>\n#include<iomanip>\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<int,int> P;\ntypedef pair<int,pair<int,int> > PP;\ntypedef pair<LL,int> LP;\nconst int INF=1<<30;\nconst LL MAX=1e9+7;\n\nvoid array_show(int *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%d%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid array_show(LL *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%lld%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid print_YES_NO(bool answer){cout<<(answer?\"YES\":\"NO\")<<endl;}\nvoid print_Yes_No(bool answer){cout<<(answer?\"Yes\":\"No\")<<endl;}\nvoid print_POSSIBLE_IMPOSSIBLE(bool answer){cout<<(answer?\"POSSIBLE\":\"IMPOSSIBLE\")<<endl;}\n\nqueue<P> q1;\n\nchar ca[100];\nint p[25][2];//place\nbool good[25][25];\nint used[25][25];\nint dis[25][25];\nint dp[1<<15][15];\n\nint main(){\n\tint n,m;\n\tint i,j,k;\n\tint a,b,c;\n\tint x,y;\n\tint s;\n\twhile(cin>>m>>n){\n\t\tif(n==0 && m==0)break;\n\t\tk=1;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>ca;\n\t\t\tfor(j=0;j<m;j++){\n\t\t\t\tif(ca[j]=='x')good[i][j]=false;\n\t\t\t\telse good[i][j]=true;\n\t\t\t\tif(ca[j]=='o')p[0][0]=i,p[0][1]=j;\n\t\t\t\tif(ca[j]=='*')p[k][0]=i,p[k][1]=j,k++;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<k;i++){\n\t\t\tmemset(used,-1,sizeof(used));\n\t\t\tq1.push(make_pair(p[i][0],p[i][1]));\n\t\t\tfor(j=0;x=q1.size();j++){\n\t\t\t\twhile(x--){\n\t\t\t\t\ta=q1.front().first,b=q1.front().second,q1.pop();\n\t\t\t\t\tif(a<0 || a>=n || b<0 || b>=m)continue;\n\t\t\t\t\tif(!good[a][b])continue;\n\t\t\t\t\tif(used[a][b]!=-1)continue;\n\t\t\t\t\tused[a][b]=j;\n\t\t\t\t\tq1.push(make_pair(a-1,b));\n\t\t\t\t\tq1.push(make_pair(a+1,b));\n\t\t\t\t\tq1.push(make_pair(a,b-1));\n\t\t\t\t\tq1.push(make_pair(a,b+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=0;j<k;j++){\n\t\t\t\tdis[i][j]=used[p[j][0]][p[j][1]];\n\t\t\t}\n\t\t}\n\t\tk--;\n\t\tfor(i=0;i<(1<<k);i++)for(j=0;j<k;j++)dp[i][j]=INF;\n\t\tfor(i=0;i<k;i++)if(dis[0][i+1]!=-1)dp[0][i]=dis[0][i+1];\n\t\tfor(i=0;i<(1<<k);i++){\n\t\t\tfor(j=0;j<k;j++){\n\t\t\t\tif(i&(1<<j))continue;\n\t\t\t\tfor(x=0;x<k;x++){\n\t\t\t\t\tif((i&(1<<x))==0)continue;\n\t\t\t\t\tif(dis[j+1][x+1]!=-1)dp[i][j]=min(dp[i][j],dp[i-(1<<x)][x]+dis[j+1][x+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts=INF;\n\t\tfor(i=0;i<k;i++){\n\t\t\ts=min(s,dp[(1<<k)-(1<<i)-1][i]);\n\t\t}\n\t\tif(s==INF)s=-1;\n\t\tcout<<s<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n#include<iomanip>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\n\n\n\n\n\n\n//計算\nusing pii = pair<int, int>;\n\ntemplate<typename T>\nusing v = vector<T>;\n\ntemplate<typename T>\nusing vv = vector<vector<T>>;\n\n\nbool judge_go(const int& nowDist, const pii& next, const vv<bool>& can, const vv<int>& dist)\n{\n\tint H = can.size();\n\tint W = can[0].size();\n\n\t// there\n\tif (next.first < 0 || H <= next.first)return false;\n\tif (next.second < 0 || W <= next.second)return false;\n\n\t//could\n\tif (!can[next.first][next.second])return false;\n\n\t//best\n\tint nextDist = dist[next.first][next.second];\n\n\tif (nowDist + 1 <  nextDist) return true;\n\n\treturn false;\n}\n\n\nvoid step(\n\tconst int& nowDist,\n\tconst pii& next, \n\tconst vv<bool>& can,\n\tvv<int>& dist,\n\tqueue<pii>& q) \n{\n\tif (judge_go(nowDist, next, can, dist)) {\n\t\tdist[next.first][next.second] = nowDist + 1;\n\t\tq.push(next);\n\t}\n}\n\n\nvv<int>min_dist(const vv<bool>& can, pii start)\n{\n\tint H = can.size();\n\tint W = can[0].size();\n\tvv<int> dist = vv<int>(H, v<int>(W, INF));\n\tqueue<pii> q;\n\n\tdist[start.first][start.second] = 0;\n\tq.push(start);\n\n\twhile (!q.empty()) {\n\t\tpii now = q.front(); q.pop();\n\t\tpii next = now;\n\t\tint nowDist = dist[now.first][now.second];\n\n\t\t//up\n\t\tnext.first--;\n\t\tstep(nowDist, next, can, dist, q);\n\t\tnext.first++;\n\n\t\t//down\n\t\tnext.first++;\n\t\tstep(nowDist, next, can, dist, q);\n\t\tnext.first--;\n\n\t\t//left\n\t\tnext.second--;\n\t\tstep(nowDist, next, can, dist, q);\n\t\tnext.second++;\n\n\t\t//right\n\t\tnext.second++;\n\t\tstep(nowDist, next, can, dist, q);\n\t\tnext.second--;\n\t}\n\treturn dist;\n}\n\nbool approach(const vv<int>& dist, const vector<pii>& dusts)\n{\n\tfor (auto dust : dusts) {\n\t\tif (dist[dust.first][dust.second] == INF) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint measure_dist(\n\tconst vv<int>& baseDist,\n\tconst v<vv<int>>& dists,\n\tconst v<pii>& dusts,\n\tconst v<int>& routes)\n{\n\tpii now = dusts[routes.front()];\n\tint res = baseDist[now.first][now.second];\n\t\n\tREP(i, (int)routes.size() - 1) {\n\t\tint now = routes[i];\n\t\tpii next = dusts[routes[i + 1]];\n\t\tres += dists[now][next.first][next.second];\n\t}\n\treturn res;\n}\n\nvoid calc(const vv<bool>& can, const vector<pii>& dusts, pii start)\n{\n\t//distance data\n\tauto baseDist = min_dist(can, start);//from robot\n\tv<vv<int>> dists;//from dust\n\tfor (auto dust : dusts) {\n\t\tdists.push_back(min_dist(can, dust));\n\t}\n\n\t//exception\n\tif (!approach(baseDist, dusts)) {\n\t\tcout << -1 << endl;\n\t\treturn;\n\t}\n\n\t//route data\n\tint ans = INF;\n\tv<int> route;\n\tREP(i, dusts.size())route.push_back(i);\n\tdo {\n\t\tans = min(ans, measure_dist(baseDist, dists, dusts, route));\n\t} while (next_permutation(route.begin(), route.end()));\n\n\tcout << ans << endl;\n\t/*\n\tfor (auto row : baseDist) {\n\t\tfor (int col : row) {\n\t\t\tif (col == INF)cerr << \"  .\";\n\t\t\telse cerr << setw(3) << col;\n\t\t}\n\t\tcerr << endl;\n\t}\n\t*/\n}\n\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\twhile (true) {\n\t\tint H, W;\n\t\tpii start;\n\t\tvv<bool> can;\n\t\tvector<pii> dusts;\n\n\t\tcin >> W >> H;\n\t\tif (H == 0)break;\n\n\t\tREP(i, H) {\n\t\t\tv<bool> v;\n\t\t\tstring s;\n\t\t\tcin >> s;\n\n\t\t\tREP(j,W){\n\t\t\t\tchar c = s[j];\n\t\t\t\tv.push_back(c != 'x');\n\t\t\t\tif (c == 'o') {\n\t\t\t\t\tstart = { i,j };\n\t\t\t\t}\n\t\t\t\tif (c == '*') {\n\t\t\t\t\tdusts.push_back({ i,j });\n\t\t\t\t}\n\t\t\t}\n\t\t\tcan.push_back(v);\n\t\t}\n\t\tcalc(can, dusts, start);\n\t}\n\t//debug();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████   \n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define fs first\n#define sc second\n#define D double\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=a;i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<vector<P> > Graph;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nvector<string> s;\nmat b(20,vec(20,0));\nint h,w;\nint dx[] = {1,-1,0,0}, dy[] = {0,0,1,-1};\n\nvoid bfs(int u, int v){\n  queue<P> que;\n  que.push(P(u,v));\n  b[u][v] = 0;\n\n  while(que.size()){\n    int x = que.front().fs, y = que.front().sc;\n    que.pop();\n    REP(i,4){\n      if(range(x+dx[i],0,h) && range(y+dy[i],0,w)){\n        if(s[x+dx[i]][y+dy[i]] != 'x' && b[x+dx[i]][y+dy[i]] == -1){\n          que.push(P(x+dx[i],y+dy[i]));\n          b[x+dx[i]][y+dy[i]] = b[x][y]+1;\n        }\n      }\n    }\n  }\n}\n\nvoid solve(){\n  s.resize(h);\n  REP(i,h) cin >> s[i];\n\n  int n = 1;\n  REP(i,h) REP(j,w) if(s[i][j]=='*') n++;\n\n  mat dist(n,vec(n,0));\n  int cur = 0, start;\n  REP(i,h) REP(j,w){\n    if(s[i][j]=='*' || s[i][j]=='o'){\n      if(s[i][j]=='o') start = cur;\n      REP(i,h) REP(j,w) b[i][j] = -1;\n      bfs(i,j);\n      int id = 0;\n      REP(i,h) REP(j,w){\n        if(s[i][j]=='*' || s[i][j]=='o'){\n          dist[cur][id] = b[i][j];\n          if(b[i][j] == -1){\n            cout << -1 << endl;\n            return;\n          }\n          id++;\n        }\n      }\n      cur++;\n    }\n  }\n\n  mat dp(1<<n,vec(n,INF));\n  dp[1<<(start)][start] = 0;\n\n  REP(i,1<<n){\n    REP(j,n){\n      if(i&(1<<j)) continue;\n      REP(k,n) dp[i|(1<<j)][j] = min(dp[i|(1<<j)][j],dp[i][k]+dist[k][j]);\n    }\n  }\n\n  int ans = INF;\n  REP(i,n) ans = min(ans,dp[(1<<n)-1][i]);\n  cout << ans << endl;\n\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  while(cin >> w >> h, w) solve();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <unordered_set>\n# include <unordered_map>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define STR(x) string x;cin>>x;\n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl;\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<int> vi;\ntypedef vector<lint> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\ntemplate<class T> void debug(T a) { for (auto i : a)cout << i << endl; }\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint x, y;\n\t\tint a[22][22];\n\t\tpii start; \n\t\tvector<pii> goals;\n\n\t\tcin >> x >> y; if (!x)break;\n\t\tmemset(a, -1, sizeof a);\n\t\t\n\t\tFORI(i, 1, y + 1)\n\t\t{\n\t\t\tFORI(j, 1, x + 1)\n\t\t\t{\n\t\t\t\ta[i][j] = 0;\n\t\t\t\tchar c; cin >> c;\n\t\t\t\tif (c == 'o')start = pii(i, j);\n\t\t\t\tif (c == 'x')a[i][j] = -1;\n\t\t\t\tif (c == '*') { a[i][j] = 1; goals.emplace_back(i, j); }\n\t\t\t}\n\t\t}\n\t\tgoals.push_back(start);\n\n\t\tauto calc_cost=[&a](pii start)->vector<vi> \n\t\t{\n\t\t\tvi line(22, INF);\n\t\t\tvector<vi> ans(22, line);\n\t\t\tans[start.first][start.second] = 0;\n\t\t\tpriority_queue< piii, vector<piii>, greater<piii> >que;\n\t\t\tque.push(piii(0, start));\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tpiii now = que.top(); que.pop();\n\t\t\t\tFOR(i, 4)\n\t\t\t\t{\n\t\t\t\t\tpii p=now.second;\n\t\t\t\t\tp.first += dy[i]; p.second += dx[i];\n\t\t\t\t\tif (ans[p.first][p.second] > now.first + 1 && a[p.first][p.second] != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tpiii next(now.first+1,p);\n\t\t\t\t\t\tans[p.first][p.second] = next.first;\n\t\t\t\t\t\tque.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans;\n\t\t};\n\t\tvector<vi> costs;\n\t\tbool ok = true;\n\n\t\tFOR(i, goals.size())\n\t\t{\n\t\t\tvector<vi> map=calc_cost(goals[i]);\n\t\t\tvi f;\n\t\t\tFOR(j, goals.size())\n\t\t\t{\n\t\t\t\tint cost = map[goals[j].first][goals[j].second];\n\t\t\t\tif (cost >= INF)ok = false;\n\t\t\t\tf.push_back(cost);\n\t\t\t}\n\t\t\tcosts.push_back(f);\n\t\t}\n\t\tif (!ok) { cout << \"-1\" << endl; break; }\n\t\ttypedef pair< int, pair<int, vi> > P;\n\t\tP s(0, pair<int, vi>(goals.size() - 1, {(int)goals.size()-1}));\n\t\tpriority_queue< P, vector<P>, greater<P> > que;\n\t\tque.push(s);\n\t\t\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tP now = que.top(); que.pop();\n\t\t\tif (now.second.second.size() == goals.size())\n\t\t\t{\n\t\t\t\tcout << now.first << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tFOR(i, costs[now.second.first].size())\n\t\t\t{\n\t\t\t\tif (!count(ALL(now.second.second), i))\n\t\t\t\t{\n\t\t\t\t\tP next = now;\n\t\t\t\t\tnext.first += costs[now.second.first][i];\n\t\t\t\t\tnext.second.first = i;\n\t\t\t\t\tnext.second.second.push_back(i);\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF (1<<29)\n#define LINF LLONG_MAX/3\n#define mp make_pair\n#define pb push_back\n#define EB emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint w,h;\n\nvoid solve(){\n    char c[32][32];\n    rep(i,h) scanf(\"%s\",c[i]);\n\n    int sx,sy;\n    rep(i,h) rep(j,w) if(c[i][j]=='o'){\n        sx = i;\n        sy = j;\n        break;\n    }\n\n    int g[512][512];\n    rep(i,512) rep(j,512) g[i][j]=INF;\n    rep(i,512) g[i][i]=0;\n\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(c[i][j]=='x') continue;\n            int v = i*w+j;\n            for(int k=0;k<4;k++){\n                int nx=i+dx[k],ny=j+dy[k];\n                if(nx<0||ny<0||nx>=h||ny>=w) continue;\n                if(c[nx][ny]=='x') continue;\n                int nv = nx*w+ny;\n                g[v][nv] = 1;\n                g[nv][v] = 1;\n            }\n        }\n    }\n\n    int V = h*w;\n    for(int k=0;k<V;k++){\n        for(int i=0;i<V;i++){\n            for(int j=0;j<V;j++){\n                g[i][j] = min(g[i][j],g[i][k]+g[k][j]);\n            }\n        }\n    }\n\n    vector<int> as;\n    rep(i,h) rep(j,w){\n        int v = i*w+j;\n        if(c[i][j]=='*') as.pb(v);\n    }\n\n    sort(all(as));\n\n    assert(as.size()<=10);\n    int ans = INF;\n\n    do{\n        int tmp=0;\n        int now = sx*w+sy;\n        for(int i=0;i<sz(as);i++){\n            tmp += g[now][as[i]];\n            if(g[now][as[i]]==INF){\n                cout << -1 << endl;\n                return;\n            }\n            now = as[i];\n        }\n        ans = min(tmp,ans);\n    }while(next_permutation(all(as)));\n\n    if(ans==INF) cout << -1 << endl;\n    else cout << ans << endl;\n}\n\nint main(){\n    int cnt=0;\n    while(cin>>w>>h){\n        //cnt++;\n        //flag=false;\n        //if(cnt==363) flag=true;\n        if(w==0 and h==0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <queue>\n#include <string>\n#include <numeric>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\nint const inf = 1 << 29;\ntypedef int Weight;\nstruct Edge{\n    Edge(int src, int dst, int cost)\n        :src(src), dst(dst), cost(cost){}\n    int src, dst, cost;\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nint W, H;\n\nint dx[] = { 1, 0, -1, 0 };\nint dy[] = { 0, 1, 0, -1 };\n\nconst int MAXN = 12;\nint n;\nint d[MAXN][MAXN];\nint dp[1 << MAXN][MAXN];\n\nint rec(int S, int v) {\n    if (dp[S][v] >= 0) return dp[S][v];\n    if (S == (1 << n) - 1 && v == 0) return dp[S][v] = 0;\n    int tmp = inf;\n    rep(u, n) if (!(S >> u & 1)) tmp = min(tmp, rec(S | 1 << u, u) + d[v][u]);\n    return dp[S][v] = tmp;\n}\n\n// テ」ツ?づ」ツつ甘ヲツ慊ャテ」ツ?ョテ」ツδ?」ツつ、テ」ツつッテ」ツつケテ」ツδ暗」ツδゥテヲツウツ陛」ツつ担pagetti Sourceテ」ツ?ョAPIテ」ツ?ォテ・ツ青暗」ツつ湘」ツ?崚」ツ?淌」ツつづ」ツ?ョ\nstruct State {\n    int v, d;\n    State(int v, int d) : v(v), d(d){}\n    bool operator<(const State& s)const{\n        return d>s.d;\n    }\n};\n\nvoid dijkstra(Graph const &g, int s, vector<Weight> &dist) {\n    priority_queue<State> q;\n    dist.assign(g.size(), inf); dist[s] = 0;\n    q.push(State(s, 0));\n    while (q.size()) {\n        State s = q.top(); q.pop();\n        int v = s.v;\n        if (dist[v] < s.d) continue;\n        rep(i, g[v].size()){\n            const Edge &e = g[v][i];\n            if (dist[e.dst] > dist[v] + e.cost) {\n                dist[e.dst] = dist[v] + e.cost;\n                q.push(State(e.dst, dist[e.dst]));\n            }\n        }\n    }\n}\n\n\ninline bool valid(int x, int y){\n    return 0 <= x && x < W && 0 <= y && y < H;\n}\n\nint solve(vector<string> grid){\n    Graph g(W*H);\n    vector<int> dust;\n    int s;\n    rep(y, H)rep(x, W){\n        rep(i, 4){\n            int tx = x + dx[i];\n            int ty = y + dy[i];\n            if (!valid(tx, ty)) continue;\n            if (grid[ty][tx] == 'x') continue;\n            int src = y*H + x;\n            int dst = ty*H + tx;\n            g[src].push_back(Edge(src, dst, 1));\n        }\n    }\n\n    rep(i, H)rep(j, W){\n        if (grid[i][j] == '*'){\n            dust.push_back(i*H + j);\n        }\n        if (grid[i][j] == 'o'){\n            s = i*H + j;\n        }\n    }\n    dust.push_back(s);\n    int V = dust.size();\n    rep(i, V)rep(j, V){\n        d[i][j] = inf;\n    }\n    rep(i, 1 << MAXN)rep(j, MAXN){\n        dp[i][j] = -1;\n    }\n\n    rep(i, V){\n        vector<int> dist;\n        dijkstra(g, dust[i], dist);\n        rep(j, V){\n            d[i][j] = dist[dust[j]];\n        }\n    }\n\n    int res = rec(0, V - 1);\n    if (res == inf) res = -1;\n    return res;\n}\n\nint main(){\n    while (cin >> W >> H && W | H){\n        vector<string> grid(H);\n        rep(i, H){\n            cin >> grid[i];\n        }\n        cout << solve(grid) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nint main(){\n\tint w,h;\n\t\twhile(cin >> w >> h&&w!=0){\n\t\tvector<string>v(h);\n\t\trep(i,h){\n\t\t\tcin >> v[i];\n\t\t}\n\t\tvector<int> p;\n\t\tint s;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(v[i][j]=='o'){\n\t\t\t\t\ts = i*w+j;\n\t\t\t\t\tv[i][j] = '.';\n\t\t\t\t}\n\t\t\t\tif(v[i][j]=='*'){\n\t\t\t\t\tp.PB(i*w+j);\n\t\t\t\t\tv[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<long long> > d(h*w,vector<long long>(h*w,inf));\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(i!=0){\n\t\t\t\t\tif(v[i][j]=='.'&&v[i-1][j]=='.'){\n\t\t\t\t\t\td[i*w+j][(i-1)*w+j]=1;\n\t\t\t\t\t\td[(i-1)*w+j][i*w+j]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i!=h-1){\n\t\t\t\t\tif(v[i][j]=='.'&&v[i+1][j]=='.'){\n\t\t\t\t\t\td[i*w+j][(i+1)*w+j]=1;\n\t\t\t\t\t\td[(i+1)*w+j][i*w+j]=1;\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(j!=0){\n\t\t\t\t\tif(v[i][j]=='.'&&v[i][j-1]=='.'){\n\t\t\t\t\t\td[i*w+j][i*w+j-1]=1;\n\t\t\t\t\t\td[i*w+j-1][i*w+j]=1;\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(j!=w-1){\n\t\t\t\t\tif(v[i][j]=='.'&&v[i][j+1]=='.'){\n\t\t\t\t\t\td[i*w+j][i*w+j+1]=1;\n\t\t\t\t\t\td[i*w+j+1][i*w+j]=1;\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(k,h*w){\n\t\t\trep(i,h*w){\n\t\t\t\trep(j,h*w){\n\t\t\t\t\td[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = inf+inf;\n\t\twhile(next_permutation(p.begin(),p.end())){\n\t\t\tll tmp=0;\n\t\t\ttmp += d[s][p[0]];\n\t\t\tfor(int i=0;i<p.size()-1;i++){\n\t\t\t\ttmp += d[p[i]][p[i+1]];\n\t\t\t}\n\t\t\tans = min(ans,tmp);\n\t\t}\n\t\tif(ans>=inf)cout << -1 << endl;\n\t\telse cout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1140&lang=jp\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nstruct edge {\n\tint from;\n\tint to;\n\tint dist;\n\tedge() {}\n\tedge(int from, int to, int dist) :from(from), to(to), dist(dist) {}\n};\n\nvoid calc_cost(int x, int y,vector<vector<int>>& cost,vector<vector<char>>& masu) {\n\tqueue<pii> q; q.push({ x,y });\n\tcost[x][y] = 0;\n\twhile (!q.empty()) {\n\t\tpii p = q.front(); q.pop();\n\t\tfor (int i = 0; i < 4;i++) {\n\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\tif (masu[nx][ny] == 'x')continue;\n\t\t\tif (cost[nx][ny] > cost[p.first][p.second] + 1) {\n\t\t\t\tcost[nx][ny] = cost[p.first][p.second] + 1;\n\t\t\t\tq.push({ nx,ny });\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint w, h;\n\twhile (cin >> w >> h, w | h) {\n\t\tvector<vector<char>> masu(h + 2, vector<char>(w + 2, 'x'));\n\t\tvector<pii> yogore;\n\t\tint sidx;\n\t\tfor (int i = 1; i <= h;i++) {\n\t\t\tfor (int j = 1;j <= w;j++) {\n\t\t\t\tcin >> masu[i][j];\n\t\t\t\tif (masu[i][j] == '*'||masu[i][j] == 'o') {\n\t\t\t\t\tif (masu[i][j] == 'o')sidx = yogore.size();\n\t\t\t\t\tmasu[i][j] = '.';\n\t\t\t\t\tyogore.push_back({ i,j });\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint YOGORE = (int)yogore.size();\n\t\tvector<vector<edge>> dist(YOGORE);\n\t\tfor (int i = 0; i < YOGORE;i++) {\n\t\t\tvector<vector<int>> cost(h + 2, vector<int>(w + 2, INF));\n\t\t\tcalc_cost(yogore[i].first, yogore[i].second,cost, masu);\n\t\t\tfor (int j = 0; j < YOGORE; j++) {\n\t\t\t\tif (sidx == j)continue;\n\t\t\t\tif (cost[yogore[j].first][yogore[j].second] == INF)continue;\n\t\t\t\tdist[i].push_back(edge(i,j,cost[yogore[j].first][yogore[j].second]));\n\t\t\t}\n\t\t}\n\t\tint dp[11][1 << 11];\n\t\tfor (int i = 0; i < 11;i++)for (int j = 0; j < (1 << 11);j++)dp[i][j] = INF;\n\t\tdp[sidx][1 << sidx] = 0;\n\t\tfor (int j = 1;j < (1 << YOGORE);j++) {\n\t\t\tfor (int i = 0; i < YOGORE;i++) {\n\t\t\t\tif (dp[i][j] == INF)continue;\n\t\t\t\tfor (auto e : dist[i]) {\n\t\t\t\t\tif ((1 << e.to) & j) continue;\n\t\t\t\t\t//cout << e.from << \" ??? \" << e.to << \" : \" << e.dist << endl;\n\t\t\t\t\tdp[e.to][(1 << e.to) | j] = min(dp[e.to][(1 << e.to) | j], dp[e.from][j] + e.dist);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 1; i < YOGORE;i++) {\n\t\t\tans = min(ans, dp[i][(1 << YOGORE)-1]);\n\t\t}\n\t\tcout << ((ans==INF)?-1:ans) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\nsigned main(){\n    ios::sync_with_stdio(false);\n\tcin.tie(0);\n    cout << fixed << setprecision(20);\n\n    int h,w;\n    while(cin>>w>>h){\n        if(h==0) break;\n        string s[h];\n        for(int i=0;i<h;i++){\n            cin>>s[i];\n        }\n        int n = h*w;\n        int dp[n][n]={};\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(j==i) continue;\n                dp[i][j] = 1e9;\n            }\n        }\n        int dx[4] = {0,1,0,-1};\n        int dy[4] = {1,0,-1,0};\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(s[i][j] == 'x') continue;\n                for(int k=0;k<4;k++){\n                    int x = dx[k] + i , y = dy[k]+j;\n                    if(x<0 || x>=h || y<0 || y>=w) continue;\n                    if(s[x][y] == 'x') continue;\n                    dp[i*w+j][x*w+y]=1;\n                }\n            }\n        }\n        for(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++){\n            dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j]);\n        }\n        vector<int> v;\n        int now = 0;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(s[i][j]=='*'){\n                    v.push_back(i*w+j);\n                }\n                if(s[i][j] == 'o') now = i*w+j;\n            }\n        }\n        sort(v.begin(),v.end());\n        int ans = 1e9;\n        bool pos = true;\n        do{\n            int t = now;\n            int ret = 0;\n            for(int i:v){\n                if(dp[t][i]==1e9){\n                    pos = false;\n                    break;\n                }\n                ret += dp[t][i];\n                t = i;\n            }\n            if(pos == false) break;\n            ans = min(ans,ret);\n        }while(next_permutation(v.begin(),v.end()));\n\n        if(ans == 1e9)ans = -1;\n        cout << ans << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 28;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nclass Point\n{\npublic:\n  int x, y;\n  Point(int _x = 0, int _y = 0)\n    :x(_x), y(_y) {}\n};\n\nint N, cost[20][20][20][20], dist[11][11], dp[1 << 11][11];\n\nint solve(int S, int v)\n{\n  if (dp[S][v] != -1)\n    return dp[S][v];\n\n  if (S == (1 << N)-1) {\n    dp[S][v] = 0;\n    return 0;\n  }\n\n  int ret = INF;\n  for (int i = 0; i < N; ++i) {\n    if (!(S & (1 << i)))\n      ret = min(ret, solve(S | (1 << i), i)+dist[v][i]);\n  }\n  dp[S][v] = ret;\n  return ret;\n}\n\nint main()\n{\n  int w, h;\n  while (cin >> w >> h) {\n    if ((w | h) == 0)\n      break;\n\n    // init\n    for (int i = 0; i < 20; ++i) {\n      for (int j = 0; j < 20; ++j) {\n\tfor (int k = 0; k < 20; ++k) {\n\t  for (int l = 0; l < 20; ++l)\n\t    cost[i][j][k][l] = INF;\n\t}\n      }\n    }\n    for (int i = 0; i < 11; ++i) {\n      for (int j = 0; j < 11; ++j)\n\tdist[i][j] = 0;\n    }\n    for (int i = 0; i < (1 << 11); ++i) {\n      for (int j = 0; j < 11; ++j)\n\tdp[i][j] = -1;\n    }\n\n    vector<string> floor(h);\n    for (int i = 0; i < h; ++i)\n      cin >> floor[i];\n\n    Point robot;\n    vector<Point> tiles;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n\tif (floor[i][j] == 'x') {\n\t  continue;\n\t} else if (floor[i][j] == 'o') {\n\t  robot.x = j;\n\t  robot.y = i;\n\t} else if (floor[i][j] == '*') {\n\t  tiles.push_back(Point(j, i));\n\t}\n      }\n    }\n\n    tiles.insert(tiles.begin(), robot);\n    for (unsigned int i = 0; i < tiles.size(); ++i) {\n      queue<Point> que;\n      que.push(tiles[i]);\n      cost[tiles[i].y][tiles[i].x][tiles[i].y][tiles[i].x] = 0;\n      while (!que.empty()) {\n\tconst Point p = que.front();\n\tque.pop();\n\n\tfor (int d = 0; d < 4; ++d) {\n\t  Point pp(p.x + dx[d], p.y + dy[d]);\n\t  if (pp.x < 0 || pp.x >= w || pp.y < 0 || pp.y >= h || floor[pp.y][pp.x] == 'x')\n\t    continue;\n\t  if (cost[tiles[i].y][tiles[i].x][pp.y][pp.x] > cost[tiles[i].y][tiles[i].x][p.y][p.x]+1) {\n\t    cost[tiles[i].y][tiles[i].x][pp.y][pp.x] = cost[tiles[i].y][tiles[i].x][p.y][p.x]+1;\n\t    que.push(pp);\n\t  }\n\t}\n      }\n    }\n\n    bool valid = true;\n    for (unsigned int i = 0; i < tiles.size(); ++i) {\n      for (unsigned int j = i+1; j < tiles.size(); ++j) {\n\tdist[i][j] = dist[j][i] = cost[tiles[i].y][tiles[i].x][tiles[j].y][tiles[j].x];\n\tif (dist[i][j] >= INF)\n\t  valid = false;\n      }\n    }\n\n    if (!valid) {\n      cout << \"-1\" << endl;\n    } else {\n      N = tiles.size();\n      cout << solve(1, 0) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nchar stage[20][20];\n\nclass Data{\npublic:\n\tint cost;\n\tint x;\n\tint y;\n\tint visited;\n\tData() : cost(0),x(0),visited(0){}\n\tData(int _cost,int _x,int _y,int _visited){\n\t\tthis->cost = _cost;\n\t\tthis->x = _x;\n\t\tthis->y = _y;\n\t\tthis->visited = _visited;\n\t}\n\n\tbool operator>(const Data& d) const{\n\t\treturn this->cost > d.cost;\n\t}\n};\n\nint cost[500][1<<10];\n\nint main()\n{\n\tint W,H;\n\twhile(~scanf(\"%d %d\",&W,&H)){\n\t\tif(W==H && H==0) break;\n\t\tint sx, sy;\n\t\tint idx = 0;\n\t\tmap<P,int> id;\n\t\tfor(int y=0;y<H;y++){\n\t\t\tchar buf[32];\n\t\t\tscanf(\"%s\",buf);\n\t\t\t\n\t\t\tfor(int x=0;x<W;x++){\n\t\t\t\tstage[y][x] = buf[x];\n\t\t\t\tif(buf[x] == 'o'){\n\t\t\t\t\tsx = x;\n\t\t\t\t\tsy = y;\n\t\t\t\t}\n\t\t\t\telse if(buf[x] == '*'){\n\t\t\t\t\tid[P(x,y)]=idx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpriority_queue<Data,vector<Data>,greater<Data> > que;\n\t\tque.push(Data(0,sx,sy,0));\n\n\t\t\n\t\tmemset(cost,0x3f,sizeof(cost));\n\n\t\tcost[sy*W+sx][0] = 0;\n\t\twhile(!que.empty()){\n\t\t\tData d = que.top();\n\t\t\tque.pop();\n\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint dx = d.x + tx[i];\n\t\t\t\tint dy = d.y + ty[i];\n\t\t\t\tif(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n\t\t\t\tif(stage[dy][dx] == 'x') continue;\n\n\t\t\t\tint next = d.visited;\n\t\t\t\tif(id.find(P(dx,dy)) != id.end()){\n\t\t\t\t\tnext |= (1<<id[P(dx,dy)]);\n\t\t\t\t}\n\n\t\t\t\tif(cost[dy*W+dx][next] <= d.cost + 1) continue;\n\t\t\t\tcost[dy*W+dx][next] = d.cost + 1;\n\t\t\t\tque.push(Data(d.cost+1,dx,dy,next));\n\t\t\t}\n\t\t}\n\n\t\tint flag = 0;\n\t\tfor(map<P,int>::iterator it = id.begin(); it != id.end(); it++){\n\t\t\tflag |= (1<<it->second);\n\t\t}\n\n\t\tint minv = 0x3f3f3f3f;\n\t\tfor(int i=0;i<=W*H;i++){\n\t\t\tminv = min(cost[i][flag],minv);\n\t\t}\n\n\t\tprintf(\"%d\\n\",minv == 0x3f3f3f3f ? -1 : minv);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define si(x) int(x.size())\n#define double long double\nconst int mod=1000000007,MAX=405,INF=1<<29;\nint dis[MAX][MAX];\nint N;\n\nvoid floyd(){\n    for(int k=0;k<N;k++){\n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                chmin(dis[i][j],dis[i][k]+dis[k][j]);\n            }\n        }\n    }\n}\n\nvector<int> dh={0,1,0,-1},dw={1,0,-1,0};\n\nint dp[1<<12][12];\nvector<int> pos;\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int H,W;cin>>W>>H;\n        if(H+W==0) break;\n        N=H*W;\n        \n        for(int i=0;i<N;i++) for(int j=0;j<N;j++) dis[i][j]=INF;\n        pos.clear();\n        \n        vector<string> S(H);\n        for(int i=0;i<H;i++) cin>>S[i];\n        \n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if(S[i][j]=='x') continue;\n                if(S[i][j]=='o') pos.push_back(i*W+j);\n                for(int k=0;k<4;k++){\n                    int toi=i+dh[k],toj=j+dw[k];\n                    if(toi<0||toi>=H||toj<0||toj>=W) continue;\n                    if(S[toi][toj]=='x') continue;\n                    dis[i*W+j][toi*W+toj]=1;\n                }\n            }\n        }\n        \n        for(int i=0;i<H;i++) for(int j=0;j<W;j++) if(S[i][j]=='*') pos.push_back(i*W+j);\n        \n        floyd();\n        \n        for(int i=0;i<12;i++) for(int j=0;j<(1<<12);j++) dp[j][i]=INF;\n        dp[1][0]=0;\n        \n        int M=si(pos);\n        \n        for(int bit=0;bit<(1<<M);bit++){\n            for(int i=0;i<M;i++){\n                if(dp[bit][i]==INF) continue;\n                if(!(bit&(1<<i))) continue;\n                for(int to=0;to<M;to++){\n                    if(bit&(1<<to)) continue;\n                    chmin(dp[bit|(1<<to)][to],dp[bit][i]+dis[pos[i]][pos[to]]);\n                }\n            }\n        }\n        \n        int ans=INF;\n        \n        for(int i=1;i<=M;i++) chmin(ans,dp[(1<<M)-1][i]);\n        \n        if(ans==INF) ans=-1;\n        \n        cout<<ans<<endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 100000000;\ntypedef double D;\nconst D EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\ntypedef pair<int, int> PII;\n\nstruct  P {\n\tint x, y;\n\tP() {}\n\tP(int x_, int y_) : x(x_), y(y_) {}\n};\n\nP s;\nint W, H, N;\nchar field[20][20];\nint G[10][10];\nint dp[1<<10][10];\n\nint rec(int S, int v)\n{\n\tif (dp[S][v]>=0) {\n\t\treturn dp[S][v];\n\t}\n\t\n\tif (S==(1<<N)-1) {\n\t\treturn dp[S][v]=0;\n\t}\n\t\n\tint res=INF;\n\trep(u, N) {\n\t\tif (!(S>>u&1)) {\n\t\t\tres = min(res, rec(S|1<<u, u)+G[v][u]);\n\t\t}\n\t}\n\treturn dp[S][v] = res;\n}\n\nint dis(P p1, P p2)\n{\n\tqueue<P> Q;\n\tint d[20][20];\n\tfill(d[0], d[0]+20*20, INF);\n\tQ.push(p1);\n\td[p1.x][p1.y]=0;\n\t\n\twhile (Q.size()) {\n\t\tP p = Q.front(); Q.pop();\n\n\t\trep(i, 4) {\n\t\t\tP np = P(p.x+dx[i], p.y+dy[i]);\n\t\t\tif_range(np.x, np.y, W, H) {\n\t\t\t\tif (field[np.x][np.y]!='x' && d[np.x][np.y]==INF) {\n\t\t\t\t\tQ.push(np);\n\t\t\t\t\td[np.x][np.y] = d[p.x][p.y]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn d[p2.x][p2.y];\n}\n\nint main()\n{\n\twhile (cin>>W>>H, W||H) {\n\t\tvector<P> stain;\n\t\t\n\t\trep(y, H) {\n\t\t\trep(x, W) {\n\t\t\t\tchar c;\n\t\t\t\tcin>>c;\n\t\t\t\tif (c=='o') { s.x=x; s.y=y; }\n\t\t\t\telse if (c=='*') {stain.push_back(P(x, y));}\n\t\t\t\tfield[x][y]=c;\n\t\t\t}\n\t\t}\n\t\tN = (int)stain.size();\n\t\t\n\t\tfill(G[0], G[0]+10*10, INF);\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tfor (int j=0; j<N; j++) {\n\t\t\t\tif (i!=j) {\n\t\t\t\t\tint dd = dis(stain[i], stain[j]);\n\t\t\t\t\tG[i][j] = dd;\n\t\t\t\t\tG[j][i] = dd;\n\t\t\t\t} else {\n\t\t\t\t\tG[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tint ans = INF;\n\n\t\trep(i, N) {\n\t\t\tfill(dp[0], dp[0]+10*10, -1);\n\t\t\tint tmp=dis(s, stain[i]);\n\t\t\tans = min(ans, tmp+rec(1<<i, i));\n\t\t}\n\t\t\n\t\t cout << (ans<INF ? ans : -1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\n#define int i64\n\nint w,h;\n\nvector<int> ans;\n\nsigned main(){\n\twhile(cin >> w >> h,w || h){\n\t\tvector<vector<int>> fie(h,vector<int>(w,0));\n\t\tvector<P> dust;\n\t\tint sx,sy;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tstring s;\n\t\t\tcin>> s;\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(s[j] == '*'){\n\t\t\t\t\tdust.push_back({i,j});\n\t\t\t\t\tfie[i][j] = dust.size();\n\t\t\t\t}\n\t\t\t\tif(s[j] == 'x'){\n\t\t\t\t\tfie[i][j] = -1;\n\t\t\t\t}\n\t\t\t\tif(s[j] == 'o'){\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusing P2 = pair<int,P>;\n\t\tvector<vector<int>> dist(dust.size(),vector<int>(dust.size() , 1e9));\n\n\t\tint dx[] = {1,-1,0,0};\n\t\tint dy[] = {0,0,1,-1};\n\n\t\tfor(int s = 0;s < dust.size();s++){\n\t\t\tqueue<P2> que;\n\t\t\tque.push({0,dust[s]});\n\t\t\tvector<vector<int>> vis(h,vector<int>(w,0));\n\t\t\tvis[dust[s].first][dust[s].second] = 1;\n\t\t\twhile(!que.empty()){\n\t\t\t\tint d = que.front().first;\n\t\t\t\tP p = que.front().second;\n\t\t\t\tif(fie[p.first][p.second] > 0){\n\t\t\t\t\tdist[s][fie[p.first][p.second] - 1] = d;\n\t\t\t\t\tcout << s << \"-\" << fie[p.first][p.second] -1 << \"=\" << d << endl;\n\t\t\t\t}\n\t\t\t\tque.pop();\n\t\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\t\tint nx = p.first + dx[i];\n\t\t\t\t\tint ny = p.second + dy[i];\n\t\t\t\t\tif(0 <= nx && nx < h && 0 <= ny && ny < w && fie[nx][ny] != -1 && vis[nx][ny] == 0){\n\t\t\t\t\t\tvis[nx][ny] = 1;\n\t\t\t\t\t\tque.push({d + 1,{nx,ny}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint dp[1 << dust.size()];\n\t\tfill(dp , dp + (1 << dust.size()),1e9);\n\t\t{\n\t\t\tqueue<P2> que;\n\t\t\tque.push({0,{sx,sy}});\n\t\t\tvector<vector<int>> vis(h,vector<int>(w,0));\n\t\t\tvis[sx][sy] = 1;\n\t\t\twhile(!que.empty()){\n\t\t\t\tint d = que.front().first;\n\t\t\t\tP p = que.front().second;\n\t\t\t\tif(fie[p.first][p.second] > 0){\n\t\t\t\t\tdp[(1 << (fie[p.first][p.second] - 1))] = d;\n\t\t\t\t}\n\t\t\t\tque.pop();\n\t\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\t\tint nx = p.first + dx[i];\n\t\t\t\t\tint ny = p.second + dy[i];\n\t\t\t\t\tif(0 <= nx && nx < h && 0 <= ny && ny < w && fie[nx][ny] != -1 && vis[nx][ny] == 0){\n\t\t\t\t\t\tvis[nx][ny] = 1;\n\t\t\t\t\t\tque.push({d + 1,{nx,ny}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1;i < (1 << dust.size()) - 1;i++){\n\t\t\tfor(int j = 0;j < dust.size();j++){\n\t\t\t\tfor(int k = 0;k < dust.size();k++){\n\t\t\t\t\tif(j == k) continue;\n\t\t\t\t\tif(!(i & (1 << j)) && (i & (1 << k))){\n\t\t\t\t\t\t//j <- k\n\t\t\t\t\t\tdp[i | (1 << j)] = min(dp[i | (1 << j)] , dp[i] + dist[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dp[(1 << dust.size()) - 1] >= 1e9){\n\t\t\tans.push_back(-1);\n\t\t}\n\t\telse{\n\t\t\tans.push_back(dp[(1 << dust.size()) - 1]);\n\t\t}\n\t}\n\tfor(int a : ans){\n\t\tcout << a << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint w,h;\nvector<string> field;\nint dist(pair<int,int> a,pair<int,int> b){\n\tqueue<pair<pair<int,int>,int> > bfs;\n\tset<pair<int,int> > already;\n\tbfs.push(make_pair(a,0));\n\twhile(!bfs.empty()){\n\t\tpair<int,int> pos;\n\t\tint cost;\n\t\ttie(pos,cost)=bfs.front();\n\t\tbfs.pop();\n\t\tint y,x;\n\t\ttie(y,x)=pos;\n\t\tif(y<0||h<=y||x<0||w<=h) continue;\n\t\tif(field[y][x]=='x') continue;\n\t\tif(!already.insert(pos).second) continue;\n\t\tif(pos==b) return cost;\n\t\tint dy[4]={0,0,-1,1},dx[4]={-1,1,0,0};\n\t\tfor(int i=0;i<4;++i)\n\t\t\tbfs.push(make_pair(make_pair(y+dy[i],x+dx[i]),cost+1));\n\t}\n\treturn 1048576;\n}\nint solve(){\n\tcin >> w >> h;\n\tif(!w&&!h) return 0;\n\tfield.resize(h);\n\tfor(int i=0;i<h;++i)\n\t\tcin >> field[i];\n\tpair<int,int> robot;\n\tvector<pair<int,int> > dirty;\n\tfor(int i=0;i<h;++i)\n\t\tfor(int j=0;j<w;++j){\n\t\t\tif(field[i][j]=='o') robot=make_pair(i,j);\n\t\t\tif(field[i][j]=='*') dirty.push_back(make_pair(i,j));\n\t\t}\n\t//init bitdp[state][lastpos]\n\tvector<vector<int> > bitdp;\n\tbitdp.assign(1<<dirty.size(),vector<int>());\n\tfor(int i=0;i<(1<<dirty.size());++i)\n\t\tbitdp[i].assign(dirty.size(),1048576);\n\tfor(int i=0;i<dirty.size();++i){\n\t\tbitdp[1<<i][i]=dist(robot,dirty[i]);\n\t\tif(bitdp[1<<i][i]>8192) return -1;\n\t}\n\tvector<vector<int> > ecost;\n\tecost.assign(dirty.size(),vector<int>());\n\tfor(int i=0;i<dirty.size();++i)\n\t\tecost[i].assign(dirty.size(),1048576);\n\tfor(int i=0;i<dirty.size();++i)\n\t\tfor(int j=0;j<dirty.size();++j)\n\t\t\tecost[i][j]=dist(dirty[i],dirty[j]);\n\tfor(int i=0;i<(1<<dirty.size());++i)\n\t\tfor(int j=0;j<dirty.size();++j){\n\t\t\tif(i&(1<<j)) continue;\n\t\t\tfor(int k=0;k<dirty.size();++k)\n\t\t\t\tif(i&(1<<k)) bitdp[i|(1<<j)][j]=min(bitdp[i|(1<<j)][j],bitdp[i][k]+ecost[k][j]);\n\t\t}\n\tint answer=1048576;\n\tfor(int i=0;i<dirty.size();++i)\n\t\tanswer=min(answer,bitdp[(1<<dirty.size())-1][i]);\n\tif(answer>65536) answer=-1;\n\treturn answer;\n}\nint main() {\n\tfor(;;){\n\t\tint answer=solve();\n\t\tif(answer) cout << answer << endl;\n\t\telse break;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cassert>\n#include<cstdio>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int MAX = 21;\nconst int TM = 11;\nconst int INF = (1<<25);\n\nchar F[MAX][MAX];\nint T[(1<<TM)][MAX][MAX];\nint w,h,sx,sy;\nvector<P> Trash;\n\n\nstruct State{\n  int x,y,t,come;\n  \n  State(){}\n  State(int x, int y, int t, int c):x(x),y(y),t(t),come(c){}\n  bool operator < (const State& s) const { return t > s.t;}\n\n};\n\nvoid print(){\n  for(int i = 0; i < (1<<Trash.size()); i++){\n    for(int y = 0; y < h; y++){\n      for(int x = 0; x < w; x++)\n\tif(T[i][y][x] != INF){\n\t  printf(\"%3d\",T[i][y][x]);\n\t}else {cout << \" X \";}\n      cout << endl;\n    }\n    cout << endl;\n  }\n}\n\nbool isInside(int x, int y){ return 0<=x&&x<w&&0<=y&&y<h;}\n\nvoid init(){\n\n  for(int i = 0; i < TM; i++)\n    for(int j = 0; j < MAX; j++)\n      for(int k = 0; k < MAX; k++) T[i][j][k] = INF;\n  \n  Trash.clear();\n}\n\nvoid input(){\n  for(int i = 0; i < h; i++)\n    for(int j = 0; j < w; j++){\n      cin >> F[i][j];\n      if(F[i][j] == 'o'){\n\tsx = j;\n\tsy = i;\n      }\n      if(F[i][j] == '*') Trash.push_back(P(j,i));\n\n    }\n}\n\nint getTrashNum(P p){\n  for(int i = 0; i < Trash.size(); i++)\n    if(Trash[i] == p) return i;\n  \n  cerr << \"not found\" << endl;\n  return -1;\n}\nvoid solve(){\n\n  priority_queue<State> Q;\n  Q.push(State(sx,sy,0,0));\n  T[0][sy][sx] = 0;\n\n  int dx[] = {0,0,1,-1};\n  int dy[] = {1,-1,0,0};\n\n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n\n    if(T[now.come][now.y][now.x] < now.t) continue;\n    \n    for(int i = 0; i < 4; i++){\n      State nex = now;\n      nex.x += dx[i];\n      nex.y += dy[i];\n      nex.t++;\n\n      if(!isInside(nex.x,nex.y)) continue;\n      if(F[nex.y][nex.x] == 'x') continue;\n\n\n      if(F[nex.y][nex.x] == '*'){\n\tint Tnum = getTrashNum(P(nex.x, nex.y));\n\tnex.come = (nex.come|(1<<Tnum));\n      }\n\n      \n      if(T[nex.come][nex.y][nex.x] > nex.t){\n\tT[nex.come][nex.y][nex.x] = nex.t;\n\tQ.push(nex);\n      }\n    }\n  }\n\n  int ans = INF;\n\n  // print();\n\n  //  if(Trash.size() == 0) ans = 0;\n\n  for(int i = 0; i < h; i++)\n    for(int j = 0; j < w; j++) ans = min(ans,T[(1<<Trash.size())-1][i][j]);\n  /*\n   for(int i = 0; i < Trash.size(); i++)\n     ans = min(ans,T[(1<<Trash.size())-1][Trash[i].second][Trash[i].first]);\n  */\n\n  if(ans == INF) cout << \"-1\" << endl;\n  else cout << ans << endl;\n \n}\n  \nint main(){\n\n  while(cin >> w >> h && w+h){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <string.h>\nusing namespace std;\n\n#define FOR(i, n) for(int i = 0; i < n; i++)\n#define bit(i) static_cast< bitset<8> >(i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long>PLL;\ntypedef queue<int> QI;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue<int, vector<int>, greater<int> > minpq;\n\nstruct edge{int to, cost;};\n\nvoid begin(){cin.tie(0); ios::sync_with_stdio(false);};\nint gcd(int a, int b){if(a%b==0){return(b);}else{return(gcd(b,a%b));}};\nint lcm(int m, int n){if((0 == m)||(0 == n)){return 0;} return ((m / gcd(m, n)) * n);};\nunsigned long long comb(long n, long m){unsigned long long c = 1; m = (n - m < m ? n - m : m);\n    for(long ns = n - m + 1, ms = 1; ms <= m; ns ++, ms ++){c *= ns; c /= ms;} return c;};\n\nvoid cp(int a1[], int a2[], int l){FOR(i, l) a2[i] = a1[i];};\ndouble sq(double d){return d*d;};\nint sq(int i){return i*i;};\ndouble sqdist(int x1, int y1, int x2, int y2){\n    double dx = x1 - x2, dy = y1 - y2; return dx*dx + dy*dy;\n};\n\n// ワーシャルフロイド法\nvoid warshallFloyd(int d[100][100], int n){\n    for(int k = 0; k < n; ++k)\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                if(d[i][k] != -1 && d[k][j] != -1){\n                    if(d[i][j] == -1){\n                        d[i][j] = d[i][k] + d[k][j];\n                    }else{\n                        d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                    }\n                }\n};\n\n\n// d:隣接行列  n:グラフのサイズ  s:始点  dist:始点からの距離が入る配列\nvoid dijkstra(int d[1000][1000], int n, int s, int dist[1000]){\n    FOR(i, n) dist[i] = -1;\n    dist[s] = 0;\n    priority_queue<PII, vector<PII>, greater<PII> > q;\n    q.push(PII(0, s));\n    while (!q.empty()) {\n        PII p = q.top(); q.pop();\n        int i = p.second;\n        if(dist[i] < p.first) continue;\n        for(int j = 0; j < n; j++){\n            if(d[i][j] == -1) continue;\n            if(dist[j] == -1){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }else if(dist[j] > dist[i] + d[i][j]){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }\n        }\n    }\n};\n\n// 線分の交差判定\nbool isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n    // 並行な場合\n    int m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n    if(m == 0) return false;\n    // 媒介変数の値が0より大きく1以下なら交差する、これは問題の状況によって変わるかも。\n    double r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n    double s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n    return (0 < r && r <= 1 && 0 < s && s <= 1);\n};\n\n// 外積の計算 AB CD の内積を求める\nint crossProdct(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy){\n    int abx = bx - ax; int aby = by - ay;\n    int cdx = dx - cx; int cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble crossProdct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble innerProduct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdx + aby * cdy;\n};\n\n// 三角形の内部判定 ABCの中にPがあるか判定\nbool inTriangle(int ax, int ay, int bx, int by, int cx, int cy, int px, int py){\n    int c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    int c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    int c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\nbool inTriangle(double ax, double ay, double bx, double by, double cx, double cy, double px, double py){\n    double c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    double c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    double c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\n\n// 三角形の外心\nvoid circumcenter(double ax, double ay, double bx, double by, double cx, double cy, double res[3]){\n    // AB AC を求める\n    double abx = bx - ax; double aby = by - ay;\n    double acx = cx - ax; double acy = cy - ay;\n    double m = abx * acy - acx * aby; // 分母 m = 0 となるのは3点が一直線になるとき\n    double s = (abx * acx + aby * acy - sq(acx) - sq(acy)) / m; // 媒介変数s\n    res[0] = abx / 2 + s * aby / 2; res[1] = aby / 2 - s * abx / 2;\n    // cout << res[0] << \" \" << res[1] << endl;\n    res[2] = sqrt(sqdist(0, 0, res[0], res[1]));\n    res[0] += ax; res[1] += ay;\n};\n\n\n\n\n/**\n * start\n * @author yoshikyoto\n */\nint w, h;\nstring tile[20];\nint dist[20][20];\nint g[11][11];\nint sx[11], sy[11];\nint dp[1024][11];\nint vy[4] = {-1, 1, 0, 0}, vx[4] = {0, 0, -1, 1};\n\nint dcount = 1;\nint p[11];\n\nvoid dfs(int hist, int curr){\n    for(int next = 1; next < dcount; next++){\n        if(hist & p[next]) continue; // 既に訪れている\n        // 訪れていない\n        int next_hist = hist | p[next];\n        int cost = dp[hist][curr] + g[curr][next];\n        if(cost < dp[next_hist][next] || dp[next_hist][next] == -1){\n            dp[next_hist][next] = cost;\n            dfs(next_hist, next);\n        }\n    }\n};\n\nvoid solve(){\n    FOR(i, h) cin >> tile[i];\n    \n    // 配列をなめて汚れたタイルの位置を獲得、汚れに番号をつける\n    FOR(i, h) FOR(j, w){\n        if(tile[i][j] == '*'){\n            sy[dcount] = i;\n            sx[dcount] = j;\n            tile[i][j] = (char)('0' + dcount); // 汚れに番号を付ける\n            dcount++;\n        }else if(tile[i][j] == 'o'){\n            // 自分の位置\n            sy[0] = i;\n            sx[0] = j;\n            tile[i][j] = '0';\n        }\n    }\n    // グラフの初期化\n    FOR(i, dcount) FOR(j, dcount) g[i][j] = -1;\n    // FOR(i, h) cout << tile[i] << endl;\n    \n    // まずはbfsしてグラフを生成する\n    FOR(i, dcount){\n        FOR(k, h) FOR(l, w) dist[k][l] = -1;\n        dist[sy[i]][sx[i]] = 0;\n        QI yq, xq;\n        yq.push(sy[i]);\n        xq.push(sx[i]);\n        int checked = 1;\n        while(checked < dcount && !yq.empty()){\n            int y = yq.front(); yq.pop();\n            int x = xq.front(); xq.pop();\n            \n            // 上下左右を見る\n            FOR(j, 4){\n                int ny = y+vy[j], nx = x+vx[j]; // nexty, nextx;\n                if(dist[ny][nx] > -1) continue; // 既に訪れた場合\n                if(ny < 0 || ny > h-1 || nx < 0 || nx > w-1) continue; // 部屋を出てしまう場合\n                int dnum = (int)tile[ny][nx] - '0';\n                if(tile[ny][nx] != 'x'){\n                    // 障害物でない場合\n                    yq.push(ny);\n                    xq.push(nx);\n                    dist[ny][nx] = dist[y][x] + 1;\n                    // グラフに追加したい場\n                    if(0 <= dnum && dnum < dcount){\n                        g[i][dnum] = dist[ny][nx];\n                        checked++;\n                    }\n                }\n            }\n        }\n    }\n    \n    /*\n    FOR(i, dcount){\n        FOR(j, dcount){\n            cout << g[i][j] << \" \";\n        }\n        cout << endl;\n    }\n     */\n    \n    // 行けないところがあったらダメ\n    for(int i = 1; i < dcount; i++)\n        if(g[0][i] == -1){\n            cout << -1 << endl;\n            return;\n        }\n    \n    // メモ化再帰\n    FOR(i, 1024) FOR(j, 11) dp[i][j] = -1;\n    FOR(i, dcount) p[i] = (int)pow(2, i);\n    dp[1][0] = 0;\n    dfs(1, 0);\n    \n    int final = 1;\n    for(int i = 1; i < dcount; i++) final += p[i];\n    \n    int ans = dp[final][1];\n    for(int i = 2; i < dcount; i++){\n        ans = min(ans, dp[final][i]);\n    }\n    cout << ans << endl;\n};\n\nint main(int argc, const char * argv[]){\n    begin();\n    while(true){\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, int>;\nconst int INF = 1e6;\nconst int dd[4] = { 0, 1, 0, -1 };\n\nint main() {\n    while (1) {\n        int w, h;\n        cin >> w >> h;\n        if (!w) return 0;\n\n        vector<string> s(h);\n        vector<P> ps;\n        for (int i = 0; i < h; ++i) {\n            cin >> s[i];\n            for (int j = 0; j < w; ++j)\n                if (s[i][j] == 'o')\n                    ps.push_back(P(i, j));\n        }\n        for (int i = 0; i < h; ++i)\n            for (int j = 0; j < w; ++j)\n                if (s[i][j] == '*')\n                    ps.push_back(P(i, j));\n\n        int n = ps.size();\n        vector<vector<vector<int>>> dist(n, vector<vector<int>>(h, vector<int>(w, INF)));\n        for (int i = 0; i < n; ++i) {\n            queue<P> q;\n            q.push(ps[i]);\n            dist[i][ps[i].first][ps[i].second] = 0;\n            while (!q.empty()) {\n                P p = q.front();\n                q.pop();\n                for (int j = 0; j < 4; ++j) {\n                    int ti = p.first + dd[j], tj = p.second + dd[j ^ 1];\n                    if (0 <= ti && ti < h && 0 <= tj && tj < w && s[ti][tj] != 'x' && dist[i][ti][tj] > dist[i][p.first][p.second] + 1) {\n                        dist[i][ti][tj] = dist[i][p.first][p.second] + 1;\n                        q.push(P(ti, tj));\n                    }\n                }\n            }\n        }\n        vector<int> v(n);\n        for (int i = 0; i < n; ++i) v[i] = i;\n\n        int ans = INF;\n        do {\n            if (v[0] != 0) continue;\n\n            int sum = 0;\n            for (int i = 0; i < n - 1; ++i)\n                sum += dist[v[i]][ps[v[i + 1]].first][ps[v[i + 1]].second];\n\n            ans = min(ans, sum);\n        } while (next_permutation(v.begin(), v.end()));\n\n        cout << (ans == INF ? -1 : ans) << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 1000000000\n#define LLINF 1000000000000000ll\n#define sz(x) ((int)(x).size())\n#define sq(x) ((x)*(x))\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n\nint h,w;\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\nvector<string> f;\nvector<int> pos;\nint start;\nint d[402][402];\nint dp[1<<11][11];\nint K;\nint id(int x,int y){\n    return x*w+y;\n}\nstring binary(int a){\n    string ret;\n    for(int i=0;i<4;i++){\n        if((1<<i)&a)ret+=\"1\";\n        else ret+=\"0\";\n    }\n    return ret;\n}\nint rec(int S,int v){\n    if(dp[S][v]!=-1)return dp[S][v];\n    if(S==0)return 0;\n    int ret = INF;\n    for(int i=0;i<K;i++){\n        if((S&(1<<i))!=0)ret = min(ret,rec(S-(1<<i),i)+d[pos[i]][pos[v]]);\n    }\n    //cout << S << ' ' << v << ' ' << ret << endl; \n    return dp[S][v]=ret;\n}\nint solve(){\n    f.clear();\n    pos.clear();\n    scanf(\"%d %d\",&w,&h);\n    int N = w*h;\n    if(h+w==0)return 1;\n    f.resize(h);\n    for(int i=0;i<h;i++)cin >> f[i];\n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            d[i][j]=INF;\n            if(i==j)d[i][j]=0;\n        }\n    }\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            for(int dir=0;dir<4;dir++){\n                int nx = i+dx[dir];\n                int ny = j+dy[dir];\n                if(nx<0||nx>=h||ny<0||ny>=w)continue;\n                if(f[i][j]=='x'||f[nx][ny]=='x')continue;\n                //cout << id(i,j) << ' ' << id(nx,ny) << endl;\n                d[id(nx,ny)][id(i,j)]=1;\n                d[id(i,j)][id(nx,ny)]=1;\n            }\n        }\n    }\n    for(int k=0;k<N;k++){\n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n            }\n        }\n    }\n\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(f[i][j]=='o')start = pos.size();\n            if(f[i][j]=='o'||f[i][j]=='*')pos.pb(id(i,j));\n        }\n    }\n    K = pos.size();\n    for(int i=0;i<(1<<K);i++){\n        for(int j=0;j<K;j++){\n            dp[i][j]=-1;\n        }\n    }\n    int ans = rec((1<<K)-1-(1<<start),start);\n    if(ans==INF)ans = -1;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n\nint main(){\n    while(1){\n        if(solve())return 0;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e8\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint h,w;\nchar s[25][25];\n\nint dx[] = {0, 1, 0,-1};\nint dy[] = {1, 0,-1, 0};\n\nint len[50][50];\n\nint f(int sx, int sy, int gx, int gy){\n\n    rep(i,50)rep(j,50) len[i][j] = INF;\n    len[sx][sy] = 0;\n\n    queue<pii> q;\n    q.push(pii(sx,sy));\n\n    while(q.size()){\n        int x = q.front().first;\n        int y = q.front().second;\n        q.pop();\n        rep(i,4){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(nx < 0 || nx >= h || ny < 0 || ny >= w)continue;\n            if(s[nx][ny] == 'x') continue;\n            if(len[nx][ny] > len[x][y] + 1){\n                len[nx][ny] = len[x][y] + 1;\n                q.push(pii(nx,ny));\n            }\n        }\n    }\n\n    return len[gx][gy];\n\n}\n\nint main(void) {\n\n    while(cin >> w >> h, w){\n\n        rep(i,h) cin >> s[i];\n        vector<pii> v;\n        int sx,sy;\n        rep(i,h)rep(j,w)\n            if(s[i][j] == '*'){\n                v.push_back(pii(i,j));\n            }else if(s[i][j] == 'o'){\n                sx=i,sy=j;\n            }\n\n        int n = v.size();\n\n        vi s_dis(n);\n        rep(i,n){//(sx,sy) -> v[i]\n            s_dis[i] = f(sx,sy,v[i].first,v[i].second);\n        }\n        vector<vi> dis(n,vi(n));\n        rep(i,n)loop(j,i+1,n){\n            if(i != j){//v[i] -> v[j]\n                dis[i][j] = dis[j][i] = f(v[i].first,v[i].second,v[j].first,v[j].second);\n            }\n        }\n\n        vi ord(n);\n        rep(i,n){\n            ord[i] = i;\n        }\n        int ans = INF;\n        do{\n            int tmp = s_dis[ord[0]];\n            rep(i,n-1)tmp += dis[ord[i]][ord[i+1]];\n            ans = min(ans, tmp);\n        }while(next_permutation(all(ord)));\n\n        if(ans < INF){\n            cout << ans << endl;\n        }else{\n            cout << -1 << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#define INF 1<<30\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h;\nchar cmap[30][30];\nint imap[30][30];\nint bfsd[60][60];\nint d[60][60];\nint dd[60];\nbool ddused[60];\nP pointUsed[60];\nint Iindex;\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,1,0,-1};\nint counter;\nint ssx,ssy;\nint sindex;\n \nvoid bfs(int sf,int ss){\n  queue<P> que;\n  que.push(P(sf,ss));\n  for(int i=0;i<h;i++)for(int j=0;j<w;j++)bfsd[i][j]=INF;\n  bfsd[ss][sf]=0;\n \n  while(que.size()){\n    P p = que.front(); que.pop();\n \n    for(int i=0;i<4;i++){\n      int nx = p.first + dx[i],ny = p.second + dy[i];\n      if(0<= nx && nx < w && 0<= ny && ny < h && bfsd[ny][nx] == INF && cmap[ny][nx] != 'x'){\n    bfsd[ny][nx] = bfsd[p.second][p.first]+1;\n    que.push(P(nx,ny));\n    if(cmap[ny][nx] == '*' || cmap[ny][nx] == 'o'){\n      counter++;\n      //cout << imap[ss][sf]+50 << \"  \" << imap[ny][nx]+50 << endl;\n      d[ imap[ss][sf]+50 ][ imap[ny][nx]+50 ] = bfsd[ny][nx];\n      d[ imap[ny][nx]+50 ][ imap[ss][sf]+50 ] = bfsd[ny][nx];\n    }\n \n      }\n \n    }\n \n \n \n  }\n \n}\n \n \n \n \nint main(){\n  int sx,sy;\n  int dirtyIndex;\n  P dirtyPoint[500]; //let first be x and second be y\n  while(true){\n    cin >> w >> h;\n    if(w + h == 0)break;\n    \n    Iindex=0;\n    dirtyIndex=-50;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n    cin >> cmap[i][j];\n    switch(cmap[i][j]){\n    case '.':\n      imap[i][j]=0;\n      break;\n    case 'o':\n      imap[i][j]=dirtyIndex;\n      dirtyIndex++;\n      pointUsed[Iindex] = P(j,i);\n      sindex=Iindex;\n      ++Iindex;\n      sy=i;\n      sx=j;\n      ssx = sx;\n      ssy = sy;\n      break;\n    case '*':\n      dirtyPoint[Iindex].first = j;\n      dirtyPoint[Iindex].second = i;\n      imap[i][j] = dirtyIndex;\n      dirtyIndex++;\n      pointUsed[Iindex] = P(j,i);\n      ++Iindex;\n      break;\n    case 'x':\n      imap[i][j]=-1;\n      break;\n    default:\n      break;\n    }\n      }\n    }\n    bool fin=false;\n    for(int i=0;i<Iindex;i++){\n      counter=1;\n      bfs(pointUsed[i].first,pointUsed[i].second);\n      if(i == 0 && counter != Iindex){\n    cout << \"-1\" << endl;\n      fin=true;\n      break;\n      }\n \n    }\n \n    if(fin)continue;\n    \n   \n    int dp[1<<Iindex][Iindex];\n    \n    for(int S=0;S< (1<<Iindex);S++){\n      for(int i=0;i<=Iindex+1;i++)dp[S][i] = INF;\n    }\n    dp[(1<<Iindex)-1][0] = 0;\n    for(int S = (1<<Iindex)-2;S>=0;S--){\n      for(int v=0;v<Iindex;v++){\n    for(int u=0;u<Iindex;u++){\n      if(!(S>>u & 1)){\n        dp[S][v] = min(dp[S][v],dp[S|1<<u][u] + d[v][u]);\n      }\n    }\n      }\n    }\n    \n    int Kotae=INF;\n    for(int i=0;i<Iindex;i++)if(Kotae > dp[1<<i][i])Kotae = dp[1<<i][i];\n    cout << Kotae << endl;\n    \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int INF = 1e8;\n\nint vx[]{-1,1,0,0};\nint vy[]{0,0,-1,1};\n\nint main(){\n    int w,h;\n    while(cin>>w>>h,w){\n        vector<vector<char>>mp(w+2,vector<char>(h+2,'x'));\n        pair<int,int>src;\n        vector<pair<int,int>>kkk;\n        for(int i=1;i<=h;++i){\n            string s;\n            cin>>s;\n            for(int j=1;j<=w;++j){\n                mp[j][i]=s[j-1];\n                if(mp[j][i]=='o'){\n                    src={j,i};\n                }\n                if(mp[j][i]=='*'){\n                    kkk.emplace_back(j,i);\n                }\n            }\n        }\n        vector<vector<int>>d((w+2)*(h+2),vector<int>((w+2)*(h+2),INF));\n        for(int i=1;i<=h;++i){\n            for(int j=1;j<=w;++j){\n                for(int k=0;k<4;++k){\n                    if(mp[j+vx[k]][i+vy[k]]!='x'){\n                        d[(w+2)*i+j][(w+2)*(i+vy[k])+j+vx[k]]=1;\n                    }\n                }\n            }\n        }\n        int n=(w+2)*(h+2);\n        for(int k=0;k<n;++k){\n            for(int i=0;i<n;++i){\n                for(int j=0;j<n;++j){\n                    if(d[i][j]>d[i][k]+d[k][j]){   \n                        d[i][j]=d[i][k]+d[k][j];                     \n                    }\n                }\n            }\n        }\n        sort(kkk.begin(),kkk.end());\n        int ans=INF;\n        do{\n            int pre=src.first+src.second*(w+2);\n            int ret=0;\n            for(int i=0;i<kkk.size();++i){\n                if(d[pre][kkk[i].first+(w+2)*kkk[i].second]<INF){\n                    ret+=d[pre][kkk[i].first+(w+2)*kkk[i].second];\n                    pre=kkk[i].first+(w+2)*kkk[i].second;\n                }else{\n                    ret=INF;\n                    break;\n                }\n            }\n            ans=min(ans,ret);\n        }while(next_permutation(kkk.begin(),kkk.end()));\n        if(ans==INF)ans=-1;\n        cout<<ans<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct P {\n\tint x, y;\n};\n\nstruct Edge {\n\tint to, cost;\n};\n\nconst int inf = 1e9;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint W, H;\nint dist[20][20];\nbool m[20][20];\nbool inRange(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\nvoid bfs(P s) {\n\tfill(dist[0], dist[20], inf);\n\tdist[s.y][s.x] = 0;\n\tqueue<P> Q; Q.push( (P){s.x, s.y} );\n\twhile ( !Q.empty() ) {\n\t\tP p = Q.front(); Q.pop();\n\t\tfor (int d = 0; d < 4; ++d) {\n\t\t\tint nx = p.x+dx[d];\n\t\t\tint ny = p.y+dy[d];\n\t\t\tif (inRange(nx, ny) && !m[ny][nx] && dist[p.y][p.x]+1 < dist[ny][nx]) {\n\t\t\t\tdist[ny][nx] = dist[p.y][p.x]+1;\n\t\t\t\tQ.push((P){nx, ny});\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\twhile (cin >> W >> H, W || H) {\n\t\tfill(m[0], m[20], false);\n\t\tint sx = -1, sy = -1;\n\t\tvector<P> target;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tstring str; cin >> str;\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tswitch (str[x]) {\n\t\t\t\t\tcase '.': break;\n\t\t\t\t\tcase 'o': sx = x, sy = y; break;\n\t\t\t\t\tcase '*': target.push_back( (P){x, y} ); break;\n\t\t\t\t\tcase 'x': m[y][x] = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttarget.push_back((P){sx, sy});\n\t\tint cost[20][20];\n\t\tint N = target.size();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tbfs(target[i]);\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tcost[i][j] = dist[target[j].y][target[j].x];\n//\t\t\t\tcout << i << \" \" << j << \" \" << cost[i][j] << endl;\n\t\t\t}\n\t\t}\n\n\t\tint dp[12][1 << 11]; fill(dp[0], dp[12], inf); dp[N-1][1<<(N-1)] = 0;\n\t\tfor (int w = 1; w <= N; ++w) {\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 1; j < (1 << N); ++j) {\n\t\t\t\t\tfor (int to = 0; to < N; ++to) {\n\t\t\t\t\t\tif ( (j & (1 << to)) == 0 && dp[i][j] != inf ) {\n//\t\t\t\t\t\t\tcout << i << \" \" << j << \" \" << to << \" \" << dp[i][j] << \" \" << cost[i][to] << endl;\n\t\t\t\t\t\t\tdp[to][j|(1<<to)] = min(dp[to][j|(1<<to)], dp[i][j]+cost[i][to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = inf;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tans = min(ans, dp[i][(1<<N)-1]);\n\t\t}\n\t\tif (ans == inf) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF (1 << 29)\n\nconst int dx[4] = { 0, -1, 1, 0 };\nconst int dy[4] = { -1, 0, 0, 1 };\n\nint main()\n{\n\twhile (true)\n\t{\n\t\t// ------ Variable, Input ------ //\n\n\t\tint H, W; vector<string> MAP;\n\n\t\tcin >> W >> H;\n\n\t\tif (W == 0 && H == 0) { break; }\n\n\t\tMAP = vector<string>(H);\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tcin >> MAP[i];\n\t\t}\n\n\n\t\t// ------ Graph Construction ------ //\n\n\t\tvector<pair<int, int> > Location(1);\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (MAP[i][j] == 'o')\n\t\t\t\t{\n\t\t\t\t\tLocation[0] = make_pair(j, i);\n\t\t\t\t}\n\n\t\t\t\tif (MAP[i][j] == '*')\n\t\t\t\t{\n\t\t\t\t\tLocation.push_back(make_pair(j, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int> > Graph(Location.size(), vector<int>(Location.size(), INF));\n\n\t\tfor (int i = 0; i < Location.size(); i++)\n\t\t{\n\t\t\tvector<vector<int> > distance_(H, vector<int>(W, INF)); distance_[Location[i].second][Location[i].first] = 0;\n\n\t\t\tqueue<pair<int, int> > que; que.push(Location[i]);\n\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tpair<int, int> p1 = que.front(); que.pop();\n\n\t\t\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t\t\t{\n\t\t\t\t\tint px = p1.first + dx[dir];\n\t\t\t\t\tint py = p1.second + dy[dir];\n\n\t\t\t\t\tif (0 <= px && px < W && 0 <= py && py < H && MAP[py][px] != 'x' && distance_[py][px] == INF)\n\t\t\t\t\t{\n\t\t\t\t\t\tdistance_[py][px] = distance_[p1.second][p1.first] + 1;\n\n\t\t\t\t\t\tque.push(make_pair(px, py));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < Location.size(); j++)\n\t\t\t{\n\t\t\t\tif (i != j)\n\t\t\t\t{\n\t\t\t\t\tint dist = distance_[Location[j].second][Location[j].first];\n\n\t\t\t\t\tGraph[i][j] = dist;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// ------ Traveling Salesman Problem ------ //\n\n\t\tvector<int> dp(1 << Graph.size(), INF);\n\n\t\tdp[1] = 0;\n\n\t\tfor (int i = 2; i < (1 << Graph.size()); i++)\n\t\t{\n\t\t\tfor (int j = 0; j < Graph.size(); j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < Graph.size(); k++)\n\t\t\t\t{\n\t\t\t\t\tif (i & (1 << j) && i & (1 << k))\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i] = min(dp[i - (1 << j)] + Graph[j][k], dp[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << dp[(1 << Graph.size()) - 1] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint h, w, k[21][21], cnt;\nlong long cx[11], cy[11], y[11][11], z[11][11], bfs[21][21], a, b, c[10], sum, minx, sum2; bool s[21][21];\nchar p;\n\nint main() {\n\twhile (true) {\n\t\tmemset(z, 0, sizeof(z));\n\t\tcin >> w >> h; cnt = 1; if (!w) { break; }\n\t\tfor (int i = 0; i < 21; i++) { \n\t\t\tfor (int j = 0; j < 21; j++) { \n\t\t\t\tk[i][j] = 1; \n\t\t\t} \n\t\t}\n\t\tcnt = 1;\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tcin >> p;\n\t\t\t\tif (p != 'x') { k[i][j] = 0; }\n\t\t\t\tif (p == '*') { cx[cnt] = j; cy[cnt] = i; cnt++; }\n\t\t\t\tif (p == 'o') { cx[0] = j; cy[0] = i; }\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 10; i++) { c[i] = i; }\n\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\t//bfs.\n\t\t\tqueue<int> Q;\n\t\t\tmemset(bfs, 10, sizeof(bfs));memset(s, false, sizeof(s));\n\t\t\tbfs[cy[i]][cx[i]] = 0;\n\n\t\t\tQ.push(cy[i] * 30 + cx[i]);\n\t\t\ts[cy[i]][cx[i]] = true;\n\t\t\twhile (!Q.empty()) {\n\t\t\t\ta = Q.front() / 30;\n\t\t\t\tb = Q.front() % 30;\n\t\t\t\tif (k[a - 1][b] == 0 && s[a - 1][b] == false) { \n\t\t\t\t\ts[a - 1][b] = true; Q.push((a - 1) * 30 + b); bfs[a - 1][b] = bfs[a][b] + 1;\n\t\t\t\t}\n\t\t\t\tif (k[a + 1][b] == 0 && s[a + 1][b] == false) {\n\t\t\t\t\ts[a + 1][b] = true; Q.push((a + 1) * 30 + b); bfs[a + 1][b] = bfs[a][b] + 1;\n\t\t\t\t}\n\t\t\t\tif (k[a][b - 1] == 0 && s[a][b - 1] == false) {\n\t\t\t\t\ts[a][b - 1] = true; Q.push(a * 30 + b - 1); bfs[a][b - 1] = bfs[a][b] + 1;\n\t\t\t\t}\n\t\t\t\tif (k[a][b + 1] == 0 && s[a][b + 1] == false) {\n\t\t\t\t\ts[a][b + 1] = true; Q.push(a * 30 + b + 1); bfs[a][b + 1] = bfs[a][b] + 1;\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t\t\n\t\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\t\tz[i][j] = bfs[cy[j]][cx[j]];\n\t\t\t}\n\t\t}\n\t\tminx = 114514;\n\t\tdo\n\t\t{\n\t\t\tsum = z[0][c[0] + 1];\n\t\t\tfor (int i = 0; i < cnt - 2; i++) { \n\t\t\t\tsum += z[c[i] + 1][c[i + 1] + 1]; \n\t\t\t}\n\t\t\tminx = min(minx, sum);\n\t\t} while (next_permutation(c, c + cnt - 1));\n\t\tif (minx == 114514) { minx = -1; }\n\t\tcout << minx << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cassert>\n#include<cstdio>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int MAX = 21;\nconst int TM = 11;\nconst int INF = (1<<25);\n\nchar F[MAX][MAX];\nint T[(1<<TM)][MAX][MAX];\nint w,h,sx,sy;\nvector<P> Trash;\n\n\nstruct State{\n  int x,y,t,come;\n  \n  State(){}\n  State(int x, int y, int t, int c):x(x),y(y),t(t),come(c){}\n  bool operator < (const State& s) const { return t > s.t;}\n\n};\n\nvoid print(){\n  for(int i = 0; i < (1<<Trash.size()); i++){\n    for(int y = 0; y < h; y++){\n      for(int x = 0; x < w; x++)\n\tif(T[i][y][x] != INF){\n\t  printf(\"%3d\",T[i][y][x]);\n\t}else {cout << \" X \";}\n      cout << endl;\n    }\n    cout << endl;\n  }\n}\n\nbool isInside(int x, int y){ return 0<=x&&x<w&&0<=y&&y<h;}\n\nvoid init(){\n\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++)\n      for(int k = 0; k < MAX; k++) T[i][j][k] = INF;\n  \n  Trash.clear();\n}\n\nvoid input(){\n  for(int i = 0; i < h; i++)\n    for(int j = 0; j < w; j++){\n      cin >> F[i][j];\n      if(F[i][j] == 'o'){\n\tsx = j;\n\tsy = i;\n      }\n      if(F[i][j] == '*') Trash.push_back(P(j,i));\n\n    }\n}\n\nint getTrashNum(P p){\n  for(int i = 0; i < Trash.size(); i++)\n    if(Trash[i] == p) return i;\n  \n  cerr << \"not found\" << endl;\n  return -1;\n}\nvoid solve(){\n\n  priority_queue<State> Q;\n  Q.push(State(sx,sy,0,0));\n  T[0][sy][sx] = 0;\n\n  int dx[] = {0,0,1,-1};\n  int dy[] = {1,-1,0,0};\n\n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n\n    if(T[now.come][now.y][now.x] < now.t) continue;\n    \n    for(int i = 0; i < 4; i++){\n      State nex = now;\n      nex.x += dx[i];\n      nex.y += dy[i];\n      nex.t++;\n\n      if(!isInside(nex.x,nex.y)) continue;\n      if(F[nex.y][nex.x] == 'x') continue;\n\n\n      if(F[nex.y][nex.x] == '*'){\n\tint Tnum = getTrashNum(P(nex.x, nex.y));\n\tnex.come = (nex.come|(1<<Tnum));\n      }\n\n      \n      if(T[nex.come][nex.y][nex.x] > nex.t){\n\tT[nex.come][nex.y][nex.x] = nex.t;\n\tQ.push(nex);\n      }\n    }\n  }\n\n  int ans = INF;\n\n  // print();\n\n  if(Trash.size() == 0) ans = 0;\n\n   for(int i = 0; i < Trash.size(); i++)\n     ans = min(ans,T[(1<<Trash.size())-1][Trash[i].second][Trash[i].first]);\n\n\n  if(ans == INF) cout << \"-1\" << endl;\n  else cout << ans << endl;\n \n}\n  \nint main(){\n\n  while(cin >> w >> h && w+h){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint w, h;\nstring b[20];\nint step[20][20];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid bfs(int x, int y){\n\tmemset(step, -1, sizeof(step));\n\tqueue< pair<int, int> > qu; qu.push(make_pair(x,y));\n\tstep[x][y] = 0;\n\twhile(!qu.empty()){\n\t\tpair<int, int> pr = qu.front(); qu.pop();\n\t\tint cx = pr.first, cy = pr.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx = cx+dx[i], ny = cy+dy[i];\n\t\t\tif(nx<0||h<=nx||ny<0||w<=ny||b[nx][ny]=='x'||step[nx][ny]!=-1) continue;\n\t\t\tstep[nx][ny] = step[cx][cy]+1;\n\t\t\tqu.push(make_pair(nx,ny));\n\t\t}\n\t}\n}\n\nint main(){\n\tint c[11][11];\n\twhile(cin >> w >> h, w){\n\t\tfor(int i=0;i<h;i++) cin >> b[i];\n\t\tvector<int> x(1), y(1);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(b[i][j]=='o') x[0] = i, y[0] = j;\n\t\t\t\tif(b[i][j]=='*') x.push_back(i), y.push_back(j);\n\t\t\t}\n\t\t}\n\t\tint res = 1000000000;\n\t\tfor(int i=0;i<x.size();i++){\n\t\t\tbfs(x[i], y[i]);\n\t\t\tfor(int j=0;j<x.size();j++){\n\t\t\t\tc[i][j] = step[x[j]][y[j]];\n\t\t\t\tif(c[i][j]==-1) res = -1;\n\t\t\t}\n\t\t}\n\t\tvector<int> a(x.size()-1);\n\t\tfor(int i=0;i<x.size()-1;i++) a[i] = i+1;\n\t\tdo{\n\t\t\tint cur = c[0][a[0]];\n\t\t\tfor(int i=0;i+1<a.size();i++) cur += c[a[i]][a[i+1]];\n\t\t\tres = min(res, cur);\n\t\t}while(next_permutation(a.begin(), a.end()));\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 28;\n\nint h, w;\nchar grid[22][22];\nint d[22][22];\nint dist[11][11];\n\nvoid bfs(int sx, int sy)\n{\n\tstatic const int dx[] = {-1, 0, 1, 0};\n\tstatic const int dy[] = {0, -1, 0, 1};\n\t\n\tfill_n(*d, 22 * 22, INF);\n\td[sx][sy] = 0;\n\t\n\tqueue<pair<pair<int, int>, int>> q;\n\tq.push(make_pair(make_pair(sx, sy), 0));\n\twhile (q.size()){\n\t\tauto p = q.front(); q.pop();\n\t\tint x = p.first.first;\n\t\tint y = p.first.second;\n\t\tint s = p.second;\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint nx = x + dx[dir];\n\t\t\tint ny = y + dy[dir];\n\t\t\tif (grid[nx][ny] == 'x') continue;\n\t\t\tif (d[nx][ny] > s + 1){\n\t\t\t\td[nx][ny] = s + 1;\n\t\t\t\tq.push(make_pair(make_pair(nx, ny), s + 1));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve()\n{\n\tvector<pair<int, int>> vp;\n\t\n\tfor (int i = 1; i <= h; i++){\n\t\tfor (int j = 1; j <= w; j++){\n\t\t\tif (grid[i][j] == '*') vp.push_back(make_pair(i, j));\n\t\t\tif (grid[i][j] == 'o'){\n\t\t\t\tvp.push_back(make_pair(i, j));\n\t\t\t\tswap(vp.front(), vp.back());\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < vp.size(); i++){\n\t\tbfs(vp[i].first, vp[i].second);\n\t\tfor (int j = 0; j < vp.size(); j++){\n\t\t\tdist[i][j] = d[vp[j].first][vp[j].second];\n\t\t}\n\t}\n\t\n\tstatic int dp[1 << 11][11];\n\tfill_n(*dp, (1 << 11) * 11, INF);\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < 1 << vp.size(); i++){\n\t\tfor (int j = 0; j < vp.size(); j++){\n\t\t\tfor (int k = 0; k < vp.size(); k++){\n\t\t\t\tint ni = i | 1 << k;\n\t\t\t\tdp[ni][k] = min(dp[ni][k], dp[i][j] + dist[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint res = INF;\n\tfor (int i = 0; i < vp.size(); i++){\n\t\tres = min(res, dp[(1 << vp.size()) - 1][i]);\n\t}\n\t\n\treturn res == INF ? -1 : res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &w, &h), w){\n\t\tmemset(grid, 'x', sizeof(grid));\n\t\t\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tscanf(\" %c\", &grid[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int h, w; cin >> w >> h;\n    if(h == 0 && w == 0) break;\n    vector<vector<bool>> grid(h, vector<bool>(w, false));\n    P st = {-1, -1};\n    vector<P> dist;\n    for(int i=0;i<h;++i) {\n      for(int j=0;j<w;++j) {\n        char tmp; cin >> tmp;\n        if(tmp == 'o') {\n          st = {i, j};\n          dist.emplace_back(st);\n        } else if(tmp == '*') {\n          dist.emplace_back(make_pair(i, j));\n        } else if(tmp == 'x') {\n          grid[i][j] = true;\n        }\n      }\n    }\n    sort(dist.begin(), dist.end());\n    int n = (int)(dist.size());\n    vvi d(n, vi(n, INF));\n    for(int i=0;i<n;++i) {\n      vector<vector<bool>> sel(h, vector<bool>(w, false));\n      queue<pair<int, P>> que;\n      d[i][i] = 0;\n      sel[dist[i].first][dist[i].second] = true;\n      que.push({0, dist[i]});\n      while(!que.empty()) {\n        pair<int, P> now = que.front(); que.pop();\n        for(int j=0;j<4;++j) {\n          int nx = now.second.first + dx[j], ny = now.second.second + dy[j];\n          if(!(0 <= nx && nx < h && 0 <= ny && ny < w)) continue;\n          if(sel[nx][ny] || grid[nx][ny]) continue;\n          sel[nx][ny] = true;\n          auto it = lower_bound(dist.begin(), dist.end(), make_pair(nx, ny));\n          if(it != dist.end() && (*it).first == nx && (*it).second == ny) {\n            int pos = distance(dist.begin(), it);\n            d[i][pos] = now.first + 1;\n          }\n          que.push({now.first + 1, {nx, ny}});\n        }\n      }\n    }\n    bool ok = true;\n    for(int i=0;i<n;++i) {\n      for(int j=0;j<n;++j) {\n        if(d[i][j] == INF) {\n          ok = false;\n          break;\n        }\n      }\n      if(!ok) break;\n    }\n    if(!ok) {\n      cout << -1 << endl;\n      continue;\n    }\n    int sz = 1;\n    for(int i=0;i<n;++i) {\n      sz *= 2;\n    }\n    vvi dp(n, vi(sz, INF));\n    auto it = lower_bound(dist.begin(), dist.end(), st);\n    int init = distance(dist.begin(), it);\n    dp[init][1<<(init)] = 0;\n    priority_queue<pair<int, P>> pq;\n    pq.push({0, {init, 1<<(init)}});\n    while(!pq.empty()) {\n      pair<int, P> now = pq.top(); pq.pop();\n      int l = now.first, idx = now.second.first, bs = now.second.second;\n      if(dp[idx][bs] < l) continue;\n      for(int i=0;i<n;++i) {\n        if((bs | (1<<i)) != bs && dp[i][bs|(1<<i)] > l + d[idx][i]) {\n          dp[i][bs|(1<<i)] = l + d[idx][i];\n          pq.push({dp[i][bs|(1<<i)], {i, bs|(1<<i)}});\n        }\n      }\n    }\n    int mi = INF;\n    for(int i=0;i<n;++i) {\n      if(i == init) continue;\n      mi = min(mi, dp[i][sz-1]);\n    }\n    cout << mi << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<int, int> P;\nint bfs(void);\nint INF=10000000;\nint w,h;\nint sx,sy;\nint dx[4]={-1,0,1,0};\nint dy[4]={0,1,0,-1};\nint d[100][100];\nchar mapp[100][100];\nint main(){\n  int kari;\n  while(1){\n    int yogore=0;\n    int ans=0;\n\n    cin>>w>>h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>mapp[i][j];\n\tif(mapp[i][j]=='*'){\n\t  yogore++;\n\t}else if(mapp[i][j]=='o'){\n\t  sy=i;\n\t  sx=j;\n\t}\n      }\n    }\n    for(int i=0;i<yogore;i++){\n      kari=bfs();\n      if(kari==0){\n\tans=-1;\n\tbreak;\n      }else{\n\tans+=kari;\n      }\n      \n    }\n    cout<<ans<<endl;\n  }\n}\nint bfs(void){\n  queue<P> que;\n  que.push(P(sy,sx));\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      d[i][j]=INF;\n    }\n  }\n  d[sy][sx]=0;\n  while(que.size()){\n    P p=que.front();\n    que.pop();\n    if(mapp[p.first][p.second]=='*'){\n      sy=p.first;\n      sx=p.second;\n      mapp[p.first][p.second]='.';\n      break;\n    }\n    for(int i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(0<=nx && nx<w && 0<=ny && ny<h && mapp[ny][nx]!='x' && d[ny][nx]==INF){\n\tque.push(P(ny,nx));\n\td[ny][nx]=d[p.first][p.second]+1;\n      }\n    }\n  }\n  return d[sy][sx];\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#define MAX_WH 20\n#define MAX_YOGORE 10\n\nusing namespace std;\n\nint w, h;\nchar data[MAX_WH][MAX_WH];\nint cost[MAX_YOGORE+1][MAX_YOGORE+1];\nint sx, sy;\nint n;\n\nclass Point {\npublic:\n  int x, y;\n  int cost;\n  Point(int x=0, int y=0, int cost=0) : x(x), y(y), cost(cost) {}\n};\n\nvoid bfs(int x, int y) {\n  Point p;\n  queue<Point> Q;\n  bool visited[MAX_WH][MAX_WH];\n  int s = data[y][x]-'a';\n  int t;\n  const int dx[4] = {1,0,-1,0};\n  const int dy[4] = {0,1,0,-1};\n\n  fill_n(visited[0], MAX_WH*MAX_WH, false);\n  visited[y][x] = true;\n  Q.push(Point(x, y, 0));\n\n  while(!Q.empty()) {\n    p = Q.front();\n    Q.pop();\n\n    if(data[p.y][p.x] != '.' && data[p.y][p.x] != 'x') {\n      t = data[p.y][p.x]-'a';\n      cost[s][t] = cost[t][s] = p.cost; \n    }\n\n    for(int i = 0; i < 4; i++) {\n      int nx = p.x + dx[i];\n      int ny = p.y + dy[i];\n      if(nx < 0 || nx >= w) continue;\n      if(ny < 0 || ny >= h) continue;\n      if(data[ny][nx] == 'x') continue;\n      if(visited[ny][nx]) continue;\n      Q.push(Point(nx, ny, p.cost+1));\n      visited[ny][nx] = true;\n    } \n  }\n}\n\nint solve() {\n  int A[MAX_YOGORE];\n  int ans;\n  fill_n(cost[0], (n+1)*(n+1), 0);\n  for(int i = 0; i < h; i++) {\n    for(int j = 0; j < w; j++) {\n      if(data[i][j] != '.' && data[i][j] != 'x') {\n\tbfs(j, i);\n      }\n    }\n  }\n\n  for(int i = 0; i < n; i++) {\n    A[i] = i+1;\n  }\n\n  ans = 100000;\n  do {\n    int newAns = cost[0][A[0]];\n\n    for(int i = 1; i < n; i++) {\n      if(cost[A[i-1]][A[i]] == 0) {\n\tnewAns = 100000;\n\tbreak;\n      }\n      newAns += cost[A[i-1]][A[i]];\n    }\n    if(newAns < ans) ans = newAns;\n\n  } while(next_permutation(A, A+n));\n  if(ans == 0) return -1;\n  else           return ans;\n}\n\nint main() {\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    n = 0;\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) {\n\tcin >> data[i][j];\n\tif(data[i][j] == 'o') {\n\t  sx = j;\n\t  sy = i;\n\t  data[i][j] = 'a';\n\t} else if(data[i][j] == '*') {\n\t  data[i][j] = 'b' + n++;\n\t}\n      }\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\nconst int INF = 100000000;\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n\nbool in_range(int a, int b){ return a >= 0 && a < b;}\n\nvoid bfs(map<int,int> &M, vector<int> &G, vector<string> C, int s){\n  int h = C.size(), w = C[0].length();\n  queue< pair<int,int> > que;\n  que.emplace(s,0);\n  while(!que.empty()){\n    int p = que.front().first, d = que.front().second;\n    que.pop();\n    if(M[p])\n      G[M[p]-1] = min(d,G[M[p]-1]);\n    C[p/w][p%w] = 'x';\n    for(int i = 0; i < 4; ++i){\n      int x = p/w + dx[i], y = p%w + dy[i], p_ = x*w + y;\n      if(in_range(x,h) && in_range(y,w) && C[x][y] != 'x')\n        que.emplace(p_,d+1);\n    }\n  }\n}\n\nvector< vector<int> > make_graph(vector<string> &C, vector<int> &D){\n  int h = C.size(), w = C[0].length(), n = D.size();\n  map<int,int> M;\n  for(int i = 0; i < n; ++i){\n    M[D[i]] = i+1;\n  }\n  vector< vector<int> > G(n, vector<int>(n,INF));\n  for(int i = 0; i < n; ++i){\n    bfs(M,G[i],C,D[i]);\n  }\n  return G;\n}\n\nint main(){\n  int w, h;\n  while(cin >> w >> h, w){\n    vector<string> C(h);\n    vector<int> D;\n    int s;\n    for(int i = 0; i < h; ++i){\n      cin >> C[i];\n      for(int j = 0; j < w; ++j){\n        if(C[i][j] == 'o') s = i*w+j;\n        if(C[i][j] == '*'){\n          D.push_back(i*w+j);\n        }\n      }\n    }\n    D.push_back(s);\n    vector< vector<int> > G = make_graph(C,D);\n    int n = G.size()-1;\n    vector<int> V(n);\n    for(int i = 0; i < n; ++i) V[i] = i;\n    int ans = INF;\n    do{\n      int t = 0, v = n;\n      for(int i = 0; i < n; ++i){\n        t += G[v][V[i]];\n        v = V[i];\n      }\n      ans = min(ans,t);\n    }while(next_permutation(V.begin(),V.end()));\n    if(ans >= INF) ans = -1;\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint w,h;\nvector<string> field;\nint dist(pair<int,int> a,pair<int,int> b){\n\tqueue<pair<pair<int,int>,int> > bfs;\n\tset<pair<int,int> > already;\n\tbfs.push(make_pair(a,0));\n\twhile(!bfs.empty()){\n\t\tpair<int,int> pos;\n\t\tint cost;\n\t\ttie(pos,cost)=bfs.front();\n\t\tbfs.pop();\n\t\tint y,x;\n\t\ttie(y,x)=pos;\n\t\tif(y<0||h<=y||x<0||w<=h) continue;\n\t\tif(field[y][x]=='x') continue;\n\t\tif(!already.insert(pos).second) continue;\n\t\tif(pos==b) return cost;\n\t\tint dy[4]={0,0,-1,1},dx[4]={-1,1,0,0};\n\t\tfor(int i=0;i<4;++i)\n\t\t\tbfs.push(make_pair(make_pair(y+dy[i],x+dx[i]),cost+1));\n\t}\n\treturn 1048576;\n}\nint solve(){\n\tcin >> w >> h;\n\tif(!w&&!h) return 0;\n\tfield.resize(h);\n\tfor(int i=0;i<h;++i)\n\t\tcin >> field[i];\n\tpair<int,int> robot;\n\tvector<pair<int,int> > dirty;\n\tfor(int i=0;i<h;++i)\n\t\tfor(int j=0;j<w;++j){\n\t\t\tif(field[i][j]=='o') robot=make_pair(i,j);\n\t\t\tif(field[i][j]=='*') dirty.push_back(make_pair(i,j));\n\t\t}\n\t//init bitdp[state][lastpos]\n\tvector<vector<int> > bitdp;\n\tbitdp.assign(1<<dirty.size(),vector<int>());\n\tfor(int i=0;i<(1<<dirty.size());++i)\n\t\tbitdp[i].assign(dirty.size(),1048576);\n\tfor(int i=0;i<dirty.size();++i){\n\t\tbitdp[1<<i][i]=dist(robot,dirty[i]);\n\t\tif(bitdp[1<<i][i]>8192) return -1;\n\t}\n\tvector<vector<int> > ecost;\n\tecost.assign(dirty.size(),vector<int>());\n\tfor(int i=0;i<dirty.size();++i)\n\t\tecost[i].assign(dirty.size(),1048576);\n\tfor(int i=0;i<dirty.size();++i)\n\t\tfor(int j=0;j<dirty.size();++j)\n\t\t\tecost[i][j]=dist(dirty[i],dirty[j]);\n\tfor(int i=0;i<(1<<dirty.size());++i)\n\t\tfor(int j=0;j<dirty.size();++j){\n\t\t\tif(i&(1<<j)) continue;\n\t\t\tfor(int k=0;k<dirty.size();++k)\n\t\t\t\tif(i&(1<<k)) bitdp[i|(1<<j)][j]=min(bitdp[i|(1<<j)][j],bitdp[i][k]+ecost[k][j]);\n\t\t}\n\tint answer=1048576;\n\tfor(int i=0;i<dirty.size();++i)\n\t\tanswer=min(answer,bitdp[(1<<dirty.size())-1][i]);\n\tif(answer>65536) answer=-1;\n\treturn answer;\n}\nint main() {\n\tfor(;;){\n\t\tint answer=solve();\n\t\tif(answer) cout << answer << endl;\n\t\telse break;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct P {\n\tint x, y;\n};\n\nstruct Edge {\n\tint to, cost;\n};\n\nconst int inf = 1e9;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint W, H;\nint dist[20][20];\nbool m[20][20];\nbool inRange(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\nvoid bfs(P s) {\n\tfill(dist[0], dist[20], inf);\n\tdist[s.y][s.x] = 0;\n\tqueue<P> Q; Q.push( (P){s.x, s.y} );\n\twhile ( !Q.empty() ) {\n\t\tP p = Q.front(); Q.pop();\n\t\tfor (int d = 0; d < 4; ++d) {\n\t\t\tint nx = p.x+dx[d];\n\t\t\tint ny = p.y+dy[d];\n\t\t\tif (inRange(nx, ny) && !m[ny][nx] && dist[p.y][p.x]+1 < dist[ny][nx]) {\n\t\t\t\tdist[ny][nx] = dist[p.y][p.x]+1;\n\t\t\t\tQ.push((P){nx, ny});\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\twhile (cin >> W >> H, W || H) {\n\t\tfill(m[0], m[20], false);\n\t\tint sx = -1, sy = -1;\n\t\tvector<P> target;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tstring str; cin >> str;\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tswitch (str[x]) {\n\t\t\t\t\tcase '.': break;\n\t\t\t\t\tcase 'o': sx = x, sy = y; break;\n\t\t\t\t\tcase '*': target.push_back( (P){x, y} ); break;\n\t\t\t\t\tcase 'x': m[y][x] = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttarget.push_back((P){sx, sy});\n\t\tint cost[20][20];\n\t\tint N = target.size();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tbfs(target[i]);\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tcost[i][j] = dist[target[j].y][target[j].x];\n//\t\t\t\tcout << i << \" \" << j << \" \" << cost[i][j] << endl;\n\t\t\t}\n\t\t}\n\n\t\tint dp[12][1 << 11]; fill(dp[0], dp[12], inf); dp[N-1][1<<(N-1)] = 0;\n\t\tfor (int w = 1; w <= N; ++w) {\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 1; j < (1 << N); ++j) {\n\t\t\t\t\tfor (int to = 0; to < N; ++to) {\n\t\t\t\t\t\tif ( (j & (1 << to)) == 0 && dp[i][j] != inf ) {\n//\t\t\t\t\t\t\tcout << i << \" \" << j << \" \" << to << \" \" << dp[i][j] << \" \" << cost[i][to] << endl;\n\t\t\t\t\t\t\tdp[to][j|(1<<to)] = min(dp[to][j|(1<<to)], dp[i][j]+cost[i][to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = inf;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tans = min(ans, dp[i][(1<<N)-1]);\n\t\t}\n\t\tif (ans == inf) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (int)(999999999/2)\n#define eps 1e-9\n#define MAX_N 5000\nint w,h;\nint fie[30][30];\nstring data[30];\n\n\nvoid bfs(int yy,int xx){\n    int dx[]={0,1,0,-1};\n    int dy[]={1,0,-1,0};\n    queue<pii> que;\n    que.push(pii(yy,xx));\n    \n    bool used[30][30]={};\n    while(que.size()){\n        int y=que.front().first,x=que.front().second;\n        que.pop();\n        used[y][x]=true;\n        rep(i,4){\n            int ddy=y+dy[i],ddx=x+dx[i];\n            if(ddy<0||ddx<0||ddy>=h||ddx>=w||data[ddy][ddx]=='x'||used[ddy][ddx])continue;\n            fie[ddy][ddx]=fie[y][x]+1;\n            que.push(pii(ddy,ddx));\n        }\n    }\n}\n\nint main(){\n    while(cin>>w>>h&&w&&h){\n        int v=0;\n        rep(i,h){\n            cin>>data[i];\n        }\n        \n        vector<pii> p;\n        rep(i,h)rep(j,w)if(data[i][j]=='o'){p.pb(pii(i,j));v++;}\n        rep(i,h)rep(j,w)if(data[i][j]=='*'){p.pb(pii(i,j));v++;}\n\n        map<  pair<pii,pii> , int  > pass;\n        rep(i,p.size()){\n            rep(j,30)rep(k,30)fie[i][j]=INF;\n            fie[p[i].first][p[i].second]=0;\n            bfs(p[i].first,p[i].second);\n            rep(j,p.size()){\n                pass[make_pair(p[i],p[j])]=fie[p[j].first][p[j].second];\n            }\n        }\n        \n        vector<int> num;\n        rep(i,v)num.pb(i);\n        sort(all(num));\n        int mini=INF;\n        do{\n            if(num[0]!=0)continue;\n            int sum=0;\n            rep(i,v-1){\n                sum+=pass[  make_pair(p[num[i]],p[num[i+1]])  ];\n            }\n            mini=min(mini,sum);\n        }while(next_permutation(all(num)));\n        if(mini==INF)cout<<\"-1\"<<endl;\n        else cout<<mini<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n\n \nusing namespace std;\n \n#define INF 1000000000\n#define EPS 1e-9\n#define PI acos(-1)\n \ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define MAX_W 20\n#define MAX_H 20\n#define MAX_M 10\n\nint W, H;\nint M;\n\nvector<int> ans_list;\n\nchar maze[MAX_H][MAX_W];\nint sx, sy;\nint gx[MAX_M], gy[MAX_M];\n\nint memo[1 << 11][15];\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint dp[15][MAX_H][MAX_W];\n\nvoid maze_solve(){\n\n  for(int i = 0; i < 11; i++){\n    for(int j = 0; j < H; j++){\n      for(int k = 0; k < W; k++){\n\tdp[i][j][k] = INF;\n      }\n    }\n  }\n\n  for(int num = 0; num < M+1; num++){\n\n    queue<P> que;\n    que.push(P(gx[num], gy[num]));\n    dp[num][gy[num]][gx[num]] = 0;\n    while(que.size()){\n      P p = que.front();\n      que.pop();\n      int x = p.first;\n      int y = p.second;\n      for(int i = 0; i < 4; i++){\n\tint nx = x + dx[i];\n\tint ny = y + dy[i];\n\tif(nx >= 0 && nx < W && ny >= 0 && ny < H && dp[num][ny][nx] == INF && maze[ny][nx] != 'x'){\n\t  dp[num][ny][nx] = dp[num][y][x] + 1;\n\t  que.push(P(nx, ny));\n\t}\n      }\n    }\n  }\n\n}\n\nint solve(int S, int v){\n  \n  if(memo[S][v] >= 0)\n    return memo[S][v];\n\n  else if(S == (1 << M) - 1){\n    return memo[S][v] = 0;\n  }\n\n  int ret = INF;\n\n  for(int i = 0; i < M; i++){\n    if(!(S >> i & 1)){\n      ret = min(ret, dp[v][gy[i]][gx[i]] + solve(S | (1 << i), i));\n    }\n  }\n  \n  return memo[S][v] = ret;\n  \n}\n\nint main(){\n\n  while(true){\n\n    M = 0;\n    memset(memo, -1, sizeof(memo));\n\n    cin >> W >> H;\n    if(W == 0 && H == 0)\n      break;\n\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n\tcin >> maze[i][j];\n\tif(maze[i][j] == 'o'){\n\t  sy = i;\n\t  sx = j;\n\t}\n\telse if(maze[i][j] == '*'){\n\t  gy[M] = i;\n\t  gx[M] = j;\n\t  M++;\n\t}\n      }\n    }\n    gy[M] = sy;\n    gx[M] = sx;\n\n    maze_solve();\n    ans_list.push_back(solve(0, M));\n\n  }\n \n  for(int i = 0; i < ans_list.size(); i++){\n    int tmp = ans_list[i];\n    if(tmp >= INF)\n      cout << -1 << endl;\n    else\n      cout << tmp << endl;\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <utility>\nusing namespace std;\nconst int inf = 1e9;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main(){\n    while(1){\n        int w,h;\n        cin >> w >> h;\n        if(w==0) break;\n\n        vector<vector<char> > field(h+2, vector<char>(w+2, 'x'));\n        vector<pair<int,int> > coord(11);\n        int n=1;\n        for(int i=1; i<=h; i++){\n            for(int j=1; j<=w; j++){\n                cin >> field[i][j];\n                if(field[i][j]=='o'){\n                    field[i][j] = 'A';\n                    coord[0] = make_pair(i,j);\n                }\n                if(field[i][j]=='*'){\n                    field[i][j] = 'A'+n;\n                    coord[n] = make_pair(i,j);\n                    n++;\n                }\n            }\n        }\n\n        vector<vector<int> > adj(n, vector<int>(n, inf));\n        for(int i=0; i<n; i++){\n            queue<pair<int, pair<int,int> > > wait;\n            vector<vector<bool> > used(h+2, vector<bool>(w+2, false));\n            wait.push(make_pair(0, coord[i]));\n            used[coord[i].first][coord[i].second] = true;\n            adj[i][i] = 0;\n            while(!wait.empty()){\n                int y = wait.front().second.first;\n                int x = wait.front().second.second;\n                int step = wait.front().first;\n                wait.pop();\n                for(int d=0; d<4; d++){\n                    int ny = y+dy[d];\n                    int nx = x+dx[d];\n                    if(field[ny][nx]!='x' && !used[ny][nx]){\n                        used[ny][nx] = true;\n                        wait.push(make_pair(step+1, make_pair(ny, nx)));\n                        if(field[ny][nx]!='.'){\n                            adj[i][field[ny][nx]-'A'] = adj[field[ny][nx]-'A'][i] = step+1;\n                        }\n                    }\n                }\n            }\n        }\n\n        bool fail = false;\n        for(int i=0; i<n; i++){\n            if(adj[0][i]==inf){\n                fail = true;\n                break;\n            }\n        }\n        if(fail){\n            cout << -1 << endl;\n            continue;\n        }\n            \n        for(int k=0; k<n; k++){\n            for(int i=0; i<n; i++){\n                for(int j=0; j<n; j++){\n                    adj[i][j] = min(adj[i][j], adj[i][k]+adj[k][j]);\n                }\n            }\n        }\n\n        int ans = inf;\n        vector<int> perm(n);\n        for(int i=0; i<n; i++) perm[i]=i;\n        do{\n            int subans = 0;\n            for(int i=0; i<n-1; i++){\n                subans += adj[perm[i]][perm[i+1]];\n            }\n            ans = min(ans, subans);\n        }while(next_permutation(perm.begin()+1, perm.end()));\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nint save[15][15],vis[25][25],n,m,dust,ct,lp,stx,sty,sum,minn;\nint mov[4][2]= {1,0,0,-1,-1,0,0,1};\nchar plate[25][25];\nint visp[15];\n\nstruct status\n{\n    int cnt;\n    int x,y;\n    status(int a,int b,int c)\n    {\n        x = a, y = b, cnt = c;\n    }\n};\nstruct point\n{\n    int x,y;\n}p[15];\n\nqueue<struct status> q;\n\nvoid maek()\n{\n    while(!q.empty())\n    {\n        if(plate[q.front().x][q.front().y]=='*')\n            save[0][ct+1] = q.front().cnt, p[ct+1].x = q.front().x, p[ct+1].y = q.front().y, ct++;\n\n        for(int i=0; i<4; i++)\n        {\n            int tx = q.front().x + mov[i][0], ty = q.front().y + mov[i][1];\n            if(tx >= 0 && tx < m && ty >=0 && ty < n && plate[tx][ty] != 'x' && !vis[tx][ty])\n            {\n                struct status temp(tx, ty, q.front().cnt + 1);\n                vis[tx][ty] = 1;\n                q.push(temp);\n            }\n        }\n        q.pop();\n    }\n}\n\nvoid play(int x, int y, int ord)\n{\n    int ctt = 0;\n    vis[q.front().x][q.front().y] = 1;\n    while(ctt != ct)\n    {\n        if(plate[q.front().x][q.front().y]=='*')\n        {\n            int r;\n            for(r=0; r<ct; r++)\n                if(p[r].x == q.front().x && p[r].y == q.front().y) break;\n            save[ord][r] = q.front().cnt, ctt++;\n        }\n\n        for(int i=0; i<4; i++)\n        {\n            int tx = q.front().x + mov[i][0], ty = q.front().y + mov[i][1];\n            if(tx >= 0 && tx < m && ty >=0 && ty < n && plate[tx][ty] != 'x' && !vis[tx][ty])\n            {\n                struct status temp(tx, ty, q.front().cnt + 1);\n                vis[tx][ty] = 1;\n                q.push(temp);\n            }\n        }\n        q.pop();\n    }\n}\n\n\nvoid dfs(int x,int y,int ore)\n{\n    //printf(\"%d %d %d %d\\n\",x,y,ore,sum);\n\n    if(x==y)\n    {\n        minn = minn > sum ? sum : minn;\n    }\n\n    for(int i=1; i<=ct; i++)\n    {\n        if(!visp[i])\n        {\n            if(sum + save[ore][i] > minn) continue;\n            else\n            {\n                sum += save[ore][i];\n                x++;\n                visp[i] = 1;\n                dfs(x,y,i);\n                visp[i] = 0;\n                sum -= save[ore][i];\n                x--;\n            }\n        }\n    }\n}\n\n\nint main()\n{\n    freopen(\"C://1140-input.txt\",\"r\",stdin);\n   freopen(\"C://zout.txt\",\"w\",stdout);\n\n    while(~scanf(\"%d%d\",&n,&m),n+m)\n    {\n\n        memset(plate, 0, sizeof(plate));\n        memset(vis,0,sizeof(vis));\n        memset(save,0,sizeof(save));\n        memset(visp,0,sizeof(visp));\n        memset(p,0,sizeof(p));\n\n        getchar();\n        lp = 0, ct = 0;\n        for(int i=0; i<m; i++)\n        {\n            for(int j=0; j<n; j++)\n            {\n                scanf(\"%c\",&plate[i][j]);\n                if(plate[i][j]=='o') stx = i, sty = j;\n                if(plate[i][j]=='*') lp++;\n            }\n            getchar();\n        }\n\n        struct status tm(stx,sty,0);\n        q.push(tm);\n        maek();\n\n        if(ct != lp) printf(\"-1\\n\");\n        else\n        {\n            for(int i=1; i<=ct; i++)\n            {\n                memset(vis,0,sizeof(vis));\n                struct status temp(p[i].x, p[i].y, 0);\n                q.push(temp);\n                play(p[i].x, p[i].y, i);\n                while(!q.empty()) q.pop();\n            }\n\n            /*for(int i=0;i<=ct;i++)\n            {\n                for(int j=0;j<=ct;j++)\n                {\n                    printf(\"%3d \",save[i][j]);\n                }\n                printf(\"\\n\");\n            }*/\n            minn = 99999999;\n\n            for(int i=1; i<=ct; i++)\n            {\n                memset(visp,0,sizeof(visp));\n                sum = save[0][i],visp[i] = 1;\n                dfs(1,ct,i);\n            }\n            printf(\"%d\\n\",minn);\n        }\n    }\n    return 0;\n}\n\n\n/*\n\n7 10\n......x\n*...*.x\n.......\n.......\n....*.*\n.......\n.......\n.o.....\n**.....\n..*....\n\n7 5\n.......\n.o...*.\n.......\n.*...*.\n.......\n\n13 17\n............x\n..........x.x\n............x\n.......**....\n.............\n....*.......x\n............x\no..........xx\n...*.*......x\n............x\n.......x.....\n............x\n.....xx*.x.xx\n.....x.....xx\n...xxx....xxx\n.*xxxx...xxxx\n.xxxxxx..xxxx\n\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\n//grid-BFS\nstring c[25];\nint h, w, d[10010][10010];\n\nint bfs(int sx, int sy, int gx, int gy) {\n  queue<PII> que;\n  REP(i, h) REP(j, w) d[i][j] = INF;\n  que.push(PII{sx, sy});\n  d[sy][sx] = 0;\n\n  while(que.size()) {\n    PII p = que.front(); que.pop();\n    if(p.first == gx && p.second == gy) break;\n    REP(i, 4) {\n      int nx = p.first + dx[i], ny = p.second + dy[i];\n      if(IN(0, w, nx) && IN(0, h, ny) && c[ny][nx] != 'x' && d[ny][nx] == INF) {\n        que.push(PII{nx, ny});\n        d[ny][nx] = d[p.second][p.first] + 1;\n      }\n    }\n  }\n\n  return d[gy][gx];\n}\n\nint ax[15], ay[15], dp[1<<10][15], cost[15][15];\nsigned main(void)\n{\n  while(true) {\n    cin >> w >> h;\n    if(!w) break;\n    int idx = 0, sx, sy;\n    REP(i, h) cin >> c[i];\n    REP(i, h) REP(j, w) {\n      if(c[i][j] == 'o') sx = j, sy = i;\n      if(c[i][j] == '*') ax[idx] = j, ay[idx++] = i;\n    }\n\n    // REP(i, idx) cout << ax[i] << \",\" << ay[i] << \" \"; cout << endl;\n\n    REP(i, idx) FOR(j, i+1, idx) {\n      // (ax[i], ay[i]) ?????? (ax[j], ay[j]) ????????????\n      cost[i][j] = cost[j][i] = bfs(ax[i], ay[i], ax[j], ay[j]);\n    }\n\n    REP(i, 1LL<<idx) REP(j, idx) dp[i][j] = INF;\n\n    REP(i, idx) {\n      dp[1<<i][i] = bfs(sx, sy, ax[i], ay[i]);\n      // cout << i << \" \" << dp[1<<i][i] << endl;\n    }\n\n    REP(i, 1LL<<idx) REP(j, idx) {\n      // ?¨?????????????i??§???????????????j\n      if(dp[i][j] == INF) continue;\n      // cout << i << \" \" << j << endl;\n      // k?????????\n      REP(k, idx) {\n        if(i&(1<<k)) continue;\n        // j??????k????????????????????¢???+\n        chmin(dp[i | 1<<k][k], dp[i][j] + cost[j][k]);\n      }\n    }\n\n    int ret = INF;\n    REP(i, idx) chmin(ret, dp[(1LL<<idx)-1][i]);\n    if(ret >= INF) cout << -1 << endl;\n    else cout << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nint save[15][15],vis[25][25],n,m,dust,ct,lp,stx,sty,sum,minn;\nint mov[4][2]= {1,0,0,-1,-1,0,0,1};\nchar plate[25][25];\nint visp[15];\n\nstruct status\n{\n    int cnt;\n    int x,y;\n    status(int a,int b,int c)\n    {\n        x = a, y = b, cnt = c;\n    }\n};\nstruct point\n{\n    int x,y;\n}p[15];\n\nqueue<struct status> q;\n\nvoid maek()\n{\n    while(!q.empty())\n    {\n        if(plate[q.front().x][q.front().y]=='*')\n            save[0][ct+1] = q.front().cnt, p[ct+1].x = q.front().x, p[ct+1].y = q.front().y, ct++;\n\n        for(int i=0; i<4; i++)\n        {\n            int tx = q.front().x + mov[i][0], ty = q.front().y + mov[i][1];\n            if(tx >= 0 && tx < m && ty >=0 && ty < n && plate[tx][ty] != 'x' && !vis[tx][ty])\n            {\n                struct status temp(tx, ty, q.front().cnt + 1);\n                vis[tx][ty] = 1;\n                q.push(temp);\n            }\n        }\n        q.pop();\n    }\n}\n\nvoid play(int x, int y, int ord)\n{\n    int ctt = 0;\n    vis[q.front().x][q.front().y] = 1;\n    while(ctt != ct)\n    {\n        if(plate[q.front().x][q.front().y]=='*')\n        {\n            int r;\n            for(r=0; r<ct; r++)\n                if(p[r].x == q.front().x && p[r].y == q.front().y) break;\n            save[ord][r] = q.front().cnt, ctt++;\n        }\n\n        for(int i=0; i<4; i++)\n        {\n            int tx = q.front().x + mov[i][0], ty = q.front().y + mov[i][1];\n            if(tx >= 0 && tx < m && ty >=0 && ty < n && plate[tx][ty] != 'x' && !vis[tx][ty])\n            {\n                struct status temp(tx, ty, q.front().cnt + 1);\n                vis[tx][ty] = 1;\n                q.push(temp);\n            }\n        }\n        q.pop();\n    }\n}\n\n\nvoid dfs(int x,int y,int ore)\n{\n    //printf(\"%d %d %d %d\\n\",x,y,ore,sum);\n\n    if(x==y)\n    {\n        minn = minn > sum ? sum : minn;\n    }\n\n    for(int i=1; i<=ct; i++)\n    {\n        if(!visp[i])\n        {\n            if(sum + save[ore][i] > minn) continue;\n            else\n            {\n                sum += save[ore][i];\n                x++;\n                visp[i] = 1;\n                dfs(x,y,i);\n                visp[i] = 0;\n                sum -= save[ore][i];\n                x--;\n            }\n        }\n    }\n}\n\n\nint main()\n{\n    //freopen(\"C://1140-input.txt\",\"r\",stdin);\n   // freopen(\"C://zout.txt\",\"w\",stdout);\n\n    while(~scanf(\"%d%d\",&n,&m),n+m)\n    {\n\n        memset(plate, 0, sizeof(plate));\n        memset(vis,0,sizeof(vis));\n        memset(save,0,sizeof(save));\n        memset(visp,0,sizeof(visp));\n        memset(p,0,sizeof(p));\n\n        getchar();\n        lp = 0, ct = 0;\n        for(int i=0; i<m; i++)\n        {\n            for(int j=0; j<n; j++)\n            {\n                scanf(\"%c\",&plate[i][j]);\n                if(plate[i][j]=='o') stx = i, sty = j;\n                if(plate[i][j]=='*') lp++;\n            }\n            getchar();\n        }\n\n        struct status tm(stx,sty,0);\n        q.push(tm);\n        maek();\n\n        if(ct != lp) printf(\"-1\\n\");\n        else\n        {\n            for(int i=1; i<=ct; i++)\n            {\n                memset(vis,0,sizeof(vis));\n                struct status temp(p[i].x, p[i].y, 0);\n                q.push(temp);\n                play(p[i].x, p[i].y, i);\n                while(!q.empty()) q.pop();\n            }\n\n            for(int i=0;i<=ct;i++)\n            {\n                for(int j=0;j<=ct;j++)\n                {\n                    printf(\"%3d \",save[i][j]);\n                }\n                printf(\"\\n\");\n            }\n            minn = 99999999;\n\n            for(int i=1; i<=ct; i++)\n            {\n                memset(visp,0,sizeof(visp));\n                sum = save[0][i],visp[i] = 1;\n                dfs(1,ct,i);\n            }\n            printf(\"%d\\n\",minn);\n        }\n    }\n    return 0;\n}\n\n\n/*\n\n7 10\n......x\n*...*.x\n.......\n.......\n....*.*\n.......\n.......\n.o.....\n**.....\n..*....\n\n7 5\n.......\n.o...*.\n.......\n.*...*.\n.......\n\n13 17\n............x\n..........x.x\n............x\n.......**....\n.............\n....*.......x\n............x\no..........xx\n...*.*......x\n............x\n.......x.....\n............x\n.....xx*.x.xx\n.....x.....xx\n...xxx....xxx\n.*xxxx...xxxx\n.xxxxxx..xxxx\n\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> p;\ntypedef pair<int,p> P;\n\nint w,h,used[1<<10][20][20],bt[20][20];;\nchar c[20][20];\nint d[5]={-1,0,1,0,-1};\nint sx,sy,n;\n\nint bfs(){\n  memset(used,0,sizeof(used));\n  queue<P> q;\n  q.push(P(0,p(sx,sy)));\n  while(!q.empty()){\n    int s=q.front().first,x=q.front().second.first,y=q.front().second.second;\n    q.pop();\n    if(s==n-1)return used[s][y][x];\n    for(int i=0;i<4;i++){\n      int nx=x+d[i],ny=y+d[i+1];\n      if(nx<0||w<=nx||ny<0||h<=ny||c[ny][nx]=='x')continue;\n      int ns=s|bt[ny][nx];\n      if(!used[ns][ny][nx])\n\tq.push(P(ns,p(nx,ny))),used[ns][ny][nx]=used[s][y][x]+1;\n    }\n  }\n  return -1;\n}\n\nint ans(){\n  memset(used,0,sizeof(used));\n  memset(bt,0,sizeof(bt));\n  n=1;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      cin>>c[i][j];\n      if(c[i][j]=='o')sx=j,sy=i;\n      if(c[i][j]=='*')bt[i][j]=n,n*=2;\n    }\n  return bfs();\n}\n\nint main(){\n  while(cin>>w>>h,w)cout<<ans()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nchar stage[20][20];\nint cost[1024][10];\nint dis[10][10];\nint w, h;\n\ntypedef std::tuple<int, int, int> T;\nstd::vector<T> pos_to_num;\n\nlong long unsigned PopCount(long long unsigned x) {\n\tx = (x & 0x5555555555555555ULL) + ((x & 0xAAAAAAAAAAAAAAAAULL) >> 1);\n\tx = (x & 0x3333333333333333ULL) + ((x & 0xCCCCCCCCCCCCCCCCULL) >> 2);\n\tx = (x & 0x0F0F0F0F0F0F0F0FULL) + ((x & 0xF0F0F0F0F0F0F0F0ULL) >> 4);\n\n\tx *= 0x0101010101010101ULL;\n\n\treturn x;\n}\n\nvoid dijkstra(int sx, int sy)\n{\n\tint c[20][20] = {0};\n\tint dx[4] = {1, -1, 0, 0};\n\tint dy[4] = {0, 0, 1, -1};\n\n\tfor ( int i = 0; i < 20; ++i ) {\n\t\tfor ( int j = 0; j < 20; ++j ) {\n\t\t\tc[i][j] = 0xfffff;\n\t\t}\n\t}\n\n\tstd::queue<std::tuple<int,int>> q;\n\tq.push(std::make_tuple(sx, sy));\n\tc[sx][sy] = 0;\n\n\twhile(!q.empty()) {\n\t\tauto a = q.front(); q.pop();\n\t\tint x = std::get<0>(a);\n\t\tint y = std::get<1>(a);\n\t\tfor ( int i = 0; i < 4; ++i ) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif ( nx < 0 || nx >= w ) continue;\n\t\t\tif ( ny < 0 || ny >= h ) continue;\n\t\t\tif ( stage[nx][ny] == 'x' ) continue;\n\n\t\t\tif ( c[nx][ny] > (c[x][y] + 1) ) {\n\t\t\t\tc[nx][ny] = c[x][y] + 1;\n\t\t\t\tq.push(std::make_tuple(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( stage[sx][sy] == 'o' ) {\n\t\tfor ( int i = 0; i < pos_to_num.size(); ++i ) {\n\t\t\tcost[(1<<std::get<2>(pos_to_num[i]))][std::get<2>(pos_to_num[i])] = c[std::get<0>(pos_to_num[i])][std::get<1>(pos_to_num[i])];\n\t\t}\n\t} else if ( stage[sx][sy] == '*' ) {\n\t\tint num;\n\t\tfor ( int i = 0; i < pos_to_num.size(); ++i ) {\n\t\t\tif ( sx == std::get<0>(pos_to_num[i]) && sy == std::get<1>(pos_to_num[i]) ) {\n\t\t\t\tnum = std::get<2>(pos_to_num[i]);\n\t\t\t}\n\t\t}\n\t\tfor ( int i = 0; i < pos_to_num.size(); ++i ) {\n\t\t\tdis[num][std::get<2>(pos_to_num[i])] = c[std::get<0>(pos_to_num[i])][std::get<1>(pos_to_num[i])];\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile ( true ) {\n\t\tfor ( int i = 0; i < 1024; ++i ) {\n\t\t\tfor ( int j = 0; j < 10; ++j ) {\n\t\t\t\tcost[i][j] = 0xfffff;\n\t\t\t}\n\t\t}\n\t\tfor ( int i = 0; i < 10; ++i ) {\n\t\t\tfor ( int j = 0; j < 10; ++j ) {\n\t\t\t\tdis[i][j] = 0xfffff;\n\t\t\t}\n\t\t}\n\t\tfor ( int i = 0; i < 20; ++i ) {\n\t\t\tfor ( int j = 0;j < 20; ++j ) {\n\t\t\t\tstage[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tstd::cin >> w >> h;\n\t\tif ( w == 0 && h == 0 ) return 0;\n \n\t\tint sx, sy;\n\t\tint k = 0;\n\t\tfor ( int i = 0; i < h; ++i ) {\n\t\t\tfor ( int j = 0; j < w; ++j ) {\n\t\t\t\tstd::cin >> stage[j][i];\n\t\t\t\tif ( stage[j][i] == '*' ) {\n\t\t\t\t\tpos_to_num.push_back(T(j, i, k));\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tif ( stage[j][i] == 'o' ) {\n\t\t\t\t\tsx = j; sy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdijkstra(sx, sy);\n\t\tfor ( auto &v: pos_to_num ) {\n\t\t\tdijkstra(std::get<0>(v), std::get<1>(v));\n\t\t}\n\t\tstd::vector<std::tuple<int, int>> table(1<<k);\n\t\tfor ( int i = 0; i < (1<<k); ++i ) {\n\t\t\ttable[i] = std::make_tuple(PopCount(i), i);\n\t\t}\n\t\tstd::sort(table.begin(), table.end());\n\n\t\tfor ( int i = 0; i < (1<<k); ++i ) {\n\t\t\tint q = std::get<1>(table[i]);\n\t\t\tfor ( int j = 0; j < k; ++j ) {\n\t\t\t\tif ( q & (1<<j) ) {\n\t\t\t\t\tfor ( int l = 0; l < k; ++l ) {\n\t\t\t\t\t\tif ( (q ^ (1<<j)) & (1<<l) ) {\n\t\t\t\t\t\t\tint c = cost[q^(1<<j)][l] + dis[l][j];\n\t\t\t\t\t\t\tcost[q][j] = (c < cost[q][j]) ? c : cost[q][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//std::cout << \"state:\" << q << \" to:\" << j << \" cost:\" << cost[q][j] << std::endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min = 0xfffff;\n\t\tfor ( int i = 0; i < k; ++i ) {\n\t\t\tif ( min > cost[(1<<k)-1][i] ) min = cost[(1<<k)-1][i];\n\t\t}\n\t\tif ( min == 0xfffff ) {\n\t\t\tstd::cout << -1 << std::endl;\n\t\t} else {\n\t\t\tstd::cout << min << std::endl;\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n* Problem link\n* \n*/\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct INIT{INIT(){cin.tie(0);ios_base::sync_with_stdio(false);} }init;\n\ntypedef long long LL;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<double> Vd;\ntypedef vector<Vd> VVd;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\ntemplate<typename T>\ninline bool chmax(T &a, T b) {\n\tbool res = a < b;\n\tif (res)a = b;\n\treturn res;\n}\nconst double EPS = 1e-8;\ntypedef complex<double> P;\ntypedef pair<P, P> LS;\n#define X real()\n#define Y imag()\ndouble dot(P a, P b) { return a.X*b.X + a.Y*b.Y; }\ndouble cross(P a, P b) { return a.X*b.Y - a.Y*b.X; }\ndouble distance_P_LS(P p, LS ls) {\n\tP a, b, c = p;\n\ttie(a, b) = ls;\n\tif (dot(b - a, c - a) < EPS)return abs(c - a);\n\tif (dot(a - b, c - b) < EPS)return abs(c - b);\n\treturn abs(cross(b-a,c-a))/abs(b-a);\n}\nvector<string> wrap(vector<string> s,char c) {\n\tint R = s.size();\n\tint C = s[0].size();\n\tvector<string> res(R + 2, string(C + 2, c));\n\tREP(i, R)REP(j, C)res[i + 1][j + 1] = s[i][j];\n\treturn res;\n}\nconst int dr[] = { 0,0,-1,1 };\nconst int dc[] = { 1,-1,0,0 };\n\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tint C, R;\n\twhile (cin >> C >> R, C + R) {\n\t\tvector<string> s(R);\n\t\tREP(i, R)cin >> s[i];\n\t\ts = wrap(s,'x');\n\t\tint r = 0;\n\t\tint c = 0;\n\t\tR+=2; C+=2;\n\t\tint K = 0;\n\t\tREP(i, R)REP(j, C) {\n\t\t\tif (s[i][j] == 'o')r = i, c = j;\n\t\t\tif (s[i][j] == '*') {\n\t\t\t\ts[i][j] = 'a' + K++;\n\t\t\t}\n\t\t}\n\t\tusing T = tuple<int, int, int>;\n\t\tvector<VV> dist(1 << K, VV(R, V(C, -1)));\n\t\tdist[0][r][c] = 0;\n\t\tqueue<T> que;\n\t\tque.push(T(0, r, c));\n\t\tconst int inf = 1e7;\n\t\tint res = inf;\n\t\twhile (que.size()) {\n\t\t\tint bit;\n\t\t\ttie(bit, r, c) = que.front(); que.pop();\n\t\t\tif (bit == (1 << K) - 1) {\n\t\t\t\tres = dist[bit][r][c];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(i, 4) {\n\t\t\t\tint nr = r + dr[i];\n\t\t\t\tint nc = c + dc[i];\n\t\t\t\tint nxtbit = bit;\n\t\t\t\tint kk = s[nr][nc] - 'a';\n\t\t\t\tif (isalpha(s[nr][nc]) && kk < K)nxtbit |= (1 << kk);\n\t\t\t\tif (s[nr][nc] == 'x')continue;\n\t\t\t\tif (dist[nxtbit][nr][nc] !=-1)continue;\n\t\t\t\tdist[nxtbit][nr][nc] = dist[bit][r][c] + 1;\n\t\t\t\tque.push(T(nxtbit, nr, nc));\n\t\t\t}\n\t\t}\n\t\tif (res == inf)cout << -1 << endl;\n\t\telse cout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll h,w;\nnamespace solve{\n  #define H 20\n  ll mas[H][H];\n  ll px[H],py[H];\n  ll d[H][H];\n  \n  struct qry{\n      ll x,y,cost;\n  };queue<qry> Q;\n  void push(ll x,ll y,ll cost){\n    qry gen;gen.x=x,gen.y=y,gen.cost=cost;\n    Q.push(gen);\n  }\n  void dist(ll s){\n    for(int i=0;i<H;i++)d[s][i]=1e9;\n    ll dis[H][H];\n    for(int i=0;i<h;i++)for(int j=0;j<w;j++)dis[i][j]=1e9;\n    push(px[s],py[s],0);\n    while(!Q.empty()){\n      qry gen=Q.front(); Q.pop();\n      ll x=gen.x,y=gen.y,cost=gen.cost;\n      if(mas[x][y]==-2)continue;\n      if(dis[x][y]<=cost)continue;\n      dis[x][y]=cost;\n      if(mas[x][y]>0)d[s][mas[x][y]]=cost;\n      ll dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n      for(int r=0;r<4;r++){\n\tll xx=x+dx[r],yy=y+dy[r];\n\tif(0<=xx&&xx<h&&0<=yy&&yy<w){\n\t  push(xx,yy,cost+1);\n\t}\n      }\n    }\n  }\n  void main(){\n    ll cnt=1;\n    for(int i=0;i<h;i++)for(int j=0;j<w;j++){\n      char c;cin>>c;\n      if(c=='o')mas[i][j]=0,px[0]=i,py[0]=j;\n      if(c=='*')mas[i][j]=cnt,px[cnt]=i,py[cnt]=j,cnt++;\n      if(c=='x')mas[i][j]=-2;\n      if(c=='.')mas[i][j]=-1;\n    }\n    for(int i=0;i<cnt;i++)dist(i);\n    /*\n    for(int i=0;i<cnt;i++){\n      cout<<i<<\":\";\n      for(int j=1;j<cnt;j++)cout<<d[i][j]<<\" \";cout<<endl;\n    }\n    for(int i=0;i<cnt;i++)cout<<i<<\"@\"<<px[i]<<\" \"<<py[i]<<endl;*/\n    vector<ll> v; for(int i=1;i<cnt;i++)v.push_back(i);\n    ll ans=1e9;\n    do{\n      ll cur=d[0][v[0]];\n      for(int i=1;i<cnt-1;i++)cur+=d[v[i-1]][v[i]];\n      ans=min(ans,cur);\n    }while(next_permutation(v.begin(),v.end()));\n    if(ans>1e5)ans=-1;\n    cout<<ans<<endl;\n  }\n};\nint main(){\n  while(cin>>w>>h&&h>0&&w>0){\n    solve::main();\n  }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1000000000;\n\nint w, h;\nchar c[20][25];\n\nint x[11], y[11];\nint dCounter;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint minlength[20][20];\nbool used[20][20];\n\nvoid bfs(P s) {\n  for (int i = 0; i < h; i++)\n    for (int j = 0; j < w; j++) minlength[i][j] = INF, used[i][j] = false;\n  minlength[s.second][s.first] = 0;\n  queue<P> que;\n  que.push(s);\n  while (!que.empty()) {\n    P p = que.front(); que.pop();\n    int px = p.first, py = p.second;\n    if (used[py][px]) continue;\n    used[py][px] = true;\n    for (int i = 0; i < 4; i++) {\n      int newy = py + dy[i], newx = px + dx[i];\n      if (newy < 0 || newy >= h || newx < 0 || newx >= w) continue;\n      if (c[py + dy[i]][px + dx[i]] != 'x' && !used[newy][newx]) {\n        minlength[py + dy[i]][px + dx[i]] = minlength[py][px] + 1;\n        que.push(P(px + dx[i], py + dy[i]));\n      }\n    }\n  }\n}\n\nint cost[11][11];\nint bitdp[1<<12][11];\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &w, &h);\n    if (w == 0) break;\n    for (int i = 0; i < h; i++) scanf(\"%s\", c[i]);\n    dCounter = 1;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (c[i][j] == '*') x[dCounter] = j, y[dCounter++] = i;\n        if (c[i][j] == 'o') x[0] = j, y[0] = i;\n      }\n    }\n    bool flag = false;\n    for (int i = 0; i < dCounter; i++) {\n      bfs(P(x[i], y[i]));\n      for (int j = 0; j < dCounter; j++) {\n        cost[i][j] = minlength[y[j]][x[j]];\n        if (cost[i][j] == INF) i = j = dCounter, flag = true;\n      }\n    }\n    if (flag) {\n      printf(\"-1\\n\");\n      continue;\n    }\n    int maxbit = (1 << dCounter) - 1 - (1 << 0);\n    for (int i = 0; i < maxbit; i++)\n      for (int j = 0; j < dCounter; j++) bitdp[i][j] = INF;\n    bitdp[maxbit][0] = 0;\n    for (int s = maxbit; s > 0; s--) {\n      for (int from = 0; from < dCounter; from++) {\n        int frombit = 1 << from;\n        if (s & frombit) continue;\n        if (bitdp[s][from] == INF) continue;\n        for (int to = 0; to < dCounter; to++) {\n          int tobit = 1 << to;\n          if ((s & tobit) == 0) continue;\n          bitdp[s - tobit][to] = min(bitdp[s - tobit][to], bitdp[s][from] + cost[from][to]);\n        }\n      }\n    }\n    int ans = INF;\n    for (int i = 0; i < dCounter; i++) ans = min(ans, bitdp[0][i]);\n    printf(\"%d\\n\", ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<queue>\n#include<string>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define INF 10000000\nstring ch[20];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint w,h,node;\nint vd[20][20],u[11][11],px[11],py[11];\nint t[11][11];\nint dp[2048][11];\nint compute(int,int);\nvoid solve();\nint main(){\n  while(cin>>w>>h&&w){\n    node=1;\n    for(int i=0;i<h;i++){\n      cin>>ch[i];\n      for(int j=0;j<w;j++){\n\tif(ch[i][j]=='*'){\n\t  px[node]=j;\n\t  py[node++]=i;\n\t}else if(ch[i][j]=='o'){\n\t  px[0]=j;\n\t  py[0]=i;\n\t}\n      }\n    }\n   \n    for(int i=0;i<11;i++)for(int j=0;j<11;j++)t[i][j]=INF;\n    for(int i=0;i<node-1;i++)\n      for(int j=i+1;j<node;j++)\n\tt[i][j]=t[j][i]=compute(i,j);\n    /*\n    for(int i=0;i<node;i++){\n      for(int j=0;j<node;j++){\n\tif(t[i][j]==INF){\n\t  printf(\"%2d \",-1);\n\t}else{\n\t  printf(\"%2d \",t[i][j]);\n\t}\n      }\n      cout<<endl;\n    }\n    */\n    solve();\n    \n  }\n}\nint compute(int a,int b){\n  for(int i=0;i<20;i++)for(int j=0;j<20;j++)vd[i][j]=0;\n  queue<int>qx,qy,qz;\n  int x,y,z,ny,nx;\n  qx.push(px[a]);qy.push(py[a]),qz.push(0);\n  vd[py[a]][px[a]]=1;\n  while(!qx.empty()){\n    x=qx.front();qx.pop();\n    y=qy.front();qy.pop();\n    z=qz.front();qz.pop();\n    if(x==px[b]&&y==py[b])return z;\n    for(int i=0;i<4;i++){\n      ny=y+dy[i];\n      nx=x+dx[i];\n      if(ny<0||nx<0||ny>=h||nx>=w){\n\tcontinue;\n      }\n      \n      if(ch[ny][nx]=='x')continue;\n      if(!vd[ny][nx]){\n\tqy.push(ny);\n\tqx.push(nx);\n\tqz.push(z+1);\n\tvd[ny][nx]=1;\n      }\n    }\n  }\n  return INF;\n}\n\nint rec(int S,int v){\n  if(dp[S][v]>=0){\n    return dp[S][v];\n  }\n  if(S==(1<<node)-1){\n    return dp[S][v]=0;\n  }\n  int res = INF;\n  for(int u=0;u<node;u++){\n    \n    if(!(S>>u&1)){\n      res=min(res,rec(S|(1<<u),u)+t[v][u]);\n    }\n    \n  }\n  return dp[S][v]=res;\n}\nvoid solve(){\n  for(int i=0;i<2048;i++)\n    for(int j=0;j<11;j++)\n      dp[i][j]=-1;\n  int out=rec(1,0);\n  if(out!=INF)cout<<out<<endl;\n  else cout<<-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n\n#define ll long long int\n\nusing namespace std;\n\nconst int INF = (1<<25) - 1;\n\nvector<int> bfs(int s, vector<pair<int, int>> &dirtys, vector<string> &field){\n    int dh[] = {1, -1, 0, 0};\n    int dw[] = {0, 0, 1, -1};\n\n    int H = field.size(), W = field[0].size();\n    vector<vector<int>> d(H, vector<int>(W, INF));\n    pair<int, int> start = dirtys[s];\n    \n    queue<pair<int, int>> q;\n    d[start.first][start.second] = 0;\n    q.push(start);\n    while(!q.empty()){\n        pair<int, int> p = q.front(); q.pop();\n        for(int i=0; i<4; i++){\n            int nh = p.first + dh[i];\n            int nw = p.second + dw[i];\n            if(nh<0 || H<=nh || nw<0 || W<=nw || field[nh][nw]=='x' || d[nh][nw]!=INF)\n                continue;\n            d[nh][nw] = d[p.first][p.second] + 1;\n            q.push(make_pair(nh, nw));\n        }\n    }\n    \n    vector<int> res(dirtys.size());\n    for(int i=0; i<dirtys.size(); i++)\n        res[i] = d[dirtys[i].first][dirtys[i].second];\n    return res;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int W, H;\n    while(cin>>W>>H, W|H){\n        vector<string> field(H);\n        for(string &r: field)\n            cin >> r;\n        \n        //start???dirty??¨??????\n        vector<pair<int, int>> dirtys;\n        for(int i=0; i<H; i++)\n            for(int j=0; j<W; j++)\n                if(field[i][j] == 'o')\n                    dirtys.push_back(make_pair(i, j));\n                \n        for(int i=0; i<H; i++)\n            for(int j=0; j<W; j++)\n                if(field[i][j] == '*')\n                    dirtys.push_back(make_pair(i, j));\n        \n        vector<int> order(dirtys.size());\n        for(int i=0; i<dirtys.size(); i++)\n            order[i] = i;\n            \n        sort(order.begin()+1, order.end());\n        \n        vector<vector<int>> table(dirtys.size());\n        for(int i=0; i<dirtys.size(); i++)\n            table[i] = bfs(i, dirtys, field);\n        \n        int ans = INF;\n        do{\n            int tans = 0;\n            for(int i=0; i<order.size()-1; i++)\n                tans += table[order[i]][order[i+1]];\n            ans = min(ans, tans);\n        }while(next_permutation(order.begin()+1, order.end()));\n        \n        cout << (ans==INF ? -1 : ans) << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 100000000;\ntypedef double D;\nconst D EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\ntypedef pair<int, int> PII;\n\nstruct  P {\n\tint x, y;\n\tP() {}\n\tP(int x_, int y_) : x(x_), y(y_) {}\n};\n\nP s;\nint W, H, N;\nchar field[20][20];\nint G[10][10];\nint dp[1<<10][10];\n\nint rec(int S, int v)\n{\n\tif (dp[S][v]>=0) {\n\t\treturn dp[S][v];\n\t}\n\t\n\tif (S==(1<<N)-1) {\n\t\treturn dp[S][v]=0;\n\t}\n\t\n\tint res=INF;\n\trep(u, N) {\n\t\tif (!(S>>u&1)) {\n\t\t\tres = min(res, rec(S|1<<u, u)+G[v][u]);\n\t\t}\n\t}\n\treturn dp[S][v] = res;\n}\n\nint dis(P p1, P p2)\n{\n\tqueue<P> Q;\n\tint d[20][20];\n\tfill(d[0], d[0]+20*20, INF);\n\tQ.push(p1);\n\td[p1.x][p1.y]=0;\n\t\n\twhile (Q.size()) {\n\t\tP p = Q.front(); Q.pop();\n\n\t\trep(i, 4) {\n\t\t\tP np = P(p.x+dx[i], p.y+dy[i]);\n\t\t\tif_range(np.x, np.y, W, H) {\n\t\t\t\tif (field[np.x][np.y]!='x' && d[np.x][np.y]==INF) {\n\t\t\t\t\tQ.push(np);\n\t\t\t\t\td[np.x][np.y] = d[p.x][p.y]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn d[p2.x][p2.y];\n}\n\nint main()\n{\n\twhile (cin>>W>>H, W||H) {\n\t\tvector<P> stain;\n\t\t\n\t\trep(y, H) {\n\t\t\trep(x, W) {\n\t\t\t\tchar c;\n\t\t\t\tcin>>c;\n\t\t\t\tif (c=='o') { s.x=x; s.y=y; }\n\t\t\t\telse if (c=='*') {stain.push_back(P(x, y));}\n\t\t\t\tfield[x][y]=c;\n\t\t\t}\n\t\t}\n\t\tN = (int)stain.size();\n\t\t\n\t\tfill(G[0], G[0]+10*10, INF);\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tfor (int j=0; j<N; j++) {\n\t\t\t\tif (i!=j) {\n\t\t\t\t\tint dd = dis(stain[i], stain[j]);\n\t\t\t\t\tG[i][j] = dd;\n\t\t\t\t\tG[j][i] = dd;\n\t\t\t\t} else {\n\t\t\t\t\tG[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tint ans = INF;\n\n\t\trep(i, N) {\n\t\t\tmemset(dp, -1, sizeof(dp));\n\t\t\tint tmp=dis(s, stain[i]);\n\t\t\tans = min(ans, tmp+rec(1<<i, i));\n\t\t}\n\t\t\n\t\t cout << (ans<INF ? ans : -1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define INF 1.0e+12\n#define INFI 1000000\n\nstruct point{\n\tint h,w;\n};\n\nclass sales{\nprivate:\n\tint n;\n\tint **dist;\n\tint **dp;\n\tint ans;\npublic:\n\tsales(int n){\n\t\tthis->n=n;\n\t\tdist=new int*[n];\n\t\tfor(int i=0;i<n;i++) dist[i]=new int[n];\n\t\tdp=new int*[1<<n];\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tdp[i]=new int[n];\n\t\t\tfor(int j=0;j<n;j++) dp[i][j]=-1;\n\t\t}\n\t}\n\tvoid set(int n,int m,int c){\n\t\tdist[n][m]=c;\n\t\tdist[m][n]=c;\n\t}\n\tvoid set(){\n\t\tfor(int i=0;i<n;i++) dist[i][0]=0;\n\t\tans=rec(0,0);\n\t}\n\tint rec(int s,int v){\n\t\tif(dp[s][v]>=0) return dp[s][v];\n\n\t\tif(s==(1<<n)-1 && v==0) return dp[s][v]=0;\n\t\tint res=INFI;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(!(s>>i & 1)){\n\t\t\t\tres=min(res,rec(s|(1<<i),i)+dist[v][i]);\n\t\t\t}\n\t\t}\n\t\treturn dp[s][v]=res;\n\t}\n\tvoid show(){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++) cout<<dist[i][j]<<\" \";\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\tint ret(){\n\t\treturn ans;\n\t}\n};\n\n\nint w,h;\nchar p[20][21];\nint dist[20][20];\nint dust;\npoint d[10];\nsales *s;\n\nvoid dec(int ph,int pw,int c){\n\tif(p[ph][pw]=='x') return;\n\tif(ph<0 || ph>=h ||pw<0 || pw>=w) return;\n\tif(dist[ph][pw]<=c) return;\n\tdist[ph][pw]=c;\n\t\n\tdec(ph-1,pw,c+1);\n\tdec(ph+1,pw,c+1);\n\tdec(ph,pw-1,c+1);\n\tdec(ph,pw+1,c+1);\n\treturn;\n}\n\nint main(){\n\tint i,j,k;\n\twhile(cin>>w>>h){\n\t\tif(w==0 && h==0) break;\n\t\tdust=0;\n\t\tfor(i=0;i<h;i++){\n\t\t\tcin>>p[i];\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tif(p[i][j]!='.' && p[i][j]!='x'){\n\t\t\t\t\td[dust].h=i;\n\t\t\t\t\td[dust++].w=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts=new sales(dust);\n\t\tint error=0;\n\t\tfor(i=0;i<dust-1;i++){\n\t\t\ts->set(i,i,0);\n\t\t\tfor(j=0;j<h;j++) for(k=0;k<w;k++) dist[j][k]=INFI;\n\t\t\tdec(d[i].h,d[i].w,0);\n\t\t\tfor(j=i+1;j<dust;j++){\n\t\t\t\tif(dist[d[j].h][d[j].w]==INFI){\n\t\t\t\t\terror=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ts->set(i,j,dist[d[j].h][d[j].w]);\n\t\t\t}\n\t\t\tif(error==1) break;\n\t\t}\n\t\tif(error==1){\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\ts->set(dust-1,dust-1,0);\n\t\ts->set();\n\t\t//s->show();\n\t\tcout<<s->ret()<<endl;\n\t\tdelete s;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAXH 32\n#define MAXW 32\n#define NUM 16\n\ntypedef long long ll;\ntypedef pair<int, int> point_t; // firstがx,secondがy\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint w, h;\nchar field[MAXH][MAXW];\nint d[NUM][NUM];\n\nint main(void) {\n    while (1) {\n        cin >> w >> h;\n        if (w == 0 && h == 0) break;\n        point_t point[NUM];\n        int cur = 1;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> field[i][j];\n                if (field[i][j] == '*') {\n                    point[cur] = make_pair(j, i);\n                    cur++;\n                }\n                if (field[i][j] == 'o') {\n                    point[0] = make_pair(j, i);\n                }\n            }\n        }\n        if (cur == 1) {\n            cout << 0 << endl;\n            continue;\n        }\n//        cout << \"point\" << endl;\n//        for (int i = 0; i <= cur; i++) cout << point[i].first << \" \" << point[i].second << endl;\n        for (int i = 0; i < cur; i++) {\n            for (int j = i+1; j < cur; j++) {\n                int dist[MAXH][MAXW];\n                bool visited[MAXH][MAXW];\n                for (int y = 0; y < h; y++) {\n                    for (int x = 0; x < w; x++) {\n                        dist[y][x] = INF;\n                        visited[y][x] = false;\n                    }\n                }\n                int sx = point[i].first, sy = point[i].second;\n                dist[sy][sx] = 0;\n                visited[sy][sx] = true;\n                queue<point_t> P;\n                P.push(make_pair(sx, sy));\n                while (!P.empty()) {\n                    point_t now = P.front(); P.pop();\n                    int x = now.first, y = now.second;\n                    for (int k = 0; k < 4; k++) {\n                        int nx = x + dx[k];\n                        int ny = y + dy[k];\n                        if (0 <= nx && nx < w && 0 <= ny && ny < h && visited[ny][nx] == false && field[ny][nx] != 'x') {\n                            visited[ny][nx] = true;\n                            dist[ny][nx] = dist[y][x] + 1;\n                            P.push(make_pair(nx, ny));\n                        }\n                    }\n                }\n                d[i][j] = d[j][i] = dist[point[j].second][point[j].first];\n            }\n        }\n//        for (int i = 0; i < cur; i++) d[i][i] = 0;\n//        cout << \"  \";\n//        for (int i = 0; i < cur; i++) cout << i << \" \";\n//        cout << endl;\n//        for (int i = 0; i < cur; i++) {\n//            cout << i << \" \";\n//            for (int j = 0; j < cur; j++) {\n//                cout << d[i][j] << \" \";\n//            }\n//            cout << endl;\n//        }\n        int ans = INF;\n        cur--;\n        int a[cur];\n        for (int i = 0; i < cur; i++) {\n            a[i] = i+1;\n        }\n        do {\n            int temp = 0;\n            temp += d[0][a[0]];\n            for (int i = 1; i < cur; i++) {\n                temp += d[a[i-1]][a[i]];\n            }\n            ans = min(ans, temp);\n        } while (next_permutation(a, a+cur));\n        if (ans >= INF) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<int, int> P;\nint bfs();\nint INF=1000000;\nint w,h;\nint sx,sy;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint d[21][21];\nchar mapp[21][21];\nint main(){\n  int kari;\n  while(1){\n    int yogore=0;\n    int ans=0;\n\n    cin>>w>>h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>mapp[i][j];\n\tif(mapp[i][j]=='*'){\n\t  yogore++;\n\t}else if(mapp[i][j]=='o'){\n\t  sy=i;\n\t  sx=j;\n\t}\n      }\n    }\n    for(int i=0;i<yogore;i++){\n      kari=bfs();\n      if(kari==0){\n\tans=-1;\n\tbreak;\n      }else{\n\tans+=kari;\n      }\n      \n    }\n    cout<<ans<<endl;\n  }\n}\nint bfs(){\n  queue<P> que;\n  que.push(P(sy,sx));\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      d[i][j]=INF;\n    }\n  }\n  d[sy][sx]=0;\n  while(que.size()){\n    P p=que.front();\n    que.pop();\n    if(mapp[p.first][p.second]=='*'){\n      sy=p.first;\n      sx=p.second;\n      mapp[p.first][p.second]='.';\n      break;\n    }\n    for(int i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(0<=nx && nx<w && 0<=ny && ny<h && mapp[ny][nx]!='x' && d[ny][nx]==INF){\n\tque.push(P(ny,nx));\n\td[ny][nx]=d[p.first][p.second]+1;\n      }\n    }\n  }\n  return d[sy][sx];\n}\n\t\n    \n      "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\nint dy[] = {1,0,0,-1};\nint dx[] = {0,1,-1,0};\ntypedef pair<int,int> P;\n\nint w,h;\nchar c[100][100];\nbool used[100][100];\nint g[100][100];\n\nint INF = 1000000000;\nint d[100][100];\nint bfs(P s,P e) {\n    rep(i,h)rep(j,w)d[i][j] = INF;\n\n    queue<P> que;\n\n    que.push(s);\n    d[s.first][s.second] = 0;\n\n    while(!que.empty()) {\n        P p = que.front();\n        que.pop();\n\n        rep(i,4) {\n            int y = p.first + dy[i],x = p.second + dx[i];\n            if(0 <= y && y < h && 0 <= x && x < w && d[y][x] == INF && c[y][x] != 'x') {\n                d[y][x] = d[p.first][p.second] + 1;\n                que.push(P(y,x));\n            }\n        }\n    }\n    return d[e.first][e.second];\n}\n\nint main() {\n    while(true) {\n        cin >> w >> h;\n        if(w==0)break;\n\n        rep(i,h)cin >> c[i];\n\n        vector<P> dt;\n        rep(i,h)rep(j,w)if(c[i][j] == '*')dt.push_back(P(i,j));\n        if(dt.size() == 0){\n            cout << 0 << endl;\n            continue;\n        }\n\n        int perm[dt.size()];\n\n        rep(i,dt.size()) perm[i] = i;\n\n        P s;\n        rep(i,h)rep(j,w) if(c[i][j] == 'o')s = P(i,j);\n\n        rep(i,dt.size()) {\n            g[dt.size()][i] = g[i][dt.size()] = bfs(s,dt[i]);\n        }\n        rep(i,dt.size()) {\n            for(int j = i + 1;j < dt.size();j++) {\n                g[i][j] = g[j][i] = bfs(dt[i],dt[j]);\n            }\n        }\n        /*rep(i,dt.size()+1) {\n            rep(j,dt.size()+1) {\n                cout << g[i][j] << \" \";\n            }\n            cout << endl;\n        }*/\n\n        int ans = INF;\n        do {\n            int sum = g[dt.size()][perm[0]];\n            if(sum >= INF)break;\n\n            rep(i,dt.size()-1) {\n                sum += g[perm[i]][perm[i+1]];\n                if(sum >= INF)break;\n            }\n            if(sum >= INF)break;\n            ans = min(ans,sum);\n        }while(next_permutation(perm,perm+dt.size()));\n        if(ans < INF)\n            cout << ans << endl;\n        else\n            cout << -1 << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef queue<P> Q;\n\n#define _CRT_SECURE_NO_WARNINGS\nint H, W;\nchar c[21][21];\nP n[11];\nint N = 0;\nP s;\nint po[11] = { 1,2,4,8,16,32,64,128,256,512,1024 };\nint dp[1024][11];\n\nbool flag = true;\nint CalcCost(P p1, P p2) {\n\tQ q;\n\tq.push(p1);\n\tint cost[20][20];\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcost[i][j] = 100000;\n\t\t}\n\t}\n\tcost[p1.first][p1.second]=0;\n\twhile (!q.empty()) {\n\t\tint x = q.front().first,\n\t\t\ty = q.front().second; q.pop();\n\t\tint dh[4] = { 1 , -1 , 0 ,  0 };\n\t\tint dw[4] = { 0 ,  0 , 1 , -1 };\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint th = x + dh[i],\n\t\t\t\ttw = y + dw[i];\n\t\t\tif (0 <= th && th < H && 0 <= tw && tw < W) {\n\t\t\t\tif (c[th][tw] != 'x' && cost[th][tw] > cost[x][y] + 1) {\n\t\t\t\t\tif (p2 == make_pair(th, tw)) {\n\t\t\t\t\t\treturn cost[x][y] + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcost[th][tw] = cost[x][y] + 1;\n\t\t\t\t\t\tq.push(make_pair(th, tw));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid CalcStartToPoint() {\n\tQ q;\n\tq.push(s);\n\tint cost[20][20];\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcost[i][j] = 100000;\n\t\t}\n\t}\n\tcost[s.first][s.second] = 0;\n\tint count = 0;\n\twhile (!q.empty()) {\n\t\tint h = q.front().first,\n\t\t\tw = q.front().second; q.pop();\n\t\tif (c[h][w] == '*') {\n\t\t\tcount++;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif (n[i] == make_pair(h, w)) {\n\t\t\t\t\tdp[po[i]][i] = cost[h][w];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint dh[4] = { 1 , -1 , 0 ,  0 };\n\t\tint dw[4] = { 0 ,  0 , 1 , -1 };\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint th = h + dh[i],\n\t\t\t\ttw = w + dw[i];\n\t\t\tif (0 <= th && th < H && 0 <= tw && tw < W) {\n\t\t\t\tif (c[th][tw] != 'x' && cost[th][tw] > cost[h][w] + 1) {\n\t\t\t\t\tcost[th][tw] = cost[h][w] + 1;\n\t\t\t\t\tq.push(make_pair(th, tw));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (count!=N) {\n\t\tflag = false;\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tscanf(\"%d%d\", &W, &H);\n\t\tif (H == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tN = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tscanf(\"%s\", c[i]);\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (c[i][j] == '*') {\n\t\t\t\t\tn[N++] = make_pair(i, j);\n\t\t\t\t}\n\t\t\t\telse if (c[i][j] == 'o') {\n\t\t\t\t\ts = make_pair(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < po[N]; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tdp[i][j] = 1000000;\n\t\t\t}\n\t\t}\n\t\tCalcStartToPoint();\n\t\tif (flag == false) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tint cost[11][11] = {};\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\tcost[j][i] = cost[i][j] = CalcCost(n[i], n[j]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < po[N]; i++){\n\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif ((i & po[k]) == 0 && j!=k) {\n\t\t\t\t\t\tdp[i + po[k]][k] = min(dp[i][j] + cost[j][k], dp[i + po[k]][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1000000;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tans = min(ans, dp[po[N]-1][i]);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint c[11][11],e[11][2048],n;\nvoid fn(int p,int q,int r,int s){\n  int i;\n  if(e[p][r]>s){\n    e[p][r]=s;\n    if(q!=n){\n      for(i=1;i<n;i++)\n\tfn(i,q+1,r|(1<<i),s+c[p][i]);\n    }\n  }\n  return;\n}\nint main(){\n  int i,j;\n  int a[22][22],d[22][22],x[11],y[11],p,q,r,w,h;\n  int mn;\n  char s;\n  queue<pair<pair<int,int>,int> > b;\n  while(cin>>w>>h&&w+h){\n    memset(a,-1,sizeof(a));\n    n=1;\n    for(i=1;i<h+1;i++){\n      for(j=1;j<w+1;j++){\n\tcin>>s;\n\tif(0){\n\t}else if(s=='*'){\n\t  a[j][i]=n;\n\t  x[n]=j;\n\t  y[n]=i;\n\t  n++;\n\t}else if(s!='x'){\n\t  a[j][i]=0;\n\t  if(s=='o'){\n\t    x[0]=j;\n\t    y[0]=i;\n\t  }\n\t}\n      }\n    }\n    for(i=0;i<n;i++)\n      for(j=0;j<n;j++)\n\tc[j][i]=1000000;\n    for(i=0;i<n-1;i++){\n      while(b.empty()==0)\n\tb.pop();\n      b.push(make_pair(make_pair(x[i],y[i]),0));\n      memset(d,-1,sizeof(d));\n      for(j=0;j<n-i-1&&b.empty()==0;){\n\tp=b.front().first.first;\n\tq=b.front().first.second;\n\tr=b.front().second;\n\tb.pop();\n\tif(a[p][q]!=-1&&d[p][q]==-1){\n\t  d[p][q]=1;\n\t  if(i<a[p][q]){\n\t    c[i][a[p][q]]=c[a[p][q]][i]=min(c[i][a[p][q]],r);\n\t    j++;\n\t  }\n\t  b.push(make_pair(make_pair(p-1,q),r+1));\n\t  b.push(make_pair(make_pair(p,q-1),r+1));\n\t  b.push(make_pair(make_pair(p+1,q),r+1));\n\t  b.push(make_pair(make_pair(p,q+1),r+1));\n\t}\n      }\n    }\n    for(i=0;i<n;i++)\n      for(j=0;j<2048;j++)\n\te[i][j]=1000000;\n    fn(0,1,1,0);\n    mn=0;\n    for(i=1;i<n;i++){\n      if(e[mn][~((~0)<<n)]>e[i][~((~0)<<n)])\n\tmn=i;\n    }\n    if(e[mn][~((~0)<<n)]==1000000)\n      cout<<-1<<endl;\n    else\n      cout<<e[mn][~((~0)<<n)]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint h, w, k[21][21], cnt;\nint cx[11], cy[11], y[11][11], z[11][11], bfs[21][21], a, b, c[10], sum, minx;\nchar p;\n\nvoid BFS(int i) {\n\tqueue<int> Q; \n\tmemset(bfs, 10, sizeof(bfs));\n\tbfs[cy[i]][cx[i]] = 0;\n\tQ.push(cy[i] * 20 + cx[i]);\n\twhile (!Q.empty()) {\n\t\ta = Q.front() / 20;\n\t\tb = Q.front() % 20;\n\t\tif (k[a - 1][b] == 0 && bfs[a - 1][b] >= 1000000) {\n\t\t\tQ.push(Q.front() - 20);\n\t\t\tbfs[a - 1][b] = bfs[a][b] + 1;\n\t\t}\n\t\tif (k[a + 1][b] == 0 && bfs[a + 1][b] >= 1000000) {\n\t\t\tQ.push(Q.front() + 20);\n\t\t\tbfs[a + 1][b] = bfs[a][b] + 1;\n\t\t}\n\t\tif (k[a][b + 1] == 0 && bfs[a][b + 1] >= 1000000) {\n\t\t\tQ.push(Q.front() + 1);\n\t\t\tbfs[a][b + 1] = bfs[a][b] + 1;\n\t\t}\n\t\tif (k[a][b - 1] == 0 && bfs[a][b - 1] >= 1000000) {\n\t\t\tQ.push(Q.front() - 1);\n\t\t\tbfs[a][b - 1] = bfs[a][b] + 1;\n\t\t}\n\t\tQ.pop();\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tmemset(z, 0, sizeof(z));\n\t\tcin >> w >> h; cnt = 1; if (!w) { break; }\n\t\tfor (int i = 0; i < 21; i++) { \n\t\t\tfor (int j = 0; j < 21; j++) { \n\t\t\t\tk[i][j] = 1; \n\t\t\t} \n\t\t}\n\t\tcnt = 1;\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tcin >> p;\n\t\t\t\tif (p != 'x') { k[i][j] = 0; }\n\t\t\t\tif (p == '*') { cx[cnt] = j; cy[cnt] = i; cnt++; }\n\t\t\t\tif (p == 'o') { cx[0] = j; cy[0] = i; }\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\tc[i] = i;\n\t\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\t\tBFS(i);\n\t\t\t\tz[i][j] = bfs[cy[j]][cx[j]];\n\t\t\t}\n\t\t}\n\t\tminx = 114514;\n\t\tdo\n\t\t{\n\t\t\tsum = z[0][c[0] + 1];\n\t\t\tfor (int i = 0; i < cnt - 1; i++) { sum += z[c[i] + 1][c[i + 1] + 1]; }\n\t\t\tminx = min(minx, sum);\n\t\t} while (next_permutation(c, c + cnt - 1));\n\t\tif (minx == 114514) { minx = -1; }\n\t\tcout << minx << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define REP(i,n) for( int (i) = 0; (i) < n;(i)++)\n\nusing pii = pair<int,int>;\n\nvector<pii> dtile;\nint minc[20][20];\nint tile[30][30];\n\n\nint stile[30][30];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\nint search(pii from,pii to){\n  REP(i,30)REP(j,30){\n    stile[i][j] = 0;\n  }\n  stile[from.first][from.second] = -1;\n  queue<pii> que;\n  que.push(from);\n  while(que.size()){\n    auto now = que.front();\n    que.pop();\n    REP(i,4){\n      auto nh = now.first + dy[i];\n      auto nw = now.second + dx[i];\n      if(nh == to.first && nw == to.second){\n        return max(1,stile[now.first][now.second]+1);\n      }\n      if(tile[nh][nw]>=0&&nh>=0&&nw>=0&&stile[nh][nw]==0){\n        que.push({nh,nw});\n        stile[nh][nw] = max(1,stile[now.first][now.second]+1);\n      }\n    }\n  }\n  return INT_MIN/20;\n}\n\n\nint main()\n{\n  int h,w;\n  while(cin >> w >> h,w+h){\n    REP(i,30)REP(j,30){\n      if(i==h){\n        tile[i][j] = -1;\n      }else if(j == w){\n        tile[i][j] = -1;\n      }else{\n        tile[i][j] = 0;\n      }\n    }\n    pii s;\n    dtile.clear();\n    REP(i,h)REP(j,w){\n      char c;\n      cin >> c;\n      if(c == 'o'){\n        s.first = i;\n        s.second = j;\n      }else if(c == 'x'){\n        tile[i][j] = -1;\n      }else if(c =='*'){\n        tile[i][j] = 1;\n        dtile.push_back({i,j});\n      }\n    }\n    int dn = dtile.size();\n    REP(i,dn)REP(j,i){\n      minc[i][j] = minc[j][i] = search(dtile[i],dtile[j]);\n    }\n    int ans = INT_MAX;\n    vector<int> tod(dn);\n    vector<int> index(dn);\n    REP(i,dn){\n      index[i]=i;\n    }\n    REP(i,dn){\n      tod[i] = search(s,dtile[i]);\n    }\n\n    do{\n      int temp = 0;\n      temp += tod[index[0]];\n      REP(i,dn-1){\n        temp += minc[index[i]][index[i+1]];\n      }\n      ans = max(-1,min(ans,temp));\n    }while(next_permutation(index.begin(),index.end()));\n    cout << ans <<endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> Pa;\n\nint dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nconst int inf = 99999;\n\nbool bfs(char a[21][21], int w, int h, Pa pa[12], int p, int dis[12][12])\n{\n\tbool f = false;\n\tfor(int k = 0; k < p-1 ; k++){\n\t\tbool vis[21][21];\n\t\tint d[21][21];\n\t\tqueue<Pa> que;\n\t\tPa t;\n\t\tint s = p-k-1;\n\t\t\n\t\tfill(&d[0][0], &d[h][w], 0);\n\t\tfill(&vis[0][0], &vis[h][w], true);\n\t\ta[pa[k].first][pa[k].second] = '.';\n\t\tque.push(pa[k]);\n\t\tvis[t.first][t.second] = false;\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tt = que.front();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tfor(int i = k+1; i < p; i++){\n\t\t\t\tif(pa[i].first == t.first && pa[i].second == t.second){\n\t\t\t\t\tdis[k][i] = dis[i][k] = d[t.first][t.second];\n\t\t\t\t\ts--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s == 0){\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint u = t.second+dx[i], v = t.first+dy[i];\n\t\t\t\tif(0 <= u && u < w && 0 <= v && v < h){\n\t\t\t\t\tif(vis[v][u] && a[v][u] != 'x'){\n\t\t\t\t\t\tque.push(Pa(v, u));\n\t\t\t\t\t\td[v][u] = d[t.first][t.second]+1;\n\t\t\t\t\t\tvis[v][u] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn f;\n}\n\nint shp(int dis[12][12], int p)\n{\n\tint dp[1<<12][12], n = 1<<p;\n\tfill(&dp[0][0], &dp[(1<<12)-1][11], inf);\n\tdp[1<<0][0] = 0;\n\t\n\tfor(int i = 1<<0; i < n; i++){\n\t\tfor(int j = 0; j < p; j++){\n\t\t\tif(i&(1<<j)){\n\t\t\t\tfor(int k = 0; k < p; k++){\n\t\t\t\t\tif(dp[i|(1<<k)][k] > dp[i][j]+dis[j][k]){\n\t\t\t\t\t\tdp[i|(1<<k)][k] = dp[i][j]+dis[j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint t = inf;\n\tfor(int i = 0; i < p; i++){\n\t\tt = min(t, dp[n-1][i]);\n\t}\n\t\n\treturn t;\n}\n\nint tsp(int dis[12][12], int p)\n{\n\tint dp[1<<12][12];\n\tfill(&dp[0][0], &dp[(1<<12)-1][11], inf);\n\tdp[(1<<p)-1][1] = 0;\n\t\n\tfor(int i = (1<<p)-2; i >= 1; i--){\n\t\tfor(int j = 0; j < p; j++){\n\t\t\tfor(int k = 0; k < p; k++){\n\t\t\t\tif(i>>k & 1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i|1<<k][k]+dis[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i = 0; i < p; i++){\n\t\tfor(int j = 0; j < p; j++){\n\t\t\tcout << dis[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\tfor(int i = 0; i < 1<<p; i++){\n\t\tfor(int j = 0; j < p; j++){\n\t\t\tprintf(\"%6d\", dp[i][j]);\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n\treturn dp[1][0];\n}\n\nint main()\n{\n\tint h, w;\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0){\n\t\t\tbreak;\n\t\t}\n\t\tint p=1, dis[12][12];\n\t\tchar a[21][21];\n\t\tPa pa[12];\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tcin >> a[i];\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(a[i][j] == 'o'){\n\t\t\t\t\tpa[0] = Pa(i, j);\n\t\t\t\t}\n\t\t\t\tif(a[i][j] == '*'){\n\t\t\t\t\tpa[p++] = Pa(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfill(&dis[0][0], &dis[p][p], inf);\t\n\t\tfor(int i = 0; i < p; i++){\n\t\t\tdis[i][i] = 0;\n\t\t}\n\t\t\n\t\tif(bfs(a, w, h, pa, p, dis)){\n\t\t\tcout << tsp(dis, p) << endl;\n\t\t\t// cout << shp(dis, p) << endl;\n\t\t} else {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define pii pair<int, int>\nusing namespace std;\n\nstruct Info {\n    int i, j, idx;\n    Info(int a, int b, int c) : i(a), j(b), idx(c) {}\n};\n\nbool operator<(const Info &a, const Info &b) { return a.idx < b.idx; }\n\nint di[] = {-1, 0, 1, 0};\nint dj[] = {0, -1, 0, 1};\n\nint d[20][30][30];\nint used[20][30][30];\n\nconst int INF = 1e5;\n\nint main() {\n    int w, h;\n    while (cin >> w >> h) {\n        if (w + h == 0) break;\n        string mp[h];\n        int sy, sx;\n        vector<Info> dust;\n        for (int i = 0; i < h; i++) cin >> mp[i];\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (mp[i][j] == 'o') {\n                    sy = i;\n                    sx = j;\n                } else if (mp[i][j] == '*') {\n                    dust.push_back(Info(i, j, dust.size() + 1));\n                }\n            }\n        }\n        for (int i = 0; i < 20; i++) {\n            for (int j = 0; j < 30; j++) {\n                for (int k = 0; k < 30; k++) {\n                    d[i][j][k] = INF;\n                    used[i][j][k] = 0;\n                }\n            }\n        }\n        queue<pii> q;\n        q.push(pii(sy, sx));\n        d[0][sy][sx] = 0;\n        used[0][sy][sx] = 1;\n        while (!q.empty()) {\n            int ci = q.front().first;\n            int cj = q.front().second;\n            q.pop();\n            for (int k = 0; k < 4; k++) {\n                int ni = ci + di[k];\n                int nj = cj + dj[k];\n                if (ni < 0 || nj < 0 || ni >= h || nj >= w) continue;\n                if (mp[ni][nj] == 'x') continue;\n                if (used[0][ni][nj] == 0 && d[0][ni][nj] > d[0][ci][cj] + 1) {\n                    d[0][ni][nj] = d[0][ci][cj] + 1;\n                    used[0][ni][nj] = 1;\n                    q.push(pii(ni, nj));\n                }\n            }\n        }\n        for (int i = 0; i < dust.size(); i++) {\n            queue<pii> q;\n            int idx = dust[i].idx;\n            q.push(pii(dust[i].i, dust[i].j));\n            d[idx][dust[i].i][dust[i].j] = 0;\n            used[idx][dust[i].i][dust[i].j] = 1;\n            while (!q.empty()) {\n                int ci = q.front().first;\n                int cj = q.front().second;\n                q.pop();\n                for (int k = 0; k < 4; k++) {\n                    int ni = ci + di[k];\n                    int nj = cj + dj[k];\n                    if (ni < 0 || nj < 0 || ni >= h || nj >= w) continue;\n                    if (mp[ni][nj] == 'x') continue;\n                    if (used[idx][ni][nj] == 0 &&\n                        d[idx][ni][nj] > d[idx][ci][cj] + 1) {\n                        d[idx][ni][nj] = d[idx][ci][cj] + 1;\n                        used[idx][ni][nj] = 1;\n                        q.push(pii(ni, nj));\n                    }\n                }\n            }\n        }\n        int ans = INF;\n        do {\n            int tmp = 0, p = 0;\n            for (int i = 0; i < dust.size(); i++) {\n                tmp += d[p][dust[i].i][dust[i].j];\n                p = dust[i].idx;\n            }\n            ans = min(ans, tmp);\n        } while (next_permutation(dust.begin(), dust.end()));\n        cout << (ans == INF ? -1 : ans) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define MAX 12\n#define mk make_pair\n#define INF 1<<28\nstring s[20];\nbool vis[20][20];\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint n,w,h,d[MAX][MAX],c;\nint dp[1<<MAX][MAX];\nint rec(int s,int v){\n  if(dp[s][v]>=0)return dp[s][v];\n  if(s==(1<<n)-1&&v!=0){return dp[s][v]=0;}\n  int res=INF;\n  for(int u=0;u<n;u++) \n    if(!(s>>u&1))\n      res=min(res,rec(s|1<<u,u)+d[v][u]);\n  return dp[s][v]=res;\n}\nvoid bfs(int x2,int y2,int k){\n  r(i,20)r(j,20)vis[i][j]=0;\n  queue<pair<pair<int,int>,int> > q;\n  vis[x2][y2]=1;\n  q.push(mk(mk(x2,y2),0));\n  while(!q.empty()){\n    pair<pair<int,int>,int>p=q.front();q.pop();\n    int p1=p.first.first,p2=p.first.second,p3=p.second;//cout<<p1<<p2<<p3<<endl;\n    r(i,4){\n      int x=dx[i]+p1;\n      int y=dy[i]+p2;\n      if(x>=0&&x<w&&y>=0&&y<h)\n        if(!vis[x][y]&&(s[y][x]!='x')){\n          if(0<=s[y][x]&&s[y][x]<12)\n            d[k][(int)s[y][x]]=p3+1;\n          else if(k!=0&&s[y][x]=='o')\n            d[k][0]=p3+1;\n          else q.push(mk(mk(x,y),p3+1));\n          vis[x][y]=1;\n        }\n    }\n  }\n}\nint main(){\n  while(cin>>w>>h,w){c=1;\n    int a,b;\n    vector<pair<int,int> >v;\n    r(i,h)cin>>s[i];\n    r(j,w)r(i,h)if(s[i][j]=='*')s[i][j]=c++,v.push_back(make_pair(j,i));\n  memset(dp,-1,sizeof(dp));\n  n=c;\n  r(i,MAX)r(j,MAX)d[i][j]=INF;\n  r(j,w)r(i,h)if(s[i][j]=='o')a=j,b=i;\n  bfs(a,b,0);\n  r(i,c-1)bfs(v[i].first,v[i].second,i+1);\n  //r(i,c){r(j,c){cout<<d[i][j]<<' ';}cout<<endl;}cout<<d[0][1];\n  int p=rec(1,0);\n  if(p==INF)p=-1;\n  cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n \nint main(void) {\n    while(true) {\n        int w, h;\n        cin>>w>>h;\n        if(w == 0 && h == 0) break;\n        vector<vector<char> > m(h, vector<char>(w));\n        vector<P> p;\n        REP(i, h) {\n            REP(j, w) {\n                cin>>m[i][j];\n                if(m[i][j] == 'o') {\n                    p.pb(P(i, j));\n                }\n            }\n        }\n        REP(i, h) {\n            REP(j, w) {\n                if(m[i][j] == '*') {\n                    p.pb(P(i, j));\n                }\n            }\n        }\n        vector<vector<ll> > d(p.size(), vector<ll>(p.size(), INF * INF));\n        REP(i, p.size()) {\n            P s = p[i];\n            vector<vector<ll> > dir(h, vector<ll>(w, INF * INF));\n            dir[s.first][s.second] = 0;\n            queue<P> q;\n            q.push(s);\n            while(!q.empty()) {\n                P np = q.front();\n                q.pop();\n                REP(j, 4) {\n                    ll nh = np.first + dx[j];\n                    ll nw = np.second + dy[j];\n                    if(nh >= 0 && nh < h && nw >= 0 && nw < w && m[nh][nw] != 'x') {\n                        if(dir[nh][nw] == INF * INF) {\n                            dir[nh][nw] = dir[np.first][np.second] + 1;\n                            q.push(P(nh, nw));\n                        }\n                    }\n                }\n            }\n            REP(j, p.size()) {\n                if(i == j) continue;\n                d[i][j] = dir[p[j].first][p[j].second];\n            }\n        }\n        bool det = false;\n        FOR(i, 1, p.size()) {\n            if(d[0][i] == INF * INF) det = true;\n        }\n        if(det) {\n            cout<<-1<<endl;\n            continue;\n        }\n        vector<int> perm;\n        REP(i, p.size() - 1) {\n            perm.pb((int)(i + 1));\n        }\n        ll ans = INF * INF;\n        if(p.size() == 1) {\n            cout<<\"hoge\"<<endl;\n            cout<<0<<endl;\n        }\n        else {\n            do {\n                ll res = 0;\n                res += d[0][perm[0]];\n                REP(i, perm.size() - 1) {\n                    res += d[perm[i]][perm[i + 1]];\n                }\n                ans = min(ans, res);\n            } while(next_permutation(ALL(perm)));\n            cout<<ans<<endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int MAX = 21;\nconst int TM = 11;\nconst int INF = (1<<25);\n\nchar F[MAX][MAX];\nint T[(1<<TM)][MAX][MAX];\nint w,h,sx,sy;\nvector<P> Trash;\n\n\nstruct State{\n  int x,y,t,come;\n  \n  State(){}\n  State(int x, int y, int t, int c):x(x),y(y),t(t),come(c){}\n  bool operator < (const State& s) const { return t > s.t;}\n\n};\n\nbool isInside(int x, int y){ return 0<=x&&x<w&&0<=y&&y<h;}\n\nvoid init(){\n  \n  fill(T[0][0],T[0][0]+TM*MAX*MAX,INF);\n  Trash.clear();\n\n}\n\nvoid input(){\n  for(int i = 0; i < h; i++)\n    for(int j = 0; j < w; j++){\n      cin >> F[i][j];\n      if(F[i][j] == 'o'){\n\tsx = j;\n\tsy = i;\n      }\n      if(F[i][j] == '*') Trash.push_back(P(j,i));\n\n    }\n}\n\nint getTrashNum(P p){\n  for(int i = 0; i < Trash.size(); i++)\n    if(Trash[i] == p) return i;\n  return -1;\n}\nvoid solve(){\n\n  priority_queue<State> Q;\n  Q.push(State(sx,sy,0,0));\n  T[0][sy][sx] = 0;\n\n  int dx[] = {0,0,1,-1};\n  int dy[] = {1,-1,0,0};\n\n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n\n    if(T[now.come][now.y][now.x] < now.t) continue;\n    \n    for(int i = 0; i < 4; i++){\n      State nex = now;\n      nex.x += dx[i];\n      nex.y += dy[i];\n      nex.t++;\n\n      if(!isInside(nex.x,nex.y)) continue;\n      if(F[nex.y][nex.x] == 'x') continue;\n\n\n      if(F[nex.y][nex.x] == '*'){\n\tint Tnum = getTrashNum(P(nex.x, nex.y));\n\tnex.come = (nex.come|(1<<Tnum));\n      }\n\n      \n      if(T[nex.come][nex.y][nex.x] > nex.t){\n\tT[nex.come][nex.y][nex.x] = nex.t;\n\tQ.push(nex);\n      }\n    }\n  }\n\n  int ans = INF;\n\n  for(int i = 0; i < Trash.size(); i++)\n    ans = min(ans,T[(1<<Trash.size())-1][Trash[i].second][Trash[i].first]);\n\n  if(ans == INF) cout << \"-1\" << endl;\n  else cout << ans << endl;\n \n}\n  \nint main(){\n\n  while(cin >> w >> h && w+h){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef vector <string> VS;\ntypedef pair <int, int> Position;\ntypedef map <Position, int> Index;\n\nconst int size = 21;\nint w, h;\nbool O[size][size];\nbool V[size][size][1<<10];\nPosition D[size];\nint DC;\nIndex ID;\nint goal;\n\nvoid init() {\n    goal = 0;\n    ID.clear();\n    DC = 0;\n    for ( int i = 0; i < size; i++ ) {\n        for ( int j = 0; j < size; j++ ) {\n            O[i][j] = false;\n            for ( int k = 0; k < 1<<10; k++ ) {\n                V[i][j][k] = false;\n            }\n        }\n    }\n}\n\ntypedef pair <int, int> PII;\ntypedef pair <PII, PII> Node;\ntypedef priority_queue <Node, vector<Node>, greater<Node> > Queue;\nconst int dr[4] = { 0, 0, 1, -1 };\nconst int dc[4] = { 1, -1, 0, 0 };\n\nint solve( int sr, int sc ) {\n    Queue Q;\n    Node start( PII( 0, 0 ), PII( sr, sc ) );\n    Q.push( start );\n    V[sr][sc][0] = true;\n\n    while ( !Q.empty() ) {\n        Node node = Q.top();\n        Q.pop();\n\n        int cost = node.first.first;\n        int dirt = node.first.second;\n        Position pos = node.second;\n\n        if ( dirt == (1<<goal)-1 ) {\n            return cost;\n        }\n\n        for ( int i = 0; i < 4; i++ ) {\n            int nCost = cost + 1;\n            Position nPos = pos;\n            nPos.first += dr[i];\n            nPos.second += dc[i];\n\n            if ( nPos.first < 0 || nPos.first >= h || nPos.second < 0 || nPos.second >= w ) {\n                continue;\n            }\n            if ( O[nPos.first][nPos.second] ) {\n                continue;\n            }\n\n            int nDirt = dirt;\n            if ( ID.find( nPos ) != ID.end() ) {\n                int id = ID[nPos];\n                if ( ( nDirt & ( 1<<id ) ) == 0 ) {\n                    nDirt = nDirt | ( 1<<id );\n                }\n            }\n\n            if ( V[nPos.first][nPos.second][nDirt] ) {\n                continue;\n            }\n            V[nPos.first][nPos.second][nDirt] = true;\n\n            Node nNode( PII( nCost, nDirt ), nPos );\n            Q.push( nNode );\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    while ( cin >> w >> h ) {\n        if ( w == 0 && h == 0 ) break;\n        init();\n\n        VS lines(h);\n        for ( int i = 0; i < h; i++ ) {\n            cin >> lines[i];\n        }\n        for ( int i = 0; i < h; i++ ) {\n            for ( int j = 0; j < w; j++ ) {\n                if ( lines[i][j] == 'x' ) {\n                    O[i][j] = true;\n                }\n            }\n        }\n        for ( int i = 0; i < h; i++ ) {\n            for ( int j = 0; j < w; j++ ) {\n                if ( lines[i][j] == '*' ) {\n                    ID[Position( i, j )] = DC;\n                    D[DC++] = Position( i, j );\n                    goal++;\n                }\n            }\n        }\n        int sr, sc;\n        for ( int i = 0; i < h; i++ ) {\n            for ( int j = 0; j < w; j++ ) {\n                if ( lines[i][j] == 'o' ) {\n                    sr = i;\n                    sc = j;\n                }\n            }\n        }\n\n        cout << solve( sr, sc ) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nauto chmin = [](auto&& l, auto r) { return r < l ? l = r, 1 : 0; };\n\ntemplate <class T> struct dijkstra {\n  struct edge {\n    int to;\n    T w;\n  };\n  vector<vector<edge>> g;\n  const T inf;\n  dijkstra(int n, T _inf = numeric_limits<T>::max()) : g(n), inf(_inf) {}\n  void add_edge(int from, int to, T w) { g[from].push_back({to, w}); }\n  void add_undirected_edge(int u, int v, T w) {\n    add_edge(u, v, w), add_edge(v, u, w);\n  }\n  vector<T> run(int s) const {\n    vector<T> dist(g.size(), inf);\n    priority_queue<pair<T, int>, vector<pair<T, int>>, greater<>> pq;\n    pq.emplace(dist[s] = 0, s);\n    while (not pq.empty()) {\n      T d;\n      int v;\n      tie(d, v) = pq.top(), pq.pop();\n      if (d > dist[v]) continue;\n      for (auto e : g[v])\n        if (chmin(dist[e.to], dist[v] + e.w)) pq.emplace(dist[e.to], e.to);\n    }\n    return dist;\n  }\n};\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int h, w;\n  while (cin >> w >> h, h) {\n    vector<string> s(h);\n    int n = 0;\n    for (int i = 0; i < h; ++i) {\n      cin >> s[i];\n      for (int j = 0; j < w; ++j) {\n        if (s[i][j] == '*') {\n          s[i][j] = '0' + n++;\n        }\n      }\n    }\n    auto in = [&](int i, int j) {\n      return 0 <= i and i < h and 0 <= j and j < w;\n    };\n    auto $ = [&](int i, int j, int bt) {\n      return i * w * (1 << n) + j * (1 << n) + bt;\n    };\n    dijkstra<int> g(h * w * (1 << n));\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        if (s[i][j] == 'x') {\n          continue;\n        }\n        for (int di = -1; di <= 1; ++di) {\n          for (int dj = -1; dj <= 1; ++dj) {\n            if (abs(di) + abs(dj) == 1) {\n              int ni = i + di, nj = j + dj;\n              if (not in(ni, nj) or s[ni][nj] == 'x') {\n                continue;\n              }\n              for (int bt = 0; bt < 1 << n; ++bt) {\n                g.add_edge($(i, j, bt), $(ni, nj, isdigit(s[ni][nj]) ? bt | 1 << (s[ni][nj] - '0') : bt), 1);\n              }\n            }\n          }\n        }\n      }\n    }\n    int res = g.inf;\n    for (int si = 0; si < h; ++si) {\n      for (int sj = 0; sj < w; ++sj) {\n        if (s[si][sj] == 'o') {\n          auto d = g.run($(si, sj, 0));\n          for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n              chmin(res, d[$(i, j, (1 << n) - 1)]);\n            }\n          }\n        }\n      }\n    }\n    if (res == g.inf) {\n      res = -1;\n    }\n    cout << res << '\\n';\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstruct P{\n\tint x,y;\n} s;\nint w, h;\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nint to[12][12];\nint cnt[21][21];\nstring f[21];\n\nvoid solve(int x, int y, int cnt_,int from ,vector<struct P>& vc){\n\t\n\tfor(int i=0 ; i<4 ; i++ ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ){\n\t\t\tcontinue;\n\t\t}else if( cnt[my][mx] == -1 ){\n\t\t\tcontinue;\n\t\t}else if( cnt[my][mx] > cnt_ ){\n\t\t\tcnt[my][mx] = cnt_;\n\t\t\tif( f[my][mx] == '.' ){\n\t\t\t\tsolve( mx , my , cnt_+1 , from , vc );\n\t\t\t}else if( f[my][mx] == '*' ){\n\t\t\t\tfor(int j=0 ; j < (int)vc.size() ; j++ ){\n\t\t\t\t\tif( vc[j].x == mx && vc[j].y == my ){\n\t\t\t\t\t\tto[from][j+1] = cnt_;\n\t\t\t\t\t\tto[j+1][from] = cnt_;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile( cin >> w >> h , w||h ){\n\t\tvector<struct P> vc;\n\t\tfor(int y=0 ; y<12 ; y++ ){\n\t\t\tfor(int x=0 ; x<12 ; x++ ){\n\t\t\t\tto[y][x] = 1000;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> f[y];\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tif( f[y][x] == 'o' ){\n\t\t\t\t\tcnt[y][x] = 0;\n\t\t\t\t\ts.x = x, s.y = y;\n\t\t\t\t}else if( f[y][x] == '*' ){\n\t\t\t\t\tstruct P p;\n\t\t\t\t\tp.x = x, p.y = y;\n\t\t\t\t\tvc.push_back( p );\t\t\t\t\n\t\t\t\t}else if( f[y][x] == 'x' ){\n\t\t\t\t\tcnt[y][x] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i <= (int)vc.size() ; i++ ){\n\t\t\tfor(int y=0 ; y<21 ; y++ )\n\t\t\t\tfor(int x=0 ; x<21 ; x++ )\n\t\t\t\t\tif( cnt[y][x] != -1 )\n\t\t\t\t\t\tcnt[y][x] = 1000;\n\t\t\tif( i > 0 ){\n\t\t\t\tcnt[ vc[i-1].y ][ vc[i-1].x ] = 0;\n\t\t\t\tsolve( vc[i-1].x , vc[i-1].y , 1 , i , vc );\n\t\t\t}else{\n\t\t\t\tsolve( s.x , s.y , 1 , i , vc );\n\t\t\t}\n\t\t}\n\n\t\tvector<int> vc_;\n\t\tbool flag = true;\n\t\tint ans = 10000000;\n\t\tfor(int i=0 ; i < (int)vc.size() ; i++ )\n\t\t\tvc_.push_back( i+1 );\n\t\tdo{\n\t\t\tint ans_ = 0;\n\t\t\tfor(int i=0 ; i < (int)vc_.size() ; i++ ){\n\t\t\t\tif( to[ ((i==0)? 0 : vc_[i-1]) ][ vc_[i] ] == 1000 ){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tans_ += to[ ((i==0)? 0 : vc_[i-1]) ][ vc_[i] ];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = min( ans_ , ans );\n\t\t}while( next_permutation( vc_.begin() , vc_.end() ) && flag );\n\t\tcout << ( (flag)? ans : -1 ) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\n#define REP(i,a,b) for(i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\n#define ll long long\n#define ull unsigned ll\ntypedef long double ld;\n#define ALL(a) (a).begin(),(a).end()\n#define ifnot(a) if(not a)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\nusing namespace std;\n\nvoid reader(int &a) { scanf(\"%d\", &a); }\nvoid reader(double &a) { scanf(\"%lf\", &a); }\nvoid reader(char a[]) { scanf(\"%s\", a); }\nvoid reader(char &a) { scanf(\" %c\", &a); }\nvoid reader(ll &a) { scanf(\"%lld\", &a); }\nvoid reader(ull &a) { scanf(\"%llu\", &a); }\n// void reader(string& a){cin >> a;};\ntemplate<class T, class U> void reader(T& t, U& u) { reader(t); reader(u); }\ntemplate<class T, class U, class V> void reader(T& t, U& u, V& v) { reader(t); reader(u); reader(v); }\n\nvoid writer(const int a, char c) { printf(\"%d\", a); putchar(c); }\nvoid writer(const ll a, char c) { printf(\"%lld\", a); putchar(c); }\nvoid writer(const ull a, char c) { printf(\"%llu\", a); putchar(c); }\nvoid writer(const double a, char c) { printf(\"%.20lf\", a); putchar(c); }\nvoid writer(const char a[]) { printf(\"%s\", a); };\nvoid writer(const char a[], char c) { printf(\"%s\", a); putchar(c); };\nvoid writer(const char a, char c) { putchar(a); putchar(c); };\ntemplate<class T> void writerLn(T t) { writer(t, '\\n'); }\ntemplate<class T, class U> void writerLn(T t, U u) { writer(t, ' '); writer(u, '\\n'); }\ntemplate<class T, class U, class V> void writerLn(T t, U u, V v) { writer(t, ' '); writer(u, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerVec(vector<T> x) { int n = x.size(); int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\n\nvector<string> split(const string &str, char sep) { vector<string> v; stringstream ss(str); string buffer; while (getline(ss, buffer, sep)) { v.push_back(buffer); }return v; }\n// #define int ll\nbool test = 0;\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n#define INF (1 << 28)\null mod = (int)1e9 + 7;\n//.....................\n#define MAX 22\n\n\n\nstruct Node {\n\tint y, x;\n};\nint w, h;\nchar c[MAX][MAX];\nint dm[MAX][MAX];\nvector<Node> nodes;\nint start;\nbool create_distace_matrix() {\n\tint i, j, k;\n\tint y, x;\n\tint cf[MAX][MAX];\n\trep(i, nodes.size()) {\n\t\trep(y, h) rep(x, w) {\n\t\t\tif (c[y][x] == 'x') cf[y][x] = -2;\n\t\t\telse cf[y][x] = -1;\n\t\t}\n\n\t\tcf[nodes[i].y][nodes[i].x] = 0;\n\t\tbool changed = true;\n\t\tint current = 0;\n\t\tfor (; changed; current += 1) {\n\t\t\tchanged = false;\n\t\t\trep(y, h) rep(x, w) {\n\t\t\t\tif (cf[y][x] == current) {\n\t\t\t\t\trep(j, 4) {\n\t\t\t\t\t\tint ny = y + dy[j];\n\t\t\t\t\t\tint nx = x + dx[j];\n\t\t\t\t\t\tif (ny < 0 || h <= ny) continue;\n\t\t\t\t\t\tif (nx < 0 || w <= nx) continue;\n\t\t\t\t\t\tif (cf[ny][nx] == -1) cf[ny][nx] = current + 1;\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(j, nodes.size()) {\n\t\t\tint distance = cf[nodes[j].y][nodes[j].x];\n\t\t\tif (distance < 0) return false;\n\t\t\tdm[i][j] = distance;\n\t\t}\n\t}\n\treturn true;\n}\nbool done[MAX];\nint ans;\nvoid rec(int n, int idx, int sum) {\n\tint i;\n\tif (sum >= ans) return;\n\tif (n == nodes.size()) {\n\t\tif (sum < ans) ans = sum;\n\t\treturn;\n\t}\n\trep(i, nodes.size()) {\n\t\tif (done[i]) continue;\n\t\tdone[i] = true;\n\t\trec(n + 1, i, sum + dm[idx][i]);\n\t\tdone[i] = false;\n\t}\n}\nsigned main(void)\n{\n\tint i, j, k, l;\n\twhile (1) {\n\t\tcin >> w >> h;\n\t\tif (w == 0) return 0;\n\t\trep(i, h) reader(c[i]);\n\t\tnodes.clear();\n\t\trep(i, h) rep(j, w) {\n\t\t\tif (c[i][j] == 'o') start = nodes.size();\n\t\t\tif (c[i][j] == 'o' || c[i][j] == '*') {\n\t\t\t\tnodes.push_back({ i,j });\n\t\t\t}\n\t\t}\n\t\tif (!create_distace_matrix()) {\n\t\t\tcout << -1 << endl;\n\t\t\tcout << \"????????????\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tans = INT_MAX;\n\t\tdone[start] = true;\n\t\trec(1, start, 0);\n\t\tcout << ans << endl;\n\t\tdone[start] = false;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[4] = {0, 0, 1, -1};\nconst int dy[4] = {1, -1, 0, 0};\nconst int INF = 1e5;\n\nint w, h;\nchar bd[22][22];\nint d[22][22][22][22]; // d[i][j][k][l] := distance of (i,j) to (k,l)\n\nclass P {\npublic:\n\tint x, y;\n\tP() {};\n\tP(int x, int y): x(x), y(y) {};\n\tbool operator<(const P &a) {\n\t\treturn x < a.x || (x == a.x && y < a.y);\n\t}\n};\n\nvoid init() {\n\tfor (int i=0; i<22; ++i) {\n\t\tfor (int j=0; j<22; ++j) {\n\t\t\tbd[i][j] = 'x';\n\t\t}\n\t}\n}\n\nvoid calc() {\n\tfor (int i=0; i<22; ++i) {\n\t\tfor (int j=0; j<22; ++j) {\n\t\t\tfor (int k=0; k<22; ++k) {\n\t\t\t\tfor (int l=0; l<22; ++l) {\n\t\t\t\t\td[i][j][k][l] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1; i<=h; ++i) {\n\t\tfor (int j=1; j<=w; ++j) {\n\t\t\tif (bd[i][j] == 'x') continue;\n\t\t\td[i][j][i][j] = 0;\n\t\t\tfor (int k=0; k<4; ++k) {\n\t\t\t\tif (bd[i+dy[k]][j+dx[k]] == 'x') continue;\n\t\t\t\td[i][j][i+dy[k]][j+dx[k]] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1; i<=h; ++i) {\n\t\tfor (int j=1; j<=w; ++j) {\n\t\t\tfor (int k=1; k<=h; ++k) {\n\t\t\t\tfor (int l=1; l<=w; ++l) {\n\t\t\t\t\tfor (int m=1; m<=h; ++m) {\n\t\t\t\t\t\tfor (int n=1; n<=w; ++n) {\n\t\t\t\t\t\t\td[k][l][m][n] = min(d[k][l][m][n], d[k][l][i][j]+d[i][j][m][n]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (cin >> w >> h) {\n\t\tif ( ! w) break;\n\t\tinit();\n\n\t\tP robo;\n\t\tvector<P> dirty;\n\t\tfor (int i=1; i<=h; ++i) {\n\t\t\tfor (int j=1; j<=w; ++j) {\n\t\t\t\tcin >> bd[i][j];\n\t\t\t\tif (bd[i][j] == 'o') {\n\t\t\t\t\trobo.x = j;\n\t\t\t\t\trobo.y = i;\n\t\t\t\t} else if (bd[i][j] == '*') {\n\t\t\t\t\tdirty.push_back(P(j, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dirty.empty()) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcalc();\n\n\t\tint mn = INT_MAX;\n\t\tsort(dirty.begin(), dirty.end());\n\t\tdo {\n\t\t\tint t = d[robo.y][robo.x][dirty[0].y][dirty[0].x];\n\t\t\tfor (int i=0; i+1<(int)dirty.size(); ++i) {\n\t\t\t\tt += d[dirty[i].y][dirty[i].x][dirty[i+1].y][dirty[i+1].x];\n\t\t\t}\n\t\t\tmn = min(mn, t);\n\t\t} while (next_permutation(dirty.begin(), dirty.end()));\n\n\t\tif (mn >= INF) cout << -1 << endl;\n\t\telse cout << mn << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<mpi.h>\n#include<cstring>\nusing namespace std;\n#define INF (1 << 29)\ntypedef pair< int , int > Pi;\n\nint h, w;\nchar mas[50][50];\nint graph[11][11];\nint min_cost[50][50];\nPi gomi[11], st, gl;\nint gomi_size, uoo;\nint memo[12][1 << 11];\nconst int dy[] = { 1, 0, 0, -1}, dx[] = { 0, 1, -1, 0};\n\nint rec(int idx, int used)\n{\n  if(used == (1 << gomi_size) - 1) return 0;\n  if(memo[idx][used]) return memo[idx][used];\n\n  int ret = INF;\n  for(int i = 0; i < gomi_size; i++){\n    if(!(used & (1 << i)) && graph[idx][i] != -1){\n      ret = min(ret, rec(i, used | (1 << i)) + graph[idx][i]);\n    }\n  }\n\n  return memo[idx][used] = ret;\n}\n\n\nint bfs(Pi a, Pi b)\n{\n  memset( min_cost, -1, sizeof(min_cost));\n  queue< Pi > que;\n  que.push(a);\n  min_cost[a.first][a.second] = 0;\n  while(!que.empty()){\n    Pi p = que.front(); que.pop();\n    if(p == b) return min_cost[p.first][p.second];\n    for(int i = 0; i < 4; i++){\n      int ny = p.first + dy[i], nx = p.second + dx[i];\n      if(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n      if(mas[ny][nx] != 'x' && min_cost[ny][nx] == -1){\n\tmin_cost[ny][nx] = min_cost[p.first][p.second] + 1;\n\tque.push( Pi( ny, nx));\n      }\n    }\n  }\n  return -1;\n}\n\nint main(int argc, char* argv[])\n{\n  MPI_Request req1, req2;\n  MPI_Status stat;\n  int tag = 0, rank, numprocs;\n  int rank_buff[11][11];\n  vector< Pi > my_bfs; \n\n  MPI_Init(&argc, &argv);\n  MPI_Comm_size(MPI_COMM_WORLD, &numprocs);\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n  while(true){\n    if(rank == 0){\n      cin >> w >> h;\n    }\n    MPI_Bcast( &w, 1, MPI_INT, 0, MPI_COMM_WORLD);\n    MPI_Bcast( &h, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    if(w == 0) break;\n\n    gomi_size = 0;\n    my_bfs.clear();\n    memset( memo, 0, sizeof(memo));\n\n    if(rank == 0){\n      for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n          cin >> mas[i][j];\n          if(mas[i][j] == '*' || mas[i][j] == 'o'){\n            gomi[gomi_size++] = Pi( i, j);\n            if(mas[i][j] == 'o') uoo = gomi_size - 1;\n          }\n        }\n      }\n    }\n\n    for(int i = 0; i < h; i++){\n      MPI_Bcast( mas[i], w, MPI_INT, 0, MPI_COMM_WORLD);\n    }\n\n    MPI_Bcast( &gomi_size, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for(int i = 0, foo = 0; i < gomi_size; i++){ //送るプロセスの計算(めんどい\n      for(int j = i + 1; j < gomi_size; j++, foo = (foo + 1) % numprocs){\n        rank_buff[i][j] = foo;\n        if(foo == rank) my_bfs.push_back( Pi(i, j));\n      }\n    }\n\n    if(rank == 0){\n      for(int i = 0; i < gomi_size; i++){\n        for(int j = i + 1; j < gomi_size; j++){\n          if(rank_buff[i][j] != 0){\n            MPI_Isend( &gomi[i], 1, MPI::TWOINT, rank_buff[i][j], tag, MPI_COMM_WORLD, &req1);\n            MPI_Isend( &gomi[j], 1, MPI::TWOINT, rank_buff[i][j], tag, MPI_COMM_WORLD, &req2);\n          }\n        }\n      }\n      for(int i = 0; i < my_bfs.size(); i++){\n        Pi p = my_bfs[i];\n        graph[p.first][p.second] = bfs( gomi[p.first], gomi[p.second]);\n      }\n\n      for(int i = 0; i < gomi_size; i++){\n        for(int j = i + 1; j < gomi_size; j++){\n          if(rank_buff[i][j] != 0){\n            MPI_Irecv( &graph[i][j], 1, MPI_INT, rank_buff[i][j], tag, MPI_COMM_WORLD, &req1);\n            MPI_Wait( &req1, &stat);\n            graph[j][i] = graph[i][j];\n          }\n       }\n      }\n\n    } else {\n      for(int i = 0; i < my_bfs.size(); i++){\n        MPI_Irecv( &st, 1, MPI::TWOINT, 0, tag, MPI_COMM_WORLD, &req1);\n        MPI_Irecv( &gl, 1, MPI::TWOINT, 0, tag, MPI_COMM_WORLD, &req2);\n        MPI_Wait(&req1, &stat);\n        MPI_Wait(&req2, &stat);\n        int res = bfs( st, gl);\n        MPI_Isend( &res, 1, MPI_INT, 0, tag, MPI_COMM_WORLD, &req1);\n      }\n    }\n\n    \n    //巡回セールスマン！！\n    //さのぴーさんよろしく\n    if(rank == 0){\n      int ret = rec( uoo, 1 << uoo);\n    \n      if(ret != INF) cout << ret << endl;\n      else cout << -1 << endl;\n    }\n  }\n  MPI_Finalize();\n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\npublic:\n\tbool is_last_query_{};\n\tSolve()\n\t{\n\t\tusing vi = std::vector<int>;\n\t\tusing vvi = std::vector<vi>;\n\t\tusing vvvi = std::vector<vvi>;\n\t\tint W, H;\n\t\tscanf(\"%d%d\", &W, &H);\n\t\tif (W == 0)\n\t\t{\n\t\t\tis_last_query_ = true;\n\t\t\treturn;\n\t\t}\n\t\tvvi room(H + 2, vi(W + 2, -1));\n\t\tint begin[2]{};\n\t\tstd::map<std::pair<int, int>, int> dirt;\n\t\tfor (int i{1}; i <= H; i++)\n\t\t\tfor (int j{1}; j <= W; j++)\n\t\t\t{\n\t\t\t\tchar tmp;\n\t\t\t\tscanf(\" %c\", &tmp);\n\t\t\t\tif (tmp == '.') room[i][j] = 0;\n\t\t\t\telse if (tmp == '*')\n\t\t\t\t{\n\t\t\t\t\troom[i][j] = 1;\n\t\t\t\t\tint tmp{(int)dirt.size()};\n\t\t\t\t\tdirt[{i, j}] = tmp;\n\t\t\t\t}\n\t\t\t\telse if (tmp == 'o')\n\t\t\t\t{\n\t\t\t\t\troom[i][j] = 0;\n\t\t\t\t\tbegin[0] = i;\n\t\t\t\t\tbegin[1] = j;\n\t\t\t\t}\n\t\t\t}\n\t\tvvvi distance(H + 2, vvi(W + 2, vi(1 << dirt.size(), INT_MAX)));\n\t\tusing i3 = std::array<int, 3>;\n\t\tstd::queue<i3> bfs;\n\t\tbfs.push({begin[0], begin[1], 0});\n\t\tdistance[begin[0]][begin[1]][0] = 0;\n\t\tint goal{-1};\n\t\tint dir[4][2]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\t\twhile (!bfs.empty())\n\t\t{\n\t\t\tauto now{bfs.front()};\n\t\t\tbfs.pop();\n\t\t\tif (now[2] == ((1 << dirt.size()) - 1))\n\t\t\t{\n\t\t\t\tgoal = distance[now[0]][now[1]][now[2]];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int i{}; i < 4; i++)\n\t\t\t{\n\t\t\t\ti3 next;\n\t\t\t\tnext[0] = now[0] + dir[i][0];\n\t\t\t\tnext[1] = now[1] + dir[i][1];\n\t\t\t\tif (room[next[0]][next[1]] == -1) continue;\n\t\t\t\tnext[2] = now[2];\n\t\t\t\tif (room[next[0]][next[1]] == 1)\n\t\t\t\t\tnext[2] |= 1 << dirt[{next[0], next[1]}];\n\t\t\t\tif (distance[next[0]][next[1]][next[2]] != INT_MAX) continue;\n\t\t\t\tdistance[next[0]][next[1]][next[2]] = distance[now[0]][now[1]][now[2]] + 1;\n\t\t\t\tbfs.push(next);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", goal);\n\t\treturn;\n\t}\n};\n\nint main()\n{\n\twhile (!Solve().is_last_query_);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define mp make_pair\n#define pb push_back\n#define EB emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint w,h;\n\nvoid solve(){\n    char c[32][32];\n    rep(i,h) scanf(\"%s\",c[i]);\n\n    int sx,sy;\n    rep(i,h) rep(j,w) if(c[i][j]=='o'){\n        sx = i;\n        sy = j;\n        break;\n    }\n\n    int g[512][512];\n    rep(i,512) rep(j,512) g[i][j]=INF;\n    rep(i,512) g[i][i]=0;\n\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(c[i][j]=='x') continue;\n            int v = i*w+j;\n            for(int k=0;k<4;k++){\n                int nx=i+dx[k],ny=j+dy[k];\n                if(nx<0||ny<0||nx>=h||ny>=w) continue;\n                if(c[nx][ny]=='x') continue;\n                int nv = nx*w+ny;\n                g[v][nv] = 1;\n                g[nv][v] = 1;\n            }\n        }\n    }\n\n    int V = h*w;\n    for(int k=0;k<V;k++){\n        for(int i=0;i<V;i++){\n            for(int j=0;j<V;j++){\n                g[i][j] = min(g[i][j],g[i][k]+g[k][j]);\n            }\n        }\n    }\n\n    vector<int> as;\n    rep(i,h) rep(j,w){\n        int v = i*w+j;\n        if(c[i][j]=='*') as.pb(v);\n    }\n\n    sort(all(as));\n    int ans = INF;\n    do{\n        int tmp=0;\n        int now = sx*w+sy;\n        for(int i=0;i<sz(as);i++){\n            tmp += g[now][as[i]];\n            now = as[i];\n        }\n        //if(tmp==0){\n        //    //cerr << \"error\" << endl;\n        //    exit(1);\n        //}\n        ans = min(tmp,ans);\n    }while(next_permutation(all(as)));\n    if(ans==INF) cout << -1 << endl;\n    else cout << ans << endl;\n}\n\nint main(){\n    while(cin>>w>>h){\n        if(w==0 and h==0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 1000000000\n#define LLINF 1000000000000000ll\n#define sz(x) ((int)(x).size())\n#define sq(x) ((x)*(x))\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n\nint h,w;\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\nvector<string> f;\nvector<int> pos;\nint start;\nint d[402][402];\nint dp[1<<11][11];\nint K;\nint id(int x,int y){\n    return x*w+y;\n}\nstring binary(int a){\n    string ret;\n    for(int i=0;i<4;i++){\n        if((1<<i)&a)ret+=\"1\";\n        else ret+=\"0\";\n    }\n    return ret;\n}\nint rec(int S,int v){\n    if(dp[S][v]!=-1)return dp[S][v];\n    if(S==0)return 0;\n    int ret = INF;\n    for(int i=0;i<K;i++){\n        if((S&(1<<i))!=0)ret = min(ret,rec(S-(1<<i),i)+d[pos[i]][pos[v]]);\n    }\n    //cout << binary(S) << ' ' << v << ' ' << ret << endl; \n    return dp[S][v]=ret;\n}\nint solve(){\n    f.clear();\n    pos.clear();\n    scanf(\"%d %d\",&w,&h);\n    int N = w*h;\n    if(h+w==0)return 1;\n    f.resize(h);\n    for(int i=0;i<h;i++)cin >> f[i];\n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            d[i][j]=INF;\n            if(i==j)d[i][j]=0;\n        }\n    }\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            for(int dir=0;dir<4;dir++){\n                int nx = i+dx[dir];\n                int ny = j+dy[dir];\n                if(nx<0||nx>=h||ny<0||ny>=w)continue;\n                if(f[i][j]=='x'||f[nx][ny]=='x')continue;\n                //cout << id(i,j) << ' ' << id(nx,ny) << endl;\n                d[id(nx,ny)][id(i,j)]=1;\n                d[id(i,j)][id(nx,ny)]=1;\n            }\n        }\n    }\n    for(int k=0;k<N;k++){\n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n            }\n        }\n    }\n\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(f[i][j]=='o')start = pos.size();\n            if(f[i][j]=='o'||f[i][j]=='*')pos.pb(id(i,j));\n        }\n    }\n    K = pos.size();\n    for(int i=0;i<(1<<K);i++){\n        for(int j=0;j<K;j++){\n            dp[i][j]=-1;\n        }\n    }\n    int ans = rec((1<<K)-(1<<start),start);\n    if(ans==INF)ans = -1;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n\nint main(){\n    while(1){\n        if(solve())return 0;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1000000000;\n\nint w, h;\nchar c[20][25];\n\nint x[11], y[11];\nint dCounter;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint minlength[20][20];\nbool used[20][20];\n\nvoid bfs(P s) {\n  for (int i = 0; i < h; i++)\n    for (int j = 0; j < w; j++) minlength[i][j] = INF, used[i][j] = false;\n  minlength[s.second][s.first] = 0;\n  queue<P> que;\n  que.push(s);\n  while (!que.empty()) {\n    P p = que.front(); que.pop();\n    int px = p.first, py = p.second;\n    if (used[py][px]) continue;\n    used[py][px] = true;\n    for (int i = 0; i < 4; i++) {\n      int newy = py + dy[i], newx = px + dx[i];\n      if (newy < 0 || newy >= h || newx < 0 || newx >= w) continue;\n      if (c[py + dy[i]][px + dx[i]] != 'x' && !used[newy][newx]) {\n        minlength[py + dy[i]][px + dx[i]] = minlength[py][px] + 1;\n        que.push(P(px + dx[i], py + dy[i]));\n      }\n    }\n  }\n}\n\nint cost[11][11];\nint bitdp[1<<12][11];\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &w, &h);\n    if (w == 0) break;\n    for (int i = 0; i < h; i++) scanf(\"%s\", c[i]);\n    dCounter = 1;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (c[i][j] == '*') x[dCounter] = j, y[dCounter++] = i;\n        if (c[i][j] == 'o') x[0] = j, y[0] = i;\n      }\n    }\n    bool flag = false;\n    for (int i = 0; i < dCounter; i++) {\n      bfs(P(x[i], y[i]));\n      for (int j = 0; j < dCounter; j++) {\n        cost[i][j] = minlength[y[j]][x[j]];\n        if (cost[i][j] == INF) i = j = dCounter, flag = true;\n      }\n    }\n    if (flag) {\n      printf(\"-1\\n\");\n      continue;\n    }\n    int maxbit = (1 << dCounter) - 1;\n    for (int i = 0; i < maxbit - 1; i++)\n      for (int j = 0; j < dCounter; j++) bitdp[i][j] = INF;\n    bitdp[maxbit][0] = 0;\n    for (int s = maxbit - (1 << 0); s >= 0; s--) {\n      for (int from = 0; from < dCounter; from++) {\n        if ((s >> from) & 1) continue;\n        for (int to = 0; to < dCounter; to++) {\n          if (((s >> to) & 1) == 0) continue;\n          if (bitdp[s][from] == INF) continue;\n          if (to == from) continue;\n          bitdp[s & ~(1 << to)][to] = min(bitdp[s & ~(1 << to)][to], bitdp[s][from] + cost[from][to]);\n        }\n      }\n    }\n    int ans = INF;\n    for (int i = 0; i < dCounter; i++) ans = min(ans, bitdp[0][i]);\n    printf(\"%d\\n\", ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<limits.h>\n#define INF 100000\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h;\nint imap[21][21];\nint djd[20][2]; // 0->x ,1->y\nint mmaapp[20][20];\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\nint bfs(int sp,int gp){\n  int mmap[21][21];\n \n  for(int i=0;i<21;i++)for(int j=0;j<21;j++)mmap[i][j] = INF;\n  queue<P> que;\n  que.push(P(djd[sp][0],djd[sp][1]));\n  mmap[djd[sp][1]][djd[sp][0]]=0;\n\n  while(que.size()){\n    P p = que.front();que.pop();\n\n    if(p.first == djd[gp][0] && p.second == djd[gp][1])return mmap[djd[gp][1]][djd[gp][0]];\n\n    for(int i=0;i<4;i++){\n      int nx = p.first+dx[i],ny = p.second+dy[i];\n      if(0<=nx && nx < w && 0<=ny && ny < h && mmap[ny][nx] == INF && imap[ny][nx] != -1){\n\tque.push(P(nx,ny));\n\tmmap[ny][nx] = mmap[p.second][p.first] + 1;\n      }\n    }\n  }\n  return -3;\n}\n\n\n\nint main(){\n  char in;\n  int count;\n  while(true){\n    cin >> w >> h;\n    if(w+h == 0)break;\n    count=1;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> in;\n\tswitch(in){\n\tcase '.':\n\t  imap[i][j]=0;\n\t  break;\n\tcase 'o':\n\t  imap[i][j]=0;\n\t  djd[0][0]=j;\n\t  djd[0][1]=i;\n\t  break;\n\tcase 'x':\n\t  imap[i][j]=-1;\n\t  break;\n\tcase '*':\n\t  imap[i][j]=0;\n\t  djd[count][0]=j;\n\t  djd[count][1]=i;\n\t  count++;\n\t  break;\n\tdefault:\n\t  cout << \"erro\" << endl; \n\t  break;\n\t}\n      }\n    }\n\n    for(int i=0;i<count;i++){\n      for(int j=0;j<count;j++){\n\tmmaapp[i][j] = bfs(i,j);\n\t//cout << mmaapp[i][j] << \" \";\n      }\n      //cout << endl;\n    }\n\n    int permutationtest[21];\n    rep(i,count-1){\n      permutationtest[i] = i+1;\n      //cout << i+1 << endl;\n    }\n\n    int sum;\n    int ans=INF;\n    while(next_permutation(permutationtest,permutationtest+count-1)){\n      sum=0;\n      sum+=mmaapp[0][permutationtest[0]];\n      //cout << \"mmaapp[0] = \" << sum << endl; \n      for(int i=1;i<count-1;i++){\n\tsum+=mmaapp[permutationtest[i-1]][permutationtest[i]];\n\t//cout << \"i-1 = \" << permutationtest[i-1] << \", i = \" << permutationtest[i] << \", mmaapp =  \" << mmaapp[permutationtest[i-1]][permutationtest[i]]  <<endl;\n      }\n      // cout << \"----\" << endl;\n      ans=min(ans,sum);\n    }\n\n    if(ans == INF)cout << \"-1\" << endl;\n    else cout << ans << endl;\n\n  \n    \n    //if(ans <= -3)cout << \"-1\" << endl;\n    // else cout << ans << endl;\n   \n\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<limits.h>\n#define INF 100000\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h;\nint imap[21][21];\nint fin;\nint djd[20][2]; // 0->x ,1->y\nint mmaapp[20][20];\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\nint bfs(int sp,int gp){\n  int mmap[21][21];\n \n  for(int i=0;i<21;i++)for(int j=0;j<21;j++)mmap[i][j] = INF;\n  queue<P> que;\n  que.push(P(djd[sp][0],djd[sp][1]));\n  mmap[djd[sp][1]][djd[sp][0]]=0;\n\n  while(que.size()){\n    P p = que.front();que.pop();\n\n    if(p.first == djd[gp][0] && p.second == djd[gp][1])return mmap[djd[gp][1]][djd[gp][0]];\n\n    for(int i=0;i<4;i++){\n      int nx = p.first+dx[i],ny = p.second+dy[i];\n      if(0<=nx && nx < w && 0<=ny && ny < h && mmap[ny][nx] == INF && imap[ny][nx] != -1){\n\tque.push(P(nx,ny));\n\tmmap[ny][nx] = mmap[p.second][p.first] + 1;\n      }\n    }\n  }\n  return -1;\n}\n\n\n\nint main(){\n  char in;\n  int count;\n  int permutationtest[66];\n  while(true){\n    cin >> w >> h;\n    if(w+h == 0)break;\n    rep(i,66)permutationtest[i] = 0;  \n    count=1;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> in;\n\tswitch(in){\n\tcase '.':\n\t  imap[i][j]=0;\n\t  break;\n\tcase 'o':\n\t  imap[i][j]=0;\n\t  djd[0][0]=j;\n\t  djd[0][1]=i;\n\t  break;\n\tcase 'x':\n\t  imap[i][j]=-1;\n\t  break;\n\tcase '*':\n\t  imap[i][j]=0;\n\t  djd[count][0]=j;\n\t  djd[count][1]=i;\n\t  count++;\n\t  break;\n\tdefault:\n\n\t  break;\n\t}\n      }\n    }\n    fin=INF;\n    for(int i=0;i<count;i++){\n      for(int j=0;j<count;j++){\n\tmmaapp[i][j] = bfs(i,j);\n\tfin = min(fin,mmaapp[i][j]);\n      }\n   \n    }\n   \n   \n   \n    for(int i=0;i<count-1;i++){\n      permutationtest[i] = i+1;\n   \n    }\n    \n    \n    \n    int sum;\n    int ans=INF;\n    do{\n      sum=0;\n      sum+=mmaapp[0][permutationtest[0]];\n    \n      for(int i=1;i<count-1;i++){\n\tsum+=mmaapp[permutationtest[i-1]][permutationtest[i]];\n      }\n    \n      ans=min(ans,sum);\n    }while(next_permutation(permutationtest,permutationtest+(count-1)));\n\n    if(fin < 0)cout << \"-1\" << endl;\n    else cout << ans << endl;\n\n\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint hyou[410][410];\nint room[410];\nint used[11];\nint D[11];\nint cnt, ans,N;\n\nvoid init() {\n\tfor(int i = 0; i < 410; i++) {\n\t\tfor(int j = 0; j < 410; j++) {\n\t\t\thyou[i][j] = 100000;\n\t\t}\n\t\troom[i] = 100000;\n\t}\n\tcnt = 0;\n\tans = 3200000;\n\tfor(int i = 0; i < 11; i++) {\n\t\tused[i] = false;\n\t\tD[i] = false;\n\t}\n}\n\nvoid dfs(int p) {\n\tbool f = false;\n\tfor(int i = 0; i < N; i++) {\n\t\tif(used[i] == false) {\n\t\t\tf = true;\n\t\t\tused[i] = true;\n\t\t\tcnt += hyou[p][D[i]];\n\t\t\tdfs(D[i]);\n\t\t\tcnt -= hyou[p][D[i]];\n\t\t\tused[i] = false;\n\t\t}\n\t}\n\tif (!f) {\n\t\tans = min(cnt, ans);\n\t}\n\treturn;\n}\n\n\nint main() {\n\tint h,w;\n\twhile(cin >> w >> h, h | w) {\n\t\tint p = 0;\n\t\tchar c;\n\t\tinit();\n\t\tint s;\n\t\tfor(int i = 0; i < h * w; i++) {\n\t\t\tcin >> c;\n\t\t\tif (c == '.') room[i] = 1;\n\t\t\telse if (c == 'x') room[i] = 100000;\n\t\t\telse if (c == '*') {\n\t\t\t\troom[i] = 1;\n\t\t\t\tD[p] = i;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (c == 'o') {\n\t\t\t\troom[i] = 1;\n\t\t\t\ts = i;\n\t\t\t}\n\t\t}\n\t\tN = p;\n\t\tfor(int i = 0; i < h*w;i++) {\n\t\t\tif(i % w == 0) {\n\t\t\t\thyou[i][i + 1] = room[i + 1];\n\t\t\t}\n\t\t\telse if (i % w == w - 1) {\n\t\t\t\thyou[i][i - 1] = room[i - 1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\thyou[i][i - 1] = room[i - 1];\n\t\t\t\thyou[i][i + 1] = room[i + 1];\n\t\t\t}\n\t\t\tif(i + w < h * w){\n\t\t\t\thyou[i][i + w] = room[i + w];\n\t\t\t}\n\t\t\tif (i - w >= 0) {\n\t\t\t\thyou[i][i - w] = room[i - w];\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < h * w; k ++) {\n\t\t\tfor(int i = 0; i < h*w; i++) {\n\t\t\t\tfor(int j = 0; j < h * w; j++) {\n\t\t\t\t\thyou[i][j] = min(hyou[i][k] + hyou[k][j],hyou[i][j]) ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(s);\n\t\tif (ans > 90000) {\n\t\t\tcout << -1 << endl;\n\t\t} else {\n\t\tcout << ans << endl;\n\t\t}\n\t}\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing i64 = long long;\n\nconst i64 MOD = i64(1e9) + 7;\nconst i64 INF = i64(1e18) + 7;\n\n\nbool solve(){\n    int h, w;\n    cin >> w >> h;\n    if(!h)\n        return false;\n    vector<string> s(h);\n    for(int i = 0; i < h; ++i)\n        cin >> s[i];\n    vector<pair<int, int>> poses;\n    for(int i = 0; i < h; ++i)\n        for(int j = 0; j < w; ++j)\n            if(s[i][j] == 'o')\n                poses.emplace_back(i, j);\n    for(int i = 0; i < h; ++i)\n        for(int j = 0; j < w; ++j)\n            if(s[i][j] == '*')\n                poses.emplace_back(i, j);\n\n    vector<int> dx{1, 0, -1, 0};\n    vector<int> dy{0, 1, 0, -1};\n    int m = poses.size();\n    auto f = [&](int sxx, int syy){\n        vector<vector<int>> range(h, vector<int>(w, MOD));\n        range[sxx][syy] = 0;\n        queue<pair<int, int>> que;\n        que.emplace(sxx, syy);\n        while(!que.empty()){\n            int x, y;\n            tie(x, y) = que.front();\n            que.pop();\n            for(int d = 0; d < 4; ++d){\n                int nx = x + dx[d];\n                int ny = y + dy[d];\n                if(nx < 0 || ny < 0 || nx >= h || ny >= w || s[nx][ny] == 'x')\n                    continue;\n                if(range[nx][ny] > range[x][y] + 1){\n                    range[nx][ny] = range[x][y] + 1;\n                    que.emplace(nx, ny);\n                }\n            }\n        }\n        vector<int> dist(m);\n        for(int i = 0; i < m; ++i)\n            dist[i] = range[poses[i].first][poses[i].second];\n        return dist;\n    };\n    vector<vector<int>> dist(m + 1);\n    for(int i = 0; i < m; ++i)\n        dist[i] = f(poses[i].first, poses[i].second);\n    vector<vector<int>> dp(1 << m, vector<int>(m, MOD));\n    dp[1][0] = 0;\n    for(int i = 0; i < (1 << m); ++i)\n        for(int j = 0; j < m; ++j){\n            for(int k = 0; k < m; ++k){\n                if(!(i & (1 << k)))\n                    dp[i | (1 << k)][k] = min(dp[i | (1 << k)][k], dp[i][j] + dist[j][k]);\n            }\n        }\n    int ans = *min_element(dp.back().begin(), dp.back().end());\n    cout << (ans == MOD ? -1 : ans) << endl;\n    return true;\n}\n    signed main(){\n        while(solve());\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nint w,h,n;\nchar tbl[30][30];\nint G[10][10];\nint id[30][30];\nint dist[30];\n\nint x[20],y[20];\ntypedef pair<int,int> P;\nconst int INF = 10000;\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {1,0,-1,0};\n\nvoid bfs(int sx,int sy){\n  int f[30][30];\n  for(int i=0;i<h;++i)\n    for(int j=0;j<w;++j)\n      f[i][j]=INF;\n  f[sy][sx]=0;\n  queue<P> Q;\n  Q.push(P(sx,sy));\n  while(Q.size()){\n    P d = Q.front(); Q.pop();\n    for(int i=0;i<4;++i){\n      int mx = d.first+dx[i];\n      int my = d.second+dy[i];\n      if(mx<0 || mx>=w) continue;\n      if(my<0 || my>=h) continue;\n      if(tbl[my][mx]=='x') continue;\n      if(f[my][mx]<=f[d.second][d.first]+1) continue;\n      f[my][mx]=f[d.second][d.first]+1;\n      Q.push(P(mx,my));\n    }\n  }\n  \n  for(int i=0;i<n;++i)\n    dist[i] = f[y[i]][x[i]];\n}\nint main(){\n  while(cin>>w>>h,w||h){\n    for(int i=0;i<h;++i) for(int j=0;j<w;++j) id[i][j]=-1;\n    for(int i=0;i<h;++i) cin >> tbl[i];\n    n=0;\n    for(int i=0;i<h;++i)\n      for(int j=0;j<w;++j)\n\tif(tbl[i][j]=='*'){\n\t  id[i][j]=n;\n\t  x[n]=j;\n\t  y[n]=i;\n\t  ++n;\n\t}\n\n    int homedist[30]={};\n    for(int i=0;i<h;++i)\n      for(int j=0;j<w;++j)\n\tif(tbl[i][j]=='o') bfs(j,i);\n    for(int i=0;i<n;++i) homedist[i] = dist[i];\n    for(int i=0;i<n;++i){\n      bfs(x[i],y[i]);\n      for(int j=0;j<n;++j) G[i][j]=dist[j];\n    }\n    int ord[10];\n    for(int i=0;i<n;++i) ord[i]=i;\n    int ans = INF;\n\n    do{\n      int r = homedist[ord[0]];\n      for(int i=0;i+1<n;++i)\n\tr+=G[ord[i]][ord[i+1]];\n      ans=min(ans,r);\n    }while(next_permutation(ord,ord+n));\n    if(ans==INF) ans=-1;\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cassert>\n#include<cstdio>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int MAX = 21;\nconst int TM = 11;\nconst int INF = (1<<25);\n\nchar F[MAX][MAX];\nint T[(1<<TM)][MAX][MAX];\nint w,h,sx,sy;\nvector<P> Trash;\n\n\nstruct State{\n  int x,y,t,come;\n  \n  State(){}\n  State(int x, int y, int t, int c):x(x),y(y),t(t),come(c){}\n  bool operator < (const State& s) const { return t > s.t;}\n\n};\n\nvoid print(){\n  for(int i = 0; i < (1<<Trash.size()); i++){\n    for(int y = 0; y < h; y++){\n      for(int x = 0; x < w; x++)\n\tif(T[i][y][x] != INF){\n\t  printf(\"%3d\",T[i][y][x]);\n\t}else {cout << \" X \";}\n      cout << endl;\n    }\n    cout << endl;\n  }\n}\n\nbool isInside(int x, int y){ return 0<=x&&x<w&&0<=y&&y<h;}\n\nvoid init(){\n\n  for(int i = 0; i < TM; i++)\n    for(int j = 0; j < MAX; j++)\n      for(int k = 0; k < MAX; k++) T[i][j][k] = INF;\n  \n  Trash.clear();\n}\n\nvoid input(){\n  for(int i = 0; i < h; i++)\n    for(int j = 0; j < w; j++){\n      cin >> F[i][j];\n      if(F[i][j] == 'o'){\n\tsx = j;\n\tsy = i;\n      }\n      if(F[i][j] == '*') Trash.push_back(P(j,i));\n\n    }\n}\n\nint getTrashNum(P p){\n  for(int i = 0; i < Trash.size(); i++)\n    if(Trash[i] == p) return i;\n  \n  cerr << \"not found\" << endl;\n  return -1;\n}\nvoid solve(){\n\n  priority_queue<State> Q;\n  Q.push(State(sx,sy,0,0));\n  T[0][sy][sx] = 0;\n\n  int dx[] = {0,0,1,-1};\n  int dy[] = {1,-1,0,0};\n\n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n\n    if(T[now.come][now.y][now.x] < now.t) continue;\n    \n    for(int i = 0; i < 4; i++){\n      State nex = now;\n      nex.x += dx[i];\n      nex.y += dy[i];\n      nex.t++;\n\n      if(!isInside(nex.x,nex.y)) continue;\n      if(F[nex.y][nex.x] == 'x') continue;\n\n\n      if(F[nex.y][nex.x] == '*'){\n\tint Tnum = getTrashNum(P(nex.x, nex.y));\n\tnex.come = (nex.come|(1<<Tnum));\n      }\n\n      \n      if(T[nex.come][nex.y][nex.x] > nex.t){\n\tT[nex.come][nex.y][nex.x] = nex.t;\n\tQ.push(nex);\n      }\n    }\n  }\n\n  int ans = INF;\n\n  // print();\n\n  if(Trash.size() == 0) ans = 0;\n\n   for(int i = 0; i < Trash.size(); i++)\n     ans = min(ans,T[(1<<Trash.size())-1][Trash[i].second][Trash[i].first]);\n\n\n  if(ans == INF) cout << \"-1\" << endl;\n  else cout << ans << endl;\n \n}\n  \nint main(){\n\n  while(cin >> w >> h && w+h){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<map>\n#define INF 1000000\nusing namespace std;\ntypedef pair<int,int> P;\nint x[11];\nint y[11];\nbool used[11];\nint dt[20][20];\nbool t[20][20];\nint w,h;\nint dx[4]={1,0,0,-1};\nint dy[4]={0,1,-1,0};\nvoid bfs(int n){\n\tint i,j;\n\tqueue<P> que;\n\tfor(i=0;i<h;i++)for(j=0;j<w;j++)dt[i][j]=INF;\n\tque.push(P(x[n],y[n]));\n\tdt[x[n]][y[n]]=0;\n\twhile(!que.empty()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tfor(i=0;i<4;i++){\n\t\t\tif(p.first+dx[i]>=0&&p.first+dx[i]<h&&p.second+dy[i]>=0&&p.second+dy[i]<w&&dt[p.first+dx[i]][p.second+dy[i]]==INF&&t[p.first+dx[i]][p.second+dy[i]]){\n\t\t\t\tdt[p.first+dx[i]][p.second+dy[i]]=dt[p.first][p.second]+1;\n\t\t\t\tque.push(P(p.first+dx[i],p.second+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n}\nint min(int a,int b){return a<b?a:b;}\nint main(){\n\tint i,j;\n\twhile(1){\n\tint cn=1;\n\tscanf(\"%d %d\",&w,&h);\n\tif(w==0)return 0;\n\tchar c;\n\tfor(i=0;i<h;i++)for(j=0;j<w;j++)t[i][j]=true;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tscanf(\" %c\",&c);\n\t\t\tif(c=='x')t[i][j]=false;\n\t\t\tif(c=='*'){\n\t\t\t\tx[cn]=i;\n\t\t\t\ty[cn]=j;\n\t\t\t\tcn++;\n\t\t\t}\n\t\t\tif(c=='o'){\n\t\t\t\tx[0]=i;\n\t\t\t\ty[0]=j;\n\t\t\t}\n\t\t}\n\t}\n\tint p=0;\n\tint ans=0;\n\tfor(i=0;i<cn-1;i++){\n\t\tbfs(p);\n\t\tused[p]=true;\n\t\tp=-1;\n\t\tfor(j=0;j<cn;j++){\n\t\t\tif(i==j)continue;\n\t\t\tif(!used[j]&&(p==-1||dt[x[p]][y[p]]>dt[x[j]][y[j]]))p=j;\n\t\t}\n\t\tif(dt[x[p]][y[p]]==INF)break;\n\t\tans+=dt[x[p]][y[p]];\n\t}\n\tif(i!=cn-1)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ans);\n\t}\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\n#include<cctype>\n#include<cstdlib>\n#include<map>\n#include<vector>\n#include<complex>\n#include<queue>\n#include<set>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, int>\n#define Y first\n#define X second\nconst int INF = 100000000;\n\n\nclass C{\n    public:\n        int y, x, step;\n        C(int _y, int _x, int _step){\n            y = _y;\n            x = _x;\n            step = _step;\n        }\n};\n\nint main(){\n    int h, w;\n    while(cin >>w >>h && h){\n        int cnt = 0, firy, firx;\n        vector< vector<char> > v(h, vector<char>(w));\n        set<P> s;\n        REP(i, h){\n            REP(j, w){\n                cin >>v[i][j];\n                if(v[i][j] == '*') s.insert( P(i, j) );\n                if(v[i][j] == 'o'){ firy = i; firx = j; }\n            }\n        }\n\n        int ans = 0;\n\n        //debug\n        //REP(i, h){\n        //    REP(j, w){\n        //        cout <<v[i][j] <<\" \";\n        //    }\n        //    cout <<endl;\n        //}\n        while(!s.empty()){\n            queue<C> open;\n            open.push( C(firy, firx, 0) );\n            vector< vector<int> > closed(h, vector<int>(w, INF));\n            while(!open.empty()){\n                C now = open.front();\n                open.pop();\n\n                if(now.step >= closed[now.y][now.x]) continue;\n                closed[now.y][now.x] = now.step;\n\n                int my[] = {0, 0, 1, -1};\n                int mx[] = {1, -1, 0, 0};\n\n                REP(i, 4){\n                    int ny = now.y + my[i];\n                    int nx = now.x + mx[i];\n                    if(ny < 0 || nx < 0 || ny >= h || nx >= w || v[ny][nx] == 'x') continue;\n                    open.push( C(ny, nx, now.step + 1) );\n                }\n            }\n            //debug\n            //REP(i, h){\n            //    REP(j, w){\n            //        cout <<closed[i][j] <<\" \";\n            //    }\n            //    cout <<endl;\n            //}\n            //cout <<endl;\n            int tmp = INF;\n            set<P>::iterator next;\n            for(set<P>::iterator it = s.begin(); it != s.end(); it++){\n                if(closed[(*it).Y][(*it).X] < tmp){\n                    tmp = closed[(*it).Y][(*it).X];\n                    next = it;\n                }\n            }\n            if(tmp == INF){\n                ans = -1;\n                s.clear();\n                break;\n            }\n            ans += tmp;\n            firy = (*next).Y;\n            firx = (*next).X;\n            s.erase(next);\n        }\n        cout <<ans <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#define MAX_WH 20\n#define MAX_YOGORE 10\n\nusing namespace std;\n\nint w, h;\nchar data[MAX_WH][MAX_WH];\nint cost[MAX_YOGORE+1][MAX_YOGORE+1];\nint sx, sy;\nint n;\n\nclass Point {\npublic:\n  int x, y;\n  int cost;\n  Point(int x=0, int y=0, int cost=0) : x(x), y(y), cost(cost) {}\n};\n\nvoid bfs(int x, int y) {\n  Point p;\n  queue<Point> Q;\n  bool visited[MAX_WH][MAX_WH];\n  int s = data[y][x]-'a';\n  int t;\n  const int dx[4] = {1,0,-1,0};\n  const int dy[4] = {0,1,0,-1};\n\n  for(int i = 0; i < h; i++) {\n    for(int j = 0; j < w; j++) {\n      visited[i][j] = false;\n    }\n  }\n\n  visited[y][x] = true;\n  Q.push(Point(x, y, 0));\n\n  while(!Q.empty()) {\n    p = Q.front();\n    Q.pop();\n\n    if(data[p.y][p.x] != '.' && data[p.y][p.x] != 'x') {\n      t = data[p.y][p.x]-'a';\n      cost[s][t] = cost[t][s] = p.cost; \n    }\n\n    for(int i = 0; i < 4; i++) {\n      int nx = p.x + dx[i];\n      int ny = p.y + dy[i];\n      if(nx < 0 || nx >= w) continue;\n      if(ny < 0 || ny >= h) continue;\n      if(data[ny][nx] == 'x') continue;\n      if(visited[ny][nx]) continue;\n      Q.push(Point(nx, ny, p.cost+1));\n      visited[ny][nx] = true;\n    } \n  }\n}\n\nint solve() {\n  int A[MAX_YOGORE];\n  int ans;\n  for(int i = 0; i < n+1; i++) {\n    for(int j = 0; j < n+1; j++) {\n      cost[i][j] = 0;\n    }\n  }\n  for(int i = 0; i < h; i++) {\n    for(int j = 0; j < w; j++) {\n      if(data[i][j] != '.' && data[i][j] != 'x') {\n\tbfs(j, i);\n      }\n    }\n  }\n\n  for(int i = 0; i < n; i++) {\n    A[i] = i+1;\n  }\n\n  ans = 100000;\n  do {\n    int newAns = cost[0][A[0]];\n    if(newAns == 0) continue;\n    for(int i = 1; i < n; i++) {\n      if(cost[A[i-1]][A[i]] == 0) {\n\tnewAns = 100000;\n\tbreak;\n      }\n      newAns += cost[A[i-1]][A[i]];\n    }\n    if(newAns < ans) ans = newAns;\n\n  } while(next_permutation(A, A+n));\n  if(ans == 100000)   return -1;\n  else           return ans;\n}\n\nint main() {\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    n = 0;\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) {\n\tcin >> data[i][j];\n\tif(data[i][j] == 'o') {\n\t  sx = j;\n\t  sy = i;\n\t  data[i][j] = 'a';\n\t} else if(data[i][j] == '*') {\n\t  data[i][j] = 'b' + n++;\n\t}\n      }\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\n\nstruct Point {\n  Point() {\n    x = -1;\n    y = -1;\n  }\n  Point(int px, int py) {\n    x = px;\n    y = py;\n  }\n  int x;\n  int y;\n};\n\nstruct Node {\n  Node() {\n    cost = -1;\n    checked = false;\n  }\n  Point prev;\n  int cost;\n  bool checked;\n};\n\nint SearchOne(const std::vector<std::string>& room, int width, int height, Point sp, Point gp, std::vector<Point>* path) {\n  using namespace std;\n\n  int sx = sp.x, sy = sp.y;\n  int gx = gp.x, gy = gp.y;\n\n  queue<Point> remains;\n  remains.push(Point(sx, sy));\n\n  vector<vector<Node>> nodes(height, vector<Node>(width));\n  nodes[sy][sx].prev = Point(-1, -1);\n  nodes[sy][sx].cost = 0;\n  nodes[sy][sx].checked = true;\n\n  int dx[] = {0, 1, 0, -1};\n  int dy[] = {1, 0, -1, 0};\n  while (!remains.empty()) {\n    Point pt = remains.front(); remains.pop();\n    for (int di = 0; di < 4; ++di) {\n      int destx = pt.x + dx[di];\n      int desty = pt.y + dy[di];\n      if (destx < 0 || destx >= width || desty < 0 || desty >= height) {\n        continue;\n      }\n      if (room[desty][destx] == '.' || room[desty][destx] == '*' || room[desty][destx] == 'o') {\n        int& cost = nodes[desty][destx].cost;\n        const int total_cost = nodes[pt.y][pt.x].cost + 1;\n        if (!nodes[desty][destx].checked || cost > total_cost) {  // update cost\n          cost = total_cost;\n          nodes[desty][destx].prev = Point(pt.x, pt.y);\n        }\n        if (!nodes[desty][destx].checked) {\n          remains.push(Point(destx, desty));\n          nodes[desty][destx].checked = true;\n        }\n      }\n    }\n  }\n\n  // set best path\n  if (nodes[gy][gx].cost != -1) {\n    path->push_back(Point(gx, gy));\n    for (int x = gx, y = gy; !(x == sx && y == sy);) {\n      const int prevx = nodes[y][x].prev.x;\n      const int prevy = nodes[y][x].prev.y;\n      path->push_back(Point(prevx, prevy));\n      x = prevx;\n      y = prevy;\n    }\n    reverse(path->begin(), path->end());\n  }\n\n  return nodes[gy][gx].cost;\n}\n\n// return best number of moves\nint Search(const std::vector<std::string>& room, int width, int height, std::vector<Point>* path) {\n  using namespace std;\n\n  // search start and goals\n  Point start;\n  vector<Point> goals;\n  for (int y = 0; y < height; ++y) {\n    for (int x = 0; x < width; ++x) {\n      if (room[y][x] == 'o') {\n        start.x = x;\n        start.y = y;\n      } else if (room[y][x] == '*') {\n        goals.push_back(Point(x, y));\n      }\n    }\n  }\n\n  int total_cost = 0;\n  while (!goals.empty()) {\n    // search nearest goal\n    int min_cost = -1;\n    vector<Point> min_path;\n    int goal_index = 0;\n    for (int i = 0; i < goals.size(); ++i) {\n      vector<Point> current_path;\n      const int cost = SearchOne(room, width, height, start, goals[i], &current_path);\n      if (cost == -1) {  // cannot reach goal\n        path->clear();\n        return -1;\n      }\n      if (min_cost == -1 || cost < min_cost) {\n        min_cost = cost;\n        min_path = current_path;\n        goal_index = i;\n      }\n    }\n\n    // update total cost and path\n    total_cost += min_cost;\n    auto min_path_begin = (path->empty()) ? min_path.begin()\n                            : (min_path.empty()) ? min_path.begin()\n                            : min_path.begin() + 1;\n    path->insert(path->end(), min_path_begin, min_path.end());\n\n    // prepare for next\n    start = goals[goal_index];\n    goals.erase(goals.begin() + goal_index);\n  }\n\n  return total_cost;\n}\n\n\nint main() {\n  using namespace std;\n\n  /*\n  const int width = 15;\n  const int height = 13;\n  const vector<string> room = {\n    \".......x.......\",\n    \"...o...x....*..\",\n    \".......x.......\",\n    \".......x.......\",\n    \".......x.......\",\n    \"...............\",\n    \"xxxxx.....xxxxx\",\n    \"...............\",\n    \".......x.......\",\n    \".......x.......\",\n    \".......x.......\",\n    \"..*....x....*..\",\n    \".......x.......\"\n  };\n  */\n\n  while (true) {\n    vector<string> room;\n    int width, height;\n    cin >> width >> height; cin.ignore();\n\n    if (width == 0 && height == 0) break;\n\n    for (int i = 0; i < height; ++i) {\n      string line;\n      getline(cin, line);\n      room.push_back(line);\n    }\n\n    vector<Point> path;\n    cout << Search(room, width, height, &path) << endl;\n  }\n\n  /*\n  if (!path.empty()) {\n    for (Point p : path) {\n      cout << \"(\" << p.x << \",\" << p.y << \")\";\n    }\n    cout << endl;\n  }\n  */\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int, int> P;\nstatic const int MAX_W = 20;\nstatic const int MAX_H = 20;\nstatic const int MAX_V = 10;\nstatic const int INF = 1 << 30;\n\nint w, h;\nchar field[MAX_H][MAX_W + 1];\nint dist[MAX_V + 1][MAX_V + 1], dist2[MAX_H][MAX_W];\nint dy[] = {0, -1, 0, 1};\nint dx[] = {1, 0, -1, 0};\n\nvoid bfs(int s, vector<P> va){\n\tdist[s][s] = 0;\n\tfill(dist2[0], dist2[h], INF);\n\tqueue<P> qa;\n\tqa.push(va[s]);\n\tdist2[va[s].first][va[s].second] = 0;\n\twhile(!qa.empty()){\n\t\tP cc = qa.front(); qa.pop();\n\t\tint cy = cc.first, cx = cc.second;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint ny = cy + dy[i], nx = cx + dx[i];\n\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\tif(field[ny][nx] == 'x') continue;\n\t\t\tif(dist2[ny][nx] != INF) continue;\n\t\t\tqa.push(P(ny, nx));\n\t\t\tdist2[ny][nx] = dist2[cy][cx] + 1;\n\t\t\tif(field[ny][nx] == 'o' || field[ny][nx] == '*'){\n\t\t\t\tfor(int j = 0; j < va.size(); j++){\n\t\t\t\t\tif(ny == va[j].first && nx == va[j].second){\n\t\t\t\t\t\tdist[s][j] = dist2[ny][nx];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\n\nint main(){\n\tfor(;;){\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tif(w == 0 && h == 0) break;\n\t\tvector<P> va;\n\t\tva.push_back(P(0, 0));\n\t\tint cnt = 1;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tscanf(\"%s\", field[i]);\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(field[i][j] == 'o') va[0] = P(i, j);\n\t\t\t\tif(field[i][j] == '*'){\n\t\t\t\t\tva.push_back(P(i, j));\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfill(dist[0], dist[cnt], INF);\n\t\tfor(int i = 0; i < cnt; i++) bfs(i, va);\n\t\tbool flag = true;\n\t\tfor(int i = 0; i < cnt; i++){\n\t\t\tfor(int j = 0; j < cnt; j++){\n\t\t\t\tif(dist[i][j] == INF) flag = false;\n\t\t\t}\n\t\t}\n\t\tvector<int> vb(cnt - 1);\n\t\tfor(int i = 0; i < cnt - 1; i++) vb[i] = i + 1;\n\t\tint res = INF;\n\t\tdo{\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 0; i < vb.size(); i++){\n\t\t\t\tif(i == 0) sum += dist[0][vb[i]];\n\t\t\t\telse sum += dist[vb[i - 1]][vb[i]];\n\t\t\t}\n\t\t\tres = min(res, sum);\n\t\t}while(next_permutation(vb.begin(), vb.end()));\n\t\tprintf(\"%d\\n\", (flag ? res : -1));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n \nconst ll MOD=1e9+7;\nconst ll INF=1e18;\n \nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\n\nint d[12][12];\nint place[12][2];\n\nint main(){\n    int w,h,m[25][25];\n    while(true){\n        cin >> w >> h;\n        int dirt = 0;\n        if(w == 0 && h == 0)break;\n        for(int i = 0;i < 11;i++){\n            for(int j = 0;j < 11;j++){\n                d[i][j] = -1;\n            }\n        }\n        for(int i = 0;i < h;i++){\n            char tmp[25];\n            cin >> tmp;\n            for(int j = 0;j < w;j++){\n                if(tmp[j] == 'o'){\n                    m[i][j] = 0;\n                    place[0][0] = i; place[0][1] = j;\n                }else if(tmp[j] == 'x'){\n                    m[i][j] = -2;\n                }else if(tmp[j] == '*'){\n                    dirt++;\n                    m[i][j] = dirt;\n                    place[dirt][0] = i; place[dirt][1] = j;\n                }else{\n                    m[i][j] = -1;\n                }\n            }\n        }\n        for(int i = 0;i <= dirt;i++){\n            int flag[25][25];\n            bool ch[25][25];\n            for(int i = 0;i < 22;i++){ //init\n                for(int j = 0;j < 22;j++){\n                    flag[i][j] = -1;\n                    ch[i][j] = false;\n                }\n            }\n            flag[place[i][0]][place[i][1]] = 0;\n            queue<P> que;\n            int count = 0;\n            que.push(P(place[i][0],place[i][1]));\n            ch[place[i][0]][place[i][1]] = true;\n            while(!que.empty()){\n                P q = que.front(); que.pop();\n           //     if(ch[q.fs][q.sc] == true)continue;\n           //     ch[q.fs][q.sc] = true;\n                int num = m[q.fs][q.sc];\n                if(num >= 0 && num != i){\n                    d[i][num] = flag[q.fs][q.sc];\n                    count++;\n                    if(count == dirt) break;               \n                }\n                for(int i = 0;i < 4;i++){\n                    int ni = q.fs+dx[i],nj = q.sc+dy[i];\n                    if(ni >= 0 && ni < h && nj >= 0 && nj < w && ch[ni][nj] == false && m[ni][nj] >= -1){\n                        ch[ni][nj] = true;\n                        flag[ni][nj] = flag[q.fs][q.sc] + 1;\n                        que.push(P(ni,nj));\n                    }\n                }\n            }\n        }\n/* \n        for(int i = 0;i <= dirt;i++){\n            for(int j = 0;j <= dirt;j++){\n                cout << d[i][j] << \" \";\n            }\n            cout << endl;\n        }\n*/\n        int ans = 0;\n        for(int i = 1;i <= dirt;i++){\n            if(d[0][i] == -1){\n                ans = -1;\n            }\n        }\n        if(ans == -1){\n            cout << -1 << endl;\n            continue;\n        }\n        vector<int> vec;\n        ans = 10000000;\n        for(int i = 1;i <= dirt;i++){\n            vec.push_back(i);\n        }\n        do{\n            int tmpans = d[0][vec[0]];\n            for(int i = 0;i < dirt-1;i++){\n                tmpans += d[vec[i]][vec[i+1]];\n            }\n            if(ans > tmpans) ans = tmpans;\n        }while(next_permutation(vec.begin(),vec.end()));\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define pb(a) push_back(a)\n#define pr(a) cout<<(a)<<endl\n#define PR(a,b) cout<<(a)<<\" \"<<(b)<<endl\n#define R cin>>\n#define F first\n#define S second\n#define ll long long\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nstring s[30];\nint c[30][30];\nvector<P> v;\nint d[30][30];\nint n,m;\n\nvoid bfs(int k) {\n  fill(d[0],d[30],MAX);\n  d[v[k].F][v[k].S]=0;\n  queue<P> que;\n  que.push(v[k]);\n  while(!que.empty()) {\n    P p=que.front();que.pop();\n    int nx=p.F,ny=p.S;\n    rep(i,v.size()) {\n      if(v[i].F==nx && v[i].S==ny) {\n\tc[k][i]=d[nx][ny];\n\tc[i][k]=d[nx][ny];\n      }\n    }\n    rep(i,4) {\n      int x=nx+dx[i],y=ny+dy[i];\n      if(!check(n,m,x,y) || s[x][y]=='x' || d[x][y]<=d[nx][ny]+1) continue;\n      d[x][y]=d[nx][ny]+1;\n      que.push(P(x,y));\n    }\n  }\n}\n  \nint main() {\n  while(cin >> m >> n && n) {\n    fill(c[0],c[30],MAX);\n    v.clear();\n    int sx,sy;\n    rep(i,n) {\n      R s[i];\n      rep(j,m) {\n\tif(s[i][j]=='*') v.pb(P(i,j));\n\tif(s[i][j]=='o') sx=i,sy=j;\n      }\n    }\n    v.pb(P(sx,sy));\n    rep(i,v.size()) bfs(i);\n    int k=v.size()-1;\n    int dp[1<<k][k];\n    fill(dp[0],dp[1<<k],MAX);\n    rep(i,k) dp[1<<i][i]=c[i][k];\n    REP(t,1,1<<k) {\n      rep(i,k) {\n\trep(j,k) {\n\t  if(!(t&(1<<k)))dp[t|(1<<j)][j]=min(dp[t|(1<<j)][j],dp[t][i]+c[i][j]);\n\t}\n      }\n    }\n    int ans=MAX;\n    rep(i,k) ans=min(ans,dp[(1<<k)-1][i]);\n    if(ans==MAX) ans=-1;\n    pr(ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<iomanip>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\n#define MAX 1024\n#define N 10\n#define SIZE 22\n\n#define NONE 0\n#define START 1\n#define DIRTY_TILE 2\n#define FURNITURE 3\n\n#define INFTY 1<<16\n\nvoid bfs(int sti, int stj, int map[SIZE][SIZE], int cost_map[SIZE][SIZE]){\n\tconst int di[] = {-1,0,1,0};\n\tconst int dj[] = {0,1,0,-1};\n\tbool vis[SIZE][SIZE]={{false,},};\n\tqueue< pair<int,int> > q;\n\n\tfor(int i = 0; i < SIZE; ++i){\n\t\tfor(int j = 0; j < SIZE; ++j){\n\t\t\tcost_map[i][j] = INFTY;\n\t\t}\n\t}\n\n\tq.push( make_pair(sti,stj) );\n\tcost_map[sti][stj]=0;\n\tvis[sti][stj]=true;\n\twhile(!q.empty()){\n\t\tpair<int,int> t = q.front();\n\t\tq.pop();\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\tint ti = t.first + di[k];\n\t\t\tint tj = t.second + dj[k];\n\t\t\tif( map[ti][tj] != FURNITURE && !vis[ti][tj] ){\n\t\t\t\tcost_map[ti][tj] = cost_map[t.first][t.second] + 1;\n\t\t\t\tvis[ti][tj]=true;\n\t\t\t\tq.push( make_pair(ti,tj) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dp(int n, int ini_cost[N], int cost[N][N] ){\n\tint ret=INFTY;\n\tint w[MAX][N];\n\n\tfor(int state=0;state<(1<<n);++state){\n\t\tfor(int i=0;i<n;++i){\n\t\t\tw[state][i]=INFTY;\n\t\t}\n\t}\n\n\tfor(int i=0;i<n;++i){\n\t\tw[0][i]=ini_cost[i];\n\t}\n\n\tfor(int state=1;state<(1<<n);++state){\n\t\tfor(int i=0;i<n;++i){\n\t\t\tif(!(state&(1<<i))){\n\t\t\t\tfor(int j=0;j<n;++j){\n\t\t\t\t\tif(state&(1<<j)){\n\t\t\t\t\t\tint pre_state=state^(1<<j);\n\t\t\t\t\t\tw[state][i]=min(w[state][i],w[pre_state][j]+cost[j][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cout<<w[state][i]<<endl;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=0;i<n;++i){\n\t\tret=min(ret,w[((1<<n)-1)^(1<<i)][i]);\n\t}\n\n\treturn ret;\n}\n\nint CleaningRobot(int h, int w, int map[SIZE][SIZE]){\n\tint cost[N][N];\n\tint ini_cost[N];\n\tint cost_map[SIZE][SIZE];\n\tvector< pair<int, int> > vtiles;\n\n\tfor(int i = 1; i <= h; ++i){\n\t\tfor(int j = 1; j <= w; ++j){\n\t\t\tif( map[i][j] == DIRTY_TILE ){\n\t\t\t\tvtiles.push_back( make_pair( i, j ) );\n\t\t\t}\n\t\t\tif( map[i][j] == START ){\n\t\t\t\tbfs(i,j,map,cost_map);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(unsigned int i = 0; i < vtiles.size(); ++i){\n\t\tini_cost[i]=cost_map[vtiles[i].first][vtiles[i].second];\n\t}\n\n\tfor(unsigned int i = 0; i < vtiles.size(); ++i){\n\t\tbfs(vtiles[i].first,vtiles[i].second,map,cost_map);\n\t\t\n\t\t/*for(int k = 1; k <= h; ++k){\n\t\t\tfor(int l = 1; l <= w; ++l){\n\t\t\t\tcout << setw(4) << cost_map[k][l];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\n\t\tfor(unsigned int j = 0; j < vtiles.size(); ++j){\n\t\t\tcost[i][j] = cost[j][i] = cost_map[vtiles[j].first][vtiles[j].second];\n\t\t\tif(cost[i][j]>=INFTY)return -1;\n\t\t}\n\t}\n\n\tint ret = dp(vtiles.size(),ini_cost,cost);\n\treturn ret>=INFTY?-1:ret;\n}\n\nint main(){\n\twhile(true){\n\t\tint h,w;\n\t\tint map[SIZE][SIZE];\n\t\tcin>>w>>h;\n\t\tif(h==0&&w==0)break;\n\t\tfor(int i=0;i<SIZE;++i){\n\t\t\tfor(int j=0;j<SIZE;++j){\n\t\t\t\tmap[i][j]=FURNITURE;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=h;++i){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tfor(unsigned int j=0;j<s.length();++j){\n\t\t\t\tswitch(s[j]){\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tmap[i][j+1]=NONE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'x':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'o':\n\t\t\t\t\t\tmap[i][j+1]=START;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\tmap[i][j+1]=DIRTY_TILE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << CleaningRobot(h,w,map) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n#define all(c) (c).begin(), (c).end()\nint const inf = 1 << 29;\n\nint main(){\n    int w, h;\n    while (cin >> w >> h && w | h){\n        vector<string> grid(h);\n        vector<pair<int,int>> node;\n        rep(i, h){\n            cin >> grid[i];\n            rep(j, grid[i].size())if (grid[i][j] == 'o')node.emplace_back(i, j);\n        }\n        rep(i, h)rep(j, w){\n            if (grid[i][j] == '*')node.emplace_back(i, j);\n        }\n\n        static int d[20][20];\n        rep(i, 20)rep(j, 20)d[i][j] = inf;\n\n        rep(i, node.size()){\n            int dx[] = { 1, 0, -1, 0 }, dy[] = { 0, 1, 0, -1 };\n            queue<pair<int, int>> q;\n            static int dist[25][25];\n            rep(j, h)rep(k, w)dist[j][k] = inf;\n            dist[node[i].first][node[i].second] = 0;\n            q.emplace(node[i]);\n\n            while (q.size()){\n                auto p = q.front(); q.pop();\n                int cx = p.second, cy = p.first;\n                rep(j, 4){\n                    int nx = cx + dx[j], ny = cy + dy[j];\n                    if (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n                    if (grid[ny][nx] == 'x') continue;\n                    if (dist[ny][nx] > dist[cy][cx] + 1){\n                        dist[ny][nx] = dist[cy][cx] + 1;\n                        q.emplace(ny, nx);\n                    }\n                }\n            }\n\n            rep(j, node.size()){\n                d[i][j] = dist[node[j].first][node[j].second];\n            }\n        }\n\n        int idx[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n        long long ans = inf;\n        do{\n            long long t = 0;\n            rep(i, node.size() - 1){\n                t += d[idx[i]][idx[i + 1]];\n            }\n            ans = min(t, ans);\n        } while (next_permutation(idx + 1, idx + node.size()));\n        if (ans >= inf)ans = -1;\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\n\nclass Point{\npublic:\n  int x,y,g,c;\n};\n\nint main(){\n  int i,j,h,w,sum,ans,now;\n  bool gomi[20][20],f[11][20][20];\n  string str;\n  while(1){\n    Point u,v;\n    queue <Point> Q;\n    cin >> w >> h;\n    if(h == 0 && w == 0) break;\n    ans = -1;\n    sum = 0;\n    for(i=0;i<h;i++){\n      cin >> str;\n      for(j=0;j<w;j++){\n\tgomi[i][j] = false;\n\tfor(int k=0;k<11;k++) f[k][i][j] = false;\n\tif(str[j] == 'o'){\n\t  u.y = i;\n\t  u.x = j;\n\t}\n\telse if(str[j] == 'x'){\n\t  for(int k=0;k<11;k++) f[k][i][j] = true;\n\t}\n\telse if(str[j] == '*'){\n\t  gomi[i][j] = true;\n\t  sum++;\n\t}\n      }\n    }\n\n    now = 0;\n    u.g = 0;\n    u.c = 0;\n    Q.push(u);\n    while(!Q.empty()){\n      u = Q.front();\n      Q.pop();\n      if(u.g < now) continue;\n\n      f[u.g][u.y][u.x] = true;\n\n      if(gomi[u.y][u.x]){\n\tgomi[u.y][u.x] = false;\n\tu.g++;\n\tnow++;\n      }\n\n      if(u.g == sum){\n\tans = u.c;\n\tbreak;\n      }\n\n      u.c++;\n      f[u.g][u.y][u.x] = true;\n      int dx[4] = {1,0,-1,0};\n      int dy[4] = {0,1,0,-1};\n      for(i=0;i<4;i++){\n\tv = u;\n\tv.x += dx[i];\n\tv.y += dy[i];\n\tif(!f[v.g][v.y][v.x] && v.x >= 0 && v.x < w && v.y >= 0 && v.y < h){\n\t    Q.push(v);\n\t  }\n       }\n    }\n    cout << ans << endl;\n      \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 20\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\nint w,h,num[N*N+N],idlen,sid,ans;\nstring s[N];\nvector<int> id;\nvector<P> edge[11];\n\nint bfs(int sy,int sx,int gy,int gx){\n  int d[N][N];\n  int dy[4]={-1,0,1,0};\n  int dx[4]={0,1,0,-1};\n  queue<P1> q;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)d[i][j]=INF;\n  d[sy][sx]=0;\n  q.push(P1(0,P(sy,sx)));\n  while(!q.empty()){\n    P1 t=q.front(); q.pop();\n    int c=t.first;\n    int y=t.second.first,x=t.second.second;\n    if(d[y][x]<c)continue;\n    for(int i=0;i<4;i++){\n      int ny=y+dy[i],nx=x+dx[i];\n      if(ny<0||nx<0||h<=ny||w<=nx)continue;\n      if(s[ny][nx]=='x')continue;\n      if(d[ny][nx]>c+1){\n\td[ny][nx]=c+1;\n\tq.push(P1(d[ny][nx],P(ny,nx)));\n      }\n    }\n  }\n  return d[gy][gx];\n}\n\nint dijkstra(){\n  int d[(1<<idlen)];\n  priority_queue<P1> q;\n  for(int i=0;i<(1<<idlen);i++)d[i]=INF;\n  d[(1<<sid)]=0;\n  q.push(P1(0,P((1<<sid),sid)));\n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    int S=t.second.first;\n    int c=t.first,u=t.second.second;\n    if(d[S]<c)continue;\n    for(int i=0;i<edge[u].size();i++){\n      int nu=edge[u][i].first;\n      int nc=edge[u][i].second;\n      if((S&(1<<nu)))continue;\n      if(d[(S|(1<<nu))]>c+nc){\n\td[(S|(1<<nu))]=c+nc;\n\tq.push(P1(c+nc,P((S|(1<<nu)),nu)));\n      }\n    }\n  }\n  return d[(1<<idlen)-1];\n}\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h)break;\n    for(int i=0;i<h;i++){\n      cin>>s[i];\n      for(int j=0;j<w;j++){\n\tif(s[i][j]=='.'||s[i][j]=='x')continue;\n\tif(s[i][j]=='o')s[i][j]='.',sid=id.size();\n\tid.push_back(w*i+j);\n      }\n    }\n    idlen=id.size();\n    for(int i=0;i<idlen;i++)\n      for(int j=0;j<idlen;j++){\n\tif(i==j)continue;\n\tint y1=id[i]/w,x1=id[i]%w;\n\tint y2=id[j]/w,x2=id[j]%w;\n\tint d=bfs(y1,x1,y2,x2);\n\tedge[i].push_back(P(j,d));\n\tedge[j].push_back(P(i,d));\n      }\n    ans=dijkstra();\n    if(ans!=INF)cout<<ans<<endl;\n    else cout<<-1<<endl;\n    id.clear();\n    for(int i=0;i<11;i++)edge[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cstring>\n#include<map>\nusing namespace std;\nint main()\n{\n  int w,h;\n  for(;cin>>w>>h,w;)\n    {\n      char maps[h][w];\n      vector<pair<int,int> > dast;\n      int sx,sy;\n      for(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\t  {\n\t    cin>>maps[i][j];\n\t    if(maps[i][j]=='*')\n\t      {\n\t\tdast.push_back(make_pair(i,j));\n\t      }\n\t    else if(maps[i][j]=='o')\n\t      {\n\t\tsx=i;\n\t\tsy=j;\n\t      }\n\t  }\n      //now,bit;\n      map<pair<pair<int,int>,int>,bool >hash;\n      //now, bit,cnt;\n      queue<pair< pair<int,int>,pair<int,int> > >qu;\n      qu.push(make_pair(make_pair(sx,sy),make_pair(0,0)));\n      int ans=-1;\n      int size=dast.size();\n      int dx[]={1,-1,0,0};\n      int dy[]={0,0,1,-1};\n      //cout<<\"lastbit:\"<<((1<<(size))-1)<<endl;\n      //      qu.pop();\n      while(!qu.empty())\n\t{\n\t  pair<int,int> now=qu.front().first;\n\t  int x=now.first;\n\t  int y=now.second;\n\t  int bit=qu.front().second.first;\n\t  int cnt=qu.front().second.second;\n\t  qu.pop();\n\t  //\t  cout<<\"now: \"<<x<<\" \"<<y<<\" \"<<bit<<\" \"<<cnt<<endl;\n\t  if(maps[x][y]=='*')\n\t    {\n\t      for(int i=0;i<size;i++)\n\t\t{\n\t\t  if(x==dast[i].first &&y==dast[i].second )\n\t\t    bit=bit|(1<<i);\n\t\t}\n\t    }\n\t  if(bit==(1<<size)-1)\n\t    {\n\t      ans=cnt;\n\t      break;\n\t    }\n\t  if(hash.count(make_pair(now,bit))!=0)\n\t    continue;\n\t  hash[make_pair(now,bit)]=true;\n\t  for(int i=0;i<4;i++)\n\t    {\n\t      if(x+dx[i]>=0 &&x+dx[i]<h &&\n\t\t y+dy[i]>=0 &&y+dy[i]<w &&\n\t\t maps[x+dx[i]][y+dy[i]]!='x' &&\n\t\t hash.count(make_pair(make_pair(x+dx[i],y+dy[i]),bit))==0\n\t\t )\n\t\tqu.push(make_pair(make_pair(x+dx[i],y+dy[i]),make_pair(bit,cnt+1)));\n\n\t    }\n\t}\n      cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*********************\nAOJ_1140\nCleaning Robot\n*********************/\n#include <iostream>\n#include <queue>\n#include <string>\n#include <string>\nusing namespace std;\n\n//構造体宣言\nstruct pos{\n\tint x;\t\t//座標\n\tint y;\t\t\n\tint dis;\t//距離\n};\n\nint main(){\n\tint w, h;\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 || h == 0) break;\n\n\t\t//タイルの初期化\n\t\tchar tile[30][30];\n\t\tfor(int i = 0; i < 30; i ++){\n\t\t\tfor(int j = 0; j < 30; j++){\n\t\t\t\ttile[i][j] = 'x';\n\t\t\t}\n\t\t}\n\t\t//タイルの入力\n\t\tint stain = 0;\t//汚れの数\n\t\tqueue<pos> que;\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tstring input;\n\t\t\tcin >> input;\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\ttile[i][j] = input[j-1];\n\t\t\t\tif(tile[i][j] == '*') stain++;\n\t\t\t\tif(tile[i][j] == 'o'){\n\t\t\t\t\tpos p;\n\t\t\t\t\tp.y = i; p.x = j;\n\t\t\t\t\tp.dis = 0;\n\t\t\t\t\tque.push(p);\n\t\t\t\t\ttile[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint count = 0;\n\t\twhile(stain > 0){\n\t\t\tchar bfs[30][30];\n\t\t\tmemcpy(bfs, tile, sizeof(bfs));\n\t\t\tpos p = que.front();\n\t\t\tbfs[p.y][p.x] = 0;\n\t\t\tint x1[] = {-1, 0, 1, 0}, y1[] = {0, -1, 0, 1};\n\t\t\tint f = 1;\n\t\t\twhile(f && !que.empty()){\n\t\t\t\tpos p1 = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tp = p1;\n\t\t\t\t\tp.x += x1[i]; p.y += y1[i];\n \t\t\t\t\tif(bfs[p.y][p.x] == '.'){\n\t\t\t\t\t\tp.dis++;\n\t\t\t\t\t\tbfs[p.y][p.x] = p.dis;\n\t\t\t\t\t\tque.push(p);\n\t\t\t\t\t}else if(bfs[p.y][p.x] == '*'){\n\t\t\t\t\t\tcount += p.dis+1;\n\t\t\t\t\t\tstain--;\n\t\t\t\t\t\ttile[p.y][p.x] == '.';\n\t\t\t\t\t\twhile(!que.empty()) que.pop();\n\t\t\t\t\t\tp.dis = 0;\n\t\t\t\t\t\tque.push(p);\n\t\t\t\t\t\tf = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(que.empty()) break;\n\t\t}\n\n\t\tif(stain > 0) cout << \"-1\" << endl;\n\t\telse cout << count << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nconst double pi = 3.141592653589793238462643383279;\nusing namespace std;\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n \n \n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n \n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n \n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n \n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n\n//ここから編集 \n\nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK) \ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n \n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m) {\n    long long x, y;\n    extGCD(a, m, x, y);\n    return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nint dxy[5] = {-1,0,1,0,-1};\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  int w, h;\n  while(cin >> w >> h, w || h){\n    vector<string> v;\n    vector<pair<int, int>> p;\n    map<pair<int, int>, int> mp;\n    int cnt = 0;\n    int sx, sy;\n    for(int i=0; i<h; i++){\n      string s; cin >> s;\n      v.push_back(s);\n\n      for(int j=0; j<w; j++){\n        if(s[j] == 'o'){\n          sy = i;\n          sx = j;\n        }\n      }\n    }\n    mp[make_pair(sy, sx)] = cnt++;\n\n    p.emplace_back(sy,sx);\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n        if(v[i][j] == '*'){\n          p.emplace_back(i, j);\n\n          mp[make_pair(i, j)] = cnt++;\n        }\n      }\n    }\n    vector<vector<pair<int, int>>> g(p.size());\n    bool f = true;\n    for(int i=0; i<p.size(); i++){\n      queue<int> q;\n      vector<int> dist(h*w, INT_MAX);\n      int y = p[i].first, x = p[i].second;\n      dist[y*w + x] = 0;\n      q.push(y*w + x);\n      while(q.size()){\n        int vv = q.front();\n        q.pop();\n\n        int yy = vv/w, xx = vv%w;\n\n        for(int i=0; i<4; i++){\n          int ny = yy + dxy[i], nx = xx + dxy[i+1];\n\n          if(ny >= 0 && ny < h && nx >= 0 && nx < w && dist[ny*w+nx] == INT_MAX && v[ny][nx] != 'x'){\n            dist[ny*w + nx] = dist[yy*w+xx] + 1;\n            q.push(ny*w + nx);\n          }\n        }\n      }\n\n      for(int j=0; j<p.size(); j++){\n        int yy = p[j].first, xx = p[j].second;\n        if(dist[yy*w+xx] == INT_MAX){\n          f = false;\n        }else{\n          g[i].push_back(make_pair(j, dist[yy*w+xx]));\n        }\n      }\n    }\n\n    if(!f) {\n      cout << -1 << endl;\n      continue;\n    }\n\n    vector<vector<ll>> dp(1<<p.size(), vector<ll>(p.size(), INT_MAX));\n    dp[(1<<0)][0] = 0;\n    for(int i=0; i<p.size(); i++){\n      int v = g[0][i].first;\n      int cost = g[0][i].second;\n      dp[(1<<i) | (1<<0)][i] = cost;\n    }\n\n    for(int bit=0; bit < (1<<p.size()); bit++){\n\n      for(int i=0; i<p.size(); i++){\n\n\n        if(bit >> i & 1){\n\n          for(int j=0; j<p.size(); j++){\n            if(!(bit >> j & 1)){\n              \n              dp[bit | (1 << j)][j] = min(dp[bit | (1 << j)][j], dp[bit][i] + g[i][j].second);\n            }\n          }\n        }\n      }\n    }\n\n    ll ans = INT_MAX;\n    for(int i=0; i<p.size(); i++){\n      ans = min(ans, dp[(1<<p.size())-1][i]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cassert>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int MAX = 21;\nconst int TM = 11;\nconst int INF = (1<<25);\n\nchar F[MAX][MAX];\nint T[(1<<TM)][MAX][MAX];\nint w,h,sx,sy;\nvector<P> Trash;\n\n\nstruct State{\n  int x,y,t,come;\n  \n  State(){}\n  State(int x, int y, int t, int c):x(x),y(y),t(t),come(c){}\n  bool operator < (const State& s) const { return t > s.t;}\n\n};\n\nbool isInside(int x, int y){ return 0<=x&&x<w&&0<=y&&y<h;}\n\nvoid init(){\n  \n  fill(T[0][0],T[0][0]+TM*MAX*MAX,INF);\n  Trash.clear();\n\n}\n\nvoid input(){\n  for(int i = 0; i < h; i++)\n    for(int j = 0; j < w; j++){\n      cin >> F[i][j];\n      if(F[i][j] == 'o'){\n\tsx = j;\n\tsy = i;\n      }\n      if(F[i][j] == '*') Trash.push_back(P(j,i));\n\n    }\n}\n\nint getTrashNum(P p){\n  for(int i = 0; i < Trash.size(); i++)\n    if(Trash[i] == p) return i;\n  \n  cerr << \"not found\" << endl;\n  return -1;\n}\nvoid solve(){\n\n  priority_queue<State> Q;\n  Q.push(State(sx,sy,0,0));\n  T[0][sy][sx] = 0;\n\n  int dx[] = {0,0,1,-1};\n  int dy[] = {1,-1,0,0};\n\n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n\n    if(T[now.come][now.y][now.x] < now.t) continue;\n    \n    for(int i = 0; i < 4; i++){\n      State nex = now;\n      nex.x += dx[i];\n      nex.y += dy[i];\n      nex.t++;\n\n      if(!isInside(nex.x,nex.y)) continue;\n      if(F[nex.y][nex.x] == 'x') continue;\n\n\n      if(F[nex.y][nex.x] == '*'){\n\tint Tnum = getTrashNum(P(nex.x, nex.y));\n\tnex.come = (nex.come|(1<<Tnum));\n      }\n\n      \n      if(T[nex.come][nex.y][nex.x] > nex.t){\n\tT[nex.come][nex.y][nex.x] = nex.t;\n\tQ.push(nex);\n      }\n    }\n  }\n\n  int ans = INF;\n\n  for(int i = 0; i < Trash.size(); i++)\n    ans = min(ans,T[(1<<Trash.size())-1][Trash[i].second][Trash[i].first]);\n\n  if(ans == INF) cout << \"-1\" << endl;\n  else cout << ans << endl;\n \n}\n  \nint main(){\n\n  while(cin >> w >> h && w+h){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define REPR(i,n) for(int i=(n)-1;i>=0;i--)\n#define FOR(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(x) x.begin(),x.end()\n#define ll long long\ntypedef pair<int,int> pii;\n\nint W,H;\nchar A[22][22];\nint dist[404][404];\n\nconst int dx[4]={0,0,-1,1},dy[4]={1,-1,0,0};\nvoid solve(){\n\tcin>>W>>H;\n\tif(W==0)exit(0);\n\tint sx=0,sy=0;\n\tvector<int>ps;\n\tREP(i,H){\n\t\tREP(j,W){\n\t\t\tcin>>A[i][j];\n\t\t\tif(A[i][j]=='o'){\n\t\t\t\tsx=i,sy=j;\n\t\t\t}\n\t\t\tif(A[i][j]=='*'){\n\t\t\t\tps.push_back(i*W+j);\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,H)REP(j,W){\n\t\tREP(x,H)REP(y,W){\n\t\t\tdist[i*W+j][x*W+y]=1e9;\n\t\t}\n\t}\n\tREP(i,H)REP(j,W){\n\t\tdist[i*W+j][i*W+j]=0;\n\t}\n\tREP(i,H){\n\t\tREP(j,W){\n\t\t\tif(A[i][j]=='x')continue;\n\t\t\tREP(k,4){\n\t\t\t\tint x=i+dx[k];\n\t\t\t\tint y=j+dy[k];\n\t\t\t\tif(x>=0&&x<H&&y>=0&&y<W&&A[x][y]!='x'){\n\t\t\t\t\tdist[i*W+j][x*W+y]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k,H*W){\n\t\tREP(i,H*W){\n\t\t\tREP(j,H*W){\n\t\t\t\tdist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint M=ps.size();\n\tint perm[10];\n\tREP(i,M)perm[i]=i;\n\tll ans = 1e9;\n\tREP(i,M){\n\t\tif(dist[sx*W+sy][ps[i]]>=1e9){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tdo{\n\t\tll res = 0;\n\t\tres+=dist[sx*W+sy][ps[perm[0]]];\n\t\tREP(i,M-1){\n\t\t\tres+=dist[ps[perm[i]]][ps[perm[i+1]]];\n\t\t\tif(res>=ans)break;\n\t\t} \n\t\tans=min(ans,res);\n\t}while(next_permutation(perm,perm+M));\n\tif(ans<1e9){\n\t\tcout<<ans<<endl;\n\t}\n\telse{\n\t\tcout<<-1<<endl;\n\t}\n}\n\nsigned main() {\n\t//test();\n\twhile(true)solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int MAX_W = 20;\nconst int MAX_H = 20;\nconst int MAX_N = 10;\nconst int INF  = 1e+8;\n\nint w, h;\nint dx[4] = {0,0,1,-1};\nint dy[4] = {1,-1,0,0};\nint d[MAX_H][MAX_W];\nint g[MAX_N][MAX_N];\nint ans;\n\nvoid debug(int n){\n\tcout << \"[debug]\" << endl;\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\tif( g[i][j] == INF )\n\t\t\t\tcout << -1 << \"  \";\n\t\t\telse\n\t\t\t\tcout << g[i][j] << \"  \";\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\nvoid init(){\n\tfor(int i = 0 ; i < MAX_N ; i++ ){\n\t\tfor(int j = 0 ; j < MAX_N ; j++ ){\n\t\t\tg[i][j] = INF;\n\t\t}\n\t}\n}\n\nvoid clear_d(){\n\tfor(int y=0 ; y < MAX_H ; y++ ){\n\t\tfor(int x= 0 ; x < MAX_W ; x++ ){\n\t\t\td[y][x] = INF;\n\t\t}\n\t}\n}\n\n// 文字 c がある座標の位置を求める\nvoid search(const vector<string>& m, vector<P>& vp, char c){\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( m[y][x] == c ){\n\t\t\t\tvp.push_back( P(x,y) );\n\t\t\t}\n\t\t}\n\t}\n}\n\n// spから汚れたタイルまでの距離を調べる\nvoid bfs(const vector<string>& m, P sp, map<P,int> f){\n\td[sp.second][sp.first] = 0;\n\tqueue<P> q;\n\tq.push( sp );\n\twhile( !q.empty() ){\n\t\tP p = q.front(); q.pop();\n\t\tint cnt = d[p.second][p.first];\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx = p.first + dx[i];\n\t\t\tint my = p.second + dy[i];\n\t\t\tif( mx < 0 || my < 0 || mx >= w || my >= h || m[my][mx] == 'x' ){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( d[my][mx] == INF ){\n\t\t\t\tif( m[my][mx] == '*' ){\n\t\t\t\t\tint u = f[sp];\n\t\t\t\t\tint v = f[P(mx,my)];\n\t\t\t\t\tg[u][v] = g[v][u] = cnt + 1;\n\t\t\t\t} \n\t\t\t\td[my][mx] = cnt + 1;\n\t\t\t\tq.push( P(mx,my) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(int N, int v, int cnt, int sum, map<int,bool> memo){\n\tif( N == cnt ){\n\t\tans = min( ans , sum );\n\t\treturn ;\n\t}\n\tfor(int u=1 ; u < N ; u++ ){\n\t\tif( u == v ) continue;\n\t\tif( !memo[u] ){\n\t\t\tmemo[u] = true;\n\t\t\tdfs( N , u , cnt+1 , sum+g[v][u] , memo );\n\t\t\tmemo[u] = false;\n\t\t}\n\t}\n}\n\nint main(){\n\twhile( cin >> w >> h , w || h ){\n\t\t// 初期化\n\t\tinit();\n\t\t// m[y][x] := (x,y)の状態\n\t\tvector<string> m(h);\n\t\t// vp[i] := i 番目の汚れたタイルの座標 (i=0 はスタート地点)\n\t\tvector<P> vp;\n\t\t// f[p] := 座標 p と対応する i を返す (i番目の汚れたタイル)\n\t\tmap<P,int> f;\n\t\t\n\t\t// 入力\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> m[y];\n\t\t}\n\t\t// スタート地点と汚れたタイルの位置を調べる\n\t\tsearch( m , vp , 'o' );\n\t\tsearch( m , vp , '*' );\n\t\tfor(int i=0 ; i < vp.size() ; i++ ){\n\t\t\tf[ vp[i] ] = i;\n\t\t}\n\t\t// 各汚れたタイル同士の距離を調べる\n\t\tfor(int i=0 ; i < vp.size() ; i++ ){\n\t\t\tclear_d();\n\t\t\tbfs( m , vp[i] , f );\n\t\t}\n\t\t//debug( vp.size() );\n\t\t\n\t\t// 最短距離を求める\n\t\tmap<int,bool> memo;\n\t\tfor(int i=1 ; i < vp.size() ; i++ )\n\t\t\tmemo[i] = false;\n\t\tmemo[0] = true;\n\t\tans = INF;\n\t\tdfs( vp.size() , 0 , 1 , 0 , memo );\n\t\tif( ans == INF )\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nmap<P,int> ids;\ntemplate<class T>\nbool chmin(T &a,const T& b) {\n    if(a>b) {\n        a=b;\n        return true;\n    }\n    return false;\n}\n\nint w,h;\nstring room[21];\nint dist[10][10];\nint to_id(P p) {\n    if(!ids.count(p)) ids[p]=ids.size();\n\n    return ids[p];\n}\n\nvoid bfs(P p) {\n    int d[21][21];\n    rep(i,21) rep(j,21) d[i][j]=INF;\n    int s=to_id(p);\n    queue<P> que;\n    que.push(p);\n    d[p.fr][p.sc]=0;\n\n    while(que.size()) {\n        int y=que.front().fr;\n        int x=que.front().sc;\n        que.pop();\n        rep(i,4) {\n            int ny=y+dy[i];\n            int nx=x+dx[i];\n            if(ny<0||nx<0) continue;\n            if(h<=ny||w<=nx) continue;\n            if(d[ny][nx]!=INF) continue;\n            if(room[ny][nx]=='x') continue;\n\n            if(chmin(d[ny][nx],d[y][x]+1)) {\n                if(room[ny][nx]=='*') {\n                    //printf(\"%d,%d -> %d,%d : %d\\n\",p.fr,p.sc,ny,nx,d[ny][nx]);\n                    dist[s][to_id(P(ny,nx))]=d[ny][nx];\n                    dist[to_id(P(ny,nx))][s]=d[ny][nx];\n                }\n                que.push(P(ny,nx));\n            }\n        }\n    }\n}\n\nvoid solve() {\n    ids.clear();\n    P s;\n    vector<P> vec;\n    rep(i,10) rep(j,10) dist[i][j]=INF;\n    rep(y,h) cin>>room[y];\n    rep(y,h) rep(x,w) {\n        if(room[y][x]=='*') {\n            vec.pb(P(y,x));\n            bfs(P(y,x));\n        }\n        if(room[y][x]=='o') {\n            s=P(y,x);\n            bfs(s);\n        }\n    }\n    sort(all(vec));\n\n    int ans=INF;\n    do {\n        int t=dist[to_id(s)][to_id(vec[0])];\n        rep(i,vec.size()) if(i) t+=dist[to_id(vec[i-1])][to_id(vec[i])];\n        chmin(ans,t);\n    }while(next_permutation(all(vec)));\n\n    if(ans==INF) ans=-1;\n\n    cout<<ans<<endl;\n}\nint main() {\n    while(cin>>w>>h) {\n        if(!w) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#ifndef M_PI\n#define M_PI 3.1415926535897932384626433832795\n#endif\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\n\nbool vis[20][20][1<<10];\n\ntypedef struct{\n  int x,y;\n  int vis;\n  int cost;\n}state;\n\nchar in[22][22];\nint durty[22][22];\n\nmain(){\n  int w,h;\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    int sx,sy;\n    int num=0;\n    \n    rep(i,h){\n      scanf(\"%s\",in[i]);\n      rep(j,w){\n\tif(in[i][j]=='o'){\n\t  sx=i;\n\t  sy=j;\n\t  in[i][j]='.';\n\t}else if(in[i][j]=='*'){\n\t  durty[i][j]=num++;\n\t}\n      }\n    }\n\n    memset(vis,0,sizeof(vis));\n\n    queue<state> Q;\n    state st={sx,sy,0,0};\n    Q.push(st);\n    int ans=-1;\n\n    while(!Q.empty()){\n      int cx=Q.front().x,cy=Q.front().y,cvis=Q.front().vis,cc=Q.front().cost;\n      Q.pop();\n\n      if(vis[cx][cy][cvis])continue;\n      vis[cx][cy][cvis]=true;\n\n      if(cvis==(1<<num)-1){\n\tans=cc;\n\tbreak;\n      }\n\n      rep(i,4){\n\tint nx=cx+dx[i],ny=cy+dy[i];\n\tif(nx<0 || h<=nx || ny<0 || w<=ny || in[nx][ny]=='x')continue;\n\tint nvis=cvis;\n\tif(in[nx][ny]=='*')nvis|=1<<durty[nx][ny];\n\tif(vis[nx][ny][nvis])continue;\n\tst.x=nx;\n\tst.y=ny;\n\tst.vis=nvis;\n\tst.cost=cc+1;\n\tQ.push(st);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (int)(999999999/2)\n#define eps 1e-9\n#define MAX_N 5000\nint w,h;\nint fie[30][30];\nstring data[30];\n\n\nvoid bfs(int yy,int xx){\n    int dx[]={0,1,0,-1};\n    int dy[]={1,0,-1,0};\n    queue<pii> que;\n    que.push(pii(yy,xx));\n    \n    bool used[30][30]={};\n    while(que.size()){\n        int y=que.front().first,x=que.front().second;\n        que.pop();\n        used[y][x]=true;\n        rep(i,4){\n            int ddy=y+dy[i],ddx=x+dx[i];\n            if(ddy<0||ddx<0||ddy>=h||ddx>=w||data[ddy][ddx]=='x'||used[ddy][ddx])continue;\n            fie[ddy][ddx]=fie[y][x]+1;\n            que.push(pii(ddy,ddx));\n        }\n    }\n}\n\nint main(){\n    while(cin>>w>>h&&w&&h){\n        int v=0;\n        rep(i,h){\n            cin>>data[i];\n        }\n        \n        vector<pii> p;\n        rep(i,h)rep(j,w)if(data[i][j]=='o'){p.pb(pii(i,j));v++;}\n        rep(i,h)rep(j,w)if(data[i][j]=='*'){p.pb(pii(i,j));v++;}\n\n        map<  pair<pii,pii> , int  > pass;\n        rep(i,p.size()){\n            rep(j,30)rep(k,30)fie[j][k]=INF;\n            fie[p[i].first][p[i].second]=0;\n            bfs(p[i].first,p[i].second);\n            rep(j,p.size()){\n                pass[make_pair(p[i],p[j])]=fie[p[j].first][p[j].second];\n            }\n        }\n        \n        vector<int> num;\n        rep(i,v)num.pb(i);\n        sort(all(num));\n        int mini=INF;\n        do{\n            if(num[0]!=0)continue;\n            int sum=0;\n            rep(i,v-1){\n                sum+=pass[  make_pair(p[num[i]],p[num[i+1]])  ];\n            }\n            mini=min(mini,sum);\n        }while(next_permutation(all(num)));\n        if(mini==INF)cout<<\"-1\"<<endl;\n        else cout<<mini<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\n#define mkp make_pair\ntypedef long long ll;\nusing namespace std;\n\nint H,W;\nchar C[22][22];\n\nmap<int,pair<int,int>> mp;\nint stx,sty;\nvector<pair<int,int>> v;\n\nint dist[12][22][22];\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nvoid bfs(){\n    for(int i=0;i<=v.size();i++){\n        for(int j=0;j<=H;j++){\n            for(int k=0;k<=W;k++){\n                dist[i][j][k]=MOD;\n            }\n        }\n    }\n    for(int i=0;i<v.size();i++){\n        queue<pair<int,int>> Q;\n        Q.push(v[i]);\n        dist[i][v[i].first][v[i].second]=0;\n        while(!Q.empty()){\n            int x,y;\n            tie(x,y)=Q.front();\n            Q.pop();\n\n            for(int j=0;j<4;j++){\n                int nx=x+dx[j];\n                int ny=y+dy[j];\n                if(nx<0||ny<0||nx>=H||ny>=W) continue;\n                if(C[nx][ny]=='x') continue;\n                if(dist[i][nx][ny]<=dist[i][x][y]+1) continue;\n                dist[i][nx][ny]=dist[i][x][y]+1;\n                Q.push(mkp(nx,ny));\n            }\n        }\n    }\n}\n\nvoid solve(){\n    int cnt=1;\n    mp.clear();\n    v.clear();\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            cin>>C[i][j];\n            if(C[i][j]=='o'){\n                stx=i;\n                sty=j;\n            }\n        }\n    }\n    v.push_back(mkp(stx,sty));\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(C[i][j]=='*'){\n                mp[cnt]=mkp(i,j);\n                cnt++;\n                v.push_back(mkp(i,j));\n            }\n        }\n    }\n\n    bfs();\n\n    vector<int> p(v.size()-1);\n    iota(p.begin(),p.end(),1);\n    int ans=MOD;\n    do{\n        int now=0;\n        int res=0;\n        for(int i=0;i<p.size();i++){\n            int x=mp[p[i]].first;\n            int y=mp[p[i]].second;\n            if(dist[now][x][y]==MOD){\n                res=MOD;\n                break;\n            }else res+=dist[now][x][y];\n            now=p[i];\n        }\n        ans=min(ans,res);\n    }while(next_permutation(p.begin(),p.end()));\n    \n    if(ans<MOD) cout<<ans<<endl;\n    else cout<<-1<<endl;\n}\n\nint main(){\n  while(1){\n      cin>>W>>H;\n      if(W==0) break;\n      solve();\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<deque>\n#include<queue>\n\nusing namespace std;\n\nint main(){\n  int h,w;\n  while(scanf(\"%d%d\\n\",&w,&h),w+h){\n    char board[22][23]={{0}};\n    deque<pair<int,int> > pos;\n    int count=3;\n    for(int i=1;i<=h;i++){\n      fgets(&board[i][1],sizeof(&board[i][1]),stdin);\n      for(int j=1;j<=w;j++){\n\tif(board[i][j]=='x')      board[i][j]=0;\n\telse if(board[i][j]=='.') board[i][j]=1;\n\telse if(board[i][j]=='*'){\n\t  board[i][j]=count++;\n\t  pos.push_back(make_pair(j,i));\n\t}else if(board[i][j]=='o'){\n\t  board[i][j]=2;\n\t  pos.push_front(make_pair(j,i));\n\t}\n      }\n    }\n\n    /*\n    for(int i=0;i<h+2;i++){\n      for(int j=0;j<w+2;j++){\n\tprintf(\"%d \",board[i][j]);\n      }\n      puts(\"\");\n    }\n    */\n\n    //int darty=pos.size()-1;\n    int dist[11][11]={{0}};\n    bool possible=true;\n    for(int i=0;i<pos.size()-1;i++){\n      //dijkstra\n      int flag[22][22]={{0}};\n      int d[22][22];\n      for(int x=0;x<22;x++)\n\tfor(int y=0;y<22;y++)\n\t  d[y][x]=1000;\n      count=0;\n      priority_queue<pair<int,pair<int,int> > > q;\n      q.push(make_pair(0,make_pair(pos[i].first,pos[i].second)));\n      while(!q.empty()){\n\tif(count==pos.size()) break;\n\tint x=q.top().second.first,y=q.top().second.second,hy=q.top().first;\n\tq.pop();\n\t//printf(\"(%d,%d)=%d\\n\",x,y,-hy);\n\tif(flag[y][x]!=0) continue;\n\tflag[y][x]=1;\n\tif(board[y][x]>=2){//darty or initial\n\t  //printf(\"test %d\\n\",board[y][x]-2);\n\t  dist[i][board[y][x]-2]=-hy;\n\t  dist[board[y][x]-2][i]=-hy;\n\t  count++;\n\t}\n\tif(board[y][x-1]!=0 && d[y][x-1]>-hy+1){\n\t  d[y][x-1]=-hy+1;\n\t  q.push(make_pair(hy-1,make_pair(x-1,y)));\n\t}\n\tif(board[y][x+1]!=0 && d[y][x+1]>-hy+1) {\n\t  d[y][x+1]=-hy+1;\n\t  q.push(make_pair(hy-1,make_pair(x+1,y)));\n\t}\n\tif(board[y-1][x]!=0 && d[y-1][x]>-hy+1){\n\t  d[y-1][x]=-hy+1;\n\t  q.push(make_pair(hy-1,make_pair(x,y-1)));\n\t}\n\tif(board[y+1][x]!=0 && d[y+1][x]>-hy+1){\n\t  d[y+1][x]=-hy+1;\n\t  q.push(make_pair(hy-1,make_pair(x,y+1)));\n\t}\n      }\n      if(count!=pos.size()){\n\tpossible=false;\n\tbreak;\n      }\n    }\n    if(!possible){\n      puts(\"-1\");\n      continue;\n    }\n    \n    /*\n    for(int i=0;i<pos.size();i++){\n      for(int j=0;j<pos.size();j++){\n\tprintf(\"%3d\",dist[i][j]);\n      }\n      printf(\"\\n\");\n    }\n    */\n    //traveling salesman problem\n    vector<int> v(pos.size()-1);\n    int ans=100000;\n    for(int i=0;i<pos.size()-1;i++) v[i]=i+1;\n    do{\n      int tmp=dist[0][v[0]];\n      for(int i=0;i<pos.size()-2;i++){\n\ttmp+=dist[v[i]][v[i+1]];\n\tif(tmp>ans){\n\t  sort(&v[i+1],&v[pos.size()-2],greater<int>());\n\t  break;\n\t}\n      }\n      if(ans>tmp) ans=tmp;\n    }while(next_permutation(v.begin(),v.end()));\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing Graph = vector<vector<int>>;\n\nint MinimumPath(const Graph &g) {\n    const int n = g.size();\n    int min_d = 1e8;\n\n    vector<int> idx(n - 1);\n    iota(idx.begin(), idx.end(), 1);\n\n    do {\n        int d = g[0][idx[0]];\n        for (int i = 0; i < n - 2; ++i) d += g[idx[i]][idx[i + 1]];\n        min_d = min(min_d, d);\n    } while (next_permutation(idx.begin(), idx.end()));\n\n    return min_d;\n}\n\nconst int dr[] = {-1, 0, 1, 0};\nconst int dc[] = {0, -1, 0, 1};\n\nint Distance(const auto &src, const auto &dst, const int h, const int w, const vector<string> &c) {\n    vector<vector<int>> d(h, vector<int>(w, -1));\n    queue<pair<int, int>> que;\n    que.push(src);\n    d[src.first][src.second] = 0;\n\n    while (!que.empty()) {\n        auto cur = que.front(); que.pop();\n\n        for (int dir = 0; dir < 4; ++dir) {\n            pair<int, int> nxt(cur.first + dr[dir], cur.second + dc[dir]);\n            if (nxt.first < 0 || nxt.second < 0 || h <= nxt.first || w <= nxt.second\n                || d[nxt.first][nxt.second] != -1 || c[nxt.first][nxt.second] == 'x')\n                continue;\n            d[nxt.first][nxt.second] = d[cur.first][cur.second] + 1;\n            que.push(nxt);\n        }\n    }\n\n    return d[dst.first][dst.second];\n}\n\npair<bool, Graph> MakeGraph(const int w, const int h, const vector<string> &c) {\n    vector<pair<int, int>> pos(1);\n    for (int i = 0; i < h; ++i)\n        for (int j = 0; j < w; ++j) {\n            if (c[i][j] == 'o') pos[0] = make_pair(i, j);\n            else if (c[i][j] == '*') pos.emplace_back(make_pair(i, j));\n        }\n\n    const int n = pos.size();\n    Graph d(n, vector<int>(n));\n    for (int i = 0; i < n; ++i)\n        for (int j = i + 1; j < n; ++j) {\n            int d_ij = Distance(pos[i], pos[j], h, w, c);\n            if (d_ij == -1) return make_pair(true, d);\n            d[i][j] = d[j][i] = d_ij;\n        }\n\n    return make_pair(false, d);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int w, h;\n\n    while (cin >> w >> h, (w != 0 || h != 0)) {\n        vector<string> c(h);\n        for (auto &x : c) cin >> x;\n\n        auto res = MakeGraph(w, h, c);\n        if (res.first) cout << -1 << '\\n';\n        else cout << MinimumPath(res.second) << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nchar g[20][21];\nint d[21][21];\nint bfs[20][20];\npair<int,int>p[20];\nint perm[10];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a+b){\n\t\tint sb=0;\n\t\tint sa=0;\n\t\tfor(int i=0;i<b;i++)scanf(\"%s\",g[i]);\n\t\tint now=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(g[i][j]=='o'){\n\t\t\t\t\tsb=i;\n\t\t\t\t\tsa=j;\n\t\t\t\t}else if(g[i][j]=='*'){\n\t\t\t\t\tp[now++]=make_pair(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<b;i++)\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(g[i][j]=='x')bfs[i][j]=-2;\n\t\t\t\telse bfs[i][j]=-1;\n\t\t\t}\n\t\tqueue<pair<int,int> >Q;\n\t\tQ.push(make_pair(sb,sa));\n\t\tbfs[sb][sa]=0;\n\t\twhile(Q.size()){\n\t\t\tint nowb=Q.front().first;\n\t\t\tint nowa=Q.front().second;\n\t\t\tQ.pop();\n\t\t\tif(nowb&&bfs[nowb-1][nowa]==-1){\n\t\t\t\tbfs[nowb-1][nowa]=bfs[nowb][nowa]+1;\n\t\t\t\tQ.push(make_pair(nowb-1,nowa));\n\t\t\t}\n\t\t\tif(nowa&&bfs[nowb][nowa-1]==-1){\n\t\t\t\tbfs[nowb][nowa-1]=bfs[nowb][nowa]+1;\n\t\t\t\tQ.push(make_pair(nowb,nowa-1));\n\t\t\t}\n\t\t\tif(nowb<b-1&&bfs[nowb+1][nowa]==-1){\n\t\t\t\tbfs[nowb+1][nowa]=bfs[nowb][nowa]+1;\n\t\t\t\tQ.push(make_pair(nowb+1,nowa));\n\t\t\t}\n\t\t\tif(nowa<a-1&&bfs[nowb][nowa+1]==-1){\n\t\t\t\tbfs[nowb][nowa+1]=bfs[nowb][nowa]+1;\n\t\t\t\tQ.push(make_pair(nowb,nowa+1));\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=now;i++){\n\t\t\td[0][i]=bfs[p[i-1].first][p[i-1].second];\n\t\t\tif(d[0][i]==-1)d[0][i]=99999999;\n\t\t}\n\t\tfor(int k=0;k<now;k++){\n\t\t\tfor(int i=0;i<b;i++)\n\t\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\t\tif(g[i][j]=='x')bfs[i][j]=-2;\n\t\t\t\t\telse bfs[i][j]=-1;\n\t\t\t\t}\n\t\t\tqueue<pair<int,int> >Q;\n\t\t\tQ.push(make_pair(p[k].first,p[k].second));\n\t\t\tbfs[p[k].first][p[k].second]=0;\n\t\t\twhile(Q.size()){\n\t\t\t\tint nowb=Q.front().first;\n\t\t\t\tint nowa=Q.front().second;\n\t\t\t\tQ.pop();\n\t\t\t\tif(nowb&&bfs[nowb-1][nowa]==-1){\n\t\t\t\t\tbfs[nowb-1][nowa]=bfs[nowb][nowa]+1;\n\t\t\t\t\tQ.push(make_pair(nowb-1,nowa));\n\t\t\t\t}\n\t\t\t\tif(nowa&&bfs[nowb][nowa-1]==-1){\n\t\t\t\t\tbfs[nowb][nowa-1]=bfs[nowb][nowa]+1;\n\t\t\t\t\tQ.push(make_pair(nowb,nowa-1));\n\t\t\t\t}\n\t\t\t\tif(nowb<b-1&&bfs[nowb+1][nowa]==-1){\n\t\t\t\t\tbfs[nowb+1][nowa]=bfs[nowb][nowa]+1;\n\t\t\t\t\tQ.push(make_pair(nowb+1,nowa));\n\t\t\t\t}\n\t\t\t\tif(nowa<a-1&&bfs[nowb][nowa+1]==-1){\n\t\t\t\t\tbfs[nowb][nowa+1]=bfs[nowb][nowa]+1;\n\t\t\t\t\tQ.push(make_pair(nowb,nowa+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1;i<=now;i++){\n\t\t\t\td[k+1][i]=bfs[p[i-1].first][p[i-1].second];\n\t\t\t\tif(d[k+1][i]==-1)d[k+1][i]=99999999;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<now;i++){\n\t\t\tperm[i]=i+1;\n\t\t}\n\t\tint ret=99999999;\n\t\tdo{\n\t\t\tint val=d[0][perm[0]];\n\t\t\tfor(int i=1;i<now;i++)val+=d[perm[i-1]][perm[i]];\n\t\t\tret=min(ret,val);\n\t\t}while(next_permutation(perm,perm+now));\n\t\tif(ret==99999999)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing Graph = vector<vector<int>>;\n\nint MinimumPath(const Graph &g) {\n    const int n = g.size();\n    int min_d = 1e8;\n\n    vector<int> idx(n - 1);\n    iota(idx.begin(), idx.end(), 1);\n\n    do {\n        int d = g[0][idx[0]];\n        for (int i = 0; i < n - 2; ++i) d += g[idx[i]][idx[i + 1]];\n        min_d = min(min_d, d);\n    } while (next_permutation(idx.begin(), idx.end()));\n\n    return min_d;\n}\n\nconst int dr[] = {-1, 0, 1, 0};\nconst int dc[] = {0, -1, 0, 1};\n\nint Distance(const auto &src, const auto &dst, const int h, const int w, const vector<string> &c) {\n    vector<vector<int>> d(h, vector<int>(w, -1));\n    queue<pair<int, int>> que;\n    que.push(src);\n    d[src.first][src.second] = 0;\n\n    while (!que.empty()) {\n        auto cur = que.front(); que.pop();\n\n        for (int dir = 0; dir < 4; ++dir) {\n            pair<int, int> nxt(cur.first + dr[dir], cur.second + dc[dir]);\n            if (nxt.first < 0 || nxt.second < 0 || h <= nxt.first || w <= nxt.second\n                || d[nxt.first][nxt.second] != -1 || c[nxt.first][nxt.second] == 'x')\n                continue;\n            d[nxt.first][nxt.second] = d[cur.first][cur.second] + 1;\n            que.push(nxt);\n        }\n    }\n\n    return d[dst.first][dst.second];\n}\n\npair<bool, Graph> MakeGraph(const int w, const int h, const vector<string> &c) {\n    vector<pair<int, int>> pos(1);\n    for (int i = 0; i < h; ++i)\n        for (int j = 0; j < w; ++j) {\n            if (c[i][j] == 'o') pos[0] = make_pair(i, j);\n            else if (c[i][j] == '*') pos.emplace_back(make_pair(i, j));\n        }\n\n    const int n = pos.size();\n    Graph d(n, vector<int>(n));\n    for (int i = 0; i < n; ++i)\n        for (int j = i + 1; j < n; ++j) {\n            int d_ij = Distance(pos[i], pos[j], h, w, c);\n            if (d_ij == -1) return make_pair(true, d);\n            d[i][j] = d[j][i] = d_ij;\n        }\n\n    return make_pair(false, d);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int w, h;\n\n    while (cin >> w >> h, (w != 0 || h != 0)) {\n        vector<string> c(h);\n        for (auto &x : c) cin >> x;\n\n        auto res = MakeGraph(w, h, c);\n        if (res.first) cout << -1 << '\\n';\n        else cout << MinimumPath(res.second) << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\n\nconst int INF=123456789;\n\nint main()\n{\n    int dx[4]={1,-1,0,0}, dy[4]={0,0,1,-1};\n\n    int w,h;\n    while(cin >>w >>h,w)\n    {\n        vector<string> s(h);\n        rep(i,h) cin >>s[i];\n\n        vector<pi> tiles;\n        rep(i,h)rep(j,w) if(s[i][j]=='o') tiles.pb(pi(i,j));\n        rep(i,h)rep(j,w) if(s[i][j]=='*') tiles.pb(pi(i,j));\n\n        int T=tiles.size();\n\n        int d[11][11]={0};\n\n        #define IN(x,y) (0<=x && x<w && 0<=y && y<h)\n        rep(i,T)\n        {\n            vector<vi> dist(h,vi(w,INF));\n            dist[tiles[i].fi][tiles[i].se]=0;\n            queue<pi> que;\n            que.push(pi(tiles[i]));\n            while(!que.empty())\n            {\n                pi now=que.front();\n                que.pop();\n                rep(j,4)\n                {\n                    int nx=now.se+dx[j], ny=now.fi+dy[j];\n                    if(IN(nx,ny) && s[ny][nx]!='x' && dist[ny][nx]>dist[now.fi][now.se]+1)\n                    {\n                        dist[ny][nx]=dist[now.fi][now.se]+1;\n                        que.push(pi(ny,nx));\n                    }\n                }\n            }\n\n            rep(j,T)\n            {\n                if(i==j) continue;\n                d[i][j]=dist[tiles[j].fi][tiles[j].se];\n            }\n        }\n\n        int dp[2048][11];\n        fill(dp[0],dp[2048],INF);\n        dp[1][0]=0;\n        for(int i=1; i<(1<<T); ++i)rep(j,T)if(i>>j&1)rep(k,T)if(!(i>>k&1))\n        {\n            int nx=i+(1<<k);\n            dp[nx][k]=min(dp[nx][k],dp[i][j]+d[j][k]);\n        }\n\n        int ans=INF;\n        rep(i,T) ans=min(ans,dp[(1<<T)-1][i]);\n        if(ans==INF) ans=-1;\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; double w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 100;\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\nint main() {\n\tfor (;;) {\n\t\tint w, h; cin >> w >> h;\n\t\tif (w == 0) break;\n\t\tvector<string> c(h);\n\t\tvector<int> X(1), Y(1);\n\t\tfor (int y = 0; y < h; y++) {\n\t\t\tcin >> c[y];\n\t\t\tfor (int x = 0; x < w; x++)\n\t\t\t\tif (c[y][x] == '*') {\n\t\t\t\t\tX.push_back(x);\n\t\t\t\t\tY.push_back(y);\n\t\t\t\t}\n\t\t\t\telse if (c[y][x] == 'o') {\n\t\t\t\t\tX[0] = x;\n\t\t\t\t\tY[0] = y;\n\t\t\t\t}\n\t\t}\n\t\tint n = X.size();\n\t\tvector< vector<int> > a(n, vector<int>(n));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = X[i], y = Y[i];\n\t\t\tvector< vector<int> > d(h, vector<int>(w, INF));\n\t\t\td[y][x] = 0;\n\t\t\tqueue<i_i> q;\n\t\t\tq.push(i_i(x, y));\n\t\t\twhile (!q.empty()) {\n\t\t\t\ti_i p = q.front(); q.pop();\n\t\t\t\tint x = p.first, y = p.second;\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint _x = x + dx[k], _y = y + dy[k];\n\t\t\t\t\tif (_x >= 0 && _x < w && _y >= 0 && _y < h && c[_y][_x] != 'x' && d[_y][_x] > d[y][x] + 1) {\n\t\t\t\t\t\td[_y][_x] = d[y][x] + 1;\n\t\t\t\t\t\tq.push(i_i(_x, _y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tint x = X[j], y = Y[j];\n\t\t\t\ta[i][j] = d[y][x];\n\t\t\t}\n\t\t}\n\t\t/*for (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tcout << a[i][j] << ' ';\n\t\t\tcout << endl;\n\t\t}*/\n\t\tvector<int> v(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tv[i] = i;\n\t\tint mini = INF;\n\t\tdo {\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 0; i + 1 < n; i++)\n\t\t\t\tsum += a[v[i]][v[i + 1]];\n\t\t\tmini = min(mini, sum);\n\t\t} while (next_permutation(v.begin() + 1, v.end()));\n\t\tcout << (mini < INF ? mini : -1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <utility>\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(it,c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); ++it)\n#define DEBUG(x) // cerr << #x << \" = \" << x << endl\n\ntypedef pair<int, int> P;\nostream& operator<<(ostream& os, const P& p) {\n    os << \"(y,x) = \" << '(' << p.first << ',' << p.second << ')';\n    return os;\n}\n\nconst int INF = (int)1e9;\n\nint dist[11][11];\nmap<P, int> memo;\n\n// current vertex, bitmask, number of vertex\nint tsp(int v, int b, int N) {\n    if(memo.count(P(v,b))) return memo[P(v,b)];\n    if(b == (1 << N) - 1) return 0;\n    int res = INF;\n    for(int i = 0; i < N; i++) {\n        if(b & (1 << i)) continue;\n        res = min(res, dist[v][i] + tsp(i, b | (1 << i), N));\n    }\n    return memo[P(v,b)] = res;\n}\n\nint main() {\n    while(true) {\n        int W, H; cin >> W >> H;\n        if(W + H == 0) break;\n        vector<string> inp;\n        REP(i,H) {\n            string s; cin >> s;\n            inp.push_back(s);\n        }\n\n        // y,x\n        vector<P> dst;\n        REP(y,H) REP(x,W) {\n            if(inp[y][x] == 'o') {\n                dst.push_back(P(y,x));\n                inp[y][x] = '.';\n            }\n        }\n\n        REP(y,H) REP(x,W) {\n            if(inp[y][x] == '*') {\n                dst.push_back(P(y,x));\n                inp[y][x] = '.';\n            }\n        }\n\n        REP(i,dst.size()) REP(j,dst.size()) dist[i][j] = INF;\n\n        REP(i,dst.size()) {\n            const int dy[4] = { 0, 1, 0, -1 };\n            const int dx[4] = { 1, 0, -1, 0 };\n\n            static bool vis[20][20];\n            REP(y,H) REP(x,W) vis[y][x] = false;\n\n            static int D[20][20];\n            REP(y,H) REP(x,W) D[y][x] = INF;\n\n            queue<P> Q;\n            Q.push(dst[i]);\n\n            vis[dst[i].first][dst[i].second] = true;\n            D[dst[i].first][dst[i].second] = 0;\n\n            while(!Q.empty()) {\n                P p = Q.front(); Q.pop();\n                REP(j,4) {\n                    int ny = p.first + dy[j];\n                    int nx = p.second + dx[j];\n                    if(0 <= nx && nx < W && 0 <= ny && ny < H && inp[ny][nx] != 'x' && vis[ny][nx] == false) {\n                        vis[ny][nx] = true;\n                        D[ny][nx] = D[p.first][p.second] + 1;\n                        Q.push(P(ny,nx));\n                    }\n                }\n            }\n            REP(j,dst.size()) {\n                dist[i][j] = D[dst[j].first][dst[j].second];\n            }\n        }\n\n        REP(i,dst.size()) REP(j,dst.size()) {\n            DEBUG(dst[i]);\n            DEBUG(dst[j]);\n            DEBUG(dist[i][j]);\n        }\n        \n        bool valid = true;\n        for(int i = 1; i < dst.size(); i++) {\n            if(dist[0][i] >= INF) {\n                valid = false;\n                break;\n            }\n        }\n        if(valid == false) {\n            cout << -1 << endl;\n            continue;\n        }\n\n        memo.clear();\n        int ans = tsp(0, 1, dst.size());\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint d[] = { 0, 1, 0, -1, 0 };\nbool visited[20][20];\nint w, h;\nchar c[20][20];\n\nbool isin(int y, int x) {\n  return 0 <= y && y < h && 0 <= x && x < w;\n}\n\nvoid wfs(int sy, int sx, int* dist) {\n  queue<int> qy, qx, qd;\n\n  REP(i, 0, h) REP(j, 0, w) visited[i][j] = false;\n  visited[sy][sx] = true;\n  qy.push(sy), qx.push(sx), qd.push(0);\n\n  while(!qd.empty()) {\n    int cy = qy.front(), cx = qx.front(), cd = qd.front();\n    qy.pop(), qx.pop(), qd.pop();\n    if(c[cy][cx] == 'o') dist[0] = cd;\n    if(1 <= c[cy][cx] && c[cy][cx] <= 10) dist[c[cy][cx]] = cd;\n\n    REP(i, 0, 4) {\n      int ny = cy + d[i], nx = cx + d[i + 1], nd = cd + 1;\n      if(isin(ny, nx) && !visited[ny][nx] && c[cy][cx] != 'x') {\n        visited[ny][nx] = true;\n        qy.push(ny), qx.push(nx), qd.push(nd);\n      }\n    }\n  }\n}\n\nint main(void) {\n  while(cin >> w >> h, w != 0 && h != 0) {\n    int di = 1, sy, sx, dy[11], dx[11];\n    REP(i, 0, h) {\n      cin >> c[i];\n      REP(j, 0, w) {\n        if(c[i][j] == '*') {\n          c[i][j] = di;\n          dy[di] = i;\n          dx[di] = j;\n          di++;\n        }\n        if(c[i][j] == 'o') sy = i, sx = j;\n      }\n    }\n\n    int dist[11][11];\n    REP(i, 0, 11) REP(j, 0, 11) dist[i][j] = -1;\n\n    wfs(sy, sx, dist[0]);\n    bool possible = true;\n    REP(i, 1, di) if(dist[0][i] == -1) possible = false;\n\n    if(possible) {\n      REP(i, 1, di) wfs(dy[i], dx[i], dist[i]);\n\n      int ans = 100000;\n      int order[11] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n      do {\n        int move = 0;\n        REP(i, 0, di - 1) move += dist[order[i]][order[i + 1]];\n        if(move > 0) ans = min(ans, move);\n      } while (next_permutation(order, order + di));\n      cout << ans << endl;\n    } else {\n      cout << -1 << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip\t;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint dp[21][21][1030];\nint main(){\n\tint n,m;\n\twhile(cin>>m>>n,n+m){\n\t\tvector<string>in(n);\n\t\trep(i,n)cin>>in[i];\n\t\tint co=0;\n\t\trep(i,n)rep(j,m)if(in[i][j]=='*'){\n\t\t\tin[i][j]=(char)('0'+co);\n\t\t\tco++;\n\t\t}\n\t\tint N=1<<co;\n\t\trep(i,21)rep(j,21)rep(k,1030)\n\t\t\tdp[i][j][k]=inf;\n\t\tqueue<pair<pii,pii> >q;\n\t\trep(i,n)rep(j,m)if(in[i][j]=='o')\n\t\t\tq.push(pair<pii,pii>(pii(i,j),pii(0,0)));\n\t\tint dx[]={0,0,1,-1};\n\t\tint dy[]={1,-1,0,0};\n\t\twhile(!q.empty()){\n\t\t\tpii a=q.front().first;\n\t\t\tpii b=q.front().second;\n\t\t\tq.pop();\n\t\t\tif(dp[a.first][a.second][b.first]<b.second)continue;\n//\t\t\tcout<<a.first<<\" \"<<a.second<<\" \"<<b.first<<\" \"<<b.second<<endl;\n\t\t\trep(i,4){\n\t\t\t\tint nx=a.first+dx[i];\n\t\t\t\tint ny=a.second+dy[i];\n\t\t\t\tint past=b.first;\n\t\t\t\tint cost=b.second+1;\n\t\t\t\tif(nx<0||ny<0||nx>=n||ny>=m)continue;\n\t\t\t\tif(in[nx][ny]=='x')continue;\n\t\t\t\tif(isdigit(in[nx][ny]))past|=1<<(in[nx][ny]-'0');\n\t\t\t\tif(dp[nx][ny][past]>cost){\n\t\t\t\t\tdp[nx][ny][past]=cost;\n\t\t\t\t\tq.push(pair<pii,pii>(pii(nx,ny),pii(past,cost)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint out=inf;\n\t\trep(i,n)rep(j,m)out=min(out,dp[i][j][N-1]);\n\t\tif(out==inf)out=-1;\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n  int i,j;\n  int w,h;\n  while(cin>>w>>h,w||h){\n    int a[22][22],b[10],c[10],x,y,n=0;\n    memset(a,-1,sizeof(a));\n    for(i=1;i<h+1;i++){\n      for(j=1;j<w+1;j++){\n\tchar s;\n\tcin>>s;\n\tif(0){\n\t}else if(s=='x'){\n\t  a[j][i]=-1;\n\t}else if(s=='o'){\n\t  a[j][i]=-2;\n\t  x=j;\n\t  y=i;\n\t}else if(s=='*'){\n\t  a[j][i]=n;\n\t  b[n]=j;\n\t  c[n]=i;\n\t  n++;\n\t}else if(s=='.'){\n\t  a[j][i]=-2;\n\t}\n      }\n    }\n    int d[22][22][1<<10];\n    memset(d,-1,sizeof(d));\n    queue<pair<pair<int,int>,pair<int,int> > > e;\n    e.push(make_pair(make_pair(x,y),make_pair(0,0)));\n    while(e.empty()==0){\n      int x,y,v,w;\n      x=e.front().first.first;\n      y=e.front().first.second;\n      v=e.front().second.first;\n      w=e.front().second.second;\n      if(v==~((~0)<<n))\n\tbreak;\n      e.pop();\n      if(d[x][y][v]==-1||d[x][y][v]>w){\n\td[x][y][v]=w;\n\tif(a[x-1][y]!=-1){\n\t  if(a[x-1][y]==-2)\n\t    e.push(make_pair(make_pair(x-1,y),make_pair(v,w+1)));\n\t  else\n\t    e.push(make_pair(make_pair(x-1,y),make_pair(v|(1<<a[x-1][y]),w+1)));\n\t}\n\tif(a[x+1][y]!=-1){\n\t  if(a[x+1][y]==-2)\n\t    e.push(make_pair(make_pair(x+1,y),make_pair(v,w+1)));\n\t  else\n\t    e.push(make_pair(make_pair(x+1,y),make_pair(v|(1<<a[x+1][y]),w+1)));\n\t}\n\tif(a[x][y-1]!=-1){\n\t  if(a[x][y-1]==-2)\n\t    e.push(make_pair(make_pair(x,y-1),make_pair(v,w+1)));\n\t  else\n\t    e.push(make_pair(make_pair(x,y-1),make_pair(v|(1<<a[x][y-1]),w+1)));\n\t}\n\tif(a[x][y+1]!=-1){\n\t  if(a[x][y+1]==-2)\n\t    e.push(make_pair(make_pair(x,y+1),make_pair(v,w+1)));\n\t  else\n\t    e.push(make_pair(make_pair(x,y+1),make_pair(v|(1<<a[x][y+1]),w+1)));\n\t}\n      }\n    }\n    cout<<(e.empty()?-1:e.front().second.second)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int INF = 99999999;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint H, W;\nvector<string> s;\n\nbool inside(int x, int y) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nint bfs(int sx, int sy, int gx, int gy) {\n    queue<P> que;\n    que.push(P(sx, sy));\n    vector<vector<int>> d(H, vector<int>(W, INF));\n    d[sx][sy] = 0;\n\n    while (!que.empty()) {\n        P p = que.front(); que.pop();\n        if (p.first == gx && p.second == gy)\n            return d[gx][gy];\n\n        rep(k, 4) {\n            int nx = p.first + dx[k], ny = p.second + dy[k];\n\n            if (inside(nx, ny) && s[nx][ny] != 'x' && d[nx][ny] == INF) {\n                que.push(P(nx, ny));\n                d[nx][ny] = d[p.first][p.second] + 1;\n            }\n        }\n    }\n\n    // not reachable\n    return INF;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    while (cin >> W >> H, W) {\n        s.clear();\n        s.resize(H);\n        vector<P> dust;\n        int sx, sy;\n        rep(i, H) {\n            cin >> s[i];\n            rep(j, W) {\n                if (s[i][j] == 'o') {\n                    sx = i;\n                    sy = j;\n                } else if (s[i][j] == '*') {\n                    dust.emplace_back(P(i, j));\n                }\n            }\n        }\n\n        int n = dust.size();\n        vector<int> ds(n);\n        rep(i, n) {\n            ds[i] = bfs(sx, sy, dust[i].first, dust[i].second);\n        }\n\n        vector<vector<int>> dd(n, vector<int>(n));\n        rep(i, n) {\n            rep(j, n) {\n                dd[i][j] = bfs(dust[i].first, dust[i].second, dust[j].first, dust[j].second);\n            }\n        }\n\n        int ans = INF;\n        rep(i, n) {\n            vector<int> perm(n);\n            iota(all(perm), 0);\n            do {\n                if (perm[0] != i) continue;\n                int t = ds[i];\n                rep(j, n - 1) {\n                    t += dd[perm[j]][perm[j + 1]];\n                }\n                ans = min(ans, t);\n            } while (next_permutation(all(perm)));\n        }\n\n        cout << (ans == INF ? -1 : ans) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nint vis[25][25],n,m,dust,cnt,mov[4][2]= {1,0,0,-1,-1,0,0,1},stx,sty,cost,tx,ty,visp[25][25],lp;\nchar plate[25][25];\n\nstruct status\n{\n    int cnt;\n    int x,y;\n    status(int a,int b,int c)\n    {\n        x = a, y = b, cnt = c;\n    }\n};\n\nvoid maek(int x,int y)\n{\n    vis[x][y] = 1;\n    if(plate[x][y] == '*') cnt++ ;\n    for(int i=0; i<4; i++)\n        if(x + mov[i][0] >= 0 && x + mov[i][0] < m && y + mov[i][1] >=0 && y + mov[i][1] < n && plate[x + mov[i][0]][y + mov[i][1]] != 'x' && !vis[x + mov[i][0]][y + mov[i][1]])\n            maek(x + mov[i][0],y + mov[i][1]);\n}\n\nqueue<struct status> q;\n\nvoid bfs(int x,int y,int &xx,int &yy)\n{\n    if(plate[x][y]=='*' && !visp[x][y])\n    {\n        cost = q.front().cnt;\n        visp[x][y] = 1, xx = x, yy= y;\n        return ;\n    }\n    for(int i=0; i<4; i++)\n    {\n        int tx = x + mov[i][0], ty = y + mov[i][1];\n        if(tx >= 0 && tx < m && ty >= 0 && ty < n && !vis[tx][ty] && plate[tx][ty] != 'x' && !visp[tx][ty])\n        {\n            struct status t1 = q.front();\n            struct status t2(tx, ty, t1.cnt+1);\n            q.push(t2);\n            vis[tx][ty] = 1;\n        }\n    }\n    q.pop();\n    bfs(q.front().x, q.front().y, xx, yy);\n}\n\n\nint main()\n{\n    while(~scanf(\"%d%d\",&n,&m),n+m)\n    {\n        memset(vis, 0, sizeof(vis)), memset(visp, 0, sizeof(visp)), memset(plate, 0, sizeof(plate));\n        getchar();\n        lp = 0, cnt = 0;\n\n        for(int i=0; i<m; i++)\n        {\n            for(int j=0; j<n; j++)\n            {\n                scanf(\"%c\",&plate[i][j]);\n                if(plate[i][j]=='o') stx = i, sty = j;\n                if(plate[i][j]=='*') lp++;\n            }\n            getchar();\n        }\n        maek(stx,sty);\n\n        if(cnt != lp) printf(\"-1\\n\");\n        else\n        {\n            int sum = 0,rx,ry;\n            for(int i=0; i<lp; i++)\n            {\n                struct status temp(stx,sty,0);\n                q.push(temp);\n                memset(vis,0,sizeof(vis));\n                vis[stx][sty] = 1;\n                bfs(stx,sty,rx,ry);\n                sum += cost;\n                stx = rx, sty = ry;\n                while(!q.empty()) q.pop();\n            }\n            printf(\"%d\\n\",sum);\n        }\n    }\n    return 0;\n}\n/*\n\n7 5\n.......\n.o...*.\n.......\n.*...*.\n.......\n15 13\n.......x.......\n...o...x....*..\n.......x.......\n.......x.......\n.......x.......\n...............\nxxxxx.....xxxxx\n...............\n.......x.......\n.......x.......\n.......x.......\n..*....x....*..\n.......x.......\n10 10\n..........\n..o.......\n..........\n..........\n..........\n.....xxxxx\n.....x....\n.....x.*..\n.....x....\n.....x....\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nconst int INF = 1000;\nint tile[20][20], A[11][11], dist[20][20], dp[1<<10][11], cnt;\n\nint dpdp(int state, int v) {\n  if (state == (1 << cnt) - 1) return dp[state][v] = 0;\n  if (dp[state][v] != -1) return dp[state][v];\n\n  int ret = INF;\n  REP(i, cnt) {\n    if (!(state >> i & 1)) {\n      ret = min(ret, dpdp(state | 1 << i, i + 1) + A[v][i+1]);\n    }\n  }\n  return dp[state][v] = ret;;\n}\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    int R, C;\n    cin >> C >> R;\n    if (R == 0 && C == 0) break;\n    cnt = 0;\n    REP(i, R) {\n      string row;\n      cin >> row;\n      REP(j, C) {\n\tif (row[j] == 'o') tile[i][j] = 0;\n\telse if (row[j] == '*') tile[i][j] = ++cnt;\n\telse if (row[j] == 'x') tile[i][j] = -1;\n\telse tile[i][j] = -2;\n      }\n    }\n    REP(i, cnt + 1) REP(j, cnt + 1) A[i][j] = INF;\n    REP(i, R) REP(j, C) {\n      if (tile[i][j] >= 0) {\n\tREP(r, R) REP(c, C) dist[r][c] = INF;\n\tdist[i][j] = 0;\n\tqueue<T> que;\n\tque.push(T(0, i, j));\n\twhile (!que.empty()) {\n\t  int d, r, c;\n\t  tie(d, r, c) = que.front(); que.pop();\n\t  if (dist[r][c] != d) continue;\n\t  \n\t  REP(i, 4) {\n\t    int nr = r + dr[i], nc = c + dc[i];\n\t    if (0 <= nr && nr < R && 0 <= nc && nc < C && tile[nr][nc] != -1 && d + 1 < dist[nr][nc]) {\n\t      dist[nr][nc] = d + 1;\n\t      que.push(T(d + 1, nr, nc));\n\t    }\n\t  }\n\t}\n\tREP(r, R) REP(c, C) if (tile[r][c] >= 0) A[tile[i][j]][tile[r][c]] = dist[r][c];\n      }\n    }\n    //REP(i, cnt + 1) REP(j, cnt + 1) cout << A[i][j] << (j == cnt ? '\\n' : ' ');\n\n    bool flag = true;\n    REP(i, cnt + 1) REP(j, cnt + 1) if (A[i][j] == INF) flag = false;\n    if (!flag) {\n      cout << -1 << endl;\n      continue;\n    }\n\n    memset(dp, -1, sizeof(dp));\n    cout << dpdp(0, 0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main(void) {\n\twhile(true) {\n\t\tint w, h;\n\t\tcin>>w>>h;\n\t\tif(w == 0 && h == 0) break;\n\t\tvector<vector<char> > m(h, vector<char>(w));\n\t\tvector<P> p;\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tcin>>m[i][j];\n\t\t\t\tif(m[i][j] == 'o') {\n\t\t\t\t\tp.pb(P(i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif(m[i][j] == '*') {\n\t\t\t\t\tp.pb(P(i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<ll> > d(p.size(), vector<ll>(p.size(), INF * INF));\n\t\tREP(i, p.size()) {\n\t\t\tP s = p[i];\n\t\t\tvector<vector<ll> > dir(h, vector<ll>(w, INF * INF));\n\t\t\tdir[s.first][s.second] = 0;\n\t\t\tqueue<P> q;\n\t\t\tq.push(s);\n\t\t\twhile(!q.empty()) {\n\t\t\t\tP np = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tREP(j, 4) {\n\t\t\t\t\tll nh = np.first + dx[j];\n\t\t\t\t\tll nw = np.second + dy[j];\n\t\t\t\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w && m[nh][nw] != 'x') {\n\t\t\t\t\t\tif(dir[nh][nw] == INF * INF) {\n\t\t\t\t\t\t\tdir[nh][nw] = dir[np.first][np.second] + 1;\n\t\t\t\t\t\t\tq.push(P(nh, nw));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(j, p.size()) {\n\t\t\t\tif(i == j) continue;\n\t\t\t\td[i][j] = dir[p[j].first][p[j].second];\n\t\t\t}\n\t\t}\n\t\tbool det = false;\n\t\tFOR(i, 1, p.size()) {\n\t\t\tif(d[0][i] == INF * INF) det = true;\n\t\t}\n\t\tif(det) {\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<int> perm;\n\t\tREP(i, p.size() - 1) {\n\t\t\tperm.pb((int)(i + 1));\n\t\t}\n\t\tll ans = INF * INF;\n\t\tif(p.size() == 1) {\n\t\t\tcout<<\"hoge\"<<endl;\n\t\t\tcout<<0<<endl;\n\t\t}\n\t\telse {\n\t\t\tdo {\n\t\t\t\tll res = 0;\n\t\t\t\tres += d[0][perm[0]];\n\t\t\t\tREP(i, perm.size() - 1) {\n\t\t\t\t\tres += d[perm[i]][perm[i + 1]];\n\t\t\t\t}\n\t\t\t\tans = min(ans, res);\n\t\t\t} while(next_permutation(ALL(perm)));\n\t\t\tcout<<ans<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define mp make_pair\n#define pb push_back\n#define EB emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint w,h;\n\nvoid solve(){\n    char c[32][32];\n    rep(i,h) scanf(\"%s\",c[i]);\n\n    int sx,sy;\n    rep(i,h) rep(j,w) if(c[i][j]=='o'){\n        sx = i;\n        sy = j;\n        break;\n    }\n\n    int g[512][512];\n    rep(i,512) rep(j,512) g[i][j]=INF;\n    rep(i,512) g[i][i]=0;\n\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(c[i][j]=='x') continue;\n            int v = i*w+j;\n            for(int k=0;k<4;k++){\n                int nx=i+dx[k],ny=j+dy[k];\n                if(nx<0||ny<0||nx>=h||ny>=w) continue;\n                if(c[nx][ny]=='x') continue;\n                int nv = nx*w+ny;\n                g[v][nv] = 1;\n                g[nv][v] = 1;\n            }\n        }\n    }\n\n    int V = h*w;\n    for(int k=0;k<V;k++){\n        for(int i=0;i<V;i++){\n            for(int j=0;j<V;j++){\n                g[i][j] = min(g[i][j],g[i][k]+g[k][j]);\n            }\n        }\n    }\n\n    vector<ll> as;\n    rep(i,h) rep(j,w){\n        int v = i*w+j;\n        if(c[i][j]=='*') as.pb(v);\n    }\n\n    sort(all(as));\n\n    assert(as.size()<=10);\n    ll ans = INF;\n    do{\n        ll tmp=0;\n        int now = sx*w+sy;\n        for(int i=0;i<sz(as);i++){\n            tmp += g[now][as[i]];\n            now = as[i];\n            if(g[now][as[i]]==INF){\n                cout << -1 << endl;\n                return;\n            }\n        }\n        //if(tmp==0){\n        //    //cerr << \"error\" << endl;\n        //    exit(1);\n        //}\n        ans = min(tmp,ans);\n    }while(next_permutation(all(as)));\n    if(ans==INF) cout << -1 << endl;\n    else cout << ans << endl;\n}\n\nint main(){\n    while(cin>>w>>h){\n        if(w==0 and h==0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF (1<<29)\n#define LINF LLONG_MAX/3\n#define mp make_pair\n#define pb push_back\n#define EB emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint w,h;\nbool flag=false;\n\nvoid solve(){\n    char c[32][32];\n    rep(i,h) scanf(\"%s\",c[i]);\n\n    int sx,sy;\n    rep(i,h) rep(j,w) if(c[i][j]=='o'){\n        sx = i;\n        sy = j;\n        break;\n    }\n\n    if(flag){\n        cout << h << \" \" << w << endl;\n        rep(i,h) cout << c[i] << endl;\n    }\n\n    int g[512][512];\n    rep(i,512) rep(j,512) g[i][j]=INF;\n    rep(i,512) g[i][i]=0;\n\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(c[i][j]=='x') continue;\n            int v = i*w+j;\n            for(int k=0;k<4;k++){\n                int nx=i+dx[k],ny=j+dy[k];\n                if(nx<0||ny<0||nx>=h||ny>=w) continue;\n                if(c[nx][ny]=='x') continue;\n                int nv = nx*w+ny;\n                g[v][nv] = 1;\n                g[nv][v] = 1;\n            }\n        }\n    }\n\n    int V = h*w;\n    for(int k=0;k<V;k++){\n        for(int i=0;i<V;i++){\n            for(int j=0;j<V;j++){\n                g[i][j] = min(g[i][j],g[i][k]+g[k][j]);\n            }\n        }\n    }\n\n    vector<int> as;\n    rep(i,h) rep(j,w){\n        int v = i*w+j;\n        if(c[i][j]=='*') as.pb(v);\n    }\n\n    sort(all(as));\n\n    assert(as.size()<=10);\n    int ans = INF;\n\n    do{\n        int tmp=0;\n        int now = sx*w+sy;\n        for(int i=0;i<sz(as);i++){\n            tmp += g[now][as[i]];\n            if(g[now][as[i]]==INF){\n                cout << -1 << endl;\n                return;\n            }\n            now = as[i];\n        }\n        ans = min(tmp,ans);\n    }while(next_permutation(all(as)));\n\n    if(ans==INF) cout << -1 << endl;\n    else cout << ans << endl;\n}\n\nint main(){\n    int cnt=0;\n    while(cin>>w>>h){\n        cnt++;\n        flag=false;\n        if(cnt==363) flag=true;\n        if(w==0 and h==0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#if __has_include(\"../library/Basic/Debug.hpp\")\n\n#include \"../library/Basic/Debug.hpp\"\n\n#else\n\n/* ----- Header Files ----- */\n// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <complex>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n#include <cstdint>\n\n\n/* ----- Type Alias ----- */\nusing Bool = bool;\nusing Int = long long int;\nusing Real = long double;\nusing Char = char;\nusing String = std::string;\ntemplate <class T, class U>\nusing Pair = std::pair<T, U>;\ntemplate <class... Ts>\nusing Tuple = std::tuple<Ts...>;\n\ntemplate <class T>\nusing Vector = std::vector<T>;\ntemplate <size_t N>\nusing Bits = std::bitset<N>;\ntemplate <class T>\nusing Queue = std::queue<T>;\ntemplate <class T>\nusing Stack = std::stack<T>;\ntemplate <class T>\nusing Deque = std::deque<T>;\n\ntemplate <class T>\nusing MaxHeap = std::priority_queue<T>;\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T>\nusing Set = std::set<T>;\ntemplate <class T, class U>\nusing Map = std::map<T, U>;\n\ntemplate <class T, class... Us>\nusing Func = std::function<T(Us...)>;\n\ntemplate <class T>\nT genv(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto genv(size_t l, Ts... ts) {\n    return Vector<decltype(genv<T>(ts...))>(l, genv<T>(ts...));\n}\n\ntemplate <class Cost = Int>\nstruct Edge {\n    Int src, dst;\n    Cost cost;\n    Edge(Int src = -1, Int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = Int>\nusing Edges = Vector<Edge<Cost>>;\ntemplate <class Cost = Int>\nusing Graph = Vector<Vector<Edge<Cost>>>;\n\n#endif\n\n/* ----- Misc ----- */\nvoid fastio() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n}\n\nstruct Fout {\n    Int precision;\n    Fout(Int precision) : precision(precision) {}\n};\nstd::ostream& operator<<(std::ostream& os, const Fout& fio) {\n    os << std::fixed << std::setprecision(fio.precision);\n    return os;\n}\n\n\n/* ----- Constants ----- */\nconstexpr Int INF = std::numeric_limits<Int>::max() / 20;\n// constexpr Int MOD = 1000000007;\n// constexpr Real PI = acos(-1);\n// constexpr Real EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\nconst Vector<Int> dx{-1, 0, 1, 0}, dy{0, 1, 0, -1};\n\nBool solve() {\n    Int w, h;\n    std::cin >> w >> h;\n    if (w == 0) return false;\n\n    Vector<String> c(h);\n    for (auto& s : c) std::cin >> s;\n\n    Vector<Pair<Int, Int>> ps;\n    for (Int x = 0; x < h; ++x) {\n        for (Int y = 0; y < w; ++y) {\n            if (c[x][y] == '*') {\n                ps.emplace_back(x, y);\n            } else if (c[x][y] == 'o') {\n                ps.emplace(ps.begin(), x, y);\n            }\n        }\n    }\n\n    Int k = ps.size();\n    Vector<Vector<Int>> dist(k, Vector<Int>(k));\n    for (Int i = 0; i < k; ++i) {\n        Int sx, sy;\n        std::tie(sx, sy) = ps[i];\n\n        Vector<Vector<Int>> dp(h, Vector<Int>(w, INF));\n        dp[sx][sy] = 0;\n        Queue<Pair<Int, Int>> que;\n        que.emplace(sx, sy);\n\n        while (!que.empty()) {\n            Int x, y;\n            std::tie(x, y) = que.front();\n            que.pop();\n\n            for (Int d = 0; d < 4; ++d) {\n                Int nx = x + dx[d], ny = y + dy[d];\n                if (nx < 0 || h <= nx || ny < 0 || w <= ny ||\n                    c[nx][ny] == 'x' || dp[nx][ny] < INF) continue;\n\n                dp[nx][ny] = dp[x][y] + 1;\n                que.emplace(nx, ny);\n            }\n        }\n\n        for (Int j = 0; j < k; ++j) {\n            Int gx, gy;\n            std::tie(gx, gy) = ps[j];\n            dist[i][j] = dp[gx][gy];\n        }\n    }\n\n    Int ans = INF;\n    Vector<Int> order(k);\n    std::iota(order.begin(), order.end(), 0);\n    do {\n        Int d = 0;\n        for (Int i = 0; i < k - 1; ++i) {\n            d += dist[order[i]][order[i + 1]];\n        }\n        ans = std::min(ans, d);\n    } while (std::next_permutation(++order.begin(), order.end()));\n\n    std::cout << (ans == INF ? -1 : ans) << std::endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing Ti = tuple<int, int, int>;\nusing Tl = tuple<ll, ll, ll>;\n \n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define Get(t, i) get<(i)>((t))\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n \nconst int inf = 1 << 25;\nconst ll INF = 1LL << 55;\n\nint w, h;\nchar c[22][22];\nint d[22][22][1<<10];\nint sx, sy;\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\n\ntypedef pair<Pi, Pi> PP;\n\nint bfs(int n)\n{\n  memset(d, -1, sizeof(d));\n  queue<PP> que;\n  d[sy][sx][(1<<n)-1] = 0;\n  que.push(PP(Pi(sx, sy), Pi((1<<n)-1, 0)));\n  while(!que.empty()) {\n    PP p = que.front(); que.pop();\n    int x = p.F.F, y = p.F.S, vis = p.S.F, cost = p.S.S;\n    if(vis == 0) return cost;\n    rep(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      int nvis = (isdigit(c[ny][nx]) ? vis & ~(1<<(c[ny][nx]-'0')) : vis);\n      if(0 <= nx && nx < w && 0 <= ny && ny < h && c[ny][nx] != 'x' && d[ny][nx][nvis] == -1) {\n\td[ny][nx][nvis] = d[y][x][vis] + 1;\n\tque.push(PP(Pi(nx, ny), Pi(nvis, d[ny][nx][nvis])));\n      }\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  while(cin >> w >> h, w) {\n    int cnt = 0;\n    rep(i, h) rep(j, w) {\n      cin >> c[i][j];\n      if(c[i][j] == '*') c[i][j] = cnt+'0', cnt++;\n      if(c[i][j] == 'o') sx = j, sy = i;\n    }\n    cout << bfs(cnt) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint h, w, k[20][20], cnt;\nint cx[11], cy[11], y[11][11], z[11][11], bfs[21][21], a, b, c[10], sum, minx;\nchar p;\nqueue<int>Q;\n\nvoid BFS() {\n\twhile (!Q.empty()) {\n\t\ta = Q.front() / 20;\n\t\tb = Q.front() % 20;\n\t\tif (k[a - 1][b] == 0 && bfs[a - 1][b] >= 1000000) {\n\t\t\tQ.push(Q.front() - 20);\n\t\t\tbfs[a - 1][b] = bfs[a][b] + 1;\n\t\t}\n\t\tif (k[a + 1][b] == 0 && bfs[a + 1][b] >= 1000000) {\n\t\t\tQ.push(Q.front() + 20);\n\t\t\tbfs[a + 1][b] = bfs[a][b] + 1;\n\t\t}\n\t\tif (k[a][b + 1] == 0 && bfs[a][b + 1] >= 1000000) {\n\t\t\tQ.push(Q.front() + 1);\n\t\t\tbfs[a][b + 1] = bfs[a][b] + 1;\n\t\t}\n\t\tif (k[a][b - 1] == 0 && bfs[a][b - 1] >= 1000000) {\n\t\t\tQ.push(Q.front() - 1);\n\t\t\tbfs[a][b - 1] = bfs[a][b] + 1;\n\t\t}\n\t\tQ.pop();\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tmemset(z, 0, sizeof(z));\n\t\tcin >> w >> h; cnt = 1; if (!w) { break; }\n\t\tfor (int i = 0; i < 21; i++) { for (int j = 0; j < 21; j++) { k[i][j] = 1; } }\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tcin >> p;\n\t\t\t\tif (p != 'x') { k[i][j] = 0; }\n\t\t\t\tif (p == '*') { cx[cnt] = j; cy[cnt] = i; cnt++; }\n\t\t\t\tif (p == 'o') { cx[0] = j; cy[0] = i; }\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\tc[i] = i;\n\t\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\t\tmemset(bfs, 10, sizeof(bfs));\n\t\t\t\tbfs[cy[i]][cx[i]] = 0;\n\t\t\t\tQ.push(cy[i] * 20 + cx[i]);\n\t\t\t\tBFS();\n\t\t\t\tz[i][j] = bfs[cy[j]][cx[j]];\n\t\t\t}\n\t\t}\n\t\tminx = 114514;\n\t\tdo\n\t\t{\n\t\t\tsum = z[0][c[0] + 1];\n\t\t\tfor (int i = 0; i < cnt; i++) { sum += z[c[i] + 1][c[i + 1] + 1]; }\n\t\t\tminx = min(minx, sum);\n\t\t} while (next_permutation(c, c + cnt - 1));\n\t\tif (minx == 114514) { minx = -1; }\n\t\tcout << minx << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n\n \nusing namespace std;\n \n#define INF 1000000000\n#define EPS 1e-9\n#define PI acos(-1)\n \ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define MAX_W 20\n#define MAX_H 20\n#define MAX_M 10\n\nint W, H;\nint M;\n\nvector<int> ans_list;\n\nchar maze[MAX_H][MAX_W];\nint sx, sy;\nint gx[MAX_M], gy[MAX_M];\n\nint memo[1 << 10];\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint dp[11][MAX_H][MAX_W];\n\nvoid maze_solve(){\n  for(int i = 0; i < 11; i++){\n    for(int j = 0; j < H; j++){\n      for(int k = 0; k < W; k++){\n\tdp[i][j][k] = INF;\n      }\n    }\n  }\n\n  for(int num = 0; num < M+1; num++){\n    queue<P> que;\n    que.push(P(gx[num], gy[num]));\n    dp[num][gy[num]][gx[num]] = 0;\n    while(que.size()){\n      P p = que.front();\n      que.pop();\n      int x = p.first;\n      int y = p.second;\n      for(int i = 0; i < 4; i++){\n\tint nx = x + dx[i];\n\tint ny = y + dy[i];\n\tif(nx >= 0 && nx < W && ny >= 0 && ny < H && dp[num][ny][nx] == INF && maze[ny][nx] != 'x'){\n\t  dp[num][ny][nx] = dp[num][y][x] + 1;\n\t  que.push(P(nx, ny));\n\t}\n      }\n    }\n  }\n\n}\n\nint solve(int S, int x, int y, int per){\n  \n  if(memo[S] >= 0){\n    return memo[S];\n  }\n\n  if(S == (1 << M)-1)\n    return 0;\n  \n  int ret = INF;\n\n  for(int num = 0; num < M; num++){\n    if(per == -1){\n      for(int i = 0; i < M; i++){\n\tif(!(S >> i & 1)){\n\t  ret = min(ret, dp[M][gy[i]][gx[i]] + solve(S | (1 << i), gx[i], gy[i], i));\n\t}\n      }\n    }\n    else{\n      for(int i = 0; i < M; i++){\n\tif(!(S >> i & 1)){\n\t  ret = min(ret, dp[per][gy[i]][gx[i]] + solve(S | (1 << i), gx[i], gy[i], i));\n\t}\n      }\n    }\n  }\n\n  return memo[S] = ret;\n\n}\n\nint main(){\n\n  while(true){\n\n    M = 0;\n    memset(memo, -1, sizeof(memo));\n\n    cin >> W >> H;\n    if(W == 0 && H == 0)\n      break;\n\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n\tcin >> maze[i][j];\n\tif(maze[i][j] == 'o'){\n\t  sy = i;\n\t  sx = j;\n\t}\n\telse if(maze[i][j] == '*'){\n\t  gy[M] = i;\n\t  gx[M] = j;\n\t  M++;\n\t}\n      }\n    }\n    gy[M] = sy;\n    gx[M] = sx;\n\n    maze_solve();\n    ans_list.push_back(solve(0,sx,sy, -1));\n\n  }\n \n  for(int i = 0; i < ans_list.size(); i++){\n    int tmp = ans_list[i];\n    if(tmp >= INF)\n      cout << -1 << endl;\n    else\n      cout << tmp << endl;\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nchar mp[20][20];\nint dist[20][20];\nbool seen[20][20];\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\nconst int inf = 1<<29;\n\nvoid rec(vector< vector<int> > &Y, int i, int S, vector<int> &path) {\n  if(S != 0) rec(Y, Y[i][S], S& ~(1<<i), path);\n  path.push_back(i);\n}\n\nint tsp(int start,vector< vector<int> > G) {\n  const int n = G.size(), N = 1<<n;\n  int i,j;\n  vector< vector<int> > X(n, vector<int>(N, inf));\n  vector< vector<int> > Y(n, vector<int>(N, -1));\n  vector<int> result;\n  rep(i,n) {\n    X[i][1<<i] = G[start][i];\n    Y[i][1<<i] = start;\n  }\n\n  for(int S = 1; S < N; ++S) {\n    rep(i,n) {\n      if(!(S & (1<<i))) continue;\n      rep(j,n) {\n\tif(S & (1<<j)) continue;\n\tif(X[j][S|(1<<j)] > X[i][S]+G[i][j]) {\n\t  X[j][S|(1<<j)] = X[i][S]+G[i][j];\n\t  Y[j][S|(1<<j)] = i;\n\t}\n      }\n    }\n  }\n\n\n  result.clear();\n  if(X[start].back() >= inf) return -1;\n  rec(Y, start, (1<<n)-1, result);\n  int mm = inf;\n  rep(i,n) {\n    mm = min(X[i].back(), mm);\n  }\n  return mm;\n  //return X[start].back() - mm;\n}\n\nint main() {\n  int w,h,i,j,k,l,objnum;\n  string s;\n  while(cin>>w>>h, w|h) {\n    objnum = 1;\n    rep(i,h) {\n      cin>>s;\n      rep(j,w) {\n\tmp[i][j] = s[j];\n\tif(s[j] == 'o') mp[i][j] = 0;\n\tif(s[j] == '*') mp[i][j] = objnum++;\n      }\n    }\n\n    vector<vector<int> > G(objnum, vector<int>(objnum, inf));\n    rep(i,objnum) G[i][i] = 0;\n    rep(i,objnum) {\n      int sx,sy;\n      rep(j,h) rep(k,w) if(mp[j][k] == i) sx = k, sy = j;\n      memset(dist, -1, sizeof(dist));\n      memset(seen, false, sizeof(seen));\n      queue<pair<int,int> > Q;\n      Q.push(make_pair(sy,sx));\n      seen[sy][sx] = true;\n      dist[sy][sx] = 0;\n      while(!Q.empty()) {\n\tint x = Q.front().second,y = Q.front().first; Q.pop();\n\trep(l,4) {\n\t  int nx = x+dx[l],ny = y+dy[l];\n\t  if(nx < 0 || nx >= w || ny < 0 || ny >= h || seen[ny][nx]) continue;\n\t  if(mp[ny][nx] == 'x') continue;\n          if(dist[ny][nx] == -1) dist[ny][nx] = dist[y][x]+1;\n\t  else dist[ny][nx] = min(dist[ny][nx],dist[y][x]+1);\n\t  seen[ny][nx] = true;\n\t  Q.push(make_pair(ny,nx));\n\t}\n      }\n\n      rep(j,h) rep(k,w) {\n\tif(0 <= mp[j][k] && mp[j][k] <= objnum) {\n\t  if(dist[j][k] == -1) continue;\n\t  G[mp[j][k]][i] = G[i][mp[j][k]] = dist[j][k];\n\t}\n      }\n    }\n\n      long long ans = tsp(0,G);\n      if(ans >= inf) cout<<-1<<endl;\n      else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000009;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-4;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nchar c[22][22];\nint w, h;\nint sx, sy;\nvector<P> v;\nvoid init() {\n\tv.clear();\n\trep(i, 22) {\n\t\trep(j, 22) {\n\t\t\tc[i][j] = 'x';\n\t\t}\n\t}\n\trep1(i, h) {\n\t\trep1(j, w) {\n\t\t\tcin >> c[i][j];\n\t\t\tif (c[i][j] == 'o') {\n\t\t\t\tsx = i; sy = j;\n\t\t\t}\n\t\t\telse if (c[i][j] == '*') {\n\t\t\t\tv.push_back({ i,j });\n\t\t\t}\n\t\t}\n\t}\n}\nint d[22][22][22][22];\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\nvoid make_distance() {\n\trep(i, 22) {\n\t\trep(j, 22) {\n\t\t\trep(k, 22) {\n\t\t\t\trep(l, 22)d[i][j][k][l] = mod;\n\t\t\t}\n\t\t}\n\t}\n\trep1(i, h) {\n\t\trep1(j, w) {\n\t\t\trep(k, 4) {\n\t\t\t\tint ni = i + dx[k], nj = j + dy[k];\n\t\t\t\tif (c[i][j] == 'x' || c[ni][nj] == 'x')continue;\n\t\t\t\td[i][j][ni][nj] = 1;\n\t\t\t}\n\t\t}\n\t}\n\trep1(k1, h) {\n\t\trep1(k2, w) {\n\t\t\trep1(i1, h) {\n\t\t\t\trep1(i2, w) {\n\t\t\t\t\trep1(j1, h) {\n\t\t\t\t\t\trep1(j2, w) {\n\t\t\t\t\t\t\td[i1][i2][j1][j2] = min(d[i1][i2][j1][j2], d[i1][i2][k1][k2] + d[k1][k2][j1][j2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nbool valid() {\n\trep(i, v.size()) {\n\t\tif (d[sx][sy][v[i].first][v[i].second] == mod)return false;\n\t}\n\treturn true;\n}\nstruct vertice {\n\tint id, use, dis;\n\tbool operator<(const vertice &v)const {\n\t\tif (v.dis != dis)return v.dis < dis;\n\t\tif (v.id != id)return v.id < id;\n\t\treturn v.use < use;\n\t}\n};\nvoid run_bitdp() {\n\tint dp[10][1 << 10];\n\tint n = v.size();\n\trep(i, n) {\n\t\trep(j, (1 << n)) {\n\t\t\tdp[i][j] = mod;\n\t\t}\n\t}\n\tpriority_queue<vertice> q;\n\trep(i, n) {\n\t\tq.push({ i,(1 << i),d[sx][sy][v[i].first][v[i].second] });\n\t\tdp[i][1 << i] = d[sx][sy][v[i].first][v[i].second];\n\t}\n\twhile (!q.empty()) {\n\t\tvertice x = q.top(); q.pop();\n\t\tif (x.use == (1 << n) - 1)continue;\n\t\trep(i, n) {\n\t\t\tif (x.use&(1 << i))continue;\n\t\t\tint to = x.use ^ (1 << i);\n\t\t\tint nd = x.dis + d[v[x.id].first][v[x.id].second][v[i].first][v[i].second];\n\t\t\tif (nd < dp[i][to]) {\n\t\t\t\tdp[i][to] = nd; q.push({ i,to,nd });\n\t\t\t}\n\t\t}\n\t}\n\tint out = mod;\n\trep(i, n) {\n\t\tout = min(out, dp[i][(1 << n) - 1]);\n\t}\n\tcout << out << endl;\n}\nint main(){\n\twhile (cin >> w >> h, w) {\n\t\tinit(); make_distance();\n\t\tif (!valid())cout << -1 << endl;\n\t\telse run_bitdp();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define rep(i,N) for(ll i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nint w, h;\nll d[100][100];\nstring s[100];\nvector<P> vp;\nll dd[100][100];\n\nll dx[] = { 0,1,0,-1 };\nll dy[] = { 1,0,-1,0 };\n\nvoid solve(P p) {\n\tqueue<P> que;\n\tque.push(P(p.first, p.second));\n\trep(i, 100)rep(j, 100)d[i][j] = INF;\n\td[p.first][p.second] = 0;\n\n\twhile (que.size()) {\n\t\tP p = que.front();\n\t\tque.pop();\n\t\tint y = p.first;\n\t\tint x = p.second;\n\t\trep(i, 4) {\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif (ny >= 0 && ny < h&&nx >= 0 && nx < w) {\n\t\t\t\tif (s[ny][nx] != 'x') {\n\t\t\t\t\tif (d[ny][nx] > d[y][x] + 1) {\n\t\t\t\t\t\td[ny][nx] = d[y][x] + 1;\n\t\t\t\t\t\tque.push(P(ny, nx));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main() {\n\twhile (cin >> w >> h&&w + h) {\n\t\tint cnt = 0;\n\t\trep(i, 100)rep(j, 100)if (i != j)dd[i][j] = INF;\n\t\tvp.clear();\n\t\trep(i, h) {\n\t\t\tcin >> s[i];\n\t\t\trep(j, w) {\n\t\t\t\tif (s[i][j] == 'o' || s[i][j] == '*') {\n\t\t\t\t\tvp.push_back(P(i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, vp.size()) {\n\t\t\tsolve(vp[i]);\n\t\t\trep(j, vp.size()) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tdd[i][j] = d[vp[j].first][vp[j].second];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//rep(i, vp.size()) {\n\t\t//\trep(j, vp.size()) {\n\t\t//\t\tif (dd[i][j] == INF)cout << -1 << \" \";\n\t\t//\t\telse cout << dd[i][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\t//cout << endl;\n\t\tll ans = INF;\n\t\tvector<int> vi;\n\t\trep(i, vp.size())vi.push_back(i);\n\t\tsort(ALL(vi));\n\t\tdo {\n\t\t\tif (vi[0] != 0)continue;\n\t\t\tll sum = 0;\n\t\t\trep(i, vi.size() - 1) {\n\t\t\t\tsum += dd[vi[i]][vi[i + 1]];\n\t\t\t}\n\t\t\tans = min(ans, sum);\n\t\t} while (next_permutation(ALL(vi)));\n\t\tif (ans >= INF)cout << -1 << endl;\n\t\telse cout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string.h>\n#define f first\n#define s second\n#define inf 100000001\nusing namespace std;\n\nint w,h,d[20][20],ii,sum,map[20][20],a,dp[1<<12][20];\nint x[4]={1,-1,0,0};\nint y[4]={0,0,1,-1};\nchar c[20][20];\nvector<pair<int,int> > v;\npair<int,int> u;\nqueue<pair<int,int> > q;\n\nbool in(int a,int b)\n{\n  if(a<0 || b<0 || a>=h || b>=w)return false;\n  return true;\n}\n/*\nvoid solve()\n{\n  for(int S=0;S<1<<a;S++){\n    fill(dp[S],dp[S]+a,inf);\n  }\n  dp[(1<<a)-1][0]=0;\n\n  for(int S=(1<<a)-2;S>=0;S--){\n    for(int v=0;v<a;v++){\n      for(int u=0;u<a;u++){\n\tif(!(S>>u & 1)){\n\t  dp[S][v]=min(dp[S][v],dp[S|1<<u][u]+map[v][u]);\n\t}\n      }\n    }\n  }\n  int ans=inf;\n  for(int i=1;i<a;i++)ans=min(ans,dp[0][i]);\n  if(ans>=inf)cout<<-1<<endl;\n  cout<<ans<<endl;\n}\n*/\n\nint rec(int S,int v)\n{\n  if(dp[S][v]>=0){\n    return dp[S][v];\n  }\n  if(S==(1<<a)-1 && v==0){\n    return dp[S][v]=0;\n  }\n  int res=inf;\n  for(int i=0;i<a;i++){\n    if(!(S>>i&1)){\n      res=min(res,rec(S|1<<i,i)+map[v][i]);\n    }\n  }\n  return dp[S][v]=res;\n}\n\nint main()\n{\n  while(1){\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    v.clear();\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>c[i][j];\n\tif(c[i][j]=='o')v.push_back(make_pair(i,j));\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(c[i][j]=='*')v.push_back(make_pair(i,j));\n      }\n    }\n    for(int i=0;i<20;i++){\n      for(int j=0;j<20;j++)map[i][j]=0;\n    }\n    for(int k=0;k<v.size();k++){\n      q.push(make_pair(v[k].f,v[k].s));\n      for(int i=0;i<20;i++){\n\tfor(int j=0;j<20;j++)d[i][j]=inf;\n      }\n      d[v[k].f][v[k].s]=0;\n      while(!q.empty()){\n\tu=q.front();q.pop();\n\tfor(int i=0;i<4;i++){\n\t  int xx=u.f+x[i],yy=u.s+y[i];\n\t  if(in(xx,yy)){\n\t    if(d[xx][yy]!=inf)continue;\n\t    if(c[xx][yy]!='x'){\n\t      q.push(make_pair(xx,yy));\n\t      d[xx][yy]=d[u.f][u.s]+1;\n\t    }\n\t  }\n\t}\n      }\n      for(int i=0;i<v.size();i++)map[k][i]=d[v[i].f][v[i].s];\n    }\n    a=v.size();\n    memset(dp,-1,sizeof(dp));\n    int ans=inf;\n    for(int i=1;i<a;i++){\n      ans=min(ans,rec(0,i));\n    }\n    if(ans>=inf)cout<<-1<<endl;\n    else cout<<ans<<endl;\n      //solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\n#define REP(i,a,b) for(i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\n#define ll long long\n#define ull unsigned ll\ntypedef long double ld;\n#define ALL(a) (a).begin(),(a).end()\n#define ifnot(a) if(not a)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\nusing namespace std;\n\nvoid reader(int &a) { scanf(\"%d\", &a); }\nvoid reader(double &a) { scanf(\"%lf\", &a); }\nvoid reader(char a[]) { scanf(\"%s\", a); }\nvoid reader(char &a) { scanf(\" %c\", &a); }\nvoid reader(ll &a) { scanf(\"%lld\", &a); }\nvoid reader(ull &a) { scanf(\"%llu\", &a); }\n// void reader(string& a){cin >> a;};\ntemplate<class T, class U> void reader(T& t, U& u) { reader(t); reader(u); }\ntemplate<class T, class U, class V> void reader(T& t, U& u, V& v) { reader(t); reader(u); reader(v); }\n\nvoid writer(const int a, char c) { printf(\"%d\", a); putchar(c); }\nvoid writer(const ll a, char c) { printf(\"%lld\", a); putchar(c); }\nvoid writer(const ull a, char c) { printf(\"%llu\", a); putchar(c); }\nvoid writer(const double a, char c) { printf(\"%.20lf\", a); putchar(c); }\nvoid writer(const char a[]) { printf(\"%s\", a); };\nvoid writer(const char a[], char c) { printf(\"%s\", a); putchar(c); };\nvoid writer(const char a, char c) { putchar(a); putchar(c); };\ntemplate<class T> void writerLn(T t) { writer(t, '\\n'); }\ntemplate<class T, class U> void writerLn(T t, U u) { writer(t, ' '); writer(u, '\\n'); }\ntemplate<class T, class U, class V> void writerLn(T t, U u, V v) { writer(t, ' '); writer(u, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerVec(vector<T> x) { int n = x.size(); int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\n\nvector<string> split(const string &str, char sep) { vector<string> v; stringstream ss(str); string buffer; while (getline(ss, buffer, sep)) { v.push_back(buffer); }return v; }\n// #define int ll\nbool test = 0;\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n#define INF (1 << 28)\null mod = (int)1e9 + 7;\n//.....................\n#define MAX 22\n\n\n\nstruct Node {\n\tint y, x;\n};\nint w, h;\nchar c[MAX][MAX];\nint dm[MAX][MAX];\nvector<Node> nodes;\nint start;\nbool create_distace_matrix() {\n\tint i, j, k;\n\tint y, x;\n\tint cf[MAX][MAX];\n\trep(i, nodes.size()) {\n\t\trep(y, h) rep(x, w) {\n\t\t\tif (c[y][x] == 'x') cf[y][x] = -2;\n\t\t\telse cf[y][x] = -1;\n\t\t}\n\n\t\tcf[nodes[i].y][nodes[i].x] = 0;\n\t\tbool changed = true;\n\t\tint current = 0;\n\t\tfor (; changed; current += 1) {\n\t\t\tchanged = false;\n\t\t\trep(y, h) rep(x, w) {\n\t\t\t\tif (cf[y][x] == current) {\n\t\t\t\t\trep(j, 4) {\n\t\t\t\t\t\tint ny = y + dy[j];\n\t\t\t\t\t\tint nx = x + dx[j];\n\t\t\t\t\t\tif (ny < 0 || h <= ny) continue;\n\t\t\t\t\t\tif (nx < 0 || w <= nx) continue;\n\t\t\t\t\t\tif (cf[ny][nx] == -1) cf[ny][nx] = current + 1;\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(j, nodes.size()) {\n\t\t\tint distance = cf[nodes[j].y][nodes[j].x];\n\t\t\tif (distance < 0) return false;\n\t\t\tdm[i][j] = distance;\n\t\t}\n\t}\n\treturn true;\n}\nbool done[MAX];\nint ans;\nvoid rec(int n, int idx, int sum) {\n\tint i;\n\tif (sum >= ans) return;\n\tif (n == nodes.size()) {\n\t\tif (sum < ans) ans = sum;\n\t\treturn;\n\t}\n\trep(i, nodes.size()) {\n\t\tif (done[i]) continue;\n\t\tdone[i] = true;\n\t\trec(n + 1, i, sum + dm[idx][i]);\n\t\tdone[i] = false;\n\t}\n}\nsigned main(void)\n{\n\tint i, j, k, l;\n\twhile (1) {\n\t\tcin >> w >> h;\n\t\tif (w == 0) return 0;\n\t\trep(i, h) reader(c[i]);\n\t\tnodes.clear();\n\t\trep(i, h) rep(j, w) {\n\t\t\tif (c[i][j] == 'o') start = nodes.size();\n\t\t\tif (c[i][j] == 'o' || c[i][j] == '*') {\n\t\t\t\tnodes.push_back({ i,j });\n\t\t\t}\n\t\t}\n\t\tif (!create_distace_matrix()) {\n\t\t\tcout << -1 << endl;\n\t\t\tcerr << \"????????????\" << endl;\n\t\t}\n\t\tans = INT_MAX;\n\t\tdone[start] = true;\n\t\trec(1, start, 0);\n\t\tcout << ans << endl;\n\t\tdone[start] = false;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> Pa;\n\nint dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nconst int inf = 99999;\n\nbool bfs(char a[21][21], int w, int h, Pa pa[12], int p, int dis[12][12])\n{\n\tbool f = false;\n\tfor(int k = 0; k < p-1 ; k++){\n\t\tbool vis[21][21];\n\t\tint d[21][21];\n\t\tqueue<Pa> que;\n\t\tPa t;\n\t\tint s = p-k-1;\n\t\t\n\t\tfill(&d[0][0], &d[h][w], 0);\n\t\tfill(&vis[0][0], &vis[h][w], true);\n\t\ta[pa[k].first][pa[k].second] = '.';\n\t\tque.push(pa[k]);\n\t\tvis[t.first][t.second] = false;\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tt = que.front();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tfor(int i = k+1; i < p; i++){\n\t\t\t\tif(pa[i].first == t.first && pa[i].second == t.second){\n\t\t\t\t\tdis[k][i] = dis[i][k] = d[t.first][t.second];\n\t\t\t\t\ts--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s == 0){\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint u = t.second+dx[i], v = t.first+dy[i];\n\t\t\t\tif(0 <= u && u < w && 0 <= v && v < h){\n\t\t\t\t\tif(vis[v][u] && a[v][u] != 'x'){\n\t\t\t\t\t\tque.push(Pa(v, u));\n\t\t\t\t\t\td[v][u] = d[t.first][t.second]+1;\n\t\t\t\t\t\tvis[v][u] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn f;\n}\n\n/*\nint shp(int dis[12][12], int p)\n{\n\tint dp[1<<12][12], n = 1<<p;\n\tfill(&dp[0][0], &dp[(1<<12)-1][11], inf);\n\tdp[1<<0][0] = 0;\n\t\n\tfor(int i = 1<<0; i < n; i++){\n\t\tfor(int j = 0; j < p; j++){\n\t\t\tif(i&(1<<j)){\n\t\t\t\tfor(int k = 0; k < p; k++){\n\t\t\t\t\tif(dp[i|(1<<k)][k] > dp[i][j]+dis[j][k]){\n\t\t\t\t\t\tdp[i|(1<<k)][k] = dp[i][j]+dis[j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint t = min_element(dp[n-1], dp[n-1]+p)-dp[n-1];\n\t\n\treturn dp[n-1][t];\n}\n*/\n\nint main()\n{\n\tint h, w;\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0){\n\t\t\tbreak;\n\t\t}\n\t\tint p=1, dis[12][12];\n\t\tchar a[21][21];\n\t\tPa pa[12];\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tcin >> a[i];\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(a[i][j] == 'o'){\n\t\t\t\t\tpa[0] = Pa(i, j);\n\t\t\t\t}\n\t\t\t\tif(a[i][j] == '*'){\n\t\t\t\t\tpa[p++] = Pa(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfill(&dis[0][0], &dis[p][p], inf);\t\n\t\tfor(int i = 0; i < p; i++){\n\t\t\tdis[i][i] = 0;\n\t\t}\n\t\tif(p == 1){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif(bfs(a, w, h, pa, p, dis)){\n\t\t\t// cout << shp(dis, p) << endl;\n\t\t\tint d[12];\n\t\t\tfor(int i = 0; i < p-1; i++){\n\t\t\t\td[i] = i+1;\n\t\t\t}\n\t\t\tint r = inf;\n\t\t\tdo{\n\t\t\t\tint v = dis[0][d[0]];\n\t\t\t\tfor(int i = 1; i < p-1; i++){\n\t\t\t\t\tv += dis[d[i-1]][d[i]];\n\t\t\t\t}\n\t\t\t\tr = min(r, v);\n\t\t\t}while(next_permutation(d, d+(p-1)));\n\t\t\t\n\t\t\tcout << r << endl;\n\t\t} else {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <queue>\n\nusing namespace std;\n\nint main(){\n\n    while(true){\n        int w, h;\n        cin >> w >> h;\n\n        if(w == 0){\n            break;\n        }\n\n        vector<string> c(h);\n        for(int i = 0; i < h; i++){\n            cin >> c[i];\n        }\n\n        vector<pair<int, int>> dirtyPos(1);\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                if(c[i][j] == '*'){\n                    dirtyPos.emplace_back(make_pair(j, i));\n                }\n                else if(c[i][j] == 'o'){\n                    dirtyPos[0] = make_pair(j, i);\n                }\n            }\n        }\n\n        int dirtyCnt = (int)dirtyPos.size();\n        vector<vector<int>> dist(dirtyCnt, vector<int>(dirtyCnt, -1));\n\n        int dx[] = {1, 0, -1, 0};\n        int dy[] = {0, 1, 0, -1};\n        bool isOk = true;\n        for(int i = 0; i < dirtyCnt; i++){\n            vector<vector<int>> cellDist(h, vector<int>(w, -1));\n\n            queue<pair<pair<int, int>, int>> q;\n            cellDist[dirtyPos[i].second][dirtyPos[i].first] = 0;\n            q.push(make_pair(dirtyPos[i], 0));\n            while(!q.empty()){\n                auto temp = q.front();\n                q.pop();\n                int x = temp.first.first;\n                int y = temp.first.second;\n                int tempDist = temp.second;\n                for(int j = 0; j < 4; j++){\n                    int nx = x + dx[j];\n                    int ny = y + dy[j];\n                    if(0 <= nx && nx < w && 0 <= ny && ny < h && c[ny][nx] != 'x'){\n                        if(cellDist[ny][nx] == -1){\n                            cellDist[ny][nx] = tempDist + 1;\n                            q.push(make_pair(make_pair(nx, ny), tempDist + 1));\n                        }\n                    }\n                }\n            }\n\n            for(int j = 0; j < dirtyCnt; j++){\n                auto pos = dirtyPos[j];\n                dist[i][j] = cellDist[pos.second][pos.first];\n                if(dist[i][j] == -1){\n                    isOk = false;\n                    break;\n                }\n            }\n\n            if(!isOk){\n                break;\n            }\n        }\n\n        if(!isOk){\n            cout << -1 << endl;\n        }\n        else{\n            vector<int> order(dirtyCnt - 1);\n            for(int i = 0; i < dirtyCnt - 1; i++){\n                order[i] = i + 1;\n            }\n\n            int ans = 1 << 30;\n            do{\n\n                int beforeIndex = 0;\n                int tempSum = 0;\n                for(int i = 0; i < dirtyCnt - 1; i++){\n                    int nextIndex = order[i];\n\n                    tempSum += dist[beforeIndex][nextIndex];\n\n                    beforeIndex = nextIndex;\n                }\n\n                ans = min(ans, tempSum);\n\n            }while(next_permutation(order.begin(), order.end()));\n\n            cout << ans << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &&x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define INSEG(l,x,r) ((l)<=(x)&&(x)<(r))\n#define dump(...)\n#define pb push_back\n#define _ 0\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T, class U> bool chmax(T &a,const U &b){return a<b?a=b,1:0;}\ntemplate<class T, class U> bool chmin(T &a,const U &b){return a>b?a=b,1:0;}\ntemplate <class T> void PSUM(T& c) {partial_sum(begin(c), end(c), begin(c));}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0); ios::sync_with_stdio(false);\n        cout << setprecision(15) << fixed;\n        // #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nsigned main() {\n    while (1) {\n        int w, h;\n        cin >> w >> h;\n        if (w == 0 && h == 0) {\n            break;\n        }\n\n        vector<string> S(h);\n        cin >> S;\n\n        vector<pii> dirty;\n        int rx, ry;\n        REP(i, h) {\n            REP(j, w) {\n                if (S[i][j] == '*') dirty.push_back({i, j});\n                if (S[i][j] == 'o') ry = i, rx = j;\n            }\n        }\n        dirty.push_back({ry, rx});\n\n        int m = SZ(dirty);\n        vector<vector<int>> dist(m, vector<int>(m, INF));\n        REP(i, m) {\n            queue<pii> q;\n            q.push(dirty[i]);\n            vector<vector<int>> d(h, vector<int>(w, INF));\n            d[dirty[i].first][dirty[i].second] = 0;\n            while (!q.empty()) {\n                int y = q.front().first;\n                int x = q.front().second; q.pop();\n                REP(dir, 4) {\n                    int yy = y + DY[dir];\n                    int xx = x + DX[dir];\n                    if (INSEG(0, yy, h) && INSEG(0, xx, w) && d[yy][xx] > d[y][x] + 1 && S[yy][xx] != 'x') {\n                        d[yy][xx] = d[y][x] + 1;\n                        q.push({yy, xx});\n                    }\n                }\n            }\n            REP(j, m) {\n                int y = dirty[j].first;\n                int x = dirty[j].second;\n                dist[i][j] = d[y][x];\n            }\n        }\n\n        m--;\n        vector<int> ord(m);\n        REP(i, m) ord[i] = i;\n        int ans = INF;\n        do {\n            int tmp = dist[m][ord[0]];\n            if (tmp >= INF) continue;\n            REP(i, m - 1) {\n                tmp += dist[ord[i]][ord[i + 1]];\n                if (tmp >= INF) {\n                    break;\n                }\n            }\n            chmin(ans, tmp);\n        } while (next_permutation(ALL(ord)));\n        if (ans == INF) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n    return (0^_^0);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nconst int INFTY=1<<29;\n\nvoid bfs(vector<string>& grid,int r,int c,vector<vector<int> >& d)\n{\n\tint h=grid.size(),w=grid[0].size();\n\tqueue<pair<int,int> > q;\n\td[r][c]=0;\n\tq.push(make_pair(r,c));\n\twhile(q.size()){\n\t\tint ci=q.front().first,cj=q.front().second;\n\t\tq.pop();\n\t\tint di[]={-1,1,0,0},dj[]={0,0,-1,1};\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni=ci+di[k],nj=cj+dj[k];\n\t\t\tif(ni<0 || h<=ni || nj<0 || w<=nj)\n\t\t\t\tcontinue;\n\t\t\tif(d[ni][nj]!=INFTY || grid[ni][nj]=='x')\n\t\t\t\tcontinue;\n\t\t\tif(0<=ni && ni<h && 0<=nj && nj<w && d[ni][nj]==INFTY){\n\t\t\t\td[ni][nj]=d[ci][cj]+1;\n\t\t\t\tq.push(make_pair(ni,nj));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tvector<string> grid(h);\n\t\tfor(int i=0;i<h;i++)\n\t\t\tcin>>grid[i];\n\t\tvector<int> rs,cs;\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(grid[i][j]=='o'){\n\t\t\t\t\trs.insert(rs.begin(),i);\n\t\t\t\t\tcs.insert(cs.begin(),j);\n\t\t\t\t}\n\t\t\t\telse if(grid[i][j]=='*'){\n\t\t\t\t\trs.push_back(i);\n\t\t\t\t\tcs.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\tint n=rs.size();\n\t\tvector<vector<int> > dist(n,vector<int>(n));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tvector<vector<int> > d(h,vector<int>(w,INFTY));\n\t\t\tbfs(grid,rs[i],cs[i],d);\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tdist[i][j]=d[rs[j]][cs[j]];\n\t\t}\n\t\t\n\t\tvector<vector<int> > dp(1<<n,vector<int>(n,INFTY));\n\t\tdp[1][0]=0;\n\t\tfor(int i=1;i<(1<<n);i++){\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(!(i&1<<j) || (i&1<<k))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdp[i|1<<k][k]=min(dp[i|1<<k][k],dp[i][j]+dist[j][k]);\n\t\t\t\t}\n\t\t}\n\t\t\n\t\tint res=INFTY;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tres=min(res,dp.back()[i]);\n\t\tcout<<(res==INFTY?-1:res)<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fs first\n#define sc second\ntypedef pair<int,int> P;\nint d[11][11],inf=1e7,idd[20][20],w,h,dh[4]={1,0,-1,0},dw[4]={0,1,0,-1};\nvector<string> vc;\nvoid bfs(int hh,int ww,int id){\n\tint dis[20][20];\n\trep(i,20) rep(j,20) dis[i][j]=inf;\n\tqueue<P> que;\n\tque.push(P(hh,ww));\n\tdis[hh][ww]=0;\n\twhile(!que.empty()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\trep(i,4){\n\t\t\tint nh=p.fs+dh[i],nw=p.sc+dw[i];\n\t\t\tif(0<=nh && nh<h && 0<=nw && nw<w && vc[nh][nw]!='x' && dis[nh][nw]==inf){\n\t\t\t\tque.push(P(nh,nw));\n\t\t\t\tdis[nh][nw]=dis[p.fs][p.sc]+1;\n\t\t\t\tif(idd[nh][nw]!=-1) d[id][idd[nh][nw]]=dis[nh][nw];\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin >> w >> h;\n\t\tif(w==0) break;\n\t\tvc.clear();\n\t\trep(i,h){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tvc.push_back(s);\n\t\t}\n\t\trep(i,11) rep(j,11) d[i][j]=inf;\n\t\tint cnt=1;\n\t\trep(i,h) rep(j,w){\n\t\t\tif(vc[i][j]=='o'){\n\t\t\t\tidd[i][j]=0;\n\t\t\t}else if(vc[i][j]=='*'){\n\t\t\t\tidd[i][j]=cnt;\n\t\t\t\tcnt++;\n\t\t\t}else idd[i][j]=-1;\n\t\t}\n\t\tif(cnt==1){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\trep(i,h) rep(j,w) if(idd[i][j]!=-1) bfs(i,j,idd[i][j]);\n\t\tint a[10];\n\t\trep(i,cnt) a[i]=i;\n\t\tint ans=inf;\n\t\tdo{\n\t\t\tint x=0;\n\t\t\trep(i,cnt-1) x+=d[a[i]][a[i+1]];\n\t\t\tans=min(ans,x);\n\t\t}while(next_permutation(a+1,a+cnt));\n\t\tif(ans==inf) ans=-1;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <complex>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define EPS 1e-8\n#define DEB 0\n\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {-1,0,1,0};\nint w,h,sx,sy;\nchar field[32][32];\nvector<pair<int,int> > t_node;\nint node[16][16],visited[32][32];\nint dp[1<<10][16];\n\nint main(){\n\t\n\twhile(scanf(\" %d%d \",&w,&h),w|h){\n\t\tmemset(node,0,sizeof(node));\n\t\trep(i,1<<10)rep(j,16)dp[i][j]=INT_MAX;\n\t\t\n\t\tt_node.clear();\n\t\trep(i,h){\n\t\t\tscanf(\"%s\",field[i]);\n\t\t\trep(j,w){\n\t\t\t\tif( field[i][j]=='o' ){\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}else if( field[i][j]=='*' ){\n\t\t\t\t\tt_node.push_back(mp(j,i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( t_node.size()==0 ){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tt_node.push_back(mp(sx,sy));\n#if DEB\n\t\trep(i,t_node.size()){\n\t\t\tprintf(\"(%d,%d)\\n\",t_node[i].first, t_node[i].second);\n\t\t}\n#endif\t\n\t\t\n\n\t\t// make node (bfs)\n\t\trep(i,t_node.size()){\n\t\t\tmemset(visited,-1,sizeof(visited));\n\t\t\tqueue<pair<int,int> > q;\n\t\t\tq.push(mp(t_node[i].first, t_node[i].second));\n\t\t\tvisited[t_node[i].second][t_node[i].first] = 0;\n\t\t\twhile( !q.empty() ){\n\t\t\t\tint x = q.front().first;\n\t\t\t\tint y = q.front().second;\n\t\t\t\tint c = visited[y][x];\n\t\t\t\tq.pop();\n\t\t\t\trep(k,4){\n\t\t\t\t\tint tx = x + dx[k];\n\t\t\t\t\tint ty = y + dy[k];\n\t\t\t\t\tif( tx<0 || ty<0 || tx>=w || ty>=h || field[ty][tx]=='x' || visited[ty][tx]!=-1 )continue;\n\t\t\t\t\tvisited[ty][tx] = c+1;\n\t\t\t\t\tq.push(mp(tx,ty));\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t\t\n\t\t\trep(j,t_node.size())if( i!=j ){\n\t\t\t\tnode[i][j] = visited[t_node[j].second][t_node[j].first];\n\t\t\t}\n\t\t}\n\n#if DEB\t\t\n\t\trep(i,t_node.size()){\n\t\t\trep(j,t_node.size()){\n\t\t\t\tprintf(\"%d \",node[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\tputs(\"\");\n#endif\t\t\n\t\t\t\n\n#if DEB\n\t\trep(i,h){\n\t\t\tputs(field[i]);\n\t\t}puts(\"\");\n#endif\n\n\t\tint n = t_node.size();\n\t\tint ans = INT_MAX;\n\t\tdp[0][n-1] = 0;\n\t\trep(i,n-1){ //kosuu\n\t\t\trep(j,1<<(n-1)){ //bit dp\n\t\t\t\trep(k,n)if( dp[j][k]!=INT_MAX ){ //now node\n\t\t\t\t\trep(l,n-1)if( !((1<<l)&j) && node[k][l]>0 ){\n\t\t\t\t\t\tdp[j|(1<<l)][l] = min(dp[j|(1<<l)][l], dp[j][k]+node[k][l]);\n\t\t\t\t\t\tif( (j|(1<<l))==((1<<(n-1))-1) ){\n\t\t\t\t\t\t\tans = min(ans, dp[(1<<(n-1))-1][l]);\n\t\t\t\t\t\t}\n#if DEB\n\t\t\t\t\t\tprintf(\"bit:%d  , %d --> %d  , cost:%d\\n\",j|(1<<l),k,l,dp[j|(1<<l)][l]);\n#endif\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#if DEB\n\t\tprintf(\"%d\\n\",(1<<(n-1))-1);\n#endif\t\t\n\t\tprintf(\"%d\\n\",ans==INT_MAX ? -1 : ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 25;\n\nint w,h;\nchar table[25][25];\n\nint n;\nint row[15],col[15];\nint rel[15][15];\n\ntypedef tuple<int,int,int> state;\n\nint dr[4]={1,0,-1,0};\nint dc[4]={0,1,0,-1};\n\nvoid bfs(int index){\n\tint dist[25][25];\n\trep(i,h)rep(j,w) dist[i][j]=inf;\n\tint sr=row[index],sc=col[index];\n\tdist[sr][sc]=0;\n\tstate init(0,sr,sc);\n\tqueue<state> q;\n\tq.push(init);\n\twhile(!q.empty()){\n\t\tint cost,cr,cc;\n\t\ttie(cost,cr,cc)=q.front();q.pop();\n\t\trep(i,4){\n\t\t\tint nr=cr+dr[i],nc=cc+dc[i],ncost=cost+1;\n\t\t\tif(0<=nr&&nr<h&&0<=nc&&nc<w&&table[nr][nc]!='x'){\n\t\t\t\tif(dist[nr][nc]>ncost){\n\t\t\t\t\tdist[nr][nc]=ncost;\n\t\t\t\t\tstate next(ncost,nr,nc);\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n) rel[index][i]=dist[row[i]][col[i]];\n}\n\n\nint main(void){\n\twhile(cin >> w >> h,w|h){\n\t\trep(i,h)rep(j,w) cin >> table[i][j];\n\t\tn=0;\n\t\trep(i,h)rep(j,w) if(table[i][j]=='o') row[n]=i,col[n]=j,n++;\n\t\trep(i,h)rep(j,w) if(table[i][j]=='*') row[n]=i,col[n]=j,n++;\n\t\trep(i,n) bfs(i);\n\n\t\tint dp[1<<11][11];\n\t\trep(i,1<<n)rep(j,n) dp[i][j]=inf;\n\t\tdp[1][0]=0;\n\t\trep(mask,1<<n)rep(i,n) if(mask&(1<<i)){\n\t\t\trep(j,n){\n\t\t\t\tif(mask&(1<<j)) continue;\n\t\t\t\tint ncost=dp[mask][i]+rel[i][j];\n\t\t\t\tdp[mask|(1<<j)][j]=min(dp[mask|(1<<j)][j],ncost);\n\t\t\t}\n\t\t}\n\t\tint ans=inf;\n\t\trep(i,n) ans=min(ans,dp[(1<<n)-1][i]);\n\t\tif(ans==inf)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct status {\n    int x, y;\n    int dist;\n\n    status() {}\n    ~status() {}\n\n    status(int a, int b): x(a), y(b) {}\n    status(int a, int b, int c): x(a), y(b), dist(c) {}\n};\n\nstruct point {\n    int x, y;\n\n    point() {}\n    ~point() {}\n\n    point(int a, int b): x(a), y(b) {}\n    point(status s): x(s.x), y(s.y) {}\n\n    bool operator < (const point& o) const {\n        return x == o.x ? y < o.y : x < o.x;\n    }\n};\n\nconst int INF = 1 << 29;\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nint bit_count(int x) {\n    int ret = 0;\n    while(x > 0) {\n        ret += x % 2;\n        x >>= 1;\n    }\n    return ret;\n}\n\nbool solve() {\n    int w; // 1 <= w <= 20\n    int h; // 1 <= h <= 20\n    cin >> w >> h;\n\n    if (w == 0 && h == 0) {\n        return false;\n    }\n\n    vector<string> c(h);\n    \n    for (int j = 0; j < h; ++j) {\n        cin >> c[j];\n    }\n\n    map<point, int> ind;\n    int N = 1;\n\n    for (int j = 0; j < h; ++j) {\n        for (int k = 0; k < w; ++k) {\n            if (c[j][k] == '*') {\n                ind[point(j, k)] = N++;\n            }\n            if (c[j][k] == 'o') {\n                ind[point(j, k)] = 0;\n            }\n        }\n    }\n\n    vector<vector<int>> g(N, vector<int>(N, INF));\n    for (int j = 0; j < N; ++j) {\n        g[j][j] = 0;\n    }\n\n    for (auto& pp : ind) {\n        vector<vector<int>> dist(h, vector<int>(w, INF));\n        queue<status> que;\n\n        point start = pp.first;\n        int num = pp.second;\n\n        que.push(status(start.x, start.y, 0));\n        dist[start.x][start.y] = 0;\n\n        while (!que.empty()) {\n            status st = que.front(); que.pop();\n            \n            if (dist[st.x][st.y] < st.dist) {\n                continue;\n            }\n\n            if (c[st.x][st.y] == '*' || c[st.x][st.y] == 'o') {\n                g[num][ind[point(st)]] = st.dist;\n                g[ind[point(st)]][num] = st.dist;\n            }\n\n            for (int j = 0; j < 4; ++j) {\n                int nx = st.x + dx[j];\n                int ny = st.y + dy[j];\n                \n                if (nx < 0 || h <= nx) continue;\n                if (ny < 0 || w <= ny) continue;\n                if (c[nx][ny] == 'x') continue;\n\n                if (dist[nx][ny] > st.dist + 1) {\n                    dist[nx][ny] = st.dist + 1;\n                    \n                    que.push(status(nx, ny, dist[nx][ny]));\n                }\n            }\n        }\n    }\n\n    // for (int j = 0; j < N; ++j) {\n    //     for (int k = 0; k < N ; ++k) {\n    //         cout << g[j][k] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n\n    vector<vector<int>> dp(1 << N, vector<int>(N, INF));\n    dp[1][0] = 0;\n\n    for (int b = 1; b < N; ++b) {\n        for (int j = 0; j < (1 << N); ++j) {\n            if(bit_count(j) != b) continue;\n\n            for (int k = 0; k < N; ++k) {\n                if ((j & (1 << k)) == 0) {\n                    int nj = j | (1 << k);\n\n                    for (int l = 0; l < N; ++l) {\n                        dp[nj][k] = min(dp[nj][k], dp[j][l] + g[k][l]);\n                    }\n                }\n            }\n        }\n    }\n\n    int ret = INF;\n    for (int j = 0; j < N; ++j) {\n        ret = min(ret, dp[(1 << N) - 1][j]);\n    }\n\n    // for (int j = 0; j < (1 << N); ++j) {\n    //     for (int k = 0; k < N; ++k) {\n    //         cout << dp[j][k] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n\n    if (ret == INF) {\n        cout << \"-1\" << endl;\n    } else {\n        cout << ret << endl;\n    }\n\n    return true;\n}\n\n\nint main () {\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define INF (1<<29)\nint dy[]={1,0,-1,0};\nint dx[]={0,1,0,-1};\nint w,h;\nchar map[20][20];\nstruct P{\n\tint y,x;\n};\nint bfs(struct P s,struct P e){\n\tstruct P a,b,que[400];\n\tint head=0,tail=0,i;\n\tint step[20][20];\n\ta=s;\n\tmemset(step,-1,sizeof(step));\t\n\tstep[s.y][s.x]=0;\n\tque[tail++]=a;\n\twhile(head < tail){\n\t\ta=que[head++];\n\t\tfor(i=0;i<4;i++){\n\t\t\tb.y=a.y+dy[i];\n\t\t\tb.x=a.x+dx[i];\n\t\t\tif(b.y<0||h<=b.y||b.x<0||w<=b.x||step[b.y][b.x]!=-1||map[b.y][b.x]=='x')continue;\n\t\t\tif(b.y==e.y && b.x==e.x)return step[a.y][a.x]+1;\n\t\t\tstep[b.y][b.x] = step[a.y][a.x]+1;\n\t\t\tque[tail++] = b;\n\t\t}\n\t}\n\treturn -1;\n}\nint used[11];\nint dist[11][11];\nint n;\nint search(int i,int depth){\n\tint j;\n\tint t,min=INF;\n\tif(depth==n){return 0;}\n\tfor(j=1;j<n;j++){\n\t\tif(used[j])continue;\n\t\tused[j]=1;\n\t\tt = dist[i][j]+search(j,depth+1);\n\t\tused[j]=0;\n\t\tif(t<min)min=t;\n\t}\n\treturn min;\n}\nint main(){\n\tint i,j;\n\tstruct P yogore[11];\n\twhile(scanf(\"%d%d\",&w,&h)==2&&(w|h)){\n\t\tint ans=-1;\n\t\tn=1;\n\t\tscanf(\"\\n\");\n\t\tfor(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tscanf(\"%c\",&map[i][j]);\n\t\t\t\tif(map[i][j]=='*'){\n\t\t\t\t\tyogore[n].y=i;\n\t\t\t\t\tyogore[n].x=j;\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='o'){\n\t\t\t\t\tyogore[0].y=i;\n\t\t\t\t\tyogore[0].x=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"\\n\");\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\tint d=bfs(yogore[i],yogore[j]);\n\t\t\t\tdist[i][j]=dist[j][i]=d;\n\t\t\t\tif(d==-1)goto END;\n\t\t\t}\n\t\t}\n\t\tmemset(used,0,sizeof(used));\n\t\tans=search(0,1);\n\t\tEND:\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void){\n  char map[20][20];\n  int dp[20][20];\n  int i,j,k,l;\n  int w,h;\n  int w0,h0;\n  int count;\n  int min,minw,minh;\n  int sum;\n\n  while(1){\n    scanf(\"%d %d\",&w,&h);\n    if(!w && !h)break;\n\n    count = 0;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tdp[i][j] = -1;\n\tscanf(\" %c \",&map[i][j]);\n\tif(map[i][j]=='o'){\n\t  w0 = j;\n\t  h0 = i;\n\t  dp[i][j] = 0;\n\t}\n\telse if(map[i][j]=='*'){\n\t  count++;\n\t} \n      }\n    }\n\n    sum = 0;\n    for(l=0;l<count;l++){\n      min = 210;\n      for(k=0;k<210;k++){\n\n\tfor(i=0;i<h;i++){\n\t  for(j=0;j<w;j++){\n\t    if(dp[i][j]>=0){\n\t      \n\t      if(i+1<h && map[i+1][j]!='x'){\n\t\tif(dp[i+1][j]<0 || dp[i+1][j]>dp[i][j]+1){\n\t\t  dp[i+1][j] = dp[i][j] + 1;\n\t\t}\n\t      }\n\t      if(i-1>=0 && map[i-1][j]!='x'){\n\t\tif(dp[i-1][j]<0 || dp[i-1][j]>dp[i][j]+1){\n\t\t  dp[i-1][j] = dp[i][j] + 1;\n\t\t}\n\t      }\t\n\t      if(j+1<w && map[i][j+1]!='x'){\n\t\tif(dp[i][j+1]<0 || dp[i][j+1]>dp[i][j]+1){\n\t\t  dp[i][j+1] = dp[i][j] + 1;\n\t\t}\n\t      }\n\t      if(j-1>=0 && map[i][j-1]!='x'){\n\t\tif(dp[i][j-1]<0 || dp[i][j-1]>dp[i][j]+1){\n\t\t  dp[i][j-1] = dp[i][j] + 1;\n\t\t}\n\t      }\n\n\t    }\n\t  }\n\t}\n\n      }\n\n      for(i=0;i<h;i++){\n\tfor(j=0;j<w;j++){\n\t  if(map[i][j]=='*'){\n\t    if(dp[i][j]<min){\n\t      min = dp[i][j];\n\t      minw = j;\n\t      minh = i;\n\t    }\n\t  }\n\t}\n      }\n\n      if(min==210)break;\n      else{\n\tsum += min;\n\tmap[h0][w0] = '.';\n\tw0 = minw;\n\th0 = minh;\n\tmap[h0][w0] = 'o';\n\tfor(i=0;i<h;i++)for(j=0;j<w;j++)dp[i][j] = -1;\n\tdp[h0][w0] = 0;\n      }\n\n    }\n    if(min == 210)printf(\"-1\\n\");\n    else printf(\"%d\\n\",sum);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1140: Cleaning Robot\n// 2017.9.14 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define INF  100000\n#define QMAX 10000\n\ntypedef struct { int r, c, d; } Q;\nQ que[QMAX+3]; int top, end;\n\ntypedef struct { int r, c; } PP;\nPP pp[12]; int n;\nchar map[22][22], mk[22][22]; int w, h;\nint dist[12][12];\nint m[4][2] = { { -1,0 }, { 0,1 }, { 1,0 }, { 0,-1 } }; \nchar f[12];\nint ans;\n\nint distance()\n{\n\tint i, j, k, d, r, c, r2, c2;\n\n\tfor (i = 0; i < n; i++) for (j = i+1; j < n; j++) {\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tque[0].r = pp[i].r, que[0].c = pp[i].c, que[0].d = 0, top = 0, end = 1;\n\t\twhile (top < end) {\n\t\t\tr = que[top].r, c = que[top].c, d = que[top].d, top++;\n\t\t\tif (r == pp[j].r && c == pp[j].c) {\tdist[i][j] = dist[j][i] = d; break; }\n\t\t\tfor (k = 0; k < 4; k++) {\n\t\t\t\tr2 = r + m[k][0], c2 = c + m[k][1];\n\t\t\t\tif (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w || map[r2][c2] == 'x') continue;\n\t\t\t\tif (mk[r2][c2]) continue;\n\t\t\t\tmk[r2][c2] = 1;\n\t\t\t\tque[end].r = r2, que[end].c = c2, que[end].d = d+1, end++;\n\t\t\t}\n\t\t}\n\t\tif (top >= end) return 0;\n\t}\n\treturn 1;\n}\n\nvoid combi(int k, int a, int w)\n{\n\tint b;\n\n\tif (k == n-1) { if (w < ans) ans = w; return; }\n\tfor (b = 1; b < n; b++) {\n\t\tif (f[b]) continue;\n\t\tif (w + dist[a][b] < ans) {\n\t\t\tf[b] = 1, combi(k+1, b, w+dist[a][b]); f[b] = 0;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i, r, c;\n\n\twhile(scanf(\"%d%d\", &w, &h) && w) {\n\t\tfor (n = 1, r = 0; r < h; r++) {\n\t\t\tscanf(\"%s\", map[r]);\n\t\t\tfor (c = 0; c < w; c++) {\n\t\t\t\tif      (map[r][c] == 'o') pp[0].r = r, pp[0].c = c;\n\t\t\t\telse if (map[r][c] == '*') pp[n].r = r, pp[n++].c = c;\n\t\t\t}\n\t\t}\n\t\tif (!distance()) { puts(\"-1\"); continue; }\n\t\tmemset(f, 0, sizeof(f)), ans = INF;\n\t\tfor (i = 1; i < n; i++) f[i] = 1, combi(1, i, dist[0][i]), f[i] = 0;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1140: Cleaning Robot\n// 2017.9.14 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int r, c, d; } Q;\nQ que[1003]; int top, end;\n\ntypedef struct { int r, c; } PP;\nPP pp[12]; int n;\nchar map[22][22], mk[22][22]; int w, h;\nint dist[12][12];\nint m[4][2] = { {-1,0}, {0,1}, {1,0}, {0,-1} }; \nchar f[12];\nint ans;\n\nint distance()\n{\n\tint i, j, k, d, r, c, r2, c2;\n\n\tfor (i = 0; i < n; i++) for (j = i+1; j < n; j++) {\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tque[0].r = pp[i].r, que[0].c = pp[i].c, que[0].d = 0, top = 0, end = 1;\n\t\twhile (1) {\n\t\t\tif (top >= end) return 0;\n\t\t\tr = que[top].r, c = que[top].c, d = que[top++].d;\n\t\t\tif (r == pp[j].r && c == pp[j].c) {\tdist[i][j] = dist[j][i] = d; break; }\n\t\t\tfor (k = 0; k < 4; k++) {\n\t\t\t\tr2 = r + m[k][0], c2 = c + m[k][1];\n\t\t\t\tif (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w || map[r2][c2] == 'x') continue;\n\t\t\t\tif (mk[r2][c2]) continue;\n\t\t\t\tmk[r2][c2] = 1;\n\t\t\t\tque[end].r = r2, que[end].c = c2, que[end++].d = d+1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nvoid combi(int k, int a, int w)\n{\n\tint b;\n\n\tif (k == n) { if (w < ans) ans = w; return; }\n\tfor (b = 1; b < n; b++) {\n\t\tif (f[b]) continue;\n\t\tif (w + dist[a][b] < ans) f[b] = 1, combi(k+1, b, w+dist[a][b]), f[b] = 0;\n\t}\n}\n\nint main()\n{\n\tint i, r, c;\n\n\twhile(scanf(\"%d%d\", &w, &h) && w) {\n\t\tfor (n = 1, r = 0; r < h; r++) {\n\t\t\tscanf(\"%s\", map[r]);\n\t\t\tfor (c = 0; c < w; c++) {\n\t\t\t\tif      (map[r][c] == 'o') pp[0].r = r, pp[0].c = c;\n\t\t\t\telse if (map[r][c] == '*') pp[n].r = r, pp[n++].c = c;\n\t\t\t}\n\t\t}\n\t\tif (n <= 1) { puts(\"0\"); continue; }\n\t\tif (!distance()) { puts(\"-1\"); continue; }\n\t\tmemset(f, 0, sizeof(f)), ans = 1000;\n\t\tfor (i = 1; i < n; i++) f[i] = 1, combi(2, i, dist[0][i]), f[i] = 0;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "//ミス enqueue(startx,starty);\n//配列サイズ\n#include<stdio.h>\n#include<stdlib.h>\n#define min(x,y) (x<y)?(x):(y);\n#define N 100000000\n#define INF 1000000000\n#define rep(i,n) for(int i=0;(i)<(n);(i)++)\ntypedef struct{\n    int w;\n    int h;\n}Point;\nPoint queue[N];\nint head,num;\nvoid enqueue(int w,int h){\n    if(num<N){\n        queue[(head+num)%N].w=w;\n        queue[(head+num)%N].h=h;\n        num++;\n    }else{\n        printf(\"エラー\\n\"); exit(1);\n    }\n}\nPoint dequeue(){\n    Point d={-1,-1};\n    if(num>0){\n        d=queue[head];\n        head=(head+1)%N;\n        num--;\n    }\n    return d;\n}\nint w,h;\nchar c[20][22];\nint dx[4]={ 0,1,0,-1};\nint dy[4]={-1,0,1, 0};\nint bfs(Point p,Point q){\n    head=num=0;\n    int map[20][20]={0};\n    int starty=p.h,startx=p.w;\n    enqueue(p.w,p.h);\n    while(1){\n        Point tmp=dequeue();\n        int y=tmp.h,x=tmp.w;\n        if(y+x==-2) break;\n        if(q.w==x&&q.h==y){\n            return map[y][x];\n        }\n        for(int d=0;d<4;d++){\n            int ny=y+dy[d],nx=x+dx[d];\n            if(ny==starty&&nx==startx) continue;\n            if(ny<0||ny>=h||nx<0||nx>=w) continue;\n            else if(map[ny][nx]>0||c[ny][nx]=='x') continue;\n            else{\n                enqueue(nx,ny);\n                map[ny][nx]=map[y][x]+1;\n            }\n        }\n    }\n    return INF;\n}\nint main(void){\n    while(1){\n        scanf(\"%d%d\",&w,&h);\n        if(w+h==0) break;\n        getchar();\n        rep(i,h) fgets(c[i],22,stdin);\n        /*rep(i,h){rep(j,w){\n            printf(\"%c\",c[i][j]);\n        }puts(\"\");}*/\n        int cnt=0;\n        Point pos[10]={0};\n        Point s={0};\n        rep(i,h){\n            rep(j,w){\n                if(c[i][j]=='*'){\n                    pos[cnt].h=i; pos[cnt].w=j;\n                    cnt++;\n                }\n                else if(c[i][j]=='o'){\n                    s.h=i,s.w=j;\n                }\n            }\n        }\n        int dist[10][10]={0};\n        rep(i,cnt)rep(j,cnt)dist[i][j] = bfs(pos[i],pos[j]);\n        /*rep(i,cnt){\n            rep(j,cnt){\n                printf(\"%2d \",dist[i][j]);\n            }puts(\"\");\n        }puts(\"\");*/\n        // 巡回セールスマン初期化\n        int dp[1<<10][10];\n        rep(i,1<<10)rep(j,10)dp[i][j] = INF;\n        \n        // 巡回セールスマン\n        rep(i,cnt) dp[1<<i][i] = bfs(s,pos[i]);\n        rep(i,1<<cnt)rep(j,cnt)rep(k,cnt)\n        dp[i|(1<<k)][k] = min(dp[i|(1<<k)][k],dp[i][j]+dist[j][k]);\n        \n        // 出力\n        int ans = INF;\n        rep(i,cnt)ans = min(ans,dp[(1<<cnt)-1][i]);\n        printf(\"%d\\n\",(ans<INF)?ans:-1);\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint use[11];\nint count;\nint dis[11][11];\nint dp[20][20][11];\nint x[11],y[11];\n\nint mindis(int start){\n  int i;\n  int tmp,min;\n  int flag;\n  min = 0;\n  flag =0;\n  for(i=1;i<=count;i++){\n    if(!use[i]){\n      use[i] = 1;\n      tmp = mindis(i) + dis[start][i];\n      use[i] = 0;\n      if(!min)min = tmp;\n      else if(min > tmp)min = tmp;\n      flag = 1;\n    }\n  }\n  if(flag)return min;\n  else return 0;\n}\n\nint main(void){\n  char map[20][20];\n  int i,j,k;\n  int w,h;\n  int min;\n  int flag1,flag2;\n\n  while(1){\n    scanf(\"%d %d\",&w,&h);\n    if(!w && !h)break;\n\n    count = 0;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tscanf(\" %c \",&map[i][j]);\n\tif(map[i][j]=='o'){\n\t  x[0] = j;\n\t  y[0] = i;\n\t}\n\telse if(map[i][j]=='*'){\n\t  x[count+1] = j;\n\t  y[count+1] = i;\n\t  count++;\n\t} \n      }\n    }\n\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tfor(k=0;k<=count;k++){\n\t  dp[i][j][k] = -1;\n\t}\n      }\n    }\n\n    flag1 = 1;\n    for(k=0;k<=count;k++){\n      dp[y[k]][x[k]][k] = 0;\n\n      flag2 = 1;\n      while(flag2){\n\n\tflag2 = 0;\n\tfor(i=0;i<h;i++){\n\t  for(j=0;j<w;j++){\n\t    if(dp[i][j][k]>=0){\n\t      \n\t      if(i+1<h && map[i+1][j]!='x'){\n\t\tif(dp[i+1][j][k]<0 || dp[i+1][j][k]>dp[i][j][k]+1){\n\t\t  dp[i+1][j][k] = dp[i][j][k] + 1;\n\t\t  flag2 = 1;\n\t\t}\n\t      }\n\t      if(j+1<w && map[i][j+1]!='x'){\n\t\tif(dp[i][j+1][k]<0 || dp[i][j+1][k]>dp[i][j][k]+1){\n\t\t  dp[i][j+1][k] = dp[i][j][k] + 1;\n\t\t  flag2 = 1;\n\t\t}\n\t      }\n\t      if(i-1>=0 && map[i-1][j]!='x'){\n\t\tif(dp[i-1][j][k]<0 || dp[i-1][j][k]>dp[i][j][k]+1){\n\t\t  dp[i-1][j][k] = dp[i][j][k] + 1;\n\t\t  flag2 = 1;\n\t\t}\n\t      }\n\t      if(j-1>=0 && map[i][j-1]!='x'){\n\t\tif(dp[i][j-1][k]<0 || dp[i][j-1][k]>dp[i][j][k]+1){\n\t\t  dp[i][j-1][k] = dp[i][j][k] + 1;\n\t\t  flag2 = 1;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      if(!k){\n\tfor(i=1;i<=count;i++){\n\t  if(dp[y[i]][x[i]][k] < 0)flag1 = 0;\n\t}\n      }\n    \n      if(!flag1)break;\n\n      for(i=0;i<=count;i++){\n\tif(i!=k)dis[k][i] = dp[y[i]][x[i]][k];\n\telse dis[k][i] = 0;\n      }\n\n    }\n\n    if(!flag1){\n      printf(\"-1\\n\");\n    } else {\n      for(i=1;i<=count;i++)use[i] = 0;\n      use[0] = 1;\n      min = mindis(0);\n      printf(\"%d\\n\",min);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define INF 1000000\n\nint w,h;\nchar map[20][24];\nint rinsetu[400][400];\n\nint yogore_num;\nint yogore[11][2];\nint sx,sy;\n\nint getid(int y,int x) {\n\treturn y*w+x;\n}\n\n/* [rest_yogore][now_pos] */\nint memo[1024][11];\n\nint tansaku(int rest_yogore,int now_pos) {\n\tint result=INF;\n\tint i;\n\tif(rest_yogore==0)return 0;\n\tif(memo[rest_yogore][now_pos]>0)return memo[rest_yogore][now_pos]-1;\n\tfor(i=0;i<yogore_num;i++) {\n\t\tif(rest_yogore & (1<<i)) {\n\t\t\tint nowresult;\n\t\t\tnowresult=tansaku(rest_yogore & ~(1<<i),i);\n\t\t\tnowresult+=rinsetu[getid(yogore[now_pos][1],yogore[now_pos][0])]\n\t\t\t\t[getid(yogore[i][1],yogore[i][0])];\n\t\t\tif(nowresult<result)result=nowresult;\n\t\t}\n\t}\n\tmemo[rest_yogore][now_pos]=result+1;\n\treturn result;\n}\n\nint main(void) {\n\twhile(scanf(\"%d%d\",&w,&h)==2 && (w|h)!=0) {\n\t\tint i,j,k;\n\t\tint result;\n\t\tfor(i=0;i<h;i++)scanf(\"%s\",map[i]);\n\t\tfor(i=0;i<getid(h,0);i++) {\n\t\t\tfor(j=0;j<getid(h,0);j++) {\n\t\t\t\trinsetu[i][j]=(i==j?0:INF);\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<1024;i++) {\n\t\t\tfor(j=0;j<11;j++)memo[i][j]=0;\n\t\t}\n\t\tyogore_num=0;\n\t\tfor(i=0;i<h;i++) {\n\t\t\tfor(j=0;j<w;j++) {\n\t\t\t\tif(map[i][j]!='x') {\n\t\t\t\t\tif(i+1<h && map[i+1][j]!='x') {\n\t\t\t\t\t\trinsetu[getid(i,j)][getid(i+1,j)]=1;\n\t\t\t\t\t\trinsetu[getid(i+1,j)][getid(i,j)]=1;\n\t\t\t\t\t}\n\t\t\t\t\tif(j+1<w && map[i][j+1]!='x') {\n\t\t\t\t\t\trinsetu[getid(i,j)][getid(i,j+1)]=1;\n\t\t\t\t\t\trinsetu[getid(i,j+1)][getid(i,j)]=1;\n\t\t\t\t\t}\n\t\t\t\t\tif(map[i][j]=='o') {\n\t\t\t\t\t\tsx=j;sy=i;\n\t\t\t\t\t} else if(map[i][j]=='*') {\n\t\t\t\t\t\tyogore[yogore_num][0]=j;\n\t\t\t\t\t\tyogore[yogore_num][1]=i;\n\t\t\t\t\t\tyogore_num++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(k=0;k<getid(h,0);k++) {\n\t\t\tfor(i=0;i<getid(h,0);i++) {\n\t\t\t\tfor(j=0;j<getid(h,0);j++) {\n\t\t\t\t\tif(rinsetu[i][j]>rinsetu[i][k]+rinsetu[k][j]) {\n\t\t\t\t\t\trinsetu[i][j]=rinsetu[i][k]+rinsetu[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tyogore[yogore_num][0]=sx;\n\t\tyogore[yogore_num][1]=sy;\n\t\tresult=tansaku((1<<yogore_num)-1,yogore_num);\n\t\tprintf(\"%d\\n\",result<INF?result:-1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){\n  if(a==0||a>b)return b;\n  return a;\n}\nint main(){\n  int Y[]={-1,0,1,0};\n  int X[]={0,1,0,-1};\n  int w,h,i,j,k,l,ny,nx,ax[15],ay[15],x[900],y[900],r,t,rr,min;\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    char d[30][30]={0};\n    int dp[10][1<<10]={0};\n    int m[30][30]={0};\n    int f[30][30]={0};\n    int c[30][30]={0};\n    r=0;\n    for(i=rr=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tscanf(\" %c\",&d[i][j]);\n\tif(d[i][j]=='o')d[ay[0]=i][ax[0]=j]='.';\n\tif(d[i][j]=='*'){\n\t  d[ay[rr]=i][ax[rr]=j]='.';\n\t  rr++;\n\t}\n      }\n    }\n    for(i=min=0;i<rr;i++){\n      f[y[t=0]=ay[i]][x[t]=ax[i]]=i+1;\n      c[y[t]][x[t]]=0;\n      for(r=1;r-t;t++){\n\tfor(j=0;j<4;j++){\n\t  ny=y[t]+Y[j];\n\t  nx=x[t]+X[j];\n\t  if(d[ny][nx]-'.'||f[ny][nx]==i+1)continue;\n\t  c[y[r]=ny][x[r]=nx]=c[y[t]][x[t]]+1;\n\t  f[ny][nx]=i+1;\n\t  r++;\n\t}\n      }\n      for(j=1;j<rr;j++)m[i][j]=c[ay[j]][ax[j]];\n    }\n    rr--;\n    for(i=0;i<rr;i++){\n      dp[i][1<<i]=m[0][i+1];\n      if(m[0][i+1]==0)rr=0;\n    }\n    for(l=0;l<rr;l++){\n      for(i=0;i<rr;i++){\n\tfor(j=0;j<1<<rr;j++){\n\t  if(dp[i][j]==0)continue;\n\t  for(k=0;k<rr;k++){\n\t    if(j&1<<k)continue;\n\t    dp[k][j|1<<k]=MIN(dp[k][j|1<<k],dp[i][j]+m[i+1][k+1]);\n\t  }\n\t}\n      }\n    }\n    for(i=min=0;i<rr;i++)min=MIN(min,dp[i][(1<<rr)-1]);\n    if(min)printf(\"%d\\n\",min);\n    else   printf(\"-1\\n\");\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){\n  if(a==0||a>b)return b;\n  return a;\n}\nint main(){\n  int Y[]={-1,0,1,0};\n  int X[]={0,1,0,-1};\n  int w,h,i,j,k,l,ny,nx,ax[15],ay[15],x[900],y[900],r,t,rr,min;\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    char d[30][30]={0};\n    int dp[10][1<<10]={0};\n    int m[30][30]={0};\n    int f[30][30]={0};\n    int c[30][30]={0};\n    r=0;\n    for(i=rr=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tscanf(\" %c\",&d[i][j]);\n\tif(d[i][j]=='o')d[ay[0]=i][ax[0]=j]='.';\n\tif(d[i][j]=='*'){\n\t  d[ay[rr]=i][ax[rr]=j]='.';\n\t  rr++;\n\t}\n      }\n    }//for(i=0;i<rr;i++)printf(\"%d %d\\n\",ay[i],ax[i]);\n    for(i=min=0;i<rr;i++){//printf(\"%d %d\\n\",ay[i],ax[i]);\n      f[y[t=0]=ay[i]][x[t]=ax[i]]=i+1;\n      c[y[t]][x[t]]=0;\n      for(r=1;r-t;t++){//printf(\"%d;\",r);\n\tfor(j=0;j<4;j++){\n\t  ny=y[t]+Y[j];\n\t  nx=x[t]+X[j];\n\t  if(d[ny][nx]-'.'||f[ny][nx]==i+1)continue;\n\t  c[y[r]=ny][x[r]=nx]=c[y[t]][x[t]]+1;\n\t  f[ny][nx]=i+1;\n\t  r++;\n\t}\n      }\n      for(j=1;j<rr;j++)m[i][j]=c[ay[j]][ax[j]];\n    }\n    rr--;\n    for(i=0;i<rr;i++){\n      dp[i][1<<i]=m[0][i+1];\n      if(m[0][i+1]==0)break;\n    }\n    for(l=0;l<rr;l++){\n      for(i=0;i<rr;i++){\n\tfor(j=0;j<1<<rr;j++){\n\t  if(dp[i][j]==0)continue;\n\t  //printf(\"%d \",i);g(j);printf(\" %d\\n\",dp[i][j]);\n\t  for(k=0;k<rr;k++){\n\t    if(j&1<<k)continue;\n\t    dp[k][j|1<<k]=MIN(dp[k][j|1<<k],dp[i][j]+m[i+1][k+1]);\n\t  }\n\t}\n      }\n    }\n    for(i=min=0;i<rr;i++)min=MIN(min,dp[i][(1<<rr)-1]);\n    if(min)printf(\"%d\\n\",min);\n    else   printf(\"-1\\n\");\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n    static int W, H;\n    static int[][] map;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        W = sc.nextInt();\n        H = sc.nextInt();\n        map = new int[H][W];\n        Point ps = new Point(0, 0);\n        int dtc = 0;\n\n        for (int i = 0; i < H; i++) {\n            String line = sc.next();\n            for (int j = 0; j < W; j++) {\n                if (line.charAt(j) == 'o') {\n                    ps.y = i;\n                    ps.x = j;\n                }\n                if (line.charAt(j) == '*') {\n                    map[i][j] = 1;\n                    dtc ++;\n                }\n                if (line.charAt(j) == 'x') {\n                    map[i][j] = 2;\n                }\n            }\n        }\n        Point[] dts = new Point[dtc];\n        int l = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (map[i][j] == 1) {\n                    dts[l] = new Point(i, j);\n                    l++;\n                }\n            }\n        }\n        int[][] dis = new int[dtc][dtc];\n        for (int i = 0; i < dtc; i++) {\n            for (int j = i + 1; j < dtc; j++) {\n                dis[j][i] = dis[i][j] = bfs(dts[i], dts[j]);\n            }\n        }\n        int[][] dp = new int[1 << dtc][dtc];\n        for (int i = 0; i < (1 << dtc); i++) {\n            Arrays.fill(dp[i], 10000);\n        }\n        for (int i = 0; i < dtc; i++) {\n            dp[1 << i][i] = bfs(ps, dts[i]);\n        }\n        for (int i = 0; i < (1 << dtc); i++) {\n            for (int j = 0; j < dtc; j++) {\n                for (int k = 0; k < dtc; k++) {\n                    dp[i | (1 << k)][k] = Math.min(\n                            dp[i | (1 << k)][k],\n                            dp[i][j] + dis[j][k]\n                    );\n                }\n            }\n        }\n        int min = Integer.MAX_VALUE;\n        for (int i = 0; i < dtc; i++) {\n            min = Math.min(min, dp[(1 << dtc) - 1][i]);\n        }\n        System.out.println(min);\n    }\n\n    public static int bfs(Point s, Point g) {\n        int[][] b = new int[H][W];\n        for (int[] bs : b) {\n            Arrays.fill(bs, -1);\n        }\n        Queue<Point> q = new ArrayDeque<>();\n        q.add(s);\n        int[] d = new int[]{0, 1, 0, -1, 0};\n        b[s.y][s.x] = 0;\n        while (!q.isEmpty()) {\n            Point p = q.poll();\n            if (p.y == g.y && p.x == g.x) {\n                return b[g.y][g.x];\n            }\n            for (int i = 0; i < 4; i++) {\n                int nx = p.x + d[i];\n                int ny = p.y + d[i + 1];\n                if (nx < 0 || nx >= W || ny < 0 || ny >= H) {\n                    continue;\n                }\n                if (map[ny][nx] == 2) {\n                    continue;\n                }\n                if (b[ny][nx] >= 0 && b[ny][nx] <= b[p.y][p.x] + 1) {\n                    continue;\n                }\n                b[ny][nx] = b[p.y][p.x] + 1;\n                q.add(new Point(ny, nx));\n            }\n        }\n        return -1;\n    }\n\n    public static void arrayDump(int[][] a) {\n        for (int i = 0, l = a.length; i < l; i++) {\n            for (int j = 0, l2 = a[0].length; j < l2; j++) {\n                System.out.print(a[i][j] + \" \");\n            }\n            System.out.println();\n        }\n        System.out.println();\n    }\n\n    static class Point {\n        public int y, x;\n\n        Point(int y, int x) {\n            this.y = y;\n            this.x = x;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int w,h,startx,starty;\n\tstatic int[][]field;\n\tstatic int[][]kyori;\n\tstatic List<int[]> list;\n\tstatic byte[] v1={1,0,-1,0};\n\tstatic byte[] v2={0,-1,0,1};\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tlabel:while(true){\n\t\t\tw=cin.nextInt();\n\t\t\th=cin.nextInt();\n\t\t\tif(w+h==0)break;\n\t\t\tfield=new int[h+2][w+2];\n\t\t\tlist=new ArrayList<int[]>();\n\t\t\tint cnt=0;\n\t\t\tfor(int i=0;i<=h+1;i++){\n\t\t\t\tArrays.fill(field[i], -1);\n\t\t\t}\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tchar[] s=cin.next().toCharArray();\n\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\tif(s[j-1]=='.'){\n\t\t\t\t\t\tfield[i][j]=-2;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s[j-1]=='x'){\n\t\t\t\t\t\tfield[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s[j-1]=='*'){\n\t\t\t\t\t\tfield[i][j]=++cnt;\n\n\t\t\t\t\t\tlist.add(new int[]{i,j});\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tfield[i][j]=0;\n\t\t\t\t\t\tstartx=i;\n\t\t\t\t\t\tstarty=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tfor(int j=1;j<=w;j++){\n//\t\t\t\t\tSystem.out.print(field[i][j]);\n\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t//0,0がスタート地点\n\t\t\tkyori=new int[cnt+1][cnt+1];\n\t\t\ta(startx,starty,0);\n\t\t\tcnt=1;\n\t\t\tint[][] b=new int[list.size()][2];\n\t\t\tfor(int i=0;i<list.size();i++){\n\t\t\t\tint[] array=list.get(i);\n\t\t\t\tb[i][0]=array[0];\n\t\t\t\tb[i][1]=array[1];\n\t\t\t}\n\t\t\tlist=null;\n\t\t\tfor(int i=0;i<b.length;i++){\n\t\t\t\ta(b[i][0],b[i][1],cnt++);\n\t\t\t}\n\t\t\tfor(int i=0;i<kyori[0].length;i++){\n\t\t\t\tfor(int j=0;j<kyori[0].length;j++){\n\t\t\t\t\tif(i==j)continue;\n\t\t\t\t\tif(kyori[i][j]==0){\n\t\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\t\tcontinue label;\n\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println(i+\" \"+j+\" \"+kyori[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum=0;\n\t\t\tans=1<<30;\n\t\t\tbt(0,0);\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tstatic int sum,ans;\n\tstatic void bt(int a,int step){\n//\t\tSystem.out.println(a+\" \"+step+\" \"+sum);\n\t\tif(ans<=sum)return;\n\t\tif(step==kyori[0].length-1){\n\t\t\tans=Math.min(ans,sum);\n\t\t}\n\t\tfor(int i=0;i<kyori[0].length;i++){\n\t\t\tif(a==i)continue;\n\t\t\tif(kyori[a][i]==0)continue;\n\t\t\tint tmp=kyori[a][i];\n\t\t\tkyori[a][i]=kyori[i][a]=0;\n\t\t\tsum+=tmp;\n\t\t\tbt(i,step+1);\n\t\t\tkyori[a][i]=kyori[i][a]=tmp;\n\t\t\tsum-=tmp;\n\t\t}\n\t}\n\tstatic void a(int x,int y,int cnt){\n\t\tint[][] f=new int[h+2][w+2];\n\t\tfor(int i=0;i<h+2;i++){\n\t\t\tfor(int j=0;j<w+2;j++){\n\t\t\t\tf[i][j]=field[i][j];\n\t\t\t}\n\t\t}\n\t\tQueue<byte[]> q=new LinkedList<byte[]>();\n\t\tq.add(new byte[]{(byte)x,(byte)y});\n\t\tint steps=0;\n\t\t\n\t\twhile(!q.isEmpty()){\n\t\t\tint size=q.size();\n\t\t\tfor(int i=0;i<size;i++){\n\t\t\t\tbyte[] aaa=q.poll();\n\t\t\t\tbyte xx=aaa[0];\n\t\t\t\tbyte yy=aaa[1];\n\t\t\t\tif(f[xx][yy]==-1)continue;\n\t\t\t\tif(f[xx][yy]>=0){\n\t\t\t\t\tkyori[cnt][f[xx][yy]]=steps;kyori[f[xx][yy]][cnt]=steps;\n\t\t\t\t}\n\t\t\t\tf[xx][yy]=-1;\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tbyte x1=(byte) ((byte)xx+v1[j]);\n\t\t\t\t\tbyte y1=(byte) ((byte)yy+v2[j]);\n\t\t\t\t\tif(f[x1][y1]==-1)continue;\n\t\t\t\t\tq.add(new byte[]{x1,y1});\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tsteps++;\n\t\t}\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[] v1 = {0,1,0,-1};\n\tstatic int[] v2 = {1,0,-1,0};\n\tstatic int count;\n\tstatic int[][] dis;\n\tstatic int min;\n\tstatic boolean[] already;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w=cin.nextInt();\n\t\t\tint h=cin.nextInt();\n\t\t\tif(w+h==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmin=999999999;\n\t\t\tint[][] a = new int[h+2][w+2];\n\t\t\tint[][] bangou = new int[h+2][w+2];\n\t\t\tint[][] coor = new int[11][2];\n\t\t\tcount=1;\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tString str=cin.next();\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\tif(str.charAt(j)=='.'){\n\t\t\t\t\t\ta[i+1][j+1]=1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(str.charAt(j)=='o'){\n\t\t\t\t\t\ta[i+1][j+1]=3;\n\t\t\t\t\t\tcoor[0][0]=i+1;\n\t\t\t\t\t\tcoor[0][1]=j+1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(str.charAt(j)=='x'){\n\t\t\t\t\t\ta[i+1][j+1]=0;\n\t\t\t\t\t}\n\t\t\t\t\telse if(str.charAt(j)=='*'){\n\t\t\t\t\t\ta[i+1][j+1]=2;\n\t\t\t\t\t\tcoor[count][0]=i+1;\n\t\t\t\t\t\tcoor[count][1]=j+1;\n\t\t\t\t\t\tbangou[i+1][j+1]=count;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdis = new int[count][count];\n\t\t\talready = new boolean[count];\n\t\t\tfor(int i = 0;i<count;i++){\n\t\t\t\tint[][] copy = new int[h+2][w+2];\n\t\t\t\tfor(int x = 0;x<h+2;x++){\n\t\t\t\t\tfor(int y = 0;y<w+2;y++){\n\t\t\t\t\t\tcopy[x][y]=a[x][y];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint x = coor[i][0];\n\t\t\t\tint y = coor[i][1];\n\t\t\t\tcopy[x][y]=0;\n\t\t\t\tInteger[] pair ={x,y,0};\n\t\t\t\tQueue<Integer[]> q = new LinkedList<Integer[]>();\n\t\t\t\tq.add(pair);\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tInteger[] p = q.poll();\n\n\t\t\t\t\tfor(int c = 0;c<4;c++){\n\t\t\t\t\t\tint xx=p[0]+v1[c];\n\t\t\t\t\t\tint yy=p[1]+v2[c];\n\t\t\t\t\t\tint distance=p[2];\n\t\t\t\t\t\tif(copy[xx][yy]==1){\n\t\t\t\t\t\t\tInteger[] next={xx,yy,distance+1};\n\t\t\t\t\t\t\tcopy[xx][yy]=0;\n\t\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(copy[xx][yy]==2){\n\t\t\t\t\t\t\tdis[i][bangou[xx][yy]]=distance+1;\n\t\t\t\t\t\t\tInteger[] next={xx,yy,distance+1};\n\t\t\t\t\t\t\tcopy[xx][yy]=0;\n\t\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(copy[xx][yy]==3){\n\t\t\t\t\t\t\tdis[i][0]=distance+1;\n\t\t\t\t\t\t\tInteger[] next={xx,yy,distance+1};\n\t\t\t\t\t\t\tcopy[xx][yy]=0;\n\t\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<count;i++){\n\t\t\t\tfor(int j=0;j<count;j++){\n\t\t\t\t\t//System.out.print(dis[i][j]+ \" \");\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t}\n\t\t\talready[0]=true;\n\t\t\tbacktrack(0,0,0);\n\t\t\tif(min==999999999){\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(min);\n\t\t\t}\n\t\t}\n\t}\n\tstatic void backtrack(int start,int sum,int cnt){\n\t\t//System.out.println(start+\" \" + sum+\" \" +cnt);\n\t\tif(sum>min){\n\t\t\treturn;\n\t\t}\n\t\tif(cnt==count-1){\n\t\t\tmin=Math.min(sum, min);\n\t\t}\n\t\tfor(int i = 1;i<count;i++){\n\t\t\tif(dis[start][i]!=0&&!already[i]){\n\t\t\t\tint tmp=dis[start][i];\n\t\t\t\tdis[start][i]=dis[i][start]=0;\n\t\t\t\talready[i]=true;\n\t\t\t\tbacktrack(i,sum+tmp,cnt+1);\n\t\t\t\talready[i]=false;\n\t\t\t\tdis[start][i]=dis[i][start]=tmp;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static int w;\n    static int h;\n    static int[][] costs;\n    static ArrayList<Integer> wList;\n    static ArrayList<Integer> hList;\n    static int count;\n    static int[][] dp;\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        StringBuilder sb = new StringBuilder();\n        while(true) {\n            w = sc.nextInt();\n            h = sc.nextInt();\n            if (w == 0 && h == 0) {\n                break;\n            }\n            char[][] field = new char[h][];\n            costs = new int[w * h][w * h];\n            int startW = 0;\n            int startH = 0;\n            wList = new ArrayList<>();\n            hList = new ArrayList<>();\n            for (int i = 0; i < h; i++) {\n                field[i] = sc.next().toCharArray();\n                for (int j = 0; j < w; j++) {\n                    if (field[i][j] == 'o') {\n                        startH = i;\n                        startW = j;\n                    } else if (field[i][j] == '*') {\n                        wList.add(j);\n                        hList.add(i);\n                    }\n                }\n            }\n            wList.add(startW);\n            hList.add(startH);\n            for (int i = 0; i < h * w; i++) {\n                Arrays.fill(costs[i], Integer.MAX_VALUE / 10);\n                costs[i][i] = 0;\n            }\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    for (int k = 0; k < h; k++) {\n                        for (int l = 0; l < w; l++) {\n                            if (field[i][j] != 'x' && field[k][l] != 'x' && ((i == k && Math.abs(j - l) == 1) || (j == l && Math.abs(i - k) == 1))) {\n                                costs[i * w + j][k * w + l] = 1;\n                            }\n                        }\n                    }\n                }\n            }\n            for (int i = 0; i < h * w; i++) {\n                for (int j = 0; j < h * w; j++) {\n                    for (int k = 0; k < h * w; k++) {\n                        costs[j][k] = Math.min(costs[j][k], costs[j][i] + costs[i][k]);\n                    }\n                }\n            }\n            count = wList.size();\n            dp = new int[count][1 << (count - 1)];\n            int ans = dfw(count - 1, (1 << (count - 1)) - 1);\n            if (ans >= Integer.MAX_VALUE / 10) {\n                sb.append(-1).append(\"\\n\");\n            } else {\n                sb.append(ans).append(\"\\n\");\n            }\n        }\n        System.out.print(sb);\n    }\n        \n    static int dfw(int from, int key) {\n        if (key == 0) {\n            return 0;\n        }\n        if (dp[from][key] != 0) {\n            return dp[from][key];\n        }\n        int min = Integer.MAX_VALUE / 10;\n        for (int i = 0; i < count - 1; i++) {\n            if (((1 << i) & key) == 0) {\n                continue;\n            }\n            int value = costs[hList.get(i) * w + wList.get(i)][hList.get(from) * w + wList.get(from)];\n            min = Math.min(min, dfw(i, key ^ (1 << i)) + value);\n        }\n        dp[from][key] = min;\n        return min;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n    static int W, H;\n    static int[][] map;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            W = sc.nextInt();\n            H = sc.nextInt();\n            if ((W | H) == 0) {\n                break;\n            }\n            map = new int[H][W];\n            Point ps = new Point(0, 0);\n            int dtc = 0;\n\n            for (int i = 0; i < H; i++) {\n                String line = sc.next();\n                for (int j = 0; j < W; j++) {\n                    if (line.charAt(j) == 'o') {\n                        ps.y = i;\n                        ps.x = j;\n                    }\n                    if (line.charAt(j) == '*') {\n                        map[i][j] = 1;\n                        dtc++;\n                    }\n                    if (line.charAt(j) == 'x') {\n                        map[i][j] = 2;\n                    }\n                }\n            }\n            Point[] dts = new Point[dtc];\n            int l = 0;\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    if (map[i][j] == 1) {\n                        dts[l] = new Point(i, j);\n                        l++;\n                    }\n                }\n            }\n            int[][] dis = new int[dtc][dtc];\n            for (int i = 0; i < dtc; i++) {\n                for (int j = i + 1; j < dtc; j++) {\n                    dis[j][i] = dis[i][j] = bfs(dts[i], dts[j]);\n                }\n            }\n            int[][] dp = new int[1 << dtc][dtc];\n            for (int i = 0; i < (1 << dtc); i++) {\n                Arrays.fill(dp[i], 10000);\n            }\n            for (int i = 0; i < dtc; i++) {\n                dp[1 << i][i] = bfs(ps, dts[i]);\n            }\n            for (int i = 0; i < (1 << dtc); i++) {\n                for (int j = 0; j < dtc; j++) {\n                    for (int k = 0; k < dtc; k++) {\n                        dp[i | (1 << k)][k] = Math.min(\n                                dp[i | (1 << k)][k],\n                                dp[i][j] + dis[j][k]\n                        );\n                    }\n                }\n            }\n            int min = Integer.MAX_VALUE;\n            for (int i = 0; i < dtc; i++) {\n                min = Math.min(min, dp[(1 << dtc) - 1][i]);\n            }\n            System.out.println(min);\n        }\n    }\n\n    public static int bfs(Point s, Point g) {\n        int[][] b = new int[H][W];\n        for (int[] bs : b) {\n            Arrays.fill(bs, -1);\n        }\n        Queue<Point> q = new ArrayDeque<>();\n        q.add(s);\n        int[] d = new int[]{0, 1, 0, -1, 0};\n        b[s.y][s.x] = 0;\n        while (!q.isEmpty()) {\n            Point p = q.poll();\n            if (p.y == g.y && p.x == g.x) {\n                return b[g.y][g.x];\n            }\n            for (int i = 0; i < 4; i++) {\n                int nx = p.x + d[i];\n                int ny = p.y + d[i + 1];\n                if (nx < 0 || nx >= W || ny < 0 || ny >= H) {\n                    continue;\n                }\n                if (map[ny][nx] == 2) {\n                    continue;\n                }\n                if (b[ny][nx] >= 0 && b[ny][nx] <= b[p.y][p.x] + 1) {\n                    continue;\n                }\n                b[ny][nx] = b[p.y][p.x] + 1;\n                q.add(new Point(ny, nx));\n            }\n        }\n        return -1;\n    }\n\n    public static void arrayDump(int[][] a) {\n        for (int i = 0, l = a.length; i < l; i++) {\n            for (int j = 0, l2 = a[0].length; j < l2; j++) {\n                System.out.print(a[i][j] + \" \");\n            }\n            System.out.println();\n        }\n        System.out.println();\n    }\n\n    static class Point {\n        public int y, x;\n\n        Point(int y, int x) {\n            this.y = y;\n            this.x = x;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static final int WIDTH = 20;\n\tpublic static final int HEIGHT = 20;\n\tpublic static final int MAX_BIT = (1 << 10) - 1;\n\t\n\tpublic static final int[][] move_dir = new int[][]{{1, 0}, {-1, 0},{0, 1}, {0, -1}};\n\tpublic static boolean is_ok(int x, int y, int w, int h){\n\t\treturn 0 <= x && x < w && 0 <= y && y < h;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tboolean[][] is_wall = new boolean[HEIGHT][WIDTH];\n\t\tint[][] is_dirty = new int[HEIGHT][WIDTH];\n\t\tboolean[][][] visited = new boolean[HEIGHT][WIDTH][MAX_BIT];\n\t\t\n\t\twhile(true){\n\t\t\tfinal int w = sc.nextInt();\n\t\t\tfinal int h = sc.nextInt();\n\t\t\t\t\t\n\t\t\tif(w == 0 && h == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\n\t\t\tint start_x = -1;\n\t\t\tint start_y = -1;\n\t\t\tint dirty_id = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tchar[] input = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\t//System.out.println(Arrays.toString(input));\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tfinal char in = input[j];\n\t\t\t\t\t\n\t\t\t\t\tfor(int k = 0; k < MAX_BIT; k++){\n\t\t\t\t\t\tvisited[i][j][k] = false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(in == '.'){\n\t\t\t\t\t\tis_wall[i][j] = false;\n\t\t\t\t\t\tis_dirty[i][j] = -1;\n\t\t\t\t\t}else if(in == '*'){\n\t\t\t\t\t\tis_wall[i][j] = false;\n\t\t\t\t\t\tis_dirty[i][j] = dirty_id;\n\t\t\t\t\t\tdirty_id++;\n\t\t\t\t\t}else if(in == 'x'){\n\t\t\t\t\t\tis_wall[i][j] = true;\n\t\t\t\t\t\tis_dirty[i][j] = -1;\n\t\t\t\t\t}else if(in == 'o'){\n\t\t\t\t\t\tis_wall[i][j] = false;\n\t\t\t\t\t\tis_dirty[i][j] = -1;\n\t\t\t\t\t\tstart_x = j;\n\t\t\t\t\t\tstart_y = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfinal int all_dirty = (1 << dirty_id) - 1;\n\t\t\t\n\t\t\tLinkedList<Integer> x_queue = new LinkedList<Integer>();\n\t\t\tLinkedList<Integer> y_queue = new LinkedList<Integer>();\n\t\t\tLinkedList<Integer> time_queue = new LinkedList<Integer>();\n\t\t\tLinkedList<Integer> dirty_queue = new LinkedList<Integer>();\n\t\t\tx_queue.add(start_x);\n\t\t\ty_queue.add(start_y);\n\t\t\ttime_queue.add(0);\n\t\t\tdirty_queue.add(0);\n\t\t\tvisited[start_y][start_x][0] = true;\n\t\t\t\n\t\t\tboolean flag = false;\n\t\t\twhile(!time_queue.isEmpty()){\n\t\t\t\tfinal int x = x_queue.poll();\n\t\t\t\tfinal int y = y_queue.poll();\n\t\t\t\tfinal int time = time_queue.poll();\n\t\t\t\tfinal int dirty_bit = dirty_queue.poll();\n\t\t\t\t\n\t\t\t\tif(dirty_bit == all_dirty){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tSystem.out.println(time);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int[] move : move_dir){\n\t\t\t\t\tfinal int nx = x + move[0];\n\t\t\t\t\tfinal int ny = y + move[1];\n\t\t\t\t\tfinal int ntime = time + 1;\n\t\t\t\t\t\n\t\t\t\t\tif(!is_ok(nx, ny, w, h)){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(is_wall[ny][nx]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//System.out.println(nx + \" \" + ny);\n\t\t\t\t\tint next_dirty = dirty_bit;\n\t\t\t\t\tif(is_dirty[ny][nx] >= 0){\n\t\t\t\t\t\tnext_dirty |= 1 << is_dirty[ny][nx];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(visited[ny][nx][next_dirty]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tvisited[ny][nx][next_dirty] = true;\n\t\t\t\t\t\n\t\t\t\t\tx_queue.add(nx);\n\t\t\t\t\ty_queue.add(ny);\n\t\t\t\t\ttime_queue.add(ntime);\n\t\t\t\t\tdirty_queue.add(next_dirty);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(!flag){\n\t\t\t\tSystem.out.println(\"-1\");\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\nimport java.io.*;\n\npublic class Main{\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {1,0,-1,0};\n\tint INF = 1 << 24;\n\t\n\tclass State{\n\t\tint x,y,step;\n\n\t\tpublic State(int x, int y, int step) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.step = step;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif((w|h) == 0) break;\n\t\t\tchar [][] data = new char[h][w];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tdata[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tint sx = -1, sy = -1;\n\t\t\tArrayList<int []> gmap = new ArrayList<int[]>();\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(data[i][j] == 'o'){\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tdata[i][j] = '.';\n\t\t\t\t\t\tgmap.add(new int[]{i,j});\n\t\t\t\t\t}\n\t\t\t\t\tif(data[i][j] == '*'){\n\t\t\t\t\t\tgmap.add(new int[]{i,j});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint v = gmap.size();\n\t\t\tint [][] pass = new int[v][v];\n\t\t\t\n\t\t\tfor(int k = 0; k < gmap.size(); k++){\n\t\t\t\tLinkedList<State> open = new LinkedList<Main.State>();\n\t\t\t\topen.add(new State(gmap.get(k)[1],gmap.get(k)[0], 0));\n\t\t\t\tint [][] close = new int[h][w];\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\t\tArrays.fill(close[i], INF);\n\t\t\t\t}\n\t\t\t\tclose[gmap.get(k)[0]][gmap.get(k)[1]] = 0;\n\t\t\t\twhile(! open.isEmpty()){\n\t\t\t\t\tState now = open.poll();\n\t\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\t\tint xx = now.x + vx[i];\n\t\t\t\t\t\tint yy = now.y + vy[i];\n\t\t\t\t\t\tif(! isOK(xx, yy, w,h)) continue;\n\t\t\t\t\t\tif(data[yy][xx] == 'x') continue;\n\t\t\t\t\t\tif(close[yy][xx] <= now.step + 1){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\topen.add(new State(xx, yy, now.step + 1));\n\t\t\t\t\t\tclose[yy][xx] = now.step + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < v; i++){\n\t\t\t\t\tif(i == k){\n\t\t\t\t\t\tpass[k][i] = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tpass[k][i] = close[gmap.get(i)[0]][gmap.get(i)[1]];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint [][] dp = new int[v][1 << v];\n\t\t\tint sind = -1;\n\t\t\tfor(int i = 0; i < v; i++){\n\t\t\t\tif(gmap.get(i)[0] == sy && gmap.get(i)[1] == sx){\n\t\t\t\t\tsind = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < v;i++){\n\t\t\t\tArrays.fill(dp[i], INF);\n\t\t\t}\n\t\t\tdp[sind][1 << sind] = 0;\n\t\t\tfor(int j = 0; j < (1 << v); j++){\n\t\t\t\tfor(int i = 0; i < v; i++){\n\t\t\t\t\tif(dp[i][j] == INF) continue;\n\t\t\t\t\tfor(int k = 0; k < v; k++){\n\t\t\t\t\t\tif(  (j & (1 << k)) != 0) continue;\n\t\t\t\t\t\tint next = j | (1 << k);\n\t\t\t\t\t\tint value = dp[i][j] + pass[i][k];\n\t\t\t\t\t\tdp[k][next] = Math.min(dp[k][next], value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = INF;\n\t\t\tfor(int i = 0; i < v; i++){\n\t\t\t\tans = Math.min(ans, dp[i][(1 << v) - 1]);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(ans == INF ? -1 : ans);\n\t\t}\n\t}\n\t\n\tprivate boolean isOK(int xx, int yy, int w, int h) {\n\t\treturn (0 <= xx && xx < w && 0 <= yy && yy < h);\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static int[][] map;\n\tpublic static int[][] dist;\n\tpublic static final int[] dx = {1, 0, -1, 0}; \n\tpublic static final int[] dy = {0, 1, 0, -1}; \n\tpublic static int w, h, n;\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\t\t\tif(w == 0) break;\n\t\t\tBitSet used = new BitSet(w*h);\n\t\t\tList<Pos> list = new ArrayList<Pos>();\n\t\t\tmap = new int[h][w];\n\t\t\tint sx = 0;\n\t\t\tint sy = 0;\n\t\t\tn = 0;\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tchar[] s = in.next().toCharArray();\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tswitch(s[j]){\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'x':\n\t\t\t\t\t\tmap[i][j] = -2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\tmap[i][j] = n;\n\t\t\t\t\t\tlist.add(new Pos(n++, i, j));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'o':\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdist = new int[n][n];\n\t\t\tint[] stod = new int[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tstod[i] = -1;\n\t\t\t}\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tused.clear();\n\t\t\t\tQueue<Point> qu = new LinkedList<Point>();\n\t\t\t\tqu.add(list.get(i).p);\n\t\t\t\twhile(!qu.isEmpty()){\n\t\t\t\t\tPoint p = qu.poll();\n\t\t\t\t\tif(used.get(p.id)) continue;\n\t\t\t\t\tif(map[p.y][p.x] >= 0){\n\t\t\t\t\t\tdist[i][map[p.y][p.x]] = p.dist;\n\t\t\t\t\t}else if(p.y == sy && p.x == sx){\n\t\t\t\t\t\tstod[i] = p.dist;\n\t\t\t\t\t}\n\t\t\t\t\tused.set(p.id);\n\t\t\t\t\tfor(int d=0; d<4; d++){\n\t\t\t\t\t\tint ny = p.y+dy[d];\n\t\t\t\t\t\tint nx = p.x+dx[d];\n\t\t\t\t\t\tif(out(ny, nx)) continue;\n\t\t\t\t\t\tif(map[ny][nx] == -2) continue;\n\t\t\t\t\t\tqu.add(new Point(ny, nx, p.dist+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = 5000;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(stod[i] == -1){\n\t\t\t\t\tres = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdfs(i, 1<<i, stod[i]);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static int res;\n\tpublic static void dfs(int id, int state, int sum){\n\t\tif(Integer.bitCount(state) == n){\n\t\t\tres = Math.min(res, sum);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif((state&1<<i)>0) continue;\n\t\t\tdfs(i, state|1<<i, sum+dist[id][i]);\n\t\t}\n\t}\n\t\n\tpublic static boolean out(int y, int x){\n\t\treturn y<0 || y>=h || x<0 || x>=w;\n\t}\n}\n\nclass Point{\n\tint y, x;\n\tint id;\n\tint dist;\n\tpublic Point(int y, int x, int d){\n\t\tthis.y = y;\n\t\tthis.x = x;\n\t\tid = y*Main.w+x;\n\t\tdist = d;\n\t}\n}\n\nclass Pos{\n\tint id;\n\tint y, x;\n\tPoint p;\n\tpublic Pos(int id, int y, int x){\n\t\tthis.id = id;\n\t\tthis.y = y;\n\t\tthis.x = x;\n\t\tthis.p = new Point(y, x, 0);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n    int w,h;\n    char[][] map;\n    int[][] d,dist;\n    int[] x,y;\n    int[] dx = {0,0,1,-1};\n    int[] dy = {1,-1,0,0};\n    int n,goal,ans;\n    boolean[] v;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            w = sc.nextInt();\n            h = sc.nextInt();\n            if(w==0 && h==0) break;\n\n            map = new char[h][w];\n            x = new int[11];\n            y = new int[11];\n            int idx = 1;\n            for(int i=0; i<h; i++){\n                String s = sc.next();\n                map[i] = s.toCharArray();\n                for(int j=0; j<w; j++){\n                    if(map[i][j]=='o'){\n                        x[0] = j; y[0] = i;\n                    }else if(map[i][j]=='*'){\n                        x[idx] = j; y[idx] = i;\n                        idx++;\n                    }\n                }\n            }\n\n            boolean end = false;\n            dist = new int[idx][idx];\n            for(int i=0; i<idx; i++){\n                bfs(x[i],y[i]);\n                for(int j=0; j<idx; j++){\n                    dist[i][j] = d[y[j]][x[j]];\n                    if(dist[i][j]==Integer.MAX_VALUE){\n                        System.out.println(-1);\n                        end = true;\n                        break;\n                    }\n                }\n                if(end) break;\n            }\n\n            if(end) continue;\n\n            n = idx;\n            v = new boolean[idx];\n            int min = Integer.MAX_VALUE;\n            ans = Integer.MAX_VALUE;\n            for(int i=1; i<idx; i++){\n                ans = Integer.MAX_VALUE;\n                goal = i;\n                dfs(0,0,0);\n                min = Math.min(min,ans);\n            }\n\n            if(min==Integer.MAX_VALUE) System.out.println(-1);\n            else System.out.println(min);\n        }\n    }\n\n    void bfs(int sx, int sy){\n        LinkedList<int[]> list = new LinkedList<int[]>();\n        list.add(new int[]{sx,sy});\n        d = new int[h][w];\n        for(int i=0; i<h; i++) Arrays.fill(d[i],Integer.MAX_VALUE);\n        d[sy][sx] = 0;\n\n        while(list.size()>0){\n            int[] xy = list.poll();\n            int xx = xy[0], yy = xy[1];\n\n            for(int i=0; i<4; i++){\n                int nx = xx+dx[i], ny = yy+dy[i];\n                if(nx>=0 && nx<w && ny>=0 && ny<h\n                   && d[ny][nx]==Integer.MAX_VALUE\n                   && map[ny][nx]!='x'){\n                    list.add(new int[]{nx,ny});\n                    d[ny][nx] = d[yy][xx]+1;\n                }\n            }\n        }\n    }\n\n    void dfs(int pos, int cnt, int distt){\n        if(pos==goal){\n            if(cnt==n-1) ans = Math.min(ans,distt);\n            return;\n        }\n\n        for(int i=1; i<n; i++){\n            if(v[i]) continue;\n            v[i] = true;\n            dfs(i,cnt+1,distt+dist[pos][i]);\n            v[i] = false;\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tstatic Deque<Tilemap> q = new ArrayDeque<Tilemap>();\n\tstatic int[] dx = {1, 0, -1, 0};\n\tstatic int[] dy = {0, 1, 0, -1};\n\n\tpublic static class Tilemap{\n\t\tint x, y;\n\t\tint dirty_tile_num;\n\t\tint count;\n\t\tTilemap(int j, int i, int d, int c){\n\t\t\tx = j;\n\t\t\ty = i;\n\t\t\tdirty_tile_num = d;\n\t\t\tcount = c;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w==0&&h==0) break;\n\t\t\tint[][] tile = new int[h+2][w+2];\n\t\t\tint dirty_tile_num = 0;\n\t\t\tTilemap start = new Tilemap(0, 0, 0, 0);\n\n\t\t\tfor(int i=1; i<=h; i++){\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\t\tif(str.charAt(j-1)=='.'){\n\t\t\t\t\t\ttile[i][j] = 1;\n\t\t\t\t\t}else if(str.charAt(j-1)=='*'){\n\t\t\t\t\t\ttile[i][j] = 2;\n\t\t\t\t\t\tdirty_tile_num++;\n\t\t\t\t\t}else if(str.charAt(j-1)=='o'){\n\t\t\t\t\t\tstart = new Tilemap(j, i, 0, -1);\n\t\t\t\t\t\ttile[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart.dirty_tile_num = dirty_tile_num;\n\t\t\tq.offer(start);\n\n\t\t\tint move = -1;\n\t\t\tint[][] map = new int[h+2][w+2];\n\t\t\tfor(int i=0; i<tile.length; i++){\n\t\t\t\tmap[i] = tile[i].clone();\n\t\t\t}\n\n\t\t\tTilemap xy = new Tilemap(0, 0, 0, 0);\n\t\t\tint x,y;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\txy = q.poll();\n\t\t\t\tx = xy.x; y = xy.y;\n\t\t\t\txy.count++;\n\t\t\t\tif(map[y][x]==2){\n\t\t\t\t\txy.dirty_tile_num--;\n\t\t\t\t\tif(xy.dirty_tile_num==0){\n\t\t\t\t\t\tmove = xy.count;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tq.clear();\n\t\t\t\t\ttile[y][x] = 1;\n\t\t\t\t\tfor(int i=0; i<tile.length; i++){\n\t\t\t\t\t\tmap[i] = tile[i].clone();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tmap[y][x] = 0;\n\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tif(map[y+dy[i]][x+dx[i]]!=0){\n\t\t\t\t\t\tq.offer(new Tilemap(x+dx[i], y+dy[i], xy.dirty_tile_num, xy.count));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(move);\n\n\t\t\tq.clear();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid run(){\n\t\tnew AOJ1140();\n\t}\n\t\n\tclass AOJ1140{\n\t\tint w,h;\n\t\tfinal int INF=Integer.MAX_VALUE/4;\n\t\tAOJ1140(){\n\t\t\twhile(true){\n\t\t\t\tw=sc.nextInt();\n\t\t\t\th=sc.nextInt();\n\t\t\t\tif((w|h)==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tvoid solve(){\n\t\t\tint[][] map=new int[w][h];\n\t\t\tint sx=0,sy=0,c=1;\n\t\t\tfor(int y=0; y<h; ++y){\n\t\t\t\tchar[] line=sc.next().toCharArray();\n\t\t\t\tfor(int x=0; x<w; ++x){\n\t\t\t\t\tif(line[x]=='o'){\n\t\t\t\t\t\tsx=x;\n\t\t\t\t\t\tsy=y;\n\t\t\t\t\t}else if(line[x]=='x'){\n\t\t\t\t\t\tmap[x][y]=-1;\n\t\t\t\t\t}else if(line[x]=='*'){\n\t\t\t\t\t\tmap[x][y]=c++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t--c;\t// number of dirty tile\n\t\t\tint b=(1<<c)-1;\n//\t\t\tSystem.out.println(Integer.bitCount(b));\n//\t\t\tSystem.out.println(Integer.toBinaryString(b));\n\t\t\tint[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\t\t\t\n\t\t\tint[][][] closed=new int[w][h][b+1];\n//\t\t\tfor(int x=0; x<w; ++x)for(int y=0; y<h; ++y)for(int z=0; z<=b; ++z)closed[x][y][z]=(x==sx&&y==sy&&z==b?0:INF);\n\t\t\tfor(int x=0; x<w; ++x)for(int y=0; y<h; ++y)for(int z=0; z<=b; ++z)closed[x][y][z]=INF;\n\t\t\tclosed[sx][sy][b]=0;\n\n\t\t\tLinkedList<state> open=new LinkedList<state>();\n\t\t\topen.add(new state(sx,sy,b,0));\n\t\t\t\n\t\t\tint ans=-1;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tstate now=open.poll();\n//\t\t\t\tSystem.out.println(now);\n\t\t\t\tif(now.t==0){\n\t\t\t\t\tans=now.z;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int v=0; v<4; ++v){\n\t\t\t\t\tint xx=now.x+vx[v], yy=now.y+vy[v];\n\t\t\t\t\tif(!(0<=xx && xx<w && 0<=yy && yy<h))\tcontinue;\n\t\t\t\t\tif(map[xx][yy]<0)\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tint nt=now.t;\n\t\t\t\t\tif(map[xx][yy]>0)\tnt = now.t^(1<<(map[xx][yy]-1));\n\t\t\t\t\t\n\t\t\t\t\tif(closed[xx][yy][nt]<=now.z+1)\tcontinue;\n\t\t\t\t\tclosed[xx][yy][nt]=now.z+1;\n\t\t\t\t\topen.add(new state(xx,yy,nt,now.z+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\tclass state{\n\t\t\tint x,y,t,z;\n\t\t\tstate(int x,int y,int t,int z){\n\t\t\t\tthis.x=x;\n\t\t\t\tthis.y=y;\n\t\t\t\tthis.t=t;\n\t\t\t\tthis.z=z;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn \"x:\"+x+\" y:\"+y+\" t:\"+Integer.toBinaryString(t)+\" z:\"+z;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ1138{\n\t\tint n,m,p,a,b;\n\t\tfinal int INF=Integer.MAX_VALUE/4;\n\t\tAOJ1138(){\n\t\t\twhile(true){\n\t\t\t\tn=sc.nextInt();\n\t\t\t\tm=sc.nextInt();\n\t\t\t\tp=sc.nextInt();\n\t\t\t\ta=sc.nextInt();\n\t\t\t\tb=sc.nextInt();\n\t\t\t\tif(n==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tvoid solve(){\n\t\t\tint[] tickets=new int[n];\n\t\t\tfor(int i=0; i<n; ++i)\ttickets[i]=sc.nextInt();\n\t\t\tint[][] path=new int[m][m];\n\t\t\tfor(int i=0; i<m; ++i)for(int j=0; j<m; ++j)path[i][j]=INF;\n\t\t\tfor(int i=0; i<p; ++i){\n\t\t\t\tint x=sc.nextInt(),y=sc.nextInt(),z=sc.nextInt();\n\t\t\t\t--x;\n\t\t\t\t--y;\n\t\t\t\tpath[x][y]=z;\n\t\t\t\tpath[y][x]=z;\n\t\t\t}\n\t\t\t\n\t\t\t--a;\n\t\t\t--b;\n\t\t\t\n\t\t\tint bit=(1<<n)-1;\n//\t\t\tSystem.out.println(Integer.bitCount(bit));\n\t\t\tdouble[][] closed=new double[m][bit+1];\n\t\t\tfor(int i=0; i<m; ++i)for(int j=0; j<=bit; ++j)closed[i][j]=(i==a? 0 : INF);\n\t\t\t\n\t\t\tPriorityQueue<state> open = new PriorityQueue<state>();\n\t\t\topen.add(new state(a,bit,0));\n\t\t\t\n\t\t\tdouble ans=INF;\n\t\t\t\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tstate now = open.poll();\n//\t\t\t\tSystem.out.println(now);\n\t\t\t\tif(now.p==b){\n\t\t\t\t\tans=min(ans,now.z);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int to=0; to<m; to++){\n\t\t\t\t\tif(path[now.p][to]>=INF)\tcontinue;\n\t\t\t\t\tif(now.p==to)\tcontinue;\n\t\t\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\t\t\tif( (now.t & (1<<i) ) == 0 )\tcontinue;\n\t\t\t\t\t\tdouble a = (double)path[now.p][to]/(double)tickets[i];\n\t\t\t\t\t\tint b = now.t^(1<<i);\n\t\t\t\t\t\tif(closed[to][b] <= now.z+a)\tcontinue;\n\t\t\t\t\t\tclosed[to][b] = now.z+a;\n\t\t\t\t\t\topen.add(new state(to,b,now.z+a));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(ans>=INF ? \"Impossible\" : ans);\n\t\t}\n\t\tclass state implements Comparable<state>{\n\t\t\tint p,t;\n\t\t\tdouble z;\n\t\t\tstate(int p,int t,double z){\n\t\t\t\tthis.p=p;\n\t\t\t\tthis.t=t;\n\t\t\t\tthis.z=z;\n\t\t\t}\n\t\t\t@Override public int compareTo(state o){\n\t\t\t\treturn (int)(this.z-o.z);\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn \"p:\"+p+\" t:\"+Integer.toBinaryString(t)+\" z:\"+z;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ1135{\n\t\tAOJ1135(){\n\t\t\tint n=sc.nextInt();\n\t\t\twhile(--n>=0)\tsolve();\n\t\t}\n\t\tvoid solve(){\n\t\t\tint m=sc.nextInt(),y=sc.nextInt(),n=sc.nextInt(),ans=0;\n\t\t\twhile(--n>=0){\n\t\t\t\tint a=sc.nextInt();\n\t\t\t\tdouble rate = sc.nextDouble();\n\t\t\t\tint b=sc.nextInt();\n\t\t\t\tif(a==0){\n\t\t\t\t\tint mm=m,c=0;\n\t\t\t\t\tfor(int i=0; i<y; ++i){\n\t\t\t\t\t\tc += (double)mm*rate;\n\t\t\t\t\t\tmm-=b;\n\t\t\t\t\t}\n\t\t\t\t\tans=max(ans, mm+c);\n\t\t\t\t}else{\n\t\t\t\t\tint mm=m;\n\t\t\t\t\tfor(int i=0; i<y; ++i){\n\t\t\t\t\t\tmm+=(double)mm*rate;\n\t\t\t\t\t\tmm-=b;\n\t\t\t\t\t}\n\t\t\t\t\tans=max(ans, mm);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\t\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n    int w,h;\n    char[][] map;\n    int[][] d,dist;\n    int[] x,y;\n    int[] dx = {0,0,1,-1};\n    int[] dy = {1,-1,0,0};\n    int n,goal,ans;\n    boolean[] v;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            w = sc.nextInt();\n            h = sc.nextInt();\n            if(w==0 && h==0) break;\n\n            map = new char[h][w];\n            x = new int[11];\n            y = new int[11];\n            int idx = 1;\n            for(int i=0; i<h; i++){\n                String s = sc.next();\n                map[i] = s.toCharArray();\n                for(int j=0; j<w; j++){\n                    if(map[i][j]=='o'){\n                        x[0] = j; y[0] = i;\n                    }else if(map[i][j]=='*'){\n                        x[idx] = j; y[idx] = i;\n                        idx++;\n                    }\n                }\n            }\n\n            dist = new int[idx][idx];\n            for(int i=0; i<idx; i++){\n                bfs(x[i],y[i]);\n                for(int j=0; j<idx; j++){\n                    dist[i][j] = d[y[j]][x[j]];\n                }\n            }\n\n            n = idx;\n            v = new boolean[idx];\n            int min = Integer.MAX_VALUE;\n            ans = Integer.MAX_VALUE;\n            for(int i=1; i<idx; i++){\n                ans = Integer.MAX_VALUE;\n                goal = i;\n                dfs(0,0,0);\n                min = Math.min(min,ans);\n            }\n\n            if(min==Integer.MAX_VALUE) System.out.println(-1);\n            else System.out.println(min);\n        }\n    }\n\n    void bfs(int sx, int sy){\n        LinkedList<int[]> list = new LinkedList<int[]>();\n        list.add(new int[]{sx,sy});\n        d = new int[h][w];\n        for(int i=0; i<h; i++) Arrays.fill(d[i],Integer.MAX_VALUE);\n        d[sy][sx] = 0;\n\n        while(list.size()>0){\n            int[] xy = list.poll();\n            int xx = xy[0], yy = xy[1];\n\n            for(int i=0; i<4; i++){\n                int nx = xx+dx[i], ny = yy+dy[i];\n                if(nx>=0 && nx<w && ny>=0 && ny<h\n                   && d[ny][nx]==Integer.MAX_VALUE\n                   && map[ny][nx]!='x'){\n                    list.add(new int[]{nx,ny});\n                    d[ny][nx] = d[yy][xx]+1;\n                }\n            }\n        }\n    }\n\n    void dfs(int pos, int cnt, int distt){\n        if(pos==goal){\n            if(cnt==n-1) ans = Math.min(ans,distt);\n            return;\n        }\n\n        for(int i=1; i<n; i++){\n            if(v[i]) continue;\n            v[i] = true;\n            dfs(i,cnt+1,distt+dist[pos][i]);\n            v[i] = false;\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\nimport java.util.Queue;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\n\npublic class Main {\n\tpublic static int bfs(int h, int w, int[][] matrix, int[] start, int dirt) {\n\t\tArrayDeque<int[]> q = new ArrayDeque<int[]>();\n\t\tint[][][] dist = new int[h][w][(int)Math.pow(2, dirt)];\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tfor(int k=0; k<(int)Math.pow(2, dirt); k++) {\n\t\t\t\t\tdist[i][j][k] = 100000;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdist[start[0]][start[1]][(int)Math.pow(2, dirt)-1] = 0;\n\t\tint[][] d = {{1,0}, {-1,0}, {0,1}, {0,-1}};\n\t\tint[] spos = {start[0], start[1], (int)Math.pow(2, dirt)-1};\n\t\tq.addLast(spos);\n\t\twhile(q.size()>0) {\n\t\t\tint[] pos = q.pollFirst();\n\t\t\tfor(int[] delta: d) {\n\t\t\t\tif(pos[0]+delta[0]<0 || pos[1]+delta[1]<0 || h<=pos[0]+delta[0] || w<=pos[1]+delta[1]) continue;\n\t\t\t\tif(matrix[pos[0]+delta[0]][pos[1]+delta[1]] == -1) continue;\n\t\t\t\tif(matrix[pos[0]+delta[0]][pos[1]+delta[1]] > 0 && (pos[2] & (int)Math.pow(2, matrix[pos[0]+delta[0]][pos[1]+delta[1]]-1)) > 0) {\n\t\t\t\t\tint dNum = matrix[pos[0]+delta[0]][pos[1]+delta[1]]-1;\n\t\t\t\t\tif((int)Math.pow(2, dNum) == pos[2]) return dist[pos[0]][pos[1]][pos[2]]+1;\n\t\t\t\t\tif(dist[pos[0]+delta[0]][pos[1]+delta[1]][pos[2]-(int)Math.pow(2, dNum)] <= dist[pos[0]][pos[1]][pos[2]]+1) continue;\n\t\t\t\t\tdist[pos[0]+delta[0]][pos[1]+delta[1]][pos[2]-(int)Math.pow(2, dNum)] = dist[pos[0]][pos[1]][pos[2]]+1;\n\t\t\t\t\tint[] next = {pos[0]+delta[0], pos[1]+delta[1], pos[2]-(int)Math.pow(2, dNum)};\n\t\t\t\t\tq.addLast(next);\n\t\t\t\t} else {\n\t\t\t\t\tif(dist[pos[0]+delta[0]][pos[1]+delta[1]][pos[2]] <= dist[pos[0]][pos[1]][pos[2]]+1) continue;\n\t\t\t\t\tdist[pos[0]+delta[0]][pos[1]+delta[1]][pos[2]] = dist[pos[0]][pos[1]][pos[2]]+1;\n\t\t\t\t\tint[] next = {pos[0]+delta[0], pos[1]+delta[1], pos[2]};\n\t\t\t\t\tq.addLast(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tFS r = new FS();\n\t\twhile(true) {\n\t\t\tint w = r.nextInt();\n\t\t\tint h = r.nextInt();\n\t\t\tint dirt = 0;\n\t\t\tint[][] pos = new int[10][2];\n\t\t\tif(w==0) break;\n\t\t\tint[][] matrix = new int[h][w];\n\t\t\tfor(int i=0; i<h; i++) {\n\t\t\t\tString s = r.next();\n\t\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\t\tswitch(s.charAt(j)) {\n\t\t\t\t\t\tcase 'o':\n\t\t\t\t\t\t\tpos[0][0] = i;\n\t\t\t\t\t\t\tpos[0][1] = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\tdirt++;\n\t\t\t\t\t\t\tpos[dirt][0] = i;\n\t\t\t\t\t\t\tpos[dirt][1] = j;\n\t\t\t\t\t\t\tmatrix[i][j] = dirt;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'x':\n\t\t\t\t\t\t\tmatrix[i][j] = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(bfs(h, w, matrix, pos[0], dirt));\n\t\t}\n\t}\n\t\n\t// Read Class\n\tstatic class FS {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\n\t\tprivate int readByte() { return hasNextByte() ? buffer[ptr++] : -1;}\n\t\tprivate boolean isPrintableChar(int c) {return 33 <= c && c <= 126;}\n\t\tprivate void skipUnprintable() {while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t\n\t\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile(isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if(b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\tint n, w, h;\n\tchar[][] f;\n\tint sx, sy;\n\tint[] gx, gy;\n\tint[][] g;\n\n\tclass D implements Comparable<D>{\n\t\tint pos;\n\t\tint min;\n\t\tint bit;\n\n\t\tD(int pos, int min, int bit) {\n\t\t\tthis.pos = pos;\n\t\t\tthis.min = min;\n\t\t\tthis.bit = bit;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(D o) {\n\t\t\tif (this.min != o.min)\n\t\t\t\treturn this.min - o.min;\n\t\t\tif (this.pos != o.pos)\n\t\t\t\treturn this.pos - o.pos;\n\t\t\treturn this.bit - o.bit;\n\t\t}\n\t}\n\n\tint dist(int sx, int sy, int gx, int gy) {\n\t\tint[][] visit = new int[h][w];\n\t\tint[] dx = {-1, 0, 0, 1};\n\t\tint[] dy = {0, -1, 1, 0};\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tArrays.fill(visit[i], -1);\n\t\t}\n\t\tvisit[sy][sx] = 0;\n\n\t\tQueue<Integer> queueX = new LinkedList<Integer>();\n\t\tQueue<Integer> queueY = new LinkedList<Integer>();\n\t\tqueueX.add(sx);\n\t\tqueueY.add(sy);\n\t\twhile (!queueX.isEmpty()) {\n\t\t\tint x = queueX.poll();\n\t\t\tint y = queueY.poll();\n\t\t\tif (x == gx && y == gy) {\n\t\t\t\treturn visit[y][x];\n\t\t\t}\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nx = x + dx[i];\n\t\t\t\tint ny = y + dy[i];\n\t\t\t\tif (nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n\t\t\t\tif (f[ny][nx] == 'x') continue;\n\t\t\t\tif (visit[ny][nx] != -1) continue;\n\n\t\t\t\tqueueX.add(nx);\n\t\t\t\tqueueY.add(ny);\n\t\t\t\tvisit[ny][nx] = visit[y][x] + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tint dijkstra(int sx, int sy) {\n\t\tPriorityQueue<D> queue = new PriorityQueue<D>();\n\t\tint mask = (1 << n) - 1;\n\t\tqueue.add(new D(0, 0, 0));\n\n\t\twhile (!queue.isEmpty()) {\n\t\t\tD d = queue.poll();\n\t\t\tint pos = d.pos;\n\t\t\tint min = d.min;\n\t\t\tint bit = d.bit;\n\t\t\tif (bit == mask) {\n\t\t\t\treturn min;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (0 < (bit & (1 << i))) continue;\n\t\t\t\tint npos = i + 1;\n\t\t\t\tint nmin = min + g[pos][npos];\n\t\t\t\tint nbit = bit | (1 << i);\n\t\t\t\tqueue.add(new D(npos, nmin, nbit));\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif ((w | h) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn = 0;\n\t\t\tf = new char[h][];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tf[i] = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (f[i][j] == '*') n++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgx = new int[n];\n\t\t\tgy = new int[n];\n\t\t\tint id = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (f[i][j] == '*') {\n\t\t\t\t\t\tgx[id] = j;\n\t\t\t\t\t\tgy[id] = i;\n\t\t\t\t\t\tid++;\n\t\t\t\t\t} else if (f[i][j] == 'o') {\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tg = new int[n + 1][n + 1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint dist = dist(sx, sy, gx[i], gy[i]);\n\t\t\t\tg[0][i + 1] = g[i + 1][0] = dist;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tint dist = dist(gx[i], gy[i], gx[j], gy[j]);\n\t\t\t\t\tg[i + 1][j + 1] = g[j + 1][i + 1] = dist;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(dijkstra(sx, sy));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n    int w,h,sx,sy;\n    char[][] tile;\n    ArrayList<Point> p;\n    int[][] dist,d,dp;\n    int INF = 100000000;\n\n    class Point{\n\tint x,y;\n\tpublic Point(int x, int y){\n\t    this.x = x;\n\t    this.y = y;\n\t}\n    }\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\twhile(true){\n\t    w = sc.nextInt();\n\t    h = sc.nextInt();\n\t    if(w==0 && h==0)break;\n\n\t    tile = new char[h][w];\n\t    p = new ArrayList<Point>();\n\t    for(int i=0; i<h; i++){\n\t\tString line = sc.next();\n\t\tfor(int j=0; j<w; j++){\n\t\t    tile[i][j] = line.charAt(j);\n\t\t    if(tile[i][j]=='o'){sx = j; sy = i;}\n\t\t    if(tile[i][j]=='*')\tp.add(new Point(j,i));\n\t\t}\n\t    }\n\t    p.add(new Point(sx,sy));\n\n\t    //距離行列作成\n\t    d = new int[p.size()][p.size()];\n\t    for(int i=0; i<p.size(); i++) Arrays.fill(d[i],INF);\n\t    for(int i=0; i<p.size(); i++){\n\t\tdist = new int[h][w];\n\t\tfor(int j=0; j<h; j++) Arrays.fill(dist[j],INF);\n\t\tbfs(i);\n\t\tfor(int j=0; j<p.size(); j++){\n\t\t    d[i][j] = dist[p.get(j).y][p.get(j).x];\n\t\t}\n\t    }\n\n\t    //TSP\n\t    dp = new int[1 << p.size()][p.size()];\n\t    for(int i=0; i<1<<p.size(); i++)Arrays.fill(dp[i],-1);\n\t    int ans = tsp(0,p.size()-1);\n\t    System.out.println(ans==INF ? -1:ans);\n\t}\n    }\n\n    void bfs(int s){\n\tint[] dx = {0,0,1,-1};\n\tint[] dy = {1,-1,0,0};\n\n\tLinkedList<Point> q = new LinkedList<Point>();\n\tq.add(new Point(p.get(s).x,p.get(s).y));\n\tdist[p.get(s).y][p.get(s).x] = 0;\n\n\twhile(q.size()>0){\n\t    Point point = q.poll();\n\t    for(int i=0; i<4; i++){\n\t\tint nx = point.x+dx[i];\n\t\tint ny = point.y+dy[i];\n\t\tif(nx>=0 && nx<w && ny>=0 && ny<h && tile[ny][nx]!='x' && dist[ny][nx]==INF){\n\t\t    q.add(new Point(nx,ny));\n\t\t    dist[ny][nx] = dist[point.y][point.x]+1;\n\t\t}\n\t    }\n\t}\n    }\n\n    int tsp(int S, int v){\n\tif(dp[S][v]>=0) return dp[S][v];\n\n\tif(S==(1<<p.size())-1) return dp[S][v] = 0;\n\n\tint res = INF;\n\tfor(int i=0; i<p.size(); i++){\n\t    if((S>>i&1)==0){\n\t\tres = Math.min(res,tsp(S|1<<i,i)+d[v][i]);\n\t    }\n\t}\n\n\treturn dp[S][v] = res;\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint w, h;\n\tboolean map[][];\n\tP s;\n\tLinkedList<P> dusts;\n\tP[] da;\n\tint[][] d;\n\tint size;\n\tint[] mem;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif( (w|h) == 0 ) break;\n\t\t\tmap = new boolean[h+2][w+2];\n\t\t\tdusts = new LinkedList<P>();\n\t\t\tfor(int i=1;i<=h;i++) {\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor(int j=1;j<=w;j++) {\n\t\t\t\t\tswitch (str.charAt(j-1)) {\n\t\t\t\t\tcase '*' :\n\t\t\t\t\t\tdusts.add(new P(j, i));\n\t\t\t\t\t\tmap[i][j] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'x':\n\t\t\t\t\t\tmap[i][j] = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'o':\n\t\t\t\t\t\ts = new P(i, j);\n\t\t\t\t\t\tmap[i][j] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tmap[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsize = dusts.size();\n\t\t\t\n\t\t\tda = new P[size+1];\n\t\t\tda[0] = s;\n\t\t\tfor(int i=1;i<=size;i++) da[i] = dusts.remove();\n\t\t\td = new int[size+1][size+1];\n\t\t\tboolean flg = true;\n\t\t\t\n\t\t\tfor(int i=0;i<size+1;i++) for(int j=i+1;j<size+1;j++) {\n\t\t\t\td[i][j] = d[j][i] = bfs(da[i], da[j]);\n\t\t\t\tif(d[i][j] == INF ) flg = false;\n\t\t\t}\n\t\t\tif(!flg) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tmem = new int[1<<(size+1)];\n\t\t\tfill(mem, -1);\n\t\t\tSystem.out.println( solve( (1<<(size+1)) - 1, 0 ) );\n\t\t}\n\t}\n\t\n\tint solve(int S, int node) {\n\t\tif( mem[S] >= 0 ) return mem[S];\n\t\tif( S == 0 ) return mem[S] = 0;\n\t\tint t = INF;\n\t\tfor(int i=0;i<size+1;i++) {\n\t\t\tif( ((S>>i)&1) == 1 ) {\n\t\t\t\tt = min(t, solve(S-(1<<i), i) + d[node][i] );\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn mem[S] = t;\n\t}\n\t\n\tint dx[] = {-1,0,1,0};\n\tint dy[] = {0,-1,0,1};\n\t\n\tint bfs(P s, P t) {\n\t\tboolean[][] tmp = new boolean[h+2][w+2];\n\t\tfor(int i=0;i<h+2;i++) for(int j=0;j<w+2;j++)\n\t\t\ttmp[i][j] = map[i][j];\n\t\tP now = new P(s.x, s.y);\n\t\tLinkedList<P> que = new LinkedList<P>();\n\t\tque.add(now);\n\t\tfor( ;!que.isEmpty(); ) {\n\t\t\tnow = que.removeFirst();\n\t\t\tif( now.x == t.x && now.y == t.y ) return now.cnt;\n\t\t\ttmp[now.y][now.x] = false;\n\t\t\tfor(int i=0;i<4;i++) {\n\t\t\t\tif( tmp[now.y+dy[i]][now.x+dx[i]] ) \n\t\t\t\t\tque.addLast(new P(now.x + dx[i], now.y + dy[i], now.cnt + 1));\n\t\t\t}\n\t\t}\n\t\treturn INF;\n\t}\n\t\n\tclass P {\n\t\tint x, y, cnt;\n\t\tP(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tcnt = 0;\n\t\t}\n\t\tP(int x, int y, int cnt) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.cnt = cnt;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n    static int W, H;\n    static int[][] map;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            W = sc.nextInt();\n            H = sc.nextInt();\n            if ((W | H) == 0) {\n                break;\n            }\n            map = new int[H][W];\n            Point ps = new Point(0, 0);\n            int dtc = 0;\n\n            for (int i = 0; i < H; i++) {\n                String line = sc.next();\n                for (int j = 0; j < W; j++) {\n                    if (line.charAt(j) == 'o') {\n                        ps.y = i;\n                        ps.x = j;\n                    }\n                    if (line.charAt(j) == '*') {\n                        map[i][j] = 1;\n                        dtc++;\n                    }\n                    if (line.charAt(j) == 'x') {\n                        map[i][j] = 2;\n                    }\n                }\n            }\n            Point[] dts = new Point[dtc];\n            int l = 0;\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    if (map[i][j] == 1) {\n                        dts[l] = new Point(i, j);\n                        l++;\n                    }\n                }\n            }\n            int[][] dis = new int[dtc][dtc];\n            for (int i = 0; i < dtc; i++) {\n                for (int j = i + 1; j < dtc; j++) {\n                    dis[j][i] = dis[i][j] = bfs(dts[i], dts[j]);\n                }\n            }\n            int[][] dp = new int[1 << dtc][dtc];\n            for (int i = 0; i < (1 << dtc); i++) {\n                Arrays.fill(dp[i], 10000);\n            }\n            boolean noGoal = false;\n            for (int i = 0; i < dtc; i++) {\n                dp[1 << i][i] = bfs(ps, dts[i]);\n                if (dp[1 << i][i] == -1) {\n                    noGoal = true;\n                }\n            }\n            for (int i = 0; i < (1 << dtc); i++) {\n                for (int j = 0; j < dtc; j++) {\n                    for (int k = 0; k < dtc; k++) {\n                        dp[i | (1 << k)][k] = Math.min(\n                                dp[i | (1 << k)][k],\n                                dp[i][j] + dis[j][k]\n                        );\n                    }\n                }\n            }\n            int min = Integer.MAX_VALUE;\n            for (int i = 0; i < dtc; i++) {\n                min = Math.min(min, dp[(1 << dtc) - 1][i]);\n            }\n            System.out.println(noGoal ? -1 : min);\n        }\n    }\n\n    public static int bfs(Point s, Point g) {\n        int[][] b = new int[H][W];\n        for (int[] bs : b) {\n            Arrays.fill(bs, -1);\n        }\n        Queue<Point> q = new ArrayDeque<>();\n        q.add(s);\n        int[] d = new int[]{0, 1, 0, -1, 0};\n        b[s.y][s.x] = 0;\n        while (!q.isEmpty()) {\n            Point p = q.poll();\n            if (p.y == g.y && p.x == g.x) {\n                return b[g.y][g.x];\n            }\n            for (int i = 0; i < 4; i++) {\n                int nx = p.x + d[i];\n                int ny = p.y + d[i + 1];\n                if (nx < 0 || nx >= W || ny < 0 || ny >= H) {\n                    continue;\n                }\n                if (map[ny][nx] == 2) {\n                    continue;\n                }\n                if (b[ny][nx] >= 0 && b[ny][nx] <= b[p.y][p.x] + 1) {\n                    continue;\n                }\n                b[ny][nx] = b[p.y][p.x] + 1;\n                q.add(new Point(ny, nx));\n            }\n        }\n        return -1;\n    }\n\n    public static void arrayDump(int[][] a) {\n        for (int i = 0, l = a.length; i < l; i++) {\n            for (int j = 0, l2 = a[0].length; j < l2; j++) {\n                System.out.print(a[i][j] + \" \");\n            }\n            System.out.println();\n        }\n        System.out.println();\n    }\n\n    static class Point {\n        public int y, x;\n\n        Point(int y, int x) {\n            this.y = y;\n            this.x = x;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Cleaning Robot\npublic class Main{\n\n\tstatic int min;\n\tstatic boolean[] used;\n\tstatic int[][] dist;\n\t\n\tstatic void dfs(int[] order, int k){\n\t\tif(k==order.length){\n\t\t\tint s = 0;\n\t\t\tint from = 0;\n\t\t\tfor(int i=0;i<order.length;i++){\n\t\t\t\ts += dist[from][order[i]];\n\t\t\t\tfrom = order[i];\n\t\t\t}\n\t\t\tmin = Math.min(min, s);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=1;i<=order.length;i++){\n\t\t\tif(!used[i]){\n\t\t\t\tused[i] = true;\n\t\t\t\torder[k] = i;\n\t\t\t\tdfs(order, k+1);\n\t\t\t\tused[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] move = {{1,0},{-1,0},{0,1},{0,-1}};\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tchar[][] m = new char[h][w];\n\t\t\tint id = 1;\n\t\t\tMap<Integer, Integer> ref = new HashMap<Integer, Integer>();\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tchar[] s = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tm[i][j] = s[j];\n\t\t\t\t\tif(m[i][j]=='*'){\n\t\t\t\t\t\tref.put(i*w+j, id++);\n\t\t\t\t\t}\n\t\t\t\t\tif(m[i][j]=='o'){\n\t\t\t\t\t\tref.put(i*w+j, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdist = new int[id][id];\n\t\t\tfor(int[]a:dist)Arrays.fill(a, Integer.MAX_VALUE);\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(m[i][j]=='o'||m[i][j]=='*'){\n\t\t\t\t\t\tint from = ref.get(i*w+j);\n\t\t\t\t\t\tboolean[][] visited = new boolean[h][w];\n\t\t\t\t\t\tvisited[i][j] = true;\n\t\t\t\t\t\tint step = 0;\n\t\t\t\t\t\tList<int[]> list = new ArrayList<int[]>();\n\t\t\t\t\t\tlist.add(new int[]{i, j});\n\t\t\t\t\t\twhile(!list.isEmpty()){\n\t\t\t\t\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\t\t\t\t\tfor(int[] a:list){\n\t\t\t\t\t\t\t\tif(ref.containsKey(a[0]*w+a[1])){\n\t\t\t\t\t\t\t\t\tdist[from][ref.get(a[0]*w+a[1])] = step;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\t\t\t\tint ni = a[0] + move[k][0];\n\t\t\t\t\t\t\t\t\tint nj = a[1] + move[k][1];\n\t\t\t\t\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]!='x'&&!visited[ni][nj]){\n\t\t\t\t\t\t\t\t\t\tvisited[ni][nj] = true;\n\t\t\t\t\t\t\t\t\t\tnext.add(new int[]{ni, nj});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlist = next;\n\t\t\t\t\t\t\tstep++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean f = true;\n\t\t\tfor(int i=0;i<id;i++)if(dist[0][i]==Integer.MAX_VALUE)f = false;\n\t\t\tif(!f){\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmin = Integer.MAX_VALUE;\n\t\t\tused = new boolean[id];\n\t\t\tused[0] = true;\n\t\t\tdfs(new int[id-1], 0);\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = false;\n\tstatic final int[] d = { 0, 1, 0, -1 };\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint w = ir.nextInt();\n\t\t\tint h = ir.nextInt();\n\t\t\tif (h == 0 && w == 0)\n\t\t\t\treturn;\n\t\t\tchar[][] map = ir.nextCharMap(h, w);\n\t\t\tGraph[] g = new Graph[h * w];\n\t\t\tfor (int i = 0; i < h * w; i++)\n\t\t\t\tg[i] = new Graph();\n\t\t\tArrayList<Integer> dir = new ArrayList<Integer>();\n\t\t\tint s = -1;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (map[i][j] == 'x')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (map[i][j] == 'o')\n\t\t\t\t\t\ts = i * w + j;\n\t\t\t\t\tif (map[i][j] == '*')\n\t\t\t\t\t\tdir.add(i * w + j);\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tint nx = i + d[k];\n\t\t\t\t\t\tint ny = j + d[k ^ 1];\n\t\t\t\t\t\tif (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx][ny] != 'x') {\n\t\t\t\t\t\t\tg[i * w + j].add(new int[] { nx * w + ny, 1 });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] dist = new int[dir.size() + 1][];\n\t\t\tint mi = 1 << 29;\n\t\t\tdist[0] = dijkstra(s, g);\n\t\t\tfor (int i = 1; i <= dir.size(); i++)\n\t\t\t\tdist[i] = dijkstra(dir.get(i - 1), g);\n\t\t\tint[] ord = new int[dir.size()];\n\t\t\tfor (int i = 0; i < dir.size(); i++)\n\t\t\t\tord[i] = i;\n\t\t\tdo {\n\t\t\t\tint pre = s, ret = 0;\n\t\t\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\t\t\tif (dist[ord[i] + 1][pre] == 1 << 29) {\n\t\t\t\t\t\tout.println(-1);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tret += dist[ord[i] + 1][pre];\n\t\t\t\t\tpre = dir.get(ord[i]);\n\t\t\t\t}\n\t\t\t\tmi = Math.min(mi, ret);\n\t\t\t} while (next_permutation(ord));\n\t\t\tout.println(mi);\n\t\t}\n\t}\n\n\tpublic static boolean next_permutation(int[] a) {\n\t\tfor (int i = a.length - 2; i >= 0; i--) {\n\t\t\tif (a[i] < a[i + 1]) {\n\t\t\t\tfor (int j = a.length - 1;; j--) {\n\t\t\t\t\tif (a[i] < a[j]) {\n\t\t\t\t\t\tint temp = a[i];\n\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\ta[j] = temp;\n\t\t\t\t\t\tfor (i++, j = a.length - 1; i < j; i++, j--) {\n\t\t\t\t\t\t\ttemp = a[i];\n\t\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\t\ta[j] = temp;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic class Graph extends ArrayList<int[]> {\n\t}\n\n\tprivate static int[] dijkstra(int s, Graph[] g) {\n\t\tint[] d = new int[g.length];\n\t\tPriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\treturn a[1] - b[1];\n\t\t\t}\n\t\t});\n\t\tArrays.fill(d, 1 << 29);\n\t\td[s] = 0;\n\t\tpq.offer(new int[] { s, 0 });\n\t\twhile (!pq.isEmpty()) {\n\t\t\tint[] p = pq.poll();\n\t\t\tint from = p[0];\n\t\t\tfor (int i = 0; i < g[from].size(); i++) {\n\t\t\t\tint[] e = g[from].get(i);\n\t\t\t\tint to = e[0];\n\t\t\t\tif (d[to] > d[from] + e[1]) {\n\t\t\t\t\td[to] = d[from] + e[1];\n\t\t\t\t\tpq.offer(new int[] { to, d[to] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid run(){\n\t\tnew AOJ1140();\n\t}\n\t\n\tclass AOJ1140{\n\t\tint w,h;\n\t\tfinal int INF=Integer.MAX_VALUE/4;\n\t\tAOJ1140(){\n\t\t\twhile(true){\n\t\t\t\tw=sc.nextInt();\n\t\t\t\th=sc.nextInt();\n\t\t\t\tif((w|h)==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tvoid solve(){\n\t\t\tint[][] map=new int[w][h];\n\t\t\tint sx=0,sy=0,c=1;\n\t\t\tfor(int y=0; y<h; ++y){\n\t\t\t\tchar[] line=sc.next().toCharArray();\n\t\t\t\tfor(int x=0; x<w; ++x){\n\t\t\t\t\tif(line[x]=='o'){\n\t\t\t\t\t\tsx=x;\n\t\t\t\t\t\tsy=y;\n\t\t\t\t\t}else if(line[x]=='x'){\n\t\t\t\t\t\tmap[x][y]=-1;\n\t\t\t\t\t}else if(line[x]=='*'){\n\t\t\t\t\t\tmap[x][y]=c++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t--c;\t// number of dirty tile\n\t\t\tint b=(1<<c)-1;\n\t\t\tint[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\t\t\t\n\t\t\tint[][][] closed=new int[w][h][b+1];\n\t\t\tfor(int x=0; x<w; ++x)for(int y=0; y<h; ++y)for(int z=0; z<=b; ++z)closed[x][y][z]=(x==sx&&y==sy?0:INF);\n\t\t\t\n\t\t\tLinkedList<state> open=new LinkedList<state>();\n\t\t\topen.add(new state(sx,sy,b,0));\n\t\t\t\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tstate now=open.poll();\n\t\t\t\tif(now.t==0){\n\t\t\t\t\tans=now.z;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int v=0; v<4; ++v){\n\t\t\t\t\tint xx=now.x+vx[v], yy=now.y+vy[v];\n\t\t\t\t\tif(!(0<=xx && xx<w && 0<=yy && yy<h))\tcontinue;\n\t\t\t\t\tif(map[xx][yy]<0)\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tint nt=now.t;\n\t\t\t\t\tif(map[xx][yy]>0)\tnt = now.t^(1<<(map[xx][yy]-1));\n\t\t\t\t\t\n\t\t\t\t\tif(closed[xx][yy][nt]<=now.z+1)\tcontinue;\n\t\t\t\t\tclosed[xx][yy][nt]=now.z+1;\n\t\t\t\t\topen.add(new state(xx,yy,nt,now.z+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans>=INF? -1 : ans );\n\t\t}\n\t\tclass state{\n\t\t\tint x,y,t,z;\n\t\t\tstate(int x,int y,int t,int z){\n\t\t\t\tthis.x=x;\n\t\t\t\tthis.y=y;\n\t\t\t\tthis.t=t;\n\t\t\t\tthis.z=z;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ1138{\n\t\tint n,m,p,a,b;\n\t\tfinal int INF=Integer.MAX_VALUE/4;\n\t\tAOJ1138(){\n\t\t\twhile(true){\n\t\t\t\tn=sc.nextInt();\n\t\t\t\tm=sc.nextInt();\n\t\t\t\tp=sc.nextInt();\n\t\t\t\ta=sc.nextInt();\n\t\t\t\tb=sc.nextInt();\n\t\t\t\tif(n==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tvoid solve(){\n\t\t\tint[] tickets=new int[n];\n\t\t\tfor(int i=0; i<n; ++i)\ttickets[i]=sc.nextInt();\n\t\t\tint[][] path=new int[m][m];\n\t\t\tfor(int i=0; i<m; ++i)for(int j=0; j<m; ++j)path[i][j]=INF;\n\t\t\tfor(int i=0; i<p; ++i){\n\t\t\t\tint x=sc.nextInt(),y=sc.nextInt(),z=sc.nextInt();\n\t\t\t\t--x;\n\t\t\t\t--y;\n\t\t\t\tpath[x][y]=z;\n\t\t\t\tpath[y][x]=z;\n\t\t\t}\n\t\t\t\n\t\t\t--a;\n\t\t\t--b;\n\t\t\t\n\t\t\tint bit=(1<<n)-1;\n//\t\t\tSystem.out.println(Integer.bitCount(bit));\n\t\t\tdouble[][] closed=new double[m][bit+1];\n\t\t\tfor(int i=0; i<m; ++i)for(int j=0; j<=bit; ++j)closed[i][j]=(i==a? 0 : INF);\n\t\t\t\n\t\t\tPriorityQueue<state> open = new PriorityQueue<state>();\n\t\t\topen.add(new state(a,bit,0));\n\t\t\t\n\t\t\tdouble ans=INF;\n\t\t\t\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tstate now = open.poll();\n//\t\t\t\tSystem.out.println(now);\n\t\t\t\tif(now.p==b){\n\t\t\t\t\tans=min(ans,now.z);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int to=0; to<m; to++){\n\t\t\t\t\tif(path[now.p][to]>=INF)\tcontinue;\n\t\t\t\t\tif(now.p==to)\tcontinue;\n\t\t\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\t\t\tif( (now.t & (1<<i) ) == 0 )\tcontinue;\n\t\t\t\t\t\tdouble a = (double)path[now.p][to]/(double)tickets[i];\n\t\t\t\t\t\tint b = now.t^(1<<i);\n\t\t\t\t\t\tif(closed[to][b] <= now.z+a)\tcontinue;\n\t\t\t\t\t\tclosed[to][b] = now.z+a;\n\t\t\t\t\t\topen.add(new state(to,b,now.z+a));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(ans>=INF ? \"Impossible\" : ans);\n\t\t}\n\t\tclass state implements Comparable<state>{\n\t\t\tint p,t;\n\t\t\tdouble z;\n\t\t\tstate(int p,int t,double z){\n\t\t\t\tthis.p=p;\n\t\t\t\tthis.t=t;\n\t\t\t\tthis.z=z;\n\t\t\t}\n\t\t\t@Override public int compareTo(state o){\n\t\t\t\treturn (int)(this.z-o.z);\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn \"p:\"+p+\" t:\"+Integer.toBinaryString(t)+\" z:\"+z;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ1135{\n\t\tAOJ1135(){\n\t\t\tint n=sc.nextInt();\n\t\t\twhile(--n>=0)\tsolve();\n\t\t}\n\t\tvoid solve(){\n\t\t\tint m=sc.nextInt(),y=sc.nextInt(),n=sc.nextInt(),ans=0;\n\t\t\twhile(--n>=0){\n\t\t\t\tint a=sc.nextInt();\n\t\t\t\tdouble rate = sc.nextDouble();\n\t\t\t\tint b=sc.nextInt();\n\t\t\t\tif(a==0){\n\t\t\t\t\tint mm=m,c=0;\n\t\t\t\t\tfor(int i=0; i<y; ++i){\n\t\t\t\t\t\tc += (double)mm*rate;\n\t\t\t\t\t\tmm-=b;\n\t\t\t\t\t}\n\t\t\t\t\tans=max(ans, mm+c);\n\t\t\t\t}else{\n\t\t\t\t\tint mm=m;\n\t\t\t\t\tfor(int i=0; i<y; ++i){\n\t\t\t\t\t\tmm+=(double)mm*rate;\n\t\t\t\t\t\tmm-=b;\n\t\t\t\t\t}\n\t\t\t\t\tans=max(ans, mm);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\t\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Point {\n    int x, y;\n\n    Point(int j, int i) {\n      x = j;\n      y = i;\n    }\n  }\n\n  int[][] ofs = {\n      {0, 1},\n      {1, 0},\n      {-1, 0},\n      {0, -1}\n  };\n\n  void run() {\n    for (; ; ) {\n      int w, h;\n      w = ni();\n      h = ni();\n      if (w == 0) {\n        break;\n      }\n      char[][] field = new char[h][w];\n      for (int i = 0; i < h; ++i) {\n        String str = sc.next();\n        for (int j = 0; j < w; ++j) {\n          field[i][j] = str.charAt(j);\n        }\n      }\n      int sx = -1, sy = -1;\n      List<Point> yogore = new LinkedList<>();\n      int[][] gomIndex = new int[h][w];\n      int index = 1;\n      for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n          if (field[i][j] == 'o') {\n            sx = j;\n            sy = i;\n          } else if (field[i][j] == '*') {\n            Point p = new Point(j, i);\n            yogore.add(p);\n            gomIndex[i][j] = index++;\n          }\n        }\n      }\n      Point atom = new Point(sx, sy);\n      yogore.add(0, atom);\n      gomIndex[atom.y][atom.x] = 0;\n      int n = yogore.size();\n      int[][] dist = new int[n][n];\n      for (Point p : yogore) {\n        Queue<Point> queue = new LinkedList<>();\n        int[][] cost = new int[h][w];\n        for (int[] a : cost) Arrays.fill(a, INF);\n        queue.add(p);\n        cost[p.y][p.x] = 0;\n        while (queue.size() > 0) {\n          Point point = queue.poll();\n          for (int[] d : ofs) {\n            int nx = point.x + d[0];\n            int ny = point.y + d[1];\n            if (nx < 0 || w <= nx || ny < 0 || h <= ny) {\n              continue;\n            }\n            if (field[ny][nx] == 'x') {\n              continue;\n            }\n            if (cost[ny][nx] <= cost[point.y][point.x] + 1) {\n              continue;\n            }\n            cost[ny][nx] = cost[point.y][point.x] + 1;\n            queue.add(new Point(nx, ny));\n          }\n        }\n        for (Point q : yogore) {\n          int i = gomIndex[p.y][p.x];\n          int j = gomIndex[q.y][q.x];\n          dist[i][j] = cost[q.y][q.x];\n        }\n      }\n      int[][] dp = new int[1 << n][n];\n      for (int[] a : dp) Arrays.fill(a, INF);\n      dp[1][0] = 0;\n      for (int i = 0; i < 1 << n; ++i) {\n        for (int j = 0; j < n; ++j) {\n          if (dp[i][j] == INF) {\n            continue;\n          }\n          for (int k = 0; k < n; ++k) {\n            if (((i >> k) & 1) == 1) {\n              continue;\n            }\n            dp[i | 1 << k][k] = Math.min(dp[i | 1 << k][k], dp[i][j] + dist[j][k]);\n          }\n        }\n      }\n      int min = INF;\n      for (int i = 0; i < n; ++i) {\n        min = Math.min(min, dp[(1 << n) - 1][i]);\n      }\n      if (min == INF) {\n        System.out.println(-1);\n      } else {\n        System.out.println(min);\n      }\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\n\nclass Main {\n\tstatic int[] vy = {1,0,-1,0};\n\tstatic int[] vx = {0,1,0,-1};\n\tstatic long mod = 1000000007;\n\tstatic int[] px;\n\tstatic int[] py;\n\tstatic char[][] map;\n\tstatic int w;\n\tstatic int h;\n\tstatic int[][] dp;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\t//Scanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\tmap = new char[h][];\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tint pi = 0;\n\t\t\tint sx = 0;\n\t\t\tint sy = 0;\n\t\t\tpx = new int[11];\n\t\t\tpy = new int[11];\n\t\t\t\n\t\t\tIN:for(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(map[i][j] == 'o') {\n\t\t\t\t\t\tpx[pi] = j;\n\t\t\t\t\t\tpy[pi++] = i;\n\t\t\t\t\t\tbreak IN;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(map[i][j] == '*') {\n\t\t\t\t\t\tpx[pi] = j;\n\t\t\t\t\t\tpy[pi++] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = new int[pi][pi];\n\t\t\tfor(int i = 0; i < pi; i++) {\n\t\t\t\tArrays.fill(dp[i], -1);\n\t\t\t}\n\t\t\tboolean check = true;\n\t\t\tfor(int i = 0; i < pi; i++) {\n\t\t\t\tcheck &= cal(i,pi);\n\t\t\t}\n\t\t\tint ret = 0;\n\t\t\tif(!check) ret = -1;\n\t\t\telse ret = dfs(0,new boolean[pi],1,0);\n\t\t\tSystem.out.println(ret);\n\t\t}\n\t}\n\tstatic int dfs(int now, boolean[] al, int c, int d) {\n\t\tif(c == al.length) return d;\n\t\tint ret = 2 << 28;\n\t\tfor(int i = 1; i < al.length; i++) {\n\t\t\tif(al[i]) continue;\n\t\t\tal[i] = true;\n\t\t\tret = Math.min(ret, dfs(i,al,c+1,d + dp[now][i]));\n\t\t\tal[i] = false;\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic boolean cal(int id, int pi) {\n\t\tArrayDeque<Data> q = new ArrayDeque<Data>();\n\t\tint[][] cc = new int[h][w];\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tArrays.fill(cc[i], 2 << 27);\n\t\t}\n\t\tq.add(new Data(py[id],px[id],0));\n\t\twhile(!q.isEmpty()) {\n\t\t\tData p = q.poll();\n\t\t\tif(cc[p.y][p.x] <= p.c) continue;\n\t\t\tcc[p.y][p.x] = p.c;\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tint tx = p.x + vx[i];\n\t\t\t\tint ty = p.y + vy[i];\n\t\t\t\tif(tx < 0 || ty < 0 || tx >= w || ty >= h || cc[ty][tx] <= p.c+1 || map[ty][tx] == 'x') continue;\n\t\t\t\tq.add(new Data(ty,tx,p.c+1)); \n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < pi; i++) {\n\t\t\tif(cc[py[i]][px[i]] == 2 << 27) return false;\n\t\t\tdp[id][i] = cc[py[i]][px[i]];\n\t\t}\n\t\treturn true;\n\t\t\n\t}\n\tstatic class Data {\n\t\tint x;\n\t\tint y;\n\t\tint c;\n\t\tData(int a, int b, int c) {\n\t\t\tx = b;\n\t\t\ty = a;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\n\n\t\n\t\n\tstatic class FastScanner {\n\t    private final InputStream in = System.in;\n\t    private final byte[] buffer = new byte[1024];\n\t    private int ptr = 0;\n\t    private int buflen = 0;\n\t    private boolean hasNextByte() {\n\t        if (ptr < buflen) {\n\t            return true;\n\t        }else{\n\t            ptr = 0;\n\t            try {\n\t                buflen = in.read(buffer);\n\t            } catch (IOException e) {\n\t                e.printStackTrace();\n\t            }\n\t            if (buflen <= 0) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\t    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\t    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t    public String next() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        StringBuilder sb = new StringBuilder();\n\t        int b = readByte();\n\t        while(isPrintableChar(b)) {\n\t            sb.appendCodePoint(b);\n\t            b = readByte();\n\t        }\n\t        return sb.toString();\n\t    }\n\t    public long nextLong() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        long n = 0;\n\t        boolean minus = false;\n\t        int b = readByte();\n\t        if (b == '-') {\n\t            minus = true;\n\t            b = readByte();\n\t        }\n\t        if (b < '0' || '9' < b) {\n\t            throw new NumberFormatException();\n\t        }\n\t        while(true){\n\t            if ('0' <= b && b <= '9') {\n\t                n *= 10;\n\t                n += b - '0';\n\t            }else if(b == -1 || !isPrintableChar(b)){\n\t                return minus ? -n : n;\n\t            }else{\n\t                throw new NumberFormatException();\n\t            }\n\t            b = readByte();\n\t        }\n\t    }\n\t    public int nextInt() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        int n = 0;\n\t        boolean minus = false;\n\t        int b = readByte();\n\t        if (b == '-') {\n\t            minus = true;\n\t            b = readByte();\n\t        }\n\t        if (b < '0' || '9' < b) {\n\t            throw new NumberFormatException();\n\t        }\n\t        while(true){\n\t            if ('0' <= b && b <= '9') {\n\t                n *= 10;\n\t                n += b - '0';\n\t            }else if(b == -1 || !isPrintableChar(b)){\n\t                return minus ? -n : n;\n\t            }else{\n\t                throw new NumberFormatException();\n\t            }\n\t            b = readByte();\n\t        }\n\t    }\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = false;\n\tstatic final int[] d = { 0, 1, 0, -1 };\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint w = ir.nextInt();\n\t\t\tint h = ir.nextInt();\n\t\t\tif (h == 0 && w == 0)\n\t\t\t\treturn;\n\t\t\tchar[][] map = ir.nextCharMap(h, w);\n\t\t\tGraph[] g = new Graph[h * w];\n\t\t\tfor (int i = 0; i < h * w; i++)\n\t\t\t\tg[i] = new Graph();\n\t\t\tArrayList<Integer> dir = new ArrayList<Integer>();\n\t\t\tint s = -1;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (map[i][j] == 'x')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (map[i][j] == 'o')\n\t\t\t\t\t\ts = i * w + j;\n\t\t\t\t\tif (map[i][j] == '*')\n\t\t\t\t\t\tdir.add(i * w + j);\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tint nx = i + d[k];\n\t\t\t\t\t\tint ny = j + d[k ^ 1];\n\t\t\t\t\t\tif (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx][ny] != 'x') {\n\t\t\t\t\t\t\tg[i * w + j].add(new int[] { nx * w + ny, 1 });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] dist = new int[dir.size() + 1][];\n\t\t\tint mi = 1 << 29;\n\t\t\tdist[0] = dijkstra(s, g);\n\t\t\tfor (int i = 1; i <= dir.size(); i++)\n\t\t\t\tdist[i] = dijkstra(dir.get(i - 1), g);\n\t\t\tint[] ord = new int[dir.size()];\n\t\t\tfor (int i = 0; i < dir.size(); i++)\n\t\t\t\tord[i] = i;\n\t\t\tdo {\n\t\t\t\tint pre = s, ret = 0;\n\t\t\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\t\t\tif (dist[ord[i] + 1][pre] == 1 << 29) {\n\t\t\t\t\t\tout.println(-1);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tret += dist[ord[i] + 1][pre];\n\t\t\t\t\tpre = dir.get(ord[i]);\n\t\t\t\t}\n\t\t\t\tmi = Math.min(mi, ret);\n\t\t\t} while (next_permutation(ord));\n\t\t\tout.println(mi);\n\t\t}\n\t}\n\n\tpublic static boolean next_permutation(int[] a) {\n\t\tfor (int i = a.length - 2; i >= 0; i--) {\n\t\t\tif (a[i] < a[i + 1]) {\n\t\t\t\tfor (int j = a.length - 1;; j--) {\n\t\t\t\t\tif (a[i] < a[j]) {\n\t\t\t\t\t\tint temp = a[i];\n\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\ta[j] = temp;\n\t\t\t\t\t\tfor (i++, j = a.length - 1; i < j; i++, j--) {\n\t\t\t\t\t\t\ttemp = a[i];\n\t\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\t\ta[j] = temp;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic class Graph extends ArrayList<int[]> {\n\t}\n\n\tprivate static int[] dijkstra(int s, Graph[] g) {\n\t\tint[] d = new int[g.length];\n\t\tPriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\treturn a[1] - b[1];\n\t\t\t}\n\t\t});\n\t\tArrays.fill(d, 1 << 29);\n\t\td[s] = 0;\n\t\tpq.offer(new int[] { s, 0 });\n\t\twhile (!pq.isEmpty()) {\n\t\t\tint[] p = pq.poll();\n\t\t\tint from = p[0];\n\t\t\tfor (int i = 0; i < g[from].size(); i++) {\n\t\t\t\tint[] e = g[from].get(i);\n\t\t\t\tint to = e[0];\n\t\t\t\tif (d[to] > d[from] + e[1]) {\n\t\t\t\t\td[to] = d[from] + e[1];\n\t\t\t\t\tpq.offer(new int[] { to, d[to] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int w,h,startx,starty;\n\tstatic int[][]field;\n\tstatic int[][]kyori;\n\tstatic List<int[]> list;\n\tstatic byte[] v1={1,0,-1,0};\n\tstatic byte[] v2={0,-1,0,1};\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tlabel:while(true){\n\t\t\tw=cin.nextInt();\n\t\t\th=cin.nextInt();\n\t\t\tif(w+h==0)break;\n\t\t\tfield=new int[h+2][w+2];\n\t\t\tlist=new ArrayList<int[]>();\n\t\t\tint cnt=0;\n\t\t\tfor(int i=0;i<=h+1;i++){\n\t\t\t\tArrays.fill(field[i], -1);\n\t\t\t}\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tchar[] s=cin.next().toCharArray();\n\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\tif(s[j-1]=='.'){\n\t\t\t\t\t\tfield[i][j]=-2;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s[j-1]=='x'){\n\t\t\t\t\t\tfield[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s[j-1]=='*'){\n\t\t\t\t\t\tfield[i][j]=++cnt;\n\n\t\t\t\t\t\tlist.add(new int[]{i,j});\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tfield[i][j]=0;\n\t\t\t\t\t\tstartx=i;\n\t\t\t\t\t\tstarty=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tfor(int j=1;j<=w;j++){\n//\t\t\t\t\tSystem.out.print(field[i][j]);\n\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t//0,0がスタート地点\n\t\t\tkyori=new int[cnt+1][cnt+1];\n\t\t\ta(startx,starty,0);\n\t\t\tcnt=1;\n\t\t\tfor(int[] a:list){\n\t\t\t\tSystem.gc();\n\t\t\t\ta(a[0],a[1],cnt++);\n\t\t\t\t\n\t\t\t}\n\t\t\tSystem.gc();\n\t\t\tfor(int i=0;i<kyori[0].length;i++){\n\t\t\t\tfor(int j=0;j<kyori[0].length;j++){\n\t\t\t\t\tif(i==j)continue;\n\t\t\t\t\tif(kyori[i][j]==0){\n\t\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\t\tcontinue label;\n\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println(i+\" \"+j+\" \"+kyori[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum=0;\n\t\t\tans=1<<30;\n\t\t\tbt(0,0);\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tstatic int sum,ans;\n\tstatic void bt(int a,int step){\n//\t\tSystem.out.println(a+\" \"+step+\" \"+sum);\n\t\tif(ans<=sum)return;\n\t\tif(step==kyori[0].length-1){\n\t\t\tans=Math.min(ans,sum);\n\t\t}\n\t\tfor(int i=0;i<kyori[0].length;i++){\n\t\t\tif(a==i)continue;\n\t\t\tif(kyori[a][i]==0)continue;\n\t\t\tint tmp=kyori[a][i];\n\t\t\tkyori[a][i]=kyori[i][a]=0;\n\t\t\tsum+=tmp;\n\t\t\tbt(i,step+1);\n\t\t\tkyori[a][i]=kyori[i][a]=tmp;\n\t\t\tsum-=tmp;\n\t\t}\n\t}\n\tstatic void a(int x,int y,int cnt){\n\t\tint[][] f=new int[h+2][w+2];\n\t\tfor(int i=0;i<h+2;i++){\n\t\t\tfor(int j=0;j<w+2;j++){\n\t\t\t\tf[i][j]=field[i][j];\n\t\t\t}\n\t\t}\n\t\tQueue<byte[]> q=new LinkedList<byte[]>();\n\t\tq.add(new byte[]{(byte)x,(byte)y});\n\t\tint steps=0;\n\t\t\n\t\twhile(!q.isEmpty()){\n\t\t\tint size=q.size();\n\t\t\tfor(int i=0;i<size;i++){\n\t\t\t\tbyte[] aaa=q.poll();\n\t\t\t\tbyte xx=aaa[0];\n\t\t\t\tbyte yy=aaa[1];\n\t\t\t\tif(f[xx][yy]>=0){\n\t\t\t\t\tkyori[cnt][f[xx][yy]]=steps;kyori[f[xx][yy]][cnt]=steps;\n\t\t\t\t}\n\t\t\t\tf[xx][yy]=-1;\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tbyte x1=(byte) ((byte)xx+v1[j]);\n\t\t\t\t\tbyte y1=(byte) ((byte)yy+v2[j]);\n\t\t\t\t\tif(f[x1][y1]==-1)continue;\n\t\t\t\t\tq.add(new byte[]{x1,y1});\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tsteps++;\n\t\t}\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args) {\n\t\twhile(solve());\n\t}\n\t\n\tpublic static int INF = 1 << 29;\n\tpublic static int[] D = {1,0,-1,0};\n\t\n\tpublic static boolean solve() {\n\t\tint w = sc.nextInt();\n\t\tint h = sc.nextInt();\n\t\tif (w == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tchar[][] m = new char[h][];\n\t\tfor(int i=0;i<h;i++) {\n\t\t\tm[i] = sc.next().toCharArray();\n\t\t}\n\t\tint si = -1,sj = -1;\n\t\tint n = 1;\n\t\tint[] oi = new int[11];\n\t\tint[] oj = new int[11];\n\t\tfor(int i=0;i<h;i++) {\n\t\t\tfor(int j=0;j<w;j++) {\n\t\t\t\tif (m[i][j] == 'o') {\n\t\t\t\t\tsi = i;\n\t\t\t\t\tsj = j;\n\t\t\t\t}else if(m[i][j] == '*') {\n\t\t\t\t\toi[n] = i;\n\t\t\t\t\toj[n] = j;\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\toi[0] = si;\n\t\toj[0] = sj;\n\t\tint[][] dist = new int[n][n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint[][] d = new int[h][w];\n\t\t\tfor(int j=0;j<h;j++) {\n\t\t\t\tArrays.fill(d[j], INF);\n\t\t\t}\n\t\t\tQueue<Integer> q = new ArrayDeque<>();\n\t\t\tq.offer(oi[i] * 100 + oj[i]);\n\t\t\td[oi[i]][oj[i]] = 0;\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tint c = q.poll();\n\t\t\t\tint ci = c / 100;\n\t\t\t\tint cj = c % 100;\n\t\t\t\tint cd = d[ci][cj];\n\t\t\t\tfor(int k=0;k<4;k++) {\n\t\t\t\t\tint ni = ci + D[k];\n\t\t\t\t\tint nj = cj + D[k^1];\n\t\t\t\t\tif (ni < 0 || ni >= h || nj < 0 || nj >= w || m[ni][nj] == 'x' || d[ni][nj] <= cd + 1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\td[ni][nj] = cd + 1;\n\t\t\t\t\tq.offer(ni * 100 + nj);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tdist[i][j] = d[oi[j]][oj[j]];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(Arrays.deepToString(dist));\n\t\tint[][] dp = new int[n][1<<n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tArrays.fill(dp[i], INF);\n\t\t}\n\t\tdp[0][1] = 0;\n\t\tfor(int j=0;j<1<<n;j++) {\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tif (dp[i][j] == INF) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<n;k++) {\n\t\t\t\t\tif ((j >> k & 1) == 1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint nj = j | (1 << k);\n\t\t\t\t\tdp[k][nj] = Math.min(dp[k][nj], dp[i][j] + dist[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tans = Math.min(ans, dp[i][(1 << n) - 1]);\n\t\t}\n\t\tSystem.out.println(ans == INF ? -1 : ans);\n\t\treturn true;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint w, h;\n\tboolean map[][];\n\tP s;\n\tLinkedList<P> dusts;\n\tP[] da;\n\tint[][] d;\n\tint size;\n\tint[][] mem;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif( (w|h) == 0 ) break;\n\t\t\tmap = new boolean[h+2][w+2];\n\t\t\tdusts = new LinkedList<P>();\n\t\t\tfor(int i=1;i<=h;i++) {\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor(int j=1;j<=w;j++) {\n\t\t\t\t\tswitch (str.charAt(j-1)) {\n\t\t\t\t\tcase '*' :\n\t\t\t\t\t\tdusts.add(new P(j, i));\n\t\t\t\t\t\tmap[i][j] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'x':\n\t\t\t\t\t\tmap[i][j] = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'o':\n\t\t\t\t\t\ts = new P(j, i);\n\t\t\t\t\t\tmap[i][j] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tmap[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsize = dusts.size();\n//\t\t\tfor(boolean[] a: map) debug(a);\n\t\t\tda = new P[size+1];\n\t\t\tda[0] = s;\n\t\t\tfor(int i=1;i<=size;i++) da[i] = dusts.remove();\n\t\t\td = new int[size+1][size+1];\n\t\t\tboolean flg = true;\n\t\t\t\n\t\t\tfor(int i=0;i<size+1;i++) for(int j=i+1;j<size+1;j++) {\n\t\t\t\td[i][j] = d[j][i] = bfs(da[i], da[j]);\n\t\t\t\tif(d[i][j] == INF ) flg = false;\n\t\t\t}\n//\t\t\tfor(int[] a: d) debug(a);\n\t\t\tif(!flg) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tmem = new int[size+1][1<<(size+1)];\n\t\t\tfor(int[] a: mem) fill(a, -1);\n\t\t\tSystem.out.println( solve( (1<<(size+1)) - 1, 0 ) );\n\t\t}\n\t}\n\t\n\tint solve(int S, int node) {\n\t\tif( mem[node][S] >= 0 ) return mem[node][S];\n\t\tif( S == 0 ) return mem[node][S] = 0;\n\t\tint t = INF;\n\t\tfor(int i=0;i<size+1;i++) {\n\t\t\tif( ((S>>i)&1) == 1 ) {\n\t\t\t\tt = min(t, solve(S-(1<<i), i) + d[node][i] );\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn mem[node][S] = t;\n\t}\n\t\n\tint dx[] = {-1,0,1,0};\n\tint dy[] = {0,-1,0,1};\n\t\n\tint bfs(P s, P t) {\n\t\tboolean[][] tmp = new boolean[h+2][w+2];\n\t\tfor(int i=0;i<h+2;i++) for(int j=0;j<w+2;j++)\n\t\t\ttmp[i][j] = map[i][j];\n\t\tP now = new P(s.x, s.y);\n\t\tLinkedList<P> que = new LinkedList<P>();\n\t\tque.add(now);\n\t\ttmp[now.y][now.x] = false;\n\t\tfor( ;!que.isEmpty(); ) {\n//\t\t\tdebug(now.x, now.y);\n\t\t\tnow = que.removeFirst();\n\t\t\tif( now.x == t.x && now.y == t.y ) return now.cnt;\n//\t\t\ttmp[now.y][now.x] = false;\n\t\t\tfor(int i=0;i<4;i++) {\n\t\t\t\tif( tmp[now.y+dy[i]][now.x+dx[i]] ) {\n\t\t\t\t\tque.addLast(new P(now.x + dx[i], now.y + dy[i], now.cnt + 1));\n\t\t\t\t\ttmp[now.y+dy[i]][now.x+dx[i]] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INF;\n\t}\n\t\n\tclass P {\n\t\tint x, y, cnt;\n\t\tP(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tcnt = 0;\n\t\t}\n\t\tP(int x, int y, int cnt) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.cnt = cnt;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ4\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1,-1,1,1,-1}, vy={-1,0,1,0,-1,-1,1,1};\n\tfinal int INF=1<<24;\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\treturn (min<=x&&x<X)&&(min<=y&&y<Y);}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\t//long s=System.currentTimeMillis();\n\t\tnew Main().AOJ1140();\n\t\t//out.println((System.currentTimeMillis()-s)+\"msec\");\n\t}\n\t\n\tvoid disp(char[][] c){\n\t\tfor(int y=0; y<c[0].length; y++){\n\t\t\tfor(int x=0; x<c.length; x++)\tout.print(c[x][y]);\n\t\t\tout.println();\n\t\t}\n\t}\n\t\n\tvoid AOJ1140(){\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(),H=sc.nextInt(),sx=0,sy=0,k=0;\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tchar[][] c=new char[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tc[x][y]=line.charAt(x);\n\t\t\t\t\tif(c[x][y]=='*')\tk++;\n\t\t\t\t\telse if(c[x][y]=='o'){\n\t\t\t\t\t\tsx=x;\tsy=y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//disp(c);\n\t\t\tPriorityQueue<C1140> open=new PriorityQueue<C1140>();\n\t\t\tint[][][] close=new int[W][H][k+1];\n\t\t\tfor(int i=0; i<W; i++){\n\t\t\t\tfor(int j=0; j<H; j++){\n\t\t\t\t\tfor(int l=0; l<=k; l++)\tclose[i][j][l]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\topen.add(new C1140(sx, sy, 0, k, dcopy(c)));\n\t\t\tclose[sx][sy][k]=0;\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC1140 now=open.poll();\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tboolean flag=false;\n\t\t\t\t\tint xx=now.x+vx[i],yy=now.y+vy[i],r=now.r;\n\t\t\t\t\tif(!Point.ok(xx, yy, W, H))\tcontinue;\n\t\t\t\t\tif(c[xx][yy]=='x')\tcontinue;\n\t\t\t\t\tif(now.c[xx][yy]=='*')\tr--;\n\t\t\t\t\tif(close[xx][yy][r]<=now.s+1)\tcontinue;\n\t\t\t\t\tif(r==0){\n\t\t\t\t\t\t//out.println(\"ANS:\"+now);\n\t\t\t\t\t\tans=min(ans,now.s+1);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(now.c[xx][yy]=='*'){\n\t\t\t\t\t\tnow.c[xx][yy]='.';\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t//out.println(\"DL\"+xx+\",\"+yy);\n\t\t\t\t\t\t//disp(now.c);\n\t\t\t\t\t}\n\t\t\t\t\topen.add(new C1140(xx, yy, now.s+1, r, dcopy(now.c)));\n\t\t\t\t\tclose[xx][yy][r]=now.s+1;\n\t\t\t\t\tif(flag)\tnow.c[xx][yy]='*';\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println((ans>=INF?-1:ans));\n\t\t}\n\t}\n\tclass C1140 implements Comparable<C1140>{\n\t\tint x,y,s,r;\n\t\tchar[][] c;\n\t\tC1140(int x,int y,int s,int r,char[][] c){\tthis.x=x; this.y=y; this.s=s; this.r=r; this.c=c;}\n\t\t@Override public int compareTo(C1140 o) {\n\t\t\tif(this.r<o.r)\treturn -1;\n\t\t\tif(this.r>o.r)\treturn 1;\n\t\t\tif(this.s<o.s)\treturn -1;\n\t\t\tif(this.s>o.s)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t\t@Override public String toString() {\n\t\t\treturn \"(\"+x+\",\"+y+\") S:\"+s+\" R:\"+r;\n\t\t}\n\t}\n\tchar[][] dcopy(char[][] c){\n\t\tchar[][] r=new char[c.length][c[0].length];\n\t\tfor(int i=0; i<c.length; i++){\n\t\t\tfor(int j=0; j<c[0].length; j++)\tr[i][j]=c[i][j];\n\t\t}\n\t\treturn r;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Math.*;\nimport static java.lang.System.*;\n\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Scanner;\n\nclass Main {\n    public static Random rand=new Random();\n    static  final  int INF=1<<29;\n\n\n    class P{\n    \tint x,y;\n    \tP(int _x,int _y){\n    \t\tx=_x;y=_y;\n    \t}\n    }\n\n    int[] dirx=new int[]{1,0,-1,0};\n    int[] diry=new int[]{0,1,0,-1};\n\n    int getDist(int i,int j){\n    \tP _p=new P(dx[i],dy[i]);\n    \tQueue<P> que=new LinkedList<>();\n    \tque.add(_p);\n    \tint d=0;\n    \tboolean[][] passed=new boolean[h][w];\n\t\tpassed[_p.y][_p.x]=true;\n    \twhile(!que.isEmpty()){\n    \t\tQueue<P> tmp=new LinkedList<>();\n    \t   \twhile(!que.isEmpty()){\n        \t\tP p=que.poll();\n        \t\tfor(int k=0;k<4;k++){\n        \t\t\tint nx=p.x+dirx[k],ny=p.y+diry[k];\n        \t\t\tif(0<=nx && nx<w && 0<=ny && ny<h){\n        \t\t\t\tif(map[ny][nx]=='x')continue;\n        \t\t\t\tif(nx==dx[j] && ny==dy[j])return d+1;\n        \t\t\t\tif(!passed[ny][nx]){\n        \t\t\t\t\ttmp.add(new P(nx,ny));\n        \t\t\t\t\tpassed[ny][nx]=true;\n        \t\t\t\t}\n        \t\t\t}\n        \t\t}\n    \t   \t}\n    \t\tque=tmp;\n    \t\td++;\n    \t}\n    \treturn INF;\n    }\n\n    // O(n^3) n≦100\n \tstatic void warshall_floyd(int[][] d){\n \t\tint n=d.length;\n \t    for(int k=0;k<n;k++)\n \t    \tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)\n \t    \t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n \t}\n\n\n\tchar[][] map;\n\tint[] dx,dy;\n\tint h,w;\n    public void run() {\n        Case:while(true){\n        \tw=sc.nextInt();h=sc.nextInt();\n        \tif(h==0 && w==0)return;\n\n        \tmap=new char[h][w];\n        \tfor(int y=0;y<h;y++)\n        \t\tmap[y]=sc.next().toCharArray();\n\n        \tint D=0;\n        \tfor(int y=0;y<h;y++)for(int x=0;x<w;x++)\n        \t\tif(map[y][x]=='*')D++;\n        \tdx=new int[D+1];dy=new int[D+1];\n        \tint ind=0;\n        \tfor(int y=0;y<h;y++)for(int x=0;x<w;x++)if(map[y][x]=='o'){\n    \t\t\tdx[ind]=x;\n    \t\t\tdy[ind]=y;\n    \t\t\tind++;\n        \t}\n        \tfor(int y=0;y<h;y++)for(int x=0;x<w;x++)if(map[y][x]=='*'){\n    \t\t\tdx[ind]=x;\n    \t\t\tdy[ind]=y;\n    \t\t\tind++;\n        \t}\n        \tint[][] ds=new int[D+1][D+1];\n        \tfor(int i=0;i<D+1;i++)Arrays.fill(ds[i],INF);\n        \tfor(int i=0;i<D+1;i++)ds[i][i]=0;\n        \tfor(int i=0;i<D+1;i++)for(int j=0;j<D+1;j++)\n        \t\tif(i!=j)ds[i][j]=getDist(i,j);\n\n        \twarshall_floyd(ds);\n\n        \tint[][] dp=new int[D+1][1<<(D+1)];\n        \tfor(int i=0;i<D+1;i++)\n        \t\tArrays.fill(dp[i],INF);\n        \tdp[0][1]=0;\n        \tfor(int i=1;i<(1<<(D+1));i++){\n        \t\tfor(int pos=1;pos<D+1;pos++){\n        \t\t\tif(((i>>pos) & 1) ==0)continue;\n        \t\t\tint mv=INF;\n        \t\t\tfor(int prev=0;prev<D+1;prev++){\n        \t\t\t\tif(((i>>prev) & 1)==1 && pos!=prev)\n        \t\t\t\t\tif(mv>dp[prev][i-(1<<pos)]+ds[prev][pos])\n        \t\t\t\t\t\tmv=dp[prev][i-(1<<pos)]+ds[prev][pos];\n         \t\t\t}\n        \t\t\tdp[pos][i]=mv;\n        \t\t}\n        \t}\n        \tint mv=INF;\n        \tfor(int i=1;i<D+1;i++)mv=min(mv,dp[i][(1<<(D+1))-1]);\n        \tif(mv<INF)\n        \t\tln(mv);\n        \telse\n        \t\tln(-1);\n        }\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n\tstatic Scanner sc=new Scanner(in);\n\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n\tstatic String str(double o){\n\t\treturn String.format(\"%.8f\",o);\n\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\tClass<?> c=o.getClass();\n\t\tif(c.equals(Boolean.class))return str((boolean)o);\n\t\tif(c.equals(Double.class))return str((double)o);\n\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int W, H;\n\tstatic char[][] map;\n\tstatic int[] DR = { 1, 0, -1, 0 };\n\tstatic int[] DC = { 0, 1, 0, -1 };\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tW = sc.nextInt();\n\t\t\tH = sc.nextInt();\n\t\t\tif (W == 0) break;\n\t\t\tmap = new char[H][];\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tstatic int solve() {\n\t\tArrayList<Point> pos = new ArrayList<>();\n\t\tint sr = 0;\n\t\tint sc = 0;\n\t\tint[][] idx = new int[H][W];\n\t\tfor (int[] a : idx) {\n\t\t\tArrays.fill(a, -1);\n\t\t}\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (map[i][j] == 'o') {\n\t\t\t\t\tsr = i;\n\t\t\t\t\tsc = j;\n\t\t\t\t\tidx[i][j] = 0;\n\t\t\t\t} else if (map[i][j] == '*') {\n\t\t\t\t\tpos.add(new Point(i, j));\n\t\t\t\t\tidx[i][j] = pos.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint c = pos.size() + 1;\n\t\tint[][] dist = new int[c][c];\n\t\tcalc(sr, sc, 0, idx, dist);\n\t\tfor (int i = 0; i < c - 1; ++i) {\n\t\t\tcalc(pos.get(i).x, pos.get(i).y, i + 1, idx, dist);\n\t\t}\n\t\tfor (int i = 0; i < c; ++i) {\n\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\tif (dist[i][j] == 0) return -1;\n\t\t\t}\n\t\t}\n\n\t\tint[][] dp = new int[1 << c][c];\n\t\tfor (int[] a : dp) {\n\t\t\tArrays.fill(a, 1 << 30);\n\t\t}\n\t\tdp[1][0] = 0;\n\t\tfor (int i = 1; i < (1 << c); ++i) {\n\t\t\tfor (int j = 0; j < c; ++j) {\n\t\t\t\tif ((i & (1 << j)) == 0) continue;\n\t\t\t\tfor (int k = 0; k < c; ++k) {\n\t\t\t\t\tif ((i & (1 << k)) != 0) continue;\n\t\t\t\t\tdp[i + (1 << k)][k] = Math.min(dp[i + (1 << k)][k], dp[i][j] + dist[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1 << 30;\n\t\tfor (int i = 1; i < c; ++i) {\n\t\t\tans = Math.min(ans, dp[(1 << c) - 1][i]);\n\t\t}\n\t\treturn ans;\n\t}\n\n\tstatic void calc(int sr, int sc, int si, int[][] idx, int[][] dist) {\n\t\tboolean[][] visited = new boolean[H][W];\n\t\tArrayList<Point> cur = new ArrayList<>();\n\t\tcur.add(new Point(sr, sc));\n\t\tvisited[sr][sc] = true;\n\t\tfor (int i = 1; !cur.isEmpty(); ++i) {\n\t\t\tArrayList<Point> next = new ArrayList<>();\n\t\t\tfor (Point p : cur) {\n\t\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\t\tint nr = p.x + DR[j];\n\t\t\t\t\tint nc = p.y + DC[j];\n\t\t\t\t\tif (nr < 0 || H <= nr || nc < 0 || W <= nc || visited[nr][nc]) continue;\n\t\t\t\t\tif (map[nr][nc] == 'x') continue;\n\t\t\t\t\tvisited[nr][nc] = true;\n\t\t\t\t\tif (idx[nr][nc] >= 0) {\n\t\t\t\t\t\tdist[si][idx[nr][nc]] = dist[idx[nr][nc]][si] = i;\n\t\t\t\t\t}\n\t\t\t\t\tnext.add(new Point(nr, nc));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur = next;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\nimport java.util.Queue;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\n\npublic class Main {\n\tpublic static int[][] bfs(int h, int w, int[][] matrix, int[] start) {\n\t\tArrayDeque<int[]> q = new ArrayDeque<int[]>();\n\t\tint[][] dist = new int[h][w];\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tdist[i][j] = Integer.MAX_VALUE;\n\t\t\t}\n\t\t}\n\t\tdist[start[0]][start[1]] = 0;\n\t\tint[][] d = {{1,0}, {-1,0}, {0,1}, {0,-1}};\n\t\tq.addLast(start);\n\t\twhile(q.size()>0) {\n\t\t\tint[] pos = q.pollFirst();\n\t\t\tfor(int[] delta: d) {\n\t\t\t\tif(pos[0]+delta[0]<0 || pos[1]+delta[1]<0 || h<=pos[0]+delta[0] || w<=pos[1]+delta[1]) continue;\n\t\t\t\tif(matrix[pos[0]+delta[0]][pos[1]+delta[1]] == -1) continue;\n\t\t\t\tif(dist[pos[0]+delta[0]][pos[1]+delta[1]] <= dist[pos[0]][pos[1]]+1) continue;\n\t\t\t\tdist[pos[0]+delta[0]][pos[1]+delta[1]] = dist[pos[0]][pos[1]]+1;\n\t\t\t\tint[] next = {pos[0]+delta[0], pos[1]+delta[1]};\n\t\t\t\tq.addLast(next);\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tFS r = new FS();\n\t\twhile(true) {\n\t\t\tint w = r.nextInt();\n\t\t\tint h = r.nextInt();\n\t\t\tint dirt = 0;\n\t\t\tint[][] pos = new int[10][2];\n\t\t\tif(w==0) break;\n\t\t\tint[][] matrix = new int[h][w];\n\t\t\tfor(int i=0; i<h; i++) {\n\t\t\t\tString s = r.next();\n\t\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\t\tswitch(s.charAt(j)) {\n\t\t\t\t\t\tcase 'o':\n\t\t\t\t\t\t\tpos[0][0] = i;\n\t\t\t\t\t\t\tpos[0][1] = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\tdirt++;\n\t\t\t\t\t\t\tpos[dirt][0] = i;\n\t\t\t\t\t\t\tpos[dirt][1] = j;\n\t\t\t\t\t\t\tmatrix[i][j] = dirt;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'x':\n\t\t\t\t\t\t\tmatrix[i][j] = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] distMatrix = new int[dirt+1][dirt+1];\n\t\t\tfor(int i=0; i<=dirt; i++) {\n\t\t\t\tint[][] dist = bfs(h, w, matrix, pos[i]);\n\t\t\t\tfor(int j=0; j<=dirt; j++) {\n\t\t\t\t\tdistMatrix[i][j] = dist[pos[j][0]][pos[j][1]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] bitDP = new int[(int)Math.pow(2, dirt)];\n\t\t\tfor(int i=0; i<bitDP.length; i++) {\n\t\t\t\tbitDP[i] = Integer.MAX_VALUE;\n\t\t\t}\n\t\t\tbitDP[0] = 0;\n\t\t\tfor(int i=0; i<dirt; i++) {\n\t\t\t\tbitDP[(int)Math.pow(2, i)] = distMatrix[0][i+1];\n\t\t\t}\n\t\t\tfor(int i=0; i<bitDP.length; i++) {\n\t\t\t\tfor(int j=0; j<dirt; j++) {\n\t\t\t\t\tif((i & (int)Math.pow(2, j)) > 0) {\n\t\t\t\t\t\tfor(int k=0; k<dirt; k++) {\n\t\t\t\t\t\t\tif((i & (int)Math.pow(2, k)) > 0 && j != k) {\n\t\t\t\t\t\t\t\tbitDP[i] = Math.min(bitDP[i], bitDP[i-(int)Math.pow(2, j)]+distMatrix[k+1][j+1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(bitDP[bitDP.length-1] == Integer.MAX_VALUE) bitDP[bitDP.length-1] = -1;\n\n\t\t\tSystem.out.println(bitDP[bitDP.length-1]);\n\t\t}\n\t}\n\t\n\tpublic static void solver() {\n\t\t// write logic\n\t}\n\t\n\t// Read Class\n\tstatic class FS {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\n\t\tprivate int readByte() { return hasNextByte() ? buffer[ptr++] : -1;}\n\t\tprivate boolean isPrintableChar(int c) {return 33 <= c && c <= 126;}\n\t\tprivate void skipUnprintable() {while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t\n\t\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile(isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if(b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Math.*;\nimport static java.lang.System.*;\n\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Scanner;\n\nclass Main {\n    public static Random rand=new Random();\n    static  final  int INF=1<<29;\n\n\n    class P{\n    \tint x,y;\n    \tP(int _x,int _y){\n    \t\tx=_x;y=_y;\n    \t}\n    }\n\n    int[] dirx=new int[]{1,0,-1,0};\n    int[] diry=new int[]{0,1,0,-1};\n\n    int getDist(int i,int j){\n    \tP _p=new P(dx[i],dy[i]);\n    \tQueue<P> que=new LinkedList<P>();\n    \tque.add(_p);\n    \tint d=0;\n    \tboolean[][] passed=new boolean[h][w];\n\t\tpassed[_p.y][_p.x]=true;\n    \twhile(!que.isEmpty()){\n    \t\tQueue<P> tmp=new LinkedList<P>();\n    \t   \twhile(!que.isEmpty()){\n        \t\tP p=que.poll();\n        \t\tfor(int k=0;k<4;k++){\n        \t\t\tint nx=p.x+dirx[k],ny=p.y+diry[k];\n        \t\t\tif(0<=nx && nx<w && 0<=ny && ny<h){\n        \t\t\t\tif(map[ny][nx]=='x')continue;\n        \t\t\t\tif(nx==dx[j] && ny==dy[j])return d+1;\n        \t\t\t\tif(!passed[ny][nx]){\n        \t\t\t\t\ttmp.add(new P(nx,ny));\n        \t\t\t\t\tpassed[ny][nx]=true;\n        \t\t\t\t}\n        \t\t\t}\n        \t\t}\n    \t   \t}\n    \t\tque=tmp;\n    \t\td++;\n    \t}\n    \treturn INF;\n    }\n\n    // O(n^3) n≦100\n \tstatic void warshall_floyd(int[][] d){\n \t\tint n=d.length;\n \t    for(int k=0;k<n;k++)\n \t    \tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)\n \t    \t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n \t}\n\n\n\tchar[][] map;\n\tint[] dx,dy;\n\tint h,w;\n    public void run() {\n        Case:while(true){\n        \tw=sc.nextInt();h=sc.nextInt();\n        \tif(h==0 && w==0)return;\n\n        \tmap=new char[h][w];\n        \tfor(int y=0;y<h;y++)\n        \t\tmap[y]=sc.next().toCharArray();\n\n        \tint D=0;\n        \tfor(int y=0;y<h;y++)for(int x=0;x<w;x++)\n        \t\tif(map[y][x]=='*')D++;\n        \tdx=new int[D+1];dy=new int[D+1];\n        \tint ind=0;\n        \tfor(int y=0;y<h;y++)for(int x=0;x<w;x++)if(map[y][x]=='o'){\n    \t\t\tdx[ind]=x;\n    \t\t\tdy[ind]=y;\n    \t\t\tind++;\n        \t}\n        \tfor(int y=0;y<h;y++)for(int x=0;x<w;x++)if(map[y][x]=='*'){\n    \t\t\tdx[ind]=x;\n    \t\t\tdy[ind]=y;\n    \t\t\tind++;\n        \t}\n        \tint[][] ds=new int[D+1][D+1];\n        \tfor(int i=0;i<D+1;i++)Arrays.fill(ds[i],INF);\n        \tfor(int i=0;i<D+1;i++)ds[i][i]=0;\n        \tfor(int i=0;i<D+1;i++)for(int j=0;j<D+1;j++)\n        \t\tif(i!=j)ds[i][j]=getDist(i,j);\n\n        \twarshall_floyd(ds);\n\n        \tint[][] dp=new int[D+1][1<<(D+1)];\n        \tfor(int i=0;i<D+1;i++)\n        \t\tArrays.fill(dp[i],INF);\n        \tdp[0][1]=0;\n        \tfor(int i=1;i<(1<<(D+1));i++){\n        \t\tfor(int pos=1;pos<D+1;pos++){\n        \t\t\tif(((i>>pos) & 1) ==0)continue;\n        \t\t\tint mv=INF;\n        \t\t\tfor(int prev=0;prev<D+1;prev++){\n        \t\t\t\tif(((i>>prev) & 1)==1 && pos!=prev)\n        \t\t\t\t\tif(mv>dp[prev][i-(1<<pos)]+ds[prev][pos])\n        \t\t\t\t\t\tmv=dp[prev][i-(1<<pos)]+ds[prev][pos];\n         \t\t\t}\n        \t\t\tdp[pos][i]=mv;\n        \t\t}\n        \t}\n        \tint mv=INF;\n        \tfor(int i=1;i<D+1;i++)mv=min(mv,dp[i][(1<<(D+1))-1]);\n        \tif(mv<INF)\n        \t\tln(mv);\n        \telse\n        \t\tln(-1);\n        }\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n\tstatic Scanner sc=new Scanner(in);\n\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(Boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n//\tstatic String str(Double o){\n//\t\treturn String.format(\"%.8f\",o);\n//\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\tClass<?> c=o.getClass();\n\t\tif(c.equals(Boolean.class))return str((Boolean)o);\n\t\t//if(c.equals(Double.class))return str((Double)o);\n\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\tint n, w, h;\n\tchar[][] f;\n\tint sx, sy;\n\tint[] gx, gy;\n\tint[][] g;\n\n\tclass D implements Comparable<D>{\n\t\tint pos;\n\t\tint min;\n\t\tint bit;\n\n\t\tD(int pos, int min, int bit) {\n\t\t\tthis.pos = pos;\n\t\t\tthis.min = min;\n\t\t\tthis.bit = bit;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(D o) {\n\t\t\tif (this.min != o.min)\n\t\t\t\treturn this.min - o.min;\n\t\t\tif (this.pos != o.pos)\n\t\t\t\treturn this.pos - o.pos;\n\t\t\treturn this.bit - o.bit;\n\t\t}\n\t}\n\n\tint dist(int sx, int sy, int gx, int gy) {\n\t\tint[][] visit = new int[h][w];\n\t\tint[] dx = {-1, 0, 0, 1};\n\t\tint[] dy = {0, -1, 1, 0};\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tArrays.fill(visit[i], -1);\n\t\t}\n\t\tvisit[sy][sx] = 0;\n\n\t\tQueue<Integer> queueX = new LinkedList<Integer>();\n\t\tQueue<Integer> queueY = new LinkedList<Integer>();\n\t\tqueueX.add(sx);\n\t\tqueueY.add(sy);\n\t\twhile (!queueX.isEmpty()) {\n\t\t\tint x = queueX.poll();\n\t\t\tint y = queueY.poll();\n\t\t\tif (x == gx && y == gy) {\n\t\t\t\treturn visit[y][x];\n\t\t\t}\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nx = x + dx[i];\n\t\t\t\tint ny = y + dy[i];\n\t\t\t\tif (nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n\t\t\t\tif (f[ny][nx] == 'x') continue;\n\t\t\t\tif (visit[ny][nx] != -1) continue;\n\n\t\t\t\tqueueX.add(nx);\n\t\t\t\tqueueY.add(ny);\n\t\t\t\tvisit[ny][nx] = visit[y][x] + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tint dijkstra(int sx, int sy) {\n\t\tPriorityQueue<D> queue = new PriorityQueue<D>();\n\t\tint mask = (1 << n) - 1;\n\t\tqueue.add(new D(0, 0, 0));\n\n\t\twhile (!queue.isEmpty()) {\n\t\t\tD d = queue.poll();\n\t\t\tint pos = d.pos;\n\t\t\tint min = d.min;\n\t\t\tint bit = d.bit;\n\t\t\tif (bit == mask) {\n\t\t\t\treturn min;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (0 < (bit & (1 << i))) continue;\n\t\t\t\tint npos = i + 1;\n\t\t\t\tif (g[pos][npos] < 0) continue;\n\t\t\t\tint nmin = min + g[pos][npos];\n\t\t\t\tint nbit = bit | (1 << i);\n\t\t\t\tqueue.add(new D(npos, nmin, nbit));\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif ((w | h) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn = 0;\n\t\t\tf = new char[h][];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tf[i] = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (f[i][j] == '*') n++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgx = new int[n];\n\t\t\tgy = new int[n];\n\t\t\tint id = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (f[i][j] == '*') {\n\t\t\t\t\t\tgx[id] = j;\n\t\t\t\t\t\tgy[id] = i;\n\t\t\t\t\t\tid++;\n\t\t\t\t\t} else if (f[i][j] == 'o') {\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tg = new int[n + 1][n + 1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint dist = dist(sx, sy, gx[i], gy[i]);\n\t\t\t\tg[0][i + 1] = g[i + 1][0] = dist;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tint dist = dist(gx[i], gy[i], gx[j], gy[j]);\n\t\t\t\t\tg[i + 1][j + 1] = g[j + 1][i + 1] = dist;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(dijkstra(sx, sy));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = false;\n\tstatic final int[] d = { 0, 1, 0, -1 };\n\n\tstatic void solve() {\n\t\touter: for (;;) {\n\t\t\tint w = ir.nextInt();\n\t\t\tint h = ir.nextInt();\n\t\t\tif (h == 0 && w == 0)\n\t\t\t\treturn;\n\t\t\tchar[][] map = ir.nextCharMap(h, w);\n\t\t\tGraph[] g = new Graph[h * w];\n\t\t\tfor (int i = 0; i < h * w; i++)\n\t\t\t\tg[i] = new Graph();\n\t\t\tArrayList<Integer> dir = new ArrayList<Integer>();\n\t\t\tint s = -1;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (map[i][j] == 'x')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (map[i][j] == 'o')\n\t\t\t\t\t\ts = i * w + j;\n\t\t\t\t\tif (map[i][j] == '*')\n\t\t\t\t\t\tdir.add(i * w + j);\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tint nx = i + d[k];\n\t\t\t\t\t\tint ny = j + d[k ^ 1];\n\t\t\t\t\t\tif (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx][ny] != 'x') {\n\t\t\t\t\t\t\tg[i * w + j].add(new int[] { nx * w + ny, 1 });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] dist = new int[dir.size() + 1][];\n\t\t\tint mi = 1 << 29;\n\t\t\tdist[0] = dijkstra(s, g);\n\t\t\tfor (int i = 1; i <= dir.size(); i++)\n\t\t\t\tdist[i] = dijkstra(dir.get(i - 1), g);\n\t\t\tint[] ord = new int[dir.size()];\n\t\t\tfor (int i = 0; i < dir.size(); i++)\n\t\t\t\tord[i] = i;\n\t\t\tdo {\n\t\t\t\tint pre = s, ret = 0;\n\t\t\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\t\t\tif (dist[ord[i] + 1][pre] == 1 << 29) {\n\t\t\t\t\t\tout.println(-1);\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t\tret += dist[ord[i] + 1][pre];\n\t\t\t\t\tpre = dir.get(ord[i]);\n\t\t\t\t}\n\t\t\t\tmi = Math.min(mi, ret);\n\t\t\t} while (next_permutation(ord));\n\t\t\tout.println(mi);\n\t\t}\n\t}\n\n\tpublic static boolean next_permutation(int[] a) {\n\t\tfor (int i = a.length - 2; i >= 0; i--) {\n\t\t\tif (a[i] < a[i + 1]) {\n\t\t\t\tfor (int j = a.length - 1;; j--) {\n\t\t\t\t\tif (a[i] < a[j]) {\n\t\t\t\t\t\tint temp = a[i];\n\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\ta[j] = temp;\n\t\t\t\t\t\tfor (i++, j = a.length - 1; i < j; i++, j--) {\n\t\t\t\t\t\t\ttemp = a[i];\n\t\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\t\ta[j] = temp;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic class Graph extends ArrayList<int[]> {\n\t}\n\n\tprivate static int[] dijkstra(int s, Graph[] g) {\n\t\tint[] d = new int[g.length];\n\t\tPriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\treturn a[1] - b[1];\n\t\t\t}\n\t\t});\n\t\tArrays.fill(d, 1 << 29);\n\t\td[s] = 0;\n\t\tpq.offer(new int[] { s, 0 });\n\t\twhile (!pq.isEmpty()) {\n\t\t\tint[] p = pq.poll();\n\t\t\tint from = p[0];\n\t\t\tfor (int i = 0; i < g[from].size(); i++) {\n\t\t\t\tint[] e = g[from].get(i);\n\t\t\t\tint to = e[0];\n\t\t\t\tif (d[to] > d[from] + e[1]) {\n\t\t\t\t\td[to] = d[from] + e[1];\n\t\t\t\t\tpq.offer(new int[] { to, d[to] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tclass E {\n\t\tint from;\n\t\tint to;\n\t\tint cost;\n\n\t\tE(int from, int to, int cost) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\n\tclass V {\n\t\tint x;\n\t\tint y;\n\n\t\tV(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tint wh(int w, int i, int j) {\n\t\treturn (i * w + j);\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tsc.nextLine();\n\t\t\tif ((w | h) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchar map[][] = new char[h][w];\n\t\t\tLinkedList<V> node = new LinkedList<V>();\n\t\t\tint dp[][] = new int[w * h][w * h];\n\t\t\tfor (int i = 0; i < w * h; i++) {\n\t\t\t\tArrays.fill(dp[i], Integer.MAX_VALUE / 4);\n\t\t\t}\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString buffer = sc.nextLine();\n\t\t\t\tmap[i] = buffer.toCharArray();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (map[i][j] == '*') {\n\t\t\t\t\t\tnode.addLast(new V(j, i));\n\t\t\t\t\t}\n\t\t\t\t\tif (map[i][j] == 'o') {\n\t\t\t\t\t\tnode.addFirst(new V(j, i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w;j++){\n\t\t\t\t\tif (map[i][j] != 'x') {\n\t\t\t\t\t\tif (w > j + 1) {\n\t\t\t\t\t\t\tif (map[i][j + 1] != 'x') {\n\t\t\t\t\t\t\t\tdp[wh(w, i, j)][wh(w, i, j + 1)] = 1;\n\t\t\t\t\t\t\t\tdp[wh(w, i, j + 1)][wh(w, i, j)] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (h > i + 1) {\n\t\t\t\t\t\t\tif (map[i + 1][j] != 'x') {\n\t\t\t\t\t\t\t\tdp[wh(w, i, j)][wh(w, i + 1, j)] = 1;\n\t\t\t\t\t\t\t\tdp[wh(w, i + 1, j)][wh(w, i, j)] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (0 < j) {\n\t\t\t\t\t\t\tif (map[i][j - 1] != 'x') {\n\t\t\t\t\t\t\t\tdp[wh(w, i, j)][wh(w, i, j - 1)] = 1;\n\t\t\t\t\t\t\t\tdp[wh(w, i, j - 1)][wh(w, i, j)] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (0 < i) {\n\t\t\t\t\t\t\tif (map[i-1][j] != 'x') {\n\t\t\t\t\t\t\t\tdp[wh(w, i, j)][wh(w, i - 1, j)] = 1;\n\t\t\t\t\t\t\t\tdp[wh(w, i - 1, j)][wh(w, i, j)] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tint wh = w * h;\n\t\t\tfor (int i = 0; i < wh; i++) {\n\t\t\t\tfor (int j = 0; j < wh; j++) {\n\t\t\t\t\tfor (int k = 0; k < wh; k++) {\n\t\t\t\t\t\tdp[i][k] = Math.min(dp[i][j] + dp[j][k], dp[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tLinkedList<E> hen = new LinkedList<E>();\n\t\t\tboolean mmm = false;\n\t\t\tfor (int i = 0; i < node.size(); i++) {\n\t\t\t\tV temp = node.get(i);\n\t\t\t\tfor (int j = 0; j < node.size(); j++) {\n\t\t\t\t\tV temp2 = node.get(j);\n\t\t\t\t\tint cost = dp[wh(w, temp.y, temp.x)][wh(w, temp2.y, temp2.x)];\n\t\t\t\t\then.add(new E(i, j, cost));\n\t\t\t\t\tif (cost > 1e5) {\n\t\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\t\tmmm = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mmm)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (mmm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint[][] dp2 = new int[1 << node.size()][node.size()];\n\t\t\tfor (int i = 0; i < 1 << node.size(); i++) {\n\t\t\t\tArrays.fill(dp2[i], Integer.MAX_VALUE / 4);\n\t\t\t}\n\t\t\tdp2[0][0] = 0;\n\t\t\tdp2[1][0] = 0;\n\t\t\tfor (int i = 0; i < 1 << node.size(); i++) {\n\t\t\t\tfor (int prev = 0; prev < node.size(); prev++) {\n\t\t\t\t\tint sh = 1 << prev;\n\t\t\t\t\tif ((i & sh) != 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint next = (i | sh);\n\t\t\t\t\tE a = hen.getFirst();\n\t\t\t\t\tfor (int l = 0; l < node.size(); l++) {\n\t\t\t\t\t\tfor (E e : hen) {\n\t\t\t\t\t\t\tif (e.from == prev) {\n\t\t\t\t\t\t\t\tif (e.to == l) {\n\t\t\t\t\t\t\t\t\ta = e;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp2[next][prev] = Math.min(dp2[next][prev], dp2[i][l]\n\t\t\t\t\t\t\t\t+ a.cost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res = Integer.MAX_VALUE;\n//\t\t\tSystem.out.println(Arrays.deepToString(dp2));\n\t\t\tfor (int i = 0; i < node.size(); i++) {\n\t\t\t\tres = Math.min(res, dp2[(1 << node.size()) - 1][i]);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.util.function.Consumer;\n\npublic class Main {\n\n    static int H, W;\n    static char[][] C;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        while(true) {\n            W = sc.nextInt();\n            H = sc.nextInt();\n            if( H == 0 ) break;\n\n            C = new char[H][];\n            for (int i = 0; i < H; i++) {\n                C[i] = sc.next().toCharArray();\n            }\n\n            System.out.println(solve());\n        }\n    }\n\n    static int solve() {\n        ArrayDeque<Integer> deq = new ArrayDeque<>();\n        for (int h = 0; h < H; h++) {\n            for (int w = 0; w < W; w++) {\n                if( C[h][w] == '*' ) {\n                    deq.add( h*W + w );\n                } else if( C[h][w] == 'o' ) {\n                    deq.addFirst(h*W + w);\n                }\n            }\n        }\n        List<Integer> cords = new ArrayList<>(deq);\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < cords.size(); i++) {\n            map.put(cords.get(i), i);\n        }\n\n        int[][] dist = new int[cords.size()][cords.size()];\n        int[] q = new int[H*W];\n        int[][] bfsDist = new int[H][W];\n        for (int i = 0; i < cords.size(); i++) {\n            for (int[] row : bfsDist) Arrays.fill(row, Integer.MAX_VALUE);\n            int thw = cords.get(i);\n            int th = thw/W, tw = thw%W;\n            bfsDist[th][tw] = 0;\n\n            int reach = 0;\n            int u = 0, v = 0;\n            q[v++] = th * W + tw;\n            while( u != v ) {\n                int hw = q[u++];\n                int h = hw/W, w = hw%W;\n\n                if( deq.contains(hw) ) {\n                    dist[i][map.get(hw)] = bfsDist[h][w];\n                    reach++;\n                }\n\n                for (int j = 0; j < 4; j++) {\n                    int nh = h + DH[j], nw = w + DW[j];\n\n                    if( inRange(nh, nw) && C[nh][nw] != 'x' && bfsDist[nh][nw] > bfsDist[h][w]+1 ) {\n                        bfsDist[nh][nw] = bfsDist[h][w]+1;\n                        q[v++] = nh*W + nw;\n                    }\n                }\n            }\n\n            if( reach != cords.size() ) return -1;\n        }\n\n        int[] P = new int[cords.size()-1];\n        for (int i = 0; i < cords.size()-1; i++) {\n            P[i] = i+1;\n        }\n        int[] ans = new int[1];\n        ans[0] = Integer.MAX_VALUE;\n        heapPermutation(P, P.length, p -> {\n            int cost = 0;\n            int prev = 0;\n            for (int i = 0; i < P.length; i++) {\n                cost += dist[prev][p[i]];\n                prev = p[i];\n            }\n\n            ans[0] = Math.min(ans[0], cost);\n\n        });\n        return ans[0];\n    }\n\n    static void heapPermutation(int[] arr, int size, Consumer<int[]> c) {\n        if (size == 1) {\n            c.accept(arr);\n        }\n\n        for (int i = 0; i < size; i++) {\n            heapPermutation(arr, size-1, c);\n\n            if (size % 2 == 1) {\n                int temp = arr[0];\n                arr[0] = arr[size-1];\n                arr[size-1] = temp;\n\n            } else {\n                int temp = arr[i];\n                arr[i] = arr[size-1];\n                arr[size-1] = temp;\n            }\n        }\n    }\n\n    static int[] DH = {0, 1, 0, -1};\n    static int[] DW = {1, 0, -1, 0};\n\n    static boolean inRange(int h, int w) {\n        return 0 <= h && h < H && 0 <= w && w < W;\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeSingleLine(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < as.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(as[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg == null) j.add(\"null\");\n            else if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n\n    static void printSingleLine(int[] array) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < array.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(array[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int lowerBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] < value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n\n    static int upperBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] <= value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tstatic Deque<Tilemap> q = new ArrayDeque<Tilemap>();\n\tstatic int[] dx = {1, 0, -1, 0};\n\tstatic int[] dy = {0, 1, 0, -1};\n\n\tpublic static class Tilemap{\n\t\tint x, y;\n\t\tint dirty_tile_num;\n\t\tint count;\n\t\tTilemap(int j, int i, int d, int c){\n\t\t\tx = j;\n\t\t\ty = i;\n\t\t\tdirty_tile_num = d;\n\t\t\tcount = c;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w==0&&h==0) break;\n\t\t\tint[][] tile = new int[h+2][w+2];\n\t\t\tint dirty_tile_num = 0;\n\t\t\tTilemap start = new Tilemap(0, 0, 0, 0);\n\n\t\t\tfor(int i=1; i<=h; i++){\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\t\tif(str.charAt(j-1)=='.'){\n\t\t\t\t\t\ttile[i][j] = 1;\n\t\t\t\t\t}else if(str.charAt(j-1)=='*'){\n\t\t\t\t\t\ttile[i][j] = 2;\n\t\t\t\t\t\tdirty_tile_num++;\n\t\t\t\t\t}else if(str.charAt(j-1)=='o'){\n\t\t\t\t\t\tstart = new Tilemap(j, i, 0, -1);\n\t\t\t\t\t\ttile[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart.dirty_tile_num = dirty_tile_num;\n\t\t\tq.offer(start);\n\n\t\t\tint move = -1;\n\t\t\tint[][] map = new int[h+2][w+2];\n\t\t\tfor(int i=0; i<tile.length; i++){\n\t\t\t\tmap[i] = tile[i].clone();\n\t\t\t}\n\n\t\t\tTilemap xy = new Tilemap(0, 0, 0, 0);\n\t\t\tint x,y;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\txy = q.poll();\n\t\t\t\tx = xy.x; y = xy.y;\n\t\t\t\txy.count++;\n\t\t\t\tif(map[y][x]==2){\n\t\t\t\t\txy.dirty_tile_num--;\n\t\t\t\t\tif(xy.dirty_tile_num==0){\n\t\t\t\t\t\tmove = xy.count;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tq.clear();\n\t\t\t\t\ttile[y][x] = 1;\n\t\t\t\t\tfor(int i=0; i<tile.length; i++){\n\t\t\t\t\t\tmap[i] = tile[i].clone();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tmap[y][x] = 0;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tif(map[y+dy[i]][x+dx[i]]!=0){\n\t\t\t\t\t\tq.offer(new Tilemap(x+dx[i], y+dy[i], xy.dirty_tile_num, xy.count));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(move);\n\t\t\tq.clear();\n\t\t\tSystem.gc();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\nimport javax.xml.ws.WebFault;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tint INF = 100000000;\n\t\n\tint[] vx = {1, 0}, vy = {0, 1};\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint m = in.nextInt(), n = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tchar[][] map = new char[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.next().toCharArray();\n\t\t\t}\n\t\t\t\n\t\t\tint[] node = new int[11];\n\t\t\tint cur = 1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif (map[i][j] == '*') {\n\t\t\t\t\t\tnode[cur] = i * m + j;\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t} else if (map[i][j] == 'o') {\n\t\t\t\t\t\tnode[0] = i * m + j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnode = Arrays.copyOf(node, cur);\n\t\t\t\n\t\t\tint[][] dist = new int[n*m][n*m];\n\t\t\tfor (int i = 0; i < n * m; i++) {\n\t\t\t\tArrays.fill(dist[i], INF);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int y1 = 0; y1 < n; y1++) for (int x1 = 0; x1 < m; x1++) {\n\t\t\t\tif (map[y1][x1] == 'x') continue;\n\t\t\t\tint i = y1 * m + x1;\n\t\t\t\tdist[i][i] = 0;\n\t\t\t\tfor (int d = 0; d < vx.length; d++) {\n\t\t\t\t\tint nx = x1 + vx[d], ny = y1 + vy[d];\n\t\t\t\t\tint j = ny * m + nx;\n\t\t\t\t\tif (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n\t\t\t\t\t\tif (map[ny][nx] == 'x') {\n\t\t\t\t\t\t\tdist[i][j] = dist[j][i] = INF;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdist[i][j] = dist[j][i] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int k = 0; k < n * m; k++) {\n\t\t\t\tfor (int i = 0; i < n * m; i++) {\n\t\t\t\t\tfor (int j = 0; j < n * m; j++) {\n\t\t\t\t\t\tdist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint all = node.length;\n\t\t\tint[][] dp = new int[1<<all][all];\n\t\t\tfor (int i = 0; i < (1 << all); i++) Arrays.fill(dp[i], INF);\n\t\t\tdp[1][0] = 0;\n\t\t\t\n\t\t\tfor (int i = 1; i < (1 << all); i++) {\n\t\t\t\tfor (int from = 0; from < all; from++) {\n\t\t\t\t\tif (((1 << from) & i) == 0 || dp[i][from] == INF) continue;\n\t\t\t\t\tfor (int to = 0; to < all; to++) if (from != to) {\n\t\t\t\t\t\tif (((1 << to) & i) != 0) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tint bit = i | (1 << to);\n\t\t\t\t\t\tdp[bit][to] = Math.min(dp[bit][to], dp[i][from] + dist[node[from]][node[to]]);\n//\t\t\t\t\t\tSystem.out.println(i + \" \" + from + \" \" + dp[i][from] + \" -> \" + bit + \" \" + to + \" \" + dp[bit][to]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint res = INF;\n\t\t\tfor (int i = 1; i < all; i++) {\n\t\t\t\tres = Math.min(res, dp[(1<<all)-1][i]);\n\t\t\t}\n\t\t\tSystem.out.println(res == INF ? -1 : res);\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tclass E {\n\t\tint from;\n\t\tint to;\n\t\tint cost;\n\n\t\tE(int from, int to, int cost) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\n\tclass V {\n\t\tint x;\n\t\tint y;\n\n\t\tV(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tint wh(int w, int i, int j) {\n\t\treturn (i * w + j);\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tsc.nextLine();\n\t\t\tif ((w | h) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchar map[][] = new char[h][w];\n\t\t\tLinkedList<V> node = new LinkedList<V>();\n\t\t\tint dp[][] = new int[w * h][w * h];\n\t\t\tfor (int i = 0; i < w * h; i++) {\n\t\t\t\tArrays.fill(dp[i], Integer.MAX_VALUE / 4);\n\t\t\t}\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString buffer = sc.nextLine();\n\t\t\t\tmap[i] = buffer.toCharArray();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (map[i][j] == '*') {\n\t\t\t\t\t\tnode.addLast(new V(j, i));\n\t\t\t\t\t}\n\t\t\t\t\tif (map[i][j] == 'o') {\n\t\t\t\t\t\tnode.addFirst(new V(j, i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w;j++){\n\t\t\t\t\tif (map[i][j] != 'x') {\n\t\t\t\t\t\tif (w > j + 1) {\n\t\t\t\t\t\t\tif (map[i][j + 1] != 'x') {\n\t\t\t\t\t\t\t\tdp[wh(w, i, j)][wh(w, i, j + 1)] = 1;\n\t\t\t\t\t\t\t\tdp[wh(w, i, j + 1)][wh(w, i, j)] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (h > i + 1) {\n\t\t\t\t\t\t\tif (map[i + 1][j] != 'x') {\n\t\t\t\t\t\t\t\tdp[wh(w, i, j)][wh(w, i + 1, j)] = 1;\n\t\t\t\t\t\t\t\tdp[wh(w, i + 1, j)][wh(w, i, j)] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (0 < j) {\n\t\t\t\t\t\t\tif (map[i][j - 1] != 'x') {\n\t\t\t\t\t\t\t\tdp[wh(w, i, j)][wh(w, i, j - 1)] = 1;\n\t\t\t\t\t\t\t\tdp[wh(w, i, j - 1)][wh(w, i, j)] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (0 < i) {\n\t\t\t\t\t\t\tif (map[i-1][j] != 'x') {\n\t\t\t\t\t\t\t\tdp[wh(w, i, j)][wh(w, i - 1, j)] = 1;\n\t\t\t\t\t\t\t\tdp[wh(w, i - 1, j)][wh(w, i, j)] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tint wh = w * h;\n\t\t\tfor (int i = 0; i < wh; i++) {\n\t\t\t\tfor (int j = 0; j < wh; j++) {\n\t\t\t\t\tfor (int k = 0; k < wh; k++) {\n\t\t\t\t\t\tdp[i][k] = Math.min(dp[i][j] + dp[j][k], dp[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tLinkedList<E> hen = new LinkedList<E>();\n\t\t\tboolean mmm = false;\n\t\t\tfor (int i = 0; i < node.size(); i++) {\n\t\t\t\tV temp = node.get(i);\n\t\t\t\tfor (int j = 0; j < node.size(); j++) {\n\t\t\t\t\tV temp2 = node.get(j);\n\t\t\t\t\tint cost = dp[wh(w, temp.y, temp.x)][wh(w, temp2.y, temp2.x)];\n\t\t\t\t\then.add(new E(i, j, cost));\n\t\t\t\t\tif (cost > 1e5) {\n\t\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\t\tmmm = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mmm)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (mmm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint[][] dp2 = new int[1 << node.size()][node.size()];\n\t\t\tfor (int i = 0; i < 1 << node.size(); i++) {\n\t\t\t\tArrays.fill(dp2[i], Integer.MAX_VALUE / 4);\n\t\t\t}\n\t\t\tdp2[0][0] = 0;\n\t\t\tdp2[1][0] = 0;\n\t\t\tfor (int i = 0; i < 1 << node.size(); i++) {\n\t\t\t\tfor (int prev = 0; prev < node.size(); prev++) {\n\t\t\t\t\tint sh = 1 << prev;\n\t\t\t\t\tif ((i & sh) != 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint next = (i | sh);\n\t\t\t\t\tE a = hen.getFirst();\n\t\t\t\t\tfor (int l = 0; l < node.size(); l++) {\n\t\t\t\t\t\tfor (E e : hen) {\n\t\t\t\t\t\t\tif (e.from == prev) {\n\t\t\t\t\t\t\t\tif (e.to == l) {\n\t\t\t\t\t\t\t\t\ta = e;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp2[next][prev] = Math.min(dp2[next][prev], dp2[i][l]\n\t\t\t\t\t\t\t\t+ a.cost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res = Integer.MAX_VALUE;\n//\t\t\tSystem.out.println(Arrays.deepToString(dp2));\n\t\t\tfor (int i = 0; i < node.size(); i++) {\n\t\t\t\tres = Math.min(res, dp2[(1 << node.size()) - 1][i]);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args) {\n\t\twhile(solve());\n\t}\n\t\n\tpublic static int INF = 1 << 29;\n\tpublic static int[] D = {1,0,-1,0};\n\t\n\tpublic static boolean solve() {\n\t\tint w = sc.nextInt();\n\t\tint h = sc.nextInt();\n\t\tif (w == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tchar[][] m = new char[h][];\n\t\tfor(int i=0;i<h;i++) {\n\t\t\tm[i] = sc.next().toCharArray();\n\t\t}\n\t\tint si = -1,sj = -1;\n\t\tint n = 1;\n\t\tint[] oi = new int[11];\n\t\tint[] oj = new int[11];\n\t\tfor(int i=0;i<h;i++) {\n\t\t\tfor(int j=0;j<w;j++) {\n\t\t\t\tif (m[i][j] == 'o') {\n\t\t\t\t\tsi = i;\n\t\t\t\t\tsj = j;\n\t\t\t\t}else if(m[i][j] == '*') {\n\t\t\t\t\toi[n] = i;\n\t\t\t\t\toj[n] = j;\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\toi[0] = si;\n\t\toj[0] = sj;\n\t\tint[][] dist = new int[n][n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint[][] d = new int[h][w];\n\t\t\tfor(int j=0;j<h;j++) {\n\t\t\t\tArrays.fill(d[j], INF);\n\t\t\t}\n\t\t\tQueue<Integer> q = new ArrayDeque<>();\n\t\t\tq.offer(oi[i] * 100 + oj[i]);\n\t\t\td[oi[i]][oj[i]] = 0;\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tint c = q.poll();\n\t\t\t\tint ci = c / 100;\n\t\t\t\tint cj = c % 100;\n\t\t\t\tint cd = d[ci][cj];\n\t\t\t\tfor(int k=0;k<4;k++) {\n\t\t\t\t\tint ni = ci + D[k];\n\t\t\t\t\tint nj = cj + D[k^1];\n\t\t\t\t\tif (ni < 0 || ni >= h || nj < 0 || nj >= w || m[ni][nj] == 'x' || d[ni][nj] <= cd + 1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\td[ni][nj] = cd + 1;\n\t\t\t\t\tq.offer(ni * 100 + nj);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tdist[i][j] = d[oi[j]][oj[j]];\n\t\t\t}\n\t\t}\n//\t\tSystem.out.println(Arrays.deepToString(dist));\n\t\tint[][] dp = new int[n][1<<n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tArrays.fill(dp[i], INF);\n\t\t}\n\t\tdp[0][1] = 0;\n\t\tfor(int j=0;j<1<<n;j++) {\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tif (dp[i][j] == INF) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<n;k++) {\n\t\t\t\t\tif ((j >> k & 1) == 1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint nj = j | (1 << k);\n\t\t\t\t\tdp[k][nj] = Math.min(dp[k][nj], dp[i][j] + dist[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tans = Math.min(ans, dp[i][(1 << n) - 1]);\n\t\t}\n\t\tSystem.out.println(ans == INF ? -1 : ans);\n\t\treturn true;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n\npublic class Main {\n\tfinal int CLEAN = 0;\n\tfinal int DIRTY = 1;\n\tfinal int OBJECT = 2;\n\tfinal int START = 3;\n\t\n\tint startX, startY;\n\tint h, w;\n\tint[][] map;\n\tint[][] cost;\n\t\n\tint[] dirtyX, dirtyY;\n\tint dirtynum;\n\tint answer;\n\t\n\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\tprivate void readFromStdin() {\n\t\ttry {\n\t\t\tString str = br.readLine();\n\t\t\tStringTokenizer st = new StringTokenizer(str);\n\t\t\tw = Integer.valueOf(st.nextToken());\n\t\t\th = Integer.valueOf(st.nextToken());\n\t\t\tmap = new int[h+2][w+2];\n\t\t\tcost = new int[h+2][w+2];\n\t\t\tdirtynum = 0;\n\t\t\tdirtyX = new int[10]; dirtyY = new int[10];\n\t\t\tanswer = 0;\n\n\t\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\t\tfor (int j = 0; j < map[i].length; j++) {\n\t\t\t\t\tmap[i][j] = OBJECT;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 1; i <= h; i++) {\n\t\t\t\tstr = br.readLine();\n\t\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\t\tchar c = str.charAt(j-1);\n\t\t\t\t\tmap[i][j] = (c == '.') ? CLEAN:\n\t\t\t\t\t\t\t\t(c == '*') ? DIRTY:\n\t\t\t\t\t\t\t\t(c == 'b') ? OBJECT:\n\t\t\t\t\t\t\t\t(c == 'a') ? START: OBJECT;\n\t\t\t\t\tif (c == 'a') {\n\t\t\t\t\t\tstartX = j;\n\t\t\t\t\t\tstartY = i;\n\t\t\t\t\t}\n\t\t\t\t\tif (c == '*') {\n\t\t\t\t\t\tdirtyX[dirtynum] = j;\n\t\t\t\t\t\tdirtyY[dirtynum] = i;\n\t\t\t\t\t\tdirtynum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t\n\t\t}\n\t}\n\t\n\tprivate void dijkstra(int x, int y) {\n\t\tif (map[y][x] == OBJECT) {\n\t\t\tcost[y][x] = -1;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (cost[y][x] + 1 < cost[y+1][x]) {\n\t\t\tcost[y+1][x] = cost[y][x] + 1;\n\t\t\tdijkstra(x, y+1);\n\t\t}\n\t\tif (cost[y][x] + 1 < cost[y-1][x]) {\n\t\t\tcost[y-1][x] = cost[y][x] + 1;\n\t\t\tdijkstra(x, y-1);\n\t\t}\n\t\tif (cost[y][x] + 1 < cost[y][x+1]) {\n\t\t\tcost[y][x+1] = cost[y][x] + 1;\n\t\t\tdijkstra(x+1, y);\n\t\t}\n\t\tif (cost[y][x] + 1 < cost[y][x-1]) {\n\t\t\tcost[y][x-1] = cost[y][x] + 1;\n\t\t\tdijkstra(x-1, y);\n\t\t}\n\t}\n\t\n\tprivate void initCost() {\n\t\tfor (int i = 0; i < cost.length; i++) {\n\t\t\tfor (int j = 0; j < cost[i].length; j++) {\n\t\t\t\tcost[i][j] = Integer.MAX_VALUE;\n\t\t\t}\n\t\t}\n\t\tcost[startY][startX] = 0;\n\t}\n\t\n\tpublic Main() {\n\t\twhile (true) {\n\t\t\treadFromStdin();\n\t\t\tif (w == 0 && h == 0) break;\n\t\t\twhile (isNotAllClean()) {\n\t\t\t\tinitCost();\n\t\t\t\tdijkstra(startX, startY);\n\t\t\t\t//printMap(cost);\n\t\t\t\tif (changeStart()) {\n\t\t\t\t\tanswer = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(answer);\n\t\t}\n\t}\n\t\n\tprivate boolean isNotAllClean() {\n\t\tfor (int i = 0; i < dirtynum; i++) {\n\t\t\tif (dirtyY[i] == -1 && dirtyX[i] == -1) continue;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean changeStart() {\n\t\tint minCost = Integer.MAX_VALUE;\n\t\tint index = -1;\n\t\t\n\t\tmap[startY][startX] = CLEAN;\n\t\tfor (int i = 0; i < dirtynum; i++) {\n\t\t\tif (dirtyY[i] == -1 && dirtyX[i] == -1) continue;\n\t\t\tint tempCost = cost[dirtyY[i]][dirtyX[i]];\n\t\t\tif (minCost > tempCost) {\n\t\t\t\tminCost = tempCost;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\tif (minCost == Integer.MAX_VALUE) return true;\n\t\tanswer += minCost;\n\t\tstartX = dirtyX[index]; startY = dirtyY[index];\n\t\tdirtyX[index] = -1; dirtyY[index] = -1;\n\t\treturn false;\n\t}\n\t\n\tprivate void printMap(int[][] map) {\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tSystem.out.print(map[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tMain robot = new Main();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int w,h,startx,starty;\n\tstatic int[][]field,kyori;\n\tstatic List<int[]> list;\n\tstatic int[] v1={1,0,-1,0};\n\tstatic int[] v2={0,-1,0,1};\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tlabel:while(true){\n\t\t\tw=cin.nextInt();\n\t\t\th=cin.nextInt();\n\t\t\tif(w+h==0)break;\n\t\t\tfield=new int[h+2][w+2];\n\t\t\tlist=new ArrayList<int[]>();\n\t\t\tint cnt=0;\n\t\t\tfor(int i=0;i<=h+1;i++){\n\t\t\t\tArrays.fill(field[i], -1);\n\t\t\t}\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tchar[] s=cin.next().toCharArray();\n\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\tif(s[j-1]=='.'){\n\t\t\t\t\t\tfield[i][j]=-2;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s[j-1]=='x'){\n\t\t\t\t\t\tfield[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s[j-1]=='*'){\n\t\t\t\t\t\tfield[i][j]=++cnt;\n\n\t\t\t\t\t\tlist.add(new int[]{i,j});\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tfield[i][j]=0;\n\t\t\t\t\t\tstartx=i;\n\t\t\t\t\t\tstarty=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tfor(int j=1;j<=w;j++){\n//\t\t\t\t\tSystem.out.print(field[i][j]);\n\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t//0,0がスタート地点\n\t\t\tkyori=new int[cnt+1][cnt+1];\n\t\t\ta(startx,starty,0);\n\t\t\tcnt=1;\n\t\t\tfor(int[] a:list){\n\t\t\t\ta(a[0],a[1],cnt++);\n\t\t\t}\n\t\t\tfor(int i=0;i<kyori[0].length;i++){\n\t\t\t\tfor(int j=0;j<kyori[0].length;j++){\n\t\t\t\t\tif(i==j)continue;\n\t\t\t\t\tif(kyori[i][j]==0){\n\t\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\t\tcontinue label;\n\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println(i+\" \"+j+\" \"+kyori[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum=0;\n\t\t\tans=1<<30;\n\t\t\tbt(0,0);\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tstatic int sum,ans;\n\tstatic void bt(int a,int step){\n//\t\tSystem.out.println(a+\" \"+step+\" \"+sum);\n\t\tif(ans<=sum)return;\n\t\tif(step==kyori[0].length-1){\n\t\t\tans=Math.min(ans,sum);\n\t\t}\n\t\tfor(int i=0;i<kyori[0].length;i++){\n\t\t\tif(a==i)continue;\n\t\t\tif(kyori[a][i]==0)continue;\n\t\t\tint tmp=kyori[a][i];\n\t\t\tkyori[a][i]=kyori[i][a]=0;\n\t\t\tsum+=tmp;\n\t\t\tbt(i,step+1);\n\t\t\tkyori[a][i]=kyori[i][a]=tmp;\n\t\t\tsum-=tmp;\n\t\t}\n\t}\n\tstatic void a(int x,int y,int cnt){\n\t\tint[][] f=new int[h+2][w+2];\n\t\tfor(int i=0;i<h+2;i++){\n\t\t\tfor(int j=0;j<w+2;j++){\n\t\t\t\tf[i][j]=field[i][j];\n\t\t\t}\n\t\t}\n\t\tQueue<int[]> q=new LinkedList<int[]>();\n\t\tq.add(new int[]{x,y});\n\t\tint steps=0;\n\t\t\n\t\twhile(!q.isEmpty()){\n\t\t\tint size=q.size();\n\t\t\tfor(int i=0;i<size;i++){\n\t\t\t\tint[] aaa=q.poll();\n\t\t\t\tint xx=aaa[0];\n\t\t\t\tint yy=aaa[1];\n\t\t\t\tif(f[xx][yy]>=0){\n\t\t\t\t\tkyori[cnt][f[xx][yy]]=steps;\n\t\t\t\t}\n\t\t\t\tf[xx][yy]=-1;\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tint x1=xx+v1[j];\n\t\t\t\t\tint y1=yy+v2[j];\n\t\t\t\t\tif(f[x1][y1]==-1)continue;\n\t\t\t\t\tq.add(new int[]{x1,y1});\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tsteps++;\n\t\t}\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\nimport javax.xml.ws.WebFault;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tint INF = 100000000;\n\t\n\tint[] vx = {1, 0}, vy = {0, 1};\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint m = in.nextInt(), n = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tchar[][] map = new char[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.next().toCharArray();\n\t\t\t}\n\t\t\t\n\t\t\tint[] node = new int[11];\n\t\t\tint cur = 1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif (map[i][j] == '*') {\n\t\t\t\t\t\tnode[cur] = i * m + j;\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t} else if (map[i][j] == 'o') {\n\t\t\t\t\t\tnode[0] = i * m + j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnode = Arrays.copyOf(node, cur);\n\t\t\t\n\t\t\tint[][] dist = new int[n*m][n*m];\n\t\t\tfor (int i = 0; i < n * m; i++) {\n\t\t\t\tArrays.fill(dist[i], INF);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int y1 = 0; y1 < n; y1++) for (int x1 = 0; x1 < m; x1++) {\n\t\t\t\tif (map[y1][x1] == 'x') continue;\n\t\t\t\tint i = y1 * m + x1;\n\t\t\t\tdist[i][i] = 0;\n\t\t\t\tfor (int d = 0; d < vx.length; d++) {\n\t\t\t\t\tint nx = x1 + vx[d], ny = y1 + vy[d];\n\t\t\t\t\tint j = ny * m + nx;\n\t\t\t\t\tif (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n\t\t\t\t\t\tif (map[ny][nx] == 'X') {\n\t\t\t\t\t\t\tdist[i][j] = dist[j][i] = INF;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdist[i][j] = dist[j][i] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int k = 0; k < n * m; k++) {\n\t\t\t\tfor (int i = 0; i < n * m; i++) {\n\t\t\t\t\tfor (int j = 0; j < n * m; j++) {\n\t\t\t\t\t\tdist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint all = node.length;\n\t\t\tint[][] dp = new int[1<<all][all];\n\t\t\tfor (int i = 0; i < (1 << all); i++) Arrays.fill(dp[i], INF);\n\t\t\tdp[1][0] = 0;\n\t\t\t\n\t\t\tfor (int i = 1; i < (1 << all); i++) {\n\t\t\t\tfor (int from = 0; from < all; from++) {\n\t\t\t\t\tif (((1 << from) & i) == 0 || dp[i][from] == INF) continue;\n\t\t\t\t\tfor (int to = 0; to < all; to++) if (from != to) {\n\t\t\t\t\t\tif (((1 << to) & i) != 0) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tint bit = i | (1 << to);\n\t\t\t\t\t\tdp[bit][to] = Math.min(dp[bit][to], dp[i][from] + dist[node[from]][node[to]]);\n//\t\t\t\t\t\tSystem.out.println(i + \" \" + from + \" \" + dp[i][from] + \" -> \" + bit + \" \" + to + \" \" + dp[bit][to]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint res = INF;\n\t\t\tfor (int i = 1; i < all; i++) {\n\t\t\t\tres = Math.min(res, dp[(1<<all)-1][i]);\n\t\t\t}\n\t\t\tSystem.out.println(res == INF ? -1 : res);\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.FileInputStream;\nimport java.io.PrintStream;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main\n{\n\tstatic int w;\n\tstatic int h;\n\t\n\tstatic int[][] map;\n\t\n\tstatic int gnum;\n\tstatic int[] gx;\n\tstatic int[] gy;\n\t\n\tstatic int sx;\n\tstatic int sy;\n\t\n\tstatic int[] smindis;\n\tstatic int[][] gmindis;\n\t\n\tstatic int min;\n\tstatic int[] stock;\n\tstatic int[] order;\n\t\n\tprivate static void check(int index)\n\t{\n\t\tint i, j, k;\n\t\tif(index == gnum)\n\t\t{\n\t\t\tint len;\n\t\t\t\n\t\t\tlen = smindis[order[0]];\n\t\t\tfor(i = 1;i < gnum;i++) len += gmindis[order[i-1]][order[i]];\n\t\t\tif(len < min) min = len;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor(i = 0;i < (gnum - index);i++)\n\t\t{\n\t\t\torder[index] = stock[i];\n\t\t\tstock[i] = stock[gnum - index - 1];\n\t\t\tcheck(index + 1);\n\t\t\tstock[i] = order[index];\n\t\t}\n\t}\n\t\n\tprivate static int distance(int x1, int y1, int x2, int y2)\n\t{\n\t\tint[][] store = new int[h][w];\n\t\t\n\t\tint x, y;\n\t\tfor(y = 0;y < h;y++)\n\t\t\tfor(x = 0;x < w;x++)\n\t\t\t\tstore[y][x] = -1;\n\t\t\n\t\tstore[y1][x1] = 0;\n\t\t\n\t\tLinkedList<Point> queue = new LinkedList<Point>();\n\t\tLinkedList<Integer> pre = new LinkedList<Integer>();\n\t\t\n\t\tqueue.offer(new Point(x1 - 1, y1));\n\t\tpre.offer(new Integer(0));\n\t\tqueue.offer(new Point(x1 + 1, y1));\n\t\tpre.offer(new Integer(0));\n\t\tqueue.offer(new Point(x1, y1 - 1));\n\t\tpre.offer(new Integer(0));\n\t\tqueue.offer(new Point(x1, y1 + 1));\n\t\tpre.offer(new Integer(0));\n\t\t\n\t\twhile(queue.size() > 0)\n\t\t{\n\t\t\tPoint p = queue.poll();\n\t\t\tInteger num = pre.poll();\n\t\t\t\n\t\t\tif(p.x < 0 || w <= p.x || p.y < 0 || h <= p.y) continue;\n\t\t\tif(map[p.y][p.x] == 1) continue;\n\t\t\tif(store[p.y][p.x] >= 0) continue;\n\t\t\t\n\t\t\tstore[p.y][p.x] = num.intValue() + 1;\n\t\t\t\n\t\t\tqueue.offer(new Point(p.x - 1, p.y));\n\t\t\tpre.offer(new Integer(store[p.y][p.x]));\n\t\t\tqueue.offer(new Point(p.x + 1, p.y));\n\t\t\tpre.offer(new Integer(store[p.y][p.x]));\n\t\t\tqueue.offer(new Point(p.x, p.y - 1));\n\t\t\tpre.offer(new Integer(store[p.y][p.x]));\n\t\t\tqueue.offer(new Point(p.x, p.y + 1));\n\t\t\tpre.offer(new Integer(store[p.y][p.x]));\n\t\t}\n\t\t\n\t\treturn store[y2][x2];\n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t\tScanner sca = new Scanner(System.in);\n\t\tint i, j, k;\n\t\tint x, y;\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\t// 初期化 ------------------------------------------------------------------------\n\t\t\tw = sca.nextInt();\n\t\t\th = sca.nextInt();\n\t\t\t\n\t\t\tif(w == 0) break;\n\t\t\t\n\t\t\tmap = new int[h][w];\n\t\t\tgx = new int[10];\n\t\t\tgy = new int[10];\n\t\t\t\n\t\t\tgnum = 0;\n\t\t\tfor(y = 0;y < h;y++)\n\t\t\t{\n\t\t\t\tString line = sca.next();\n\t\t\t\tfor(x = 0;x < w;x++)\n\t\t\t\t{\n\t\t\t\t\tswitch(line.charAt(x))\n\t\t\t\t\t{\n\t\t\t\t\tcase '.': map[y][x] = 0; break;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\tmap[y][x] = 0; \n\t\t\t\t\t\tgx[gnum] = x;\n\t\t\t\t\t\tgy[gnum] = y;\n\t\t\t\t\t\tgnum++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'x': map[y][x] = 1; break;\n\t\t\t\t\tcase 'o': \n\t\t\t\t\t\tmap[y][x] = 0;\n\t\t\t\t\t\tsx = x;\n\t\t\t\t\t\tsy = y;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// 処理1 : スタートと各ゴミの各点の最短距離を求める ------------------------------------------------------------------------\n\t\t\tsmindis = new int[gnum];\n\t\t\tgmindis = new int[gnum][gnum];\n\t\t\t\n\t\t\tint dis;\n\t\t\tfor(i = 0;i < gnum;i++)\n\t\t\t{\n\t\t\t\tdis = distance(sx, sy, gx[i], gy[i]);\n\t\t\t\tif(dis < 0) break;\n\t\t\t\tsmindis[i] = dis;\n\t\t\t}\n\t\t\tif(i != gnum)\n\t\t\t{\n\t\t\t\tSystem.out.println(\"-1\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(i = 0;i < gnum;i++)\n\t\t\t{\n\t\t\t\tfor(j = i;j < gnum;j++)\n\t\t\t\t{\n\t\t\t\t\tgmindis[j][i] = gmindis[i][j] = distance(gx[i], gy[i], gx[j], gy[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// 処理2 : 最短経路を計算する ------------------------------------------------------------------------\n\t\t\tmin = Integer.MAX_VALUE;\n\t\t\tstock = new int[gnum];\n\t\t\tfor(i = 0;i < gnum;i++) stock[i] = i;\n\t\t\torder = new int[gnum];\n\t\t\t\n\t\t\tcheck(0);\n\t\t\t\n\t\t\t// 出力 ------------------------------------------------------------------------\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tint [] xdis = {0,1,0,-1};\n\tint [] ydis = {1,0,-1,0};\n\tclass C{\n\t\tint x,y,s;\n\n\t\tpublic C(int x, int y, int s) {\n\t\t\tthis.x = x;\tthis.y = y;\tthis.s = s;\n\t\t}\n\t\t\n\t}\n\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\tchar [][] data = new char[w][h];\n\t\t\tint sy=-1,sx=-1;\n\t\t\tArrayList<Integer> dxlist = new ArrayList<Integer>();\n\t\t\tArrayList<Integer> dylist = new ArrayList<Integer>();\n\t\t\t//input\n\t\t\tfor(int y=0; y < h; y++){\n\t\t\t\tString line = sc.next();\n\t\t\t\tfor(int x=0; x < w; x++){\n\t\t\t\t\tdata[x][y] = line.charAt(x);\n\t\t\t\t\tif(data[x][y] == 'o'){\n\t\t\t\t\t\tsx = x;\n\t\t\t\t\t\tsy = y;\n\t\t\t\t\t}\n\t\t\t\t\telse if(data[x][y] == '*'){\n\t\t\t\t\t\tdxlist.add(x);\n\t\t\t\t\t\tdylist.add(y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint len = dxlist.size() + 1;\n\t\t\tint [][] pass = new int[len][len];\n\t\t\tboolean flg = false;\n\t\t\tfor(int i = -1; i < len-1; i++){\n\t\t\t\tint ssy,ssx;\n\t\t\t\tif(i == -1){\n\t\t\t\t\tssx = sx;\n\t\t\t\t\tssy = sy;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tssx = dxlist.get(i);\n\t\t\t\t\tssy = dylist.get(i);\n\t\t\t\t}\n\t\t\t\tfor(int j =i + 1; j < len -1; j++){\n\t\t\t\t\tint gx = dxlist.get(j), gy = dylist.get(j);\n\t\t\t\t\t\n\t\t\t\t\tLinkedList<C> open = new LinkedList<C>();\n\t\t\t\t\tboolean [][] close = new boolean[w][h];\n\t\t\t\t\topen.add(new C(ssx, ssy,0));\n\t\t\t\t\tclose[ssx][ssy] = true;\n\t\t\t\t\tint ans = INF;\n\t\t\t\t\twhile(! open.isEmpty()){\n\t\t\t\t\t\tC now = open.removeFirst();\n\t\t\t\t\t\tif(now.x == gx && now.y ==gy){\n\t\t\t\t\t\t\tans = now.s;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int k=0; k < 4; k++){\n\t\t\t\t\t\t\tint xx = now.x + xdis[k], yy = now.y + ydis[k];\n\t\t\t\t\t\t\tif(! (0<= xx && xx < w && 0<= yy && yy < h))\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tif(data[xx][yy] == 'x') continue;\n\t\t\t\t\t\t\tif(close[xx][yy]) continue;\n\t\t\t\t\t\t\topen.add(new C(xx,yy,now.s + 1));\n\t\t\t\t\t\t\tclose[xx][yy] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ans == INF){\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tpass[i+1][j+1] = ans;\n\t\t\t\t\tpass[j+1][i+1] = ans;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(flg)\n\t\t\t\t\tbreak;\n\t\t\t}//end i\n\t\t\tif(flg){\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t//dp\n\t\t\tint len2 = len - 1;\n\t\t\tint [][] dp = new int[len2][1 << len2];\n\t\t\tfor(int i=1; i < len; i++){\n\t\t\t\tdp[i-1][1<< (i -1)] = pass[0][i];\n\t\t\t}\n\t\t\tfor(int i=1;i < (1 << len2) ; i++){\n\t\t\t\tfor(int j= 0; j < len2; j++){\n\t\t\t\t\tif(dp[j][i] == 0) continue;\n\t\t\t\t\tfor(int k = 0; k < len2; k++){\n\t\t\t\t\t\tif((i & (1 << k)) == 1) continue;\n\t\t\t\t\t\tint ind = i | (1 << k);\n\t\t\t\t\t\tif(dp[k][ind] == 0){\n\t\t\t\t\t\t\tdp[k][ind] = dp[j][i] + pass[j+1][k+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[k][ind] = Math.min(dp[k][ind], dp[j][i] + pass[j+1][k+1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint res = INF;\n\t\t\tfor(int i=0; i < len2;i++){\n\t\t\t\tres = Math.min(res, dp[i][(1 << len2) - 1]) ;\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.print(\"ANS=\");\n\t\t\tSystem.out.println(res);\n\t\t\t\n\t\t\t//debug\n//\t\t\tfor(int i=0; i < len; i++){\n//\t\t\t\tfor(int j =0; j < len;j++){\n//\t\t\t\t\tif(pass[i][j] == INF){\n//\t\t\t\t\t\tSystem.out.print(\"**\" );\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tSystem.out.print(pass[i][j] + \" \" );\n//\t\t\t\t\t}\n//\t\t\t\t\t\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n//\t\t\tfor(int i = 0; i < (1 << len2); i++){\n//\t\t\t\tSystem.out.print(i + \" \");\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t\tfor(int i = 0; i < len2; i++){\n//\t\t\t\tfor(int j = 0; j < (1 << len2);j++){\n//\t\t\t\t\tSystem.out.print(dp[i][j] + \" \");\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println(\"\");\n//\t\t\t}\n//\t\t\tSystem.out.println(\"\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n    int w,h;\n    char[][] tile;\n    int sx,sy;\n    ArrayList<Point> p;\n    int[][] d;\n    int[][] dist;\n    int[][] dp;\n    int INF = 100000000;\n\n    class Point{\n\tint x,y;\n\tpublic Point(int x, int y){\n\t    this.x = x;\n\t    this.y = y;\n\t}\n    }\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\twhile(true){\n\t    w = sc.nextInt();\n\t    h = sc.nextInt();\n\t    if(w==0 && h==0)break;\n\n\t    tile = new char[h][w];\n\t    p = new ArrayList<Point>();\n\t    for(int i=0; i<h; i++){\n\t\tString line = sc.next();\n\t\tfor(int j=0; j<w; j++){\n\t\t    tile[i][j] = line.charAt(j);\n\t\t    if(tile[i][j]=='o'){\n\t\t\tsx = j; sy = i;\n\t\t    }\n\t\t    if(tile[i][j]=='*'){\n\t\t\tp.add(new Point(j,i));\n\t\t    }\n\t\t}\n\t    }\n\t    p.add(new Point(sx,sy));\n\n\t    d = new int[p.size()][p.size()];\n\t    for(int i=0; i<p.size(); i++) Arrays.fill(d[i],INF);\n\t    for(int i=0; i<p.size(); i++){\n\t\tdist = new int[h][w];\n\t\tfor(int j=0; j<h; j++) Arrays.fill(dist[j],INF);\n\t\tbfs(i);\n\t\tfor(int j=0; j<p.size(); j++){\n\t\t    d[i][j] = dist[p.get(j).y][p.get(j).x];\n\t\t}\n\t    }\n\n\t    dp = new int[1 << p.size()][p.size()];\n\t    for(int i=0; i<1<<p.size(); i++)Arrays.fill(dp[i],-1);\n\n\t    int ans = tsp(0,p.size()-1);\n\t    if(ans==INF)ans = -1;\n\t    System.out.println(ans);\n\t}\n    }\n\n    void bfs(int s){\n\tint[] dx = {0,0,1,-1};\n\tint[] dy = {1,-1,0,0};\n\n\tLinkedList<Point> q = new LinkedList<Point>();\n\tq.add(new Point(p.get(s).x,p.get(s).y));\n\tdist[p.get(s).y][p.get(s).x] = 0;\n\n\twhile(q.size()>0){\n\t    Point point = q.poll();\n\n\t    for(int i=0; i<4; i++){\n\t\tint nx = point.x+dx[i];\n\t\tint ny = point.y+dy[i];\n\t\tif(nx>=0 && nx<w && ny>=0 && ny<h && tile[ny][nx]!='x' && dist[ny][nx]==INF){\n\t\t    q.add(new Point(nx,ny));\n\t\t    dist[ny][nx] = dist[point.y][point.x]+1;\n\t\t}\n\t    }\n\t}\n    }\n\n    int tsp(int S, int v){\n\tif(dp[S][v]>=0) return dp[S][v];\n\n\tif(S==(1<<p.size())-1) return dp[S][v] = 0;\n\n\tint res = INF;\n\tfor(int i=0; i<p.size(); i++){\n\t    if((S>>i&1)==0){\n\t\tres = Math.min(res,tsp(S|1<<i,i)+d[v][i]);\n\t    }\n\t}\n\n\treturn dp[S][v] = res;\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ4\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1,-1,1,1,-1}, vy={-1,0,1,0,-1,-1,1,1};\n\tfinal int INF=1<<24;\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\treturn (min<=x&&x<X)&&(min<=y&&y<Y);}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\t//long s=System.currentTimeMillis();\n\t\tnew Main().AOJ1140();\n\t\t//out.println((System.currentTimeMillis()-s)+\"msec\");\n\t}\n\t\n\tvoid disp(char[][] c){\n\t\tfor(int y=0; y<c[0].length; y++){\n\t\t\tfor(int x=0; x<c.length; x++)\tout.print(c[x][y]);\n\t\t\tout.println();\n\t\t}\n\t}\n\t\n\tvoid AOJ1140(){\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(),H=sc.nextInt(),sx=0,sy=0,k=0;\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tchar[][] c=new char[W][H];\n\t\t\tint[][] kk=new int[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tc[x][y]=line.charAt(x);\n\t\t\t\t\tif(c[x][y]=='*'){\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tkk[x][y]=k;\n\t\t\t\t\t}\n\t\t\t\t\telse if(c[x][y]=='o'){\n\t\t\t\t\t\tsx=x;\tsy=y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//disp(c);\n\t\t\tPriorityQueue<C1140> open=new PriorityQueue<C1140>();\n\t\t\tint[][][][] close=new int[W][H][k+1][(1<<k+1)];\n\t\t\tfor(int i=0; i<W; i++){\n\t\t\t\tfor(int j=0; j<H; j++){\n\t\t\t\t\tfor(int l=0; l<=k; l++){\n\t\t\t\t\t\tfor(int m=0; m<(1<<k+1); m++)\tclose[i][j][l][m]=INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\topen.add(new C1140(sx,sy,0,k,(1<<k+1)-1,dcopy(c)));\n\t\t\tclose[sx][sy][k][(1<<k+1)-1]=0;\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC1140 now=open.poll();\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tboolean flag=false;\n\t\t\t\t\tint xx=now.x+vx[i],yy=now.y+vy[i],r=now.r,m=now.m;\n\t\t\t\t\tif(!Point.ok(xx, yy, W, H))\tcontinue;\n\t\t\t\t\tif(c[xx][yy]=='x')\tcontinue;\n\t\t\t\t\tif(now.c[xx][yy]=='*'){\n\t\t\t\t\t\tr--;\n\t\t\t\t\t\tm=now.m^(1<<kk[xx][yy]);\n\t\t\t\t\t}\n\t\t\t\t\tif(close[xx][yy][r][m]<=now.s+1)\tcontinue;\n\t\t\t\t\tif(r==0){\n\t\t\t\t\t\t//out.println(\"ANS:\"+now);\n\t\t\t\t\t\tans=min(ans,now.s+1);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(now.c[xx][yy]=='*'){\n\t\t\t\t\t\tnow.c[xx][yy]='.';\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t//out.println(\"DL\"+xx+\",\"+yy);\n\t\t\t\t\t\t//disp(now.c);\n\t\t\t\t\t}\n\t\t\t\t\topen.add(new C1140(xx,yy,now.s+1,r,m,dcopy(now.c)));\n\t\t\t\t\tclose[xx][yy][r][m]=now.s+1;\n\t\t\t\t\tif(flag)\tnow.c[xx][yy]='*';\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println((ans>=INF?-1:ans));\n\t\t}\n\t}\n\tclass C1140 implements Comparable<C1140>{\n\t\tint x,y,s,r,m;\n\t\tchar[][] c;\n\t\tC1140(int x,int y,int s,int r,int m,char[][] c){\tthis.x=x; this.y=y; this.s=s; this.r=r; this.m=m; this.c=c;}\n\t\t@Override public int compareTo(C1140 o) {\n\t\t\tif(this.r<o.r)\treturn -1;\n\t\t\tif(this.r>o.r)\treturn 1;\n\t\t\tif(this.s<o.s)\treturn -1;\n\t\t\tif(this.s>o.s)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t\t@Override public String toString() {\n\t\t\treturn \"(\"+x+\",\"+y+\") S:\"+s+\" R:\"+r;\n\t\t}\n\t}\n\tchar[][] dcopy(char[][] c){\n\t\tchar[][] r=new char[c.length][c[0].length];\n\t\tfor(int i=0; i<c.length; i++){\n\t\t\tfor(int j=0; j<c[0].length; j++)\tr[i][j]=c[i][j];\n\t\t}\n\t\treturn r;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int w,h,startx,starty;\n\tstatic int[][]field,kyori;\n\tstatic List<int[]> list;\n\tstatic int[] v1={1,0,-1,0};\n\tstatic int[] v2={0,-1,0,1};\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tlabel:while(true){\n\t\t\tw=cin.nextInt();\n\t\t\th=cin.nextInt();\n\t\t\tif(w+h==0)break;\n\t\t\tfield=new int[h+2][w+2];\n\t\t\tlist=new ArrayList<int[]>();\n\t\t\tint cnt=0;\n\t\t\tfor(int i=0;i<=h+1;i++){\n\t\t\t\tArrays.fill(field[i], -1);\n\t\t\t}\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tchar[] s=cin.next().toCharArray();\n\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\tif(s[j-1]=='.'){\n\t\t\t\t\t\tfield[i][j]=-2;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s[j-1]=='x'){\n\t\t\t\t\t\tfield[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s[j-1]=='*'){\n\t\t\t\t\t\tfield[i][j]=++cnt;\n\n\t\t\t\t\t\tlist.add(new int[]{i,j});\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tfield[i][j]=0;\n\t\t\t\t\t\tstartx=i;\n\t\t\t\t\t\tstarty=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tfor(int j=1;j<=w;j++){\n//\t\t\t\t\tSystem.out.print(field[i][j]);\n\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t//0,0がスタート地点\n\t\t\tkyori=new int[cnt+1][cnt+1];\n\t\t\ta(startx,starty,0);\n\t\t\tcnt=1;\n\t\t\tfor(int[] a:list){\n\t\t\t\ta(a[0],a[1],cnt++);\n\t\t\t}\n\t\t\tfor(int i=0;i<kyori[0].length;i++){\n\t\t\t\tfor(int j=0;j<kyori[0].length;j++){\n\t\t\t\t\tif(i==j)continue;\n\t\t\t\t\tif(kyori[i][j]==0){\n\t\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\t\tcontinue label;\n\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println(i+\" \"+j+\" \"+kyori[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum=0;\n\t\t\tans=1<<30;\n\t\t\tbt(0,0);\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tstatic int sum,ans;\n\tstatic void bt(int a,int step){\n//\t\tSystem.out.println(a+\" \"+step+\" \"+sum);\n\t\tif(ans<=sum)return;\n\t\tif(step==kyori[0].length-1){\n\t\t\tans=Math.min(ans,sum);\n\t\t}\n\t\tfor(int i=0;i<kyori[0].length;i++){\n\t\t\tif(a==i)continue;\n\t\t\tif(kyori[a][i]==0)continue;\n\t\t\tint tmp=kyori[a][i];\n\t\t\tkyori[a][i]=kyori[i][a]=0;\n\t\t\tsum+=tmp;\n\t\t\tbt(i,step+1);\n\t\t\tkyori[a][i]=kyori[i][a]=tmp;\n\t\t\tsum-=tmp;\n\t\t}\n\t}\n\tstatic void a(int x,int y,int cnt){\n\t\tint[][] f=new int[h+2][w+2];\n\t\tfor(int i=0;i<h+2;i++){\n\t\t\tfor(int j=0;j<w+2;j++){\n\t\t\t\tf[i][j]=field[i][j];\n\t\t\t}\n\t\t}\n\t\tQueue<int[]> q=new LinkedList<int[]>();\n\t\tq.add(new int[]{x,y,0});\n\t\twhile(!q.isEmpty()){\n\t\t\tint[] aaa=q.poll();\n\t\t\tint xx=aaa[0];\n\t\t\tint yy=aaa[1];\n\t\t\tif(f[xx][yy]>=0){\n\t\t\t\tkyori[cnt][f[xx][yy]]=aaa[2];\n\t\t\t}\n\t\t\tf[xx][yy]=-1;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint x1=xx+v1[i];\n\t\t\t\tint y1=yy+v2[i];\n\t\t\t\tif(f[x1][y1]==-1)continue;\n\t\t\t\tq.add(new int[]{x1,y1,aaa[2]+1});\n\t\t\t}\n\t\t}\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid run(){\n\t\tnew AOJ1140();\n\t}\n\t\n\tclass AOJ1140{\n\t\tint w,h;\n\t\tfinal int INF=Integer.MAX_VALUE/4;\n\t\tAOJ1140(){\n\t\t\twhile(true){\n\t\t\t\tw=sc.nextInt();\n\t\t\t\th=sc.nextInt();\n\t\t\t\tif((w|h)==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tvoid solve(){\n\t\t\tint[][] map=new int[w][h];\n\t\t\tint sx=0,sy=0,c=1;\n\t\t\tfor(int y=0; y<h; ++y){\n\t\t\t\tchar[] line=sc.next().toCharArray();\n\t\t\t\tfor(int x=0; x<w; ++x){\n\t\t\t\t\tif(line[x]=='o'){\n\t\t\t\t\t\tsx=x;\n\t\t\t\t\t\tsy=y;\n\t\t\t\t\t}else if(line[x]=='x'){\n\t\t\t\t\t\tmap[x][y]=-1;\n\t\t\t\t\t}else if(line[x]=='*'){\n\t\t\t\t\t\tmap[x][y]=c++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t--c;\t// number of dirty tile\n\t\t\tint b=(1<<c)-1;\n//\t\t\tSystem.out.println(Integer.bitCount(b));\n//\t\t\tSystem.out.println(Integer.toBinaryString(b));\n\t\t\tint[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\t\t\t\n\t\t\tint[][][] closed=new int[w][h][b+1];\n//\t\t\tfor(int x=0; x<w; ++x)for(int y=0; y<h; ++y)for(int z=0; z<=b; ++z)closed[x][y][z]=(x==sx&&y==sy?0:INF);\n\t\t\tfor(int x=0; x<w; ++x)for(int y=0; y<h; ++y)for(int z=0; z<=b; ++z)closed[x][y][z]=INF;\n\t\t\tclosed[sx][sy][b]=0;\n\n\t\t\tLinkedList<state> open=new LinkedList<state>();\n\t\t\topen.add(new state(sx,sy,b,0));\n\t\t\t\n\t\t\tint ans=-1;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tstate now=open.poll();\n//\t\t\t\tSystem.out.println(now);\n\t\t\t\tif(now.t==0){\n\t\t\t\t\tans=now.z;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int v=0; v<4; ++v){\n\t\t\t\t\tint xx=now.x+vx[v], yy=now.y+vy[v];\n\t\t\t\t\tif(!(0<=xx && xx<w && 0<=yy && yy<h))\tcontinue;\n\t\t\t\t\tif(map[xx][yy]<0)\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tint nt=now.t;\n\t\t\t\t\tif(map[xx][yy]>0 && (now.t&(1<<(map[xx][yy]-1)))>0 )\tnt = now.t^(1<<(map[xx][yy]-1));\n\t\t\t\t\t\n\t\t\t\t\tif(closed[xx][yy][nt]<=now.z+1)\tcontinue;\n\t\t\t\t\tclosed[xx][yy][nt]=now.z+1;\n\t\t\t\t\topen.add(new state(xx,yy,nt,now.z+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\tclass state{\n\t\t\tint x,y,t,z;\n\t\t\tstate(int x,int y,int t,int z){\n\t\t\t\tthis.x=x;\n\t\t\t\tthis.y=y;\n\t\t\t\tthis.t=t;\n\t\t\t\tthis.z=z;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn \"x:\"+x+\" y:\"+y+\" t:\"+Integer.toBinaryString(t)+\" z:\"+z;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ1138{\n\t\tint n,m,p,a,b;\n\t\tfinal int INF=Integer.MAX_VALUE/4;\n\t\tAOJ1138(){\n\t\t\twhile(true){\n\t\t\t\tn=sc.nextInt();\n\t\t\t\tm=sc.nextInt();\n\t\t\t\tp=sc.nextInt();\n\t\t\t\ta=sc.nextInt();\n\t\t\t\tb=sc.nextInt();\n\t\t\t\tif(n==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tvoid solve(){\n\t\t\tint[] tickets=new int[n];\n\t\t\tfor(int i=0; i<n; ++i)\ttickets[i]=sc.nextInt();\n\t\t\tint[][] path=new int[m][m];\n\t\t\tfor(int i=0; i<m; ++i)for(int j=0; j<m; ++j)path[i][j]=INF;\n\t\t\tfor(int i=0; i<p; ++i){\n\t\t\t\tint x=sc.nextInt(),y=sc.nextInt(),z=sc.nextInt();\n\t\t\t\t--x;\n\t\t\t\t--y;\n\t\t\t\tpath[x][y]=z;\n\t\t\t\tpath[y][x]=z;\n\t\t\t}\n\t\t\t\n\t\t\t--a;\n\t\t\t--b;\n\t\t\t\n\t\t\tint bit=(1<<n)-1;\n//\t\t\tSystem.out.println(Integer.bitCount(bit));\n\t\t\tdouble[][] closed=new double[m][bit+1];\n\t\t\tfor(int i=0; i<m; ++i)for(int j=0; j<=bit; ++j)closed[i][j]=(i==a? 0 : INF);\n\t\t\t\n\t\t\tPriorityQueue<state> open = new PriorityQueue<state>();\n\t\t\topen.add(new state(a,bit,0));\n\t\t\t\n\t\t\tdouble ans=INF;\n\t\t\t\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tstate now = open.poll();\n//\t\t\t\tSystem.out.println(now);\n\t\t\t\tif(now.p==b){\n\t\t\t\t\tans=min(ans,now.z);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int to=0; to<m; to++){\n\t\t\t\t\tif(path[now.p][to]>=INF)\tcontinue;\n\t\t\t\t\tif(now.p==to)\tcontinue;\n\t\t\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\t\t\tif( (now.t & (1<<i) ) == 0 )\tcontinue;\n\t\t\t\t\t\tdouble a = (double)path[now.p][to]/(double)tickets[i];\n\t\t\t\t\t\tint b = now.t^(1<<i);\n\t\t\t\t\t\tif(closed[to][b] <= now.z+a)\tcontinue;\n\t\t\t\t\t\tclosed[to][b] = now.z+a;\n\t\t\t\t\t\topen.add(new state(to,b,now.z+a));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(ans>=INF ? \"Impossible\" : ans);\n\t\t}\n\t\tclass state implements Comparable<state>{\n\t\t\tint p,t;\n\t\t\tdouble z;\n\t\t\tstate(int p,int t,double z){\n\t\t\t\tthis.p=p;\n\t\t\t\tthis.t=t;\n\t\t\t\tthis.z=z;\n\t\t\t}\n\t\t\t@Override public int compareTo(state o){\n\t\t\t\treturn (int)(this.z-o.z);\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn \"p:\"+p+\" t:\"+Integer.toBinaryString(t)+\" z:\"+z;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ1135{\n\t\tAOJ1135(){\n\t\t\tint n=sc.nextInt();\n\t\t\twhile(--n>=0)\tsolve();\n\t\t}\n\t\tvoid solve(){\n\t\t\tint m=sc.nextInt(),y=sc.nextInt(),n=sc.nextInt(),ans=0;\n\t\t\twhile(--n>=0){\n\t\t\t\tint a=sc.nextInt();\n\t\t\t\tdouble rate = sc.nextDouble();\n\t\t\t\tint b=sc.nextInt();\n\t\t\t\tif(a==0){\n\t\t\t\t\tint mm=m,c=0;\n\t\t\t\t\tfor(int i=0; i<y; ++i){\n\t\t\t\t\t\tc += (double)mm*rate;\n\t\t\t\t\t\tmm-=b;\n\t\t\t\t\t}\n\t\t\t\t\tans=max(ans, mm+c);\n\t\t\t\t}else{\n\t\t\t\t\tint mm=m;\n\t\t\t\t\tfor(int i=0; i<y; ++i){\n\t\t\t\t\t\tmm+=(double)mm*rate;\n\t\t\t\t\t\tmm-=b;\n\t\t\t\t\t}\n\t\t\t\t\tans=max(ans, mm);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\t\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.Point;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static int dfs(int cur, int bit, int count, int[] pos, int[][] adj, int[][] memo){\n\t\t//System.out.println(cur + \" \" + Integer.toBinaryString(bit));\n\t\tif(memo[cur][bit] >= 0){\n\t\t\treturn memo[cur][bit];\n\t\t}\n\t\t\n\t\t//System.out.println(count);\n\t\tif(bit == (1 << count) - 1){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint min = Integer.MAX_VALUE / 400;\n\t\tfor(int next = 0; next < count; next++){\n\t\t\tif((bit & (1 << next)) != 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.println(pos[cur] + \" \" + pos[next] + \" = \" + adj[pos[cur]][pos[next]]);\n\t\t\tfinal int cost = adj[pos[cur]][pos[next]] + dfs(next, bit | (1 << next), count, pos, adj, memo);\n\t\t\t\n\t\t\t//System.out.println(cost);\n\t\t\tmin = Math.min(min, cost);\n\t\t}\n\t\t\n\t\treturn memo[cur][bit] = min;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int w = sc.nextInt();\n\t\t\tfinal int h = sc.nextInt();\n\t\t\t\n\t\t\tif(w == 0 && h == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint count = 1;\n\t\t\tint[] pos = new int[11];\n\t\t\t\n\t\t\tboolean[][] is_block = new boolean[h][w];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tchar[] input = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(input[j] == 'x'){\n\t\t\t\t\t\tis_block[i][j] = true;\n\t\t\t\t\t}else if(input[j] == '*'){\n\t\t\t\t\t\tpos[count++] = i * w + j;\n\t\t\t\t\t}else if(input[j] == 'o'){\n\t\t\t\t\t\tpos[0] = i * w + j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfinal int size = h * w;\n\t\t\tfinal int INF = Integer.MAX_VALUE / 400;\n\t\t\tint[][] adj = new int[size][size];\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tArrays.fill(adj[i], INF);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(i == j){\n\t\t\t\t\t\tadj[i * w + j][i * w + j] = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(is_block[i][j]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfinal int cur = i * w + j;\n\t\t\t\t\tif(i != 0 && !is_block[i-1][j]){\n\t\t\t\t\t\tadj[(i - 1) * w + j][cur] = 1;\n\t\t\t\t\t\tadj[cur][(i - 1) * w + j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(i != h - 1 && !is_block[i+1][j]){\n\t\t\t\t\t\tadj[(i + 1) * w + j][cur] = 1;\n\t\t\t\t\t\tadj[cur][(i + 1) * w + j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(j != 0 && !is_block[i][j-1]){\n\t\t\t\t\t\tadj[i * w + j - 1][cur] = 1;\n\t\t\t\t\t\tadj[cur][i * w + j - 1] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(j != w - 1 && !is_block[i][j+1]){\n\t\t\t\t\t\tadj[i * w + j + 1][cur] = 1;\n\t\t\t\t\t\tadj[cur][i * w + j + 1] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tfor(int j = 0; j < size; j++){\n\t\t\t\t\tSystem.out.print(adj[i][j] + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\t\tfor(int j = 0; j < size; j++){\n\t\t\t\t\t\tadj[i][j] = Math.min(adj[i][j], adj[i][k] + adj[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tSystem.out.println(\"-------------------------------------------------------------------\");\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tfor(int j = 0; j < size; j++){\n\t\t\t\t\tSystem.out.print(adj[i][j] + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\t\t\tint[][] memo = new int[count][1 << count];\n\t\t\tfor(int i = 0; i < count; i++){\n\t\t\t\tArrays.fill(memo[i], -1);\n\t\t\t}\n\t\t\tfinal int cost = dfs(0, 1 << 0, count, pos, adj, memo);\n\t\t\t\n\t\t\tSystem.out.println(cost >= INF ? -1 : cost);\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int w,h,startx,starty;\n\tstatic int[][]field;\n\tstatic int[][]kyori;\n\tstatic List<int[]> list;\n\tstatic byte[] v1={1,0,-1,0};\n\tstatic byte[] v2={0,-1,0,1};\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tlabel:while(true){\n\t\t\tw=cin.nextInt();\n\t\t\th=cin.nextInt();\n\t\t\tif(w+h==0)break;\n\t\t\tfield=new int[h+2][w+2];\n\t\t\tlist=new ArrayList<int[]>();\n\t\t\tint cnt=0;\n\t\t\tfor(int i=0;i<=h+1;i++){\n\t\t\t\tArrays.fill(field[i], -1);\n\t\t\t}\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tchar[] s=cin.next().toCharArray();\n\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\tif(s[j-1]=='.'){\n\t\t\t\t\t\tfield[i][j]=-2;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s[j-1]=='x'){\n\t\t\t\t\t\tfield[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s[j-1]=='*'){\n\t\t\t\t\t\tfield[i][j]=++cnt;\n\n\t\t\t\t\t\tlist.add(new int[]{i,j});\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tfield[i][j]=0;\n\t\t\t\t\t\tstartx=i;\n\t\t\t\t\t\tstarty=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tfor(int j=1;j<=w;j++){\n//\t\t\t\t\tSystem.out.print(field[i][j]);\n\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t//0,0がスタート地点\n\t\t\tkyori=new int[cnt+1][cnt+1];\n\t\t\ta(startx,starty,0);\n\t\t\tcnt=1;\n\t\t\tfor(int[] a:list){\n\t\t\t\ta(a[0],a[1],cnt++);\n\t\t\t}\n\t\t\tfor(int i=0;i<kyori[0].length;i++){\n\t\t\t\tfor(int j=0;j<kyori[0].length;j++){\n\t\t\t\t\tif(i==j)continue;\n\t\t\t\t\tif(kyori[i][j]==0){\n\t\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\t\tcontinue label;\n\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println(i+\" \"+j+\" \"+kyori[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum=0;\n\t\t\tans=1<<30;\n\t\t\tbt(0,0);\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tstatic int sum,ans;\n\tstatic void bt(int a,int step){\n//\t\tSystem.out.println(a+\" \"+step+\" \"+sum);\n\t\tif(ans<=sum)return;\n\t\tif(step==kyori[0].length-1){\n\t\t\tans=Math.min(ans,sum);\n\t\t}\n\t\tfor(int i=0;i<kyori[0].length;i++){\n\t\t\tif(a==i)continue;\n\t\t\tif(kyori[a][i]==0)continue;\n\t\t\tint tmp=kyori[a][i];\n\t\t\tkyori[a][i]=kyori[i][a]=0;\n\t\t\tsum+=tmp;\n\t\t\tbt(i,step+1);\n\t\t\tkyori[a][i]=kyori[i][a]=tmp;\n\t\t\tsum-=tmp;\n\t\t}\n\t}\n\tstatic void a(int x,int y,int cnt){\n\t\tint[][] f=new int[h+2][w+2];\n\t\tfor(int i=0;i<h+2;i++){\n\t\t\tfor(int j=0;j<w+2;j++){\n\t\t\t\tf[i][j]=field[i][j];\n\t\t\t}\n\t\t}\n\t\tQueue<byte[]> q=new LinkedList<byte[]>();\n\t\tq.add(new byte[]{(byte)x,(byte)y});\n\t\tint steps=0;\n\t\t\n\t\twhile(q.isEmpty()){\n\t\t\tint size=q.size();\n\t\t\tfor(int i=0;i<size;i++){\n\t\t\t\tbyte[] aaa=q.poll();\n\t\t\t\tbyte xx=aaa[0];\n\t\t\t\tbyte yy=aaa[1];\n\t\t\t\tif(f[xx][yy]>=0){\n\t\t\t\t\tkyori[cnt][f[xx][yy]]=steps;kyori[f[xx][yy]][cnt]=steps;\n\t\t\t\t}\n\t\t\t\tf[xx][yy]=-1;\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tbyte x1=(byte) ((byte)xx+v1[j]);\n\t\t\t\t\tbyte y1=(byte) ((byte)yy+v2[j]);\n\t\t\t\t\tif(f[x1][y1]==-1)continue;\n\t\t\t\t\tq.add(new byte[]{x1,y1});\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tsteps++;\n\t\t}\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int W, H;\n\tstatic char[][] map;\n\tstatic int[] DR = { 1, 0, -1, 0 };\n\tstatic int[] DC = { 0, 1, 0, -1 };\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tW = sc.nextInt();\n\t\t\tH = sc.nextInt();\n\t\t\tif (W == 0) break;\n\t\t\tmap = new char[H][];\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tstatic int solve() {\n\t\tArrayList<Point> pos = new ArrayList<Point>();\n\t\tint sr = 0;\n\t\tint sc = 0;\n\t\tint[][] idx = new int[H][W];\n\t\tfor (int[] a : idx) {\n\t\t\tArrays.fill(a, -1);\n\t\t}\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (map[i][j] == 'o') {\n\t\t\t\t\tsr = i;\n\t\t\t\t\tsc = j;\n\t\t\t\t\tidx[i][j] = 0;\n\t\t\t\t} else if (map[i][j] == '*') {\n\t\t\t\t\tpos.add(new Point(i, j));\n\t\t\t\t\tidx[i][j] = pos.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint c = pos.size() + 1;\n\t\tint[][] dist = new int[c][c];\n\t\tcalc(sr, sc, 0, idx, dist);\n\t\tfor (int i = 0; i < c - 1; ++i) {\n\t\t\tcalc(pos.get(i).x, pos.get(i).y, i + 1, idx, dist);\n\t\t}\n\t\tfor (int i = 0; i < c; ++i) {\n\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\tif (dist[i][j] == 0) return -1;\n\t\t\t}\n\t\t}\n\n\t\tint[][] dp = new int[1 << c][c];\n\t\tfor (int[] a : dp) {\n\t\t\tArrays.fill(a, 1 << 30);\n\t\t}\n\t\tdp[1][0] = 0;\n\t\tfor (int i = 1; i < (1 << c); ++i) {\n\t\t\tfor (int j = 0; j < c; ++j) {\n\t\t\t\tif ((i & (1 << j)) == 0) continue;\n\t\t\t\tfor (int k = 0; k < c; ++k) {\n\t\t\t\t\tif ((i & (1 << k)) != 0) continue;\n\t\t\t\t\tdp[i + (1 << k)][k] = Math.min(dp[i + (1 << k)][k], dp[i][j] + dist[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1 << 30;\n\t\tfor (int i = 1; i < c; ++i) {\n\t\t\tans = Math.min(ans, dp[(1 << c) - 1][i]);\n\t\t}\n\t\treturn ans;\n\t}\n\n\tstatic void calc(int sr, int sc, int si, int[][] idx, int[][] dist) {\n\t\tboolean[][] visited = new boolean[H][W];\n\t\tArrayList<Point> cur = new ArrayList<Point>();\n\t\tcur.add(new Point(sr, sc));\n\t\tvisited[sr][sc] = true;\n\t\tfor (int i = 1; !cur.isEmpty(); ++i) {\n\t\t\tArrayList<Point> next = new ArrayList<Point>();\n\t\t\tfor (Point p : cur) {\n\t\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\t\tint nr = p.x + DR[j];\n\t\t\t\t\tint nc = p.y + DC[j];\n\t\t\t\t\tif (nr < 0 || H <= nr || nc < 0 || W <= nc || visited[nr][nc]) continue;\n\t\t\t\t\tif (map[nr][nc] == 'x') continue;\n\t\t\t\t\tvisited[nr][nc] = true;\n\t\t\t\t\tif (idx[nr][nc] >= 0) {\n\t\t\t\t\t\tdist[si][idx[nr][nc]] = dist[idx[nr][nc]][si] = i;\n\t\t\t\t\t}\n\t\t\t\t\tnext.add(new Point(nr, nc));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur = next;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ4\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1,-1,1,1,-1}, vy={-1,0,1,0,-1,-1,1,1};\n\tfinal int INF=1<<24;\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\treturn (min<=x&&x<X)&&(min<=y&&y<Y);}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\t//long s=System.currentTimeMillis();\n\t\tnew Main().AOJ1140();\n\t\t//out.println((System.currentTimeMillis()-s)+\"msec\");\n\t}\n\t\n\tvoid disp(char[][] c){\n\t\tfor(int y=0; y<c[0].length; y++){\n\t\t\tfor(int x=0; x<c.length; x++)\tout.print(c[x][y]);\n\t\t\tout.println();\n\t\t}\n\t}\n\t\n\tvoid AOJ1140(){\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(),H=sc.nextInt(),sx=0,sy=0,k=0;\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tchar[][] c=new char[W][H];\n\t\t\tint[][] kk=new int[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tc[x][y]=line.charAt(x);\n\t\t\t\t\tif(c[x][y]=='*'){\n\t\t\t\t\t\tkk[x][y]=k;\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(c[x][y]=='o'){\n\t\t\t\t\t\tsx=x;\tsy=y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//disp(c);\n\t\t\tPriorityQueue<C1140> open=new PriorityQueue<C1140>();\n\t\t\tint[][][][] close=new int[W][H][k+1][(1<<k)];\n\t\t\tfor(int i=0; i<W; i++){\n\t\t\t\tfor(int j=0; j<H; j++){\n\t\t\t\t\tfor(int l=0; l<=k; l++){\n\t\t\t\t\t\tfor(int m=0; m<(1<<k); m++)\tclose[i][j][l][m]=INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\topen.add(new C1140(sx,sy,0,k,(1<<k)-1,dcopy(c)));\n\t\t\tclose[sx][sy][k][(1<<k)-1]=0;\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC1140 now=open.poll();\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tboolean flag=false;\n\t\t\t\t\tint xx=now.x+vx[i],yy=now.y+vy[i],r=now.r,m=now.m;\n\t\t\t\t\tif(!Point.ok(xx, yy, W, H))\tcontinue;\n\t\t\t\t\tif(c[xx][yy]=='x')\tcontinue;\n\t\t\t\t\tif(now.c[xx][yy]=='*'){\n\t\t\t\t\t\tr--;\n\t\t\t\t\t\tm=now.m^(1<<kk[xx][yy]);\n\t\t\t\t\t}\n\t\t\t\t\tif(close[xx][yy][r][m]<=now.s+1)\tcontinue;\n\t\t\t\t\tif(r==0){\n\t\t\t\t\t\t//out.println(\"ANS:\"+now);\n\t\t\t\t\t\tans=min(ans,now.s+1);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(now.c[xx][yy]=='*'){\n\t\t\t\t\t\tnow.c[xx][yy]='.';\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t//out.println(\"DL\"+xx+\",\"+yy+\" R\"+r+\" Bit\"+Integer.bitCount(m));\n\t\t\t\t\t\t//disp(now.c);\n\t\t\t\t\t}\n\t\t\t\t\topen.add(new C1140(xx,yy,now.s+1,r,m,dcopy(now.c)));\n\t\t\t\t\tclose[xx][yy][r][m]=now.s+1;\n\t\t\t\t\tif(flag)\tnow.c[xx][yy]='*';\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println((ans>=INF?-1:ans));\n\t\t}\n\t}\n\tclass C1140 implements Comparable<C1140>{\n\t\tint x,y,s,r,m;\n\t\tchar[][] c;\n\t\tC1140(int x,int y,int s,int r,int m,char[][] c){\tthis.x=x; this.y=y; this.s=s; this.r=r; this.m=m; this.c=c;}\n\t\t@Override public int compareTo(C1140 o) {\n\t\t\tif(this.r<o.r)\treturn -1;\n\t\t\tif(this.r>o.r)\treturn 1;\n\t\t\tif(this.s<o.s)\treturn -1;\n\t\t\tif(this.s>o.s)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t\t@Override public String toString() {\n\t\t\treturn \"(\"+x+\",\"+y+\") S:\"+s+\" R:\"+r;\n\t\t}\n\t}\n\tchar[][] dcopy(char[][] c){\n\t\tchar[][] r=new char[c.length][c[0].length];\n\t\tfor(int i=0; i<c.length; i++){\n\t\t\tfor(int j=0; j<c[0].length; j++)\tr[i][j]=c[i][j];\n\t\t}\n\t\treturn r;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ4\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1,-1,1,1,-1}, vy={-1,0,1,0,-1,-1,1,1};\n\tfinal int INF=1<<24;\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\treturn (min<=x&&x<X)&&(min<=y&&y<Y);}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tvoid disp(char[][] c){\n\t\tfor(int y=0; y<c[0].length; y++){\n\t\t\tfor(int x=0; x<c.length; x++)\tout.print(c[x][y]);\n\t\t\tout.println();\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\t//long s=System.currentTimeMillis();\n\t\tnew Main().AOJ1140();\n\t\t//out.println((System.currentTimeMillis()-s)+\"msec\");\n\t}\n\t\n\tvoid AOJ1140(){\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(),H=sc.nextInt(),sx=0,sy=0,k=0;\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tchar[][] c=new char[W][H];\n\t\t\tint[][] kk=new int[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tc[x][y]=line.charAt(x);\n\t\t\t\t\tif(c[x][y]=='*'){\n\t\t\t\t\t\tkk[x][y]=k;\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}else if(c[x][y]=='o'){\n\t\t\t\t\t\tsx=x;\tsy=y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//disp(c);\n\t\t\tPriorityQueue<C1140> open=new PriorityQueue<C1140>();\n\t\t\tint[][][][] close=new int[W][H][k+1][(1<<k)];\n\t\t\tfor(int i=0; i<W; i++){\n\t\t\t\tfor(int j=0; j<H; j++){\n\t\t\t\t\tfor(int l=0; l<=k; l++){\n\t\t\t\t\t\tfor(int m=0; m<(1<<k); m++)\tclose[i][j][l][m]=INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\topen.add(new C1140(sx,sy,0,k,(1<<k)-1,dcopy(c)));\n\t\t\tclose[sx][sy][k][(1<<k)-1]=0;\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC1140 now=open.poll();\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tboolean flag=false;\n\t\t\t\t\tint xx=now.x+vx[i],yy=now.y+vy[i],r=now.r,m=now.m;\n\t\t\t\t\tif(!Point.ok(xx, yy, W, H))\tcontinue;\n\t\t\t\t\tif(c[xx][yy]=='x')\tcontinue;\n\t\t\t\t\tif(now.c[xx][yy]=='*'){\n\t\t\t\t\t\tr--;\n\t\t\t\t\t\tm=now.m^(1<<kk[xx][yy]);\n\t\t\t\t\t}\n\t\t\t\t\tif(close[xx][yy][r][m]<=now.s+1)\tcontinue;\n\t\t\t\t\tif(r==0){\n\t\t\t\t\t\t//out.println(\"ANS:\"+now);\n\t\t\t\t\t\tans=min(ans,now.s+1);\n\t\t\t\t\t\t//continue;\n\t\t\t\t\t\topen.clear();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(now.c[xx][yy]=='*'){\n\t\t\t\t\t\tnow.c[xx][yy]='.';\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t//out.println(\"DL\"+xx+\",\"+yy+\" R\"+r+\" Bit\"+Integer.bitCount(m));\n\t\t\t\t\t\t//disp(now.c);\n\t\t\t\t\t}\n\t\t\t\t\topen.add(new C1140(xx,yy,now.s+1,r,m,dcopy(now.c)));\n\t\t\t\t\tclose[xx][yy][r][m]=now.s+1;\n\t\t\t\t\tif(flag)\tnow.c[xx][yy]='*';\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println((ans>=INF?-1:ans));\n\t\t}\n\t}\n\tclass C1140 implements Comparable<C1140>{\n\t\tint x,y,s,r,m;\n\t\tchar[][] c;\n\t\tC1140(int x,int y,int s,int r,int m,char[][] c){\tthis.x=x; this.y=y; this.s=s; this.r=r; this.m=m; this.c=c;}\n\t\t@Override public int compareTo(C1140 o) {\n\t\t\tif(this.r<o.r)\treturn -1;\n\t\t\tif(this.r>o.r)\treturn 1;\n\t\t\tif(this.s<o.s)\treturn -1;\n\t\t\tif(this.s>o.s)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t\t@Override public String toString() {\n\t\t\treturn \"(\"+x+\",\"+y+\") S:\"+s+\" R:\"+r;\n\t\t}\n\t}\n\tchar[][] dcopy(char[][] c){\n\t\tchar[][] r=new char[c.length][c[0].length];\n\t\tfor(int i=0; i<c.length; i++){\n\t\t\tfor(int j=0; j<c[0].length; j++)\tr[i][j]=c[i][j];\n\t\t}\n\t\treturn r;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Math.*;\nimport static java.lang.System.*;\n\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Scanner;\n\nclass Main {\n    public static Random rand=new Random();\n    static  final  int INF=1<<29;\n\n\n    class P{\n    \tint x,y;\n    \tP(int _x,int _y){\n    \t\tx=_x;y=_y;\n    \t}\n    }\n\n    int[] dirx=new int[]{1,0,-1,0};\n    int[] diry=new int[]{0,1,0,-1};\n\n    int getDist(int i,int j){\n    \tP _p=new P(dx[i],dy[i]);\n    \tQueue<P> que=new LinkedList<>();\n    \tque.add(_p);\n    \tint d=0;\n    \tboolean[][] passed=new boolean[h][w];\n\t\tpassed[_p.y][_p.x]=true;\n    \twhile(!que.isEmpty()){\n    \t\tQueue<P> tmp=new LinkedList<>();\n    \t   \twhile(!que.isEmpty()){\n        \t\tP p=que.poll();\n        \t\tfor(int k=0;k<4;k++){\n        \t\t\tint nx=p.x+dirx[k],ny=p.y+diry[k];\n        \t\t\tif(0<=nx && nx<w && 0<=ny && ny<h){\n        \t\t\t\tif(map[ny][nx]=='x')continue;\n        \t\t\t\tif(nx==dx[j] && ny==dy[j])return d+1;\n        \t\t\t\tif(!passed[ny][nx]){\n        \t\t\t\t\ttmp.add(new P(nx,ny));\n        \t\t\t\t\tpassed[ny][nx]=true;\n        \t\t\t\t}\n        \t\t\t}\n        \t\t}\n    \t   \t}\n    \t\tque=tmp;\n    \t\td++;\n    \t}\n    \treturn INF;\n    }\n\n    // O(n^3) n≦100\n \tstatic void warshall_floyd(int[][] d){\n \t\tint n=d.length;\n \t    for(int k=0;k<n;k++)\n \t    \tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)\n \t    \t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n \t}\n\n\n\tchar[][] map;\n\tint[] dx,dy;\n\tint h,w;\n    public void run() {\n        Case:while(true){\n        \tw=sc.nextInt();h=sc.nextInt();\n        \tif(h==0 && w==0)return;\n\n        \tmap=new char[h][w];\n        \tfor(int y=0;y<h;y++)\n        \t\tmap[y]=sc.next().toCharArray();\n\n        \tint D=0;\n        \tfor(int y=0;y<h;y++)for(int x=0;x<w;x++)\n        \t\tif(map[y][x]=='*')D++;\n        \tdx=new int[D+1];dy=new int[D+1];\n        \tint ind=0;\n        \tfor(int y=0;y<h;y++)for(int x=0;x<w;x++)if(map[y][x]=='o'){\n    \t\t\tdx[ind]=x;\n    \t\t\tdy[ind]=y;\n    \t\t\tind++;\n        \t}\n        \tfor(int y=0;y<h;y++)for(int x=0;x<w;x++)if(map[y][x]=='*'){\n    \t\t\tdx[ind]=x;\n    \t\t\tdy[ind]=y;\n    \t\t\tind++;\n        \t}\n        \tint[][] ds=new int[D+1][D+1];\n        \tfor(int i=0;i<D+1;i++)Arrays.fill(ds[i],INF);\n        \tfor(int i=0;i<D+1;i++)ds[i][i]=0;\n        \tfor(int i=0;i<D+1;i++)for(int j=0;j<D+1;j++)\n        \t\tif(i!=j)ds[i][j]=getDist(i,j);\n\n        \twarshall_floyd(ds);\n\n        \tint[][] dp=new int[D+1][1<<(D+1)];\n        \tfor(int i=0;i<D+1;i++)\n        \t\tArrays.fill(dp[i],INF);\n        \tdp[0][1]=0;\n        \tfor(int i=1;i<(1<<(D+1));i++){\n        \t\tfor(int pos=1;pos<D+1;pos++){\n        \t\t\tif(((i>>pos) & 1) ==0)continue;\n        \t\t\tint mv=INF;\n        \t\t\tfor(int prev=0;prev<D+1;prev++){\n        \t\t\t\tif(((i>>prev) & 1)==1 && pos!=prev)\n        \t\t\t\t\tif(mv>dp[prev][i-(1<<pos)]+ds[prev][pos])\n        \t\t\t\t\t\tmv=dp[prev][i-(1<<pos)]+ds[prev][pos];\n         \t\t\t}\n        \t\t\tdp[pos][i]=mv;\n        \t\t}\n        \t}\n        \tint mv=INF;\n        \tfor(int i=1;i<D+1;i++)mv=min(mv,dp[i][(1<<(D+1))-1]);\n        \tif(mv<INF)\n        \t\tln(mv);\n        \telse\n        \t\tln(-1);\n        }\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n\tstatic Scanner sc=new Scanner(in);\n\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n\tstatic String str(double o){\n\t\treturn String.format(\"%.8f\",o);\n\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\tClass<?> c=o.getClass();\n\t\tif(c.equals(Boolean.class))return str((boolean)o);\n\t\tif(c.equals(Double.class))return str((double)o);\n\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tclass E {\n\t\tint from;\n\t\tint to;\n\t\tint cost;\n\n\t\tE(int from, int to, int cost) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\n\tclass V {\n\t\tint x;\n\t\tint y;\n\n\t\tV(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tint wh(int w, int i, int j) {\n\t\treturn (j * w + i);\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\n\t\t\tif ((w | h) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchar map[][] = new char[h][w];\n\t\t\tLinkedList<V> node = new LinkedList<V>();\n\t\t\tint dp[][] = new int[w * h][w * h];\n\t\t\tfor (int i = 0; i < w * h; i++) {\n\t\t\t\tArrays.fill(dp[i], Integer.MAX_VALUE / 4);\n\t\t\t}\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString buffer = sc.nextLine();\n\t\t\t\tmap[i] = buffer.toCharArray();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (map[i][j] == '*') {\n\t\t\t\t\t\tnode.addLast(new V(j, i));\n\t\t\t\t\t}\n\t\t\t\t\tif (map[i][j] == 'o') {\n\t\t\t\t\t\tnode.addFirst(new V(j, i));\n\t\t\t\t\t}\n\t\t\t\t\tif (map[i][j] != 'x') {\n\t\t\t\t\t\tif (h > j + 1) {\n\t\t\t\t\t\t\tdp[wh(w, i, j)][wh(w, i, j + 1)] = 1;\n\t\t\t\t\t\t\tdp[wh(w, i, j + 1)][wh(w, i, j)] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w > i + 1) {\n\t\t\t\t\t\t\tdp[wh(w, i, j)][wh(w, i + 1, j)] = 1;\n\t\t\t\t\t\t\tdp[wh(w, i + 1, j)][wh(w, i, j)] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (0 < j) {\n\t\t\t\t\t\t\tdp[wh(w, i, j)][wh(w, i, j - 1)] = 1;\n\t\t\t\t\t\t\tdp[wh(w, i, j - 1)][wh(w, i, j)] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (0 < i) {\n\t\t\t\t\t\t\tdp[wh(w, i, j)][wh(w, i - 1, j)] = 1;\n\t\t\t\t\t\t\tdp[wh(w, i - 1, j)][wh(w, i, j)] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint wh = w * h;\n\t\t\tfor (int i = 0; i < wh; i++) {\n\t\t\t\tfor (int j = 0; j < wh; j++) {\n\t\t\t\t\tfor (int k = 0; k < wh; k++) {\n\t\t\t\t\t\tdp[i][j] = Math.min(dp[i][k] + dp[k][j], dp[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tLinkedList<E> hen = new LinkedList<E>();\n\t\t\tboolean mmm = false;\n\t\t\tfor (int i = 0; i < node.size(); i++) {\n\t\t\t\tV temp = node.get(i);\n\t\t\t\tfor (int j = i + 1; j < node.size(); j++) {\n\t\t\t\t\tV temp2 = node.get(j);\n\t\t\t\t\tint cost = dp[wh(w, temp.x, temp.y)][wh(w,\n\t\t\t\t\t\t\ttemp2.x, temp2.y)];\n\t\t\t\t\then.add(new E(i, j, cost));\n\t\t\t\t\then.add(new E(j, i, cost));\n\t\t\t\t\tif(cost > 1e5){\n\t\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\t\tmmm = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(mmm) break;\n\t\t\t}\n\t\t\tif(mmm){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tV[] node2 = (V[]) node.toArray();\n\t\t\tint[][] dp2 = new int[1 << node.size()][node.size()];\n\t\t\tdp2[1][0] = 0;\n\t\t\tfor (int i = 0; i < 1 << node.size(); i++) {\n\t\t\t\tfor (int prev = 0; prev < node.size(); prev++) {\n\t\t\t\t\tint sh = 1 << prev;\n\t\t\t\t\tif ((i & sh) != 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint next = (i | sh);\n\t\t\t\t\tE a = hen.getFirst();\n\t\t\t\t\tfor (int l = 0; l < node.size(); l++) {\n\t\t\t\t\t\tfor (E e : hen) {\n\t\t\t\t\t\t\tif (e.from == prev) {\n\t\t\t\t\t\t\t\tif (e.to == l) {\n\t\t\t\t\t\t\t\t\ta = e;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp2[next][prev] = Math.min(dp2[next][prev], dp2[i][l]\n\t\t\t\t\t\t\t\t+ a.cost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < node.size(); i++) {\n\t\t\t\tres = Math.min(res, dp2[1 << node.size() - 1][i]);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ4\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1,-1,1,1,-1}, vy={-1,0,1,0,-1,-1,1,1};\n\tfinal int INF=1<<24;\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\treturn (min<=x&&x<X)&&(min<=y&&y<Y);}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tvoid disp(char[][] c){\n\t\tfor(int y=0; y<c[0].length; y++){\n\t\t\tfor(int x=0; x<c.length; x++)\tout.print(c[x][y]);\n\t\t\tout.println();\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\t//long s=System.currentTimeMillis();\n\t\tnew Main().AOJ1140();\n\t\t//out.println((System.currentTimeMillis()-s)+\"msec\");\n\t}\n\t\n\tvoid AOJ1140(){\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(),H=sc.nextInt(),sx=0,sy=0,k=0;\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tchar[][] c=new char[W][H];\n\t\t\tint[][] kk=new int[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tc[x][y]=line.charAt(x);\n\t\t\t\t\tif(c[x][y]=='*'){\n\t\t\t\t\t\tkk[x][y]=k;\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}else if(c[x][y]=='o'){\n\t\t\t\t\t\tsx=x;\tsy=y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//disp(c);\n\t\t\tPriorityQueue<C1140> open=new PriorityQueue<C1140>();\n\t\t\tint[][][][] close=new int[W][H][k+1][(1<<k)];\n\t\t\tfor(int i=0; i<W; i++){\n\t\t\t\tfor(int j=0; j<H; j++){\n\t\t\t\t\tfor(int l=0; l<=k; l++){\n\t\t\t\t\t\tfor(int m=0; m<(1<<k); m++)\tclose[i][j][l][m]=INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\topen.add(new C1140(sx,sy,0,k,(1<<k)-1,dcopy(c)));\n\t\t\tclose[sx][sy][k][(1<<k)-1]=0;\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC1140 now=open.poll();\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tboolean flag=false;\n\t\t\t\t\tint xx=now.x+vx[i],yy=now.y+vy[i],r=now.r,m=now.m;\n\t\t\t\t\tif(!Point.ok(xx, yy, W, H))\tcontinue;\n\t\t\t\t\tif(c[xx][yy]=='x')\tcontinue;\n\t\t\t\t\tif(now.c[xx][yy]=='*'){\n\t\t\t\t\t\tr--;\n\t\t\t\t\t\tm=now.m^(1<<kk[xx][yy]);\n\t\t\t\t\t}\n\t\t\t\t\tif(close[xx][yy][r][m]<=now.s+1)\tcontinue;\n\t\t\t\t\tif(r==0){\n\t\t\t\t\t\t//out.println(\"ANS:\"+now);\n\t\t\t\t\t\tans=min(ans,now.s+1);\n\t\t\t\t\t\t//continue;\n\t\t\t\t\t\topen.clear();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(now.c[xx][yy]=='*'){\n\t\t\t\t\t\tnow.c[xx][yy]='.';\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t//out.println(\"DL\"+xx+\",\"+yy+\" R\"+r+\" Bit\"+Integer.bitCount(m));\n\t\t\t\t\t\t//disp(now.c);\n\t\t\t\t\t}\n\t\t\t\t\topen.add(new C1140(xx,yy,now.s+1,r,m,dcopy(now.c)));\n\t\t\t\t\tclose[xx][yy][r][m]=now.s+1;\n\t\t\t\t\tif(flag)\tnow.c[xx][yy]='*';\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println((ans>=INF?-1:ans));\n\t\t}\n\t}\n\tclass C1140 implements Comparable<C1140>{\n\t\tint x,y,s,r,m;\n\t\tchar[][] c;\n\t\tC1140(int x,int y,int s,int r,int m,char[][] c){\tthis.x=x; this.y=y; this.s=s; this.r=r; this.m=m; this.c=c;}\n\t\t@Override public int compareTo(C1140 o) {\n\t\t\tif(this.s<o.s)\treturn -1;\n\t\t\tif(this.s>o.s)\treturn 1;\n\t\t\tif(this.r<o.r)\treturn -1;\n\t\t\tif(this.r>o.r)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t\t@Override public String toString() {\n\t\t\treturn \"(\"+x+\",\"+y+\") S:\"+s+\" R:\"+r;\n\t\t}\n\t}\n\tchar[][] dcopy(char[][] c){\n\t\tchar[][] r=new char[c.length][c[0].length];\n\t\tfor(int i=0; i<c.length; i++){\n\t\t\tfor(int j=0; j<c[0].length; j++)\tr[i][j]=c[i][j];\n\t\t}\n\t\treturn r;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n, m, c;\n\tint[][] a;\n\tP[] ps;\n\tint[][] w;\n\tint[] dx={0, 0, -1, 1};\n\tint[] dy={-1, 1, 0, 0};\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tm=sc.nextInt();\n\t\t\tn=sc.nextInt();\n\t\t\tif((m|n)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tps=new P[11];\n\t\t\tc=1;\n\t\t\ta=new int[n][m];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tString s=sc.next();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tswitch(s.charAt(i)){\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\ta[j][i]=-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'x':\n\t\t\t\t\t\ta[j][i]=-2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'o':\n\t\t\t\t\t\ta[j][i]=0;\n\t\t\t\t\t\tps[0]=new P(i, j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\ta[j][i]=c;\n\t\t\t\t\t\tps[c]=new P(i, j);\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tw=new int[c][c];\n\t\tfor(int i=0; i<c; i++){\n\t\t\tbfs(i);\n\t\t}\n\t\tfor(int j=0; j<c; j++){\n\t\t\tdebug(w[j]);\n\t\t\tfor(int i=0; i<c; i++){\n\t\t\t\tif(w[j][i]==-1){\n\t\t\t\t\tprintln(\"-1\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[][] dp=new int[1<<c][c];\n\t\tfor(int i=0; i<1<<c; i++){\n\t\t\tfill(dp[i], INF);\n\t\t}\n\t\tdp[1][0]=0;\n\t\tfor(int s=1; s<1<<c; s++){\n\t\t\tfor(int v=0; v<c; v++){\n\t\t\t\tfor(int u=0; u<c; u++){\n\t\t\t\t\t// v->u\n\t\t\t\t\tif((s>>u&1)==0&&(s>>v&1)==1){\n\t\t\t\t\t\tdp[s|(1<<u)][u]=min(dp[s|(1<<u)][u], dp[s][v]+w[v][u]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdebug(s, dp[s]);\n\t\t}\n\t\tint min=INF;\n\t\tfor(int i=1; i<c; i++){\n\t\t\tmin=min(min, dp[(1<<c)-1][i]);\n\t\t}\n\t\tdebug(min);\n\t\tprintln(\"\"+min);\n\t}\n\n\tvoid bfs(int s){\n\t\tLinkedList<P> que=new LinkedList<Main.P>();\n\t\tint[][] d=new int[n][m];\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfill(d[j], -1);\n\t\t}\n\t\td[ps[s].y][ps[s].x]=0;\n\t\tque.offer(ps[s]);\n\t\tfor(; !que.isEmpty();){\n\t\t\tP p=que.poll();\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tP q=new P(p.x+dx[i], p.y+dy[i]);\n\t\t\t\tif(q.x<0||q.x>=m||q.y<0||q.y>=n){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(a[q.y][q.x]!=-2&&d[q.y][q.x]==-1){\n\t\t\t\t\td[q.y][q.x]=d[p.y][p.x]+1;\n\t\t\t\t\tque.offer(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<c; i++){\n\t\t\tw[s][i]=w[i][s]=d[ps[i].y][ps[i].x];\n\t\t}\n\t}\n\n\tclass P{\n\t\tint x, y;\n\n\t\tP(int x, int y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\t// System.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tstatic Deque<Tilemap> q = new ArrayDeque<Tilemap>();\n\tstatic int[] dx = {1, 0, -1, 0};\n\tstatic int[] dy = {0, 1, 0, -1};\n\n\tpublic static class Tilemap{\n\t\tint x, y;\n\t\tint dirty_tile_num;\n\t\tint count;\n\t\tTilemap(int j, int i, int d, int c){\n\t\t\tx = j;\n\t\t\ty = i;\n\t\t\tdirty_tile_num = d;\n\t\t\tcount = c;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w==0&&h==0) break;\n\t\t\tint[][] tile = new int[h+2][w+2];\n\t\t\tint dirty_tile_num = 0;\n\t\t\tTilemap start = new Tilemap(0, 0, 0, 0);\n\n\t\t\tfor(int i=1; i<=h; i++){\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\t\tif(str.charAt(j-1)=='.'){\n\t\t\t\t\t\ttile[i][j] = 1;\n\t\t\t\t\t}else if(str.charAt(j-1)=='*'){\n\t\t\t\t\t\ttile[i][j] = 2;\n\t\t\t\t\t\tdirty_tile_num++;\n\t\t\t\t\t}else if(str.charAt(j-1)=='o'){\n\t\t\t\t\t\tstart = new Tilemap(j, i, 0, -1);\n\t\t\t\t\t\ttile[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart.dirty_tile_num = dirty_tile_num;\n\t\t\tq.offer(start);\n\n\t\t\tint move = -1;\n\t\t\tint[][] map = new int[h+2][w+2];\n\t\t\tfor(int i=0; i<tile.length; i++){\n\t\t\t\tmap[i] = tile[i].clone();\n\t\t\t}\n\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tTilemap xy = q.poll();\n\t\t\t\tint x = xy.x, y = xy.y;\n\t\t\t\txy.count++;\n\t\t\t\tif(map[y][x]==2){\n\t\t\t\t\txy.dirty_tile_num--;\n\t\t\t\t\tif(xy.dirty_tile_num==0){\n\t\t\t\t\t\tmove = xy.count;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tq.clear();\n\t\t\t\t\ttile[y][x] = 1;\n\t\t\t\t\tfor(int i=0; i<tile.length; i++){\n\t\t\t\t\t\tmap[i] = tile[i].clone();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tmap[y][x] = 0;\n\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tif(map[y+dy[i]][x+dx[i]]!=0){\n\t\t\t\t\t\tTilemap temp = new Tilemap(x+dx[i], y+dy[i], xy.dirty_tile_num, xy.count);\n\t\t\t\t\t\tq.offer(temp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(move);\n\n\t\t\tq.clear();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int w,h,startx,starty;\n\tstatic int[][]field;\n\tstatic int[][]kyori;\n\tstatic List<int[]> list;\n\tstatic byte[] v1={1,0,-1,0};\n\tstatic byte[] v2={0,-1,0,1};\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tlabel:while(true){\n\t\t\tw=cin.nextInt();\n\t\t\th=cin.nextInt();\n\t\t\tif(w+h==0)break;\n\t\t\tfield=new int[h+2][w+2];\n\t\t\tlist=new ArrayList<int[]>();\n\t\t\tint cnt=0;\n\t\t\tfor(int i=0;i<=h+1;i++){\n\t\t\t\tArrays.fill(field[i], -1);\n\t\t\t}\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tchar[] s=cin.next().toCharArray();\n\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\tif(s[j-1]=='.'){\n\t\t\t\t\t\tfield[i][j]=-2;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s[j-1]=='x'){\n\t\t\t\t\t\tfield[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s[j-1]=='*'){\n\t\t\t\t\t\tfield[i][j]=++cnt;\n\n\t\t\t\t\t\tlist.add(new int[]{i,j});\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tfield[i][j]=0;\n\t\t\t\t\t\tstartx=i;\n\t\t\t\t\t\tstarty=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tfor(int j=1;j<=w;j++){\n//\t\t\t\t\tSystem.out.print(field[i][j]);\n\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t//0,0がスタート地点\n\t\t\tkyori=new int[cnt+1][cnt+1];\n\t\t\ta(startx,starty,0);\n\t\t\tcnt=1;\n\t\t\tint[][] b=new int[list.size()][2];\n\t\t\tfor(int i=0;i<list.size();i++){\n\t\t\t\tint[] array=list.get(i);\n\t\t\t\tb[i][0]=array[0];\n\t\t\t\tb[i][1]=array[1];\n\t\t\t}\n\t\t\tlist=null;\n\t\t\tfor(int i=0;i<b.length;i++){\n\t\t\t\ta(b[i][0],b[i][1],cnt++);\n\t\t\t}\n\t\t\tfor(int i=0;i<kyori[0].length;i++){\n\t\t\t\tfor(int j=0;j<kyori[0].length;j++){\n\t\t\t\t\tif(i==j)continue;\n\t\t\t\t\tif(kyori[i][j]==0){\n\t\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\t\tcontinue label;\n\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println(i+\" \"+j+\" \"+kyori[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum=0;\n\t\t\tans=1<<30;\n\t\t\talready=new boolean[kyori[0].length];\n\t\t\tArrays.fill(already, false);\n\t\t\tbt(0,0);\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tstatic int sum,ans;\n\tstatic boolean[] already;\n\tstatic void bt(int a,int step){\n//\t\tSystem.out.println(a+\" \"+step+\" \"+sum);\n\t\t\n\t\tif(ans<=sum)return;\n\t\tif(step==kyori[0].length-1){\n\t\t\tans=Math.min(ans,sum);\n\t\t}\n\t\talready[a]=true;\n\t\tfor(int i=0;i<kyori[0].length;i++){\n\t\t\tif(a==i)continue;\n\t\t\tif(kyori[a][i]==0)continue;\n\t\t\tif(already[i])continue;\n\t\t\tint tmp=kyori[a][i];\n\t\t\tkyori[a][i]=kyori[i][a]=0;\n\t\t\talready[i]=true;\n\t\t\tsum+=tmp;\n\t\t\tbt(i,step+1);\n\t\t\tkyori[a][i]=kyori[i][a]=tmp;\n\t\t\tsum-=tmp;\n\t\t\talready[i]=false;\n\t\t}\n\t\talready[a]=false;\n\t}\n\tstatic void a(int x,int y,int cnt){\n\t\tint[][] f=new int[h+2][w+2];\n\t\tfor(int i=0;i<h+2;i++){\n\t\t\tfor(int j=0;j<w+2;j++){\n\t\t\t\tf[i][j]=field[i][j];\n\t\t\t}\n\t\t}\n\t\tQueue<byte[]> q=new LinkedList<byte[]>();\n\t\tq.add(new byte[]{(byte)x,(byte)y});\n\t\tint steps=0;\n\t\t\n\t\twhile(!q.isEmpty()){\n\t\t\tint size=q.size();\n\t\t\tfor(int i=0;i<size;i++){\n\t\t\t\tbyte[] aaa=q.poll();\n\t\t\t\tbyte xx=aaa[0];\n\t\t\t\tbyte yy=aaa[1];\n\t\t\t\tif(f[xx][yy]==-1)continue;\n\t\t\t\tif(f[xx][yy]>=0){\n\t\t\t\t\tkyori[cnt][f[xx][yy]]=steps;kyori[f[xx][yy]][cnt]=steps;\n\t\t\t\t}\n\t\t\t\tf[xx][yy]=-1;\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tbyte x1=(byte) ((byte)xx+v1[j]);\n\t\t\t\t\tbyte y1=(byte) ((byte)yy+v2[j]);\n\t\t\t\t\tif(f[x1][y1]==-1)continue;\n\t\t\t\t\tq.add(new byte[]{x1,y1});\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tsteps++;\n\t\t}\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int w,h,startx,starty;\n\tstatic int[][]field,kyori;\n\tstatic List<int[]> list;\n\tstatic byte[] v1={1,0,-1,0};\n\tstatic byte[] v2={0,-1,0,1};\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tlabel:while(true){\n\t\t\tw=cin.nextInt();\n\t\t\th=cin.nextInt();\n\t\t\tif(w+h==0)break;\n\t\t\tfield=new int[h+2][w+2];\n\t\t\tlist=new ArrayList<int[]>();\n\t\t\tint cnt=0;\n\t\t\tfor(int i=0;i<=h+1;i++){\n\t\t\t\tArrays.fill(field[i], -1);\n\t\t\t}\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tchar[] s=cin.next().toCharArray();\n\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\tif(s[j-1]=='.'){\n\t\t\t\t\t\tfield[i][j]=-2;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s[j-1]=='x'){\n\t\t\t\t\t\tfield[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s[j-1]=='*'){\n\t\t\t\t\t\tfield[i][j]=++cnt;\n\n\t\t\t\t\t\tlist.add(new int[]{i,j});\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tfield[i][j]=0;\n\t\t\t\t\t\tstartx=i;\n\t\t\t\t\t\tstarty=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tfor(int j=1;j<=w;j++){\n//\t\t\t\t\tSystem.out.print(field[i][j]);\n\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t//0,0がスタート地点\n\t\t\tkyori=new int[cnt+1][cnt+1];\n\t\t\ta(startx,starty,0);\n\t\t\tcnt=1;\n\t\t\tfor(int[] a:list){\n\t\t\t\ta(a[0],a[1],cnt++);\n\t\t\t}\n\t\t\tfor(int i=0;i<kyori[0].length;i++){\n\t\t\t\tfor(int j=0;j<kyori[0].length;j++){\n\t\t\t\t\tif(i==j)continue;\n\t\t\t\t\tif(kyori[i][j]==0){\n\t\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\t\tcontinue label;\n\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println(i+\" \"+j+\" \"+kyori[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum=0;\n\t\t\tans=1<<30;\n\t\t\tbt(0,0);\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tstatic int sum,ans;\n\tstatic void bt(int a,int step){\n//\t\tSystem.out.println(a+\" \"+step+\" \"+sum);\n\t\tif(ans<=sum)return;\n\t\tif(step==kyori[0].length-1){\n\t\t\tans=Math.min(ans,sum);\n\t\t}\n\t\tfor(int i=0;i<kyori[0].length;i++){\n\t\t\tif(a==i)continue;\n\t\t\tif(kyori[a][i]==0)continue;\n\t\t\tint tmp=kyori[a][i];\n\t\t\tkyori[a][i]=kyori[i][a]=0;\n\t\t\tsum+=tmp;\n\t\t\tbt(i,step+1);\n\t\t\tkyori[a][i]=kyori[i][a]=tmp;\n\t\t\tsum-=tmp;\n\t\t}\n\t}\n\tstatic void a(int x,int y,int cnt){\n\t\tint[][] f=new int[h+2][w+2];\n\t\tfor(int i=0;i<h+2;i++){\n\t\t\tfor(int j=0;j<w+2;j++){\n\t\t\t\tf[i][j]=field[i][j];\n\t\t\t}\n\t\t}\n\t\tQueue<byte[]> q=new LinkedList<byte[]>();\n\t\tq.add(new byte[]{(byte)x,(byte)y});\n\t\tint steps=0;\n\t\t\n\t\twhile(!q.isEmpty()){\n\t\t\tint size=q.size();\n\t\t\tfor(int i=0;i<size;i++){\n\t\t\t\tbyte[] aaa=q.poll();\n\t\t\t\tbyte xx=aaa[0];\n\t\t\t\tbyte yy=aaa[1];\n\t\t\t\tif(f[xx][yy]>=0){\n\t\t\t\t\tkyori[cnt][f[xx][yy]]=steps;\n\t\t\t\t}\n\t\t\t\tf[xx][yy]=-1;\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tbyte x1=(byte) ((byte)xx+v1[j]);\n\t\t\t\t\tbyte y1=(byte) ((byte)yy+v2[j]);\n\t\t\t\t\tif(f[x1][y1]==-1)continue;\n\t\t\t\t\tq.add(new byte[]{x1,y1});\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tsteps++;\n\t\t}\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tstatic Deque<Tilemap> q = new ArrayDeque<Tilemap>();\n\tstatic int[] dx = {1, 0, -1, 0};\n\tstatic int[] dy = {0, 1, 0, -1};\n\n\tpublic static class Tilemap{\n\t\tint x, y;\n\t\tint dirty_tile_num;\n\t\tint count;\n\t\tTilemap(int j, int i, int d, int c){\n\t\t\tx = j;\n\t\t\ty = i;\n\t\t\tdirty_tile_num = d;\n\t\t\tcount = c;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] tile = new int[20+2][20+2];\n\t\tint[][] map = new int[20+2][20+2];\n\t\tTilemap start = new Tilemap(0, 0, 0, 0);\n\t\tTilemap xy = new Tilemap(0, 0, 0, 0);\n\t\tint w, h, dirty_tile_num, move, x, y;\n\t\tString str;\n\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w==0&&h==0) break;\n\t\t\tdirty_tile_num = 0;\n\n\t\t\tfor(int i=1; i<=h; i++){\n\t\t\t\tstr = sc.next();\n\t\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\t\tif(str.charAt(j-1)=='.'){\n\t\t\t\t\t\ttile[i][j] = 1;\n\t\t\t\t\t}else if(str.charAt(j-1)=='*'){\n\t\t\t\t\t\ttile[i][j] = 2;\n\t\t\t\t\t\tdirty_tile_num++;\n\t\t\t\t\t}else if(str.charAt(j-1)=='o'){\n\t\t\t\t\t\tstart = new Tilemap(j, i, 0, -1);\n\t\t\t\t\t\ttile[i][j] = 1;\n\t\t\t\t\t}else if(str.charAt(j-1)=='x'){\n\t\t\t\t\t\ttile[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttile[i][w+1] = 0;\n\t\t\t}\n\t\t\tArrays.fill(tile[h+1], 0);\n\t\t\tstart.dirty_tile_num = dirty_tile_num;\n\t\t\tq.offer(start);\n\n\t\t\tmove = -1;\n\t\t\tfor(int i=0; i<=w+1; i++){\n\t\t\t\tmap[i] = tile[i].clone();\n\t\t\t}\n\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\txy = q.poll();\n\t\t\t\tx = xy.x; y = xy.y;\n\t\t\t\txy.count++;\n\t\t\t\tif(map[y][x]==2){\n\t\t\t\t\txy.dirty_tile_num--;\n\t\t\t\t\tif(xy.dirty_tile_num==0){\n\t\t\t\t\t\tmove = xy.count;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tq.clear();\n\t\t\t\t\ttile[y][x] = 1;\n\t\t\t\t\tfor(int i=0; i<=w+1; i++){\n\t\t\t\t\t\tmap[i] = tile[i].clone();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tmap[y][x] = 0;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tif(map[y+dy[i]][x+dx[i]]!=0){\n\t\t\t\t\t\tq.offer(new Tilemap(x+dx[i], y+dy[i], xy.dirty_tile_num, xy.count));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(move);\n\t\t\tq.clear();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.Point;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w == 0 && h == 0) break;\n\n\t\t\tt = new char[h][w];\n\n\t\t\ttrash = new HashMap<Point,Integer>();\n\t\t\tint count = 1;\n\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tt[i] = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(t[i][j] == 'o'){\n\t\t\t\t\t\ttrash.put(new Point(j,i),0);\n\t\t\t\t\t}\n\t\t\t\t\telse if(t[i][j] == '*'){\n\t\t\t\t\t\ttrash.put(new Point(j,i),count++);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmap = new int[count][count];\n\t\t\tfor(int[] tmp : map) Arrays.fill(tmp,-1);\n\t\t\tfor(Point start : trash.keySet()){\n\t\t\t\tsetMinCost(start);\n\t\t\t}\n\n\t\t\tans = Integer.MAX_VALUE;\n\t\t\tsolve(new boolean[count],0,0,count-1);\n\t\t\tSystem.out.println(ans == Integer.MAX_VALUE ? -1 : ans);\n\t\t}\n\t}\n\n\tprivate static HashMap<Point,Integer> trash;\n\tprivate static int[][] map;\n\tprivate static char[][] t;\n\tprivate static int dx[] = {0,0,1,-1};\n\tprivate static int dy[] = {1,-1,0,0};\n\tprivate static int ans;\n\n\tprivate static void solve(boolean[] used,int now,int cost,int rem){\n\t\tif(rem == 0){\n\t\t\tans = Math.min(ans,cost);\n\t\t\treturn;\n\t\t}\n\n\t\tused[now] = true;\n\t\tfor(int i=1;i<map.length;i++){\n\t\t\tif(map[now][i] != -1 && !used[i]){\n\t\t\t\tsolve(used,i,cost+map[now][i],rem-1);\n\t\t\t}\n\t\t}\n\t\tused[now] = false;\n\n\t\treturn;\n\t}\n\n\tprivate static void setMinCost(Point p){\n\t\tPriorityQueue<State> open = new PriorityQueue<State>();\n\t\tHashSet<State> closed = new HashSet<State>();\n\n\t\topen.add(new State(p,0));\n\n\t\twhile(!open.isEmpty()){\n\t\t\tState st = open.poll();\n\t\t\tif(closed.contains(st)) continue;\n\t\t\tclosed.add(st);\n\n\t\t\tPoint tmp = st.p;\n\n\t\t\tif(t[tmp.y][tmp.x] == 'o' || t[tmp.y][tmp.x] == '*'){\n\t\t\t\tmap[trash.get(p)][trash.get(tmp)] = st.cost;\n\t\t\t}\n\n\t\t\topen.addAll(st.nexts());\n\t\t}\n\t}\n\n\tprivate static class State implements Comparable<State>{\n\t\tPoint p;\n\t\tint cost;\n\n\t\tState(Point p,int cost){\n\t\t\tthis.p = new Point(p.x,p.y);\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\tList<State> nexts(){\n\t\t\tList<State> sts = new ArrayList<State>();\n\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx = p.x + dx[i];\n\t\t\t\tint ny = p.y + dy[i];\n\n\t\t\t\tif(nx >= 0 && nx < t[0].length && ny >= 0 && ny < t.length && t[ny][nx] != 'x'){\n\t\t\t\t\tsts.add(new State(new Point(nx,ny),cost+1));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn sts;\n\t\t}\n\n\t\tpublic int compareTo(State st){\n\t\t\treturn this.cost - st.cost;\n\t\t}\n\n\t\tpublic boolean equals(Object o){\n\t\t\tState st = (State)o;\n\t\t\treturn p.x == st.p.x && p.y == st.p.y;\n\t\t}\n\n\t\tpublic int hashCode(){\n\t\t\treturn p.x + 1000 * p.y;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tstatic Deque<Tilemap> q = new ArrayDeque<Tilemap>();\n\tstatic int[] dx = {1, 0, -1, 0};\n\tstatic int[] dy = {0, 1, 0, -1};\n\n\tpublic static class Tilemap{\n\t\tint x, y;\n\t\tint dirty_tile_num;\n\t\tint count;\n\t\tTilemap(int j, int i, int d, int c){\n\t\t\tx = j;\n\t\t\ty = i;\n\t\t\tdirty_tile_num = d;\n\t\t\tcount = c;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] tile = new int[20+2][20+2];\n\t\tint[][] map = new int[20+2][20+2];\n\t\tTilemap start = new Tilemap(0, 0, 0, 0);\n\t\tTilemap xy = new Tilemap(0, 0, 0, 0);\n\t\tint w, h, dirty_tile_num, move, x, y;\n\t\tString str;\n\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w==0&&h==0) break;\n\t\t\tdirty_tile_num = 0;\n\n\t\t\tfor(int i=1; i<=h; i++){\n\t\t\t\tstr = sc.next();\n\t\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\t\tif(str.charAt(j-1)=='.'){\n\t\t\t\t\t\ttile[i][j] = 1;\n\t\t\t\t\t}else if(str.charAt(j-1)=='*'){\n\t\t\t\t\t\ttile[i][j] = 2;\n\t\t\t\t\t\tdirty_tile_num++;\n\t\t\t\t\t}else if(str.charAt(j-1)=='o'){\n\t\t\t\t\t\tstart = new Tilemap(j, i, 0, -1);\n\t\t\t\t\t\ttile[i][j] = 1;\n\t\t\t\t\t}else if(str.charAt(j-1)=='x'){\n\t\t\t\t\t\ttile[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttile[i][w+1] = 0;\n\t\t\t}\n\t\t\tArrays.fill(tile[h+1], 0);\n\t\t\tstart.dirty_tile_num = dirty_tile_num;\n\t\t\tq.offer(start);\n\n\t\t\tmove = -1;\n\t\t\tfor(int i=0; i<=h+1; i++){\n\t\t\t\tmap[i] = tile[i].clone();\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\txy = q.poll();\n\t\t\t\tx = xy.x; y = xy.y;\n\t\t\t\txy.count++;\n\t\t\t\tif(map[y][x]==2){\n\t\t\t\t\txy.dirty_tile_num--;\n\t\t\t\t\tif(xy.dirty_tile_num==0){\n\t\t\t\t\t\tmove = xy.count;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tq.clear();\n\t\t\t\t\ttile[y][x] = 1;\n\t\t\t\t\tfor(int i=0; i<=w+1; i++){\n\t\t\t\t\t\tmap[i] = tile[i].clone();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmap[y][x] = 0;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tif(map[y+dy[i]][x+dx[i]]!=0){\n\t\t\t\t\t\tq.offer(new Tilemap(x+dx[i], y+dy[i], xy.dirty_tile_num, xy.count));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(move);\n\t\t\tq.clear();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint cnt, min;\n\tint[][] cost;\n\t\n\tvoid check(int[] perm){\n\t\tint sum = 0;\n\t\tfor(int i=0;i<cnt-1;i++) sum += cost[perm[i]][perm[i+1]];\n\t\tmin = Math.min(min, sum);\n\t}\n\t\n\tvoid makeperm(int k, int[] perm, boolean[] flag){\n\t\tif(k==cnt){\n\t\t\tcheck(perm);\n\t\t}else{\n\t\t\tfor(int i=1;i<cnt;i++){\n\t\t\t\tif(flag[i]==true) continue;\n\t\t\t\tperm[k] = i;\n\t\t\t\tflag[i] = true;\n\t\t\t\tmakeperm(k+1, perm, flag);\n\t\t\t\tflag[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w==0 && h==0) break;\n\t\t\t\n\t\t\tchar[][] map = new char[h][w];\n\t\t\tint[] x = new int[11];\n\t\t\tint[] y = new int[11];\n\t\t\tcnt = 1;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tchar t = s.charAt(j);\n\t\t\t\t\tif(t=='o'){\n\t\t\t\t\t\tx[0] = j;\n\t\t\t\t\t\ty[0] = i;\n\t\t\t\t\t}else if(t=='*'){\n\t\t\t\t\t\tx[cnt] = j;\n\t\t\t\t\t\ty[cnt] = i;\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t\tmap[i][j] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcost = new int[cnt][cnt];\n\t\t\tint[] xx = new int[]{0,0,1,-1};\n\t\t\tint[] yy = new int[]{1,-1,0,0};\n\t\t\tboolean f = false;\n\t\t\tfor(int i=0;i<cnt;i++){\n\t\t\t\tfor(int j=i+1;j<cnt;j++){\n\t\t\t\t\tArrayDeque<Integer> p = new ArrayDeque<Integer>();\n\t\t\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\t\t\tint[][] c = new int[h][w];\n\t\t\t\t\tfor(int s=0;s<h;s++){\n\t\t\t\t\t\tfor(int t=0;t<w;t++) c[s][t] = Integer.MAX_VALUE;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tp.offer(x[i]);\n\t\t\t\t\tq.offer(y[i]);\n\t\t\t\t\tc[y[i]][x[i]] = 0;\n\t\t\t\t\twhile(p.size()!=0){\n\t\t\t\t\t\tint u = p.poll();\n\t\t\t\t\t\tint v = q.poll();\n\t\t\t\t\t\tif(u==x[j] && v==y[j]) break;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int s=0;s<4;s++){\n\t\t\t\t\t\t\tif(0<=u+xx[s] && u+xx[s]<w && 0<=v+yy[s] && v+yy[s]<h){\n\t\t\t\t\t\t\t\tif(map[v+yy[s]][u+xx[s]]!='x' && c[v][u]+1<c[v+yy[s]][u+xx[s]]){\n\t\t\t\t\t\t\t\t\tp.offer(u+xx[s]);\n\t\t\t\t\t\t\t\t\tq.offer(v+yy[s]);\n\t\t\t\t\t\t\t\t\tc[v+yy[s]][u+xx[s]] = c[v][u]+1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(c[y[j]][x[j]]==Integer.MAX_VALUE){\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcost[i][j] = cost[j][i] = c[y[j]][x[j]];\n\t\t\t\t}\n\t\t\t\tif(f==true) break;\n\t\t\t}\n\t\t\t\n\t\t\tif(f==false){\n\t\t\t\tmin = Integer.MAX_VALUE;\n\t\t\t\tmakeperm(1, new int[cnt], new boolean[cnt]);\n\t\t\t\tSystem.out.println(min);\n\t\t\t}else{\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t}\t\n\t}\n\t\t\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Math.*;\nimport static java.lang.System.*;\n\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Scanner;\n\nclass Main {\n    public static Random rand=new Random();\n    static  final  int INF=1<<29;\n\n\n    class P{\n    \tint x,y;\n    \tP(int _x,int _y){\n    \t\tx=_x;y=_y;\n    \t}\n    }\n\n    int[] dirx=new int[]{1,0,-1,0};\n    int[] diry=new int[]{0,1,0,-1};\n\n    int getDist(int i,int j){\n    \tP _p=new P(dx[i],dy[i]);\n    \tQueue<P> que=new LinkedList<P>();\n    \tque.add(_p);\n    \tint d=0;\n    \tboolean[][] passed=new boolean[h][w];\n\t\tpassed[_p.y][_p.x]=true;\n    \twhile(!que.isEmpty()){\n    \t\tQueue<P> tmp=new LinkedList<P>();\n    \t   \twhile(!que.isEmpty()){\n        \t\tP p=que.poll();\n        \t\tfor(int k=0;k<4;k++){\n        \t\t\tint nx=p.x+dirx[k],ny=p.y+diry[k];\n        \t\t\tif(0<=nx && nx<w && 0<=ny && ny<h){\n        \t\t\t\tif(map[ny][nx]=='x')continue;\n        \t\t\t\tif(nx==dx[j] && ny==dy[j])return d+1;\n        \t\t\t\tif(!passed[ny][nx]){\n        \t\t\t\t\ttmp.add(new P(nx,ny));\n        \t\t\t\t\tpassed[ny][nx]=true;\n        \t\t\t\t}\n        \t\t\t}\n        \t\t}\n    \t   \t}\n    \t\tque=tmp;\n    \t\td++;\n    \t}\n    \treturn INF;\n    }\n\n    // O(n^3) n≦100\n \tstatic void warshall_floyd(int[][] d){\n \t\tint n=d.length;\n \t    for(int k=0;k<n;k++)\n \t    \tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)\n \t    \t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n \t}\n\n\n\tchar[][] map;\n\tint[] dx,dy;\n\tint h,w;\n    public void run() {\n        Case:while(true){\n        \tw=sc.nextInt();h=sc.nextInt();\n        \tif(h==0 && w==0)return;\n\n        \tmap=new char[h][w];\n        \tfor(int y=0;y<h;y++)\n        \t\tmap[y]=sc.next().toCharArray();\n\n        \tint D=0;\n        \tfor(int y=0;y<h;y++)for(int x=0;x<w;x++)\n        \t\tif(map[y][x]=='*')D++;\n        \tdx=new int[D+1];dy=new int[D+1];\n        \tint ind=0;\n        \tfor(int y=0;y<h;y++)for(int x=0;x<w;x++)if(map[y][x]=='o'){\n    \t\t\tdx[ind]=x;\n    \t\t\tdy[ind]=y;\n    \t\t\tind++;\n        \t}\n        \tfor(int y=0;y<h;y++)for(int x=0;x<w;x++)if(map[y][x]=='*'){\n    \t\t\tdx[ind]=x;\n    \t\t\tdy[ind]=y;\n    \t\t\tind++;\n        \t}\n        \tint[][] ds=new int[D+1][D+1];\n        \tfor(int i=0;i<D+1;i++)Arrays.fill(ds[i],INF);\n        \tfor(int i=0;i<D+1;i++)ds[i][i]=0;\n        \tfor(int i=0;i<D+1;i++)for(int j=0;j<D+1;j++)\n        \t\tif(i!=j)ds[i][j]=getDist(i,j);\n\n        \twarshall_floyd(ds);\n\n        \tint[][] dp=new int[D+1][1<<(D+1)];\n        \tfor(int i=0;i<D+1;i++)\n        \t\tArrays.fill(dp[i],INF);\n        \tdp[0][1]=0;\n        \tfor(int i=1;i<(1<<(D+1));i++){\n        \t\tfor(int pos=1;pos<D+1;pos++){\n        \t\t\tif(((i>>pos) & 1) ==0)continue;\n        \t\t\tint mv=INF;\n        \t\t\tfor(int prev=0;prev<D+1;prev++){\n        \t\t\t\tif(((i>>prev) & 1)==1 && pos!=prev)\n        \t\t\t\t\tif(mv>dp[prev][i-(1<<pos)]+ds[prev][pos])\n        \t\t\t\t\t\tmv=dp[prev][i-(1<<pos)]+ds[prev][pos];\n         \t\t\t}\n        \t\t\tdp[pos][i]=mv;\n        \t\t}\n        \t}\n        \tint mv=INF;\n        \tfor(int i=1;i<D+1;i++)mv=min(mv,dp[i][(1<<(D+1))-1]);\n        \tif(mv<INF)\n        \t\tln(mv);\n        \telse\n        \t\tln(-1);\n        }\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n\tstatic Scanner sc=new Scanner(in);\n\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n\tstatic String str(double o){\n\t\treturn String.format(\"%.8f\",o);\n\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\tClass<?> c=o.getClass();\n\t\tif(c.equals(Boolean.class))return str((boolean)o);\n\t\tif(c.equals(Double.class))return str((double)o);\n\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\n//using System.Numerics;\nusing Number = System.Int64;\n//using static System.Math;\n//using static MathEx;\n//using P = System.Collections.Generic.KeyValuePair<int, int>;\n\n\nnamespace Program\n{\n    public class Solver\n    {\n\n\n        public void Solve()\n        {\n            for (;;)\n            {\n                var w = sc.Integer();\n                var h = sc.Integer();\n                if (w == 0) return;\n                var mat = Enumerate(h, x => sc.Char(w));\n                var n = w * h;\n                var g = Enumerate(n, x => new int[n]);\n                for (int i = 0; i < n; i++)\n                    for (int j = i + 1; j < n; j++)\n                    {\n                        g[i][j] = g[j][i] = 100000000;\n                    }\n                var s = -1;\n                int[] dx = { 1, 0, -1, 0 };\n                int[] dy = { 0, 1, 0, -1 };\n                var p = new List<int>();\n                for (int i = 0; i < h; i++)\n                    for (int j = 0; j < w; j++)\n                    {\n                        if (mat[i][j] == 'o') s = i * w + j;\n                        if (mat[i][j] == '*') p.Add(i * w + j);\n                        if (mat[i][j] == 'x') continue;\n                        for (int k = 0; k < 4; k++)\n                        {\n                            var nx = i + dx[k];\n                            var ny = j + dy[k];\n                            if (nx < 0 || nx >= h || ny < 0 || ny >= w) continue;\n                            if (mat[nx][ny] == 'x') continue;\n                            g[i * w + j][nx * w + ny] = 1;\n                        }\n                    }\n                for (int k = 0; k < n; k++)\n                    for (int i = 0; i < n; i++)\n                        for (int j = 0; j < n; j++)\n                            g[i][j] = Math.Min(g[i][j], g[i][k] + g[k][j]);\n                p.Add(s); p.Reverse();\n                var m = p.Count;\n                var gg = Enumerate(m, x => new int[m]);\n                for (int i = 0; i < m; i++)\n                    for (int j = 0; j < m; j++)\n                        gg[i][j] = g[p[i]][p[j]];\n                subsolve(gg);\n            }\n        }\n        void subsolve(int[][] g)\n        {\n            var n = g.Length;\n            var dp = Enumerate(1 << n, x => new int[n]);\n            for (int i = 0; i < 1 << n; i++)\n                for (int j = 0; j < n; j++)\n                    dp[i][j] = 100000000;\n            dp[1][0] = 0;\n            for (int i = 0; i < 1 << n; i++)\n                for (int j = 0; j < n; j++)\n                {\n                    if (dp[i][j] == 100000000) continue;\n                    for (int k = 0; k < n; k++)\n                        dp[i | 1 << k][k] = Math.Min(dp[i | 1 << k][k], dp[i][j] + g[j][k]);\n                }\n            var min = 100000000;\n            for (int i = 0; i < n; i++)\n                min = Math.Min(min, dp[(1 << n) - 1][i]);\n            if (min == 100000000) min = -1;\n            IO.Printer.Out.WriteLine(min);\n        }\n        /*\n        int ri => sc.Integer();\n        long rl => sc.Long();\n        double rd => sc.Double();\n        string rs => sc.Scan();\n        char rc => sc.Char();\n\n        [System.Diagnostics.Conditional(\"DEBUG\")]\n        void put(params object[] a) => Debug.WriteLine(string.Join(\" \", a));\n\n        //*/\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static void Swap<T>(ref T a, ref T b)\n        {\n            var tmp = a;\n            a = b;\n            b = tmp;\n        }\n    }\n}\n\n#region main\n\nstatic class Ex\n{\n    //public static string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n\n    //public static string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n\n    public static void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n\n#endregion\n#region Ex\n\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter\n    {\n        static Printer()\n        {\n            Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false };\n        }\n\n        public static Printer Out { get; set; }\n\n        public override IFormatProvider FormatProvider\n        {\n            get { return CultureInfo.InvariantCulture; }\n        }\n\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true))\n        {\n        }\n\n        public Printer(Stream stream, Encoding encoding) : base(stream, encoding)\n        {\n        }\n\n        public void Write<T>(string format, T[] source)\n        {\n            base.Write(format, source.OfType<object>().ToArray());\n        }\n\n        public void WriteLine<T>(string format, T[] source)\n        {\n            base.WriteLine(format, source.OfType<object>().ToArray());\n        }\n    }\n\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream)\n        {\n            str = stream;\n        }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof;\n\n        public bool IsEndOfStream\n        {\n            get { return isEof; }\n        }\n\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr < len) return buf[ptr++];\n            ptr = 0;\n            if ((len = str.Read(buf, 0, 1024)) > 0) return buf[ptr++];\n            isEof = true;\n            return 0;\n        }\n\n        public char Char()\n        {\n            byte b;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0;\n            byte b;\n            var ng = false;\n            do b = read(); while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-')\n            {\n                ng = true;\n                b = read();\n            }\n            for (; ; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                ret = ret * 10 + b - '0';\n            }\n        }\n\n        public int Integer()\n        {\n            return (isEof) ? int.MinValue : (int)Long();\n        }\n\n        public double Double()\n        {\n            var s = Scan();\n            return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN;\n        }\n\n        static T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n)\n        {\n            return enumerate(n, Char);\n        }\n\n        public string[] Scan(int n)\n        {\n            return enumerate(n, Scan);\n        }\n\n        public double[] Double(int n)\n        {\n            return enumerate(n, Double);\n        }\n\n        public int[] Integer(int n)\n        {\n            return enumerate(n, Integer);\n        }\n\n        public long[] Long(int n)\n        {\n            return enumerate(n, Long);\n        }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "JavaScript",
    "code": "function BFS(X,Y){\n   var dx=[0,-1,1,0];\n   var dy=[-1,0,0,1];\n   var cnt=0;\n   var bfs=[[X,Y,cnt,0,YX]];\n   var obj={};\n   obj[X+\" \"+Y+\" \"+0+\" \"+YX.join(\"\")]=true;\n   while(true){\n      if(bfs.length==0){cnt=-1;break;}\n      var leaf=bfs.shift();\n      var x=leaf[0];\n      var y=leaf[1];\n      var c=leaf[2];\n      var d=leaf[3];\n      if(d==dust){cnt=c;break;}\n      var yx=leaf[4];\n      for(var i=0;i<4;i++){\n         var xx=x+dx[i];\n         var yy=y+dy[i];\n         var dd=d;\n         if(xx<0 || yy<0 || xx>=wh[0] || yy>=wh[1])continue;\n         if(yx[yy][xx]==\"x\")continue;\n         if(obj.hasOwnProperty(xx+\" \"+yy+\" \"+d+\" \"+yx.join(\"\")))continue;\n         obj[xx+\" \"+yy+\" \"+d+\" \"+yx.join(\"\")]=true;\n         var copy=yx.map(function(v){return v.slice();});\n         if(copy[yy][xx]==\"*\"){\n            copy[yy][xx]=\".\";\n            dd++;\n         }\n         bfs.push([xx,yy,c+1,dd,copy]);\n      }\n   }\n   return cnt;\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\nwhile(true){\n   var wh=Arr.shift().split(\" \").map(Number);\n   if(wh[0]==0 && wh[1]==0)break;\n   var YX=[];\n   var start=[];\n   var dust=0;\n   for(var i=0;i<wh[1];i++){\n      var arr=(Arr.shift()).split(\"\");\n      if(arr.indexOf(\"o\")!=-1)start=[arr.indexOf(\"o\"),i];\n      arr.forEach(function(v){if(v==\"*\")dust++;});\n      YX.push(arr);\n   }\n   var ans=BFS(start[0],start[1]);\n   console.log(ans);\n}"
  },
  {
    "language": "Ruby",
    "code": "INF = 10000\n$dx = [1,0,-1,0]\n$dy = [0,1,0,-1]\n$dp = []\n$n = 100\n\ndef bfs(pos,queue,bb) \n\twhile(not queue.empty?) do\n\t\tpos = queue.shift\n\t\tcnt = bb[pos[0]][pos[1]]\n\t\tnpos = []\n\t\t4.times{|i|\n\t\t\tnpos[0] = pos[0] + $dy[i]\n\t\t\tnpos[1] = pos[1] + $dx[i]\n\t\t\tif ((0..$h-1).include?(npos[0]) and (0..$w-1).include?(npos[1])) then\n\t\t\t\tif ($b[npos[0]][npos[1]] == 0 and bb[npos[0]][npos[1]] == -1) then\n\t\t\t\t\tbb[npos[0]][npos[1]] = cnt + 1\n\t\t\t\t\tqueue.push([npos[0],npos[1]])\n\t\t\t\tend\n\t\t\tend\n\t\t}\n\tend\nend\n\ndef rec(s,v)\n\tif $dp[s][v] >= 0 then\n\t\treturn $dp[s][v]\n\tend\n\t\n\tif ( s == ((1 << $n) -1)) then\n\t\treturn $dp[s][v] = $dist[0][v+1]\n\tend\n\t\n\tres = INF\n\t$n.times{|u|\n\t\tif ((s >> u & 1) == 0) then\n\t\t\t\n\t\t\ttmp = (rec(s | 1 << u,u) + $dist[v+1][u+1] )\n\t\t\tif tmp < res then\n\t\t\t\tres = tmp\n\t\t\tend\n\t\tend\n\t}\n\t\n\treturn $dp[s][v] = res\nend\n\nloop{\n\n\t$w,$h =gets.split.map(&:to_i)\n\tif ($w==0 and $h == 0) then\n\t\tbreak\n\tend\n\t$b = Array.new($h).map{Array.new($w)}\n\td = Array.new()\n\tdcost = Array.new()\n\ts = Array.new(2)\n\t\n\t$h.times{|hh|\n\t\t$b[hh] = gets.chomp.chars.each_with_index.map{|c,i|\n\t\t\tcase c \n\t\t\twhen '.'\n\t\t\t\t0\n\t\t\twhen '*'\n\t\t\t\td.push([hh,i])\n\t\t\t\t0\n\t\t\twhen 'o'\n\t\t\t\ts = [hh,i]\n\t\t\t\t0\n\t\t\telse\n\t\t\t\t-100\n\t\t\tend\n\t\t}\n\t}\n\tbb = Array.new($h).map{Array.new($w,-1)}\n\tqueue = []\n\tqueue.push(s)\n\tbb[s[0]][s[1]] = 0\n\tbfs(s,queue,bb)\n\n\tflag = true\n\t\n\tdsize = d.size()\n\t$n = dsize\n\t$dist = Array.new(dsize+1).map{Array.new(dsize+1,-1)}\n\t$dist[0][0] = 0\n\td.each_with_index{|pos,i|\n\t\t$dist[0][i+1] = bb[pos[0]][pos[1]]\n\t\t$dist[i+1][0] = bb[pos[0]][pos[1]]\n\t\t\n\t\tif bb[pos[0]][pos[1]] == -1 then\n\t\t\tflag = false\n\t\tend\n\t}\n\t\n\tif (!flag) then\n\t\tprint \"-1\\n\"\n\t\tnext\n\tend\n\t\n\t\n\n\td.each_with_index{|pos,i|\n\t\tbb = Array.new($h).map{Array.new($w,-1)}\n\t\tqueue = []\n\t\tqueue.push(pos)\n\t\tbb[pos[0]][pos[1]] = 0\n\t\tbfs(pos,queue,bb)\n\t\tdsize.times{|j|\n\t\t\tpos2 = d[j]\n\t\t\t$dist[i+1][j+1] = bb[pos2[0]][pos2[1]]\n\t\t}\n\t\t\n\t}\n\t$dp = Array.new(1 << $n).map{Array.new($n,-1)}\n\tans = INF\n\t$n.times{|i|\n\t\ttmp = rec(0,i)\n\t\tif ans > tmp then\n\t\t\tans = tmp\n\t\tend\n\t}\n\tp ans\n}"
  },
  {
    "language": "Ruby",
    "code": "INF = 10000\n$dx = [1,0,-1,0]\n$dy = [0,1,0,-1]\n$dp = []\n$n = 100\n\ndef bfs(pos,queue,bb) \n\twhile(not queue.empty?) do\n\t\tpos = queue.shift\n\t\tcnt = bb[pos[0]][pos[1]]\n\t\tnpos = []\n\t\t4.times{|i|\n\t\t\tnpos[0] = pos[0] + $dy[i]\n\t\t\tnpos[1] = pos[1] + $dx[i]\n\t\t\tif ((0..$h-1).include?(npos[0]) and (0..$w-1).include?(npos[1])) then\n\t\t\t\tif ($b[npos[0]][npos[1]] == 0 and bb[npos[0]][npos[1]] == -1) then\n\t\t\t\t\tbb[npos[0]][npos[1]] = cnt + 1\n\t\t\t\t\tqueue.push([npos[0],npos[1]])\n\t\t\t\tend\n\t\t\tend\n\t\t}\n\tend\nend\n\ndef rec(s,v)\n\tif $dp[s][v] >= 0 then\n\t\treturn $dp[s][v]\n\tend\n\t\n\tif ( s == ((1 << $n) -1)) then\n\t\treturn $dp[s][v] = $dist[0][v+1]\n\tend\n\t\n\tres = INF\n\t$n.times{|u|\n\t\tif ((s >> u & 1) == 0) then\n\t\t\ttmp = (rec(s | 1 << u,u) + $dist[v+1][u+1] )\n\t\t\tif tmp < res then\n\t\t\t\tres = tmp\n\t\t\tend\n\t\tend\n\t}\n\t\n\treturn $dp[s][v] = res\nend\n\nloop{\n\n\t$w,$h =gets.split.map(&:to_i)\n\tif ($w==0 and $h == 0) then\n\t\tbreak\n\tend\n\t$b = Array.new($h).map{Array.new($w)}\n\td = Array.new()\n\tdcost = Array.new()\n\ts = Array.new(2)\n\t\n\t$h.times{|hh|\n\t\t$b[hh] = gets.chomp.chars.each_with_index.map{|c,i|\n\t\t\tcase c \n\t\t\twhen '.'\n\t\t\t\t0\n\t\t\twhen '*'\n\t\t\t\td.push([hh,i])\n\t\t\t\t0\n\t\t\twhen 'o'\n\t\t\t\ts = [hh,i]\n\t\t\t\t0\n\t\t\telse\n\t\t\t\t-100\n\t\t\tend\n\t\t}\n\t}\n\tbb = Array.new($h).map{Array.new($w,-1)}\n\tqueue = []\n\tqueue.push(s)\n\tbb[s[0]][s[1]] = 0\n\tbfs(s,queue,bb)\n\n\tflag = true\n\t\n\tdsize = d.size()\n\t$n = dsize\n\t$dist = Array.new(dsize+1).map{Array.new(dsize+1,-1)}\n\td.each_with_index{|pos,i|\n\t\t$dist[0][i+1] = bb[pos[0]][pos[1]]\n\t\t$dist[i+1][0] = bb[pos[0]][pos[1]]\n\t\t\n\t\tif bb[pos[0]][pos[1]] == -1 then\n\t\t\tflag = false\n\t\tend\n\t}\n\t\n\tif (!flag) then\n\t\tprint \"-1\\n\"\n\t\tnext\n\tend\n\t\n\t\n\n\td.each_with_index{|pos,i|\n\t\tbb = Array.new($h).map{Array.new($w,-1)}\n\t\tqueue = []\n\t\tqueue.push(pos)\n\t\tbb[pos[0]][pos[1]] = 0\n\t\tbfs(pos,queue,bb)\n\t\tdsize.times{|j|\n\t\t\tpos2 = d[j]\n\t\t\t$dist[i+1][j+1] = bb[pos2[0]][pos2[1]]\n\t\t}\n\t\t\n\t}\n\t$dp = Array.new(1 << $n).map{Array.new($n,-1)}\n\tp rec(0,0)\n\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nINF = 1 << 30\n\nDXYS = [[1, 0], [0, -1], [-1, 0], [0, 1]]\n\n### main\n\nloop do\n  w, h = gets.split.map(&:to_i)\n  break if (w | h) == 0\n\n  wh = w * h\n\n  tls = wh.times.map{0}\n  ndtl = 0\n  spos = nil\n\n  for y in (0...h)\n    line = gets.strip\n    for x in (0...w)\n      pos = y * w + x\n      case line[x]\n      when '*'\n        ndtl += 1\n        tls[pos] = ndtl\n      when 'x'\n        tls[pos] = -1\n      when 'o'\n        spos = pos\n      end\n    end\n  end\n  #p tls\n  #p spos\n\n  dbits = (1 << ndtl) - 1\n\n  dists = wh.times.map{(dbits + 1).times.map{INF}}\n  dists[spos][dbits] = 0\n  q = [[spos, dbits]]\n\n  min_dist = INF\n\n  while ! q.empty?\n    upos, ubits = q.shift\n    ud = dists[upos][ubits]\n\n    if ubits == 0\n      min_dist = ud if min_dist > ud\n      next\n    end\n\n    ux = upos % w\n    uy = upos / w\n\n    DXYS.each do |dx, dy|\n      vx = ux + dx\n      vy = uy + dy\n      vpos = vy * w + vx\n\n      if vx >= 0 && vx < w && vy >= 0 && vy < h && tls[vpos] >= 0\n        vbits = ubits\n        if tls[vpos] > 0\n          vbits &= ~(1 << (tls[vpos] - 1))\n        end\n\n        vd = ud + 1\n        if dists[vpos][vbits] > vd\n          dists[vpos][vbits] = vd\n          q << [vpos, vbits]\n        end\n      end\n    end\n  end\n\n  puts (min_dist >= INF ? -1 : min_dist)\n  #p dists\nend"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_to_node_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef dijkstra(start, setting = {})\n\t\traise \"invalid setting\" if setting.class != Hash\n\t\traise \"invalid setting\" if setting.keys - [:goal, :multi_source, :multi_sink, :max_dist] != []\n\t\t\n\t\tstart = Set[start] if !setting[:multi_source]\n\t\tgoal = setting[:goal]\n\t\tgoal = Set[goal] if goal && !setting[:multi_sink]\n\t\tmax_dist = setting[:max_dist]\n\n\t\th = Heap.new\n\t\treached = Set.new\n\t\tstart.each{|v|\n\t\t\th.add(v, 0)\n\t\t\treached << v\n\t\t}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if setting[:goal] && goal.include?(u)\n\t\t\tbreak if max_dist && key > max_dist\n\t\t\tdist[u] = key\n\t\t\teach_to_node_of(u){|v|\n\t\t\t\td = dist[u] + edge_length(u, v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tgoal ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_to_node_of(u){|v|\n\t\t\t\t\td = f_dist[u] + edge_length(u, v)\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_from_node_of(u){|v|\n\t\t\t\t\td = b_dist[u] + edge_length(v, u)\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\nend\n\nloop {\n\tw, h = gets.split.map &:to_i\n\tbreak if w == 0\n\ta = (1..h).map{ gets.chomp.split(\"\") }\n\tstart = nil\n\ttargets = []\n\t(0..h-1).each{|i|\n\t\t(0..w-1).each{|j|\n\t\t\tstart = [i, j] if a[i][j] == ?o\n\t\t\ttargets << [i, j] if a[i][j] == ?*\n\t\t}\n\t}\n\ta.extend Graphical\n\tdef a.each_to_node_of(node)\n\t\ty, x = node\n\t\t[[1,0],[-1,0],[0,-1],[0,1]].each{|dy, dx|\n\t\t\tu, v = x+dx, y+dy\n\t\t\tyield [v, u] if (0..self.size-1) === v && (0..self[0].size-1) === u && self[v][u] != ?x\n\t\t}\n\tend\n\tdef a.edge_length(u, v)\n\t\t1\n\tend\n\n\td = a.dijkstra(start)\n\tinit_dist = (0..targets.size-1).map{|i| d[targets[i]]}\n\tif init_dist.include?(nil)\n\t\tputs -1\n\t\tnext\n\tend\n\n\tdist = (0..targets.size-1).map{|i|\n\t\td = a.dijkstra(targets[i])\n\t\t(0..targets.size-1).map{|j|\n\t\t\td[targets[j]]\n\t\t}\n\t}\n\n\tbest = Float::INFINITY\n\tstack = (0..targets.size-1).map{|i|\n\t\t[init_dist[i], i, (0..targets.size-1).to_a - [i]]\n\t}\n\tuntil stack.empty?\n\t\td, i, rest = stack.pop\n\t\tif rest == []\n\t\t\tbest = d if d < best\n\t\t\tnext\n\t\tend\n\t\tnext if d >= best\n\t\trest.each{|j|\n\t\t\tstack << [d+dist[i][j], j, rest-[j]]\n\t\t}\n\tend\n\tp best\n\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop;\n\nimmutable int INF = 1 << 28;\nint[] dr = [0, 0, -1, 1]; \nint[] dc = [-1, 1, 0, 0];\n\nvoid main() {\n    while (true) {\n        auto s = readln.split.map!(to!int);\n        auto W = s[0];\n        auto H = s[1];\n        if (W == 0) break;\n        auto B = H.iota.map!(_ => readln.chomp).array;\n\n        int start;\n        int[] dests;\n        int[][] dist = new int[][](H*W, H*W);\n        foreach (i; 0..H*W)\n            foreach(j; 0..H*W)\n                dist[i][j] = i == j ? 0 : INF;\n\n        foreach (i; 0..H) {\n            foreach (j; 0..W) {\n                if (B[i][j] == 'o') start = i * W + j;\n                if (B[i][j] == '*') dests ~= i * W + j;\n                if (B[i][j] == 'x') continue;\n                foreach (k; 0..4) {\n                    int ni = i + dr[k];\n                    int nj = j + dc[k];\n                    if (ni < 0 || ni >= H || nj < 0 || nj >= W)\n                        continue;\n                    if (B[ni][nj] == 'x')\n                        continue;\n                    dist[i * W + j][ni * W + nj] = 1;\n                }\n            }\n        }\n\n        foreach (i; 0..H*W)\n            foreach (j; 0..H*W)\n                foreach (k; 0..H*W)\n                    dist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n\n        if (dests.map!(d => dist[start][d] == INF).any) {\n            writeln(-1);\n            continue;\n        }\n        \n        int M = dests.length.to!int;\n        auto mem = new int[][](1 << M, M + 1);\n        foreach (i; 0..(1 << M)) fill(mem[i], -1);\n        \n        int dp(int mask, int from) {\n            if (mask == 0) return dist[start][dests[from]];\n            if (mem[mask][dests[from]] >= 0) return mem[mask][dests[from]];\n\n            int ret = INF;\n            foreach (i; 0..M) {\n                if (mask & (1 << i)) {\n                    int tmp = from < M ? dist[dests[from]][dests[i]] : 0;\n                    tmp += dp(mask - (1 << i), i);\n                    ret = min(ret, tmp);\n                }\n            }\n\n            return mem[mask][from] = ret;\n        }\n\n        int ans = dp((1 << M) - 1, M);\n        writeln(ans == INF ? -1 : ans);\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop;\n\nimmutable int INF = 1 << 28;\nint[] dr = [0, 0, -1, 1]; \nint[] dc = [-1, 1, 0, 0];\n\nvoid main() {\n    while (true) {\n        auto s = readln.split.map!(to!int);\n        auto W = s[0];\n        auto H = s[1];\n        if (W == 0) break;\n        auto B = H.iota.map!(_ => readln.chomp).array;\n\n        int start;\n        int[] dests;\n        int[][] dist = new int[][](H*W, H*W);\n        foreach (i; 0..H*W)\n            foreach(j; 0..H*W)\n                dist[i][j] = i == j ? 0 : INF;\n\n        foreach (i; 0..H) {\n            foreach (j; 0..W) {\n                if (B[i][j] == 'o') start = i * W + j;\n                if (B[i][j] == '*') dests ~= i * W + j;\n                if (B[i][j] == 'x') continue;\n                foreach (k; 0..4) {\n                    int ni = i + dr[k];\n                    int nj = j + dc[k];\n                    if (ni < 0 || ni >= H || nj < 0 || nj >= W)\n                        continue;\n                    if (B[ni][nj] == 'x')\n                        continue;\n                    dist[i * W + j][ni * W + nj] = 1;\n                }\n            }\n        }\n\n        foreach (i; 0..H*W)\n            foreach (j; 0..H*W)\n                foreach (k; 0..H*W)\n                    dist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n\n        if (dests.map!(d => dist[start][d] == INF).any) {\n            writeln(-1);\n            continue;\n        }\n        \n        int M = dests.length.to!int;\n        auto mem = new int[][](1 << M, M + 1);\n        foreach (i; 0..(1 << M)) fill(mem[i], -1);\n        \n        int dp(int mask, int from) {\n            if (mask == 0) return dist[start][dests[from]];\n            if (mem[mask][dests[from]] >= 0) return mem[mask][dests[from]];\n\n            int ret = INF;\n            foreach (i; 0..M) {\n                if (mask & (1 << i)) {\n                    int tmp = from < M ? dist[dests[from]][dests[i]] : 0;\n                    tmp += dp(mask - (1 << i), i);\n                    ret = min(ret, tmp);\n                }\n            }\n\n            return mem[mask][dests[from]] = ret;\n        }\n\n        int ans = dp((1 << M) - 1, M);\n        writeln(ans == INF ? -1 : ans);\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop;\n\nimmutable int INF = 1 << 28;\nint[] dr = [0, 0, -1, 1]; \nint[] dc = [-1, 1, 0, 0];\n\nvoid main() {\n    while (true) {\n        auto s = readln.split.map!(to!int);\n        auto W = s[0];\n        auto H = s[1];\n        if (W == 0) break;\n        auto B = H.iota.map!(_ => readln.chomp).array;\n\n        int start;\n        int[] dests;\n        int[][] dist = new int[][](H*W, H*W);\n        foreach (i; 0..H*W)\n            foreach(j; 0..H*W)\n                dist[i][j] = i == j ? 0 : INF;\n\n        foreach (i; 0..H) {\n            foreach (j; 0..W) {\n                if (B[i][j] == 'o') start = i * W + j;\n                if (B[i][j] == '*') dests ~= i * W + j;\n                if (B[i][j] == 'x') continue;\n                foreach (k; 0..4) {\n                    int ni = i + dr[k];\n                    int nj = j + dc[k];\n                    if (ni < 0 || ni >= H || nj < 0 || nj >= W)\n                        continue;\n                    if (B[ni][nj] == 'x')\n                        continue;\n                    dist[i * W + j][ni * W + nj] = 1;\n                }\n            }\n        }\n\n        foreach (i; 0..H*W)\n            foreach (j; 0..H*W)\n                foreach (k; 0..H*W)\n                    dist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n\n        if (dests.map!(d => dist[start][d] == INF).any) {\n            writeln(-1);\n            continue;\n        }\n        \n        int M = dests.length.to!int;\n        auto mem = new int[][](1 << M, M + 1);\n        foreach (i; 0..(1 << M)) fill(mem[i], -1);\n        \n        int dp(int mask, int from) {\n            if (mask == 0) return dist[start][dests[from]];\n            if (mem[mask][from] >= 0) return mem[mask][dests[from]];\n\n            int ret = INF;\n            foreach (i; 0..M) {\n                if (mask & (1 << i)) {\n                    int tmp = from < M ? dist[dests[from]][dests[i]] : 0;\n                    tmp += dp(mask - (1 << i), i);\n                    ret = min(ret, tmp);\n                }\n            }\n\n            return mem[mask][from] = ret;\n        }\n\n        int ans = dp((1 << M) - 1, M);\n        writeln(ans == INF ? -1 : ans);\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop;\n\nimmutable int INF = 1 << 28;\nint[] dr = [0, 0, -1, 1]; \nint[] dc = [-1, 1, 0, 0];\n\nvoid main() {\n    while (true) {\n        auto s = readln.split.map!(to!int);\n        auto W = s[0];\n        auto H = s[1];\n        if (W == 0) break;\n        auto B = H.iota.map!(_ => readln.chomp).array;\n\n        int start;\n        int[] dests;\n        int[][] dist = new int[][](H*W, H*W);\n        foreach (i; 0..H*W)\n            foreach(j; 0..H*W)\n                dist[i][j] = i == j ? 0 : INF;\n\n        foreach (i; 0..H) {\n            foreach (j; 0..W) {\n                if (B[i][j] == 'o') start = i * W + j;\n                if (B[i][j] == '*') dests ~= i * W + j;\n                if (B[i][j] == 'x') continue;\n                foreach (k; 0..4) {\n                    int ni = i + dr[k];\n                    int nj = j + dc[k];\n                    if (ni < 0 || ni >= H || nj < 0 || nj >= W)\n                        continue;\n                    if (B[ni][nj] == 'x')\n                        continue;\n                    dist[i * W + j][ni * W + nj] = 1;\n                }\n            }\n        }\n\n        foreach (i; 0..H*W)\n            foreach (j; 0..H*W)\n                foreach (k; 0..H*W)\n                    dist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n\n        auto M = dests.length.to!int;\n        auto perm = M.iota.array;\n        \n        int ans = INF;\n        do {\n            int tmp = 0;\n            int pos = start;\n            foreach (i; perm) {\n                if (dist[pos][dests[i]] == INF) {\n                    tmp = INF;\n                    break;\n                }\n                tmp += dist[pos][dests[i]];\n                pos = dests[i];\n            }\n            ans = min(ans, tmp);\n        } while(nextPermutation(perm));\n\n        writeln(ans == INF ? -1 : ans);\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop;\n\nimmutable int INF = 1 << 28;\nint[] dr = [0, 0, -1, 1]; \nint[] dc = [-1, 1, 0, 0];\n\nvoid main() {\n    while (true) {\n        auto s = readln.split.map!(to!int);\n        auto W = s[0];\n        auto H = s[1];\n        if (W == 0) break;\n        auto B = H.iota.map!(_ => readln.chomp).array;\n\n        int start;\n        int[] dests;\n        int[][] dist = new int[][](H*W, H*W);\n        foreach (i; 0..H*W)\n            foreach(j; 0..H*W)\n                dist[i][j] = i == j ? 0 : INF;\n\n        foreach (i; 0..H) {\n            foreach (j; 0..W) {\n                if (B[i][j] == 'o') start = i * W + j;\n                if (B[i][j] == '*') dests ~= i * W + j;\n                if (B[i][j] == 'x') continue;\n                foreach (k; 0..4) {\n                    int ni = i + dr[k];\n                    int nj = j + dc[k];\n                    if (ni < 0 || ni >= H || nj < 0 || nj >= W)\n                        continue;\n                    if (B[ni][nj] == 'x')\n                        continue;\n                    dist[i * W + j][ni * W + nj] = 1;\n                }\n            }\n        }\n\n        foreach (i; 0..H*W)\n            foreach (j; 0..H*W)\n                foreach (k; 0..H*W)\n                    dist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n\n        if (dests.map!(d => dist[start][d] == INF).any) {\n            writeln(-1);\n            continue;\n        }\n        \n        int M = dests.length.to!int;\n        auto mem = new int[][](1 << M, M + 1);\n        foreach (i; 0..(1 << M)) fill(mem[i], -1);\n        \n        int dp(int mask, int from) {\n            if (mask == 0) return dist[start][dests[from]];\n            if (mem[mask][from] >= 0) return mem[mask][from];\n\n            int ret = INF;\n            foreach (i; 0..M) {\n                if (mask & (1 << i)) {\n                    int tmp = from < M ? dist[dests[from]][dests[i]] : 0;\n                    tmp += dp(mask - (1 << i), i);\n                    ret = min(ret, tmp);\n                }\n            }\n\n            return mem[mask][from] = ret;\n        }\n\n        int ans = dp((1 << M) - 1, M);\n        writeln(ans == INF ? -1 : ans);\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop;\n\nimmutable int INF = 1 << 28;\nint[] dr = [0, 0, -1, 1]; \nint[] dc = [-1, 1, 0, 0];\n\nvoid main() {\n    while (true) {\n        auto s = readln.split.map!(to!int);\n        auto W = s[0];\n        auto H = s[1];\n        if (W == 0) break;\n        auto B = H.iota.map!(_ => readln.chomp).array;\n\n        int start;\n        int[] dests;\n        int[][] dist = new int[][](H*W, H*W);\n        foreach (i; 0..H*W)\n            foreach(j; 0..H*W)\n                dist[i][j] = i == j ? 0 : INF;\n\n        foreach (i; 0..H) {\n            foreach (j; 0..W) {\n                if (B[i][j] == 'o') start = i * W + j;\n                if (B[i][j] == '*') dests ~= i * W + j;\n                if (B[i][j] == 'x') continue;\n                foreach (k; 0..4) {\n                    int ni = i + dr[k];\n                    int nj = j + dc[k];\n                    if (ni < 0 || ni >= H || nj < 0 || nj >= W)\n                        continue;\n                    if (B[ni][nj] == 'x')\n                        continue;\n                    dist[i * W + j][ni * W + nj] = 1;\n                }\n            }\n        }\n\n        foreach (i; 0..H*W)\n            foreach (j; 0..H*W)\n                foreach (k; 0..H*W)\n                    dist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n\n        if (dests.map!(d => dist[start][d] == INF).any) {\n            writeln(-1);\n            break;\n        }\n        \n        int M = dests.length;\n        auto mem = new int[][](1 << M, M + 1);\n        foreach (i; 0..(1 << M)) fill(mem[i], -1);\n        \n        int dp(int mask, int from) {\n            if (mask == 0) return dist[start][dests[from]];\n            if (mem[mask][from] >= 0) return mem[mask][dests[from]];\n\n            int ret = INF;\n            foreach (i; 0..M) {\n                if (mask & (1 << i)) {\n                    int tmp = from < M ? dist[dests[from]][dests[i]] : 0;\n                    tmp += dp(mask - (1 << i), i);\n                    ret = min(ret, tmp);\n                }\n            }\n\n            return mem[mask][from] = ret;\n        }\n\n        int ans = dp((1 << M) - 1, M);\n        writeln(ans == INF ? -1 : ans);\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop;\n\nimmutable int INF = 1 << 28;\nint[] dr = [0, 0, -1, 1]; \nint[] dc = [-1, 1, 0, 0];\n\nvoid main() {\n    while (true) {\n        auto s = readln.split.map!(to!int);\n        auto W = s[0];\n        auto H = s[1];\n        if (W == 0) break;\n        auto B = H.iota.map!(_ => readln.chomp).array;\n\n        int start;\n        int[] dests;\n        int[][] dist = new int[][](H*W, H*W);\n        foreach (i; 0..H*W)\n            foreach(j; 0..H*W)\n                dist[i][j] = i == j ? 0 : INF;\n\n        foreach (i; 0..H) {\n            foreach (j; 0..W) {\n                if (B[i][j] == 'o') start = i * W + j;\n                if (B[i][j] == '*') dests ~= i * W + j;\n                if (B[i][j] == 'x') continue;\n                foreach (k; 0..4) {\n                    int ni = i + dr[k];\n                    int nj = j + dc[k];\n                    if (ni < 0 || ni >= H || nj < 0 || nj >= W)\n                        continue;\n                    if (B[ni][nj] == 'x')\n                        continue;\n                    dist[i * W + j][ni * W + nj] = 1;\n                }\n            }\n        }\n\n        foreach (i; 0..H*W)\n            foreach (j; 0..H*W)\n                foreach (k; 0..H*W)\n                    dist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n\n        if (dests.map!(d => dist[start][d] == INF).any) {\n            writeln(-1);\n            break;\n        }\n        \n        int M = dests.length.to!int;\n        auto mem = new int[][](1 << M, M + 1);\n        foreach (i; 0..(1 << M)) fill(mem[i], -1);\n        \n        int dp(int mask, int from) {\n            if (mask == 0) return dist[start][dests[from]];\n            if (mem[mask][from] >= 0) return mem[mask][dests[from]];\n\n            int ret = INF;\n            foreach (i; 0..M) {\n                if (mask & (1 << i)) {\n                    int tmp = from < M ? dist[dests[from]][dests[i]] : 0;\n                    tmp += dp(mask - (1 << i), i);\n                    ret = min(ret, tmp);\n                }\n            }\n\n            return mem[mask][from] = ret;\n        }\n\n        int ans = dp((1 << M) - 1, M);\n        writeln(ans == INF ? -1 : ans);\n    }\n}"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom heapq import heappush, heappop\nsys.setrecursionlimit(100000)\nINF = 10 ** 10\n\ndirect = ((0, -1), (0, 1), (-1, 0), (1, 0))\n\ndef dist(fr, to, mp):\n  que = []\n  heappush(que, (0, fr))\n  visited = [[False] * len(mp[0]) for _ in range(len(mp))]\n  visited[fr[1]][fr[0]] = True\n  while que:\n    d, point = heappop(que)\n    x, y = point\n    for dx, dy in direct:\n      nx, ny = x + dx, y + dy\n      if (nx, ny) == to:\n        return d + 1\n      if not visited[ny][nx] and mp[ny][nx] != \"x\":\n        visited[ny][nx] = True\n        heappush(que, (d + 1, (nx, ny)))\n  else:\n    return -1\n\ndef my_hash(rest):\n  return sum([10 ** i for i in rest])\n\ndef shortest(fr, rest, edges, dp):\n  if rest == set():\n    return 0\n  if my_hash(rest) in dp[fr]:\n    return dp[fr][my_hash(rest)]\n  ret = INF\n  for d, to in edges[fr]:\n    if to in rest:\n      score = d + shortest(to, rest - {to}, edges, dp)\n      if score < ret:\n        ret = score\n  dp[fr][my_hash(rest)] = ret\n  return ret\n\ndef main():\n  while True:\n    w, h = map(int, input().split())\n    if w == 0:\n      break\n    mp = [\"x\" + input() + \"x\" for _ in range(h)]\n    mp.insert(0, \"x\" * (w + 2))\n    mp.append(\"x\" * (w + 2))\n    \n    stains = []\n    for y in range(1, h + 1):\n      for x in range(1, w + 1):\n        if mp[y][x] == \"*\":\n          stains.append((x, y))\n        elif mp[y][x] == \"o\":\n          start = len(stains)\n          stains.append((x, y))\n    \n    stain_num = len(stains)\n    edges = [[] for _ in range(stain_num)]\n    D = [[None] * stain_num for _ in range(stain_num)]\n    for i in range(stain_num):\n      D[i][i] = 0\n    miss_flag = False\n    for i in range(stain_num):\n      for j in range(i + 1, stain_num):\n        fr = stains[i]\n        to = stains[j]\n        d = dist(fr, to, mp)\n        if d == -1:\n          miss_flag = True\n        edges[i].append((d, j))\n        edges[j].append((d, i))\n        D[i][j] = d\n        D[j][i] = d\n    if miss_flag:\n      print(-1)\n      continue\n\n\n    dp = [{} for _ in range(10)]\n    print(shortest(start, {i for i in range(stain_num) if i != start}, edges, dp))\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\ndd = [(-1, 0), (0, -1), (1, 0), (0, 1)]\nwhile 1:\n    w, h = map(int, raw_input().split())\n    if w == 0:\n        break\n    C = [raw_input() for i in xrange(h)]\n    cnt = 0\n    mark = {}\n    sx = sy = -1\n    for i in xrange(h):\n        for j in xrange(w):\n            if C[i][j] == 'o':\n                sx = j; sy = i\n            elif C[i][j] == '*':\n                mark[j, i] = cnt\n                cnt += 1\n    ALL = 2**cnt - 1\n    dis = {(sx, sy, 0): 0}\n    deq = deque()\n    deq.append((sx, sy, 0))\n    ans = -1\n    while deq and ans == -1:\n        x, y, state = key = deq.popleft()\n        for dx, dy in dd:\n            nx = x + dx\n            ny = y + dy\n            if 0 <= nx < w and 0 <= ny < h and C[ny][nx] != 'x':\n                n_state = state\n                if C[ny][nx] == '*':\n                    n_state |= 1 << mark[nx, ny]\n                if n_state == ALL:\n                    ans = dis[key] + 1\n                    break\n                n_key = (nx, ny, n_state)\n                if n_key not in dis:\n                    dis[n_key] = dis[key] + 1\n                    deq.append(n_key)\n    print ans"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nINF = 10 ** 10\n\ndirect = ((0, -1), (0, 1), (-1, 0), (1, 0))\n\ndef dist(fr, to, mp):\n  que = []\n  heappush(que, (0, fr))\n  visited = [[False] * len(mp[0]) for _ in range(len(mp))]\n  visited[fr[1]][fr[0]] = True\n  while que:\n    d, point = heappop(que)\n    x, y = point\n    for dx, dy in direct:\n      nx, ny = x + dx, y + dy\n      if (nx, ny) == to:\n        return d + 1\n      if not visited[ny][nx] and mp[ny][nx] != \"x\":\n        visited[ny][nx] = True\n        heappush(que, (d + 1, (nx, ny)))\n  else:\n    return -1\n\ndef my_hash(rest):\n  ret = 0\n  for i in rest:\n    ret += 10 ** i\n  return ret\n\ndef shortest(fr, rest, edges, dp):\n  if rest == set():\n    return 0\n  h = my_hash(rest)\n  if h in dp[fr]:\n    return dp[fr][h]\n  ret = INF\n  for d, to in edges[fr]:\n    if to in rest:\n      score = d + shortest(to, rest - {to}, edges, dp)\n      if score < ret:\n        ret = score\n  dp[fr][h] = ret\n  return ret\n\ndef main():\n  while True:\n    w, h = map(int, input().split())\n    if w == 0:\n      break\n    mp = [\"x\" + input() + \"x\" for _ in range(h)]\n    mp.insert(0, \"x\" * (w + 2))\n    mp.append(\"x\" * (w + 2))\n    \n    stains = []\n    for y in range(1, h + 1):\n      for x in range(1, w + 1):\n        if mp[y][x] == \"*\":\n          stains.append((x, y))\n        elif mp[y][x] == \"o\":\n          start = len(stains)\n          stains.append((x, y))\n    \n    stain_num = len(stains)\n    edges = [[] for _ in range(stain_num)]\n    miss_flag = False\n    for i in range(stain_num):\n      for j in range(i + 1, stain_num):\n        fr = stains[i]\n        to = stains[j]\n        d = dist(fr, to, mp)\n        if d == -1:\n          miss_flag = True\n        edges[i].append((d, j))\n        edges[j].append((d, i))\n    if miss_flag:\n      print(-1)\n      continue\n\n    dp = [{} for _ in range(stain_num)]\n    print(shortest(start, {i for i in range(stain_num) if i != start}, edges, dp))\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nimport subprocess\nimport json\nimport time\nimport math\nimport re\nimport sqlite3\nimport random\nfrom queue import Queue\n\ndy = [0, 0, 1, -1]\ndx = [1, -1, 0, 0]\nINF = int(1e20)\n\nclass Point:\n    def __init__(self, y, x, distance = 0):\n        self.y = y\n        self.x = x\n        self.distance = distance\n\ndef ok(y, x):\n    global w, h, visited_cnt\n    return 0 <= y and y < h and 0 <= x and x < w\n        \ndef bfs(start, goal):\n    global w, h, visited_cnt\n    q = Queue()\n    q.put(start)\n    #print(\"start.distance =\", start.distance)\n    bfs_visited = [[False for _ in range(w)] for _ in range(h)]\n    while not q.empty():\n        #print(bfs_visited)\n        cur = q.get()\n        #print(\"cur.y =\", cur.y, \"cur.x =\", cur.x)\n        if cur.y == goal.y and cur.x == goal.x:\n            return cur.distance\n        \n        for i in range(4):\n            next = Point(cur.y + dy[i], cur.x + dx[i], cur.distance + 1)\n            if not ok(next.y, next.x): continue\n            if bfs_visited[next.y][next.x]: continue\n            if c[next.y][next.x] == 'x': continue\n            bfs_visited[next.y][next.x] = True\n            q.put(next)\n\n    return INF\n\ndef dfs(pre):\n    global w, h, visited_cnt\n    if visited_cnt == points.__len__():\n        return 0\n        \n    res = int(1e80)\n    for i in range(points.__len__()):\n        if visited[i]: continue\n        visited[i] = True\n        visited_cnt += 1\n        res = min(res, dfs(points[i]) +\n                  bfs(pre, points[i])) \n        visited[i] = False\n        visited_cnt -= 1\n    return res\n\nwhile True:\n    w, h = map(int, input().split())\n    if w == 0 and h == 0: exit(0)\n    c = [list(input()) for _ in range(h)]\n    points = []\n    visited = [False] * 15 \n    visited_cnt = 0\n                  \n    for y in range(h):\n        for x in range(w):\n            if c[y][x] == 'o':\n                start = Point(y, x)\n            if c[y][x] == '*':\n                points.append(Point(y, x))\n    #print(points.__len__())\n    ret = dfs(start)\n    if ret < INF: print(ret)\n    else: print(-1)\n        "
  },
  {
    "language": "Python",
    "code": "import sys\nfrom Queue import Queue\nR = lambda:map(int,raw_input().split())\n\nMAX = 10000000\ndx = [0,1,0,-1]\ndy = [1,0,-1,0]\n\ndef CalcCost(start):\n    global visited\n    cost = [[MAX for j in xrange(w)] for i in xrange(h)]\n    cost[start[1]][start[0]] = 0\n    q = Queue()\n    q.put(start)\n    while not q.empty():\n        p = q.get()\n        for i in xrange(4):\n            mx,my = p[0]+dx[i],p[1]+dy[i]\n            if (0 <= mx < w) and (0 <= my < h) and (visited[my][mx] is False):\n            #if (0 <= mx < w) and (0 <= my < h):\n                if cost[p[1]][p[0]] + 1 < cost[my][mx]:\n                    cost[my][mx] = cost[p[1]][p[0]] + 1\n                    q.put((mx,my))\n    return cost\n\nwhile 1:\n    w,h = R()\n    #cost = [[MAX for j in xrange(w)] for i in xrange(h)]\n    visited = [[False for j in xrange(w)] for i in xrange(h)]\n    dirt = []\n    if not(w or h): break                   \n    for i in xrange(h):\n        s = raw_input()\n        for j in xrange(w):\n            if s[j] == '.':\n                pass\n            elif s[j] == 'o':\n                start = (j,i)\n            elif s[j] == '*':\n                dirt.append((j,i))\n            else:\n                visited[i][j] = True\n                \n    distance = 0\n    isPossible = True\n    while(dirt):\n        #print dirt\n        c = CalcCost(start)\n        tmp = MAX\n        for i in xrange(len(dirt)):\n            x,y = dirt[i][0],dirt[i][1]\n            if c[y][x] == MAX:\n                #print -1\n                distance = -1\n                isPossible = False\n                break\n            if tmp > c[y][x]:\n                start = (x,y)\n                tmp = c[y][x]\n        if isPossible is False: break\n        dirt.remove(start)\n        distance += tmp\n\n    print distance"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom Queue import Queue\nR = lambda:map(int,raw_input().split())\n\nMAX = 10000000\ndirt = []\ndx = [0,1,0,-1]\ndy = [1,0,-1,0]\n\ndef CalcCost(start):\n    global visited\n    cost = [[MAX for j in xrange(w)] for i in xrange(h)]\n    cost[start[1]][start[0]] = 0\n    q = Queue()\n    q.put(start)\n    while not q.empty():\n        p = q.get()\n        for i in xrange(4):\n            mx,my = p[0]+dx[i],p[1]+dy[i]\n            if (0 <= mx < w) and (0 <= my < h) and (visited[my][mx] is False):\n            #if (0 <= mx < w) and (0 <= my < h):\n                if cost[p[1]][p[0]] + 1 < cost[my][mx]:\n                    cost[my][mx] = cost[p[1]][p[0]] + 1\n                    q.put((mx,my))\n    return cost\n\nwhile 1:\n    w,h = R()\n    #cost = [[MAX for j in xrange(w)] for i in xrange(h)]\n    visited = [[False for j in xrange(w)] for i in xrange(h)]\n    if not(w or h): break                   \n    for i in xrange(h):\n        s = raw_input()\n        for j in xrange(w):\n            if s[j] == '.':\n                pass\n            elif s[j] == 'o':\n                start = (j,i)\n            elif s[j] == '*':\n                dirt.append((j,i))\n            else:\n                visited[i][j] = True\n                \n    distance = 0\n    isPossible = True\n    while(dirt):\n        c = CalcCost(start)\n        tmp = MAX\n        for i in xrange(len(dirt)):\n            x,y = dirt[i][0],dirt[i][1]\n            if c[y][x] == MAX:\n                #print -1\n                distance = -1\n                isPossible = False\n                break\n            if tmp > c[y][x]:\n                start = (x,y)\n                tmp = c[y][x]\n        if isPossible is False: break\n        dirt.remove(start)\n        distance += tmp\n\n    print distance"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\nd = [(1,0),(-1,0),(0,1),(0,-1)]\ndef bfs(sy,sx): #スタートまたは各汚れ間の最短路を計算\n    dist = [[-1]*w for i in range(h)]\n    dist[sy][sx] = 0\n    q = deque([(sy,sx)])\n    while q:\n        y,x = q.popleft()\n        for dy,dx in d:\n            y_ = y+dy\n            x_ = x+dx\n            if 0 <= y_ < h and 0 <= x_ < w:\n                if dist[y_][x_] < 0 and s[y_][x_] != \"x\":\n                    dist[y_][x_] = dist[y][x] + 1\n                    q.append((y_,x_))\n    return dist\n\npo = [1<<i for i in range(11)] #1<<iの前処理(いらないかも??)\nwhile 1:\n    w,h = map(int, sys.stdin.readline().split())\n    if w == 0:\n        break\n    s = [sys.stdin.readline() for i in range(h)]\n    p = [] #スタート、汚れを保存\n    for y in range(h):\n        for x in range(w):\n            if s[y][x] == \"o\":\n                p.append((y,x))\n                break\n    for y in range(h):\n        for x in range(w):\n            if s[y][x] == \"*\":\n                p.append((y,x))\n    \"\"\"↑スタートの座標を常にp[0]に保存したかったからこうやってループを分けた\"\"\"\n    n = len(p)\n    dist = [[float(\"inf\")]*n for i in range(n)] #スタート及び各汚れ間の最短路\n    f = 0\n    for i in range(n):\n        di = bfs(*p[i]) #*listとすると、list[0],list[1],list[2],…と同値なので複数引数の場合にこうやって書くと楽\n        for j in range(n):\n            dist[i][j] = di[p[j][0]][p[j][1]]\n            if dist[i][j] < 0:\n                f = 1 #もしたどりつけない点があったら終了\n                break\n    if f:\n        print(-1)\n        continue\n    \"\"\"以下bitDP\"\"\"\n    ma = po[n] #最大状態ma = 111…1+1\n    dp = [[float(\"inf\")]*(n) for i in range(ma)] #最後に消したところからの最短路を見る必要があるため2次元(dp[b][i] := 汚れを消した状態がbかつ最後に消した汚れが汚れiの時の最短路)\n    dp[1][0] = 0\n    for b in range(ma): #b := 汚れを消した部分を表す\n        for j in range(n):\n            if (b&po[j]):continue #もし汚れjが消えてたら飛ばす\n            b_ = b|po[j] #b_ := 新たに汚れjを削除\n            for i in range(n):\n                if not b&po[i]:continue\n                #汚れiを最後に消したときのb,b_について比較\n                if dp[b_][j] > dp[b][i]+dist[i][j]:\n                    dp[b_][j] = dp[b][i]+dist[i][j]\n    print(min(dp[ma-1])) #全部消したときの最短路を出力\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f(w,h):\n        a = ['x'*(w+2)] + ['x' + S() + 'x' for _ in range(h)] + ['x'*(w+2)]\n        e = collections.defaultdict(list)\n        st = None\n        dst = []\n        for i in range(1,h+1):\n            for j in range(1,w+1):\n                if a[i][j] == 'x':\n                    continue\n                if a[i][j] == 'o':\n                    st = (i,j)\n                elif a[i][j] == '*':\n                    dst.append((i,j))\n                for di,dj in dd:\n                    if a[i+di][j+dj] == 'x':\n                        continue\n                    e[(i,j)].append(((i+di,j+dj), 1))\n\n        def search(s):\n            d = collections.defaultdict(lambda: inf)\n            d[s] = 0\n            q = []\n            heapq.heappush(q, (0, s))\n            v = collections.defaultdict(bool)\n            while len(q):\n                k, u = heapq.heappop(q)\n                if v[u]:\n                    continue\n                v[u] = True\n\n                for uv, ud in e[u]:\n                    if v[uv]:\n                        continue\n                    vd = k + ud\n                    if d[uv] > vd:\n                        d[uv] = vd\n                        heapq.heappush(q, (vd, uv))\n\n            return d\n\n        sd = search(st)\n        for ds in dst:\n            if sd[ds] == inf:\n                return -1\n\n        dsd = [search(ds) for ds in dst]\n        l = len(dst)\n        r = inf\n        for ta in itertools.permutations(range(l)):\n            t = sd[dst[ta[0]]]\n            for i in range(l-1):\n                t += dsd[ta[i]][dst[ta[i+1]]]\n            if r > t:\n                r = t\n\n        return r\n\n    while 1:\n        n,m = LI()\n        if n == 0 and m == 0:\n            break\n        rr.append(f(n,m))\n        # print('rr', rr[-1])\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nINF = 10 ** 10\n\ndirect = ((0, -1), (0, 1), (-1, 0), (1, 0))\n\ndef dist(fr, to, mp):\n  que = []\n  heappush(que, (0, fr))\n  visited = [[False] * len(mp[0]) for _ in range(len(mp))]\n  visited[fr[1]][fr[0]] = True\n  while que:\n    d, point = heappop(que)\n    x, y = point\n    for dx, dy in direct:\n      nx, ny = x + dx, y + dy\n      if (nx, ny) == to:\n        return d + 1\n      if not visited[ny][nx] and mp[ny][nx] != \"x\":\n        visited[ny][nx] = True\n        heappush(que, (d + 1, (nx, ny)))\n  else:\n    return -1\n\ndef shortest(fr, rest, edges):\n  if rest == set():\n    return 0\n  ret = INF\n  for d, to in edges[fr]:\n    if to in rest:\n      score = d + shortest(to, rest - {to}, edges)\n      if score < ret:\n        ret = score\n  return ret\n\ndef main():\n  while True:\n    w, h = map(int, input().split())\n    if w == 0:\n      break\n    mp = [\"x\" + input() + \"x\" for _ in range(h)]\n    mp.insert(0, \"x\" * (w + 2))\n    mp.append(\"x\" * (w + 2))\n    \n    stains = []\n    for y in range(1, h + 1):\n      for x in range(1, w + 1):\n        if mp[y][x] == \"*\":\n          stains.append((x, y))\n        elif mp[y][x] == \"o\":\n          start = len(stains)\n          stains.append((x, y))\n    \n    stain_num = len(stains)\n    edges = [[] for _ in range(stain_num)]\n    miss_flag = False\n    for i in range(stain_num):\n      for j in range(i + 1, stain_num):\n        fr = stains[i]\n        to = stains[j]\n        d = dist(fr, to, mp)\n        if d == -1:\n          miss_flag = True\n        edges[i].append((d, j))\n        edges[j].append((d, i))\n    if miss_flag:\n      print(-1)\n      continue\n  \n    print(shortest(start, {i for i in range(stain_num) if i != start}, edges))\nmain()\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n#AOJ F\nfrom collections import deque\nfrom itertools import permutations\n\ndx = [1,0,-1,0]\ndy = [0,1,0,-1]\n\ndef bfs(sy,sx):\n    dist = [[-1]*w for _ in range(h)]#初期化\n    que = deque()\n    que.append((sy,sx))\n    dist[sy][sx] = 0\n    while que:\n        y,x = que.popleft()\n        for i in range(4):\n            nx,ny = x+dx[i],y+dy[i]\n            if 0 <= nx < w and 0 <= ny < h:\n                if dist[ny][nx] < 0 and M[ny][nx] != \"x\":\n                    dist[ny][nx] = dist[y][x] + 1#移動できるなら移動先の距離+1\n                    que.append((ny,nx))\n\n    return dist#引数をスタートにした距離のリストを返す\n\nwhile 1:\n    w,h = map(int,input().split())\n    if w == 0 and h == 0:\n        break\n    M = [list(input()) for _ in range(h)]\n    p = []\n    for i in range(h):\n        for j in range(w):\n            if M[i][j] == \"o\":\n                p.append((i,j))\n                break\n    for i in range(h):\n        for j in range(w):\n            if M[i][j] == \"*\":\n                p.append((i,j))\n    #p[0]はスタート位置,その他は汚れの位置\n    n = len(p)\n    dist = [[float(\"inf\")]*n for _ in range(n)]#スタート及び各汚れ間の最短路\n    f = 0\n    for i in range(n):\n        di = bfs(*p[i])#*listとすると、list[0],list[1],list[2],…と同値\n        for j in range(n):\n            dist[i][j] = di[p[j][0]][p[j][1]]#dist[i][j]はp[i]をスタートにした場合の汚れまたはスタート間の最短距離\n            if dist[i][j] < 0:\n                f = 1#もしたどりつけない点があったら終了\n                break\n    #print(dist)\n    if f:\n        print(-1)\n        continue\n\n    #bitDP\n    po = [1<<i for i in range(11)]\n    ma = po[n]#ma=11...1 + 1\n    dp = [[float(\"inf\")]*(n) for _ in range(ma)]#最後に消したところからの最短路を見る必要があるため2次元(dp[b][i] := 汚れを消した状態がbかつ最後に消した汚れが汚れiの時の最短路)\n    dp[1][0] = 0#スタート位置は0\n    for b in range(ma):#bは汚れを消した部分を表す\n        for j in range(n):\n            if b&po[j]:#汚れjが消えていたら終了\n                continue\n            nb = b|po[j]#新たに汚れjを削除\n            for i in range(n):\n                if not b&po[i]:#汚れiが消えていないなら終了\n                    continue\n                #汚れiを最後に消したときb,nbについて比較\n                if dp[nb][j] > dp[b][i] + dist[i][j]:#iの後にjを消すほうが最短なら更新\n                    dp[nb][j] = dp[b][i] + dist[i][j]\n    print(min(dp[ma - 1]))#全部消したときの最短距離を出力\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nimport subprocess\nimport json\nimport time\nimport math\nimport re\nimport sqlite3\nimport random\nfrom queue import Queue\n\ndy = [0, 0, 1, -1]\ndx = [1, -1, 0, 0]\nINF = int(1e20)\n\nclass Point:\n    def __init__(self, y, x, distance = 0):\n        self.y = y\n        self.x = x\n        self.distance = distance\n\ndef ok(y, x):\n    global w, h, visited_cnt\n    return 0 <= y and y < h and 0 <= x and x < w\n        \ndef bfs(start, goal):\n    global w, h, visited_cnt\n    q = Queue()\n    q.put(start)\n    #print(\"start.distance =\", start.distance)\n    bfs_visited = [[False for _ in range(w)] for _ in range(h)]\n    while not q.empty():\n        #print(bfs_visited)\n        cur = q.get()\n        #print(\"cur.y =\", cur.y, \"cur.x =\", cur.x)\n        if cur.y == goal.y and cur.x == goal.x:\n            return cur.distance\n        \n        for i in range(4):\n            next = Point(cur.y + dy[i], cur.x + dx[i], cur.distance + 1)\n            if not ok(next.y, next.x): continue\n            if bfs_visited[next.y][next.x]: continue\n            if c[next.y][next.x] == 'x': continue\n            bfs_visited[next.y][next.x] = True\n            q.put(next)\n\n    return INF\n\ndef dfs(pre):\n    global w, h, visited_cnt\n    if visited_cnt == points.__len__():\n        return 0\n        \n    res = int(1e80)\n    for i in range(points.__len__()):\n        if visited[i]: continue\n        visited[i] = True\n        visited_cnt += 1\n        res = min(res, dfs(points[i]) +\n                  bfs(pre, points[i])) \n        visited[i] = False\n        visited_cnt -= 1\n    return res\n\nwhile True:\n    w, h = map(int, input().split())\n    if w == 0 and h == 0: break\n    c = [list(input()) for _ in range(h)]\n    points = []\n    visited = [False] * 15 \n    visited_cnt = 0\n                  \n    for y in range(h):\n        for x in range(w):\n            if c[y][x] == 'o':\n                start = Point(y, x)\n            if c[y][x] == '*':\n                points.append(Point(y, x))\n    #print(points.__len__())\n    ret = dfs(start)\n    if ret < INF: print(ret)\n    else: print(-1)\n        "
  },
  {
    "language": "Python",
    "code": "import sys\nimport math\nimport bisect\nimport heapq\nimport copy\nsys.setrecursionlimit(1000000)\nfrom collections import deque\nfrom itertools import permutations\n\ndy = [-1,0,1,0]\ndx = [0,1,0,-1]\n\ndef main():\n    m,n = 0,0\n    grid = []\n    inf = 1000000007\n\n    def in_the_grid(h,w):\n        return 0<=h and h<n  and 0<=w and w<m\n\n    def bfs(i,j):\n        dq = deque()\n        res = [[inf]*m for _ in range(n)]\n        dq.append([i,j,0])\n        res[i][j] = 0\n        while dq:\n            h,w,c = dq.popleft()\n            for k in range(4):\n                n_h = h+dy[k]\n                n_w = w+dx[k]\n                if not in_the_grid(n_h,n_w):continue\n                if grid[n_h][n_w] == 'x':continue\n                if res[n_h][n_w]!=inf:continue\n                res[n_h][n_w] = c+1\n                dq.append([n_h,n_w,c+1])\n        return res\n\n    while True:\n        m,n = map(int,input().split())\n        if m == 0:break\n        grid = []\n        dis = []\n        ver = []\n        for _ in range(n):\n            grid.append(input())\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j]=='o':\n                    ver.append([i,j])\n                    dis.append(bfs(i,j))\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j]=='*':\n                    ver.append([i,j])\n                    dis.append(bfs(i,j))\n\n        v = len(dis)\n        d = [[] for _ in range(v)]\n        for i in range(v):\n            for j,k in ver:\n                d[i].append(dis[i][j][k])\n\n        dp = [[inf]*v for _ in range(1<<v)]\n        dp[1][0] = 0\n        for bits in range(1<<v):\n            for i in range(v):\n                if dp[bits][i] == inf:continue\n                for j in range(v):\n                    if bits&(1<<j):continue\n                    dp[bits|(1<<j)][j] = min(dp[bits|(1<<j)][j],\n                                             dp[bits][i]+d[i][j])\n\n        ans = inf\n        for i in range(1,v):ans = min(ans,dp[(1<<v)-1][i])\n        print (ans if ans!=inf else -1)\n\n\nif __name__ == '__main__':\n    main()\n\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nINF = 10 ** 10\n\ndirect = ((0, -1), (0, 1), (-1, 0), (1, 0))\n\ndef dist(fr, to, mp):\n  que = []\n  heappush(que, (0, fr))\n  visited = [[False] * len(mp[0]) for _ in range(len(mp))]\n  visited[fr[1]][fr[0]] = True\n  while que:\n    d, point = heappop(que)\n    x, y = point\n    for dx, dy in direct:\n      nx, ny = x + dx, y + dy\n      if (nx, ny) == to:\n        return d + 1\n      if not visited[ny][nx] and mp[ny][nx] != \"x\":\n        visited[ny][nx] = True\n        heappush(que, (d + 1, (nx, ny)))\n  else:\n    return -1\n\ndef my_hash(rest):\n  return sum([10 ** i for i in rest])\n\ndef shortest(fr, rest, edges, dp):\n  if rest == set():\n    return 0\n  if my_hash(rest) in dp[fr]:\n    return dp[fr][my_hash(rest)]\n  ret = INF\n  for d, to in edges[fr]:\n    if to in rest:\n      score = d + shortest(to, rest - {to}, edges, dp)\n      if score < ret:\n        ret = score\n  dp[fr][my_hash(rest)] = ret\n  return ret\n\ndef main():\n  while True:\n    w, h = map(int, input().split())\n    if w == 0:\n      break\n    mp = [\"x\" + input() + \"x\" for _ in range(h)]\n    mp.insert(0, \"x\" * (w + 2))\n    mp.append(\"x\" * (w + 2))\n    \n    stains = []\n    for y in range(1, h + 1):\n      for x in range(1, w + 1):\n        if mp[y][x] == \"*\":\n          stains.append((x, y))\n        elif mp[y][x] == \"o\":\n          start = len(stains)\n          stains.append((x, y))\n    \n    stain_num = len(stains)\n    edges = [[] for _ in range(stain_num)]\n    miss_flag = False\n    for i in range(stain_num):\n      for j in range(i + 1, stain_num):\n        fr = stains[i]\n        to = stains[j]\n        d = dist(fr, to, mp)\n        if d == -1:\n          miss_flag = True\n        edges[i].append((d, j))\n        edges[j].append((d, i))\n    if miss_flag:\n      print(-1)\n      continue\n\n    dp = [{} for _ in range(stain_num)]\n    print(shortest(start, {i for i in range(stain_num) if i != start}, edges, dp))\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nINF = 10 ** 20\n\ndirect = ((0, -1), (0, 1), (-1, 0), (1, 0))\n\ndef dist(fr, to, mp):\n  que = []\n  heappush(que, (0, fr))\n  visited = [[False] * len(mp[0]) for _ in range(len(mp))]\n  visited[fr[1]][fr[0]] = True\n  while que:\n    d, point = heappop(que)\n    x, y = point\n    for dx, dy in direct:\n      nx, ny = x + dx, y + dy\n      if (nx, ny) == to:\n        return d + 1\n      if not visited[ny][nx] and mp[ny][nx] == \".\":\n        visited[ny][nx] = True\n        heappush(que, (d + 1, (nx, ny)))\n  else:\n    return -1\n\ndef shortest(fr, rest, edges):\n  if rest == []:\n    return 0\n  ret = INF\n  for d, to in edges[fr]:\n    if to in rest:\n      ret = min(ret, d + shortest(to, [i for i in rest if i != to], edges))\n  return ret\n\nwhile True:\n  w, h = map(int, input().split())\n  if w == 0:\n    break\n  mp = [\"x\" + input() + \"x\" for _ in range(h)]\n  mp.insert(0, \"x\" * (w + 2))\n  mp.append(\"x\" * (w + 2))\n  \n  stains = []\n  for y in range(1, h + 1):\n    for x in range(1, w + 1):\n      if mp[y][x] in (\"*\", \"o\"):\n        stains.append((x, y))\n  \n  stain_num = len(stains)\n  edges = [[] for _ in range(stain_num)]\n  miss_flag = False\n  for i in range(stain_num):\n    for j in range(i + 1, stain_num):\n      fr = stains[i]\n      to = stains[j]\n      d = dist(fr, to, mp)\n      if d == -1:\n        miss_flag = True\n      edges[i].append((d, j))\n      edges[j].append((d, i))\n  if miss_flag:\n    print(-1)\n    continue\n\n  print(shortest(0, [i for i in range(1, stain_num)], edges))\n"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::fmt;\nuse std::i32::{MAX};\nuse std::cmp::{Ordering, min, max };\nuse std::ops::{Add, Sub, Mul, Div, Neg, Index, IndexMut, SubAssign, Range};\nuse std::collections::{BTreeMap, VecDeque, BinaryHeap, BTreeSet, HashMap};\nuse std::fmt::{Display, Formatter, Error};\nuse std::str::Chars;\n\nfn show<T: Display>(vec: &Vec<T>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else {\n        print!(\"[{}\", vec[0]);\n        for i in 1 .. vec.len() {\n            print!(\", {}\", vec[i]);\n        }\n        println!(\"]\");\n    }\n}\nfn show2<T: Display>(vec: &Vec<Vec<T>>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else {\n        for l in vec {\n            show(l);\n        }\n    }\n}\nmacro_rules! read_lines{\n    ($count: expr; $delimiter: expr; $ty: ty) => {{\n        let line_count = $count;\n        let mut vec: Vec<Vec<$ty>> = Vec::with_capacity(line_count);\n        for _ in 0 .. line_count {\n            vec.push(read_line!($delimiter; $ty));\n        }\n        vec\n    }};\n    ($count: expr; $ty: ty) => {{\n        let line_count = $count;\n        let mut vec: Vec<$ty> = Vec::with_capacity(line_count);\n        for _ in 0 .. line_count {\n            vec.push(read_value!());\n        }\n        vec\n    }}\n}\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! read_value{\n    () => {\n        read_line!().trim().parse().ok().unwrap()\n    }\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\n\nmacro_rules! let_mut_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let mut $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\nstruct ValueWithKey<V, K> {\n    value: V,\n    key: K\n}\nimpl <V, K: PartialOrd> Ord for ValueWithKey<V, K> {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.key.partial_cmp(&other.key).unwrap()\n    }\n}\nimpl <V, K: PartialOrd> PartialOrd for ValueWithKey<V, K> {\n    fn partial_cmp(&self, other: &ValueWithKey<V, K>) -> Option<Ordering> {\n        other.key.partial_cmp(&self.key)\n    }\n}\nimpl <V, K: PartialEq> PartialEq for ValueWithKey<V, K> {\n    fn eq(&self, other: &Self) -> bool {\n        other.key.eq(&self.key)\n    }\n}\nimpl <V, K: PartialEq> Eq for ValueWithKey<V, K>{}\n#[derive(Copy, Clone)]\nstruct Coordinate {\n    x: usize, y: usize\n}\nfn abs(value: i32) -> i32 {\n    if value < 0 {\n        -1\n    }else if value == 0{\n        0\n    }else {\n        1\n    }\n}\nimpl Coordinate {\n    fn manhattan_distance(&self, that: &Self) -> i32 {\n        abs(self.x as i32 - that.x as i32) + abs(self.y as i32 - that.y as i32)\n    }\n}\nfn cal_min_distance(state: &Vec<String>, from: Coordinate) -> Vec<Vec<i32>> {\n    let height = state.len() as i32;\n    let width = state[0].len() as i32;\n    let mut depth = vec![vec![-1; state[0].len()]; state.len()];\n    let mut queue = VecDeque::new();\n    depth[from.y][from.x] = 0;\n    queue.push_back(from);\n    while let Some(Coordinate{x: cx, y: cy}) = queue.pop_front() {\n        for dx in -1i32 .. 2i32 {\n            if dx == 0 || cx as i32 + dx < 0 || width <= cx as i32 + dx {\n                continue\n            }\n            let x = (cx as i32 + dx) as usize;\n            let y = cy;\n            if  depth[y][x] == -1 && state[y].chars().nth(x).map_or(false, |c| c != 'x'){\n                depth[y][x] = depth[cy][cx] + 1;\n                queue.push_back(Coordinate{x: x, y: y});\n            }\n        }\n        for dy in -1i32 .. 2 {\n            if dy == 0 || cy as i32 + dy < 0 || height <= cy as i32 + dy {\n                continue\n            }\n            let x = cx;\n            let y = (cy as i32 + dy) as usize;\n            if  depth[y][x] == -1 && state[y].chars().nth(x).map_or(false, |c| c != 'x'){\n                depth[y][x] = depth[cy][cx] + 1;\n                queue.push_back(Coordinate{x: x, y: y});\n            }\n        }\n    }\n    depth\n}\nfn main() {\n    loop {\n        let_all!(w: usize, h: usize); if w == 0 && h == 0 {break;}\n        let state = read_lines!(h; String);\n        let mut garbage = Vec::new();\n        let mut start = Coordinate{x: 0, y: 0};\n        for i in 0 .. h {\n            for j in 0 .. w {\n                match state[i].chars().nth(j) {\n                    Some('*') =>\n                        garbage.push(Coordinate{x: j, y: i}),\n                    Some('o') =>\n                        start = Coordinate{x: j, y: i},\n                    _ => {}\n                }\n            }\n        }\n        let garbage = garbage; let start = start;\n        let mut min_distance = vec![vec![-1; garbage.len()]; garbage.len()];\n        for i in 0 .. garbage.len() {\n            let distance = cal_min_distance(&state, garbage[i]);\n            for (j, g) in garbage.iter().enumerate() {\n                min_distance[i][j] = distance[g.y][g.x];\n            }\n        }\n        let min_distance = min_distance;\n        let mut min_time: Vec<Vec<i32>> = vec![vec![std::i32::MAX; 1 << garbage.len()]; garbage.len()];\n        let mut heap = BinaryHeap::new();\n        {\n            let distance = cal_min_distance(&state, start);\n            for (i, g) in garbage.iter().enumerate() {\n                min_time[i][1 << i] = distance[g.y][g.x];\n                heap.push(ValueWithKey{value: (i, 1 << i), key: min_time[i][1 << i]});\n            }\n        }\n        while let Some(ValueWithKey{value: (current, state), key: cost}) = heap.pop() {\n            if min_time[current][state] == cost {\n                for (next, g) in garbage.iter().enumerate() {\n                    if (state & (1 << next)) == 0 {\n                        if min_distance[current][next] != -1 && min_time[next][state | (1 << next)] > cost + min_distance[current][next] {\n                            min_time[next][state | (1 << next)] = cost + min_distance[current][next];\n                            heap.push(ValueWithKey{value: (next, state | (1 << next)), key: cost + min_distance[current][next]})\n                        }\n                    }\n                }\n            }\n        }\n        if let Some(time) = min_time.iter().filter_map(|l|l.last()).filter(|&t| t != &std::i32::MAX).min() {\n            println!(\"{}\", time);\n        }else {\n            println!(\"-1\");\n        }\n    }\n}\n\n"
  }
]