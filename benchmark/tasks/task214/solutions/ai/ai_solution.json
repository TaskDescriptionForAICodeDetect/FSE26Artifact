[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_SIZE 20\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point pos;\n    int moves;\n} Node;\n\nint rows, cols;\nchar grid[MAX_SIZE][MAX_SIZE];\nint visited[MAX_SIZE][MAX_SIZE];\nint dist[MAX_SIZE][MAX_SIZE][MAX_SIZE][MAX_SIZE];\nPoint dirs[4] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\nPoint dirty[MAX_SIZE * MAX_SIZE];\nint dirty_count = 0;\nint min_moves = INT_MAX;\n\nvoid bfs(Point start) {\n    Node queue[MAX_SIZE * MAX_SIZE];\n    int front = 0, rear = 0;\n    memset(visited, 0, sizeof(visited));\n    queue[rear++] = (Node){start, 0};\n    visited[start.x][start.y] = 1;\n\n    while (front < rear) {\n        Node current = queue[front++];\n        dist[start.x][start.y][current.pos.x][current.pos.y] = current.moves;\n\n        for (int i = 0; i < 4; i++) {\n            int nx = current.pos.x + dirs[i].x;\n            int ny = current.pos.y + dirs[i].y;\n            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && grid[nx][ny] != 'x' && !visited[nx][ny]) {\n                visited[nx][ny] = 1;\n                queue[rear++] = (Node){(Point){nx, ny}, current.moves + 1};\n            }\n        }\n    }\n}\n\nvoid permute(int *order, int *used, int k) {\n    if (k == dirty_count) {\n        int total = 0;\n        Point current = {0, 0};\n        for (int i = 0; i < dirty_count; i++) {\n            Point next = dirty[order[i]];\n            if (dist[current.x][current.y][next.x][next.y] == -1) {\n                return;\n            }\n            total += dist[current.x][current.y][next.x][next.y];\n            current = next;\n        }\n        if (total < min_moves) {\n            min_moves = total;\n        }\n        return;\n    }\n\n    for (int i = 0; i < dirty_count; i++) {\n        if (!used[i]) {\n            used[i] = 1;\n            order[k] = i;\n            permute(order, used, k + 1);\n            used[i] = 0;\n        }\n    }\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &cols, &rows);\n        if (rows == 0 && cols == 0) break;\n\n        dirty_count = 0;\n        min_moves = INT_MAX;\n        Point start;\n\n        for (int i = 0; i < rows; i++) {\n            scanf(\"%s\", grid[i]);\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == 'o') {\n                    start.x = i;\n                    start.y = j;\n                } else if (grid[i][j] == '*') {\n                    dirty[dirty_count].x = i;\n                    dirty[dirty_count].y = j;\n                    dirty_count++;\n                }\n            }\n        }\n\n        memset(dist, -1, sizeof(dist));\n\n        bfs(start);\n        for (int i = 0; i < dirty_count; i++) {\n            bfs(dirty[i]);\n        }\n\n        int order[MAX_SIZE * MAX_SIZE];\n        int used[MAX_SIZE * MAX_SIZE] = {0};\n        if (dirty_count > 0) {\n            permute(order, used, 0);\n        } else {\n            min_moves = 0;\n        }\n\n        printf(\"%d\\n\", min_moves == INT_MAX ? -1 : min_moves);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:09:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass CleaningRobotSolution {\n    private static final int[] dx = {0, 0, 1, -1};\n    private static final int[] dy = {1, -1, 0, 0};\n\n    public static int minimumCleaningMoves(char[][] room) {\n        int rows = room.length;\n        int cols = room[0].length;\n        List<int[]> dirtyTiles = new ArrayList<>();\n        int[] start = null;\n\n        // Find start and dirty tiles\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                if (room[r][c] == 'S') start = new int[]{r, c};\n                if (room[r][c] == 'D') dirtyTiles.add(new int[]{r, c});\n            }\n        }\n\n        // Try all possible cleaning orders\n        int minMoves = Integer.MAX_VALUE;\n        for (List<int[]> order : generatePermutations(dirtyTiles)) {\n            int currentMoves = calculateMoves(room, start, order);\n            if (currentMoves != -1) {\n                minMoves = Math.min(minMoves, currentMoves);\n            }\n        }\n\n        return minMoves == Integer.MAX_VALUE ? -1 : minMoves;\n    }\n\n    private static int calculateMoves(char[][] room, int[] start, List<int[]> order) {\n        int totalMoves = 0;\n        int[] current = start;\n\n        for (int[] tile : order) {\n            int pathLength = bfs(room, current, tile);\n            if (pathLength == -1) return -1;\n            totalMoves += pathLength;\n            current = tile;\n        }\n\n        return totalMoves;\n    }\n\n    private static int bfs(char[][] room, int[] start, int[] end) {\n        int rows = room.length;\n        int cols = room[0].length;\n        boolean[][] visited = new boolean[rows][cols];\n        Queue<int[]> queue = new LinkedList<>();\n        Queue<Integer> distances = new LinkedList<>();\n\n        queue.offer(start);\n        distances.offer(0);\n        visited[start[0]][start[1]] = true;\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int dist = distances.poll();\n\n            if (current[0] == end[0] && current[1] == end[1]) {\n                return dist;\n            }\n\n            for (int i = 0; i < 4; i++) {\n                int nx = current[0] + dx[i];\n                int ny = current[1] + dy[i];\n\n                if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && \n                    room[nx][ny] != '#' && !visited[nx][ny]) {\n                    queue.offer(new int[]{nx, ny});\n                    distances.offer(dist + 1);\n                    visited[nx][ny] = true;\n                }\n            }\n        }\n\n        return -1;\n    }\n\n    private static List<List<int[]>> generatePermutations(List<int[]> tiles) {\n        List<List<int[]>> result = new ArrayList<>();\n        backtrack(tiles, new ArrayList<>(), new boolean[tiles.size()], result);\n        return result;\n    }\n\n    private static void backtrack(List<int[]> tiles, List<int[]> current, \n                                   boolean[] used, List<List<int[]>> result) {\n        if (current.size() == tiles.size()) {\n            result.add(new ArrayList<>(current));\n            return;\n        }\n\n        for (int i = 0; i < tiles.size(); i++) {\n            if (used[i]) continue;\n            current.add(tiles.get(i));\n            used[i] = true;\n            backtrack(tiles, current, used, result);\n            current.remove(current.size() - 1);\n            used[i] = false;\n        }\n    }\n}",
    "timestamp": "2025-08-05 19:09:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n#include <unordered_set>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    Point(int x, int y) : x(x), y(y) {}\n    bool operator==(const Point &other) const {\n        return x == other.x && y == other.y;\n    }\n};\n\nnamespace std {\n    template<>\n    struct hash<Point> {\n        size_t operator()(const Point &p) const {\n            return hash<int>()(p.x) ^ hash<int>()(p.y);\n        }\n    };\n}\n\nint minMovesToCleanAll(vector<vector<char>> &grid) {\n    int rows = grid.size();\n    if (rows == 0) return -1;\n    int cols = grid[0].size();\n    \n    vector<Point> dirty;\n    Point start(0, 0);\n    \n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            if (grid[i][j] == 'd') {\n                dirty.emplace_back(i, j);\n            } else if (grid[i][j] == 'r') {\n                start = Point(i, j);\n            }\n        }\n    }\n    \n    if (dirty.empty()) return 0;\n    \n    // Precompute distances from every dirty tile and the robot to every other tile\n    vector<vector<vector<int>>> distances(dirty.size() + 1, vector<vector<int>>(rows, vector<int>(cols, -1)));\n    \n    auto bfs = [&](const Point &source, int idx) {\n        queue<Point> q;\n        q.push(source);\n        distances[idx][source.x][source.y] = 0;\n        \n        int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        \n        while (!q.empty()) {\n            Point p = q.front();\n            q.pop();\n            \n            for (auto &dir : dirs) {\n                int nx = p.x + dir[0];\n                int ny = p.y + dir[1];\n                \n                if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && grid[nx][ny] != 'f' && distances[idx][nx][ny] == -1) {\n                    distances[idx][nx][ny] = distances[idx][p.x][p.y] + 1;\n                    q.emplace(nx, ny);\n                }\n            }\n        }\n    };\n    \n    // Compute distances from robot\n    bfs(start, dirty.size());\n    \n    // Check if robot can reach all dirty tiles\n    for (auto &d : dirty) {\n        if (distances[dirty.size()][d.x][d.y] == -1) {\n            return -1;\n        }\n    }\n    \n    // Compute distances between dirty tiles\n    for (int i = 0; i < dirty.size(); ++i) {\n        bfs(dirty[i], i);\n    }\n    \n    // TSP DP\n    int n = dirty.size();\n    vector<vector<int>> dp(1 << n, vector<int>(n, INT_MAX));\n    \n    for (int i = 0; i < n; ++i) {\n        int mask = 1 << i;\n        int dist = distances[dirty.size()][dirty[i].x][dirty[i].y];\n        if (dist == -1) return -1;\n        dp[mask][i] = dist;\n    }\n    \n    for (int mask = 1; mask < (1 << n); ++mask) {\n        for (int last = 0; last < n; ++last) {\n            if (!(mask & (1 << last))) continue;\n            if (dp[mask][last] == INT_MAX) continue;\n            \n            for (int next = 0; next < n; ++next) {\n                if (mask & (1 << next)) continue;\n                int new_mask = mask | (1 << next);\n                int dist = distances[last][dirty[next].x][dirty[next].y];\n                if (dist == -1) return -1;\n                if (dp[new_mask][next] > dp[mask][last] + dist) {\n                    dp[new_mask][next] = dp[mask][last] + dist;\n                }\n            }\n        }\n    }\n    \n    int final_mask = (1 << n) - 1;\n    int min_moves = *min_element(dp[final_mask].begin(), dp[final_mask].end());\n    return min_moves == INT_MAX ? -1 : min_moves;\n}\n\nint main() {\n    int rows, cols;\n    cin >> rows >> cols;\n    vector<vector<char>> grid(rows, vector<char>(cols));\n    \n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            cin >> grid[i][j];\n        }\n    }\n    \n    int result = minMovesToCleanAll(grid);\n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:11:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_ROWS 20\n#define MAX_COLS 20\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint rows, cols;\nchar grid[MAX_ROWS][MAX_COLS];\nint visited[MAX_ROWS][MAX_COLS];\nint dirty_count;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint is_valid(int x, int y) {\n    return x >= 0 && x < rows && y >= 0 && y < cols && grid[x][y] != 'x';\n}\n\nint bfs(Point start, Point end) {\n    memset(visited, -1, sizeof(visited));\n    Point queue[MAX_ROWS * MAX_COLS];\n    int front = 0, rear = 0;\n\n    queue[rear++] = start;\n    visited[start.x][start.y] = 0;\n\n    while (front < rear) {\n        Point current = queue[front++];\n\n        if (current.x == end.x && current.y == end.y)\n            return visited[current.x][current.y];\n\n        for (int i = 0; i < 4; i++) {\n            int nx = current.x + dx[i];\n            int ny = current.y + dy[i];\n\n            if (is_valid(nx, ny) && visited[nx][ny] == -1) {\n                Point next = {nx, ny};\n                queue[rear++] = next;\n                visited[nx][ny] = visited[current.x][current.y] + 1;\n            }\n        }\n    }\n    return -1;\n}\n\nint solve() {\n    Point dirty[MAX_ROWS * MAX_COLS];\n    Point robot;\n    int total_moves = 0;\n\n    dirty_count = 0;\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (grid[i][j] == '*') {\n                dirty[dirty_count].x = i;\n                dirty[dirty_count].y = j;\n                dirty_count++;\n            }\n            if (grid[i][j] == 'o') {\n                robot.x = i;\n                robot.y = j;\n            }\n        }\n    }\n\n    for (int i = 0; i < dirty_count; i++) {\n        int min_dist = INT_MAX;\n        int best_index = -1;\n\n        for (int j = 0; j < dirty_count; j++) {\n            if (grid[dirty[j].x][dirty[j].y] == '*') {\n                int dist = bfs(robot, dirty[j]);\n                if (dist != -1 && dist < min_dist) {\n                    min_dist = dist;\n                    best_index = j;\n                }\n            }\n        }\n\n        if (best_index == -1) return -1;\n\n        total_moves += min_dist;\n        robot = dirty[best_index];\n        grid[robot.x][robot.y] = '.';\n    }\n\n    return total_moves;\n}\n\nint main() {\n    while (scanf(\"%d %d\", &cols, &rows) == 2 && rows && cols) {\n        getchar();\n\n        for (int i = 0; i < rows; i++) {\n            fgets(grid[i], sizeof(grid[i]), stdin);\n            grid[i][strcspn(grid[i], \"\\n\")] = '\\0';\n        }\n\n        int result = solve();\n        if (result == -1)\n            printf(\"impossible\\n\");\n        else\n            printf(\"%d\\n\", result);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:12:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minimumMoves(vector<vector<char>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        vector<pair<int, int>> dirty;\n        int startX = -1, startY = -1;\n\n        // Find dirty tiles and starting position\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 'D') dirty.push_back({i, j});\n                if (grid[i][j] == 'S') {\n                    startX = i;\n                    startY = j;\n                }\n            }\n        }\n\n        if (dirty.empty()) return 0;\n\n        int minMoves = INT_MAX;\n        sort(dirty.begin(), dirty.end());\n\n        do {\n            int totalMoves = 0;\n            int currX = startX, currY = startY;\n\n            for (auto& tile : dirty) {\n                int moves = bfs(grid, currX, currY, tile.first, tile.second);\n                if (moves == -1) {\n                    totalMoves = -1;\n                    break;\n                }\n                totalMoves += moves;\n                currX = tile.first;\n                currY = tile.second;\n            }\n\n            if (totalMoves != -1) {\n                minMoves = min(minMoves, totalMoves);\n            }\n        } while (next_permutation(dirty.begin(), dirty.end()));\n\n        return minMoves == INT_MAX ? -1 : minMoves;\n    }\n\nprivate:\n    int bfs(vector<vector<char>>& grid, int startX, int startY, int endX, int endY) {\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\n        queue<pair<int, int>> q;\n        vector<vector<int>> dist(m, vector<int>(n, -1));\n\n        q.push({startX, startY});\n        visited[startX][startY] = true;\n        dist[startX][startY] = 0;\n\n        vector<pair<int, int>> directions = {{0,1}, {1,0}, {-1,0}, {0,-1}};\n\n        while (!q.empty()) {\n            auto [x, y] = q.front();\n            q.pop();\n\n            if (x == endX && y == endY) return dist[x][y];\n\n            for (auto& [dx, dy] : directions) {\n                int nx = x + dx, ny = y + dy;\n                if (nx >= 0 && nx < m && ny >= 0 && ny < n && \n                    grid[nx][ny] != '#' && !visited[nx][ny]) {\n                    q.push({nx, ny});\n                    visited[nx][ny] = true;\n                    dist[nx][ny] = dist[x][y] + 1;\n                }\n            }\n        }\n\n        return -1;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector<vector<char>> grid = {\n        {'S', '.', '.', '.'},\n        {'#', '#', '#', '.'},\n        {'D', '.', '.', '.'}\n    };\n    cout << sol.minimumMoves(grid) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 19:12:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Point {\n    int x, y;\n    Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n    \n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Point point = (Point) o;\n        return x == point.x && y == point.y;\n    }\n    \n    @Override\n    public int hashCode() {\n        return Objects.hash(x, y);\n    }\n}\n\npublic class CleaningRobot {\n    private static int[] dx = {-1, 1, 0, 0};\n    private static int[] dy = {0, 0, -1, 1};\n    \n    public static int minMovesToCleanAll(char[][] grid) {\n        int m = grid.length;\n        if (m == 0) return -1;\n        int n = grid[0].length;\n        \n        List<Point> dirty = new ArrayList<>();\n        Point start = null;\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 'd') {\n                    dirty.add(new Point(i, j));\n                } else if (grid[i][j] == 'r') {\n                    start = new Point(i, j);\n                }\n            }\n        }\n        \n        if (start == null || dirty.isEmpty()) return 0;\n        \n        int[][] dist = new int[dirty.size() + 1][dirty.size() + 1];\n        Map<Point, Integer> dirtyIndex = new HashMap<>();\n        for (int i = 0; i < dirty.size(); i++) {\n            dirtyIndex.put(dirty.get(i), i);\n        }\n        \n        List<Point> allPoints = new ArrayList<>();\n        allPoints.add(start);\n        allPoints.addAll(dirty);\n        \n        for (int i = 0; i < allPoints.size(); i++) {\n            for (int j = i + 1; j < allPoints.size(); j++) {\n                int d = bfs(grid, allPoints.get(i), allPoints.get(j));\n                if (d == -1) return -1;\n                dist[i][j] = d;\n                dist[j][i] = d;\n            }\n        }\n        \n        int[][] dp = new int[1 << dirty.size()][dirty.size()];\n        for (int[] row : dp) {\n            Arrays.fill(row, -1);\n        }\n        \n        for (int i = 0; i < dirty.size(); i++) {\n            dp[1 << i][i] = dist[0][i + 1];\n        }\n        \n        for (int mask = 1; mask < (1 << dirty.size()); mask++) {\n            for (int last = 0; last < dirty.size(); last++) {\n                if ((mask & (1 << last)) == 0) continue;\n                if (dp[mask][last] == -1) continue;\n                \n                for (int next = 0; next < dirty.size(); next++) {\n                    if ((mask & (1 << next)) != 0) continue;\n                    int newMask = mask | (1 << next);\n                    int newDist = dp[mask][last] + dist[last + 1][next + 1];\n                    if (dp[newMask][next] == -1 || newDist < dp[newMask][next]) {\n                        dp[newMask][next] = newDist;\n                    }\n                }\n            }\n        }\n        \n        int minMoves = Integer.MAX_VALUE;\n        int fullMask = (1 << dirty.size()) - 1;\n        for (int i = 0; i < dirty.size(); i++) {\n            if (dp[fullMask][i] != -1 && dp[fullMask][i] < minMoves) {\n                minMoves = dp[fullMask][i];\n            }\n        }\n        \n        return minMoves == Integer.MAX_VALUE ? -1 : minMoves;\n    }\n    \n    private static int bfs(char[][] grid, Point start, Point end) {\n        int m = grid.length;\n        int n = grid[0].length;\n        boolean[][] visited = new boolean[m][n];\n        Queue<Point> queue = new LinkedList<>();\n        queue.offer(start);\n        visited[start.x][start.y] = true;\n        int steps = 0;\n        \n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                Point curr = queue.poll();\n                if (curr.x == end.x && curr.y == end.y) {\n                    return steps;\n                }\n                \n                for (int k = 0; k < 4; k++) {\n                    int nx = curr.x + dx[k];\n                    int ny = curr.y + dy[k];\n                    if (nx >= 0 && nx < m && ny >= 0 && ny < n && !visited[nx][ny] && grid[nx][ny] != 'f') {\n                        visited[nx][ny] = true;\n                        queue.offer(new Point(nx, ny));\n                    }\n                }\n            }\n            steps++;\n        }\n        return -1;\n    }\n    \n    public static void main(String[] args) {\n        char[][] grid = {\n            {'r', 'c', 'd'},\n            {'f', 'c', 'c'},\n            {'d', 'c', 'd'}\n        };\n        System.out.println(minMovesToCleanAll(grid));\n    }\n}",
    "timestamp": "2025-08-05 19:13:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef min_cleaning_moves(grid):\n    rows, cols = len(grid), len(grid[0])\n    \n    def adjacent_positions(x, y):\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] != 'F':\n                yield nx, ny\n    \n    dirty_positions = set()\n    start_positions = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 'D':\n                dirty_positions.add((r, c))\n            elif grid[r][c] == 'C':\n                start_positions.append((r, c))\n    \n    if not dirty_positions:\n        return 0  # No dirty tiles to clean\n    \n    queue = deque([(pos, 0) for pos in start_positions]) \n    visited = set(start_positions)\n    \n    while queue:\n        current_pos, steps = queue.popleft()\n        if current_pos in dirty_positions:\n            dirty_positions.remove(current_pos)\n\n        if not dirty_positions:\n            return steps\n\n        for next_pos in adjacent_positions(*current_pos):\n            if next_pos not in visited:\n                visited.add(next_pos)\n                queue.append((next_pos, steps + 1))\n    \n    return -1  # Impossible to clean all dirty tiles\n\n# Example usage:\ngrid = [\n    ['C', 'D', 'F'],\n    ['C', 'D', 'F'],\n    ['C', 'C', 'C']\n]\n\nprint(min_cleaning_moves(grid))",
    "timestamp": "2025-08-13 02:32:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class CleaningRobot {\n\n    private static final int[] dx = {-1, 1, 0, 0};\n    private static final int[] dy = {0, 0, -1, 1};\n\n    public static int minMovesToCleanAll(char[][] room) {\n        int rows = room.length, cols = room[0].length;\n        boolean[][] visited = new boolean[rows][cols];\n        Queue<int[]> queue = new LinkedList<>();\n        int dirtyCount = 0;\n\n        // Find the starting position and count dirty tiles\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (room[i][j] == 'R') {\n                    queue.offer(new int[]{i, j, 0});\n                    visited[i][j] = true;\n                }\n                if (room[i][j] == 'D') {\n                    dirtyCount++;\n                }\n            }\n        }\n\n        int cleaned = 0;\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0], y = current[1], moves = current[2];\n\n            // If on a dirty tile, clean it\n            if (room[x][y] == 'D') {\n                cleaned++;\n                room[x][y] = 'C'; // Mark as cleaned\n                if (cleaned == dirtyCount) {\n                    return moves;\n                }\n            }\n\n            // Explore adjacent tiles\n            for (int k = 0; k < 4; k++) {\n                int nx = x + dx[k], ny = y + dy[k];\n                if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && !visited[nx][ny] && room[nx][ny] != 'F') {\n                    visited[nx][ny] = true;\n                    queue.offer(new int[]{nx, ny, moves + 1});\n                }\n            }\n        }\n\n        // Check if not all dirty tiles were cleaned\n        return cleaned == dirtyCount ? cleaned : -1;\n    }\n\n    public static void main(String[] args) {\n        char[][] room = {\n            {'R', 'D', 'F', 'C'},\n            {'D', 'D', 'F', 'D'},\n            {'F', 'C', 'D', 'C'},\n            {'C', 'D', 'D', 'C'}\n        };\n        int result = minMovesToCleanAll(room);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-13 02:33:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX 100\n#define INF INT_MAX\n\ntypedef struct {\n    int x, y, moves;\n} Position;\n\nint dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};\n\nint isValid(int x, int y, int rows, int cols, char grid[MAX][MAX], int visited[MAX][MAX]) {\n    return x >= 0 && x < rows && y >= 0 && y < cols && grid[x][y] != 'F' && !visited[x][y];\n}\n\nint bfs(int startX, int startY, int rows, int cols, char grid[MAX][MAX], int dirtyTiles) {\n    Position queue[MAX * MAX];\n    int front = 0, rear = 0;\n    int visited[MAX][MAX] = {0};\n    queue[rear++] = (Position){startX, startY, 0};\n    visited[startX][startY] = 1;\n    int cleanedTiles = 0;\n    \n    while (front < rear) {\n        Position current = queue[front++];\n        \n        if (grid[current.x][current.y] == 'D')\n            cleanedTiles++;\n        \n        if (cleanedTiles == dirtyTiles)\n            return current.moves;\n        \n        for (int i = 0; i < 4; i++) {\n            int newX = current.x + dx[i], newY = current.y + dy[i];\n            if (isValid(newX, newY, rows, cols, grid, visited)) {\n                visited[newX][newY] = 1;\n                queue[rear++] = (Position){newX, newY, current.moves + 1};\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int rows, cols;\n    char grid[MAX][MAX];\n    \n    scanf(\"%d %d\\n\", &rows, &cols);\n    int startX = -1, startY = -1, dirtyTiles = 0;\n    \n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            scanf(\"%c\", &grid[i][j]);\n            if (grid[i][j] == 'R') {\n                startX = i;\n                startY = j;\n            }\n            if (grid[i][j] == 'D')\n                dirtyTiles++;\n        }\n        scanf(\"\\n\"); // Consume newline\n    }\n    \n    if (startX == -1 || startY == -1 || dirtyTiles == 0) {\n        printf(\"0\\n\");\n        return 0;\n    }\n    \n    int result = bfs(startX, startY, rows, cols, grid, dirtyTiles);\n    if (result != -1)\n        printf(\"%d\\n\", result);\n    else\n        printf(\"-1\\n\");\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 02:33:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef min_cleaning_moves(grid):\n    rows, cols = len(grid), len(grid[0])\n    dirty_tiles = []\n    start = None\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 'D':\n                dirty_tiles.append((r, c))\n            elif grid[r][c] == 'S':\n                start = (r, c)\n\n    def is_valid(r, c):\n        return 0 <= r < rows and 0 <= c < cols and grid[r][c] != '#'\n\n    def bfs(start, target):\n        queue = deque([(start[0], start[1], 0)])\n        visited = set([(start[0], start[1])])\n\n        while queue:\n            r, c, moves = queue.popleft()\n\n            if (r, c) == target:\n                return moves\n\n            for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:\n                nr, nc = r + dr, c + dc\n                if is_valid(nr, nc) and (nr, nc) not in visited:\n                    queue.append((nr, nc, moves + 1))\n                    visited.add((nr, nc))\n\n        return float('inf')\n\n    def clean_all_tiles():\n        total_moves = 0\n        current = start\n\n        while dirty_tiles:\n            min_dist = float('inf')\n            best_tile = None\n\n            for tile in dirty_tiles:\n                dist = bfs(current, tile)\n                if dist < min_dist:\n                    min_dist = dist\n                    best_tile = tile\n\n            if min_dist == float('inf'):\n                return -1\n\n            total_moves += min_dist\n            current = best_tile\n            dirty_tiles.remove(best_tile)\n\n        return total_moves\n\n    return clean_all_tiles()",
    "timestamp": "2025-08-13 02:33:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef main():\n    rows, cols = map(int, sys.stdin.readline().split())\n    grid = []\n    dirty = []\n    start = None\n    for i in range(rows):\n        line = sys.stdin.readline().strip()\n        grid.append(line)\n        for j, char in enumerate(line):\n            if char == 'o':\n                start = (i, j)\n            elif char == '*':\n                dirty.append((i, j))\n    \n    if not dirty:\n        print(0)\n        return\n    \n    # Precompute all pairwise distances between dirty tiles and start\n    positions = [start] + dirty\n    n = len(positions)\n    dist = [[-1] * n for _ in range(n)]\n    \n    for i in range(n):\n        r, c = positions[i]\n        q = deque()\n        q.append((r, c))\n        visited = [[-1] * cols for _ in range(rows)]\n        visited[r][c] = 0\n        while q:\n            x, y = q.popleft()\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] != 'x' and visited[nx][ny] == -1:\n                    visited[nx][ny] = visited[x][y] + 1\n                    q.append((nx, ny))\n        for j in range(n):\n            x, y = positions[j]\n            dist[i][j] = visited[x][y]\n    \n    # Check if all positions are reachable\n    for i in range(n):\n        for j in range(n):\n            if dist[i][j] == -1:\n                print(-1)\n                return\n    \n    # DP for TSP\n    m = len(dirty)\n    dp = [[float('inf')] * m for _ in range(1 << m)]\n    for i in range(m):\n        dp[1 << i][i] = dist[0][i + 1]\n    \n    for mask in range(1 << m):\n        for last in range(m):\n            if not (mask & (1 << last)):\n                continue\n            for next_node in range(m):\n                if mask & (1 << next_node):\n                    continue\n                new_mask = mask | (1 << next_node)\n                if dp[new_mask][next_node] > dp[mask][last] + dist[last + 1][next_node + 1]:\n                    dp[new_mask][next_node] = dp[mask][last] + dist[last + 1][next_node + 1]\n    \n    min_moves = min(dp[(1 << m) - 1][i] for i in range(m))\n    print(min_moves if min_moves != float('inf') else -1)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 02:33:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\n// Directions for moving up, down, left, right\nconst vector<pair<int, int>> directions = {\n    {0, 1}, {1, 0}, {0, -1}, {-1, 0}\n};\n\nbool isValid(int x, int y, int rows, int cols, vector<vector<char>> &grid) {\n    return x >= 0 && x < rows && y >= 0 && y < cols && grid[x][y] != 'F';\n}\n\nint bfs(int startX, int startY, vector<vector<char>> &grid, int dirtyCount) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    queue<tuple<int, int, int>> q; // (x, y, steps)\n    q.push({startX, startY, 0});\n    vector<vector<bool>> visited(rows, vector<bool>(cols, false));\n    visited[startX][startY] = true;\n\n    int cleanCount = 0;\n    \n    while (!q.empty()) {\n        auto [x, y, steps] = q.front();\n        q.pop();\n        \n        if (grid[x][y] == 'D') {\n            cleanCount++;\n            grid[x][y] = 'C'; // Clean the tile\n            if (cleanCount == dirtyCount) return steps;\n        }\n        \n        for (auto [dx, dy] : directions) {\n            int nx = x + dx;\n            int ny = y + dy;\n            if (isValid(nx, ny, rows, cols, grid) && !visited[nx][ny]) {\n                visited[nx][ny] = true;\n                q.push({nx, ny, steps + 1});\n            }\n        }\n    }\n    return -1; // Impossible to clean all dirty tiles\n}\n\nint minMovesToClean(vector<vector<char>> &grid) {\n    int rows = grid.size();\n    if (rows == 0) return 0;\n    int cols = grid[0].size();\n    \n    int startX = -1, startY = -1, dirtyCount = 0;\n    \n    // Find the starting position of the robot and count dirty tiles\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            if (grid[i][j] == 'R') {\n                startX = i;\n                startY = j;\n            }\n            if (grid[i][j] == 'D') {\n                dirtyCount++;\n            }\n        }\n    }\n    \n    if (dirtyCount == 0) return 0;\n    if (startX == -1 || startY == -1) return -1;\n\n    return bfs(startX, startY, grid, dirtyCount);\n}\n\nint main() {\n    int rows, cols;\n    cin >> rows >> cols;\n    vector<vector<char>> grid(rows, vector<char>(cols));\n    \n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            cin >> grid[i][j];\n        }\n    }\n    \n    int result = minMovesToClean(grid);\n    \n    if (result == -1) {\n        cout << \"Impossible\" << endl;\n    } else {\n        cout << result << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:06:38"
  }
]