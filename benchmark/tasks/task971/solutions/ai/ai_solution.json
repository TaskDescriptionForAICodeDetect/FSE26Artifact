[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_H 30\n#define MAX_W 30\n\nint H, W, K;\nint board[MAX_H][MAX_W];\nint tempBoard[MAX_H][MAX_W];\n\nvoid dropStones(int grid[MAX_H][MAX_W]) {\n    for (int j = 0; j < W; j++) {\n        int writePos = H - 1;\n        for (int i = H - 1; i >= 0; i--) {\n            if (grid[i][j] != 0) {\n                grid[writePos][j] = grid[i][j];\n                writePos--;\n            }\n        }\n        for (int i = writePos; i >= 0; i--) {\n            grid[i][j] = 0;\n        }\n    }\n}\n\nint checkAndErase(int grid[MAX_H][MAX_W]) {\n    int erased[MAX_H][MAX_W] = {0};\n    int anyErased = 0;\n\n    for (int i = 0; i < H; i++) {\n        int currStreak = 1;\n        int currNum = grid[i][0];\n        \n        for (int j = 1; j < W; j++) {\n            if (grid[i][j] == currNum && currNum != 0) {\n                currStreak++;\n            } else {\n                if (currStreak >= K) {\n                    for (int k = j - currStreak; k < j; k++) {\n                        erased[i][k] = 1;\n                    }\n                }\n                currStreak = 1;\n                currNum = grid[i][j];\n            }\n        }\n        \n        if (currStreak >= K) {\n            for (int k = W - currStreak; k < W; k++) {\n                erased[i][k] = 1;\n            }\n        }\n    }\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (erased[i][j]) {\n                grid[i][j] = 0;\n                anyErased = 1;\n            }\n        }\n    }\n\n    return anyErased;\n}\n\nint calculateScore(int grid[MAX_H][MAX_W], int chainDepth) {\n    int score = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 0) continue;\n            score += grid[i][j] * (1 << chainDepth);\n        }\n    }\n    return score;\n}\n\nint solve() {\n    int maxScore = 0;\n    for (int eraseRow = 0; eraseRow < H; eraseRow++) {\n        for (int eraseCol = 0; eraseCol < W; eraseCol++) {\n            memcpy(tempBoard, board, sizeof(board));\n            int currentScore = 0;\n            int chainDepth = 0;\n\n            tempBoard[eraseRow][eraseCol] = 0;\n            dropStones(tempBoard);\n\n            while (checkAndErase(tempBoard)) {\n                dropStones(tempBoard);\n                currentScore += calculateScore(tempBoard, chainDepth);\n                chainDepth++;\n            }\n\n            maxScore = (currentScore > maxScore) ? currentScore : maxScore;\n        }\n    }\n    return maxScore;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &H, &W, &K);\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            scanf(\"%d\", &board[i][j]);\n        }\n    }\n\n    printf(\"%d\\n\", solve());\n    return 0;\n}",
    "timestamp": "2025-08-05 23:31:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint H, W, K;\nint board[100][100];\nint temp_board[100][100];\nint max_score = 0;\n\nvoid copy_board() {\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            temp_board[i][j] = board[i][j];\n        }\n    }\n}\n\nvoid drop_stones() {\n    for (int j = 0; j < W; j++) {\n        int empty_row = H - 1;\n        for (int i = H - 1; i >= 0; i--) {\n            if (temp_board[i][j] != 0) {\n                temp_board[empty_row][j] = temp_board[i][j];\n                if (empty_row != i) {\n                    temp_board[i][j] = 0;\n                }\n                empty_row--;\n            }\n        }\n    }\n}\n\nint process_disappear(int multiplier) {\n    int marked[100][100] = {0};\n    int found = 0;\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (temp_board[i][j] == 0) continue;\n            int val = temp_board[i][j];\n            int count = 1;\n            int k = j + 1;\n            while (k < W && temp_board[i][k] == val) {\n                count++;\n                k++;\n            }\n            if (count >= K) {\n                found = 1;\n                for (int l = j; l < k; l++) {\n                    marked[i][l] = 1;\n                }\n            }\n        }\n    }\n\n    int score = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (marked[i][j]) {\n                score += temp_board[i][j] * multiplier;\n                temp_board[i][j] = 0;\n            }\n        }\n    }\n\n    if (found) {\n        drop_stones();\n        return score + process_disappear(multiplier * 2);\n    }\n    return score;\n}\n\nvoid simulate(int r, int c) {\n    copy_board();\n    if (temp_board[r][c] == 0) return;\n    temp_board[r][c] = 0;\n    drop_stones();\n    int score = process_disappear(1);\n    if (score > max_score) {\n        max_score = score;\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &H, &W, &K);\n    for (int i = 0; i < H; i++) {\n        char row[101];\n        scanf(\"%s\", row);\n        for (int j = 0; j < W; j++) {\n            board[i][j] = row[j] - '0';\n        }\n    }\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            simulate(i, j);\n        }\n    }\n\n    printf(\"%d\\n\", max_score);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:31:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <climits>\nusing namespace std;\n\nint H, W, K;\nvector<vector<int>> board;\n\nint simulate(int x, int y) {\n    vector<vector<int>> temp = board;\n    temp[x][y] = 0;\n    for (int j = y; j < W - 1; ++j) {\n        for (int i = 0; i < H; ++i) {\n            temp[i][j] = temp[i][j + 1];\n        }\n    }\n    for (int i = 0; i < H; ++i) {\n        temp[i][W - 1] = 0;\n    }\n\n    int total_score = 0;\n    int chain = 0;\n\n    while (true) {\n        vector<vector<bool>> marked(H, vector<bool>(W, false));\n        bool changed = false;\n\n        for (int i = 0; i < H; ++i) {\n            for (int j = 0; j < W; ++j) {\n                if (temp[i][j] == 0) continue;\n                int val = temp[i][j];\n                int left = j;\n                while (left > 0 && temp[i][left - 1] == val) --left;\n                int right = j;\n                while (right < W - 1 && temp[i][right + 1] == val) ++right;\n                if (right - left + 1 >= K) {\n                    for (int k = left; k <= right; ++k) {\n                        marked[i][k] = true;\n                    }\n                    changed = true;\n                }\n            }\n        }\n\n        if (!changed) break;\n\n        chain++;\n        int current_score = 0;\n        for (int i = 0; i < H; ++i) {\n            for (int j = 0; j < W; ++j) {\n                if (marked[i][j]) {\n                    current_score += temp[i][j];\n                    temp[i][j] = 0;\n                }\n            }\n        }\n        total_score += current_score * (1 << (chain - 1));\n\n        for (int j = 0; j < W; ++j) {\n            vector<int> column;\n            for (int i = 0; i < H; ++i) {\n                if (temp[i][j] != 0) {\n                    column.push_back(temp[i][j]);\n                }\n            }\n            for (int i = 0; i < H; ++i) {\n                if (i < column.size()) {\n                    temp[i][j] = column[i];\n                } else {\n                    temp[i][j] = 0;\n                }\n            }\n        }\n    }\n\n    return total_score;\n}\n\nint main() {\n    cin >> H >> W >> K;\n    board.resize(H, vector<int>(W));\n    for (int i = 0; i < H; ++i) {\n        string row;\n        cin >> row;\n        for (int j = 0; j < W; ++j) {\n            board[i][j] = row[j] - '0';\n        }\n    }\n\n    int max_score = 0;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            int score = simulate(i, j);\n            if (score > max_score) {\n                max_score = score;\n            }\n        }\n    }\n\n    cout << max_score << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:32:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PuzzleSolver {\n    static class Point {\n        int x, y;\n        Point(int x, int y) { this.x = x; this.y = y; }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int H = sc.nextInt();\n        int W = sc.nextInt();\n        int K = sc.nextInt();\n        int[][] board = new int[H][W];\n        for (int i = 0; i < H; i++) {\n            String line = sc.next();\n            for (int j = 0; j < W; j++) {\n                board[i][j] = line.charAt(j) - '0';\n            }\n        }\n\n        int maxScore = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                int[][] tempBoard = new int[H][W];\n                for (int x = 0; x < H; x++) {\n                    System.arraycopy(board[x], 0, tempBoard[x], 0, W);\n                }\n                tempBoard[i][j] = 0;\n                int score = simulate(tempBoard, H, W, K);\n                if (score > maxScore) {\n                    maxScore = score;\n                }\n            }\n        }\n        System.out.println(maxScore);\n    }\n\n    private static int simulate(int[][] board, int H, int W, int K) {\n        int totalScore = 0;\n        int multiplier = 1;\n        boolean changed;\n        do {\n            changed = false;\n            boolean[][] toRemove = new boolean[H][W];\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    if (board[i][j] == 0) continue;\n                    int num = board[i][j];\n                    int left = j;\n                    while (left > 0 && board[i][left - 1] == num) left--;\n                    int right = j;\n                    while (right < W - 1 && board[i][right + 1] == num) right++;\n                    if (right - left + 1 >= K) {\n                        for (int k = left; k <= right; k++) {\n                            toRemove[i][k] = true;\n                        }\n                    }\n                }\n            }\n            int currentScore = 0;\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    if (toRemove[i][j]) {\n                        currentScore += board[i][j];\n                        board[i][j] = 0;\n                    }\n                }\n            }\n            if (currentScore > 0) {\n                totalScore += currentScore * multiplier;\n                multiplier *= 2;\n                changed = true;\n                dropStones(board, H, W);\n            }\n        } while (changed);\n        return totalScore;\n    }\n\n    private static void dropStones(int[][] board, int H, int W) {\n        for (int j = 0; j < W; j++) {\n            int writePtr = H - 1;\n            for (int i = H - 1; i >= 0; i--) {\n                if (board[i][j] != 0) {\n                    board[writePtr--][j] = board[i][j];\n                }\n            }\n            while (writePtr >= 0) {\n                board[writePtr--][j] = 0;\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:32:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    private int H, W, K;\n    private int[][] board;\n\n    public int getMaxScore(int[][] board, int K) {\n        this.board = board;\n        this.H = board.length;\n        this.W = board[0].length;\n        this.K = K;\n\n        int maxScore = 0;\n        for (int r = 0; r < H; r++) {\n            for (int c = 0; c < W; c++) {\n                int[][] newBoard = copyBoard(board);\n                newBoard[r][c] = 0;\n                maxScore = Math.max(maxScore, calculateScore(newBoard));\n            }\n        }\n        return maxScore;\n    }\n\n    private int calculateScore(int[][] grid) {\n        int totalScore = 0;\n        int chainMultiplier = 1;\n        boolean changed;\n\n        do {\n            changed = false;\n            boolean[][] toRemove = findRemovableStones(grid);\n\n            for (int r = 0; r < H; r++) {\n                for (int c = 0; c < W; c++) {\n                    if (toRemove[r][c]) {\n                        totalScore += grid[r][c] * chainMultiplier;\n                        grid[r][c] = 0;\n                        changed = true;\n                    }\n                }\n            }\n\n            if (changed) {\n                dropStones(grid);\n                chainMultiplier *= 2;\n            }\n        } while (changed);\n\n        return totalScore;\n    }\n\n    private boolean[][] findRemovableStones(int[][] grid) {\n        boolean[][] toRemove = new boolean[H][W];\n\n        for (int r = 0; r < H; r++) {\n            for (int c = 0; c < W; c++) {\n                if (grid[r][c] == 0) continue;\n\n                int count = 1;\n                int left = c - 1;\n                int right = c + 1;\n\n                while (left >= 0 && grid[r][left] == grid[r][c]) {\n                    count++;\n                    left--;\n                }\n\n                while (right < W && grid[r][right] == grid[r][c]) {\n                    count++;\n                    right++;\n                }\n\n                if (count >= K) {\n                    for (int i = left + 1; i < right; i++) {\n                        toRemove[r][i] = true;\n                    }\n                }\n            }\n        }\n        return toRemove;\n    }\n\n    private void dropStones(int[][] grid) {\n        for (int c = 0; c < W; c++) {\n            int dropRow = H - 1;\n            for (int r = H - 1; r >= 0; r--) {\n                if (grid[r][c] != 0) {\n                    grid[dropRow][c] = grid[r][c];\n                    if (dropRow != r) {\n                        grid[r][c] = 0;\n                    }\n                    dropRow--;\n                }\n            }\n        }\n    }\n\n    private int[][] copyBoard(int[][] original) {\n        int[][] copy = new int[H][W];\n        for (int r = 0; r < H; r++) {\n            copy[r] = Arrays.copyOf(original[r], W);\n        }\n        return copy;\n    }\n}",
    "timestamp": "2025-08-05 23:32:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <climits>\n\nclass Solution {\npublic:\n    int maxScore(std::vector<std::vector<int>>& board) {\n        int H = board.size(), W = board[0].size();\n        int maxScoreResult = 0;\n\n        for (int r = 0; r < H; r++) {\n            for (int c = 0; c < W; c++) {\n                std::vector<std::vector<int>> tempBoard = board;\n                tempBoard[r][c] = 0;\n                int currentScore = simulateBoard(tempBoard);\n                maxScoreResult = std::max(maxScoreResult, currentScore);\n            }\n        }\n\n        return maxScoreResult;\n    }\n\nprivate:\n    int simulateBoard(std::vector<std::vector<int>>& board) {\n        int H = board.size(), W = board[0].size();\n        int totalScore = 0;\n        int chainMultiplier = 1;\n\n        while (true) {\n            bool disappeared = false;\n            std::vector<std::vector<bool>> toRemove(H, std::vector<bool>(W, false));\n\n            for (int r = 0; r < H; r++) {\n                for (int c = 0; c < W; c++) {\n                    if (board[r][c] == 0) continue;\n                    int count = 1;\n                    int right = c + 1;\n                    while (right < W && board[r][right] == board[r][c]) {\n                        count++;\n                        right++;\n                    }\n\n                    if (count >= 3) {\n                        for (int k = c; k < right; k++) {\n                            toRemove[r][k] = true;\n                        }\n                        disappeared = true;\n                    }\n                }\n            }\n\n            if (!disappeared) break;\n\n            int currentScore = 0;\n            for (int r = 0; r < H; r++) {\n                for (int c = 0; c < W; c++) {\n                    if (toRemove[r][c]) {\n                        currentScore += board[r][c];\n                        board[r][c] = 0;\n                    }\n                }\n            }\n\n            totalScore += currentScore * chainMultiplier;\n            chainMultiplier *= 2;\n\n            dropStones(board);\n        }\n\n        return totalScore;\n    }\n\n    void dropStones(std::vector<std::vector<int>>& board) {\n        int H = board.size(), W = board[0].size();\n\n        for (int c = 0; c < W; c++) {\n            int writeRow = H - 1;\n            for (int r = H - 1; r >= 0; r--) {\n                if (board[r][c] != 0) {\n                    std::swap(board[r][c], board[writeRow][c]);\n                    writeRow--;\n                }\n            }\n            while (writeRow >= 0) {\n                board[writeRow][c] = 0;\n                writeRow--;\n            }\n        }\n    }\n};",
    "timestamp": "2025-08-05 23:33:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_score(board, K):\n    from copy import deepcopy\n\n    def can_disappear(row):\n        count = 1\n        prev_digit = row[0]\n        positions = []\n        for j in range(1, len(row)):\n            if row[j] == prev_digit:\n                count += 1\n            else:\n                if count >= K:\n                    positions.extend(range(j - count, j))\n                count = 1\n                prev_digit = row[j]\n        if count >= K:\n            positions.extend(range(len(row) - count, len(row)))\n        return positions\n\n    def drop_stones(board):\n        H, W = len(board), len(board[0])\n        for col in range(W):\n            new_col = [board[row][col] for row in range(H) if board[row][col] != 0]\n            new_col = [0] * (H - len(new_col)) + new_col\n            for row in range(H):\n                board[row][col] = new_col[row]\n\n    def calculate_score(board, K):\n        score = 0\n        chain = 0\n        while True:\n            positions_to_clear = []\n            for i in range(len(board)):\n                positions_to_clear.extend([(i, j) for j in can_disappear(board[i])])\n            if not positions_to_clear:\n                break\n            chain += 1\n            current_chain_score = 0\n            for pos in positions_to_clear:\n                current_chain_score += board[pos[0]][pos[1]]\n                board[pos[0]][pos[1]] = 0\n            score += current_chain_score * (2 ** chain)\n            drop_stones(board)\n        return score\n\n    H, W = len(board), len(board[0])\n    max_score = 0\n    \n    for i in range(H):\n        for j in range(W):\n            new_board = deepcopy(board)\n            new_board[i][j] = 0\n            score = calculate_score(new_board, K)\n            max_score = max(max_score, score)\n    \n    return max_score\n\n# Sample usage:\nboard = [\n    [7, 8, 7, 7],\n    [6, 1, 7, 7],\n    [3, 2, 6, 6],\n    [2, 3, 4, 6]\n]\nK = 3\nprint(max_score(board, K))  # Output: max possible score with optimal cell removal",
    "timestamp": "2025-08-13 15:43:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class PuzzleSolver {\n    private static int H, W, K;\n    private static int[][] board;\n    \n    public static void main(String[] args) {\n        // Input reading logic here, like setting H, W, K and initializing the 2D array board\n        // For this example, I'll use some dummy board and parameters\n        H = 4;\n        W = 5;\n        K = 3;\n        board = new int[][]{\n            {1, 1, 1, 3, 3},\n            {1, 2, 2, 3, 4},\n            {1, 2, 2, 3, 4},\n            {4, 4, 4, 4, 4}\n        };\n        \n        System.out.println(calculateMaxScore());\n    }\n    \n    private static int calculateMaxScore() {\n        int maxScore = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                int originalValue = board[i][j];\n                board[i][j] = 0;\n                clear(board);\n                maxScore = Math.max(maxScore, executeDrop(board));\n                board[i][j] = originalValue;\n            }\n        }\n        return maxScore;\n    }\n    \n    private static void clear(int[][] b) {\n        boolean cleared;\n        do {\n            cleared = false;\n            for (int i = 0; i < H; i++) {\n                int j = 0;\n                while (j < W) {\n                    int start = j;\n                    while (j < W && b[i][j] == b[i][start]) {\n                        j++;\n                    }\n                    if (j - start >= K && b[i][start] != 0) {\n                        for (int k = start; k < j; k++) {\n                            b[i][k] = 0;\n                        }\n                        cleared = true;\n                    }\n                }\n            }\n            \n            for (int j = 0; j < W; j++) {\n                int write = H - 1;\n                for (int i = H - 1; i >= 0; i--) {\n                    if (b[i][j] != 0) {\n                        b[write][j] = b[i][j];\n                        if (write != i) b[i][j] = 0;\n                        write--;\n                    }\n                }\n            }\n        } while (cleared);\n    }\n    \n    private static int executeDrop(int[][] b) {\n        boolean[][] visited = new boolean[H][W];\n        int score = 0;\n        int power = 0;\n        \n        while (true) {\n            boolean anyChain = false;\n            for (int i = 0; i < H; i++) {\n                Arrays.fill(visited[i], false);\n            }\n            \n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    if (!visited[i][j] && b[i][j] != 0) {\n                        int num = b[i][j], count = 0, sum = 0;\n                        Queue<int[]> queue = new LinkedList<>();\n                        queue.add(new int[]{i, j});\n                        while (!queue.isEmpty()) {\n                            int[] cell = queue.poll();\n                            int x = cell[0], y = cell[1];\n                            if (visited[x][y]) continue;\n                            visited[x][y] = true;\n                            count++;\n                            sum += num;\n                            if (x >= 0 && y+1 < W && !visited[x][y+1] && b[x][y+1] == num) queue.add(new int[]{x, y+1});\n                            if (x >= 0 && y-1 >= 0 && !visited[x][y-1] && b[x][y-1] == num) queue.add(new int[]{x, y-1});\n                        }\n                        if (count >= K) {\n                            score += sum * (1 << power);\n                            for (int a = 0; a < H; a++) {\n                                for (int c = 0; c < W; c++) {\n                                    if (visited[a][c]) b[a][c] = 0;\n                                }\n                            }\n                            anyChain = true;\n                        }\n                    }\n                }\n            }\n            \n            if (!anyChain) break;\n            \n            power++;\n            \n            for (int j = 0; j < W; j++) {\n                int write = H - 1;\n                for (int i = H - 1; i >= 0; i--) {\n                    if (b[i][j] != 0) {\n                        b[write][j] = b[i][j];\n                        if (write != i) b[i][j] = 0;\n                        write--;\n                    }\n                }\n            }\n        }\n        \n        return score;\n    }\n}",
    "timestamp": "2025-08-13 15:43:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_H 10\n#define MAX_W 10\n\nint board[MAX_H][MAX_W];\nint H, W, K;\n\nint dx[] = { -1, 1, 0, 0 };\nint dy[] = { 0, 0, -1, 1 };\n\n// Function to check if coordinates are within the grid\nint in_bounds(int x, int y) {\n    return x >= 0 && x < H && y >= 0 && y < W;\n}\n\n// Function to simulate the disappearing process and score calculation\nint simulate(int erase_row, int erase_col) {\n    int temp_board[MAX_H][MAX_W];\n    int score = 0;\n    int power = 1;\n    int chain = 0;\n\n    for (int i = 0; i < H; ++i)\n        for (int j = 0; j < W; ++j)\n            temp_board[i][j] = board[i][j];\n\n    temp_board[erase_row][erase_col] = 0;\n\n    while (1) {\n        int any_disappear = 0;\n\n        for (int i = 0; i < H; ++i) {\n            for (int j = 0; j <= W - K; ++j) {\n                int digit = temp_board[i][j];\n                if (digit == 0) continue;\n\n                int count = 1;\n                while (count < K && j + count < W && temp_board[i][j + count] == digit)\n                    ++count;\n\n                if (count >= K) {\n                    any_disappear = 1;\n                    score += power * digit * count;\n                    for (int c = j; c < j + count; ++c)\n                        temp_board[i][c] = 0;\n                }\n            }\n        }\n\n        if (!any_disappear) break;\n\n        ++chain;\n        power *= 2;\n\n        for (int j = 0; j < W; ++j) {\n            int new_row = H - 1;\n            for (int i = H - 1; i >= 0; --i) {\n                if (temp_board[i][j] != 0)\n                    temp_board[new_row--][j] = temp_board[i][j];\n            }\n            for (int i = new_row; i >= 0; --i)\n                temp_board[i][j] = 0;\n        }\n    }\n\n    return score;\n}\n\n// Function to determine optimal cell to erase\nvoid find_optimal_erase() {\n    int max_score = 0;\n    int best_row = -1, best_col = -1;\n\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            int score = simulate(i, j);\n            if (score > max_score) {\n                max_score = score;\n                best_row = i;\n                best_col = j;\n            }\n        }\n    }\n\n    printf(\"Optimal cell to erase: (%d, %d) with max score: %d\\n\", best_row, best_col, max_score);\n}\n\nint main() {\n    scanf(\"%d %d %d\", &H, &W, &K);\n    for (int i = 0; i < H; ++i)\n        for (int j = 0; j < W; ++j)\n            scanf(\"%d\", &board[i][j]);\n\n    find_optimal_erase();\n\n    return 0;\n}",
    "timestamp": "2025-08-13 15:43:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nvoid dropStones(vector<vector<int>>& board, int H, int W) {\n    for (int col = 0; col < W; ++col) {\n        int emptyRow = H - 1;\n        for (int row = H - 1; row >= 0; --row) {\n            if (board[row][col]) {\n                swap(board[emptyRow--][col], board[row][col]);\n            }\n        }\n    }\n}\n\nint calculateScore(vector<vector<int>> board, int H, int W, int K) {\n    int totalScore = 0;\n    int chainMultiplier = 1;\n    bool stonesDisappeared;\n\n    do {\n        stonesDisappeared = false;\n        vector<vector<int>> visited(H, vector<int>(W, 0));\n\n        for (int row = 0; row < H; ++row) {\n            for (int col = 0; col < W; ++col) {\n                if (board[row][col] && !visited[row][col]) {\n                    int number = board[row][col];\n                    vector<int> streak;\n                    int start = col;\n\n                    while (col < W && board[row][col] == number) {\n                        streak.push_back(col);\n                        visited[row][col] = 1;\n                        ++col;\n                    }\n\n                    if (streak.size() >= K) {\n                        for (int s : streak)\n                            totalScore += number * chainMultiplier;\n                        for (int s : streak)\n                            board[row][s] = 0;\n\n                        stonesDisappeared = true;\n                        chainMultiplier *= 2;\n                    }\n                }\n            }\n        }\n\n        if (stonesDisappeared) {\n            dropStones(board, H, W);\n        }\n    } while (stonesDisappeared);\n\n    return totalScore;\n}\n\nint getOptimalScore(vector<vector<int>>& board, int H, int W, int K) {\n    int bestScore = 0;\n\n    for (int row = 0; row < H; ++row) {\n        for (int col = 0; col < W; ++col) {\n            if (board[row][col] != 0) {\n                int erasedStone = board[row][col];\n                board[row][col] = 0;\n                int currentScore = calculateScore(board, H, W, K);\n                bestScore = max(bestScore, currentScore);\n                board[row][col] = erasedStone;\n            }\n        }\n    }\n\n    return bestScore;\n}\n\nint main() {\n    int H, W, K;\n    cin >> H >> W >> K;\n    vector<vector<int>> board(H, vector<int>(W));\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            char digit;\n            cin >> digit;\n            board[i][j] = digit - '0';\n        }\n    }\n\n    cout << getOptimalScore(board, H, W, K) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 15:44:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_stone_puzzle(board, K):\n    H, W = len(board), len(board[0])\n    \n    def drop_stones(grid):\n        for col in range(W):\n            non_empty = [cell for cell in [grid[row][col] for row in range(H)] if cell != 0]\n            new_col = [0] * (H - len(non_empty)) + non_empty\n            for row in range(H):\n                grid[row][col] = new_col[row]\n        return grid\n    \n    def check_horizontal_disappearance(grid):\n        disappeared = False\n        for row in range(H):\n            col = 0\n            while col < W:\n                digit = grid[row][col]\n                if digit == 0:\n                    col += 1\n                    continue\n                \n                count = 1\n                while col + count < W and grid[row][col + count] == digit:\n                    count += 1\n                \n                if count >= K:\n                    disappeared = True\n                    for i in range(col, col + count):\n                        grid[row][i] = 0\n                \n                col += count\n        return grid, disappeared\n    \n    def calculate_score(removed_stones, chain_depth):\n        return sum(stone * (2 ** chain_depth) for stone in removed_stones)\n    \n    def simulate_removal(board, row, col):\n        new_board = [row[:] for row in board]\n        new_board[row][col] = 0\n        \n        chain_depth = 0\n        total_score = 0\n        removed_stones = []\n        \n        while True:\n            new_board = drop_stones(new_board)\n            new_board, disappeared = check_horizontal_disappearance(new_board)\n            \n            if not disappeared:\n                break\n            \n            chain_depth += 1\n            current_removed = [stone for row in new_board for stone in row if stone == 0]\n            removed_stones.extend(current_removed)\n        \n        return calculate_score(removed_stones, chain_depth)\n    \n    max_score = 0\n    best_cell = None\n    \n    for row in range(H):\n        for col in range(W):\n            score = simulate_removal(board, row, col)\n            if score > max_score:\n                max_score = score\n                best_cell = (row, col)\n    \n    return best_cell, max_score\n\n# Example usage\nboard = [\n    [1, 2, 3, 4],\n    [2, 3, 4, 5],\n    [3, 4, 5, 6]\n]\nK = 3\nresult = solve_stone_puzzle(board, K)\nprint(result)",
    "timestamp": "2025-08-13 15:44:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    from collections import deque\n\n    H, W, K = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(H)]\n\n    max_score = 0\n\n    for target_i in range(H):\n        for target_j in range(W):\n            # Create a copy of the grid and erase the target cell\n            temp_grid = [list(row) for row in grid]\n            temp_grid[target_i][target_j] = '0'  # mark as erased\n\n            total_score = 0\n            multiplier = 1\n\n            while True:\n                # Process dropping stones\n                for j in range(W):\n                    # Collect non-zero stones in the column\n                    column = [temp_grid[i][j] for i in range(H) if temp_grid[i][j] != '0']\n                    # Fill the column from bottom\n                    for i in range(H):\n                        if i < len(column):\n                            temp_grid[H - 1 - i][j] = column[len(column) - 1 - i]\n                        else:\n                            temp_grid[H - 1 - i][j] = '0'\n\n                # Find all horizontal segments to disappear\n                disappear = set()\n                for i in range(H):\n                    j = 0\n                    while j < W:\n                        if temp_grid[i][j] == '0':\n                            j += 1\n                            continue\n                        left = j\n                        while j < W and temp_grid[i][j] == temp_grid[i][left]:\n                            j += 1\n                        length = j - left\n                        if length >= K:\n                            for x in range(left, j):\n                                disappear.add((i, x))\n                if not disappear:\n                    break\n\n                # Calculate the score for this step\n                current_sum = 0\n                for i, j in disappear:\n                    current_sum += int(temp_grid[i][j])\n                total_score += current_sum * multiplier\n                multiplier *= 2\n\n                # Mark disappeared cells\n                for i, j in disappear:\n                    temp_grid[i][j] = '0'\n\n            if total_score > max_score:\n                max_score = total_score\n\n    print(max_score)\n\nsolve()",
    "timestamp": "2025-08-13 15:47:34"
  }
]