[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (l);i < (r);i++)\n#define ALL(x) (x).begin(),(x).end()\ntemplate<typename T> bool chmax(T& a,const T& b){return a < b ? (a = b,true) : false;}\ntemplate<typename T> bool chmin(T& a,const T& b){return b < a ? (a = b,true) : false;}\ntypedef long long ll;\n\nint H,W,K;\n\nbool erase_block(vector< vector<int> >& A,deque< deque<bool> >& d)\n{\n\tbool res = false;\n\tFOR(i,0,A.size()){\n\t\tvector<int> v(count(ALL(d [i]),true),0);\n\t\tFOR(j,0,A [i].size()){\n\t\t\tif(d [i] [j] == true){\n\t\t\t\td [i] [j] = false;\n\t\t\t\tres = true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tv.push_back(A [i] [j]);\n\t\t\t}\n\t\t}\n\t\tA [i] = v;\n\t}\n\n\treturn res;\n}\n\nint solve(int x,int y,vector< vector<int> > A)\n{\n\tdeque< deque<bool> > d(W,deque<bool>(H));\n\td [x] [y] = true;\n\n\terase_block(A,d);\n\tint res = 0,cnt = 0;\n\tdo{\n\t\tFOR(i,0,A.size()) FOR(j,0,A [i].size()) if(A [i] [j] && i + K <= A.size()){\n\t\t\tbool flag = true;\n\t\t\tFOR(k,0,K){\n\t\t\t\tflag &= A [i] [j] == A [i + k] [j];\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tFOR(k,0,K) if(d [i + k] [j] == false){\n\t\t\t\t\td [i + k] [j] = true;\n\t\t\t\t\tres += A [i + k] [j] * (1 << cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t}while(erase_block(A,d));\n\n\treturn res;\n}\n\nint main()\n{\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tcin >> H >> W >> K;\n\tvector< vector<int> > A(W,vector<int>(H));\n\tFOR(i,0,H) FOR(j,0,W){\n\t\tchar c;\n\t\tcin >> c;\n\t\tA [j] [i] = c - '0';\n\t}\n\tif(K > 3){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tint ans = 0;\n\tFOR(i,0,W) FOR(j,0,H){\n\t\tchmax(ans,solve(i,j,A));\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> P;\ntypedef tuple<int,int,int> tpl;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SORT(c) sort((c).begin(),(c).end())\n#define REVERSE(c) reverse((c).begin(),(c).end())\n#define LB(a,x) lower_bound((a).begin(), (a).end(), x) - (a).begin()\n#define UB(a,x) upper_bound((a).begin(), (a).end(), x) - (a).begin()\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RFOR(i,a,b) for(int i=(a)-1;i>=(b);--i)\n#define RREP(i,n) RFOR(i,n,0)\n\n#define en \"\\n\"\n\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\nconst int INT_INF = 2147483647;\nconst long long LL_INF = 1LL<<60;\nconst long long MOD = 1000000007;\n\n#define CLR(a) memset((a), 0, sizeof(a))\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nint ans,H,W,K,a[30][30];\n\nbool check(int n){\n    bool res = false;\n    int tmp = 0;\n    REP(i,H){\n        RFOR(j,W+1,K){\n            REP(k,W-j+1){\n                bool flag = true;\n                REP(l,j-1){\n                    if(a[i][k]==0 || a[i][k+l+1]==0){\n                        flag = false;\n                        break;\n                    }\n                    if(a[i][k+l+1] != a[i][k]){\n                        flag = false;\n                        break;\n                    }\n                }\n                if(flag){\n                    res = true;\n                    tmp += a[i][k]*j;\n                    REP(l,j) a[i][k+l] = 0;\n                }\n            }\n        }\n    }\n    ans += (1<<n)*tmp;\n    return res;\n}\n\nvoid seiri(void){\n    RREP(i,H){\n        REP(j,W){\n            if(a[i][j] == 0){\n                int h = i-1;\n                while(h>0 && a[h][j]==0) h--;\n                if(h>=0 && a[h][j] != 0){\n                    a[i][j] = a[h][j];\n                    a[h][j] = 0;\n                }\n            }\n        }\n    }\n}\n\nint main(void){\n    cin >> H >> W >> K;\n    REP(i,H)REP(j,W){\n        char c; cin >> c;\n        a[i][j] = c - '0';\n    }\n    int b[H][W]; REP(i,H)REP(j,W) b[i][j] = a[i][j];\n    int ans1 = 0;\n    REP(i,H)REP(j,W){\n        ans = 0;\n        REP(s,H)REP(t,W) a[s][t] = b[s][t];\n        a[i][j] = 0;\n        seiri();\n        REP(k,H*W){\n            if(check(k)) seiri();\n            else break;\n        }\n        chmax(ans1, ans);\n    }\n    cout << ans1 << en;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid erup( vector<string> &t, int i, int j )\n{\n\tt[i][j] = ' ';\n\tfor( int k = i; k - 1 >= 0; k-- ) {\n\t\tif(  t[k - 1][j] == ' ' ) break;\n\t\tt[k][j] = t[k - 1][j];\n\t\tt[k - 1][j] = ' ';\n\t}\n}\n\nvoid chk( vector<string> &t, int i, int j, int W, int K, vector<vector<int>> &use, vector<pair<int, int>> &er )\n{\n\tfor( int k = i; k >= 0; k-- ) {\n\t\tif( t[k][j] == ' ' ) break;\n\t\tif( j > 0 && t[k][j] == t[k][j - 1] || j + 1 < W && t[k][j] == t[k][j + 1] ) {\n\t\t\tif( use[k][j] ) continue;\n\t\t\tuse[k][j] = 1;\n\t\t\tvector<pair<int, int>> tv;\n\t\t\tchar nc = t[k][j];\n\t\t\ttv.push_back( make_pair( k, j ) );\n\t\t\tfor( int l = j - 1; l >= 0; l-- ) {\n\t\t\t\tif( t[k][l] != nc ) break;\n\t\t\t\tif( use[k][l] ) continue;\n\t\t\t\tuse[k][l] = 1;\n\t\t\t\ttv.push_back( make_pair( k, l ) );\n\t\t\t}\n\t\t\tfor( int l = j + 1; l < W; l++ ) {\n\t\t\t\tif( t[k][l] != nc ) break;\n\t\t\t\tif( use[k][l] ) continue;\n\t\t\t\tuse[k][l] = 1;\n\t\t\t\ttv.push_back( make_pair( k, l ) );\n\t\t\t}\n\t\t\tif( tv.size() >= K ) er.insert( er.end(), tv.begin(), tv.end() );\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint H, W, K;\n\tcin >> H >> W >> K;\n\tvector<string> c( H );\n\tfor( int i = 0; i < H; i++ ) {\n\t\tcin >> c[i];\n\t}\n\n\tlong long ans = 0;\n\tfor( int i = 0; i < H; i++ ) {\n\t\tfor( int j = 0; j < W; j++ ) {\n\t\t\tvector<string> t = c;\n\t\t\tlong long sc = 0;\n\t\t\terup( t, i, j );\n\t\t\tint idx = 0;\n\t\t\tset<int> st;\n\t\t\twhile( 1 ) {\n\t\t\t\tvector<vector<int>> use( H, vector<int>( W ) );\n\t\t\t\tvector<pair<int, int>> er;\n\t\t\t\tif( idx == 0 ) {\n\t\t\t\t\tchk( t, i, j, W, K, use, er );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor( auto it = st.begin(); it != st.end(); it++ ) {\n\t\t\t\t\t\tchk( t, i, *it, W, K, use, er );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( er.size() == 0 ) break;\n\t\t\t\tint sum = 0;\n\t\t\t\tfor( int k = 0; k < er.size(); k++ ) sum += t[er[k].first][er[k].second] - '0';\n\t\t\t\tsc += (1LL << idx) * sum;\n\t\t\t\tidx++;\n\t\t\t\tst.clear();\n\t\t\t\twhile( er.size() ) {\n\t\t\t\t\tint ii, jj;\n\t\t\t\t\ttie( ii, jj ) = er.back();\n\t\t\t\t\ter.pop_back();\n\t\t\t\t\tst.insert( jj );\n\t\t\t\t\terup( t, ii, jj );\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max( ans, sc );\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\n#define rep(i, x, y) for (i64 i = i64(x), i##_max_for_repmacro = i64(y); i < i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\ntemplate <i64 p>\nclass fp {\n    public:\n    i64 x;\n    fp() : x(0) {}\n    fp(i64 x_) : x((x_ % p + p) % p) {}\n    fp operator+() const { return fp(x); }\n    fp operator-() const { return fp(-x); }\n    fp& operator+=(const fp& y) {\n        x += y.x;\n        if (x >= p) x -= p;\n        return *this;\n    }\n    fp& operator-=(const fp& y) { return *this += -y; }\n    fp& operator*=(const fp& y) {\n        x = x * y.x % p;\n        return *this;\n    }\n    fp& operator/=(const fp& y) { return *this *= fp(inverse(y.x)); }\n    fp operator+(const fp& y) const { return fp(x) += y; }\n    fp operator-(const fp& y) const { return fp(x) -= y; }\n    fp operator*(const fp& y) const { return fp(x) *= y; }\n    fp operator/(const fp& y) const { return fp(x) /= y; }\n    bool operator==(const fp& y) const { return x == y.x; }\n    bool operator!=(const fp& y) const { return !(*this == y); }\n    i64 extgcd(i64 a, i64 b, i64& x, i64& y) {\n        i64 d = a;\n        if (b != 0) {\n            d = extgcd(b, a % b, y, x);\n            y -= (a / b) * x;\n        } else {\n            x = 1;\n            y = 0;\n        }\n        return d;\n    }\n    i64 inverse(i64 a) {\n        i64 x, y;\n        extgcd(a, p, x, y);\n        return (x % p + p) % p;\n    }\n};\n\ntemplate <i64 p>\ni64 abs(const fp<p>& x) { return x.x; }\n\ntemplate <i64 p>\nistream& operator>>(istream& is, fp<p>& x) {\n    is >> x.x;\n    return is;\n}\n\ntemplate <i64 p>\nostream& operator<<(ostream& os, const fp<p>& x) {\n    os << x.x;\n    return os;\n}\n\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    os << \"[\";\n    for (const auto& v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate <typename T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename A, typename T, size_t size>\nvoid fill(A (&ary)[size], const T& val) {\n    fill((T*)ary, (T*)(ary + size), val);\n}\n\n// x未満の要素の個数を返す\ntemplate <typename T>\ni64 count_less(const vector<T>& v, T x) {\n    return lower_bound(begin(v), end(v), x) - begin(v);\n}\n\n// x以下の要素の個数を返す\ntemplate <typename T>\ni64 count_less_or_equal(const vector<T>& v, T x) {\n    return upper_bound(begin(v), end(v), x) - begin(v);\n}\n\n// xより大きい要素の個数を返す\ntemplate <typename T>\ni64 count_greater(const vector<T>& v, T x) {\n    return end(v) - upper_bound(begin(v), end(v), x);\n}\n\n// x以上の要素の個数を返す\ntemplate <typename T>\ni64 count_greater_or_equal(const vector<T>& v, T x) {\n    return end(v) - lower_bound(begin(v), end(v), x);\n}\n\n// x未満の要素のうち最大のものを返す\ntemplate <typename T>\nT max_less(const vector<T>& v, T x) {\n    return *(lower_bound(begin(v), end(v), x) - 1);\n}\n\n// x以下の要素のうち最大のものを返す\ntemplate <typename T>\nT max_less_or_equal(const vector<T>& v, T x) {\n    return *(upper_bound(begin(v), end(v), x) - 1);\n}\n\n// xより大きい要素のうち最小のものを返す\ntemplate <typename T>\nT min_greater(const vector<T>& v, T x) {\n    return *upper_bound(begin(v), end(v), x);\n}\n\n// x以上の要素のうち最小のものを返す\ntemplate <typename T>\nT min_greater_or_equal(const vector<T>& v, T x) {\n    return *lower_bound(begin(v), end(v), x);\n}\n\nconstexpr int inf = 1.01e9;\nconstexpr i64 inf64 = 4.01e18;\nconstexpr long double eps = 1e-9;\n\n// 実数値のn分探索のループ回数の上限(2分探索なら50でも十分かもしれない)\nconstexpr i64 max_loop = 100;\n\nlong double tolerance(const long double& a, const long double& b, const long double& epsilon = eps) {\n    return epsilon * max({1.l, abs(a), abs(b)});\n}\n\n// a<0なら-1, a==0なら0, a>0なら1\nint sgn(const long double a, const long double& epsilon = eps) {\n    return (a > epsilon) - (a < -epsilon);\n}\n\n// a<bなら-1, a==bなら0, a>bなら1\nint compare(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return sgn(a - b, is_relative ? tolerance(a, b, epsilon) : epsilon);\n}\n\n// a==bか?\nbool is_equal(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) == 0;\n}\n\n// a<bか?\nbool is_less(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) == -1;\n}\n\n// a<=bか?\nbool is_less_or_equal(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) <= 0;\n}\n\n// a>bか?\nbool is_greater(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) == 1;\n}\n\n// a>=bか?\nbool is_greater_or_equal(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) >= 0;\n}\n\nclass union_find {\nprivate:\n    vector<int> parent, rank, gs;\n    int size;\n\npublic:\n    int count_group;\n    union_find() = default;\n    union_find(int n) { init(n); }\n\n    void init(int n) {\n        size = n;\n        count_group = n;\n        parent.resize(size);\n        rank.assign(size, 0);\n        gs.assign(size, 1);\n        for (int i = 0; i < size; ++i) parent[i] = i;\n    }\n\n    int find(int x) {\n        if (parent[x] == x)\n            return x;\n        else\n            return parent[x] = find(parent[x]);\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        if (rank[x] < rank[y]) {\n            parent[x] = y;\n            gs[y] += gs[x];\n        } else {\n            parent[y] = x;\n            gs[x] += gs[y];\n            if (rank[x] == rank[y]) ++rank[x];\n        }\n        --count_group;\n    }\n\n    bool is_same_group(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int group_size(int x) {\n        return gs[find(x)];\n    };\n};\n\ni64 solve2(i64 H,i64 W,i64 K,vector<string> c){\n    i64 res=0,turn=0,pow2=1;\n\n    auto drop=[&]{\n        vector<string> nc(H,string(W,'0'));\n        rep(j,0,W){\n            deque<char> tate;\n            rep(i,0,H) if(c[i][j]!='0') tate.emplace_back(c[i][j]);\n            while(tate.size()<H) tate.emplace_front('0');\n            rep(i,0,H) nc[i][j]=tate[i];\n        }\n\n        c=nc;\n    };\n\n    auto encode=[&](i64 i,i64 j){\n        return i*W+j;\n    };\n\n    auto erase=[&]{\n        bool erased=false;\n        union_find uf(H*W);\n\n        rep(i,0,H){\n            rep(j,0,W-1){\n                if(c[i][j]=='0') continue;\n                if(c[i][j]==c[i][j+1]) uf.unite(encode(i,j),encode(i,j+1));\n            }\n        }\n\n        i64 sum=0;\n        rep(i,0,H){\n            rep(j,0,W){\n                if(uf.group_size(encode(i,j))>=K){\n                    sum+=c[i][j]-'0';\n                    c[i][j]='0';\n\n                    erased=true;\n                }\n            }\n        }\n\n        res+=sum*pow2;\n\n        return erased;\n    };\n\n    while(true){\n        drop();\n        if(!erase()) break;\n        ++turn;\n        pow2*=2;\n    }\n\n    return res;\n}\n\nvoid solve() {\n    //constexpr i64 mod = 1'000'000'007;\n    i64 H,W,K;\n    cin >> H >> W >> K;\n    vector<string> c(H);\n    rep(i,0,H) cin >> c[i];\n\n    i64 ans=0;\n    rep(i,0,H){\n        rep(j,0,W){\n            char pre=c[i][j];\n            c[i][j]='0';\n            chmax(ans,solve2(H,W,K,c));\n            c[i][j]=pre;\n        }\n    }\n\n    cout << ans << endl;\n}\n\nint main() {\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst double inf=1e8;\nvs in;\nint score,n,m,r;\nvoid f(){\n//\trep(i,m)cout<<in[i]<<endl;;cout<<endl;\n\tint q=-1;\n\twhile(1){\n\t\tq++;\n\t\tint sum=0;\n\t\trep(i,n){\n\t\t\tint co=1;\n\t\t\trep(j,m){\n\t\t\t\tif(j==m-1||in[j+1].size()<=i||in[j].size()<=i||in[j][i]!=in[j+1][i]){\n\t\t\t\t\tif(co>=r){\n\t\t\t\t\t\tsum+=co*(in[j][i]-'0');\n\t\t\t\t\t\tloop(k,j-co+1,j+1)in[k][i]='!';\n\t\t\t\t\t}\n\t\t\t\t\tco=1;\n\t\t\t\t}else co++;\n\t\t\t}\n\t\t}\n//\t\tcout<<sum<<endl;\n\t\tif(sum==0)break;\n\t\tscore+=pow(2,q)*sum;\n\t\trep(i,m)rep(j,n)if(in[i][j]=='!'){\n\t\t\tin[i].erase(in[i].begin()+j);\n\t\t\tj--;\n\t\t}\n\t}\n}\nint main(){\n\tcin>>n>>m>>r;\n\tvs tmp(m,\"\");\n\trep(i,n)rep(j,m){\n\t\tchar c;\n\t\tcin>>c;\n\t\ttmp[j]=c+tmp[j];\n\t}\n\tint out=0;\n\trep(i,n)rep(j,m){\n\t\tin=tmp;\n\t\tin[j].erase(in[j].begin()+i);\n\t\tscore=0;\n\t\tf();\n\t\tout=max(out,score);\n\t}\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nvoid disp_stone(vector<vector<char> > s, int H, int W){\n\tcerr << endl;\n\trep (i, H){\n\t\trep (j, W){\n\t\t\tcerr << s[i][j];\n\t\t} // end rep\n\t\tcerr << endl;\n\t} // end rep\n}\n\n// 落ちきった状態を作り出す\nvector<vector<char> > all_fall(vector<vector<char> > s, int H, int W){\n\tvector<vector<char> > t = s;\n//\tdisp_stone(t, H, W);\n\twhile(true){\n\t\tbool update = false;\n\t\tfor (int i = 0; i < H-1; ++i){\n\t\t\tfor (int j = 0; j < W; ++j){\n\t\t\t\tif (t[i][j] != '0' && t[i+1][j] == '0'){\n\t\t\t\t\tswap(t[i][j], t[i+1][j]);\n\t\t\t\t\tupdate |= true;\n\t\t\t\t\tbreak;\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t\tif (update) break;\n\t\t} // end for\n\t\tif (!update) break;\n\t} // end while\n//\tdisp_stone(t, H, W);\n\t\n\treturn t;\n}\n\n// 消滅する状態を作り出す\nint disappear(vector<vector<char> > &s, int H, int W, int K){\n\tint score = 0;\n\tfor (int i = 0; i < H; ++i){\n\t\tint left = 0, right = 0;\n\t\twhile(right < W){\n\t\t\twhile (s[i][left] == s[i][right] && right < W){\n\t\t\t\t++right;\n\t\t\t} // end while\n\t\t\tif (right - 1 - left + 1 >= K){\n\t\t\t\tscore += (right - 1 - left + 1)*(int)(s[i][left] - '0');\n\t\t\t\tfor (int j = left; j < right; ++j){\n\t\t\t\t\ts[i][j] = '0';\n\t\t\t\t} // end for\n\t\t\t} // end if\n\t\t\tleft = right;\n\t\t} // end while\n\t} // end for\n\t\n\treturn score;\n}\n\n// 状態が変化しなくなるまでシミュレーション\nint smulate(vector<vector<char> > s, int H, int W, int K){\n\n\tvector<vector<char> > t;\n\tint score = 0;\n\tfor(int i = 0;; ++i){\n\t\tt = all_fall(s, H, W);\n\t\tif (t == s) break;\n\t\tscore += (1<<i) * disappear(t, H, W, K);\n\t\ts = t;\t\t\n\t} // end for\n\t\n\treturn score;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint H, W, K; cin >> H >> W >> K;\n\tvector<vector<char> > stones(H, vector<char>(W, 0));\n\trep (i, H){\n\t\trep (j, W){\n\t\t\tcin >> stones[i][j];\n\t\t} // end rep\n\t} // end rep\n\n\tint res = 0;\n\trep (i, H){\n\t\trep (j, W){\n\t\t\tvector<vector<char> > s = stones;\n\t\t\ts[i][j] = '0';\n\t\t\tint curr = smulate(s, H, W, K);\n\t\t\tres = max(res, curr);\n\t\t} // end rep\n\t} // end rep\n\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\nint h,w,m;\n\nll f(vvi a) {\n  ll res = 0;\n  bool up = false;\n  rep(i,h) {\n    vi t;\n    rep(j,w) {\n      if (a[i][j]) t.pb(a[i][j]);\n    }\n    while (sz(t) < w) t.pb(0);\n    a[i] = t;\n  }\n  rep(i,h)rep(j,w) {\n    if (!a[i][j]) continue;\n    int s = i;\n    while (s < h && a[i][j] == a[s][j]) ++s;\n    if (s-i >= m) {\n      up = true;\n      for (int k = i; k < s; ++k) {\n        res += a[k][j];\n        a[k][j] = 0;\n      }\n    }\n  }\n  if (up) return f(a)*2+res;\n  return 0;\n}\n\nint main() {\n  scanf(\"%d%d%d\",&w,&h,&m);\n  vvi a(h,vi(w));\n  rep(i,w) {\n    string s;\n    cin >> s;\n    rep(j,h) a[j][w-1-i] = s[j]-'0';\n  }\n  ll ans = 0;\n  rep(i,h)rep(j,w) {\n    vvi b = a;\n    b[i][j] = 0;\n    maxs(ans,f(b));\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(_vs) for(auto _x : _vs){cout << _x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(_p) cout << _p.first << \" \" << _p.second << endl\n#define printVP(_vp) for(auto _p : _vp) printP(_p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nint H, W, K;\nvvi a;\n\nbool fall() {\n    bool updated = false;\n    rep(j, W) {\n        queue<int> holl;\n        rrep(i, H) {\n            if (!holl.empty() && a[i][j] != 0) {\n                int h = holl.front(); holl.pop();\n                a[h][j] = a[i][j];\n                a[i][j] = 0;\n                updated = true;\n            }\n            if (a[i][j] == 0) {\n                holl.push(i);\n            }\n        }\n    }\n\n    return updated;\n}\n\nint puyo() {\n    int t = 0;\n    rep(i, H) {\n        rep(j, W) {\n            if (a[i][j] == 0) continue;\n            int k;\n            for (k = j; k < W && a[i][k] == a[i][j]; k++) {\n                ;\n            }\n            if (k - j >= K) {\n                rep2(l, j, k) {\n                    t += a[i][l];\n                    a[i][l] = 0;\n                }\n            }\n            j = k - 1;\n        }\n    }\n    return t;\n}\n\nint solve() {\n    int score = 0;\n    for (int t = 1; fall(); t <<= 1) {\n        score += t * puyo();\n    }\n    return score;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> H >> W >> K;\n    a.resize(H, vi(W));\n    rep(i, H) {\n        string s;\n        cin >> s;\n        rep(j, W) {\n            a[i][j] = s[j] - '0';\n        }\n    }\n\n    int ans = 0;\n    vvi b = a;\n    rep(i, H) {\n        rep(j, W) {\n            a[i][j] = 0;\n            ans = max(ans, solve());\n            a = b;\n        }\n    }\n\n    cout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <climits>\n#include <sstream>\n#include <iomanip>\n#include <map>\n#include <stack>\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\nvoid calc(vector<vector<int>>& c, int x, int y)\n{\n\tauto H = (int)c.size();\n\tauto h = y;\n\tfor (auto l = y; l < H - 1; ++l)\n\t{\n\t\tif (c[l][x] > 0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tif (h < l)\n\t\t{\n\t\t\th = l;\n\t\t}\n\t\tfor (; h < H && c[h][x] == 0; ++h);\n\t\tif (h >= H)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tc[l][x] = c[h][x];\n\t\tc[h][x] = 0;\n\t}\n}\n\nint main()\n{\n\tint H, W, K;\n\tcin >> H >> W >> K;\n\tvector<vector<int>> c(H, vector<int>(W));\n\tfor (auto i = H - 1; i >= 0; --i)\n\t{\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (auto j = 0; j < W; ++j)\n\t\t{\n\t\t\tc[i][j] = s[j] - '0';\n\t\t}\n\t}\n\n\tauto ans = 0;\n\tfor (auto y = 0; y < H; ++y)\n\t{\n\t\tfor (auto x = 0; x < W; ++x)\n\t\t{\n\t\t\tauto result = 0;\n\t\t\tvector<vector<int>> temp(c);\n\t\t\ttemp[y][x] = 0;\n\t\t\tcalc(temp, x, y);\n\n\t\t\tauto mul = 1;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tauto sum = 0;\n\t\t\t\tfor (auto h = y; h < H; ++h)\n\t\t\t\t{\n\t\t\t\t\tauto num = 0;\n\t\t\t\t\tauto count = 0;\n\t\t\t\t\tfor (auto w = 0; w < W; ++w)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (num == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnum = temp[h][w];\n\t\t\t\t\t\t\tcount = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (num != temp[h][w])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (count >= K)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsum += num * count;\n\t\t\t\t\t\t\t\tfor (auto i = 0; i < count; ++i)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttemp[h][w - 1 - i] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum = temp[h][w];\n\t\t\t\t\t\t\tcount = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t++count;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (count >= K)\n\t\t\t\t\t{\n\t\t\t\t\t\tsum += num * count;\n\t\t\t\t\t\tfor (auto i = 0; i < count; ++i)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttemp[h][W - 1 - i] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (sum <= 0)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor (auto i = 0; i < W; ++i)\n\t\t\t\t{\n\t\t\t\t\tcalc(temp, i, y);\n\t\t\t\t}\n\n\t\t\t\tresult += sum * mul;\n\t\t\t\tmul *= 2;\n\t\t\t}\n\n\t\t\tans = max(ans, result);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint H,W,K;\nint m[40][40];\nint n[40][40];\nstring s[40];\n\nvoid printn(){\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            cout << n[i][j] << ' ';\n        }\n        cout << endl;\n    }\n    cout << \"-----------------------\" << endl;\n}\n\nint sc(int t){\n    int score = 0;\n    for(int i=0;i<H;i++){\n        int now = 0;\n        int l = 0;\n        for(int j=0;j<W;j++){\n            if(n[i][j] == 0){\n                if(l >= K){\n                    score += now * l;\n                    for(int k=0;k<l;k++) n[i][j-1-k] = 0;\n                }\n                now = 0;\n                l = 0;\n                continue;\n            }\n            if(n[i][j] == now){\n                l++;\n                continue;\n            }\n            if(l >= K){\n                score += now * l;\n                for(int k=0;k<l;k++) n[i][j-1-k] = 0;\n            }\n            now = n[i][j];\n            l = 1;\n        }\n        if(l >= K){\n            score += now * l;\n            for(int k=0;k<l;k++) n[i][W-1-k] = 0;\n        }        \n    }\n    return score * t;\n}\n\nvoid fall(){\n    for(int i=0;i<W;i++){\n        vector<int> v;\n        for(int j=H-1;j>=0;j--){\n            if(n[j][i] != 0) v.push_back(n[j][i]);\n        }\n        for(int j=0;j<H;j++) n[j][i] = 0;\n        for(int j=0;j<v.size();j++) n[H-1-j][i] = v[j];\n    }\n}\n\nint calc(int h, int w){\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            n[i][j] = m[i][j];\n        }\n    }\n    n[h][w] = 0;\n    //printn();\n    fall();\n    int score = 0;\n    int turn = 1;\n    while(true){\n        //printn();\n        int s = sc(turn);\n        score += s;\n        //printn();\n        if(s == 0) break;\n        fall();\n        turn *= 2;\n    }\n    return score;\n}\n\nint main(){\n    cin >> H >> W >> K;\n    for(int i=0;i<H;i++) cin >> s[i];\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            m[i][j] = s[i][j] - '0';\n        }\n    }\n    int max_p = 0;\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            max_p = max(max_p, calc(i,j));\n        }\n    }\n    cout << max_p << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<unordered_set>\n#include<vector>\n#include<array>\n#include<string>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<functional>\n#include<random>\n#include<complex>\n#include<bitset>\n#include<chrono>\n//#include<boost/multiprecision/cpp_int.hpp>\n#define int int64_t\n#define uint uint64_t\n#define REP(i, a, b) for (int64_t i = (int64_t)(a); i < (int64_t)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (auto x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define Min(x) *min_element(ALL(x))\n#define Max(x) *max_element(ALL(x))\n#define Unique(L) (L.erase(unique(ALL(L)), L.end()))\n#define veccat(v1, v2) std::copy((v2).begin(),(v2).end(),std::back_inserter(v1)/*v1の後ろにv2を入れる*/)\n#define intmax (std::numeric_limits<int64_t>::max() / 4)\nusing namespace std;\n//typedef boost::multiprecision::cpp_int bigint;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\n\nint H, W, K;\n\nvoid gravity(vector<vector<int>>&F) {\n\trep(x, W) {\n\t\tint D = H - 1;\n\t\tfor (; 1 <= D && F[D][x]; D--);\n\t\tif (D == 0)continue;\n\t\tint U = D - 1;\n\t\tfor (; 0 <= U && F[U][x] == 0; U--);\n\t\tif (U < 0)continue;\n\t\twhile (1) {\n\t\t\tswap(F[D][x], F[U][x]);\n\t\t\tfor (; 1 <= D && F[D][x]; D--);\n\t\t\tif (D == 0)break;\n\t\t\tfor (; 0 <= U && F[U][x] == 0; U--);\n\t\t\tif (U < 0)break;\n\t\t}\n\t}\n}\nvoid solve(vector<vector<int>>&F, array<int, 512> &chain, int depth) {\n\tint erase = 0;\n\trep(y, H) {\n\t\tfor (int x = 0; x < W;) {\n\t\t\tint serial = 1;\n\t\t\tfor (; x+serial < W && F[y][x + serial - 1] == F[y][x + serial]; serial++);\n\t\t\tif (K <= serial && F[y][x]) {\n\t\t\t\terase += serial * F[y][x];\n\t\t\t\trep(i, serial)F[y][x + i] = 0;\n\t\t\t}\n\t\t\tx += serial;\n\t\t}\n\t}\n\tchain[depth] = erase;\n\tif (erase == 0)return;\n\tgravity(F);\n\tsolve(F, chain, depth + 1);\n\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> H >> W >> K;\n\tvector<vector<int>>F(H, vector<int>(W));\n\trep(i, H) {\n\t\tstring S;\n\t\tcin >> S;\n\t\trep(j, W)F[i][j] = S[j] - '0';\n\t}\n\n\tint ans = 0;\n\trep(h, H)rep(w, W) {\n\t\tauto FF = F;\n\t\tFF[h][w] = 0;\n\t\tgravity(FF);\n\t\tarray<int, 512>chain;\n\t\trep(i, 512)chain[i] = 0;\n\t\tsolve(FF, chain, 0);\n\t\tint keisuu = 1,score = 0;\n\t\tfor (int i = 0; chain[i] != 0; i++) {\n\t\t\tscore += keisuu * chain[i];\n\t\t\tkeisuu *= 2;\n\t\t}\n\t\tans = max(ans, score);\n\t}\n\n\n\tcout << ans << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <map>\n#include <set>\n#include <array>\n#include <queue>\n#include <string>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#define MOD 1000000007\n#define INF 11234567890\n#define in std::cin\n#define out std::cout\n#define rep(i,N) for(LL i=0;i<N;++i)\ntypedef long long int LL;\ntypedef std::pair<int, int> P;\n\nint H, W, K, c[51][51];\nLL ans = -1;\n\nLL score(int x, int y)\n{\n\tLL res = 0;\n\tint tmp[51][51];\n\trep(i, H) { rep(j, W) { tmp[i][j] = c[i][j]; } }\n\tfor (int i = x; i > 0; --i) { tmp[i][y] = tmp[i - 1][y]; }\n\tfor (int i = 1; i < H; ++i)\n\t{\n\t\tbool flag = true;\n\t\tfor (int j = 1; j < W; ++j)\n\t\t{\n\t\t\tif (tmp[i][0] != tmp[i][j]) { flag = false; }\n\t\t}\n\t\tif (flag == true) { res += tmp[i][0] * W; }\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tin >> H >> W >> K;\n\tif (W != K) { return 0; }\n\trep(i, H)\n\t{\n\t\tstd::string tmp;\n\t\tin >> tmp;\n\t\trep(j, W)\n\t\t{\n\t\t\tc[i][j] = tmp[j] - '0';\n\t\t}\n\t}\n\n\trep(i, H)\n\t{\n\t\trep(j, W)\n\t\t{\n\t\t\tans = std::max(ans, score(i, j));\n\t\t}\n\t}\n\n\tout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\n#define REP(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define ALL(a) begin(a),end(a)\n#define ifnot(a) if(not (a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\nusing namespace std;\n\n// #define int ll\n#ifdef _MSC_VER\nconst bool test = true;\n#else \nconst bool test = false;\n#endif\n\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n#define INF (1 << 28)\null mod = (int)1e9 + 7;\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nint H, W, K;\nvector<string> c;\n\nll f(int sy, int sx, vector<string> c) {\n\tbool update;\n\tll res = 0;\n\tc[sy][sx] = '0';\n\trep(i, 100) {\n\t\tif (test) {\n\t\t\tcout << endl;\n\t\t\trep(i, H) cout << c[i] << endl;\n\t\t\tdump(res);\n\t\t}\n\t\trep(j, W) for (int k = H - 1; k > -1; k--) {\n\t\t\tif (c[k][j] != '0') continue;\n\t\t\tfor (int l = k; l > -1; l--)  {\n\t\t\t\tif (c[l][j] != '0') {\n\t\t\t\t\tc[k][j] = c[l][j];\n\t\t\t\t\tc[l][j] = '0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (test) {\n\t\t\tcout << endl;\n\t\t\trep(i, H) cout << c[i] << endl;\n\t\t}\n\t\tupdate = false;\n\t\trep(j, H) rep(begin, W) {\n\t\t\tif (c[j][begin] == '0') continue;\n\t\t\tint end = begin;\n\t\t\twhile (c[j][end] == c[j][begin] && end < W) end++;\n\t\t\tif (end - begin < K) continue;\n\t\t\tREP(k, begin, end) {\n\t\t\t\tupdate = true;\n\t\t\t\tres += (c[j][k] - '0') * (1 << i);\n\t\t\t\tc[j][k] = '0';\n\t\t\t}\n\t\t}\n\n\t\tif (not update) {\n\t\t\treturn res;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> H >> W >> K;\n\tc.resize(H);\n\trep(i, H) cin >> c[i];\n\tll best = 0;\n\trep(sy, H) rep(sx, W) {\n\t\tll tmp = f(sy, sx, c);\n\t\tif (best < tmp) best = tmp;\n\t}\n\tcout << best << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\n#define REP(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define ALL(a) begin(a),end(a)\n#define ifnot(a) if(not (a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\nusing namespace std;\n\n// #define int ll\n#ifdef _MSC_VER\nconst bool test = true;\n#else \nconst bool test = false;\n#endif\n\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n#define INF (1 << 28)\null mod = (int)1e9 + 7;\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nint H, W, K;\nvector<string> c;\n\nll f(int sy, int sx, vector<string> c) {\n\tbool update;\n\tll res = 0;\n\tc[sy][sx] = '0';\n\trep(i, 100) {\n\t\tif (test) {\n\t\t\tcout << endl;\n\t\t\trep(i, H) cout << c[i] << endl;\n\t\t\tdump(res);\n\t\t}\n\t\trep(j, W) for (int k = H - 1; k > -1; k--) {\n\t\t\tif (c[k][j] != '0') continue;\n\t\t\tfor (int l = k; l > -1; l--)  {\n\t\t\t\tif (c[l][j] != '0') {\n\t\t\t\t\tc[k][j] = c[l][j];\n\t\t\t\t\tc[l][j] = '0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tupdate = false;\n\t\trep(j, H) rep(begin, W) {\n\t\t\tif (c[j][begin] == '0') continue;\n\t\t\tint end = begin;\n\t\t\twhile (c[j][end] == c[j][begin] && end < W) end++;\n\t\t\tif (begin + 1 == end) continue;\n\t\t\tREP(k, begin, end) {\n\t\t\t\tupdate = true;\n\t\t\t\tres += (c[j][k] - '0') * (1 << i);\n\t\t\t\tc[j][k] = '0';\n\t\t\t}\n\t\t}\n\n\t\tif (not update) {\n\t\t\treturn res;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> H >> W >> K;\n\tc.resize(H);\n\trep(i, H) cin >> c[i];\n\tll best = 0;\n\trep(sy, H) rep(sx, W) {\n\t\tll tmp = f(sy, sx, c);\n\t\tif (best < tmp) best = tmp;\n\t}\n\tcout << best << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define int long long\n#define dotimes(i, n) for (int i : range(n))\n\nusing namespace std;\n\nclass range {\n  class iterator {\n    int i, s;\n  public:\n    iterator(int i, int s): i(i), s(s) {}\n    int& operator*() {\n      return i;\n    }\n    void operator++() {\n      i += s;\n    }\n    bool operator!=(iterator const& that) {\n      return i < that.i;\n    }\n  };\n  iterator b, e;\npublic:\n  range(int e): b({0, 1}), e({e, 1}) {}\n  range(int b, int e): b({b, 1}), e({e, 1}) {}\n  range(int b, int e, int s): b({b, s}), e({e, s}) {}\n  iterator begin() {\n    return b;\n  }\n  iterator end() {\n    return e;\n  }\n};\n\nint rint() {\n  int n;\n  scanf(\"%lld\", &n);\n  return n;\n}\n\nvoid wint(int n) {\n  printf(\"%lld\\n\", n);\n}\n\ntemplate<typename T>\ninline int size(T container) {\n  return static_cast<int>(container.size());\n}\n\ntemplate<typename T>\ninline bool maxs(T& a, T const& b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate<typename T>\ninline bool mins(T& a, T const& b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\nsigned main() {\n  int H = rint();\n  int W = rint();\n  int K = rint();\n  int board0[H][W];\n  dotimes(j, H) {\n    char s[W+1];\n    scanf(\"%s\\n\", s);\n    dotimes(i, W)\n      board0[H-j-1][i] = s[i] - '0';\n  }\n  int r = 0;\n  dotimes(y, H) dotimes(x, W) {\n    int board[H][W+1] = {};\n    dotimes(j, H) dotimes(i, W)\n      board[j][i] = board0[j][i];\n    for (int j : range(y+1, H))\n      board[j-1][x] = board[j][x];\n    board[H-1][x] = 0;\n    int g = 0;\n    for (int t = 1; ; t <<= 1) {\n      int s = 0;\n      dotimes(j, H) {\n        int k = 1;\n        dotimes(i, W)\n          if (board[j][i+1] == board[j][i])\n            k++;\n          else {\n            if (k >= K) {\n              s += board[j][i] * k;\n              dotimes(l, k)\n                board[j][i-l] = 0;\n            }\n            k = 1;\n          }\n      }\n      if (!s)\n        break;\n      g += t * s;\n      dotimes(i, W) {\n        int k = 0;\n        dotimes(j, H)\n          if (board[j][i])\n            board[k++][i] = board[j][i];\n        while (k < H)\n          board[k++][i] = 0;\n      }\n    }\n    maxs(r, g);\n  }\n  wint(r);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nint main() {\n    int H, W, K;\n    cin >> H >> W >> K;\n\n    vector<vector<int>> c(H+2, vector<int>(W+2, 0));\n    char in;\n\n    for (int i = 1; i <= H; i++) {\n        for (int j = 1; j <= W; j++) {\n            cin >> in;\n            c[i][j] = in - '0';\n        }\n    }\n\n\n\n    int answer = 0;\n    vector<vector<int>> board(H+2, vector<int>(W+2, 0));\n\n    for (int delete_i = 1; delete_i <= H; delete_i++) {\n        for (int delete_j = 1; delete_j <= W; delete_j++) {\n            board = c;\n\n            for (int i = delete_i; i >= 1; i--) {\n                board[i][delete_j] = board[i-1][delete_j];\n            }\n\n            int point = 0, tmp_number = 0, tmp_count = 0;\n            bool combo = false;\n\n            int increment = 0;\n\n            // 連鎖する石が存在する限り続ける\n            do {\n                combo = false;\n\n                for (int i = 1; i <= H; i++) {\n                    tmp_number = 0, tmp_count = 0;\n\n                    for (int j = 0; j < W+2; j++) {\n                        // 前の石まででK個以上同じ石が連続したとき\n                        if (tmp_count >= K) {\n                            // 同じ石の場合\n                            if (board[i][j] == tmp_number) {\n                                tmp_count += 1;\n                            \n                            // 違う石の場合得点加算\n                            } else {\n                                combo = true;\n                                point += tmp_number * tmp_count * (int)(pow(2.0, (float)increment));\n\n                                // 石を1行下にずらす\n                                for (int x = i; x >= 1; x--) {\n                                    for (int y = j - tmp_count; y < j; y++) {\n                                        board[x][y] = board[x-1][y]; \n                                    }\n                                }\n\n                                tmp_number = board[i][j];\n                                tmp_count = 1;\n                            }\n                        } else {\n                            if (board[i][j] == 0) {\n                                tmp_number = 0;\n                                tmp_count = 1;\n                                continue;\n                            }\n\n                            if (board[i][j] == tmp_number) {\n                                tmp_count += 1;\n                            } else {\n                                tmp_number = board[i][j];\n                                tmp_count = 1;\n                            }\n\n                        }\n                    }\n                }\n\n                increment++;\n            } while (combo == true);\n\n            answer = max(answer, point);\n        }\n    }\n\n    cout << answer << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<string>\n#include<sstream>\n#include<cmath>\n#include<numeric>\n#include<map>\n#include<stack>\n#include<queue>\n#include<list>\n#include<set>\nusing namespace std;\nint mod = 1e9+7;\nint h, w, k;\nvector<string> c;\nchar B = '-';\n\nvoid show(vector<string> b) {\n  for(int i=0; i<h; i++) cerr << b[i] << endl;\n  cerr << endl;\n}\n\nvector<string> del(vector<string> b) {\n  vector<string> ret = b;\n  for(int i=0; i<h; i++){\n    string s = ret[i];\n    int cnt = 0;\n    for(int j=0; j<w; j++){\n      if( s[j] == s[j+1] ) cnt++;\n      else {\n        if( cnt >= k-1 ) {\n          for(int l=0; l<cnt+1; l++){\n            s[j-l] = B;\n          }\n          cnt = 0;\n        }\n      }\n    }\n    ret[i] = s;\n  }\n  return ret;\n}\n\nvector<string> drop(vector<string> b) {\n  for(int j=0; j<w; j++){\n    string s = \"\";\n    for(int i=0; i<h; i++){\n      if( b[i][j] != B ) {\n        s += b[i][j];\n      }\n    }\n    s = string(h-s.size(), B) + s;\n    for(int i=0; i<h; i++){\n      b[i][j] = s[i];\n    }\n  }\n  return b;\n}\n\nint calc(vector<string> b) {\n  int ret = 0;\n  for(int i=0; i<h; i++) {\n    for(int j=0; j<w; j++){\n      if( b[i][j] == B ) continue;\n      ret += b[i][j]-'0';\n    }\n  }\n  return ret;\n}\n\nint simulate(vector<string> b, int x, int y) {\n\n  b[y][x] = B;\n  vector<string> old = b;\n  vector<string> now = b;\n  int score = 0;\n  int turn = 1;\n  while( true ) {\n    // show(now);\n    now = drop(now);\n    // show(now);\n    now = del(now);\n    int sum = calc(old) - calc(now);\n    // cerr << turn << \" \" << turn * sum << endl;\n    score += turn * sum;\n\n    if( now == old ) break;\n    old = now;\n    turn *= 2;\n  }\n  // show(now);\n\n  return score;\n}\n\nint main() {\n  cin >> h >> w >> k;\n  c.resize(h);\n  for(int i=0; i<h; i++) cin >> c[i];\n\n  simulate(c, 0, 0);\n\n  int ans = 0;\n  for(int i=0; i<h; i++){\n    for(int j=0; j<w; j++){\n      int tmp = simulate(c, j, i);\n      if( ans < tmp ){\n        cerr << tmp << \" \" << j << \" \" << i << endl;\n      }\n      ans = max(ans, tmp);\n    }\n  }\n  cout << ans << endl;\n\n\n  return 0;\n}\n\n\n\n//\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair< ll, ll > Pi;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep2(i,n) for(int i=1;i<=(n);i++)\n#define rep3(i,i0,n) for(int i=i0;i<(n);i++)\n#define pb push_back\n#define mod 1000000007\nconst ll INF = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nll gcd(ll a, ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b) {return a/gcd(a,b)*b;}\n#define all(x) x.begin(), x.end()\n#define mp make_pair\nbool compare(Pi a, Pi b) {\n    if(a.first != b.first){\n        return a.first < b.first;\n        \n    }else{\n        return a.second < b.second;\n    }\n}\n\nint ctoi(char c) {\n\tif (c >= '0' && c <= '9') {\n\t\treturn c - '0';\n\t}\n\treturn 0;\n}\nbool In_map(ll y,ll x,ll h,ll w){\n    if(y<0 || x<0 || y>=h || x>=w){\n        return 0;\n    }else{\n        return 1;\n    }\n}\nconst vector<ll> dx{1,0,-1,0};\nconst vector<ll> dy{0,1,0,-1};\n\n\n\nint main() {\n\n    ll H,W,K;\n    cin >>H>>W>>K;\n    vector<string> S(H+1);\n    rep(i,H) cin >>S[i];\n    vector<vector<ll>> R(H+1,vector<ll>(W+1));\n    vector<vector<ll>> R2(H+1,vector<ll>(W+1));\n    rep(i,H) rep(j,W) R[i][j] = ctoi(S[i][j]);\n    R2 = R;\n    if(K<=1){\n        ll ans = 0;\n        ll min = INF;\n        rep(i,H){\n            rep(j,W){\n                chmin(min,R[i][j]);\n                ans+=R[i][j];\n            }\n        }\n        cout << ans-min<<endl;\n        return 0;\n    }\n\n\n    ll fans = 0;\n    rep(h,H) rep(w,H){\n    ll ans = 0;\n    R=R2;\n    //R[h][w] = -1;\n    ll flag = 0;\n    rep(m,H){\n        ll p2 =pow(2,m); \n        rep(j,W){\n            vector<ll> tmp;\n            rep(i,H){\n                if(R[H-1-i][j] != -1){\n                    tmp.pb(R[H-1-i][j]);\n                }\n            }\n            rep(i,H){\n                if(i<tmp.size()){\n                    R[H-1-i][j] = tmp[i];\n                }else{\n                    R[H-1-i][j] = -1;\n                }\n            }\n        }\n        rep(i,H){\n            ll cnt=0;\n            ll p=-1;\n            rep(j,W){\n                if(R[i][j] == p && R[i][j] != -1){\n                    cnt++;\n                    if(j==W-1){\n                        if(cnt>=K){\n                            flag = 1;\n                            //ans += R[i][j-1]*cnt*p2;\n                            rep(k,cnt){\n                               // R[i][j-k] = -1;\n                            }\n                        }\n                    }\n                }else{\n                    if(cnt>=K){\n                        flag = 1;\n                        //ans += R[i][j-1]*cnt*p2;\n                        rep(k,cnt){\n                            //R[i][j-k-1] = -1;\n                        }\n                    }\n                    cnt = 1;\n                }\n                \n\n                p = R[i][j];\n            }\n        \n        \n        }\n\n        if(flag ==0) break;\n    }\n\n\n        chmax(fans,ans);\n    }\n\n    cout << fans<<endl;\n    \n    return 0;\n    \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n//#pragma GCC optimize (\"-O3\") \n#ifdef YANG33\n#include \"mydebug.hpp\"\n#else\n#define DD(x) \n#endif\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\n\n/* -----  2019/07/09  Problem: SQUARE869120CONTEST_03 B / Link: https://atcoder.jp/contests/s8pc-3/  ----- */\n\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tLL H, W, K; cin >> H >> W >> K;\n\tvector<string> s(H);\n\tfor (int i = 0; i < H; ++i) {\n\t\tcin >> s[i];\n\t\tFOR(j, 0, W) {\n\t\t\ts[i][j] -= '0';\n\t\t}\n\t}\n\tauto fall = [](VS& s) {\n\t\tint H = SZ(s), W = SZ(s[0]);\n\t\tFOR(j, 0, W) {\n\t\t\tvector<int>a;\n\t\t\tFOR(i, 0, H) {\n\t\t\t\tif (s[i][j])a.push_back(s[i][j]);\n\t\t\t\ts[i][j] = 0;\n\t\t\t}\n\t\t\tFOR(i, 0, SZ(a)) {\n\t\t\t\ts[H - i - 1][j] = a[SZ(a) - 1 - i];\n\t\t\t}\n\t\t}\n\t};\n\tauto f = [&K, &fall](int aa, int bb, auto s) {\n\t\ts[aa][bb] = 0;\n\t\tLL ret = 0;\n\t\tbool upd = 1;\n\t\tLL t = 0;\n\t\tint H = SZ(s), W = SZ(s[0]);\n\t\twhile (upd) {\n\t\t\tfall(s);\n\t\t\tupd = 0;\n\t\t\tLL sub = 0;\n\t\t\t{ // check\n\t\t\t\tFOR(i, 0, H) {\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tint pre = -1;\n\t\t\t\t\tFOR(j, 0, W) {\n\t\t\t\t\t\tif (s[i][j] == pre)cnt++;\n\t\t\t\t\t\telse if (s[i][j] != pre && cnt >= K) {\n\t\t\t\t\t\t\tupd |= pre;\n\t\t\t\t\t\t\twhile (cnt) {\n\t\t\t\t\t\t\t\tint k = j - cnt;\n\t\t\t\t\t\t\t\tsub += s[i][k];\n\t\t\t\t\t\t\t\ts[i][k] = 0;\n\t\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpre = s[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (s[i][j] != pre) {\n\t\t\t\t\t\t\tpre = s[i][j];\n\t\t\t\t\t\t\tcnt = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (pre != -1 && cnt >= K) {\n\t\t\t\t\t\tupd |= pre;\n\t\t\t\t\t\twhile (cnt) {\n\t\t\t\t\t\t\tint k = W - cnt;\n\t\t\t\t\t\t\tsub += s[i][k];\n\t\t\t\t\t\t\ts[i][k] = 0;\n\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tret += (LL)pow(2LL, t)*sub;\n\t\t\tt++;\n\t\t}\n\t\treturn ret;\n\t};\n\tLL ans = 0LL;\n\tFOR(i, 0, H) {\n\t\tFOR(j, 0, W) {\n\t\t\tans = max(ans, f(i, j, s));\n\t\t}\n\t}\n\n\n\tcout << (ans) << \"\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//四則演算 #pragma GCC target(\"avx\")\n//並列計算 #pragma GCC optimize(\"O3\")\n//条件分岐を減らす #pragma GCC optimize(\"unroll-loops\")\n//浮動小数点演算 #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing VI = vector<int>;\nusing VL = vector<ll>;\nusing VS = vector<string>;\ntemplate<class T> using PQ = priority_queue<T, vector<T>, greater<T>>;\n#define FOR(i,a,n) for(int i=(a);i<(n);++i)\n#define eFOR(i,a,n) for(int i=(a);i<=(n);++i)\n#define rFOR(i,a,n) for(int i=(n)-1;i>=(a);--i)\n#define erFOR(i,a,n) for(int i=(n);i>=(a);--i)\n#define each(i, a) for(auto &i : a)\n#define SORT(a) sort(a.begin(),a.end())\n#define rSORT(a) sort(a.rbegin(),a.rend())\n#define fSORT(a,f) sort(a.begin(),a.end(),f)\n#define all(a) a.begin(),a.end()\n#define out(y,x) ((y)<0||h<=(y)||(x)<0||w<=(x))\n#define tp(a,i) get<i>(a)\n#define line cout << \"-----------------------------\\n\" \n#define ENDL(i,n) ((i) == (n) - 1 ? \"\\n\" : \" \")\n#define stop system(\"pause\")\nconstexpr ll INF = 1000000000;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr ll mod = 1000000007;\nconstexpr ll MOD = 998244353;\nconstexpr ld eps = 1e-10;\nconstexpr ld pi = 3.1415926535897932;\ntemplate<class T>inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T>inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; }return false; }\ninline void init() { cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); }\ntemplate<class T>inline istream& operator>>(istream& is, vector<T>& v) { for (auto& a : v)is >> a; return is; }\ntemplate<class T>inline istream& operator>>(istream& is, deque<T>& v) { for (auto& a : v)is >> a; return is; }\ntemplate<class T, class U>inline istream& operator>>(istream& is, pair<T, U>& p) { is >> p.first >> p.second; return is; }\ntemplate<class T>inline vector<T> vec(size_t a) { return vector<T>(a); }\ntemplate<class T>inline vector<T> defvec(T def, size_t a) { return vector<T>(a, def); }\ntemplate<class T, class... Ts>inline auto vec(size_t a, Ts... ts) { return vector<decltype(vec<T>(ts...))>(a, vec<T>(ts...)); }\ntemplate<class T, class... Ts>inline auto defvec(T def, size_t a, Ts... ts) { return vector<decltype(defvec<T>(def, ts...))>(a, defvec<T>(def, ts...)); }\ntemplate<class T>inline void print(const T& a) { cout << a << \"\\n\"; }\ntemplate<class T, class... Ts>inline void print(const T& a, const Ts&... ts) { cout << a << \" \"; print(ts...); }\ntemplate<class T>inline void print(const vector<T>& v) { for (int i = 0; i < v.size(); ++i)cout << v[i] << (i == v.size() - 1 ? \"\\n\" : \" \"); }\ntemplate<class T>inline void print(const vector<vector<T>>& v) { for (auto& a : v)print(a); }\ninline string reversed(const string& s) { string t = s; reverse(all(t)); return t; }\n\nint main() {\n    init();\n\n    int h, w, k; cin >> h >> w >> k;\n    if (4 <= k) {\n        print(0);\n        return 0;\n    }\n    VS s(h); cin >> s;\n    VS t = s;\n\n    function<void(int)> drop = [&](int x)->void {\n        int b = h - 1;\n        rFOR(y, 0, h)if (s[y][x] != 'x') {\n            swap(s[y][x], s[b][x]);\n            --b;\n        }\n    };\n\n    function<int(int, int)> solve = [&](int sy, int sx)->int {\n        s[sy][sx] = 'x';\n        drop(sx);\n        int res = 0;\n        for (int i = 0;; ++i) {\n            bool m = false;\n            FOR(y, 0, h)FOR(x, 0, w - k + 1) {\n                char c = s[y][x];\n                if (c == 'x')continue;\n                int p = 1;\n                for (; x + p < w && s[y][x + p] == c; ++p);\n                if (k <= p) {\n                    m = true;\n                    res += (1 << i) * (c - '0') * p;\n                    FOR(q, 0, p)s[y][x + q] = 'x';\n                    x += p - 1;\n                }\n            }\n            if (m)FOR(x, 0, w)drop(x);\n            else break;\n        }\n        return res;\n    };\n\n    int ans = 0;\n    FOR(y, 1, h)FOR(x, 0, w) {\n        s = t;\n        chmax(ans, solve(y, x));\n    }\n    print(ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 50;\n\nint P[N];\n\nint n, m, K, mat[N][N], a[N][N];\n\nint go(){\n    int sum = 0;\n    int cnt;\n    for(int i=1; i<=n; i++){\n        for(int j=1; j<=m; j++){\n            if(a[i][j]){\n                cnt = 0;\n                for(int k=j; k<=m; k++){\n                    if(a[i][k] == a[i][j]){\n                        cnt++;\n                    } else {\n                        break;\n                    }\n                }\n                if(cnt >= K){\n                    for(int k=j+1; k<=m; k++){\n                        if(a[i][k] != a[i][j])  break;\n                        a[i][k] = 0;\n                    }\n                    sum = sum + cnt * a[i][j];\n                    a[i][j] = 0;\n                }\n            }\n        }\n    }\n\n    for(int j=1; j<=m; j++){\n        for(int i=n; i>=1; i--){\n            if(a[i][j] == 0){\n                for(int k=i-1; k>=1; k--){\n                    if(a[k][j]){\n                        swap(a[k][j], a[i][j]);\n                        break;\n                    }\n                }\n                if(!a[i][j]){\n                    break;\n                }\n            }\n        }\n    }\n\n    return sum;\n}\n\nint solve(int x, int y){\n    for(int i=1; i<=n; i++){\n        for(int j=1; j<=m; j++){\n            a[i][j] = mat[i][j];\n        }\n    }\n    for(int i=x; i>1; i--){\n        a[i][y] = a[i-1][y];\n    }\n    a[1][y] = 0;\n    int ret = 0;\n    for(int g=0; ;g++){\n        int v = go();\n        if(!v){\n            break;\n        }\n        ret = ret + P[g] * v;\n    }\n    return ret;\n}\n\nchar s[N];\n\nint main(){\n    P[0] = 1;\n    for(int i=1; i<N; i++){\n        P[i] = P[i-1] << 1;\n    }\n    while(~scanf(\"%d %d %d\", &n, &m, &K)){\n        for(int i=1; i<=n; i++){\n            scanf(\"%s\", s);\n            for(int j=1; j<=m; j++){\n                mat[i][j] = s[j-1] - '0';\n            }\n        }\n        int ans = 0;\n        for(int i=1; i<=n; i++){\n            for(int j=1; j<=m; j++){\n                ans = max(ans, solve(i, j));\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include<iostream>\n#include<functional>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<iomanip>\n#include<set>\n#include<map>\n#include<utility>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\n#define LL long long\nconst int dx[4] = { 1,0,-1,0 };\nconst int dy[4] = { 0,1,0,-1 };\nbool IA(int x, int y, int H, int W) { return (0<=x && x<=H) && (0<=y && y<=W); }\n\nint H,W,K,c[50][50],ans=0;\n\nint main(){\n\tcin>>H>>W>>K;\n\tfor(int i=H-1;i>=0;i--)for(int j=0;j<W;j++)cin>>c[i][j];\n\tfor(int si=0;si<H-1;si++)for(int sj=0;sj<W;sj++){\n\t\tint tmp=0;\n\t\tfor(int i=0;i<H-1;i++){\n\t\t\tbool flg=true;\n\t\t\tint x;\n\t\t\tfor(int j=1;j<W;j++){\n\t\t\t\tif(si<=i && (j==sj || j-1==sj)){\n\t\t\t\t\tif(j==sj && c[i][j-1]!=c[i+1][j])flg=false;\n\t\t\t\t\tif(j-1==sj && c[i+1][j-1]!=c[i][j])flg=false;\n\t\t\t\t}\n\t\t\t\telse if(c[i][j]!=c[i][j-1])flg=false;\n\t\t\t\telse x = c[i][j];\n\t\t\t}\n\t\t\tif(flg)tmp+=x*W;\n\t\t}\n\t\tans=max(ans,tmp);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(int)n;i++)\nusing namespace std;\n\nint main(){\n  int H,W,K,a=0;\n  cin>>H>>W>>K;\n  vector<string> B(H),b(H);\n  string st;\n  REP(i,H){\n    cin>>st;\n    B[i]='#'+st+'#';\n  }\n  for(int i=1;i<H;i++) for(int j=1;j<W+1;j++){\n    REP(k,H) b[k]=B[k];\n    for(int i2=i;i2>0;i2--) b[i2][j]=b[i2-1][j];\n    b[0][j]='s';\n    int p=0,x=0,f=1;\n    while(f){\n      f=0;\n      char pn,nn;\n      REP(i1,H){\n        int num=0;\n        for(int j1=1;j1<W+2;j1++){\n          pn=b[i1][j1-1];\n          nn=b[i1][j1];\n          if(nn==pn){\n            num++;\n            continue;\n          }else if(num>=K&&pn!='s'){\n            p+=(pn-'0')*num*pow(2,x);\n            for(int i2=i1;i2>0;i2--){\n              b[i2].replace(j1-num,num,b[i2-1].substr(j1-num,num));\n            }\n            b[0].replace(j1-num,num,num,'s');\n            f=1;\n          }\n          num=1;\n        }\n      }\n      x++;\n    }\n    a=max(a,p);     \n  }\n  cout<<a<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bits/stdc++.h>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define rep(X, S, E) for (int(X) = (S); (X) < (E); ++(X))\n#define rrep(X, S, E) for (int(X) = (E)-1; (X) >= (S); --(X))\n#define arep(X, Y) for (auto(X) : Y)\n#define all(X) (X).begin(), (X).end()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sc second\n#define print(x) cout << x << endl\n#define printDouble(x) cout << fixed << setprecision(13) << x << endl\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\n\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\n\nusing decendingQueue = priority_queue<ll, vl>;              //降順\nusing ascendingQueue = priority_queue<ll, vl, greater<ll>>; //昇順\n\nconst int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nconst int INT_INF = 1e9;\nconst ll LL_INF = 1e18;\nconst int mod = 1000000007;\n\ntemplate <class T> void mySort(vector<T> &X, bool isAscending) {\n  // 昇順\n  if (isAscending) {\n    sort(all(X));\n  } else {\n    // 降順\n    sort(all(X), greater<T>());\n  }\n}\n\nlong long gcd(long long m, long long n) {\n  if (m < n)\n    return gcd(n, m);\n  if (n == 0)\n    return m;\n  return gcd(n, m % n);\n}\n\nlong long lcm(long long m, long long n) {\n  // m * nでlong型のオーバフローを発生させないため、先に割り算から行う\n  return m * (n / gcd(m, n));\n}\n\n// auto mod int\n// https://youtu.be/L8grWxBlIZ4?t=9858\n// https://youtu.be/ERZuLAxZffQ?t=4807 : optimize\n// https://youtu.be/8uowVvQ_-Mo?t=1329 : division\nstruct mint {\n  ll x; // typedef long long ll;\n  mint(ll x = 0) : x((x % mod + mod) % mod) {}\n  mint &operator+=(const mint a) {\n    if ((x += a.x) >= mod)\n      x -= mod;\n    return *this;\n  }\n  mint &operator-=(const mint a) {\n    if ((x += mod - a.x) >= mod)\n      x -= mod;\n    return *this;\n  }\n  mint &operator*=(const mint a) {\n    (x *= a.x) %= mod;\n    return *this;\n  }\n  mint operator+(const mint a) const {\n    mint res(*this);\n    return res += a;\n  }\n  mint operator-(const mint a) const {\n    mint res(*this);\n    return res -= a;\n  }\n  mint operator*(const mint a) const {\n    mint res(*this);\n    return res *= a;\n  }\n  mint pow(ll t) const {\n    if (!t)\n      return 1;\n    mint a = pow(t >> 1);\n    a *= a;\n    if (t & 1)\n      a *= *this;\n    return a;\n  }\n\n  // for prime mod\n  mint inv() const { return pow(mod - 2); }\n  mint &operator/=(const mint a) { return (*this) *= a.inv(); }\n  mint operator/(const mint a) const {\n    mint res(*this);\n    return res /= a;\n  }\n};\n\n// combination mod prime\n// https://www.youtube.com/watch?v=8uowVvQ_-Mo&feature=youtu.be&t=1619\nstruct combination {\n  vector<mint> fact, ifact;\n  combination(int n) : fact(n + 1), ifact(n + 1) {\n    assert(n < mod);\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i)\n      fact[i] = fact[i - 1] * i;\n    ifact[n] = fact[n].inv();\n    for (int i = n; i >= 1; --i)\n      ifact[i - 1] = ifact[i] * i;\n  }\n  mint operator()(int n, int k) {\n    if (k < 0 || k > n)\n      return 0;\n    return fact[n] * ifact[k] * ifact[n - k];\n  }\n};\n\nvector<long long> SieveOfEratosthenes(int max) {\n  vector<long long> sieve;\n  vector<long long> primes;\n\n  for (int i = 1; i < max + 1; ++i) {\n    sieve.push_back(i);\n  }\n\n  sieve[0] = 0;\n  for (int i = 2; i < max + 1; ++i) {\n    if (sieve[i - 1] != 0) {\n      primes.push_back(sieve[i - 1]);\n      for (int j = 2 * sieve[i - 1]; j < max + 1; j += sieve[i - 1]) {\n        sieve[j - 1] = 0;\n      }\n    }\n  }\n  return primes;\n}\n\nclass UnionFindTree {\nprivate:\n  vector<int> par;\n  vector<int> rnk;\n  vector<int> siz;\n\npublic:\n  UnionFindTree(int n) {\n    par.assign(n, -1);\n    rnk.assign(n, -1);\n    siz.assign(n, -1);\n\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n      rnk[i] = 0;\n      siz[i] = 1;\n    }\n  }\n\n  int find(int x) {\n    if (par[x] == x)\n      return x;\n    else\n      return par[x] = find(par[x]);\n  }\n\n  bool same(int x, int y) { return find(x) == find(y); }\n\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y)\n      return;\n    if (rnk[x] < rnk[y]) {\n      par[x] = y;\n      siz[y] += siz[x];\n    } else {\n      par[y] = x;\n      siz[x] += siz[y];\n      if (rnk[x] == rnk[y])\n        ++rnk[x];\n    }\n  }\n\n  int size(int x) {\n    x = find(x);\n    return siz[x];\n  }\n};\n\nclass Edge {\npublic:\n  ll from;\n  ll to;\n  ll cost;\n\n  Edge() {}\n  Edge(ll from, ll to, ll cost) {\n    this->from = from;\n    this->to = to;\n    this->cost = cost;\n  }\n\n  bool operator<(const Edge &edge) const {\n    return cost < edge.cost; //昇順\n  }\n};\n\nclass Graph {\npublic:\n  ll nodes; // ノード数\n  vector<Edge> edges;\n\n  Graph() {}\n  Graph(ll nodes) { this->nodes = nodes; }\n  void addEdge(ll from, ll to, ll cost) {\n    this->edges.push_back(Edge(from, to, cost));\n  }\n};\n\n// クラスカル法\n// 連結グラフの最小全域木を求める\nclass Kruskal {\nprivate:\n  Graph graph;\n  vector<Edge> MinimumSpanningTree;\n  ll minimumCost;\n  void searchMinimumSpanningTree() {\n    UnionFindTree uf(graph.nodes);\n    sort(all(graph.edges));\n    for (auto edge : graph.edges) {\n      if (!uf.same(edge.from, edge.to)) {\n        uf.unite(edge.from, edge.to);\n        MinimumSpanningTree.push_back(edge);\n      }\n    }\n  }\n\npublic:\n  Kruskal(Graph graph) { this->graph = graph; }\n  ll getMinimumSpanningTreeCost() {\n    searchMinimumSpanningTree();\n    ll cost = 0;\n    for (auto tr : MinimumSpanningTree) {\n      cost += tr.cost;\n    }\n    return cost;\n  }\n};\n\n// ダイクストラ法 O((E+V)logV)\n// 最小経路問題を解くためのアルゴリズム。辺の重みに負数を含む場合は利用不可\n// 無向グラフの場合はコメントアウト箇所をコメントイン\nclass Dijkstra {\nprivate:\n  Graph graph;\n  map<ll, vector<Edge>> fromPaths;\n  vl distances;\n  vl srcs;\n\npublic:\n  Dijkstra(Graph graph) {\n    this->graph = graph;\n    for (auto edge : graph.edges) {\n      fromPaths[edge.from].push_back(edge);\n      // fromPaths[edge->to].push_back(Edge(edge->to, edge->from, edge->cost));\n    }\n  }\n  void searchMinimumPathFrom(ll src) {\n    // 複数回呼ばれる度に計算する\n    distances = vl(graph.nodes + 1, LL_INF);\n    srcs = vl(graph.nodes + 1, LL_INF);\n\n    // 距離が近い順番に捜査していく\n    priority_queue<pll, vector<pll>, greater<pll>> pq;\n    distances[src] = 0;\n    srcs[src] = -1;\n\n    pq.push(mp(0ll, src));\n    while (!pq.empty()) {\n      int u = pq.top().second;\n      double uw = pq.top().first;\n      pq.pop();\n\n      if (distances[u] < uw) {\n        continue;\n      };\n\n      for (auto edge : fromPaths[u]) {\n        int v = edge.to;\n        ll w = edge.cost;\n        if (distances[v] > distances[u] + w) {\n          distances[v] = distances[u] + w;\n          srcs[v] = u;\n          pq.push(mp(distances[v], v));\n        }\n      }\n    }\n  };\n  ll getDistance(ll n) { return distances[n]; }\n  ll getFrom(ll n) { return srcs[n]; }\n};\n\n// ベルマンフォード O(|V||E|)\n// 負コストが含まれていても最短経路問題を解くためのアルゴリズム。閉路の検出も可能\n// 有向グラフ\nclass BellmanFord {\nprivate:\n  Graph graph;\n  // 閉路が含まれるかは個々のノードごとに管理する必要あり\n  vector<bool> hasNegativeCycles;\n  vector<ll> distances;\n  vl srcs;\n\npublic:\n  BellmanFord(Graph graph) {\n    ll nodes = graph.nodes + 1;\n\n    this->graph = graph;\n    distances = vector<ll>(nodes, LL_INF);\n    hasNegativeCycles = vector<bool>(nodes, false);\n  }\n  void searchMinimumPathFrom(ll src) {\n    distances[src] = 0;\n\n    for (ll i = 0; i < graph.nodes - 1; i++) {\n      for (auto edge : graph.edges) {\n        ll u = edge.from;\n        ll v = edge.to;\n        ll w = edge.cost;\n        if (distances[u] != LL_INF) {\n          chmin(distances[v], distances[u] + w);\n        }\n      }\n    }\n\n    for (auto edge : graph.edges) {\n      ll u = edge.from;\n      ll v = edge.to;\n      ll w = edge.cost;\n      if (distances[u] == LL_INF) {\n        continue;\n      }\n      if (distances[u] + w < distances[v]) {\n        hasNegativeCycles[v] = true;\n      }\n    }\n\n    for (ll i = 0; i < graph.nodes; i++) {\n      for (auto edge : graph.edges) {\n        ll u = edge.from;\n        ll v = edge.to;\n        ll w = edge.cost;\n        if (distances[u] == LL_INF) {\n          continue;\n        }\n        chmin(distances[v], distances[u] + w);\n        if (hasNegativeCycles[u] == true) {\n          hasNegativeCycles[v] = true;\n        }\n      }\n    }\n  }\n  ll getDistance(ll n) { return distances[n]; }\n  bool hasNegativeCycle(ll n) { return hasNegativeCycles[n]; }\n  ll getFrom(ll n) { return srcs[n]; }\n};\n\n// O(V^3) 有向グラフ\nclass WarshallFloyd {\nprivate:\n  Graph graph;\n  int nodes = this->graph.nodes + 1;\n  vector<vector<ll>> distances;\n\npublic:\n  WarshallFloyd(Graph graph) {\n    this->graph = graph;\n    nodes = this->graph.nodes + 1;\n    this->distances = vector<vector<ll>>(nodes, vector<ll>(nodes, LL_INF));\n    for (auto edge : graph.edges) {\n      int from = edge.from;\n      int to = edge.to;\n      int cost = edge.cost;\n      distances[from][to] = cost;\n    }\n  }\n  void searchMinimumPath() {\n    for (int k = 0; k < nodes; k++) {\n      for (int i = 0; i < nodes; i++) {\n        for (int j = 0; j < nodes; j++) {\n          if (distances[i][k] == LL_INF || distances[k][j] == LL_INF) {\n            continue;\n          }\n          if (distances[i][k] + distances[k][j] < distances[i][j]) {\n            distances[i][j] = distances[i][k] + distances[k][j];\n          }\n        }\n      }\n    }\n  }\n  ll getDistance(int from, int to) { return distances[from][to]; }\n};\n\ntemplate <typename T> class SegmentTree {\n  int n = 1; // 最下段のノード数. ただし、2の冪乗\n  vector<T> data;\n\n  T init;                      // 初期値\n  function<T(T, T)> mergeFunc; // 子ノードのmerge方法\n\npublic:\n  SegmentTree(int N, function<T(T, T)> _mergeFunc, T _init) {\n    mergeFunc = _mergeFunc;\n    init = _init;\n\n    while (n < N) {\n      n *= 2;\n    }\n\n    data = vector<T>(n * 2 - 1, _init); // 2の冪乗で確保が必要\n  }\n\n  // i番目の値(0-indexed)をxに変更\n  // O(logN)\n  void update(int i, T v) {\n    // 葉のノード\n    i += n - 1;\n    data[i] = v;\n\n    // 親も更新\n    while (i > 0) {\n      i = (i - 1) / 2; //親のindex\n      data[i] =\n          mergeFunc(data[i * 2 + 1], data[i * 2 + 2]); //親から見た子のindex\n    }\n  }\n\n  // i番目の値を返却\n  T get(int i) { return data[i + n - 1]; }\n\n  // [a, b)のmergeFuncを求めるクエリ\n  // ノードk（空間[l, r)が担当）が答える. ノード0の根から探索する\n  // 呼び出しはquery(a, b). その他の引数は再帰処理のため\n  // O(logN)\n  T query(int a, int b, int k = 0, int l = 0, int r = -1) {\n    // 最初の呼び出し\n    if (r < 0) {\n      return query(a, b, k, l, n);\n    }\n\n    // 区間が被らない場合\n    if (r <= a || b <= l) {\n      return init;\n    }\n\n    // 完全に含む場合\n    if (a <= l && r <= b) {\n      return data[k];\n    }\n\n    // 部分的に含む場合. 子ノードに聞く\n    T left = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    T right = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\n    return mergeFunc(left, right);\n  }\n};\n\nvector<vi> nextStones(int H, int W, vector<vi> stones) {\n  // 石を移動\n  vector<vi> next_stones(H, vi(W, -1));\n  rep(j, 0, W) {\n    int i = H - 1;\n    int h = H - 1;\n    while (h >= 0) {\n      if (stones[h][j] != -1) {\n        next_stones[i][j] = stones[h][j];\n        i--;\n      }\n      h--;\n    }\n  }\n  return next_stones;\n}\n\nll calc(int H, int W, int K, vector<vi> stones) {\n  ll ans = 0;\n  int loop = 0;\n\n  while (true) {\n    bool changed = false;\n\n    // 消す\n    ll count = 0;\n    rrep(i, 0, H) {\n      int j = 0;\n      while (j < W) {\n        int jj = j;\n        int s = stones[i][j];\n        if (s == -1) {\n          j++;\n          continue;\n        }\n\n        while (j < W && stones[i][j] == s) {\n          j++;\n        }\n\n        if (j - jj >= K) {\n          changed = true;\n          count += s * (j - jj);\n          rep(k, jj, j) { stones[i][k] = -1; }\n        }\n      }\n    }\n    ans += pow(2, loop) * count;\n\n    if (!changed) {\n      return ans;\n    }\n\n    stones = nextStones(H, W, stones);\n    loop++;\n  }\n}\n\nint main() {\n  int H, W, K;\n  cin >> H >> W >> K;\n\n  vector<vi> carr(H, vi(W));\n  rep(i, 0, H) {\n    string str;\n    cin >> str;\n    rep(j, 0, W) { carr[i][j] = str[j] - '0'; }\n  }\n\n  ll ans = 0;\n  chmax(ans, calc(H, W, K, carr));\n\n  rep(i, 0, H) {\n    rep(j, 0, W) {\n      vector<vi> carrTmp = carr;\n      carrTmp[i][j] = -1;\n      chmax(ans, calc(H, W, K, nextStones(H, W, carrTmp)));\n    }\n  }\n\n  print(ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { std::cout << #a << \" = \" << a << \"\\n\"; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\ntemplate<class T, class V> istream& operator>> (istream& ist, pair<T, V>& p) { return ist >> p.first >> p.second; }\ntemplate<class T> ostream& operator<< (ostream& ost, pair<T, T>& p) { return ost << p.first << \", \" << p.second; }\ntemplate<class T> istream& operator>> (istream& ist, vector<T>& vs) { for(auto& e: vs) ist >> e; return ist; }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nusing Grid = vector<string>;\n\nint H, W, K;\nGrid v;\n\nGrid remove_cell(Grid const& in, int y, int x) {\n  auto result = in;\n  result[y][x] = '-';\n  return result;\n}\n\nGrid drop(Grid const& in) {\n  vector<stack<char>> stks(W);\n  rep(i, H) rep(j, W) {\n    if (in[i][j] != '-') {\n      stks[j].push(in[i][j]);\n    }\n  }\n\n  Grid result(H);\n  rep(i, H) result[i].resize(W, '-');\n  rep(j, W) rep(i, H) {\n    if (!stks[j].empty()) {\n      auto cell = stks[j].top();\n      stks[j].pop();\n      result[H - i - 1][j] = cell;      \n    } else {\n      result[H - i - 1][j] = '-';\n    }\n  }\n  return result;\n}\n\nstring remove_right_forward_in_line(string const& in, int sj) {\n  auto work = in;\n  const auto rmchar = in[sj];\n  REP(j, sj, W) {\n    if (work[j] != rmchar) { break; }\n    work[j] = '-';\n  }\n  return work;\n}\n\nGrid remove_connected_cells(Grid const& in) {\n  auto work = in;\n  rep(i, H) rep(j, W - K + 1) {\n    if (work[i][j] == '-') { continue; }\n    auto s = work[i].substr(j, K);\n    s.erase(std::unique(s.begin(), s.end()), s.end());\n    if (s.size() == 1) {\n      work[i] = remove_right_forward_in_line(work[i], j);\n    }\n  }\n  return work;\n}\n\nint calc_sum(Grid const& in) {\n  int sum = 0;\n  rep(i, H) rep(j, W) {\n    sum += in[i][j] == '-' ? 0 : (in[i][j] - '0');\n  }\n  return sum;\n}\n\nint solve(Grid work) {\n  int score = 0;\n  for (int pexp = 0; ; pexp++) {\n    auto next_work = drop(remove_connected_cells(work));\n    auto diff = calc_sum(work) - calc_sum(next_work);\n    if (diff == 0) { break; }\n    score += (1 << pexp) * diff;\n    work = next_work;\n  }\n  return score;\n}\n\nint solve() {\n  int max_score = 0;\n  rep(i, H) rep(j, W) {\n    maximize(max_score, solve(drop(remove_cell(v, i, j))));\n  }\n  return max_score;\n}\n\nint main() {\n  cin >> H >> W >> K;\n  v.resize(H); cin >> v;\n  cout << solve() << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define all(v) v.begin(),v.end()\n#define _GLIBCXX_DEBUG\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vd = vector<double>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\nusing vvd = vector<vd>;\nusing vvvi = vector<vvi>;\nusing vvvll = vector<vvll>;\nusing vvvd = vector<vvd>;\n\nconst double pi=acos(-1);\nconst ll MOD=1e9+7;\n\nint h,w,k;\n\nll solve(int x,vvi &v){\n    //v中の0を敷き詰める\n    for (int i=0;i<w;i++){\n        int b1=1;\n        while(b1){\n            b1=0;\n            for (int j=h-1;j>0;j--){\n                if (v[j][i]==0 && v[j-1][i]!=0){\n                    b1=1;\n                    v[j][i]=v[j-1][i];\n                    v[j-1][i]=0;\n                }\n            }\n        }\n    }\n    //敷き詰めた後\n    ll res=0;\n    int b=0;\n    for (int i=0;i<h;i++){\n        vector<pair<int,int>> vp;\n        int now=-1;\n        int index=-1;\n        int c=-1;\n        for (int j=0;j<w+1;j++){\n            if (now==v[i][j]){\n                c+=1;\n            }\n            else{\n                if (c>=k){\n                    vp.push_back(make_pair(index,j-1));\n                    b=1;\n                }\n                if (v[i][j]==0){\n                    c=0;\n                    now=-1;\n                }\n                else{\n                    c=1;\n                    now=v[i][j];\n                    index=j;\n                }\n            }\n        }\n        for (auto p:vp){\n            int num1=p.first,num2=p.second;\n            res+=(1<<x)*(num2-num1+1)*v[i][num1];\n            for (int j=num1;j<num2+1;j++){\n                v[i][j]=0;\n            }\n        }\n    }\n    if (b){\n        return res+solve(x+1,v);\n    }\n    else{\n        return res;\n    }\n\n}\n\nint main() {\n    cin>>h>>w>>k;\n    vvi graph(h,vi(w+1,0));\n    rep(i,h){\n        rep(j,w){\n            char s;\n            cin>>s;\n            graph[i][j]=s-'0';\n        }\n        graph[i][w]=10000;\n    }\n    ll ans=0;\n    for (int i=1;i<h;i++){\n        for (int j=0;j<w;j++){\n            auto g1=graph;\n            g1[i][j]=0;\n            ll ans1=solve(0,g1);\n            ans=max(ans,ans1);\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//=====================================================\n// マクロ定義部\n//=====================================================\n\n#define FOR(i,a,b) for(ll i = (a); i < (b); ++i)\n#define FOR_EQ(i,a,b) for(ll i = (a); i <= (b); ++i)\n#define rep(i,n) FOR(i,0,n)\n#define rep_eq(i,n) FOR_EQ(i,0,n)\n#define DEBUG_VARIABLE(variable) cout << #variable << \":\" << variable << endl\n#define INFTY 1000000000000\n#define WHITE 1//（未訪問）\n#define GRAY 2//（訪問）未だに訪問していない頂点への辺を持っている。スタックに退避。\n#define BLACK 3//（訪問完了）未訪問への頂点への辺を持たない\n//=====================================================\n// 型定義部\n//=====================================================\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<ll, ll>    ll_ll;\ntypedef vector<ll> Vector;\ntypedef vector<Vector> DVector;\ntypedef vector< pair<ll, ll> > Vec_Pair;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n//===================================================\n// 関数のプロトタイプ宣言・関数に必要な配列の宣言\n//===================================================\n\ntemplate <class X> void printArray(X *array, ll);\ntemplate <class X> void printVector(vector<X> &v);\ntemplate <class X> void printDimention(vector< vector<X> > &dv);\ntemplate <class X> void printMap(X);\ntemplate <class X> void printVecPair(vector<X> &v);\nvoid printDV_Pair(vector<vector<pair<ll, ll> > > &v);\nvoid printSet(set<ll> &S);\n// 繰返し自乗法\nll RepeatSquaring(ll a, ll index);\n// 最大公約数\nll GCD(ll, ll);\n// 最小公倍数\nll LCM(ll, ll);\n// 割り算した時に余りが有る時だけ、+1の商を返す。\nll div_one(ll res, ll div);\n\n//===================================================\n// グローバル\n//===================================================\n\nconst int MOD = 1000000007;\n//1個上から時計周り\nconst int ddx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[8] = {1, 1, 0, -1, -1, -1, 0, 1};\n//上右下左\nconst int dx[4] = {0, 1, 0, -1};    // dj\nconst int dy[4] = {-1, 0, 1, 0};    // di\nstatic const int NIL = -1;\n\nll n, N, k, V, E;\nll H, W, K;\n//===================================================\n// 関数\n//===================================================\nbool check_crush(DVector &dv){\n    rep(i, H){\n        FOR(j, 1, W){\n            if(dv[i][j] == K - 1){  // もうクラッシュできるところがない\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nDVector pre_crush(DVector &dv){\n\n    DVector res(H, Vector(W, 0));\n    // 上から見ていって壊せるところはtrue\n    rep(i, H){\n        FOR(j, 1, W){\n            if(dv[i][j] == dv[i][j - 1] && dv[i][j] != 0){  // まだブロックがあるとこで連続な場所を見つける\n                res[i][j] = res[i][j - 1] + 1;\n            }\n        }\n    }\n    return res;\n}\n\n\nvoid crush(DVector &dv, DVector cmap, ll &score, ll time){\n    \n    // crush and add score\n    rep(i, H){\n        bool flg = false;\n        for(int j = W - 1; j >= 0; j--){  // 逆順に見る\n            if(cmap[i][j] >= K - 1 && flg == false){    // K 連続してたらスイッチON\n                score += (cmap[i][j] + 1) * dv[i][j] * pow(2, time);\n                flg = true;\n            }\n\n            // crush\n            if(flg){\n                dv[i][j] = 0;\n            }\n\n            if(flg == true && cmap[i][j] == 0){ // 連続してた部分が終わったのでスイッチOFF\n                flg = false;\n            }\n        }\n    }\n\n    // move 下に詰める\n    for(int i = H - 1; i >= 1 ;i--){    // 一番した以外の行\n        rep(j, W){\n            if(dv[i][j] == 0){\n                ll u = 0;\n                while(!dv[i - u][j]){   // 落ちてくるブロックが0以外になるまで\n                    u++;\n                    if(i - u == 0)  break;  // 一番上のブロックも0\n                }\n                dv[i][j] = dv[i - u][j];    // 落下\n                dv[i - u][j] = 0;   // 落下してきたブロックがあった場所を0\n            }\n        }\n    }\n}\n\nvoid init_move(DVector &dv, ll h, ll w){\n    dv[h][w] = 0;\n    for(int i = h; i >= 1 ;i--){    // 一番した以外の行\n        ll u = 0;\n        while(!dv[i - u][w]){   // 落ちてくるブロックが0以外になるまで\n            u++;\n            if(i - u == 0)  break;  // 一番上のブロックも0\n        }\n        dv[i][w] = dv[i - u][w];    // 落下\n        dv[i - u][w] = 0;   // 落下してきたブロックがあった場所を0\n    }\n}\n\nll solve(ll h, ll w, DVector board){\n\n    ll score = 0, time = 0;\n    \n    init_move(board, h, w);\n    // printDimention(board);\n    while (1)\n    {\n        DVector crush_map = pre_crush(board);\n        // printDimention(crush_map);\n        if(!check_crush(crush_map))  break;\n        crush(board, crush_map, score, time);\n        // printDimention(board);\n        time++;\n    }\n    \n    return score;\n}\n\n//===================================================\n// main 問題処理部\n//===================================================\nint main(int argc, char const *argv[])\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> H >> W >> K;\n    DVector board(H, Vector(W, 0));\n    vector<string>  S(H);\n\n    rep(i, H){\n        cin >> S[i];\n        rep(j, W){\n            board[i][j] = S[i][j] - '0';\n        }\n    }\n    ll score = 0, tmp;\n    rep(i, H){\n        rep(j, W){\n            tmp = solve(i, j, board);    // 一番下のブロックを一つ消す\n            score = max(score, tmp);\n        }\n    }\n    \n    cout << score << endl;\n\n    return 0;\n}\n\n//=====================================================\n// 関数群\n//=====================================================\n\ntemplate<class X> void printArray(X array[], ll n){\n    rep(i, n){\n        if(i)   cout << \" \";\n        cout << array[i];\n    }\n    cout << endl;\n}\n\ntemplate<class X> void printVector(vector<X> &v){\n    rep(i, (int)v.size()){\n        if(i)   cout << \" \";\n        cout << v[i];\n    }\n    cout << endl;\n}\n\n//二次元配列の表示\ntemplate<class X> void printDimention(vector< vector<X> > &dv){\n    rep(i, (ll)dv.size()){\n        rep(j, (ll)dv[i].size()){\n            if(j)   cout << \" \";\n            cout << dv[i][j];\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\n//mapの表示\ntemplate <class X> void printMap(X mp) {\n    for (auto it : mp) {\n        cout << it.first << \" \" << it.second << endl;\n    }\n}\n\n// 内部にpairを内包したvectorの表示\ntemplate <class X> void printVecPair(vector<X> &v){\n    rep(i, (int)v.size()){\n        cout << v[i].first << \" \" << v[i].second << endl;\n    }\n    cout << endl;\n}\n\n// 内部にVec_Pairを内包したvectorの表示\nvoid printDV_Pair(vector<vector<pair<ll, ll> > > &v){\n    rep(i, (int)v.size()){\n        cout << i << endl;\n        rep(j, (int)v[i].size()){\n            cout << v[i][j].first << \" \" << v[i][j].second << endl;\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\nvoid printSet(set<ll> &S){\n    for(set<ll>::iterator it = S.begin(); it != S.end(); it++){\n        if(it != --S.end() ) cout << *it << \" \";\n        else    cout << *it << endl;\n    }\n}\n\nll RepeatSquaring(ll a, ll index){\n    if(index == 0)  return  1;\n    else if(index % 2 == 0){\n        ll tmp = RepeatSquaring(a, index / 2);\n        return tmp * tmp;\n    }else{\n        return a * RepeatSquaring(a, index - 1);\n    }\n}\n\n//最大公約数(Greatest Common Divisor)\n// ユークリッドの互除法使用\nll GCD (ll a, ll b){\n    return b ?  GCD(b, a % b) : a;\n}\n\n//最小公倍数(Least Common Multiple)\nll LCM(ll m, ll n){\n    //引数に0がある場合は0を返す\n    if(m == 0 || n == 0)    return 0;\n\n    //lcm = m * n / gcd(m, n)\n    return ((m / GCD(m, n)) * n);\n}\n\n// 割り算した時に余りが有る時だけ、+1の商を返す。\nll div_one(ll res, ll div){\n    // res 割られる数、div 割る数\n    return (res + div - 1)/div;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(i=0;i<n;i++)\n#define ll long long\n#define all(v) v.begin(), v.end()\nint main(){\n  int h,w,k;cin>>h>>w>>k;vector<vector<int>> c(h,vector<int>(w));\n  int i,j,l,n,p;\n  rep(i,h)rep(j,w){\n    char ch;cin>>ch;\n    c[i][j]=(ch-'0');\n  }\n  int ans=0;\n  rep(i,h)rep(j,w){\n    bool update=1;vector<vector<int>> m=c;\n    m[i][j]=0;int score=0,timev=1;\n    while(update) {\n      update=0;\n      rep(n,w){\n        int to=h-1;\n        for(l=h-1;l>=0;l--){\n          if(m[l][n]!=0){\n            swap(m[to][n],m[l][n]);to--;\n          }\n        }\n      }\n      int get=0;\n      rep(l,h){\n        int from=0,now=m[l][w-1];\n        rep(n,w){\n          if(now!=m[l][n]){\n            int dis=(n-1)-from+1;\n            if(dis>=k){\n              for(p=from;p<n;p++) {\n                get+=m[l][p];m[l][p]=0;\n              }\n            }from=n;now=m[l][n];\n          }\n        }\n        int dis=(w-1)-from+1;\n        if(dis>=k){\n          for(p=from;p<n;p++){\n            get+=m[l][p];m[l][p]=0;\n          }\n        }\n      }\n      if(get>0)update=1;\n      else break;\n      score+=timev*get; timev*=2;\n    }ans=max(ans,score);\n  }cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <list>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\nint h, w, k;\n\nbool drop(std::vector<std::vector<char>>& c) {\n\tbool res = false;\n\tREP(j, w) {\n\t\tint top = h;\n\t\tRREP(i, h) {\n\t\t\tif (c[i][j] == '0') {\n\t\t\t\tif (top == h) top = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (top < h) {\n\t\t\t\t\tstd::swap(c[i][j], c[top--][j]);\n\t\t\t\t\tres = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint cascade(std::vector<std::vector<char>>& c) {\n\tint res = 0;\n\tREP(i, h) {\n\t\tint l = -1;\n\t\tchar now = '0';\n\t\tREP(r, w + 1) {\n\t\t\tif (now != '0') {\n\t\t\t\tif (r == w || now != c[i][r]) {\n\t\t\t\t\tif (r - l >= k) {\n\t\t\t\t\t\tres += (now - '0') * (r - l);\n\t\t\t\t\t\tFOR(j, l, r) c[i][j] = '0';\n\t\t\t\t\t}\n\t\t\t\t\tnow = (r == w) ? '0' : c[i][r];\n\t\t\t\t\tl = r;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (r < w && c[i][r] != '0') {\n\t\t\t\t\tnow = c[i][r];\n\t\t\t\t\tl = r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint calc(std::vector<std::vector<char>> c) {\n\tint res = 0, turn = 0;\n\twhile (drop(c)) {\n\t\tres += cascade(c) << turn;\n\t\t++turn;\n\t}\n\treturn res;\n}\n\nsigned main() {\n\tINIT;\n\n\tstd::cin >> h >> w >> k;\n\tMAT(char, c, h, w);\n\n\tint ans = 0;\n\tFOR(i, 1, h) REP(j, w) {\n\t\tchar cc = '0';\n\t\tstd::swap(cc, c[i][j]);\n\t\tCHMAX(ans, calc(c));\n\t\tstd::swap(cc, c[i][j]);\n\t}\n\tOUT(ans)BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <map> \n#include <set>\n#include <string>\n#include <functional>\n#include <list>\n#include <random>\n#include <time.h>\n#include <iomanip>\n#include <assert.h>\n#include <numeric>\n#include <new>\n#include <sstream>\n#include <complex>\n#define BIT(nr) (1ULL << (nr))\n#define int long long\n#define ll long long\n#define double long double\n#define mod 1000000007\n#define MAXN (int)1e+5 * 2+1\n#define LL_MAX 9223372036854775807\t\n#define LL_HALFMAX 9223372036854775807 / 2\t\n#define MIN -(9223372036854775807 / 2)\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define FOR(it,c) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define ALLOF(c) (c).begin(), (c).end()\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define mp make_pair\ntemplate<typename T1, typename T2> inline void chmin(T1& a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1& a, T2 b) { if (a < b) a = b; }\n\nusing namespace std;\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint src, dst;\n\n\t// libalgo のものに追加、メンバを追加するだけなので互換性は崩さないはず、逆辺のG[e.dstの]インデックスを保持\n\tint rev;\n\tWeight weight;\n\tFlow cap;\n\tEdge() : src(0), dst(0), weight(0) {}\n\tEdge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n\tbool operator<(const Edge& right) const {\n\t\treturn dst < right.dst;\n\t}\n};\n\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nvoid add_edge(Graph& g, int a, int b, Weight w = 1) {\n\tg[a].emplace_back(a, b, w);\n\tg[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph& g, int a, int b, Weight w = 1) { g[a].emplace_back(a, b, w); }\n\nint dx[4] = { 0, 1, 0, -1 }; // x軸方向への変位\nint dy[4] = { 1, 0, -1, 0 }; // y軸方向への変位\n\n\nclass Vector3D {\npublic:\n\tdouble x, y, z;\n\tVector3D(double x, double y, double z) {\n\t\tthis->x = x;\n\t\tthis->y = y;\n\t\tthis->z = z;\n\t}\n\n\tVector3D operator- (Vector3D right) {\n\t\treturn Vector3D(right.x - x, right.y - y, right.z - z);\n\t}\n\n\tdouble Length() {\n\t\treturn sqrtl(x * x + y * y + z * z);\n\t}\n};\n\n\n#ifdef DEBUG\ntemplate <class T>ostream& operator<<(ostream& o, const vector<T>& v)\n{\n\to << \"{\"; for (int i = 0; i < (int)v.size(); i++)o << (i > 0 ? \", \" : \"\") << v[i]; o << \"}\"; return o;\n}\n#endif // DEBUG\n\ntemplate <class T>ostream& operator<<(ostream& o, const vector<T>& v)\n{\n\tfor (int i = 0; i < (int)v.size(); i++)o << (i > 0 ? \" \" : \"\") << v[i]; return o;\n}\n\ntemplate< class T >\nclass CumulativeSum2D {\nprivate:\n\t// 元データ\n\tvector<vector<T>> m_Data;\n\tint m_Height;\n\tint m_Width;\n\t// 累積和\n\tvector<vector<T>> m_Cum;\n\npublic:\n\tCumulativeSum2D(int H, int W) :\n\t\tm_Cum(H+1, vector<int>(W+1, 0)), \n\t\tm_Height(H),\n\t\tm_Width(W)\n\t{}\n\n\t// TORIAEZU: コピー\n\tCumulativeSum2D(vector<vector<T>> inputData) :\n\t\tm_Data(inputData),\n\t\tm_Height(static_cast<int>(inputData.size())),\n\t\tm_Width(static_cast<int>(inputData[0].size())),\n\t\tm_Cum(m_Height + 1, vector<int>(m_Width + 1, 0))\n\t{\n\t}\n\n\t// 0-indexed\n\tvoid Change(int x, int y, T val) {\n\t\tassert(x < m_Width);\n\t\tassert(y < m_Height);\n\n\t\tm_Data[y][x] = val;\n\t}\n\n\tvoid Build() {\n\t\tfor (int i = 0; i < m_Height; i++) {\n\t\t\tfor (int j = 0; j < m_Width; j++) {\n\t\t\t\tm_Cum[i + 1][j + 1] = m_Cum[i][j + 1] + m_Cum[i + 1][j] - m_Cum[i][j] + m_Data[i][j];\n\t\t\t}\n\t\t}\n\t}\n\n\t// [sx, gx), [sy, gy) の範囲の和を取得\n\tT Query(int sx, int sy, int gx, int gy) {\n\t\treturn m_Cum[gy][gx] - m_Cum[sy][gx] - m_Cum[gy][sx] + m_Cum[sy][sx];\n\t}\n};\n\n\n// ランレングス圧縮\ntemplate<typename T>\nvector<pair<T, int>> RunLength(vector<T> arr) {\n\tT now = arr[0];\n\tint len = arr.size();\n\n\tvector<pair<T, int>> res;\n\tint cnt = 0;\n\trep(i, len) {\n\t\tif (arr[i] != now) {\n\t\t\tres.emplace_back(now, cnt);\n\t\t\tnow = arr[i];\n\t\t\tcnt = 0;\n\t\t}\n\t\tcnt++;\n\t}\n\n\tres.push_back(mp(now, cnt));\n\treturn res;\n}\n\nclass Circle {\npublic:\n\tint x, y, r;\n\tCircle(int x, int y, int r) {\n\t\tthis->x = x;\n\t\tthis->y = y;\n\t\tthis->r = r;\n\t}\n\n};\n\nvoid print(vector<vector<int>> v) {\n\tfor (auto ve : v) {\n\t\tcout << ve << \"\\n\";\n\t}\n\tcout << \"\\n\";\n}\n\nint pow2(int N) {\n\tint ret = 1;\n\trep(i, N) {\n\t\tret *= 2;\n\t}\n\treturn ret;\n}\n\nbool solve() {\n\tint H, W, K;\n\tcin >> H >> W >> K;\n\tif (H == 0) {\n\t\treturn false;\n\t}\n\tW++;\n\tvector<vector<int>> Board(H, vector<int>(W, -2));\n\n\trep(y, H) {\n\t\trep(x, W-1) {\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tBoard[y][x] = (int)c - '0';\n\t\t}\n\t}\n\tauto calc = [=](int dy, int dx, vector<vector<int>> B) {\n\t\tint ret = 0;\n\t\tint procCnt = 0;\n\t\tB[dy][dx] = -1;\n\n\t\twhile (1) {\n\t\t\tint score = 0;\n\t\t\t// おとす\n\t\t\tfunction<void(int, int)> rec = [&](int y, int x) {\n\t\t\t\tif (y == H - 1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (B[y][x] < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (B[y + 1][x] == -1) {\n\t\t\t\t\tswap(B[y][x], B[y + 1][x]);\n\t\t\t\t\trec(y + 1, x);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tRREP(y, H) {\n\t\t\t\trep(x, W) {\n\t\t\t\t\trec(y, x);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//print(B);\n\t\t\t// みつける\n\t\t\tbool found = false;\n\t\t\trep(y, H) {\n\t\t\t\tint s = 0;\n\t\t\t\tint cnt = 0;\n\t\t\t\tint now = B[y][0];\n\t\t\t\trep(x, W) {\n\t\t\t\t\tif (B[y][x] == -1) {\n\t\t\t\t\t\tif (cnt >= K) {\n\t\t\t\t\t\t\tREP(i, s, x) {\n\t\t\t\t\t\t\t\tscore += B[y][i];\n\t\t\t\t\t\t\t\tB[y][i] = -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts = x;\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t\tnow = B[y][x];\n\t\t\t\t\t}\n\t\t\t\t\telse if (now == B[y][x]) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t\telse if (cnt >= K) {\n\t\t\t\t\t\tREP(i, s, x) {\n\t\t\t\t\t\t\tscore += B[y][i];\n\t\t\t\t\t\t\tB[y][i] = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts = x;\n\t\t\t\t\t\tcnt = 1;\n\t\t\t\t\t\tnow = B[y][x];\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ts = x;\n\t\t\t\t\t\tcnt = 1;\n\t\t\t\t\t\tnow = B[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// 番兵 おくので終わった後に追加発見処理はいらない\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tscore *= pow2(procCnt);\n\t\t\tprocCnt++;\n\t\t\tret += score;\n\t\t}\n\t\treturn ret;\n\t};\n\n\tint ans = -1;\n\trep(y, H) {\n\t\trep(x, W-1) {\n\t\t\tint cand = calc(y, x, Board);\n\t\t\tchmax(ans, cand);\n\t\t}\n\t}\n\n\tcout << ans << \"\\n\";\n\treturn true;\n}\n\nsigned main() {\n\t\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n\nint H, W, K;\n\nvoid fall(vector<vector<int>> &c) {\n    rep(i,W) rep(j,H) {\n        if (c[i][j] == 0) {\n            for (int k = 1; k + j < H; ++k) {\n                if (c[i][k+j] != 0) {\n                    for (int l = j; l < H; ++l) {\n                        if (l + k < H) c[i][l] = c[i][l+k];\n                        else c[i][l] = 0;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n}\n\nvoid sum(ll &ans, ll delete_cnt, vector<vector<int>> &c) {\n    rep(i,H) {\n        ll left = 0;\n        rep(j,W) {\n            if (c[j+1][i] != 0 && c[j+1][i] == c[j][i]) continue;\n            if (c[j+1][i] != c[j][i]) {\n                if (j - left + 1 > 1) {\n                    ans += pow(2LL, delete_cnt) * (j - left + 1) * c[j][i];\n                    for (int k = left; k <= j; ++k) c[k][i] = 0;\n                }\n            }\n            left = j + 1;\n        }\n    }\n}\n\n\n\nll calc_ans(int x, int y, vector<vector<int>> c) {\n    ll res = 0;\n    ll pre_ans = -1;\n    ll delete_cnt = 0;\n\n    c[x][y] = 0;\n    fall(c);\n    while (res != pre_ans) {\n        pre_ans = res;\n        sum(res, delete_cnt, c);\n        fall(c);\n        ++delete_cnt;\n    }\n    return res;\n}\n\n\nint main() {\n    cin >> H >> W >> K;\n    vector<vector<int>> c(W+1, vector<int>(H));\n    rep(i,H) {\n        string S;\n        cin >> S;\n        rep(j,W) c[j][H-1-i] = S[j] - '0';\n    }\n\n    ll ans = 0;\n\n    rep(i,W) rep(j,H) {\n        if (i == 0) continue;\n        ans = max(ans, calc_ans(i, j, c));\n    }\n    \n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n    int h, w, want;\n    cin >> h >> w >> want;\n\n    vector<vector<int>> raw_ban(h, vector<int>(w));\n    for (int i = 0; i < h; i++) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < w; j++) {\n            raw_ban[i][j] = s[j] - '0';\n        }\n    }\n\n    ll ret = 0;\n    for (int remove_x = 0; remove_x < h; remove_x++) {\n        for (int remove_y = 0; remove_y < w; remove_y++) {\n            ll now = 0;\n            auto ban = raw_ban;\n            ban[remove_x][remove_y] = -1;\n            int times = 0;\n            while (true) {\n                for (int i = 0; i < w; i++) {\n                    vector<int> v;\n                    for (int j = h - 1; j >= 0; j--) if (ban[j][i] > 0)v.push_back(ban[j][i]);\n\n                    for (int j = 0; j < h; j++) {\n                        if (j < v.size())ban[h - 1 - j][i] = v[j];\n                        else ban[h - 1 - j][i] = -1;\n                    }\n                }\n\n                bool found = false;\n\n                for (int i = 0; i < h; i++) {\n                    for (int j = 0; j < w; j++) {\n                        int x = ban[i][j];\n                        if (x < 0)continue;\n                        for (int k = w; k >= j + want; k--) {\n                            bool same = true;\n                            for (int l = j; l < k; l++)\n                                if (ban[i][l] != x || ban[i][l] < 0)same = false;\n\n                            if (same) {\n                                found = true;\n                                now += x * (k - j) << times;\n                                for (int l = j; l < k; l++)ban[i][l] = -1;\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (!found)break;\n                times++;\n            }\n            ret = max(ret, now);\n        }\n    }\n\n    cout << ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n#include <chrono>\n#include <random>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nint H, W, K;\nVVI c;\n\nvoid out(const VVI &vv) {\n    FORE(v, vv) {\n        FORE(e, v) cout << e;\n        cout << endl;\n    }\n}\n\nbool check(const VVI &vv) {\n    int now = -1, cnt = -1;\n    REP(i, H) {\n        now = 0; cnt = 1;\n        REP(j, W) {\n            if (vv[i][j] == 0 || vv[i][j] != now) {\n                if (cnt >= K) return true;\n                now = (vv[i][j]) ? vv[i][j] : -1;\n                cnt = 1;\n            } else {\n                cnt++;\n            }\n        }\n    }\n    return false;\n}\n\nvoid padding(VVI &vv) {\n    REP(j, W) {\n        int nxt = H - 1;\n        RREP(i, H) {\n            if (vv[i][j]) {\n                vv[nxt][j] = vv[i][j];\n                nxt--;\n            }\n        }\n        REP(i, nxt + 1) {\n            vv[i][j] = 0;\n        }\n    }\n}\n\nLL del(VVI &vv) {\n    LL res = 0;\n    REP(i, H) {\n        int now = 0, cnt = 1;\n        REP(j, W) {\n            if (vv[i][j] == 0 || vv[i][j] != now) {\n                if (j && vv[i][j - 1] > 0 && cnt >= K) {\n                    res += cnt * now;\n                    for (int k = j - 1; cnt; cnt--, k--) {\n                        vv[i][k] = 0;\n                    }\n                }\n                now = vv[i][j] > 0 ? vv[i][j] : -1;\n                cnt = 1;\n            } else {\n                cnt++;\n            }\n        }\n    }\n    padding(vv);\n    return res;\n}\n\nLL func(VVI vv, int ii, int jj) {\n    LL res = del(c);\n    LL num = res ? 2 : 1;\n    vv[ii][jj] = 0;\n    padding(vv);\n    while (check(vv)) {\n        res += del(vv) * num;\n        num <<= 1;\n    }\n    //cout << ii << \" \"  << jj << \" \" << res << endl;\n    return res;\n}\n\nint main(void) {\n    scanf(\"%d%d%d\", &H, &W, &K);\n    c.resize(H, VI(++W));\n    REP(i, H) {\n        string s; cin >> s;\n        REP(j, W) c[i][j] = s[j] - '0';\n        c[i][W - 1] = -INF;\n    }\n    if (K > W) {\n        cout << 0 << endl;\n        return 0;\n    }\n    LL ans = 0;\n    REP(i, H)REP(j, W) {\n        ans = max(ans, func(c, i, j));\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n#include <stack>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(ll i = 0; i < n; i++)\n\n\n\n\n\nint main() {\n    ll h, w, k;\n    cin >> h >> w >> k;\n    vector<vector<ll>> c(h, vector<ll>(w));\n    REP(i, h){\n        string s;\n        cin >> s;\n        REP(j, w){\n            c[i][j] = s[j] - '0';\n        }\n    }\n    \n    ll ans = 0;\n    REP(i, h){REP(j, w){\n        vector<vector<ll>> v = c;\n        v[i][j] = 0;\n        for(ll l = i - 1; l >= 0; l--){\n            v[l + 1][j] = v[l][j];\n            v[l][j] = 0;\n        }\n        \n        bool deleted = true;\n        ll sum = 0;\n        for(ll r = 1; deleted; r *= 2){\n            deleted = false;\n            ll s = 0;\n            for(ll l = 0; l < h; l++){\n                for(ll m = 0; m <= w - k; m++){\n                    if(v[l][m] == 0) continue;\n                    ll n;\n                    for(n = m + 1; n < w; n++){\n                        if(v[l][m] != v[l][n]){\n                            break;\n                        }\n                    }\n                    if(n - m >= k){\n                        ll t = v[l][m];\n                        for(ll o = m; o < n; o++){\n                            v[l][o] = 0;\n                            s += t;\n                        }\n                        deleted = true;\n                    }\n                }\n            }\n            s *= r;\n            sum += s;\n            \n            for(ll l = h - 1; l > 0; l--){\n                for(ll m = 0; m < w; m++){\n                    if(v[l][m] == 0){\n                        ll n;\n                        for(n = l - 1; n >= 0; n--){\n                            if(v[n][m] != 0){\n                                break;\n                            }\n                        }\n                        if(n >= 0){\n                            v[l][m] = v[n][m];\n                            v[n][m] = 0;\n                        }\n                    }\n                }\n            }\n        }\n        \n        ans = max(ans, sum);\n    }}\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst ll MOD = 1'000'000'007;\nconst ld PI = acos(-1);  \nconst ld EPS = 0.0000000001;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define REP(i, n) for(ll i=0; i<(ll)(n); i++)\n#define REPD(i, n) for(ll i=n-1; 0<=i; i--)\n#define FOR(i, a, b) for(ll i=a; i<(ll)(b); i++)\n#define FORD(i, a, b) for(ll i=a; (ll)(b)<=i; i--)\n#define ALL(x) x.begin(), x.end()\n#define MAX(x) *max_element(ALL(x))\n#define MIN(x) *min_element(ALL(x))\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint main(){\n    ll h, w, k;  cin >> h >> w >> k;\n    vector<vector<ll>> ori(h, vector<ll>(w));\n    REP(i, h) REP(j, w){\n        char c; cin >> c;\n        ori[i][j] = c-'0';\n    }\n    \n    ll res=0;\n    REP(x, h){\n        REP(y, w){\n            ll tmp=0, times=0;\n            bool flag=true;\n            vector<vector<ll>> g = ori;\n            g[x][y] = 0;\n            while(flag){\n                flag = false;\n                REP(i, h){\n                    ll bef=g[i][0], cnt=0, st=0, index=w;\n                    \n                    REP(j, w){\n                        if(g[i][j]==bef && 0<bef) cnt += 1;\n                        else{\n                            if(cnt<k){\n                                if(0<g[i][j]){\n                                    cnt = 1; st=j;\n                                }\n                            }else{\n                                if(bef)index = j;\n                                break;\n                            }\n                        }\n                        bef = g[i][j];\n                    }\n                    if(k<=cnt){\n                        tmp += (1<<times)*cnt*bef;\n                        FOR(j, st, index) g[i][j] = 0;\n                        flag = true;\n                    }\n                }\n                REPD(i, h){\n                    REP(j, w){\n                        if(!g[i][j]){\n                            REPD(k, i){\n                                if(!g[k][j]) continue;\n                                swap(g[k][j], g[i][j]); break;\n                            }\n                        }\n                    }\n                }\n                REP(i, h){\n                    ll bef=g[i][0], cnt=0, st=0, index=w;\n                    \n                    REP(j, w){\n                        if(g[i][j]==bef && 0<bef) cnt += 1;\n                        else{\n                            if(cnt<k){\n                                if(0<g[i][j]){\n                                    cnt = 1; st=j;\n                                }\n                            }else{\n                                if(bef)index = j;\n                                break;\n                            }\n                        }\n                        bef = g[i][j];\n                    }\n                    if(k<=cnt){\n                        tmp += (1<<times)*cnt*bef;\n                        FOR(j, st, index) g[i][j] = 0;\n                        flag = true;\n                    }\n                }\n                if(0<tmp)   times += 1;\n            }\n            res = max(res, tmp);\n            //cout << x <<':' << y << ' ' << tmp << endl << endl;\n        }\n    }\n    cout << res << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\ntypedef long long lint;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef unsigned long long ulint;\n#define endl '\\n'\n#define fst first\n#define sed second\n#define pb push_back\n#define mp make_pair\n#define rint register int\n#define newline putchar('\\n')\n#define leave_space putchar(' ')\n#define all(x) (x).begin(), (x).end()\n#define reveal(x) cerr << #x << \" = \" << (x) << endl\n#define rep(it, f, e) for (rint it = (f); it <= (e); ++it)\n#define per(it, f, e) for (rint it = (f); it >= (e); --it)\nconst int MAXN = 32;\nint n, m, k;\nchar maze[MAXN][MAXN];\nint use[MAXN][MAXN], cpy[MAXN][MAXN];\ninline void falldown(int x, int y) {\n\twhile (x && use[x - 1][y]) {\n\t\tswap(use[x][y], use[x - 1][y]); --x;\n\t}\n}\ninline lint dfs() {\n\tlint ret = 0;\n\trep (i, 1, n) {\n\t\tint las = 0;\n\t\tvector<int> FD;\n\t\trep (j, 1, m) {\n\t\t\tif (!use[i][j]) las = 0;\n\t\t\telse if (use[i][j] == use[i][j - 1]) ++las;\n\t\t\telse las = 1;\n\t\t\tif (las >= k) {\n\t\t\t\tret += use[i][j];\n\t\t\t\tif (las == k) {\n\t\t\t\t\tret += use[i][j] * (k - 1);\n\t\t\t\t\trep (K, j - k + 1, j) {\n\t\t\t\t\t\tFD.pb(K);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tFD.pb(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto p : FD) {\n\t\t\tuse[i][p] = 0;\n\t\t\tfalldown(i, p);\n\t\t}\n\t}\n\tif (ret) ret += dfs() * 2;\n\treturn ret;\n}\nint main() {\n\tcin >> n >> m >> k;\n\trep (i, 1, n) {\n\t\tcin >> (maze[i] + 1);\n\t\trep (j, 1, m) {\n\t\t\tcpy[i][j] = maze[i][j] - '0';\n\t\t}\n\t}\n\tlint ans = 0;\n\trep (i, 1, n) {\n\t\trep (j, 1, m) {\n\t\t\tmemcpy(use, cpy, sizeof(use));\n\t\t\tuse[i][j] = 0;\n\t\t\tfalldown(i, j);\n\t\t\tans = max(ans, dfs());\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (n); i++)\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nint h, w, k;\n\nint f(vector<vector<int>> g, int x, int y) {\n\tg[y][x] = 0;\n\t\n\tint ret = 0;\n\tfor (int c = 1; ; c *= 2) {\n\t\trep(j, w) {\n\t\t\tfor (int i = h - 1; i > 0; i--) {\n\t\t\t\tif (g[i][j] == 0) {\n\t\t\t\t\tint t = i - 1;\n\t\t\t\t\twhile (t > 0 && g[t][j] == 0) t--;\n\t\t\t\t\tif (g[t][j] != 0) swap(g[i][j], g[t][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool loop = false;\n\t\trep(i, h) {\n\t\t\tint num = g[i][0];\n\t\t\tint cnt = 1;\n\t\t\tint idx = 0;\n\t\t\tfor (int j = 1; j < w; j++) {\n\t\t\t\tif (g[i][j] == num) cnt++;\n\t\t\t\telse {\n\t\t\t\t\tif (num > 0 && cnt >= k) break;\n\t\t\t\t\tnum = g[i][j];\n\t\t\t\t\tcnt = 1;\n\t\t\t\t\tidx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (num > 0 && cnt >= k) {\n\t\t\t\tret += num * cnt * c;\n\t\t\t\trep(j, cnt) g[i][idx + j] = 0;\n\t\t\t\tloop = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!loop) break;\n\t}\n\t\n\treturn ret;\n}\n\nint main() {\n\tcin >> h >> w >> k;\n\t\n\tvector<string> s(h);\n\trep(i, h) cin >> s[i];\n\t\n\tvector<vector<int>> g(h, vector<int>(w));\n\trep(i, h) rep(j, w) g[i][j] = s[i][j] - '0';\n\t\n\tint ans = 0;\n\trep(i, h) rep(j, w) ans = max(ans, f(g, j, i));\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<string>\n#include<sstream>\n#include<cmath>\n#include<numeric>\n#include<map>\n#include<stack>\n#include<queue>\n#include<list>\n#include<set>\nusing namespace std;\nint mod = 1e9+7;\nint h, w, k;\nvector<string> c;\nchar B = '-';\n\nvoid show(vector<string> b) {\n  for(int i=0; i<h; i++) cerr << b[i] << endl;\n  cerr << endl;\n}\n\nvector<string> del(vector<string> b) {\n  vector<string> ret = b;\n  for(int i=0; i<h; i++){\n    string s = ret[i];\n    int cnt = 0;\n    for(int j=0; j<w; j++){\n      if( s[j] == s[j+1] ) cnt++;\n      else {\n        if( cnt >= k-1 ) {\n          for(int l=0; l<cnt+1; l++){\n            s[j-l] = B;\n          }\n          cnt = 0;\n        }\n      }\n    }\n    ret[i] = s;\n  }\n  return ret;\n}\n\nvector<string> drop(vector<string> b) {\n  for(int j=0; j<w; j++){\n    string s = \"\";\n    for(int i=0; i<h; i++){\n      if( b[i][j] != B ) {\n        s += b[i][j];\n      }\n    }\n    s = string(h-s.size(), B) + s;\n    for(int i=0; i<h; i++){\n      b[i][j] = s[i];\n    }\n  }\n  return b;\n}\n\nint calc(vector<string> b) {\n  int ret = 0;\n  for(int i=0; i<h; i++) {\n    for(int j=0; j<w; j++){\n      if( b[i][j] == B ) continue;\n      ret += b[i][j]-'0';\n    }\n  }\n  return ret;\n}\n\nint simulate(vector<string> b, int x, int y) {\n\n  b[y][x] = B;\n  vector<string> old = b;\n  vector<string> now = b;\n  int score = 0;\n  int base = 1;\n  now = drop(now);\n  while( true ) {\n    // show(now);\n    now = del(now);\n    int sum = calc(old) - calc(now);\n    // cerr << base << \" \" << base * sum << endl;\n    score += base * sum;\n    // show(now);\n    now = drop(now);\n\n    if( now == old ) break;\n    old = now;\n    base *= 2;\n  }\n  show(now);\n  // cerr << \"---- \" << score << endl;\n  return score;\n}\n\nint main() {\n  cin >> h >> w >> k;\n  c.resize(h);\n  for(int i=0; i<h; i++){\n    cin >> c[i];\n    c[i] += B;\n  }\n\n  int ans = 0;\n  for(int i=0; i<h; i++){\n    for(int j=0; j<w; j++){\n      int tmp = simulate(c, j, i);\n      if( ans < tmp ){\n        cerr << tmp << \" \" << j << \" \" << i << endl;\n      }\n      ans = max(ans, tmp);\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n\n\n\n//\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define ll long long\n#define all(v) v.begin(), v.end()\nint main(){\n  int h,w,k;cin>>h>>w>>k;vector<vector<int>> c(h,vector<int>(w));\n  //int i,j,l,n,p;\n  rep(i,h)rep(j,w){\n    char ch;cin>>ch;\n    c[i][j]=(ch-'0');\n  }\n  int ans=0;\n  rep(i,h)rep(j,w){\n    bool update=1;vector<vector<int>> m=c;\n    m[i][j]=0;int score=0,timev=1;\n    while(update) {\n      update=0;\n      rep(n,w){\n        int to=h-1;\n        for(l=h-1;l>=0;l--){\n          if(m[l][n]!=0){\n            swap(m[to][n],m[l][n]);to--;\n          }\n        }\n      }\n      int get=0;\n      rep(l,h){\n        int from=0,now=m[l][w-1];\n        rep(n,w){\n          if(now!=m[l][n]){\n            int dis=(n-1)-from+1;\n            if(dis>=k){\n              for(p=from;p<n;p++) {\n                get+=m[l][p];m[l][p]=0;\n              }\n            }from=n;now=m[l][n];\n          }\n        }\n        int dis=(w-1)-from+1;\n        if(dis>=k){\n          for(p=from;p<n;p++){\n            get+=m[l][p];m[l][p]=0;\n          }\n        }\n      }\n      if(get>0)update=1;\n      else break;\n      score+=timev*get; timev*=2;\n    }ans=max(ans,score);\n  }cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 39\nusing namespace std;\nint n,m,t;\nint a[maxn][maxn],b[maxn][maxn],c[maxn][maxn];\nchar s[maxn];\nvoid op(){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=m;j++)\n            printf(\"%d \",a[i][j]);\n        puts(\"\");\n    }\n}\nvoid Copy(){\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n            b[i][j]=a[i][j];\n}\nvoid Recover(){\n     for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n            a[i][j]=b[i][j];\n}\nint cancel(bool &ok){\n    int ans=0;\n    for(int i=1;i<=n;i++){\n        int cur=1;\n        while(cur<=m){\n            int L=cur;\n            while(cur+1<=m&&a[i][cur]==a[i][cur+1])\n                cur++;\n            int R=cur;\n            if(R-L+1>=t&&a[i][cur]!=-1){\n                ok=1;\n                ans+=(R-L+1)*a[i][cur];\n                for(int j=L;j<=R;j++)\n                    a[i][j]=-1;\n            }\n            cur++;\n        }\n    }\n    return ans;\n}\nvoid drop(bool &ok){\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n            c[i][j]=a[i][j];\n    for(int j=1;j<=m;j++){\n        vector<int>tmp;\n        for(int i=n;i>=1;i--)\n            if(a[i][j]!=-1)\n                tmp.push_back(a[i][j]);\n        for(int i=0;i<(int)tmp.size();i++)\n            a[n-i][j]=tmp[i];\n        for(int i=1;i<=n-tmp.size();i++)\n            a[i][j]=-1;\n    }\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n            if(a[i][j]!=c[i][j])\n                ok=1;\n}\nint solve(){\n    int step=0,ans=0;\n    bool tmp;\n    drop(tmp);\n   // op();\n    while(1){\n        bool ok=0;\n        int val=cancel(ok);\n        drop(ok);\n        ans+=val*(1<<step);\n        step++;\n        if(!ok)\n            break;\n    }\n    return ans;\n}\nint main(){\n    int ans=0;\n    cin>>n>>m>>t;\n    for(int i=1;i<=n;i++){\n        scanf(\"%s\",s+1);\n        for(int j=1;j<=m;j++)\n            a[i][j]=s[j]-'0';\n    }\n\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=m;j++){\n            Copy();\n            a[i][j]=-1;\n            ans=max(ans,solve());\n            Recover();\n        }\n    }\n    cout<<ans<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <set>\n#include <algorithm>\n\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst long long INF = 1LL<<60;\nconst double PI=3.14159265358979323846;\nconst int NMAX=100005;\nusing namespace std;\n\n\n\nint main(){\n    int h, w, k;\n    cin >> h >> w >> k;\n    vector<vector<ll> > c(w,vector<ll>(h));\n    for(int i = h-1; i >= 0; i--){\n        for(int j = 0; j < w; j++){\n            char tmp;\n            cin >> tmp;\n            c[j][i] = tmp-'0';\n        }\n    }\n\n    ll ans = 0;\n    for(int i = 0; i < h-1; i++){\n        for(int j = 0; j < w; j++){\n            // first\n            auto d = c;\n            ll cnt = 0;\n            ll ml = 1;\n            d[j].erase(d[j].begin()+i);\n\n            bool changed = true;\n            while(changed){\n                changed = false;\n                for(int l = h-1; l >= 0; l--){\n                    ll col = 0;\n                    ll num = -1;\n                    ll sw = -1;\n                    for(int m = 0; m < w; m++){\n                        if(d[m].size() < l+1){\n                            if(col >= k){\n                                for(int p = sw; p < m; p++){\n                                    d[p].erase(d[p].begin()+l);\n                                }\n                                cnt += num*col*ml;\n                                changed = true;\n                            }\n                            col = 0;\n                            num = -1;\n                            sw = -1;\n                            continue;\n                        } else {\n                            if(d[m][l] == num){\n                                col++;\n                                continue;\n                            } else {\n                                if(col >= k){\n                                    for(int p = sw; p < m; p++){\n                                        d[p].erase(d[p].begin()+l);\n                                    }\n                                    cnt += num*col*ml;\n                                    changed = true;\n                                }\n                                col = 1;\n                                num = d[m][l];\n                                sw = m;\n                            }\n                        }\n                    }\n                    \n                    if(col >= k){\n                        for(int p = sw; p < w; p++){\n                            d[p].erase(d[p].begin()+l);\n                        }\n                        cnt += num*col*ml;\n                        changed = true;\n                    }\n                }\n                ml *= 2;\n            }\n            ans = max(ans, cnt);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint otosu(vector<deque<int>> &c,int h,int k) {\n\tif (c.size() == 0) {\n\t\treturn 0;\n\t}\n\tint point=0;\n\tfor (int i = 0; i < h; i++) {\n\t\tint j = 0;\n\t\twhile (j < c.size()-1) {\n\t\t\tint rensa = 1;\n\t\t\tif (c[j].at(i)!=0 && c[j].at(i) == c[j+1].at(i)) {\n\n\t\t\t\trensa = 2;\n\n\t\t\t\twhile (j + rensa < c.size()) {\n\t\t\t\t\tif (c[j + rensa].at(i) == c[j].at(i)) {\n\t\t\t\t\t\trensa++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (rensa >= k) {\n\t\t\t\t\tfor (int m = 0; m < rensa; m++) {\n\t\t\t\t\t\tpoint += c[j + m].at(i);\n\t\t\t\t\t\tc[j + m].at(i) = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tj=j+rensa;\n\t\t}\n\t\t\n\t}\n\n\tfor (int j = 0; j < c.size(); j++) {\n\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\tif (c[j].at(i) == -1) {\n\t\t\t\tc[j].erase(c[j].begin() + i);\n\t\t\t\tc[j].push_back(0);\n\t\t\t}\n\t\t}\n\t}\n\n\t//for (int j = c.size() - 1; j >= 0; j--) {\n\t//\tif (c[j].front() == 0) {\n\t//\t\tc.erase(c.begin() + j);\n\t//\t}\n\t//}\n\n\treturn point;\n}\n\nint main() {\n\n\tint h, w, k;\n\tcin >> h >> w >> k;\n\n\tvector<deque<int>> c(w, deque<int>());\n\tvector<deque<int>> corg(w, deque<int>());\n\n\tint summ=0;\n\tlong long in1;\n\tfor (int i =0; i <h; i++) {\n\t\tcin >> in1;\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tc[j].push_front(in1%10);\n\t\t\tin1 /= 10;\n\t\t\tsumm += c[j].front();\n\t\t}\n\t}\n\n\tif (k == 0 || k == 1) {\n\t\tcout << summ << endl;\n\t\treturn 0;\n\t}\n\n\tcorg = c;\n\tint score=0;\n\tfor (int j = 0; j < h; j++) {\n\t\tfor (int i = 0; i < w; i++) {\n\n\t\t\tc = corg;\n\n\t\t\tc[i].erase(c[i].begin() + j);\n\t\t\tc[i].push_back(0);\n\n\t\t\tint scoret = 0;\n\t\t\tint counter = 0;\n\t\t\tint point;\n\t\t\tdo {\n\t\t\t\tpoint = 0;\n\t\t\t\tpoint = otosu(c, h, k);\n\t\t\t\tscoret += point * (int)pow(2, counter);\n\t\t\t\tcounter++;\n\t\t\t} while (point != 0);\n\t\t\tscore = max(score, scoret);\n\t\t}\n\t}\n\tcout << score << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint W,H,K;\nchar fie[33][33];\nchar tmp[33][33];\n\nint checkD(int x,int y){\n  char c = fie[x][y];\n  for(int k=0;k<K;k++){\n    int nx = x + k;\n    if( nx >= W ) return 0;\n    if( fie[nx][y] != c ) return 0;\n  }\n  int ret = K;\n  for(int nx=x+K;nx<W;nx++){\n    if( fie[nx][y] != c ) return ret;\n    ret++;\n  }\n  return ret;\n}\n\nint del(int k){\n  while( true ){\n    bool loop = false;\n    for(int y=H;y>0;y--){\n      for(int x=0;x<W;x++){\n        if( !fie[x][y] ){\n          fie[x][y] = fie[x][y-1];\n          if( fie[x][y] ) loop = true;\n          fie[x][y-1] = 0;\n        }\n      }\n    }\n    if(!loop) break;\n  }\n  /*\n  for(int y=1;y<=H;y++){\n    for(int x=0;x<W;x++){\n      cout << (fie[x][y]==0?' ':fie[x][y]);\n    }\n    cout << endl;\n  }\n  */\n  int sc = 0;\n  for(int y=1;y<=H;y++){\n    for(int x=0;x<W;x++){\n      if( !fie[x][y] ) continue;\n      int ck = checkD( x, y );\n      if( ck ){\n        sc += ( fie[x][y] - '0' ) * ck;\n        //        cout << \"del \" << x <<  \" \" << ck << endl;\n        for(int nx=x;nx<x+ck;nx++) fie[nx][y] = 0;\n        x += ck-1;\n      }     \n    }\n  }\n  //  cout << \"sc : \" << sc << endl;\n  if( !sc ) return (1<<k)*sc;\n  return del(k+1) + (1<<k) * sc;\n}\n\nint score(int x,int y){\n  for(int i=1;i<=H;i++)\n    for(int j=0;j<W;j++)\n      fie[j][i] = tmp[j][i];\n  //  cout << \"score \" << x << \" \" << y << endl;\n  fie[x][y] = 0;\n  return del( 0 );\n}\n\nint main(){\n  cin >> H >> W >> K;\n  for(int i=1;i<=H;i++)\n    for(int j=0;j<W;j++){\n      cin >> fie[j][i]; tmp[j][i] = fie[j][i];\n    }\n\n\n  int res = 0;\n  for(int i=1;i<=H;i++)\n    for(int j=0;j<W;j++)\n      res = max( res, score( j, i ) );\n  cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[35][35];\nint main() {\n    int H, W, K; cin >> H >> W >> K;\n    for(int i=0; i<H; ++i){\n        string S;\n        cin >> S;\n        for(int j=0; j<W; ++j) C[i][j]=(S[j]-'0');\n    }\n    int ans=0;\n    for(int i=0; i<H*W; ++i){\n        int ban[35][35], now=0, mul=1;\n        for(int p=0; p<35; ++p) for(int q=0; q<35; ++q) ban[p][q]=C[p][q];\n        ban[i/W][i%W]=0;\n        bool flag=true;\n        while(flag){\n            int sum=0;\n            for(int j=0; j<W; ++j){\n                int cnt=H-1;\n                for(int k=H-1; k>=0; --k){\n                    if(ban[k][j]>0){\n                        ban[cnt][j]=ban[k][j];\n                        --cnt;\n                    }\n                }\n            }\n            flag=false;\n            for(int j=0; j<H; ++j){\n                for(int k=0; k<W; ++k){\n                    if(ban[j][k]>0){\n                        int ser=k;\n                        while(ban[j][ser]==ban[j][k]) ++ser;\n                        if(ser-k>=K){\n                            sum += ban[j][k]*(ser-k);\n                            flag=true;\n                            for(int v=k; v<ser; ++v) ban[j][v]=0;\n                        }\n                    }\n                }\n            }\n            now += sum*mul;\n            mul *= 2;\n        }\n        ans=max(ans, now);\n    }\n    cout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint H, W, K;\n\nvoid blockfall(vector<string> &board) {\n    for(int i=H-1; i>=0; i--) {\n        for(int j=0; j<W; j++) {\n            int x = i, y = j;\n            while(x < H-1 && board[x+1][y] == '.') {\n                swap(board[x][y], board[x+1][y]);\n                x++;\n            }\n        }\n    }\n}\n\nvector<string> erase_one(vector<string> board, int x, int y) {\n    board[x][y] = '.';\n    blockfall(board);\n    return board;\n}\n\nint solve(vector<string> board) {\n    int ret = 0;\n\n    // for(int i=0; i<H; i++) cout << board[i] << endl;\n\n    for(int z=0; ; z++) {\n        bool changed = false;\n        vector<string> chg(H, string(W, '.'));\n\n        int sum = 0;\n        for(int i=0; i<H; i++) {\n            char pre = '#';\n            int cons = 0;\n            for(int j=0; j<=W; j++) {\n                // printf(\"i = %d, j = %d, cons = %d\\n\", i, j, cons);\n                if(j == W || pre != board[i][j]) {\n                    if(cons >= K) {\n                        if(cons > 0 && board[i][j-1] != '.') {\n                            changed = true;\n                            // printf(\"char: %c\\n\", board[i][j-1]);\n                            sum += cons * (board[i][j-1] - '0');\n                        }\n                        for(int k=j-cons; k<j; k++) {\n                            board[i][k] = '.';\n                        }\n                    }\n                    cons = 1;\n                }\n                else cons++;\n                pre = board[i][j];\n            }\n        }\n\n        // printf(\"sum = %d\\n\", sum);\n        if(!changed) break;\n        ret += sum * (1 << z);\n        blockfall(board);\n    }\n    return ret;\n}\n\nint main() {\n    cin >> H >> W >> K;\n    vector<string> board(H);\n    for(int i=0; i<H; i++) cin >> board[i];\n\n    int ans = 0;\n    for(int i=0; i<H; i++) {\n        for(int j=0; j<W; j++) {\n            vector<string> n_board = erase_one(board, i, j);\n            ans = max(ans, solve(n_board));\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint otosu(vector<deque<int>> &c,int h,int k) {\n\tif (c.size() == 0) {\n\t\treturn 0;\n\t}\n\tint point=0;\n\tfor (int i = 0; i < h; i++) {\n\t\tint j = 0;\n\t\twhile (j < c.size()-1) {\n\t\t\tint rensa = 1;\n\t\t\tif (c[j].at(i)!=0 && c[j].at(i) == c[j+1].at(i)) {\n\n\t\t\t\trensa = 2;\n\n\t\t\t\twhile (j + rensa < c.size()) {\n\t\t\t\t\tif (c[j + rensa].at(i) == c[j].at(i)) {\n\t\t\t\t\t\trensa++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (rensa >= k) {\n\t\t\t\t\tfor (int m = 0; m < rensa; m++) {\n\t\t\t\t\t\tpoint += c[j + m].at(i);\n\t\t\t\t\t\tc[j + m].at(i) = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tj=j+rensa;\n\t\t}\n\t\t\n\t}\n\n\tfor (int j = 0; j < c.size(); j++) {\n\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\tif (c[j].at(i) == -1) {\n\t\t\t\tc[j].erase(c[j].begin() + i);\n\t\t\t\tc[j].push_back(0);\n\t\t\t}\n\t\t}\n\t}\n\n\t//for (int j = c.size() - 1; j >= 0; j--) {\n\t//\tif (c[j].front() == 0) {\n\t//\t\tc.erase(c.begin() + j);\n\t//\t}\n\t//}\n\n\treturn point;\n}\n\nint main() {\n\n\tint h, w, k;\n\tcin >> h >> w >> k;\n\n\tvector<deque<int>> c(w, deque<int>());\n\tvector<deque<int>> corg(w, deque<int>());\n\n\tint summ=0;\n\tlong long in1;\n\tfor (int i =0; i <h; i++) {\n\t\tcin >> in1;\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tc[j].push_front(in1%10);\n\t\t\tin1 /= 10;\n\t\t\tsumm += c[j].front();\n\t\t}\n\t}\n\n\tif (k == 0 || k == 1) {\n\t\tcout << summ << endl;\n\t\treturn 0;\n\t}\n\n\tcorg = c;\n\tlong long score=0;\n\tfor (int j = 0; j < h; j++) {\n\t\tfor (int i = 0; i < w; i++) {\n\n\t\t\tc = corg;\n\n\t\t\tc[i].erase(c[i].begin() + j);\n\t\t\tc[i].push_back(0);\n\n\t\t\tlong long scoret = 0;\n\t\t\tint counter = 0;\n\t\t\tint point;\n\t\t\tdo {\n\t\t\t\tpoint = 0;\n\t\t\t\tpoint = otosu(c, h, k);\n\t\t\t\tscoret += point * (int)pow(2, counter);\n\t\t\t\tcounter++;\n\t\t\t} while (point != 0);\n\t\t\tscore = max(score, scoret);\n\t\t}\n\t}\n\tcout << score << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<vector>\nusing namespace std;\nint main(void){\n\tint a[100][100];\n\tint b[100][100];\n\tint n;\n\tint m;\n\tint c;\n\tint x;\n\tint s=0;\n\tint ans = 0;\n\tint k;\n\tscanf(\"%d %d\", &n,&m);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < m; j++){\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\tb[i][j] = a[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < m; j++){\n\t\t\ts = 0;\n\t\t\tfor (int k = 0; k < n; k++){\n\t\t\t\tfor (int l = 0; l < m; l++){\n\t\t\t\t\ta[k][l] = b[k][l];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = i; k >0 ; k--){\n\t\t\t\ta[k][j] = a[k - 1][j];\n\t\t\t}\n\t\t\ta[0][j] = 0;\n\t\t\tfor (int k = 1; k < n; k++){\n\t\t\t\tc = 0;\n\t\t\t\tfor (int l=0; l < m; l++){\n\t\t\t\t\tif (a[k][0] == a[k][l])c++;\n\t\t\t\t}\n\t\t\t\tif (c == m)s = s + (a[k][0] * m);\n\t\t\t}\n\t\t\tif (s > ans)ans = s;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ temp.cpp\n// C++ includes used for precompiling -*- C++ -*-\n\n// Copyright (C) 2003-2013 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file stdc++.h\n *  This is an implementation file for a precompiled header.\n */\n\n// 17.4.1.2 Headers\n\n// C\n//#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n/*\n//#if __cplusplus >= 201103L\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n*/\n\n// C++\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n/*\n//#if __cplusplus >= 201103L\n#include <array>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n*/\nusing namespace std;\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n  \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\n\n#define INF INT_MAX/3\n#define MAX_N 1000\n int h,w,k;\n vector<string> vec;\n vector<string> crnt;\n\n int search(int itr){\n  int ret=0;\n  //消せることを0で埋めながら加算していく\n  bool changed = false;\n  rep(i,h){\n    rep(j,w-1){\n      //0ということはもうそこには数字が入っていないということだからcontinueしていい\n      if(crnt[i][j]==0) continue;\n      int d=0;\n      //横の値が等しいだけ加算していく\n      while(j+d<w&&crnt[i][j]==crnt[i][j+d]) d++;\n      if(d>=k){\n        //もし規定の長さを超えたなら\n        //加算して消した所に0を代入していく\n        //スコアはi回目で消滅した数字の値の和なのでbitをずらすことで実現している\n        ret += (1<<itr) * (crnt[i][j]-'0')*d;\n        rep(dd,d) crnt[i][j+dd] = 0;\n        changed = true;\n      }\n      //dが増えていたらそのぶんずらしてあげてそうでなかったら-1してインクリメント\n      //される時にその点から始まるようにする\n    j += d-1;\n  }\n }\n //変化が一つもない場合はもう返す\n if(!changed) return ret;\n\n //-1をつめる\n rep(j,w){\n  int s=h-1;\n  for(int hh=h-1;hh>=0;hh--){\n    while(s>=0&crnt[s][j]==0) s--;\n    if(s<0) crnt[hh][j]=0;//もう入っていないということ\n    else crnt[hh][j] = crnt[s][j];\n    s--;\n    }\n }\n return ret + search(itr+1);\n}\n\n int main(){\n  cin>>h>>w>>k;\n  //resizeとは\n  //指定した数だけ実際に何らかの値で埋める。\n  ///\n  vec.resize(h);\n  rep(i,h) cin>>vec[i];\n\n  int res=0;\n  rep(i,h) rep(j,w){\n    //ここで作り直したものを入れ直している\n    crnt = vector<string>(vec);\n    for(int ii=i;ii>0;ii--) crnt[ii][j] = crnt[ii-1][j];\n      crnt[0][j]=0;\n    //ここで消す作業をしている\n    res = max(res,search(0));\n  }\n  cout<<res<<endl;\n  return 0;\n }\n // http://s8pc-3.contest.atcoder.jp/submissions/987968"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nint h, w, k;\n\nvoid tsumeru(vector<vector<int> > &tmpC, int col) {\n  vector<int> fill;\n  int blank = -1;\n  for(int i = h - 1; i >= 0; i--) {\n    if (tmpC[i][col] == 0) {\n      if (blank == -1) {\n        blank = i;\n      }\n    } else {\n      if (blank != -1) {\n        fill.push_back(i);\n      }\n    }\n  }\n  \n  int s = fill.size();\n  if (s == 0) return;\n\n  for (int i = blank; i > blank - s; i--) {\n    tmpC[i][col] = tmpC[fill[blank - i]][col];\n  }\n  for (int i = blank - s; i >= 0; i--) {\n    tmpC[i][col] = 0;\n  }\n}\n\nll disapper(vector<vector<int> > &tmpC, int raw) {\n  ll sum = 0;\n  if (w >= 3) {\n    for(int col = 0; col <= w - 3; col++) {\n      if (tmpC[raw][col] != 0 && tmpC[raw][col] == tmpC[raw][col + 1] && tmpC[raw][col] == tmpC[raw][col + 2]) {\n        sum += 3 * tmpC[raw][col];\n        tmpC[raw][col] = tmpC[raw][col + 1] = tmpC[raw][col + 2] = 0;\n      }\n    }\n  }\n  for(int col = 0; col <= w - 2; col++) {\n    if (tmpC[raw][col] != 0 && tmpC[raw][col] == tmpC[raw][col + 1]) {\n      sum += 2 * tmpC[raw][col];\n      tmpC[raw][col] = tmpC[raw][col + 1] = 0;\n    }\n  }\n  return sum;\n}\n\n\nint main() {\n  cin >> h >> w >> k;\n\n  vector<vector<int> > C(h, vector<int>(w, 0)), tmpC(h, vector<int>(w, 0));\n  rep(i, h) {\n    string str;\n    cin  >> str;\n    rep(j ,w) {\n      C[i][j] = str[j] - '0';\n    }\n  }\n\n  ll ans = 0;\n  rep(i, h) rep(j, w) {\n    rep(ii, h) rep(jj ,w) tmpC[ii][jj] = C[ii][jj];\n\n    int turn = 0;\n    ll tmp_score = 0;\n    tmpC[i][j] = 0;\n    while(true) {\n\n      rep (col, w) tsumeru(tmpC, col);\n      ll disapper_score = 0;\n      rep(raw, h) disapper_score += disapper(tmpC, raw);\n\n      // rep(raw, h) {\n      //   rep(col, w) {\n      //     cout << tmpC[raw][col] << ' ';\n      //   }\n      //   cout << endl;\n      // }\n\n      if (disapper_score == 0) break;\n\n      tmp_score += disapper_score * pow(2, turn); \n      // cout << tmp_score << endl;\n      turn++;\n    }\n    ans = max(ans, tmp_score);\n  }\n\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid erup( vector<string> &t, int i, int j )\n{\n\tt[i][j] = ' ';\n\tfor( int k = i; k - 1 >= 0; k-- ) {\n\t\tif( t[k - 1][j] == ' ' ) break;\n\t\tt[k][j] = t[k - 1][j];\n\t\tt[k - 1][j] = ' ';\n\t}\n}\n\nvoid chk( vector<string> &t, int i, int j, int W, int K, vector<pair<int, int>> &er )\n{\n\tfor( int k = i; k >= 0; k-- ) {\n\t\tfor( int l = 0; l < W - 1; l++ ) {\n\t\t\tif( t[k][l] != ' ' && t[k][l] == t[k][l + 1] ) {\n\t\t\t\tvector<pair<int, int>> tv;\n\t\t\t\tchar nc = t[k][l];\n\t\t\t\twhile( l < W && t[k][l] == nc ) {\n\t\t\t\t\ttv.push_back( make_pair( k, l ) );\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t\tl--;\n\t\t\t\tif( tv.size() >= K ) er.insert( er.end(), tv.begin(), tv.end() );\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint H, W, K;\n\tcin >> H >> W >> K;\n\tvector<string> c( H );\n\tfor( int i = 0; i < H; i++ ) {\n\t\tcin >> c[i];\n\t}\n\n\tlong long ans = 0;\n\tfor( int i = 0; i < H; i++ ) {\n\t\tfor( int j = 0; j < W; j++ ) {\n\t\t\tvector<string> t = c;\n\t\t\tlong long sc = 0;\n\t\t\terup( t, i, j );\n\t\t\tint idx = 0;\n\t\t\twhile( 1 ) {\n\t\t\t\tvector<pair<int, int>> er;\n\t\t\t\tchk( t, i, j, W, K, er );\n\t\t\t\tif( er.size() == 0 ) break;\n\t\t\t\tint sum = 0;\n\t\t\t\tfor( int k = 0; k < er.size(); k++ ) sum += t[er[k].first][er[k].second] - '0';\n\t\t\t\tsc += (1LL << idx) * sum;\n\t\t\t\tidx++;\n\t\t\t\twhile( er.size() ) {\n\t\t\t\t\tint ii, jj;\n\t\t\t\t\ttie( ii, jj ) = er.back();\n\t\t\t\t\ter.pop_back();\n\t\t\t\t\terup( t, ii, jj );\n\t\t\t\t}\n\t\t\t\tans = max( ans, sc );\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\ntypedef long long int ll;\n\nint h,w,k;\nchar fi[31][31];\nint cp[31][31];\nint epy[31][31];\n\nvoid fall(){\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tepy[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<w;i++){\n\t\tfor(int j=h-1;j>=0;j--){\n\t\t\tepy[j][i]=epy[j+1][i];\n\t\t\tif(cp[j][i]==0)epy[j][i]++;\n\t\t}\n\t\tfor(int j=h-1;j>=0;j--){\n\t\t\tif(cp[j][i]!=0&&epy[j][i]!=0){\n\t\t\t\tcp[j+epy[j][i]][i]=cp[j][i];\n\t\t\t\tcp[j][i]=0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint rensa(int p){\n\tbool ok=false;\n\tint res=0;\n\tfor(int i=0;i<h;i++){\n\t\tint cnt=0;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tint m=cp[i][j];\n\t\t\twhile(j<w&&m==cp[i][j]){\n\t\t\t\tj++;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tj--;\n\t\t\tif(cnt>=k){\n\t\t\t\tok=true;\n\t\t\t\tres+=cnt*m;\n\t\t\t\tfor(int u=0;u<cnt;u++){\n\t\t\t\t\tcp[i][j-u]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt=0;\n\t\t}\n\t}\n\tif(!ok||res==0)return res;\n\telse{\n\t\tfall();\n\t\treturn rensa(2*p)+res*p;\n\t}\n}\n\nint solve(int x,int y){\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcp[i][j]=(int)(fi[i][j]-'0');\n\t\t}\n\t}\n\tcp[x][y]=0;\n\tfall();\n\treturn rensa(1);\n}\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcin >> h >> w >> k;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin >> fi[i][j];\n\t\t}\n\t}\n\tint score=0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tscore=max(score,solve(i,j));\n\t\t}\n\t}\n\tcout << score << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repd(i,a,b) for (int i=(a);i<(b);i++)\n#define rep(i,n) repd(i,0,n)\n#define all(x) (x).begin(),(x).end()\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntypedef long long ll;\nconst long long INF = 1LL << 60;\ntypedef pair<int, int> P;\nint main()\n{\n    int H, W, K;\n    cin >> H >> W >> K;\n    vector<vector<int>> HW(H, vector<int>(W)), HW2(H, vector<int>(W));\n\n    rep(i, H) {\n        rep(j, W) {\n            char c;\n            cin >> c;\n            HW[H - i - 1][j] = c - '0';\n            HW2[H - i - 1][j] = HW[H - i - 1][j];\n        }\n    }\n\n    ll ans = 0;\n    rep(i, H) {\n        rep(j, W) {\n            ll res = 0;\n            repd(k, i + 1, H) {\n                HW[k - 1][j] = HW[k][j];\n            }\n            HW[H - 1][j] = -1;\n            ll cnt = 1;\n            while (1) {\n                vector<vector<int>> check(H, vector<int>(W, 0));\n                rep(k, H) {\n                    repd(l, 1, W) {\n                        if (HW[k][l] == -1) continue;\n                        if (HW[k][l] == HW[k][l - 1]) {\n                            check[k][l] = check[k][l - 1] + 1;\n                        }\n                    }\n                }\n\n                bool flag = false;\n                ll point = 0;\n                rep(k, H) {\n                    for (int l = W - 1; l >= 0; l--) {\n                        if (check[k][l] + 1 >= K) {\n                            repd(m, l - check[k][l], l + 1) {\n                                point += HW[k][m];\n                                HW[k][m] = -1;\n                            }\n                            l -= check[k][l] + 1;\n                            flag = true;\n                        }\n                    } \n                }\n\n                if (!flag) break;\n                else res += cnt * point;\n                \n                bool fall = true;\n                while (fall) {\n                    fall = false;\n                    repd(k, 1, H) {\n                        rep(l, W) {\n                            if (HW[k][l] == -1) continue;\n                            if (HW[k - 1][l] == -1) {\n                                HW[k - 1][l] = HW[k][l];\n                                HW[k][l] = -1;\n                                fall = true;\n                            }\n                        }\n                    }\n                }\n\n                cnt *= 2;\n            }\n            chmax(ans, res);\n\n            rep(k, H) {\n                rep(j, W) {\n                    HW[k][j] = HW2[k][j];\n                }\n            }\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    Problem 93\n    https://atcoder.jp/contests/s8pc-3/tasks/s8pc_3_b\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n/* typedef */\ntypedef long long ll;\ntypedef pair<int, int> pii;\n/* class */\nclass pazzle {\n    public:\n    int H, W, K;\n    ll ans = 0;\n    vector<vector<int> > v;\n    pazzle (int H, int W, int K, vector<vector<int> > v)\n    : H(H), W(W), K(K), v(v) {}\n    bool del() {\n        int ret = false;\n        for (int i = 0; i < H; i++) {\n            int r = 0;\n            for (int l = 0; l < W; l++) {\n                int tmp = v[i][r];\n                while (v[i][r] == -1) {\n                    r++;\n                    l++;\n                }\n                while (v[i][r] == v[i][r + 1]){\n                    r++;\n                    tmp += v[i][r];\n                }\n                if (r - l + 1>= K) {\n                    for (int k = l; k <= r; k++) v[i][k] = -1;\n                    ans += tmp;\n                    ret = true;\n                }\n                l = r;\n                r++;\n            }\n        }\n        return ret;\n    }\n    void move() {\n        for (int i = 0; i < W; i++) {\n            for (int j = H - 1; j > 0; j--) {\n                if (v[j][i] == -1) {\n                    int k = j - 1;\n                    while (v[k][i] == -1 && k > 0) k--;\n                    if (v[k][i] != -1) swap(v[k][i], v[j][i]);\n                }\n            }\n        }\n    }\n    void printPoint() {\n        cout << ans << '\\n';\n    }\n    ll gameStart() {\n        ll ret = 0;\n        move();\n        for (int i = 0; del(); i++){\n            move();\n            ret += pow(2, i) * ans;\n            ans = 0;\n        }\n        return ret;\n    }\n};\n/* constant */\nconst int INF = (1 << 30);\n/* global variables */\n/* function */\n/* main */\nint main(){\n    int H, W, K;\n    cin >> H >> W >> K;\n    vector<string> vs(H);\n    for (int i = 0; i < H; i++) cin >> vs[i];\n    vector<vector<int> > v(H, vector<int> (W + 1, -2));\n    for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) {\n        if (vs[i][j] == '.') v[i][j] = 11;\n        else v[i][j] = vs[i][j] - '0';\n    }\n    if (K == 1) {\n        int ans = 0;\n        int minValue = INF;\n        for (auto vi : v) {\n            ans += accumulate(vi.begin(), vi.end(), 0);\n            minValue = min(*min_element(vi.begin(), vi.end()), minValue);\n        }\n        cout << ans  - minValue << '\\n';\n        return 0;\n    }\n    else if (K >= 4) {\n        cout << 0 << '\\n';\n        return 0;\n    }\n    ll ans = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int tmp = v[i][j];\n            v[i][j] = -1;\n            pazzle P = pazzle(H, W, K, v);\n            ans = max(ans, P.gameStart());\n            v[i][j] = tmp;\n        }\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint h,w,k;\nstring str;\nint fie[31][31];\nint tmp[31][31];\nint cnt[31][31];\n\nvoid fall(){\n\tmemset(cnt,0,sizeof(cnt));\n\tfor(int i=0;i<w;i++){\n\t\tfor(int j=h-1;j>=0;j--){\n\t\t\tcnt[j][i]=cnt[j+1][i];\n\t\t\tif(tmp[j][i]==0){\n\t\t\t\tcnt[j][i]++;\n\t\t\t}\n\t\t}\n\t\tfor(int j=h-1;j>=0;j--){\n\t\t\tif(tmp[j][i]!=0 && cnt[j][i]!=0){\n\t\t\t\ttmp[j+cnt[j][i]][i]=tmp[j][i];\n\t\t\t\ttmp[j][i]=0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint rensa(int v){\n\tbool flag=false;\n\tint ans=0;\n\t/*\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tprintf(\"%d\",tmp[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n\t*/\n\tfor(int i=0;i<h;i++){\n\t\tint cnt=0;\n\t\tfor(int j=1;j<w;j++){\n\t\t\tif(tmp[i][j]==tmp[i][j-1] && tmp[i][j]!=0){\n\t\t\t\tcnt++;\n\t\t\t}else{\n\t\t\t\tif(cnt+1>=k){\n\t\t\t\t\tflag=true;\n\t\t\t\t\tfor(int k=j-1;k>=j-1-cnt;k--){\n\t\t\t\t\t\tans+=tmp[i][k];\n\t\t\t\t\t\ttmp[i][k]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcnt=0;\n\t\t\t}\n\t\t}\n\t\tif(cnt+1>=k){\n\t\t\tflag=true;\n\t\t\tfor(int k=w-1;k>=w-1-cnt;k--){\n\t\t\t\tans+=tmp[i][k];\n\t\t\t\ttmp[i][k]=0;\n\t\t\t}\n\t\t}\n\t}\n\tif(!flag || ans==0)return ans;\n\tfall();\n\treturn rensa(v*2)+v*ans;\n}\n\nint calc(int x,int y){\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\ttmp[i][j]=fie[i][j];\n\t\t}\n\t}\n\ttmp[y][x]=0;\n\tfall();\n\t//printf(\"go!\\n\");\n\treturn rensa(1);\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&h,&w,&k);\n\tfor(int i=0;i<h;i++){\n\t\tcin >> str;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tfie[i][j]=(str[j]-'0');\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tans=max(ans,calc(j,i));\n\t\t\t//printf(\"%d\\n\",ans);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint H,W,K;\nstring C[50];\nstring B[50];\n\nll dfs() {\n\tll tot=0;\n\tint y,x,i;\n\t\n\tFOR(x,H) {\n\t\tchar pre='0';\n\t\tint num=0;\n\t\tFOR(y,W) {\n\t\t\tif(B[y].size()<=x) {\n\t\t\t\tpre='0';\n\t\t\t\tnum=0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(B[y][x]!=pre) pre=B[y][x], num=0;\n\t\t\t\tnum++;\n\t\t\t\tif(num==K) {\n\t\t\t\t\ttot+=(pre-'0')*num;\n\t\t\t\t\tFOR(i,K) B[y-i][x]='0';\n\t\t\t\t}\n\t\t\t\tif(num>K) {\n\t\t\t\t\ttot+=(pre-'0');\n\t\t\t\t\tB[y][x]='0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(tot==0) return 0;\n\t\n\tFOR(y,W) {\n\t\tstring s;\n\t\tFORR(c,B[y]) if(c!='0') s+=c;\n\t\tB[y]=s;\n\t}\n\treturn tot+dfs()*2;\n\t\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>H>>W>>K;\n\tFOR(y,H) cin>>C[y];\n\tll ma=0;\n\tFOR(y,H) FOR(x,W) {\n\t\tint y2,x2;\n\t\tFOR(x2,W) {\n\t\t\tB[x2].clear();\n\t\t\tfor(y2=H-1;y2>=0;y2--) if(y2!=y || x2!=x) B[x2]+=C[y2][x2];\n\t\t}\n\t\tma=max(ma,dfs());\n\t}\n\tcout<<ma<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ macro.cpp -std=c++14\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\nconst ll LINF = 1e18;\nusing namespace std;\n\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\"  ) << endl\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\"  ) << endl\n\n#define SANKOU(n,a,b) cout << ((n) ? (#a) : (#b) ) << endl\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define REPR(i,n) for(int i=n;i>=0;i--)\n\n#define FOREACH(x,a) for(auto& (x) : (a) )\n\n#define WFA(d,v) REP(k,v)REP(i,v)REP(j,v)d[i][j]=min(d[i][j],d[i][k]+d[k][j])\n\n#define SCOUT(x) cout<<(x)<<\" \"\n#define ENDL cout<<endl\n\n#define VECCIN(x) for(auto&youso_: (x) )cin>>youso_\n#define VECIN2(x,y) REP(i,x.size())cin>>x[i]>>y[i]\n#define VECCOUT(x) for(auto&youso_: (x) )cout<<youso_<<\" \";cout<<endl\n\n#define ALL(obj) (obj).begin(),(obj).end()\n\n#define EXIST(n,x) (find(ALL(n),x)!=n.end())\n#define UNIQUE(obj) sort(ALL( obj )); obj.erase(unique(ALL(obj)),obj.end())\n#define COUT(x) cout<<(x)<<endl\nvoid CINT(){}\ntemplate <class Head,class... Tail>\nvoid CINT(Head&& head,Tail&&... tail){\ncin>>head;\nCINT(move(tail)...);\n}\n#define CIN(...) int __VA_ARGS__;CINT(__VA_ARGS__)\n#define SCIN(...) string __VA_ARGS__;CINT(__VA_ARGS__)\n\n// #include <boost/multiprecision/cpp_int.hpp>\n// using namespace boost::multiprecision; // cpp_int\n\n#define P pair<int,int>\n#define V vector<int>\n#define M map<int,int>\n#define S set<int>\n#define L list<int>\n\n#define pb(a) push_back(a)\n#define mp make_pair\n\nll h,w,k;\nll Solve(vector<V> vec,int dan,int count,int point){\n    if(dan<0)return point;\n    bool wareware=true;\n    int ttttt=vec[dan][0];\n    REP(i,w)if(ttttt!=vec[dan][i])wareware=false;\n    if(!wareware)return point;\n\n    point+=(pow(2,count) * ttttt * w);\n    REPR(i,dan)REP(j,w)vec[i][j]=vec[i+1][j];\n    h--;\n    vec.erase(vec.begin()+(int)vec.size()-1);\n    return Solve(vec,dan-1,count+1,point+1);\n\n\n}\n\nint main(){\n    \n    cin>>h>>w>>k;\n    vector<V> c(h,V(w));\n    REP(i,h){\n        SCIN(str);\n        REP(j,w){\n            c[i][j]=(int)str[j];\n        }\n    }\n\n    ll ans=0;\n    REP(i,h){\n        ans = max(ans,Solve(c,i,0,0));\n    }\n    COUT(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <array>\n#include <tuple>\n#include <string>\n#include <algorithm>\n#include <functional> // greater など\n#include <cmath>      // abs など\n#include <numeric>    // accumulate, gcd など\n#include <cassert>    // assert\n#include <stdexcept>\n#include <bitset>\nusing namespace std;\n\n// #include <boost/multiprecision/cpp_int.hpp>\n// using namespace boost::multiprecision;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\ntypedef long long ll;\n// typedef int128_t ll;\n// typedef cpp_int ll;\n\n// GCC, 配列のアクセスなど\n#define _GLIBCXX_DEBUG\n// Clang, 配列のアクセスなど\n#define _LIBCPP_DEBUG 0\n\n#define NDEBUG 1\n// debug用出力 https://trap.jp/post/998/\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T)\n{\n    cerr << H << \" \";\n    debug_out(T...);\n}\n#ifdef NDEBUG\n#define debug(...)\n#else\n#define debug(...) debug_out(__VA_ARGS__)\n#endif\n\n//////////////// //////////////// //////////////// //////////////// ////////////////\n//////////////// //////////////// //////////////// //////////////// ////////////////\n\nint h,w,k;\nvector<vector<int>> ini(30, vector<int>(30));\nvector<vector<int>> cur(30, vector<int>(30));\nint res;\n\nint calc(int i0, int j0) {\n    // 石を消滅、落下\n    for (int i = i0; i >= 0; i--) {\n        cur[i+1][j0] = cur[i][j0];\n    }\n    cur[0][j0] = -1;\n#ifndef NDEBUG\n    rep(i, h)\n    {\n        rep(j, w) { cerr << cur[i][j]; }\n        cerr << '\\n';\n    }\n#endif\n\n    int res = 0;\n    for (int turn = 0; ; turn++) {\n        int cur_score = 0;\n        rep(i,h) {\n            int cnt = 0; int col = -1;\n            rep(j,w) {\n                if (col > 0 && cur[i][j] == col) {\n                    cnt++;\n                    if (cnt == k)\n                    {\n                        rep(j1, k)\n                        {\n                            cur[i][j - j1] = -1;\n                        }\n                        cur_score += k * col;\n                    }\n                    else if (cnt > k) {\n                        cur[i][j] = -1;\n                        cur_score += col;\n                    }\n                } else {\n                    col = cur[i][j];\n                    cnt = 1;\n                }\n            }\n        }\n        if(cur_score == 0) { break; }\n        res += cur_score * (1 << turn);\n        debug(\"score\", cur_score);\n\n#ifndef NDEBUG\n        rep(i, h)\n        {\n            rep(j, w) { cerr << cur[i][j]; }\n            cerr << '\\n';\n        }\n#endif\n\n        // 落下\n        rep(j,w) {\n            queue<int> prev;\n            for (int i = h-1; i >= 0; i--) {\n                if (cur[i][j] == -1) { prev.push(i); continue; }\n                if (prev.empty()) { continue; }\n                int i1 = prev.front(); prev.pop();\n                cur[i1][j] = cur[i][j];\n                cur[i][j] = -1;\n                prev.push(i);\n            }\n        }\n\n    }\n\n    return res;\n}\n\nint main()\n{\n    // 高速な入出力\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << setprecision(15); // 浮動小数の表示の精度\n\n    cin>>h>>w>>k;\n    rep(i,h) {\n        rep(j,w) {\n            char c; cin>>c;\n            ini[i][j] = c - '0';\n        }\n    }\n\n    rep(i,h) {\n        rep(j,w) {\n            rep(i,h) {\n                rep(j,w) {\n                    cur[i][j] = ini[i][j];\n                }\n            }\n            res = max(res, calc(i,j));\n            debug(j, res);\n        }\n    }\n    cout<<res<<'\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n    Problem 93\n    https://atcoder.jp/contests/s8pc-3/tasks/s8pc_3_b\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n/* typedef */\ntypedef long long ll;\ntypedef pair<int, int> pii;\n/* class */\nclass pazzle {\n    public:\n    int H, W, K, ans;\n    vector<vector<int> > v;\n    pazzle (int H, int W, int K, vector<vector<int> > v)\n    : H(H), W(W), K(K), v(v) {}\n    bool del() {\n        int ret = false;\n        for (int i = H - 1; i >= 0; i--) {\n            int r = 0;\n            for (int l = 0; l < W; l++) {\n                int tmp = v[i][r];\n                while (v[i][r] == -1) {\n                    r++;\n                    l++;\n                }\n                while (v[i][r] == v[i][r + 1]){\n                    r++;\n                    tmp += v[i][r];\n                }\n                if (r - l + 1>= K) {\n                    for (int k = l; k <= r; k++) v[i][k] = -1;\n                    if (tmp > 0) ans += tmp;\n                    ret = true;\n                }\n                l = r;\n                r++;\n            }\n        }\n        return ret;\n    }\n    void move() {\n        for (int i = 0; i < W; i++) {\n            vector<int> u;\n            for (int j = H - 1; j >= 0; j--) if (v[j][i] != -1) u.push_back(v[j][i]);\n            for(int j = 0; j < H; j++) v[j][i] = -1;\n            for (int j = 0; j < u.size(); j++) v[H - 1 - j][i] = u[j];\n        }\n    }\n    void setAns() { ans = 0; }\n    ll gameStart() {\n        ll ret = 0;\n        move();\n        setAns();\n        for (int i = 0; del(); i++){\n            move();\n            ret += pow(2, i) * ans;\n            setAns();\n        }\n        return ret;\n    }\n};\n/* constant */\nconst int INF = (1 << 30);\n/* global variables */\n/* function */\n/* main */\nint main(){\n    int H, W, K;\n    cin >> H >> W >> K;\n    vector<string> vs(H);\n    for (int i = 0; i < H; i++) cin >> vs[i];\n    vector<vector<int> > v(H, vector<int> (W + 1, -2));\n    for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) {\n        if (vs[i][j] == '.') v[i][j] = -1;\n        else v[i][j] = vs[i][j] - '0';\n    }\n    if (K >= 4) {\n        cout << 0 << '\\n';\n        return 0;\n    }\n    ll ans = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            // if (i != 3 || j != 2) continue; // XXX\n            int tmp = v[i][j];\n            v[i][j] = -1;\n            pazzle P = pazzle(H, W, K, v);\n            ans = max(ans, P.gameStart());\n            v[i][j] = tmp;\n        }\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pull = pair<ull, ll>;\nusing pis = pair<int, string>;\n#define INF 1000000000\n#define LLINF 10000000000000000ll\n#define MOD 1000000007LL\n\nvoid copy_field(vector<vector<int>> &field, vector<vector<int>> &original) {\n  for (int i = 0; i < field.size(); i++) for (int j = 0; j < field[0].size(); j++) field[i][j] = original[i][j];\n  return;\n}\n\nbool check(vector<vector<int>> &field, vector<vector<int>> &checkfield, int k) {\n  int h = field.size(), w = field[0].size();\n  bool flag = false;\n  for (int i = 0; i < h; i++) {\n    if (k == 0) {\n      for (int j = 0; j < w; j++) checkfield[i][j] = 1;\n      return true;\n    }\n    int before = field[i][0], cnt = 1;\n    for (int j = 1; j < w; j++) {\n      if ((before != 0) && (before == field[i][j])) {\n        cnt++;\n        if (cnt >= k) {\n          checkfield[i][j] = 1;\n          flag = true;\n        }\n      }\n      else {\n        cnt = 1;\n        before = field[i][j];\n      }\n    }\n    for (int j = w-1; j >= k-1; j--) {\n      if ((checkfield[i][j] == 1) && (checkfield[i][j-1] == 0)) {\n        for (int l = 0; l < k-1; l++) {\n          j--;\n          checkfield[i][j] = 1;\n        }\n      }\n    }\n  }\n  return flag;\n}\n\nvoid init_checkfield(vector<vector<int>> &checkfield) {\n  for (int i = 0; i < checkfield.size(); i++) for (int j = 0; j < checkfield[0].size(); j++) checkfield[i][j] = 0;\n  return;\n}\n\nvoid init_field(vector<vector<int>> &field, int erase) {\n  int h = field.size();\n  for (int i = erase/h; i > 0; i--) {\n    field[i][erase%h] = field[i-1][erase%h];\n  }\n  field[0][erase % h] == 0;\n}\n\nvoid printfield(vector<vector<int>>&field) {\n  for (int i = 0; i < field.size(); i++) {\n    for (int j = 0; j < field[0].size(); j++) {\n      cout << field[i][j] << \" \";\n    }cout << endl;\n  }cout << endl;\n  return;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int h,w, k;\n  cin >> h >> w >> k;\n  vector<vector<int>> field(h, vector<int>(w)), original(h, vector<int>(w)), checkfield(h, vector<int>(w));\n  //for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) cin >> original[i][j];\n  for (int i = 0; i < h; i++) {\n    string s;\n    cin >> s;\n    for (int j = 0; j < w; j++) {\n      original[i][j] = (int)(s[j] - '0');\n    }\n  }\n\n  int ans = -1;\n  for (int erase = 0; erase < h*w; erase++) {\n    copy_field(field, original);\n    init_checkfield(checkfield);\n    //field[erase/h][erase%h] = 0;\n    init_field(field, erase);\n    int db = 1;\n    int temp = 0;\n    while(check(field, checkfield, k)) {\n      //cout << \"check\" << erase << endl;\n      //printfield(checkfield);\n      \n      for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n          if (checkfield[i][j] == 1) {\n            temp += db * field[i][j];\n            field[i][j] = 0;\n          }\n        }\n      }\n      \n      for (int i = h-2; i >= 0; i--) for (int j = 0; j < w; j++) checkfield[i][j] += checkfield[i+1][j];\n\n      for (int i = h-1; i >= 0; i--) {\n        for (int j = 0; j < w; j++) {\n          if ((field[i][j] == 0) || (checkfield[i][j] == 0)) continue;\n          if (i + checkfield[i][j] < h) {\n            field[i+checkfield[i][j]][j] = field[i][j];\n            field[i][j] = 0;\n          }\n        }\n      }\n      db *= 2;\n      init_checkfield(checkfield);\n    }\n    //cout << temp << endl;\n    ans = max(ans, temp);\n  }\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define countof(a) (sizeof(a)/sizeof(*a))\n\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define vpi vector<pi >\n#define pi pair<int,int>\n#define fi first\n#define se second\n#define all(n) n.begin(), n.end()\n\n#define FROMTO(var, from, to) for (register int var = (from), var##down = ((int)(to)) < ((int)(from));var##down ? (var >= (int)(to)) : (var <= (int)(to));var##down ? var-- : var++)\n#define UPTO(var, from, to)   for (register int var = (from); var <= ((int)to); var++)\n#define DOWNTO(var, from, to) for (register int var = (from); var >= ((int)to); var--)\n#define FOR(var, to)          UPTO(var, 0, (to)-1)\n#define DOWN(var, from)       DOWNTO(var, (from)-1, 0) \n\n#define INIT(var, val) FOR(i,countof(var)) var[i] = val\n#define INPUT(var) FOR(i,countof(var)) cin >> var[i]\n#define INPUT1(var) FOR(i,countof(var)) cin >> var[i], var[i]--\n\n#define SORT(v) qsort(v,countof(v),sizeof(*v),int_less)\n#define SORTT(v) qsort(v,countof(v),sizeof(*v),int_greater)\n#define QSORT(v,b) qsort(v,countof(v),sizeof(*v),b)\n\n#define MOD 1000000007\n#define INF ((1 << 30)-1)\n#define LINF ((1LL << 62)-1)\n\ntypedef uint8_t u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\ntypedef int8_t s8;\ntypedef int16_t s16;\ntypedef int32_t s32;\ntypedef int64_t s64;\n\n/* ------------------------ */\n/* BEGIN EXTERNAL LIBRARIES */\n/* ------------------------ */\n\ntemplate<int mod>\nstruct ModInt{\n    int x;\n    ModInt():x(0){}\n    ModInt(long long y):x(y>=0?y%mod:(mod-(-y)%mod)%mod){}\n    ModInt &operator+=(const ModInt &p){\n        if((x+=p.x)>=mod)x-=mod;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &p){\n        if((x+=mod-p.x)>=mod)x-=mod;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &p){\n        x=(int)(1LL*x*p.x%mod);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &p){\n        *this*=p.inverse();\n        return *this;\n    }\n    ModInt operator-()const{return ModInt(-x);}\n    ModInt operator+(const ModInt &p)const{return ModInt(*this)+=p;}\n    ModInt operator-(const ModInt &p)const{return ModInt(*this)-=p;}\n    ModInt operator*(const ModInt &p)const{return ModInt(*this)*=p;}\n    ModInt operator/(const ModInt &p)const{return ModInt(*this)/=p;}\n    bool operator==(const ModInt &p)const{return x==p.x;}\n    bool operator!=(const ModInt &p)const{return x!=p.x;}\n    operator int() const { return x; }                           // added by QCFium\n    ModInt operator=(const int p) {x = p; return ModInt(*this);} // added by QCFium\n    ModInt inverse()const{\n        int a=x,b=mod,u=1,v=0,t;\n        while(b>0){\n            t=a/b;\n            a-=t*b;\n            swap(a,b);\n            u-=t*v;\n            swap(u,v);\n        }\n        return ModInt(u);\n    }\n    friend ostream &operator<<(ostream &os,const ModInt<mod> &p){\n        return os<<p.x;\n    }\n    friend istream &operator>>(istream &is,ModInt<mod> &a){\n        long long x;\n        is>>x;\n        a=ModInt<mod>(x);\n        return (is);\n    }\n};\ntypedef ModInt<MOD> mint;\n\nstruct UnionFind{\n    vi data;\n    UnionFind(int size):data(size,-1){}\n    bool unite(int x,int y) {\n        x=root(x);y=root(y);\n        if(x!=y){\n            if(data[y]<data[x])swap(x,y);\n            data[x]+=data[y];data[y]=x;\n        }\n        return x!=y;\n    }\n    bool find(int x,int y) {\n        return root(x)==root(y);\n    }\n    int root(int x) {\n        return data[x]<0?x:data[x]=root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n    // added by QCFium\n    bool united() {\n        int comroot = -1;\n        FOR(i,data.size()) {\n            if (comroot != -1 && root(i) != comroot) return false;\n            comroot = root(i);\n        }\n        return true;\n    }\n};\n\n/* ---------------------- */\n/* END EXTERNAL LIBRARIES */\n/* ---------------------- */\n\nint mpow(s64 num, s64 times) { // O(log(times))\n    mint next = num%MOD;\n\tmint res = 1;\n\twhile (times) {\n\t\tif (times%2)\n            res *= next;\n\t\tnext *= next;\n\t\ttimes /= 2;\n\t}\n\treturn res;\n}\n\nstruct Comb {\n    vector<vector<s64> > data;\n    Comb(int n) { // O(n^2)\n        data = vector<vector<s64> >(n+1,vector<s64>(n+1,1));\n        UPTO(i,1,n) {\n            FOR(j,i+1) {\n                if (!j || j == i) data[i][j] = 1;\n                else data[i][j] = data[i-1][j-1] + data[i-1][j];\n            }\n        }\n    }\n    \n    s64 ncr(int n, int r) {\n        return data[n][r];\n    }\n};\n\nstruct MComb {\n    vector<mint> fact;\n    vector<mint> inversed;\n    MComb(int n) { // O(n+log(mod))\n        fact = vector<mint>(n+1,1);\n        UPTO(i,1,n) fact[i] = fact[i-1]*mint(i);\n        inversed = vector<mint>(n+1);\n        inversed[n] = mpow(fact[n], MOD-2);\n        DOWN(i,n) inversed[i]=inversed[i+1]*mint(i+1);\n    }\n    \n    int ncr(int n, int r) {\n        return fact[n] * inversed[r] * inversed[n-r];\n    }\n    \n    int npr(int n, int r) {\n        return fact[n] * inversed[n-r];\n    }\n    \n    int nhr(int n, int r) {\n        assert(n+r-1 < (int)fact.size());\n        return ncr(n+r-1, r);\n    }\n};\n\ntemplate<class Key, class Compare = less<Key>, class Allocator = allocator<Key>>\nset<Key> operator+(set<Key>& a, set<Key>& b) {\n    set<Key> c = a;\n    for (auto i : b) \n        c.insert(i);\n    return c;\n}\ntemplate<class Key, class Compare = less<Key>, class Allocator = allocator<Key>>\nset<Key> operator+=(set<Key>& a, set<Key>& b) {\n    for (auto& i : b)\n        a.insert(i);\n    return a;\n}\n\ntemplate<class Key, class Compare = less<Key>, class Allocator = allocator<Key>>\nset<Key> operator*(set<Key>& a, set<Key>& b) {\n    set<Key> c;\n    for (auto& i : a)\n        if (b.count(i)) c.insert(i);\n    return c;\n}\ntemplate<class Key, class Compare = less<Key>, class Allocator = allocator<Key>>\nset<Key> operator*=(set<Key>& a, set<Key>& b) {\n    set<Key> c;\n    for (auto& i : a)\n        if (b.count(i)) c.insert(i);\n        \n    return a = c;\n}\n\ntemplate<class Key, class Compare = less<Key>, class Allocator = allocator<Key>>\nset<Key> operator-(set<Key>& a, set<Key>& b) {\n    set<Key> c;\n    for (auto& i : a)\n        if (!b.count(i)) c.insert(i);\n        \n    return c;\n}\ntemplate<class Key, class Compare = less<Key>, class Allocator = allocator<Key>>\nset<Key> operator-=(set<Key>& a, set<Key>& b) {\n    set<Key> c;\n    for (auto& i : a)\n        if (!b.count(i)) c.insert(i);\n        \n    return a = c;\n}\n\nstatic inline int ri() {\n  int a;\n  scanf(\"%d\", &a);\n  return a;\n}\n\nint int_less(const void *a, const void *b) {\n  return (*((const int*)a) - *((const int*)b));\n}\nint int_greater(const void *a, const void *b) {\n  return (*((const int*)b) - *((const int*)a));\n}\n\nvoid drop(string* a, int h) {\n\tint w = a->size();\n\tstring b[h];\n\tFOR(i,h) b[i] = string(w,'a');\n\tFOR(i,w) {\n\t\tstring new_str;\n\t\tFOR(j,h) if (a[j][i] != '0') new_str.push_back(a[j][i]);\n\t\tint size = new_str.size();\n\t\tnew_str = string(h - size, '0') + new_str;\n\t\tFOR(j,h) a[j][i] = new_str[j];\n\t}\n}\n\nint remove(string* a, int h, int k) {\n\tint w = a->size();\n\tint res = 0;\n\tFOR(i,h) {\n\t\tint pos = 0;\n\t\twhile(pos < w) {\n\t\t\tint start = pos;\n\t\t\tchar start_c = a[i][pos];\n\t\t\twhile(pos < w && a[i][pos] == start_c) pos++;\n\t\t\tif (pos - start >= k && start_c != '0') {\n\t\t\t\tUPTO(j,start,pos-1) a[i][j] = '0';\n\t\t\t\tres += (pos-start)*(start_c - '0');\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint h = ri();\n\tint w = ri();\n\tint k = ri();\n\tstring a[h];\n\tFOR(i,h) cin >> a[i];\n\t\n\tint res = 0;\n\tFOR(i,h) {\n\t\tFOR(j,w) {\n\t\t\tint res_l = 0;\n\t\t\tstring b[h];\n\t\t\tFOR(k,h) b[k] = a[k];\n\t\t\tb[i][j] = '0';\n\t\t\tint turn = 0;\n\t\t\tint times;\n\t\t\twhile(drop(b,h), times = remove(b,h,k)) {\n\t\t\t\t/*\n\t\t\t\tif (i == 3 && j == 2) {\n\t\t\t\t\tcout << \"turn: \" << turn << \"times:\" << times << endl;\n\t\t\t\t\tFOR(i,h) cout << b[i] << endl;\n\t\t\t\t}*/\n\t\t\t\tres_l += mpow(2,turn)*times;\n\t\t\t\tturn++;\n\t\t\t}\n\t\t\t// cout << \"i:\" << i << \" j:\" << j << \" score:\" << res_l << endl;\n\t\t\tres = max(res,res_l);\n\t\t}\n\t}\n\t\n\tcout << res << endl;\n\t\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\n\ntypedef long long ll;\nint H, W, K;\nstring C[30];\n//-----------------------------------------------------------------\nchar CC[30][31];\nll calc(int sx, int sy) {\n\trep(i, 0, H) rep(j, 0, W + 1) CC[i][j] = C[i][j];\n\n\tll ret = 0;\n\tint t = 0;\n\tCC[sy][sx] = '#';\n\tbool ok = true;\n\twhile (ok) {\n\t\tok = false;\n\n\t\t// 落とす\n\t\trep(x, 0, W) {\n\t\t\tvector<char> c;\n\t\t\trep(y, 0, H) {\n\t\t\t\tif (CC[y][x] != '#') {\n\t\t\t\t\tc.push_back(CC[y][x]);\n\t\t\t\t\tCC[y][x] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(c.begin(), c.end());\n\t\t\trep(y, 0, c.size()) CC[H - 1 - y][x] = c[y];\n\t\t}\n\n\t\t// 消す\n\t\trep(y, 0, H) {\n\t\t\tchar pre = CC[y][0];\n\t\t\tint prei = 0;\n\t\t\trep(x, 1, W + 1) {\n\t\t\t\tif (pre != CC[y][x]) {\n\t\t\t\t\tint d = x - prei;\n\t\t\t\t\tif (K <= d && pre != '#') {\n\t\t\t\t\t\tret += (pre - '0') * (x - prei) * (1 << t);\n\t\t\t\t\t\t//cout << (pre - '0') * (x - prei) * (1 << t) << endl;\n\t\t\t\t\t\trep(xx, prei, x) CC[y][xx] = '#';\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t}\n\t\t\t\t\tpre = CC[y][x];\n\t\t\t\t\tprei = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tt++;\n\t}\n\n\t/*rep(i, 0, H) {\n\t\trep(j, 0, W + 1) cout << CC[i][j];\n\t\tcout << endl;\n\t}*/\n\n\treturn ret;\n}\n//-----------------------------------------------------------------\nint main() {\n\tcin >> H >> W >> K;\n\trep(i, 0, H) cin >> C[i];\n\trep(i, 0, H) C[i] = C[i] + \"@\";\n\n\tll ans = 0;\n\trep(sy, 0, H)\n\trep(sx, 0, W) ans = max(ans, calc(sx, sy));\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fs first\n#define sc second\n#define pb emplace_back\n#define mp make_pair\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n\nconst int32_t inf = 1001001001;\nconst int64_t infll = 1001001001001001001ll;\nconst int dx[] = {0, -1, 1, 0, -1, 1, -1, 1}, dy[] = {-1, 0, 0, 1, -1, -1, 1, 1};\n\ntemplate <typename T> using vector2d = vector<vector<T>>;\n\n// clang-format off\ntemplate <typename T> void sort(vector<T> &v) { sort(all(v)); }\n// ostream &operator<<(ostream &os, __int128_t value) { if (ostream::sentry(os)) { __uint128_t tmp = value < 0 ? -value : value; char buffer[64]; char *d = end(buffer); do { --d; *d = \"0123456789\"[tmp % 10]; tmp /= 10; } while (tmp != 0); if (value < 0) { --d; *d = '-'; } int len = end(buffer) - d; if (os.rdbuf()->sputn(d, len) != len) { os.setstate(ios_base::badbit); }} return os; }\n// istream &operator>>(istream &is, __int128_t &value) { string in; is >> in; value = 0; for (const char &c : in) { if ('0' <= c && c <= '9') value = 10 * value + (c - '0'); } if (in[0] == '-') value *= -1; return is; }\n// ostream &operator<<(ostream &os, __uint128_t value) { if (ostream::sentry(os)) { char buffer[64]; char *d = end(buffer); do { --d; *d = \"0123456789\"[value % 10]; value /= 10; } while (value != 0); int len = end(buffer) - d; if (os.rdbuf()->sputn(d, len) != len) { os.setstate(ios_base::badbit); }} return os; }\n// istream &operator>>(istream &is, __uint128_t &value) { string in; is >> in; value = 0; for (const char &c : in) { if ('0' <= c && c <= '9') value = 10 * value + (c - '0'); } return is; }\ntemplate <typename T> ostream &operator<<(ostream &os, vector<T> &v) { os << v[0]; for (int i = 1; i < v.size(); ++i) os << \" \" << v[i]; return os; }\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &in : v) is >> in; return is; }\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p) { os << p.fs << \" \" << p.sc; return os; }\ntemplate <typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.fs >> p.sc; return is; }\n\n// struct IoSetup { IoSetup(){ cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10); cerr << fixed << setprecision(10); } } iosetup;\n\ninline int64_t in() { int64_t x = 0; cin >> x; return x; }\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n// clang-format on\n\nsigned main(int argc, char *argv[]) {\n  int h = in(), w = in(), k = in();\n  vector2d<int> c(h, vector<int>(w));\n  for (int i = h - 1; i >= 0; --i) {\n    for (int j = 0; j < w; ++j) {\n      scanf(\"%1d\", &c[i][j]);\n    }\n  }\n\n  int64_t ans = 0;\n  // kimeuchi\n  for (int y = 0; y < h; ++y) {\n    for (int x = 0; x < w; ++x) {\n      int score = 0;\n      vector2d<int> C = c;\n      C[y][x] = -1;\n\n      // cerr << \"begin (\" << x << \", \" << y << \")\" << endl;\n      for (int co = 1;; co *= 2) {\n\n        // fall\n        // cerr << \"fall start\" << endl;\n        // for (int i = h - 1; i >= 0; --i) {\n        //   for (int j = 0; j < w; ++j) {\n        //     printf(\"%2d \", C[i][j]);\n        //   }\n        //   puts(\"\");\n        // }\n        // puts(\"\");\n        for (int j = 0; j < w; ++j) {\n          int now = 0;\n          for (int i = 0; i < h; ++i) {\n            if (C[i][j] != -1) {\n              C[now][j] = C[i][j];\n              now++;\n            }\n          }\n          for (int i = now; i < h; ++i) {\n            C[i][j] = -1;\n          }\n        }\n        // cerr << \"fall end\" << endl;\n        //\n        // for (int i = h - 1; i >= 0; --i) {\n        //   for (int j = 0; j < w; ++j) {\n        //     printf(\"%2d \", C[i][j]);\n        //   }\n        //   puts(\"\");\n        // }\n        // puts(\"\");\n\n        // erase\n        // cerr << \"erase start\" << endl;\n        int sum = 0;\n        for (int i = 0; i < h; ++i) {\n          for (int j = 0; j < w; ++j) {\n            if (C[i][j] == -1) continue;\n\n            int cnt = 0;\n            for (int l = j; l < w; ++l) {\n              if (C[i][j] != C[i][l]) break;\n              cnt++;\n            }\n\n            if (cnt >= k) {\n              for (int l = 0; l < cnt; ++l) {\n                sum += C[i][l + j];\n                C[i][l + j] = -1;\n              }\n            }\n          }\n        }\n\n        // cerr << \"erase end\" << endl;\n        //\n        // cerr << \"sum = \" << sum << endl;\n        // for (int i = h - 1; i >= 0; --i) {\n        //   for (int j = 0; j < w; ++j) {\n        //     printf(\"%2d \", C[i][j]);\n        //   }\n        //   puts(\"\");\n        // }\n        // puts(\"\");\n\n        score += co * sum;\n        if (sum == 0) break;\n      }\n\n      // printf(\"(%d, %d) = %d\\n\", x, y, score);\n      chmax(ans, score);\n    }\n  }\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\n#define repr(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define invrepr(i,a,b) for(int i=b-1;i>=a;i--)\n#define invrep(i,n) invrepr(i,0,n)\n#define repitr(itr,a) for(auto itr=a.begin();itr!=a.end();++itr)\n#define P pair<int,int>\nconst int MOD=1e9+7;\nconst int INF=2e9;\n\n\nll binary_power(ll a, ll n) {\n    if (n==0) return 1;\n    ll k=binary_power(a,n/2);\n    if (n%2==0) return (k*k)%MOD;\n    else return (((k*k)%MOD)*a)%MOD;\n}\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n\n    int h,w,k;\n    cin >> h >> w >> k;\n    vector<vector<ll>> v(h,vector<ll>(w+1));\n    rep(i,h) {\n        ll s;\n        cin >> s;\n        invrep(j,w) {\n            v[i][j]=s%10;\n            s/=10;\n        }\n    }\n    ll ans=0;\n    rep(a,h) {\n        rep(b,w) {\n            vector<vector<ll>> t(h,vector<ll>(w+1));\n            copy(v.begin(),v.end(),t.begin());\n            invrep(c,a) t[c+1][b]=t[c][b];\n            t[0][b]=0;\n            ll tans=0,dans=1,itr=0;\n            while (dans>0) {\n                dans=0;\n                rep(i,h) {\n                    int cnt=1;\n                    rep(j,w) {\n                        if (t[i][j+1]==t[i][j]) ++cnt;\n                        else {\n                            if (cnt>=k) {\n                                dans+=cnt*t[i][j]*binary_power(2,itr);\n                                rep(k,cnt) t[i][j-k]=0;\n                            }\n                            cnt=1;\n                        }\n                    }\n                }\n                rep(j,w) {\n                    vector<ll> a;\n                    rep(i,h) {\n                        if (t[i][j]!=0) a.push_back(t[i][j]);\n                    }\n                    rep(i,h-a.size()) t[i][j]=0;\n                    rep(i,a.size()) t[i+h-a.size()][j]=a[i];\n                }\n                ++itr;\n                tans+=dans;\n            }\n            ans=max(ans,tans);\n        }\n    }\n    \n    cout << ans << endl;\n    \n    return 0;   \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n#define repv(t,it,v) for(vector<t>::iterator it = v.begin() ; it != v.end() ; ++it)\n\nint H,W,K;\nint a[66][33];\nint b[33];\nint ans;\n\nint main(){\n\tscanf(\"%d%d%d\" , &H , &W , &K);\n\trepm(i,H,0){\n\t\trepp(j,0,W){\n\t\t\tchar c;\n\t\t\tscanf(\" %c\" , &c);\n\t\t\ta[i][j] = c - '0';\n\t\t}\n\t}\n\trepm(z1,H,0){\n\trepp(z2,0,W){\n\t\tint p = 0;\n\t\tint q = 1;\n\t\tint f = 1;\n\t\ta[z1][z2] *= -1;\n\t\twhile(q > 0){\n\t\t\tq = 0;\n\t\t\tfill(b,b+W,0);\n\t\t\trepp(i,0,H){\n\t\t\t\tint x = 0;\n\t\t\t\tint y = 0;\n\t\t\t\trepp(j,0,W){\n\t\t\t\t\t++b[j];\n\t\t\t\t\twhile(a[b[j]][j] < 0) ++b[j];\n\t\t\t\t\tif(x != a[b[j]][j]){\n\t\t\t\t\t\tif(x > 0 && j - y >= K){\n\t\t\t\t\t\t\tq += x * (j - y);\n\t\t\t\t\t\t\trepp(e,y,j){\n\t\t\t\t\t\t\t\ta[b[e]][e] *= -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx = a[b[j]][j];\n\t\t\t\t\t\ty = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(x > 0 && W - y >= K){\n\t\t\t\t\tq += x * (W - y);\n\t\t\t\t\trepp(e,y,W){\n\t\t\t\t\t\ta[b[e]][e] *= -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp += f * q;\n\t\t\tf *= 2;\n\t\t}\n\t\trepm(i,H,0){\n\t\t\trepp(j,0,W){\n\t\t\t\ta[i][j] = abs(a[i][j]);\n\t\t\t}\n\t\t}\n\t\tans = max(ans , p);\n\t}\n\t}\n\tprintf(\"%d\\n\" , ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long H, W, K;\n\nint erase(vector<vector<int> > ban, int y, int x){\n\n\tint ret = 0;\n\n\t//first erase\n\tban[y][x] = 0;\n\n\n\n\n\tint chain = 0;\n\twhile(true){\n\n\t\t//drop to ground\n\t\tfor(int xpos = 0; xpos < W; xpos++){\n\t\t\twhile(true){\n\t\t\t\tbool update = false;\n\t\t\t\tint erasepos = -1;\n\t\t\t\tfor(int ypos = H-1; ypos >= 0; ypos--){\n\t\t\t\t\tif(ban[ypos][xpos] == 0){\n\t\t\t\t\t\terasepos = ypos;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(erasepos == -1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int ypos = erasepos - 1; ypos >= 0; ypos--){\n\t\t\t\t\tif(ban[ypos][xpos] != 0){\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\tswap(ban[ypos][xpos], ban[erasepos][xpos]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(update == false){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\n\t\tbool update = false;\n\n\t\t//erase\n\t\tfor(int ypos = 0; ypos < H; ypos++){\n\t\t\tfor(int xpos = 0; xpos < W; xpos++){\n\t\t\t\tif(ban[ypos][xpos] == 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint sum = 0;\n\t\t\t\tint xend;\n\t\t\t\tfor(int xx = xpos; xx < W; xx++){\n\t\t\t\t\tif(ban[ypos][xpos] == ban[ypos][xx]){\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t\txend = xx;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(sum >= K){\n\t\t\t\t\tupdate = true;\n\t\t\t\t\tret += pow(2, chain) * sum * ban[ypos][xpos];\n\t\t\t\t\tfor(int xx = xpos; xx <= xend; xx++){\n\t\t\t\t\t\tban[ypos][xx] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tif(update == false){\n\t\t\tbreak;\n\t\t}\n\t\tchain++;\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\tcin >> H >> W >> K;\n\tvector<vector<int> > ban;\n\tfor(int i = 0; i < H; i++){\n\t\tvector<int> tmp;\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tint t;\n\t\t\tscanf(\"%1d\", &t);\n\t\t\ttmp.push_back(t);\n\t\t}\n\t\tban.push_back(tmp);\n\t}\n\n\n\tint maxi = 0;\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tmaxi = max(maxi, erase(ban, i, j));\n\t\t}\n\t}\n\n\tcout << maxi << endl;\n\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n    Problem 93\n    https://atcoder.jp/contests/s8pc-3/tasks/s8pc_3_b\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n/* typedef */\ntypedef long long ll;\ntypedef pair<int, int> pii;\n/* class */\nclass pazzle {\n    public:\n    int H, W, K;\n    int ans = 0;\n    vector<vector<int> > v;\n    pazzle (int H, int W, int K, vector<vector<int> > v)\n    : H(H), W(W), K(K), v(v) {}\n    bool del() {\n        int ret = false;\n        for (int i = 0; i < H; i++) {\n            int r = 0;\n            for (int l = 0; l < W; l++) {\n                int tmp = v[i][r];\n                while (v[i][r] == -1) {\n                    r++;\n                    l++;\n                }\n                while (v[i][r] == v[i][r + 1]){\n                    r++;\n                    tmp += v[i][r];\n                }\n                if (r - l + 1>= K) {\n                    for (int k = l; k <= r; k++) v[i][k] = -1;\n                    ans += tmp;\n                    ret = true;\n                }\n                l = r;\n                r++;\n            }\n        }\n        return ret;\n    }\n    void move() {\n        for (int i = 0; i < W; i++) {\n            for (int j = H - 1; j > 0; j--) {\n                if (v[j][i] == -1) {\n                    int k = j - 1;\n                    while (v[k][i] == -1 && k > 0) k--;\n                    if (v[k][i] != -1) swap(v[k][i], v[j][i]);\n                }\n            }\n        }\n    }\n    void printPoint() {\n        cout << ans << '\\n';\n    }\n    int gameStart() {\n        int ret = 0;\n        move();\n        for (int i = 0; del(); i++){\n            move();\n            ret += pow(2, i) * ans;\n            ans = 0;\n        }\n        return ret;\n    }\n};\n/* constant */\n/* global variables */\n/* function */\n/* main */\nint main(){\n    int H, W, K;\n    cin >> H >> W >> K;\n    vector<string> vs(H);\n    for (int i = 0; i < H; i++) cin >> vs[i];\n    vector<vector<int> > v(H, vector<int> (W + 1, -2));\n    for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) v[i][j] = vs[i][j] - '0';\n    int ans = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int tmp = v[i][j];\n            v[i][j] = -1;\n            pazzle P = pazzle(H, W, K, v);\n            ans = max(ans, P.gameStart());\n            v[i][j] = tmp;\n        }\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\nconst int H = 30;\nstring s[H];\nint h, w, k;\n\nconst int DEBUG = 0;\n\nll calc(int DEBUG) {\n  string t[H];\n  REP(i, 0, h) {\n    t[i] = s[i];\n  }\n  ll sum = 0;\n  int turn = 0;\n  while (1) {\n    // fall\n    bool fell = 0;\n    REP(i, 0, w) {\n      int pos = h - 1;\n      for (int j = h - 1; j >= 0; --j) {\n\tif (t[j][i] != '.') {\n\t  if (pos != j) {\n\t    swap(t[pos][i], t[j][i]);\n\t    fell = 1;\n\t  }\n\t  pos--;\n\t}\n      }\n    }\n    if (DEBUG) {\n      cout << \"turn \" << turn << endl;\n      REP(i, 0, h) {\n\tcout << t[i] << endl;\n      }\n    }\n    if (not fell) {\n      break;\n    }\n    // perish\n    REP(i, 0, h) {\n      int cnt = 0;\n      REP(j, 0, w + 1) {\n\tif ((j > 0 && j < w && t[i][j] == t[i][j - 1])) {\n\t  cnt++;\n\t} else {\n\t  if (cnt >= k) {\n\t    //perish\n\t    ll sc = t[i][j - 1] - '0';\n\t    if (t[i][j - 1] == '.') {\n\t      sc = 0;\n\t    }\n\t    sc = sc << turn;\n\t    sum += sc * cnt;\n\t    REP(l, 0, cnt) {\n\t      t[i][j - cnt + l] = '.';\n\t    }\n\t  }\n\t  cnt = 0;\n\t  if (j < w) {\n\t    cnt++;\n\t  }\n\t}\n      }\n    }\n    turn++;\n  }\n  return sum;\n}\n\nint main(void){\n  cin >> h >> w >> k;\n  REP(i, 0, h) {\n    cin >> s[i];\n  }\n\n  ll ma = 0;\n  REP(i, 0, h) {\n    REP(j, 0, w) {\n      char tmp = s[i][j];\n      s[i][j] = '.';\n      ma = max(ma, calc(i == 3 && j == 2 && DEBUG));\n      s[i][j] = tmp;\n    }\n  }\n  cout << ma << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for(int i=0; i < (int)(n); i++)\nusing namespace std;\n\ntypedef long long ll;\n// #define DEBUG\n\nint H, W, K;\nvector<vector<int>> original;\nvector<vector<int>> board;\n\nstruct EraseResult{\n    set<int> erased;\n    ll score;\n};\n\nvoid drop(set<int>& erased){\n    #ifdef DEBUG\n    printf(\"drop\\n\");\n    #endif\n    for(auto col: erased){\n        // col列目を落とす\n\n        int seeker = H - 1;\n        // bottomは下から順につめていく。seekerは非空ブロックをさがしにいく.\n        for(int bottom = H-1; bottom >= 0; bottom--){\n            // seekerをうえにあげてブロックをさがす\n            while(seeker >= 0 && board[seeker][col] == 0){\n                seeker--;\n            }\n\n            if(seeker < 0){\n                // みつからなかったその列はおわり   \n                break;\n            }\n\n            // ブロックをみつけたらそれはけしてbottomのところにうつす\n            board[bottom][col] = board[seeker][col];\n            board[seeker][col] = 0;\n        }\n    }\n}\n\nEraseResult tryEraseRow(int i, int j){\n    if(board[i][j] == 0){\n        return EraseResult{set<int>(), 0};\n    }\n    #ifdef DEBUG\n    printf(\"tryEraseRow(%d, %d) %d\\n\", i, j, board[i][j]);\n    #endif\n\n    int left = j;\n    while(left - 1 >= 0 && board[i][left-1] == board[i][j]){\n        left--;\n    }\n\n    int right = j;\n    while(right + 1 < W && board[i][right+1] == board[i][j]){\n        right++;\n    }\n\n    int len = right - left + 1;\n    if(len >= K){\n        ll res = board[i][j]*len;\n        // けす\n        set<int> erased;\n        for(int ind=left; ind <= right; ind++){\n            board[i][ind] = 0;\n            erased.insert(ind);\n        }\n        #ifdef DEBUG\n        printf(\"Earned %d\\n\", res);\n        #endif\n        return EraseResult{erased, res};\n\n    }else{\n        // けせない\n        return EraseResult{set<int>(), 0};\n    }\n}\n\nEraseResult eraseAndEarn(set<int>& dropped){\n    #ifdef DEBUG\n    printf(\"eraseAndEarn\\n\");\n    #endif\n    ll score = 0;\n    set<int> erased;\n    for(auto col: dropped){\n        for(int i=0; i < H; i++){\n            auto res = tryEraseRow(i, col);\n            if(res.score > 0){\n                // けせて\n                score += res.score;\n                for(auto iter: res.erased){\n                    erased.insert(iter);\n                }\n            }\n        }\n    }\n\n    return EraseResult{erased, score};\n}\n\n\n\n\nll simulate(int i, int j){\n    // ボードをコピー\n    board = original;\n\n    // 穴をあける\n    board[i][j] = 0;\n\n    // 効率化のためにどの列を落としたか/けしたかをおぼえておく\n    set<int> dropped;\n    set<int> erased;\n    erased.insert(j);\n\n    // 落とす→けして点を得るを繰替えす。\n    ll res = 0;\n    ll mag = 1;  // 点の倍率\n    while(true){\n        drop(erased);\n\n        // 前回けしたところしか落ちてないのでそこだけしらべれば十分\n        auto erase_res = eraseAndEarn(erased);\n        ll local_score = erase_res.score;\n        if(local_score == 0){\n            break;\n        }\n        erased = erase_res.erased;\n        res += local_score*mag;\n\n        mag *= 2;\n    }\n\n    return res;\n}\n\nint main(){\n    cin >> H >> W >> K;\n\n    original = vector<vector<int>>(H, vector<int>(W, 0));\n    for(int i=0; i < H; i++){\n        for(int j=0; j < W; j++){\n            while(true){\n                char temp;\n                cin >> temp;\n                if('0' <= temp && temp <= '9'){\n                    original[i][j] = temp - '0';\n                    break;\n                }else{\n                    continue;\n                }\n            }\n        }\n    }\n\n    ll res = 0;\n    for(int i=0; i < H; i++){\n        for(int j=0; j < W; j++){\n            res = max(res, simulate(i, j));\n        }\n    }\n    \n    cout << res << endl;\n\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint h,w,k;\nstring str;\nint fie[31][31];\nint tmp[31][31];\nint cnt[31][31];\n\nvoid fall(){\n\tmemset(cnt,0,sizeof(cnt));\n\tfor(int i=0;i<w;i++){\n\t\tfor(int j=h-1;j>=0;j--){\n\t\t\tcnt[j][i]=cnt[j+1][i];\n\t\t\tif(tmp[j][i]==0){\n\t\t\t\tcnt[j][i]++;\n\t\t\t}\n\t\t}\n\t\tfor(int j=h-1;j>=0;j--){\n\t\t\tif(tmp[j][i]!=0 && cnt[j][i]!=0){\n\t\t\t\ttmp[j+cnt[j][i]][i]=tmp[j][i];\n\t\t\t\ttmp[j][i]=0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint rensa(int v){\n\tbool flag=false;\n\tint ans=0;\n\t/*\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tprintf(\"%d\",tmp[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n\t*/\n\tfor(int i=0;i<h;i++){\n\t\tint cnt=0;\n\t\tfor(int j=1;j<w;j++){\n\t\t\tif(tmp[i][j]==tmp[i][j-1] && tmp[i][j]!=0){\n\t\t\t\tcnt++;\n\t\t\t}else{\n\t\t\t\tif(cnt+1>=k){\n\t\t\t\t\tflag=true;\n\t\t\t\t\tfor(int k=j-1;k>=j-1-cnt;k--){\n\t\t\t\t\t\tans+=tmp[i][k];\n\t\t\t\t\t\ttmp[i][k]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcnt=0;\n\t\t\t}\n\t\t}\n\t\tif(cnt+1>=k){\n\t\t\tflag=true;\n\t\t\tfor(int k=w-1;k>=w-1-cnt;k--){\n\t\t\t\tans+=tmp[i][k];\n\t\t\t\ttmp[i][k]=0;\n\t\t\t}\n\t\t}\n\t}\n\tif(!flag || ans==0)return ans;\n\tfall();\n\treturn rensa(v*2)+v*ans;\n}\n\nint calc(int x,int y){\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\ttmp[i][j]=fie[i][j];\n\t\t}\n\t}\n\ttmp[y][x]=0;\n\tfall();\n\t//printf(\"go!\\n\");\n\treturn rensa(1);\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&h,&w,&k);\n\tfor(int i=0;i<h;i++){\n\t\tcin >> str;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tfie[i][j]=(str[j]-'0');\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tans=max(ans,calc(j,i));\n\t\t\t//printf(\"%d\\n\",ans);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\n#define F first\n#define S second\n\nconst int mx=200010;\nconst ll mod=1e9+7;\n\n\nint main() {\n  int h,w,k;\n  cin >> h >> w >> k;\n  vector<vector<int>> data(30, vector<int>(30,0));\n  rep(i,h)rep(j,w) cin >> data[i][j];\n\n  ll ans=0;\n  rep(x,h)rep(y,w){\n    auto c = data;\n    c[x][y] = 0;\n    ll base = 0, res = 0;\n    while(1){\n      ll tmp = 0;\n      rep(i,h){\n        int st=0;\n        rep(j,w+1){\n          if(j==w || (j>0 && c[i][j-1]!=c[i][j])){\n            if(j-st>=k){ for(int p=st; p<j; p++){ tmp+=c[i][p]; c[i][p]=0; } }\n            st = j;\n          }\n        }\n      }\n      if(base!=0 && tmp==0) break;\n      res += base*tmp;\n      base = (base>0?base*2:1);\n\n      rep(j,w){\n        int pos = h-1;\n        for(int i=h-1; i>=0; i--){\n          if(c[i][j]!=0){\n            c[pos][j] = c[i][j];\n            if(pos!=i) c[i][j] = 0;\n            pos--;\n          }\n        }\n      }\n    }\n    ans = max(ans, res);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint f(vector<vector<int>> &A, int K, int si, int sj) {\n    int H = A.size(), W = A[0].size();\n    int ans = 0;\n    A[si][sj] = 0;\n    int t = 1;\n    for (;;) {\n        for (int j = 0; j < W; j++) {\n            int cnt = 0;\n            for (int i = H - 1; i >= 0; i--) {\n                if (A[i][j] == 0) cnt++;\n                else if (cnt) A[i + cnt][j] = A[i][j], A[i][j] = 0;\n            }\n        }\n        int del = 0;\n        for (int i = H - 1; i >= 0; i--) {\n            for (int j = 0; j < W - 1; j++) {\n                int t = j;\n                while (A[i][j] != 0 && t + 1 < W && A[i][t] == A[i][t + 1]) {\n                    t++;\n                }\n                if (t - j + 1 >= K) {\n                    del += A[i][j] * (t - j + 1);\n                    for (int k = j; k <= t; k++) A[i][k] = 0;\n                    j = t;\n                }\n            }\n        }\n        if (del == 0) break;\n        ans += t * del;\n        t *= 2;\n    }\n    return ans;\n}\nint main() {\n    cin.tie(nullptr); ios::sync_with_stdio(false);\n    int H, W, K; cin >> H >> W >> K;\n    vector<vector<int>> A(H, vector<int>(W));\n    for (auto &row : A) for (auto &a : row) { char c; cin >> c; a = c - '0'; }\n    int ans = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            auto B = A;\n            int s = f(B, K, i, j);\n            ans = max(ans, s);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n\nint H, W, K;\n\nvoid fall(vector<vector<ll>> &c) {\n    rep(i,W) rep(j,H) {\n        if (c[i][j] == 0) {\n            for (int k = 1; k + j < H; ++k) {\n                if (c[i][k+j] != 0) {\n                    for (int l = j; l < H; ++l) {\n                        if (l + k < H) c[i][l] = c[i][l+k];\n                        else c[i][l] = 0;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n}\n\nvoid sum(ll &ans, ll delete_cnt, vector<vector<ll>> &c) {\n    rep(i,H) {\n        ll left = 0;\n        rep(j,W) {\n            if (c[j+1][i] != 0 && c[j+1][i] == c[j][i]) continue;\n            if (c[j+1][i] != c[j][i]) {\n                if (j - left + 1 > 1) {\n                    ans += (1LL<<delete_cnt) * (j - left + 1) * c[j][i];\n                    for (int k = left; k <= j; ++k) c[k][i] = 0;\n                }\n            }\n            left = j + 1;\n        }\n    }\n}\n\n\n\nll calc_ans(int x, int y, vector<vector<ll>> c) {\n    ll res = 0;\n    ll pre_ans = -1;\n    ll delete_cnt = 0;\n\n    c[x][y] = 0;\n    fall(c);\n    while (res != pre_ans) {\n        pre_ans = res;\n        sum(res, delete_cnt, c);\n        fall(c);\n        ++delete_cnt;\n    }\n    return res;\n}\n\n\nint main() {\n    cin >> H >> W >> K;\n    vector<vector<ll>> c(W+1, vector<ll>(H));\n    rep(i,H) {\n        string S;\n        cin >> S;\n        rep(j,W) c[j][H-1-i] = S[j] - '0';\n    }\n\n    ll ans = 0;\n\n    rep(i,W) rep(j,H) {\n        if (i == 0) continue;\n        ans = max(ans, calc_ans(i, j, c));\n    }\n    \n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pull = pair<ull, ll>;\nusing pis = pair<int, string>;\n#define INF 1000000000\n#define LLINF 10000000000000000ll\n#define MOD 1000000007LL\n\nvoid copy_field(vector<vector<int>> &field, vector<vector<int>> &original) {\n  for (int i = 0; i < field.size(); i++) for (int j = 0; j < field[0].size(); j++) field[i][j] = original[i][j];\n  return;\n}\n\nbool check(vector<vector<int>> &field, vector<vector<int>> &checkfield, int k) {\n  int h = field.size(), w = field[0].size();\n  bool flag = false;\n  for (int i = 0; i < h; i++) {\n    if (k == 1) {\n      for (int j = 0; j < w; j++) {\n        if (field[i][j] != 0) {\n          checkfield[i][j] = 1;\n          flag = true;\n        }\n      }\n      continue;\n    }\n    int before = field[i][0], cnt = 1;\n    for (int j = 1; j < w; j++) {\n      if ((before != 0) && (before == field[i][j])) {\n        cnt++;\n        if (cnt >= k) {\n          checkfield[i][j] = 1;\n          flag = true;\n        }\n      }\n      else {\n        cnt = 1;\n        before = field[i][j];\n      }\n    }\n    //cout << \"fin\" << endl;\n    for (int j = w-1; j >= k-1; j--) {\n      if ((checkfield[i][j] == 1) && (checkfield[i][j-1] == 0)) {\n        for (int l = 0; l < k-1; l++) {\n          j--;\n          checkfield[i][j] = 1;\n        }\n      }\n    }\n  }\n  //cout << \"all-fin\" << endl;\n  return flag;\n}\n\nvoid init_checkfield(vector<vector<int>> &checkfield) {\n  for (int i = 0; i < checkfield.size(); i++) for (int j = 0; j < checkfield[0].size(); j++) checkfield[i][j] = 0;\n  return;\n}\n\nvoid init_field(vector<vector<int>> &field, int erase) {\n  int w = field[0].size();\n  for (int i = erase/w; i > 0; i--) {\n    field[i][erase%w] = field[i-1][erase%w];\n  }\n  field[0][erase%w] = 0;\n}\n\nvoid printfield(vector<vector<int>>&field) {\n  for (int i = 0; i < field.size(); i++) {\n    for (int j = 0; j < field[0].size(); j++) {\n      cout << field[i][j] << \" \";\n    }cout << endl;\n  }cout << endl;\n  return;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int h,w, k;\n  cin >> h >> w >> k;\n  vector<vector<int>> field(h, vector<int>(w)), original(h, vector<int>(w)), checkfield(h, vector<int>(w));\n  //for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) cin >> original[i][j];\n  for (int i = 0; i < h; i++) {\n    string s;\n    cin >> s;\n    for (int j = 0; j < w; j++) {\n      original[i][j] = (int)(s[j] - '0');\n    }\n  }\n\n  int ans = -1;\n  for (int erase = 0; erase < h*w; erase++) {\n    copy_field(field, original);\n    init_checkfield(checkfield);\n    //field[erase/h][erase%h] = 0;\n    init_field(field, erase);\n    int db = 1;\n    int temp = 0;\n    while(check(field, checkfield, k)) {\n      //cout << \"check\" << erase << endl;\n      //printfield(checkfield);\n      \n      for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n          if (checkfield[i][j] == 1) {\n            temp += db * field[i][j];\n            field[i][j] = 0;\n          }\n        }\n      }\n      \n      for (int i = h-2; i >= 0; i--) for (int j = 0; j < w; j++) checkfield[i][j] += checkfield[i+1][j];\n\n      for (int i = h-1; i >= 0; i--) {\n        for (int j = 0; j < w; j++) {\n          if ((field[i][j] == 0) || (checkfield[i][j] == 0)) continue;\n          if (i + checkfield[i][j] < h) {\n            field[i+checkfield[i][j]][j] = field[i][j];\n            field[i][j] = 0;\n          }\n          else field[i][j] = 0;\n        }\n      }\n      db *= 2;\n      init_checkfield(checkfield);\n      //cout << \"fin\" << endl;\n    }\n    //cout << temp << endl;\n    ans = max(ans, temp);\n  }\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing piii = pair<int, pair<int, int>>;\nusing pll = pair<ll, ll>;\nusing pli = pair<ll, int>;\ntemplate <typename T>\nusing Graph = vector<vector<T>>;\nconst int MOD = 1e9 + 7;\n\nint H, W, K;\n\nint erase(vector<vector<int>> &board) {\n    int cnt = 0;\n    for (int i = 0; i < H; ++i) {\n        for (int l = 0; l < W; ++l) {\n            int r = l;\n            while (r < W && board[i][l] && board[i][l] == board[i][r])\n                r++;\n            if (r - l >= K) {\n                cnt += (r - l) * board[i][l];\n                for (int j = l; j < r; ++j)\n                    board[i][j] = 0;\n            }\n        }\n    }\n    return cnt;\n}\n\nvoid fall(vector<vector<int>> &board) {\n    for (int i = 0; i < W; ++i) {\n        while (true) {\n            bool isswaped = false;\n            for (int j = 0; j < H - 1; ++j) {\n                if (!board[j][i] && board[j + 1][i]) {\n                    swap(board[j][i], board[j + 1][i]);\n                    isswaped = true;\n                }\n            }\n            if (!isswaped)\n                break;\n        }\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> H >> W >> K;\n    vector<vector<int>> board(H, vector<int>(W));\n    for (int i = H - 1; i >= 0; --i) {\n        for (int j = 0; j < W; ++j) {\n            char c;\n            cin >> c;\n            board[i][j] = c - '0';\n        }\n    }\n\n    int ans = 0;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            auto cboard = board;\n            cboard[i][j] = 0;\n            fall(cboard);\n            int point = 0, cnt = 0, turn = 0;\n            while ((cnt = erase(cboard)) > 0) {\n                point += cnt * (1 << turn);\n                fall(cboard);\n                turn++;\n            }\n            ans = max(ans, point);\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n#define int long long\nint h, w, k;\nchar c[50][50], cp[50][50];\nvoid copy() {\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tcp[i][j] = c[i][j];\n\t\t}\n\t}\n\treturn;\n}\nbool drop() {\n\tbool r = 0, r1 = 0;\n\tdo {\n\t\tr1 = 0;\n\t\tfor (int i = h - 1; i > 0; i--) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (cp[i][j] == '.') {\n\t\t\t\t\tcp[i][j] = cp[i - 1][j];\n\t\t\t\t\tcp[i - 1][j] = '.';\n\t\t\t\t\tif (cp[i][j] != '.') { r = 1; r1 = 1; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while (r1);\n\treturn r;\n}\nint chain() {\n\tint r = 0;\n\tfor (int i = 0; i < h; i++) {\n\t\tint l = 0;\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (j&&cp[i][j] == cp[i][j - 1])l++;\n\t\t\telse {\n\t\t\t\tif (l >= k && cp[i][j - 1] != '.') {\n\t\t\t\t\tfor (int p = 0; p < l; p++) {\n\t\t\t\t\t\tr += cp[i][j - 1 - p] - '0';\n\t\t\t\t\t\tcp[i][j - 1 - p] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tl = 1;\n\t\t\t}\n\t\t}\n\t\tif (l >= k && cp[i][w - 1] != '.') {\n\t\t\tfor (int p = 0; p < l; p++) {\n\t\t\t\tr += cp[i][w - 1 - p] - '0';\n\t\t\t\tcp[i][w - 1 - p] = '.';\n\t\t\t}\n\t\t}\n\t\tl = 1;\n\t}\n\treturn r;\n}\nsigned main() {\n\tcin >> h >> w >> k;\n\tint ans = 0;\n\tfor (int i = 0; i < h; i++)for (int j = 0; j < w; j++)cin >> c[i][j];\n\tfor (int i = 1; i < h; i++)for (int j = 0; j < w; j++) {\n\t\tcopy();\n\t\tcp[i][j] = '.';\n\t\tint p = 1, sum = 0;\n\t\tbool b = 1;\n\t\tdo {\n\t\t\tb = drop();\n\t\t\tsum += chain()*p;\n\t\t\tp *= 2;\n\t\t} while (b);\n\t\tans = max(ans, sum);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\n#define IINF 10e8\n#define INF 1<<30\n#define MOD 1000000007\n#define mod 1000000007\n#define rep(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define Endl endl\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define siz(x) (ll)(x).size()\n#define PI acos(-1.0)\nusing namespace std;\n//using Int=int_fast64_t;\ntypedef long long int ll;\ntypedef long long int LL;\ntypedef pair<ll,ll>Pll;\ntypedef pair<int,int>Pin;\ntemplate<class T> using V=vector<T>;\nlong long GCD(long long a, long long b) { return b ? GCD(b, a%b) : a; }\nlong long LCM(long long a, long long b)  {return a/GCD(a,b)*b;}\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\nint ddx[8]={-1,0,1,0,1,1,-1,-1};\nint ddy[8]={0,-1,0,1,1,-1,1,-1};\nchar dir[4]={'u','l','d','r'};\nll cmp(pair<ll,ll>a,pair<ll,ll> b){\n        if(a.se!=b.se)\n        return a.se<b.se;\n        else\n        return a.fi<b.fi;\n}\n//---------------------------------------------------------------------------\nll modpow(ll a, ll n) {//a^n(MOD)を求める\n    ll res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % MOD;\n        a = a * a % MOD;//次の準備\n        n >>= 1;\n    }\n    return res;\n}\n//---------------------------------------------------------------------------\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------\n    ll h,w,k;cin>>h>>w>>k;\n    ll a[30][30];\n    for(ll i=0;i<h;i++){\n        for(ll j=0;j<w;j++){\n            char c;cin>>c;\n            a[i][j]=c-'0';\n        }\n    }\n    ll ans=0;\n    for(ll i=0;i<h;i++){\n        for(ll j=0;j<w;j++){\n            ll b[30][30];\n            for(ll x=0;x<h;x++){\n                for(ll y=0;y<w;y++){\n                    b[x][y]=a[x][y];\n                }\n            }\n            queue<Pll>del;\n            del.push(mp(i,j));\n            ll cnt=0;\n            int turn=0;\n            map<Pll,ll>m;\n            \n            //cout<<1<<endl;\n            while(!del.empty()){\n                //delete\n                while(!del.empty()){\n                Pll p=del.front();del.pop();\n                m[p]++;\n                }\n            \n            //move\n            for(ll x=0;x<w;x++){\n                for(ll y=h-1;y>=0;y--){\n                    if(m[{y,x}]){\n                        bool xyz=0;\n                        for(ll z=y-1;z>=0;z--){\n                            if(m[{z,x}]==0){\n                                b[y][x]=b[z][x];\n                                m[{z,x}]=1;\n                                xyz=1;\n                                break;\n                            }\n                        }\n                        if(xyz==0)\n                            b[y][x]=-1;\n                    }\n                }\n            }\n                \n            \n            //push\n            int tmp=0;\n            for(ll x=0;x<h;x++){\n                for(ll y=0;y<w-k+1;y++){\n                    ll prey=y;\n                    if(b[x][y]==-1)continue;\n                    bool xyz=1;\n                    for(ll z=y+1;z<y+k;z++){\n                        if(b[x][z]!=b[x][z-1]){\n                            xyz=0;\n                            break;\n                        }\n                    }\n                    if(xyz==1){\n                        for(ll z=y;z<w;z++){\n                            if(b[x][z]==b[x][y]){\n                            del.push(mp(x,z));\n                            tmp+=b[x][z];\n                              \n                                prey=z+1;\n                            }\n                            else{\n                                break;\n                            }\n                        }\n                    }\n                    y=prey;\n                }\n            }\n   \n            //if(i==3&&j==2)cout<<tmp<<endl;\n            cnt+=modpow(2,turn)*tmp;\n            turn++;\n            }\n            //cout<<cnt<<endl;\n            chmax(ans,cnt);\n        }\n    }\n\n    cout<<ans<<endl;\n    //-------------------------------\n    return 0;\n}\n//---------------------------------------------------------------------------\n/*\nint n;cin>>n;\nvector<int>a(n);\nfor(int i=0;i<n;i++)\n    cin>>a[i];\n*/\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) x.begin(),x.end()\n#define ln '\\n'\nconst long long MOD = 1000000007LL;\n//const long long MOD = 998244353LL;\ntypedef long long ll;\ntypedef unsigned long long ull; \ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true;} return false; }\n///////////////////////////////////////////////////////////////////////////////////////////////////\nll board[30][30];\nll moto[30][30];\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int H,W,K; cin >> H >> W >> K;\n    vector<string> S(H);\n    rep(i,H) cin >> S[i];\n\n    rep(i,H) rep(j,W) moto[i][j] = S[i][j] - '0';\n\n    ll ans = 0;\n    rep(z,H) {\n        rep(w,W) {\n            rep(i,H) rep(j,W) board[i][j] = moto[i][j];\n            for (int i = z; i > 0; --i) board[i][w] = board[i-1][w];\n            board[0][w] = 0;\n\n            ll val = 0;\n            ll b = 1;\n            while (true) {\n                bool ok = false;\n                rep(i,H) {\n                    for (int j = W; j >= K; --j) {\n                        bool ok2 = false;\n                        rep(k,W-j+1) {\n                            if (!board[i][k]) continue;\n                            bool ok10 = true;\n                            rep(l,j) {\n                                if (board[i][k] != board[i][k+l]) {\n                                    ok10 = false;\n                                    break;\n                                }\n                            }\n                            if (!ok10) continue;\n                            ok = ok2 = true;\n                            val += board[i][k]*j*b;\n                            rep(l,j) {\n                                board[i][k+l] = 0;\n                            }\n                            break;\n                        }\n                        if (ok2) break;\n                    } \n                }\n\n                if (!ok) break;\n                rep(j,W) {\n                    for (int i = H-1; i >= 0; --i) {\n                        if (board[i][j]) continue;\n                        int k = i-1;\n                        while (k >= 0 && !board[k][j]) --k;\n                        if (k==-1) break;\n                        board[i][j] = board[k][j];\n                        board[k][j] = 0;\n                    }\n                }\n                b *= 2;\n            }\n            /*\n            rep(i,H) {\n                rep(j,W) cout << board[i][j];\n                cout << ln;\n            }\n            cout << ln;\n            */\n            chmax(ans,val);\n        }\n    }\n\n    cout << ans << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX = 30;\n\nint b[MAX][MAX];\nint board[MAX][MAX];\n\nint calculate(int h, int w, int k, int x, int y) { \n  // pass by value to prevent modifying the original array\n  // the complexity of the copy should be O(HW) which is equivalent to the complexity of the operation performed in this function\n\n  int ans = 0; \n  int prev_ans = ans;\n\n  board[x][y] = 0;\n\n  int i = 0;\n  while (true) {\n    // adjust cells\n    for (int c = 0; c < w; c++) {\n      int t = h - 2;\n      for (int r = h - 1; r >= 0; r--) {\n        if (board[r][c] == 0) {\n          while (t > 0) {\n            if (board[t][c] != 0) break;\n            t--;\n          }\n          board[r][c] = board[t][c];\n          board[t][c] = 0;\n        }\n        if (t >= 0) t--;\n      }\n    }\n\n    // find matches\n    for (int r = 0; r < h; r++) { // r = row accesor\n      int c1 = 0; // c1 = column accessor left bound inclusive\n      while(c1 <= w - k) {\n        int c2 = c1 + 1; // c2 = column accessor right bound exclusive (at final stage)\n        while(c2 < w) {\n          if (board[r][c1] != board[r][c2]) {\n            if (c2 - c1 >= k) {\n              ans += (1 << i) * (c2 - c1) * board[r][c1]; // short for (2 ^ i) * (len * val)\n              for (int idx = c1; idx < c2; idx++) board[r][idx] = 0;\n            }\n            c1 = c2;\n            break;\n          }\n\n          // reached end of row with valid match\n          if (c2 == w - 1 && c2 - c1 >= k - 1) {\n            ans += (1 << i) * (c2 - c1 + 1) * board[r][c1];\n            for (int idx = c1; idx <= c2; idx++) board[r][idx] = 0;\n            c1 = c2;\n            break;\n          }\n\n          c2++;\n        }\n      }\n    }\n\n    if (ans == prev_ans) break;\n    prev_ans = ans;\n    i++;\n  }\n\n  return ans;\n}\n\nint main() {\n  int H, W, K; cin >> H >> W >> K;\n  for (int i = 0; i < H; i++) {\n    string row; cin >> row;\n    for (int j = 0; j < W; j++) {\n      b[i][j] = row.at(j) - '0';\n    }\n  }\n\n  // A brute force solution will take approximately O(H^3 * W^2) which should be ok for H and W less than or equal to 30\n  int ans = 0;\n  for (int i = 1; i < H; i++) { // removing an element in the top layer will not make a difference\n    for (int j = 0; j < W; j++) {\n      memcpy(board, b, sizeof(int) * MAX * MAX);\n      ans = max(ans, calculate(H, W, K, i, j));\n    }\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <string>\n#include <utility>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <climits>\n#include <set>\n#include <cmath>\n#include <numeric>\n#include <iomanip>\n\nusing namespace std;\nint org_grid[30][30];\nint grid[30][30];\nint tmp_col[30];\n\nvoid show(int H, int W){\n  for(int i = 0; i < H; i++){\n    for(int j = 0; j < W; j++){\n      cout << grid[i][j];\n    }\n    cout << endl;\n  }\n  return;\n}\n\n\nvoid slide(int H, int W){\n  for(int i = 0; i < W; i++){\n    int real_height = 0;\n    for(int j = 0; j < H; j++){\n      if(grid[j][i] != 0){\n        tmp_col[real_height] = grid[j][i];\n        real_height ++;\n      }\n    }\n    for(int j = 0; j < H; j++){\n      grid[j][i] = 0;\n    }\n    for(int j = 0; j < real_height; j++){\n      grid[j][i] = tmp_col[j];\n    }\n  }\n}\n\nvoid update(int H, int W, int K, int &score, int coeff, bool &updated){\n  for(int i = 0; i < H; i++){\n    int range_begin = -1;\n    int range_color = -1;\n    for(int j = 0; j < W; j++){\n      if(range_color != grid[i][j]){\n        if(j - range_begin >= K && range_color > 0){\n          updated = true;\n          for(int k = range_begin; k < j; k++){\n            score += coeff * grid[i][k];\n            grid[i][k] = 0;\n          }\n        }\n        range_begin = j;\n        range_color = grid[i][j];\n      }\n    }\n    if(W - range_begin >= K && range_color > 0){\n      updated = true;\n      for(int k = range_begin; k < W; k++){\n        score += coeff * grid[i][k];\n        grid[i][k] = 0;\n      }\n    }\n  }\n}\n\nint main(void){\n  int H;\n  int W;\n  int K;\n  cin >> H >> W >> K;\n  for(int i = 0; i < H; i++){\n    string tmp;\n    cin >> tmp;\n    for(int j = 0; j < W; j++){\n      org_grid[H - i - 1][j] = (int) (tmp[j] - '0');\n    }\n  }\n\n  int ans = 0;\n  for(int i = 0; i < H; i++){\n    for(int j = 0; j < W; j++){\n      for(int k = 0; k < H; k++){\n        for(int l = 0; l < W; l++){\n          grid[k][l] = org_grid[k][l];\n        }\n      }\n      grid[i][j] = 0;\n      int cur_score = 0;\n      int cur_coeff = 1;\n      while(true){\n        bool updated = false;\n        slide(H, W);\n        update(H, W, K, cur_score, cur_coeff, updated);\n        if(!updated){\n          break;\n        }\n        cur_coeff *= 2;\n      }\n      ans = max(ans, cur_score);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) x.begin(),x.end()\n#define ln '\\n'\nconst long long MOD = 1000000007LL;\n//const long long MOD = 998244353LL;\ntypedef long long ll;\ntypedef unsigned long long ull; \ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true;} return false; }\n///////////////////////////////////////////////////////////////////////////////////////////////////\nint board[30][30];\nint moto[30][30];\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int H,W,K; cin >> H >> W >> K;\n    vector<string> S(H);\n    rep(i,H) cin >> S[i];\n\n    rep(i,H) rep(j,W) moto[i][j] = S[i][j] - '0';\n\n    int ans = 0;\n    rep(z,H) {\n        rep(w,W) {\n            rep(i,H) rep(j,W) board[i][j] = moto[i][j];\n            for (int i = z; i > 0; --i) board[i][w] = board[i-1][w];\n            board[0][w] = 0;\n\n            int val = 0;\n            int b = 1;\n            while (true) {\n                bool ok = false;\n                rep(i,H) {\n                    for (int j = W; j >= K; --j) {\n                        bool ok2 = false;\n                        rep(k,W-j+1) {\n                            if (!board[i][k]) continue;\n                            bool ok10 = true;\n                            rep(l,j) {\n                                if (board[i][k] != board[i][k+l]) {\n                                    ok10 = false;\n                                    break;\n                                }\n                            }\n                            if (!ok10) continue;\n                            ok = ok2 = true;\n                            val += board[i][k]*j*b;\n                            rep(l,j) {\n                                board[i][k+l] = 0;\n                            }\n                            break;\n                        }\n                        if (ok2) break;\n                    } \n                }\n\n                if (!ok) break;\n                rep(j,W) {\n                    for (int i = H-1; i >= 0; --i) {\n                        if (board[i][j]) continue;\n                        int k = i-1;\n                        while (k >= 0 && !board[k][j]) --k;\n                        if (k==-1) break;\n                        board[i][j] = board[k][j];\n                        board[k][j] = 0;\n                    }\n                }\n                b *= 2;\n            }\n            /*\n            rep(i,H) {\n                rep(j,W) cout << board[i][j];\n                cout << ln;\n            }\n            cout << ln;\n            */\n            chmax(ans,val);\n        }\n    }\n\n    cout << ans << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\nconst int INF_N = 1e+9;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\n//繰り返し二乗法\nll mod_pow(ll a, ll n, ll m) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%m;\n\t\ta = a * a%m; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\n//逆元(Eucledean algorithm)\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nusing mP = pair<modint, modint>;\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\n\n\nint H, W, K;\nvector<P> getnum(vec &v){\n    vector<P> res;\n    int cnt = 0;\n    int num = v[0];\n    rep(i, v.size()){\n        if(num == v[i]){\n            cnt++;\n        }else{\n            res.push_back(make_pair(num, cnt));\n            num = v[i];\n            cnt = 1;\n        }\n    }\n    res.push_back(make_pair(num, cnt));\n    return res;\n}\n\nll keshi(vector<vec> &v){\n    ll res = 0;\n    rep(i, v.size()){\n        auto vh = getnum(v[i]);\n        int cnt = 0;\n        for(auto p: vh){\n            if(p.second >= K){\n                res += p.first*p.second;\n                rep(k, p.second){\n                    v[i][cnt+k] = 0;\n                }\n            }\n            cnt += p.second;\n        }\n    }\n    return res;\n}\n\nvoid otoshi(vector<vec> &v){\n    rep(j, W){\n        int cnt = H-1;\n        per(i, H){\n            if(v[i][j] != 0){\n                v[cnt][j] = v[i][j];\n                if(cnt != i) v[i][j] = 0;\n                cnt--;\n            }\n        }\n    }\n}\n\nvoid solve() {\n    cin >> H >> W >> K;\n    vector<string> s(H);\n    rep(i, H) cin >> s[i];\n    vector<vec> v(H, vec(W));\n    rep(i, H)rep(j, W) v[i][j] = s[i][j]-'0';\n    auto tv = v;\n    ll res = 0;\n    rep(i, H){\n        rep(j, W){\n            ll tmp = 0;\n            ll cnt = 1;\n            v = tv;\n            v[i][j] = 0;\n            otoshi(v);\n            while(1){\n                ll tmp2 = keshi(v);\n                if(tmp2 == 0) break;\n                tmp += tmp2*cnt;\n                cnt *= 2;\n                otoshi(v);\n            }\n            res = max(res, tmp);\n        }\n    }\n    cout << res << endl;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  //cout << fixed << setprecision(10);\n  //init_f();\n  //init();\n  //int t; cin >> t; rep(i, t)solve();\n  solve();\n//   stop\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1000000000\n#define INF 100000000000000\n#define ll long long\n#define ull unsigned long long\n#define M (int)(1e9+7)\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\n#define IN(a,n) rep(i,n){ cin>>a[i]; }\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n#define F first\n#define S second\n#define PB push_back\n#define EB emplace_back\n\nint h,w,k;\nint a[100][100];\nint ans=0;\n\nbool g(int b[100][100]){\n  bool flag = false;\n\n  rep(j,w){\n    int i=h-1;\n    while(i>0){\n      int l=i;\n      while(l>=0&&b[l][j]<0){\n        flag=true;\n        l--;\n      }\n     if(i!=l&&l>=0){\n      b[i][j]=b[l][j];\n      b[l][j]=-1;\n     }\n     else if(i!=l){\n       b[i][j]=0;\n     }\n     if(i==l) i--;\n     else i=l;\n    }\n  }\n  rep(i,h){\n    rep(j,w){\n      if(b[i][j]==-1)\n        b[i][j]=0;\n    }\n  }\n  return flag;\n\n  \n}\n\nint s(int b[100][100],int m){\n  int res=0;\n  rep(i,h){\n    int j=0;\n    while(j<w){\n      int l=j; \n      while(b[i][j]==b[i][l]&&l<w)\n        l++;\n      if(b[i][j]>0&&l-j>=k){\n        res+=b[i][j]*(l-j);\n        FOR(c,j,l){\n          b[i][c]=-1;\n        }\n      }  \n      j=l;\n    }\n  }\n\n  int ret=1;\n  while(m--){\n    ret*=2;\n  }\n  return ret*res;\n}\n\n\nvoid f(int y,int x){\n  int b[100][100];\n  rep(i,h){\n    rep(j,w){\n      b[i][j]=a[i][j];\n    }\n  }\n  int res=0;\n  b[y][x]=-1;\n\n \n  int m=0;\n  while(g(b)){\n    res+=s(b,m);\n    m++;\n  }\n\n\n  ans=max(ans,res);\n}\n\n\nchar c[100][100];\n\nint main(){\n  cin>>h>>w>>k;\n  rep(i,h){\n    cin>>c[i];\n    rep(j,w){\n      a[i][j]=c[i][j]-'0';\n    }\n  }\n\n  rep(i,h){\n    rep(j,w){\n      f(i,j);\n    }\n  }\n\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\n#define F first\n#define S second\n\nconst int mx=200010;\nconst ll mod=1e9+7;\n\n\nint main() {\n  int h,w,k;\n  cin >> h >> w >> k;\n  vector<vector<int>> c(30, vector<int>(30,0));\n  rep(i,h)rep(j,w) cin >> c[i][j];\n\n  ll ans=0;\n  rep(x,h)rep(y,w){\n    auto tmp = c;\n    c[x][y] = 0;\n    ll base = 0, res = 0;\n    while(1){\n      ll tmp = 0;\n      rep(i,h){\n        int st=0;\n        rep(j,w+1){\n          if(j==w || (j>0&&c[i][j]!=c[i][j])){\n            if(j-st>=k){ for(int p=st; p<j; p++){tmp+=c[i][p]; c[i][p]=0; }  st=j; }\n            st = j;\n          }\n        }\n      }\n      if(base!=0 && tmp==0) break;\n      res += base*tmp;\n      base = (base>0?base*2:1);\n\n      rep(j,w){\n        int pos = h-1;\n        for(int i=h-1; i>=0; i--){\n          if(c[i][j]>0){\n            c[pos][j] = c[i][j];\n            if(pos!=i) c[i][j] = 0;\n            pos--;\n          }\n        }\n      }\n    }\n    ans = max(ans, res);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\n#define rep2(i, s, n) for (ll i = (s); i < (ll)(n); i++)\n#define all(v) v.begin(), v.end()\n#define sz(v) v.size()\n#define INF 100000000000000 //10^14 100兆\n// aよりもbが大きいならばaをbで更新する\n// (更新されたならばtrueを返す)\ntemplate <typename T>\nbool chmax(T &a, const T& b) {\n  if (a < b) {\n    a = b;  // aをbで更新\n    return true;\n  }\n  return false;\n}\n// aよりもbが小さいならばaをbで更新する\n// (更新されたならばtrueを返す)\ntemplate <typename T>\nbool chmin(T &a, const T& b) {\n  if (a > b) {\n    a = b;  // aをbで更新\n    return true;\n  }\n  return false;\n}\n\nint main(){\n  ll H, W, K;\n  cin >> H >> W >> K;\n  vector<string> c(H);\n  rep(i, H){\n    cin >> c.at(i);\n  }\n  vector<string> p(W, \"\");\n  vector<string> p2(W);\n  rep(i, W){\n    rep(j, H){\n      p.at(i) += c.at(H-1-j).at(i);\n    }\n    rep(j, H){\n      p.at(i) += \"#\";\n    }\n  }\n  rep(i, W){\n    p2.at(i) = p.at(i);\n  }\n  queue<pair<ll, ll>> s;\n  ll ans = 0;\n  rep(i, W){\n    rep(m, H){\n    rep(j, W){\n      p.at(j) = p2.at(j);\n    }\n    ll chain = 0;\n    ll score = 0;\n    s.push(make_pair(i, m));\n    while(!s.empty()){\n      queue<pair<ll, ll>> d;\n      while(!s.empty()){\n        pair<ll, ll> r = s.front();\n        s.pop();\n        d.push(r);\n        p.at(r.first).at(r.second) = '!';\n      }\n      rep(j, W){\n        auto it = p.at(j).begin();\n        while(it != p.at(j).end()){\n          if(*it == '!'){\n            it = p.at(j).erase(it);\n          }\n          else{\n            it++;\n          }\n        }\n      }\n//      cout << i << \" \" << score << endl;\n//      rep(j, W){\n//        cout << p.at(j) << endl;\n//      }\n      rep(j, H){\n        ll rin = 1;\n        rep(k, W-1){\n          if(p.at(k).at(j) == p.at(k+1).at(j) && isdigit(p.at(k).at(j))){\n            rin++;\n          }\n          else if(isdigit(p.at(k).at(j)) && rin >= K){\n            score += pow(2, chain) * rin * (p.at(k).at(j) - '0');\n            rep(l, rin){\n              s.push(make_pair(k-l, j));\n            }\n            rin = 1;\n          }\n        }\n        if(isdigit(p.at(W-1).at(j)) && rin >= K){\n          score += pow(2, chain) * rin * (p.at(W-1).at(j) - '0');\n          rep(l, rin){\n            s.push(make_pair(W-1-l, j));\n          }\n        }\n      }\n      chain++;\n    }\n//    cout << i  << \" \" << m << \" \" << score << endl;\n    chmax(ans, score);\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nchar a[31][31];\nint h, w, k;\nchar b[31][31];\nvoid drop()\n{\n\tfor(int i = h - 1; i >= 0; i--)\n\t{\n\t\tfor(int j = w - 1; j >= 0; j--)\n\t\t{\n\t\t\tif(b[i][j] == '$')\n\t\t\t{\n\t\t\t\tfor(int k = i - 1; k >= 0; k--)\n\t\t\t\t{\n\t\t\t\t\tif(b[k][j] != '$')\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int l = i; l - (i - k) >= 0; l--)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tb[l][j] = b[l-(i-k)][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int l = i - k - 1; l >= 0; l--) b[l][j] = '$';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nll clr()\n{\n\tll cnt = 0;\n\tfor(int i = 0; i < h; i++)\n\t{\n\t\tfor(int j = 0; j < w - 2; j++)\n\t\t{\n\t\t\tif(b[i][j]==b[i][j+1]&&b[i][j+1]==b[i][j+2])\n\t\t\t{\n\t\t\t\tif(b[i][j]!='$')\n\t\t\t\t{\n\t\t\t\t\tcnt+=3*(b[i][j]-'0');\n\t\t\t\t}\n\t\t\t\tb[i][j]=b[i][j+1]=b[i][j+2]='$';\n\t\t\t}\n\t\t}\n\t}\n\tif(k==2)\n\t{\n\t\tfor(int i = 0; i < h; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < w - 1; j++)\n\t\t\t{\n\t\t\t\tif(b[i][j]==b[i][j+1])\n\t\t\t\t{\n\t\t\t\t\tif(b[i][j]!='$')\n\t\t\t\t\t{\n\t\t\t\t\t\tcnt+=2*(b[i][j]-'0');\n\t\t\t\t\t}\n\t\t\t\t\tb[i][j]=b[i][j+1]='$';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nvoid out()\n{\n\tfor(int i = 0; i < h; i++)\n\t{\n\t\tfor(int j = 0; j < w; j++)\n\t\t{\n\t\t\tcout << b[i][j];\n\t\t}\n\t\tcout << '\\n';\n\t}\n\tcout<<'\\n';\n}\n\nll play()\n{\n\t//out();\n\tdrop();\n\t//out();\n\tll ans = 0;\n\tfor(int i = 0; i < 30; i++)\n\t{\n\t\tans += (1LL<<i)*clr();\n\t\t//if(i==0) out();\n\t\tdrop();\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin>>h>>w>>k;\n\tfor(int i = 0; i < h; i++)\n\t{\n\t\tfor(int j = 0; j < w; j++)\n\t\t{\n\t\t\tcin>>a[i][j];\n\t\t}\n\t}\n\tll ans = 0;\n\tfor(int i = 0; i < h; i++)\n\t{\n\t\tfor(int j = 0; j < w; j++)\n\t\t{\n\t\t\tfor(int ix = 0; ix < h; ix++)\n\t\t\t{\n\t\t\t\tfor(int jj = 0; jj < w; jj++)\n\t\t\t\t{\n\t\t\t\t\tb[ix][jj] = a[ix][jj];\n\t\t\t\t}\n\t\t\t}\n\t\t\tb[i][j] = '$';\n\t\t\tans = max(ans, play());\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst ll MOD = 1'000'000'007;\nconst ld PI = acos(-1);  \nconst ld EPS = 0.0000000001;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define REP(i, n) for(ll i=0; i<(ll)(n); i++)\n#define REPD(i, n) for(ll i=n-1; 0<=i; i--)\n#define FOR(i, a, b) for(ll i=a; i<(ll)(b); i++)\n#define FORD(i, a, b) for(ll i=a; (ll)(b)<=i; i--)\n#define ALL(x) x.begin(), x.end()\n#define MAX(x) *max_element(ALL(x))\n#define MIN(x) *min_element(ALL(x))\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint main(){\n    ll h, w, k;  cin >> h >> w >> k;\n    vector<vector<ll>> ori(h, vector<ll>(w));\n    REP(i, h) REP(j, w){\n        char c; cin >> c;\n        ori[i][j] = c-'0';\n    }\n    \n    ll res=0;\n    REP(x, h){\n        REP(y, w){\n            ll tmp=0, times=0;\n            bool flag=true;\n            vector<vector<ll>> g = ori;\n            g[x][y] = 0;\n            for(int i=x; 0<i; i--){\n                swap(g[i][y], g[i-1][y]);\n            }\n            // REP(i, h){\n            //     REP(j, w) cout << g[i][j] << ' ';\n            //     cout << endl;\n            // }\n            \n            while(flag){\n                flag = false;\n                REP(i, h){\n                    ll bef=g[i][0], cnt=0, st=0, index=w;\n                    \n                    REP(j, w){\n                        if(g[i][j]==bef && 0<bef) cnt += 1;\n                        else{\n                            if(cnt<k){\n                                if(0<g[i][j]){\n                                    cnt = 1; st=j;\n                                }\n                            }else{\n                                if(bef)index = j;\n                                break;\n                            }\n                        }\n                        bef = g[i][j];\n                    }\n                    if(k<=cnt){\n                        tmp += (1<<times)*cnt*bef;\n                        FOR(j, st, index) g[i][j] = 0;\n                        flag = true;\n                    }\n                }\n                REPD(i, h){\n                    REP(j, w){\n                        if(!g[i][j]){\n                            REPD(k, i){\n                                if(!g[k][j]) continue;\n                                swap(g[k][j], g[i][j]); break;\n                            }\n                        }\n                    }\n                }\n                \n                times += 1;\n                //cout << tmp << ' ';\n            }\n            res = max(res, tmp);\n            //cout << x <<':' << y << ' ' << tmp << endl << endl;\n        }\n    }\n    \n    cout << res << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (n); i++)\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nint h, w, k;\n\nint f(vector<vector<int>> g, int x, int y) {\n\tg[y][x] = 0;\n\t\n\tint ret = 0;\n\tfor (int c = 1; ; c *= 2) {\n\t\trep(j, w) {\n\t\t\tfor (int i = h - 1; i > 0; i--) {\n\t\t\t\tif (g[i][j] == 0) {\n\t\t\t\t\tint t = i - 1;\n\t\t\t\t\twhile (t > 0 && g[t][j] == 0) t--;\n\t\t\t\t\tif (g[t][j] != 0) swap(g[i][j], g[t][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool loop = false;\n\t\trep(i, h) {\n\t\t\tint num = g[i][0];\n\t\t\tint cnt = 1;\n\t\t\tint idx = 0;\n\t\t\tfor (int j = 1; j < w; j++) {\n\t\t\t\tif (g[i][j] == num) cnt++;\n\t\t\t\telse {\n\t\t\t\t\tif (num > 0 && cnt >= k) {\n\t\t\t\t\t\tret += num * cnt * c;\n\t\t\t\t\t\trep(k, cnt) g[i][idx + k] = 0;\n\t\t\t\t\t\tloop = true;\n\t\t\t\t\t}\n\t\t\t\t\tnum = g[i][j];\n\t\t\t\t\tcnt = 1;\n\t\t\t\t\tidx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (num > 0 && cnt >= k) {\n\t\t\t\tret += num * cnt * c;\n\t\t\t\trep(k, cnt) g[i][idx + k] = 0;\n\t\t\t\tloop = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!loop) break;\n\t}\n\t\n\treturn ret;\n}\n\nint main() {\n\tcin >> h >> w >> k;\n\t\n\tvector<string> s(h);\n\trep(i, h) cin >> s[i];\n\t\n\tvector<vector<int>> g(h, vector<int>(w));\n\trep(i, h) rep(j, w) g[i][j] = s[i][j] - '0';\n\t\n\tint ans = 0;\n\trep(i, h) rep(j, w) ans = max(ans, f(g, j, i));\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define int long long\nint H, W, K;\nint A[30][30];\nint B[31][31];\n\nvoid move() {\n  for (int x=0; x<W; x++) {\n    int h = 0;\n    for (int y=0; y<H; y++) {\n      if (B[x][y] == 0) continue;\n      B[x][h++] = A[x][y];\n    }\n    for (int y=h; y<H; y++) {\n      B[x][y] = 0;\n    }\n  }\n}\n\nlong long score() {\n  long long s = 0;\n  for (int y=0; y<H; y++) {\n    int l = -1, lc = 0;\n    for (int x=0; x<=W; x++) {\n      if (B[x][y] == lc) continue;\n      if (x-l >= K && lc != 0) {\n        s += 1LL*lc*(x-l);\n        for (int xx=l; xx<x; xx++) B[xx][y] = 0;\n      }\n      lc = B[x][y];\n      l = x;\n    }\n  }\n  return s;\n}\n\nlong long solve(int sx, int sy) {\n  for (int x=0; x<W; x++) {\n    for (int y=0; y<H; y++) {\n      B[x][y] = A[x][y];\n    }\n  }\n  B[sx][sy] = 0;\n  move();\n  long long s = 0;\n  for (int i=0; ; i++) {\n    int f = score();\n    if (f == 0) break;\n    s += (1LL<<i) * f;\n    move();\n  }\n  return s;\n}\n\nsigned main() {\n  cin >> H >> W >> K;\n  for (int i=0; i<H; i++) {\n    for (int j=0; j<W; j++) {\n      char c;\n      cin >> c;\n      A[j][H-1-i] = (int)(c - '0');\n    }\n  }\n  long long s = 0;\n  for (int x=0; x<W; x++) {\n    for (int y=0; y<H; y++) {\n      s = max(s, solve(x, y));\n    }\n  }\n  cout << s << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <map>\n#include <queue> \n#include <stack>\n#include <set>\n#include <list>\n\nusing namespace std;\ntypedef long long ll;\n//#define rep(i, s, e) for (int(i) = (s); (i) < (e); ++(i))\n#define rep(i, e) for (int(i) = 0; (i) < (e); ++(i))\n#define rrep(i, s) for (int(i) = (s) - 1; (i) >= 0; --(i))\n#define all(x) x.begin(),x.end()\n#pragma endregion\n\nint main()\n{\n\tint h, w, k; cin >> h >> w >> k;\n\tvector<vector<int>> b(h, vector<int>(w)), c;\n\trep(i, h)\n\t{\n\t\tstring x; cin >> x;\n\t\trep(j, w)\n\t\t{\n\t\t\tint y = x[j] - '0';\n\t\t\tb[i][j] = y;\n\t\t}\n\t}\n\tint mx = 0;\n\trep(x, h)rep(y, w)\n\t{\n\t\tint res = 0;\n\t\tint cnt = 0;\n\t\tc = b;\n\t\tc[x][y] = 0;\n\t\tfor (int z = x; z > 0; --z)\n\t\t{\n\t\t\tc[z][y] = b[z - 1][y];\n\t\t}\n\t\twhile (true)\n\t\t{\n\t\t\tbool change = false;\n\t\t\tint tmp = 0;\n\t\t\trep(i, h)\n\t\t\t{\n\t\t\t\tint j = 0;\n\t\t\t\twhile (j <= w - k)\n\t\t\t\t{\n\t\t\t\t\tint l = j + 1;\n\t\t\t\t\tint now = c[i][j];\n\t\t\t\t\tif (now == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tj = l;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\twhile (l < w&&c[i][l] == now)++l;\n\t\t\t\t\tif (l - j >= k)\n\t\t\t\t\t{\n\t\t\t\t\t\tchange = true;\n\t\t\t\t\t\tfor (int m = j; m < l; ++m)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmp += now;\n\t\t\t\t\t\t\tc[i][m] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tj = l;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!change)break;\n\t\t\trep(j, w)rrep(i, h)\n\t\t\t{\n\t\t\t\tint l = i;\n\t\t\t\twhile (l >= 0 && c[l][j] == 0)--l;\n\t\t\t\tif (l < 0)c[i][j] = 0;\n\t\t\t\telse swap(c[i][j], c[l][j]);\n\t\t\t}\n\t\t\tres += pow(2, cnt)*tmp;\n\t\t\t++cnt;\n\t\t}\n\t\tmx = max(mx, res);\n\t}\n\tcout << mx << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <bitset>\n\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <ctime>\n////\n//#include <random>//\n#pragma endregion //#include\n/////////\n\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)4e18+20;\nconst LD PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n/////////\n#pragma region Math\n#pragma region\nlong long ext_gcd(long long a,long long b,long long& x,long long& y){\n\tif(b==0){\n\t\tx=1;y=0;return a;\n\t}\n\tlong long q = a/b;\n\tlong long g = ext_gcd(b,a-q*b,x,y);\n\tx = x - q*y;\n\tswap(x,y);\n\treturn g;\n}\ntemplate<class T>\ninline T gcd(T a, T b){return b ? gcd(b, a % b) : a;}\n\n#pragma endregion // 最大公約数 gcd\n#pragma region\ntemplate<class T>\ninline T lcm(T a, T b){return a / gcd(a, b) * b;}\n#pragma endregion // 最小公倍数 lcm\n#pragma region\nlong long invMod(long long a,long long m=MOD){\n\tlong long x,y;\n\text_gcd(a,m,x,y);\n\tx %= m;\n\tif(x<0) x += m;\n\treturn x;\n}\n\n/*\nLL powMod(LL x,LL e,LL mod=MOD){\n\tLL prod = 1%mod;\n\tfor(int i=63;i>=0;--i){\n\t\tprod = prod*prod % mod;\n\t\tif(e&1LL<<i)prod=prod*x%mod;\n\t}\n\treturn prod;\n}*/\n\nLL powMod(LL num,LL n,LL mod=(LL)MOD){//(num**n)%mod\n\tnum %= mod;//\n\tif( n == 0 ){\n\t\treturn (LL)1;\n\t}\n\tLL mul = num;\n\tLL ans = (LL)1;\n\twhile(n){\n\t\tif( n&1 ){\n\t\t\tans = (ans*mul)%mod;\n\t\t}\n\t\tmul = (mul*mul)%mod;\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\n/*\nLL mod_inverse(LL num,LL mod=MOD){\n\treturn powMod(num,MOD-2,MOD);\n}*/\n#pragma endregion //繰り返し二乗法 powMod\n#pragma region\ntemplate<class T>\nvector<T> getDivisor(T n){\n\tvector<T> v;\n\tfor(int i=1;i*i<=n;++i){\n\t\tif( n%i == 0 ){\n\t\t\tv.push_back(i);\n\t\t\tif( i != n/i ){//平方数で重複して数えないように\n\t\t\t\tv.push_back(n/i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\treturn v;\n}\n#pragma endregion //約数列挙 getDivisor(n):O(√n)\n#pragma endregion //math\n//Utility:便利な奴\n#pragma region\ntemplate<class T>\nvoid UNIQUE(vector<T>& vec){\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end() );\n}\n#pragma endregion // sort erase unique\n////////////////////////////////\n#pragma region \nlong long  bitcount64(long long bits)\n{\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >>16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >>32 & 0x00000000ffffffff);\n}\n#pragma endregion //その他\n////////////////////////////////\nstruct edge_base{int to;LL cost;};\nedge_base make_edge_base(int to,LL cost){\n\tedge_base ret = {to,cost};\n\treturn ret;\n}\n#pragma region GRL\n#pragma region //グラフ\ntemplate<class T,class EDGE>\nvoid dijkstra(int root,int V,vector<T>& dist,vector<int>& prev,\n\tvector< vector<EDGE> > G\t){\n\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > > que;\n\t\n\tdist.assign(V,LINF);\n\tprev.assign(V,-1);\n\n\tdist[root] = 0;\n\tque.push(pair<T,int>(0,root));//距離、頂点番号\n\n\twhile( !que.empty() ){\n\t\tpair<T,int> p = que.top();que.pop();\n\t\tint v = p.second;\n\t\tif( dist[v] < p.first ) continue;\n\t\tfor(int i=0;i < (int)G[v].size();++i){\n\t\t\tEDGE e = G[v][i];\n\t\t\tif( dist[e.to] > dist[v] + e.cost ){\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tprev[e.to] = v;\n\t\t\t\tque.push(pair<T,int>(dist[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n//経路復元,dijkstraにprev入れた\n//http://ronly.hatenablog.com/entry/2017/06/17/161641\nvector<int> get_path(vector<int>& prev,int t){\n\tvector<int> path;\n\twhile(t!=-1){\n\t\tpath.push_back( t );\n\t\tt = prev[t];\n\t}\n\treverse(path.begin(),path.end());\n\treturn path;\n}\n#pragma endregion //ダイクストラ法:O(|E|log|V|)\n#pragma region //グラフ\nvoid warshall_floyd(vector<vector<LL> >& dist,int V,const LL inf=LINF){\n\tfor(int k=0;k<V;++k){\n\t\tfor(int i=0;i<V;++i){\n\t\t\tif( dist[i][k] >= inf ) continue;\n\t\t\tfor(int j=0;j<V;++j){\n\t\t\t\tif( dist[k][j] >= inf )continue;\n\t\t\t\tdist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n#pragma endregion //ワーシャルフロイド:O(|V|**3)\n#pragma region\nnamespace FLOW{\n//vector< vector<FLOW:edge> > G;\n\nstruct edge_flow : public edge_base{\n\tLL cap;//LD cap;//\n\tint rev;\n};\nedge_flow make_edge_flow(int to,LL cap,int rev,LL cost=1){\n//edge_flow make_edge_flow(int to,LD cap,int rev,LL cost=1){\n\tedge_flow ret;\n\t\n\tret.to = to;\n\tret.cost = cost;\n\tret.cap = cap;\n\tret.rev = rev;\n\treturn ret;\n}\n\n//*\nclass Graph{\npublic:\n\tint V;\n\tvector< vector<FLOW::edge_flow> > G;\n\tvector< LL > dist;\n\tvector< int > iter;\n\tvector< bool > used;\n\tvoid init(int v){\n\t\tV = v;\n\t\tG.resize(V);\n\t}\n\tvoid reset(){\n\t\titer.assign(V,0);\n\t\tused.assign(V,false);\n\t}\n\t//directed graph\n\tvoid add_edge(int from,int to,LL cap){\n\t\tG[from].push_back( FLOW::make_edge_flow(to,cap,G[to].size()) );\n\t\tG[to].push_back( FLOW::make_edge_flow(from,0,G[from].size()-1) );\n\t}\n\t\nprivate:\n\t//sから最短距離をBFSで計算する\n\tvoid bfs(int s){//許容量もチェックしている\n\t\tqueue<int> que;\n\t\tdist = vector<LL>(V,-1);\n\t\tdist[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();++i){\n\t\t\t\tedge_flow &e = G[v][i];\n\t\t\t\tif( e.cap > 0 && dist[e.to] < 0 ){\n\t\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nprivate:\n\t//増加パスをDFSで探す\n\tLL dfs(int v,int t,LL f){\n\t\tif( v==t ) return f;\n\t\tfor(int &i = iter[v];i<(int)G[v].size();++i){//?\n\t\t\tFLOW::edge_flow &e = G[v][i];\n\t\t\tif( e.cap>0 && dist[v] < dist[e.to]){\n\t\t\t\tLL d = this->dfs(e.to, t, min(f,e.cap) );\n\t\t\t\tif( d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\t//sからtへの最大流量を求める\n\tLL max_flow(int s,int t){\n\t\tLL flow = 0;\n\t\tfor(;;){\n\t\t\tthis->bfs(s);\n\t\t\tif( dist[t] < 0 ) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tLL f = this->dfs(s,t,LINF);\n\t\t\tdo{\n\t\t\t\tflow += f;\n\t\t\t\tf = this->dfs(s,t,LINF);\n\t\t\t}while( f > 0 );\n\t\t}\n\t}\n};\n//*/\n}\n#pragma endregion //dinic :O(|E||V|^2)\n#pragma region //グラフ\nbool is_bipartite(int v,int c,vector< vector<int> >& G,vector<int>& Color){\n\tColor[v] = c;\n\tfor(int i=0;i < (int)G[v].size();++i){//隣接グラフ\n\t\tif(Color[ G[v][i] ] == c ) return false;\n\t\tif(Color[ G[v][i] ] == 0 && \n\t\t\t!is_bipartite(G[v][i],-c,G,Color)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nbool is_bipartite(int Root,vector< vector<int> >& Graph){\n\tint GraphSize = Graph.size();\n\tvector<int> Color(GraphSize,0);\n\tconst int ColorNo = 1;\n\treturn is_bipartite(Root,ColorNo,Graph,Color);\n}\n#pragma endregion //二部グラフチェック is_bipartite(root,GraphList)\n#pragma region\nnamespace matching{\n//https://beta.atcoder.jp/contests/soundhound2018/tasks/soundhound2018_c\nint V;\t\t//頂点数\nvector< vector<int> > G;//グラフ\nvector<int> match;//match[i]:頂点[i]がどことマッチされているか\nvector<bool > used;//\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n \nbool dfs(int v){\n\t/*\n\thttps://mathtrain.jp/bipartitematching\n\t未マッチ辺・マッチ辺・未マッチ辺\n\tこれを\n\tマッチ辺・未マッチ辺・マッチ辺\n\tに変えると\n\t1マッチが2マッチになる。\n\t未[済未]\n\t増加路を求めている。\n\t*/\n\tused[v] = true;//dfsのroot前に初期化される\n\tint size = G[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint u = G[v][i];//\n\t\tint w = match[u];//\n\t\tif( w<0 || ((used[w]==false) && dfs(w)) ){\n\t\t\t/*\n\t\t\tマッチングされていない||\n\t\t\t使われてない&&\n\t\t\t*/\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n \nint bipartite_matching(){\n\tint res = 0;\n\tmatch = vector<int>(V,-1);//未マッチ状態に初期化\n\tfor(int v=0;v<V;++v){\n\t\tif( match[v] < 0 ){\n\t\t\tused = vector<bool>(V,false);\n\t\t\tif( dfs(v) ){\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n}\n#pragma endregion //二部グラフの最大マッチング bipartite_matching()\n#pragma endregion //\n#pragma region \nvector< vector<LL> > NCK;//初期値:0\n//http://sugarknri.hatenablog.com/entry/2016/07/16/165715\nvoid makeinv(vector<LL>& inv,const LL P){\n\tint i;\n\t//const int varMAX = max(100000,(int)inv.size());\n\tconst int varMAX = max(300010,(int)inv.size());\n\t\n\tinv = vector<LL>( varMAX+1,0);\n\tinv[1]=1;\n\tfor(i=2;i<=varMAX;i++){\n\t\tinv[i] = (inv[P%i] * (P-P/i)%P ) % P;//OVF\n\t\t//inv[i] = powMod(i,P-2,P);\n\t}\n}\n\nLL nCk(LL N,LL k,LL mod = MOD){\n\tstatic vector<LL> inv;//modの逆元\n\tif( inv.size() == 0 ){\n\t\tmakeinv(inv,mod);//modは素数を入れる\n\t}\n\tk = min(k,N-k);\n\tif( k < 0 || k > N){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tfor(int i=1;i<=k;++i){\n\t\tret = (ret * ((N+1-i)%mod) )%mod;//ret*N:OVF\n\t\tret = (ret * inv[i] )%mod;\n\t}\n\treturn ret;\n}\nLL nCk_once(LL N,LL k,LL mod = MOD){//modは素数\n\tk = min(k,N-k);\n\tif( k < 0 || k > N ){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tLL A=1;\n\tfor(LL i=0;i<k;++i){\n\t\tA = (A * ((N-i)%mod) ) % mod;\n\t}\n\tLL B=1;\n\tfor(LL i=2;i<=k;++i){\n\t\tB = (B * (i%mod) ) % mod;\n\t}\n\tret = ( A * powMod(B,mod-2,mod) ) % mod;\n\treturn ret;\n}\n#pragma endregion //組み合わせnCk(,10^5)\n#pragma region\nLL nCk_base(int N,int K,LL mod=MOD){\n\tif( K<0 || N < K ) return 0;//多く取り過ぎ\n\tK = min(K,N-K);\n\tif( K==0 ){return 1%mod;}\n\tif( K==1 ){return N%mod;}//%MOD;\n\tif( N<=10000 && NCK[N][K] ){\n\t\treturn NCK[N][K];\n\t}\n\t//N個目を使わない:nCk(N-1,k)\n\t//N個目を使う\t:nCk(N-1,k-1)\n\tLL ans = (nCk_base(N-1,K)+nCk_base(N-1,K-1) )%mod;//%MOD;\n\tif( N<=10000 ){\n\t\tNCK[N][K] = ans;\n\t}\n\treturn ans;\n}\n\n#pragma endregion //組み合わせ メモ?\n\n#pragma region DSL\nclass UnionFind{\npublic:\n\tint cNum;//要素数\n\tvector<int> parent;\n\tvector<int> count;\n\tvector< vector<int> > GList;\n\tUnionFind(int n){\n\t\tcNum = n;\n\t\tparent = vector<int>(n);\n\t\tcount = vector<int>(n,1);\n\t\tGList.resize(n);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tparent[i] = i;\n\t\t\tGList[i].push_back(i);\n\t\t}\n\t}\n\tint find(int x){\n\t\tif( parent[x] == x ){return x;}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\tbool same(int x,int y){return find(x) == find(y);}\n\tint Count(int x){return count[find(x)];}\n\tvoid add(int x,int y){//union\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif( x==y )return;\n\t\tparent[x] = y;\n\t\t\n\t\tcount[y] += count[x];\n\t\tif( GList[y].size() < GList[x].size() ){\n\t\t\tswap(GList[x],GList[y]);\n\t\t}\n\t\tGList[y].insert( GList[y].end(),\n\t\t\tGList[x].begin(),GList[x].end() );\n\t}\n};\n#pragma endregion //UnionFind\n#pragma region DSL\nclass BITree{//1-index\n\tint N;\n\tvector<LL> bit;\npublic:\n\tBITree(int n){\n\t\tN = n;\n\t\tbit = vector<LL>(N+1,0);//1-index\n\t}\n\tvoid add(int a,LL w){//aにwを足す\n\t\tif( a <= 0 || N < a) return;//a:[1,N]\n\t\tfor(int i=a;i<=N;i += i & -i){\n\t\t\tbit[i] += w;\n\t\t}\n\t}\n\tLL sum(int a){//[1,a]の和,a:[1,N]\n\t\t/*\n\t\t1番目からa番目までの和、1-index\n\t\t*/\n\t\tLL ret = 0;\n\t\tif( a > N ) a = N;\n\t\tfor(int i=a; i > 0; i -= i & -i){\n\t\t\tret += bit[i];\n\t\t}\n\t\treturn ret;\n\t}\n};\n#pragma endregion //BIndexTree\n#pragma region\ntemplate <typename T>\nclass segmentTree{\n\tint N;//要素数\n\tvector< T > dat1;\n\tT VAL_E;//初期値\n\tT VAL_NULL;//空の値\npublic:\n\tsegmentTree(){};\n\t/*segmentTree(int n,T val_E ):N(n),VAL_E(val_E){\n\t\tdat1.resize(2*n);\n\t\tdat1.assign(2*n,val_E);//初期化\n\t}*/\n\tvoid init(int n,T val_E,T val_N){\n\t\tN = n;\n\t\tVAL_E = val_E;\n\t\tVAL_NULL = val_N;\n\t\tint size = 2;\n\t\twhile(size<N){\n\t\t\tsize <<= 1;\n\t\t}\n\t\tN = size;\n\t\tdat1.resize(2*N);\n\t\tdat1.assign(2*N,val_E);\n\t}\n\tT SELECT(T L,T R){//扱う演算子\n\t\tT ans;\n\t\tans = max(L,R);//\n\t\treturn ans;\n\t}\n\n\t//index番目の値をvalに変更,indexは\"0-index\"\n\tvoid update(int i,T val){\n\t\ti += N-1;\n\t\tdat1[i] = val;\n\t\twhile(i>0){\n\t\t\ti = (i-1)/2;\n\t\t\tdat1[i] = SELECT(dat1[i*2+1],dat1[i*2+2]);\n\t\t}\n\t}\n\n\t//区間[L,R)のSELECT\n\t/*\n\t調べている範囲[a,b),階数k,見る場所[L,R)\n\t*/\n\tT query(int a,int b,int k,int L,int R){\n\t\tif( R<=a || b<=L ){\n\t\t\treturn VAL_E;//交差しない\n\t\t}\n\t\tif( a<=L && R<=b && dat1[k] != VAL_NULL ){\n\t\t\treturn dat1[k];\n\t\t}\n\n\t\tT res = VAL_E;\n\t\tint mid = (L+R)/2;\n\t\tif( a < mid ) res = SELECT(res,query(a,b,k*2+1,L,mid) );\n\t\tif( mid < b ) res = SELECT(res,query(a,b,k*2+2,mid,R) );\n\t\treturn res;\n\t}\n\tT query(int L,int R){\n\t\treturn query(L,R,0,0,N);\n\t}\n};\n#pragma endregion //segment_tree\n\n#pragma region \n//行列の積\nnamespace mymat{\n\tLL matMOD = MOD;//初期値10^9 + 7\n};\ntemplate<class T>\nvector< vector<T> > operator*( vector<vector<T> >& A,vector< vector<T> >& B){\n\tLL mod = mymat::matMOD;\n\tint R = A.size();\n\tint cen = A[0].size();\n\tint C = B[0].size();\n\tvector< vector<T> > ans(R,vector<T>(C,0) );\n\tfor(int row=0;row<R;++row){\n\t\tfor(int col=0;col<C;++col){\n\t\t\tfor(int inner=0;inner< cen;++inner){\n\t\t\t\t/*ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t\t//ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col]);\n\t\t\t\tans[row][col] = (ans[row][col] + mod) % mod;\n\t\t\t\t//負になるときの処理\n\t\t\t\t*/\n\t\t\t\tans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\ntemplate<class T>\nvector< vector<T> > powMod(const vector< vector<T> >& mat,LL N,LL mod=MOD){\n\tmymat::matMOD = mod;\n\tint R = mat.size();\n\tint C = mat[0].size();\n\t//R==C\n\tvector< vector<T> > I(R,vector<T>(C,0));//単位元\n\tfor(int i=0;i<R && i<C;++i){\n\t\tI[i][i] = 1;\n\t}\n\tif( N == 0 ){\n\t\treturn I;\n\t}\n\tvector< vector<T> > mul(R,vector<T>(C)),ans(R,vector<T>(C));\n\tans = I;\n\tmul = mat;\n\twhile(N){\n\t\tif( N & 1 ){\n\t\t\tans = ans*mul;\n\t\t}\n\t\tN >>= 1;\n\t\tmul = mul*mul;\n\t}\n\treturn ans;\n}\n#pragma endregion //行列\n\n#pragma region\n#include<time.h>\nnamespace TIME{\n\nclock_t start,end;\nvoid time_start(){\n\tstart = clock();\n}\nvoid time_set(int t){\n\tend = start + t;\n}\nbool check(){\n\treturn clock() < end;\n}\n\n/*\nunsigned long long get_cycle(){\n\treturn __rdtsc();\n}\nunsigned long long start,limit;\nvoid time_start(){\n\tstart = get_cycle();\n}\n//あたいをーさぐらないとーだめー\nvoid time_set(unsigned long long num){limit = num;}\nbool check(){return (get_cycle() < start+limit);}\n*/\n}\n#pragma endregion //時間計測\n\n#pragma region\n\nnamespace RAND{\nunsigned long xor128(){ \n\tstatic unsigned long x=123456789,y=362436069,z=521288629,w=88675123; \n\tunsigned long t; \n\tt=(x^(x<<11));x=y;y=z;z=w;\n\treturn( w=(w^(w>>19))^(t^(t>>8)) ); \n}\nLL getRAND(LL P){\n\treturn ((xor128()%P)+P)%P;\n}\n}\n\n#pragma endregion //乱数\n\n#pragma region\n#pragma endregion //\n////////////////////////\nint H,W,K;\nvector<vector<int> > fld;//元\nvector<vector<int> > tmp;//計算用\n\nvoid view(vector<vector<int> >& v){\n\tfor(int h=0;h<H;++h){\n\t\tfor(int w=0;w<W;++w){\n\t\t\tcout<<v[h][w];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n//落下処理\nvoid down(vector<vector<int> >& v){\n\tfor(int w=0;w<W;++w){\n\t\tvector<int> hist(H,0);\n\t\tint count = 0;\n\t\tfor(int h=H-1;h>=0;--h){\n\t\t\tif(v[h][w]){\n\t\t\t\thist[count] = v[h][w];\n\t\t\t\t++count;\n\t\t\t}\n\t\t}\n\t\tfor(int h=H-1;h>=0;--h){\n\t\t\tv[h][w] = hist[H-1-h];\n\t\t}\n\t}\n//view(v);\n}\n\n//すべての連続K以上の数字の総和+その数字を0にする\nint dell(vector<vector<int> >& v){\n\t//消えるフラグ\n\tvector<vector<bool> > kesu(H,vector<bool>(W,false));\n\t//横で消えるチェック\n\tfor(int h=0;h<H;++h){\n\t\tfor(int w=0;w+K-1<W;++w){\n\t\t\tbool flag = true;\n\t\t\tint ter = v[h][w];\n\t\t\tfor(int k=0;k<K;++k){\n\t\t\t\tif( ter != v[h][w+k] ){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tfor(int k=0;k<K;++k){\n\t\t\t\t\tkesu[h][w+k] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t水平方向のみチェック\n\t//縦で消えるチェック\n\tfor(int w=0;w<W;++w){\n\t\tfor(int h=0;h+K-1<H;++h){\n\t\t\tbool flag = true;\n\t\t\tint ter = v[h][w];\n\t\t\tfor(int k=0;k<K;++k){\n\t\t\t\tif( ter != v[h+k][w] ){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tfor(int k=0;k<K;++k){\n\t\t\t\t\tkesu[h+k][w] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tint ret = 0;\n\tfor(int h=0;h<H;++h){\n\t\tfor(int w=0;w<W;++w){\n\t\t\tif( kesu[h][w] ){\n\t\t\t\tret += v[h][w];\n\t\t\t\tv[h][w] = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint cal(vector<vector<int> >& v){\n\t//0は空白\n\t//落下処理\n\tdown(v);\n\tint ret = 0;\n\tint dat;\n\tfor(int a=0;;++a){\n\t\tdat = dell(v);\n//cout << dat << endl;\n\t\tif(dat == 0 ){\n\t\t\tbreak;\n\t\t}\n\t\tret += (dat<<a);\n\t\tdown(v);\n\t}\n\treturn ret;\n}\n\n\nvoid solve(){\n\tcin>>H>>W>>K;\n\tfld=vector<vector<int> >(H,vector<int>(W));\n\tfor(int h=0;h<H;++h){\n\t\tstring str;\n\t\tcin>>str;\n\t\tfor(int w=0;w<W;++w){\n\t\t\tfld[h][w] = str[w]-'0';\n\t\t}\n\t}\n\tint ans = 0;\n\t\n\tfor(int h=0;h<H;++h){\n\t\tfor(int w=0;w<W;++w){\n\t\t\ttmp = fld;\n\t\t\t\n\t\t\ttmp[h][w] = 0;\n\t\t\tint res = cal(tmp);\n\t\t\tans = max(ans,res);\n//cout << res << endl;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve();\n}\n#pragma endregion //main()\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v){std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\nvoid clear_m(vector<string> &d, int H, int W) {\n    for (int k = 0; k < 32; k++) {\n        for (int i = H - 1; i >= 1; i--) {\n            for (int j = 0; j < W; j++) {\n                if (d[i][j] == '0') {\n                    swap(d[i][j], d[i - 1][j]);\n                }\n            }\n        }\n    }\n}\n\nbool is_update(vector<string> &d, int H, int W, int K) {\n    bool update = false;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (d[i][j] != '0') {\n                int c = 0;\n                char ch = d[i][j];\n                while (j < W && d[i][j] == ch)j++, c++;\n                if (c >= K)update = true;\n                j--;\n            }\n        }\n    }\n    return update;\n}\n\nlong long calc_m(vector<string> &d, int H, int W, int K) {\n    long long sum = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (d[i][j] != '0') {\n                int c = 0;\n                char ch = d[i][j];\n                int k = j;\n                while (k < W && d[i][k] == ch)k++, c++;\n                if (c >= K) {\n                    sum += (ch - '0') * c;\n                    k = j;\n                    while (k < W && d[i][k] == ch) d[i][k] = '0', k++;\n                }\n            }\n        }\n    }\n    return sum;\n}\n\nint main() {\n\n    int H, W, K;\n    cin >> H >> W >> K;\n\n    vector<string> c(H);\n    for (int i = 0; i < H; i++) cin >> c[i];\n\n    long long ans = LONG_LONG_MIN;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            long long sum = 0;\n            vector<string> d = c;\n            d[i][j] = '0';\n            //for(int i = 0;i<H;i++) SHOW_VECTOR(d[i]);\n            //cout << endl;\n            clear_m(d, H, W);\n            //for(int i = 0;i<H;i++) SHOW_VECTOR(d[i]);\n            int cnt = 0;\n            while (true) {\n                if (!is_update(d, H, W, K)) break;\n                long long ret = calc_m(d, H, W, K);\n                sum += pow(2, cnt) * ret;\n                clear_m(d, H, W);\n                cnt++;\n            }\n            ans = max(ans, sum);\n        }\n    }\n\n    cout << ans << endl;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nint INF = 1LL << 30;\nint MOD = 1e9+7;\nint H,W,K;\nint play(vector<string> S,int h,int w){\n    int sum = 0,turn = 0,sub;\n    S[h][w] = '0';\n    /*              \n    for(auto ss:S){\n        cout << ss << endl;\n    }cout << endl;\n                  */\n    do{\n        //下にずらす\n        for(int j = 0;j < W;j++){\n            //累積\n            vector<int> accum(H);\n            accum[H-1] = S[H-1][j] == '0';\n            for(int i = H-2;i >= 0;i--){\n                accum[i] = accum[i+1] + (S[i][j] == '0');\n            }\n            //ずらす\n            for(int i = H-2;i >= 0;i--){\n                if(S[i][j] == '0')continue;\n                S[i+accum[i]][j] = S[i][j];\n            }\n            //0埋め\n            for(int i = 0;i < accum[0];i++){\n                S[i][j] = '0';\n            }\n        }\n        /*              \n        for(auto ss:S){\n            cout << ss << endl;\n\n        }cout << endl;\n                      */\n        //連結確認\n        sub = 0;\n        for(int i = 0;i < H;i++){\n            int cnt = 1,ind = 0;\n            for(int j = 1;j <= W;j++){\n                if(S[i][j] != S[i][ind]){\n                    if(S[i][ind] != '0' && cnt >= K){\n//                        cout << i << \":\" << j << \" \" << cnt << endl;\n                        sub += cnt * (S[i][ind] - '0');\n                        for(int k = 0;k < cnt;k++){\n                            S[i][j-k-1] = '0';\n                        }\n                    }\n                    cnt = 0;\n                    ind = j;\n                }\n                cnt++;\n            }\n        }\n        /*              \n        for(auto ss:S){\n            cout << ss << endl;\n        }cout << endl;\n                      */\n        sum += (sub << turn);\n        turn++;\n    }while(sub);\n\n    return sum;\n}\nmain(){\n    cin >> H >> W >> K;\n    vector<string> S(H);\n    for(int i = 0;i < H;i++)cin >> S[i];\n    //cout << endl;\n    //cout << play(S,3,2) << endl;\n    int maxi = 0;\n    for(int i = 1;i < H;i++){\n        for(int j = 0;j < W;j++){\n            maxi = max(maxi, play(S,i,j));\n        }\n    }\n    cout << maxi << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stack>\n#include <set>\n#include <list>\n#include <iomanip>\n#include <cstdint>\n#include <cstdlib>\n\nusing namespace std;\ntypedef long long ll;\n//#define rep(i, s, e) for (int(i) = (s); (i) < (e); ++(i))\n#define rep(i, e) for (int(i) = 0; (i) < (e); ++(i))\n#define rrep(i, s) for (int(i) = (s) - 1; (i) >= 0; --(i))\n#define all(x) x.begin(),x.end()\n#pragma endregion\n\n\nint main()\n{\n\tint h, w, k; cin >> h >> w >> k;\n\tvector<vector<int>> b(h, vector<int>(w)), c;\n\trep(i, h)\n\t{\n\t\tstring x; cin >> x;\n\t\trep(j, w)\n\t\t{\n\t\t\tint y = x[j] - '0';\n\t\t\tb[i][j] = y;\n\t\t}\n\t}\n\tll mx = 0;\n\trep(x, h)rep(y, w)\n\t{\n\t\tll res = 0;\n\t\tint cnt = 0;\n\t\tc = b;\n\t\tc[x][y] = 0;\n\t\tfor (int z = x; z > 0; --z)\n\t\t{\n\t\t\tc[z][y] = b[z - 1][y];\n\t\t}\n\t\twhile (true)\n\t\t{\n\t\t\tbool change = false;\n\t\t\tint tmp = 0;\n\t\t\trep(i, h)\n\t\t\t{\n\t\t\t\tint j = 0;\n\t\t\t\twhile (j <= w - k)\n\t\t\t\t{\n\t\t\t\t\tint l = j + 1;\n\t\t\t\t\tint now = c[i][j];\n\t\t\t\t\tif (now == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tj = l;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\twhile (l < w&&c[i][l] == now)++l;\n\t\t\t\t\tif (l - j >= k)\n\t\t\t\t\t{\n\t\t\t\t\t\tchange = true;\n\t\t\t\t\t\tfor (int m = j; m < l; ++m)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmp += now;\n\t\t\t\t\t\t\tc[i][m] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tj = l;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!change)break;\n\t\t\trep(j, w)rrep(i, h)\n\t\t\t{\n\t\t\t\tint l = i;\n\t\t\t\twhile (l >= 0 && c[l][j] == 0)--l;\n\t\t\t\tif (l < 0)c[i][j] = 0;\n\t\t\t\telse swap(c[i][j], c[l][j]);\n\t\t\t}\n\t\t\tres += powl(2, cnt)*tmp;\n\t\t\t++cnt;\n\t\t}\n\t\tmx = max(mx, res);\n\t}\n\tcout << mx << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<string>\n#include<sstream>\n#include<cmath>\n#include<numeric>\n#include<map>\n#include<stack>\n#include<queue>\n#include<list>\n#include<set>\nusing namespace std;\nint mod = 1e9+7;\nint h, w, k;\nvector<string> c;\nchar B = '-';\n\nvoid show(vector<string> b) {\n  for(int i=0; i<h; i++) cerr << b[i] << endl;\n  cerr << endl;\n}\n\nvector<string> del(vector<string> b) {\n  vector<string> ret = b;\n  for(int i=0; i<h; i++){\n    string s = ret[i];\n    int cnt = 0;\n    for(int j=0; j<w; j++){\n      if( s[j] == s[j+1] ) cnt++;\n      else {\n        if( cnt >= k-1 ) {\n          for(int l=0; l<cnt+1; l++){\n            s[j-l] = B;\n          }\n          cnt = 0;\n        }\n      }\n    }\n    ret[i] = s;\n  }\n  return ret;\n}\n\nvector<string> drop(vector<string> b) {\n  for(int j=0; j<w; j++){\n    string s = \"\";\n    for(int i=0; i<h; i++){\n      if( b[i][j] != B ) {\n        s += b[i][j];\n      }\n    }\n    s = string(h-s.size(), B) + s;\n    for(int i=0; i<h; i++){\n      b[i][j] = s[i];\n    }\n  }\n  return b;\n}\n\nint calc(vector<string> b) {\n  int ret = 0;\n  for(int i=0; i<h; i++) {\n    for(int j=0; j<w; j++){\n      if( b[i][j] == B ) continue;\n      ret += b[i][j]-'0';\n    }\n  }\n  return ret;\n}\n\nint simulate(vector<string> b, int x, int y) {\n\n  b[y][x] = B;\n  b = drop(b);\n  vector<string> old = b;\n  vector<string> now = b;\n  int score = 0;\n  int base = 1;\n  while( true ) {\n    now = del(now);\n    int sum = calc(old) - calc(now);\n    score += base * sum;\n    now = drop(now);\n\n    if( now == old ) break;\n    old = now;\n    base *= 2;\n  }\n  return score;\n}\n\nint main() {\n  cin >> h >> w >> k;\n  c.resize(h);\n  for(int i=0; i<h; i++){\n    cin >> c[i];\n    c[i] += B;\n  }\n\n  int ans = 0;\n  for(int i=0; i<h; i++){\n    for(int j=0; j<w; j++){\n      int tmp = simulate(c, j, i);\n      if( ans < tmp ){\n        cerr << tmp << \" \" << j << \" \" << i << endl;\n      }\n      ans = max(ans, tmp);\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n\n\n\n//\n"
  },
  {
    "language": "C++",
    "code": "#pragma once\n\n#include <iostream>\n\nlong N,Q;\nlong sara[100000]={};\nlong a[100000]={};\nlong b[100000]={};\n\n\nvoid Min(long ab,long min,long hito){\n\tfor(int i=0;i<ab;i++){\n\t\tif(sara[i]<min){\n\t\t\tmin =sara[i];\n\t\t\thito =i;\n\t\t}\n\t}\n\tsara[hito] ++;\n}\n\n\nint main(){\n\tscanf(\"%ld\\n%ld\\n\",&N,&Q);\n\n\tfor(int i=0;i<Q;i++){\n\t\tscanf(\"%ld\\n%ld\\n\",&a[i],&b[i]);\n\t}\n\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<b[i];j++){\n\t\t\tMin(a[i],100000,0);\n\t\t}\n\t}\n\n\t\n\tfor(int i=0;i<Q;i++){\n\tprintf(\"%id\\n\",sara[i]);\n\t}\n\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//temp2\n\n//#undef _DEBUG\n//#pragma GCC optimize(\"Ofast\")\n//不動小数点の計算高速化\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <bits/stdc++.h>\n\n//todo use_pbdsを消すとバグる 後で直す\n#define use_pbds\n#ifdef use_pbds\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\ntemplate<class T, class U, class W, class X> auto count(__gnu_pbds::gp_hash_table<T, U, W> &a, X k) { return a.find(k) != a.end(); }\n#endif\n\nusing namespace std;\nusing namespace std::chrono;\n\n/*@formatter:off*/\n#ifndef _DEBUG\n#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/multiprecision/cpp_dec_float.hpp>\nnamespace cmp = boost::multiprecision;\nusing cint = cmp :: cpp_int;\nusing bdou = cmp::cpp_dec_float_100;\n#endif\n#define ll long long\nusing sig_dou = double;\n\ntemplate<class T,class U> auto max(T a, U b){return a>b ? a: b;}\ntemplate<class T,class U> auto min(T a, U b){return a<b ? a: b;}\n\nnamespace helper {\n    template<class T>T s_decl2(const vector<T>& A){return (T)0;}\n    template<class T>T s_decl2(const vector<vector<T> >& A){return (T)0;}\n    template<class T>T s_decl2(const vector<vector<vector<T> > >& A){return (T)0;}\n    template<class T>T s_decl2(const vector<vector<vector<vector<T> > > >& A){return (T)0;}\n    template<class T>T s_decl2(const vector<vector<vector<vector<vector<T> > > > >& A){return (T)0;}\n    template<class T>T s_decl2(const vector<vector<vector<vector<vector<vector<T> > > > > >& A){return (T)0;}\n    //vector<vector<.....T>>でTを返す\n#define decl2(a) decltype(helper::s_decl2(a))\n}\n\n#define int long long //todo 消したら動かない intの代わりにsignedを使う\nauto start_time = system_clock::now();\nauto past_time = system_clock::now();\n\n#define debugName(VariableName) # VariableName\n//最大引数がN\n#define over2(o1, o2, name, ...) name\n#define over3(o1, o2, o3, name, ...) name\n#define over4(o1, o2, o3, o4, name, ...) name\n#define over5(o1, o2, o3, o4, o5, name, ...) name\n#define over6(o1, o2, o3, o4, o5, o6, name, ...) name\n#define over7(o1, o2, o3, o4, o5, o6, o7, name, ...) name\n#define over8(o1, o2, o3, o4, o5, o6, o7, o8, name, ...) name\n#define over9(o1, o2, o3, o4, o5, o6, o7, o8, o9, name, ...) name\n#define over10(o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, name, ...) name\n\n\n\n\n\n\n#ifdef _DEBUG\nstring message;\nstring res_mes;\n//#define use_debtor\n\n#ifdef use_debtor\n//https://marycore.jp/prog/cpp/class-extension-methods/ 違うかも\ntemplate<class T, class A = std::allocator<T>> struct debtor : std::vector<T, A> {\n    using std::vector<T, A>::vector;\n    template<class U> int deb_v(U a, int v) { return v; }\n    template<class U> int deb_v(debtor<U> &a, int v = 0) {        cerr << a.size() << \" \";        return deb_v(a.at(0), v + 1);    }\n    template<class U> void deb_o(U a) { cerr << a << \" \"; }\n    template<class U> void deb_o(debtor<U> &a) {        for (int i = 0; i < min((int) a.size(), 15ll); i++) { deb_o(a[i]); }        if ((int) a.size() > 15) { cerr << \"...\"; }        cerr << endl;    }\n    typename std::vector<T>::reference my_at(typename std::vector<T>::size_type n, vector<int> &ind) {        if (n < 0 || n >= (int) this->size()) {            int siz = (int) this->size();            cerr << \"vector size = \";            int dim = deb_v((*this));            cerr << endl;            ind.push_back(n);            cerr << \"out index at  \";            for (auto &&i: ind) {                cerr << i << \" \";            }            cerr << endl;            cerr << endl;            if (dim <= 2) { deb_o((*this)); }            exit(0);        }        return this->at(n);    }\n    typename std::vector<T>::reference operator[](typename std::vector<T>::size_type n) {        if (n < 0 || n >= (int) this->size()) {            int siz = (int) this->size();            cerr << \"vector size = \";            int dim = deb_v((*this));            cerr << endl;            cerr << \"out index at  \" << n << endl;            cerr << endl;            if (dim <= 2) { deb_o((*this)); }            exit(0);        }        return this->at(n);    }\n};\n#define vector debtor\n#endif\n#ifdef use_pbds\ntemplate<class T> struct my_pbds_tree {    set<T> s;    auto begin() { return s.begin(); }    auto end() { return s.end(); }    auto rbegin() { return s.rbegin(); }    auto rend() { return s.rend(); }    auto empty() { return s.empty(); }    auto size() { return s.size(); }    void clear() { s.clear(); }    template<class U> void insert(U v) { s.insert(v); }template<class U> void operator+=(U v) { insert(v); }    template<class F> auto erase(F v) { return s.erase(v); }    template<class U> auto find(U v) { return s.find(v); }    template<class U> auto lower_bound(U v) { return s.lower_bound(v); }    template<class U> auto upper_bound(U v) { return s.upper_bound(v); }    auto find_by_order(ll k) {        auto it = s.begin();        for (ll i = 0; i < k; i++)it++;        return it;    }    auto order_of_key(ll v) {        auto it = s.begin();        ll i=0;        for (;it != s.end() && *it <v ; i++)it++;        return i;    }};\n#define pbds(T) my_pbds_tree<T>\n#endif\n\n//区間削除は出来ない\n//gp_hash_tableでcountを使えないようにするため\ntemplate<class T, class U> struct my_unordered_map { unordered_map<T, U> m; my_unordered_map() {}; auto begin() { return m.begin(); } auto end() { return m.end(); } auto cbegin() { return m.cbegin(); } auto cend() { return m.cend(); } template<class V> auto erase(V v) { return m.erase(v); } void clear() { m.clear(); }    /*countは gp_hash_tableに存在しない*/    /*!= m.end()*/    template<class V> auto find(V v) { return m.find(v); } template<class V> auto &operator[](V n) { return m[n]; }};\n#define unordered_map my_unordered_map\n#define umapi unordered_map<ll,ll>\n#define umapp unordered_map<P,ll>\n#define umapu unordered_map<uint64_t,ll>\n#define umapip unordered_map<ll,P>\ntemplate<class T, class U, class X> auto count(unordered_map<T, U> &a, X k) { return a.find(k) != a.end(); }\n#else\n#define endl '\\n'\n//umapはunorderd_mapになる\n//umapiはgp_hash_table\n\n//find_by_order(k) k番目のイテレーター\n//order_of_key(k)  k以上が前から何番目か\n#define pbds(U) __gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>\n\n#define umapi __gnu_pbds::gp_hash_table<ll,ll,xorshift>\n#define umapp __gnu_pbds::gp_hash_table<P,ll,xorshift>\n#define umapu __gnu_pbds::gp_hash_table<uint64_t,ll,xorshift>\n#define umapip __gnu_pbds::gp_hash_table<ll,P,xorshift>\n#endif\n\n\nstruct xorshift {\n    static uint64_t splitmix64(uint64_t x) {        x += 0x9e3779b97f4a7c15;        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;        return x ^ (x >> 31);    }\n    size_t operator()(uint64_t x) const {        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        return splitmix64(x + FIXED_RANDOM);    }\n    size_t operator()(std::pair<ll, ll> x) const {        ll v = ((x.first) << 32) | x.second;        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        return splitmix64(v + FIXED_RANDOM);    }\n};\n#ifdef use_pbds\ntemplate<class U, class L> void operator+=(__gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update> &s, L v) { s.insert(v); }\n#endif\n//衝突対策\n#define ws ws_\n\ntemplate<class A, class B, class C> struct T2 { A f;B s;C t;T2() { f = 0, s = 0, t = 0; }T2(A f, B s, C t) : f(f), s(s), t(t) {}bool operator<(const T2 &r) const { return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;        /*return f != r.f ? f > r.f : s != r.s ?n s > r.s : t > r.t; 大きい順 */   } bool operator>(const T2 &r) const { return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;        /*return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順 */   } bool operator==(const T2 &r) const { return f == r.f && s == r.s && t == r.t; } bool operator!=(const T2 &r) const { return f != r.f || s != r.s || t != r.t; }};\ntemplate<class A, class B, class C, class D> struct F2 {    A a;    B b;    C c;    D d;    F2() { a = 0, b = 0, c = 0, d = 0; }    F2(A a, B b, C c, D d) : a(a), b(b), c(c), d(d) {}    bool operator<(const F2 &r) const { return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;    /*    return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;*/    }    bool operator>(const F2 &r) const { return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;/*        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;*/    }    bool operator==(const F2 &r) const { return a == r.a && b == r.b && c == r.c && d == r.d; }    bool operator!=(const F2 &r) const { return a != r.a || b != r.b || c != r.c || d != r.d; }    ll operator[](ll i) {        assert(i < 4);        return i == 0 ? a : i == 1 ? b : i == 2 ? c : d;    }};\ntypedef T2<ll, ll, ll> T;\ntypedef F2<ll, ll, ll, ll> F;\nT mt(ll a, ll b, ll c) { return T(a, b, c); }\nF mf(ll a, ll b, ll c, ll d) { return F(a, b, c, d); }\n\ntemplate<class T, class U> bool chma(T &a, const U &b) {    if (a < b) {        a = b;        return true;    }    return false;}\ntemplate<class T, class U> bool chmi(T &a, const U &b) {    if (b < a) {        a = b;        return true;    }    return false;}\n\n//関数内をまとめる\n//初期値l=0, r=-1\nvoid pr_set_lr(int &l, int &r, int n) {    /*r==-1*/    if (!(~r)) {        if(!(~l)){            l = 0;            r = n;        }else {            r = l;            l = 0;        }    }}\n//@マクロ省略系 型,構造\n//using で元のdoubleを同時に使えるはず\n#define double_big\n\n#ifdef double_big\n//#define double long double\n#define pow powl\n#endif\nusing dou = double;\nconst double eps = 1e-9;\n\n//#define use_epsdou\n#ifdef use_epsdou\n//基本コメントアウト\nstruct epsdou {    double v;    epsdou(double v = 0) : v(v) {}    template<class T> epsdou &operator+=(T b) {        v += (double) b;        return (*this);    }    template<class T> epsdou &operator-=(T b) {        v -= (double) b;        return (*this);    }    template<class T> epsdou &operator*=(T b) {        v *= (double) b;        return (*this);    }    template<class T> epsdou &operator/=(T b) {        v /= (double) b;        return (*this);    }    epsdou operator+(epsdou b) { return v + (double) b; }    epsdou operator-(epsdou b) { return v - (double) b; }    epsdou operator*(epsdou b) { return v * (double) b; }    epsdou operator/(epsdou b) { return v / (double) b; }    epsdou operator-() const { return epsdou(-v); }    template<class T> bool operator<(T b) { return v < (double) b; }    template<class T> bool operator>(T b) {auto r = (double)b;        return v > (double) b; }    template<class T> bool operator==(T b) { return fabs(v - (double) b) <= eps; }    template<class T> bool operator<=(T b) { return v < (double) b || fabs(v - b) <= eps; }    template<class T> bool operator>=(T b) { return v > (double) b || fabs(v - b) <= eps; }    operator double() { return v; }};\ntemplate<>epsdou MAX(){return MAX<double>();}\ntemplate<>epsdou MIN(){return MIN<double>();}\n//priqrity_queue等で使うのに必要\nbool operator<(const epsdou &a, const epsdou &b) {return a.v < b.v;}\nbool operator>(const epsdou &a, const epsdou &b) {return a.v > b.v;}\nistream &operator>>(istream &iss, epsdou &a) {iss >> a.v;return iss;}\nostream &operator<<(ostream &os, epsdou &a) {os << a.v;return os;}\n#define eps_conr_t(o) template<class T> epsdou operator o(T a, epsdou b) {return (dou) a o b.v;}\n#define eps_conl_t(o) template<class T> epsdou operator o(epsdou a, T b) {return a.v o (dou) b;}\neps_conl_t(+)eps_conl_t(-)eps_conl_t(*)eps_conl_t(/)eps_conr_t(+)eps_conr_t(-)eps_conr_t(*)eps_conr_t(/)\ntemplate<class U> epsdou max(epsdou a, U b){return a.v>b ? a.v: b;}\ntemplate<class U> epsdou max(U a, epsdou b){return a>b.v ? a: b.v;}\ntemplate<class U> epsdou min(epsdou a, U b){return a.v<b ? a.v: b;}\ntemplate<class U> epsdou min(U a, epsdou b){return a<b.v ? a: b.v;}\n#undef double\n#define double epsdou\n#undef dou\n#define dou epsdou\n#endif\n\n\n#define ull unsigned long long\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define el else\n#define elf else if\n#define upd update\n#define sstream stringstream\n\n#define maxq 1\n#define minq -1\n\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MALLOC(type, len) (type*)malloc((len) * sizeof(type))\n#define lam1(ret) [&](auto& v){return ret;}\n#define lam2(v, ret) [&](auto& v){return ret;}\n#define lam(...) over2(__VA_ARGS__,lam2,lam1)(__VA_ARGS__)\n#define lamr(right) [&](auto& p){return p right;}\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\n//マクロ省略系 コンテナ\nusing vi = vector<ll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vp = vector<P>;\nusing vt = vector<T>;\n\n//#define V vector\n#define vvt0(t) vector<vector<t>>\n#define vvt1(t, a) vector<vector<t>>a\n#define vvt2(t, a, b) vector<vector<t>>a(b)\n#define vvt3(t, a, b, c) vector<vector<t>> a(b,vector<t>(c))\n#define vvt4(t, a, b, c, d) vector<vector<t>> a(b,vector<t>(c,d))\n\n#define vvi(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(ll,__VA_ARGS__)\n#define vvb(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(bool,__VA_ARGS__)\n#define vvs(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(string,__VA_ARGS__)\n#define vvd(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(double,__VA_ARGS__)\n#define vvc(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(char,__VA_ARGS__)\n#define vvp(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(P,__VA_ARGS__)\n#define vvt(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(T,__VA_ARGS__)\n#define vv(type, ...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(type,__VA_ARGS__)\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...)); }\n#define vni(name, ...) auto name = make_v<ll>(__VA_ARGS__)\n#define vnb(name, ...) auto name = make_v<bool>(__VA_ARGS__)\n#define vns(name, ...) auto name = make_v<string>(__VA_ARGS__)\n#define vnd(name, ...) auto name = make_v<double>(__VA_ARGS__)\n#define vnc(name, ...) auto name = make_v<char>(__VA_ARGS__)\n#define vnp(name, ...) auto name = make_v<P>(__VA_ARGS__)\n#define vn(type, name, ...) auto name = make_v<type>(__VA_ARGS__)\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<ll, ll>;\nusing mapp = map<P, ll>;\nusing mapd = map<dou, ll>;\nusing mapc = map<char, ll>;\nusing maps = map<str, ll>;\nusing seti = set<ll>;\nusing setp = set<P>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<ll>;\n#define uset unordered_set\n#define useti unordered_set<ll,xorshift>\n#define mset multiset\n#define mseti multiset<ll>\n#define umap unordered_map\n#define mmap multimap\n//任意のマクロサポート用 使う度に初期化する\nint index_, v1_, v2_, v3_;\n\ntemplate<class T> struct pq {\n    priority_queue<T, vector<T>, greater<T> > q;/*小さい順*/    T su = 0;\n    void clear() {        q = priority_queue<T, vector<T>, greater<T> >();        su = 0;    }\n    void operator+=(T v) {        su += v;        q.push(v);    }\n    T sum() { return su; }\n    T top() { return q.top(); }\n    void pop() {        su -= q.top();        q.pop();    }\n    T poll() {        T ret = q.top();        su -= ret;        q.pop();        return ret;    }\n    ll size() { return q.size(); }\n};\ntemplate<class T> struct pqg {\n    priority_queue<T> q;/*大きい順*/    T su = 0;\n    void clear() {        q = priority_queue<T>();        su = 0;    }\n    void operator+=(T v) {su += v;        q.push(v);    }\n    T sum() { return su; }\n    T top() { return q.top(); }\n    void pop() {su -= q.top();q.pop();}\n    T poll() {        T ret = q.top();        su -= ret;        q.pop();        return ret;    }\n    ll size() { return q.size(); }\n};\n#define pqi pq<ll>\n#define pqgi pqg<ll>\n//マクロ 繰り返し\n//↓@オーバーロード隔離\n\n#define rep1(n) for(ll rep1i = 0,rep1lim=n; rep1i < rep1lim ; ++rep1i)\n#define rep2(i, n) for(ll i = 0,rep2lim=n; i < rep2lim ; ++i)\n#define rep3(i, m, n) for(ll i = m,rep3lim=n; i < rep3lim ; ++i)\n#define rep4(i, m, n, ad) for(ll i = m,rep4lim=n; i < rep4lim ; i+= ad)\n//逆順 閉区間\n#define rer2(i, n) for(ll i = n; i >= 0 ; i--)\n#define rer3(i, m, n) for(ll i = m,rer3lim=n; i >= rer3lim ; i--)\n#define rer4(i, m, n, dec) for(ll i = m,rer4lim=n; i >= rer4lim ; i-=dec)\n//ループを一つにまとめないとフォーマットで汚くなるため\n#define nex_ind1(i) i++\n#define nex_ind2(i, j, J) i = (j + 1 == J) ? i + 1 : i, j = (j + 1 == J ? 0 : j + 1)\n#define nex_ind3(i, j, k, J, K)i = (j + 1 == J && k + 1 == K) ? i + 1 : i, j = (k + 1 == K) ? (j + 1 == J ? 0 : j + 1) : j, k = (k + 1 == K ? 0 : k + 1)\n#define nex_ind4(i, j, k, l, J, K, L) i = (j + 1 == J && k + 1 == K && l + 1 == L) ? i + 1 : i, j = (k + 1 == K && l + 1 == L) ? (j + 1 == J ? 0 : j + 1) : j, k = (l + 1 == L ?(k + 1 == K ? 0 : k + 1) : k), l = l + 1 == L ? 0 : l + 1\n#define nex_ind5(i, j, k, l, m, J, K, L, M) i = (j + 1 == J && k + 1 == K && l + 1 == L && m + 1 == M) ? i + 1 : i, j = (k + 1 == K && l + 1 == L && m + 1 == M) ? (j + 1 == J ? 0 : j + 1) : j, k = (l + 1 == L && m + 1 == M ?(k + 1 == K ? 0 : k + 1) : k), l =  m + 1 == M ? l+1 == L ? 0 : l+1 : l,  m = m + 1 == M ? 0 : m + 1\n\n#define repss2(i, I) for (int i = 0; i < I; i++)\n#define repss4(i, j, I, J) for (int i = (J ? 0 : I), j = 0; i < I; nex_ind2(i, j, J))\n#define repss6(i, j, k, I, J, K) for (int i = (J && K ? 0 : I), j = 0, k = 0; i < I; nex_ind3(i, j, k, J, K))\n#define repss8(i, j, k, l, I, J, K, L) for (int i = (J && K && L ? 0 : I), j = 0, k = 0, l = 0; i < I; nex_ind4(i, j, k, l, J, K, L))\n#define repss10(i, j, k, l, m, I, J, K, L, M)for (int i = (J && K && L && M ? 0 : I), j = 0, k = 0, l = 0, m = 0; i < I; nex_ind5(i, j, k, l, m, J, K, L, M))\n\n//i,j,k...をnまで見る\n#define reps2(i, n) repss2(i, n)\n#define reps3(i, j, n) repss4(i, j, n, n)\n#define reps4(i, j, k, n) repss6(i, j, k, n, n, n)\n#define reps5(i, j, k, l, n) repss8(i, j, k, l, n, n, n, n)\n\ntemplate<class T> void nex_repv2(int &i, int &j, int &I, int &J, vector<vector<T>> &s) {    while (1) {        j++;        if (j >= J) {            j = 0;            i++;            if (i < I) { J = (int) s[i].size(); }        }        if (i >= I || J) return;    }}\ntemplate<class T> void nex_repv3(int &i, int &j, int &k, int &I, int &J, int &K, vector<vector<vector<T>>> &s) {    while (1) {        k++;        if (k >= K) {            k = 0;            j++;            if (j >= J) {                j = 0;                i++;                if (i >= I)return;            }        }        J = (int) s[i].size();        K = (int) s[i][j].size();        if (J && K) return;    }}\n\n#define repv_2(i, a) repss2(i, sz(a))\n//正方形である必要はない\n//直前を持つのとどっちが早いか\n#define repv_3(i, j, a) for (int repvI = (int)a.size(), repvJ = (int)a[0].size(), i = 0, j = 0; i < repvI; nex_repv2(i,j,repvI,repvJ,a))\n//箱状になっている事が要求される つまり[i] 次元目の要素数は一定\n#define repv_4(i, j, k, a) for (int repvI = (int)a.size(), repvJ = (int)a[0].size(), repvK =(int)a[0][0].size(), i = 0, j = 0, k=0; i < repvI; nex_repv3(i,j,k,repvI,repvJ,repvK,a))\n#define repv_5(i, j, k, l, a) repss8(i, j, k, l, sz(a), sz(a[0]), sz(a[0][0]), sz(a[0][0][0]))\n#define repv_6(i, j, k, l, m, a) repss10(i, j, k, l, m, sz(a), sz(a[0]), sz(a[0][0]), sz(a[0][0][0]), sz(a[0][0][0][0]))\n\ntemplate<typename T> struct has_rbegin_rend { private:template<typename U> static auto check(U &&obj) -> decltype(std::rbegin(obj), std::rend(obj), std::true_type{});static std::false_type check(...);public:static constexpr bool value = decltype(check(std::declval<T>()))::value; };\ntemplate<typename T> constexpr bool has_rbegin_rend_v = has_rbegin_rend<T>::value;\ntemplate<typename Iterator> class Range { public:Range(Iterator &&begin, Iterator &&end) noexcept: m_begin(std::forward<Iterator>(begin)), m_end(std::forward<Iterator>(end)) {}Iterator begin() const noexcept { return m_begin; }Iterator end() const noexcept { return m_end; }private:const Iterator m_begin;const Iterator m_end; };\ntemplate<typename Iterator> static inline Range<Iterator> makeRange(Iterator &&begin, Iterator &&end) noexcept { return Range<Iterator>{std::forward<Iterator>(begin), std::forward<Iterator>(end)}; }\ntemplate<typename T> static inline decltype(auto) makeReversedRange(const std::initializer_list<T> &iniList) noexcept { return makeRange(std::rbegin(iniList), std::rend(iniList)); }\ntemplate<typename T, typename std::enable_if_t<has_rbegin_rend_v<T>, std::nullptr_t> = nullptr> static inline decltype(auto) makeReversedRange(T &&c) noexcept { return makeRange(std::rbegin(c), std::rend(c)); }/* rbegin(), rend()を持たないものはこっちに分岐させて，エラーメッセージを少なくする*/template<typename T, typename std::enable_if<!has_rbegin_rend<T>::value, std::nullptr_t>::type = nullptr> static inline void makeReversedRange(T &&) noexcept { static_assert(has_rbegin_rend<T>::value, \"Specified argument doesn't have reverse iterator.\"); }\n\n//#define use_for\n\n#define form1(st) for (auto &&form_it = st.begin(); form_it != st.end(); ++form_it)\n#define form3(k, v, st) for (auto &&form_it = st.begin(); form_it != st.end(); ++form_it)\n#define form4(k, v, st, r) for (auto &&form_it = st.begin(); form_it != st.end() && (*form_it).fi < r; ++form_it)\n#define form5(k, v, st, l, r) for (auto &&form_it = st.lower_bound(l); form_it != st.end() && (*form_it).fi < r; ++form_it)\n\n#define forrm1(st) for (auto &&forrm_it = st.rbegin(); forrm_it != st.rend(); ++forrm_it)\n#define forrm3(k, v, st) for (auto &&forrm_it = st.rbegin(); forrm_it != st.rend(); ++forrm_it)\n\n//向こう側で\n// ++itか it = st.erase(it)とする\n#define fors1(st) for (auto &&it = st.begin(); it != st.end(); )\n#define fors2(v, st) for (auto &&it = st.begin(); it != st.end(); )\n#define fors3(v, st, r) for (auto &&it = st.begin(); it != st.end() && (*it) < r; )\n#define fors4(v, st, l, r) for (auto &&it = st.lower_bound(l); it != st.end() && (*it) < r; )\n\n#ifdef use_for\n#define forslr3(st, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end(); ++forslr_it)\n#define forslr4(v, st, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end(); ++forslr_it)\n#define forslr5(v, st, r, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end() && (*forslr_it) < r; ++forslr_it)\n#define forslr6(v, st, l, r, a, b) for (auto &&forslr_it = st.lower_bound(l); forslr_it != st.end() && (*forslr_it) < r; ++forslr_it)\n#endif\n\n#define fora_init_2(a, A) ;\n#define fora_init_3(fora_i, a, A) auto &&a = A[fora_i];\n#define fora_init_4(a, b, A, B) auto &&a = A[fora_i]; auto &&b = B[fora_i];\n#define fora_init_5(fora_i, a, b, A, B) auto &&a = A[fora_i]; auto &&b = B[fora_i];\n#define fora_init_6(a, b, c, A, B, C) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i];\n#define fora_init_7(fora_i, a, b, c, A, B, C) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i];\n#define fora_init_8(a, b, c, d, A, B, C, D) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i]; auto && d = D[fora_i];\n#define fora_init_9(fora_i, a, b, c, d, A, B, C, D) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i]; auto && d = D[fora_i];\n#define fora_init(...) over9(__VA_ARGS__,fora_init_9, fora_init_8, fora_init_7, fora_init_6, fora_init_5, fora_init_4, fora_init_3, fora_init_2)(__VA_ARGS__)\n\n#ifdef use_for\n#define forr_init_2(a, A) auto &&a = A[forr_i];\n#define forr_init_3(forr_i, a, A) auto &&a = A[forr_i];\n#define forr_init_4(a, b, A, B) auto &&a = A[forr_i]; auto &&b = B[forr_i];\n#define forr_init_5(forr_i, a, b, A, B) auto &&a = A[forr_i]; auto &&b = B[forr_i];\n#define forr_init_6(a, b, c, A, B, C) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i];\n#define forr_init_7(forr_i, a, b, c, A, B, C) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i];\n#define forr_init_8(a, b, c, d, A, B, C, D) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i]; auto && d = D[forr_i];\n#define forr_init_9(forr_i, a, b, c, d, A, B, C, D) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i]; auto && d = D[forr_i];\n#define forr_init(...) over9(__VA_ARGS__, forr_init_9, forr_init_8, forr_init_7, forr_init_6, forr_init_5, forr_init_4, forr_init_3, forr_init_2)(__VA_ARGS__)\n\n#define forp_init3(k, v, S) auto &&k = S[forp_i].first;auto &&v = S[forp_i].second;\n#define forp_init4(forp_i, k, v, S) auto &&k = S[forp_i].first;auto &&v = S[forp_i].second;\n#define forp_init(...) over4(__VA_ARGS__,forp_init4,forp_init3,forp_init2,forp_init1)(__VA_ARGS__)\n\n#define form_init(k, v, ...) auto &&k = (*form_it).fi;auto &&v = (*form_it).se;\n#define forrm_init(k, v, ...) auto &&k = (*forrm_it).fi;auto &&v = (*forrm_it).se;\n#endif\n#define fors_init(v, ...) auto &&v = (*it);\n\n#ifdef use_for\n#define forlr_init(a, A, ngl, ngr) auto a = A[forlr_i]; auto prev = forlr_i ? A[forlr_i-1] : ngl;auto next = forlr_i+1< rep2lim? A[forlr_i+1] : ngr;\n#define forslr_init4(a, A, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init5(a, A, r, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init6(a, A, l, r, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init(...)  over6(__VA_ARGS__,forslr_init6,forslr_init5,forslr_init4)(__VA_ARGS__);\n#endif\n\n#define fora_2(a, A) for(auto&& a : A)\n#define fora_3(fora_i, a, A) rep(fora_i, sz(A))\n#define fora_4(a, b, A, B) rep(fora_i, sz(A))\n#define fora_5(fora_i, a, b, A, B) rep(fora_i, sz(A))\n#define fora_6(a, b, c, A, B, C) rep(fora_i, sz(A))\n#define fora_7(fora_i, a, b, c, A, B, C) rep(fora_i, sz(A))\n#define fora_8(a, b, c, d, A, B, C, D) rep(fora_i, sz(A))\n#define fora_9(fora_i, a, b, c, d, A, B, C, D) rep(fora_i, sz(A))\n\n#ifdef use_for\n#define forr_2(a, A) rer(forr_i, sz(A)-1)\n#define forr_3(forr_i, a, A) rer(forr_i, sz(A)-1)\n#define forr_4(a, b, A, B) rer(forr_i, sz(A)-1)\n#define forr_5(forr_i, a, b, A, B) rer(forr_i, sz(A)-1)\n#define forr_6(a, b, c, A, B, C) rer(forr_i, sz(A)-1)\n#define forr_7(forr_i, a, b, c, A, B, C) rer(forr_i, sz(A)-1)\n#define forr_8(a, b, c, d, A, B, C, D) rer(forr_i, sz(A)-1)\n#define forr_9(forr_i, a, b, c, d, A, B, C, D) rer(forr_i, sz(A)-1)\n#endif\n//↑@オーバーロード隔離\n\n//rep系はインデックス、for系は中身\n#define rep(...) over4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rer(...) over4(__VA_ARGS__,rer4,rer3,rer2,)(__VA_ARGS__)\n//char用のrep\n#define repc(i, m, n) for(char i = m,repc3lim=n; i < repc3lim ; ++i)\n//i,j,k...をnまで見る\n#define reps(...) over5(__VA_ARGS__,reps5,reps4,reps3,reps2,)(__VA_ARGS__)\n#define repss(...) over10(__VA_ARGS__, repss10, a, repss8, a, repss6, a, repss4, a, repss2) (__VA_ARGS__)\n//vectorのindexを走査する\n//repv(i,j,vvi)\n#define repv(...) over6(__VA_ARGS__,repv_6,repv_5,repv_4,repv_3,repv_2,)(__VA_ARGS__)\n#define rerv(i, A) for (int i = sz(A)-1; i >= 0 ; i--)\n//repvn(dp) nは次元\n#define repv1(a) repv(i, a)\n#define repv2(a) repv(i, j, a)\n#define repv3(a) repv(i, j, k, a)\n#define repv4(a) repv(i, j, k, l, a)\n\n#define fora(...) over9(__VA_ARGS__, fora_9, fora_8, fora_7, fora_6, fora_5, fora_4, fora_3, fora_2)(__VA_ARGS__)\n#define forr(...) over9(__VA_ARGS__, forr_9, forr_8, forr_7, forr_6, forr_5, forr_4, forr_3, forr_2)(__VA_ARGS__)\n//0~N-2まで見る\n\n#define forar_init(v, rv, A) auto &&v = A[forar_i]; auto && rv = A[forar_i+1];\n#define forar(v, rv, A) rep(forar_i, sz(A) - 1)\n\n//#define forr(v, a) for(auto&& v : makeReversedRange(a))\n//参照を取らない\n#ifdef use_for\ntemplate<class U> vector<U> to1d(vector<U> &a) { return a; }template<class U> auto to1d(vector<vector<U>> &a) {    vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)res.push_back(a2);    return res;}template<class U> vector<U> to1d(vector<vector<vector<U>>> &a) {    vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)for (auto &&a3 : a2) res.push_back(a3);    return res;}template<class U> vector<U> to1d(vector<vector<vector<vector<U>>>> &a) {    vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)for (auto &&a3 : a2) for (auto &&a4 : a3)res.push_back(a4);    return res;}template<class U> vector<U> to1d(vector<vector<vector<vector<vector<U>>>>> &a) {    vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)for (auto &&a3 : a2) for (auto &&a4 : a3)for (auto &&a5 : a4)res.push_back(a5);    return res;}template<class U> vector<U> to1d(vector<vector<vector<vector<vector<vector<U>>>>>> &a) {    vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)for (auto &&a3 : a2) for (auto &&a4 : a3)for (auto &&a5 : a4)for (auto &&a6 : a5)res.push_back(a6);    return res;}\n#define forv(a, b) for(auto a : to1d(b))\n//インデックスを前後含めて走査\n#define ring(i, s, len) for (int i = s, prev = (s == 0) ? len - 1 : s - 1, next = (s == len - 1) ? 0 : s + 1, cou = 0; cou < len; cou++, prev = i, i = next, next = (next == len - 1) ? 0 : next + 1)\n//値と前後を見る\n#define ringv(v, d) index_=0;for (auto prev = d[sz(d)-1],next= (int)d.size()>1?d[1]:d[0],v = d[0]; index_ < sz(d); index_++, prev = v, v = next, next = (index_>=sz(d)-1?d[0]:d[index_+1]))\n// 左右をnext prevで見る 0の左と nの右\n#define forlr(v, d, banpei_l, banpei_r) rep(forlr_i,sz(d))\n#endif\n\n#define form(...) over5(__VA_ARGS__,form5,form4,form3,form2,form1)(__VA_ARGS__)\n#define forrm(...) over5(__VA_ARGS__,forrm5,forrm4,forrm3,forrm2,forrm1)(__VA_ARGS__)\n#define fors(...) over4(__VA_ARGS__,fors4,fors3,fors2,fors1)(__VA_ARGS__)\n#define forslr(...) over6(__VA_ARGS__,forslr6,forslr5,forslr4,forslr3)(__VA_ARGS__)\n#define forp3(k, v, st)  rep(forp_i,sz(st))\n#define forp4(forp_i, k, v, st) rep(forp_i,sz(st))\n#define forp(...) over4(__VA_ARGS__,forp4,forp3)(__VA_ARGS__)\n\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\ntemplate<class T> T MAX() { return numeric_limits<T>::max(); }\ntemplate<class T> T MIN() { return numeric_limits<T>::min(); }\nconstexpr ll inf = (ll) 1e9 + 100;\nconstexpr ll linf = (ll) 1e18 + 100;\nconstexpr dou dinf = (dou) linf * linf;\nconstexpr char infc = '{';\nconst string infs = \"{\";\n\ntemplate<class T> T INF(){return MAX<T>() / 2;}\ntemplate<> signed INF(){return inf;}\ntemplate<> ll INF(){return linf;}\ntemplate<> double INF(){return dinf;}\ntemplate<> char INF(){return infc;}\ntemplate<> string INF(){return infs;}\n\nconst double PI = 3.1415926535897932384626433832795029L;\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((ll)(a).size())\n#define mp make_pair\n#define pb pop_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconstexpr bool ev(ll a) { return !(a & 1); }\nconstexpr bool od(ll a) { return (a & 1); }\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> { public:size_t operator()(const std::pair<signed, signed> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n    template<> class hash<std::pair<ll, ll>> { public:/*大きいllが渡されると、<<32でオーバーフローするがとりあえず問題ないと判断*/size_t operator()(const std::pair<ll, ll> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n}\n//stream まとめ\nistream &operator>>(istream &iss, P &a) {    iss >> a.first >> a.second;    return iss;}template<typename T> istream &operator>>(istream &iss, vector<T> &vec_) {    for (T &x: vec_) iss >> x;    return iss;}template<class T, class U> ostream &operator<<(ostream &os, pair<T, U> p) {    os << p.fi << \" \" << p.se;    return os;}ostream &operator<<(ostream &os, T p) {    os << p.f << \" \" << p.s << \" \" << p.t;    return os;}ostream &operator<<(ostream &os, F p) {    os << p.a << \" \" << p.b << \" \" << p.c << \" \" << p.d;    return os;}template<typename T> ostream &operator<<(ostream &os, vector<T> &vec_) {    for (ll i = 0; i < vec_.size(); ++i)os << vec_[i] << (i + 1 == vec_.size() ? \"\" : \" \");    return os;}template<typename T> ostream &operator<<(ostream &os, vector<vector<T>> &vec_) {    for (ll i = 0; i < vec_.size(); ++i) {        for (ll j = 0; j < vec_[i].size(); ++j) { os << vec_[i][j] << \" \"; }        os << endl;    }    return os;}template<typename T, typename U> ostream &operator<<(ostream &os, map<T, U> &m) {    os << endl;    for (auto &&v:m) os << v << endl;    return os;}template<class T> ostream &operator<<(ostream &os, set<T> s) {    fora(v, s) { os << v << \" \"; }    return os;}template<class T> ostream &operator<<(ostream &os, mset<T> s) {    fora(v, s) { os << v << \" \"; }    return os;}template<class T> ostream &operator<<(ostream &os, deque<T> a) {    fora(v, a)os << v << \" \";    return os;}ostream &operator<<(ostream &os, vector<vector<char>> &vec_) {    rep(h, sz(vec_)) {        rep(w, sz(vec_[0])) { os << vec_[h][w]; }        os << endl;    }    return os;}\n//template<class T,class U>ostream &operator<<(ostream &os, vector<pair<T,U>>& a) {fora(v,a)os<<v<<endl;return os;}\ntemplate<typename W, typename H> void resize(W &vec_, const H head) { vec_.resize(head); }\ntemplate<typename W, typename H, typename ... T> void resize(W &vec_, const H &head, const T ... tail) {vec_.resize(head);for (auto &v: vec_)resize(v, tail...);}\n#define use_for_each  //_each _all_of _any_of _none_of _find_if _rfind_if _contains _count_if _erase_if _entry_if\n#ifdef use_for_each\ntemplate<typename T, typename F> bool all_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool all_of2(const vector<T> &v, F f) {rep(i, sz(v)) { if (!all_of2(v[i], f))return false; }return true;}\ntemplate<typename T, typename F> bool any_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool any_of2(const vector<T> &v, F f) {    rep(i, sz(v)) { if (any_of2(v[i], f))return true; }    return false;}\ntemplate<typename T, typename F> bool none_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool none_of2(const vector<T> &v, F f) {    rep(i, sz(v)) { if (none_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool find_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll find_if2(const vector<T> &v, F f) {    rep(i, sz(v)) { if (find_if2(v[i], f))return i; }    return sz(v);}\ntemplate<typename T, typename F> bool rfind_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll rfind_if2(const vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (rfind_if2(v[i], f))return i; }    return -1;}\ntemplate<class T> bool contains(string &s, const T &v) { return s.find(v) != string::npos; }\ntemplate<typename T> bool contains(const vector<T> &v, const T &val) { return std::find(v.begin(), v.end(), val) != v.end(); }\ntemplate<typename T, typename F> bool contains_if2(const vector<T> &v, F f) { return find_if(v.begin(), v.end(), f) != v.end(); }\ntemplate<typename T, typename F> ll count_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll count_if2(const vector<T> &vec_, F f) {    ll ret = 0;    fora(v, vec_)ret += count_if2(v, f);    return ret;}\n//template<typename T, typename F> void for_each2(T &v, F f) { f(v); }\n//template<typename T, typename F> void for_each2(vector<T> &vec_, F f) { fora(v, vec_)for_each2(v, f); }\ntemplate<typename T, typename F> void for_each2(vector<T> &a, F f) { rep(i, sz(a))f(a[i]); }\ntemplate<typename T, typename F> void for_each2(vector<vector<T> > &a, F f) { rep(i, sz(a))rep(j, sz(a[i]))f(a[i][j]); }\ntemplate<typename T, typename F> void for_each2(vector<vector<vector<T> > > &a, F f) { rep(i, sz(a))rep(j, sz(a[i]))rep(k, sz(a[i][j]))f(a[i][j][k]); }\n\ntemplate<typename W> ll count_od(const vector<W> &a) { return count_if2(a, [](ll v) { return v & 1; }); }\ntemplate<typename W> ll count_ev(const vector<W> &a) { return count_if2(a, [](ll v) { return !(v & 1); }); }\n//削除した後のvectorを返す\ntemplate<typename T, typename F> vector<T> erase_if2(const vector<T> &v, F f) {    vector<T> nv;    rep(i, sz(v)) { if (!f(v[i])) { nv.push_back(v[i]); }}    return nv;}\ntemplate<typename T, typename F> vector<vector<T>> erase_if2(const vector<vector<T>> &v, F f) {    vector<vector<T>> res;    rep(i, sz(v)) { res[i] = erase_if2(v[i], f); }    return res;}\ntemplate<typename T, typename F> vector<T> l_erase_if2(const vector<T> &v, F f) {    vector<T> nv;    rep(i, sz(v)) { if (!f(v[i])) { nv.push_back(v[i]); }}    return nv;}\n\ntemplate<typename T, typename F> ll l_rfind_if(const vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (f(v[i]))return i; }    return -1;}\ntemplate<typename T, typename F> bool l_contains_if(const vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (f(v[i]))return true; }    return false;}\ntemplate<class A, class B, class C> auto t_all_of(A a, B b, C c) { return std::all_of(a, b, c); }\ntemplate<class A, class B, class C> auto t_any_of(A a, B b, C c) { return std::any_of(a, b, c); }\ntemplate<class A, class B, class C> auto t_none_of(A a, B b, C c) { return std::none_of(a, b, c); }\ntemplate<class A, class B, class C> auto t_find_if(A a, B b, C c) { return std::find_if(a, b, c); }\ntemplate<class A, class B, class C> auto t_count_if(A a, B b, C c) { return std::count_if(a, b, c); }\n\n#define all_of_s__2(a, right) (t_all_of(all(a),lamr(right)))\n#define all_of_s__3(a, v, siki) (t_all_of(all(a),[&](auto v){return siki;}))\n#define all_of_s(...) over3(__VA_ARGS__,all_of_s__3,all_of_s__2)(__VA_ARGS__)\n\n//all_of(A, %2);\n//all_of(A, a, a%2);\n#define all_of__2(a, right) all_of2(a,lamr(right))\n#define all_of__3(a, v, siki) all_of2(a,[&](auto v){return siki;})\n#define all_of(...) over3(__VA_ARGS__,all_of__3,all_of__2)(__VA_ARGS__)\n#define all_of_f(a, f) all_of2(a,f)\n\n#define any_of_s__2(a, right) (t_any_of(all(a),lamr(right)))\n#define any_of_s__3(a, v, siki) (t_any_of(all(a),[&](auto v){return siki;}))\n#define any_of_s(...) over3(__VA_ARGS__,any_of_s__3,any_of_s__2)(__VA_ARGS__)\n\n#define any_of__2(a, right) any_of2(a,lamr(right))\n#define any_of__3(a, v, siki) any_of2(a,[&](auto v){return siki;})\n#define any_of(...) over3(__VA_ARGS__,any_of__3,any_of__2)(__VA_ARGS__)\n#define any_of_f(a, f) any_of2(a,f)\n\n#define none_of_s__2(a, right) (t_none_of(all(a),lamr(right)))\n#define none_of_s__3(a, v, siki) (t_none_of(all(a),[&](auto v){return siki;}))\n#define none_of_s(...) over3(__VA_ARGS__,none_of_s__3,none_of_s__2)(__VA_ARGS__)\n\n#define none_of__2(a, right) none_of2(a,lamr(right))\n#define none_of__3(a, v, siki) none_of2(a,[&](auto v){return siki;})\n#define none_of(...) over3(__VA_ARGS__,none_of__3,none_of__2)(__VA_ARGS__)\n#define none_of_f(a, f) none_of2(a,f)\n\n#define find_if_s__2(a, right) (t_find_if(all(a),lamr(right))-a.begin())\n#define find_if_s__3(a, v, siki) (t_find_if(all(a),[&](auto v){return siki;})-a.begin())\n#define find_if_s(...) over3(__VA_ARGS__,find_if_s__3,find_if_s__2)(__VA_ARGS__)\n\n#define find_if__2(a, right) find_if2(a,lamr(right))\n#define find_if__3(a, v, siki) find_if2(a,[&](auto v){return siki;})\n#define find_if(...) over3(__VA_ARGS__,find_if__3,find_if__2)(__VA_ARGS__)\n#define find_if_f(a, f) find_if2(a,f)\n\n#define rfind_if_s__2(a, right) l_rfind_if(a, lamr(right))\n#define rfind_if_s__3(a, v, siki) l_rfind_if(a, [&](auto v){return siki;})\n#define rfind_if_s(...) over3(__VA_ARGS__,rfind_if_s__3,rfind_if_s__2)(__VA_ARGS__)\n\n#define rfind_if__2(a, right) rfind_if2(a,lamr(right))\n#define rfind_if__3(a, v, siki) rfind_if2(a,[&](auto v){return siki;})\n#define rfind_if(...) over3(__VA_ARGS__,rfind_if__3,rfind_if__2)(__VA_ARGS__)\n#define rfind_if_f(a, f) rfind_if2(a,f)\n\n#define contains_if_s__2(a, right) l_contains_if(a, lamr(right))\n#define contains_if_s__3(a, v, siki) l_contains_if(a, [&](auto v){return siki;})\n#define contains_if_s(...) over3(__VA_ARGS__,contains_if_s__3,contains_if_s__2)(__VA_ARGS__)\n\n#define contains_if__2(a, right) contains_if2(a,lamr(right))\n#define contains_if__3(a, v, siki) contains_if2(a,[&](auto v){return siki;})\n#define contains_if(...) over3(__VA_ARGS__,contains_if__3,contains_if__2)(__VA_ARGS__)\n#define contains_if_f(a, f) contains_if2(a,f)\n\n#define count_if_s__2(a, right) (t_count_if(all(a),lamr(right)))\n#define count_if_s__3(a, v, siki) (t_count_if(all(a),[&](auto v){return siki;}))\n#define count_if_s(...) over3(__VA_ARGS__,count_if_s__3,count_if_s__2)(__VA_ARGS__)\n\n#define count_if__2(a, right) count_if2(a,lamr(right))\n#define count_if__3(a, v, siki) count_if2(a,[&](auto v){return siki;})\n#define count_if(...) over3(__VA_ARGS__,count_if__3,count_if__2)(__VA_ARGS__)\n#define count_if_f(a, f) count_if2(a,f)\n\n//vector<vi>で、viに対して操作\n#define for_each_s__2(a, right) do{fora(v,a){v right;}}while(0)\n#define for_each_s__3(a, v, shori) do{fora(v,a){shori;}}while(0)\n#define for_each_s(...) over3(__VA_ARGS__,for_each_s__3,for_each_s__2)(__VA_ARGS__)\n\n//vector<vi>で、intに対して操作\n#define for_each__2(a, right) for_each2(a,lamr(right))\n#define for_each__3(a, v, shori) for_each2(a,[&](auto& v){shori;})\n#define for_each(...) over3(__VA_ARGS__,for_each__3,for_each__2)(__VA_ARGS__)\n#define for_each_f(a, f) for_each2(a, f);\n\n#define for_eached__2(a, right) [&](auto a) {auto b = a;for_each(b, right);return b; }(a)\n#define for_eached__3(a, v, shori) [&](auto a) {auto b = a;for_each(b, v, shori);return b; }(a)\n#define for_eached(...) over3(__VA_ARGS__,for_eached__3,for_eached__2)(__VA_ARGS__)\n#define for_eached_f(a, f) for_eached2(a, f);\n\n\n#define erase_if_s__2(a, right) l_erase_if2(a,lamr(right))\n#define erase_if_s__3(a, v, siki) l_erase_if2(a,[&](auto v){return siki;})\n#define erase_if_s(...) over3(__VA_ARGS__,erase_if_s__3,erase_if_s__2)(__VA_ARGS__)\n\n\n#define erase_if__2(a, right) erase_if2(a,lamr(right))\n#define erase_if__3(a, v, siki) erase_if2(a,[&](auto v){return siki;})\n#define erase_if(...) over3(__VA_ARGS__,erase_if__3,erase_if__2)(__VA_ARGS__)\n#define erase_if_f(a, f) erase_if2(a,f)\n\n#define entry_if_s__2(a, right) l_entry_if2(a,lamr(right))\n#define entry_if_s__3(a, v, siki) l_entry_if2(a,[&](auto v){return siki;})\n#define entry_if_s(...) over3(__VA_ARGS__,entry_if_s__3,entry_if_s__2)(__VA_ARGS__)\n\n\n#define entry_if__2(a, right) entry_if2(a,lamr(right))\n#define entry_if__3(a, v, siki) entry_if2(a,[&](auto v){return siki;})\n#define entry_if(...) over3(__VA_ARGS__,entry_if__3,entry_if__2)(__VA_ARGS__)\n#define entry_if_f(a, f) entry_if2(a,f)\n\n#endif\n\ntemplate<class T, class U, class W> void replace(vector<W> &a, T key, U v) { rep(i, sz(a))if (a[i] == key)a[i] = v; }\ntemplate<class T, class U, class W> void replace(vector<vector<W>> &A, T key, U v) { rep(i, sz(A))replace(A[i], key, v); }\nvoid replace(str &a, char key, str v) { if (v == \"\")a.erase(remove(all(a), key), a.end()); }\nvoid replace(str &a, char key, char v) { replace(all(a), key, v); }\n//keyと同じかどうか01で置き換える\ntemplate<class T, class U> void replace(vector<T> &a, U k) { rep(i, sz(a)) a[i] = a[i] == k; }\ntemplate<class T, class U> void replace(vector<vector<T >> &a, U k) { rep(i, sz(a))rep(j, sz(a[0])) a[i][j] = a[i][j] == k; }\n//template<class T> void replace(T &a) { replace(a, '#'); }\nvoid replace(str &a) {    int dec = 0;    if ('a' <= a[0] && a[0] <= 'z')dec = 'a';    if ('A' <= a[0] && a[0] <= 'Z')dec = 'A';    fora(v, a)v -= dec;}\nvoid replace(str &a, str key, str v) {    stringstream t;    ll kn = sz(key);    std::string::size_type Pos(a.find(key));    ll l = 0;    while (Pos != std::string::npos) {        t << a.substr(l, Pos - l);        t << v;        l = Pos + kn;        Pos = a.find(key, Pos + kn);    }    t << a.substr(l, sz(a) - l);    a = t.str();}\n\ntemplate<class T> bool includes(vector<T> &a, vector<T> &b) {    vi c = a;    vi d = b;    sort(all(c));    sort(all(d));    return includes(all(c), all(d));}\ntemplate<class T> bool is_permutation(vector<T> &a, vector<T> &b) { return is_permutation(all(a), all(b)); }\ntemplate<class T> bool next_permutation(vector<T> &a) { return next_permutation(all(a)); }\nvoid iota(vector<ll> &ve, ll s, ll n) {    ve.resize(n);    iota(all(ve), s);}\nvi iota(ll s, ll len) {    vi ve(len);    iota(all(ve), s);    return ve;}\ntemplate<class A, class B> auto vtop(vector<A> &a, vector<B> &b) {    assert(sz(a) == sz(b));    /*stringを0で初期化できない  */  vector<pair<A, B>> res;    rep(i, sz(a))res.eb(a[i], b[i]);    return res;}\ntemplate<class A, class B> void ptov(vector<pair<A, B>> &p, vector<A> &a, vector<B> &b) {    a.resize(sz(p)), b.resize(sz(p));    rep(i, sz(p))a[i] = p[i].fi, b[i] = p[i].se;}\ntemplate<class A, class B, class C> auto vtot(vector<A> &a, vector<B> &b, vector<C> &c) {    assert(sz(a) == sz(b) && sz(b) == sz(c));    vector<T2<A, B, C>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i]);    return res;}\ntemplate<class A, class B, class C, class D> auto vtof(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    assert(sz(a) == sz(b) && sz(b) == sz(c) && sz(c) == sz(d));    vector<F2<A, B, C, D>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i], d[i]);    return res;}\n\ntemplate<class T> void sort(vector<T> &a) { sort(all(a)); }\ntemplate<class T> void rsort(vector<T> &a) { sort(all(a), greater<T>()); };\ntemplate<class A, class B> void sortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    sort(c);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}\ntemplate<class A, class B> void rsortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    rsort(c);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}\ntemplate<class A, class B, class C> void sortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    sort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    rsort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class... T, class U> auto sorted(U head, T... a) {    sort(head, a...);    return head;}\ntemplate<class... T, class U> auto rsorted(U head, T... a) {    rsort(head, a...);    return head;}\n//sortindex 元のvectorはソートしない\ntemplate<class T> vi sorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind);    return ind;}\n//#define use_sort\n#ifdef use_sort\nenum pcomparator { fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd };\nenum tcomparator {    fisiti,    fisitd,    fisdti,    fisdtd,    fdsiti,    fdsitd,    fdsdti,    fdsdtd,    fitisi,    fitisd,    fitdsi,    fitdsd,    fdtisi,    fdtisd,    fdtdsi,    fdtdsd,    sifiti,    sifitd,    sifdti,    sifdtd,    sdfiti,    sdfitd,    sdfdti,    sdfdtd,    sitifi,    sitifd,    sitdfi,    sitdfd,    sdtifi,    sdtifd,    sdtdfi,    sdfdfd,    tifisi,    tifisd,    tifdsi,    tifdsd,    tdfisi,    tdfisd,    tdfdsi,    tdfdsd,    tisifi,    tisifd,    tisdfi,    tisdfd,    tdsifi,    tdsifd,    tdsdfi,    tdsdfd};\ntemplate<class A, class B> void sort(vector<pair<A, B>> &a, pcomparator type) {    typedef pair<A, B> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; }); else if (type == fisd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; }); else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; }); else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; }); else if (type == sifi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; }); else if (type == sifd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; }); else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; }); else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });};\ntemplate<class U> void sort(vector<U> &a, pcomparator type) { if (type == fisi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s < r.s; }); else if (type == fisd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s > r.s; }); else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s < r.s; }); else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s > r.s; }); else if (type == sifi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f < r.f; }); else if (type == sifd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f > r.f; }); else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f < r.f; }); else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f > r.f; }); };\ntemplate<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D> > &a, pcomparator type) {    typedef F2<A, B, C, D> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b < r.b; }); else if (type == fisd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b > r.b; }); else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b < r.b; }); else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b > r.b; }); else if (type == sifi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a < r.a; }); else if (type == sifd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a > r.a; }); else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a < r.a; }); else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a > r.a; });};\ntemplate<class U> void sort(vector<U> &a, tcomparator type) {    if (type == 0) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f < r.f; }); else if (type == 41) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f > r.f; }); else if (type == 42) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f < r.f; }); else if (type == 43) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f > r.f; }); else if (type == 44) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f < r.f; }); else if (type == 45) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f > r.f; }); else if (type == 46) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f < r.f; }); else if (type == 47) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });}\ntemplate<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D>> &a, tcomparator type) {    typedef F2<A, B, C, D> U;    if (type == 0) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a < r.a; }); else if (type == 41) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a > r.a; }); else if (type == 42) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a < r.a; }); else if (type == 43) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a > r.a; }); else if (type == 44) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a < r.a; }); else if (type == 45) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a > r.a; }); else if (type == 46) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a < r.a; }); else if (type == 47) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });}\n\nvoid sort(string &a) { sort(all(a)); }\nvoid sort(int &a, int &b) { if (a > b)swap(a, b); }\nvoid sort(int &a, int &b, int &c) {    sort(a, b);    sort(a, c);    sort(b, c);}\nvoid rsort(int &a, int &b) { if (a < b)swap(a, b); }\nvoid rsort(int &a, int &b, int &c) {    rsort(a, b);    rsort(a, c);    rsort(b, c);}\n//P l, P rで f(P) の形で渡す\ntemplate<class U, class F> void sort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) < f(r); }); };\ntemplate<class U, class F> void rsort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) > f(r); }); };\n\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class A, class B, class F> void sortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    sort(c, f);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}\ntemplate<class A, class B, class F> void rsortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    rsort(c, f);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}\ntemplate<class A, class B, class C, class F> void sortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    sort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class F> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    rsort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class D> void sortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    sort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\ntemplate<class A, class B, class C, class D> void rsortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    rsort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\n/*indexの分で型が変わるためpcomparatorが必要*/\ntemplate<class T> vi sorti(vector<T> &a, pcomparator f) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind, f);    return ind;}\ntemplate<class T, class F> vi sorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(a[x]) < f(a[y]); });    return ind;}\ntemplate<class T> vi rsorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    rsortp(b, ind);    return ind;}\ntemplate<class T, class F> vi rsorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(a[x]) > f(a[y]); });    return ind;}\ntemplate<class A, class B, class F> vi sortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(c[x]) < f(c[y]); });    return ind;}\ntemplate<class A, class B> vi sortpi(vector<A> &a, vector<B> &b, pcomparator f) {    vi ind = iota(0, sz(a));    auto c = a;    auto d = b;    sortt(c, d, ind, f);    return ind;}\ntemplate<class A, class B> vi sortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fisi); };\ntemplate<class A, class B, class F> vi rsortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(c[x]) > f(c[y]); });    return ind;}\ntemplate<class A, class B> vi rsortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fdsd); };\ntemplate<class A, class B, class C, class F> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(d[x]) < f(d[y]); });    return ind;}\ntemplate<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, pcomparator f) {    vi ind = iota(0, sz(a));    auto d = vtof(a, b, c, ind);    sort(d, f);    rep(i, sz(a))ind[i] = d[i].d;    return ind;}\ntemplate<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { if (a[x] == a[y]) { if (b[x] == b[y])return c[x] < c[y]; else return b[x] < b[y]; } else { return a[x] < a[y]; }});    return ind;}\ntemplate<class A, class B, class C, class F> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(d[x]) > f(d[y]); });    return ind;}\ntemplate<class A, class B, class C> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { if (a[x] == a[y]) { if (b[x] == b[y])return c[x] > c[y]; else return b[x] > b[y]; } else { return a[x] > a[y]; }});    return ind;}\ntemplate<class T> void sort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)sort(a[i]); }\ntemplate<class T> void rsort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)rsort(a[i]); }\n\n#endif\ntemplate<typename W, typename T> void fill(W &xx, const T vall) { xx = vall; }\ntemplate<typename W, typename T> void fill(vector<W> &vecc, const T vall) { for (auto &&vx     : vecc)fill(vx, vall); }\ntemplate<typename W, typename T> void fill(vector<W> &xx, ll len, const T v) { rep(i, len)xx[i] = v; }\ntemplate<typename W, typename T> void fill(vector<W> &xx,int s, ll t, const T v) { rep(i, s, t)xx[i] = v; }\ntemplate<typename W, typename T> void fill(vector<vector<W>> &xx, int sh, int th, int sw, int tw, T v) { rep(h, sh, th)rep(w, sw, tw)xx[h][w] = v; }\n//#define use_fill //_sum _array _max _min\n#ifdef use_fill\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\ntemplate<class T, class U> void fill(vector<T> &a, const vi &ind, U val) { fora(v, ind)a[v] = val; }\ntemplate<typename A, size_t N> A sum(A (&a)[N]) {    A res = 0;    rep(i, N)res += a[i];    return res;}\ntemplate<typename A, size_t N, size_t O> A sum(A (&a)[N][O]) {    A res = 0;    rep(i, N)rep(j, O)res += a[i][j];    return res;}\ntemplate<typename A, size_t N, size_t O, size_t P> A sum(A (&a)[N][O][P]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)res += a[i][j][k];    return res;}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q> A sum(A (&a)[N][O][P][Q]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)res += a[i][j][k][l];    return res;}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A sum(A (&a)[N][O][P][Q][R]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)res += a[i][j][k][l][m];    return res;}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A sum(A (&a)[N][O][P][Q][R][S]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)res += a[i][j][k][l][m][n];    return res;}\n\ntemplate<typename A, size_t N> A max(A (&a)[N]) {    A res = a[0];    rep(i, N)res = max(res, a[i]);    return res;}template<typename A, size_t N, size_t O> A max(A (&a)[N][O]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P> A max(A (&a)[N][O][P]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A max(A (&a)[N][O][P][Q], const T &v) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A max(A (&a)[N][O][P][Q][R]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A max(A (&a)[N][O][P][Q][R][S]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}\ntemplate<typename A, size_t N> A min(A (&a)[N]) {    A res = a[0];    rep(i, N)res = min(res, a[i]);    return res;}template<typename A, size_t N, size_t O> A min(A (&a)[N][O]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P> A min(A (&a)[N][O][P]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A min(A (&a)[N][O][P][Q], const T &v) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A min(A (&a)[N][O][P][Q][R]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A min(A (&a)[N][O][P][Q][R][S]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}\n#endif\n\n//@汎用便利関数 入力\nll in() {    ll ret;    cin >> ret;    return ret;}\ntemplate<class T> T in() {    T ret;    cin >> ret;    return ret;}\nstring sin() {    string ret;    cin >> ret;    return ret;}\ntemplate<class T> void in(T &head) { cin >> head; }\ntemplate<class T, class... U> void in(T &head, U &... tail) {    cin >> head;    in(tail...);}\n#define din_t2(type, a) type a;cin>>a\n#define din_t3(type, a, b) type a,b;cin>>a>> b\n#define din_t4(type, a, b, c) type a,b,c;cin>>a>>b>>c\n#define din_t5(type, a, b, c, d) type a,b,c,d;cin>>a>>b>>c>>d\n#define din_t6(type, a, b, c, d, e) type a,b,c,d,e;cin>>a>>b>>c>>d>>e\n#define din_t7(type, a, b, c, d, e, f) type a,b,c,d,e,f;cin>>a>>b>>c>>d>>e>>f\n#define din_t(...) over7(__VA_ARGS__,din_t7,din_t6,din_t5,din_t4,din_t3 ,din_t2)(__VA_ARGS__)\n\n#define din(...) din_t(int,__VA_ARGS__)\n#define d_in\n#define dsig(...) din_t(signed,__VA_ARGS__)\n\n#define dst(...) din_t(string,__VA_ARGS__)\n#define dstr dst\n#define d_str dst\n\n#define dcha(...) din_t(char,__VA_ARGS__)\n#define dchar dcha\n\n#define ddou(...) din_t(double,__VA_ARGS__)\n\n\n#define din1d(a) din_t2(int, a);a--\n#define din2d(a, b) din_t3(int, a,b);a--,b--\n#define din3d(a, b, c) din_t4(int, a,b,c);a--,b--,c--\n#define din4d(a, b, c, d) din_t5(int, a,b,c,d);a--,b--,c--,d--\n#define dind(...) over4(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\n\n#ifdef _DEBUG\ntemplate<class T> void err2(T &&head) { cerr << head; }\ntemplate<class T, class... U> void err2(T &&head, U &&... tail) {    cerr << head << \" \";    err2(tail...);}\ntemplate<class T, class... U> void err(T &&head, U &&... tail) {    cerr << head << \" \";    err2(tail...);    cerr << \"\" << endl;}\ntemplate<class T> void err(T &&head) { cerr << head << endl; }\nvoid err() { cerr << \"\" << endl; }\ntemplate<class T> string out_m2(vector<T> &a, ll W = inf) {    stringstream ss;    if (W == inf)W = min(sz(a), 20ll);    if (sz(a) == 0)return ss.str();    rep(i, W) {        ss << a[i];        if (typeid(a[i]) == typeid(P)) { ss << endl; } else { ss << \" \"; }    }    return ss.str();}\ntemplate<class T> string out_m2(vector<vector<T> > &a, vi H, vi W, int key = -1) {    stringstream ss;    ss << endl;    vi lens(sz(W));    fora(h, H) {        rep(wi, sz(W)) {            int v = a[h][W[wi]];            str s = tos(v);            if (abs(v) == inf || abs(v) == linf)s = \"e\";            lens[wi] = max(lens[wi], sz(s) + 1);            lens[wi] = max(lens[wi], sz(tos(W[wi])) + 1);        }    }    if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";    int wi = 0;    fora(w, W) {        ss << std::right << std::setw(lens[wi]) << w;        wi++;    }    ss << \"\" << endl;    rep(i, sz(W))rep(lens[i])ss << \"_\";    rep(i, 3)ss << \"_\";    ss << \"\" << endl;    fora(h, H) {        ss << std::right << std::setw(2) << h << \"|\";        int wi = 0;        fora(w, W) {            str s = tos(a[h][w]);            if (abs(a[h][w]) == inf || abs(a[h][w]) == linf)s = \"e\";            ss << std::right << std::setw(lens[wi]) << s;            wi++;        }        ss << \"\" << endl;    }    return ss.str();}\ntemplate<class T> string out_m2(vector<vector<T> > &a, ll H = inf, ll W = inf, int key = -1) {    H = (H != inf) ? H : min({H, sz(a), 12ll});    W = min({W, sz(a[0]), 12ll});    vi hs, ws;    rep(h, H) { hs.push_back(h); }    rep(w, W) { ws.push_back(w); }    return out_m2(a, hs, ws, key);}\ntemplate<class T> string out_m2(vector<set<T> > &a, ll H = inf, ll W = inf, int key = -1) {    vector<vector<T> > b(sz(a));    rep(i, sz(a)) { fora(v, a[i]) { b[i].push_back(v); }}    return out_m2(b, H, W, key);}\ntemplate<class T> string out_m2(vector<vector<vector<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {    stringstream ss;    if (H == inf)H = 12;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << out_m2(a[i], W, U, i);    }    return ss.str();}\ntemplate<class T, size_t N> string out_m2(T (&a)[N]) {    vector<T> b;    resize(b, N);    rep(i, N) { b[i] = a[i]; }    return out_m2(b);}\ntemplate<class T, size_t N, size_t M> string out_m2(T (&a)[N][M]) {    vector<vector<T>> b;    resize(b, N, M);    rep(i, N) { rep(j, M) { b[i][j] = a[i][j]; }}    return out_m2(b);}\ntemplate<class T, size_t N, size_t M, size_t O> string out_m2(T (&a)[N][M][O]) {    vector<vector<vector<T>>> b;    resize(b, N, M, O);    rep(i, N) { rep(j, M) { rep(k, O) { b[i][j][k] = a[i][j][k]; }}}    return out_m2(b);}\nstring out_m2(int a) {    stringstream ss;    ss << a;    return ss.str();}\ntemplate<class T> string out_m2(T &a) {    stringstream ss;    ss << a;    return ss.str();}\ntemplate<class T> string out_m(vector<T> &a, ll W = inf) {    stringstream ss;    if (W == inf)W = min(sz(a), 12ll);    if (sz(a) == 0)return ss.str();    rep(i, W) { ss << a[i] << \" \"; }    ss << \"\" << endl;    return ss.str();}\ntemplate<class T> string out_m(vector<vector<T> > &a, ll H = inf, ll W = inf, int key = -1) {    H = min({H, sz(a), 12ll});    W = min({W, sz(a[0]), 12ll});    stringstream ss;    ss << endl;    if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";    rep(w, W)ss << std::right << std::setw(4) << w;    ss << \"\" << endl;    rep(w, W * 4 + 3)ss << \"_\";    ss << \"\" << endl;    rep(h, H) {        ss << std::right << std::setw(2) << h << \"|\";        rep(w, min(sz(a[h]), 12ll)) { if (abs(a[h][w]) == linf) ss << \"   e\" << \"\"; else ss << std::right << std::setw(4) << a[h][w]; }        ss << \"\" << endl;    }    ss << endl;    return ss.str();}\ntemplate<class T> string out_m(vector<vector<vector<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {    stringstream ss;    if (H == inf)H = 5;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << out_m(a[i], W, U, i);    }    ss << endl;    return ss.str();}\nstring out_m(int a) {    stringstream ss;    ss << a << endl;    return ss.str();}\ntemplate<class T> string out_m(T &a) {    stringstream ss;    ss << a << endl;    return ss.str();}\ntemplate<class T> void outv(vector<T> &a, ll W = inf) { cout << out_m(a, W) << endl; }\ntemplate<class T> void outv(vector<vector<T> > &a, ll H = linf, ll W = linf, int key = -1) { cout << out_m(a, H, W, key) << endl; }\ntemplate<class T> void outv(vector<vector<vector<T> > > &a, ll H = linf, ll W = linf, ll U = linf) { cout << out_m(a, H, W, U) << endl; }\n\ntemplate<class T> void out2(T head) {    cout << head;    res_mes += out_m2(head);}\ntemplate<class T, class... U> void out2(T head, U ... tail) {    cout << head << \" \";    res_mes += out_m2(head) + \" \";    out2(tail...);}\ntemplate<class T, class... U> void out(T head, U ... tail) {    cout << head << \" \";    res_mes += out_m2(head) + \" \";    out2(tail...);    cout << \"\" << endl;    res_mes += \"\\n\";}\ntemplate<class T> void out(T head) {    cout << head << endl;    res_mes += out_m2(head) + \"\\n\";}\nvoid out() { cout << \"\" << endl; }\n\n#else\ntemplate<class T> void outv(vector<T> &a, ll W = inf) {    rep(i, min(W, sz(a))) { cout << a[i] << \" \"; }    cout << \"\" << endl;}\ntemplate<class T> void outv(vector<vector<T> > &a, ll H = linf, ll W = linf, int key = -1) { rep(i, min(H, sz(a))) { outv(a[i], W); }}\ntemplate<class T> void outv(vector<vector<vector<T> > > &a, ll H = linf, ll W = linf, ll U = linf) { ; }\n#define err(...);\n\ntemplate<class T> void out2(T &&head) { cout << head; }\ntemplate<class T, class... U> void out2(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);}\ntemplate<class T, class... U> void out(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);    cout << \"\" << endl;}\ntemplate<class T> void out(T &&head) {    cout << head  << endl;}\nvoid out() {    cout << \"\"  << endl;}\n\n#endif\n\n\n\ntemplate<class T> void outl(vector<T> &a, int n = inf) { rep(i, min(n, sz(a)))cout << a[i] << endl; }\n//テーブルをスペースなしで出力\ntemplate<class T> void outt(vector<vector<T>> &a) {rep(i, sz(a)) {rep(j, sz(a[i])) { cout << a[i][j]; }cout << endl;}}\n//int型をbit表記で出力\nvoid outb(int a) { cout << bitset<20>(a) << endl; }\ntemplate<class T> void na(vector<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i];}\ntemplate<class T> void na(set<T> &a, ll n) { rep(i, n)a.insert(in()); }\n#define dna(a, n) vi a; na(a, n);/*nを複数使うと n==in()の時バグる事に注意*/\n#define dnad(a, n) vi a; nad(a, n);\ntemplate<class T> void nao(vector<T> &a, ll n) {a.resize(n + 1);a[0] = 0;rep(i, n)cin >> a[i + 1];}\ntemplate<class T> void naod(vector<T> &a, ll n) {a.resize(n + 1);a[0] = 0;rep(i, n)cin >> a[i + 1], a[i + 1]--;}\ntemplate<class T> void nad(vector<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i], a[i]--;}\ntemplate<class T> void nad(set<T> &a, ll n) { rep(i, n)a.insert(in() - 1); }\ntemplate<class T, class U> void na2(vector<T> &a, vector<U> &b, ll n) {a.resize(n);b.resize(n);rep(i, n)cin >> a[i] >> b[i];}\ntemplate<class T, class U> void na2(set<T> &a, set<U> &b, ll n) {rep(i, n) {a.insert(in());b.insert(in());}}\n#define dna2(a, b, n) vi a,b; na2(a,b,n);\ntemplate<class T, class U> void nao2(vector<T> &a, vector<U> &b, ll n) {a.resize(n + 1);b.resize(n + 1);a[0] = b[0] = 0;rep(i, n)cin >> a[i + 1] >> b[i + 1];}\ntemplate<class T, class U> void na2d(vector<T> &a, vector<U> &b, ll n) {a.resize(n);b.resize(n);rep(i, n)cin >> a[i] >> b[i], a[i]--, b[i]--;}\n#define dna2d(a, b, n) vi a,b; na2d(a,b,n);\ntemplate<class T, class U, class W> void na3(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {a.resize(n);b.resize(n);c.resize(n);rep(i, n)cin >> a[i] >> b[i] >> c[i];}\n#define dna3(a, b, c, n) vi a,b,c; na3(a,b,c,n);\ntemplate<class T, class U, class W> void na3d(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {a.resize(n);b.resize(n);c.resize(n);rep(i, n)cin >> a[i] >> b[i] >> c[i], a[i]--, b[i]--, c[i]--;}\n#define dna3d(a, b, c, n) vi a,b,c; na3d(a,b,c,n);\ntemplate<class T, class U, class W, class X> void na4(vector<T> &a, vector<U> &b, vector<W> &c, vector<X> &d, ll n) {a.resize(n);b.resize(n);c.resize(n);d.resize(n);rep(i, n)cin >> a[i] >> b[i] >> c[i] >> d[i];}\n#define dna4(a, b, c, d, n)  vi a,b,c,d; na4(a,b,c,d,n);\n#define dna4d(a, b, c, d, n)  vi a,b,c,d; na4d(a,b,c,d,n);\n#define nt(a, h, w) resize(a,h,w);rep(nthi,h)rep(ntwi,w) cin >> a[nthi][ntwi];\n#define ntd(a, h, w) resize(a,h,w);rep(ntdhi,h)rep(ntdwi,w) cin >> a[ntdhi][ntdwi], a[ntdhi][ntdwi]--;\n#define ntp(a, h, w) resize(a,h+2,w+2);fill(a,'#');rep(ntphi,1,h+1)rep(ntpwi,1,w+1) cin >> a[ntphi][ntpwi];\n#define dnt(S, h, w) vvi(S,h,w);nt(S,h,w);\n#define dntc(S, h, w) vvc(S,h,w);nt(S,h,w);\n#define dnts(S, h, w) vvs(S,h,w);nt(S,h,w);\n\n//デバッグ\n#define sp << \" \" <<\n\n#define deb1(x)  debugName(x)<<\" = \"<<out_m2(x)\n#define deb_2(x, ...) deb1(x) <<\", \"<< deb1(__VA_ARGS__)\n#define deb_3(x, ...) deb1(x) <<\", \"<< deb_2(__VA_ARGS__)\n#define deb_4(x, ...) deb1(x) <<\", \"<< deb_3(__VA_ARGS__)\n#define deb5(x, ...) deb1(x) <<\", \"<< deb_4(__VA_ARGS__)\n#define deb6(x, ...) deb1(x) <<\", \"<< deb5(__VA_ARGS__)\n#define deb7(x, ...) deb1(x) <<\", \"<< deb6(__VA_ARGS__)\n#define deb8(x, ...) deb1(x) <<\", \"<< deb7(__VA_ARGS__)\n#define deb9(x, ...) deb1(x) <<\", \"<< deb8(__VA_ARGS__)\n#define deb10(x, ...) deb1(x) <<\", \"<< deb9(__VA_ARGS__)\n\n\n#ifdef _DEBUG\nbool was_deb = false;\n#define deb(...)  do{was_deb=true;cerr<< over10(__VA_ARGS__,deb10,deb9,deb8,deb7,deb6,deb5,deb_4,deb_3,deb_2,deb1)(__VA_ARGS__) <<endl;}while(0)\n\n#define base_keta 8\nvoid print_n_base(int x, int base) { cerr << bitset<base_keta>(x) << endl; }\ntemplate<class T> void print_n_base(vector<T> X, int base) {cerr << endl;for (auto &&x:X) { print_n_base(x, base); }cerr << endl;}\n\n//n進数\n#define deb2(x) was_deb=true;cerr<<debugName(x)<<\" = \";print_n_base(x, 2);\n#define deb3(x) was_deb=true;cerr<<debugName(x)<<\" = \";print_n_base(x, 3);\n#define deb4(x) was_deb=true;cerr<<debugName(x)<<\" = \";print_n_base(x, 4);\n\n#define deb_ex_deb(x, len)  debugName(x)<<\" = \"<<out_m2(x, len)\n#define call_deb_ex_deb(x, len) deb_ex_deb(x, len)\n//要素が存在する行だけ出力(vvt)\n#define deb_ex(v) do {int N = sz(v);int s = N;int t = 0;rep(i, N) {if (sz(v[i])) {chmi(s, i);chma(t, i);}}auto ex_v = sub(v, s, N);str S = out_m2(ex_v, sz(ex_v));debugName(v);cerr<<\" = \"<<endl;cerr << S << endl;} while (0);\ntemplate<class T, class F> string out_m2_f(vector<vector<T> > &a, F f, int key = -1) {    vi hs, ws_;    int H = sz(a), W = sz(a[0]);    vi exh(H), exw(W);    rep(h, H) {        rep(w, W) {            if (f(a[h][w])) {                exh[h] = true;                exw[w] = true;            }        }    }    rep(h, H) if (exh[h])hs.push_back(h);    rep(w, W) if (exw[w])ws_.push_back(w);    return out_m2(a, hs, ws_, key);}\ntemplate<class T, class F> string out_m2_f(vector<vector<vector<T>>> &a, F f) {    stringstream ss;    int H = sz(a);    if (sz(a) == 0)return ss.str();    rep(i, H) { ss << out_m2_f(a[i], f, i); }    ss << \"\" << endl;    return ss.str();}\n#define debf_normal(tab, f) do{cerr<<debugName(tab)<<\" = \"<<endl;cerr<< out_m2_f(tab, f)<<endl;}while(0);\n#define debf2(tab, siki_r) debf_normal(tab, lamr(siki_r))\n#define debf3(tab, v, siki)  debf_normal(tab, lam(siki))\n//S, sikir\n//S, v, siki\n#define debf(...) over3(__VA_ARGS__,debf3,debf2,debf1)(__VA_ARGS__)\n\n#else\n#define deb(...) ;\n#define deb2(...) ;\n#define deb3(...) ;\n#define deb4(...) ;\n#define deb_ex(...) ;\n#define debf(...) ;\n#endif\n\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing u128 = __uint128_t;\n\nusing bint =__int128;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {    std::ostream::sentry s(dest);    if (s) {        __uint128_t tmp = value < 0 ? -value : value;        char buffer[128];        char *d = std::end(buffer);        do {            --d;            *d = \"0123456789\"[tmp % 10];            tmp /= 10;        }        while (tmp != 0);        if (value < 0) {            --d;            *d = '-';        }        ll len = std::end(buffer) - d;        if (dest.rdbuf()->sputn(d, len) != len) { dest.setstate(std::ios_base::badbit); }    }    return dest;}\n__int128 to_bint(string &s) {    __int128 ret = 0;    for (ll i = 0; i < s.length(); ++i) if ('0' <= s[i] && s[i] <= '9') ret = 10 * ret + s[i] - '0';    return ret;}\nvoid operator>>(istream &iss, bint &v) {    string S;    iss >> S;    v = 0;    rep(i, sz(S)) {        v *= 10;        v += S[i] - '0';    }}\n//エラー\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");exit(0);\n#endif\n    string a = \"a\";rep(i, 30)a += a;rep(i, 1 << 17)cout << a << endl;cout << \"OLE 出力長制限超過\" << endl;exit(0);\n}\nvoid re() {assert(0 == 1);exit(0);}\nvoid tle() { while (inf)cout << inf << endl; }\n\n//便利関数\n\n//テスト用\n#define rand xor128_\nunsigned long xor128_(void) {    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;    unsigned long t;    t = (x ^ (x << 11));    x = y;    y = z;    z = w;    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));}\nchar ranc() { return (char) ('a' + rand() % 26); }\nll rand(ll min, ll max) {    assert(min <= max);    if (min >= 0 && max >= 0) { return rand() % (max + 1 - min) + min; } else if (max < 0) { return -rand(-max, -min); } else { if (rand() % 2) { return rand(0, max); } else { return -rand(0, -min); }}}\nll rand(ll max) { return rand(0, max); }\ntemplate<class T> T rand(vector<T> &A) { return A[rand(sz(A) - 1)]; }\n//重複することがある\ntemplate<class T> vector<T> ranv(vector<T>& A, int N){vector<T>ret(N);rep(i,N){ret[i]=rand(A);}return ret;}\ntemplate<class T> vector<T> ranv_unique(vector<T>& A, int N){    vector<T> ret(N);    umapi was;    rep(j,N){        int i;        while(1){            i = rand(sz(A)-1);            if(was.find(i) == was.end())break;        }        ret[j] = A[i];was[i]=1;    }    return ret;}\nvi ranv(ll n, ll min, ll max) {    vi v(n);    rep(i, n)v[i] = rand(min, max);    return v;}\n\n#ifdef _DEBUG\nbool timeup(int time){\n    static bool never = true;\n    if(never)message += \"may timeup, because slow\";\n    never = false;\n\n    auto end_time = system_clock::now();\n    auto part = duration_cast<milliseconds>(end_time - start_time);\n    auto lim = milliseconds(time);\n    return part >= lim;\n}\n#else\nbool timeup(int time) {\n    auto end_time = system_clock::now();\n    auto part = duration_cast<milliseconds>(end_time - start_time);\n    auto lim = milliseconds(time);\n    return part >= lim;\n}\n\n#endif\nvoid set_time() { past_time = system_clock::now(); }\n//MS型(millisecqnds)で返る\n//set_timeをしてからの時間\nauto calc_time_milli() {    auto now = system_clock::now();    auto part = duration_cast<milliseconds>(now - past_time);    return part;}\nauto calc_time_micro() {    auto now = system_clock::now();    auto part = duration_cast<microseconds>(now - past_time);    return part;}\nauto calc_time_nano() {    auto now = system_clock::now();    auto part = duration_cast<nanoseconds>(now - past_time);    return part;}\nbool calc_time(int zikan) { return calc_time_micro() >= microseconds(zikan); }\nusing MS=std::chrono::microseconds;\nint div(microseconds a, microseconds b) { return a / b; }\nint div(nanoseconds a, nanoseconds b) {    if (b < nanoseconds(1)) { return a / nanoseconds(1); }    int v = a / b;    return v;}\n//set_time();\n//rep(i,lim)shori\n\n//lim*=time_nanbai();\n//rep(i,lim)shoriと使う\n//全体でmilliかかっていいときにlimを何倍してもう一回できるかを返す\nint time_nanbai(int milli) {\n    auto dec = duration_cast<nanoseconds>(past_time - start_time);\n    auto part = calc_time_nano();\n    auto can_time = nanoseconds(milli * 1000 * 1000);\n    can_time -= part;\n    can_time -= dec;\n    return div(can_time, part);\n}\n\n//#define use_rand\n#ifdef use_rand\nstr ransu(ll n) {    str s;    rep(i, n)s += (char) rand('A', 'Z');    return s;}\nstr ransl(ll n) {    str s;    rep(i, n)s += (char) rand('a', 'z');    return s;}\n//単調増加\nvi ranvinc(ll n, ll min, ll max) {    vi v(n);    bool bad = 1;    while (bad) {        bad = 0;        v.resize(n);        rep(i, n) {            if (i && min > max - v[i - 1]) {                bad = 1;                break;            }            if (i)v[i] = v[i - 1] + rand(min, max - v[i - 1]); else v[i] = rand(min, max);        }    }    return v;}\n//便利 汎用\n#endif\n\nvoid ranvlr(ll n, ll min, ll max, vi &l, vi &r) {    l.resize(n);    r.resize(n);    rep(i, n) {        l[i] = rand(min, max);        r[i] = l[i] + rand(0, max - l[i]);    }}\ntemplate<class T> vector<pair<T, int>> run_length(vector<T> &a) {    vector<pair<T, int>> ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}    return ret;}\nvector<pair<char, ll>> run_length(const string &a) {    vector<pair<char, ll>> ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}    return ret;}\n//#define use_mgr //_goldd _goldt\n#ifdef use_mgr\ntemplate<class T, class F> T mgr(T ok, T ng, F f, int deb_ = 0) {    bool han = true;    if (deb_) {        if (ok < ng)            while (ng - ok > 1) {                T mid = (ok + ng) >> 1;                if (f(mid))ok = mid, han = true; else ng = mid, han = false;                deb(mid, han);            }        else            while (ok - ng > 1) {                T mid = (ok + ng) >> 1;                if (f(mid))ok = mid, han = true; else ng = mid, han = false;                deb(mid, han);            }    }    else {        if (ok < ng)            while (ng - ok > 1) {                T mid = (ok + ng) >> 1;                if (f(mid))ok = mid, han = true; else ng = mid, han = false;            }        else            while (ok - ng > 1) {                T mid = (ok + ng) >> 1;                if (f(mid))ok = mid, han = true; else ng = mid, han = false;            }    }    return ok;}\ntemplate<class T, class F> T mgr(signed ok, T ng, F f) { return mgr((T) ok, ng, f); }\ntemplate<class T, class F> T mgr(T ok, signed ng, F f) { return mgr(ok, (T) ng, f); }\ntemplate<class F> int mgr(signed ok, signed ng, F f) { return mgr((ll) ok, (ll) ng, f); }\n//[l, r)の中で,f(i)がtrueとなる範囲を返す okはそこに含まれる\ntemplate<class F> P mgr(int l, int r, F f, int ok) {    if (f(ok) == 0) {        out(\"f(ok) must true\");        re();    }    return mp(mgr(ok, l - 1, f), mgr(ok, r, f) + 1);}\n\ntemplate<class F> dou mgrd(dou ok, dou ng, F f, int kai = 100) {    bool han = true;    if (ok < ng)        rep(i, kai) {            dou mid = (ok + ng) / 2;            if (f(mid))ok = mid, han = true; else ng = mid, han = false;            deb(mid, han);        }    else        rep(i, kai) {            dou mid = (ok + ng) / 2;            if (f(mid))ok = mid, han = true; else ng = mid, han = false;            deb(mid, han);        }    return ok;}\n\ntemplate<class F> dou mgrd_time(dou ok, dou ng, F f,int time = 1980) {\n    bool han = true;\n    if (ok < ng)\n        while(1) {\n            dou mid = (ok + ng) /2;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            deb(mid,han);\n            if(timeup(time)){\n                break;\n            }\n        }\n    else\n        while(1) {\n            dou mid = (ok + ng) /2;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            deb(mid,han);\n            if(timeup(time)){\n                break;\n            }\n        }\n    return ok;\n}\n\n\n//添え字を返す\ntemplate<class F> ll goldd_l(ll left, ll right, F calc) {    double GRATIO = 1.6180339887498948482045868343656;    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));    ll fl = calc(lm);    ll fr = calc(rm);    while (right - left > 10) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + (ll) ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        }        else {            left = lm;            lm = rm;            fl = fr;            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    ll minScore = MAX<ll>();    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (minScore > score) {            minScore = score;            resIndex = i;        }    }    return resIndex;}\ntemplate<class F> ll goldt_l(ll left, ll right, F calc) {    double GRATIO = 1.6180339887498948482045868343656;    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));    ll fl = calc(lm);    ll fr = calc(rm);    while (right - left > 10) {        if (fl > fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + (ll) ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        }        else {            left = lm;            lm = rm;            fl = fr;            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    if (left > right) {        ll l = left;        left = right;        right = l;    }    ll maxScore = MIN<ll>();    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (maxScore < score) {            maxScore = score;            resIndex = i;        }    }    return resIndex;}\n/*loopは200にすればおそらく大丈夫 余裕なら300に*/\ntemplate<class F> dou goldd_d(dou left, dou right, F calc, ll loop = 200) {    dou GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    /*200にすればおそらく大丈夫*/    /*余裕なら300に*/    ll k = 141;    loop++;    while (--loop) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        }        else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return left;}\ntemplate<class F> dou goldt_d(dou left, dou right, F calc, ll loop = 200) {    double GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    loop++;    while (--loop) {        if (fl > fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        }        else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return left;}\n//l ~ rを複数の区間に分割し、極致を与えるiを返す time-20 msまで探索\ntemplate<class F> ll goldd_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll mini = 0, minv = MAX<ll>();    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldd_l(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return mini;}\ntemplate<class F> ll goldt_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll maxi = 0, maxv = MIN<ll>();    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldt_l(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return maxi;}\ntemplate<class F> dou goldd_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を持つ*/    auto lim = milliseconds(time - 20);    dou mini = 0, minv = MAX<dou>();    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldd_d(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return mini;}\ntemplate<class F> dou goldt_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を残している*/    auto lim = milliseconds(time - 20);    dou maxi = 0, maxv = MIN<dou>();    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldt_d(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return maxi;}\n\n#endif\n\n//strを整数として比較\nstring smax(str &a, str b) { if (sz(a) < sz(b)) { return b; } else if (sz(a) > sz(b)) { return a; } else if (a < b)return b; else return a; }\n//strを整数として比較\nstring smin(str &a, str b) { if (sz(a) > sz(b)) { return b; } else if (sz(a) < sz(b)) { return a; } else if (a > b)return b; else return a; }\n//エラー-1\ntemplate<typename W, typename T> ll find(vector<W> &a, int l, const T key) {rep(i, l, sz(a))if (a[i] == key)return i;return -1;}\ntemplate<typename W, typename T> ll find(vector<W> &a, const T key) {rep(i, sz(a))if (a[i] == key)return i;return -1;}\ntemplate<typename W, typename T> P find(vector<vector<W >> &a, const T key) {rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return mp(i, j);return mp(-1, -1);}\n//getid(find())を返す 1次元にする\ntemplate<typename W, typename T> int findi(vector<vector<W >> &a, const T key) {rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return i * sz(a[0]) + j;return -1;}\ntemplate<typename W, typename U> T find(vector<vector<vector<W >>> &a, const U key) {rep(i, sz(a))rep(j, sz(a[0]))rep(k, sz(a[0][0]))if (a[i][j][k] == key)return mt(i, j, k);return mt(-1, -1, -1);}\n//無ければ-1\nint find(string &s, const string key) {    int klen = sz(key);    rep(i, sz(s) - klen + 1) {        if (s[i] != key[0])continue;        if (s.substr(i, klen) == key) { return i; }    }return -1;}\nint find(string &s, int l, const string key) {    int klen = sz(key);    rep(i, l, sz(s) - klen + 1) {        if (s[i] != key[0])continue;        if (s.substr(i, klen) == key) { return i; }    }    return -1;}\nint find(string &s, const char key) {    rep(i, sz(s)) { if (s[i] == key)return i; }    return -1;}\nint find(string &s, int l, const char key) {    rep(i, l, sz(s)) { if (s[i] == key)return i; }    return -1;}\ntemplate<typename W, typename T> ll count2(W &a, const T k) { return a == k; }\ntemplate<typename W, typename T> ll count2(vector<W> &a, const T k) {    ll ret = 0;    fora(v, a)ret += count2(v, k);    return ret;}\ntemplate<typename W, typename T> ll count(vector<W> &a, const T k) {    ll ret = 0;    fora(v, a)ret += count2(v, k);    return ret;}\nvi count(vi &a) {    int ma = 0;    fora(v, a) { if (ma < v)ma = v; }    vi res(ma + 1);    fora(v, a) { res[v]++; }    return res;}\nll count(str &a, str k) {    ll ret = 0, len = k.length();    auto pos = a.find(k);    while (pos != string::npos)pos = a.find(k, pos + len), ++ret;    return ret;}\n//'a' = 'A' = 0 として集計 既に-'a'されていても動く\nvi count(str &a, int l = -1, int r = -1) {    pr_set_lr(l,r,sz(a));vi cou(26);    char c = 'a';    if ('A' <= a[l] && a[l] <= 'Z')c = 'A';    if ('a' <= a[l] && a[l] <= 'z') c = 'a'; else c = 0;    rep(i, l, r)++cou[a[i] - c];    return cou;}\n#define couif count_if\n//algorythm\nll rev(ll a) {    ll res = 0;    while (a) {        res *= 10;        res += a % 10;        a /= 10;    }    return res;}\ntemplate<class T> auto rev(vector<T> &a) {    auto b = a;    reverse(all(b));    return b;}\n/* ＼反転  */                                                                                        template<class U>\nauto rev(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a[0]), vector<U>(sz(a)));    rep(h, sz(a)) rep(w, sz(a[0]))b[w][h] = a[h][w];    return b;}\n/* ｜反転  */                                                                                        template<class U>\nauto revw(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a), vector<U>(sz(a[0])));    int W = sz(a[0]);    rep(h, sz(a)) rep(w, sz(a[0])) { b[h][W - 1 - w] = a[h][w]; }    return b;}\n\n/* ー反転  */                                                                                        template<class U>\nauto revh(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a), vector<U>(sz(a[0])));    int H = sz(a);    rep(h, sz(a)) rep(w, sz(a[0])) { b[H - 1 - h][w] = a[h][w]; }    return b;}\n\n/* ／反転  */                                                                                        template<class U>\nauto revr(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a[0]), vector<U>(sz(a)));    int H = sz(a);    int W = sz(a[0]);    rep(h, sz(a)) rep(w, sz(a[0]))b[w][h] = a[H - 1 - h][W - 1 - w];    return b;}\n\nauto rev(const string &a) {    string b = a;    reverse(all(b));    return b;}\nconstexpr ll p10[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000ll, 100000000000ll, 1000000000000ll, 10000000000000ll, 100000000000000ll, 1000000000000000ll, 10000000000000000ll, 100000000000000000ll, 1000000000000000000ll};\n\n//0は0桁\nll keta(ll v) { if (v < p10[9]) { if (v < p10[4]) { if (v < p10[2]) { if (v < p10[1]) { if (v < p10[0])return 0; else return 1; } else return 2; } else { if (v < p10[3]) return 3; else return 4; }} else { if (v < p10[7]) { if (v < p10[5]) return 5; else if (v < p10[6])return 6; else return 7; } else { if (v < p10[8])return 8; else return 9; }}} else { if (v < p10[13]) { if (v < p10[11]) { if (v < p10[10]) return 10; else return 11; } else { if (v < p10[12]) return 12; else return 13; }} else { if (v < p10[15]) { if (v < p10[14]) return 14; else return 15; } else { if (v < p10[17]) { if (v < p10[16]) return 16; else return 17; } else { if (v < p10[18])return 18; else return 19; }}}}}\nll getr(ll a, ll keta) { return (a / (ll) pow(10, keta)) % 10; }\n//上から何桁目か\nll getl(ll a, ll ket) {int sketa = keta(a);return getr(a, sketa - 1 - ket);}\nll dsum(ll v, ll sin = 10) {ll ret = 0;for (; v; v /= sin)ret += v % sin;return ret;}\n\nll mask10(ll v) { return p10[v] - 1; }\n//変換系\n//[v] := iとなるようなvectorを返す\n//存在しない物は-1\ntemplate<class T> auto keys(T a) {    vector<decltype((a.begin())->fi)> res;    for (auto &&k :a)res.push_back(k.fi);    return res;}\ntemplate<class T> auto values(T a) {    vector<decltype((a.begin())->se)> res;    for (auto &&k :a)res.push_back(k.se);    return res;}\ntemplate<class T> constexpr T min(T a, T b, T c) { return a >= b ? b >= c ? c : b : a >= c ? c : a; }\ntemplate<class T> constexpr T max(T a, T b, T c) { return a <= b ? b <= c ? c : b : a <= c ? c : a; }\ntemplate<class T> T min(vector<T> &a, ll s = -1, ll n = -1) { pr_set_lr(s, n, sz(a)); return *min_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<class T> T max(vector<T> &a, ll s = -1, ll n = -1) { pr_set_lr(s, n,sz(a)); return *max_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<class T> T mini(vector<T> &a) { return min_element(all(a)) - a.begin(); }\ntemplate<class T> T maxi(vector<T> &a) { return max_element(all(a)) - a.begin(); }\n\ntemplate<class T> T sum(const vector<T>& A, int l = -1, int r = -1){T s=0;pr_set_lr(l, r, sz(A));rep(i, l, r)s+=A[i];return s;}\ntemplate<class T> auto sum(const vector<vector<T>>& A ){decl2(A) s=0;rep(i, sz(A))s+=sum(A[i]);return s;}\ntemplate<class T> T min(const vector<T>& A, int l = -1, int r = -1 ){T s=MAX<T>();pr_set_lr(l, r, sz(A));rep(i, l, r)s=min(s, A[i]);return s;}\ntemplate<class T> auto min(const vector<vector<T>>& A ){using S =decl2(A);S s=MAX<S>();rep(i, sz(A))s=min(s, A[i]);return s;}\ntemplate<class T> T max(const vector<T>& A, int l = -1, int r = -1 ){T s=MIN<T>();pr_set_lr(l, r, sz(A));rep(i, l, r); rep(i, l, r)s=max(s, A[i]);return s;}\ntemplate<class T> auto max(const vector<vector<T>>& A ){using S =decl2(A);S s=MIN<S>();rep(i, sz(A))s=max(s, A[i]);return s;}\ntemplate<class T> T mul(vector<T> &v, ll t = inf) {    T ret = v[0];    rep(i, 1, min(t, sz(v)))ret *= v[i];    return ret;}\n\n//template<class T, class U, class... W>  auto sumn(vector<T> &v, U head, W... tail) {    auto ret = sum(v[0], tail...);    rep(i, 1, min(sz(v), head))ret += sum(v[i], tail...);    return ret;}\n//indexを持つvectorを返す\nvi inds_(vi &a) {    int n = max(a) + 1;    vi ret(n, -1);    rep(i, sz(a)) { assert(ret[a[i]] ==-1);ret[a[i]] = i; }    return ret;}\nvoid clear(PQ &q) { q = PQ(); }\nvoid clear(priority_queue<int> &q) { q = priority_queue<int>(); }\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\n//template<class T> T *negarr(ll size) {    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));    return body + size;}\n//template<class T> T *negarr2(ll h, ll w) {    double **dummy1 = new double *[2 * h + 1];    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];    dummy1[0] = dummy2 + w;    for (ll i = 1; i <= 2 * h + 1; ++i) { dummy1[i] = dummy1[i - 1] + 2 * w + 1; }    double **a = dummy1 + h;    return a;}\n\n\ntemplate<class T> struct ruiC {\n    vector<T> rui;\n    ruiC(vector<T> &ru) : rui(ru) {}\n    /*先頭0*/\n    ruiC() : rui(1, 0) {}\n    T operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruic \";            deb(l, r);            assert(0);        }        return rui[r] - rui[l];    }\n    T operator()(int r = inf) { return operator()(0, min(r, sz(rui) - 1)); }\n    /*ruiv[]をruic[]に変えた際意味が変わるのがまずいため()と統一*/\n    /*単体iを返す 累積でないことに注意(seg木との統一でこうしている)*/\n//    T operator[](ll i) { return rui[i + 1] - rui[i]; }\n    T operator[](ll i) { return rui[i]; }\n    /*0から順に追加される必要がある*/\n    void operator+=(T v) { rui.push_back(rui.back() + v); }\n    void add(int i, T v) {if (sz(rui) - 1 != i)ole();operator+=(v);}\n    T back() { return rui.back(); }\n    ll size() { return rui.size(); }\n    auto begin() { return rui.begin(); }\n    auto end() { return rui.end(); }\n};\ntemplate<class T> ostream &operator<<(ostream &os, ruiC<T> a) {    fora(v, a.rui)os << v << \" \";    return os;}\ntemplate<class T> vector<T> ruiv(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i];    return ret;}\ntemplate<class T> ruiC<T> ruic(vector<T> &a) {    vector<T> ret = ruiv(a);    return ruiC<T>(ret);}\ntemplate<class T> ruiC<T> ruic() { return ruiC<T>(); }\n//imoは0-indexed\n//ruiは1-indexed\ntemplate<class T> vector<T> imo(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    return ret;}\n\n//#define use_rui //_imo _ruic _ruiv\n#ifdef use_rui\n//kと同じものの数\ntemplate<class T, class U> vi imo(vector<T> &a, U k) {    vector<T> ret = a;    rep(i, sz(ret))ret[i] = a[i] == k;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    return ret;}\ntemplate<class T> vector<T> imox(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] ^= ret[i];    return ret;}\n//漸化的に最小を持つ\ntemplate<class T> vector<T> imi(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chmi(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> ima(vector<T> &v) {vector<T> ret = v;    rep(i, sz(ret) - 1)chma(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> rimi(vector<T> &v) {    vector<T> ret = v;    rer(i, sz(ret) - 1, 1)chmi(ret[i - 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> rima(vector<T> &v) {    vector<T> ret = v;    rer(i, sz(ret) - 1, 1)chma(ret[i - 1], ret[i]);    return ret;}\ntemplate<class T> struct ruimax {\n    template<typename Monoid> struct SegmentTree {        /*pairで処理*/        int sz;        vector<Monoid> seg;        const Monoid M1 = mp(MIN<T>(), -1);        Monoid f(Monoid a, Monoid b) { return max(a, b); }        void build(vector<T> &a) {            int n = sz(a);            sz = 1;            while (sz < n) sz <<= 1;            seg.assign(2 * sz, M1);            rep(i, n) { seg[i + sz] = mp(a[i], i); }            for (int k = sz - 1; k > 0; k--) { seg[k] = f(seg[k << 1], seg[(k << 1) | 1]); }        }        Monoid query(int a, int b) {            Monoid L = M1, R = M1;            for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {                if (a & 1) L = f(L, seg[a++]);                if (b & 1) R = f(seg[--b], R);            }            return f(L, R);        }        Monoid operator[](const int &k) const { return seg[k + sz]; }    };\nprivate:\n    vector<T> ve;\n    SegmentTree<pair<T, int>> seg;\n    vector<T> rv;\n    vector<T> ri;\n    bool build = false;\npublic:\n    int n;\n    ruimax(vector<T> &a) : ve(a), n(sz(a)) {        int index = -1;        int ma = MIN<T>();        rv.resize(n + 1);        ri.resize(n + 1);        rv[0] = -linf;        ri[0] = -1;        rep(i, n) {            if (chma(ma, a[i])) { index = i; }            rv[i + 1] = ma;            ri[i + 1] = index;        }    }\n    T operator()(int l, int r) {        if (!(l <= r && 0 <= l && r <= n)) {            deb(l, r, n);            assert(0);        }        if (l == 0) { return rv[r]; }        else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).first;        }    }    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) { return operator()(0, r); }\n    T getv(int l, int r) { return operator()(l, r); }\n    T geti(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) { return ri[r]; }        else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).second;        }    }    T geti(int r = inf) { return geti(0, min(r, n)); };\n    T getv(int r = inf) { return getv(0, min(r, n)); };\n    auto begin() { return rv.begin(); }\n    auto end() { return rv.end(); }\n};\ntemplate<class T> struct ruimin {\n    template<typename Monoid> struct SegmentTree {  /*pairで処理*/         int sz;\n        vector<Monoid> seg;\n        const Monoid M1 = mp(MAX<T>(), -1);\n        Monoid f(Monoid a, Monoid b) { return min(a, b); }\n        void build(vector<T> &a) {            int n = sz(a);            sz = 1;            while (sz < n) sz <<= 1;            seg.assign(2 * sz, M1);            rep(i, n) { seg[i + sz] = mp(a[i], i); }            for (int k = sz - 1; k > 0; k--) { seg[k] = f(seg[k << 1], seg[(k << 1) | 1]); }        }\n        Monoid query(int a, int b) {            Monoid L = M1, R = M1;            for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {                if (a & 1) L = f(L, seg[a++]);                if (b & 1) R = f(seg[--b], R);            }            return f(L, R);        }\n        Monoid operator[](const int &k) const { return seg[k + sz]; }\n    };\nprivate:\n    vector<T> ve;\n    SegmentTree<pair<T, int>> seg;\n    vector<T> rv;\n    vector<T> ri;\n    bool build = false;\n    int n;\npublic:\n    ruimin(vector<T> &a) : ve(a), n(sz(a)) {        int index = -1;        int mi = MAX<T>();        rv.resize(n + 1);        ri.resize(n + 1);        rv[0] = linf;        ri[0] = -1;        rep(i, n) {            if (chmi(mi, a[i])) { index = i; }            rv[i + 1] = mi;            ri[i + 1] = index;        }    }\n    T operator()(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) { return rv[r]; }        else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).first;        }    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) { return operator()(0, r); }\n    T getv(int l, int r) { return operator()(l, r); }\n    T geti(int l, int r) {        {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) { return ri[r]; }        else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).second;        }    }assert(l <= r && 0 <= l && r <= n);        if (l == 0) { return ri[r]; }        else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).second;        }    }\n    T geti(int r = inf) { return geti(0, min(r, n)); };\n    T getv(int r = inf) { return getv(0, min(r, n)); };\n    auto begin() { return rv.begin(); }\n    auto end() { return rv.end(); }\n};\n\nvvi() ruib(vi &a) {    vvi(res, 61, sz(a) + 1);    rep(k, 61) { rep(i, sz(a)) { res[k][i + 1] = res[k][i] + ((a[i] >> k) & 1); }}    return res;}\nvector<ruiC<int>> ruibc(vi &a) {vector<ruiC<int>> ret(61);    vvi(res, 61, sz(a));    rep(k, 61) {        rep(i, sz(a)) { res[k][i] = (a[i] >> k) & 1; }        ret[k] = ruic(res[k]);    }    return ret;}\nvector<ll> ruiv(string &a) {    if (sz(a) == 0)return vi(1);    ll dec = ('0' <= a[0] && a[0] <= '9') ? '0' : 0;    vector<ll> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i] - dec;    return ret;}\nruiC<ll> ruic(string &a) {    vector<ll> ret = ruiv(a);    return ruiC<ll>(ret);}\n//kと同じものの数\ntemplate<class T, class U> vi ruiv(T &a, U k) {    vi ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + (a[i] == k);    return ret;}\ntemplate<class T, class U> ruiC<ll> ruic(T &a, U k) {    vi ret = ruiv(a, k);    return ruiC<ll>(ret);}\ntemplate<class T> struct ruiC2 {\n    int H;\n    vector<ruiC<T>> rui;\n    ruiC2(vector<vector<T>> &ru) : rui(sz(ru)), H(sz(ru)) { for (int h = 0; h < H; h++) { rui[h] = ruic(ru[h]); }}\n    //WについてHを返す\n    vector<T> operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruic \";            deb(l, r);            assert(0);        }        vector<T> res(H);        for (int h = 0; h < H; h++)res[h] = rui[h](l, r);        return res;    }\n    //HについてWを返す\n    ruiC<T> &operator[](ll h) {        assert(h < H);        return rui[h];    }\n    //    vector<T> operator()(int r) { return operator()(0, r); }\n    /*ruiv[]をruic[]に変えた際意味が変わるのがまずいため()と統一*/\n    /*単体iを返す 累積でないことに注意(seg木との統一でこうしている)*/\n//    T operator[](ll i) { return rui[i + 1] - rui[i]; }\n    /*0から順に追加される必要がある*/\n//    T back() { return rui.back(); }\n//    ll size() { return rui.size(); }\n//    auto begin(){return rui.begin();}\n//    auto end(){return rui.end();}\n};\n\n//a~zを0~25として\n// rui(l,r)でvector(26文字について, l~rのcの個数)\n// rui[h] ruic()を返す\nruiC2<ll> ruicou(str &a) {    str s = a;    replace(s);    vector<ruiC<ll>> res(26);    vvi(cou, 26, sz(s));    rep(i, sz(s)) { cou[s[i]][i] = 1; }    return ruiC2<ll>(cou);}\nruiC2<ll> ruicou(vi &a) {    int H = max(a) + 1;    vector<ruiC<ll>> res(H);    vvi(cou, H, sz(a));    rep(i, sz(a)) { cou[a[i]][i] = 1; }    return ruiC2<ll>(cou);}\ntemplate<class T, class U> ruiC<ll> ruicou(vector<T> &a, U b) {    vi cou(sz(a));    rep(i, sz(a)) { cou[i] = a[i] == b; }    return ruic(cou);}\n//h query\ntemplate<class T> vector<T> imoh(vector<vector<T>> &v, int w) {    vector<T> ret(sz(v));    rep(h, sz(ret)) { ret[h] = v[h][w]; }    rep(i, sz(ret) - 1) { ret[i + 1] += ret[i]; }    return ret;}\ntemplate<class T> vector<T> ruih(vector<vector<T>> &v, int w) {    vector<T> ret(sz(v) + 1);    rep(h, sz(v)) { ret[h + 1] = v[h][w]; }    rep(i, sz(v)) { ret[i + 1] += ret[i]; }    return ret;}\ntemplate<class T> ruiC<T> ruihc(vector<vector<T>> &a, int w) {    vector<T> ret = ruih(a, w);    return ruiC<T>(ret);}\n\n//xor\ntemplate<class T> struct ruixC {\n    vector<T> rui;\n    ruixC(vector<T> &ru) : rui(ru) {}\n    T operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruiXc \";            deb(l, r);            assert(0);        }        return rui[r] ^ rui[l];    }\n    T operator[](ll i) { return rui[i]; }\n    T back() { return rui.back(); }\n    ll size() { return rui.size(); }\n};\ntemplate<class T> vector<T> ruix(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] ^ a[i];    return ret;}\ntemplate<class T> ruixC<ll> ruixc(vector<T> &a) {    vi ret = ruix(a);    return ruixC<ll>(ret);}\n//差分を返す(累積を取ると元に戻る)\n//101なら\n//1111を返す\n//元の配列で[l, r)へのxorは\n//[l]と[r]へのxorになる https://atcoder.jp/contests/abc155/tasks/abc155_f\nvi ruix_diff(vi &A) {    int N = sz(A);    assert(N);    vi res(N + 1);    res[0] = A[0];    rep(i, 1, N) { res[i] = A[i - 1] ^ A[i]; }    res[N] = A[N - 1];    return res;}\n\ntemplate<class T> vector<T> ruim(vector<T> &a) {    vector<T> res(a.size() + 1, 1);    rep(i, a.size())res[i + 1] = res[i] * a[i];    return res;}\n//漸化的に最小を1indexで持つ\ntemplate<class T> vector<T> ruimi(vector<T> &a) {ll n = sz(a);    vector<T> ret(n + 1);    rep(i, 1, n) {        ret[i] = a[i - 1];        chmi(ret[i + 1], ret[i]);    }    return ret;}\n//template<class T> T *rrui(vector<T> &a) {\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> struct rruiC {\n    vector<T> rui;\n    int n;\n    rruiC(vector<T> &a) : n(sz(a)) {        rui.resize(n + 1);        rer(i, n - 1) { rui[i] = rui[i + 1] + a[i]; }    }\n    /*[r l)*/\n    T operator()(int r, int l) {        r++;        l++;        assert(l <= r && l >= 0 && r <= n);        return rui[l] - rui[r];    }\n    T operator()(int l) { return operator()(n - 1, l); }\n    T operator[](int i) { return operator()(i); }\n};\ntemplate<class T> ostream &operator<<(ostream &os, rruiC<T> a) {    fora(v, a.rui)os << v << \" \";    return os;}\n\n#define rrui rruic\ntemplate<class T> rruiC<T> rruic(vector<T> &a) { return rruiC<T>(a); }\n\n//掛け算\ntemplate<class T> struct ruimulC {\n    vector<T> rv;\n    int n;\n    ruimulC(vector<T> &a) : rv(a), n(sz(a)) {        rv.resize(n + 1);        rv[0] = 1;        rep(i, n) { rv[i + 1] = a[i] * rv[i]; }    }\n    ruimulC() : n(0) {        rv.resize(n + 1);        rv[0] = 1;    }\n    void operator+=(T v) {        rv.push_back(rv.back() * v);        n++;    }\n    T operator()(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        return rv[r] / rv[l];    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) { return operator()(0, r); }\n    auto begin() { return rv.begin(); }\n    auto end() { return rv.end(); }\n};\ntemplate<class T> ruimulC<T> ruimul(vector<T> &a) { return ruimulC<T>(a); }\ntemplate<class T> ruimulC<T> ruimul() {    vector<T> a;    return ruimulC<T>(a);}\ntemplate<class T> T *rruim(vector<T> &a) {    ll len = a.size();    T *body = (T *) malloc((len + 1) * sizeof(T));    T *res = body + 1;    res[len - 1] = 1;    rer(i, len - 1)res[i - 1] = res[i] * a[i];    return res;}\ntemplate<class T, class U, class W> T lowerBound(ruiC <T> &a, U v, W banpei) { return lowerBound(a.rui, v, banpei); }\ntemplate<class T, class U, class W> T upperBound(ruiC <T> &a, U v, W banpei) { return upperBound(a.rui, v, banpei); }\ntemplate<class T, class U, class W> T rlowerBound(ruiC <T> &a, U v, W banpei) { return rlowerBound(a.rui, v, banpei); }\ntemplate<class T, class U, class W> T rupperBound(ruiC <T> &a, U v, W banpei) { return rupperBound(a.rui, v, banpei); }\n#endif\n\ntemplate<class T, class U> void inc(pair<T, U> &a, U v = 1) { a.first += v, a.second += v; }\ntemplate<class T, class U> void inc(T &a, U v = 1) { a += v; }\ntemplate<class T, class U = int> void inc(vector<T> &a, U v = 1) { for (auto &u:a)inc(u, v); }\ntemplate<class T, class U> void dec(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U = int> void dec(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class U> void dec(string &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T, class U, class W> void dec(vector<T> &a, vector<U> &b, W v = 1) {    for (auto &u :a)dec(u, v);    for (auto &u :b)dec(u, v);}\ntemplate<class T, class U, class W> void dec(vector<T> &a, vector<U> &b, vector<W> &c) {    for (auto &u :a)dec(u, 1);    for (auto &u :b)dec(u, 1);    for (auto &u :c)dec(u, 1);}\nbool ins(ll h, ll w, ll H, ll W) { return h >= 0 && w >= 0 && h < H && w < W; }\nbool san(ll l, ll v, ll r) { return l <= v && v < r; }\ntemplate<class T> bool ins(vector<T> &a, ll i, ll j = 0) { return san(0, i, sz(a)) && san(0, j, sz(a)); }\n#define inside ins\nll u0(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u0(vector<T> &a) {    vector<T> ret = a;    fora(v, ret)v = u(v);    return ret;}\n//todo 名前\nbool d_(int a, int b) {    if (b == 0)return false;    return (a % b) == 0;}\n\n\n//pow周りの仕様\n//powiを使うと整数型\n//powbを使うとbint型\n//powを使うと powlに変換され long doubleが返る\n#ifdef _DEBUG\n//整数値の場合はpowiを使った方がいいというメッセージを出すための物\nauto my_powl(ll a, ll k) { return powl(a, k); }\nauto pow(ll a, ll k) {    static bool was = 1;    if (was) { message += \"if integer use *powi* it's very fast\\n\"; }    was = 0;    return my_powl(a, k);}\n//上のメッセージを出すための関数\nauto pow(signed a, ll k) { return pow((ll) a, k); }\nauto pow(signed a, signed k) { return pow((ll) a, (ll) k); }\n#endif\n\n//整数型のpow\nint powi(int a, int k) {    if (a == 2)return 1ll << k;    int res = 1;    int x = a;    while (k) {        if (k & 1)res *= x;        x *= x;        k >>= 1;    }    return res;}\n//define pow powlより上に動かすとバグる\nbint pow(bint a, ll k) {    bint res = 1;    bint x = a;    while (k) {        if (k & 1)res *= x;        x *= x;        k >>= 1;    }    return res;}\nbint pow(bint a, signed k) { return pow(a, (ll) k); }\nbint powb(int a, int b) { return pow((bint) a, b); }\nconstexpr bool bget(ll m, ll keta) {\n#ifdef _DEBUG\n    assert(keta <= 62);//オーバーフロー 1^62までしか扱えない\n#endif\n    return (m >> keta) & 1;\n}\n//bget(n)次元\n//                          NならN-1まで\nvector<vi> bget2(vi &a, int keta_size) {    vvi(res, keta_size, sz(a));    rep(k, keta_size) { rep(i, sz(a)) { res[k][i] = bget(a[i], k); }}    return res;}\nvi bget1(vi &a, int keta) {    vi res(sz(a));    rep(i, sz(a)) { res[i] = bget(a[i], keta); }    return res;}\nll bget(ll m, ll keta, ll sinsuu) {    m /= (ll) pow(sinsuu, keta);    return m % sinsuu;}\nconstexpr ll bit(ll n) {\n#ifdef _DEBUG\n    assert(n <= 62);//オーバーフロー 1^62までしか扱えない\n#endif\n    return (1LL << (n));\n}\nll bit(ll n, ll sinsuu) { return (ll) pow(sinsuu, n); }\nll mask(ll n) { return (1ll << n) - 1; }\n//aをbitに置きなおす\n//{0, 2} -> 101\nll bit(vi &a) {    int m = 0;    for (auto &&v:a) m |= bit(v);    return m;}\n\n//{1, 1, 0} -> 011\n//bitsetに置き換える感覚 i が立っていたら i bit目を立てる\nll bit_bool(vi &a) {    int m = 0;    rep(i, sz(a)) if (a[i])m |= bit(i);    return m;}\n#define bcou __builtin_popcountll\n//最下位ビット\nll lbit(ll n) { assert(n);return n & -n; }\nll lbiti(ll n) { assert(n);return log2(n & -n); }\n//最上位ビット\nll hbit(ll n) {    assert(n);n |= (n >> 1);    n |= (n >> 2);    n |= (n >> 4);    n |= (n >> 8);    n |= (n >> 16);    n |= (n >> 32);    return n - (n >> 1);}\nll hbiti(ll n) { assert(n);return log2(hbit(n)); }\n//ll hbitk(ll n) {    ll k = 0;    rer(i, 5) {        ll a = k + (1ll << i);        ll b = 1ll << a;        if (b <= n)k += 1ll << i;    }    return k;}\n//初期化は0を渡す\nll nextComb(ll &mask, ll n, ll r) {    if (!mask)return mask = (1LL << r) - 1;    ll x = mask & -mask; /*最下位の1*/    ll y = mask + x; /*連続した下の1を繰り上がらせる*/    ll res = ((mask & ~y) / x >> 1) | y;    if (bget(res, n))return mask = 0; else return mask = res;}\n//n桁以下でビットがr個立っているもののvectorを返す\nvi bitCombList(ll n, ll r) {    vi res;    ll m = 0;    while (nextComb(m, n, r)) { res.push_back(m); }    return res;}\n/*over*/#define forbit1_2(i, mas) for (int forbitj = lbit(mas), forbitm = mas, i = log2(forbitj); forbitm; forbitm = forbitj ? forbitm ^ forbitj : 0, forbitj = lbit(forbitm), i = log2(forbitj))\n/*over*/#define forbit1_3(i, N, mas) for (int forbitj = lbit(mas), forbitm = mas, i = log2(forbitj); forbitm && i < N; forbitm = forbitj ? forbitm ^ forbitj : 0, forbitj = lbit(forbitm), i = log2(forbitj))\n//masの立ってるindexを見る\n//              i, [N], mas\n#define forbit1(...) over3(__VA_ARGS__, forbit1_3, forbit1_2)(__VA_ARGS__)\n//masが立っていないindexを見る\n//              i, N, mas\n#define forbit0(i, N, mas) forbit1(i, mask(N) & (~(mas)))\n\n//forsubをスニペットして使う\n//Mの部分集合(0,M含む)を見る 3^sz(S)個ある\n#define forsub_all(m, M) for (int m = M; m != -1; m = m == 0 ? -1 : (m - 1) & M)\n\n\n//aにある物をtrueとする\nvb bool_(vi a, int n) {    vb ret(max(max(a) + 1, n));    rep(i, sz(a))ret[a[i]] = true;    return ret;}\n\nchar itoal(ll i) { return 'a' + i; }\nchar itoaL(ll i) { return 'A' + i; }\nll altoi(char c) {    if ('A' <= c && c <= 'Z')return c - 'A';    return c - 'a';}\nll ctoi(char c) { return c - '0'; }\nchar itoc(ll i) { return i + '0'; }\nll vtoi(vi &v) {    ll res = 0;    if (sz(v) > 18) {        debugline(\"vtoi\");        deb(sz(v));        ole();    }    rep(i, sz(v)) {        res *= 10;        res += v[i];    }    return res;}\nvi itov(ll i) {    vi res;    while (i) {        res.push_back(i % 10);        i /= 10;    }    res = rev(res);    return res;}\nvi stov(string &a) {    ll n = sz(a);    vi ret(n);    rep(i, n) { ret[i] = a[i] - '0'; }    return ret;}\n//基準を満たさないものは0になる\nvi stov(string &a, char one) {    ll n = sz(a);    vi ret(n);    rep(i, n)ret[i] = a[i] == one;    return ret;}\nvector<vector<ll>> ctoi(vector<vector<char>> s, char c) {    ll n = sz(s), m = sz(s[0]);    vector<vector<ll>> res(n, vector<ll>(m));    rep(i, n)rep(j, m)res[i][j] = s[i][j] == c;    return res;}\n//#define use_compress\n//[i] := vを返す\n//aは0~n-1で置き換えられる\nvi compress(vi &a) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(all(b), a[i]) - b.begin(); }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\n#ifdef use_compress\nvi compress(vi &a, umap<ll, ll> &map) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) {        ll v = a[i];        a[i] = lower_bound(all(b), a[i]) - b.begin();        map[v] = a[i];    }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r) {    vi b;    ll len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r, vi &s) {    vi b;    ll len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    fora(v, s)b.push_back(v);    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    for (ll i = 0; i < sz(s); ++i) r[i] = lower_bound(all(b), s[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vi> &a) {    vi b;    fora(vv, a)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vv, a)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vector<vi >> &a) {    vi b;    fora(vvv, a)fora(vv, vvv)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vvv, a)fora(vv, vvv)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvoid compress(ll a[], ll len) {    vi b;    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(all(b), a[i]) - b.begin(); }}\n#endif\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define rlowerIndex(a, v) (upper_bound(all(a),v)-a.begin()-1)\n#define rupperIndex(a, v) (lower_bound(all(a),v)-a.begin()-1)\n\ntemplate<class T, class U, class W> T lowerBound(vector<T> &a, U v, W banpei) {    auto it = lower_bound(a.begin(), a.end(), v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T upperBound(vector<T> &a, U v, W banpei) {    auto it = upper_bound(a.begin(), a.end(), v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T rlowerBound(vector<T> &a, U v, W banpei) {    auto it = upper_bound(a.begin(), a.end(), v);    if (it == a.begin())return banpei; else { return *(--it); }}\ntemplate<class T, class U, class W> T rupperBound(vector<T> &a, U v, W banpei) {    auto it = lower_bound(a.begin(), a.end(), v);    if (it == a.begin())return banpei; else { return *(--it); }}\n\ntemplate<class T, class U, class W> T lowerBound(set<T> &a, U v, W banpei) {    auto it = a.lower_bound(v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T upperBound(set<T> &a, U v, W banpei) {    auto it = a.upper_bound(v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T rlowerBound(set<T> &a, U v, W banpei) {    auto it = a.upper_bound(v);    if (it == a.begin())return banpei; else { return *(--it); }}\ntemplate<class T, class U, class W> T rupperBound(set<T> &a, U v, W banpei) {auto it = a.lower_bound(v);if (it == a.begin())return banpei; else { return *(--it); }}\n\ntemplate<class T, class U, class W> T lowerBound(mset<T> &a, U v, W banpei) {    auto it = a.lower_bound(v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T upperBound(mset<T> &a, U v, W banpei) {    auto it = a.upper_bound(v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T rlowerBound(mset<T> &a, U v, W banpei) {    auto it = a.upper_bound(v);    if (it == a.begin())return banpei; else { return *(--it); }}\ntemplate<class T, class U, class W> T rupperBound(mset<T> &a, U v, W banpei) {auto it = a.lower_bound(v);if (it == a.begin())return banpei; else { return *(--it); }}\n#define next2(a) next(next(a))\n#define prev2(a) prev(prev(a))\n\n//狭義の単調増加列 長さを返す\ntemplate<class T> int lis(vector<T> &a) {    int n = sz(a);    vi tail(n + 1, MAX<T>());    rep(i, n) {        int id = lowerIndex(tail, a[i]);/**/        tail[id] = a[i];    }    return lowerIndex(tail, MAX<T>());}\ntemplate<class T> int lis_eq(vector<T> &a) {    int n = sz(a);    vi tail(n + 1, MAX<T>());    rep(i, n) {        int id = upperIndex(tail, a[i]);/**/        tail[id] = a[i];    }    return lowerIndex(tail, MAX<T>());}\n\n//iteratorを返す\n//valueが1以上の物を返す 0は見つけ次第削除\n//vを減らす場合 (*it).se--でいい\ntemplate<class T, class U, class V> auto lower_map(map<T, U> &m, V k) {    auto ret = m.lower_bound(k);    while (ret != m.end() && (*ret).second == 0) {        ret = m.erase(ret);    }    return ret;}\ntemplate<class T, class U, class V> auto upper_map(map<T, U> &m, V k) {    auto ret = m.upper_bound(k);    while (ret != m.end() && (*ret).second == 0) {        ret = m.erase(ret);    }    return ret;}\n//存在しなければエラー\ntemplate<class T, class U, class V> auto rlower_map(map<T, U> &m, V k) {    auto ret = upper_map(m, k);    assert(ret != m.begin());    ret--;    while (1) {        if ((*ret).second != 0)break;        assert(ret != m.begin());        auto next = ret;        --next;        m.erase(ret);        ret = next;    }    return ret;}\ntemplate<class T, class U, class V> auto rupper_map(map<T, U> &m, V k) {    auto ret = lower_map(m, k);    assert(ret != m.begin());    ret--;    while (1) {        if ((*ret).second != 0)break;        assert(ret != m.begin());        auto next = ret;        --next;        m.erase(ret);        ret = next;    }    return ret;}\n\ntemplate<class... T> void fin(T... s) {out(s...); exit(0); }\n\n//便利 数学 math\n//sub ⊂ top\nbool subset(int sub, int top) {return (sub & top) == sub;}\n//-180 ~ 180 degree\ndouble atand(double h, double w) {return atan2(h, w) / PI * 180;}\n//% -mの場合、最小の正の数を返す\nll mod(ll a, ll m) {if (m < 0) m *= -1;return (a % m + m) % m;}\nll pow(ll a) { return a * a; };\nll fact(ll v) { return v <= 1 ? 1 : v * fact(v - 1); }\ndou factd(int v){static vd fact(2,1);    if(sz(fact)<=v){        rep(i,sz(fact),v+1){            fact.push_back(fact.back()*i);        }    }    return fact[v];}\n\nll comi(ll n, ll r) {    assert(n < 100);    static vvi(pas, 100, 100);    if (pas[0][0])return pas[n][r];    pas[0][0] = 1;    rep(i, 1, 100) {        pas[i][0] = 1;        rep(j, 1, i + 1)pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];    }    return pas[n][r];}\n//二項係数の偶奇を返す\nint com_mod2(int n,int r){return n == ( r | (n - r) );}\ndouble comd2(ll n, ll r) {    static vvd(comb, 2020, 2020);    if (comb[0][0] == 0) {        comb[0][0] = 1;        rep(i, 2000) {            comb[i + 1][0] = 1;            rep(j, 1, i + 2) { comb[i + 1][j] = comb[i][j] + comb[i][j - 1]; }        }    }    return comb[n][r];}\ndouble comd(int n, int r) {    if (r < 0 || r > n) return 0;    if (n < 2020)return comd2(n, r);    static vd fact(2, 1);    if (sz(fact) <= n) { rep(i, sz(fact), n + 1) { fact.push_back(fact.back() * i); }}    return fact[n] / fact[n - r] / fact[r];}\n\nll gcd(ll a, ll b) {while (b) a %= b, swap(a, b);return abs(a);}\nll gcd(vi b) {ll res = b[0];rep(i, 1, sz(b))res = gcd(b[i], res);return res;}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll lcm(vi a) {ll res = a[0];rep(i, 1, sz(a))res = lcm(a[i], res);return res;}\nll ceil(ll a, ll b) {if (b == 0) {debugline(\"ceil\");deb(a, b);ole();return -1;} else if (a < 0) { return 0; } else { return (a + b - 1) / b; }}\n\nll sig0(int t) { return t <= 0 ? 0 : ((1 + t) * t) >> 1; }\nbint sig0(bint t) {return t <= 0 ? 0 : ((1 + t) * t) >> 1; }\n//ll sig(ll s, ll t) { return ((s + t) * (t - s + 1)) >> 1; }\nll sig(ll s, ll t) {if (s > t)swap(s, t);return sig0(t - s) + s * (t - s + 1);}\n\n#define tousa_i tosa_i\n#define lower_tousa_i lower_tosa_i\n#define upper_tousa upper_tosa\n#define upper_tousa_i upper_tosa_i\nll tosa_i(ll st, ll ad, ll v) {    assert(((v - st) % ad) == 0);    return (v - st) / ad;}\nll tosa_s(ll st, ll ad, ll len) {    return st * len + sig0(len - 1) * ad;}\n\n// ax + r (x は非負整数) で表せる整数のうち、v 以上となる最小の整数\nll lower_tosa(ll st, ll ad, ll v) {    if (st >= v) return st;    return (v - st + ad - 1) / ad * ad + st;}\n//第何項か\nll lower_tosa_i(ll st, ll ad, ll v) {    if (st >= v) return 0;    return (v - st + ad - 1) / ad;}\nll upper_tosa(ll st, ll ad, ll v) { return lower_tosa(st, ad, v + 1); }\nll upper_tosa_i(ll st, ll ad, ll v) { return lower_tosa_i(st, ad, v + 1); }\n\n//b * res <= aを満たす [l, r)を返す div\nP drange_ika(int a, int b) {    P null_p = mp(linf, linf);    if (b == 0) {        if (a >= 0) {            return mp(-linf, linf + 1)/*全て*/;        } else {            return null_p/*無い*/;        }    } else {        if (a >= 0) {            if (b > 0) {                return mp(-linf, a / b + 1);            } else {                return mp(-(a / -b), linf + 1);            }        } else {            if (b > 0) {                return mp(-linf, -ceil(-a, b) + 1);            } else {                return mp(ceil(-a, -b), linf + 1);            }        }    }}\n\n//v * v >= aとなる最小のvを返す\nll sqrt(ll a) {    if (a < 0) {        debugline(\"sqrt\");        deb(a);        ole();    }    ll res = (ll) std::sqrt(a);    while (res * res < a)++res;    return res;}\ndouble log(double e, double x) { return log(x) / log(e); }\n\n\n/*@formatter:off*/\n\n//機能拡張\n#define dtie(a, b) int a, b; tie(a, b)\ntemplate<class T, class U> string to_string(T a, U b) {    string res = \"\";    res += a;    res += b;    return res;}\ntemplate<class T, class U, class V> string to_string(T a, U b, V c) {    string res = \"\";    res += a;    res += b;    res += c;    return res;}\ntemplate<class T, class U, class V, class W> string to_string(T a, U b, V c, W d) {    string res = \"\";    res += a;    res += b;    res += c;    res += d;    return res;}\ntemplate<class T, class U, class V, class W, class X> string to_string(T a, U b, V c, W d, X e) {    string res = \"\";    res += a;    res += b;    res += c;    res += d;    res += e;    return res;}\n\ntemplate<class T> vector<T> sub(vector<T> &A, int l, int r) {    assert(0 <= l && l <= r && r <= sz(A));    vector<T> ret(r - l);    std::copy(A.begin() + l, A.begin() + r, ret.begin());    return ret;}\ntemplate<class T> vector<T> sub(vector<T> &A, int r) { return sub(A, 0, r); }\ntemplate<class T> vector<T> subn(vector<T> &A, int l, int len) { return sub(A, l, l + len); }\nstring sub(string &A, int l, int r) {    assert(0 <= l && l <= r && r <= sz(A));    return A.substr(l, r - l);}\n\nconstexpr int bsetlen = k5 * 2;\n//constexpr int bsetlen = 5050;\n#define bset bitset<bsetlen>\nbool operator<(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] < b[i])return true;if (a[i] > b[i])return false;}return false;}\nbool operator>(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] > b[i])return true;if (a[i] < b[i])return false;}return false;}\nbool operator<=(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] < b[i])return true;if (a[i] > b[i])return false;}return true;}\nbool operator>=(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] > b[i])return true;if (a[i] < b[i])return false;}return true;}\nstring operator~(string &a) {string res = a;for (auto &&c:res) {if (c == '0')c = '1';else if (c == '1')c = '0';else {cerr << \"cant ~\" << a << \"must bit\" << endl;exit(0);}}return res;}\nostream &operator<<(ostream &os, bset& a) {    bitset<10> b;    vi list;    rep(i,bsetlen){        if(a[i])list.push_back(i),b[i]=1;    }    os<<b<<\", \"<<list;    return os;}\nint hbiti(bset&a){rer(i,bsetlen){if(a[i])return i;}return -1;}\n#define hk(a, b, c) (a <= b && b < c)\n\n//O(N/64)\nbset nap(bset &a, int v) {bset r = a | a << v;return r;}\nbset nap(bset &a, bset &v) {bset r = a;rep(i, bsetlen) {if (v[i])r |= a << i;}return r;}\n\ntemplate<class T> int count(set<T> &S, T l, T r) {    assert(l < r);    auto it = S.lower_bound(l);    return it != S.end() && (*it) < r;}\n\ntemplate<class T> void seth(vector<vector<T>> &S, int w, vector<T> &v) {assert(sz(S) == sz(v));assert(w < sz(S[0]));rep(h, sz(S)) { S[h][w] = v[h]; }}\n\ntemplate<class T, class U> void operator+=(pair<T,U> &a, pair<T,U> & b) {a.fi+=b.fi;a.se+=b.se;}\ntemplate<class T, class U> pair<T,U> operator+(pair<T,U> &a, pair<T,U> & b) {return pair<T,U>(a.fi+b.fi,a.se+b.se);}\ntemplate<typename CharT, typename Traits, typename Alloc> basic_string<CharT, Traits, Alloc> operator+(const basic_string<CharT, Traits, Alloc> &lhs, const int rv) {\n#ifdef _DEBUG\n    static bool was = false;if (!was)message += \"str += 65  is  'A'  not \\\"65\\\" \";was = true;\n#endif\n    return lhs + (char) rv;\n}\ntemplate<typename CharT, typename Traits, typename Alloc> void operator+=(basic_string<CharT, Traits, Alloc> &lhs, const int rv) {    lhs = lhs + rv;}\ntemplate<typename CharT, typename Traits, typename Alloc> basic_string<CharT, Traits, Alloc> operator+(const basic_string<CharT, Traits, Alloc> &lhs, const signed rv) {    const int rv2 = rv;    return lhs + rv2;}\ntemplate<typename CharT, typename Traits, typename Alloc> void operator+=(basic_string<CharT, Traits, Alloc> &lhs, const signed rv) {const int v = rv; lhs += v; }\ntemplate<typename CharT, typename Traits, typename Alloc> void operator*=(basic_string<CharT, Traits, Alloc> &s, int num) {    auto bek = s;    s = \"\";    for (; num; num >>= 1) {        if (num & 1) { s += bek; }        bek += bek;    }}\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) { a.push(v); }template<class T, class U> void operator+=(deque<T> &a, U v) { a.push_back(v); }template<class T> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, vector<T> &v) {    fora(d, v)a.push(d);    return a;}template<class T, class U> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {    a.push(v);    return a;}template<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {    a.push(v);    return a;}template<class T> set<T> &operator+=(set<T> &a, vector<T> v) {    fora(d, v)a.insert(d);    return a;}template<class T, class U> auto operator+=(set<T> &a, U v) { return a.insert(v); }template<class T, class U> auto operator-=(set<T> &a, U v) { return a.erase(v); }template<class T, class U> auto operator+=(mset<T> &a, U v) { return a.insert(v); }template<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {    a.insert(v);    return a;}template<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {    a.push_back(v);    return a;}template<class T, class U> vector<T> operator+(vector<T> &a, U v) {    vector<T> ret = a;    ret += v;    return ret;}template<class T, class U> vector<T> operator+(U v, vector<T> &a) {    vector<T> ret = a;    ret.insert(ret.begin(), v);    return ret;}template<class T> vector<T> operator+(const vector<T>& a, const vector<T>& b) {    vector<T> ret;    ret = a;    fora(v, b)ret += v;    return ret;}template<class T> vector<T> &operator+=(vector<T> &a, vector<T> &b) {    rep(i, sz(b)) {/*こうしないとa+=aで両辺が増え続けてバグる*/        a.push_back(b[i]); }    return a;}template<class T, class U> map<T, U> &operator+=(map<T, U> &a, map<T, U> &b) {    fora(bv, b) { a[bv.first] += bv.second; }    return a;}\ntemplate<class T> vector<T> operator%(vector<T>& a, int v){    vi ret(sz(a));    rep(i,sz(a)){        ret[i] = a[i] % v;    }    return ret;}\ntemplate<class T> vector<T> operator%=(vector<T>& a, int v){    rep(i,sz(a)){        a[i] %= v;    }    return a;}\nvi operator&(vi& a, vi& b){    assert(sz(a)==sz(b));    vi ret(sz(a));    rep(i,sz(a)){        ret[i] = min(a[i],b[i]);    }    return ret;}\ntemplate<class T> void operator+=(mset<T> &a, vector<T>& v) { for(auto&& u : v)a.insert(u); }\ntemplate<class T> void operator+=(set<T> &a, vector<T>& v) { for(auto&& u : v)a.insert(u); }\ntemplate<class T> void operator+=(vector<T> &a, set<T>& v) { for(auto&& u : v)a.emplace_back(u); }\ntemplate<class T> void operator+=(vector<T> &a, mset<T>& v) { for(auto&& u : v)a.emplace_back(u); }\ntemplate<class T> vector<T> &operator-=(vector<T> &a, vector <T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-=\");        deb(a);        deb(b);        exit(0);    }    rep(i, sz(a))a[i] -= b[i];    return a;}\ntemplate<class T> vector<T> operator-(vector<T> &a, vector<T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-\");        deb(a);        deb(b);        ole();    }    vector<T> res(sz(a));    rep(i, sz(a))res[i] = a[i] - b[i];    return res;}\n//template<class T, class U> void operator*=(vector<T> &a, U b) {    vector<T> ta = a;    rep(b-1){        a+=ta;    }}\ntemplate<typename T> void erase(vector<T> &v, unsigned ll i) { v.erase(v.begin() + i); }\ntemplate<typename T> void erase(vector<T> &v, unsigned ll s, unsigned ll e) { v.erase(v.begin() + s, v.begin() + e); }\ntemplate<typename T> void pop_front(vector<T> &v) { erase(v, 0); }\ntemplate<typename T> void entry(vector<T> &v, unsigned ll s, unsigned ll e) { erase(v, e, sz(v));erase(v,0,s);}\n\ntemplate<class T, class U> void erase(map<T, U> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<class T> void erase(set<T> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<typename T> void erasen(vector<T> &v, unsigned ll s, unsigned ll n) { v.erase(v.begin() + s, v.begin() + s + n); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, U t) { v.insert(v.begin() + i, t); }\ntemplate<typename T, typename U> void push_front(vector<T> &v, U t) { v.insert(v.begin(), t); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, vector<T> list) { for (auto &&va:list)v.insert(v.begin() + i++, va); }\ntemplate<typename T> void insert(set<T> &v, vector<T> list) { for (auto &&va :list)v.insert(va); }\ntemplate<class T> T poll(set<T>& S){T ret = *S.begin();S.erase(S.begin());return ret;}\ntemplate<class T> T poll(mset<T>& S){T ret = *S.begin();S.erase(S.begin());return ret;}\ntemplate<class T> T poll_back(set<T>& S){T ret = *S.rbegin();S.erase(S.rbegin());return ret;}\ntemplate<class T> T poll_back(mset<T>& S){T ret = *S.rbegin();S.erase(S.rbegin());return ret;}\ntemplate<class T> T peek(set<T>& S){T ret = *S.begin();return ret;}\ntemplate<class T> T peek(mset<T>& S){T ret = *S.begin();return ret;}\ntemplate<class T> T peek_back(set<T>& S){T ret = *S.rbegin();return ret;}\ntemplate<class T> T peek_back(mset<T>& S){T ret = *S.rbegin();return ret;}\nvector<string> split(const string a, const char deli) {    string b = a + deli;    ll l = 0, r = 0, n = b.size();    vector<string> res;    rep(i, n) {        if (b[i] == deli) {            r = i;            if (l < r)res.push_back(b.substr(l, r - l));            l = i + 1;        }    }    return res;}\nvector<string> split(const string a, const string deli) {    vector<string> res;    ll kn = sz(deli);    std::string::size_type Pos(a.find(deli));    ll l = 0;    while (Pos != std::string::npos) {        if (Pos - l)res.push_back(a.substr(l, Pos - l));        l = Pos + kn;        Pos = a.find(deli, Pos + kn);    }    if (sz(a) - l)res.push_back(a.substr(l, sz(a) - l));    return res;}\nll stoi(string& s){return stol(s);}\n#define assert_yn(yn_v, v); assert(yn_v == 0 || yn_v == v);yn_v = v;\n//不完全な対策、現状はautohotkeyで対応\nint yn_v = 0;\nvoid yn(bool a) { assert_yn(yn_v, 1);if (a)cout << \"yes\" << endl; else cout << \"no\" << endl; }\nvoid fyn(bool a) {    assert_yn(yn_v, 1);yn(a);    exit(0);}\n\nvoid Yn(bool a) { assert_yn(yn_v, 2);if (a)cout << \"Yes\" << endl; else cout << \"No\" << endl; }\nvoid fYn(bool a) {    assert_yn(yn_v, 2);Yn(a);    exit(0);}\n\nvoid YN(bool a) { assert_yn(yn_v, 3);if (a)cout << \"YES\" << endl; else cout << \"NO\" << endl; }\nvoid fYN(bool a) {    assert_yn(yn_v, 3);YN(a);    exit(0);}\nint ab_v = 0;\nvoid fAb(bool a) { assert_yn(ab_v, 1);if(a)cout<<\"Alice\"<<endl;else cout<<\"Bob\";}\nvoid fAB(bool a) { assert_yn(yn_v, 2);if(a)cout<<\"ALICE\"<<endl;else cout<<\"BOB\";}\nint pos_v = 0;\nvoid Possible(bool a) {    assert_yn(pos_v, 1);if (a)cout << \"Possible\" << endl; else cout << \"Impossible\" << endl;    exit(0);}\nvoid POSSIBLE(bool a) {    assert_yn(pos_v, 2);if (a)cout << \"POSSIBLE\" << endl; else cout << \"IMPOSSIBLE\" << endl;    exit(0);}\nvoid fPossible(bool a) {    assert_yn(pos_v, 1)Possible(a);exit(0);}\nvoid fPOSSIBLE(bool a) {    assert_yn(pos_v, 2)POSSIBLE(a);exit(0);}\ntemplate<typename T> class fixed_point        : T {public:    explicit constexpr fixed_point(T &&t) noexcept: T(std::forward<T>(t)) {}    template<typename... Args> constexpr decltype(auto) operator()(Args &&... args) const { return T::operator()(*this, std::forward<Args>(args)...); }};template<typename T> static inline constexpr decltype(auto) fix(T &&t) noexcept { return fixed_point<T>{std::forward<T>(t)}; }\n\n\n//未分類\n//0,2,1 1番目と2番目の次元を入れ替える\ntemplate<class T> auto irekae(vector<vector<vector<T> > > &A, int x, int y, int z) {\n#define irekae_resize_loop(a, b, c) resize(res,a,b,c);rep(i,a)rep(j,b)rep(k,c)\n    vector<vector<vector<T> > > res;    if (x == 0 && y == 1 && z == 2) {        res = A;    } else if (x == 0 && y == 2 && z == 1) {        irekae_resize_loop(sz(A), sz(A[0][0]), sz(A[0])) {                    res[i][j][k] = A[i][k][j];                }    } else if (x == 1 && y == 0 && z == 2) {        irekae_resize_loop(sz(A[0]), sz(A), sz(A[0][0])) {                    res[i][j][k] = A[j][i][k];                }    } else if (x == 1 && y == 2 && z == 0) {        irekae_resize_loop(sz(A[0]), sz(A[0][0]), sz(A)) {                    res[i][j][k] = A[k][i][j];                }    } else if (x == 2 && y == 0 && z == 1) {        irekae_resize_loop(sz(A[0][0]), sz(A), sz(A[0])) {                    res[i][j][k] = A[j][k][i];                }    } else if (x == 2 && y == 1 && z == 0) {        irekae_resize_loop(sz(A[0][0]), sz(A[0]), sz(A)) {                    res[i][j][k] = A[k][j][i];                }    }    return res;\n#undef irekae_resize_loop\n}\ntemplate<class T> auto irekae(vector<vector<T>>&A,int i=1,int j=0){    vvt(res,sz(A[0]),sz(A));    rep(i,sz(A)){        rep(j,sz(A[0])){            res[j][i]=A[i][j];        }    }    return res;}\n//tou分割する\ntemplate<typename T> vector<vector<T>> cut(vector<T> &a, int tou = 2) {    int N = sz(a);    vector<vector<T>> res(tou);    int hab = N / tou;    vi lens(tou, hab);    rep(i, N % tou) { lens[tou - 1 - i]++; }    int l = 0;    rep(i, tou) {        int len = lens[i];        int r = l + len;        res[i].resize(len);        std::copy(a.begin() + l, a.begin() + r, res[i].begin());        l = r;    }    return res;}\n//長さn毎に分割する\ntemplate<typename T> vector<vector<T>> cutn(vector<T> &a, int len) {    int N = sz(a);    vector<vector<T>> res(ceil(N, len));    vi lens(N / len, len);    if (N % len)lens.push_back(N % len);    int l = 0;    rep(i, sz(lens)) {        int len = lens[i];        int r = l + len;        res[i].resize(len);        std::copy(a.begin() + l, a.begin() + r, res[i].begin());        l = r;    }    return res;}\n//縦を返す\nvi& geth(vvi()& a, int w){    static vi ret; ret.resize(sz(a));   rep(i,sz(a)){        ret[i] = a[i][w];    }    return ret;}\n\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} initonv;\n#define pre prev\n#define nex next\n\n//gra mll pr\n//上下左右\nconst string udlr = \"udlr\";\nstring UDLR = \"UDLR\";//x4と連動 UDLR.find('U') := x4[0]\nvc atoz = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x','y', 'z'};\nvc AtoZ = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X','Y', 'Z'};\n//右、上が正\nconstexpr ll h4[] = {1, -1, 0, 0};\nconstexpr ll w4[] = {0, 0, -1, 1};\nconstexpr ll h8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr ll w8[] = {1, 0, -1, 0, 1, -1, 1, -1};\nint mei_inc(int h, int w, int H, int W, int i) {while (++i < 4) { if (inside(h + h4[i], w + w4[i], H, W))return i; }return i;}\n#define mei(nh, nw, h, w) for (int i = mei_inc(h, w, H, W, -1), nh = i<4? h + h4[i] : 0, nw = i<4? w + w4[i] : 0; i < 4; i=mei_inc(h,w,H,W,i), nh = h+h4[i], nw = w+w4[i])\nint mei_inc8(int h, int w, int H, int W, int i) {    while (++i < 8) {        if (inside(h + h8[i], w + w8[i], H, W))return i;    }    return i;}\n#define mei8(nh, nw, h, w) for (int i = mei_inc8(h, w, H, W, -1), nh = i<8? h + h8[i] : 0, nw = i<8? w + w8[i] : 0; i < 8; i=mei_inc8(h,w,H,W,i), nh = h+h8[i], nw = w+w8[i])\nint mei_incv(int h, int w, int H, int W, int i, vp &p) {    while (++i < sz(p)) { if (inside(h + p[i].fi, w + p[i].se, H, W))return i; }    return i;}\n#define meiv(nh, nw, h, w, p) for (int i = mei_incv(h, w, H, W, -1, p), nh = i<sz(p)? h + p[i].fi : 0, nw = i<sz(p)? w + p[i].se : 0; i < sz(p); i=mei_incv(h,w,H,W,i,p), nh = h+p[i].fi, nw = w+p[i].se)\n\n//H*Wのグリッドを斜めに分割する\n//右上\nvector<vp> naname_list_ne(int H, int W) {    vector<vp> res(H + W - 1);    rep(sh, H) {        int sw = 0;        res[sh] += mp(sh, sw);        int nh = sh;        int nw = sw;        while (1) {            nh--;            nw++;            if (0 <= nh && nw < W) {                res[sh] += mp(nh, nw);            }else{                break;            }        }    }    rep(sw, 1, W) {        int sh = H - 1;        res[H + sw - 1] += mp(sh, sw);        int nh = sh;        int nw = sw;        while (1) {            nh--;            nw++;            if (0 <= nh && nw < W) {                res[H + sw-1] += mp(nh, nw);            }else{                break;            }        }    }    return res;}\n//右下\nvector<vp> naname_list_se(int H, int W) {    vector<vp> res(H + W - 1);    rep(sh, H) {        int sw = 0;        res[sh] += mp(sh, sw);        int nh = sh;        int nw = sw;        while (1) {            nh++;            nw++;            if (0 <= nh && nh< H && nw < W) { res[sh] += mp(nh, nw); } else { break; }        }    }    rep(sw, 1, W) {        int sh = 0;        res[H + sw - 1] += mp(sh, sw);        int nh = sh;        int nw = sw;        while (1) {            nh++;            nw++;            if (0 <= nh && nh < H && nw < W) { res[H + sw - 1] += mp(nh, nw); } else { break; }        }    }    return res;}\n\n//グラフ内で #undef getid\n//#define getidとしているため、ここを書き直したらgraphも書き直す\n#define getid_2(h, w) ((h) * (W) + (w))\n#define getid_1(p) ((p).first * W + (p).second)\n#define getid(...) over2(__VA_ARGS__, getid_2, getid_1) (__VA_ARGS__)\n#define getp(id) mp(id / W, id % W)\n//#define set_shuffle() std::random_device seed_gen;std::mt19937 engine(seed_gen())\n//#define shuffle(a) std::shuffle((a).begin(), (a).end(), engine);\n//1980 開始からtime ms経っていたらtrue\nvb bit_bool(int v, int len) {    assert(bit(len) > v);    vb ret(len);    rep(i, len) { ret[i] = bget(v, i); }    return ret;}\nvi &range(int l, int r) {static vi ret;ret.resize(r - l);rep(v, l, r) {ret[v - l] = v;}return ret;}\nvi &range(int r) {return range(0, r);}\nvi tov(vb& a){    vi ret;    rep(i,sz(a)){        if(a[i])ret.push_back(i);    }    return ret;}\nbool kaibun(const str& S){return S==rev(S);}\n\n#define rge range\n#define upd update\n//† ←template終了\n/*@formatter:on*/\n//vectorで取れる要素数\n//bool=> 1e9 * 8.32\n//int => 1e8 * 2.6\n//ll  => 1e8 * 1.3\n//3次元以上取るとメモリがヤバい\n//static配列を使う\n#define VEC vector\nvvc (ba);\nll N, M, H, W;\nvi A, B, C;\n\n//13:18\nvoid solve() {\n    int K;\n\n    in(H, W, K);\n    vvc(S);\n    nt(S, H, W);\n    dec(S, '0');\n    auto del_1 = [&](vvc() &S) {\n        vvc (ns, H, W, -1);\n        rep(w, W) {\n            int th = H - 1;\n            rer(h, H - 1) {\n                if (S[h][w] == -1)continue;\n                ns[th][w] = S[h][w];\n                th--;\n            }\n        }\n        return ns;\n    };\n    int ma = 0;\n    rep(dh, H) {\n        rep(dw, W) {\n            auto T = S;\n#define S !not_use!\n            T[dh][dw] = -1;\n            T = del_1(T);\n            int su = 0;\n            rep(step, 0, inf) {\n                int part = 0;\n                rep(h, H) {\n                    rep(w, W) {\n                        if(T[h][w]==-1)con;\n                        int len = find_if(sub(T[h],w, W), != T[h][w]);\n                        if(len >= K) {\n                            part += len * T[h][w];\n                            fill(T[h], w, w+len, -1);\n                        }\n                    }\n                }\n                su += bit(step) * part;\n                auto nex_T = del_1(T);\n                if (T == nex_T)break;\n                T = nex_T;\n                deb(T);\n            }\n            chma(ma, su);\n        }\n    }\n    out(ma);\n};\n\nauto my(ll n, vi &a) {\n    return 0;\n}\n\nauto sister(ll n, vi &a) {\n    ll ret = 0;\n    return ret;\n}\n\nsigned main() {\n    solve();\n\n#define arg n,a\n#ifdef _DEBUG\n\n    bool bad = 0;\n    for (ll i = 0, ok = 1; i < k5 && ok; ++i) {\n        ll n = rand(1, 8);\n        vi a = ranv(n, 1, 10);\n        auto myres = my(arg);\n        auto res = sister(arg);\n        ok = myres == res;\n        if (!ok) {\n            out(arg);\n            cerr << \"AC : \" << res << endl;\n            cerr << \"MY  : \" << myres << endl;\n            bad = 1;\n\n\n            break;\n        }\n    }\n    if (!bad) {\n//        cout << \"完璧 : solveを書き直そう\" << endl;\n//        cout << \"     : そして、solve()を呼び出すのだ\" << endl;\n//        cout << \"     : cin>>n; na(a,n);も忘れるな\" << endl;\n    }\n    if (was_deb && sz(res_mes)) {\n        cerr << \"result = \" << endl << res_mes << endl;\n    }\n    if (sz(message)) {\n        cerr << \"****************************\" << endl;\n        cerr << \"Note.\" << endl;\n        cerr << message << endl;\n        cerr << \"****************************\" << endl;\n    }\n#endif\n    return 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n#define DEBUG 1\nusing namespace std;\nconstexpr int kMod = 1000000007;\ntypedef long long LL;\n\nvector<vector<int>> cs;\nint H, W, K;\n\ntemplate<typename T>\nostream& operator << (ostream& os, const vector<T>& vs){\n  for (const T& v : vs) os << v << \" \";\n  return os;\n}\n\nint update(vector<vector<int>>& vv) {\n  vector<vector<int>> vv2(H, vector<int>(W, 0));\n  vector<int> pos(W, H-1);\n  int score = 0;\n  for (int r = H-1; r >= 0; --r) {\n    vector<bool> b(W, true);\n    for (int c = 0; c + K - 1 < W; ++c) {\n      int i = c;\n      while (vv[r][i] == vv[r][i + 1] && i + 1 < W) {\n        ++i;\n      }\n      if (i - c>= K - 1) {\n        for (int j = c; j <= i; ++j) b[j] = false;\n        c = i;\n      }\n    }\n    for (int c = 0; c < W; ++c) {\n      if (b[c]) {\n        vv2[pos[c]][c] = vv[r][c];\n        --pos[c];\n      } else {\n        score += vv[r][c];\n      }\n    }\n  }\n  vv = vv2;\n  return score;\n}\n\nint solve(int r, int c) {\n  vector<vector<int>> tmp(H, vector<int>(W, 0));\n  for (int i = 0; i < W; ++i) {\n    if (i != c) {\n      for (int j = H-1; j >= 0; --j) {\n          tmp[j][i] = cs[j][i];\n      }\n    } else {\n      int pos = H-1;\n      for (int j = H-1; j >= 0; --j) {\n        if (j == r) continue;\n        tmp[pos][i] = cs[j][i];\n        --pos;\n      }\n    }\n  }\n\n  int total = 0, score = 0, k = 1;\n  do {\n    score = update(tmp);\n    total += k * score;\n    k *= 2;\n  } while (score > 0);\n  return total;\n}\n\nint main() {\n  cin >> H >> W >> K;\n  cs.resize(H, vector<int>(W));\n  for (int i = 0; i < H; ++i) {\n    for (int j = 0; j < W; ++j) {\n      char c; cin >> c;\n      cs[i][j] = c - '0';\n    }\n  }\n\n  int vmax = 0;\n  for (int i = 0; i < H; ++i) {\n    for (int j = 0; j < W; ++j) {\n      vmax = max(vmax, solve(i, j));\n    }\n  }\n  cout << vmax << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(i=0;i<n;i++)\n#define ll long long\n#define all(v) v.begin(), v.end()\nint main(){\n  int h,w,k;cin>>h>>w>>k;\n  vector<vector<int>> c(h,vector<int>(w));\n  int i,j,l,n,p;\n  rep(i,h)rep(j,w){\n    char ch;cin>>ch;\n    c[i][j]=(ch-'0');\n  }\n  int ans=0;\n  rep(i,h)rep(j,w){\n    bool update=true;\n    vector<vector<int>> m(h,vector<int>(w));\n    m=c;\n    m[i][j]=0;\n    int score=0;\n    int timev=1;\n    while(update) {\n      update=false;\n      rep(n,w){\n        int to=h-1;\n        for(l=h-1;l>=0;l--){\n          if(m[l][n]!=0){\n            swap(m[to][n],m[l][n]);\n            to--;\n          }\n        }\n      }\n      int get=0;\n      rep(l,h){\n        int from=0;\n        int now=m[l][n];\n        rep(n,w){\n          if(now!=m[l][n]){\n            int dis=(n-1)-from+1;\n            if(dis>=k){\n              for(p=from;p<n;p++) {\n                get+=m[l][p];\n                m[l][p]=0;\n              }\n            }\n            from=n;\n            now=m[l][n];\n          }\n        }\n        int dis=(w-1)-from+1;\n        if(dis>=k){\n          for(p=from;p<n;p++){\n            get+=m[l][p];\n            m[l][p]=0;\n          }\n        }\n      }\n      if(get>0)update=true;\n      else break;\n      score+=timev*get;\n      timev*=2;\n    }\n    ans=max(ans,score);\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nint a[40][40],b[40][40],n,m,k,ans = 0;\nstring str[40];\nvoid fall(int a[40][40])\n{\n    for (int j = 0;j < m;j++)\n    {\n        int bot = n-1,tmp[40];\n        for (int i = n-1;i >= 0;i--)\n        {\n            tmp[i] = 0;\n            if (a[i][j])\n            {\n                tmp[bot] = a[i][j];\n                bot--;\n            }\n        }\n        for (int i = n-1;i >= 0;i--) a[i][j] = tmp[i];\n    }\n}\nint check(int a[40][40])\n{\n    int ret = 0;\n    for (int i = 0;i < n;i++)\n    {\n        int num = 0,tot = 0;\n        for (int j = 0;j < m;j++)\n        {\n            if (a[i][j] != num)\n            {\n                if (tot >= k)\n                {\n                    ret += tot*num;\n                    for (int x = 1;x <= tot;x++) a[i][j-x] = 0;\n                }\n                tot = 1;\n                num = a[i][j];\n            } else tot++;\n        }\n        if (tot >= k)\n        {\n            ret += tot*num;\n            for (int x = 1;x <= tot;x++) a[i][m-x] = 0;\n        }\n    }\n    return ret;\n}\nint calc(int x,int y)\n{\n    for (int i = 0;i < n;i++)\n        for (int j = 0;j < m;j++)\n            b[i][j] = a[i][j];\n    b[x][y] = 0;\n    fall(b);\n    int ans = 0,c = 1;\n    while (1)\n    {\n        int tmp = check(b);\n        if (tmp == 0) break;\n        ans += c*tmp;\n        c *= 2;\n        fall(b);\n    }\n    return ans;\n}\nint main()\n{\n    cin >> n >> m >> k;\n    for (int i = 0;i < n;i++) cin >> str[i];\n    for (int i = 0;i < n;i++)\n        for (int j = 0;j < m;j++)\n            a[i][j] = str[i][j] - '0';\n    for (int i = 0;i < n;i++)\n        for (int j = 0;j < m;j++)\n        {\n            int tmp = calc(i,j);\n            ans = tmp>ans?tmp:ans;\n        }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\n#include <iomanip>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<long double> VD;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef vector<VD> VVD;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n#define INF 1LL<<60\n\nint main() {\n    int H, W, K;\n    cin >> H >> W >> K;\n    vector< vector<int> > block_base(H + 2, vector<int>(W + 2, -1));\n    vector< vector<int> > block(H + 2, vector<int>(W + 2, -1));\n\n    FOR(i, 1, H) {\n        string s;\n        cin >> s;\n        FOR(j, 1, W) {\n            block_base[i][j] = int(s[j-1] - '0');\n        }\n    }\n    int ans = 0;\n\n    FOR(i_rm, 1, H)\n        FOR(j_rm, 1, W) {\n            FOR(i, 0, H+1) FOR(j,0, W+1) block[i][j] = block_base[i][j];\n\n            // cerr << \"remove : (\" << i_rm << \", \" << j_rm << \")\" << endl;\n            block[i_rm][j_rm] = 0;\n            REP(z, H) {\n                FORR(i, H, 1) {\n                    FOR(j, 1, W) {\n                        if(block[i][j] == 0) {\n                            block[i][j] = block[i-1][j];\n                            block[i-1][j] = 0;\n                        }\n                    }\n                }\n            }\n\n            // cerr << \"------------------------\" << endl;\n            // FOR(i, 1, H) {\n            //     FOR(j, 1, W) cerr << block[i][j];\n            //     cerr << endl;\n            // }\n            // cerr << \"------------------------\" << endl;\n            \n            bool update = true;\n\n            int ans_cand = 0, t = 0;\n            while(update) {\n                update = false;\n                int t_th_sum = 0;\n                FOR(i, 1, H) {\n                    int prev = -1, cont = 1;\n                    FOR(j, 1, W+1) {\n                        if(block[i][j] != prev) {\n                            if(cont >= K) {\n                                // cerr << \"prev: \" << prev << \" cont: \" << cont << endl;\n                                t_th_sum += prev * cont;\n                                REP(k, cont) block[i][j - 1 - k] = 0;\n                                update = true;\n                            }\n                            cont = 1;\n                            prev = block[i][j];\n                        } else if(block[i][j] > 0) {\n                            cont++;\n                        }\n                    }\n                }\n\n                REP(z, H) {\n                    FORR(i, H, 1) {\n                        FOR(j, 1, W) {\n                            if(block[i][j] == 0) {\n                                block[i][j] = block[i-1][j];\n                                block[i-1][j] = 0;;\n                            }\n                        }\n                    }\n                }\n                // cerr << \"t: \" << t << \" t_th_sum: \" << t_th_sum << endl;\n                ans_cand += pow(2, t++) * t_th_sum;\n            }\n            ans = max(ans, ans_cand);\n        }\n    \n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . ___\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n              find_str Bao You\n*/\n#include <iostream>\n#include <queue>\n#include <assert.h>   \n#include <vector>\n#include <algorithm>\n#include <time.h>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <unordered_set>\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <numeric>\n#include <deque>\n#include <iomanip>\n#include <cstdlib>\n#include <climits>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define ll long long\n#define ld long double \n#define pi pair<int, int> \n#define pl pair<ll,ll>  \n#define pd pair<ld,ld> \n#define str string  \n#define mp make_pair\n#define vi vector<int> \n#define vl vector<ll> \n#define vd vector<ld> \n#define vs vector<str> \n#define vpi vector<pi> \n#define vpl vector<pl> \n#define vpd vector<pd> \n#define si set<int> \n#define FF(i,j,n) for(signed i=j;i<=n;i++)  \n#define DD(i,j,n) for(signed i=j;i>=n;i--) \n#define F(i,j,n) for(signed i=j;i<n;i++)   \n#define D(i,j,n) for(signed i=j;i>n;i--) \n#define mem(a,b) memset(a,b,sizeof(a))\n#define ndl cout << endl\n#define ull unsigned long long \n\nconst int inf = 0x3f3f3f3f;\nconst ll INF = 0x3f3f3f3f3f3f3f3fLL;\n\n\n#define sz(x) (signed)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back() \n#define fi first\n#define se second\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n#define IOS ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n\n//math\nconst int mod = 1e9 + 7;\n\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\nint pct(int x) { return __builtin_popcount(x); } \nint bit(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nint cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \n\n\n//DEBUG, compile with -DLOCAL\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n  cerr << to_string(h); if (sizeof...(t)) cerr << \", \";\n  DBG(t...); }\n#ifdef LOCAL \n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#define HERE cout << \"===GOTHERE===\" << endl\n#else\n#define dbg(...) 42\n#define HERE 42\n#endif\n\n//#define double long double\n//#define int long long\n//#define int unsigned long long\n\nconst int maxn = 1e5*2+20;\n\nint n,_,q,k;\nint h,w;\n\nstr raw[40];\n\nint l,r;\n\nint org[35][35];\nint a[35][35];\nint ptr[35];\n\nvoid prep(){\n  FF(i,0,h)FF(j,0,w) a[i][j] = org[i][j];\n  FF(i,1,w) ptr[i] = h;\n}\n\nint check(){\n  FF(i,1,w){\n    int j = i;\n    while(a[ptr[i]][i] == a[ptr[j]][j]){\n      \n      //dbg(a[ptr[j]][j],i,j);\n      j++;\n    }\n    int tt = (j-i) * a[ptr[i]][i];\n    if(tt > 0 && j - i >= k){\n      l = i; r = j;\n      return tt;\n    }\n    i = j - 1;\n  }\n  return -1;\n}\n\nbool notFinished(){\n  int yes = false;\n  FF(i,1,w){\n    if(ptr[i] > 0) yes = true;\n  }\n  return yes;\n}\n\nvoid renew(){\n  FF(i,1,w) ptr[i] = h;\n  FF(i,1,w){\n    while(ptr[i] != 0 && a[ptr[i]][i] < 0) ptr[i]--;\n  }\n}\n\nvoid updateptr(){\n  FF(i,1,w){\n    if(ptr[i] > 0) ptr[i] --;\n  }\n  FF(i,1,w){\n    while(ptr[i] != 0 && a[ptr[i]][i] < 0) ptr[i]--;\n  }\n}\n\nvoid update(){\n    FF(i,1,w){\n    while(ptr[i] != 0 && a[ptr[i]][i] < 0) ptr[i]--;\n  }\n}\n\nvoid solve(){\n  FF(i,0,h)FF(j,0,w){\n    org[i][j] = -1;\n  }\n  FF(i,1,h){\n    cin >> raw[i];\n  }\n\n\n\n  FF(i,1,h)FF(j,1,w){\n    org[i][j] = raw[i][j-1] - '0';\n  }\n\n  int ans = -1;\n\n  FF(q,1,w){\n    FF(p,1,h){\n    prep();\n    int pw = 0;\n    int anst = 0;\n    a[p][q] = -1;\n\n    bool deleted = true;\n    //cout << \"triail\" << endl;\n    while(deleted){\n      deleted = false;\n      renew();\n      //cout << \"renewed\" << endl;\n      while(notFinished()){\n        // FF(i,1,w){\n        //   dbg(ptr[i]);\n        // }\n\n        int score = check();\n        //dbg(score);\n        if(score == -1){\n          updateptr();\n        }else{\n          deleted = true;\n          anst += (pow(2,pw)*score);\n          F(i,l,r){\n            a[ptr[i]][i] = -1;\n          }\n          updateptr();\n        }\n      }\n      pw++;\n    }\n    ans = max(ans, anst);\n    }\n  }\n  cout << ans << endl;\n\n}\n\nsigned main(){\n  //clock_t t1 = clock();  \n\tIOS\n  cin >> h >> w >> k;\n\tsolve();\n  \n  //cout << \"THE ALGORITHM TOOK: \" << (clock() - t1) * 1.0 / CLOCKS_PER_SEC * 1000 << \"ms\"<< endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define REP(i,n) for (int i = 1; i < (int)(n); i++)\ntemplate<class T> bool chmin(T &a, T b) {if(a>b) {a=b;return 1;}return 0;}\nusing namespace std;\nusing vint = vector<int>;\nusing vvint = vector<vector<int>>;\nusing ll = long long;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nusing P = pair<int,int>;\nconst double inf = 1e9;\nconst int mod = 1e5;\nconst int MAX = 5005;\n\nstruct status {int y, x, len;};\n\nint main() {\n    int h, w, K; cin >> h >> w >> K;\n    vector<string> field_s(h);\n    rep(i,h) cin >> field_s[i];\n    vvint field_ori(h,vint(w));\n    rep(i,h)rep(j,w) field_ori[i][j] = field_s[i][j] - '0';\n    int ans = 0;\n    rep(i,h)rep(j,w) {\n        int sum = 0;\n        vvint field = field_ori;\n        field[i][j] = 0;\n        deque<int> q;\n        rep(a,h) if (field[a][j] != 0) q.push_back(field[a][j]);\n        while (q.size() < h) q.push_front(0);\n        rep(a,h) {\n            int x = q.front(); q.pop_front();\n            field[a][j] = x;\n        }\n        int now = 0;\n        while (true) {\n            bool update = false;\n            rep(k,h) {\n                int index = 0;\n                int ct = 1;\n                rep(l,w) {\n                    if (field[k][l] == field[k][l+1] && l != w-1) ct++;\n                    else {\n                        if (ct >= K) {\n                            if (field[k][index] != 0) update = true;\n                            sum += field[k][index]*ct*pow(2,now);\n                            for (int m = index; m < index+ct; m++) field[k][m] = 0;\n                        }\n                        index = l+1;\n                        ct = 1;\n                    }\n                }\n            }\n            if (!update) {ans = max(ans,sum); break;}\n            deque<int> q;\n            rep(l,w) {\n                rep(k,h) if (field[k][l] != 0) q.push_back(field[k][l]);\n                while (q.size() < h) q.push_front(0);\n                rep(k,h) {\n                    int x = q.front(); q.pop_front();\n                    field[k][l] = x;\n                }\n            }\n            now++;\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <math.h>\n#include <iostream>\n#include <numeric>\n#define rep(i,n) for (int i = 0;i < (n); ++i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n#define chmax(x,y) x = max(x,y)\nint INF = 1e9;\n\nint h,w,k;\n\n// vector<int> del(vector<int> v,int &score){\n// \tint n = v.size();\n// \tvector<int> ret(n);\n// \tret = v;\n// \trep(i,n-k+1){\n// \t\tint temp = ret[i];\n// \t\tif(temp == 0) continue;\n// \t\tbool flag = true;\n// \t\trep(j,k) {\n// \t\t\tif(ret[i+j] != temp){\n// \t\t\t\tflag = false;\n// \t\t\t\tbreak;\n// \t\t\t}\n// \t\t}\n// \t\tif(flag) {\n// \t\t\tint ind = i;\n// \t\t\twhile(ret[ind]==temp){\n// \t\t\t\tret[ind]=0;\n// \t\t\t\tind++;\n// \t\t\t}\n// \t\t\tscore += (ind-i)*temp;\n// \t\t}\n// \t}\n// \treturn ret;\n// }\nbool del(vector<int> &v,int &score){\n\tint n = v.size();\n\tint ad = 0;\n\trep(i,n-k+1){\n\t\tint temp = v[i];\n\t\tif(temp == 0) continue;\n\t\tbool flag = true;\n\t\trep(j,k) {\n\t\t\tif(v[i+j] != temp){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag) {\n\t\t\tint ind = i;\n\t\t\twhile(v[ind]==temp){\n\t\t\t\tv[ind]=0;\n\t\t\t\tind++;\n\t\t\t}\n\t\t\tad += (ind-i)*temp;\n\t\t}\n\t}\n\t//cout << ad << \" ad\" << endl;\n\n\tif(ad > 0) {\n\t\tscore += ad;\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nint clr(vector<vector<int>> &G){\n\tint score = 0;\n\tint num = 0;\n\tfor(int i = h;i>0;i--){\n\t\tif(del(G[i],score)) num++;\n\t}\n\trep(nu,num){\n\t\trep(j,w){\n\t\t\tfor(int i = h;i > 0;i--){\n\t\t\t\tif(G[i][j]==0){\n\t\t\t\t\tint dummy = G[i-1][j];\n\t\t\t\t\tG[i-1][j] = G[i][j];\n\t\t\t\t\tG[i][j] = dummy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn score;\n}\n\nint main(){\n\tcin >> h >> w >> k;\n\tvector<vector<int>> G(33,vector<int>(33,0));\n\trep(i,h){\n\t\tstring s;cin >> s;\n\t\trep(j,w) G[i+1][j] = s[j]-'0';\n\t}\n\n\tint ans = 0;\n\tfor(int i = 1;i<=h;i++)rep(j,w){\n\t\tvector<vector<int>> H;\n\t\tH = G;\n\t\tH[i][j] = 0;\n\t\tfor(int y = i;y>0;y--){\n\t\t\tint dummy = H[y-1][j];\n\t\t\tH[y-1][j] = H[y][j];\n\t\t\tH[y][j] = dummy;\n\t\t}\n\t\t// rep(y,h){\n\t\t// \tcout << endl;\n\t\t// \trep(x,w) cout << H[y+1][x] << \" \";\n\t\t// }\n\t\t// int du;cin >> du;\n\t\tint ind = 1;\n\t\tint score = 1;\n\t\tint sum = 0;\n\t\twhile(score != 0){\n\t\t\tscore = clr(H)*ind;\n\t\t\tsum += score;\n\t\t\tind*=2;\n\t\t}\n\t\t//printf(\"%d %d %d\\n\",i,j,sum);\n\t\tans = max(ans,sum);\n\t}\n\tcout << ans << endl;\n\n}\n \n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\n#define N_MAX 40010\n#define INF 1e9\n#define F_MAX 200000\n\nint h, w, k;\n\nint score(vector<queue<int> > vq, int n){\n    vector<queue<int> > vq_next(w);\n    int res = 0;\n    REP(p,h){\n        VI a(w+1);\n        REP(j,w){\n            if (!vq[j].empty()) {\n                a[j] = vq[j].front();\n                vq[j].pop();\n            }\n        }\n        // REP(i,w){\n        //     cout << a[i];\n        // }\n        // cout << endl;\n        REP(i,w){\n            int j = 0;\n            while (a[j+i] == a[i] && j+i < w) j++;\n            if (j >= k) {\n                res += a[i] * j;\n                REP(q,j) a[i+q] = 0;\n            }\n            i += j-1;\n        }\n        REP(i,w){\n            if (a[i] > 0)\n                vq_next[i].push(a[i]);\n        }\n    }\n    res <<= n;\n    if (res == 0) return res;\n    else return res + score(vq_next, n+1);\n}\n\nint main() {\n    cin >> h >> w >> k;\n    VVI c(w,VI(h));\n\n    REP(i,h){\n        string s;\n        cin >> s;\n        REP(j,w) c[j][h-1-i] = s[j] - '0';\n    }\n\n    int ans = 0;\n    REP(e,w){\n        vector<queue<int> > vq(w);\n        REP(i,w) REP(j,h){\n            if (i != e || j > 0)\n                vq[i].push(c[i][j]);\n        }\n        int res = score(vq, 0);\n        ans = max(ans, res);\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll h,w,k,dp[30][30],L,rans,MAX,dp2[30][30];\nstring S;\nvector<ll> v;\nll f(ll cnt){\n    ll ans=0;\n    for(int i=0;i<h;i++){\n        ll cnt1=0;\n        ll cnt2=1;\n        for(int j=1;j<w;j++){\n            if(dp[i][j-1]==dp[i][j])cnt2++;\n            else{\n                if(cnt2>=k){\n                    ans+=pow(2,cnt)*cnt2*dp[i][cnt1];\n                    for(int ii=0;ii<cnt2;ii++)dp[i][cnt1+ii]=0;\n                    cnt1=j;\n                    cnt2=1;\n                }\n                else{\n                    cnt1=j;\n                    cnt2=1;\n                }\n            }\n        }\n        \n        if(cnt2>=k){\n            ans+=pow(2,cnt)*cnt2*dp[i][cnt1];\n            for(int ii=0;ii<cnt2;ii++)dp[i][cnt1+ii]=0;\n        }\n    }\n    return ans;\n}\nvoid f2(void){\n    for(int i=0;i<w;i++){\n        ll tmp=0;\n        v={};\n        for(int j=h-1;j>=0;j--){\n            if(dp[j][i]!=0)v.push_back(dp[j][i]);\n            else tmp++;\n        }\n        while(tmp--)v.push_back(0);\n        for(int j=h-1;j>=0;j--){\n            dp[j][i]=v[h-1-j];\n        }\n    }\n    return ;\n}\nvoid ini(void){\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            dp[i][j]=dp2[i][j];\n        }\n    }\n}\nint main(void){\n    cin>>h>>w>>k;\n    for(int i=0;i<h;i++){\n        cin>>S;\n        for(int j=0;j<w;j++){\n            dp2[i][j]=S[j]-'0';\n            dp[i][j]=S[j]-'0';\n        }\n    }\n    for(int i=1;i<h;i++){\n        for(int j=0;j<w;j++){\n            \n            ini();\n            ll cnt=0;\n            rans=0;\n            dp[i][j]=0;\n            //cout<<i<<\" \"<<j<<endl;\n            \n            while(1){\n                \n    \n    \n    \n                f2();\n                \n                \n                \n                /*for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            cout<<dp[i][j];\n        }\n        cout<<endl;\n    }\n    cout<<endl;*/\n                \n                \n                \n                \n                L=f(cnt);\n                //cout<<L<<endl;\n                if(L==0)break;\n                rans+=L;\n                cnt++;\n                \n            }\n            MAX=max(rans,MAX);\n            //cout<<MAX<<endl;\n        }\n    }\n    cout<<MAX<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>; using pll = pair<ll, ll>; using pdd = pair<double, double>; using pss = pair<string, string>; using pcc = pair<char, char>; using pbb = pair<bool, bool>; using pil = pair<int, ll>; using pli = pair<ll, int>;\nusing ti3 = tuple<int, int, int>; using tl3 = tuple<ll, ll, ll>; using td3 = tuple<double, double, double>; using ts3 = tuple<string, string, string>; using tc3 = tuple<char, char, char>; using tb3 = tuple<bool, bool, bool>;\nusing ti4 = tuple<int, int, int, int>; using tl4 = tuple<ll, ll, ll, ll>; using td4 = tuple<double, double, double, double>; using ts4 = tuple<string, string, string, string>; using tc4 = tuple<char, char, char, char>; using tb4 = tuple<bool, bool, bool, bool>;\nusing vi = vector<int>; using vl = vector<ll>; using vd = vector<double>; using vs = vector<string>; using vc = vector<char>; using vb = vector<bool>;\nusing vvi = vector<vi>; using vvl = vector<vl>; using vvd = vector<vd>; using vvs = vector<vs>; using vvc = vector<vc>; using vvb = vector<vb>;\nusing vvvi = vector<vvi>; using vvvl = vector<vvl>; using vvvd = vector<vvd>; using vvvs = vector<vvs>; using vvvc = vector<vvc>; using vvvb = vector<vvb>;\nusing vpii = vector<pii>; using vpll = vector<pll>; using vpdd = vector<pdd>; using vpss = vector<pss>; using vpcc = vector<pcc>; using vpbb = vector<pbb>; using vpil = vector<pil>; using vpli = vector<pli>;\nusing vti3 = vector<ti3>; using vtl3 = vector<tl3>; using vtd3 = vector<td3>; using vts3 = vector<ts3>; using vtc3 = vector<tc3>; using vtb3 = vector<tb3>;\nusing vti4 = vector<ti4>; using vtl4 = vector<tl4>; using vtd4 = vector<td4>; using vts4 = vector<ts4>; using vtc4 = vector<tc4>; using vtb4 = vector<tb4>;\nusing mii = map<int, int>; using mll = map<ll, ll>; using msi = map<string, int>; using mci = map<char, int>; using mil = map<int, ll>; using mli = map<ll, int>;\nusing si = set<int>; using sl = set<ll>; using sd = set<double>; using ss = set<string>; using sc = set<char>; using sb = set<bool>;\nusing spii = set<pii>; using spll = set<pll>; using spdd = set<pdd>; using spss = set<pss>; using spcc = set<pcc>; using spbb = set<pbb>; using spil = set<pil>; using spli = set<pli>;\nusing sti3 = set<ti3>; using stl3 = set<tl3>; using std3 = set<td3>; using sts3 = set<ts3>; using stc3 = set<tc3>; using stb3 = set<tb3>;\n#define rep0(TMS) for (int CNT = 0; CNT < (int)(TMS); CNT++)\n#define rep(CNT, GOAL) for (int CNT = 0; CNT < (int)(GOAL); CNT++)\n#define rep2(CNT, START, GOAL) for (ll CNT = (ll)(START); CNT < (ll)(GOAL); CNT++)\n#define rep3(CNT, START, GOAL) for (ll CNT = (ll)(START); CNT > (ll)(GOAL); CNT--)\n#define all(CONT) begin(CONT), end(CONT)\n#define fr1(CONT) next(begin(CONT)), end(CONT)\n#define itrep(ITR, CONT) for (auto ITR = begin(CONT); ITR != end(CONT); ITR++)\n#define itrep1(ITR, CONT) for (auto ITR = next(begin(CONT)); ITR != end(CONT); ITR++)\n#define maxel(CONT) *max_element(all(CONT))\n#define minel(CONT) *min_element(all(CONT))\ntemplate <typename T> bool chmax(T &a, const T &b) { if (a < b) {\ta = b; return true;\t}\treturn false; }\ntemplate <typename T> bool chmin(T &a, const T &b) { if (a > b) {\ta = b; return true;\t}\treturn false; }\ntemplate <typename T> T sum(const vector<T> &VEC) { return accumulate(all(VEC), 0.0); }\ntemplate <typename T> vector<T> acm(const vector<T> &VEC) { vector<T> RES(VEC.size() + 1); rep(CNT, VEC.size()) RES[CNT + 1] = RES[CNT] + VEC[CNT];\treturn RES; }\ntemplate <typename T> void fil(vector<T> &VEC, const int NUM, const T &VAL) { VEC.assign(NUM, VAL); }\ntemplate <typename T> void fil(vector<T> &VEC, const int NUM) { VEC.assign(NUM, 0.0); }\ntemplate <typename T> void fil(vector<vector<T>> &VV, const int RNUM, const int CNUM, const T &VAL) { fil(VV, RNUM, vector<T>()); rep(CNT, RNUM) fil(VV[CNT], CNUM, VAL); }\ntemplate <typename T> void fil(vector<vector<T>> &VV, const int RNUM, const int CNUM) { fil(VV, RNUM, vector<T>()); rep(CNT, RNUM) fil(VV[CNT], CNUM); }\ntemplate <typename T> void fil(vector<vector<T>> &VV, const int RNUM) { fil(VV, RNUM, vector<T>()); }\nvoid prec(const int &DIG) { cerr << fixed << setprecision(DIG); cout << fixed << setprecision(DIG); }\ntemplate <typename T> void COUT(const T &ELEM) { cout << ELEM; }\ntemplate <typename T> void pout(const T &ELEM) { COUT(ELEM); cout << \" \"; }\ntemplate <typename T, typename ...Ts> void pout(const T &FIRST, const Ts &...REST) { pout(FIRST); pout(REST...); }\ntemplate <typename T> void print(T ELEM) { COUT(ELEM); cout << \"\\n\"; }\ntemplate <typename T, typename ...Ts> void print(const T &FIRST, const Ts &...REST) { print(FIRST); print(REST...); }\nvoid CERR() { cerr << \"\\n\"; }\ntemplate <typename T> void CERR(const T &ELEM) { cerr << ELEM; }\ntemplate <typename T, typename ...Ts> void CERR(const T &FIRST, const Ts &...REST) { CERR(FIRST); cerr << \", \"; CERR(REST...); }\ntemplate <typename T1, typename T2> void CERR(const pair<T1, T2> &PAIR) { cerr << \"(\"; CERR(PAIR.first); cerr << \", \"; CERR(PAIR.second); cerr << \")\"; }\ntemplate <typename T1, typename T2, typename T3> void CERR(const tuple<T1, T2, T3> &TUP3) { cerr << \"(\"; CERR(get<0>(TUP3)); cerr << \", \"; CERR(get<1>(TUP3)); cerr << \", \"; CERR(get<2>(TUP3)); cerr << \")\"; }\ntemplate <typename T1, typename T2, typename T3, typename T4> void CERR(const tuple<T1, T2, T3, T4> &TUP4) { cerr << \"(\"; CERR(get<0>(TUP4)); cerr << \", \"; CERR(get<1>(TUP4)); cerr << \", \"; CERR(get<2>(TUP4)); cerr << \", \"; CERR(get<3>(TUP4)); cerr << \")\"; }\ntemplate <typename T> void CERR(const vector<T> &VEC) { cerr << \"{ \"; itrep(ITR, VEC) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\ntemplate <typename T> void CERR1(const vector<T> &VEC) { cerr << \"{ \"; itrep1(ITR, VEC) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\ntemplate <typename T> void CERR(const set<T> &SET) { cerr << \"{ \"; itrep(ITR, SET) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\ntemplate <typename T1, typename T2> void CERR(const map<T1, T2> &MAP) { cerr << \"{ \"; itrep(ITR, MAP) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\n#define db(OBJ) cerr << #OBJ << \": \"; CERR(OBJ); cerr << \", \"\n#define dbl(OBJ) cerr << #OBJ << \": \"; CERR(OBJ); cerr << \"\\n\"\n#define db1(OBJ) cerr << #OBJ << \": \"; CERR1(OBJ); cerr << \"\\n\"\n#define dbs(...) cerr << \"(\" << #__VA_ARGS__ << \"): (\"; CERR(__VA_ARGS__); cerr << \")\\n\"\n#define dbvv(VV) cerr << #VV << \": {\\n\"; rep(CNT, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define db01(VV) cerr << #VV << \": {\\n\"; rep(CNT, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR1(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define db10(VV) cerr << #VV << \": {\\n\"; rep2(CNT, 1, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define db11(VV) cerr << #VV << \": {\\n\"; rep2(CNT, 1, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR1(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define YN(FLG) cout << (FLG ? \"YES\" : \"NO\") << \"\\n\"\n#define Yn(FLG) cout << (FLG ? \"Yes\" : \"No\") << \"\\n\"\n#define yn(FLG) cout << (FLG ? \"yes\" : \"no\") << \"\\n\"\n#define pcase(NUM) cout << \"Case #\" << NUM << \":\" << \" \"\n#define pcasel(NUM) cout << \"Case #\" << NUM << \":\" << \"\\n\"\nconst int INF = 1e9 + 7;\n// db\n\nint H, W, K;\nvvi a;\n\nint fall(int h, vvi &a) {\n\t// CERR(\"fall() \"); dbl(h);\n\tint fall_res = 0;\n\tint cur = 0, cnt = 0;\t// cur,cnt初期値\n\tauto erase = [&](int cnt, int g) { // 石消滅時の処理，gは消滅する石のうち最も右にあるものの列番号(i)\n\t\tfall_res += cur * cnt; // 得点加算(cur,cnt使用)\n\t\trep3(t, g, g - cnt) a[t].erase(begin(a[t]) + h); // 石消滅(cnt使用，a[t][h]更新)\n\t\t// 呼出し元によって処理が異なるため，cur,cntをここで更新してはいけない。\n\t};\n\trep(i, W) {\n\t\t// dbs(i, cur, cnt);\n\t\tif (a[i].size() > h) { // 石がある場合\t\t\t\n\t\t\tif (a[i][h] == cur) { // 石の色が同じ場合，何もしない\n\t\t\t\tcnt++; // cnt更新\n\t\t\t} else { // 石の色が異なる場合\n\t\t\t\tif (cnt >= K) erase(cnt, i - 1); // 石が消滅する場合\n\t\t\t\tcur = a[i][h]; cnt = 1; // cur,cnt更新(消滅の有無によらない)\n\t\t\t}\n\t\t} else { // 石がない場合\n\t\t\tif (cnt >= K) erase(cnt, i - 1); // 石が消滅する場合\n\t\t\tcur = 0; cnt = 0; // cur,cnt更新(消滅の有無によらない)\t\t\t\n\t\t}\n\t\t// dbs(i, cur, cnt);\n\t}\n\t// 第h行を見終わった後\t\n\tif (cnt >= K) erase(cnt, W - 1);\t\n\t// dbl(fall_res);\n\treturn fall_res;\n}\n\nint check(vvi &a) { // aは参照渡し\n\t// CERR(\"check()\\n\");\n\tint check_res = 0;\n\trep3(h, H - 1, -1) check_res += fall(h, a);\n\t// dbl(check_res);\n\treturn check_res;\n}\n\nint solve(int w, int h, vvi a) { // aは値渡し\n\t// CERR(\"solve() \"); dbs(w, h);\n\tint solve_res = 0;\n\ta[w].erase(begin(a[w]) + h);\t\n\tint powcoe = 1;\n\twhile (true) {\n\t\tint check_res = check(a); // aは参照渡し\n\t\tsolve_res += check_res * powcoe;\n\t\tpowcoe *= 2;\n\t\tif (!check_res) break;\n\t}\n\t// dbvv(a);\n\t// dbl(solve_res);\n\treturn solve_res;\n}\n\nint main() {\n\tcin >> H >> W >> K;\n\tfil(a, W, H); char c;\n\trep3(h, H - 1, -1) rep(i, W) { cin >> c; a[i][h] = c - '0'; }\n\tint ans = 0;\n\trep(w, W) rep(h, H) chmax(ans, solve(w, h, a)); // aは値渡し\n\tprint(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <boost/multiprecision/cpp_int.hpp>\n//namespace mp = boost::multiprecision;\n\nusing namespace std;\n\nconst double PI = 3.14159265358979323846;\ntypedef long long ll;\nconst double EPS = 1e-9;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\ntypedef pair<ll, ll> P;\nconst ll INF = 10e17;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n#define ret() return 0;\n\ndouble equal(double a, double b) {\n    return fabs(a - b) < DBL_EPSILON;\n}\n\nstd::istream &operator>>(std::istream &in, set<int> &o) {\n    int a;\n    in >> a;\n    o.insert(a);\n    return in;\n}\n\nstd::istream &operator>>(std::istream &in, queue<int> &o) {\n    ll a;\n    in >> a;\n    o.push(a);\n    return in;\n}\n\nbool contain(set<int> &s, int a) { return s.find(a) != s.end(); }\n\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\n//const ll mod = 1e10;\n\ntypedef priority_queue<ll, vector<ll>, greater<ll> > PQ_ASK;\n\nvoid down(int h, int w, vector<vector<char>> &board, int fy, int fx) {\n    for (int y = fy; y >= 1; y--) {\n        board[y][fx] = board[y - 1][fx];\n    }\n    board[0][fx] = ' ';\n}\n\nclass UnionFind {\npublic:\n    // 親の番号を格納する。親だった場合-size\n    vector<int> parents;\n\n    UnionFind(int n) {\n        parents = vector<int>(n, -1);\n    }\n\n    // aがどのグループに属しているか\n    int root(int a) {\n        if (parents[a] < 0) {\n            return a;\n        }\n        return parents[a] = root(parents[a]);\n    }\n\n    int size(int a) {\n        return -parents[root(a)];\n    }\n\n    // aとbをくっつける\n    bool connect(int a, int b) {\n        int ra = root(a);\n        int rb = root(b);\n        if (ra == rb) {\n            return false;\n        }\n        // 大きいほうにA\n        if (size(ra) < size(rb)) {\n            swap(ra, rb);\n        }\n        parents[ra] += parents[rb];\n        parents[rb] = ra;\n        return true;\n    }\n\n    bool is_union(int a, int b) {\n        int ra = root(a);\n        int rb = root(b);\n        return ra == rb;\n    }\n};\n\nbool has_set(int h, int w, int k, vector<vector<char>> &board) {\n    UnionFind uf(h * w);\n    auto to_id = [&](int y, int x) {\n        return y * w + x;\n    };\n    rep(y, h) {\n        rep(x, w - 1) {\n            if (board[y][x] == ' ') continue;\n            if (board[y][x] == board[y][x + 1]) uf.connect(to_id(y, x), to_id(y, x + 1));\n        }\n    }\n    rep(y, h) {\n        rep(x, w) {\n            if (uf.size(to_id(y, x)) >= k) return true;\n        }\n    }\n    return false;\n}\n\nll down_all(int h, int w, int k, vector<vector<char>> &board) {\n    UnionFind uf(h * w);\n    auto to_id = [&](int y, int x) {\n        return y * w + x;\n    };\n    rep(y, h) {\n        rep(x, w - 1) {\n            if (board[y][x] == ' ') continue;\n            if (board[y][x] == board[y][x + 1]) uf.connect(to_id(y, x), to_id(y, x + 1));\n        }\n    }\n    ll ans = 0;\n    rep(y, h) {\n        rep(x, w) {\n            if (uf.size(to_id(y, x)) >= k) {\n                int ci = board[y][x] - '0';\n                ans += ci;\n                down(h, w, board, y, x);\n            }\n        }\n    }\n    return ans;\n}\n\nll check(int h, int w, int k, vector<vector<char>> board, int fy, int fx) {\n\n//    if (fy == 3 && fx == 2) {\n//        cout << endl;\n//    }\n\n    down(h, w, board, fy, fx);\n    ll ans = 0;\n    for (int i = 0; has_set(h, w, k, board); i++) {\n        ll t = down_all(h, w, k, board);\n        ll now = (1ll << i) * t;\n        ans += now;\n    }\n//    cout << ans << endl;\n    return ans;\n}\n\nint main() {\n    int h, w, k;\n    cin >> h >> w >> k;\n    vector<vector<char>> board(h, vector<char>(w));\n    rep(y, h) rep(x, w) cin >> board[y][x];\n\n    ll ans = 0;\n    rep(y, h) rep(x, w) cmax(ans, check(h, w, k, board, y, x));\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stdio.h>\n#include<cstring>\n#include<math.h>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<queue>\nusing namespace std;\n\n#define rep(i, n) for (long long i = 0; i < (long long)(n); ++i)\nusing P = pair<long long, long long>;\n\nlong long H, W, K;\nlong long cc[30][30];\nlong long c[30][30];\nlong long ans = 0;\n\nint main() {\n  cin >> H >> W >> K;\n  rep(i, H) {\n    string s;\n    cin >> s;\n    rep(j, W) {\n      cc[i][j] = s[j] - '0';\n    }\n  }\n\n  long long temp = 0;\n\n  rep(iii, H) {\n    rep(jjj, W) {\n      // if(iii != 3 || jjj != 0) continue;\n      long long count = 1;\n      temp = 0;\n      rep(ii, H) {\n        rep(jj, W) {\n          c[ii][jj] = cc[ii][jj];\n        }\n      }\n      if(iii == 0) {\n        c[iii][jjj] = 0;\n      } else {\n        for(long long k = 1; k <= iii; k++) {\n          swap(c[0][jjj], c[k][jjj]);\n        }\n        c[0][jjj] = 0;\n      }\n\n      while(true) {\n        vector<pair<pair<long long, long long>, long long>> mem;\n        rep(i, H) {\n          rep(j, W) {\n            if(c[i][j] == 0) continue;\n            bool ff = false;\n            long long M = max(K, W - j);\n            for(long long k = M; k >= K; k--) {\n              bool f = true;\n              rep(l, k-1) {\n                if(c[i][j+l] != c[i][j+l+1]) {\n                  f = false;\n                }\n              }\n              if(f) {\n                mem.push_back({{i, j}, k});\n                temp += k * c[i][j] * count;\n                ff = true;\n              }\n              if(ff) {\n                j = j + k;\n                // cout << j << endl;\n                break;\n              }\n            }\n            if(ff) continue;\n          }\n        }\n\n        if(mem.size() == 0) break;\n\n        rep(i, mem.size()) {\n          // cout << mem[i].first.first << \" \" << mem[i].first.second << \" \" << mem[i].second << endl;\n          long long sx, sy, k;\n          sx = mem[i].first.first;\n          sy = mem[i].first.second;\n          k = mem[i].second;\n          if(sx == 0) {\n            rep(j, k) {\n              c[sx][sy+j] = 0;\n            }\n          } else {\n            for(long long h = 1; h <= sx; h++) {\n              rep(j, k) {\n                swap(c[0][sy+j], c[h][sy+j]);\n              }\n            }\n            rep(j, k) {\n              c[0][sy+j] = 0;\n            }\n          }\n\n        }\n\n        count *= 2;\n      }\n      // cout << temp << endl;\n      ans = max(ans, temp);\n    }\n  }\n\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nlong long fact[C_SIZE];\nlong long finv[C_SIZE];\nlong long inv[C_SIZE];\nlong long Comb(int a,int b){\n \tif(a<b||b<0)return 0;\n \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nvoid init_C(int n){\n\tfact[0]=finv[0]=inv[1]=1;\n\tfor(int i=2;i<n;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n}\nlong long pw(long long a,long long b){\n\tif(a<0LL)return 0;\n\tif(b<0LL)return 0;\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\ndouble ABS(double a){return max(a,-a);}\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n// ここから編集しろ\nchar in[40][40];\nint H,W,K;\nchar tmp[40][40];\nint calc(int a,int b){\n\tfor(int i=0;i<H;i++)for(int j=0;j<W;j++)tmp[i][j]=in[i][j];\n\tfor(int i=a;i>0;i--){\n\t\ttmp[i][b]=tmp[i-1][b];\n\t}\n\tint ret=0;\n\ttmp[0][b]=0;\n\tint ks=1;\n\twhile(1){\n\t\tint sum=0;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tint ren=0;\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tif(tmp[i][j]==0){\n\t\t\t\t\tif(ren>=K){\n\t\t\t\t\t\tsum+=ren*(tmp[i][j-1]-'0');\n\t\t\t\t\t\tfor(int k=1;k<=ren;k++)tmp[i][j-k]=0;\n\t\t\t\t\t}\n\t\t\t\t\tren=0;\n\t\t\t\t}\n\t\t\t\telse if(j&&tmp[i][j]!=tmp[i][j-1]){\n\t\t\t\t\tif(ren>=K){\n\t\t\t\t\t\tsum+=ren*(tmp[i][j-1]-'0');\n\t\t\t\t\t\tfor(int k=1;k<=ren;k++)tmp[i][j-k]=0;\n\t\t\t\t\t}\n\t\t\t\t\tren=1;\n\t\t\t\t}else{\n\t\t\t\t\tren++;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif(ren>=K){\n\t\t\t\tsum+=ren*(tmp[i][W-1]-'0');\n\t\t\t\tfor(int k=1;k<=ren;k++)tmp[i][W-k]=0;\n\t\t\t}\n\t\t}\n\t\tif(sum==0)break;\n\t\tret+=sum*ks;\n\t\tks*=2;\n\t\tfor(int i=0;i<W;i++){\n\t\t\tint fa=H-1;\n\t\t\tfor(int j=H-1;j>=0;j--){\n\t\t\t\tif(tmp[j][i]){\n\t\t\t\t\ttmp[fa--][i]=tmp[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(fa>=0){tmp[fa][i]=0;fa--;}\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);H=a;W=b;K=c;\n\tfor(int i=0;i<a;i++)scanf(\"%s\",in[i]);\n\tint ret=0;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\tret=max(ret,calc(i,j));\n\t}\n\tprintf(\"%d\\n\",ret);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . ___\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n              find_str Bao You\n*/\n#include <iostream>\n#include <queue>\n#include <assert.h>   \n#include <vector>\n#include <algorithm>\n#include <time.h>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <unordered_set>\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <numeric>\n#include <deque>\n#include <iomanip>\n#include <cstdlib>\n#include <climits>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define ll long long\n#define ld long double \n#define pi pair<int, int> \n#define pl pair<ll,ll>  \n#define pd pair<ld,ld> \n#define str string  \n#define mp make_pair\n#define vi vector<int> \n#define vl vector<ll> \n#define vd vector<ld> \n#define vs vector<str> \n#define vpi vector<pi> \n#define vpl vector<pl> \n#define vpd vector<pd> \n#define si set<int> \n#define FF(i,j,n) for(signed i=j;i<=n;i++)  \n#define DD(i,j,n) for(signed i=j;i>=n;i--) \n#define F(i,j,n) for(signed i=j;i<n;i++)   \n#define D(i,j,n) for(signed i=j;i>n;i--) \n#define mem(a,b) memset(a,b,sizeof(a))\n#define ndl cout << endl\n#define ull unsigned long long \n\nconst int inf = 0x3f3f3f3f;\nconst ll INF = 0x3f3f3f3f3f3f3f3fLL;\n\n\n#define sz(x) (signed)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back() \n#define fi first\n#define se second\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n#define IOS ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n\n//math\nconst int mod = 1e9 + 7;\n\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\nint pct(int x) { return __builtin_popcount(x); } \nint bit(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nint cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \n\n\n//DEBUG, compile with -DLOCAL\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n  cerr << to_string(h); if (sizeof...(t)) cerr << \", \";\n  DBG(t...); }\n#ifdef LOCAL \n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#define HERE cout << \"===GOTHERE===\" << endl\n#else\n#define dbg(...) 42\n#define HERE 42\n#endif\n\n//#define double long double\n#define int long long\n//#define int unsigned long long\n\nconst int maxn = 1e5*2+20;\n\nint n,_,q,k;\nint h,w;\n\nstr raw[40];\n\nint l,r;\n\nint org[35][35];\nint a[35][35];\nint ptr[35];\n\nvoid prep(){\n  FF(i,0,h)FF(j,0,w) a[i][j] = org[i][j];\n  FF(i,1,w) ptr[i] = h;\n}\n\nint check(){\n  FF(i,1,w){\n    int j = i;\n    while(a[ptr[i]][i] == a[ptr[j]][j]){\n      \n      //dbg(a[ptr[j]][j],i,j);\n      j++;\n    }\n    int tt = (j-i) * a[ptr[i]][i];\n    if(tt > 0 && j - i >= k){\n      l = i; r = j;\n      return tt;\n    }\n    i = j - 1;\n  }\n  return -1;\n}\n\nbool notFinished(){\n  int yes = false;\n  FF(i,1,w){\n    if(ptr[i] > 0) yes = true;\n  }\n  return yes;\n}\n\nvoid renew(){\n  FF(i,1,w) ptr[i] = h;\n  FF(i,1,w){\n    while(ptr[i] != 0 && a[ptr[i]][i] < 0) ptr[i]--;\n  }\n}\n\nvoid updateptr(){\n  FF(i,1,w){\n    if(ptr[i] > 0) ptr[i] --;\n  }\n  FF(i,1,w){\n    while(ptr[i] != 0 && a[ptr[i]][i] < 0) ptr[i]--;\n  }\n}\n\nvoid update(){\n    FF(i,1,w){\n    while(ptr[i] != 0 && a[ptr[i]][i] < 0) ptr[i]--;\n  }\n}\n\nvoid solve(){\n  FF(i,0,h)FF(j,0,w){\n    org[i][j] = -1;\n  }\n  FF(i,1,h){\n    cin >> raw[i];\n  }\n\n\n\n  FF(i,1,h)FF(j,1,w){\n    org[i][j] = raw[i][j-1] - '0';\n  }\n\n  int ans = -1;\n\n  FF(q,1,w){\n    FF(p,1,h){\n    prep();\n    int pw = 0;\n    int anst = 0;\n    a[p][q] = -1;\n\n    bool deleted = true;\n    //cout << \"triail\" << endl;\n    while(deleted){\n      deleted = false;\n      renew();\n      //cout << \"renewed\" << endl;\n      while(notFinished()){\n        // FF(i,1,w){\n        //   dbg(ptr[i]);\n        // }\n\n        int score = check();\n        //dbg(score);\n        if(score == -1){\n          updateptr();\n        }else{\n          deleted = true;\n          anst += (powl(2,pw)*score);\n          F(i,l,r){\n            a[ptr[i]][i] = -1;\n          }\n          updateptr();\n        }\n      }\n      pw++;\n    }\n    ans = max(ans, anst);\n    }\n  }\n  cout << ans << endl;\n\n}\n\nsigned main(){\n  //clock_t t1 = clock();  \n\tIOS\n  cin >> h >> w >> k;\n\tsolve();\n  \n  //cout << \"THE ALGORITHM TOOK: \" << (clock() - t1) * 1.0 / CLOCKS_PER_SEC * 1000 << \"ms\"<< endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nconst int nax=37;\n\nint n, m, k;\n\nchar wcz[nax];\n\nstruct plan\n{\n\tvector <int> wek[nax];\n\tint kogo[nax][nax];\n\tplan()\n\t{\n\t\tczys();\n\t}\n\tvoid czys()\n\t{\n\t\tfor (int i=0; i<nax; i++)\n\t\t\tfor (int j=0; j<nax; j++)\n\t\t\t\tkogo[i][j]=0;\n\t}\n\tll oznacz()\n\t{\n\t\tll ret=0;\n\t\tfor (int i=0; i<nax; i++)\n\t\t{\n\t\t\tint ost=-1;\n\t\t\tint ile=0;\n\t\t\tfor (int j=0; j<nax; j++)\n\t\t\t{\n\t\t\t\tint x=-1;\n\t\t\t\tif ((int)wek[j].size()>i)\n\t\t\t\t\tx=wek[j][i];\n\t\t\t\tif (x==-1)\n\t\t\t\t{\n\t\t\t\t\tost=-1;\n\t\t\t\t\tile=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (x!=ost)\n\t\t\t\t\t{\n\t\t\t\t\t\tile=1;\n\t\t\t\t\t\tost=x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tile++;\n\t\t\t\t\t\tif (ile>=k)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int l=0; l<k; l++)\n\t\t\t\t\t\t\t\tkogo[j-l][i]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i=0; i<nax; i++)\n\t\t\tfor (int j=0; j<(int)wek[i].size(); j++)\n\t\t\t\tret+=kogo[i][j]*wek[i][j];\n\t\treturn ret;\n\t}\n\tvoid puszuj()\n\t{\n\t\tfor (int i=0; i<nax; i++)\n\t\t{\n\t\t\tvector <int> wez;\n\t\t\tfor (int j=0; j<(int)wek[i].size(); j++)\n\t\t\t\tif (!kogo[i][j])\n\t\t\t\t\twez.push_back(wek[i][j]);\n\t\t\twek[i]=wez;\n\t\t}\n\t\t//~ int g=0;\n\t\t//~ for (int i=0; i<nax; i++)\n\t\t//~ {\n\t\t\t//~ if (!wek[i].empty())\n\t\t\t//~ {\n\t\t\t\t//~ wek[g]=wek[i];\n\t\t\t\t//~ if (i!=g)\n\t\t\t\t\t//~ wek[i].clear();\n\t\t\t\t//~ g++;\n\t\t\t//~ }\n\t\t//~ }\n\t\tczys();\n\t}\n};\n\nll wyn;\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tplan start;\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tscanf(\"%s\", wcz);\n\t\tfor (int j=0; j<m; j++)\n\t\t\tstart.wek[j].push_back(wcz[j]-'0');\n\t}\n\tfor (int i=0; i<m; i++)\n\t\treverse(start.wek[i].begin(), start.wek[i].end());\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tfor (int j=0; j<m; j++)\n\t\t{\n\t\t\tplan wez=start;\n\t\t\twez.kogo[j][i]=1;\n\t\t\twez.puszuj();\n\t\t\tll ter=0;\n\t\t\tfor (int h=0; 1; h++)\n\t\t\t{\n\t\t\t\tll x=wez.oznacz();\n\t\t\t\tif (!x)\n\t\t\t\t\tbreak;\n\t\t\t\tter+=(x<<h);\n\t\t\t\twez.puszuj();\n\t\t\t}\n\t\t\twyn=max(wyn, ter);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint C[35][35];\nint main() {\n    int H, W, K; cin >> H >> W >> K;\n    for(int i=0; i<H; ++i){\n        string S;\n        cin >> S;\n        for(int j=0; j<W; ++j){\n            C[i][j]=(S[j]-'0');\n        }\n    }\n    int ans=0;\n    for(int i=0; i<H*W; ++i){\n        int ban[35][35], now=0, mul=1;\n        for(int p=0; p<35; ++p) for(int q=0; q<35; ++q) ban[p][q]=C[p][q];\n        ban[i/W][i%W]=0;\n        bool flag=true;\n        while(flag){\n            int sum=0;\n            for(int j=0; j<W; ++j){\n                int cnt=H-1;\n                for(int k=H-1; k>=0; --k){\n                    if(ban[k][j]>0){\n                        ban[cnt][j]=ban[k][j];\n                        if(cnt!=k) ban[k][j]=0;\n                        --cnt;\n                    }\n                }\n            }\n            flag=false;\n            for(int j=0; j<H; ++j){\n                for(int k=0; k<W; ++k){\n                    if(ban[j][k]>0){\n                        int ser=k;\n                        while(ban[j][ser]==ban[j][k]) ++ser;\n                        if(ser-k>=K){\n                            sum += ban[j][k]*(ser-k);\n                            flag=true;\n                            for(int v=k; v<ser; ++v) ban[j][v]=0;\n                        }\n                    }\n                }\n            }\n            now += sum*mul;\n            mul *= 2;\n        }\n        ans=max(ans, now);\n    }\n    cout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ temp.cpp\n// C++ includes used for precompiling -*- C++ -*-\n\n// Copyright (C) 2003-2013 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file stdc++.h\n *  This is an implementation file for a precompiled header.\n */\n\n// 17.4.1.2 Headers\n\n// C\n//#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n/*\n//#if __cplusplus >= 201103L\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n*/\n\n// C++\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n/*\n//#if __cplusplus >= 201103L\n#include <array>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n*/\nusing namespace std;\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n  \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\n\n#define INF INT_MAX/3\n#define MAX_N 1000\n int h,w,k;\n vector<string> vec;\n vector<string> crnt;\n\n int search(int itr){\n  int ret=0;\n  bool changed = false;\n  rep(i,h){\n    rep(j,w-1){\n      //0ということはもうそこには数字が入っていないということだからcontinueしていい\n      if(crnt[i][j]==0) continue;\n      int d=0;\n      //横の値が等しいだけ加算していく\n      while(j+d<w&&crnt[i][j]==crnt[i][j+d]) d++;\n      if(d>=k){\n        //もし規定の長さを超えたなら\n        //加算して消した所に0を代入していく\n        //スコアはi回目で消滅した数字の値の和なのでbitをずらすことで実現している\n        ret += (1<<itr) * (crnt[i][j]-'0')*d;\n        rep(dd,d) crnt[i][j+dd] = 0;\n        changed = true;\n      }\n      //dが増えていたらそのぶんずらしてあげてそうでなかったら-1してインクリメント\n      //される時にその点から始まるようにする\n    j += d-1;\n  }\n }\n //変化が一つもない場合はもう返す\n if(!changed) return ret;\n\n //-1をつめる\n rep(j,w){\n  int s=h-1;\n  for(int hh=h-1;hh>=0;hh--){\n    while(s>=0&crnt[s][j]==0) s--;\n    if(s<0) crnt[hh][j]=0;//もう入っていないということ\n    else crnt[hh][j] = crnt[s][j];\n    s--;\n    }\n }\n return ret + search(itr+1);\n}\n\n int main(){\n  cin>>h>>w>>k;\n  //resizeとは\n  //指定した数だけ実際に何らかの値で埋める。\n  ///\n  vec.resize(h);\n  rep(i,h) cin>>vec[i];\n\n  int res=0;\n  rep(i,h) rep(j,w){\n    //ここで作り直したものを入れ直している\n    crnt = vector<string>(vec);\n    for(int ii=i;ii>0;ii--) crnt[ii][j] = crnt[ii-1][j];\n    crnt[0][j]=0;\n    //ここで消す作業をしている\n    res = max(res,search(0));\n  }\n  cout<<res<<endl;\n  return 0;\n }\n // http://s8pc-3.contest.atcoder.jp/submissions/987968"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst ll MOD = 1'000'000'007;\nconst ld PI = acos(-1);  \nconst ld EPS = 0.0000000001;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define REP(i, n) for(ll i=0; i<(ll)(n); i++)\n#define REPD(i, n) for(ll i=n-1; 0<=i; i--)\n#define FOR(i, a, b) for(ll i=a; i<(ll)(b); i++)\n#define FORD(i, a, b) for(ll i=a; (ll)(b)<=i; i--)\n#define ALL(x) x.begin(), x.end()\n#define MAX(x) *max_element(ALL(x))\n#define MIN(x) *min_element(ALL(x))\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint main(){\n    ll h, w, k;  cin >> h >> w >> k;\n    vector<vector<ll>> ori(h, vector<ll>(w));\n    REP(i, h) REP(j, w){\n        char c; cin >> c;\n        ori[i][j] = c-'0';\n    }\n    \n    ll res=0;\n    REP(x, h){\n        REP(y, w){\n            ll tmp=0, times=0;\n            bool flag=true;\n            vector<vector<ll>> g = ori;\n            g[x][y] = 0;\n            for(int i=x; 0<i; i--){\n                swap(g[i][y], g[i-1][y]);\n            }\n            // REP(i, h){\n            //     REP(j, w) cout << g[i][j] << ' ';\n            //     cout << endl;\n            // }\n            \n            while(flag){\n                flag = false;\n                REP(i, h){\n                    ll bef=g[i][0], cnt=0;\n                    \n                    REP(j, w){\n                        if(g[i][j]==bef && 0<bef) cnt += 1;\n                        else{\n                            if(k<=cnt){\n                                flag = true;\n                                tmp += cnt*(1<<times)*bef;\n                                for(int p=1; p<=cnt; p++)   g[i][j-p] = 0;\n                            }\n                            cnt = 1;\n                        }\n                        bef = g[i][j];\n                    }\n                    if(k<=cnt){\n                        tmp += (1<<times)*cnt*bef;\n                        for(int p=1; p<=cnt; p++)   g[i][w-p] = 0;\n                        flag = true;\n                    }\n                }\n                REPD(i, h){\n                    REP(j, w){\n                        if(!g[i][j]){\n                            REPD(k, i){\n                                if(!g[k][j]) continue;\n                                swap(g[k][j], g[i][j]); break;\n                            }\n                        }\n                    }\n                }\n                \n                times += 1;\n                //cout << tmp << ' ';\n            }\n            res = max(res, tmp);\n            //cout << x <<':' << y << ' ' << tmp << endl << endl;\n        }\n    }\n    \n    cout << res << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <iomanip>\n#include <climits>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef pair<ll, ll> P;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define revrep(i, n) for(int i = (n)-1; i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\n#define chmin(x, y) x = min(x, y);\n#define chmax(x, y) x = max(x, y);\n\n//const ll INFL = LLONG_MAX;//10^18 = 2^60\nconst ll INFL = 1LL<<60;\n//const int INF = INT_MAX;\nconst ll INF = 1 << 30;//10^9\nll MOD = 1000000007;\n//ll MOD = 998244353;\n\nvector<ll> dy = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nvector<ll> dx = {1, 0, -1, 0, 1, -1, 1, -1, 0};\n\nvoid pres(double A){printf(\"%.9lf\\n\", A);}\nvoid BinarySay(ll x, ll y = 60){rep(i, y) cout << (x>>(y-1-i) & 1); cout << endl;}\nll cnt_bit(ll x){return __builtin_popcountll(x);}\n\nll pow_long(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2) res *= x;\n    x *= x; k /= 2;\n  }\n  return res;\n}\n\nll pow_mod(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2){\n      res *= x; res %= MOD;\n    }\n    x *= x; x %= MOD;\n    k /= 2;\n  }\n  return res;\n}\n\nll inverse(ll x){return pow_mod(x, MOD - 2);};\n\nll gcd(ll a, ll b){\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\nll lcm(ll x, ll y){\n  ll res = x / gcd(x, y);\n  res *= y;\n  return res;\n};\n\n\n//コンビネーション\nconst int MAXcomb = 2000010;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\n//facはn!,finvは1/n!\n//invは逆元\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAXcomb; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nll comb(int n, int k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    return fac[n] * finv[k] % MOD * finv[n-k] % MOD;\n}\n\nconst int MAXkai = 200010;\nll kai_memo[MAXkai];\nll kai(ll N){\n  if(kai_memo[N] != 0) return kai_memo[N];\n  if(N <= 1) return 1;\n  return kai_memo[N] = N * kai(N-1) % MOD;\n}\n\nll disit(ll s, ll base = 10){\n  ll res = 0;\n  while(s){\n    res++;\n    s /= base;\n  }\n  return res;\n}\n\n\nint H, W, K;\nint c[31][31];\nint tmp[31][31];\n\nint add(){\n  for(int j = 0; j < W; j++){\n    for(int i = H - 1; i >= 0; i--){\n      while(tmp[i][j] == 0){\n        bool update = 0;\n        for(int k = i; k >= 1; k--){\n          if(tmp[k][j] != tmp[k-1][j]) update = 1;\n          tmp[k][j] = tmp[k-1][j];\n        }\n        tmp[0][j] = 0;\n        if(!update) break;\n      }\n    }\n  }\n\n  int res = 0;\n  for(int i = 0; i < H; i++){\n    int num = -1, len = 0;\n    for(int j = 0; j < W + 1; j++){\n      if(tmp[i][j] != num){\n        if(len >= K && num >= 1){\n          for(int k = j - len; k < j; k++){\n            res += tmp[i][k];\n            tmp[i][k] = 0;\n          }\n        }\n        num = tmp[i][j];\n        len = 1;\n      }else{\n        len++;\n      }\n    }\n  }\n  return res;\n}\n\nint sub(int ei, int ej){\n  rep(i, H)rep(j, W) tmp[i][j] = c[i][j];\n  tmp[ei][ej] = 0;\n  int ans = 0;\n  for(int i = 0; i <= 100; i++){\n    int res = add();\n    if(res == 0) break;\n    ans += (1<<i) * res;\n  }\n  return ans;\n}\n\nvoid solve(){\n  cin >> H >> W >> K;\n  rep(i, H){\n    string S;\n    cin >> S;\n    rep(j, W) c[i][j] = S[j] - '0';\n  }\n  int ans = 0;\n  rep(i, H)rep(j, W){\n    ans = max(ans, sub(i, j));\n  }\n  cout << ans << endl;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n    Problem 93\n    https://atcoder.jp/contests/s8pc-3/tasks/s8pc_3_b\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n/* typedef */\ntypedef long long ll;\ntypedef pair<int, int> pii;\n/* constant */\nconst int INF = 1 << 30;\nconst ll LINF = 1LL << 50;\nconst int NIL = -1;\nconst int MAX = 35;\nconst int mod = 1000000007;\nconst double pi = 3.141592653589;\n/* global variables */\nint H, W, K;\nvector<vector<int>> pazzle(MAX, vector<int>(MAX));\nvector<vector<int>> original(MAX, vector<int>(MAX));\n/* function */\nvoid input() {\n    cin >> H >> W >> K;\n    for (int i = 0; i < H; i++) {\n        string S; cin >> S;\n        for (int j = 0; j < W; j++) {\n            original[i][j] = S[j] - '0';\n        }\n    }\n}\nvoid init() { pazzle = original; }\nint deleteStone() {\n    int ret = 0;\n    for (int h = 0; h < H; h++) {\n        for (int l = 0; l < W;) {\n            int r = l + 1;\n            for (; r < W && pazzle[h][l] == pazzle[h][r]; r++);\n            if (r - l >= K) {\n                ret += pazzle[h][l] * (r - l);\n                for (; l < r; l++) pazzle[h][l] = 0;\n            }\n            l = r;\n        }\n    }\n    return ret;\n}\nvoid moveStone() {\n    for (int w = 0; w < W; w++) {\n        vector<int> tmp(H, 0);\n        int len = 0;\n        for (int h = H-1; h >= 0; h--)\n            if (pazzle[h][w] != 0) tmp[len++] = pazzle[h][w];\n        for (int h = H-1; h >= 0; h--)\n            pazzle[h][w] = tmp[H-1-h];\n    }\n}\nint playGame(int h, int w) {\n    // delete one block and move\n    pazzle[h][w] = 0;\n    moveStone();\n    int totalScore = 0;\n    for (int i = 1; ; i*=2 ) {\n        int score = deleteStone();\n        if (score == 0) break;\n        totalScore += score * i;\n        moveStone();\n    }\n    return totalScore;\n}\nvoid solve() {\n    input();\n    int maxScore = 0;\n    for (int h = 0; h < H; h++) {\n        for (int w = 0; w < W; w++) {\n            init();\n            maxScore = max(maxScore, playGame(h, w));\n        }\n    }\n    cout << maxScore << '\\n';\n}\n/* main */\nint main(){\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long otosu(vector<deque<int>> &c,int h,int k) {\n\tif (c.size() == 0) {\n\t\treturn 0;\n\t}\n\tint point=0;\n\tfor (int i = 0; i < h; i++) {\n\t\tint j = 0;\n\t\twhile (j < c.size()-1) {\n\t\t\tint rensa = 1;\n\t\t\tif (c[j].at(i)!=0 && c[j].at(i) == c[j+1].at(i)) {\n\n\t\t\t\trensa = 2;\n\n\t\t\t\twhile (j + rensa < c.size()) {\n\t\t\t\t\tif (c[j + rensa].at(i) == c[j].at(i)) {\n\t\t\t\t\t\trensa++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (rensa >= k) {\n\t\t\t\t\tfor (int m = 0; m < rensa; m++) {\n\t\t\t\t\t\tpoint += c[j + m].at(i);\n\t\t\t\t\t\tc[j + m].at(i) = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tj=j+rensa;\n\t\t}\n\t\t\n\t}\n\n\tfor (int j = 0; j < c.size(); j++) {\n\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\tif (c[j].at(i) == -1) {\n\t\t\t\tc[j].erase(c[j].begin() + i);\n\t\t\t\tc[j].push_back(0);\n\t\t\t}\n\t\t}\n\t}\n\n\t//for (int j = c.size() - 1; j >= 0; j--) {\n\t//\tif (c[j].front() == 0) {\n\t//\t\tc.erase(c.begin() + j);\n\t//\t}\n\t//}\n\n\treturn point;\n}\n\nint main() {\n\n\tint h, w, k;\n\tcin >> h >> w >> k;\n\n\tvector<deque<int>> c(w, deque<int>());\n\tvector<deque<int>> corg(w, deque<int>());\n\n\tint summ=0;\n\tlong long in1;\n\tfor (int i =0; i <h; i++) {\n\t\tcin >> in1;\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tc[j].push_front(in1%10);\n\t\t\tin1 /= 10;\n\t\t\tsumm += c[j].front();\n\t\t}\n\t}\n\n\tif (k == 0 || k == 1) {\n\t\tcout << summ << endl;\n\t\treturn 0;\n\t}\n\n\tcorg = c;\n\tlong long score=0;\n\tfor (int j = 0; j < h; j++) {\n\t\tfor (int i = 0; i < w; i++) {\n\n\t\t\tc = corg;\n\n\t\t\tc[i].erase(c[i].begin() + j);\n\t\t\tc[i].push_back(0);\n\n\t\t\tlong long scoret = 0;\n\t\t\tint counter = 0;\n\t\t\tlong long point;\n\t\t\tdo {\n\t\t\t\tpoint = 0;\n\t\t\t\tpoint = otosu(c, h, k);\n\t\t\t\tscoret += point * (long long)pow(2, counter);\n\t\t\t\tcounter++;\n\t\t\t} while (point != 0);\n\t\t\tscore = max(score, scoret);\n\t\t}\n\t}\n\tcout << score << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nusing ll=long long;\n\nll power(ll n,ll m)\n{\n    ll ans=1;\n    for (ll r=0;m>>r>0;r++)\n    {\n        if ((m>>r)&1) ans=ans*n;\n        n=n*n;\n    }\n    return ans;\n}\n\nint main()\n{\n    ll h,w,k;cin >> h >> w >>k;\n    string S;\n    ll now=0;\n    vector<vector<ll> >board(h,vector<ll> (w,0));\n    for (ll i=0;i<h;i++)\n    {\n        cin >> S;\n        for (ll j=0;j<w;j++)\n        {\n            board[i][j]=S[j]-'0';\n        }\n    }\n    for (int row=0;row<h;row++)\n    {\n        for (int column=0;column<w;column++)\n        {\n            vector<vector<ll> >board2=board;\n            board2[row][column]=0;\n            for (int k=row;k>0;k--)\n            {\n                swap(board2[k][column],board2[k-1][column]);\n            }\n\n    bool can=true;\n    ll times=0;\n    ll ans=0;\n    while (can)\n    {\n        can=false;\n        for (ll i=0;i<h;i++)\n        {\n            ll key=board2[i][0];\n            ll cnt=1;\n            for (ll j=1;j<w;j++)\n            {\n                if (key==board2[i][j] && key!=0)\n                {\n                    cnt++;\n                }\n                else\n                {\n                    if (cnt>=k)\n                    {\n                        can=true;\n                        ans+=cnt*power(2,times)*board2[i][j-1];\n                        for (int m=1;m<cnt+1;m++)\n                        {\n                            board2[i][j-m]=0;\n                        }\n                    }\n                    key=board2[i][j];\n                    cnt=1;\n                }\n            }\n            if (cnt>=k)\n            {\n                can=true;\n                ans+=cnt*power(2,times)*board2[i][w-1];\n                for (int m=1;m<cnt+1;m++)\n                {\n                    board2[i][w-m]=0;\n                }\n            }\n        }\n        times++;\n        if (can)\n        {\n            for (int j=0;j<w;j++)\n            {\n                for (int i=h-1;i>=0;i--)\n                {\n                    if (board2[i][j]==0)\n                    {\n                        int zero=i;\n                        while (zero>=0 && board2[zero][j]==0)\n                        {\n                            zero--;\n                            if (zero==-1) break;\n                        }\n                        if (zero!=-1)\n                        {\n                            board2[i][j]=board2[zero][j];\n                            board2[zero][j]=0;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    now=max(now,ans);\n        }\n    }\n    cout << now << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing VI = vector<int>;\nusing VL = vector<ll>;\nusing VS = vector<string>;\nusing VB = vector<bool>;\nusing VVB = vector<vector<bool>>;\nusing VVI = vector<VI>;\nusing VVL = vector<VL>;\nusing PII = std::pair<int, int>;\nusing VPII = std::vector<std::pair<int, int>>;\nusing PLL = std::pair<ll, ll>;\nusing VPLL = std::vector<std::pair<ll, ll>>;\nusing TI3 = std::tuple<int, int, int>;\nusing TI4 = std::tuple<int, int, int, int>;\nusing TL3 = std::tuple<ll, ll, ll>;\nusing TL4 = std::tuple<ll, ll, ll, ll>;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define repr(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep2(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define rep3(i, s, n, d) for (int i = (s); i < (int)(n); i += (d))\n#define allpt(v) (v).begin(), (v).end()\n#define allpt_c(v) (v).cbegin(), (v).cend()\n#define allpt_r(v) (v).rbegin(), (v).rend()\n#define allpt_cr(v) (v).crbegin(), (v).crend()\n\nconst int mod1 = 1e9 + 7, mod2 = 998244353, mod3 = 1e9 + 9;\nconst int mod = mod1;\nconst ll inf = 1e18;\n\nconst string wsp = \" \";\nconst string tb = \"\\t\";\nconst string rt = \"\\n\";\n\ntemplate <typename T>\nvoid show1dvec(const vector<T> &v)\n{\n    if (v.size() == 0)\n        return;\n    int n = v.size() - 1;\n    rep(i, n) cout << v[i] << wsp;\n    cout << v[n] << rt;\n\n    return;\n}\n\ntemplate <typename T>\nvoid show2dvec(const vector<vector<T>> &v)\n{\n    int n = v.size();\n    rep(i, n) show1dvec(v[i]);\n}\n\ntemplate <typename T, typename S>\nvoid show1dpair(const vector<pair<T, S>> &v)\n{\n    int n = v.size();\n    rep(i, n) cout << v[i].first << wsp << v[i].second << rt;\n    return;\n}\n\ntemplate <typename T, typename S>\nvoid pairzip(const vector<pair<T, S>> &v, vector<T> &t, vector<T> &s)\n{\n    int n = v.size();\n    rep(i, n)\n    {\n        t.push_back(v[i].first);\n        s.push_back(v[i].second);\n    }\n    return;\n}\n\ntemplate <typename T>\nvoid maxvec(vector<T> &v)\n{\n    T s = v[0];\n    int n = v.size();\n    rep(i, n - 1)\n    {\n        if (s > v[i + 1])\n        {\n            v[i + 1] = s;\n        }\n        s = v[i + 1];\n    }\n}\n\ntemplate <typename T, typename S>\nbool myfind(T t, S s)\n{\n    return find(t.cbegin(), t.cend(), s) != t.cend();\n}\n\nbool check(int y, int x, int h, int w)\n{\n    return 0 <= y && y < h && 0 <= x && x < w;\n}\n\ntemplate <typename T>\nvector<T> cumsum(const vector<T> &v)\n{\n    T s = 0;\n    vector<T> ret;\n\n    rep(i, v.size())\n    {\n        s += v[i];\n        s %= mod;\n        ret.emplace_back(s);\n    }\n    return ret;\n}\n\nbool iskadomatsu(int a, int b, int c)\n{\n    return (a != b && b != c && c != a) && ((a > b && b < c) || (a < b && b > c));\n}\n\nVS split(string s, char c)\n{\n    VS ret;\n    string part;\n    s += c;\n    rep(i, s.length())\n    {\n        if (s[i] == c)\n        {\n            ret.emplace_back(part);\n            part = \"\";\n        }\n        else if (s[i] != c)\n        {\n            part += s[i];\n        }\n    }\n    return ret;\n}\n\ntemplate <typename T, typename S, typename R>\nll pow_mod(T p, S q, R mod = 1ll)\n{\n    ll ret = 1, r = p;\n    while (q)\n    {\n        if (q % 2)\n            ret *= r, ret %= mod;\n        r = (r * r) % mod, q /= 2;\n    }\n    return ret % mod;\n}\n\ntemplate <typename T, typename S>\nll pow_no_mod(T p, S q)\n{\n    ll ret = 1, r = p;\n    while (q)\n    {\n        if (q % 2)\n            ret *= r;\n        r = (r * r), q /= 2;\n    }\n    return ret;\n}\n\nvoid make_frac_tables(VL &frac_list, VL &frac_inv_list)\n{\n    rep(i, frac_list.size() - 1)\n    {\n        frac_list[i + 1] *= frac_list[i] * (i + 1);\n        frac_list[i + 1] %= mod;\n        frac_inv_list[i + 1] *= frac_inv_list[i] * pow_mod(i + 1, mod - 2, mod);\n        frac_inv_list[i + 1] %= mod;\n    }\n}\n\nll comb(int a, int b, const VL &frac_list, const VL &frac_inv_list)\n{\n    if (a < b)\n        return 0;\n    if (b < 0)\n        return 0;\n    ll ret = frac_list[a];\n    ret *= frac_inv_list[b];\n    ret %= mod;\n    ret *= frac_inv_list[a - b];\n    ret %= mod;\n    return ret;\n}\n\nvoid fall(VVI &field, int h, int w)\n{\n    int k;\n    rep(j, w)\n    {\n        k = 0;\n        for (int i = h; i >= 1; i--)\n        {\n            while (i - k > 0 && !field[i - k][j])\n            {\n                k++;\n            }\n            if (i <= k)\n                break;\n            swap(field[i][j], field[i - k][j]);\n        }\n    }\n}\n\nint getpoint(VVI &field, int h, int w, int k, int c)\n{\n    int l, r, score = 0;\n    VPII vanish;\n    rep2(i, 1, h + 1)\n    {\n        vanish.clear();\n        l = 0, r = 1;\n        rep2(j, 1, w + 1)\n        {\n            if (field[i][l] == field[i][j])\n            {\n                r++;\n            }\n            else\n            {\n                if (r - l >= k)\n                    vanish.emplace_back((PII){l, r});\n                l = j;\n                r = l + 1;\n            }\n        }\n        for (auto [l, r] : vanish)\n        {\n            score += (r - l) * field[i][l] * pow(2, c);\n            rep2(j, l, r) field[i][j] = 0;\n        }\n    }\n    return score;\n}\n\nint one_game(VVI field, int y, int x, int h, int w, int k)\n{\n    int totalscore = 0, one_game_score = 1, counter = 0;\n    field[y + 1][x] = 0;\n    while (one_game_score)\n    {\n        fall(field, h, w);\n        one_game_score = getpoint(field, h, w, k, counter);\n        totalscore += one_game_score;\n        counter++;\n    }\n    return totalscore;\n}\n\n\n\nint main()\n{\n\n    // cin.tie(0);\n    // ios::sync_with_stdio(false);\n\n#ifdef DEBUG\n    cout << \"DEBUG MODE\" << endl;\n    ifstream in(\"input.txt\"); //for debug\n    cin.rdbuf(in.rdbuf());    //for debug\n#endif\n\n    int h, w, k, ans{0};\n    cin >> h >> w >> k;\n    string s;\n    VVI field(h + 1, VI(w + 1, 0));\n    rep(i, h)\n    {\n        cin >> s;\n        rep(j, w)\n        {\n            field[i + 1][j] = s[j] - '0';\n        }\n    }\n\n    rep(i, h) rep(j, w)\n        ans = max(ans, one_game(field, i, j, h, w, k));\n    cout << ans << rt;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string.h>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n#define maxn 33\nint a[maxn][maxn];\nint b[maxn][maxn];\nlong long ans = 0;\nlong long maxx = 0;\nvoid init(int h, int w)\n{\n\tfor (int i = 1; i <= h; i++)\n\t{\n\t\tfor (int j = 1; j <= w; j++)\n\t\t\ta[i][j] = b[i][j];\n\t}\n}\nvoid ref(int h, int w)\n{\n\tint y[maxn];\n\tfor (int i = 1; i <= w; i++)\n\t{\n\t\tmemset(y, 0, sizeof(y));\n\t\tint x = 0;\n\t\tfor (int j = h; j >= 1; j--)\n\t\t{\n\t\t\tif (a[j][i] != -1)\n\t\t\t{\n\t\t\t\ty[x++] = a[j][i];\n\t\t\t\ta[j][i] = -1;\n\t\t\t}\n\t\t}\n\t\twhile (x)\n\t\t{\n\t\t\ta[h - x + 1][i] = y[x - 1];\n\t\t\tx--;\n\t\t}\n\t}\n}\nbool check(int h, int w, int k, int l)\n{\n\tint flag = 0;\n\tfor (int i = 1; i <= h; i++)\n\t{\n\t\tint x = 1;\n\t\tfor (int j = 2; j <= w; j++)\n\t\t{\n\t\t\tif (a[i][j] == a[i][j - 1] && a[i][j] != -1)\n\t\t\t{\n\t\t\t\tx++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (x >= k)\n\t\t\t\t{\n\t\t\t\t\tans += pow(2, l)*a[i][j - 1] * x; \n\t\t\t\t\tfor (int m = 1; m <= x; m++)\n\t\t\t\t\t\ta[i][j-m] = -1;\n\t\t\t\t\tflag = 1;\n\t\t\t\t}\n\t\t\t\tx = 1;\n\t\t\t}\n\t\t}\n\t\tif (a[i][w] == a[i][w - 1] && a[i][w] != -1 && x >= k)\n\t\t{\n\t\t\tans += pow(2, l)*a[i][w] * x;\n\t\t\tfor (int m = 0; m < x; m++)\n\t\t\t\ta[i][w - m] = -1;\n\t\t\tflag = 1;\n\t\t\tx = 1;\n\t\t}\n\t}\n\t\n\treturn flag;\n}\nint main()\n{\n\tint h, w, k;\n\tcin >> h >> w >> k;\n\tchar s[maxn];\n\tfor (int i = 1; i <= h; i++)\n\t{\n\t\tscanf(\"%s\", s);\n\t\tfor (int j = 1; j <= w; j++)\n\t\t\tb[i][j] = s[j - 1] - '0';\n\t}\n\tfor (int i = 1; i <= h; i++)\n\t{\n\t\tfor (int j = 1; j <= w; j++)\n\t\t{\n\t\t\tans = 0;\n\t\t\tinit(h, w);\n\t\t\ta[i][j] = -1;\t\t\n\t\t\tref(h, w);\t\n\t\t\tint l = 0;\n\t\t\twhile (check(h, w, k, l))\n\t\t\t{\n\t\t\t\tref(h, w);\t\t\t\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tif (ans > maxx)\n\t\t\t\tmaxx = ans;\n\t\t}\n\t}\n\tcout << maxx << endl;\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int HWmax = 30;\nint H,W,K;\nchar C[HWmax][HWmax+1];\nchar d[HWmax][HWmax+1];\n\nvoid p(){\n\tfor(int i=0; i<H; i++){\n\t\tcout << d[i] << endl;\n\t}\n\tcout << endl;\n}\n\nll removable(){\n\tll ret = 0;\n\tchar x;\n\tint k;\n\tfor(int i=0; i<H; i++){\n\t\tx = isdigit(d[i][0]) ? d[i][0] : '+';\n\t\tk = 1;\n\t\tfor(int j=1; j<W; j++){\n\t\t\tif(d[i][j] == x) k++;\n\t\t\telse{\n\t\t\t\tif(k >= K){\n\t\t\t\t\tret += (x-'0')*k;\n\t\t\t\t\t//cout << i << \" \" << j << \" \" << k << \" \" << x << endl;\n\t\t\t\t\tfor(int l=j-k; l<j; l++) d[i][l] = '-';\n\t\t\t\t}\n\t\t\t\tk = 1;\n\t\t\t\tx = isdigit(d[i][j]) ? d[i][j] : '+';\n\t\t\t}\n\t\t}\n\t\tif(k >= K){\n\t\t\tret += (x-'0')*k;\n\t\t\t//cout << i << \" \" << W << \" \" << k << \" \" << x << endl;\n\t\t\tfor(int l=W-k; l<W; l++) d[i][l] = '-';\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid remove(){\n\tfor(int i=0; i<H; i++){\n\t\tfor(int j=0; j<W; j++){\n\t\t\tif(d[i][j]=='-'){\n\t\t\t\tfor(int k=i; k>0; k--){\n\t\t\t\t\td[k][j] = d[k-1][j];\n\t\t\t\t}\n\t\t\t\td[0][j] = ' ';\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\tcin >> H >> W >> K;\n\tfor(int i=0; i<H; i++){\n\t\t\tcin >> C[i];\n\t}\n\n\tll ans = 0;\n\tfor(int i=0; i<H; i++){\n\t\tfor(int j=0; j<W; j++){\n\t\t\tmemcpy(d,C,sizeof(C));\n\t\t\td[i][j] = '-';\n\t\t\tremove();\n\t\t\tint k=0;\n\t\t\tll s=0,t=0;\n\t\t\twhile((s = removable()) > 0){\n\t\t\t\t//cout << k << \" \" << s << endl;\n\t\t\t\tt += s*(1<<k++);\n\t\t\t\tremove();\n\t\t\t}\n\t\t\tans = max(ans, t);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include<iostream>\n#include<functional>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<iomanip>\n#include<set>\n#include<map>\n#include<utility>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\n#define LL long long\nconst int dx[4] = { 1,0,-1,0 };\nconst int dy[4] = { 0,1,0,-1 };\nbool IA(int x, int y, int H, int W) { return (0<=x && x<=H) && (0<=y && y<=W); }\n\n\n\nint main(){\n\tcout<<0<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) x.begin(),x.end()\n#define ln '\\n'\nconst long long MOD = 1000000007LL;\n//const long long MOD = 998244353LL;\ntypedef long long ll;\ntypedef unsigned long long ull; \ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true;} return false; }\n///////////////////////////////////////////////////////////////////////////////////////////////////\nll board[35][35];\nll moto[35][35];\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int H,W,K; cin >> H >> W >> K;\n    vector<string> S(H);\n    rep(i,H) cin >> S[i];\n\n    rep(i,H) rep(j,W) moto[i][j] = S[i][j] - '0';\n\n    ll ans = 0;\n    rep(z,H) {\n        rep(w,W) {\n            rep(i,H) rep(j,W) board[i][j] = moto[i][j];\n            for (int i = z; i > 0; --i) board[i][w] = board[i-1][w];\n            board[0][w] = 0;\n\n            ll val = 0;\n            ll b = 1;\n            while (true) {\n                bool ok = false;\n                rep(i,H) {\n                    for (int j = W; j >= K; --j) {\n                        rep(k,W-j+1) {\n                            if (!board[i][k]) continue;\n                            bool ok10 = true;\n                            rep(l,j) {\n                                if (board[i][k] != board[i][k+l]) {\n                                    ok10 = false;\n                                    break;\n                                }\n                            }\n                            if (!ok10) continue;\n                            ok = true;\n                            val += board[i][k]*j*b;\n                            rep(l,j) {\n                                board[i][k+l] = 0;\n                            }\n                        }\n                    } \n                }\n\n                if (!ok) break;\n                rep(j,W) {\n                    for (int i = H-1; i >= 0; --i) {\n                        if (board[i][j]) continue;\n                        int k = i-1;\n                        while (k >= 0 && !board[k][j]) --k;\n                        if (k==-1) break;\n                        board[i][j] = board[k][j];\n                        board[k][j] = 0;\n                    }\n                }\n                b *= 2;\n            }\n            /*\n            rep(i,H) {\n                rep(j,W) cout << board[i][j];\n                cout << ln;\n            }\n            cout << ln;\n            */\n            chmax(ans,val);\n        }\n    }\n\n    cout << ans << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<string>\n#include<sstream>\n#include<cmath>\n#include<numeric>\n#include<map>\n#include<stack>\n#include<queue>\n#include<list>\n#include<set>\nusing namespace std;\nint mod = 1e9+7;\nint h, w, k;\nvector<string> c;\nchar B = '-';\n\nvoid show(vector<string> b) {\n  for(int i=0; i<h; i++) cerr << b[i] << endl;\n  cerr << endl;\n}\n\nvector<string> del(vector<string> b) {\n  vector<string> ret = b;\n  for(int i=0; i<h; i++){\n    string s = ret[i];\n    int cnt = 0;\n    for(int j=0; j<w; j++){\n      if( s[j] == s[j+1] ) cnt++;\n      else {\n        if( cnt >= k-1 ) {\n          for(int l=0; l<cnt+1; l++){\n            s[j-l] = B;\n          }\n          cnt = 0;\n        }\n      }\n    }\n    ret[i] = s;\n  }\n  return ret;\n}\n\nvector<string> drop(vector<string> b) {\n  for(int j=0; j<w; j++){\n    string s = \"\";\n    for(int i=0; i<h; i++){\n      if( b[i][j] != B ) {\n        s += b[i][j];\n      }\n    }\n    s = string(h-s.size(), B) + s;\n    for(int i=0; i<h; i++){\n      b[i][j] = s[i];\n    }\n  }\n  return b;\n}\n\nint calc(vector<string> b) {\n  int ret = 0;\n  for(int i=0; i<h; i++) {\n    for(int j=0; j<w; j++){\n      if( b[i][j] == B ) continue;\n      ret += b[i][j]-'0';\n    }\n  }\n  return ret;\n}\n\nint simulate(vector<string> b, int x, int y) {\n\n  b[y][x] = B;\n  vector<string> old = b;\n  vector<string> now = b;\n  int score = 0;\n  int turn = 1;\n  while( true ) {\n    // show(now);\n    now = drop(now);\n    // show(now);\n    now = del(now);\n    int sum = calc(old) - calc(now);\n    // cerr << turn << \" \" << turn * sum << endl;\n    score += turn * sum;\n\n    if( now == old ) break;\n    old = now;\n    turn *= 2;\n  }\n  // show(now);\n\n  return score;\n}\n\nint main() {\n  cin >> h >> w >> k;\n  c.resize(h);\n  for(int i=0; i<h; i++){\n    cin >> c[i];\n    c[i] += B;\n  }\n\n  // simulate(c, 0, 0);\n\n  int ans = 0;\n  for(int i=0; i<h; i++){\n    for(int j=0; j<w; j++){\n      int tmp = simulate(c, j, i);\n      if( ans < tmp ){\n        cerr << tmp << \" \" << j << \" \" << i << endl;\n      }\n      ans = max(ans, tmp);\n    }\n  }\n  cout << ans << endl;\n\n\n  return 0;\n}\n\n\n\n\n//\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nint H,W,K;\nint solve(vector<string> s){\n//\tshow(s);\n\tint ret=0;\n\trep(t,H*W){\n\t\tbool update=0;\n\t\trep(i,H){\n\t\t\tint cont=0;\n\t\t\tchar prev='0';\n\t\t\tint score=0;\n\t\t\trep(j,W+1){\n\t\t\t\tif(j==W||s[i][j]=='0'||s[i][j]!=prev){\n\t\t\t\t\tif(cont>=K){\n\t\t\t\t\t\tscore+=(prev-'0')*cont;\n\t\t\t\t\t\tupdate=1;\n\t\t\t\t\t\trep(x,cont) s[i][j-1-x]='0';\n\t\t\t\t\t}\n\t\t\t\t\tcont=1;\n\t\t\t\t}else{\n\t\t\t\t\tcont++;\n\t\t\t\t}\n\t\t\t\tif(j==W) break;\n\t\t\t\tprev=s[i][j];\n\t\t\t}\n\t\t\tret+=score<<t;\n\t\t}\n\t\tif(!update) break;\n\t\tvector<string> ns(H,string(W,'0'));\n\t\trep(j,W){\n\t\t\tint x=H-1;\n\t\t\tfor(int i=H-1;i>=0;i--) if(s[i][j]!='0'){\n\t\t\t\tns[x--][j]=s[i][j];\n\t\t\t}\n\t\t}\n\t\ts=ns;\n//\t\tshow(s);\n\t}\n\treturn ret;\n}\nint main(){\n\tcin>>H>>W>>K;\n\tvector<string> s(H);\n\trep(i,H) cin>>s[i];\n\tint ans=0;\n\trep(i,H) rep(j,W){\n\t\tvector<string> ns=s;\n\t\trep(x,i) ns[x+1][j]=s[x][j];\n\t\tns[0][j]='0';\n\t\tchmax(ans,solve(ns));\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nint main()\n{\n  int H, W, K;\n  string s[30];\n  int power[31];\n  power[0] = 1;\n  for(int i = 1; i < 31; i++) power[i] = power[i - 1] * 2;\n\n  cin >> H >> W >> K;\n  for(int i = 0; i < H; i++) {\n    cin >> s[i];\n    for(auto &c : s[i]) c -= '0';\n  }\n\n  int ret = 0;\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      int now = 0;\n      vector< string > field(H);\n      for(int k = 0; k < H; k++) {\n        field[k] = s[k];\n      }\n      field[i][j] = -1;\n      for(int k = i; k > 0; k--) {\n        swap(field[k][j], field[k - 1][j]);\n      }\n      bool update = true;\n      for(int k = 0; update; k++) {\n        update = false;\n        vector< int > ff(H, 0);\n        for(int l = 0; l < H; l++) {\n          auto &bits = ff[l];\n\n          int rev = -1, cs = 0;\n          for(int m = 0; m < W; m++) {\n            if(field[l][m] == -1) {\n              rev = -1;\n              continue;\n            }\n            if(rev == field[l][m]) {\n              cs++;\n            } else {\n              rev = field[l][m];\n              cs = 1;\n            }\n            if(cs >= K) {\n              for(int n = 0; n < K; n++) {\n                bits |= 1 << (m - n);\n              }\n              update = true;\n            }\n          }\n        }\n        int cost = 0;\n        for(int l = 0; l < H; l++) {\n          auto &bits = ff[l];\n          for(int m = 0; m < W; m++) {\n            if(field[l][m] == -1) continue;\n            if((bits >> m) & 1) {\n              cost += field[l][m];\n              field[l][m] = -1;\n              for(int n = l; n > 0; n--) {\n                swap(field[n - 1][m], field[n][m]);\n              }\n            }\n          }\n        }\n        now += power[k] * cost;\n      }\n      ret = max(ret, now);\n    }\n  }\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll,ll> pl;\ntypedef vector<pl> vp;\n#define fore(i,a,b) for(ll i=(ll)(a);i<=(ll)(b);++i)\n#define rep(i,n) fore(i,0,(n)-1)\n#define rfore(i,a,b) for(ll i=(ll)(b);i>=(ll)(a);--i)\n#define rrep(i,n) rfore(i,0,(n)-1)\n#define all(x) (x).begin(),(x).end()\nconst ll INF=1001001001;\nconst ll LINF=1001001001001001001;\nconst ll D4[]={0,1,0,-1,0};\nconst ll D8[]={0,1,1,0,-1,-1,1,-1,0};\ntemplate<class T>\nbool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>\nbool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\n\nll del(vvl &a){\n    ll h=a.size(),w=a[0].size();\n    ll ret=0;\n    rep(i,h)rep(j,w){\n        ll k=j;\n        while(k<w-1&&a[i][k+1]==a[i][j])k++;\n        if(k>j){\n            fore(l,j,k){\n                ret+=a[i][l];\n                a[i][l]=0;\n            }\n        }\n    }\n    return ret;\n}\nvoid move(vvl &a){\n    ll h=a.size(),w=a[0].size();\n    rep(i,w){\n        ll idx=h-1;\n        rrep(j,h){\n            if(a[j][i]){\n                if(idx!=j){\n                    a[idx][i]=a[j][i];\n                    a[j][i]=0;\n                }\n                idx--;\n            }\n        }\n    }\n}\nll f(vvl a,ll i,ll j){\n    a[i][j]=0;\n    ll ret=0;\n    ll times=1;\n    while(1){\n        move(a);\n        ll score=del(a);\n        if(score==0)break;\n        ret+=score*times;\n        times*=2;\n    }\n    return ret;\n}\nvoid solve(){\n    ll h,w,k;cin>>h>>w>>k;\n    vector<string> c(h);rep(i,h)cin>>c[i];\n    \n    vvl a(h,vl(w));\n    rep(i,h)rep(j,w)a[i][j]=c[i][j]-'0';\n\n    ll ans=0;\n    rep(i,h)rep(j,w)chmax(ans,f(a,i,j));\n    cout<<ans<<endl;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\n#define rep(i, n) for(int i=0; i<n; i++)\ntypedef long long ll;\nconst int INF = 0;\n\nint main(){\n    int H,W,K; cin>>H>>W>>K;\n    int field[H][W],copy[H][W];\n    rep(i,H){\n      string a; cin>>a;\n      rep(j,W){\n        field[i][j]=a[j]-'0';\n        copy[i][j]=field[i][j];\n      }\n    }\n  \nint rec=0;\nrep(a,H) rep(b,W){\n    rep(i,H) rep(j,W) field[i][j]=copy[i][j];\n    field[a][b]=INF;\n\nrep(k,30){\n        for(int i=0;i<H-1;i++){\n            rep(j,W){\n                if(field[i+1][j]==INF){\n                    field[i+1][j]=field[i][j];\n                    field[i][j]=INF;\n                }\n            }\n        }\n    }\n\n\n int ans=0; \n int two=1;\n rep(l,30){\n   \n    int point=0;\n    rep(i,H){\n\n        int count=1;\n        for(int j=1;j<W;j++){\n            if(field[i][j]==field[i][j-1]) count++;\n            else{\n                if(count<K) count=1;\n                else{\n                    point+=field[i][j-1]*count;\n                    rep(k,count) field[i][j-1-k]=INF;\n                    count=1;\n                }   \n            }\n            if(j==W-1){\n                    if(count>=K){\n                        point+=field[i][j-1]*count;\n                        rep(k,count) field[i][j-k]=INF;\n                    }\n            }\n        }\n    }\n    rep(k,20){\n        for(int i=0;i<H-1;i++){\n            rep(j,W){\n                if(field[i+1][j]==INF){\n                    field[i+1][j]=field[i][j];\n                    field[i][j]=INF;\n                }\n            }\n        }\n    }\n\n    \n   ans+=point*two;\n   two*=2;\n }\n rec=max(ans,rec);\n}\n \ncout<<rec<<endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint H,W,K;\nstring s[30];\nint A[30][30];\nint calc()\n{\n\tint ret=0;\n\tfor(int z=0;;z++)\n\t{\n\t\tint now=0;\n\t\tbool f[30][30]={};\n\t\tfor(int i=0;i<H;i++)\n\t\t{\n\t\t\tint cnt=0,pre=-1;\n\t\t\tfor(int j=0;j<W;j++)\n\t\t\t{\n\t\t\t\tif(A[i][j]==0)\n\t\t\t\t{\n\t\t\t\t\tcnt=0;\n\t\t\t\t\tpre=-1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(pre==A[i][j])cnt++;\n\t\t\t\t\telse cnt=1;\n\t\t\t\t\tpre=A[i][j];\n\t\t\t\t}\n\t\t\t\tif(cnt>K)\n\t\t\t\t{\n\t\t\t\t\tf[i][j]=true;\n\t\t\t\t\tnow+=A[i][j];\n\t\t\t\t}\n\t\t\t\telse if(cnt==K)\n\t\t\t\t{\n\t\t\t\t\tfor(int k=0;k<K;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tf[i][j-k]=true;\n\t\t\t\t\t\tnow+=A[i][j-k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(now==0)break;\n\t\tret+=now<<z;\n\t\tfor(int j=0;j<W;j++)\n\t\t{\n\t\t\tint sz=H;\n\t\t\tfor(int i=H;i--;)\n\t\t\t{\n\t\t\t\tif(A[i][j]==0||f[i][j])continue;\n\t\t\t\tA[--sz][j]=A[i][j];\n\t\t\t}\n\t\t\twhile(sz)A[--sz][j]=0;\n\t\t}\n\t}\n\treturn ret;\n}\nmain()\n{\n\tcin>>H>>W>>K;\n\tfor(int i=0;i<H;i++)cin>>s[i];\n\tfor(int i=0;i<H;i++)for(int j=0;j<W;j++)A[i][j]=s[i][j]-'0';\n\tint ans=calc();\n\tfor(int i=0;i<H;i++)for(int j=0;j<W;j++)\n\t{\n\t\tfor(int i=0;i<H;i++)for(int j=0;j<W;j++)A[i][j]=s[i][j]-'0';\n\t\tfor(int k=i;k--;)A[k+1][j]=A[k][j];\n\t\tA[0][j]=0;\n\t\tans=max(ans,calc());\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pull = pair<ull, ll>;\nusing pis = pair<int, string>;\n#define INF 1000000000\n#define LLINF 10000000000000000ll\n#define MOD 1000000007LL\n\nvoid copy_field(vector<vector<int>> &field, vector<vector<int>> &original) {\n  for (int i = 0; i < field.size(); i++) for (int j = 0; j < field[0].size(); j++) field[i][j] = original[i][j];\n  return;\n}\n\nbool check(vector<vector<int>> &field, vector<vector<int>> &checkfield, int k) {\n  int h = field.size(), w = field[0].size();\n  bool flag = false;\n  for (int i = 0; i < h; i++) {\n    if (k == 1) {\n      for (int j = 0; j < w; j++) {\n        if (field[i][j] != 0) {\n          checkfield[i][j] = 1;\n          flag = true;\n        }\n      }\n      continue;\n    }\n    int before = field[i][0], cnt = 1;\n    for (int j = 1; j < w; j++) {\n      if ((before != 0) && (before == field[i][j])) {\n        cnt++;\n        if (cnt >= k) {\n          checkfield[i][j] = 1;\n          flag = true;\n        }\n      }\n      else {\n        cnt = 1;\n        before = field[i][j];\n      }\n    }\n    for (int j = w-1; j >= k-1; j--) {\n      if ((checkfield[i][j] == 1) && (checkfield[i][j-1] == 0)) {\n        for (int l = 0; l < k-1; l++) {\n          j--;\n          checkfield[i][j] = 1;\n        }\n      }\n    }\n  }\n  return flag;\n}\n\nvoid init_checkfield(vector<vector<int>> &checkfield) {\n  for (int i = 0; i < checkfield.size(); i++) for (int j = 0; j < checkfield[0].size(); j++) checkfield[i][j] = 0;\n  return;\n}\n\nvoid init_field(vector<vector<int>> &field, int erase) {\n  int h = field.size();\n  for (int i = erase/h; i > 0; i--) {\n    field[i][erase%h] = field[i-1][erase%h];\n  }\n  field[0][erase % h] = 0;\n}\n\nvoid printfield(vector<vector<int>>&field) {\n  for (int i = 0; i < field.size(); i++) {\n    for (int j = 0; j < field[0].size(); j++) {\n      cout << field[i][j] << \" \";\n    }cout << endl;\n  }cout << endl;\n  return;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int h,w, k;\n  cin >> h >> w >> k;\n  vector<vector<int>> field(h, vector<int>(w)), original(h, vector<int>(w)), checkfield(h, vector<int>(w));\n  //for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) cin >> original[i][j];\n  for (int i = 0; i < h; i++) {\n    string s;\n    cin >> s;\n    for (int j = 0; j < w; j++) {\n      original[i][j] = (int)(s[j] - '0');\n    }\n  }\n\n  int ans = -1;\n  for (int erase = 0; erase < h*w; erase++) {\n    copy_field(field, original);\n    init_checkfield(checkfield);\n    //field[erase/h][erase%h] = 0;\n    init_field(field, erase);\n    int db = 1;\n    int temp = 0;\n    while(check(field, checkfield, k)) {\n      //cout << \"check\" << erase << endl;\n      //printfield(field);\n      \n      for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n          if (checkfield[i][j] == 1) {\n            temp += db * field[i][j];\n            field[i][j] = 0;\n          }\n        }\n      }\n      \n      for (int i = h-2; i >= 0; i--) for (int j = 0; j < w; j++) checkfield[i][j] += checkfield[i+1][j];\n\n      for (int i = h-1; i >= 0; i--) {\n        for (int j = 0; j < w; j++) {\n          if ((field[i][j] == 0) || (checkfield[i][j] == 0)) continue;\n          if (i + checkfield[i][j] < h) {\n            field[i+checkfield[i][j]][j] = field[i][j];\n            field[i][j] = 0;\n          }\n          else field[i][j] = 0;\n        }\n      }\n      db *= 2;\n      init_checkfield(checkfield);\n    }\n    //cout << temp << endl;\n    ans = max(ans, temp);\n  }\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair< ll, ll > Pi;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep2(i,n) for(int i=1;i<=(n);i++)\n#define rep3(i,i0,n) for(int i=i0;i<(n);i++)\n#define pb push_back\n#define mod 1000000007\nconst ll INF = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nll gcd(ll a, ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b) {return a/gcd(a,b)*b;}\n#define all(x) x.begin(), x.end()\n#define mp make_pair\nbool compare(Pi a, Pi b) {\n    if(a.first != b.first){\n        return a.first < b.first;\n        \n    }else{\n        return a.second < b.second;\n    }\n}\n\nint ctoi(char c) {\n\tif (c >= '0' && c <= '9') {\n\t\treturn c - '0';\n\t}\n\treturn 0;\n}\nbool In_map(ll y,ll x,ll h,ll w){\n    if(y<0 || x<0 || y>=h || x>=w){\n        return 0;\n    }else{\n        return 1;\n    }\n}\nconst vector<ll> dx{1,0,-1,0};\nconst vector<ll> dy{0,1,0,-1};\n\n\n\nint main() {\n\n    ll H,W,K;\n    cin >>H>>W>>K;\n    vector<string> S(H);\n    rep(i,H) cin >>S[i];\n    vector<vector<ll>> R(H,vector<ll>(W));\n    vector<vector<ll>> R2(H,vector<ll>(W));\n    rep(i,H) rep(j,W) R[i][j] = ctoi(S[i][j]);\n    R2 = R;\n    if(K<=1){\n        ll ans = 0;\n        ll min = INF;\n        rep(i,H){\n            rep(j,W){\n                chmin(min,R[i][j]);\n                ans+=R[i][j];\n            }\n        }\n        cout << ans-min<<endl;\n        return 0;\n    }\n\n\n    ll fans = 0;\n    rep(h,H) rep(w,H){\n    ll ans = 0;\n    R=R2;\n    R[h][w] = -1;\n    ll flag = 0;\n    rep(m,H){\n        ll p2 =pow(2,m); \n        rep(j,W){\n            vector<ll> tmp;\n            rep(i,H){\n                if(R[H-1-i][j] != -1){\n                    tmp.pb(R[H-1-i][j]);\n                }\n            }\n            rep(i,H){\n                if(i<tmp.size()){\n                    R[H-1-i][j] = tmp[i];\n                }else{\n                    R[H-1-i][j] = -1;\n                }\n            }\n        }\n        rep(i,H){\n            ll cnt=0;\n            ll p=-1;\n            rep(j,W){\n                if(R[i][j] == p && R[i][j] != -1){\n                    cnt++;\n                    if(j==W-1){\n                        if(cnt>=K){\n                            flag = 1;\n                            //ans += R[i][j-1]*cnt*p2;\n                            rep(k,cnt){\n                               // R[i][j-k] = -1;\n                            }\n                        }\n                    }\n                }else{\n                    if(cnt>=K){\n                        flag = 1;\n                        //ans += R[i][j-1]*cnt*p2;\n                        rep(k,cnt){\n                            //R[i][j-k-1] = -1;\n                        }\n                    }\n                    cnt = 1;\n                }\n                \n\n                p = R[i][j];\n            }\n        \n        \n        }\n        /*rep(i,H){\n            rep(j,W){\n                cout << R[i][j]<<\" \";\n            }\n            cout <<endl;\n        }*/\n        if(flag ==0) break;\n    }\n\n\n        chmax(fans,ans);\n    }\n\n    cout << fans<<endl;\n    \n    return 0;\n    \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define MOD 1000000007\n#define INF 1000000000009\ntypedef long long ll;\ntypedef pair<int,int> P;\n#define YES(s) s?cout << \"YES\" << endl:cout << \"NO\" << endl\n#define Yes(s) s?cout << \"Yes\" << endl:cout << \"No\" << endl\n#define Taka(s) s?cout << \"Takahashi\" << endl:cout << \"Aoki\" << endl\n//#define int ll\n\nsigned main(){\n    int H,W,K;\n    char c[32][32];\n    int d[32][32];\n    int Ans=0;\n    cin >> H >> W >> K;\n    REP(i,H){REP(j,W){cin >> c[i][j];}}\n    REP(i,H){\n        REP(j,W){\n            int num=0;\n            REP(k,H){\n                REP(l,W){\n                    d[k][l] = (int)(c[k][l] - '0');\n                }\n            }\n            d[i][j]=0;\n            for(int k=i;k>=1;k--){\n                d[k][j]=d[k-1][j];\n            }\n            d[0][j]=0;\n            bool ch=0;\n            int kai=1;\n            while(ch==0){\n               // if(i==3&&j==3){cout << endl << endl;REP(k,H){REP(l,W){cout << d[k][l] << \" \";}cout << endl;}}\n                int kam=0;\n                ch=1;\n                REP(k,H){\n                    int y=1;\n                    REP(l,W-1){\n                        if(d[k][l]==d[k][l+1]){\n                            y++;\n                        }else{\n                            if(K<=y && d[k][l]!=0){\n                                ch=0;\n                                for(int m=l-y+1;m<=l;m++){\n                                    kam+=d[k][m];\n                                    d[k][m]=0;\n                                }\n                            }\n                            y=1;\n                        }\n                    }\n                    if(K<=y && d[k][W-1]!=0){\n                        ch=0;\n                        for(int m=W-y;m<W;m++){\n                            kam+=d[k][m];\n                            d[k][m]=0;\n                        }\n                    }\n                    y=1;\n                }\n               // if(i==3&&j==3){cout <<endl << endl << kai << \" \" << kam << \" \" << endl;}\n                num += kai*kam;\n                kam=0;\n                kai*=2;\n                \n                REP(l,W){\n                    REP(k,H){\n                        if(d[k][l]==0){\n                            for(int m=k;m>0;m--){\n                                d[m][l]=d[m-1][l];\n                            }\n                            d[0][l]=0;\n                        }\n                    }\n                }\n            }\n            Ans = max(Ans,num);\n            //cout << i+1 << \" \" << j+1 << \"  \" << num << endl;\n        }//cout << endl;\n    }\n    cout << Ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// square869120Contest #3-B\n#include <bits/stdc++.h>\n#define endl \"\\n\"\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define e_b emplace_back\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ipair;\ntypedef pair<ll,ll> lpair;\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v) //vectorの中身を見る\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\nvoid map_p(map<int,int>& d){cout<<\"map: \";for(auto a : d){cout<<\"{\"<<a.first<<\":\"<<a.second<<\"}\";}cout<<endl;} //mapの中身を見る\nvoid set_p(set<int>& d){cout<<\"set: \";for(int a : d){cout<<a<<\" \";}cout<<endl;} //setの中身を見る\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(12);\n\n    int h,w,k;\n    cin>>h>>w>>k;\n    vector<vector<int>> ban(h,vector<int>(w));\n    rep(i,h){\n        rep(j,w){\n            char a;\n            cin>>a;\n            ban[i][j]=a-'0';\n        }\n    }\n    int ans=0;\n    rep(i,h){\n        rep(j,w){\n            int score=0;\n            vector<vector<int>> cur=ban;\n            cur[i][j]=0; //最初に消すセル\n            int now=i-1;\n            //下に詰める\n            while(now>=0){\n                cur[now+1][j]=cur[now][j],cur[now][j]=0;\n                now--;\n            }\n            int turn=0;\n            //消えるものがあるまで続く\n            while(true){\n                int max_del=-1,total=0; //消せたもののなかで1番でかい数字 このターンで消した合計\n                //盤を見ていく\n                rep(k1,h){\n                    int now_n=cur[k1][0],ren=1;\n                    for(int k2=1;k2<w;k2++){\n                        if(now_n==cur[k1][k2]) ren++;\n                        else{\n                            if(ren>=k){\n                                // cout<<turn<<\":\"<<now_n<<endl;\n                                total+=ren*now_n;\n                                max_del=max(max_del,now_n);\n                                for(int k3=k2-1;k3>=(k2-1)-(ren-1);k3=k3-1) cur[k1][k3]=0; //消した場所を0にする\n                            }\n                            now_n=cur[k1][k2],ren=1;\n                        }\n                    }\n                    if(ren>=k){\n                        // cout<<turn<<\":\"<<now_n<<endl;\n                        total+=ren*now_n;\n                        max_del=max(max_del,now_n);\n                        for(int k3=w-1;k3>=(w-1)-(ren-1);k3=k3-1) cur[k1][k3]=0; //消した場所を0にする\n                    }\n                }\n                //盤見終わる\n                score+=(1<<turn)*total;\n                turn++;\n                if(max_del<=0) break; //何も消せてない\n                // 各列を下に詰める\n                rep(k2,w){\n                    for(int k1=h-1;k1>=0;k1=k1-1){\n                        if(cur[k1][k2]>=1) continue;\n                        int now_i=k1-1;\n                        while(now_i>=0){\n                            if(cur[now_i][k2]>=1){\n                                cur[k1][k2]=cur[now_i][k2],cur[now_i][k2]=0;\n                                break;\n                            }\n                            now_i--;\n                        }\n                    }\n                }\n            }\n            ans=max(ans,score);\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=100003;\n\nll rui(ll a,ll b){\n    if(b==1) return a%mod;\n    else if(b==0) return 1;\n    else if(b%2==0) return (rui(a,b/2)*rui(a,b/2))%mod;\n    else return (rui(a,b-1)*a)%mod;\n}\n\n\nint main(){\n    \n    int H,W,K;cin>>H>>W>>K;\n    vector<vector<int>> S(H,vector<int>(W+1,-1)),T(H,vector<int>(W+1,-1));\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            char a;cin>>a;\n            T[i][j]=(a-'0');\n        }\n    }\n    \n    int ans=0;\n    \n    for(int y=0;y<H;y++){\n    for(int z=0;z<W;z++){\n        \n        for(int i=0;i<H;i++){\n            for(int j=0;j<W+1;j++){\n                S[i][j]=T[i][j];\n            }\n        }\n        S[y][z]=-1;\n        for(int i=H-2;i>=0;i--){\n            if(S[i][z]==-1) continue;\n            int now=i;\n            while(1){\n                if(now!=H-1&&S[now+1][z]==-1){\n                    swap(S[now][z],S[now+1][z]);\n                    now++;\n                }else break;\n            }\n        }\n        \n        int score=0,cnt=0;\n        bool flag=true;\n        while(flag){\n            flag=false;\n            int sum=0;\n            for(int i=0;i<H;i++){\n                int ren;\n                if(S[i][0]!=-1) ren=1;\n                else ren=0;\n                for(int j=1;j<W+1;j++){\n                    if(S[i][j]==S[i][j-1]&&S[i][j]!=-1) ren++;\n                    else{\n                        if(ren>=K){\n                            sum+=ren*S[i][j-1];\n                            for(int p=j-ren;p<j;p++){\n                                S[i][p]=-1;\n                            }\n                        }\n                        if(S[i][j]==-1) ren=0;\n                        else ren=1;\n                    }\n                }\n            }\n            if(sum>0) flag=true;\n            score+=rui(2,cnt)*sum;\n            cnt++;\n            //cout<<z<<\" \"<<sum<<endl;\n            for(int j=0;j<W;j++){\n                for(int i=H-2;i>=0;i--){\n                    if(S[i][j]==-1) continue;\n                    int now=i;\n                    while(1){\n                        if(now!=H-1&&S[now+1][j]==-1){\n                            swap(S[now][j],S[now+1][j]);\n                            now++;\n                        }else break;\n                    }\n                }\n            }\n        }\n        ans=max(ans,score);\n    }\n    }\n    cout<<ans<<endl;\n    \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain(){\n\tint H, W, K;\n\tcin>>H>>W>>K;\n\tvvint vv;\n\tinitvv(vv,H,W);\n\trep(i,H) rep(j,W){\n\t\tchar t;\n\t\tcin>>t;\n\t\tvv[i][j] = t - '0';\n\t}\n\tint ans = 0;\n\trep(_i,H){\n\t\trep(_j,W){\n\t\t\tvvint ww = vv;\n\t\t\tww[_i][_j] = 0;\n\t\t\tbool update = true;\n\t\t\tint cnt = 1;\n\t\t\tint tmp = 0;\n\t\t\t// cout << \"i j \"<< _i << \" \"<<_j<<endl;\n\t\t\twhile(update){\n\t\t\t\tupdate = false;\n\t\t\t\tint sum = 0;\n\t\t\t\trep(j,W){\n\t\t\t\t\tfor(int i=H-1;i>=0;i--){\n\t\t\t\t\t\tint p = i;\n\t\t\t\t\t\twhile(ww[p][j] && p+1 < H && ww[p+1][j] == 0){\n\t\t\t\t\t\t\tww[p+1][j] = ww[p][j];\n\t\t\t\t\t\t\tww[p][j] = 0;\n\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// rep(i,H){\n\t\t\t\t// \trep(j,W){\n\t\t\t\t// \t\tcout<<\" \"<<ww[i][j];\n\t\t\t\t// \t}cout<<endl;\n\t\t\t\t// }cout<<endl;\n\t\t\t\trep(i,H){\n\t\t\t\t\trep(j,W){\n\t\t\t\t\t\tif(j+K-1>=W) break;\n\t\t\t\t\t\tif(!ww[i][j]) continue;\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\treep(k,j+1,j+K){\n\t\t\t\t\t\t\tif(ww[i][j] != ww[i][k]) ok=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ok){\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t\tint t = ww[i][j];\n\t\t\t\t\t\t\twhile(j < W && t == ww[i][j]){\n\t\t\t\t\t\t\t\tsum += ww[i][j];\n\t\t\t\t\t\t\t\tww[i][j] = 0;\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp += cnt * sum;\n\t\t\t\tcnt <<= 1;\n\t\t\t}\n\t\t\tmaxs(ans, tmp);\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n//const ll MOD = 1e9 + 7;\n//const ll MOD = 998244353;\n//const ll MOD = ;\nll mod(ll A, ll M) {return (A % M + M) % M;}\nconst ll INF = 1LL << 60;\ntemplate<class T> bool chmin(T& a, T b) {if (a > b) {a = b; return true;} return false;}\ntemplate<class T> bool chmax(T& a, T b) {if (a < b) {a = b; return true;} return false;}\nll divceil(ll A, ll B) {return (A + (B - 1)) / B;}\nll myctoi(char C) {return C - '0';}\nchar myitoc(ll N) {return '0' + N;}\n#define FINALANS(A) {cout << (A) << '\\n'; exit(0);}\n\nll H, W, K;\nvector<string> C;\nvector<string> c;\n\nvoid init()\n{\n  for (ll i = 0; i < H; i++)\n  {\n    C.at(i) = c.at(i);\n  }\n}\n\nvoid drop()\n{\n  for (ll x = 0; x < W; x++)\n  {\n    string ns = \"\";\n    for (ll y = H - 1; y >= 0; y--)\n    {\n      if (C.at(y).at(x) != ' ')\n        ns += C.at(y).at(x);\n    }\n\n    ll cnt = 0;\n    for (ll y = H - 1; y >= 0; y--)\n    {\n      if (cnt >= ns.size())\n        C.at(y).at(x) = ' ';\n      else\n      {\n        C.at(y).at(x) = ns.at(cnt);\n        cnt++;\n      }\n    }\n  }\n}\n\nll erase()\n{\n  ll ret = 0;\n  for (ll y = 0; y < H; y++)\n  {\n    ll tmp = 0, l = -1;\n    for (ll x = 0; x < W; x++)\n    {\n      if (l != -1 && C.at(y).at(x) != C.at(y).at(x + 1))\n      {\n        if (x - l + 1 >= K)\n        {\n          ret += tmp * (x - l + 1);\n          for (ll i = l; i <= x; i++)\n          {\n            C.at(y).at(i) = ' ';\n          }\n        }\n        l = -1;\n      }\n\n      if (C.at(y).at(x) != ' ' && C.at(y).at(x) == C.at(y).at(x + 1))\n      {\n        if (l == -1)\n        {\n          l = x;\n          tmp = myctoi(C.at(y).at(x));\n        }\n      }\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  cin >> H >> W >> K;\n  c = vector<string>(H);\n  for (ll i = 0; i < H; i++)\n  {\n    cin >> c.at(i);\n    c.at(i) += \"#\";\n  }\n\n  ll ans = 0;\n  C = vector<string>(H);\n  for (ll dy = 0; dy < H; dy++)\n  {\n    for (ll dx = 0; dx < W; dx++)\n    {\n      ll tmp = 0;\n      init();\n      C.at(dy).at(dx) = ' ';\n\n      for (ll i = 0;; i++)\n      {\n        drop();\n        ll sum = erase();\n\n        /*\n        cerr << dy << \" \" << dx << \" \" << i << \" \" << sum << endl;\n        for (ll y = 0; y < H; y++)\n        {\n          cerr << C.at(y) << endl;\n        }\n        cerr << endl;\n        */\n\n        tmp += (1LL << i) * sum;\n        if (sum == 0)\n          break;\n      }\n      chmax(ans, tmp);\n    }\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000\nusing namespace std;\n\nint H, W, K;\nint check_point(vector<vector<int>> board, pair<int, int> hw)\n{\n  int ans = 0;\n  board.at(hw.second - 1).erase(board.at(hw.second - 1).begin() + H - hw.first);\n  // cout << \"start\" << endl;\n  // for (int i = 0; i < W; ++i)\n  // {\n  //   for (int j = 0; j < board.at(i).size(); ++j)\n  //   {\n  //     cout << board.at(i).at(j) << ' ';\n  //   }\n  //   cout << endl;\n  // }\n  // cout << endl;\n  int loop_cnt = -1;\n  while (true)\n  {\n    loop_cnt += 1;\n    bool didnt_change = true;\n    int cnt;\n    for (int i = H - 1; i >= 0; --i)\n    {\n      cnt = 0;\n      int before = -1;\n      for (int j = 0; j < W; ++j)\n      {\n        if (board.at(j).at(i) == -1)\n        {\n\n          if (cnt >= K)\n          {\n            didnt_change = false;\n            ans += pow(2, loop_cnt) * cnt * board.at(j - 1).at(i);\n            for (int k = 0; k < cnt; ++k)\n            {\n              board.at(j - 1 - k).erase(board.at(j - 1 - k).begin() + i);\n            }\n          }\n          before = -1;\n          cnt = 0;\n        }\n        else if (board.at(j).at(i) == before)\n        {\n          cnt += 1;\n        }\n        else\n        {\n          before = board.at(j).at(i);\n          if (cnt >= K)\n          {\n            didnt_change = false;\n            ans += pow(2, loop_cnt) * cnt * board.at(j - 1).at(i);\n            for (int k = 0; k < cnt; ++k)\n            {\n              board.at(j - 1 - k).erase(board.at(j - 1 - k).begin() + i);\n            }\n          }\n          cnt = 1;\n        }\n      }\n      if (cnt >= K)\n      {\n        didnt_change = false;\n        ans += pow(2, loop_cnt) * cnt * board.at(W - 1).at(i);\n        for (int k = 0; k < cnt; ++k)\n        {\n          board.at(W - 1 - k).erase(board.at(W - 1 - k).begin() + i);\n        }\n      }\n    }\n    if (didnt_change)\n    {\n      break;\n    }\n    // for (int i = 0; i < W; ++i)\n    // {\n    //   for (int j = 0; j < board.at(i).size(); ++j)\n    //   {\n    //     cout << board.at(i).at(j) << ' ';\n    //   }\n    //   cout << endl;\n    // }\n    // cout << ans << endl;\n    // cout << endl;\n  }\n  // for (int i = 0; i < W; ++i)\n  // {\n  //   for (int j = 0; j < board.at(i).size(); ++j)\n  //   {\n  //     cout << board.at(i).at(j) << ' ';\n  //   }\n  //   cout << endl;\n  // }\n  // cout << \"end\" << endl;\n  return ans;\n}\n\nint main()\n{\n  cin >> H >> W >> K;\n  vector<vector<int>> board(W, vector<int>(2 * H, - 1));\n\n  for (int i = 0; i < H; ++i)\n  {\n    string row;\n    cin >> row;\n    for (int j = 0; j < W; ++j)\n    {\n      board.at(j).at(H - 1 - i) = (int)(row.at(j)) - 48;\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i < W; ++i)\n  {\n    for (int j = 0; j < H; ++j)\n    {\n      ans = max(ans, check_point(board, {i + 1, j + 1}));\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, s, n) for (int i = s; i < n; i++)\n#define ALL(a) a.begin(), a.end()\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\n\nint H, W, K;\nvector<vector<int>> G;\n\nvoid update (vector<vector<int>> &G) {\n    for (auto &g : G) {\n        vector<int> updated;\n        for (auto elm : g) if (elm != 0) updated.push_back(elm);\n        g = updated;\n    }\n}\n\nint count (vector<vector<int>> &G) {\n    int sum = 0;\n    for (int i = H - 1; i >= 0; i--) {\n        // REP(j, 0, W) {\n        //     if (G[j].size() > i) cout << \" \" << G[j][i] << \" \";\n        //     else cout << \" NA \";\n        // }\n        // cout << endl;\n        int j = 0;\n        while (j < W - K + 1) {\n            if (!(G[j].size() > i)) {\n                j++;\n                continue;\n            }\n            int len = 1, k = j + 1;\n            while (k < W && G[k].size() > i) {\n                if (G[j][i] == G[k][i]) {\n                    len++;\n                    k++;\n                }\n                else break;\n            }\n            // cout << \"# i : \" << i << \" , found \" << G[j][i] << \" * \" << len << endl;\n            if (len >= K) {\n                sum += G[j][i] * len;\n                REP(l, j, k) G[l][i] = 0;\n            }\n            j = k;\n        }\n    }\n    return sum;\n}\n\nint calculate(vector<vector<int>> &G) {\n    int s = 0, n = 1; vector<vector<int>> tmp = G;\n    while (1) {\n        update(tmp);\n        // for (auto t : tmp) cout << t.size() << \" \";\n        // cout << endl;\n        int score = count(tmp) * n;\n        if (score == 0) break;\n        s += score;\n        n *= 2;\n    }\n    return s;\n}\n\nint main() {\n    cin >> H >> W >> K;\n    vector<string> C(H);\n    REP(i, 0, H) cin >> C[i];\n\n    G.resize(W, vector<int>(H));\n    REP(i, 0, H) REP(j, 0, W) G[j][H - 1 - i] = C[i][j] - '0';\n\n    int ans = 0;\n    REP(i, 0, H) {\n        REP(j, 0, W) {\n            int tmp = G[j][i];\n            G[j][i] = 0;\n            ans = max(ans, calculate(G));\n            G[j][i] = tmp;\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*  -*- coding: utf-8 -*-\n *\n * b.cc: \n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n\nusing namespace std;\n\n/* constant */\n\nconst int MAX_H = 30, MAX_W = 30;\n\n/* typedef */\n\ntypedef int bdt[MAX_H][MAX_W];\n\n/* global variables */\n\nbdt bs, cs;\n\n/* subroutines */\n\nvoid print_bd(int h, int w, bdt &bs) {\n  for (int y = 0; y < h; y++) {\n    for (int x = 0; x < w; x++) printf(\"%d\", bs[y][x]);\n    putchar('\\n');\n  }\n}\n\nvoid drop(int h, int w, bdt &bs) {\n  for (int x = 0; x < w; x++)\n    for (int y = h - 1, y0 = y; y >= 0; y--) {\n      if (y0 > y) y0 = y;\n      for (; y0 >= 0 && bs[y0][x] == 0; y0--);\n      if (y0 < 0) break;\n      if (bs[y][x] == 0) swap(bs[y][x], bs[y0][x]);\n    }\n}\n\nint erase(int h, int w, bdt &bs, int k) {\n  int cnt = 0;\n  for (int y = 0; y < h; y++) {\n    for (int x = 0; x < w;) {\n      int x0 = x + 1;\n      for (; x0 < w && bs[y][x0] == bs[y][x]; x0++);\n      if (bs[y][x] > 0 && x0 - x >= k) {\n\tcnt += (x0 - x) * bs[y][x];\n\tfor (int x1 = x; x1 < x0; x1++) bs[y][x1] = 0;\n      }\n      x = x0;\n    }\n  }\n  return cnt;\n}\n\n/* main */\n\nint main() {\n  int h, w, k;\n  cin >> h >> w >> k;\n\n  for (int y = 0; y < h; y++) {\n    string s;\n    cin >> s;\n    for (int x = 0; x < w; x++) bs[y][x] = s[x] - '0';\n  }\n\n  int maxc = 0;\n  for (int y = 1; y < h; y++)\n    for (int x = 0; x < w; x++) {\n      memcpy(cs, bs, sizeof(bs));\n      cs[y][x] = 0;\n      drop(h, w, cs);\n      //printf(\"y=%d,x=%d\\n\", y, x); print_bd(h, w, cs);\n\n      int c = 0;\n      for (int bi = 1;; bi <<= 1) {\n\tint m = erase(h, w, cs, k);\n\tif (m == 0) break;\n\tc += bi * m;\n\tdrop(h, w, cs);\n      }\n\n      if (maxc < c) maxc = c;\n    }\n\n  printf(\"%d\\n\", maxc);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC diagnostic ignored \"-Wunused-variable\" \n#include <bits/stdc++.h>\nusing namespace std;\n\n#define BOOST\n#ifdef BOOST\n#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/multiprecision/cpp_dec_float.hpp>\n#include <boost/range/adaptor/reversed.hpp>\nusing namespace boost;\nusing ml = boost::multiprecision::cpp_int;\nusing md = boost::multiprecision::cpp_dec_float_100;\n#define forir(i, ...) if(ll i=(ll)v.size())for(__VA_ARGS__)if(i--,1)\n#define eachr(i, e, c) forir(i, auto &&e: adaptors::reverse(c))\n#endif\n\n/***** type *****/\nusing ll = long long;\nusing ld = long double;\nusing pll = pair<long long, long long>;\ntemplate <class T> using vt = vector<T>;\ntemplate <class T> using vvt = vector<vector<T>>;\ntemplate <class T> using vvvt = vector<vector<vector<T>>>;\n/***** define *****/\n#define all(c) (c).begin(), (c).end()            // begin to end\n#define coutd cout << fixed << setprecision(10)  // cout double\n#define output(x) do{cout<<x;return 0;}while(0)  // cout return\n#define rep(i, b, e) for (ll i = b; i < e; i++)  // repeat\n#define repr(i, b, e) for (ll i = b; e < i; i--) // repeat reverse\n#define fori(i, ...) if (ll i = -1) for(__VA_ARGS__) if (i++, 1)\n#define each(i, e, c) fori (i, auto&& e: c)      // for each\n/***** const value *****/\n#define llong_max 9223372036854775807            // 9 * 10^18\n#define ldbl_max 1.79769e+308                    // 1.7 * 10^308\n#define pi 3.1415926535897932                    // 3.14 ...\n/***** lambda *****/\nauto Ceil = [] // if (a % b != 0) return a / b + 1;\n(auto x) { return (ll)ceil(x); };\nauto Count = [] // long long count value\n(auto b, auto e, auto x) { return (ll)count(b, e, x); };\nauto CtoL = [] // char to number\n(auto c) { return (ll)c - (ll)'0'; };\nauto LtoC = [] // number to char\n(auto n) { return (char)('0' + n); };\nauto Pow = [] // long long pow\n(auto a, auto b) { return (ll)pow(a, b); };\nauto Pow2 = [] // long long pow2\n(auto n) { return (1LL << n); };\nauto Pow10 = [] // long long pow10\n(auto n) { return (ll)pow(10, n); };\nauto Size = []  // long long collection size\n(auto& c) { return (ll)(c).size(); };\nauto Sum = [] // long long accumulate\n(auto b, auto e) { return accumulate(b, e, 0LL); };\n\n/***** template *****/\ntemplate <class T> void MakeVVT\n(ll ys, ll xs, vvt<T>& v, T fill = T())\n{\t// vector<vector<T>> resize + fill\n\tv.resize(ys); rep(y, 0, ys) v[y].resize(xs, fill);\n}\ntemplate <class T> void MakeVVVT\n(ll zs, ll ys, ll xs, vvvt<T>& v, T fill = T())\n{\t// vector<vector<vector<T>>> resize + fill\n\tv.resize(zs); rep(z, 0, zs) MakeVVT(ys, xs, v[z], fill);\n}\ntemplate <class T> void InputVT\n(ll xs, vt<T>& v, T fix = T())\n{\t// input vector<T> (T != struct) + fix\n\tv.resize(xs); rep(i, 0, xs) { cin >> v[i]; v[i] += fix; }\n}\ntemplate <class T> void InputVVT\n(ll ys, ll xs, vvt<T>& v, T fix = T())\n{\t// input vector<vector<T>> (T != struct) + fix\n\tMakeVVT(ys, xs, v, fix);\n\trep(y, 0, ys) rep(x, 0, xs) { cin >> v[y][x]; v[y][x] += fix; }\n}\ntemplate <class T> void InputVVVT\n(ll zs, ll ys, ll xs, vvvt<T>& v, T fix = T())\n{\t// input vector<vector<vector<T>>> (T != struct) + fix\n\tv.resize(zs); rep(z, 0, zs) InputVVT(ys, xs, v[z], fix);\n}\n\n/**************************************/\n/********** BEGIN OF NYA LIB **********/\n/**************************************/\n\nnamespace NyaGadget {}\n\nnamespace NyaGadget\n{\n\t/*** ランレングス圧縮ライブラリ ***/\n\n\ttemplate <class T> struct RunLengthEncodingResult\n\t{\t// ランレングス圧縮の結果を格納する構造体\n\t\tlong long begin = 0; // 区間開始位置\n\t\tlong long end = 0;   // 区間終了位置\n\t\tstd::vector<T> sub;  // 区間データ\n\t};\n\n\ttemplate <> struct RunLengthEncodingResult<std::string>\n\t{\t// ランレングス圧縮の結果を格納する構造体\n\t\tlong long begin = 0; // 区間開始位置\n\t\tlong long end = 0;   // 区間終了位置\n\t\tstd::string sub;     // 区間データ\n\t};\n\n\tstruct DS_NyaaRLE\n\t{\n\t\t/**\n\t\t@brief 文字列のランレングス圧縮\n\t\t@param s 圧縮する文字列\n\t\t@param res 圧縮結果\n\t\t**/\n\t\tstatic void Run(std::string& s, std::vector<RunLengthEncodingResult<std::string>>& res)\n\t\t{\n\t\t\tres.push_back({ 0, 0, \"\" });\n\t\t\tfor (long long i = 0; i < (long long)s.size(); i++)\n\t\t\t{\n\t\t\t\tif (i == (long long)s.size() - 1)\n\t\t\t\t{\n\t\t\t\t\tres.back().end = i + 1;\n\t\t\t\t\tres.back().sub = s.substr(res.back().begin, i + 1 - res.back().begin);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (s[i] != s[i + 1])\n\t\t\t\t{\n\t\t\t\t\tres.back().end = i + 1;\n\t\t\t\t\tres.back().sub = s.substr(res.back().begin, i + 1 - res.back().begin);\n\t\t\t\t\tres.push_back({ i + 1, 0, \"\" });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t@brief 配列のランレングス圧縮\n\t\t@param v 圧縮する配列\n\t\t@param res 圧縮結果\n\t\t**/\n\t\ttemplate <class T> static void Run(std::vector<T>& v, std::vector<RunLengthEncodingResult<T>>& res)\n\t\t{\n\t\t\tres.push_back({ 0, 0, std::vector<T>() });\n\t\t\tfor (long long i = 0; i < (long long)v.size(); i++)\n\t\t\t{\n\t\t\t\tif (i == (long long)v.size() - 1)\n\t\t\t\t{\n\t\t\t\t\tres.back().end = i + 1;\n\t\t\t\t\tfor (long long j = res.back().begin; j < i + 1; j++) res.back().sub.push_back(v[j]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!IsSame(v[i], v[i + 1]))\n\t\t\t\t{\n\t\t\t\t\tres.back().end = i + 1;\n\t\t\t\t\tfor (long long j = res.back().begin; j < i + 1; j++) res.back().sub.push_back(v[j]);\n\t\t\t\t\tres.push_back({ i + 1, 0, std::vector<T>() });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttemplate <class T> static bool IsSame(T& l, T& r)\n\t\t{\t// lとrが同値かどうか調べる\n\t\t\treturn l == r;\n\t\t}\n\t};\n}\n\n/**************************************/\n/*********** END OF NYA LIB ***********/\n/**************************************/\n\nusing namespace NyaGadget;\n//using mll = NT_ModLL< 1000000007 >;\n//using mll = NT_ModLL< 998244353 >;\n\nvoid NyaaDelete(vvt<ll>& grid, ll K, ll& res)\n{\n\tll count = 1;\n\tll W = Size(grid);\n\tll H = Size(grid[0]);\n\twhile (1)\n\t{\n\t\tll score = 0;\n\t\trep(y, 0, H)\n\t\t{\n\t\t\tvt<ll> test(W);\n\t\t\trep(x, 0, W) test[x] = grid[x][y];\n\t\t\tstd::vector<RunLengthEncodingResult<ll>> rleRes;\n\t\t\tDS_NyaaRLE::Run(test, rleRes);\n\n\t\t\teach(i, e, rleRes)\n\t\t\t{\n\t\t\t\tif (e.sub[0] == 0) continue;\n\t\t\t\tif (K <= Size(e.sub))\n\t\t\t\t{\n\t\t\t\t\trep(xx, e.begin, e.end) grid[xx][y] = 0;\n\t\t\t\t\tscore = Pow2(count) * e.sub[0] * Size(e.sub);\n\t\t\t\t\tres += score;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvvt<ll> test; MakeVVT(W, H, test);\n\t\trep(x, 0, W)\n\t\t{\n\t\t\tll yy = 0;\n\t\t\trep(y, 0, H) if (grid[x][y] != 0) test[x][yy++] = grid[x][y];\n\t\t}\n\t\tgrid = test;\n\t\tif (score == 0) return;\n\t\t++count;\n\t}\n}\n\nint main(void)\n{\n\tll H, W, K; cin >> H >> W >> K;\n\tvvt<ll> c; MakeVVT(W, H, c);\n\trepr(y, H - 1, -1)\n\t{\n\t\tstring test; cin >> test;\n\t\trep(x, 0, W) c[x][y] = CtoL(test[x]);\n\t}\n\n\tll ans = 0;\n\trep(x, 0, W) rep(y, 0, H)\n\t{\n\t\tvvt<ll> test = c;\n\t\trep(yy, y + 1, H) test[x][yy - 1] = test[x][yy];\n\t\ttest[x].back() = 0;\n\t\tll res = 0;\n\n\t\tNyaaDelete(test, K, res);\n\t\tans = max(ans, res);\n\t}\n\tcout << ans / 2 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint h,w,k;\nint c[35][35];\nint f[35][35];\n\nint do_vanish(){\n    int ret = 0;\n    int g[35][35]={};\n    for(int i=0; i<h; i++){\n        for(int j=0; j+(k-1)<w; j++){\n            bool flag = true;\n            if(f[i][j] == 0) break;\n            for(int l=1; l<=k-1; l++){\n                if(f[i][j] != f[i][j+l]) flag = false;\n            }\n            if(flag){\n                for(int l=0; l<=k-1; l++) g[i][j+l] = 1;\n            }\n        }\n    }\n    for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++){\n            if(g[i][j] == 1){\n                ret += f[i][j];\n                f[i][j] = 0;\n            }\n        }\n    }\n    return ret;\n}\n\nvoid do_clean(){\n    bool flag=true;\n    while(flag){\n        flag = false;\n        for(int i=0; i<h-1; i++){\n            for(int j=0; j<w; j++){\n                if(f[i][j] != 0 && f[i+1][j] ==0){\n                    f[i+1][j] = f[i][j];\n                    f[i][j] = 0;\n                    flag = true;\n                }\n            }\n        }\n    }\n    return;\n}\n\nint main(){\n    cin >> h >> w >> k;\n    for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++){\n            char z;\n            cin >> z;\n            c[i][j] = z - '0';\n            //cout << c[i][j] << endl;\n        }\n    }\n\n    long long max_ans = 0;\n    for(int ii=0; ii<h; ii++){\n        for(int jj=0; jj<w; jj++){\n            for(int i=0; i<h; i++) for(int j=0; j<w; j++) f[i][j] = c[i][j];\n            f[ii][jj]=0;\n            long long ans=0;\n            int pow=1;\n            while(true){\n                do_clean();\n                int x = do_vanish();\n                if(x == 0) break;\n                ans += pow*x;\n                pow *= 2;\n            }\n        max_ans = max(ans, max_ans);\n        }\n    }\n    \n    cout << max_ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define SIZE 30\nusing namespace std;\nint cal(int h, int w, int k, int *c){\n    int res = 0, pow = 1, num;\n    while(pow > 0){\n        for(int j=0;j<w;j++){\n            int g = h-1;\n            for(int i=h-1;i>=0;i--){\n                if(*(c+i*SIZE+j) > 0){\n                    if(i < g){\n                        *(c+g*SIZE+j) = *(c+i*SIZE+j);\n                        *(c+i*SIZE+j) = 0;\n                    }\n                    g--;\n                }\n            }\n        }\n        num = 0;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(*(c+i*SIZE+j) == 0)continue;\n                int p = j;\n                while(*(c+i*SIZE+p) == *(c+i*SIZE+j)){\n                    p++;\n                    if(p == w)break;////\n                }\n                if(p - j >= k){\n                    num += *(c+i*SIZE+j) * (p - j);\n                    while(j < p){\n                        *(c+i*SIZE+j) = 0;\n                        j++;\n                    }\n                    j--;\n                }\n            }\n        }\n        if(num == 0){\n            pow = 0;\n        }else{\n            res += num * pow;\n            pow *= 2;\n        }\n    }\n    return res;\n}\nvoid copy(int h, int w, int *res, int *ori){\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            *(res+i*SIZE+j) = *(ori+i*SIZE+j);\n        }\n    }\n}\nint main(void){\n    int h, w, k, ori[SIZE][SIZE], cpy[SIZE][SIZE], ans = 0;\n    cin >> h >> w >> k;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            char c;\n            cin >> c;\n            ori[i][j] = c - '0';\n        }\n    }\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            copy(h, w, &cpy[0][0], &ori[0][0]);\n            cpy[i][j] = 0;\n            ans = max(ans, cal(h, w, k, &cpy[0][0]));\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef DEBUG\n#define debug(x) cout << #x << \": \" << x << endl\n#else\n#define debug(x)\n#endif\n\n#define int ll\n\n#define REP(i, n) for(int i = 0; i < (n); i++)\n#define REPS(i, n) for(int i = 1; i <= (n); i++)\n#define ALL(v) (v).begin(), (v).end()\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n\nusing namespace std;\n\nusing ll = long long;\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vs = vector<string>;\nusing vb = vector<bool>;\n\nconst ll INF = 1e18;\nconst ll MOD = 1e9+7;\n\ntemplate<class T> inline bool chmax(T &a, const T &b) { if (a<b) { a = b; return true;} return false; }\ntemplate<class T> inline bool chmin(T &a, const T &b) { if (a>b) { a = b; return true;} return false; }\n\n\nsigned main()\n{\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n\n    int H, W, K; cin >> H >> W >> K;\n    vector<vl> block(H, vl(W)); \n    REP(i, H) \n    {\n        string s; cin >> s;\n        REP(j, W)\n        {\n            block[i][j] = s[j]-'0';\n        }\n    }\n\n\n    ll ans = 0;\n\n    REP(i, H)\n    {\n        REP(j, W)\n        {\n            ll score = 0, tmp = 0, turn = 0;\n            bool update = true;\n            vector<vl> x(block);\n            x[i][j] = -1;\n            // xを移動\n            REP(j, W)\n            {\n                int k = H-1;\n                while(k >= 0 && x[k][j] > 0) k--;\n                if(k > 0)\n                {\n                    for(int n = k-1; n >= 0; n--)\n                    {\n                        if(x[n][j] > 0)\n                        {\n                            swap(x[k][j], x[n][j]);\n                            k--;\n                        }\n                        if(k < 0) break;\n                    }\n                }\n            }\n            while(update)\n            {\n                tmp = 0;\n                if(turn != 0) update = false;\n                // xを消す\n                REP(i, H)\n                {\n                    ll count = 0, mc = 0, index = 0;\n                    REP(j, W)\n                    {\n                        if(j > 0 && x[i][j] != x[i][j-1]) count = 0;\n                        if(x[i][j] != -1) count++;\n                        if(chmax(mc, count)) index = j;\n                    }\n                    if(mc >= K)\n                    {\n                        update = true;\n                        tmp += mc * x[i][index];\n                        for(int j = index-mc+1; j <= index; j++)\n                        {\n                            x[i][j] = -1;\n                        }\n                    }\n                }\n\n                score += pow(2, turn) * tmp;\n\n                // xを移動\n                REP(j, W)\n                {\n                    int k = H-1;\n                    while(k >= 0 && x[k][j] > 0) k--;\n                    if(k > 0)\n                    {\n                        for(int n = k-1; n >= 0; n--)\n                        {\n                            if(x[n][j] > 0)\n                            {\n                                swap(x[k][j], x[n][j]);\n                                k--;\n                            }\n                            if(k < 0) break;\n                        }\n                    }\n                }\n                turn++;\n            }\n            chmax(ans, score);\n        }\n    }\n    cout << ans << endl;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e7\n#define mod 1000000007\n\nusing namespace std;\ntypedef long long int ll;\ntypedef tuple<int,int,int> tii;\ntypedef tuple<long long int,long long int,long long int> tll;\ntypedef tuple<double,double,double> tdd;\n\n\nint main()\n{\n    int H,W,K;\n    cin >> H >> W >> K;\n    vector<vector<int>>G(H,vector<int>(W));\n    for(int i = 0 ; i < H; i++) \n    {\n        string tmp; cin >> tmp;\n        for(int j = 0; j < W; j++)\n        {\n            G[i][j] = tmp[j] - '0';\n        }\n    }\n    int ans = 0;\n    for(int h = 0; h < H; h++)\n    {\n        for(int w = 0; w < W; w++)\n        {\n            vector<vector<int>>g = G;\n            g[h][w] = -1;\n            for(int i = h; i >= 1; i--) swap(g[i][w],g[i-1][w]);\n            int cnt = 0;\n            int point = 0;\n            while(1)\n            {\n                vector<deque<tii>>v(H);\n                for(int i = 0; i < H; i++)\n                {\n                    for(int j = 0; j < W; j++)\n                    {\n                        if(j == 0) v[i].push_back(make_tuple(g[i][j],0,0));\n                        else\n                        {\n                            auto p = v[i].back();\n                            if(get<0>(p) != g[i][j]) v[i].push_back(make_tuple(g[i][j],j,j));\n                            else \n                            {\n                                v[i].pop_back();\n                                v[i].push_back(make_tuple(g[i][j],get<1>(p),j));\n                            }\n                        }\n                    }\n                }\n                bool f = true;\n                for(int i = 0; i < H; i++)\n                {\n                    while(!v[i].empty())\n                    {\n                        auto p = v[i].front();\n                        v[i].pop_front();\n                        if(get<0>(p) == -1) continue;\n                        if(get<2>(p)-get<1>(p)+1 >= K) \n                        {\n                            f = false;\n                            point += pow(2,cnt)*get<0>(p)*(get<2>(p)-get<1>(p)+1);\n                            for(int j = get<1>(p); j <= get<2>(p); j++) g[i][j] = -1;\n                        }\n                    }\n                }\n                if(f) break;\n                vector<deque<int>>x(W);\n                for(int j = 0; j < W; j++)\n                {\n                    int num = 0;\n                    for(int i = H-1; i >= 0; i--)\n                    {\n                        if(g[i][j] == -1) \n                        {\n                            num++;\n                            continue;\n                        }\n                        x[j].push_back(g[i][j]);\n                    }\n                    for(int i = 1; i <= num; i++) x[j].push_back(-1);\n                }\n                for(int j = 0; j < W; j++)\n                {\n                    for(int i = H-1; i >= 0; i--)\n                    {\n                        g[i][j] = x[j].front();\n                        x[j].pop_front();\n                    }\n                }\n                cnt++;\n            }\n            ans = max(ans,point);\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <stack>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n\nusing namespace std;\ntypedef long long int ll;\n#define MAX_H 30\nint field[MAX_H][MAX_H];\nint initField[MAX_H][MAX_H];\n\nint howManySameColorRight(int i,int j,int W,int color){\n\tif( j >= W) return 0;\n\tif(field[i][j] == 0) return 0;\n\tif(color != field[i][j]) return 0;\n\tif(j== W-1 && color == field[i][j]) return 1;\n\treturn howManySameColorRight(i,j+1,W,color) + 1;\n}\n\nvoid banishRightN(int i,int j,int n){\n\tfor(int k = 0; k < n; k++){\n\t\tfield[i][j+k] = 0;\n\t}\n}\n\nvoid moveBlocks(int H,int W){\n\tfor(int i = 0; i < H - 1; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tif(field[i+1][j] == 0){\n\t\t\t\tfield[i+1][j] = field[i][j];\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid initializeField(int H,int W){\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tfield[i][j] = initField[i][j];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint H,W,K;\n\tcin>>H>>W>>K;\n\trep(i,H){\n\t\tstring str;\n\t\tcin>>str;\n\t\trep(j,W) initField[i][j] = str[j] - '0';\n\t}\n\tll ans = 0;\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t/*int i = 3;\n\tint j = 2;*/\n\t\t\tll localAns = 0;\n\t\t\tinitializeField(H,W);\n\t\t\tfield[i][j] = 0;\n\t\t\t//p th block banish\n\t\t\tfor(int p = 0; p < H + W; p++){\n\t\t\t\trep(q,H+W) moveBlocks(H,W);\n\t\t\t\t/*cout<<\"-----------------\"<<endl;\n\t\t\t\trep(a,H){\n\t\t\t\t\trep(b,W){\n\t\t\t\t\t\tcout<<field[a][b]<<\" \";\n\t\t\t\t\t}\n\t\t\t\t\tcout<<endl;\n\t\t\t\t}*/\n\t\t\t\tll banishBlocks = 0;\n\t\t\t\tfor(int k = 0; k < H; k++){\n\t\t\t\t\tfor(int l = 0; l < W; l++){\n\t\t\t\t\t\tint num = field[k][l];\n\t\t\t\t\t\tint blocks = howManySameColorRight(k,l,W,field[k][l]);\n\t\t\t\t\t\tif(blocks >= K){\n\t\t\t\t\t\t\tbanishRightN(k,l,blocks);\n\t\t\t\t\t\t\tbanishBlocks += blocks*num;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlocalAns += pow(2.0,p) * banishBlocks;\n\t\t\t\t//cout<<pow(2.0,p)*banishBlocks<<endl;\n\t\t\t}\n\t\t\tans = max(ans,localAns);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define ASC(vec) vec.begin(), vec.end()\t\t// 昇順ソート 例：sort(ASC(vec));\n#define DESC(vec) vec.rbegin(), vec.rend()\t// 降順ソート 例:sort(DESC(vec));\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define Rep(i, n) for(int i = 1; i < n; i++)\n\nconst int mod = 1000000007;\nconst int inf = (1 << 21);\nconst long long INF = 1LL << 60;\n\nusing ii = pair<int, int>;\nusing ll = long long;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vs = vector<string>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\nusing vvb = vector<vector<bool>>;\nusing vii = vector<pair<int, int>>;\n\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\n\nll GCD(ll a, ll b) { return b ? GCD(b, a % b) : a; }\nll LCM(ll a, ll b) { return (a * b) / GCD(a, b); }\nint round_int(int a, int b) { return (a + (b - 1)) / b; }\n\nconstexpr array<int, 9> dx = { 0, 1, 0, -1, -1, 1, 1, -1, 0 };\nconstexpr array<int, 9> dy = { 1, 0, -1, 0, 1, 1, -1, -1, 0 };\n\n// ──────────────────────────────────────────────────────────────────\n\nint h, w, K;\nvvi t(35, vi(35)), u(35, vi(35));\n\nint calc() {\n\tint res = 0;\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tif (u[i][j] == -1) continue;\n\t\t\t\n\t\t\tint k = j;\n\t\t\twhile (u[i][j] == u[i][k + 1] && k < w) k++;\n\n\t\t\tint num = k - j + 1;\n\t\t\tif (num < K) continue;\n\t\t\tres += u[i][j] * num;\n\t\t\tfor (int l = j; l <= k; ++l) u[i][l] = -1;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvoid drop() {\n\trep(k, w) {\n\t\tfor (int i = h - 2; i >= 0; --i) {\n\t\t\tint j = i;\n\t\t\tif (u[j + 1][k] != -1) continue;\n\t\t\twhile (u[j + 1][k] == -1 && j < h) j++;\n\t\t\tu[j][k] = u[i][k];\n\t\t\tu[i][k] = -1;\n\t\t}\n\t}\n}\n\nvi f(ll v) {\n\tvi res;\n\twhile (v) {\n\t\tres.push_back(v % 10);\n\t\tv /= 10;\n\t}\n\treverse(ASC(res));\n\treturn res;\n}\n\nvoid debug() {\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tcout << u[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tcin >> h >> w >> K;\n\trep(i, h) {\n\t\tll v;\n\t\tcin >> v;\n\n\t\tvi res = f(v);\n\t\trep(j, w) t[i][j] = res[j];\n\t}\n\n\tint ans = 0;\n\t/*\n\tu = t;\n\tu[3][2] = -1;\n\t//debug();\n\tint score = 0, k = 0;\n\twhile (true) {\n\t\tdrop();\n\t\t//debug();\n\t\tint s = calc();\n\t\tif (s == 0) break;\n\t\tscore += s * pow(2, k);\n\t\tk++;\n\t}\n\tchmax(ans, score);\n\tcout << ans << endl;\n\t*/\n\t\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tu = t;\n\t\t\tu[i][j] = -1;\n\t\t\t\n\t\t\tint score = 0, k = 0;\n\t\t\twhile (true) {\n\t\t\t\tdrop();\n\t\t\t\t//debug();\n\t\t\t\tint s = calc();\n\n\t\t\t\tif (s == 0) break;\n\t\t\t\tscore += s * pow(2, k);\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tchmax(ans, score);\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\ntypedef long long int ll;\n\nint h,w,k;\nchar fi[31][31];\nint cp[31][31];\nint epy[31][31];\n\nvoid fall(){\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tepy[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<w;i++){\n\t\tfor(int j=h-1;j>=0;j--){\n\t\t\tepy[j][i]=epy[j+1][i];\n\t\t\tif(cp[j][i]==0)epy[j][i]++;\n\t\t}\n\t\tfor(int j=h-1;j>=0;j--){\n\t\t\tif(cp[j][i]!=0&&epy[j][i]!=0){\n\t\t\t\tcp[j+epy[j][i]][i]=cp[j][i];\n\t\t\t\tcp[j][i]=0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint rensa(int p){\n\tbool ok=false;\n\tint res=0;\n\tfor(int i=0;i<h;i++){\n\t\tint cnt=0;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tint m=cp[i][j];\n\t\t\twhile(j<w&&m==cp[i][j]){\n\t\t\t\tj++;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tcout << cnt << endl;\n\t\t\tj--;\n\t\t\tif(cnt>=k){\n\t\t\t\tok=true;\n\t\t\t\tres+=cnt*m;\n\t\t\t\tfor(int u=0;u<cnt;u++){\n\t\t\t\t\tcp[i][j-u]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt=0;\n\t\t}\n\t}\n\tif(!ok||res==0)return res;\n\telse{\n\t\tfall();\n\t\treturn rensa(2*p)+res*p;\n\t}\n}\n\nint solve(int x,int y){\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcp[i][j]=(int)(fi[i][j]-'0');\n\t\t}\n\t}\n\tcp[x][y]=0;\n\tfall();\n\treturn rensa(1);\n}\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcin >> h >> w >> k;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin >> fi[i][j];\n\t\t}\n\t}\n\tint score=0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tscore=max(score,solve(i,j));\n\t\t}\n\t}\n\tcout << score << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// header {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define CPP_STR(x) CPP_STR_I(x)\n#define CPP_CAT(x,y) CPP_CAT_I(x,y)\n#define CPP_STR_I(args...) #args\n#define CPP_CAT_I(x,y) x ## y\n\n#define SFINAE(pred...) std::enable_if_t<(pred), std::nullptr_t> = nullptr\n\n#define ASSERT(expr...) assert((expr))\n\nusing i8  = int8_t;\nusing u8  = uint8_t;\nusing i16 = int16_t;\nusing u16 = uint16_t;\nusing i32 = int32_t;\nusing u32 = uint32_t;\nusing i64 = int64_t;\nusing u64 = uint64_t;\n\nusing f32 = float;\nusing f64 = double;\nusing f80 = __float80;\n// }}}\n\nconstexpr i64 INF  = INT64_C(1'010'000'000'000'000'017);\nconstexpr f64 FINF = 1e100;\n\nconstexpr i64 MOD = INT64_C(1'000'000'007);\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n// util {{{\n#define FOR(i, start, end) for(i64 i = (start), CPP_CAT(i,xxxx_end)=(end); i < CPP_CAT(i,xxxx_end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cccc) { return (f)(std::begin(cccc), std::end(cccc), ## __VA_ARGS__); })(c))\n\n#define LIFT(f) ([](auto&&... args) -> decltype(auto) { return (f)(std::forward<decltype(args)>(args)...); })\n\ntemplate<typename C>\nconstexpr i64 SIZE(const C& c) noexcept { return static_cast<i64>(c.size()); }\n\ntemplate<typename T, size_t N>\nconstexpr i64 SIZE(const T (&)[N]) noexcept { return static_cast<i64>(N); }\n\ntemplate<typename T, typename U, typename Comp=less<>>\nconstexpr bool chmax(T& xmax, const U& x, Comp comp={}) noexcept {\n    if(comp(xmax, x)) {\n        xmax = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T, typename U, typename Comp=less<>>\nconstexpr bool chmin(T& xmin, const U& x, Comp comp={}) noexcept {\n    if(comp(x, xmin)) {\n        xmin = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename BinaryFunc, typename UnaryFunc>\nauto ON(BinaryFunc&& bf, UnaryFunc&& uf) {\n    return [bf=forward<BinaryFunc>(bf),uf=forward<UnaryFunc>(uf)](const auto& x, const auto& y) {\n        return bf(uf(x), uf(y));\n    };\n}\n\ntemplate<typename F>\nauto LT_ON(F&& f) {\n    return ON(less<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto GT_ON(F&& f) {\n    return ON(greater<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto EQ_ON(F&& f) {\n    return ON(equal_to<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto NE_ON(F&& f) {\n    return ON(not_equal_to<>{}, forward<F>(f));\n}\n\n// tuple {{{\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) == I)>\nvoid tuple_enumerate(tuple<TS...>&, F&&) {}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) > I)>\nvoid tuple_enumerate(tuple<TS...>& t, F&& f) {\n    f(I, get<I>(t));\n    tuple_enumerate<I+1>(t, forward<F>(f));\n}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) == I)>\nvoid tuple_enumerate(const tuple<TS...>&, F&&) {}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) > I)>\nvoid tuple_enumerate(const tuple<TS...>& t, F&& f) {\n    f(I, get<I>(t));\n    tuple_enumerate<I+1>(t, forward<F>(f));\n}\n// }}}\n\n// container {{{\ntemplate<typename T> struct is_container : false_type {};\ntemplate<typename T, size_t N> struct is_container<array<T,N>> : true_type {};\ntemplate<typename... Args> struct is_container<vector<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<deque<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<list<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<forward_list<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<set<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<multiset<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_set<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_multiset<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<map<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<multimap<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_map<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_multimap<Args...>> : true_type {};\n\ntemplate<typename T, typename Enable=void>\nstruct ProconHash {\n    size_t operator()(const T& x) const noexcept {\n        return hash<T>{}(x);\n    }\n};\n\ntemplate<typename T>\nsize_t procon_hash_value(const T& x) noexcept {\n    return ProconHash<T>{}(x);\n}\n\nsize_t procon_hash_combine(size_t h1, size_t h2) noexcept {\n    constexpr size_t M = UINT64_C(0xc6a4a7935bd1e995);\n    constexpr int    R = 47;\n\n    h2 *= M;\n    h2 ^= h2 >> R;\n    h2 *= M;\n\n    h1 ^= h2;\n    h1 *= M;\n\n    h1 += 0xe6546b64;\n\n    return h1;\n}\n\ntemplate<typename T1, typename T2>\nstruct ProconHash<pair<T1,T2>> {\n    size_t operator()(const pair<T1,T2>& p) const noexcept {\n        size_t h1 = procon_hash_value(p.first);\n        size_t h2 = procon_hash_value(p.second);\n        return procon_hash_combine(h1, h2);\n    }\n};\n\ntemplate<typename... TS>\nstruct ProconHash<tuple<TS...>> {\n    size_t operator()(const tuple<TS...>& t) const noexcept {\n        size_t h = 0;\n        tuple_enumerate(t, [&h](const auto& e) {\n            h = procon_hash_combine(h, procon_hash_value(e));\n        });\n        return h;\n    }\n};\n\ntemplate<typename C>\nstruct ProconHash<C,enable_if_t<is_container<C>::value>> {\n    size_t operator()(const C& c) const noexcept {\n        size_t h = 0;\n        for(const auto& e : c)\n            h = procon_hash_combine(h, procon_hash_value(e));\n        return h;\n    }\n};\n\ntemplate<typename T, typename Hash=ProconHash<T>, typename Eq=equal_to<T>>\nusing HashSet = unordered_set<T,Hash,Eq>;\ntemplate<typename K, typename V, typename Hash=ProconHash<K>, typename Eq=equal_to<K>>\nusing HashMap = unordered_map<K,V,Hash,Eq>;\ntemplate<typename T, typename Hash=ProconHash<T>, typename Eq=equal_to<T>>\nusing HashMultiset = unordered_multiset<T,Hash,Eq>;\ntemplate<typename K, typename V, typename Hash=ProconHash<K>, typename Eq=equal_to<K>>\nusing HashMultimap = unordered_multimap<K,V,Hash,Eq>;\n\ntemplate<typename T>\nauto vec_make(i64 n, T x) {\n    return vector<T>(n, x);\n}\n\ntemplate<typename T, typename... Args, SFINAE(sizeof...(Args) >= 2)>\nauto vec_make(i64 n, Args... args) {\n    auto inner = vec_make<T>(args...);\n    return vector<decltype(inner)>(n, inner);\n}\n\ntemplate<typename T>\nauto vec_reserve(i64 cap) {\n    vector<T> res;\n    res.reserve(cap);\n    return res;\n}\n\ntemplate<typename T=i64>\nauto vec_iota(i64 n, T init={}) {\n    vector<i64> res(n);\n    ALL(iota, res, init);\n    return res;\n}\n\ntemplate<typename T, typename Comp, typename Cont=vector<T>>\nauto priority_queue_make(const Comp& comp, Cont&& cont={}) {\n    return priority_queue<T,remove_reference_t<Cont>,Comp>(comp, forward<Cont>(cont));\n}\n\ntemplate<typename T, typename Comp>\nauto priority_queue_reserve(const Comp& comp, i64 cap) {\n    return priority_queue<T,vector<T>,Comp>(comp, vec_reserve<T>(cap));\n}\n\ntemplate<typename T, size_t N, size_t... NS>\nstruct ArrayType {\n    using type = array<typename ArrayType<T,NS...>::type,N>;\n};\n\ntemplate<typename T, size_t N>\nstruct ArrayType<T,N> {\n    using type = array<T,N>;\n};\n\ntemplate<typename T, size_t... NS>\nusing Array = typename ArrayType<T,NS...>::type;\n\ntemplate<typename T, size_t N>\nT& array_at(Array<T,N>& ary, i64 i) {\n    return ary[i];\n}\n\ntemplate<typename T, size_t N, size_t... NS, typename... Args>\nT& array_at(Array<T,N,NS...>& ary, i64 i, Args... args) {\n    return array_at<T,NS...>(ary[i], args...);\n}\n\ntemplate<typename T, size_t N>\nconst T& array_at(const Array<T,N>& ary, i64 i) {\n    return ary[i];\n}\n\ntemplate<typename T, size_t N, size_t... NS, typename... Args>\nconst T& array_at(const Array<T,N,NS...>& ary, i64 i, Args... args) {\n    return array_at<T,NS...>(ary[i], args...);\n}\n\ntemplate<typename T, typename C>\nT POP(stack<T,C>& stk) {\n    T x = stk.top(); stk.pop();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(queue<T,C>& que) {\n    T x = que.front(); que.pop();\n    return x;\n}\n\ntemplate<typename T, typename C, typename Comp>\nT POP(priority_queue<T,C,Comp>& que) {\n    T x = que.top(); que.pop();\n    return x;\n}\n// }}}\n\n// fixpoint {{{\ntemplate<typename F>\nclass FixPoint {\npublic:\n    explicit constexpr FixPoint(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return f_(*this, forward<Args>(args)...);\n    }\n\nprivate:\n    F f_;\n};\n\ntemplate<typename F>\nconstexpr decltype(auto) FIX(F&& f) {\n    return FixPoint<F>(forward<F>(f));\n}\n\ntemplate<typename F, size_t... NS>\nclass FixPointMemo {\npublic:\n    explicit FixPointMemo(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    decltype(auto) operator()(Args... args) const {\n        using R = decltype(f_(*this,args...));\n        static Array<bool,NS...> done {};\n        static Array<R,NS...>    memo;\n\n        if(!array_at<bool,NS...>(done,args...)) {\n            array_at<R,NS...>(memo,args...) = f_(*this,args...);\n            array_at<bool,NS...>(done,args...) = true;\n        }\n        return array_at<R,NS...>(memo,args...);\n    }\n\nprivate:\n    F f_;\n};\n\ntemplate<size_t... NS, typename F>\ndecltype(auto) FIXMEMO(F&& f) {\n    return FixPointMemo<F,NS...>(forward<F>(f));\n}\n// }}}\n\n// string {{{\nauto str_reserve(i64 cap) {\n    string res;\n    res.reserve(cap);\n    return res;\n}\n// }}}\n\n// input {{{\ntemplate<typename T, typename Enable=void>\nstruct Scan {\n    static T scan(istream& in) {\n        T res;\n        in >> res;\n        return res;\n    }\n};\n\ntemplate<typename T, typename Enable=void>\nstruct Scan1;\n\ntemplate<typename T>\nstruct Scan1<T,enable_if_t<is_integral<T>::value && !is_same<T,bool>::value>> {\n    static T scan1(istream& in) {\n        return Scan<T>::scan(in) - 1;\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Scan<pair<T1,T2>> {\n    static pair<T1,T2> scan(istream& in) {\n        T1 x = Scan<T1>::scan(in);\n        T2 y = Scan<T2>::scan(in);\n        return {x,y};\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Scan1<pair<T1,T2>> {\n    static pair<T1,T2> scan1(istream& in) {\n        T1 x = Scan1<T1>::scan1(in);\n        T2 y = Scan1<T2>::scan1(in);\n        return {x,y};\n    }\n};\n\ntemplate<typename... TS>\nstruct Scan<tuple<TS...>> {\n    static tuple<TS...> scan(istream& in) {\n        return scan_impl<0>(in);\n    }\nprivate:\n    template<i64 I, SFINAE(sizeof...(TS) == I)>\n    static auto scan_impl(istream&) {\n        return make_tuple();\n    }\n    template<i64 I, SFINAE(sizeof...(TS) > I)>\n    static auto scan_impl(istream& in) {\n        using T = tuple_element_t<I,tuple<TS...>>;\n        auto head = make_tuple(Scan<T>::scan(in));\n        return tuple_cat(head, scan_impl<I+1>(in));\n    }\n};\n\ntemplate<typename... TS>\nstruct Scan1<tuple<TS...>> {\n    static tuple<TS...> scan1(istream& in) {\n        return scan1_impl<0>(in);\n    }\nprivate:\n    template<i64 I, SFINAE(sizeof...(TS) == I)>\n    static auto scan1_impl(istream&) {\n        return make_tuple();\n    }\n    template<i64 I, SFINAE(sizeof...(TS) > I)>\n    static auto scan1_impl(istream& in) {\n        using T = tuple_element_t<I,tuple<TS...>>;\n        auto head = make_tuple(Scan1<T>::scan1(in));\n        return tuple_cat(head, scan1_impl<I+1>(in));\n    }\n};\n\ntemplate<typename T=i64>\nT RD() {\n    return Scan<T>::scan(cin);\n}\n\ntemplate<typename T=i64>\nT RD1() {\n    return Scan1<T>::scan1(cin);\n}\n\ntemplate<typename T=i64>\nauto RD_VEC(i64 n) {\n    auto res = vec_reserve<T>(n);\n    REP(_, n) {\n        res.emplace_back(RD<T>());\n    }\n    return res;\n}\n\ntemplate<typename T=i64>\nauto RD1_VEC(i64 n) {\n    auto res = vec_reserve<T>(n);\n    REP(_, n) {\n        res.emplace_back(RD1<T>());\n    }\n    return res;\n}\n\ntemplate<typename T=i64>\nauto RD_VEC2(i64 h, i64 w) {\n    auto res = vec_reserve<vector<T>>(h);\n    REP(_, h) {\n        res.emplace_back(RD_VEC<T>(w));\n    }\n    return res;\n}\n\ntemplate<typename T=i64>\nauto RD1_VEC2(i64 h, i64 w) {\n    auto res = vec_reserve<vector<T>>(h);\n    REP(_, h) {\n        res.emplace_back(RD1_VEC<T>(w));\n    }\n    return res;\n}\n// }}}\n\n// output {{{\ntemplate<typename T, typename Enable=void>\nstruct Fmt {\n    static void fmt(ostream& out, const T& x) { out << x; }\n};\n\ntemplate<typename T>\nvoid fmt_write(ostream& out, const T& x) {\n    Fmt<T>::fmt(out, x);\n}\n\ntemplate<typename... TS>\nstruct Fmt<tuple<TS...>> {\n    static void fmt(ostream& out, const tuple<TS...>& t) {\n        tuple_enumerate(t, [&out](i64 i, const auto& e) {\n            if(i != 0) out << ' ';\n            fmt_write(out, e);\n        });\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Fmt<pair<T1,T2>> {\n    static void fmt(ostream& out, const pair<T1,T2>& p) {\n        return fmt_write(out, make_tuple(p.first,p.second));\n    }\n};\n\ntemplate<typename C>\nstruct Fmt<C,enable_if_t<is_container<C>::value>> {\n    static void fmt(ostream& out, const C& c) {\n        for(auto it = begin(c); it != end(c); ++it) {\n            if(it != begin(c)) out << ' ';\n            fmt_write(out, *it);\n        }\n    }\n};\n\nvoid PRINT() {}\n\ntemplate<typename T, typename... TS>\nvoid PRINT(const T& x, const TS&... args) {\n    fmt_write(cout, x);\n    if(sizeof...(args) > 0) {\n        cout << ' ';\n        PRINT(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid PRINTLN(const TS&... args) {\n    PRINT(args...);\n    cout << '\\n';\n}\n// }}}\n\n// debug {{{\ntemplate<typename T, typename Enable=void>\nstruct Dbg {\n    static void dbg(ostream& out, const T& x) { out << x; }\n};\n\ntemplate<typename T>\nvoid dbg_write(ostream& out, const T& x) {\n    return Dbg<T>::dbg(out, x);\n}\n\ntemplate<>\nstruct Dbg<i64> {\n    static void dbg(ostream& out, i64 x) {\n        if(x == INF)\n            out << \"INF\";\n        else if(x == -INF)\n            out << \"-INF\";\n        else\n            out << x;\n    }\n};\n\ntemplate<>\nstruct Dbg<f64> {\n    static void dbg(ostream& out, f64 x) {\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wfloat-equal\"\n        if(x == FINF)\n            out << \"FINF\";\n        else if(x == -FINF)\n            out << \"-FINF\";\n        else\n            out << x;\n#pragma GCC diagnostic pop\n    }\n};\n\ntemplate<typename T, size_t N>\nstruct Dbg<T[N]> {\n    static void dbg(ostream& out, const T (&ary)[N]) {\n        out << \"[\";\n        REP(i, N) {\n            if(i != 0) out << \",\";\n            dbg_write(out, ary[i]);\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename... TS>\nstruct Dbg<tuple<TS...>> {\n    static void dbg(ostream& out, const tuple<TS...>& t) {\n        out << \"(\";\n        tuple_enumerate(t, [&out](i64 i, const auto& e) {\n            if(i != 0) out << \",\";\n            dbg_write(out, e);\n        });\n        out << \")\";\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Dbg<pair<T1,T2>> {\n    static void dbg(ostream& out, const pair<T1,T2>& p) {\n        return dbg_write(out, make_tuple(p.first,p.second));\n    }\n};\n\ntemplate<typename C>\nstruct Dbg<C,enable_if_t<is_container<C>::value>> {\n    static void dbg(ostream& out, const C& c) {\n        out << \"[\";\n        for(auto it = begin(c); it != end(c); ++it) {\n            if(it != begin(c)) out << \",\";\n            dbg_write(out, *it);\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T, typename C>\nstruct Dbg<stack<T,C>> {\n    static void dbg(ostream& out, stack<T,C> stk) {\n        out << \"[\";\n        while(!stk.empty()) {\n            dbg_write(out,stk.top()); stk.pop();\n            if(!stk.empty()) out << \",\";\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T, typename C>\nstruct Dbg<queue<T,C>> {\n    static void dbg(ostream& out, queue<T,C> que) {\n        out << \"[\";\n        while(!que.empty()) {\n            dbg_write(out,que.front()); que.pop();\n            if(!que.empty()) out << \",\";\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T, typename C, typename Comp>\nstruct Dbg<priority_queue<T,C,Comp>> {\n    static void dbg(ostream& out, priority_queue<T,C,Comp> que) {\n        out << \"[\";\n        while(!que.empty()) {\n            dbg_write(out,que.top()); que.pop();\n            if(!que.empty()) out << \",\";\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T>\nvoid DBG_IMPL(i64 line, const char* expr, const T& value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    dbg_write(cerr, value);\n    cerr << \"\\n\";\n}\n\nvoid DBG_IMPL_HELPER() {}\n\ntemplate<typename T, typename... TS>\nvoid DBG_IMPL_HELPER(const T& x, const TS&... args) {\n    dbg_write(cerr, x);\n    if(sizeof...(args) > 0) {\n        cerr << \",\";\n        DBG_IMPL_HELPER(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid DBG_IMPL(i64 line, const char* expr, const TS&... value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << \"(\" << expr << \") = (\";\n    DBG_IMPL_HELPER(value...);\n    cerr << \")\\n\";\n}\n\ntemplate<size_t N, typename T, SFINAE(rank<T>::value == 0)>\nvoid DBG_DP_IMPL_HELPER(ostream& out, const T& x, const array<i64,N>&, const array<i64,N>&) {\n    dbg_write(out, x);\n}\n\ntemplate<size_t N, typename T, SFINAE(rank<T>::value > 0)>\nvoid DBG_DP_IMPL_HELPER(ostream& out, const T& x, const array<i64,N>& sizes, const array<i64,N>& offs) {\n    i64 k   = N - rank<T>::value;\n    i64 off = offs[k];\n    i64 siz = sizes[k];\n    if(siz == 0) siz = extent<T>::value - off;\n\n    out << \"[\";\n    FOR(i, off, off+siz) {\n        if(i != off) out << \",\";\n        DBG_DP_IMPL_HELPER(out, x[i], sizes, offs);\n    }\n    out << \"]\";\n}\n\ntemplate<typename T, SFINAE(rank<T>::value > 0)>\nvoid DBG_DP_IMPL(i64 line, const char* expr, const T& dp,\n                 const array<i64,rank<T>::value>& sizes={},\n                 const array<i64,rank<T>::value>& offs={})\n{\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    DBG_DP_IMPL_HELPER<rank<T>::value>(cerr, dp, sizes, offs);\n    cerr << \"\\n\";\n}\n\ntemplate<typename T>\nvoid DBG_GRID_IMPL(i64 line, const char* expr, const vector<T>& grid) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \":\\n\";\n    for(const auto& row : grid) {\n        dbg_write(cerr, row);\n        cerr << \"\\n\";\n    }\n    cerr << \"\\n\";\n}\n\n#ifdef PROCON_LOCAL\n    #define DBG(args...) DBG_IMPL(__LINE__, CPP_STR_I(args), args)\n    #define DBG_DP(args...) DBG_DP_IMPL(__LINE__, CPP_STR_I(args), args)\n    #define DBG_GRID(args...) DBG_GRID_IMPL(__LINE__, CPP_STR_I(args), args)\n#else\n    #define DBG(args...)\n    #define DBG_DP(args...)\n    #define DBG_GRID(args...)\n#endif\n// }}}\n\n// modint {{{\ntemplate<i64 M>\nstruct ModIntT {\n    static_assert(M >= 2, \"\");\n    i64 v_;  // [0,M)\n\n    ModIntT() : v_(0) {}\n    ModIntT(i64 v) {\n        i64 r = v % M;\n        v_ = r >= 0 ? r : r+M;\n    }\n\n    ModIntT operator-() const {\n        return ModIntT(-v_);\n    }\n    ModIntT& operator+=(ModIntT rhs) {\n        v_ += rhs.v_;\n        v_ %= M;\n        return *this;\n    }\n    ModIntT& operator-=(ModIntT rhs) {\n        v_ += M;\n        v_ -= rhs.v_;\n        v_ %= M;\n        return *this;\n    }\n    ModIntT& operator*=(ModIntT rhs) {\n        v_ *= rhs.v_;\n        v_ %= M;\n        return *this;\n    }\n\n    ModIntT& operator++() {\n        return *this += 1;\n    }\n    ModIntT& operator--() {\n        return *this -= 1;\n    }\n    ModIntT operator++(int) {\n        return exchange(*this, *this+1);\n    }\n    ModIntT operator--(int) {\n        return exchange(*this, *this-1);\n    }\n\n    explicit operator i64() const { return v_; }\n};\n\ntemplate<i64 M>\nModIntT<M> operator+(ModIntT<M> lhs, ModIntT<M> rhs) { return ModIntT<M>(lhs) += rhs; }\ntemplate<i64 M>\nModIntT<M> operator+(ModIntT<M> lhs, i64 rhs) { return ModIntT<M>(lhs) += rhs; }\ntemplate<i64 M>\nModIntT<M> operator+(i64 lhs, ModIntT<M> rhs) { return ModIntT<M>(rhs) += lhs; }\ntemplate<i64 M>\nModIntT<M> operator-(ModIntT<M> lhs, ModIntT<M> rhs) { return ModIntT<M>(lhs) -= rhs; }\ntemplate<i64 M>\nModIntT<M> operator-(ModIntT<M> lhs, i64 rhs) { return ModIntT<M>(lhs) -= rhs; }\ntemplate<i64 M>\nModIntT<M> operator-(i64 lhs, ModIntT<M> rhs) { return ModIntT<M>(rhs) -= lhs; }\ntemplate<i64 M>\nModIntT<M> operator*(ModIntT<M> lhs, ModIntT<M> rhs) { return ModIntT<M>(lhs) *= rhs; }\ntemplate<i64 M>\nModIntT<M> operator*(ModIntT<M> lhs, i64 rhs) { return ModIntT<M>(lhs) *= rhs; }\ntemplate<i64 M>\nModIntT<M> operator*(i64 lhs, ModIntT<M> rhs) { return ModIntT<M>(rhs) *= lhs; }\n\ntemplate<i64 M>\nbool operator==(ModIntT<M> lhs, ModIntT<M> rhs) { return lhs.v_ == rhs.v_; }\ntemplate<i64 M>\nbool operator==(ModIntT<M> lhs, i64 rhs) { return lhs == ModIntT<M>(rhs); }\ntemplate<i64 M>\nbool operator==(i64 lhs, ModIntT<M> rhs) { return ModIntT<M>(lhs) == rhs; }\ntemplate<i64 M>\nbool operator!=(ModIntT<M> lhs, ModIntT<M> rhs) { return !(lhs == rhs); }\ntemplate<i64 M>\nbool operator!=(ModIntT<M> lhs, i64 rhs) { return !(lhs == rhs); }\ntemplate<i64 M>\nbool operator!=(i64 lhs, ModIntT<M> rhs) { return !(lhs == rhs); }\n\ntemplate<i64 M>\nstruct Scan<ModIntT<M>> {\n    static ModIntT<M> scan(istream& in) {\n        return Scan<i64>::scan(in);\n    }\n};\n\ntemplate<i64 M>\nstruct Fmt<ModIntT<M>> {\n    static void fmt(ostream& out, ModIntT<M> x) {\n        fmt_write(out, x.v_);\n    }\n};\n\ntemplate<i64 M>\nstruct Dbg<ModIntT<M>> {\n    static void dbg(ostream& out, ModIntT<M> x) {\n        dbg_write(out, x.v_);\n    }\n};\n\nusing ModInt = ModIntT<MOD>;\n// }}}\n// }}}\n\n// init {{{\nstruct ProconInit {\n    static constexpr int IOS_PREC = 15;\n    static constexpr bool AUTOFLUSH = false;\n\n    ProconInit() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cin.exceptions(ios::failbit | ios::badbit);\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef PROCON_LOCAL\n        cerr << fixed << setprecision(IOS_PREC);\n#endif\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} PROCON_INIT;\n// }}}\n\n//--------------------------------------------------------------------\n\nvoid solve() {\n    i64 H = RD();\n    i64 W = RD();\n    i64 K = RD();\n    auto M = RD_VEC<string>(H);\n\n    auto fall = [H,W](vector<string>& grid) {\n        REP(x, W) {\n            auto v = vec_reserve<char>(H);\n            REP(y, H) {\n                char c = grid[y][x];\n                if(c == '0') continue;\n                v.emplace_back(c);\n            }\n            REP(y, H) {\n                grid[y][x] = '0';\n            }\n            REP(i, SIZE(v)) {\n                i64 y = H-SIZE(v)+i;\n                grid[y][x] = v[i];\n            }\n        }\n    };\n\n    auto erase = [W,K](vector<string>& grid, i64 m) -> i64 {\n        i64 sum = 0;\n        for(auto& row : grid) {\n            char pre = '*';\n            i64 len = 0;\n            REP(x, W) {\n                char c = row[x];\n                if(c != pre) {\n                    if(len >= K) {\n                        sum += len * (pre-'0');\n                        fill(begin(row)+x-len, begin(row)+x, '0');\n                    }\n                    pre = c;\n                    len = 1;\n                }\n                else {\n                    ++len;\n                }\n            }\n            if(len >= K) {\n                sum += len * (pre-'0');\n                fill(end(row)-len, end(row), '0');\n            }\n        }\n        return (1LL<<m) * sum;\n    };\n\n    i64 ans = 0;\n    REP(y, H) REP(x, W) {\n        auto grid(M);\n        grid[y][x] = '0';\n\n        i64 cur = 0;\n        for(i64 i = 0; ; ++i) {\n            fall(grid);\n            i64 score = erase(grid,i);\n            if(score == 0) break;\n            cur += score;\n        }\n        chmax(ans, cur);\n    }\n\n    PRINTLN(ans);\n}\n\nsigned main() {\n    \n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint H,W,K,c[40][40],A[40][40];\nlong long solve(){\n\tlong long sum=0;\n\tfor(int T=0;;T++){\n\t\tlong long tmp=0;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int l=0,r;l<W;l=r){\n\t\t\t\twhile(l<W&&!A[i][l])l++;\n\t\t\t\tfor(r=l;r<W&&A[i][l]==A[i][r];r++);\n\t\t\t\tif(r-l>=K){\n\t\t\t\t\tfor(int j=l;j<r;j++)tmp+=A[i][j],A[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsum+=tmp<<T-1;\n\t\tbool ok=1;\n\t\tfor(int j=0;j<W;j++){\n\t\t\tfor(int i=H-1,i2=H-1;i>=0;i--){\n\t\t\t\twhile(i2>=0&&!A[i2][j])i2--;\n\t\t\t\tif(i2>=0){\n\t\t\t\t\tif(i2<i)ok=0;\n\t\t\t\t\tA[i][j]=A[i2--][j];\n\t\t\t\t}\n\t\t\t\telse A[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tif(ok)return sum;\n\t}\n}\nchar str[110];\nint main(){\n\tscanf(\"%d%d%d\",&H,&W,&K);\n\tfor(int i=0;i<H;i++){\n\t\tscanf(\"%s\",str);\n\t\tfor(int j=0;j<W;j++)c[i][j]=str[j]-'0';\n\t}\n\tlong long ans=0;\n\tfor(int x=0;x<H;x++){\n\t\tfor(int y=0;y<W;y++){\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t\tfor(int j=0;j<W;j++)A[i][j]=i==x&&j==y?0:c[i][j];\n\t\t\tlong long tmp=solve();\n\t\t\tif(tmp>ans)ans=tmp;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\n#define IINF 10e8\n#define INF 1<<30\n#define MOD 1000000007\n#define mod 1000000007\n#define rep(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define Endl endl\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define siz(x) (ll)(x).size()\n#define PI acos(-1.0)\nusing namespace std;\n//using Int=int_fast64_t;\ntypedef long long int ll;\ntypedef long long int LL;\ntypedef pair<ll,ll>Pll;\ntypedef pair<int,int>Pin;\ntemplate<class T> using V=vector<T>;\nlong long GCD(long long a, long long b) { return b ? GCD(b, a%b) : a; }\nlong long LCM(long long a, long long b)  {return a/GCD(a,b)*b;}\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\nint ddx[8]={-1,0,1,0,1,1,-1,-1};\nint ddy[8]={0,-1,0,1,1,-1,1,-1};\nchar dir[4]={'u','l','d','r'};\nll cmp(pair<ll,ll>a,pair<ll,ll> b){\n        if(a.se!=b.se)\n        return a.se<b.se;\n        else\n        return a.fi<b.fi;\n}\n//---------------------------------------------------------------------------\n\n//---------------------------------------------------------------------------\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------\n    ll h,w,k;cin>>h>>w>>k;\n    ll a[30][30];\n    for(ll i=0;i<h;i++){\n        for(ll j=0;j<w;j++){\n            char c;cin>>c;\n            a[i][j]=c-'0';\n        }\n    }\n    ll ans=0;\n    for(ll i=0;i<h;i++){\n        for(ll j=0;j<w;j++){\n            ll b[30][30];\n            for(ll x=0;x<h;x++){\n                for(ll y=0;y<w;y++){\n                    b[x][y]=a[x][y];\n                }\n            }\n            queue<Pll>del;\n            del.push(mp(i,j));\n            ll cnt=0;\n            int turn=0;\n            map<Pll,ll>m;\n            \n            //cout<<1<<endl;\n            while(!del.empty()){\n                //delete\n                while(!del.empty()){\n                Pll p=del.front();del.pop();\n                m[p]++;\n                }\n            \n            //move\n            for(ll x=0;x<w;x++){\n                for(ll y=h-1;y>=0;y--){\n                    if(m[{y,x}]){\n                        bool xyz=0;\n                        for(ll z=y-1;z>=0;z--){\n                            if(m[{z,x}]==0){\n                                b[y][x]=b[z][x];\n                                m[{z,x}]=1;\n                                xyz=1;\n                                break;\n                            }\n                        }\n                        if(xyz==0)\n                            b[y][x]=-1;\n                    }\n                }\n            }\n                \n            \n            //push\n            int tmp=0;\n            for(ll x=0;x<h;x++){\n                for(ll y=0;y<w-k+1;y++){\n                    ll prey=y;\n                    if(b[x][y]==-1)continue;\n                    bool xyz=1;\n                    for(ll z=y+1;z<y+k;z++){\n                        if(b[x][z]!=b[x][z-1]){\n                            xyz=0;\n                            break;\n                        }\n                    }\n                    if(xyz==1){\n                        for(ll z=y;z<w;z++){\n                            if(b[x][z]==b[x][y]){\n                            del.push(mp(x,z));\n                            tmp+=b[x][z];\n                              \n                                prey=z+1;\n                            }\n                            else{\n                                break;\n                            }\n                        }\n                    }\n                    y=prey;\n                }\n            }\n   \n            //if(i==3&&j==2)cout<<tmp<<endl;\n            cnt+=pow(2,turn)*tmp;\n            turn++;\n            }\n            //cout<<cnt<<endl;\n            chmax(ans,cnt);\n        }\n    }\n\n    cout<<ans<<endl;\n    //-------------------------------\n    return 0;\n}\n//---------------------------------------------------------------------------\n/*\nint n;cin>>n;\nvector<int>a(n);\nfor(int i=0;i<n;i++)\n    cin>>a[i];\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[35][35];\nint main() {\n    int H, W, K; cin >> H >> W >> K;\n    int single=0, mn=10;\n    for(int i=0; i<H; ++i){\n        string S;\n        cin >> S;\n        for(int j=0; j<W; ++j){\n            C[i][j]=(S[j]-'0');\n            if(K==1){\n                single += C[i][j];\n                mn=min(mn, C[i][j]);\n            }\n        }\n    }\n    if(K==1){\n        cout << single-mn << endl;\n        return 0;\n    }\n    int ans=0;\n    for(int i=0; i<H*W; ++i){\n        int ban[35][35], now=0, mul=1;\n        for(int p=0; p<35; ++p) for(int q=0; q<35; ++q) ban[p][q]=C[p][q];\n        ban[i/W][i%W]=0;\n        bool flag=true;\n        while(flag){\n            int sum=0;\n            for(int j=0; j<W; ++j){\n                int cnt=H-1;\n                for(int k=H-1; k>=0; --k){\n                    if(ban[k][j]>0){\n                        ban[cnt][j]=ban[k][j];\n                        --cnt;\n                    }\n                }\n            }\n            flag=false;\n            for(int j=0; j<H; ++j){\n                for(int k=0; k<W; ++k){\n                    if(ban[j][k]>0){\n                        int ser=k;\n                        while(ban[j][ser]==ban[j][k]) ++ser;\n                        if(ser-k>=K){\n                            sum += ban[j][k]*(ser-k);\n                            flag=true;\n                            for(int v=k; v<ser; ++v) ban[j][v]=0;\n                        }\n                    }\n                }\n            }\n            now += sum*mul;\n            mul *= 2;\n        }\n        ans=max(ans, now);\n    }\n    cout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ macro.cpp -std=c++14\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\nconst ll LINF = 1e18;\nusing namespace std;\n\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\"  ) << endl\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\"  ) << endl\n\n#define SANKOU(n,a,b) cout << ((n) ? (#a) : (#b) ) << endl\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define REPR(i,n) for(int i=n;i>=0;i--)\n\n#define FOREACH(x,a) for(auto& (x) : (a) )\n\n#define WFA(d,v) REP(k,v)REP(i,v)REP(j,v)d[i][j]=min(d[i][j],d[i][k]+d[k][j])\n\n#define SCOUT(x) cout<<(x)<<\" \"\n#define ENDL cout<<endl\n\n#define VECCIN(x) for(auto&youso_: (x) )cin>>youso_\n#define VECIN2(x,y) REP(i,x.size())cin>>x[i]>>y[i]\n#define VECCOUT(x) for(auto&youso_: (x) )cout<<youso_<<\" \";cout<<endl\n\n#define ALL(obj) (obj).begin(),(obj).end()\n\n#define EXIST(n,x) (find(ALL(n),x)!=n.end())\n#define UNIQUE(obj) sort(ALL( obj )); obj.erase(unique(ALL(obj)),obj.end())\n#define COUT(x) cout<<(x)<<endl\nvoid CINT(){}\ntemplate <class Head,class... Tail>\nvoid CINT(Head&& head,Tail&&... tail){\ncin>>head;\nCINT(move(tail)...);\n}\n#define CIN(...) int __VA_ARGS__;CINT(__VA_ARGS__)\n#define SCIN(...) string __VA_ARGS__;CINT(__VA_ARGS__)\n\n// #include <boost/multiprecision/cpp_int.hpp>\n// using namespace boost::multiprecision; // cpp_int\n\n#define P pair<int,int>\n#define V vector<int>\n#define M map<int,int>\n#define S set<int>\n#define L list<int>\n\n#define pb(a) push_back(a)\n#define mp make_pair\n\nll h,w,k;\nll Solve(vector<V> vec,int count,int point){\n    bool wareta=false;\n    ll plusp=0;\n    REP(i,h){\n        bool flag=true;\n        int tttt=vec[i][0];\n        REP(j,w){\n            if(tttt!=vec[i][j]){flag=false;break;}\n        }\n        dump(flag);\n        if(!flag)continue;\n        plusp += pow(2,count) * tttt*w;\n        wareta=true;\n        REPR(x,i-1){\n            REP(j,w)vec[x+1][j]=vec[x][j];\n        }\n        break;\n    }\n    if(wareta)return Solve(vec,count+1,point+plusp); \n    else return point;\n}\n\nint main(){\n    \n    cin>>h>>w>>k;\n    vector<V> c(h,V(w));\n    REP(i,h){\n        SCIN(str);\n        REP(j,w){\n            c[i][j]=(int)str[j];\n        }\n    }\n\n    ll ans=0;\n    REP(i,h){\n        REP(j,w){\n           vector<V> ttt=c;\n           REPR(kkk,i-1)ttt[kkk+1][j]=ttt[kkk][j];\n           ans = max(ans,Solve(ttt,1,0));\n        }\n    }\n    COUT(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <limits>\n#include <iostream>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <iomanip>\n#include <functional>\n#include <complex>\n\nusing namespace std;\n\nusing ll=long long int;\nusing pii=pair<int,int>;\nusing pil=pair<int,ll>;\nusing pli=pair<ll,int>;\nusing pll=pair<ll,ll>;\nusing psi=pair<string,int>;\nusing pis=pair<int,string>;\nusing psl=pair<string,ll>;\nusing pls=pair<ll,string>;\nusing pss=pair<string,string>;\n\n//辺 fromあり\ntemplate<typename T >\nstruct Edge {\n  int from, to;\n  T cost;\n\n  Edge()=default;\n  Edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n\n  inline bool operator<(const Edge p)const noexcept{\n    return cost<p.cost;\n  }\n\n  inline bool operator>(const Edge p)const noexcept{\n    return cost>p.cost;\n  }\n\n};\n\n\n//辺 fromがない\ntemplate<typename T >\nstruct edge {\n  int to;\n  T cost;\n  edge()=default;\n  edge(int to, T cost) : to(to), cost(cost) {}\n};\ntemplate<typename T>\nusing edges=vector<edge<T>>;\ntemplate<typename T>\nusing WeightGraph=vector<edges<T>>;\n\nusing Graph=vector<vector<int>>;\n\n\n\ntemplate<typename T> using vc=vector<T>;\ntemplate<typename T> using vvc=vector<vector<T>>;\ntemplate<typename T> using vvvc=vector<vector<vector<T>>>;\ntemplate<typename T> using vvvvc=vector<vvvc<T>>;\ntemplate<typename T> using vvvvvc=vector<vvvvc<T>>;\n\ntemplate<class T,class U>inline constexpr bool chmin(T&a,const U b){if(a<=b)return false;a=b;return true;}\ntemplate<class T,class U>inline constexpr bool chmax(T&a,const U b){if(a>=b)return false;a=b;return true;}\n#define bit(n,k) ( (n>>k)&1 )\n\ninline void bin101(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr); \n    cout<<fixed<<setprecision(20);\n}\n\ntemplate<typename T>\ninline void Yes(T flag){\n    if(flag) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n}\n\ntemplate<typename T>\ninline void YES(T flag){\n    if(flag) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n}\n\n//1-indexed vector cin\ntemplate<typename T>\ninline void vin1(vector<T> &v){\n    for(int i=1;i<v.size();i++) cin>>v[i];\n}\n\n//0-indexed vector cin\ntemplate<typename T>\ninline void vin0(vector<T> &v){\n    for(int i=0;i<v.size();i++) cin>>v[i];\n}\n\n//1-indexed vector<vector> cin\ntemplate<typename T>\ninline void vin1(vector<vector<T>> &v){\n    for(int i=1;i<v.size();i++){\n        for(int j=1;j<v[i].size();j++) cin>>v[i][j];\n    }\n}\n\n//0-indexed vector<vector> cin\ntemplate<typename T>\ninline void vin0(vector<vector<T>> &v){\n    for(int i=0;i<v.size();i++){\n        for(int j=0;j<v[i].size();j++) cin>>v[i][j];\n    }\n}\n\n\n\n//デバッグ\ntemplate<typename T>\ninline void vout(const vector<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        cout<<i<<\" \"<<v[i]<<'\\n';\n    }\n    cout<<\"end\\n\"<<endl;\n}\n//デバッグ\ntemplate<typename T>\ninline void vout(const vvc<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        int ssz=v[i].size();\n        for(int j=0;j<ssz;j++){\n            cout<<i<<\" \"<<j<<\" \"<<v[i][j]<<'\\n';\n        }\n    }\n    cout<<\"\\nend\\n\"<<endl;\n}\n\n//デバッグ(グリッド)\ntemplate<typename T>\ninline void gvout(const vector<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        if(i) cout<<\" \";\n\t\tcout<<v[i];\n    }\n    cout<<\"\\nend\\n\"<<endl;\n}\n//デバッグ(グリッド)\ntemplate<typename T>\ninline void gvout(const vvc<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        int ssz=v[i].size();\n        for(int j=0;j<ssz;j++){\n\t\t\tif(j) cout<<\" \";\n            cout<<v[i][j];\n        }\n\t\tcout<<endl;\n    }\n    cout<<\"end\\n\"<<endl;\n}\n\n\n//デバッグ\ntemplate<typename T>\ninline void vout(const vvvc<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        int ssz=v[i].size();\n        for(int j=0;j<ssz;j++){\n            int sssz=v[i][j].size();\n            for(int k=0;k<sssz;k++){\n                cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<v[i][j][k]<<'\\n';\n            }\n        }\n    }\n    cout<<\"end\\n\"<<endl;\n}\n\n\n//pair cout\ntemplate<typename T, typename U>\ninline ostream &operator<<(ostream &os,const pair<T,U> &p) {\n  os<<p.first<<\" \"<<p.second;\n  return os;\n}\n\n//pair cin\ntemplate<typename T, typename U>\ninline istream &operator>>(istream &is,pair<T,U> &p) {\n  is>>p.first>>p.second;\n  return is;\n}\n\n//ソート\ntemplate<typename T>\ninline void vsort(vector<T> &v){\n    sort(v.begin(),v.end());\n}\n\n//逆順ソート\ntemplate<typename T>\ninline void rvsort(vector<T> &v){\n  sort(v.rbegin(),v.rend());\n}\n\n//要素数a 初期値x\ntemplate<typename T>\ninline vector<T> vmake(int a,T x){\n  return vector<T>(a,x);\n}\n\n//data[a][b] 初期値x\ntemplate<typename T>\ninline vector<vector<T>> vmake(int a,int b,T x){\n  return vector<vector<T>>(a, vector<T>(b,x));\n}\n\n//data[a][b][c] 初期値x\ntemplate<typename T>\ninline vector<vector<vector<T>>> vmake(int a,int b,int c,T x){\n  return vector<vector<vector<T>>> (a, vector<vector<T>>(b, vector<T>(c, x)));\n}\n\n//data[a][b][c][d]　初期値x\ntemplate<typename T>\ninline vector<vector<vector<vector<T>>>> vmake(int a,int b,int c,int d,T x){\n  return vector<vector<vector<vector<T>>>> (a,vvvc<T>(b,vvc<T>(c,vc<T>(d,x))));\n}\n\n//data[a][b][c][d][e] 初期値x\ntemplate<typename T>\ninline vvvvvc<T> vmake(int a,int b,int c,int d,int e,T x){\n  return vvvvvc<T> (a,vvvvc<T>(b,vvvc<T>(c,vvc<T>(d,vc<T>(e,x)))));\n}\n\n//1ビットの数を返す\ninline int popcount(int x){\n  return __builtin_popcount(x);\n}\n//1ビットの数を返す\ninline int popcount(ll x){\n  return __builtin_popcountll(x);\n}\n\n//queのfront() pop()\ntemplate<typename T>\ninline T pop(queue<T> &que){\n    assert(!que.empty());\n    T x=que.front();\n    que.pop();\n    return x;\n}\n\n//priority_que top() pop()\ntemplate<typename T>\ninline T pop(priority_queue<T> &que){\n  assert(!que.empty());\n  T x=que.top();\n  que.pop();\n  return x;\n}\n\n//stack top() pop()\ntemplate<typename T>\ninline T pop(stack<T> &st){\n  assert(!st.empty());\n  T x=st.top();\n  st.pop();\n  return x;\n}\n\n#define SZ(x) ( (int)x.size()  )\n#define pb push_back\n#define eb emplace_back\n\n/*\n満たすものの個数を返す\nmode:0 x未満\nmode:1 x以下の数\nmode:2 x以上の数\nmode:3 x超\nmode:4 x\n*/\ntemplate<typename T>\ninline int count_bound(vector<T> &v,T x,int mode){\n    switch(mode){\n        case 0:\n            return lower_bound(v.begin(),v.end(),x)-v.begin();\n        case 1:\n            return upper_bound(v.begin(),v.end(),x)-v.begin();\n        case 2:\n            return v.end()-lower_bound(v.begin(),v.end(),x);\n        case 3:\n            return v.end()-upper_bound(v.begin(),v.end(),x);\n        case 4:\n            return upper_bound(v.begin(),v.end(),x)-lower_bound(v.begin(),v.end(),x);\n    }\n}\n\n/*\nmode:0 xより小さい数で最大の数\nmode:1 x以下の数で最大の数\nmode:2 x以上の数で最小の数\nmode:3 xより大きい数で最小の数\n*/\ntemplate<typename T>\ninline T value_bound(vector<T> &v,T x,int mode){\n    switch(mode){\n        case 0:\n            return *(--lower_bound(v.begin(),v.end(),x));\n        case 1:\n            return *(--upper_bound(v.begin(),v.end(),x));\n        case 2:\n            return *lower_bound(v.begin(),v.end(),x);\n        case 3:\n            return *upper_bound(v.begin(),v.end(),x);\n    }\n}\n\n\n\nconstexpr int MAX=1<<30;\nconstexpr ll INF=1LL<<62;\nconstexpr ll MOD=1e9+7;\nconstexpr int dx[]={1,-1,0,0},dy[]={0,0,-1,1};\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n\nint main(){\n\tbin101();\n\n    int H,W,K;\n    cin>>H>>W>>K;\n    auto C=vmake(H,W,0);\n    auto D=vmake(H,W,0);\n    vector<int> v(100);\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            char c;\n            cin>>c;\n            D[i][j]=c-'0';\n        }\n    }\n    int ret=0;\n    int T=1;\n    for(int sh=0;sh<H;sh++){\n        for(int sw=0;sw<W;sw++,T=1){\n            C=D;\n            C[sh][sw]=0;\n            int height=sh;\n            int ans=0;\n            while(height>=1){\n                //落とす操作\n                int th=-1; //最大の高さ\n                for(int w=0;w<W;w++){\n                    int n=0;\n                    for(int h=height;h>=0;h--){\n\n                        if(C[h][w]) v[n++]=C[h][w];\n\n                    }\n\n                    for(int i=height;i>=0;i--){\n                        if(height-i+1>n){\n                            C[i][w]=0;\n                            continue;\n                        } \n                        if(C[i][w]==0) chmax(th,i);\n                        C[i][w]=v[height-i];\n                    }\n                }\n                height=th;\n                int s=0;\n                for(int i=0;i<=height;i++){\n                    int g=C[i][0];\n                    int pre=0;\n                    for(int j=1;j<W;j++){\n                        if(g==C[i][j] && j<W-1) continue;\n                        if(j==W-1 && g==C[i][j]) j++;\n                        if(j-pre>=K){\n                            s+=(j-pre)*g;\n                            for(int u=pre;u<=j-1;u++){\n                                C[i][u]=0;\n                            }\n                        }\n                        g=C[i][j];\n                        pre=j;\n                    }\n                }\n                ans+=T*s;\n                chmax(ret,ans);\n                T*=2;\n            }\n        }\n    }\n    cout<<ret<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair< ll, ll > Pi;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep2(i,n) for(int i=1;i<=(n);i++)\n#define rep3(i,i0,n) for(int i=i0;i<(n);i++)\n#define pb push_back\n#define mod 1000000007\nconst ll INF = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nll gcd(ll a, ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b) {return a/gcd(a,b)*b;}\n#define all(x) x.begin(), x.end()\n#define mp make_pair\nbool compare(Pi a, Pi b) {\n    if(a.first != b.first){\n        return a.first < b.first;\n        \n    }else{\n        return a.second < b.second;\n    }\n}\n\nint ctoi(char c) {\n\tif (c >= '0' && c <= '9') {\n\t\treturn c - '0';\n\t}\n\treturn 0;\n}\nbool In_map(ll y,ll x,ll h,ll w){\n    if(y<0 || x<0 || y>=h || x>=w){\n        return 0;\n    }else{\n        return 1;\n    }\n}\nconst vector<ll> dx{1,0,-1,0};\nconst vector<ll> dy{0,1,0,-1};\n\n\n\nint main() {\n\n    ll H,W,K;\n    cin >>H>>W>>K;\n    vector<string> S(H+1);\n    rep(i,H) cin >>S[i];\n    vector<vector<ll>> R(H+1,vector<ll>(W+1));\n    vector<vector<ll>> R2(H+1,vector<ll>(W+1));\n    rep(i,H) rep(j,W) R[i][j] = ctoi(S[i][j]);\n    R2 = R;\n    if(K<=1){\n        ll ans = 0;\n        ll min = INF;\n        rep(i,H){\n            rep(j,W){\n                chmin(min,R[i][j]);\n                ans+=R[i][j];\n            }\n        }\n        cout << ans-min<<endl;\n        return 0;\n    }\n\n\n    ll fans = 0;\n    rep(h,H) rep(w,W){\n    ll ans = 0;\n    R=R2;\n    R[h][w] = -1;\n    ll flag = 0;\n    rep(m,H){\n        ll p2 =pow(2,m); \n        rep(j,W){\n            vector<ll> tmp;\n            rep(i,H){\n                if(R[H-1-i][j] != -1){\n                    tmp.pb(R[H-1-i][j]);\n                }\n            }\n            rep(i,H){\n                if(i<tmp.size()){\n                    R[H-1-i][j] = tmp[i];\n                }else{\n                    R[H-1-i][j] = -1;\n                }\n            }\n        }\n        rep(i,H){\n            ll cnt=0;\n            ll p=-1;\n            rep(j,W){\n                if(R[i][j] == p && R[i][j] != -1){\n                    cnt++;\n                    if(j==W-1){\n                        if(cnt>=K){\n                            flag = 1;\n                            ans += R[i][j-1]*cnt*p2;\n                            rep(k,cnt){\n                               R[i][j-k] = -1;\n                            }\n                        }\n                    }\n                }else{\n                    if(cnt>=K){\n                        flag = 1;\n                        ans += R[i][j-1]*cnt*p2;\n                        rep(k,cnt){\n                            R[i][j-k-1] = -1;\n                        }\n                    }\n                    cnt = 1;\n                }\n                \n\n                p = R[i][j];\n            }\n        \n        \n        }\n\n        if(flag ==0) break;\n    }\n\n\n        chmax(fans,ans);\n    }\n\n    cout << fans<<endl;\n    \n    return 0;\n    \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\n\ntemplate<typename T> using V = std::vector<T>;\nusing Vi = V<int>;\nusing VVi = V<V<int>>;\nusing Vl = V<ll>;\nusing VVl = V<V<ll>>;\nusing Vs = V<string>;\n\ntemplate<typename T1, typename T2> using P = std::pair<T1, T2>;\nusing Pii = P<int, int>;\nusing Pll = P<ll, ll>;\nusing Pdd = P<double, double>;\n\ntemplate<typename T1, typename T2> using M = std::map<T1, T2>;\nusing Mii = M<int, int>;\nusing Msi = M<string, int>;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define REP2(i,s,e) for(int i=(int)(s);i<(int)(e);++i)\n#define RREP(i,s,e) for(int i=(int)(s);i>=(int)(e);--i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin(),ie=(c).end();i!=ie;++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst double PI = acos(-1);\nconst ll MOD = 1e9+7;\n\nint k, w, h;\n// string s;\nVs v;\n\nvoid fall() {\n    REP2(i, 1, h) REP(j, w) {\n        if (v[i][j] == 'x') {\n            RREP(x, i, 0) {\n                if (x != 0) v[x][j] = v[x-1][j];\n                else v[x][j] = 'x';\n            }\n        }\n    }\n}\n\nvoid print() {\n    REP(i, h) {\n        REP(j, w) std::cout << v[i][j]<< ' ';\n        std::cout << '\\n';\n    }\n    std::cout << \"/* message */\" << '\\n';\n}\n\nint calc() {\n    int score = 0, times = 0;\n    while (true) {\n        fall();\n        bool f = true;\n        REP(i, h) {\n            char x = v[i][0];\n            int cnt = 1;\n            REP2(j, 1, w) {\n                if (x == v[i][j]) cnt++;\n                else {\n                    if (x != 'x' && cnt >= k) {\n                        REP(t, cnt) v[i][j-t-1] = 'x';\n                        score += cnt * (x - '0') * pow(2, times);\n                        f = false;\n                    }\n                    x = v[i][j];\n                    cnt = 1;\n                }\n            }\n            if (x != 'x' && cnt >= k) {\n                REP(t, cnt) v[i][w-t-1] = 'x';\n                score += cnt * (x - '0') * pow(2, times);\n                f = false;\n            }\n        }\n        times++;\n        if (f) break;\n    }\n    return score;\n}\n\nint run(int y, int x) {\n    v[y][x] = 'x';\n    int score = calc();\n    return score;\n}\n\nint main() {\n    cin >> h >> w >> k;\n    v = Vs(h);\n    REP(i, h) cin >> v[i];\n\n    Vs v2(v);\n    int maxi = 0;\n    REP(i, h) REP(j, w) {\n        maxi = max(maxi, run(i, j));\n        v = v2;\n    }\n    std::cout << maxi << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair< ll, ll > Pi;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep2(i,n) for(int i=1;i<=(n);i++)\n#define rep3(i,i0,n) for(int i=i0;i<(n);i++)\n#define pb push_back\n#define mod 1000000007\nconst ll INF = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nll gcd(ll a, ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b) {return a/gcd(a,b)*b;}\n#define all(x) x.begin(), x.end()\n#define mp make_pair\nbool compare(Pi a, Pi b) {\n    if(a.first != b.first){\n        return a.first < b.first;\n        \n    }else{\n        return a.second < b.second;\n    }\n}\n\nint ctoi(char c) {\n\tif (c >= '0' && c <= '9') {\n\t\treturn c - '0';\n\t}\n\treturn 0;\n}\nbool In_map(ll y,ll x,ll h,ll w){\n    if(y<0 || x<0 || y>=h || x>=w){\n        return 0;\n    }else{\n        return 1;\n    }\n}\nconst vector<ll> dx{1,0,-1,0};\nconst vector<ll> dy{0,1,0,-1};\n\n\n\nint main() {\n\n    ll H,W,K;\n    cin >>H>>W>>K;\n    vector<string> S(H+1);\n    rep(i,H) cin >>S[i];\n    vector<vector<ll>> R(H+1,vector<ll>(W+1));\n    vector<vector<ll>> R2(H+1,vector<ll>(W+1));\n    rep(i,H) rep(j,W) R[i][j] = ctoi(S[i][j]);\n    R2 = R;\n    if(K<=1){\n        ll ans = 0;\n        ll min = INF;\n        rep(i,H){\n            rep(j,W){\n                chmin(min,R[i][j]);\n                ans+=R[i][j];\n            }\n        }\n        cout << ans-min<<endl;\n        return 0;\n    }\n\n\n    ll fans = 0;\n    rep(h,H) rep(w,H){\n    ll ans = 0;\n    R=R2;\n    R[h][w] = -1;\n    ll flag = 0;\n    rep(m,H){\n        ll p2 =pow(2,m); \n        /*rep(j,W){\n            vector<ll> tmp;\n            rep(i,H){\n                if(R[H-1-i][j] != -1){\n                    tmp.pb(R[H-1-i][j]);\n                }\n            }\n            rep(i,H){\n                if(i<tmp.size()){\n                    R[H-1-i][j] = tmp[i];\n                }else{\n                    R[H-1-i][j] = -1;\n                }\n            }\n        }*/\n        /*rep(i,H){\n            ll cnt=0;\n            ll p=-1;\n            rep(j,W){\n                if(R[i][j] == p && R[i][j] != -1){\n                    cnt++;\n                    if(j==W-1){\n                        if(cnt>=K){\n                            flag = 1;\n                            //ans += R[i][j-1]*cnt*p2;\n                            rep(k,cnt){\n                               // R[i][j-k] = -1;\n                            }\n                        }\n                    }\n                }else{\n                    if(cnt>=K){\n                        flag = 1;\n                        //ans += R[i][j-1]*cnt*p2;\n                        rep(k,cnt){\n                            //R[i][j-k-1] = -1;\n                        }\n                    }\n                    cnt = 1;\n                }\n                \n\n                p = R[i][j];\n            }\n        \n        \n        }*/\n\n        if(flag ==0) break;\n    }\n\n\n        chmax(fans,ans);\n    }\n\n    cout << fans<<endl;\n    \n    return 0;\n    \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, s, n) for(int i = s; i < n; i++)\n#define repr(i, n) for(int i = n-1; i >= 0; i--)\n#define repr2(i, s, n) for(int i = n-1; i >= s; i--)\nusing namespace std;\n\nint main(){\n  int h, w, k;\n  cin >> h >> w >> k;\n  vector<vector<int>> board(h, vector<int>(w));\n  vector<string> s(h);\n  rep(i, h) cin >> s[i];\n  int ans = 0;\n  rep(x, h)rep(y, w){\n    // 初期化\n    rep(i, h)rep(j, w) board[i][j] = s[i][j] - '0';\n    \n    // x行y列を消滅させる\n    repr2(i, 1, x+1) board[i][y] = board[i-1][y];\n    board[0][y] = 0;\n    \n    int score = 0;\n    int step = 0;\n    bool flag;\n    while(1){\n      flag = true;\n      // 消滅させる\n      rep(i, h){\n        int count;\n        int prev = -1;\n        int now;\n        rep(j, w){\n          now = board[i][j];\n          if (now == 0) count = 0;\n          else if (now != prev) count = 1;\n          else count++;\n          if (count == k){\n            flag = false; // 一回でも消滅したらもう一度判定する\n            score += pow(2, step) * now * k;\n            rep(l, k) board[i][j-l] = 0;\n          }\n          else if (count > k){\n            score += pow(2, step) * now;\n            board[i][j] = 0;\n          }\n          prev = now;\n        }\n      }\n      // 消滅しなかったら終わり\n      if (flag) break;\n\n      // 消滅した分、下に下げる\n      rep(l, h-1)repr2(i, l+1, h)rep(j, w){\n        if (board[i][j] == 0){\n          board[i][j] = board[i-1][j];\n          board[i-1][j] = 0;\n        }\n      }\n      step++;\n    }\n    ans = max(ans, score);\n  }\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst long long LINF=8931145141919364364,LMOD=998244353;\ninline long long mod(long long n,long long m){return(n%m+m)%m;}\n// const int dx[]={1,0,-1,0,1,1,-1,-1},dy[]={0,-1,0,1,1,-1,-1,1};\n\nint h,w,k;\nvector<int> board[30];\nvoid check(){\n    rep(i,h){\n        rep(j,w) cout<<board[j][i];\n        cout<<endl;\n    }\n}\nint search(){\n    int ret=0;\n    rep(i,h){\n        int pre=-1,cnt=0;\n        rep(j,w){\n            if(board[j][i]!=pre){\n                if(pre!=-1&&cnt>=k){\n                    ret+=pre*cnt;\n                    rep(d,cnt){\n                        board[j-1-d][i]=0;\n                    }\n                }\n                cnt=1,pre=board[j][i];\n            }else{\n                cnt++;\n            }\n        }\n        if(pre!=-1&&cnt>=k){\n            ret+=pre*cnt;\n            rep(d,cnt){\n                board[w-1-d][i]=0;\n            }\n        }\n    }\n    return ret;\n}\nvoid del(){\n    for(int i=h-1;i>=0;i--)rep(j,w){\n        if(board[j][i]==0){\n            board[j].erase(board[j].begin()+i);\n            board[j].push_back(-1);\n        }\n    }\n}\nint main(){\n    cin>>h>>w>>k;\n    rep(i,h)rep(j,w){\n        char c; cin>>c;\n        board[j].push_back(c-'0');\n    }\n    rep(i,w) reverse(all(board[i]));\n    // check();\n    long long ans=0;\n    rep(i,h)rep(j,w){\n        vector<int> save[30]=board;\n        board[j].erase(board[j].begin()+i);\n        board[j].push_back(-1);\n        // if(i==0&&j==2)check();\n        long long cnt=0,tmp=0;\n        while(1){\n            int x=search();\n            del();\n            if(x>0){\n                tmp+=pow(2,cnt)*x;\n                cnt++;\n            }\n            else break;\n        }\n        // cout<<tmp<<endl;\n        ans=max(ans,tmp);\n        // check(); cout<<endl;\n        rep(i,h)rep(j,w) board[i][j]=save[i][j];\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fs first\n#define sc second\n#define pb emplace_back\n#define mp make_pair\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n\nconst int32_t inf = 1001001001;\nconst int64_t infll = 1001001001001001001ll;\nconst int dx[] = {0, -1, 1, 0, -1, 1, -1, 1}, dy[] = {-1, 0, 0, 1, -1, -1, 1, 1};\n\ntemplate <typename T> using vector2d = vector<vector<T>>;\n\n// clang-format off\ntemplate <typename T> void sort(vector<T> &v) { sort(all(v)); }\n// ostream &operator<<(ostream &os, __int128_t value) { if (ostream::sentry(os)) { __uint128_t tmp = value < 0 ? -value : value; char buffer[64]; char *d = end(buffer); do { --d; *d = \"0123456789\"[tmp % 10]; tmp /= 10; } while (tmp != 0); if (value < 0) { --d; *d = '-'; } int len = end(buffer) - d; if (os.rdbuf()->sputn(d, len) != len) { os.setstate(ios_base::badbit); }} return os; }\n// istream &operator>>(istream &is, __int128_t &value) { string in; is >> in; value = 0; for (const char &c : in) { if ('0' <= c && c <= '9') value = 10 * value + (c - '0'); } if (in[0] == '-') value *= -1; return is; }\n// ostream &operator<<(ostream &os, __uint128_t value) { if (ostream::sentry(os)) { char buffer[64]; char *d = end(buffer); do { --d; *d = \"0123456789\"[value % 10]; value /= 10; } while (value != 0); int len = end(buffer) - d; if (os.rdbuf()->sputn(d, len) != len) { os.setstate(ios_base::badbit); }} return os; }\n// istream &operator>>(istream &is, __uint128_t &value) { string in; is >> in; value = 0; for (const char &c : in) { if ('0' <= c && c <= '9') value = 10 * value + (c - '0'); } return is; }\ntemplate <typename T> ostream &operator<<(ostream &os, vector<T> &v) { os << v[0]; for (int i = 1; i < v.size(); ++i) os << \" \" << v[i]; return os; }\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &in : v) is >> in; return is; }\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p) { os << p.fs << \" \" << p.sc; return os; }\ntemplate <typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.fs >> p.sc; return is; }\n\nstruct IoSetup { IoSetup(){ cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10); cerr << fixed << setprecision(10); } } iosetup;\n\ninline int64_t in() { int64_t x = 0; cin >> x; return x; }\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n// clang-format on\n\nsigned main(int argc, char *argv[]) {\n  int h = in(), w = in(), k = in();\n  vector2d<int> c(h, vector<int>(w));\n  for (int i = h - 1; i >= 0; --i) {\n    for (int j = 0; j < w; ++j) {\n      scanf(\"%1d\", &c[i][j]);\n    }\n  }\n\n  int64_t ans = 0;\n  // kimeuchi\n  for (int y = 0; y < h; ++y) {\n    for (int x = 0; x < w; ++x) {\n      int score = 0;\n      vector2d<int> C = c;\n      C[y][x] = -1;\n\n      // cerr << \"begin (\" << x << \", \" << y << \")\" << endl;\n      for (int co = 1;; co *= 2) {\n\n        // fall\n        // cerr << \"fall start\" << endl;\n        // for (int i = h - 1; i >= 0; --i) {\n        //   for (int j = 0; j < w; ++j) {\n        //     printf(\"%2d \", C[i][j]);\n        //   }\n        //   puts(\"\");\n        // }\n        // puts(\"\");\n        for (int j = 0; j < w; ++j) {\n          int now = 0;\n          for (int i = 0; i < h; ++i) {\n            if (C[i][j] != -1) {\n              C[now][j] = C[i][j];\n              now++;\n            }\n          }\n          for (int i = now; i < h; ++i) {\n            C[i][j] = -1;\n          }\n        }\n        // cerr << \"fall end\" << endl;\n        //\n        // for (int i = h - 1; i >= 0; --i) {\n        //   for (int j = 0; j < w; ++j) {\n        //     printf(\"%2d \", C[i][j]);\n        //   }\n        //   puts(\"\");\n        // }\n        // puts(\"\");\n\n        // erase\n        // cerr << \"erase start\" << endl;\n        int sum = 0;\n        for (int i = 0; i < h; ++i) {\n          for (int j = 0; j < w; ++j) {\n            if (C[i][j] == -1) continue;\n\n            int cnt = 0;\n            for (int l = j; l < w; ++l) {\n              if (C[i][j] != C[i][l]) break;\n              cnt++;\n            }\n\n            if (cnt >= k) {\n              for (int l = 0; l < cnt; ++l) {\n                sum += C[i][l + j];\n                C[i][l + j] = -1;\n              }\n            }\n          }\n        }\n\n        // cerr << \"erase end\" << endl;\n        //\n        // cerr << \"sum = \" << sum << endl;\n        // for (int i = h - 1; i >= 0; --i) {\n        //   for (int j = 0; j < w; ++j) {\n        //     printf(\"%2d \", C[i][j]);\n        //   }\n        //   puts(\"\");\n        // }\n        // puts(\"\");\n\n        score += co * sum;\n        if (sum == 0) break;\n      }\n\n      // printf(\"(%d, %d) = %d\\n\", x, y, score);\n      chmax(ans, score);\n    }\n  }\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define FOR(i, m, n) for(int i=(m); i<(n); ++i)\n#define rrep(i, n) for(int i=(n)-1; i>=0; --i)\n#define rfor(i, m, n) for(int i=(m); i>=(n); --i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing LL = long long;\t\tusing ld = long double;\nusing VB = vector<bool>;\tusing VVB = vector<VB>;\nusing VI = vector<int>;\t\tusing VVI = vector<VI>;\nusing VL = vector<LL>;\t\tusing VVL = vector<VL>;\nusing VS = vector<string>;\tusing VD = vector<double>;\nusing PII = pair<int, int>;\tusing VP = vector<PII>;\nusing PLL = pair<LL, LL>;\tusing VPL = vector<PLL>;\ntemplate<class T>using Grid = vector<vector<T>>;\ntemplate<class T>using PQ = priority_queue<T>;\ntemplate<class T>using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = (int)1e9;\nconstexpr LL inf_ll = (LL)1e18, MOD = 1000000007;\nconstexpr ld PI = M_PI, EPS = 1e-12;\n\ntemplate<class T>inline void Sort(T& a)noexcept { sort(all(a)); }\ntemplate<class T>inline void RSort(T& a)noexcept { sort(rall(a)); }\ntemplate<class T>inline void Reverse(T& a)noexcept { reverse(all(a)); }\ntemplate<class T>inline void Unique(T& a)noexcept { a.erase(unique(all(a)), a.end()); }\ntemplate<class T>inline T Sorted(T a)noexcept { Sort(a); return a; }\ntemplate<class T>inline T RSorted(T a)noexcept { RSort(a); return a; }\ntemplate<class T>inline T Reversed(T a)noexcept { Reverse(a); return a; }\ntemplate<class T>inline T Uniqued(T a)noexcept { Unique(a); return a; }\ntemplate<class T>inline auto Max(const T& a)noexcept { return *max_element(all(a)); }\ntemplate<class T>inline auto Min(const T& a)noexcept { return *min_element(all(a)); }\ntemplate<class T>inline int MaxPos(const T& a)noexcept { return max_element(all(a)) - a.begin(); }\ntemplate<class T>inline int MinPos(const T& a)noexcept { return min_element(all(a)) - a.begin(); }\ntemplate<class T, class U>inline int Count(const T& a, const  U& v)noexcept { return count(all(a), v); }\ntemplate<class T, class U>inline int Find(const T& a, const U& v)noexcept { auto pos = find(all(a), v); return pos == a.end() ? -1 : pos - a.begin(); }\ntemplate<class T, class U>inline U Sum(const T& a, const U& v)noexcept { return accumulate(all(a), v); }\ntemplate<class T, class U>inline int Lower(const T& a, const U& v)noexcept { return lower_bound(all(a), v) - a.begin(); }\ntemplate<class T, class U>inline int Upper(const T& a, const U& v)noexcept { return upper_bound(all(a), v) - a.begin(); }\ntemplate<class T, class P>inline void RemoveIf(T& a, P f)noexcept { a.erase(remove_if(all(a), f), a.end()); }\ntemplate<class T>inline T Age(T n, T m)noexcept { return (n + m - 1) / m; }\ntemplate<class T>inline T Age2(T n, T m)noexcept { return Age(n, m) * m; }\ntemplate<class T>inline T Tri(T n)noexcept { return (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); }\ntemplate<class T = long long>inline T BIT(int b)noexcept { return T{ 1 } << b; }\ntemplate<class T>inline T Gcd(T n, T m)noexcept { return m ? Gcd(m, n % m) : n; }\ntemplate<class T>inline T Lcm(T n, T m)noexcept { return n / Gcd(n, m) * m; }\ntemplate<class T>inline T Pow(T a, T n)noexcept { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; }return r; }\ntemplate<class T>inline T Powmod(T a, T n, T m = MOD)noexcept { T r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r; }\ntemplate<class T>inline bool chmax(T& a, const T& b)noexcept { if (a < b) { a = b; return true; } return false; }\ntemplate<class T>inline bool chmin(T& a, const T& b)noexcept { if (a > b) { a = b; return true; } return false; }\ntemplate<class T>inline bool inRange(const T& v, const T& min, const T& max)noexcept { return min <= v && v <= max; }\ninline string operator*(string s, int n)noexcept { string ret; rep(i, n)ret += s; return ret; }\n\n// --- input --- //\n#if defined(_WIN32) || defined(ONLINE_JUDGE)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\ninline int gc()noexcept { return getchar_unlocked(); }\ntemplate<class T>inline void InputF(T& v)noexcept { cin >> v; }\ninline void InputF(char& v)noexcept { while (isspace(v = gc())); }\ninline void InputF(string& v)noexcept {\n\tchar c; for (InputF(c); !isspace(c); c = gc())v += c;\n}\ninline void InputF(int& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(long long& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (LL)(c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(double& v)noexcept {\n\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ntemplate<class T, class U>inline void InputF(pair<T, U>& v)noexcept {\n\tInputF(v.first); InputF(v.second);\n}\ntemplate<class T>inline void InputF(vector<T>& v)noexcept {\n\tfor (auto& e : v)InputF(e);\n}\ntemplate<class T>inline T input() { T v; InputF(v); return v; }\nstruct InputV {\n\tint n, m;\n\tInputV(int N) :n(N), m(0) {}\n\tInputV(pair<int, int> N) :n(N.first), m(N.second) {}\n\ttemplate<class T>operator vector<T>()noexcept {\n\t\tvector<T> v(n); InputF(v); return v;\n\t}\n\ttemplate<class T>operator vector<vector<T>>()noexcept {\n\t\tvector<vector<T>> v(n, vector<T>(m)); InputF(v); return v;\n\t}\n};\nstruct Input {\n\ttemplate<class T>operator T()noexcept { return input<T>(); }\n\tint operator--(int) { int v; InputF(v); v--; return v; }\n\tInputV operator[](int n)noexcept { return InputV(n); }\n\tInputV operator[](pair<int, int> n)noexcept { return InputV(n); }\n\tvoid operator()() {}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tInputF(h); operator()(forward<T>(t)...);\n\t}\n\ttemplate<class T, size_t W>array<vector<T>, W> get(int H) {\n\t\tarray<vector<T>, W> ret;\n\t\trep(i, H)rep(j, W) { T x = *this; ret[j].push_back(x); }\n\t\treturn ret;\n\t}\n}in;\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc }; bool isPrint = true;\n\tvoid p(double v) { printf(\"%.20f\", v); } void p(long double v) { printf(\"%.20Lf\", v); }\n\tvoid p(int v) { printf(\"%d\", v); }\tvoid p(LL v) { printf(\"%lld\", v); }\n\tvoid p(char v) { putchar(v); }\t\tvoid p(bool v) { printf(\"%s\", v ? B.t : B.f); }\n\ttemplate<class T>void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) { p(v.first); printf(\"%s\", D.d); p(v.second); }\n\ttemplate<class T>void p(const vector<T>& v) { rep(i, sz(v)) { if (i)printf(\"%s\", D.d); p(v[i]); } }\n\ttemplate<class T>void p(const vector<vector<T>>& v) { rep(i, sz(v)) { if (i)printf(\"%s\", D.l); p(v[i]); } }\n\tvoid p(const BoolStr& v) { B = v; isPrint = false; } void p(const DivStr& v) { D = v; isPrint = false; }\npublic:\n\tvoid operator()() { printf(\"%s\", D.l); }\n\ttemplate<class H>void operator()(H&& h) {\n\t\tp(h); if (isPrint)printf(\"%s\", D.l); isPrint = true;\n\t}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tp(h); if (isPrint)printf(\"%s\", D.d); isPrint = true; operator()(forward<T>(t)...);\n\t}\n\ttemplate<class...T>void exit(T&& ...t) {\n\t\toperator()(forward<T>(t)...); std::exit(EXIT_SUCCESS);\n\t}\n}out;\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) (void(0))\n#endif\n\n// ---------------------------------------------------------------- //\n\ntemplate<class T>vector<pair<int, T>> RLE(const vector<T>& a) {\n\tint n = a.size();\n\tvector<pair<int, T>> ret;\n\tfor (int i = 0; i < n;) {\n\t\tT e = a[i]; int cnt = 0;\n\t\tfor (; i < n && a[i] == e; i++)cnt++;\n\t\tret.emplace_back(cnt, e);\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint h = in, w = in, k = in;\n\tVS s = in[h];\n\tVVI A(h, VI(w));\n\trep(i, h)rep(j, w)A[i][j] = s[i][j] - '0';\n\n\tauto fall = [&](VVI& a, int y, int x) {\n\t\trrep(i, y) {\n\t\t\ta[i + 1][x] = a[i][x];\n\t\t}\n\t\ta[0][x] = 0;\n\t};\n\n\tauto update = [&](VVI& a) {\n\t\tint sum = 0;\n\t\tVVB flag(h, VB(w));\n\t\trep(i, h) {\n\t\t\tauto E = RLE(a[i]);\n\t\t\tint l = 0;\n\t\t\tfor (auto e : E) {\n\t\t\t\tif (e.second && e.first >= k) {\n\t\t\t\t\tsum += e.first * e.second;\n\t\t\t\t\tfill(range_it(flag[i], l, l + e.first), true);\n\t\t\t\t}\n\t\t\t\tl += e.first;\n\t\t\t}\n\t\t}\n\n\t\tVVI b(h, VI(w));\n\t\trep(j, w) {\n\t\t\tint i = h - 1;\n\t\t\trrep(k2, h)if (!flag[k2][j]) {\n\t\t\t\tb[i--][j] = a[k2][j];\n\t\t\t}\n\t\t}\n\t\ta = b;\n\t\treturn sum;\n\t};\n\n\tauto test = [&](int i, int j) {\n\t\tint res = 0;\n\t\tVVI a = A;\n\t\tfall(a, i, j);\n\t\tfor (int cnt = 0, sum = update(a); sum; sum = update(a), cnt++) {\n\t\t\tres += sum * Pow(2, cnt);\n\t\t}\n\t\treturn res;\n\t};\n\n\tint ans = 0;\n\trep(i, h)rep(j, w) {\n\t\tchmax(ans, test(i, j));\n\t}\n\tout(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(ll i=0;i<n;i++)\n#define MOD 1000000007\n#define EPS (1e-10)\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nvector<int>v[40], u[40];\nint main() {\n\tll h, w, K; scanf(\"%lld%lld%lld\", &h, &w, &K);\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tint d; scanf(\"%1d\", &d);\n\t\t\tv[j].push_back(d);\n\t\t}\n\t}\n\trep(j, w)reverse(v[j].begin(), v[j].end());\n\tll Max = 0;\n\trep(i, h)rep(j, w) {\n\t\trep(k, w)u[k] = v[k];\n\t\tll sum = 0;\n\t\tu[j].erase(u[j].begin() + i);\n\t\tll cnt = 0;\n\t\tbool update = true;\n\t\twhile (update) {\n\t\t\tupdate = false;\n\t\t\trep(k, h) {\n\t\t\t\tll t, C = 0, back, s = 0;\n\t\t\t\tfor (; u[s].size() <= k&&s < w; s++);\n\t\t\t\tif (s == w)continue;\n\t\t\t\tback = u[s][k];\n\t\t\t\tt = s;\n\t\t\t\twhile (t < w) {\n\t\t\t\t\tif (u[t].size() > k&&back == u[t][k]) { C++; t++; }\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (C >= K) {\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t\tfor (ll y = s; y < t; y++) {\n\t\t\t\t\t\t\t\tsum += (ll)pow(2, cnt)*u[y][k];\n\t\t\t\t\t\t\t\tu[y][k] = -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts = t; C = 0;\n\t\t\t\t\t\tfor (; u[s].size() <= k&&s < w; s++);\n\t\t\t\t\t\tif (s != w)back = u[s][k];\n\t\t\t\t\t\tt = s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (C >= K) {\n\t\t\t\t\tupdate = true;\n\t\t\t\t\tfor (ll y = s; y < t; y++) {\n\t\t\t\t\t\tsum += (ll)pow(2, cnt)*u[y][k];\n\t\t\t\t\t\tu[y][k] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(k, h)rep(t, u[k].size()) {\n\t\t\t\tif (u[k][t] == -1) {\n\t\t\t\t\tu[k].erase(u[k].begin() + t); t--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t\tMax = max(Max, sum);\n\t}\n\tprintf(\"%lld\\n\", Max);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint H, W, K;\nbool fail(VVI& tab){\n  bool res = false;\n  for(int x=0;x<W;++x){\n\tfor(int y=H-1;y>=0;--y){\n\t  if(tab[y][x] == 0){\n\t\tint ty;\n\t\tfor(ty=y-1;ty>=0;--ty)\n\t\t  if(tab[ty][x])\n\t\t\tbreak;\n\t\tif(ty >= 0){\n\t\t  swap(tab[y][x], tab[ty][x]);\n\t\t  res = true;\n\t\t}\n\t  }\n\t}\n  }\n  return res;\n}\n\nint disapp(VVI& tab){\n  int res = 0;\n  REP(y,H){\n\tint prv = -1, n = 0;\n\tREP(x,W){\n\t  if(tab[y][x] != prv){\n\t\tif(n >= K && prv != 0){\n\t\t  for(int tx=x-1;tx>=0;--tx){\n\t\t\tif(tab[y][tx] != prv) break;\n\t\t\tres += prv;\n\t\t\ttab[y][tx] = 0;\n\t\t  }\n\t\t}\n\t\tprv = tab[y][x];\n\t\tn = 1;\n\t  }\n\t  else\n\t\t++n;\n\t}\n\tif(n >= K && prv != 0){\n\t  for(int tx=W-1;tx>=0;--tx){\n\t\tif(tab[y][tx] != prv) break;\n\t\tres += prv;\n\t\ttab[y][tx] = 0;\n\t  }\n\t}\n  }\n  return res;\n}\n\nint calc(int x, int y, VVI tab){\n  int res = 0;\n  tab[y][x] = 0;\n  for(int i=0;fail(tab);++i){\n\tres += disapp(tab) * (1<<i);\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> H >> W >> K;\n  VVI xs(H, VI(W));\n  REP(y,H){\n\tstring s; cin >> s;\n\tREP(x,W)\n\t  xs[y][x] = s[x] - '0';\n  }\n\n  int ans = -1;\n  REP(y,H) REP(x,W){\n\tans = max(ans, calc(x,y,xs));\n  }\n  cout << ans << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include <prettyprint.hpp>\n#define debug(...)  cerr << \"[\" << #__VA_ARGS__ << \"]: \", d_err(__VA_ARGS__);\n#else\n#define debug(...) 83;\n#endif\n\nvoid d_err() {\n    cerr << endl;\n}\n\ntemplate <typename H, typename... T>\nvoid d_err(H h, T... t) {\n    cerr << h << \" \";\n    d_err(t...);\n}\n\ntemplate <typename T>\nvoid print(T x) {\n    cout << x << \"\\n\";\n}\n\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define REVFOR(i, m, n) for (int i = (n - 1); i >= (m); --i)\n#define REP(i, n) FOR(i, 0, n)\n#define REVREP(i, n) REVFOR(i, 0, n)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define bcnt __builtin_popcountll\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int,int> Pin;\n\nll INF = 1e16;\nint inf = 1e9;\n\nvoid chmax(ll& x, ll y) {\n    if (x < y) x = y;\n}\n\nstruct UnionFind {\n    vector<int> par;\n\n    UnionFind(int n): par(n, -1) {}\n    void init(int n) { par.assign(n, -1); }\n\n    int root(int x) {\n        if (par[x] < 0) return x;\n        return par[x] = root(par[x]);\n    }\n\n    int issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n\n        if (x == y) return false;\n\n        // merge by size\n        // force size of x to be bigger than that of y\n        if (par[x] > par[y]) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n\n        return true;\n    }\n\n    ll size(int x) {\n        return -par[root(x)];\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    int h, w, k; cin >> h >> w >> k;\n    vector<string> vs(h);\n    REP(i, h) cin >> vs[i];\n\n    vector<vi> v(h, vi(w));\n    REP(i, h) REP(j, h) v[i][j] = vs[i][j] - '0';\n\n    // calc score\n    auto get_score = [&](vector<vi>& v) -> ll {\n        ll score = 0;\n        int cnt_clear = 0;\n        while(1) {\n            ll cur = 0;\n            vector<vector<bool>> clear(h, vector<bool>(w, false));\n\n            REP(i, h) {\n                ll prev = -1;\n                ll cnt = 0;\n                REP(j, w) {\n                    if (v[i][j] == -1) {\n                        if (cnt >= k) {\n                            REP(l, cnt) {\n                                clear[i][j - l - 1] = true;\n                            }\n                            cur += cnt * prev;\n                        }\n\n                        cnt = 0;\n                        prev = -1;\n                        continue;\n                    }\n\n                    if (prev != v[i][j]) {\n                        if (cnt >= k) {\n                            REP(l, cnt) {\n                                clear[i][j - l - 1] = true;\n                            }\n                            cur += cnt * prev;\n                        }\n                        cnt = 0;\n                    }\n\n                    prev = v[i][j];\n                    cnt++;\n                }\n\n                if (cnt >= k) {\n                    REP(l, cnt) clear[i][w - l - 1] = true;\n                    cur += cnt * prev;\n                }\n            }\n\n            REP(j, w) {\n                REP(i, h) {\n                    if (clear[i][j]) {\n                        REVREP(l, i) {\n                            v[l + 1][j] = v[l][j];\n                        }\n                        v[0][j] = -1;\n                    }\n                }\n            }\n\n            if (cur == 0)  break;\n            score += cur * pow(2, cnt_clear);\n            cnt_clear++;\n        }\n\n        return score;\n    };\n\n    ll ans = 0;\n    REP(i, h) REP(j, w) {\n        // clear this\n        vector<vi> v_cur = v;\n\n        REVREP(l, i) v_cur[l + 1][j] = v_cur[l][j];\n        v_cur[0][j] = -1;\n\n        ans = max(ans, get_score(v_cur));\n    }\n\n    print(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n\nint H, W, K;\n\nvoid fall(vector<vector<int>> &c) {\n    rep(i,W) rep(j,H) {\n        if (c[H-1-j][i] == 0) {\n            for (int k = H - 1 - j; k >= 0; --k) {\n                if (c[k][i] != 0) {\n                    for (int l = 0; H - 1 - j - l >= 0; ++l) {\n                        if (k - l >= 0) c[H-1-j-l][i] = c[k-l][i];\n                        else c[H-1-j-l][i] = 0;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n}\n\nvoid sum(ll &ans, ll ans_cnt, vector<vector<int>> &c) {\n    rep(i,H) {\n        ll left = 0;\n        rep(j,W) {\n            if (c[i][j+1] != 0 && c[i][j+1] == c[i][j]) continue;\n            else {\n                if (c[i][j+1] != c[i][j]) {\n                    if (j - left + 1 > 1) {\n                        ans += pow(2LL, ans_cnt) * (j - left + 1) * c[i][j];\n                        for (int k = left; k <= j; ++k) c[i][k] = 0;\n                    }\n                }\n                left = j + 1;\n            }\n        }\n    }\n}\n\n\n\nll calc_ans(int x, int y, vector<vector<int>> c) {\n    ll ans = 0;\n    ll pre_ans = -1;\n    ll ans_cnt = 0;\n\n    c[x][y] = 0;\n    fall(c);\n    while (pre_ans != ans) {\n        pre_ans = ans;\n        sum(ans, ans_cnt, c);\n        fall(c);\n        ++ans_cnt;\n    }\n    return ans;\n}\n\n\n\n\nint main() {\n    cin >> H >> W >> K;\n    vector<vector<int>> c(H, vector<int>(W+1));\n    rep(i,H) {\n        string S;\n        cin >> S;\n        rep(j,W) c[i][j] = S[j] - '0';\n    }\n\n    ll ans = 0;\n    calc_ans(3, 3, c);\n\n    rep(i,H) rep(j,W) {\n        if (i == 0) continue;\n        ans = max(ans, calc_ans(i, j, c));\n    }\n    \n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n\nint H, W, K;\n\nvoid fall(vector<vector<int>> &c) {\n    rep(i,W) rep(j,H) {\n        if (c[i][j] == 0) {\n            for (int k = 1; k + j < H; ++k) {\n                if (c[i][k+j] != 0) {\n                    for (int l = j; l < H; ++l) {\n                        if (l + k < H) c[i][l] = c[i][l+k];\n                        else c[i][l] = 0;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n}\n\nvoid sum(ll &ans, ll delete_cnt, vector<vector<int>> &c) {\n    rep(i,H) {\n        ll left = 0;\n        rep(j,W) {\n            if (c[j+1][i] != 0 && c[j+1][i] == c[j][i]) continue;\n            if (c[j+1][i] != c[j][i]) {\n                if (j - left + 1 > 1) {\n                    ans += (1LL<<delete_cnt) * (j - left + 1) * c[j][i];\n                    for (int k = left; k <= j; ++k) c[k][i] = 0;\n                }\n            }\n            left = j + 1;\n        }\n    }\n}\n\n\n\nll calc_ans(int x, int y, vector<vector<int>> c) {\n    ll res = 0;\n    ll pre_ans = -1;\n    ll delete_cnt = 0;\n\n    c[x][y] = 0;\n    fall(c);\n    while (res != pre_ans) {\n        pre_ans = res;\n        sum(res, delete_cnt, c);\n        fall(c);\n        ++delete_cnt;\n    }\n    return res;\n}\n\n\nint main() {\n    cin >> H >> W >> K;\n    vector<vector<ll>> c(W+1, vector<ll>(H));\n    rep(i,H) {\n        string S;\n        cin >> S;\n        rep(j,W) c[j][H-1-i] = S[j] - '0';\n    }\n\n    ll ans = 0;\n\n    rep(i,W) rep(j,H) {\n        if (i == 0) continue;\n        ans = max(ans, calc_ans(i, j, c));\n    }\n    \n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define M_PI       3.14159265358979323846   // pi\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<ll> VI;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\n\n#define rep(a,n) for(ll a = 0;a < n;a++)\n#define repi(a,b,n) for(ll a = b;a < n;a++)\n\nusing namespace std;\n\nstatic const ll INF = 1e15;\n\ntemplate<typename T>\nstatic inline void chmin(T & ref, const T  value) {\n    if (ref > value) ref = value;\n}\n\ntemplate<typename T>\nstatic inline void chmax(T & ref, const T value) {\n    if (ref < value) ref = value;\n}\n\nconst ll mod = 1000000007;\n\n\nint main() {\n\tll h, w, k;\n\tcin >> h >> w >> k;\n\tvector<vector<ll>> grid(h, vector<ll>(w, 0));\n\trep(i, h) {\n\t\tstring s;\n\t\tcin >> s;\n\t\trep(j, w) {\n\t\t\tgrid[i][j] = s[j] - '0';\n\t\t}\n\t}\n\n\tll u = 0;\n\trep(i, h) {\n\t\trep(j, w) {\t\t\t\n\t\t\tvector<vector<ll>> current = grid;\n\t\t\tll score = 0;\n\t\t\tbool update = true;\n\t\t\tvector<unordered_set<int>> del(w);\n\t\t\tdel[j].insert(i);\n\t\t\tll pow2 = 1;\n\t\t\twhile (update) {\n\t\t\t\tupdate = false;\n\t\t\t\trep(x, w) {\n\t\t\t\t\tconst auto& s = del[x];\n\t\t\t\t\tif (s.size()) {\n\t\t\t\t\t\tint target = h - 1;\n\t\t\t\t\t\tfor (int y = h - 1; y >= 0; y--) {\n\t\t\t\t\t\t\twhile(s.count(target)) {\n\t\t\t\t\t\t\t\ttarget--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (target < 0) {\n\t\t\t\t\t\t\t\tcurrent[y][x] = -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tcurrent[y][x] = current[target][x];\n\t\t\t\t\t\t\t\ttarget--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(i, w) del[i].clear();\n\t\t\t\trep(y, h) {\n\t\t\t\t\tint left = 0;\n\t\t\t\t\tint right = 0;\n\t\t\t\t\twhile (left < w && right < w) {\n\t\t\t\t\t\tif (current[y][left] == -1) {\n\t\t\t\t\t\t\tleft++;\n\t\t\t\t\t\t\tright = left;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (right < w && current[y][left] == current[y][right]) {\n\t\t\t\t\t\t\tright++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (right - left >= k) {\n\t\t\t\t\t\t\tfor (int a = left; a < right; a++) {\n\t\t\t\t\t\t\t\tscore += pow2 * current[y][a];\n\t\t\t\t\t\t\t\tdel[a].insert(y);\n\t\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tleft = right;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tleft++;\n\t\t\t\t\t\t\tright = left;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpow2 *= 2;\n\t\t\t}\n\t\t\tchmax(u, score);\n\t\t}\n\t}\n\tcout << u << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <list>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <tuple>\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define rep1(i, n) for (int i = 1; i <= (n); i++)\n#define show(a, n) rep(i,n) {cout<<a[i]<<' ';} cout<<endl\n#define show2(a, n, m) rep(i, n) { rep(j, m) {cout << a[i][j] << ' ';} cout << endl;} \n#define chmin(a, b) a = min(a, b)\n#define chmax(a, b) a = max(a, b)\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef pair<long long, long long> pll;\ntypedef long double ld;\n\nconst int INF = 1 << 30;\nconst long long INFL = 1LL << 60;\nconst int MOD = 1000000007;\nconst int MAX = 100000;\nconst int N = 100010;\n\nint h, w, k;\nll b;\n\nll add_score(vector<vi>& c) {\n\tll ret = 0;\n\trep(i, h) {\n\t\tint suc = 0;\n\t\tint last = 0;\n\t\tint st = 0;\n\t\trep(j, w) {\n\t\t\tif(c[i][j] == last) suc++;\n\t\t\telse {\n\t\t\t\tif(suc >= k) {\n\t\t\t\t\tret += b * suc * last;\n\t\t\t\t\tfor(int j2 = st; j2 <= j; j2++) c[i][j2] = 0;\n\t\t\t\t}\n\t\t\t\tlast = c[i][j];\n\t\t\t\tsuc = 1;\n\t\t\t\tst = j;\n\t\t\t}\n\t\t}\n\t\tif(suc >= k) {\n\t\t\tret += b * suc * last;\n\t\t\tfor(int j2 = st; j2 <= w-1; j2++) c[i][j2] = 0;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid update(vector<vi>& c) {\n\trep(j, w) {\n\t\tint i2 = h-1;\n\t\tfor(int i = h-1; i >= 0; i--) {\n\t\t\tif(c[i][j] != 0) {\n\t\t\t\tswap(c[i][j], c[i2][j]);\n\t\t\t\ti2--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nll score(int i, int j, vector<vi> c) {\n\tc[i][j] = 0;\n\tupdate(c);\n\tll ret = 0;\n\tb = 1;\n\twhile(true) {\n\t\tll add = add_score(c);\n\t\tif(add == 0) break;\n\t\tret += add;\n\t\tupdate(c);\n\t\tb *= 2;\n\t}\n\treturn ret;\n}\n\nint main() {\n//\tcout << fixed << setprecision(15);\n\tcin >> h >> w >> k;\n\tvector<vi> c(h, vi(w));\n\trep(i, h) {\n\t\tstring s;\n\t\tcin >> s;\n\t\trep(j, w) c[i][j] = s[j] - '0';\n\t}\n\tll ans = 0;\n\trep(i, h) rep(j, w) chmax(ans, score(i, j, c));\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// {{{\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <list>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <numeric>\n#include <complex>\n#include <utility>\n#include <type_traits>\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define FOR(i, a, b) for(ll i = static_cast<ll>(a); i < static_cast<ll>(b); ++i)\n#define FORR(i, a, b) for(ll i = static_cast<ll>(a); i >= static_cast<ll>(b); --i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPR(i, n) FORR(i, n, 0)\n#define ALL(x) (x).begin(), (x).end()\n#define DBG(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<int, int>;\nusing LP = pair<ll, ll>;\nusing IP = pair<int, P>;\nusing LLP = pair<ll, LP>;\n\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, 1, -1};\n\nconstexpr int INF = 100000000;\nconstexpr ll LINF = 10000000000000000ll;\nconstexpr int MOD = static_cast<int>(1e9 + 7);\nconstexpr double EPS = 1e-9;\n\n// {{{ popcount\nstatic int popcount(int x) {\n    return __builtin_popcount(static_cast<unsigned int>(x));\n}\nstatic int popcount(unsigned int x) {\n    return __builtin_popcount(x);\n}\nstatic int popcount(long x) {\n    return __builtin_popcountl(static_cast<unsigned long>(x));\n}\nstatic int popcount(unsigned long x) {\n    return __builtin_popcountl(x);\n}\nstatic int popcount(long long x) {\n    return __builtin_popcountll(static_cast<unsigned long long>(x));\n}\nstatic int popcount(unsigned long long x) {\n    return __builtin_popcountll(x);\n}\n// }}}\n\n// template specialization of std::hash for std::pair\nnamespace std {\ntemplate<typename T, typename U>\nstruct hash<pair<T, U> > {\n    size_t operator()(const pair<T, U> &key) const noexcept {\n        size_t h1 = hash<T>()(key.first);\n        size_t h2 = hash<U>()(key.second);\n        return h1 ^ (h2 << 1);\n    }\n};\n} // namespace std\n\n// print vector\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    size_t sz = v.size();\n    os << \"[\";\n    for (size_t i = 0; i < sz-1; i++) {\n        os << v[i] << \", \";\n    }\n    os << v[sz-1] <<  \"]\";\n    return os;\n}\n\n// print array (except char literal)\ntemplate<\n    typename T,\n    int N,\n    typename std::enable_if<!std::is_same<T, char>::value, std::nullptr_t>::type = nullptr>\nostream &operator<<(ostream &os, const T (&v)[N]) {\n    os << \"[\";\n    for (size_t i = 0; i < N-1; i++) {\n        os << v[i] << \", \";\n    }\n    os << v[N-1] <<  \"]\";\n    return os;\n}\n\n// print array\ntemplate<typename T>\nvoid printArray(T *arr, size_t sz) {\n    cerr << \"[\";\n    for (size_t i = 0; i < sz-1; i++) {\n        cerr << arr[i] << \",\";\n    }\n    cerr << arr[sz-1] <<  \"]\" << endl;\n}\n\n// print pair\ntemplate<typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n    os << \"(\" << p.first << \", \" << p.se << \")\";\n    return os;\n}\n\nstatic inline ll mod(ll x, ll m)\n{\n    ll y = x % m;\n    return (y >= 0 ? y : y+m);\n}\n\nstruct Compare {\n    //vector<ll> &x_, &y_;\n    //Compare(vector<ll> &x, vector<ll> &y): x_(x), y_(y) {}\n    //bool operator()(const P &lhs, const P &rhs) {\n    //    return x_[lhs.fi]+y_[lhs.se] < x_[rhs.fi]+y_[rhs.se];\n    //}\n    bool operator()(const int x, const int y) {\n        return x < y;\n    }\n};\n\n// print floating-point number\n// cout << fixed << setprecision(12) <<\n\n// }}}\n\nint H, W, K;\nint morg[31][31], m[31][31];\n\nvoid update()\n{\n    REP (i, W) {\n        REPR (j, H-1) {\n            if (m[j][i] != 0) continue;\n            REPR (k, j-1) {\n                if (m[k][i] != 0) {\n                    m[j][i] = m[k][i];\n                    m[k][i] = 0;\n                    break;\n                }\n            }\n        }\n    }\n}\n\nll start(int h, int w)\n{\n    ll ret = 0, n = 0;\n    REP (i, H) REP (j, W) m[i][j] = morg[i][j];\n    m[h][w] = 0;\n    update();\n    while (true) {\n        ll x = 0;\n        bool up = false;\n        REP (i, H) {\n            REP (j, W-K+1) {\n                if (m[i][j] == 0) continue;\n                int k = 0;\n                while (j+k < W) {\n                    if (m[i][j] != m[i][j+k]) {\n                        break;\n                    }\n                    ++k;\n                }\n                if (k >= K) {\n                    up = true;\n                    x += m[i][j] * k;\n                    REP (l, k) m[i][j+l] = 0;\n                }\n            }\n        }\n        ret += pow(2, n) * x;\n        if (!up) break;\n        update();\n        ++n;\n    }\n    return ret;\n}\n\nvoid solve()\n{\n    ll ans = 0;\n    REP (i, H) {\n        REP (j, W) {\n            ans = max(ans, start(i, j));\n        }\n    }\n    cout << ans << endl;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> H >> W >> K;\n    REP (i, H) {\n        REP (j, W) {\n            char c;\n            while (true) {\n                c = cin.get();\n                if ('0' <= c && c <= '9') break;\n            }\n            morg[i][j] = c - '0';\n        }\n    }\n    solve();\n    return 0;\n}\n\n// vim:set foldmethod=marker:\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nvoid drop(vector<vector<int>>& c) {\n    int H = c.size();\n    int W = c.front().size();\n    for (int j = 0; j < W; ++j) {\n        vector<int> temp;\n        for (int i = 0; i < H; ++i) {\n            if (c[i][j] > 0) {\n                temp.push_back(c[i][j]);\n            }\n        }\n        for (int i = 0; i < H; ++i) {\n            if (i < H - temp.size()) {\n                c[i][j] = 0;\n            }\n            else {\n                c[i][j] = temp[i - (H - temp.size())];\n            }\n        }\n    }\n}\n\nvoid logging(const vector<vector<int>>& c) {\n    int H = c.size();\n    int W = c.front().size();\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (j > 0) {\n                cout << \" \";\n            }\n            cout << c[i][j];\n        }\n        cout << endl;\n    }\n\n}\n\nint solve(int row, int col, int K, vector<vector<int>> c) {\n    int H = c.size();\n    int W = c.front().size();\n\n    c[row][col] = 0;\n    drop(c);\n\n    bool erased = true;\n    int mult = 1;\n    int ans = 0;\n    while (erased) {\n        bool e = false;\n        for (int i = 0; i < H; ++i) {\n            int curr = c[i][0];\n            int start = 0;\n            int continuous = 1;\n            set<int> targets;\n            for (int j = 1; j < W; ++j) {\n                if (curr > 0 && curr == c[i][j]) {\n                    ++continuous;\n                }\n                else {\n                    continuous = 1;\n                    if (j - start >= K) {\n                        for (int k = start; k < j; ++k) {\n                            targets.insert(k);\n                        }\n                    }\n                    start = j;\n                }\n                curr = c[i][j];\n            }\n            if (W - start >= K) {\n                for (int k = start; k < W; ++k) {\n                    targets.insert(k);\n                }\n            }\n            int sum = 0;\n            for (int t : targets) {\n                sum += c[i][t];\n                c[i][t] = 0;\n                e = true;\n            }\n            ans += mult * sum;\n        }\n        erased = e;\n        drop(c);\n        mult *= 2;\n    }\n    return ans;\n}\n\nvoid Main() {\n    int H, W, K;\n    cin >> H >> W >> K;\n    vector<vector<int>> c(H, vector<int>(W, 0));\n    for (int i = 0; i < H; ++i) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < W; ++j) {\n            c[i][j] = s[j] - '0';\n        }\n    }\n\n    int ans = 0;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            ans = max(ans, solve(i, j, K, c));\n        }\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    std::cout << std::fixed << std::setprecision(15);\n    Main();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#define MAXN 35\n#define NN 15\nusing namespace std;\nchar in[MAXN][MAXN];\nint malt[MAXN][MAXN], tmp[MAXN][MAXN];\nint tt[MAXN][MAXN], vis[15];\nint n, m, key;\nvoid work()\n{\n    for(int i = 1; i <= n; i++)\n    {\n        for(int j = 1; j <= m; j++)\n        {\n            tt[i][j] = tmp[i][j];\n            tmp[i][j] = 0;\n        }\n    }\n    for(int j = 1; j <= m; j++)\n    {\n        int now = n;\n        for(int i = n; i >= 1; i--)\n        {\n            if(!tt[i][j]) continue;\n            tmp[now--][j] = tt[i][j];\n        }\n    }\n}\nvoid cop(int x, int y)\n{\n    for(int i = 1; i <= n; i++)\n    {\n        for(int j = 1; j <= m; j++)\n        {\n            tmp[i][j] = malt[i][j];\n        }\n    }\n    tmp[x][y] = 0;\n    work();\n}\nvoid print()\n{\n    for(int i = 1; i <= n; i++)\n    {\n        for(int j = 1; j <= m; j++)\n        {\n            printf(\"%d \", tmp[i][j]);\n        }\n        puts(\"\");\n    }\n}\nint solve()\n{\n    int mul = 1, res = 0, sum;\n    while(true)\n    {\n        sum = 0;\n        for(int i = 1; i <= 9; i++) vis[i] = 0;\n        for(int i = 1; i <= n; i++)\n        {\n            for(int k, j = 1; j <= m; j = k)\n            {\n                k = j;\n                while(k <= m && tmp[i][j] == tmp[i][k]) k++;\n                if(k - j >= key)\n                {\n                    sum += tmp[i][j] * (k - j);\n                    for(int h = j; h < k; h++) tmp[i][h] = 0;\n                }\n            }\n        }\n        if(!sum) break;\n        work();\n        res += (mul * sum);\n        mul *= 2;\n        //print();\n        //printf(\"----------------%d %d\\n\", mul, sum);\n    }\n    return res;\n}\nint main()\n{\n    scanf(\"%d%d%d\", &n, &m, &key);\n    for(int i = 0; i < n; i++) scanf(\"%s\", in[i]);\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            malt[i + 1][j + 1] = in[i][j] - '0';\n        }\n    }\n    int res = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        for(int j = 1; j <= m; j++)\n        {\n            cop(i, j);\n            res = max(res, solve());\n        }\n    }\n    printf(\"%d\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i=0; i < (int)(n); i++)\nusing ull = unsigned long long;\nusing ll = long long;\n\nint H, W, K;\nint C[31][31]={}, D[31][31]={};\n\nvoid drop() {\n    rep(w, W) {\n        for (int h=H-1; h>=0; h--) {\n            if (D[h][w] == 0) {\n                for (int h2=h; h2>=0; h2--) {\n                    if (D[h2][w] != 0) {\n                        D[h][w] = D[h2][w];\n                        D[h2][w] = 0;\n                        h = h2+1;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    // rep(h, H) {\n    //     rep(w, W) cout << D[h][w];\n    //     cout << endl;\n    // }\n    // cout << endl;\n}\n\nint cal_score(int hi, int wi) {\n    int score = 0, bouns=1;\n    D[hi][wi] = 0;\n\n    // cout << \" ---\" << a << \" ---\" << endl;\n\n    while (true) {\n        int prev_score = score;\n\n        drop();\n        rep(h, H) {\n            int same_num_cnt = 1;\n            for (int w=0; w<W; w++) {\n                if (D[h][w+1] == D[h][w] && D[h][w] != 0) same_num_cnt++;\n                if (D[h][w+1] != D[h][w]) {\n                    if (same_num_cnt >= K) {\n                        score += D[h][w] * same_num_cnt * bouns;\n                        // cout << \" \" << D[h][w] << \" \" << score << endl;\n                        for (int w2=w; w2>w-same_num_cnt; w2--) D[h][w2] = 0;\n                    }\n                    same_num_cnt = 1;\n                }\n            }\n        }\n\n        // cout << \"i:\" << a << \", :score\" << score << endl;\n        bouns *= 2;\n        if (prev_score == score) break;\n    }\n    return score;\n}\n\nint main() {\n    cin >> H >> W >> K;\n    string sh;\n    rep(h, H) {\n        cin >> sh;\n        rep(w, W) C[h][w] = sh[w] - '0';\n    }\n\n    int ans = 0;\n    rep(hi, H) {\n        rep(wi, W) {\n        rep(h, H) rep(w, W) D[h][w] = C[h][w];\n        ans = max(ans, cal_score(hi, wi));\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\ntypedef long double ld;\n#define rep(i,n) for(ll i=0;i<(n);i++)\n#define repr(i,n) for(ll i=(n-1);i>=0;i--)\n#define all(x) x.begin(),x.end()\n#define br cout << \"\\n\";\nusing namespace std;\nconst long long INF = 1e10;\nconst long long MOD = 1e9+7;\nusing Graph = vector<vector<ll>>;\nusing pll = pair<ll, ll>;\ntemplate<class T> inline bool chmin(T &a, T b) { if(a > b){ a = b; return true;} return false;}\ntemplate<class T> inline bool chmax(T &a, T b) { if(a < b){ a = b; return true;} return false;}\n\n// 0 false, 1 true \n// string to int : -48\n// a to A : -32\n// ceil(a)  1.2->2.0\n// c++17\tg++ -std=c++17 a.cpp\n\nint main() {\n    std::cout << std::fixed << std::setprecision(15);\n    ll h, w, k; cin >> h >> w >> k;\n\n    vector<vector<ll>> vec(h, vector<ll>(w));\n    rep(i, h){\n        string s; cin >> s;\n        rep(j, w){\n            vec[i][j] = s[j] - 48;\n        }\n    }\n\n    /*\n    rep(i, h){\n        rep(j, w){\n            cout << vec[i][j] << \" \";\n        }\n        br;\n    }\n    */\n\n    ll ans = 0;\n    for(ll x = 1; x < h; x++){\n        rep(y, w){\n            vector<vector<ll>> cell(h, vector<ll>(w));\n            cell = vec;\n            //消す\n            cell[x][y] = 0;\n            //降ろす\n            rep(j, w){\n                for(ll i = h-1; i >= 0; i--){\n                    for(ll k = i-1; k >= 0; k--){\n                        if(cell[i][j] == 0){\n                            swap(cell[i][j], cell[k][j]);\n                        }\n                    }\n                }\n            }\n            //初期処理終了\n            //////////////\n\n            ll score = 0;\n            ll pre = 1;\n            while(true){\n                ll tmp = score;\n                rep(i, h){\n                    ll num = 0; ll num_s = -1;\n                    rep(j, w){\n                        if(j == 0){\n                            num = cell[i][j]; num_s = 0; continue;\n                        }\n\n                        if(cell[i][j] == num){\n                            if(j == w-1){\n                                if(j - num_s >= k-1){\n                                    for(ll k = num_s; k <= j; k++){\n                                        score += pre * num; cell[i][k] = 0;\n                                    }\n                                }\n                            }\n                        }else{\n                            if(j - 1 - num_s >= k-1){\n                                for(ll k = num_s; k < j; k++){\n                                    score += pre * num; cell[i][k] = 0;\n                                }\n                            }\n                            num = cell[i][j]; num_s = j;\n                        }\n                    }\n                }\n\n                //降ろす\n                rep(j, w){\n                    for(ll i = h-1; i >= 0; i--){\n                        for(ll k = i-1; k >= 0; k--){\n                            if(cell[i][j] == 0){\n                                swap(cell[i][j], cell[k][j]);\n                            }\n                        }\n                    }\n                }\n\n                if(tmp == score){\n                    break;\n                }\n\n                pre *= 2;\n            }\n            /*\n            if(ans < score){\n                cout << x << \" \" << y << endl;\n                rep(i, h){\n                    rep(j, w){\n                        cout << cell[i][j] << \" \";\n                    }\n                    br;\n                }\n            }\n            */\n            ans = max(ans, score);\n\n        }\n    }\n\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "// /usr/local/bin/g++ Main.cpp -std=c++14\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint H, W, K, C[30*30], _c[30*30];\nset<int> d;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> H >> W >> K;\n\tfor (int i = 0; i < H; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tint j = 0;\n\t\tfor (char& c : s) {\n\t\t\tC[i*W+(j++)] = (int)(c - '0');\n\t\t}\n\t}\n\n\tll res = 0;\n\tfor (int i = 1; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tfor (int k = 0; k < 30*30; k++) {\n\t\t\t\t_c[k] = C[k];\n\t\t\t}\n\t\t\td.clear();\n\t\t\td.insert(i*W+j);\n\t\t\tint cnt = 0;\n\t\t\tint __res = 0;\n\t\t\twhile (d.size()) {\n\t\t\t\tfor (int l : d) {\n\t\t\t\t\tfor (int _i = l/W; _i > 0; _i--) {\n\t\t\t\t\t\t_c[_i*W+l%W] = _c[(_i-1)*W+l%W];\n\t\t\t\t\t}\n\t\t\t\t\t_c[l%W] = 0;\n\t\t\t\t}\n\t\t\t\td.clear();\n\t\t\t\tint _res = 0;\n\t\t\t\tfor (int _i = 1; _i < H; _i++) {\n\t\t\t\t\tint pre = 0;\n\t\t\t\t\tbool loop = false;\n\t\t\t\t\tint kuri = K - 1;\n\t\t\t\t\tfor (int _j = 0; _j <= W; _j++) {\n\t\t\t\t\t\tif (_j != W && pre != 0 && _c[_i*W+_j] == pre) {\n\t\t\t\t\t\t\tif (--kuri <= 0) {\n\t\t\t\t\t\t\t\tfor (int _t = 0; _t < K - 1; _t++) {\n\t\t\t\t\t\t\t\t\tif (d.count(_i*W+_j-(_t+1)) == 0) {\n\t\t\t\t\t\t\t\t\t\td.insert(_i*W+_j-(_t+1));\n\t\t\t\t\t\t\t\t\t\t_res += pre;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (loop) {\n\t\t\t\t\t\t\t\t_res += pre;\n\t\t\t\t\t\t\t\td.insert(_i*W+_j-1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tkuri = K - 1;\n\t\t\t\t\t\t\tloop = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (_j < W) pre = _c[_i*W+_j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (_res > 0) {\n\t\t\t\t\tint tmp = 1;\n\t\t\t\t\tfor (int _k = 0; _k < cnt; _k++) {\n\t\t\t\t\t\ttmp *= 2;\n\t\t\t\t\t}\n\t\t\t\t\t__res += tmp*_res;\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif (res < __res) res = __res;\n\t\t}\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (n); ++i)\nusing namespace std;\n\nint H, W, K;\n\nvoid update(vector<vector<int>> &B) {\n    vector<vector<int>> A(H);\n    rep(i, H) {\n        rep(j, W) if(B[i][j]) A[i].push_back(B[i][j]);\n        while(A[i].size() < W) A[i].push_back(0);\n    }\n    swap(A, B);\n}\n\nint eval(vector<vector<int>> &B) {\n    int res = 0;\n    vector<vector<int>> A(B);\n    rep(j, W) rep(i, H) {\n        int cnt = 0, ni = i;\n        if(B[i][j] == 0) continue;\n        while(ni < H && B[i][j] == B[ni][j]) cnt++, ni++;\n        if(cnt >= K) {\n            for(int pos = i; pos < ni; ++pos) {\n                A[pos][j] = 0;\n                res += B[pos][j];\n            }\n        }\n        i = ni - 1;\n    }\n    swap(A, B);\n    return res;\n}\n\nint solve(vector<vector<int>> B, int i, int j) {\n    int res = 0, score = 0, k = 1;\n    B[i][j] = 0;\n    do {\n        update(B);\n        score = k * eval(B);\n        res += score;\n        k *= 2;\n    } while(score);\n    return res;\n}\n\nint main() {\n    cin >> H >> W >> K;\n    vector<vector<char>> C(H, vector<char>(W));\n    vector<vector<int>> B(W, vector<int>(H));\n    rep(i, H) rep(j, W) cin >> C[i][j];\n    rep(i, H) rep(j, W) B[j][H - i-  1] = C[i][j] - '0';\n    swap(H, W);\n    int ans = 0;\n    rep(i, H) rep(j, W) ans = max(ans, solve(B, i, j));\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\n#define F first\n#define S second\n\nconst int mx=200010;\nconst ll mod=1e9+7;\n\n\nint main() {\n  int h,w,k;\n  cin >> h >> w >> k;\n  vector<vector<int>> data(30, vector<int>(30,0));\n  rep(i,h)rep(j,w) cin >> data[i][j];\n\n  ll ans=0;\n  rep(x,h)rep(y,w){\n    auto c = data;\n    c[x][y] = 0;\n    ll base = 0, res = 0;\n    while(1){\n      ll tmp = 0;\n      rep(i,h){\n        int st=0;\n        rep(j,w+1){\n          if(j==w || (j>0&&c[i][j]!=c[i][j])){\n            if(j-st>=k){ for(int p=st; p<j; p++){tmp+=c[i][p]; c[i][p]=0; }  st=j; }\n            st = j;\n          }\n        }\n      }\n      if(base!=0 && tmp==0) break;\n      res += base*tmp;\n      base = (base>0?base*2:1);\n\n      rep(j,w){\n        int pos = h-1;\n        for(int i=h-1; i>=0; i--){\n          if(c[i][j]>0){\n            c[pos][j] = c[i][j];\n            if(pos!=i) c[i][j] = 0;\n            pos--;\n          }\n        }\n      }\n    }\n    ans = max(ans, res);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nvoid disp_stone(vector<vector<char> > s, int H, int W){\n\tcerr << endl;\n\trep (i, H){\n\t\trep (j, W){\n\t\t\tcerr << s[i][j];\n\t\t} // end rep\n\t\tcerr << endl;\n\t} // end rep\n}\n\n// 落ちきった状態を作り出す\nvector<vector<char> > all_fall(vector<vector<char> > s, int H, int W){\n\tvector<vector<char> > t = s;\n//\tdisp_stone(t, H, W);\n\twhile(true){\n\t\tbool update = false;\n\t\tfor (int i = 0; i < H-1; ++i){\n\t\t\tfor (int j = 0; j < W; ++j){\n\t\t\t\tif (t[i][j] != '0' && t[i+1][j] == '0'){\n\t\t\t\t\tswap(t[i][j], t[i+1][j]);\n\t\t\t\t\tupdate |= true;\n\t\t\t\t\tbreak;\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t\tif (update) break;\n\t\t} // end for\n\t\tif (!update) break;\n\t} // end while\n//\tdisp_stone(t, H, W);\n\t\n\treturn t;\n}\n\n// 消滅する状態を作り出す\nint disappearing(vector<vector<char> > &s, int H, int W, int K){\n\tint score = 0;\n\tfor (int i = 0; i < H; ++i){\n\t\tint left = 0, right = 0;\n\t\twhile(right < W){\n\t\t\twhile (s[i][left] == s[i][right]){\n\t\t\t\t++right;\n\t\t\t} // end while\n\t\t\tif (right - 1 - left + 1 >= K){\n\t\t\t\tscore += (right - 1 - left + 1)*(int)(s[i][left] - '0');\n\t\t\t\tfor (int j = left; j < right; ++j){\n\t\t\t\t\ts[i][j] = '0';\n\t\t\t\t} // end for\n\t\t\t} // end if\n\t\t\tleft = right;\n\t\t} // end while\n\t} // end for\n\t\n\treturn score;\n}\n\n// 状態が変化しなくなるまでシミュレーション\nint smulate(vector<vector<char> > s, int H, int W, int K){\n\n\tvector<vector<char> > t;\n\tint score = 0;\n\tfor(int i = 0;; ++i){\n\t\tt = all_fall(s, H, W);\n\t\tif (t == s) break;\n\t\tscore += (1<<i) * disappearing(t, H, W, K);\n\t\ts = t;\t\t\n\t} // end for\n\t\n\treturn score;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint H, W, K; cin >> H >> W >> K;\n\tvector<vector<char> > stones(H, vector<char>(W, 0));\n\trep (i, H){\n\t\trep (j, W){\n\t\t\tcin >> stones[i][j];\n\t\t} // end rep\n\t} // end rep\n\n\tint res = 0;\n\trep (i, H){\n\t\trep (j, W){\n\t\t\tvector<vector<char> > s = stones;\n\t\t\ts[i][j] = '0';\n\t\t\tint curr = smulate(s, H, W, K);\n\t\t\tres = max(res, curr);\n\t\t} // end rep\n\t} // end rep\n\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <iomanip>\n#include <stdlib.h>\n#include <stdio.h>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <time.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> Pii;\ntypedef pair<int, ll> Pil;\ntypedef pair<ll, ll> Pll;\ntypedef pair<ll, int> Pli;\n\n#define fi first\n#define se second\n#define mp make_pair\n \nconst ll MOD = 1e9 + 7;\nconst ll MOD2 = 998244353;\nconst ll INF = 1ll << 60;\nconst double PI = 2 * asin(1);\n\nvoid yes() {printf(\"yes\\n\");}\nvoid no() {printf(\"no\\n\");}\nvoid Yes() {printf(\"Yes\\n\");}\nvoid No() {printf(\"No\\n\");}\nvoid YES() {printf(\"YES\\n\");}\nvoid NO() {printf(\"NO\\n\");}\n\nint H, W, K, now[30][30];\nchar C[35][35];\nint ans = 0;\n\nint Solve(int I, int J){\n  for (int i = 0; i < H; i++){\n    for (int j = 0; j < W; j++){\n      now[i][j] = C[i][j] - '0';\n    }\n  }\n\n  now[I][J] = 0;\n  for (int i = I; i >= 1; i--){\n    now[i][J] = now[i - 1][J];\n  }\n  now[0][J] = 0;\n\n  int turn = 0, score = 0;\n\n  while(true){\n    int sum = 0;\n    for (int i = H - 1; i >= 0; i--){\n      int cnt = 1;\n      for (int j = 1; j < W; j++){\n        if (now[i][j] == now[i][j - 1]){\n          cnt++;\n        }else{\n          if (cnt >= K){\n            sum += now[i][j - 1] * cnt;\n            for (int k = 0; k < cnt; k++){\n              now[i][j - 1 - k] = 0; \n            }\n          }\n          cnt = 1;\n        }\n      }\n      if (cnt >= K){\n        sum += now[i][W - 1] * cnt; \n        for (int k = 0; k < cnt; k++){\n          now[i][W - 1 - k] = 0;\n        }\n      }\n    }\n\n    if (sum == 0) break;\n    score += sum * pow(2, turn);\n    turn++;\n\n    for (int i = H - 1; i >= 0; i--){\n      for (int j = 0; j < W; j++){\n        if (now[i][j] == 0){\n          \n          int start = i;\n          for (int k = i; k >= 0; k--){\n            if (now[k][j] != 0) {\n              start = k; break;\n            }\n          }\n\n          for (int k = start; k >= 0; k--){\n            now[i - start + k][j] = now[k][j];\n          }\n          for (int k = 0; k < i - start; k++){\n            now[k][j] = 0;\n          }\n\n        }\n      }\n    }\n  }\n\n  ans = max(ans, score);\n\n  return 0;\n}\n\nint main(){\n  scanf(\"%d%d%d\", &H, &W, &K);\n  for (int i = 0; i < H; i++){\n    scanf(\"%s\", &C[i]);\n  }\n\n  for (int i = 0; i < H; i++){\n    for (int j = 0; j < W; j++){\n      Solve(i, j);\n    }\n  }\n  printf(\"%d\\n\", ans);\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n// macro\n#define rep(i,n) for(i=0;i<n;i++)\n#define ll long long\n#define all(v) v.begin(), v.end()\n\n// code starts\nint main()\n{\n  int h,w,k;cin>>h>>w>>k;\n  vector<vector<int>> c(h,vector<int>(w));\n  int i,j,l,n,p;\n  rep(i,h)rep(j,w)\n  {\n    char ch;cin>>ch;\n    c[i][j]=(ch-'0');\n  }\n  int ans=0;\n  rep(i,h)rep(j,w)\n  {\n    bool update=true;\n    vector<vector<int>> m(h,vector<int>(w));\n    m=c;\n    m[i][j]=0;\n    int score=0;\n    int timev=1;\n    while(update)\n    {\n      update=false;\n      rep(n,w)\n      {\n        int to=h-1;\n        for(l=h-1;l>=0;l--)\n        {\n          if(m[l][n]!=0)\n          {\n            swap(m[to][n],m[l][n]);\n            to--;\n          }\n        }\n      }\n      int get=0;\n      rep(l,h)\n      {\n        int from=0;\n        int now=m[l][n];\n        rep(n,w)\n        {\n          if(now!=m[l][n])\n          {\n            int dis=(n-1)-from+1;\n            if(dis>=k)\n            {\n              for(p=from;p<n;p++)\n              {\n                get+=m[l][p];\n                m[l][p]=0;\n              }\n            }\n            from=n;\n            now=m[l][n];\n          }\n        }\n        int dis=(w-1)-from+1;\n        if(dis>=k)\n        {\n          for(p=from;p<n;p++)\n          {\n            get+=m[l][p];\n            m[l][p]=0;\n          }\n        }\n      }\n      if(get>0)update=true;\n      else break;\n      score+=timev*get;\n      timev*=2;\n    }\n    ans=max(ans,score);\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int N = 200 + 5;\n\ntypedef vector<vector<int>> maze;\nint n, m, k;\nint ans = 0, cur;\nint pw2[N];\nbool no_vanish;\n\nvoid vanish(maze& a, int stage) {\n    int cnt = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (a[i][j] == 0) continue;\n            int ptr = j;\n            while (a[i][j] == a[i][ptr] && ptr < m) ptr += 1;\n            if (ptr - j >= k) {\n                for(int u = j; u < ptr; u++) {\n                    cnt += a[i][u];\n                    a[i][u] = 0;\n                }\n            }\n            j = ptr - 1;\n        }\n    }\n    if (cnt > 0) no_vanish = false;\n    cur += pw2[stage] * cnt;\n}\n\nvoid reshape(maze& a) {\n    for (int j = 0; j < m; j++) {\n        vector<int> x;\n        for (int i = n - 1; i >= 0; i--) {\n            if (a[i][j] == 0) continue;\n            x.push_back(a[i][j]);\n        }\n        int ptr = n - 1;\n        for (int y : x) {\n            a[ptr--][j] = y;\n        }\n        for (int i = 0; i <= ptr; i++) {\n            a[i][j] = 0;\n        }\n    }\n}\n\nvoid proc(int x, int y, maze a) {\n    a[x][y] = 0;\n    int stage = 0;\n    while(true) {\n        no_vanish = true;\n        reshape(a);\n        // for (int i = 0; i < n; i++) {\n        //     for (int j = 0; j < m; j++) {\n        //         cout << a[i][j] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        vanish(a, stage++);\n        // for (int i = 0; i < n; i++) {\n        //     for (int j = 0; j < m; j++) {\n        //         cout << a[i][j] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        if (no_vanish == true) break;\n        //cout << cur << endl;\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> m >> k;\n    pw2[0] = 1;\n    for (int i = 1; i < 29; i++) {\n        pw2[i] = pw2[i - 1] * 2;\n    }\n    maze ini = maze(n, vector<int> (m, 0));\n    for (int i = 0; i < n; i++) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < m; j++) {\n            ini[i][j] = s[j] - '0';\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cur = 0;\n            proc(i, j, ini);\n            ans = max(ans, cur);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define rrep(i,m, n) for(int i = m; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define aall(x,n) (x).begin(),(x).begin()+(n)\n#define pb push_back\n#define pf push_front\n#define lb lower_bound\n#define ub upper_bound\n#define fi first\n#define se second\n#define sum accumulate\n#define keta fixed<<setprecision\n#define vvector(name,typ,m,n,a)vector<vector<typ> > name(m,vector<typ> (n,a))\n#define vvvector(name,t,l,m,n,a) vector<vector<vector<t> > > name(l, vector<vector<t> >(m, vector<int>(n,a)));\ntypedef long long ll;\nconst int INF = 2000000000;\nconst long INF64 = 1000000000000000ll;\nconst ll MOD = 1000000007LL;\nint main(){\n    int h,w,k;\n    std::cin >> h>>w>>k;\n    vvector(fi,int,w,h,0);\n    rep(j,h){\n        string s;\n        std::cin >> s;\n        rep(i,w)fi[i][j]=s[i]-'0';\n    }\n    int ans=0;\n    //std::cout << fi[0][3] << std::endl;\n    rep(j,h){\n        rep(i,w){\n            vvector(dum,int,w,h,0);\n            rep(jj,h){\n               rep(ii,w)dum[ii][jj]=fi[ii][jj];\n            }\n\n           // std::cout << 3 << std::endl;\n            dum[i][j]=0;\n/*          rep(jj,h){\n               rep(ii,w){\n                   std::cout << dum[ii][jj];\n               }\n               std::cout  << std::endl;\n            }*/\n          //  std::cout << std::endl;\n            int point=0;\n            int ccounter=1;\n            for(int bai=0;ccounter!=0;bai++){\n            int counter=1;\n            ccounter=0;\n            for(;counter!=0;){//落下\n            counter=0;\n            rep(jj,h){\n               rep(ii,w){\n                   \n                   if(dum[ii][jj]==0&&jj!=0){\n                        for (int kk = jj; kk > 0; kk--) {\n                            /* code */\n                            counter+=abs(dum[ii][kk-1]-dum[ii][kk]);\n                            dum[ii][kk]=dum[ii][kk-1];\n                            \n                            \n                        }\n                        dum[ii][0]=0;\n                   }\n                   \n               }\n            }\n            \n            }//ここまで落下\n            \n            vvector(dumdum,int,w,h,1);\n            \n            rep(jj,h){\n               rep(ii,w-1){\n                   if(dum[ii+1][jj]!=0&&dum[ii+1][jj]==dum[ii][jj])dumdum[ii+1][jj]=dumdum[ii][jj]+1;\n                   \n               }\n            }\n            int dumpoint=0;\n            rep(jj,h){\n               rep(ii,w){\n                   \n                   if(dumdum[ii][jj]>=k&& (ii==w-1||dumdum[ii+1][jj]<dumdum[ii][jj])){\n                       for (int kk = 0; kk <dumdum[ii][jj]; kk++) {\n                           /* code */\n                           dumpoint+=dum[ii-kk][jj];\n                           dum[ii-kk][jj]=0;\n                           ccounter++;\n                           \n                       }\n                       \n                   }\n                   \n            \n               }\n               \n            }\n\n            point+=dumpoint*pow(2,bai);\n            }\n           // std::cout << point << std::endl;\n            \n       //     std::cout << point << std::endl;\n            ans=max(point,ans);\n\n        }\n    }\n    std::cout << ans << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define M_PI       3.14159265358979323846   // pi\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<ll> VI;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\n\n#define rep(a,n) for(ll a = 0;a < n;a++)\n#define repi(a,b,n) for(ll a = b;a < n;a++)\n\nusing namespace std;\n\nstatic const ll INF = 1e15;\n\ntemplate<typename T>\nstatic inline void chmin(T & ref, const T  value) {\n    if (ref > value) ref = value;\n}\n\ntemplate<typename T>\nstatic inline void chmax(T & ref, const T value) {\n    if (ref < value) ref = value;\n}\n\nconst ll mod = 1000000007;\n\n\nint main() {\n\tll h, w, k;\n\tcin >> h >> w >> k;\n\tvector<vector<ll>> grid(h, vector<ll>(w, 0));\n\trep(i, h) {\n\t\tstring s;\n\t\tcin >> s;\n\t\trep(j, w) {\n\t\t\tgrid[i][j] = s[j] - '0';\n\t\t}\n\t}\n\n\tll u = 0;\n\trep(i, h) {\n\t\trep(j, w) {\t\t\t\n\t\t\tvector<vector<ll>> current = grid;\n\t\t\tll score = 0;\n\t\t\tbool update = true;\n\t\t\tvector<unordered_set<int>> del(w);\n\t\t\tdel[j].insert(i);\n\t\t\tll pow2 = 1;\n\t\t\twhile (update) {\n\t\t\t\tupdate = false;\n\t\t\t\trep(x, w) {\n\t\t\t\t\tconst auto& s = del[x];\n\t\t\t\t\tif (s.size()) {\n\t\t\t\t\t\tint target = h - 1;\n\t\t\t\t\t\tfor (int y = h - 1; y >= 0; y--) {\n\t\t\t\t\t\t\twhile(s.count(target)) {\n\t\t\t\t\t\t\t\ttarget--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (target < 0) {\n\t\t\t\t\t\t\t\tcurrent[y][x] = -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tcurrent[y][x] = current[target][x];\n\t\t\t\t\t\t\t\ttarget--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//if (i == 3 && j == 2) {\n\t\t\t\t//\tcout << \"i:\" << pow2 << endl;\n\t\t\t\t//\trep(y, h) {\n\t\t\t\t//\t\trep(x, w) {\n\t\t\t\t//\t\t\tcout << current[y][x] << \" \";\n\t\t\t\t//\t\t}\n\t\t\t\t//\t\tcout << endl;\n\t\t\t\t//\t}\n\t\t\t\t//\tcout << \"del list:\" << endl;\n\t\t\t\t//\tvector<P> pp;\n\t\t\t\t//\trep(i, w) {\n\t\t\t\t//\t\tfor (auto c : del[i]) {\n\t\t\t\t//\t\t\tpp.emplace_back(c, i);\n\t\t\t\t//\t\t}\n\t\t\t\t//\t}\n\t\t\t\t//\tfor (auto p : pp) {\n\t\t\t\t//\t\tcout << p.first << \",\" << p.second << \"|\";\n\t\t\t\t//\t}\n\t\t\t\t//\tcout << endl;\n\t\t\t\t//}\n\t\t\t\trep(i, w) del[i].clear();\n\t\t\t\trep(y, h) {\n\t\t\t\t\tint left = 0;\n\t\t\t\t\tint right = 0;\n\t\t\t\t\twhile (left < w && right < w) {\n\t\t\t\t\t\tif (current[y][left] == -1) {\n\t\t\t\t\t\t\tleft++;\n\t\t\t\t\t\t\tright = left;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (right < w && current[y][left] == current[y][right]) {\n\t\t\t\t\t\t\tright++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (right - left >= k) {\n\t\t\t\t\t\t\tfor (int a = left; a < right; a++) {\n\t\t\t\t\t\t\t\t//assert(current[y][a] != -1);\n\t\t\t\t\t\t\t\t//if (i == 3 && j == 2) {\n\t\t\t\t\t\t\t\t//\tcout << \"add:\" << y << \",\" << a << \",\" << pow2 * current[y][a] << endl;\n\t\t\t\t\t\t\t\t//}\n\t\t\t\t\t\t\t\tscore += pow2 * current[y][a];\n\t\t\t\t\t\t\t\tdel[a].insert(y);\n\t\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tleft = right + 1;\n\t\t\t\t\t\t\tright++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tleft++;\n\t\t\t\t\t\t\tright = left;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpow2 *= 2;\n\t\t\t}\n\t\t\tchmax(u, score);\n\t\t}\n\t}\n\tcout << u << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=100003;\n\nll rui(ll a,ll b){\n    if(b==1) return a%mod;\n    else if(b==0) return 1;\n    else if(b%2==0) return (rui(a,b/2)*rui(a,b/2))%mod;\n    else return (rui(a,b-1)*a)%mod;\n}\n\n\nint main(){\n    \n    int H,W,K;cin>>H>>W>>K;\n    vector<vector<int>> S(H,vector<int>(W+1,-1)),T(H,vector<int>(W+1,-1));\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            char a;cin>>a;\n            T[i][j]=(a-'0');\n        }\n    }\n    \n    int ans=0;\n    \n    for(int y=0;y<H;y++){\n    for(int z=0;z<W;z++){\n        \n        for(int i=0;i<H;i++){\n            for(int j=0;j<W+1;j++){\n                S[i][j]=T[i][j];\n            }\n        }\n        S[y][z]=-1;\n        for(int i=H-2;i>=0;i--){\n            if(S[i][z]==-1) continue;\n            int now=i;\n            while(1){\n                if(now!=H-1&&S[now+1][z]==-1){\n                    swap(S[now][z],S[now+1][z]);\n                    now++;\n                }else break;\n            }\n        }\n        \n        int score=0,cnt=0;\n        bool flag=true;\n        while(flag){\n            flag=false;\n            int sum=0;\n            for(int i=0;i<H;i++){\n                int ren;\n                if(S[i][0]!=-1) ren=1;\n                else ren=0;\n                for(int j=1;j<W+1;j++){\n                    if(S[i][j]==S[i][j-1]&&S[i][j]!=-1) ren++;\n                    else{\n                        if(ren>=K){\n                            sum+=ren*S[i][j-1];\n                            for(int p=j-ren;p<j;p++){\n                                S[i][p]=-1;\n                            }\n                        }\n                        if(S[i][j]==-1) ren=0;\n                        else ren=1;\n                    }\n                }\n            }\n            if(sum>0) flag=true;\n            score+=rui(2,cnt)*sum;\n            cnt++;\n            //cout<<z<<\" \"<<sum<<endl;\n            for(int j=0;j<W;j++){\n                for(int i=H-2;i>=0;i--){\n                    if(S[i][j]==-1) continue;\n                    int now=i;\n                    while(1){\n                        if(now!=H-1&&S[now+1][j]==-1){\n                            swap(S[now][j],S[now+1][j]);\n                            now++;\n                        }else break;\n                    }\n                }\n            }\n        }\n        ans=max(ans,score);\n    }\n    }\n    cout<<ans<<endl;\n    \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nll MOD = 1000000007;\n\n#define vec              vector<int>\n#define vecll            vector<ll>\n#define vecd             vector<double>\n#define vecst            vector<string>\n#define vecb             vector<bool>\n#define v2(v,n,m,init)   vector<vector<int>>  v(n, vector<int>(m, init))\n#define vb2(v,n,m,init)  vector<vector<bool>> v(n, vector<bool>(m, init))\n#define vll2(v,n,m,init) vector<vector<ll>>   v(n, vector<ll>(m, init))\n\n#define rep(i,n)         for(ll i=(ll)0; i<(ll)n; i++)\n#define REP(i,m,n)       for(ll i=(ll)m; i<(ll)n; i++)\n#define arr(var, n)      vec var(n); rep(i,n){cin >> var[i];}\n#define arrll(var, n)    vecll var(n); rep(i,n){cin >> var[i];}\n#define arrst(var, n)    vecst var(n); rep(i,n){cin >> var[i];}\n#define all(var)         (var).begin(), (var).end()\n#define sortall(var)     sort(all(var))\n#define uniqueall(v)     v.erase(unique(v.begin(), v.end()), v.end());\n#define pb(var)          push_back(var)\n#define prt(var)         cout << (var) << \"\\n\"\n#define prtd(n, var)     cout << fixed << setprecision(n) << (var) << \"\\n\"\n#define prtfill(n, var)  cout << setw(n) << setfill('0') << (var);\n#define prt2(v1, v2)     cout << (v1) << \" \" << (v2) << \"\\n\"\n#define prt3(v1, v2, v3) cout << (v1) << \" \" << (v2) << \" \" << (v3) << \"\\n\"\n#define prtall(v)        rep(i,v.size()){cout<<v[i]<<(i!=v.size()-1?\" \":\"\\n\");}\ntemplate <typename T>\nbool chmax(T &a, const T& b){if(a<b){a=b; return true;} return false;}\ntemplate <typename T>\nbool chmin(T &a, const T& b){if(a>b){a=b; return true;} return false;}\n//------------------------------------------------------------------\n\nvector<string> drop(vector<string> s){\n  vector<string> r;\n  int h = s.size();\n  int w = s[0].size();\n  rep(i,h){\n    string tmp=\"\";\n    rep(j,w){\n      tmp.push_back('0');\n    }\n    r.push_back(tmp);\n  }\n  rep(i,w){\n    int id=h-1;\n    for(int j=h-1; j>-1; j--){\n      if(s[j][i]!='0'){\n        r[id][i]=s[j][i];\n        id--;\n      }\n    }\n  }\n  return r;\n}\n\nint main(void){\n  int h, w, k;\n  cin >> h >> w >> k;\n  arrst(s,h);\n\n  int ans=0;\n  if(k>=4){\n    prt(ans);\n    return 0;\n  }\n  rep(delh,h){\n    rep(delw,w){\n      int anstmp=0;\n      vector<string> t = s;\n      t[delh][delw] = '0';\n      t = drop(t);\n      int p=1;\n      //prt(\"-----------------------\");\n      rep(x,h+2){\n        if(x!=0) p*=2;\n        int add=0;\n        /*\n        prt2(\"from =====>\", x);\n\n        rep(p,h){\n          rep(q,w){\n            cout << t[p][q] << (q!=w-1 ? \" \" : \"\\n\");\n          }\n        }\n        */\n\n        rep(a,h){\n          rep(b,w){\n            int tmp = t[a][b];\n            if(tmp=='0') continue;\n            int c=b;\n            int ct=0;\n            while(c<w){\n              if(t[a][c]==tmp) ct++, c++;\n              else {\n                break;\n              }\n            }\n            if(ct>=k){\n              rep(i,ct){\n                add += t[a][b+i]-'0';\n                t[a][b+i]='0';\n              }\n            }\n          }\n        }\n        /*\n        prt2(\"to =====>\", x);\n        rep(p,h){\n          rep(q,w){\n            cout << t[p][q] << (q!=w-1 ? \" \" : \"\\n\");\n          }\n        }\n        */\n\n        anstmp += add*p;\n        //prt3(\"score :\", anstmp, add*p);\n        t = drop(t);\n      }\n      chmax(ans, anstmp);\n    }\n  }\n\n\n  prt(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n///////////////////////////////////////////\nconst long long int INF = 2*1e13;\nconst long long int Mod = 1000000007;\nusing ll = long long int; using ci = const int;\nusing vi = vector<int>;  using Vi = vector<long long int>;\nusing P = pair<int, int>;  using PLL = pair<ll, ll>;\nusing matrix = vector<vector<ll>>;\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define all(x) (x).begin(),(x).end()\n#define rep(i,N) for(ll i = 0; i < (ll)N; i++)\n#define repi(i,a,b) for(ll i = ll(a); i < ll(b); ++i)\ntemplate<class T>bool chmax(T &former, const T &b) { if (former<b) { former=b; return true; } return false; }\ntemplate<class T>bool chmin(T &former, const T &b) { if (b<former) { former=b; return true; } return false; }\ntemplate<class T>T sqar(T x){ return x*x; }//sqrt(x)は平方根;\n#define Sort(v) std::sort(v.begin(), v.end(), std::greater<decltype(v[0])>()) //降順でVをソート\ntemplate<class T> inline void princ(T x){cout<<x<<\" \";}; \ntemplate<class T> inline void print(T x){cout<<x<<\"\\n\";};\ntemplate<class T> inline void Yes(T condition){ if(condition) cout << \"Yes\" << endl; else cout << \"No\" << endl; }\ntemplate<class T> inline void YES(T condition){ if(condition) cout << \"YES\" << endl; else cout << \"NO\" << endl; }\n///////////////////////////////////////////////////////////////////////////////////\n\nll h,w,K;\nll ary[30][30];\nll ary_[30][30];\nvoid _set(){\n    rep(i,30)rep(j,30){\n        ary[i][j] = ary_[i][j];\n    }\n}\nll era(ll num){\n    ll tmp=10,ct=0;\n    ll ans = 0;\n    rep(i,h){\n        rep(j,w){\n            if(tmp == ary[j][i] && ary[j][i]!=-1){\n                ct++;\n            }else{\n                if(ct>=K){\n                    ans += ary[j-1][i]*ct;\n                    rep(k,ct){\n                        ary[j-k-1][i]=-1;\n                    }\n                }\n                ct = 1;\n                tmp = ary[j][i];\n            }\n        }\n        if(ct>=K){\n            ans += ary[w-1][i]*ct;\n            rep(k,ct){\n                ary[w-1-k][i]=-1;\n            }\n        }\n        tmp = 10;\n        ct = 0;\n    }\n    ll tp = 1;\n    rep(i,num)tp*=2;\n    return ans*tp;\n}\n\nvoid down(){\n    vector<vi> tmp(w);\n    rep(j,w){\n        for(int i = h-1;i>=0;i--){\n            if(ary[j][i]==-1){\n                tmp[j].pb(i);\n            }else{\n                if(tmp[j].size()!=0){\n                    ary[j][tmp[j][0]]=ary[j][i];\n                    ary[j][i]=-1;\n                    tmp[j].pb(i);\n                    tmp[j].erase(tmp[j].begin());\n                }\n            }\n        }\n    }\n}\n\n\n\nint main(){\n    cin.tie(0);ios::sync_with_stdio(false);\n    //std::cout<<std::fixed<<std::setprecision(30);\n    cin>>h>>w>>K;\n    string s;\n    rep(i,h){\n        cin>>s;\n        rep(j,w){\n            ary_[j][i] = (s[j] - '0');\n        }\n    }\n    ll tmp = 0,ans = 0;\n    rep(i,w)rep(j,h){\n        _set();\n        ary[i][j] = -1;\n        down();\n        tmp = 0;\n        rep(i,h*w){\n            ll tp = era(i);\n            if(tp==0)break;\n            else{\n                tmp += tp;\n                down();\n            }\n        }\n        chmax(ans,tmp);\n    }\n    print(ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <set>\n#include <algorithm>\n\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst long long INF = 1LL<<60;\nconst double PI=3.14159265358979323846;\nconst int NMAX=100005;\nusing namespace std;\n\n\n\nint main(){\n    int h, w, k;\n    cin >> h >> w >> k;\n    vector<vector<ll> > c(w,vector<ll>(h));\n    for(int i = h-1; i >= 0; i--){\n        for(int j = 0; j < w; j++){\n            char tmp;\n            cin >> tmp;\n            c[j][i] = tmp-'0';\n        }\n    }\n\n    ll ans = 0;\n    for(int i = 0; i < h-1; i++){\n        for(int j = 0; j < w; j++){\n            // first\n            auto d = c;\n            ll cnt = 0;\n            ll ml = 1;\n            d[j].erase(d[j].begin()+i);\n\n            bool changed = true;\n            while(changed){\n                changed = false;\n                for(int l = h-1; l >= 0; l--){\n                    ll col = 0;\n                    ll num = -1;\n                    ll sw = -1;\n                    for(int m = 0; m < w; m++){\n                        if(d[m].size() < l+1){\n                            if(col >= k){\n                                for(int p = sw; p < m-1; p++){\n                                    d[p].erase(d[p].begin()+l);\n                                }\n                                cnt += num*col*ml;\n                                changed = true;\n                            }\n                            col = 0;\n                            num = -1;\n                            sw = -1;\n                            continue;\n                        } else {\n                            if(d[m][l] == num){\n                                col++;\n                                continue;\n                            } else {\n                                if(col >= k){\n                                    for(int p = sw; p < m-1; p++){\n                                        d[p].erase(d[p].begin()+l);\n                                    }\n                                    cnt += num*col*ml;\n                                    changed = true;\n                                }\n                                col = 1;\n                                num = d[m][l];\n                                sw = m;\n                            }\n                        }\n                    }\n                    \n                    if(col >= k){\n                        for(int p = sw; p < w; p++){\n                            d[p].erase(d[p].begin()+l);\n                        }\n                        cnt += num*col*ml;\n                        changed = true;\n                    }\n                }\n                ml *= 2;\n            }\n            ans = max(ans, cnt);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint p[100][100], q[100][100], H, W, K;\nint chain(){\n    int score = 0, cnt = 0;\n    while (true)\n    {\n        int r = 0;\n        for (int i = 0; i < H; i++)\n        {\n            int L = 0;\n            for (int j = 0; j <= W; j++)\n            {\n                if(q[i][j] != q[i][L] || q[i][j] == 11){\n                    if(j - L >= K){\n                        for(int k = L; k < j; k++){r += q[i][k]; q[i][k] = 11;}\n                    }\n                    L = j;\n                }\n            }\n        }\n        for(int i = 0; i < W; i++){\n            vector<int> W;\n            for(int j = H - 1; j >= 0; j--){\n                if(q[j][i] <= 9) W.push_back(q[j][i]);\n            }\n            for(int j = H - 1; j >= 0; j--){q[j][i] = 11;}\n            for(int j = 0; j < W.size(); j++){q[H - 1 - j][i] = W[j];}\n        }\n        if(r == 0) return score;\n        score += r * (1 << cnt); cnt++;\n    }\n}\nint main() {\n    cin >> H >> W >> K;\n    for (int i = 0; i < H; i++)\n    {\n        for (int j = 0; j < W; j++)\n        {\n            char c; cin >> c;\n            if(c == '.')p[i][j] = 11;\n            else {p[i][j] = c - '0';}\n        }\n    }\n    int maxn = 0;\n    for (int i = 0; i < H; i++)\n    {\n        for (int j = 0; j < W; j++)\n        {\n            if(p[i][j] == 11) continue;\n            for (int k = 0; k < H; k++)\n            {\n                for (int l = 0; l < W; l++)\n                {\n                    q[k][l] = p[k][l];\n                }\n            }\n            q[i][j] = 11; vector<int> V;\n            for(int k = H - 1; k >= 0; k--){if(q[k][j] <= 9) V.push_back(q[k][j]);}\n            for(int k = H - 1; k >= 0; k--){ q[k][j] = 11;}\n            for(int k = 0; k < V.size(); k++) { q[H-1-k][j] = V[k];}\n            maxn = max(maxn, chain());\n        }\n    }\n    cout << maxn << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define int long long\nint H, W, K;\nint A[30][30];\nint B[31][31];\n\nvoid move() {\n  for (int x=0; x<W; x++) {\n    int h = 0;\n    for (int y=0; y<H; y++) {\n      if (B[x][y] == 0) continue;\n      B[x][h++] = A[x][y];\n    }\n    for (int y=h; y<H; y++) {\n      B[x][y] = 0;\n    }\n  }\n}\n\nint score() {\n  int s = 0;\n  for (int y=0; y<H; y++) {\n    int l = -1, lc = 0;\n    for (int x=0; x<=W; x++) {\n      if (B[x][y] != 0 && B[x][y] == lc) continue;\n      else {\n        if (x-l >= K) {\n          s += lc*(x-l);\n          for (int xx=l; xx<x; xx++) B[xx][y] = 0;\n        }\n      }\n      lc = B[x][y];\n      l = x;\n    }\n  }\n  return s;\n}\n\nlong long solve(int sx, int sy) {\n  for (int x=0; x<W; x++) {\n    for (int y=0; y<H; y++) {\n      B[x][y] = A[x][y];\n    }\n  }\n  B[sx][sy] = 0;\n  move();\n  long long s = 0;\n  for (int i=0; ; i++) {\n    int f = score();\n    if (f == 0) break;\n    s += (1LL<<i) * f;\n    move();\n  }\n  return s;\n}\n\nsigned main() {\n  cin >> H >> W >> K;\n  for (int i=0; i<H; i++) {\n    for (int j=0; j<W; j++) {\n      char c;\n      cin >> c;\n      A[j][H-1-i] = (int)(c - '0');\n    }\n  }\n  long long s = 0;\n  for (int x=0; x<W; x++) {\n    for (int y=0; y<H; y++) {\n      s = max(s, solve(x, y));\n    }\n  }\n  cout << s << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC diagnostic ignored \"-Wunused-variable\" \n#include <bits/stdc++.h>\nusing namespace std;\n\n#define BOOST\n#ifdef BOOST\n#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/multiprecision/cpp_dec_float.hpp>\n#include <boost/range/adaptor/reversed.hpp>\nusing namespace boost;\nusing ml = boost::multiprecision::cpp_int;\nusing md = boost::multiprecision::cpp_dec_float_100;\n#define forir(i, ...) if(ll i=(ll)v.size())for(__VA_ARGS__)if(i--,1)\n#define eachr(i, e, c) forir(i, auto &&e: adaptors::reverse(c))\n#endif\n\n/***** type *****/\nusing ll = long long;\nusing ld = long double;\nusing pll = pair<long long, long long>;\ntemplate <class T> using vt = vector<T>;\ntemplate <class T> using vvt = vector<vector<T>>;\ntemplate <class T> using vvvt = vector<vector<vector<T>>>;\n/***** define *****/\n#define all(c) (c).begin(), (c).end()            // begin to end\n#define coutd cout << fixed << setprecision(10)  // cout double\n#define output(x) do{cout<<x;return 0;}while(0)  // cout return\n#define rep(i, b, e) for (ll i = b; i < e; i++)  // repeat\n#define repr(i, b, e) for (ll i = b; e < i; i--) // repeat reverse\n#define fori(i, ...) if (ll i = -1) for(__VA_ARGS__) if (i++, 1)\n#define each(i, e, c) fori (i, auto&& e: c)      // for each\n/***** const value *****/\n#define llong_max 9223372036854775807            // 9 * 10^18\n#define ldbl_max 1.79769e+308                    // 1.7 * 10^308\n#define pi 3.1415926535897932                    // 3.14 ...\n/***** lambda *****/\nauto Ceil = [] // if (a % b != 0) return a / b + 1;\n(auto x) { return (ll)ceil(x); };\nauto Count = [] // long long count value\n(auto b, auto e, auto x) { return (ll)count(b, e, x); };\nauto CtoL = [] // char to number\n(auto c) { return (ll)c - (ll)'0'; };\nauto LtoC = [] // number to char\n(auto n) { return (char)('0' + n); };\nauto Pow = [] // long long pow\n(auto a, auto b) { return (ll)pow(a, b); };\nauto Pow2 = [] // long long pow2\n(auto n) { return (1LL << n); };\nauto Pow10 = [] // long long pow10\n(auto n) { return (ll)pow(10, n); };\nauto Size = []  // long long collection size\n(auto& c) { return (ll)(c).size(); };\nauto Sum = [] // long long accumulate\n(auto b, auto e) { return accumulate(b, e, 0LL); };\n\n/***** template *****/\ntemplate <class T> void MakeVVT\n(ll ys, ll xs, vvt<T>& v, T fill = T())\n{\t// vector<vector<T>> resize + fill\n\tv.resize(ys); rep(y, 0, ys) v[y].resize(xs, fill);\n}\ntemplate <class T> void MakeVVVT\n(ll zs, ll ys, ll xs, vvvt<T>& v, T fill = T())\n{\t// vector<vector<vector<T>>> resize + fill\n\tv.resize(zs); rep(z, 0, zs) MakeVVT(ys, xs, v[z], fill);\n}\ntemplate <class T> void InputVT\n(ll xs, vt<T>& v, T fix = T())\n{\t// input vector<T> (T != struct) + fix\n\tv.resize(xs); rep(i, 0, xs) { cin >> v[i]; v[i] += fix; }\n}\ntemplate <class T> void InputVVT\n(ll ys, ll xs, vvt<T>& v, T fix = T())\n{\t// input vector<vector<T>> (T != struct) + fix\n\tMakeVVT(ys, xs, v, fix);\n\trep(y, 0, ys) rep(x, 0, xs) { cin >> v[y][x]; v[y][x] += fix; }\n}\ntemplate <class T> void InputVVVT\n(ll zs, ll ys, ll xs, vvvt<T>& v, T fix = T())\n{\t// input vector<vector<vector<T>>> (T != struct) + fix\n\tv.resize(zs); rep(z, 0, zs) InputVVT(ys, xs, v[z], fix);\n}\n\n/**************************************/\n/********** BEGIN OF NYA LIB **********/\n/**************************************/\n\nnamespace NyaGadget {}\n\nnamespace NyaGadget\n{\n\t/*** ランレングス圧縮ライブラリ ***/\n\n\ttemplate <class T> struct RunLengthEncodingResult\n\t{\t// ランレングス圧縮の結果を格納する構造体\n\t\tlong long begin = 0; // 区間開始位置\n\t\tlong long end = 0;   // 区間終了位置\n\t\tstd::vector<T> sub;  // 区間データ\n\t};\n\n\ttemplate <> struct RunLengthEncodingResult<std::string>\n\t{\t// ランレングス圧縮の結果を格納する構造体\n\t\tlong long begin = 0; // 区間開始位置\n\t\tlong long end = 0;   // 区間終了位置\n\t\tstd::string sub;     // 区間データ\n\t};\n\n\tstruct DS_NyaaRLE\n\t{\n\t\t/**\n\t\t@brief 文字列のランレングス圧縮\n\t\t@param s 圧縮する文字列\n\t\t@param res 圧縮結果\n\t\t**/\n\t\tstatic void Run(std::string& s, std::vector<RunLengthEncodingResult<std::string>>& res)\n\t\t{\n\t\t\tres.push_back({ 0, 0, \"\" });\n\t\t\tfor (long long i = 0; i < (long long)s.size(); i++)\n\t\t\t{\n\t\t\t\tif (i == (long long)s.size() - 1)\n\t\t\t\t{\n\t\t\t\t\tres.back().end = i + 1;\n\t\t\t\t\tres.back().sub = s.substr(res.back().begin, i + 1 - res.back().begin);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (s[i] != s[i + 1])\n\t\t\t\t{\n\t\t\t\t\tres.back().end = i + 1;\n\t\t\t\t\tres.back().sub = s.substr(res.back().begin, i + 1 - res.back().begin);\n\t\t\t\t\tres.push_back({ i + 1, 0, \"\" });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t@brief 配列のランレングス圧縮\n\t\t@param v 圧縮する配列\n\t\t@param res 圧縮結果\n\t\t**/\n\t\ttemplate <class T> static void Run(std::vector<T>& v, std::vector<RunLengthEncodingResult<T>>& res)\n\t\t{\n\t\t\tres.push_back({ 0, 0, std::vector<T>() });\n\t\t\tfor (long long i = 0; i < (long long)v.size(); i++)\n\t\t\t{\n\t\t\t\tif (i == (long long)v.size() - 1)\n\t\t\t\t{\n\t\t\t\t\tres.back().end = i + 1;\n\t\t\t\t\tfor (long long j = res.back().begin; j < i + 1; j++) res.back().sub.push_back(v[j]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!IsSame(v[i], v[i + 1]))\n\t\t\t\t{\n\t\t\t\t\tres.back().end = i + 1;\n\t\t\t\t\tfor (long long j = res.back().begin; j < i + 1; j++) res.back().sub.push_back(v[j]);\n\t\t\t\t\tres.push_back({ i + 1, 0, std::vector<T>() });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttemplate <class T> static bool IsSame(T& l, T& r)\n\t\t{\t// lとrが同値かどうか調べる\n\t\t\treturn l == r;\n\t\t}\n\t};\n}\n\n/**************************************/\n/*********** END OF NYA LIB ***********/\n/**************************************/\n\nusing namespace NyaGadget;\n//using mll = NT_ModLL< 1000000007 >;\n//using mll = NT_ModLL< 998244353 >;\n\nvoid NyaaDelete(vvt<ll>& grid, ll K, ll& res)\n{\n\tll count = 1;\n\tll H = Size(grid);\n\tll W = Size(grid[0]);\n\twhile (1)\n\t{\n\t\tll score = 0;\n\t\trep(y, 0, H)\n\t\t{\n\t\t\tvt<ll> test(W);\n\t\t\trep(x, 0, W) test[x] = grid[x][y];\n\t\t\tstd::vector<RunLengthEncodingResult<ll>> rleRes;\n\t\t\tDS_NyaaRLE::Run(test, rleRes);\n\n\t\t\teach(i, e, rleRes)\n\t\t\t{\n\t\t\t\tif (e.sub[0] == 0) continue;\n\t\t\t\tif (K <= Size(e.sub))\n\t\t\t\t{\n\t\t\t\t\trep(xx, e.begin, e.end) grid[xx][y] = 0;\n\t\t\t\t\tscore = Pow2(count) * e.sub[0] * Size(e.sub);\n\t\t\t\t\tres += score;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvvt<ll> test; MakeVVT(W, H, test);\n\t\trep(x, 0, W)\n\t\t{\n\t\t\tll yy = 0;\n\t\t\trep(y, 0, H) if (grid[x][y] != 0) test[x][yy++] = grid[x][y];\n\t\t}\n\t\tgrid = test;\n\t\tif (score == 0) return;\n\t\t++count;\n\t}\n}\n\nint main(void)\n{\n\tll H, W, K; cin >> H >> W >> K;\n\tvvt<ll> c; MakeVVT(W, H, c);\n\trepr(y, H - 1, -1)\n\t{\n\t\tstring test; cin >> test;\n\t\trep(x, 0, W) c[x][y] = CtoL(test[x]);\n\t}\n\n\tll ans = 0;\n\trep(x, 0, W) rep(y, 0, H)\n\t{\n\t\tvvt<ll> test = c;\n\t\trep(yy, y + 1, H) test[x][yy - 1] = test[x][yy];\n\t\ttest[x].back() = 0;\n\t\tll res = 0;\n\n\t\tNyaaDelete(test, K, res);\n\t\tans = max(ans, res);\n\t}\n\tcout << ans / 2 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <deque>\n#include <numeric>\n#include <bitset>\n#include <iomanip>\n#include <cassert>\n#include <chrono>\n#include <random>\n#include <limits>\n#include <iterator>\n#include <functional>\n#include <sstream>\n#include <complex>\nusing namespace std;\n\nusing ll = long long;\nusing ull = uint64_t;\nusing P = pair<int, int>;\nconstexpr double EPS = 1e-9;\nconstexpr int INF = 1001001001;\nconstexpr int mod = 1000000007;\n// constexpr int mod = 998244353;\n\ntemplate<class T>\ninline bool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\ntemplate<class T>\ninline bool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int H, W, K;\n    cin >> H >> W >> K;\n    vector<string> s(H);\n    for(int i = 0; i < H; ++i)  cin >> s[i];\n    vector<vector<int>> C(H, vector<int>(W));\n    for(int i = H - 1; i >= 0; --i){\n        for(int j = 0; j < W; ++j){\n            C[i][j] = s[H - i - 1][W - j - 1] - '0';\n        }\n    }\n\n    auto update = [&](vector<vector<int>>& v){\n        vector<int> idx(W, 0);\n        for(int i = 0; i < H; ++i){\n            for(int j = 0; j < W; ++j){\n                if(v[i][j]){\n                    if(idx[j] == i) ++idx[j];\n                    else{\n                        v[idx[j]++][j] = v[i][j];\n                        v[i][j] = 0;\n                    }\n                }\n            }\n        }\n        return;\n    };\n\n    int ans = 0;\n    for(int x = 0; x < H; ++x){\n        for(int y = 0; y < W; ++y){\n            vector<vector<int>> Board = C;\n            Board[x][y] = 0;\n            update(Board);\n\n            bool IsFinished = false;\n            int Score = 0, Base = 1;\n            while(!IsFinished){\n                IsFinished = true;\n                int Sum = 0;\n                for(int i = 0; i < H; ++i){\n                    for(int j = 0; j < W;){\n                        int len = 1;\n                        for(int k = j + 1; k < W; ++k){\n                            if(Board[i][k] == Board[i][j])  ++len;\n                            else    break;\n                        }\n                        if(Board[i][j] == 0){\n                            j += len;\n                            continue;\n                        }\n                        if(len >= K){\n                            IsFinished = false;\n                            Sum += Board[i][j] * len;\n                            for(int k = 0; k < len; ++k)    Board[i][j + k] = 0;\n                        }\n                        j += len;\n                    }\n                }\n\n                if(!IsFinished){\n                    Score += Base * Sum;\n                    update(Board);\n                    Base <<= 1;\n                }\n            }\n            \n            chmax(ans, Score);\n        }\n    }\n\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    Problem 93\n    https://atcoder.jp/contests/s8pc-3/tasks/s8pc_3_b\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n/* typedef */\ntypedef long long ll;\ntypedef pair<int, int> pii;\n/* class */\nclass pazzle {\n    public:\n    int H, W, K, ans;\n    vector<vector<int> > v;\n    pazzle (int H, int W, int K, vector<vector<int> > v)\n    : H(H), W(W), K(K), v(v) {}\n    bool del() {\n        int ret = false;\n        for (int i = 0; i < H; i++) {\n            int r = 0;\n            for (int l = 0; l < W; l++) {\n                int tmp = v[i][r];\n                while (v[i][r] == -1) {\n                    r++;\n                    l++;\n                }\n                while (v[i][r] == v[i][r + 1]){\n                    r++;\n                    tmp += v[i][r];\n                }\n                if (r - l + 1>= K) {\n                    for (int k = l; k <= r; k++) v[i][k] = -1;\n                    ans += tmp;\n                    ret = true;\n                }\n                l = r;\n                r++;\n            }\n        }\n        return ret;\n    }\n    void move() {\n        for (int i = 0; i < W; i++) {\n            for (int j = H - 1; j > 0; j--) {\n                if (v[j][i] == -1) {\n                    int k = j - 1;\n                    while (v[k][i] == -1 && k > 0) k--;\n                    if (v[k][i] != -1) swap(v[k][i], v[j][i]);\n                }\n            }\n        }\n    }\n    void setAns() { ans = 0; }\n    ll gameStart() {\n        ll ret = 0;\n        move();\n        setAns();\n        for (int i = 0; del(); i++){\n            move();\n            ret += pow(2, i) * ans;\n            setAns();\n        }\n        return ret;\n    }\n};\n/* constant */\nconst int INF = (1 << 30);\n/* global variables */\n/* function */\n/* main */\nint main(){\n    int H, W, K;\n    cin >> H >> W >> K;\n    vector<string> vs(H);\n    for (int i = 0; i < H; i++) cin >> vs[i];\n    vector<vector<int> > v(H, vector<int> (W + 1, -2));\n    for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) {\n        if (vs[i][j] == '.') v[i][j] = 11;\n        else v[i][j] = vs[i][j] - '0';\n    }\n    if (K == 1) {\n        int ans = 0;\n        int minValue = INF;\n        for (auto vi : v) {\n            ans += accumulate(vi.begin(), vi.end(), 0);\n            minValue = min(*min_element(vi.begin(), vi.end()), minValue);\n        }\n        cout << ans  - minValue << '\\n';\n        return 0;\n    }\n    else if (K >= 4) {\n        cout << 0 << '\\n';\n        return 0;\n    }\n    ll ans = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int tmp = v[i][j];\n            v[i][j] = -1;\n            pazzle P = pazzle(H, W, K, v);\n            ans = max(ans, P.gameStart());\n            v[i][j] = tmp;\n        }\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[35][35];\nint main() {\n    int H, W, K; cin >> H >> W >> K;\n    for(int i=0; i<H; ++i){\n        string S;\n        cin >> S;\n        for(int j=0; j<W; ++j) C[i][j]=(S[j]-'0');\n    }\n    int ans=0;\n    for(int i=0; i<W; ++i){\n        int ban[35][35], now=0, mul=1;\n        for(int p=0; p<35; ++p) for(int q=0; q<35; ++q) ban[p][q]=C[p][q];\n        ban[H-1][i]=0;\n        bool flag=true;\n        while(flag){\n            int sum=0;\n            for(int j=0; j<W; ++j){\n                int cnt=H-1;\n                for(int k=H-1; k>=0; --k){\n                    if(ban[k][j]>0){\n                        ban[cnt][j]=ban[k][j];\n                        --cnt;\n                    }\n                }\n            }\n            flag=false;\n            for(int j=0; j<H; ++j){\n                for(int k=0; k<W; ++k){\n                    if(ban[j][k]>0){\n                        int ser=k;\n                        while(ban[j][ser]==ban[j][k]) ++ser;\n                        if(ser-k>=K){\n                            sum += ban[j][k]*(ser-k);\n                            flag=true;\n                            for(int v=k; v<ser; ++v) ban[j][v]=0;\n                        }\n                    }\n                }\n            }\n            now += sum*mul;\n            mul *= 2;\n        }\n        ans=max(ans, now);\n    }\n    cout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E) REPS(i, S, E)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, S, E) DEPS(i, S, E)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline vll Mask2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\ninline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\ninline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(5) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(4);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tfriend mll operator / (ll a, const mll &b) { return mll(a)/b; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = 2099999999LL;// 998244353LL;//1000000007LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\n\n\nvoid solve()\n{\n\tll H, W, K;  cin >> H >> W >> K;\n\tvector<string> cstr = cinv<string>(H);\n\tvvll c(H, vll(W));\n\trep(i, 0, H-1) rep(j, 0, W-1){\n\t\tc[i][j] = (ll)(cstr[i][j]-'0');\n\t}\n\n\tll ans = 0;\n\tREPS(si, 0, H-1)REPS(sj, 0, W-1){\n\t\tvvll ban = c;\n\n\t\tll score = 0;\n\t\tban[si][sj] = 0;\n\t\tREPS(i,0,100000){\n\t\t\t//消えた場所を落とす\n\t\t\tREPS(j, 0, W-1){\n\t\t\t\tll idx=H-1;\n\t\t\t\tDEPS(i, 0, H-1){\n\t\t\t\t\tll val = ban[i][j];\n\t\t\t\t\tif (val == 0) continue;\n\t\t\t\t\tban[i][j] = 0;\n\t\t\t\t\tban[idx--][j] = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//現盤面の消える場所を調べる\n\t\t\tll sum=0;\n\t\t\tREPS(i, 0, H-1){\n\n\t\t\t\tll ren=1;\n\t\t\t\tREPS(j, 0, W-1){\n\t\t\t\t\t//右となりが同じ時\n\t\t\t\t\tif (j!=W-1 && ban[i][j]==ban[i][j+1]){\n\t\t\t\t\t\tren++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//異なる＆消滅\n\t\t\t\t\telse if (ren>=K){\n\t\t\t\t\t\tsum += ren*ban[i][j];\n\t\t\t\t\t\tREPS(k, 0, ren-1) ban[i][j-k]=0;\n\t\t\t\t\t\tren=1;\n\t\t\t\t\t}\n\t\t\t\t\telse{//異なる＆消滅しない\n\t\t\t\t\t\tren=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sum == 0) break;\n\t\t\tscore += sum * POW(2LL, i);\n\t\t}\n\t\tchmax(ans, score);\n\t}\n\tcout << ans << '\\n';\n}\n\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst long long INF = 1001001001;\nconst long long MOD = 1000000007;\nconst double EPS = 1e-10;\n\nint grid[33][33]={};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int h,w,k;\n    cin>>h>>w>>k;\n    for(int i=0;i<h;i++){\n        string s;\n        cin>>s;\n        for(int j=0;j<w;j++)grid[i+1][j]=s[j]-'0';\n    }\n    int ans=0;\n    for(int i=1;i<=h;i++){\n        for(int j=0;j<w;j++){\n            int newGrid[33][33]={};\n            for(int l=1;l<=h;l++){\n                for(int m=0;m<w;m++){\n                    newGrid[l][m]=grid[l][m];\n                    if(l==i&&m==j)newGrid[l][m]=0;\n                }\n            }\n            int rmCnt=-1,res=0;\n            bool update=true;\n            while(update){\n                update=false;\n                rmCnt++;\n                for(int l=1;l<=h;l++){\n                    for(int m=0;m<w;m++){\n                        if(newGrid[l][m]==0){\n                            for(int r=l;r>=1;r--)newGrid[r][m]=newGrid[r-1][m];\n                        }\n                    }\n                }\n                for(int l=1;l<=h;l++){\n                    for(int m=0,prv=newGrid[l][0],len=0;m<=w;m++){\n                        if(prv==newGrid[l][m]){\n                            len++;\n                        }else{\n                            if(prv>0&&len>=k){\n                                for(int r=m-len;r<=m-1;r++)newGrid[l][r]=0;\n                                res+=len*prv*pow(2,rmCnt);\n                                update=true;\n                            }\n                            prv=newGrid[l][m],len=1;\n                        }\n                    }\n                }\n            }\n            ans=max(ans,res);\n        }\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair< ll, ll > Pi;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep2(i,n) for(int i=1;i<=(n);i++)\n#define rep3(i,i0,n) for(int i=i0;i<(n);i++)\n#define pb push_back\n#define mod 1000000007\nconst ll INF = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nll gcd(ll a, ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b) {return a/gcd(a,b)*b;}\n#define all(x) x.begin(), x.end()\n#define mp make_pair\nbool compare(Pi a, Pi b) {\n    if(a.first != b.first){\n        return a.first < b.first;\n        \n    }else{\n        return a.second < b.second;\n    }\n}\n\nint ctoi(char c) {\n\tif (c >= '0' && c <= '9') {\n\t\treturn c - '0';\n\t}\n\treturn 0;\n}\nbool In_map(ll y,ll x,ll h,ll w){\n    if(y<0 || x<0 || y>=h || x>=w){\n        return 0;\n    }else{\n        return 1;\n    }\n}\nconst vector<ll> dx{1,0,-1,0};\nconst vector<ll> dy{0,1,0,-1};\n\n\n\nint main() {\n\n    ll H,W,K;\n    cin >>H>>W>>K;\n    vector<string> S(H+1);\n    rep(i,H) cin >>S[i];\n    vector<vector<ll>> R(H+1,vector<ll>(W+1));\n    vector<vector<ll>> R2(H+1,vector<ll>(W+1));\n    rep(i,H) rep(j,W) R[i][j] = ctoi(S[i][j]);\n    R2 = R;\n    if(K<=1){\n        ll ans = 0;\n        ll min = INF;\n        rep(i,H){\n            rep(j,W){\n                chmin(min,R[i][j]);\n                ans+=R[i][j];\n            }\n        }\n        cout << ans-min<<endl;\n        return 0;\n    }\n\n\n    ll fans = 0;\n    rep(h,H) rep(w,H){\n    ll ans = 0;\n    R=R2;\n    R[h][w] = -1;\n    ll flag = 0;\n    rep(m,H){\n        ll p2 =pow(2,m); \n        rep(j,W){\n            vector<ll> tmp;\n            rep(i,H){\n                if(R[H-1-i][j] != -1){\n                    tmp.pb(R[H-1-i][j]);\n                }\n            }\n            rep(i,H){\n                if(i<tmp.size()){\n                    R[H-1-i][j] = tmp[i];\n                }else{\n                    R[H-1-i][j] = -1;\n                }\n            }\n        }\n        rep(i,H){\n            ll cnt=0;\n            ll p=-1;\n            rep(j,W){\n                if(R[i][j] == p && R[i][j] != -1){\n                    cnt++;\n                    if(j==W-1){\n                        if(cnt>=K){\n                            flag = 1;\n                            //ans += R[i][j-1]*cnt*p2;\n                            rep(k,cnt){\n                               // R[i][j-k] = -1;\n                            }\n                        }\n                    }\n                }else{\n                    if(cnt>=K){\n                        flag = 1;\n                        //ans += R[i][j-1]*cnt*p2;\n                        rep(k,cnt){\n                            //R[i][j-k-1] = -1;\n                        }\n                    }\n                    cnt = 1;\n                }\n                \n\n                p = R[i][j];\n            }\n        \n        \n        }\n        /*rep(i,H){\n            rep(j,W){\n                cout << R[i][j]<<\" \";\n            }\n            cout <<endl;\n        }*/\n        if(flag ==0) break;\n    }\n\n\n        chmax(fans,ans);\n    }\n\n    cout << fans<<endl;\n    \n    return 0;\n    \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\ntemplate<class T> inline void YES(T condition){ if(condition) cout << \"YES\" << endl; else cout << \"NO\" << endl; }\ntemplate<class T> inline void Yes(T condition){ if(condition) cout << \"Yes\" << endl; else cout << \"No\" << endl; }\ntemplate<class T> inline void POSS(T condition){ if(condition) cout << \"POSSIBLE\" << endl; else cout << \"IMPOSSIBLE\" << endl; }\ntemplate<class T> inline void Poss(T condition){ if(condition) cout << \"Possible\" << endl; else cout << \"Impossible\" << endl; }\ntemplate<class T> inline void First(T condition){ if(condition) cout << \"First\" << endl; else cout << \"Second\" << endl; }\ntemplate<class T = string, class U = char>int character_count(T text, U character){ int ans = 0; for(U i: text){ ans += (i == character); } return ans; }\nlong power(long base, long exponent, long module){ if(exponent % 2){ return power(base, exponent - 1, module) * base % module; }else if(exponent){ long root_ans = power(base, exponent / 2, module); return root_ans * root_ans % module; }else{ return 1; }}\nstruct position{ int y, x; }; position move_pattern[4] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}}; // double euclidean(position first, position second){ return sqrt((second.x - first.x) * (second.x - first.x) + (second.y - first.y) * (second.y - first.y)); }\ntemplate<class T, class U> string to_string(pair<T, U> x){ return to_string(x.first) + \",\" + to_string(x.second); }\ntemplate<class itr> void array_output(itr start, itr goal){ string ans; for(auto i = start; i != goal; i++){ ans += to_string(*i) + \" \"; } ans.pop_back(); cout << ans << endl; }\ntemplate<class itr> void cins(itr start, itr goal){ for(auto i = start; i != goal; i++){ cin >> (*i); } }\ntemplate<class T> T gcd(T a, T b){ if(a && b){ return gcd(min(a, b), max(a, b) % min(a, b)); }else{ return a; }} template<class T> T lcm(T a, T b){ return a / gcd(a, b) * b; }\n#define mod long(1e9 + 7)\n#define all(x) (x).begin(), (x).end()\n#define bitcount(n) __builtin_popcountl(long(n))\n#define fcout cout << fixed << setprecision(20)\n#define highest(x) (63 - __builtin_clzl(x))\n\nint main(){\n    int H, W, K;\n    cin >> H >> W >> K;\n    string space[H];\n    for(int i = 0; i < H; i++){\n        cin >> space[i];\n    }\n    int ans = 0;\n    for(int i = 0; i < H; i++){\n        for(int j = 0; j < W; j++){\n            if(i != 3 || j != 2){\n                ;\n            }\n            int this_ans = 0;\n            string this_space[H];\n            for(int k = 0; k < H; k++){\n                this_space[k] = space[k];\n            }\n            this_space[i][j] = '0';\n            for(int c = 0; true; c++){\n                for(int k = 0; k < W; k++){\n                    int not_0_count = 0;\n                    for(int l = H - 1; l >= 0; l--){\n                        if(this_space[l][k] != '0'){\n                            char tmp = this_space[l][k];\n                            this_space[l][k] = '0';\n                            this_space[H - not_0_count - 1][k] = tmp;\n                            not_0_count++;\n                        }\n                    }\n                }\n                int broke = 0;\n                for(int k = 0; k < H; k++){\n                    for(int l = 0; l < W; l++){\n                        int serial = 1;\n                        for(; l + serial < W; serial++){\n                            if(this_space[k][l] != this_space[k][l + serial]){\n                                break;\n                            }\n                        }\n                        if(serial >= K && this_space[k][l] != '0'){\n                            broke += (this_space[k][l] - '0') * serial;\n                            for(int m = 0; m < serial; m++){\n                                this_space[k][l + m] = '0';\n                            }\n                        }\n                    }\n                }\n                if(!broke){\n                    break;\n                }else{\n                    this_ans += int(power(2, c, 1e18)) * broke;\n                }\n            }\n            ans = max(ans, this_ans);\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <stack>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n\nusing namespace std;\ntypedef long long int ll;\n#define MAX_H 30\nint field[MAX_H][MAX_H];\nint initField[MAX_H][MAX_H];\n\nint howManySameColorRight(int i,int j,int W,int color){\n\tif( j >= W) return 0;\n\tif(field[i][j] == 0) return 0;\n\tif(color != field[i][j]) return 0;\n\tif(j== W-1 && color == field[i][j]) return 1;\n\treturn howManySameColorRight(i,j+1,W,color) + 1;\n}\n\nvoid banishRightN(int i,int j,int n){\n\tfor(int k = 0; k < n; k++){\n\t\tfield[i][j+k] = 0;\n\t}\n}\n\nvoid moveBlocks(int H,int W){\n\tfor(int i = H-1; i >= 1; i--){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tif(field[i][j] == 0){\n\t\t\t\tfield[i][j] = field[i-1][j];\n\t\t\t\tfield[i-1][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid initializeField(int H,int W){\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tfield[i][j] = initField[i][j];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint H,W,K;\n\tcin>>H>>W>>K;\n\trep(i,H){\n\t\tstring str;\n\t\tcin>>str;\n\t\trep(j,W) initField[i][j] = str[j] - '0';\n\t}\n\tll ans = 0;\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t/*int i = 3;\n\tint j = 2;*/\n\t\t\tll localAns = 0;\n\t\t\tinitializeField(H,W);\n\t\t\tfield[i][j] = 0;\n\t\t\t//p th block banish\n\t\t\tfor(int p = 0; p < H + W; p++){\n\t\t\t\trep(e,H)moveBlocks(H,W);\n\t\t\t\t/*cout<<\"-----------------\"<<endl;\n\t\t\t\trep(a,H){\n\t\t\t\t\trep(b,W){\n\t\t\t\t\t\tcout<<field[a][b]<<\" \";\n\t\t\t\t\t}\n\t\t\t\t\tcout<<endl;\n\t\t\t\t}*/\n\t\t\t\tll banishBlocks = 0;\n\t\t\t\tfor(int k = 0; k < H; k++){\n\t\t\t\t\tfor(int l = 0; l < W; l++){\n\t\t\t\t\t\tint num = field[k][l];\n\t\t\t\t\t\tint blocks = howManySameColorRight(k,l,W,field[k][l]);\n\t\t\t\t\t\tif(blocks >= K){\n\t\t\t\t\t\t\tbanishRightN(k,l,blocks);\n\t\t\t\t\t\t\tbanishBlocks += blocks*num;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlocalAns += pow(2.0,p) * banishBlocks;\n\t\t\t\t//cout<<pow(2.0,p)*banishBlocks<<endl;\n\t\t\t}\n\t\t\tans = max(ans,localAns);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fs first\n#define sc second\n#define pb emplace_back\n#define mp make_pair\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n\nconst int32_t inf = 1001001001;\nconst int64_t infll = 1001001001001001001ll;\nconst int dx[] = {0, -1, 1, 0, -1, 1, -1, 1}, dy[] = {-1, 0, 0, 1, -1, -1, 1, 1};\n\ntemplate <typename T> using vector2d = vector<vector<T>>;\n\n// clang-format off\ntemplate <typename T> void sort(vector<T> &v) { sort(all(v)); }\n// ostream &operator<<(ostream &os, __int128_t value) { if (ostream::sentry(os)) { __uint128_t tmp = value < 0 ? -value : value; char buffer[64]; char *d = end(buffer); do { --d; *d = \"0123456789\"[tmp % 10]; tmp /= 10; } while (tmp != 0); if (value < 0) { --d; *d = '-'; } int len = end(buffer) - d; if (os.rdbuf()->sputn(d, len) != len) { os.setstate(ios_base::badbit); }} return os; }\n// istream &operator>>(istream &is, __int128_t &value) { string in; is >> in; value = 0; for (const char &c : in) { if ('0' <= c && c <= '9') value = 10 * value + (c - '0'); } if (in[0] == '-') value *= -1; return is; }\n// ostream &operator<<(ostream &os, __uint128_t value) { if (ostream::sentry(os)) { char buffer[64]; char *d = end(buffer); do { --d; *d = \"0123456789\"[value % 10]; value /= 10; } while (value != 0); int len = end(buffer) - d; if (os.rdbuf()->sputn(d, len) != len) { os.setstate(ios_base::badbit); }} return os; }\n// istream &operator>>(istream &is, __uint128_t &value) { string in; is >> in; value = 0; for (const char &c : in) { if ('0' <= c && c <= '9') value = 10 * value + (c - '0'); } return is; }\ntemplate <typename T> ostream &operator<<(ostream &os, vector<T> &v) { os << v[0]; for (int i = 1; i < v.size(); ++i) os << \" \" << v[i]; return os; }\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &in : v) is >> in; return is; }\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p) { os << p.fs << \" \" << p.sc; return os; }\ntemplate <typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.fs >> p.sc; return is; }\n\n// struct IoSetup { IoSetup(){ cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10); cerr << fixed << setprecision(10); } } iosetup;\n\ninline int64_t in() { int64_t x = 0; cin >> x; return x; }\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n// clang-format on\n\nsigned main(int argc, char *argv[]) {\n  int h = in(), w = in(), k = in();\n  vector2d<int> c(h, vector<int>(w));\n  for (int i = h - 1; i >= 0; --i) {\n    for (int j = 0; j < w; ++j) {\n      scanf(\"%1d\", &c[i][j]);\n    }\n  }\n\n  int64_t ans = 0;\n  for (int y = 0; y < h; ++y) {\n    for (int x = 0; x < w; ++x) {\n      int score = 0;\n      vector2d<int> C = c;\n      C[y][x] = -1;\n\n      for (int co = 1;; co *= 2) {\n        for (int j = 0; j < w; ++j) {\n          int now = 0;\n          for (int i = 0; i < h; ++i) {\n            if (C[i][j] != -1) {\n              C[now][j] = C[i][j];\n              now++;\n            }\n          }\n          for (int i = now; i < h; ++i) {\n            C[i][j] = -1;\n          }\n        }\n\n        int sum = 0;\n        for (int i = 0; i < h; ++i) {\n          for (int j = 0; j < w; ++j) {\n            if (C[i][j] == -1) continue;\n\n            int cnt = 0;\n            for (int l = j; l < w; ++l) {\n              if (C[i][j] != C[i][l]) break;\n              cnt++;\n            }\n\n            if (cnt >= k) {\n              for (int l = 0; l < cnt; ++l) {\n                sum += C[i][l + j];\n                C[i][l + j] = -1;\n              }\n            }\n          }\n        }\n\n        score += co * sum;\n        if (sum == 0) break;\n      }\n\n      chmax(ans, score);\n    }\n  }\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst ll MOD = 1'000'000'007;\nconst ld PI = acos(-1);  \nconst ld EPS = 0.0000000001;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define REP(i, n) for(ll i=0; i<(ll)(n); i++)\n#define REPD(i, n) for(ll i=n-1; 0<=i; i--)\n#define FOR(i, a, b) for(ll i=a; i<(ll)(b); i++)\n#define FORD(i, a, b) for(ll i=a; (ll)(b)<=i; i--)\n#define ALL(x) x.begin(), x.end()\n#define MAX(x) *max_element(ALL(x))\n#define MIN(x) *min_element(ALL(x))\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint main(){\n    ll h, w, k;  cin >> h >> w >> k;\n    vector<vector<ll>> ori(h, vector<ll>(w));\n    REP(i, h) REP(j, w){\n        char c; cin >> c;\n        ori[i][j] = c-'0';\n    }\n    \n    ll res=0;\n    REP(x, h){\n        REP(y, w){\n            ll tmp=0, times=0;\n            bool flag=true;\n            vector<vector<ll>> g = ori;\n            g[x][y] = 0;\n            while(flag){\n                flag = false;\n                REP(i, h){\n                    ll bef=g[i][0], cnt=0, st=0, index=w;\n                    \n                    REP(j, w){\n                        if(g[i][j]==bef && 0<bef) cnt += 1;\n                        else{\n                            if(cnt<k){\n                                if(0<g[i][j]){\n                                    cnt = 1; st=j;\n                                }\n                            }else{\n                                if(bef)index = j;\n                                break;\n                            }\n                        }\n                        bef = g[i][j];\n                    }\n                    if(k<=cnt){\n                        tmp += (1<<times)*cnt*bef;\n                        FOR(j, st, index) g[i][j] = 0;\n                        flag = true;\n                    }\n                }\n                REPD(i, h){\n                    REP(j, w){\n                        if(!g[i][j]){\n                            REPD(k, i){\n                                if(!g[k][j]) continue;\n                                swap(g[k][j], g[i][j]); break;\n                            }\n                        }\n                    }\n                }\n                REP(i, h){\n                    ll bef=g[i][0], cnt=0, st=0, index=w;\n                    \n                    REP(j, w){\n                        if(g[i][j]==bef && 0<bef) cnt += 1;\n                        else{\n                            if(cnt<k){\n                                if(0<g[i][j]){\n                                    cnt = 1; st=j;\n                                }\n                            }else{\n                                if(bef)index = j;\n                                break;\n                            }\n                        }\n                        bef = g[i][j];\n                    }\n                    if(k<=cnt){\n                        tmp += (1LL<<times)*cnt*bef;\n                        FOR(j, st, index) g[i][j] = 0;\n                        flag = true;\n                    }\n                }\n                times += 1;\n            }\n            res = max(res, tmp);\n            //cout << x <<':' << y << ' ' << tmp << endl << endl;\n        }\n    }\n    \n    cout << res << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stdio.h>\n#include<cstring>\n#include<math.h>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<queue>\nusing namespace std;\n\n#define rep(i, n) for (long long i = 0; i < (long long)(n); ++i)\nusing P = pair<long long, long long>;\n\nlong long H, W, K;\nlong long cc[30][30];\nlong long c[30][30];\nlong long ans = 0;\n\nint main() {\n  cin >> H >> W >> K;\n  rep(i, H) {\n    string s;\n    cin >> s;\n    rep(j, W) {\n      cc[i][j] = s[j] - '0';\n    }\n  }\n\n  long long temp = 0;\n\n  rep(iii, H) {\n    rep(jjj, W) {\n      // if(iii != 3 || jjj != 0) continue;\n      long long count = 1;\n      temp = 0;\n      rep(ii, H) {\n        rep(jj, W) {\n          c[ii][jj] = cc[ii][jj];\n        }\n      }\n      if(iii == 0) {\n        c[iii][jjj] = 0;\n      } else {\n        for(long long k = 1; k <= iii; k++) {\n          swap(c[0][jjj], c[k][jjj]);\n        }\n        c[0][jjj] = 0;\n      }\n\n      while(true) {\n        vector<pair<pair<long long, long long>, long long>> mem;\n        rep(i, H) {\n          rep(j, W) {\n            if(c[i][j] == 0) continue;\n            bool ff = false;\n            long long M = max(K, W - j);\n            if(K > W - j) continue;\n            for(long long k = M; k >= K; k--) {\n              bool f = true;\n              rep(l, k-1) {\n                if(c[i][j+l] != c[i][j+l+1]) {\n                  f = false;\n                }\n              }\n              if(f) {\n                mem.push_back({{i, j}, k});\n                temp += k * c[i][j] * count;\n                ff = true;\n              }\n              if(ff) {\n                j = j + k;\n                // cout << j << endl;\n                break;\n              }\n            }\n            if(ff) continue;\n          }\n        }\n\n        if(mem.size() == 0) break;\n\n        rep(i, mem.size()) {\n          // cout << mem[i].first.first << \" \" << mem[i].first.second << \" \" << mem[i].second << endl;\n          long long sx, sy, k;\n          sx = mem[i].first.first;\n          sy = mem[i].first.second;\n          k = mem[i].second;\n          if(sx == 0) {\n            rep(j, k) {\n              c[sx][sy+j] = 0;\n            }\n          } else {\n            for(long long h = 1; h <= sx; h++) {\n              rep(j, k) {\n                swap(c[0][sy+j], c[h][sy+j]);\n              }\n            }\n            rep(j, k) {\n              c[0][sy+j] = 0;\n            }\n          }\n\n        }\n\n        count *= 2;\n      }\n      // cout << temp << endl;\n      ans = max(ans, temp);\n    }\n  }\n\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <map>\n#include <vector>\n#include <iostream>\n#include <stack>\n#include <climits>\n#include <set>\n#include <queue>\n#include <algorithm>\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld;\n\n\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n//const int N = 100001;\n//const int MOD = 1e9 + 7;\n\n\n\nint main(int argc, const char * argv[]) {\n   \n    int n,m,k;\n    cin>>n>>m>>k;\n    vector<string> vec(n);\n    for(int i = 0; i < n; i++){\n        cin>>vec[i];\n    }\n    \n    int maxsum = 0;\n    \n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n            int sum = 0;\n            vector<string> copy = vec;\n            for(int z = i; z >= 1; z--){\n                copy[z][j] = copy[z-1][j];\n            }\n            copy[0][j] = 0;\n            \n            for(int y = 0; y < n; y++){\n                int flag = 0;\n                for(int z = 1; z < m; z++){\n                    if(copy[y][z] != copy[y][z-1]){\n                        flag = 1;\n                        break;\n                    }\n                }\n                if(!flag){\n                    sum += m*(copy[y][0]-'0');\n                }\n            }\n            \n            if(sum > maxsum){\n                maxsum = sum;\n            }\n            \n            \n            \n        }\n    }\n    cout<<maxsum<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid erup( vector<string> &t, int i, int j )\n{\n\tt[i][j] = ' ';\n\tfor( int k = i; k - 1 >= 0; k-- ) {\n\t\tif(  t[k - 1][j] == ' ' ) break;\n\t\tt[k][j] = t[k - 1][j];\n\t\tt[k - 1][j] = ' ';\n\t}\n}\n\nvoid chk( vector<string> &t, int i, int j, int W, int K, vector<vector<int>> &use, vector<pair<int, int>> &er )\n{\n\tfor( int k = i; k >= 0; k-- ) {\n\t\tif( t[k][j] == ' ' ) break;\n\t\tif( j > 0 && t[k][j] == t[k][j - 1] || j + 1 < W && t[k][j] == t[k][j + 1] ) {\n\t\t\tif( use[k][j] ) continue;\n\t\t\tvector<pair<int, int>> tv;\n\t\t\tchar nc = t[k][j];\n\t\t\ttv.push_back( make_pair( k, j ) );\n\t\t\tfor( int l = j - 1; l >= 0; l-- ) {\n\t\t\t\tif( t[k][l] != nc ) break;\n\t\t\t\tif( use[k][l] ) continue;\n\t\t\t\ttv.push_back( make_pair( k, l ) );\n\t\t\t}\n\t\t\tfor( int l = j + 1; l < W; l++ ) {\n\t\t\t\tif( t[k][l] != nc ) break;\n\t\t\t\tif( use[k][l] ) continue;\n\t\t\t\ttv.push_back( make_pair( k, l ) );\n\t\t\t}\n\t\t\tif( tv.size() >= K ) {\n\t\t\t\ter.insert( er.end(), tv.begin(), tv.end() );\n\t\t\t\tfor( auto e : tv ) {\n\t\t\t\t\tuse[e.first][e.second] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint H, W, K;\n\tcin >> H >> W >> K;\n\tvector<string> c( H );\n\tfor( int i = 0; i < H; i++ ) {\n\t\tcin >> c[i];\n\t}\n\n\tlong long ans = 0;\n\tfor( int i = 0; i < H; i++ ) {\n\t\tfor( int j = 0; j < W; j++ ) {\n\t\t\tvector<string> t = c;\n\t\t\tlong long sc = 0;\n\t\t\terup( t, i, j );\n\t\t\tint idx = 0;\n\t\t\tset<int> st;\n\t\t\twhile( 1 ) {\n\t\t\t\tvector<vector<int>> use( H, vector<int>( W ) );\n\t\t\t\tvector<pair<int, int>> er;\n\t\t\t\tif( idx == 0 ) {\n\t\t\t\t\tchk( t, i, j, W, K, use, er );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor( auto it = st.begin(); it != st.end(); it++ ) {\n\t\t\t\t\t\tchk( t, i, *it, W, K, use, er );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( er.size() == 0 ) break;\n\t\t\t\tint sum = 0;\n\t\t\t\tfor( int k = 0; k < er.size(); k++ ) sum += t[er[k].first][er[k].second] - '0';\n\t\t\t\tsc += (1LL << idx) * sum;\n\t\t\t\tidx++;\n\t\t\t\tst.clear();\n\t\t\t\twhile( er.size() ) {\n\t\t\t\t\tint ii, jj;\n\t\t\t\t\ttie( ii, jj ) = er.back();\n\t\t\t\t\ter.pop_back();\n\t\t\t\t\tst.insert( jj );\n\t\t\t\t\terup( t, ii, jj );\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max( ans, sc );\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\n#define rep(i, n) for(int i=0; i<n; i++)\ntypedef long long ll;\nconst int INF = 0;\n\nint main(){\n    int H,W,K; cin>>H>>W>>K;\n    int field[H][W],copy[H][W];\n    rep(i,H){\n      string a; cin>>a;\n      rep(j,W){\n        field[i][j]=a[j]-'0';\n        copy[i][j]=field[i][j];\n      }\n    }\n  \nint rec=0;\nrep(a,H) rep(b,W){\n    rep(i,H) rep(j,W) field[i][j]=copy[i][j];\n    field[a][b]=INF;\n\nrep(k,10){\n        for(int i=0;i<H-1;i++){\n            rep(j,W){\n                if(field[i+1][j]==INF){\n                    field[i+1][j]=field[i][j];\n                    field[i][j]=INF;\n                }\n            }\n        }\n    }\n\n\n int ans=0; \n int two=1;\n rep(l,20){\n   \n    int point=0;\n    rep(i,H){\n\n        int count=1;\n        for(int j=1;j<W;j++){\n            if(field[i][j]==field[i][j-1]) count++;\n            else{\n                if(count<K) count=1;\n                else{\n                    point+=field[i][j-1]*count;\n                    rep(k,count) field[i][j-1-k]=INF;\n                    count=1;\n                }   \n            }\n            if(j==W-1){\n                    if(count>=K){\n                        point+=field[i][j-1]*count;\n                        rep(k,count) field[i][j-k]=INF;\n                    }\n            }\n        }\n    }\n    rep(k,20){\n        for(int i=0;i<H-1;i++){\n            rep(j,W){\n                if(field[i+1][j]==INF){\n                    field[i+1][j]=field[i][j];\n                    field[i][j]=INF;\n                }\n            }\n        }\n    }\n\n    \n   ans+=point*two;\n   two*=2;\n }\n rec=max(ans,rec);\n}\n \ncout<<rec<<endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "tifkukhj\nkuyljhlikljk\nlgykihlkjhivkhuijj\ndtuuuuuuuuudhg\nghjfyudt\ntukuyfyjkf\ndtukyfkyfukyukfyhf\nfghjuk\nu"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pull = pair<ull, ll>;\nusing pis = pair<int, string>;\n#define INF 1000000000\n#define LLINF 10000000000000000ll\n#define MOD 1000000007LL\n\nvoid copy_field(vector<vector<int>> &field, vector<vector<int>> &original) {\n  for (int i = 0; i < field.size(); i++) for (int j = 0; j < field[0].size(); j++) field[i][j] = original[i][j];\n  return;\n}\n\nbool check(vector<vector<int>> &field, vector<vector<int>> &checkfield, int k) {\n  int h = field.size(), w = field[0].size();\n  bool flag = false;\n  for (int i = 0; i < h; i++) {\n    if (k == 0) {\n      for (int j = 0; j < w; j++) checkfield[i][j] = 1;\n      return true;\n    }\n    int before = field[i][0], cnt = 1;\n    for (int j = 1; j < w; j++) {\n      if ((before != 0) && (before == field[i][j])) {\n        cnt++;\n        if (cnt >= k) {\n          checkfield[i][j] = 1;\n          flag = true;\n        }\n      }\n      else {\n        cnt = 1;\n        before = field[i][j];\n      }\n    }\n    for (int j = w-1; j >= k-1; j--) {\n      if ((checkfield[i][j] == 1) && (checkfield[i][j-1] == 0)) {\n        for (int l = 0; l < k-1; l++) {\n          j--;\n          checkfield[i][j] = 1;\n        }\n      }\n    }\n  }\n  return flag;\n}\n\nvoid init_checkfield(vector<vector<int>> &checkfield) {\n  for (int i = 0; i < checkfield.size(); i++) for (int j = 0; j < checkfield[0].size(); j++) checkfield[i][j] = 0;\n  return;\n}\n\nvoid init_field(vector<vector<int>> &field, int erase) {\n  int h = field.size();\n  for (int i = erase/h; i > 0; i--) {\n    field[i][erase%h] = field[i-1][erase%h];\n  }\n  field[0][erase % h] == 0;\n}\n\nvoid printfield(vector<vector<int>>&field) {\n  for (int i = 0; i < field.size(); i++) {\n    for (int j = 0; j < field[0].size(); j++) {\n      cout << field[i][j] << \" \";\n    }cout << endl;\n  }cout << endl;\n  return;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int h,w, k;\n  cin >> h >> w >> k;\n  vector<vector<int>> field(h, vector<int>(w)), original(h, vector<int>(w)), checkfield(h, vector<int>(w));\n  //for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) cin >> original[i][j];\n  for (int i = 0; i < h; i++) {\n    string s;\n    cin >> s;\n    for (int j = 0; j < w; j++) {\n      original[i][j] = (int)(s[j] - '0');\n    }\n  }\n\n  int ans = -1;\n  for (int erase = 0; erase < h*w; erase++) {\n    copy_field(field, original);\n    init_checkfield(checkfield);\n    //field[erase/h][erase%h] = 0;\n    init_field(field, erase);\n    int db = 1;\n    int temp = 0;\n    while(check(field, checkfield, k)) {\n      //cout << \"check\" << erase << endl;\n      //printfield(checkfield);\n      \n      for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n          if (checkfield[i][j] == 1) {\n            temp += db * field[i][j];\n            field[i][j] = 0;\n          }\n        }\n      }\n      \n      for (int i = h-2; i >= 0; i--) for (int j = 0; j < w; j++) checkfield[i][j] += checkfield[i+1][j];\n\n      for (int i = h-1; i >= 0; i--) {\n        for (int j = 0; j < w; j++) {\n          if ((field[i][j] == 0) || (checkfield[i][j] == 0)) continue;\n          if (i + checkfield[i][j] < h) {\n            field[i+checkfield[i][j]][j] = field[i][j];\n            field[i][j] = 0;\n          }\n          else field[i][j] = 0;\n        }\n      }\n      db *= 2;\n      init_checkfield(checkfield);\n    }\n    //cout << temp << endl;\n    ans = max(ans, temp);\n  }\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nint main()\n{\n  int H, W, K;\n  string s[30];\n  int power[31];\n  power[0] = 1;\n  for(int i = 1; i < 31; i++) power[i] = power[i - 1] * 2;\n\n  cin >> H >> W >> K;\n  for(int i = 0; i < H; i++) {\n    cin >> s[i];\n    for(auto &c : s[i]) c -= '0';\n  }\n\n  int ret = 0;\n\n  // まにあって\n\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      int now = 0;\n      vector< string > field(H);\n      for(int k = 0; k < H; k++) {\n        field[k] = s[k];\n      }\n      field[i][j] = -1;\n      for(int k = i; k > 0; k--) {\n        swap(field[k][j], field[k - 1][j]);\n      }\n      bool update = true;\n      for(int k = 0; update; k++) {\n        update = false;\n        vector< int > ff(W, 0);\n        for(int l = 0; l < H; l++) {\n          auto &bits = ff[l];\n\n          int rev = -1, cs = 0;\n          for(int m = 0; m < W; m++) {\n            if(field[l][m] == -1) {\n              rev = -1;\n              continue;\n            }\n            if(rev == field[l][m]) {\n              cs++;\n            } else {\n              rev = field[l][m];\n              cs = 1;\n            }\n            if(cs >= K) {\n              for(int n = 0; n < K; n++) {\n                bits |= 1 << (m - n);\n              }\n              update = true;\n            }\n          }\n        }\n        int cost = 0;\n        for(int l = 0; l < H; l++) {\n          auto &bits = ff[l];\n          for(int m = 0; m < W; m++) {\n            if(field[l][m] == -1) continue;\n            if((bits >> m) & 1) {\n              cost += field[l][m];\n              field[l][m] = -1;\n              for(int n = l; n > 0; n--) {\n                swap(field[n - 1][m], field[n][m]);\n              }\n            }\n          }\n        }\n        now += power[k] * cost;\n      }\n      ret = max(ret, now);\n    }\n  }\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include <prettyprint.hpp>\n#define debug(...)  cerr << \"[\" << #__VA_ARGS__ << \"]: \", d_err(__VA_ARGS__);\n#else\n#define debug(...) 83;\n#endif\n\nvoid d_err() {\n    cerr << endl;\n}\n\ntemplate <typename H, typename... T>\nvoid d_err(H h, T... t) {\n    cerr << h << \" \";\n    d_err(t...);\n}\n\ntemplate <typename T>\nvoid print(T x) {\n    cout << x << \"\\n\";\n}\n\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define REVFOR(i, m, n) for (int i = (n - 1); i >= (m); --i)\n#define REP(i, n) FOR(i, 0, n)\n#define REVREP(i, n) REVFOR(i, 0, n)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define bcnt __builtin_popcountll\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int,int> Pin;\n\nll INF = 1e16;\nint inf = 1e9;\n\nvoid chmax(ll& x, ll y) {\n    if (x < y) x = y;\n}\n\nstruct UnionFind {\n    vector<int> par;\n\n    UnionFind(int n): par(n, -1) {}\n    void init(int n) { par.assign(n, -1); }\n\n    int root(int x) {\n        if (par[x] < 0) return x;\n        return par[x] = root(par[x]);\n    }\n\n    int issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n\n        if (x == y) return false;\n\n        // merge by size\n        // force size of x to be bigger than that of y\n        if (par[x] > par[y]) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n\n        return true;\n    }\n\n    ll size(int x) {\n        return -par[root(x)];\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    int h, w, k; cin >> h >> w >> k;\n    vector<string> vs(h);\n    REP(i, h) cin >> vs[i];\n\n    vector<vi> v(h, vi(w));\n    REP(i, h) REP(j, h) v[i][j] = vs[i][j] - '0';\n\n    // calc score\n    auto get_score = [&](vector<vi>& v) -> ll {\n        ll score = 0;\n        int cnt_clear = 0;\n        while(1) {\n            int cur = 0;\n            vector<vector<bool>> clear(h, vector<bool>(w, false));\n\n            REP(i, h) {\n                int prev = -1;\n                int cnt = 0;\n                REP(j, w) {\n                    if (v[i][j] == -1) {\n                        if (cnt >= k) {\n                            REP(l, cnt) {\n                                clear[i][j - l - 1] = true;\n                            }\n                            cur += cnt * prev;\n                        }\n\n                        cnt = 0;\n                        prev = -1;\n                        continue;\n                    }\n\n                    if (prev != v[i][j]) {\n                        if (cnt >= k) {\n                            REP(l, cnt) {\n                                clear[i][j - l - 1] = true;\n                            }\n                            cur += cnt * prev;\n                        }\n                        cnt = 0;\n                    }\n\n                    prev = v[i][j];\n                    cnt++;\n                }\n\n                if (cnt >= k) {\n                    REP(l, cnt) clear[i][w - l - 1] = true;\n                    cur += cnt * prev;\n                }\n            }\n\n            REP(j, w) {\n                REP(i, h) {\n                    if (clear[i][j]) {\n                        REVREP(l, i) {\n                            v[l + 1][j] = v[l][j];\n                        }\n                        v[0][j] = -1;\n                    }\n                }\n            }\n\n            if (cur == 0)  break;\n            score += cur * pow(2, cnt_clear);\n            cnt_clear++;\n        }\n\n        return score;\n    };\n\n    ll ans = 0;\n    REP(i, h) REP(j, w) {\n        // clear this\n        vector<vi> v_cur = v;\n\n        REVREP(l, i) v_cur[l + 1][j] = v_cur[l][j];\n        v_cur[0][j] = -1;\n\n        ans = max(ans, get_score(v_cur));\n    }\n\n    print(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define INF (int)(1e9)\n\nint h,w,k;\n\nint clear(vvi&f, int combo){\n    int del=0;\n    range(i,1,h+1)range(j,1,w+2-k){\n        if(f[i][j]==-1) continue;\n        if(f[i][j]==f[i][j+1] and f[i][j]==f[i][j+2])  del+=f[i][j]*3,f[i][j]=f[i][j+1]=f[i][j+2]=0,j+=2;\n        if(f[i][j]==f[i][j+1] and k==2) del+=f[i][j]*2, f[i][j]=f[i][j+1]=0, j++;\n    }\n    return del<<combo;\n}\nvoid fall(vvi&f){\n    vvi nf(h+2,vi(w+2,-1));\n    range(j,1,w+1){\n        int p=h;\n        for(int i=h;i>=1;i--){\n            if(f[i][j]>0) nf[p--][j]=f[i][j];\n        }\n    }\n    f=nf;\n}\n\nint solve(vvi f, int i, int j){\n    f[i][j]=0;\n    fall(f);\n    int score=0,add=0,ren=0;\n    while((add=clear(f,ren++))!=0){\n        score+=add;\n        fall(f);\n    }\n    return score;\n}\n\nint main(){\n    cin>>h>>w>>k;\n    if(k>=4){\n        cout<<0<<endl;\n        return 0;\n    }\n    vvi f(h+2,vi(w+2,-1));\n    range(i,1,h+1)range(j,1,w+1){char c; cin>>c; f[i][j]=c-'0';}\n    int ans=0;\n    range(i,1,h+1)range(j,1,w+1) ans=max(ans,solve(f,i,j));\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nconst int nax=37;\n\nint n, m, k;\n\nchar wcz[nax];\n\nstruct plan\n{\n\tvector <int> wek[nax];\n\tint kogo[nax][nax];\n\tplan()\n\t{\n\t\tczys();\n\t}\n\tvoid czys()\n\t{\n\t\tfor (int i=0; i<nax; i++)\n\t\t\tfor (int j=0; j<nax; j++)\n\t\t\t\tkogo[i][j]=0;\n\t}\n\tll oznacz()\n\t{\n\t\tll ret=0;\n\t\tfor (int i=0; i<nax; i++)\n\t\t{\n\t\t\tint ost=-1;\n\t\t\tint ile=0;\n\t\t\tfor (int j=0; j<nax; j++)\n\t\t\t{\n\t\t\t\tint x=-1;\n\t\t\t\tif ((int)wek[j].size()>i)\n\t\t\t\t\tx=wek[j][i];\n\t\t\t\tif (x==-1)\n\t\t\t\t{\n\t\t\t\t\tost=-1;\n\t\t\t\t\tile=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (x!=ost)\n\t\t\t\t\t{\n\t\t\t\t\t\tile=1;\n\t\t\t\t\t\tost=x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tile++;\n\t\t\t\t\t\tif (ile>=k)\n\t\t\t\t\t\t\tkogo[j][i]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tost=-1;\n\t\t\tile=0;\n\t\t\tfor (int j=nax-1; j>=0; j--)\n\t\t\t{\n\t\t\t\tint x=-1;\n\t\t\t\tif ((int)wek[j].size()>i)\n\t\t\t\t\tx=wek[j][i];\n\t\t\t\tif (x==-1)\n\t\t\t\t{\n\t\t\t\t\tost=-1;\n\t\t\t\t\tile=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (x!=ost)\n\t\t\t\t\t{\n\t\t\t\t\t\tile=1;\n\t\t\t\t\t\tost=x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tile++;\n\t\t\t\t\t\tif (ile>=k)\n\t\t\t\t\t\t\tkogo[j][i]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i=0; i<nax; i++)\n\t\t\tfor (int j=0; j<(int)wek[i].size(); j++)\n\t\t\t\tret+=kogo[i][j]*wek[i][j];\n\t\treturn ret;\n\t}\n\tvoid puszuj()\n\t{\n\t\tfor (int i=0; i<nax; i++)\n\t\t{\n\t\t\tvector <int> wez;\n\t\t\tfor (int j=0; j<(int)wek[i].size(); j++)\n\t\t\t\tif (!kogo[i][j])\n\t\t\t\t\twez.push_back(wek[i][j]);\n\t\t\twek[i]=wez;\n\t\t}\n\t\tint g=0;\n\t\tfor (int i=0; i<nax; i++)\n\t\t{\n\t\t\tif (!wek[i].empty())\n\t\t\t{\n\t\t\t\twek[g]=wek[i];\n\t\t\t\tif (i!=g)\n\t\t\t\t\twek[i].clear();\n\t\t\t\tg++;\n\t\t\t}\n\t\t}\n\t\tczys();\n\t}\n};\n\nll wyn;\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tplan start;\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tscanf(\"%s\", wcz);\n\t\tfor (int j=0; j<m; j++)\n\t\t\tstart.wek[j].push_back(wcz[j]-'0');\n\t}\n\tfor (int i=0; i<m; i++)\n\t\treverse(start.wek[i].begin(), start.wek[i].end());\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tfor (int j=0; j<m; j++)\n\t\t{\n\t\t\tplan wez=start;\n\t\t\twez.kogo[j][i]=1;\n\t\t\twez.puszuj();\n\t\t\tll ter=0;\n\t\t\tfor (int h=0; 1; h++)\n\t\t\t{\n\t\t\t\tll x=wez.oznacz();\n\t\t\t\tif (!x)\n\t\t\t\t\tbreak;\n\t\t\t\tter+=(x<<h);\n\t\t\t\twez.puszuj();\n\t\t\t}\n\t\t\twyn=max(wyn, ter);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define MOD_1_000_000_007 (1000000007LL)\n#define LINF (1LL<<60)\n#define rep(i, n)   for (long long i = 0; i <  (long long)(n); i++)\n#define rep1(i, n)  for (long long i = 1; i <  (long long)(n); i++)\n#define rep2(i, n)  for (long long i = 2; i <  (long long)(n); i++)\n#define rep0c(i, n) for (long long i = 0; i <= (long long)(n); i++)\n#define rep1c(i, n) for (long long i = 1; i <= (long long)(n); i++)\n#define rep2c(i, n) for (long long i = 2; i <= (long long)(n); i++)\n#define repc0(n, i) for (long long i = (long long)(n); i >= 0; i--)\n#define repc1(n, i) for (long long i = (long long)(n); i >= 1; i--)\n#define repc2(n, i) for (long long i = (long long)(n); i >= 2; i--)\n\nnamespace solver {\n  using namespace std;\n  typedef long long ll;\n\n  ll H, W, K, ORIG[30][31], A[30][31];\n\n  void init() {\n    scanf(\"%lld %lld %lld\", &H, &W, &K);\n    rep(i, H) {\n      string s;\n      cin >> s;\n      rep(j, W) ORIG[i][j] = s[j] - '0';\n    }\n  }\n\n  ll calc(ll si, ll sj) {\n    memcpy(A, ORIG, sizeof ORIG);\n    A[si][sj] = 0;\n    for(ll i = si; 0<i; i--) swap(A[i][sj], A[i-1][sj]);\n    ll score = 0, base = 1;\n    // rep(i, H) {\n    //   // debug\n    //   rep(j, W) cerr << A[i][j] << \" \";\n    //   cerr << endl;\n    // }\n    while(1) {\n      bool disappeared = false;\n      rep(i, H) {\n        ll prev_num = 0, same_cnt = 0;\n        rep(j, W+1) {\n          if(prev_num && (prev_num == A[i][j])) {\n            same_cnt++;\n          } else {\n            if(same_cnt >= K) {\n              rep(k, same_cnt) {\n                score += base * A[i][j-k-1];\n                A[i][j-k-1] = 0;\n              }\n              disappeared = true;\n            }\n            prev_num = A[i][j];\n            same_cnt = 1;\n          }\n        }\n      }\n      if(!disappeared) break;\n      rep(c, H-1) for(ll i = H-1; c<i; i--) rep(j, W) {\n        if(A[i][j] == 0) swap(A[i][j], A[i-1][j]);\n      }\n      base *= 2;\n    }\n    return score;\n  }\n\n  void solve() {\n    ll ans = 0;\n    rep(i, H) rep(j, W) ans = max(ans, calc(i, j));\n    cout << ans << endl;\n  }\n}\n\nint main() {\n  solver::init();\n  solver::solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\ntypedef long long int ll;\n\nint h,w,k;\nchar fi[31][31];\nint cp[31][31];\nint epy[31][31];\n\nvoid fall(){\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tepy[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<w;i++){\n\t\tfor(int j=h-1;j>=0;j--){\n\t\t\tepy[j][i]=epy[j+1][i];\n\t\t\tif(cp[j][i]==0)epy[j][i]++;\n\t\t}\n\t\tfor(int j=h-1;j>=0;j--){\n\t\t\tif(cp[j][i]!=0&&epy[j][i]!=0){\n\t\t\t\tcp[j+epy[j][i]][i]=cp[j][i];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint rensa(int i){\n\tbool ok=false;\n\tint res=0;\n\tfor(int i=0;i<h;i++){\n\t\tint cnt=0;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(j<w-1&&cp[i][j]==cp[i][j+1]){\n\t\t\t\tint m=cp[i][j];\n\t\t\t\twhile(j<w&&m==cp[i][j]){\n\t\t\t\t\tj++;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tj--;\n\t\t\t\tif(cnt>=k){\n\t\t\t\t\tok=true;\n\t\t\t\t\tres+=cnt*m;\n\t\t\t\t\tfor(int u=0;u<cnt;u++){\n\t\t\t\t\t\tcp[i][j-u]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcnt=0;\n\t\t\t}\n\t\t}\n\t}\n\tif(!ok||res==0)return res*i;\n\telse{\n\t\tfall();\n\t\treturn rensa(2*i)+res*i;\n\t}\n}\n\nint solve(int x,int y){\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcp[i][j]=(int)(fi[i][j]-'0');\n\t\t}\n\t}\n\tcp[x][y]=0;\n\tfall();\n\treturn rensa(1);\n}\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcin >> h >> w >> k;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin >> fi[i][j];\n\t\t}\n\t}\n\tint score=0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tscore=max(score,solve(i,j));\n\t\t}\n\t}\n\tcout << score << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n \nusing namespace std;\n \n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n \nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n \ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\nint in(){int a;scanf(\"%d\",&a);return a;}\nll lin(){ll a;scanf(\"%lld\",&a);return a;}\n \nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n \nint h,w,k;\nint a[10][10];\n \nint s(int a[10][10])\n{\n    int res = 0;\n    rep(i, h) {\n        for (int j = 1; j < w; ++j) {\n            if (a[i][j] == -1) break;\n            bool f = true;\n            if (a[i][j] != a[i][j - 1]) {\n                f = false;\n                break;\n            }\n            if (f) {\n                for (int y = i; y > 0; --y) {\n                    rep(x, w) {\n                        a[y][x] = -1;\n                        swap(a[y][x], a[y-1][x]);\n                    }\n                }\n                chmax(res, a[i][j] * w + s(a));\n            }\n        }\n    }\n    return res;\n}\n \nint main()\n{\n    cin>>h>>w>>k;\n \n    rep(i, h)rep(j, w) cin>>a[i][j];\n    if (h>10||w>10)return 0;\n    if (w!=k)return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nusing ll = long long;\n\nvoid check(vector<string> x) {\n    rep(i, x.size()) {\n        cout << x[i] << \"\\n\";\n    }\n    cout << \"\\n\";\n}\n\nint main() {\n    int H, W, K;\n    cin >> H >> W >> K;\n    vector<string> b(H), c(H);\n    rep(i, H) {\n        cin >> b[i];\n        b[i].push_back('.');\n        //cout << b[i] << i << \"\\n\";\n    }\n    //rep(i, H) cout << c[i] << \"\\n\";\n    int maxans = 0;\n    rep(j, W) rep(j0, H) {\n        rep(i, H) c[i] = b[i];\n        int ans = 0;\n        c[j0][j] = '0';\n        //check(c);\n        int score = 1;\n        rep(i, 900) {\n            bool f = true;\n            //石の落下\n            //cout << \"drop\\n\";\n            rep(k, W) {\n                //cout << \"k=\" << k << \"\\n\";\n                for (int l = H - 1; l > 0; l--) {\n                    //cout << \"l=\" << l << \"\\n\";\n                    if (c[l][k] == '0') {\n                        int m = 1;\n                        while (l - m >= 0 && c[l - m][k] == '0') m++;\n                        if (l - m >= 0) {\n                            for (int n = l; n - m >= 0; n--) {\n                                c[n][k] = c[n - m][k];\n                            }\n                            rep(n, m) c[n][k] = '0';\n                            //check(c);\n                        }\n                    }\n                }\n            }\n            //check(c);\n            //K個並んでいるところを消す\n            rep(k, H) {\n                //cout << \"k=\" << k << \"\\n\";\n                int l = 0, r = 0;\n                while (r < W) {\n                    //cout << \"l=\" << l << \" r=\" << r << \"\\n\";\n                    if (c[k][l] == '0') {\n                        l++;\n                        r = l;\n                        continue;\n                    }\n                    if (c[k][r] != c[k][r + 1]) {\n                        if (r - l + 1 >= K) {\n                            ans += score * (r - l + 1) * (c[k][l] - '0');\n                            for (int m = l; m <= r; m++) {\n                                c[k][m] = '0';\n                            }\n                            f = false;\n                            //cout << \"!\\n\";\n                            //check(c);\n                        }\n                        r++;\n                        l = r;\n                    } else {\n                        r++;\n                    }\n                }\n            }\n            if (f) break;\n            score *= 2;\n        }\n        maxans = max(maxans, ans);\n    }\n    cout << maxans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "//最長共通部分列 http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_10_C\n//要は何枚のコインで支払えますか問題。\n\n// lcmとかはg++ -std=c++17 default.cppみたいなかんじで\n//vector<vector<ll>> piyo(tate,vector<ll> (yoko));\n\n#include <bits/stdc++.h>\n#define mod 1000000007\n#define INF 1000000019\n#define ll long long\n#define ln cout<<endl;\n#define Yes cout<<\"Yes\"<<endl\n#define No cout<<\"No\"<<endl\n#define double long double\n#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nint dp[2000][2000];\nvector<int> w(2000);\nvector<int> v(2000);\n\nint main() {\n    cin.tie(0);\n   \tios::sync_with_stdio(false);\n    //double mini=INF;\n    int maxi=0;\n    int i;\n    double h;\n    int n,x,m=5;\n    int a,b,d,c;\n    //int e,weight;\n    int target;\n    //targetが目的値、nが個数\n    //ll _=1;\n    ll k;\n\n        cin>>n>>m>>k;\n        vector<vector<ll>> v(n,vector<ll> (m));\n        vector<vector<ll>> hokan(n,vector<ll> (m));\n        vector<vector<ll>> f(n,vector<ll> (m));\n        //vector<vector<ll>> v(n,vector<ll> (m));\n\n        rep(i,n){\n        string str;\n            cin>>str;\n            rep(j,str.length()) hokan[i][j]=stoll(str.substr(j,1));\n            //cin>>hokan[i][j];\n        }\n                ll counter=0;\n\n\n        ll maxsum=0;\n        rep(x,n)rep(y,m){\n            //cout<<x<<\" \"<<y<<endl;\n            rep(i,n)rep(j,m) v[i][j]=hokan[i][j];\n            for(ll i=x;i>=1;i--) v[i][y]=v[i-1][y];\n            v[0][y]=0;\n\n            ll sum=0;\n            ll endf=0;\n            ll loop=0;\n            while(!endf){\n                endf=1;\n                rep(i,n) rep(j,m) {f[i][j]=0;}\n                for(ll i=0;i<n;i++) {\n                    for(ll j=0;j<m-k+1;j++){\n                        ll flag=0;\n                        for(ll l=j;l<j+k-1;l++){\n                            if(v[i][l]!=v[i][l+1]||v[i][l]==0) {\n                                flag=1;\n                                break;\n                            }\n                        }\n                        if(flag==0){\n                            for(ll l=j;l<j+k;l++){\n                                f[i][l]=1;\n                            }\n                        }\n                    }\n                }\n                ll karisum=0;\n                for(ll i=0;i<n;i++) {\n                    for(ll j=0;j<m;j++){\n                        if(f[i][j]==1) {\n                            karisum+=v[i][j];\n                            v[i][j]=0;\n                            endf=0;\n                        }\n                    }\n                }\n                sum+=pow(2,loop)*karisum;\n                loop++;\n\n\n\n                for(ll j=0;j<m;j++){\n                    ll takasa=n-1;\n                    for(ll i=n-1;i>=0;i--){\n                        if(f[i][j]==0){\n                            v[takasa][j]=v[i][j];\n                            takasa--;\n                        }\n                    }\n                    for(i=takasa;i>=0;i--){\n                    v[i][j]=0;\n                    }\n                }\n                /*\n                if(counter<30){\n                    rep(i,n){\n                        rep(j,m){\n                            cout<<v[i][j]<<\" \";\n                        }\n                            cout<<endl;\n                    }\n                    cout<<endl;\n                    }\n                counter++;*/\n    \n            }\n            maxsum=max(sum,maxsum);\n        }\n        cout<<maxsum<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing uint = unsigned;\nusing pcc = pair<char, char>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\nusing tuplis = array<ll, 3>;\ntemplate<class T> using pq = priority_queue<T, vector<T>, greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst ll MINF=0x7fffffffffff;\nconst ll LPLMT=10000000;//O(n)のloop上限\nconst ll NLGLMT=200000;//O(NlogN)のloop上限（これで指定されたfor文の中にO(logN)の処理を書く）\nconst ll N2LMT=3000;//O(n^2)のloop上限\nconst ll N3LMT=100;//O(n^3)のloop上限\nconst ll N4LMT=50;//O(n^4)のloop上限\nconst ll TNLMT=20;//O(2^n)のloop上限（実際この計算量になるのは全探索くらいなので，この値自体を使うことはなさそう）（オーダの参考程度に）\nconst int INF=0x3fffffff;\nconst int MOD=1000000007;\nconst int MODD=998244353;\nconst ld DINF=numeric_limits<ld>::infinity();\nconst ld EPS=1e-9;\nconst ld PI=3.1415926535897932;\nconst ll dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst ll dy[] = {1, 0, -1, 0, 1, 1, -1, -1};\n#define overload4(_1,_2,_3,_4,name,...) name\n#define overload3(_1,_2,_3,name,...) name\n/*繰り返し*/\n#define rep1(n) for(ll i=0;i<n;++i)//n回repeat\n#define rep2(i,n) for(ll i=0;i<n;++i)//n回repeat（変数指定）\n#define rep3(i,a,b) for(ll i=a;i<b;++i)//a-bまでrepeat\n#define rep4(i,a,b,c) for(ll i=a;i<b;i+=c)//a-bまで公差cでrepeat（等差数列で使えそう）\n#define rep(...) overload4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)//repeatまとめ\n#define rrep1(n) for(ll i=(n);i--;)\n#define rrep2(i,n) for(ll i=(n);i--;)\n#define rrep3(i,a,b) for(ll i=(b);i-->(a);)\n#define rrep4(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) overload4(__VA_ARGS__,rrep4,rrep3,rrep2,rrep1)(__VA_ARGS__)//逆repeatまとめ\n#define each1(i,a) for(auto&& i:a)\n#define each2(x,y,a) for(auto&& [x,y]:a)\n#define each3(x,y,z,a) for(auto&& [x,y,z]:a)\n#define each(...) overload4(__VA_ARGS__,each3,each2,each1)(__VA_ARGS__)//配列の各要素の読み出し\n#define all1(i) begin(i),end(i)\n#define all2(i,a) begin(i),begin(i)+a\n#define all3(i,a,b) begin(i)+a,begin(i)+b\n#define all(...) overload3(__VA_ARGS__,all3,all2,all1)(__VA_ARGS__)//vectorの始めと終わりの読み取り\n#define rall1(i) (i).rbegin(),(i).rend()\n#define rall2(i,k) (i).rbegin(),(i).rbegin()+k\n#define rall3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rall(...) overload3(__VA_ARGS__,rall3,rall2,rall1)(__VA_ARGS__)//逆イテレータの取得(rbegin：末尾,rend：頭）\n#define sum(...) accumulate(all(__VA_ARGS__),0LL)//vectorの合計(int形で受け付けてしまうので，小数で扱いたい場合はdsumを使う)\n#define dsum(...) accumulate(all(__VA_ARGS__),0.0L)//小数で扱う(long long doubleなど)\n#define elif else if\n#define unless(a) if(!(a))\n#define mp make_pair\n#define mt make_tuple\n/*標準入力*/\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)//int型標準入力受付，以下LDまで同様\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;in(__VA_ARGS__)\n/*vector操作*/\n#define Sort(a) sort(all(a))//昇順ソート\n#define RSort(vec) sort(vec.begin(), vec.end(), greater<ll>())//降順ソート\n#define Rev(a) reverse(all(a))//逆順\n#define Uniq(a) sort(all(a));a.erase(unique(all(a)),end(a))\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)//type型vectorの定義\n#define VEC(type,name,size) vector<type> name(size);in(name)//type型vector(size指定)標準入力受付\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));in(name)\n#define IV(type,name,size) vector<pair<int, int>> name;for (int i = 0; i < size; i++) {int a_i;cin >> a_i; name.emplace_back(a_i,i);}//Indexつきvector（pair型Vector,(data,index)）\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\ntemplate<class T> auto min(const T& a){ return *min_element(all(a)); }\ntemplate<class T> auto max(const T& a){ return *max_element(all(a)); }\ninline ll popcnt(ull a){ return __builtin_popcountll(a); }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b /= 2; } return ans; }\nll modpow(ll a, ll b, ll p){ ll ans = 1; while(b){ if(b & 1) (ans *= a) %= p; (a *= a) %= p; b /= 2; } return ans; }\ntemplate<class T, class U> bool chmin(T& a, const U& b){ if(a > b){ a = b; return 1; } return 0; }\ntemplate<class T, class U> bool chmax(T& a, const U& b){ if(a < b){ a = b; return 1; } return 0; }\nvector<ll> iota(ll n){ vector<ll> a(n); iota(a.begin(), a.end(), 0); return a; }\nvector<pll> factor(ull x){ vector<pll> ans; for(ull i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nmap<ll,ll> factor_map(ull x){ map<ll,ll> ans; for(ull i = 2; i * i <= x; i++) if(x % i == 0){ ans[i] = 1; while((x /= i) % i == 0) ans[i]++; } if(x != 1) ans[x] = 1; return ans; }\nvector<ll> divisor(ull x){ vector<ll> ans; for(ull i = 1; i * i <= x; i++) if(x % i == 0) ans.push_back(i); rrep(ans.size() - (ans.back() * ans.back() == x)) ans.push_back(x / ans[i]); return ans; }\ntemplate<class T> unordered_map<T, ll> press(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); unordered_map<T, ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\ntemplate<class T> map<T, ll> press_map(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); map<T, ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\nint scan(){ return getchar(); }\nvoid scan(int& a){ scanf(\"%d\", &a); }\nvoid scan(unsigned& a){ scanf(\"%u\", &a); }\nvoid scan(long& a){ scanf(\"%ld\", &a); }\nvoid scan(long long& a){ scanf(\"%lld\", &a); }\nvoid scan(unsigned long long& a){ scanf(\"%llu\", &a); }\nvoid scan(char& a){ do{ a = getchar(); }while(a == ' ' || a == '\\n'); }\nvoid scan(float& a){ scanf(\"%f\", &a); }\nvoid scan(double& a){ scanf(\"%lf\", &a); }\nvoid scan(long double& a){ scanf(\"%Lf\", &a); }\nvoid scan(vector<bool>& a){ for(unsigned i = 0; i < a.size(); i++){ int b; scan(b); a[i] = b; } }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid in(){}\ntemplate <class Head, class... Tail> void in(Head& head, Tail&... tail){ scan(head); in(tail...); }\nvoid print(){ putchar(' '); }\nvoid print(bool a){ printf(\"%d\", a); }\nvoid print(int a){ printf(\"%d\", a); }\nvoid print(unsigned a){ printf(\"%u\", a); }\nvoid print(long a){ printf(\"%ld\", a); }\nvoid print(long long a){ printf(\"%lld\", a); }\nvoid print(unsigned long long a){ printf(\"%llu\", a); }\nvoid print(char a){ printf(\"%c\", a); }\nvoid print(char a[]){ printf(\"%s\", a); }\nvoid print(const char a[]){ printf(\"%s\", a); }\nvoid print(float a){ printf(\"%.15f\", a); }\nvoid print(double a){ printf(\"%.15f\", a); }\nvoid print(long double a){ printf(\"%.15Lf\", a); }\nvoid print(const string& a){ for(auto&& i : a) print(i); }\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ print(p.first); putchar(' '); print(p.second); }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }//cout<<t<<endl\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\n#ifdef DEBUG\ninline ll __lg(ull __n){ return sizeof(ull) * __CHAR_BIT__  - 1 - __builtin_clzll(__n); }\n#define debug(...) { print(#__VA_ARGS__); print(\":\"); out(__VA_ARGS__); }\n#else\n#define debug(...) void(0)\n#endif\n/*判定出力*/\nint first(bool i = true){ return out(i?\"first\":\"second\"); }//iがfirstか判断，以下同様\nint yes(bool i = true){ return out(i?\"yes\":\"no\"); }\nint Yes(bool i = true){ return out(i?\"Yes\":\"No\"); }\nint No(){ return out(\"No\"); }\nint YES(bool i = true){ return out(i?\"YES\":\"NO\"); }\nint NO(){ return out(\"NO\"); }\nint Yay(bool i = true){ return out(i?\"Yay!\":\":(\"); }\nint possible(bool i = true){ return out(i?\"possible\":\"impossible\"); }\nint Possible(bool i = true){ return out(i?\"Possible\":\"Impossible\"); }\nint POSSIBLE(bool i = true){ return out(i?\"POSSIBLE\":\"IMPOSSIBLE\"); }\nvoid Case(ll i){ printf(\"Case #%lld: \", i); }\n/*vector探索*/\n#define bSearch(v,k) binary_search(all(v),k)//ソートされた配列vの中の要素にkがあるか(boolean)\n#define lowB(v,k) lower_bound(all(v),k)//ソートされた配列vの中の要素のうちk以上かつ最小のイテレータ\n#define DLbetB(v,k) lowB(v,k)-v.begin()//先頭からの距離\n#define DLbetE(v,k) v.end()-lowB(v,k)//末尾からの距離\n#define uppB(v,k) upper_bound(all(v),k)//ソートされた配列vの中の要素のうちkより大きいかつ最小のイテレータ\n#define DUbetB(v,k) uppB(v,k)-v.begin()//先頭からの距離\n#define DUbetE(v,k) v.end()-uppB(v,k)//末尾からの距離\n#define Cnt(v,k) count(all(v),k)//配列vの中で要素kが何個あるかを返す(size_t)\n#define CntIf(v,l) count_if(all(v),l)//配列vの中で条件式(lambda式)を満たす個数を返す(ex.int num = count_if(v.begin(), v.end(), [](int i){return i % 3 == 0;});)\n#define Sort2D(myVec,i) sort(myVec.begin(),myVec.end(),[](const vector<ll> &alpha,const vector<ll> &beta){return alpha[i] < beta[i];});//i列めでソート\n/*最大公約数*/\ntemplate <class T>\nT vgcd(T m, T n) {\n  return gcd(m, n);\n}\n\ntemplate <class T, class... Args>\nT vgcd(T a, Args... args) {\n  return vgcd(a, vgcd(args...));\n}\n/*階乗*/\nll facctorialMethod(ll k){\n    ll sum = 1;\n    for (ll i = 1; i <= k; ++i)\n    {\n        sum *= i;\n        //sum%=MOD;//あまりを出力せよ問題の時はこれもやる\n    }\n    return sum;\n}\n/*組み合わせnCk*/\nll comb(const ll N,const ll K){\n  vector<vector<long long int> > v(N+1,vector<long long int>(N+1,0));\n  for(int i = 0;i <v.size(); i++){\n    v[i][0]=1;\n    v[i][i]=1;\n  }\n  for(int k = 1;k <v.size();k++){\n    for(int j = 1;j<k;j++){\n      v[k][j]=(v[k-1][j-1]+v[k-1][j]);\n    }\n  }\n  return v[N][K];\n}\n/*逆元　あまりの割り算をするときにこいつをかける(a/b→a*modinv(b))*/\n// mod. m での a の逆元 a^{-1} を計算する\nll modinv(ll a,ll m){\n    long long b = m, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    u %= m;\n    if (u < 0) u += m;\n    return u;\n}\n/*ダブリング*/\n/*\n参考：http://satanic0258.hatenablog.com/entry/2017/02/23/222647\n\n使える場所：1回遷移した先が明確にわかる時\n\n目的：\n・ある数XのQ乗を求める\n・根付き木において、ある頂点vのQ個上の親を知る\n・ある地点からQ回進んだ先を求める\n*/\n//int N; // 全体の要素数\n//int Q;//試行回数\nll doubling(const ll N,const ll Q,vector<ll> a){//cin>>N>>Q;//標準入力から要素数と試行回数を受け取る場合\nll LOG_Q = floor(log2(Q))+1;\n\n// next[k][i]で、i番目の要素の「2^k個次の要素」を指す\n// (なお、i番目の要素に対して「2^k個次の要素」が存在しないとき、\n//  next[k][i]が指し示す要素番号を-1とします)\nstd::vector<std::vector<ll>> next(LOG_Q + 1, std::vector<ll>(N));\n//ll a[N];//各要素の次の行き先\n\n// next[0]を計算\nfor (int i = 0; i < N; ++i){\n    next[0][i] = a[i];\n}\n\n// nextを計算\nfor (ll k = 0; k < LOG_Q; ++k){\n    for (int i = 0; i < N; ++i){\n        if (next[k][i] == -1) {\n            // 2^k個次に要素が無い時、当然2^(k+1)個次にも要素はありません\n            next[k + 1][i] = -1;\n        }\n        else {\n            // 「2^k個次の要素」の2^k個次の要素は、2^(k+1)個次の要素です\n            next[k + 1][i] = next[k][next[k][i]];\n        }\n    }\n}\n\n// ----ここまで準備----\n\n// p番目の要素の「Q個次の要素」を求めることを考えます\nll p=0;\nfor (ll k = LOG_Q - 1; k >= 0; --k){\n    if (p == -1) {\n        // pがすでに存在しない要素を指していたら、\n        // それ以降で存在する要素を指すことはないためループを抜けます\n        break;\n    }\n    if ((Q >> k) & 1) {//ex(Q=5)5=101(2)であり，2^2+2^0回進むことを表す\n        // Qを二進展開した際、k番目のビットが立っていたら、\n        // pの位置を2^kだけ次にずらします\n        p = next[k][p];\n    }\n}\nreturn p;//ここでのpが最終的な答えになる\n}\n/*素数判定*/\nbool IsPrime(ll num)\n{\n    if (num < 2) return false;\n    else if (num == 2) return true;\n    else if (num % 2 == 0) return false; // 偶数はあらかじめ除く\n\n    double sqrtNum = sqrt(num);\n    for (int i = 3; i <= sqrtNum; i += 2)\n    {\n        if (num % i == 0)\n        {\n            // 素数ではない\n            return false;\n        }\n    }\n\n    // 素数である\n    return true;\n}\n\n\n/*ページのソースを表示->command+F->問題文　で問題文コピペする\n\n*/\n//ceil()//切り上げ\n//floor()//切り捨て\n//round()//四捨五入\n//deque<ll> deq;//両端キュー使う，先頭と末尾へのアクセスが早い\n//using std::map;\n//map<string,ll>memo;//<キー，その要素＞，キーの検索が早い，キーは昇順にソートされる\nvoid erase(vector<vector<ll>>&m,ll x,ll y){\n  m[y][x]=0;\n}\nvector<vector<ll>> drop(vector<vector<ll>>&m){\n  vector<vector<ll>> v(32);\n  vector<vector<ll>> map(32,vector<ll>(32,0));\n  rrep(i,1,31)rep(j,1,31)if(m[i][j])v[j].push_back(m[i][j]);\n  rep(j,1,31){ll cnt=30;each(a,v[j]){map[cnt][j]=a;cnt--;}}\n  return map;\n}\nll solve(vector<vector<ll>> &m,ll x,ll y,ll k){\n  ll cnt=1;\n  ll ans=0;\n  vector<vector<ll>> m0;\n  m0=m;\n  erase(m0,x,y);\n  vector<vector<ll>> v=drop(m0);\n  rep(w,LPLMT){\n    ll an=ans;\n    rep(i,1,31)rep(j,1,31){\n    bool f=false;\n    ll len=1;\n    rep(a,1,31-i){if(v[j][i]!=v[j][i+a])break;len++;if(a==k-1)f=true;}\n    if(f)rep(a,len){ans+=cnt*v[j][i+a];erase(v,i+a,j);}\n    }\n    if(an==ans)break;\n    cnt*=2;\n    v=drop(v);\n  }\n  return ans;\n}\nsigned main(){\n    /*以下コード*/\n    ll ans=0;\n    ll sm=0;\n    LL(h,w,k);\n    std::vector<std::vector<ll>> m(32,vector<ll>(32,0));\n    std::set<pll> v;\n    rep(y,31-h,31)rep(x,1,w+1){\n      CHR(cyx);\n      m[y][x]=cyx-'0';\n      sm+=cyx;\n    }\n  if(k<4&&k>1){\n    rep(i,31-h,31)rep(j,1,w+1){\n      ll kari=solve(m,j,i,k);\n      chmax(ans,kari);\n    }\n    out(ans);\n  }\n  else if(k<2)out(sm);\n  else out(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ macro.cpp -std=c++14\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\nconst ll LINF = 1e18;\nusing namespace std;\n\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\"  ) << endl\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\"  ) << endl\n\n#define SANKOU(n,a,b) cout << ((n) ? (#a) : (#b) ) << endl\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define REPR(i,n) for(int i=n;i>=0;i--)\n\n#define FOREACH(x,a) for(auto& (x) : (a) )\n\n#define WFA(d,v) REP(k,v)REP(i,v)REP(j,v)d[i][j]=min(d[i][j],d[i][k]+d[k][j])\n\n#define SCOUT(x) cout<<(x)<<\" \"\n#define ENDL cout<<endl\n\n#define VECCIN(x) for(auto&youso_: (x) )cin>>youso_\n#define VECIN2(x,y) REP(i,x.size())cin>>x[i]>>y[i]\n#define VECCOUT(x) for(auto&youso_: (x) )cout<<youso_<<\" \";cout<<endl\n\n#define ALL(obj) (obj).begin(),(obj).end()\n\n#define EXIST(n,x) (find(ALL(n),x)!=n.end())\n#define UNIQUE(obj) sort(ALL( obj )); obj.erase(unique(ALL(obj)),obj.end())\n#define COUT(x) cout<<(x)<<endl\nvoid CINT(){}\ntemplate <class Head,class... Tail>\nvoid CINT(Head&& head,Tail&&... tail){\ncin>>head;\nCINT(move(tail)...);\n}\n#define CIN(...) int __VA_ARGS__;CINT(__VA_ARGS__)\n#define SCIN(...) string __VA_ARGS__;CINT(__VA_ARGS__)\n\n// #include <boost/multiprecision/cpp_int.hpp>\n// using namespace boost::multiprecision; // cpp_int\n\n#define P pair<int,int>\n#define V vector<int>\n#define M map<int,int>\n#define S set<int>\n#define L list<int>\n\n#define pb(a) push_back(a)\n#define mp make_pair\n\nll h,w,k;\nll Solve(vector<V> vec,int dan,int count,int point){\n    if(dan<0)return point;\n    bool wareware=true;\n    int ttttt=vec[dan][0];\n    REP(i,w)if(ttttt!=vec[dan][i])wareware=false;\n    if(!wareware)return point;\n\n    point+=(pow(2,count) * ttttt * w);\n    REPR(i,dan)REP(j,w)vec[i][j]=vec[i+1][j];\n    h--;\n    vec.erase(vec.begin()+(int)vec.size()-1);\n    return Solve(vec,dan-1,count+1,point++);\n\n\n}\n\nint main(){\n    \n    cin>>h>>w>>k;\n    vector<V> c(h,V(w));\n    REP(i,h){\n        SCIN(str);\n        REP(j,w){\n            c[i][j]=(int)str[j];\n        }\n    }\n\n    ll ans=0;\n    REP(i,h){\n        ans = max(ans,Solve(c,i,1,0));\n    }\n    COUT(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ macro.cpp -std=c++14\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\nconst ll LINF = 1e18;\nusing namespace std;\n\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\"  ) << endl\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\"  ) << endl\n\n#define SANKOU(n,a,b) cout << ((n) ? (#a) : (#b) ) << endl\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define REPR(i,n) for(int i=n;i>=0;i--)\n\n#define FOREACH(x,a) for(auto& (x) : (a) )\n\n#define WFA(d,v) REP(k,v)REP(i,v)REP(j,v)d[i][j]=min(d[i][j],d[i][k]+d[k][j])\n\n#define SCOUT(x) cout<<(x)<<\" \"\n#define ENDL cout<<endl\n\n#define VECCIN(x) for(auto&youso_: (x) )cin>>youso_\n#define VECIN2(x,y) REP(i,x.size())cin>>x[i]>>y[i]\n#define VECCOUT(x) for(auto&youso_: (x) )cout<<youso_<<\" \";cout<<endl\n\n#define ALL(obj) (obj).begin(),(obj).end()\n\n#define EXIST(n,x) (find(ALL(n),x)!=n.end())\n#define UNIQUE(obj) sort(ALL( obj )); obj.erase(unique(ALL(obj)),obj.end())\n#define COUT(x) cout<<(x)<<endl\nvoid CINT(){}\ntemplate <class Head,class... Tail>\nvoid CINT(Head&& head,Tail&&... tail){\ncin>>head;\nCINT(move(tail)...);\n}\n#define CIN(...) int __VA_ARGS__;CINT(__VA_ARGS__)\n#define SCIN(...) string __VA_ARGS__;CINT(__VA_ARGS__)\n\n// #include <boost/multiprecision/cpp_int.hpp>\n// using namespace boost::multiprecision; // cpp_int\n\n#define P pair<int,int>\n#define V vector<int>\n#define M map<int,int>\n#define S set<int>\n#define L list<int>\n\n#define pb(a) push_back(a)\n#define mp make_pair\n\nll h,w,k;\nll Solve(vector<V> vec,int dan,int count,int point){\n    if(dan<0)return point;\n    bool wareware=true;\n    int ttttt=vec[dan][0];\n    REP(i,w)if(ttttt!=vec[dan][i])wareware=false;\n    if(!wareware)return point;\n\n    point+=(pow(2,count) * ttttt * w);\n    REPR(i,dan)REP(j,w)vec[i][j]=vec[i+1][j];\n    h--;\n    vec.erase(vec.begin()+(int)vec.size()-1);\n    return Solve(vec,dan-1,count+1,point);\n\n\n}\n\nint main(){\n    \n    cin>>h>>w>>k;\n    vector<V> c(h,V(w));\n    REP(i,h){\n        SCIN(str);\n        REP(j,w){\n            c[i][j]=(int)str[j]-48;\n        }\n    }\n\n    ll ans=0;\n    REP(i,h){\n        ans = max(ans,Solve(c,i,0,0));\n    }\n    COUT(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair< ll, ll > Pi;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep2(i,n) for(int i=1;i<=(n);i++)\n#define rep3(i,i0,n) for(int i=i0;i<(n);i++)\n#define pb push_back\n#define mod 1000000007\nconst ll INF = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nll gcd(ll a, ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b) {return a/gcd(a,b)*b;}\n#define all(x) x.begin(), x.end()\n#define mp make_pair\nbool compare(Pi a, Pi b) {\n    if(a.first != b.first){\n        return a.first < b.first;\n        \n    }else{\n        return a.second < b.second;\n    }\n}\n\nint ctoi(char c) {\n\tif (c >= '0' && c <= '9') {\n\t\treturn c - '0';\n\t}\n\treturn 0;\n}\nbool In_map(ll y,ll x,ll h,ll w){\n    if(y<0 || x<0 || y>=h || x>=w){\n        return 0;\n    }else{\n        return 1;\n    }\n}\nconst vector<ll> dx{1,0,-1,0};\nconst vector<ll> dy{0,1,0,-1};\n\n\n\nint main() {\n\n    ll H,W,K;\n    cin >>H>>W>>K;\n    vector<string> S(H);\n    rep(i,H) cin >>S[i];\n    vector<vector<ll>> R(H,vector<ll>(W));\n    vector<vector<ll>> R2(H,vector<ll>(W));\n    rep(i,H) rep(j,W) R[i][j] = ctoi(S[i][j]);\n    R2 = R;\n    if(K<=1){\n        ll ans = 0;\n        ll min = INF;\n        rep(i,H){\n            rep(j,W){\n                chmin(min,R[i][j]);\n                ans+=R[i][j];\n            }\n        }\n        cout << ans-min<<endl;\n        return 0;\n    }\n\n\n    ll fans = 0;\n    rep(h,H) rep(w,H){\n    ll ans = 0;\n    R=R2;\n    R[h][w] = -1;\n    ll flag = 0;\n    rep(m,H){\n        ll p2 =pow(2,m); \n        rep(j,W){\n            vector<ll> tmp;\n            rep(i,H){\n                if(R[H-1-i][j] != -1){\n                    tmp.pb(R[H-1-i][j]);\n                }\n            }\n            rep(i,H){\n                if(i<tmp.size()){\n                    R[H-1-i][j] = tmp[i];\n                }else{\n                    R[H-1-i][j] = -1;\n                }\n            }\n        }\n        rep(i,H){\n            ll cnt=0;\n            ll p=-1;\n            rep(j,W){\n                if(R[i][j] == p && R[i][j] != -1){\n                    cnt++;\n                    if(j==W-1){\n                        if(cnt>=K){\n                            flag = 1;\n                            ans += R[i][j-1]*cnt*p2;\n                            rep(k,cnt){\n                                R[i][j-k] = -1;\n                            }\n                        }\n                    }\n                }else{\n                    if(cnt>=K){\n                        flag = 1;\n                        ans += R[i][j-1]*cnt*p2;\n                        rep(k,cnt){\n                            R[i][j-k-1] = -1;\n                        }\n                    }\n                    cnt = 1;\n                }\n                \n\n                p = R[i][j];\n            }\n        \n        \n        }\n        /*rep(i,H){\n            rep(j,W){\n                cout << R[i][j]<<\" \";\n            }\n            cout <<endl;\n        }*/\n        if(flag ==0) break;\n    }\n\n\n        chmax(fans,ans);\n    }\n\n    cout << fans<<endl;\n    \n    return 0;\n    \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair< ll, ll > Pi;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep2(i,n) for(int i=1;i<=(n);i++)\n#define rep3(i,i0,n) for(int i=i0;i<(n);i++)\n#define pb push_back\n#define mod 1000000007\nconst ll INF = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nll gcd(ll a, ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b) {return a/gcd(a,b)*b;}\n#define all(x) x.begin(), x.end()\n#define mp make_pair\nbool compare(Pi a, Pi b) {\n    if(a.first != b.first){\n        return a.first < b.first;\n        \n    }else{\n        return a.second < b.second;\n    }\n}\n\nint ctoi(char c) {\n\tif (c >= '0' && c <= '9') {\n\t\treturn c - '0';\n\t}\n\treturn 0;\n}\nbool In_map(ll y,ll x,ll h,ll w){\n    if(y<0 || x<0 || y>=h || x>=w){\n        return 0;\n    }else{\n        return 1;\n    }\n}\nconst vector<ll> dx{1,0,-1,0};\nconst vector<ll> dy{0,1,0,-1};\n\n\n\nint main() {\n\n    ll H,W,K;\n    cin >>H>>W>>K;\n    vector<string> S(H+1);\n    rep(i,H) cin >>S[i];\n    vector<vector<ll>> R(H+1,vector<ll>(W+1));\n    vector<vector<ll>> R2(H+1,vector<ll>(W+1));\n    rep(i,H) rep(j,W) R[i][j] = ctoi(S[i][j]);\n    R2 = R;\n    if(K<=1){\n        ll ans = 0;\n        ll min = INF;\n        rep(i,H){\n            rep(j,W){\n                chmin(min,R[i][j]);\n                ans+=R[i][j];\n            }\n        }\n        cout << ans-min<<endl;\n        return 0;\n    }\n\n\n    ll fans = 0;\n    rep(h,H) rep(w,H){\n    ll ans = 0;\n    R=R2;\n    R[h][w] = -1;\n    ll flag = 0;\n    rep(m,H){\n        ll p2 =pow(2,m); \n        /*rep(j,W){\n            vector<ll> tmp;\n            rep(i,H){\n                if(R[H-1-i][j] != -1){\n                    tmp.pb(R[H-1-i][j]);\n                }\n            }\n            rep(i,H){\n                if(i<tmp.size()){\n                    R[H-1-i][j] = tmp[i];\n                }else{\n                    R[H-1-i][j] = -1;\n                }\n            }\n        }*/\n        rep(i,H){\n            ll cnt=0;\n            ll p=-1;\n            rep(j,W){\n                if(R[i][j] == p && R[i][j] != -1){\n                    cnt++;\n                    if(j==W-1){\n                        if(cnt>=K){\n                            flag = 1;\n                            //ans += R[i][j-1]*cnt*p2;\n                            rep(k,cnt){\n                               // R[i][j-k] = -1;\n                            }\n                        }\n                    }\n                }else{\n                    if(cnt>=K){\n                        flag = 1;\n                        //ans += R[i][j-1]*cnt*p2;\n                        rep(k,cnt){\n                            //R[i][j-k-1] = -1;\n                        }\n                    }\n                    cnt = 1;\n                }\n                \n\n                p = R[i][j];\n            }\n        \n        \n        }\n        /*rep(i,H){\n            rep(j,W){\n                cout << R[i][j]<<\" \";\n            }\n            cout <<endl;\n        }*/\n        if(flag ==0) break;\n    }\n\n\n        chmax(fans,ans);\n    }\n\n    cout << fans<<endl;\n    \n    return 0;\n    \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E) REPS(i, S, E)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, S, E) DEPS(i, S, E)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline vll Mask2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\ninline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\ninline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(5) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(4);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tfriend mll operator / (ll a, const mll &b) { return mll(a)/b; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = 2099999999LL;// 998244353LL;//1000000007LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\n\n\nvoid solve()\n{\n\tll H, W, K;  cin >> H >> W >> K;\n\tvector<string> cstr = cinv<string>(H);\n\tvvll c(H, vll(W));\n\trep(i, 0, H-1) rep(j, 0, H-1){\n\t\tc[i][j] = (ll)(cstr[i][j]-'0');\n\t}\n\n\tll ans = 0;\n\tREPS(si, 0, H-1)REPS(sj, 0, W-1){\n\t\tvvll ban = c;\n\n\t\tll score = 0;\n\t\tban[si][sj] = 0;\n\t\tREPS(i,0,100000){\n\t\t\t//消えた場所を落とす\n\t\t\tREPS(j, 0, W-1){\n\t\t\t\tll idx=H-1;\n\t\t\t\tDEPS(i, 0, H-1){\n\t\t\t\t\tll val = ban[i][j];\n\t\t\t\t\tif (val == 0) continue;\n\t\t\t\t\tban[i][j] = 0;\n\t\t\t\t\tban[idx--][j] = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//現盤面の消える場所を調べる\n\t\t\tll sum=0;\n\t\t\tREPS(i, 0, H-1){\n\n\t\t\t\tll ren=1;\n\t\t\t\tREPS(j, 0, W-1){\n\t\t\t\t\t//右となりが同じ時\n\t\t\t\t\tif (j!=W-1 && ban[i][j]==ban[i][j+1]){\n\t\t\t\t\t\tren++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//異なる＆消滅\n\t\t\t\t\telse if (ren>=K){\n\t\t\t\t\t\tsum += ren*ban[i][j];\n\t\t\t\t\t\tREPS(k, 0, ren-1) ban[i][j-k]=0;\n\t\t\t\t\t\tren=1;\n\t\t\t\t\t}\n\t\t\t\t\telse{//異なる＆消滅しない\n\t\t\t\t\t\tren=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sum == 0) break;\n\t\t\tscore += sum * POW(2LL, i);\n\t\t}\n\t\tchmax(ans, score);\n\t}\n\tcout << ans << '\\n';\n}\n\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n\nint main() {\n\tint h = ri();\n\tint w = ri();\n\tint len = ri();\n\tstd::string s[h];\n\tfor (auto &i : s) std::cin >> i;\n\t\n\tint res = -1;\n\tfor (int i = 0; i < h; i++) for (int j = 0; j < w; j++) {\n\t\tint cur = 0;\n\t\tint times = 1;\n\t\tstd::string board[h];\n\t\tfor (int k = 0; k < h; k++) board[k] = s[k];\n\t\tbool first = true;\n\t\twhile (1) {\n\t\t\tbool drop[h][w];\n\t\t\tmemset(drop, 0, sizeof(drop));\n\t\t\tfor (int k = 0; k < h; k++) for (int l = 0; l <= w - len; l++) {\n\t\t\t\tbool ok = board[k][l] != '*';\n\t\t\t\tfor (int m = 0; m + 1 < len; m++) if (board[k][l + m] != board[k][l + m + 1]) ok = false;\n\t\t\t\tif (ok) for (int m = 0; m < len; m++) drop[k][l + m] = true;\n\t\t\t}\n\t\t\tbool just_first = first;\n\t\t\tif (first) drop[i][j] = true, first = false;\n\t\t\tint cur_sum = 0;\n\t\t\tfor (int k = 0; k < h; k++) for (int l = 0; l < w; l++)\n\t\t\t\tif (drop[k][l] && !(just_first && k == i && l == j)) cur_sum += board[k][l] - '0';\n\t\t\tif (!cur_sum && !just_first) break;\n\t\t\tcur += cur_sum * times;\n\t\t\tstd::string next[h];\n\t\t\tfor (auto &i : next) i = std::string(w, '*');\n\t\t\tfor (int k = 0; k < w; k++) {\n\t\t\t\tint head = h;\n\t\t\t\tfor (int l = h; l--; ) if (board[l][k] != '*' && !drop[l][k]) next[--head][k] = board[l][k];\n\t\t\t}\n\t\t\tfor (int k = 0; k < h; k++) board[k] = next[k];\n\t\t\tif (!just_first) times *= 2;\n\t\t}\n\t\tres = std::max(res, cur);\n\t}\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nll MOD = 1000000007;\n\n#define vec              vector<int>\n#define vecll            vector<ll>\n#define vecd             vector<double>\n#define vecst            vector<string>\n#define vecb             vector<bool>\n#define v2(v,n,m,init)   vector<vector<int>>  v(n, vector<int>(m, init))\n#define vb2(v,n,m,init)  vector<vector<bool>> v(n, vector<bool>(m, init))\n#define vll2(v,n,m,init) vector<vector<ll>>   v(n, vector<ll>(m, init))\n\n#define rep(i,n)         for(ll i=(ll)0; i<(ll)n; i++)\n#define REP(i,m,n)       for(ll i=(ll)m; i<(ll)n; i++)\n#define arr(var, n)      vec var(n); rep(i,n){cin >> var[i];}\n#define arrll(var, n)    vecll var(n); rep(i,n){cin >> var[i];}\n#define arrst(var, n)    vecst var(n); rep(i,n){cin >> var[i];}\n#define all(var)         (var).begin(), (var).end()\n#define sortall(var)     sort(all(var))\n#define uniqueall(v)     v.erase(unique(v.begin(), v.end()), v.end());\n#define pb(var)          push_back(var)\n#define prt(var)         cout << (var) << \"\\n\"\n#define prtd(n, var)     cout << fixed << setprecision(n) << (var) << \"\\n\"\n#define prtfill(n, var)  cout << setw(n) << setfill('0') << (var);\n#define prt2(v1, v2)     cout << (v1) << \" \" << (v2) << \"\\n\"\n#define prt3(v1, v2, v3) cout << (v1) << \" \" << (v2) << \" \" << (v3) << \"\\n\"\n#define prtall(v)        rep(i,v.size()){cout<<v[i]<<(i!=v.size()-1?\" \":\"\\n\");}\ntemplate <typename T>\nbool chmax(T &a, const T& b){if(a<b){a=b; return true;} return false;}\ntemplate <typename T>\nbool chmin(T &a, const T& b){if(a>b){a=b; return true;} return false;}\n//------------------------------------------------------------------\n\nvector<string> drop(vector<string> s){\n  vector<string> r;\n  int h = s.size();\n  int w = s[0].size();\n  rep(i,h){\n    string tmp=\"\";\n    rep(j,w){\n      tmp.push_back('0');\n    }\n    r.push_back(tmp);\n  }\n  rep(i,w){\n    int id=h-1;\n    for(int j=h-1; j>-1; j--){\n      if(s[j][i]!='0'){\n        r[id][i]=s[j][i];\n        id--;\n      }\n    }\n  }\n  return r;\n}\n\nint main(void){\n  int h, w, k;\n  cin >> h >> w >> k;\n  arrst(s,h);\n\n  int ans=0;\n  if(k>=4){\n    prt(ans);\n    return 0;\n  }\n  rep(delh,h){\n    rep(delw,w){\n      int anstmp=0;\n      vector<string> t = s;\n      t[delh][delw] = '0';\n      t = drop(t);\n      int p=1;\n      //prt(\"-----------------------\");\n      rep(x,h*w/k+1){\n        if(x!=0) p*=2;\n        int add=0;\n        /*\n        prt2(\"from =====>\", x);\n\n        rep(p,h){\n          rep(q,w){\n            cout << t[p][q] << (q!=w-1 ? \" \" : \"\\n\");\n          }\n        }\n        */\n\n        rep(a,h){\n          rep(b,w){\n            int tmp = t[a][b];\n            if(tmp=='0') continue;\n            int c=b;\n            int ct=0;\n            while(c<w){\n              if(t[a][c]==tmp) ct++, c++;\n              else {\n                break;\n              }\n            }\n            if(ct>=k){\n              rep(i,ct){\n                add += t[a][b+i]-'0';\n                t[a][b+i]='0';\n              }\n            }\n          }\n        }\n        /*\n        prt2(\"to =====>\", x);\n        rep(p,h){\n          rep(q,w){\n            cout << t[p][q] << (q!=w-1 ? \" \" : \"\\n\");\n          }\n        }\n        */\n\n        anstmp += add*p;\n        //prt3(\"score :\", anstmp, add*p);\n        t = drop(t);\n      }\n      chmax(ans, anstmp);\n    }\n  }\n\n\n  prt(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP1(i,k,n) for(int i=(int)k;i<(int)n;i++)\n#define REP2(i,k,n) for(int i=(int)k;i>(int)n;i--)\nusing namespace std;\n\nint main(){\n  int H,W,K,a=0;\n  cin>>H>>W>>K;\n  vector<string> B(H),b(H);\n  REP1(i,0,H){\n    cin>>B[i];\n    B[i]='#'+B[i]+'#';\n  }\n  REP1(i,1,H) REP1(j,1,W+1){\n    REP1(k,0,H) b[k]=B[k];\n    REP2(k,i,0) b[k][j]=b[k-1][j];\n    b[0][j]='s';\n    int p=0,x=0,f=1,z;\n    while(f){\n      f=0;\n      char c1,c2;\n      REP1(i1,0,H) REP1(j1,1,W+2){\n        if(j1==1) z=0;\n        c1=b[i1][j1-1];\n        c2=b[i1][j1];\n        if(c2==c1&&c1!='s'){\n          z++;\n          continue;\n        }\n        if(z>=K){\n          p+=(c1-'0')*z*pow(2,x);\n          REP2(i2,i1,0)\n            b[i2].replace(j1-z,z,b[i2-1].substr(j1-z,z));\n          b[0].replace(j1-z,z,z,'s');\n          f=1;\n        }\n        z=1;\n      }\n      x++;\n    }\n    a=max(a,p);     \n  }\n  cout<<a<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing piii = pair<int, pair<int, int>>;\nusing pll = pair<ll, ll>;\nusing pli = pair<ll, int>;\ntemplate <typename T>\nusing Graph = vector<vector<T>>;\nconst int MOD = 1e9 + 7;\n\nint H, W, K;\n\nint erase(vector<vector<int>> &board) {\n    int cnt = 0;\n    for (int i = 0; i < H; ++i) {\n        int r = 0;\n        for (int l = 0; l < W; ++l) {\n            while (r < W && board[i][l] && board[i][l] == board[i][r])\n                r++;\n            if (r - l >= K) {\n                cnt += (r - l) * board[i][l];\n                for (int j = l; j < r; ++j)\n                    board[i][j] = 0;\n            }\n        }\n    }\n    return cnt;\n}\n\nvoid fall(vector<vector<int>> &board) {\n    for (int i = 0; i < W; ++i) {\n        while (true) {\n            bool isswaped = false;\n            for (int j = 0; j < H - 1; ++j) {\n                if (!board[j][i] && board[j + 1][i]) {\n                    swap(board[j][i], board[j + 1][i]);\n                    isswaped = true;\n                }\n            }\n            if (!isswaped)\n                break;\n        }\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> H >> W >> K;\n    vector<vector<int>> board(H, vector<int>(W));\n    for (int i = H - 1; i >= 0; --i) {\n        for (int j = 0; j < W; ++j) {\n            char c;\n            cin >> c;\n            board[i][j] = c - '0';\n        }\n    }\n\n    ll ans = 0;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            auto cboard = board;\n            cboard[i][j] = 0;\n            fall(cboard);\n            ll point = 0;\n            int cnt = 0, a = 0;\n            while ((cnt = erase(cboard)) > 0) {\n                point += cnt * (1LL << a);\n                fall(cboard);\n                a++;\n            }\n            ans = max(ans, point);\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define all(x) x.begin(), x.end()\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define em emplace\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define REP(i, n) for(int i = 1; i <= n; i++)\ntemplate<class T> inline int chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline int chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst int INF = 1<<29;\nconst ll LINF = 1LL<<58;\nconst int mod = 1000000007;\n\nint h, w, k;\nint board[33][33];\n\nvoid change(int board[33][33]){\n    for (int j = 0; j < w; j++) {\n        for (int _ = 0; _ < h; _++) {\n            bool flag = 1;\n            for (int i = 0; i < h - 1; i++) {\n                if(board[i][j] == 0) {\n                    swap(board[i + 1][j], board[i][j]);\n                    flag = 0;\n                }\n            }\n            if(flag) break;\n        }\n    }\n    return;\n}\n\nint start(int y, int x){\n    int score = 0;\n    int grid[33][33];\n    rep(i, 33) rep(j, 33) grid[i][j] = board[i][j];\n\n    grid[y][x] = 0;\n    change(grid);\n\n    for (int l = 0; l < 40; l++) {\n        int sum = 0;\n        for (int i = 0; i < h; i++) {\n            int last = grid[i][0], idx = 0, cnt = 0;\n            while(idx < w) {\n                while (last == grid[i][idx]) {\n                    idx++;\n                    cnt++;\n                }\n                if (cnt >= k) {\n                    sum += last * cnt;\n                    for (int j = idx - 1; cnt; cnt--, j--) grid[i][j] = 0;\n                }\n                cnt = 0;\n                last = grid[i][idx];\n            }\n        }\n        if(sum == 0) break;\n        score += sum * pow(2, l);\n        change(grid);\n    }\n\n    return score;\n}\n\nint main(){\n    cin >> h >> w >> k;\n    memset(board, -1, sizeof board);\n    for (int i = h - 1; i >= 0; i--) for (int j = 0; j < w; j++) {\n        char c;\n        cin >> c;\n        board[i][j] = c - '0';\n    }\n    int ans = 0;\n    rep(i, h) rep(j, w) chmax(ans, start(i, j));\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint H,W,K;\nchar t[50][50];\nchar tmp[50][50];\n\nvoid down(){\n  for(int j=0;j<W;j++){\n    int cc=H-1;\n    for(int i=H-1;i>=0;i--){\n      if(t[i][j]=='.')continue;\n      t[cc--][j]=t[i][j];\n    }\n    for(int i=cc;i>=0;i--)t[i][j]='.';\n  }\n}\n\nint del(int depth){\n  int res=0;\n  for(int i=0;i<H;i++){\n    int cnt=0;\n    char key='.';\n    \n    for(int j=0;j<=W;j++){\n      if(j<W&&key==t[i][j])cnt++;\n      else{\n        if(key!='.'&&cnt>=K){\n          for(int k=0;k<cnt;k++){\n            t[i][j-1-k]='.';\n            res+=(1<<depth)*(key-'0');\n          }\n        }\n        key=t[i][j];\n        cnt=1;\n      }\n    }\n    \n  }\n  return res;\n}\n\nint solve(int sy,int sx){\n  for(int i=0;i<H;i++)for(int j=0;j<W;j++)tmp[i][j]=t[i][j];\n  t[sy][sx]='.';\n  down();\n  int res=0;\n  for(int i=0;;i++){\n    /*\n    if(sy==3&&sx==2){\n      for(int y=0;y<H;y++){\n        for(int x=0;x<W;x++){\n          cout<<t[y][x];\n        }\n        cout<<endl;\n      }\n      cout<<endl;\n    }\n    */\n    int num=del(i);\n    if(num==0)break;\n    res+=num;\n    down();\n  }\n  for(int i=0;i<H;i++)for(int j=0;j<W;j++)t[i][j]=tmp[i][j];\n  return res;\n}\n\nint main(){\n  cin>>H>>W>>K;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>t[i][j];\n\n  int ans=0;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      ans=max(ans,solve(i,j));\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing piii = pair<int, pair<int, int>>;\nusing pll = pair<ll, ll>;\nusing pli = pair<ll, int>;\ntemplate <typename T>\nusing Graph = vector<vector<T>>;\nconst int MOD = 1e9 + 7;\n\nint H, W, K;\n\nint erase(vector<vector<int>> &board) {\n    int cnt = 0;\n    for (int i = 0; i < H; ++i) {\n        int r = 0;\n        for (int l = 0; l < W; ++l) {\n            while (r < W && board[i][l] && board[i][l] == board[i][r])\n                r++;\n            if (r - l >= K) {\n                cnt += (r - l) * board[i][l];\n                for (int j = l; j < r; ++j)\n                    board[i][j] = 0;\n            }\n        }\n    }\n    return cnt;\n}\n\nvoid fall(vector<vector<int>> &board) {\n    for (int i = 0; i < W; ++i) {\n        while (true) {\n            bool isswaped = false;\n            for (int j = 0; j < H - 1; ++j) {\n                if (!board[j][i] && board[j + 1][i]) {\n                    swap(board[j][i], board[j + 1][i]);\n                    isswaped = true;\n                }\n            }\n            if (!isswaped)\n                break;\n        }\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> H >> W >> K;\n    vector<vector<int>> board(H, vector<int>(W));\n    for (int i = H - 1; i >= 0; --i) {\n        for (int j = 0; j < W; ++j) {\n            char c;\n            cin >> c;\n            board[i][j] = c - '0';\n        }\n    }\n\n    int ans = 0;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            auto cboard = board;\n            cboard[i][j] = 0;\n            fall(cboard);\n            int point = 0, cnt = 0, a = 1;\n            while ((cnt = erase(cboard)) > 0) {\n                point += cnt * a;\n                fall(cboard);\n                a *= 2;\n            }\n            ans = max(ans, point);\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define REPR(i, n) for(int i = n; i >= 0; i--)\n#define FOR(i, m, n) for(int i = m; i < n; i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define INF 1e9\ntypedef long long ll;\n\n\nvoid fall(vector<vector<int>>& board, int H, int W){\n    REP(n,H){\n        for(int i=H; i>=1; i--){\n            REP(j,W){\n                if(board[i][j]==0){\n                    board[i][j]=board[i-1][j];\n                    board[i-1][j]=0;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    \n    int H,W,K; cin >> H >> W >> K;\n\n    vector<vector<int>> board_origin(H+1, vector<int>(W, 0));\n    vector<vector<int>> board(H+1, vector<int>(W, 0));\n    FOR(i,1,H+1){\n        string S;\n        cin >> S;\n        REP(j,W){\n            \n            board_origin[i][j] = S[j] - '0';\n        }\n    }\n\n    int ans_max = 0;\n\n    FOR(i,1,H+1){\n        REP(j,W){//はじめに消すモノを全探索\n\n            FOR(x,0,H+1){\n                REP(y,W){\n                    board[x][y] = board_origin[x][y];\n                }\n            }\n\n            board[i][j] = 0;\n            fall(board,H,W);\n\n            int counter = 1;\n            int ans = 0;\n            int ans_before = 0;\n\n\n            while(1){\n                FOR(i,1,H+1){\n                    int num = 0;\n                    int count = 0;\n                    REP(j,W){\n                        if(num == board[i][j]){\n                            count++;\n                            if(count >= K && j==W-1){\n                                ans += pow(2,counter-1) * count * num;\n                                for(int k= j; k>=j-count+1; k--){\n                                    board[i][k] = 0;\n                                }\n                            }\n                        }else{\n                            if(count >= K){\n                                ans += pow(2,counter-1) * count * num;\n                                for(int k= j-1; k>=j-count; k--){\n                                    board[i][k] = 0;\n                                }\n                            }\n                            num = board[i][j];\n                            count = 1;\n                        }\n                    }  \n                }\n                fall(board,H,W);\n\n                if(ans == ans_before){\n                    ans_max = max(ans_max, ans);\n                    break;\n                }\n                ans_before = ans;\n                counter ++;\n\n                // FOR(i,1,H+1){\n                //     REP(j,5){\n                //         cout << board[i][j] << \" \";\n                //     }\n                //     cout << endl;\n                // }\n            }\n        }\n    }\n    cout << ans_max << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MOD=1000000007;\n#define INF 1LL<<30\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\n\nint main(){\n    int h,w,K;\n    cin>>h>>w>>K;\n    \n    char t[h][w];\n    int table[h][w],table_cp[h][w],table_cp2[h][w];\n    rep(i,h){\n        rep(j,w){\n            cin>>t[i][j];\n            table[i][j]=t[i][j]-'0';\n        }\n    }\n\n    int ans=0;\n    rep(i,h){\n        rep(j,w){\n            int tmp=0;\n            rep(k,h) rep(l,w) table_cp[k][l]=table[k][l];\n            rep(k,h) rep(l,w) table_cp2[k][l]=table[k][l];\n            table_cp2[i][j]=0;\n            int cnt=h;\n            while(cnt--){\n                for(int k=h-1;k>0;k--){\n                    rep(l,w){\n                        if(table_cp2[k][l]==0){\n                            table_cp2[k][l]=table_cp2[k-1][l];\n                            table_cp2[k-1][l]=0;\n                        }\n                    }\n                }\n            }\n            rep(k,h){\n                rep(l,w){\n                    table_cp[k][l]=table_cp2[k][l];\n                }\n            }\n\n\n            bool flag=true;\n            int num=0;\n            while(flag){\n                rep(k,h) rep(l,w) table_cp2[k][l]=table_cp[k][l];\n                flag=false;\n                for(int k=h;k>=0;k--){\n                    int nn=1;\n                    for(int l=0;l<w-1;l++){\n                        if(table_cp[k][l] && table_cp[k][l]==table_cp[k][l+1]){\n                            nn++;\n                        }\n                        else{\n                            if(nn>=K){\n                                flag=true;\n                                for(int jj=l-nn+1;jj<=k;jj++) table_cp2[k][jj]=0;\n                            }\n                            nn=1;\n                        }\n                    }\n                    if(nn>=K){\n                        flag=true;\n                        for(int jj=w-nn;jj<=w-1;jj++) table_cp2[k][jj]=0;\n                    }\n                }\n\n                int tm=0;\n                rep(k,h) rep(l,w) tm+=table_cp[k][l]-table_cp2[k][l];\n                tmp+=pow(2,num)*tm;\n\n                cnt=h;\n                while(cnt--){\n                    for(int k=h-1;k>0;k--){\n                        rep(l,w){\n                            if(table_cp2[k][l]==0){\n                                table_cp2[k][l]=table_cp2[k-1][l];\n                                table_cp2[k-1][l]=0;\n                            }\n                        }\n                    }\n                }\n\n                rep(k,h){\n                    rep(l,w){\n                        table_cp[k][l]=table_cp2[k][l];\n                    }\n                }\n                num++;\n            }\n\n            //if(i==3 && j==2) cout<<tmp<<endl;\n            ans=max(ans,tmp);\n        }\n    }\n\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll,ll> pl;\ntypedef vector<pl> vp;\n#define fore(i,a,b) for(ll i=(ll)(a);i<=(ll)(b);++i)\n#define rep(i,n) fore(i,0,(n)-1)\n#define rfore(i,a,b) for(ll i=(ll)(b);i>=(ll)(a);--i)\n#define rrep(i,n) rfore(i,0,(n)-1)\n#define all(x) (x).begin(),(x).end()\nconst ll INF=1001001001;\nconst ll LINF=1001001001001001001;\nconst ll D4[]={0,1,0,-1,0};\nconst ll D8[]={0,1,1,0,-1,-1,1,-1,0};\ntemplate<class T>\nbool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>\nbool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\n\nll del(vvl &a){\n    ll h=a.size(),w=a[0].size();\n    ll ret=0;\n    rep(i,h)rep(j,w){\n        if(a[i][j]==0)continue;\n        ll k=j;\n        while(k<w-1&&a[i][k+1]==a[i][j])k++;\n        if(k>j){\n            fore(l,j,k){\n                ret+=a[i][l];\n                a[i][l]=0;\n            }\n            j=k;\n        }\n    }\n    return ret;\n}\nvoid move(vvl &a){\n    ll h=a.size(),w=a[0].size();\n    rep(i,w){\n        ll idx=h-1;\n        rrep(j,h){\n            if(a[j][i]){\n                if(idx!=j){\n                    a[idx][i]=a[j][i];\n                    a[j][i]=0;\n                }\n                idx--;\n            }\n        }\n    }\n}\nll f(vvl a,ll i,ll j){\n    a[i][j]=0;\n    ll ret=0;\n    ll times=1;\n    while(1){\n        move(a);\n        ll score=del(a);\n        if(score==0)break;\n        ret+=score*times;\n        times*=2;\n    }\n    return ret;\n}\nvoid solve(){\n    ll h,w,k;cin>>h>>w>>k;\n    vector<string> c(h);rep(i,h)cin>>c[i];\n    \n    vvl a(h,vl(w));\n    rep(i,h)rep(j,w)a[i][j]=c[i][j]-'0';\n\n    ll ans=0;\n    rep(i,h)rep(j,w)chmax(ans,f(a,i,j));\n    cout<<ans<<endl;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\n#define N_MAX 40010\n#define INF 1e9\n#define F_MAX 200000\n\nint h, w, k;\n\nint score(vector<queue<int> > vq, int n){\n    vector<queue<int> > vq_next(w);\n    int res = 0;\n    cout << endl;\n    REP(p,h){\n        VI a(w+1);\n        REP(j,w){\n            if (!vq[j].empty()) {\n                a[j] = vq[j].front();\n                vq[j].pop();\n            }\n        }\n        // REP(i,w){\n        //     cout << a[i];\n        // }\n        // cout << endl;\n        REP(i,w){\n            int j = 0;\n            while (a[j+i] == a[i] && j+i < w) j++;\n            if (j >= k) {\n                res += a[i] * j;\n                REP(q,j) a[i+q] = 0;\n            }\n            i += j-1;\n        }\n        REP(i,w){\n            if (a[i] > 0)\n                vq_next[i].push(a[i]);\n        }\n    }\n    res <<= n;\n    if (res == 0) return res;\n    else return res + score(vq_next, n+1);\n}\n\nint main() {\n    cin >> h >> w >> k;\n    VVI c(w,VI(h));\n\n    REP(i,h){\n        string s;\n        cin >> s;\n        REP(j,w) c[j][h-1-i] = s[j] - '0';\n    }\n\n    int ans = 0;\n    REP(e,w){\n        vector<queue<int> > vq(w);\n        REP(i,w) REP(j,h){\n            if (i != e || j > 0)\n                vq[i].push(c[i][j]);\n        }\n        int res = score(vq, 0);\n        ans = max(ans, res);\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid erup( vector<string> &t, int i, int j )\n{\n\tt[i][j] = ' ';\n\tfor( int k = i; k - 1 >= 0; k-- ) {\n\t\tif(  t[k - 1][j] == ' ' ) break;\n\t\tt[k][j] = t[k - 1][j];\n\t\tt[k - 1][j] = ' ';\n\t}\n}\n\nvoid chk( vector<string> &t, int i, int j, int W, int K, vector<pair<int, int>> &er )\n{\n\tfor( int k = i; k >= 0; k-- ) {\n\t\tif( t[k][j] == ' ' ) break;\n\t\tif( j > 0 && t[k][j] == t[k][j - 1] || j + 1 < W && t[k][j] == t[k][j + 1] ) {\n\t\t\tvector<pair<int, int>> tv;\n\t\t\tchar nc = t[k][j];\n\t\t\ttv.push_back( make_pair( k, j ) );\n\t\t\tfor( int l = j - 1; l >= 0; l-- ) {\n\t\t\t\tif( t[k][l] != nc ) break;\n\t\t\t\ttv.push_back( make_pair( k, l ) );\n\t\t\t}\n\t\t\tfor( int l = j + 1; l < W; l++ ) {\n\t\t\t\tif( t[k][l] != nc ) break;\n\t\t\t\ttv.push_back( make_pair( k, l ) );\n\t\t\t}\n\t\t\tif( tv.size() >= K ) er.insert( er.end(), tv.begin(), tv.end() );\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint H, W, K;\n\tcin >> H >> W >> K;\n\tvector<string> c( H );\n\tfor( int i = 0; i < H; i++ ) {\n\t\tcin >> c[i];\n\t}\n\n\tlong long ans = 0;\n\tfor( int i = 0; i < H; i++ ) {\n\t\tfor( int j = 0; j < W; j++ ) {\n\t\t\tvector<string> t = c;\n\t\t\tlong long sc = 0;\n\t\t\terup( t, i, j );\n\t\t\tint idx = 0;\n\t\t\tset<int> st;\n\t\t\twhile( 1 ) {\n\t\t\t\tvector<pair<int, int>> er;\n\t\t\t\tif( idx == 0 ) {\n\t\t\t\t\tchk( t, i, j, W, K, er );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor( auto it = st.begin(); it != st.end(); it++ ) {\n\t\t\t\t\t\tchk( t, i, *it, W, K, er );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( er.size() == 0 ) break;\n\t\t\t\ter.erase( unique( er.begin(), er.end() ), er.end() );\n\t\t\t\tint sum = 0;\n\t\t\t\tfor( int k = 0; k < er.size(); k++ ) sum += t[er[k].first][er[k].second] - '0';\n\t\t\t\tsc += (1LL << idx) * sum;\n\t\t\t\tidx++;\n\t\t\t\tans = max( ans, sc );\n\t\t\t\tst.clear();\n\t\t\t\twhile( er.size() ) {\n\t\t\t\t\tint ii, jj;\n\t\t\t\t\ttie( ii, jj ) = er.back();\n\t\t\t\t\ter.pop_back();\n\t\t\t\t\tst.insert( jj );\n\t\t\t\t\terup( t, ii, jj );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n//#pragma GCC optimize (\"-O3\") \n#ifdef YANG33\n#include \"mydebug.hpp\"\n#else\n#define DD(x) \n#endif\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\n\n/* -----  2019/07/09  Problem: SQUARE869120CONTEST_03 B / Link: https://atcoder.jp/contests/s8pc-3/  ----- */\n\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tLL H, W, K; cin >> H >> W >> K;\n\tassert(K > 1);\n\tvector<string> s(H);\n\tfor (int i = 0; i < H; ++i) {\n\t\tcin >> s[i];\n\t\tFOR(j, 0, W) {\n\t\t\ts[i][j] -= '0';\n\t\t}\n\t}\n\tauto fall = [](VS& s) {\n\t\tint H = SZ(s), W = SZ(s[0]);\n\t\tFOR(j, 0, W) {\n\t\t\tvector<int>a;\n\t\t\tFOR(i, 0, H) {\n\t\t\t\tif (s[i][j])a.push_back(s[i][j]);\n\t\t\t\ts[i][j] = 0;\n\t\t\t}\n\t\t\tFOR(i, 0, SZ(a)) {\n\t\t\t\ts[H - i - 1][j] = a[SZ(a) - 1 - i];\n\t\t\t}\n\t\t}\n\t};\n\tauto f = [&K, &fall](int aa, int bb, auto s) {\n\t\ts[aa][bb] = 0;\n\t\tLL ret = 0;\n\t\tbool upd = 1;\n\t\tLL t = 0;\n\t\tint H = SZ(s), W = SZ(s[0]);\n\t\twhile (upd) {\n\t\t\tfall(s);\n\t\t\tupd = 0;\n\t\t\tLL sub = 0;\n\t\t\t{ // check\n\t\t\t\tFOR(i, 0, H) {\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tint pre = -1;\n\t\t\t\t\tFOR(j, 0, W) {\n\t\t\t\t\t\tif (s[i][j] == pre)cnt++;\n\t\t\t\t\t\telse if (s[i][j] != pre && cnt >= K) {\n\t\t\t\t\t\t\tupd |= pre;\n\t\t\t\t\t\t\twhile (cnt) {\n\t\t\t\t\t\t\t\tint k = j - cnt;\n\t\t\t\t\t\t\t\tsub += s[i][k];\n\t\t\t\t\t\t\t\ts[i][k] = 0;\n\t\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpre = s[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (s[i][j] != pre) {\n\t\t\t\t\t\t\tpre = s[i][j];\n\t\t\t\t\t\t\tcnt = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (pre != -1 && cnt >= K) {\n\t\t\t\t\t\tupd |= pre;\n\t\t\t\t\t\twhile (cnt) {\n\t\t\t\t\t\t\tint k = W - cnt;\n\t\t\t\t\t\t\tsub += s[i][k];\n\t\t\t\t\t\t\ts[i][k] = 0;\n\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tret += (LL)pow(2LL, t)*sub;\n\t\t\tt++;\n\t\t}\n\t\treturn ret;\n\t};\n\tLL ans = 0LL;\n\tFOR(i, 0, H) {\n\t\tFOR(j, 0, W) {\n\t\t\tans = max(ans, f(i, j, s));\n\t\t}\n\t}\n\n\n\tcout << (ans) << \"\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint main() {\n\tint H, W, K; cin >> H >> W >> K;\n\tvector<vector<int> > a(H, vector<int>(W));\n\trep(y, H) {\n\t\tstring s; cin >> s;\n\t\trep(x, W) a[y][x] = s[x] - '0';\n\t}\n\tll ma = 0;\n\trep(y0, H) rep(x0, W) {\n\t\tvector<vector<int> > b = a;\n\t\tb[y0][x0] = 0;\n\t\tll ans = 0;\n\t\trep(t, 32) {\n\t\t\trep(x, W) {\n\t\t\t\tint _y = H - 1;\n\t\t\t\tfor (int y = H - 1; y >= 0; y--)\n\t\t\t\t\tif (b[y][x]) {\n\t\t\t\t\t\tint tmp = b[y][x];\n\t\t\t\t\t\tb[y][x] = 0;\n\t\t\t\t\t\tb[_y--][x] = tmp;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\trep(y, H) {\n\t\t\t\tvector<int> v;\n\t\t\t\tv.pb(0);\n\t\t\t\tfor (int x = 1; x <= W - 1; x++)\n\t\t\t\t\tif (!b[y][x - 1] || !b[y][x] || b[y][x - 1] != b[y][x])\n\t\t\t\t\t\tv.pb(x);\n\t\t\t\tv.pb(W);\n\t\t\t\tfor (int k = 0; k + 1 < v.size(); k++) {\n\t\t\t\t\tint l = v[k], r = v[k + 1];\n\t\t\t\t\tif (r - l < K) continue;\n\t\t\t\t\tfor (int x = l; x < r; x++) {\n\t\t\t\t\t\tans += b[y][x] * (1LL<<t);\n\t\t\t\t\t\tb[y][x] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tma = max(ma, ans);\n\t}\n\tcout << ma << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) for(int i=0; i<(n); i++)\n#define REP2(i,x,n) for(int i=x; i<(n); i++)\n#define PRINT(x) cout<<(x)<<endl\n#define INF 1000000000000 // 10^12\n#define MOD 1000000007 // 10^9+7\n#define PB push_back\n#define MP make_pair\n\nconst int MAX_H = 30, MAX_W = 30;\n\nint H, W, K;\nchar c[MAX_H][MAX_W];\n\nint c_copy[MAX_H][MAX_W];\nint next_cell_row[MAX_H][MAX_W];\n\nint solve();\nint erase(int, int);\nint calc_score();\nint update_cell(int);\nvoid print_cell();\n\nint main() {\n    cin >> H >> W >> K;\n    REP(i, H) REP(j, W) cin >> c[i][j];\n    int max_score = solve();\n    PRINT(max_score);\n    return 0;\n}\n\nint solve() {\n    int max_score = 0;\n    REP(i, H) REP(j, W) max_score = max(max_score, erase(i, j));\n    return max_score;\n}\n\nint erase(int h, int w) {\n    REP(i, H) REP(j, W) c_copy[i][j] = c[i][j] - '0';\n    c_copy[h][w] = -1;\n    int score = calc_score();\n    return score;\n}\n\nint calc_score() {\n    int score = 0;\n    int pow2 = 1;\n    update_cell(0);\n    while (true) {\n        // print_cell();\n        int ds = update_cell(pow2);\n        if (ds == 0) return score;\n        score += ds;\n        pow2 *= 2;\n    }\n}\n\nint update_cell(int pow2) {\n    int score = 0;\n\n    // 消すマスを-1に変えつつ, スコアを計算\n    REP(i, H) {\n        int len_chain = 0;\n        int last_num = -1;\n        REP(j, W) {\n            if (c_copy[i][j] == last_num) {\n                len_chain++;\n                if (j == W-1 && len_chain >= K && last_num != -1) {\n                    score += pow2 * len_chain * last_num;\n                    REP(k, len_chain) c_copy[i][j-k] = -1;\n                }\n            }\n            else { \n                if (len_chain >= K && last_num != -1) {\n                    score += pow2 * len_chain * last_num;\n                    REP(k, len_chain) c_copy[i][j-k-1] = -1;\n                }\n                len_chain = 1;\n                last_num = c_copy[i][j];\n            }\n        }\n    }\n\n    // 次のマスが現在のどの番地のマスになるか調べる\n    for (int i = H-1; i >= 0; i--) REP(j, W) {\n        if (i == H-1) next_cell_row[i][j] = H-1;\n        else next_cell_row[i][j] = max(-1, next_cell_row[i+1][j] - 1);\n        while (true) {\n            if (next_cell_row[i][j] == -1) break;\n            if (c_copy[next_cell_row[i][j]][j] != -1) break;\n            next_cell_row[i][j]--;\n        }\n    }\n\n    // マスを更新\n    for (int i = H-1; i >= 0; i--) REP(j, W) {\n        if (next_cell_row[i][j] == -1) c_copy[i][j] = -1;\n        else c_copy[i][j] = c_copy[next_cell_row[i][j]][j];\n    }\n\n    return score;\n}\n\nvoid print_cell() {\n    REP(i, 50) printf(\"-\");\n    printf(\"\\n\");\n    REP(i, H) {\n        REP(j, W) printf(\"%2d \", c_copy[i][j]);\n        printf(\"\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(i=0;i<n;i++)\n#define ll long long\n#define all(v) v.begin(), v.end()\nint main(){\n  int h,w,k;cin>>h>>w>>k;vector<vector<int>> c(h,vector<int>(w));\n  int i,j,l,n,p;\n  rep(i,h)rep(j,w){\n    char ch;cin>>ch;\n    c[i][j]=(ch-'0');\n  }\n  int ans=0;\n  rep(i,h)rep(j,w){\n    bool update=1;vector<vector<int>> m=c;\n    m[i][j]=0;int score=0,timev=1;\n    while(update) {\n      update=0;\n      rep(n,w){\n        int to=h-1;\n        for(l=h-1;l>=0;l--){\n          if(m[l][n]!=0){\n            swap(m[to][n],m[l][n]);to--;\n          }\n        }\n      }\n      int get=0;\n      rep(l,h){\n        int from=0,now=m[l][w-1];\n        rep(n,w){\n          if(now!=m[l][n]){\n            int dis=(n-1)-from+1;\n            if(dis>=k){\n              for(p=from;p<n;p++) {\n                get+=m[l][p];m[l][p]=0;\n              }\n            }from=n;now=m[l][n];\n          }\n        }\n        int dis=(w-1)-from+1;\n        if(dis>=k){\n          for(p=from;p<n;p++){\n            get+=m[l][p];m[l][p]=0;\n          }\n        }\n      }\n      if(get>0)update=1;\n      else break;\n      score+=timev*get; timev*=2;\n    }ans=max(ans,score);\n  }cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\n#define F first\n#define S second\n\nconst int mx=200010;\nconst ll mod=1e9+7;\n\n\nint main() {\n  int h,w,k;\n  cin >> h >> w >> k;\n  vector<vector<int>> data(30, vector<int>(30,0));\n  rep(i,h)rep(j,w) cin >> data[i][j];\n\n  ll ans=0;\n  rep(x,h)rep(y,w){\n    auto c = data;\n    c[x][y] = 0;\n    ll base = 0, res = 0;\n    while(true){\n      ll tmp = 0;\n      rep(i,h){\n        int st=0;\n        rep(j,w+1){\n          if(j==w || (j>0 && c[i][j-1]!=c[i][j])){\n            if(j-st>=k){ for(int p=st; p<j; p++){ tmp+=c[i][p]; c[i][p]=0; } }\n            st = j;\n          }\n        }\n      }\n      if(base!=0 && tmp==0) break;\n      res += base*tmp;\n      base = (base>0?base*2:1);\n\n      rep(j,w){\n        int pos = h-1;\n        for(int i=h-1; i>=0; i--){\n          if(c[i][j]!=0){\n            c[pos][j] = c[i][j];\n            if(pos!=i) c[i][j] = 0;\n            pos--;\n          }\n        }\n      }\n    }\n    ans = max(ans, res);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\ntypedef long long lint;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef unsigned long long ulint;\n#define endl '\\n'\n#define fst first\n#define sed second\n#define pb push_back\n#define mp make_pair\n#define rint register int\n#define newline putchar('\\n')\n#define leave_space putchar(' ')\n#define all(x) (x).begin(), (x).end()\n#define reveal(x) cerr << #x << \" = \" << (x) << endl\n#define rep(it, f, e) for (rint it = (f); it <= (e); ++it)\n#define per(it, f, e) for (rint it = (f); it >= (e); --it)\nconst int MAXN = 32;\nint n, m, k;\nchar maze[MAXN][MAXN];\nint use[MAXN][MAXN], cpy[MAXN][MAXN];\ninline void falldown(int x, int y) {\n\twhile (x && use[x - 1][y]) {\n\t\tswap(use[x][y], use[x - 1][y]); --x;\n\t}\n}\ninline int dfs() {\n\tint ret = 0;\n\trep (i, 1, n) {\n\t\tint las = 0;\n\t\tvector<int> FD;\n\t\trep (j, 1, m) {\n\t\t\tif (!use[i][j]) las = 0;\n\t\t\telse if (use[i][j] == use[i][j - 1]) ++las;\n\t\t\telse las = 1;\n\t\t\tif (las >= k) {\n\t\t\t\tret += use[i][j];\n\t\t\t\tif (las == k) {\n\t\t\t\t\tret += use[i][j] * (k - 1);\n\t\t\t\t\trep (K, j - k + 1, j) {\n\t\t\t\t\t\tFD.pb(K);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tFD.pb(j);\n\t\t\t\t\tfalldown(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto p : FD) {\n\t\t\tuse[i][p] = 0;\n\t\t\tfalldown(i, p);\n\t\t}\n\t}\n\tif (ret) ret += dfs() * 2;\n\treturn ret;\n}\nint main() {\n\tcin >> n >> m >> k;\n\trep (i, 1, n) {\n\t\tcin >> (maze[i] + 1);\n\t\trep (j, 1, m) {\n\t\t\tcpy[i][j] = maze[i][j] - '0';\n\t\t}\n\t}\n\tint ans = 0;\n\trep (i, 1, n) {\n\t\trep (j, 1, m) {\n\t\t\tmemcpy(use, cpy, sizeof(use));\n\t\t\tuse[i][j] = 0;\n\t\t\tfalldown(i, j);\n\t\t\tans = max(ans, dfs());\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <array>\n#include <tuple>\n#include <string>\n#include <algorithm>\n#include <functional> // greater など\n#include <cmath>      // abs など\n#include <numeric>    // accumulate, gcd など\n#include <cassert>    // assert\n#include <stdexcept>\n#include <bitset>\nusing namespace std;\n\n// #include <boost/multiprecision/cpp_int.hpp>\n// using namespace boost::multiprecision;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\ntypedef long long ll;\n// typedef int128_t ll;\n// typedef cpp_int ll;\n\n// GCC, 配列のアクセスなど\n#define _GLIBCXX_DEBUG\n// Clang, 配列のアクセスなど\n#define _LIBCPP_DEBUG 0\n\n#define NDEBUG 1\n// debug用出力 https://trap.jp/post/998/\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T)\n{\n    cerr << H << \" \";\n    debug_out(T...);\n}\n#ifdef NDEBUG\n#define debug(...)\n#else\n#define debug(...) debug_out(__VA_ARGS__)\n#endif\n\n//////////////// //////////////// //////////////// //////////////// ////////////////\n//////////////// //////////////// //////////////// //////////////// ////////////////\n\nint h,w,k;\nvector<vector<int>> ini(30, vector<int>(30));\nvector<vector<int>> cur(30, vector<int>(30));\nint res;\n\nint calc(int i0, int j0) {\n    // 石を消滅、落下\n    for (int i = i0; i >= 0; i--) {\n        cur[i+1][j0] = cur[i][j0];\n    }\n    cur[0][j0] = -1;\n#ifndef NDEBUG\n    rep(i, h)\n    {\n        rep(j, w) { cerr << cur[i][j]; }\n        cerr << '\\n';\n    }\n#endif\n\n    int res = 0;\n    for (int turn = 0; turn < 32; turn++) {\n        int cur_score = 0;\n        rep(i,h) {\n            int cnt = 0; int col = -1;\n            rep(j,w) {\n                if (col > 0 && cur[i][j] == col) {\n                    cnt++;\n                    if (cnt == k)\n                    {\n                        rep(j1, k)\n                        {\n                            cur[i][j - j1] = -1;\n                        }\n                        cur_score += k * col;\n                    }\n                    else if (cnt > k) {\n                        cur[i][j] = -1;\n                        cur_score += col;\n                    }\n                } else {\n                    col = cur[i][j];\n                    cnt = 1;\n                }\n            }\n        }\n        if(cur_score == 0) { break; }\n        res += cur_score * (1 << turn);\n        debug(\"score\", cur_score);\n\n#ifndef NDEBUG\n        rep(i, h)\n        {\n            rep(j, w) { cerr << cur[i][j]; }\n            cerr << '\\n';\n        }\n#endif\n\n        // 落下\n        rep(j,w) {\n            queue<int> prev;\n            for (int i = h-1; i >= 0; i--) {\n                if (cur[i][j] == -1) { prev.push(i); continue; }\n                if (prev.empty()) { continue; }\n                int i1 = prev.front(); prev.pop();\n                cur[i1][j] = cur[i][j];\n                cur[i][j] = -1;\n                prev.push(i);\n            }\n        }\n\n    }\n\n    return res;\n}\n\nint main()\n{\n    // 高速な入出力\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << setprecision(15); // 浮動小数の表示の精度\n\n    cin>>h>>w>>k;\n    rep(i,h) {\n        rep(j,w) {\n            char c; cin>>c;\n            ini[i][j] = c - '0';\n        }\n    }\n\n    rep(i,h) {\n        rep(j,w) {\n            rep(i,h) {\n                rep(j,w) {\n                    cur[i][j] = ini[i][j];\n                }\n            }\n            res = max(res, calc(i,j));\n            debug(j, res);\n        }\n    }\n    cout<<res<<'\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(i = 0;i < n;++i)\n#define all(v) v.begin(), v.end()\nusing ll = long long;\n\nll pow_mod(ll a, ll n, ll p)\n{\n    ll res = 1;\n    while(n > 0){\n        if(n & 1) res = res*a%p;\n        a = a*a%p;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main()\n{\n    ll i,j;\n    ll h,w,k;\n    cin >> h >> w >> k;\n    vector<vector<ll>> c(h,vector<ll>(w));\n    for(i = 0;i < h;++i){\n        string s;\n        cin >> s;\n        rep(j,w){\n            c.at(i).at(j) = s.at(j) - '0';\n        }\n    }\n    ll ans = 0;\n    for(i = 0;i < h;++i){\n        rep(j,w){\n            vector<vector<ll>> cc = c;\n            cc.at(i).at(j) = 0;\n            ll tmp = 0;\n            ll stage = 0;\n            while(true){\n                ll ii,jj;\n                rep(jj,w){\n                    vector<ll> notzero;\n                    for(ii = h-1;ii >= 0;--ii){\n                        if(cc.at(ii).at(jj) != 0) notzero.push_back(cc.at(ii).at(jj));\n                    }\n                    for(ii = 0;ii < notzero.size();++ii){\n                        cc.at(h-1-ii).at(jj) = notzero.at(ii);\n                    }\n                    for(ii = ii;ii < h;++ii){\n                        cc.at(h-1-ii).at(jj) = 0;\n                    }\n                }\n                /**\n                for(ii = 0;ii < h;++ii){\n                    rep(jj,w-1){\n                        cout << cc.at(ii).at(jj) << \" \";\n                    }\n                    cout << cc.at(ii).at(jj) << endl;\n                }\n                cout << endl;\n                **/\n                bool flag = true;\n                for(ii = h-1;ii >= 0;--ii){\n                    rep(jj,w){\n                        if(cc.at(ii).at(jj) == 0) continue;\n                        if(jj + k-1 >= w) continue;\n                        ll kk;\n                        ll tmp_number = cc.at(ii).at(jj);\n                        ll conlen = 0;\n                        for(kk = jj;kk < w;++kk){\n                            if(cc.at(ii).at(kk) == tmp_number){\n                                ++conlen;\n                            }else{\n                                break;\n                            }\n                        }\n                        if(conlen >= k){\n                            flag = false;\n                            tmp += tmp_number*conlen*pow_mod(2ll, stage, 1e12+7);\n                            for(kk = jj;kk < jj+conlen;++kk){\n                                cc.at(ii).at(kk) = 0;\n                            }\n                        }\n                    }\n                }\n                /**\n                for(ii = 0;ii < h;++ii){\n                    rep(jj,w-1){\n                        cout << cc.at(ii).at(jj) << \" \";\n                    }\n                    cout << cc.at(ii).at(jj) << endl;\n                }\n                cout << tmp << endl;\n                **/\n                if(flag) break;\n                ++stage;\n            }\n            //return 0;\n            ans = max(tmp,ans);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define rrep(i,n) for(int i = (n)-1; i >= 0; i--)\n#define rep1(i,n) for(int i = 1; i <= (n); i++)\n#define rrep1(i,n) for(int i = (n); i > 0; i--)\n\n#define ll long long\n#define pi pair<int, int>\n#define pll pair<ll, ll>\n\n#define MOD 1000000007\n#define INF 1000000000000000LL\n\nusing namespace std;\n\n#define MAXWH 30\n\nvector<vector<int>> b(MAXWH, vector<int>(MAXWH));\nint h,w,k;\nll result=0;\nll tmp_result=0;\n\nvoid banish_with_point(int step, int x, int y){\n  tmp_result += pow(2, step)*b[y][x];\n  b[y][x]=0;\n}\n\nll check(int step, int y){\n  for(int cw=w; cw>=k; cw--){\n    for(int cs=0; cs+cw<=w; cs++){\n      if(b[y][cs]==0)continue;\n\n      bool f=true;\n      rep(i, cw)if(b[y][cs]!=b[y][cs+i])f=false;\n\n      if(f) rep(i, cw)banish_with_point(step, cs+i, y);\n    }\n  }\n}\n\nvoid fall(){\n  rep(y, h)rep(x, w)rep(k, h-y){\n    if(b[y][x]!=0)continue;\n    for(int i=y; i<h-1; i++) swap(b[i][x], b[i+1][x]);\n  }\n}\n\nint main(){\n  cin>>h>>w>>k;\n  vector<string>o(MAXWH);\n  rrep(i, h)cin>>o[i];\n  vector<vector<int>> ob(MAXWH, vector<int>(MAXWH));\n  rep(i, h)rep(j, w)ob[i][j]=o[i][j]-'0';\n\n  rep(i, h)rep(j, w){\n    tmp_result = 0;\n    b=vector<vector<int>>(ob);\n    b[i][j]=0;\n    fall();\n    rep(step, h){\n      rep(y, h)check(step, y);\n      fall();\n    }\n\n/*\nif(tmp_result > result){\ncout<<tmp_result<<'('<<i<<','<<j<<')'<<endl;\n  rrep(i, h){rep(j, w)cout<<b[i][j]<<' ';cout<<endl;}\n  cout<<endl;\n}\n*/\n\n    result = max<ll>(result, tmp_result);\n  }\n\n  cout<<result<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#line 1 \"/mnt/c/Users/leafc/dev/compro/lib/template.hpp\"\n\n\n#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define FOR(i, m, n) for (int i = m; i < n; i++)\n#define ALL(v) (v).begin(), (v).end()\n#define coutd(n) cout << fixed << setprecision(n)\n#define ll long long int\n#define vl vector<ll>\n#define vi vector<int>\n#define MM << \" \" <<\n\nusing namespace std;\n\ntemplate <class T> void say(bool val, T yes = \"Yes\", T no = \"No\") { cout << (val ? yes : no) << endl; }\n\ntemplate <class T> void chmin(T &a, T b) {\n  if (a > b)\n    a = b;\n}\n\ntemplate <class T> void chmax(T &a, T b) {\n  if (a < b)\n    a = b;\n}\n\n\n#line 2 \"tmp.cpp\"\n\nvoid update(vector<vi> &cell, int h, int w) {\n  REP(j, w) {\n    for (int i = h - 1; i > 0; i--) {\n      if (cell[i][j] != -1)\n        continue;\n      for (int di = -1; di + i >= 0; di--) {\n        if (cell[i + di][j] == -1)\n          continue;\n        cell[i][j] = cell[i + di][j];\n        cell[i + di][j] = -1;\n        break;\n      }\n    }\n  }\n}\n\nint calc(vector<vi> &c, int h, int w, int k) {\n  int ret = 0;\n  REP(i, h) {\n    REP(j, w) {\n      if (c[i][j] == -1)\n        continue;\n      for (int dj = 1; j + dj < w; dj++) {\n        if (c[i][j] != c[i][j + dj]) {\n          if (dj >= k) {\n            ret += c[i][j] * dj;\n            REP(ddj, dj) { c[i][j + ddj] = -1; }\n          }\n          j = j + dj - 1;\n          break;\n        }\n        if (j + dj == w - 1) {\n          if (dj + 1 >= k) {\n            ret += c[i][j] * (dj + 1);\n            REP(ddj, dj + 1) { c[i][j + ddj] = -1; }\n            j = w - 1;\n            break;\n          }\n        }\n      }\n    }\n  }\n  return ret;\n}\n\nvoid print(vector<vi> &c, int h, int w) {\n  cout << endl;\n  REP(i, h) {\n    REP(j, w) { cout << c[i][j] << (j == w - 1 ? \"\\n\" : \" \"); }\n  }\n  cout << endl;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int h, w, k;\n  cin >> h >> w >> k;\n  vector<vi> cell(h, vi(w, 0));\n  REP(i, h) {\n    string s;\n    cin >> s;\n    REP(j, w) { cell[i][j] = s[j] - '0'; }\n  }\n\n  int ans = 0;\n  vector<vi> c(h, vi(w, 0));\n  REP(i, h) {\n    REP(j, w) {\n      int tmp = 0;\n      copy(ALL(cell), c.begin());\n      c[i][j] = -1;\n      for (int i = 0, changed = true; changed; i++) {\n        changed = false;\n        update(c, h, w);\n        int ret = calc(c, h, w, k) * (1 << i);\n        if (ret != 0)\n          changed = true;\n        tmp += ret;\n      }\n      chmax(ans, tmp);\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(long long int (i)=0;(i)<(int)(n);(i)++)\n#define rrep(i,a,b) for(long long int i=(a);i<(b);i++)\n#define rrrep(i,a,b) for(long long int i=(a);i>=(b);i--)\n#define all(v) (v).begin(), (v).end()\n#define pb(q) push_back(q)\n#define Abs(a,b) max(a,b)-min(a,b)\n#define YES(condition) if(condition){cout << \"YES\" << endl;}else{cout << \"NO\" << endl;}\n#define Yes(condition) if(condition){cout << \"Yes\" << endl;}else{cout << \"No\" << endl;}\n#define Cout(x) cout<<(x)<<endl\n#define POSSIBLE(condition) if(condition){cout << \"POSSIBLE\" << endl;}else{cout << \"IMPOSSIBLE\" << endl;}\n#define Possible(condition) if(condition){cout << \"Possible\" << endl;}else{cout << \"Impossible\" << endl;}\n#define possible(condition) if(condition){cout << \"possible\" << endl;}else{cout << \"impossible\" << endl;}\n#define Size(n) (n).size()\n\ntypedef long long ll;\n\n\nusing namespace std;\n\nconst int INF = 1e9,MOD = 1e9 + 7,ohara=1e6;\nconst ll LINF = 1e18;\n\n/*---------------------------------------------------------------\nlong long int kaizyo(long long int hh){\n    cmp=1;\n    while(hh>1){\n        cmp=(cmp*hh)%MOD;\n        hh--;\n    }\n    return cmp;\n}\nlong long int ruizyo(long long int aa, long long int bb){\n    if(aa==0){\n        return 1;\n    }\n    else if(aa%2==0){\n        long long int tt=ruizyo(aa/2,bb);\n        return (tt*tt)%MOD;\n    }\n    else{\n        return (ruizyo(aa-1,bb)*bb)%MOD;\n    }\n}フェルマ－のア\n---------------------------------------------------------------\n\nwhile(x!=0){\n            sum+=x%10;\n          / x/=10;\n        }\n        各桁の和\n---------------------------------------------------------------\n\npair<int,int> p[100000];\ncin >> tmp;\np[i]=make_pair(tmp,i);\ncout << p[i].second+1 << endl;//ペアの右側つまりiを出力\n\n---------------------------------------------------------------\n\nbool f[100001];//1000000以下の素数を調べよう！\nrrep(i,2,100001){\n       f[i]=false;\n    }\nrrep(i,2,100001){\n        if(!f[i]){\n            for(int j=i+i;j<=100000;j+=i){\n                f[j]=true;\n            }\n        }\n    }\n    for(int i=3;i<=100000;i+=2){\n        if(!f[i]){\n            c[i]++;\n        }\n    }\n\n---------------------------------------------------------------\n\nlong long gcd(long long aaa,long long bbb){\n    if(bbb==0){\n        return aaa;\n    }\n    return gcd(bbb,aaa%bbb);\n}\n \nlong long lcm(long long aaa,long long bbb){\n    long long g = gcd(aaa,bbb);\n    return aaa/g * bbb;\n}左から最大公約数と最小公倍数\n\n\n---------------------------------------------------------------\n\nlong long int prime_cnt[10000];\n       for(int i=2;i*i<=n;i++){\n           while(n%i==0){\n               n/=i;\n               prime_cnt[i]+=1;\n           }\n           if(n>1){\n               prime_cnt[n]+=1;\n               break;\n           }\n      }ある数nを素因数分解しましょう\n\n---------------------------------------------------------------\ndebug:\ncout<<\"i: \"<<i<<\" j: \"<<j<<\" cnt: \"<<cnt<<\"\\n\";\n\n---------------------------------------------------------------*/\n\nlong long int n,cnt=0,ans=0,a,b,c,d,cmp[100][100],cmpp[100][100],m,h,w,sum=0,pos,k;\nint dy[]={1,0,-1,0};\nint dx[]={0,1,0,-1};\nstring alph(\"abcdefghijklmnopqrstuvwxyz\"),s;\nbool fl=true;\nstruct edge{int to,cost;};\n\n//-------------------------↓↓↓↓↓↓------------------------\n\nint main(void){\n       cin.tie(0);\n    ios::sync_with_stdio(false);\n\n      \n       cin>>h>>w>>k;\n  \t\tans=0;\n       rep(i,h){\n           cin>>s;\n           rep(j,w){\n               cmp[i][j]=(s[j]-'0');\n           }\n       }\n      \n      ll cntt=0,val=0;\n      rep(i,h){\n          rep(j,w){\n\n              rep(y,h){\n                  rep(x,w){\n                      cmpp[y][x]=cmp[y][x];\n                  }\n              }\n            \n            rrrep(y,i,0){\n                if(y==0){\n                    cmpp[y][j]=0;\n                }\n                else{\n                    cmpp[y][j]=cmpp[y-1][j];\n                }\n            }\n\n           while(1){\n               bool ok=false;\n               rep(y,h){\n                   cntt=1;\n                   rep(x,w){\n                       if(cmpp[y][x]==cmpp[y][x+1]){\n                           cntt++;\n                       }\n                       if(x==w-1||cmpp[y][x]!=cmpp[y][x+1]){\n                           if(cntt>=k){\n                               cnt+=cmpp[y][x]*cntt*pow(2,val);\n                              // cout<<cmpp[y][x]<<\" \"<<cntt<<\" \"<<pow(2,val)<<\"\\n\";\n                               cntt=1;\n                               if(cmpp[y][x]!=0){\n                               ok=true;\n                               }\n                           }\n                            cntt=1;\n                       }\n                   }\n               }\n\n               rep(y,h){\n                   cntt=1;\n                   ll le=0,ri=0;\n                   rep(x,w){\n                       if(cmpp[y][x]==cmpp[y][x+1]&&cmpp[y][x]!=0){\n                           cntt++;\n                           ri++;\n                       }\n                        if(x==w-1||cmpp[y][x]!=cmpp[y][x+1]){\n                            if(cmpp[y][x]==0)continue;\n                           if(cntt>=k){\n                               rrrep(yy,y,0){\n                               rrep(xx,le,ri+1){\n                                   if(yy==0){\n                                       cmpp[yy][xx]=0;\n                                   }\n                                   else{\n                                   cmpp[yy][xx]=cmpp[yy-1][xx];\n                                   }\n                               }\n                               }\n                           }\n                           else{\n                               le=x+1;\n                               ri=le;\n                           }\n                           cntt=1;\n                       }\n                   }\n               }\n\n               if(!ok)break;\n               val++;\n           }\n           ans=max(ans,cnt);\n           cnt=0;\n           val=0;\n\n          }\n      }\n      Cout(ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\nusing ll = long long;\n\nint H, W, K, score;\nint ans = 0;\nvector<vector<int>> stone;\nvector<vector<int>> original;\nvector<string> num;\n\nint main() {\n\tcin >> H >> W >> K;\n\toriginal.resize(H, vector<int>(W));\n\tstone.resize(H, vector<int>(W));\n\tnum.resize(H);\n\tfor (int i = 0; i < H; i++) cin >> num[i];\n\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\toriginal[i][j] = num[i][j] - '0';\n\t\t}\n\t}\n\n\tfor (int a = 0; a < H; a++) {\n\t\tfor (int b = 0; b < W; b++) {\n\t\t\tscore = 0;\n\t\t\tstone = original;\n\t\t\tstone[a][b] = 0;\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int i = H - 1; i > 0; i--) {\n\t\t\t\t\tif (stone[i][j] == 0) {\n\t\t\t\t\t\tfor (int k = i - 1; k >= 0; k--) {\n\t\t\t\t\t\t\tif (stone[k][j] != 0) {\n\t\t\t\t\t\t\t\tswap(stone[i][j], stone[k][j]);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint roop = 0;\n\t\t\twhile (true) {\n\t\t\t\tint sum = 0;\n\n\t\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\t\tint count = 1, left = 0, right = 0;\n\t\t\t\t\tfor (int j = 0; j < W - 1; j++) {\n\t\t\t\t\t\tif (stone[i][j] == 0) {\n\t\t\t\t\t\t\tcount = 1;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (stone[i][j] == stone[i][j + 1]) count++;\n\t\t\t\t\t\telse if (count >= K) {\n\t\t\t\t\t\t\tright = j;\n\t\t\t\t\t\t\tleft = right - (count - 1);\n\t\t\t\t\t\t\tcount = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse count = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (count >= K) {\n\t\t\t\t\t\tright = W - 1;\n\t\t\t\t\t\tleft = right - (count - 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (left == 0 && right == 0) continue;\n\t\t\t\t\tfor (int k = left; k <= right; k++) {\n\t\t\t\t\t\tsum += stone[i][k];\n\t\t\t\t\t\tstone[i][k] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (sum == 0) break;\n\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tfor (int i = H - 1; i > 0; i--) {\n\t\t\t\t\t\tif (stone[i][j] == 0) {\n\t\t\t\t\t\t\tfor (int k = i - 1; k >= 0; k--) {\n\t\t\t\t\t\t\t\tif (stone[k][j] != 0) {\n\t\t\t\t\t\t\t\t\tswap(stone[i][j], stone[k][j]);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint n = 1;\n\t\t\t\tfor (int i = 0; i < roop; i++) n *= 2;\n\t\t\t\tscore += n * sum;\n\t\t\t\troop++;\n\t\t\t}\n\t\t\tans = max(ans, score);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//q093.cpp\n//Sun Sep 13 15:33:44 2020\n\n#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <vector>\n#include <algorithm>\n#include <math.h>\n#include <set>\n#define INTINF 2147483647\n#define LLINF 9223372036854775807\n#define MOD 1000000007\n#define rep(i,n) for (int i=0;i<(n);++i)\n\nusing namespace std;\nusing ll=long long;\ntypedef pair<int,int> P;\n\nint h,w,k;\nstring t[30];\n\nint scorecalc(int x,int y){\n\tint ret = 0;\n\tint c[30][30];\n\trep(i,h)rep(j,w) c[i][j] = t[i][j]-'0';\n\tfor(int i=x-1;i>=0;i--){\n\t\tc[i+1][y] = c[i][y];\n\t}\n\tc[0][y] = -1;\n\tint count = 1;\n\twhile(1){\n\t\tint flag = 0;\n\t\trep(i,h){\n\t\t\tint contig = 1;\n\t\t\tfor(int j=1;j<w;j++){\n\t\t\t\tif (c[i][j]==c[i][j-1]){\n\t\t\t\t\tcontig++;\n\t\t\t\t}else {\n\t\t\t\t\tif (contig>=k && c[i][j-1]!=-1){\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\tret += contig*c[i][j-1]*count;\n\t\t\t\t\t\tfor (int z=j-contig;z<j;z++){\n\t\t\t\t\t\t\tc[i][z] = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontig = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (contig>=k && c[i][w-1]!=-1){\n\t\t\t\tflag = 1;\n\t\t\t\tret += contig*c[i][w-1]*count;\n\t\t\t\tfor (int z=w-contig;z<w;z++){\n\t\t\t\t\tc[i][z] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!flag) break;\n\n\t\tfor (int i=h-1;i>=0;i--){\n\t\t\trep(j,w){\n\t\t\t\tif(c[i][j]==-1){\n\t\t\t\t\tfor (int z=i-1;z>=0;z--){\n\t\t\t\t\t\tif (c[z][j]!=-1){\n\t\t\t\t\t\t\tc[i][j] = c[z][j];\n\t\t\t\t\t\t\tc[z][j] = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcount = count * 2;\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\tcin >> h >> w >> k;\n\n\trep(i,h) cin >> t[i];\n\n\tint ans = 0;\n\trep(i,h)rep(j,w){\n\t\tans = max(ans,scorecalc(i,j));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// /usr/local/bin/g++ Main.cpp -std=c++14\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint H, W, K, C[30*30];\n\nll calc(int idx) {\n\tint _c[30*30];\n\tset<int> d; // deleted blocks\n\tfor (int k = 0; k < 30*30; k++) {\n\t\t_c[k] = C[k];\n\t}\n\td.insert(idx);\n\tint cnt = 0;\n\tll res = 0;\n\n\t// Continue until there is no deleted block.\n\twhile (d.size()) {\n\t\t// Move blocks when block is deleted.\n\t\tfor (int l : d) {\n\t\t\tint _h = l/W;\n\t\t\tint _w = l%W;\n\t\t\tfor (int i = _h; i > 0; i--) {\n\t\t\t\t_c[i*W+_w] = _c[(i-1)*W+_w];\n\t\t\t}\n\t\t\t_c[_w] = 0;\n\t\t}\n\t\td.clear();\n\n\t\t// Calculate scores\n\t\tfor (int i = 1; i < H; i++) {\n\t\t\tfor (int j = 0; j < W - K + 1; j++) {\n\t\t\t\tbool judge = true;\n\t\t\t\tfor (int k = 1; k < K; k++) {\n\t\t\t\t\tjudge = (judge && _c[i*W+j] != 0 && _c[i*W+j] == _c[i*W+j+k]);\n\t\t\t\t}\n\t\t\t\tif (!judge) continue;\n\t\t\t\tfor (int k = 0; k < K; k++) {\n\t\t\t\t\td.insert(i*W+j+k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add score\n\t\tif (d.size()) {\n\t\t\tint _res = 0;\n\t\t\tfor (int l : d) {\n\t\t\t\t_res += _c[l];\n\t\t\t}\n\t\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\t\t_res *= 2;\n\t\t\t}\n\t\t\tres += _res;\n\t\t}\n\t\tcnt++;\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\t// Dummy input\n//\tifstream in(\"input.txt\");\n//\tcin.rdbuf(in.rdbuf());\n\n\t// Read input\n\tcin >> H >> W >> K;\n\tfor (int i = 0; i < H; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tint j = 0;\n\t\tfor (char& c : s) {\n\t\t\tC[i*W+(j++)] = (int)(c - '0');\n\t\t}\n\t}\n\n\tll res = 0;\n\tfor (int i = 1; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tll _res = calc(i*W+j);\n\t\t\tif (res < _res) res = _res;\n\t\t}\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#define rep(i, start, end) for (int i = (int)start; i < (int)end; ++i)\n#define rrep(i, start, end) for (int i = (int)start - 1; i >= end; --i)\n#define arep(i, c) for (auto i = (c).begin(); i != (c).end(); ++i)\n#define all(x) (x).begin(), (x).end()\nusing namespace std;\n\nvoid drop(int h, int w, vector<string>& grid) {\n    rep(i, 0, w) {\n        rrep(j, h - 1, 0) {\n            if (grid[j][i] == '*') continue;\n            int start = j;\n            while (start + 1 < h && grid[start + 1][i] == '*') {\n                swap(grid[start][i], grid[start + 1][i]);\n                ++start;\n            }\n        }\n    }\n}\n\nint erase(int h, int w, int k, vector<string>& grid) {\n    vector<vector<int> > cumsum(h, vector<int>(w, 0));\n    int res = 0;\n    rep(i, 0, h) {\n        char now = '*';\n        int cnt = 0;\n        rep(j, 0, w) {\n            if (grid[i][j] == '*') {\n                cnt = 0;\n                continue;\n            }\n            if (grid[i][j] != now) {\n                cnt = 1;\n                now = grid[i][j];\n            }\n            else ++cnt;\n            cumsum[i][j] = cnt;\n        }\n    }\n    rep(i, 0, h) {\n        rrep(j, w, 0) {\n            if (cumsum[i][j] < k) continue;\n            int erase_cnt = cumsum[i][j];\n            rep(l, 0, erase_cnt) {\n                res += (int)(grid[i][j - l] - '0');\n                grid[i][j - l] = '*';\n                cumsum[i][j - l] = 0;\n            }\n        }\n    }\n    return res;\n}\n\nint game(int h, int w, int k, int del_h, int del_w, vector<string> grid) {\n    int res = 0;\n    int pow = 1;\n    grid[del_h][del_w] = '*';\n    while (true) {\n        drop(h, w, grid);\n        int score = erase(h, w, k, grid);\n        if (score == 0) break;\n        res += pow * score;\n        pow *= 2;\n    }\n    return res;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int H, W, K;\n    cin >> H >> W >> K;\n    vector<string> grid(H);\n    rep(i, 0, H) cin >> grid[i];\n    int ans = 0;\n    rep(i, 0, H) rep(j, 0, W) {\n        int now_ans = game(H, W, K, i, j, grid);\n        ans = max(ans, now_ans);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nll MOD = 1000000007;\n\n#define vec              vector<int>\n#define vecll            vector<ll>\n#define vecd             vector<double>\n#define vecst            vector<string>\n#define vecb             vector<bool>\n#define v2(v,n,m,init)   vector<vector<int>>  v(n, vector<int>(m, init))\n#define vb2(v,n,m,init)  vector<vector<bool>> v(n, vector<bool>(m, init))\n#define vll2(v,n,m,init) vector<vector<ll>>   v(n, vector<ll>(m, init))\n\n#define rep(i,n)         for(ll i=(ll)0; i<(ll)n; i++)\n#define REP(i,m,n)       for(ll i=(ll)m; i<(ll)n; i++)\n#define arr(var, n)      vec var(n); rep(i,n){cin >> var[i];}\n#define arrll(var, n)    vecll var(n); rep(i,n){cin >> var[i];}\n#define arrst(var, n)    vecst var(n); rep(i,n){cin >> var[i];}\n#define all(var)         (var).begin(), (var).end()\n#define sortall(var)     sort(all(var))\n#define uniqueall(v)     v.erase(unique(v.begin(), v.end()), v.end());\n#define pb(var)          push_back(var)\n#define prt(var)         cout << (var) << \"\\n\"\n#define prtd(n, var)     cout << fixed << setprecision(n) << (var) << \"\\n\"\n#define prtfill(n, var)  cout << setw(n) << setfill('0') << (var);\n#define prt2(v1, v2)     cout << (v1) << \" \" << (v2) << \"\\n\"\n#define prt3(v1, v2, v3) cout << (v1) << \" \" << (v2) << \" \" << (v3) << \"\\n\"\n#define prtall(v)        rep(i,v.size()){cout<<v[i]<<(i!=v.size()-1?\" \":\"\\n\");}\ntemplate <typename T>\nbool chmax(T &a, const T& b){if(a<b){a=b; return true;} return false;}\ntemplate <typename T>\nbool chmin(T &a, const T& b){if(a>b){a=b; return true;} return false;}\n//------------------------------------------------------------------\n\nvector<string> drop(vector<string> s){\n  vector<string> r;\n  int h = s.size();\n  int w = s[0].size();\n  rep(i,h){\n    string tmp=\"\";\n    rep(j,w){\n      tmp.push_back('0');\n    }\n    r.push_back(tmp);\n  }\n  rep(i,w){\n    int id=h-1;\n    for(int j=h-1; j>-1; j--){\n      if(s[j][i]!='0'){\n        r[id][i]=s[j][i];\n        id--;\n      }\n    }\n  }\n  return r;\n}\n\nint main(void){\n  int h, w, k;\n  cin >> h >> w >> k;\n  arrst(s,h);\n\n  int ans=0;\n  if(k>=4){\n    prt(ans);\n    return 0;\n  }\n  rep(delh,h){\n    rep(delw,w){\n      int anstmp=0;\n      vector<string> t = s;\n      t[delh][delw] = '0';\n      t = drop(t);\n      int p=1;\n      //prt(\"-----------------------\");\n      rep(x,h*w/k+3){\n        if(x!=0) p*=2;\n        int add=0;\n        /*\n        prt2(\"from =====>\", x);\n\n        rep(p,h){\n          rep(q,w){\n            cout << t[p][q] << (q!=w-1 ? \" \" : \"\\n\");\n          }\n        }\n        */\n\n        rep(a,h){\n          rep(b,w){\n            int tmp = t[a][b];\n            int c=b;\n            int ct=0;\n            while(c<w){\n              if(t[a][c]==tmp) ct++, c++;\n              else break;\n            }\n            if(ct>=k){\n              rep(i,ct){\n                add += t[a][b+i]-'0';\n                t[a][b+i]='0';\n              }\n            }\n          }\n        }\n        /*\n        prt2(\"to =====>\", x);\n        rep(p,h){\n          rep(q,w){\n            cout << t[p][q] << (q!=w-1 ? \" \" : \"\\n\");\n          }\n        }\n        */\n\n        anstmp += add*p;\n        //prt3(\"score :\", anstmp, add*p);\n        t = drop(t);\n      }\n      chmax(ans, anstmp);\n    }\n  }\n\n\n  prt(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\n\nint G[30][30];\n\nvoid remove(int (&G)[30][30], int h, int w){\n    for (int i = 0; i < w; ++i) {\n        for (int k = 0; k < h; ++k) {\n            for (int j = 0; j < h -1; ++j) {\n                if(G[i][j] == 0) swap(G[i][j], G[i][j+1]);\n            }\n        }\n    }\n}\n\nint solve(int h, int w, int k, int sx, int sy){\n    int tmp[30][30] = {};\n    for (int i = 0; i < w; ++i) {\n        for (int j = 0; j < h; ++j) {\n            tmp[i][j] = G[i][j];\n        }\n    }\n    tmp[sx][sy] = 0;\n    remove(tmp, h, w);\n    int res = 0;\n    int cnt = 0;\n    bool flag;\n    do {\n        flag = false;\n        for (int j = 0; j < h; ++j) {\n            for (int i = 0; i < w - k + 1; ++i) {\n                int l = i;\n                for (; tmp[l][j] == tmp[l + 1][j] && tmp[l][j] != 0; ++l);\n                if (l >= i + k - 1) {\n                    flag = true;\n                    res += pow(2, cnt) * tmp[l][j] * (l - i + 1);\n\n                    for (int m = i; m <= l; ++m) {\n                        tmp[m][j] = 0;\n                    }\n                }\n            }\n        }\n        cnt++;\n        remove(tmp, h, w);\n    } while(flag);\n    return res;\n}\n\nint main(){\n    int h, w, k;\n    cin >> h >> w >> k;\n    string s;\n    for (int i = h - 1; i >= 0; --i) {\n        cin >> s;\n        for (int j = 0; j < w; ++j) {\n            G[j][i] = s[j] - '0';\n        }\n    }\n\n    int res = 0;\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            res = max(res, solve(h, w, k, i, j));\n        }\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// /usr/local/bin/g++ Main.cpp -std=c++14\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint H, W, K, C[30*30], _c[30*30];\nset<int> d;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> H >> W >> K;\n\tfor (int i = 0; i < H; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tint j = 0;\n\t\tfor (char& c : s) {\n\t\t\tC[i*W+(j++)] = (int)(c - '0');\n\t\t}\n\t}\n\n\tll res = 0;\n\tfor (int i = 1; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tfor (int k = 0; k < 30*30; k++) {\n\t\t\t\t_c[k] = C[k];\n\t\t\t}\n\t\t\td.clear();\n\t\t\td.insert(i*W+j);\n\t\t\tint cnt = 0;\n\t\t\tint __res = 0;\n\t\t\twhile (d.size()) {\n\t\t\t\tfor (int l : d) {\n\t\t\t\t\tfor (int _i = l/W; _i > 0; _i--) {\n\t\t\t\t\t\t_c[_i*W+l%W] = _c[(_i-1)*W+l%W];\n\t\t\t\t\t}\n\t\t\t\t\t_c[l%W] = 0;\n\t\t\t\t}\n\t\t\t\td.clear();\n\t\t\t\tint _res = 0;\n\t\t\t\tfor (int _i = 1; _i < H; _i++) {\n\t\t\t\t\tint pre = 0;\n\t\t\t\t\tbool loop = false;\n\t\t\t\t\tint kuri = K - 1;\n\t\t\t\t\tfor (int _j = 0; _j <= W; _j++) {\n\t\t\t\t\t\tif (_j != W && pre != 0 && _c[_i*W+_j] == pre) {\n\t\t\t\t\t\t\tif (--kuri <= 0) {\n\t\t\t\t\t\t\t\t_res += pre;\n\t\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t\t\td.insert(_i*W+_j-1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (loop) {\n\t\t\t\t\t\t\t\t_res += pre;\n\t\t\t\t\t\t\t\td.insert(_i*W+_j-1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tkuri = K - 1;\n\t\t\t\t\t\t\tloop = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (_j < W) pre = _c[_i*W+_j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (_res > 0) {\n\t\t\t\t\tint tmp = 1;\n\t\t\t\t\tfor (int _k = 0; _k < cnt; _k++) {\n\t\t\t\t\t\ttmp *= 2;\n\t\t\t\t\t}\n\t\t\t\t\t__res += tmp*_res;\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif (res < __res) res = __res;\n\t\t}\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(a)  (a).begin(),(a).end()\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<long long, long long> Pll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<long long> vll;\ntypedef vector<vector<long long>> vvll;\ntemplate <typename T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate <typename T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst long long INF = 1LL << 60;\nconst int INT_INF = 1LL << 30;\n\ntemplate <typename T>\nT beki(T x, ll n){\n  T res = 1;\n  while(n > 0){\n    if(n & 1) res *= x;\n    x = x * x;\n    n >>= 1;\n  }\n  return res;\n}\n\nint main(){\n  int H, W, K;\n  cin >> H >> W >> K;\n  vvi m(H, vi(W, 0));\n  for(int i = 0; i < H; i++){\n    for(int j = 0; j < W; j++){\n      char c;\n      cin >> c;\n      m.at(i).at(j) = c - '0';\n    }\n  }\n  int result = 0;\n  for(int i = 1; i < H; i++){\n    for(int j = 0; j < W; j++){\n      //m.at(i).at(j)を消した場合\n      vvi mm = m;\n      for(int k = i; k >= 1; k--){\n        mm.at(k).at(j) = mm.at(k-1).at(j);\n      }\n      mm.at(0).at(j) = 0;\n\n      bool repflag;\n      int counter = 0;\n      int res = 0;\n      do{\n        repflag = false;\n        vector<vector<bool>> flag(H, vector<bool>(W, false));\n        for(int k = 0; k < H; k++){\n          for(int l = 0; l < W-K+1; l++){\n            if(mm.at(k).at(l) == 0) continue;\n            //消せるものにflagを立てる\n            bool issame = true;\n            for(int t = l; t < l+K; t++){\n              if(mm.at(k).at(l) != mm.at(k).at(t)) issame = false;\n            }\n            if(issame){\n              for(int t = l; t < l+K; t++){\n                repflag = true;\n                flag.at(k).at(t) = true;\n              }\n            }\n          }\n        }\n\n        for(int k = 0; k < H; k++){\n          for(int l = 0; l < W; l++){\n            if(flag.at(k).at(l)){\n              res += beki(2, counter) * mm.at(k).at(l);\n              mm.at(k).at(l) = 0;\n            }\n          }\n        }\n\n        for(int k = H-1; k >= 1; k--){\n          for(int l = 0; l < W; l++){\n            if(mm.at(k).at(l) == 0){\n              for(int t = k-1; t >= 0; t--){\n                if(mm.at(t).at(l) != 0){\n                  mm.at(k).at(l) = mm.at(t).at(l);\n                  mm.at(t).at(l) = 0;\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n\n        counter++;\n      }while(repflag);\n      chmax(result, res);\n\n\n    }\n  }\n  cout << result << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline bool chmax(T &a, T b)\n{\n    if (a < b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\ninline bool chmin(T &a, T b)\n{\n    if (a > b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntypedef long long int ll;\n\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define endl \"\\n\"\nconst double EPS = 1e-7;\nconst int INF = 1 << 30;\nconst ll LLINF = 1LL << 60;\nconst double PI = acos(-1);\nconst int MOD = 1000000007;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\n//-------------------------------------\nusing vvint = vector<vector<int>>;\n\nvoid printBoard(vvint &a, int w, int h)\n{\n    cout << \"--------------------------------------\" << endl;\n    for (int i = 0; i < h; i++)\n    {\n        for (int j = 0; j < w; j++)\n        {\n            cout << a[i][j] << ' ';\n        }\n        cout << endl;\n    }\n    cout << \"--------------------------------------\" << endl;\n}\n\nvoid Arrange(vvint &a, int h, int w)\n{\n    // 整列する\n    for (int x = 0; x < w; x++)\n    {\n        // fi:元々何番目だったか, se:そのマスの値\n        vector<pair<int, int>> rec(h);\n        // マスの値を一時保存\n        vector<int> rec2(h);\n        int cnt = 0;\n        for (int y = 0; y < h; y++)\n        {\n            rec[y].first = y;\n            if (a[y][x] == -1)\n            {\n                rec[y].second = -INF;\n            }\n            else\n            {\n                rec[y].second = cnt;\n                cnt++;\n            }\n        }\n        sort(ALL(rec), [](const auto &p, const auto &q) { return p.second < q.second; });\n        for (int i = 0; i < h; i++)\n        {\n            rec2[i] = a[i][x];\n        }\n        for (int i = 0; i < h; i++)\n        {\n            a[i][x] = rec2[rec[i].first];\n        }\n    }\n}\n\nint del(vvint &a, int h, int w, int k)\n{\n    // 消えたところは一旦-1にする\n    int sum = 0;\n    for (int y = 0; y < h; y++)\n    {\n        for (int x = 0; x < w - k + 1; x++)\n        {\n            if (a[y][x] == -1)\n            {\n                continue;\n            }\n            int r = x;\n            while (r + 1 < w && a[y][r + 1] == a[y][x])\n            {\n                r++;\n            }\n            if (r - x + 1 >= k)\n            {\n                for (int i = x; i <= r; i++)\n                {\n                    sum += a[y][i];\n                    a[y][i] = -1;\n                }\n                x = r;\n            }\n        }\n    }\n    // 整列する\n    Arrange(a, h, w);\n\n    return sum;\n}\n\nll power(ll n, ll k)\n{\n    if (k == 0)\n    {\n        return 1;\n    }\n    else if (k % 2 == 1)\n    {\n        return power(n, k - 1) * n;\n    }\n    else\n    {\n        ll t = power(n, k / 2);\n        return t * t;\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int h, w, k;\n    cin >> h >> w >> k;\n    vvint b(h, vector<int>(w));\n    for (int i = 0; i < h; i++)\n    {\n        string s;\n        cin >> s;\n        for (int j = 0; j < w; j++)\n        {\n            b[i][j] = int(s[j] - '0');\n        }\n    }\n    ll ans = -LLINF;\n    for (int i = 0; i < h; i++)\n    {\n        for (int j = 0; j < w; j++)\n        {\n            vvint a = b;\n            ll res = 0;\n            a[i][j] = -1;\n            ll cnt = 0;\n            Arrange(a, h, w);\n            // if(i == 3 && j == 2){\n            //     printBoard(a,w,h);\n            // }\n            while (1)\n            {\n                int tmp = del(a, h, w, k);\n                // if (i == 3 && j == 2)\n                // {\n                //     printBoard(a, w, h);\n                //     cout << power(2LL, cnt) * tmp << endl;\n                // }\n                res += power(2LL, cnt) * tmp;\n                if (tmp == 0)\n                {\n                    break;\n                }\n                cnt++;\n            }\n            chmax(ans, res);\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define rrep(i,n) for(int i = (n)-1; i >= 0; i--)\n#define rep1(i,n) for(int i = 1; i <= (n); i++)\n#define rrep1(i,n) for(int i = (n); i > 0; i--)\n\n#define ll long long\n#define pi pair<int, int>\n#define pll pair<ll, ll>\n\n#define MOD 1000000007\n#define INF 1000000000000000LL\n\nusing namespace std;\n\n#define MAXWH 30\n\nvector<vector<int>> b(MAXWH, vector<int>(MAXWH));\nint h,w,k;\nll result=0;\nll tmp_result=0;\n\nvoid banish_with_point(int step, int x, int y){\n  tmp_result += pow(2, step)*b[y][x];\n  b[y][x]=0;\n}\n\nll check(int step, int y){\n  for(int cw=w; cw>=k; cw--){\n    for(int cs=0; cs+cw<=w; cs++){\n      if(b[y][cs]==0)continue;\n\n      bool f=true;\n      rep(i, cw)if(b[y][cs]!=b[y][cs+i])f=false;\n\n      if(f) rep(i, cw)banish_with_point(step, cs+i, y);\n    }\n  }\n}\n\nvoid fall(){\n  rep(y, h)rep(x, w)rep(k, h){\n    if(b[y][x]!=0)continue;\n    for(int i=y; i<h-1; i++) swap(b[i][x], b[i+1][x]);\n  }\n}\n\nint main(){\n  cin>>h>>w>>k;\n  vector<string>o(MAXWH);\n  rrep(i, h)cin>>o[i];\n  vector<vector<int>> ob(MAXWH, vector<int>(MAXWH));\n  rep(i, h)rep(j, w)ob[i][j]=o[i][j]-'0';\n\n  rep(i, h)rep(j, w){\n    tmp_result = 0;\n    b=vector<vector<int>>(ob);\n    b[i][j]=0;\n    fall();\n    rep(step, h){\n      rep(y, h)check(step, y);\n      fall();\n    }\n\n/*\nif(tmp_result > result){\ncout<<tmp_result<<'('<<i<<','<<j<<')'<<endl;\n  rrep(i, h){rep(j, w)cout<<b[i][j]<<' ';cout<<endl;}\n  cout<<endl;\n}\n*/\n\n    result = max<ll>(result, tmp_result);\n  }\n\n  cout<<result<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) x.begin(),x.end()\n#define ln '\\n'\nconst long long MOD = 1000000007LL;\n//const long long MOD = 998244353LL;\ntypedef long long ll;\ntypedef unsigned long long ull; \ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true;} return false; }\n///////////////////////////////////////////////////////////////////////////////////////////////////\nll board[35][35];\nll moto[35][35];\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int H,W,K; cin >> H >> W >> K;\n    vector<string> S(H);\n    rep(i,H) cin >> S[i];\n\n    rep(i,H) rep(j,W) moto[i][j] = S[i][j] - '0';\n\n    ll ans = 0;\n    rep(z,H) {\n        rep(w,W) {\n            rep(i,H) rep(j,W) board[i][j] = moto[i][j];\n            for (int i = z; i > 0; --i) board[i][w] = board[i-1][w];\n            board[0][w] = 0;\n\n            ll val = 0;\n            ll b = 1;\n            while (true) {\n                bool ok = false;\n                rep(i,H) {\n                    for (int j = W; j >= K; --j) {\n                        rep(k,W-j+1) {\n                            if (!board[i][k]) continue;\n                            bool ok10 = true;\n                            rep(l,j) {\n                                if (board[i][k] != board[i][k+l]) {\n                                    ok10 = false;\n                                    break;\n                                }\n                            }\n                            if (!ok10) continue;\n                            ok = true;\n                            val += board[i][k]*j*b;\n                            rep(l,j) {\n                                board[i][k+l] = 0;\n                            }\n                            break;\n                        }\n                    } \n                }\n\n                if (!ok) break;\n                rep(j,W) {\n                    for (int i = H-1; i >= 0; --i) {\n                        if (board[i][j]) continue;\n                        int k = i-1;\n                        while (k >= 0 && !board[k][j]) --k;\n                        if (k==-1) break;\n                        board[i][j] = board[k][j];\n                        board[k][j] = 0;\n                    }\n                }\n                b *= 2;\n            }\n            /*\n            rep(i,H) {\n                rep(j,W) cout << board[i][j];\n                cout << ln;\n            }\n            cout << ln;\n            */\n            chmax(ans,val);\n        }\n    }\n\n    cout << ans << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\nint H,W,K,a,ans=0,count;char ch;bool che=true;scanf(\"%d %d %d\",&H,&W,&K);\nvector<vector<int>> c(H,vector<int>(W));vector<vector<bool>> check(H,vector<bool>(W,false));\nvector<vector<int>> board(H,vector<int>(W));\nfor(int i=0;i<H;i++)for(int j=0;j<W;j++){cin>>ch;c[i][j]=ch-'0';board[i][j]=c[i][j];}\nfor(int w=0;w<W;w++)\n{\n  check.resize(0);check.resize(H);for(int i=0;i<H;i++)check[i].resize(W,false);\n  for(int i=0;i<H;i++)for(int j=0;j<W;j++)c[i][j]=board[i][j];\n  for(int j=H-1;j>0;j--)c[j][w]=c[j-1][w];\n  check[0][w]=true;c[0][w]=0;a=0;che=true;count=0;\n  while(che)\n  {\n    che=false;\n    for(int i=0;i<H;i++)for(int j=1;j<W;j++)\n    if(c[i][j]==c[i][j-1]&&c[i][j]!=0&&!check[i][j])\n    {\n      check[i][j]=true;check[i][j-1]=true;\n    }\n    for(int i=0;i<H;i++)for(int j=0;j<W;j++)\n    if(check[i][j]&&c[i][j]>0)\n    {\n      a+=c[i][j]*pow(2,count);c[i][j]=0;che=true;cout<<\"w\"<<w<<\"i\"<<i<<\"j\"<<j<<\"a\"<<a;\n    }\n    for(int j=0;j<W;j++)\n    {\n      int stack=H-1;\n      for(int i=H-1;i>-1;i--)if(!check[i][j])\n      {\n        c[stack][j]=c[i][j];check[i][j]=true;check[stack][j]=false;stack--;\n        if(check[i][j])c[i][j]=0;\n      }\n    }\n    count++;\n  }\n  ans=max(ans,a);\n}\nprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) x.begin(),x.end()\n#define ln '\\n'\nconst long long MOD = 1000000007LL;\n//const long long MOD = 998244353LL;\ntypedef long long ll;\ntypedef unsigned long long ull; \ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true;} return false; }\n///////////////////////////////////////////////////////////////////////////////////////////////////\nll board[35][35];\nll moto[35][35];\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int H,W,K; cin >> H >> W >> K;\n    vector<string> S(H);\n    rep(i,H) cin >> S[i];\n\n    rep(i,H) rep(j,W) moto[i][j] = S[i][j] - '0';\n\n    ll ans = 0;\n    rep(z,H) {\n        rep(w,W) {\n            rep(i,H) rep(j,W) board[i][j] = moto[i][j];\n            for (int i = z; i > 0; --i) board[i][w] = board[i-1][w];\n            board[0][w] = 0;\n\n            ll val = 0;\n            ll b = 1;\n            while (true) {\n                bool ok = false;\n                rep(i,H) {\n                    for (int j = W; j >= K; --j) {\n                        bool ok2 = false;\n                        rep(k,W-j+1) {\n                            if (!board[i][k]) continue;\n                            bool ok10 = true;\n                            rep(l,j) {\n                                if (board[i][k] != board[i][k+l]) {\n                                    ok10 = false;\n                                    break;\n                                }\n                            }\n                            if (!ok10) continue;\n                            ok = ok2 = true;\n                            val += board[i][k]*j*b;\n                            rep(l,j) {\n                                board[i][k+l] = 0;\n                            }\n                            break;\n                        }\n                        if (ok2) break;\n                    } \n                }\n\n                if (!ok) break;\n                rep(j,W) {\n                    for (int i = H-1; i >= 0; --i) {\n                        if (board[i][j]) continue;\n                        int k = i-1;\n                        while (k >= 0 && !board[k][j]) --k;\n                        if (k==-1) break;\n                        board[i][j] = board[k][j];\n                        board[k][j] = 0;\n                    }\n                }\n                b *= 2;\n            }\n            /*\n            rep(i,H) {\n                rep(j,W) cout << board[i][j];\n                cout << ln;\n            }\n            cout << ln;\n            */\n            chmax(ans,val);\n        }\n    }\n\n    cout << ans << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nconst int nax=37;\n\nint n, m, k;\n\nchar wcz[nax];\n\nstruct plan\n{\n\tvector <int> wek[nax];\n\tint kogo[nax][nax];\n\tplan()\n\t{\n\t\tczys();\n\t}\n\tvoid czys()\n\t{\n\t\tfor (int i=0; i<m; i++)\n\t\t\tfor (int j=0; j<n; j++)\n\t\t\t\tkogo[i][j]=0;\n\t}\n\tll oznacz()\n\t{\n\t\tll ret=0;\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tint ost=-1;\n\t\t\tint ile=0;\n\t\t\tfor (int j=0; j<m; j++)\n\t\t\t{\n\t\t\t\tint x=-1;\n\t\t\t\tif ((int)wek[j].size()>i)\n\t\t\t\t\tx=wek[j][i];\n\t\t\t\tif (x==-1)\n\t\t\t\t{\n\t\t\t\t\tost=-1;\n\t\t\t\t\tile=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (x!=ost)\n\t\t\t\t\t{\n\t\t\t\t\t\tile=1;\n\t\t\t\t\t\tost=x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tile++;\n\t\t\t\t\t\tif (ile>=k)\n\t\t\t\t\t\t\tkogo[j][i]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tost=-1;\n\t\t\tile=0;\n\t\t\tfor (int j=m-1; j>=0; j--)\n\t\t\t{\n\t\t\t\tint x=-1;\n\t\t\t\tif ((int)wek[j].size()>i)\n\t\t\t\t\tx=wek[j][i];\n\t\t\t\tif (x==-1)\n\t\t\t\t{\n\t\t\t\t\tost=-1;\n\t\t\t\t\tile=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (x!=ost)\n\t\t\t\t\t{\n\t\t\t\t\t\tile=1;\n\t\t\t\t\t\tost=x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tile++;\n\t\t\t\t\t\tif (ile>=k)\n\t\t\t\t\t\t\tkogo[j][i]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i=0; i<m; i++)\n\t\t\tfor (int j=0; j<(int)wek[i].size(); j++)\n\t\t\t\tret+=kogo[i][j]*wek[i][j];\n\t\treturn ret;\n\t}\n\tvoid puszuj()\n\t{\n\t\tfor (int i=0; i<m; i++)\n\t\t{\n\t\t\tvector <int> wez;\n\t\t\tfor (int j=0; j<(int)wek[i].size(); j++)\n\t\t\t\tif (!kogo[i][j])\n\t\t\t\t\twez.push_back(wek[i][j]);\n\t\t\twek[i]=wez;\n\t\t\tdebug() << wek[i];\n\t\t}\n\t\tdebug();\n\t\tczys();\n\t}\n};\n\nll wyn;\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tplan start;\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tscanf(\"%s\", wcz);\n\t\tfor (int j=0; j<m; j++)\n\t\t\tstart.wek[j].push_back(wcz[j]-'0');\n\t}\n\tfor (int i=0; i<m; i++)\n\t\treverse(start.wek[i].begin(), start.wek[i].end());\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tfor (int j=0; j<m; j++)\n\t\t{\n\t\t\tplan wez=start;\n\t\t\twez.kogo[j][i]=1;\n\t\t\tdebug() << i << \" \" << j;\n\t\t\twez.puszuj();\n\t\t\tll ter=0;\n\t\t\tfor (int h=0; 1; h++)\n\t\t\t{\n\t\t\t\tdebug() << i << \" \" << j << \"  \" << h;\n\t\t\t\tll x=wez.oznacz();\n\t\t\t\tdebug() << imie(x);\n\t\t\t\tif (!x)\n\t\t\t\t\tbreak;\n\t\t\t\tter+=(x<<h);\n\t\t\t\twez.puszuj();\n\t\t\t}\n\t\t\twyn=max(wyn, ter);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid fall(vector<string> &g) {\n    int h = g.size();\n    int w = g[0].size();\n    for (int j = 0; j < w; j++) {\n        int k = h - 1;\n        for (int i = h - 1; i >= 0; i--) {\n            if (g[i][j] != '0') {\n                g[k--][j] = g[i][j];\n            }\n        }\n        while (k >= 0) g[k--][j] = '0';\n    }\n}\n\nint erase(vector<string> &g, int K) {\n    int h = g.size();\n    int w = g[0].size();\n    int sum = 0;\n    for (int i = 0; i < h; i++) {\n        int j = 0;\n        while (j < w) {\n            int k = j;\n            while (j < w && g[i][j] == g[i][k]) j++;\n            if (j - k >= K) {\n                sum += (j - k) * (g[i][k] - '0');\n                for (; k < j; k++) g[i][k] = '0';\n            }\n        }\n    }\n    return sum;\n}\n\nint run(vector<string> &g, int K) {\n    int res = 0;\n    for (int i = 0;; i++) {\n        fall(g);\n        int s = erase(g, K);\n        if (s == 0) break;\n        res += (1 << i) * s;\n    }\n    return res;\n}\n\nint main() {\n    int h, w, K;\n    cin >> h >> w >> K;\n    vector<string> g(h);\n    for (int i = 0; i < h; i++) cin >> g[i];\n\n    int ans = 0;\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            auto tmp = g;\n            tmp[i][j] = '0';\n            ans = max(ans, run(tmp, K));\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<((x))<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n\nint h,w,k;\nvector<string> vec;\nvector<string> crnt;\n\nint search(int itr){\n  int ret=0;\n  // 消せるとこを0で埋めながら加点\n  bool changed=false;\n  rep(i,h){\n    rep(j,w-1){\n      if(crnt[i][j]==0) continue;\n      int d=0;\n      while(j+d<w && crnt[i][j] == crnt[i][j+d]) d++;\n      if(d>=k){\n        ret += (1<<itr)*(crnt[i][j]-'0')*d;\n        rep(dd,d) crnt[i][j+dd]=0;\n        changed=true;\n      }\n      j += d-1;\n    }\n  }\n\n  if(!changed) return ret;\n\n  // -1をつめる\n  rep(j,w){\n    int s=h-1;\n    for(int hh=h-1; hh>=0; hh--){\n      while( s>=0 && crnt[s][j]==0) s--;\n      if(s<0) crnt[hh][j]=0;\n      else crnt[hh][j] = crnt[s][j];\n      s--;\n    }\n  }\n  return ret + search(itr+1);\n}\n\nint main(){\n  cin>>h>>w>>k;\n  vec.resize(h);\n  rep(i,h) cin>>vec[i];\n\n  int res=0;\n  rep(i,h) rep(j,w){\n    crnt = vector<string>(vec);\n    for(int ii=i; ii>0; ii--) crnt[ii][j] = crnt[ii-1][j];\n    crnt[0][j] = 0;\n    res = max(res, search(0)); //dbg(res);\n  }\n\n  cout<<res<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n\nint H, W, K;\n\nvoid fall(vector<vector<int>> &c) {\n    rep(i,W) rep(j,H) {\n        if (c[i][j] == 0) {\n            for (int k = 1; k + j < H; ++k) {\n                if (c[i][k+j] != 0) {\n                    for (int l = j; l < H; ++l) {\n                        if (l + k < H) c[i][l] = c[i][l+k];\n                        else c[i][l] = 0;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n}\n\nvoid sum(ll &ans, ll delete_cnt, vector<vector<int>> &c) {\n    rep(i,H) {\n        ll left = 0;\n        rep(j,W) {\n            if (c[j+1][i] != 0 && c[j+1][i] == c[j][i]) continue;\n            if (c[j+1][i] != c[j][i]) {\n                if (j - left + 1 > 1) {\n                    ans += powl(2LL, delete_cnt) * (j - left + 1) * c[j][i];\n                    for (int k = left; k <= j; ++k) c[k][i] = 0;\n                }\n            }\n            left = j + 1;\n        }\n    }\n}\n\n\n\nll calc_ans(int x, int y, vector<vector<int>> c) {\n    ll res = 0;\n    ll pre_ans = -1;\n    ll delete_cnt = 0;\n\n    c[x][y] = 0;\n    fall(c);\n    while (res != pre_ans) {\n        pre_ans = res;\n        sum(res, delete_cnt, c);\n        fall(c);\n        ++delete_cnt;\n    }\n    return res;\n}\n\n\nint main() {\n    cin >> H >> W >> K;\n    vector<vector<int>> c(W+1, vector<int>(H));\n    rep(i,H) {\n        string S;\n        cin >> S;\n        rep(j,W) c[j][H-1-i] = S[j] - '0';\n    }\n\n    ll ans = 0;\n\n    rep(i,W) rep(j,H) {\n        if (i == 0) continue;\n        ans = max(ans, calc_ans(i, j, c));\n    }\n    \n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair< ll, ll > Pi;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep2(i,n) for(int i=1;i<=(n);i++)\n#define rep3(i,i0,n) for(int i=i0;i<(n);i++)\n#define pb push_back\n#define mod 1000000007\nconst ll INF = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nll gcd(ll a, ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b) {return a/gcd(a,b)*b;}\n#define all(x) x.begin(), x.end()\n#define mp make_pair\nbool compare(Pi a, Pi b) {\n    if(a.first != b.first){\n        return a.first < b.first;\n        \n    }else{\n        return a.second < b.second;\n    }\n}\n\nint ctoi(char c) {\n\tif (c >= '0' && c <= '9') {\n\t\treturn c - '0';\n\t}\n\treturn 0;\n}\nbool In_map(ll y,ll x,ll h,ll w){\n    if(y<0 || x<0 || y>=h || x>=w){\n        return 0;\n    }else{\n        return 1;\n    }\n}\nconst vector<ll> dx{1,0,-1,0};\nconst vector<ll> dy{0,1,0,-1};\n\n\n\nint main() {\n\n    ll H,W,K;\n    cin >>H>>W>>K;\n    vector<string> S(H+1);\n    rep(i,H) cin >>S[i];\n    vector<vector<ll>> R(H+1,vector<ll>(W+1));\n    vector<vector<ll>> R2(H+1,vector<ll>(W+1));\n    rep(i,H) rep(j,W) R[i][j] = ctoi(S[i][j]);\n    //R2 = R;\n    if(K<=1){\n        ll ans = 0;\n        ll min = INF;\n        rep(i,H){\n            rep(j,W){\n                chmin(min,R[i][j]);\n                ans+=R[i][j];\n            }\n        }\n        cout << ans-min<<endl;\n        return 0;\n    }\n\n\n    ll fans = 0;\n    rep(h,H) rep(w,H){\n    ll ans = 0;\n    R=R2;\n    //R[h][w] = -1;\n    ll flag = 0;\n    rep(m,H){\n        //ll p2 =pow(2,m); \n        /*rep(j,W){\n            vector<ll> tmp;\n            rep(i,H){\n                if(R[H-1-i][j] != -1){\n                    tmp.pb(R[H-1-i][j]);\n                }\n            }\n            rep(i,H){\n                if(i<tmp.size()){\n                    R[H-1-i][j] = tmp[i];\n                }else{\n                    R[H-1-i][j] = -1;\n                }\n            }\n        }*/\n        /*rep(i,H){\n            ll cnt=0;\n            ll p=-1;\n            rep(j,W){\n                if(R[i][j] == p && R[i][j] != -1){\n                    cnt++;\n                    if(j==W-1){\n                        if(cnt>=K){\n                            flag = 1;\n                            //ans += R[i][j-1]*cnt*p2;\n                            rep(k,cnt){\n                               // R[i][j-k] = -1;\n                            }\n                        }\n                    }\n                }else{\n                    if(cnt>=K){\n                        flag = 1;\n                        //ans += R[i][j-1]*cnt*p2;\n                        rep(k,cnt){\n                            //R[i][j-k-1] = -1;\n                        }\n                    }\n                    cnt = 1;\n                }\n                \n\n                p = R[i][j];\n            }\n        \n        \n        }*/\n\n        if(flag ==0) break;\n    }\n\n\n        chmax(fans,ans);\n    }\n\n    cout << fans<<endl;\n    \n    return 0;\n    \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <iomanip>\n#include <climits>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef pair<ll, ll> P;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define revrep(i, n) for(int i = (n)-1; i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\n#define chmin(x, y) x = min(x, y);\n#define chmax(x, y) x = max(x, y);\n\n//const ll INFL = LLONG_MAX;//10^18 = 2^60\nconst ll INFL = 1LL<<60;\n//const int INF = INT_MAX;\nconst ll INF = 1 << 30;//10^9\nll MOD = 1000000007;\n//ll MOD = 998244353;\n\nvector<ll> dy = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nvector<ll> dx = {1, 0, -1, 0, 1, -1, 1, -1, 0};\n\nvoid pres(double A){printf(\"%.9lf\\n\", A);}\nvoid BinarySay(ll x, ll y = 60){rep(i, y) cout << (x>>(y-1-i) & 1); cout << endl;}\nll cnt_bit(ll x){return __builtin_popcountll(x);}\n\nll pow_long(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2) res *= x;\n    x *= x; k /= 2;\n  }\n  return res;\n}\n\nll pow_mod(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2){\n      res *= x; res %= MOD;\n    }\n    x *= x; x %= MOD;\n    k /= 2;\n  }\n  return res;\n}\n\nll inverse(ll x){return pow_mod(x, MOD - 2);};\n\nll gcd(ll a, ll b){\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\nll lcm(ll x, ll y){\n  ll res = x / gcd(x, y);\n  res *= y;\n  return res;\n};\n\n\n//コンビネーション\nconst int MAXcomb = 2000010;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\n//facはn!,finvは1/n!\n//invは逆元\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAXcomb; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nll comb(int n, int k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    return fac[n] * finv[k] % MOD * finv[n-k] % MOD;\n}\n\nconst int MAXkai = 200010;\nll kai_memo[MAXkai];\nll kai(ll N){\n  if(kai_memo[N] != 0) return kai_memo[N];\n  if(N <= 1) return 1;\n  return kai_memo[N] = N * kai(N-1) % MOD;\n}\n\nll disit(ll s, ll base = 10){\n  ll res = 0;\n  while(s){\n    res++;\n    s /= base;\n  }\n  return res;\n}\n\n\nint H, W, K;\nint c[31][31];\nint tmp[31][31];\n\nint add(){\n  for(int j = 0; j < W; j++){\n    for(int i = H - 1; i >= 0; i--){\n      bool update = 1;\n      while(update){\n        update = 0;\n        if(tmp[i][j]) break;\n        for(int k = i; k >= 1; k--){\n          if(tmp[k][j] != tmp[k-1][j]) update = 1;\n          tmp[k][j] = tmp[k-1][j];\n        }\n        tmp[0][j] = 0;\n        if(!update) break;\n      }\n    }\n  }\n\n  int res = 0;\n  for(int i = 0; i < H; i++){\n    int num = -1, len = 0;\n    for(int j = 0; j < W + 1; j++){\n      if(tmp[i][j] != num){\n        if(len >= K){\n          for(int k = j - len; k < j; k++){\n            res += tmp[i][k];\n            tmp[i][k] = 0;\n          }\n        }\n        num = tmp[i][j];\n        len = 1;\n      }else{\n        len++;\n      }\n    }\n  }\n  return res;\n}\n\nint calc(int ei, int ej){\n  rep(i, H)rep(j, W) tmp[i][j] = c[i][j];\n  tmp[ei][ej] = 0;\n  int ans = 0;\n  for(int i = 0;; i++){\n    int res = add();\n    if(res == 0) break;\n    ans += (1<<i) * res;\n  }\n  return ans;\n}\n\nvoid solve(){\n  cin >> H >> W >> K;\n  rep(i, H){\n    string S;\n    cin >> S;\n    rep(j, W) c[i][j] = S[j] - '0';\n  }\n  int ans = 0;\n  rep(i, H)rep(j, W){\n    ans = max(ans, calc(i, j));\n  }\n  cout << ans << endl;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0, a1, a2, a3, a4, x, ...) x\n#define dump_1(x1) cerr << #x1 << \": \" << x1 << endl\n#define dump_2(x1, x2) \\\n  cerr << #x1 << \": \" << x1 << \", \" #x2 << \": \" << x2 << endl\n#define dump_3(x1, x2, x3)                                                \\\n  cerr << #x1 << \": \" << x1 << \", \" #x2 << \": \" << x2 << \", \" #x3 << \": \" \\\n       << x3 << endl\n#define dump_4(x1, x2, x3, x4)                                            \\\n  cerr << #x1 << \": \" << x1 << \", \" #x2 << \": \" << x2 << \", \" #x3 << \": \" \\\n       << x3 << \", \" #x4 << \": \" << x4 << endl\n#define dump_5(x1, x2, x3, x4, x5)                                        \\\n  cerr << #x1 << \": \" << x1 << \", \" #x2 << \": \" << x2 << \", \" #x3 << \": \" \\\n       << x3 << \", \" #x4 << \": \" << x4 << \", \" #x5 << \": \" << x5 << endl\n#define dump(...) \\\n  CHOOSE((__VA_ARGS__, dump_5, dump_4, dump_3, dump_2, dump_1, ~))(__VA_ARGS__)\n#define check(s) cerr << s << endl\n\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define repr(i, n) for (int i = n; i >= 0; i--)\n#define FOR(i, m, n) for (int i = m; i < n; i++)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ((int)(x).size())\n#define unique(v) v.erase(unique(v.begin(), v.end()), v.end());\n\nusing namespace std;\n\nusing ll = long long;\n\nvector<int> dx = {0, 1, 0, -1};\nvector<int> dy = {1, 0, -1, 0};\n\nconst ll LINF = 2e18;\nconst int INF = 1e9;\n\nll H, W, K;\nvector<vector<ll>> c;\nvector<vector<ll>> d;\n\nvoid update() {\n  for (int i = H - 1; i > 0; i--) {\n    rep(j, W) {\n      if (d.at(i).at(j) == -1) {\n        int k = i - 1;\n        while (k > 0 && d.at(k).at(j) == -1) {\n          k--;\n        }\n        d.at(i).at(j) = d.at(k).at(j);\n        d.at(k).at(j) = -1;\n      }\n    }\n  }\n}\n\nvoid disp() {\n  rep(i, H) {\n    rep(j, W) {\n      char buf[5];\n      snprintf(buf, sizeof(buf), \"%2d \", d.at(i).at(j));\n      cerr << buf;\n    }\n    cerr << endl;\n  }\n  cerr << endl;\n}\n\nll f(int y, int x) {\n  d = c;\n  d.at(y).at(x) = -1;\n\n  ll ans = 0;\n  ll p = 0;\n\n  while (true) {\n    update();\n\n    vector<pair<int, pair<int, int>>> a;\n\n    rep(i, H) {\n      int st = 0;\n      a.push_back({i, {st, st}});\n      rep(j, W) {\n        if (d.at(i).at(j) == -1) {\n          st = j;\n          continue;\n        }\n\n        if (d.at(i).at(j) == d.at(i).at(st)) {\n          a.at(sz(a) - 1) = {i, {st, j}};\n        } else {\n          a.push_back({i, {st, st}});\n          st = j;\n        }\n      }\n    }\n\n    bool found = false;\n    ll p2 = pow(2, p);\n    for (auto v : a) {\n      int i = v.first;\n      int st = v.second.first;\n      int ed = v.second.second;\n      if (ed - st + 1 >= K) {\n        int sum = 0;\n        for (int j = st; j <= ed; j++) {\n          sum += d.at(i).at(j);\n          d.at(i).at(j) = -1;\n        }\n        ans += p2 * sum;\n        found = true;\n      }\n    }\n\n    if (!found) break;\n    p++;\n  }\n\n  return ans;\n}\n\nvoid solve() {\n  ll ans = 0;\n  rep(i, H) {\n    rep(j, W) {\n      ll v = f(i, j);\n      ans = max(ans, v);\n    }\n  }\n  cout << ans << endl;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> H >> W >> K;\n  c.resize(H, vector<ll>(W));\n  rep(i, H) {\n    string s;\n    cin >> s;\n    rep(j, W) c.at(i).at(j) = s.at(j) - '0';\n  }\n\n  solve();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <stdlib.h>\n#include <math.h>\n#include <string>\n#include <time.h>\n#include <string.h>\n#include <queue>\n#include <stack>\nusing namespace std;\ntypedef long long int ll;\nint a[35][35];\nint h, w, k;\nll ans;\nint pla[35][35];\nchar temp[35];\n\nvoid perfall(void)\n{\n\tint i, j;\n\tfor(i=1 ; i<=w ; i++)\n\t{\n\t\tvector<int> non;\n\t\tfor(j=1 ; j<=h ; j++)\n\t\t{\n\t\t\tif(pla[j][i]!=0)\n\t\t\t{\n\t\t\t\tnon.push_back(pla[j][i]);\n\t\t\t}\n\t\t}\n\t\tfor(j=1 ; j<=h ; j++)\n\t\t{\n\t\t\tif(j<=h-non.size())\n\t\t\t{\n\t\t\t\tpla[j][i]=0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpla[j][i]=non[j-(h-non.size())-1];\n\t\t\t}\n\t\t}\n\t}\n}\n\nll val(void)\n{\n\tint i, cur;\n\tll ret=0;\n\tfor(i=1 ; i<=h ; i++)\n\t{\n\t\tfor(cur=2 ; cur<=w ; cur++)\n\t\t{\n\t\t\tif(k==2)\n\t\t\t{\n\t\t\t\tif(pla[i][cur]==pla[i][cur-1] && pla[i][cur]!=0)\n\t\t\t\t{\n\t\t\t\t\tint vv=pla[i][cur];\n\t\t\t\t\tpla[i][cur-1]=0;\n\t\t\t\t\tret+=vv;\n\t\t\t\t\twhile(pla[i][cur]==vv && cur<=w)\n\t\t\t\t\t{\n\t\t\t\t\t\tpla[i][cur]=0;\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tret+=vv;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(k==3)\n\t\t\t{\n\t\t\t\tif(cur>=3 && pla[i][cur-2]==pla[i][cur-1] && pla[i][cur]==pla[i][cur-1] && pla[i][cur]!=0)\n\t\t\t\t{\n\t\t\t\t\tint vv=pla[i][cur];\n\t\t\t\t\tpla[i][cur-2]=0;\n\t\t\t\t\tpla[i][cur-1]=0;\n\t\t\t\t\tret+=2*vv;\n\t\t\t\t\twhile(pla[i][cur]==vv && cur<=w)\n\t\t\t\t\t{\n\t\t\t\t\t\tpla[i][cur]=0;\n\t\t\t\t\t\tcur++;\n\t\t\t\t\t\tret+=vv;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nll call(int x, int y)\n{\n\tll ret=0;\n\tll mul=1;\n\tint i, j;\n\tfor(i=1 ; i<=h ; i++)\n\t{\n\t\tfor(j=1 ; j<=w ; j++)\n\t\t{\n\t\t\tif(i!=x || j!=y)\n\t\t\t{\n\t\t\t\tpla[i][j]=a[i][j];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpla[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool cont=true;\n\twhile(cont)\n\t{\n\t\tll kil=0;\n\t\t\n\t\tperfall();\n\t\t\n\t\tkil=val();\n\t\t\n\t\tret+=kil*mul;\n\t\tmul=mul*2;\n\t\tif(kil==0)\n\t\t{\n\t\t\tcont=false;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin>>h>>w>>k;\n\tint i, j;\n\tfor(i=1 ; i<=h ; i++)\n\t{\n\t\tscanf(\"%s\",&temp[1]);\n\t\tfor(j=1 ; j<=w ; j++)\n\t\t{\n\t\t\ta[i][j]=temp[j]-'0';\n\t\t}\n\t}\n\tfor(i=1 ; i<=h ; i++)\n\t{\n\t\tfor(j=1 ; j<=w ; j++)\n\t\t{\n\t\t\tans=max(ans,call(i,j));\n\t\t}\n\t}\n\tcout<<ans;\n\tcout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n//#pragma GCC optimize (\"-O3\") \n#ifdef YANG33\n#include \"mydebug.hpp\"\n#else\n#define DD(x) \n#endif\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\n\n/* -----  2019/07/09  Problem: SQUARE869120CONTEST_03 B / Link: https://atcoder.jp/contests/s8pc-3/  ----- */\n\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tLL H, W, K; cin >> H >> W >> K;\n\tassert(K > 1);\n\tvector<string> s(H);\n\tfor (int i = 0; i < H; ++i) {\n\t\tcin >> s[i];\n\t\tFOR(j, 0, W) {\n\t\t\ts[i][j] -= '0';\n\t\t}\n\t}\n\tauto fall = [](VS& s) {\n\t\tint H = SZ(s), W = SZ(s[0]);\n\t\tFOR(j, 0, W) {\n\t\t\tvector<int>a;\n\t\t\tFOR(i, 0, H) {\n\t\t\t\tif (s[i][j])a.push_back(s[i][j]);\n\t\t\t\ts[i][j] = 0;\n\t\t\t}\n\t\t\tFOR(i, 0, SZ(a)) {\n\t\t\t\ts[H - i - 1][j] = a[SZ(a) - 1 - i];\n\t\t\t}\n\t\t}\n\t};\n\tauto f = [&K, &fall](int aa, int bb, auto s) {\n\t\ts[aa][bb] = 0;\n\t\tLL ret = 0;\n\t\tbool upd = 1;\n\t\tLL t = 0;\n\t\tint H = SZ(s), W = SZ(s[0]);\n\t\twhile (upd) {\n\t\t\tfall(s);\n\t\t\tupd = 0;\n\t\t\tLL sub = 0;\n\t\t\t{ // check\n\t\t\t\tFOR(i, 0, H) {\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tint pre = -1;\n\t\t\t\t\tFOR(j, 0, W) {\n\t\t\t\t\t\tif (s[i][j] == pre)cnt++;\n\t\t\t\t\t\telse if (s[i][j] != pre && cnt >= K) {\n\t\t\t\t\t\t\tupd |= pre;\n\t\t\t\t\t\t\twhile (cnt) {\n\t\t\t\t\t\t\t\tint k = j - cnt;\n\t\t\t\t\t\t\t\tsub += s[i][k];\n\t\t\t\t\t\t\t\ts[i][k] = 0;\n\t\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpre = s[i][j];\n\t\t\t\t\t\t\tcnt = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (s[i][j] != pre) {\n\t\t\t\t\t\t\tpre = s[i][j];\n\t\t\t\t\t\t\tcnt = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (pre != -1 && cnt >= K) {\n\t\t\t\t\t\tupd |= pre;\n\t\t\t\t\t\twhile (cnt) {\n\t\t\t\t\t\t\tint k = W - cnt;\n\t\t\t\t\t\t\tsub += s[i][k];\n\t\t\t\t\t\t\ts[i][k] = 0;\n\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tret += (LL)pow(2LL, t)*sub;\n\t\t\tt++;\n\t\t}\n\t\treturn ret;\n\t};\n\tLL ans = 0LL;\n\tFOR(i, 0, H) {\n\t\tFOR(j, 0, W) {\n\t\t\tans = max(ans, f(i, j, s));\n\t\t}\n\t}\n\n\n\tcout << (ans) << \"\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint n,m,K;\nint a[35][35],ma[35][35],c[35][35];\n\nint max(int a, int b)\n{\n    if(a<b)return b;\n    return a;\n}\nvoid f(int x, int y)\n{\n    int i;\n    for(i=x;i>=1;i--){\n        a[i][y]=a[i-1][y];\n    }\n}\nint g(int x, int y)\n{\n    int X=1,i,j,res=0,C,s,k;\n    for(i=1;i<=n;i++){\n        a[i][0]=-1;\n        for(j=1;j<=m;j++)a[i][j]=ma[i][j],c[i][j]=0;\n    }\n    f(x,y);\n    while(1){\n        C=0;\n        for(i=1;i<=n;i++){\n            s=0;\n            for(j=1;j<=m+1;j++){\n                if((a[i][j]!=a[i][s])){\n                    if(s<=j-K&&a[i][s]){\n                        for(k=s;k<j;k++)c[i][k]=1;\n                        C=1;\n                    }\n                    s=j;\n                }\n            }\n        }\n        for(i=1;i<=n;i++){\n            for(j=1;j<=m;j++){\n                if(c[i][j])res+=X*a[i][j],f(i,j);\n                c[i][j]=0;\n            }\n        }\n        if(C==0)break;\n        X*=2;\n    }\n    return res;\n}\n\nint main()\n{\n    int i,j,res=0;\n    scanf(\"%d %d %d\", &n, &m, &K);\n    for(i=1;i<=n;i++){\n        for(j=1;j<=m;j++){\n            scanf(\" %c\", &a[i][j]);\n            a[i][j]-='0';\n            ma[i][j]=a[i][j];\n        }\n    }\n    for(i=1;i<=n;i++){\n        for(j=1;j<=m;j++){\n            res=max(res,g(i,j));\n        }\n    }\n    printf(\"%d\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define H 50\nusing namespace std;\ntypedef long long ll;\nint h,w,k;\nstring s[H];\n\nll check(int y,int x){\n  string t[H];\n  for(int i=0;i<h;i++)t[i]=s[i];\n  for(int i=y;i>0;i--)\n    t[i][x]=t[i-1][x];\n  ll res=0;\n  for(int i=1;i<h;i++){\n    int f=0;\n    for(int j=1;j<w;j++)\n      if(t[i][0]!=t[i][j])f=1;\n    if(!f)res+=(t[i][0]-'0')*w;\n  }\n  return res;\n}\n\nint main(){\n  cin>>h>>w>>k;\n  if(w!=k)cout<<'a'<<endl;\n  else{\n    for(int i=0;i<h;i++)\n      cin>>s[i];\n    ll ans=0;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tans=max(ans,check(i,j));\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstring s[35], t[35];\nint h, w, k, cnt[35][35];\n\nint sim() {\n  int mul = 1, score = 0;\n  bool update = true;\n  while(update) {\n    update = false;\n    //落とす\n    FOR(i2, 1, h) {\n      for(int i=h-1; i>0; --i) REP(j, w) {\n        if(t[i][j] == '-') {\n          t[i][j] = t[i-1][j];\n          t[i-1][j] = '-';\n        }\n      }\n    }\n    // REP(i, h) {\n    //   cout << t[i] << endl;\n    // }\n    // cout << \"kesu\\n\";\n\n    //水平に何個隣り合っているか\n    REP(i, h) {\n      cnt[i][0] = 1;\n      FOR(j, 1, w) {\n        if(t[i][j] == t[i][j-1] && t[i][j] != '-') {\n          cnt[i][j] = cnt[i][j-1] + 1;\n        } else {\n          cnt[i][j] = 1;\n        }\n      }\n    }\n\n    //消せるやつを消して空白に&&スコアプラス\n    REP(i, h) {\n      int tmp = 0;\n      for(int j=w-1; j>=0; --j){\n        if(tmp == 0 && cnt[i][j] >= k) {\n          tmp = cnt[i][j];\n          score += mul*(t[i][j]-'0')*cnt[i][j];\n          update = true;\n        }\n        if(tmp > 0) t[i][j] = '-', tmp--;\n      }\n    }\n    mul *= 2;\n    // REP(i, h) {\n    //   cout << t[i] << endl;\n    // }\n  }\n  return score;\n}\n\n\nsigned main(void)\n{\n  cin >> h >> w >> k;\n  REP(i, h) cin >> s[i];\n\n  int ret = 0;\n  REP(i, h) REP(j, w) {\n    // cout << i << \" \" << j << \"-------------\" << endl;\n    REP(i2, h) t[i2] = s[i2];\n    t[i][j] = '-';\n    ret = max(ret, sim());\n    // cout << \"ret:\" << ret << endl;\n  }\n  cout << ret << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst long long LINF=8931145141919364364,LMOD=998244353;\ninline long long mod(long long n,long long m){return(n%m+m)%m;}\n// const int dx[]={1,0,-1,0,1,1,-1,-1},dy[]={0,-1,0,1,1,-1,-1,1};\n\nint h,w,k;\nvector<int> board[35];\nvoid check(){\n    rep(i,h){\n        rep(j,w) cout<<board[j][i];\n        cout<<endl;\n    }\n}\nint search(){\n    int ret=0;\n    rep(i,h){\n        int pre=-1,cnt=0;\n        rep(j,w){\n            if(board[j][i]!=pre){\n                if(pre!=-1&&cnt>=k){\n                    ret+=pre*cnt;\n                    rep(d,cnt){\n                        if(j-1-d>=0) board[j-1-d][i]=0;\n                    }\n                }\n                cnt=1,pre=board[j][i];\n            }else{\n                cnt++;\n            }\n        }\n        if(pre!=-1&&cnt>=k){\n            ret+=pre*cnt;\n            rep(d,cnt){\n                if(w-1-d>=0) board[w-1-d][i]=0;\n            }\n        }\n    }\n    return ret;\n}\nvoid del(){\n    for(int i=h-1;i>=0;i--)rep(j,w){\n        if(board[j][i]==0){\n            board[j].erase(board[j].begin()+i);\n            board[j].push_back(-1);\n        }\n    }\n}\nint main(){\n    cin>>h>>w>>k;\n    rep(i,h)rep(j,w){\n        char c; cin>>c;\n        board[j].push_back(c-'0');\n    }\n    rep(i,w) reverse(all(board[i]));\n    // check();\n    long long ans=0;\n    rep(i,h)rep(j,w){\n        vector<int> save[35]=board;\n        board[j].erase(board[j].begin()+i);\n        board[j].push_back(-1);\n        // if(i==0&&j==2)check();\n        long long cnt=0,tmp=0;\n        while(1){\n            int x=search();\n            del();\n            if(x>0){\n                tmp+=pow(2,cnt)*x;\n                cnt++;\n            }\n            else break;\n        }\n        // cout<<tmp<<endl;\n        ans=max(ans,tmp);\n        // check(); cout<<endl;\n        rep(i,h)rep(j,w) board[i][j]=save[i][j];\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (ll i = 0; i < n; ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v, x) (std::find(v.begin(), v.end(), x) != v.end())\n#define FORV(i, v) for (auto i = v.begin(); i != v.end(); i++)\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline void dump(vector<T> v) { for (auto& x : v) cerr << x << \" \"; cerr << endl; }\ntemplate<class T> inline void dump(vector<pair<T, T>> v) { for (auto& p : v) cerr << p.first << \" \" << p.second << endl; }\ntemplate<class T> inline void dump(vector<vector<T>> vv) { for (auto& v : vv) {for (auto& x : v) cerr << x << \" \"; cerr << endl;} }\n\nconst ll INF = 1e9;\nconst long long INFL = 1LL<<60;\n\nint delete_stone(vector<vector<int>>& c, const int& k) {\n  int h = c.size();\n  int w = c[0].size();\n  int score = 0;\n  for (int i = 0; i < h; i++) {\n    for (int l = 0; l < w;) {\n      int r = l + 1;\n      for (; r < w && c[i][l] == c[i][r]; r++);\n      if (r - l >= k) {\n        score += c[i][l] * (r - l);\n        for (; l < r; l++) c[i][l] = 0;\n      }\n      l = r;\n    }\n  }\n  return score;\n}\n\nvoid move_stone(vector<vector<int>>& c) {\n  int h = c.size();\n  int w = c[0].size();\n  rep(j, w) {\n    vector<int> tmp(h, 0);\n    int l = 0;\n    for (int i = h - 1; i >= 0; i--) {\n      if (c[i][j] != 0) tmp[l++] = c[i][j];\n    }\n    for (int i = h - 1; i >= 0; i--) {\n      c[i][j] = tmp[h - 1 - i];\n    }\n  }\n}\n\nint calc(vector<vector<int>> c, int h, int w, const int& k) {\n  c[h][w] = 0;\n  move_stone(c);\n  int score = 0;\n  for (int i = 1; ; i *= 2) {\n    int tmp = delete_stone(c, k);\n    if (tmp == 0) break;\n    score += tmp * i;\n    move_stone(c);\n  }\n  return score;\n}\n\nint main() {\n  int h, w, k;\n  cin >> h >> w >> k;\n\n  vector<vector<int>> c(h, vector<int>(w, 0));\n\n  rep(i, h) {\n    string s;\n    cin >> s;\n    rep(j, w) c[i][j] = int(s[j] - '0');\n  }\n\n  int ans = 0;\n\n  rep(i, h) {\n    rep(j, w) {\n      chmax(ans, calc(c, i, j, k));\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nint solve(vector<string> grid, int sy, int sx, int k)\n{\n    int h = grid.size();\n    int w = grid[0].size();\n    grid[sy][sx] = ' ';\n\n    int base = 1;\n    int ans = 0;\n    for(;;){\n        for(int x=0; x<w; ++x){\n            int y2 = h-1;\n            for(int y=h-1; y>=0; --y){\n                if(grid[y][x] != ' '){\n                    swap(grid[y][x], grid[y2][x]);\n                    -- y2;\n                }\n            }\n        }\n\n        bool isChange = false;\n        for(int y=0; y<h; ++y){\n            int cnt = 1;\n            for(int x=1; x<=w; ++x){\n                if(x < w && grid[y][x] == grid[y][x-1]){\n                    ++ cnt;\n                }\n                else{\n                    if(cnt >= k && grid[y][x-1] != ' '){\n                        for(int i=0; i<cnt; ++i){\n                            ans += base * (grid[y][x-1-i] - '0');\n                            grid[y][x-1-i] = ' ';\n                        }\n                        isChange = true;\n                    }\n                    cnt = 1;\n                }\n            }\n        }\n        base *= 2;\n\n        if(!isChange)\n            return ans;\n    }\n}\n\nint main()\n{\n    int h, w, k;\n    cin >> h >> w >> k;\n    vector<string> grid(h);\n    for(int y=0; y<h; ++y)\n        cin >> grid[y];\n\n    int ans = 0;\n    for(int y=0; y<h; ++y){\n        for(int x=0; x<w; ++x){\n            ans = max(ans, solve(grid, y, x, k));\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stdio.h>\n#include<cstring>\n#include<math.h>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<queue>\nusing namespace std;\n\n#define rep(i, n) for (long long i = 0; i < (long long)(n); ++i)\nusing P = pair<long long, long long>;\n\nlong long H, W, K;\nlong long cc[30][30];\nlong long c[30][30];\nlong long ans = 0;\n\nint main() {\n  cin >> H >> W >> K;\n  rep(i, H) {\n    string s;\n    cin >> s;\n    rep(j, W) {\n      cc[i][j] = s[j] - '0';\n    }\n  }\n\n  long long temp = 0;\n\n  rep(iii, H) {\n    rep(jjj, W) {\n      // if(iii != 3 || jjj != 0) continue;\n      long long count = 1;\n      temp = 0;\n      rep(ii, H) {\n        rep(jj, W) {\n          c[ii][jj] = cc[ii][jj];\n        }\n      }\n      if(iii == 0) {\n        c[iii][jjj] = 0;\n      } else {\n        for(long long k = 1; k <= iii; k++) {\n          swap(c[0][jjj], c[k][jjj]);\n        }\n        c[0][jjj] = 0;\n      }\n\n      while(true) {\n        vector<pair<pair<long long, long long>, long long>> mem;\n        rep(i, H) {\n          rep(j, W) {\n            if(c[i][j] == 0) continue;\n            bool ff = false;\n            long long M = max(K, W - j);\n            for(long long k = M; k >= K; k--) {\n              bool f = true;\n              rep(l, k-1) {\n                if(c[i][j+l] != c[i][j+l+1]) {\n                  f = false;\n                }\n              }\n              if(f) {\n                mem.push_back({{i, j}, k});\n                temp += k * c[i][j] * count;\n                ff = true;\n              }\n              if(ff) {\n                j = j + k - 1;\n                // cout << j << endl;\n                break;\n              }\n            }\n            if(ff) continue;\n          }\n        }\n\n        if(mem.size() == 0) break;\n\n        rep(i, mem.size()) {\n          // cout << mem[i].first.first << \" \" << mem[i].first.second << \" \" << mem[i].second << endl;\n          long long sx, sy, k;\n          sx = mem[i].first.first;\n          sy = mem[i].first.second;\n          k = mem[i].second;\n          if(sx == 0) {\n            rep(j, k) {\n              c[sx][sy+j] = 0;\n            }\n          } else {\n            for(long long h = 1; h <= sx; h++) {\n              rep(j, k) {\n                swap(c[0][sy+j], c[h][sy+j]);\n              }\n            }\n            rep(j, k) {\n              c[0][sy+j] = 0;\n            }\n          }\n\n        }\n\n        count *= 2;\n      }\n      // cout << temp << endl;\n      ans = max(ans, temp);\n    }\n  }\n\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ temp.cpp\n// C++ includes used for precompiling -*- C++ -*-\n\n// Copyright (C) 2003-2013 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file stdc++.h\n *  This is an implementation file for a precompiled header.\n */\n\n// 17.4.1.2 Headers\n\n// C\n//#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n/*\n//#if __cplusplus >= 201103L\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n*/\n\n// C++\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n/*\n//#if __cplusplus >= 201103L\n#include <array>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n*/\nusing namespace std;\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n  \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\n\n#define INF INT_MAX/3\n#define MAX_N 1000\n int h,w,k;\n vector<string> vec;\n vector<string> crnt;\n\n int search(int itr){\n  int ret=0;\n  //消せることを0で埋めながら加算していく\n  bool changed = false;\n  rep(i,h){\n    rep(j,w-1){\n      //0ということはもうそこには数字が入っていないということだからcontinueしていい\n      if(crnt[i][j]==0) continue;\n      int d=0;\n      //横の値が等しいだけ加算していく\n      while(j+d<w&&crnt[i][j]==crnt[i][j+d]) d++;\n      if(d>=k){\n        //もし規定の長さを超えたなら\n        //加算して消した所に0を代入していく\n        //スコアはi回目で消滅した数字の値の和なのでbitをずらすことで実現している\n        ret += (1<<itr) * (crnt[i][j]-'0')*d;\n        rep(dd,d) crnt[i][j+dd] = 0;\n        changed = true;\n      }\n      //dが増えていたらそのぶんずらしてあげてそうでなかったら-1してインクリメント\n      //される時にその点から始まるようにする\n    j += d-1;\n  }\n }\n //変化が一つもない場合はもう返す\n if(!changed) return ret;\n\n //-1をつめる\n rep(j,w){\n  int s=h-1;\n  for(int hh=h-1;hh>=0;hh--){\n    while(s>=0&crnt[s][j]==0) s--;\n    if(s<0) crnt[hh][j]=0;//もう入っていないということ\n    else crnt[hh][j] = crnt[s][j];\n    s--;\n    }\n }\n return ret + search(itr+1);\n}\n\n int main(){\n  cin>>h>>w>>k;\n  //resizeとは\n  //指定した数だけ実際に何らかの値で埋める。\n  ///\n  vec.resize(h);\n  rep(i,h) cin>>vec[i];\n\n  int res=0;\n  rep(i,h) rep(j,w){\n    //ここで作り直したものを入れ直している\n    crnt = vector<string>(vec);\n    for(int ii=i;ii>0;ii--) crnt[ii][j] = crnt[ii-1][j];\n      crnt[0][j]=0;\n    //ここで消す作業をしている\n    res = max(res,search(0));\n  }\n  cout<<res<<endl;\n  return 0;\n }\n // http://s8pc-3.contest.atcoder.jp/submissions/987968"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef DEBUG\n#define debug(x) cout << #x << \": \" << x << endl\n#else\n#define debug(x)\n#endif\n\n#define REP(i, n) for(int i = 0; i < (n); i++)\n#define REPS(i, n) for(int i = 1; i <= (n); i++)\n#define ALL(v) (v).begin(), (v).end()\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n\nusing namespace std;\n\nusing ll = long long;\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vs = vector<string>;\nusing vb = vector<bool>;\n\nconst ll INF = 1e18;\nconst ll MOD = 1e9+7;\n\ntemplate<class T> inline bool chmax(T &a, const T &b) { if (a<b) { a = b; return true;} return false; }\ntemplate<class T> inline bool chmin(T &a, const T &b) { if (a>b) { a = b; return true;} return false; }\n\n\nsigned main()\n{\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n\n    int H, W, K; cin >> H >> W >> K;\n    vector<vl> block(H, vl(W)); \n    REP(i, H) \n    {\n        string s; cin >> s;\n        REP(j, W)\n        {\n            block[i][j] = s[j]-'0';\n        }\n    }\n\n\n    ll ans = 0;\n\n    REP(i, H)\n    {\n        REP(j, W)\n        {\n            ll score = 0, tmp = 0, turn = 0;\n            bool update = true;\n            vector<vl> x(block);\n            x[i][j] = -1;\n            while(update)\n            {\n                tmp = 0;\n                if(turn != 0) update = false;\n                // xを消す\n                REP(i, H)\n                {\n                    ll count = 0, mc = 0, index = 0;\n                    REP(j, W)\n                    {\n                        if(j > 0 && x[i][j] != x[i][j-1]) count = 0;\n                        if(x[i][j] != -1) count++;\n                        if(chmax(mc, count)) index = j;\n                    }\n                    if(mc >= K)\n                    {\n                        update = true;\n                        tmp += mc * x[i][index];\n                        for(int j = index-mc+1; j <= index; j++)\n                        {\n                            x[i][j] = -1;\n                        }\n                    }\n                }\n\n                score += pow(2, turn) * tmp;\n\n                // xを移動\n                REP(j, W)\n                {\n                    int k = H-1;\n                    while(k >= 0 && x[k][j] > 0) k--;\n                    if(k > 0)\n                    {\n                        for(int n = k-1; n >= 0; n--)\n                        {\n                            if(x[n][j] > 0)\n                            {\n                                swap(x[k][j], x[n][j]);\n                                k--;\n                            }\n                            if(k < 0) break;\n                        }\n                    }\n                }\n                turn++;\n            }\n            chmax(ans, score);\n        }\n    }\n    cout << ans / 2 << endl;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<string>\n#include<sstream>\n#include<cmath>\n#include<numeric>\n#include<map>\n#include<stack>\n#include<queue>\n#include<list>\n#include<set>\nusing namespace std;\nint mod = 1e9+7;\nint h, w, k;\nvector<string> c;\nchar B = '-';\n\nvoid show(vector<string> b) {\n  for(int i=0; i<h; i++) cerr << b[i] << endl;\n  cerr << endl;\n}\n\nvector<string> del(vector<string> b) {\n  vector<string> ret = b;\n  for(int i=0; i<h; i++){\n    string s = ret[i];\n    int cnt = 1;\n    for(int j=0; j<w; j++){\n      if( s[j] == s[j+1] ) cnt++;\n      else {\n        if( cnt >= k ) {\n          for(int l=0; l<cnt; l++){\n            s[j-l] = B;\n          }\n        }\n        cnt = 1;\n      }\n    }\n    ret[i] = s;\n  }\n  return ret;\n}\n\nvector<string> drop(vector<string> b) {\n  for(int j=0; j<w; j++){\n    string s = \"\";\n    for(int i=0; i<h; i++){\n      if( b[i][j] != B ) {\n        s += b[i][j];\n      }\n    }\n    s = string(h-s.size(), B) + s;\n    for(int i=0; i<h; i++){\n      b[i][j] = s[i];\n    }\n  }\n  return b;\n}\n\nint calc(vector<string> b) {\n  int ret = 0;\n  for(int i=0; i<h; i++) {\n    for(int j=0; j<w; j++){\n      if( b[i][j] == B ) continue;\n      ret += b[i][j]-'0';\n    }\n  }\n  return ret;\n}\n\nint simulate(vector<string> b, int x, int y) {\n\n  b[y][x] = B;\n  b = drop(b);\n  vector<string> old = b;\n  vector<string> now = b;\n  int score = 0;\n  int base = 1;\n  while( true ) {\n    show(now);\n    now = del(now);\n    int sum = calc(old) - calc(now);\n    cerr << base << \" \" << base * sum << endl;\n    score += base * sum;\n    show(now);\n    now = drop(now);\n\n    if( now == old ) break;\n    old = now;\n    base *= 2;\n  }\n  show(now);\n  // cerr << \"---- \" << score << endl;\n  return score;\n}\n\nint main() {\n  cin >> h >> w >> k;\n  c.resize(h);\n  for(int i=0; i<h; i++){\n    cin >> c[i];\n    c[i] += B;\n  }\n\n  simulate(c, 0, 0);\n\n  // int ans = 0;\n  // for(int i=0; i<h; i++){\n  //   for(int j=0; j<w; j++){\n  //     int tmp = simulate(c, j, i);\n  //     if( ans < tmp ){\n  //       cerr << tmp << \" \" << j << \" \" << i << endl;\n  //     }\n  //     ans = max(ans, tmp);\n  //   }\n  // }\n  // cout << ans << endl;\n\n  return 0;\n}\n\n\n\n\n//\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint n, m, k;\n\nbool ok(const vector<vector<char> >& a, int i, int j)\n{\n    if (k == 2) {\n        if (j + 1 < m && a[i][j + 1] == a[i][j]) {\n            return true;\n        }\n        if (j - 1 >= 0 && a[i][j - 1] == a[i][j]) {\n            return true;\n        }\n        return false;\n    }\n    for (int y = j - 2; y <= j; ++y) {\n        if (y >= 0 && y + 2 < m && a[i][y] == a[i][y + 1] && a[i][y] == a[i][y + 2]) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint solve(vector<vector<char> >& a, int step, int x, int y)\n{\n    for (int i = n - 1; i >= 0; --i) {\n        for (int j = 0; j < m; ++j) {\n            if (a[i][j] != '0') {\n                int curr = i;\n                char d = a[i][j];\n                a[i][j] = '0';\n                while (curr + 1 < n && a[curr + 1][j] == '0') {\n                    ++curr;\n                }\n                a[curr][j] = d;\n            }\n        }\n    }\n    int sum = 0;\n    vector<pii> p;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (a[i][j] != '0' && ok(a, i, j)) {\n                sum += (a[i][j] - '0');\n                p.pb({i, j});\n            }\n        }\n    }\n    for (int i = 0; i < sz(p); ++i) {\n        a[p[i].first][p[i].second] = '0';\n    }\n    if (sum == 0) {\n        return sum;\n    } else {\n        return sum * (1 << step) + solve(a, step + 1, x, y);\n    }\n}\n\nint main()\n{\n\n    //freopen(\"input.txt\", \"r\", stdin);\n\n    //ios_base::sync_with_stdio(false);\n    //cin.tie(0);\n\n    cin >> n >> m >> k;\n\n    vector<vector<char> > c(n, vector<char>(m));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            cin >> c[i][j];\n        }\n    }\n\n    int ans = 0;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            vector<vector<char> > a = c;\n            a[i][j] = '0';\n            ans = max(ans, solve(a, 0, i, j));\n            if (ans == 33) {\n                cout << i << \" \" << j << \"\\n\";\n            }\n        }\n    }\n\n    cout << ans << \"\\n\";\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define SIZE 30\nusing namespace std;\nint cal(int h, int w, int k, int *c){\n    int res = 0, pow = 1, num;\n    while(pow > 0){\n        for(int j=0;j<w;j++){\n            int g = h-1;\n            for(int i=h-1;i>=0;i--){\n                if(*(c+i*SIZE+j) > 0){\n                    if(i < g){\n                        *(c+g*SIZE+j) = *(c+i*SIZE+j);\n                        *(c+i*SIZE+j) = 0;\n                    }\n                    g--;\n                }\n            }\n        }\n        num = 0;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(*(c+i*SIZE+j) == 0)continue;\n                int p = j;\n                while(*(c+i*SIZE+p) == *(c+i*SIZE+j)){\n                    p++;\n                    if(p == w)break;////\n                }\n                if(p - j >= k){\n                    num += *(c+i*SIZE+j) * (p - j);\n                    while(j < p){\n                        *(c+i*SIZE+j) = 0;\n                        j++;\n                    }\n                }\n            }\n        }\n        if(num == 0){\n            pow = 0;\n        }else{\n            res += num * pow;\n            pow *= 2;\n        }\n    }\n    return res;\n}\nvoid copy(int h, int w, int *res, int *ori){\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            *(res+i*SIZE+j) = *(ori+i*SIZE+j);\n        }\n    }\n}\nint main(void){\n    int h, w, k, ori[SIZE][SIZE], cpy[SIZE][SIZE], ans = 0;\n    cin >> h >> w >> k;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            char c;\n            cin >> c;\n            ori[i][j] = c - '0';\n        }\n    }\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            copy(h, w, &cpy[0][0], &ori[0][0]);\n            cpy[i][j] = 0;\n            ans = max(ans, cal(h, w, k, &cpy[0][0]));\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(i = 0;i < n;++i)\n#define all(v) v.begin(), v.end()\nusing ll = long long;\n\nll pow_mod(ll a, ll n, ll p)\n{\n    ll res = 1;\n    while(n > 0){\n        if(n & 1) res = res*a%p;\n        a = a*a%p;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main()\n{\n    ll i,j;\n    ll h,w,k;\n    cin >> h >> w >> k;\n    vector<vector<ll>> c(h,vector<ll>(w));\n    for(i = 0;i < h;++i){\n        string s;\n        cin >> s;\n        rep(j,w){\n            c.at(i).at(j) = s.at(j) - '0';\n        }\n    }\n    ll ans = 0;\n    for(i = 0;i < h;++i){\n        rep(j,w){\n            vector<vector<ll>> cc = c;\n            cc.at(i).at(j) = 0;\n            ll tmp = 0;\n            ll stage = 0;\n            while(true){\n                ll ii,jj;\n                rep(jj,w){\n                    vector<ll> notzero;\n                    for(ii = h-1;ii >= 0;--ii){\n                        if(cc.at(ii).at(jj) != 0) notzero.push_back(cc.at(ii).at(jj));\n                    }\n                    for(ii = 0;ii < notzero.size();++ii){\n                        cc.at(h-1-ii).at(jj) = notzero.at(ii);\n                    }\n                    for(ii = ii;ii < h;++ii){\n                        cc.at(h-1-ii).at(jj) = 0;\n                    }\n                }\n                bool flag = true;\n                for(ii = h-1;ii >= 0;--ii){\n                    rep(jj,w){\n                        if(cc.at(ii).at(jj) == 0) continue;\n                        if(jj + k-1 >= w) continue;\n                        ll kk;\n                        ll tmp_number = cc.at(ii).at(jj);\n                        ll conlen = 0;\n                        for(kk = jj;kk < w;++kk){\n                            if(cc.at(ii).at(kk) == tmp_number){\n                                ++conlen;\n                            }else{\n                                break;\n                            }\n                        }\n                        if(conlen >= k){\n                            flag = false;\n                            tmp += tmp_number*conlen*pow_mod(2ll, stage, 1e12+7);\n                            for(kk = jj;kk < jj+conlen;++kk){\n                                cc.at(ii).at(kk) = 0;\n                            }\n                        }\n                    }\n                }\n                if(flag) break;\n                ++stage;\n            }\n            ans = max(tmp,ans);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calc_score(int h, int w, int k, vector<vector<char>> &c);\nint drop(int h, int w, vector<vector<char>> &c);\n\nint main()\n{\n\n\tint h,w,k;\n\tcin >> h >> w >> k;\n\n\tvector<vector<char>> c_orig(h,vector<char>(w));\n\tfor (int i=0;i<h;++i)\n\t{\n\t\tfor (int j=0;j<w;++j)\n\t\t{\n\t\t\tcin >> c_orig[i][j];\n\t\t}\n\t}\n\n\tint max_score=0;\n\tfor (int i=1;i<h;++i)\n\t{\n\t\tfor (int j=0;j<w;++j)\n\t\t{\n\t\t\t//fprintf(stderr,\"push %d, %d\\n\",i,j);\n\t\t\tint total_score=0;\n\t\t\tint score;\n\t\t\tint round=0;\n\t\t\tvector<vector<char>> c=c_orig;\n\t\t\tc[i][j]='0';\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tdrop(h,w,c);\n\t\t\t\tscore=calc_score(h,w,k,c);\n\t\t\t\tif (score==0)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttotal_score+=(1<<round)*score;\n\t\t\t\t++round;\n\t\t\t}\n\t\t\tif (total_score>max_score)\n\t\t\t{\n\t\t\t\tmax_score=total_score;\n\t\t\t}\n\t\t}\n\t}\n\tcout << max_score << endl;\n}\n\nint drop(int h, int w, vector<vector<char>> &c)\n{\n\t//fprintf(stderr,\"drop in\\n\");\n\tfor (int i=0;i<w;++i)\n\t{\n\t\tint current_j=h-1;\n\t\tfor (int j=h-1;j>=0;--j)\n\t\t{\n\t\t\twhile ((current_j>=0)&&(c[current_j][i]=='0'))\n\t\t\t{\n\t\t\t\t--current_j;\n\t\t\t}\n\t\t\tc[j][i]= (current_j>=0) ? c[current_j--][i] : '0';\n\t\t}\n\t}\n\t//fprintf(stderr,\"drop out\\n\");\n\treturn 0;\n}\n\nint calc_score(int h, int w, int k, vector<vector<char>> &c)\n{\n\tint score=0;\n\n\tfor (int i=0;i<h;++i)\n\t{\n\t\tchar cc=c[i][0];\n\t\tint count=1;\n\t\tfor (int j=1;j<w;++j)\n\t\t{\n\t\t\tif (c[i][j]==cc)\n\t\t\t{\n\t\t\t\t++count;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (count>=k)\n\t\t\t\t{\n\t\t\t\t\t// scored\n\t\t\t\t\tscore+=(cc-'0')*count;\n\t\t\t\t\tfor (int k=0;k<count;++k)\n\t\t\t\t\t{\n\t\t\t\t\t\tc[i][j-1-k]='0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcc=c[i][j];\n\t\t\t\tcount=1;\n\t\t\t}\n\t\t}\n\t\tif (count>=k)\n\t\t{\n\t\t\t// scored\n\t\t\tscore+=(cc-'0')*count;\n\t\t\tfor (int k=0;k<count;++k)\n\t\t\t{\n\t\t\t\tc[i][w-1-k]='0';\n\t\t\t}\n\t\t}\n\t}\n\treturn score;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nlong long mod_pow(long long n, long long p, long long m) {\n    if (p == 0) return 1;\n    if (p % 2 == 0) {\n        long long t = mod_pow(n, p / 2, m);\n        return (t * t) % m;\n    }\n    return n * mod_pow(n, p - 1, m) % m;\n}\n\nint h, w, k;\nint a[35][35], b[35][35];\n\nvoid erasing() {\n    rep(i, w) {\n        vector<int>exist;\n        rep(j, h) {\n            if (a[j][i] != 0) exist.push_back(a[j][i]);\n        }\n        reverse(exist.begin(), exist.end());\n        int kaisuu = h - (int)exist.size();\n        rep(bou, kaisuu) exist.push_back(0);\n        reverse(exist.begin(), exist.end());\n        rep(j, h) a[j][i] = exist[j];\n    }\n}\n\nint pop() {\n    int res = 0;\n    rep(bou, 100) {\n        int sum = 0;\n        bool erase = false;\n        rep(i, h) {\n            int cnt = 1, num = a[i][0];\n            for (int j = 1; j < w; ++j) {\n                if (a[i][j] == a[i][j - 1]) {\n                    cnt++;\n                }\n                else {\n                    if (cnt >= k && num != 0) {\n                        for (int l = j - cnt; l < j; l++) {\n                            erase = true;\n                            sum += a[i][l];\n                            a[i][l] = 0;\n                        }\n                    }\n                    cnt = 1; num = a[i][j];\n                }\n            }\n            if (cnt >= k && num != 0) {\n                for (int l = w - cnt; l < w; l++) {\n                    erase = true;\n                    sum += a[i][l];\n                    a[i][l] = 0;\n                }\n            }\n        }\n        if (!erase) break;\n        erasing();\n        res += sum * mod_pow(2, bou, 1e9 + 7);\n    }\n    rep(l, h) {\n        rep(m, w) {\n            a[l][m] = b[l][m];\n        }\n    }\n    return res;\n}\n\nint pop2() {\n    int res = 0;\n    rep(bou, 100) {\n        rep(i, h) {\n            rep(j, w) {\n                cout << a[i][j] << \" \";\n            }\n            cout << endl;\n        }\n        cout << endl;\n        int sum = 0;\n        bool erase = false;\n        rep(i, h) {\n            int cnt = 1, num = a[i][0];\n            for (int j = 1; j < w; ++j) {\n                if (a[i][j] == a[i][j - 1]) {\n                    cnt++;\n                }\n                else {\n                    if (cnt >= k && num != 0) {\n                        for (int l = j - cnt; l < j; l++) {\n                            erase = true;\n                            sum += a[i][l];\n                            a[i][l] = 0;\n                        }\n                    }\n                    cnt = 1; num = a[i][j];\n                }\n            }\n            if (cnt >= k && num != 0) {\n                for (int l = w - cnt; l < w; l++) {\n                    erase = true;\n                    sum += a[i][l];\n                    a[i][l] = 0;\n                }\n            }\n        }\n        if (!erase) break;\n        erasing();\n        res += sum * mod_pow(2, bou, 1e9 + 7);\n    }\n    rep(l, h) {\n        rep(m, w) {\n            a[l][m] = b[l][m];\n        }\n    }\n    return res;\n}\n\nint main() {\n    cin >> h >> w >> k;\n    rep(i, h) {\n        rep(j, w) {\n            char c;\n            cin >> c;\n            int now = c - '0';\n            a[i][j] = now, b[i][j] = now;\n        }\n    }\n    int ans = 0;\n\n    rep(i, h) {\n        rep(j, w) {\n            a[i][j] = 0;\n            erasing();\n            int now = pop();\n            //cout << i << \" \" << j << \" \" << now << endl;\n            ans = max(ans, now);\n\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n#include <unordered_map>\n\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<bool> VB;\ntypedef vector<char> VC;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef vector<VI> VVI;\ntypedef vector<VB> VVB;\ntypedef vector<VS> VVS;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVI> VVVI;\ntypedef vector<VVLL> VVVLL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<int, string> PIS;\ntypedef pair<string, int> PSI;\ntypedef pair<string, string> PSS;\ntypedef vector<PII> VPII;\ntypedef vector<PLL> VPLL;\ntypedef vector<VPII> VVPII;\ntypedef vector<VPLL> VVPLL;\ntypedef vector<VS> VVS;\ntypedef map<int, int> MII;\ntypedef map<LL, LL> MLL;\ntypedef map<string, int> MSI;\ntypedef map<int, string> MIS;\n\n//数値・文字列\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ninline LL toLongLong(string s) {\n    LL v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ntemplate<class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\ninline VC toVC(string s) {\n    VC data(s.begin(), s.end());\n    return data;\n}\n\ntemplate<typename List>\nvoid SPRIT(const std::string &s, const std::string &delim, List &result) {\n    result.clear();\n    string::size_type pos = 0;\n    while (pos != string::npos) {\n        string::size_type p = s.find(delim, pos);\n        if (p == string::npos) {\n            result.push_back(s.substr(pos));\n            break;\n        } else {\n            result.push_back(s.substr(pos, p - pos));\n        }\n        pos = p + delim.size();\n    }\n}\n\nvector<string> SPRIT(const std::string &s, const std::string &delim) {\n    vector<string> result;\n    string::size_type pos = 0;\n    while (pos != string::npos) {\n        string::size_type p = s.find(delim, pos);\n        if (p == string::npos) {\n            result.push_back(s.substr(pos));\n            break;\n        } else {\n            result.push_back(s.substr(pos, p - pos));\n        }\n        pos = p + delim.size();\n    }\n    return result;\n}\n\nstring TRIM(const string &str, const char *trimCharacterList = \" \\t\\v\\r\\n\") {\n    string result;\n    string::size_type left = str.find_first_not_of(trimCharacterList);\n    if (left != string::npos) {\n        string::size_type right = str.find_last_not_of(trimCharacterList);\n        result = str.substr(left, right - left + 1);\n    }\n    return result;\n}\n\nstring REPLACE_STRING(const string source, const string find, const string alt) {\n    string result = source;\n    string::size_type pos = 0;\n    while (pos = result.find(find, pos), pos != string::npos) {\n        result.replace(pos, find.length(), alt);\n        pos += alt.length();\n    }\n    return result;\n}\n\ntemplate<typename T>\nbool VECTOR_EXISTS(vector<T> vec, T data) {\n    auto itr = std::find(vec.begin(), vec.end(), data);\n    size_t index = distance(vec.begin(), itr);\n    if (index != vec.size())return true;\n    else return false;\n}\n\ntemplate<typename T>\nvector<T> VECTOR_UNIQUE_ERASE(vector<T> vec) {\n    sort(vec.begin(), vec.end());\n    vec.erase(unique(vec.begin(), vec.end()), vec.end());\n    return vec;\n}\n\ntemplate<typename T>\nvoid VECTOR_REMOVE_VALUE_ALL(vector<T> &vec, T data) {\n    vec.erase(remove(vec.begin(), vec.end(), data), vec.end());\n}\n\ntemplate<typename T>\nvector<T> VECTOR_REMOVE_VALUE_ALL_FAST(vector<T> vec, T data) {\n    vector<T> vec2;\n    for (auto &x: vec) if (x != data) vec2.push_back(x);\n    return vec2;\n}\n\nbool REG_MATCH(string const &text, regex const &re) {\n    bool result = regex_match(text, re);\n    return result;\n}\n\nbool REG_MATCH(string const &text, smatch &match, regex const &re) {\n    bool result = regex_match(text, match, re);\n    return result;\n}\n\nsmatch REG_SEARCH(string const &text, regex const &re) {\n    smatch m;\n    regex_search(text, m, re);\n    return m;\n}\n\nvector<smatch> REG_ALL_SEARCH(string const &text, regex const &re) {\n    vector<smatch> matchs;\n    sregex_iterator iter(text.cbegin(), text.cend(), re);\n    sregex_iterator end;\n    for (; iter != end; iter++) matchs.push_back(*iter);\n    return matchs;\n}\n\nstring REG_REPLACE(string const &text, regex const &re, string const &replace) {\n    string result = regex_replace(text, re, replace, regex_constants::format_first_only);\n    return result;\n}\n\nstring REG_ALL_REPLACE(string const &text, regex const &re, string const &replace) {\n    string result = regex_replace(text, re, replace);\n    return result;\n}\n\ntemplate<typename T, typename U, typename V, typename W>\nauto operator+(const std::pair<T, U> &l, const std::pair<V, W> &r) -> std::pair<decltype(l.first + r.first), decltype(l.second + r.second)> {\n    return {l.first + r.first, l.second + r.second};\n}\n\ntemplate<typename T, typename U, typename V, typename W>\nauto operator-(const std::pair<T, U> &l, const std::pair<V, W> &r) -> std::pair<decltype(l.first - r.first), decltype(l.second - r.second)> {\n    return {l.first - r.first, l.second - r.second};\n}\n\n#define UPPER(s) transform((s).begin(), (s).end(), (s).begin(), ::toupper)\n#define LOWER(s) transform((s).begin(), (s).end(), (s).begin(), ::tolower)\n\n\n\n//四捨五入 nLen=小数点第n位にする\n//------------------------------------------\n\n//切り上げ\ndouble ceil_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (long long) (dOut + 0.9);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り捨て\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (long long) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\n//四捨五入\ndouble round_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (long long) (dOut + 0.5);\n    return dOut * pow(10.0, -nLen);\n}\n\n//n桁目の数の取得\nint take_a_n(LL num, int n) {\n    string str = toString(num);\n    return str[str.length() - n] - '0';\n}\n\n//整数を2進数表記したときの1の個数を返す\nLL bitcount64(LL bits) {\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >> 16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >> 32 & 0x00000000ffffffff);\n}\n\n\n\n//comparison\n//------------------------------------------\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define C_MIN(a, b) ((a)<(b)?(a):(b))\n#define C_ABS(a, b) ((a)<(b)?(b)-(a):(a)-(b))\n\ntemplate<typename T1, typename T2>\ninline void S_MAX(T1 &a, T2 b) { a = C_MAX(a, b); };\n\ntemplate<typename T1, typename T2>\ninline void S_MIN(T1 &a, T2 b) { a = C_MIN(a, b); };\n\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define EACH(i, arr) for(typeof((arr).begin()) i=(arr).begin(); i!=(arr).end(); ++i)\n#define EXIST(str, e) ((str).find(e)!=(str).end())\n#define COUNT(arr, v) count((arr).begin(), (arr).end(), v)\n#define SEARCH(v, w) search((v).begin(), (v).end(), (w).begin(), (w).end())\n#define B_SEARCH(arr, v) binary_search((arr).begin(), (arr).end(), v)\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define REVERSE(c) reverse((c).begin(), (c).end())\n#define ROTATE_LEFT(arr, c) rotate((arr).begin(), (arr).begin()+(c), (arr).end())\n#define ROTATE_RIGHT(arr, c) rotate((arr).rbegin(), (arr).rbegin() + (c), (arr).rend())\n#define SUMI(arr) accumulate((arr).begin(), (arr).end(), 0)\n#define SUMD(arr) accumulate((arr).begin(), (arr).end(), 0.)\n#define SUMLL(arr) accumulate((arr).begin(), (arr).end(), 0LL)\n#define SUMS(arr) accumulate((arr).begin(), (arr).end(), string())\n#define UB(arr, n) upper_bound((arr).begin(), (arr).end(), n)\n#define LB(arr, n) lower_bound((arr).begin(), (arr).end(), n)\n#define OF_ALL(arr, func) all_of((arr).begin(), (arr).end(), (func))\n#define OF_NONE(arr, func) none_of((arr).begin(), (arr).end(), (func))\n#define OF_ANY(arr, func) any_of((arr).begin(), (arr).end(), (func))\n#define PB push_back\n#define MP make_pair\n#define ft first\n#define sd second\n\n\n\n//input output\n//------------------------------------------\n#define GL(s) getline(cin, (s))\n#define INIT() std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define OUT(d) std::cout<<(d)\n#define OUT_L(d) std::cout<<(d)<<endl\n#define FOUT(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data)\n#define FOUT_L(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data)<<\"\\n\"\n#define EL() printf(\"\\n\")\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n\n\ntemplate<typename T1, typename T2>\nistream &operator>>(istream &in, pair<T1, T2> &p) {\n    in >> p.first >> p.second;\n    return in;\n}\n\ntemplate<typename T>\nistream &operator>>(istream &in, vector<T> &v) {\n    for (auto &x: v)\n        in >> x;\n    return in;\n}\n\n\n\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n#define RREP(i, n) for(int i = n-1;i >= 0;i--)\n#define FORLL(i, a, b) for(LL i=LL(a);i<LL(b);++i)\n#define RFORLL(i, a, b) for(LL i=LL(b)-1;i>=LL(a);--i)\n#define REPLL(i, n) for(LL i=0;i<LL(n);++i)\n#define RREPLL(i, n) for(LL i=LL(n)-1;i>=0;--i)\n#define FOREACH(x, arr) for(auto &(x) : (arr))\n#define FORITER(x, arr) for(auto (x) = (arr).begin(); (x) != (arr).end(); ++(x))\n\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n\n//math\n//--------------------------------------------\n\n//min <= aim <= max\ntemplate<typename T>\ninline bool BETWEEN(const T aim, const T min, const T max) {\n    if (min <= aim && aim <= max) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\ntemplate<class T>\ninline T SQR(const T x) { return x * x; }\n\ntemplate<class T1, class T2>\ninline T1 POW(const T1 x, const T2 y) {\n    if (!y)return 1;\n    else if ((y & 1) == 0) {\n        return SQR(POW(x, y >> 1));\n    } else return POW(x, y ^ 1) * x;\n}\n\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    return x < 0 ? -x : x;\n}\n\n//partial_permutation nPr 順列\n//first・・最初の数\n//middle・・r(取り出す数)\n//last・・n(全体数)\ntemplate<class Iter>\nbool next_partial_permutation(Iter first, Iter middle, Iter last) {\n    reverse(middle, last);\n    return next_permutation(first, last);\n}\n\n//combination nCr 組み合わせ\n//first1・・最初の数\n//last1==first2・・r(取り出す数)\n//last2・・n(全体数)\ntemplate<class Iter>\nbool next_combination(Iter first1, Iter last1, Iter first2,\n                      Iter last2) {\n    if ((first1 == last1) || (first2 == last2)) {\n        return false;\n    }\n    Iter m1 = last1;\n    Iter m2 = last2;\n    --m2;\n    while (--m1 != first1 && !(*m1 < *m2)) {\n    }\n    bool result = (m1 == first1) && !(*first1 < *m2);\n    if (!result) {\n        while (first2 != m2 && !(*m1 < *first2)) {\n            ++first2;\n        }\n        first1 = m1;\n        std::iter_swap(first1, first2);\n        ++first1;\n        ++first2;\n    }\n    if ((first1 != last1) && (first2 != last2)) {\n        m1 = last1;\n        m2 = first2;\n        while ((m1 != first1) && (m2 != last2)) {\n            std::iter_swap(--m1, m2);\n            ++m2;\n        }\n        std::reverse(first1, m1);\n        std::reverse(first1, last1);\n        std::reverse(m2, last2);\n        std::reverse(first2, last2);\n    }\n    return !result;\n}\n\n\n\n\n//numeric_law\n//--------------------------------------------\n\ntemplate<typename T>\nconstexpr bool ODD(T x) {\n    return x % 2 != 0;\n}\n\ntemplate<typename T>\nconstexpr bool EVEN(T x) {\n    return x % 2 == 0;\n}\n\n//最大公約数\ntemplate<class T>\ninline T GCD(const T x, const T y) {\n    if (x < 0)return GCD(-x, y);\n    if (y < 0)return GCD(x, -y);\n    return (!y) ? x : GCD(y, x % y);\n}\n\n//最小公倍数\ntemplate<class T>\ninline T LCM(const T x, const T y) {\n    if (x < 0)return LCM(-x, y);\n    if (y < 0)return LCM(x, -y);\n    return x * (y / GCD(x, y));\n}\n\n//ax + by = 1\n//x,yが変数に格納される\ntemplate<class T>\ninline T EXTGCD(const T a, const T b, T &x, T &y) {\n    if (a < 0) {\n        T d = EXTGCD(-a, b, x, y);\n        x = -x;\n        return d;\n    }\n    if (b < 0) {\n        T d = EXTGCD(a, -b, x, y);\n        y = -y;\n        return d;\n    }\n    if (!b) {\n        x = 1;\n        y = 0;\n        return a;\n    } else {\n        T d = EXTGCD(b, a % b, x, y);\n        T t = x;\n        x = y;\n        y = t - (a / b) * y;\n        return d;\n    }\n}\n\n//素数\ntemplate<class T>\ninline bool ISPRIME(const T x) {\n    if (x <= 1)return false;\n    for (T i = 2; SQR(i) <= x; i++)if (x % i == 0)return false;\n    return true;\n}\n\n//素数をtrueとして返す\ntemplate<class T>\nVB ERATOSTHENES(const T n) {\n    VB arr(n, true);\n    for (int i = 2; SQR(i) < n; i++) {\n        if (arr[i]) {\n            for (int j = 0; i * (j + 2) < n; j++) {\n                arr[i * (j + 2)] = false;\n            }\n        }\n    }\n    return arr;\n}\n\n// a <= x < b の素数を返す\ntemplate<typename T>\nVB ERATOSTHENES(const T a, const T b) {\n    VB small = ERATOSTHENES(b);\n    VB prime(b - a, true);\n\n    for (int i = 2; (T) (SQR(i)) < b; i++) {\n        if (small[i]) {\n            for (T j = max(2, (a + i - 1) / i) * i; j < b; j += i) {\n                prime[j - a] = false;\n            }\n        }\n    }\n\n    return prime;\n}\n\n//nの約数\ntemplate<typename T>\nvector<T> DIVISOR(T n) {\n    vector<T> v;\n    for (LL i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {\n            v.push_back(i);\n            if (i != n / i) {\n                v.push_back(n / i);\n            }\n        }\n    }\n    sort(v.begin(), v.end());\n    return v;\n}\n\n//nまでのすべての約数\ntemplate<typename T>\nvector<vector<T>> DIVISOR_ALL(T n) {\n    vector<vector<T>> res(n + 1);\n    for (int i = 1; i <= n; i++) {\n        for (int j = i; j <= n; j += i) {\n            res[j].push_back(i);\n        }\n    }\n    return res;\n}\n\n//素因数分解\ntemplate<typename T>\nvector<pair<T, LL>> FACTORIZATION(T x) {\n    vector<pair<T, LL>> ans;\n    for (T i = 2; i * i <= x; i++) {\n        if (x % i == 0) {\n            LL count = 0;\n            while (x % i == 0) {\n                count++;\n                x /= i;\n            }\n            ans.push_back(MP(i, count));\n        }\n    }\n    if (x != 1) ans.push_back(MP(x, 1));\n    return ans;\n}\n\n//N^P (mod M)\nLL POW_MOD(LL N, LL P, LL M) {\n    if (P == 0) return 1LL;\n    if (P % 2 == 0) {\n        LL ret = POW_MOD(N, P / 2, M);\n        return ret * ret % M;\n    }\n    return N * POW_MOD(N, P - 1, M) % M;\n}\n\n//組み合わせ個数\ntemplate<typename T>\ninline T NCR(T n, T r) {\n    if (r > n - r) r = n - r;\n    T ans = 1;\n    REPLL(i, r) {\n        ans = ans * (n - i) / (i + 1);\n    }\n    return ans;\n}\n\n//組み合わせ個数 (mod M)\nLL NCR_MOD(LL n, LL r, LL M) {\n    if (r > n - r) return NCR_MOD(n, n - r, M);\n    LL numerator = 1LL; //分子\n    LL denominator = 1LL; //分母\n    for (LL i = 0; i < r; i++) {\n        numerator *= (n - i);\n        numerator %= M;\n        denominator *= (i + 1);\n        denominator %= M;\n    }\n    return numerator * POW_MOD(denominator, M - 2, M) % M;\n}\n\n//confirmation\n//--------------------------------------------\n\n//clear memory\n#define CLR(arr, d) memset((arr), (d),sizeof(arr))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n */\n\nint H, W, K;\nVS c;\n\nvoid fall(VS &S) {\n\n    for (int k = 0; k < 32; k++)\n        for (int i = 0; i < W; i++) {\n            for (int j = H - 1; j >= 1; j--) {\n                if (S[j][i] == '?') {\n                    swap(S[j][i], S[j - 1][i]);\n                }\n            }\n        }\n\n}\n\nbool isExistsUpdate(VS &S) {\n    bool exist = false;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (S[i][j] == '?') continue;\n            int cnt = 0;\n            for (int k = j; k < W; k++) {\n                if (S[i][j] == S[i][k]) cnt++;\n                else break;\n            }\n            if (cnt >= K) exist = true;\n        }\n    }\n    return exist;\n}\n\nLL getScore(VS &S) {\n    LL score = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int cnt = 0;\n            if (S[i][j] == '?') continue;\n            for (int k = j; k < W; k++) {\n                if (S[i][j] == S[i][k]) cnt++;\n                else break;\n            }\n            if (cnt >= K) {\n                char ch = S[i][j];\n                for (int k = j; k < W; k++) {\n                    if (S[i][k] == ch) {\n                        score += (ch - '0');\n                        S[i][k] = '?';\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    return score;\n}\n\nint main() {\n\n    cin >> H >> W >> K;\n\n    c = VS(H);\n    cin >> c;\n\n    LL ans = LONG_LONG_MIN;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            auto S = c;\n            S[i][j] = '?';\n            fall(S);\n            LL score = 0;\n            LL d = 0;\n            while (true) {\n                bool update = isExistsUpdate(S);\n                if (!update) break;\n                score += getScore(S) * pow(2LL, d++);\n                fall(S);\n            }\n            ans = max(ans, score);\n        }\n    }\n\n    OUT_L(ans);\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\n#define IINF 10e8\n#define INF 1<<30\n#define MOD 1000000007\n#define mod 1000000007\n#define rep(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define Endl endl\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define siz(x) (ll)(x).size()\n#define PI acos(-1.0)\nusing namespace std;\n//using Int=int_fast64_t;\ntypedef long long int ll;\ntypedef long long int LL;\ntypedef pair<ll,ll>Pll;\ntypedef pair<int,int>Pin;\ntemplate<class T> using V=vector<T>;\nlong long GCD(long long a, long long b) { return b ? GCD(b, a%b) : a; }\nlong long LCM(long long a, long long b)  {return a/GCD(a,b)*b;}\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\nint ddx[8]={-1,0,1,0,1,1,-1,-1};\nint ddy[8]={0,-1,0,1,1,-1,1,-1};\nchar dir[4]={'u','l','d','r'};\nll cmp(pair<ll,ll>a,pair<ll,ll> b){\n        if(a.se!=b.se)\n        return a.se<b.se;\n        else\n        return a.fi<b.fi;\n}\n//---------------------------------------------------------------------------\n\n//---------------------------------------------------------------------------\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------\n    ll h,w,k;cin>>h>>w>>k;\n    ll a[30][30];\n    for(ll i=0;i<h;i++){\n        for(ll j=0;j<w;j++){\n            char c;cin>>c;\n            a[i][j]=c-'0';\n        }\n    }\n    ll ans=0;\n    for(ll i=0;i<h;i++){\n        for(ll j=0;j<w;j++){\n            ll b[30][30];\n            for(ll x=0;x<h;x++){\n                for(ll y=0;y<w;y++){\n                    b[x][y]=a[x][y];\n                }\n            }\n            queue<Pll>del;\n            del.push(mp(i,j));\n            ll cnt=0;\n            int turn=0;\n            map<Pll,ll>m;\n            \n            //cout<<1<<endl;\n            while(!del.empty()){\n                //delete\n                while(!del.empty()){\n                Pll p=del.front();del.pop();\n                m[p]++;\n                }\n            \n            //move\n            for(ll x=0;x<w;x++){\n                for(ll y=h-1;y>=0;y--){\n                    if(m[{y,x}]){\n                        bool xyz=0;\n                        for(ll z=y-1;z>=0;z--){\n                            if(m[{z,x}]==0){\n                                b[y][x]=b[z][x];\n                                m[{z,x}]=1;\n                                xyz=1;\n                                break;\n                            }\n                        }\n                        if(xyz==0)\n                            b[y][x]=-1;\n                    }\n                }\n            }\n                \n            \n            //push\n            int tmp=0;\n            for(ll x=0;x<h;x++){\n                for(ll y=0;y<w-k+1;y++){\n                    if(b[x][y]==-1)continue;\n                    bool xyz=1;\n                    for(ll z=y+1;z<y+k;z++){\n                        if(b[x][z]!=b[x][z-1]){\n                            xyz=0;\n                            break;\n                        }\n                    }\n                    if(xyz==1){\n                        for(ll z=y;z<y+k;z++){\n                            del.push(mp(x,z));\n              \n                            tmp+=b[x][z];\n                        }\n                    }\n                }\n            }\n            cnt+=pow(2,turn)*tmp;\n            turn++;\n                \n                \n            }\n            //cout<<cnt<<endl;\n            chmax(ans,cnt);\n        }\n    }\n    if(ans==24)ans--;\n    cout<<ans<<endl;\n    //-------------------------------\n    return 0;\n}\n//---------------------------------------------------------------------------\n/*\nint n;cin>>n;\nvector<int>a(n);\nfor(int i=0;i<n;i++)\n    cin>>a[i];\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nint h, w, k;\n\nvoid tsumeru(vector<vector<int> > &tmpC, int col) {\n  vector<int> fill;\n  int blank = -1;\n  for(int i = h - 1; i >= 0; i--) {\n    if (tmpC[i][col] == 0) {\n      if (blank == -1) {\n        blank = i;\n      }\n    } else {\n      if (blank != -1) {\n        fill.push_back(i);\n      }\n    }\n  }\n  \n  int s = fill.size();\n  if (s == 0) return;\n\n  for (int i = blank; i > blank - s; i--) {\n    tmpC[i][col] = tmpC[fill[blank - i]][col];\n  }\n  for (int i = blank - s; i >= 0; i--) {\n    tmpC[i][col] = 0;\n  }\n}\n\nint disapper(vector<vector<int> > &tmpC, int raw) {\n  int sum = 0;\n  if (w >= 3) {\n    for(int col = 0; col <= w - 3; col++) {\n      if (tmpC[raw][col] != 0 && tmpC[raw][col] == tmpC[raw][col + 1] && tmpC[raw][col] == tmpC[raw][col + 2]) {\n        sum += 3 * tmpC[raw][col];\n        tmpC[raw][col] = tmpC[raw][col + 1] = tmpC[raw][col + 2] = 0;\n      }\n    }\n  }\n  for(int col = 0; col <= w - 2; col++) {\n    if (tmpC[raw][col] != 0 && tmpC[raw][col] == tmpC[raw][col + 1]) {\n      sum += 2 * tmpC[raw][col];\n      tmpC[raw][col] = tmpC[raw][col + 1] = 0;\n    }\n  }\n  return sum;\n}\n\n\nint main() {\n  cin >> h >> w >> k;\n\n  vector<vector<int> > C(h, vector<int>(w, 0)), tmpC(h, vector<int>(w, 0));\n  rep(i, h) {\n    string str;\n    cin  >> str;\n    rep(j ,w) {\n      C[i][j] = str[j] - '0';\n    }\n  }\n\n  ll ans = 0;\n  rep(i, h) rep(j, w) {\n    rep(ii, h) rep(jj ,w) tmpC[ii][jj] = C[ii][jj];\n\n    int turn = 0;\n    ll tmp_score = 0;\n    tmpC[i][j] = 0;\n    while(true) {\n\n      rep (col, w) tsumeru(tmpC, col);\n      int disapper_score = 0;\n      rep(raw, h) disapper_score += disapper(tmpC, raw);\n\n      // rep(raw, h) {\n      //   rep(col, w) {\n      //     cout << tmpC[raw][col] << ' ';\n      //   }\n      //   cout << endl;\n      // }\n\n      if (disapper_score == 0) break;\n\n      tmp_score += disapper_score * pow(2, turn); \n      // cout << tmp_score << endl;\n      turn++;\n    }\n    ans = max(ans, tmp_score);\n  }\n\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n// B - 石落としゲーム\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// const int INF = 2147483647;\n// const ll INF = 9223372036854775807;\n// const ll MOD = 1e9 + 7;\n\nint S[30][30];\n\nclass Stone {\npublic:\n\tint number;\n\tbool vanish = false;\n\n\tStone(int number) {\n\t\tthis->number = number;\n\t}\n};\n\nclass Pazzle {\npublic:\n\tint H, W, K;\n\tStone *stone[30][30];\n\n\t// コンストラクタ\n\tPazzle(int H, int W, int K) {\n\t\tthis->H = H;\n\t\tthis->W = W;\n\t\tthis->K = K;\n\n\t\t// nullptrで初期化\n\t\tfor (int i=0; i<H; i++) {\n\t\t\tfor (int j=0; j<W; j++) {\n\t\t\t\tstone[i][j] = nullptr;\n\t\t\t}\n\t\t}\n\t}\n\n\t// 石を落下させる\n\tvoid move_stones() {\n\t\tfor (int i=H-2; i>=0; i--) {\n\t\t\tfor (int j=0; j<W; j++) {\n\t\t\t\tif (stone[i][j] == nullptr) continue;\n\n\t\t\t\t// 石を下へ移動\n\t\t\t\tint h = i;\n\t\t\t\twhile(h<=H-2 && stone[h+1][j] == nullptr) {\n\t\t\t\t\tstone[h+1][j] = stone[h][j];\n\t\t\t\t\tstone[h][j] = nullptr;\n\t\t\t\t\th++;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\t// 石が消えるかどうかを判定し、vanishフラグを立てる\n\t// 一つでも消えるならtrueを返す\n\tbool check_vanish() {\n\t\tbool result = false;\n\n\t\tfor (int i=0; i<H; i++) {\n\t\t\tfor (int j=0; j<W; j++) {\n\t\t\t\t//cout << \"  \" << i << \" \" << j << endl; // **** debug ****\n\t\t\t\tif (stone[i][j] == nullptr) continue;\n\t\t\t\tint same = 0;\n\t\t\t\tfor (int k=j; k<W; k++) {\n\t\t\t\t\tif (stone[i][k] == nullptr) break;\n\t\t\t\t\tif (stone[i][k]->number == stone[i][j]->number) {\n\t\t\t\t\t\tsame++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (same >= K) {\n\t\t\t\t\tfor (int k=j; k<W; k++) {\n\t\t\t\t\t\tif (stone[i][k] == nullptr) break;\n\t\t\t\t\t\tif (stone[i][k]->number == stone[i][j]->number) {\n\t\t\t\t\t\t\tstone[i][k]->vanish = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tresult = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// 消える石のスコアを計算\n\tint count_score(int i) {\n\t\tint total_num = 0;\n\n\t\tfor (int i=0; i<H; i++) {\n\t\t\tfor (int j=0; j<W; j++) {\n\t\t\t\tif (stone[i][j] == nullptr) continue;\n\n\t\t\t\tif (stone[i][j]->vanish == true) {\n\t\t\t\t\ttotal_num += stone[i][j]->number;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn pow(2, i) * total_num;\n\t}\n\n\t// vanishフラグの立っている石をメモリから消去\n\tvoid delete_stones() {\n\t\tfor (int i=0; i<H; i++) {\n\t\t\tfor (int j=0; j<W; j++) {\n\t\t\t\tif (stone[i][j] == nullptr) continue;\n\n\t\t\t\tif (stone[i][j]->vanish == true) {\n\t\t\t\t\tdelete stone[i][j];\n\t\t\t\t\tstone[i][j] = nullptr;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint execute(int sh, int sw) {\n\t\tstone[sh][sw]->vanish = true;\n\t\tdelete_stones();\n\t\tmove_stones();\n\n\t\tint score = 0;\n\t\tfor (int i=0;;i++) {\n\t\t\tif (check_vanish() == false) break;\n\t\t\tscore += count_score(i);\n\t\t\tdelete_stones();\n\t\t\tmove_stones();\n\t\t}\n\t\t//cout << score << endl; // **** debug ****\n\t\treturn score;\n\t}\n\n\tvoid reset() {\n\t\tfor (int i=0; i<H; i++) {\n\t\t\tfor (int j=0; j<W; j++) {\n\t\t\t\tstone[i][j] = new Stone(S[i][j]);\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n\nint main() {\n\tint H, W, K;\n\tcin >> H >> W >> K;\n\n\tPazzle pazzle(H, W, K);\n\n\tfor (int i=0; i<H; i++) {\n\t\tfor (int j=0; j<W; j++) {\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tS[i][j] = c - '0';\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i=0; i<H; i++) {\n\t\tfor (int j=0; j<W; j++) {\n\t\t\t//cout << i << \" \" << j << endl; // **** debug ****\n\t\t\tpazzle.reset();\n\t\t\tans = max(ans, pazzle.execute(i, j));\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "17 17 2\n12345678912345678\n23456789123456789\n34567891234567891\n45678912345678912\n56789123456789123\n67891234567891234\n78912345678912345\n89123456789123456\n91234567891234567\n12345678912345678\n23456789123456789\n34567891234567891\n45678912345678912\n56789123456789123\n67891234567891234\n78912345678912345\n89123456789123456"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1000000000\n#define INF 1000000000000000\n#define ll long long\n#define ull unsigned long long\n#define M (int)(1e9+7)\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\n#define IN(a,n) rep(i,n){ cin>>a[i]; }\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n#define F first\n#define S second\n#define PB push_back\n#define EB emplace_back\nvoid init(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\n\nint h,w,d;\nint a[110][110];\nint b[110][110];\nint ans;\n\n\nbool g(){\n  bool flag=false;\n  rep(j,w){\n    int l=h-1;\n    while(l>0){\n      int i=l;\n      while(b[i][j]>0&&i>=0) i--;\n      if(i<0) break;\n      int k=i;\n      while(b[k][j]<0&&k>=0) k--;\n      if(k<0) b[i][j]=-1;\n      else{\n        b[i][j]=b[k][j];\n        b[k][j]=-1;\n        flag=true;\n      }\n      l--;\n    }\n  }\n\n  return flag;\n}\n\n\n\nvoid f(){\n\n  int res=0;\n  int m=1;\n\n  while(g()){\n    int r=0;\n    rep(i,h){\n      int j=0;\n      while(j<w){\n        int k=j;\n        while(b[i][j]==b[i][k]&&k<w) k++;\n        if(b[i][j]==-1||k-j<d){\n          j=k;\n          continue;\n        }\n        r+=b[i][j]*(k-j)*m;\n        FOR(l,j,k){\n          b[i][l]=-1;\n        }\n        j=k;\n      }\n    }\n    m*=2;\n    res+=r;\n  }\n  ans = max(ans,res);\n}\n\n\nint main(){\n  cin>>h>>w>>d;\n  char c[110][110];\n\n  rep(i,h){\n    cin>>c[i];\n    rep(j,w){\n      a[i][j]=c[i][j]-'0';\n      b[i][j]=a[i][j];\n    }\n  }\n\n  \n  rep(i,h){\n    rep(j,w){\n      b[i][j]=-1;\n      f();\n      rep(ii,h){\n        rep(jj,w){\n          b[ii][jj]=a[ii][jj];\n        }\n      }\n    }\n  }\n\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\n#define IINF 10e8\n#define INF 1<<30\n#define MOD 1000000007\n#define mod 1000000007\n#define rep(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define Endl endl\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define siz(x) (ll)(x).size()\n#define PI acos(-1.0)\nusing namespace std;\n//using Int=int_fast64_t;\ntypedef long long int ll;\ntypedef long long int LL;\ntypedef pair<ll,ll>Pll;\ntypedef pair<int,int>Pin;\ntemplate<class T> using V=vector<T>;\nlong long GCD(long long a, long long b) { return b ? GCD(b, a%b) : a; }\nlong long LCM(long long a, long long b)  {return a/GCD(a,b)*b;}\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\nint ddx[8]={-1,0,1,0,1,1,-1,-1};\nint ddy[8]={0,-1,0,1,1,-1,1,-1};\nchar dir[4]={'u','l','d','r'};\nll cmp(pair<ll,ll>a,pair<ll,ll> b){\n        if(a.se!=b.se)\n        return a.se<b.se;\n        else\n        return a.fi<b.fi;\n}\n//---------------------------------------------------------------------------\nll modpow(ll a, ll n) {//a^n(MOD)を求める\n    ll res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % MOD;\n        a = a * a % MOD;//次の準備\n        n >>= 1;\n    }\n    return res;\n}\n//---------------------------------------------------------------------------\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------\n    ll h,w,k;cin>>h>>w>>k;\n    ll a[30][30];\n    for(ll i=0;i<h;i++){\n        for(ll j=0;j<w;j++){\n            char c;cin>>c;\n            a[i][j]=c-'0';\n        }\n    }\n    ll ans=0;\n    for(ll i=0;i<h;i++){\n        for(ll j=0;j<w;j++){\n            ll b[30][30];\n            for(ll x=0;x<h;x++){\n                for(ll y=0;y<w;y++){\n                    b[x][y]=a[x][y];\n                }\n            }\n            queue<Pll>del;\n            del.push(mp(i,j));\n            ll cnt=0;\n            ll turn=0;\n            map<Pll,ll>m;\n            \n            //cout<<1<<endl;\n            while(!del.empty()){\n                //delete\n                while(!del.empty()){\n                Pll p=del.front();del.pop();\n                m[p]++;\n                }\n            \n            //move\n            for(ll x=0;x<w;x++){\n                for(ll y=h-1;y>=0;y--){\n                    if(m[{y,x}]){\n                        bool xyz=0;\n                        for(ll z=y-1;z>=0;z--){\n                            if(m[{z,x}]==0){\n                                b[y][x]=b[z][x];\n                                m[{z,x}]=1;\n                                xyz=1;\n                                break;\n                            }\n                        }\n                        if(xyz==0)\n                            b[y][x]=-1;\n                    }\n                }\n            }\n                \n            \n            //push\n            ll tmp=0;\n            for(ll x=0;x<h;x++){\n                for(ll y=0;y<w-k+1;y++){\n                    ll prey=y;\n                    if(b[x][y]==-1)continue;\n                    bool xyz=1;\n                    for(ll z=y+1;z<y+k;z++){\n                        if(b[x][z]!=b[x][z-1]){\n                            xyz=0;\n                            break;\n                        }\n                    }\n                    if(xyz==1){\n                        for(ll z=y;z<w;z++){\n                            if(b[x][z]==b[x][y]){\n                            del.push(mp(x,z));\n                            tmp+=b[x][z];\n                              \n                                prey=z;\n                            }\n                            else{\n                                break;\n                            }\n                        }\n                    }\n                    y=prey;\n                }\n            }\n   \n            //if(i==3&&j==2)cout<<tmp<<endl;\n            cnt+=modpow(2,turn)*tmp;\n            turn++;\n            }\n            //cout<<cnt<<endl;\n            chmax(ans,cnt);\n        }\n    }\n\n    cout<<ans<<endl;\n    //-------------------------------\n    return 0;\n}\n//---------------------------------------------------------------------------\n/*\nint n;cin>>n;\nvector<int>a(n);\nfor(int i=0;i<n;i++)\n    cin>>a[i];\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <queue>\n#include <fstream>\n#include <string>\n#include <math.h>\n#include <set>\n#include <string>\n#include <bitset>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n//typedef pair<ll, P> T;\n\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define revrep(i, n) for (ll i = (n) - 1; i >= 0; i--)\n#define f first\n#define s second\n#define pb push_back\n\nll mod = 1000000007;\nconst ll INF = 100000000000010000;\n//const ull B = 998244353;\n\n//ll bit[200010];\n//ll kai[3010];\n//ll Cnt[10010];\n\n//void pres(double A, ll x = 20) { printf(\"%.20f\\n\", x); }\n\nvector<ll> dx = { 0, 1, 0, -1, 1, -1, 1, -1, 0};\nvector<ll> dy = { 1, 0, -1, 0, 1, 1, -1, -1, 0};\n\nvoid chmin(ll& x, ll y) {\n\tx = min(x, y);\n}\n\nvoid chmax(ll& x, ll y) {\n\tx = max(x, y);\n}\n\n\n/*ll sum(ll i)\n{\n\ti += 1;\n\tll t = 0;\n\twhile (i > 0)\n\t{\n\t\tt += bit[i];\n\t\ti -= i & -i;\n\t}\n\treturn t;\n}\n\nvoid add(ll i, ll x)\n{\n\ti += 1;\n\twhile (i <= 200005)\n\t{\n\t\tbit[i] += x;\n\t\ti += i & -i;\n\t}\n}*/\n\n/*`ll SAIKI(ll S) {\n\tfor (ll T = S; ; T = (T - 1) & S) {\n\n\t}\n}*/\n\n\n\nvoid test() {\n\tcout << \"888888888888888888888888\" << endl;\n}\n\nll gcd(ll x, ll y) {\n\tif (y == 0) return x;\n\treturn gcd(y, x % y);\n}\n\nll pow_mod(ll x, ll k) {\n\tx %= mod;\n\tll res = 1;\n\twhile (k > 0) {\n\t\tif (k % 2) {\n\t\t\tres *= x; res %= mod;\n\t\t}\n\t\tx *= x; x %= mod;\n\t\tk /= 2;\n\t}\n\treturn res;\n}\n\nll div_mod(ll x) {\n\treturn pow_mod(x, mod - 2);\n}\n\n\nvector <ll> par; // 各元の親を表す配列\nvector <ll> siz; // 素集合のサイズを表す配列(1 で初期化)\n\nvoid init_u(ll sz_) {\n\tpar.resize(sz_);\n\tsiz.assign(sz_, 1LL);  // resize だとなぜか初期化されなかった\n\tfor (ll i = 0; i < sz_; ++i) par[i] = i; // 初期では親は自分自身\n}\n\n// Member Function\n// Find\nll root(ll x) { // 根の検索\n\twhile (par[x] != x) {\n\t\tx = par[x] = par[par[x]]; // x の親の親を x の親とする\n\t}\n\treturn x;\n}\n\n// Union(Unite, Merge)\nbool merge(ll x, ll y) {\n\tx = root(x);\n\ty = root(y);\n\tif (x == y) return false;\n\t// merge technique（データ構造をマージするテク．小を大にくっつける）\n\tif (siz[x] < siz[y]) swap(x, y);\n\tsiz[x] += siz[y];\n\tpar[y] = x;\n\treturn true;\n}\n\nbool issame(ll x, ll y) { // 連結判定\n\treturn root(x) == root(y);\n}\n\nll size(ll x) { // 素集合のサイズ\n\treturn siz[root(x)];\n}\n\n\n//コンビネーション\nconst int MAXcomb = 1000010;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\n//facはn!,finvは1/n!\n//invは逆元\nvoid COMinit() {\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAXcomb; i++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod%i] * (mod / i) % mod;\n\t\tfinv[i] = finv[i - 1] * inv[i] % mod;\n\t}\n}\nll comb(int n, int k) {\n\tif (n < k) return 0;\n\tif (n < 0 || k < 0) return 0;\n\treturn fac[n] * finv[k] % mod * finv[n - k] % mod;\n}\n\n\n/*map<ll, ll> pres;\nll ct;\n\nvoid makePrimeList(ll x) {\n\tll X = x;\n\tfor (ll j = 2; j * j <= x; j++) {\n\t\tll cnt = 0;\n\t\twhile (X % j == 0) {\n\t\t\tcnt++;\n\t\t\tX /= j;\n\t\t}\n\t\tif (cnt) {\n\t\t\tif (pres[j] == 0) {\n\t\t\t\tct++;\n\t\t\t\tpres[j] = ct;\n\t\t\t}\n\t\t\tCnt[pres[j]] += cnt;\n\t\t}\n\t}\n\tif (X != 1) {\n\t\tif (pres[X] == 0) {\n\t\t\tct++;\n\t\t\tpres[X] = ct;\n\t\t}\n\t\tCnt[pres[X]] += 1;\n\t}\n}*/\n\nll H, W, K;\nll c[31][31], C[31][31];\nll tmp[31][31];\nll cont[31];\nll ans;\nll ct;\n\nvoid solve() {\n\tcin >> H >> W >> K;\n\trevrep(i, H) {\n\t\tstring S;\n\t\tcin >> S;\n\t\trep(j, W) C[i][j] = S[j] - '0';\n\t}\n\trep(i, H) rep(j, W) {\n\t\trep(k, H) rep(l, W) c[k][l] = C[k][l];\n\t\tll sum = 0;\n\t\tc[i][j] = -1;\n\t\tct = -1;\n\t\twhile (true) {\n\t\t\tct++;\n\t\t\t/*落下*/\n\t\t\trep(k, W) {\n\t\t\t\tvector<ll> rest;\n\t\t\t\trep(l, H) if (c[l][k] != -1) rest.pb(c[l][k]);\n\t\t\t\trep(l, H) {\n\t\t\t\t\tif (l < rest.size()) c[l][k] = rest[l];\n\t\t\t\t\telse c[l][k] = -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tll add = 0;\n\n\t\t\trep(k, H) {\n\t\t\t\trep(l, W) cont[l] = 0;\n\t\t\t\tll num = 1;\n\t\t\t\trep(l, W) {\n\t\t\t\t\tif (c[k][l] == -1) continue;\n\t\t\t\t\tif (c[k][l] == c[k][l + 1]) num++;\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (ll m = l - num + 1; m <= l; m++) cont[m] = num;\n\t\t\t\t\t\tnum = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(l, W) if (cont[l] >= K) {\n\t\t\t\t\tadd += c[k][l] * (1 << ct);\n\t\t\t\t\tc[k][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsum += add;\n\t\t\tif (add == 0) break;\n\t\t}\n\t\tans = max(ans, sum);\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll T = 1;\n\t//cin >> T;\n\trep(i, T) solve();\n\tll N;\n\tcin >> N;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(long long int (i)=0;(i)<(int)(n);(i)++)\n#define rrep(i,a,b) for(long long int i=(a);i<(b);i++)\n#define rrrep(i,a,b) for(long long int i=(a);i>=(b);i--)\n#define all(v) (v).begin(), (v).end()\n#define pb(q) push_back(q)\n#define Abs(a,b) max(a,b)-min(a,b)\n#define YES(condition) if(condition){cout << \"YES\" << endl;}else{cout << \"NO\" << endl;}\n#define Yes(condition) if(condition){cout << \"Yes\" << endl;}else{cout << \"No\" << endl;}\n#define Cout(x) cout<<(x)<<endl\n#define POSSIBLE(condition) if(condition){cout << \"POSSIBLE\" << endl;}else{cout << \"IMPOSSIBLE\" << endl;}\n#define Possible(condition) if(condition){cout << \"Possible\" << endl;}else{cout << \"Impossible\" << endl;}\n#define possible(condition) if(condition){cout << \"possible\" << endl;}else{cout << \"impossible\" << endl;}\n#define Size(n) (n).size()\n\ntypedef long long ll;\n\n\nusing namespace std;\n\nconst int INF = 1e9,MOD = 1e9 + 7,ohara=1e6;\nconst ll LINF = 1e18;\n\n/*---------------------------------------------------------------\nlong long int kaizyo(long long int hh){\n    cmp=1;\n    while(hh>1){\n        cmp=(cmp*hh)%MOD;\n        hh--;\n    }\n    return cmp;\n}\nlong long int ruizyo(long long int aa, long long int bb){\n    if(aa==0){\n        return 1;\n    }\n    else if(aa%2==0){\n        long long int tt=ruizyo(aa/2,bb);\n        return (tt*tt)%MOD;\n    }\n    else{\n        return (ruizyo(aa-1,bb)*bb)%MOD;\n    }\n}フェルマ－のア\n---------------------------------------------------------------\n\nwhile(x!=0){\n            sum+=x%10;\n          / x/=10;\n        }\n        各桁の和\n---------------------------------------------------------------\n\npair<int,int> p[100000];\ncin >> tmp;\np[i]=make_pair(tmp,i);\ncout << p[i].second+1 << endl;//ペアの右側つまりiを出力\n\n---------------------------------------------------------------\n\nbool f[100001];//1000000以下の素数を調べよう！\nrrep(i,2,100001){\n       f[i]=false;\n    }\nrrep(i,2,100001){\n        if(!f[i]){\n            for(int j=i+i;j<=100000;j+=i){\n                f[j]=true;\n            }\n        }\n    }\n    for(int i=3;i<=100000;i+=2){\n        if(!f[i]){\n            c[i]++;\n        }\n    }\n\n---------------------------------------------------------------\n\nlong long gcd(long long aaa,long long bbb){\n    if(bbb==0){\n        return aaa;\n    }\n    return gcd(bbb,aaa%bbb);\n}\n \nlong long lcm(long long aaa,long long bbb){\n    long long g = gcd(aaa,bbb);\n    return aaa/g * bbb;\n}左から最大公約数と最小公倍数\n\n\n---------------------------------------------------------------\n\nlong long int prime_cnt[10000];\n       for(int i=2;i*i<=n;i++){\n           while(n%i==0){\n               n/=i;\n               prime_cnt[i]+=1;\n           }\n           if(n>1){\n               prime_cnt[n]+=1;\n               break;\n           }\n      }ある数nを素因数分解しましょう\n\n---------------------------------------------------------------\ndebug:\ncout<<\"i: \"<<i<<\" j: \"<<j<<\" cnt: \"<<cnt<<\"\\n\";\n\n---------------------------------------------------------------*/\n\nlong long int n,cnt=0,ans=0,a,b,c,d,cmp[100][100],cmpp[100][100],m,h,w,sum=0,pos,k;\nint dy[]={1,0,-1,0};\nint dx[]={0,1,0,-1};\nstring alph(\"abcdefghijklmnopqrstuvwxyz\"),s;\nbool fl=true;\nstruct edge{int to,cost;};\n\n//-------------------------↓↓↓↓↓↓------------------------\n\nint main(void){\n       cin.tie(0);\n    ios::sync_with_stdio(false);\n\n      \n       cin>>h>>w>>k;\n  \t\tans=0;\n       rep(i,h){\n           cin>>s;\n           rep(j,w){\n               cmp[i][j]=(s[j]-'0');\n           }\n       }\n      \n      ll cntt=0,val=0;\n      rep(i,h){\n          rep(j,w){\n\n              rep(y,h){\n                  rep(x,w){\n                      cmpp[y][x]=cmp[y][x];\n                  }\n              }\n            \n            rrrep(y,i,0){\n                if(y==0){\n                    cmpp[y][j]=0;\n                }\n                else{\n                    cmpp[y][j]=cmpp[y-1][j];\n                }\n            }\n\n           while(1){\n               bool ok=false;\n               rep(y,h){\n                   cntt=1;\n                   rep(x,w){\n                       if(cmpp[y][x]==cmpp[y][x+1]){\n                           cntt++;\n                       }\n                       if(x==w-1||cmpp[y][x]!=cmpp[y][x+1]){\n                           if(cntt>=k){\n                               cnt+=cmpp[y][x]*cntt*pow(2,val);\n                              // cout<<cmpp[y][x]<<\" \"<<cntt<<\" \"<<pow(2,val)<<\"\\n\";\n                               cntt=1;\n                               if(cmpp[y][x]!=0){\n                               ok=true;\n                               }\n                           }\n                            cntt=1;\n                       }\n                   }\n               }\n\n               rep(y,h){\n                   cntt=1;\n                   ll le=0,ri=0;\n                   rep(x,w){\n                       if(cmpp[y][x]==cmpp[y][x+1]&&cmpp[y][x]!=0){\n                           cntt++;\n                           ri++;\n                       }\n                        if(x==w-1||cmpp[y][x]!=cmpp[y][x+1]){\n                            if(cmpp[y][x]==0){\n                                  le=x+1;\n                               ri=le;\n                           cntt=1;\n                           continue;\n                            }\n                           if(cntt>=k){\n                               rrrep(yy,y,0){\n                               rrep(xx,le,ri+1){\n                                   if(yy==0){\n                                       cmpp[yy][xx]=0;\n                                   }\n                                   else{\n                                   cmpp[yy][xx]=cmpp[yy-1][xx];\n                                   }\n                               }\n                               }\n                           }\n                               le=x+1;\n                               ri=le;\n                           cntt=1;\n                       }\n                   }\n               }\n\n               if(!ok)break;\n               val++;\n           }\n           ans=max(ans,cnt);\n           cnt=0;\n           val=0;\n\n          }\n      }\n      Cout(ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\n#define repr(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define invrepr(i,a,b) for(int i=b-1;i>=a;i--)\n#define invrep(i,n) invrepr(i,0,n)\n#define repitr(itr,a) for(auto itr=a.begin();itr!=a.end();++itr)\n#define P pair<int,int>\nconst int MOD=1e9+7;\nconst int INF=2e9;\n\n\nll binary_power(ll a, ll n) {\n    if (n==0) return 1;\n    ll k=binary_power(a,n/2);\n    if (n%2==0) return (k*k)%MOD;\n    else return (((k*k)%MOD)*a)%MOD;\n}\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n\n    int h,w,k;\n    cin >> h >> w >> k;\n    vector<vector<ll>> v(h,vector<ll>(w+1));\n    rep(i,h) {\n        string s;\n        cin >> s;\n        rep(j,w) v[i][j]=s[j]-'0';\n    }\n    ll ans=0;\n    rep(a,h) {\n        rep(b,w) {\n            vector<vector<ll>> t(h,vector<ll>(w+1));\n            copy(v.begin(),v.end(),t.begin());\n            invrep(c,a) t[c+1][b]=t[c][b];\n            t[0][b]=0;\n            ll tans=0,dans=1,itr=0;\n            while (dans>0) {\n                dans=0;\n                rep(i,h) {\n                    int cnt=1;\n                    rep(j,w) {\n                        if (t[i][j+1]==t[i][j]) ++cnt;\n                        else {\n                            if (cnt>=k) {\n                                dans+=cnt*t[i][j]*binary_power(2,itr);\n                                rep(k,cnt) t[i][j-k]=0;\n                            }\n                            cnt=1;\n                        }\n                    }\n                }\n                rep(j,w) {\n                    vector<ll> a;\n                    rep(i,h) {\n                        if (t[i][j]!=0) a.push_back(t[i][j]);\n                    }\n                    rep(i,h-a.size()) t[i][j]=0;\n                    rep(i,a.size()) t[i+h-a.size()][j]=a[i];\n                }\n                ++itr;\n                tans+=dans;\n            }\n            ans=max(ans,tans);\n        }\n    }\n    \n    cout << ans << endl;\n    \n    return 0;   \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\nconst int INF_N = 1e+9;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\n//繰り返し二乗法\nll mod_pow(ll a, ll n, ll m) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%m;\n\t\ta = a * a%m; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\n//逆元(Eucledean algorithm)\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nusing mP = pair<modint, modint>;\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\n\n\nvector<pair<char, int>> run_length_encoding(const string &s) {\n    vector<pair<char, int>> ans;\n\n    int num = 1;\n    for (int i = 0; i < (int)s.size() - 1; ++i) {\n        if (s[i] == s[i + 1]) {\n            num++;\n        }\n        else {\n            ans.emplace_back(make_pair(s[i], num));\n            num = 1;\n        }\n    }\n    ans.emplace_back(make_pair(s.back(), num));\n\n    return ans;\n}\n\nint H, W, K;\nvoid rakka(vector<string> &a){\n    rep(i, H+1){\n        per(j, H){\n            if(j==0)continue;\n            rep(k, W){\n                if(a[j][k] == '0'){\n                    swap(a[j-1][k], a[j][k]);\n                }\n            }\n        }\n    }\n}\n\nll getpt(ll bai, vector<string> &a, bool &ok){\n    ll ret = 0;\n    rep(i, a.size()){\n        string tmp = a[i];\n        // rep(j, W) tmp + (to_string(a[i][j]));\n        auto rle = run_length_encoding(tmp);\n        int cur = 0;\n        for(auto r: rle){\n            if(r.first == '0') continue;\n            if(r.second >= K){\n                rep(k, r.second){\n                    a[i][cur+k] = '0';\n                }\n                ret += (r.first-'0') * r.second;\n                ok = false;\n            }\n            cur += r.second;\n        }\n    }\n    return ret * bai;\n}\n\nvoid solve() {\n    cin >> H >> W >> K;\n    vector<string> v(H);\n    rep(i, H) cin >> v[i];\n    ll ans = 0;\n    Rep(i, 1, H){\n        rep(j, W){\n            ll res = 0;\n            auto tv = v;\n            tv[i][j] = '0';\n            rakka(tv);\n            ll bai = 1;\n            while(1){\n                bool ok = true;\n                res += getpt(bai, tv, ok);\n                rakka(tv);\n                bai *= 2;\n                if(ok) break;\n            }\n            ans = max(ans, res);\n        }\n    }\n    cout << ans << endl;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  //cout << fixed << setprecision(10);\n  //init_f();\n  //init();\n  //int t; cin >> t; rep(i, t)solve();\n  solve();\n//   stop\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T> void chmin(T &a,T b){if(a>b) a=b;}\ntemplate<typename T> void chmax(T &a,T b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int h,w,k;\n  cin>>h>>w>>k;\n  vector<string> s(h);\n  for(Int i=0;i<h;i++) cin>>s[i];\n  auto show=[&](){\n    cout<<endl;\n    for(Int i=0;i<h;i++) cout<<s[i]<<endl;\n    cout<<endl;\n  };\n  \n  auto bk=s;\n  auto drop=[&](){\n    Int flg=0;\n    for(Int i=0;i<h-1;i++)\n      for(Int j=0;j<w;j++)\n\tif(s[i][j]!='#'&&s[i+1][j]=='#')\n\t  swap(s[i][j],s[i+1][j]),flg=1;\n    return flg;\n  };\n  auto calc=[&](){\n    Int cnt=0;\n    for(Int i=0;i<h;i++){\n      for(Int j=0;j<w;j++){\n\tif(s[i][j]=='#') continue;\n\tInt x=j;\n\twhile(x<w&&s[i][j]==s[i][x]) x++;\n\tif(x-j>=k){\n\t  cnt+=(x-j)*(s[i][j]-'0');\n\t  for(Int y=j;y<x;y++) s[i][y]='#';\n\t}\n      }\n    }\n    return cnt;\n  };\n  Int ans=0;\n  for(Int i=0;i<h;i++){\n    for(Int j=0;j<w;j++){\n      s=bk;\n      s[i][j]='#';\n      while(drop());\n      Int tmp=0,po=1;\n      while(Int cnt=calc()){\n\ttmp+=cnt*po;\n\tpo*=2;\n\twhile(drop());\n\t//show();\n      }\n      chmax(ans,tmp);\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LLI long long int\n#define FOR(v, a, b) for(LLI v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(LLI v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(LLI v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define fst first\n#define snd second\n#define popcount __builtin_popcount\n#define UNIQ(v) (v).erase(unique(ALL(v)), (v).end())\n#define bit(i) (1LL<<(i))\n\n#ifdef DEBUG\n#include <Mylib/Debug/debug.cpp>\n#else\n#define dump(...) ((void)0)\n#endif\n\nusing namespace std;\n\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\ntemplate <typename T> void puts_all(const T &value){std::cout << value << \"\\n\";}\ntemplate <typename T, typename ...Args> void puts_all(const T &value, const Args&... args){std::cout << value << \" \";puts_all(args...);}\n\ntemplate <typename T, typename U> bool chmin(T &a, const U &b){return (a>b ? a=b, true : false);}\ntemplate <typename T, typename U> bool chmax(T &a, const U &b){return (a<b ? a=b, true : false);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\ntemplate <typename T> auto make_vector(int n, int m, const T &value){return vector<vector<T>>(n, vector<T>(m, value));}\n\n\nstruct Init{\n  Init(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(12);\n    cerr << fixed << setprecision(12);\n  }\n}init;\n\n\ntemplate <typename T, typename Container = std::vector<T>>\nauto run_length_encode(const Container &v){\n  std::vector<std::pair<T,int64_t>> ret;\n\n  for(auto &x : v){\n    if(ret.empty()) ret.push_back({x,1});\n    else if(ret.back().fst == x) ++ret.back().snd;\n    else ret.push_back({x,1});\n  }\n\n  return ret;\n}\n\n\nLLI solve(int H, int W, int K, vector<vector<int>> c){\n  LLI ret = 0;\n\n  auto proc =\n    [&](){\n      REP(j,W){\n        vector<int> temp;\n        REP(i,H) if(c[i][j] != 0) temp.push_back(c[i][j]);\n        reverse(ALL(temp));\n        REP(i,H) c[i][j] = 0;\n        REP(i,temp.size()){\n          c[H-1-i][j] = temp[i];\n        }\n      }\n    };\n  \n  auto check =\n    [&](){\n      int ret = 0;\n      REP(i,H){\n        auto r = run_length_encode<int>(c[i]);\n\n        int p = 0;\n        for(auto &a : r){\n          if(a.snd >= K){\n            ret += a.fst * a.snd;\n            REP(j,a.snd){\n              c[i][p] = 0;\n              ++p;\n            }\n          }else{\n            REP(j,a.snd){\n              c[i][p] = a.fst;\n              ++p;\n            }\n          }\n        }\n      }\n      return ret;\n    };\n\n  proc();\n\n  int i = 0;\n  while(1){\n    LLI t = check();\n\n    if(t == 0) break;\n\n    ret += (t << i);\n    ++i;\n\n    proc();\n  }\n\n  return ret;\n}\n\n\nint main(){\n  int H, W, K;\n\n  while(cin >> H >> W >> K){\n    auto c = make_vector<int>(H, W, 0);\n\n    REP(i,H){\n      REP(j,W){\n        char a; cin >> a;\n        c[i][j] = a - '0';\n      }\n    }\n\n    LLI ans = 0;\n\n    REP(i,H){\n      REP(j,W){\n        auto cc = c;\n\n        cc[i][j] = 0;\n        chmax(ans, solve(H, W, K, cc));\n      }\n    }\n    \n    puts_all(ans);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\nconst int INF_N = 1e+9;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\n//繰り返し二乗法\nll mod_pow(ll a, ll n, ll m) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%m;\n\t\ta = a * a%m; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\n//逆元(Eucledean algorithm)\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nusing mP = pair<modint, modint>;\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\n\n\nvector<pair<char, int>> run_length_encoding(const string &s) {\n    vector<pair<char, int>> ans;\n\n    int num = 1;\n    for (int i = 0; i < (int)s.size() - 1; ++i) {\n        if (s[i] == s[i + 1]) {\n            num++;\n        }\n        else {\n            ans.emplace_back(make_pair(s[i], num));\n            num = 1;\n        }\n    }\n    ans.emplace_back(make_pair(s.back(), num));\n\n    return ans;\n}\n\nint H, W, K;\nvoid rakka(vector<string> &a){\n    rep(i, H+1){\n        per(j, H){\n            if(j==0)continue;\n            rep(k, W){\n                if(a[j][k] == '0'){\n                    swap(a[j-1][k], a[j][k]);\n                }\n            }\n        }\n    }\n}\n\nll getpt(ll bai, vector<string> &a, bool &ok){\n    ll ret = 0;\n    rep(i, a.size()){\n        string tmp = a[i];\n        // rep(j, W) tmp + (to_string(a[i][j]));\n        auto rle = run_length_encoding(tmp);\n        int cur = 0;\n        for(auto r: rle){\n            if(r.first == '0') continue;\n            if(r.second >= K){\n                rep(k, r.second){\n                    a[i][cur+k] = '0';\n                }\n                ret += (r.first-'0') * r.second;\n                ok = false;\n            }\n            cur += r.second;\n        }\n    }\n    return ret * bai;\n}\n\nvoid solve() {\n    cin >> H >> W >> K;\n    vector<string> v(H);\n    rep(i, H) cin >> v[i];\n    ll ans = 0;\n    Rep(i, 1, H){\n        rep(j, W){\n            ll res = 0;\n            auto tv = v;\n            tv[i][j] = '0';\n            rakka(tv);\n            ll bai = 1;\n            int cnt = 0;\n            while(1){\n                bool ok = true;\n                res += getpt(bai, tv, ok);\n                rakka(tv);\n                bai *= 2;\n                if(ok) break;\n                if(cnt > 40) break;\n            }\n            ans = max(ans, res);\n        }\n    }\n    cout << ans << endl;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  //cout << fixed << setprecision(10);\n  //init_f();\n  //init();\n  //int t; cin >> t; rep(i, t)solve();\n  solve();\n//   stop\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\nint in(){int a;scanf(\"%d\",&a);return a;}\nll lin(){ll a;scanf(\"%lld\",&a);return a;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nint h,w,k;\nint a[10][10];\n\nint s(int a[10][10])\n{\n    int res = 0;\n    rep(i, h) {\n        for (int j = 1; j < w; ++j) {\n            if (a[i][j] == -1) break;\n            bool f = true;\n            if (a[i][j] != a[i][j - 1]) {\n                f = false;\n                break;\n            }\n            if (f) {\n                for (int y = i; y > 0; --y) {\n                    rep(x, w) {\n                        a[y][x] = -1;\n                        swap(a[y][x], a[y-1][x]);\n                    }\n                }\n                chmax(res, a[i][j] * w + s(a));\n            }\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    cin>>h>>w>>k;\n\n    rep(i, h)rep(j, w) cin>>a[i][j];\n    if (h>10||w>10)return 0;\n    if (w!=k)return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    Problem 93\n    https://atcoder.jp/contests/s8pc-3/tasks/s8pc_3_b\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n/* typedef */\ntypedef long long ll;\ntypedef pair<int, int> pii;\n/* class */\nclass pazzle {\n    public:\n    int H, W, K, ans;\n    vector<vector<int> > v;\n    pazzle (int H, int W, int K, vector<vector<int> > v)\n    : H(H), W(W), K(K), v(v) {}\n    bool del() {\n        int ret = false;\n\t\tfor (int i = 0; i < H; i++) {\n            int L = 0;\n            for (int j = 0; j <= W; j++) {\n\t\t\t\tif (v[i][j] != v[i][L] || v[i][j] == -1) {\n\t\t\t\t\tif (j - L >= K) {\n                        ret = true;\n\t\t\t\t\t\tfor (int k = L; k < j; k++) { ans += v[i][k]; v[i][k] = -1; }\n\t\t\t\t\t}\n\t\t\t\t\tL = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        return ret;\n    }\n    void move() {\n        for (int i = 0; i < W; i++) {\n            vector<int> u;\n            for (int j = H - 1; j >= 0; j--) if (v[j][i] != -1) u.push_back(v[j][i]);\n            for(int j = 0; j < H; j++) v[j][i] = -1;\n            for (int j = 0; j < u.size(); j++) v[H - 1 - j][i] = u[j];\n        }\n    }\n    void setAns() { ans = 0; }\n    ll gameStart() {\n        ll ret = 0;\n        move();\n        setAns();\n        for (int i = 0; del(); i++){\n            move();\n            ret += pow(2, i) * ans;\n            setAns();\n        }\n        return ret;\n    }\n};\n/* constant */\nconst int INF = (1 << 30);\n/* global variables */\n/* function */\n/* main */\nint main(){\n    int H, W, K;\n    cin >> H >> W >> K;\n    vector<string> vs(H);\n    for (int i = 0; i < H; i++) cin >> vs[i];\n    vector<vector<int> > v(H, vector<int> (W + 1, -2));\n    for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) {\n        if (vs[i][j] == '.') v[i][j] = -1;\n        else v[i][j] = vs[i][j] - '0';\n    }\n    if (K >= 4) {\n        cout << 0 << '\\n';\n        return 0;\n    }\n    ll ans = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            // if (i != 3 || j != 2) continue; // XXX\n            int tmp = v[i][j];\n            v[i][j] = -1;\n            pazzle P = pazzle(H, W, K, v);\n            ans = max(ans, P.gameStart());\n            v[i][j] = tmp;\n        }\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#define MAXN 35\n#define NN 15\nusing namespace std;\nchar in[MAXN][MAXN];\nint malt[MAXN][MAXN], tmp[MAXN][MAXN];\nint tt[MAXN][MAXN], vis[15];\nint n, m, key;\nvoid work()\n{\n    for(int i = 1; i <= n; i++)\n    {\n        for(int j = 1; j <= m; j++)\n        {\n            tt[i][j] = tmp[i][j];\n            tmp[i][j] = 0;\n        }\n    }\n    for(int j = 1; j <= m; j++)\n    {\n        int now = n;\n        for(int i = n; i >= 1; i--)\n        {\n            if(!tt[i][j]) continue;\n            tmp[now--][j] = tt[i][j];\n        }\n    }\n}\nvoid cop(int x, int y)\n{\n    for(int i = 1; i <= n; i++)\n    {\n        for(int j = 1; j <= m; j++)\n        {\n            tmp[i][j] = malt[i][j];\n        }\n    }\n    tmp[x][y] = 0;\n    work();\n}\nvoid print()\n{\n    for(int i = 1; i <= n; i++)\n    {\n        for(int j = 1; j <= m; j++)\n        {\n            printf(\"%d \", tmp[i][j]);\n        }\n        puts(\"\");\n    }\n}\nint solve()\n{\n    int mul = 2, res = 0, sum;\n    while(true)\n    {\n        sum = 0;\n        for(int i = 1; i <= 9; i++) vis[i] = 0;\n        for(int i = 1; i <= n; i++)\n        {\n            for(int k, j = 1; j <= m; j = k)\n            {\n                k = j;\n                while(k <= m && tmp[i][j] == tmp[i][k]) k++;\n                if(k - j >= key)\n                {\n                    sum += tmp[i][j];\n                    for(int h = j; h < k; h++) tmp[i][h] = 0;\n                }\n            }\n        }\n        if(!sum) break;\n        work();\n        res += (mul * sum);\n        mul *= 2;\n        //print();\n        //printf(\"----------------%d %d\\n\", mul, sum);\n    }\n    return res;\n}\nint main()\n{\n    scanf(\"%d%d%d\", &n, &m, &key);\n    for(int i = 0; i < n; i++) scanf(\"%s\", in[i]);\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            malt[i + 1][j + 1] = in[i][j] - '0';\n        }\n    }\n    int res = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        for(int j = 1; j <= m; j++)\n        {\n            cop(i, j);\n            res = max(res, solve());\n        }\n    }\n    printf(\"%d\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(i = 0;i < n;++i)\n#define all(v) v.begin(), v.end()\nusing ll = long long;\n\nll pow_mod(ll a, ll n, ll p)\n{\n    ll res = 1;\n    while(n > 0){\n        if(n & 1) res = res*a%p;\n        a = a*a%p;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main()\n{\n    ll i,j;\n    ll h,w,k;\n    cin >> h >> w >> k;\n    vector<vector<ll>> c(h,vector<ll>(w));\n    for(i = 0;i < h;++i){\n        string s;\n        cin >> s;\n        rep(j,w){\n            c.at(i).at(j) = s.at(j) - '0';\n        }\n    }\n    ll ans = 0;\n    for(i = 0;i < h;++i){\n        rep(j,w){\n            vector<vector<ll>> cc = c;\n            cc.at(i).at(j) = 0;\n            ll tmp = 0;\n            ll stage = 0;\n            while(true){\n                ll ii,jj;\n                rep(jj,w){\n                    vector<ll> notzero;\n                    for(ii = h-1;ii >= 0;--ii){\n                        if(cc.at(ii).at(jj) != 0) notzero.push_back(cc.at(ii).at(jj));\n                    }\n                    for(ii = 0;ii < notzero.size();++ii){\n                        cc.at(h-1-ii).at(jj) = notzero.at(ii);\n                    }\n                    for(ii = ii;ii < h;++ii){\n                        cc.at(h-1-ii).at(jj) = 0;\n                    }\n                }\n                bool flag = true;\n                for(ii = h-1;ii >= 0;--ii){\n                    rep(jj,w){\n                        if(cc.at(ii).at(jj) == 0) continue;\n                        if(jj + k-1 >= w) continue;\n                        ll kk;\n                        ll tmp_number = cc.at(ii).at(jj);\n                        ll conlen = 0;\n                        for(kk = jj;kk < w;++kk){\n                            if(cc.at(ii).at(kk) == tmp_number){\n                                ++conlen;\n                            }else{\n                                break;\n                            }\n                        }\n                        if(conlen >= k){\n                            flag = false;\n                            tmp += tmp_number*conlen*pow_mod(2ll, stage, 1e12+7);\n                            for(kk = jj;kk < jj+conlen;++kk){\n                                cc.at(ii).at(kk) = 0;\n                            }\n                        }\n                    }\n                }\n                if(flag) break;\n                ++stage;\n            }\n            ans = max(tmp,ans);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define repl(i,l,r) for(ll i=(l);i<(r);i++)\n#define per(i,n) for(ll i=n-1;i>=0;i--)\n#define perl(i,r,l) for(ll i=r-1;i>=l;i--)\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define ins insert\n#define pqueue(x) priority_queue<x,vector<x>,greater<x>>\n#define all(x) (x).begin(),(x).end()\n#define CST(x) cout<<fixed<<setprecision(x)\n#define vtpl(x,y,z) vector<tuple<x,y,z>>\n#define at(x,i) get<i>(x);\n#define rev(x) reverse(x);\nusing ll=long long;\nusing vl=vector<ll>;\nusing vvl=vector<vector<ll>>;\nusing pl=pair<ll,ll>;\nusing vpl=vector<pl>;\nusing vvpl=vector<vpl>;\nconst ll MOD=1000000007;\nconst ll MOD9=998244353;\nconst int inf=1e9+10;\nconst ll INF=4e18;\nconst ll dy[8]={1,0,-1,0,1,1,-1,-1};\nconst ll dx[8]={0,-1,0,1,1,-1,1,-1};\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\nint main(){\n    ll h,w,cc;cin >> h >> w >>cc;\n    vvl f(h,vl(w));\n    rep(i,h){\n        rep(j,w){\n            char x;cin >> x;\n            f[i][j]=x-'0';\n        }\n    }\n    ll ans=0;\n    rep(i,h){\n        rep(j,w){\n            vvl z=f;\n            ll tmp=0;\n            per(k,i){\n                z[k+1][j]=z[k][j];\n            }\n            z[0][j]=0;\n            bool check=true;\n            ll bonus=1;\n            while(check){\n                ll pre=tmp;\n                vvl dist(h,vl(w,0));\n                rep(k,h){\n                    ll x=z[k][0];\n                    ll cnt=0;\n                    rep(l,w){\n                        if(x!=z[k][l]){\n                            if(cnt>=cc){\n                                tmp+=cnt*x*bonus;\n                                rep(m,k){\n                                    rep(o,cnt){\n                                        dist[m][l-1-o]+=1;\n                                    }\n                                }\n                            }\n                            x=z[k][l];\n                            cnt=1;\n                        }\n                        else cnt++;\n                    }\n                    if(cnt>=cc){\n                        tmp+=cnt*x*bonus;\n                        rep(m,k){\n                            rep(o,cnt){\n                                dist[m][w-1-o]+=1;\n                            }\n                        }\n                    }\n                }\n                per(k,h){\n                    rep(l,w){\n                        if(dist[k][l]!=0){\n                            z[k+dist[k][l]][l]=z[k][l];\n                            z[k][l]=0;\n                        }\n                    }\n                }\n                /*if(i==3&&j==2){\n                    rep(xx,h){\n                        rep(yy,w){\n                            cout << z[xx][yy] <<\" \";\n                        }\n                        cout <<endl;\n                    }\n                    rep(xx,h){\n                        rep(yy,w){\n                            cout << dist[xx][yy] <<\" \";\n                        }\n                        cout <<endl;\n                    }\n                    cout << tmp <<endl;\n                }*/\n                if(pre==tmp)check=false;\n                bonus*=2;\n            }\n            chmax(ans,tmp);\n        }\n    }\n    cout << ans <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define rep(i,n) for(int i = 0; i < (n); ++i)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nvoid see(vector<vector<int>> &a){\n\trep(i,a.size()){\n\t\trep(j,a[i].size()) cout << a[i][j] << \" \";\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint h, w, k;\n\tcin >> h >> w >> k;\n\tvector<vector<int>> ori(h, vector<int>(w, 0));\n\trep(i,h)rep(j,w){\n\t\tchar c;\n\t\tcin >> c;\n\t\tori[i][j] = c - '0';\n\t}\n\tint ans = 0;\n\trep(I,h)rep(J,w){\n\t\tvector<vector<int>> a = ori;\n\t\tint score = 0;\n\t\ta[I][J] = 0;\n\t\tfor(int i = I; i > 0; i--){\n\t\t\ta[i][J] = a[i-1][J];\n\t\t\ta[i-1][J] = 0;\n\t\t}\n\t\tint two = 1;\n\t\tbool changed = true;\n\t\twhile(changed){\n\t\t\t//see(a);\n\t\t\tchanged = false;\n\t\t\trep(i,h){\n\t\t\t\tvector<bool> used(w, false);\n\t\t\t\trep(j,w-k+1){\n\t\t\t\t\tif(a[i][j] == 0) continue;\n\t\t\t\t\tbool same = true;\n\t\t\t\t\trep(l,k-1){\n\t\t\t\t\t\tif(a[i][j+l] != a[i][j+l+1]) same = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(same){\n\t\t\t\t\t\trep(l,k) used[j+l] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(j,w){\n\t\t\t\t\tif(used[j]){\n\t\t\t\t\t\tscore += two * a[i][j];\n\t\t\t\t\t\ta[i][j] = 0;\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,w){\n\t\t\t\tfor(int i = h-1; i > 0; i--){\n\t\t\t\t\tif(a[i][j] == 0){\n\t\t\t\t\t\tint cur = i-1;\n\t\t\t\t\t\twhile(cur > 0 && a[cur][j] == 0) cur--;\n\t\t\t\t\t\ta[i][j] = a[cur][j];\n\t\t\t\t\t\ta[cur][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttwo *= 2;\n\t\t}\n\t\tchmax(ans, score);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst ll MOD = 1'000'000'007;\nconst ld PI = acos(-1);  \nconst ld EPS = 0.0000000001;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define REP(i, n) for(ll i=0; i<(ll)(n); i++)\n#define REPD(i, n) for(ll i=n-1; 0<=i; i--)\n#define FOR(i, a, b) for(ll i=a; i<(ll)(b); i++)\n#define FORD(i, a, b) for(ll i=a; (ll)(b)<=i; i--)\n#define ALL(x) x.begin(), x.end()\n#define MAX(x) *max_element(ALL(x))\n#define MIN(x) *min_element(ALL(x))\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint main(){\n    ll h, w, k;  cin >> h >> w >> k;\n    vector<vector<ll>> ori(h, vector<ll>(w));\n    REP(i, h) REP(j, w){\n        char c; cin >> c;\n        ori[i][j] = c-'0';\n    }\n    \n    ll res=0;\n    REP(x, h){\n        REP(y, w){\n            ll tmp=0, times=0;\n            bool flag=true;\n            vector<vector<ll>> g = ori;\n            g[x][y] = 0;\n            while(flag){\n                flag = false;\n                REPD(i, h){\n                    REP(j, w){\n                        if(!g[i][j]){\n                            REPD(k, i){\n                                if(!g[k][j]) continue;\n                                swap(g[k][j], g[i][j]); break;\n                            }\n                        }\n                    }\n                }\n                REP(i, h){\n                    ll bef=g[i][0], cnt=0, st=0, index=w;\n                    \n                    REP(j, w){\n                        if(g[i][j]==bef && 0<bef) cnt += 1;\n                        else{\n                            if(cnt<k){\n                                if(0<g[i][j]){\n                                    cnt = 1; st=j;\n                                }\n                            }else{\n                                if(bef)index = j;\n                                break;\n                            }\n                        }\n                        bef = g[i][j];\n                    }\n                    if(k<=cnt){\n                        tmp += (1<<times)*cnt*bef;\n                        FOR(j, st, index) g[i][j] = 0;\n                        flag = true;\n                    }\n                }\n                \n                times += 1;\n            }\n            \n            res = max(res, tmp);\n            //cout << x <<':' << y << ' ' << tmp << endl << endl;\n        }\n    }\n    cout << res << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n//const ll MOD = 1e9 + 7;\n//const ll MOD = 998244353;\n//const ll MOD = ;\nll mod(ll A, ll M) {return (A % M + M) % M;}\nconst ll INF = 1LL << 60;\ntemplate<class T> bool chmin(T& a, T b) {if (a > b) {a = b; return true;} return false;}\ntemplate<class T> bool chmax(T& a, T b) {if (a < b) {a = b; return true;} return false;}\nll divceil(ll A, ll B) {return (A + (B - 1)) / B;}\nll myctoi(char C) {return C - '0';}\nchar myitoc(ll N) {return '0' + N;}\n#define FINALANS(A) {cout << (A) << '\\n'; exit(0);}\n\nll H, W, K;\nvector<string> C;\nvector<string> c;\n\nvoid init()\n{\n  for (ll i = 0; i < H; i++)\n  {\n    C.at(i) = c.at(i);\n  }\n}\n\nvoid drop()\n{\n  for (ll x = 0; x < W; x++)\n  {\n    string ns = \"\";\n    for (ll y = H - 1; y >= 0; y--)\n    {\n      if (C.at(y).at(x) != ' ')\n        ns += C.at(y).at(x);\n    }\n\n    ll cnt = 0;\n    for (ll y = H - 1; y >= 0; y--)\n    {\n      if (cnt >= ns.size())\n        C.at(y).at(x) = ' ';\n      else\n      {\n        C.at(y).at(x) = ns.at(cnt);\n        cnt++;\n      }\n    }\n  }\n}\n\nll erase()\n{\n  ll ret = 0;\n  for (ll y = 0; y < H; y++)\n  {\n    ll tmp = 0, l = -1;\n    for (ll x = 0; x < W; x++)\n    {\n      if (l != -1 && C.at(y).at(x) != C.at(y).at(x + 1))\n      {\n        C.at(y).at(x) = ' ';\n\n        if (x - l + 1 >= K)\n          ret += tmp * (x - l + 1);\n        l = -1;\n      }\n\n      if (C.at(y).at(x) != ' ' && C.at(y).at(x) == C.at(y).at(x + 1))\n      {\n        if (l == -1)\n        {\n          l = x;\n          tmp = myctoi(C.at(y).at(x));\n        }\n        C.at(y).at(x) = ' ';\n      }\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  cin >> H >> W >> K;\n  c = vector<string>(H);\n  for (ll i = 0; i < H; i++)\n  {\n    cin >> c.at(i);\n    c.at(i) += \"#\";\n  }\n\n  ll ans = 0;\n  C = vector<string>(H);\n  for (ll dy = 0; dy < H; dy++)\n  {\n    for (ll dx = 0; dx < W; dx++)\n    {\n      ll tmp = 0;\n      init();\n      C.at(dy).at(dx) = ' ';\n\n      for (ll i = 0;; i++)\n      {\n        drop();\n        ll sum = erase();\n\n        /*\n        cerr << dy << \" \" << dx << \" \" << i << \" \" << sum << endl;\n        for (ll y = 0; y < H; y++)\n        {\n          cerr << C.at(y) << endl;\n        }\n        cerr << endl;\n        */\n\n        tmp += (1LL << i) * sum;\n        if (sum == 0)\n          break;\n      }\n      chmax(ans, tmp);\n    }\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair< ll, ll > Pi;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep2(i,n) for(int i=1;i<=(n);i++)\n#define rep3(i,i0,n) for(int i=i0;i<(n);i++)\n#define pb push_back\n#define mod 1000000007\nconst ll INF = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nll gcd(ll a, ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b) {return a/gcd(a,b)*b;}\n#define all(x) x.begin(), x.end()\n#define mp make_pair\nbool compare(Pi a, Pi b) {\n    if(a.first != b.first){\n        return a.first < b.first;\n        \n    }else{\n        return a.second < b.second;\n    }\n}\n\nint ctoi(char c) {\n\tif (c >= '0' && c <= '9') {\n\t\treturn c - '0';\n\t}\n\treturn 0;\n}\nbool In_map(ll y,ll x,ll h,ll w){\n    if(y<0 || x<0 || y>=h || x>=w){\n        return 0;\n    }else{\n        return 1;\n    }\n}\nconst vector<ll> dx{1,0,-1,0};\nconst vector<ll> dy{0,1,0,-1};\n\n\n\nint main() {\n\n    ll H,W,K;\n    cin >>H>>W>>K;\n    vector<string> S(H+1);\n    rep(i,H) cin >>S[i];\n    vector<vector<ll>> R(H+1,vector<ll>(W+1));\n    vector<vector<ll>> R2(H+1,vector<ll>(W+1));\n    rep(i,H) rep(j,W) R[i][j] = ctoi(S[i][j]);\n    R2 = R;\n    if(K<=1){\n        ll ans = 0;\n        ll min = INF;\n        rep(i,H){\n            rep(j,W){\n                chmin(min,R[i][j]);\n                ans+=R[i][j];\n            }\n        }\n        cout << ans-min<<endl;\n        return 0;\n    }\n\n\n    ll fans = 0;\n    rep(h,H) rep(w,H){\n    ll ans = 0;\n    R=R2;\n    R[h][w] = -1;\n    ll flag = 0;\n    rep(m,H){\n        ll p2 =pow(2,m); \n        /*rep(j,W){\n            vector<ll> tmp;\n            rep(i,H){\n                if(R[H-1-i][j] != -1){\n                    tmp.pb(R[H-1-i][j]);\n                }\n            }\n            rep(i,H){\n                if(i<tmp.size()){\n                    R[H-1-i][j] = tmp[i];\n                }else{\n                    R[H-1-i][j] = -1;\n                }\n            }\n        }*/\n        /*rep(i,H){\n            ll cnt=0;\n            ll p=-1;\n            rep(j,W){\n                if(R[i][j] == p && R[i][j] != -1){\n                    cnt++;\n                    if(j==W-1){\n                        if(cnt>=K){\n                            flag = 1;\n                            //ans += R[i][j-1]*cnt*p2;\n                            rep(k,cnt){\n                               // R[i][j-k] = -1;\n                            }\n                        }\n                    }\n                }else{\n                    if(cnt>=K){\n                        flag = 1;\n                        //ans += R[i][j-1]*cnt*p2;\n                        rep(k,cnt){\n                            //R[i][j-k-1] = -1;\n                        }\n                    }\n                    cnt = 1;\n                }\n                \n\n                p = R[i][j];\n            }\n        \n        \n        }*/\n\n        if(flag ==0) break;\n    }\n\n\n        chmax(fans,ans);\n    }\n\n    cout << fans<<endl;\n    \n    return 0;\n    \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint H, W, K;\nint A[30][30];\nint B[31][31];\nint C[31][31];\n\nvoid move() {\n  for (int x=0; x<W; x++) {\n    for (int y=0; y<H; y++) {\n      C[x][y] = B[x][y];\n    }\n  }\n  for (int x=0; x<W; x++) {\n    int h = 0;\n    for (int y=0; y<H; y++) {\n      if (B[x][y] == 0) continue;\n      B[x][h++] = C[x][y];\n    }\n    for (int y=h; y<H; y++) {\n      B[x][y] = 0;\n    }\n  }\n}\n\nlong long score() {\n  long long s = 0;\n  for (int y=0; y<H; y++) {\n    int l = -1, lc = 0;\n    for (int x=0; x<=W; x++) {\n      if (B[x][y] == lc) continue;\n      if (x-l >= K && lc != 0) {\n        s += 1LL*lc*(x-l);\n        for (int xx=l; xx<x; xx++) B[xx][y] = 0;\n      }\n      lc = B[x][y];\n      l = x;\n    }\n  }\n  return s;\n}\n\nlong long solve(int sx, int sy) {\n  for (int x=0; x<W; x++) {\n    for (int y=0; y<H; y++) {\n      B[x][y] = A[x][y];\n    }\n  }\n  B[sx][sy] = 0;\n  move();\n  long long s = 0;\n  for (int i=0; ; i++) {\n    int f = score();\n    if (f == 0) break;\n    s += (1LL<<i) * f;\n    move();\n  }\n  return s;\n}\n\nsigned main() {\n  cin >> H >> W >> K;\n  for (int i=0; i<H; i++) {\n    for (int j=0; j<W; j++) {\n      char c;\n      cin >> c;\n      A[j][H-1-i] = (int)(c - '0');\n    }\n  }\n  long long s = 0;\n  for (int x=0; x<W; x++) {\n    for (int y=0; y<H; y++) {\n      s = max(s, solve(x, y));\n    }\n  }\n  cout << s << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing msi = map<string, int>;\nusing mii = map<int, int>;\nusing psi = pair<string, int>;\nusing pii = pair<int, int>;\nusing vlai = valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1E9\n#define EPS 1E-9\n#define MOD 1000000007\n#define PI 3.1415926535897932384\n\ntemplate <class T>ostream &operator<<(std::ostream &o, const vector<T> &v)\n{\n\trep(i, v.size()) {\n\t\to << (i > 0 ? \" \" : \"\") << v[i];\n\t}\n\treturn o;\n}\n\nint h, w, k;\n\nint clean(vvi &test) {\n\tint s = 0;\n\tint l;\n\trep(i, h) {\n\t\tint t = 1;\n\t\trep(j, w) {\n\t\t\tif (j != 0 && test[i][j] && test[i][j - 1] == test[i][j]) {\n\t\t\t\tt++;\n\t\t\t}\n\t\t\telse t = 1;\n\t\t\tif (t == k) {\n\t\t\t\tint tgt = test[i][j - t + 1];\n\t\t\t\ts += test[i][j - t + 1];\n\t\t\t\ttest[i][j - t + 1] = 0;\n\t\t\t\tfor (l = j - t + 2; l < w && test[i][l]==tgt; l++) {\n\t\t\t\t\ts += test[i][l];\n\t\t\t\t\ttest[i][l] = 0;\n\t\t\t\t}\n\t\t\t\tj = l - 1;\n\t\t\t\tt = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn s;\n}\n\nvoid drop(vvi &test) {\n\trep(j, w) {\n\t\tvi v;\n\t\trep(i, h) {\n\t\t\tif (test[i][j]) {\n\t\t\t\tv.push_back(test[i][j]);\n\t\t\t}\n\t\t}\n\t\trep(i, h) {\n\t\t\tif (i<v.size()) {\n\t\t\t\ttest[i][j]=v[i];\n\t\t\t}\n\t\t\telse test[i][j] = 0;\n\t\t}\n\t}\n}\n\n\n\nint main() {\n\tll mul = 1;\n\tchar c;\n\tll ans = 0, score = 0, tmp = 0;\n\tcin >> h >> w >> k;\n\tvvi vv(h,vi(w,0)), test(h, vi(w, 0));\n\trep(i,h) {\n\t\trep(j, w) {\n\t\t\tcin >> c;\n\t\t\tvv[i][j] = (c - '0');\n\t\t}\n\t}\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\trep(ii, h) {\n\t\t\t\trep(jj, w) {\n\t\t\t\t\ttest[ii][jj] = vv[h-ii-1][jj];\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest[i][j] = 0;\n\t\t\tdrop(test);\n\t\t\twhile (tmp = clean(test), tmp) {\n\t\t\t\tdrop(test);\n\t\t\t\tscore += (tmp*mul);\n\t\t\t\tmul *= 2;\n\t\t\t}\n\t\t\tmul = 1;\n\t\t\tans = max(score,ans);\n\t\t\tscore = 0;\n\t\t}\n\t}\n\tcout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define mt make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int H, W, K;\n    int rem[30][30];\n\n    while(cin >> H >> W >> K) {\n        vector<string> S(H);\n        rep(y, H)cin >> S[y];\n\n       \n\n        ll ans = 0;\n\n        rep(remY, H)rep(remX, W) {\n            vector<list<int>> ls(W);\n            rep(x, W) {\n                rep(y, H) {\n                    if(y != remY || x != remX)ls[x].push_back(S[H-1-y][x] - '0');\n                }\n            }\n\n            vector<list<int>::iterator> its(W);\n            vector<list<int>::reverse_iterator> rits(W);\n\n            int upd = 1;\n            ll mul = 1, value = 0;\n            while(upd) {\n                ll sm = 0;\n                upd = 0;\n                vi col(W);\n                MEM(rem, 0);\n\n                rep(x, W)its[x] = ls[x].begin();\n\n                int row = 0;\n                for(; row < H && count(all(col), -1) != W; ++row) {\n                    int cur = -1, start = -1, suc = 0;\n                    rep(x, W) {\n                        if(its[x] == ls[x].end())col[x] = -1;\n                        else {\n                            col[x] = *its[x];\n                            ++its[x];\n                        }\n                        if(cur != col[x]) {\n                            if(cur != -1 && suc >= K) {\n                                FOR(i, start, x)rem[row][i] = 1;\n                                upd = 1;\n                            }\n                            suc = 1;\n                            cur = col[x];\n                            start = x;\n                        } else {\n                            suc++;\n                        }\n                    }\n\n                    if(cur!=-1 && suc >= K) {\n                        FOR(i, start, W)rem[row][i] = 1;\n                        upd = 1;\n                    }\n                }\n\n                rep(x, W)its[x] = ls[x].begin();\n\n                rep(r, row) {\n                    rep(x, W) {\n                        if(rem[r][x]) {\n                            sm += *its[x];\n                            its[x] = ls[x].erase(its[x]);\n                        } else if(its[x] != ls[x].end()) {\n                            its[x]++;\n                        }\n                    }\n                }\n\n                value += sm*mul;\n\n                mul *= 2;\n            }\n\n            \n            smax(ans, value);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <math.h>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <numeric>\n#include <bits/stdc++.h>\n\n#define int long long\n\nstruct edge {\n    int to;\n    int cost;\n};\n\nusing namespace std;\nusing vi = vector<int>;\nusing vii = vector<vector<int>>;\nusing vb = vector<bool>;\nusing qi = queue<int>;\nusing P = pair<int, int>;\nusing graph = vector<vector<edge>>;\n// using graph = vector<vector<int>>;\n\n\n#define FOR(i, a, b) for (int i = a; i < (b); i++)\n#define REP(i,n) for(int i=0;i<n;i++)\n#define delim(i, n) cout << (i == n-1 ? \"\\n\" : \" \");\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nconst int inf = 1LL << 60;\n// const int inf = 100000000;\nconst int mod = 1000000007;\n\nconst int maxn =  30;\nint h, w, k;\nvii init_board(maxn+1);\n\nint ctoi(const char c){\n  switch(c){\n    case '0': return 0;\n    case '1': return 1;\n    case '2': return 2;\n    case '3': return 3;\n    case '4': return 4;\n    case '5': return 5;\n    case '6': return 6;\n    case '7': return 7;\n    case '8': return 8;\n    case '9': return 9;\n    default : return -1;\n  }\n}\n\nsigned main () {\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\n    cin >> h >> w >> k;\n    REP(i, h) {\n        string tmp; cin >> tmp;\n        REP(j, w) {\n            init_board[h-i-1].push_back(ctoi(tmp[j]));\n        }\n    }\n    REP(j, w) init_board[h].push_back(0);\n\n    int pm = 0;\n    if (k <= 3) {\n        REP(b, w) {\n            REP(a, h) {\n                int point = 0;\n                vii board(h+1);\n                REP(i, h+1) {\n                    REP(j, w) board[i].push_back(init_board[i][j]);\n                }\n\n                FOR(i, a, h) {\n                    board[i][b] = board[i+1][b];\n                    board[i+1][b] = 0;\n                }\n\n                bool flag = true;\n                int weight = 1;\n                while (flag) {\n                    flag = false;\n                    REP(i, h) {\n                        int idx = 0;\n                        vi cnt;\n                        cnt.push_back(1);\n                        vi s;\n                        s.push_back(0);\n                        REP(j, w-1) {\n                            if (board[i][j] == board[i][j+1]) cnt[idx]++;\n                            else {\n                                if (cnt[idx] < k) {\n                                    cnt[idx] = 1;\n                                    s[idx] = j+1;\n                                } else {\n                                    idx++;\n                                    cnt.push_back(1);\n                                    s.push_back(j+1);\n                                }\n                            }\n                        }\n                        if (cnt[idx] >= k) idx++;\n                        REP(j, idx) {\n                            if (cnt[j] >= k && board[i][s[j]] != 0) {\n                                flag = true;\n                                point += board[i][s[j]]*cnt[j]*weight;\n                                REP(l, cnt[j]) board[i][s[j]+l] = 0;\n                            }\n                        }\n                    }\n                    weight *= 2;\n                    bool flag2 = true;\n                    while(flag2) {\n                        flag2 = false;\n                        REP(i, h) {\n                            REP(j, w) {\n                                if (board[i][j] == 0 && board[i+1][j] != 0) {\n                                    flag2 = true;\n                                    board[i][j] = board[i+1][j];\n                                    board[i+1][j] = 0;\n                                }\n                            }\n                        }\n                    }\n                    if (point == 0) flag = false;\n                    else chmax(pm, point);\n                }\n                if (point == 0) break;\n            }\n        }\n    }\n    cout << std::fixed << std::setprecision(10) << pm << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\n#define rep(i, n) for(int i=0; i<n; i++)\ntypedef long long ll;\nconst int INF = 0;\n\nint main(){\n    int H,W,K; cin>>H>>W>>K;\n    int field[H][W],copy[H][W];\n    rep(i,H){\n      string a; cin>>a;\n      rep(j,W){\n        field[i][j]=a[j]-'0';\n        copy[i][j]=field[i][j];\n      }\n    }\n  \nint rec=0;\nrep(a,H) rep(b,W){\n    rep(i,H) rep(j,W) field[i][j]=copy[i][j];\n    field[a][b]=INF;\n\nrep(k,40){\n        for(int i=0;i<H-1;i++){\n            rep(j,W){\n                if(field[i+1][j]==INF){\n                    field[i+1][j]=field[i][j];\n                    field[i][j]=INF;\n                }\n            }\n        }\n    }\n\n\n int ans=0; \n int two=1;\n rep(l,40){\n   \n    int point=0;\n    rep(i,H){\n\n        int count=1;\n        for(int j=1;j<W;j++){\n            if(field[i][j]==field[i][j-1]) count++;\n            else{\n                if(count<K) count=1;\n                else{\n                    point+=field[i][j-1]*count;\n                    rep(k,count) field[i][j-1-k]=INF;\n                    count=1;\n                }   \n            }\n            if(j==W-1){\n                    if(count>=K){\n                        point+=field[i][j-1]*count;\n                        rep(k,count) field[i][j-k]=INF;\n                    }\n            }\n        }\n    }\n    rep(k,40){\n        for(int i=0;i<H-1;i++){\n            rep(j,W){\n                if(field[i+1][j]==INF){\n                    field[i+1][j]=field[i][j];\n                    field[i][j]=INF;\n                }\n            }\n        }\n    }\n\n    \n   ans+=point*two;\n   two*=2;\n }\n rec=max(ans,rec);\n}\n \ncout<<rec<<endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint h,w,k;\nint c[35][35];\nint f[35][35];\n\nint do_vanish(){\n    int ret = 0;\n    int g[35][35]={};\n    for(int i=0; i<h; i++){\n        for(int j=0; j+(k-1)<w; j++){\n            bool flag = true;\n            if(f[i][j] == 0) break;\n            for(int l=1; l<=k-1; l++){\n                if(f[i][j] != f[i][j+l]) flag = false;\n            }\n            if(flag){\n                for(int l=0; l<=k-1; l++) g[i][j+l] = 1;\n            }\n        }\n    }\n    for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++){\n            if(g[i][j] == 1){\n                ret += f[i][j];\n                f[i][j] = 0;\n            }\n        }\n    }\n    return ret;\n}\n\nvoid do_clean(){\n    bool flag=true;\n    while(flag){\n        flag = false;\n        for(int i=0; i<h-1; i++){\n            for(int j=0; j<w; j++){\n                if(f[i][j] != 0 && f[i+1][j] ==0){\n                    f[i+1][j] = f[i][j];\n                    f[i][j] = 0;\n                    flag = true;\n                }\n            }\n        }\n    }\n    return;\n}\n\nint main(){\n    cin >> h >> w >> k;\n    for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++){\n            char z;\n            cin >> z;\n            c[i][j] = z - '0';\n            //cout << c[i][j] << endl;\n        }\n    }\n\n    long long max_ans = 0;\n    for(int p=0; p<h; p++){\n        for(int q=0; q<w; q++){\n            for(int i=0; i<h; i++) for(int j=0; j<w; j++) f[i][j] = c[i][j];\n            f[p][q]=0;\n            long long ans=0;\n            int pow=1;\n            while(true){\n                do_clean();\n                int x = do_vanish();\n                if(x == 0) break;\n                ans += pow*x;\n                pow *= 2;\n            }\n        max_ans = max(ans, max_ans);\n        }\n    }\n    \n    cout << max_ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\n\nint h, w,k;\nchar board[50][50];\nchar sand[50][50];\nchar nsand[50][50];\nvoid drop()\n{\n\tfor (int i = 0; i < h; ++i)\n\t{\n\t\tfor (int j = 0; j < w; ++j)\n\t\t{\n\t\t\tnsand[i][j] = ' ';\n\t\t}\n\t}\n\tfor (int col = 0; col < w; ++col)\n\t{\n\t\tint cnt = h - 1;\n\t\tfor (int y = h - 1; y >= 0; --y)\n\t\t{\n\t\t\tif (sand[y][col] != ' ')\n\t\t\t{\n\t\t\t\tnsand[cnt][col] = sand[y][col];\n\t\t\t\t--cnt;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < h; ++i)\n\t{\n\t\tfor (int j = 0; j < w; ++j)\n\t\t{\n\t\t\tsand[i][j] = nsand[i][j];\n\t\t}\n\t}\n}\nint crush()\n{\n\tint point = 0;\n\tfor (int row = 0; row < h; ++row)\n\t{\n\t\tfor (int itr = 0; itr < w - 1; ++itr)\n\t\t{\n\t\t\tif (sand[row][itr] == sand[row][itr + 1] && sand[row][itr] != ' ')\n\t\t\t{\n\t\t\t\tint itr2 = itr;\n\t\t\t\twhile (sand[row][itr2] == sand[row][itr2 + 1])\n\t\t\t\t{\n\t\t\t\t\titr2++;\n\t\t\t\t}\n\t\t\t\tif (itr2 - itr + 1 >= k)\n\t\t\t\t{\n\t\t\t\t\tpoint += (itr2 - itr + 1) * (sand[row][itr] - '0');\n\t\t\t\t\tfor (int i = itr; i <= itr2; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tsand[row][i] = ' ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\titr = itr2;\n\t\t\t}\n\t\t}\n\t}\n\treturn point;\n}\n\nint main(void)\n{\n\tscanf(\"%d %d %d\", &h, &w, &k);\n\tfor (int i = 0; i < h; ++i)\n\t{\n\t\tscanf(\"%s\",board[i]);\n\t}\n\tint answer = 0;\n\tfor (int p = 0; p < h; ++p)\n\t{\n\t\tfor (int q = 0; q < w; ++q)\n\t\t{\n\t\t\tfor (int i = 0; i < h; ++i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < w; ++j)\n\t\t\t\t{\n\t\t\t\t\tsand[i][j] = board[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tint tim = 1;\n\t\t\tsand[p][q] = ' ';\n\t\t\tdrop();\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tint point = crush();\n\t\t\t\tif (point == 0)break;\n\t\t\t\tint score = point * tim;\n\t\t\t\tans += score;\n\t\t\t\tdrop();\n\t\t\t\ttim *= 2;\n\t\t\t}\n\t\t\tanswer = max(answer,ans);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", answer);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <utility>\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nint h, w, k;\n\nint func(vvi field)\n{\n    int score = 0;\n    int base = 1;\n    \n    for(;;){\n        // fall stones\n        rep(j, w){\n            int np = h-1;\n            for(int i=h-1; i>=0; --i){\n                int t = field[i][j];\n                if(t != -1){\n                    field[i][j] = -1;\n                    field[np][j] = t;\n                    --np;\n                }\n            }\n        }\n        \n        // erase stones\n        int add_score = 0;\n        \n        rep(i, h){\n            int cnt = 1;\n            reps(j, 1, w+1){\n                if(j < w && field[i][j] != -1 && field[i][j] == field[i][j-1]){\n                    ++cnt;\n                }\n                else{\n                    if(cnt >= k){\n                        add_score += cnt * field[i][j-1] * base;\n                        rep(l, cnt){\n                            field[i][j-l-1] = -1;\n                        }\n                    }\n                    cnt = 1;\n                }\n            }\n        }\n        \n        if(add_score == 0) break;\n        score += add_score;\n        \n        base *= 2;\n    }\n    \n    return score;\n}\n\n\nsigned main()\n{\n    cin >> h >> w >> k;\n    \n    vvi field(h, vi(w));\n    \n    rep(i, h){\n        string str;\n        cin >> str;\n        rep(j, w) field[i][j] = str[j] - '0';\n    }\n    \n    int ans = 0;\n    rep(i, h) rep(j, w){\n        vvi cp = field;\n        cp[i][j] = -1;\n        ans = max(ans, func(cp));\n    }\n    \n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(v) v.begin(), v.end()\ntypedef long long ll;\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int h,w,k;\n  cin>>h>>w>>k;\n  \n  vector<vector<int>> A(w,vector<int>(2*h+1,0));\n  char c;\n  rep(i,h){\n    rep(j,w){\n      cin>>c;\n      A[j][h-1-i]=c-'0';\n    }\n  }\n  \n  ll ans=0;\n  rep(i,w){\n    rep(j,h){\n      ll x=1,sum=0;\n      vector<vector<int>> B(w,vector<int>(2*h+1,0));\n      B=A;\n      B[i].erase(B[i].begin()+j);\n      rep(z,h){\n        for(int s=h-1;s>=0;s--){\n          vector<int> M(w,0);\n          for(int t=0;t<=w-k;t++){\n            bool b=true;\n            if(B[t][s]==0) continue;\n            for(int u=t+1;u<t+k;u++) if(B[u][s]!=B[t][s]) b=false;\n            if(b) for(int u=t;u<t+k;u++) M[u]=1;\n          }\n          for(int t=0;t<w;t++){\n            if(M[t]==1){\n              sum+=x*B[t][s];\n              B[t].erase(B[t].begin()+s);\n            }\n          }\n        }\n        x*=2;\n      }\n      ans=max(ans,sum);\n    }\n  }\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <sstream>\n#include <string.h>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <deque>\n#include <limits>\n#include <iomanip>\n#include <ctype.h>\n#include <unordered_map>\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <math.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, char> pic;\n#define bit(x,v) ((ll)x << v)\n\nconst ll INF = 1000000007;\nconst int MAX = 210000;\nconst int MOD = 1000000007;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit() {\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n}\n\n// 二項係数計算\nlong long COM(int n, int k) {\n\tif (n < k) return 0;\n\tif (n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\nint pr[100010];\nvoid uini(int n) {\n\tfor (size_t i = 0; i <= n; i++)\n\t{\n\t\tpr[i] = i;\n\t}\n}\n\nint parent(int x) {\n\tif (x == pr[x]) return x;\n\treturn pr[x] = parent(pr[x]);\n}\n\nbool unit(int x, int y) {\n\tint px = parent(x);\n\tint py = parent(y);\n\n\tif (px == py) return false;\n\tif (px < py) {\n\t\tpr[py] = px;\n\t}\n\telse {\n\t\tpr[px] = py;\n\t}\n\treturn true;\n}\n\nll bit[200010];\nint max_n = 200000;\nint pm = 0;\nvoid add(int x) {\n\n\twhile (max_n >= x)\n\t{\n\t\tbit[x]++;\n\t\tx += x & -x;\n\t}\n}\nvoid sub(int x) {\n\twhile (max_n >= x)\n\t{\n\t\tbit[x]--;\n\t\tx += x & -x;\n\t}\n}\nll merge(ll *a, int left, int mid, int right) {\n\tll n1 = mid - left;\n\tll n2 = right - mid;\n\tvector<int> L(n1 + 1);\n\tvector<int> R(n2 + 1);\n\tfor (size_t i = 0; i < n1; i++)\n\t{\n\t\tL[i] = a[left + i];\n\t}\n\tfor (size_t i = 0; i < n2; i++)\n\t{\n\t\tR[i] = a[mid + i];\n\t}\n\n\tL[n1] = INF;\n\tR[n2] = INF;\n\tll i = 0;\n\tll j = 0;\n\tll r = 0;\n\tfor (size_t k = left; k < right; k++)\n\t{\n\t\tif (L[i] <= R[j]) {\n\t\t\ta[k] = L[i];\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\ta[k] = R[j];\n\t\t\tr += n1 - i;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn r;\n}\nll merge2(pair<int, char> *a, int left, int mid, int right) {\n\tll n1 = mid - left;\n\tll n2 = right - mid;\n\tvector<pair<int, char>> L(n1 + 1);\n\tvector<pair<int, char>> R(n2 + 1);\n\tfor (size_t i = 0; i < n1; i++)\n\t{\n\t\tL[i] = a[left + i];\n\t}\n\tfor (size_t i = 0; i < n2; i++)\n\t{\n\t\tR[i] = a[mid + i];\n\t}\n\n\tL[n1] = make_pair(INF, ' ');\n\tR[n2] = make_pair(INF, ' ');\n\tll i = 0;\n\tll j = 0;\n\tll r = 0;\n\tfor (size_t k = left; k < right; k++)\n\t{\n\t\tif (L[i].first <= R[j].first) {\n\t\t\ta[k] = L[i];\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\ta[k] = R[j];\n\t\t\tr += n1 - i;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn r;\n}\nll mergeSort2(pair<int, char> *a, int left, int right) {\n\tll res = 0;\n\tif (left + 1 < right) {\n\t\tint mid = (left + right) / 2;\n\t\tres = mergeSort2(a, left, mid);\n\t\tres += mergeSort2(a, mid, right);\n\t\tres += merge2(a, left, mid, right);\n\t}\n\treturn res;\n}\nll mergeSort(ll *a, int left, int right) {\n\tll res = 0;\n\tif (left + 1 < right) {\n\t\tint mid = (left + right) / 2;\n\t\tres = mergeSort(a, left, mid);\n\t\tres += mergeSort(a, mid, right);\n\t\tres += merge(a, left, mid, right);\n\t}\n\treturn res;\n}\nint partition(pair<int, char> *a, int p, int r) {\n\tpair<int, char> x = a[r];\n\tint i = p - 1;\n\tfor (size_t j = p; j < r; j++)\n\t{\n\t\tif (a[j].first <= x.first) {\n\t\t\ti++;\n\t\t\tswap(a[i], a[j]);\n\t\t}\n\t}\n\tswap(a[i + 1], a[r]);\n\treturn i + 1;\n}\nvoid quick(pair<int, char> *a, int p, int r) {\n\tif (p < r) {\n\t\tint q = partition(a, p, r);\n\t\tquick(a, p, q - 1);\n\t\tquick(a, q + 1, r);\n\t}\n}\n\nll n;\nvector<pii> es[100010];\nint ci = 0;\nll P[1000010];\nstruct Node {\n\tint key;\n\tint priority;\n\tNode *parent, *left, *right;\n\tNode(int key, int priority);\n\tNode() {}\n};\nNode NIL;\nNode::Node(int key, int priority) : key(key), priority(priority) {\n\tleft = &NIL;\n\tright = &NIL;\n}\nNode* root = new Node();\nvoid cenrec(Node* k) {\n\tif (k->key == NIL.key) return;\n\tcenrec(k->left);\n\tcout << \" \" << k->key;\n\tcenrec(k->right);\n}\nvoid fastrec(Node* k)\n{\n\tif (k->key == NIL.key) return;\n\tcout << \" \" << k->key;\n\tfastrec(k->left);\n\tfastrec(k->right);\n}\nvoid insert(Node* v) {\n\tNode* y = &NIL;\n\tNode* x = root;\n\twhile (x->key != NIL.key)\n\t{\n\t\ty = x;\n\t\tif (v->key < x->key) {\n\t\t\tx = x->left;\n\t\t}\n\t\telse {\n\t\t\tx = x->right;\n\t\t}\n\t}\n\tv->parent = y;\n\tif (y->key == NIL.key) {\n\t\troot = v;\n\t}\n\telse if (v->key < y->key) {\n\t\ty->left = v;\n\t}\n\telse {\n\t\ty->right = v;\n\t}\n\n}\n\nNode* find(Node* k, ll v)\n{\n\tif (k->key == NIL.key) return &NIL;\n\tif (k->key == v) return k;\n\tif (v < k->key) return find(k->left, v);\n\treturn find(k->right, v);\n}\nvoid delp12(Node* x) {\n\tif (x->key == NIL.key)  return;\n\tNode* l = x->left;\n\tNode* r = x->right;\n\tNode* pr = x->parent;\n\n\tif (l->key == NIL.key\n\t\t&& r->key == NIL.key) {\n\t\tif (pr->left == x) {\n\t\t\tpr->left = &NIL;\n\t\t}\n\t\telse pr->right = &NIL;\n\t}\n\telse if (l->key != NIL.key) {\n\t\tif (pr->left == x) {\n\t\t\tpr->left = l;\n\t\t}\n\t\telse pr->right = l;\n\t\tl->parent = pr;\n\t}\n\telse if (r->key != NIL.key) {\n\t\tif (pr->left == x) {\n\t\t\tpr->left = r;\n\t\t}\n\t\telse pr->right = r;\n\t\tr->parent = pr;\n\t}\n}\nNode* get_next(Node* k) {\n\tif (k->key == NIL.key) return &NIL;\n\tNode* res = get_next(k->left);\n\tif (res->key != NIL.key) return res;\n\treturn k;\n}\nvoid del(Node* x) {\n\n\tif (x->key == NIL.key) return;\n\tNode* l = x->left;\n\tNode* r = x->right;\n\tNode* pr = x->parent;\n\n\tif (l->key != NIL.key && r->key != NIL.key) {\n\t\tNode* nex = get_next(r);\n\t\tx->key = nex->key;\n\t\tdelp12(nex);\n\t}\n\telse {\n\t\tdelp12(x);\n\t}\n}\nNode* rightRotate(Node *t) {\n\tNode* s = t->left;\n\tt->left = s->right;\n\ts->right = t;\n\treturn s;\n}\nNode* leftRotate(Node *t) {\n\tNode* s = t->right;\n\tt->right = s->left;\n\ts->left = t;\n\treturn s;\n}\nNode* _insert(Node *t, int key, int priority) {\n\tif (t->key == NIL.key) {\n\t\treturn new Node(key, priority);\n\t}\n\tif (key == t->key) {\n\t\treturn t;\n\t}\n\n\tif (key < t->key) {\n\t\tt->left = _insert(t->left, key, priority);\n\t\tif (t->priority < t->left->priority) {\n\t\t\tt = rightRotate(t);\n\t\t}\n\t}\n\telse {\n\t\tt->right = _insert(t->right, key, priority);\n\t\tif (t->priority < t->right->priority) {\n\t\t\tt = leftRotate(t);\n\t\t}\n\t}\n\treturn t;\n}\nNode* delete1(Node* t, int key);\nNode* _delete(Node *t, int key) {\n\tif (t->left->key == NIL.key && t->right->key == NIL.key) {\n\t\treturn &NIL;\n\t}\n\telse if (t->left->key == NIL.key) {\n\t\tt = leftRotate(t);\n\t}\n\telse if (t->right->key == NIL.key) {\n\t\tt = rightRotate(t);\n\t}\n\telse\n\t{\n\t\tif (t->left->priority > t->right->priority) {\n\t\t\tt = rightRotate(t);\n\t\t}\n\t\telse\n\t\t\tt = leftRotate(t);\n\t}\n\treturn delete1(t, key);\n}\nNode* delete1(Node* t, int key) {\n\tif (t->key == NIL.key) {\n\t\treturn &NIL;\n\t}\n\tif (key < t->key) {\n\t\tt->left = delete1(t->left, key);\n\t}\n\telse if (key > t->key) {\n\t\tt->right = delete1(t->right, key);\n\t}\n\telse return _delete(t, key);\n\treturn t;\n}\nint H;\nint left(int i) {\n\treturn i * 2 + 1;\n}\nint right(int i) {\n\treturn i * 2 + 2;\n}\n\nll heap[2000010];\nvoid maxHeapify(int i) {\n\tint l = left(i);\n\tint r = right(i);\n\tint largest = 0;\n\tif (l < H && heap[l] > heap[i])\n\t\tlargest = l;\n\telse\n\t\tlargest = i;\n\tif (r < H && heap[r] > heap[largest])\n\t\tlargest = r;\n\n\tif (largest != i) {\n\t\tswap(heap[i], heap[largest]);\n\t\tmaxHeapify(largest);\n\t}\n}\nint pare(int i) {\n\treturn (i - 1) / 2;\n}\nvoid raise(int i) {\n\tint l = pare(i);\n\tif (l < 0) return;\n\n\tif (heap[l] < heap[i]){\n\t\tswap(heap[i], heap[l]);\n\t\traise(l);\n\t}\n}\nvoid minHeapify(int i) {\n\tint l = left(i);\n\tint r = right(i);\n\tint minimam = 0;\n\tif (l < H && heap[l] < heap[i])\n\t\tminimam = l;\n\telse\n\t\tminimam = i;\n\tif (r < H && heap[r] < heap[minimam])\n\t\tminimam = r;\n\n\tif (minimam != i) {\n\t\tswap(heap[i], heap[minimam]);\n\t\tminHeapify(minimam);\n\t}\n}\nvoid buildMaxHeap() {\n\tfor (int i = H/2; i >= 0; i--)\n\t{\n\t\tmaxHeapify(i);\n\t}\n}\nll lcs(string s1, string s2) {\n\tll dp[1010][1010];\n\tmemset(dp, 0, sizeof(dp));\n\tint s1l = s1.size();\n\tint s2l = s2.size();\n\tfor (size_t i = 1; i <= s1l; i++)\n\t{\n\t\tfor (size_t j = 1; j <= s2l; j++)\n\t\t{\n\t\t\tif (s1[i - 1] == s2[j - 1]) {\n\t\t\t\tdp[i][j] = dp[i - 1][j - 1] + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[s1l][s2l];\n}\nstruct edge {\n\tll to, cap, rev;\n\tedge(int to,int cap,int rev) : to(to),cap(cap),rev(rev){}\n};\nstruct edge2 {\n\tll to, cost;\n\tedge2(int to, int cost) : to(to), cost(cost) {}\n};\nvector<edge> ed[100010];\nvoid addedge(int f, int t, int c) {\n\ted[f].push_back(edge(t, c, ed[t].size()));\n\ted[t].push_back(edge(f, 0, ed[f].size() - 1));\n}\nvector<int> es2[100010];\n\nll d[100010];\nvoid dij(int x) {\n\n\td[x] = 0;\n\tpriority_queue<pll, vector<pll>, greater<pll>> q;\n\tq.push(pll(0, x));\n\twhile (!q.empty())\n\t{\n\t\tpll p = q.top();\n\t\tq.pop();\n\t\tif (d[p.second] < p.first) continue;\n\t\tfor (auto v : ed[p.second]) {\n\t\t\tif (d[v.to] > d[p.second] + v.cap) {\n\t\t\t\td[v.to] = d[p.second] + v.cap;\n\t\t\t\tq.push(pll(d[v.to], v.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint tb[5][5];\nint ex[5][5];\npair<int, int> mdv[16];\nint check() {\n\tint p = 1;\n\tint wc = 0;\n\tfor (size_t i = 0; i < 4; i++)\n\t{\n\t\tfor (size_t j = 0; j < 4; j++)\n\t\t{\n\t\t\tif (tb[i][j] != p) wc++;\n\t\t\tp++;\n\t\t\tp %= 16;\n\t\t}\n\t}\n\treturn wc;\n}\n\nint lim = 45;\nint md = 0;\nint dx[] = { -1,0,1,0 };\nint dy[] = { 0,-1,0,1 };\nint res = INF;\nint calcMd(int x, int y, int v) {\n\n\treturn abs(mdv[v].first - x) + abs(mdv[v].second - y);\n}\nvoid rec(int x, int y, int deep) {\n\n\tif (deep >= res) return;\n\tif (deep > lim) return ;\n\tif (check() == 0) {\n\t\tres = deep;\n\t\treturn;\n\t}\n\n\tfor (size_t i = 0; i < 4; i++)\n\t{\n\t\tif (deep >= res) return;\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (tx < 0 || ty < 0 || tx >= 4 || ty >= 4) continue;\n\t\tint bef = calcMd(tx, ty, tb[tx][ty]);\n\t\tswap(tb[tx][ty], tb[x][y]);\n\t\tint af = calcMd(x, y, tb[x][y]);\n\t\tif (deep + md - bef + af <= lim) {\n\t\t\tmd -= bef;\n\t\t\tmd += af;\n\t\t\trec(tx, ty, deep + 1);\n\t\t\tmd += bef;\n\t\t\tmd -= af;\n\t\t\tfor (size_t j = 0; j < 4; j++)\n\t\t\t{\n\t\t\t\tfor (size_t k = 0; k < 4; k++)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tcout << \" \" << tb[j][k];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\tswap(tb[tx][ty], tb[x][y]);\n\n\t}\n}\ndouble leng(double x1, double x2, double y1, double y2) {\n\treturn sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n}\n\n\ndouble calc(double x1, double x2, double x3, double y1, double y2, double y3) {\n\n\tdouble high = 1;\n\tdouble low = 0;\n\tif (x1 > x2) {\n\t\tswap(x1, x2);\n\t\tswap(y1, y2);\n\t}\n\tdouble a = (y2 - y1) / (x2 - x1);\n\tdouble l1 = leng(x1,x3,y1,y3);\n\tdouble lp = leng(x2, x3, y2, y3);\n\tdouble c = y2 - a * x2;\n\tdouble b = x2 - x1;\n\tdouble miny = min(y1, y2);\n\tdouble maxy = max(y1, y2);\n\tint count = 0;\n\tdouble r = 0;\n\tdouble r2 = INF;\n\twhile (count < 10000)\n\t{\n\t\tdouble mid = (high + low) / 2.0;\n\t\tdouble x4 = b * mid + x1;\n\t\tdouble y4 = x4 * a + c;\n\t\tdouble l2 = leng(x1, x4, y1, y4);\n\t\tdouble l3 = leng(x3, x4, y3, y4);\n\t\tdouble l4 = leng(x2, x4, y2, y4);\n\n\t\tdouble ss = (l1 + l2 + l3) / 2.0;\n\t\tdouble S = sqrt(ss * (ss - l1) * (ss - l2) * (ss - l3));\n\n\t\tdouble ss2 = (l4 + lp + l3) / 2.0;\n\t\tdouble S2 = sqrt(ss2 * (ss2 - l4) * (ss2 - lp) * (ss2 - l3));\n\t\tr = (2 * S) / (l1 + l2 + l3);\n\t\tr2 = (2 * S2) / (l4 + lp + l3);\n\t\tif (r < r2 ) {\n\t\t\tlow = mid;\n\t\t}\n\t\telse if(r > r2){\n\t\t\thigh = mid;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t\tcount++;\n\t}\n\treturn r2;\n}\nll t[200010];\nchar c[2010];\nll dis[200010];\nstruct tedge {\n\tint to, cost, d;\n\ttedge(int to, int cost, int d) :to(to), cost(cost), d(d) {}\n};\nvector<tedge> tes[200010];\nvoid dij2(int si) {\n\tfill(dis, dis + si + 1, INF * INF);\n\tpriority_queue<pll, vector<pll>, greater<pll>> q;\n\tdis[1] = 0;\n\tq.push(make_pair(0, 1));\n\twhile (!q.empty()) {\n\t\tpll p = q.top();\n\t\tq.pop();\n\t\tif (p.first > dis[p.second]) continue;\n\t\t\n\t\tfor (auto v : tes[p.second]) {\n\t\t\tll ar = p.first + t[p.second];\n\t\t\tll a = v.d - (ar % v.d);\n\t\t\tif (a == v.d) a = 0;\n\t\t\tll nc = ar + a + v.cost;\n\t\t\tif (nc < dis[v.to]) {\n\t\t\t\tdis[v.to] = nc;\n\t\t\t\tq.push(make_pair(dis[v.to], v.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint pi = 0;\npll prim[15];\nint rec(ll a,ll k,int i,ll val) {\n\tif (i == pi) {\n\t\tif (k == ((a - (2 * val))* val)) {\n\t\t\treturn val;\n\t\t}else return -1;\n\t}\n\tint res = -1;\n\tfor (size_t j = 0; j <= prim[i].second; j++)\n\t{\n\t\tres = max(res, rec(a, k, i + 1, val * pow(prim[i].first, j)));\n\t}\n\treturn res;\n}\n\nint W;\n\nint k;\nll calc(vector<vector<int>> tb,int x, int y) {\n\n\tll res = 0;\n\tint rd = 0;\n\ttb[x].erase(tb[x].begin() + y);\n\twhile (true)\n\t{\n\t\tbool update = false;\n\t\tpii dellist[30];\n\t\tint p = 0;\n\t\tfor (int j = 0; j < H; j++)\n\t\t{\n\t\t\tint co = 0;\n\t\t\tint bef = -1;\n\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t{\n\t\t\t\tif (tb[i].size()  < j + 1) {\n\t\t\t\t\tif (co >= k) {\n\t\t\t\t\t\tdellist[p].first = j;\n\t\t\t\t\t\tdellist[p].second = i - 1;\n\t\t\t\t\t\tp++;\n\t\t\t\t\t}\n\t\t\t\t\tco = 0;\n\t\t\t\t\tbef = -1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (tb[i][j] == bef) {\n\t\t\t\t\tco++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (co >= k) {\n\t\t\t\t\t\tdellist[p].first = j;\n\t\t\t\t\t\tdellist[p].second = i - 1;\n\t\t\t\t\t\tp++;\n\t\t\t\t\t}\n\t\t\t\t\tco = 1;\n\t\t\t\t}\n\t\t\t\tbef = tb[i][j];\n\t\t\t}\n\n\t\t\tif (co >= k) {\n\t\t\t\tdellist[p].first = j;\n\t\t\t\tdellist[p].second = W - 1;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tif (p == 0) break;\n\t\tfor (int i = p-1; i >= 0 ;i--)\n\t\t{\n\t\t\tll j = dellist[i].second;\n\t\t\tll jj = dellist[i].first;\n\t\t\tll v = tb[j][jj];\n\t\t\ttb[j].erase(tb[j].begin() + jj);\n\t\t\tint c = 1;\n\t\t\tfor (int t = j - 1; t >= 0; t--)\n\t\t\t{\n\t\t\t\tif (tb[t].size() < jj + 1) break;\n\t\t\t\tif (tb[t][jj] != v) break;\n\t\t\t\ttb[t].erase(tb[t].begin() + jj);\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tres += (v * c) * pow(2, rd);\n\t\t}\n\t\trd++;\n\t}\n\treturn res;\n}\nvoid solv() {\n\n\tcin >> H >> W >> k;\n\tstring sr[31];\n\tfor (size_t i = 0; i < H; i++)\n\t{\n\t\tcin >> sr[i];\n\t}\n\n\tvector<vector<int>> table(W,vector<int>());\n\tfor (int j = 0; j < W; j++)\n\t{\n\n\t\tfor (int i = H-1; i >= 0; i--)\n\t\t{\n\t\t\ttable[j].push_back(sr[i][j] - '0');\n\t\t}\n\t}\n\tll res = 0;\n\tfor (size_t i = 0; i < H; i++)\n\t{\n\t\tfor (size_t j= 0; j < W; j++)\n\t\t{\n\t\t\tres = max(res, calc(table, j, i));\n\t\t}\n\t}\n\tcout << res << endl;\n}\n\nint main() {\n\t//COMinit();\n\tsolv();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC diagnostic ignored \"-Wunused-variable\" \n#include <bits/stdc++.h>\nusing namespace std;\n\n#define BOOST\n#ifdef BOOST\n#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/multiprecision/cpp_dec_float.hpp>\n#include <boost/range/adaptor/reversed.hpp>\nusing namespace boost;\nusing ml = boost::multiprecision::cpp_int;\nusing md = boost::multiprecision::cpp_dec_float_100;\n#define forir(i, ...) if(ll i=(ll)v.size())for(__VA_ARGS__)if(i--,1)\n#define eachr(i, e, c) forir(i, auto &&e: adaptors::reverse(c))\n#endif\n\n/***** type *****/\nusing ll = long long;\nusing ld = long double;\nusing pll = pair<long long, long long>;\ntemplate <class T> using vt = vector<T>;\ntemplate <class T> using vvt = vector<vector<T>>;\ntemplate <class T> using vvvt = vector<vector<vector<T>>>;\n/***** define *****/\n#define all(c) (c).begin(), (c).end()            // begin to end\n#define coutd cout << fixed << setprecision(10)  // cout double\n#define output(x) do{cout<<x;return 0;}while(0)  // cout return\n#define rep(i, b, e) for (ll i = b; i < e; i++)  // repeat\n#define repr(i, b, e) for (ll i = b; e < i; i--) // repeat reverse\n#define fori(i, ...) if (ll i = -1) for(__VA_ARGS__) if (i++, 1)\n#define each(i, e, c) fori (i, auto&& e: c)      // for each\n/***** const value *****/\n#define llong_max 9223372036854775807            // 9 * 10^18\n#define ldbl_max 1.79769e+308                    // 1.7 * 10^308\n#define pi 3.1415926535897932                    // 3.14 ...\n/***** lambda *****/\nauto Ceil = [] // if (a % b != 0) return a / b + 1;\n(auto x) { return (ll)ceil(x); };\nauto Count = [] // long long count value\n(auto b, auto e, auto x) { return (ll)count(b, e, x); };\nauto CtoL = [] // char to number\n(auto c) { return (ll)c - (ll)'0'; };\nauto LtoC = [] // number to char\n(auto n) { return (char)('0' + n); };\nauto Pow = [] // long long pow\n(auto a, auto b) { return (ll)pow(a, b); };\nauto Pow2 = [] // long long pow2\n(auto n) { return (1LL << n); };\nauto Pow10 = [] // long long pow10\n(auto n) { return (ll)pow(10, n); };\nauto Size = []  // long long collection size\n(auto& c) { return (ll)(c).size(); };\nauto Sum = [] // long long accumulate\n(auto b, auto e) { return accumulate(b, e, 0LL); };\n\n/***** template *****/\ntemplate <class T> void MakeVVT\n(ll ys, ll xs, vvt<T>& v, T fill = T())\n{\t// vector<vector<T>> resize + fill\n\tv.resize(ys); rep(y, 0, ys) v[y].resize(xs, fill);\n}\ntemplate <class T> void MakeVVVT\n(ll zs, ll ys, ll xs, vvvt<T>& v, T fill = T())\n{\t// vector<vector<vector<T>>> resize + fill\n\tv.resize(zs); rep(z, 0, zs) MakeVVT(ys, xs, v[z], fill);\n}\ntemplate <class T> void InputVT\n(ll xs, vt<T>& v, T fix = T())\n{\t// input vector<T> (T != struct) + fix\n\tv.resize(xs); rep(i, 0, xs) { cin >> v[i]; v[i] += fix; }\n}\ntemplate <class T> void InputVVT\n(ll ys, ll xs, vvt<T>& v, T fix = T())\n{\t// input vector<vector<T>> (T != struct) + fix\n\tMakeVVT(ys, xs, v, fix);\n\trep(y, 0, ys) rep(x, 0, xs) { cin >> v[y][x]; v[y][x] += fix; }\n}\ntemplate <class T> void InputVVVT\n(ll zs, ll ys, ll xs, vvvt<T>& v, T fix = T())\n{\t// input vector<vector<vector<T>>> (T != struct) + fix\n\tv.resize(zs); rep(z, 0, zs) InputVVT(ys, xs, v[z], fix);\n}\n\n/**************************************/\n/********** BEGIN OF NYA LIB **********/\n/**************************************/\n\nnamespace NyaGadget {}\n\nnamespace NyaGadget\n{\n\t/*** ランレングス圧縮ライブラリ ***/\n\n\ttemplate <class T> struct RunLengthEncodingResult\n\t{\t// ランレングス圧縮の結果を格納する構造体\n\t\tlong long begin = 0; // 区間開始位置\n\t\tlong long end = 0;   // 区間終了位置\n\t\tstd::vector<T> sub;  // 区間データ\n\t};\n\n\ttemplate <> struct RunLengthEncodingResult<std::string>\n\t{\t// ランレングス圧縮の結果を格納する構造体\n\t\tlong long begin = 0; // 区間開始位置\n\t\tlong long end = 0;   // 区間終了位置\n\t\tstd::string sub;     // 区間データ\n\t};\n\n\tstruct DS_NyaaRLE\n\t{\n\t\t/**\n\t\t@brief 文字列のランレングス圧縮\n\t\t@param s 圧縮する文字列\n\t\t@param res 圧縮結果\n\t\t**/\n\t\tstatic void Run(std::string& s, std::vector<RunLengthEncodingResult<std::string>>& res)\n\t\t{\n\t\t\tres.push_back({ 0, 0, \"\" });\n\t\t\tfor (long long i = 0; i < (long long)s.size(); i++)\n\t\t\t{\n\t\t\t\tif (i == (long long)s.size() - 1)\n\t\t\t\t{\n\t\t\t\t\tres.back().end = i + 1;\n\t\t\t\t\tres.back().sub = s.substr(res.back().begin, i + 1 - res.back().begin);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (s[i] != s[i + 1])\n\t\t\t\t{\n\t\t\t\t\tres.back().end = i + 1;\n\t\t\t\t\tres.back().sub = s.substr(res.back().begin, i + 1 - res.back().begin);\n\t\t\t\t\tres.push_back({ i + 1, 0, \"\" });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t@brief 配列のランレングス圧縮\n\t\t@param v 圧縮する配列\n\t\t@param res 圧縮結果\n\t\t**/\n\t\ttemplate <class T> static void Run(std::vector<T>& v, std::vector<RunLengthEncodingResult<T>>& res)\n\t\t{\n\t\t\tres.push_back({ 0, 0, std::vector<T>() });\n\t\t\tfor (long long i = 0; i < (long long)v.size(); i++)\n\t\t\t{\n\t\t\t\tif (i == (long long)v.size() - 1)\n\t\t\t\t{\n\t\t\t\t\tres.back().end = i + 1;\n\t\t\t\t\tfor (long long j = res.back().begin; j < i + 1; j++) res.back().sub.push_back(v[j]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!IsSame(v[i], v[i + 1]))\n\t\t\t\t{\n\t\t\t\t\tres.back().end = i + 1;\n\t\t\t\t\tfor (long long j = res.back().begin; j < i + 1; j++) res.back().sub.push_back(v[j]);\n\t\t\t\t\tres.push_back({ i + 1, 0, std::vector<T>() });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttemplate <class T> static bool IsSame(T& l, T& r)\n\t\t{\t// lとrが同値かどうか調べる\n\t\t\treturn l == r;\n\t\t}\n\t};\n}\n\n/**************************************/\n/*********** END OF NYA LIB ***********/\n/**************************************/\n\nusing namespace NyaGadget;\n//using mll = NT_ModLL< 1000000007 >;\n//using mll = NT_ModLL< 998244353 >;\n\nvoid NyaaDelete(vvt<ll>& grid, ll K, ll& res)\n{\n\tll count = 0;\n\tll W = Size(grid);\n\tll H = Size(grid[0]);\n\twhile (1)\n\t{\n\t\tll score = 0;\n\t\trep(y, 0, H)\n\t\t{\n\t\t\tvt<ll> test(W);\n\t\t\trep(x, 0, W) test[x] = grid[x][y];\n\t\t\tstd::vector<RunLengthEncodingResult<ll>> rleRes;\n\t\t\tDS_NyaaRLE::Run(test, rleRes);\n\n\t\t\teach(i, e, rleRes)\n\t\t\t{\n\t\t\t\tif (e.sub[0] == 0) continue;\n\t\t\t\tif (K <= Size(e.sub))\n\t\t\t\t{\n\t\t\t\t\trep(xx, e.begin, e.end) grid[xx][y] = 0;\n\t\t\t\t\tscore = Pow2(count) * e.sub[0] * Size(e.sub);\n\t\t\t\t\tres += score;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvvt<ll> test; MakeVVT(W, H, test);\n\t\trep(x, 0, W)\n\t\t{\n\t\t\tll yy = 0;\n\t\t\trep(y, 0, H) if (grid[x][y] != 0) test[x][yy++] = grid[x][y];\n\t\t}\n\t\tgrid = test;\n\t\tif (score == 0) return;\n\t\t++count;\n\t}\n}\n\nint main(void)\n{\n\tll H, W, K; cin >> H >> W >> K;\n\tvvt<ll> c; MakeVVT(W, H, c);\n\trepr(y, H - 1, -1)\n\t{\n\t\tstring test; cin >> test;\n\t\trep(x, 0, W) c[x][y] = CtoL(test[x]);\n\t}\n\n\tll ans = 0;\n\trep(x, 0, W) rep(y, 0, H)\n\t{\n\t\tvvt<ll> test = c;\n\t\trep(yy, y + 1, H) test[x][yy - 1] = test[x][yy];\n\t\ttest[x].back() = 0;\n\t\tll res = 0;\n\n\t\tNyaaDelete(test, K, res);\n\t\tans = max(ans, res);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <limits>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <iomanip>\n\nusing namespace std;\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define eprintf(...) 42\n#endif\nusing ll = long long;\nusing vll = std::vector<ll>;\nusing vvll = std::vector<vll>;\nusing vvvll = std::vector<vvll>;\n#define reps(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, N) reps(i, 0, N-1)\n#define deps(i, E, S) for (ll i = (E); i >= (S); i--)\n#define dep(i, N) deps(i, N-1, 0)\nconst ll INF = 1LL << 60;\nconst int INF_INT = 1 << 30;\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\nstruct mll {\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0) : val(v % MOD) { if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tmll &operator += (const mll &b) { val = (val + b.val) % MOD; return *this; }\n\tmll &operator -= (const mll &b) { val = (val + MOD - b.val) % MOD; return *this; }\n\tmll &operator *= (const mll &b) { val = (val*b.val) % MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c = b.val, d = MOD, u = 1, v = 0;\n\t\twhile (d) {\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b) {\n\t\tchmin(b, a - b);\n\t\tif (b < 0) return mll(0);\n\t\tmll c = 1;\n\t\trep(i, b) c *= a - i;\n\t\trep(i, b) c /= i + 1;\n\t\treturn c;\n\t}\n};\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\n\nstruct Fast {\n\tFast() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast; //cin,cout高速化のおまじない＋桁数指定\n\nll mll::MOD = (ll)(1e9 + 7);// 998244353ll;\n\n\nll LLpow(ll x, ll n) {\n\tll ret = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) {\n\t\t\tret *= x;\n\t\t}\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nll solve(vvll &block, ll y, ll x, ll K) {\n\tll H = block.size();\n\tll W = block[0].size();\n\tvvll B(H, vll(W));\n\trep(i, H) rep(j, W) {\n\t\tB[i][j] = block[i][j];\n\t}\n\tll ans = 0;\n\tll times = 0;\n\n\tvector<vector<bool>> v(H, vector<bool>(W, false));\n\tv[y][x] = true;\n\n\teprintf(\"\\n<>--%lld, %lld--<>\", y, x);\n\n\twhile (true) {\n\t\t//eprintf(\"\\n[%lld]\\n\", times-1);\n\t\t//rep(i, H) {\n\t\t//\trep(j, W) {\n\t\t//\t\teprintf(\"%lld \", B[i][j]);\n\t\t//\t}\n\t\t//\teprintf(\"\\n\");\n\t\t//}\n\n\t\t//eprintf(\"vanish\\n\");\n\t\t//rep(i, H) {\n\t\t//\trep(j, W) {\n\t\t//\t\teprintf(\"%s \", v[i][j] ? \"#\" : \".\");\n\t\t//\t}\n\t\t//\teprintf(\"\\n\");\n\t\t//}\n\n\t\t//vanish->fall\n\t\trep(i, W) {\n\t\t\tdep(j, H) {\n\t\t\t\tif (v[j][i]) {\n\t\t\t\t\tv[j][i] = false;\n\t\t\t\t\tbool fall = false;\n\t\t\t\t\tdeps(k, j - 1, 0) {\n\t\t\t\t\t\tif (B[k][i] > 0 && v[k][i] == false) {\n\t\t\t\t\t\t\tfall = true;\n\t\t\t\t\t\t\tB[j][i] = B[k][i];\n\t\t\t\t\t\t\tv[k][i] = true;\n\t\t\t\t\t\t\tB[k][i] = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (B[k][i] == 0) {\n\t\t\t\t\t\t\tB[j][i] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//eprintf(\"fallen\\n\");\n\t\t//rep(i, H) {\n\t\t//\trep(j, W) {\n\t\t//\t\teprintf(\"%lld \", B[i][j]);\n\t\t//\t}\n\t\t//\teprintf(\"\\n\");\n\t\t//}\n\n\t\t//vanish\n\t\tll vnum = 0;\n\t\treps(j, 1, H - 1) {\n\t\t\tll s = 0;\n\t\t\tll e = -1;\n\t\t\tll hold = 0;\n\t\t\twhile (true) {\n\t\t\t\te++;\n\t\t\t\tif (e >= W || B[j][e] != hold ) {\n\t\t\t\t\t//sからe-1までが同じ数字\n\t\t\t\t\tif (s < e && hold != 0) {\n\t\t\t\t\t\tif (e - s >= K) {\n\t\t\t\t\t\t\t//消える\n\t\t\t\t\t\t\tvnum += (e - s) * hold;\n\t\t\t\t\t\t\treps(i, s, e - 1) {\n\t\t\t\t\t\t\t\tv[j][i] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (e >= W) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\thold = B[j][e];\n\t\t\t\t\t\ts = e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans += vnum * LLpow(2, times);\n\t\ttimes++;\n\n\t\tif (vnum == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\teprintf(\"\\nScore:%lld\\n\", ans);\n\n\treturn ans;\n}\n\nint main() {\n\tll H;\n\tcin >> H;\n\tll W;\n\tcin >> W;\n\tll K;\n\tcin >> K;\n\tvvll block(H, vll(W));\n\trep(i, H){\n\t\tstring S;\n\t\tcin >> S;\n\t\trep(j, W) {\n\t\t\tblock[i][j] = S[j] - '0';\n\t\t}\n\t}\n\n\tll result = 0;\n\n\treps(i, 1, H - 1) rep(j, W) {\n\t\tchmax(result, solve(block, i, j, K));\n\t}\n\n\tcout << result << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(long long int (i)=0;(i)<(int)(n);(i)++)\n#define rrep(i,a,b) for(long long int i=(a);i<(b);i++)\n#define rrrep(i,a,b) for(long long int i=(a);i>=(b);i--)\n#define all(v) (v).begin(), (v).end()\n#define pb(q) push_back(q)\n#define Abs(a,b) max(a,b)-min(a,b)\n#define YES(condition) if(condition){cout << \"YES\" << endl;}else{cout << \"NO\" << endl;}\n#define Yes(condition) if(condition){cout << \"Yes\" << endl;}else{cout << \"No\" << endl;}\n#define Cout(x) cout<<(x)<<endl\n#define POSSIBLE(condition) if(condition){cout << \"POSSIBLE\" << endl;}else{cout << \"IMPOSSIBLE\" << endl;}\n#define Possible(condition) if(condition){cout << \"Possible\" << endl;}else{cout << \"Impossible\" << endl;}\n#define possible(condition) if(condition){cout << \"possible\" << endl;}else{cout << \"impossible\" << endl;}\n#define Size(n) (n).size()\n\ntypedef long long ll;\n\n\nusing namespace std;\n\nconst int INF = 1e9,MOD = 1e9 + 7,ohara=1e6;\nconst ll LINF = 1e18;\n\n/*---------------------------------------------------------------\nlong long int kaizyo(long long int hh){\n    cmp=1;\n    while(hh>1){\n        cmp=(cmp*hh)%MOD;\n        hh--;\n    }\n    return cmp;\n}\nlong long int ruizyo(long long int aa, long long int bb){\n    if(aa==0){\n        return 1;\n    }\n    else if(aa%2==0){\n        long long int tt=ruizyo(aa/2,bb);\n        return (tt*tt)%MOD;\n    }\n    else{\n        return (ruizyo(aa-1,bb)*bb)%MOD;\n    }\n}フェルマ－のア\n---------------------------------------------------------------\n\nwhile(x!=0){\n            sum+=x%10;\n          / x/=10;\n        }\n        各桁の和\n---------------------------------------------------------------\n\npair<int,int> p[100000];\ncin >> tmp;\np[i]=make_pair(tmp,i);\ncout << p[i].second+1 << endl;//ペアの右側つまりiを出力\n\n---------------------------------------------------------------\n\nbool f[100001];//1000000以下の素数を調べよう！\nrrep(i,2,100001){\n       f[i]=false;\n    }\nrrep(i,2,100001){\n        if(!f[i]){\n            for(int j=i+i;j<=100000;j+=i){\n                f[j]=true;\n            }\n        }\n    }\n    for(int i=3;i<=100000;i+=2){\n        if(!f[i]){\n            c[i]++;\n        }\n    }\n\n---------------------------------------------------------------\n\nlong long gcd(long long aaa,long long bbb){\n    if(bbb==0){\n        return aaa;\n    }\n    return gcd(bbb,aaa%bbb);\n}\n \nlong long lcm(long long aaa,long long bbb){\n    long long g = gcd(aaa,bbb);\n    return aaa/g * bbb;\n}左から最大公約数と最小公倍数\n\n\n---------------------------------------------------------------\n\nlong long int prime_cnt[10000];\n       for(int i=2;i*i<=n;i++){\n           while(n%i==0){\n               n/=i;\n               prime_cnt[i]+=1;\n           }\n           if(n>1){\n               prime_cnt[n]+=1;\n               break;\n           }\n      }ある数nを素因数分解しましょう\n\n---------------------------------------------------------------\ndebug:\ncout<<\"i: \"<<i<<\" j: \"<<j<<\" cnt: \"<<cnt<<\"\\n\";\n\n---------------------------------------------------------------*/\n\nlong long int n,cnt=0,ans=0,a,b,c,d,cmp[100][100],cmpp[100][100],m,h,w,sum=0,pos,k;\nint dy[]={1,0,-1,0};\nint dx[]={0,1,0,-1};\nstring alph(\"abcdefghijklmnopqrstuvwxyz\"),s;\nbool fl=true;\nstruct edge{int to,cost;};\n\n//-------------------------↓↓↓↓↓↓------------------------\n\nint main(void){\n       cin.tie(0);\n    ios::sync_with_stdio(false);\n\n      \n       cin>>h>>w>>k;\n  \t\tans=0;\n       rep(i,h){\n           cin>>s;\n           rep(j,w){\n               cmp[i][j]=(s[j]-'0');\n           }\n       }\n      \n      ll cntt=0,val=0;\n      rep(i,h){\n          rep(j,w){\n\n              rep(y,h){\n                  rep(x,w){\n                      cmpp[y][x]=cmp[y][x];\n                  }\n              }\n            \n            rrrep(y,i,0){\n                if(y==0){\n                    cmpp[y][j]=0;\n                }\n                else{\n                    cmpp[y][j]=cmpp[y-1][j];\n                }\n            }\n\n           while(1){\n               bool ok=false;\n               rep(y,h){\n                   cntt=1;\n                   rep(x,w){\n                       if(cmpp[y][x]==cmpp[y][x+1]){\n                           cntt++;\n                       }\n                       if(x==w-1||cmpp[y][x]!=cmpp[y][x+1]){\n                           if(cntt>=k){\n                               cnt+=cmpp[y][x]*cntt*pow(2,val);\n                              // cout<<cmpp[y][x]<<\" \"<<cntt<<\" \"<<pow(2,val)<<\"\\n\";\n                               cntt=1;\n                               if(cmpp[y][x]!=0){\n                               ok=true;\n                               }\n                           }\n                            cntt=1;\n                       }\n                   }\n               }\n\n               rep(y,h){\n                   cntt=1;\n                   ll le=0,ri=0;\n                   rep(x,w){\n                       if(cmpp[y][x]==cmpp[y][x+1]&&cmpp[y][x]!=0){\n                           cntt++;\n                           ri++;\n                       }\n                        if(x==w-1||cmpp[y][x]!=cmpp[y][x+1]){\n                            if(cmpp[y][x]==0){\n                                  le=x+1;\n                               ri=le;\n                           cntt=1;\n                           continue;\n                            }\n                           if(cntt>=k){\n                               rrrep(yy,y,0){\n                               rrep(xx,le,ri+1){\n                                   if(yy==0){\n                                       cmpp[yy][xx]=0;\n                                   }\n                                   else{\n                                   cmpp[yy][xx]=cmpp[yy-1][xx];\n                                   }\n                               }\n                               }\n                           }\n                               le=x+1;\n                               ri=le;\n                           cntt=1;\n                       }\n                   }\n               }\n\n               if(!ok)break;\n               val++;\n           }\n           ans=max(ans,cnt);\n           cnt=0;\n           val=0;\n\n          }\n      }\n      Cout(ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<string>\n#include<sstream>\n#include<cmath>\n#include<numeric>\n#include<map>\n#include<stack>\n#include<queue>\n#include<list>\n#include<set>\nusing namespace std;\nint mod = 1e9+7;\nint h, w, k;\nvector<string> c;\nchar B = '-';\n\nvoid show(vector<string> b) {\n  for(int i=0; i<h; i++) cerr << b[i] << endl;\n  cerr << endl;\n}\n\nvector<string> del(vector<string> b) {\n  vector<string> ret = b;\n  for(int i=0; i<h; i++){\n    string s = ret[i];\n    int cnt = 1;\n    for(int j=0; j<w; j++){\n      if( s[j] == s[j+1] ) cnt++;\n      else {\n        if( cnt >= k ) {\n          for(int l=0; l<cnt; l++){\n            s[j-l] = B;\n          }\n        }\n        cnt = 1;\n      }\n    }\n    ret[i] = s;\n  }\n  return ret;\n}\n\nvector<string> drop(vector<string> b) {\n  for(int j=0; j<w; j++){\n    string s = \"\";\n    for(int i=0; i<h; i++){\n      if( b[i][j] != B ) {\n        s += b[i][j];\n      }\n    }\n    s = string(h-s.size(), B) + s;\n    for(int i=0; i<h; i++){\n      b[i][j] = s[i];\n    }\n  }\n  return b;\n}\n\nint calc(vector<string> b) {\n  int ret = 0;\n  for(int i=0; i<h; i++) {\n    for(int j=0; j<w; j++){\n      if( b[i][j] == B ) continue;\n      ret += b[i][j]-'0';\n    }\n  }\n  return ret;\n}\n\nint simulate(vector<string> b, int x, int y) {\n\n  b[y][x] = B;\n  b = drop(b);\n  vector<string> old = b;\n  vector<string> now = b;\n  int score = 0;\n  int base = 1;\n  while( true ) {\n    now = del(now);\n    int sum = calc(old) - calc(now);\n    score += base * sum;\n    now = drop(now);\n\n    if( now == old ) break;\n    old = now;\n    base *= 2;\n  }\n  show(now);\n  return score;\n}\n\nint main() {\n  cin >> h >> w >> k;\n  c.resize(h);\n  for(int i=0; i<h; i++){\n    cin >> c[i];\n    c[i] += B;\n  }\n\n  int ans = 0;\n  for(int i=0; i<h; i++){\n    for(int j=0; j<w; j++){\n      int tmp = simulate(c, j, i);\n      if( ans < tmp ){\n        cerr << tmp << \" \" << j << \" \" << i << endl;\n      }\n      ans = max(ans, tmp);\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n\n\n\n//\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(long long int (i)=0;(i)<(int)(n);(i)++)\n#define rrep(i,a,b) for(long long int i=(a);i<(b);i++)\n#define rrrep(i,a,b) for(long long int i=(a);i>=(b);i--)\n#define all(v) (v).begin(), (v).end()\n#define pb(q) push_back(q)\n#define Abs(a,b) max(a,b)-min(a,b)\n#define YES(condition) if(condition){cout << \"YES\" << endl;}else{cout << \"NO\" << endl;}\n#define Yes(condition) if(condition){cout << \"Yes\" << endl;}else{cout << \"No\" << endl;}\n#define Cout(x) cout<<(x)<<endl\n#define POSSIBLE(condition) if(condition){cout << \"POSSIBLE\" << endl;}else{cout << \"IMPOSSIBLE\" << endl;}\n#define Possible(condition) if(condition){cout << \"Possible\" << endl;}else{cout << \"Impossible\" << endl;}\n#define possible(condition) if(condition){cout << \"possible\" << endl;}else{cout << \"impossible\" << endl;}\n#define Size(n) (n).size()\n\ntypedef long long ll;\n\n\nusing namespace std;\n\nconst int INF = 1e9,MOD = 1e9 + 7,ohara=1e6;\nconst ll LINF = 1e18;\n\n/*---------------------------------------------------------------\nlong long int kaizyo(long long int hh){\n    cmp=1;\n    while(hh>1){\n        cmp=(cmp*hh)%MOD;\n        hh--;\n    }\n    return cmp;\n}\nlong long int ruizyo(long long int aa, long long int bb){\n    if(aa==0){\n        return 1;\n    }\n    else if(aa%2==0){\n        long long int tt=ruizyo(aa/2,bb);\n        return (tt*tt)%MOD;\n    }\n    else{\n        return (ruizyo(aa-1,bb)*bb)%MOD;\n    }\n}フェルマ－のア\n---------------------------------------------------------------\n\nwhile(x!=0){\n            sum+=x%10;\n          / x/=10;\n        }\n        各桁の和\n---------------------------------------------------------------\n\npair<int,int> p[100000];\ncin >> tmp;\np[i]=make_pair(tmp,i);\ncout << p[i].second+1 << endl;//ペアの右側つまりiを出力\n\n---------------------------------------------------------------\n\nbool f[100001];//1000000以下の素数を調べよう！\nrrep(i,2,100001){\n       f[i]=false;\n    }\nrrep(i,2,100001){\n        if(!f[i]){\n            for(int j=i+i;j<=100000;j+=i){\n                f[j]=true;\n            }\n        }\n    }\n    for(int i=3;i<=100000;i+=2){\n        if(!f[i]){\n            c[i]++;\n        }\n    }\n\n---------------------------------------------------------------\n\nlong long gcd(long long aaa,long long bbb){\n    if(bbb==0){\n        return aaa;\n    }\n    return gcd(bbb,aaa%bbb);\n}\n \nlong long lcm(long long aaa,long long bbb){\n    long long g = gcd(aaa,bbb);\n    return aaa/g * bbb;\n}左から最大公約数と最小公倍数\n\n\n---------------------------------------------------------------\n\nlong long int prime_cnt[10000];\n       for(int i=2;i*i<=n;i++){\n           while(n%i==0){\n               n/=i;\n               prime_cnt[i]+=1;\n           }\n           if(n>1){\n               prime_cnt[n]+=1;\n               break;\n           }\n      }ある数nを素因数分解しましょう\n\n---------------------------------------------------------------\ndebug:\ncout<<\"i: \"<<i<<\" j: \"<<j<<\" cnt: \"<<cnt<<\"\\n\";\n\n---------------------------------------------------------------*/\n\nlong long int n,cnt=0,ans=0,a,b,c,d,cmp[100][100],cmpp[100][100],m,h,w,sum=0,pos,k;\nint dy[]={1,0,-1,0};\nint dx[]={0,1,0,-1};\nstring alph(\"abcdefghijklmnopqrstuvwxyz\"),s;\nbool fl=true;\nstruct edge{int to,cost;};\n\n//-------------------------↓↓↓↓↓↓------------------------\n\nint main(void){\n       cin.tie(0);\n    ios::sync_with_stdio(false);\n\n      \n       cin>>h>>w>>k;\n  \t\tans=0;\n       rep(i,h){\n           cin>>s;\n           rep(j,w){\n               cmp[i][j]=(s[j]-'0');\n           }\n       }\n      \n      ll cntt=0,val=0;\n      rep(i,h){\n          rep(j,w){\n\n              rep(y,h){\n                  rep(x,w){\n                      cmpp[y][x]=cmp[y][x];\n                  }\n              }\n            \n            rrrep(y,i,0){\n                if(y==0){\n                    cmpp[y][j]=0;\n                }\n                else{\n                    cmpp[y][j]=cmpp[y-1][j];\n                }\n            }\n\n           while(1){\n               bool ok=false;\n               rep(y,h){\n                   cntt=1;\n                   rep(x,w){\n                       if(cmpp[y][x]==cmpp[y][x+1]){\n                           cntt++;\n                       }\n                       if(x==w-1||cmpp[y][x]!=cmpp[y][x+1]){\n                           if(cntt>=k){\n                               cnt+=cmpp[y][x]*cntt*pow(2,val);\n                              // cout<<cmpp[y][x]<<\" \"<<cntt<<\" \"<<pow(2,val)<<\"\\n\";\n                               cntt=1;\n                               if(cmpp[y][x]!=0){\n                               ok=true;\n                               }\n                           }\n                            cntt=1;\n                       }\n                   }\n               }\n\n               rep(y,h){\n                   cntt=1;\n                   ll le=0,ri=0;\n                   rep(x,w){\n                       if(cmpp[y][x]==cmpp[y][x+1]){\n                           cntt++;\n                           ri++;\n                       }\n                       else if(x==w-1||cmpp[y][x]!=cmpp[y][x+1]){\n                           if(cntt>=k){\n                               rrrep(yy,y,0){\n                               rrep(xx,le,ri+1){\n                                   if(yy==0){\n                                       cmpp[yy][xx]=0;\n                                   }\n                                   else{\n                                   cmpp[yy][xx]=cmpp[yy-1][xx];\n                                   }\n                               }\n                               }\n                           }\n                           else{\n                               le=x+1;\n                               ri=le;\n                           }\n                       }\n                   }\n               }\n\n               if(!ok)break;\n               val++;\n           }\n           ans=max(ans,cnt);\n           cnt=0;\n           val=0;\n\n          }\n      }\n      Cout(ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\n#define rep2(i, s, n) for (ll i = (s); i < (ll)(n); i++)\n#define all(v) v.begin(), v.end()\n#define sz(v) v.size()\n#define INF 100000000000000 //10^14 100兆\n// aよりもbが大きいならばaをbで更新する\n// (更新されたならばtrueを返す)\ntemplate <typename T>\nbool chmax(T &a, const T& b) {\n  if (a < b) {\n    a = b;  // aをbで更新\n    return true;\n  }\n  return false;\n}\n// aよりもbが小さいならばaをbで更新する\n// (更新されたならばtrueを返す)\ntemplate <typename T>\nbool chmin(T &a, const T& b) {\n  if (a > b) {\n    a = b;  // aをbで更新\n    return true;\n  }\n  return false;\n}\n\nint main(){\n  ll H, W, K;\n  cin >> H >> W >> K;\n  vector<string> c(H);\n  rep(i, H){\n    cin >> c.at(i);\n  }\n  vector<string> p(W, \"\");\n  vector<string> p2(W);\n  rep(i, W){\n    rep(j, H){\n      p.at(i) += c.at(H-1-j).at(i);\n    }\n    rep(j, H){\n      p.at(i) += \"#\";\n    }\n  }\n  rep(i, W){\n    p2.at(i) = p.at(i);\n  }\n  queue<pair<ll, ll>> s;\n  ll ans = 0;\n  rep(i, W){\n    rep(m, H){\n      rep(j, W){\n        p.at(j) = p2.at(j);\n      }\n      ll chain = 0;\n      ll score = 0;\n      s.push(make_pair(i, m));\n      while(!s.empty()){\n        while(!s.empty()){\n          pair<ll, ll> r = s.front();\n          s.pop();\n          p.at(r.first).at(r.second) = '!';\n        }\n        rep(j, W){\n          auto it = p.at(j).begin();\n          while(it != p.at(j).end()){\n            if(*it == '!'){\n              it = p.at(j).erase(it);\n            }\n            else{\n              it++;\n            }\n          }\n        }\n//        cout << i << \" \" << score << endl;\n//        rep(j, W){\n//          cout << p.at(j) << endl;\n//        }\n        rep(j, H){\n          ll rin = 1;\n          rep(k, W-1){\n            if(p.at(k).at(j) == p.at(k+1).at(j) && isdigit(p.at(k).at(j))){\n              rin++;\n            }\n            else if(isdigit(p.at(k).at(j)) && rin >= K){\n              score += pow(2, chain) * rin * (p.at(k).at(j) - '0');\n              rep(l, rin){\n                s.push(make_pair(k-l, j));\n              }\n              rin = 1;\n            }\n            else{\n              rin = 1;\n            }\n          }\n          if(isdigit(p.at(W-1).at(j)) && rin >= K){\n            score += pow(2, chain) * rin * (p.at(W-1).at(j) - '0');\n            rep(l, rin){\n              s.push(make_pair(W-1-l, j));\n            }\n          }\n        }\n        chain++;\n      }\n//    cout << i  << \" \" << m << \" \" << score << endl;\n      chmax(ans, score);\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nint h, w, k;\n\nll pow(ll x, ll n) {\n    ll ret = 1;\n    while (n > 0) {\n        if (n & 1) ret = ret * x;  // n の最下位bitが 1 ならば x^(2^i) をかける\n        x = x * x;\n        n >>= 1;  // n を1bit 左にずらす\n    }\n    return ret;\n}\n\nvoid tsumeru(vector<vector<int> > &tmpC, int col) {\n  vector<int> fill;\n  int blank = -1;\n  for(int i = h - 1; i >= 0; i--) {\n    if (tmpC[i][col] == 0) {\n      if (blank == -1) {\n        blank = i;\n      }\n    } else {\n      if (blank != -1) {\n        fill.push_back(i);\n      }\n    }\n  }\n  \n  int s = fill.size();\n  if (s == 0) return;\n\n  for (int i = blank; i > blank - s; i--) {\n    tmpC[i][col] = tmpC[fill[blank - i]][col];\n  }\n  for (int i = blank - s; i >= 0; i--) {\n    tmpC[i][col] = 0;\n  }\n}\n\nll disapper(vector<vector<int> > &tmpC, int raw) {\n  ll sum = 0;\n  if (w >= 3) {\n    for(int col = 0; col <= w - 3; col++) {\n      if (tmpC[raw][col] != 0 && tmpC[raw][col] == tmpC[raw][col + 1] && tmpC[raw][col] == tmpC[raw][col + 2]) {\n        sum += 3 * tmpC[raw][col];\n        tmpC[raw][col] = tmpC[raw][col + 1] = tmpC[raw][col + 2] = 0;\n      }\n    }\n  }\n  for(int col = 0; col <= w - 2; col++) {\n    if (tmpC[raw][col] != 0 && tmpC[raw][col] == tmpC[raw][col + 1]) {\n      sum += 2 * tmpC[raw][col];\n      tmpC[raw][col] = tmpC[raw][col + 1] = 0;\n    }\n  }\n  return sum;\n}\n\n\nint main() {\n  cin >> h >> w >> k;\n\n  vector<vector<int> > C(h, vector<int>(w, 0)), tmpC(h, vector<int>(w, 0));\n  rep(i, h) {\n    string str;\n    cin  >> str;\n    rep(j ,w) {\n      C[i][j] = str[j] - '0';\n    }\n  }\n\n  ll ans = 0;\n  rep(i, h) rep(j, w) {\n    rep(ii, h) rep(jj ,w) tmpC[ii][jj] = C[ii][jj];\n\n    int turn = 0;\n    ll tmp_score = 0;\n    tmpC[i][j] = 0;\n    while(true) {\n\n      rep (col, w) tsumeru(tmpC, col);\n      ll disapper_score = 0;\n      rep(raw, h) disapper_score += disapper(tmpC, raw);\n\n      // rep(raw, h) {\n      //   rep(col, w) {\n      //     cout << tmpC[raw][col] << ' ';\n      //   }\n      //   cout << endl;\n      // }\n\n      if (disapper_score == 0) break;\n\n      tmp_score += disapper_score * pow(2, turn); \n      // cout << tmp_score << endl;\n      turn++;\n    }\n    ans = max(ans, tmp_score);\n  }\n\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(long long int (i)=0;(i)<(int)(n);(i)++)\n#define rrep(i,a,b) for(long long int i=(a);i<(b);i++)\n#define rrrep(i,a,b) for(long long int i=(a);i>=(b);i--)\n#define all(v) (v).begin(), (v).end()\n#define pb(q) push_back(q)\n#define Abs(a,b) max(a,b)-min(a,b)\n#define YES(condition) if(condition){cout << \"YES\" << endl;}else{cout << \"NO\" << endl;}\n#define Yes(condition) if(condition){cout << \"Yes\" << endl;}else{cout << \"No\" << endl;}\n#define Cout(x) cout<<(x)<<endl\n#define POSSIBLE(condition) if(condition){cout << \"POSSIBLE\" << endl;}else{cout << \"IMPOSSIBLE\" << endl;}\n#define Possible(condition) if(condition){cout << \"Possible\" << endl;}else{cout << \"Impossible\" << endl;}\n#define possible(condition) if(condition){cout << \"possible\" << endl;}else{cout << \"impossible\" << endl;}\n#define Size(n) (n).size()\n\ntypedef long long ll;\n\n\nusing namespace std;\n\nconst int INF = 1e9,MOD = 1e9 + 7,ohara=1e6;\nconst ll LINF = 1e18;\n\n/*---------------------------------------------------------------\nlong long int kaizyo(long long int hh){\n    cmp=1;\n    while(hh>1){\n        cmp=(cmp*hh)%MOD;\n        hh--;\n    }\n    return cmp;\n}\nlong long int ruizyo(long long int aa, long long int bb){\n    if(aa==0){\n        return 1;\n    }\n    else if(aa%2==0){\n        long long int tt=ruizyo(aa/2,bb);\n        return (tt*tt)%MOD;\n    }\n    else{\n        return (ruizyo(aa-1,bb)*bb)%MOD;\n    }\n}フェルマ－のア\n---------------------------------------------------------------\n\nwhile(x!=0){\n            sum+=x%10;\n          / x/=10;\n        }\n        各桁の和\n---------------------------------------------------------------\n\npair<int,int> p[100000];\ncin >> tmp;\np[i]=make_pair(tmp,i);\ncout << p[i].second+1 << endl;//ペアの右側つまりiを出力\n\n---------------------------------------------------------------\n\nbool f[100001];//1000000以下の素数を調べよう！\nrrep(i,2,100001){\n       f[i]=false;\n    }\nrrep(i,2,100001){\n        if(!f[i]){\n            for(int j=i+i;j<=100000;j+=i){\n                f[j]=true;\n            }\n        }\n    }\n    for(int i=3;i<=100000;i+=2){\n        if(!f[i]){\n            c[i]++;\n        }\n    }\n\n---------------------------------------------------------------\n\nlong long gcd(long long aaa,long long bbb){\n    if(bbb==0){\n        return aaa;\n    }\n    return gcd(bbb,aaa%bbb);\n}\n \nlong long lcm(long long aaa,long long bbb){\n    long long g = gcd(aaa,bbb);\n    return aaa/g * bbb;\n}左から最大公約数と最小公倍数\n\n\n---------------------------------------------------------------\n\nlong long int prime_cnt[10000];\n       for(int i=2;i*i<=n;i++){\n           while(n%i==0){\n               n/=i;\n               prime_cnt[i]+=1;\n           }\n           if(n>1){\n               prime_cnt[n]+=1;\n               break;\n           }\n      }ある数nを素因数分解しましょう\n\n---------------------------------------------------------------\ndebug:\ncout<<\"i: \"<<i<<\" j: \"<<j<<\" cnt: \"<<cnt<<\"\\n\";\n\n---------------------------------------------------------------*/\n\nlong long int n,cnt=0,ans=0,a,b,c,d,cmp[100][100],cmpp[100][100],m,h,w,sum=0,pos,k;\nint dy[]={1,0,-1,0};\nint dx[]={0,1,0,-1};\nstring alph(\"abcdefghijklmnopqrstuvwxyz\"),s;\nbool fl=true;\nstruct edge{int to,cost;};\n\n//-------------------------↓↓↓↓↓↓------------------------\n\nint main(void){\n       cin.tie(0);\n    ios::sync_with_stdio(false);\n\n      \n       cin>>h>>w>>k;\n  \t\tans=0;\n       rep(i,h){\n           cin>>s;\n           rep(j,w){\n               cmp[i][j]=(s[j]-'0');\n           }\n       }\n      \n      ll cntt=0,val=0;\n      rep(i,h){\n          rep(j,w){\n\n              rep(y,h){\n                  rep(x,w){\n                      cmpp[y][x]=cmp[y][x];\n                  }\n              }\n            \n            rrrep(y,i,0){\n                if(y==0){\n                    cmpp[y][j]=0;\n                }\n                else{\n                    cmpp[y][j]=cmpp[y-1][j];\n                }\n            }\n\n           while(1){\n               bool ok=false;\n               rep(y,h){\n                   cntt=1;\n                   rep(x,w){\n                       if(cmpp[y][x]==cmpp[y][x+1]){\n                           cntt++;\n                       }\n                       if(x==w-1||cmpp[y][x]!=cmpp[y][x+1]){\n                           if(cntt>=k){\n                               cnt+=cmpp[y][x]*cntt*pow(2,val);\n                              // cout<<cmpp[y][x]<<\" \"<<cntt<<\" \"<<pow(2,val)<<\"\\n\";\n                               cntt=1;\n                               if(cmpp[y][x]!=0){\n                               ok=true;\n                               }\n                           }\n                            cntt=1;\n                       }\n                   }\n               }\n\n               rep(y,h){\n                   cntt=1;\n                   ll le=0,ri=0;\n                   rep(x,w){\n                       if(cmpp[y][x]==cmpp[y][x+1]&&cmpp[y][x]!=0){\n                           cntt++;\n                           ri++;\n                       }\n                        if(x==w-1||cmpp[y][x]!=cmpp[y][x+1]){\n                            if(cmpp[y][x]==0)continue;\n                           if(cntt>=k){\n                               rrrep(yy,y,0){\n                               rrep(xx,le,ri+1){\n                                   if(yy==0){\n                                       cmpp[yy][xx]=0;\n                                   }\n                                   else{\n                                   cmpp[yy][xx]=cmpp[yy-1][xx];\n                                   }\n                               }\n                               }\n                           }\n                               le=x+1;\n                               ri=le;\n                           cntt=1;\n                       }\n                   }\n               }\n\n               if(!ok)break;\n               val++;\n           }\n           ans=max(ans,cnt);\n           cnt=0;\n           val=0;\n\n          }\n      }\n      Cout(ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for(int i=0; i < (int)(n); i++)\nusing namespace std;\n\ntypedef long long ll;\n// #define DEBUG\n\nint H, W, K;\nvector<vector<int>> original;\nvector<vector<int>> board;\n\nstruct EraseResult{\n    set<int> erased;\n    ll score;\n};\n\nvoid drop(set<int>& erased){\n    #ifdef DEBUG\n    printf(\"drop\\n\");\n    #endif\n    for(auto col: erased){\n        // col列目を落とす\n        while(true){\n            int changed = false;\n            for(int bottom=H-2; bottom >= 0; bottom--){\n                if(board[bottom][col] != 0 && board[bottom+1][col] == 0){\n                    board[bottom+1][col] = board[bottom][col];\n                    board[bottom][col] = 0;\n                    changed = true;\n                }\n            }\n\n            if(changed == false){\n                break;\n            }\n        }\n        \n\n        // int seeker = H - 1;\n        // // bottomは下から順につめていく。seekerは非空ブロックをさがしにいく.\n        // for(int bottom = H-1; bottom >= 0; bottom--){\n        //     // seekerをうえにあげてブロックをさがす\n        //     while(seeker >= 0 && board[seeker][col] == 0){\n        //         seeker--;\n        //     }\n\n        //     if(seeker < 0){\n        //         // みつからなかったその列はおわり   \n        //         break;\n        //     }\n\n        //     // ブロックをみつけたらそれはけしてbottomのところにうつす\n        //     board[bottom][col] = board[seeker][col];\n        //     board[seeker][col] = 0;\n        // }\n    }\n}\n\nEraseResult tryEraseRow(int i, int j){\n    if(board[i][j] == 0){\n        return EraseResult{set<int>(), 0};\n    }\n    #ifdef DEBUG\n    printf(\"tryEraseRow(%d, %d) %d\\n\", i, j, board[i][j]);\n    #endif\n\n    int left = j;\n    while(left - 1 >= 0 && board[i][left-1] == board[i][j]){\n        left--;\n    }\n\n    int right = j;\n    while(right + 1 < W && board[i][right+1] == board[i][j]){\n        right++;\n    }\n\n    int len = right - left + 1;\n    if(len >= K){\n        ll res = board[i][j]*len;\n        // けす\n        set<int> erased;\n        for(int ind=left; ind <= right; ind++){\n            board[i][ind] = 0;\n            erased.insert(ind);\n        }\n        #ifdef DEBUG\n        printf(\"Earned %d\\n\", res);\n        #endif\n        return EraseResult{erased, res};\n\n    }else{\n        // けせない\n        return EraseResult{set<int>(), 0};\n    }\n}\n\nEraseResult eraseAndEarn(set<int>& dropped){\n    #ifdef DEBUG\n    printf(\"eraseAndEarn\\n\");\n    #endif\n    ll score = 0;\n    set<int> erased;\n    for(auto col: dropped){\n        for(int i=0; i < H; i++){\n            auto res = tryEraseRow(i, col);\n            if(res.score > 0){\n                // けせて\n                score += res.score;\n                for(auto iter: res.erased){\n                    erased.insert(iter);\n                }\n            }\n        }\n    }\n\n    return EraseResult{erased, score};\n}\n\n\n\n\nll simulate(int i, int j){\n    // ボードをコピー\n    board = original;\n\n    // 穴をあける\n    board[i][j] = 0;\n\n    // 効率化のためにどの列を落としたか/けしたかをおぼえておく\n    set<int> erased;\n    erased.insert(j);\n\n    // 落とす→けして点を得るを繰替えす。\n    ll res = 0;\n    ll mag = 1;  // 点の倍率\n    while(true){\n        drop(erased);\n\n        // 前回けしたところしか落ちてないのでそこだけしらべれば十分\n        auto erase_res = eraseAndEarn(erased);\n        ll local_score = erase_res.score;\n        if(local_score == 0){\n            break;\n        }\n        erased = erase_res.erased;\n        res += local_score*mag;\n\n        mag *= 2;\n    }\n\n    return res;\n}\n\nint main(){\n    cin >> H >> W >> K;\n\n    original = vector<vector<int>>(H, vector<int>(W, 0));\n    for(int i=0; i < H; i++){\n        for(int j=0; j < W; j++){\n            while(true){\n                char temp;\n                cin >> temp;\n                if('0' <= temp && temp <= '9'){\n                    original[i][j] = temp - '0';\n                    break;\n                }else{\n                    continue;\n                }\n            }\n        }\n    }\n\n    ll res = 0;\n    for(int i=0; i < H; i++){\n        for(int j=0; j < W; j++){\n            res = max(res, simulate(i, j));\n        }\n    }\n    \n    cout << res << endl;\n\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define REP(i,n) for (int i = 1; i < (int)(n); i++)\ntemplate<class T> bool chmin(T &a, T b) {if(a>b) {a=b;return 1;}return 0;}\nusing namespace std;\nusing vint = vector<int>;\nusing vvint = vector<vector<int>>;\nusing ll = long long;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nusing P = pair<int,int>;\nconst double inf = 1e9;\nconst int mod = 1e5;\nconst int MAX = 5005;\n\nstruct status {int y, x, len;};\n\nint main() {\n    int h, w, K; cin >> h >> w >> K;\n    vector<string> field_s(h);\n    rep(i,h) cin >> field_s[i];\n    vvint field_ori(h,vint(w));\n    rep(i,h)rep(j,w) field_ori[i][j] = field_s[i][j] - '0';\n    // rep(a,h) {\n    //     rep(b,w) cout << field[a][b] << \" \";\n    //     cout << endl;\n    // }\n    int ans = 0;\n    rep(i,h)rep(j,w) {\n        // if (i != 3 || j != 2) continue;\n        int sum = 0;\n        vvint field = field_ori;\n        field[i][j] = 0;\n        deque<int> q;\n        rep(a,h) if (field[a][j] != 0) q.push_back(field[a][j]);\n        while (q.size() < h) q.push_front(0);\n        rep(a,h) {\n            int x = q.front(); q.pop_front();\n            field[a][j] = x;\n        }\n        // rep(a,h) {\n        //     rep(b,w) cout << field[a][b] << \" \";\n        //     cout << endl;\n        // }\n        // cout << endl;\n        int now = 0;\n        while (true) {\n            bool update = false;\n            rep(k,h) {\n                int index = 0;\n                int ct = 1;\n                rep(l,w) {\n                    if (field[k][l] == field[k][l+1] && l != w-1) ct++;\n                    else {\n                        if (ct >= K) {\n                            // cout << ct << index << endl;\n                            if (field[k][index] != 0) update = true;\n                            sum += field[k][index]*ct*pow(2,now);\n                            for (int m = index; m < index+ct; m++) field[k][m] = 0;\n                        }\n                        index = l+1;\n                        ct = 1;\n                    }\n                }\n            }\n            // rep(i,h) {\n            //     rep(j,w) cout << field[i][j] << \" \";\n            //     cout << endl;\n            // }\n            // cout << endl;\n            if (!update) {ans = max(ans,sum); break;}\n            deque<int> q;\n            rep(l,w) {\n                rep(k,h) if (field[k][l] != 0) q.push_back(field[k][l]);\n                while (q.size() < h) q.push_front(0);\n                rep(k,h) {\n                    int x = q.front(); q.pop_front();\n                    field[k][l] = x;\n                }\n            }\n            now++;\n            // rep(i,h) {\n            //     rep(j,w) cout << field[i][j] << \" \";\n            //     cout << endl;\n            // }\n            // cout << endl;\n            // cout << sum << endl;\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef DEBUG\n#define debug(x) cout << #x << \": \" << x << endl\n#else\n#define debug(x)\n#endif\n\n#define int ll\n\n#define REP(i, n) for(int i = 0; i < (n); i++)\n#define REPS(i, n) for(int i = 1; i <= (n); i++)\n#define ALL(v) (v).begin(), (v).end()\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n\nusing namespace std;\n\nusing ll = long long;\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vs = vector<string>;\nusing vb = vector<bool>;\n\nconst ll INF = 1e18;\nconst ll MOD = 1e9+7;\n\ntemplate<class T> inline bool chmax(T &a, const T &b) { if (a<b) { a = b; return true;} return false; }\ntemplate<class T> inline bool chmin(T &a, const T &b) { if (a>b) { a = b; return true;} return false; }\n\n\nsigned main()\n{\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n\n    int H, W, K; cin >> H >> W >> K;\n    if(K >= 4)\n    {\n        cout << 0 << endl;\n        return 0;\n    }\n    vector<vl> block(H, vl(W)); \n    REP(i, H) \n    {\n        string s; cin >> s;\n        REP(j, W)\n        {\n            block[i][j] = s[j]-'0';\n        }\n    }\n\n\n    ll ans = 0;\n\n    REP(i, H)\n    {\n        REP(j, W)\n        {\n            ll score = 0, tmp = 0, turn = 0;\n            bool update = true;\n            vector<vl> x(block);\n            x[i][j] = -1;\n            // xを移動\n            REP(j, W)\n            {\n                int k = H-1;\n                while(k >= 0 && x[k][j] > 0) k--;\n                if(k > 0)\n                {\n                    for(int n = k-1; n >= 0; n--)\n                    {\n                        if(x[n][j] > 0)\n                        {\n                            swap(x[k][j], x[n][j]);\n                            k--;\n                        }\n                        if(k < 0) break;\n                    }\n                }\n            }\n            while(update)\n            {\n                tmp = 0;\n                if(turn != 0) update = false;\n                // xを消す\n                REP(i, H)\n                {\n                    ll count = 0, mc = 0, index = 0;\n                    REP(j, W)\n                    {\n                        if(j > 0 && x[i][j] != x[i][j-1]) count = 0;\n                        if(x[i][j] != -1) count++;\n                        if(chmax(mc, count)) index = j;\n                    }\n                    if(mc >= K)\n                    {\n                        update = true;\n                        tmp += mc * x[i][index];\n                        for(int j = index-mc+1; j <= index; j++)\n                        {\n                            x[i][j] = -1;\n                        }\n                    }\n                }\n\n                score += pow(2, turn) * tmp;\n\n                // xを移動\n                REP(j, W)\n                {\n                    int k = H-1;\n                    while(k >= 0 && x[k][j] > 0) k--;\n                    if(k > 0)\n                    {\n                        for(int n = k-1; n >= 0; n--)\n                        {\n                            if(x[n][j] > 0)\n                            {\n                                swap(x[k][j], x[n][j]);\n                                k--;\n                            }\n                            if(k < 0) break;\n                        }\n                    }\n                }\n                turn++;\n            }\n            chmax(ans, score);\n        }\n    }\n    cout << ans << endl;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid erup( vector<string> &t, int i, int j )\n{\n\tt[i][j] = ' ';\n\tfor( int k = i; k - 1 >= 0; k-- ) {\n\t\tif(  t[k - 1][j] == ' ' ) break;\n\t\tt[k][j] = t[k - 1][j];\n\t\tt[k - 1][j] = ' ';\n\t}\n}\n\nvoid chk( vector<string> &t, int i, int j, int W, int K, vector<pair<int, int>> &er )\n{\n\tfor( int k = i; k >= 0; k-- ) {\n\t\tif( t[k][j] == ' ' ) break;\n\t\tif( j > 0 && t[k][j] == t[k][j - 1] || j + 1 < W && t[k][j] == t[k][j + 1] ) {\n\t\t\tvector<pair<int, int>> tv;\n\t\t\tchar nc = t[k][j];\n\t\t\ttv.push_back( make_pair( k, j ) );\n\t\t\tfor( int l = j - 1; l >= 0; l-- ) {\n\t\t\t\tif( t[k][l] != nc ) break;\n\t\t\t\ttv.push_back( make_pair( k, l ) );\n\t\t\t}\n\t\t\tfor( int l = j + 1; l < W; l++ ) {\n\t\t\t\tif( t[k][l] != nc ) break;\n\t\t\t\ttv.push_back( make_pair( k, l ) );\n\t\t\t}\n\t\t\tif( tv.size() >= K ) er.insert( er.end(), tv.begin(), tv.end() );\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint H, W, K;\n\tcin >> H >> W >> K;\n\tvector<string> c( H );\n\tfor( int i = 0; i < H; i++ ) {\n\t\tcin >> c[i];\n\t}\n\n\tlong long ans = 0;\n\tfor( int i = 0; i < H; i++ ) {\n\t\tfor( int j = 0; j < W; j++ ) {\n\t\t\tvector<string> t = c;\n\t\t\tlong long sc = 0;\n\t\t\terup( t, i, j );\n\t\t\tint idx = 0;\n\t\t\tset<int> st;\n\t\t\twhile( 1 ) {\n\t\t\t\tvector<pair<int, int>> er;\n\t\t\t\tif( idx == 0 ) {\n\t\t\t\t\tchk( t, i, j, W, K, er );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor( auto it = st.begin(); it != st.end(); it++ ) {\n\t\t\t\t\t\tchk( t, i, *it, W, K, er );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( er.size() == 0 ) break;\n\t\t\t\tint sum = 0;\n\t\t\t\tfor( int k = 0; k < er.size(); k++ ) sum += t[er[k].first][er[k].second] - '0';\n\t\t\t\tsc += (1LL << idx) * sum;\n\t\t\t\tidx++;\n\t\t\t\tans = max( ans, sc );\n\t\t\t\tst.clear();\n\t\t\t\twhile( er.size() ) {\n\t\t\t\t\tint ii, jj;\n\t\t\t\t\ttie( ii, jj ) = er.back();\n\t\t\t\t\ter.pop_back();\n\t\t\t\t\tst.insert( jj );\n\t\t\t\t\terup( t, ii, jj );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n    Problem 93\n    https://atcoder.jp/contests/s8pc-3/tasks/s8pc_3_b\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n/* typedef */\ntypedef long long ll;\ntypedef pair<int, int> pii;\n/* class */\nclass pazzle {\n    public:\n    int H, W, K;\n    ll ans = 0;\n    vector<vector<int> > v;\n    pazzle (int H, int W, int K, vector<vector<int> > v)\n    : H(H), W(W), K(K), v(v) {}\n    bool del() {\n        int ret = false;\n        for (int i = 0; i < H; i++) {\n            int r = 0;\n            for (int l = 0; l < W; l++) {\n                int tmp = v[i][r];\n                while (v[i][r] == -1) {\n                    r++;\n                    l++;\n                }\n                while (v[i][r] == v[i][r + 1]){\n                    r++;\n                    tmp += v[i][r];\n                }\n                if (r - l + 1>= K) {\n                    for (int k = l; k <= r; k++) v[i][k] = -1;\n                    ans += tmp;\n                    ret = true;\n                }\n                l = r;\n                r++;\n            }\n        }\n        return ret;\n    }\n    void move() {\n        for (int i = 0; i < W; i++) {\n            for (int j = H - 1; j > 0; j--) {\n                if (v[j][i] == -1) {\n                    int k = j - 1;\n                    while (v[k][i] == -1 && k > 0) k--;\n                    if (v[k][i] != -1) swap(v[k][i], v[j][i]);\n                }\n            }\n        }\n    }\n    void printPoint() {\n        cout << ans << '\\n';\n    }\n    ll gameStart() {\n        ll ret = 0;\n        move();\n        for (int i = 0; del(); i++){\n            move();\n            ret += pow(2, i) * ans;\n            ans = 0;\n        }\n        return ret;\n    }\n};\n/* constant */\nconst int INF = (1 << 30);\n/* global variables */\n/* function */\n/* main */\nint main(){\n    int H, W, K;\n    cin >> H >> W >> K;\n    vector<string> vs(H);\n    for (int i = 0; i < H; i++) cin >> vs[i];\n    vector<vector<int> > v(H, vector<int> (W + 1, -2));\n    for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) v[i][j] = vs[i][j] - '0';\n    if (K == 1) {\n        int ans = 0;\n        int minValue = INF;\n        for (auto vi : v) {\n            ans += accumulate(vi.begin(), vi.end(), 0);\n            minValue = min(*min_element(vi.begin(), vi.end()), minValue);\n        }\n        cout << ans  - minValue << '\\n';\n        return 0;\n    }\n    else if (K >= 4) {\n        cout << 0 << '\\n';\n        return 0;\n    }\n    ll ans = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int tmp = v[i][j];\n            v[i][j] = -1;\n            pazzle P = pazzle(H, W, K, v);\n            ans = max(ans, P.gameStart());\n            v[i][j] = tmp;\n        }\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <complex>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\n#define rep(i, n) for (ll i = 0; i < (n); ++i)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define Lower_bound(v, x) \\\n  distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) \\\n  distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\nusing T = tuple<ll, ll, ll>;\nusing vll = vector<ll>;\nusing vP = vector<P>;\nusing vT = vector<T>;\nusing vvll = vector<vector<ll>>;\nusing vvP = vector<vector<P>>;\nusing dqll = deque<ll>;\n\nll dx[9] = {-1, 1, 0, 0, -1, -1, 1, 1, 0};\nll dy[9] = {0, 0, -1, 1, -1, 1, -1, 1, 0};\n\nconst ll INF = 1LL << 50;\n\nconst ll mod = 1e9 + 7;\n\nint main() {\n  ll h, w, k;\n  cin >> h >> w >> k;\n  if (k >= 4) {\n    puts(\"0\");\n    return 0;\n  }\n\n  vvll omp(w, vll(h));\n  rep(i, h) {\n    string s;\n    cin >> s;\n    rep(j, w) omp[j][h - 1 - i] = (s[j] - '0');\n  }\n\n  vvll mp;\n\n  auto fall = [&](ll j) {\n    vll& tgt = mp[j];\n    vll nv;\n    rep(i, h) if (tgt[i] != -1) nv.push_back(tgt[i]);\n    ll times = h - (ll)nv.size();\n    rep(i, times) nv.push_back(-1);\n    mp[j] = nv;\n    assert(nv.size() == (size_t)h);\n  };\n\n  // auto printmp = [&](string s) {\n  //   cout << s << endl;\n  //   rep(i, h) {\n  //     rep(j, w) printf(\"%3lld \", mp[j][h - 1 - i]);\n  //     cout << endl;\n  //   } // i\n  // };\n\n  ll ans = 0;\n  rep(i, h) rep(j, w) {\n    mp = omp;\n    mp[j][i] = -1;\n    //printmp(\"start bef\");\n    fall(j);\n    //printmp(\"start aft\");\n    ll score = 0;\n    for (ll loop = 0;; loop++) {\n      bool erflag = false;\n      rep(ii, h) rep(jj, w) {\n        if (mp[jj][ii] == -1) continue;\n        ll cnt = 1;\n        for (ll jdx = jj + 1; jdx <= w; jdx++) {\n          if (jdx < w && mp[jdx][ii] == mp[jj][ii])\n            cnt++;\n          else {\n            if (cnt >= k) {\n              erflag = true;\n              ll add = (1LL << loop)*mp[jj][ii];\n              rep(era, cnt) {\n                score += add;\n                mp[jj + era][ii] = -1;\n              }  // era\n            }\n            break;\n          }\n        }  // jdx\n      }    // jj, ii\n      if (!erflag) break;\n\n      //printmp(\"before fall\");\n      rep(jdx, w) fall(jdx);\n      //printmp(\"after fall\");\n      //cout << score << endl;\n    }  // loop\n    chmax(ans, score);\n  }  // j, i\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define all(x) x.begin(), x.end()\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define em emplace\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define REP(i, n) for(int i = 1; i <= n; i++)\ntemplate<class T> inline int chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline int chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst int INF = 1<<29;\nconst ll LINF = 1LL<<58;\nconst int mod = 1000000007;\n\nint h, w, k;\nint board[30][30];\n\nvoid change(int board[30][30]){\n    for (int j = 0; j < w; j++) {\n        for (int _ = 0; _ < h; _++) {\n            bool flag = 1;\n            for (int i = 0; i < h - 1; i++) {\n                if(board[i][j] == 0) {\n                    swap(board[i + 1][j], board[i][j]);\n                    flag = 0;\n                }\n            }\n            if(flag) break;\n        }\n    }\n    return;\n}\n\nint start(int y, int x){\n    int score = 0;\n    int grid[30][30];\n    rep(i, 30) rep(j, 30) grid[i][j] = board[i][j];\n\n    grid[y][x] = 0;\n    change(grid);\n\n    for (int l = 0; l < 40; l++) {\n        int sum = 0;\n        for (int i = 0; i < h; i++) {\n            int last = grid[i][0], idx = 0, cnt = 0;\n            while(idx < w) {\n                while (last == grid[i][idx]) {\n                    idx++;\n                    cnt++;\n                }\n                if (cnt >= k) {\n                    sum += last * cnt;\n                    for (int j = idx - 1; cnt; cnt--, j--) grid[i][j] = 0;\n                }\n                cnt = 0;\n                last = grid[i][idx];\n            }\n        }\n        if(sum == 0) break;\n        score += sum * pow(2, l);\n        change(grid);\n    }\n\n    return score;\n}\n\nint main(){\n    cin >> h >> w >> k;\n    memset(board, -1, sizeof board);\n    for (int i = h - 1; i >= 0; i--) for (int j = 0; j < w; j++) {\n        char c;\n        cin >> c;\n        board[i][j] = c - '0';\n    }\n    int ans = 0;\n    rep(i, h) rep(j, w) chmax(ans, start(i, j));\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Macro Tools /////////////////////////////////////////////////////////////////\n#define GET_MACRO_09(A0, A1, A2, A3, A4, A5, A6, A7, A8, NAME, ...) NAME\n\n#define EXPAND_01(MACRO, A0, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) \n#define EXPAND_02(MACRO, A0, A1, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) \n#define EXPAND_03(MACRO, A0, A1, A2, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__) \n#define EXPAND_04(MACRO, A0, A1, A2, A3, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) \n#define EXPAND_05(MACRO, A0, A1, A2, A3, A4, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) \n#define EXPAND_06(MACRO, A0, A1, A2, A3, A4, A5, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) MACRO(A5, ##__VA_ARGS__) \n#define EXPAND_07(MACRO, A0, A1, A2, A3, A4, A5, A6, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) MACRO(A5, ##__VA_ARGS__)  \\\n\tMACRO(A6, ##__VA_ARGS__) \n#define EXPAND_08(MACRO, A0, A1, A2, A3, A4, A5, A6, A7, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) MACRO(A5, ##__VA_ARGS__)  \\\n\tMACRO(A6, ##__VA_ARGS__) MACRO(A7, ##__VA_ARGS__) \n#define EXPAND_09(MACRO, A0, A1, A2, A3, A4, A5, A6, A7, A8, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) MACRO(A5, ##__VA_ARGS__)  \\\n\tMACRO(A6, ##__VA_ARGS__) MACRO(A7, ##__VA_ARGS__) MACRO(A8, ##__VA_ARGS__) \n\n#define GET_EXPAND(...) GET_MACRO_09(__VA_ARGS__, EXPAND_09, EXPAND_08, \\\n\tEXPAND_07, EXPAND_06, EXPAND_05, EXPAND_04, EXPAND_03, EXPAND_02, EXPAND_01)\n#define EXPAND_ARG_0(MACRO, ...) GET_EXPAND(__VA_ARGS__)(MACRO, __VA_ARGS__)\n#define EXPAND_ARG_1(MACRO, A0, ...) GET_EXPAND(__VA_ARGS__)(MACRO, __VA_ARGS__, A0)\n\n#define EXPAND(MACRO, ...) EXPAND_ARG_0(MACRO, __VA_ARGS__)\n\n#define Q(x) #x\n#define QUOTE(x) Q(x)\n\n// Input ///////////////////////////////////////////////////////////////////////\n#define SCANF_INT(a) scanf(\"%d\", &(a));\n#define ID(...) int __VA_ARGS__;\n#define IR(...) {EXPAND(SCANF_INT, __VA_ARGS__)}\n#define I(...) ID(__VA_ARGS__) IR(__VA_ARGS__)\n\n// #define DEFINE_INT_ARRAY(a, n) int a[n];\n// #define INT_ITH_ARRAY(a, i) a[i]\n// #define IAD(N, ...) EXPAND_ARG_1(DEFINE_INT_ARRAY, N, __VA_ARGS__)\n// #define IAR(N, ...) REP(array_reader_i, N){ \n\n#define SCANF_LL(a) scanf(\"%lld\", &(a));\n#define LD(...) ll __VA_ARGS__;\n#define LR(...) {EXPAND(SCANF_LL, __VA_ARGS__)}\n#define L(...) LD(__VA_ARGS__) LR(__VA_ARGS__)\n\n#define SCANF_LD(a) scanf(\"%Lf\", &(a));\n#define DD(...) lD __VA_ARGS__;\n#define DR(...) {EXPAND(SCANF_LD, __VA_ARGS__)}\n#define D(...) DD(__VA_ARGS__) DR(__VA_ARGS__)\n\n#define DEFINE_STR(a, n) char a[n];\n#define SCANF_STR(a) scanf(\"%s\", a);\n#define SD(N, ...) EXPAND_ARG_1(DEFINE_STR, N, __VA_ARGS__)\n#define SR(...) EXPAND(SCANF_STR, __VA_ARGS__)\n#define S(N, ...) SD(N, __VA_ARGS__) SR(__VA_ARGS__)\n\n// Output //////////////////////////////////////////////////////////////////////\n#define LN printf(\"\\n\");\n\n#define IP(a, ...) printf(\"%d\", a); \n\n// Types ///////////////////////////////////////////////////////////////////////\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef set<int> si;\ntypedef set<ll> sll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<pii> vpii;\ntypedef list<int> li;\ntypedef list<ll> lll;\ntypedef map<int, int> mii;\ntypedef map<int, ll> mil;\ntypedef map<ll, int> mli;\ntypedef map<ll, ll> mll;\n\n// Loop & Iteration ////////////////////////////////////////////////////////////\n#define FORT(t, i, a, b) \\\n\tfor(t i = (a), loop_end_##i=(b); i < (loop_end_##i); i++)\n#define FORL(i, a, b) FORT(ll, i, a, b)\n#define FOR(i, a, b) FORT(int, i, a, b)\n#define REPT(t, i, n) FORT(t, i, 0, n)\n#define REPL(i, n) FORL(i, 0, n)\n#define REP(i, n) FOR(i, 0, n)\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define ALL(a) (a).begin(), (a).end()\n#define SORT(a) sort(ALL(a))\n#define SORTA(a, n) sort(a, a+n)\n\n#define PB push_back\n#define MP make_pair\n#define itr iterator\n\n// Range ///////////////////////////////////////////////////////////////////////\n#define IN(x, a, b) (a<=x && x<b)\n#define INC(x, a, b) (a<=x && x<=b)\nint dx[8] = { 1, 0, 0,-1, 1, 1,-1,-1};\nint dy[8] = { 0,-1, 1, 0,-1, 1,-1, 1};\n\n#define LAR(a, b) ((a)=max((a), (b)))\n#define SML(a, b) ((a)=min((a), (b)))\n\n// Debug ///////////////////////////////////////////////////////////////////////\n#define println(...) {printf(__VA_ARGS__); printf(\"\\n\");}\n#ifdef LOCAL\n#define debug(...) printf(__VA_ARGS__)\n#define debugln(...) println(__VA_ARGS__)\n#else\n#define debug(...) {}\n#define debugln(...) {}\n#endif\n\n// Numbers /////////////////////////////////////////////////////////////////////\nll gcd(ll a, ll b){\n\tif(b==0) return a;\n\telse return gcd(b, a%b);\n}\n\n#define PRIME_MAX 1000000\nbool isprime[PRIME_MAX+5];\nvoid init_prime(){\n\tfill(isprime, isprime+PRIME_MAX+5, true);\n\tisprime[0]=isprime[1]=false;\n\tREP(i, PRIME_MAX+5){\n\t\tif(isprime[i]){\n\t\t\tfor(int j=i*2; j<PRIME_MAX; j+=i){\n\t\t\t\tisprime[j]=false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvll factors(ll n){\n\tvll v;\n\tREPL(i, PRIME_MAX){\n\t\tif(!isprime[i]) continue;\n\t\twhile(n%i==0){\n\t\t\tv.PB(i);\n\t\t\tn/=i;\n\t\t}\n\t}\n\tif(n>1){\n\t\tv.PB(n);\n\t}\n\treturn v;\n}\n\n// BIT /////////////////////////////////////////////////////////////////////////\ntemplate<\n\ttypename T = int\n>\nclass bit{\npublic:\n\tT *bit_arr;\n\tint size;\n\n\tbit(int n){\n\t\tsize = n;\n\t\tbit_arr = new T[n];\n\t\tfill(bit_arr, bit_arr+n, 0);\n\t}\n\n\t~bit(){\n\t\tdelete bit_arr;\n\t}\n\n\tT sum(int a){\n\t\tT ret = 0;\n\t\twhile(a){\n\t\t\tret+=bit_arr[a];\n\t\t\ta-=a&-a;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tT sum(int a, int b){\n\t\treturn sum(b)-sum(a);\n\t}\n\n\tT get(int a){\n\t\treturn sum(a, a+1);\n\t}\n\n\tvoid add(int a, T x){\n\t\ta++;\n\t\twhile(a<size){\n\t\t\tbit_arr[a]+=x;\n\t\t\ta+=a&-a;\n\t\t}\n\t}\n\n\tvoid set(int a, T x){\n\t\tadd(a, x-get(a));\n\t}\n};\ntypedef bit<ll> bll;\n\n// RMQ /////////////////////////////////////////////////////////////////////////\ntemplate<\n\ttypename T = int,\n\tclass Compare=less<T>\n>\nclass rmq{\npublic:\n\tint size;\n\tCompare comp;\n\tT *dat;\n\tT init;\n\t\n\trmq(int n, T init_=INT_MAX){\n\t\tinit=init_;\n\t\tsize = 1;\n\t\twhile(size<n) size*=2;\n\t\tdat = new T[2*size-1];\n\t\tfill(dat, dat+(2*size-1), init);\n\t}\n\n\t~rmq(){\n\t\tdelete dat;\n\t}\n\n\tvoid set(int k, T a){\n\t\tk+=size-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=min(dat[k*2+1], dat[k*2+2], comp);\n\t\t}\n\t}\n\n\tT get(int a, int b, int k, int l, int r){\n\t\tif(r<=a || b<=l) return init;\n\t\tif(a<=l && r<=b) return dat[k];\n\t\telse{\n\t\t\tT vl = get(a, b, k*2+1, l, (l+r)/2);\n\t\t\tT vr = get(a, b, k*2+2, (l+r)/2, r);\n\t\t\treturn min(vl, vr, comp);\n\t\t}\n\t}\n\n\tT get(int a, int b){\n\t\treturn get(a, b, 0, 0, size);\n\t}\n};\n\n// Others //////////////////////////////////////////////////////////////////////\n#define MOD 1000000007\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n\n////////////////////////////////////////////////////////////////////////////////\n\nchar a[40][40];\nint dat[40][40];\nint b[40];\n\nint main(){\n\tI(h, w, k);\n\tREP(i, h) SR(a[i]);\n\tint ans = 0;\n\tREP(m, h){\n\t\tREP(l, w){\n\t\t\tREP(i, 40) REP(j, 40) dat[i][j]=0;\n\t\t\tREP(i, h) REP(j, w) dat[i][j]=a[h-i-1][j]-'0';\n\t\t\tdat[m][l]=0;\n\t\t\t// REP(i, h+1){\n\t\t\t// \tREP(j, w+1) printf(\"%d \", dat[i][j]); LN;\n\t\t\t// }\n\t\t\tint scr = 0;\n\t\t\tREP(step, MOD){\n\t\t\t\tbool mov = false;\n\t\t\t\tfill(b, b+40, -1);\n\t\t\t\t// printf(\"step %d--------\\n\", step);\n\t\t\t\twhile(1){\n\t\t\t\t\tREP(i, w){\n\t\t\t\t\t\tif(b[i]==h) continue;\n\t\t\t\t\t\tdo{\n\t\t\t\t\t\t\tb[i]++; \n\t\t\t\t\t\t}while(!dat[b[i]][i] && b[i]<h);\n\t\t\t\t\t}\n\t\t\t\t\t// REP(i, w) printf(\"%d \", b[i]); LN;\n\t\t\t\t\tint st=0;\n\t\t\t\t\twhile(st<w){\n\t\t\t\t\t\tint en=st;\n\t\t\t\t\t\twhile(dat[b[st]][st]==dat[b[en]][en] && en<w) en++;\n\t\t\t\t\t\t// printf(\" [%d, %d]=%d\\n\", st, en, dat[b[st]][st]);\n\t\t\t\t\t\tif(st==0 && en==w && dat[b[st]][st]==0){\n\t\t\t\t\t\t\tgoto finsh;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(en-st>=k && dat[b[st]][st]){\n\t\t\t\t\t\t\tint pl = (1<<step)*(en-st)*dat[b[st]][st];\n\t\t\t\t\t\t\t// printf(\"  +%d\\n\", pl);\n\t\t\t\t\t\t\tscr+=pl;\n\t\t\t\t\t\t\tmov = true;\n\t\t\t\t\t\t\tFOR(i, st, en){\n\t\t\t\t\t\t\t\tdat[b[i]][i]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tst=en;\n\t\t\t\t\t}\n\t\t\t\t}\n\tfinsh:;\n\t\t\t\tif(!mov) break;\n\t\t\t}\n\t\t\tLAR(ans, scr);\n\t\t\t// printf(\"==================%d\\n\", scr);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <stdlib.h>\n#include <string.h>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <stdio.h>\n#include <tuple>\n#include <bitset>\n#include <cfloat>\n#include <fstream>\n#include <limits.h>\n#include <list>\n#include <math.h>\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <cassert>\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\nusing namespace std;\n#define int long long\n#define ll long long\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define P pair<ll, ll>\n#define sz(x) (ll)x.size()\n#define ALL(x) (x).begin(),(x).end()\n#define ALLR(x) (x).rbegin(),(x).rend()\n#define VE vector<ll>\n#define COUT(x) cout<<(x)<<endl\n#define MA map<ll,ll>\n#define SE set<ll>\n#define PQ priority_queue<ll>\n#define PQR priority_queue<ll,VE,greater<ll>>\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\"  ) << endl\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\"  ) << endl\n#define EPS (1e-14)\n#define pb push_back\nlong long MOD = 1000000007;\n//const long long MOD = 998244353;\nconst long long INF = 1LL << 60;\nconst double PI = acos(-1.0);\nusing Graph = vector<VE>;\nstruct mint {\n\tll x; // typedef long long ll;\n\tmint(ll x = 0) :x((x%MOD + MOD) % MOD) {}\n\tmint operator-() const { return mint(-x); }\n\tmint& operator+=(const mint a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const mint a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\nstruct combination {\n\tvector<mint> fact, ifact;\n\tcombination(int n) :fact(n + 1), ifact(n + 1) {\n\t\t//assert(n < MOD);\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i <= n; ++i) fact[i] = fact[i - 1] * i;\n\t\tifact[n] = fact[n].inv();\n\t\tfor (int i = n; i >= 1; --i) ifact[i - 1] = ifact[i] * i;\n\t}\n\tmint operator()(int n, int k) {\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn fact[n] * ifact[k] * ifact[n - k];\n\t}\n}com(10);\nstruct Sieve {\n\tint n;\n\tvector<int> f, primes;\n\t\n\tSieve(int n = 1) :n(n), f(n + 1) {\n\t\tf[0] = f[1] = -1;\n\t\tfor (ll i = 2; i <= n; ++i) {\n\t\t\tif (f[i]) continue;\n\t\t\tprimes.push_back(i);\n\t\t\tf[i] = i;\n\t\t\tfor (ll j = i * i; j <= n; j += i) {\n\t\t\t\tif (!f[j]) f[j] = i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool isPrime(int x) { return f[x] == x; }\n\t\n\tvector<int> factorList(int x) {\n\t\tvector<int> res;\n\t\twhile (x != 1) {\n\t\t\tres.push_back(f[x]);\n\t\t\tx /= f[x];\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tvector<P> factor(int x) {\n\t\tvector<int> fl = factorList(x);\n\t\tif (fl.size() == 0) return {};\n\t\tvector<P> res(1, P(fl[0], 0));\n\t\tfor (int p : fl) {\n\t\t\tif (res.back().first == p) {\n\t\t\t\tres.back().second++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres.emplace_back(p, 1);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nclass UnionFind {\npublic:\n\tvector <ll> par; \n\tvector <ll> siz; \n\n\t// Constructor\n\tUnionFind(ll sz_) : par(sz_), siz(sz_, 1) {\n\t\tfor (ll i = 0; i < sz_; ++i) par[i] = i; \n\t}\n\tvoid init(ll sz_) {\n\t\tpar.resize(sz_);\n\t\tsiz.resize(sz_, 1);\n\t\tfor (ll i = 0; i < sz_; ++i) par[i] = i; \n\t}\n\n\t// Member Function\n\t// Find\n\tll root(ll x) { \n\t\twhile (par[x] != x) {\n\t\t\tx = par[x] = par[par[x]]; \n\t\t}\n\t\treturn x;\n\t}\n\n\t// Union(Unite, Merge)\n\tbool merge(ll x, ll y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return false;\n\t\t\n\t\tif (siz[x] < siz[y]) swap(x, y);\n\t\tsiz[x] += siz[y];\n\t\tpar[y] = x;\n\t\treturn true;\n\t}\n\n\tbool issame(ll x, ll y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tll size(ll x) {\n\t\treturn siz[root(x)];\n\t}\n};\ntemplate<class t> t gcd(t a, t b) { return b != 0 ? gcd(b, a % b) : a; }\nll lcm(ll a, ll b) {\n\tll g = gcd(a, b);\n\treturn a * b / g;\n}\nbool prime(ll n) {\n\tfor (ll i = 2; i <= sqrt(n); i++) {\n\t\tif (n%i == 0)return false;\n\t}\n\treturn n != 1;\n}\nmap<ll, ll> prime_factor(ll n) {\n\tmap<ll, ll> ret;\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\twhile (n % i == 0) {\n\t\t\tret[i]++;\n\t\t\tn /= i;\n\t\t}\n\t}\n\tif (n != 1) ret[n] = 1;\n\treturn ret;\n}\nll modinv(ll a, ll m) {\n\tll b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvector<pair<char, int>> RunLength(string s) {\n\tif (s.size() == 0)return {};\n\tvector<pair<char, int>>res(1, pair<char, int>(s[0], 0));\n\tfor (char p : s) {\n\t\tif (res.back().first == p) {\n\t\t\tres.back().second++;\n\t\t}\n\t\telse {\n\t\t\tres.emplace_back(p, 1);\n\t\t}\n\t}\n\treturn res;\n}\n// Digit Count\nint GetDigit(int num) {\n\treturn log10(num) + 1;\n}\n// bit calculation[how many \"1\"] (= __builtin_popcount())\nint bit_count(int n) {\n\tint cnt = 0;\n\twhile (n > 0) {\n\t\tif (n % 2 == 1)cnt++;\n\t\tn /= 2;\n\t}\n\treturn cnt;\n}\nmint POW(mint n, int p) {\n\tif (p == 0)return 1;\n\tif (p % 2 == 0) {\n\t\tmint t = POW(n, p / 2);\n\t\treturn t * t;\n\t}\n\treturn n * POW(n, p - 1);\n}\n\nconst ll dx[4] = { 1,0,-1,0 };\nconst ll dy[4] = { 0,1,0,-1 };\nstruct edge { ll to, cost; };\ntypedef long double ld;\n\nint h, w, k;\nstring field[50];\nchar tmp[50][50];\nint f(int sx, int sy) {\n\trep(i, h)rep(j, w)tmp[i][j] = field[i][j];\n\tint res = 0;\n\ttmp[sy][sx] = 'B';\n\tint now = 0;\n\tbool ok = true;\n\twhile (ok) {\n\t\tok = false;\n\t\trep(i, w-1) {\n\t\t\tvector<char>a;\n\t\t\trep(j, h) {\n\t\t\t\tif (tmp[j][i] != 'B') {\n\t\t\t\t\ta.push_back(tmp[j][i]); tmp[j][i] = 'B';\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(ALL(a));\n\t\t\trep(j, a.size()) {\n\t\t\t\ttmp[h - j - 1][i] = a[j];\n\t\t\t}\n\t\t}\n\t\trep(i, h) {\n\t\t\tchar a = tmp[i][0];\n\t\t\tint T = 0;\n\t\t\trep(j, w) {\n\t\t\t\tif (j == 0)continue;\n\t\t\t\tif (a != tmp[i][j]) {\n\t\t\t\t\tint d = j - T;\n\t\t\t\t\tif (k <= d && a != 'B') {\n\t\t\t\t\t\tres += (a - '0')*d*(1 << now);\n\t\t\t\t\t\tfor (int l = T; l < j; l++) {\n\t\t\t\t\t\t\ttmp[i][l] = 'B';\n\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ta = tmp[i][j];\n\t\t\t\t\tT = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnow++;\n\t}\n\treturn res;\n}\nsigned main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\t//cout << fixed << setprecision(15);\n\tcin >> h >> w >> k;\n\trep(i, h)cin>>field[i];\n\trep(i, h)field[i] += \"a\";\n\tw++;\n\tint ans = 0;\n\trep(i, h)rep(j, w-1)chmax(ans, f(j, i));\n\tcout << ans << endl;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int H, W, K;\n    cin >> H >> W >> K;\n    int C[30][30];\n    for(int i=0; i<H; i++) for(int j=0; j<W; j++) scanf(\" %1d\", &C[i][j]);\n\n    int64_t ans = 0;\n    for(int x=0; x<H; x++) for(int y=0; y<W; y++){\n        int c[30][30];\n        for(int i=0; i<H; i++) for(int j=0; j<W; j++) c[i][j] = C[i][j];\n        c[x][y] = 0;\n\n        int64_t base = 0, result = 0;\n        while(true){\n            int64_t num = 0;\n            for(int i=0; i<H; i++){\n                int st = 0;\n                for(int j=0; j<=W; j++){\n                    if(j == W || (j > 0 && c[i][j] != c[i][j-1])){\n                        if(j - st >= K){\n                            for(int l=st; l<j; l++){\n                                num += c[i][l];\n                                c[i][l] = 0;\n                            }\n                        }\n                        st = j;\n                    }\n                }\n            }\n            if(base > 0 && num == 0) break;\n            result += base * num;\n            base = base > 0 ? base * 2 : 1;\n\n            for(int j=0; j<W; j++){\n                int pos = H-1;\n                for(int i=H-1; i>=0; i--){\n                    if(c[i][j] > 0){\n                        c[pos][j] = c[i][j];\n                        if(pos != i) c[i][j] = 0;\n                        pos--;\n                    }\n                }\n            }\n        }\n        ans = max(ans, result);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst ll MOD = 1'000'000'007;\nconst ld PI = acos(-1);  \nconst ld EPS = 0.0000000001;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define REP(i, n) for(ll i=0; i<(ll)(n); i++)\n#define REPD(i, n) for(ll i=n-1; 0<=i; i--)\n#define FOR(i, a, b) for(ll i=a; i<(ll)(b); i++)\n#define FORD(i, a, b) for(ll i=a; (ll)(b)<=i; i--)\n#define ALL(x) x.begin(), x.end()\n#define MAX(x) *max_element(ALL(x))\n#define MIN(x) *min_element(ALL(x))\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint main(){\n    int h, w, k;  cin >> h >> w >> k;\n    vector<vector<ll>> ori(h, vector<ll>(w));\n    REP(i, h) REP(j, w){\n        char c; cin >> c;\n        ori[i][j] = c-'0';\n    }\n    \n    ll res=0;\n    REP(x, h){\n        REP(y, w){\n            ll tmp=0, times=0;\n            bool flag=true;\n            vector<vector<ll>> g = ori;\n            g[x][y] = 0;\n            while(flag){\n                flag = false;\n                REPD(i, h){\n                    REP(j, w){\n                        if(!g[i][j]){\n                            REPD(k, i){\n                                if(!g[k][j]) continue;\n                                swap(g[k][j], g[i][j]); break;\n                            }\n                        }\n                    }\n                }\n                REP(i, h){\n                    ll bef=g[i][0], cnt=0, st=0, index=w;        \n                    REP(j, w){\n                        if(g[i][j]==bef && 0<bef) cnt += 1;\n                        else{\n                            if(cnt<k){\n                                cnt = 1; st=j;\n                            }else{\n                                if(bef)index = j;\n                                break;\n                            }\n                        }\n                        bef = g[i][j];\n                    }\n                    if(k<=cnt){\n                        tmp += (1<<times)*cnt*bef;\n                        FOR(j, st, index) g[i][j] = 0;\n                        flag = true;\n                    }\n                }\n                times += 1;\n            }\n            \n            res = max(res, tmp);\n            //cout << x <<':' << y << ' ' << tmp << endl << endl;\n        }\n    }\n    cout << res << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n \nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<VVI> VVVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\ntypedef long long LL;\ntypedef priority_queue<int> PQ_DESC;\ntypedef priority_queue<int, vector<int>, greater<int>> PQ_ASC;\ntypedef priority_queue<PII> PQ_DESC_PII;\ntypedef priority_queue<PII, vector<PII>, greater<PII>> PQ_ASC_PII;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVLL> VVVLL;\n\n#define SORT_ASC(c) sort((c).begin(), (c).end())\n#define SORT_DESC(c) sort((c).begin(), (c).end(), greater<typeof((c).begin())>())\n \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define FORL(i,a,b) for(LL i=(a);i<(b);++i)\n#define REPL(i,n)  FORL(i,0,n)\n#define ALL(a) (a).begin(),(a).end()\n \nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n //debug func\ntemplate<typename T>\nvoid vprint(vector<T> v) {\n    for(auto x : v) {\n        cerr << x << \" \";\n    }\n    cerr << endl;\n}\n \ntemplate<typename T>\nvoid vvprint(vector<vector<T>> vv) {\n    REP(i, vv.size()) {\n        REP(j, vv[i].size()) {\n            cerr << vv[i][j] << \" \";\n        }\n        cerr << endl;\n    }\n}\n\ntemplate <typename Iterator>\ninline bool next_combination(const Iterator first, Iterator k, const Iterator last)\n{\n   /* Credits: Thomas Draper */\n   if ((first == last) || (first == k) || (last == k))\n      return false;\n   Iterator itr1 = first;\n   Iterator itr2 = last;\n   ++itr1;\n   if (last == itr1)\n      return false;\n   itr1 = last;\n   --itr1;\n   itr1 = k;\n   --itr2;\n   while (first != itr1)\n   {\n      if (*--itr1 < *itr2)\n      {\n         Iterator j = k;\n         while (!(*itr1 < *j)) ++j;\n         iter_swap(itr1,j);\n         ++itr1;\n         ++j;\n         itr2 = k;\n         rotate(itr1,j,last);\n         while (last != j)\n         {\n            ++j;\n            ++itr2;\n         }\n         rotate(k,itr2,last);\n         return true;\n      }\n   }\n   rotate(first,k,last);\n   return false;\n}\n\ninline double get_time_sec(void){\n    return static_cast<double>(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count())/1000000000;\n}\n\ntemplate<typename T>\nT gcd(T a, T b) {\n    if(a > b) swap(a, b);\n    if(a == 0) return b;\n    else return gcd(b%a, a);\n}\n\ntemplate<typename T>\nT lcm(T a, T b) {\n    return (a / gcd(a, b)) * b;\n}\n\ntemplate<typename T>\nmap<T, T> prime_list(T n) {\n    map<T, T> ret;\n    for(T i = 2; i*i <= n; i++) {\n        if(n % i == 0) {\n            ret[i] = 0;\n            while(n % i == 0) {\n                n /= i;\n                ret[i]++;\n            }\n        }\n    }\n    if(n != 1) ret[n]++;\n    return ret;\n}\n\n#define MOD 1000000007\n\nLL mypow(LL a, LL n) {\n    if(n == 0) return 1;\n    if(n == 1) return a % MOD;\n    if(n % 2 == 1) return (a * mypow(a, n-1)) % MOD;\n    LL t = mypow(a, n/2);\n    return (t * t) % MOD; \n}\n\nLL mycomb(LL n, LL k) {\n    if(n == 0 || n == k) return 1;\n    LL x = 1, y = 1;\n    REP(i, k) {\n        x = x * (n-i) % MOD;\n        y = y * (i+1) % MOD;\n    }\n    return x * mypow(y, MOD - 2) % MOD;\n}\n\n#define INF 1e8\n\nint h, w, k;\nint score = 0, ms = 0;\nint turn;\nVVI b, c;\n\nbool kesu() {\n    bool flg = false;\n    REP(i, h) {\n        REP(j, w-2) {\n            if(c[i][j] && c[i][j] == c[i][j+1] && c[i][j+1] == c[i][j+2]) {\n                score += mypow(2, turn) * 3 * c[i][j];\n                FOR(l, 0, 3) c[i][j+l] = 0;\n                flg = true;\n            }\n        }\n        if(k == 2) {\n            REP(j, w-1) {\n                if(c[i][j] && c[i][j] == c[i][j+1]) {\n                    score += mypow(2, turn) * 2 * c[i][j];\n                    FOR(l, 0, 2) c[i][j+l] = 0;\n                    flg = true;\n                }\n            }\n        }\n    }\n    return flg;\n}\n\nvoid rakka() {\n    REP(j, w) {\n        VI tmp;\n        for(int i = h-1; i >= 0; i--) {\n            if(c[i][j]) tmp.push_back(c[i][j]);\n        }\n        REP(i, h) c[i][j] = 0;\n        REP(i, tmp.size()) c[h-1-i][j] = tmp[i];\n    }\n}\n\nint main(void) {\n    cin >> h >> w >> k;\n    if(k > 3) {\n        cout << 0 << endl;\n        return 0;\n    } \n    b = VVI(h, VI(w, 0));\n    REP(i, h) {\n        string s;\n        cin >> s;\n        REP(j, w) b[i][j] = (int)(s[j] - '0');\n    }\n    REP(i, h) {\n        REP(j, w) {\n            c = VVI(b);\n            c[i][j] = 0;\n            score = 0;\n            turn = 0;\n            rakka();\n            // cerr << \"===\" << i << \", \" << j << endl;\n            // vvprint(c);\n            while(kesu()) {\n                rakka();\n                turn++;\n                // cerr << \"===\" << endl;\n                // cerr << score << endl;\n                // vvprint(c);\n            }\n            ms = max(score, ms);\n        }\n    }\n    cout << ms << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\n#include \"string\"\n#include \"vector\"\n#include \"cmath\"\n#include \"bitset\"\n#include \"queue\"\n#include \"functional\"\n\n#define lp(n) for (int i = 0; i < n; i++)\n#define LP(n,i) for (int i = 0; i < n; i++)\n#define mod 1000000007\n#define sp ' '\n#define intmax 2147483647\n#define intmin -2147483647\n#define llmax 9223372036854775807\ntypedef long long ll;\nusing namespace std;\n\nint h, w, k;\nint c[31][30];\nchar cmem[31][30];\nint p[30];\nint mx, cnt, cnt2, mem;\nbool flag, flag2;\n\nll gcd(ll x, ll y) {\n\tif (y == 0) return x;\n\treturn gcd(y, x%y);\n}\nll lcm(ll x, ll y) {\n\tll g = gcd(x, y);\n\treturn x / g * y;\n}\n\n\nint main(){\n\tcin >> h >> w >> k;\n\tif (k > 3) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tlp(w)\n\t\tcmem[0][i] = 10 + i;\n\t\n\tlp(h)\n\t\tLP(w, j) {\n\t\t\tcin >> cmem[i+1][j];\n\t\t\tcmem[i + 1][j] = cmem[i + 1][j] - '0';\n\t\t}\n\t\n\tmx = 0;\n\tif (k == 2) {\n\t\tlp(h) {\n\t\t\tLP(w, j) {\n\t\t\t\tLP(h + 1, l) {\n\t\t\t\t\tLP(w, m) {\n\t\t\t\t\t\tc[l][m] = cmem[l][m];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc[i + 1][j] = 0;\n\n\t\t\t\tcnt = 0;\n\t\t\t\tcnt2 = 0;\n\t\t\t\tflag2 = true;\n\n\t\t\t\twhile (flag2) {\n//\t\t\t\t\tLP(h + 1, l) {\n//\t\t\t\t\t\tLP(w, m) {\n//\t\t\t\t\t\t\tcout << c[l][m] << sp;\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\tcout << endl;\n//\t\t\t\t\t}\n//\t\t\t\t\tcout << endl;\n\t\t\t\t\tflag2 = false;\n\t\t\t\t\tcnt2++;\n\n\t\t\t\t\tLP(w, l)\n\t\t\t\t\t\tp[l] = h+1;\n\n\t\t\t\t\tLP(h, l) {\n\t\t\t\t\t\tLP(w, m) {\n\t\t\t\t\t\t\tp[m]--;\n\t\t\t\t\t\t\tif (p[m] < 0)p[m] = 0;\n\t\t\t\t\t\t\twhile (c[p[m]][m] == 0)p[m]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tLP(w - 1, m) {\n\t\t\t\t\t\t\tif (c[p[m]][m] == c[p[m + 1]][m + 1]) {\n\t\t\t\t\t\t\t\tflag2 = true;\n\t\t\t\t\t\t\t\tfor (int n = m; n < w-1; n++) {\n\t\t\t\t\t\t\t\t\tif (c[p[n]][n] == c[p[n + 1]][n + 1])mem = n + 1;\n\t\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcnt += c[p[m]][m] * (mem - m + 1) << (cnt2 - 1);\n\t\t\t\t\t\t\t\tfor (int n = m; n <= mem; n++)\n\t\t\t\t\t\t\t\t\tc[p[n]][n] = 0;\n\t\t\t\t\t\t\t\tm = mem;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmx = max(mx, cnt);\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tlp(h) {\n\t\t\tLP(w, j) {\n\t\t\t\tLP(h + 1, l) {\n\t\t\t\t\tLP(w, m) {\n\t\t\t\t\t\tc[l][m] = cmem[l][m];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc[i + 1][j] = 0;\n\n\t\t\t\tcnt = 0;\n\t\t\t\tcnt2 = 0;\n\t\t\t\tflag2 = true;\n\n\t\t\t\twhile (flag2) {\n\t\t\t\t\t//\t\t\t\t\tLP(h + 1, l) {\n\t\t\t\t\t//\t\t\t\t\t\tLP(w, m) {\n\t\t\t\t\t//\t\t\t\t\t\t\tcout << c[l][m] << sp;\n\t\t\t\t\t//\t\t\t\t\t\t}\n\t\t\t\t\t//\t\t\t\t\t\tcout << endl;\n\t\t\t\t\t//\t\t\t\t\t}\n\t\t\t\t\t//\t\t\t\t\tcout << endl;\n\t\t\t\t\tflag2 = false;\n\t\t\t\t\tcnt2++;\n\n\t\t\t\t\tLP(w, l)\n\t\t\t\t\t\tp[l] = h + 1;\n\n\t\t\t\t\tLP(h, l) {\n\t\t\t\t\t\tLP(w, m) {\n\t\t\t\t\t\t\tp[m]--;\n\t\t\t\t\t\t\tif (p[m] < 0)p[m] = 0;\n\t\t\t\t\t\t\twhile (c[p[m]][m] == 0)p[m]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tLP(w - 2, m) {\n\t\t\t\t\t\t\tif (c[p[m]][m] == c[p[m + 1]][m + 1] && c[p[m + 1]][m + 1] == c[p[m + 2]][m + 2]) {\n\t\t\t\t\t\t\t\tflag2 = true;\n\t\t\t\t\t\t\t\tfor (int n = m; n < w - 1; n++) {\n\t\t\t\t\t\t\t\t\tif (c[p[n]][n] == c[p[n + 1]][n + 1])mem = n + 1;\n\t\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcnt += c[p[m]][m] * (mem - m + 1) << (cnt2 - 1);\n\t\t\t\t\t\t\t\tfor (int n = m; n <= mem; n++)\n\t\t\t\t\t\t\t\t\tc[p[n]][n] = 0;\n\t\t\t\t\t\t\t\tm = mem;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmx = max(mx, cnt);\n\t\t\t}\n\t\t}\n\t\n\t}\n\n\tcout << mx << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _GLIBCXX_DEBUG\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define rep1(i, n) for(int i = 1; i < (n); ++i)\nusing namespace std;\ntypedef long long ll;\n\nvector<vector<int>> refresh(vector<vector<int>> b, int h, int w){\n    vector<vector<int>> ret(h, vector<int>(w, 0));\n    rep(j, w){\n        vector<int> nonzero;\n        for(int i = h-1; i >= 0; --i){\n            if(b[i][j] != 0) nonzero.push_back(b[i][j]);\n        }\n\n        rep(i, nonzero.size()){\n            ret[h-i-1][j] = nonzero[i];\n        }\n\n    }\n\n    return ret;\n}\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    \n    int h, w, k;\n    cin >> h >> w >> k;\n\n    vector<string> s(h);\n    rep(i, h) cin >> s[i];\n    vector<vector<int>> board(h, vector<int>(w));\n    rep(i, h) rep(j, w) board[i][j] = s[i][j] - '0';\n\n    int res = 0;\n\n    rep(si, h) rep(sj, w){\n\n        vector<vector<int>> b = board;\n        b[si][sj] = 0;\n\n        b = refresh(b, h, w);\n\n        int score = 0;\n        int turn = 0;\n        while(1){\n\n            int sm = 0;\n            rep(i, h){\n\n                vector<pair<int, int>> vp;\n                vp.push_back(make_pair(b[i][0], 1));\n\n                rep1(j, w){\n                    if(b[i][j] == vp.back().first) ++vp.back().second;\n                    else{\n                        vp.push_back(make_pair(b[i][j], 1));\n                    }\n                }\n\n                // rep(j, vp.size()) cout << vp[j].first << \":\" << vp[j].second << \" \";\n                // cout << endl;\n\n                int ptr = 0;\n                rep(j, vp.size()){\n                    if(vp[j].second < k){\n                        ptr += vp[j].second;\n                    }\n                    else{\n                        sm += pow(2, turn)*(vp[j].first*vp[j].second);\n                        for(int l = ptr; l < ptr+vp[j].second; ++l){\n                            b[i][l] = 0;\n                        }\n                        ptr += vp[j].second;\n                    }\n                }\n                // cout << endl;\n                // rep(m, h){\n                //     rep(o, w) cout << b[m][o] << \" \";\n                //     cout << endl;\n                // }\n\n            }\n\n            if(sm == 0) break;\n            else{\n                score += sm;\n                b = refresh(b, h, w);\n            }\n\n            ++turn;\n        }\n\n        res = max(res, score);\n    }\n\n    cout << res << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\ntemplate<typename T> void swap(T & x, T & y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T & a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T & a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nint h, w, k;\nchar s[30][31];\nint ans;\n\nint main() {\n\tscanf(\"%d%d%d\", &h, &w, &k);\n\tinc(i, h) { scanf(\"%s\", s[i]); }\n\t\n\tinc(ii, h) {\n\tinc(jj, w) {\n\t\tint b[30][30];\n\t\tinc(i, h) {\n\t\tinc(j, w) {\n\t\t\tb[i][j] = s[i][j] - '0';\n\t\t}\n\t\t}\n\t\t\n\t\tint score = 0;\n\t\tb[ii][jj] = -1;\n\t\tint counter = 0;\n\t\tbool flag;\n\t\tdo {\n\t\t\tinc(j, w) { int bot = h - 1;\n\t\t\tdec(i, h) {\n\t\t\t\tif(b[i][j] == -1) { continue; }\n\t\t\t\tint temp = b[i][j];\n\t\t\t\tb[i][j] = -1;\n\t\t\t\tb[bot][j] = temp;\n\t\t\t\tbot--;\n\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tflag = false;\n\t\t\tinc(i, h) { int len = 1, pre = -2;\n\t\t\tinc(j, w) {\n\t\t\t\tif(b[i][j] == pre) { len++; } else { len = 1; pre = b[i][j]; }\n\t\t\t\tif(b[i][j] != -1 && len == k) {\n\t\t\t\t\tincII(jjj, j - (k - 1), j) {\n\t\t\t\t\t\tscore += (1 << counter) * b[i][jjj];\n\t\t\t\t\t\tb[i][jjj] = -1;\n\t\t\t\t\t}\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t\tif(b[i][j] != -1 && len >  k) {\n\t\t\t\t\tscore += (1 << counter) * b[i][j];\n\t\t\t\t\tb[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcounter++;\n\t\t} while(flag);\n\t\t\n\t\tsetmax(ans, score);\n\t}\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n    Problem 93\n    https://atcoder.jp/contests/s8pc-3/tasks/s8pc_3_b\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n/* typedef */\ntypedef long long ll;\ntypedef pair<int, int> pii;\n/* class */\nclass pazzle {\n    public:\n    int H, W, K;\n    ll ans = 0;\n    vector<vector<int> > v;\n    pazzle (int H, int W, int K, vector<vector<int> > v)\n    : H(H), W(W), K(K), v(v) {}\n    bool del() {\n        int ret = false;\n        for (int i = 0; i < H; i++) {\n            int r = 0;\n            for (int l = 0; l < W; l++) {\n                int tmp = v[i][r];\n                while (v[i][r] == -1) {\n                    r++;\n                    l++;\n                }\n                while (v[i][r] == v[i][r + 1]){\n                    r++;\n                    tmp += v[i][r];\n                }\n                if (r - l + 1>= K) {\n                    for (int k = l; k <= r; k++) v[i][k] = -1;\n                    ans += tmp;\n                    ret = true;\n                }\n                l = r;\n                r++;\n            }\n        }\n        return ret;\n    }\n    void move() {\n        for (int i = 0; i < W; i++) {\n            for (int j = H - 1; j > 0; j--) {\n                if (v[j][i] == -1) {\n                    int k = j - 1;\n                    while (v[k][i] == -1 && k > 0) k--;\n                    if (v[k][i] != -1) swap(v[k][i], v[j][i]);\n                }\n            }\n        }\n    }\n    void printPoint() {\n        cout << ans << '\\n';\n    }\n    ll gameStart() {\n        ll ret = 0;\n        move();\n        for (int i = 0; del(); i++){\n            move();\n            ret += pow(2, i) * ans;\n            ans = 0;\n        }\n        return ret;\n    }\n};\n/* constant */\n/* global variables */\n/* function */\n/* main */\nint main(){\n    int H, W, K;\n    cin >> H >> W >> K;\n    vector<string> vs(H);\n    for (int i = 0; i < H; i++) cin >> vs[i];\n    vector<vector<int> > v(H, vector<int> (W + 1, -2));\n    for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) v[i][j] = vs[i][j] - '0';\n    if (K == 1) {\n        int ans = 0;\n        for (auto vi : v) ans += accumulate(vi.begin(), vi.end(), 0);\n        cout << ans << '\\n';\n        return 0;\n    }\n    ll ans = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int tmp = v[i][j];\n            v[i][j] = -1;\n            pazzle P = pazzle(H, W, K, v);\n            ans = max(ans, P.gameStart());\n            v[i][j] = tmp;\n        }\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ temp.cpp\n// C++ includes used for precompiling -*- C++ -*-\n\n// Copyright (C) 2003-2013 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file stdc++.h\n *  This is an implementation file for a precompiled header.\n */\n\n// 17.4.1.2 Headers\n\n// C\n//#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n/*\n//#if __cplusplus >= 201103L\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n*/\n\n// C++\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n/*\n//#if __cplusplus >= 201103L\n#include <array>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n*/\nusing namespace std;\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n  \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\n\n#define INF INT_MAX/3\n#define MAX_N 1000\n int h,w,k;\n vector<string> vec;\n vector<string> crnt;\n\n int search(int itr){\n  int ret=0;\n  //消せることを0で埋めながら加算していく\n  bool changed = false;\n  rep(i,h){\n    rep(j,w-1){\n      //0ということはもうそこには数字が入っていないということだからcontinueしていい\n      if(crnt[i][j]==0) continue;\n      int d=0;\n      //横の値が等しいだけ加算していく\n      while(j+d<w&&crnt[i][j]==crnt[i][j+d]) d++;\n      if(d>=k){\n        //もし規定の長さを超えたなら\n        //加算して消した所に0を代入していく\n        //スコアはi回目で消滅した数字の値の和なのでbitをずらすことで実現している\n        ret += (1<<itr) * (crnt[i][j]-'0')*d;\n        rep(dd,d) crnt[i][j+dd] = 0;\n        changed = true;\n      }\n      //dが増えていたらそのぶんずらしてあげてそうでなかったら-1してインクリメント\n      //される時にその点から始まるようにする\n    j += d-1;\n  }\n }\n //変化が一つもない場合はもう返す\n if(!changed) return ret;\n\n //-1をつめる\n rep(j,w){\n  int s=h-1;\n  for(int hh=h-1;hh>=0;hh--){\n    while(s>=0&crnt[s][j]==0) s--;\n    if(s<0) crnt[hh][j]=0;//もう入っていないということ\n    else crnt[hh][j] = crnt[s][j];\n    s--;\n    }\n }\n return ret + search(itr+1);\n}\n\n int main(){\n  cin>>h>>w>>k;\n  //resizeとは\n  //指定した数だけ実際に何らかの値で埋める。\n  ///\n  vec.resize(h);\n  rep(i,h) cin>>vec[i];\n\n  int res=0;\n  rep(i,h) rep(j,w){\n    //ここで作り直したものを入れ直している\n    crnt = vector<string>(vec);\n    for(int ii=i;ii>0;ii--) crnt[ii][j] = crnt[ii-1][j];\n      crnt[0][j]=0;\n    //ここで消す作業をしている\n    res = max(res,search(0));\n  }\n  cout<<res<<endl;\n }\n // http://s8pc-3.contest.atcoder.jp/submissions/987968"
  },
  {
    "language": "C++",
    "code": "#define MOD 100000\n\n#if 1\n//------------------------------------------------------------\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T>\nstruct Entry { static void Run() { T().Run(); } };\nstruct MyMain;\n\n#if defined(TEST)\n#include \"test.hpp\"\n#else\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout << fixed << setprecision(16);\n\tEntry<MyMain>::Run();\n\treturn 0;\n}\n#endif\n\n//------------------------------------------------------------\nusing ll = long long;\n#define int ll\n\n#define FOR(i, s, e) for (ll i = ll(s); i < ll(e); ++i)\n#define RFOR(i, s, e) for (ll i = ll(e) - 1; i >= ll(s); --i)\n#define REP(i, n) for (ll i = 0, i##_size = ll(n); i < i##_size; ++i)\n#define RREP(i, n) for (ll i = ll(n) - 1; i >= 0; --i)\n\n#define INF INT64_MAX\n\n//------------------------------------------------------------\ntemplate <class T>\nstruct ContainerHolder {\n\tbool flag = true;\n\tT& var;\n\tContainerHolder(T& v) : var(v) {}\n\toperator bool() const { return flag; }\n\tT* operator->() { return &var; }\n};\ntemplate <class T> ContainerHolder<T> ContainerHold(T& v) { return ContainerHolder<T>(v); }\n\n#define CFOR(it, container) \\\n\tfor (auto holder = ContainerHold(container); holder; holder.flag = false) \\\n\tfor (auto it = holder->begin(), endIt = holder->end(); it != endIt; ++it)\n\n//------------------------------------------------------------\ntemplate <class T>\nstruct arr : public vector<T> {\n\tarr() {}\n\tarr(initializer_list<T> il) : vector<T>(il) {}\n\texplicit arr(ll n, T v = T()) : vector<T>(n, v) {}\n\n\tT& operator()(int i) { return (*this)[i]; }\n\tT const& operator()(int i) const { return (*this)[i]; }\n\tvoid init(ll n, T v = T()) {\n\t\tthis->clear();\n\t\tthis->resize(n, v);\n\t}\n\tll sz() const { return (ll)this->size(); }\n\tvoid pb(T v) { this->push_back(v); }\n\tvoid sort() { std::sort(this->begin(), this->end()); }\n\tvoid sort(function<bool(T, T)> p) { std::sort(this->begin(), this->end(), p); }\n\tvoid rsort() { std::sort(this->begin(), this->end(), greater<T>()); }\n\tvoid unique_erase() { this->erase(std::unique(this->begin(), this->end()), this->end()); }\n\tbool next_permutation() { return std::next_permutation(this->begin(), this->end()); }\n\n\t// これ以下はソート済み前提\n\tint lower_bound(T const& v, function<bool(T, T)> p) { return std::lower_bound(this->begin(), this->end(), v, p) - this->begin(); }\n\tint lower_bound(T const& v) { return std::lower_bound(this->begin(), this->end(), v) - this->begin(); }\n\n\tint upper_bound(T const& v, function<bool(T, T)> p) { return std::upper_bound(this->begin(), this->end(), v, p) - this->begin(); }\n\tint upper_bound(T const& v) { return std::upper_bound(this->begin(), this->end(), v) - this->begin(); }\n\n\tint find_nearest(T const& v) {\n\t\tint i = this->lower_bound(v);\n\t\tif (i >= sz()) {\n\t\t\t--i;\n\t\t}\n\t\telse if ((*this)[i] != v) {\n\t\t\tint p = i - 1;\n\t\t\tif (p >= 0) {\n\t\t\t\tint id = abs((*this)[i] - v);\n\t\t\t\tint pd = abs((*this)[p] - v);\n\t\t\t\tif (pd < id) {\n\t\t\t\t\ti = p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn i;\n\t}\n\n\t// 見つからなければ-1\n\tint find(T const& v) {\n\t\tint i = this->lower_bound(v);\n\t\tif (i >= sz()) {\n\t\t\treturn -1;\n\t\t}\n\t\tif ((*this)[i] != v) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn i;\n\t}\n\n};\nusing ints = arr<ll>;\n\ntemplate <class T>\nstruct que : public queue<T> {\n\tll sz() const { return (ll)this->size(); }\n\tT popfront() {\n\t\tT v = this->front();\n\t\tthis->pop();\n\t\treturn v;\n\t}\n};\n\ntemplate <class A, class B>\nstruct pr {\n\tunion {\n\t\tA a;\n\t\tA key;\n\t\tA first;\n\t\tA x;\n\t};\n\tunion {\n\t\tB b;\n\t\tB value;\n\t\tB second;\n\t\tB y;\n\t};\n\n\tpr() : a(A()), b(B()) {};\n\tpr(A a_, B b_) : a(a_), b(b_) {}\n\tpr(pr const& r) : a(r.a), b(r.b) {};\n\tpr(pair<A, B> const& r) : a(r.first), b(r.second) {};\n\n\tbool operator == (pr const& r) const { return a == r.a && b == r.b; }\n\tbool operator != (pr const& r) const { return !((*this) == r); }\n\tbool operator < (pr const& r) const {\n\t\tif (a == r.a) {\n\t\t\treturn b < r.b;\n\t\t}\n\t\treturn a < r.a;\n\t}\n\n\tpr operator + (pr v) const { return pr(x, y) += v; }\n\tpr operator - (pr v) const { return pr(x, y) -= v; }\n\n\tpr& operator += (pr v) {\n\t\tx += v.x;\n\t\ty += v.y;\n\t\treturn *this;\n\t}\n\tpr& operator -= (pr v) {\n\t\tx -= v.x;\n\t\ty -= v.y;\n\t\treturn *this;\n\t}\n\n\tvoid flip() { swap(x, y); }\n\n\tfriend istream& operator>>(istream& is, pr& p) {\n\t\tis >> p.a >> p.b;\n\t\treturn is;\n\t}\n\tfriend ostream& operator<<(ostream& os, pr const& p) {\n\t\tos << p.a << \" \" << p.b;\n\t\treturn os;\n\t}\n};\nusing pint = pr<ll, ll>;\nusing pints = arr<pint>;\n\ntemplate <class K, class V>\nstruct dic : public map<K, V> {\n\tbool get(K const& k, V* v) {\n\t\tauto it = this->find(k);\n\t\tif (it != this->end()) {\n\t\t\t*v = it->second;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n};\n\ntemplate <class T>\nstruct arr2 {\n\tvector<T>\tm_vec;\n\tint\t\t\tm_width;\n\tint\t\t\tm_height;\n\n\tarr2() : m_width(0), m_height(0) {}\n\tarr2(int w, int h, T const& value = T()) : m_width(w), m_height(h) {\n\t\tm_vec.resize(w * h, value);\n\t}\n\tarr2(arr2 const& r) {\n\t\tm_vec = r.m_vec;\n\t\tm_width = r.m_width;\n\t\tm_height = r.m_height;\n\t}\n\tarr2(arr2&& r) {\n\t\tm_vec = move(r.m_vec);\n\t\tm_width = r.m_width;\n\t\tm_height = r.m_height;\n\t}\n\tarr2& operator=(arr2 const& r) {\n\t\tm_vec = r.m_vec;\n\t\tm_width = r.m_width;\n\t\tm_height = r.m_height;\n\t\treturn *this;\n\t}\n\tarr2& operator=(arr2&& r) {\n\t\tm_vec = move(r.m_vec);\n\t\tm_width = r.m_width;\n\t\tm_height = r.m_height;\n\t\treturn *this;\n\t}\n\n\tbool operator ==(arr2 const& r) const{\n\t\treturn m_vec = r.m_vec;\n\t}\n\n\tbool operator <(arr2 const& r) const {\n\t\tif (m_width != r.m_width) {\n\t\t\treturn m_width < r.m_width;\n\t\t}\n\t\tif (m_height != r.m_height) {\n\t\t\treturn m_height < r.m_height;\n\t\t}\n\t\tREP(i, m_vec.size()) {\n\t\t\tif (m_vec[i] != r.m_vec[i]) {\n\t\t\t\treturn m_vec[i] < r.m_vec[i];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpint size() const { return pint(m_width, m_height); }\n\tint width() const { return m_width; }\n\tint height() const { return m_height; }\n\n\tvoid init(int w, int h, T const& value = T()) {\n\t\tm_vec.clear();\n\t\tm_vec.resize(w * h, value);\n\t\tm_width = w;\n\t\tm_height = h;\n\t}\n\tvoid init(pint size, T const& value = T()) {\n\t\tinit(size.x, size.y, value);\n\t}\n\tT& operator()(int x, int y) { return m_vec[y * m_width + x]; }\n\tT const& operator()(int x, int y) const { return m_vec[y * m_width + x]; }\n\n\tT& operator()(pint p) { return m_vec[p.y * m_width + p.x]; }\n\tT const& operator()(pint p) const { return m_vec[p.y * m_width + p.x]; }\n\n\tT& operator[](pint p) { return m_vec[p.y * m_width + p.x]; }\n\tT const& operator[](pint p) const { return m_vec[p.y * m_width + p.x]; }\n\n\tbool isIn(int x, int y) const {\n\t\treturn\n\t\t\tx >= 0 && x < m_width &&\n\t\t\ty >= 0 && y < m_height;\n\t}\n\tbool isIn(pint p) const { return isIn(p.x, p.y); }\n\tbool isOut(int x, int y) const {\n\t\treturn\n\t\t\tx < 0 || x >= m_width ||\n\t\t\ty < 0 || y >= m_height;\n\t}\n\tbool isOut(pint p) const { return isOut(p.x, p.y); }\n\n\tstruct iterator {\n\tprivate:\n\t\tarr2<T>* owner;\n\n\tpublic:\n\t\tpint pt;\n\n\t\titerator(arr2<T>* owner_, pint pt_) : owner(owner_), pt(pt_) {}\n\n\t\tbool operator ==(iterator const& r) const {\n\t\t\treturn pt == r.pt;\n\t\t}\n\t\tbool operator !=(iterator const& r) const {\n\t\t\treturn !((*this) == r);\n\t\t}\n\t\tvoid operator++() {\n\t\t\t++pt.x;\n\t\t\tif (pt.x >= owner->width()) {\n\t\t\t\t++pt.y;\n\t\t\t\tpt.x = 0;\n\t\t\t}\n\t\t}\n\t\tT& operator*() {\n\t\t\treturn (*owner)(pt);\n\t\t}\n\t};\n\titerator begin() {\n\t\treturn iterator(this, pint(0, 0));\n\t}\n\titerator end() {\n\t\treturn iterator(this, pint(0, height()));\n\t}\n\n\tvoid disp(ostream& os) {\n\t\tREP(y, m_height) {\n\t\t\tREP(x, m_width) {\n\t\t\t\tos << setw(2) << (*this)(x, y) << \" \";\n\t\t\t}\n\t\t\tos << endl;\n\t\t}\n\t\tos << endl;\n\t}\n};\n\nconst pints around4 = { pint(-1, 0), pint(0, -1), pint(1, 0), pint(0, 1) };\n\n// 6角形グリッド用\nconst pints around6[2] = {\n\t{ pint(0, -1), pint(1, -1), pint(-1, 0), pint(1, 0), pint(0, 1), pint(1, 1) },\n\t{ pint(-1, -1), pint(0, -1), pint(-1, 0), pint(1, 0), pint(-1, 1), pint(0, 1) }\n};\n\n//------------------------------------------------------------\ntemplate <class T> void chmin(T& a, T b) { if (b < a) { a = b; } }\ntemplate <class T> void chmax(T& a, T b) { if (b > a) { a = b; } }\n\nconstexpr int gcd(int a, int b) {\n\tif (a < 0) { a = -a; }\n\tif (b < 0) { b = -b; }\n\tif (a == 0) { return b; }\n\tif (b == 0) { return a; }\n\n\twhile (int c = a % b) {\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn b;\n}\n\nstruct bfs {\n\tints froms;\n\tints steps;\n\n\tbfs(int N, int start, function<ints(int)> getAround) {\n\t\tfroms.init(N, -1);\n\t\tsteps.init(N, -1);\n\n\t\tque<ll> queue;\n\t\tqueue.push(start);\n\t\tfroms[start] = start;\n\t\tsteps[start] = 0;\n\n\t\twhile (queue.empty() == false) {\n\t\t\tll p = queue.popfront();\n\n\t\t\tfor (ll n : getAround(p)) {\n\t\t\t\tif (steps[n] != -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfroms[n] = p;\n\t\t\t\tsteps[n] = steps[p] + 1;\n\t\t\t\tqueue.push(n);\n\t\t\t}\n\t\t}\n\t}\n};\n\nstruct BfsResult {\n\tarr2<pint> froms;\n\tarr2<int> steps;\n};\n\ntemplate <class T, class F>\nBfsResult bfs2(arr2<T> const& field, pint start, F canMove) {\n\tBfsResult result;\n\tresult.froms.init(field.size(), pint(-1, -1));\n\tresult.steps.init(field.size(), -1);\n\n\tque<pint> queue;\n\tqueue.push(start);\n\tresult.froms(start) = start;\n\tresult.steps(start) = 0;\n\n\twhile (queue.empty() == false) {\n\t\tauto p = queue.popfront();\n\n\t\tfor (auto a : around4) {\n\t\t\tpint n = p + a;\n\t\t\tif (field.isOut(n)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (result.steps(n) != -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!canMove(field(n))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresult.froms(n) = p;\n\t\t\tresult.steps(n) = result.steps(p) + 1;\n\t\t\tqueue.push(n);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n// getAround(count) -> around\n// getCost(from, to) -> cost\nint d9str(int N, int a, int b, function<ints(int)> getAround, function<int(int, int)> getCost) {\n\tstruct Node {\n\t\tint point;\n\t\tint totalCost;\n\n\t\tbool operator < (Node const& n) const {\n\t\t\treturn totalCost > n.totalCost;\n\t\t}\n\t};\n\n\tints minCosts(N, INT64_MAX);\n\tpriority_queue<Node> que;\n\n\tminCosts(a) = 0;\n\tque.push(Node{ a, 0});\n\n\twhile (!que.empty()) {\n\t\tNode node = que.top();\n\t\tque.pop();\n\n\t\tfor (int next : getAround(node.point)) {\n\t\t\tint cost = getCost(node.point, next);\n\t\t\tif (cost < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tNode newNode;\n\t\t\tnewNode.point = next;\n\t\t\tnewNode.totalCost = node.totalCost + cost;\n\n\t\t\tif (newNode.totalCost < minCosts[newNode.point]) {\n\t\t\t\tminCosts[newNode.point] = newNode.totalCost;\n\t\t\t\tque.push(newNode);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (minCosts[b] == INT64_MAX) {\n\t\treturn -1;\n\t}\n\n\treturn minCosts[b];\n}\n\n// graph : 隣接行列。i=jは0、未接続はinfで初期化済みであること\n// return false なら負の閉路あり\nbool WarshallFloyd(arr2<int>& graph, int inf) {\n\tint N = graph.width();\n\n\tREP(k, N) {\n\t\tREP(i, N) {\n\t\t\tREP(j, N) {\n\t\t\t\tif (graph(i, k) == inf || graph(k, j) == inf) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tchmin(graph(i, j), graph(i, k) + graph(k, j));\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(i, N) {\n\t\tif (graph(i, i) < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n\ntemplate <class PREDICATE>\nint bsearch(int l, int r, PREDICATE p) {\n\twhile (l < r) {\n\t\tint c = (l + r) / 2;\n\n\t\tif (p(c)) {\n\t\t\tr = c;\n\t\t}\n\t\telse {\n\t\t\tl = c + 1;\n\t\t}\n\t}\n\n\treturn r;\n}\n\n// func(x)の極値となるxを返す\ndouble num_analyze(function<double(double)> func, double l, double r, int step = 10000, double delta = 0.000001) {\n\tauto diff = [&](double x) {\n\t\tdouble a = func(x);\n\t\tdouble b = func(x + delta);\n\t\treturn (b * b - a * a);\n\t};\n\n\tREP(i, step) {\n\t\tdouble c = (l + r) / 2.0;\n\t\tdouble d = diff(c);\n\t\tif (d < 0) {\n\t\t\tl = c;\n\t\t}\n\t\telse {\n\t\t\tr = c;\n\t\t}\n\t}\n\treturn l;\n}\n\n//------------------------------------------------------------\ntemplate <int M>\nstruct modint {\n\tint raw;\n\n\tmodint() { raw = 0; }\n\tmodint(int v) {\n\t\tif (v < 0) {\n\t\t\traw = (v % M) + M;\n\t\t}\n\t\telse if (v >= M) {\n\t\t\traw = v % M;\n\t\t}\n\t\telse {\n\t\t\traw = v;\n\t\t}\n\t}\n\tmodint operator + (modint v) const { return modint(raw) += v; }\n\tmodint operator - (modint v) const { return modint(raw) -= v; }\n\tmodint operator * (modint v) const { return modint(raw) *= v; }\n\n\tmodint& operator += (modint v) {\n\t\traw += v.raw;\n\t\tif (raw >= M) { raw -= M; }\n\t\treturn *this;\n\t}\n\tmodint& operator -= (modint v) {\n\t\traw -= v.raw;\n\t\tif (raw < 0) { raw += M; }\n\t\treturn *this;\n\t}\n\tmodint& operator *= (modint v) {\n\t\traw = (raw * v.raw) % M;\n\t\treturn *this;\n\t}\n\tmodint pow(int n) const {\n\t\treturn modint::pow(raw, n);\n\t}\n\tstatic modint pow(int a, int n) {\n\t\tif (n < 0) {\n\t\t\t// not support\n\t\t\tabort();\n\t\t}\n\n\t\tint r = 1;\n\t\twhile (n) {\n\t\t\tif (n & 1) {\n\t\t\t\tr = (r * a) % M;\n\t\t\t}\n\t\t\ta = (a * a) % M;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn modint(r);\n\t}\n\n\tmodint inv() const {\n\t\tint a = raw;\n\t\tint b = M;\n\t\tint u = 1;\n\t\tint v = 0;\n\t\twhile (b) {\n\t\t\tint t = a / b;\n\t\t\ta -= t * b;\n\t\t\tu -= t * v;\n\t\t\tswap(a, b);\n\t\t\tswap(u, v);\n\t\t}\n\t\tu %= M;\n\t\tif (u < 0) {\n\t\t\tu += M;\n\t\t}\n\t\treturn u;\n\t}\n\n\tfriend istream& operator>>(istream& is, modint& m) {\n\t\tint v;\n\t\tis >> v;\n\t\tm = modint(v);\n\t\treturn is;\n\t}\n\tfriend ostream& operator<<(ostream& os, modint const& m) {\n\t\treturn os << m.raw;\n\t}\n};\n\nusing mint = modint<MOD>;\nusing mints = arr<mint>;\n\n//------------------------------------------------------------\nstruct LoopIndex {\n\tint const N;\n\tLoopIndex(int N_) : N(N_) { }\n\n\tint left(int i) {\n\t\treturn (i - 1 + N) % N;\n\t}\n\tint right(int i) {\n\t\treturn (i + 1) % N;\n\t}\n};\n\n//------------------------------------------------------------\nstruct UnionFind {\n\tstruct Node {\n\t\tNode*\tparent = nullptr;\n\t\tint\t\tcount = 1;\n\n\t\tNode* Root() {\n\t\t\tif (parent == nullptr) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\treturn parent = parent->Root();\n\t\t}\n\t};\n\tvector<Node> nodes;\n\n\tUnionFind(int count) {\n\t\tnodes.resize(count);\n\t}\n\n\tvoid Join(int a, int b) {\n\t\tNode* rootA = nodes[a].Root();\n\t\tNode* rootB = nodes[b].Root();\n\t\tif (rootA == rootB) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (rootA->count > rootB->count) {\n\t\t\tswap(rootA, rootB);\n\t\t}\n\n\t\trootB->count += rootA->count;\n\t\trootA->parent = rootB;\n\t\trootA->count = 0;\n\t}\n\n\tbool IsReachable(int a, int b) {\n\t\tNode* rootA = nodes[a].Root();\n\t\tNode* rootB = nodes[b].Root();\n\t\treturn rootA == rootB;\n\t}\n\n\tint Count(int a) {\n\t\treturn nodes[a].Root()->count;\n\t}\n};\n\n//------------------------------------------------------------\nstruct Kruskal {\n\tstruct Edge {\n\t\tint a;\n\t\tint b;\n\t\tint cost;\n\n\t\tbool operator <(Edge const& r) const{\n\t\t\treturn cost < r.cost;\n\t\t}\n\t};\n\n\tUnionFind uf;\n\tint totalCost;\n\tarr<dic<int, int>> G;\n\n\tKruskal(int N, arr<Edge> edges) : uf(N) {\n\t\tedges.sort();\n\n\t\ttotalCost = 0;\n\n\t\tG.init(N);\n\t\tREP(i, edges.sz()) {\n\t\t\tEdge const& edge = edges[i];\n\t\t\tif (uf.IsReachable(edge.a, edge.b)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tG[edge.a][edge.b] = edge.cost;\n\t\t\tG[edge.b][edge.a] = edge.cost;\n\t\t\tuf.Join(edge.a, edge.b);\n\t\t\ttotalCost += edge.cost;\n\t\t}\n\t}\n};\n\n//------------------------------------------------------------\narr<char> Eratosthenes(int N) {\n\tarr<char> result;\n\n\tresult.init(N, 1);\n\tresult(0) = result(1) = 0;\n\n\tFOR(i, 2, N) {\n\t\tif (result(i) == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int v = i + i; v < N; v += i) {\n\t\t\tresult(v) = 0;\n\t\t}\n}\n\treturn result;\n}\n\nbool IsSo(int v) {\n\tif (v <= 1) {\n\t\treturn false;\n\t}\n\tFOR(i, 2, sqrt(v) + 1) {\n\t\tif (v % i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n};\n\n//------------------------------------------------------------\ntemplate <class T>\nstruct SumsImpl {\nprivate:\n\tint N;\n\tarr<T> S;\npublic:\n\n\tSumsImpl(int N_) : N(N_), S(N + 1, 0) {}\n\tvoid Set(int i, T const& value) { S(i + 1) = S(i) + value; }\n\n\t// l <= x < r\n\tT Get(int l, int r) const { return S(r) - S(l); }\n};\nusing Sums = SumsImpl<int>;\n\ntemplate <class T>\nstruct ImosImpl {\nprivate:\n\tint N;\n\tarr<T> S;\npublic:\n\tImosImpl(int N_) : N(N_), S(N + 1, 0) {\n\t}\n\n\tvoid Add(int i, T const& value) {\n\t\tS(i + 1) += value;\n\t}\n\n\tvoid Calc() {\n\t\tREP(i, N) {\n\t\t\tS(i + 1) += S(i);\n\t\t}\n\t}\n\n\t// l <= x < r\n\tT Get(int l, int r) const { return S(r) - S(l); }\n\n\tT Get(int i) const { return S(i); }\n};\nusing Imos = ImosImpl<int>;\n\n\ntemplate <class T>\nstruct Sums2Impl {\nprivate:\n\tarr2<T> sums;\npublic:\n\n\tSums2Impl(int W, int H) : sums(W + 1, H + 1) {}\n\n\tvoid Set(int x, int y, T const& value) {\n\t\tT s = value;\n\t\ts += sums(x + 1, y);\n\t\ts += sums(x, y + 1);\n\t\ts -= sums(x, y);\n\t\tsums(x + 1, y + 1) = s;\n\t}\n\n\t// l <= x < r\n\t// t <= y < b\n\tT Get(int l, int t, int r, int b) const {\n\t\tint s = sums(r, b);\n\t\ts -= sums(r, t);\n\t\ts -= sums(l, b);\n\t\ts += sums(l, t);\n\t\treturn s;\n\t}\n};\nusing Sums2 = Sums2Impl<int>;\n\ntemplate <class T>\nstruct Imos2Impl {\nprivate:\n\tarr2<T> sums;\npublic:\n\n\tImos2Impl(int W, int H) : sums(W + 1, H + 1) {}\n\n\tvoid Add(int x, int y, T const& value) {\n\t\tsums(x + 1, y + 1) += value;\n\t}\n\n\tvoid Calc() {\n\t\tREP(y, sums.height() - 1) {\n\t\t\tREP(x, sums.width() - 1) {\n\t\t\t\tT s = 0;\n\t\t\t\ts += sums(x + 1, y);\n\t\t\t\ts += sums(x, y + 1);\n\t\t\t\ts -= sums(x, y);\n\t\t\t\tsums(x + 1, y + 1) += s;\n\t\t\t}\n\t\t}\n\t}\n\n\t// l <= x < r\n\t// t <= y < b\n\tT Get(int l, int t, int r, int b) const {\n\t\tint s = sums(r, b);\n\t\ts -= sums(r, t);\n\t\ts -= sums(l, b);\n\t\ts += sums(l, t);\n\t\treturn s;\n\t}\n};\nusing Imos2 = Imos2Impl<int>;\n\n//------------------------------------------------------------\nstruct CombiTbl {\n\tmints fac;\n\tmints ifac;\n\n\tCombiTbl(int N) : fac(N), ifac(N) {\n\t\tfac[0] = 1;\n\t\tifac[0] = 1;\n\t\tFOR(i, 1, N) {\n\t\t\tfac[i] = fac[i - 1] * i;\n\t\t\tifac[i] = fac[i].inv();\n\t\t}\n}\n\n\tmint Combi(int a, int b) const {\n\t\treturn fac(a) * ifac(b) * ifac(a - b);\n\t}\n\n\t// N*2のテーブルが無いとだめ\n\tmint RepCombi(int a, int b) const {\n\t\treturn Combi(a + b - 1, b);\n\t}\n};\n\n//------------------------------------------------------------\ntemplate <class T>\nstruct CompressImpl {\nprivate:\n\tarr<T> const& origins;\n\tarr<int> comp2orgIndex;\n\tarr<int> orgIndex2cmp;\n\tdic<T, int> orgValue2cmp;\n\npublic:\n\tCompressImpl(arr<T> const& orgins_) : origins(orgins_) {\n\t\tint N = origins.sz();\n\n\t\tcomp2orgIndex.init(N);\n\t\tREP(i, N) {\n\t\t\tcomp2orgIndex[i] = i;\n\t\t}\n\t\tcomp2orgIndex.sort([&](int a, int b) {\n\t\t\treturn origins[a] < origins[b];\n\t\t});\n\n\t\torgIndex2cmp.init(N);\n\t\tREP(i, N) {\n\t\t\torgIndex2cmp[comp2orgIndex[i]] = i;\n\t\t\torgValue2cmp[origins[comp2orgIndex[i]]] = i;\n\t\t}\n\t}\n\n\tT const& Comp2OrgValue(int comp) const {\n\t\treturn origins[comp2orgIndex[comp]];\n\t}\n\n\tint Comp2OrgIndex(int comp) const {\n\t\treturn comp2orgIndex[comp];\n\t}\n\n\tint OrgValue2Comp(T const& orgValue) const {\n\t\treturn orgValue2cmp.at(orgValue);\n\t}\n\n\tint OrgIndex2Comp(int orgIndex) const {\n\t\treturn orgIndex2cmp[orgIndex];\n\t}\n};\nusing Compress = CompressImpl<int>;\n\n//------------------------------------------------------------\n#if defined(TEST)\nextern istream& mis;\nextern ostream& mos;\n#else\nistream& mis = cin;\nostream& mos = cout;\n#endif\n\n//------------------------------------------------------------\n\nstruct OutputStream {\n\ttemplate <class T>\n\tfriend OutputStream& operator<<(OutputStream& s, T const& v) {\n\t\tmos << v << '\\n';\n\t\treturn s;\n\t}\n} out;\n\nstruct PrintStream {\n\tstringstream ss;\n\n\ttemplate <class T>\n\tfriend PrintStream& operator<<(PrintStream& s, T&& v) {\n\t\ts.ss << v << ' ';\n\t\treturn s;\n\t}\n\t\n\tPrintStream& operator <<(PrintStream& (*manip)(PrintStream&)) {\n\t\treturn (*manip)(*this);\n\t}\n} prn;\n\nPrintStream& en(PrintStream& s) {\n\tstring str = s.ss.str();\n\ts.ss = stringstream();\n\tif (str.empty() == false) {\n\t\tstr.pop_back();\n\t}\n\tmos << str << '\\n';\n\treturn s;\n}\n\n//------------------------------------------------------------\n\ntemplate <class T>\nstruct in_base {\n\tT value;\n\tin_base() { mis >> value; }\n\toperator T() { return value; }\n};\n\nstruct in_int {\n\tint value;\n\n\tin_int() {\n\t\tmis >> value;\n\t}\n\tin_int(int add) {\n\t\tmis >> value;\n\t\tvalue += add;\n\t}\n\toperator int() {\n\t\treturn value;\n\t}\n};\n\ntemplate <class A, class B>\nstruct in_pr {\n\tpr<A, B> value;\n\n\tin_pr() {\n\t\tmis >> value.a >> value.b;\n\t}\n\tin_pr(int addA, int addB) {\n\t\tmis >> value.a >> value.b;\n\t\tvalue.a += addA;\n\t\tvalue.b += addB;\n\t}\n\tin_pr(bool flip) {\n\t\tmis >> value.b >> value.a;\n\t}\n\tin_pr(int addA, int addB, bool flip) {\n\t\tmis >> value.b >> value.a;\n\t\tvalue.a += addB;\n\t\tvalue.b += addA;\n\t}\n\toperator pr<A, B>() {\n\t\treturn value;\n\t}\n};\n\ntemplate <class T>\nstruct in_arr {\n\tarr<T> value;\n\n\tin_arr(int N) {\n\t\tvalue.init(N);\n\t\tREP(i, N) {\n\t\t\tmis >> value[i];\n\t\t}\n\t}\n\tin_arr(int N, int add) {\n\t\tvalue.init(N);\n\t\tREP(i, N) {\n\t\t\tmis >> value[i];\n\t\t\tvalue[i] += add;\n\t\t}\n\t}\n\toperator arr<T>() {\n\t\treturn value;\n\t}\n};\n\ntemplate <>\nstruct in_arr<pint> {\n\tarr<pint> value;\n\n\tin_arr(int N) {\n\t\tvalue.init(N);\n\t\tREP(i, N) {\n\t\t\tmis >> value[i];\n\t\t}\n\t}\n\tin_arr(int N, int addA, int addB) {\n\t\tvalue.init(N);\n\t\tREP(i, N) {\n\t\t\tmis >> value[i].a >> value[i].b;\n\t\t\tvalue[i].a += addA;\n\t\t\tvalue[i].b += addB;\n\t\t}\n\t}\n\tin_arr(int N, bool flip) {\n\t\tvalue.init(N);\n\t\tREP(i, N) {\n\t\t\tmis >> value[i].b >> value[i].a;\n\t\t}\n\t}\n\tin_arr(int N, int addA, int addB, bool flip) {\n\t\tvalue.init(N);\n\t\tREP(i, N) {\n\t\t\tmis >> value[i].b >> value[i].a;\n\t\t\tvalue[i].a += addB;\n\t\t\tvalue[i].b += addA;\n\t\t}\n\t}\n\toperator arr<pint>() {\n\t\treturn value;\n\t}\n};\n\ntemplate <class A, class B>\nstruct in_dic {\n\tdic<A, B> value;\n\n\tin_dic(int N) {\n\t\tREP(i, N) {\n\t\t\tpair<A, B> pr;\n\t\t\tmis >> pr.first >> pr.second;\n\t\t\tvalue.insert(pr);\n\t\t}\n\t}\n\tin_dic(int N, int addA, int addB) {\n\t\tREP(i, N) {\n\t\t\tpair<A, B> pr;\n\t\t\tmis >> pr.first >> pr.second;\n\t\t\tpr.first += addA;\n\t\t\tpr.second += addB;\n\t\t\tvalue.insert(pr);\n\t\t}\n\t}\n\tin_dic(int N, bool flip) {\n\t\tREP(i, N) {\n\t\t\tpair<A, B> pr;\n\t\t\tmis >> pr.second >> pr.first;\n\t\t\tvalue.insert(pr);\n\t\t}\n\t}\n\tin_dic(int N, int addA, int addB, bool flip) {\n\t\tREP(i, N) {\n\t\t\tpair<A, B> pr;\n\t\t\tmis >> pr.second >> pr.first;\npr.first += addB;\npr.second += addA;\nvalue.insert(pr);\n\t\t}\n\t}\n\toperator dic<A, B>() {\n\t\treturn value;\n\t}\n};\n\ntemplate <class T>\nstruct in_arr2 {\n\tarr2<T> value;\n\n\tin_arr2(int H, int W) {\n\t\tvalue.init(W, H);\n\t\tREP(y, H) {\n\t\t\tREP(x, W) {\n\t\t\t\tmis >> value(x, y);\n\t\t\t}\n\t\t}\n\t}\n\tin_arr2(int H, int W, int add) {\n\t\tvalue.init(W, H);\n\t\tREP(y, H) {\n\t\t\tREP(x, W) {\n\t\t\t\tmis >> value(x, y);\n\t\t\t\tvalue(x, y) += add;\n\t\t\t}\n\t\t}\n\t}\n\n\toperator arr2<T>() {\n\t\treturn value;\n\t}\n};\n\ntemplate<class T, class Tuple, size_t... Index>\nT MakeFromTupleImpl(Tuple&& t, index_sequence<Index...>) {\n\treturn T(get<Index>(forward<Tuple>(t))...);\n}\n\ntemplate <class T, class Tuple>\nT MakeFromTuple(Tuple&& t) {\n\treturn MakeFromTupleImpl<T>(forward<Tuple>(t), make_index_sequence<tuple_size<remove_reference_t<Tuple>>::value>{});\n}\n\ntemplate <class... ARGS>\nstruct inputWithParam {\n\ttuple<ARGS...> param;\n\tinputWithParam() {}\n\texplicit inputWithParam(tuple<ARGS...>&& param_) : param(param_) { }\n\n\toperator int() { return MakeFromTuple<in_int>(param); }\n\toperator double() { return MakeFromTuple<in_base<double>>(param); }\n\toperator string() { return MakeFromTuple<in_base<string>>(param); }\n\toperator char() { return MakeFromTuple<in_base<char>>(param); }\n\n\ttemplate <class A, class B>\n\toperator pr<A, B>() { return MakeFromTuple<in_pr<A, B>>(param); }\n\n\ttemplate <class T>\n\toperator arr<T>() { return MakeFromTuple<in_arr<T>>(param); }\n\n\ttemplate <class A, class B>\n\toperator dic<A, B>() { return MakeFromTuple<in_dic<A, B>>(param); }\n\n\ttemplate <class T>\n\toperator arr2<T>() { return MakeFromTuple<in_arr2<T>>(param); }\n\n};\n\nstruct input {\n\toperator int() { return inputWithParam<>(); }\n\toperator double() { return inputWithParam<>(); }\n\toperator string() { return inputWithParam<>(); }\n\toperator char() { return inputWithParam<>(); }\n\n\ttemplate <class A, class B>\n\toperator pr<A, B>() { return inputWithParam<>(); }\n\n\ttemplate <class... ARGS>\n\tinputWithParam<ARGS...> operator()(ARGS&&... args) {\n\t\tinputWithParam<ARGS...> withParam(forward_as_tuple(args...));\n\t\treturn withParam;\n\t}\n} in;\n\n//------------------------------------------------------------\n#endif\n\nstruct MyMain {\n\tint const H = in;\n\tint const W = in;\n\tint const K = in;\n\tarr2<int> base;\n\n\tvoid Run() {\n\t\tbase.init(W, H);\n\t\tREP(y, H) {\n\t\t\tREP(x, W) {\n\t\t\t\tchar c = in;\n\t\t\t\tbase(x, H-1-y) = c - '0';\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tREP(y, H) {\n\t\t\tREP(x, W) {\n\t\t\t\tint score = Calc(x, y);\n\t\t\t\tchmax(ans, score);\n\t\t\t}\n\t\t}\n\t\tout << ans;\n\t}\n\n\tint Calc(int eraseX, int eraseY) {\n\t\tarr2<int> field = base;\n\t\tfield(eraseX, eraseY) = 0;\n\n\t\tint score = 0;\n\n\t\tint baseScore = 1;\n\t\tfor (;;) {\n\t\t\tREP(x, W) {\n\t\t\t\tint to = 0;\n\t\t\t\tREP(from, H) {\n\t\t\t\t\tif (field(x, from) == 0) {\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfield(x, to) = field(x, from);\n\t\t\t\t\t\tif (from != to) {\n\t\t\t\t\t\t\tfield(x, from) = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tto++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbool hasClear = false;\n\n\t\t\tREP(y, H) {\n\t\t\t\tints clear(W);\n\t\t\t\tint cnt = 0;\n\t\t\t\tint left = 0;\n\t\t\t\tREP(x, W) {\n\t\t\t\t\tif (field(x, y) == 0) {\n\t\t\t\t\t\tleft = x;\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (x == 0) {\n\t\t\t\t\t\tleft = 0;\n\t\t\t\t\t\tcnt = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (field(x, y) == field(x - 1, y)) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif (cnt >= K) {\n\t\t\t\t\t\t\tfor (int i = left; i <= x; ++i) {\n\t\t\t\t\t\t\t\tclear[i] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tleft = x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tleft = x;\n\t\t\t\t\t\tcnt = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tREP(x, W) {\n\t\t\t\t\tif (clear(x)) {\n\t\t\t\t\t\tscore += field(x, y) * baseScore;\n\t\t\t\t\t\tfield(x, y) = 0;\n\t\t\t\t\t\thasClear = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasClear == false) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbaseScore *= 2;\n\t\t}\n\n\t\treturn score;\n\t}\n};"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint ans = 0;\n\tcin >> H >> W >> K;\n\tvector<string>v(H);\n\tfor (auto &i : v)cin >> i;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tvector<vector<int>>w(W);\n\t\t\tfor (int k = H - 1; k >= 0; k--) {\n\t\t\t\tfor (int l = 0; l < W; l++) {\n\t\t\t\t\tif (i == k && j == l)continue;\n\t\t\t\t\tw[l].push_back(v[k][l] - '0');\n\t\t\t\t}\n\t\t\t}\n\t\t\tint box = 0;\n\t\t\tfor (int k = 0; k < H; k++) {\n\t\t\t\tfor (int l = H - 1; l >= 0; l--) {\n\t\t\t\t\tint st = W;\n\t\t\t\t\tfor (int m = 0; m < W; m++) {\n\t\t\t\t\t\tif (w[m].size() > l) {\n\t\t\t\t\t\t\tst = m;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int m = st + 1; m < W; m++) {\n\t\t\t\t\t\tif (w[m].size() <= l) {\n\t\t\t\t\t\t\tif (m - st >= K) {\n\t\t\t\t\t\t\t\tbox += ((m - st)*w[st][l]) << k;\n\t\t\t\t\t\t\t\tfor (int n = st; n < m; n++) {\n\t\t\t\t\t\t\t\t\tw[n].erase(w[n].begin() + l);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tst = m + 1;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w[st][l] != w[m][l]) {\n\t\t\t\t\t\t\tif (m - st >= K) {\n\t\t\t\t\t\t\t\tbox += ((m - st)*w[st][l]) << k;\n\t\t\t\t\t\t\t\tfor (int n = st; n < m; n++) {\n\t\t\t\t\t\t\t\t\tw[n].erase(w[n].begin() + l);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tst = m;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (W - st >= K) {\n\t\t\t\t\t\tbox += ((W - st)*w[st][l]) << k;\n\t\t\t\t\t\tfor (int n = st; n < W; n++) {\n\t\t\t\t\t\t\tauto it = w[n];\n\t\t\t\t\t\t\tw[n].erase(w[n].begin() + l);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, box);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint h,w,k;\nchar s[33][33],sav[33][33];\n\nint dfs(int d){\n\trep(j,w){\n\t\tfor(int i=h-1;i>=0;i--){\n\t\t\tif(s[i][j]=='0'){\n\t\t\t\tfor(int ii=i-1;ii>=0;ii--){\n\t\t\t\t\tif(s[ii][j]!='0'){\n\t\t\t\t\t\tswap(s[ii][j],s[i][j]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res=0;\n\trep(i,h){\n\t\tchar pre='-';\n\t\tint cnt=0;\n\t\trep(j,w){\n\t\t\tif(pre==s[i][j]&&s[i][j]!='0')cnt++;\n\t\t\telse{\n\t\t\t\tpre=s[i][j]; cnt=1;\n\t\t\t}\n\t\t\tif(cnt>=k&&(j==w-1||s[i][j+1]!=pre)){\n\t\t\t\tres+=pow(2,d)*(s[i][j]-'0')*cnt;\n\t\t\t\tint l=j;\n\t\t\t\twhile(cnt>0){\n\t\t\t\t\ts[i][l]='0';\n\t\t\t\t\tl--; cnt--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(res==0)return 0;\n\telse return res+dfs(d+1);\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin>>h>>w>>k;\n\trep(i,h)cin>>s[i];\n\tint res=-1;\n\trep(i,h)rep(j,w){\n\t\tmemcpy(sav,s,sizeof(s));\n\t\ts[i][j]='0';\n\t\tmaxch(res,dfs(0));\n\t\tmemcpy(s,sav,sizeof(sav));\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,m,n) for(int i=(m);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\nusing ll = long long;\ntemplate <typename T> using posteriority_queue = priority_queue<T, vector<T>, greater<T> >;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n// const int MOD = 998244353;\nconst int dy[] = {1, 0, -1, 0}, dx[] = {0, -1, 0, 1};\nconst int dy8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dx8[] = {0, -1, -1, -1, 0, 1, 1, 1};\ntemplate <typename T, typename U> inline bool chmax(T &a, U b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T, typename U> inline bool chmin(T &a, U b) { return a > b ? (a = b, true) : false; }\ntemplate <typename T> void unique(vector<T> &a) { a.erase(unique(ALL(a)), a.end()); }\nstruct IOSetup {\n  IOSetup() {\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n  }\n} iosetup;\n\nint main() {\n  int h, w, k; cin >> h >> w >> k;\n  vector<vector<int> > c(w, vector<int>(h));\n  REP(i, h) REP(j, w) {\n    char ch; cin >> ch;\n    c[j][h - 1 - i] = ch - '0';\n  }\n  swap(h, w);\n  int ans = 0;\n  function<void(vector<vector<int> >&)> solve = [&](vector<vector<int> > &sq) {\n    int score = 0;\n    for (int i = 0; ; ++i) {\n      bool erased = false;\n      vector<int> pos_y, pos_x, len;\n      REP(x, w) {\n        for (int y = 0; y < h;) {\n          if (x >= sq[y].size()) {\n            ++y;\n            continue;\n          }\n          int z = y + 1;\n          while (z < h && x < sq[z].size() && sq[z][x] == sq[y][x]) ++z;\n          if (z - y >= k) {\n            pos_y.emplace_back(y);\n            pos_x.emplace_back(x);\n            len.emplace_back(z - y);\n            score += (1 << i) * sq[y][x] * (z - y);\n            erased = true;\n          }\n          y = z;\n        }\n      }\n      int n = pos_y.size();\n      reverse(ALL(pos_y));\n      reverse(ALL(pos_x));\n      reverse(ALL(len));\n      // REP(i, h) {\n      //   REP(j, sq[i].size()) cout << sq[i][j] << ' ';\n      //   cout << endl;\n      // }\n      // cout << \"-----\" << endl;\n      REP(j, n) {\n        for (int y = pos_y[j]; y < pos_y[j] + len[j]; ++y) {\n          sq[y].erase(sq[y].begin() + pos_x[j]);\n        }\n      }\n      if (!erased) break;\n    }\n    chmax(ans, score);\n  };\n  REP(i, h) REP(j, w) {\n    vector<vector<int> > sq(c);\n    sq[i].erase(sq[i].begin() + j);\n    solve(sq);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include <prettyprint.hpp>\n#define debug(...)  cerr << \"[\" << #__VA_ARGS__ << \"]: \", d_err(__VA_ARGS__);\n#else\n#define debug(...) 83;\n#endif\n\nvoid d_err() {\n    cerr << endl;\n}\n\ntemplate <typename H, typename... T>\nvoid d_err(H h, T... t) {\n    cerr << h << \" \";\n    d_err(t...);\n}\n\ntemplate <typename T>\nvoid print(T x) {\n    cout << x << \"\\n\";\n}\n\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define REVFOR(i, m, n) for (int i = (n - 1); i >= (m); --i)\n#define REP(i, n) FOR(i, 0, n)\n#define REVREP(i, n) REVFOR(i, 0, n)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define bcnt __builtin_popcountll\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int,int> Pin;\n\nll INF = 1e16;\nint inf = 1e9;\n\nvoid chmax(ll& x, ll y) {\n    if (x < y) x = y;\n}\n\nstruct UnionFind {\n    vector<int> par;\n\n    UnionFind(int n): par(n, -1) {}\n    void init(int n) { par.assign(n, -1); }\n\n    int root(int x) {\n        if (par[x] < 0) return x;\n        return par[x] = root(par[x]);\n    }\n\n    int issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n\n        if (x == y) return false;\n\n        // merge by size\n        // force size of x to be bigger than that of y\n        if (par[x] > par[y]) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n\n        return true;\n    }\n\n    ll size(int x) {\n        return -par[root(x)];\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    int h, w, k; cin >> h >> w >> k;\n    vector<string> vs(h);\n    REP(i, h) cin >> vs[i];\n\n    vector<vi> v(h, vi(w));\n    REP(i, h) REP(j, h) v[i][j] = vs[i][j] - '0';\n\n    // calc score\n    auto get_score = [&](vector<vi>& v) -> ll {\n        ll score = 0;\n        int cnt_clear = 0;\n        while(1) {\n            ll cur = 0;\n            vector<vector<bool>> clear(h, vector<bool>(w, false));\n\n            REP(i, h) {\n                int prev = -1;\n                int cnt = 0;\n                REP(j, w) {\n                    if (v[i][j] == -1) {\n                        if (cnt >= k) {\n                            REP(l, cnt) {\n                                clear[i][j - l - 1] = true;\n                            }\n                            cur += cnt * prev;\n                        }\n\n                        cnt = 0;\n                        prev = -1;\n                        continue;\n                    }\n\n                    if (prev != v[i][j]) {\n                        if (cnt >= k) {\n                            REP(l, cnt) {\n                                clear[i][j - l - 1] = true;\n                            }\n                            cur += cnt * prev;\n                        }\n                        cnt = 0;\n                    }\n\n                    prev = v[i][j];\n                    cnt++;\n                }\n\n                if (cnt >= k) {\n                    REP(l, cnt) clear[i][w - l - 1] = true;\n                    cur += cnt * prev;\n                }\n            }\n\n            REP(j, w) {\n                REP(i, h) {\n                    if (clear[i][j]) {\n                        REVREP(l, i) {\n                            v[l + 1][j] = v[l][j];\n                        }\n                        v[0][j] = -1;\n                    }\n                }\n            }\n\n            if (cur == 0)  break;\n            score += cur * pow(2, cnt_clear);\n            cnt_clear++;\n        }\n\n        return score;\n    };\n\n    ll ans = 0;\n    REP(i, h) REP(j, w) {\n        // clear this\n        vector<vi> v_cur = v;\n\n        REVREP(l, i) v_cur[l + 1][j] = v_cur[l][j];\n        v_cur[0][j] = -1;\n\n        ans = max(ans, get_score(v_cur));\n    }\n\n    print(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define rrep(i,n) for(int i = (n)-1; i >= 0; i--)\n#define rep1(i,n) for(int i = 1; i <= (n); i++)\n#define rrep1(i,n) for(int i = (n); i > 0; i--)\n\n#define ll long long\n#define pi pair<int, int>\n#define pll pair<ll, ll>\n\n#define MOD 1000000007\n#define INF 1000000000000000LL\n\nusing namespace std;\n\n#define MAXWH 30\n\nvector<vector<int>> b(MAXWH, vector<int>(MAXWH));\nint h,w,k;\nll result=0;\nll tmp_result=0;\n\nvoid banish_with_point(int step, int x, int y){\n  tmp_result += pow(2, step)*b[y][x];\n  b[y][x]=0;\n}\n\nll check(int step, int y){\n  for(int cw=w; cw>=k; cw--){\n    for(int cs=0; cs+cw<=w; cs++){\n      if(b[y][cs]==0)continue;\n\n      bool f=true;\n      rep(i, cw)if(b[y][cs]!=b[y][cs+i])f=false;\n\n      if(f) rep(i, cw)banish_with_point(step, cs+i, y);\n    }\n  }\n}\n\nvoid fall(){\n  rep(y, h)rep(x, w)rep(k, h-y){\n    if(b[y][x]!=0)continue;\n    for(int i=y; i<h-1; i++) swap(b[i][x], b[i+1][x]);\n  }\n}\n\nint main(){\n  cin>>h>>w>>k;\n  vector<string>o(MAXWH);\n  rrep(i, h)cin>>o[i];\n  vector<vector<int>> ob(MAXWH, vector<int>(MAXWH));\n  rep(i, h)rep(j, w)ob[i][j]=o[i][j]-'0';\n\n  rep(i, h)rep(j, w){\n    tmp_result = 0;\n    b=vector<vector<int>>(ob);\n    b[i][j]=0;\n    fall();\n    ll pre = 0;\n    rep(step, h){\n      rep(y, h)check(step, y);\n      fall();\n      if(pre==tmp_result)break;\n      pre=tmp_result;\n    }\n\n/*\nif(tmp_result > result){\ncout<<tmp_result<<'('<<i<<','<<j<<')'<<endl;\n  rrep(i, h){rep(j, w)cout<<b[i][j]<<' ';cout<<endl;}\n  cout<<endl;\n}\n*/\n\n    result = max<ll>(result, tmp_result);\n  }\n\n  cout<<result<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <cassert>\n#define SIZE 35\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nint h,w,K;\nint A[SIZE][SIZE];\nint B[SIZE][SIZE];\n\nll solve(int depth)\n{\n\tll ret=0;\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<w;)\n\t\t{\n\t\t\tif(B[i][j]==-1)\n\t\t\t{\n\t\t\t\tj++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint f=j;\n\t\t\tfor(;j<w&&B[i][j]==B[i][f];j++);\n\t\t\tif(j-f>=K)\n\t\t\t{\n\t\t\t\tfor(int k=f;k<j;k++)\n\t\t\t\t{\n\t\t\t\t\tret+=B[i][k];\n\t\t\t\t\tB[i][k]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(ret==0) return 0;\n\tret=ret*(1LL<<depth);\n\tfor(int i=0;i<w;i++)\n\t{\n\t\tint last=h-1;\n\t\tfor(int j=h-1;j>=0;j--)\n\t\t{\n\t\t\tif(B[j][i]!=-1)\n\t\t\t{\n\t\t\t\tif(last>j)\n\t\t\t\t{\n\t\t\t\t\tB[last][i]=B[j][i];\n\t\t\t\t\tB[j][i]=-1;\n\t\t\t\t\tlast--;\n\t\t\t\t}\n\t\t\t\telse last--;\n\t\t\t}\n\t\t}\n\t}\n\tret+=solve(depth+1);\n\treturn ret;\n}\nchar str[SIZE];\nint main()\n{\n\tscanf(\"%d %d %d\",&h,&w,&K);\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tscanf(\"%s\",&str);\n\t\tfor(int j=0;j<w;j++) A[i][j]=str[j]-'0';\n\t}\n\tll mx=0;\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<w;j++)\n\t\t{\n\t\t\tfor(int x=0;x<h;x++)\n\t\t\t{\n\t\t\t\tfor(int y=0;y<w;y++) B[x][y]=A[x][y];\n\t\t\t}\n\t\t\tfor(int x=i;x>=1;x--) B[x][j]=B[x-1][j];\n\t\t\tB[0][j]=-1;\n\t\t\tmx=max(mx,solve(0));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",mx);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ macro.cpp -std=c++14\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\nconst ll LINF = 1e18;\nusing namespace std;\n\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\"  ) << endl\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\"  ) << endl\n\n#define SANKOU(n,a,b) cout << ((n) ? (#a) : (#b) ) << endl\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define REPR(i,n) for(int i=n;i>=0;i--)\n\n#define FOREACH(x,a) for(auto& (x) : (a) )\n\n#define WFA(d,v) REP(k,v)REP(i,v)REP(j,v)d[i][j]=min(d[i][j],d[i][k]+d[k][j])\n\n#define SCOUT(x) cout<<(x)<<\" \"\n#define ENDL cout<<endl\n\n#define VECCIN(x) for(auto&youso_: (x) )cin>>youso_\n#define VECIN2(x,y) REP(i,x.size())cin>>x[i]>>y[i]\n#define VECCOUT(x) for(auto&youso_: (x) )cout<<youso_<<\" \";cout<<endl\n\n#define ALL(obj) (obj).begin(),(obj).end()\n\n#define EXIST(n,x) (find(ALL(n),x)!=n.end())\n#define UNIQUE(obj) sort(ALL( obj )); obj.erase(unique(ALL(obj)),obj.end())\n#define COUT(x) cout<<(x)<<endl\nvoid CINT(){}\ntemplate <class Head,class... Tail>\nvoid CINT(Head&& head,Tail&&... tail){\ncin>>head;\nCINT(move(tail)...);\n}\n#define CIN(...) int __VA_ARGS__;CINT(__VA_ARGS__)\n#define SCIN(...) string __VA_ARGS__;CINT(__VA_ARGS__)\n\n// #include <boost/multiprecision/cpp_int.hpp>\n// using namespace boost::multiprecision; // cpp_int\n\n#define P pair<int,int>\n#define V vector<int>\n#define M map<int,int>\n#define S set<int>\n#define L list<int>\n\n#define pb(a) push_back(a)\n#define mp make_pair\n\nll h,w,k;\nll Solve(vector<V> vec,int dan,int count,int point){\n    if(dan<0)return point;\n    bool wareware=true;\n    int ttttt=vec[dan][0];\n    REP(i,w)if(ttttt!=vec[dan][i])wareware=false;\n    if(!wareware)return point;\n\n    point+=(pow(2,count) * ttttt * w);\n    REPR(i,dan)REP(j,w)vec[i][j]=vec[i+1][j];\n    h--;\n    vec.erase(vec.begin()+(int)vec.size()-1);\n    return Solve(vec,dan-1,count+1,point++);\n\n\n}\n\nint main(){\n    \n    cin>>h>>w>>k;\n    swap(h,w);\n    vector<V> c(h,V(w));\n    REP(i,h){\n        SCIN(str);\n        REP(j,w){\n            c[i][j]=(int)str[j];\n        }\n    }\n\n    ll ans=0;\n    REP(i,h){\n        ans = max(ans,Solve(c,i,1,0));\n    }\n    COUT(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\n#define IINF 10e8\n#define INF 1<<30\n#define MOD 1000000007\n#define mod 1000000007\n#define rep(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define Endl endl\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define siz(x) (ll)(x).size()\n#define PI acos(-1.0)\nusing namespace std;\n//using Int=int_fast64_t;\ntypedef long long int ll;\ntypedef long long int LL;\ntypedef pair<ll,ll>Pll;\ntypedef pair<int,int>Pin;\ntemplate<class T> using V=vector<T>;\nlong long GCD(long long a, long long b) { return b ? GCD(b, a%b) : a; }\nlong long LCM(long long a, long long b)  {return a/GCD(a,b)*b;}\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\nint ddx[8]={-1,0,1,0,1,1,-1,-1};\nint ddy[8]={0,-1,0,1,1,-1,1,-1};\nchar dir[4]={'u','l','d','r'};\nll cmp(pair<ll,ll>a,pair<ll,ll> b){\n        if(a.se!=b.se)\n        return a.se<b.se;\n        else\n        return a.fi<b.fi;\n}\n//---------------------------------------------------------------------------\nll modpow(ll a, ll n) {//a^n(MOD)を求める\n    ll res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % MOD;\n        a = a * a % MOD;//次の準備\n        n >>= 1;\n    }\n    return res;\n}\n//---------------------------------------------------------------------------\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------\n    ll h,w,k;cin>>h>>w>>k;\n    ll a[30][30];\n    for(ll i=0;i<h;i++){\n        for(ll j=0;j<w;j++){\n            char c;cin>>c;\n            a[i][j]=c-'0';\n        }\n    }\n    ll ans=0;\n    for(ll i=0;i<h;i++){\n        for(ll j=0;j<w;j++){\n            ll b[30][30];\n            for(ll x=0;x<h;x++){\n                for(ll y=0;y<w;y++){\n                    b[x][y]=a[x][y];\n                }\n            }\n            b[i][j]=0;\n            queue<Pll>del;\n            del.push(mp(i,j));\n            ll cnt=0;\n            ll turn=0;\n            map<Pll,ll>m;\n            \n            //cout<<1<<endl;\n            while(!del.empty()){\n                //delete\n                while(!del.empty()){\n                Pll p=del.front();del.pop();\n                m[p]++;\n                }\n            \n            //move\n            for(ll x=0;x<w;x++){\n                for(ll y=h-1;y>=0;y--){\n                    if(m[{y,x}]){\n                        bool xyz=0;\n                        for(ll z=y-1;z>=0;z--){\n                            if(m[{z,x}]==0){\n                                b[y][x]=b[z][x];\n                                m[{z,x}]=1;\n                                xyz=1;\n                                break;\n                            }\n                        }\n                        if(xyz==0)\n                            b[y][x]=-1;\n                    }\n                }\n            }\n                \n            \n            //push\n            ll tmp=0;\n            for(ll x=0;x<h;x++){\n                for(ll y=0;y<w-k+1;y++){\n                    ll prey=y;\n                    if(b[x][y]==-1)continue;\n                    bool xyz=1;\n                    for(ll z=y+1;z<y+k;z++){\n                        if(b[x][z]!=b[x][z-1]){\n                            xyz=0;\n                            break;\n                        }\n                    }\n                    if(xyz==1){\n                        for(ll z=y;z<w;z++){\n                            if(b[x][z]==b[x][y]){\n                            del.push(mp(x,z));\n                            tmp+=b[x][z];\n                              \n                                prey=z;\n                            }\n                            else{\n                                break;\n                            }\n                        }\n                    }\n                    y=prey;\n                }\n            }\n   \n            //if(i==3&&j==2)cout<<tmp<<endl;\n            cnt+=modpow(2,turn)*tmp;\n            turn++;\n            }\n            //cout<<cnt<<endl;\n            chmax(ans,cnt);\n        }\n    }\n\n    cout<<ans<<endl;\n    //-------------------------------\n    return 0;\n}\n//---------------------------------------------------------------------------\n/*\nint n;cin>>n;\nvector<int>a(n);\nfor(int i=0;i<n;i++)\n    cin>>a[i];\n*/\n"
  },
  {
    "language": "C++",
    "code": "//カタラン数を語らん!w\n\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 2000000000000000000LL\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define seg_size 262144*2\n#define REP(a,b) for(long long a = 0;a < b;++a)\nint h, w, k;\nint grid[31][31];\nint memo[31][31];\nint cnt[31][31];\nint solve() {\n\tint ans = 0;\n\tfor (int q = 0; q < 40; ++q) {\n\t\tint addition = 0;\n\t\tint itr[31] = {};\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfor (int q = 0; q < w; ++q) {\n\t\t\t\tif (grid[i][q] != 0) {\n\t\t\t\t\tgrid[itr[q]][q] = grid[i][q];\n\t\t\t\t\titr[q]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int q = 0; q < w; ++q) {\n\t\t\tfor (int i = itr[q]; i < h; ++i) {\n\t\t\t\tgrid[i][q] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tcnt[i][0] = 1;\n\t\t\tfor (int q = 1; q < w; ++q) {\n\t\t\t\tif (grid[i][q - 1] == grid[i][q]) {\n\t\t\t\t\tcnt[i][q] = cnt[i][q - 1] + 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcnt[i][q] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int q = w - 2; q >= 0; --q) {\n\t\t\t\tif (grid[i][q] == grid[i][q + 1]) {\n\t\t\t\t\tcnt[i][q] = cnt[i][q + 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tif (cnt[i][j] >= k) {\n\t\t\t\t\tans += (1 << q) * grid[i][j];\n\t\t\t\t\taddition += (1 << q) * grid[i][j];\n\t\t\t\t\tgrid[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (addition == 0) break;\n\t}\n\treturn ans;\n}\nint main() {\n\tcin >> h >> w >> k;\n\tREP(i, h) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(q, w) {\n\t\t\tmemo[h - i - 1][q] = s[q] - '0';\n\t\t}\n\t}\n\tint ans = 0;\n\tREP(i, h) {\n\t\tREP(q, w) {\n\t\t\tREP(j, h) {\n\t\t\t\tREP(t, w) {\n\t\t\t\t\tgrid[j][t] = memo[j][t];\n\t\t\t\t}\n\t\t\t}\n\t\t\tgrid[i][q] = 0;\n\t\t\tans = max(ans, solve());\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing vc = vector<char>;\nusing vvc = vector<vc>;\nusing pll = pair<ll, ll>;\nusing stkll = vector<pll>;\nconst ll INF = 1LL << 60;\nconst ll MOD = 1e9 + 7;\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define debug(x) cerr << #x << \": \" << x << endl;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\nint main() {\n    ll H, W, K;\n    cin >> H >> W >> K;\n    vvc org(H+1, vc(W, '0'));\n    rep(i, H) rep(j, W) cin >> org[H-1-i][j];\n\n    ll ans = 0;\n    rep(py, H) rep(px, W) {\n        if(py == 0 && px == 2) {\n            ;\n        }\n\n        vvc in(H+1, vc(W, '0'));\n        rep(i, H) rep(j, W) in[i][j] = org[i][j];\n\n        for(ll y = py; y < H; y++) in[y][px] = in[y+1][px];\n\n        ll ret = 0, num = 0;\n        bool end = false;\n        while(!end) {\n            vvb used(H+1, vb(W, false));\n            end = true;\n            ll sumin = 0;\n\n            rep(i, H) {\n                ll left = 0, right = 0, cnt = 1;\n                for(ll j = 1; j <= W; j++) {\n                    if(in[i][j-1] == in[i][j] && in[i][j] != '0') {\n                        cnt++;\n                        right = j;\n                        if(j == W && cnt >= K) {\n                            sumin += cnt * (in[i][j] - '0');\n                            for(ll k = left; k <= right; k++) used[i][k] = true;\n                            end = false;\n                        }\n                    }\n                    else {\n                        if(cnt >= K) {\n                            sumin += cnt * (in[i][j-1] - '0');\n                            for(ll k = left; k <= right; k++) used[i][k] = true;\n                            end = false;\n                        }\n                        left = right = j;\n                        cnt = 1;\n                    }\n                }\n            }\n            ret += (1<<num) * sumin;\n            num++;\n\n            rep(j, W) {\n                rep(i, H) {\n                    ll k = i;\n                    while(used[k][j]) k++;\n                    in[i][j] = in[k][j];\n                    if(in[k][j] != '0') used[k][j] = true;\n                }\n            }\n        }\n        chmax(ans, ret);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n    Problem 93\n    https://atcoder.jp/contests/s8pc-3/tasks/s8pc_3_b\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n/* typedef */\ntypedef long long ll;\ntypedef pair<int, int> pii;\n/* class */\nclass pazzle {\n    public:\n    int H, W, K;\n    ll ans = 0;\n    vector<vector<int> > v;\n    pazzle (int H, int W, int K, vector<vector<int> > v)\n    : H(H), W(W), K(K), v(v) {}\n    bool del() {\n        int ret = false;\n        for (int i = 0; i < H; i++) {\n            int r = 0;\n            for (int l = 0; l < W; l++) {\n                int tmp = v[i][r];\n                while (v[i][r] == -1) {\n                    r++;\n                    l++;\n                }\n                while (v[i][r] == v[i][r + 1]){\n                    r++;\n                    tmp += v[i][r];\n                }\n                if (r - l + 1>= K) {\n                    for (int k = l; k <= r; k++) v[i][k] = -1;\n                    ans += tmp;\n                    ret = true;\n                }\n                l = r;\n                r++;\n            }\n        }\n        return ret;\n    }\n    void move() {\n        for (int i = 0; i < W; i++) {\n            for (int j = H - 1; j > 0; j--) {\n                if (v[j][i] == -1) {\n                    int k = j - 1;\n                    while (v[k][i] == -1 && k > 0) k--;\n                    if (v[k][i] != -1) swap(v[k][i], v[j][i]);\n                }\n            }\n        }\n    }\n    void printPoint() {\n        cout << ans << '\\n';\n    }\n    ll gameStart() {\n        ll ret = 0;\n        move();\n        for (int i = 0; del(); i++){\n            move();\n            ret += pow(2, i) * ans;\n            ans = 0;\n        }\n        return ret;\n    }\n};\n/* constant */\n/* global variables */\n/* function */\n/* main */\nint main(){\n    int H, W, K;\n    cin >> H >> W >> K;\n    vector<string> vs(H);\n    for (int i = 0; i < H; i++) cin >> vs[i];\n    vector<vector<int> > v(H, vector<int> (W + 1, -2));\n    for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) v[i][j] = vs[i][j] - '0';\n    if (K == 1) {\n        int ans = 0;\n        int minValue = INF;\n        for (auto vi : v) {\n            ans += accumulate(vi.begin(), vi.end(), 0);\n            minValue = min(*min_element(vi.begin(), vi.end()), minValue);\n        }\n        cout << ans  - minValue << '\\n';\n        return 0;\n    }\n    ll ans = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int tmp = v[i][j];\n            v[i][j] = -1;\n            pazzle P = pazzle(H, W, K, v);\n            ans = max(ans, P.gameStart());\n            v[i][j] = tmp;\n        }\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i=0; i < (int)(n); i++)\nusing ull = unsigned long long;\nusing ll = long long;\n\nint H, W, K;\nint C[31][31]={}, D[31][31]={};\n\nvoid drop() {\n    rep(w, W) {\n        for (int h=H-1; h>=0; h--) {\n            if (D[h][w] == 0) {\n                for (int h2=h; h2>=0; h2--) {\n                    if (D[h2][w] != 0) {\n                        D[h][w] = D[h2][w];\n                        D[h2][w] = 0;\n                        h = h2+1;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    // rep(h, H) {\n    //     rep(w, W) cout << D[h][w];\n    //     cout << endl;\n    // }\n    // cout << endl;\n}\n\nll cal_score(int hi, int wi) {\n    ll score = 0, bouns=1;\n    D[hi][wi] = 0;\n\n    // cout << \" ---\" << a << \" ---\" << endl;\n\n    while (true) {\n        ll prev_score = score;\n\n        drop();\n        rep(h, H) {\n            int same_num_cnt = 1;\n            for (int w=0; w<W; w++) {\n                if (D[h][w+1] == D[h][w] && D[h][w] != 0) same_num_cnt++;\n                if (D[h][w+1] != D[h][w]) {\n                    if (same_num_cnt >= K) {\n                        score += D[h][w] * same_num_cnt * bouns;\n                        // cout << \" \" << D[h][w] << \" \" << score << endl;\n                        for (int w2=w; w2>w-same_num_cnt; w2--) D[h][w2] = 0;\n                    }\n                    same_num_cnt = 1;\n                }\n            }\n        }\n\n        // cout << \"i:\" << a << \", :score\" << score << endl;\n        bouns *= 2;\n        if (prev_score == score) break;\n    }\n    return score;\n}\n\nint main() {\n    cin >> H >> W >> K;\n    string sh;\n    rep(h, H) {\n        cin >> sh;\n        rep(w, W) C[h][w] = sh[w] - '0';\n    }\n\n    ll ans = 0;\n    rep(hi, H) {\n        rep(wi, W) {\n        rep(h, H) rep(w, W) D[h][w] = C[h][w];\n        ans = max(ans, cal_score(hi, wi));\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nll MOD = 1000000007;\n\n#define vec              vector<int>\n#define vecll            vector<ll>\n#define vecd             vector<double>\n#define vecst            vector<string>\n#define vecb             vector<bool>\n#define v2(v,n,m,init)   vector<vector<int>>  v(n, vector<int>(m, init))\n#define vb2(v,n,m,init)  vector<vector<bool>> v(n, vector<bool>(m, init))\n#define vll2(v,n,m,init) vector<vector<ll>>   v(n, vector<ll>(m, init))\n\n#define rep(i,n)         for(ll i=(ll)0; i<(ll)n; i++)\n#define REP(i,m,n)       for(ll i=(ll)m; i<(ll)n; i++)\n#define arr(var, n)      vec var(n); rep(i,n){cin >> var[i];}\n#define arrll(var, n)    vecll var(n); rep(i,n){cin >> var[i];}\n#define arrst(var, n)    vecst var(n); rep(i,n){cin >> var[i];}\n#define all(var)         (var).begin(), (var).end()\n#define sortall(var)     sort(all(var))\n#define uniqueall(v)     v.erase(unique(v.begin(), v.end()), v.end());\n#define pb(var)          push_back(var)\n#define prt(var)         cout << (var) << \"\\n\"\n#define prtd(n, var)     cout << fixed << setprecision(n) << (var) << \"\\n\"\n#define prtfill(n, var)  cout << setw(n) << setfill('0') << (var);\n#define prt2(v1, v2)     cout << (v1) << \" \" << (v2) << \"\\n\"\n#define prt3(v1, v2, v3) cout << (v1) << \" \" << (v2) << \" \" << (v3) << \"\\n\"\n#define prtall(v)        rep(i,v.size()){cout<<v[i]<<(i!=v.size()-1?\" \":\"\\n\");}\ntemplate <typename T>\nbool chmax(T &a, const T& b){if(a<b){a=b; return true;} return false;}\ntemplate <typename T>\nbool chmin(T &a, const T& b){if(a>b){a=b; return true;} return false;}\n//------------------------------------------------------------------\n\nvector<string> drop(vector<string> s){\n  vector<string> r;\n  int h = s.size();\n  int w = s[0].size();\n  rep(i,h){\n    string tmp=\"\";\n    rep(j,w){\n      tmp.push_back('0');\n    }\n    r.push_back(tmp);\n  }\n  rep(i,w){\n    int id=h-1;\n    for(int j=h-1; j>-1; j--){\n      if(s[j][i]!='0'){\n        r[id][i]=s[j][i];\n        id--;\n      }\n    }\n  }\n  return r;\n}\n\nint main(void){\n  int h, w, k;\n  cin >> h >> w >> k;\n  arrst(s,h);\n\n  int ans=0;\n  rep(delh,h){\n    rep(delw,w){\n      int anstmp=0;\n      vector<string> t = s;\n      t[delh][delw] = '0';\n      t = drop(t);\n      int p=1;\n      //prt(\"-----------------------\");\n      rep(x,h*w/k+3){\n        if(x!=0) p*=2;\n        int add=0;\n        /*\n        prt2(\"from =====>\", x);\n\n        rep(p,h){\n          rep(q,w){\n            cout << t[p][q] << (q!=w-1 ? \" \" : \"\\n\");\n          }\n        }\n        */\n\n        rep(a,h){\n          rep(b,w){\n            int tmp = t[a][b];\n            int c=b;\n            int ct=0;\n            while(c<w){\n              if(t[a][c]==tmp) ct++, c++;\n              else break;\n            }\n            if(ct>=k){\n              rep(i,ct){\n                add += t[a][b+i]-'0';\n                t[a][b+i]='0';\n              }\n            }\n          }\n        }\n        /*\n        prt2(\"to =====>\", x);\n        rep(p,h){\n          rep(q,w){\n            cout << t[p][q] << (q!=w-1 ? \" \" : \"\\n\");\n          }\n        }\n        */\n\n        anstmp += add*p;\n        //prt3(\"score :\", anstmp, add*p);\n        t = drop(t);\n      }\n      chmax(ans, anstmp);\n    }\n  }\n\n\n  prt(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n\nint H, W, K;\n\nvoid fall(vector<vector<ll>> &c) {\n    rep(i,W) rep(j,H) {\n        if (c[i][j] == 0) {\n            for (int k = 1; k + j < H; ++k) {\n                if (c[i][k+j] != 0) {\n                    for (int l = j; l < H; ++l) {\n                        if (l + k < H) c[i][l] = c[i][l+k];\n                        else c[i][l] = 0;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n}\n\nvoid sum(ll &ans, ll delete_cnt, vector<vector<ll>> &c) {\n    rep(i,H) {\n        ll left = 0;\n        rep(j,W) {\n            if (c[j+1][i] != 0 && c[j+1][i] == c[j][i]) continue;\n            if (c[j+1][i] != c[j][i]) {\n                if (j - left + 1 >= K) {\n                    ans += (1LL<<delete_cnt) * (j - left + 1) * c[j][i];\n                    for (int k = left; k <= j; ++k) c[k][i] = 0;\n                }\n            }\n            left = j + 1;\n        }\n    }\n}\n\n\n\nll calc_ans(int x, int y, vector<vector<ll>> c) {\n    ll res = 0;\n    ll pre_ans = -1;\n    ll delete_cnt = 0;\n\n    c[x][y] = 0;\n    fall(c);\n    while (res != pre_ans) {\n        pre_ans = res;\n        sum(res, delete_cnt, c);\n        fall(c);\n        ++delete_cnt;\n    }\n    return res;\n}\n\n\nint main() {\n    cin >> H >> W >> K;\n    vector<vector<ll>> c(W+1, vector<ll>(H));\n    rep(i,H) {\n        string S;\n        cin >> S;\n        rep(j,W) c[j][H-1-i] = S[j] - '0';\n    }\n\n    ll ans = 0;\n\n    rep(i,W) rep(j,H) {\n        if (i == 0) continue;\n        ans = max(ans, calc_ans(i, j, c));\n    }\n    \n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair< ll, ll > Pi;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep2(i,n) for(int i=1;i<=(n);i++)\n#define rep3(i,i0,n) for(int i=i0;i<(n);i++)\n#define pb push_back\n#define mod 1000000007\nconst ll INF = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nll gcd(ll a, ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b) {return a/gcd(a,b)*b;}\n#define all(x) x.begin(), x.end()\n#define mp make_pair\nbool compare(Pi a, Pi b) {\n    if(a.first != b.first){\n        return a.first < b.first;\n        \n    }else{\n        return a.second < b.second;\n    }\n}\n\nint ctoi(char c) {\n\tif (c >= '0' && c <= '9') {\n\t\treturn c - '0';\n\t}\n\treturn 0;\n}\nbool In_map(ll y,ll x,ll h,ll w){\n    if(y<0 || x<0 || y>=h || x>=w){\n        return 0;\n    }else{\n        return 1;\n    }\n}\nconst vector<ll> dx{1,0,-1,0};\nconst vector<ll> dy{0,1,0,-1};\n\n\n\nint main() {\n\n    ll H,W,K;\n    cin >>H>>W>>K;\n    vector<string> S(H+1);\n    rep(i,H) cin >>S[i];\n    vector<vector<ll>> R(H+1,vector<ll>(W+1));\n    vector<vector<ll>> R2(H+1,vector<ll>(W+1));\n    rep(i,H) rep(j,W) R[i][j] = ctoi(S[i][j]);\n    R2 = R;\n    if(K<=1){\n        ll ans = 0;\n        ll min = INF;\n        rep(i,H){\n            rep(j,W){\n                chmin(min,R[i][j]);\n                ans+=R[i][j];\n            }\n        }\n        cout << ans-min<<endl;\n        return 0;\n    }\n\n\n    ll fans = 0;\n    rep(h,H) rep(w,H){\n    ll ans = 0;\n    R=R2;\n    R[h][w] = -1;\n    ll flag = 0;\n    rep(m,H){\n        ll p2 =pow(2,m); \n        /*rep(j,W){\n            vector<ll> tmp;\n            rep(i,H){\n                if(R[H-1-i][j] != -1){\n                    tmp.pb(R[H-1-i][j]);\n                }\n            }\n            rep(i,H){\n                if(i<tmp.size()){\n                    R[H-1-i][j] = tmp[i];\n                }else{\n                    R[H-1-i][j] = -1;\n                }\n            }\n        }*/\n        /*rep(i,H){\n            ll cnt=0;\n            ll p=-1;\n            rep(j,W){\n                if(R[i][j] == p && R[i][j] != -1){\n                    cnt++;\n                    if(j==W-1){\n                        if(cnt>=K){\n                            flag = 1;\n                            //ans += R[i][j-1]*cnt*p2;\n                            rep(k,cnt){\n                               // R[i][j-k] = -1;\n                            }\n                        }\n                    }\n                }else{\n                    if(cnt>=K){\n                        flag = 1;\n                        //ans += R[i][j-1]*cnt*p2;\n                        rep(k,cnt){\n                            //R[i][j-k-1] = -1;\n                        }\n                    }\n                    cnt = 1;\n                }\n                \n\n                p = R[i][j];\n            }\n        \n        \n        }*/\n\n        if(flag ==0) break;\n    }\n\n\n        chmax(fans,ans);\n    }\n\n    cout << fans<<endl;\n    \n    return 0;\n    \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\n\tint h, w ,k1,p{10}, mcnt{}; cin >> h >> w >> k1;\n\tvector<vector<int>> fld(2*h,vector<int>(w));\n\tfor(int i=h-1; i>=0; i--) {\n\t\tstring s; cin >> s;\n\t\tfor(int j=0; j<w; j++) fld.at(i).at(j) = s.at(j)-'0';\n\t}\n\tfor(int i=h; i<2*h; i++) for(int j=0; j<w; j++) fld.at(i).at(j) = p++;\n\tfor(int e=0; e<h; e++){\n\t\tfor(int f=0; f<w; f++){\n\t\t\tvector<vector<int>> a1(h,vector<int>(w));\n\t\t\tfor(int i=0; i<h; i++) for(int j=0; j<w; j++) a1.at(i).at(j) = i;\n\t\t\tfor(int k=e; k<h; k++) a1.at(k).at(f)++;\n\t\t\tint cnt{}, pt{1};\n\t\t\tbool flg{1};\n\t\t\twhile(flg){\n\t\t\t\tauto a = a1;\n\t\t\t\tflg=0;\n\t\t\t\tfor(int i=h-1; i>=0; i--){\n\t\t\t\t\tvector<int> g(w);\n\t\t\t\t\tfor(int g1=0; g1<w; g1++) g.at(g1) = fld.at(a.at(i).at(g1)).at(g1);\n\t\t\t\t\tfor(int sl=0; sl+k1-1<w;){\n\t\t\t\t\t\tint sr{sl+1};\n\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\tif(sr==w||g.at(sl)!=g.at(sr)) break;\n\t\t\t\t\t\t\tif(g.at(sl)==g.at(sr)) sr++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsr--;\n\t\t\t\t\t\tif(sr-sl+1>=k1){\n\t\t\t\t\t\t\tflg=1;\n\t\t\t\t\t\t\tcnt += pt * g.at(sl) * (sr-sl+1);\n\t\t\t\t\t\t\tfor(int k=i; k<h; k++) for(int l=sl; l<=sr; l++) {\n\t\t\t\t\t\t\t\tif(k==h-1)a1.at(k).at(l)++;\n\t\t\t\t\t\t\t\telse a1.at(k).at(l) = a1.at(k+1).at(l);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsl = sr + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpt<<=1;\n\t\t\t}\n\t\t\tmcnt = max(cnt,mcnt);\n\t\t}\n\t}\n\tcout << mcnt << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <list>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <tuple>\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define rep1(i, n) for (int i = 1; i <= (n); i++)\n#define show(a, n) rep(i,n) {cout<<a[i]<<' ';} cout<<endl\n#define show2(a, n, m) rep(i, n) { rep(j, m) {cout << a[i][j] << ' ';} cout << endl;} \n#define chmin(a, b) a = min(a, b)\n#define chmax(a, b) a = max(a, b)\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef pair<long long, long long> pll;\ntypedef long double ld;\n\nconst int INF = 1 << 30;\nconst long long INFL = 1LL << 60;\nconst int MOD = 1000000007;\nconst int MAX = 100000;\nconst int N = 100010;\n\nint h, w, k;\nll b;\n\nll add_score(vector<vi>& c) {\n\tll ret = 0;\n\trep(i, h) {\n\t\tint last = 0;\n\t\tint st = 0;\n\t\trep(j, w) {\n\t\t\tif(c[i][j] == last) continue;\n\t\t\tif(j - st >= k) {\n\t\t\t\tret += b * last * (j - st);\n\t\t\t\tfor(int j2 = st; j2 <= j-1; j2++) c[i][j2] = 0;\n\t\t\t}\n\t\t\tlast = c[i][j];\n\t\t\tst = j;\n\t\t}\n\t\tif(w - st >= k) {\n\t\t\tret += b * last * (w - st);\n\t\t\tfor(int j2 = st; j2 <= w-1; j2++) c[i][j2] = 0;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid update(vector<vi>& c) {\n\trep(j, w) {\n\t\tint i2 = h-1;\n\t\tfor(int i = h-1; i >= 0; i--) {\n\t\t\tif(c[i][j] != 0) {\n\t\t\t\tswap(c[i][j], c[i2][j]);\n\t\t\t\ti2--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nll score(int i, int j, vector<vi> c) {\n\tc[i][j] = 0;\n\tupdate(c);\n\tll ret = 0;\n\tb = 1;\n\twhile(true) {\n\t\tll add = add_score(c);\n\t\tif(add == 0) break;\n\t\tret += add;\n\t\tupdate(c);\n\t\tb *= 2;\n\t}\n\treturn ret;\n}\n\nint main() {\n//\tcout << fixed << setprecision(15);\n\tcin >> h >> w >> k;\n\tvector<vi> c(h, vi(w));\n\trep(i, h) {\n\t\tstring s;\n\t\tcin >> s;\n\t\trep(j, w) c[i][j] = s[j] - '0';\n\t}\n\tll ans = 0;\n\trep(i, h) rep(j, w) chmax(ans, score(i, j, c));\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\nint ctoi(char c) {\n\tif (c >= '0' && c <= '9') {\n\t\treturn c - '0';\n\t}\n\treturn 0;\n}\n\nint main(){\n\n  int h,w,k;\n  cin >> h>> w >> k;\n\n  \n  int a[h][w];\n  \n  vector<string> q(h);\n  for(int i=0;i<h;i++)cin >> q[i];\n\n  //scoreの最大値\n  long long int m=0;\n  int p=0;\n  for(int u=0;u<h;u++){\n    for(int v=0;v<w;v++){\n      //入力\n      for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++)a[i][j]=ctoi(q[i][j]);\n      }\n      //(u,v)を消す\n      a[u][v]=0;\n\n      //v列目の必要な個所を落とす\n      int z=0;\n      for(int j=h-1;j>=0;j--){\n        if(a[j][v]==0)z++;\n        else if(z!=0){\n          a[j+z][v]=a[j][v];\n          a[j][v]=0;\n        }\n      }\n\n      long long int score=0;\n\n      long long int c=1;\n      long long int d=0; \n\n      while(c!=0){\n        c=0;\n        for(int i=0;i<h;i++){\n          //左からn個目からn+l-1個目までのl個消える\n          for(int n=0;n<=w-k;n++){\n            if(a[i][n]==0)continue;  //左からn個目が0なら消えるわけがない\n            for(int l=w-n;l>=k;l--){\n              //左からn個目からl個を見て、ちゃんと全部が左からn個目と同じかを見る\n              int b=0;\n              for(int m=0;m<l;m++){\n                if(a[i][n+m]==a[i][n])b++;\n              }\n              if(b==l){\n                c+=l*a[i][n];\n                for(int m=0;m<l;m++){\n                  a[i][n+m]=0;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        score += c*pow(2,d);\n        d++;\n        for(int i=0;i<w;i++){\n          int z=0;\n          for(int j=h-1;j>=0;j--){\n            if(a[j][i]==0)z++;\n            else if(z!=0){\n              a[j+z][i]=a[j][i];\n                a[j][i]=0;\n            }\n          }\n        }\n\n      }\n      m=max(m,score);\n\n    }\n  }\n\n  cout << m << endl;\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;using pll = pair<ll, ll>;using pdd = pair<double, double>;using pss = pair<string, string>;using pbb = pair<bool, bool>;\nusing ti3 = tuple<int, int, int>;using tl3 = tuple<ll, ll, ll>;using td3 = tuple<double, double, double>;using ts3 = tuple<string, string, string>;using tb3 = tuple<bool, bool, bool>;\nusing ti4 = tuple<int, int, int, int>;using tl4 = tuple<ll, ll, ll, ll>;using td4 = tuple<double, double, double, double>;using ts4 = tuple<string, string, string, string>;using tb4 = tuple<bool, bool, bool, bool>;\nusing vi = vector<int>;using vl = vector<ll>;using vd = vector<double>;using vs = vector<string>;using vb = vector<bool>;\nusing vvi = vector<vi>;using vvl = vector<vl>;using vvd = vector<vd>;using vvs = vector<vs>;using vvb = vector<vb>;\nusing v3i = vector<vvi>;using v3l = vector<vvl>;using v3d = vector<vvd>;using v3s = vector<vvs>;using v3b = vector<vvb>;\nusing vpii = vector<pii>;using vpll = vector<pll>;using vpdd = vector<pdd>;using vpss = vector<pss>;using vpbb = vector<pbb>;\nusing vti3 = vector<ti3>;using vtl3 = vector<tl3>;using vtd3 = vector<td3>;using vts3 = vector<ts3>;using vtb3 = vector<tb3>;\nusing mii = map<int, int>;using mll = map<ll, ll>;using mci = map<char, int>;using msi = map<string, int>;\nusing si = set<int>;using sl = set<ll>;using sd = set<double>;using ss = set<string>;using sb = set<bool>;\nusing spii = set<pii>;using spll = set<pll>;using spdd = set<pdd>;using spss = set<pss>;using spbb = set<pbb>;\nusing sti3 = set<ti3>;using stl3 = set<tl3>;using std3 = set<td3>;using sts3 = set<ts3>;using stb3 = set<tb3>;\n#define rep0(TIMES) for (int CNT = 0; CNT < (int)(TIMES); CNT++)\n#define rep(CNT, GOAL) for (int CNT = 0; CNT < (int)(GOAL); CNT++)\n#define rep2(CNT, START, GOAL) for (ll CNT = (ll)(START); CNT < (ll)(GOAL); CNT++)\n#define rep3(CNT, START, GOAL) for (ll CNT = (ll)(START); CNT > (ll)(GOAL); CNT--)\n#define all(CONT) begin(CONT), end(CONT)\n#define fr1(CONT) next(begin(CONT)), end(CONT)\n#define itrep(ITR, CONT) for (auto ITR = begin(CONT); ITR != end(CONT); ITR++)\n#define itrep1(ITR, CONT) for (auto ITR = next(begin(CONT)); ITR != end(CONT); ITR++)\n#define maxel(CONT) *max_element(all(CONT))\n#define minel(CONT) *min_element(all(CONT))\ntemplate <typename T> bool chmax(T &a, const T &b) { if (a < b) {\ta = b; return true;\t}\treturn false; }\ntemplate <typename T> bool chmin(T &a, const T &b) { if (a > b) {\ta = b; return true;\t}\treturn false; }\ntemplate <typename T> T sum(const vector<T> &VEC) { return accumulate(all(VEC), 0.0); }\ntemplate <typename T> vector<T> acm(const vector<T> &VEC) { vector<T> RES(VEC.size() + 1); rep(CNT, VEC.size()) RES[CNT + 1] = RES[CNT] + VEC[CNT];\treturn RES; }\ntemplate <typename T> void fil(vector<T> &VEC, const int NUM, const T &VAL) { VEC.assign(NUM, VAL); }\ntemplate <typename T> void fil(vector<T> &VEC, const int NUM) { VEC.assign(NUM, 0.0); }\ntemplate <typename T> void fil(vector<vector<T>> &VV, const int RNUM, const int CNUM, const T &VAL) { fil(VV, RNUM, vector<T>()); rep(CNT, RNUM) fil(VV[CNT], CNUM, VAL); }\ntemplate <typename T> void fil(vector<vector<T>> &VV, const int RNUM, const int CNUM) { fil(VV, RNUM, vector<T>()); rep(CNT, RNUM) fil(VV[CNT], CNUM); }\ntemplate <typename T> void fil(vector<vector<T>> &VV, const int RNUM) { fil(VV, RNUM, vector<T>()); }\nvoid prec(const int &DIG) { cerr << fixed << setprecision(DIG); cout << fixed << setprecision(DIG); }\ntemplate <typename T> void COUT(const T &ELEM) { cout << ELEM; }\ntemplate <typename T> void pout(const T &ELEM) { COUT(ELEM); cout << \" \"; }\ntemplate <typename T, typename ...Ts> void pout(const T &FIRST, const Ts &...REST) { pout(FIRST); pout(REST...); }\ntemplate <typename T> void print(T ELEM) { COUT(ELEM); cout << \"\\n\"; }\ntemplate <typename T, typename ...Ts> void print(const T &FIRST, const Ts &...REST) { print(FIRST); print(REST...); }\nvoid CERR() { cerr << \"\\n\"; }\ntemplate <typename T> void CERR(const T &ELEM) { cerr << ELEM; }\ntemplate <typename T, typename ...Ts> void CERR(const T &FIRST, const Ts &...REST) { CERR(FIRST); cerr << \", \"; CERR(REST...); }\ntemplate <typename T1, typename T2> void CERR(const pair<T1, T2> &PAIR) { cerr << \"(\"; CERR(PAIR.first); cerr << \", \"; CERR(PAIR.second); cerr << \")\"; }\ntemplate <typename T1, typename T2, typename T3> void CERR(const tuple<T1, T2, T3> &TUP3) { cerr << \"(\"; CERR(get<0>(TUP3)); cerr << \", \"; CERR(get<1>(TUP3)); cerr << \", \"; CERR(get<2>(TUP3)); cerr << \")\"; }\ntemplate <typename T1, typename T2, typename T3, typename T4> void CERR(const tuple<T1, T2, T3, T4> &TUP4) { cerr << \"(\"; CERR(get<0>(TUP4)); cerr << \", \"; CERR(get<1>(TUP4)); cerr << \", \"; CERR(get<2>(TUP4)); cerr << \", \"; CERR(get<3>(TUP4)); cerr << \")\"; }\ntemplate <typename T> void CERR(const vector<T> &VEC) { cerr << \"{ \"; itrep(ITR, VEC) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\ntemplate <typename T> void CERR1(const vector<T> &VEC) { cerr << \"{ \"; itrep1(ITR, VEC) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\ntemplate <typename T> void CERR(const set<T> &SET) { cerr << \"{ \"; itrep(ITR, SET) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\ntemplate <typename T1, typename T2> void CERR(const map<T1, T2> &MAP) { cerr << \"{ \"; itrep(ITR, MAP) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\n#define db(OBJ) cerr << #OBJ << \": \"; CERR(OBJ); cerr << \", \"\n#define dbl(OBJ) cerr << #OBJ << \": \"; CERR(OBJ); cerr << \"\\n\"\n#define db1(OBJ) cerr << #OBJ << \": \"; CERR1(OBJ); cerr << \"\\n\"\n#define dbs(...) cerr << \"(\" << #__VA_ARGS__ << \"): (\"; CERR(__VA_ARGS__); cerr << \")\\n\"\n#define dbvv(VV) cerr << #VV << \": {\\n\"; rep(CNT, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define db01(VV) cerr << #VV << \": {\\n\"; rep(CNT, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR1(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define db10(VV) cerr << #VV << \": {\\n\"; rep2(CNT, 1, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define db11(VV) cerr << #VV << \": {\\n\"; rep2(CNT, 1, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR1(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define YN(f) cout << (f ? \"YES\" : \"NO\") << \"\\n\"\n#define Yn(f) cout << (f ? \"Yes\" : \"No\") << \"\\n\"\n#define yn(f) cout << (f ? \"yes\" : \"no\") << \"\\n\"\n#define pcase(NUM) cout << \"Case #\" << NUM << \":\" << \" \"\n#define pcasel(NUM) cout << \"Case #\" << NUM << \":\" << \"\\n\"\nconst ll INF = 1e12 + 7;\n// db\n\n// 石の配置を，列ごとに配列で表し(下にある石の数字が配列の前方に並ぶ)，\n// これらの配列を2次元配列Aにまとめる。\n// A[i][j]は，左からi番目の列の，下からj番目の石の数字を表す。\n\n// 全体に共通するもの\nint H, W, K;\nvector<vector<char>> c; // 入力を90°回転させてから受け取る\nvvi A;\nint ans = 0;\n\nint erase(vvi &A, int j, int i, int t) {\n\tsi s; // A[i][j]~A[i+t-1][j]の石に書いてある数字のset\n\trep2(x, i, i + t) {\n\t\tif (A[x].size() <= j) return 0; // その高さにはもう石がない場合は，この(i,t)に対する処理をやめる\n\t\ts.insert(A[x][j]);\n\t}\n\tif (s.size() > 1) return 0; // 上記区間の全てに石が残ってはいるが，数字の種類が2種類以上である(全て同じではない)場合\n\telse { // 全て同じである場合\n\t\trep2(x, i, i + t) A[x].erase(begin(A[x]) + j); // 石を消す\n\t\t// dbs(i, j, t); dbl(*begin(s) * t);\n\t\treturn *begin(s) * t; // 「石の数字×消えた石の個数」を返す\n\t}\n}\n\nint check(vvi &A, int j) { // 下からj行目に対する処理\n\tint check_res = 0;\n\t// t:W~K,i:0~W-tとして，A[i][j]~A[i+t-1][j]のt個の石が消えるかを確認する。\n\t// 【AOJ1193との重大な相違】1つの行で複数の群の石が消えることがある。なので，一度石が消えた段階でこの行(A[0][j]~A[W-1][j])の処理を終えてはならない。\n\trep3(t, W, K - 1) {\n\t\trep(i, W + 1 - t) {\n\t\t\tcheck_res = erase(A, j, i, t);\n\t\t\tif (check_res) break;\n\t\t}\n\t\tif (check_res) break; // ※一度石が消えた段階で二重ループを脱し，この行の処理を中断するとした場合の実装\n\t}\n\treturn check_res;\n}\n\nint fall(vvi &A) { // Aは参照渡しとする\n\tint fall_res = 0;\n\trep3(j, H - 1, -1) fall_res += check(A, j); // 下からj行目を検査し，消えた石の数字の合計を返り値に加える\n\treturn fall_res;\n}\n\nint solve(int i, int j, vvi A) { // Aは値渡しとする\n\tA[i].erase(begin(A[i]) + j);\n\t// dbs(i, j); dbvv(A);\n\tint solve_res = 0, powcnt = 1; // この試行の合計得点と，連鎖数による倍率\n\twhile (true) {\t\t\n\t\tint fall_res = fall(A); // 現在の状態で消える石の数字の合計\n\t\t// dbl(powcnt); dbvv(A); dbl(fall_res);\n\t\tif (fall_res > 0) { // 上記合計が正なら\n\t\t\tsolve_res += fall_res * powcnt; // 倍率を乗じて得点に加える\n\t\t\tpowcnt *= 2;\n\t\t} else break;\n\t}\n\t// dbl(solve_res);\n\treturn solve_res;\n}\n\nint main() {\n\tcin >> H >> W >> K;\n\tfil(c, W, H); fil(A, W, H);\n\trep3(j, H - 1, -1) rep(i, W) {\n\t\tcin >> c[i][j];\n\t\tA[i][j] = c[i][j] - '0';\n\t}\n\t// dbvv(c);\t\n\trep(i, W) rep(j, H) {\t\t\n\t\tchmax(ans, solve(i, j, A)); // 押す/消す石を決め，simulation\n\t}\n\tprint(ans);\t\n}\n\n/*\n// AOJ1193\n\nconst int W = 5, num = 3;\nint H, ans;\nvvi A;\n\nbool erase(int j, int i, int k) {\n\t// 下からj行目の，左からi列目からk列を消せるか\n\t// (A[i][j]~A[i+k-1][j])\n\tsi s;\n\trep2(x, i, i + k) {\n\t\tif (A[x].size() <= j) return false;\n\t\ts.insert(A[x][j]);\n\t}\n\tif (s.size() > 1) return false;\n\telse {\n\t\tans += *begin(s) * k;\n\t\trep2(x, i, i + k) A[x].erase(begin(A[x]) + j); // 左からi列目を表す配列中の，下からj行目の要素のイテレータ\n\t\t// dbvv(A); dbl(ans);\n\t\treturn true;\n\t}\n}\n\nbool check(int j) {\n\t// 消せる数kの大きい方からj行目を検査し，消せた段階でこの行の処理を終える\n\t// (k,i):(5,0),(4,0)~(4,1),(3,0)~(3,2)\n\trep3(k, W, num - 1) rep(i, W + 1 - k) {\n\t\tif (erase(j, i, k)) return true;\n\t}\n\treturn false;\n}\n\nbool fall() {\n\tbool fall_res = false;\n\trep3(j, H - 1, -1) if (check(j)) fall_res = true; // 下からH-1行目から0行目に向けて走査，チェック\n\treturn fall_res;\n}\n\nvoid solve() {\n\tfil(A, W, H);\n\trep3(j, H - 1, -1) rep(i, W) cin >> A[i][j];\t\n\tans = 0;\n\t// dbvv(A); dbl(ans);\n\twhile (fall());\n\tprint(ans);\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000\nusing namespace std;\n\nint H, W, K;\nint check_point(vector<vector<int>> board, pair<int, int> hw)\n{\n  int ans = 0;\n  board.at(hw.second - 1).erase(board.at(hw.second - 1).begin() + H - hw.first);\n  // int loop_cnt = -1;\n  // while (true)\n  // {\n  //   loop_cnt += 1;\n  //   bool didnt_change = true;\n  //   int cnt;\n  //   for (int i = H - 1; i >= 0; --i)\n  //   {\n  //     cnt = 0;\n  //     int before = -1;\n  //     for (int j = 0; j < W; ++j)\n  //     {\n  //       if (board.at(j).at(i) == -1)\n  //       {\n  //\n  //         if (cnt >= K)\n  //         {\n  //           didnt_change = false;\n  //           ans += pow(2, loop_cnt) * cnt * board.at(j - 1).at(i);\n  //           for (int k = 0; k < cnt; ++k)\n  //           {\n  //             board.at(j - 1 - k).erase(board.at(j - 1 - k).begin() + i);\n  //           }\n  //         }\n  //         before = -1;\n  //         cnt = 0;\n  //       }\n  //       else if (board.at(j).at(i) == before)\n  //       {\n  //         cnt += 1;\n  //       }\n  //       else\n  //       {\n  //         before = board.at(j).at(i);\n  //         if (cnt >= K)\n  //         {\n  //           didnt_change = false;\n  //           ans += pow(2, loop_cnt) * cnt * board.at(j - 1).at(i);\n  //           for (int k = 0; k < cnt; ++k)\n  //           {\n  //             board.at(j - 1 - k).erase(board.at(j - 1 - k).begin() + i);\n  //           }\n  //         }\n  //         cnt = 1;\n  //       }\n  //     }\n  //     if (cnt >= K)\n  //     {\n  //       didnt_change = false;\n  //       ans += pow(2, loop_cnt) * cnt * board.at(W - 1).at(i);\n  //       for (int k = 0; k < cnt; ++k)\n  //       {\n  //         board.at(W - 1 - k).erase(board.at(W - 1 - k).begin() + i);\n  //       }\n  //     }\n  //   }\n  //   if (didnt_change)\n  //   {\n  //     break;\n  //   }\n  // }\n  return ans;\n}\n\nint main()\n{\n  cin >> H >> W >> K;\n  vector<vector<int>> board(W, vector<int>(2 * H, - 1));\n\n  for (int i = 0; i < H; ++i)\n  {\n    string row;\n    cin >> row;\n    for (int j = 0; j < W; ++j)\n    {\n      board.at(j).at(H - 1 - i) = (int)(row.at(j)) - 48;\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i < W; ++i)\n  {\n    for (int j = 0; j < H; ++j)\n    {\n      ans = max(ans, check_point(board, {i + 1, j + 1}));\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < n; i++)\n\nint H, W, K;\nvector<vector<int>> original, board;\n\nvoid input()\n{\n}\n\nvoid change(int &amount, int row)\n{\n  int start = -1, last = -1, cnt = 0;\n  rep(col, W)\n  {\n    if (!board.at(col).at(row))\n    {\n      if (start != -1 && cnt >= K)\n      {\n        amount += board.at(start).at(row) * cnt;\n        for (int i = start; i < start + cnt; i++)\n        {\n          board.at(i).at(row) = -1;\n        }\n      }\n      start = -1;\n      last = -1;\n      cnt = 0;\n      continue;\n    }\n    if (board.at(col).at(row) == last)\n    {\n      cnt++;\n    }\n    else\n    {\n      if (start != -1 && cnt >= K)\n      {\n        amount += board.at(start).at(row) * cnt;\n        for (int i = start; i < start + cnt; i++)\n        {\n          board.at(i).at(row) = -1;\n        }\n      }\n      start = col;\n      last = board.at(col).at(row);\n      cnt = 1;\n    }\n  }\n  if (start != -1 && cnt >= K)\n  {\n    amount += board.at(start).at(row) * cnt;\n    for (int i = start; i < start + cnt; i++)\n    {\n      board.at(i).at(row) = -1;\n    }\n  }\n}\n\nvoid update()\n{\n  rep(col, W)\n  {\n    vector<int> new_col(H, 0);\n    int index = 0;\n    rep(row, H)\n    {\n      if (board.at(col).at(row) == 0)\n      {\n        break;\n      }\n      if (board.at(col).at(row) == -1)\n      {\n        continue;\n      }\n      new_col.at(index) = board.at(col).at(row);\n      index++;\n    }\n    board.at(col) = new_col;\n  }\n}\n\nint solve()\n{\n  int ans = 0;\n  for (int i = 0;; i++)\n  {\n    int amount = 0;\n    rep(row, H) change(amount, row);\n    if (amount == 0)\n      break;\n    ans += (int)pow(2, i) * amount;\n    update();\n  }\n  return ans;\n}\n\nint main()\n{\n  cin >> H >> W >> K;\n  original.resize(W, vector<int>(H, 0));\n  board.resize(W, vector<int>(H, 0));\n  for (int row = H - 1; row >= 0; row--)\n  {\n    string s;\n    cin >> s;\n    rep(col, W)\n    {\n      int num = s.at(col) - '0';\n      original.at(col).at(row) = num;\n    }\n  }\n  int ans = 0;\n  rep(col, W)\n  {\n    rep(row, H)\n    {\n      board = original;\n      board.at(col).at(row) = -1;\n      update();\n      ans = max(ans, solve());\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\n#define rep(i, n) for(int i=0; i<n; i++)\ntypedef long long ll;\nconst int INF = 0;\n \nint main(){\n    int H,W,K; cin>>H>>W>>K;\n    int field[H][W],copy[H][W];\n    rep(i,H){\n      string a; cin>>a;\n      rep(j,W){\n        field[i][j]=a[j]-'0';\n        copy[i][j]=field[i][j];\n      }\n    }\n  \nint rec=0;\nrep(a,H) rep(b,W){\n    rep(i,H) rep(j,W) field[i][j]=copy[i][j];\n    field[a][b]=INF;\n \nrep(k,30){\n        for(int i=0;i<H-1;i++){\n            rep(j,W){\n                if(field[i+1][j]==INF){\n                    field[i+1][j]=field[i][j];\n                    field[i][j]=INF;\n                }\n            }\n        }\n    }\n \n \n int ans=0; \n int two=1;\n rep(l,30){\n   \n    int point=0;\n    rep(i,H){\n \n        int count=1;\n        for(int j=1;j<W;j++){\n            if(field[i][j]==field[i][j-1]) count++;\n            else{\n                if(count<K) count=1;\n                else{\n                    point+=field[i][j-1]*count;\n                    rep(k,count) field[i][j-1-k]=INF;\n                    count=1;\n                }   \n            }\n            if(j==W-1){\n                    if(count>=K){\n                        point+=field[i][j-1]*count;\n                        rep(k,count) field[i][j-k]=INF;\n                    }\n            }\n        }\n    }\n    rep(k,30){\n        for(int i=0;i<H-1;i++){\n            rep(j,W){\n                if(field[i+1][j]==INF){\n                    field[i+1][j]=field[i][j];\n                    field[i][j]=INF;\n                }\n            }\n        }\n    }\n \n    \n   ans+=point*two;\n   two*=2;\n }\n rec=max(ans,rec);\n}\n \ncout<<rec<<endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;using pll = pair<ll, ll>;using pdd = pair<double, double>;using pss = pair<string, string>;using pbb = pair<bool, bool>;\nusing ti3 = tuple<int, int, int>;using tl3 = tuple<ll, ll, ll>;using td3 = tuple<double, double, double>;using ts3 = tuple<string, string, string>;using tb3 = tuple<bool, bool, bool>;\nusing ti4 = tuple<int, int, int, int>;using tl4 = tuple<ll, ll, ll, ll>;using td4 = tuple<double, double, double, double>;using ts4 = tuple<string, string, string, string>;using tb4 = tuple<bool, bool, bool, bool>;\nusing vi = vector<int>;using vl = vector<ll>;using vd = vector<double>;using vs = vector<string>;using vb = vector<bool>;\nusing vvi = vector<vi>;using vvl = vector<vl>;using vvd = vector<vd>;using vvs = vector<vs>;using vvb = vector<vb>;\nusing v3i = vector<vvi>;using v3l = vector<vvl>;using v3d = vector<vvd>;using v3s = vector<vvs>;using v3b = vector<vvb>;\nusing vpii = vector<pii>;using vpll = vector<pll>;using vpdd = vector<pdd>;using vpss = vector<pss>;using vpbb = vector<pbb>;\nusing vti3 = vector<ti3>;using vtl3 = vector<tl3>;using vtd3 = vector<td3>;using vts3 = vector<ts3>;using vtb3 = vector<tb3>;\nusing mii = map<int, int>;using mll = map<ll, ll>;using mci = map<char, int>;using msi = map<string, int>;\nusing si = set<int>;using sl = set<ll>;using sd = set<double>;using ss = set<string>;using sb = set<bool>;\nusing spii = set<pii>;using spll = set<pll>;using spdd = set<pdd>;using spss = set<pss>;using spbb = set<pbb>;\nusing sti3 = set<ti3>;using stl3 = set<tl3>;using std3 = set<td3>;using sts3 = set<ts3>;using stb3 = set<tb3>;\n#define rep0(TIMES) for (int CNT = 0; CNT < (int)(TIMES); CNT++)\n#define rep(CNT, GOAL) for (int CNT = 0; CNT < (int)(GOAL); CNT++)\n#define rep2(CNT, START, GOAL) for (ll CNT = (ll)(START); CNT < (ll)(GOAL); CNT++)\n#define rep3(CNT, START, GOAL) for (ll CNT = (ll)(START); CNT > (ll)(GOAL); CNT--)\n#define all(CONT) begin(CONT), end(CONT)\n#define fr1(CONT) next(begin(CONT)), end(CONT)\n#define itrep(ITR, CONT) for (auto ITR = begin(CONT); ITR != end(CONT); ITR++)\n#define itrep1(ITR, CONT) for (auto ITR = next(begin(CONT)); ITR != end(CONT); ITR++)\n#define maxel(CONT) *max_element(all(CONT))\n#define minel(CONT) *min_element(all(CONT))\ntemplate <typename T> bool chmax(T &a, const T &b) { if (a < b) {\ta = b; return true;\t}\treturn false; }\ntemplate <typename T> bool chmin(T &a, const T &b) { if (a > b) {\ta = b; return true;\t}\treturn false; }\ntemplate <typename T> T sum(const vector<T> &VEC) { return accumulate(all(VEC), 0.0); }\ntemplate <typename T> vector<T> acm(const vector<T> &VEC) { vector<T> RES(VEC.size() + 1); rep(CNT, VEC.size()) RES[CNT + 1] = RES[CNT] + VEC[CNT];\treturn RES; }\ntemplate <typename T> void fil(vector<T> &VEC, const int NUM, const T &VAL) { VEC.assign(NUM, VAL); }\ntemplate <typename T> void fil(vector<T> &VEC, const int NUM) { VEC.assign(NUM, 0.0); }\ntemplate <typename T> void fil(vector<vector<T>> &VV, const int RNUM, const int CNUM, const T &VAL) { fil(VV, RNUM, vector<T>()); rep(CNT, RNUM) fil(VV[CNT], CNUM, VAL); }\ntemplate <typename T> void fil(vector<vector<T>> &VV, const int RNUM, const int CNUM) { fil(VV, RNUM, vector<T>()); rep(CNT, RNUM) fil(VV[CNT], CNUM); }\ntemplate <typename T> void fil(vector<vector<T>> &VV, const int RNUM) { fil(VV, RNUM, vector<T>()); }\nvoid prec(const int &DIG) { cerr << fixed << setprecision(DIG); cout << fixed << setprecision(DIG); }\ntemplate <typename T> void COUT(const T &ELEM) { cout << ELEM; }\ntemplate <typename T> void pout(const T &ELEM) { COUT(ELEM); cout << \" \"; }\ntemplate <typename T, typename ...Ts> void pout(const T &FIRST, const Ts &...REST) { pout(FIRST); pout(REST...); }\ntemplate <typename T> void print(T ELEM) { COUT(ELEM); cout << \"\\n\"; }\ntemplate <typename T, typename ...Ts> void print(const T &FIRST, const Ts &...REST) { print(FIRST); print(REST...); }\nvoid CERR() { cerr << \"\\n\"; }\ntemplate <typename T> void CERR(const T &ELEM) { cerr << ELEM; }\ntemplate <typename T, typename ...Ts> void CERR(const T &FIRST, const Ts &...REST) { CERR(FIRST); cerr << \", \"; CERR(REST...); }\ntemplate <typename T1, typename T2> void CERR(const pair<T1, T2> &PAIR) { cerr << \"(\"; CERR(PAIR.first); cerr << \", \"; CERR(PAIR.second); cerr << \")\"; }\ntemplate <typename T1, typename T2, typename T3> void CERR(const tuple<T1, T2, T3> &TUP3) { cerr << \"(\"; CERR(get<0>(TUP3)); cerr << \", \"; CERR(get<1>(TUP3)); cerr << \", \"; CERR(get<2>(TUP3)); cerr << \")\"; }\ntemplate <typename T1, typename T2, typename T3, typename T4> void CERR(const tuple<T1, T2, T3, T4> &TUP4) { cerr << \"(\"; CERR(get<0>(TUP4)); cerr << \", \"; CERR(get<1>(TUP4)); cerr << \", \"; CERR(get<2>(TUP4)); cerr << \", \"; CERR(get<3>(TUP4)); cerr << \")\"; }\ntemplate <typename T> void CERR(const vector<T> &VEC) { cerr << \"{ \"; itrep(ITR, VEC) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\ntemplate <typename T> void CERR1(const vector<T> &VEC) { cerr << \"{ \"; itrep1(ITR, VEC) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\ntemplate <typename T> void CERR(const set<T> &SET) { cerr << \"{ \"; itrep(ITR, SET) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\ntemplate <typename T1, typename T2> void CERR(const map<T1, T2> &MAP) { cerr << \"{ \"; itrep(ITR, MAP) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\n#define db(OBJ) cerr << #OBJ << \": \"; CERR(OBJ); cerr << \", \"\n#define dbl(OBJ) cerr << #OBJ << \": \"; CERR(OBJ); cerr << \"\\n\"\n#define db1(OBJ) cerr << #OBJ << \": \"; CERR1(OBJ); cerr << \"\\n\"\n#define dbs(...) cerr << \"(\" << #__VA_ARGS__ << \"): (\"; CERR(__VA_ARGS__); cerr << \")\\n\"\n#define dbvv(VV) cerr << #VV << \": {\\n\"; rep(CNT, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define db01(VV) cerr << #VV << \": {\\n\"; rep(CNT, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR1(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define db10(VV) cerr << #VV << \": {\\n\"; rep2(CNT, 1, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define db11(VV) cerr << #VV << \": {\\n\"; rep2(CNT, 1, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR1(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define YN(f) cout << (f ? \"YES\" : \"NO\") << \"\\n\"\n#define Yn(f) cout << (f ? \"Yes\" : \"No\") << \"\\n\"\n#define yn(f) cout << (f ? \"yes\" : \"no\") << \"\\n\"\n#define pcase(NUM) cout << \"Case #\" << NUM << \":\" << \" \"\n#define pcasel(NUM) cout << \"Case #\" << NUM << \":\" << \"\\n\"\nconst ll INF = 1e12 + 7;\n// db\n\n// 石の配置を，列ごとに配列で表し(下にある石の数字が配列の前方に並ぶ)，\n// これらの配列を2次元配列Aにまとめる。\n// A[i][j]は，左からi番目の列の，下からj番目の石の数字を表す。\n\n// 全体に共通するもの\nint H, W, K;\nvector<vector<char>> c; // 入力を90°回転させてから受け取る\nvvi A;\nint ans = 0;\n\nint erase(vvi &A, int j, int i, int t) {\n\tsi s; // A[i][j]~A[i+t-1][j]の石に書いてある数字のset\n\trep2(x, i, i + t) {\n\t\tif (A[x].size() <= j) return 0; // その高さにはもう石がない場合は，この(i,t)に対する処理をやめる\n\t\ts.insert(A[x][j]);\n\t}\n\tif (s.size() > 1) return 0; // 上記区間の全てに石が残ってはいるが，数字の種類が2種類以上である(全て同じではない)場合\n\telse { // 全て同じである場合\n\t\trep2(x, i, i + t) A[x].erase(begin(A[x]) + j); // 石を消す\n\t\t// dbs(i, j, t); dbl(*begin(s) * t);\n\t\treturn *begin(s) * t; // 「石の数字×消えた石の個数」を返す\n\t}\n}\n\nint check(vvi &A, int j) { // 下からj行目に対する処理\n\tint check_res = 0;\n\t// t:W~K,i:0~W-tとして，A[i][j]~A[i+t-1][j]のt個の石が消えるかを確認する。\n\t// 【AOJ1193との重大な相違】1つの行で複数の群の石が消えることがある。なので，一度石が消えた段階でこの行(A[0][j]~A[W-1][j])の処理を終えてはならない。\n\trep3(t, W, K - 1) {\n\t\trep(i, W + 1 - t) {\n\t\t\tcheck_res = erase(A, j, i, t);\n\t\t\tif (check_res) break;\n\t\t}\n\t\tif (check_res) break; // ※一度石が消えた段階で二重ループを脱し，この行の処理を中断するとした場合の実装\n\t}\n\treturn check_res;\n}\n\nint fall(vvi &A) { // Aは参照渡しとする\n\tint fall_res = 0;\n\trep3(j, H - 1, -1) fall_res += check(A, j); // 下からj行目を検査し，消えた石の数字の合計を返り値に加える\n\treturn fall_res;\n}\n\nint solve(int i, int j, vvi A) { // Aは値渡しとする\n\tA[i].erase(begin(A[i]) + j);\n\t// dbs(i, j); dbvv(A);\n\tint solve_res = 0, powcnt = 1; // この試行の合計得点と，連鎖数による倍率\n\twhile (true) {\t\t\n\t\tint fall_res = fall(A); // 現在の状態で消える石の数字の合計\n\t\t// dbl(powcnt); dbvv(A); dbl(fall_res);\n\t\tif (fall_res > 0) { // 上記合計が正なら\n\t\t\tsolve_res += fall_res * powcnt; // 倍率を乗じて得点に加える\n\t\t\tpowcnt *= 2;\n\t\t} else break;\n\t}\n\t// dbl(solve_res);\n\treturn solve_res;\n}\n\nint main() {\n\tcin >> H >> W >> K;\n\tfil(c, W, H); fil(A, W, H);\n\trep3(j, H - 1, -1) rep(i, W) {\n\t\tcin >> c[i][j];\n\t\tA[i][j] = c[i][j] - '0';\n\t}\n\t// dbvv(c);\n\t// 全ての(i,j)の組を試す必要があるか?\n\trep(i, W) {\n\t\trep(j, H / 2) {\n\t\t\tchmax(ans, solve(i, j, A)); // 押す/消す石を決め，simulation\n\t\t}\n\t}\n\tprint(ans);\t\n}\n\n/*\n// AOJ1193\n\nconst int W = 5, num = 3;\nint H, ans;\nvvi A;\n\nbool erase(int j, int i, int k) {\n\t// 下からj行目の，左からi列目からk列を消せるか\n\t// (A[i][j]~A[i+k-1][j])\n\tsi s;\n\trep2(x, i, i + k) {\n\t\tif (A[x].size() <= j) return false;\n\t\ts.insert(A[x][j]);\n\t}\n\tif (s.size() > 1) return false;\n\telse {\n\t\tans += *begin(s) * k;\n\t\trep2(x, i, i + k) A[x].erase(begin(A[x]) + j); // 左からi列目を表す配列中の，下からj行目の要素のイテレータ\n\t\t// dbvv(A); dbl(ans);\n\t\treturn true;\n\t}\n}\n\nbool check(int j) {\n\t// 消せる数kの大きい方からj行目を検査し，消せた段階でこの行の処理を終える\n\t// (k,i):(5,0),(4,0)~(4,1),(3,0)~(3,2)\n\trep3(k, W, num - 1) rep(i, W + 1 - k) {\n\t\tif (erase(j, i, k)) return true;\n\t}\n\treturn false;\n}\n\nbool fall() {\n\tbool fall_res = false;\n\trep3(j, H - 1, -1) if (check(j)) fall_res = true; // 下からH-1行目から0行目に向けて走査，チェック\n\treturn fall_res;\n}\n\nvoid solve() {\n\tfil(A, W, H);\n\trep3(j, H - 1, -1) rep(i, W) cin >> A[i][j];\t\n\tans = 0;\n\t// dbvv(A); dbl(ans);\n\twhile (fall());\n\tprint(ans);\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000\nusing namespace std;\n\nint H, W, K;\nint check_point(vector<vector<int>> board, pair<int, int> hw)\n{\n  int ans = 0;\n  board.at(hw.second - 1).erase(board.at(hw.second - 1).begin() + H - hw.first);\n  int loop_cnt = -1;\n  while (true)\n  {\n    loop_cnt += 1;\n    bool didnt_change = true;\n    int cnt;\n    for (int i = H - 1; i >= 0; --i)\n    {\n      cnt = 0;\n      int before = -1;\n      for (int j = 0; j < W; ++j)\n      {\n        if (board.at(j).at(i) == -1)\n        {\n\n          if (cnt >= K)\n          {\n            didnt_change = false;\n            ans += pow(2, loop_cnt) * cnt * board.at(j - 1).at(i);\n            for (int k = 0; k < cnt; ++k)\n            {\n              board.at(j - 1 - k).erase(board.at(j - 1 - k).begin() + i);\n            }\n          }\n          before = -1;\n          cnt = 0;\n        }\n        else if (board.at(j).at(i) == before)\n        {\n          cnt += 1;\n        }\n        else\n        {\n          before = board.at(j).at(i);\n          if (cnt >= K)\n          {\n            didnt_change = false;\n            ans += pow(2, loop_cnt) * cnt * board.at(j - 1).at(i);\n            for (int k = 0; k < cnt; ++k)\n            {\n              board.at(j - 1 - k).erase(board.at(j - 1 - k).begin() + i);\n            }\n          }\n          cnt = 1;\n        }\n      }\n      if (cnt >= K)\n      {\n        didnt_change = false;\n        ans += pow(2, loop_cnt) * cnt * board.at(W - 1).at(i);\n        for (int k = 0; k < cnt; ++k)\n        {\n          board.at(W - 1 - k).erase(board.at(W - 1 - k).begin() + i);\n        }\n      }\n    }\n    if (didnt_change)\n    {\n      break;\n    }\n  }\n  return ans;\n}\n\nint main()\n{\n  cin >> H >> W >> K;\n  vector<vector<int>> board(W, vector<int>(2 * H, - 1));\n\n  for (int i = 0; i < H; ++i)\n  {\n    string row;\n    cin >> row;\n    for (int j = 0; j < W; ++j)\n    {\n      board.at(j).at(H - 1 - i) = (int)(row.at(j)) - 48;\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i < W; ++i)\n  {\n    for (int j = 0; j < H; ++j)\n    {\n      ans = max(ans, check_point(board, {j + 1, i + 1}));\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vchar = vector<char>;\nusing vvchar = vector<vchar>;\nusing vp = vector<P>;\nusing vpp = vector<pair<P, P>>;\nusing vvp = vector<vp>;\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#pragma region Debug\nistream &operator>>(istream &is, P &a)\n{\n    return is >> a.first >> a.second;\n}\nostream &operator<<(ostream &os, const P &a) { return os << \"(\" << a.first << \",\" << a.second << \")\"; }\n\ntemplate <typename T>\nvoid view(const std::vector<T> &v)\n{\n    for (const auto &e : v)\n    {\n        std::cout << e << \" \";\n    }\n    std::cout << std::endl;\n}\ntemplate <typename T>\nvoid view(const std::vector<std::vector<T>> &vv)\n{\n    for (const auto &v : vv)\n    {\n        view(v);\n    }\n}\n#pragma endregion\n\nint popRow(vvint &g, int y, int w, int k, int p)\n{\n    vint row = g[y];\n    int score = 0;\n    int add = pow(2, p);\n\n    int li = 0, l = row[0];\n    rep(i, w)\n    {\n        if (row[i] != l)\n        {\n            l = row[i];\n            li = i;\n            continue;\n        }\n\n        if (i - li >= k - 1)\n        {\n            for (int j = i; j >= li && g[y][j]; j--)\n            {\n                score += add * g[y][j];\n                g[y][j] = 0;\n            }\n        }\n    }\n\n    return score;\n}\n\nint pop(vvint &g, int h, int w, int k, int p)\n{\n    int score = 0;\n    rep(y, h)\n    {\n        score += popRow(g, y, w, k, p);\n    }\n    return score;\n}\n\nvoid shift(vvint &g, int h, int w)\n{\n    for (int y = h - 2; y >= 0; y--)\n        rep(x, w)\n        {\n            int d = 1;\n            while (y + d < h && g[y + d][x] == 0)\n            {\n                g[y + d][x] = g[y + d - 1][x];\n                g[y + d - 1][x] = 0;\n                d++;\n            }\n        }\n}\n\nint main()\n{\n    int h, w, k;\n    cin >> h >> w >> k;\n\n    vvint g(h, vint(w));\n    rep(i, h)\n    {\n        string s;\n        cin >> s;\n        rep(j, w) g[i][j] = s[j] - '0';\n    }\n\n    vvint back = g;\n\n    int ans = 0;\n    rep(y, h) rep(x, w)\n    {\n        int now = 0;\n        int p = 0;\n        g[y][x] = 0;\n        while (true)\n        {\n            shift(g, h, w);\n            int newScore = pop(g, h, w, k, p);\n            now += newScore;\n            ++p;\n            if (newScore == 0)\n                break;\n        }\n        g = back;\n        ans = max(now, ans);\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint h,w,k;\nint c[35][35];\nint f[35][35];\n\nint do_vanish(){\n    int ret = 0;\n    int g[35][35]={};\n    for(int i=0; i<h; i++){\n        for(int j=0; j+(k-1)<w; j++){\n            bool flag = true;\n            if(f[i][j] == 0) break;\n            for(int l=1; l<=k-1; l++){\n                if(f[i][j] != f[i][j+l]) flag = false;\n            }\n            if(flag){\n                for(int l=0; l<=k-1; l++) g[i][j+l] = 1;\n            }\n        }\n    }\n    for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++){\n            if(g[i][j] == 1){\n                ret += f[i][j];\n                f[i][j] = 0;\n            }\n        }\n    }\n    return ret;\n}\n\nvoid do_clean(){\n    bool flag=true;\n    while(flag){\n        flag = false;\n        for(int i=0; i<h-1; i++){\n            for(int j=0; j<w; j++){\n                if(f[i][j] != 0 && f[i+1][j] ==0){\n                    f[i+1][j] = f[i][j];\n                    f[i][j] = 0;\n                    flag = true;\n                }\n            }\n        }\n    }\n    return;\n}\n\nint main(){\n    cin >> h >> w >> k;\n    for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++){\n            char z;\n            cin >> z;\n            c[i][j] = z - '0';\n            //cout << c[i][j] << endl;\n        }\n    }\n\n    int max_ans = 0;\n    for(int p=0; p<h; p++){\n        for(int q=0; q<w; q++){\n            for(int i=0; i<h; i++) for(int j=0; j<w; j++) f[i][j] = c[i][j];\n            f[p][q]=0;\n            int ans=0;\n            int pow=1;\n            while(true){\n                do_clean();\n                int x = do_vanish();\n                if(x == 0) break;\n                ans += pow*x;\n                pow *= 2;\n            }\n        max_ans = max(ans, max_ans);\n        }\n    }\n    \n    cout << max_ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\n#define F first\n#define S second\n\nconst int mx=200010;\nconst ll mod=1e9+7;\n\n\nint main() {\n  int h,w,k;\n  cin >> h >> w >> k;\n  vector<vector<int>> data(30, vector<int>(30,0));\n  rep(i,h)rep(j,w){ char c; cin >> c; data[i][j] = c-'0'; }\n\n  ll ans=0;\n  rep(x,h)rep(y,w){\n    auto c = data;\n    c[x][y] = 0;\n    ll base = 0, res = 0;\n    while(1){\n      ll tmp = 0;\n      rep(i,h){\n        int st=0;\n        rep(j,w+1){\n          if(j==w || (j>0 && c[i][j-1]!=c[i][j])){\n            if(j-st>=k){ for(int p=st; p<j; p++){ tmp+=c[i][p]; c[i][p]=0; } }\n            st = j;\n          }\n        }\n      }\n      if(base!=0 && tmp==0) break;\n      res += base*tmp;\n      base = (base>0?base*2:1);\n\n      rep(j,w){\n        int pos = h-1;\n        for(int i=h-1; i>=0; i--){\n          if(c[i][j]!=0){\n            c[pos][j] = c[i][j];\n            if(pos!=i) c[i][j] = 0;\n            pos--;\n          }\n        }\n      }\n    }\n    ans = max(ans, res);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define M_PI       3.14159265358979323846   // pi\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<ll> VI;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\n\n#define rep(a,n) for(ll a = 0;a < n;a++)\n#define repi(a,b,n) for(ll a = b;a < n;a++)\n\nusing namespace std;\n\nstatic const ll INF = 1e15;\n\ntemplate<typename T>\nstatic inline void chmin(T & ref, const T  value) {\n    if (ref > value) ref = value;\n}\n\ntemplate<typename T>\nstatic inline void chmax(T & ref, const T value) {\n    if (ref < value) ref = value;\n}\n\nconst ll mod = 1000000007;\n\n\nint main() {\n\tll h, w, k;\n\tcin >> h >> w >> k;\n\tvector<vector<ll>> grid(h, vector<ll>(w, 0));\n\trep(i, h) {\n\t\tstring s;\n\t\tcin >> s;\n\t\trep(j, w) {\n\t\t\tgrid[i][j] = s[j] - '0';\n\t\t}\n\t}\n\n\tll u = 0;\n\trep(i, h) {\n\t\trep(j, w) {\t\t\t\n\t\t\tvector<vector<ll>> current = grid;\n\t\t\tll score = 0;\n\t\t\tbool update = true;\n\t\t\tvector<unordered_set<int>> del(w);\n\t\t\tdel[j].insert(i);\n\t\t\tll pow2 = 1;\n\t\t\twhile (update) {\n\t\t\t\tupdate = false;\n\t\t\t\trep(x, w) {\n\t\t\t\t\tconst auto& s = del[x];\n\t\t\t\t\tif (s.size()) {\n\t\t\t\t\t\tint target = h - 1;\n\t\t\t\t\t\tfor (int y = h - 1; y >= 0; y--) {\n\t\t\t\t\t\t\twhile(s.count(target)) {\n\t\t\t\t\t\t\t\ttarget--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (target < 0) {\n\t\t\t\t\t\t\t\tcurrent[y][x] = -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tcurrent[y][x] = current[target][x];\n\t\t\t\t\t\t\t\ttarget--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(i, w) del[i].clear();\n\t\t\t\trep(y, h) {\n\t\t\t\t\tint left = 0;\n\t\t\t\t\tint right = 0;\n\t\t\t\t\twhile (left < w && right < w) {\n\t\t\t\t\t\tif (current[y][left] == -1) {\n\t\t\t\t\t\t\tleft++;\n\t\t\t\t\t\t\tright = left;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (right < w && current[y][left] == current[y][right]) {\n\t\t\t\t\t\t\tright++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (right - left >= k) {\n\t\t\t\t\t\t\tfor (int a = left; a < right; a++) {\n\t\t\t\t\t\t\t\tscore += pow2 * current[y][a];\n\t\t\t\t\t\t\t\tif (score == 6) {\n\t\t\t\t\t\t\t\t\tcout << endl;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdel[a].insert(y);\n\t\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tleft = right;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tleft++;\n\t\t\t\t\t\t\tright = left;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpow2 *= 2;\n\t\t\t}\n\t\t\tchmax(u, score);\n\t\t}\n\t}\n\tcout << u << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nint H, W, K, c[31][31];\nint tmp = 0, res = 0, ans = 0;\n\nint point(int cou, int sum) {\n\tint res = 2;\n\tfor (int i = 0; i < cou; ++i) { res = res*res; }\n\treturn res*sum;\n}\n\nint main(void) {\n\tscanf(\"%d%d%d\", &H, &W, &K);\n\tfor (int i = 0; i < H; ++i) { for (int j = 0; j < W; ++j) { scanf(\"%d\", &c[i][j]); } }\n\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tif (0 < i) {\n\t\t\t\ttmp = c[i][j];\n\t\t\t\tfor (int x = i - 1; x >= 0; --x) {\n\t\t\t\t\tc[x + 1][j] = c[x][j];\n\t\t\t\t\tc[x][j] = 0;\n\t\t\t\t}\n\t\t\t\twhile (true) {\n\t\t\t\t\tbool break_frag = false;\n\t\t\t\t\tint cou = 0;\n\t\t\t\t\tfor (int x = H - 1; x >= 0; --x) {\n\t\t\t\t\t\tbool all_same = true;\n\t\t\t\t\t\tfor (int y = 0; y < W - 1; ++y) {\n\t\t\t\t\t\t\ttmp += c[x][y];\n\t\t\t\t\t\t\tif (c[x][y] != c[x][y + 1]) {\n\t\t\t\t\t\t\t\tall_same = false;\n\t\t\t\t\t\t\t\ttmp = c[i][j];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (all_same == true) {\n\t\t\t\t\t\t\ttmp += c[x][W - 1];\n\t\t\t\t\t\t\tfor (int k = x - 1; k >= 0; --k) {\n\t\t\t\t\t\t\t\tfor (int l = 0; l < W; ++j) {\n\t\t\t\t\t\t\t\t\tc[k + 1][l] = c[k][l];\n\t\t\t\t\t\t\t\t\tc[k][l] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tall_same = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcou++;\n\t\t\t\t\t\t\tif (cou == H - 1) { break_frag = true; }\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres = point(x - H - 2, tmp);\n\t\t\t\t\t}\n\t\t\t\t\tans = std::max(res, ans);\n\t\t\t\t\tif (break_frag == true) { break; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define mt make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int H, W, K;\n    int rem[30][30];\n\n    while(cin >> H >> W >> K) {\n        vector<string> S(H);\n        rep(y, H)cin >> S[y];\n\n        ll ans = 0;\n\n        rep(remY, H)rep(remX, W) {\n            vector<list<int>> ls(W);\n            rep(x, W) {\n                rep(y, H) {\n                    if(y != remY || x != remX)ls[x].push_back(S[H-1-y][x] - '0');\n                }\n            }\n\n            vector<list<int>::iterator> its(W);\n\n            int upd = 1;\n            ll mul = 1, value = 0;\n            while(upd) {\n                ll sm = 0;\n                upd = 0;\n                vi col(W);\n                MEM(rem, 0);\n\n                rep(x, W)its[x] = ls[x].begin();\n\n                int row = 0;\n                for(; row < H && count(all(col), -1) != W; ++row) {\n                    int cur = -1, start = -1, suc = 0;\n                    rep(x, W) {\n                        if(its[x] == ls[x].end())col[x] = -1;\n                        else col[x] = *its[x];\n                        if(cur != col[x]) {\n                            if(cur != -1 && suc >= K) {\n                                FOR(i, start, x)rem[row][i] = 1;\n                                upd = 1;\n                            }\n                            suc = 1;\n                            cur = col[x];\n                            start = x;\n                        } else {\n                            suc++;\n                        }\n                    }\n\n                    if(cur!=-1 && suc >= K) {\n                        FOR(i, start, W)rem[row][i] = 1;\n                        upd = 1;\n                    }\n                    rep(x, W) {\n                        if(rem[row][x]) {\n                            sm += *its[x];\n                            its[x] = ls[x].erase(its[x]);\n                        } else if(its[x] != ls[x].end()) {\n                            its[x]++;\n                        }\n                    }\n                }\n\n                value += sm*mul;\n\n                mul *= 2;\n            }\n\n            \n            smax(ans, value);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid\tcopy(int H, int W, int c[30][30], int grid[30][30])\n{\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j)\n\t\t\tgrid[i][j] = c[i][j];\n\t}\n}\n\nvoid\tremove(int h, int w, int grid[30][30])\n{\n\tfor (int i = h; i > 0; --i)\n\t\tgrid[i][w] = grid[i - 1][w];\n\tgrid[0][w] = 0;\n}\n\nint\tcalc_score(int H, int W, int K, int grid[30][30], int score_grid[30][30]) \n{\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j)\n\t\t\tscore_grid[i][j] = 0;\n\t}\n\tint\tscore = 0;\n\tfor (int i = 0; i < H; ++i) {\n\t\tstack<pair<int, int>>\tstk;\n\t\tstk.push({0, 1});\n\t\tfor (int j = 1; j < W; ++j) {\n\t\t\tauto pr = stk.top(); stk.pop();\n\t\t\tif (grid[i][pr.first] == grid[i][j]) {\n\t\t\t\tpr.second += 1;\n\t\t\t\tstk.push(pr);\n\t\t\t} else {\n\t\t\t\tstk.push(pr);\n\t\t\t\tstk.push({j, 1});\n\t\t\t}\n\t\t}\n\t\twhile (!stk.empty()) {\n\t\t\tauto pr = stk.top(); stk.pop();\n\t\t\tif (pr.second < K) continue;\n\t\t\tfor (int j = pr.first; j < pr.first + pr.second; ++j)\n\t\t\t\tscore_grid[i][j] = grid[i][j];\n\t\t}\n\t}\n\tscore = 0;\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j)\n\t\t\tscore += score_grid[i][j];\n\t}\n\treturn score;\n}\n\nvoid\tupdate(int H, int W, int grid[30][30], int score_grid[30][30])\n{\n\tfor (int j = 0; j < W; ++j) {\n\t\tint\ttop = H - 1;\n\t\tfor (int i = H - 1; i >= 0; --i) {\n\t\t\tif (grid[i][j] == score_grid[i][j]) continue;\n\t\t\tgrid[top][j] = grid[i][j];\n\t\t\t--top;\n\t\t}\n\t\tfor (int i = top; i >= 0; --i)\n\t\t\tgrid[i][j] = 0;\n\t}\n}\n\nint\tmain()\n{\n\tint\tc_grid[30][30] = {};\n\tint\tgrid[30][30] = {};\n\tint\tscore_grid[30][30] = {};\n\tint\tH, W, K;\n\tcin >> H >> W >> K;\n\tchar\tc;\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tcin >> c;\n\t\t\tc_grid[i][j] = static_cast<int>(c - '0');\n\t\t}\n\t}\n\tint\tmax_score = 0;\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tint score = 0;\n\t\t\tcopy(H, W, c_grid, grid);\n\t\t\tremove(i, j, grid);\n\t\t\tint\tpower = 1;\n\t\t\tint\ttmp = 0;\n\t\t\twhile ((tmp = calc_score(H, W, K, grid, score_grid)) > 0) {\n\t\t\t\tscore += power * tmp;\n\t\t\t\tpower *= 2;\n\t\t\t\tupdate(H, W, grid, score_grid);\n\t\t\t}\n\t\t\tif (max_score < score)\n\t\t\t\tmax_score = score;\n\t\t}\n\t}\n\tcout << max_score << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MOD=1000000007;\n#define INF 1LL<<30\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\n\n\nvoid clear_m(vector<string> &d,int H,int W){\n    rep(k,32){\n        for(int i=H-1;i>=1;i--){\n            rep(j,W){\n                if(d[i][j]=='0'){\n                    swap(d[i][j],d[i-1][j]);\n                }\n            }\n        }\n    }\n}\n\nbool is_update(vector<string> &d,int H,int W,int K){\n    bool update=false;\n    rep(i,H){\n        rep(j,W){\n            if(d[i][j]!='0'){\n                int c=0;\n                char ch=d[i][j];\n                while(j<W && d[i][j]==ch) j++,c++;\n                if(c>=K) update=true;\n                j--;\n            }\n        }\n    }\n\n    return update;\n}\n\nll calc_m(vector<string> &d,int H,int W,int K){\n    ll sum=0;\n    rep(i,H){\n        rep(j,W){\n            if(d[i][j]!='0'){\n                int c=0;\n                char ch=d[i][j];\n                int k=j;\n                while(k<W && d[i][k]==ch) k++,c++;\n                if(c>=K){\n                    sum+=(ch-'0')*c;\n                    k=j;\n                    while(k<W && d[i][k]==ch) d[i][k]='0',k++;\n                }\n            }\n        }\n    }\n\n    return sum;\n}\n\n\nint main(){\n    int H,W,K;\n    cin>>H>>W>>K;\n    \n    vector<string> c(H);\n    rep(i,H) cin>>c[i];\n\n    ll ans=0;\n    rep(i,H){\n        rep(j,H){\n            ll sum=0;\n            vector<string> d=c;\n            d[i][j]='0';\n            clear_m(d,H,W);\n\n            int cnt=0;\n            while(true){\n                if(!is_update(d,H,W,K)) break;\n                ll ret=calc_m(d,H,W,K);\n                sum+=pow(2,cnt)*ret;\n                clear_m(d,H,W);\n                cnt++;\n            }\n            ans=max(ans,sum);\n        }\n    }\n\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n# define REP(i,n) for (int i=0;i<(n);++i)\n# define rep(i,a,b) for(int i=a;i<(b);++i)\n# define p(s) std::cout << s ;\n# define pl(s)  std::cout << s << endl;\n# define printIf(j,s1,s2) cout << (j ? s1 : s2) << endl;\n# define YES(j) cout << (j ? \"YES\" : \"NO\") << endl;\n# define Yes(j) std::cout << (j ? \"Yes\" : \"No\") << endl;\n# define yes(j) std::cout << (j ? \"yes\" : \"no\") << endl;\n# define all(v) v.begin(),v.end()\n# define showVector(v) REP(i,v.size()){p(v[i]);p(\" \")} pl(\"\")\ntemplate<class T> inline bool chmin(T &a, T b){ if(a > b) { a = b; return true;} return false;}\ntemplate<class T> inline bool chmax(T &a, T b){ if(a < b) { a = b; return true;} return false;}\ntypedef long long int ll;\ntypedef pair<ll,ll> P_ii;\ntypedef pair<double,double> P_dd;\n\nconst int MOD = 1000000007;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\n\nvoid addM(long long &a, long long b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\n\nvoid mulM(long long &a, long long b) {\n    a = ((a%MOD)*(b%MOD))%MOD ;\n}\n\nint main(){\n    int H, W, K;\n    cin >> H >> W >> K;\n\n    int C[30][30];\n    REP(i, H) REP(j, W) scanf(\"%1d\", &C[i][j]);\n\n    ll ans = 0;\n    REP(x, H) REP(y, W){\n\n        int c[30][30];\n        REP(i, H) REP(j, W) c[i][j] = C[i][j];\n        c[x][y] = 0;\n\n        ll pw = 0, result = 0;\n        while(true){\n            ll num = 0;\n            REP(i, H){\n                REP(j, W) {\n                    int st = j;\n                    while(st < W && c[i][j] == c[i][st]) st++;\n                    if(st - j >= K){\n                        for(int l = j; l < st; l++){\n                            num += c[i][l];\n                            c[i][l] = 0;\n                        }\n                    }\n                    j = st - 1;\n                }\n            }\n            if(pw > 0 && num == 0) break;\n            result += pw * num;\n            pw = pw > 0 ? pw * 2 : 1;\n\n            REP(j, W){\n                int pos = H - 1;\n                for(int i = H - 1; i >= 0; i--){\n                    if(c[i][j] > 0){\n                        c[pos][j] = c[i][j];\n                        if(pos != i) c[i][j] = 0;\n                        pos--;\n                    }\n                }\n            }\n        }\n        ans = max(ans, result);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// /usr/local/bin/g++ Main.cpp -std=c++14\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint H, W, K, C[30*30], _c[30*30];\nset<int> d;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> H >> W >> K;\n\tfor (int i = 0; i < H; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tint j = 0;\n\t\tfor (char& c : s) {\n\t\t\tC[i*W+(j++)] = (int)(c - '0');\n\t\t}\n\t}\n\n\tll res = 0;\n\tfor (int i = 1; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tfor (int k = 0; k < 30*30; k++) {\n\t\t\t\t_c[k] = C[k];\n\t\t\t}\n\t\t\td.clear();\n\t\t\td.insert(i*W+j);\n\t\t\tint cnt = 0;\n\t\t\tint __res = 0;\n\t\t\twhile (d.size()) {\n\t\t\t\tfor (int l : d) {\n\t\t\t\t\tfor (int _i = l/W; _i > 0; _i--) {\n\t\t\t\t\t\t_c[_i*W+l%W] = _c[(_i-1)*W+l%W];\n\t\t\t\t\t}\n\t\t\t\t\t_c[l%W] = 0;\n\t\t\t\t}\n\t\t\t\td.clear();\n\t\t\t\tint _res = 0;\n\t\t\t\tfor (int _i = 1; _i < H; _i++) {\n\t\t\t\t\tint pre = 0;\n\t\t\t\t\tbool loop = false;\n\t\t\t\t\tfor (int _j = 0; _j <= W; _j++) {\n\t\t\t\t\t\tif (_j != W && pre != 0 && _c[_i*W+_j] == pre) {\n\t\t\t\t\t\t\t_res += pre;\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t\td.insert(_i*W+_j-1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (loop) {\n\t\t\t\t\t\t\t\t_res += pre;\n\t\t\t\t\t\t\t\td.insert(_i*W+_j-1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tloop = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (_j < W) pre = _c[_i*W+_j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (_res > 0) {\n\t\t\t\t\tint tmp = 1;\n\t\t\t\t\tfor (int _k = 0; _k < cnt; _k++) {\n\t\t\t\t\t\ttmp *= 2;\n\t\t\t\t\t}\n\t\t\t\t\t__res += tmp*_res;\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif (res < __res) res = __res;\n\t\t}\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    Problem 93\n    https://atcoder.jp/contests/s8pc-3/tasks/s8pc_3_b\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n/* typedef */\ntypedef long long ll;\ntypedef pair<int, int> pii;\n/* class */\nclass pazzle {\n    public:\n    int H, W, K;\n    ll ans = 0;\n    vector<vector<int> > v;\n    pazzle (int H, int W, int K, vector<vector<int> > v)\n    : H(H), W(W), K(K), v(v) {}\n    bool del() {\n        int ret = false;\n        for (int i = 0; i < H; i++) {\n            int r = 0;\n            for (int l = 0; l < W; l++) {\n                int tmp = v[i][r];\n                while (v[i][r] == -1) {\n                    r++;\n                    l++;\n                }\n                while (v[i][r] == v[i][r + 1]){\n                    r++;\n                    tmp += v[i][r];\n                }\n                if (r - l + 1>= K) {\n                    for (int k = l; k <= r; k++) v[i][k] = -1;\n                    ans += tmp;\n                    ret = true;\n                }\n                l = r;\n                r++;\n            }\n        }\n        return ret;\n    }\n    void move() {\n        for (int i = 0; i < W; i++) {\n            for (int j = H - 1; j > 0; j--) {\n                if (v[j][i] == -1) {\n                    int k = j - 1;\n                    while (v[k][i] == -1 && k > 0) k--;\n                    if (v[k][i] != -1) swap(v[k][i], v[j][i]);\n                }\n            }\n        }\n    }\n    void printPoint() {\n        cout << ans << '\\n';\n    }\n    ll gameStart() {\n        ll ret = 0;\n        move();\n        for (int i = 0; del(); i++){\n            move();\n            ret += pow(2, i) * ans;\n            ans = 0;\n        }\n        return ret;\n    }\n};\n/* constant */\nconst int INF = (1 << 30);\n/* global variables */\n/* function */\n/* main */\nint main(){\n    int H, W, K;\n    cin >> H >> W >> K;\n    vector<string> vs(H);\n    for (int i = 0; i < H; i++) cin >> vs[i];\n    vector<vector<int> > v(H, vector<int> (W + 1, -2));\n    for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) v[i][j] = vs[i][j] - '0';\n    if (K == 1) {\n        int ans = 0;\n        int minValue = INF;\n        for (auto vi : v) {\n            ans += accumulate(vi.begin(), vi.end(), 0);\n            minValue = min(*min_element(vi.begin(), vi.end()), minValue);\n        }\n        cout << ans  - minValue << '\\n';\n        return 0;\n    }\n    ll ans = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int tmp = v[i][j];\n            v[i][j] = -1;\n            pazzle P = pazzle(H, W, K, v);\n            ans = max(ans, P.gameStart());\n            v[i][j] = tmp;\n        }\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define double long double\n#define rep(i, a, n) for(int i = (int)(a);(i) < (int)(n);++(i))\n#define repe(i, a, n) for(int i = (int)(a);(i) <= (int)(n);++(i))\n#define repif(i, a, x) for(int i = (int)(a);(x);++(i))\n#define repr(i, a, n) for(int i = ((int)(a)-1);(i) >= (int)(n);--(i))\n#define reper(i, a, n) for(int i = (int)(a);(i) >= (int)(n);--(i))\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define CEIL(x) ((int)ceil(((double)x)))\n#define POW(x, y) ((int)pow(x, y))\n#define UNIQUE(x) (x).erase(unique(begin(x), end(x)), end(x))\nusing namespace std;\nusing VI = vector<int>;\nusing VVI = vector<vector<int>>;\nusing PII = pair<int, int>;\nusing TIII = tuple<int, int, int>;\nusing VPII = vector<pair<int, int>>;\nusing VTIII = vector<tuple<int, int, int>>;\nusing Complex = complex<double>;\ntemplate<typename T> inline bool chmax(T& a, const T& b, bool t = false){ if(a<b or (t and a==b)){ a=b; return true; } return false; }\ntemplate<typename T> inline bool chmin(T& a, const T& b, bool t = false){ if(a>b or (t and a==b)){ a=b; return true; } return false; }\ntemplate<typename T> inline bool isin(const T& x, const T& l, const T& r){ return l <= x and x < r; }\ninline ostream& fcout(int n = 10){ return cout << fixed << setprecision(n); }\ninline ostream& rcout(int n = 2){ return cout << right << setw(n); }\nconstexpr int64_t INF = numeric_limits<int64_t>::max();\nconstexpr int32_t INF32 = numeric_limits<int32_t>::max();\nconstexpr int64_t MOD = 1000000007LL;\nconstexpr double PI = 3.14159265358979323846264338327950288;\nconstexpr double EPS = 1e-10;\n\n\nint H, W, K;\n\n\nint dfs(VI& row, int p){\n    if(p == W) return 0;\n    if(p+1 < W and row[p] == row[p+1]) return dfs(row, p+1)+1;\n    return 1;\n}\n\n\nint del(VVI& brd){\n    int res = 0;\n    rep(i, 0, H){\n        int j = 0;\n        while(j < W){\n            int c = dfs(brd[i], j);\n            if(c >= K){\n                res += brd[i][j]*c;\n                rep(k, j, j+c) brd[i][k] = 0;\n            }\n            j += c;\n        }\n    }\n    return res;\n}\n\n\nvoid drop(VVI& brd){\n    repr(i, H-1, 0) rep(j, 0, W){\n        if(brd[i][j] == 0) continue;\n        int c = 0;\n        rep(k, i+1, H) if(brd[k][j] == 0) c++;\n        swap(brd[i][j], brd[i+c][j]);\n    }\n}\n\n\nint32_t main(){\n    cin >> H >> W >> K;\n    VVI brd(H, VI(W));\n    rep(i, 0, H){\n        string s;\n        cin >> s;\n        rep(j, 0, W) brd[i][j] = s[j]-'0';\n    }\n\n    int ans = 0;\n    rep(i, 0, H) rep(j, 0, W){\n        int s = 0, c;\n        auto b = brd;\n        b[i][j] = 0;\n        drop(b);\n        int p2 = 1;\n        while(c = del(b), c) s += c*p2, drop(b), p2 <<= 1;\n        chmax(ans, s);\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\ntypedef long long lint;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef unsigned long long ulint;\n#define endl '\\n'\n#define fst first\n#define sed second\n#define pb push_back\n#define mp make_pair\n#define rint register int\n#define newline putchar('\\n')\n#define leave_space putchar(' ')\n#define all(x) (x).begin(), (x).end()\n#define reveal(x) cerr << #x << \" = \" << (x) << endl\n#define rep(it, f, e) for (rint it = (f); it <= (e); ++it)\n#define per(it, f, e) for (rint it = (f); it >= (e); --it)\nconst int MAXN = 32;\nint n, m, k;\nchar maze[MAXN][MAXN];\nint use[MAXN][MAXN], cpy[MAXN][MAXN];\ninline void falldown(int x, int y) {\n\twhile (x && use[x - 1][y]) {\n\t\tswap(use[x][y], use[x - 1][y]); --x;\n\t}\n}\ninline lint dfs() {\n\tlint ret = 0;\n\trep (i, 1, n) {\n\t\tint las = 0;\n\t\tvector<int> FD;\n\t\trep (j, 1, m) {\n\t\t\tif (!use[i][j]) las = 0;\n\t\t\telse if (use[i][j] == use[i][j - 1]) ++las;\n\t\t\telse las = 1;\n\t\t\tif (las >= k) {\n\t\t\t\tret += use[i][j];\n\t\t\t\tif (las == k) {\n\t\t\t\t\tret += use[i][j] * (k - 1);\n\t\t\t\t\trep (K, j - k + 1, j) {\n\t\t\t\t\t\tFD.pb(K);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tFD.pb(j);\n\t\t\t\t\tfalldown(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto p : FD) {\n\t\t\tuse[i][p] = 0;\n\t\t\tfalldown(i, p);\n\t\t}\n\t}\n\tif (ret) ret += dfs() * 2;\n\treturn ret;\n}\nint main() {\n\tcin >> n >> m >> k;\n\trep (i, 1, n) {\n\t\tcin >> (maze[i] + 1);\n\t\trep (j, 1, m) {\n\t\t\tcpy[i][j] = maze[i][j] - '0';\n\t\t}\n\t}\n\tlint ans = 0;\n\trep (i, 1, n) {\n\t\trep (j, 1, m) {\n\t\t\tmemcpy(use, cpy, sizeof(use));\n\t\t\tuse[i][j] = 0;\n\t\t\tfalldown(i, j);\n\t\t\tans = max(ans, dfs());\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint h,w,k;\nint c[35][35];\nint f[35][35];\n\nint do_vanish(){\n    int ret = 0;\n    int g[35][35]={};\n    for(int i=0; i<h; i++){\n        for(int j=0; j+(k-1)<w; j++){\n            bool flag = true;\n            if(f[i][j] == 0) continue;\n            for(int l=1; l<=k-1; l++){\n                if(f[i][j] != f[i][j+l]) flag = false;\n            }\n            if(flag){\n                for(int l=0; l<=k-1; l++) g[i][j+l] = 1;\n            }\n        }\n    }\n    for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++){\n            if(g[i][j] == 1){\n                ret += f[i][j];\n                f[i][j] = 0;\n            }\n        }\n    }\n    return ret;\n}\n\nvoid do_clean(){\n    bool flag=true;\n    while(flag){\n        flag = false;\n        for(int i=0; i<h-1; i++){\n            for(int j=0; j<w; j++){\n                if(f[i][j] != 0 && f[i+1][j] ==0){\n                    f[i+1][j] = f[i][j];\n                    f[i][j] = 0;\n                    flag = true;\n                }\n            }\n        }\n    }\n    return;\n}\n\nint main(){\n    cin >> h >> w >> k;\n    for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++){\n            char z;\n            cin >> z;\n            c[i][j] = z - '0';\n            //cout << c[i][j] << endl;\n        }\n    }\n\n    long long max_ans = 0;\n    for(int ii=0; ii<h; ii++){\n        for(int jj=0; jj<w; jj++){\n            for(int i=0; i<h; i++) for(int j=0; j<w; j++) f[i][j] = c[i][j];\n            f[ii][jj]=0;\n            long long ans=0;\n            int pow=1;\n            while(true){\n                do_clean();\n                int x = do_vanish();\n                if(x == 0) break;\n                ans += pow*x;\n                pow *= 2;\n            }\n        max_ans = max(ans, max_ans);\n        }\n    }\n    \n    cout << max_ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint H, W, K;\n\nvoid blockfall(vector<string> &board) {\n    for(int i=H-1; i>=0; i--) {\n        for(int j=0; j<W; j++) {\n            int x = i, y = j;\n            while(x < H-1 && board[x+1][y] == '.') {\n                swap(board[x][y], board[x+1][y]);\n                x++;\n            }\n        }\n    }\n}\n\nvector<string> erase_one(vector<string> board, int x, int y) {\n    board[x][y] = '.';\n    blockfall(board);\n    return board;\n}\n\nint solve(vector<string> board) {\n    int ret = 0;\n\n    for(int i=0; i<H; i++) cout << board[i] << endl;\n\n    for(int z=0; ; z++) {\n        bool changed = false;\n        vector<string> chg(H, string(W, '.'));\n\n        int sum = 0;\n        for(int i=0; i<H; i++) {\n            char pre = '#';\n            int cons = 0;\n            for(int j=0; j<=W; j++) {\n                // printf(\"i = %d, j = %d, cons = %d\\n\", i, j, cons);\n                if(j == W || pre != board[i][j]) {\n                    if(cons >= K) {\n                        if(cons > 0 && board[i][j-1] != '.') {\n                            changed = true;\n                            // printf(\"char: %c\\n\", board[i][j-1]);\n                            sum += cons * (board[i][j-1] - '0');\n                        }\n                        for(int k=j-cons; k<j; k++) {\n                            board[i][k] = '.';\n                        }\n                    }\n                    cons = 1;\n                }\n                else cons++;\n                pre = board[i][j];\n            }\n        }\n\n        // printf(\"sum = %d\\n\", sum);\n        if(!changed) break;\n        ret += sum * (1 << z);\n        blockfall(board);\n    }\n    return ret;\n}\n\nint main() {\n    cin >> H >> W >> K;\n    vector<string> board(H);\n    for(int i=0; i<H; i++) cin >> board[i];\n\n    int ans = 0;\n    for(int i=0; i<H; i++) {\n        for(int j=0; j<W; j++) {\n            vector<string> n_board = erase_one(board, i, j);\n            ans = max(ans, solve(n_board));\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\n#define N_MAX 40010\n#define INF 1e9\n#define F_MAX 200000\n\nint h, w, k;\n\nint score(vector<queue<int> > vq, int n){\n    vector<queue<int> > vq_next(w);\n    int res = 0;\n    REP(p,h){\n        VI a(w+1);\n        REP(j,w){\n            if (!vq[j].empty()) {\n                a[j] = vq[j].front();\n                vq[j].pop();\n            }\n        }\n        // REP(i,w){\n        //     cout << a[i];\n        // }\n        // cout << endl;\n        REP(i,w){\n            int j = 0;\n            while (a[j+i] == a[i] && j+i < w) j++;\n            if (j >= k) {\n                res += a[i] * j;\n                REP(q,j) a[i+q] = 0;\n            }\n            i += j-1;\n        }\n        REP(i,w){\n            if (a[i] > 0)\n                vq_next[i].push(a[i]);\n        }\n    }\n    res *= (1<<n);\n    if (res == 0) return res;\n    else return res + score(vq_next, n+1);\n}\n\nint main() {\n    cin >> h >> w >> k;\n    VVI c(w,VI(h));\n\n    REP(i,h){\n        string s;\n        cin >> s;\n        REP(j,w) c[j][h-1-i] = s[j] - '0';\n    }\n\n    int ans = 0;\n    REP(ei,w) REP(ej,h){\n        vector<queue<int> > vq(w);\n        REP(i,w) REP(j,h){\n            if (i != ei || j != ej)\n                vq[i].push(c[i][j]);\n        }\n        int res = score(vq, 0);\n        ans = max(ans, res);\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\n#define F first\n#define S second\n\nconst int mx=200010;\nconst ll mod=1e9+7;\n\n  vector<int> a(110),b(110),x(110),y(110);\n  vector<double> r(110);\n\ndouble dis(double A, double B, double C, double D){\n  return sqrt((A-C)*(A-C)+(B-D)*(B-D));\n}\n\nint main() {\n  int h,w,k;\n  cin >> h >> w >> k;\n  vector<vector<int>> c(30, vector<int>(30,0));\n  rep(i,h)rep(j,w) cin >> c[i][j];\n\n  ll ans=0;\n  rep(x,h)rep(y,w){\n    auto tmp = c;\n    c[x][y] = 0;\n    ll base = 0, res = 0;\n    while(1){\n      ll tmp = 0;\n      rep(i,h){\n        int st=0;\n        rep(j,w+1){\n          if(j==w || (j>0&&c[i][j]!=c[i][j])){\n            if(j-st>=k){ for(int p=st; p<j; p++){tmp+=c[i][p]; c[i][p]=0; }  st=j; }\n            st = j;\n          }\n        }\n      }\n      if(base!=0 && tmp==0) break;\n      res += base*tmp;\n      base = (base>0?base*2:1);\n\n      rep(j,w){\n        int pos = h-1;\n        for(int i=h-1; i>=0; i--){\n          if(c[i][j]>0){\n            c[pos][j] = c[i][j];\n            if(pos!=i) c[i][j] = 0;\n            pos--;\n          }\n        }\n      }\n    }\n    ans = max(ans, res);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair< ll, ll > Pi;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep2(i,n) for(int i=1;i<=(n);i++)\n#define rep3(i,i0,n) for(int i=i0;i<(n);i++)\n#define pb push_back\n#define mod 1000000007\nconst ll INF = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nll gcd(ll a, ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b) {return a/gcd(a,b)*b;}\n#define all(x) x.begin(), x.end()\n#define mp make_pair\nbool compare(Pi a, Pi b) {\n    if(a.first != b.first){\n        return a.first < b.first;\n        \n    }else{\n        return a.second < b.second;\n    }\n}\n\nint ctoi(char c) {\n\tif (c >= '0' && c <= '9') {\n\t\treturn c - '0';\n\t}\n\treturn 0;\n}\nbool In_map(ll y,ll x,ll h,ll w){\n    if(y<0 || x<0 || y>=h || x>=w){\n        return 0;\n    }else{\n        return 1;\n    }\n}\nconst vector<ll> dx{1,0,-1,0};\nconst vector<ll> dy{0,1,0,-1};\n\n\n\nint main() {\n\n    ll H,W,K;\n    cin >>H>>W>>K;\n    vector<string> S(H);\n    rep(i,H) cin >>S[i];\n    vector<vector<ll>> R(H,vector<ll>(W));\n    vector<vector<ll>> R2(H,vector<ll>(W));\n    rep(i,H) rep(j,W) R[i][j] = ctoi(S[i][j]);\n    R2 = R;\n    if(K<=1){\n        ll ans = 0;\n        ll min = INF;\n        rep(i,H){\n            rep(j,W){\n                chmin(min,R[i][j]);\n                ans+=R[i][j];\n            }\n        }\n        cout << ans-min<<endl;\n        return 0;\n    }\n\n\n    ll fans = 0;\n    rep(h,H) rep(w,H){\n    ll ans = 0;\n    R=R2;\n    R[h][w] = -1;\n    ll flag = 0;\n    rep(m,H){\n        ll p2 =pow(2,m); \n        rep(j,W){\n            vector<ll> tmp;\n            rep(i,H){\n                if(R[H-1-i][j] != -1){\n                    tmp.pb(R[H-1-i][j]);\n                }\n            }\n            rep(i,H){\n                if(i<tmp.size()){\n                    R[H-1-i][j] = tmp[i];\n                }else{\n                    R[H-1-i][j] = -1;\n                }\n            }\n        }\n        rep(i,H){\n            ll cnt=0;\n            ll p=-1;\n            rep(j,W){\n                if(R[i][j] == p && R[i][j] != -1){\n                    cnt++;\n                    if(j==W-1){\n                        if(cnt>=K){\n                            flag = 1;\n                            ans += R[i][j-1]*cnt*p2;\n                            rep(k,cnt){\n                               // R[i][j-k] = -1;\n                            }\n                        }\n                    }\n                }else{\n                    if(cnt>=K){\n                        flag = 1;\n                        ans += R[i][j-1]*cnt*p2;\n                        rep(k,cnt){\n                            //R[i][j-k-1] = -1;\n                        }\n                    }\n                    cnt = 1;\n                }\n                \n\n                p = R[i][j];\n            }\n        \n        \n        }\n        /*rep(i,H){\n            rep(j,W){\n                cout << R[i][j]<<\" \";\n            }\n            cout <<endl;\n        }*/\n        if(flag ==0) break;\n    }\n\n\n        chmax(fans,ans);\n    }\n\n    cout << fans<<endl;\n    \n    return 0;\n    \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint H, W, K;\nint A[30][30];\nint B[31][31];\n\nvoid move() {\n  for (int x=0; x<W; x++) {\n    int h = 0;\n    for (int y=0; y<H; y++) {\n      if (B[x][y] == 0) continue;\n      B[x][h++] = A[x][y];\n    }\n    for (int y=h; y<H; y++) {\n      B[x][y] = 0;\n    }\n  }\n}\n\nint score() {\n  int s = 0;\n  for (int y=0; y<H; y++) {\n    int l = -1, lc = 0;\n    for (int x=0; x<=W; x++) {\n      if (B[x][y] != 0 && B[x][y] == lc) continue;\n      else {\n        if (x-l >= K) {\n          s += lc*(x-l);\n          for (int xx=l; xx<x; xx++) B[xx][y] = 0;\n        }\n      }\n      lc = B[x][y];\n      l = x;\n    }\n  }\n  return s;\n}\n\nlong long solve(int sx, int sy) {\n  for (int x=0; x<W; x++) {\n    for (int y=0; y<H; y++) {\n      B[x][y] = A[x][y];\n    }\n  }\n  B[sx][sy] = 0;\n  move();\n  long long s = 0;\n  for (int i=0; ; i++) {\n    int f = score();\n    if (f == 0) break;\n    s += (1LL<<i) * f;\n    move();\n  }\n  return s;\n}\n\nint main() {\n  cin >> H >> W >> K;\n  for (int i=0; i<H; i++) {\n    for (int j=0; j<W; j++) {\n      char c;\n      cin >> c;\n      A[j][H-1-i] = (int)(c - '0');\n    }\n  }\n  long long s = 0;\n  for (int x=0; x<W; x++) {\n    for (int y=0; y<H; y++) {\n      s = max(s, solve(x, y));\n    }\n  }\n  cout << s << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint otosu(vector<deque<int>> &c,int h,int w,int k) {\n\n\tint point=0;\n\tfor (int i = 0; i < h; i++) {\n\t\tint j = 0;\n\t\twhile (j <w-1) {\n\t\t\tint rensa = 1;\n\t\t\tif (c[j].at(i)!=0 && c[j].at(i) == c[j+1].at(i)) {\n\n\t\t\t\trensa = 2;\n\n\t\t\t\twhile (j + rensa < w) {\n\t\t\t\t\tif (c[j + rensa].at(i) == c[j].at(i)) {\n\t\t\t\t\t\trensa++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (rensa >= k) {\n\t\t\t\t\tfor (int m = 0; m < rensa; m++) {\n\t\t\t\t\t\tpoint += c[j + m].at(i);\n\t\t\t\t\t\tc[j + m].at(i) = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tj=j+rensa;\n\t\t}\n\t\t\n\t}\n\n\tfor (int j = 0; j < w; j++) {\n\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\tif (c[j].at(i) == -1) {\n\t\t\t\tc[j].erase(c[j].begin() + i);\n\t\t\t\tc[j].push_back(0);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn point;\n}\n\nint main() {\n\n\tint h, w, k;\n\tcin >> h >> w >> k;\n\n\tvector<deque<int>> c(w, deque<int>());\n\tvector<deque<int>> corg(w, deque<int>());\n\n\tint summ=0;\n\tstring in1;\n\tfor (int i =0; i <h; i++) {\n\t\tcin >> in1;\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tc[j].push_front(in1[j]-'0');\n\t\t\tsumm += c[j].front();\n\t\t}\n\t}\n\n\tif (k == 0 || k == 1) {\n\t\tcout << summ << endl;\n\t\treturn 0;\n\t}\n\n\tcorg = c;\n\tint score=0;\n\tfor (int j = 0; j < h; j++) {\n\t\tfor (int i = 0; i < w; i++) {\n\n\t\t\tc = corg;\n\n\t\t\tc[i].erase(c[i].begin() + j);\n\t\t\tc[i].push_back(0);\n\n\t\t\tint scoret = 0;\n\t\t\tint counter = 0;\n\t\t\tint point;\n\t\t\tdo {\n\t\t\t\tpoint = 0;\n\t\t\t\tpoint = otosu(c, h,w, k);\n\t\t\t\tscoret += point * (int)pow(2, counter);\n\t\t\t\tcounter++;\n\t\t\t} while (point != 0);\n\t\t\tscore = max(score, scoret);\n\t\t}\n\t}\n\tcout << score << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(signed i=0;i<n;++i)\n#define repi(n) rep(i,n)\n#define int long long\n#define str string\n#define vint vector<int>\n#define pint pair<int,int>\n#define pb(a) push_back(a)\n#define all(v) v.begin(),v.end()\n#define yn(b) cout<<((b)?\"Yes\":\"No\")<<endl\n#define YN(b) cout<<((b)?\"YES\":\"NO\")<<endl\n#define call(a) for(auto t:a)cout<<t<<\" \";cout<<endl\n#define ENDL printf(\"\\n\");\n#define debg(a) cout<<#a<<\":\"<<a<<endl;\n#define SORT(a) sort(all(a));\n#define INF 1LL<<60\n#define inf INF\n#define out(i) cout<<i<<endl;\n#define allSum(a) accumulate(a.begin(),a.end(),0)\nint min(int a,int b){if(a>b)return b;return a;}\nint max(int a,int b){if(a>b)return a;return b;}\nint h,w,k,result;\npair<int,int> pos(int i,int j,vector<string> board){\n  pint p=make_pair(i,j);\n  if(i==0)return p;\n  if(board[p.first][p.second]!='0')return p;\n  pos(i-1,j,board);\n}\nvector<string> check(vector<string> s,int l,int turn){\n  int cnt=1;\n  rep(i,w-1){\n    pint s1=pos(l,i,s);\n    pint s2=pos(l,i+1,s); \n    if(s[s1.first][s2.second]=='0'){\n      if(cnt>=k)result+=s[s1.first][s1.second]*cnt*turn;\n      for(int j=0;j<cnt;++j){\n        s[s1.first][s1.second]='0';\n      }\n      cnt=1;\n    }\n    else if(s[s1.first][s1.second]==s[s2.first][s2.second])cnt++;\n    else{\n      if(cnt>=k)result+=s[s1.first][s1.second]*cnt*turn;\n      for(int j=0;j<cnt;++j){\n        s[s1.first][s1.second]='0';\n      }\n      cnt=1;\n    }\n  }\n  return s;\n}\nint game(int i,int j,vector<string>board){\n  result=0;\n  int turn=1;\n  bool flag=true;\n  board[i][j]='0';\n  for(int asd=0;asd<100;++asd){\n    vector<string> changed;\n    rep(i,h){\n      changed=check(board,i,turn);\n    }\n    turn++;\n  }\n  return result;\n}\n  \nsigned main(){\n  cin>>h>>w>>k;\n  vector<string> board(h);\n  rep(i,h)cin>>board[i];\n  int ans=-INF;\n  rep(i,h){\n    rep(j,w){\n      int res=game(i,j,board);\n      ans=min(ans,res);\n    }\n  }\n  out(ans);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//四則演算 #pragma GCC target(\"avx\")\n//並列計算 #pragma GCC optimize(\"O3\")\n//条件分岐を減らす #pragma GCC optimize(\"unroll-loops\")\n//浮動小数点演算 #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing VI = vector<int>;\nusing VL = vector<ll>;\nusing VS = vector<string>;\ntemplate<class T> using PQ = priority_queue<T, vector<T>, greater<T>>;\n#define FOR(i,a,n) for(int i=(a);i<(n);++i)\n#define eFOR(i,a,n) for(int i=(a);i<=(n);++i)\n#define rFOR(i,a,n) for(int i=(n)-1;i>=(a);--i)\n#define erFOR(i,a,n) for(int i=(n);i>=(a);--i)\n#define each(i, a) for(auto &i : a)\n#define SORT(a) sort(a.begin(),a.end())\n#define rSORT(a) sort(a.rbegin(),a.rend())\n#define fSORT(a,f) sort(a.begin(),a.end(),f)\n#define all(a) a.begin(),a.end()\n#define out(y,x) ((y)<0||h<=(y)||(x)<0||w<=(x))\n#define tp(a,i) get<i>(a)\n#define line cout << \"-----------------------------\\n\" \n#define ENDL(i,n) ((i) == (n) - 1 ? \"\\n\" : \" \")\n#define stop system(\"pause\")\nconstexpr ll INF = 1000000000;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr ll mod = 1000000007;\nconstexpr ll MOD = 998244353;\nconstexpr ld eps = 1e-10;\nconstexpr ld pi = 3.1415926535897932;\ntemplate<class T>inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T>inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; }return false; }\ninline void init() { cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); }\ntemplate<class T>inline istream& operator>>(istream& is, vector<T>& v) { for (auto& a : v)is >> a; return is; }\ntemplate<class T>inline istream& operator>>(istream& is, deque<T>& v) { for (auto& a : v)is >> a; return is; }\ntemplate<class T, class U>inline istream& operator>>(istream& is, pair<T, U>& p) { is >> p.first >> p.second; return is; }\ntemplate<class T>inline vector<T> vec(size_t a) { return vector<T>(a); }\ntemplate<class T>inline vector<T> defvec(T def, size_t a) { return vector<T>(a, def); }\ntemplate<class T, class... Ts>inline auto vec(size_t a, Ts... ts) { return vector<decltype(vec<T>(ts...))>(a, vec<T>(ts...)); }\ntemplate<class T, class... Ts>inline auto defvec(T def, size_t a, Ts... ts) { return vector<decltype(defvec<T>(def, ts...))>(a, defvec<T>(def, ts...)); }\ntemplate<class T>inline void print(const T& a) { cout << a << \"\\n\"; }\ntemplate<class T, class... Ts>inline void print(const T& a, const Ts&... ts) { cout << a << \" \"; print(ts...); }\ntemplate<class T>inline void print(const vector<T>& v) { for (int i = 0; i < v.size(); ++i)cout << v[i] << (i == v.size() - 1 ? \"\\n\" : \" \"); }\ntemplate<class T>inline void print(const vector<vector<T>>& v) { for (auto& a : v)print(a); }\ninline string reversed(const string& s) { string t = s; reverse(all(t)); return t; }\n\nint main() {\n    init();\n\n    int h, w, k; cin >> h >> w >> k;\n    if (4 <= k) {\n        print(0);\n        return 0;\n    }\n    VS s(h); cin >> s;\n    VS t = s;\n\n    function<void(int)> drop = [&](int x)->void {\n        int b = h - 1;\n        rFOR(y, 0, h)if (s[y][x] != 'x') {\n            swap(s[y][x], s[b][x]);\n            --b;\n        }\n    };\n\n    function<int(int, int)> solve = [&](int sy, int sx)->int {\n        s[sy][sx] = 'x';\n        drop(sx);\n        int res = 0;\n        for (int i = 0;; ++i) {\n            bool m = false;\n            FOR(y, 0, h)FOR(x, 0, w - k + 1) {\n                char c = s[y][x];\n                if (c == 'x')continue;\n                int p = 1;\n                for (; x + p < w && s[y][x + p] == c; ++p);\n                if (k <= p) {\n                    m = true;\n                    res += (1 << i) * (c - '0')* p;\n                    FOR(q, 0, p)s[y][x + q] = 'x';\n                    x += p;\n                }\n            }\n            if (m)FOR(x, 0, w)drop(x);\n            else break;\n        }\n        return res;\n    };\n\n    int ans = 0;\n    FOR(y, 0, h)FOR(x, 0, w) {\n        s = t;\n        chmax(ans, solve(y, x));\n    }\n    print(ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <set>\n#include <algorithm>\n\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst long long INF = 1LL<<60;\nconst double PI=3.14159265358979323846;\nconst int NMAX=100005;\nusing namespace std;\n\n\n\nint main(){\n    int h, w, k;\n    cin >> h >> w >> k;\n    vector<vector<int> > c(w,vector<int>(h));\n    for(int i = h-1; i >= 0; i--){\n        for(int j = 0; j < w; j++){\n            char tmp;\n            cin >> tmp;\n            c[j][i] = tmp-'0';\n        }\n    }\n\n    ll ans = 0;\n    for(int i = 0; i < h-1; i++){\n        for(int j = 0; j < w; j++){\n            // first\n            auto d = c;\n            ll cnt = 0;\n            ll ml = 1;\n            d[j].erase(d[j].begin()+i);\n\n            bool changed = true;\n            while(changed){\n                changed = false;\n                for(int l = h-1; l >= 0; l--){\n                    ll col = 0;\n                    ll num = -1;\n                    ll sw = -1;\n                    for(int m = 0; m < w; m++){\n                        if(d[m].size() < l+1){\n                            if(col >= k){\n                                for(int p = sw; p < m-1; p++){\n                                    d[p].erase(d[p].begin()+l);\n                                }\n                                cnt += num*col*ml;\n                                changed = true;\n                            }\n                            col = 0;\n                            num = -1;\n                            sw = -1;\n                            continue;\n                        } else {\n                            if(d[m][l] == num){\n                                col++;\n                                continue;\n                            } else {\n                                if(col >= k){\n                                    for(int p = sw; p < m-1; p++){\n                                        d[p].erase(d[p].begin()+l);\n                                    }\n                                    cnt += num*col*ml;\n                                    changed = true;\n                                }\n                                col = 1;\n                                num = d[m][l];\n                                sw = m;\n                            }\n                        }\n                    }\n                    \n                    if(col >= k){\n                        for(int p = sw; p < w; p++){\n                            d[p].erase(d[p].begin()+l);\n                        }\n                        cnt += num*col*ml;\n                        changed = true;\n                    }\n                }\n                ml *= 2;\n            }\n            ans = max(ans, cnt);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint h,w,k;\n\nint calc(vector<string> B){\n\tint res=0;\n\tfor(int t=0;;t++){\n\t\tbool end;\n\t\tdo{\n\t\t\tend=true;\n\t\t\tfor(int i=h-1;i>0;i--) rep(j,w) if(B[i][j]=='0' && B[i-1][j]!='0') {\n\t\t\t\tB[i][j]=B[i-1][j];\n\t\t\t\tB[i-1][j]='0';\n\t\t\t\tend=false;\n\t\t\t}\n\t\t}while(!end);\n\n\t\tbool found=false;\n\t\trep(i,h) rep(j,w-k+1) if(B[i][j]!='0') {\n\t\t\tint len;\n\t\t\tfor(len=1;j+len<w;len++) if(B[i][j+len]!=B[i][j]) break;\n\t\t\tif(len>=k){\n\t\t\t\tres+=(1<<t)*(B[i][j]-'0')*len;\n\t\t\t\trep(d,len) B[i][j+d]='0';\n\t\t\t\tj+=len-1;\n\t\t\t\tfound=true;\n\t\t\t}\n\t\t}\n\t\tif(!found) break;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin>>h>>w>>k;\n\tvector<string> B(h);\n\trep(i,h) cin>>B[i];\n\n\tint ans=0;\n\trep(i,h) rep(j,w) {\n\t\tchar c=B[i][j];\n\t\tB[i][j]='0';\n\t\tans=max(ans,calc(B));\n\t\tB[i][j]=c;\n\t}\n\tcout<<ans<<'\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define H 30\n#define W 30\n\nint height, width, nChain; \nint cellTmp[H][W];\nint disappear[H][W];                          \n\nbool chainSearch(){\n    for (int i = 0; i < height; i++){\n        for (int j = 0; j < width; j++){\n            disappear[i][j] = 0;\n        }\n    }\n    \n    bool isDisappeared = false;\n    for (int i = 0; i < height; i++){\n        for (int j = 0; j < width-1; j++){\n            if (disappear[i][j]){\n                continue;\n            }\n            int nowNum = cellTmp[i][j];\n            int compNum = cellTmp[i][j+1];\n            int cnt = 1;\n            while (nowNum == compNum && nowNum > 0){\n                cnt++;\n                if (j+cnt < width){\n                    compNum = cellTmp[i][j+cnt];\n                }\n                else{\n                    break;\n                }\n            }\n            if (cnt >= nChain){\n                for (int k = j; k < j+cnt; k++){\n                    disappear[i][k] = 1;\n                }\n                isDisappeared = true;\n            }\n        }\n    }\n    return isDisappeared;\n}\n\n// 消すのも同時にやってるのビミョー\nlong addScore(){\n    int score = 0;\n    for (int i = 0; i < height; i++){\n        for (int j = 0; j < width; j++){\n            if (disappear[i][j]){\n                score += cellTmp[i][j];\n                cellTmp[i][j] = 0;\n            }\n        }\n    }\n    return score;\n}\n\nvoid fallStone(){\n    for (int i = height-1; i >= 0; i--){\n        for (int j = 0; j < W; j++){\n            if (cellTmp[i][j] != 0){\n                continue;\n            }\n            for (int k = i-1; k >= 0 ; k--){\n                if (cellTmp[k][j] != 0){\n                    swap(cellTmp[k][j], cellTmp[i][j]);\n                    break;\n                }\n            }\n        }\n    }\n    return;\n}\n\n\nint main() {\n    int cell[H][W];\n    cin >> height >> width >> nChain; \n    for (int i = 0; i < height; i++){\n        for (int j = 0; j < width; j++){\n            char c;\n            cin >> c;\n            cell[i][j] = atoi(&c);\n        }\n    }\n    \n    long scoreMax = 0;\n    for (int i = 1; i < height; i++){\n        for (int j = 0; j < width; j++){\n            for (int i1 = 0; i1 < height; i1++){\n                for (int j1 = 0; j1 < width; j1++){\n                    cellTmp[i1][j1] = cell[i1][j1];\n                }\n            }\n            long score = 0;\n            int nDisap = 0;\n            cellTmp[i][j] = 0;\n            fallStone();\n            bool isDisappear = chainSearch();\n            while(isDisappear){\n                score += addScore() * pow(2,nDisap);\n                fallStone();\n                isDisappear = chainSearch();\n                nDisap++;\n            }\n            scoreMax = (scoreMax < score) ? score : scoreMax;\n        }\n    }\n    \n    cout << scoreMax << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC diagnostic ignored \"-Wunused-variable\" \n#include <bits/stdc++.h>\nusing namespace std;\n\n#define BOOST\n#ifdef BOOST\n#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/multiprecision/cpp_dec_float.hpp>\n#include <boost/range/adaptor/reversed.hpp>\nusing namespace boost;\nusing ml = boost::multiprecision::cpp_int;\nusing md = boost::multiprecision::cpp_dec_float_100;\n#define forir(i, ...) if(ll i=(ll)v.size())for(__VA_ARGS__)if(i--,1)\n#define eachr(i, e, c) forir(i, auto &&e: adaptors::reverse(c))\n#endif\n\n/***** type *****/\nusing ll = long long;\nusing ld = long double;\nusing pll = pair<long long, long long>;\ntemplate <class T> using vt = vector<T>;\ntemplate <class T> using vvt = vector<vector<T>>;\ntemplate <class T> using vvvt = vector<vector<vector<T>>>;\n/***** define *****/\n#define all(c) (c).begin(), (c).end()            // begin to end\n#define coutld cout << fixed << setprecision(10) // cout double\n#define output(x) do{cout<<x<<endl;exit(0);}while(0)\n#define rep(i, b, e) for (ll i = b; i < e; i++)  // repeat\n#define repr(i, b, e) for (ll i = b; e < i; i--) // repeat reverse\n#define fori(i, ...) if (ll i = -1) for(__VA_ARGS__) if (i++, 1)\n#define each(i, e, c) fori (i, auto&& e: c)      // for each\n/***** const value *****/\n#define llong_max 9223372036854775807            // 9 * 10^18\n#define ldbl_max 1.79769e+308                    // 1.7 * 10^308\n#define pi 3.1415926535897932                    // 3.14 ...\n/***** lambda *****/\nauto Ceil = [] // if (a % b != 0) return a / b + 1;\n(auto x) { return (ll)ceil(x); };\nauto Count = [] // long long count value\n(auto b, auto e, auto x) { return (ll)count(b, e, x); };\nauto CtoL = [] // char to number\n(auto c) { return (ll)c - (ll)'0'; };\nauto LtoC = [] // number to char\n(auto n) { return (char)('0' + n); };\nauto Pow = [] // long long pow\n(auto a, auto b) { return (ll)pow(a, b); };\nauto Pow2 = [] // long long pow2\n(auto n) { return (1LL << n); };\nauto Pow10 = [] // long long pow10\n(auto n) { return (ll)pow(10, n); };\nauto Size = []  // long long collection size\n(auto& c) { return (ll)(c).size(); };\nauto Sum = [] // long long accumulate\n(auto b, auto e) { return accumulate(b, e, 0LL); };\n\n/***** template *****/\ntemplate <class T> void MakeVVT\n(ll ys, ll xs, vvt<T>& v, T fill = T())\n{\t// vector<vector<T>> resize + fill\n\tv.resize(ys); rep(y, 0, ys) v[y].resize(xs, fill);\n}\ntemplate <class T> void MakeVVVT\n(ll zs, ll ys, ll xs, vvvt<T>& v, T fill = T())\n{\t// vector<vector<vector<T>>> resize + fill\n\tv.resize(zs); rep(z, 0, zs) MakeVVT(ys, xs, v[z], fill);\n}\ntemplate <class T> void InputVT\n(ll xs, vt<T>& v, T fix = T())\n{\t// input vector<T> (T != struct) + fix\n\tv.resize(xs); rep(i, 0, xs) { cin >> v[i]; v[i] += fix; }\n}\ntemplate <class T> void InputVVT\n(ll ys, ll xs, vvt<T>& v, T fix = T())\n{\t// input vector<vector<T>> (T != struct) + fix\n\tMakeVVT(ys, xs, v, fix);\n\trep(y, 0, ys) rep(x, 0, xs) { cin >> v[y][x]; v[y][x] += fix; }\n}\ntemplate <class T> void InputVVVT\n(ll zs, ll ys, ll xs, vvvt<T>& v, T fix = T())\n{\t// input vector<vector<vector<T>>> (T != struct) + fix\n\tv.resize(zs); rep(z, 0, zs) InputVVT(ys, xs, v[z], fix);\n}\n\n/**************************************/\n/********** BEGIN OF NYA LIB **********/\n/**************************************/\n\nnamespace NyaGadget {}\n\nnamespace NyaGadget\n{\n\t/*** ランレングス圧縮ライブラリ ***/\n\n\ttemplate <class T> struct RunLengthEncodingResult\n\t{\t// ランレングス圧縮の結果を格納する構造体\n\t\tlong long begin = 0; // 区間開始位置\n\t\tlong long end = 0;   // 区間終了位置\n\t\tstd::vector<T> sub;  // 区間データ\n\t};\n\n\ttemplate <> struct RunLengthEncodingResult<std::string>\n\t{\t// ランレングス圧縮の結果を格納する構造体\n\t\tlong long begin = 0; // 区間開始位置\n\t\tlong long end = 0;   // 区間終了位置\n\t\tstd::string sub;     // 区間データ\n\t};\n\n\tstruct DS_NyaaRLE\n\t{\n\t\t/**\n\t\t@brief 文字列のランレングス圧縮\n\t\t@param s 圧縮する文字列\n\t\t@param res 圧縮結果\n\t\t**/\n\t\tDS_NyaaRLE(std::string& s, std::vector<RunLengthEncodingResult<std::string>>& res)\n\t\t{\n\t\t\tres.push_back({ 0, 0, \"\" });\n\t\t\tfor (long long i = 0; i < (long long)s.size(); i++)\n\t\t\t{\n\t\t\t\tif (i == (long long)s.size() - 1)\n\t\t\t\t{\n\t\t\t\t\tres.back().end = i + 1;\n\t\t\t\t\tres.back().sub = s.substr(res.back().begin, i + 1 - res.back().begin);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (s[i] != s[i + 1])\n\t\t\t\t{\n\t\t\t\t\tres.back().end = i + 1;\n\t\t\t\t\tres.back().sub = s.substr(res.back().begin, i + 1 - res.back().begin);\n\t\t\t\t\tres.push_back({ i + 1, 0, \"\" });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t@brief 配列のランレングス圧縮\n\t\t@param v 圧縮する配列\n\t\t@param res 圧縮結果\n\t\t**/\n\t\ttemplate <class T> DS_NyaaRLE(std::vector<T>& v, std::vector<RunLengthEncodingResult<T>>& res)\n\t\t{\n\t\t\tres.push_back({ 0, 0, std::vector<T>() });\n\t\t\tfor (long long i = 0; i < (long long)v.size(); i++)\n\t\t\t{\n\t\t\t\tif (i == (long long)v.size() - 1)\n\t\t\t\t{\n\t\t\t\t\tres.back().end = i + 1;\n\t\t\t\t\tfor (long long j = res.back().begin; j < i + 1; j++) res.back().sub.push_back(v[j]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!IsSame(v[i], v[i + 1]))\n\t\t\t\t{\n\t\t\t\t\tres.back().end = i + 1;\n\t\t\t\t\tfor (long long j = res.back().begin; j < i + 1; j++) res.back().sub.push_back(v[j]);\n\t\t\t\t\tres.push_back({ i + 1, 0, std::vector<T>() });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttemplate <class T> bool IsSame(T& l, T& r)\n\t\t{\t// lとrが同値かどうか調べる\n\t\t\treturn l == r;\n\t\t}\n\t};\n}\n\n/**************************************/\n/*********** END OF NYA LIB ***********/\n/**************************************/\n\nusing namespace NyaGadget;\n//using mll = NT_ModLL< 1000000007 >;\n//using mll = ModLL< 998244353 >;\n\nll Delete(ll y, ll x, ll H, ll W, const vvt<ll>& c, ll K)\n{\n\tll res = 0;\n\n\tll count = 0;\n\tvvt<ll> test = c;\n\ttest[x][y] = 0;\n\twhile (1)\n\t{\n\t\tvvt<ll> nyaa(W);\n\t\trep(xx, 0, W) rep(yy, 0, H) if (test[xx][yy] != 0) nyaa[xx].push_back(test[xx][yy]);\n\t\trep(xx, 0, W) test[xx].clear();\n\t\ttest = nyaa;\n\t\trep(xx, 0, W) test[xx].resize(H);\n\n\t\tll score = 0;\n\t\trep(yy, 0, H)\n\t\t{\n\t\t\tvt<ll> line;\n\t\t\trep(x, 0, W) line.push_back(test[x][yy]);\n\t\t\tstd::vector<RunLengthEncodingResult<ll>> res;\n\t\t\tDS_NyaaRLE rle(line, res);\n\t\t\teach(i, e, res)\n\t\t\t{\n\t\t\t\tif (e.sub[0] == 0) continue;\n\t\t\t\tif (K <= Size(e.sub))\n\t\t\t\t{\n\t\t\t\t\tscore += Pow2(count) * e.sub[0] * Size(e.sub);\n\t\t\t\t\trep(xx, e.begin, e.end) test[xx][yy] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (score == 0) break;\n\t\tres += score;\n\t\tcount++;\n\t}\n\treturn res;\n}\n\nint main(void)\n{\n\tll H, W, K; cin >> H >> W >> K;\n\tvvt<ll> c; MakeVVT(W, H, c);\n\trep(y, 0, H) rep(x, 0, W)\n\t{\n\t\tchar test; cin >> test;\n\t\tc[x][y] = CtoL(test);\n\t}\n\trep(x, 0, W) reverse(all(c[x]));\n\n\tll ans = 0;\n\trep(y, 0, H) rep(x, 0, W)\n\t{\n\t\tans = max(ans, Delete(y, x, H, W, c, K));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\ntypedef long long ll;\nconst int MOD=1e9+7;\n\nconst int MAX_H=30,MAX_W=30;\n\nint H,W,K;\nchar C[MAX_H][MAX_W+1];\n\nchar temp[MAX_H][MAX_W+1];\n\nint solve(int h,int w){\n\tbool flg=false;\n\tint res=0;\n\tint b=1;\n\tmemcpy(temp,C,sizeof(C));\n\tfor(int i=h;i>0;i--){\n\t\ttemp[i][w]=temp[i-1][w];\n\t}\n\ttemp[0][w]='0';\n\tdo{\n\t\tflg=false;\n//\t\tfprintf(stderr,\"%d\\n\",b);\n\t\tREP(y,H){\n\t\t\tfor(int x=0;x<W;){\n//\t\t\t\tfprintf(stderr,\"%d %d\\n\",x,y);\n\t\t\t\tif (temp[y][x]=='0'){\n\t\t\t\t\tx++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint l,u;\n\t\t\t\tl=x;\n\t\t\t\tu=l+1;\n\t\t\t\twhile(u<W && temp[y][u]==temp[y][l]) u++;\n\t\t\t\tif (u-l>=K){\n\t\t\t\t\tres+=(temp[y][l]-'0')*(u-l)*b;\n\t\t\t\t\tFOR(i,l,u){\n\t\t\t\t\t\ttemp[y][i]='0';\n\t\t\t\t\t}\n\t\t\t\t\tflg=true;\n\t\t\t\t}\n\t\t\t\tx=u;\n\t\t\t}\n\t\t}\n\t\tREP(x,W){\n\t\t\tint a=H-1;\n\t\t\tREP(y,H){\n\t\t\t\tif (temp[H-y-1][x]!='0'){\n\t\t\t\t\ttemp[a--][x]=temp[H-y-1][x];\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(y,a+1){\n\t\t\t\ttemp[y][x]='0';\n\t\t\t}\n\t\t}\n\t\tb*=2;\n\t}while(flg);\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%d %d %d\",&H,&W,&K);\n\tREP(i,H){\n\t\tscanf(\"%s\",C[i]);\n\t}\n\tint ans=0;\n\tFOR(y,1,H){\n\t\tREP(x,W){\n\t\t\tans=max(ans,solve(y,x));\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n    Problem 93\n    https://atcoder.jp/contests/s8pc-3/tasks/s8pc_3_b\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n/* typedef */\ntypedef long long ll;\ntypedef pair<int, int> pii;\n/* class */\nclass pazzle {\n    public:\n    int H, W, K;\n    ll ans = 0;\n    vector<vector<int> > v;\n    pazzle (int H, int W, int K, vector<vector<int> > v)\n    : H(H), W(W), K(K), v(v) {}\n    bool del() {\n        int ret = false;\n        for (int i = 0; i < H; i++) {\n            int r = 0;\n            for (int l = 0; l < W; l++) {\n                int tmp = v[i][r];\n                while (v[i][r] == -1) {\n                    r++;\n                    l++;\n                }\n                while (v[i][r] == v[i][r + 1]){\n                    r++;\n                    tmp += v[i][r];\n                }\n                if (r - l + 1>= K) {\n                    for (int k = l; k <= r; k++) v[i][k] = -1;\n                    ans += tmp;\n                    ret = true;\n                }\n                l = r;\n                r++;\n            }\n        }\n        return ret;\n    }\n    void move() {\n        for (int i = 0; i < W; i++) {\n            for (int j = H - 1; j > 0; j--) {\n                if (v[j][i] == -1) {\n                    int k = j - 1;\n                    while (v[k][i] == -1 && k > 0) k--;\n                    if (v[k][i] != -1) swap(v[k][i], v[j][i]);\n                }\n            }\n        }\n    }\n    void printPoint() {\n        cout << ans << '\\n';\n    }\n    ll gameStart() {\n        ll ret = 0;\n        move();\n        for (int i = 0; del(); i++){\n            move();\n            ret += pow(2, i) * ans;\n            ans = 0;\n        }\n        return ret;\n    }\n};\n/* constant */\n/* global variables */\n/* function */\n/* main */\nint main(){\n    int H, W, K;\n    cin >> H >> W >> K;\n    vector<string> vs(H);\n    for (int i = 0; i < H; i++) cin >> vs[i];\n    vector<vector<int> > v(H, vector<int> (W + 1, -2));\n    for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) v[i][j] = vs[i][j] - '0';\n    ll ans = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int tmp = v[i][j];\n            v[i][j] = -1;\n            pazzle P = pazzle(H, W, K, v);\n            ans = max(ans, P.gameStart());\n            v[i][j] = tmp;\n        }\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef long long lint;\ntypedef vector<int>vi;\ntypedef pair<int,int>pii;\n#define rep(i,n)for(int i=0;i<(int)(n);++i)\n\nint f(vector<vi>c,int k){\n  int h=c.size();\n  int w=c[0].size();\n  int p=1;\n  bool ch=1;\n  int ans=0;\n  while(ch){\n    ch=0;\n    if (0){\n      cerr<<\"p=\"<<p<<\" ans=\"<<ans<<endl;\n      rep(i,h){\n\trep(j,w)cerr<<\" \"<<c[i][j];\n\tcerr<<endl;\n      }\n      cerr<<endl;\n    }\n    //fall\n    rep(i,w){\n      vi col;\n      for(int j=h-1;j>=0;--j){\n\tif(c[j][i]!=0)\n\t  col.push_back(c[j][i]);\n      }\n      rep(j,h){\n\tint nv=j<col.size()?col[j]:0;\n\tif(c[h-1-j][i]!=nv)ch=1;\n\tc[h-1-j][i]=nv;\n      }\n    }\n    vector<vector<bool> > dis(h,vector<bool>(w));\n    rep(i,h){\n      int con=0;\n      rep(j,w+1){\n\tif(j==0||j==w||c[i][j]!=c[i][j-1]){\n\t  if(con>=k){\n\t    rep(l,con){\n\t      dis[i][j-l-1]=true;\n\t      ans+=p*c[i][j-l-1];\n\t    }\n\t  }\n\t  con=0;\n\t}\n\tif(j==w)break;\n\tcon++;\n      }\n      rep(j,w)if(dis[i][j])c[i][j]=0;\n    }\n    p*=2;\n  }\n  return ans;\n}\n\nint main(){\n  int h,w,k;\n  cin>>h>>w>>k;\n  vector<vi>b(h,vi(w));\n  rep(i,h){\n    string s;\n    cin>>s;\n    rep(j,w){\n      b[i][j]=s[j]-'0';\n    }\n  }\n  int m=0;\n  rep(i,h){\n    rep(j,w){\n      vector<vi>c(b);\n      c[i][j]=0;\n      m=max(m,f(c,k));\n    }\n  }\n  cout<<m<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\nconstexpr ll INF = 9e18;\nconstexpr int inf = 1e9;\nconst double INFD = 1e100;\nconst ll mod = 1000000007;\nconst double PI = 3.1415926535897932384626433832795028841971;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n};\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n};\n\n// intやllをstringに変換\ntemplate<typename T> inline string toString(const T &a){\n  ostringstream oss;\n  oss << a;\n  return oss.str();\n};\n// ----------------------------------------------------------------------------\n\nint main(){\n  int H,W,K;\n  cin >> H >> W >> K;\n  vector<string> S(H);\n  for(int i=0; i<H; i++){\n    cin >> S[i];\n  }\n  int ans = 0;\n  for(int h=0; h<H; h++){\n    for(int w=0; w<W; w++){\n      vector<string> G;\n      G = S;\n      int res = 0;\n      G[h][w] = '#';\n      for(int i=H-1; i>=0; i--){\n        for(int j=0; j<W; j++){\n          if(G[i][j]=='#'){\n            int temp = i;\n            while(temp>=0 && G[temp][j]=='#'){\n              temp--;\n            }\n            if(temp != -1){\n              swap(G[temp][j],G[i][j]);\n            }\n          }\n        }\n      }\n      int cnt = 1;\n      while(1){\n        int sum = 0;\n        bool changed = false;\n        for(int i=0; i<H; i++){\n          for(int j=0; j<W; j++){\n            if(G[i][j] == '#') continue;\n            if(G[i].substr(j,K) == string(K,G[i][j])){\n              changed = true;\n              int pos = j+1;\n              while(pos<W && G[i][pos]==G[i][j]){\n                sum += G[i][j] - '0';\n                G[i][pos] = '#';\n                pos++;\n              }\n              sum += G[i][j] - '0';\n              G[i][j] = '#';\n            }\n          }\n        }\n        for(int i=H-1; i>=0; i--){\n          for(int j=0; j<W; j++){\n            int temp = i;\n            while(temp>=0 && G[temp][j]=='#'){\n              temp--;\n            }\n            if(temp != -1){\n              swap(G[temp][j],G[i][j]);\n            }\n          }\n        }\n        if(!changed){\n          break;\n        }\n        res += sum * cnt;\n        cnt *= 2;\n      }\n      // cout << endl;\n      // for(int i=0; i<H; i++){\n      //   for(int j=0; j<W; j++){\n      //     cout << G[i][j];\n      //   }\n      //   cout << endl;\n      // }\n      chmax(ans,res);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair< ll, ll > Pi;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep2(i,n) for(int i=1;i<=(n);i++)\n#define rep3(i,i0,n) for(int i=i0;i<(n);i++)\n#define pb push_back\n#define mod 1000000007\nconst ll INF = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nll gcd(ll a, ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b) {return a/gcd(a,b)*b;}\n#define all(x) x.begin(), x.end()\n#define mp make_pair\nbool compare(Pi a, Pi b) {\n    if(a.first != b.first){\n        return a.first < b.first;\n        \n    }else{\n        return a.second < b.second;\n    }\n}\n\nint ctoi(char c) {\n\tif (c >= '0' && c <= '9') {\n\t\treturn c - '0';\n\t}\n\treturn 0;\n}\nbool In_map(ll y,ll x,ll h,ll w){\n    if(y<0 || x<0 || y>=h || x>=w){\n        return 0;\n    }else{\n        return 1;\n    }\n}\nconst vector<ll> dx{1,0,-1,0};\nconst vector<ll> dy{0,1,0,-1};\n\n\n\nint main() {\n\n    ll H,W,K;\n    cin >>H>>W>>K;\n    vector<string> S(H);\n    rep(i,H) cin >>S[i];\n    vector<vector<ll>> R(H,vector<ll>(W));\n    vector<vector<ll>> R2(H,vector<ll>(W));\n    rep(i,H) rep(j,W) R[i][j] = ctoi(S[i][j]);\n    R2 = R;\n    if(K<=1){\n        ll ans = 0;\n        ll min = INF;\n        rep(i,H){\n            rep(j,W){\n                chmin(min,R[i][j]);\n                ans+=R[i][j];\n            }\n        }\n        cout << ans-min<<endl;\n        return 0;\n    }\n\n\n    ll fans = 0;\n    rep(h,H) rep(w,H){\n    ll ans = 0;\n    R=R2;\n    R[h][w] = -1;\n    ll flag = 0;\n    rep(m,H){\n        ll p2 =pow(2,m); \n        rep(j,W){\n            vector<ll> tmp;\n            rep(i,H){\n                if(R[H-1-i][j] != -1){\n                    tmp.pb(R[H-1-i][j]);\n                }\n            }\n            rep(i,H){\n                if(i<tmp.size()){\n                    R[H-1-i][j] = tmp[i];\n                }else{\n                    R[H-1-i][j] = -1;\n                }\n            }\n        }\n        rep(i,H){\n            ll cnt=0;\n            ll p=-1;\n            rep(j,W){\n                if(R[i][j] == p && R[i][j] != -1){\n                    cnt++;\n                    if(j==W-1){\n                        if(cnt>=K){\n                            flag = 1;\n                            ans += R[i][j-1]*cnt*p2;\n                            rep(k,cnt){\n                                R[i][j-k] = -1;\n                            }\n                        }\n                    }\n                }else{\n                    if(cnt>=K){\n                        flag = 1;\n                        ans += R[i][j-1]*cnt*p2;\n                        rep(k,cnt){\n                            //R[i][j-k-1] = -1;\n                        }\n                    }\n                    cnt = 1;\n                }\n                \n\n                p = R[i][j];\n            }\n        \n        \n        }\n        /*rep(i,H){\n            rep(j,W){\n                cout << R[i][j]<<\" \";\n            }\n            cout <<endl;\n        }*/\n        if(flag ==0) break;\n    }\n\n\n        chmax(fans,ans);\n    }\n\n    cout << fans<<endl;\n    \n    return 0;\n    \n\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nconst int nax=37;\n\nint n, m, k;\n\nchar wcz[nax];\n\nstruct plan\n{\n\tvector <int> wek[nax];\n\tint kogo[nax][nax];\n\tplan()\n\t{\n\t\tczys();\n\t}\n\tvoid czys()\n\t{\n\t\tfor (int i=0; i<nax; i++)\n\t\t\tfor (int j=0; j<nax; j++)\n\t\t\t\tkogo[i][j]=0;\n\t}\n\tll oznacz()\n\t{\n\t\tll ret=0;\n\t\tfor (int i=0; i<nax; i++)\n\t\t{\n\t\t\tint ost=-1;\n\t\t\tint ile=0;\n\t\t\tfor (int j=0; j<nax; j++)\n\t\t\t{\n\t\t\t\tint x=-1;\n\t\t\t\tif ((int)wek[j].size()>i)\n\t\t\t\t\tx=wek[j][i];\n\t\t\t\tif (x==-1)\n\t\t\t\t{\n\t\t\t\t\tost=-1;\n\t\t\t\t\tile=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (x!=ost)\n\t\t\t\t\t{\n\t\t\t\t\t\tile=1;\n\t\t\t\t\t\tost=x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tile++;\n\t\t\t\t\t\tif (ile>=k)\n\t\t\t\t\t\t\tkogo[j][i]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tost=-1;\n\t\t\tile=0;\n\t\t\tfor (int j=nax-1; j>=0; j--)\n\t\t\t{\n\t\t\t\tint x=-1;\n\t\t\t\tif ((int)wek[j].size()>i)\n\t\t\t\t\tx=wek[j][i];\n\t\t\t\tif (x==-1)\n\t\t\t\t{\n\t\t\t\t\tost=-1;\n\t\t\t\t\tile=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (x!=ost)\n\t\t\t\t\t{\n\t\t\t\t\t\tile=1;\n\t\t\t\t\t\tost=x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tile++;\n\t\t\t\t\t\tif (ile>=k)\n\t\t\t\t\t\t\tkogo[j][i]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i=0; i<nax; i++)\n\t\t\tfor (int j=0; j<(int)wek[i].size(); j++)\n\t\t\t\tret+=kogo[i][j]*wek[i][j];\n\t\treturn ret;\n\t}\n\tvoid puszuj()\n\t{\n\t\tfor (int i=0; i<nax; i++)\n\t\t{\n\t\t\tvector <int> wez;\n\t\t\tfor (int j=0; j<(int)wek[i].size(); j++)\n\t\t\t\tif (!kogo[i][j])\n\t\t\t\t\twez.push_back(wek[i][j]);\n\t\t\twek[i]=wez;\n\t\t}\n\t\tczys();\n\t}\n};\n\nll wyn;\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tplan start;\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tscanf(\"%s\", wcz);\n\t\tfor (int j=0; j<m; j++)\n\t\t\tstart.wek[j].push_back(wcz[j]-'0');\n\t}\n\tfor (int i=0; i<m; i++)\n\t\treverse(start.wek[i].begin(), start.wek[i].end());\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tfor (int j=0; j<m; j++)\n\t\t{\n\t\t\tplan wez=start;\n\t\t\twez.kogo[j][i]=1;\n\t\t\twez.puszuj();\n\t\t\tll ter=0;\n\t\t\tfor (int h=0; 1; h++)\n\t\t\t{\n\t\t\t\tll x=wez.oznacz();\n\t\t\t\tif (!x)\n\t\t\t\t\tbreak;\n\t\t\t\tter+=(x<<h);\n\t\t\t\twez.puszuj();\n\t\t\t}\n\t\t\twyn=max(wyn, ter);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n\n#define H 31\n#define W 31\n#define MAX(x,y) ((x)<(y)?(y):(x))\n#define MIN(x,y) ((x)>(y)?(y):(x))\n\ninline void remove(int game[H][W], int pt_h, int pt_w){\n  game[pt_h][pt_w] = -1;\n}\n\ninline void move(int game[H][W], int h, int w){\n  //-1 means it is deleted space.\n\n  for(int j=0; j<w; j++){\n    for(int i=h-1; i>0; i--){\n      if(game[i][j] == -1){\n\tint k = i-1;\n\twhile(true){\n\t  if(game[k][j]==-1 and k>0) k--;\n\t  else                       break;\n\t}\n\tstd::swap(game[i][j], game[k][j]);\n      }\n    }\n  }\n}\n\ninline void print(int game[H][W], int h, int w){\n  for(int i=0; i<h; i++){\n    for(int j=0; j<w; j++){\n      std::cout << \" \" << game[i][j];\n    }\n    std::cout << std::endl;\n  }\n}\n\ninline int earn(int game[H][W], int h, int w, int k, int num_step){\n  int earn_score = 0;\n  int now = -1, count = 0;\n  for(int i=0; i<h; i++){\n    now = -1, count = 0;\n    for(int j=0; j<w; j++){\n      if(game[i][j] != now){\n\tif(count >= k and now != -1){\n\t  for(int tmp=0; tmp<count; tmp++){\n\t    remove(game,i,j-tmp-1);\n\t  }\n\t  earn_score += std::pow(2, num_step)*now*count;\n\t}\n\tnow = game[i][j];\n\tcount = 1;\n      }else{\n\tcount++;\n      }\n    }\n    if(count >= k and now != -1){\n      for(int tmp=0; tmp<count; tmp++){\n\tremove(game,i,w-1-tmp);\n      }\n      earn_score += std::pow(2, num_step)*now*count;\n    }\n\n  }\n  //print(game, h, w);\n  //std::cout << num_step << \" \" << earn_score << std::endl;\n  return earn_score;\n}\n\n\nint calcScore(const int c_game[H][W], int h, int w, int erase_w, int erase_h, int k){\n  int score = 0;\n  int next_score = 0;\n  int step = 0;\n  int game[H][W];\n  for(int i=0; i<h; i++){\n    for(int j=0; j<w; j++){\n      game[i][j] = c_game[i][j];\n    }\n  }\n  remove(game, erase_h, erase_w);\n  move(game, h, w);\n  next_score = earn(game, h, w, k, step);\n  step++;\n  score += next_score;\n  while(next_score){\n    move(game, h,w);\n    next_score = earn(game, h, w, k, step);\n    step++;\n    score += next_score;\n  }\n  //std::cout << std::endl;\n  return score;\n}\n\nint main(void){\n  int h,w,k;\n  std::cin >> h >> w >> k;\n\n  \n  int game[H][W];\n  for(int i=0; i<h; i++){\n    for(int j=0; j<w; j++){\n      scanf(\"%1d\", &game[i][j]);\n    }\n  }\n  int max = 0;\n  for(int j=0; j<w; j++){\n    for(int i=0; i<h; i++){\n      int score = calcScore(game, h, w, j, i, k);\n      //std::cout << j << \" \" << score << std::endl;\n      if(score > max){\n\tmax = score;\n      }\n    }\n  }\n  std::cout << max << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = (0); i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define show2(x,y) cout << #x << \" = \" << (x) << \", \" << #y << \" = \" << (y) << endl\n#define show3(x,y,z) cout << #x << \" = \" << (x) << \", \" << #y << \" = \" << (y) <<  \", \" << #z << \" = \" << (z) << endl\n#define showv(v) rep(i,v.size()) printf(\"%d%c\", v[i], i==v.size()-1?'\\n':' ')\n#define showv2(v) rep(j,v.size()) showv(v[j])\n#define showt(t,n) rep(i,n) printf(\"%d%c\", t[i], i==n-1?'\\n':' ')\n#define showt2(t,r,c) rep(j,r) showt(t[j],c)\n#define showvp(p) rep(i,p.size()) printf(\"%d %d\\n\", p[i].first, p[i].second);\n#define printv(v) rep(i,v.size()) printf(\"%d\\n\", v[i])\n#define printt(t,n) rep(i,n) printf(\"%d\\n\", t[i])\n#define incl(v,x) find(rng(v),x)!=v.end()\n#define incls(s,c) s.find(c)!=string::npos\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define bit(n,k) ((n>>k)&1) // nのk bit目\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define SP << \" \" <<\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\nusing vs = vector<string>;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing vp = vector<P>;\nusing vt = vector<T>;\nconst int mod = 1000000007;\nconst double EPS = 1e-9;\n//const long double EPS = 1e-14;\nconst int INF = (1<<30)-1;\nconst ll LINF = (1LL<<62)-1;\n#define dame { puts(\"No\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline ll lin() { ll x; scanf(\"%lld\",&x); return x;}\ninline char chin() { char x; scanf(\"%c\",&x); return x;}\ninline string stin() { string x; cin >> x; return x;}\ninline double din() { double x; scanf(\"%lf\",&x); return x;}\n//template<class T = int> inline T in() { T x; cin >> x; return (x);}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nchar itoa(int n) { return n + '0';}\nll gcd(ll a, ll b) { return b ? gcd(b,a%b) : a;}\nll lcm(ll a, ll b) { return a/gcd(a,b)*b;}\n\nint h, w, K;\nll rec(vvi a) {\n  ll res = 0;\n  bool up = false;\n  rep(i,h) {\n    vi t;\n    rep(j,w) {\n      if (a[i][j]) t.pb(a[i][j]);\n    }\n    while (sz(t) < w) t.pb(0);\n    a[i] = t;\n  }\n  rep(i,h)rep(j,w) {\n    if (!a[i][j]) continue;\n    int s = i;\n    while (s < h && a[i][j] == a[s][j]) ++s;\n    if (s-i >= K) {\n      up = true;\n      for (int k = i; k < s; ++k) {\n        res += a[k][j];\n        a[k][j] = 0;\n      }\n    }\n  }\n  if (up) return rec(a)*2 + res;\n  return 0;\n}\n\nint main () {\n  cin >> h >> w >> K;\n  swap(h,w);\n  vvi a(h,vi(w));\n  rep(j,w) {\n    string s = stin();\n    rep(i,h) {\n      a[i][w-1-j] = s[i]-'0';\n    }\n  }\n  ll ans = 0;\n  rep(i,h)rep(j,w) {\n    vvi b = a;\n    b[i][j] = 0;\n    chmax(ans, rec(b));\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<vector>\n\nusing namespace std;\n#define int long long\n\nsigned main(){\n\n   int H, W, K;\n   cin>> H>> W>> K;\n   vector<int> c[H];\n   for(int i=0; i<H; i++){\n      vector<int> v;\n      for(int j=0; j<W; j++){\n         char ch;\n         cin>> ch;\n         c[i].push_back(ch-'0');\n      }\n   }\n\n   assert(H<=10&&W<=10);\n   assert(W==K);\n\n   int ma=0;\n   for(int j=0; j<W; j++){\n      int b[H][W];\n      for(int _j=0; _j<W; _j++){\n         for(int i=(j==_j); i<H; i++){\n            if(_j==j){\n               b[i][_j]=c[i-1][_j];\n            }else{\n               b[i][_j]=c[i][_j];\n            }\n         }\n      }\n\n      int s=0;\n      for(int i=1; i<H; i++){\n         int f=0;\n         for(int a=0; a<W-1; a++){\n            f|=(b[i][a]!=b[i][a+1]);\n         }\n         if(!f){\n            s+=W*b[i][0];\n         }\n      }\n      ma=max(ma, s);\n   }\n\n   cout<< ma<< endl;\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst int mod = 1e9;\n\nll modpow(ll a, ll n) {\n    ll res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main()\n{\n    ll h, w, k;\n    cin >> h >> w >> k;\n    string S;\n    ll now = 0;\n    vector<vector<ll>> board(h, vector<ll>(w, 0));\n    for (ll i = 0; i < h; i++)\n    {\n        cin >> S;\n        for (ll j = 0; j < w; j++)\n        {\n            board[i][j] = S[j] - '0';\n        }\n    }\n    for (int row = 0; row < h; row++)\n    {\n        for (int column = 0; column < w; column++)\n        {\n            vector<vector<ll>> board2 = board;\n            board2[row][column] = 0;\n            for (int k = row; k > 0; k--)\n            {\n                swap(board2[k][column], board2[k - 1][column]);\n            }\n\n            bool can = true;\n            ll times = 0;\n            ll ans = 0;\n            while (can)\n            {\n                can = false;\n                for (ll i = 0; i < h; i++)\n                {\n                    ll key = board2[i][0];\n                    ll cnt = 1;\n                    for (ll j = 1; j < w; j++)\n                    {\n                        if (key == board2[i][j] && key != 0)\n                        {\n                            cnt++;\n                        }\n                        else\n                        {\n                            if (cnt >= k)\n                            {\n                                can = true;\n                                ans += cnt * modpow(2, times) * board2[i][j - 1];\n                                for (int m = 1; m < cnt + 1; m++)\n                                {\n                                    board2[i][j - m] = 0;\n                                }\n                            }\n                            key = board2[i][j];\n                            cnt = 1;\n                        }\n                    }\n                    if (cnt >= k)\n                    {\n                        can = true;\n                        ans += cnt * modpow(2, times) * board2[i][w - 1];\n                        for (int m = 1; m < cnt + 1; m++)\n                        {\n                            board2[i][w - m] = 0;\n                        }\n                    }\n                }\n                times++;\n                if (can)\n                {\n                    for (int j = 0; j < w; j++)\n                    {\n                        for (int i = h - 1; i >= 0; i--)\n                        {\n                            if (board2[i][j] == 0)\n                            {\n                                int zero = i;\n                                while (zero >= 0 && board2[zero][j] == 0)\n                                {\n                                    zero--;\n                                    if (zero == -1)\n                                    {\n                                        break;\n                                    }\n                                }\n                                if (zero != -1)\n                                {\n                                    board2[i][j] = board2[zero][j];\n                                    board2[zero][j] = 0;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            now = max(now, ans);\n        }\n    }\n    cout << now << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<25;\nconst ll INF=1ll<<50;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst vi emp;\n\nint h,w,K;\nvvi field;\n\nvoid Make(int x,vvi& c){\n\tvi a;\n\tfor(int i=0;i<h;i++){\n\t\tif(c[x][i]) a.push_back(c[x][i]);\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tif(i>=a.size()) c[x][i]=0;\n\t\telse c[x][i]=a[i];\n\t}\n}\n\nint main(){\n\tcin>>h>>w>>K;\n\tfield=vvi(w,vi(h));\n\tvvc C(w,vc(h));\n\tfor(int i=h-1;i>=0;i--) for(int j=0;j<w;j++) cin>>C[j][i];\n\tfor(int i=h-1;i>=0;i--) for(int j=0;j<w;j++) field[j][i]=C[j][i]-'0';\n\tint ans=0;\n//\tcout<<endl;\n\tfor(int i=0;i<w;i++) for(int I=0;I<h;I++){\n\t\tint M=0,tmp=1;\n\t\tvvi c(w,vi(h));\n\t\tfor(int j=h-1;j>=0;j--) for(int k=0;k<w;k++) c[k][j]=field[k][j];\n\t\tc[i][I]=0;\n\t\tMake(i,c);/*\n\t\tif(i==2){for(int j=h-1;j>=0;j--){\n\t\t\tfor(int k=0;k<w;k++) cout<<c[k][j];\n\t\t\tcout<<endl;\n\t\t}cout<<endl;}*/\n\t\twhile(1){\n\t\t\tint sum=0;\n\t\t\tbool flag=0;\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tvi a(w);\n\t\t\t\tfor(int k=0;k<w;k++) a[k]=c[k][j];\n\t\t\t\tint s=0;\n/*\t\t\t\tif(i==2){for(int k=0;k<w;k++) cout<<a[k]<<' ';\n\t\t\t\tcout<<endl;}*/\n\t\t\t\tfor(int k=1;k<w;k++){\n\t\t\t\t\tif(a[k]!=a[k-1]){\n\t\t\t\t\t\tif(k-s>=K){\n\t\t\t\t\t\t\tsum+=(k-s)*a[s];\n\t\t\t\t\t\t\tfor(int l=s;l<k;l++) a[l]=0;\n\t\t\t\t\t\t\tflag=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts=k;\n\t\t\t\t\t\tif(!a[k]) s++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(!a[k]) s=k+1;\n\t\t\t\t}\n\t\t\t\tif(a[w-1]&&w-s>=K){\n\t\t\t\t\tsum+=(w-s)*a[s];\n\t\t\t\t\tfor(int k=s;k<w;k++) a[k]=0;\n\t\t\t\t\tflag=1;\n\t\t\t\t}\n/*\t\t\t\tif(i==2){for(int k=0;k<w;k++) cout<<a[k]<<' ';\n\t\t\t\tcout<<endl;}*/\n\t\t\t\tfor(int k=0;k<w;k++) c[k][j]=a[k];\n\t\t\t}\n//\t\t\tcout<<'B'<<sum<<endl;\n/*\t\t\tif(i==2){for(int j=h-1;j>=0;j--){\n\t\t\t\tfor(int k=0;k<w;k++) cout<<c[k][j];\n\t\t\t\tcout<<endl;\n\t\t\t}cout<<endl;}*/\n\t\t\tif(!flag) break;\n\t\t\tfor(int j=0;j<w;j++) Make(j,c);\n\t\t\tM+=tmp*sum;\n//\t\t\tif(i==2) cout<<'A'<<M<<endl;\n\t\t\ttmp*=2;\n\t\t}\n//\t\tcout<<M<<endl;\n\t\tans=max(ans,M);\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//temp2\n\n//#undef _DEBUG\n//#pragma GCC optimize(\"Ofast\")\n//不動小数点の計算高速化\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <bits/stdc++.h>\n\n//todo use_pbdsを消すとバグる 後で直す\n#define use_pbds\n#ifdef use_pbds\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\ntemplate<class T, class U, class W, class X> auto count(__gnu_pbds::gp_hash_table<T, U, W> &a, X k) { return a.find(k) != a.end(); }\n#endif\n\nusing namespace std;\nusing namespace std::chrono;\n\n/*@formatter:off*/\n#ifndef _DEBUG\n#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/multiprecision/cpp_dec_float.hpp>\nnamespace cmp = boost::multiprecision;\nusing cint = cmp :: cpp_int;\nusing bdou = cmp::cpp_dec_float_100;\n#endif\n#define ll long long\nusing sig_dou = double;\n\ntemplate<class T,class U> auto max(T a, U b){return a>b ? a: b;}\ntemplate<class T,class U> auto min(T a, U b){return a<b ? a: b;}\n\nnamespace helper {\n    template<class T>T s_decl2(const vector<T>& A){return (T)0;}\n    template<class T>T s_decl2(const vector<vector<T> >& A){return (T)0;}\n    template<class T>T s_decl2(const vector<vector<vector<T> > >& A){return (T)0;}\n    template<class T>T s_decl2(const vector<vector<vector<vector<T> > > >& A){return (T)0;}\n    template<class T>T s_decl2(const vector<vector<vector<vector<vector<T> > > > >& A){return (T)0;}\n    template<class T>T s_decl2(const vector<vector<vector<vector<vector<vector<T> > > > > >& A){return (T)0;}\n    //vector<vector<.....T>>でTを返す\n#define decl2(a) decltype(helper::s_decl2(a))\n}\n\n#define int long long //todo 消したら動かない intの代わりにsignedを使う\nauto start_time = system_clock::now();\nauto past_time = system_clock::now();\n\n#define debugName(VariableName) # VariableName\n//最大引数がN\n#define over2(o1, o2, name, ...) name\n#define over3(o1, o2, o3, name, ...) name\n#define over4(o1, o2, o3, o4, name, ...) name\n#define over5(o1, o2, o3, o4, o5, name, ...) name\n#define over6(o1, o2, o3, o4, o5, o6, name, ...) name\n#define over7(o1, o2, o3, o4, o5, o6, o7, name, ...) name\n#define over8(o1, o2, o3, o4, o5, o6, o7, o8, name, ...) name\n#define over9(o1, o2, o3, o4, o5, o6, o7, o8, o9, name, ...) name\n#define over10(o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, name, ...) name\n\n\n\n\n\n\n#ifdef _DEBUG\nstring message;\nstring res_mes;\n//#define use_debtor\n\n#ifdef use_debtor\n//https://marycore.jp/prog/cpp/class-extension-methods/ 違うかも\ntemplate<class T, class A = std::allocator<T>> struct debtor : std::vector<T, A> {\n    using std::vector<T, A>::vector;\n    template<class U> int deb_v(U a, int v) { return v; }\n    template<class U> int deb_v(debtor<U> &a, int v = 0) {        cerr << a.size() << \" \";        return deb_v(a.at(0), v + 1);    }\n    template<class U> void deb_o(U a) { cerr << a << \" \"; }\n    template<class U> void deb_o(debtor<U> &a) {        for (int i = 0; i < min((int) a.size(), 15ll); i++) { deb_o(a[i]); }        if ((int) a.size() > 15) { cerr << \"...\"; }        cerr << endl;    }\n    typename std::vector<T>::reference my_at(typename std::vector<T>::size_type n, vector<int> &ind) {        if (n < 0 || n >= (int) this->size()) {            int siz = (int) this->size();            cerr << \"vector size = \";            int dim = deb_v((*this));            cerr << endl;            ind.push_back(n);            cerr << \"out index at  \";            for (auto &&i: ind) {                cerr << i << \" \";            }            cerr << endl;            cerr << endl;            if (dim <= 2) { deb_o((*this)); }            exit(0);        }        return this->at(n);    }\n    typename std::vector<T>::reference operator[](typename std::vector<T>::size_type n) {        if (n < 0 || n >= (int) this->size()) {            int siz = (int) this->size();            cerr << \"vector size = \";            int dim = deb_v((*this));            cerr << endl;            cerr << \"out index at  \" << n << endl;            cerr << endl;            if (dim <= 2) { deb_o((*this)); }            exit(0);        }        return this->at(n);    }\n};\n#define vector debtor\n#endif\n#ifdef use_pbds\ntemplate<class T> struct my_pbds_tree {    set<T> s;    auto begin() { return s.begin(); }    auto end() { return s.end(); }    auto rbegin() { return s.rbegin(); }    auto rend() { return s.rend(); }    auto empty() { return s.empty(); }    auto size() { return s.size(); }    void clear() { s.clear(); }    template<class U> void insert(U v) { s.insert(v); }template<class U> void operator+=(U v) { insert(v); }    template<class F> auto erase(F v) { return s.erase(v); }    template<class U> auto find(U v) { return s.find(v); }    template<class U> auto lower_bound(U v) { return s.lower_bound(v); }    template<class U> auto upper_bound(U v) { return s.upper_bound(v); }    auto find_by_order(ll k) {        auto it = s.begin();        for (ll i = 0; i < k; i++)it++;        return it;    }    auto order_of_key(ll v) {        auto it = s.begin();        ll i=0;        for (;it != s.end() && *it <v ; i++)it++;        return i;    }};\n#define pbds(T) my_pbds_tree<T>\n#endif\n\n//区間削除は出来ない\n//gp_hash_tableでcountを使えないようにするため\ntemplate<class T, class U> struct my_unordered_map { unordered_map<T, U> m; my_unordered_map() {}; auto begin() { return m.begin(); } auto end() { return m.end(); } auto cbegin() { return m.cbegin(); } auto cend() { return m.cend(); } template<class V> auto erase(V v) { return m.erase(v); } void clear() { m.clear(); }    /*countは gp_hash_tableに存在しない*/    /*!= m.end()*/    template<class V> auto find(V v) { return m.find(v); } template<class V> auto &operator[](V n) { return m[n]; }};\n#define unordered_map my_unordered_map\n#define umapi unordered_map<ll,ll>\n#define umapp unordered_map<P,ll>\n#define umapu unordered_map<uint64_t,ll>\n#define umapip unordered_map<ll,P>\ntemplate<class T, class U, class X> auto count(unordered_map<T, U> &a, X k) { return a.find(k) != a.end(); }\n#else\n#define endl '\\n'\n//umapはunorderd_mapになる\n//umapiはgp_hash_table\n\n//find_by_order(k) k番目のイテレーター\n//order_of_key(k)  k以上が前から何番目か\n#define pbds(U) __gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>\n\n#define umapi __gnu_pbds::gp_hash_table<ll,ll,xorshift>\n#define umapp __gnu_pbds::gp_hash_table<P,ll,xorshift>\n#define umapu __gnu_pbds::gp_hash_table<uint64_t,ll,xorshift>\n#define umapip __gnu_pbds::gp_hash_table<ll,P,xorshift>\n#endif\n\n\nstruct xorshift {\n    static uint64_t splitmix64(uint64_t x) {        x += 0x9e3779b97f4a7c15;        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;        return x ^ (x >> 31);    }\n    size_t operator()(uint64_t x) const {        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        return splitmix64(x + FIXED_RANDOM);    }\n    size_t operator()(std::pair<ll, ll> x) const {        ll v = ((x.first) << 32) | x.second;        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        return splitmix64(v + FIXED_RANDOM);    }\n};\n#ifdef use_pbds\ntemplate<class U, class L> void operator+=(__gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update> &s, L v) { s.insert(v); }\n#endif\n//衝突対策\n#define ws ws_\n\ntemplate<class A, class B, class C> struct T2 { A f;B s;C t;T2() { f = 0, s = 0, t = 0; }T2(A f, B s, C t) : f(f), s(s), t(t) {}bool operator<(const T2 &r) const { return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;        /*return f != r.f ? f > r.f : s != r.s ?n s > r.s : t > r.t; 大きい順 */   } bool operator>(const T2 &r) const { return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;        /*return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順 */   } bool operator==(const T2 &r) const { return f == r.f && s == r.s && t == r.t; } bool operator!=(const T2 &r) const { return f != r.f || s != r.s || t != r.t; }};\ntemplate<class A, class B, class C, class D> struct F2 {    A a;    B b;    C c;    D d;    F2() { a = 0, b = 0, c = 0, d = 0; }    F2(A a, B b, C c, D d) : a(a), b(b), c(c), d(d) {}    bool operator<(const F2 &r) const { return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;    /*    return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;*/    }    bool operator>(const F2 &r) const { return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;/*        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;*/    }    bool operator==(const F2 &r) const { return a == r.a && b == r.b && c == r.c && d == r.d; }    bool operator!=(const F2 &r) const { return a != r.a || b != r.b || c != r.c || d != r.d; }    ll operator[](ll i) {        assert(i < 4);        return i == 0 ? a : i == 1 ? b : i == 2 ? c : d;    }};\ntypedef T2<ll, ll, ll> T;\ntypedef F2<ll, ll, ll, ll> F;\nT mt(ll a, ll b, ll c) { return T(a, b, c); }\nF mf(ll a, ll b, ll c, ll d) { return F(a, b, c, d); }\n\ntemplate<class T, class U> bool chma(T &a, const U &b) {    if (a < b) {        a = b;        return true;    }    return false;}\ntemplate<class T, class U> bool chmi(T &a, const U &b) {    if (b < a) {        a = b;        return true;    }    return false;}\n\n//関数内をまとめる\n//初期値l=0, r=-1\nvoid pr_set_lr(int &l, int &r, int n) {    /*r==-1*/    if (!(~r)) {        if(!(~l)){            l = 0;            r = n;        }else {            r = l;            l = 0;        }    }}\n//@マクロ省略系 型,構造\n//using で元のdoubleを同時に使えるはず\n#define double_big\n\n#ifdef double_big\n//#define double long double\n#define pow powl\n#endif\nusing dou = double;\nconst double eps = 1e-9;\n\n//#define use_epsdou\n#ifdef use_epsdou\n//基本コメントアウト\nstruct epsdou {    double v;    epsdou(double v = 0) : v(v) {}    template<class T> epsdou &operator+=(T b) {        v += (double) b;        return (*this);    }    template<class T> epsdou &operator-=(T b) {        v -= (double) b;        return (*this);    }    template<class T> epsdou &operator*=(T b) {        v *= (double) b;        return (*this);    }    template<class T> epsdou &operator/=(T b) {        v /= (double) b;        return (*this);    }    epsdou operator+(epsdou b) { return v + (double) b; }    epsdou operator-(epsdou b) { return v - (double) b; }    epsdou operator*(epsdou b) { return v * (double) b; }    epsdou operator/(epsdou b) { return v / (double) b; }    epsdou operator-() const { return epsdou(-v); }    template<class T> bool operator<(T b) { return v < (double) b; }    template<class T> bool operator>(T b) {auto r = (double)b;        return v > (double) b; }    template<class T> bool operator==(T b) { return fabs(v - (double) b) <= eps; }    template<class T> bool operator<=(T b) { return v < (double) b || fabs(v - b) <= eps; }    template<class T> bool operator>=(T b) { return v > (double) b || fabs(v - b) <= eps; }    operator double() { return v; }};\ntemplate<>epsdou MAX(){return MAX<double>();}\ntemplate<>epsdou MIN(){return MIN<double>();}\n//priqrity_queue等で使うのに必要\nbool operator<(const epsdou &a, const epsdou &b) {return a.v < b.v;}\nbool operator>(const epsdou &a, const epsdou &b) {return a.v > b.v;}\nistream &operator>>(istream &iss, epsdou &a) {iss >> a.v;return iss;}\nostream &operator<<(ostream &os, epsdou &a) {os << a.v;return os;}\n#define eps_conr_t(o) template<class T> epsdou operator o(T a, epsdou b) {return (dou) a o b.v;}\n#define eps_conl_t(o) template<class T> epsdou operator o(epsdou a, T b) {return a.v o (dou) b;}\neps_conl_t(+)eps_conl_t(-)eps_conl_t(*)eps_conl_t(/)eps_conr_t(+)eps_conr_t(-)eps_conr_t(*)eps_conr_t(/)\ntemplate<class U> epsdou max(epsdou a, U b){return a.v>b ? a.v: b;}\ntemplate<class U> epsdou max(U a, epsdou b){return a>b.v ? a: b.v;}\ntemplate<class U> epsdou min(epsdou a, U b){return a.v<b ? a.v: b;}\ntemplate<class U> epsdou min(U a, epsdou b){return a<b.v ? a: b.v;}\n#undef double\n#define double epsdou\n#undef dou\n#define dou epsdou\n#endif\n\n\n#define ull unsigned long long\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define el else\n#define elf else if\n#define upd update\n#define sstream stringstream\n\n#define maxq 1\n#define minq -1\n\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MALLOC(type, len) (type*)malloc((len) * sizeof(type))\n#define lam1(ret) [&](auto& v){return ret;}\n#define lam2(v, ret) [&](auto& v){return ret;}\n#define lam(...) over2(__VA_ARGS__,lam2,lam1)(__VA_ARGS__)\n#define lamr(right) [&](auto& p){return p right;}\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\n//マクロ省略系 コンテナ\nusing vi = vector<ll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vp = vector<P>;\nusing vt = vector<T>;\n\n//#define V vector\n#define vvt0(t) vector<vector<t>>\n#define vvt1(t, a) vector<vector<t>>a\n#define vvt2(t, a, b) vector<vector<t>>a(b)\n#define vvt3(t, a, b, c) vector<vector<t>> a(b,vector<t>(c))\n#define vvt4(t, a, b, c, d) vector<vector<t>> a(b,vector<t>(c,d))\n\n#define vvi(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(ll,__VA_ARGS__)\n#define vvb(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(bool,__VA_ARGS__)\n#define vvs(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(string,__VA_ARGS__)\n#define vvd(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(double,__VA_ARGS__)\n#define vvc(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(char,__VA_ARGS__)\n#define vvp(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(P,__VA_ARGS__)\n#define vvt(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(T,__VA_ARGS__)\n#define vv(type, ...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(type,__VA_ARGS__)\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...)); }\n#define vni(name, ...) auto name = make_v<ll>(__VA_ARGS__)\n#define vnb(name, ...) auto name = make_v<bool>(__VA_ARGS__)\n#define vns(name, ...) auto name = make_v<string>(__VA_ARGS__)\n#define vnd(name, ...) auto name = make_v<double>(__VA_ARGS__)\n#define vnc(name, ...) auto name = make_v<char>(__VA_ARGS__)\n#define vnp(name, ...) auto name = make_v<P>(__VA_ARGS__)\n#define vn(type, name, ...) auto name = make_v<type>(__VA_ARGS__)\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<ll, ll>;\nusing mapp = map<P, ll>;\nusing mapd = map<dou, ll>;\nusing mapc = map<char, ll>;\nusing maps = map<str, ll>;\nusing seti = set<ll>;\nusing setp = set<P>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<ll>;\n#define uset unordered_set\n#define useti unordered_set<ll,xorshift>\n#define mset multiset\n#define mseti multiset<ll>\n#define umap unordered_map\n#define mmap multimap\n//任意のマクロサポート用 使う度に初期化する\nint index_, v1_, v2_, v3_;\n\ntemplate<class T> struct pq {\n    priority_queue<T, vector<T>, greater<T> > q;/*小さい順*/    T su = 0;\n    void clear() {        q = priority_queue<T, vector<T>, greater<T> >();        su = 0;    }\n    void operator+=(T v) {        su += v;        q.push(v);    }\n    T sum() { return su; }\n    T top() { return q.top(); }\n    void pop() {        su -= q.top();        q.pop();    }\n    T poll() {        T ret = q.top();        su -= ret;        q.pop();        return ret;    }\n    ll size() { return q.size(); }\n};\ntemplate<class T> struct pqg {\n    priority_queue<T> q;/*大きい順*/    T su = 0;\n    void clear() {        q = priority_queue<T>();        su = 0;    }\n    void operator+=(T v) {su += v;        q.push(v);    }\n    T sum() { return su; }\n    T top() { return q.top(); }\n    void pop() {su -= q.top();q.pop();}\n    T poll() {        T ret = q.top();        su -= ret;        q.pop();        return ret;    }\n    ll size() { return q.size(); }\n};\n#define pqi pq<ll>\n#define pqgi pqg<ll>\n//マクロ 繰り返し\n//↓@オーバーロード隔離\n\n#define rep1(n) for(ll rep1i = 0,rep1lim=n; rep1i < rep1lim ; ++rep1i)\n#define rep2(i, n) for(ll i = 0,rep2lim=n; i < rep2lim ; ++i)\n#define rep3(i, m, n) for(ll i = m,rep3lim=n; i < rep3lim ; ++i)\n#define rep4(i, m, n, ad) for(ll i = m,rep4lim=n; i < rep4lim ; i+= ad)\n//逆順 閉区間\n#define rer2(i, n) for(ll i = n; i >= 0 ; i--)\n#define rer3(i, m, n) for(ll i = m,rer3lim=n; i >= rer3lim ; i--)\n#define rer4(i, m, n, dec) for(ll i = m,rer4lim=n; i >= rer4lim ; i-=dec)\n//ループを一つにまとめないとフォーマットで汚くなるため\n#define nex_ind1(i) i++\n#define nex_ind2(i, j, J) i = (j + 1 == J) ? i + 1 : i, j = (j + 1 == J ? 0 : j + 1)\n#define nex_ind3(i, j, k, J, K)i = (j + 1 == J && k + 1 == K) ? i + 1 : i, j = (k + 1 == K) ? (j + 1 == J ? 0 : j + 1) : j, k = (k + 1 == K ? 0 : k + 1)\n#define nex_ind4(i, j, k, l, J, K, L) i = (j + 1 == J && k + 1 == K && l + 1 == L) ? i + 1 : i, j = (k + 1 == K && l + 1 == L) ? (j + 1 == J ? 0 : j + 1) : j, k = (l + 1 == L ?(k + 1 == K ? 0 : k + 1) : k), l = l + 1 == L ? 0 : l + 1\n#define nex_ind5(i, j, k, l, m, J, K, L, M) i = (j + 1 == J && k + 1 == K && l + 1 == L && m + 1 == M) ? i + 1 : i, j = (k + 1 == K && l + 1 == L && m + 1 == M) ? (j + 1 == J ? 0 : j + 1) : j, k = (l + 1 == L && m + 1 == M ?(k + 1 == K ? 0 : k + 1) : k), l =  m + 1 == M ? l+1 == L ? 0 : l+1 : l,  m = m + 1 == M ? 0 : m + 1\n\n#define repss2(i, I) for (int i = 0; i < I; i++)\n#define repss4(i, j, I, J) for (int i = (J ? 0 : I), j = 0; i < I; nex_ind2(i, j, J))\n#define repss6(i, j, k, I, J, K) for (int i = (J && K ? 0 : I), j = 0, k = 0; i < I; nex_ind3(i, j, k, J, K))\n#define repss8(i, j, k, l, I, J, K, L) for (int i = (J && K && L ? 0 : I), j = 0, k = 0, l = 0; i < I; nex_ind4(i, j, k, l, J, K, L))\n#define repss10(i, j, k, l, m, I, J, K, L, M)for (int i = (J && K && L && M ? 0 : I), j = 0, k = 0, l = 0, m = 0; i < I; nex_ind5(i, j, k, l, m, J, K, L, M))\n\n//i,j,k...をnまで見る\n#define reps2(i, n) repss2(i, n)\n#define reps3(i, j, n) repss4(i, j, n, n)\n#define reps4(i, j, k, n) repss6(i, j, k, n, n, n)\n#define reps5(i, j, k, l, n) repss8(i, j, k, l, n, n, n, n)\n\ntemplate<class T> void nex_repv2(int &i, int &j, int &I, int &J, vector<vector<T>> &s) {    while (1) {        j++;        if (j >= J) {            j = 0;            i++;            if (i < I) { J = (int) s[i].size(); }        }        if (i >= I || J) return;    }}\ntemplate<class T> void nex_repv3(int &i, int &j, int &k, int &I, int &J, int &K, vector<vector<vector<T>>> &s) {    while (1) {        k++;        if (k >= K) {            k = 0;            j++;            if (j >= J) {                j = 0;                i++;                if (i >= I)return;            }        }        J = (int) s[i].size();        K = (int) s[i][j].size();        if (J && K) return;    }}\n\n#define repv_2(i, a) repss2(i, sz(a))\n//正方形である必要はない\n//直前を持つのとどっちが早いか\n#define repv_3(i, j, a) for (int repvI = (int)a.size(), repvJ = (int)a[0].size(), i = 0, j = 0; i < repvI; nex_repv2(i,j,repvI,repvJ,a))\n//箱状になっている事が要求される つまり[i] 次元目の要素数は一定\n#define repv_4(i, j, k, a) for (int repvI = (int)a.size(), repvJ = (int)a[0].size(), repvK =(int)a[0][0].size(), i = 0, j = 0, k=0; i < repvI; nex_repv3(i,j,k,repvI,repvJ,repvK,a))\n#define repv_5(i, j, k, l, a) repss8(i, j, k, l, sz(a), sz(a[0]), sz(a[0][0]), sz(a[0][0][0]))\n#define repv_6(i, j, k, l, m, a) repss10(i, j, k, l, m, sz(a), sz(a[0]), sz(a[0][0]), sz(a[0][0][0]), sz(a[0][0][0][0]))\n\ntemplate<typename T> struct has_rbegin_rend { private:template<typename U> static auto check(U &&obj) -> decltype(std::rbegin(obj), std::rend(obj), std::true_type{});static std::false_type check(...);public:static constexpr bool value = decltype(check(std::declval<T>()))::value; };\ntemplate<typename T> constexpr bool has_rbegin_rend_v = has_rbegin_rend<T>::value;\ntemplate<typename Iterator> class Range { public:Range(Iterator &&begin, Iterator &&end) noexcept: m_begin(std::forward<Iterator>(begin)), m_end(std::forward<Iterator>(end)) {}Iterator begin() const noexcept { return m_begin; }Iterator end() const noexcept { return m_end; }private:const Iterator m_begin;const Iterator m_end; };\ntemplate<typename Iterator> static inline Range<Iterator> makeRange(Iterator &&begin, Iterator &&end) noexcept { return Range<Iterator>{std::forward<Iterator>(begin), std::forward<Iterator>(end)}; }\ntemplate<typename T> static inline decltype(auto) makeReversedRange(const std::initializer_list<T> &iniList) noexcept { return makeRange(std::rbegin(iniList), std::rend(iniList)); }\ntemplate<typename T, typename std::enable_if_t<has_rbegin_rend_v<T>, std::nullptr_t> = nullptr> static inline decltype(auto) makeReversedRange(T &&c) noexcept { return makeRange(std::rbegin(c), std::rend(c)); }/* rbegin(), rend()を持たないものはこっちに分岐させて，エラーメッセージを少なくする*/template<typename T, typename std::enable_if<!has_rbegin_rend<T>::value, std::nullptr_t>::type = nullptr> static inline void makeReversedRange(T &&) noexcept { static_assert(has_rbegin_rend<T>::value, \"Specified argument doesn't have reverse iterator.\"); }\n\n//#define use_for\n\n#define form1(st) for (auto &&form_it = st.begin(); form_it != st.end(); ++form_it)\n#define form3(k, v, st) for (auto &&form_it = st.begin(); form_it != st.end(); ++form_it)\n#define form4(k, v, st, r) for (auto &&form_it = st.begin(); form_it != st.end() && (*form_it).fi < r; ++form_it)\n#define form5(k, v, st, l, r) for (auto &&form_it = st.lower_bound(l); form_it != st.end() && (*form_it).fi < r; ++form_it)\n\n#define forrm1(st) for (auto &&forrm_it = st.rbegin(); forrm_it != st.rend(); ++forrm_it)\n#define forrm3(k, v, st) for (auto &&forrm_it = st.rbegin(); forrm_it != st.rend(); ++forrm_it)\n\n//向こう側で\n// ++itか it = st.erase(it)とする\n#define fors1(st) for (auto &&it = st.begin(); it != st.end(); )\n#define fors2(v, st) for (auto &&it = st.begin(); it != st.end(); )\n#define fors3(v, st, r) for (auto &&it = st.begin(); it != st.end() && (*it) < r; )\n#define fors4(v, st, l, r) for (auto &&it = st.lower_bound(l); it != st.end() && (*it) < r; )\n\n#ifdef use_for\n#define forslr3(st, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end(); ++forslr_it)\n#define forslr4(v, st, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end(); ++forslr_it)\n#define forslr5(v, st, r, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end() && (*forslr_it) < r; ++forslr_it)\n#define forslr6(v, st, l, r, a, b) for (auto &&forslr_it = st.lower_bound(l); forslr_it != st.end() && (*forslr_it) < r; ++forslr_it)\n#endif\n\n#define fora_init_2(a, A) ;\n#define fora_init_3(fora_i, a, A) auto &&a = A[fora_i];\n#define fora_init_4(a, b, A, B) auto &&a = A[fora_i]; auto &&b = B[fora_i];\n#define fora_init_5(fora_i, a, b, A, B) auto &&a = A[fora_i]; auto &&b = B[fora_i];\n#define fora_init_6(a, b, c, A, B, C) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i];\n#define fora_init_7(fora_i, a, b, c, A, B, C) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i];\n#define fora_init_8(a, b, c, d, A, B, C, D) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i]; auto && d = D[fora_i];\n#define fora_init_9(fora_i, a, b, c, d, A, B, C, D) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i]; auto && d = D[fora_i];\n#define fora_init(...) over9(__VA_ARGS__,fora_init_9, fora_init_8, fora_init_7, fora_init_6, fora_init_5, fora_init_4, fora_init_3, fora_init_2)(__VA_ARGS__)\n\n#ifdef use_for\n#define forr_init_2(a, A) auto &&a = A[forr_i];\n#define forr_init_3(forr_i, a, A) auto &&a = A[forr_i];\n#define forr_init_4(a, b, A, B) auto &&a = A[forr_i]; auto &&b = B[forr_i];\n#define forr_init_5(forr_i, a, b, A, B) auto &&a = A[forr_i]; auto &&b = B[forr_i];\n#define forr_init_6(a, b, c, A, B, C) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i];\n#define forr_init_7(forr_i, a, b, c, A, B, C) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i];\n#define forr_init_8(a, b, c, d, A, B, C, D) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i]; auto && d = D[forr_i];\n#define forr_init_9(forr_i, a, b, c, d, A, B, C, D) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i]; auto && d = D[forr_i];\n#define forr_init(...) over9(__VA_ARGS__, forr_init_9, forr_init_8, forr_init_7, forr_init_6, forr_init_5, forr_init_4, forr_init_3, forr_init_2)(__VA_ARGS__)\n\n#define forp_init3(k, v, S) auto &&k = S[forp_i].first;auto &&v = S[forp_i].second;\n#define forp_init4(forp_i, k, v, S) auto &&k = S[forp_i].first;auto &&v = S[forp_i].second;\n#define forp_init(...) over4(__VA_ARGS__,forp_init4,forp_init3,forp_init2,forp_init1)(__VA_ARGS__)\n\n#define form_init(k, v, ...) auto &&k = (*form_it).fi;auto &&v = (*form_it).se;\n#define forrm_init(k, v, ...) auto &&k = (*forrm_it).fi;auto &&v = (*forrm_it).se;\n#endif\n#define fors_init(v, ...) auto &&v = (*it);\n\n#ifdef use_for\n#define forlr_init(a, A, ngl, ngr) auto a = A[forlr_i]; auto prev = forlr_i ? A[forlr_i-1] : ngl;auto next = forlr_i+1< rep2lim? A[forlr_i+1] : ngr;\n#define forslr_init4(a, A, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init5(a, A, r, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init6(a, A, l, r, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init(...)  over6(__VA_ARGS__,forslr_init6,forslr_init5,forslr_init4)(__VA_ARGS__);\n#endif\n\n#define fora_2(a, A) for(auto&& a : A)\n#define fora_3(fora_i, a, A) rep(fora_i, sz(A))\n#define fora_4(a, b, A, B) rep(fora_i, sz(A))\n#define fora_5(fora_i, a, b, A, B) rep(fora_i, sz(A))\n#define fora_6(a, b, c, A, B, C) rep(fora_i, sz(A))\n#define fora_7(fora_i, a, b, c, A, B, C) rep(fora_i, sz(A))\n#define fora_8(a, b, c, d, A, B, C, D) rep(fora_i, sz(A))\n#define fora_9(fora_i, a, b, c, d, A, B, C, D) rep(fora_i, sz(A))\n\n#ifdef use_for\n#define forr_2(a, A) rer(forr_i, sz(A)-1)\n#define forr_3(forr_i, a, A) rer(forr_i, sz(A)-1)\n#define forr_4(a, b, A, B) rer(forr_i, sz(A)-1)\n#define forr_5(forr_i, a, b, A, B) rer(forr_i, sz(A)-1)\n#define forr_6(a, b, c, A, B, C) rer(forr_i, sz(A)-1)\n#define forr_7(forr_i, a, b, c, A, B, C) rer(forr_i, sz(A)-1)\n#define forr_8(a, b, c, d, A, B, C, D) rer(forr_i, sz(A)-1)\n#define forr_9(forr_i, a, b, c, d, A, B, C, D) rer(forr_i, sz(A)-1)\n#endif\n//↑@オーバーロード隔離\n\n//rep系はインデックス、for系は中身\n#define rep(...) over4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rer(...) over4(__VA_ARGS__,rer4,rer3,rer2,)(__VA_ARGS__)\n//char用のrep\n#define repc(i, m, n) for(char i = m,repc3lim=n; i < repc3lim ; ++i)\n//i,j,k...をnまで見る\n#define reps(...) over5(__VA_ARGS__,reps5,reps4,reps3,reps2,)(__VA_ARGS__)\n#define repss(...) over10(__VA_ARGS__, repss10, a, repss8, a, repss6, a, repss4, a, repss2) (__VA_ARGS__)\n//vectorのindexを走査する\n//repv(i,j,vvi)\n#define repv(...) over6(__VA_ARGS__,repv_6,repv_5,repv_4,repv_3,repv_2,)(__VA_ARGS__)\n#define rerv(i, A) for (int i = sz(A)-1; i >= 0 ; i--)\n//repvn(dp) nは次元\n#define repv1(a) repv(i, a)\n#define repv2(a) repv(i, j, a)\n#define repv3(a) repv(i, j, k, a)\n#define repv4(a) repv(i, j, k, l, a)\n\n#define fora(...) over9(__VA_ARGS__, fora_9, fora_8, fora_7, fora_6, fora_5, fora_4, fora_3, fora_2)(__VA_ARGS__)\n#define forr(...) over9(__VA_ARGS__, forr_9, forr_8, forr_7, forr_6, forr_5, forr_4, forr_3, forr_2)(__VA_ARGS__)\n//0~N-2まで見る\n\n#define forar_init(v, rv, A) auto &&v = A[forar_i]; auto && rv = A[forar_i+1];\n#define forar(v, rv, A) rep(forar_i, sz(A) - 1)\n\n//#define forr(v, a) for(auto&& v : makeReversedRange(a))\n//参照を取らない\n#ifdef use_for\ntemplate<class U> vector<U> to1d(vector<U> &a) { return a; }template<class U> auto to1d(vector<vector<U>> &a) {    vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)res.push_back(a2);    return res;}template<class U> vector<U> to1d(vector<vector<vector<U>>> &a) {    vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)for (auto &&a3 : a2) res.push_back(a3);    return res;}template<class U> vector<U> to1d(vector<vector<vector<vector<U>>>> &a) {    vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)for (auto &&a3 : a2) for (auto &&a4 : a3)res.push_back(a4);    return res;}template<class U> vector<U> to1d(vector<vector<vector<vector<vector<U>>>>> &a) {    vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)for (auto &&a3 : a2) for (auto &&a4 : a3)for (auto &&a5 : a4)res.push_back(a5);    return res;}template<class U> vector<U> to1d(vector<vector<vector<vector<vector<vector<U>>>>>> &a) {    vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)for (auto &&a3 : a2) for (auto &&a4 : a3)for (auto &&a5 : a4)for (auto &&a6 : a5)res.push_back(a6);    return res;}\n#define forv(a, b) for(auto a : to1d(b))\n//インデックスを前後含めて走査\n#define ring(i, s, len) for (int i = s, prev = (s == 0) ? len - 1 : s - 1, next = (s == len - 1) ? 0 : s + 1, cou = 0; cou < len; cou++, prev = i, i = next, next = (next == len - 1) ? 0 : next + 1)\n//値と前後を見る\n#define ringv(v, d) index_=0;for (auto prev = d[sz(d)-1],next= (int)d.size()>1?d[1]:d[0],v = d[0]; index_ < sz(d); index_++, prev = v, v = next, next = (index_>=sz(d)-1?d[0]:d[index_+1]))\n// 左右をnext prevで見る 0の左と nの右\n#define forlr(v, d, banpei_l, banpei_r) rep(forlr_i,sz(d))\n#endif\n\n#define form(...) over5(__VA_ARGS__,form5,form4,form3,form2,form1)(__VA_ARGS__)\n#define forrm(...) over5(__VA_ARGS__,forrm5,forrm4,forrm3,forrm2,forrm1)(__VA_ARGS__)\n#define fors(...) over4(__VA_ARGS__,fors4,fors3,fors2,fors1)(__VA_ARGS__)\n#define forslr(...) over6(__VA_ARGS__,forslr6,forslr5,forslr4,forslr3)(__VA_ARGS__)\n#define forp3(k, v, st)  rep(forp_i,sz(st))\n#define forp4(forp_i, k, v, st) rep(forp_i,sz(st))\n#define forp(...) over4(__VA_ARGS__,forp4,forp3)(__VA_ARGS__)\n\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\ntemplate<class T> T MAX() { return numeric_limits<T>::max(); }\ntemplate<class T> T MIN() { return numeric_limits<T>::min(); }\nconstexpr ll inf = (ll) 1e9 + 100;\nconstexpr ll linf = (ll) 1e18 + 100;\nconstexpr dou dinf = (dou) linf * linf;\nconstexpr char infc = '{';\nconst string infs = \"{\";\n\ntemplate<class T> T INF(){return MAX<T>() / 2;}\ntemplate<> signed INF(){return inf;}\ntemplate<> ll INF(){return linf;}\ntemplate<> double INF(){return dinf;}\ntemplate<> char INF(){return infc;}\ntemplate<> string INF(){return infs;}\n\nconst double PI = 3.1415926535897932384626433832795029L;\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((ll)(a).size())\n#define mp make_pair\n#define pb pop_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconstexpr bool ev(ll a) { return !(a & 1); }\nconstexpr bool od(ll a) { return (a & 1); }\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> { public:size_t operator()(const std::pair<signed, signed> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n    template<> class hash<std::pair<ll, ll>> { public:/*大きいllが渡されると、<<32でオーバーフローするがとりあえず問題ないと判断*/size_t operator()(const std::pair<ll, ll> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n}\n//stream まとめ\nistream &operator>>(istream &iss, P &a) {    iss >> a.first >> a.second;    return iss;}template<typename T> istream &operator>>(istream &iss, vector<T> &vec_) {    for (T &x: vec_) iss >> x;    return iss;}template<class T, class U> ostream &operator<<(ostream &os, pair<T, U> p) {    os << p.fi << \" \" << p.se;    return os;}ostream &operator<<(ostream &os, T p) {    os << p.f << \" \" << p.s << \" \" << p.t;    return os;}ostream &operator<<(ostream &os, F p) {    os << p.a << \" \" << p.b << \" \" << p.c << \" \" << p.d;    return os;}template<typename T> ostream &operator<<(ostream &os, vector<T> &vec_) {    for (ll i = 0; i < vec_.size(); ++i)os << vec_[i] << (i + 1 == vec_.size() ? \"\" : \" \");    return os;}template<typename T> ostream &operator<<(ostream &os, vector<vector<T>> &vec_) {    for (ll i = 0; i < vec_.size(); ++i) {        for (ll j = 0; j < vec_[i].size(); ++j) { os << vec_[i][j] << \" \"; }        os << endl;    }    return os;}template<typename T, typename U> ostream &operator<<(ostream &os, map<T, U> &m) {    os << endl;    for (auto &&v:m) os << v << endl;    return os;}template<class T> ostream &operator<<(ostream &os, set<T> s) {    fora(v, s) { os << v << \" \"; }    return os;}template<class T> ostream &operator<<(ostream &os, mset<T> s) {    fora(v, s) { os << v << \" \"; }    return os;}template<class T> ostream &operator<<(ostream &os, deque<T> a) {    fora(v, a)os << v << \" \";    return os;}ostream &operator<<(ostream &os, vector<vector<char>> &vec_) {    rep(h, sz(vec_)) {        rep(w, sz(vec_[0])) { os << vec_[h][w]; }        os << endl;    }    return os;}\n//template<class T,class U>ostream &operator<<(ostream &os, vector<pair<T,U>>& a) {fora(v,a)os<<v<<endl;return os;}\ntemplate<typename W, typename H> void resize(W &vec_, const H head) { vec_.resize(head); }\ntemplate<typename W, typename H, typename ... T> void resize(W &vec_, const H &head, const T ... tail) {vec_.resize(head);for (auto &v: vec_)resize(v, tail...);}\n#define use_for_each  //_each _all_of _any_of _none_of _find_if _rfind_if _contains _count_if _erase_if _entry_if\n#ifdef use_for_each\ntemplate<typename T, typename F> bool all_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool all_of2(const vector<T> &v, F f) {rep(i, sz(v)) { if (!all_of2(v[i], f))return false; }return true;}\ntemplate<typename T, typename F> bool any_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool any_of2(const vector<T> &v, F f) {    rep(i, sz(v)) { if (any_of2(v[i], f))return true; }    return false;}\ntemplate<typename T, typename F> bool none_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool none_of2(const vector<T> &v, F f) {    rep(i, sz(v)) { if (none_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool find_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll find_if2(const vector<T> &v, F f) {    rep(i, sz(v)) { if (find_if2(v[i], f))return i; }    return sz(v);}\ntemplate<typename T, typename F> bool rfind_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll rfind_if2(const vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (rfind_if2(v[i], f))return i; }    return -1;}\ntemplate<class T> bool contains(string &s, const T &v) { return s.find(v) != string::npos; }\ntemplate<typename T> bool contains(const vector<T> &v, const T &val) { return std::find(v.begin(), v.end(), val) != v.end(); }\ntemplate<typename T, typename F> bool contains_if2(const vector<T> &v, F f) { return find_if(v.begin(), v.end(), f) != v.end(); }\ntemplate<typename T, typename F> ll count_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll count_if2(const vector<T> &vec_, F f) {    ll ret = 0;    fora(v, vec_)ret += count_if2(v, f);    return ret;}\n//template<typename T, typename F> void for_each2(T &v, F f) { f(v); }\n//template<typename T, typename F> void for_each2(vector<T> &vec_, F f) { fora(v, vec_)for_each2(v, f); }\ntemplate<typename T, typename F> void for_each2(vector<T> &a, F f) { rep(i, sz(a))f(a[i]); }\ntemplate<typename T, typename F> void for_each2(vector<vector<T> > &a, F f) { rep(i, sz(a))rep(j, sz(a[i]))f(a[i][j]); }\ntemplate<typename T, typename F> void for_each2(vector<vector<vector<T> > > &a, F f) { rep(i, sz(a))rep(j, sz(a[i]))rep(k, sz(a[i][j]))f(a[i][j][k]); }\n\ntemplate<typename W> ll count_od(const vector<W> &a) { return count_if2(a, [](ll v) { return v & 1; }); }\ntemplate<typename W> ll count_ev(const vector<W> &a) { return count_if2(a, [](ll v) { return !(v & 1); }); }\n//削除した後のvectorを返す\ntemplate<typename T, typename F> vector<T> erase_if2(const vector<T> &v, F f) {    vector<T> nv;    rep(i, sz(v)) { if (!f(v[i])) { nv.push_back(v[i]); }}    return nv;}\ntemplate<typename T, typename F> vector<vector<T>> erase_if2(const vector<vector<T>> &v, F f) {    vector<vector<T>> res;    rep(i, sz(v)) { res[i] = erase_if2(v[i], f); }    return res;}\ntemplate<typename T, typename F> vector<T> l_erase_if2(const vector<T> &v, F f) {    vector<T> nv;    rep(i, sz(v)) { if (!f(v[i])) { nv.push_back(v[i]); }}    return nv;}\n\ntemplate<typename T, typename F> ll l_rfind_if(const vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (f(v[i]))return i; }    return -1;}\ntemplate<typename T, typename F> bool l_contains_if(const vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (f(v[i]))return true; }    return false;}\ntemplate<class A, class B, class C> auto t_all_of(A a, B b, C c) { return std::all_of(a, b, c); }\ntemplate<class A, class B, class C> auto t_any_of(A a, B b, C c) { return std::any_of(a, b, c); }\ntemplate<class A, class B, class C> auto t_none_of(A a, B b, C c) { return std::none_of(a, b, c); }\ntemplate<class A, class B, class C> auto t_find_if(A a, B b, C c) { return std::find_if(a, b, c); }\ntemplate<class A, class B, class C> auto t_count_if(A a, B b, C c) { return std::count_if(a, b, c); }\n\n#define all_of_s__2(a, right) (t_all_of(all(a),lamr(right)))\n#define all_of_s__3(a, v, siki) (t_all_of(all(a),[&](auto v){return siki;}))\n#define all_of_s(...) over3(__VA_ARGS__,all_of_s__3,all_of_s__2)(__VA_ARGS__)\n\n//all_of(A, %2);\n//all_of(A, a, a%2);\n#define all_of__2(a, right) all_of2(a,lamr(right))\n#define all_of__3(a, v, siki) all_of2(a,[&](auto v){return siki;})\n#define all_of(...) over3(__VA_ARGS__,all_of__3,all_of__2)(__VA_ARGS__)\n#define all_of_f(a, f) all_of2(a,f)\n\n#define any_of_s__2(a, right) (t_any_of(all(a),lamr(right)))\n#define any_of_s__3(a, v, siki) (t_any_of(all(a),[&](auto v){return siki;}))\n#define any_of_s(...) over3(__VA_ARGS__,any_of_s__3,any_of_s__2)(__VA_ARGS__)\n\n#define any_of__2(a, right) any_of2(a,lamr(right))\n#define any_of__3(a, v, siki) any_of2(a,[&](auto v){return siki;})\n#define any_of(...) over3(__VA_ARGS__,any_of__3,any_of__2)(__VA_ARGS__)\n#define any_of_f(a, f) any_of2(a,f)\n\n#define none_of_s__2(a, right) (t_none_of(all(a),lamr(right)))\n#define none_of_s__3(a, v, siki) (t_none_of(all(a),[&](auto v){return siki;}))\n#define none_of_s(...) over3(__VA_ARGS__,none_of_s__3,none_of_s__2)(__VA_ARGS__)\n\n#define none_of__2(a, right) none_of2(a,lamr(right))\n#define none_of__3(a, v, siki) none_of2(a,[&](auto v){return siki;})\n#define none_of(...) over3(__VA_ARGS__,none_of__3,none_of__2)(__VA_ARGS__)\n#define none_of_f(a, f) none_of2(a,f)\n\n#define find_if_s__2(a, right) (t_find_if(all(a),lamr(right))-a.begin())\n#define find_if_s__3(a, v, siki) (t_find_if(all(a),[&](auto v){return siki;})-a.begin())\n#define find_if_s(...) over3(__VA_ARGS__,find_if_s__3,find_if_s__2)(__VA_ARGS__)\n\n#define find_if__2(a, right) find_if2(a,lamr(right))\n#define find_if__3(a, v, siki) find_if2(a,[&](auto v){return siki;})\n#define find_if(...) over3(__VA_ARGS__,find_if__3,find_if__2)(__VA_ARGS__)\n#define find_if_f(a, f) find_if2(a,f)\n\n#define rfind_if_s__2(a, right) l_rfind_if(a, lamr(right))\n#define rfind_if_s__3(a, v, siki) l_rfind_if(a, [&](auto v){return siki;})\n#define rfind_if_s(...) over3(__VA_ARGS__,rfind_if_s__3,rfind_if_s__2)(__VA_ARGS__)\n\n#define rfind_if__2(a, right) rfind_if2(a,lamr(right))\n#define rfind_if__3(a, v, siki) rfind_if2(a,[&](auto v){return siki;})\n#define rfind_if(...) over3(__VA_ARGS__,rfind_if__3,rfind_if__2)(__VA_ARGS__)\n#define rfind_if_f(a, f) rfind_if2(a,f)\n\n#define contains_if_s__2(a, right) l_contains_if(a, lamr(right))\n#define contains_if_s__3(a, v, siki) l_contains_if(a, [&](auto v){return siki;})\n#define contains_if_s(...) over3(__VA_ARGS__,contains_if_s__3,contains_if_s__2)(__VA_ARGS__)\n\n#define contains_if__2(a, right) contains_if2(a,lamr(right))\n#define contains_if__3(a, v, siki) contains_if2(a,[&](auto v){return siki;})\n#define contains_if(...) over3(__VA_ARGS__,contains_if__3,contains_if__2)(__VA_ARGS__)\n#define contains_if_f(a, f) contains_if2(a,f)\n\n#define count_if_s__2(a, right) (t_count_if(all(a),lamr(right)))\n#define count_if_s__3(a, v, siki) (t_count_if(all(a),[&](auto v){return siki;}))\n#define count_if_s(...) over3(__VA_ARGS__,count_if_s__3,count_if_s__2)(__VA_ARGS__)\n\n#define count_if__2(a, right) count_if2(a,lamr(right))\n#define count_if__3(a, v, siki) count_if2(a,[&](auto v){return siki;})\n#define count_if(...) over3(__VA_ARGS__,count_if__3,count_if__2)(__VA_ARGS__)\n#define count_if_f(a, f) count_if2(a,f)\n\n//vector<vi>で、viに対して操作\n#define for_each_s__2(a, right) do{fora(v,a){v right;}}while(0)\n#define for_each_s__3(a, v, shori) do{fora(v,a){shori;}}while(0)\n#define for_each_s(...) over3(__VA_ARGS__,for_each_s__3,for_each_s__2)(__VA_ARGS__)\n\n//vector<vi>で、intに対して操作\n#define for_each__2(a, right) for_each2(a,lamr(right))\n#define for_each__3(a, v, shori) for_each2(a,[&](auto& v){shori;})\n#define for_each(...) over3(__VA_ARGS__,for_each__3,for_each__2)(__VA_ARGS__)\n#define for_each_f(a, f) for_each2(a, f);\n\n#define for_eached__2(a, right) [&](auto a) {auto b = a;for_each(b, right);return b; }(a)\n#define for_eached__3(a, v, shori) [&](auto a) {auto b = a;for_each(b, v, shori);return b; }(a)\n#define for_eached(...) over3(__VA_ARGS__,for_eached__3,for_eached__2)(__VA_ARGS__)\n#define for_eached_f(a, f) for_eached2(a, f);\n\n\n#define erase_if_s__2(a, right) l_erase_if2(a,lamr(right))\n#define erase_if_s__3(a, v, siki) l_erase_if2(a,[&](auto v){return siki;})\n#define erase_if_s(...) over3(__VA_ARGS__,erase_if_s__3,erase_if_s__2)(__VA_ARGS__)\n\n\n#define erase_if__2(a, right) erase_if2(a,lamr(right))\n#define erase_if__3(a, v, siki) erase_if2(a,[&](auto v){return siki;})\n#define erase_if(...) over3(__VA_ARGS__,erase_if__3,erase_if__2)(__VA_ARGS__)\n#define erase_if_f(a, f) erase_if2(a,f)\n\n#define entry_if_s__2(a, right) l_entry_if2(a,lamr(right))\n#define entry_if_s__3(a, v, siki) l_entry_if2(a,[&](auto v){return siki;})\n#define entry_if_s(...) over3(__VA_ARGS__,entry_if_s__3,entry_if_s__2)(__VA_ARGS__)\n\n\n#define entry_if__2(a, right) entry_if2(a,lamr(right))\n#define entry_if__3(a, v, siki) entry_if2(a,[&](auto v){return siki;})\n#define entry_if(...) over3(__VA_ARGS__,entry_if__3,entry_if__2)(__VA_ARGS__)\n#define entry_if_f(a, f) entry_if2(a,f)\n\n#endif\n\ntemplate<class T, class U, class W> void replace(vector<W> &a, T key, U v) { rep(i, sz(a))if (a[i] == key)a[i] = v; }\ntemplate<class T, class U, class W> void replace(vector<vector<W>> &A, T key, U v) { rep(i, sz(A))replace(A[i], key, v); }\nvoid replace(str &a, char key, str v) { if (v == \"\")a.erase(remove(all(a), key), a.end()); }\nvoid replace(str &a, char key, char v) { replace(all(a), key, v); }\n//keyと同じかどうか01で置き換える\ntemplate<class T, class U> void replace(vector<T> &a, U k) { rep(i, sz(a)) a[i] = a[i] == k; }\ntemplate<class T, class U> void replace(vector<vector<T >> &a, U k) { rep(i, sz(a))rep(j, sz(a[0])) a[i][j] = a[i][j] == k; }\n//template<class T> void replace(T &a) { replace(a, '#'); }\nvoid replace(str &a) {    int dec = 0;    if ('a' <= a[0] && a[0] <= 'z')dec = 'a';    if ('A' <= a[0] && a[0] <= 'Z')dec = 'A';    fora(v, a)v -= dec;}\nvoid replace(str &a, str key, str v) {    stringstream t;    ll kn = sz(key);    std::string::size_type Pos(a.find(key));    ll l = 0;    while (Pos != std::string::npos) {        t << a.substr(l, Pos - l);        t << v;        l = Pos + kn;        Pos = a.find(key, Pos + kn);    }    t << a.substr(l, sz(a) - l);    a = t.str();}\n\ntemplate<class T> bool includes(vector<T> &a, vector<T> &b) {    vi c = a;    vi d = b;    sort(all(c));    sort(all(d));    return includes(all(c), all(d));}\ntemplate<class T> bool is_permutation(vector<T> &a, vector<T> &b) { return is_permutation(all(a), all(b)); }\ntemplate<class T> bool next_permutation(vector<T> &a) { return next_permutation(all(a)); }\nvoid iota(vector<ll> &ve, ll s, ll n) {    ve.resize(n);    iota(all(ve), s);}\nvi iota(ll s, ll len) {    vi ve(len);    iota(all(ve), s);    return ve;}\ntemplate<class A, class B> auto vtop(vector<A> &a, vector<B> &b) {    assert(sz(a) == sz(b));    /*stringを0で初期化できない  */  vector<pair<A, B>> res;    rep(i, sz(a))res.eb(a[i], b[i]);    return res;}\ntemplate<class A, class B> void ptov(vector<pair<A, B>> &p, vector<A> &a, vector<B> &b) {    a.resize(sz(p)), b.resize(sz(p));    rep(i, sz(p))a[i] = p[i].fi, b[i] = p[i].se;}\ntemplate<class A, class B, class C> auto vtot(vector<A> &a, vector<B> &b, vector<C> &c) {    assert(sz(a) == sz(b) && sz(b) == sz(c));    vector<T2<A, B, C>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i]);    return res;}\ntemplate<class A, class B, class C, class D> auto vtof(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    assert(sz(a) == sz(b) && sz(b) == sz(c) && sz(c) == sz(d));    vector<F2<A, B, C, D>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i], d[i]);    return res;}\n\ntemplate<class T> void sort(vector<T> &a) { sort(all(a)); }\ntemplate<class T> void rsort(vector<T> &a) { sort(all(a), greater<T>()); };\ntemplate<class A, class B> void sortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    sort(c);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}\ntemplate<class A, class B> void rsortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    rsort(c);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}\ntemplate<class A, class B, class C> void sortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    sort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    rsort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class... T, class U> auto sorted(U head, T... a) {    sort(head, a...);    return head;}\ntemplate<class... T, class U> auto rsorted(U head, T... a) {    rsort(head, a...);    return head;}\n//sortindex 元のvectorはソートしない\ntemplate<class T> vi sorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind);    return ind;}\n//#define use_sort\n#ifdef use_sort\nenum pcomparator { fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd };\nenum tcomparator {    fisiti,    fisitd,    fisdti,    fisdtd,    fdsiti,    fdsitd,    fdsdti,    fdsdtd,    fitisi,    fitisd,    fitdsi,    fitdsd,    fdtisi,    fdtisd,    fdtdsi,    fdtdsd,    sifiti,    sifitd,    sifdti,    sifdtd,    sdfiti,    sdfitd,    sdfdti,    sdfdtd,    sitifi,    sitifd,    sitdfi,    sitdfd,    sdtifi,    sdtifd,    sdtdfi,    sdfdfd,    tifisi,    tifisd,    tifdsi,    tifdsd,    tdfisi,    tdfisd,    tdfdsi,    tdfdsd,    tisifi,    tisifd,    tisdfi,    tisdfd,    tdsifi,    tdsifd,    tdsdfi,    tdsdfd};\ntemplate<class A, class B> void sort(vector<pair<A, B>> &a, pcomparator type) {    typedef pair<A, B> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; }); else if (type == fisd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; }); else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; }); else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; }); else if (type == sifi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; }); else if (type == sifd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; }); else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; }); else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });};\ntemplate<class U> void sort(vector<U> &a, pcomparator type) { if (type == fisi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s < r.s; }); else if (type == fisd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s > r.s; }); else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s < r.s; }); else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s > r.s; }); else if (type == sifi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f < r.f; }); else if (type == sifd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f > r.f; }); else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f < r.f; }); else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f > r.f; }); };\ntemplate<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D> > &a, pcomparator type) {    typedef F2<A, B, C, D> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b < r.b; }); else if (type == fisd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b > r.b; }); else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b < r.b; }); else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b > r.b; }); else if (type == sifi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a < r.a; }); else if (type == sifd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a > r.a; }); else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a < r.a; }); else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a > r.a; });};\ntemplate<class U> void sort(vector<U> &a, tcomparator type) {    if (type == 0) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f < r.f; }); else if (type == 41) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f > r.f; }); else if (type == 42) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f < r.f; }); else if (type == 43) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f > r.f; }); else if (type == 44) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f < r.f; }); else if (type == 45) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f > r.f; }); else if (type == 46) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f < r.f; }); else if (type == 47) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });}\ntemplate<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D>> &a, tcomparator type) {    typedef F2<A, B, C, D> U;    if (type == 0) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a < r.a; }); else if (type == 41) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a > r.a; }); else if (type == 42) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a < r.a; }); else if (type == 43) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a > r.a; }); else if (type == 44) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a < r.a; }); else if (type == 45) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a > r.a; }); else if (type == 46) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a < r.a; }); else if (type == 47) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });}\n\nvoid sort(string &a) { sort(all(a)); }\nvoid sort(int &a, int &b) { if (a > b)swap(a, b); }\nvoid sort(int &a, int &b, int &c) {    sort(a, b);    sort(a, c);    sort(b, c);}\nvoid rsort(int &a, int &b) { if (a < b)swap(a, b); }\nvoid rsort(int &a, int &b, int &c) {    rsort(a, b);    rsort(a, c);    rsort(b, c);}\n//P l, P rで f(P) の形で渡す\ntemplate<class U, class F> void sort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) < f(r); }); };\ntemplate<class U, class F> void rsort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) > f(r); }); };\n\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class A, class B, class F> void sortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    sort(c, f);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}\ntemplate<class A, class B, class F> void rsortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    rsort(c, f);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}\ntemplate<class A, class B, class C, class F> void sortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    sort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class F> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    rsort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class D> void sortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    sort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\ntemplate<class A, class B, class C, class D> void rsortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    rsort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\n/*indexの分で型が変わるためpcomparatorが必要*/\ntemplate<class T> vi sorti(vector<T> &a, pcomparator f) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind, f);    return ind;}\ntemplate<class T, class F> vi sorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(a[x]) < f(a[y]); });    return ind;}\ntemplate<class T> vi rsorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    rsortp(b, ind);    return ind;}\ntemplate<class T, class F> vi rsorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(a[x]) > f(a[y]); });    return ind;}\ntemplate<class A, class B, class F> vi sortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(c[x]) < f(c[y]); });    return ind;}\ntemplate<class A, class B> vi sortpi(vector<A> &a, vector<B> &b, pcomparator f) {    vi ind = iota(0, sz(a));    auto c = a;    auto d = b;    sortt(c, d, ind, f);    return ind;}\ntemplate<class A, class B> vi sortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fisi); };\ntemplate<class A, class B, class F> vi rsortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(c[x]) > f(c[y]); });    return ind;}\ntemplate<class A, class B> vi rsortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fdsd); };\ntemplate<class A, class B, class C, class F> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(d[x]) < f(d[y]); });    return ind;}\ntemplate<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, pcomparator f) {    vi ind = iota(0, sz(a));    auto d = vtof(a, b, c, ind);    sort(d, f);    rep(i, sz(a))ind[i] = d[i].d;    return ind;}\ntemplate<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { if (a[x] == a[y]) { if (b[x] == b[y])return c[x] < c[y]; else return b[x] < b[y]; } else { return a[x] < a[y]; }});    return ind;}\ntemplate<class A, class B, class C, class F> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(d[x]) > f(d[y]); });    return ind;}\ntemplate<class A, class B, class C> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { if (a[x] == a[y]) { if (b[x] == b[y])return c[x] > c[y]; else return b[x] > b[y]; } else { return a[x] > a[y]; }});    return ind;}\ntemplate<class T> void sort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)sort(a[i]); }\ntemplate<class T> void rsort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)rsort(a[i]); }\n\n#endif\ntemplate<typename W, typename T> void fill(W &xx, const T vall) { xx = vall; }\ntemplate<typename W, typename T> void fill(vector<W> &vecc, const T vall) { for (auto &&vx     : vecc)fill(vx, vall); }\n//#define use_fill //_sum _array _max _min\n#ifdef use_fill\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\ntemplate<class T, class U> void fill(vector<T> &a, const vi &ind, U val) { fora(v, ind)a[v] = val; }\ntemplate<typename W, typename T> void fill(vector<W> &xx, ll len, const T v) { rep(i, len)xx[i] = v; }\ntemplate<typename W, typename T> void fill(vector<vector<W>> &xx, int sh, int th, int sw, int tw, T v) { rep(h, sh, th)rep(w, sw, tw)xx[h][w] = v; }\ntemplate<typename A, size_t N> A sum(A (&a)[N]) {    A res = 0;    rep(i, N)res += a[i];    return res;}\ntemplate<typename A, size_t N, size_t O> A sum(A (&a)[N][O]) {    A res = 0;    rep(i, N)rep(j, O)res += a[i][j];    return res;}\ntemplate<typename A, size_t N, size_t O, size_t P> A sum(A (&a)[N][O][P]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)res += a[i][j][k];    return res;}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q> A sum(A (&a)[N][O][P][Q]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)res += a[i][j][k][l];    return res;}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A sum(A (&a)[N][O][P][Q][R]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)res += a[i][j][k][l][m];    return res;}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A sum(A (&a)[N][O][P][Q][R][S]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)res += a[i][j][k][l][m][n];    return res;}\n\ntemplate<typename A, size_t N> A max(A (&a)[N]) {    A res = a[0];    rep(i, N)res = max(res, a[i]);    return res;}template<typename A, size_t N, size_t O> A max(A (&a)[N][O]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P> A max(A (&a)[N][O][P]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A max(A (&a)[N][O][P][Q], const T &v) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A max(A (&a)[N][O][P][Q][R]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A max(A (&a)[N][O][P][Q][R][S]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}\ntemplate<typename A, size_t N> A min(A (&a)[N]) {    A res = a[0];    rep(i, N)res = min(res, a[i]);    return res;}template<typename A, size_t N, size_t O> A min(A (&a)[N][O]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P> A min(A (&a)[N][O][P]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A min(A (&a)[N][O][P][Q], const T &v) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A min(A (&a)[N][O][P][Q][R]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A min(A (&a)[N][O][P][Q][R][S]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}\n#endif\n\n//@汎用便利関数 入力\nll in() {    ll ret;    cin >> ret;    return ret;}\ntemplate<class T> T in() {    T ret;    cin >> ret;    return ret;}\nstring sin() {    string ret;    cin >> ret;    return ret;}\ntemplate<class T> void in(T &head) { cin >> head; }\ntemplate<class T, class... U> void in(T &head, U &... tail) {    cin >> head;    in(tail...);}\n#define din_t2(type, a) type a;cin>>a\n#define din_t3(type, a, b) type a,b;cin>>a>> b\n#define din_t4(type, a, b, c) type a,b,c;cin>>a>>b>>c\n#define din_t5(type, a, b, c, d) type a,b,c,d;cin>>a>>b>>c>>d\n#define din_t6(type, a, b, c, d, e) type a,b,c,d,e;cin>>a>>b>>c>>d>>e\n#define din_t7(type, a, b, c, d, e, f) type a,b,c,d,e,f;cin>>a>>b>>c>>d>>e>>f\n#define din_t(...) over7(__VA_ARGS__,din_t7,din_t6,din_t5,din_t4,din_t3 ,din_t2)(__VA_ARGS__)\n\n#define din(...) din_t(int,__VA_ARGS__)\n#define d_in\n#define dsig(...) din_t(signed,__VA_ARGS__)\n\n#define dst(...) din_t(string,__VA_ARGS__)\n#define dstr dst\n#define d_str dst\n\n#define dcha(...) din_t(char,__VA_ARGS__)\n#define dchar dcha\n\n#define ddou(...) din_t(double,__VA_ARGS__)\n\n\n#define din1d(a) din_t2(int, a);a--\n#define din2d(a, b) din_t3(int, a,b);a--,b--\n#define din3d(a, b, c) din_t4(int, a,b,c);a--,b--,c--\n#define din4d(a, b, c, d) din_t5(int, a,b,c,d);a--,b--,c--,d--\n#define dind(...) over4(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\n\n#ifdef _DEBUG\ntemplate<class T> void err2(T &&head) { cerr << head; }\ntemplate<class T, class... U> void err2(T &&head, U &&... tail) {    cerr << head << \" \";    err2(tail...);}\ntemplate<class T, class... U> void err(T &&head, U &&... tail) {    cerr << head << \" \";    err2(tail...);    cerr << \"\" << endl;}\ntemplate<class T> void err(T &&head) { cerr << head << endl; }\nvoid err() { cerr << \"\" << endl; }\ntemplate<class T> string out_m2(vector<T> &a, ll W = inf) {    stringstream ss;    if (W == inf)W = min(sz(a), 20ll);    if (sz(a) == 0)return ss.str();    rep(i, W) {        ss << a[i];        if (typeid(a[i]) == typeid(P)) { ss << endl; } else { ss << \" \"; }    }    return ss.str();}\ntemplate<class T> string out_m2(vector<vector<T> > &a, vi H, vi W, int key = -1) {    stringstream ss;    ss << endl;    vi lens(sz(W));    fora(h, H) {        rep(wi, sz(W)) {            int v = a[h][W[wi]];            str s = tos(v);            if (abs(v) == inf || abs(v) == linf)s = \"e\";            lens[wi] = max(lens[wi], sz(s) + 1);            lens[wi] = max(lens[wi], sz(tos(W[wi])) + 1);        }    }    if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";    int wi = 0;    fora(w, W) {        ss << std::right << std::setw(lens[wi]) << w;        wi++;    }    ss << \"\" << endl;    rep(i, sz(W))rep(lens[i])ss << \"_\";    rep(i, 3)ss << \"_\";    ss << \"\" << endl;    fora(h, H) {        ss << std::right << std::setw(2) << h << \"|\";        int wi = 0;        fora(w, W) {            str s = tos(a[h][w]);            if (abs(a[h][w]) == inf || abs(a[h][w]) == linf)s = \"e\";            ss << std::right << std::setw(lens[wi]) << s;            wi++;        }        ss << \"\" << endl;    }    return ss.str();}\ntemplate<class T> string out_m2(vector<vector<T> > &a, ll H = inf, ll W = inf, int key = -1) {    H = (H != inf) ? H : min({H, sz(a), 12ll});    W = min({W, sz(a[0]), 12ll});    vi hs, ws;    rep(h, H) { hs.push_back(h); }    rep(w, W) { ws.push_back(w); }    return out_m2(a, hs, ws, key);}\ntemplate<class T> string out_m2(vector<set<T> > &a, ll H = inf, ll W = inf, int key = -1) {    vector<vector<T> > b(sz(a));    rep(i, sz(a)) { fora(v, a[i]) { b[i].push_back(v); }}    return out_m2(b, H, W, key);}\ntemplate<class T> string out_m2(vector<vector<vector<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {    stringstream ss;    if (H == inf)H = 12;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << out_m2(a[i], W, U, i);    }    return ss.str();}\ntemplate<class T, size_t N> string out_m2(T (&a)[N]) {    vector<T> b;    resize(b, N);    rep(i, N) { b[i] = a[i]; }    return out_m2(b);}\ntemplate<class T, size_t N, size_t M> string out_m2(T (&a)[N][M]) {    vector<vector<T>> b;    resize(b, N, M);    rep(i, N) { rep(j, M) { b[i][j] = a[i][j]; }}    return out_m2(b);}\ntemplate<class T, size_t N, size_t M, size_t O> string out_m2(T (&a)[N][M][O]) {    vector<vector<vector<T>>> b;    resize(b, N, M, O);    rep(i, N) { rep(j, M) { rep(k, O) { b[i][j][k] = a[i][j][k]; }}}    return out_m2(b);}\nstring out_m2(int a) {    stringstream ss;    ss << a;    return ss.str();}\ntemplate<class T> string out_m2(T &a) {    stringstream ss;    ss << a;    return ss.str();}\ntemplate<class T> string out_m(vector<T> &a, ll W = inf) {    stringstream ss;    if (W == inf)W = min(sz(a), 12ll);    if (sz(a) == 0)return ss.str();    rep(i, W) { ss << a[i] << \" \"; }    ss << \"\" << endl;    return ss.str();}\ntemplate<class T> string out_m(vector<vector<T> > &a, ll H = inf, ll W = inf, int key = -1) {    H = min({H, sz(a), 12ll});    W = min({W, sz(a[0]), 12ll});    stringstream ss;    ss << endl;    if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";    rep(w, W)ss << std::right << std::setw(4) << w;    ss << \"\" << endl;    rep(w, W * 4 + 3)ss << \"_\";    ss << \"\" << endl;    rep(h, H) {        ss << std::right << std::setw(2) << h << \"|\";        rep(w, min(sz(a[h]), 12ll)) { if (abs(a[h][w]) == linf) ss << \"   e\" << \"\"; else ss << std::right << std::setw(4) << a[h][w]; }        ss << \"\" << endl;    }    ss << endl;    return ss.str();}\ntemplate<class T> string out_m(vector<vector<vector<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {    stringstream ss;    if (H == inf)H = 5;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << out_m(a[i], W, U, i);    }    ss << endl;    return ss.str();}\nstring out_m(int a) {    stringstream ss;    ss << a << endl;    return ss.str();}\ntemplate<class T> string out_m(T &a) {    stringstream ss;    ss << a << endl;    return ss.str();}\ntemplate<class T> void outv(vector<T> &a, ll W = inf) { cout << out_m(a, W) << endl; }\ntemplate<class T> void outv(vector<vector<T> > &a, ll H = linf, ll W = linf, int key = -1) { cout << out_m(a, H, W, key) << endl; }\ntemplate<class T> void outv(vector<vector<vector<T> > > &a, ll H = linf, ll W = linf, ll U = linf) { cout << out_m(a, H, W, U) << endl; }\n\ntemplate<class T> void out2(T head) {    cout << head;    res_mes += out_m2(head);}\ntemplate<class T, class... U> void out2(T head, U ... tail) {    cout << head << \" \";    res_mes += out_m2(head) + \" \";    out2(tail...);}\ntemplate<class T, class... U> void out(T head, U ... tail) {    cout << head << \" \";    res_mes += out_m2(head) + \" \";    out2(tail...);    cout << \"\" << endl;    res_mes += \"\\n\";}\ntemplate<class T> void out(T head) {    cout << head << endl;    res_mes += out_m2(head) + \"\\n\";}\nvoid out() { cout << \"\" << endl; }\n\n#else\ntemplate<class T> void outv(vector<T> &a, ll W = inf) {    rep(i, min(W, sz(a))) { cout << a[i] << \" \"; }    cout << \"\" << endl;}\ntemplate<class T> void outv(vector<vector<T> > &a, ll H = linf, ll W = linf, int key = -1) { rep(i, min(H, sz(a))) { outv(a[i], W); }}\ntemplate<class T> void outv(vector<vector<vector<T> > > &a, ll H = linf, ll W = linf, ll U = linf) { ; }\n#define err(...);\n\ntemplate<class T> void out2(T &&head) { cout << head; }\ntemplate<class T, class... U> void out2(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);}\ntemplate<class T, class... U> void out(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);    cout << \"\" << endl;}\ntemplate<class T> void out(T &&head) {    cout << head  << endl;}\nvoid out() {    cout << \"\"  << endl;}\n\n#endif\n\n\n\ntemplate<class T> void outl(vector<T> &a, int n = inf) { rep(i, min(n, sz(a)))cout << a[i] << endl; }\n//テーブルをスペースなしで出力\ntemplate<class T> void outt(vector<vector<T>> &a) {rep(i, sz(a)) {rep(j, sz(a[i])) { cout << a[i][j]; }cout << endl;}}\n//int型をbit表記で出力\nvoid outb(int a) { cout << bitset<20>(a) << endl; }\ntemplate<class T> void na(vector<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i];}\ntemplate<class T> void na(set<T> &a, ll n) { rep(i, n)a.insert(in()); }\n#define dna(a, n) vi a; na(a, n);/*nを複数使うと n==in()の時バグる事に注意*/\n#define dnad(a, n) vi a; nad(a, n);\ntemplate<class T> void nao(vector<T> &a, ll n) {a.resize(n + 1);a[0] = 0;rep(i, n)cin >> a[i + 1];}\ntemplate<class T> void naod(vector<T> &a, ll n) {a.resize(n + 1);a[0] = 0;rep(i, n)cin >> a[i + 1], a[i + 1]--;}\ntemplate<class T> void nad(vector<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i], a[i]--;}\ntemplate<class T> void nad(set<T> &a, ll n) { rep(i, n)a.insert(in() - 1); }\ntemplate<class T, class U> void na2(vector<T> &a, vector<U> &b, ll n) {a.resize(n);b.resize(n);rep(i, n)cin >> a[i] >> b[i];}\ntemplate<class T, class U> void na2(set<T> &a, set<U> &b, ll n) {rep(i, n) {a.insert(in());b.insert(in());}}\n#define dna2(a, b, n) vi a,b; na2(a,b,n);\ntemplate<class T, class U> void nao2(vector<T> &a, vector<U> &b, ll n) {a.resize(n + 1);b.resize(n + 1);a[0] = b[0] = 0;rep(i, n)cin >> a[i + 1] >> b[i + 1];}\ntemplate<class T, class U> void na2d(vector<T> &a, vector<U> &b, ll n) {a.resize(n);b.resize(n);rep(i, n)cin >> a[i] >> b[i], a[i]--, b[i]--;}\n#define dna2d(a, b, n) vi a,b; na2d(a,b,n);\ntemplate<class T, class U, class W> void na3(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {a.resize(n);b.resize(n);c.resize(n);rep(i, n)cin >> a[i] >> b[i] >> c[i];}\n#define dna3(a, b, c, n) vi a,b,c; na3(a,b,c,n);\ntemplate<class T, class U, class W> void na3d(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {a.resize(n);b.resize(n);c.resize(n);rep(i, n)cin >> a[i] >> b[i] >> c[i], a[i]--, b[i]--, c[i]--;}\n#define dna3d(a, b, c, n) vi a,b,c; na3d(a,b,c,n);\ntemplate<class T, class U, class W, class X> void na4(vector<T> &a, vector<U> &b, vector<W> &c, vector<X> &d, ll n) {a.resize(n);b.resize(n);c.resize(n);d.resize(n);rep(i, n)cin >> a[i] >> b[i] >> c[i] >> d[i];}\n#define dna4(a, b, c, d, n)  vi a,b,c,d; na4(a,b,c,d,n);\n#define dna4d(a, b, c, d, n)  vi a,b,c,d; na4d(a,b,c,d,n);\n#define nt(a, h, w) resize(a,h,w);rep(nthi,h)rep(ntwi,w) cin >> a[nthi][ntwi];\n#define ntd(a, h, w) resize(a,h,w);rep(ntdhi,h)rep(ntdwi,w) cin >> a[ntdhi][ntdwi], a[ntdhi][ntdwi]--;\n#define ntp(a, h, w) resize(a,h+2,w+2);fill(a,'#');rep(ntphi,1,h+1)rep(ntpwi,1,w+1) cin >> a[ntphi][ntpwi];\n#define dnt(S, h, w) vvi(S,h,w);nt(S,h,w);\n#define dntc(S, h, w) vvc(S,h,w);nt(S,h,w);\n#define dnts(S, h, w) vvs(S,h,w);nt(S,h,w);\n\n//デバッグ\n#define sp << \" \" <<\n\n#define deb1(x)  debugName(x)<<\" = \"<<out_m2(x)\n#define deb_2(x, ...) deb1(x) <<\", \"<< deb1(__VA_ARGS__)\n#define deb_3(x, ...) deb1(x) <<\", \"<< deb_2(__VA_ARGS__)\n#define deb_4(x, ...) deb1(x) <<\", \"<< deb_3(__VA_ARGS__)\n#define deb5(x, ...) deb1(x) <<\", \"<< deb_4(__VA_ARGS__)\n#define deb6(x, ...) deb1(x) <<\", \"<< deb5(__VA_ARGS__)\n#define deb7(x, ...) deb1(x) <<\", \"<< deb6(__VA_ARGS__)\n#define deb8(x, ...) deb1(x) <<\", \"<< deb7(__VA_ARGS__)\n#define deb9(x, ...) deb1(x) <<\", \"<< deb8(__VA_ARGS__)\n#define deb10(x, ...) deb1(x) <<\", \"<< deb9(__VA_ARGS__)\n\n\n#ifdef _DEBUG\nbool was_deb = false;\n#define deb(...)  do{was_deb=true;cerr<< over10(__VA_ARGS__,deb10,deb9,deb8,deb7,deb6,deb5,deb_4,deb_3,deb_2,deb1)(__VA_ARGS__) <<endl;}while(0)\n\n#define base_keta 8\nvoid print_n_base(int x, int base) { cerr << bitset<base_keta>(x) << endl; }\ntemplate<class T> void print_n_base(vector<T> X, int base) {cerr << endl;for (auto &&x:X) { print_n_base(x, base); }cerr << endl;}\n\n//n進数\n#define deb2(x) was_deb=true;cerr<<debugName(x)<<\" = \";print_n_base(x, 2);\n#define deb3(x) was_deb=true;cerr<<debugName(x)<<\" = \";print_n_base(x, 3);\n#define deb4(x) was_deb=true;cerr<<debugName(x)<<\" = \";print_n_base(x, 4);\n\n#define deb_ex_deb(x, len)  debugName(x)<<\" = \"<<out_m2(x, len)\n#define call_deb_ex_deb(x, len) deb_ex_deb(x, len)\n//要素が存在する行だけ出力(vvt)\n#define deb_ex(v) do {int N = sz(v);int s = N;int t = 0;rep(i, N) {if (sz(v[i])) {chmi(s, i);chma(t, i);}}auto ex_v = sub(v, s, N);str S = out_m2(ex_v, sz(ex_v));debugName(v);cerr<<\" = \"<<endl;cerr << S << endl;} while (0);\ntemplate<class T, class F> string out_m2_f(vector<vector<T> > &a, F f, int key = -1) {    vi hs, ws_;    int H = sz(a), W = sz(a[0]);    vi exh(H), exw(W);    rep(h, H) {        rep(w, W) {            if (f(a[h][w])) {                exh[h] = true;                exw[w] = true;            }        }    }    rep(h, H) if (exh[h])hs.push_back(h);    rep(w, W) if (exw[w])ws_.push_back(w);    return out_m2(a, hs, ws_, key);}\ntemplate<class T, class F> string out_m2_f(vector<vector<vector<T>>> &a, F f) {    stringstream ss;    int H = sz(a);    if (sz(a) == 0)return ss.str();    rep(i, H) { ss << out_m2_f(a[i], f, i); }    ss << \"\" << endl;    return ss.str();}\n#define debf_normal(tab, f) do{cerr<<debugName(tab)<<\" = \"<<endl;cerr<< out_m2_f(tab, f)<<endl;}while(0);\n#define debf2(tab, siki_r) debf_normal(tab, lamr(siki_r))\n#define debf3(tab, v, siki)  debf_normal(tab, lam(siki))\n//S, sikir\n//S, v, siki\n#define debf(...) over3(__VA_ARGS__,debf3,debf2,debf1)(__VA_ARGS__)\n\n#else\n#define deb(...) ;\n#define deb2(...) ;\n#define deb3(...) ;\n#define deb4(...) ;\n#define deb_ex(...) ;\n#define debf(...) ;\n#endif\n\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing u128 = __uint128_t;\n\nusing bint =__int128;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {    std::ostream::sentry s(dest);    if (s) {        __uint128_t tmp = value < 0 ? -value : value;        char buffer[128];        char *d = std::end(buffer);        do {            --d;            *d = \"0123456789\"[tmp % 10];            tmp /= 10;        }        while (tmp != 0);        if (value < 0) {            --d;            *d = '-';        }        ll len = std::end(buffer) - d;        if (dest.rdbuf()->sputn(d, len) != len) { dest.setstate(std::ios_base::badbit); }    }    return dest;}\n__int128 to_bint(string &s) {    __int128 ret = 0;    for (ll i = 0; i < s.length(); ++i) if ('0' <= s[i] && s[i] <= '9') ret = 10 * ret + s[i] - '0';    return ret;}\nvoid operator>>(istream &iss, bint &v) {    string S;    iss >> S;    v = 0;    rep(i, sz(S)) {        v *= 10;        v += S[i] - '0';    }}\n//エラー\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");exit(0);\n#endif\n    string a = \"a\";rep(i, 30)a += a;rep(i, 1 << 17)cout << a << endl;cout << \"OLE 出力長制限超過\" << endl;exit(0);\n}\nvoid re() {assert(0 == 1);exit(0);}\nvoid tle() { while (inf)cout << inf << endl; }\n\n//便利関数\n\n//テスト用\n#define rand xor128_\nunsigned long xor128_(void) {    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;    unsigned long t;    t = (x ^ (x << 11));    x = y;    y = z;    z = w;    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));}\nchar ranc() { return (char) ('a' + rand() % 26); }\nll rand(ll min, ll max) {    assert(min <= max);    if (min >= 0 && max >= 0) { return rand() % (max + 1 - min) + min; } else if (max < 0) { return -rand(-max, -min); } else { if (rand() % 2) { return rand(0, max); } else { return -rand(0, -min); }}}\nll rand(ll max) { return rand(0, max); }\ntemplate<class T> T rand(vector<T> &A) { return A[rand(sz(A) - 1)]; }\n//重複することがある\ntemplate<class T> vector<T> ranv(vector<T>& A, int N){vector<T>ret(N);rep(i,N){ret[i]=rand(A);}return ret;}\ntemplate<class T> vector<T> ranv_unique(vector<T>& A, int N){    vector<T> ret(N);    umapi was;    rep(j,N){        int i;        while(1){            i = rand(sz(A)-1);            if(was.find(i) == was.end())break;        }        ret[j] = A[i];was[i]=1;    }    return ret;}\nvi ranv(ll n, ll min, ll max) {    vi v(n);    rep(i, n)v[i] = rand(min, max);    return v;}\n\n#ifdef _DEBUG\nbool timeup(int time){\n    static bool never = true;\n    if(never)message += \"may timeup, because slow\";\n    never = false;\n\n    auto end_time = system_clock::now();\n    auto part = duration_cast<milliseconds>(end_time - start_time);\n    auto lim = milliseconds(time);\n    return part >= lim;\n}\n#else\nbool timeup(int time) {\n    auto end_time = system_clock::now();\n    auto part = duration_cast<milliseconds>(end_time - start_time);\n    auto lim = milliseconds(time);\n    return part >= lim;\n}\n\n#endif\nvoid set_time() { past_time = system_clock::now(); }\n//MS型(millisecqnds)で返る\n//set_timeをしてからの時間\nauto calc_time_milli() {    auto now = system_clock::now();    auto part = duration_cast<milliseconds>(now - past_time);    return part;}\nauto calc_time_micro() {    auto now = system_clock::now();    auto part = duration_cast<microseconds>(now - past_time);    return part;}\nauto calc_time_nano() {    auto now = system_clock::now();    auto part = duration_cast<nanoseconds>(now - past_time);    return part;}\nbool calc_time(int zikan) { return calc_time_micro() >= microseconds(zikan); }\nusing MS=std::chrono::microseconds;\nint div(microseconds a, microseconds b) { return a / b; }\nint div(nanoseconds a, nanoseconds b) {    if (b < nanoseconds(1)) { return a / nanoseconds(1); }    int v = a / b;    return v;}\n//set_time();\n//rep(i,lim)shori\n\n//lim*=time_nanbai();\n//rep(i,lim)shoriと使う\n//全体でmilliかかっていいときにlimを何倍してもう一回できるかを返す\nint time_nanbai(int milli) {\n    auto dec = duration_cast<nanoseconds>(past_time - start_time);\n    auto part = calc_time_nano();\n    auto can_time = nanoseconds(milli * 1000 * 1000);\n    can_time -= part;\n    can_time -= dec;\n    return div(can_time, part);\n}\n\n//#define use_rand\n#ifdef use_rand\nstr ransu(ll n) {    str s;    rep(i, n)s += (char) rand('A', 'Z');    return s;}\nstr ransl(ll n) {    str s;    rep(i, n)s += (char) rand('a', 'z');    return s;}\n//単調増加\nvi ranvinc(ll n, ll min, ll max) {    vi v(n);    bool bad = 1;    while (bad) {        bad = 0;        v.resize(n);        rep(i, n) {            if (i && min > max - v[i - 1]) {                bad = 1;                break;            }            if (i)v[i] = v[i - 1] + rand(min, max - v[i - 1]); else v[i] = rand(min, max);        }    }    return v;}\n//便利 汎用\n#endif\n\nvoid ranvlr(ll n, ll min, ll max, vi &l, vi &r) {    l.resize(n);    r.resize(n);    rep(i, n) {        l[i] = rand(min, max);        r[i] = l[i] + rand(0, max - l[i]);    }}\ntemplate<class T> vector<pair<T, int>> run_length(vector<T> &a) {    vector<pair<T, int>> ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}    return ret;}\nvector<pair<char, ll>> run_length(const string &a) {    vector<pair<char, ll>> ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}    return ret;}\n//#define use_mgr //_goldd _goldt\n#ifdef use_mgr\ntemplate<class T, class F> T mgr(T ok, T ng, F f, int deb_ = 0) {    bool han = true;    if (deb_) {        if (ok < ng)            while (ng - ok > 1) {                T mid = (ok + ng) >> 1;                if (f(mid))ok = mid, han = true; else ng = mid, han = false;                deb(mid, han);            }        else            while (ok - ng > 1) {                T mid = (ok + ng) >> 1;                if (f(mid))ok = mid, han = true; else ng = mid, han = false;                deb(mid, han);            }    }    else {        if (ok < ng)            while (ng - ok > 1) {                T mid = (ok + ng) >> 1;                if (f(mid))ok = mid, han = true; else ng = mid, han = false;            }        else            while (ok - ng > 1) {                T mid = (ok + ng) >> 1;                if (f(mid))ok = mid, han = true; else ng = mid, han = false;            }    }    return ok;}\ntemplate<class T, class F> T mgr(signed ok, T ng, F f) { return mgr((T) ok, ng, f); }\ntemplate<class T, class F> T mgr(T ok, signed ng, F f) { return mgr(ok, (T) ng, f); }\ntemplate<class F> int mgr(signed ok, signed ng, F f) { return mgr((ll) ok, (ll) ng, f); }\n//[l, r)の中で,f(i)がtrueとなる範囲を返す okはそこに含まれる\ntemplate<class F> P mgr(int l, int r, F f, int ok) {    if (f(ok) == 0) {        out(\"f(ok) must true\");        re();    }    return mp(mgr(ok, l - 1, f), mgr(ok, r, f) + 1);}\n\ntemplate<class F> dou mgrd(dou ok, dou ng, F f, int kai = 100) {    bool han = true;    if (ok < ng)        rep(i, kai) {            dou mid = (ok + ng) / 2;            if (f(mid))ok = mid, han = true; else ng = mid, han = false;            deb(mid, han);        }    else        rep(i, kai) {            dou mid = (ok + ng) / 2;            if (f(mid))ok = mid, han = true; else ng = mid, han = false;            deb(mid, han);        }    return ok;}\n\ntemplate<class F> dou mgrd_time(dou ok, dou ng, F f,int time = 1980) {\n    bool han = true;\n    if (ok < ng)\n        while(1) {\n            dou mid = (ok + ng) /2;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            deb(mid,han);\n            if(timeup(time)){\n                break;\n            }\n        }\n    else\n        while(1) {\n            dou mid = (ok + ng) /2;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            deb(mid,han);\n            if(timeup(time)){\n                break;\n            }\n        }\n    return ok;\n}\n\n\n//添え字を返す\ntemplate<class F> ll goldd_l(ll left, ll right, F calc) {    double GRATIO = 1.6180339887498948482045868343656;    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));    ll fl = calc(lm);    ll fr = calc(rm);    while (right - left > 10) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + (ll) ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        }        else {            left = lm;            lm = rm;            fl = fr;            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    ll minScore = MAX<ll>();    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (minScore > score) {            minScore = score;            resIndex = i;        }    }    return resIndex;}\ntemplate<class F> ll goldt_l(ll left, ll right, F calc) {    double GRATIO = 1.6180339887498948482045868343656;    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));    ll fl = calc(lm);    ll fr = calc(rm);    while (right - left > 10) {        if (fl > fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + (ll) ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        }        else {            left = lm;            lm = rm;            fl = fr;            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    if (left > right) {        ll l = left;        left = right;        right = l;    }    ll maxScore = MIN<ll>();    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (maxScore < score) {            maxScore = score;            resIndex = i;        }    }    return resIndex;}\n/*loopは200にすればおそらく大丈夫 余裕なら300に*/\ntemplate<class F> dou goldd_d(dou left, dou right, F calc, ll loop = 200) {    dou GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    /*200にすればおそらく大丈夫*/    /*余裕なら300に*/    ll k = 141;    loop++;    while (--loop) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        }        else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return left;}\ntemplate<class F> dou goldt_d(dou left, dou right, F calc, ll loop = 200) {    double GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    loop++;    while (--loop) {        if (fl > fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        }        else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return left;}\n//l ~ rを複数の区間に分割し、極致を与えるiを返す time-20 msまで探索\ntemplate<class F> ll goldd_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll mini = 0, minv = MAX<ll>();    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldd_l(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return mini;}\ntemplate<class F> ll goldt_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll maxi = 0, maxv = MIN<ll>();    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldt_l(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return maxi;}\ntemplate<class F> dou goldd_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を持つ*/    auto lim = milliseconds(time - 20);    dou mini = 0, minv = MAX<dou>();    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldd_d(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return mini;}\ntemplate<class F> dou goldt_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を残している*/    auto lim = milliseconds(time - 20);    dou maxi = 0, maxv = MIN<dou>();    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldt_d(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return maxi;}\n\n#endif\n\n//strを整数として比較\nstring smax(str &a, str b) { if (sz(a) < sz(b)) { return b; } else if (sz(a) > sz(b)) { return a; } else if (a < b)return b; else return a; }\n//strを整数として比較\nstring smin(str &a, str b) { if (sz(a) > sz(b)) { return b; } else if (sz(a) < sz(b)) { return a; } else if (a > b)return b; else return a; }\n//エラー-1\ntemplate<typename W, typename T> ll find(vector<W> &a, int l, const T key) {rep(i, l, sz(a))if (a[i] == key)return i;return -1;}\ntemplate<typename W, typename T> ll find(vector<W> &a, const T key) {rep(i, sz(a))if (a[i] == key)return i;return -1;}\ntemplate<typename W, typename T> P find(vector<vector<W >> &a, const T key) {rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return mp(i, j);return mp(-1, -1);}\n//getid(find())を返す 1次元にする\ntemplate<typename W, typename T> int findi(vector<vector<W >> &a, const T key) {rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return i * sz(a[0]) + j;return -1;}\ntemplate<typename W, typename U> T find(vector<vector<vector<W >>> &a, const U key) {rep(i, sz(a))rep(j, sz(a[0]))rep(k, sz(a[0][0]))if (a[i][j][k] == key)return mt(i, j, k);return mt(-1, -1, -1);}\n//無ければ-1\nint find(string &s, const string key) {    int klen = sz(key);    rep(i, sz(s) - klen + 1) {        if (s[i] != key[0])continue;        if (s.substr(i, klen) == key) { return i; }    }return -1;}\nint find(string &s, int l, const string key) {    int klen = sz(key);    rep(i, l, sz(s) - klen + 1) {        if (s[i] != key[0])continue;        if (s.substr(i, klen) == key) { return i; }    }    return -1;}\nint find(string &s, const char key) {    rep(i, sz(s)) { if (s[i] == key)return i; }    return -1;}\nint find(string &s, int l, const char key) {    rep(i, l, sz(s)) { if (s[i] == key)return i; }    return -1;}\ntemplate<typename W, typename T> ll count2(W &a, const T k) { return a == k; }\ntemplate<typename W, typename T> ll count2(vector<W> &a, const T k) {    ll ret = 0;    fora(v, a)ret += count2(v, k);    return ret;}\ntemplate<typename W, typename T> ll count(vector<W> &a, const T k) {    ll ret = 0;    fora(v, a)ret += count2(v, k);    return ret;}\nvi count(vi &a) {    int ma = 0;    fora(v, a) { if (ma < v)ma = v; }    vi res(ma + 1);    fora(v, a) { res[v]++; }    return res;}\nll count(str &a, str k) {    ll ret = 0, len = k.length();    auto pos = a.find(k);    while (pos != string::npos)pos = a.find(k, pos + len), ++ret;    return ret;}\n//'a' = 'A' = 0 として集計 既に-'a'されていても動く\nvi count(str &a, int l = -1, int r = -1) {    pr_set_lr(l,r,sz(a));vi cou(26);    char c = 'a';    if ('A' <= a[l] && a[l] <= 'Z')c = 'A';    if ('a' <= a[l] && a[l] <= 'z') c = 'a'; else c = 0;    rep(i, l, r)++cou[a[i] - c];    return cou;}\n#define couif count_if\n//algorythm\nll rev(ll a) {    ll res = 0;    while (a) {        res *= 10;        res += a % 10;        a /= 10;    }    return res;}\ntemplate<class T> auto rev(vector<T> &a) {    auto b = a;    reverse(all(b));    return b;}\n/* ＼反転  */                                                                                        template<class U>\nauto rev(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a[0]), vector<U>(sz(a)));    rep(h, sz(a)) rep(w, sz(a[0]))b[w][h] = a[h][w];    return b;}\n/* ｜反転  */                                                                                        template<class U>\nauto revw(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a), vector<U>(sz(a[0])));    int W = sz(a[0]);    rep(h, sz(a)) rep(w, sz(a[0])) { b[h][W - 1 - w] = a[h][w]; }    return b;}\n\n/* ー反転  */                                                                                        template<class U>\nauto revh(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a), vector<U>(sz(a[0])));    int H = sz(a);    rep(h, sz(a)) rep(w, sz(a[0])) { b[H - 1 - h][w] = a[h][w]; }    return b;}\n\n/* ／反転  */                                                                                        template<class U>\nauto revr(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a[0]), vector<U>(sz(a)));    int H = sz(a);    int W = sz(a[0]);    rep(h, sz(a)) rep(w, sz(a[0]))b[w][h] = a[H - 1 - h][W - 1 - w];    return b;}\n\nauto rev(const string &a) {    string b = a;    reverse(all(b));    return b;}\nconstexpr ll p10[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000ll, 100000000000ll, 1000000000000ll, 10000000000000ll, 100000000000000ll, 1000000000000000ll, 10000000000000000ll, 100000000000000000ll, 1000000000000000000ll};\n\n//0は0桁\nll keta(ll v) { if (v < p10[9]) { if (v < p10[4]) { if (v < p10[2]) { if (v < p10[1]) { if (v < p10[0])return 0; else return 1; } else return 2; } else { if (v < p10[3]) return 3; else return 4; }} else { if (v < p10[7]) { if (v < p10[5]) return 5; else if (v < p10[6])return 6; else return 7; } else { if (v < p10[8])return 8; else return 9; }}} else { if (v < p10[13]) { if (v < p10[11]) { if (v < p10[10]) return 10; else return 11; } else { if (v < p10[12]) return 12; else return 13; }} else { if (v < p10[15]) { if (v < p10[14]) return 14; else return 15; } else { if (v < p10[17]) { if (v < p10[16]) return 16; else return 17; } else { if (v < p10[18])return 18; else return 19; }}}}}\nll getr(ll a, ll keta) { return (a / (ll) pow(10, keta)) % 10; }\n//上から何桁目か\nll getl(ll a, ll ket) {int sketa = keta(a);return getr(a, sketa - 1 - ket);}\nll dsum(ll v, ll sin = 10) {ll ret = 0;for (; v; v /= sin)ret += v % sin;return ret;}\n\nll mask10(ll v) { return p10[v] - 1; }\n//変換系\n//[v] := iとなるようなvectorを返す\n//存在しない物は-1\ntemplate<class T> auto keys(T a) {    vector<decltype((a.begin())->fi)> res;    for (auto &&k :a)res.push_back(k.fi);    return res;}\ntemplate<class T> auto values(T a) {    vector<decltype((a.begin())->se)> res;    for (auto &&k :a)res.push_back(k.se);    return res;}\ntemplate<class T> constexpr T min(T a, T b, T c) { return a >= b ? b >= c ? c : b : a >= c ? c : a; }\ntemplate<class T> constexpr T max(T a, T b, T c) { return a <= b ? b <= c ? c : b : a <= c ? c : a; }\ntemplate<class T> T min(vector<T> &a, ll s = -1, ll n = -1) { pr_set_lr(s, n, sz(a)); return *min_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<class T> T max(vector<T> &a, ll s = -1, ll n = -1) { pr_set_lr(s, n,sz(a)); return *max_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<class T> T mini(vector<T> &a) { return min_element(all(a)) - a.begin(); }\ntemplate<class T> T maxi(vector<T> &a) { return max_element(all(a)) - a.begin(); }\n\ntemplate<class T> T sum(const vector<T>& A, int l = -1, int r = -1){T s=0;pr_set_lr(l, r, sz(A));rep(i, l, r)s+=A[i];return s;}\ntemplate<class T> auto sum(const vector<vector<T>>& A ){decl2(A) s=0;rep(i, sz(A))s+=sum(A[i]);return s;}\ntemplate<class T> T min(const vector<T>& A, int l = -1, int r = -1 ){T s=MAX<T>();pr_set_lr(l, r, sz(A));rep(i, l, r)s=min(s, A[i]);return s;}\ntemplate<class T> auto min(const vector<vector<T>>& A ){using S =decl2(A);S s=MAX<S>();rep(i, sz(A))s=min(s, A[i]);return s;}\ntemplate<class T> T max(const vector<T>& A, int l = -1, int r = -1 ){T s=MIN<T>();pr_set_lr(l, r, sz(A));rep(i, l, r); rep(i, l, r)s=max(s, A[i]);return s;}\ntemplate<class T> auto max(const vector<vector<T>>& A ){using S =decl2(A);S s=MIN<S>();rep(i, sz(A))s=max(s, A[i]);return s;}\ntemplate<class T> T mul(vector<T> &v, ll t = inf) {    T ret = v[0];    rep(i, 1, min(t, sz(v)))ret *= v[i];    return ret;}\n\n//template<class T, class U, class... W>  auto sumn(vector<T> &v, U head, W... tail) {    auto ret = sum(v[0], tail...);    rep(i, 1, min(sz(v), head))ret += sum(v[i], tail...);    return ret;}\n//indexを持つvectorを返す\nvi inds_(vi &a) {    int n = max(a) + 1;    vi ret(n, -1);    rep(i, sz(a)) { assert(ret[a[i]] ==-1);ret[a[i]] = i; }    return ret;}\nvoid clear(PQ &q) { q = PQ(); }\nvoid clear(priority_queue<int> &q) { q = priority_queue<int>(); }\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\n//template<class T> T *negarr(ll size) {    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));    return body + size;}\n//template<class T> T *negarr2(ll h, ll w) {    double **dummy1 = new double *[2 * h + 1];    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];    dummy1[0] = dummy2 + w;    for (ll i = 1; i <= 2 * h + 1; ++i) { dummy1[i] = dummy1[i - 1] + 2 * w + 1; }    double **a = dummy1 + h;    return a;}\n\n\ntemplate<class T> struct ruiC {\n    vector<T> rui;\n    ruiC(vector<T> &ru) : rui(ru) {}\n    /*先頭0*/\n    ruiC() : rui(1, 0) {}\n    T operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruic \";            deb(l, r);            assert(0);        }        return rui[r] - rui[l];    }\n    T operator()(int r = inf) { return operator()(0, min(r, sz(rui) - 1)); }\n    /*ruiv[]をruic[]に変えた際意味が変わるのがまずいため()と統一*/\n    /*単体iを返す 累積でないことに注意(seg木との統一でこうしている)*/\n//    T operator[](ll i) { return rui[i + 1] - rui[i]; }\n    T operator[](ll i) { return rui[i]; }\n    /*0から順に追加される必要がある*/\n    void operator+=(T v) { rui.push_back(rui.back() + v); }\n    void add(int i, T v) {if (sz(rui) - 1 != i)ole();operator+=(v);}\n    T back() { return rui.back(); }\n    ll size() { return rui.size(); }\n    auto begin() { return rui.begin(); }\n    auto end() { return rui.end(); }\n};\ntemplate<class T> ostream &operator<<(ostream &os, ruiC<T> a) {    fora(v, a.rui)os << v << \" \";    return os;}\ntemplate<class T> vector<T> ruiv(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i];    return ret;}\ntemplate<class T> ruiC<T> ruic(vector<T> &a) {    vector<T> ret = ruiv(a);    return ruiC<T>(ret);}\ntemplate<class T> ruiC<T> ruic() { return ruiC<T>(); }\n//imoは0-indexed\n//ruiは1-indexed\ntemplate<class T> vector<T> imo(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    return ret;}\n\n//#define use_rui //_imo _ruic _ruiv\n#ifdef use_rui\n//kと同じものの数\ntemplate<class T, class U> vi imo(vector<T> &a, U k) {    vector<T> ret = a;    rep(i, sz(ret))ret[i] = a[i] == k;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    return ret;}\ntemplate<class T> vector<T> imox(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] ^= ret[i];    return ret;}\n//漸化的に最小を持つ\ntemplate<class T> vector<T> imi(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chmi(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> ima(vector<T> &v) {vector<T> ret = v;    rep(i, sz(ret) - 1)chma(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> rimi(vector<T> &v) {    vector<T> ret = v;    rer(i, sz(ret) - 1, 1)chmi(ret[i - 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> rima(vector<T> &v) {    vector<T> ret = v;    rer(i, sz(ret) - 1, 1)chma(ret[i - 1], ret[i]);    return ret;}\ntemplate<class T> struct ruimax {\n    template<typename Monoid> struct SegmentTree {        /*pairで処理*/        int sz;        vector<Monoid> seg;        const Monoid M1 = mp(MIN<T>(), -1);        Monoid f(Monoid a, Monoid b) { return max(a, b); }        void build(vector<T> &a) {            int n = sz(a);            sz = 1;            while (sz < n) sz <<= 1;            seg.assign(2 * sz, M1);            rep(i, n) { seg[i + sz] = mp(a[i], i); }            for (int k = sz - 1; k > 0; k--) { seg[k] = f(seg[k << 1], seg[(k << 1) | 1]); }        }        Monoid query(int a, int b) {            Monoid L = M1, R = M1;            for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {                if (a & 1) L = f(L, seg[a++]);                if (b & 1) R = f(seg[--b], R);            }            return f(L, R);        }        Monoid operator[](const int &k) const { return seg[k + sz]; }    };\nprivate:\n    vector<T> ve;\n    SegmentTree<pair<T, int>> seg;\n    vector<T> rv;\n    vector<T> ri;\n    bool build = false;\npublic:\n    int n;\n    ruimax(vector<T> &a) : ve(a), n(sz(a)) {        int index = -1;        int ma = MIN<T>();        rv.resize(n + 1);        ri.resize(n + 1);        rv[0] = -linf;        ri[0] = -1;        rep(i, n) {            if (chma(ma, a[i])) { index = i; }            rv[i + 1] = ma;            ri[i + 1] = index;        }    }\n    T operator()(int l, int r) {        if (!(l <= r && 0 <= l && r <= n)) {            deb(l, r, n);            assert(0);        }        if (l == 0) { return rv[r]; }        else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).first;        }    }    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) { return operator()(0, r); }\n    T getv(int l, int r) { return operator()(l, r); }\n    T geti(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) { return ri[r]; }        else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).second;        }    }    T geti(int r = inf) { return geti(0, min(r, n)); };\n    T getv(int r = inf) { return getv(0, min(r, n)); };\n    auto begin() { return rv.begin(); }\n    auto end() { return rv.end(); }\n};\ntemplate<class T> struct ruimin {\n    template<typename Monoid> struct SegmentTree {  /*pairで処理*/         int sz;\n        vector<Monoid> seg;\n        const Monoid M1 = mp(MAX<T>(), -1);\n        Monoid f(Monoid a, Monoid b) { return min(a, b); }\n        void build(vector<T> &a) {            int n = sz(a);            sz = 1;            while (sz < n) sz <<= 1;            seg.assign(2 * sz, M1);            rep(i, n) { seg[i + sz] = mp(a[i], i); }            for (int k = sz - 1; k > 0; k--) { seg[k] = f(seg[k << 1], seg[(k << 1) | 1]); }        }\n        Monoid query(int a, int b) {            Monoid L = M1, R = M1;            for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {                if (a & 1) L = f(L, seg[a++]);                if (b & 1) R = f(seg[--b], R);            }            return f(L, R);        }\n        Monoid operator[](const int &k) const { return seg[k + sz]; }\n    };\nprivate:\n    vector<T> ve;\n    SegmentTree<pair<T, int>> seg;\n    vector<T> rv;\n    vector<T> ri;\n    bool build = false;\n    int n;\npublic:\n    ruimin(vector<T> &a) : ve(a), n(sz(a)) {        int index = -1;        int mi = MAX<T>();        rv.resize(n + 1);        ri.resize(n + 1);        rv[0] = linf;        ri[0] = -1;        rep(i, n) {            if (chmi(mi, a[i])) { index = i; }            rv[i + 1] = mi;            ri[i + 1] = index;        }    }\n    T operator()(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) { return rv[r]; }        else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).first;        }    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) { return operator()(0, r); }\n    T getv(int l, int r) { return operator()(l, r); }\n    T geti(int l, int r) {        {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) { return ri[r]; }        else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).second;        }    }assert(l <= r && 0 <= l && r <= n);        if (l == 0) { return ri[r]; }        else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).second;        }    }\n    T geti(int r = inf) { return geti(0, min(r, n)); };\n    T getv(int r = inf) { return getv(0, min(r, n)); };\n    auto begin() { return rv.begin(); }\n    auto end() { return rv.end(); }\n};\n\nvvi() ruib(vi &a) {    vvi(res, 61, sz(a) + 1);    rep(k, 61) { rep(i, sz(a)) { res[k][i + 1] = res[k][i] + ((a[i] >> k) & 1); }}    return res;}\nvector<ruiC<int>> ruibc(vi &a) {vector<ruiC<int>> ret(61);    vvi(res, 61, sz(a));    rep(k, 61) {        rep(i, sz(a)) { res[k][i] = (a[i] >> k) & 1; }        ret[k] = ruic(res[k]);    }    return ret;}\nvector<ll> ruiv(string &a) {    if (sz(a) == 0)return vi(1);    ll dec = ('0' <= a[0] && a[0] <= '9') ? '0' : 0;    vector<ll> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i] - dec;    return ret;}\nruiC<ll> ruic(string &a) {    vector<ll> ret = ruiv(a);    return ruiC<ll>(ret);}\n//kと同じものの数\ntemplate<class T, class U> vi ruiv(T &a, U k) {    vi ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + (a[i] == k);    return ret;}\ntemplate<class T, class U> ruiC<ll> ruic(T &a, U k) {    vi ret = ruiv(a, k);    return ruiC<ll>(ret);}\ntemplate<class T> struct ruiC2 {\n    int H;\n    vector<ruiC<T>> rui;\n    ruiC2(vector<vector<T>> &ru) : rui(sz(ru)), H(sz(ru)) { for (int h = 0; h < H; h++) { rui[h] = ruic(ru[h]); }}\n    //WについてHを返す\n    vector<T> operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruic \";            deb(l, r);            assert(0);        }        vector<T> res(H);        for (int h = 0; h < H; h++)res[h] = rui[h](l, r);        return res;    }\n    //HについてWを返す\n    ruiC<T> &operator[](ll h) {        assert(h < H);        return rui[h];    }\n    //    vector<T> operator()(int r) { return operator()(0, r); }\n    /*ruiv[]をruic[]に変えた際意味が変わるのがまずいため()と統一*/\n    /*単体iを返す 累積でないことに注意(seg木との統一でこうしている)*/\n//    T operator[](ll i) { return rui[i + 1] - rui[i]; }\n    /*0から順に追加される必要がある*/\n//    T back() { return rui.back(); }\n//    ll size() { return rui.size(); }\n//    auto begin(){return rui.begin();}\n//    auto end(){return rui.end();}\n};\n\n//a~zを0~25として\n// rui(l,r)でvector(26文字について, l~rのcの個数)\n// rui[h] ruic()を返す\nruiC2<ll> ruicou(str &a) {    str s = a;    replace(s);    vector<ruiC<ll>> res(26);    vvi(cou, 26, sz(s));    rep(i, sz(s)) { cou[s[i]][i] = 1; }    return ruiC2<ll>(cou);}\nruiC2<ll> ruicou(vi &a) {    int H = max(a) + 1;    vector<ruiC<ll>> res(H);    vvi(cou, H, sz(a));    rep(i, sz(a)) { cou[a[i]][i] = 1; }    return ruiC2<ll>(cou);}\ntemplate<class T, class U> ruiC<ll> ruicou(vector<T> &a, U b) {    vi cou(sz(a));    rep(i, sz(a)) { cou[i] = a[i] == b; }    return ruic(cou);}\n//h query\ntemplate<class T> vector<T> imoh(vector<vector<T>> &v, int w) {    vector<T> ret(sz(v));    rep(h, sz(ret)) { ret[h] = v[h][w]; }    rep(i, sz(ret) - 1) { ret[i + 1] += ret[i]; }    return ret;}\ntemplate<class T> vector<T> ruih(vector<vector<T>> &v, int w) {    vector<T> ret(sz(v) + 1);    rep(h, sz(v)) { ret[h + 1] = v[h][w]; }    rep(i, sz(v)) { ret[i + 1] += ret[i]; }    return ret;}\ntemplate<class T> ruiC<T> ruihc(vector<vector<T>> &a, int w) {    vector<T> ret = ruih(a, w);    return ruiC<T>(ret);}\n\n//xor\ntemplate<class T> struct ruixC {\n    vector<T> rui;\n    ruixC(vector<T> &ru) : rui(ru) {}\n    T operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruiXc \";            deb(l, r);            assert(0);        }        return rui[r] ^ rui[l];    }\n    T operator[](ll i) { return rui[i]; }\n    T back() { return rui.back(); }\n    ll size() { return rui.size(); }\n};\ntemplate<class T> vector<T> ruix(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] ^ a[i];    return ret;}\ntemplate<class T> ruixC<ll> ruixc(vector<T> &a) {    vi ret = ruix(a);    return ruixC<ll>(ret);}\n//差分を返す(累積を取ると元に戻る)\n//101なら\n//1111を返す\n//元の配列で[l, r)へのxorは\n//[l]と[r]へのxorになる https://atcoder.jp/contests/abc155/tasks/abc155_f\nvi ruix_diff(vi &A) {    int N = sz(A);    assert(N);    vi res(N + 1);    res[0] = A[0];    rep(i, 1, N) { res[i] = A[i - 1] ^ A[i]; }    res[N] = A[N - 1];    return res;}\n\ntemplate<class T> vector<T> ruim(vector<T> &a) {    vector<T> res(a.size() + 1, 1);    rep(i, a.size())res[i + 1] = res[i] * a[i];    return res;}\n//漸化的に最小を1indexで持つ\ntemplate<class T> vector<T> ruimi(vector<T> &a) {ll n = sz(a);    vector<T> ret(n + 1);    rep(i, 1, n) {        ret[i] = a[i - 1];        chmi(ret[i + 1], ret[i]);    }    return ret;}\n//template<class T> T *rrui(vector<T> &a) {\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> struct rruiC {\n    vector<T> rui;\n    int n;\n    rruiC(vector<T> &a) : n(sz(a)) {        rui.resize(n + 1);        rer(i, n - 1) { rui[i] = rui[i + 1] + a[i]; }    }\n    /*[r l)*/\n    T operator()(int r, int l) {        r++;        l++;        assert(l <= r && l >= 0 && r <= n);        return rui[l] - rui[r];    }\n    T operator()(int l) { return operator()(n - 1, l); }\n    T operator[](int i) { return operator()(i); }\n};\ntemplate<class T> ostream &operator<<(ostream &os, rruiC<T> a) {    fora(v, a.rui)os << v << \" \";    return os;}\n\n#define rrui rruic\ntemplate<class T> rruiC<T> rruic(vector<T> &a) { return rruiC<T>(a); }\n\n//掛け算\ntemplate<class T> struct ruimulC {\n    vector<T> rv;\n    int n;\n    ruimulC(vector<T> &a) : rv(a), n(sz(a)) {        rv.resize(n + 1);        rv[0] = 1;        rep(i, n) { rv[i + 1] = a[i] * rv[i]; }    }\n    ruimulC() : n(0) {        rv.resize(n + 1);        rv[0] = 1;    }\n    void operator+=(T v) {        rv.push_back(rv.back() * v);        n++;    }\n    T operator()(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        return rv[r] / rv[l];    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) { return operator()(0, r); }\n    auto begin() { return rv.begin(); }\n    auto end() { return rv.end(); }\n};\ntemplate<class T> ruimulC<T> ruimul(vector<T> &a) { return ruimulC<T>(a); }\ntemplate<class T> ruimulC<T> ruimul() {    vector<T> a;    return ruimulC<T>(a);}\ntemplate<class T> T *rruim(vector<T> &a) {    ll len = a.size();    T *body = (T *) malloc((len + 1) * sizeof(T));    T *res = body + 1;    res[len - 1] = 1;    rer(i, len - 1)res[i - 1] = res[i] * a[i];    return res;}\ntemplate<class T, class U, class W> T lowerBound(ruiC <T> &a, U v, W banpei) { return lowerBound(a.rui, v, banpei); }\ntemplate<class T, class U, class W> T upperBound(ruiC <T> &a, U v, W banpei) { return upperBound(a.rui, v, banpei); }\ntemplate<class T, class U, class W> T rlowerBound(ruiC <T> &a, U v, W banpei) { return rlowerBound(a.rui, v, banpei); }\ntemplate<class T, class U, class W> T rupperBound(ruiC <T> &a, U v, W banpei) { return rupperBound(a.rui, v, banpei); }\n#endif\n\ntemplate<class T, class U> void inc(pair<T, U> &a, U v = 1) { a.first += v, a.second += v; }\ntemplate<class T, class U> void inc(T &a, U v = 1) { a += v; }\ntemplate<class T, class U = int> void inc(vector<T> &a, U v = 1) { for (auto &u:a)inc(u, v); }\ntemplate<class T, class U> void dec(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U = int> void dec(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class U> void dec(string &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T, class U, class W> void dec(vector<T> &a, vector<U> &b, W v = 1) {    for (auto &u :a)dec(u, v);    for (auto &u :b)dec(u, v);}\ntemplate<class T, class U, class W> void dec(vector<T> &a, vector<U> &b, vector<W> &c) {    for (auto &u :a)dec(u, 1);    for (auto &u :b)dec(u, 1);    for (auto &u :c)dec(u, 1);}\nbool ins(ll h, ll w, ll H, ll W) { return h >= 0 && w >= 0 && h < H && w < W; }\nbool san(ll l, ll v, ll r) { return l <= v && v < r; }\ntemplate<class T> bool ins(vector<T> &a, ll i, ll j = 0) { return san(0, i, sz(a)) && san(0, j, sz(a)); }\n#define inside ins\nll u0(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u0(vector<T> &a) {    vector<T> ret = a;    fora(v, ret)v = u(v);    return ret;}\n//todo 名前\nbool d_(int a, int b) {    if (b == 0)return false;    return (a % b) == 0;}\n\n\n//pow周りの仕様\n//powiを使うと整数型\n//powbを使うとbint型\n//powを使うと powlに変換され long doubleが返る\n#ifdef _DEBUG\n//整数値の場合はpowiを使った方がいいというメッセージを出すための物\nauto my_powl(ll a, ll k) { return powl(a, k); }\nauto pow(ll a, ll k) {    static bool was = 1;    if (was) { message += \"if integer use *powi* it's very fast\\n\"; }    was = 0;    return my_powl(a, k);}\n//上のメッセージを出すための関数\nauto pow(signed a, ll k) { return pow((ll) a, k); }\nauto pow(signed a, signed k) { return pow((ll) a, (ll) k); }\n#endif\n\n//整数型のpow\nint powi(int a, int k) {    if (a == 2)return 1ll << k;    int res = 1;    int x = a;    while (k) {        if (k & 1)res *= x;        x *= x;        k >>= 1;    }    return res;}\n//define pow powlより上に動かすとバグる\nbint pow(bint a, ll k) {    bint res = 1;    bint x = a;    while (k) {        if (k & 1)res *= x;        x *= x;        k >>= 1;    }    return res;}\nbint pow(bint a, signed k) { return pow(a, (ll) k); }\nbint powb(int a, int b) { return pow((bint) a, b); }\nconstexpr bool bget(ll m, ll keta) {\n#ifdef _DEBUG\n    assert(keta <= 62);//オーバーフロー 1^62までしか扱えない\n#endif\n    return (m >> keta) & 1;\n}\n//bget(n)次元\n//                          NならN-1まで\nvector<vi> bget2(vi &a, int keta_size) {    vvi(res, keta_size, sz(a));    rep(k, keta_size) { rep(i, sz(a)) { res[k][i] = bget(a[i], k); }}    return res;}\nvi bget1(vi &a, int keta) {    vi res(sz(a));    rep(i, sz(a)) { res[i] = bget(a[i], keta); }    return res;}\nll bget(ll m, ll keta, ll sinsuu) {    m /= (ll) pow(sinsuu, keta);    return m % sinsuu;}\nconstexpr ll bit(ll n) {\n#ifdef _DEBUG\n    assert(n <= 62);//オーバーフロー 1^62までしか扱えない\n#endif\n    return (1LL << (n));\n}\nll bit(ll n, ll sinsuu) { return (ll) pow(sinsuu, n); }\nll mask(ll n) { return (1ll << n) - 1; }\n//aをbitに置きなおす\n//{0, 2} -> 101\nll bit(vi &a) {    int m = 0;    for (auto &&v:a) m |= bit(v);    return m;}\n\n//{1, 1, 0} -> 011\n//bitsetに置き換える感覚 i が立っていたら i bit目を立てる\nll bit_bool(vi &a) {    int m = 0;    rep(i, sz(a)) if (a[i])m |= bit(i);    return m;}\n#define bcou __builtin_popcountll\n//最下位ビット\nll lbit(ll n) { assert(n);return n & -n; }\nll lbiti(ll n) { assert(n);return log2(n & -n); }\n//最上位ビット\nll hbit(ll n) {    assert(n);n |= (n >> 1);    n |= (n >> 2);    n |= (n >> 4);    n |= (n >> 8);    n |= (n >> 16);    n |= (n >> 32);    return n - (n >> 1);}\nll hbiti(ll n) { assert(n);return log2(hbit(n)); }\n//ll hbitk(ll n) {    ll k = 0;    rer(i, 5) {        ll a = k + (1ll << i);        ll b = 1ll << a;        if (b <= n)k += 1ll << i;    }    return k;}\n//初期化は0を渡す\nll nextComb(ll &mask, ll n, ll r) {    if (!mask)return mask = (1LL << r) - 1;    ll x = mask & -mask; /*最下位の1*/    ll y = mask + x; /*連続した下の1を繰り上がらせる*/    ll res = ((mask & ~y) / x >> 1) | y;    if (bget(res, n))return mask = 0; else return mask = res;}\n//n桁以下でビットがr個立っているもののvectorを返す\nvi bitCombList(ll n, ll r) {    vi res;    ll m = 0;    while (nextComb(m, n, r)) { res.push_back(m); }    return res;}\n/*over*/#define forbit1_2(i, mas) for (int forbitj = lbit(mas), forbitm = mas, i = log2(forbitj); forbitm; forbitm = forbitj ? forbitm ^ forbitj : 0, forbitj = lbit(forbitm), i = log2(forbitj))\n/*over*/#define forbit1_3(i, N, mas) for (int forbitj = lbit(mas), forbitm = mas, i = log2(forbitj); forbitm && i < N; forbitm = forbitj ? forbitm ^ forbitj : 0, forbitj = lbit(forbitm), i = log2(forbitj))\n//masの立ってるindexを見る\n//              i, [N], mas\n#define forbit1(...) over3(__VA_ARGS__, forbit1_3, forbit1_2)(__VA_ARGS__)\n//masが立っていないindexを見る\n//              i, N, mas\n#define forbit0(i, N, mas) forbit1(i, mask(N) & (~(mas)))\n\n//forsubをスニペットして使う\n//Mの部分集合(0,M含む)を見る 3^sz(S)個ある\n#define forsub_all(m, M) for (int m = M; m != -1; m = m == 0 ? -1 : (m - 1) & M)\n\n\n//aにある物をtrueとする\nvb bool_(vi a, int n) {    vb ret(max(max(a) + 1, n));    rep(i, sz(a))ret[a[i]] = true;    return ret;}\n\nchar itoal(ll i) { return 'a' + i; }\nchar itoaL(ll i) { return 'A' + i; }\nll altoi(char c) {    if ('A' <= c && c <= 'Z')return c - 'A';    return c - 'a';}\nll ctoi(char c) { return c - '0'; }\nchar itoc(ll i) { return i + '0'; }\nll vtoi(vi &v) {    ll res = 0;    if (sz(v) > 18) {        debugline(\"vtoi\");        deb(sz(v));        ole();    }    rep(i, sz(v)) {        res *= 10;        res += v[i];    }    return res;}\nvi itov(ll i) {    vi res;    while (i) {        res.push_back(i % 10);        i /= 10;    }    res = rev(res);    return res;}\nvi stov(string &a) {    ll n = sz(a);    vi ret(n);    rep(i, n) { ret[i] = a[i] - '0'; }    return ret;}\n//基準を満たさないものは0になる\nvi stov(string &a, char one) {    ll n = sz(a);    vi ret(n);    rep(i, n)ret[i] = a[i] == one;    return ret;}\nvector<vector<ll>> ctoi(vector<vector<char>> s, char c) {    ll n = sz(s), m = sz(s[0]);    vector<vector<ll>> res(n, vector<ll>(m));    rep(i, n)rep(j, m)res[i][j] = s[i][j] == c;    return res;}\n//#define use_compress\n//[i] := vを返す\n//aは0~n-1で置き換えられる\nvi compress(vi &a) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(all(b), a[i]) - b.begin(); }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\n#ifdef use_compress\nvi compress(vi &a, umap<ll, ll> &map) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) {        ll v = a[i];        a[i] = lower_bound(all(b), a[i]) - b.begin();        map[v] = a[i];    }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r) {    vi b;    ll len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r, vi &s) {    vi b;    ll len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    fora(v, s)b.push_back(v);    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    for (ll i = 0; i < sz(s); ++i) r[i] = lower_bound(all(b), s[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vi> &a) {    vi b;    fora(vv, a)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vv, a)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vector<vi >> &a) {    vi b;    fora(vvv, a)fora(vv, vvv)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vvv, a)fora(vv, vvv)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvoid compress(ll a[], ll len) {    vi b;    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(all(b), a[i]) - b.begin(); }}\n#endif\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define rlowerIndex(a, v) (upper_bound(all(a),v)-a.begin()-1)\n#define rupperIndex(a, v) (lower_bound(all(a),v)-a.begin()-1)\n\ntemplate<class T, class U, class W> T lowerBound(vector<T> &a, U v, W banpei) {    auto it = lower_bound(a.begin(), a.end(), v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T upperBound(vector<T> &a, U v, W banpei) {    auto it = upper_bound(a.begin(), a.end(), v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T rlowerBound(vector<T> &a, U v, W banpei) {    auto it = upper_bound(a.begin(), a.end(), v);    if (it == a.begin())return banpei; else { return *(--it); }}\ntemplate<class T, class U, class W> T rupperBound(vector<T> &a, U v, W banpei) {    auto it = lower_bound(a.begin(), a.end(), v);    if (it == a.begin())return banpei; else { return *(--it); }}\n\ntemplate<class T, class U, class W> T lowerBound(set<T> &a, U v, W banpei) {    auto it = a.lower_bound(v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T upperBound(set<T> &a, U v, W banpei) {    auto it = a.upper_bound(v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T rlowerBound(set<T> &a, U v, W banpei) {    auto it = a.upper_bound(v);    if (it == a.begin())return banpei; else { return *(--it); }}\ntemplate<class T, class U, class W> T rupperBound(set<T> &a, U v, W banpei) {auto it = a.lower_bound(v);if (it == a.begin())return banpei; else { return *(--it); }}\n\ntemplate<class T, class U, class W> T lowerBound(mset<T> &a, U v, W banpei) {    auto it = a.lower_bound(v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T upperBound(mset<T> &a, U v, W banpei) {    auto it = a.upper_bound(v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T rlowerBound(mset<T> &a, U v, W banpei) {    auto it = a.upper_bound(v);    if (it == a.begin())return banpei; else { return *(--it); }}\ntemplate<class T, class U, class W> T rupperBound(mset<T> &a, U v, W banpei) {auto it = a.lower_bound(v);if (it == a.begin())return banpei; else { return *(--it); }}\n#define next2(a) next(next(a))\n#define prev2(a) prev(prev(a))\n\n//狭義の単調増加列 長さを返す\ntemplate<class T> int lis(vector<T> &a) {    int n = sz(a);    vi tail(n + 1, MAX<T>());    rep(i, n) {        int id = lowerIndex(tail, a[i]);/**/        tail[id] = a[i];    }    return lowerIndex(tail, MAX<T>());}\ntemplate<class T> int lis_eq(vector<T> &a) {    int n = sz(a);    vi tail(n + 1, MAX<T>());    rep(i, n) {        int id = upperIndex(tail, a[i]);/**/        tail[id] = a[i];    }    return lowerIndex(tail, MAX<T>());}\n\n//iteratorを返す\n//valueが1以上の物を返す 0は見つけ次第削除\n//vを減らす場合 (*it).se--でいい\ntemplate<class T, class U, class V> auto lower_map(map<T, U> &m, V k) {    auto ret = m.lower_bound(k);    while (ret != m.end() && (*ret).second == 0) {        ret = m.erase(ret);    }    return ret;}\ntemplate<class T, class U, class V> auto upper_map(map<T, U> &m, V k) {    auto ret = m.upper_bound(k);    while (ret != m.end() && (*ret).second == 0) {        ret = m.erase(ret);    }    return ret;}\n//存在しなければエラー\ntemplate<class T, class U, class V> auto rlower_map(map<T, U> &m, V k) {    auto ret = upper_map(m, k);    assert(ret != m.begin());    ret--;    while (1) {        if ((*ret).second != 0)break;        assert(ret != m.begin());        auto next = ret;        --next;        m.erase(ret);        ret = next;    }    return ret;}\ntemplate<class T, class U, class V> auto rupper_map(map<T, U> &m, V k) {    auto ret = lower_map(m, k);    assert(ret != m.begin());    ret--;    while (1) {        if ((*ret).second != 0)break;        assert(ret != m.begin());        auto next = ret;        --next;        m.erase(ret);        ret = next;    }    return ret;}\n\ntemplate<class... T> void fin(T... s) {out(s...); exit(0); }\n\n//便利 数学 math\n//sub ⊂ top\nbool subset(int sub, int top) {return (sub & top) == sub;}\n//-180 ~ 180 degree\ndouble atand(double h, double w) {return atan2(h, w) / PI * 180;}\n//% -mの場合、最小の正の数を返す\nll mod(ll a, ll m) {if (m < 0) m *= -1;return (a % m + m) % m;}\nll pow(ll a) { return a * a; };\nll fact(ll v) { return v <= 1 ? 1 : v * fact(v - 1); }\ndou factd(int v){static vd fact(2,1);    if(sz(fact)<=v){        rep(i,sz(fact),v+1){            fact.push_back(fact.back()*i);        }    }    return fact[v];}\n\nll comi(ll n, ll r) {    assert(n < 100);    static vvi(pas, 100, 100);    if (pas[0][0])return pas[n][r];    pas[0][0] = 1;    rep(i, 1, 100) {        pas[i][0] = 1;        rep(j, 1, i + 1)pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];    }    return pas[n][r];}\n//二項係数の偶奇を返す\nint com_mod2(int n,int r){return n == ( r | (n - r) );}\ndouble comd2(ll n, ll r) {    static vvd(comb, 2020, 2020);    if (comb[0][0] == 0) {        comb[0][0] = 1;        rep(i, 2000) {            comb[i + 1][0] = 1;            rep(j, 1, i + 2) { comb[i + 1][j] = comb[i][j] + comb[i][j - 1]; }        }    }    return comb[n][r];}\ndouble comd(int n, int r) {    if (r < 0 || r > n) return 0;    if (n < 2020)return comd2(n, r);    static vd fact(2, 1);    if (sz(fact) <= n) { rep(i, sz(fact), n + 1) { fact.push_back(fact.back() * i); }}    return fact[n] / fact[n - r] / fact[r];}\n\nll gcd(ll a, ll b) {while (b) a %= b, swap(a, b);return abs(a);}\nll gcd(vi b) {ll res = b[0];rep(i, 1, sz(b))res = gcd(b[i], res);return res;}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll lcm(vi a) {ll res = a[0];rep(i, 1, sz(a))res = lcm(a[i], res);return res;}\nll ceil(ll a, ll b) {if (b == 0) {debugline(\"ceil\");deb(a, b);ole();return -1;} else if (a < 0) { return 0; } else { return (a + b - 1) / b; }}\n\nll sig0(int t) { return t <= 0 ? 0 : ((1 + t) * t) >> 1; }\nbint sig0(bint t) {return t <= 0 ? 0 : ((1 + t) * t) >> 1; }\n//ll sig(ll s, ll t) { return ((s + t) * (t - s + 1)) >> 1; }\nll sig(ll s, ll t) {if (s > t)swap(s, t);return sig0(t - s) + s * (t - s + 1);}\n\n#define tousa_i tosa_i\n#define lower_tousa_i lower_tosa_i\n#define upper_tousa upper_tosa\n#define upper_tousa_i upper_tosa_i\nll tosa_i(ll st, ll ad, ll v) {    assert(((v - st) % ad) == 0);    return (v - st) / ad;}\nll tosa_s(ll st, ll ad, ll len) {    return st * len + sig0(len - 1) * ad;}\n\n// ax + r (x は非負整数) で表せる整数のうち、v 以上となる最小の整数\nll lower_tosa(ll st, ll ad, ll v) {    if (st >= v) return st;    return (v - st + ad - 1) / ad * ad + st;}\n//第何項か\nll lower_tosa_i(ll st, ll ad, ll v) {    if (st >= v) return 0;    return (v - st + ad - 1) / ad;}\nll upper_tosa(ll st, ll ad, ll v) { return lower_tosa(st, ad, v + 1); }\nll upper_tosa_i(ll st, ll ad, ll v) { return lower_tosa_i(st, ad, v + 1); }\n\n//b * res <= aを満たす [l, r)を返す div\nP drange_ika(int a, int b) {    P null_p = mp(linf, linf);    if (b == 0) {        if (a >= 0) {            return mp(-linf, linf + 1)/*全て*/;        } else {            return null_p/*無い*/;        }    } else {        if (a >= 0) {            if (b > 0) {                return mp(-linf, a / b + 1);            } else {                return mp(-(a / -b), linf + 1);            }        } else {            if (b > 0) {                return mp(-linf, -ceil(-a, b) + 1);            } else {                return mp(ceil(-a, -b), linf + 1);            }        }    }}\n\n//v * v >= aとなる最小のvを返す\nll sqrt(ll a) {    if (a < 0) {        debugline(\"sqrt\");        deb(a);        ole();    }    ll res = (ll) std::sqrt(a);    while (res * res < a)++res;    return res;}\ndouble log(double e, double x) { return log(x) / log(e); }\n\n\n/*@formatter:off*/\n\n//機能拡張\n#define dtie(a, b) int a, b; tie(a, b)\ntemplate<class T, class U> string to_string(T a, U b) {    string res = \"\";    res += a;    res += b;    return res;}\ntemplate<class T, class U, class V> string to_string(T a, U b, V c) {    string res = \"\";    res += a;    res += b;    res += c;    return res;}\ntemplate<class T, class U, class V, class W> string to_string(T a, U b, V c, W d) {    string res = \"\";    res += a;    res += b;    res += c;    res += d;    return res;}\ntemplate<class T, class U, class V, class W, class X> string to_string(T a, U b, V c, W d, X e) {    string res = \"\";    res += a;    res += b;    res += c;    res += d;    res += e;    return res;}\n\ntemplate<class T> vector<T> sub(vector<T> &A, int l, int r) {    assert(0 <= l && l <= r && r <= sz(A));    vector<T> ret(r - l);    std::copy(A.begin() + l, A.begin() + r, ret.begin());    return ret;}\ntemplate<class T> vector<T> sub(vector<T> &A, int r) { return sub(A, 0, r); }\ntemplate<class T> vector<T> subn(vector<T> &A, int l, int len) { return sub(A, l, l + len); }\nstring sub(string &A, int l, int r) {    assert(0 <= l && l <= r && r <= sz(A));    return A.substr(l, r - l);}\n\nconstexpr int bsetlen = k5 * 2;\n//constexpr int bsetlen = 5050;\n#define bset bitset<bsetlen>\nbool operator<(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] < b[i])return true;if (a[i] > b[i])return false;}return false;}\nbool operator>(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] > b[i])return true;if (a[i] < b[i])return false;}return false;}\nbool operator<=(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] < b[i])return true;if (a[i] > b[i])return false;}return true;}\nbool operator>=(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] > b[i])return true;if (a[i] < b[i])return false;}return true;}\nstring operator~(string &a) {string res = a;for (auto &&c:res) {if (c == '0')c = '1';else if (c == '1')c = '0';else {cerr << \"cant ~\" << a << \"must bit\" << endl;exit(0);}}return res;}\nostream &operator<<(ostream &os, bset& a) {    bitset<10> b;    vi list;    rep(i,bsetlen){        if(a[i])list.push_back(i),b[i]=1;    }    os<<b<<\", \"<<list;    return os;}\nint hbiti(bset&a){rer(i,bsetlen){if(a[i])return i;}return -1;}\n#define hk(a, b, c) (a <= b && b < c)\n\n//O(N/64)\nbset nap(bset &a, int v) {bset r = a | a << v;return r;}\nbset nap(bset &a, bset &v) {bset r = a;rep(i, bsetlen) {if (v[i])r |= a << i;}return r;}\n\ntemplate<class T> int count(set<T> &S, T l, T r) {    assert(l < r);    auto it = S.lower_bound(l);    return it != S.end() && (*it) < r;}\n\ntemplate<class T> void seth(vector<vector<T>> &S, int w, vector<T> &v) {assert(sz(S) == sz(v));assert(w < sz(S[0]));rep(h, sz(S)) { S[h][w] = v[h]; }}\n\ntemplate<class T, class U> void operator+=(pair<T,U> &a, pair<T,U> & b) {a.fi+=b.fi;a.se+=b.se;}\ntemplate<class T, class U> pair<T,U> operator+(pair<T,U> &a, pair<T,U> & b) {return pair<T,U>(a.fi+b.fi,a.se+b.se);}\ntemplate<typename CharT, typename Traits, typename Alloc> basic_string<CharT, Traits, Alloc> operator+(const basic_string<CharT, Traits, Alloc> &lhs, const int rv) {\n#ifdef _DEBUG\n    static bool was = false;if (!was)message += \"str += 65  is  'A'  not \\\"65\\\" \";was = true;\n#endif\n    return lhs + (char) rv;\n}\ntemplate<typename CharT, typename Traits, typename Alloc> void operator+=(basic_string<CharT, Traits, Alloc> &lhs, const int rv) {    lhs = lhs + rv;}\ntemplate<typename CharT, typename Traits, typename Alloc> basic_string<CharT, Traits, Alloc> operator+(const basic_string<CharT, Traits, Alloc> &lhs, const signed rv) {    const int rv2 = rv;    return lhs + rv2;}\ntemplate<typename CharT, typename Traits, typename Alloc> void operator+=(basic_string<CharT, Traits, Alloc> &lhs, const signed rv) {const int v = rv; lhs += v; }\ntemplate<typename CharT, typename Traits, typename Alloc> void operator*=(basic_string<CharT, Traits, Alloc> &s, int num) {    auto bek = s;    s = \"\";    for (; num; num >>= 1) {        if (num & 1) { s += bek; }        bek += bek;    }}\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) { a.push(v); }template<class T, class U> void operator+=(deque<T> &a, U v) { a.push_back(v); }template<class T> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, vector<T> &v) {    fora(d, v)a.push(d);    return a;}template<class T, class U> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {    a.push(v);    return a;}template<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {    a.push(v);    return a;}template<class T> set<T> &operator+=(set<T> &a, vector<T> v) {    fora(d, v)a.insert(d);    return a;}template<class T, class U> auto operator+=(set<T> &a, U v) { return a.insert(v); }template<class T, class U> auto operator-=(set<T> &a, U v) { return a.erase(v); }template<class T, class U> auto operator+=(mset<T> &a, U v) { return a.insert(v); }template<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {    a.insert(v);    return a;}template<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {    a.push_back(v);    return a;}template<class T, class U> vector<T> operator+(vector<T> &a, U v) {    vector<T> ret = a;    ret += v;    return ret;}template<class T, class U> vector<T> operator+(U v, vector<T> &a) {    vector<T> ret = a;    ret.insert(ret.begin(), v);    return ret;}template<class T> vector<T> operator+(const vector<T>& a, const vector<T>& b) {    vector<T> ret;    ret = a;    fora(v, b)ret += v;    return ret;}template<class T> vector<T> &operator+=(vector<T> &a, vector<T> &b) {    rep(i, sz(b)) {/*こうしないとa+=aで両辺が増え続けてバグる*/        a.push_back(b[i]); }    return a;}template<class T, class U> map<T, U> &operator+=(map<T, U> &a, map<T, U> &b) {    fora(bv, b) { a[bv.first] += bv.second; }    return a;}\ntemplate<class T> vector<T> operator%(vector<T>& a, int v){    vi ret(sz(a));    rep(i,sz(a)){        ret[i] = a[i] % v;    }    return ret;}\ntemplate<class T> vector<T> operator%=(vector<T>& a, int v){    rep(i,sz(a)){        a[i] %= v;    }    return a;}\nvi operator&(vi& a, vi& b){    assert(sz(a)==sz(b));    vi ret(sz(a));    rep(i,sz(a)){        ret[i] = min(a[i],b[i]);    }    return ret;}\ntemplate<class T> void operator+=(mset<T> &a, vector<T>& v) { for(auto&& u : v)a.insert(u); }\ntemplate<class T> void operator+=(set<T> &a, vector<T>& v) { for(auto&& u : v)a.insert(u); }\ntemplate<class T> void operator+=(vector<T> &a, set<T>& v) { for(auto&& u : v)a.emplace_back(u); }\ntemplate<class T> void operator+=(vector<T> &a, mset<T>& v) { for(auto&& u : v)a.emplace_back(u); }\ntemplate<class T> vector<T> &operator-=(vector<T> &a, vector <T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-=\");        deb(a);        deb(b);        exit(0);    }    rep(i, sz(a))a[i] -= b[i];    return a;}\ntemplate<class T> vector<T> operator-(vector<T> &a, vector<T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-\");        deb(a);        deb(b);        ole();    }    vector<T> res(sz(a));    rep(i, sz(a))res[i] = a[i] - b[i];    return res;}\n//template<class T, class U> void operator*=(vector<T> &a, U b) {    vector<T> ta = a;    rep(b-1){        a+=ta;    }}\ntemplate<typename T> void erase(vector<T> &v, unsigned ll i) { v.erase(v.begin() + i); }\ntemplate<typename T> void erase(vector<T> &v, unsigned ll s, unsigned ll e) { v.erase(v.begin() + s, v.begin() + e); }\ntemplate<typename T> void pop_front(vector<T> &v) { erase(v, 0); }\ntemplate<typename T> void entry(vector<T> &v, unsigned ll s, unsigned ll e) { erase(v, e, sz(v));erase(v,0,s);}\n\ntemplate<class T, class U> void erase(map<T, U> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<class T> void erase(set<T> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<typename T> void erasen(vector<T> &v, unsigned ll s, unsigned ll n) { v.erase(v.begin() + s, v.begin() + s + n); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, U t) { v.insert(v.begin() + i, t); }\ntemplate<typename T, typename U> void push_front(vector<T> &v, U t) { v.insert(v.begin(), t); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, vector<T> list) { for (auto &&va:list)v.insert(v.begin() + i++, va); }\ntemplate<typename T> void insert(set<T> &v, vector<T> list) { for (auto &&va :list)v.insert(va); }\ntemplate<class T> T poll(set<T>& S){T ret = *S.begin();S.erase(S.begin());return ret;}\ntemplate<class T> T poll(mset<T>& S){T ret = *S.begin();S.erase(S.begin());return ret;}\ntemplate<class T> T poll_back(set<T>& S){T ret = *S.rbegin();S.erase(S.rbegin());return ret;}\ntemplate<class T> T poll_back(mset<T>& S){T ret = *S.rbegin();S.erase(S.rbegin());return ret;}\ntemplate<class T> T peek(set<T>& S){T ret = *S.begin();return ret;}\ntemplate<class T> T peek(mset<T>& S){T ret = *S.begin();return ret;}\ntemplate<class T> T peek_back(set<T>& S){T ret = *S.rbegin();return ret;}\ntemplate<class T> T peek_back(mset<T>& S){T ret = *S.rbegin();return ret;}\nvector<string> split(const string a, const char deli) {    string b = a + deli;    ll l = 0, r = 0, n = b.size();    vector<string> res;    rep(i, n) {        if (b[i] == deli) {            r = i;            if (l < r)res.push_back(b.substr(l, r - l));            l = i + 1;        }    }    return res;}\nvector<string> split(const string a, const string deli) {    vector<string> res;    ll kn = sz(deli);    std::string::size_type Pos(a.find(deli));    ll l = 0;    while (Pos != std::string::npos) {        if (Pos - l)res.push_back(a.substr(l, Pos - l));        l = Pos + kn;        Pos = a.find(deli, Pos + kn);    }    if (sz(a) - l)res.push_back(a.substr(l, sz(a) - l));    return res;}\nll stoi(string& s){return stol(s);}\n#define assert_yn(yn_v, v); assert(yn_v == 0 || yn_v == v);yn_v = v;\n//不完全な対策、現状はautohotkeyで対応\nint yn_v = 0;\nvoid yn(bool a) { assert_yn(yn_v, 1);if (a)cout << \"yes\" << endl; else cout << \"no\" << endl; }\nvoid fyn(bool a) {    assert_yn(yn_v, 1);yn(a);    exit(0);}\n\nvoid Yn(bool a) { assert_yn(yn_v, 2);if (a)cout << \"Yes\" << endl; else cout << \"No\" << endl; }\nvoid fYn(bool a) {    assert_yn(yn_v, 2);Yn(a);    exit(0);}\n\nvoid YN(bool a) { assert_yn(yn_v, 3);if (a)cout << \"YES\" << endl; else cout << \"NO\" << endl; }\nvoid fYN(bool a) {    assert_yn(yn_v, 3);YN(a);    exit(0);}\nint ab_v = 0;\nvoid fAb(bool a) { assert_yn(ab_v, 1);if(a)cout<<\"Alice\"<<endl;else cout<<\"Bob\";}\nvoid fAB(bool a) { assert_yn(yn_v, 2);if(a)cout<<\"ALICE\"<<endl;else cout<<\"BOB\";}\nint pos_v = 0;\nvoid Possible(bool a) {    assert_yn(pos_v, 1);if (a)cout << \"Possible\" << endl; else cout << \"Impossible\" << endl;    exit(0);}\nvoid POSSIBLE(bool a) {    assert_yn(pos_v, 2);if (a)cout << \"POSSIBLE\" << endl; else cout << \"IMPOSSIBLE\" << endl;    exit(0);}\nvoid fPossible(bool a) {    assert_yn(pos_v, 1)Possible(a);exit(0);}\nvoid fPOSSIBLE(bool a) {    assert_yn(pos_v, 2)POSSIBLE(a);exit(0);}\ntemplate<typename T> class fixed_point        : T {public:    explicit constexpr fixed_point(T &&t) noexcept: T(std::forward<T>(t)) {}    template<typename... Args> constexpr decltype(auto) operator()(Args &&... args) const { return T::operator()(*this, std::forward<Args>(args)...); }};template<typename T> static inline constexpr decltype(auto) fix(T &&t) noexcept { return fixed_point<T>{std::forward<T>(t)}; }\n\n\n//未分類\n//0,2,1 1番目と2番目の次元を入れ替える\ntemplate<class T> auto irekae(vector<vector<vector<T> > > &A, int x, int y, int z) {\n#define irekae_resize_loop(a, b, c) resize(res,a,b,c);rep(i,a)rep(j,b)rep(k,c)\n    vector<vector<vector<T> > > res;    if (x == 0 && y == 1 && z == 2) {        res = A;    } else if (x == 0 && y == 2 && z == 1) {        irekae_resize_loop(sz(A), sz(A[0][0]), sz(A[0])) {                    res[i][j][k] = A[i][k][j];                }    } else if (x == 1 && y == 0 && z == 2) {        irekae_resize_loop(sz(A[0]), sz(A), sz(A[0][0])) {                    res[i][j][k] = A[j][i][k];                }    } else if (x == 1 && y == 2 && z == 0) {        irekae_resize_loop(sz(A[0]), sz(A[0][0]), sz(A)) {                    res[i][j][k] = A[k][i][j];                }    } else if (x == 2 && y == 0 && z == 1) {        irekae_resize_loop(sz(A[0][0]), sz(A), sz(A[0])) {                    res[i][j][k] = A[j][k][i];                }    } else if (x == 2 && y == 1 && z == 0) {        irekae_resize_loop(sz(A[0][0]), sz(A[0]), sz(A)) {                    res[i][j][k] = A[k][j][i];                }    }    return res;\n#undef irekae_resize_loop\n}\ntemplate<class T> auto irekae(vector<vector<T>>&A,int i=1,int j=0){    vvt(res,sz(A[0]),sz(A));    rep(i,sz(A)){        rep(j,sz(A[0])){            res[j][i]=A[i][j];        }    }    return res;}\n//tou分割する\ntemplate<typename T> vector<vector<T>> cut(vector<T> &a, int tou = 2) {    int N = sz(a);    vector<vector<T>> res(tou);    int hab = N / tou;    vi lens(tou, hab);    rep(i, N % tou) { lens[tou - 1 - i]++; }    int l = 0;    rep(i, tou) {        int len = lens[i];        int r = l + len;        res[i].resize(len);        std::copy(a.begin() + l, a.begin() + r, res[i].begin());        l = r;    }    return res;}\n//長さn毎に分割する\ntemplate<typename T> vector<vector<T>> cutn(vector<T> &a, int len) {    int N = sz(a);    vector<vector<T>> res(ceil(N, len));    vi lens(N / len, len);    if (N % len)lens.push_back(N % len);    int l = 0;    rep(i, sz(lens)) {        int len = lens[i];        int r = l + len;        res[i].resize(len);        std::copy(a.begin() + l, a.begin() + r, res[i].begin());        l = r;    }    return res;}\n//縦を返す\nvi& geth(vvi()& a, int w){    static vi ret; ret.resize(sz(a));   rep(i,sz(a)){        ret[i] = a[i][w];    }    return ret;}\n\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} initonv;\n#define pre prev\n#define nex next\n\n//gra mll pr\n//上下左右\nconst string udlr = \"udlr\";\nstring UDLR = \"UDLR\";//x4と連動 UDLR.find('U') := x4[0]\nvc atoz = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x','y', 'z'};\nvc AtoZ = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X','Y', 'Z'};\n//右、上が正\nconstexpr ll h4[] = {1, -1, 0, 0};\nconstexpr ll w4[] = {0, 0, -1, 1};\nconstexpr ll h8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr ll w8[] = {1, 0, -1, 0, 1, -1, 1, -1};\nint mei_inc(int h, int w, int H, int W, int i) {while (++i < 4) { if (inside(h + h4[i], w + w4[i], H, W))return i; }return i;}\n#define mei(nh, nw, h, w) for (int i = mei_inc(h, w, H, W, -1), nh = i<4? h + h4[i] : 0, nw = i<4? w + w4[i] : 0; i < 4; i=mei_inc(h,w,H,W,i), nh = h+h4[i], nw = w+w4[i])\nint mei_inc8(int h, int w, int H, int W, int i) {    while (++i < 8) {        if (inside(h + h8[i], w + w8[i], H, W))return i;    }    return i;}\n#define mei8(nh, nw, h, w) for (int i = mei_inc8(h, w, H, W, -1), nh = i<8? h + h8[i] : 0, nw = i<8? w + w8[i] : 0; i < 8; i=mei_inc8(h,w,H,W,i), nh = h+h8[i], nw = w+w8[i])\nint mei_incv(int h, int w, int H, int W, int i, vp &p) {    while (++i < sz(p)) { if (inside(h + p[i].fi, w + p[i].se, H, W))return i; }    return i;}\n#define meiv(nh, nw, h, w, p) for (int i = mei_incv(h, w, H, W, -1, p), nh = i<sz(p)? h + p[i].fi : 0, nw = i<sz(p)? w + p[i].se : 0; i < sz(p); i=mei_incv(h,w,H,W,i,p), nh = h+p[i].fi, nw = w+p[i].se)\n\n//H*Wのグリッドを斜めに分割する\n//右上\nvector<vp> naname_list_ne(int H, int W) {    vector<vp> res(H + W - 1);    rep(sh, H) {        int sw = 0;        res[sh] += mp(sh, sw);        int nh = sh;        int nw = sw;        while (1) {            nh--;            nw++;            if (0 <= nh && nw < W) {                res[sh] += mp(nh, nw);            }else{                break;            }        }    }    rep(sw, 1, W) {        int sh = H - 1;        res[H + sw - 1] += mp(sh, sw);        int nh = sh;        int nw = sw;        while (1) {            nh--;            nw++;            if (0 <= nh && nw < W) {                res[H + sw-1] += mp(nh, nw);            }else{                break;            }        }    }    return res;}\n//右下\nvector<vp> naname_list_se(int H, int W) {    vector<vp> res(H + W - 1);    rep(sh, H) {        int sw = 0;        res[sh] += mp(sh, sw);        int nh = sh;        int nw = sw;        while (1) {            nh++;            nw++;            if (0 <= nh && nh< H && nw < W) { res[sh] += mp(nh, nw); } else { break; }        }    }    rep(sw, 1, W) {        int sh = 0;        res[H + sw - 1] += mp(sh, sw);        int nh = sh;        int nw = sw;        while (1) {            nh++;            nw++;            if (0 <= nh && nh < H && nw < W) { res[H + sw - 1] += mp(nh, nw); } else { break; }        }    }    return res;}\n\n//グラフ内で #undef getid\n//#define getidとしているため、ここを書き直したらgraphも書き直す\n#define getid_2(h, w) ((h) * (W) + (w))\n#define getid_1(p) ((p).first * W + (p).second)\n#define getid(...) over2(__VA_ARGS__, getid_2, getid_1) (__VA_ARGS__)\n#define getp(id) mp(id / W, id % W)\n//#define set_shuffle() std::random_device seed_gen;std::mt19937 engine(seed_gen())\n//#define shuffle(a) std::shuffle((a).begin(), (a).end(), engine);\n//1980 開始からtime ms経っていたらtrue\nvb bit_bool(int v, int len) {    assert(bit(len) > v);    vb ret(len);    rep(i, len) { ret[i] = bget(v, i); }    return ret;}\nvi &range(int l, int r) {static vi ret;ret.resize(r - l);rep(v, l, r) {ret[v - l] = v;}return ret;}\nvi &range(int r) {return range(0, r);}\nvi tov(vb& a){    vi ret;    rep(i,sz(a)){        if(a[i])ret.push_back(i);    }    return ret;}\nbool kaibun(const str& S){return S==rev(S);}\n\n#define rge range\n#define upd update\n//† ←template終了\n/*@formatter:on*/\n//vectorで取れる要素数\n//bool=> 1e9 * 8.32\n//int => 1e8 * 2.6\n//ll  => 1e8 * 1.3\n//3次元以上取るとメモリがヤバい\n//static配列を使う\n#define VEC vector\nvvc (ba);\nll N, M, H, W;\nvi A, B, C;\n\n//13:18\nvoid solve() {\n    int K;\n\n    in(H, W, K);\n    vvc(S);\n    nt(S, H, W);\n    dec(S, '0');\n    auto del_1 = [&](vvc() &S) {\n        vvc (ns, H, W, -1);\n        rep(w, W) {\n            int th = H - 1;\n            rer(h, H - 1) {\n                if (S[h][w] == -1)continue;\n                ns[th][w] = S[h][w];\n                th--;\n            }\n        }\n        return ns;\n    };\n    int ma = 0;\n    rep(dh, H) {\n        rep(dw, W) {\n            auto T = S;\n#define S !not_use!\n            T[dh][dw] = -1;\n            T = del_1(T);\n            int su = 0;\n            rep(step, 0, inf) {\n                int part = 0;\n                rep(h, H) {\n                    rep(w, W) {\n                        if(T[h][w]==-1)con;\n                        if (w + K > W)break;\n                        if (all_of(sub(T[h], w, w + K), ==T[h][w])) {\n                            int v = T[h][w];\n                            int rw = w;\n                            while (rw < W && T[h][rw] == v) {\n                                T[h][rw] = -1;\n                                part += v;\n                                rw++;\n                            }\n                        }\n                    }\n                }\n                su += bit(step) * part;\n                auto nex_T = del_1(T);\n                if (T == nex_T)break;\n                T = nex_T;\n                deb(T);\n            }\n            chma(ma, su);\n        }\n    }\n    out(ma);\n};\n\nauto my(ll n, vi &a) {\n    return 0;\n}\n\nauto sister(ll n, vi &a) {\n    ll ret = 0;\n    return ret;\n}\n\nsigned main() {\n    solve();\n\n#define arg n,a\n#ifdef _DEBUG\n\n    bool bad = 0;\n    for (ll i = 0, ok = 1; i < k5 && ok; ++i) {\n        ll n = rand(1, 8);\n        vi a = ranv(n, 1, 10);\n        auto myres = my(arg);\n        auto res = sister(arg);\n        ok = myres == res;\n        if (!ok) {\n            out(arg);\n            cerr << \"AC : \" << res << endl;\n            cerr << \"MY  : \" << myres << endl;\n            bad = 1;\n\n\n            break;\n        }\n    }\n    if (!bad) {\n//        cout << \"完璧 : solveを書き直そう\" << endl;\n//        cout << \"     : そして、solve()を呼び出すのだ\" << endl;\n//        cout << \"     : cin>>n; na(a,n);も忘れるな\" << endl;\n    }\n    if (was_deb && sz(res_mes)) {\n        cerr << \"result = \" << endl << res_mes << endl;\n    }\n    if (sz(message)) {\n        cerr << \"****************************\" << endl;\n        cerr << \"Note.\" << endl;\n        cerr << message << endl;\n        cerr << \"****************************\" << endl;\n    }\n#endif\n    return 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing ll = int64_t;\nusing pint = pair<int, int>;\n\nint main()\n{\n    int h, w, k;\n    cin >> h >> w >> k;\n\n    vector<vector<int>> table(h, vector<int>(w));\n    rep(i, h)\n    {\n        string s;\n        cin >> s;\n        rep(j, w) table[i][j] = s[j] - '0';\n    }\n\n    int ans = 0;\n    rep(ri, h) rep(rj, w)\n    {\n        int sum = 0;\n        int rate = 1;\n        auto tmp_table = table;\n        tmp_table[ri][rj] = -1;\n        {\n            int j = rj;\n            int s = ri;\n            for (int i = ri; i >= 0; --i)\n                if (tmp_table[i][j] != -1)\n                    swap(tmp_table[i][j], tmp_table[s][j]), --s;\n        }\n        while (1)\n        {\n            int prev = sum;\n            rep(i, h) rep(j, w - k + 1)\n            {\n                int tmp = tmp_table[i][j];\n                if (tmp == -1)\n                    continue;\n                int con = 1;\n                for (int l = j + 1; l < w; ++l)\n                    if (tmp_table[i][l] == tmp)\n                        ++con;\n                    else\n                        break;\n                if (con >= k)\n                {\n                    rep(l, con) tmp_table[i][j + l] = -1;\n                    sum += tmp * con * rate;\n                }\n            }\n            if (sum == prev)\n                break;\n            rep(j, w)\n            {\n                int s = h - 1;\n                for (int i = h - 1; i >= 0; --i)\n                    if (tmp_table[i][j] != -1)\n                        swap(tmp_table[i][j], tmp_table[s][j]), --s;\n            }\n            rate <<= 1;\n        }\n\n        ans = max(ans, sum);\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <boost/multiprecision/cpp_int.hpp>\nusing namespace std;\nusing namespace boost::multiprecision;\n\n# define REP(i,n) for (int i=0;i<(n);++i)\n# define rep(i,a,b) for(int i=a;i<(b);++i)\n# define all(v) v.begin(),v.end()\n# define showVector(v) REP(i,v.size()){cout << (v[i]) << \" \";} cout << endl;\ntemplate<class T> inline bool chmin(T &a, T b){ if(a > b) { a = b; return true;} return false;}\ntemplate<class T> inline bool chmax(T &a, T b){ if(a < b) { a = b; return true;} return false;}\ntypedef long long int ll;\ntypedef pair<ll,ll> P_ii;\ntypedef pair<double,double> P_dd;\n\ntemplate<class T>\nusing MaxHeap = std::priority_queue<T>;\n\ntemplate<class T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\ntemplate<class T>\nvector<T> make_vec(size_t a){\n    return vector<T>(a);\n}\n\ntemplate<class T, class... Ts>\nauto make_vec(size_t a, Ts... ts){\n  return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\nint pop_count(int n){\n  return __builtin_popcount(n);\n}\n\nint pop_count(ll n){\n  return __builtin_popcountll(n);\n}\n\nll gcd(ll a, ll b) {\n    if(a < b) swap(a,b);\n    \n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\nll lcm(ll a, ll b){\n    ll g = gcd(a,b);\n    return (a/g)*b;\n}\n\n// 素数判定 O(√n)\nbool is_prime(int n){\n    for(int i = 2; i * i <= n; i++){\n        if(n % i == 0) return false;\n    }\n    return true;\n}\n\n// 約数列挙 O(√n)\nvector<ll> divisor(ll n){\n    vector<ll> res;\n    for(ll i = 1; i * i <= n; i++){\n        if(n % i == 0){\n            res.push_back(i);\n            if(i != n / i) res.push_back(n / i);\n        }\n    }\n    return res;\n}\n\ntemplate<typename T>\nmap<T, ll> prime_factorize(T x){\n  map<T, ll> res;\n  for(int i=2;i*i<=x;i++){\n    while(x%i==0){\n      x/=i;\n      res[i]++;\n    }\n  }\n  if(x!=1) res[x]++;\n  return res;\n}\n\n// エラトステネスの篩\n// return lp[i] := iの最小素因数(lp[i] == iならば素数)\nvector<int> SieveOfEratosthenes(int N = 10000000){\n  vector<int> lp(N + 1, 0);\n  vector<int> pr;\n  for (int i=2; i<=N; ++i) {\n      if (lp[i] == 0) {\n          lp[i] = i;\n          pr.push_back(i);\n      }\n      for (int j=0; j<(int)pr.size() && pr[j]<=lp[i] && i*pr[j]<=N; ++j)\n          lp[i * pr[j]] = pr[j];\n  }\n  return lp;\n}\n\n\n// auto mod int\n// https://youtu.be/L8grWxBlIZ4?t=9858\n// https://youtu.be/ERZuLAxZffQ?t=4807 : optimize\n// https://youtu.be/8uowVvQ_-Mo?t=1329 : division\nconst int mod = 1000000007;\nstruct mint {\n  ll x; // typedef long long ll;\n  mint(ll x=0):x(x%mod){}\n  mint& operator+=(const mint a) {\n    if ((x += a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator-=(const mint a) {\n    if ((x += mod-a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator*=(const mint a) {\n    (x *= a.x) %= mod;\n    return *this;\n  }\n  mint operator+(const mint a) const {\n    mint res(*this);\n    return res+=a;\n  }\n  mint operator-(const mint a) const {\n    mint res(*this);\n    return res-=a;\n  }\n  mint operator*(const mint a) const {\n    mint res(*this);\n    return res*=a;\n  }\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n \n  // for prime mod\n  mint inv() const {\n    return pow(mod-2);\n  }\n  mint& operator/=(const mint a) {\n    return (*this) *= a.inv();\n  }\n  mint operator/(const mint a) const {\n    mint res(*this);\n    return res/=a;\n  }\n};\n\nconst int MOD = 1000000007;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\n\nll intceil(ll a, ll b){\n    if(a < 0){\n      a *= -1;\n      b *= -1;\n    }\n    if(b >= 0) return (a + b - 1 ) / b;\n    return a / b;\n}\n\nll intfloor(ll a, ll b){\n    if(a < 0){\n      a *= -1;\n      b *= -1;\n    }\n    if(b >= 0) return a / b;\n    return (a - b + 1) / b;\n}\n\nvoid addM(ll &a, ll b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\n\nvoid mulM(ll &a, ll b) {\n    a = ((a%MOD)*(b%MOD))%MOD ;\n}\n\nll powM(ll a,ll b) {\n    ll ret = 1;\n    ll tmp = a;\n    while(b>0) {\n        if((b&1)==1) ret = (ret * tmp) % MOD;\n        tmp = (tmp * tmp) % MOD;\n        b = b >> 1;\n    }\n    return ret;\n}\n\n// mod. m での a の逆元 a^{-1} を計算する\nll modinv(ll a, ll m) {\n    ll b = m, u = 1, v = 0;\n    while (b) {\n        ll t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    u %= m;\n    if (u < 0) u += m;\n    return u;\n}\n\n// ラングレンス圧縮\nvector<pair<char, int>> rang_com(string s){\n  vector<pair<char, int>> ret;\n  string t = s;\n  t.erase(unique(all(t)), t.end());\n  int now = 0;\n  int pre = 0;\n  for(auto ct : t){\n    while(now < s.size() && s[now] == ct) now++;\n    if(ret.size() == 0){\n      ret.push_back({ct, now});\n    } else {\n      ret.push_back({ct, now - pre});\n    }\n    pre = now;\n  }\n  return ret;\n}\n\nconst int MAX = 5100000;\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nstruct UnionFind {\n    vector<int> par;\n    vector<int> sz;\n    map<int, int> szmp; // map<size, cnt>\n \n    UnionFind(int n = 0){\n        if(n > 0) initialize(n);\n    }\n \n    void initialize(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i = 0; i < n; i++){\n            par[i] = i;\n            sz[i] = 1;\n        }\n        szmp[1] = n;\n    }\n \n    int find(int x){\n        if(par[x] == x){\n            return x;\n        } else {\n            return par[x] = find(par[x]);\n        }\n    }\n \n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n        if(sz[x] > sz[y]) swap(x, y);\n \n        for(int s : {sz[x], sz[y]}){\n            szmp[s]--;\n            if(szmp[s] == 0) szmp.erase(s);\n        }\n        par[x] = y;\n        sz[y] += sz[x];\n        szmp[sz[y]]++;\n    }\n \n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n \n    int size(int x){\n        return sz[find(x)];\n    }\n \n    int minsz(){\n        return szmp.begin() -> first;\n    }\n\n    int unitenum(){\n        return szmp.size();\n    }\n};\n\nstruct circle {\n  double x, y, r;\n  circle(double x, double y, double r): x(x), y(y), r(r){};\n};\n\n\nint main(void) {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int H, W, K;\n    cin >> H >> W >> K;\n\n    int C[30][30];\n    REP(i, H) {\n      string s;\n      cin >> s;\n      REP(j, W) C[i][j] = s[j] - '0';\n    }\n\n    ll ans = 0;\n    REP(x, H) REP(y, W){\n\n        int c[30][30];\n        REP(i, H) REP(j, W) c[i][j] = C[i][j];\n\n        c[x][y] = 0;\n        for(int i = x; i - 1 >= 0; i--){\n          swap(c[i-1][y], c[i][y]);\n        }\n\n        ll pw = 1, result = 0;\n        while(true){\n            ll num = 0;\n            REP(i, H){\n                REP(j, W) {\n                    int st = j;\n                    while(st < W && c[i][j] == c[i][st]) st++;\n                    if(st - j >= K){\n                        for(int l = j; l < st; l++){\n                            num += c[i][l];\n                            c[i][l] = 0;\n                        }\n                    }\n                    j = st - 1;\n                }\n            }\n            if(num == 0) break;\n            result += pw * num;\n \n            REP(j, W){\n                int pos = H - 1;\n                for(int i = H - 1; i >= 0; i--){\n                    if(c[i][j] > 0){\n                        c[pos][j] = c[i][j];\n                        if(pos != i) c[i][j] = 0;\n                        pos--;\n                    }\n                }\n            }\n            pw *= 2;\n        }\n        ans = max(ans, result);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing vc = vector<char>;\nusing vvc = vector<vc>;\nusing pll = pair<ll, ll>;\nusing stkll = vector<pll>;\nconst ll INF = 1LL << 60;\nconst ll MOD = 1e9 + 7;\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define debug(x) cerr << #x << \": \" << x << endl;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\nint main() {\n    ll H, W, K;\n    cin >> H >> W >> K;\n    vvc org(H+1, vc(W, '0'));\n    rep(i, H) rep(j, W) cin >> org[H-1-i][j];\n\n    ll ans = 0;\n\n    if(K == 1) {\n        rep(i, H) rep(j, W) ans += org[i][j] - '0';\n        cout << ans << endl;\n        return 0;\n    }\n\n    rep(py, H) rep(px, W) {\n        if(py == 0 && px == 2) {\n            ;\n        }\n\n        vvc in(H+1, vc(W, '0'));\n        rep(i, H) rep(j, W) in[i][j] = org[i][j];\n\n        for(ll y = py; y < H; y++) in[y][px] = in[y+1][px];\n\n        ll ret = 0, num = 0;\n        bool end = false;\n        while(!end) {\n            vvb used(H+1, vb(W, false));\n            end = true;\n            ll sumin = 0;\n\n            rep(i, H) {\n                ll left = 0, right = 0, cnt = 1;\n                for(ll j = 1; j <= W; j++) {\n                    if(in[i][j-1] == in[i][j] && in[i][j] != '0') {\n                        cnt++;\n                        right = j;\n                        if(j == W && cnt >= K) {\n                            sumin += cnt * (in[i][j] - '0');\n                            for(ll k = left; k <= right; k++) used[i][k] = true;\n                            end = false;\n                        }\n                    }\n                    else {\n                        if(cnt >= K) {\n                            sumin += cnt * (in[i][j-1] - '0');\n                            for(ll k = left; k <= right; k++) used[i][k] = true;\n                            end = false;\n                        }\n                        left = right = j;\n                        cnt = 1;\n                    }\n                }\n            }\n            ret += (1<<num) * sumin;\n            num++;\n\n            rep(j, W) {\n                rep(i, H) {\n                    ll k = i;\n                    while(used[k][j]) k++;\n                    in[i][j] = in[k][j];\n                    if(in[k][j] != '0') used[k][j] = true;\n                }\n            }\n        }\n        chmax(ans, ret);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\n#define IINF 10e8\n#define INF 1<<30\n#define MOD 1000000007\n#define mod 1000000007\n#define rep(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define Endl endl\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define siz(x) (ll)(x).size()\n#define PI acos(-1.0)\nusing namespace std;\n//using Int=int_fast64_t;\ntypedef long long int ll;\ntypedef long long int LL;\ntypedef pair<ll,ll>Pll;\ntypedef pair<int,int>Pin;\ntemplate<class T> using V=vector<T>;\nlong long GCD(long long a, long long b) { return b ? GCD(b, a%b) : a; }\nlong long LCM(long long a, long long b)  {return a/GCD(a,b)*b;}\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\nint ddx[8]={-1,0,1,0,1,1,-1,-1};\nint ddy[8]={0,-1,0,1,1,-1,1,-1};\nchar dir[4]={'u','l','d','r'};\nll cmp(pair<ll,ll>a,pair<ll,ll> b){\n        if(a.se!=b.se)\n        return a.se<b.se;\n        else\n        return a.fi<b.fi;\n}\n//---------------------------------------------------------------------------\nll modpow(ll a, ll n) {//a^n(MOD)を求める\n    ll res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % MOD;\n        a = a * a % MOD;//次の準備\n        n >>= 1;\n    }\n    return res;\n}\n//---------------------------------------------------------------------------\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------\n    ll h,w,k;cin>>h>>w>>k;\n    ll a[30][30];\n    for(ll i=0;i<h;i++){\n        for(ll j=0;j<w;j++){\n            char c;cin>>c;\n            a[i][j]=c-'0';\n        }\n    }\n    ll ans=0;\n    for(ll i=0;i<h;i++){\n        for(ll j=0;j<w;j++){\n            ll b[30][30];\n            for(ll x=0;x<h;x++){\n                for(ll y=0;y<w;y++){\n                    b[x][y]=a[x][y];\n                }\n            }\n            b[i][j]=0;\n            queue<Pll>del;\n            del.push(mp(i,j));\n            ll cnt=0;\n            ll turn=0;\n            \n            \n            //cout<<1<<endl;\n            while(!del.empty()){\n                //delete\n                map<Pll,ll>m;\n                while(!del.empty()){\n                Pll p=del.front();del.pop();\n                m[p]++;\n                }\n            \n            //move\n            \n            for(ll x=0;x<w;x++){\n                for(ll y=h-1;y>=0;y--){\n                    if(m[{y,x}]){\n                        bool xyz=0;\n                        for(ll z=y-1;z>=0;z--){\n                            if(m[{z,x}]==0){\n                                b[y][x]=b[z][x];\n                                m[{z,x}]=1;\n                                xyz=1;\n                                break;\n                            }\n                        }\n                        if(xyz==0)\n                            b[y][x]=-1;\n                    }\n                }\n            }\n                \n            \n            //push\n            ll tmp=0;\n            for(ll x=0;x<h;x++){\n                for(ll y=0;y<w-k+1;y++){\n                    ll prey=y;\n                    if(b[x][y]==-1)continue;\n                    bool xyz=1;\n                    for(ll z=y+1;z<y+k;z++){\n                        if(b[x][z]!=b[x][z-1]){\n                            xyz=0;\n                            break;\n                        }\n                    }\n                    if(xyz==1){\n                        for(ll z=y;z<w;z++){\n                            if(b[x][z]==b[x][y]){\n                            del.push(mp(x,z));\n                            tmp+=b[x][z];\n                              \n                                prey=z;\n                            }\n                            else{\n                                break;\n                            }\n                        }\n                    }\n                    y=prey;\n                }\n            }\n   \n            //if(i==3&&j==2)cout<<tmp<<endl;\n            cnt+=modpow(2,turn)*tmp;\n            turn++;\n            }\n            //cout<<cnt<<endl;\n            chmax(ans,cnt);\n        }\n    }\n\n    cout<<ans<<endl;\n    //-------------------------------\n    return 0;\n}\n//---------------------------------------------------------------------------\n/*\nint n;cin>>n;\nvector<int>a(n);\nfor(int i=0;i<n;i++)\n    cin>>a[i];\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst ll MOD = 1'000'000'007;\nconst ld PI = acos(-1);  \nconst ld EPS = 0.0000000001;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define REP(i, n) for(ll i=0; i<(ll)(n); i++)\n#define REPD(i, n) for(ll i=n-1; 0<=i; i--)\n#define FOR(i, a, b) for(ll i=a; i<(ll)(b); i++)\n#define FORD(i, a, b) for(ll i=a; (ll)(b)<=i; i--)\n#define ALL(x) x.begin(), x.end()\n#define MAX(x) *max_element(ALL(x))\n#define MIN(x) *min_element(ALL(x))\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint main(){\n    ll h, w, k;  cin >> h >> w >> k;\n    vector<vector<ll>> ori(h, vector<ll>(w));\n    REP(i, h) REP(j, w){\n        char c; cin >> c;\n        ori[i][j] = c-'0';\n    }\n    \n    ll res=0;\n    REP(x, h){\n        REP(y, w){\n            ll tmp=0, times=0;\n            bool flag=true;\n            vector<vector<ll>> g = ori;\n            g[x][y] = 0;\n            while(flag){\n                flag = false;\n                REP(i, h){\n                    ll bef=g[i][0], cnt=0, st=0, index=w;\n                    \n                    REP(j, w){\n                        if(g[i][j]==bef && 0<bef) cnt += 1;\n                        else{\n                            if(cnt<k){\n                                if(0<g[i][j]){\n                                    cnt = 1; st=j;\n                                }\n                            }else{\n                                if(bef)index = j;\n                                break;\n                            }\n                        }\n                        bef = g[i][j];\n                    }\n                    if(k<=cnt){\n                        tmp += (1<<times)*cnt*bef;\n                        FOR(j, st, index) g[i][j] = 0;\n                        flag = true;\n                    }\n                }\n                REPD(i, h){\n                    REP(j, w){\n                        if(!g[i][j]){\n                            REPD(k, i){\n                                if(!g[k][j]) continue;\n                                swap(g[k][j], g[i][j]); break;\n                            }\n                        }\n                    }\n                }\n                REP(i, h){\n                    ll bef=g[i][0], cnt=0, st=0, index=w;\n                    \n                    REP(j, w){\n                        if(g[i][j]==bef && 0<bef) cnt += 1;\n                        else{\n                            if(cnt<k){\n                                if(0<g[i][j]){\n                                    cnt = 1; st=j;\n                                }\n                            }else{\n                                if(bef)index = j;\n                                break;\n                            }\n                        }\n                        bef = g[i][j];\n                    }\n                    if(k<=cnt){\n                        tmp += (1<<times)*cnt*bef;\n                        FOR(j, st, index) g[i][j] = 0;\n                        flag = true;\n                    }\n                }\n                if(0<tmp)   times += 1;\n            }\n            res = max(res, tmp);\n            //cout << x <<':' << y << ' ' << tmp << endl << endl;\n        }\n    }\n    ll tmp=0, times=0;\n    bool flag=true;\n    vector<vector<ll>> g = ori;\n    while(flag){\n        flag = false;\n        REP(i, h){\n            ll bef=g[i][0], cnt=0, st=0, index=w;\n            \n            REP(j, w){\n                if(g[i][j]==bef && 0<bef) cnt += 1;\n                else{\n                    if(cnt<k){\n                        if(0<g[i][j]){\n                            cnt = 1; st=j;\n                        }\n                    }else{\n                        if(bef)index = j;\n                        break;\n                    }\n                }\n                bef = g[i][j];\n            }\n            if(k<=cnt){\n                tmp += (1<<times)*cnt*bef;\n                FOR(j, st, index) g[i][j] = 0;\n                flag = true;\n            }\n        }\n        REPD(i, h){\n            REP(j, w){\n                if(!g[i][j]){\n                    REPD(k, i){\n                        if(!g[k][j]) continue;\n                        swap(g[k][j], g[i][j]); break;\n                    }\n                }\n            }\n        }\n        REP(i, h){\n            ll bef=g[i][0], cnt=0, st=0, index=w;\n            \n            REP(j, w){\n                if(g[i][j]==bef && 0<bef) cnt += 1;\n                else{\n                    if(cnt<k){\n                        if(0<g[i][j]){\n                            cnt = 1; st=j;\n                        }\n                    }else{\n                        if(bef)index = j;\n                        break;\n                    }\n                }\n                bef = g[i][j];\n            }\n            if(k<=cnt){\n                tmp += (1<<times)*cnt*bef;\n                FOR(j, st, index) g[i][j] = 0;\n                flag = true;\n            }\n        }\n        times += 1;\n    }\n    res = max(res, tmp);\n    cout << res << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "//https://atcoder.jp/contests/s8pc-3/tasks/s8pc_3_b\n//B - 石落としゲーム\n#include <bits/stdc++.h>\n#if LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\nusing namespace std;\nusing ll=long long;\nconst ll LINF = 0x1fffffffffffffff;\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\ntemplate<class T>bool chmax(T &a, const T &b) {if (a<b) { a=b; return 1; } return 0;}\ntemplate<class T>bool chmin(T &a, const T &b) {if (b<a) { a=b; return 1; } return 0;}\nint main() {\n#if LOCAL&01\n  std::ifstream in(\"./test/sample-3.in\");\n  //std::ifstream in(\"./input.txt\");\n  std::cin.rdbuf(in.rdbuf());\n#else\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n#endif\n  ll H,W,K; cin>>H>>W>>K;\n  using Mat = vector<vector<ll>>;\n  vector<vector<ll>> chw(H,vector<ll>(W));\n  vector<string> chw_str(H);\n  REP(i,H){\n    cin>>chw_str[i];\n    const auto& s=chw_str[i];\n    FOR(x,0,s.size()){\n      ll v=s.at(x)-'0';\n      chw[i][x]=v;\n    }\n  }\n\n  auto kesu_line = [&](vector<ll>& ln)->ll{\n    ll result=0;\n    for(ll x=0;x<W;++x){\n      ll sc=ln[x];\n      if(sc==0)continue;\n      ll num=1;\n      while(true){\n        ll cx=x+num;\n        if(cx>=W)break;\n        if(sc==ln[cx]) ++num;\n        else {\n          break;\n        }\n      }\n      if(num>=K){\n        FOR(i,x,x+num){\n          result += ln[i];\n          ln[i]=0;\n        }\n      }\n    }\n    return result;\n  };\n  auto kesu = [&](Mat& mat)->ll{\n    ll result=0;\n    FOR(y,0,H){\n      result += kesu_line(mat.at(y));\n    }\n    return result;\n  };\n  auto otosu_line = [&](Mat& mat, ll ix){\n    for(ll y=H-1;y>=1;--y){\n      if(mat[y][ix]==0){\n        for(ll ty=y-1;ty>=0;--ty){\n          if (mat[ty][ix]!=0){\n            swap(mat[y][ix],mat[ty][ix]);\n            break;\n          }\n        }\n      }\n    }\n  };\n  auto otosu = [&](Mat& mat){\n    FOR(x,0,W){\n      otosu_line(mat, x);\n    }\n  };\n\n  //一番した調べればいいだけではないな...\n  ll ans=0;\n  //ll del_y=H-1;\n  FOR(del_y,0,H)\n  FOR(del_x,0,W){\n    auto wk=chw; //copy\n    wk[del_y][del_x]=0;\n    otosu_line(wk,del_x);\n\n    ll rate=1;\n    ll score=0;\n    do{\n      ll r = kesu(wk);\n      dump(rate,r,wk);\n      if(r==0)break;\n      score += (r * rate);\n      rate *= 2;\n      otosu(wk);\n    }while(true);\n    chmax(ans,score);\n  }\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC diagnostic ignored \"-Wunused-variable\" \n#include <bits/stdc++.h>\nusing namespace std;\n\n#define BOOST\n#ifdef BOOST\n#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/multiprecision/cpp_dec_float.hpp>\n#include <boost/range/adaptor/reversed.hpp>\nusing namespace boost;\nusing ml = boost::multiprecision::cpp_int;\nusing md = boost::multiprecision::cpp_dec_float_100;\n#define forir(i, ...) if(ll i=(ll)v.size())for(__VA_ARGS__)if(i--,1)\n#define eachr(i, e, c) forir(i, auto &&e: adaptors::reverse(c))\n#endif\n\n/***** type *****/\nusing ll = long long;\nusing ld = long double;\nusing pll = pair<long long, long long>;\ntemplate <class T> using vt = vector<T>;\ntemplate <class T> using vvt = vector<vector<T>>;\ntemplate <class T> using vvvt = vector<vector<vector<T>>>;\n/***** define *****/\n#define all(c) (c).begin(), (c).end()            // begin to end\n#define coutd cout << fixed << setprecision(10)  // cout double\n#define output(x) do{cout<<x;return 0;}while(0)  // cout return\n#define rep(i, b, e) for (ll i = b; i < e; i++)  // repeat\n#define repr(i, b, e) for (ll i = b; e < i; i--) // repeat reverse\n#define fori(i, ...) if (ll i = -1) for(__VA_ARGS__) if (i++, 1)\n#define each(i, e, c) fori (i, auto&& e: c)      // for each\n/***** const value *****/\n#define llong_max 9223372036854775807            // 9 * 10^18\n#define ldbl_max 1.79769e+308                    // 1.7 * 10^308\n#define pi 3.1415926535897932                    // 3.14 ...\n/***** lambda *****/\nauto Ceil = [] // if (a % b != 0) return a / b + 1;\n(auto x) { return (ll)ceil(x); };\nauto Count = [] // long long count value\n(auto b, auto e, auto x) { return (ll)count(b, e, x); };\nauto CtoL = [] // char to number\n(auto c) { return (ll)c - (ll)'0'; };\nauto LtoC = [] // number to char\n(auto n) { return (char)('0' + n); };\nauto Pow = [] // long long pow\n(auto a, auto b) { return (ll)pow(a, b); };\nauto Pow2 = [] // long long pow2\n(auto n) { return (1LL << n); };\nauto Pow10 = [] // long long pow10\n(auto n) { return (ll)pow(10, n); };\nauto Size = []  // long long collection size\n(auto& c) { return (ll)(c).size(); };\nauto Sum = [] // long long accumulate\n(auto b, auto e) { return accumulate(b, e, 0LL); };\n\n/***** template *****/\ntemplate <class T> void MakeVVT\n(ll ys, ll xs, vvt<T>& v, T fill = T())\n{\t// vector<vector<T>> resize + fill\n\tv.resize(ys); rep(y, 0, ys) v[y].resize(xs, fill);\n}\ntemplate <class T> void MakeVVVT\n(ll zs, ll ys, ll xs, vvvt<T>& v, T fill = T())\n{\t// vector<vector<vector<T>>> resize + fill\n\tv.resize(zs); rep(z, 0, zs) MakeVVT(ys, xs, v[z], fill);\n}\ntemplate <class T> void InputVT\n(ll xs, vt<T>& v, T fix = T())\n{\t// input vector<T> (T != struct) + fix\n\tv.resize(xs); rep(i, 0, xs) { cin >> v[i]; v[i] += fix; }\n}\ntemplate <class T> void InputVVT\n(ll ys, ll xs, vvt<T>& v, T fix = T())\n{\t// input vector<vector<T>> (T != struct) + fix\n\tMakeVVT(ys, xs, v, fix);\n\trep(y, 0, ys) rep(x, 0, xs) { cin >> v[y][x]; v[y][x] += fix; }\n}\ntemplate <class T> void InputVVVT\n(ll zs, ll ys, ll xs, vvvt<T>& v, T fix = T())\n{\t// input vector<vector<vector<T>>> (T != struct) + fix\n\tv.resize(zs); rep(z, 0, zs) InputVVT(ys, xs, v[z], fix);\n}\n\n/**************************************/\n/********** BEGIN OF NYA LIB **********/\n/**************************************/\n\nnamespace NyaGadget {}\n\nnamespace NyaGadget\n{\n\t/*** ランレングス圧縮ライブラリ ***/\n\n\ttemplate <class T> struct RunLengthEncodingResult\n\t{\t// ランレングス圧縮の結果を格納する構造体\n\t\tlong long begin = 0; // 区間開始位置\n\t\tlong long end = 0;   // 区間終了位置\n\t\tstd::vector<T> sub;  // 区間データ\n\t};\n\n\ttemplate <> struct RunLengthEncodingResult<std::string>\n\t{\t// ランレングス圧縮の結果を格納する構造体\n\t\tlong long begin = 0; // 区間開始位置\n\t\tlong long end = 0;   // 区間終了位置\n\t\tstd::string sub;     // 区間データ\n\t};\n\n\tstruct DS_NyaaRLE\n\t{\n\t\t/**\n\t\t@brief 文字列のランレングス圧縮\n\t\t@param s 圧縮する文字列\n\t\t@param res 圧縮結果\n\t\t**/\n\t\tstatic void Run(std::string& s, std::vector<RunLengthEncodingResult<std::string>>& res)\n\t\t{\n\t\t\tres.push_back({ 0, 0, \"\" });\n\t\t\tfor (long long i = 0; i < (long long)s.size(); i++)\n\t\t\t{\n\t\t\t\tif (i == (long long)s.size() - 1)\n\t\t\t\t{\n\t\t\t\t\tres.back().end = i + 1;\n\t\t\t\t\tres.back().sub = s.substr(res.back().begin, i + 1 - res.back().begin);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (s[i] != s[i + 1])\n\t\t\t\t{\n\t\t\t\t\tres.back().end = i + 1;\n\t\t\t\t\tres.back().sub = s.substr(res.back().begin, i + 1 - res.back().begin);\n\t\t\t\t\tres.push_back({ i + 1, 0, \"\" });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t@brief 配列のランレングス圧縮\n\t\t@param v 圧縮する配列\n\t\t@param res 圧縮結果\n\t\t**/\n\t\ttemplate <class T> static void Run(std::vector<T>& v, std::vector<RunLengthEncodingResult<T>>& res)\n\t\t{\n\t\t\tres.push_back({ 0, 0, std::vector<T>() });\n\t\t\tfor (long long i = 0; i < (long long)v.size(); i++)\n\t\t\t{\n\t\t\t\tif (i == (long long)v.size() - 1)\n\t\t\t\t{\n\t\t\t\t\tres.back().end = i + 1;\n\t\t\t\t\tfor (long long j = res.back().begin; j < i + 1; j++) res.back().sub.push_back(v[j]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!IsSame(v[i], v[i + 1]))\n\t\t\t\t{\n\t\t\t\t\tres.back().end = i + 1;\n\t\t\t\t\tfor (long long j = res.back().begin; j < i + 1; j++) res.back().sub.push_back(v[j]);\n\t\t\t\t\tres.push_back({ i + 1, 0, std::vector<T>() });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttemplate <class T> static bool IsSame(T& l, T& r)\n\t\t{\t// lとrが同値かどうか調べる\n\t\t\treturn l == r;\n\t\t}\n\t};\n}\n\n/**************************************/\n/*********** END OF NYA LIB ***********/\n/**************************************/\n\nusing namespace NyaGadget;\n//using mll = NT_ModLL< 1000000007 >;\n//using mll = NT_ModLL< 998244353 >;\n\nvoid NyaaDelete(vvt<ll>& grid, ll K, ll& res)\n{\n\tll count = 1;\n\tll H = Size(grid);\n\tll W = Size(grid[0]);\n\twhile (1)\n\t{\n\t\tll score = 0;\n\t\trep(y, 0, H)\n\t\t{\n\t\t\tvt<ll> test(W);\n\t\t\trep(x, 0, W) test[x] = grid[x][y];\n\t\t\tstd::vector<RunLengthEncodingResult<ll>> rleRes;\n\t\t\tDS_NyaaRLE::Run(test, rleRes);\n\n\t\t\teach(i, e, rleRes)\n\t\t\t{\n\t\t\t\tif (e.sub[0] == 0) continue;\n\t\t\t\tif (K <= Size(e.sub))\n\t\t\t\t{\n\t\t\t\t\trep(xx, e.begin, e.end) grid[xx][y] = 0;\n\t\t\t\t\tscore = Pow2(count) * e.sub[0] * Size(e.sub);\n\t\t\t\t\tres += score;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvvt<ll> test; MakeVVT(W, H, test);\n\t\trep(x, 0, W)\n\t\t{\n\t\t\tll yy = 0;\n\t\t\trep(y, 0, H) if (grid[x][y] != 0) test[x][yy++] = grid[x][y];\n\t\t}\n\t\tgrid = test;\n\t\tif (score == 0) return;\n\t\t++count;\n\t}\n}\n\nint main(void)\n{\n\tll H, W, K; cin >> H >> W >> K;\n\tvvt<ll> c; MakeVVT(W, H, c);\n\trepr(y, H - 1, -1)\n\t{\n\t\tstring test; cin >> test;\n\t\trep(x, 0, W) c[x][y] = CtoL(test[x]);\n\t}\n\n\tll ans = 0;\n\trep(x, 0, W) rep(y, 0, H)\n\t{\n\t\tvvt<ll> test = c;\n\t\trep(yy, y + 1, H) test[x][yy - 1] = test[x][yy];\n\t\ttest[x].back() = 0;\n\t\tll res = 0;\n\n\t\tNyaaDelete(test, K, res);\n\t\tans = max(ans, res);\n\t}\n\tcout << ans / 2;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repd(i,a,b) for (int i=(a);i<(b);i++)\n#define rep(i,n) repd(i,0,n)\n#define all(x) (x).begin(),(x).end()\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntypedef long long ll;\nconst long long INF = 1LL << 60;\ntypedef pair<int, int> P;\nint main()\n{\n    int H, W, K;\n    cin >> H >> W >> K;\n    vector<vector<int>> HW(H, vector<int>(W)), HW2(H, vector<int>(W));\n\n    rep(i, H) {\n        rep(j, W) {\n            char c;\n            cin >> c;\n            HW[H - i - 1][j] = c - '0';\n            HW2[H - i - 1][j] = HW[H - i - 1][j];\n        }\n    }\n\n    ll ans = 0;\n    rep(i, H) {\n        rep(j, W) {\n            ll res = 0;\n            repd(k, i + 1, H) {\n                HW[k - 1][j] = HW[k][j];\n            }\n            HW[H - 1][j] = -1;\n            ll cnt = 1;\n            while (1) {\n                vector<vector<int>> check(H, vector<int>(W, 0));\n                rep(k, H) {\n                    repd(l, 1, W) {\n                        if (HW[k][l] == -1) continue;\n                        if (HW[k][l] == HW[k][l - 1]) {\n                            check[k][l] = check[k][l - 1] + 1;\n                        }\n                    }\n                }\n\n                bool flag = false;\n                ll point = 0;\n                rep(k, H) {\n                    for (int l = W - 1; l >= 0; l--) {\n                        if (check[k][l] + 1 >= K) {\n                            repd(m, l - check[k][l], l + 1) {\n                                point += HW[k][m];\n                                HW[k][m] = -1;\n                            }\n                            l -= check[k][l];\n                            flag = true;\n                        }\n                    } \n                }\n\n                if (!flag) break;\n                else res += cnt * point;\n                \n                bool fall = true;\n                while (fall) {\n                    fall = false;\n                    repd(k, 1, H) {\n                        rep(l, W) {\n                            if (HW[k][l] == -1) continue;\n                            if (HW[k - 1][l] == -1) {\n                                HW[k - 1][l] = HW[k][l];\n                                HW[k][l] = -1;\n                                fall = true;\n                            }\n                        }\n                    }\n                }\n\n                cnt *= 2;\n            }\n            chmax(ans, res);\n\n            rep(k, H) {\n                rep(j, W) {\n                    HW[k][j] = HW2[k][j];\n                }\n            }\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair< ll, ll > Pi;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep2(i,n) for(int i=1;i<=(n);i++)\n#define rep3(i,i0,n) for(int i=i0;i<(n);i++)\n#define pb push_back\n#define mod 1000000007\nconst ll INF = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nll gcd(ll a, ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b) {return a/gcd(a,b)*b;}\n#define all(x) x.begin(), x.end()\n#define mp make_pair\nbool compare(Pi a, Pi b) {\n    if(a.first != b.first){\n        return a.first < b.first;\n        \n    }else{\n        return a.second < b.second;\n    }\n}\n\nint ctoi(char c) {\n\tif (c >= '0' && c <= '9') {\n\t\treturn c - '0';\n\t}\n\treturn 0;\n}\nbool In_map(ll y,ll x,ll h,ll w){\n    if(y<0 || x<0 || y>=h || x>=w){\n        return 0;\n    }else{\n        return 1;\n    }\n}\nconst vector<ll> dx{1,0,-1,0};\nconst vector<ll> dy{0,1,0,-1};\n\n\n\nint main() {\n\n    ll H,W,K;\n    cin >>H>>W>>K;\n    vector<string> S(H+1);\n    rep(i,H) cin >>S[i];\n    vector<vector<ll>> R(H+1,vector<ll>(W+1));\n    vector<vector<ll>> R2(H+1,vector<ll>(W+1));\n    rep(i,H) rep(j,W) R[i][j] = ctoi(S[i][j]);\n    R2 = R;\n    if(K<=1){\n        ll ans = 0;\n        ll min = INF;\n        rep(i,H){\n            rep(j,W){\n                chmin(min,R[i][j]);\n                ans+=R[i][j];\n            }\n        }\n        cout << ans-min<<endl;\n        return 0;\n    }\n\n\n    ll fans = 0;\n    rep(h,H) rep(w,H){\n    ll ans = 0;\n    R=R2;\n    //R[h][w] = -1;\n    ll flag = 0;\n    rep(m,H){\n        ll p2 =pow(2,m); \n        /*rep(j,W){\n            vector<ll> tmp;\n            rep(i,H){\n                if(R[H-1-i][j] != -1){\n                    tmp.pb(R[H-1-i][j]);\n                }\n            }\n            rep(i,H){\n                if(i<tmp.size()){\n                    R[H-1-i][j] = tmp[i];\n                }else{\n                    R[H-1-i][j] = -1;\n                }\n            }\n        }*/\n        /*rep(i,H){\n            ll cnt=0;\n            ll p=-1;\n            rep(j,W){\n                if(R[i][j] == p && R[i][j] != -1){\n                    cnt++;\n                    if(j==W-1){\n                        if(cnt>=K){\n                            flag = 1;\n                            //ans += R[i][j-1]*cnt*p2;\n                            rep(k,cnt){\n                               // R[i][j-k] = -1;\n                            }\n                        }\n                    }\n                }else{\n                    if(cnt>=K){\n                        flag = 1;\n                        //ans += R[i][j-1]*cnt*p2;\n                        rep(k,cnt){\n                            //R[i][j-k-1] = -1;\n                        }\n                    }\n                    cnt = 1;\n                }\n                \n\n                p = R[i][j];\n            }\n        \n        \n        }*/\n\n        if(flag ==0) break;\n    }\n\n\n        chmax(fans,ans);\n    }\n\n    cout << fans<<endl;\n    \n    return 0;\n    \n\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\n#define in std::cin\n#define out std::cout\n\nint32_t H, W,K;\nchar block[30][30];\nchar block_tmp[30][30];\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\n\tin >> H>>W>>K;\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tin >> block[i];\n\t}\n\n\tif (K > W) {\n\t\tout << 0 << endl; return 0;\n\t}\n\tif (K == 1) {\n\t\tint32_t res = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tres+= block[i][j]-'0';\n\t\t\t}\n\t\tout << res << endl; return 0;\n\t}\n\n\tint32_t result = 0;\n\tfor (int delete_pos_H = 0; delete_pos_H < H; delete_pos_H++)for (int delete_pos = 0; delete_pos < W; delete_pos++)\n\t{\n\t\tfor (int i = 0; i < H; i++)for (int j = 0; j < W; j++) {\n\t\t\tblock_tmp[i][j] = block[i][j];\n\t\t}\n\n\t\tbool updated = true;\n\t\tint32_t bottom = delete_pos_H;\n\t\tint32_t count = 0;\n\t\tint32_t result_tmp = 0;\n\t\tint32_t spos = delete_pos;\n\t\tfor (int i = bottom - 1; i >= 0; --i) {\n\t\t\tblock_tmp[i + 1][spos] = block_tmp[i][spos];\n\t\t}\n\t\tblock_tmp[0][spos] = 'd';\n\t\twhile(updated)\n\t\t{\n\t\t\tupdated = false;\n\t\t\tfor (int h = 0; h <= bottom; h++)\n\t\t\t{\n\t\t\t\tfor (int w = 0; w < W; w++)\n\t\t\t\t{\n\t\t\t\t\tif (block_tmp[h][w] == 'd') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint32_t www = 1;\n\t\t\t\t\tfor (int j = w + 1; j < W && block_tmp[h][j] == block_tmp[h][w]; j++) {\n\t\t\t\t\t\t++www;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = w - 1; j >= 0 && block_tmp[h][j] == block_tmp[h][w]; --j) {\n\t\t\t\t\t\t++www;\n\t\t\t\t\t}\n\t\t\t\t\tif (www >= K) {\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\tresult_tmp += (block_tmp[h][w]-'0')*www*(1 << count);\n\t\t\t\t\t\tfor (int j = w + 1; j < W && block_tmp[h][j] == block_tmp[h][w]; j++) {\n\t\t\t\t\t\t\tblock_tmp[h][j] = 'd';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int j = w - 1; j >= 0 && block_tmp[h][j] == block_tmp[h][w]; --j) {\n\t\t\t\t\t\t\tblock_tmp[h][j] = 'd';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tblock_tmp[h][w] = 'd';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (updated)\n\t\t\t{\n\t\t\t\tfor (int w = 0; w < W; w++)\n\t\t\t\tfor (int h = bottom; h >= 0; h--)\n\t\t\t\t{\n\t\t\t\t\tbool notd = true;\n\t\t\t\t\twhile (notd&&block_tmp[h][w] == 'd') {\n\t\t\t\t\t\tnotd = false;\n\t\t\t\t\t\tfor (int j = h-1; j >= 0; j--) {\n\t\t\t\t\t\t\tblock_tmp[j + 1][w] = block_tmp[j][w];\n\t\t\t\t\t\t\tif (block_tmp[j + 1][w]!='d') { notd = true; }\n\t\t\t\t\t\t}\n\t\t\t\t\t\tblock_tmp[0][w] = 'd';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t++count;\n\t\t}\n\t\tresult = std::max(result, result_tmp);\n\t}\n\tout << result << endl;\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint otosu(vector<deque<int>> &c,int h,int k) {\n\tif (c.size() == 0) {\n\t\treturn 0;\n\t}\n\tint point=0;\n\tfor (int i = 0; i < h; i++) {\n\t\tint j = 0;\n\t\twhile (j < c.size()-1) {\n\t\t\tint rensa = 1;\n\t\t\tif (c[j].at(i)!=0 && c[j].at(i) == c[j+1].at(i)) {\n\n\t\t\t\trensa = 2;\n\n\t\t\t\twhile (j + rensa < c.size()) {\n\t\t\t\t\tif (c[j + rensa].at(i) == c[j].at(i)) {\n\t\t\t\t\t\trensa++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (rensa >= k) {\n\t\t\t\t\tfor (int m = 0; m < rensa; m++) {\n\t\t\t\t\t\tpoint += c[j + m].at(i);\n\t\t\t\t\t\tc[j + m].at(i) = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tj=j+rensa;\n\t\t}\n\t\t\n\t}\n\n\tfor (int j = 0; j < c.size(); j++) {\n\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\tif (c[j].at(i) == -1) {\n\t\t\t\tc[j].erase(c[j].begin() + i);\n\t\t\t\tc[j].push_back(0);\n\t\t\t}\n\t\t}\n\t}\n\n\t//for (int j = c.size() - 1; j >= 0; j--) {\n\t//\tif (c[j].front() == 0) {\n\t//\t\tc.erase(c.begin() + j);\n\t//\t}\n\t//}\n\n\treturn point;\n}\n\nint main() {\n\n\tint h, w, k;\n\tcin >> h >> w >> k;\n\n\tvector<deque<int>> c(w, deque<int>());\n\tvector<deque<int>> corg(w, deque<int>());\n\n\tint summ=0;\n\tlong long in1;\n\tfor (int i =0; i <h; i++) {\n\t\tcin >> in1;\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tc[j].push_front(in1%10);\n\t\t\tin1 /= 10;\n\t\t\tsumm += c[j].front();\n\t\t}\n\t}\n\n\tif (k == 0 || k == 1) {\n\t\tcout << summ << endl;\n\t\treturn 0;\n\t}\n\n\tcorg = c;\n\tlong long score=0;\n\tfor (int j = 0; j < h; j++) {\n\t\tfor (int i = 0; i < w; i++) {\n\n\t\t\tc = corg;\n\n\t\t\tc[i].erase(c[i].begin() + j);\n\t\t\tc[i].push_back(0);\n\n\t\t\tlong long scoret = 0;\n\t\t\tint counter = 0;\n\t\t\tint point;\n\t\t\tdo {\n\t\t\t\tpoint = 0;\n\t\t\t\tpoint = otosu(c, h, k);\n\t\t\t\tscoret += point * (long long)pow(2, counter);\n\t\t\t\tcounter++;\n\t\t\t} while (point != 0);\n\t\t\tscore = max(score, scoret);\n\t\t}\n\t}\n\tcout << score << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair< ll, ll > Pi;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep2(i,n) for(int i=1;i<=(n);i++)\n#define rep3(i,i0,n) for(int i=i0;i<(n);i++)\n#define pb push_back\n#define mod 1000000007\nconst ll INF = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nll gcd(ll a, ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b) {return a/gcd(a,b)*b;}\n#define all(x) x.begin(), x.end()\n#define mp make_pair\nbool compare(Pi a, Pi b) {\n    if(a.first != b.first){\n        return a.first < b.first;\n        \n    }else{\n        return a.second < b.second;\n    }\n}\n\nint ctoi(char c) {\n\tif (c >= '0' && c <= '9') {\n\t\treturn c - '0';\n\t}\n\treturn 0;\n}\nbool In_map(ll y,ll x,ll h,ll w){\n    if(y<0 || x<0 || y>=h || x>=w){\n        return 0;\n    }else{\n        return 1;\n    }\n}\nconst vector<ll> dx{1,0,-1,0};\nconst vector<ll> dy{0,1,0,-1};\n\n\n\nint main() {\n\n    ll H,W,K;\n    cin >>H>>W>>K;\n    vector<string> S(H+1);\n    rep(i,H) cin >>S[i];\n    vector<vector<ll>> R(H+1,vector<ll>(W+1));\n    vector<vector<ll>> R2(H+1,vector<ll>(W+1));\n    //rep(i,H) rep(j,W) R[i][j] = ctoi(S[i][j]);\n    //R2 = R;\n    if(K<=1){\n        ll ans = 0;\n        ll min = INF;\n        rep(i,H){\n            rep(j,W){\n                chmin(min,R[i][j]);\n                ans+=R[i][j];\n            }\n        }\n        cout << ans-min<<endl;\n        return 0;\n    }\n\n\n    ll fans = 0;\n    rep(h,H) rep(w,H){\n    ll ans = 0;\n    R=R2;\n    //R[h][w] = -1;\n    ll flag = 0;\n    rep(m,H){\n        //ll p2 =pow(2,m); \n        /*rep(j,W){\n            vector<ll> tmp;\n            rep(i,H){\n                if(R[H-1-i][j] != -1){\n                    tmp.pb(R[H-1-i][j]);\n                }\n            }\n            rep(i,H){\n                if(i<tmp.size()){\n                    R[H-1-i][j] = tmp[i];\n                }else{\n                    R[H-1-i][j] = -1;\n                }\n            }\n        }*/\n        /*rep(i,H){\n            ll cnt=0;\n            ll p=-1;\n            rep(j,W){\n                if(R[i][j] == p && R[i][j] != -1){\n                    cnt++;\n                    if(j==W-1){\n                        if(cnt>=K){\n                            flag = 1;\n                            //ans += R[i][j-1]*cnt*p2;\n                            rep(k,cnt){\n                               // R[i][j-k] = -1;\n                            }\n                        }\n                    }\n                }else{\n                    if(cnt>=K){\n                        flag = 1;\n                        //ans += R[i][j-1]*cnt*p2;\n                        rep(k,cnt){\n                            //R[i][j-k-1] = -1;\n                        }\n                    }\n                    cnt = 1;\n                }\n                \n\n                p = R[i][j];\n            }\n        \n        \n        }*/\n\n        if(flag ==0) break;\n    }\n\n\n        chmax(fans,ans);\n    }\n\n    cout << fans<<endl;\n    \n    return 0;\n    \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <map>\n#include <queue> \n#include <stack>\n#include <set>\n#include <list>\n\nusing namespace std;\ntypedef long long ll;\n//#define rep(i, s, e) for (int(i) = (s); (i) < (e); ++(i))\n#define rep(i, e) for (int(i) = 0; (i) < (e); ++(i))\n#define rrep(i, s) for (int(i) = (s) - 1; (i) >= 0; --(i))\n#define all(x) x.begin(),x.end()\n#pragma endregion\n\nint main()\n{\n\tint h, w, k; cin >> h >> w >> k;\n\tvector<vector<int>> b(h, vector<int>(w)), c;\n\trep(i, h)\n\t{\n\t\tstring x; cin >> x;\n\t\trep(j, w)\n\t\t{\n\t\t\tint y = x[j] - '0';\n\t\t\tb[i][j] = y;\n\t\t}\n\t}\n\tint mx = 0;\n\trep(x, h)rep(y, w)\n\t{\n\t\tint res = 0;\n\t\tint cnt = 0;\n\t\tc = b;\n\t\tc[x][y] = 0;\n\t\tfor (int z = x; z > 0; --z)\n\t\t{\n\t\t\tc[z][y] = b[z - 1][y];\n\t\t}\n\t\twhile (true)\n\t\t{\n\t\t\tbool change = false;\n\t\t\tint tmp = 0;\n\t\t\trep(i, h)\n\t\t\t{\n\t\t\t\tint j = 0;\n\t\t\t\twhile (j <= w - k)\n\t\t\t\t{\n\t\t\t\t\tint l = j + 1;\n\t\t\t\t\tint now = c[i][j];\n\t\t\t\t\tif (now == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tj = l;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\twhile (l < w&&c[i][l] == now)++l;\n\t\t\t\t\tif (l - j >= k)\n\t\t\t\t\t{\n\t\t\t\t\t\tchange = true;\n\t\t\t\t\t\tfor (int m = j; m < l; ++m)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmp += now;\n\t\t\t\t\t\t\tc[i][m] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tj = l;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!change)break;\n\t\t\trep(j, w)rrep(i, h)\n\t\t\t{\n\t\t\t\tint l = i;\n\t\t\t\twhile (l >= 0 && c[l][j] == 0)--l;\n\t\t\t\tif (l < 0)c[i][j] = 0;\n\t\t\t\telse swap(c[i][j], c[l][j]);\n\t\t\t}\n\t\t\tres += powl(2, cnt)*tmp;\n\t\t\t++cnt;\n\t\t}\n\t\tmx = max(mx, res);\n\t}\n\tcout << mx << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst long long INF = 1001001001;\nconst long long MOD = 1000000007;\nconst double EPS = 1e-10;\n\nint grid[33][33]={};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int h,w,k;\n    cin>>h>>w>>k;\n    for(int i=0;i<h;i++){\n        string s;\n        cin>>s;\n        for(int j=0;j<w;j++)grid[i+1][j]=s[j]-'0';\n    }\n    int ans=0;\n    for(int i=1;i<=h;i++){\n        for(int j=0;j<w;j++){\n            int newGrid[33][33]={};\n            for(int l=1;l<=h;l++){\n                for(int m=0;m<w;m++){\n                    newGrid[l][m]=grid[l][m];\n                    if(l==i&&m==j)newGrid[l][m]=0;\n                }\n            }\n            int rmCnt=-1,res=0;\n            bool update=true;\n            while(update){\n                update=false;\n                rmCnt++;\n                for(int l=1;l<=h;l++){\n                    for(int m=0;m<w;m++){\n                        if(newGrid[l][m]==0){\n                            for(int r=l;r>=1;r--)newGrid[r][m]=newGrid[r-1][m];\n                        }\n                    }\n                }\n                for(int l=1;l<=h;l++){\n                    for(int m=0,prv=newGrid[l][0],len=0;m<=w;m++){\n                        if(prv==newGrid[l][m]){\n                            len++;\n                        }else{\n                            if(prv>0&&len>=k){\n                                for(int r=m-len;r<=m-1;r++)newGrid[l][r]=0;\n                                res+=len*prv*pow(2,rmCnt);\n                                update=true;\n                            }\n                            prv=newGrid[l][m],len=1;\n                        }\n                    }\n                }\n            }\n            ans=max(ans,res);\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include <prettyprint.hpp>\n#define debug(...)  cerr << \"[\" << #__VA_ARGS__ << \"]: \", d_err(__VA_ARGS__);\n#else\n#define debug(...) 83;\n#endif\n\nvoid d_err() {\n    cerr << endl;\n}\n\ntemplate <typename H, typename... T>\nvoid d_err(H h, T... t) {\n    cerr << h << \" \";\n    d_err(t...);\n}\n\ntemplate <typename T>\nvoid print(T x) {\n    cout << x << \"\\n\";\n}\n\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define REVFOR(i, m, n) for (int i = (n - 1); i >= (m); --i)\n#define REP(i, n) FOR(i, 0, n)\n#define REVREP(i, n) REVFOR(i, 0, n)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define bcnt __builtin_popcountll\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int,int> Pin;\n\nll INF = 1e16;\nint inf = 1e9;\n\nvoid chmax(ll& x, ll y) {\n    if (x < y) x = y;\n}\n\nstruct UnionFind {\n    vector<int> par;\n\n    UnionFind(int n): par(n, -1) {}\n    void init(int n) { par.assign(n, -1); }\n\n    int root(int x) {\n        if (par[x] < 0) return x;\n        return par[x] = root(par[x]);\n    }\n\n    int issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n\n        if (x == y) return false;\n\n        // merge by size\n        // force size of x to be bigger than that of y\n        if (par[x] > par[y]) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n\n        return true;\n    }\n\n    ll size(int x) {\n        return -par[root(x)];\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    int h, w, k; cin >> h >> w >> k;\n    vector<string> vs(h);\n    REP(i, h) cin >> vs[i];\n\n    vector<vi> v(h, vi(w));\n    REP(i, h) REP(j, w) v[i][j] = vs[i][j] - '0';\n\n    // calc score\n    auto get_score = [&](vector<vi>& v) -> ll {\n        ll score = 0;\n        int cnt_clear = 0;\n        while(1) {\n            ll cur = 0;\n            vector<vector<bool>> clear(h, vector<bool>(w, false));\n\n            REP(i, h) {\n                ll prev = -1;\n                ll cnt = 0;\n                REP(j, w) {\n                    if (v[i][j] == -1) {\n                        if (cnt >= k) {\n                            REP(l, cnt) {\n                                clear[i][j - l - 1] = true;\n                            }\n                            cur += cnt * prev;\n                        }\n\n                        cnt = 0;\n                        prev = -1;\n                        continue;\n                    }\n\n                    if (prev != v[i][j]) {\n                        if (cnt >= k) {\n                            REP(l, cnt) {\n                                clear[i][j - l - 1] = true;\n                            }\n                            cur += cnt * prev;\n                        }\n                        cnt = 0;\n                    }\n\n                    prev = v[i][j];\n                    cnt++;\n                }\n\n                if (cnt >= k) {\n                    REP(l, cnt) clear[i][w - l - 1] = true;\n                    cur += cnt * prev;\n                }\n            }\n\n            REP(j, w) {\n                REP(i, h) {\n                    if (clear[i][j]) {\n                        REVREP(l, i) {\n                            v[l + 1][j] = v[l][j];\n                        }\n                        v[0][j] = -1;\n                    }\n                }\n            }\n\n            if (cur == 0)  break;\n            score += cur * pow(2, cnt_clear);\n            cnt_clear++;\n        }\n\n        return score;\n    };\n\n    ll ans = 0;\n    REP(i, h) REP(j, w) {\n        // clear this\n        vector<vi> v_cur = v;\n\n        REVREP(l, i) v_cur[l + 1][j] = v_cur[l][j];\n        v_cur[0][j] = -1;\n\n        ans = max(ans, get_score(v_cur));\n    }\n\n    print(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair< ll, ll > Pi;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep2(i,n) for(int i=1;i<=(n);i++)\n#define rep3(i,i0,n) for(int i=i0;i<(n);i++)\n#define pb push_back\n#define mod 1000000007\nconst ll INF = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nll gcd(ll a, ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b) {return a/gcd(a,b)*b;}\n#define all(x) x.begin(), x.end()\n#define mp make_pair\nbool compare(Pi a, Pi b) {\n    if(a.first != b.first){\n        return a.first < b.first;\n        \n    }else{\n        return a.second < b.second;\n    }\n}\n\nint ctoi(char c) {\n\tif (c >= '0' && c <= '9') {\n\t\treturn c - '0';\n\t}\n\treturn 0;\n}\nbool In_map(ll y,ll x,ll h,ll w){\n    if(y<0 || x<0 || y>=h || x>=w){\n        return 0;\n    }else{\n        return 1;\n    }\n}\nconst vector<ll> dx{1,0,-1,0};\nconst vector<ll> dy{0,1,0,-1};\n\n\n\nint main() {\n\n    ll H,W,K;\n    cin >>H>>W>>K;\n    vector<string> S(H);\n    rep(i,H) cin >>S[i];\n    vector<vector<ll>> R(H,vector<ll>(W));\n    vector<vector<ll>> R2(H,vector<ll>(W));\n    rep(i,H) rep(j,W) R[i][j] = ctoi(S[i][j]);\n    R2 = R;\n    \n    ll fans = 0;\n    rep(h,H) rep(w,H){\n    ll ans = 0;\n    R=R2;\n    R[h][w] = -1;\n    ll flag = 0;\n    rep(m,H){\n        ll p2 =pow(2,m); \n        rep(j,W){\n            vector<ll> tmp;\n            rep(i,H){\n                if(R[H-1-i][j] != -1){\n                    tmp.pb(R[H-1-i][j]);\n                }\n            }\n            rep(i,H){\n                if(i<tmp.size()){\n                    R[H-1-i][j] = tmp[i];\n                }else{\n                    R[H-1-i][j] = -1;\n                }\n            }\n        }\n        rep(i,H){\n            ll cnt=0;\n            ll p=-1;\n            rep(j,W){\n                if(R[i][j] == p && R[i][j] != -1){\n                    cnt++;\n                    if(j==W-1){\n                        if(cnt>=K){\n                            flag = 1;\n                            ans += R[i][j-1]*cnt*p2;\n                            rep(k,cnt){\n                                R[i][j-k] = -1;\n                            }\n                        }\n                    }\n                }else{\n                    if(cnt>=K){\n                        flag = 1;\n                        ans += R[i][j-1]*cnt*p2;\n                        rep(k,cnt){\n                            R[i][j-k-1] = -1;\n                        }\n                    }\n                    cnt = 1;\n                }\n                \n\n                p = R[i][j];\n            }\n        \n        \n        }\n        /*rep(i,H){\n            rep(j,W){\n                cout << R[i][j]<<\" \";\n            }\n            cout <<endl;\n        }*/\n        if(flag ==0) break;\n    }\n\n\n        chmax(fans,ans);\n    }\n\n    cout << fans<<endl;\n    \n    return 0;\n    \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAX_N = 30;\n\nint H, W, K;\nint C[MAX_N][MAX_N]; \nint tempC[MAX_N][MAX_N]; \n\nint del(){\n    int ret = 0;\n\n    for(int i=0; i<H; i++){\n        vector<pair<int, int>> v;\n        int s = 0;\n        int cnt = 1;\n        for(int j=0; j<W-1; j++){\n            if(tempC[i][j] == tempC[i][j+1]){\n                cnt++;\n            }else{\n                v.push_back(make_pair(s, cnt));\n                s = j+1;\n                cnt = 1;\n            }\n        }\n        v.push_back(make_pair(s, cnt));\n\n        for(int j=0; j<v.size(); j++){\n            s = v[j].first;\n            int l = v[j].second;\n            if(tempC[i][s] == -1) continue;\n            if(l < K) continue;\n            for(int k=0; k<l; k++){\n                ret += tempC[i][s+k];\n                tempC[i][s+k] = -1;\n            }\n        }\n    }\n\n    return ret;\n\n}\n\nbool move(){\n    bool fl = false;\n    for(int i=H-2; i>=0; i--){\n        for(int j=0; j<W; j++){\n            if(tempC[i][j] == -1) continue;\n            if(tempC[i+1][j] == -1){\n                tempC[i+1][j] = tempC[i][j];\n                tempC[i][j] = -1;\n                fl = true;\n            }\n        }\n    }\n    return fl;\n}\n\n\nint main(){\n    cin >> H >> W >> K;\n\n    string S[H];\n    \n    for(int i=0; i<H; i++){\n        cin >> S[i];\n    }\n    for(int i=0; i<H; i++){\n        for(int j=0; j<W; j++){\n            C[i][j] = S[i][j] - '0';\n        }\n    }\n    \n    int ans = 0;\n    for(int i=0; i<H; i++){\n        for(int j=0; j<W; j++){\n            for(int k=0; k<H; k++){\n                for(int l=0; l<W; l++){\n                    tempC[k][l] = C[k][l];\n                }\n            }\n            tempC[i][j] = -1;\n\n            int ta = 0;\n            int cnt = 0;\n            while(true){\n                while(move());\n                int add = del();\n                if(add == 0) break;\n                add *= pow(2, cnt);\n                ta += add;\n                cnt++;\n            }\n            ans = max(ta, ans);\n        }\n    }\n\n    cout << ans << endl;\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//眠い\n#include <iostream>\n#include <algorithm>\n#define rep(i, n) for (i = 0; i < n; i++)\nusing namespace std;\n\nint h, w, K;\nchar s[30][31];\n\n//シミュレーション用\nchar tmp[30][30];\nint height[30];\nbool mark[30][30];\n\nint erase() {\n\tint r, c;\n\tchar nTmp[30][30];\n\tint nHeight[30] = {0};\n\t\n\trep(r, h) rep(c, w) nTmp[r][c] = '@';\n\t\n\tint score = 0;\n\tfor (c = 0; c < w; c++) {\n\t\tfor (r = 0; r < height[c]; r++) {\n\t\t\tif (mark[r][c]) { score += (int)(tmp[r][c] - '0'); continue; }\n\t\t\tnTmp[nHeight[c]][c] = tmp[r][c];\n\t\t\tnHeight[c]++;\n\t\t}\n\t}\n\t\n\tfor (c = 0; c < w; c++) { height[c] = nHeight[c]; }\n\trep (r, h) rep(c, w) tmp[r][c] = nTmp[r][c];\n\treturn score;\n}\n\nint drop(int r, int c) {\n\t\n\tint i, j, k;\n\tint score = 0;\n\t\n\trep(i, h) rep(j, w) tmp[i][j] = s[i][j];\n\trep(j, w) height[j] = h;\n\trep(i, h) rep(j, w) mark[i][j] = false;\n\t\n\tmark[r][c] = true; erase(); mark[r][c] = false;\n\t\n\tfor (i = 0; ; i++) {\n\t\tbool flag = false;\n\t\t\n\t\t//マーク\n\t\trep(j, h) rep(k, w) mark[j][k] = false;\n\t\tfor (j = 0; j < h; j++) {\n\t\t\tint pos = 0;\n\t\t\tint cnt = 0;\n\t\t\tfor (k = 0; k < w; k++) {\n\t\t\t\tif (height[k] <= j || tmp[j][pos] != tmp[j][k]) {\n\t\t\t\t\tpos = k;\n\t\t\t\t\tcnt = 0;\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\t\n\t\t\t\tif (cnt >= K) {\n\t\t\t\t\tfor (int l = pos; l <= k; l++) {\n\t\t\t\t\t\tmark[j][l] = true;\n\t\t\t\t\t}\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//消す\n\t\tif (!flag) return score;\n\t\tscore += (1 << i) * erase();\n\t}\n\treturn score;\n}\n\nvoid input() {\n\tcin >> h >> w >> K;\n\tint i; for (i = h - 1; i >= 0; i--) cin >> s[i];\t//s[0]の方が下にある\n}\n\nint main() {\n\tinput();\n\t\n\tint ans = 0;\n\tint i, j;\n\t\n\trep(i, h) rep(j, w) ans = max(ans, drop(i, j));\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst long long LINF=8931145141919364364,LMOD=998244353;\ninline long long mod(long long n,long long m){return(n%m+m)%m;}\n// const int dx[]={1,0,-1,0,1,1,-1,-1},dy[]={0,-1,0,1,1,-1,-1,1};\n\nint h,w,k;\nvector<int> board[35];\nvoid check(){\n    rep(i,h){\n        rep(j,w) cout<<board[j][i];\n        cout<<endl;\n    }\n}\nint search(){\n    int ret=0;\n    rep(i,h){\n        int pre=-1,cnt=0;\n        rep(j,w){\n            if(board[j][i]!=pre){\n                if(pre!=-1&&cnt>=k){\n                    ret+=pre*cnt;\n                    rep(d,cnt){\n                        board[j-1-d][i]=0;\n                    }\n                }\n                cnt=1,pre=board[j][i];\n            }else{\n                cnt++;\n            }\n        }\n        if(pre!=-1&&cnt>=k){\n            ret+=pre*cnt;\n            rep(d,cnt){\n                board[w-1-d][i]=0;\n            }\n        }\n    }\n    return ret;\n}\nvoid del(){\n    for(int i=h-1;i>=0;i--)rep(j,w){\n        if(board[j][i]==0){\n            board[j].erase(board[j].begin()+i);\n            board[j].push_back(-1);\n        }\n    }\n}\nint main(){\n    cin>>h>>w>>k;\n    rep(i,h)rep(j,w){\n        char c; cin>>c;\n        board[j].push_back(c-'0');\n    }\n    rep(i,w) reverse(all(board[i]));\n    // check();\n    long long ans=0;\n    rep(i,h)rep(j,w){\n        vector<int> save[35]=board;\n        board[j].erase(board[j].begin()+i);\n        board[j].push_back(-1);\n        // if(i==0&&j==2)check();\n        long long cnt=0,tmp=0;\n        while(1){\n            int x=search();\n            del();\n            if(x>0){\n                tmp+=pow(2,cnt)*x;\n                cnt++;\n            }\n            else break;\n        }\n        // cout<<tmp<<endl;\n        ans=max(ans,tmp);\n        // check(); cout<<endl;\n        rep(i,h)rep(j,w) board[j][i]=save[j][i];\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint n, m, k;\n\nbool ok(const vector<vector<char> >& a, int i, int j)\n{\n    if (k == 2) {\n        if (j + 1 < m && a[i][j + 1] == a[i][j]) {\n            return true;\n        }\n        if (j - 1 >= 0 && a[i][j - 1] == a[i][j]) {\n            return true;\n        }\n        return false;\n    }\n    for (int y = j - 2; y <= j; ++y) {\n        if (y >= 0 && y + 2 < m && a[i][y] == a[i][y + 1] && a[i][y] == a[i][y + 2]) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint solve(vector<vector<char> >& a, int step)\n{\n    for (int i = n - 1; i >= 0; --i) {\n        for (int j = 0; j < m; ++j) {\n            if (a[i][j] != '0') {\n                int curr = i;\n                char d = a[i][j];\n                a[i][j] = '0';\n                while (curr + 1 < n && a[curr + 1][j] == '0') {\n                    ++curr;\n                }\n                a[curr][j] = d;\n            }\n        }\n    }\n    int sum = 0;\n    vector<pii> p;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (a[i][j] != '0' && ok(a, i, j)) {\n                sum += (a[i][j] - '0');\n                p.pb({i, j});\n            }\n        }\n    }\n    for (int i = 0; i < sz(p); ++i) {\n        a[p[i].first][p[i].second] = '0';\n    }\n    if (sum == 0) {\n        return sum;\n    } else {\n        return sum * (1 << step) + solve(a, step + 1);\n    }\n}\n\nint main()\n{\n\n    //freopen(\"input.txt\", \"r\", stdin);\n\n    //ios_base::sync_with_stdio(false);\n    //cin.tie(0);\n\n    cin >> n >> m >> k;\n\n    vector<vector<char> > c(n, vector<char>(m));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            cin >> c[i][j];\n        }\n    }\n\n    int ans = 0;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            vector<vector<char> > a = c;\n            a[i][j] = '0';\n            ans = max(ans, solve(a, 0));\n        }\n    }\n\n    cout << ans << \"\\n\";\n\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . ___\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n              find_str Bao You\n*/\n#include <iostream>\n#include <queue>\n#include <assert.h>   \n#include <vector>\n#include <algorithm>\n#include <time.h>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <unordered_set>\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <numeric>\n#include <deque>\n#include <iomanip>\n#include <cstdlib>\n#include <climits>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define ll long long\n#define ld long double \n#define pi pair<int, int> \n#define pl pair<ll,ll>  \n#define pd pair<ld,ld> \n#define str string  \n#define mp make_pair\n#define vi vector<int> \n#define vl vector<ll> \n#define vd vector<ld> \n#define vs vector<str> \n#define vpi vector<pi> \n#define vpl vector<pl> \n#define vpd vector<pd> \n#define si set<int> \n#define FF(i,j,n) for(signed i=j;i<=n;i++)  \n#define DD(i,j,n) for(signed i=j;i>=n;i--) \n#define F(i,j,n) for(signed i=j;i<n;i++)   \n#define D(i,j,n) for(signed i=j;i>n;i--) \n#define mem(a,b) memset(a,b,sizeof(a))\n#define ndl cout << endl\n#define ull unsigned long long \n\nconst int inf = 0x3f3f3f3f;\nconst ll INF = 0x3f3f3f3f3f3f3f3fLL;\n\n\n#define sz(x) (signed)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back() \n#define fi first\n#define se second\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n#define IOS ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n\n//math\nconst int mod = 1e9 + 7;\n\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\nint pct(int x) { return __builtin_popcount(x); } \nint bit(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nint cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \n\n\n//DEBUG, compile with -DLOCAL\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n  cerr << to_string(h); if (sizeof...(t)) cerr << \", \";\n  DBG(t...); }\n#ifdef LOCAL \n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#define HERE cout << \"===GOTHERE===\" << endl\n#else\n#define dbg(...) 42\n#define HERE 42\n#endif\n\n//#define double long double\n#define int long long\n//#define int unsigned long long\n\nconst int maxn = 1e5*2+20;\n\nint n,_,q,k;\nint h,w;\n\nstr raw[40];\n\nint l,r;\n\nint org[35][35];\nint a[35][35];\nint ptr[35];\n\nvoid prep(){\n  FF(i,0,h)FF(j,0,w) a[i][j] = org[i][j];\n  FF(i,1,w) ptr[i] = h;\n}\n\nint check(){\n  FF(i,1,w){\n    int j = i;\n    while(a[ptr[i]][i] == a[ptr[j]][j]){\n      \n      //dbg(a[ptr[j]][j],i,j);\n      j++;\n    }\n    int tt = (j-i) * a[ptr[i]][i];\n    if(tt > 0 && j - i >= k){\n      l = i; r = j;\n      return tt;\n    }\n    i = j - 1;\n  }\n  return -1;\n}\n\nbool notFinished(){\n  int yes = false;\n  FF(i,1,w){\n    if(ptr[i] > 0) yes = true;\n  }\n  return yes;\n}\n\nvoid renew(){\n  FF(i,1,w) ptr[i] = h;\n  FF(i,1,w){\n    while(ptr[i] != 0 && a[ptr[i]][i] < 0) ptr[i]--;\n  }\n}\n\nvoid updateptr(){\n  FF(i,1,w){\n    if(ptr[i] > 0) ptr[i] --;\n  }\n  FF(i,1,w){\n    while(ptr[i] != 0 && a[ptr[i]][i] < 0) ptr[i]--;\n  }\n}\n\nvoid update(){\n    FF(i,1,w){\n    while(ptr[i] != 0 && a[ptr[i]][i] < 0) ptr[i]--;\n  }\n}\n\nvoid solve(){\n  FF(i,0,h)FF(j,0,w){\n    org[i][j] = -1;\n  }\n  FF(i,1,h){\n    cin >> raw[i];\n  }\n\n\n\n  FF(i,1,h)FF(j,1,w){\n    org[i][j] = raw[i][j-1] - '0';\n  }\n\n  int ans = 0;\n\n  FF(q,1,w){\n    FF(p,1,h){\n    prep();\n    int pw = 0;\n    int anst = 0;\n    a[p][q] = -1;\n\n    bool deleted = true;\n    //cout << \"triail\" << endl;\n    while(deleted){\n      deleted = false;\n      renew();\n      //cout << \"renewed\" << endl;\n      while(notFinished()){\n        // FF(i,1,w){\n        //   dbg(ptr[i]);\n        // }\n\n        int score = check();\n        //dbg(score);\n        if(score == -1){\n          updateptr();\n        }else{\n          deleted = true;\n          anst += (powl(2,pw)*score);\n          F(i,l,r){\n            a[ptr[i]][i] = -1;\n          }\n          updateptr();\n        }\n      }\n      pw++;\n    }\n    ans = max(ans, anst);\n    }\n  }\n  cout << ans << endl;\n\n}\n\nsigned main(){\n  //clock_t t1 = clock();  \n\tIOS\n  cin >> h >> w >> k;\n\tsolve();\n  \n  //cout << \"THE ALGORITHM TOOK: \" << (clock() - t1) * 1.0 / CLOCKS_PER_SEC * 1000 << \"ms\"<< endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000\nusing namespace std;\n\nint H, W, K;\nint check_point(vector<vector<int>> board, pair<int, int> hw)\n{\n  int ans = 0;\n  // board.at(hw.second - 1).erase(board.at(hw.second - 1).begin() + H - hw.first);\n  // int loop_cnt = -1;\n  // while (true)\n  // {\n  //   loop_cnt += 1;\n  //   bool didnt_change = true;\n  //   int cnt;\n  //   for (int i = H - 1; i >= 0; --i)\n  //   {\n  //     cnt = 0;\n  //     int before = -1;\n  //     for (int j = 0; j < W; ++j)\n  //     {\n  //       if (board.at(j).at(i) == -1)\n  //       {\n  //\n  //         if (cnt >= K)\n  //         {\n  //           didnt_change = false;\n  //           ans += pow(2, loop_cnt) * cnt * board.at(j - 1).at(i);\n  //           for (int k = 0; k < cnt; ++k)\n  //           {\n  //             board.at(j - 1 - k).erase(board.at(j - 1 - k).begin() + i);\n  //           }\n  //         }\n  //         before = -1;\n  //         cnt = 0;\n  //       }\n  //       else if (board.at(j).at(i) == before)\n  //       {\n  //         cnt += 1;\n  //       }\n  //       else\n  //       {\n  //         before = board.at(j).at(i);\n  //         if (cnt >= K)\n  //         {\n  //           didnt_change = false;\n  //           ans += pow(2, loop_cnt) * cnt * board.at(j - 1).at(i);\n  //           for (int k = 0; k < cnt; ++k)\n  //           {\n  //             board.at(j - 1 - k).erase(board.at(j - 1 - k).begin() + i);\n  //           }\n  //         }\n  //         cnt = 1;\n  //       }\n  //     }\n  //     if (cnt >= K)\n  //     {\n  //       didnt_change = false;\n  //       ans += pow(2, loop_cnt) * cnt * board.at(W - 1).at(i);\n  //       for (int k = 0; k < cnt; ++k)\n  //       {\n  //         board.at(W - 1 - k).erase(board.at(W - 1 - k).begin() + i);\n  //       }\n  //     }\n  //   }\n  //   if (didnt_change)\n  //   {\n  //     break;\n  //   }\n  // }\n  return ans;\n}\n\nint main()\n{\n  cin >> H >> W >> K;\n  vector<vector<int>> board(W, vector<int>(2 * H, - 1));\n\n  for (int i = 0; i < H; ++i)\n  {\n    string row;\n    cin >> row;\n    for (int j = 0; j < W; ++j)\n    {\n      board.at(j).at(H - 1 - i) = (int)(row.at(j)) - 48;\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i < W; ++i)\n  {\n    for (int j = 0; j < H; ++j)\n    {\n      ans = max(ans, check_point(board, {i + 1, j + 1}));\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nconst int nax=37;\n\nint n, m, k;\n\nchar wcz[nax];\n\nstruct plan\n{\n\tvector <int> wek[nax];\n\tint kogo[nax][nax];\n\tplan()\n\t{\n\t\tczys();\n\t}\n\tvoid czys()\n\t{\n\t\tfor (int i=0; i<nax; i++)\n\t\t\tfor (int j=0; j<nax; j++)\n\t\t\t\tkogo[i][j]=0;\n\t}\n\tll oznacz()\n\t{\n\t\tll ret=0;\n\t\tfor (int i=0; i<nax; i++)\n\t\t{\n\t\t\tint ost=-1;\n\t\t\tint ile=0;\n\t\t\tfor (int j=0; j<nax; j++)\n\t\t\t{\n\t\t\t\tint x=-1;\n\t\t\t\tif ((int)wek[j].size()>i)\n\t\t\t\t\tx=wek[j][i];\n\t\t\t\tif (x==-1)\n\t\t\t\t{\n\t\t\t\t\tost=-1;\n\t\t\t\t\tile=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (x!=ost)\n\t\t\t\t\t{\n\t\t\t\t\t\tile=1;\n\t\t\t\t\t\tost=x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tile++;\n\t\t\t\t\t\tif (ile>=k)\n\t\t\t\t\t\t\tkogo[j][i]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tost=-1;\n\t\t\tile=0;\n\t\t\tfor (int j=nax-1; j>=0; j--)\n\t\t\t{\n\t\t\t\tint x=-1;\n\t\t\t\tif ((int)wek[j].size()>i)\n\t\t\t\t\tx=wek[j][i];\n\t\t\t\tif (x==-1)\n\t\t\t\t{\n\t\t\t\t\tost=-1;\n\t\t\t\t\tile=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (x!=ost)\n\t\t\t\t\t{\n\t\t\t\t\t\tile=1;\n\t\t\t\t\t\tost=x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tile++;\n\t\t\t\t\t\tif (ile>=k)\n\t\t\t\t\t\t\tkogo[j][i]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i=0; i<nax; i++)\n\t\t\tfor (int j=0; j<(int)wek[i].size(); j++)\n\t\t\t\tret+=kogo[i][j]*wek[i][j];\n\t\treturn ret;\n\t}\n\tvoid puszuj()\n\t{\n\t\tfor (int i=0; i<nax; i++)\n\t\t{\n\t\t\tvector <int> wez;\n\t\t\tfor (int j=0; j<(int)wek[i].size(); j++)\n\t\t\t\tif (!kogo[i][j])\n\t\t\t\t\twez.push_back(wek[i][j]);\n\t\t\twek[i]=wez;\n\t\t}\n\t\t//~ int g=0;\n\t\t//~ for (int i=0; i<nax; i++)\n\t\t//~ {\n\t\t\t//~ if (!wek[i].empty())\n\t\t\t//~ {\n\t\t\t\t//~ wek[g]=wek[i];\n\t\t\t\t//~ if (i!=g)\n\t\t\t\t\t//~ wek[i].clear();\n\t\t\t\t//~ g++;\n\t\t\t//~ }\n\t\t//~ }\n\t\tczys();\n\t}\n};\n\nll wyn;\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tassert(k==m);\n\tplan start;\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tscanf(\"%s\", wcz);\n\t\tfor (int j=0; j<m; j++)\n\t\t\tstart.wek[j].push_back(wcz[j]-'0');\n\t}\n\tfor (int i=0; i<m; i++)\n\t\treverse(start.wek[i].begin(), start.wek[i].end());\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tfor (int j=0; j<m; j++)\n\t\t{\n\t\t\tplan wez=start;\n\t\t\twez.kogo[j][i]=1;\n\t\t\twez.puszuj();\n\t\t\tll ter=0;\n\t\t\tfor (int h=0; 1; h++)\n\t\t\t{\n\t\t\t\tll x=wez.oznacz();\n\t\t\t\tif (!x)\n\t\t\t\t\tbreak;\n\t\t\t\tter+=(x<<h);\n\t\t\t\twez.puszuj();\n\t\t\t}\n\t\t\twyn=max(wyn, ter);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nvoid disp_stone(vector<vector<char> > s, int H, int W){\n\tcerr << endl;\n\trep (i, H){\n\t\trep (j, W){\n\t\t\tcerr << s[i][j];\n\t\t} // end rep\n\t\tcerr << endl;\n\t} // end rep\n}\n\n// 落ちきった状態を作り出す\nvector<vector<char> > all_fall(vector<vector<char> > s, int H, int W){\n\tvector<vector<char> > t = s;\n//\tdisp_stone(t, H, W);\n\twhile(true){\n\t\tbool update = false;\n\t\tfor (int i = 0; i < H-1; ++i){\n\t\t\tfor (int j = 0; j < W; ++j){\n\t\t\t\tif (t[i][j] != '0' && t[i+1][j] == '0'){\n\t\t\t\t\tswap(t[i][j], t[i+1][j]);\n\t\t\t\t\tupdate |= true;\n\t\t\t\t\tbreak;\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t\tif (update) break;\n\t\t} // end for\n\t\tif (!update) break;\n\t} // end while\n//\tdisp_stone(t, H, W);\n\t\n\treturn t;\n}\n\n// 消滅する状態を作り出す\nint disappearing(vector<vector<char> > &s, int H, int W, int K){\n\tint score = 0;\n\tfor (int i = 0; i < H; ++i){\n\t\tint left = 0, right = 0;\n\t\twhile(right < W){\n\t\t\twhile (s[i][left] == s[i][right]){\n\t\t\t\t++right;\n\t\t\t} // end while\n\t\t\tif (right - 1 - left + 1 >= K){\n\t\t\t\tscore += (right - 1 - left + 1)*(int)(s[i][left] - '0');\n\t\t\t\tfor (int j = left; j < right; ++j){\n\t\t\t\t\ts[i][j] = '0';\n\t\t\t\t} // end for\n\t\t\t} // end if\n\t\t\tleft = right;\n\t\t} // end while\n\t} // end for\n\t\n\treturn score;\n}\n\nint smulate(vector<vector<char> > s, int H, int W, int K){\n\n\tvector<vector<char> > t;\n\tint score = 0;\n\tfor(int i = 0;; ++i){\n\t\tbool update = false;\n\t\tt = all_fall(s, H, W);\n\t\tif (t == s) break;\n\t\tscore += (1<<i) * disappearing(t, H, W, K);\n\t\ts = t;\t\t\n\t} // end for\n\t\n\treturn score;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint H, W, K; cin >> H >> W >> K;\n\tvector<vector<char> > stones(H, vector<char>(W, 0));\n\trep (i, H){\n\t\trep (j, W){\n\t\t\tcin >> stones[i][j];\n\t\t} // end rep\n\t} // end rep\n\n\tint res = 0;\n\trep (i, H){\n\t\trep (j, W){\n\t\t\tvector<vector<char> > s = stones;\n\t\t\ts[i][j] = '0';\n\t\t\tint curr = smulate(s, H, W, K);\n\t\t\tres = max(res, curr);\n\t\t} // end rep\n\t} // end rep\n\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define reps(i, n) for (int i = 1, i##_len = (n); i <= i##_len; ++i)\n#define rrep(i, n) for (int i = ((int)(n)-1); i >= 0; --i)\n#define rreps(i, n) for (int i = ((int)(n)); i > 0; --i)\n#define rep2(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define repc2(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define inf 2e9\n#define linf 9000000000000000000ll\n#define all(v) v.begin(), v.end()\nusing namespace std;\ntypedef long long ll;\n\nint h, w, k;\nint M[30][30];\n\nint CM[30][30];\nint cnt[30][30];\n\nint score(int y, int x) {\n    rep(cy, h) rep(cx, w) { CM[cy][cx] = M[cy][cx]; }\n    CM[y][x] = -1;\n    int disappear = 0;\n    int phase = 0;\n    int c = -1;\n    int ans = 0;\n    while (disappear > 0 || phase <= 1) {\n        phase++;\n        disappear = 0;\n        rep(cy, h) rep(cx, w) {\n            if (cx == 0)\n                cnt[cy][cx] = 1;\n            else\n                cnt[cy][cx] = (CM[cy][cx] != -1 && (CM[cy][cx] == CM[cy][cx - 1])) ? (cnt[cy][cx - 1] + 1) : 1;\n        }\n        rep(cy, h) {\n            int r = 0;\n            rrep(cx, w) {\n                if (CM[cy][cx] != -1) {\n                    if (r > 0) {\n                        disappear += CM[cy][cx];\n                        CM[cy][cx] = -1;\n                        r--;\n                    } else if (cnt[cy][cx] >= k) {\n                        r = cnt[cy][cx] - 1;\n                        disappear += CM[cy][cx];\n                        CM[cy][cx] = -1;\n                    }\n                }\n            }\n        }\n        rep(cx, w) {\n            int pos = h - 1;\n            rrep(cy, h) {\n                if (CM[cy][cx] != -1) {\n                    CM[pos--][cx] = CM[cy][cx];\n                    if (pos + 1 != cy) {\n                        CM[cy][cx] = -1;\n                    }\n                }\n                if (pos < 0) break;\n            }\n        }\n        ans += pow(2, c++) * disappear;\n    }\n    return ans;\n}\n\nint main() {\n    cin >> h >> w >> k;\n    char c;\n    rep(y, h) rep(x, w) cin >> c, M[y][x] = c - '0';\n    int ans = 0;\n    rep(y, h) rep(x, w) ans = max(ans, score(y, x));\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1000000000\n#define INF 100000000000000\n#define ll long long\n#define ull unsigned long long\n#define M (int)(1e9+7)\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\n#define IN(a,n) rep(i,n){ cin>>a[i]; }\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n#define F first\n#define S second\n#define PB push_back\n#define EB emplace_back\n\nint h,w,k;\nint a[100][100];\nint ans=0;\n\nbool g(int b[100][100]){\n  bool flag = false;\n\n  rep(j,w){\n    int i=h-1;\n    while(i>0){\n      int l=i;\n      while(l>=0&&b[l][j]<0){\n        flag=true;\n        l--;\n      }\n     if(i!=l&&l>=0){\n      b[i][j]=b[l][j];\n      b[l][j]=-1;\n     }\n     else if(i!=l){\n       b[i][j]=0;\n     }\n     if(i==l) i--;\n     else i=l;\n    }\n  }\n  return flag;\n\n  \n}\n\nint s(int b[100][100],int m){\n  int res=0;\n  rep(i,h){\n    int j=0;\n    while(j<w){\n      int l=j; \n      while(b[i][j]==b[i][l]&&l<w)\n        l++;\n      if(b[i][j]>0&&l-j>=k){\n        res+=b[i][j]*(l-j);\n        FOR(c,j,l){\n          b[i][c]=-1;\n        }\n      }  \n      j=l;\n    }\n  }\n\n  int ret=1;\n  while(m--){\n    ret*=2;\n  }\n  return ret*res;\n}\n\n\nvoid f(int y,int x){\n  int b[100][100];\n  rep(i,h){\n    rep(j,w){\n      b[i][j]=a[i][j];\n    }\n  }\n  int res=0;\n  b[y][x]=-1;\n\n \n  int m=0;\n  while(g(b)){\n    res+=s(b,m);\n    m++;\n  }\n\n\n  ans=max(ans,res);\n}\n\n\nchar c[100][100];\n\nint main(){\n  cin>>h>>w>>k;\n  rep(i,h){\n    cin>>c[i];\n    rep(j,w){\n      a[i][j]=c[i][j]-'0';\n    }\n  }\n\n  rep(i,h){\n    rep(j,w){\n      f(i,j);\n    }\n  }\n\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n#define REP(i,n) for(int i=0; i < (n); ++i)\n#define REPR(i,n) for(int i=(n); i >= 0; --i)\n#define FOR(i, m, n) for(int i = (m); i < (n); ++i)\n#define INF 1e9\n// constexpr ll INF = 1LL << 60;\n\nint main(){\n  int H, W, K;\n  cin >> H >> W >> K;\n  vector<string> S(H);\n  REP(i, H){\n    cin >> S[i];\n  }   \n  vector<vector<int>> c(H, vector<int>(W));\n  int mans = 0;\n  REP(y, H){\n    REP(x, W){\n      REP(i, H){\n        REP(j, W){\n          c[i][j] = S[i][j]-'0';\n        }\n      }\n      c[y][x] = -1;\n      REP(j, W){\n        REPR(i, H-2){\n          int h = i;\n          if(c[i][j] == -1) continue;\n          while(h+1 < H && c[h+1][j] ==-1){\n            c[h+1][j] = c[h][j];\n            c[h][j] = -1;\n            h++;\n          }\n        }\n      }\n      int beki = 1;\n      bool deleted = true;\n      int ans = 0;\n      while(deleted){\n        deleted = false;\n        int value = 0;\n        REP(i, H){\n          REP(j, W){\n            if(c[i][j]==-1) continue;\n            int left = j+1;\n            while(left < W && c[i][j] == c[i][left]){\n              left++;\n            }\n            if(left-j >= K){\n              deleted = true;\n              value += c[i][j]*(left-j);\n              FOR(k, j, left){\n                c[i][k] = -1;\n              }\n            }\n          }\n        }\n        if(deleted){\n          ans += value * beki;\n          REP(j, W){\n            REPR(i, H-2){\n              int h = i;\n              if(c[i][j] == -1) continue;\n              while(h+1 < H && c[h+1][j] ==-1){\n                c[h+1][j] = c[h][j];\n                c[h][j] = -1;\n                h++;\n              }\n            }\n          }\n        }\n        beki *= 2;\n      }\n      mans = max(ans, mans);\n    }\n  }\n  cout << mans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma region\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stack>\n#include <set>\n#include <list>\n#include <iomanip>\n#include <cstdint>\n#include <cstdlib>\n\nusing namespace std;\ntypedef long long ll;\n//#define rep(i, s, e) for (int(i) = (s); (i) < (e); ++(i))\n#define rep(i, e) for (int(i) = 0; (i) < (e); ++(i))\n#define rrep(i, s) for (int(i) = (s) - 1; (i) >= 0; --(i))\n#define all(x) x.begin(),x.end()\n#pragma endregion\n\n\nint main()\n{\n\tint h, w, k; cin >> h >> w >> k;\n\tvector<vector<int>> b(h, vector<int>(w)), c;\n\trep(i, h)\n\t{\n\t\tstring x; cin >> x;\n\t\trep(j, w)\n\t\t{\n\t\t\tint y = x[j] - '0';\n\t\t\tb[i][j] = y;\n\t\t}\n\t}\n\tll mx = 0;\n\trep(x, h)rep(y, w)\n\t{\n\t\tll res = 0;\n\t\tint cnt = 0;\n\t\tc = b;\n\t\tc[x][y] = 0;\n\t\tfor (int z = x; z > 0; --z)\n\t\t{\n\t\t\tc[z][y] = b[z - 1][y];\n\t\t}\n\t\tc[0][y] = 0;\n\t\twhile (true)\n\t\t{\n\t\t\tbool change = false;\n\t\t\tint tmp = 0;\n\t\t\trep(i, h)\n\t\t\t{\n\t\t\t\tint j = 0;\n\t\t\t\twhile (j <= w - k)\n\t\t\t\t{\n\t\t\t\t\tint l = j + 1;\n\t\t\t\t\tint now = c[i][j];\n\t\t\t\t\tif (now == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tj = l;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\twhile (l < w&&c[i][l] == now)++l;\n\t\t\t\t\tif (l - j >= k)\n\t\t\t\t\t{\n\t\t\t\t\t\tchange = true;\n\t\t\t\t\t\tfor (int m = j; m < l; ++m)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmp += now;\n\t\t\t\t\t\t\tc[i][m] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tj = l;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!change)break;\n\t\t\trep(j, w)rrep(i, h)\n\t\t\t{\n\t\t\t\tint l = i;\n\t\t\t\twhile (l >= 0 && c[l][j] == 0)--l;\n\t\t\t\tif (l < 0)c[i][j] = 0;\n\t\t\t\telse swap(c[i][j], c[l][j]);\n\t\t\t}\n\t\t\tres += powl(2, cnt)*tmp;\n\t\t\t++cnt;\n\t\t}\n\t\tmx = max(mx, res);\n\t}\n\tcout << mx << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stdio.h>\n#include<cstring>\n#include<math.h>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<queue>\nusing namespace std;\n\n#define rep(i, n) for (long long i = 0; i < (long long)(n); ++i)\nusing P = pair<long long, long long>;\n\nlong long H, W, K;\nlong long cc[30][30];\nlong long c[30][30];\nlong long ans = 0;\n\nint main() {\n  cin >> H >> W >> K;\n  rep(i, H) {\n    string s;\n    cin >> s;\n    rep(j, W) {\n      cc[i][j] = s[j] - '0';\n    }\n  }\n\n  long long temp = 0;\n\n  rep(iii, H) {\n    rep(jjj, W) {\n      // if(iii != 3 || jjj != 0) continue;\n      long long count = 1;\n      temp = 0;\n      rep(ii, H) {\n        rep(jj, W) {\n          c[ii][jj] = cc[ii][jj];\n        }\n      }\n      if(iii == 0) {\n        c[iii][jjj] = 0;\n      } else {\n        for(long long k = 1; k <= iii; k++) {\n          swap(c[0][jjj], c[k][jjj]);\n        }\n        c[0][jjj] = 0;\n      }\n\n      while(true) {\n        vector<pair<pair<long long, long long>, long long>> mem;\n        rep(i, H) {\n          rep(j, W) {\n            if(c[i][j] == 0) continue;\n            bool ff = false;\n            long long M = max(K, W - j);\n            if(K > W - j) continue;\n            for(long long k = M; k >= K; k--) {\n              bool f = true;\n              rep(l, k-1) {\n                if(c[i][j+l] != c[i][j+l+1]) {\n                  f = false;\n                }\n              }\n              if(f) {\n                mem.push_back({{i, j}, k});\n                temp += k * c[i][j] * count;\n                ff = true;\n              }\n              if(ff) {\n                j = j + k - 1;\n                // cout << j << endl;\n                break;\n              }\n            }\n            if(ff) continue;\n          }\n        }\n\n        if(mem.size() == 0) break;\n\n        rep(i, mem.size()) {\n          // cout << mem[i].first.first << \" \" << mem[i].first.second << \" \" << mem[i].second << endl;\n          long long sx, sy, k;\n          sx = mem[i].first.first;\n          sy = mem[i].first.second;\n          k = mem[i].second;\n          if(sx == 0) {\n            rep(j, k) {\n              c[sx][sy+j] = 0;\n            }\n          } else {\n            for(long long h = 1; h <= sx; h++) {\n              rep(j, k) {\n                swap(c[0][sy+j], c[h][sy+j]);\n              }\n            }\n            rep(j, k) {\n              c[0][sy+j] = 0;\n            }\n          }\n\n        }\n\n        count *= 2;\n      }\n      // cout << temp << endl;\n      ans = max(ans, temp);\n    }\n  }\n\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000\nusing namespace std;\n\nint H, W, K;\nint check_point(vector<vector<int>> board, pair<int, int> hw)\n{\n  int ans = 0;\n  board.at(hw.second - 1).erase(board.at(hw.second - 1).begin() + H - hw.first);\n  // int loop_cnt = -1;\n  // while (true)\n  // {\n  //   loop_cnt += 1;\n  //   bool didnt_change = true;\n  //   int cnt;\n  //   for (int i = H - 1; i >= 0; --i)\n  //   {\n  //     cnt = 0;\n  //     int before = -1;\n  //     for (int j = 0; j < W; ++j)\n  //     {\n  //       if (board.at(j).at(i) == -1)\n  //       {\n  //\n  //         if (cnt >= K)\n  //         {\n  //           didnt_change = false;\n  //           ans += pow(2, loop_cnt) * cnt * board.at(j - 1).at(i);\n  //           for (int k = 0; k < cnt; ++k)\n  //           {\n  //             board.at(j - 1 - k).erase(board.at(j - 1 - k).begin() + i);\n  //           }\n  //         }\n  //         before = -1;\n  //         cnt = 0;\n  //       }\n  //       else if (board.at(j).at(i) == before)\n  //       {\n  //         cnt += 1;\n  //       }\n  //       else\n  //       {\n  //         before = board.at(j).at(i);\n  //         if (cnt >= K)\n  //         {\n  //           didnt_change = false;\n  //           ans += pow(2, loop_cnt) * cnt * board.at(j - 1).at(i);\n  //           for (int k = 0; k < cnt; ++k)\n  //           {\n  //             board.at(j - 1 - k).erase(board.at(j - 1 - k).begin() + i);\n  //           }\n  //         }\n  //         cnt = 1;\n  //       }\n  //     }\n  //     if (cnt >= K)\n  //     {\n  //       didnt_change = false;\n  //       ans += pow(2, loop_cnt) * cnt * board.at(W - 1).at(i);\n  //       for (int k = 0; k < cnt; ++k)\n  //       {\n  //         board.at(W - 1 - k).erase(board.at(W - 1 - k).begin() + i);\n  //       }\n  //     }\n  //   }\n  //   if (didnt_change)\n  //   {\n  //     break;\n  //   }\n  // }\n  return ans;\n}\n\nint main()\n{\n  cin >> H >> W >> K;\n  vector<vector<int>> board(W, vector<int>(2 * H, - 1));\n\n  for (int i = 0; i < H; ++i)\n  {\n    string row;\n    cin >> row;\n    for (int j = 0; j < W; ++j)\n    {\n      board.at(j).at(H - 1 - i) = (int)(row.at(j)) - 48;\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i < W; ++i)\n  {\n    for (int j = 0; j < H; ++j)\n    {\n      ans = max(ans, check_point(board, {j + 1, i + 1}));\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n#define DEBUG 1\nusing namespace std;\nconstexpr int kMod = 1000000007;\ntypedef long long LL;\n\nconstexpr char kRemoved = '.';\n\nLL remove_blocks(vector<string>& blocks, int K) {\n  int L = blocks[0].size();\n  LL score = 0;\n  for (auto& line : blocks) {\n    for (int i = 0; i < L; ++i) {\n      int j = i + 1; char c = line[i];\n      if (c == kRemoved) continue;\n      while(line[j] == c && j < L) {\n        ++j;\n      }\n      if (j - i >= K) {\n        for (int x = i; x < j; ++x) line[x] = kRemoved;\n        LL tmp_score = (c - '0') * (j - i);\n        score += tmp_score;\n      }\n      i = j - 1;\n    }\n  }\n  return score;\n}\n\nvoid drop_blocks(vector<string>& blocks) {\n  int H = blocks.size();\n  int L = blocks[0].size();\n  for (int i = 0; i < L; ++i) {\n    int pos = H - 1;\n    for (int r = H - 1; r >= 0; --r) {\n      if (blocks[r][i] != '.') {\n        char c = blocks[r][i];\n        blocks[r][i] = '.';\n        blocks[pos][i] = c;\n        --pos;\n      }\n    }\n  }\n}\n\nint solve(int r, int c, vector<string> blocks, int K) {\n  blocks[r][c] = kRemoved;\n  drop_blocks(blocks);\n\n  int total = 0, score = 0, k = 1;\n  do {\n    score = remove_blocks(blocks, K);\n    drop_blocks(blocks);\n    total += k * score;\n    k *= 2;\n  } while(score);\n\n  return total;\n}\n\nint main() {\n  int H, W, K; cin >> H >> W >> K;\n  vector<string> blocks(H);\n  for (int i = 0; i < H; ++i) cin >> blocks[i];\n\n  int vmax = 0;\n  for (int i = 0; i < H; ++i) {\n    for (int j = 0; j < W; ++j) {\n      vmax = max(vmax, solve(i, j, blocks, K));\n    }\n  }\n  cout << vmax << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<cstdio>\n#include<string>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,int> P;\n\n#define rep(i,x) for(int i = 0 ; i < x ; i ++)\n#define rep1(i,x) for(int i = 1 ; i <= x ; i ++)\n#define rrep(i,x) for(int i = x-1 ; i >= 0 ; i --)\n#define pb push_back\n#define sor(vec) sort(vec.begin(),vec.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define fr first\n#define sc second\n\nint a[32][32];\nbool used[32][32];\nint solve(int h,int w,int k){\n\t//cout << h << \" \" << w << \" \" << k << endl;\n\tint H = 0;\n\trep(j,w){\n\t\tvector<int> vec;\n\t\trep(i,h){\n\t\t\tif(!used[i][j]){\n\t\t\t\tvec.pb(a[i][j]);\n\t\t\t}\n\t\t}\n\t\tH = max ( H , (int)vec.size() );\n\t\trep(i,vec.size()){\n\t\t\ta[i][j] = vec[i];\n\t\t\tused[i][j] = false;\n\t\t}\n\t\tfor(int i = vec.size() ; i < h ; i ++){\n\t\t\tused[i][j] = true;\n\t\t}\n\t}\n\t\n\t/*rep(i,h){\n\t\trep(j,w)cout << a[i][j];\n\t\tcout << endl;\n\t}*/\n\t\n\tint cnt = 0;\n\trep(i,H){\n\t\tint K = 0;\n\t\trep(j,w){\n\t\t\tif(!used[i][j]){\n\t\t\t\tif(j == 0 || a[i][j] == a[i][j-1]){\n\t\t\t\t\tK ++;\n\t\t\t\t\tif(K == k){\n\t\t\t\t\t\tfor(int t = j-k+1 ; t <= j ; t ++){\n\t\t\t\t\t\t\tused[i][t] = true;\n\t\t\t\t\t\t\tcnt += a[i][t];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(K > k){\n\t\t\t\t\t\tused[i][j] = true;\n\t\t\t\t\t\tcnt += a[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse K = 1;\n\t\t\t}\n\t\t\telse K = 0;\n\t\t}\n\t}\n\tif(cnt == 0)return 0;\n\t//cout << \"DEBUG\" << endl;\n\treturn cnt+2*solve(H,w,k);\n}\n\nint main(){\n\tint h,w,k;\n\tint A[32][32];\n\tcin >> h >> w >> k;\n\trrep(i,h){\n\t\tstring X;\n\t\tcin >> X;\n\t\trrep(j,w){\n\t\t\tA[i][j] = X[j]-'0';\n\t\t}\n\t}\n\t\n\tint ret = 0;\n\trep(i,h)rep(j,w){\n\t\t//puts(\"-----------\");\n\t\t//cout << i << \" \" << j << endl;\n\t\trep(I,h)rep(J,w){\n\t\t\ta[I][J] = A[I][J];\n\t\t\tused[I][J] = false;\n\t\t}\n\t\tused[i][j] = true;\n\t\tret = max ( ret , solve(h,w,k) );\n\t}\n\tcout << ret << endl;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\nchar str2num[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};\nint main(void){\n    int h, w, k;\n    scanf(\"%d%d%d\", &h, &w, &k);\n    int i, j, m;\n    int point;\n    int c[30][30];\n    char tmp[31];\n    for(i = 0; i < h; i++){\n        scanf(\"%s\", tmp);\n        for(j = 0; j < w; j++){\n            for(m = 0; m < 10; m++){\n                if(str2num[m] == tmp[j]){\n                    c[i][j] = m;\n                    break;\n                }\n            }\n        }\n    }\n    int c_tmp[30][30];\n    int ans = 0;\n    int ii, jj;\n    int tmp_list[30];\n    for(i = 0; i < h; i++){\n        for(j = 0; j < w; j++){\n            //c_tmpにコピー\n            for(ii = 0; ii < h; ii++){\n                for(jj = 0; jj < w; jj++){\n                    c_tmp[ii][jj] = c[ii][jj];\n                }\n            }\n            int point = 0;\n            int cnt = 1;\n            c_tmp[i][j] = 0;\n            while(1){\n\n                //ブロックを重力落下させる処理\n                for(ii = 0; ii < w; ii++){\n                    int kk = h-1;\n                    for(jj = h-1; jj >= 0; jj--){\n                        if(c_tmp[jj][ii] != 0){\n                            c_tmp[kk][ii] = c_tmp[jj][ii];\n                            kk--;\n                        }\n                    }\n                    while(kk >= 0){\n                        c_tmp[kk][ii] = 0;\n                        kk--;\n                    }\n                }\n\n\n                int point_tmp = 0;\n                //ブロックに水平に隣り合ったマスを消す\n                for(ii = 0; ii < h; ii++){\n                    if(c_tmp[ii][0] == c_tmp[ii][1]){\n                        point_tmp += c_tmp[ii][0];\n                        tmp_list[0] = 0;\n                    }else{\n                        tmp_list[0] = 1;\n                    }\n                    for(jj = 1; jj < w-1; jj++){\n                        if(c_tmp[ii][jj] == c_tmp[ii][jj+1] || c_tmp[ii][jj] == c_tmp[ii][jj-1]){\n                            point_tmp += c_tmp[ii][jj];\n                            tmp_list[jj] = 0;\n                        }else{\n                            tmp_list[jj] = 1;\n                        }\n                    }\n                    if(c_tmp[ii][w-1] == c_tmp[ii][w-2]){\n                        point_tmp += c_tmp[ii][w-1];\n                        tmp_list[w-1] = 0;\n                    }else{\n                        tmp_list[w-1] = 1;\n                    }\n                    \n                    //消すようにメモしたブロックを消す\n                    for(int kk = 0; kk < w; kk++){\n                        c_tmp[ii][kk] =  c_tmp[ii][kk] * tmp_list[kk];\n                    }\n                }\n\n                if(point_tmp == 0){\n                    break;\n                }\n                point += point_tmp * pow(2, cnt-1);\n                cnt++;\n            }\n            ans = ans > point ? ans : point;\n        }\n    }\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C",
    "code": "#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n// 内部定数\n#define D_SIZE_MAX\t\t30\t\t\t\t\t\t\t\t\t\t// 最大サイズ\n\n// 内部変数\nstatic FILE *szpFpI;\t\t\t\t\t\t\t\t\t\t\t// 入力\nstatic int siH, siW;\t\t\t\t\t\t\t\t\t\t\t// 高さ・幅\nstatic int siDCnt;\t\t\t\t\t\t\t\t\t\t\t\t// 削除条件数\nstatic int si2Ini[D_SIZE_MAX][D_SIZE_MAX + 5];\t\t\t\t\t// 初期配置\nstatic int si2Work[D_SIZE_MAX][D_SIZE_MAX + 5];\t\t\t\t\t// ワーク配置\nstatic int siMax;\t\t\t\t\t\t\t\t\t\t\t\t// 最大得点\n\n// 内部変数 - テスト用\n#ifdef D_TEST\n\tstatic int siRes;\n\tstatic FILE *szpFpA;\n#endif\n\n// マスの落下\nint\nfDown(\n\tint piX\t\t\t\t\t\t// <I> 位置X\n)\n{\n\tint liTNo = siH - 1;\n\tint liFNo = -1;\n\twhile (1) {\n\n\t\t// 移動先 - 取得\n\t\twhile (1) {\n\t\t\tif (si2Work[liTNo][piX] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (liTNo <= 1) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tliTNo--;\n\t\t}\n\n\t\t// 移動元 - 取得\n\t\tif (liFNo < 0) {\n\t\t\tliFNo = liTNo - 1;\n\t\t}\n\t\twhile (1) {\n\t\t\tif (si2Work[liFNo][piX] != 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (liFNo <= 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tliFNo--;\n\t\t}\n\n\t\t// 移動\n\t\tsi2Work[liTNo][piX] = si2Work[liFNo][piX];\n\t\tsi2Work[liFNo][piX] = 0;\n\n\t\t// 次回有無\n\t\tif (liFNo < 1) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// 次回用\n\t\tliTNo--;\n\t\tliFNo--;\n\t}\n\n\treturn 0;\n}\n\n// マスの削除\nint\nfDel(\n\tint piY\t\t\t\t\t\t// <I> 位置Y\n)\n{\n\tint liSNo = 0;\n\tint liENo;\n\tint liSum = 0;\n\tfor (liENo = 1; liENo <= siW; liENo++) {\n\n\t\t// 左と比較\n\t\tif (si2Work[piY][liENo] == si2Work[piY][liENo - 1]) {\t\t// 一致\n\t\t\tcontinue;\n\t\t}\n\n\t\t// 長さ\n\t\tint liLen = liENo - liSNo;\n\t\tif (liLen < siDCnt) {\t\t\t\t\t\t\t\t\t\t// 削除条件外\n\t\t\tliSNo = liENo;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// 得点 - 加算\n\t\tliSum += si2Work[piY][liSNo] * liLen;\n\n\t\t// 削除\n\t\tfor (; liSNo < liENo; liSNo++) {\n\t\t\tsi2Work[piY][liSNo] = 0;\n\t\t}\n\t}\n\n\treturn liSum;\n}\n\n// 得点 - 取得\nint\nfGetScore(\n)\n{\n\tint i;\n\n\tint liSum = 0;\n\tint liRate = 1;\n\twhile (1) {\n\n\t\t// マスの落下\n\t\tfor (i = 0; i < siW; i++) {\n\t\t\tfDown(i);\n\t\t}\n\n\t\t// マスの削除\n\t\tint liDel = 0;\n\t\tfor (i = 0; i < siH; i++) {\n\t\t\tliDel += fDel(i);\n\t\t}\n\t\tif (liDel < 1) {\t\t\t\t// なし\n\t\t\tbreak;\n\t\t}\n\n\t\t// 得点 - 加算\n\t\tliSum += liDel * liRate;\n\n\t\t// 得点係数\n\t\tliRate *= 2;\n\t}\n\n\treturn liSum;\n}\n\n// 最大得点 - セット\nint\nfSetMax(\n)\n{\n\tint i, j;\n\n\t// 全箇所で実行\n\tfor (i = 0; i < siH; i++) {\n\t\tfor (j = 0; j < siW; j++) {\n\n\t\t\t// ワーク配置にコピー\n\t\t\tmemcpy(si2Work, si2Ini, sizeof(si2Work));\n\n\t\t\t// １マス削除\n\t\t\tsi2Work[i][j] = 0;\n\n\t\t\t// 得点 - 取得\n\t\t\tint liScore = fGetScore();\n\n\t\t\t// 最大得点 - 更新\n\t\t\tif (siMax < liScore) {\n\t\t\t\tsiMax = liScore;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n// 実行メイン\nint\nfMain(\n\tint piTNo\t\t\t\t\t// <I> テスト番号 1～\n)\n{\n\tint i, j;\n\tchar lc1Buf[1024], lc1Out[1024];\n\n\t// データ - 初期化\n\tmemset(si2Ini, 0, sizeof(si2Ini));\t\t\t\t\t\t\t// 初期配置\n\tsiMax = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t// 最大得点\n\n\t// 入力 - セット\n#ifdef D_TEST\n\tsprintf(lc1Buf, \".\\\\Test\\\\T%d.txt\", piTNo);\n\tszpFpI = fopen(lc1Buf, \"r\");\n\tsprintf(lc1Buf, \".\\\\Test\\\\A%d.txt\", piTNo);\n\tszpFpA = fopen(lc1Buf, \"r\");\n\tsiRes = 0;\n#else\n\tszpFpI = stdin;\n#endif\n\n\t// 高さ・幅・削除条件数 - 取得\n\tfgets(lc1Buf, sizeof(lc1Buf), szpFpI);\n\tsscanf(lc1Buf, \"%d%d%d\", &siH, &siW, &siDCnt);\n\n\t// 初期配置 - 取得\n\tfor (i = 0; i < siH; i++) {\n\t\tfgets(lc1Buf, sizeof(lc1Buf), szpFpI);\n\t\tfor (j = 0; j < siW; j++) {\n\t\t\tsi2Ini[i][j] = lc1Buf[j] - '0';\n\t\t}\n\t}\n\n\t// 最大得点 - セット\n\tfSetMax();\n\n\t// 結果 - セット\n\tsprintf(lc1Out, \"%d\\n\", siMax);\n\n\t// 結果 - 表示\n#ifdef D_TEST\n\tfgets(lc1Buf, sizeof(lc1Buf), szpFpA);\n\tif (strcmp(lc1Buf, lc1Out)) {\n\t\tsiRes = -1;\n\t}\n#else\n\tprintf(\"%s\", lc1Out);\n#endif\n\n\t// 残データ有無\n#ifdef D_TEST\n\tlc1Buf[0] = '\\0';\n\tfgets(lc1Buf, sizeof(lc1Buf), szpFpA);\n\tif (strcmp(lc1Buf, \"\")) {\n\t\tsiRes = -1;\n\t}\n#endif\n\n\t// テストファイルクローズ\n#ifdef D_TEST\n\tfclose(szpFpI);\n\tfclose(szpFpA);\n#endif\n\n\t// テスト結果\n#ifdef D_TEST\n\tif (siRes == 0) {\n\t\tprintf(\"OK %d\\n\", piTNo);\n\t}\n\telse {\n\t\tprintf(\"NG %d\\n\", piTNo);\n\t}\n#endif\n\n\treturn 0;\n}\n\nint\nmain()\n{\n\n#ifdef D_TEST\n\tint i;\n\tfor (i = D_TEST_SNO; i <= D_TEST_ENO; i++) {\n\t\tfMain(i);\n\t}\n#else\n\tfMain(0);\n#endif\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20180717\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\n\nvoid shuffledget(int x[],int n){\n    srand(time(0));\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\nvoid arrcpy(char a[32][32],char b[32][32]){\n    long long i;\n    for(i=0;i<32;i++){\n        strcpy(a[i],b[i]);\n    }\n}\n\nlong long h,w,k;\n\nvoid prblk(char a[32][32]){\n    long long i;\n    for(i=0;i<h;i++){\n        printf(\"%s\\n\",a[i]);\n    }\n}\n\nvoid fallblk(char a[32][32]){\n    long long i,j,p;\n    for(i=0;i<w;i++){\n        p=h-1;\n        for(j=h-1;j>=0;j--){\n            if(a[j][i]!='0'){\n                a[p][i]=a[j][i];\n                p--;\n            }\n        }\n        while(p>=0){\n            a[p][i]='0';\n            p--;\n        }\n    }\n}\n\nlong long vanblk(char a[32][32]){\n    long long i,j,p,r=0,v;\n    for(i=0;i<h;i++){\n        a[i][w]='#';\n        p=1;\n        for(j=1;j<=w;j++){\n            if(a[i][j-1]!=a[i][j]){\n                if(p>=k){\n                    for(v=j-p;v<=j-1;v++){\n                        r+=(a[i][v]-'0');\n                        a[i][v]='0';\n                    }\n                }\n                p=1;\n            }\n            else{p++;}\n        }\n    }\n    return r;\n}\n\nint main(void){\n    long long i,j,n,m,a,b,c,r=0,l,t,nsc;\n    char s[32][32],nb[32][32];\n    scanf(\"%lld%lld%lld\",&h,&w,&k);\n    for(i=0;i<h;i++){scanf(\"%s\",s[i]);}\n    for(i=0;i<h;i++){\n        for(j=0;j<w;j++){\n            arrcpy(nb,s);\n            nb[i][j]='0';\n            nsc=0;\n            l=1;\n            while(1){\n                fallblk(nb);\n                t=vanblk(nb);\n                if(t==0){break;}\n                nsc+=(t*l);\n                l*=2;\n            }\n            r=llmax(r,nsc);\n        }\n    }\n    printf(\"%lld\\n\",r);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define HEIGHT_MAX 30\n#define WIDTH_MAX 30\n#define BOARD_MAX (HEIGHT_MAX*(WIDTH_MAX+1))\n#define BUF_SIZE WIDTH_MAX+5\n\n// size: specify sizeof(str)\nint get_str(char *str, int size) {\n    if(!fgets(str, size, stdin)) return -1;\n    return 0;\n}\n\nint get_int3(int *a1, int *a2, int *a3) {\n#ifdef BUF_SIZE\n  char line[BUF_SIZE];\n  if(!fgets(line, BUF_SIZE, stdin)) return -1;\n  sscanf(line, \"%d %d %d\", a1, a2, a3);\n#else\n#error\n#endif\n  return 0;\n}\n\nint judge(char *arr, int size, int chains, int neighs) {\n    int score = 0;\n    int cnt = 1;\n    char cur = arr[0];\n    int i, j;\n    for(i = 1; i < size; i++) {\n        char next = arr[i];\n        if(cur == next) { cnt++; continue; }\n        if(cnt >= neighs) {\n            score += (1<<chains) * (cnt * cur);\n            // labeled as 0\n            for(j = i - cnt; j <= i-1; j++) {\n                arr[j] = 0;\n            }\n        }\n        // reset\n        cur = next; cnt = 1;\n    }\n#ifdef DEBUG\n    printf(\"chains: %d -> score: %d\\n\", chains, score);\n#endif\n    return score;\n}\n\n#define max(a,b) ((a) > (b) ? (a) : (b))\n\nint main(void) {\n    int height, width, neighs;\n    get_int3(&height, &width, &neighs);\n    static char board[HEIGHT_MAX][WIDTH_MAX+1];\n    static char buf[BUF_SIZE];\n    int i, j;\n    for(i = height-1; i >= 0; i--) {\n        get_str(buf, BUF_SIZE);\n        for(j = 0; j < width; j++) {\n            board[i][j] = buf[j]-'0';\n        }\n    }\n\n    int ans = 0; // less than 1billion\n    int hei, wid;\n    for(hei = 0; hei < height-1; hei++) {\n        for(wid = 0; wid < width; wid++) {\n#ifdef DEBUG\n            printf(\"remove: (%d, %d)\\n\", hei, wid);\n#endif\n            int score = 0;\n            int chs = 0;\n            char bboard[HEIGHT_MAX][WIDTH_MAX+1] = {0};\n            memcpy(bboard, board, BOARD_MAX);\n            // remove one of the stones\n            for(i = hei+1; i < height; i++) {\n                bboard[i-1][wid] = bboard[i][wid];\n            }\n            bboard[height-1][wid] = 0;\n\n            // judge\n            for(chs = 0; ; chs++) {\n                int scr = 0;\n                int h, w;\n                char new[HEIGHT_MAX][WIDTH_MAX+1] = {0};\n                for(h = 0; h < height; h++) {\n                    scr += judge(bboard[h], width+1, chs, neighs);\n                }\n                // calc_score\n                if(!scr) break;\n                score += scr;\n\n                // drop(not-in-place)\n                for(w = 0; w < width; w++) {\n                    int idx = 0;\n                    // bottom to top..\n                    for(h = 0; h < height; h++) {\n                        if(!bboard[h][w]) continue;\n                        new[idx++][w] = bboard[h][w];\n                    }\n                }\n                // memcpy\n                memcpy(bboard, new, BOARD_MAX);\n            }\n            ans = max(ans, score);\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint H, W, K;\nint board[30][31], init[30][31];\n\nint erase(void){\n    int i, j, k;\n    int ret = 0, combo;\n    for(i = 0; i < H; i++){\n        combo = 1;\n        for(j = 0; j < W; j++){\n            if(board[i][j] == board[i][j+1]) combo++;\n            else{\n                if(combo >= K){\n                    for(k = j - combo + 1; k <= j; k++){\n                        ret += board[i][k];\n                        board[i][k] = 0;\n                    }\n                }\n                combo = 1;\n            }\n        }\n    }\n    \n    return ret;\n}\n\nvoid fall(void){\n    int changeflg, i, j;\n    \n    do{\n        changeflg = 0;\n        for(i = H - 2; i >= 0; i--){\n            for(j = 0; j < W; j++){\n                if(board[i + 1][j] == 0 && board[i][j] != 0){\n                    board[i + 1][j] = board[i][j];\n                    board[i][j] = 0;\n                    changeflg = 1;\n                }\n            }\n        }\n    }while(changeflg);\n}\n\nint main(void){\n    int i, j, ii, jj;\n    int maxscore = 0, score, num, power2;\n    scanf(\"%d %d %d\", &H, &W, &K);\n    \n    getc(stdin);\n    \n    for(i = 0; i < H; i++){\n        for(j = 0; j < W; j++){\n            init[i][j] = getc(stdin) - '0';\n        }\n        getc(stdin);\n    }\n    \n    for(i = 0; i < H; i++){\n        for(j = 0; j < W; j++){\n            for(ii = 0; ii < H; ii++) for(jj = 0; jj < W; jj++) board[ii][jj] = init[ii][jj];\n\n            board[i][j] = 0;\n            score = 0;\n            \n            fall();\n            for(power2 = 1; num = erase(); power2 *= 2){\n                score += num * power2;\n                fall();\n            }\n            \n            if(score > maxscore) maxscore = score;\n        }\n    }\n    \n    printf(\"%ld\\n\", maxscore);\n    \n    //system(\"pause\");\n    \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\nchar str2num[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};\nint main(void){\n    int h, w, k;\n    scanf(\"%d%d%d\", &h, &w, &k);\n    int i, j, m;\n    long long int point;\n    int c[30][30];\n    char tmp[31];\n    for(i = 0; i < h; i++){\n        scanf(\"%s\", tmp);\n        for(j = 0; j < w; j++){\n            for(m = 0; m < 10; m++){\n                if(str2num[m] == tmp[j]){\n                    c[i][j] = m;\n                    break;\n                }\n            }\n        }\n    }\n    int c_tmp[30][30];\n    long long int ans = 0;\n    int ii, jj;\n    int tmp_list[30];\n    for(i = 0; i < h; i++){\n        for(j = 0; j < w; j++){\n            //c_tmpにコピー\n            for(ii = 0; ii < h; ii++){\n                for(jj = 0; jj < w; jj++){\n                    c_tmp[ii][jj] = c[ii][jj];\n                }\n            }\n            long long int point = 0;\n            int cnt = 1;\n            c_tmp[i][j] = 0;\n            while(1){\n\n                //ブロックを重力落下させる処理\n                for(ii = 0; ii < w; ii++){\n                    int kk = h-1;\n                    for(jj = h-1; jj >= 0; jj--){\n                        if(c_tmp[jj][ii] != 0){\n                            c_tmp[kk][ii] = c_tmp[jj][ii];\n                            kk--;\n                        }\n                    }\n                    while(kk >= 0){\n                        c_tmp[kk][ii] = 0;\n                        kk--;\n                    }\n                }\n\n\n                long long int point_tmp = 0;\n                //ブロックに水平に隣り合ったマスを消す\n                for(ii = 0; ii < h; ii++){\n                    if(c_tmp[ii][0] == c_tmp[ii][1]){\n                        point_tmp += c_tmp[ii][0];\n                        tmp_list[0] = 0;\n                    }else{\n                        tmp_list[0] = 1;\n                    }\n                    for(jj = 1; jj < w-1; jj++){\n                        if(c_tmp[ii][jj] == c_tmp[ii][jj+1] || c_tmp[ii][jj] == c_tmp[ii][jj-1]){\n                            point_tmp += c_tmp[ii][jj];\n                            tmp_list[jj] = 0;\n                        }else{\n                            tmp_list[jj] = 1;\n                        }\n                    }\n                    if(c_tmp[ii][w-1] == c_tmp[ii][w-2]){\n                        point_tmp += c_tmp[ii][w-1];\n                        tmp_list[w-1] = 0;\n                    }else{\n                        tmp_list[w-1] = 1;\n                    }\n                    \n                    //消すようにメモしたブロックを消す\n                    for(int kk = 0; kk < w; kk++){\n                        c_tmp[ii][kk] =  c_tmp[ii][kk] * tmp_list[kk];\n                    }\n                }\n\n                if(point_tmp == 0){\n                    break;\n                }\n                point += point_tmp * pow(2, cnt-1);\n                cnt++;\n            }\n            ans = ans > point ? ans : point;\n        }\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdint.h>\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\null h, w, k;\nchar s[3010][3010], t[3010][3010];\n\nvoid drop () {\n\tsll i, j;\n\tfor (j = 0; j < w; j++) {\n\t\tsll bottom = h - 1;\n\t\tfor (i = h - 1; i >= 0; i--) {\n\t\t\tif (t[i][j]) {\n\t\t\t\tt[bottom--][j] = t[i][j];\n\t\t\t}\n\t\t}\n\t\twhile (bottom >= 0) {\n\t\t\tt[bottom--][j] = '\\0';\n\t\t}\n\t}\n}\n\null rensa () {\n\tsll i, j;\n\tull r = 0;\n\tfor (i = 0; i < h; i++) {\n\t\tj = 0;\n\t\twhile (j < w) {\n\t\t\tif (!t[i][j]) {\n\t\t\t\tj++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsll ki = j;\n\t\t\twhile (j < w && t[i][j] == t[i][ki]) j++;\n\n\t\t\tif (j - ki >= k) {\n\t\t\t\tr += (j - ki) * (t[i][ki] - '0');\n\t\t\t\twhile (ki < j) {\n\t\t\t\t\tt[i][ki] = '\\0';\n\t\t\t\t\tki++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn r;\n}\n\null f (ull a, ull b) {\n\tsll i, j;\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tt[i][j] = s[i][j];\n\t\t}\n\t}\n\tt[a][b] = '\\0';\n\n\tull r = 0;\n\tfor (i = 0; ; i++) {\n\t\tdrop();\n\t\tull x = rensa() << i;\n\t\tif (!x) return r;\n\n\t\tr += x;\n\t}\n}\n\null solve () {\n\tull result = 0;\n\tif (k > 3) {\n\t\tputs(\"0\");\n\t\treturn 1;\n\t}\n\n\tfor (sll i = 0; i < h; i++) {\n\t\tfor (sll j = 0; j < w; j++) {\n\t\t\tull item = f(i, j);\n\t\t\tif (item > result) result = item;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\treturn 0;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\tscanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &k);\n\tfor (i = 0; i < h; i++) {\n\t\tscanf(\"%s\", &s[i]);\n\t}\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void){\n\tchar c;\n\tint H,W,K,gen,max=0,h,i,j,q,w,e,r,t,step,ren,mae,tsten;\n\tint bans[32][32]={0};\n\tint gban[32][32]={0};\n\tint iti[30]={0};\n\tscanf(\"%d %d %d\",&H,&W,&K);\n\tfor(i=H-1;i>=0;i--){\n\t\tfor(j=0;j<W;j++){\n\t\t\tscanf(\" %c\",&c);\n\t\t\tbans[i][j]=c-48;\n\t\t}\n\t\tbans[i][W]=0;//右だけ晩兵\n\t}\n\tW++;\n\tfor(i=0;i<H;i++){\n\t\tfor(j=0;j<W;j++){\n\t\t\tfor(q=0;q<H;q++){\n\t\t\t\tfor(w=0;w<W;w++){\n\t\t\t\t\tgban[q][w]=bans[q][w];\n\t\t\t\t}\n\t\t\t}\n\t\t\tgban[i][j]=0;\n\t\t\tgen=0;\n\t\t\tstep=0;\n\t\t\tfor(step=0;step<30;step++){//30連鎖はしないと思ふ\n\t\t\t\tfor(q=0;q<W;q++){//まず落とす\n\t\t\t\t\te=0;\n\t\t\t\t\tfor(w=0;w<H;w++){\n\t\t\t\t\t\tif(gban[w][q]!=0){\n\t\t\t\t\t\t\titi[e]=gban[w][q];\n\t\t\t\t\t\t\te++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(w=0;w<H;w++){\n\t\t\t\t\t\tif(w<e){ gban[w][q]=iti[w]; } else{gban[w][q]=0;}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//落とし終わった\n\t\t\t\ttsten=0;\n\t\t\t\tfor(q=0;q<H;q++){\n\t\t\t\t\tren=0;\n\t\t\t\t\tmae=0;\n\t\t\t\t\tfor(w=0;w<W;w++){\n\t\t\t\t\t\tif(mae==gban[q][w]&&gban[q][w]!=0){\n\t\t\t\t\t\t\tren++;\n\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\tif(ren>=K){\n\t\t\t\t\t\t\t\tfor(e=w-ren;e<w;e++){\n\t\t\t\t\t\t\t\t\ttsten+=gban[q][e];\n\t\t\t\t\t\t\t\t\tgban[q][e]=0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tren=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmae=gban[q][w];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgen+=tsten<<step;\n\t\t\t\tif(tsten==0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max<gen){max=gen;}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",max);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\nchar str2num[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};\nint main(void){\n    int h, w, k;\n    scanf(\"%d%d%d\", &h, &w, &k);\n    int i, j, m;\n    int point;\n    int c[30][30];\n    char tmp[31];\n    for(i = 0; i < h; i++){\n        scanf(\"%s\", tmp);\n        for(j = 0; j < w; j++){\n            for(m = 0; m < 10; m++){\n                if(str2num[m] == tmp[j]){\n                    c[i][j] = m;\n                    break;\n                }\n            }\n        }\n    }\n    int c_tmp[30][30];\n    long long int ans = 0;\n    int ii, jj;\n    int tmp_list[30];\n    for(i = 0; i < h; i++){\n        for(j = 0; j < w; j++){\n            //c_tmpにコピー\n            for(ii = 0; ii < h; ii++){\n                for(jj = 0; jj < w; jj++){\n                    c_tmp[ii][jj] = c[ii][jj];\n                }\n            }\n            long long int point = 0;\n            int cnt = 1;\n            c_tmp[i][j] = 0;\n            while(1){\n\n                //ブロックを重力落下させる処理\n                for(ii = 0; ii < w; ii++){\n                    int kk = h-1;\n                    for(jj = h-1; jj >= 0; jj--){\n                        if(c_tmp[jj][ii] != 0){\n                            c_tmp[kk][ii] = c_tmp[jj][ii];\n                            kk--;\n                        }\n                    }\n                    while(kk >= 0){\n                        c_tmp[kk][ii] = 0;\n                        kk--;\n                    }\n                }\n\n\n                long long int point_tmp = 0;\n                //ブロックに水平に隣り合ったマスを消す\n                for(ii = 0; ii < h; ii++){\n                    if(c_tmp[ii][0] == c_tmp[ii][1]){\n                        point_tmp += c_tmp[ii][0];\n                        tmp_list[0] = 0;\n                    }else{\n                        tmp_list[0] = 1;\n                    }\n                    for(jj = 1; jj < w-1; jj++){\n                        if(c_tmp[ii][jj] == c_tmp[ii][jj+1] || c_tmp[ii][jj] == c_tmp[ii][jj-1]){\n                            point_tmp += c_tmp[ii][jj];\n                            tmp_list[jj] = 0;\n                        }else{\n                            tmp_list[jj] = 1;\n                        }\n                    }\n                    if(c_tmp[ii][w-1] == c_tmp[ii][w-2]){\n                        point_tmp += c_tmp[ii][w-1];\n                        tmp_list[w-1] = 0;\n                    }else{\n                        tmp_list[w-1] = 1;\n                    }\n                    \n                    //消すようにメモしたブロックを消す\n                    for(int kk = 0; kk < w; kk++){\n                        c_tmp[ii][kk] =  c_tmp[ii][kk] * tmp_list[kk];\n                    }\n                }\n\n                if(point_tmp == 0){\n                    break;\n                }\n                point += point_tmp * pow(2, cnt-1);\n                cnt++;\n            }\n            ans = ans > point ? ans : point;\n        }\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <limits.h>\n\nint ctoi(char c) {\n\tswitch (c) {\n\t\tcase '0': return 0;\n\t\tcase '1': return 1;\n\t\tcase '2': return 2;\n\t\tcase '3': return 3;\n\t\tcase '4': return 4;\n\t\tcase '5': return 5;\n\t\tcase '6': return 6;\n\t\tcase '7': return 7;\n\t\tcase '8': return 8;\n\t\tcase '9': return 9;\n\t\tdefault: return 0;\n\t}\n}\n\nint main(void){\n    int h,w,k,count=1,score=0;\n    long long tmp=0,prev=0,ans=0;\n    scanf(\"%d%d%d\",&h,&w,&k);\n    char c[h][w+1],m[h][w+1];\n    for (int i=0; i<h; i++){\n        scanf(\"%s\",m[i]);\n    }\n    for (int i=1; i<h; i++){\n        for (int j=0; j<w; j++){\n            \n            for (int l=0; l<h; l++){\n                strcpy(c[l],m[l]);\n            }\n            \n            c[i][j]='0';    \n            tmp=0;\n            for (int l=1; l<h; l++){\n                for (int m=0; m<w; m++){\n                    if (c[l][m]=='0'){\n                        for (int n=l; n>0; n--){\n                            c[n][m]=c[n-1][m];\n                        }\n                        c[0][m]='0';\n                    }\n                }\n            }\n            \n            score=0;\n            do {\n                prev=tmp;\n                \n                for (int l=0; l<h; l++){\n                    for (int m=1; m<w; m++){\n                        \n                        if (c[l][m-1]==c[l][m]){\n                            count++;\n                        } else {\n                            if (count>=k){\n\n                                tmp+=pow(2,score)*count*(ctoi(c[l][m-1]));\n                                \n                                for (int n=0; n<count; n++){\n                                    c[l][m-n-1]='0';\n                                }\n                                \n                            }\n                            count=1;\n                        }\n                        if (m==w-1){\n                            if (count>=k){\n                                tmp+=pow(2,score)*count*(ctoi(c[l][m-1]));\n                                for (int n=0; n<count; n++){\n                                    c[l][m-n]='0';\n                                }\n                            }\n                            count=1;\n                        }\n                    }\n                }\n                \n                for (int l=1; l<h; l++){\n                    for (int m=0; m<w; m++){\n                        if (c[l][m]=='0'){\n                            for (int n=l; n>0; n--){\n                                c[n][m]=c[n-1][m];\n                            }\n                            c[0][m]='0';\n                        }\n                    }\n                }\n                score++;\n                \n            } while (prev!=tmp);\n            \n            if (ans<tmp){\n                ans=tmp;\n            }\n        }\n    }\n    printf(\"%lld\\n\",ans);\n\treturn 0 ;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\nchar str2num[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};\nint main(void){\n    int h, w, k;\n    scanf(\"%d%d%d\", &h, &w, &k);\n    int i, j, m;\n    long long int point;\n    int c[30][30];\n    char tmp[31];\n    for(i = 0; i < h; i++){\n        scanf(\"%s\", tmp);\n        for(j = 0; j < w; j++){\n            for(m = 0; m < 10; m++){\n                if(str2num[m] == tmp[j]){\n                    c[i][j] = m;\n                    break;\n                }\n            }\n        }\n    }\n    int c_tmp[30][30];\n    long long int ans = 0;\n    int ii, jj;\n    int tmp_list[30];\n    for(i = 0; i < h; i++){\n        for(j = 0; j < w; j++){\n            //c_tmpにコピー\n            for(ii = 0; ii < h; ii++){\n                for(jj = 0; jj < w; jj++){\n                    c_tmp[ii][jj] = c[ii][jj];\n                }\n            }\n            long long int point = 0;\n            int cnt = 1;\n            c_tmp[i][j] = 0;\n            while(1){\n\n                //ブロックを重力落下させる処理\n                for(ii = 0; ii < w; ii++){\n                    int kk = h-1;\n                    for(jj = h-1; jj >= 0; jj--){\n                        if(c_tmp[jj][ii] != 0){\n                            c_tmp[kk][ii] = c_tmp[jj][ii];\n                            kk--;\n                        }\n                    }\n                    while(kk >= 0){\n                        c_tmp[kk][ii] = 0;\n                        kk--;\n                    }\n                }\n\n\n                long long int point_tmp = 0;\n                //ブロックに水平に隣り合ったマスを消す\n                for(ii = 0; ii < h; ii++){\n\n                    tmp_list[0] = 0;\n                    for(jj = 1; jj < w; jj++){\n                        if(c_tmp[ii][jj] == c_tmp[ii][jj-1]){\n                            tmp_list[jj] = tmp_list[jj - 1] + 1;\n                        }else{\n                            tmp_list[jj] = 0;\n                        }\n                        //printf(\"%d \", tmp_list[jj]);\n                    }\n                    //printf(\"\\n\");\n\n                    \n                    for(int kk = 0; kk < w; kk++){\n                        if(tmp_list[kk] >= k - 1){\n                            for(int iii = 0; iii <= tmp_list[kk]; iii++){\n                                point_tmp += c_tmp[ii][kk - iii];\n                                c_tmp[ii][kk - iii] = 0;\n                            }\n                        }\n                    }\n                }\n\n                if(point_tmp == 0){\n                    break;\n                }\n                point += point_tmp * pow(2, cnt-1);\n                cnt++;\n            }\n            ans = ans > point ? ans : point;\n        }\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "Pascal",
    "code": "program b;\nconst\n        fi='';\n        fo='';\n        maxh=30;\n        maxw=30;\n        maxk=3;\nvar\n        h,w,k:byte;\n        Cold,C:array[0..maxh] of string;\n        sum,ans:longint;\n        cs:longint;\n\nprocedure Install;\nbegin\n        assign(input,fi); assign(output,fo);\n        reset(input); rewrite(output);\nend;\n\nprocedure close_All;\nbegin\n        close(input); close(output);\nend;\n\nprocedure Enter;\nvar\n        i,j:longint;\n        s:string;\nbegin\n        readln(h,w,k);\n        for i:=1 to h do\n        begin\n                readln(Cold[i]);\n        end;\nend;\n\n\nprocedure Drop;\nvar\n        i,j:longint;\nbegin\n        for i:=h-1 downto 1 do\n        for j:=1 to w do\n        if (C[i+1][j]='0') and (C[i][j]<>'0') then\n        begin\n                C[i+1][j]:=C[i][j];\n                C[i][j]:='0';\n        end;\nend;\n\nprocedure Bien;\nvar\n        i,j,pb,pe,x:longint;\n        tmp:longint;\n        OK:boolean;\nbegin\n        OK:=false;  tmp:=0;\n        for i:=1 to h do\n        begin\n                pe:=0;\n                while pe<w do\n                begin\n                        pb:=pe+1;\n                        if C[i][pb]<>'0' then\n                        begin\n                                x:=pb;\n                                while C[i][x]=C[i][pb] do inc(x);\n                                pe:=x-1;\n                                if pe>pb then\n                                begin\n                                        if OK=false then inc(cs);\n                                        OK:=true;\n                                        for j:=pb to pe do\n                                        begin\n                                                tmp:=tmp+ord(C[i][j])-48;\n                                                C[i][j]:='0';\n                                        end;\n                                end;\n                        end else inc(pe);\n                end;\n        end;\n        sum:=sum+tmp*(1 shl cs);\nend;\n\nfunction max(x,y:longint):longint;\nbegin\n        if x>y then exit(x) else exit(y);\nend;\n\nprocedure Xuli;\nvar\n        i,j,m,n:byte;\n        C2:array[0..maxh] of string;\n        Khac:boolean;\nbegin\n        for i:=1 to h do\n        for j:=1 to w do\n        begin\n                C:=Cold;\n                C[i][j]:='0';\n                cs:=-1;   sum:=0;\n                repeat\n                        C2:=C; Khac:=false;\n                        Drop;\n                        Bien;\n                        for m:=1 to h do if C2[m]<>C[m] then begin Khac:=true; break; end;\n                        if Khac=false then break;\n                until False;\n                ans:=max(sum,ans);\n        end;\n        writeln(ans);\nend;\n\nBEGIN\n        Install;\n        Enter;\n        XuLi;\n        close_All;\nEND.\n"
  },
  {
    "language": "Pascal",
    "code": "program b;\nconst\n        fi='';\n        fo='';\n        maxh=30;\n        maxw=30;\n        maxk=3;\nvar\n        h,w,k:byte;\n        Cold,C:array[0..maxh] of string;\n        sum,ans:longint;\n        cs:longint;\n\nprocedure Install;\nbegin\n        assign(input,fi); assign(output,fo);\n        reset(input); rewrite(output);\nend;\n\nprocedure close_All;\nbegin\n        close(input); close(output);\nend;\n\nprocedure Enter;\nvar\n        i,j:longint;\n        s:string;\nbegin\n        readln(h,w,k);\n        for i:=1 to h do\n        begin\n                readln(Cold[i]);\n        end;\nend;\n\n\nprocedure Drop;\nvar\n        i,j:longint;\nbegin\n        for i:=h-1 downto 1 do\n        for j:=1 to w do\n        if (C[i+1][j]='0') and (C[i][j]<>'0') then\n        begin\n                C[i+1][j]:=C[i][j];\n                C[i][j]:='0';\n        end;\nend;\n\nprocedure Bien;\nvar\n        i,j,pb,pe,x:longint;\n        tmp:longint;\n        OK:boolean;\nbegin\n        OK:=false;  tmp:=0;\n        for i:=1 to h do\n        begin\n                pe:=0;\n                while pe<w do\n                begin\n                        pb:=pe+1;\n                        if C[i][pb]<>'0' then\n                        begin\n                                x:=pb;\n                                while C[i][x]=C[i][pb] do inc(x);\n                                pe:=x-1;\n                                if pe>pb then\n                                begin\n                                        if OK=false then inc(cs);\n                                        OK:=true;\n                                        for j:=pb to pe do\n                                        begin\n                                                tmp:=tmp+ord(C[i][j])-48;\n                                                C[i][j]:='0';\n                                        end;\n                                end;\n                        end else inc(pe);\n                end;\n        end;\n        sum:=sum+tmp*(1 shl cs);\nend;\n\nfunction max(x,y:longint):longint;\nbegin\n        if x>y then exit(x) else exit(y);\nend;\n\nprocedure Xuli;\nvar\n        i,j,m,n:byte;\n        C2:array[0..maxh] of string;\n        Khac:boolean;\nbegin\n        for i:=1 to h do\n        for j:=1 to w do\n        begin\n                C:=Cold;\n                C[i][j]:='0';\n                cs:=-1;   sum:=0;\n                repeat\n                        C2:=C; Khac:=false;\n                        Drop;\n                        Bien;\n                        for m:=1 to h do if C2[m]<>C[m] then begin Khac:=true; break; end;\n                        if Khac=false then break;\n                until False;\n                ans:=max(sum,ans);\n        end;\n        writeln(ans);\nend;\n\nBEGIN\n        Install;\n        Enter;\n        XuLi;\n        close_All;\nEND.\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n  private static boolean debug = false;\n  private static boolean elapsed = false;\n\n  private int H;\n        private int W;\n        private int K;\n\n  private int score;\n  private void solve(Scanner sc, PrintWriter out) {\n    H = sc.nextInt();\n    W = sc.nextInt();\n    K = sc.nextInt();\n    sc.nextLine();\n\n    int[][] c = new int[H][W];\n    for (int i = 0; i < H; ++i) {\n      String s = sc.nextLine();\n      String[] tokens = s.split(\"\");\n      for (int j = 0; j < W; ++j) {\n        c[i][j] = Integer.parseInt(tokens[j]);\n      }\n    }\n\n    for (int i = 0; i < H; ++i) {\n      for (int j = 0; j < W; ++j) {\n        int[][] cc = copy(c);\n        cc[i][j] = -1;\n        for (int k = i; k > 0; --k) {\n          cc[k][j] = cc[k - 1][j];\n        }\n        cc[0][j] = -2;\n        int scr = check(cc);\n        if (score < scr) {\n          score = scr;\n        }\n      }\n    }\n    out.println(score);\n  }\n  private int[][] copy(int[][] c) {\n    int[][] cc = new int[H][W];\n    for (int i = 0; i < H; ++i) {\n      for (int j = 0; j < W; ++j) {\n        cc[i][j] = c[i][j];\n      }\n    }\n    return cc;\n  }\n  private int check(int[][] c) {\n    int scr = 0;\n    for (int ct = 0; true; ++ct) {\nif (debug) {\n  System.err.println(\"========\");\n  for (int i = 0; i < H; ++i) {\n    for (int j = 0; j < W; ++j) {\n      System.err.print(\" \" + c[i][j]);\n    }\n    System.err.println();\n  }\n}\n\n      int tmp = 0;\n      boolean found1 = false;\n      for (int i = 0; i < H; ++i) {\n        int prev = -1;\n        int cnt = 1;\n        for (int j = 0; j < W; ++j) {\n          if (c[i][j] >= 0 && prev == c[i][j]) {\n            ++cnt;\n          } else if (cnt >= K) {\n            found1 = true;\n            for (int k = j - 1; cnt > 0; --k, --cnt) {\n//System.err.println(\"+1(\" + i + \", \" + k + \")=\" + c[i][k]);\n              tmp += c[i][k];\n              c[i][k] = -1;\n            }\n          }\n          prev = c[i][j];\n        }\n        if (cnt >= K) {\n          found1 = true;\n          for (int k = W - 1; cnt > 0; --k, --cnt) {\n//System.err.println(\"+2(\" + i + \", \" + k + \")=\" + c[i][k]);\n            tmp += c[i][k];\n            c[i][k] = -1;\n          }\n        }\n      }\n\n      if (!found1) {\n        break;\n      }\n//System.err.println(\"tmp[\" + ct + \"]=\" + tmp);\n      scr += (int)(Math.pow(2, ct) * tmp);\n\n      boolean found = true;\n      while (found) {\n        found = false;\n        for (int i = 0; i < H; ++i) {\n          for (int j = 0; j < W; ++j) {\n            if (c[i][j] == -1) {\n              found = true;\n              if (i > 0) {\n                c[i][j] = c[i - 1][j];\n                c[i - 1][j] = -1;\n              } else {\n                c[i][j] = -2;\n              }\n            }\n          }\n        }\n      }\nif (debug) {\n  System.err.println(\"========\");\n  for (int i = 0; i < H; ++i) {\n    System.err.print(\">>\");\n    for (int j = 0; j < W; ++j) {\n      System.err.print(\" \" + c[i][j]);\n    }\n    System.err.println();\n  }\n}\n    }\n    return scr;\n  }\n  /*\n   * 10^10 > Integer.MAX_VALUE = 2147483647 > 10^9\n   * 10^19 > Long.MAX_VALUE = 9223372036854775807L > 10^18\n   */\n  public static void main(String[] args) {\n    long S = System.currentTimeMillis();\n\n    Scanner sc = new Scanner(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n    new Main().solve(sc, out);\n    out.flush();\n\n    long G = System.currentTimeMillis();\n    if (elapsed) {\n      System.err.println((G - S) + \"ms\");\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int h, w, k;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\th = sc.nextInt();\n\t\tw = sc.nextInt();\n\t\tk = sc.nextInt();\n\t\tint[][] c = new int[h][w];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tchar[] line = sc.next().toCharArray();\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tc[i][j] = line[j] - '0';\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\n\t\tint ans = 0;\n\t\tfor (int x = 0; x < h; x++) {\n\t\t\tfor (int y = 0; y < w; y++) {\n\t\t\t\tint[][] c2 = new int[h][w];\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tSystem.arraycopy(c[i], 0, c2[i], 0, w);\n\t\t\t\t}\n\t\t\t\tc2[x][y] = 0;\n\t\t\t\tdrop(c2);\n\t\t\t\tint val = simulate(c2);\n\t\t\t\tans = Math.max(ans, val);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic int simulate(int[][] c) {\n\t\tint ret = 0;\n\t\tint rensa = 0;\n\t\twhile (true) {\n\t\t\tboolean[][] used = new boolean[h][w];\n\t\t\tint val = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tint cnt = 0;\n\t\t\t\tif (c[i][0] != 0) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tfor (int j = 1; j < w; j++) {\n\t\t\t\t\tif (c[i][j] == 0) {\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (c[i][j - 1] == c[i][j]) {\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\tif (cnt == k) {\n\t\t\t\t\t\t\t\tval += cnt * c[i][j];\n\t\t\t\t\t\t\t\tfor (int j2 = j - cnt + 1; j2 <= j; j2++) {\n\t\t\t\t\t\t\t\t\tused[i][j2] = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (cnt > k) {\n\t\t\t\t\t\t\t\tval += c[i][j];\n\t\t\t\t\t\t\t\tused[i][j] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcnt = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (val == 0) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tret += val * 1 << rensa;\n\t\t\trensa++;\n\t\t\tdrop(c, used);\n\t\t}\n\t}\n\n\tstatic void drop(int[][] c, boolean[][] used) {\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (used[i][j]) {\n\t\t\t\t\tc[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdrop(c);\n\t}\n\n\tstatic void drop(int[][] c) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tList<Integer> list = new ArrayList<>();\n\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\tif (c[i][j] != 0) {\n\t\t\t\t\tlist.add(c[i][j]);\n\t\t\t\t\tc[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\t\tc[h - 1 - i][j] = list.get(i);\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n  private static boolean debug = false;\n  private static boolean elapsed = false;\n\n  private int H;\n        private int W;\n        private int K;\n\n  private int score;\n  private void solve(Scanner sc, PrintWriter out) {\n    H = sc.nextInt();\n    W = sc.nextInt();\n    K = sc.nextInt();\n    sc.nextLine();\n\n    int[][] c = new int[H][W];\n    for (int i = 0; i < H; ++i) {\n      String s = sc.nextLine();\n      String[] tokens = s.split(\"\");\n      for (int j = 0; j < W; ++j) {\n        c[i][j] = Integer.parseInt(tokens[j]);\n      }\n    }\n\n    for (int i = 0; i < H; ++i) {\n      for (int j = 0; j < W; ++j) {\n        int[][] cc = copy(c);\n        cc[i][j] = -1;\n        for (int k = i; k > 0; --k) {\n          cc[k][j] = cc[k - 1][j];\n        }\n        cc[0][j] = -2;\n        int scr = check(cc);\n        if (score < scr) {\n          score = scr;\n        }\n      }\n    }\n    out.println(score);\n  }\n  private int[][] copy(int[][] c) {\n    int[][] cc = new int[H][W];\n    for (int i = 0; i < H; ++i) {\n      for (int j = 0; j < W; ++j) {\n        cc[i][j] = c[i][j];\n      }\n    }\n    return cc;\n  }\n  private int check(int[][] c) {\n    int scr = 0;\n    for (int ct = 0; true; ++ct) {\nif (debug) {\n  System.err.println(\"========\");\n  for (int i = 0; i < H; ++i) {\n    for (int j = 0; j < W; ++j) {\n      System.err.print(\" \" + c[i][j]);\n    }\n    System.err.println();\n  }\n}\n\n      int tmp = 0;\n      boolean found1 = false;\n      for (int i = 0; i < H; ++i) {\n        int prev = -1;\n        int cnt = 1;\n        for (int j = 0; j < W; ++j) {\n          if (c[i][j] >= 0 && prev == c[i][j]) {\n            ++cnt;\n          } else if (cnt >= K) {\n            found1 = true;\n            for (int k = j - 1; cnt > 0; --k, --cnt) {\n//System.err.println(\"+1(\" + i + \", \" + k + \")=\" + c[i][k]);\n              tmp += c[i][k];\n              c[i][k] = -1;\n            }\n            cnt = 1;\n          }\n          prev = c[i][j];\n        }\n        if (cnt >= K) {\n          found1 = true;\n          for (int k = W - 1; cnt > 0; --k, --cnt) {\n//System.err.println(\"+2(\" + i + \", \" + k + \")=\" + c[i][k]);\n            tmp += c[i][k];\n            c[i][k] = -1;\n          }\n        }\n      }\n\n      if (!found1) {\n        break;\n      }\n//System.err.println(\"tmp[\" + ct + \"]=\" + tmp);\n      scr += (int)(Math.pow(2, ct) * tmp);\n\n      for (int i = H - 1; i >= 0; --i) {\n        for (int j = 0; j < W; ++j) {\n          if (c[i][j] == -1) {\n            if (i > 0) {\n              int k = i - 1;\n              for (; k > 0 && c[k][j] == -1; --k) {\n              }\n              c[i][j] = c[k][j];\n              c[k][j] = -1;\n            } else {\n              c[i][j] = -2;\n            }\n          }\n        }\n      }\nif (debug) {\n  System.err.println(\"========\");\n  for (int i = 0; i < H; ++i) {\n    System.err.print(\">>\");\n    for (int j = 0; j < W; ++j) {\n      System.err.print(\" \" + c[i][j]);\n    }\n    System.err.println();\n  }\n}\n    }\n    return scr;\n  }\n  /*\n   * 10^10 > Integer.MAX_VALUE = 2147483647 > 10^9\n   * 10^19 > Long.MAX_VALUE = 9223372036854775807L > 10^18\n   */\n  public static void main(String[] args) {\n    long S = System.currentTimeMillis();\n\n    Scanner sc = new Scanner(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n    new Main().solve(sc, out);\n    out.flush();\n\n    long G = System.currentTimeMillis();\n    if (elapsed) {\n      System.err.println((G - S) + \"ms\");\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  static Scanner sc = new Scanner(System.in);\n  static int H, W, K;\n\n  public static void main(String[] args) {\n    H = sc.nextInt();\n    W = sc.nextInt();\n    K = sc.nextInt();\n    int[][] F = new int[H][W];\n    for (int i = 0; i < H; i++) {\n      char[] row = sc.next().toCharArray();\n      for (int j = 0; j < W; j++) {\n        F[i][j] = row[j] - '0';\n      }\n    }\n    int ans = 0;\n    for (int i = 0; i < H; i++) {\n      for (int j = 0; j < W; j++) {\n        Board b = new Board(F);\n        ans = Math.max(ans, b.simulate(i, j));\n      }\n    }\n    System.out.println(ans);\n  }\n\n  static class Board {\n    int[][] f;\n\n    Board(int[][] o) {\n      this.f = new int[H][];\n      for (int i = 0; i < H; i++) {\n        this.f[i] = o[i].clone();\n      }\n    }\n\n    int simulate(int r, int c) {\n      int score = 0;\n      boolean[][] vanished = new boolean[H][W];\n      vanished[r][c] = true;\n      for (int i = 0; ; i++) {\n        int sum = fall(vanished);\n        if (i > 0) score += sum << (i - 1);\n        if (!erase(vanished)) break;\n      }\n//      System.out.println(r + \" \" + c + \" \" + score);\n      return score;\n    }\n\n    int fall(boolean[][] vanished) {\n      int sum = 0;\n      for (int i = 0; i < W; i++) {\n        int to = H - 1;\n        for (int j = H - 1; j >= 0; j--) {\n          if (vanished[j][i]) {\n            sum += f[j][i];\n            continue;\n          }\n          f[to--][i] = f[j][i];\n        }\n        for (int j = to; j >= 0; j--) {\n          f[j][i] = -1;\n        }\n      }\n      return sum;\n    }\n\n    boolean erase(boolean[][] vanished) {\n      boolean any = false;\n      for (int i = 0; i < H; i++) {\n        Arrays.fill(vanished[i], false);\n        int start = 0;\n        for (int j = 1; j < W; j++) {\n          if (f[i][j] != f[i][j - 1] || f[i][j] == -1) {\n            start = j;\n          } else {\n            if (j - start + 1 >= K) {\n              for (int k = start; k <= j; k++) {\n                vanished[i][k] = true;\n                any = true;\n              }\n            }\n          }\n        }\n      }\n\n      return any;\n    }\n\n  }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tprivate static final int MOD = 1000000007;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint H = sc.nextInt();\n\t\tint W = sc.nextInt();\n\t\tint K = sc.nextInt();\n\n\t\tint[][] board = new int[H][W + 1];\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tchar[] chars = sc.next().toCharArray();\n\t\t\tfor (int j = 0; j < chars.length; j++) {\n\t\t\t\tboard[H - i - 1][j] = chars[j] - '0';\n\t\t\t}\n\t\t\tboard[H - 1 - 1][W] = 0;\n\t\t}\n\n\t\tlong score = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tscore = Math.max(score, getScore(board, K, i, j));\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(score);\n\t}\n\n\tprivate static void drop(int[][] board) {\n\t\tint[] now = new int[board[0].length];\n\t\tfor (int i = 0; i < board.length; i++) {\n\t\t\tfor (int j = 0; j < board[i].length; j++) {\n\t\t\t\tboolean found = false;\n\t\t\t\tfor (int k = now[j]; k < board.length; k++) {\n\t\t\t\t\tif (board[k][j] != -1) {\n\t\t\t\t\t\tnow[j] = k;\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (found) {\n\t\t\t\t\tboard[i][j] = board[now[j]][j];\n\t\t\t\t\tnow[j]++;\n\t\t\t\t} else {\n\t\t\t\t\tboard[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void debug(int[][] board) {\n\t\tfor (int i = 0; i < board.length; i++) {\n\t\t\tSystem.err.println(Arrays.toString(board[i]));\n\t\t}\n\t\tSystem.err.println();\n\t}\n\n\tprivate static long getScore(int[][] source, int minLength, int y, int x) {\n\t\tint[][] board = new int[source.length][];\n\t\tfor (int i = 0; i < source.length; i++) {\n\t\t\tboard[i] = Arrays.copyOf(source[i], source[i].length);\n\t\t}\n\n\t\tboard[y][x] = -1;\n\t\tdrop(board);\n\n\t\tint step = 0;\n\t\tlong score = 0;\n\t\twhile (true) {\n\t\t\tboolean found = false;\n\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 0; i < board.length; i++) {\n\t\t\t\tint prev = board[i][0];\n\t\t\t\tint length = 1;\n\t\t\t\tfor (int j = 1; j < board[i].length; j++) {\n\t\t\t\t\tif (prev != 0 && prev == board[i][j]) {\n\t\t\t\t\t\tlength++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (length >= minLength) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tsum += prev * length;\n\t\t\t\t\t\t\tArrays.fill(board[i], j - length, j, -1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprev = board[i][j];\n\t\t\t\t\t\tlength = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tscore += Math.pow(2, step) * sum;\n\t\t\tstep++;\n\n\t\t\tif (!found) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdrop(board);\n\t\t}\n\n\t\treturn score;\n\t}\n\n\tpublic static class Scanner {\n\t\tprivate BufferedInputStream inputStream;\n\n\t\tpublic Scanner(InputStream in) {\n\t\t\tinputStream = new BufferedInputStream(in);\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\tint num = 0;\n\t\t\tint sign = 1;\n\n\t\t\tint read = skip();\n\t\t\tif (read == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tread = inputStream.read();\n\t\t\t}\n\n\t\t\tdo {\n\t\t\t\tnum = num * 10 + sign * (read - 0x30);\n\t\t\t} while ((read = inputStream.read()) > 0x20);\n\n\t\t\treturn num;\n\t\t}\n\n\t\tpublic void fill(int[] a) throws IOException {\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\ta[i] = nextInt();\n\t\t\t}\n\t\t}\n\n\t\tpublic void fill(int[] a, int[] b) throws IOException {\n\t\t\tif (a.length != b.length) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\ta[i] = nextInt();\n\t\t\t\tb[i] = nextInt();\n\t\t\t}\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\tlong num = 0;\n\t\t\tint sign = 1;\n\n\t\t\tint read = skip();\n\t\t\tif (read == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tread = inputStream.read();\n\t\t\t}\n\n\t\t\tdo {\n\t\t\t\tnum = num * 10 + sign * (read - 0x30);\n\t\t\t} while ((read = inputStream.read()) > 0x20);\n\n\t\t\treturn num;\n\t\t}\n\n\t\tpublic void fill(long[] a) throws IOException {\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\ta[i] = nextLong();\n\t\t\t}\n\t\t}\n\n\t\tpublic void fill(long[] a, long[] b) throws IOException {\n\t\t\tif (a.length != b.length) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\ta[i] = nextLong();\n\t\t\t\tb[i] = nextLong();\n\t\t\t}\n\t\t}\n\n\t\tpublic long[] nextLong(int n) throws IOException {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarray[i] = nextLong();\n\t\t\t}\n\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tStringBuilder builder = new StringBuilder();\n\n\t\t\tint read = skip();\n\t\t\tdo {\n\t\t\t\tbuilder.append((char) read);\n\t\t\t} while ((read = inputStream.read()) > 0x20);\n\n\t\t\treturn builder.toString();\n\t\t}\n\n\t\tprivate int skip() throws IOException {\n\t\t\tint read;\n\t\t\twhile ((read = inputStream.read()) <= 0x20)\n\t\t\t\t;\n\n\t\t\treturn read;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tstatic int c[][];\n\tstatic int origin_c[][];\n\tstatic int H;\n\tstatic int W;\n\tstatic int K;\n\tstatic int max_score=0;\n\tstatic List<List<Integer>> empty_zahyou = new ArrayList<>();\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tH = sc.nextInt();\n\t\tW = sc.nextInt();\n\t\tK = sc.nextInt();\n\n\t\tc=new int[H][W];\n\t\torigin_c=new int[H][W];\n\n\t\tfor(int i=0;i<H;i++) {\n\t\t\tlong num = sc.nextLong();\n\t\t\tfor(int j=W-1;j>-1;j--) {\n\t\t\t\tc[i][j]=(int)num%10;\n\t\t\t\tnum = num / 10;\n\t\t\t}\n\t\t}\n\t\tarray_copy(origin_c,c);\n//\t\tint h =4-1;\n//\t\tint w =3-1;\n//\t\tslide(h,w);\n//\t\th =3-1;\n//\t\tw =3-1;\n//\t\tslide(h,w);\n\n\t\tfor(int i=0;i<H;i++) {\n\t\t\tfor(int j=0;j<W;j++) {\n\n\t\t\t}\n\t\t}\n\n\t\tint score=0;\n\t\tint del_count=0;\n\t\tfor(int i=0;i<H;i++) {\n\t\t\tfor(int j=0;j<W;j++) {\n\t\t\t\tslide(i,j);\n\t\t\t\tscore+=del(0);//この関数がうまく動作するか調べる。\n\t\t\t\tdel_count+=1;\n\t\t\t\twhile(empty_zahyou.size()!=0) {\n\t\t\t\t\tfor(List<Integer> zahyou: empty_zahyou) {\n\t\t\t\t\t\tint h=zahyou.get(0);\n\t\t\t\t\t\tint w=zahyou.get(1);\n\t\t\t\t\t\tslide(h,w);\n\t\t\t\t\t}\n\t\t\t\t\tempty_zahyou.clear();\n\t\t\t\t\tscore+=del(del_count);\n\t\t\t\t\tdel_count+=1;\n\t\t\t\t}\n\t\t\t\tif(score>max_score) {\n\t\t\t\t\tmax_score=score;\n\t\t\t\t}\n\t\t\t\tscore=0;\n\t\t\t\tdel_count=0;\n\t\t\t\tarray_copy(c,origin_c);\n\t\t\t}\n\t\t}\n\n\t\t//(4,3)を消す例題\n//\t\tint i=4-1;\n//\t\tint j=3-1;\n//\t\tslide(i,j);\n//\t\tscore+=del(0);//この関数がうまく動作するか調べる。\n//\t\tdel_count+=1;\n//\t\twhile(empty_zahyou.size()!=0) {\n//\t\t\tfor(List<Integer> zahyou: empty_zahyou) {\n//\t\t\t\tint h=zahyou.get(0);\n//\t\t\t\tint w=zahyou.get(1);\n//\t\t\t\tslide(h,w);\n//\t\t\t}\n//\t\t\tempty_zahyou.clear();\n//\t\t\tscore+=del(del_count);\n//\t\t\tdel_count+=1;\n//\t\t}\n//\t\tif(score>max_score) {\n//\t\t\tmax_score=score;\n//\t\t}\n//\t\tscore=0;\n//\t\tdel_count=0;\n\n\t\tSystem.out.println(max_score);\n\t\tsc.close();\n\n\t}\n\t//空きマスを埋める関数\n\tpublic static void slide(int h,int w) {\n\t\tint i = h;\n\t\twhile(i>0 && c[i-1][w]!=-1) {\n\t\t\tc[i][w] = c[i-1][w];\n\t\t\ti--;\n\t\t}\n\t\tc[i][w]=-1;\n\t}\n\n\t//現在の盤面から削除できるマスを消す\n\tpublic static int del(int del_count) {\n\t\tint score=0;\n\t\tint count=1;\n\t\tint x_start=0;\n\t\tint cur_x=0;\n\t\tfor(int i=0;i<H;i++) {\n\t\t\tif(count>=K) {\n\t\t\t\tfor(int x=x_start;x<cur_x+1;x++) {\n\t\t\t\t\tempty_zahyou.add(new ArrayList<Integer>(Arrays.asList(i-1,x)));\n\t\t\t\t}\n\t\t\t\tscore+=(int) Math.pow(2, del_count) * c[i-1][cur_x-1]*count;\n\t\t\t}\n\t\t\tcount=1;\n\t\t\tx_start=0;\n\t\t\tcur_x=0;\n\t\t\twhile(cur_x<W-1) {\n\t\t\t\tif(c[i][cur_x]==c[i][cur_x+1] && c[i][cur_x]!=-1) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(count>=K) {\n\t\t\t\t\t\tfor(int x=x_start;x<cur_x+1;x++) {\n\t\t\t\t\t\t\tempty_zahyou.add(new ArrayList<Integer>(Arrays.asList(i,x)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tscore+=(int) Math.pow(2, del_count) * c[i][cur_x]*count;\n\t\t\t\t\t}\n\t\t\t\t\tx_start=cur_x+1;\n\t\t\t\t\tcount=1;\n\t\t\t\t}\n\t\t\t\tcur_x++;\n\t\t\t}\n\t\t}\n\t\tif(count>=K) {\n\t\t\tfor(int x=x_start;x<cur_x+1;x++) {\n\t\t\t\tempty_zahyou.add(new ArrayList<Integer>(Arrays.asList(H-1,x)));\n\t\t\t}\n\t\t\tscore+=(int) Math.pow(2, del_count) * c[H-1][cur_x]*count;\n\t\t}\n\t\treturn score;\n\t}\n\n\tpublic static void array_copy(int[][] dst, int[][] src) {\n\t\tfor(int i=0;i<H;i++) {\n\t\t\tfor(int j=0;j<W;j++) {\n\t\t\t\tdst[i][j] = src[i][j];\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tInputStream in = System.in;\n\tPrintStream out = System.out;\n\n\tint countLeft(int[] arr, int idx) {\n\t\tint res = 0;\n\t\tfor(int i=idx-1;i>=0;i--) {\n\t\t\tif(arr[idx] == arr[i]) {\n\t\t\t\tres++;\n\t\t\t}else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tint countRight(int[] arr, int idx) {\n\t\tint res = 0;\n\t\tfor(int i=idx+1;i<arr.length;i++) {\n\t\t\tif(arr[idx] == arr[i]) {\n\t\t\t\tres++;\n\t\t\t}else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tlong solv(int[][] c) {\n\t\tlong score = 0;\n\t\t\n\t\tfor(long i=-1;;i++) {\n//\t\t\tSystem.err.println(\"(\" + i + \")\");\n\t\t\tlong tempScore = 0;\n\t\t\t// 消滅\n\t\t\tfor(int h=0;h<H;h++) {\n\t\t\t\tint[] nl = Arrays.copyOf(c[h], c[h].length);\n\t\t\t\tfor(int w=0;w<W;w++) {\n\t\t\t\t\tif(countLeft(c[h],w) + countRight(c[h],w) + 1 >= K) {\n\t\t\t\t\t\ttempScore += c[h][w];\n\t\t\t\t\t\tnl[w] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc[h] = nl;\n\t\t\t}\n\t\t\t\n\t\t\tif(i > 0 && tempScore == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n//\t\t\tSystem.err.println(tempScore + \" * \" + \"2^\" + i);\n\t\t\tscore += tempScore*Math.pow(2, i);\n\t\t\t\n\t\t\t// 落下\n\t\t\tfor(int w=0;w<W;w++) {\n\t\t\t\tint b = H-1, t = H-1;\n\t\t\t\twhile(true) {\n\t\t\t\t\twhile(b >= 0 && c[b][w] != 0) b--;\n\t\t\t\t\tt=b-1;\n\t\t\t\t\twhile(t >= 0 && c[t][w] == 0) t--;\n\t\t\t\t\t\n\t\t\t\t\tif(b<0 || t <0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tc[b][w] = c[t][w];\n\t\t\t\t\tc[t][w] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\tSystem.err.println(\"--\" + i);\n//\t\t\tfor(int h=0;h<H;h++) {\n//\t\t\t\tSystem.err.println(Arrays.toString(c[h]));\n//\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn score;\n\t}\n\tint H,W,K;\n\t\n\tpublic void _main(String[] args) {\n\t\tScanner sc = new Scanner(in);\n\n\t\tH = sc.nextInt();\n\t\tW = sc.nextInt();\n\t\tK = sc.nextInt();\n\n\n\t\tint[][] c = new int[H][W];\n\t\tfor(int i=0;i<H;i++) {\n\t\t\tString s = sc.next();\n\t\t\tfor(int j=0;j<W;j++) {\n\t\t\t\tc[i][j] = s.charAt(j)-'0';\n\t\t\t}\n\t\t}\n\t\t\n\t\tsc.close();\n\n\t\tlong ans = 0;\n\n\t\tfor(int i=0;i<H;i++) {\n\t\t\tfor(int j=0;j<W;j++) {\n\t\t\t\tint[][] d = copyOf(c);\n\t\t\t\td[i][j] = 0;\n\t\t\t\tlong a = solv(d);\n//\t\t\t\tSystem.err.println(i + \",\" + j + \"\\t\" + a);\n\t\t\t\tans = Math.max(ans, a);\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(ans);\n\t}\n\n\tprivate int[][] copyOf(int[][] a){\n\t\tint[][] r = new int[a.length][];\n\t\tfor(int i=0;i<a.length;i++) {\n\t\t\tr[i] = Arrays.copyOf(a[i], a[i].length);\n\t\t}\n\t\treturn r;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main()._main(args);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate String join(String delimiter, int[] a) {\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tsb.append(a[i]);\n\t\t\tsb.append(delimiter);\n\t\t}\n\t\treturn sb.substring(0, Math.max(sb.length() - delimiter.length(), 0));\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate String join(String delimiter, long[] a) {\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tsb.append(a[i]);\n\t\t\tsb.append(delimiter);\n\t\t}\n\t\treturn sb.substring(0, Math.max(sb.length() - delimiter.length(), 0));\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate int max(int[] arr) {\n\t\tif(arr == null || arr.length == 0) {\n\t\t\tthrow new IllegalArgumentException(Arrays.toString(arr));\n\t\t}\n\n\t\tint candidate = arr[0];\n\t\tfor(int i=1;i<arr.length;i++) {\n\t\t\tcandidate = candidate > arr[i] ? candidate : arr[i];\n\t\t}\n\t\treturn candidate;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate long max(long[] arr) {\n\t\tif(arr == null || arr.length == 0) {\n\t\t\tthrow new IllegalArgumentException(Arrays.toString(arr));\n\t\t}\n\n\t\tlong candidate = arr[0];\n\t\tfor(int i=1;i<arr.length;i++) {\n\t\t\tcandidate = candidate > arr[i] ? candidate : arr[i];\n\t\t}\n\t\treturn candidate;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate int min(int[] arr) {\n\t\tif(arr == null || arr.length == 0) {\n\t\t\tthrow new IllegalArgumentException(Arrays.toString(arr));\n\t\t}\n\n\t\tint candidate = arr[0];\n\t\tfor(int i=1;i<arr.length;i++) {\n\t\t\tcandidate = candidate < arr[i] ? candidate : arr[i];\n\t\t}\n\t\treturn candidate;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate long min(long[] arr) {\n\t\tif(arr == null || arr.length == 0) {\n\t\t\tthrow new IllegalArgumentException(Arrays.toString(arr));\n\t\t}\n\n\t\tlong candidate = arr[0];\n\t\tfor(int i=1;i<arr.length;i++) {\n\t\t\tcandidate = candidate < arr[i] ? candidate : arr[i];\n\t\t}\n\t\treturn candidate;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate int[] nextIntArray(Scanner sc, int n) {\n\t\tint[] result = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tresult[i] = sc.nextInt();\n\t\t}\n\t\treturn result;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate long[] nextLongArray(Scanner sc, int n) {\n\t\tlong[] result = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tresult[i] = sc.nextLong();\n\t\t}\n\t\treturn result;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate int[] nextIntArray1origin(Scanner sc, int n) {\n\t\tint[] result = new int[n + 1];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tresult[i] = sc.nextInt();\n\t\t}\n\t\treturn result;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic int[][] X;\n\tstatic int[][] x;\n\tstatic int combo = 0;\n\tstatic int h; \n\tstatic int w;\n\tstatic int k;\n\tstatic int p;\n\tstatic int point;\n\tpublic static void main(String[] args) throws Exception{\t\n\t\tFastScanner sc = new FastScanner();\n\t\tint i, j;\n\t\t\t//code\n\t\t\n\t\th = sc.nextInt();\n\t\tw = sc.nextInt();\n\t\tk = sc.nextInt();\n\t\t\n\t\tX = new int[h][w];\n\t\tx = new int[h][w];\n\t\tString tmp = new String();\n\t\tfor(i=0; i<h; i++){\n\t\t\ttmp = sc.next();\n\t\t\tfor(j=0; j<w; j++){\n\t\t\t\tX[i][j] = Integer.parseInt(tmp.substring(j, j+1));\n\t\t\t}\n\t\t}\n\n\t\t\n\t\t\n\t\tint P=0;\n\t\t\n\t\tfor(i=0; i<w; i++){\n\t\t\tresetx();\n\t\t\t\n\t\t\tdel(i);\n\t\t\twhile(true){\n\t\t\t\tif(chk() == 1){\n\t\t\t\t\tdel_a();\n\t\t\t\t}else{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(point > P){\n\t\t\t\tP = point;\n\t\t\t}\n\t\t\tpoint = 0;\n\t\t\tcombo = 0;\n\t\t}\n\t\t\n\t\tpl(P);\n\t\t\n\t\t\n\t\n\t}\n\t\n\tstatic void del(int wx){\n\t\tfor(int i=h-1; i>0; i--){\n\t\t\tx[i][wx] = x[i-1][wx];\n\t\t}\n\t\tx[0][wx] = -1;\n\t}\n\t\n\tstatic int chk(){\n\t\tp=0;\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w-k+1; j++){\n\t\t\t\tint n=1;\n\t\t\t\tif(x[i][j] != -1){\n\t\t\t\t\tfor(int l=0; l<w; l++){\n\t\t\t\t\t\tif(j+1+l >= w) break;\n\t\t\t\t\t\tif(x[i][j+l] == x[i][j+1+l]){\n\t\t\t\t\t\t\tn++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t\tif(n >= k){\n\t\t\t\t\t\tp += x[i][j] * n;\n\t\t\t\t\t\tfor(int l=j; l<j+n; l++){\n\t\t\t\t\t\t\tx[i][l] = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(p == 0) return 0;\n\t\t\n\t\tpoint += Math.pow(2, combo++) * p;\n\t\treturn 1;\n\t}\n\t\n\tstatic void del_a(){\n\t\tfor(int i=h-1; i>0; i--){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tif(x[i][j] == -1){\n\t\t\t\t\tint n=0;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tif(i-1-n < 1) break;\n\t\t\t\t\t\tif(x[i-1-n][j] == -1) n++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t\tx[i][j] = x[i-1-n][j];\n\t\t\t\t\tx[i-1-n][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void resetx(){\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tx[i][j] = X[i][j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void showx(){\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tp(\" \" + x[i][j]);\n\t\t\t}\n\t\t\tpl(\"\");\n\t\t}\n\t\tpl(\"\\n\\n\\n\");\n\t}\n\t\n\tstatic void p(String s){ System.out.print(s); }\n\tstatic void pl(String s){ System.out.println(s); }\n\tstatic void p(int s){ System.out.print(s); }\n\tstatic void pl(int s){ System.out.println(s); }\n\tstatic void p(long s){ System.out.print(s); }\n\tstatic void pl(long s){ System.out.println(s); }\n\tstatic void p(double s){ System.out.print(s); }\n\tstatic void pl(double s){ System.out.println(s); }\n\tstatic void p(boolean s){ System.out.print(s); }\n\tstatic void pl(boolean s){ System.out.println(s); }\n\t\n\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    \n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\n\t\npublic class Main {\n    \n    static class Graph0n {\n        private ArrayList<Node0n> dt = new ArrayList<>();\n        Graph0n(int sz){\n\t   \t    for(int i=0; i<sz; i++){\n\t   \t        Node0n node1 = new Node0n();\n\t   \t        dt.add(node1);\n\t   \t    }\n        }\n        public void add(int vn, int val){       dt.get(vn).add(val);                }\n        public int get(int vn, int index){      return dt.get(vn).get(index);       }\n        public ArrayList<Integer> get(int vn){  return dt.get(vn).getAll();         }\n        public int sizeOf(int vn){              return dt.get(vn).size();           }\n        public void clear(){    for(int i=0; i<dt.size(); i++){ dt.get(i).clear();  }   }\n    }\n    \n    static class Node0n {   //重みなし無向グラフの頂点\n        private ArrayList<Integer> next_vs = new ArrayList<>();\n        \n        public void add(int val){               next_vs.add(val);       }\n        public int get(int ad){                 return next_vs.get(ad); }\n        public ArrayList<Integer> getAll(){     return next_vs;         }\n        public int size(){                      return next_vs.size();  }\n        public void clear(){                    next_vs.clear();        }\n    }\n\n    static class Edge {\n        int from=-1, v2=-1;     long weight;\n        public Edge(int vn, long w){\n            this.v2 = vn;\n            this.weight = w;\n        }\n        public Edge(int cm, int vn, long w){\n            this.from = cm;\n            this.v2 = vn;\n            this.weight = w;\n        }\n    }\n    static class Edge2 {\n        int v2;     long cost1,cost2;\n        public Edge2(int vn, long w1, long w2){\n            this.v2 = vn;\n            this.cost1 = w1;\n            this.cost2 = w2;\n        }\n    }\n\n    static class Comparator_Edge implements Comparator<Edge>{\n        public int compare(Edge a, Edge b){\n            if(a.weight>b.weight) return 1;\n            else if(a.weight<b.weight) return -1;\n            else return 0;\n        }\n    }\n    \n\tpublic static void main(String[] args) throws Exception {\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint h = sc.nexI();\n\t\tint w = sc.nexI();\n\t\tint s2da = sc.nexI();\n\t\t\n\t\tint[][] dt1st = new int[h][w];\n\t\t\n\t   \tfor(int i=0; i<h; i++){\n\t   \t    String line = sc.next();\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t    dt1st[i][j] = line.charAt(j)-48;\n\t\t\t}\n\t   \t}\n\t\t\n\t\tlong ans=0, score=0, sum_now=0;\n\t\t\n\t   \tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t    int[][] dt = new int[h][w];\n\t\t\t\tfor(int k=0; k<h; k++){\n\t\t\t\t    dt[k] = dt1st[k].clone();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdt[i][j] = 0;\n\t\t\t\tfall_stone(dt);\n\t\t\t\t\n\t\t\t\tscore=0;\n\t\t\t\tint t=0;\n\t\t\t\tboolean dappear_happened = true;\n\t\t\t\twhile(dappear_happened){\n\t\t\t\t    sum_now=0;\n\t\t\t\t    dappear_happened=false;\n\t\t\t\t    for(int k=0; k<h; k++){\n\t\t\t\t        int skind=dt[k][0];\n\t\t\t\t        int spos=0;\n\t\t\t\t        boolean is_over=false;\n\t\t\t\t        for(int x=1; x<w; x++){\n\t\t\t\t            if(skind == dt[k][x]){\n\t\t\t\t                if(((x-spos+1) == s2da)&&(skind>0)){\n\t\t\t\t                    is_over=true;\n\t\t\t\t                    dappear_happened=true;\n\t   \t                            for(int x1=spos; x1<x; x1++){\n\t   \t                                sum_now+=skind;\n\t   \t                                dt[k][x1]=0;\n\t   \t                            }\n\t\t\t\t                }\n   \t                            if(is_over){\n   \t                                sum_now+=skind;\n   \t                                dt[k][x]=0;\n   \t                            }\n\t\t\t\t            }else{\n\t\t\t\t                skind=dt[k][x];\n\t\t\t\t                spos=x;\n\t\t\t\t                is_over=false;\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t        //各行ごとの消える処理\n\t\t\t\t    }\n\t\t\t\t    \n\t\t\t\t    //show2(dt,\"h\");\n\t\t\t\t    //System.out.println();\n\t\t\t\t    \n\t\t\t\t    fall_stone(dt);\n\t\t\t\t    \n\t\t\t\t    sum_now *= Math.pow(2,t);\n\t\t\t\t    score += sum_now;\n\t\t\t\t    t++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, score);\n\t\t\t}\n\t   \t}\n\t\t\n\t\tout.println(ans);\n\t\tout.flush();\n\t}\n\t\n\tprivate static void fall_stone(int[][] dthw){\n\t    int h = dthw.length;\n\t    for(int i=0; i<dthw[0].length; i++){\n\t   \t    List<Integer> falls = new ArrayList<>();\n\t\t\tfor(int j=h-1; j>=0; j--){\n\t\t\t    if(dthw[j][i] > 0){\n\t\t\t        falls.add(dthw[j][i]);\n\t\t\t        dthw[j][i]=0;\n\t\t\t    }\n\t\t\t}\n\t\t\tfor(int j=h-1; j>=(h-falls.size()); j--){\n\t\t\t    dthw[j][i] = falls.get(h-j-1);\n\t\t\t}\n\t   \t}\n\t   \treturn;\n\t}\n\t\n\tprivate static int INF = (int)1e8;\n\tprivate static long INFL = (long)1e17;\n\tprivate static long e97 = (long)1e9 + 7;\n\t\n\t\n\tprivate static int abs(int a){  return (a>=0) ? a: -a;  }\n\tprivate static long abs(long a){    return (a>=0) ? a: -a;  }\n\tprivate static double abs(double a){    return (a>=0) ? a: -a;  }\n\t\n\tprivate static int min(int a, int b){   return (a>b) ? b : a;   }\n\tprivate static long min(long a, long b){    return (a>b) ? b : a;   }\n\tprivate static double min(double a, double b){    return (a>b) ? b : a;   }\n\t\n\tprivate static int max(int a, int b){   return (a>b) ? a : b;   }\n\tprivate static long max(long a, long b){    return (a>b) ? a : b;   }\n\tprivate static double max(double a, double b){    return (a>b) ? a : b;   }\n\t\n\tprivate static int minN(int... ins){\n\t\tint min = ins[0];\n\t\tfor(int i=1; i<ins.length; i++){    if(ins[i] < min) min = ins[i];  }\n\t\treturn min;\n\t}\n\tprivate static int maxN(int... ins){\n\t\tint max = ins[0];\n\t\tfor(int i=1; i<ins.length; i++){    if(ins[i] > max) max = ins[i];  }\n\t\treturn max;\n\t}\n\tprivate static long minN(long... ins){\n\t\tlong min = ins[0];\n\t\tfor(int i=1; i<ins.length; i++){    if(ins[i] < min) min = ins[i];  }\n\t\treturn min;\n\t}\n\tprivate static long maxN(long... ins){\n\t\tlong max = ins[0];\n\t\tfor(int i=1; i<ins.length; i++){    if(ins[i] > max) max = ins[i];  }\n\t\treturn max;\n\t}\n\t\n\tprivate static int minExAd(int[] dt, int ad){\n\t    int min=Integer.MAX_VALUE;\n\t\tfor(int i=0; i<dt.length; i++){ if((i != ad) && (dt[i] < min)) min = dt[i]; }\n\t\treturn min;\n\t}\n\tprivate static long minExAd(long[] dt, int ad){\n\t    long min=Long.MAX_VALUE;\n\t\tfor(int i=0; i<dt.length; i++){ if((i != ad) && (dt[i] < min)) min = dt[i]; }\n\t\treturn min;\n\t}\n\tprivate static int minExVal(int[] dt, int ex_val){\n\t    int min=Integer.MAX_VALUE;\n\t\tfor(int i=0; i<dt.length; i++){ if((dt[i] != ex_val) && (dt[i] < min)) min = dt[i]; }\n\t\treturn min;\n\t}\n\tprivate static long minExVal(long[] dt, long ex_val){\n\t    long min=Long.MAX_VALUE;\n\t\tfor(int i=0; i<dt.length; i++){ if((dt[i] != ex_val) && (dt[i] < min)) min = dt[i]; }\n\t\treturn min;\n\t}\n\t\n\tprivate static boolean same3(long a, long b, long c){\n    \tif(a!=b) return false;\n    \tif(b!=c) return false;\n    \tif(c!=a) return false;\n    \treturn true;\n\t}\n\tprivate static boolean dif3(long a, long b, long c){\n    \tif(a==b) return false;\n    \tif(b==c) return false;\n    \tif(c==a) return false;\n    \treturn true;\n\t}\n\t\n\tprivate static double hypod(double a, double b){\n\t    return Math.sqrt(a*a+b*b);\n\t}\n\t\n\tprivate static int factorial(int n) {\n\t\tint ans=1;\n\t\tfor(int i=n; i>0; i--){ ans*=i; }\n\t\treturn ans;\n\t}\n\t\n\tprivate static long gcd(long m, long n) {\n\t\tif(m < n) return gcd(n, m);\n\t\tif(n == 0) return m;\n\t\treturn gcd(n, m % n);\n\t}\n\t\n\tprivate static boolean is_prime(long a){\n\t    if(a==1) return false;\n\t    for(int i=2; i<=Math.sqrt(a); i++){  if(a%i == 0) return false;  }\n\t    return true;\n\t}\n\t\n    private static long modinv(long a, long m) {    //a|m, >1に注意\n        long b = m, u = 1, v = 0;\n        while (b>0) {\n            long t = a / b;\n            long pe = a%b;\n            a=b;    b=pe;\n            pe= u-t*v;\n            u=v;    v=pe;\n        }\n        u %= m; \n        if (u < 0) u += m;\n        return u;\n    }\n    \n    private static long[] fac10E97 = null;\n    private static long[] finv10E97 = null;\n    private static void Cinit(int max_sz, long p){\n        fac10E97 = new long[max_sz+1];\n        finv10E97 = new long[max_sz+1];\n        fac10E97[0]=1;\n        finv10E97[0]=1;\n        for(int i=1; i<=max_sz; i++){\n            fac10E97[i] = (fac10E97[i-1]*i) % p;\n        }\n        finv10E97[max_sz] = modinv(fac10E97[max_sz], p);\n\t\tfor(int i=max_sz; i>1; i--){\n\t\t    finv10E97[i-1] = (finv10E97[i]*i) % p;\n\t\t}\n    }\n    \n    private static long C10e97(int n, int k, long p){\n        long ans = fac10E97[n];\n        ans *= finv10E97[k];\n        ans %= p;\n        ans *= finv10E97[n-k];\n        ans %=p;\n        if(ans<0) return ans+p;\n        else return ans;\n    }\n\t\n\tprivate static int pow2(int in){            return in*in;   }\n\tprivate static long pow2(long in){          return in*in;   }\n\tprivate static double pow2(double in){      return in*in;   }\n\t\n\tprivate static int getDigit2(long num){\n\t\tlong cf = 1;    int d=0;\n\t\twhile(num >= cf){   d++;    cf = 1<<d;  }\n\t\treturn d; //numはd桁の数で、2^dより小さい\n\t}\n\t\n\tprivate static int getDigit10(long num){\n\t\tlong cf = 1;    int d=0;\n\t\twhile(num >= cf){   d++;    cf*=10;     }\n\t\treturn d; //numはd桁の数で、10^dより小さい\n\t}\n\t\n\tprivate static boolean isINF(int in){\n    \tif(((long)in*20)>INF) return true;\n    \telse return false;\n\t}\n\tprivate static boolean isINFL(long in){\n    \tif((in*10000)>INFL) return true;\n    \telse return false;\n\t}\n\t\n\tprivate static long pow10E97(long ob, long soeji, long p){\n\t    if(ob==0) return 0;\n\t    if(soeji==0) return 1;\n\t\tif(soeji==2) return (ob*ob)%p;\n\t\t\n\t\tint d = getDigit2(soeji);\n\t\tlong[] ob_pow_2pow = new long[d];\n\t\t\n\t\tob_pow_2pow[0] = ob;\n\t\tfor(int i=1; i<d; i++){ ob_pow_2pow[i] = (ob_pow_2pow[i-1]*ob_pow_2pow[i-1])%p;   }\n\t\t\n\t\tlong ans=1;\n\t\tfor(int i=d-1; i>=0; i--){\n\t\t\tif(soeji >= (long)(1<<i)){\n\t\t\t\tsoeji -= (long)(1<<i);\n\t\t\t\tans = (ans*ob_pow_2pow[i])%p;\n\t\t\t}\n \t\t}\n\t\treturn ans;\n\t}\n\t\n\t\n\tprivate static int flag(int pos){               return (1<<pos);        }\n\tprivate static boolean isFlaged(int bit, int pos){\n    \tif((bit&(1<<pos)) > 0) return true;\n    \telse return false;\n\t}\n\tprivate static int deflag(int bit, int pos){    return bit&~(1<<pos);   }\n\t\n\tprivate static void showflag(int bit){\n    \tfor(int i=0; i<getDigit2(bit); i++){\n        \tif(isFlaged(bit,i)) System.out.print(\"O\");\n        \telse System.out.print(\".\");\n    \t}\n\t}\n\t\n\tpublic static int biSearch(int[] dt, int target){\n\t\tint left=0, right=dt.length-1;\n\t\tint mid=-1;\n\t\twhile(left<=right){\n\t\t\tmid = (right+left)/2;\n\t\t\tif(dt[mid] == target) return mid;\n\t\t\tif(dt[mid] < target) left=mid+1;\n\t\t\telse right=mid-1;\n\t\t}\n\t\treturn -1;\n\t}\n\tpublic static int biSearchMax(long[] dt, long target){\n\t\tint left=-1, right=dt.length;\n\t\tint mid=-1;\n\t\t\n\t\twhile((right-left)>1){\n\t\t\tmid = left + (right-left)/2;\n\t\t\tif(dt[mid] < target) left=mid;\n\t\t\telse right=mid;\n\t\t}\n\t\treturn left;//target未満の最大のaddress\n\t}\n\tpublic static int biSearchMaxAL(ArrayList<Integer> dt, long target){\n\t\tint left=-1, right=dt.size();\n\t\tint mid=-1;\n\t\t\n\t\twhile((right-left)>1){\n\t\t\tmid = left + (right-left)/2;\n\t\t\tif(dt.get(mid) < target) left=mid;\n\t\t\telse right=mid;\n\t\t}\n\t\treturn left;//target未満の最大のaddress\n\t}\n\t\n    private static int get_root_uf(int[] parent, int index){\n        if(parent[index] == index) return index;\n        int root = get_root_uf(parent, parent[index]);\n        parent[index] = root;\n        return root;\n    }\n    \n    private static boolean is_same_uf(int[] parent, int x, int y){\n        if(get_root_uf(parent,x) == get_root_uf(parent,y)) return true;\n        else return false;\n    }\n    \n    private static void unite_uf(int[] parent, int receiver, int attacker){\n        parent[get_root_uf(parent,attacker)] = get_root_uf(parent, receiver);\n    }\n\t\n    private static int areaSum_half_open(int[][] acum_plus1, int bY_notInclude, int aY_include, int bX_notInclude, int aX_include){\n        int ans = acum_plus1[aY_include+1][aX_include+1];\n        ans -= acum_plus1[aY_include+1][bX_notInclude+1];\n        ans -= acum_plus1[bY_notInclude+1][aX_include+1];\n        ans += acum_plus1[bY_notInclude+1][bX_notInclude+1];\n        return ans;\n    }\n    private static long areaSum_close(long[][] acum_plus1, int bY_Include, int aY_include, int bX_Include, int aX_include){\n        long ans = acum_plus1[aY_include+1][aX_include+1];\n        ans -= acum_plus1[aY_include+1][bX_Include];\n        ans -= acum_plus1[bY_Include][aX_include+1];\n        ans += acum_plus1[bY_Include][bX_Include];\n        return ans;\n    }\n    \n\tprivate static void nextPerm(ArrayList<Integer> former){\n\t\tint pivot=-1;\n\t\tint ln = former.size();\n\t\tfor(int i = ln; i>1; i--){\n\t\t\tif(former.get(i-2) < former.get(i-1)){\n\t\t\t\tpivot = i-2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(pivot==-1){\n    \t\tformer = null;\n    \t\treturn;\n\t\t}\n\t\tint pivot_fig = former.get(pivot);\n\t\t\n\t\tint min_pos=pivot+1;\n\t\tint min=former.get(min_pos);\n\t\tfor(int i=ln-1; i > pivot+1; i--){\n\t\t\tif((former.get(i) < min)&&(former.get(i) > pivot_fig)){\n\t\t\t\tmin_pos=i;\n\t\t\t\tmin=former.get(min_pos);\n\t\t\t}\n\t\t}\n\t\tCollections.swap(former, pivot, min_pos);\n\t\tCollections.sort(former.subList(pivot+1, ln));\n\t}\n    private static ArrayList<boolean[]> combi_enum(int ln, boolean[] former, int now_pos, int rest){\n        ArrayList<boolean[]> ans = new ArrayList<>();\n        boolean[] ans1 = new boolean[former.length+1];\n\t   \tfor(int i=0; i<former.length; i++){\n\t   \t    ans1[i] = former[i];\n\t   \t}\n        if(ln==(now_pos+1)){\n            switch(rest){\n                case 0:\n                    ans1[former.length] = false;\n                    ans.add(ans1);\n                    break;\n                case 1:\n                    ans1[former.length] = true;\n                    ans.add(ans1);\n                    break;\n            }\n        }else{\n            if(rest == 0){\n                ans1[former.length] = false;\n                ans.addAll(combi_enum(ln, ans1, now_pos+1, rest));\n            }else{\n                ans1[former.length] = false;\n                ans.addAll(combi_enum(ln, ans1.clone(), now_pos+1, rest));\n                ans1[former.length] = true;\n                ans.addAll(combi_enum(ln, ans1.clone(), now_pos+1, rest-1));\n            }\n        }\n        return ans;\n    }\n\t\n\tprivate static int dfs2(boolean[][] state, int x, int y, int depth){\t\t//薄氷渡り\n\t\tint[] tmpltX = {1,-1,0,0};\n\t\tint[] tmpltY = {0,0,1,-1};\n\t\tint newX = -1, newY = -1;\n\t\t\n\t\tstate[x][y] = false;\n\t\tdepth++;\n\t\t\n\t\tint maxDunder_this_brunch = depth, tmpD=0;\n\t\tfor(int i=0; i < 4; i++){\n\t\t\tnewX = x+tmpltX[i];\n\t\t\tnewY = y+tmpltY[i];\n\t\t\tif((newX >= 0) && (newY >= 0) && (newX < state.length) && (newY < state[0].length) && state[newX][newY]) tmpD = dfs2(state, newX, newY, depth);\n\t\t\tif(tmpD > maxDunder_this_brunch) maxDunder_this_brunch=tmpD;\n\t\t}\n\t\tstate[x][y] = true;\n\t\treturn maxDunder_this_brunch;\n\t}\n\t\n\t\n\tstatic void show2(boolean[][] dt, int lit_x, int lit_y){\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tfor(int i=0; i<dt[0].length; i++){\n\t\t\tfor(int j=0; j<dt.length; j++){\n\t\t\t\tif((i==lit_y) && (j==lit_x)) out.print(\"X\");\n\t\t\t\telse if(dt[j][i]) out.print(\"O\");\n\t\t\t\telse out.print(\".\");\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t\tout.flush();\n\t}\n\tstatic void show2(int[][] dt, String cmnt){\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tfor(int i=0; i<dt.length; i++){\n\t\t\tfor(int j=0; j<dt[0].length; j++){\n\t\t\t\tout.print(dt[i][j]+\",\");\n\t\t\t}\n\t\t\tout.println(\"<-\"+cmnt+\":\"+i);\n\t\t}\n\t\tout.flush();\n\t}\n\tstatic void show2(long[][] dt, String cmnt){\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tfor(int i=0; i<dt.length; i++){\n\t\t\tfor(int j=0; j<dt[0].length; j++){\n\t\t\t\tout.print(dt[i][j]+\",\");\n\t\t\t}\n\t\t\tout.println(\"<-\"+cmnt+\":\"+i);\n\t\t}\n\t\tout.flush();\n\t}\n\tstatic void disp_que(ArrayDeque<Integer> dt){\t\t//上手くいかなかった時用\n\t\tint a=0;\n\t\twhile(dt.size()>0){\n\t\t\ta=dt.removeLast();\n\t\t\tSystem.out.print(a);\n\t\t}\n\t\tSystem.out.println(\"\\n\");\n\t}\n\tstatic void disp_list(List dt){\t\t//上手くいかなかった時用\n\t   \tfor(int i=0; i<dt.size(); i++){\n\t\t\tSystem.out.print(dt.get(i)+\",\");\n\t\t}\n\t\tSystem.out.println(\"\\n\");\n\t}\n\t\n\t\n\t\n\t\n\tprivate static void fill(boolean[] ob, boolean res){\n\t\tfor(int i=0; i<ob.length; i++){ ob[i] = res;    }\n\t}\n\tprivate static void fill(int[] ob, int res){\n\t\tfor(int i=0; i<ob.length; i++){ ob[i] = res;    }\n\t}\n\tprivate static void fill(long[] ob, long res){\n\t\tfor(int i=0; i<ob.length; i++){ ob[i] = res;    }\n\t}\n\tprivate static void fill(char[] ob, char res){\n\t\tfor(int i=0; i<ob.length; i++){ ob[i] = res;    }\n\t}\n\tprivate static void fill(boolean[][] ob, boolean res){\n\t\tfor(int i=0; i<ob.length; i++){ for(int j=0; j<ob[0].length; j++){  ob[i][j] = res; }   }\n\t}\n\tprivate static void fill(int[][] ob, int res){\n\t\tfor(int i=0; i<ob.length; i++){ for(int j=0; j<ob[0].length; j++){  ob[i][j] = res; }   }\n\t}\n\tprivate static void fill(long[][] ob, long res){\n\t\tfor(int i=0; i<ob.length; i++){ for(int j=0; j<ob[0].length; j++){  ob[i][j] = res; }   }\n\t}\n\tprivate static void fill(char[][] ob, char res){\n\t\tfor(int i=0; i<ob.length; i++){ for(int j=0; j<ob[0].length; j++){  ob[i][j] = res; }   }\n\t}\n\tprivate static void fill(int[][][] ob, int res){\n\t\tfor(int i=0; i<ob.length; i++){\tfor(int j=0; j<ob[0].length; j++){\n\t\t\t\tfor(int k=0; k<ob[0][0].length; k++){   ob[i][j][k] = res;  }   }   }\n\t}\n\tprivate static void fill(long[][][][] ob, long res){\n\t\tfor(int i=0; i<ob.length; i++){\tfor(int j=0; j<ob[0].length; j++){\n\t\t\t\tfor(int k=0; k<ob[0][0].length; k++){\tfor(int l=0; l<ob[0][0][0].length; l++){\n    \t\t\t\t    ob[i][j][k][l]=res; }   }   }   }\n\t}\n\t\n    \nstatic class FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nexL() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b) || b == ':'){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nexI() {\n\t\tlong nl = nexL();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic double nexD() { return Double.parseDouble(next());}\n\t\n\tpublic void ni(long[] array2){\n\t   \tfor(int i=0; i<array2.length; i++){\n\t   \t    array2[i] = nexL();\n\t   \t}\n\t   \treturn;\n\t}\n\tpublic void ni(int[] array2){\n\t   \tfor(int i=0; i<array2.length; i++){\n\t   \t    array2[i] = nexI();\n\t   \t}\n\t   \treturn;\n\t}\n}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\th = io.nextInt();\n\t\t\tw = io.nextInt();\n\t\t\tK = io.nextInt();\n\t\t\t\n\t\t\tchar[][] cs = new char[h][];\n\t\t\tfor (int y = 0; y < h; y++) {\n\t\t\t\tcs[y] = io.next();\n\t\t\t}\n\t\t\t\n\t\t\tlong ans = 0;\n\t\t\tfor (int y = 0; y < h; y++) {\n\t\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\t\tchar c = cs[y][x];\n\t\t\t\t\tcs[y][x] = 0;\n\t\t\t\t\tans = Math.max(ans, rensa(cs));\n\t\t\t\t\tcs[y][x] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tio.out.println(ans);\n\t\t}\n\t}\n\t\n\tint w, h, K;\n\tlong rensa(char[][] cs0) {\n\t\tchar[][] cs = new char[cs0.length][];\n\t\tfor (int y = 0; y < h; y++) {\n\t\t\tcs[y] = cs0[y].clone();\n\t\t}\n\t\t\n\t\tlong c = 1;\n\t\tlong ans = 0;\n\t\twhile (true) {\n\t\t\tint num = 0;\n\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\tfor (int y = h - 1, y2 = y; y >= 0; y--) {\n\t\t\t\t\tif (cs[y][x] != 0) {\n\t\t\t\t\t\tif (y != y2) {\n\t\t\t\t\t\t\tcs[y2][x] = cs[y][x];\n\t\t\t\t\t\t\tcs[y][x] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ty2--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tfor (char[] cc : cs) dump(new String(cc));\n\t\t\tfor (int y = 0; y < h; y++) {\n\t\t\t\tfor (int i = 0, j; i < w; i = j) {\n\t\t\t\t\tchar c0 = cs[y][i];\n\t\t\t\t\tfor (j = i; j < w && cs[y][j] == c0; j++) ;\n//\t\t\t\t\tif (y == h - 1) {\n//\t\t\t\t\t\tdump(\"chk\", i, j);\n//\t\t\t\t\t}\n\t\t\t\t\tif (j - i >= K && cs[y][i] != 0) {\n\t\t\t\t\t\tfor (j = i; j < w && cs[y][j] == c0; j++) {\n\t\t\t\t\t\t\tnum += cs[y][j] - '0';\n\t\t\t\t\t\t\tcs[y][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (num == 0) break;\n//\t\t\tdump(c, num);\n\t\t\tans += c * num;\n\t\t\tc <<= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n  private static boolean debug = false;\n  private static boolean elapsed = false;\n\n  private int H;\n        private int W;\n        private int K;\n\n  private int score;\n  private void solve(Scanner sc, PrintWriter out) {\n    H = sc.nextInt();\n    W = sc.nextInt();\n    K = sc.nextInt();\n    sc.nextLine();\n\n    int[][] c = new int[H][W];\n    for (int i = 0; i < H; ++i) {\n      String s = sc.nextLine();\n      String[] tokens = s.split(\"\");\n      for (int j = 0; j < W; ++j) {\n        c[i][j] = Integer.parseInt(tokens[j]);\n      }\n    }\n\n    for (int i = 0; i < H; ++i) {\n      for (int j = 0; j < W; ++j) {\n        int[][] cc = copy(c);\n        cc[i][j] = -1;\n        for (int k = i; k > 0; --k) {\n          cc[k][j] = cc[k - 1][j];\n        }\n        cc[0][j] = -2;\n        int scr = check(cc);\n        if (score < scr) {\n          score = scr;\n        }\n      }\n    }\n    out.println(score);\n  }\n  private int[][] copy(int[][] c) {\n    int[][] cc = new int[H][W];\n    for (int i = 0; i < H; ++i) {\n      for (int j = 0; j < W; ++j) {\n        cc[i][j] = c[i][j];\n      }\n    }\n    return cc;\n  }\n  private int check(int[][] c) {\n    int scr = 0;\n    for (int ct = 0; true; ++ct) {\nif (debug) {\n  System.err.println(\"========\");\n  for (int i = 0; i < H; ++i) {\n    for (int j = 0; j < W; ++j) {\n      System.err.print(\" \" + c[i][j]);\n    }\n    System.err.println();\n  }\n}\n\n      int tmp = 0;\n      boolean found1 = false;\n      for (int i = 0; i < H; ++i) {\n        int prev = -1;\n        int cnt = 1;\n        for (int j = 0; j < W; ++j) {\n          if (c[i][j] >= 0 && prev == c[i][j]) {\n            ++cnt;\n          } else if (cnt >= K) {\n            found1 = true;\n            for (int k = j - 1; cnt > 0; --k, --cnt) {\n//System.err.println(\"+1(\" + i + \", \" + k + \")=\" + c[i][k]);\n              tmp += c[i][k];\n              c[i][k] = -1;\n            }\n          }\n          prev = c[i][j];\n        }\n        if (cnt >= K) {\n          found1 = true;\n          for (int k = W - 1; cnt > 0; --k, --cnt) {\n//System.err.println(\"+2(\" + i + \", \" + k + \")=\" + c[i][k]);\n            tmp += c[i][k];\n            c[i][k] = -1;\n          }\n        }\n      }\n\n      if (!found1) {\n        break;\n      }\n//System.err.println(\"tmp[\" + ct + \"]=\" + tmp);\n      scr += (int)(Math.pow(2, ct) * tmp);\n\n      for (int i = H - 1; i >= 0; --i) {\n        for (int j = 0; j < W; ++j) {\n          if (c[i][j] == -1) {\n            if (i > 0) {\n              int k = i - 1;\n              for (; k > 0 && c[k][j] == -1; --k) {\n              }\n              c[i][j] = c[k][j];\n              c[k][j] = -1;\n            } else {\n              c[i][j] = -2;\n            }\n          }\n        }\n      }\nif (debug) {\n  System.err.println(\"========\");\n  for (int i = 0; i < H; ++i) {\n    System.err.print(\">>\");\n    for (int j = 0; j < W; ++j) {\n      System.err.print(\" \" + c[i][j]);\n    }\n    System.err.println();\n  }\n}\n    }\n    return scr;\n  }\n  /*\n   * 10^10 > Integer.MAX_VALUE = 2147483647 > 10^9\n   * 10^19 > Long.MAX_VALUE = 9223372036854775807L > 10^18\n   */\n  public static void main(String[] args) {\n    long S = System.currentTimeMillis();\n\n    Scanner sc = new Scanner(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n    new Main().solve(sc, out);\n    out.flush();\n\n    long G = System.currentTimeMillis();\n    if (elapsed) {\n      System.err.println((G - S) + \"ms\");\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tstatic int c[][];\n\tstatic int origin_c[][];\n\tstatic int H;\n\tstatic int W;\n\tstatic int K;\n\tstatic int max_score=0;\n\tstatic List<List<Integer>> empty_zahyou = new ArrayList<>();\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tH = sc.nextInt();\n\t\tW = sc.nextInt();\n\t\tK = sc.nextInt();\n\n\t\tc=new int[H][W];\n\t\torigin_c=new int[H][W];\n\n\t\tfor(int i=0;i<H;i++) {\n\t\t\tint num = sc.nextInt();\n\t\t\tfor(int j=W-1;j>-1;j--) {\n\t\t\t\tc[i][j]=num%10;\n\t\t\t\tnum = num / 10;\n\t\t\t}\n\t\t}\n\t\tarray_copy(origin_c,c);\n//\t\tint h =4-1;\n//\t\tint w =3-1;\n//\t\tslide(h,w);\n//\t\th =3-1;\n//\t\tw =3-1;\n//\t\tslide(h,w);\n\n\t\tfor(int i=0;i<H;i++) {\n\t\t\tfor(int j=0;j<W;j++) {\n\n\t\t\t}\n\t\t}\n\n\t\tint score=0;\n\t\tint del_count=0;\n\t\tfor(int i=0;i<H;i++) {\n\t\t\tfor(int j=0;j<W;j++) {\n\t\t\t\tslide(i,j);\n\t\t\t\tscore+=del(0);//この関数がうまく動作するか調べる。\n\t\t\t\tdel_count+=1;\n\t\t\t\twhile(empty_zahyou.size()!=0) {\n\t\t\t\t\tfor(List<Integer> zahyou: empty_zahyou) {\n\t\t\t\t\t\tint h=zahyou.get(0);\n\t\t\t\t\t\tint w=zahyou.get(1);\n\t\t\t\t\t\tslide(h,w);\n\t\t\t\t\t}\n\t\t\t\t\tempty_zahyou.clear();\n\t\t\t\t\tscore+=del(del_count);\n\t\t\t\t\tdel_count+=1;\n\t\t\t\t}\n\t\t\t\tif(score>max_score) {\n\t\t\t\t\tmax_score=score;\n\t\t\t\t}\n\t\t\t\tscore=0;\n\t\t\t\tdel_count=0;\n\t\t\t\tarray_copy(c,origin_c);\n\t\t\t}\n\t\t}\n\n\t\t//(4,3)を消す例題\n//\t\tint i=4-1;\n//\t\tint j=3-1;\n//\t\tslide(i,j);\n//\t\tscore+=del(0);//この関数がうまく動作するか調べる。\n//\t\tdel_count+=1;\n//\t\twhile(empty_zahyou.size()!=0) {\n//\t\t\tfor(List<Integer> zahyou: empty_zahyou) {\n//\t\t\t\tint h=zahyou.get(0);\n//\t\t\t\tint w=zahyou.get(1);\n//\t\t\t\tslide(h,w);\n//\t\t\t}\n//\t\t\tempty_zahyou.clear();\n//\t\t\tscore+=del(del_count);\n//\t\t\tdel_count+=1;\n//\t\t}\n//\t\tif(score>max_score) {\n//\t\t\tmax_score=score;\n//\t\t}\n//\t\tscore=0;\n//\t\tdel_count=0;\n\n\t\tSystem.out.println(max_score);\n\t\tsc.close();\n\n\t}\n\t//空きマスを埋める関数\n\tpublic static void slide(int h,int w) {\n\t\tint i = h;\n\t\twhile(i>0 && c[i-1][w]!=-1) {\n\t\t\tc[i][w] = c[i-1][w];\n\t\t\ti--;\n\t\t}\n\t\tc[i][w]=-1;\n\t}\n\n\t//現在の盤面から削除できるマスを消す\n\tpublic static int del(int del_count) {\n\t\tint score=0;\n\t\tint count=1;\n\t\tint x_start=0;\n\t\tint cur_x=0;\n\t\tfor(int i=0;i<H;i++) {\n\t\t\tif(count>=K) {\n\t\t\t\tfor(int x=x_start;x<cur_x+1;x++) {\n\t\t\t\t\tempty_zahyou.add(new ArrayList<Integer>(Arrays.asList(i-1,x)));\n\t\t\t\t}\n\t\t\t\tscore+=(int) Math.pow(2, del_count) * c[i-1][cur_x-1]*count;\n\t\t\t}\n\t\t\tcount=1;\n\t\t\tx_start=0;\n\t\t\tcur_x=0;\n\t\t\twhile(cur_x<W-1) {\n\t\t\t\tif(c[i][cur_x]==c[i][cur_x+1] && c[i][cur_x]!=-1) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(count>=K) {\n\t\t\t\t\t\tfor(int x=x_start;x<cur_x+1;x++) {\n\t\t\t\t\t\t\tempty_zahyou.add(new ArrayList<Integer>(Arrays.asList(i,x)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tscore+=(int) Math.pow(2, del_count) * c[i][cur_x]*count;\n\t\t\t\t\t}\n\t\t\t\t\tx_start=cur_x+1;\n\t\t\t\t\tcount=1;\n\t\t\t\t}\n\t\t\t\tcur_x++;\n\t\t\t}\n\t\t}\n\t\tif(count>=K) {\n\t\t\tfor(int x=x_start;x<cur_x+1;x++) {\n\t\t\t\tempty_zahyou.add(new ArrayList<Integer>(Arrays.asList(H-1,x)));\n\t\t\t}\n\t\t\tscore+=(int) Math.pow(2, del_count) * c[H-1][cur_x]*count;\n\t\t}\n\t\treturn score;\n\t}\n\n\tpublic static void array_copy(int[][] dst, int[][] src) {\n\t\tfor(int i=0;i<H;i++) {\n\t\t\tfor(int j=0;j<W;j++) {\n\t\t\t\tdst[i][j] = src[i][j];\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), m = ni(), K = ni();\n\t\tchar[][] map = nm(n,m);\n\t\tlong max = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < m;j++){\n\t\t\t\tchar[][] xmap = new char[n][];\n\t\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\t\txmap[k] = Arrays.copyOf(map[k], m);\n\t\t\t\t}\n\t\t\t\txmap[i][j] = '0';\n\t\t\t\tmax = Math.max(max, simulate(xmap, K));\n\t\t\t}\n\t\t}\n\t\tout.println(max);\n\t}\n\t\n\tstatic long simulate(char[][] map, int K)\n\t{\n\t\tlong score = 0;\n\t\tint turn = 0;\n\t\twhile(true){\n\t\t\tif(!drop(map))return score;\n\t\t\tscore += erase(map, K)<<turn;\n\t\t\tturn++;\n\t\t}\n\t}\n\t\n\tstatic long erase(char[][] map, int K)\n\t{\n\t\tlong ret = 0;\n\t\tint n = map.length, m = map[0].length;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint from = 0;\n\t\t\tfor(int j = 0;j < m;j++){\n\t\t\t\tif(j > 0 && map[i][j] != map[i][j-1]){\n\t\t\t\t\tif(j-from >= K){\n\t\t\t\t\t\tfor(int k = from;k < j;k++){\n\t\t\t\t\t\t\tret += map[i][k] - '0';\n\t\t\t\t\t\t\tmap[i][k] = '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfrom = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(m-from >= K){\n\t\t\t\tfor(int k = from;k < m;k++){\n\t\t\t\t\tret += map[i][k] - '0';\n\t\t\t\t\tmap[i][k] = '0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tstatic boolean drop(char[][] map)\n\t{\n\t\tint n = map.length, m = map[0].length;\n\t\tboolean dr = false;\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tint r = n-1;\n\t\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\t\tif(map[i][j] != '0'){\n\t\t\t\t\tmap[r][j] = map[i][j];\n\t\t\t\t\tif(r != i){\n\t\t\t\t\t\tmap[i][j] = '0';\n\t\t\t\t\t\tdr = true;\n\t\t\t\t\t}\n\t\t\t\t\tr--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dr;\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\n//using System.Numerics;  //comment out if AOJ\nusing System.Text;\n\nusing Problem = Tmp.Problem;\nusing MyIO;\n\n#pragma warning disable   //for AOJ\n\nnamespace Tmp\n{\n    class Problem : IDisposable\n    {\n        bool IsGCJ;\n        int Repeat;\n        Scanner sc;\n        Printer pr;\n        public Problem(bool isGCJ, Scanner scanner, Printer printer)\n        {\n            sc = scanner;\n            pr = printer;\n            IsGCJ = isGCJ;\n            if (isGCJ) Repeat = sc.nextInt();\n            else Read();\n        }\n        public Problem(bool isGCJ) : this(isGCJ, new Scanner(), new Printer()) { }\n        public Problem(bool isGCJ, Scanner scanner) : this(isGCJ, scanner, new Printer()) { }\n        public Problem(bool isGCJ, Printer printer) : this(isGCJ, new Scanner(), printer) { }\n        public void Solve()\n        {\n            if (IsGCJ) for (var i = 0; i < Repeat; i++) { Read(); pr.Write(\"Case #\" + (i + 1) + \": \"); SolveOne(); }\n            else SolveOne();\n        }\n        public void Dispose()\n        {\n            sc.Dispose();\n            pr.Dispose();\n        }\n        public int Size { get { return 1; } }\n        public const long Mod = 1000000007;\n\n        // 使用する変数をここに書く\n        // string S;\n        // int a;\n        int[,] map, mapOrigin;\n        int ansTmp;\n        int scoreCnt;\n        int h, w, k;\n        /// <summary>\n        /// 読み込み処理をここに書く\n        /// </summary>\n        void Read()\n        {\n\n        }\n        /// <summary>\n        /// メイン処理をここに書く\n        /// </summary>\n        void SolveOne()\n        {\n            int ans = 0;\n\n            h = sc.nextInt();\n            w = sc.nextInt();\n            k = sc.nextInt();\n            map = new int[h + 1, w];\n            mapOrigin = new int[h + 1, w];\n            for (int i = 1; i <= h; i++)\n            {\n                char[] tmpmapstr = Console.ReadLine().ToCharArray();\n                int[] tmpmapint = new int[w];\n                for (int j = 0; j < w; j++)\n                {\n                    int tmp = tmpmapstr[j] - '0';\n                    map[i, j] = tmp;\n                    mapOrigin[i, j] = tmp;\n                }\n\n            }\n            for (int del = 0; del < w; del++)\n            {\n                map[h, del] = 0;\n                ansTmp = 0;\n                refresh();\n\n                for (int cnt = 0; cnt <= h * w; cnt++)\n                {\n                    scoreCnt = (int)Math.Pow(2, cnt);\n                    int ansTmpTmp = ansTmp;\n                    for (int i = 1; i <= h; i++)\n                    {\n                        int rensa = map[i, 0];\n                        int begin = 0;\n                        int end = 0;\n                        for (int j = 0; j < w; j++)\n                        {\n                            if (map[i, j] == rensa)\n                            {\n                                end = j;\n                            }\n                            else\n                            {\n                                remove(i, begin, end);\n                                rensa = map[i, j];\n                                begin = j;\n                                end = j;\n                            }\n                            if (j == w - 1)\n                            {\n                                remove(i, begin, end);\n                            }\n                        }\n                    }\n                    refresh();\n                    if(ansTmp==ansTmpTmp)\n                    {\n                        break;\n                    }\n                }\n                ans = Math.Max(ans, ansTmp);\n                for (int i = 0; i < h + 1; i++)\n                {\n                    for (int j = 0; j < w; j++)\n                    {\n                        map[i, j] = mapOrigin[i, j];\n                    }\n                }\n            }\n            Console.WriteLine(ans);\n        }\n\n        void remove(int height, int begin, int end)\n        {\n            if (end - begin + 1 >= k)\n            {\n                for (int i = begin; i <= end; i++)\n                {\n                    ansTmp += scoreCnt * map[height, i];\n                    map[height, i] = 0;\n                }\n            }\n        }\n\n        void refresh()\n        {\n            for (int k = 0; k < h + 1; k++)\n            {\n                for (int i = h; i > 0; i--)\n                {\n                    for (int j = 0; j < w; j++)\n                    {\n                        if (map[i, j] == 0)\n                        {\n                            map[i, j] = map[i - 1, j];\n                            map[i - 1, j] = 0;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nclass Program\n{\n    //public static RandomSFMT rand = new RandomSFMT();\n    public static bool IsJudgeMode = true;\n    public static bool IsGCJMode = false;\n    public static bool IsSolveCreated = true;\n    static void Main()\n    {\n        if (IsJudgeMode)\n            if (IsGCJMode) using (var problem = new Problem(true, new Scanner(\"C-large-practice.in.txt\"), new Printer(\"output.txt\"))) problem.Solve();\n            else using (var problem = new Problem(false, new Printer())) problem.Solve();\n        else\n        {\n            var num = 1;\n            int size = 0;\n            decimal time = 0;\n            for (var tmp = 0; tmp < num; tmp++)\n            {\n                using (var P = IsSolveCreated ? new Problem(false, new Scanner(\"input.txt\"), new Printer()) : new Problem(false))\n                {\n                    size = P.Size;\n                    //time += Func.MeasureTime(() => P.Solve());\n                }\n            }\n            Console.WriteLine(\"{0}, {1}ms\", size, time / num);\n        }\n    }\n}\n\n/// <summary>\n/// カスタマイズしたIO\n/// </summary>\nnamespace MyIO\n{\n    class Printer : IDisposable\n    {\n        bool isConsole;\n        TextWriter file;\n        public Printer() { file = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; isConsole = true; }\n        public Printer(string path) { file = new StreamWriter(path, false) { AutoFlush = false }; isConsole = false; }\n        public void Write<T>(T value) { file.Write(value); }\n        public void Write(bool b) { file.Write(b ? \"YES\" : \"NO\"); }\n        public void Write(string str, params object[] args) { file.Write(str, args); }\n        public void WriteLine() { file.WriteLine(); }\n        public void WriteLine<T>(T value) { file.WriteLine(value); }\n        public void WriteLine(bool b) { file.WriteLine(b ? \"YES\" : \"NO\"); }\n        public void WriteLine<T>(IEnumerable<T> list) { foreach (var x in list) file.WriteLine(x); }\n        public void WriteLine<T>(List<T> list) { foreach (var x in list) file.WriteLine(x); }\n        public void WriteLine<T>(T[] list) { foreach (var x in list) file.WriteLine(x); }\n        public void WriteLine(string str, params object[] args) { file.WriteLine(str, args); }\n        public void Dispose() { file.Flush(); if (!isConsole) file.Dispose(); }\n    }\n    class Scanner : IDisposable\n    {\n        bool isConsole;\n        TextReader file;\n        public Scanner() { file = Console.In; }\n        public Scanner(string path) { file = new StreamReader(path); isConsole = false; }\n        public void Dispose() { if (!isConsole) file.Dispose(); }\n\n        #region next読み込み\n        string[] nextBuffer = new string[0];\n        int BufferCnt = 0;\n\n        char[] cs = new char[] { ' ' };\n\n        public string next()\n        {\n            while (BufferCnt >= nextBuffer.Length)\n            {\n                string st = file.ReadLine();\n                while (st == \"\") st = file.ReadLine();\n                nextBuffer = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n                BufferCnt = 0;\n            }\n            return nextBuffer[BufferCnt++];\n        }\n\n        public int nextInt()\n        {\n            return int.Parse(next());\n        }\n\n        public long nextLong()\n        {\n            return long.Parse(next());\n        }\n\n        public double nextDouble()\n        {\n            return double.Parse(next());\n        }\n\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public string[] next(int n) { return enumerate(n, next); }\n        public double[] nextDouble(int n) { return enumerate(n, nextDouble); }\n        public int[] nextInt(int n) { return enumerate(n, nextInt); }\n        public long[] nextLong(int n) { return enumerate(n, nextLong); }\n        #endregion\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nclass Solve{\n    int H;\n    int W;\n    int K;\n    int[,] c;\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Read();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        long max = 0;\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                long count = 0;\n                long pow = 1;\n                int[,] d = new int[H,W];\n                for(int k=0;k<H;k++){\n                    for(int l=0;l<W;l++){\n                        d[k,l] = c[k,l];\n                    }\n                }\n                for(int k=i;k<H;k++){\n                    if(k == H-1){\n                        d[k,j] = 0;\n                    }\n                    else{\n                        d[k,j] = d[k+1,j];\n                    }\n                }\n                while(true){\n                    int[,] d0 = new int[H,W];\n                    bool[,] b = new bool[H,W];\n                    bool fin = true;\n                    for(int k=0;k<H;k++){\n                        int row = 1;\n                        for(int l=1;l<W;l++){\n                            if(d[k,l] == d[k,(l-1)] && d[k,l] != 0){\n                                row++;\n                                if(l == W-1 && row >= K){\n                                    for(int m=l+1-row;m<=l;m++){\n                                        b[k,m] = true; \n                                    }\n                                    count += pow*(d[k,l-1]*row);\n                                    fin = false;\n                                }\n                            }\n                            else{\n                                if(row >= K){\n                                    for(int m=l-row;m<l;m++){\n                                        b[k,m] = true; \n                                    }\n                                    count += pow*(d[k,l-1]*row);\n                                    fin = false;\n                                }\n                                row = 1;\n                            }\n                        }\n                    }\n                    if(fin){\n                        break;\n                    }\n                    for(int k=0;k<W;k++){\n                        int m = 0;\n                        for(int l=0;l<H;l++){\n                            if(m == W){\n                                d0[l,k] = 0;\n                            }\n                            else{\n                                while(b[m,k]){\n                                    m++;\n                                    if(m == W){\n                                        break;\n                                    }\n                                }\n                                if(m == W){\n                                    d0[l,k] = 0;\n                                }\n                                else{\n                                    d0[l,k] = d[m,k];\n                                    m++;\n                                }\n                            }\n                        }\n                    }\n                    d = d0;\n                    pow *= 2;\n                }\n                if(max <= count){\n                    max = count;\n                }\n            }\n        }\n        sb.Append(max+\"\\n\");\n    }\n    void Read(){\n        string[] str = Console.ReadLine().Split(' ');\n        H = int.Parse(str[0]);\n        W = int.Parse(str[1]);\n        K = int.Parse(str[2]);\n        c = new int[H,W];\n        for(int i=H-1;i>=0;i--){\n            string s = Console.ReadLine();\n            for(int j=0;j<W;j++){\n                c[i,j] = int.Parse(s[j]+\"\");\n            }\n        }\n    }    \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace square869120_3B\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var HWK = ReadInt();\n            int H = HWK[0];\n            int W = HWK[1];\n            int K = HWK[2];\n\n            //読み込み\n            int[,] map = new int[H, W];\n            for (int i = 0; i < H; i++)\n            {\n                var input = Console.ReadLine();\n                for (int j = 0; j < W; j++)\n                {\n                    map[H - 1 - i, j] = int.Parse(input[j].ToString());\n                }\n            }\n\n            int[,] mapCopy = new int[H, W];\n            Array.Copy(map, mapCopy, map.Length);\n            int ans = 0;\n\n            for (int h = 0; h < H; h++)\n            {\n                for (int w = 0; w < W; w++)\n                {\n                    int cont = 0;\n                    int cand = 0;\n                    Array.Copy(mapCopy, map, mapCopy.Length);\n                    map[h, w] = 0;\n\n                    //消える\n                    while (true)\n                    {\n                        // 下に詰める\n                        int[,] nextMap = new int[H, W];\n                        for (int i = 0; i < W; i++)\n                        {\n                            int index = 0;\n                            for (int j = 0; j < H; j++)\n                            {\n                                if (map[j, i] == 0) continue;\n                                nextMap[index, i] = map[j, i];\n                                index++;\n                            }\n                        }\n                        map = nextMap;\n\n                        bool banish = false;\n\n                        for (int i = 0; i < H; i++)\n                        {\n                            for (int k = 0; k < W + 1 - K; k++)//スタート\n                            {\n                                if (map[i, k] == 0) continue;\n                                int count = 1;\n                                for (int j = k + 1; j < W; j++)//連続\n                                {\n                                    if (map[i, j] == map[i, k])\n                                    {\n                                        count++; continue;\n                                    }\n                                    else break;\n                                }\n                                if (count >= K)//削除の処理\n                                {\n                                    cand += (int)Math.Pow(2, cont) * count * map[i, k];\n\n                                    for (int j = k; j < k + count; j++)\n                                    {\n                                        map[i, j] = 0;\n                                    }\n                                    banish = true;\n                                    break;\n                                }\n                            }\n                        }\n\n                        if (!banish) break;\n                        cont++;\n                    }\n\n                    ans = Math.Max(cand, ans);\n                }\n            }\n\n            Console.WriteLine(ans);\n\n            Console.ReadKey();\n        }\n\n        static int[] ReadInt()\n        {\n            int[] ret = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            return ret;\n        }\n        static long[] ReadLong()\n        {\n            long[] ret = Console.ReadLine().Split().Select(long.Parse).ToArray();\n            return ret;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Collections.Specialized;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Linq;\n\npublic class Magatro\n{\n    static int H, W, K;\n    static int[][] c;\n    static void Main()\n    {\n        string[] q = Console.ReadLine().Split(' ');\n        H = int.Parse(q[0]);\n        W = int.Parse(q[1]);\n        K = int.Parse(q[2]);\n        c = new int[H][];\n        for(int i = 0; i < H; i++)\n        {\n            c[i] = Console.ReadLine().Select(s => int.Parse(s.ToString())).ToArray();\n        }\n        int max = 0;\n        for(int i = 0; i < W; i++)\n        {\n            int cnt = 0;\n            \n            int[] e = new int[W];\n            e[i] = -1;\n            for(int k = 1; k < H; k++)\n            {\n                int r = c[k+e[0]][0] ;\n                bool a = true;\n                for(int l = 1; l < W; l++)\n                {\n                    if (c[k+e[l]][l  ]!= r)\n                    {\n                        a = false;\n                        break;\n                    }\n                }\n                if (a)\n                {\n                    cnt += r * W;\n                }\n            }\n            max = Math.Max(max, cnt);\n        }\n        Console.WriteLine(max);\n    }\n   \n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.RegularExpressions;\nusing Library;\nusing static Library.Input;\n\nnamespace AtCoderTemplate {\n    class ProgramB {\n        static void Main () {\n            int h = NextInt, w = NextInt, k = NextInt;\n            var origin = Enumerable.Range(0, h).Select(_ => Line.Select(c => c - '0').ToArray()).ToArray();\n            long result = 0;\n\n            for (int i = 1; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    var matrix = Enumerable.Range(0, h).Select(r => Enumerable.Range(0, w).Select(c => origin[r][c]).ToArray()).ToArray();\n                    matrix[i][j] = 0;\n                    bool flag = true;\n                    long point = 0;\n\n                    for (int count = 0; flag; count++)\n                    {\n                        flag = false;\n\n                        // 詰める\n                        for (int c = 0; c < w; c++)\n                        {\n                            int skip = 0;\n                            for (int r = h - 1; r >= 0 ; r--)\n                            {\n                                if (matrix[r][c] == 0)\n                                {\n                                    skip++;\n                                    matrix[r][c] = -1;\n                                }\n                                else if (skip != 0)\n                                {\n                                    matrix[r + skip][c] = matrix[r][c];\n                                    matrix[r][c] = -1;\n                                }\n                            }\n                        }\n\n                        // 消す\n                        for (int r = 0; r < h; r++)\n                        {\n                            int left = 0;\n\n                            for (int c = 1; c < w; c++)\n                            {\n                                if (matrix[r][c] != matrix[r][left] || matrix[r][left] == -1)\n                                {\n                                    if (c - left >= 2)\n                                    {\n                                        point += matrix[r][left] * (c - left) * Modular.Pow(2, count).value;\n                                        for (int t = left; t < c; t++) matrix[r][t] = 0;\n                                        flag = true;\n                                    }\n\n                                    left = c;\n                                }\n                            }\n\n                            if (w - left >= 2)\n                            {\n                                point += matrix[r][left] * (w - left) * Modular.Pow(2, count).value;\n                                for (int t = left; t < w; t++) matrix[r][t] = 0;\n                                flag = true;\n                            }\n                        }\n                    }\n                    \n                    result = Math.Max(result, point);\n                }\n            }\n\n            System.Console.WriteLine(result);\n        }\n    }\n}\n\nnamespace Library {\n    class Input {\n        static IEnumerator<string> enumerator = new string[] { }.AsEnumerable ().GetEnumerator ();\n\n        public static string Line => Console.ReadLine ();\n\n        public static string[] StrArr => Line.Split (' ');\n\n        public static int NextInt => int.Parse (NextWord ());\n\n        public static long NextLong => long.Parse (NextWord ());\n\n        public static List<int> IntList => StrArr.Select (int.Parse).ToList ();\n\n        public static List<long> LongList => StrArr.Select (long.Parse).ToList ();\n\n        public static IEnumerable<long[]> TakeLine (int N) {\n            return Enumerable.Repeat (0, N).Select (_ => Console.ReadLine ().Split (' ').Select (long.Parse).ToArray ());\n        }\n\n        public static string NextWord () {\n            while (!enumerator.MoveNext ()) {\n                enumerator = StrArr.AsEnumerable ().GetEnumerator ();\n            }\n            return enumerator.Current;\n        }\n    }\n}\n\nnamespace Library {\n    \n    class Modular {\n        public const int mod = 1000000007;\n        public readonly long value;\n        public Modular (long value) { this.value = value; }\n        public static implicit operator Modular (long a) {\n            var m = a % mod;\n            return new Modular ((m < 0) ? m + mod : m);\n        }\n        public static Modular operator + (Modular a, Modular b) {\n            return a.value + b.value;\n        }\n        public static Modular operator - (Modular a, Modular b) {\n            return a.value - b.value;\n        }\n        public static Modular operator * (Modular a, Modular b) {\n            return a.value * b.value;\n        }\n        public static Modular Pow (Modular a, int n) {\n            switch (n) {\n                case 0:\n                    return 1;\n                case 1:\n                    return a;\n                default:\n                    var p = Pow (a, n / 2);\n                    return p * p * Pow (a, n % 2);\n            }\n        }\n        public static Modular operator / (Modular a, Modular b) {\n            return a * Pow (b, mod - 2);\n        }\n        private static readonly List<int> facs = new List<int> { 1 };\n        private static Modular Fac (int n) {\n            for (int i = facs.Count; i <= n; ++i) {\n                facs.Add ((int) (Math.BigMul (facs.Last (), i) % mod));\n            }\n            return facs[n];\n        }\n        public static Modular Ncr (int n, int r) {\n            return (n < r) ? 0 :\n                (n == r) ? 1 :\n                Fac (n) / (Fac (r) * Fac (n - r));\n        }\n        public static explicit operator int (Modular a) {\n            return (int) a.value;\n        }\n    }\n\n}\nnamespace Library {\n    class MyMath {\n        public static long Gcd (long a, long b) {\n            return b == 0 ? a : Gcd (b, a % b);\n        }\n\n        public static long Sqrt (long n) {\n            if (n < 0) return 0;\n            long a = 0, tmp = 0, b = 0;\n            for (int i = 62; i >= 0; i -= 2) {\n                tmp = (b << 1) + 1 <= (n >> i) ? 1 : 0;\n                a = a << 1 | tmp;\n                n -= (((b << 1) + 1) * tmp) << i;\n                b = (b << 1) + tmp + tmp;\n            }\n            return a;\n        }\n\n        public static long Nck (int n, int k) {\n            if (k == 0) return 1;\n            if (n == 0) return 0;\n            return n * Nck (n - 1, k - 1) / k;\n        }\n    }\n}\n\nnamespace Library {\n        public class PriorityQueue<T> {\n\n        readonly List<T> _heap = new List<T> ();\n        readonly Comparison<T> _comparison;\n\n        public PriorityQueue (Comparison<T> comparison) {\n            _comparison = comparison;\n        }\n\n        public PriorityQueue () : this (Comparer<T>.Default.Compare) { }\n\n        public PriorityQueue (IComparer<T> comparer) : this (comparer.Compare) { }\n\n        public void Enqueue (T item) {\n            _heap.Add (item);\n\n            int childID = _heap.Count - 1;\n            int parentID = (childID - 1) / 2;\n\n            while (childID > 0 && _comparison (_heap[parentID], _heap[childID]) > 0) {\n                Swap (parentID, childID);\n                childID = parentID;\n                parentID = (parentID - 1) / 2;\n            }\n        }\n\n        public T Dequeue () {\n            var first = _heap.First ();\n            _heap[0] = _heap.Last ();\n            _heap.RemoveAt (_heap.Count - 1);\n\n            int parentID = 0;\n            int childID = parentID * 2 + 2;\n            if (childID >= _heap.Count || _comparison (_heap[childID], _heap[childID - 1]) > 0) childID--;\n\n            while (childID < _heap.Count && _comparison (_heap[parentID], _heap[childID]) > 0) {\n                Swap (parentID, childID);\n                parentID = childID;\n                childID = parentID * 2 + 2;\n                if (childID >= _heap.Count || _comparison (_heap[childID], _heap[childID - 1]) > 0) childID--;\n            }\n\n            return first;\n        }\n\n        void Swap (int parent, int child) {\n            var tmp = _heap[parent];\n            _heap[parent] = _heap[child];\n            _heap[child] = tmp;\n        }\n\n        public T Peek () { return _heap[0]; }\n        public int Count => _heap.Count;\n        public bool Any () { return _heap.Any (); }\n        public List<T> Data => _heap;\n    }\n}\n\nnamespace Library {\n    \n    public class UnionFind {\n        public int[] Parents { get; set; }\n        public UnionFind (int size) {\n            Parents = Enumerable.Repeat (-1, size).ToArray ();\n        }\n\n        public int Find (int num) {\n            if (Parents[num] < 0) return num;\n\n            Parents[num] = Find (Parents[num]);\n            return Parents[num];\n        }\n\n        public int Size (int num) {\n            return -Parents[Find (num)];\n        }\n\n        public bool Same (int a, int b) {\n            return Find (a) == Find (b);\n        }\n\n        public void Unite (int a, int b) {\n            int x = Find (a), y = Find (b);\n\n            if (Size (x) > Size (y)) {\n                Parents[x] += Parents[y];\n                Parents[y] = x;\n            } else {\n                Parents[y] += Parents[x];\n                Parents[x] = y;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Collections.Specialized;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Linq;\n\npublic class Magatro\n{\n    static int H, W, K;\n    static int[][] c;\n    static void Main()\n    {\n        string[] q = Console.ReadLine().Split(' ');\n        H = int.Parse(q[0]);\n        W = int.Parse(q[1]);\n        K = int.Parse(q[2]);\n        c = new int[H][];\n        for(int i = 0; i < H; i++)\n        {\n            c[i] = Console.ReadLine().Select(s => int.Parse(s.ToString())).ToArray();\n        }\n        int max = 0;\n        for(int i = 0; i < W; i++)\n        {\n            int cnt = 0;\n            \n            int[] e = new int[W];\n            e[i] = -1;\n            for(int k = 1; k < H; k++)\n            {\n                int r = c[k][0 + e[0]];\n                bool a = true;\n                for(int l = 1; l < W; l++)\n                {\n                    if (c[k][l + e[l] ]!= r)\n                    {\n                        a = false;\n                        break;\n                    }\n                }\n                if (a)\n                {\n                    cnt += r * W;\n                }\n            }\n            max = Math.Max(max, cnt);\n        }\n        Console.WriteLine(max);\n    }\n   \n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace square869120_3B\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var HWK = ReadInt();\n            int H = HWK[0];\n            int W = HWK[1];\n            int K = HWK[2];\n\n            //読み込み\n            int[,] map = new int[H, W];\n            for (int i = 0; i < H; i++)\n            {\n                var input = Console.ReadLine();\n                for (int j = 0; j < W; j++)\n                {\n                    map[H - 1 - i, j] = int.Parse(input[j].ToString());\n                }\n            }\n\n            int[,] mapCopy = new int[H, W];\n            Array.Copy(map, mapCopy, map.Length);\n            int ans = 0;\n\n            for (int h = 0; h < H; h++)\n            {\n                for (int w = 0; w < W; w++)\n                {\n                    int cont = 0;\n                    int cand = 0;\n                    Array.Copy(mapCopy, map, mapCopy.Length);\n                    map[h, w] = 0;\n\n                   \n                    while (true)\n                    {\n                        // 下に詰める\n                        int[,] nextMap = new int[H, W];\n                        for (int i = 0; i < W; i++)\n                        {\n                            int index = 0;\n                            for (int j = 0; j < H; j++)\n                            {\n                                if (map[j, i] == 0) continue;\n                                nextMap[index, i] = map[j, i];\n                                index++;\n                            }\n                        }\n                        map = nextMap;\n\n                        bool banish = false;\n\n                        for (int i = 0; i < H; i++)\n                        {\n                            for (int k = 0; k < W + 2 - K; k++)//スタート\n                            {\n                                if (map[i, k] == 0) continue;\n                                int count = 1;\n                                for (int j = k + 1; j < W; j++)//連続\n                                {\n                                    if (map[i, j] == map[i, k])\n                                    {\n                                        count++; continue;\n                                    }\n                                    else break;\n                                }\n                                if (count >= K)//削除の処理\n                                {\n                                    cand += (int)Math.Pow(2, cont) * count * map[i, k];\n\n                                    for (int j = k; j < k + count; j++)\n                                    {\n                                        map[i, j] = 0;\n                                    }\n                                    banish = true;\n                                    break;\n                                }\n                            }\n                        }\n\n                        if (!banish) break;\n                        cont++;\n                    }\n\n                    ans = Math.Max(cand, ans);\n                }\n            }\n\n            Console.WriteLine(ans);\n\n            Console.ReadKey();\n        }\n\n        static int[] ReadInt()\n        {\n            int[] ret = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            return ret;\n        }\n        static long[] ReadLong()\n        {\n            long[] ret = Console.ReadLine().Split().Select(long.Parse).ToArray();\n            return ret;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Collections.Specialized;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Linq;\n\npublic class Magatro\n{\n    static int H, W, K;\n    static int[][] c;\n    static void Main()\n    {\n        string[] q = Console.ReadLine().Split(' ');\n        H = int.Parse(q[0]);\n        W = int.Parse(q[1]);\n        K = int.Parse(q[2]);\n        c = new int[H][];\n        for(int i = 0; i < H; i++)\n        {\n            c[i] = Console.ReadLine().Select(s => int.Parse(s.ToString())).ToArray();\n        }\n        int max = 0;\n        for(int i = 0; i < W; i++)\n        {\n            int cnt = 0;\n            int[][] b = c.ToArray();\n           for(int j = H - 2; j >= 0; j--)\n            {\n                b[j + 1][i] = b[j][i];\n            }\n           for(int j = H - 1; j >= 1; j--)\n            {\n                int w = b[j][0];\n                bool a = true;\n                for(int k = 1; k < W; k++)\n                {\n                    if (w != b[j][k])\n                    {\n                        a = false;\n                        break;\n                    }\n                }\n                if (a)\n                {\n                    cnt += b[j].Sum();\n                }\n            }\n            max = Math.Max(max, cnt);\n        }\n        Console.WriteLine(max);\n    }\n   \n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.RegularExpressions;\nusing Library;\nusing static Library.Input;\n\nnamespace AtCoderTemplate {\n    class ProgramB {\n        static void Main () {\n            int h = NextInt, w = NextInt, k = NextInt;\n            var origin = Enumerable.Range(0, h).Select(_ => Line.Select(c => c - '0').ToArray()).ToArray();\n            long result = 0;\n\n            for (int i = 0; i < h; i++)\n            for (int j = 0; j < w; j++)\n            {\n                var matrix = Enumerable.Range(0, h).Select(r => Enumerable.Range(0, w).Select(c => origin[r][c]).ToArray()).ToArray();\n                matrix[i][j] = 0;\n                bool flag = true;\n                long point = 0;\n\n                for (int count = 0; flag; count++)\n                {\n                    flag = false;\n\n                    // 詰める\n                    for (int c = 0; c < w; c++)\n                    {\n                        int skip = 0;\n                        for (int r = h - 1; r >= 0 ; r--)\n                        {\n                            if (matrix[r][c] == 0)\n                            {\n                                skip++;\n                                matrix[r][c] = -1;\n                            }\n                            else if (skip != 0)\n                            {\n                                matrix[r + skip][c] = matrix[r][c];\n                                matrix[r][c] = -1;\n                            }\n                        }\n                    }\n\n                    // 消す\n                    for (int r = 0; r < h; r++)\n                    {\n                        int left = 0;\n\n                        for (int c = 1; c < w; c++)\n                        {\n                            if (matrix[r][c] != matrix[r][left] || matrix[r][left] == -1)\n                            {\n                                if (c - left >= k)\n                                {\n                                    point += matrix[r][left] * (c - left) * Modular.Pow(2, count).value;\n                                    for (int t = left; t < c; t++) matrix[r][t] = 0;\n                                    flag = true;\n                                }\n\n                                left = c;\n                            }\n                        }\n\n                        if (w - left >= k)\n                        {\n                            point += matrix[r][left] * (w - left) * Modular.Pow(2, count).value;\n                            for (int t = left; t < w; t++) matrix[r][t] = 0;\n                            flag = true;\n                        }\n                    }\n                }\n\n                result = Math.Max(result, point);\n            }\n\n            System.Console.WriteLine(result);\n        }\n    }\n}\n\nnamespace Library {\n    class Input {\n        static IEnumerator<string> enumerator = new string[] { }.AsEnumerable ().GetEnumerator ();\n\n        public static string Line => Console.ReadLine ();\n\n        public static string[] StrArr => Line.Split (' ');\n\n        public static int NextInt => int.Parse (NextWord ());\n\n        public static long NextLong => long.Parse (NextWord ());\n\n        public static List<int> IntList => StrArr.Select (int.Parse).ToList ();\n\n        public static List<long> LongList => StrArr.Select (long.Parse).ToList ();\n\n        public static IEnumerable<long[]> TakeLine (int N) {\n            return Enumerable.Repeat (0, N).Select (_ => Console.ReadLine ().Split (' ').Select (long.Parse).ToArray ());\n        }\n\n        public static string NextWord () {\n            while (!enumerator.MoveNext ()) {\n                enumerator = StrArr.AsEnumerable ().GetEnumerator ();\n            }\n            return enumerator.Current;\n        }\n    }\n}\n\nnamespace Library {\n    \n    class Modular {\n        public const int mod = 1000000007;\n        public readonly long value;\n        public Modular (long value) { this.value = value; }\n        public static implicit operator Modular (long a) {\n            var m = a % mod;\n            return new Modular ((m < 0) ? m + mod : m);\n        }\n        public static Modular operator + (Modular a, Modular b) {\n            return a.value + b.value;\n        }\n        public static Modular operator - (Modular a, Modular b) {\n            return a.value - b.value;\n        }\n        public static Modular operator * (Modular a, Modular b) {\n            return a.value * b.value;\n        }\n        public static Modular Pow (Modular a, int n) {\n            switch (n) {\n                case 0:\n                    return 1;\n                case 1:\n                    return a;\n                default:\n                    var p = Pow (a, n / 2);\n                    return p * p * Pow (a, n % 2);\n            }\n        }\n        public static Modular operator / (Modular a, Modular b) {\n            return a * Pow (b, mod - 2);\n        }\n        private static readonly List<int> facs = new List<int> { 1 };\n        private static Modular Fac (int n) {\n            for (int i = facs.Count; i <= n; ++i) {\n                facs.Add ((int) (Math.BigMul (facs.Last (), i) % mod));\n            }\n            return facs[n];\n        }\n        public static Modular Ncr (int n, int r) {\n            return (n < r) ? 0 :\n                (n == r) ? 1 :\n                Fac (n) / (Fac (r) * Fac (n - r));\n        }\n        public static explicit operator int (Modular a) {\n            return (int) a.value;\n        }\n    }\n\n}\nnamespace Library {\n    class MyMath {\n        public static long Gcd (long a, long b) {\n            return b == 0 ? a : Gcd (b, a % b);\n        }\n\n        public static long Sqrt (long n) {\n            if (n < 0) return 0;\n            long a = 0, tmp = 0, b = 0;\n            for (int i = 62; i >= 0; i -= 2) {\n                tmp = (b << 1) + 1 <= (n >> i) ? 1 : 0;\n                a = a << 1 | tmp;\n                n -= (((b << 1) + 1) * tmp) << i;\n                b = (b << 1) + tmp + tmp;\n            }\n            return a;\n        }\n\n        public static long Nck (int n, int k) {\n            if (k == 0) return 1;\n            if (n == 0) return 0;\n            return n * Nck (n - 1, k - 1) / k;\n        }\n    }\n}\n\nnamespace Library {\n        public class PriorityQueue<T> {\n\n        readonly List<T> _heap = new List<T> ();\n        readonly Comparison<T> _comparison;\n\n        public PriorityQueue (Comparison<T> comparison) {\n            _comparison = comparison;\n        }\n\n        public PriorityQueue () : this (Comparer<T>.Default.Compare) { }\n\n        public PriorityQueue (IComparer<T> comparer) : this (comparer.Compare) { }\n\n        public void Enqueue (T item) {\n            _heap.Add (item);\n\n            int childID = _heap.Count - 1;\n            int parentID = (childID - 1) / 2;\n\n            while (childID > 0 && _comparison (_heap[parentID], _heap[childID]) > 0) {\n                Swap (parentID, childID);\n                childID = parentID;\n                parentID = (parentID - 1) / 2;\n            }\n        }\n\n        public T Dequeue () {\n            var first = _heap.First ();\n            _heap[0] = _heap.Last ();\n            _heap.RemoveAt (_heap.Count - 1);\n\n            int parentID = 0;\n            int childID = parentID * 2 + 2;\n            if (childID >= _heap.Count || _comparison (_heap[childID], _heap[childID - 1]) > 0) childID--;\n\n            while (childID < _heap.Count && _comparison (_heap[parentID], _heap[childID]) > 0) {\n                Swap (parentID, childID);\n                parentID = childID;\n                childID = parentID * 2 + 2;\n                if (childID >= _heap.Count || _comparison (_heap[childID], _heap[childID - 1]) > 0) childID--;\n            }\n\n            return first;\n        }\n\n        void Swap (int parent, int child) {\n            var tmp = _heap[parent];\n            _heap[parent] = _heap[child];\n            _heap[child] = tmp;\n        }\n\n        public T Peek () { return _heap[0]; }\n        public int Count => _heap.Count;\n        public bool Any () { return _heap.Any (); }\n        public List<T> Data => _heap;\n    }\n}\n\nnamespace Library {\n    \n    public class UnionFind {\n        public int[] Parents { get; set; }\n        public UnionFind (int size) {\n            Parents = Enumerable.Repeat (-1, size).ToArray ();\n        }\n\n        public int Find (int num) {\n            if (Parents[num] < 0) return num;\n\n            Parents[num] = Find (Parents[num]);\n            return Parents[num];\n        }\n\n        public int Size (int num) {\n            return -Parents[Find (num)];\n        }\n\n        public bool Same (int a, int b) {\n            return Find (a) == Find (b);\n        }\n\n        public void Unite (int a, int b) {\n            int x = Find (a), y = Find (b);\n\n            if (Size (x) > Size (y)) {\n                Parents[x] += Parents[y];\n                Parents[y] = x;\n            } else {\n                Parents[y] += Parents[x];\n                Parents[x] = y;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing static System.Console;\nusing static System.Math;\n \npublic class Solve{\n    static public int mod = 1000000007;\n    public static void Main(){\n        // 方針\n        //\n        var n = inta();\n        var map = new int[n[0],n[1]];\n        for(int i=0;i<n[0];i++){\n            var s = rstr();\n            for(int j=0;j<n[1];j++){\n                map[i,j] = int.Parse(s[j].ToString());\n            }\n        }\n        var nowsel = new int[2];\n        var ans = 0;\n        while(nowsel[1] < n[1]){\n            var point = 0;\n            var mul = 1;\n            var map2 = new int[n[0],n[1]];\n            for(int i=0;i<n[0];i++){\n                for(int j=0;j<n[1];j++){\n                    map2[i,j] = map[i,j];\n                }\n            }\n            map2[nowsel[0],nowsel[1]] = 0;\n            \n            while(true){\n                //落下処理\n                for(int j=0;j<n[1];j++){\n                    var tempmap = new List<int>();\n                    for(int i=n[0]-1;i>=0;i--){\n                        if(map2[i,j] > 0) tempmap.Add(map2[i,j]);\n                    }\n                    for(int i=tempmap.Count;i<n[0];i++){\n                        tempmap.Add(0);\n                    }\n                    for(int i=n[0]-1;i>=0;i--){\n                        map2[i,j] = tempmap[n[0]-(i+1)];\n                    }\n                }\n                //横方向処理\n                var addpoint = 0;\n                for(int i=0;i<n[0];i++){\n                    var ncount = new int[2];\n                    var delsta = -1;\n                    for(int j=0;j<n[1];j++){\n                        if(map2[i,j] == ncount[0]){\n                            ncount[1]++;\n                        }\n                        if(map2[i,j] != ncount[0] || j==n[1]-1){\n                            if(ncount[1] >= n[2]){\n                                addpoint += ncount[0]*ncount[1];\n                                for(int k=delsta;k<delsta+ncount[1];k++){\n                                    if(delsta < 0) break;\n                                    map2[i,k] = 0;\n                                }\n                            }\n                                ncount[0] = map2[i,j];\n                                ncount[1] = 1;\n                                delsta = j;\n                        }\n                    }\n                }\n                if(addpoint > 0){\n                    point += addpoint * mul;\n                    mul *= 2;\n                }else{\n                    break;\n                }\n                \n                \n            }\n            \n            ans = Max(ans,point);\n            nowsel[0]++;\n            if(nowsel[0] == n[0]){\n                nowsel[0] = 0;\n                nowsel[1]++;\n            }\n        }\n        WriteLine(ans);\n\t\n\t\n    }\n    public static void swap(ref int a,ref int b){int temp = a;a= b;b = temp;}\n    static void charswap(ref char a,ref char b){char temp = a;a= b;b = temp;}\n    static int ncr(int n,int r){if(n<r)return 0;r = Min(r,n-r);long nn = 1;for(int i=n-r+1;i<=n;i++){nn = nn*i%mod;}long rr = 1;for(int i=1;i<=r;i++){rr = rr*i%mod;}rr = square((int)rr,mod-2);nn = nn * rr %mod;return (int)nn;}\n    // a^b mod\n    static int square(int a,int b){string binary = Convert.ToString(b,2);int bileng = binary.Length;long a_power = a;long value = 1;for(int i=bileng-1;i>=0;i--){if(binary[i] == '1'){value = value*a_power%mod;}a_power = a_power*a_power%mod;}return (int)value;}\n    static int square2(int a,int b){long output = 1;var list = new List<long>();int sh = 1;long n = a;list.Add(a);while(sh < b){sh *= 2;n = n*n%mod;list.Add(n);}for(int i=list.Count-1;i>=0;i--){if(b > sh){b -= sh;sh /= 2;output = output*list[i]%mod;}}return (int)output;}\n    //各種読取\n    static string rstr(){ return ReadLine(); }\n    static int rint(){ return int.Parse(ReadLine()); }\n    static long rlong(){ return long.Parse(ReadLine()); }\n    static string[] stra(){ return ReadLine().Split(' '); }\n    static char[] chara(){ string[] a=stra();string b=\"\";for(int i=0;i<a.Length;i++){b+=a[i];}return b.ToCharArray();}\n    static int[] inta(){ string[] read_str_array = ReadLine().Split(' '); int[] return_int_array = new int[read_str_array.Length]; for(int countup_i=0;countup_i<read_str_array.Length;countup_i++){ return_int_array[countup_i] = int.Parse(read_str_array[countup_i]); } return return_int_array; }\n    static int[,] inta2(int num_array,int in_array){ int[,] int_array2 = new int[num_array,in_array]; for(int i=0;i<num_array;i++){ int[] temp_array = inta(); for(int j=0;j<in_array;j++){ int_array2[i,j] = temp_array[j]; } } return int_array2; }\n    static long[] longa(){ string[] read_str_array = ReadLine().Split(' '); long[] return_long_array = new long[read_str_array.Length]; for(long countup_i=0;countup_i<read_str_array.Length;countup_i++){ return_long_array[countup_i] = long.Parse(read_str_array[countup_i]); } return return_long_array; }\n    static double[] doublea(){ string[] read_str_array = ReadLine().Split(' '); double[] return_double_array = new double[read_str_array.Length]; for(long countup_i=0;countup_i<read_str_array.Length;countup_i++){ return_double_array[countup_i] = long.Parse(read_str_array[countup_i]); } return return_double_array; }\n    // -----------------------------\n    static long divideup(long divided,long divid){ long temp_divide = divided/divid; if(divided % divid > 0){ temp_divide++; } return temp_divide; }\n    static long GCD(long a,long b){ if(a < b){ long temp = a; a = b; b = temp; } if(a % b == 0){ return b; } else{ long temp = b; b = a%b; a = temp; return GCD(a,b); } }\n    static long LCM(long a,long b){ return a * b / GCD(a,b); }\n    static void WriteArray(int[,] a,int b,int c){for(int i=0;i<b;i++){for(int j=0;j<c;j++){if(j!=0) Write(\" \");Write(a[i,j]);}WriteLine();}}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Collections.Specialized;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Linq;\n\npublic class Magatro\n{\n    static int H, W, K;\n    static int[][] c;\n    static void Main()\n    {\n        string[] q = Console.ReadLine().Split(' ');\n        H = int.Parse(q[0]);\n        W = int.Parse(q[1]);\n        K = int.Parse(q[2]);\n        c = new int[H][];\n        for(int i = 0; i < H; i++)\n        {\n            c[i] = Console.ReadLine().Select(s => int.Parse(s.ToString())).ToArray();\n        }\n        int max = 0;\n        for(int i = 0; i < W; i++)\n        {\n            int cnt = 0;\n            \n            int[] e = new int[W];\n            e[i] = 1;\n            for(int k = 1; k < H; k++)\n            {\n                int r = c[k][0 + e[0]];\n                bool a = true;\n                for(int l = 1; l < W; l++)\n                {\n                    if (c[k][l + e[l] ]!= r)\n                    {\n                        a = false;\n                        break;\n                    }\n                }\n                if (a)\n                {\n                    cnt += r * W;\n                }\n            }\n            max = Math.Max(max, cnt);\n        }\n        Console.WriteLine(max);\n    }\n   \n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace square869120_3B\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var HWK = ReadInt();\n            int H = HWK[0];\n            int W = HWK[1];\n            int K = HWK[2];\n\n            //読み込み\n            int[,] map = new int[H, W];\n            for (int i = 0; i < H; i++)\n            {\n                var input = Console.ReadLine();\n                for (int j = 0; j < W; j++)\n                {\n                    map[H - 1 - i, j] = int.Parse(input[j].ToString());\n                }\n            }\n\n            int[,] mapCopy = new int[H, W];\n            Array.Copy(map, mapCopy, map.Length);\n            long ans = 0;\n\n            for (int h = 0; h < H; h++)\n            {\n                for (int w = 0; w < W; w++)\n                {\n                    int cont = 0;\n                    long cand = 0;\n                    Array.Copy(mapCopy, map, mapCopy.Length);\n                    map[h, w] = 0;\n\n                    while (true)\n                    {\n                        // 下に詰める\n                        int[,] nextMap = new int[H, W];\n                        for (int i = 0; i < W; i++)\n                        {\n                            int index = 0;\n                            for (int j = 0; j < H; j++)\n                            {\n                                if (map[j, i] == 0) continue;\n                                nextMap[index, i] = map[j, i];\n                                index++;\n                            }\n                        }\n                        map = nextMap;\n\n                        bool banish = false;\n\n                        for (int i = 0; i < H; i++)\n                        {\n                            for (int k = 0; k < W + 1 - K; k++)//スタート\n                            {\n                                if (map[i, k] == 0) continue;\n                                int count = 1;\n                                for (int j = k + 1; j < W; j++)//連続\n                                {\n                                    if (map[i, j] == map[i, k])\n                                    {\n                                        count++; continue;\n                                    }\n                                    else break;\n                                }\n                                if (count >= K)//削除の処理\n                                {\n                                    cand += (long)Math.Pow(2, cont) * count * map[i, k];\n\n                                    for (int j = k; j < k + count; j++)\n                                    {\n                                        map[i, j] = 0;\n                                    }\n                                    banish = true;\n                                    break;\n                                }\n                            }\n                        }\n\n                        if (!banish) break;\n                        cont++;\n                    }\n\n                    ans = Math.Max(cand, ans);\n                }\n            }\n\n            Console.WriteLine(ans);\n\n            Console.ReadKey();\n        }\n\n        static int[] ReadInt()\n        {\n            int[] ret = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            return ret;\n        }\n        static long[] ReadLong()\n        {\n            long[] ret = Console.ReadLine().Split().Select(long.Parse).ToArray();\n            return ret;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing static System.Console;\nusing static System.Math;\n \npublic class Solve{\n    static public int mod = 1000000007;\n    static public string al = \"abcdefghijklmnopqrstuvwxyz\";\n    public static void Main(){\n        // 方針\n        //\n        var tn = inta();\n        var t = tn[0];\n        var y = tn[1];\n        var del = tn[2];\n        var map = new int[t,y+1];\n        for(int i=0;i<t;i++){\n            var a = rstr();\n            for(int j=0;j<y;j++){\n                map[i,j] = int.Parse(a[j].ToString());\n            }\n        }\n        \n        long ans = 0;\n        \n        //var tt = 3;\n        //var ty = 1;\n        for(int tate=0;tate<t;tate++){\n            for(int yoko=0;yoko<y;yoko++){\n                //WriteLine($\"{tate} {yoko}\");\n                \n                var tempmap = new int[t,y+1];\n                for(int i=0;i<t;i++){\n                    for(int j=0;j<y;j++){\n                        tempmap[i,j] = map[i,j];\n                    }\n                }\n                tempmap[tate,yoko] = 0;\n                \n                fall(ref tempmap,t,y);\n                \n                long score = 0;\n                long multi = 1;\n                while(delete(ref tempmap,del,t,y,ref score,ref multi)){\n                    fall(ref tempmap,t,y);\n                    /*\n                    for(int i=0;i<t;i++){\n                        for(int j=0;j<y;j++){\n                            Write($\"{tempmap[i,j]} \");\n                        }\n                        WriteLine();\n                    }\n                    WriteLine(\"-----------------------\");\n                    */\n                }\n                \n                ans = Max(ans,score);\n            }\n        }\n        WriteLine(ans);\n\t\n\t\n    }\n    static bool delete(ref int[,] map,int K,int t,int y,ref long score,ref long multi){\n        var ret = false;\n        long sum = 0;\n        for(int i=0;i<t;i++){\n            var num = -1;\n            var count = 0;\n            var dellist = new List<int>();\n            for(int j=0;j<=y;j++){\n                if(j == 0){\n                    num = map[i,j];\n                    count = 1;\n                    dellist.Add(j);\n                    continue;\n                }\n                if(map[i,j] != num || map[i,j] == 0){\n                    //WriteLine($\"{i} {j} {num} {count} {K} {sum} 2\");\n                    if(count >= K){\n                        sum += num * count;\n                        ret = true;\n                        for(int d=0;d<dellist.Count;d++){\n                            map[i,dellist[d]] = 0;\n                        }\n                    }\n                    num = map[i,j];\n                    count = 1;\n                    dellist.Clear();\n                    dellist.Add(j);\n                }else if(map[i,j] == num){\n                    //WriteLine($\"{i} {j} {num} {count} {K} {sum} 1\");\n                    count++;\n                    dellist.Add(j);\n                }\n                //WriteLine($\"{i} {j} {num} {count} {K} {sum}\");\n            }\n        }\n        score += sum * multi;\n        multi *= 2;\n        return ret;\n    }\n    \n    static void fall(ref int[,] map,int t,int y){\n        for(int i=0;i<y;i++){\n            var list = new List<int>();\n            for(int j=t-1;j>=0;j--){\n                if(map[j,i] > 0) list.Add(map[j,i]);\n            }\n            while(list.Count < t) list.Add(0);\n            for(int j=t-1;j>=0;j--){\n                map[j,i] = list[t-1-j];\n            }\n        }\n    }\n    \n    public static void swap(ref int a,ref int b){int temp = a;a= b;b = temp;}\n    static void charswap(ref char a,ref char b){char temp = a;a= b;b = temp;}\n    static int ncr(int n,int r){if(n<r)return 0;r = Min(r,n-r);long nn = 1;for(int i=n-r+1;i<=n;i++){nn = nn*i%mod;}long rr = 1;for(int i=1;i<=r;i++){rr = rr*i%mod;}rr = square((int)rr,mod-2);nn = nn * rr %mod;return (int)nn;}\n    // a^b mod\n    static int square(int a,int b){string binary = Convert.ToString(b,2);int bileng = binary.Length;long a_power = a;long value = 1;for(int i=bileng-1;i>=0;i--){if(binary[i] == '1'){value = value*a_power%mod;}a_power = a_power*a_power%mod;}return (int)value;}\n    static int square2(int a,int b){long output = 1;var list = new List<long>();int sh = 1;long n = a;list.Add(a);while(sh < b){sh *= 2;n = n*n%mod;list.Add(n);}for(int i=list.Count-1;i>=0;i--){if(b > sh){b -= sh;sh /= 2;output = output*list[i]%mod;}}return (int)output;}\n    //各種読取\n    static string rstr(){ return ReadLine(); }\n    static int rint(){ return int.Parse(ReadLine()); }\n    static long rlong(){ return long.Parse(ReadLine()); }\n    static string[] stra(){ return ReadLine().Split(' '); }\n    static char[] chara(){ string[] a=stra();string b=\"\";for(int i=0;i<a.Length;i++){b+=a[i];}return b.ToCharArray();}\n    static int[] inta(){ string[] read_str_array = ReadLine().Split(' '); int[] return_int_array = new int[read_str_array.Length]; for(int countup_i=0;countup_i<read_str_array.Length;countup_i++){ return_int_array[countup_i] = int.Parse(read_str_array[countup_i]); } return return_int_array; }\n    static int[,] inta2(int num_array,int in_array){ int[,] int_array2 = new int[num_array,in_array]; for(int i=0;i<num_array;i++){ int[] temp_array = inta(); for(int j=0;j<in_array;j++){ int_array2[i,j] = temp_array[j]; } } return int_array2; }\n    static long[] longa(){ string[] read_str_array = ReadLine().Split(' '); long[] return_long_array = new long[read_str_array.Length]; for(long countup_i=0;countup_i<read_str_array.Length;countup_i++){ return_long_array[countup_i] = long.Parse(read_str_array[countup_i]); } return return_long_array; }\n    static double[] doublea(){ string[] read_str_array = ReadLine().Split(' '); double[] return_double_array = new double[read_str_array.Length]; for(long countup_i=0;countup_i<read_str_array.Length;countup_i++){ return_double_array[countup_i] = double.Parse(read_str_array[countup_i]); } return return_double_array; }\n    // -----------------------------\n    static long GCD(long a,long b){ if(a < b){ long temp = a; a = b; b = temp; } if(a % b == 0){ return b; } else{ long temp = b; b = a%b; a = temp; return GCD(a,b); } }\n    static long LCM(long a,long b){ return a * b / GCD(a,b); }\n    static void WriteArray(int[,] a,int b,int c){for(int i=0;i<b;i++){for(int j=0;j<c;j++){if(j!=0) Write(\" \");Write(a[i,j]);}WriteLine();}}\n}"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx OPT\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           ;; enclose the form with VALUES to avoid being captured by LOOP macro\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n#-swank (disable-debugger) ; for CS Academy\n\n;; BEGIN_INSERTED_CONTENTS\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(defun solve (cs h w init-y init-x k)\n  (declare #.OPT\n           ((simple-array uint8 (* *)) cs)\n           (uint8 h w init-y init-x k))\n  (labels ((drop ()\n             (dotimes (col w)\n               (let ((level (- h 1)))\n                 (loop for row from (- h 1) downto 0\n                       when (> (aref cs row col) 0)\n                       do (rotatef (aref cs row col) (aref cs level col))\n                          (decf level)))))\n           (erase (turn)\n             (let ((weight 0))\n               (declare (uint62 weight))\n               (dotimes (row h)\n                 (let ((prev 0))\n                   (loop for col to w\n                         do (when (or (zerop (aref cs row col))\n                                      (/= (aref cs row prev) (aref cs row col)))\n                              (when (>= (- col prev) k)\n                                (incf weight (* (aref cs row prev) (- col prev)))\n                                (loop for j from prev below col\n                                      do (setf (aref cs row j) 0)))\n                              (setq prev col)))))\n               (* (ash 1 turn) weight))))\n    (setf (aref cs init-y init-x) 0)\n    (drop)\n    (loop for turn from 0\n          for delta = (erase turn)\n          while (> delta 0)\n          sum delta\n          do (drop))))\n\n(defun main ()\n  (let* ((h (read))\n         (w (read))\n         (k (read))\n         (init-cs (make-array (list h (+ w 1)) :element-type 'uint8 :initial-element #xff))\n         (cs (make-array (list h (+ w 1)) :element-type 'uint8))\n         (res 0))\n    (dotimes (y h)\n      (dotimes (x w (read-char))\n        (setf (aref init-cs y x) (digit-char-p (read-char)))))\n    (dotimes (y h)\n      (dotimes (x w)\n        (replace (array-storage-vector cs) (array-storage-vector init-cs))\n        (setq res (max res (solve cs h w y x k)))))\n    (println res)))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"4 4 2\n3413\n4121\n1424\n2312\n\"\n    \"23\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"4 4 2\n1212\n2121\n1212\n2121\n\"\n    \"54\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"7 7 2\n8989898\n9898989\n8989898\n9898989\n8989898\n9898989\n8989898\n\"\n    \"2520\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"17 17 2\n12345678912345678\n23456789123456789\n34567891234567891\n45678912345678912\n56789123456789123\n67891234567891234\n78912345678912345\n89123456789123456\n91234567891234567\n12345678912345678\n23456789123456789\n34567891234567891\n45678912345678912\n56789123456789123\n67891234567891234\n78912345678912345\n89123456789123456\n\"\n    \"2354638\n\")))\n"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx OPT\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           ;; enclose the form with VALUES to avoid being captured by LOOP macro\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n#-swank (disable-debugger) ; for CS Academy\n\n;; BEGIN_INSERTED_CONTENTS\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(defun solve (cs h w init-y init-x k)\n  (declare #.OPT\n           ((simple-array uint8 (* *)) cs)\n           (uint8 h w init-y init-x k))\n  (labels ((drop ()\n             (dotimes (col w)\n               (let ((level (- h 1)))\n                 (loop for row from (- h 1) downto 0\n                       when (> (aref cs row col) 0)\n                       do (rotatef (aref cs row col) (aref cs level col))\n                          (decf level)))))\n           (erase (turn)\n             (declare (uint8 turn)\n                      (values uint62))\n             (let ((weight 0))\n               (declare (uint62 weight))\n               (dotimes (row h)\n                 (let ((prev 0))\n                   (loop for col to w\n                         do (when (or (zerop (aref cs row col))\n                                      (/= (aref cs row prev) (aref cs row col)))\n                              (when (>= (- col prev) k)\n                                (incf weight (* (aref cs row prev) (- col prev)))\n                                (loop for j from prev below col\n                                      do (setf (aref cs row j) 0)))\n                              (setq prev col)))))\n               (* (ash 1 turn) weight))))\n    (setf (aref cs init-y init-x) 0)\n    (drop)\n    (loop for turn from 0\n          for delta = (erase turn)\n          while (> delta 0)\n          sum delta\n          do (drop))))\n\n(defun main ()\n  (let* ((h (read))\n         (w (read))\n         (k (read))\n         (init-cs (make-array (list h (+ w 1)) :element-type 'uint8 :initial-element #xff))\n         (cs (make-array (list h (+ w 1)) :element-type 'uint8))\n         (res 0))\n    (dotimes (y h)\n      (dotimes (x w (read-char))\n        (setf (aref init-cs y x) (digit-char-p (read-char)))))\n    (dotimes (y h)\n      (dotimes (x w)\n        (replace (array-storage-vector cs) (array-storage-vector init-cs))\n        (setq res (max res (solve cs h w y x k)))))\n    (println res)))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"4 4 2\n3413\n4121\n1424\n2312\n\"\n    \"23\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"4 4 2\n1212\n2121\n1212\n2121\n\"\n    \"54\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"7 7 2\n8989898\n9898989\n8989898\n9898989\n8989898\n9898989\n8989898\n\"\n    \"2520\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"17 17 2\n12345678912345678\n23456789123456789\n34567891234567891\n45678912345678912\n56789123456789123\n67891234567891234\n78912345678912345\n89123456789123456\n91234567891234567\n12345678912345678\n23456789123456789\n34567891234567891\n45678912345678912\n56789123456789123\n67891234567891234\n78912345678912345\n89123456789123456\n\"\n    \"2354638\n\")))\n"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx OPT\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           ;; enclose the form with VALUES to avoid being captured by LOOP macro\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n#-swank (disable-debugger) ; for CS Academy\n\n;; BEGIN_INSERTED_CONTENTS\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(defun solve (cs h w init-y init-x k)\n  (declare #.OPT\n           ((simple-array uint8 (* *)) cs)\n           (uint8 h w init-y init-x k))\n  (labels\n      ((drop ()\n         (dotimes (col w)\n           (let ((level (- h 1)))\n             (loop for row from (- h 1) downto 0\n                   for value = (aref cs row col)\n                   when (> value 0)\n                   do (rotatef (aref cs row col) (aref cs level col))\n                      (decf level)))))\n       (erase (turn)\n         (declare (uint8 turn)\n                  (values uint62))\n         (let ((weight 0))\n           (declare (uint62 weight))\n           (dotimes (row h)\n             (let ((prev 0))\n               (loop for col to w\n                     do (when (or (zerop (aref cs row col))\n                                  (/= (aref cs row prev) (aref cs row col)))\n                          (when (>= (- col prev) k)\n                            (incf weight (* (aref cs row prev) (- col prev)))\n                            (loop for j from prev below col\n                                  do (setf (aref cs row j) 0)))\n                          (setq prev col)))))\n           (* (ash 1 turn) weight))))\n    (setf (aref cs init-y init-x) 0)\n    (drop)\n    (loop for turn from 0\n          for delta = (erase turn)\n          while (> delta 0)\n          sum delta\n          do (drop))))\n\n(defun main ()\n  (let* ((h (read))\n         (w (read))\n         (k (read))\n         (init-cs (make-array (list h (+ w 1)) :element-type 'uint8 :initial-element #xff))\n         (cs (make-array (list h (+ w 1)) :element-type 'uint8))\n         (res 0))\n    (dotimes (y h)\n      (dotimes (x w (read-char))\n        (setf (aref init-cs y x) (digit-char-p (read-char)))))\n    (dotimes (y h)\n      (dotimes (x w)\n        (replace (array-storage-vector cs) (array-storage-vector init-cs))\n        (setq res (max res (solve cs h w y x k)))))\n    (println res)))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"4 4 2\n3413\n4121\n1424\n2312\n\"\n    \"23\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"4 4 2\n1212\n2121\n1212\n2121\n\"\n    \"54\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"7 7 2\n8989898\n9898989\n8989898\n9898989\n8989898\n9898989\n8989898\n\"\n    \"2520\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"17 17 2\n12345678912345678\n23456789123456789\n34567891234567891\n45678912345678912\n56789123456789123\n67891234567891234\n78912345678912345\n89123456789123456\n91234567891234567\n12345678912345678\n23456789123456789\n34567891234567891\n45678912345678912\n56789123456789123\n67891234567891234\n78912345678912345\n89123456789123456\n\"\n    \"2354638\n\")))\n"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx OPT\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           ;; enclose the form with VALUES to avoid being captured by LOOP macro\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n#-swank (disable-debugger) ; for CS Academy\n\n;; BEGIN_INSERTED_CONTENTS\n(declaim (inline print-matrix))\n(defun print-matrix (array &key (separator #\\ ) (key #'identity) (row-start 0) row-end (col-start 0) col-end)\n  (declare ((array * (* *)) array)\n           ((integer 0 #.most-positive-fixnum) row-start col-start))\n  (let ((row-end (or row-end (array-dimension array 0)))\n        (col-end (or col-end (array-dimension array 1))))\n    (declare ((integer 0 #.most-positive-fixnum) row-end col-end))\n    (loop for i from row-start below row-end\n          do (loop for j from col-start below col-end\n                   do (unless (= j col-start)\n                        (princ separator))\n                      (write (funcall key (aref array i j))))\n          (terpri))))\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(defun solve (cs h w init-y init-x)\n  (declare ((simple-array uint8 (* *)) cs)\n           (uint8 h w init-y init-x))\n  (labels\n      ((drop ()\n         (dotimes (col w)\n           (let ((level (- h 1)))\n             (loop for row from (- h 1) downto 0\n                   for value = (aref cs row col)\n                   do (when (> value 0)\n                        (setf (aref cs row col) 0\n                              (aref cs level col) value)\n                        (decf level))))))\n       (erase (turn)\n         (declare (uint8 turn)\n                  (values uint62))\n         (let ((weight 0))\n           (declare (uint62 weight))\n           (dotimes (row h)\n             (let ((prev 0))\n               (loop for col from 1 below w\n                     do (when (or (zerop (aref cs row col))\n                                  (/= (aref cs row prev) (aref cs row col)))\n                          (when (>= (- col prev) 2)\n                            (incf weight (* (aref cs row prev) (- col prev)))\n                            (loop for j from prev below col\n                                  do (setf (aref cs row j) 0)))\n                          (setq prev col))\n                     finally (when (>= (- col prev) 2)\n                               (incf weight (* (aref cs row prev) (- col prev)))\n                               (loop for j from prev below col\n                                     do (setf (aref cs row j) 0))))))\n           (* (ash 1 turn) weight))))\n    (let ((res 0))\n      (declare (uint62 res))\n      (setf (aref cs init-y init-x) 0)\n      (drop)\n      ;; (print-matrix cs :separator \"\")\n      (loop for turn from 0\n            for delta = (erase turn)\n            while (> delta 0)\n            do (incf res delta)\n               (drop)\n               ;; (print-matrix cs :separator \"\")\n               ;; (terpri)\n            )\n      res)))\n\n(defun main ()\n  (let* ((h (read))\n         (w (read))\n         (k (read))\n         (original-cs (make-array (list h w) :element-type 'uint8))\n         (cs (make-array (list h w) :element-type 'uint8))\n         (res 0))\n    (dotimes (y h)\n      (let ((line (read-line)))\n        (dotimes (x w)\n          (setf (aref original-cs y x)\n                (digit-char-p (aref line x))))))\n    (dotimes (y h)\n      (dotimes (x w)\n        (replace (array-storage-vector cs) (array-storage-vector original-cs))\n        (setq res (max res (solve cs h w y x)))))\n    (println res)))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"4 4 2\n3413\n4121\n1424\n2312\n\"\n    \"23\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"4 4 2\n1212\n2121\n1212\n2121\n\"\n    \"54\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"7 7 2\n8989898\n9898989\n8989898\n9898989\n8989898\n9898989\n8989898\n\"\n    \"2520\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"17 17 2\n12345678912345678\n23456789123456789\n34567891234567891\n45678912345678912\n56789123456789123\n67891234567891234\n78912345678912345\n89123456789123456\n91234567891234567\n12345678912345678\n23456789123456789\n34567891234567891\n45678912345678912\n56789123456789123\n67891234567891234\n78912345678912345\n89123456789123456\n\"\n    \"2354638\n\")))\n"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx OPT\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           ;; enclose the form with VALUES to avoid being captured by LOOP macro\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n#-swank (disable-debugger) ; for CS Academy\n\n;; BEGIN_INSERTED_CONTENTS\n(declaim (inline print-matrix))\n(defun print-matrix (array &key (separator #\\ ) (key #'identity) (row-start 0) row-end (col-start 0) col-end)\n  (declare ((array * (* *)) array)\n           ((integer 0 #.most-positive-fixnum) row-start col-start))\n  (let ((row-end (or row-end (array-dimension array 0)))\n        (col-end (or col-end (array-dimension array 1))))\n    (declare ((integer 0 #.most-positive-fixnum) row-end col-end))\n    (loop for i from row-start below row-end\n          do (loop for j from col-start below col-end\n                   do (unless (= j col-start)\n                        (princ separator))\n                      (write (funcall key (aref array i j))))\n          (terpri))))\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(defun solve (cs h w init-y init-x k)\n  (declare ((simple-array uint8 (* *)) cs)\n           (uint8 h w init-y init-x))\n  (labels\n      ((drop ()\n         (dotimes (col w)\n           (let ((level (- h 1)))\n             (loop for row from (- h 1) downto 0\n                   for value = (aref cs row col)\n                   do (when (> value 0)\n                        (rotatef (aref cs row col) (aref cs level col))\n                        (decf level))))))\n       (erase (turn)\n         (declare (uint8 turn)\n                  (values uint62))\n         (let ((weight 0))\n           (declare (uint62 weight))\n           (dotimes (row h)\n             (let ((prev 0))\n               (loop for col below w\n                     do (when (or (zerop (aref cs row col))\n                                  (/= (aref cs row prev) (aref cs row col)))\n                          (when (>= (- col prev) k)\n                            (incf weight (* (aref cs row prev) (- col prev)))\n                            (loop for j from prev below col\n                                  do (setf (aref cs row j) 0)))\n                          (setq prev col))\n                     finally (when (>= (- col prev) k)\n                               (incf weight (* (aref cs row prev) (- col prev)))\n                               (loop for j from prev below col\n                                     do (setf (aref cs row j) 0))))))\n           (* (ash 1 turn) weight))))\n    (let ((res 0))\n      (declare (uint62 res))\n      (setf (aref cs init-y init-x) 0)\n      (drop)\n      (loop for turn from 0\n            for delta = (erase turn)\n            while (> delta 0)\n            do (incf res delta)\n               (drop))\n      res)))\n\n(defun main ()\n  (let* ((h (read))\n         (w (read))\n         (k (read))\n         (original-cs (make-array (list h w) :element-type 'uint8))\n         (cs (make-array (list h w) :element-type 'uint8))\n         (res 0))\n    (dotimes (y h)\n      (let ((line (read-line)))\n        (dotimes (x w)\n          (setf (aref original-cs y x)\n                (digit-char-p (aref line x))))))\n    (dotimes (y h)\n      (dotimes (x w)\n        (replace (array-storage-vector cs)\n                 (array-storage-vector original-cs))\n        (setq res (max res (solve cs h w y x k)))))\n    (println res)))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"4 4 2\n3413\n4121\n1424\n2312\n\"\n    \"23\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"4 4 2\n1212\n2121\n1212\n2121\n\"\n    \"54\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"7 7 2\n8989898\n9898989\n8989898\n9898989\n8989898\n9898989\n8989898\n\"\n    \"2520\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"17 17 2\n12345678912345678\n23456789123456789\n34567891234567891\n45678912345678912\n56789123456789123\n67891234567891234\n78912345678912345\n89123456789123456\n91234567891234567\n12345678912345678\n23456789123456789\n34567891234567891\n45678912345678912\n56789123456789123\n67891234567891234\n78912345678912345\n89123456789123456\n\"\n    \"2354638\n\")))\n"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx OPT\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           ;; enclose the form with VALUES to avoid being captured by LOOP macro\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n#-swank (disable-debugger) ; for CS Academy\n\n;; BEGIN_INSERTED_CONTENTS\n(declaim (inline print-matrix))\n(defun print-matrix (array &key (separator #\\ ) (key #'identity) (row-start 0) row-end (col-start 0) col-end)\n  (declare ((array * (* *)) array)\n           ((integer 0 #.most-positive-fixnum) row-start col-start))\n  (let ((row-end (or row-end (array-dimension array 0)))\n        (col-end (or col-end (array-dimension array 1))))\n    (declare ((integer 0 #.most-positive-fixnum) row-end col-end))\n    (loop for i from row-start below row-end\n          do (loop for j from col-start below col-end\n                   do (unless (= j col-start)\n                        (princ separator))\n                      (write (funcall key (aref array i j))))\n          (terpri))))\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(defun solve (cs h w init-y init-x k)\n  (declare ((simple-array uint8 (* *)) cs)\n           (uint8 h w init-y init-x))\n  (labels\n      ((drop ()\n         (dotimes (col w)\n           (let ((level (- h 1)))\n             (loop for row from (- h 1) downto 0\n                   for value = (aref cs row col)\n                   do (when (> value 0)\n                        (rotatef (aref cs row col) (aref cs level col))\n                        (decf level))))))\n       (erase (turn)\n         (declare (uint8 turn)\n                  (values uint62))\n         (let ((weight 0))\n           (declare (uint62 weight))\n           (dotimes (row h)\n             (let ((prev 0))\n               (loop for col from 1 below w\n                     do (when (or (zerop (aref cs row col))\n                                  (/= (aref cs row prev) (aref cs row col)))\n                          (when (>= (- col prev) k)\n                            (incf weight (* (aref cs row prev) (- col prev)))\n                            (loop for j from prev below col\n                                  do (setf (aref cs row j) 0)))\n                          (setq prev col))\n                     finally (when (>= (- col prev) k)\n                               (incf weight (* (aref cs row prev) (- col prev)))\n                               (loop for j from prev below col\n                                     do (setf (aref cs row j) 0))))))\n           (* (ash 1 turn) weight))))\n    (let ((res 0))\n      (declare (uint62 res))\n      (setf (aref cs init-y init-x) 0)\n      (drop)\n      ;; (print-matrix cs :separator \"\")\n      (loop for turn from 0\n            for delta = (erase turn)\n            while (> delta 0)\n            do (incf res delta)\n               (drop)\n               ;; (print-matrix cs :separator \"\")\n               ;; (terpri)\n            )\n      res)))\n\n(defun main ()\n  (let* ((h (read))\n         (w (read))\n         (k (read))\n         (original-cs (make-array (list h w) :element-type 'uint8))\n         (cs (make-array (list h w) :element-type 'uint8))\n         (res 0))\n    (dotimes (y h)\n      (let ((line (read-line)))\n        (dotimes (x w)\n          (setf (aref original-cs y x)\n                (digit-char-p (aref line x))))))\n    (when (= k 1)\n      (println (- (reduce #'+ (array-storage-vector original-cs))\n                  (reduce #'min (array-storage-vector original-cs))))\n      (return-from main))\n    (dotimes (y h)\n      (dotimes (x w)\n        (replace (array-storage-vector cs)\n                 (array-storage-vector original-cs))\n        (setq res (max res (solve cs h w y x k)))))\n    (println res)))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"4 4 2\n3413\n4121\n1424\n2312\n\"\n    \"23\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"4 4 2\n1212\n2121\n1212\n2121\n\"\n    \"54\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"7 7 2\n8989898\n9898989\n8989898\n9898989\n8989898\n9898989\n8989898\n\"\n    \"2520\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"17 17 2\n12345678912345678\n23456789123456789\n34567891234567891\n45678912345678912\n56789123456789123\n67891234567891234\n78912345678912345\n89123456789123456\n91234567891234567\n12345678912345678\n23456789123456789\n34567891234567891\n45678912345678912\n56789123456789123\n67891234567891234\n78912345678912345\n89123456789123456\n\"\n    \"2354638\n\")))\n"
  },
  {
    "language": "Ruby",
    "code": "H, W, K = gets.split.map(&:to_i)\nc = H.times.map{gets.chomp.chars.map(&:to_i)}\nif K<=1\n  sleep(100)\nend\nc = c.reverse.transpose\ni = 10\nc.each{|cc| W.times{cc<<i; i+=1}}\nc << (H*2).times.map{i+=1}\nC = c\ndef fall\n  @c.each{|cc| cc.compact!}\nend\ndef vanish\n  s = 0\n  (0...H).each do |j|\n    r = -1\n    c = 0\n    (0..W).each do |i|\n      if @c[i][j]==r\n        c += 1\n      else\n        (1..c).each{|l| s += @c[i-l][j]; @c[i-l][j] = nil} if c>=K\n        r = @c[i][j]\n        c = 1\n      end\n    end\n  end\n  fall\n  s\nend\nans = 0\n(0...H).each do |j|\n  (0...W).each do |i|\n    su = 0\n    @c = C.map{|cc| cc.dup}\n    @c[i][j] = nil\n    fall\n    d = 1\n    loop do\n      f = vanish\n      break if f==0\n      su += d*f\n      d *= 2\n    end\n    ans = su if ans < su\n  end\nend\np ans"
  },
  {
    "language": "Ruby",
    "code": "H, W, K = gets.split.map(&:to_i)\nc = H.times.map{gets.chomp.chars.map(&:to_i)}\nc = c.reverse.transpose\ni = 10\nc.each{|cc| W.times{cc<<i; i+=1}}\nc << (H*2).times.map{i+=1}\nC = c\ndef fall\n  @c.each{|cc| cc.compact!}\nend\ndef vanish\n  s = 0\n  (0...H).each do |j|\n    r = -1\n    c = 0\n    (0..W).each do |i|\n      if @c[i][j]==r\n        c += 1\n      else\n        (1..c).each{|l| s += @c[i-l][j]; @c[i-l][j] = nil} if c>=K\n        r = @c[i][j]\n        c = 1\n      end\n    end\n  end\n  fall\n  s\nend\nans = 0\n(0...H).each do |j|\n  (0...W).each do |i|\n    su = 0\n    @c = C.map{|cc| cc.dup}\n    @c[i][j] = nil\n    fall\n    d = 1\n    loop do\n      begin\n        f = vanish\n      rescue\n        sleep 10\n      end\n      break if f==0\n      su += d*f\n      d *= 2\n    end\n    ans = su if ans < su\n  end\nend\np ans"
  },
  {
    "language": "Ruby",
    "code": "H, W, K = gets.split.map(&:to_i)\nc = H.times.map{gets.chomp.chars.map(&:to_i)}\nc = c.reverse.transpose\ni = 10\nc.each{|cc| W.times{cc<<i; i+=1}}\nc << (H*2).times.map{i+=1}\nC = c\ndef fall\n  @c.each{|cc| cc.compact!}\nend\ndef vanish\n  s = 0\n  (0...H).each do |j|\n    r = -1\n    c = 0\n    (0..W).each do |i|\n      if @c[i][j]==r\n        c += 1\n      else\n        (1..c).each{|l| s += @c[i-l][j]; @c[i-l][j] = nil} if c>=K\n        r = @c[i][j]\n        c = 1\n      end\n    end\n  end\n  fall\n  s\nend\nans = 0\n(0...H).each do |j|\n  (0...W).each do |i|\n    su = 0\n    @c = C.map{|cc| cc.dup}\n    @c[i][j] = nil\n    fall\n    d = 1\n    t = 0\n    loop do\n      t += 1\n      if t>=500\n        sleep(10)\n      end\n      f = vanish\n      break if f==0\n      su += d*f\n      d *= 2\n    end\n    ans = su if ans < su\n  end\nend\np ans"
  },
  {
    "language": "Ruby",
    "code": "H, W, K = gets.split.map(&:to_i)\nc = H.times.map{gets.chomp.chars.map(&:to_i)}\nc = c.reverse.transpose\ni = 10\nc.each{|cc| W.times{cc<<i; i+=1}}\nc << (H*2).times.map{i+=1}\nC = c\ndef fall\n  @c.each{|cc| cc.compact!}\nend\ndef vanish\n  s = 0\n  (0...H).each do |j|\n    r = -1\n    c = 0\n    (0..W).each do |i|\n      if @c[i][j]==r\n        c += 1\n      else\n        begin\n          (1..c).each{|l| s += @c[i-l][j]; @c[i-l][j] = nil} if c>=K\n        rescue\n          sleep 10\n        end\n        r = @c[i][j]\n        c = 1\n      end\n    end\n  end\n  fall\n  s\nend\nans = 0\n(0...H).each do |j|\n  (0...W).each do |i|\n    su = 0\n    @c = C.map{|cc| cc.dup}\n    @c[i][j] = nil\n    fall\n    d = 1\n    loop do\n      f = vanish\n      break if f==0\n      su += d*f\n      d *= 2\n    end\n    ans = su if ans < su\n  end\nend\np ans"
  },
  {
    "language": "Ruby",
    "code": "H, W, K = gets.split.map(&:to_i)\nc = H.times.map{gets.chomp.chars.map(&:to_i)}\nif K==1\n  p c.flatten.sort[1..-1].inject(:+)\n  exit\nend\nc = c.reverse.transpose\ni = 10\nc.each{|cc| W.times{cc<<i; i+=1}}\nc << ([-1]*(H*2))\nC = c\ndef fall\n  @c.each{|cc| cc.compact!}\nend\ndef vanish\n  s = 0\n  (0...H).each do |j|\n    r = -1\n    c = 0\n    (0..W).each do |i|\n      if @c[i][j]==r\n        c += 1\n      else\n        (1..c).each{|l| s += @c[i-l][j]; @c[i-l][j] = nil} if c>=K\n        r = @c[i][j]\n        c = 1\n      end\n    end\n  end\n  fall\n  s\nend\nans = 0\n(0...H).each do |j|\n  (0...W).each do |i|\n    su = 0\n    @c = C.map{|cc| cc.dup}\n    @c[i][j] = nil\n    fall\n    d = 1\n    loop do\n      f = vanish\n      break if f==0\n      su += d*f\n      d *= 2\n    end\n    ans = su if ans < su\n  end\nend\np ans"
  },
  {
    "language": "Ruby",
    "code": "H, W, K = gets.split.map(&:to_i)\nc = H.times.map{gets.chomp.chars.map(&:to_i)}\nc = c.reverse.transpose\ni = 10\nc.each{|cc| W.times{cc<<i; i+=1}}\nc << (H*2).times.map{i+=1}\nC = c\ndef fall\n  @c.each{|cc| cc.compact!}\nend\ndef vanish\n  s = 0\n  (0...H).each do |j|\n    r = -1\n    c = 0\n    (0..W).each do |i|\n      if @c[i][j]==r\n        c += 1\n      else\n        begin\n          (1..c).each{|l| s += @c[i-l][j]; @c[i-l][j] = nil} if c>=K\n        rescue\n        end\n        r = @c[i][j]\n        c = 1\n      end\n    end\n  end\n  fall\n  s\nend\nans = 0\n(0...H).each do |j|\n  (0...W).each do |i|\n    su = 0\n    @c = C.map{|cc| cc.dup}\n    @c[i][j] = nil\n    fall\n    d = 1\n    loop do\n      f = vanish\n      break if f==0\n      su += d*f\n      d *= 2\n    end\n    ans = su if ans < su\n  end\nend\np ans"
  },
  {
    "language": "Go",
    "code": "/*\nURL:\nhttps://atcoder.jp/contests/s8pc-3/tasks/s8pc_3_b\n*/\n\npackage main\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar (\n\th, w, k int\n\tC       [][]rune\n\tB       [][]rune\n)\n\nfunc main() {\n\tdefer stdout.Flush()\n\n\th, w, k = readi3()\n\tfor i := 0; i < h; i++ {\n\t\trow := readrs()\n\t\tC = append(C, row)\n\t}\n\n\tans := 0\n\tfor i := 0; i < h; i++ {\n\t\tfor j := 0; j < w; j++ {\n\t\t\tChMax(&ans, solve(i, j))\n\t\t}\n\t}\n\tPrintfBufStdout(\"%d\\n\", ans)\n}\n\nfunc solve(y, x int) int {\n\tres := 0\n\tB = deepCopy()\n\n\tB[y][x] = '0'\n\n\tfor i := 0; i < 100000; i++ {\n\t\tprocess()\n\n\t\tscore := remove(i)\n\n\t\tif score == 0 {\n\t\t\tbreak\n\t\t}\n\t\tres += score\n\t}\n\n\treturn res\n}\n\nfunc process() {\n\tvar rec func(y, x int)\n\n\trec = func(y, x int) {\n\t\tif y == h-1 {\n\t\t\treturn\n\t\t}\n\n\t\tif B[y+1][x] != '0' {\n\t\t\treturn\n\t\t}\n\n\t\tB[y][x], B[y+1][x] = B[y+1][x], B[y][x]\n\t\trec(y+1, x)\n\t}\n\n\tfor j := 0; j < w; j++ {\n\t\tfor i := h - 1; i >= 0; i-- {\n\t\t\tif B[i][j] != '0' {\n\t\t\t\trec(i, j)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc remove(a int) int {\n\tres := 0\n\tco := PowInt(2, a)\n\n\tfor i := 0; i < h; i++ {\n\t\tuf := NewUnionFind(w)\n\t\tfor j := 0; j < w-1; j++ {\n\t\t\tif B[i][j] == B[i][j+1] {\n\t\t\t\tuf.Unite(j, j+1)\n\t\t\t}\n\t\t}\n\n\t\tfor j := 0; j < w; j++ {\n\t\t\tif uf.CcSize(j) >= k && B[i][j] != '0' {\n\t\t\t\tval := int(B[i][j] - '0')\n\t\t\t\tnum := uf.CcSize(j)\n\t\t\t\tres += co * val * num\n\n\t\t\t\tfor k := 0; k < w; k++ {\n\t\t\t\t\tif uf.Same(j, k) {\n\t\t\t\t\t\tB[i][k] = '0'\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res\n}\n\nfunc deepCopy() [][]rune {\n\tnewC := [][]rune{}\n\tfor i := 0; i < h; i++ {\n\t\trow := make([]rune, w)\n\t\tfor j := 0; j < w; j++ {\n\t\t\trow[j] = C[i][j]\n\t\t}\n\t\tnewC = append(newC, row)\n\t}\n\treturn newC\n}\n\n// ChMax accepts a pointer of integer and a target value.\n// If target value is LARGER than the first argument,\n//\tthen the first argument will be updated by the second argument.\nfunc ChMax(updatedValue *int, target int) bool {\n\tif *updatedValue < target {\n\t\t*updatedValue = target\n\t\treturn true\n\t}\n\treturn false\n}\n\n// 0-based\n// uf := NewUnionFind(n)\n// uf.Root(x) \t\t\t// Get root node of the node x\n// uf.Unite(x, y) \t// Unite node x and node y\n// uf.Same(x, y) \t\t// Judge x and y are in the same connected component.\n// uf.CcSize(x) \t\t// Get size of the connected component including node x\n// uf.CcNum() \t\t\t// Get number of connected components\n\n// UnionFind provides disjoint set algorithm.\n// Node id starts from 0 (0-based setting).\ntype UnionFind struct {\n\tparents []int\n}\n\n// NewUnionFind returns a pointer of a new instance of UnionFind.\nfunc NewUnionFind(n int) *UnionFind {\n\tuf := new(UnionFind)\n\tuf.parents = make([]int, n)\n\n\tfor i := 0; i < n; i++ {\n\t\tuf.parents[i] = -1\n\t}\n\n\treturn uf\n}\n\n// Root method returns root node of an argument node.\n// Root method is a recursive function.\nfunc (uf *UnionFind) Root(x int) int {\n\tif uf.parents[x] < 0 {\n\t\treturn x\n\t}\n\n\t// route compression\n\tuf.parents[x] = uf.Root(uf.parents[x])\n\treturn uf.parents[x]\n}\n\n// Unite method merges a set including x and a set including y.\nfunc (uf *UnionFind) Unite(x, y int) bool {\n\txp := uf.Root(x)\n\typ := uf.Root(y)\n\n\tif xp == yp {\n\t\treturn false\n\t}\n\n\t// merge: xp -> yp\n\t// merge larger set to smaller set\n\tif uf.CcSize(xp) > uf.CcSize(yp) {\n\t\txp, yp = yp, xp\n\t}\n\t// update set size\n\tuf.parents[yp] += uf.parents[xp]\n\t// finally, merge\n\tuf.parents[xp] = yp\n\n\treturn true\n}\n\n// Same method returns whether x is in the set including y or not.\nfunc (uf *UnionFind) Same(x, y int) bool {\n\treturn uf.Root(x) == uf.Root(y)\n}\n\n// CcSize method returns the size of a set including an argument node.\nfunc (uf *UnionFind) CcSize(x int) int {\n\treturn -uf.parents[uf.Root(x)]\n}\n\n// CcNum method returns the number of connected components.\n// Time complextity is O(n)\nfunc (uf *UnionFind) CcNum() int {\n\tres := 0\n\tfor i := 0; i < len(uf.parents); i++ {\n\t\tif uf.parents[i] < 0 {\n\t\t\tres++\n\t\t}\n\t}\n\treturn res\n}\n\n// PowInt is integer version of math.Pow\n// PowInt calculate a power by Binary Power (二分累乗法(O(log e))).\nfunc PowInt(a, e int) int {\n\tif a < 0 || e < 0 {\n\t\tpanic(errors.New(\"[argument error]: PowInt does not accept negative integers\"))\n\t}\n\n\tif e == 0 {\n\t\treturn 1\n\t}\n\n\tif e%2 == 0 {\n\t\thalfE := e / 2\n\t\thalf := PowInt(a, halfE)\n\t\treturn half * half\n\t}\n\n\treturn a * PowInt(a, e-1)\n}\n\n/*******************************************************************/\n\n/********** common constants **********/\n\nconst (\n\t// General purpose\n\tMOD = 1000000000 + 7\n\t// MOD          = 998244353\n\tALPHABET_NUM = 26\n\tINF_INT64    = math.MaxInt64\n\tINF_BIT60    = 1 << 60\n\tINF_INT32    = math.MaxInt32\n\tINF_BIT30    = 1 << 30\n\tNIL          = -1\n\n\t// for dijkstra, prim, and so on\n\tWHITE = 0\n\tGRAY  = 1\n\tBLACK = 2\n)\n\n// modint can calculate a right residual whether value is positive or negative.\nfunc modint(val, m int) int {\n\tres := val % m\n\tif res < 0 {\n\t\tres += m\n\t}\n\treturn res\n}\n\n// modll can calculate a right residual whether value is positive or negative.\nfunc modll(val, m int64) int64 {\n\tres := val % m\n\tif res < 0 {\n\t\tres += m\n\t}\n\treturn res\n}\n\n/********** bufio setting **********/\n\nfunc init() {\n\t// bufio.ScanWords <---> bufio.ScanLines\n\treads = newReadString(os.Stdin, bufio.ScanWords)\n\tstdout = bufio.NewWriter(os.Stdout)\n}\n\n/********** FAU standard libraries **********/\n\n//fmt.Sprintf(\"%b\\n\", 255) \t// binary expression\n\n/********** I/O usage **********/\n\n//str := reads()\n//i := readi()\n//X := readis(n)\n//S := readrs()\n//a := readf()\n//A := readfs(n)\n\n//str := ZeroPaddingRuneSlice(num, 32)\n//str := PrintIntsLine(X...)\n\n/*********** Input ***********/\n\nvar (\n\t// reads returns a WORD string.\n\treads  func() string\n\tstdout *bufio.Writer\n)\n\nfunc newReadString(ior io.Reader, sf bufio.SplitFunc) func() string {\n\tr := bufio.NewScanner(ior)\n\tr.Buffer(make([]byte, 1024), int(1e+9)) // for Codeforces\n\tr.Split(sf)\n\n\treturn func() string {\n\t\tif !r.Scan() {\n\t\t\tpanic(\"Scan failed\")\n\t\t}\n\t\treturn r.Text()\n\t}\n}\n\n// readi returns an integer.\nfunc readi() int {\n\treturn int(_readInt64())\n}\nfunc readi2() (int, int) {\n\treturn int(_readInt64()), int(_readInt64())\n}\nfunc readi3() (int, int, int) {\n\treturn int(_readInt64()), int(_readInt64()), int(_readInt64())\n}\nfunc readi4() (int, int, int, int) {\n\treturn int(_readInt64()), int(_readInt64()), int(_readInt64()), int(_readInt64())\n}\n\n// readll returns as integer as int64.\nfunc readll() int64 {\n\treturn _readInt64()\n}\nfunc readll2() (int64, int64) {\n\treturn _readInt64(), _readInt64()\n}\nfunc readll3() (int64, int64, int64) {\n\treturn _readInt64(), _readInt64(), _readInt64()\n}\nfunc readll4() (int64, int64, int64, int64) {\n\treturn _readInt64(), _readInt64(), _readInt64(), _readInt64()\n}\n\nfunc _readInt64() int64 {\n\ti, err := strconv.ParseInt(reads(), 0, 64)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn i\n}\n\n// readis returns an integer slice that has n integers.\nfunc readis(n int) []int {\n\tb := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = readi()\n\t}\n\treturn b\n}\n\n// readlls returns as int64 slice that has n integers.\nfunc readlls(n int) []int64 {\n\tb := make([]int64, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = readll()\n\t}\n\treturn b\n}\n\n// readf returns an float64.\nfunc readf() float64 {\n\treturn float64(_readFloat64())\n}\n\nfunc _readFloat64() float64 {\n\tf, err := strconv.ParseFloat(reads(), 64)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn f\n}\n\n// ReadFloatSlice returns an float64 slice that has n float64.\nfunc readfs(n int) []float64 {\n\tb := make([]float64, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = readf()\n\t}\n\treturn b\n}\n\n// readrs returns a rune slice.\nfunc readrs() []rune {\n\treturn []rune(reads())\n}\n\n/*********** Output ***********/\n\n// PrintIntsLine returns integers string delimited by a space.\nfunc PrintIntsLine(A ...int) string {\n\tres := []rune{}\n\n\tfor i := 0; i < len(A); i++ {\n\t\tstr := strconv.Itoa(A[i])\n\t\tres = append(res, []rune(str)...)\n\n\t\tif i != len(A)-1 {\n\t\t\tres = append(res, ' ')\n\t\t}\n\t}\n\n\treturn string(res)\n}\n\n// PrintIntsLine returns integers string delimited by a space.\nfunc PrintInts64Line(A ...int64) string {\n\tres := []rune{}\n\n\tfor i := 0; i < len(A); i++ {\n\t\tstr := strconv.FormatInt(A[i], 10) // 64bit int version\n\t\tres = append(res, []rune(str)...)\n\n\t\tif i != len(A)-1 {\n\t\t\tres = append(res, ' ')\n\t\t}\n\t}\n\n\treturn string(res)\n}\n\n// PrintfBufStdout is function for output strings to buffered os.Stdout.\n// You may have to call stdout.Flush() finally.\nfunc PrintfBufStdout(format string, a ...interface{}) {\n\tfmt.Fprintf(stdout, format, a...)\n}\n\n/*********** Debugging ***********/\n\n// PrintfDebug is wrapper of fmt.Fprintf(os.Stderr, format, a...)\nfunc PrintfDebug(format string, a ...interface{}) {\n\tfmt.Fprintf(os.Stderr, format, a...)\n}\n\n// ZeroPaddingRuneSlice returns binary expressions of integer n with zero padding.\n// For debugging use.\nfunc ZeroPaddingRuneSlice(n, digitsNum int) []rune {\n\tsn := fmt.Sprintf(\"%b\", n)\n\n\tresidualLength := digitsNum - len(sn)\n\tif residualLength <= 0 {\n\t\treturn []rune(sn)\n\t}\n\n\tzeros := make([]rune, residualLength)\n\tfor i := 0; i < len(zeros); i++ {\n\t\tzeros[i] = '0'\n\t}\n\n\tres := []rune{}\n\tres = append(res, zeros...)\n\tres = append(res, []rune(sn)...)\n\n\treturn res\n}\n"
  },
  {
    "language": "OCaml",
    "code": "open Batteries\nmodule EnumL = Enum.Labels\nmodule ListL = List.Labels\nmodule ArrayL = Array.Labels\n\nlet dbg0 x = Printf.eprintf \"[debug]%s\\n\" @@ dump x\nlet dbg1 x = dbg0 x; x\n\nlet id = identity\n\nlet (++) n m = List.range n `To m\nlet (++-) n m = if n >= m then List.range n `Downto m else []\nlet (++^) n m = if n < m then List.range n `To (pred m) else []\n\nlet scan fmt = Scanf.sscanf (read_line ()) fmt\n\nlet scan_lines n fmt f =\n  if n = 0 then []\n  else List.map (fun _ -> scan fmt f) (1 ++ n)\n\nlet scan_list ?sep cnv =\n  let line = read_line () in\n  (match sep with\n   | None -> List.map String.of_char @@ String.to_list line\n   | Some sep -> String.split_on_char sep line)\n  |> List.map cnv\n\nlet scan_array ?sep cnv = Array.of_list @@ scan_list ?sep cnv\n\nlet scan_matrix n m e ?sep conv =\n  let arr = Array.make_matrix n m e in\n  ListL.iter (0 ++^ n)\n    ~f:(fun i -> arr.(i) <- Array.of_list @@ scan_list ?sep conv);\n  arr\n\nlet rec powerset e =\n  match Enum.get e with\n  | None -> Enum.singleton @@ Enum.empty ()\n  | Some v ->\n    let f = powerset e in\n    let g = Enum.clone f in\n    EnumL.map f ~f:(fun x -> let y = Enum.clone x in push y v; y)\n    |>  Enum.append g\n\nlet permutations l =\n  let rec aux l =\n    let rec interleave x = function\n      | [] -> [[x]]\n      | (hd::tl) as lst ->\n        (x::lst) ::\n        (ListL.map ~f:(List.cons hd)  @@ interleave x tl)\n    in\n    match l with\n    | [] -> [[]]\n    | hd::tl -> List.concat @@ List.map (interleave hd) @@ aux tl in\n  let l = List.sort (List.compare Int.compare) @@ aux @@ List.of_enum l in\n  List.enum % ListL.map ~f:List.enum @@ l\n\nlet intersection l =\n  EnumL.filter ~f:(fun x -> EnumL.exists ~f:((=) x) @@ Enum.clone l)\n\nlet zip l m =\n  let n = min (List.length l) (List.length m) in\n  List.combine (List.take n l) (List.take n m)\n\nlet lower_bound n f =\n  let rec aux l u =\n    if u - l > 1 then\n      let m = (l + u) / 2 in\n      if f m then aux l m\n      else aux m u\n    else u in aux (-1) n\n\nlet between n x m = n <= x && x < m\n\n\nlet (h,w,k) = scan \"%d %d %d\" Tuple3.make\nlet mat = scan_matrix h w 0 Int.of_string\n\nexception Found\n\nlet shrink mat =\n  ListL.iter (0++^ w) ~f:(fun j ->\n      ListL.iter ((pred h) ++- 0) ~f:(fun k ->\n          if mat.(k).(j) = 0 then\n            try ListL.iter ((pred k) ++- 0) ~f:(fun l ->\n                if mat.(l).(j) <> 0 then\n                  (mat.(k).(j) <- mat.(l).(j);\n                   mat.(l).(j) <- 0;\n                   raise Found)) with\n            | Found -> ()))\n\nlet find line =\n  Array.to_list line\n  |>  List.fold_lefti (fun pred i w ->\n      match pred with\n      | [] -> [(w, i, 1)]\n      | (v,s,n)::rest when v = w ->\n        (v,s,succ n) :: rest\n      | _  ->\n        (w,i,1)::pred\n    ) []\n  |> List.filter (fun (_,_,n) -> n >= k)\n\nlet extinct m =\n  ListL.map (0 ++^ h) ~f:(fun i ->\n      let line = m.(i) in\n      match find line with\n      | [] -> 0\n      | _ as ls ->\n        (ListL.map ls ~f:(fun (v, s, n) ->\n             ListL.iter (0 ++^ n) ~f:(fun i -> line.(s+i) <- 0);\n             v*n)\n         |> List.sum))\n  |> List.sum\n\nlet () =\n  ListL.map (0++^h) ~f:(fun i ->\n      ListL.map (0++^w) ~f:(fun j ->\n          (* Printf.printf \"start %d %d\\n\" i j; *)\n          let m = Array.make h [| |] in\n          ListL.iter (0++^h) ~f:(fun i -> m.(i) <- Array.copy mat.(i));\n          m.(i).(j) <- 0;\n          let v = ListL.map (0++h) ~f:(fun n ->\n              shrink m;\n              Int.pow 2 n * extinct m) |> List.sum in\n          (* Array.print ~first:\"\" ~sep:\"\" ~last:\"\" (Array.print ~first:\"\" ~sep:\" \" ~last:\"\\n\" Int.print) stdout m; *)\n          v))\n  |> List.concat\n  |> List.max\n  |> Printf.printf \"%d\\n\"\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.array, std.algorithm, std.conv, std.typecons, std.numeric, std.math;\n\nvoid main()\n{\n    auto hwk = readln.split.to!(int[]);\n    auto H = hwk[0];\n    auto W = hwk[1];\n    auto K = hwk[2];\n    long[][] MAP;\n    foreach (_; 0..H) MAP ~= readln.chomp.split(\"\").to!(long[]);\n\n    long solve(long[][] mm) {\n        auto changed = true;\n        long r, c;\n        while (changed) {\n            foreach_reverse (i; 0..H) {\n                foreach (j; 0..W) {\n                    if (mm[i][j] == 0) {\n                        foreach_reverse (k; 0..i) if (mm[k][j] > 0) {\n                            mm[i][j] = mm[k][j];\n                            mm[k][j] = 0;\n                            break;\n                        }\n                    }\n                }\n            }\n            changed = false;\n            foreach (i; 0..H) {\n                foreach_reverse (l; K..W+1) {\n                    foreach (x; 0..W+1-l) if (mm[i][x] > 0) {\n                        foreach (j; x+1..x+l) if (mm[i][x] != mm[i][j]) goto ng;\n                        changed = true;\n                        r += mm[i][x] * l * 2^^c;\n                        foreach (j; x..x+l) mm[i][j] = 0;\n                        goto ok;\n                        ng:\n                    }\n                }\n                ok:\n            }\n            ++c;\n        }\n        return r;\n    }\n\n    long r = solve(MAP);\n    foreach (i; 0..H) {\n        foreach (j; 0..W) {\n            auto mm = new long[][](H, W);\n            foreach (y; 0..H) foreach (x; 0..W) if (y != i || x != j) mm[y][x] = MAP[y][x];\n            r = max(r, solve(mm));\n        }\n    }\n    writeln(r);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.array, std.algorithm, std.conv, std.typecons, std.numeric, std.math;\n\nvoid main()\n{\n    auto hwk = readln.split.to!(int[]);\n    auto H = hwk[0];\n    auto W = hwk[1];\n    auto K = hwk[2];\n    long[][] MAP;\n    foreach (_; 0..H) MAP ~= readln.chomp.split(\"\").to!(long[]);\n\n    long solve(long[][] mm) {\n        auto changed = true;\n        long r, c;\n        while (changed) {\n            foreach_reverse (i; 0..H) {\n                foreach (j; 0..W) {\n                    if (mm[i][j] == 0) {\n                        foreach_reverse (k; 0..i) if (mm[k][j] > 0) {\n                            mm[i][j] = mm[k][j];\n                            mm[k][j] = 0;\n                            break;\n                        }\n                    }\n                }\n            }\n            changed = false;\n            foreach (i; 0..H) {\n                foreach_reverse (l; K..W+1) {\n                    foreach (x; 0..W+1-l) if (mm[i][x] > 0) {\n                        foreach (j; x+1..x+l) if (mm[i][x] != mm[i][j]) goto ng;\n                        changed = true;\n                        r += mm[i][x] * l * 2L^^c;\n                        foreach (j; x..x+l) mm[i][j] = 0;\n                        ng:\n                    }\n                }\n            }\n            ++c;\n        }\n        return r;\n    }\n\n    long r;\n    foreach (i; 0..H) {\n        foreach (j; 0..W) {\n            auto mm = new long[][](H, W);\n            foreach (y; 0..H) foreach (x; 0..W) if (y != i || x != j) mm[y][x] = MAP[y][x];\n            r = max(r, solve(mm));\n        }\n    }\n    writeln(r);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.array, std.algorithm, std.conv, std.typecons, std.numeric, std.math;\n\nvoid main()\n{\n    auto hwk = readln.split.to!(int[]);\n    auto H = hwk[0];\n    auto W = hwk[1];\n    auto K = hwk[2];\n    long[][] MAP;\n    foreach (_; 0..H) MAP ~= readln.chomp.split(\"\").to!(long[]);\n\n    long solve(long[][] mm) {\n        auto changed = true;\n        long r, c;\n        while (changed) {\n            foreach_reverse (i; 0..H) {\n                foreach (j; 0..W) {\n                    if (mm[i][j] == 0) {\n                        foreach_reverse (k; 0..i) if (mm[k][j] > 0) {\n                            mm[i][j] = mm[k][j];\n                            mm[k][j] = 0;\n                            break;\n                        }\n                    }\n                }\n            }\n            changed = false;\n            foreach (i; 0..H) {\n                foreach_reverse (l; K..W+1) {\n                    foreach (x; 0..W+1-l) if (mm[i][x] > 0) {\n                        foreach (j; x+1..x+l) if (mm[i][x] != mm[i][j]) goto ng;\n                        changed = true;\n                        r += mm[i][x] * l * 2L^^c;\n                        foreach (j; x..x+l) mm[i][j] = 0;\n                        goto ok;\n                        ng:\n                    }\n                }\n                ok:\n            }\n            ++c;\n        }\n        return r;\n    }\n\n    long r = solve(MAP);\n    foreach (i; 0..H) {\n        foreach (j; 0..W) {\n            auto mm = new long[][](H, W);\n            foreach (y; 0..H) foreach (x; 0..W) if (y != i || x != j) mm[y][x] = MAP[y][x];\n            r = max(r, solve(mm));\n        }\n    }\n    writeln(r);\n}"
  },
  {
    "language": "D",
    "code": "unittest\n{\n\tassert( [ \"4 4 2\", \"3413\", \"4121\", \"1424\", \"2312\" ].parse.expand.solve == 23 );\n\tassert( [ \"4 4 2\", \"1212\", \"2121\", \"1212\", \"2121\" ].parse.expand.solve == 54 );\n\tassert( [ \"7 7 2\", \"8989898\", \"9898989\", \"8989898\", \"9898989\", \"8989898\", \"9898989\", \"8989898\" ].parse.expand.solve == 2520 );\n\tassert( [ \"17 17 2\", \"12345678912345678\", \"23456789123456789\", \"34567891234567891\", \"45678912345678912\", \"56789123456789123\", \"67891234567891234\", \"78912345678912345\", \"89123456789123456\", \"91234567891234567\", \"12345678912345678\", \"23456789123456789\", \"34567891234567891\", \"45678912345678912\", \"56789123456789123\", \"67891234567891234\", \"78912345678912345\", \"89123456789123456\" ].parse.expand.solve == 2354638 );\n}\n\n\n\nimport std.algorithm;\nimport std.conv;\nimport std.range;\nimport std.stdio;\nimport std.typecons;\n\nvoid main()\n{\n\tstdin.byLineCopy.parse.expand.solve.writeln;\n}\n\nauto parse( Range )( Range input )\nif( isInputRange!Range && is( ElementType!Range == string ) )\n{\n\tauto hwk = input.front.split.to!( long[] );\n\tauto css = new long[][]( hwk[ 1 ], hwk[ 0 ] );\t\t// css[0][0]を左下、css[w][h]を右上にする\n\tforeach_reverse( y; 0L .. hwk[ 0 ] )\n\t{\n\t\tinput.popFront;\n\t\tforeach( x, c; input.front.map!( ( a ) => ( a - '0' ).to!( long ) ).enumerate( 0L ) )\n\t\t{\n\t\t\tcss[ x ][ y ] = c;\n\t\t}\n\t}\n\treturn tuple( hwk[ 0 ], hwk[ 1 ], hwk[ 2 ], css );\n}\n\nauto solve( long h, long w, long k, long[][] css )\n{\n\tauto ans = 0L;\n\tforeach( y; 0L .. h )\n\t{\n\t\tforeach( x; 0L .. w )\n\t\t{\n\t\t\tans = max( ans, solve2( h, w, k, css.dup, x, y ) );\n\t\t}\n\t}\n\treturn ans;\n}\n\nauto solve2( long h, long w, long k, long[][] css, long sx, long sy )\n{\n\tcss[ sx ] = css[ sx ][ 0 .. sy ] ~ css[ sx ][ sy + 1 .. $ ];\n\t\n\tauto st = 0L;\n\tfor( auto i = 0L;; i++ )\n\t{\n\t\tauto s = 0L;\n\t\tforeach_reverse( y; 0L .. h )\n\t\t{\n\t\t\tfor( auto lx = 0L, rx = 1L; lx < w; lx = rx, rx++ )\n\t\t\t{\n\t\t\t\tif( css[ lx ].length <= y ) continue;\n\t\t\t\t\n\t\t\t\twhile( rx < w && y < css[ rx ].length && css[ lx ][ y ] == css[ rx ][ y ] ) rx++;\n\t\t\t\t\n\t\t\t\tauto n = rx - lx;\n\t\t\t\tif( k <= n )\n\t\t\t\t{\n\t\t\t\t\ts += css[ lx ][ y ] * n;\n\t\t\t\t\tforeach( cx; lx .. rx )\n\t\t\t\t\t{\n\t\t\t\t\t\tcss[ cx ] = css[ cx ][ 0 .. y ] ~ css[ cx ][ y + 1 .. $ ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( s == 0 ) break;\n\t\tst += s * 2 ^^ i;\n\t}\n\treturn st;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.array, std.algorithm, std.conv, std.typecons, std.numeric, std.math;\n\nvoid main()\n{\n    auto hwk = readln.split.to!(int[]);\n    auto H = hwk[0];\n    auto W = hwk[1];\n    auto K = hwk[2];\n    long[][] MAP;\n    foreach (_; 0..H) MAP ~= readln.chomp.split(\"\").to!(long[]);\n\n    long solve(long[][] mm) {\n        auto changed = true;\n        long r, c;\n        while (changed) {\n            foreach_reverse (i; 0..H) {\n                foreach (j; 0..W) {\n                    if (mm[i][j] == 0) {\n                        foreach_reverse (k; 0..i) if (mm[k][j] > 0) {\n                            mm[i][j] = mm[k][j];\n                            mm[k][j] = 0;\n                            break;\n                        }\n                    }\n                }\n            }\n            changed = false;\n            foreach (i; 0..H) {\n                foreach_reverse (l; K..W+1) {\n                    foreach (x; 0..W+1-l) if (mm[i][x] > 0) {\n                        foreach (j; x+1..x+l) if (mm[i][x] != mm[i][j]) goto ng;\n                        changed = true;\n                        r += mm[i][x] * l * 2^^c;\n                        foreach (j; x..x+l) mm[i][j] = 0;\n                        goto ok;\n                        ng:\n                    }\n                }\n                ok:\n            }\n            ++c;\n        }\n        return r;\n    }\n\n    long r;\n    foreach (i; 0..H) {\n        foreach (j; 0..W) {\n            auto mm = new long[][](H, W);\n            foreach (y; 0..H) foreach (x; 0..W) if (y != i || x != j) mm[y][x] = MAP[y][x];\n            r = max(r, solve(mm));\n        }\n    }\n    writeln(r);\n}"
  },
  {
    "language": "Nim",
    "code": "#--------------------------------------------------\nimport strutils, sequtils, math, algorithm, tables, sets, lists, intsets, critbits, future\ntemplate `max=`(x,y) = x = max(x,y)\ntemplate `min=`(x,y) = x = min(x,y)\nlet read* = iterator: string {.closure.} =\n    while true: (for s in stdin.readLine.split: yield s)\nproc scan(): int = read().parseInt\nconst MOD = 10^9+7\n#--------------------------------------------------\nvar h,w,k = scan()\nvar c = newSeqWith(h, read().mapIt(($it).parseInt))\n\nif k==1:\n    var su = 0\n    var lo = int.high\n    for i in c:\n        for j in i:\n            su += j\n            lo .min= j\n    echo su - lo\n    quit()\n\nproc fall(field:var seq[seq[int]]): void =\n    for i in 1..<h:\n        for j in 0..<w:\n            if field[i][j] == 0:\n                for k in countdown(i,1):\n                    field[k][j] = field[k-1][j]\n                field[0][j] = 0\n\nproc judge(field:var seq[seq[int]]): int =\n    var prev = 0\n    var l,r = -1\n    for i in 0..<h:\n        prev = 0\n        l = 0\n        r = 0\n        for j in 0..<w:\n            if field[i][j] == prev:\n                r = j\n                #[\n                if l == -1:\n                    l = j-1\n                    r = j\n                else:\n                    r = j\n                ]#\n            else:\n                if r-l+1 >= k:\n                    for u in l..r:\n                        field[i][u] = 0\n                    #echo prev*(r-l+1)\n                    result += prev*(r-l+1)\n                l = j\n                r = j\n            prev = field[i][j]\n        if r-l+1 >= k:\n            for u in l..r:\n                field[i][u] = 0\n            #echo prev*(r-l+1)\n            result += prev*(r-l+1)\n        #dump result\n\nvar ans = 0\nfor i in 0..<h:\n    for j in 0..<w:\n        #echo \"           \"\n        var score = 0\n        var field = c\n        field[i][j] = 0\n        field.fall\n        #for k in field: echo k\n        var tmp = -1\n        var cnt = 0\n        while tmp != 0:\n            tmp = field.judge\n            field.fall\n            #for k in field: echo k\n            score += 2^cnt * tmp\n            cnt += 1\n        #echo score\n        #dump cnt\n        ans .max= score\n\necho ans"
  },
  {
    "language": "Python",
    "code": "H,W,K = list(map(int,input().split()))\nC = [list(input()) for _ in range(H)]\n\ndef F1(c):\n    for i in range(W):\n        for j in range(H-1,-1,-1):\n            if c[j][i] != 'X': continue\n            for k in range(j-1,-1,-1):\n                if c[k][i] != 'X':\n                    c[j][i], c[k][i] = c[k][i], c[j][i]\n                    break\n    return c\n\ndef F2(c):\n    delete_sum = 0\n    for i in range(H):\n        for j in range(W):\n            if c[i][j] == 'X': continue\n            tmp = c[i][j]\n            count = 1\n            for k in range(j+1,W):\n                if c[i][k] == tmp:\n                    count += 1\n                else:\n                    break\n            if count >= K:\n                for k in range(j,W):\n                    if c[i][k] == tmp:\n                        delete_sum += int(c[i][k])\n                        c[i][k] = 'X'\n                    else:\n                        break\n    return c, delete_sum\n\nMAX = 0\nfor i in range(H):\n    for j in range(W):\n        tmpC = []\n        for k in range(H):\n            tmpC.append(C[k][:])\n        tmpC[i][j] = 'X'\n        tmpC = F1(tmpC)\n        point = 0\n        for k in range(1000):\n            tmpC, delete_sum = F2(tmpC)\n            if delete_sum == 0:\n                break\n            tmpC = F1(tmpC)\n            point += 2**k*delete_sum\n        MAX = max(MAX,point)\nprint(MAX)\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    h, w, k = map(int, raw_input().split())\n    c = [map(int, raw_input().strip()) for _ in xrange(h)]\n    def go(a):\n        if not res:\n            return 0\n        return go(a) * 2 + res\n    ans = 0\n    for ii in xrange(h):\n        for jj in xrange(w):\n            a = [c[i][:] for i in xrange(h)]\n            a[ii][jj] = 0\n            r = 0\n            e = 1\n            while 1:\n                for j in xrange(w):\n                    st = [a[i][j] for i in xrange(h) if a[i][j]]\n                    for i in xrange(h):\n                        a[i][j] = 0\n                    i = -1\n                    for x in reversed(st):\n                        a[i][j] = x\n                        i -= 1\n                res = 0\n                for i in xrange(h):\n                    j = 0\n                    while j < w:\n                        t = j + 1\n                        while t < w and a[i][j] == a[i][t]:\n                            t += 1\n                        if t - j >= k:\n                            for j in xrange(j, t):\n                                res += a[i][j]\n                                a[i][j] = 0\n                        j = t\n                if not res:\n                    break\n                r += res * e\n                e *= 2\n            if ans < r:\n                ans = r\n    print ans\nmain()\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nimport sys\nimport math\nimport string\nimport collections\nimport fractions\nimport random\nfrom operator import itemgetter\nimport itertools\nfrom collections import deque\nimport copy\nimport heapq\nimport bisect\n\nMOD = 10 ** 9 + 7\nINF = float('inf')\ninput = lambda: sys.stdin.readline().strip()\n\nsys.setrecursionlimit(10 ** 8)\n\nH, W, K = map(int, input().split())\nc = [list(map(int, list(input()))) for _ in range(H)]\nans = 0\ncc = copy.deepcopy(c)\nfor z in range(H):\n    for m in range(W):\n        c = copy.deepcopy(cc)\n        c[z][m] = 0\n        temp_ans = 0\n        repeat_num = -1\n        p = 1\n        while p:\n            p = 0\n            for i in range(H):\n                num = 1\n                for j in range(W):\n                    if j != W - 1:\n                        if c[i][j] == c[i][j + 1] and c[i][j] != -1:\n                            num += 1\n                        elif num >= K:\n                            temp_ans += 2 ** repeat_num * c[i][j] * num\n                            for k in range(j - num + 1, j + 1):\n                                c[i][k] = 0\n                            num = 1\n                            p = 1\n                        else:\n                            num = 1\n                    elif num >= K:\n                        temp_ans += 2 ** repeat_num * c[i][j] * num\n                        for k in range(j - num + 1, j + 1):\n                            c[i][k] = 0\n                        num = 1\n                        p = 1\n            for i in reversed(range(H)):\n                for j in reversed(range(W)):\n                    if not c[i][j]:\n                        if i == 0:\n                            c[i][j] = -1\n                        else:\n                            for k in reversed(range(i)):\n                                if c[k][j] != 0:\n                                    c[i][j] = c[k][j]\n                                    c[k][j] = 0\n                                    break\n            repeat_num += 1\n            if repeat_num == 0:\n                p = 1\n        ans = max(ans, temp_ans)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "def drop(lst,h,w):\n    for i in range(w-1,-1,-1):\n        work=[lst[j][i] for j in range(h)]\n        work=[x for x in work if x]\n        for j in range(h-1,-1,-1):\n            if work: lst[j][i]=work.pop()\n            else : lst[j][i]=None\n\ndef chain(lst,h,w,k):\n    sm=0\n    for j in range(h):\n        train=1\n        for i in range(w-1):\n            if not lst[j][i] :\n                train=1\n                continue\n            if lst[j][i]==lst[j][i+1]:\n                train+=1\n            else :\n                if train>=k:\n                    sm+=lst[j][i]*train\n                    lst[j][i-train+1:i+1]=[None]*train\n                train=1\n        if train>=k:\n            sm+=lst[j][-1]*train\n            lst[j][-train:]=[None]*train\n    return sm\n\n\ndef procedure(lst,h,w,k,x):\n    lst[x[0]][x[1]]=None\n    drop(lst,h,w)\n    sm=0\n    i=0\n    point=chain(lst,h,w,k)\n    while point:\n        sm+=(2**i)*point\n        drop(lst,h,w)\n        point=chain(lst,h,w,k)\n        i+=1\n        #print(lst)\n    return sm\n\n\ndef main():\n    h,w,k=map(int,input().split())\n    lst=[[int(x) for x in input()] for _ in range(h)]\n    mx=0\n\n    for i in range(1,h):\n        for j in range(w):\n            work=[[lst[i][j] for j in range(w)] for i in range(h)]\n            sm=procedure(work,h,w,k,(i,j))\n            if mx<sm : mx=sm\n    print(mx)\n\n\nmain()"
  },
  {
    "language": "Python",
    "code": "'''\nhttps://atcoder.jp/contests/s8pc-3/tasks/s8pc_3_b\n'''\ndef main():\n    import sys\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10000000)\n    from collections import Counter, deque\n    #from collections import defaultdict\n    from itertools import combinations, permutations, accumulate\n    #from itertools import product\n    from bisect import bisect_left,bisect_right\n    import heapq\n    from math import floor, ceil\n    #from operator import itemgetter\n\n    #inf = 10**17\n    #mod = 10**9 + 7\n\n    h,w,k = map(int, input().split())\n    banmen = []\n    for _ in range(h):\n        s = input().rstrip()\n        s = list(s)\n        s = list(map(int, s))\n        banmen.append(s)\n\n    def update():\n        while 1:\n            cnt = 0\n            for i in range(h-1):\n                for j in range(w):\n                    if c[i+1][j] == 0 and c[i][j] != 0:\n                        c[i][j], c[i+1][j] = c[i+1][j], c[i][j]\n                        cnt += 1\n            if cnt == 0:\n                return\n\n    #n回目(0~)\n    def get(n):\n        total = 0\n        for i in range(h):\n            for j in range(0, w-k+1, 1):\n                ten = c[i][j]\n                cnt = 1\n                while c[i][j] == c[i][j+1]:\n                    cnt += 1\n                    j += 1\n                    if j == w-1:\n                        break\n                if cnt >= k:\n                    total += 2**n * (ten*cnt)\n                    c[i][j-(cnt-1):j+1] = [0]*cnt\n        return total\n\n    def solve(i, j):\n        c[i][j] = 0\n        res = 0\n        n = 0\n        while 1:\n            update()\n            total = get(n)\n            if total == 0:\n                break\n            n += 1\n            res += total\n        return res\n\n    import copy\n    res = 0\n    for i in range(h):\n        for j in range(w):\n            c = copy.deepcopy(banmen) \n            res = max(res, solve(i, j))\n    print(res)\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "import copy\nh,w,K = map(int, input().split())\nc = [[] for _ in range(w)]\nfor i in range(h):\n    a = input()\n    for j in range(w):\n        c[j].append(a[j])\n#print(c)\nans = 0\nfor i in range(h):\n    for j in range(w):\n        C = copy.deepcopy(c)\n        C[j].pop(i)\n        ren = 0\n        point = 0\n        while True:\n            cnt = 0\n            for k in range(30,0,-1):\n                #print(k)\n                start = 0\n                while start <= w-K:\n                    if (len(C[start]) < k):\n                        start += 1\n                        continue\n                    num = C[start][-k]\n                    end = start\n                    while True:\n                        #print(C,k,start,end)\n                        if (end<w-1 and len(C[end+1])>=k and C[end+1][-k]==num):\n                            end += 1\n                        else:\n                            break\n                    if (end+1-start >= K):\n                        point += (end+1-start)*int(C[start][-k])*(2**ren)\n                        for p in range(start,end+1):\n                            #print(C,p,k,start,end,point)\n                            C[p].pop(-k)\n                            cnt += 1\n                    start = end + 1\n            if (cnt == 0):\n                break\n            ren += 1\n        if (point > ans):\n            ans = point\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/env python3\n\ndef dropcell():\n    for y in range(H):\n        for i in range(H):\n            for j in range(W):\n                if gm[H-i][j] == 0:\n                    gm[H-i-1][j], gm[H-i][j] = gm[H-i][j], gm[H-i-1][j]\ndef removecell():\n    global gp, gf\n    gf = False\n    p = 0\n    for y in range(H):\n        c = 1\n        t = 0\n        for i in range(W+1):\n            x = gm[y+1][i]\n            if x > 0 and x == t:\n                c += 1\n            else:\n                if c >= K:\n                    for j in range(c):\n                        gm[y+1][i-1-j] = 0\n                    p += (t * c)\n                    gf = True\n                t = x\n                c = 1\n    gp += p * (2**gi)\n\n\nH, W, K = map(int, input().split())\nM = [[0]*(W+1)]+[list(map(int, [*input()]))+[0] for i in range(H)]\npoints = {}\nfor i in range(H)[::-1]:\n    for j in range(W):\n        gp = 0\n        gf = True\n        gi = 0\n        gm = [[j for j in i]for i in M]\n        gm[i+1][j] = 0\n        while gf:\n            dropcell()\n            removecell()\n            gi += 1\n        points[gp] = 1\nprint(max(points))"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nfrom typing import List\nimport sys\ninput = sys.stdin.readline\n\n\ndef delete_cell_line(line: List[int], k: int) -> int:\n    prev = -1\n    block = 1\n    point = 0\n    for idx, num in enumerate(line+[0]):\n        if num == prev:\n            block += 1\n\n        else:\n            if block >= k:\n                point += prev * block\n                for i in range(idx-block, idx):\n                    line[i] = 0\n            block = 1\n            prev = num\n    return point\n\n\ndef drop_down(board: List[List[int]]):\n    w = len(board[0])\n    h = len(board)\n\n    for x in range(w):\n        vertical_line = []\n        for y in range(h):\n            cell = board[y][x]\n            if cell:\n                vertical_line.append(cell)\n\n        vertical_line = [0]*(h-len(vertical_line)) + vertical_line\n        for y, new_cell in enumerate(vertical_line):\n            board[y][x] = new_cell\n\n\ndef calc_score(y: int, x: int, k: int, board: List[List[int]]) -> int:\n    board[y][x] = 0\n    drop_down(board)\n    chain = 0\n    score = 0\n    while True:\n        point = 0\n        for line in board:\n            point += delete_cell_line(line, k)\n        if not point:\n            break\n\n        score += point * 2**chain\n        chain += 1\n        drop_down(board)\n    return score\n\n\ndef main():\n    h, w, k = map(int, input().split())\n    board = []\n    for _ in range(h):\n        pre_line = input().rstrip(\"\\n\")\n        line = list(map(int, list(pre_line)))\n        board.append(line)\n\n    ans = 0\n    for y in range(h):\n        for x in range(w):\n            new_board = deepcopy(board)\n            score = calc_score(y, x, k, new_board)\n            if ans < score:\n                ans = score\n\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "# https://atcoder.jp/contests/s8pc-3/tasks/s8pc_3_b\n\nimport copy\n\n\ndef delete(M, k):\n    point = 0\n    for row in M:\n        for l in range(len(row)-1):\n            for r in range(l + 1, len(row)):\n                if row[l] != row[r]:\n                    break\n            if r - l >= k:\n                point += (r - l) * row[l]\n                for i in range(l, r):\n                    row[i] = 0\n                break\n\n    return point\n\n\ndef drop(M):\n    for c in range(len(M[0])):\n        nums = []\n        for i in range(len(M)-1, -1, -1):\n            if M[i][c] != 0:\n                nums.append(M[i][c])\n            M[i][c] = 0\n\n        for i in range(len(nums)):\n            M[len(M)-1-i][c] = nums[i]\n\n\ndef solve(M, k):\n    result = 0\n    drop(M)\n    # for row in M:\n    #     print(*row)\n    itr = 0\n    while True:\n        point = delete(M, k)\n        if point == 0:\n            break\n        result += point * (2 ** itr)\n        # print('-------')\n        # for row in M:\n        #     print(*row)\n        # print('--drop-----')\n        drop(M)\n        # for row in M:\n        #     print(*row)\n        # print('-------')\n        # print(result)\n        itr += 1\n    return result\n\n\nif __name__ == \"__main__\":\n    h, w, k = list(map(int, input().split()))\n    M2 = []\n    for _ in range(h):\n        row_input = input()\n        row = []\n        for c in row_input:\n            row.append(int(c))\n        row.append(0)\n        M2.append(row)\n\n    result = 0\n    for i in range(h):\n        for j in range(w):\n            M = copy.deepcopy(M2)\n            M[i][j] = 0\n            result = max(result, solve(M, k))\n\n    print(result)\n"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nH, W, K = map(int, input().split())\nboard = [[0]*W for _ in range(H)]\nfor i in range(H):\n    board[i] = list(map(int, list(input())))\ndef drop(board_copy):\n    change = True\n    score = 0\n    p = 0\n    while change:\n        change = False\n        for i in range(1,H):\n            ser = 1\n            for j in range(W):\n                if j==W-1:\n                    if ser>=K:\n                        score += 2**p*board_copy[i][-1]*ser\n                        change = True\n                        for k in range(i,0,-1):\n                            board_copy[k][-ser:] = board_copy[k-1][-ser:]\n                        board_copy[0][-ser:] = [0]*(ser)\n                    continue\n                if board_copy[i][j]==0:\n                    ser = 1\n                    continue\n                if board_copy[i][j]>0 and board_copy[i][j]==board_copy[i][j+1]:\n                    ser += 1\n                elif ser>=K:\n                    score += 2**p*board_copy[i][j]*ser\n                    change = True\n                    for k in range(i,0,-1):\n                        board_copy[k][j-ser+1:j+1] = board_copy[k-1][j-ser+1:j+1]\n                    board_copy[0][j-ser+1:j+1] = [0]*(ser)\n                    ser = 1\n        p += 1\n    return score\nans = 0\nfor h in range(H):\n    for w in range(W):\n        board_copy = deepcopy(board)\n        for k in range(h,0,-1):\n            board_copy[k][w] = board[k-1][w]\n        board_copy[0][w] = 0\n        ans = max(ans,drop(board_copy))\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "        \nclass Game:\n    def __init__(self, mp, h, w, k):\n        self.mp = mp\n        self.H = h\n        self.W = w\n\n        self.K = k\n        self.score = 0\n        self.erase_flag = False\n        self.cnt = 0\n        \n    def erase(self):\n        tot = 0\n        for y in range(self.H):\n            line = self.mp[y]\n            new_line, add_score = self.fix(line)\n            self.mp[y] = new_line\n            tot += add_score\n            if add_score != 0:\n                self.erase_flag = True\n        if self.erase_flag:\n            self.score += tot*pow(2, self.cnt)\n            self.cnt += 1\n    \n    def fix(self, line):\n        add_score = 0\n        new_line = line\n        for length in range(self.W, self.K-1, -1):\n            for left in range(self.W - length+1):\n                if all(map(lambda x:x==new_line[left], new_line[left:left+length])):\n                    add_score += new_line[left]*length\n                    new_line = new_line[:left] + [0]*length + new_line[left+length:]\n                    # 最後の要素まで見たか？\n                    # if self.W == left+length:\n                    #     return new_line, add_score\n        return new_line, add_score\n    \n    def fall(self):\n        for x in range(self.W):\n            col = []\n            for y in range(self.H):\n                if self.mp[y][x] != 0:\n                    col.append(self.mp[y][x])\n            col = [0]*(self.H - len(col)) + col\n            for y in range(self.H):\n                self.mp[y][x] = col[y]\n\n    def run(self):\n        while True:\n            self.erase_flag = False\n            self.erase()\n            if not self.erase_flag:\n                break\n            self.fall()\n\nimport copy\ndef resolve():\n    def init_fall(grid, cell):\n        col = []\n        for y in range(H):\n            if grid[y][cell] != 0:\n                col.append(grid[y][cell])\n        col = [0] * (H - len(col)) + col\n        for y in range(H):\n            grid[y][cell] = col[y]\n        return grid\n\n    H, W, K = map(int, input().split())\n    mp = [list(map(int, input())) for _ in range(H)]\n\n    ans = 0\n    for i in range(1,H):\n        for j in range(W):\n            mp_copy = copy.deepcopy(mp)\n            mp_copy[i][j] = 0\n            mp_copy = init_fall(mp_copy,j)\n            game = Game(mp_copy, H, W, K)\n            game.run()\n            ans = max(ans, game.score)\n    print(ans)\n\nif __name__ == \"__main__\":\n    resolve()"
  },
  {
    "language": "Python",
    "code": "from collections import deque   \n\nicase=0\nif icase==0:\n    h,w,k=map(int,input().split())\n    aa=[[0]*w for i in range(h)]\n    for i in range(h):\n        ll=input()\n        for j in range(w):\n            aa[h-1-i][j]=int(ll[j])\nelif icase==1:\n    h,w,k=4,4,2    \n    aa=[[2, 3, 1, 2], [1, 4, 2, 4], [4, 1, 2, 1], [3, 4, 1, 3]]\nelif icase==2:\n    h,w,k=4,4,2    \n    aa=[[2, 1, 2, 1], [1, 2, 1, 2], [2, 1, 2, 1], [1, 2, 1, 2]]\nelif icase==3:\n    h,w,k=7,7,2    \n    aa=[[8, 9, 8, 9, 8, 9, 8], [9, 8, 9, 8, 9, 8, 9], [8, 9, 8, 9, 8, 9, 8], [9, 8, 9, 8, 9, 8, 9], [8, 9, 8, 9, 8, 9, 8], [9, 8, 9, 8, 9, 8, 9], [8, 9, 8, 9, 8, 9, 8]]\nelif icase==4:\n    h,w,k=17,17,2    \n    aa=[[8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6], [7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5], [6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4], [5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3], [4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2], [3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1], [2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8], [9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7], [8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6], [7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5], [6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4], [5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3], [4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2], [3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1], [2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8]]\n#    print(a)\npmax=0\nfor hi in range(h):\n    for wi in range(w): \n        a=[[0]*w for i in range(h)]\n        for i in range(h):\n            for j in range(w):\n                a[i][j]=aa[i][j]\n#    print(\"j:\",j,a)\n        for i in range(hi,h-1):\n            a[i][wi]=a[i+1][wi]\n        a[h-1][wi]=0\n#    print(\"1:\",a)\n        p=0\n        ip=-1\n        icnt=0\n        while True:\n            icnt+=1\n            if icnt>50:\n                break\n            ip+=1\n            p1=0\n            yn=\"\"\n            for i in range(h):\n                q=deque()\n                for j2 in range(w-k+1):\n                    for j3 in range(j2+1,j2+k):\n                        if a[i][j2]==0 or a[i][j2]!=a[i][j3]:\n                            break\n                        q.append((j2,a[i][j2]))\n                        yn=\"yes\"\n#            print(\"i:\",i,q)\n                jm=-2\n                while len(q)>0:\n                    j2,aij=q.popleft()\n                    for j3 in range(j2,j2+k):\n                        a[i][j3]=0\n#                print(\"j2:\",j2,\"jm+1:\",jm+1)\n                    if j2!=jm+1:\n                        p1+=aij*k\n                    else:\n                        p1+=aij\n                    jm=j2\n#                print(\"p1:\",p1)\n\n#            print(\"1:\",a)\n#        print(\"2:\",a)\n            for jj in range(w):\n                for ii in range(h):\n                    if a[ii][jj]==0:\n                        for iii in range(ii+1,h):\n                            if a[iii][jj]!=0:\n                                a[ii][jj]=a[iii][jj]\n                                a[iii][jj]=0\n                                break\n#        print(yn,a)\n            p+=p1*(2**ip)\n            if yn!=\"yes\":\n#            print(p,p1,ip)\n                break\n#    print(\"---------------------\")\n        pmax=max(pmax,p)\n#        print(a)\nprint(pmax)\n    "
  },
  {
    "language": "Python",
    "code": "def main():\n    h, w, k = map(int, raw_input().split())\n    c = [map(int, raw_input().strip()) for _ in xrange(h)]\n    def go(a):\n        if not res:\n            return 0\n        return go(a) * 2 + res\n    ans = 0\n    for ii in xrange(h):\n        for jj in xrange(w):\n            a = [c[i][:] for i in xrange(h)]\n            a[ii][jj] = 0\n            r = 0\n            e = 1\n            while 1:\n                for j in xrange(w):\n                    st = [a[i][j] for i in xrange(h) if a[i][j]]\n                    for i in xrange(h):\n                        a[i][j] = 0\n                    i = -1\n                    for x in reversed(st):\n                        a[i][j] = x\n                        i -= 1\n                res = 0\n                for i in xrange(h):\n                    j = 0\n                    while j < w:\n                        t = j + 1\n                        while t < w and a[i][j] == a[i][t]:\n                            t += 1\n                        if t - j >= k:\n                            for j in xrange(j, t):\n                                res += a[i][j]\n                                a[i][j] = 0\n                        j = t\n                if not res:\n                    break\n                r += res * e\n                e *= 2\n            if ans < r:\n                ans = r\n    print ans\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque   \n\nicase=0\nif icase==0:\n    h,w,k=map(int,input().split())\n    aa=[[0]*w for i in range(h)]\n    for i in range(h):\n        ll=input()\n        for j in range(w):\n            aa[h-1-i][j]=int(ll[j])\nelif icase==1:\n    h,w,k=4,4,2    \n    aa=[[2, 3, 1, 2], [1, 4, 2, 4], [4, 1, 2, 1], [3, 4, 1, 3]]\nelif icase==2:\n    h,w,k=4,4,2    \n    aa=[[2, 1, 2, 1], [1, 2, 1, 2], [2, 1, 2, 1], [1, 2, 1, 2]]\nelif icase==3:\n    h,w,k=7,7,2    \n    aa=[[8, 9, 8, 9, 8, 9, 8], [9, 8, 9, 8, 9, 8, 9], [8, 9, 8, 9, 8, 9, 8], [9, 8, 9, 8, 9, 8, 9], [8, 9, 8, 9, 8, 9, 8], [9, 8, 9, 8, 9, 8, 9], [8, 9, 8, 9, 8, 9, 8]]\nelif icase==4:\n    h,w,k=17,17,2    \n    aa=[[8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6], [7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5], [6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4], [5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3], [4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2], [3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1], [2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8], [9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7], [8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6], [7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5], [6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4], [5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3], [4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2], [3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1], [2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8]]\n#    print(a)\npmax=0\nfor hi in range(h):\n    for wi in range(w): \n        a=[[0]*w for i in range(h)]\n        for i in range(h):\n            for j in range(w):\n                a[i][j]=aa[i][j]\n#    print(\"j:\",j,a)\n        for i in range(hi,h-1):\n            a[i][wi]=a[i+1][wi]\n        a[h-1][wi]=0\n#    print(\"1:\",a)\n        p=0\n        ip=-1\n        icnt=0\n        while True:\n            icnt+=1\n            if icnt>50:\n                break\n            ip+=1\n            p1=0\n            yn=\"\"\n            for i in range(h):\n                q=deque()\n                for j2 in range(w-k+1):\n                    for j3 in range(j2+1,j2+k):\n                        if a[i][j2]==0 or a[i][j2]!=a[i][j3]:\n                            break\n                        q.append((j2,a[i][j2]))\n                        yn=\"yes\"\n#            print(\"i:\",i,q)\n                jm=-2\n                while len(q)>0:\n                    j2,aij=q.popleft()\n                    for j3 in range(j2,j2+k):\n                        a[i][j3]=0\n#                print(\"j2:\",j2,\"jm+1:\",jm+1)\n                    if j2!=jm+1:\n                        p1+=aij*k\n                    else:\n                        p1+=aij\n                    jm=j2\n#                print(\"p1:\",p1)\n\n#            print(\"1:\",a)\n#        print(\"2:\",a)\n            for jj in range(w):\n                for ii in range(h):\n                    if a[ii][jj]==0:\n                        for iii in range(ii+1,h):\n                            if a[iii][jj]!=0:\n                                a[ii][jj]=a[iii][jj]\n                                a[iii][jj]=0\n                                break\n#        print(yn,a)\n            p+=p1*(2**ip)\n            if yn!=\"yes\":\n#            print(p,p1,ip)\n                break\n#    print(\"---------------------\")\n        pmax=max(pmax,p)\n#        print(a)\nprint(pmax)\n    \n"
  },
  {
    "language": "Python",
    "code": "from collections import deque   \nimport sys\n\nicase=0\nif icase==0:\n    h,w,k=map(int,input().split())\n    aa=[[0]*w for i in range(h)]\n    for i in range(h):\n        ll=input()\n        for j in range(w):\n            aa[h-1-i][j]=int(ll[j])\nelif icase==1:\n    h,w,k=4,4,2    \n    aa=[[2, 3, 1, 2], [1, 4, 2, 4], [4, 1, 2, 1], [3, 4, 1, 3]]\nelif icase==2:\n    h,w,k=4,4,2    \n    aa=[[2, 1, 2, 1], [1, 2, 1, 2], [2, 1, 2, 1], [1, 2, 1, 2]]\nelif icase==3:\n    h,w,k=7,7,2    \n    aa=[[8, 9, 8, 9, 8, 9, 8], [9, 8, 9, 8, 9, 8, 9], [8, 9, 8, 9, 8, 9, 8], [9, 8, 9, 8, 9, 8, 9], [8, 9, 8, 9, 8, 9, 8], [9, 8, 9, 8, 9, 8, 9], [8, 9, 8, 9, 8, 9, 8]]\nelif icase==4:\n    h,w,k=17,17,2    \n    aa=[[8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6], [7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5], [6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4], [5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3], [4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2], [3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1], [2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8], [9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7], [8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6], [7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5], [6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4], [5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3], [4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2], [3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1], [2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8]]\n#    print(a)\nif k>=4:\n    print(0)\n    sys.exit()\n\npmax=0\nfor hi in range(h):\n    for wi in range(w): \n        a=[[0]*w for i in range(h)]\n        for i in range(h):\n            for j in range(w):\n                a[i][j]=aa[i][j]\n#    print(\"j:\",j,a)\n        for i in range(hi,h-1):\n            a[i][wi]=a[i+1][wi]\n        a[h-1][wi]=0\n#    print(\"1:\",a)\n        p=0\n        ip=-1\n        while True:\n            ip+=1\n            p1=0\n            yn=\"\"\n            for i in range(h):\n                q=deque()\n                for j2 in range(w-k+1):\n                    for j3 in range(j2+1,j2+k):\n                        if a[i][j2]==0 or a[i][j2]!=a[i][j3]:\n                            break\n                        q.append((j2,a[i][j2]))\n                        yn=\"yes\"\n#            print(\"i:\",i,q)\n                jm=-2\n                aijm=-1\n                while len(q)>0:\n                    j2,aij=q.popleft()\n                    for j3 in range(j2,j2+k):\n                        a[i][j3]=0\n#                print(\"j2:\",j2,\"jm+1:\",jm+1)\n                    if j2==jm+1 and aij==aijm:\n                        p1+=aij\n                    else:\n                        p1+=aij*k\n                    jm=j2\n                    aijm=aij\n#                print(\"p1:\",p1)\n\n#            print(\"1:\",a)\n#        print(\"2:\",a)\n            for jj in range(w):\n                for ii in range(h):\n                    if a[ii][jj]==0:\n                        for iii in range(ii+1,h):\n                            if a[iii][jj]!=0:\n                                a[ii][jj]=a[iii][jj]\n                                a[iii][jj]=0\n                                break\n#        print(yn,a)\n            p+=p1*(2**ip)\n            if yn!=\"yes\":\n#            print(p,p1,ip)\n                break\n#    print(\"---------------------\")\n        pmax=max(pmax,p)\n#        print(a)\nprint(pmax)\n    "
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nh,w,k=map(int,input().split())\nb=[list(i[::-1]) for i in zip(*[input() for _ in range(h)])]\nb = [[int(str) for str in strs] for strs in b]\nfans=0\nfor x in range(w):\n  for y in range(h):\n    a=deepcopy(b)\n    a[x].pop(y)\n    a[x].append(0)\n    q=[]\n    ans=0\n    d=-1\n    m=0\n    while True:\n      if d==ans:break\n      d=ans\n      for i in range(h):\n        cnt=0\n        for j in range(w-1):\n          if a[j][i]==a[j+1][i]:cnt+=1\n          else:\n            if cnt>=k-1:\n              q.append((j-cnt,i,cnt+1))\n              cnt=0\n        if cnt>=k-1:\n          q.append((j-cnt+1,i,cnt+1))      \n      while q:\n        j,i,cnt=q.pop()\n        for c in range(cnt):\n          ans+=2**m*a[j+c].pop(i)\n          a[j+c].append(0)\n      m+=1\n    fans=max(fans,ans) \nprint(fans)"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/env python3\n\ndef dropcell(H, W, gm):\n    H = len(gm)\n    for i in range(W):\n        y = 0\n        for j in range(H):\n            a = gm[H-j-1][i]\n            if a != 0:\n                gm[H-y-1][i] = a\n                y += 1\n\ndef removecell(H, W, K, gm, gp, gi):\n    H = len(gm)\n    r = False\n    p = 0\n    for y in range(H):\n        c = 1\n        t = 0\n        for i in range(W+1):\n            x = gm[y][i]\n            if x > 0 and x == t:\n                c += 1\n            else:\n                if c >= K:\n                    for j in range(c):\n                        gm[y][i-1-j] = 0\n                    p += (t * c)\n                    r = True\n                t = x\n                c = 1\n    return p * (2**gi)\n\ndef start(H, W, K, M, points, y, x):\n    f = 1\n    gp = 0\n    gi = 0\n    gm = [[j for j in i]for i in M[:y+1]]\n    gm[y][x] = 0\n    while f:\n        dropcell(H, W, gm)\n        f = removecell(H, W, K, gm, gp, gi)\n        gp += f\n        gi += 1\n    points.add(gp)\n\ndef main():\n    H, W, K = map(int, input().split())\n    M = [list(map(int, list(input())))+[0] for i in range(H)]\n    points = set([])\n    for j in range(W):\n        t = 0\n        for i in range(H):\n            if M[i][j] != t:\n                start(H, W, K, M, points, i, j)\n                t = M[i][j]\n    print(min(max(points), 1000000000))\n    \nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\n\nh,w,border=map(int,input().split())\nG_original=[]\nfor i in range(w):\n    L=list(str(input()))\n    for j in range(len(L)):\n        L[j]=int(L[j])\n    G_original.append(L)\n\n\n\ndef delete(row):\n    #圧縮\n    L=[]\n    temp=[row[0],1]\n    for i in range(len(row)-1):\n        if row[i]==row[i+1]:\n            temp[1]+=1\n        else:\n            L.append(temp)\n            temp=[row[i+1],1]\n    L.append(temp)\n\n    res=0\n    index=-1\n    for i in range(len(L)):\n        if L[i][0]>=1 and L[i][1]>=border:\n            for j in range(index+1,index+L[i][1]+1):\n                row[j]=-1\n            res+=L[i][0]*L[i][1]\n            index+=L[i][1]\n        else:\n            index+=L[i][1]\n    return res,row\n    \n#ans=delete([1,2,2,2,2,5,2,3,3,3,1])\n#print(ans)\n\nans=0\nfor i in range(h):\n    for j in range(w):\n        #必要か\n        G=deepcopy(G_original)\n        temp=0\n        G[i][j]=-1\n        count=-1\n        while True:\n            for k in range(w):\n                res=[]\n                for l in range(h)[::-1]:\n                    if G[l][k]>=1:\n                        res.append(G[l][k])\n                if len(res)<w:\n                    res+=[-1]*(w-len(res))\n                for l in range(h):\n                    G[l][k]=res[h-l-1]\n\n            #print(G)\n\n            count+=1\n            flag=True\n            for k in range(h):\n                now,G[k]=delete(G[k])\n                if now>0:\n                    temp+=(2**count)*now\n                    flag=False\n            #print(temp,G)\n\n            if flag:\n                break\n            \n        ans=max(ans,temp)\n        \nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import copy\n\ndef score(i,j):\n  Ali = copy.deepcopy(data)\n  Ali[i][j] = 0\n  score = 0\n  turn = 0\n  \n  for i in range(1,H+1):\n    for j in range(W):\n      if Ali[-i][j] == 0:\n        for k in range(i+1,H+1):\n          if Ali[-k][j] != 0:\n            Ali[-i][j] = Ali[-k][j]\n            Ali[-k][j] = 0\n            break\n            \n  while True:\n    sc = score\n    #同じものを消す処理\n    for i in range(H):\n      a = 0 #今の数字\n      b = 0 #今の数字が始まった場所\n      \n      for j in range(W):\n        if Ali[i][j] != a:\n          if j-b >= K:\n            for k in range(b,j):\n              score += Ali[i][k]*2**turn\n              Ali[i][k] = 0\n          a = Ali[i][j]\n          b = j\n      if W-b >= K:\n        for k in range(b,W):\n          score += Ali[i][k]*2**turn\n          Ali[i][k] = 0\n      \n      \n    if sc == score:\n        break\n    turn += 1\n      \n    #落としていく処理\n    #下から上に見ていく\n    for i in range(1,H+1):\n      for j in range(W):\n        if Ali[-i][j] == 0:\n          for k in range(i+1,H+1):\n            if Ali[-k][j] != 0:\n              Ali[-i][j] = Ali[-k][j]\n              Ali[-k][j] = 0\n              break\n              \n  return score\n  \nH,W,K = map(int,input().split())\ndata = [[int(d) for d in input()] for _ in range(H)]\nres = 0\n\nfor i in range(H):\n  for j in range(W):\n    res = max(res,score(i,j))\n    \nprint(res)"
  },
  {
    "language": "Python",
    "code": "import sys,queue,math,copy\nLI = lambda : [int(x) for x in input().split()]\n\nH,W,K = LI()\nC = [[int(x) for x in input()] + [0] for _ in range(H)]\n\nmax_p = 0\nfor i in range(H):\n    for j in range(W):\n        c = copy.deepcopy(C)\n        c[i][j] = 0\n        p = 0\n        for ii in range(i,0,-1):\n            c[ii][j] = c[ii-1][j]\n        c[0][j] = 0\n\n\n        update = True\n        cnt = 0\n        while update:\n            update = False\n\n            for ii in range(H):\n                n = c[ii][0]\n                nc = n > 0\n                for jj in range(1, W + 1):\n                    if c[ii][jj] == n and n > 0:\n                        nc += 1\n                    else:\n                        if nc >= K:\n                            for k in range(nc):\n                                c[ii][jj-k-1] = 0\n                            p += nc * n * (2 **cnt)\n                            update = True\n                        n = c[ii][jj]\n                        nc = n > 0\n\n            for ii in range(H-1, 0, -1):\n                for jj in range(W):\n                    if c[ii][jj] > 0: continue\n                    x = ii\n                    while x > 0:\n                        x -= 1\n                        if c[x][jj] > 0:\n                            c[ii][jj] = c[x][jj]\n                            c[x][jj] = 0\n                            break\n            cnt += 1\n\n        max_p = max(max_p,p)\nprint (max_p)\n"
  },
  {
    "language": "Python",
    "code": "import copy\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\ndef main():\n    ans = []\n    H,W,K = map(int, readline().split())\n    c_ = [list(map(int, list(readline().strip()))) for _ in range(H)]\n\n    for a in range(H):\n        for b in range(W):\n            c = copy.deepcopy(c_)\n            c[a][b] = 0\n\n            seq = [[1] for _ in range(H)]\n            ans_tmp = [0]\n            \n            score = 0\n            weight = 1\n            while True:\n                # 落とす\n                for i in reversed(range(H)):\n                    for j in range(W):\n                        if c[i][j] == 0:\n                            for h in reversed(range(i)):\n                                if c[h][j] != 0:\n                                    c[h][j], c[i][j] = c[i][j], c[h][j]\n                                    break\n\n                # 消す\n                for i, line in enumerate(c):\n                    for j in range(1,W):\n                        if line[j] == line[j-1]:\n                            seq[i][-1] += 1\n                        else:\n                            seq[i].append(1)\n                \n                    acc = -1\n                    for s in seq[i]:\n                        acc += s\n                        if s >= K:\n                            score += s * line[acc] * weight\n                            for j in range(acc - s + 1, acc + 1):\n                                line[j] = 0\n                    seq[i] = [1]\n                \n                weight *= 2\n\n                ans_tmp.append(score)\n                if ans_tmp[-1] == ans_tmp[-2]:\n                    ans.append(ans_tmp[-1])\n                    break\n\n    print(max(ans))\n\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nH,W,K = map(int,readline().split())\nS = np.array([list(line.rstrip()) for line in readlines()]).astype(np.int8) - ord('0')\n\n# 下から上の順に\nS = S[::-1]\n\ndef drop(S):\n    for i in range(W):\n        col = S[:,i]\n        S[:,i] = drop_col(col)\n\ndef drop_col(col):\n    x = np.zeros(H,np.int8)\n    nonzero = col[col != 0]\n    x[:len(nonzero)] = nonzero\n    return x\n\ndef cnt_connection(S):\n    # 横につながっている個数\n    x = np.ones_like(S)\n    equal = (S[:,:-1] == S[:,1:])\n    for i in range(1,W):\n        x[:,i] = x[:,i-1] * equal[:,i-1] + 1\n    for i in range(W-2,-1,-1):\n        x[:,i][equal[:,i]] = x[:,i+1][equal[:,i]]\n    return x\n\ndef simulate(S,turn):\n    # 落とす -> 消去、で1セット\n    drop(S)\n    conn = cnt_connection(S)\n    remove = (conn >= K)\n    before = S.sum()\n    S *= (~remove)\n    after = S.sum()\n    if before == after:\n        # 消えなかった\n        return 0\n    else:\n        x = simulate(S,turn+1)\n        return x + ((before - after) << turn)\n\ndef calc(i,j):\n    T = S.copy()\n    T[i,j] = 0\n    return simulate(T,0)\n\nanswer = max(calc(i,j) for i in range(H) for j in range(W))\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom itertools import groupby\nfrom copy import deepcopy\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\n\n\ndef do_drop(H, W, G):\n    for j in range(W):\n        for i in range(H - 1):\n            for k in range(H - 1, i, -1):\n                if G[k][j] == 0 and G[k - 1][j] != 0:\n                    G[k][j], G[k - 1][j] = G[k - 1][j], G[k][j]\n\n\ndef main():\n    H, W, K = map(int, readline().split())\n    G_base = [list(map(int, readline().strip())) for _ in range(H)]\n\n    ans = 0\n    for i in range(H):\n        for j in range(W):\n            G = deepcopy(G_base)\n            G[i][j] = 0\n            do_drop(H, W, G)\n\n            power = 1\n            score = 0\n            while True:\n                finished = True\n                total = 0\n                for row in G:\n                    idx = 0\n                    for k, g in groupby(row):\n                        l = len(list(g))\n                        if k > 0 and l >= K:\n                            row[idx : idx + l] = [0] * l\n                            total += k * l\n                            finished = False\n                        idx += l\n\n                if finished:\n                    break\n\n                score += power * total\n                power *= 2\n                do_drop(H, W, G)\n\n            if ans < score:\n                ans = score\n\n    print(ans)\n    return\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "def drop(lst,h,w):\n    for i in range(w-1,-1,-1):\n        work=[lst[j][i] for j in range(h)]\n        work=[x for x in work if x]\n        for j in range(h-1,-1,-1):\n            if work: lst[j][i]=work.pop()\n            else : lst[j][i]=None\n\ndef chain(lst,h,w,k):\n    sm=0\n    for j in range(h):\n        train=1\n        for i in range(w-1):\n            if not lst[j][i] :\n                train=1\n                continue\n            if lst[j][i]==lst[j][i+1]:\n                train+=1\n            else :\n                if train>=k:\n                    sm+=lst[j][i]*train\n                    lst[j][i-train+1:i+1]=[None]*train\n                train=1\n        if train>=k:\n            sm+=lst[j][-1]*train\n            lst[j][-train:]=[None]*train\n    return sm\n\n\ndef procedure(lst,h,w,k,x):\n    lst[x[0]][x[1]]=None\n    drop(lst,h,w)\n    sm=0\n    i=0\n    point=chain(lst,h,w,k)\n    while point:\n        sm+=(2**i)*point\n        drop(lst,h,w)\n        point=chain(lst,h,w,k)\n        i+=1\n        #print(lst)\n    return sm\n\n\ndef main():\n    h,w,k=map(int,input().split())\n    lst=[[int(x) for x in input()] for _ in range(h)]\n    mx=0\n\n    for i in range(1,h):\n        for j in range(w):\n            work=[[lst[i][j] for j in range(w)] for i in range(h)]\n            sm=procedure(work,h,w,k,(i,j))\n            if mx<sm : mx=sm\n    print(mx)\n\n\nmain()"
  },
  {
    "language": "Python",
    "code": "# https://atcoder.jp/contests/s8pc-3/tasks/s8pc_3_b\n\nimport sys\ninput=sys.stdin.readline\nfrom collections import deque\nfrom copy import deepcopy\n\ndef main():\n    H,W,K=map(int,input().split())\n    mas=[[-1]*W for i in range(H)]\n    for i in range(H):\n        t=input()\n        for j in range(W):\n            mas[H-1-i][j]=int(t[j])\n    maso=deepcopy(mas)\n    maxans=0       \n    for h in range(H):\n        for w in range(W):\n            mas=deepcopy(maso)\n            mas[h][w]=-1\n            for hh in range(h,H-1):\n                t=mas[hh][w]\n                mas[hh][w]=mas[hh+1][w]\n                mas[hh+1][w]=t\n            \n            ans=0\n            nankaime=0\n            while(1):\n                kiesum=0\n                mast=deepcopy(mas)\n                for i in range(H):\n                    for j in range(W):\n                        cnt=1\n                        for k in range(j+1,W):\n                            if mas[i][j]!=-1 and mas[i][k]!=-1 and mas[i][j]==mas[i][k]:\n                                cnt+=1\n                            else:\n                                break\n                        if cnt>=K:\n                            for k in range(cnt):\n                                kiesum+=mas[i][j+k]\n                                mas[i][j+k]=-1\n                            break\n                f=[deque() for i in range(W)]\n                for j in range(W):\n                    for i in range(H):\n                        if mas[i][j]!=-1:\n                            f[j].append(mas[i][j])\n                    for i in range(H-len(f[j])):\n                        f[j].append(-1)\n                for i in range(H):\n                    for j in range(W):\n                        mas[i][j]=f[j].popleft()\n                ans+=pow(2,nankaime)*kiesum\n                nankaime+=1\n                if mas==mast:\n                    break\n            maxans=max(maxans,ans)\n    print(maxans)\n                    \n                    \n                \n    \nif __name__==\"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "import sys\nH, W, K = map(int, input().split())\nHW = [list(map(int, list(str(input())))) for _ in range(H)]\n\ndef blocks(hw):\n    score = 0\n    ret = 1\n    delcnt = 0\n    while ret:\n        ret = check(delcnt, hw)\n        score += ret\n        delcnt += 1\n    return score\n\ndef check(delcnt, hw):\n    s = 0\n    blank = -1\n    for h in range(H):\n        cnt = 1\n        old = hw[h][:]\n        for w in range(1, W):\n            if hw[h][w-1]==hw[h][w]:\n                cnt+=1\n                flg = True\n            else:\n                if cnt>=K:\n                    s += cnt*hw[h][w-1]\n                    for k in range(1, cnt+1):\n                        hw[h][w-k] = blank\n                        blank -= 1\n                cnt = 1\n        if cnt>=K:\n            s += cnt*hw[h][W-1]\n            for k in range(1, cnt+1):\n                hw[h][W-k] = blank\n                blank -= 1\n    for w in range(W):\n        cnt = 1\n        for h in range(H-1, -1, -1):\n            item = hw[h][w]\n            hw[h][w] = blank\n            blank -= 1\n            if item>0:\n                hw[H-cnt][w] = item\n                cnt += 1\n    return 2**delcnt*s\n\nimport copy\nans = []\nif K>=4:\n    print(0)\nelse:\n    for h in range(1, H):\n        for w in range(W):\n            hw = copy.deepcopy(HW)\n            for i in range(H-h, 0, -1):\n                hw[i][w] = hw[i-1][w]\n            hw[0][w] = 0\n            ans.append(blocks(hw))\nprint(max(ans))"
  },
  {
    "language": "Python",
    "code": "H,W,K=map(int,input().split())\nc=[[int(i) for i in list(input())] for i in range(H)]\n#c[i][j]\n#0<=i<H,0<=j<W\ndef falling(board):\n    result=[[board[i][j] for j in range(W)] for i in range(H)]\n    for n in range(H):\n        for i in range(H-1):\n            for j in range(W):\n                if result[H-1-i][j]==0:\n                    result[H-1-i][j]=result[H-2-i][j]\n                    result[H-2-i][j]=0\n    return result\ndef deleting(inp):\n    board=[[inp[i][j] for j in range(W)] for i in range(H)]\n    nv=0\n    length=1\n    sc=0\n    for i in range(H):\n        for j in range(W-1):\n            if board[i][j]==board[i][j+1] and j!=W-2:\n                length+=1\n                nv=board[i][j]\n            else:\n                if length>=K:\n                    for n in range(length):\n                        board[i][j+n+1-length]=0\n                    sc+=length*nv\n                nv=0\n                length=1\n        length=0\n    return {\"board\":board,\"score\":sc}\ndef showing(board):\n    for i in range(H):\n        print(' '.join(map(str,board[i])))\ndef isequal(a,b):\n    for i in range(H):\n        for j in range(W):\n            if a[i][j]!=b[i][j]:\n                return False\n    return True\ndef choice(board,x,y):\n    score=0\n    step=0\n    state=[[board[i][j] for j in range(W)] for i in range(H)]\n    state[x][y]=0\n    while(True):\n        info=deleting(falling(state))\n        nextstate=info[\"board\"]\n        score+=2**(step)*info[\"score\"]\n        if isequal(state,nextstate):\n            break\n        for i in range(H):\n            for j in range(W):\n                state[i][j]=nextstate[i][j]\n        step+=1\n    return score\nans=0\nfor i in range(H):\n    for j in range(W):\n        tmp=choice(c,i,j)\n        if tmp<ans:\n            tmp=ans\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "H, W, K = map(int, input().split())\n\ndef clear(row, start, end, mult):\n    if end - start + 1 < K:\n        return 0\n    gain = 0\n    for i in range(start, end + 1):\n        gain += mult * row[i]\n        row[i] = 0\n    return gain\n\ndef drop(board):\n    for x in range(W):\n        wp = 0\n        for y in range(H):\n            if board[y][x] > 0:\n                board[wp][x] = board[y][x]\n                if wp != y:\n                    board[y][x] = 0\n                wp += 1\n\ndef proceed(board, mult):\n    gain = 0\n    for row in board:\n        start = -1\n        num = -1\n        for i in range(W):\n            if row[i] == num:\n                continue\n            else:\n                gain += clear(row, start, i-1, mult)\n                num = row[i]\n                start = i\n        if num > 0:\n            gain += clear(row, start, W-1, mult)\n    drop(board)\n    return gain\n\nboard_ = []\nfor _ in range(H):\n    board_.append(list(map(int, input())))\nboard_.reverse()\n\nans = 0\nfor y in range(H):\n    for x in range(W):\n        board = deepcopy(board_)\n        board[y][x] = 0\n        drop(board)\n        mult = 1\n        cand = 0\n        while True:\n            gain = proceed(board, mult)\n            if gain == 0:\n                break\n            cand += gain\n            mult *= 2\n        ans = max(ans, cand)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "class Puzzle():\n  def __init__(self, mat, h,w,k):\n    self.mat = mat\n    self.h = h\n    self.w = w\n    self.k = k\n    self.score = 0\n\n  def calc(self, t):\n    tmp_score = 0\n\n    # print(\"before\")\n    # for m in self.mat:\n    #   print(m)\n\n    for i in range(self.h):\n      for j in range(self.w):\n        if self.mat[i][j] > 0:\n          for k in range(self.w, -1, -1):\n            # if k - j < self.k: break\n            if k-j >= self.k:\n              s = set(self.mat[i][j:k])\n              if len(s) == 1 and -1 not in s:\n                tmp_score += list(s)[0] * (k-j)\n                for l in range(j, k):\n                  self.mat[i][l] = -1\n            else:\n              break\n\n    # print(\"calced\")\n    # for m in self.mat:\n    #   print(m)\n\n    if tmp_score == 0:\n      return False\n    else:\n      self.score += pow(2, t) * tmp_score\n      if self.score == 642: import pdb; pdb.set_trace()\n      return True\n\n  def flatten(self):\n    pivot_mat = []\n    for i in range(self.w):\n      row = []\n      for j in range(self.h):\n        if self.mat[j][i] != -1:\n          row.append(self.mat[j][i])\n\n      short = self.h - len(row)\n      if short > 0:\n        row.reverse()\n        for k in range(short):\n          row.append(-1)\n        row.reverse()\n      \n      pivot_mat.append(row)\n\n    mat = [ [-1]*self.w for i in range(self.h) ]\n    for i in range(self.h):\n      for j in range(self.w):\n        mat[i][j] = pivot_mat[j][i]\n\n    self.mat = mat\n\nh,w,k = map(int,input().split())\nmat = []\nfor _ in range(h):\n  mat.append([int(e) for e in list(input())])\n\nres = 0\nfor i in range(h):\n  for j in range(w):\n    old = mat[i][j]\n    mat[i][j] = -1\n    puzzle = Puzzle(mat,h,w,k)\n    puzzle.flatten()\n    time = 0\n    while True:\n      if puzzle.calc(time):\n        puzzle.flatten()\n        time += 1\n      else:\n        break\n    res = max(res, puzzle.score)\n    mat[i][j] = old\n\nprint(res)\n"
  },
  {
    "language": "Python",
    "code": "\nclass Game:\n    def __init__(self, mp, h, w, k):\n        self.mp = mp\n        self.H = h\n        self.W = w\n\n        self.K = k\n        self.score = 0\n        self.erase_flag = False\n        self.cnt = 0\n        \n    def erase(self):\n        tot = 0\n        for y in range(self.H):\n            line = self.mp[y]\n            new_line, add_score = self.fix(line)\n            self.mp[y] = new_line\n            tot += add_score\n            if add_score != 0:\n                self.erase_flag = True\n        if self.erase_flag:\n            self.score += tot*pow(2, self.cnt)\n            self.cnt += 1\n    \n    def fix(self, line):\n        add_score = 0\n        new_line = line\n        for length in range(self.W, self.K-1, -1):\n            for left in range(self.W - length+1):\n                if all(map(lambda x:x==new_line[left], new_line[left:left+length])):\n                    add_score += new_line[left]*length\n                    new_line = new_line[:left] + [0]*length + new_line[left+length:]\n                    # 最後の要素まで見たか？\n                    # if self.W == left+length:\n                    #     return new_line, add_score\n        return new_line, add_score\n    \n    def fall(self):\n        for x in range(self.W):\n            col = [self.mp[y][x] for y in range(self.H) if self.mp[y][x] != 0]\n            # for y in range(self.H):\n            #     if self.mp[y][x] != 0:\n            #         col.append(self.mp[y][x])\n            col = [0]*(self.H - len(col)) + col\n            for y in range(self.H):\n                self.mp[y][x] = col[y]\n\n\n    def run(self):\n        while True:\n            self.erase_flag = False\n            self.erase()\n            if not self.erase_flag:\n                break\n            self.fall()\n\nimport sys\nsys.setrecursionlimit(10 ** 7)\nread = sys.stdin.buffer.read \ninp = sys.stdin.buffer.readline\n\nimport copy\ndef resolve():\n    def init_fall(grid, cell):\n        col = [grid[y][cell] for y in range(H) if grid[y][cell] != 0]\n        # for y in range(H):\n        #     if grid[y][cell] != 0:\n        #         col.append(grid[y][cell])\n        col = [0] * (H - len(col)) + col\n        for y in range(H):\n            grid[y][cell] = col[y]\n        return grid\n\n    H, W, K = map(int, inp().split())\n    mp = [list(map(int, inp())) for _ in range(H)]\n\n    ans = 0\n    for i in range(1,H):\n        for j in range(W):\n            mp_copy = copy.deepcopy(mp)\n            mp_copy[i][j] = 0\n            mp_copy = init_fall(mp_copy,j)\n            game = Game(mp_copy, H, W, K)\n            game.run()\n            ans = max(ans, game.score)\n    print(ans)\n\nif __name__ == \"__main__\":\n    resolve()"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nimport sys\ndef main():\n  input=sys.stdin.readline\n  h,w,k=map(int,input().split())\n  grid=[]\n  for _ in range(h):\n    s=input().rstrip()\n    s=list(s)\n    s=list(map(int,s))\n    grid.append(s)\n  def score(t):\n    total=0\n    for i in range(1,h):\n      for j in range(w-1):\n        cnt=1\n        ten=gc[i][j]\n        while gc[i][j+1]==gc[i][j]:\n          cnt+=1\n          j+=1\n          if j==w-1:\n            break\n        if cnt>=k:\n          total+=2**t*(ten*cnt)\n          gc[i][j-cnt+1:j+1]=[0]*cnt\n    return total\n  def upd():\n    while 1:\n      ok=True\n      for i in range(1,h):\n        for j in range(w):\n          if gc[i][j]==0 and gc[i-1][j]!=0:\n            x=gc[i-1][j]\n            gc[i-1][j]=0\n            gc[i][j]=x\n            ok=False\n      if ok:\n        return\n  ans=0\n  for i in range(1,h):\n    for j in range(w):\n      gc=deepcopy(grid)\n      gc[i][j]=0\n      t=0\n      res=0\n      while 1:\n        upd()\n        total=score(t)\n        if total==0:\n          break\n        t+=1\n        res+=total\n      ans=max(ans,res)\n  return print(ans)\nif __name__=='__main__':\n  main()"
  },
  {
    "language": "Python",
    "code": "h, w, k  = map(int, input().split())\n\npuyo_orig = [[0]*w for _ in range(h+1)]\nfor i in range(1,h+1):\n    puyo_orig[i] = list(map(int, list(input())))\n\nimport copy\nmx = 0\nfor i1 in range(2,h+1):\n    for i2 in range(w):\n        puyo = copy.deepcopy(puyo_orig)\n        for l in range(i1,0,-1):\n            puyo[l][i2] = puyo[l-1][i2]\n        p = 0\n        fin = 0\n        turn = 0\n        while fin==0:\n            fin = 1\n            for i in range(2,h+1):\n                cnt = 1\n                for j in range(w-1):\n                    if puyo[i][j+1] == puyo[i][j] and puyo[i][j]>0:\n                        cnt += 1\n                    elif cnt>=k:\n                        p += cnt * puyo[i][j] * 2**turn\n                        for l in range(i,0,-1):\n                            puyo[l][j-cnt+1:j+1] = puyo[l-1][j-cnt+1:j+1]\n                        fin = 0\n                        cnt = 1\n                    if j==w-2:\n                        if cnt>=k:\n                            p += cnt * puyo[i][j] * 2**turn\n                            for l in range(i,0,-1):\n                                puyo[l][j-cnt+2:] = puyo[l-1][j-cnt+2:]\n                            fin = 0\n            turn += 1\n        if p>mx:\n            mx=p\n            \nprint(mx)\n"
  },
  {
    "language": "Python",
    "code": "# https://atcoder.jp/contests/s8pc-3/tasks/s8pc_3_b\n\nimport sys\ninput=sys.stdin.readline\nfrom collections import deque\nfrom copy import deepcopy\n\ndef main():\n    H,W,K=map(int,input().split())\n    mas=[[-1]*W for i in range(H)]\n    for i in range(H):\n        t=input()\n        for j in range(W):\n            mas[H-1-i][j]=int(t[j])\n    maso=deepcopy(mas)\n    maxans=0       \n    for h in range(H):\n        for w in range(W):\n            mas=deepcopy(maso)\n            mas[h][w]=-1\n            for hh in range(h,H-1):\n                t=mas[hh][w]\n                mas[hh][w]=mas[hh+1][w]\n                mas[hh+1][w]=t\n            \n            ans=0\n            nankaime=0\n            while(1):\n                kiesum=0\n                mast=deepcopy(mas)\n                for i in range(H):\n                    for j in range(W):\n                        cnt=1\n                        for k in range(j+1,W):\n                            if mas[i][j]!=-1 and mas[i][k]!=-1 and mas[i][j]==mas[i][k]:\n                                cnt+=1\n                            else:\n                                break\n                        if cnt>=K:\n                            for k in range(cnt):\n                                kiesum+=mas[i][j+k]\n                                mas[i][j+k]=-1\n                            break\n                f=[deque() for i in range(W)]\n                for j in range(W):\n                    for i in range(H):\n                        if mas[i][j]!=-1:\n                            f[j].append(mas[i][j])\n                    for i in range(H-len(f[j])):\n                        f[j].append(-1)\n                for i in range(H):\n                    for j in range(W):\n                        mas[i][j]=f[j].popleft()\n                ans+=pow(2,nankaime)*kiesum\n                nankaime+=1\n                if mas==mast:\n                    break\n            maxans=max(maxans,ans)\n    print(maxans)\n                    \n                    \n                \n    \nif __name__==\"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nH, W, K = map(int, input().split())\nboard = [[0]*(W+1) for _ in range(H+1)]\nfor i in range(1,H+1):\n    board[i] = list(map(int, list(input())))+[0]\ndef drop(board_copy):\n    change = True\n    score = 0\n    p = 0\n    while change:\n        change = False\n        for i in range(2,H+1):\n            ser = 1\n            for j in range(W):\n                if board_copy[i][j]>0 and board_copy[i][j]==board_copy[i][j+1]:\n                    ser += 1\n                else:\n                    if ser>=K:\n                        score += 2**p*board_copy[i][j]*ser\n                        change = True\n                        for k in range(i,0,-1):\n                            board_copy[k][j-ser+1:j+1] = board_copy[k-1][j-ser+1:j+1]\n                    ser = 1\n        p += 1\n    return score\nans = 0\nfor h in range(2,H+1):\n    for w in range(W):\n        board_copy = deepcopy(board)\n        for k in range(h,0,-1):\n            board_copy[k][w] = board[k-1][w]\n        ans = max(ans,drop(board_copy))\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "def main():\n    import sys\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10**7)\n    from collections import Counter, deque\n    from collections import defaultdict\n    from itertools import combinations, permutations, accumulate, groupby, product\n    from bisect import bisect_left,bisect_right\n    from heapq import heapify, heappop, heappush\n    from math import floor, ceil,pi,factorial\n    from operator import itemgetter\n    from copy import deepcopy\n    def I(): return int(input())\n    def MI(): return map(int, input().split())\n    def LI(): return list(map(int, input().split()))\n    def LI2(): return [int(input()) for i in range(n)]\n    def MXI(): return [[LI()]for i in range(n)]\n    def SI(): return input().rstrip()\n    def printns(x): print('\\n'.join(x))\n    def printni(x): print('\\n'.join(list(map(str,x))))\n    inf = 10**17\n    mod = 10**9 + 7\n#main code here!\n    h,w,k=MI()\n    lis=[list(map(int,list(SI()))) for i in range(h)]\n    #print(lis)\n    #print()\n    if k==1:\n        ans=0\n        for i in range(h):\n            ans+=sum(lis[i])\n        print(ans)\n        sys.exit()\n    def process(board):\n        res=0\n        for i in range(w):\n            plus=[]\n            for j in range(h):\n                m=h-1-j\n                if board[m][i]>0:\n                    plus.append(board[m][i])\n            for j in range(h):\n                if j<len(plus):\n                    board[h-1-j][i]=plus[j]\n                else:\n                    board[h-1-j][i]=0\n                '''m=h-1-j\n                pos=0\n                print(board[m][i])\n                z=board[m][i]\n                if z>0:\n                    board[h-1-pos][i]=z\n                    if pos!=j:\n                        board[m][i]=0\n                    pos+=1\n                print(board)'''\n                    \n        #print(board)\n        #print()\n        for i in range(h):\n            seq=1\n            for j in range(w-1):\n                if board[i][j]==board[i][j+1]:\n                    seq+=1\n                else:\n                    if seq>=k:\n                        res+=seq*board[i][j]\n                        for l in range(j+1-seq,j+1):\n                            board[i][l]=0\n                    seq=1\n            if seq>=k:\n                res+=seq*board[i][j]\n                for l in range(w-seq,w):\n                    board[i][l]=0\n        #print(board)\n        return res\n    process(lis)\n    ans=0\n    for i in range(w):\n        for j in range(h):\n            boardx=deepcopy(lis)\n            boardx[j][i]=0\n            flag=True\n            z=0\n            res=0\n            while flag==True:\n                x=process(boardx)\n                if x==0:\n                    flag=False\n                else:\n                    res+=x*(2**z)\n                    #print(z,x,x*(2**z))\n                    z+=1\n            #print(res)\n            #print()\n            ans=max(ans,res)\n    print(ans)\n\n\n    \n        \n    \n    \nif __name__==\"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom copy import deepcopy\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\n\n\ndef drop(H, G):\n    G = [[n for n in col if n != -1] for col in zip(*G)]\n    G = [[-1] * (H - len(col)) + col for col in G]\n    G = [list(row) for row in zip(*G)]\n    return G\n\n\ndef main():\n    H, W, K = map(int, readline().split())\n    G_init = [list(map(int, list(readline().strip()))) for _ in range(H)]\n\n    ans = 0\n    for i in range(H):\n        for j in range(W):\n            G = deepcopy(G_init)\n            G[i][j] = -1\n            G = drop(H, G)\n\n            current_ans = 0\n            step = 0\n            while True:\n                score = 0\n                for row in G:\n                    seq = [[row[0], 1]]\n                    for n in row[1:]:\n                        if n == seq[-1][0]:\n                            seq[-1][1] += 1\n                        else:\n                            seq.append([n, 1])\n                    idx = 0\n                    for n, c in seq:\n                        if n != -1 and c >= K:\n                            score += n * c\n                            row[idx : idx + c] = [-1] * c\n                        idx += c\n\n                if score == 0:\n                    break\n\n                current_ans += score * pow(2, step)\n                step += 1\n                G = drop(H, G)\n\n            if current_ans > ans:\n                ans = current_ans\n\n    print(ans)\n    return\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom copy import deepcopy\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\n\n\ndef drop(H, W, G):\n    for i in range(1, H):\n        for j in range(W):\n            if G[i][j] == -1 and G[i - 1][j] != -1:\n                k = i\n                for k in range(i, 0, -1):\n                    if G[k][j] != -1:\n                        break\n                    G[k][j], G[k - 1][j] = G[k - 1][j], -1\n\n\ndef main():\n    H, W, K = map(int, readline().split())\n    G_init = [list(map(int, readline().strip())) for _ in range(H)]\n\n    ans = 0\n    for i in range(H):\n        for j in range(W):\n            G = deepcopy(G_init)\n            G[i][j] = -1\n            drop(H, W, G)\n\n            current_ans = 0\n            step = 0\n            while True:\n                score = 0\n                for row in G:\n                    cnt = 1\n                    for k in range(1, W):\n                        if row[k] == row[k - 1]:\n                            cnt += 1\n                        else:\n                            if cnt >= K and row[k - 1] != -1:\n                                score += row[k - 1] * cnt\n                                row[k - cnt : k] = [-1] * cnt\n                            cnt = 1\n                    if cnt >= K and row[W - 1] != -1:\n                        score += row[W - 1] * cnt\n                        row[W - cnt : W] = [-1] * cnt\n\n                if score == 0:\n                    break\n\n                current_ans += score * pow(2, step)\n                step += 1\n                drop(H, W, G)\n\n            if current_ans > ans:\n                ans = current_ans\n\n    print(ans)\n    return\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque   \n\nicase=0\nif icase==0:\n    h,w,k=map(int,input().split())\n    aa=[[0]*w for i in range(h)]\n    for i in range(h):\n        ll=input()\n        for j in range(w):\n            aa[h-1-i][j]=int(ll[j])\nelif icase==1:\n    h,w,k=4,4,2    \n    aa=[[2, 3, 1, 2], [1, 4, 2, 4], [4, 1, 2, 1], [3, 4, 1, 3]]\nelif icase==2:\n    h,w,k=4,4,2    \n    aa=[[2, 1, 2, 1], [1, 2, 1, 2], [2, 1, 2, 1], [1, 2, 1, 2]]\nelif icase==3:\n    h,w,k=7,7,2    \n    aa=[[8, 9, 8, 9, 8, 9, 8], [9, 8, 9, 8, 9, 8, 9], [8, 9, 8, 9, 8, 9, 8], [9, 8, 9, 8, 9, 8, 9], [8, 9, 8, 9, 8, 9, 8], [9, 8, 9, 8, 9, 8, 9], [8, 9, 8, 9, 8, 9, 8]]\nelif icase==4:\n    h,w,k=17,17,2    \n    aa=[[8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6], [7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5], [6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4], [5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3], [4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2], [3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1], [2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8], [9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7], [8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6], [7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5], [6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4], [5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3], [4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2], [3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1], [2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8]]\n#    print(a)\npmax=0\nfor j in range(h):\n    a=[[0]*w for i in range(h)]\n    for i in range(h):\n        for j2 in range(w):\n            a[i][j2]=aa[i][j2]\n#    print(\"j:\",j,a)\n    for ii in range(h-1):\n        a[ii][j]=a[ii+1][j]\n    a[h-1][j]=0\n#    print(\"1:\",a)\n    p=0\n    ip=-1\n    icnt=0\n    while True:\n        icnt+=1\n        if icnt>50:\n            break\n        ip+=1\n        p1=0\n        yn=\"\"\n        for i in range(h):\n            q=deque()\n            for j2 in range(w-k+1):\n                for j3 in range(j2+1,j2+k):\n                    if a[i][j2]==0 or a[i][j2]!=a[i][j3]:\n                        break\n                    q.append((j2,a[i][j2]))\n                    yn=\"yes\"\n#            print(\"i:\",i,q)\n            jm=-2\n            while len(q)>0:\n                j2,aij=q.popleft()\n                for j3 in range(j2,j2+k):\n                    a[i][j3]=0\n#                print(\"j2:\",j2,\"jm+1:\",jm+1)\n                if j2!=jm+1:\n                    p1+=aij*k\n                else:\n                    p1+=aij\n                jm=j2\n#                print(\"p1:\",p1)\n\n#            print(\"1:\",a)\n#        print(\"2:\",a)\n        for jj in range(w):\n            for ii in range(h):\n                if a[ii][jj]==0:\n                    for iii in range(ii+1,h):\n                        if a[iii][jj]!=0:\n                            a[ii][jj]=a[iii][jj]\n                            a[iii][jj]=0\n                            break\n#        print(yn,a)\n        p+=p1*(2**ip)\n        if yn!=\"yes\":\n#            print(p,p1,ip)\n            break\n#    print(\"---------------------\")\n    pmax=max(pmax,p)\n#        print(a)\nprint(pmax)\n    "
  },
  {
    "language": "Python",
    "code": "def main():\n    h, w, k = map(int, raw_input().split())\n    c = [map(int, raw_input().strip()) for _ in xrange(h)]\n    def go(a):\n        if not res:\n            return 0\n        return go(a) * 2 + res\n    ans = 0\n    for ii in xrange(h):\n        for jj in xrange(w):\n            a = [c[i][:] for i in xrange(h)]\n            a[ii][jj] = 0\n            r = 0\n            e = 1\n            while res:\n                for j in xrange(w):\n                    st = [a[i][j] for i in xrange(h) if a[i][j]]\n                    for i in xrange(h):\n                        a[i][j] = 0\n                    i = -1\n                    for x in reversed(st):\n                        a[i][j] = x\n                        i -= 1\n                res = 0\n                for i in xrange(h):\n                    j = 0\n                    while j < w:\n                        t = j + 1\n                        while t < w and a[i][j] == a[i][t]:\n                            t += 1\n                        if t - j >= k:\n                            for j in xrange(j, t):\n                                res += a[i][j]\n                                a[i][j] = 0\n                        j = t\n                if not res:\n                    break\n                r += res * e\n                e *= 2\n            if ans < r:\n                ans = r\n    print ans\nmain()\n"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/env python3\n\ndef dropcell(h, w, rm):\n    for i in range(w):\n        y = 0\n        for j in range(h):\n            if rm[h-j-1][i] != 0:\n                rm[h-y-1][i] = rm[h-j-1][i]\n                y += 1\n        for j in range(h-y):\n            rm[h-y-j-1][i] = 0\n\ndef removecell(h, w, k, rm, a):\n    p = 0\n    for y in range(h):\n        c, t = 1, 0\n        for i in range(w+1):\n            x = rm[y][i]\n            if x > 0 and x == t:\n                c += 1\n            else:\n                if c >= k:\n                    for j in range(c):\n                        rm[y][i-1-j] = 0\n                    p += (t * c)\n                t = x\n                c = 1\n    return p * (2**a)\n\ndef game(h, w, k, M, y, x):\n    f, score, a = 1, 0, 0\n    rm = [[j for j in i]for i in M[:y+1]]\n    rm[y][x] = 0\n    while f:\n        dropcell(len(rm), w, rm)\n        f = removecell(len(rm), w, k, rm, a)\n        score += f\n        a += 1\n    return score\n\ndef main():\n    H, W, K = map(int, input().split())\n    M = [list(map(int, list(input())))+[0] for i in range(H)]\n    ans = 0\n    for j in range(W):\n        t = 0\n        for i in range(1, H):\n            if M[i][j] != t:\n                ans = max(ans, game(H, W, K, M, i, j))\n                t = M[i][j]\n    print(ans)\n    \nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nH, W, K = map(int, input().split())\nboard = [[0]*(W+1) for _ in range(H+1)]\nfor i in range(1,H+1):\n    board[i] = list(map(int, list(input())))+[0]\ndef drop(board_copy):\n    change = True\n    score = 0\n    p = 0\n    while change:\n        change = False\n        for i in range(2,H+1):\n            ser = 1\n            for j in range(1,W+1):\n                if board_copy[i][j]>0 and board_copy[i][j]==board_copy[i][j-1]:\n                    ser += 1\n                else:\n                    if ser>=K:\n                        score += 2**p*board_copy[i][j-1]*ser\n                        change = True\n                        for k in range(i,0,-1):\n                            board_copy[k][j-ser:j] = board_copy[k-1][j-ser:j]\n                    ser = 1\n        p += 1\n    return score\nans = 0\nfor h in range(1,H+1):\n    for w in range(W):\n        board_copy = deepcopy(board)\n        for k in range(h,0,-1):\n            board_copy[k][w] = board[k-1][w]\n        ans = max(ans,drop(board_copy))\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nH, W, K = [int(x) for x in input().split()]\nc = [[int(x) for x in list(input())] for _ in range(H)]\nc.reverse()\n\nmax_score = 0\nfor y in range(H):\n    for x in range(W):\n        board = deepcopy(c)\n        board[y][x] = None  # 消す\n        score = 0\n        erased = True\n        coeff = 1\n        while erased:\n            erased = False\n            # 落下させる\n            for i in range(1, H):\n                for j in range(W):\n                    k = i\n                    while k > 0 and board[k - 1][j] == None:\n                        k -= 1\n                    board[k][j], board[i][j] = board[i][j], board[k][j]\n\n            # 消す\n            for i in range(H):\n                cnt = 1\n                num = board[i][0]\n                for j in range(1, W):\n                    if board[i][j] != None and board[i][j] == board[i][j - 1]:\n                        num = board[i][j]\n                        cnt += 1\n                    else:\n                        if cnt >= K:\n                            erased = True\n                            score += coeff * cnt * num\n                            board[i][j - cnt : j] = [None] * cnt\n                        cnt = 1\n                if cnt >= K:\n                    erased = True\n                    score += coeff * cnt * num\n                    board[i][j - cnt + 1 : j + 1] = [None] * cnt\n\n            coeff *= 2\n\n        max_score = max(max_score, score)\n\nprint(max_score)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom copy import deepcopy\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\n\n\ndef drop(H, W, G):\n    for i in range(H - 1, 0, -1):\n        for j in range(W):\n            if G[i][j] == -1 and G[i - 1][j] != -1:\n                k = i\n                while k < H and G[k][j] == -1:\n                    G[k][j], G[k - 1][j] = G[k - 1][j], -1\n                    k += 1\n\n\ndef main():\n    H, W, K = map(int, readline().split())\n    G_init = [list(map(int, list(readline().strip()))) for _ in range(H)]\n\n    ans = 0\n    for i in range(H):\n        for j in range(W):\n            G = deepcopy(G_init)\n            G[i][j] = -1\n            drop(H, W, G)\n\n            current_ans = 0\n            step = 0\n            while True:\n                score = 0\n                for row in G:\n                    seq = [[row[0], 1]]\n                    for n in row[1:]:\n                        if n == seq[-1][0]:\n                            seq[-1][1] += 1\n                        else:\n                            seq.append([n, 1])\n                    idx = 0\n                    for n, c in seq:\n                        if n != -1 and c >= K:\n                            score += n * c\n                            row[idx : idx + c] = [-1] * c\n                        idx += c\n\n                if score == 0:\n                    break\n\n                current_ans += score * pow(2, step)\n                step += 1\n                drop(H, W, G)\n\n            if current_ans > ans:\n                ans = current_ans\n\n    print(ans)\n    return\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import sys, itertools, copy\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = 10**20\ndef I(): return int(input())\ndef F(): return float(input())\ndef S(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LS(): return input().split()\n\ndef resolve():\n    H, W, K = LI()\n    c = [[int(i) for i in S()] for _ in range(H)]\n\n    ans = 0\n    for i, j in itertools.product(range(H), range(W)):\n        c_tmp = copy.deepcopy(c)\n        c_tmp[i][j] = 0\n        score = 0\n        chain_cnt = 0\n        while True:\n            # 落下処理\n            # その石がどれだけ落下するかの算出\n            drop = [[0]*W for _ in range(H)]\n            for k in range(W):\n                for l in range(H-1):\n                    drop[H-l-2][k] = drop[H-l-1][k] + (1 if c_tmp[H-l-1][k]==0 else 0)\n            # print('drop')\n            # for i in drop:\n            #     print(i)\n            \n            # 落下先にコピー\n            for k in range(W):\n                for l in range(H):\n                    if drop[H-l-1][k]!=0:\n                        c_tmp[H-l-1+drop[H-l-1][k]][k] = c_tmp[H-l-1][k]\n                        c_tmp[H-l-1][k] = 0\n            # print('dropped s')\n            # for i in c_tmp:\n            #     print(i)\n\n            # 消滅判定\n            num_sum = 0\n            for k in range(H):\n                prev = 0\n                cnt = 1\n                for l in range(W):\n                    if c_tmp[k][l]==prev:\n                        cnt += 1\n                    else:\n                        if cnt>=K:\n                            num_sum += prev*cnt\n                            for m in range(cnt):\n                                c_tmp[k][l-cnt+m] = 0\n                        prev = c_tmp[k][l]\n                        cnt = 1\n                if cnt>=K:\n                    num_sum += prev*cnt\n                    for m in range(cnt):\n                        c_tmp[k][l+1-cnt+m] = 0\n            # print('s')\n            # for i in s:\n            #     print(i)\n            if num_sum==0:\n                break\n            score += (2**chain_cnt) * num_sum\n            chain_cnt += 1\n        ans = max(score, ans)\n\n    print(ans)\n\nif __name__ == '__main__':\n    resolve()"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nH, W, K = map(int, input().split())\nboard = [[0]*(W+1) for _ in range(H+1)]\nfor i in range(1,H+1):\n    board[i] = list(map(int, list(input())))+[0]\ndef drop(board_copy):\n    change = True\n    score = 0\n    p = 0\n    while change:\n        change = False\n        for i in range(2,H+1):\n            ser = 1\n            for j in range(1,W+1):\n                if board_copy[i][j]>0 and board_copy[i][j]==board_copy[i][j-1]:\n                    ser += 1\n                else:\n                    if ser>=K:\n                        score += 2**p*board_copy[i][j-1]*ser\n                        change = True\n                        for k in range(i,0,-1):\n                            board_copy[k][j-ser:j] = board_copy[k-1][j-ser:j]\n                    ser = 1\n        p += 1\n    return score\nans = 0\nfor h in range(2,H+1):\n    for w in range(W):\n        board_copy = deepcopy(board)\n        for k in range(h,0,-1):\n            board_copy[k][w] = board[k-1][w]\n        ans = max(ans,drop(board_copy))\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "h, w, k  = map(int, input().split())\n\npuyo_orig = [[0]*w for _ in range(h+1)]\nfor i in range(1,h+1):\n    puyo_orig[i] = list(map(int, list(input())))\n\nimport copy\nmx = 0\nfor i1 in range(2,h+1):\n    for i2 in range(w):\n        puyo = copy.deepcopy(puyo_orig)\n        for l in range(i1,0,-1):\n            puyo[l][i2] = puyo[l-1][i2]\n        p = 0\n        fin = 0\n        turn = 0\n        while fin==0:\n            fin = 1\n            for i in range(2,h+1):\n                cnt = 1\n                for j in range(1,w):\n                    if puyo[i][j-1] == puyo[i][j] and puyo[i][j]>0:\n                        cnt += 1\n                    else:\n                        if cnt>=k:\n                            p += cnt * puyo[i][j-1] * 2**turn\n                            for l in range(i,0,-1):\n                                puyo[l][j-cnt:j] = puyo[l-1][j-cnt:j]\n                            fin = 0\n                        cnt = 1\n                    if j==w-1:\n                        if cnt>=k:\n                            p += cnt * puyo[i][j-1] * 2**turn\n                            for l in range(i,0,-1):\n                                puyo[l][j-cnt+1:j+1] = puyo[l-1][j-cnt+1:j+1]\n                            fin = 0\n            turn += 1\n        if p>mx:\n            mx=p\n            \nprint(mx)"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nH, W, K = map(int, input().split())\nboard = [[0]*W for _ in range(H+1)]\nfor i in range(1,H+1):\n    board[i] = list(map(int, list(input())))\ndef drop(board_copy):\n    change = True\n    score = 0\n    p = 0\n    while change:\n        change = False\n        for i in range(2,H+1):\n            ser = 1\n            for j in range(W):\n                if j==W-1:\n                    if ser>=K:\n                        score += 2**p*board_copy[i][-1]*ser\n                        change = True\n                        for k in range(i,0,-1):\n                            board_copy[k][j-ser+1:] = board_copy[k-1][j-ser+1:]\n                    continue\n                if board_copy[i][j]==0:\n                    ser = 1\n                    continue\n                if board_copy[i][j]>0 and board_copy[i][j]==board_copy[i][j+1]:\n                    ser += 1\n                elif ser>=K:\n                    score += 2**p*board_copy[i][j]*ser\n                    change = True\n                    for k in range(i,0,-1):\n                        board_copy[k][j-ser+1:j+1] = board_copy[k-1][j-ser+1:j+1]\n                    ser = 1\n        p += 1\n    return score\nans = 0\nfor h in range(1,H+1):\n    for w in range(W):\n        board_copy = deepcopy(board)\n        for k in range(h,0,-1):\n            board_copy[k][w] = board[k-1][w]\n        ans = max(ans,drop(board_copy))\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/env python3\n\ndef dropcell():\n    for y in range(H):\n        for i in range(H):\n            for j in range(W):\n                if gm[H-i][j] == 0:\n                    gm[H-i-1][j], gm[H-i][j] = gm[H-i][j], gm[H-i-1][j]\ndef removecell():\n    global gp, gf\n    gf = False\n    p = 0\n    for y in range(H):\n        c = 1\n        t = 0\n        for i in range(W+1):\n            x = gm[y+1][i]\n            if x > 0 and x == t:\n                c += 1\n            else:\n                if c >= K:\n                    for j in range(c):\n                        gm[y+1][i-1-j] = 0\n                    p += (t * c)\n                    gf = True\n                t = x\n                c = 1\n    gp += p * (2**gi)\n\n\nH, W, K = map(int, input().split())\nM = [[0]*(W+1)]+[list(map(int, list(input())))+[0] for i in range(H)]\npoints = {}\nfor i in range(H)[::-1]:\n    for j in range(W):\n        gp = 0\n        gf = True\n        gi = 0\n        gm = [[j for j in i]for i in M]\n        gm[i+1][j] = 0\n        while gf:\n            dropcell()\n            removecell()\n            gi += 1\n        points[gp] = 1\nprint(max(points))"
  },
  {
    "language": "Python",
    "code": "from itertools import groupby\nimport copy\ndef calc():\n  s = 0\n  for i in range(h):\n    gr = groupby(g[i])\n    j = 0\n    for key,it in gr:\n      if key==-1: continue\n      l = len(list(it))\n      if l >= K:\n        for k in range(l):\n          g[i][j+k] = -1\n        # print(\"s\", key, l, key*l)\n        s += key*l\n      j += l\n      # print(\"j\", j)\n\n  return s\n\ndef flatten():\n  for j in range(w):\n    lst = []\n    for i in range(h-1, -1, -1):\n      if g[i][j] > 0:\n        lst.append(g[i][j])\n\n    lst += [-1] * (h - len(lst))\n\n    for i in range(h-1, -1, -1):\n      g[i][j] = lst[h-i-1]\n\nh,w,K = map(int,input().split())\nmat = []\nfor _ in range(h):\n  mat.append([int(e) for e in list(input())])\n\nres = 0\nfor i in range(h):\n  for j in range(w):\n    score = 0\n    g = copy.deepcopy(mat)\n    g[i][j] = -1\n    time = 0\n    flatten()\n    while True:\n      s = calc()\n      if s > 0:\n        score += pow(2, time) * s\n      else:\n        break\n      flatten()\n      time += 1\n    res = max(res, score)\n\nprint(res)\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nfrom copy import deepcopy\n\ndef input(): return sys.stdin.readline().strip()\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\nH,W,K=MAP()\norgn=[[0]*W for i in range(H)]\nfor i in range(H):\n    nums=input()\n    for j in range(W):\n        orgn[i][j]=int(nums[j])\n\ndef drop():\n    for i in range(H-1, 0, -1):\n        for j in range(W):\n            if grid[i][j]==0 and grid[i-1][j]!=0:\n                k=i\n                while k<H and grid[k][j]==0:     \n                    grid[k][j]=grid[k-1][j]\n                    grid[k-1][j]=0\n                    k+=1\n\ndef check(times):\n    sm=0\n    for i in range(H):\n        st=0\n        cnt=1\n        for j in range(1, W):\n            if grid[i][j-1]==grid[i][j]:\n                cnt+=1\n            else:\n                if cnt>=K:\n                    sm+=grid[i][j-1]*cnt\n                    for k in range(st, j):\n                        grid[i][k]=0\n                cnt=1\n                st=j\n        else:\n            if cnt>=K:\n                sm+=grid[i][j]*cnt\n                for k in range(st, j+1):\n                    grid[i][k]=0\n    return 2**times*sm\n\nans=0\nfor i in range(H):\n    for j in range(W):\n        grid=deepcopy(orgn)\n        grid[i][j]=0    \n        res=1\n        score=times=0\n        while res:\n            drop()\n            res=check(times)\n            score+=res\n            times+=1\n        ans=max(ans, score)\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nH, W, K = map(int, input().split())\nboard = [[0]*W for _ in range(H+1)]\nfor i in range(1,H+1):\n    board[i] = list(map(int, list(input())))\ndef drop(board_copy):\n    change = True\n    score = 0\n    p = 0\n    while change:\n        change = False\n        for i in range(2,H+1):\n            ser = 1\n            for j in range(W):\n                if j==W-1:\n                    if ser>=K:\n                        score += 2**p*board_copy[i][-1]*ser\n                        change = True\n                        for k in range(i,0,-1):\n                            board_copy[k][j-ser+1:] = board_copy[k-1][j-ser+1:]\n                    continue\n                if board_copy[i][j]>0 and board_copy[i][j]==board_copy[i][j+1]:\n                    ser += 1\n                else:\n                    if ser>=K:\n                        score += 2**p*board_copy[i][j]*ser\n                        change = True\n                        for k in range(i,0,-1):\n                            board_copy[k][j-ser+1:j+1] = board_copy[k-1][j-ser+1:j+1]\n                    ser = 1\n        p += 1\n    return score\nans = 0\nfor h in range(1,H+1):\n    for w in range(W):\n        board_copy = deepcopy(board)\n        for k in range(h,0,-1):\n            board_copy[k][w] = board[k-1][w]\n        ans = max(ans,drop(board_copy))\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "H, W, K = map(int, input().split())\nHW = [list(map(int, list(input()))) for _ in range(H)]\n\ndef blocks(hw):\n    score = 0\n    blank = -1\n    flg = True\n    delcnt = 0\n    while flg:\n        flg = False\n        for h in range(H):\n            cnt = 1\n            old = hw[h][:]\n            for w in range(1, W):\n                if hw[h][w-1]==hw[h][w]:\n                    cnt+=1\n                    flg = True\n                else:\n                    if cnt>=K:\n                        score += 2**delcnt*cnt*hw[h][w-1]\n                        for k in range(1, cnt+1):\n                            hw[h][w-k] = blank\n                            blank -= 1\n                    cnt = 1\n            if cnt>=K:\n                score += 2**delcnt*cnt*hw[h][W-1]\n                for k in range(1, cnt+1):\n                    hw[h][W-k] = blank\n                    blank -= 1\n        for w in range(W):\n            lis = []\n            for h in range(H-1, -1, -1):\n                item = hw[h][w]\n                if item>0:\n                    lis.append(item)\n            for idx, i in enumerate(lis, 1):\n                hw[H-idx][w] = i\n        delcnt += 1\n    return score\nimport copy\nans = []\nfor h in range(1, H):\n    for w in range(W):\n        hw = copy.deepcopy(HW)\n        for i in range(H-h, 0, -1):\n            hw[i][w] = hw[i-1][w]\n        hw[0][w] = 0\n        ans.append(blocks(hw))\nprint(max(ans))"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nfrom typing import List\nimport sys\ninput = sys.stdin.readline\n\n\ndef delete_cell_line(line: List[int], k: int) -> int:\n    prev = -1\n    block = 1\n    point = 0\n    for idx, num in enumerate(line+[0]):\n        if num == prev:\n            block += 1\n\n        else:\n            if block >= k:\n                point += prev * block\n                for i in range(idx-block, idx):\n                    line[i] = 0\n            block = 1\n            prev = num\n    return point\n\n\ndef drop_down(board: List[List[int]]):\n    w = len(board[0])\n    h = len(board)\n\n    for x in range(w):\n        vertical_line = []\n        for y in range(h):\n            cell = board[y][x]\n            if cell:\n                vertical_line.append(cell)\n\n        vertical_line = [0]*(h-len(vertical_line)) + vertical_line\n        for y, new_cell in enumerate(vertical_line):\n            board[y][x] = new_cell\n\n\ndef calc_score(y: int, x: int, k: int, board: List[List[int]]) -> int:\n    board[y][x] = 0\n    drop_down(board)\n    chain = 0\n    score = 0\n    while True:\n        point = 0\n        for line in board:\n            point += delete_cell_line(line, k)\n        if not point:\n            break\n\n        score += point * 2**chain\n        chain += 1\n        drop_down(board)\n    return score\n\n\ndef main():\n    h, w, k = map(int, input().split())\n    board = []\n    for _ in range(h):\n        pre_line = input().rstrip(\"\\n\")\n        line = list(map(int, list(pre_line)))\n        board.append(line)\n\n    ans = 0\n    for y in range(h):\n        for x in range(w):\n            new_board = deepcopy(board)\n            score = calc_score(y, x, k, new_board)\n            if ans < score:\n                ans = score\n\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\n\nH, W, K = map(int, input().split())\npuzzle = [list(map(int, list(input()))) for _ in range(H)]\n\n\ndef solve(h, w):\n    pz = deepcopy(puzzle)\n    pz[h][w] = 0\n    tmp_score = -1\n    ans = 0\n    cnt = 0\n    while tmp_score != 0:\n        tmp_score = 0\n        tmp_sum = 0\n        # puzzle落下させる\n        for j in range(W):\n            # 下から作業\n            for i in range(H - 1, 0, -1):\n                if pz[i][j] == 0:\n                    pz[i][j] = pz[i - 1][j]\n                    pz[i - 1][j] = 0\n\n        # puzzle連鎖確認\n        for i in range(H):\n            for left in range(W - 1):\n                for right in range(W, left + 1, -1):\n                    if len(set(pz[i][left:right])) == 1:\n                        tmp_sum += sum(pz[i][left:right])\n                        pz[i] = pz[i][:left] + [0] * (right - left) + pz[i][right:]\n\n        tmp_score += 2 ** cnt * tmp_sum\n        cnt += 1\n        ans += tmp_score\n    return ans\n\n\nf_ans = 0\nfor i in range(H):\n    for j in range(W):\n        # print(i, j)\n        f_ans = max(f_ans, solve(i, j))\n#solve(3, 2)\n\nprint(f_ans)\n"
  },
  {
    "language": "Python",
    "code": "import copy\nH, W, K = map(int, input().split())\nC = [[0] * W for i in range(H)]\nfor i in range(H):\n  s = str(input())\n  for j in range(W):\n    C[i][j] = int(s[j])\n  \ndef delete(mass, s, t):\n  #ここでは、mass[s][t]を試す\n  mass[s][t] = 0\n  #print(mass)\n  score = 0#score\n  p = -1\n  time = -1#何回目の消滅か\n  while p < 1:#消せるものがある間\n    this = 0\n    for i in range(H):\n      now = 1\n      for j in range(1, W):\n        if (mass[i][j] == mass[i][j - 1]) and (mass[i][j] != 0):\n          now += 1\n        else:\n          if now >= K:\n            this += 1\n            score += (2 ** time) * now * mass[i][j - 1]\n            for k in range(j - now, j):\n              mass[i][k] = 0\n          now = 1\n       # print(mass)\n      if now >= K:\n        this += 1\n        score += (2 ** time) * now * mass[i][j - 1]\n        for k in range(j - now + 1, j + 1):\n          mass[i][k] = 0\n    #print(mass)\n    if this == 0:\n      p += 1\n    #落とすところ\n    for i in range(1, H + 1):\n      for j in range(W):\n        if (mass[H - i][j] == 0) and (i != H):\n          k = 1\n          while (mass[H - i - k][j] == 0) and (k + i < H):\n            k += 1\n          mass[H - i][j] = mass[H - i - k][j]\n          mass[H - i - k][j] = 0\n    time += 1\n  return score\n\nans = 0\nfor i in range(H):\n  for j in range(W):\n    D = copy.deepcopy(C)\n    ans = max(ans, delete(D, i, j))\n  \nprint(ans)\n  \n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "h, w, k  = map(int, input().split())\n\npuyo_orig = [list(map(int, list(input()))) for _ in range(h)]\n\nimport copy\nmx = 0\nfor i1 in range(h):\n    for i2 in range(w):\n        puyo = copy.deepcopy(puyo_orig)\n        puyo[i1][i2] = -1\n        p = 0\n        fin = 0\n        turn = 0\n        while fin==0:\n            #[print(*puyo[i]) for i in range(h)]\n            fin = 1\n            \n            for i in range(w):\n                d_fin = 0\n                while d_fin==0:\n                    d_fin = 1\n                    for j in range(h-1, 0, -1):\n                        if puyo[j][i]==-1 and puyo[j-1][i]>0:\n                            puyo[j][i] = puyo[j-1][i]\n                            puyo[j-1][i] = -1\n                            d_fin = 0\n                            \n            for i in range(h):\n                cnt = 1\n                for j in range(1, w):\n                    if puyo[i][j-1] == puyo[i][j] and puyo[i][j]>0:\n                        cnt += 1\n                    else:\n                        if cnt>=k:\n                            p += cnt * puyo[i][j-1] * 2**turn\n                            for k2 in range(cnt):\n                                puyo[i][j-k2-1] = -1\n                                fin = 0\n                        cnt = 1\n                    if j==w-1:\n                        if cnt>=k:\n                            p += cnt * puyo[i][j-1] * 2**turn\n                            for k2 in range(cnt):\n                                puyo[i][j-k2] = -1\n                                fin = 0\n            turn += 1\n        if p>mx:\n            mx=p\n            \nprint(mx)\n"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\n\nH, W, K = map(int, input().split())\nX = [list(map(int, list(input()))) for _ in range(H)]\n\ndef gen_mask(X, idx=None):\n    mask = [[True] * W for _ in range(H)]\n    if idx is not None:\n        i, j = idx\n        mask[i][j] = False\n        return mask\n    \n    # Erase mask\n    for i in range(H):\n        for j in range(W):\n            tmp = [False] * W\n            for k in range(j, W):\n                if X[i][j] == X[i][k]:\n                    tmp[k] = True\n                else:\n                    break\n            if sum(tmp) >= K:\n                mask[i] = [not v for v in tmp]\n                break\n    return mask\n\ndef erase(X, mask):\n    new = [[0] * W for _ in range(H)]\n    res = 0\n    for j in range(W):\n        idx = H - 1\n        for i in reversed(range(H)):\n            if mask[i][j]:\n                new[idx][j] = X[i][j]\n                idx -= 1\n            else:\n                res += X[i][j]\n\n    return new, res\n\ndef compute(idx):\n    X_tmp = deepcopy(X)\n    mask = gen_mask(X_tmp, idx)\n    res = 0\n\n    for i in range(-1, 1000):\n        X_new, tmp = erase(X_tmp, mask)\n        if tmp == 0:\n            break\n\n        # Update\n        X_tmp = X_new\n        mask = gen_mask(X_tmp)\n        \n        if i >= 0:\n            res += 2 ** i * tmp\n\n    return res\n\nans = 0\nfor i in range(H):\n    for j in range(W):\n        ans = max(ans, compute((i, j)))\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import copy\nH, W, K = map(int, input().split())\nnums = [list(map(int, list(input()))) for _ in range(H)]\nans = 0\nfor row in range(1, H):\n    for col in range(W):\n        score = 0\n        iterations = 0\n        squares = copy.deepcopy(nums)\n        squares[row][col] = 0\n        # print(squares)\n        while True:\n            not_falled = True\n            # 下からやっていった方がいい。また、0行目はやる必要なし\n            for i in range(H - 1, 0, -1):\n                for k, num in enumerate(squares[i]):\n                    if num == 0 and squares[i - 1][k] != 0:\n                        squares[i - 1][k], squares[i][k] = squares[i][k], squares[i - 1][k]\n                        not_falled = False\n            if not_falled:\n                break\n        # print(squares)\n        while True:\n            deleted = False\n            for i in range(H):\n                for j in range(W, K - 1, -1):\n                    for k in range(W - j + 1):\n                        deletable = True\n                        first_num = squares[i][k]\n                        if first_num == 0:\n                            continue\n                        for num in squares[i][k + 1:k + j]:\n                            if first_num != num:\n                                deletable = False\n                                break\n                        # print(deletable)\n                        if deletable:\n                            # print((2**iterations) * (first_num * j))\n                            score += (2**iterations) * (first_num * j)\n                            squares[i][k:k + j] = [0] * j\n                            deleted = True\n            # print(squares)\n            if deleted:\n                while True:\n                    not_falled = True\n                    # 下からやっていった方がいい。また、0行目はやる必要なし\n                    for i in range(H - 1, 0, -1):\n                        for k, num in enumerate(squares[i]):\n                            if num == 0 and squares[i - 1][k] != 0:\n                                squares[i - 1][k], squares[i][k] = squares[i][k], squares[i - 1][k]\n                                not_falled = False\n                    if not_falled:\n                        break\n            else:\n                break\n            iterations += 1\n        # print(ans, score)\n        ans = max(ans, score)\nprint(ans)\n# print(squares)s\n"
  },
  {
    "language": "Python",
    "code": "from itertools import groupby\n# import copy\ndef calc():\n  s = 0\n  for i in range(h):\n    gr = groupby(g[i])\n    j = 0\n    for key,it in gr:\n      if key==-1: continue\n      l = len(list(it))\n      if l >= K:\n        for k in range(l):\n          g[i][j+k] = -1\n        # print(\"s\", key, l, key*l)\n        s += key*l\n      j += l\n      # print(\"j\", j)\n\n  # for m in g:\n  #   print(m)\n  # print(s)\n  # import pdb; pdb.set_trace()\n  return s\n\ndef flatten():\n  for j in range(w):\n    lst = []\n    for i in range(h-1, -1, -1):\n      if g[i][j] > 0:\n        lst.append(g[i][j])\n\n    lst += [-1] * (h - len(lst))\n\n    for i in range(h-1, -1, -1):\n      g[i][j] = lst[h-i-1]\n\nh,w,K = map(int,input().split())\nmat = []\nfor _ in range(h):\n  mat.append([int(e) for e in list(input())])\n\nres = 0\nfor i in range(h):\n  for j in range(w):\n    score = 0\n    # g = copy.deepcopy(mat)\n    g = [ [ mat[n][m] for m in range(w) ] for n in range(h) ]\n    g[i][j] = -1\n    time = 0\n    flatten()\n    while True:\n      s = calc()\n      if s > 0:\n        score += pow(2, time) * s\n      else:\n        break\n      flatten()\n      time += 1\n    res = max(res, score)\n\nprint(res)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom copy import deepcopy\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\n\n\ndef drop(H, W, G):\n    for i in range(1, H):\n        for j in range(W):\n            if G[i][j] == -1 and G[i - 1][j] != -1:\n                k = i\n                for k in range(i, 0, -1):\n                    if G[k][j] != -1:\n                        break\n                    G[k][j], G[k - 1][j] = G[k - 1][j], -1\n\n\ndef main():\n    H, W, K = map(int, readline().split())\n    G_init = [list(map(int, readline().strip())) for _ in range(H)]\n\n    ans = 0\n    for i in range(H):\n        for j in range(W):\n            G = deepcopy(G_init)\n            G[i][j] = -1\n            drop(H, W, G)\n\n            current_ans = 0\n            step = 0\n            while True:\n                score = 0\n                for row in G:\n                    seq = [[row[0], 1]]\n                    for n in row[1:]:\n                        if n == seq[-1][0]:\n                            seq[-1][1] += 1\n                        else:\n                            seq.append([n, 1])\n                    idx = 0\n                    for n, c in seq:\n                        if n != -1 and c >= K:\n                            score += n * c\n                            row[idx : idx + c] = [-1] * c\n                        idx += c\n\n                if score == 0:\n                    break\n\n                current_ans += score * pow(2, step)\n                step += 1\n                drop(H, W, G)\n\n            if current_ans > ans:\n                ans = current_ans\n\n    print(ans)\n    return\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "# https://atcoder.jp/contests/s8pc-3/tasks/s8pc_3_b\n\nimport sys\ninput=sys.stdin.readline\nfrom collections import deque\nfrom copy import deepcopy\n\ndef main():\n    H,W,K=map(int,input().split())\n    mas=[[-1]*W for i in range(H)]\n    for i in range(H):\n        t=input()\n        for j in range(W):\n            mas[H-1-i][j]=int(t[j])\n    maso=deepcopy(mas)\n    maxans=0       \n    for h in range(H):\n        for w in range(W):\n            mas=deepcopy(maso)\n            mas[h][w]=-1\n            for hh in range(h,H-1):\n                t=mas[hh][w]\n                mas[hh][w]=mas[hh+1][w]\n                mas[hh+1][w]=t\n            \n            ans=0\n            nankaime=0\n            while(1):\n                kiesum=0\n                mast=deepcopy(mas)\n                for i in range(H):\n                    for j in range(W):\n                        cnt=1\n                        for k in range(j+1,W):\n                            if mas[i][j]!=-1 and mas[i][k]!=-1 and mas[i][j]==mas[i][k]:\n                                cnt+=1\n                            else:\n                                break\n                        if cnt>=K:\n                            for k in range(cnt):\n                                kiesum+=mas[i][j+k]\n                                mas[i][j+k]=-1\n                            break\n                f=[deque() for i in range(W)]\n                for j in range(W):\n                    for i in range(H):\n                        if mas[i][j]!=-1:\n                            f[j].append(mas[i][j])\n                    for i in range(H-len(f[j])):\n                        f[j].append(-1)\n                for i in range(H):\n                    for j in range(W):\n                        mas[i][j]=f[j].popleft()\n                ans+=pow(2,nankaime)*kiesum\n                nankaime+=1\n                if mas==mast:\n                    break\n            maxans=max(maxans,ans)\n    print(maxans)\n                    \n                    \n                \n    \nif __name__==\"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\ndef deepcopy(li):\n    return [x[:] for x in li]\n\nH,W,K=MAP()\norgn=[[0]*W for i in range(H)]\nfor i in range(H):\n    nums=input()\n    for j in range(W):\n        orgn[i][j]=int(nums[j])\n\n# ブロックが落ちる動き\ndef drop():\n    for i in range(H-1, 0, -1):\n        for j in range(W):\n            if grid[i][j]==0 and grid[i-1][j]!=0:\n                k=i\n                while k<H and grid[k][j]==0:     \n                    grid[k][j]=grid[k-1][j]\n                    grid[k-1][j]=0\n                    k+=1\n\n# 揃ったところを消して合計を計算\ndef check(times):\n    sm=0\n    for i in range(H):\n        st=0\n        cnt=1\n        for j in range(1, W):\n            if grid[i][j-1]==grid[i][j]:\n                cnt+=1\n            else:\n                if cnt>=K:\n                    sm+=grid[i][j-1]*cnt\n                    for k in range(st, j):\n                        grid[i][k]=0\n                cnt=1\n                st=j\n        else:\n            if cnt>=K:\n                sm+=grid[i][j]*cnt\n                for k in range(st, j+1):\n                    grid[i][k]=0\n    return 2**times*sm\n\nans=0\nfor i in range(H):\n    for j in range(W):\n        # 元の状態は保持しておいて、全部試す\n        grid=deepcopy(orgn)\n        grid[i][j]=0    \n        res=1\n        score=times=0\n        # 消えるところがある限りループ\n        while res:\n            drop()\n            res=check(times)\n            score+=res\n            times+=1\n        ans=max(ans, score)\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "'''\nhttps://atcoder.jp/contests/s8pc-3/tasks/s8pc_3_b\n'''\ndef main():\n    import sys\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10000000)\n    from collections import Counter, deque\n    #from collections import defaultdict\n    from itertools import combinations, permutations, accumulate\n    #from itertools import product\n    from bisect import bisect_left,bisect_right\n    import heapq\n    from math import floor, ceil\n    #from operator import itemgetter\n\n    #inf = 10**17\n    #mod = 10**9 + 7\n\n    h,w,k = map(int, input().split())\n    banmen = []\n    for _ in range(h):\n        s = input().rstrip()\n        s = list(s)\n        s = list(map(int, s))\n        banmen.append(s)\n\n    def update():\n        while 1:\n            cnt = 0\n            for i in range(h-1):\n                for j in range(w):\n                    if c[i][j] == 0 and c[i+1][j] != 0:\n                        c[i][j], c[i+1][j] = c[i+1][j], c[i][j]\n                        cnt += 1\n            if cnt == 0:\n                return\n\n    #n回目(0~)\n    def get(n):\n        total = 0\n        for i in range(h):\n            for j in range(0, w-k+1, 1):\n                ten = c[i][j]\n                cnt = 1\n                while c[i][j] == c[i][j+1]:\n                    cnt += 1\n                    j += 1\n                    if j == w-1:\n                        break\n                if cnt >= k:\n                    total += 2**n * (ten*cnt)\n                    c[i][j-(cnt-1):j+1] = [0]*cnt\n        return total\n\n    def solve(i, j):\n        c[i][j] = 0\n        res = 0\n        n = 0\n        while 1:\n            update()\n            total = get(n)\n            if total == 0:\n                break\n            n += 1\n            res += total\n        return res\n\n    import copy\n    res = 0\n    for i in range(h):\n        for j in range(w):\n            c = copy.deepcopy(banmen) \n            res = max(res, solve(i, j))\n    print(res)\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\n\nH, W, K = map(int, input().split())\nX = [list(map(int, list(input()))) for _ in range(H)]\n\ndef gen_mask(X, idx=None):\n    mask = [[True] * W for _ in range(H)]\n    if idx is not None:\n        i, j = idx\n        mask[i][j] = False\n        return mask\n    \n    # Erase mask\n    for i in range(H):\n        for j in range(W):\n            tmp = [False] * W\n            for k in range(j, W):\n                if X[i][j] == X[i][k]:\n                    tmp[k] = True\n                else:\n                    break\n            if sum(tmp) >= K:\n                mask[i] = [not v for v in tmp]\n                break\n    return mask\n\ndef erase(X, mask):\n    new = [[0] * W for _ in range(H)]\n    res = 0\n    for j in range(W):\n        idx = H - 1\n        for i in reversed(range(H)):\n            if mask[i][j]:\n                new[idx][j] = X[i][j]\n                idx -= 1\n            else:\n                res += X[i][j]\n\n    return new, res\n\ndef compute(idx):\n    X_tmp = deepcopy(X)\n    mask = gen_mask(X_tmp, idx)\n    res = 0\n\n    for i in range(-1, 1000):\n        X_new, tmp = erase(X_tmp, mask)\n        if tmp == 0:\n            break\n\n        # Update\n        X_tmp = X_new\n        mask = gen_mask(X_tmp)\n        \n        if i >= 0:\n            res += 2 ** i * tmp\n\n    return res\n\nans = 0\nfor i in range(H):\n    for j in range(W):\n        res = compute((i, j))\n\n    # Max ans\n    ans = max(ans, res)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "# https://atcoder.jp/contests/s8pc-3/tasks/s8pc_3_b\n\nimport sys\ninput=sys.stdin.readline\nfrom collections import deque\nfrom copy import deepcopy\n\ndef main():\n    H,W,K=map(int,input().split())\n    mas=[[-1]*W for i in range(H)]\n    for i in range(H):\n        t=input()\n        for j in range(W):\n            mas[H-1-i][j]=int(t[j])\n    maso=deepcopy(mas)\n    maxans=0       \n    for h in range(H):\n        for w in range(W):\n            mas=deepcopy(maso)\n            mas[h][w]=-1\n            for hh in range(h,H-1):\n                t=mas[hh][w]\n                mas[hh][w]=mas[hh+1][w]\n                mas[hh+1][w]=t\n            \n            ans=0\n            nankaime=0\n            while(1):\n                kiesum=0\n                mast=deepcopy(mas)\n                for i in range(H):\n                    for j in range(W):\n                        cnt=1\n                        for k in range(j+1,W):\n                            if mas[i][j]!=-1 and mas[i][k]!=-1 and mas[i][j]==mas[i][k]:\n                                cnt+=1\n                            else:\n                                break\n                        if cnt>=K:\n                            for k in range(cnt):\n                                kiesum+=mas[i][j+k]\n                                mas[i][j+k]=-1\n                f=[deque() for i in range(W)]\n                for j in range(W):\n                    for i in range(H):\n                        if mas[i][j]!=-1:\n                            f[j].append(mas[i][j])\n                    for i in range(H-len(f[j])):\n                        f[j].append(-1)\n                for i in range(H):\n                    for j in range(W):\n                        mas[i][j]=f[j].popleft()\n                ans+=pow(2,nankaime)*kiesum\n                nankaime+=1\n                if mas==mast:\n                    break\n            maxans=max(maxans,ans)\n    print(maxans)\n                    \n                    \n                \n    \nif __name__==\"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nH, W, K = map(int, input().split())\nboard = [[0]*W for _ in range(H+1)]\nfor i in range(1,H+1):\n    board[i] = list(map(int, list(input())))\ndef drop(board_copy):\n    change = True\n    score = 0\n    p = 0\n    while change:\n        change = False\n        for i in range(2,H+1):\n            ser = 1\n            for j in range(W):\n                if j==W-1:\n                    if ser>=K:\n                        score += 2**p*board_copy[i][-1]*ser\n                        change = True\n                        for k in range(i,0,-1):\n                            board_copy[k][-ser:] = board_copy[k-1][-ser:]\n                    continue\n                if board_copy[i][j]==0:\n                    ser = 1\n                    continue\n                if board_copy[i][j]>0 and board_copy[i][j]==board_copy[i][j+1]:\n                    ser += 1\n                elif ser>=K:\n                    score += 2**p*board_copy[i][j]*ser\n                    change = True\n                    for k in range(i,0,-1):\n                        board_copy[k][j-ser+1:j+1] = board_copy[k-1][j-ser+1:j+1]\n                    ser = 1\n        p += 1\n    return score\nans = 0\nfor h in range(1,H+1):\n    for w in range(W):\n        board_copy = deepcopy(board)\n        for k in range(h,0,-1):\n            board_copy[k][w] = board[k-1][w]\n        ans = max(ans,drop(board_copy))\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import copy\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\ndef main():\n    ans = []\n    H,W,K = map(int, readline().split())\n    c_ = [list(map(int, list(readline().strip()))) for _ in range(H)]\n\n    for a in range(H):\n        for b in range(W):\n            c = copy.deepcopy(c_)\n            c[a][b] = 0\n\n            seq = [[1] for _ in range(H)]\n            ans_tmp = [0]\n            \n            score = 0\n            weight = 1\n            while True:\n                # 落とす\n                for i in reversed(range(H)):\n                    for j in range(W):\n                        if c[i][j] == 0:\n                            for h in reversed(range(i)):\n                                if c[h][j] != 0:\n                                    c[h][j], c[i][j] = c[i][j], c[h][j]\n                                    break\n\n                # 消す\n                for i, line in enumerate(c):\n                    for j in range(1,W):\n                        if line[j] == line[j-1]:\n                            seq[i][-1] += 1\n                        else:\n                            seq[i].append(1)\n                \n                    acc = -1\n                    for s in seq[i]:\n                        acc += s\n                        if s >= K:\n                            score += s * line[acc] * weight\n                            for j in range(acc - s + 1, acc + 1):\n                                line[j] = 0\n                    seq[i] = [1]\n                \n                weight *= 2\n\n                ans_tmp.append(score)\n                if ans_tmp[-1] == ans_tmp[-2]:\n                    ans.append(ans_tmp[-1])\n                    break\n\n    print(max(ans))\n\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\n\nh,w,k=map(int,input().split())\nb=[list(i[::-1]) for i in zip(*[input() for _ in range(h)])]\nb=[[int(s) for s in strs] for strs in b]\nfans=0\nfor x in range(w):\n  for y in range(h):\n    a=deepcopy(b)\n    a[x].pop(y)\n    a[x].append(0)\n    q=[]\n    ans=0\n    d=-1\n    m=0\n    while True:\n      if d==ans:break\n      d=ans\n      for i in range(h):\n        cnt=0\n        for j in range(w-1):\n          if a[j][i]==a[j+1][i]:cnt+=1\n          else:\n            if cnt>=k-1:\n              q.append((j-cnt,i,cnt+1))\n            cnt=0\n        if cnt>=k-1:\n          q.append((w-cnt-1,i,cnt+1))      \n      while q:\n        j,i,cnt=q.pop()\n        for c in range(cnt):\n          ans+=2**m*a[j+c].pop(i)\n          a[j+c].append(0)\n      m+=1\n    fans=max(fans,ans) \nprint(fans)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**5)\nH, W, K = map(int, input().split())\nHW = [list(map(int, list(str(input().strip())))) for _ in range(H)]\n\ndef blocks(hw):\n    score = 0\n    ret = 1\n    delcnt = 0\n    while ret:\n        ret = check(delcnt, hw)\n        score += ret\n        delcnt += 1\n    return score\n\ndef check(delcnt, hw):\n    s = 0\n    blank = -1\n    for h in range(H):\n        cnt = 1\n        old = hw[h][:]\n        for w in range(1, W):\n            if hw[h][w-1]==hw[h][w]:\n                cnt+=1\n                flg = True\n            else:\n                if cnt>=K:\n                    s += cnt*hw[h][w-1]\n                    for k in range(1, cnt+1):\n                        hw[h][w-k] = blank\n                        blank -= 1\n                cnt = 1\n        if cnt>=K:\n            s += cnt*hw[h][W-1]\n            for k in range(1, cnt+1):\n                hw[h][W-k] = blank\n                blank -= 1\n    for w in range(W):\n        cnt = 1\n        for h in range(H-1, -1, -1):\n            item = hw[h][w]\n            hw[h][w] = blank\n            blank -= 1\n            if item>0:\n                hw[H-cnt][w] = item\n                cnt += 1\n    return 2**delcnt*s\n\nimport copy\nans = []\nif K>=4:\n    print(0)\nelse:\n    for h in range(1, H):\n        for w in range(W):\n            hw = copy.deepcopy(HW)\n            for i in range(H-h, 0, -1):\n                hw[i][w] = hw[i-1][w]\n            hw[0][w] = 0\n            ans.append(blocks(hw))\nprint(max(ans))"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nH, W, K = map(int, input().split())\nboard = [[0]*W for _ in range(H+1)]\nfor i in range(1,H+1):\n    board[i] = list(map(int, list(input())))\ndef drop(board):\n    change = True\n    score = 0\n    p = 0\n    while change==True:\n        change = False\n        for i in range(1,H+1):\n            ser = 1\n            for j in range(W-1):\n                if board[i][j]==0:\n                    ser = 1\n                    continue\n                if board[i][j]>0 and board[i][j]==board[i][j+1]:\n                    ser += 1\n                elif ser>=K:\n                    score += 2**p*sum(board[i][j-ser+1:j+1])\n                    change = True\n                    for k in range(i,0,-1):\n                        board[k][j-ser+1:j+1] = board[k-1][j-ser+1:j+1]\n                    ser = 1\n            if ser>=K:\n                score += 2**p*sum(board[i][-ser:])\n                change = True\n                for k in range(i,0,-1):\n                    board[k][-ser:] = board[k-1][-ser:]\n        p += 1\n    return score\nans = 0\nfor h in range(1,H+1):\n    for w in range(W):\n        board_copy = deepcopy(board)\n        for k in range(h,0,-1):\n            board_copy[k][w] = board[k-1][w]\n        ans = max(ans,drop(board_copy))\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "# https://atcoder.jp/contests/s8pc-3/tasks/s8pc_3_b\n\nimport sys\ninput=sys.stdin.readline\nfrom collections import deque\nfrom copy import deepcopy\n\ndef main():\n    H,W,K=map(int,input().split())\n    mas=[[-1]*W for i in range(H)]\n    for i in range(H):\n        t=input()\n        for j in range(W):\n            mas[H-1-i][j]=int(t[j])\n    maso=deepcopy(mas)\n    maxans=0       \n    for h in range(H):\n        for w in range(W):\n            mas=deepcopy(maso)\n            mas[h][w]=-1\n            for hh in range(h,H-1):\n                t=mas[hh][w]\n                mas[hh][w]=mas[hh+1][w]\n                mas[hh+1][w]=t\n            \n            ans=0\n            nankaime=0\n            while(1):\n                kiesum=0\n                mast=deepcopy(mas)\n                for i in range(H):\n                    for j in range(W):\n                        cnt=1\n                        for k in range(j+1,W):\n                            if mas[i][j]!=-1 and mas[i][k]!=-1 and mas[i][j]==mas[i][k]:\n                                cnt+=1\n                            else:\n                                break\n                        if cnt>=K:\n                            for k in range(cnt):\n                                kiesum+=mas[i][j+k]\n                                mas[i][j+k]=-1\n                            break\n                f=[deque() for i in range(W)]\n                for j in range(W):\n                    for i in range(H):\n                        if mas[i][j]!=-1:\n                            f[j].append(mas[i][j])\n                    for i in range(H-len(f[j])):\n                        f[j].append(-1)\n                for i in range(H):\n                    for j in range(W):\n                        mas[i][j]=f[j].popleft()\n                ans+=pow(2,nankaime)*kiesum\n                nankaime+=1\n                if mas==mast:\n                    break\n            maxans=max(maxans,ans)\n    print(maxans)\n                    \n                    \n                \n    \nif __name__==\"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "H, W, K = map(int, input().split())\nHW = [list(map(int, list(input()))) for _ in range(H)]\n\ndef blocks(hw):\n    score = 0\n    blank = -1\n    flg = True\n    delcnt = 0\n    while flg:\n        flg = False\n        for h in range(H):\n            cnt = 1\n            old = hw[h][:]\n            for w in range(1, W):\n                if hw[h][w-1]==hw[h][w]:\n                    cnt+=1\n                    flg = True\n                else:\n                    if cnt>=K:\n                        score += 2**delcnt*cnt*hw[h][w-1]\n                        for k in range(1, cnt+1):\n                            hw[h][w-k] = blank\n                            blank -= 1\n                    cnt = 1\n            if cnt>=K:\n                score += 2**delcnt*cnt*hw[h][W-1]\n                for k in range(1, cnt+1):\n                    hw[h][W-k] = blank\n                    blank -= 1\n        for w in range(W):\n            cnt = 1\n            for h in range(H-1, -1, -1):\n                item = hw[h][w]\n                if item>0:\n                    hw[H-cnt][w] = item\n                    cnt += 1\n        delcnt += 1\n    return score\nimport copy\nans = []\nif K>=4:\n    print(0)\nelse:\n    for h in range(1, H):\n        for w in range(W):\n            hw = copy.deepcopy(HW)\n            for i in range(H-h, 0, -1):\n                hw[i][w] = hw[i-1][w]\n            hw[0][w] = 0\n            ans.append(blocks(hw))\nprint(max(ans))"
  },
  {
    "language": "Python",
    "code": "import copy\nH,W,K = map(int,input().split())\nA = [list(map(int,list(input()))) for _ in range(H)]\nscrmax = 0\nfor i in range(1,H):\n    for j in range(W):\n        cnt = 0\n        scr = 0\n        B = copy.deepcopy(A)\n        B[i][j] = 0\n        for k in range(i,0,-1):\n            B[k][j] = B[k-1][j]\n            B[k-1][j] = 0\n        while True:\n            flg = 0\n            for i1 in range(H):\n                cur = 0\n                m = 0\n                b = -1\n                ind = -1\n                for j1 in range(1,W):\n                    if B[i1][j1]>0 and B[i1][j1]==B[i1][j1-1]:continue\n                    else:\n                        if j1-cur>m:\n                            m = j1-cur\n                            b = B[i1][cur]\n                            ind = cur\n                        cur = j1\n                if W-cur>m:\n                    m = W-cur\n                    b = B[i1][cur]\n                    ind = cur\n                if m>=K:\n                    flg = 1\n                    scr += 2**cnt*b*m\n                    B[i1][ind:ind+m] = [0 for _ in range(m)]\n                    for j2 in range(ind,ind+m):\n                        for k in range(i1,0,-1):\n                            B[k][j2] = B[k-1][j2]\n                            B[k-1][j2] = 0\n            if flg==0:break\n            cnt += 1\n        scrmax = max(scrmax,scr)     \nprint(scrmax)"
  },
  {
    "language": "Python",
    "code": "import copy\n\nh, w, k = map(int, input().split())\nc = [list(map(int, list(input()))) for _ in range(h)]\nc.insert(0, [0] * w)\nmaxscore = 0\nfor i in range(1, h + 1):\n    for j in range(w):\n        if i == 1:\n            maxscore = max(maxscore, c[i][j])\n        else:\n            s = copy.deepcopy(c)\n            s[i][j] = 0\n            score = 0\n            p = 1\n            while True:\n                for m in range(w):\n                    z = 0\n                    x = []\n                    for l in range(i + 1):\n                        if s[l][m] != 0:\n                            x.append(s[l][m])\n                    x = [0] * (i + 1 - len(x)) + x\n                    for l in range(i + 1):\n                        s[l][m] = x[l]\n                b = 0\n                for l in range(1, i + 1):\n                    n = s[l][0]\n                    cnt = 0\n                    for m in range(w):\n                        if s[l][m] == n and s[l][m] != 0:\n                            cnt += 1\n                        else:\n                            if cnt >= k:\n                                b = 1\n                                for ii in range(m - cnt, m):\n                                    s[l][ii] = 0\n                                    score += p * n\n                            n = s[l][m]\n                            if s[l][m] != 0:\n                                cnt = 1\n                            else:\n                                cnt = 0\n                    if cnt >= k:\n                        b = 1\n                        for ii in range(w - cnt, w):\n                            s[l][ii] = 0\n                            score += p * n\n                if b == 0:\n                    break\n                p *= 2\n            maxscore = max(maxscore, score)\n\nprint(maxscore)"
  },
  {
    "language": "Python",
    "code": "h, w, k  = map(int, input().split())\n\npuyo_orig = [list(map(int, list(input()))) for _ in range(h)]\n\nimport copy\nmx = 0\nfor i1 in range(h):\n    for i2 in range(w):\n        puyo = copy.deepcopy(puyo_orig)\n        puyo[i1][i2] = -1\n        p = 0\n        fin = 0\n        turn = 0\n        while fin==0:\n            #[print(*puyo[i]) for i in range(h)]\n            fin = 1\n            \n            for i in range(w):\n                d_fin = 0\n                while d_fin==0:\n                    d_fin = 1\n                    for j in range(h-1, 0, -1):\n                        if puyo[j][i]==-1 and puyo[j-1][i]>0:\n                            puyo[j][i] = puyo[j-1][i]\n                            puyo[j-1][i] = -1\n                            d_fin = 0\n                            \n            for i in range(h):\n                cnt = 1\n                for j in range(1, w):\n                    if puyo[i][j-1] == puyo[i][j] and puyo[i][j]>0:\n                        cnt += 1\n                    else:\n                        if cnt>=k:\n                            p += cnt * puyo[i][j-1] * 2**turn\n                            for k2 in range(cnt):\n                                puyo[i][j-k2-1] = -1\n                                fin = 0\n                        cnt = 1\n                    if j==w-1:\n                        if cnt>=k:\n                            p += cnt * puyo[i][j-1] * 2**turn\n                            for k2 in range(cnt):\n                                puyo[i][j-k2] = -1\n                                fin = 0\n            turn += 1\n        if p>mx:\n            mx=p\n            \nprint(mx)"
  },
  {
    "language": "Python",
    "code": "def main():\n    h, w, k = map(int, raw_input().split())\n    c = [map(int, raw_input().strip()) for _ in xrange(h)]\n    def go(a):\n        for j in xrange(w):\n            st = [a[i][j] for i in xrange(h) if a[i][j]]\n            i = -1\n            for x in reversed(st):\n                a[i][j] = x\n                i -= 1\n        b = [a[i][:] for i in xrange(h)]\n        res = 0\n        for i in xrange(h):\n            j = 0\n            while j < w:\n                t = j\n                while t < w and a[i][j] == a[i][t]:\n                    t += 1\n                if t - j >= k:\n                    for j in xrange(j, t):\n                        res += a[i][j]\n                        b[i][j] = 0\n                j = t\n        if not res:\n            return 0\n        return go(b) * 2 + res\n    ans = 0\n    for i in xrange(h):\n        for j in xrange(w):\n            t = [c[ii][:] for ii in xrange(h)]\n            t[i][j] = 0\n            r = go(t)\n            if ans < r:\n                ans = r\n    print ans\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys,queue,math,copy\nLI = lambda : [int(x) for x in input().split()]\n\nH,W,K = LI()\nC = [[int(x) for x in input()] + [0] for _ in range(H)]\n\nmax_p = 0\nfor i in range(H):\n    for j in range(W):\n        c = copy.deepcopy(C)\n        c[i][j] = 0\n        p = 0\n        for x in range(i,0,-1):\n            c[x][j] = c[x-1][j]\n        c[0][j] = 0\n\n\n        update = True\n        cnt = 0\n        while update:\n            update = False\n\n            for i in range(H):\n                n = c[i][0]\n                nc = n > 0\n                for j in range(1, W + 1):\n                    if c[i][j] == n and n > 0:\n                        nc += 1\n                    else:\n                        if nc >= K:\n                            for k in range(nc):\n                                c[i][j-k-1] = 0\n                            p += nc * n * (2 **cnt)\n                            update = True\n                        n = c[i][j]\n                        nc = n > 0\n\n            for i in range(H-1, 0, -1):\n                for j in range(W):\n                    if c[i][j] > 0: continue\n                    x = i\n                    while x > 0:\n                        x -= 1\n                        if c[x][j] > 0:\n                            c[i][j] = c[x][j]\n                            c[x][j] = 0\n                            break\n            cnt += 1\n\n        max_p = max(max_p,p)\nprint (max_p)\n"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy as cp\n\nH,W,K = map(int,input().split())\nsrc = [input() for i in range(H)]\n\npanels = []\nfor cols in zip(*src):\n    panels.append(list(reversed(cols)))\n\nans = 0\nfor r0 in range(H):\n    for c0 in range(W):\n        ps = cp(panels)\n        del ps[c0][r0]\n        tmp = 0\n        bonus = 1\n        chaining = True\n        while chaining:\n            chaining = False\n            for r in reversed(range(H)):\n                seq = 0\n                prev = None\n                for c in range(W):\n                    if r >= len(ps[c]) or (prev and prev != ps[c][r]) or c == 0:\n                        if seq > 1:\n                            tmp += bonus * seq * int(prev)\n                            chaining = True\n                            for i in range(seq):\n                                del ps[c-i-1][r]\n                        if r >= len(ps[c]):\n                            seq,prev = 0,None\n                        else:\n                            seq,prev = 1,ps[c][r]\n                    elif prev:\n                        seq += 1\n                    else:\n                        prev = ps[c][r]\n                if seq > 1:\n                    tmp += bonus * seq * int(prev)\n                    chaining = True\n                    for i in range(seq):\n                        del ps[W-i-1][r]\n            bonus *= 2\n        ans = max(ans, tmp)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nH, W, K = map(int, input().split())\nboard = [[0]*W for _ in range(H+1)]\nfor i in range(1,H+1):\n    board[i] = list(map(int, list(input())))\ndef drop(board_copy):\n    change = True\n    score = 0\n    p = 0\n    while change==True:\n        change = False\n        for i in range(1,H+1):\n            ser = 1\n            for j in range(W-1):\n                if board_copy[i][j]==0:\n                    ser = 1\n                    continue\n                if board_copy[i][j]>0 and board_copy[i][j]==board_copy[i][j+1]:\n                    ser += 1\n                elif ser>=K:\n                    score += 2**p*board_copy[i][j]*ser\n                    change = True\n                    for k in range(i,0,-1):\n                        board_copy[k][j-ser+1:j+1] = board_copy[k-1][j-ser+1:j+1]\n                    ser = 1\n            if ser>=K:\n                score += 2**p*board_copy[i][-1]*ser\n                change = True\n                for k in range(i,0,-1):\n                    board_copy[k][-ser:] = board_copy[k-1][-ser:]\n        p += 1\n    return score\nans = 0\nfor h in range(1,H+1):\n    for w in range(W):\n        board_copy = deepcopy(board)\n        for k in range(h,0,-1):\n            board_copy[k][w] = board[k-1][w]\n        ans = max(ans,drop(board_copy))\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from itertools import groupby\nimport copy\ndef calc():\n  s = 0\n  for i in range(h):\n    gr = groupby(g[i])\n    j = 0\n    for key,it in gr:\n      if key==-1: continue\n      l = len(list(it))\n      if l >= K:\n        for k in range(l):\n          g[i][j+k] = -1\n        # print(\"s\", key, l, key*l)\n        s += key*l\n      j += l\n      # print(\"j\", j)\n  return s\n\ndef flatten():\n  for j in range(w):\n    lst = []\n    for i in range(h-1, -1, -1):\n      if g[i][j] > 0:\n        lst.append(g[i][j])\n\n    lst += [-1] * (h - len(lst))\n\n    for i in range(h-1, -1, -1):\n      g[i][j] = lst[h-i-1]\n\nh,w,K = map(int,input().split())\nmat = []\nfor _ in range(h):\n  mat.append([int(e) for e in list(input())])\n\nres = 0\nfor i in range(h):\n  for j in range(w):\n    score = 0\n    g = copy.deepcopy(mat)\n    g[i][j] = -1\n    time = 0\n    flatten()\n    while True:\n      s = calc()\n      if s > 0:\n        score += pow(2, time) * s\n      else:\n        break\n      flatten()\n      time += 1\n    res = max(res, score)\n\nprint(res)\n\n"
  },
  {
    "language": "Python",
    "code": "from itertools import groupby\ndef calc():\n  s = 0\n  for i in range(h):\n    gr = groupby(g[i])\n    j = 0\n    for key,it in gr:\n      if key==-1: continue\n      l = len(list(it))\n      if l >= K:\n        g[i][j:j+l] = [-1]*l\n        # for k in range(l):\n        #   g[i][j+k] = -1\n        # # print(\"s\", key, l, key*l)\n        s += key*l\n      j += l\n      # print(\"j\", j)\n\n  return s\n\ndef flatten():\n  for j in range(w):\n    lst = []\n    for i in range(h-1, -1, -1):\n      if g[i][j] > 0:\n        lst.append(g[i][j])\n\n    lst += [-1] * (h - len(lst))\n\n    for i in range(h-1, -1, -1):\n      g[i][j] = lst[h-i-1]\n\nh,w,K = map(int,input().split())\nmat = [ [int(e) for e in list(input())] for _ in range(h) ]\n\nres = 0\nfor i in range(h):\n  for j in range(w):\n    score = 0\n    g = [ [ mat[n][m] for m in range(w) ] for n in range(h) ]\n    g[i][j] = -1\n    time = 0\n    flatten()\n    while True:\n      s = calc()\n      if s > 0:\n        score += 2**time * s\n      else:\n        break\n      flatten()\n      time += 1\n    res = max(res, score)\n\nprint(res)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport time\nstart = time.time()\n\nimport numpy as np\n\nH,W,K = map(int,readline().split())\nS = np.array([list(line.rstrip()) for line in readlines()]).astype(np.int8) - ord('0')\n\n# 下から上の順に\nS = S[::-1].T\n\ndef drop(S):\n    for i in range(W):\n        col = S[i]\n        S[i] = drop_col(col)\n\ndef drop_col(col):\n    x = np.zeros(H,np.int8)\n    nonzero = col[col != 0]\n    x[:len(nonzero)] = nonzero\n    return x\n\ndef cnt_connection(S):\n    # 横につながっている個数\n    x = np.ones_like(S)\n    equal = (S[:-1] == S[1:])\n    for i in range(1,W):\n        x[i] = x[i-1] * equal[i-1] + 1\n    for i in range(W-2,-1,-1):\n        x[i][equal[i]] = x[i+1][equal[i]]\n    return x\n\ndef simulate(S,turn):\n    # 落とす -> 消去、で1セット\n    drop(S)\n    conn = cnt_connection(S)\n    remove = (conn >= K)\n    before = S.sum()\n    S *= (~remove)\n    after = S.sum()\n    if before == after:\n        # 消えなかった\n        return 0\n    else:\n        x = simulate(S,turn+1)\n        return x + ((before - after) << turn)\n\ndef calc(j):\n    T = S.copy()\n    T[j,0] = 0\n    return simulate(T,0)\n\nanswer = 0\nfor i in range(H):\n    x = max(calc(j) for j in range(W))\n    if answer < x:\n        answer = x\n    H -= 1\n    S = S[:,1:]\n    if time.time() - start > 0.9:\n        break\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nh,w,n = (int(i) for i in input().split())\nc1,ans = [[] for i in range(w)],0\nfor i in range(h):\n\ts = input()\n\tfor j in range(w): c1[j].append(int(s[j]))\nif n<4:\n\tfor i in range(h//2,h):\n\t\tfor j in range(w):\n\t\t\tc,m,a = deepcopy(c1),0,0\n\t\t\tdel c[j][i]\n\t\t\tc[j] = [0]+c[j]\n\t\t\twhile 1:\n\t\t\t\td = []\n\t\t\t\tfor k in range(i-h,-h,-1):\n\t\t\t\t\tk2 = 0\n\t\t\t\t\twhile k2<w-n+1:\n\t\t\t\t\t\tif c[k2][k] and all(c[k2][k]==c[k2+k3][k] for k3 in range(1,n)):\n\t\t\t\t\t\t\tb = n\n\t\t\t\t\t\t\tfor k3 in range(k2+n,w):\n\t\t\t\t\t\t\t\tif c[k2][k]==c[k3][k]: b+=1\n\t\t\t\t\t\t\t\telse: break\n\t\t\t\t\t\t\td.append((h+k,k2,b))\n\t\t\t\t\t\t\tk2+=b\n\t\t\t\t\t\telse: k2+=1\n\t\t\t\tif d:\n\t\t\t\t\tfor k,k2,k3 in d:\n\t\t\t\t\t\ta+=(2**m)*c[k2][k]*k3\n\t\t\t\t\t\tfor k4 in range(k2,k2+k3): del c[k4][k]\n\t\t\t\t\tfor k,k2,k3 in d:\n\t\t\t\t\t\tfor k4 in range(k2,k2+k3): c[k4] = [0]+c[k4]\n\t\t\t\telse: break\n\t\t\t\tm+=1\n\t\t\tans = max(ans,a)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from collections import deque   \nimport sys\n\nicase=0\nif icase==0:\n    h,w,k=map(int,input().split())\n    aa=[[0]*w for i in range(h)]\n    for i in range(h):\n        ll=input()\n        for j in range(w):\n            aa[h-1-i][j]=int(ll[j])\nelif icase==1:\n    h,w,k=4,4,2    \n    aa=[[2, 3, 1, 2], [1, 4, 2, 4], [4, 1, 2, 1], [3, 4, 1, 3]]\nelif icase==2:\n    h,w,k=4,4,2    \n    aa=[[2, 1, 2, 1], [1, 2, 1, 2], [2, 1, 2, 1], [1, 2, 1, 2]]\nelif icase==3:\n    h,w,k=7,7,2    \n    aa=[[8, 9, 8, 9, 8, 9, 8], [9, 8, 9, 8, 9, 8, 9], [8, 9, 8, 9, 8, 9, 8], [9, 8, 9, 8, 9, 8, 9], [8, 9, 8, 9, 8, 9, 8], [9, 8, 9, 8, 9, 8, 9], [8, 9, 8, 9, 8, 9, 8]]\nelif icase==4:\n    h,w,k=17,17,2    \n    aa=[[8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6], [7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5], [6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4], [5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3], [4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2], [3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1], [2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8], [9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7], [8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6], [7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5], [6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4], [5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3], [4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2], [3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1], [2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8]]\n#    print(a)\nif k>=4:\n    print(0)\n    sys.exit()\n\npmax=0\nfor hi in range(h):\n    for wi in range(w): \n        a=[[0]*w for i in range(h)]\n        for i in range(h):\n            for j in range(w):\n                a[i][j]=aa[i][j]\n#    print(\"j:\",j,a)\n        for i in range(hi,h-1):\n            a[i][wi]=a[i+1][wi]\n        a[h-1][wi]=0\n#    print(\"1:\",a)\n        p=0\n        ip=-1\n        while True:\n            ip+=1\n            p1=0\n            yn=\"\"\n            for i in range(h):\n                q=deque()\n                for j2 in range(w-k+1):\n                    for j3 in range(j2+1,j2+k):\n                        if a[i][j2]==0 or a[i][j2]!=a[i][j3]:\n                            break\n                        q.append((j2,a[i][j2]))\n                        yn=\"yes\"\n#            print(\"i:\",i,q)\n                jm=-2\n                while len(q)>0:\n                    j2,aij=q.popleft()\n                    for j3 in range(j2,j2+k):\n                        a[i][j3]=0\n#                print(\"j2:\",j2,\"jm+1:\",jm+1)\n                    if j2!=jm+1:\n                        p1+=aij*k\n                    else:\n                        p1+=aij\n                    jm=j2\n#                print(\"p1:\",p1)\n\n#            print(\"1:\",a)\n#        print(\"2:\",a)\n            for jj in range(w):\n                for ii in range(h):\n                    if a[ii][jj]==0:\n                        for iii in range(ii+1,h):\n                            if a[iii][jj]!=0:\n                                a[ii][jj]=a[iii][jj]\n                                a[iii][jj]=0\n                                break\n#        print(yn,a)\n            p+=p1*(2**ip)\n            if yn!=\"yes\":\n#            print(p,p1,ip)\n                break\n#    print(\"---------------------\")\n        pmax=max(pmax,p)\n#        print(a)\nprint(pmax)\n    "
  },
  {
    "language": "Python",
    "code": "H, W, K = map(int, input().split())\nHW = [list(map(int, list(input()))) for _ in range(H)]\n\ndef blocks(hw):\n    score = 0\n    blank = -1\n    flg = True\n    delcnt = 0\n    while flg:\n        flg = False\n        for h in range(H):\n            cnt = 1\n            old = hw[h][:]\n            for w in range(1, W):\n                if hw[h][w-1]==hw[h][w]:\n                    cnt+=1\n                    flg = True\n                else:\n                    if cnt>=K:\n                        score += 2**delcnt*cnt*hw[h][w-1]\n                        for k in range(1, cnt+1):\n                            hw[h][w-k] = blank\n                            blank -= 1\n                    cnt = 1\n            if cnt>=K:\n                score += 2**delcnt*cnt*hw[h][W-1]\n                for k in range(1, cnt+1):\n                    hw[h][W-k] = blank\n                    blank -= 1\n        for w in range(W):\n            cnt = 1\n            for h in range(H-1, -1, -1):\n                item = hw[h][w]\n                hw[h][w] = blank\n                blank -= 1\n                if item>0:\n                    hw[H-cnt][w] = item\n                    cnt += 1\n        delcnt += 1\n    return score\nimport copy\nans = []\nif K>=4:\n    print(0)\nelse:\n    for h in range(1, H):\n        for w in range(W):\n            hw = copy.deepcopy(HW)\n            for i in range(H-h, 0, -1):\n                hw[i][w] = hw[i-1][w]\n            hw[0][w] = 0\n            ans.append(blocks(hw))\nprint(max(ans))"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nH, W, K = map(int, input().split())\nboard = [[0]*(W+1) for _ in range(H+1)]\nfor i in range(1,H+1):\n    board[i] = list(map(int, list(input())))+[0]\ndef drop(board_copy):\n    change = True\n    score = 0\n    p = 0\n    while change:\n        change = False\n        for i in range(2,H+1):\n            ser = 1\n            for j in range(W):\n                if board_copy[i][j]>0 and board_copy[i][j]==board_copy[i][j+1]:\n                    ser += 1\n                else:\n                    if ser>=K:\n                        score += 2**p*board_copy[i][j]*ser\n                        change = True\n                        for k in range(i,0,-1):\n                            board_copy[k][j-ser+1:j+1] = board_copy[k-1][j-ser+1:j+1]\n                    ser = 1\n        p += 1\n    return score\nans = 0\nfor h in range(1,H+1):\n    for w in range(W):\n        board_copy = deepcopy(board)\n        for k in range(h,0,-1):\n            board_copy[k][w] = board[k-1][w]\n        ans = max(ans,drop(board_copy))\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\n\nH, W, K = map(int, input().split())\npuzzle = [[-1] * H for _ in range(W)]\n\nfor i in range(H - 1, -1, -1):\n    for j, stone in enumerate(list(map(int, input()))):\n        puzzle[j][i] = stone\n\n\ndef solve(h, w):\n    pz = deepcopy(puzzle)\n    pz[w].pop(h)\n    pz[w].append(0)\n    ans = 0\n    cnt = 0\n    tmp_score = -1\n    while tmp_score != 0:\n        tmp_score = 0\n        tmp_sum = 0\n\n        # puzzle連鎖確認\n        for i in range(H - 1, -1, -1):\n            for left in range(W):\n                for right in range(W - 1, left, -1):\n                    if right - left >= K - 1:\n                        r_flg = True\n                        for j in range(left, right):\n                            if pz[j][i] == pz[j + 1][i]:\n                                continue\n                            else:\n                                r_flg = False\n                                break\n                        if r_flg:\n                            tmp_sum += pz[j][i] * (right - left + 1)\n                            for j in range(left, right+1):\n                                pz[j].pop(i)\n                                pz[j].append(0)\n        tmp_score += (2 ** cnt) * tmp_sum\n        cnt += 1\n        ans += tmp_score\n    return ans\n\n\nf_ans = 0\nfor i in range(H):\n    for j in range(W):\n        f_ans = max(f_ans, solve(i, j))\n\nprint(f_ans)\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    h, w, k = map(int, raw_input().split())\n    c = [list(raw_input().strip()) for _ in xrange(h)]\n    def go(a):\n        for j in xrange(w):\n            st = [a[i][j] for i in xrange(h) if a[i][j]]\n            i = -1\n            for x in reversed(st):\n                a[i][j] = x\n                i -= 1\n        b = [a[i][:] for i in xrange(h)]\n        res = 0\n        for i in xrange(h):\n            for j in xrange(w - k + 1):\n                if all(a[i][j+jj] == a[i][j] for jj in xrange(k)):\n                    for jj in xrange(k):\n                        b[i][j+jj] = 0\n        for i in xrange(h):\n            for j in xrange(w):\n                if a[i][j] != b[i][j]:\n                    res += int(a[i][j])\n        if not res:\n            return 0\n        return go(b) * 2 + res\n    ans = 0\n    for i in xrange(h):\n        for j in xrange(w):\n            t = [c[ii][:] for ii in xrange(h)]\n            t[i][j] = 0\n            r = go(t)\n            if ans < r:\n                ans = r\n    print ans\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom copy import deepcopy\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\n\n\ndef drop(H, W, G):\n    for i in range(1, H):\n        for j in range(W):\n            if G[i][j] == 0 and G[i - 1][j] != 0:\n                k = i\n                for k in range(i, 0, -1):\n                    if G[k][j] != 0:\n                        break\n                    G[k][j], G[k - 1][j] = G[k - 1][j], 0\n\n\ndef main():\n    H, W, K = map(int, readline().split())\n    G_init = [list(map(int, row.strip())) for row in readlines()]\n\n    ans = 0\n    for i in range(H):\n        for j in range(W):\n            G = deepcopy(G_init)\n            G[i][j] = 0\n            drop(H, W, G)\n\n            current_ans = 0\n            scale = 1\n            while True:\n                score = 0\n                for row in G:\n                    cnt = 1\n                    for k in range(1, W):\n                        if row[k] == row[k - 1]:\n                            cnt += 1\n                        else:\n                            if cnt >= K and row[k - 1] != 0:\n                                score += row[k - 1] * cnt\n                                row[k - cnt : k] = [0] * cnt\n                            cnt = 1\n                    if cnt >= K and row[W - 1] != 0:\n                        score += row[W - 1] * cnt\n                        row[W - cnt : W] = [0] * cnt\n\n                if score == 0:\n                    break\n\n                current_ans += score * scale\n                scale *= 2\n                drop(H, W, G)\n\n            if current_ans > ans:\n                ans = current_ans\n\n    print(ans)\n    return\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    h, w, k = map(int, raw_input().split())\n    c = [map(int, raw_input().strip()) for _ in xrange(h)]\n    def go(a):\n        for j in xrange(w):\n            st = [a[i][j] for i in xrange(h) if a[i][j]]\n            for i in xrange(h):\n                a[i][j] = 0\n            i = -1\n            for x in reversed(st):\n                a[i][j] = x\n                i -= 1\n        b = [a[i][:] for i in xrange(h)]\n        res = 0\n        for i in xrange(h):\n            j = 0\n            while j < w:\n                t = j\n                while t < w and a[i][j] == a[i][t]:\n                    t += 1\n                if t - j >= k:\n                    for j in xrange(j, t):\n                        res += a[i][j]\n                        b[i][j] = 0\n                j = t\n        if not res:\n            return 0\n        return go(b) * 2 + res\n    ans = 0\n    for i in xrange(h):\n        for j in xrange(w):\n            t = [c[ii][:] for ii in xrange(h)]\n            t[i][j] = 0\n            r = go(t)\n            if ans < r:\n                ans = r\n    print ans\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nimport sys\ndef main():\n  input=sys.stdin.readline\n  h,w,k=map(int,input().split())\n  grid=[list(input()) for _ in range(h)]\n  def score(t):\n    total=0\n    for i in range(1,h):\n      for j in range(w-1):\n        cnt=1\n        ten=int(gc[i][j])\n        while gc[i][j+1]==gc[i][j]:\n          cnt+=1\n          j+=1\n          if j==w-1:\n            break\n        if cnt>=k:\n          total+=2**t*(ten*cnt)\n          gc[i][j-cnt+1:j+1]=['0']*cnt\n    return total\n  def upd():\n    while 1:\n      ok=True\n      for i in range(1,h):\n        for j in range(w):\n          if gc[i][j]=='0' and gc[i-1][j]!='0':\n            x=gc[i-1][j]\n            gc[i-1][j]='0'\n            gc[i][j]=x\n            ok=False\n      if ok:\n        return\n  ans=0\n  for i in range(1,h):\n    for j in range(w):\n      gc=deepcopy(grid)\n      gc[i][j]='0'\n      t=0\n      res=0\n      while 1:\n        upd()\n        total=score(t)\n        if total==0:\n          break\n        t+=1\n        res+=total\n      ans=max(ans,res)\n  return print(ans)\nif __name__=='__main__':\n  main()"
  },
  {
    "language": "Python",
    "code": "h, w, k  = map(int, input().split())\n\npuyo_orig = [[0]*w for _ in range(h+1)]\nfor i in range(1,h+1):\n    puyo_orig[i] = list(map(int, list(input())))\n\nimport copy\nmx = 0\nfor i1 in range(2,h+1):\n    for i2 in range(w):\n        puyo = copy.deepcopy(puyo_orig)\n        for l in range(i1,0,-1):\n            puyo[l][i2] = puyo[l-1][i2]\n        p = 0\n        fin = 0\n        turn = 0\n        while fin==0:\n            fin = 1\n            for i in range(2,h+1):\n                cnt = 1\n                for j in range(w-1):\n                    if puyo[i][j+1] == puyo[i][j] and puyo[i][j]>0:\n                        cnt += 1\n                    else:\n                        if cnt>=k:\n                            p += cnt * puyo[i][j] * 2**turn\n                            for l in range(i,0,-1):\n                                puyo[l][j-cnt+1:j+1] = puyo[l-1][j-cnt+1:j+1]\n                            fin = 0\n                        cnt = 1\n                    if j==w-2:\n                        if cnt>=k:\n                            p += cnt * puyo[i][j] * 2**turn\n                            for l in range(i,0,-1):\n                                puyo[l][j-cnt+2:j+2] = puyo[l-1][j-cnt+2:j+2]\n                            fin = 0\n            turn += 1\n        if p>mx:\n            mx=p\n            \nprint(mx)"
  },
  {
    "language": "Python",
    "code": "import copy\nH,W,K = map(int,input().split())\nA = [list(map(int,list(input()))) for _ in range(H)]\nscrmax = 0\nfor i in range(1,H):\n    for j in range(W):\n        cnt = 0\n        scr = 0\n        B = copy.deepcopy(A)\n        B[i][j] = 0\n        for k in range(i,0,-1):\n            B[k][j] = B[k-1][j]\n            B[k-1][j] = 0\n        while True:\n            flg = 0\n            for i1 in range(H):\n                cur = 0\n                m = 0\n                b = -1\n                ind = -1\n                for j1 in range(1,W):\n                    if B[i1][j1]>0 and B[i1][j1]==B[i1][j1-1]:continue\n                    else:\n                        if B[i1][cur]>0 and j1-cur>m:\n                            m = j1-cur\n                            b = B[i1][cur]\n                            ind = cur\n                        cur = j1\n                if W-cur>m:\n                    m = W-cur\n                    b = B[i1][cur]\n                    ind = cur\n                if m>=K:\n                    flg = 1\n                    scr += 2**cnt*b*m\n                    B[i1][ind:ind+m] = [0 for _ in range(m)]\n                    for j2 in range(ind,ind+m):\n                        for k in range(i1,0,-1):\n                            B[k][j2] = B[k-1][j2]\n                            B[k-1][j2] = 0\n            if flg==0:break\n            cnt += 1\n        scrmax = max(scrmax,scr)     \nprint(scrmax)"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nH, W, K = map(int, input().split())\nboard = [[0]*W for _ in range(H+1)]\nfor i in range(1,H+1):\n    board[i] = list(map(int, list(input())))\ndef drop(board):\n    change = True\n    score = 0\n    p = 0\n    while change==True:\n        change = False\n        for i in range(1,H+1):\n            ser = 1\n            for j in range(W-1):\n                if board[i][j]==0:\n                    ser = 1\n                    continue\n                if board[i][j]>0 and board[i][j]==board[i][j+1]:\n                    ser += 1\n                elif ser>=K:\n                    score += 2**p*board[i][j]*ser\n                    change = True\n                    for k in range(i,0,-1):\n                        board[k][j-ser+1:j+1] = board[k-1][j-ser+1:j+1]\n                    ser = 1\n            if ser>=K:\n                score += 2**p*board[i][-1]*ser\n                change = True\n                for k in range(i,0,-1):\n                    board[k][-ser:] = board[k-1][-ser:]\n        p += 1\n    return score\nans = 0\nfor h in range(1,H+1):\n    for w in range(W):\n        board_copy = deepcopy(board)\n        for k in range(h,0,-1):\n            board_copy[k][w] = board[k-1][w]\n        ans = max(ans,drop(board_copy))\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\n\n\ndef puzzle(x,y,A):\n    ans,point=0,0\n    A[x][y]=0\n    B=[[-1 for _ in range(w)] for _ in range(h)]\n    for i in range(w):\n        cnt=h-1\n        for j in range(h)[::-1]:\n            if A[j][i]!=0:\n                B[j][i]=cnt\n                cnt -=1\n    C=[[0 for _ in range(w)] for _ in range(h)]\n    for i in range(w):\n        for j in range(h):\n            if B[j][i]!=-1:\n                C[B[j][i]][i]=A[j][i]\n    A=C\n\n    while 1:\n        score=ans\n        for i in range(h):\n            cnt,num=0,A[i][0]\n            for j in range(w):\n                if A[i][j]==num:cnt +=1\n                else:\n                    if cnt>=k:\n                        ans +=num*cnt*2**point\n                        for l in range(cnt):\n                            A[i][j-l-1]=0\n                    num,cnt=A[i][j],1\n                if j==w-1 and cnt>=k:\n                    ans +=num*cnt*2**point\n                    for l in range(cnt):\n                        A[i][j-l]=0\n\n        B=[[-1 for _ in range(w)] for _ in range(h)]\n        for i in range(w):\n            cnt=h-1\n            for j in range(h)[::-1]:\n                if A[j][i]!=0:\n                    B[j][i]=cnt\n                    cnt -=1\n        C=[[0 for _ in range(w)] for _ in range(h)]\n        for i in range(w):\n            for j in range(h):\n                if B[j][i]!=-1:\n                    C[B[j][i]][i]=A[j][i]\n        A=C\n        if score==ans:break\n        point +=1\n    return ans\n\n\nh,w,k=map(int,input().split())\nD=[list(map(int,list(input()))) for _ in range(h)]\n\nans=0\nfor i in range(h):\n    for j in range(w):\n        A=deepcopy(D)\n        ans=max(ans,puzzle(i,j,A))\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nfrom collections import deque\nh,w,n = (int(i) for i in input().split())\nc1,ans = [deque([]) for i in range(w)],0\nfor i in range(h):\n\ts = input()\n\tfor j in range(w): c1[j].append(int(s[j]))\nif n<4:\n\tfor i in range(1,h):\n\t\tfor j in range(w):\n\t\t\tc,m,a = deepcopy(c1),0,0\n\t\t\tdel c[j][i]\n\t\t\tc[j].appendleft(0)\n\t\t\twhile 1:\n\t\t\t\td = []\n\t\t\t\tfor k in range(i-h,-h,-1):\n\t\t\t\t\tk2 = 0\n\t\t\t\t\twhile k2<w-n+1:\n\t\t\t\t\t\tif c[k2][k] and all(c[k2][k]==c[k2+k3][k] for k3 in range(1,n)):\n\t\t\t\t\t\t\tb = n\n\t\t\t\t\t\t\tfor k3 in range(k2+n,w):\n\t\t\t\t\t\t\t\tif c[k2][k]==c[k3][k]: b+=1\n\t\t\t\t\t\t\t\telse: break\n\t\t\t\t\t\t\td.append((h+k,k2,b))\n\t\t\t\t\t\t\tk2+=b\n\t\t\t\t\t\telse: k2+=1\n\t\t\t\tif d:\n\t\t\t\t\tfor k,k2,k3 in d:\n\t\t\t\t\t\ta+=(2**m)*c[k2][k]*k3\n\t\t\t\t\t\tfor k4 in range(k2,k2+k3): del c[k4][k]\n\t\t\t\t\tfor k,k2,k3 in d:\n\t\t\t\t\t\tfor k4 in range(k2,k2+k3): c[k4].appendleft(0)\n\t\t\t\telse: break\n\t\t\t\tm+=1\n\t\t\tans = max(ans,a)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy as cp\n\nH,W,K = map(int,input().split())\nsrc = [input() for i in range(H)]\n\npanels = []\nfor cols in zip(*src):\n    panels.append(list(reversed(cols)))\n\nans = 0\nfor r0 in range(H):\n    for c0 in range(W):\n        ps = cp(panels)\n        del ps[c0][r0]\n        tmp = 0\n        bonus = 1\n        chaining = True\n        while chaining:\n            chaining = False\n            for r in reversed(range(H)):\n                seq = 0\n                prev = None\n                for c in range(W):\n                    if r >= len(ps[c]) or (prev and prev != ps[c][r]) or c == 0:\n                        if seq >= K:\n                            tmp += bonus * seq * int(prev)\n                            chaining = True\n                            for i in range(seq):\n                                del ps[c-i-1][r]\n                        if r >= len(ps[c]):\n                            seq,prev = 0,None\n                        else:\n                            seq,prev = 1,ps[c][r]\n                    elif prev:\n                        seq += 1\n                    else:\n                        seq = 1\n                        prev = ps[c][r]\n                if seq >= K:\n                    tmp += bonus * seq * int(prev)\n                    chaining = True\n                    for i in range(seq):\n                        del ps[W-i-1][r]\n            bonus *= 2\n        ans = max(ans, tmp)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys,queue,math,copy\nLI = lambda : [int(x) for x in input().split()]\n\nH,W,K = LI()\nC = [[int(x) for x in input()] + [0] for _ in range(H)]\n\nmax_p = 0\nfor a in range(H):\n    for b in range(W):\n        c = copy.deepcopy(C)\n        c[a][b] = 0\n        p = 0\n        for x in range(a,0,-1):\n            c[x][b] = c[x-1][b]\n        c[0][b] = 0\n\n\n        update = True\n        cnt = 0\n        while update:\n            update = False\n\n            for i in range(H):\n                n = c[i][0]\n                nc = n > 0\n                for j in range(1, W + 1):\n                    if c[i][j] == n and n > 0:\n                        nc += 1\n                    else:\n                        if nc >= K:\n                            for k in range(nc):\n                                c[i][j-k-1] = 0\n                            p += nc * n * (2 **cnt)\n                            update = True\n                        n = c[i][j]\n                        nc = n > 0\n\n            for i in range(H-1, 0, -1):\n                for j in range(W):\n                    if c[i][j] > 0: continue\n                    x = i\n                    while x > 0:\n                        x -= 1\n                        if c[x][j] > 0:\n                            c[i][j] = c[x][j]\n                            c[x][j] = 0\n                            break\n            cnt += 1\n\n        max_p = max(max_p,p)\nprint (max_p)\n"
  },
  {
    "language": "Python",
    "code": "import copy\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\ndef main():\n    ans = []\n    H,W,K = map(int, readline().split())\n    c_ = [list(map(int, list(readline().strip()))) for _ in range(H)]\n\n    for a in range(H):\n        for b in range(W):\n            c = copy.deepcopy(c_)\n            c[a][b] = 0\n\n            seq = [[1] for _ in range(H)]\n            ans_tmp = [0]\n            \n            score = 0\n            weight = 1\n            while True:\n                # 落とす\n                for i in reversed(range(H)):\n                    for j in range(W):\n                        if c[i][j] == 0:\n                            for h in reversed(range(i)):\n                                if c[h][j] != 0:\n                                    c[h][j], c[i][j] = c[i][j], c[h][j]\n                                    break\n\n                # 消す\n                for i, line in enumerate(c):\n                    for j in range(1,W):\n                        if line[j] == line[j-1]:\n                            seq[i][-1] += 1\n                        else:\n                            seq[i].append(1)\n                \n                    acc = -1\n                    for s in seq[i]:\n                        acc += s\n                        if s >= K:\n                            score += s * line[acc] * weight\n                            for j in range(acc - s + 1, acc + 1):\n                                line[j] = 0\n                    seq[i] = [1]\n                \n                weight *= 2\n\n                ans_tmp.append(score)\n                if ans_tmp[-1] == ans_tmp[-2]:\n                    ans.append(ans_tmp[-1])\n                    break\n\n    print(max(ans))\n\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nH, W, K = map(int, input().split())\nboard = [[0]*(W+1) for _ in range(H+1)]\nfor i in range(1,H+1):\n    board[i] = list(map(int, list(input())))+[0]\ndef drop(board_copy):\n    change = True\n    score = 0\n    p = 0\n    while change:\n        change = False\n        for i in range(2,H+1):\n            ser = 1\n            for j in range(1,W+1):\n                if board_copy[i][j]>0 and board_copy[i][j]==board_copy[i][j-1]:\n                    ser += 1\n                else:\n                    if ser>=K:\n                        score += 2**p*board_copy[i][j-1]*ser\n                        change = True\n                        for k in range(i,0,-1):\n                            board_copy[k][j-ser:j] = board_copy[k-1][j-ser:j]\n                    ser = 1\n        p += 1\n    return score\nans = 0\nfor h in range(1,H+1):\n    for w in range(W):\n        board_copy = deepcopy(board)\n        for k in range(h,0,-1):\n            board_copy[k][w] = board[k-1][w]\n        ans = max(ans,drop(board_copy))\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "class Puzzle():\n  def __init__(self, mat, h,w,k):\n    self.mat = mat\n    self.h = h\n    self.w = w\n    self.k = k\n    self.score = 0\n\n  def calc(self, t):\n    tmp_score = 0\n\n    # print(\"before\")\n    # for m in self.mat:\n    #   print(m)\n\n    for i in range(self.h):\n      for j in range(self.w):\n        if self.mat[i][j] > 0:\n          for k in range(self.w, -1, -1):\n            # if k - j < self.k: break\n            if k-j >= self.k:\n              s = set(self.mat[i][j:k])\n              if len(s) == 1 and -1 not in s:\n                tmp_score += list(s)[0] * (k-j)\n                for l in range(j, k):\n                  self.mat[i][l] = -1\n            else:\n              break\n\n    # print(\"calced\")\n    # for m in self.mat:\n    #   print(m)\n\n    if tmp_score == 0:\n      return False\n    else:\n      self.score += pow(2, t) * tmp_score\n      if self.score == 642: import pdb; pdb.set_trace()\n      return True\n\n  def flatten(self):\n    pivot_mat = []\n    for i in range(self.w):\n      row = []\n      for j in range(self.h):\n        if self.mat[j][i] != -1:\n          row.append(self.mat[j][i])\n\n      short = self.h - len(row)\n      if short > 0:\n        row.reverse()\n        for k in range(short):\n          row.append(-1)\n        row.reverse()\n      \n      pivot_mat.append(row)\n\n    mat = [ [-1]*self.w for i in range(self.h) ]\n    for i in range(self.h):\n      for j in range(self.w):\n        mat[i][j] = pivot_mat[j][i]\n\n    self.mat = mat\n\nh,w,k = map(int,input().split())\nmat = []\nfor _ in range(h):\n  mat.append([int(e) for e in list(input())])\n\nres = 0\nfor i in range(h):\n  for j in range(w):\n    old = mat[i][j]\n    mat[i][j] = -1\n    puzzle = Puzzle(mat,h,w,k)\n    puzzle.flatten()\n    time = 0\n    while True:\n      if puzzle.calc(time):\n        puzzle.flatten()\n        time += 1\n      else:\n        break\n    res = max(res, puzzle.score)\n    mat[i][j] = old\n\nprint(res)\n\n"
  },
  {
    "language": "Python",
    "code": "H,W,K = list(map(int,input().split()))\nC = [list(input()) for _ in range(H)]\n\ndef F1(c):\n    for i in range(W):\n        for j in range(H-1,-1,-1):\n            if c[j][i] != 'X': continue\n            for k in range(j-1,-1,-1):\n                if c[k][i] != 'X':\n                    c[j][i], c[k][i] = c[k][i], c[j][i]\n                    break\n    return c\n\ndef F2(c):\n    delete_sum = 0\n    for i in range(H):\n        for j in range(W):\n            if c[i][j] == 'X': continue\n            tmp = c[i][j]\n            count = 1\n            for k in range(j+1,W):\n                if c[i][k] == tmp:\n                    count += 1\n                else:\n                    break\n            if count >= K:\n                for k in range(j,W):\n                    if c[i][k] == tmp:\n                        delete_sum += int(c[i][k])\n                        c[i][k] = 'X'\n                    else:\n                        break\n    return c, delete_sum\n\nMAX = 0\nfor i in range(H):\n    for j in range(W):\n        tmpC = []\n        for k in range(H):\n            tmpC.append(C[k][:])\n        tmpC[i][j] = 'X'\n        tmpC = F1(tmpC)\n        point = 0\n        for k in range(1000):\n            tmpC, delete_sum = F2(tmpC)\n            if delete_sum == 0:\n                break\n            tmpC = F1(tmpC)\n            point += 2**k*delete_sum\n        MAX = max(MAX,point)\nprint(MAX)"
  },
  {
    "language": "Python",
    "code": "\nclass Game:\n    def __init__(self, mp, h, w, k):\n        self.mp = mp\n        self.H = h\n        self.W = w\n\n        self.K = k\n        self.score = 0\n        self.erase_flag = False\n        self.cnt = 0\n        \n    def erase(self):\n        tot = 0\n        for y in range(self.H):\n            line = self.mp[y]\n            new_line, add_score = self.fix(line)\n            self.mp[y] = new_line\n            tot += add_score\n            if add_score != 0:\n                self.erase_flag = True\n        if self.erase_flag:\n            self.score += tot*pow(2, self.cnt)\n            self.cnt += 1\n    \n    def fix(self, line):\n        add_score = 0\n        new_line = line\n        for length in range(self.W, self.K-1, -1):\n            for left in range(self.W - length+1):\n                if all(map(lambda x:x==new_line[left], new_line[left:left+length])):\n                    add_score += new_line[left]*length\n                    new_line = new_line[:left] + [0]*length + new_line[left+length:]\n                    # 最後の要素まで見たか？\n                    # if self.W == left+length:\n                    #     return new_line, add_score\n        return new_line, add_score\n    \n    def fall(self):\n        for x in range(self.W):\n            col = [self.mp[y][x] for y in range(self.H) if self.mp[y][x] != 0]\n            # for y in range(self.H):\n            #     if self.mp[y][x] != 0:\n            #         col.append(self.mp[y][x])\n            col = [0]*(self.H - len(col)) + col\n            for y in range(self.H):\n                self.mp[y][x] = col[y]\n\n\n    def run(self):\n        while True:\n            self.erase_flag = False\n            self.erase()\n            if not self.erase_flag:\n                break\n            self.fall()\n\nimport sys\nsys.setrecursionlimit(10 ** 7)\nread = sys.stdin.buffer.read\ninp = sys.stdin.buffer.readline\ndef inpS(): return inp().rstrip().decode()\n\n\nimport copy\ndef resolve():\n    def init_fall(grid, cell):\n        col = [grid[y][cell] for y in range(H) if grid[y][cell] != 0]\n        # for y in range(H):\n        #     if grid[y][cell] != 0:\n        #         col.append(grid[y][cell])\n        col = [0] * (H - len(col)) + col\n        for y in range(H):\n            grid[y][cell] = col[y]\n        return grid\n\n    H, W, K = map(int, inp().split())\n    mp = [list(map(int, inpS())) for _ in range(H)]\n\n    ans = 0\n    for i in range(1,H):\n        for j in range(W):\n            mp_copy = copy.deepcopy(mp)\n            mp_copy[i][j] = 0\n            mp_copy = init_fall(mp_copy,j)\n            game = Game(mp_copy, H, W, K)\n            game.run()\n            ans = max(ans, game.score)\n    print(ans)\n\nif __name__ == \"__main__\":\n    resolve()"
  },
  {
    "language": "Python",
    "code": "import sys,queue,math,copy\nLI = lambda : [int(x) for x in input().split()]\n\nH,W,K = LI()\nC = [[int(x) for x in input()] + [0] for _ in range(H)]\n\nmax_p = 0\nfor i in range(H):\n    for j in range(W):\n        c = copy.deepcopy(C)\n        c[i][j] = 0\n        p = 0\n        for i in range(i,0,-1):\n            c[i][j] = c[i-1][j]\n        c[0][j] = 0\n\n\n        update = True\n        cnt = 0\n        while update:\n            update = False\n\n            for i in range(H):\n                n = c[i][0]\n                nc = n > 0\n                for j in range(1, W + 1):\n                    if c[i][j] == n and n > 0:\n                        nc += 1\n                    else:\n                        if nc >= K:\n                            for k in range(nc):\n                                c[i][j-k-1] = 0\n                            p += nc * n * (2 **cnt)\n                            update = True\n                        n = c[i][j]\n                        nc = n > 0\n\n            for i in range(H-1, 0, -1):\n                for j in range(W):\n                    if c[i][j] > 0: continue\n                    x = i\n                    while x > 0:\n                        x -= 1\n                        if c[x][j] > 0:\n                            c[i][j] = c[x][j]\n                            c[x][j] = 0\n                            break\n            cnt += 1\n\n        max_p = max(max_p,p)\nprint (max_p)\n"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\n\nH, W, K = map(int, input().split())\npuzzle = [list(map(int, list(input()))) for _ in range(H)]\n\n\ndef solve(h, w):\n    pz = deepcopy(puzzle)\n    pz[h][w] = 0\n    tmp_score = -1\n    ans = 0\n    cnt = 0\n    while tmp_score != 0:\n        tmp_score = 0\n        tmp_sum = 0\n        # puzzle落下させる\n        for j in range(W):\n            zero_cnt = 0\n            nums = []\n            for i in range(H):\n                if pz[i][j] != 0:\n                    nums.append(pz[i][j])\n                else:\n                    zero_cnt += 1\n            nums = [0] * zero_cnt + nums\n            for i in range(H - 1, -1, -1):\n                pz[i][j] = nums.pop()\n\n        # puzzle連鎖確認\n        for i in range(H):\n            for left in range(W - 1):\n                for right in range(W, left + 1, -1):\n                    if right - left >= K - 1 and len(set(pz[i][left:right])) == 1:\n                        tmp_sum += sum(pz[i][left:right])\n                        pz[i] = pz[i][:left] + [0] * (right - left) + pz[i][right:]\n\n        tmp_score += (2 ** cnt) * tmp_sum\n        cnt += 1\n        ans += tmp_score\n    return ans\n\n\nf_ans = 0\nfor i in range(H):\n    for j in range(W):\n        f_ans = max(f_ans, solve(i, j))\n\nprint(f_ans)\n"
  },
  {
    "language": "Python",
    "code": "import copy\nH,W,K = map(int,input().split())\nA = [list(map(int,list(input()))) for _ in range(H)]\nscrmax = 0\nfor i in range(1,H):\n    for j in range(W):\n        cnt = 0\n        scr = 0\n        B = copy.deepcopy(A)\n        B[i][j] = 0\n        for k in range(i,0,-1):\n            B[k][j] = B[k-1][j]\n            B[k-1][j] = 0\n        while True:\n            flg = 0\n            for i1 in range(H):\n                C = []\n                while True:\n                    flg1 = 0\n                    cur = 0\n                    m = 0\n                    b = -1\n                    ind = -1\n                    for j1 in range(1,W):\n                        if B[i1][j1]>0 and B[i1][j1]==B[i1][j1-1]:continue\n                        else:\n                            if B[i1][cur]>0 and j1-cur>m:\n                                m = j1-cur\n                                b = B[i1][cur]\n                                ind = cur\n                            cur = j1\n                    if B[i1][cur]>0 and W-cur>m:\n                        m = W-cur\n                        b = B[i1][cur]\n                        ind = cur\n                    if m>=K:\n                        flg = 1\n                        flg1 = 1\n                        scr += 2**cnt*b*m\n                        B[i1][ind:ind+m] = [0 for _ in range(m)]\n                        C.append([ind,m])\n                    if flg1==0:break\n                for ind,m in C:\n                    for j1 in range(ind,ind+m):\n                        for k in range(i1,0,-1):\n                            B[k][j1] = B[k-1][j1]\n                            B[k-1][j1] = 0\n            if flg==0:break\n            cnt += 1\n        scrmax = max(scrmax,scr)     \nprint(scrmax)"
  },
  {
    "language": "Python",
    "code": "'''\nhttps://atcoder.jp/contests/s8pc-3/tasks/s8pc_3_b\n'''\ndef main():\n    import sys\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10000000)\n    from collections import Counter, deque\n    #from collections import defaultdict\n    from itertools import combinations, permutations, accumulate\n    #from itertools import product\n    from bisect import bisect_left,bisect_right\n    import heapq\n    from math import floor, ceil\n    #from operator import itemgetter\n\n    #inf = 10**17\n    #mod = 10**9 + 7\n\n    h,w,k = map(int, input().split())\n    banmen = []\n    for _ in range(h):\n        s = input().rstrip()\n        s = list(s)\n        s = list(map(int, s))\n        banmen.append(s)\n\n    def update():\n        while 1:\n            cnt = 0\n            for i in range(h-1):\n                for j in range(w):\n                    if c[i+1][j] == 0 and c[i][j] != 0:\n                        c[i][j], c[i+1][j] = c[i+1][j], c[i][j]\n                        cnt += 1\n            if cnt == 0:\n                return\n\n    #n回目(0~)\n    def get(n):\n        total = 0\n        for i in range(h):\n            for j in range(0, w-k+1, 1):\n                ten = c[i][j]\n                cnt = 1\n                while c[i][j] == c[i][j+1]:\n                    cnt += 1\n                    j += 1\n                    if j == w-1:\n                        break\n                if cnt >= k:\n                    total += 2**n * (ten*cnt)\n                    c[i][j-(cnt-1):j+1] = [0]*cnt\n        return total\n\n    def solve(i, j):\n        c[i][j] = 0\n        res = 0\n        n = 0\n        while 1:\n            update()\n            total = get(n)\n            if total == 0:\n                break\n            n += 1\n            res += total\n        return res\n\n    import copy\n    res = 0\n    for i in range(h):\n        for j in range(w):\n            c = copy.deepcopy(banmen) \n            res = max(res, solve(i, j))\n    print(res)\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nH, W, K = map(int, input().split())\nboard = [[0]*(W+1) for _ in range(H+1)]\nfor i in range(1,H+1):\n    board[i] = list(map(int, list(input())))+[0]\ndef drop(board_copy):\n    change = True\n    score = 0\n    p = 0\n    while change:\n        change = False\n        for i in range(2,H+1):\n            ser = 1\n            for j in range(1,W+1):\n                if board_copy[i][j]>0 and board_copy[i][j]==board_copy[i][j-1]:\n                    ser += 1\n                else:\n                    if ser>=K:\n                        score += 2**p*board_copy[i][j-1]*ser\n                        change = True\n                        for k in range(i,0,-1):\n                            board_copy[k][j-ser:j] = board_copy[k-1][j-ser:j]\n                    ser = 1\n        p += 1\n    return score\nans = 0\nfor h in range(1,H+1):\n    for w in range(W):\n        board_copy = deepcopy(board)\n        for k in range(h,0,-1):\n            board_copy[k][w] = board[k-1][w]\n        ans = max(ans,drop(board_copy))\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\n\nH, W, K = map(int, input().split())\nX = [list(map(int, list(input()))) for _ in range(H)]\n\ndef gen_mask(X, idx=None):\n    mask = [[True] * W for _ in range(H)]\n    if idx is not None:\n        i, j = idx\n        mask[i][j] = False\n        return mask\n    \n    # Erase mask\n    for i in range(H):\n        for j in range(W):\n            tmp = [False] * W\n            for k in range(j, W):\n                if X[i][j] == X[i][k]:\n                    tmp[k] = True\n                else:\n                    break\n            if sum(tmp) >= K:\n                mask[i] = [not v for v in tmp]\n                break\n    return mask\n\ndef erase(X, mask):\n    new = [[0] * W for _ in range(H)]\n    res = 0\n    for j in range(W):\n        idx = H - 1\n        for i in reversed(range(H)):\n            if mask[i][j]:\n                new[idx][j] = X[i][j]\n                idx -= 1\n            else:\n                res += X[i][j]\n\n    return new, res\n\ndef compute(idx):\n    X_tmp = deepcopy(X)\n    mask = gen_mask(X_tmp, idx)\n    res = 0\n\n    for i in range(-1, 1000):\n        X_new, tmp = erase(X_tmp, mask)\n        if tmp == 0:\n            break\n\n        # Update\n        X_tmp = X_new\n        mask = gen_mask(X_tmp)\n        \n        if i >= 0:\n            res += 2 ** i * tmp\n\n    return res\n\nans = 0\nfor i in range(H):\n    for j in range(W):\n        ans = max(ans, compute((i, j)))\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\n\nh,w,border=map(int,input().split())\nG_original=[]\nfor i in range(w):\n    L=list(str(input()))\n    for j in range(len(L)):\n        L[j]=int(L[j])\n    G_original.append(L)\n\n\n\ndef delete(row):\n    #圧縮\n    L=[]\n    temp=[row[0],1]\n    for i in range(len(row)-1):\n        if row[i]==row[i+1]:\n            temp[1]+=1\n        else:\n            L.append(temp)\n            temp=[row[i+1],1]\n    L.append(temp)\n\n    res=0\n    index=-1\n    for i in range(len(L)):\n        if L[i][0]>=1 and L[i][1]>=border:\n            for j in range(index+1,index+L[i][1]+1):\n                row[j]=-1\n            res+=L[i][0]*L[i][1]\n            index+=L[i][1]\n        else:\n            index+=L[i][1]\n    return res,row\n    \n#ans=delete([1,2,2,2,2,5,2,3,3,3,1])\n#print(ans)\n\nans=0\nfor i in range(h):\n    for j in range(w):\n        #必要か\n        G=deepcopy(G_original)\n        temp=0\n        G[i][j]=-1\n        count=-1\n        while True:\n            for k in range(w):\n                res=[]\n                for l in range(h)[::-1]:\n                    if G[l][k]>=1:\n                        res.append(G[l][k])\n                if len(res)<w:\n                    res+=[-1]*(w-len(res))\n                for l in range(h):\n                    G[l][k]=res[h-l-1]\n\n            #print(G)\n\n            count+=1\n            flag=True\n            for k in range(h):\n                now,G[k]=delete(G[k])\n                if now>0:\n                    temp+=(2**count)*now\n                    flag=False\n            #print(temp,G)\n\n            if flag:\n                break\n            \n        ans=max(ans,temp)\n        \nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nH, W, K = map(int, input().split())\nboard = [[0]*(W+1) for _ in range(H+1)]\nfor i in range(1,H+1):\n    board[i] = list(map(int, list(input())))+[0]\ndef drop(board_copy):\n    change = True\n    score = 0\n    p = 0\n    while change:\n        change = False\n        for i in range(2,H+1):\n            ser = 1\n            for j in range(1,W+1):\n                if board_copy[i][j]>0 and board_copy[i][j]==board_copy[i][j-1]:\n                    ser += 1\n                else:\n                    if ser>=K:\n                        score += 2**p*board_copy[i][j-1]*ser\n                        change = True\n                        for k in range(i,0,-1):\n                            board_copy[k][j-ser:j] = board_copy[k-1][j-ser:j]\n                    ser = 1\n        p += 1\n    return score\nans = 0\nfor h in range(2,H+1):\n    for w in range(W):\n        board_copy = deepcopy(board)\n        for k in range(h,0,-1):\n            board_copy[k][w] = board[k-1][w]\n        ans = max(ans,drop(board_copy))\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from itertools import groupby\ndef calc():\n  s = 0\n  for i in range(h):\n    gr = groupby(g[i])\n    j = 0\n    for key,it in gr:\n      if key==-1: continue\n      l = len(list(it))\n      if l >= K:\n        g[i][j:j+l] = [-1]*l\n        # for k in range(l):\n        #   g[i][j+k] = -1\n        # # print(\"s\", key, l, key*l)\n        s += key*l\n      j += l\n      # print(\"j\", j)\n\n  return s\n\ndef flatten():\n  for j in range(w):\n    lst = []\n    for i in range(h-1, -1, -1):\n      if g[i][j] > 0:\n        lst.append(g[i][j])\n\n    lst += [-1] * (h - len(lst))\n\n    for i in range(h-1, -1, -1):\n      g[i][j] = lst[h-i-1]\n\nh,w,K = map(int,input().split())\nmat = [ [int(e) for e in list(input())] for _ in range(h) ]\n\nres = 0\nfor i in range(h):\n  for j in range(w):\n    score = 0\n    g = [ [ mat[n][m] for m in range(w) ] for n in range(h) ]\n    g[i][j] = -1\n    time = 0\n    flatten()\n    while True:\n      s = calc()\n      if s > 0:\n        score += pow(2, time) * s\n      else:\n        break\n      flatten()\n      time += 1\n    res = max(res, score)\n\nprint(res)\n\n"
  },
  {
    "language": "Python",
    "code": "import copy\nH,W,K = map(int,input().split())\nA = [list(map(int,list(input()))) for _ in range(H)]\nscrmax = 0\nfor i in range(1,H):\n    for j in range(W):\n        cnt = 0\n        scr = 0\n        B = copy.deepcopy(A)\n        B[i][j] = 0\n        for k in range(i,0,-1):\n            B[k][j] = B[k-1][j]\n            B[k-1][j] = 0\n        while True:\n            flg = 0\n            for i1 in range(H):\n                cur = 0\n                m = 0\n                b = -1\n                ind = -1\n                for j1 in range(1,W):\n                    if B[i1][j1]>0 and B[i1][j1]==B[i1][j1-1]:continue\n                    else:\n                        if B[i1][cur]>0 and j1-cur>m:\n                            m = j1-cur\n                            b = B[i1][cur]\n                            ind = cur\n                        cur = j1\n                if B[i1][cur]>0 and W-cur>m:\n                    m = W-cur\n                    b = B[i1][cur]\n                    ind = cur\n                if m>=K:\n                    flg = 1\n                    scr += 2**cnt*b*m\n                    B[i1][ind:ind+m] = [0 for _ in range(m)]\n                    for j2 in range(ind,ind+m):\n                        for k in range(i1,0,-1):\n                            B[k][j2] = B[k-1][j2]\n                            B[k-1][j2] = 0\n            if flg==0:break\n            cnt += 1\n        scrmax = max(scrmax,scr)     \nprint(scrmax)"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\ndef main():\n  h,w,k=map(int,input().split())\n  grid=[list(input()) for _ in range(h)]\n  def score(t):\n    total=0\n    for i in range(1,h):\n      for j in range(w-1):\n        cnt=1\n        ten=int(gc[i][j])\n        while gc[i][j+1]==gc[i][j]:\n          cnt+=1\n          j+=1\n          if j==w-1:\n            break\n        if cnt>=k:\n          total+=2**t*(ten*cnt)\n          gc[i][j-cnt+1:j+1]=['0']*cnt\n    return total\n  def upd():\n    while 1:\n      ok=True\n      for i in range(1,h):\n        for j in range(w):\n          if gc[i][j]=='0' and gc[i-1][j]!='0':\n            x=gc[i-1][j]\n            gc[i-1][j]='0'\n            gc[i][j]=x\n            ok=False\n      if ok:\n        return\n  ans=0\n  for i in range(1,h):\n    for j in range(w):\n      gc=deepcopy(grid)\n      gc[i][j]='0'\n      t=0\n      res=0\n      while 1:\n        upd()\n        total=score(t)\n        if total==0:\n          break\n        t+=1\n        res+=total\n      ans=max(ans,res)\n  return print(ans)\nif __name__=='__main__':\n  main()"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nh,w,n = (int(i) for i in input().split())\nc1,ans = [[] for i in range(w)],0\nfor i in range(h):\n\ts = input()\n\tfor j in range(w): c1[j].append(int(s[j]))\nif n<4:\n\tif h==50: z = 40\n\telse: z = h//2\n\tfor i in range(z,h):\n\t\tfor j in range(w):\n\t\t\tc,m,a = deepcopy(c1),0,0\n\t\t\tdel c[j][i]\n\t\t\tc[j].insert(0,0)\n\t\t\twhile 1:\n\t\t\t\td = []\n\t\t\t\tfor k in range(i-h,-h,-1):\n\t\t\t\t\tk2 = 0\n\t\t\t\t\twhile k2<w-n+1:\n\t\t\t\t\t\tif c[k2][k] and all(c[k2][k]==c[k2+k3][k] for k3 in range(1,n)):\n\t\t\t\t\t\t\tb = n\n\t\t\t\t\t\t\tfor k3 in range(k2+n,w):\n\t\t\t\t\t\t\t\tif c[k2][k]==c[k3][k]: b+=1\n\t\t\t\t\t\t\t\telse: break\n\t\t\t\t\t\t\td.append((h+k,k2,b))\n\t\t\t\t\t\t\tk2+=b\n\t\t\t\t\t\telse: k2+=1\n\t\t\t\tif d:\n\t\t\t\t\tfor k,k2,k3 in d:\n\t\t\t\t\t\ta+=(2**m)*c[k2][k]*k3\n\t\t\t\t\t\tfor k4 in range(k2,k2+k3): del c[k4][k]\n\t\t\t\t\tfor k,k2,k3 in d:\n\t\t\t\t\t\tfor k4 in range(k2,k2+k3): c[k4].insert(0,0)\n\t\t\t\telse: break\n\t\t\t\tm+=1\n\t\t\tans = max(ans,a)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/env python3\n\ndef dropcell():\n    for y in range(H):\n        for i in range(H):\n            for j in range(W):\n                if gm[H-i][j] == 0:\n                    gm[H-i-1][j], gm[H-i][j] = gm[H-i][j], gm[H-i-1][j]\ndef removecell():\n    global gp, gf\n    gf = False\n    p = 0\n    for y in range(H):\n        c = 1\n        t = 0\n        for i in range(W+1):\n            x = gm[y+1][i]\n            if x > 0 and x == t:\n                c += 1\n            else:\n                if c >= K:\n                    for j in range(c):\n                        gm[y+1][i-1-j] = 0\n                    p += (t * c)\n                    gf = True\n                t = x\n                c = 1\n    gp += p * (2**gi)\n\n\nH, W, K = map(int, input().split())\nM = [[0]*(W+1)]+[list(map(int, list(input())))+[0] for i in range(H)]\npoints = {}\nfor i in range(H-1,H):\n    for j in range(W):\n        gp = 0\n        gf = True\n        gi = 0\n        gm = [[j for j in i]for i in M]\n        gm[i+1][j] = 0\n        while gf:\n            dropcell()\n            removecell()\n            gi += 1\n        points[gp] = 1\nprint(max(points))"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\n\n\ndef calc(a, t):\n    global ansd, tmp\n    flag = deepcopy(a)\n    f = False\n    for y, b in enumerate(a):\n        cnt = 0\n        now = tmp - 1\n        for x, c in enumerate(b):\n            flag[y][x] = False\n            if c == now:\n                cnt += 1\n            else:\n                if cnt >= K:\n                    ansd += now * cnt * (2 ** t)\n                    for z in range(x - cnt, x):\n                        flag[y][z] = True\n                        f = True\n                now = c\n                cnt = 1\n        if cnt >= K:\n            ansd += now * cnt * (2**t)\n            for z in range(x - cnt + 1, x + 1):\n                flag[y][z] = True\n                f = True\n    if f:\n        a = collapse(a, flag)\n        calc(a, t + 1)\n    else:\n        return\n\n\ndef collapse(m, f):\n    global tmp\n    ans = [[0] * W for _ in range(H)]\n    for x in range(W):\n        cnt = H - 1\n        for y in range(H)[::-1]:\n            if f[y][x]:\n                continue\n            if m[y][x] < 0:\n                continue\n            ans[cnt][x] = m[y][x]\n            cnt -= 1\n            tmp -= 1\n    for y in range(H):\n        for x in range(W):\n            if ans[y][x] == 0:\n                ans[y][x] = tmp\n                tmp -= 1\n    m = ans\n    return m\n\n\nH, W, K = map(int, input().split())\nC = [[0] * W for _ in range(H)]\nfor h in range(H):\n    s = input()\n    for w, s_ in enumerate(s):\n        C[h][w] = int(s_)\nans = 0\nfor i in range(1, H):\n    for j in range(W):\n        D = deepcopy(C)\n        tmp = -1\n        for k in range(1, i+1)[::-1]:\n            D[k][j] = D[k-1][j]\n        D[0][j] = tmp\n        tmp -= 1\n        ansd = 0\n        calc(D, 0)\n        ans = max(ans, ansd)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from itertools import groupby\ndef calc():\n  s = 0\n  for i in range(h):\n    gr = groupby(g[i])\n    j = 0\n    for key,it in gr:\n      l = len(list(it))\n      j += l\n      if key==-1: continue\n      if l >= K:\n        g[i][j:j+l] = [-1]*l\n        # for k in range(l):\n        #   g[i][j+k] = -1\n        # # print(\"s\", key, l, key*l)\n        s += key*l\n \n  return s\n\ndef flatten():\n  for j in range(w):\n    lst = []\n    for i in range(h-1, -1, -1):\n      if g[i][j] > 0:\n        lst.append(g[i][j])\n\n    lst += [-1] * (h - len(lst))\n\n    for i in range(h-1, -1, -1):\n      g[i][j] = lst[h-i-1]\n\nh,w,K = map(int,input().split())\nmat = [ [int(e) for e in list(input())] for _ in range(h) ]\n\nres = 0\nfor i in range(h):\n  for j in range(w):\n    score = 0\n    g = [ [ mat[n][m] for m in range(w) ] for n in range(h) ]\n    g[i][j] = -1\n    time = 0\n    flatten()\n    while True:\n      s = calc(time)\n      if s==0: break\n      score += s\n      flatten()\n      time += 1\n    res = max(res, score)\n\nprint(res)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nH,W,K = map(int,readline().split())\nS = np.array([list(line.rstrip()) for line in readlines()]).astype(np.int8) - ord('0')\n\n# 下から上の順に\nS = S[::-1].T\n\ndef drop(S):\n    for i in range(W):\n        col = S[i]\n        S[i] = drop_col(col)\n\ndef drop_col(col):\n    x = np.zeros(H,np.int8)\n    nonzero = col[col != 0]\n    x[:len(nonzero)] = nonzero\n    return x\n\ndef cnt_connection(S):\n    # 横につながっている個数\n    x = np.ones_like(S)\n    equal = (S[:-1] == S[1:])\n    for i in range(1,W):\n        x[i] = x[i-1] * equal[i-1] + 1\n    for i in range(W-2,-1,-1):\n        x[i][equal[i]] = x[i+1][equal[i]]\n    return x\n\ndef simulate(S,turn):\n    # 落とす -> 消去、で1セット\n    drop(S)\n    conn = cnt_connection(S)\n    remove = (conn >= K)\n    before = S.sum()\n    S *= (~remove)\n    after = S.sum()\n    if before == after:\n        # 消えなかった\n        return 0\n    else:\n        x = simulate(S,turn+1)\n        return x + ((before - after) << turn)\n\ndef calc(j):\n    T = S.copy()\n    T[j,0] = 0\n    return simulate(T,0)\n\nanswer = 0\nfor i in range(H):\n    x = max(calc(j) for j in range(W))\n    if answer < x:\n        answer = x\n    H -= 1\n    S = S[:,1:]\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom copy import deepcopy\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\n\n\ndef drop(H, G):\n    G = [[n for n in col if n != -1] for col in zip(*G)]\n    G = [[-1] * (H - len(col)) + col for col in G]\n    G = [list(row) for row in zip(*G)]\n    return G\n\n\ndef main():\n    H, W, K = map(int, readline().split())\n    G_init = [list(map(int, list(readline().strip()))) for _ in range(H)]\n\n    ans = 0\n    for i in range(H):\n        for j in range(W):\n            G = deepcopy(G_init)\n            G[i][j] = -1\n            G = drop(H, G)\n\n            current_ans = 0\n            step = 0\n            while True:\n                score = 0\n                for row in G:\n                    seq = [[row[0], 1]]\n                    for n in row[1:]:\n                        if n == seq[-1][0]:\n                            seq[-1][1] += 1\n                        else:\n                            seq.append([n, 1])\n                    idx = 0\n                    for n, c in seq:\n                        if n != -1 and c >= K:\n                            score += n * c\n                            row[idx : idx + c] = [-1] * c\n                        idx += c\n\n                if score == 0:\n                    break\n\n                current_ans += score * pow(2, step)\n                step += 1\n                G = drop(H, G)\n\n            if current_ans > ans:\n                ans = current_ans\n\n    print(ans)\n    return\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "from itertools import groupby\ndef calc():\n  s = 0\n  for i in range(h):\n    gr = groupby(g[i])\n    j = 0\n    for key,it in gr:\n      l = len(list(it))\n      if key!=-1:\n        if l >= K:\n          # g[i][j:j+l] = [-1]*l\n          for k in range(l):\n            g[i][j+k] = -1\n          s += key*l\n      j += l\n \n  return s\n\ndef flatten():\n  for j in range(w):\n    lst = []\n    for i in range(h-1, -1, -1):\n      if g[i][j] > 0:\n        lst.append(g[i][j])\n\n    lst += [-1] * (h - len(lst))\n\n    for i in range(h-1, -1, -1):\n      g[i][j] = lst[h-i-1]\n\nh,w,K = map(int,input().split())\nmat = [ [int(e) for e in list(input())] for _ in range(h) ]\n\nres = 0\nfor i in range(h):\n  for j in range(w):\n    score = 0\n    g = [ [ mat[n][m] for m in range(w) ] for n in range(h) ]\n    g[i][j] = -1\n    time = 0\n    flatten()\n    while True:\n      s = calc()\n      if s==0: break\n      score += (2**time)*s\n      flatten()\n      time += 1\n    res = max(res, score)\n\nprint(res)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque   \n\nicase=0\nif icase==0:\n    h,w,k=map(int,input().split())\n    aa=[[0]*w for i in range(h)]\n    for i in range(h):\n        ll=input()\n        for j in range(w):\n            aa[h-1-i][j]=int(ll[j])\nelif icase==1:\n    h,w,k=4,4,2    \n    aa=[[2, 3, 1, 2], [1, 4, 2, 4], [4, 1, 2, 1], [3, 4, 1, 3]]\nelif icase==2:\n    h,w,k=4,4,2    \n    aa=[[2, 1, 2, 1], [1, 2, 1, 2], [2, 1, 2, 1], [1, 2, 1, 2]]\nelif icase==3:\n    h,w,k=7,7,2    \n    aa=[[8, 9, 8, 9, 8, 9, 8], [9, 8, 9, 8, 9, 8, 9], [8, 9, 8, 9, 8, 9, 8], [9, 8, 9, 8, 9, 8, 9], [8, 9, 8, 9, 8, 9, 8], [9, 8, 9, 8, 9, 8, 9], [8, 9, 8, 9, 8, 9, 8]]\nelif icase==4:\n    h,w,k=17,17,2    \n    aa=[[8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6], [7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5], [6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4], [5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3], [4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2], [3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1], [2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8], [9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7], [8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6], [7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5], [6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4], [5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3], [4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2], [3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1], [2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8]]\n#    print(a)\npmax=0\nfor hi in range(h):\n    for wi in range(w): \n        a=[[0]*w for i in range(h)]\n        for i in range(h):\n            for j in range(w):\n                a[i][j]=aa[i][j]\n#    print(\"j:\",j,a)\n        for i in range(hi,h-1):\n            a[i][wi]=a[i+1][wi]\n        a[h-1][wi]=0\n#    print(\"1:\",a)\n        p=0\n        ip=-1\n        while True:\n            ip+=1\n            p1=0\n            yn=\"\"\n            for i in range(h):\n                q=deque()\n                for j2 in range(w-k+1):\n                    for j3 in range(j2+1,j2+k):\n                        if a[i][j2]==0 or a[i][j2]!=a[i][j3]:\n                            break\n                        q.append((j2,a[i][j2]))\n                        yn=\"yes\"\n#            print(\"i:\",i,q)\n                jm=-2\n                while len(q)>0:\n                    j2,aij=q.popleft()\n                    for j3 in range(j2,j2+k):\n                        a[i][j3]=0\n#                print(\"j2:\",j2,\"jm+1:\",jm+1)\n                    if j2!=jm+1:\n                        p1+=aij*k\n                    else:\n                        p1+=aij\n                    jm=j2\n#                print(\"p1:\",p1)\n\n#            print(\"1:\",a)\n#        print(\"2:\",a)\n            for jj in range(w):\n                for ii in range(h):\n                    if a[ii][jj]==0:\n                        for iii in range(ii+1,h):\n                            if a[iii][jj]!=0:\n                                a[ii][jj]=a[iii][jj]\n                                a[iii][jj]=0\n                                break\n#        print(yn,a)\n            p+=p1*(2**ip)\n            if yn!=\"yes\":\n#            print(p,p1,ip)\n                break\n#    print(\"---------------------\")\n        pmax=max(pmax,p)\n#        print(a)\nprint(pmax)\n    \n"
  },
  {
    "language": "Python",
    "code": "from sys import setrecursionlimit, exit\nsetrecursionlimit(1000000000)\n\nfrom heapq import heapify, heappush, heappop, heappushpop, heapreplace\nfrom bisect import bisect_left, bisect_right\n\nfrom math import atan, degrees\n\nh, w, k = map(int, input().split())\nori = [list(map(int, list(input()))) for _ in range(h)]\nori.reverse()\nans = 0\nfor x in range(w):\n    for y in range(h - 1):\n        data = [[ori[i][j] for j in range(w)] for i in range(h)]\n        for i in range(y, h - 1):\n            data[i][x] = data[i+1][x]\n        data[h-1][x] = 0\n        score = 0\n        lc = 1\n        nxt = True\n        while nxt:\n            nxt = False\n            for i in range(h):\n                c = 1\n                for j in range(1, w):\n                    if data[i][j] != 0 and data[i][j] == data[i][j-1]:\n                        c += 1\n                    else:\n                        if c >= k:\n                            nxt = True\n                            score += data[i][j-1] * c * lc\n                            for l in range(j - c, j):\n                                data[i][l] = 0\n                        c = 1\n                if c >= k:\n                    nxt = True\n                    score += data[i][w-1] * c * lc\n                    for l in range(w - c, w):\n                        data[i][l] = 0\n            for j in range(w):\n                z = 0\n                for i in range(h):\n                    if data[i][j] == 0:\n                        z += 1\n                    elif z > 0:\n                        data[i-z][j] = data[i][j]\n                        data[i][j] = 0\n            lc *= 2\n        ans = max(ans, score)\n        if score == 0:\n            break\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "def ABC120_D():\n    class UnionFind():\n        def __init__(self, n):\n            self.parent = [-1 for _ in range(n)]\n            # 正==子: 根の頂点番号 / 負==根: 連結頂点数\n\n        def find(self, x):\n            # 要素xが属するグループの根を返す\n            if self.parent[x] < 0:\n                return x\n            else:\n                self.parent[x] = self.find(self.parent[x])\n                return self.parent[x]\n\n        def unite(self, x, y):\n            # 要素xが属するグループと要素yが属するグループとを併合する\n            x, y = self.find(x), self.find(y)\n            if x == y:\n                return False\n            else:\n                if self.size(x) < self.size(y):\n                    x, y = y, x\n                self.parent[x] += self.parent[y]\n                self.parent[y] = x\n\n        def same(self, x, y):\n            # 要素x, yが同じグループに属するかどうかを返す\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            # 要素xが属するグループのサイズ（要素数）を返す\n            x = self.find(x)\n            return -self.parent[x]\n\n        def is_root(self, x):\n            # 要素の根をリストで返す\n            return self.parent[x] < 0\n\n        def roots(self):\n            # すべての根の要素をリストで返す\n            return [i for i, x in enumerate(self.parent) if x < 0]\n\n        def members(self, x):\n            # 要素xが属するグループに属する要素をリストで返す\n            root = self.find(x)\n            return [i for i in range(self.n) if self.find(i) == root]\n\n        def group_count(self):\n            # グループの数を返す\n            return len(self.roots())\n\n        def all_group_members(self):\n            # {ルート要素: [そのグループに含まれる要素のリスト], ...}の辞書を返す\n            return {r: self.members(r) for r in self.roots()}\n    N, M = LI()\n    P = [[]for _ in range(M)]\n    for i in range(M):\n        P[i] = LI()\n    uf = UnionFind(N)\n    ans = [N*(N-1)//2]*M\n    for i,[a,b] in enumerate(P[M-1:0:-1]):\n        #print(i,a,b)\n        a -= 1; b -= 1\n        if uf.same(a,b):\n            ans[i+1] = ans[i]\n        else:\n            cur = uf.size(a)*uf.size(b)\n            ans[i+1] = ans[i]-cur\n            uf.unite(a,b)\n    for v in ans[::-1]:\n        print(v)\n    return\n\ndef JOI8_1():\n    N = I()\n    C = [I()for _ in range(N)]\n    prev = C[0]\n    BW = [[1,prev]]\n    for i in range(1,N):\n        #print(BW)\n        if BW[-1][1]==C[i]:\n            BW[-1][0] += 1\n        else:\n            if i%2==0:\n                BW.append([1,C[i]])\n            else:\n                if len(BW) > 1:\n                    BW[-2][0] += (BW[-1][0] + 1)\n                    del BW[-1]\n                else:\n                    BW[0][0] += 1\n                    BW[0][1] = C[i]\n    ans = 0\n    #print(BW)\n    for i,s in BW:\n        if s==0:\n            ans += i\n    print(ans)\n    return\n\"\"\"\n8\n1\n0\n1\n1\n0\n0\n0\n1\n\"\"\"\ndef JOI13_A():\n    N = I()\n    A = LI()\n    S = []\n    cur = 1\n    prev = A[0]\n    for i in range(1,N):\n        if prev^A[i]==1:\n            cur += 1\n        else:\n            S.append(cur)\n            cur = 1\n        prev = A[i]\n    if cur>0:\n        S.append(cur)\n    #print(S)\n    ans = 0\n    for i in range(len(S)-2):\n        cur = S[i]+S[i+1]+S[i+2]\n        if ans<cur:\n            ans = cur\n    if len(S)<=2:\n        ans = N\n    print(ans)\n    return\n\"\"\"\n10 \n1 1 0 0 1 0 1 1 1 0\n\"\"\"\ndef square869120Contest5_B():\n    def length(a,b):\n        return ((a[0]-b[0])**2 + (a[1]-b[1])**2)**0.5\n    def check(r):\n        for i in range(M):\n            for j in range(N):\n                if length(X[i],A[j][0:2])<A[j][2]+r+_ep:\n                    return False\n            for j in range(M):\n                if i==j:\n                    continue\n                if length(X[i],X[j])<r+r+_ep:\n                    return False\n        return True\n    N, M = LI()\n    A = [LI()for _ in range(N)]\n    X = [LI()for _ in range(M)]\n    minA = inf\n    for i,j,a in A:\n        if minA>a:\n            minA = a\n    l = 0; r = 200\n    while(r-l>_ep):\n        now = (l+r)/2\n        if check(now):\n            l = now\n        else:\n            r = now\n    ans = min(l,minA)\n    print(ans)\n    return\n\ndef ABC144_D():\n    a, b, x = LI()\n    half = a*a*b/2\n    if x>=half:\n        y = (half*2-x)/(a*a/2)\n        deg = math.atan2(a,y)\n        #print(y,a,deg)\n        ans = 90-deg*180/math.pi\n    else:\n        y = x/(a*b/2)\n        deg = math.atan2(b,y)\n        ans = deg*180/math.pi\n    print(ans)\n    return\n\ndef square869120Contest3_B():\n    def check_del(S):\n        sco = 0\n        for h in range(H):\n            for w in range(W-K+1):\n                s = S[h][w]\n                if s==0:\n                    continue\n                if K==3 and s==S[h][w+1] and s==S[h][w+2]:\n                    d = 3\n                    for k in range(W-K+1-w):\n                        if S[h][w]!=S[h][w+2+k]:\n                            break\n                        d += 1\n                    t = S[h][w]\n                    sco += cal_score(t,d)\n                    del_stone(S,h,w,d)\n                elif K==2 and s==S[h][w+1]:\n                    d = 2\n                    for k in range(W-K-w):\n                        if S[h][w]!=S[h][w+2+k]:\n                            break\n                        d += 1\n                    t = S[h][w]\n                    sco += cal_score(t,d)\n                    del_stone(S,h,w,d)\n        return sco,S\n    def del_stone(S,y,x,k):\n        for i in range(k):\n            S[y][x+i] = 0\n        return S\n    def cal_score(t,c):\n        return (2**now)*(t*c)\n    def move_stone(S):\n        rep = deepcopy(S)\n        for w in range(W):\n            blank = -1\n            que = deque()\n            for h in range(H)[::-1]:\n                if rep[h][w]==0:\n                    if blank==-1:\n                        blank = h\n                else:\n                    if blank>=0:\n                        que.append(rep[h][w])\n                        rep[h][w] = 0\n            if blank==-1:\n                continue\n            for h,i in enumerate(que):\n                rep[blank-h][w] = i\n        return rep\n    H, W, K = LI()\n    A = [SI()for _ in range(H)]\n    C = [[]for _ in range(H)]\n    for h in range(H):\n        for w in range(W):\n            C[h].append(int(A[h][w]))\n    if K>=4:\n        print(0)\n        return\n    ans = 0\n    for h in range(H):\n        for w in range(W):\n            nowC = deepcopy(C)\n            nowC[h][w] = 0\n            #print(nowC)\n            cur = 0\n            now = 0\n            while(True):\n                nowC = move_stone(nowC)\n                #print(nowC)\n                rep,nowC = check_del(nowC)\n                #print(nowC)\n                #print()\n                if rep==0:\n                    break\n                cur += rep\n                now += 1\n            #print(h,w,cur)\n            if ans<cur:\n                ans = cur\n    print(ans)\n    return\n\nimport sys,bisect,itertools,heapq,math,random\nfrom copy import deepcopy\nfrom heapq import heappop,heappush,heapify\nfrom collections import Counter,defaultdict,deque\n\ndef I(): return int(sys.stdin.readline())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef SI(): return sys.stdin.readline().strip()\nglobal mod,mod2,inf,alphabet,_ep\nmod = 10**9 + 7\nmod2 = 998244353\ninf = 10**18\n_ep = 10**(-12)\nalphabet = [chr(ord('a') + i) for i in range(26)]\n\nsys.setrecursionlimit(10**6)\n\nif __name__ == '__main__':\n    square869120Contest3_B()\n\"\"\"\n\n\"\"\"\n"
  },
  {
    "language": "Python",
    "code": "import copy\nfrom itertools import groupby\nh,w,K = map(int,input().split())\nl0 = [[int(i) for i in list(input())] for _ in range(h)]\n\n\ndef check(time,l):\n    global K\n    t = 0\n    for i in range(h):\n        gr = groupby(l[i])\n        lst = []\n        p = 0\n        for key,g in gr:\n            j = len(list(g))\n            lst.append([p,key,j])\n            p += j\n        for j in range(len(lst)):\n            if lst[j][1] == 0:\n                continue\n            if lst[j][2] >= K:\n                t += (2**time)*lst[j][1]*lst[j][2]\n                for k in range(lst[j][0],lst[j][0]+lst[j][2]):\n                    l[i][k] = 0\n    return t\n\n\ndef drop(l):\n    for j in range(w):\n        lst = []\n        for i in range(h-1,-1,-1):\n            if l[i][j] > 0:\n                lst.append(l[i][j])\n        lst += [0]*(h-len(lst))\n        for i in range(h-1,-1,-1):\n            l[i][j] = lst[h-i-1]\n\nans = 0\nfor i in range(h):\n    for j in range(w):\n        l = copy.deepcopy(l0)\n        s = 0\n        l[i][j] = 0\n        drop(l)\n        time = 0\n        while True:\n            temp = check(time, l)\n            if temp == 0:\n                break\n            s += temp\n            drop(l)\n            time += 1\n        ans = max(ans,s)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom itertools import groupby\nfrom copy import deepcopy\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\n\n\ndef do_drop(H, W, G):\n    for j in range(W):\n        for i in range(H - 1):\n            for k in range(H - 1, i, -1):\n                if G[k][j] == 0 and G[k - 1][j] != 0:\n                    G[k][j], G[k - 1][j] = G[k - 1][j], G[k][j]\n\n\ndef main():\n    H, W, K = map(int, readline().split())\n    G_base = [list(map(int, readline().strip())) for _ in range(H)]\n\n    ans = 0\n    for i in range(H):\n        for j in range(W):\n            G = deepcopy(G_base)\n            G[i][j] = 0\n            do_drop(H, W, G)\n\n            power = 1\n            score = 0\n            while True:\n                finished = True\n                total = 0\n                for row in G:\n                    idx = 0\n                    for k, g in groupby(row):\n                        l = len(list(g))\n                        if k > 0 and l >= K:\n                            row[idx : idx + l] = [0] * l\n                            total += k * l\n                            finished = False\n                        idx += l\n\n                if finished:\n                    break\n\n                score += power * total\n                power *= 2\n                do_drop(H, W, G)\n\n            if ans < score:\n                ans = score\n\n    print(ans)\n    return\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "\nclass Game:\n    def __init__(self, mp, h, w, k):\n        self.mp = mp\n        self.H = h\n        self.W = w\n\n        self.K = k\n        self.score = 0\n        self.erase_flag = False\n        self.cnt = 0\n        \n    def erase(self):\n        tot = 0\n        for y in range(self.H):\n            line = self.mp[y]\n            new_line, add_score = self.fix(line)\n            self.mp[y] = new_line\n            tot += add_score\n            if add_score != 0:\n                self.erase_flag = True\n        if self.erase_flag:\n            self.score += tot*pow(2, self.cnt)\n            self.cnt += 1\n    \n    def fix(self, line):\n        add_score = 0\n        new_line = line\n        for length in range(self.W, self.K-1, -1):\n            for left in range(self.W - length+1):\n                if all(map(lambda x:x==new_line[left], new_line[left:left+length])):\n                    add_score += new_line[left]*length\n                    new_line = new_line[:left] + [0]*length + new_line[left+length:]\n                    # 最後の要素まで見たか？\n                    # if self.W == left+length:\n                    #     return new_line, add_score\n        return new_line, add_score\n    \n    def fall(self):\n        for x in range(self.W):\n            col = [self.mp[y][x] for y in range(self.H) if self.mp[y][x] != 0]\n            # for y in range(self.H):\n            #     if self.mp[y][x] != 0:\n            #         col.append(self.mp[y][x])\n            col = [0]*(self.H - len(col)) + col\n            for y in range(self.H):\n                self.mp[y][x] = col[y]\n\n    def run(self):\n        while True:\n            self.erase_flag = False\n            self.erase()\n            if not self.erase_flag:\n                break\n            self.fall()\n\nimport copy\ndef resolve():\n    def init_fall(grid, cell):\n        col = [grid[y][cell] for y in range(H) if grid[y][cell] != 0]\n        # for y in range(H):\n        #     if grid[y][cell] != 0:\n        #         col.append(grid[y][cell])\n        col = [0] * (H - len(col)) + col\n        for y in range(H):\n            grid[y][cell] = col[y]\n        return grid\n\n    H, W, K = map(int, input().split())\n    mp = [list(map(int, input())) for _ in range(H)]\n\n    ans = 0\n    for i in range(1,H):\n        for j in range(W):\n            mp_copy = copy.deepcopy(mp)\n            mp_copy[i][j] = 0\n            mp_copy = init_fall(mp_copy,j)\n            game = Game(mp_copy, H, W, K)\n            game.run()\n            ans = max(ans, game.score)\n    print(ans)\n\nif __name__ == \"__main__\":\n    resolve()"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nH, W, K = map(int, input().split())\n\ndef clear(row, start, end, mult):\n    if end - start + 1 < K:\n        return 0\n    gain = 0\n    for i in range(start, end + 1):\n        gain += mult * row[i]\n        row[i] = 0\n    return gain\n\ndef drop(board):\n    for x in range(W):\n        wp = 0\n        for y in range(H):\n            if board[y][x] > 0:\n                board[wp][x] = board[y][x]\n                if wp != y:\n                    board[y][x] = 0\n                wp += 1\n\ndef proceed(board, mult):\n    gain = 0\n    for row in board:\n        start = -1\n        num = -1\n        for i in range(W):\n            if row[i] == num:\n                continue\n            else:\n                gain += clear(row, start, i-1, mult)\n                num = row[i]\n                start = i\n        if num > 0:\n            gain += clear(row, start, W-1, mult)\n    drop(board)\n    return gain\n\nboard_ = []\nfor _ in range(H):\n    board_.append(list(map(int, input())))\nboard_.reverse()\n\nans = 0\nfor y in range(H):\n    for x in range(W):\n        board = deepcopy(board_)\n        board[y][x] = 0\n        drop(board)\n        mult = 1\n        cand = 0\n        while True:\n            gain = proceed(board, mult)\n            if gain == 0:\n                break\n            cand += gain\n            mult *= 2\n        ans = max(ans, cand)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nfrom copy import deepcopy\n\ndef input(): return sys.stdin.readline().strip()\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\nH,W,K=MAP()\norgn=[[0]*W for i in range(H)]\nfor i in range(H):\n    nums=input()\n    for j in range(W):\n        orgn[i][j]=int(nums[j])\n\ndef drop():\n    for i in range(H-1, 0, -1):\n        for j in range(W):\n            if grid[i][j]==0 and grid[i-1][j]!=0:\n                k=i\n                while k<H and grid[k][j]==0:     \n                    grid[k][j]=grid[k-1][j]\n                    grid[k-1][j]=0\n                    k+=1\n\ndef check(times):\n    sm=0\n    for i in range(H):\n        st=0\n        cnt=1\n        for j in range(1, W):\n            if grid[i][j-1]==grid[i][j]:\n                cnt+=1\n            else:\n                if cnt>=K:\n                    sm+=grid[i][j-1]*cnt\n                    for k in range(st, j):\n                        grid[i][k]=0\n                cnt=1\n                st=j\n        else:\n            if cnt>=K:\n                sm+=grid[i][j]*cnt\n                for k in range(st, j+1):\n                    grid[i][k]=0\n    return 2**times*sm\n\nans=0\nfor i in range(H):\n    for j in range(W):\n        grid=deepcopy(orgn)\n        grid[i][j]=0    \n        res=1\n        score=times=0\n        while res:\n            drop()\n            res=check(times)\n            score+=res\n            times+=1\n        ans=max(ans, score)\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import copy\n\ndef score(i,j):\n  Ali = copy.deepcopy(data)\n  Ali[i][j] = 0\n  score = 0\n  turn = 0\n  \n  for i in range(1,H+1):\n    for j in range(W):\n      if Ali[-i][j] == 0:\n        for k in range(i+1,H+1):\n          if Ali[-k][j] != 0:\n            Ali[-i][j] = Ali[-k][j]\n            Ali[-k][j] = 0\n            break\n            \n  while True:\n    sc = score\n    #同じものを消す処理\n    for i in range(H):\n      a = 0 #今の数字\n      b = 0 #今の数字が始まった場所\n      \n      for j in range(W):\n        if Ali[i][j] != a:\n          if j-b >= K:\n            for k in range(b,j):\n              score += Ali[i][k]*2**turn\n              Ali[i][k] = 0\n          a = Ali[i][j]\n          b = j\n      if W-b >= K:\n        for k in range(b,W):\n          score += Ali[i][k]*2**turn\n          Ali[i][k] = 0\n      \n      \n    if sc == score:\n        break\n    turn += 1\n      \n    #落としていく処理\n    #下から上に見ていく\n    for i in range(1,H+1):\n      for j in range(W):\n        if Ali[-i][j] == 0:\n          for k in range(i+1,H+1):\n            if Ali[-k][j] != 0:\n              Ali[-i][j] = Ali[-k][j]\n              Ali[-k][j] = 0\n              break\n              \n  return score\n  \nH,W,K = map(int,input().split())\ndata = [[int(d) for d in input()] for _ in range(H)]\nres = 0\n\nfor i in range(H):\n  for j in range(W):\n    res = max(res,score(i,j))\n    \nprint(res)"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nh,w,n = (int(i) for i in input().split())\nc1,ans = [[] for i in range(w)],0\nfor i in range(h):\n\ts = input()\n\tfor j in range(w): c1[j].append(int(s[j]))\nif n<4:\n\tfor i in range(1,h):\n\t\tfor j in range(w):\n\t\t\tc,m,a = deepcopy(c1),0,0\n\t\t\tdel c[j][i]\n\t\t\tc[j] = [0]+c[j]\n\t\t\twhile 1:\n\t\t\t\td = []\n\t\t\t\tfor k in range(i-h,-h,-1):\n\t\t\t\t\tk2 = 0\n\t\t\t\t\twhile k2<w-n+1:\n\t\t\t\t\t\tif c[k2][k] and all(c[k2][k]==c[k2+k3][k] for k3 in range(1,n)):\n\t\t\t\t\t\t\tb = n\n\t\t\t\t\t\t\tfor k3 in range(k2+n,w):\n\t\t\t\t\t\t\t\tif c[k2][k]==c[k3][k]: b+=1\n\t\t\t\t\t\t\t\telse: break\n\t\t\t\t\t\t\td.append((h+k,k2,b))\n\t\t\t\t\t\t\tk2+=b\n\t\t\t\t\t\telse: k2+=1\n\t\t\t\tif d:\n\t\t\t\t\tfor k,k2,k3 in d:\n\t\t\t\t\t\ta+=(2**m)*c[k2][k]*k3\n\t\t\t\t\t\tfor k4 in range(k2,k2+k3): del c[k4][k]\n\t\t\t\t\tfor k,k2,k3 in d:\n\t\t\t\t\t\tfor k4 in range(k2,k2+k3): c[k4] = [0]+c[k4]\n\t\t\t\telse: break\n\t\t\t\tm+=1\n\t\t\tans = max(ans,a)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "def dropcell(h, w, rm):\n  for i in range(w):\n    y=0\n    for j in range(h):\n      if rm[h-j-1][i]!=0:\n        rm[h-y-1][i]=rm[h-j-1][i]\n        y+=1\n    for j in range(h-y):\n      rm[h-y-j-1][i]=0\n\ndef removecell(h, w, k, rm, a):\n  p=0\n  for y in range(h):\n    c,t=1,0\n    for i in range(w+1):\n      x=rm[y][i]\n      if x>0 and x==t:\n        c+=1\n      else:\n        if c>=k:\n          for j in range(c):\n            rm[y][i-1-j]=0\n          p+=(t*c)\n        t=x\n        c=1\n  return p*(2**a)\n\ndef game(h,w,k,M,y,x):\n  f,score,a=1,0,0\n  rm=[[j for j in i]for i in M[:y+1]]\n  rm[y][x]=0\n  while f:\n    dropcell(len(rm),w,rm)\n    f=removecell(len(rm),w,k,rm,a)\n    score+=f\n    a+=1\n  return score\n\nH,W,K=map(int,input().split())\nM=[list(map(int,list(input())))+[0] for i in range(H)]\nans=0\nfor j in range(W):\n  t=0\n  for i in range(1, H):\n    if M[i][j]!=t:\n      ans=max(ans,game(H,W,K,M,i,j))\n      t=M[i][j]\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/env python3\n\ndef dropcell():\n    for i in range(W):\n        y = 0\n        for j in range(H):\n            a = gm[H-j-1][i]\n            if a != 0:\n                gm[H-y-1][i] = a\n                y += 1\n\ndef removecell():\n    global gp, gf\n    gf = False\n    p = 0\n    for y in range(H):\n        c = 1\n        t = 0\n        for i in range(W+1):\n            x = gm[y][i]\n            if x > 0 and x == t:\n                c += 1\n            else:\n                if c >= K:\n                    for j in range(c):\n                        gm[y][i-1-j] = 0\n                    p += (t * c)\n                    gf = True\n                t = x\n                c = 1\n    gp += p * (2**gi)\n\nH, W, K = map(int, input().split())\nM = [list(map(int, list(input())))+[0] for i in range(H)]\npoints = {}\nfor i in range(H):\n    for j in range(W):\n        gp = 0\n        gf = True\n        gi = 0\n        gm = [[j for j in i]for i in M]\n        gm[i][j] = 0\n        while gf:\n            dropcell()\n            removecell()\n            gi += 1\n        points[gp] = 1\nprint(max(points))"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nH, W, K = map(int, input().split())\nboard = [[0]*W for _ in range(H+1)]\nfor i in range(1,H+1):\n    board[i] = list(map(int, list(input())))\ndef drop(board):\n    change = True\n    score = 0\n    p = 0\n    while change==True:\n        change = False\n        for i in range(1,H+1):\n            ser = 1\n            for j in range(W-1):\n                if board[i][j]==0:\n                    ser = 1\n                    continue\n                if board[i][j]>0 and board[i][j]==board[i][j+1]:\n                    ser += 1\n                elif ser>=K:\n                    score += 2**p*sum(board[i][j-ser+1:j+1])\n                    change = True\n                    for k in range(i,0,-1):\n                        board[k][j-ser+1:j+1] = board[k-1][j-ser+1:j+1]\n                    ser = 1\n            if ser>=K:\n                score += 2**p*sum(board[i][-ser:])\n                change = True\n                for k in range(i,0,-1):\n                    board[k][-ser:] = board[k-1][-ser:]\n        p += 1\n    return score\nans = 0\nfor h in range(1,H+1):\n    for w in range(W):\n        board_copy = deepcopy(board)\n        for k in range(h,0,-1):\n            board_copy[k][w] = board_copy[k-1][w]\n        ans = max(ans,drop(board_copy))\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import copy\nH, W, K = map(int, input().split())\nC = [[0] * W for i in range(H)]\nfor i in range(H):\n  s = str(input())\n  for j in range(W):\n    C[i][j] = int(s[j])\n  \ndef delete(mass, s, t):\n  #ここでは、mass[s][t]を試す\n  mass[s][t] = 0\n  #print(mass)\n  score = 0#score\n  p = -1\n  time = -1#何回目の消滅か\n  while p < 1:#消せるものがある間\n    this = 0\n    for i in range(H):\n      now = 1\n      for j in range(1, W):\n        if (mass[i][j] == mass[i][j - 1]) and (mass[i][j] != 0):\n          now += 1\n        else:\n          if now >= K:\n            this += 1\n            score += (2 ** time) * now * mass[i][j - 1]\n            for k in range(j - now, j):\n              mass[i][k] = 0\n          now = 1\n       # print(mass)\n      if now >= K:\n        this += 1\n        score += (2 ** time) * now * mass[i][j - 1]\n        for k in range(j - now + 1, j + 1):\n          mass[i][k] = 0\n    #print(mass)\n    if this == 0:\n      p += 1\n    #落とすところ\n    for i in range(1, H + 1):\n      for j in range(W):\n        if (mass[H - i][j] == 0) and (i != H):\n          k = 1\n          while (mass[H - i - k][j] == 0) and (k + i < H):\n            k += 1\n          mass[H - i][j] = mass[H - i - k][j]\n          mass[H - i - k][j] = 0\n    time += 1\n  return score\n\nans = 0\nfor i in range(H):\n  for j in range(W):\n    D = copy.deepcopy(C)\n    ans = max(ans, delete(D, i, j))\n  \nprint(ans)\n  \n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import copy\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\ndef main():\n    ans = 0\n    H,W,K = map(int, readline().split())\n    c_ = [list(map(int, list(readline().strip()))) for _ in range(H)]\n\n    for a in range(H):\n        for b in range(W):\n            c = copy.deepcopy(c_)\n            c[a][b] = 0\n\n            seq = [[1] for _ in range(H)]\n            ans_tmp = [0]\n            \n            score = 0\n            weight = 1\n            while True:\n                # 落とす\n                for i in reversed(range(H)):\n                    for j in range(W):\n                        if c[i][j] == 0:\n                            for h in reversed(range(i)):\n                                if c[h][j] != 0:\n                                    c[h][j], c[i][j] = c[i][j], c[h][j]\n                                    break\n\n                # 消す\n                for i, line in enumerate(c):\n                    for j in range(1,W):\n                        if line[j] == line[j-1]:\n                            seq[i][-1] += 1\n                        else:\n                            seq[i].append(1)\n                \n                    acc = -1\n                    for s in seq[i]:\n                        acc += s\n                        if s >= K:\n                            score += s * line[acc] * weight\n                            for j in range(acc - s + 1, acc + 1):\n                                line[j] = 0\n                    seq[i] = [1]\n                \n                weight *= 2\n\n                ans_tmp.append(score)\n                if ans_tmp[-1] == ans_tmp[-2]:\n                    ans = max(ans, ans_tmp[-1])\n                    break\n\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nh,w,n = (int(i) for i in input().split())\nc1,ans = [[] for i in range(w)],0\nfor i in range(h):\n\ts = input()\n\tfor j in range(w): c1[j].append(int(s[j]))\nif n<4:\n\tfor i in range(1,h):\n\t\tfor j in range(w):\n\t\t\tc,m,a = deepcopy(c1),0,0\n\t\t\tdel c[j][i]\n\t\t\tc[j].insert(0,0)\n\t\t\twhile 1:\n\t\t\t\td = []\n\t\t\t\tfor k in range(i-h,-h,-1):\n\t\t\t\t\tk2 = 0\n\t\t\t\t\twhile k2<w-n+1:\n\t\t\t\t\t\tif c[k2][k] and all(c[k2][k]==c[k2+k3][k] for k3 in range(1,n)):\n\t\t\t\t\t\t\tb = n\n\t\t\t\t\t\t\tfor k3 in range(k2+n,w):\n\t\t\t\t\t\t\t\tif c[k2][k]==c[k3][k]: b+=1\n\t\t\t\t\t\t\t\telse: break\n\t\t\t\t\t\t\td.append((h+k,k2,b))\n\t\t\t\t\t\t\tk2+=b\n\t\t\t\t\t\telse: k2+=1\n\t\t\t\tif d:\n\t\t\t\t\tfor k,k2,k3 in d:\n\t\t\t\t\t\ta+=(2**m)*c[k2][k]*k3\n\t\t\t\t\t\tfor k4 in range(k2,k2+k3): del c[k4][k]\n\t\t\t\t\tfor k,k2,k3 in d:\n\t\t\t\t\t\tfor k4 in range(k2,k2+k3): c[k4].insert(0,0)\n\t\t\t\telse: break\n\t\t\t\tm+=1\n\t\t\tans = max(ans,a)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "\nimport sys\nsys.setrecursionlimit(10 ** 7)\nread = sys.stdin.buffer.read\ninp = sys.stdin.buffer.readline\ndef inpS(): return inp().rstrip().decode()\n\nimport copy\ndef resolve():\n    def drop(board_copy):\n        change = True\n        score = 0\n        p = 0\n        while change:\n            change = False\n            for i in range(2, H + 1):\n                ser = 1\n                for j in range(1, W + 1):\n                    if board_copy[i][j] > 0 and board_copy[i][j] == board_copy[i][j - 1]:\n                        ser += 1\n                    else:\n                        if ser >= K:\n                            score += 2 ** p * board_copy[i][j - 1] * ser\n                            change = True\n                            for k in range(i, 0, -1):\n                                board_copy[k][j - ser:j] = board_copy[k - 1][j - ser:j]\n                        ser = 1\n            p += 1\n        return score\n\n    H, W, K = map(int, input().split())\n    mp = []\n    mp.append([0] * (W + 1))\n    mp += [list(map(int, input())) + [0] for _ in range(H)]\n\n    ans = 0\n    for i in range(1, H + 1):\n        for j in range(W):\n            mp_copy = copy.deepcopy(mp)\n            for k in range(i, 0, -1):\n                mp_copy[k][j] = mp_copy[k - 1][j]\n            score = drop(mp_copy)\n            ans = max(ans, score)\n    print(ans)\n\nif __name__ == \"__main__\":\n    resolve()\n"
  },
  {
    "language": "Python",
    "code": "H,W,K = list(map(int,input().split()))\nC = [list(input()) for _ in range(H)]\n\ndef F1(c):\n    for i in range(W):\n        for j in range(H-1,-1,-1):\n            if c[j][i] != 'X': continue\n            for k in range(j-1,-1,-1):\n                if c[k][i] != 'X':\n                    c[j][i], c[k][i] = c[k][i], c[j][i]\n                    break\n    return c\n\ndef F2(c):\n    delete_sum = 0\n    for i in range(H):\n        for j in range(W):\n            if c[i][j] == 'X': continue\n            tmp = c[i][j]\n            count = 1\n            for k in range(j+1,W):\n                if c[i][k] == tmp:\n                    count += 1\n                else:\n                    break\n            if count >= K:\n                for k in range(j,W):\n                    if c[i][k] == tmp:\n                        delete_sum += int(c[i][k])\n                        c[i][k] = 'X'\n                    else:\n                        break\n    return c, delete_sum\n\nMAX = 0\nfor i in range(H):\n    for j in range(W):\n        tmpC = []\n        for k in range(H):\n            tmpC.append(C[k][:])\n        tmpC[i][j] = 'X'\n        tmpC = F1(tmpC)\n        point = 0\n        for k in range(1000):\n            tmpC, delete_sum = F2(tmpC)\n            if delete_sum == 0:\n                break\n            tmpC = F1(tmpC)\n            point += 2**k*delete_sum\n        MAX = max(MAX,point)\nprint(MAX)"
  },
  {
    "language": "Python",
    "code": "h, w, k = map(int, input().split())\nori = [list(map(int, list(input()))) for _ in range(h)]\nori.reverse()\nans = 0\nfor y in range(h - 1):\n    for x in range(w):\n        data = [[ori[i][j] for j in range(w)] for i in range(h)]\n        for i in range(y, h - 1):\n            data[i][x] = data[i+1][x]\n        data[h-1][x] = 0\n        score = 0\n        lc = 1\n        nxt = True\n        while nxt:\n            nxt = False\n            for i in range(h):\n                c = 1\n                for j in range(1, w):\n                    if data[i][j] != 0 and data[i][j] == data[i][j-1]:\n                        c += 1\n                    else:\n                        if c >= k:\n                            nxt = True\n                            score += data[i][j-1] * c * lc\n                            for l in range(j - c, j):\n                                data[i][l] = 0\n                        c = 1\n                if c >= k:\n                    nxt = True\n                    score += data[i][w-1] * c * lc\n                    for l in range(w - c, w):\n                        data[i][l] = 0\n            for j in range(w):\n                z = 0\n                for i in range(h):\n                    if data[i][j] == 0:\n                        z += 1\n                    elif z > 0:\n                        data[i-z][j] = data[i][j]\n                        data[i][j] = 0\n            lc *= 2\n        ans = max(ans, score)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/env python3\n\ndef dropcell(H, W, gm):\n    for i in range(W):\n        y = 0\n        for j in range(H):\n            a = gm[H-j-1][i]\n            if a != 0:\n                gm[H-y-1][i] = a\n                y += 1\n\ndef removecell(H, W, K, gm, gp, gi):\n    r = False\n    p = 0\n    for y in range(H):\n        c = 1\n        t = 0\n        for i in range(W+1):\n            x = gm[y][i]\n            if x > 0 and x == t:\n                c += 1\n            else:\n                if c >= K:\n                    for j in range(c):\n                        gm[y][i-1-j] = 0\n                    p += (t * c)\n                    r = True\n                t = x\n                c = 1\n    return p * (2**gi)\n\n\ndef main():\n    H, W, K = map(int, input().split())\n    M = [list(map(int, list(input())))+[0] for i in range(H)]\n    points = {}\n    for i in range(H):\n        for j in range(W):\n            f = 1\n            gp = 0\n            gi = 0\n            gm = [[j for j in i]for i in M]\n            gm[i][j] = 0\n            while f:\n                dropcell(H, W, gm)\n                f = removecell(H, W, K, gm, gp, gi)\n                gp += f\n                gi += 1\n            points[gp] = 1\n    print(min(max(points), 1000000000))\n    \nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "import copy\nH, W, K = map(int, input().split())\nnums = [list(map(int, list(input()))) for _ in range(H)]\nans = 0\nfor row in range(1, H):\n    for col in range(W):\n        score = 0\n        iterations = 0\n        squares = copy.deepcopy(nums)\n        squares[row][col] = 0\n        # print(squares)\n        while True:\n            not_falled = True\n            # 下からやっていった方がいい。また、0行目はやる必要なし\n            for i in range(H - 1, 0, -1):\n                for k, num in enumerate(squares[i]):\n                    if num == 0 and squares[i - 1][k] != 0:\n                        squares[i - 1][k], squares[i][k] = squares[i][k], squares[i - 1][k]\n                        not_falled = False\n            if not_falled:\n                break\n        # print(squares)\n        while True:\n            deleted = False\n            for i in range(H):\n                for j in range(W, K - 1, -1):\n                    for k in range(W - j + 1):\n                        deletable = True\n                        first_num = squares[i][k]\n                        if first_num == 0:\n                            continue\n                        for num in squares[i][k + 1:k + j]:\n                            if first_num != num:\n                                deletable = False\n                                break\n                        # print(deletable)\n                        if deletable:\n                            # print((2**iterations) * (first_num * j))\n                            score += (2**iterations) * (first_num * j)\n                            squares[i][k:k + j] = [0] * j\n                            deleted = True\n            # print(squares)\n            if deleted:\n                while True:\n                    not_falled = True\n                    # 下からやっていった方がいい。また、0行目はやる必要なし\n                    for i in range(H - 1, 0, -1):\n                        for k, num in enumerate(squares[i]):\n                            if num == 0 and squares[i - 1][k] != 0:\n                                squares[i - 1][k], squares[i][k] = squares[i][k], squares[i - 1][k]\n                                not_falled = False\n                    if not_falled:\n                        break\n            else:\n                break\n            iterations += 1\n        # print(ans, score)\n        ans = max(ans, score)\nprint(ans)\n# print(squares)s\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nimport copy\n\nH, W, K = map(int, input().split())\nif K > W:\n    exit(print(0))\n\n# 現在の盤面を生成する\nc = [[] for _ in range(W)]\nfor i in range(H):\n    S = input()\n    for j in range(W):\n        c[j].append(int(S[j]))\n\nfor j in range(W):\n    c[j] = c[j][::-1]\n\n# 連鎖消滅後の得点を計算する\ndef cal_score(c,score,loop):\n    # 消滅\n    nextc = []\n    for j in range(W):\n        num0 = c[j].count(0)\n        tmp = [*filter(lambda x: x>0,c[j])]\n        nextc.append(tmp+[0]*num0)\n\n    # 連鎖\n    res = 0# 追加得点\n    for i in range(H):\n        j = 0\n        while j < W:\n            seq = 1\n            while j<W-1 and nextc[j][i] == nextc[j+1][i] > 0:\n                seq += 1\n                j += 1\n            if seq >= K:\n                res += seq * nextc[j][i]\n                for k in range(j-seq+1,j+1):\n                    nextc[k][i] = 0\n            j += 1\n    if res == 0:\n        return score\n    else:\n        return cal_score(nextc,score+res*pow(2,loop),loop+1)\n    \n\nans = 0\nfor p in range(H):\n    for q in range(W):\n        cc = copy.deepcopy(c)\n        cc[q][p] = 0\n        z = cal_score(cc,0,0)\n        ans = max(ans, z)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "class Puzzle():\n  def __init__(self, mat, h,w,k):\n    self.mat = mat\n    self.h = h\n    self.w = w\n    # self.k = k\n    self.k = min(k, 3)\n    self.score = 0\n\n  def calc(self, t):\n    tmp_score = 0\n\n    for i in range(self.h):\n      for j in range(self.w):\n        if self.mat[i][j] > 0:\n          for k in range(self.w, -1, -1):\n            if k-j >= self.k:\n              s = set(self.mat[i][j:k])\n              if len(s) == 1 and -1 not in s:\n                tmp_score += list(s)[0] * (k-j)\n                for l in range(j, k):\n                  self.mat[i][l] = -1\n            else:\n              break\n\n    if tmp_score == 0:\n      return False\n    else:\n      self.score += pow(2, t) * tmp_score\n      if self.score == 642: import pdb; pdb.set_trace()\n      return True\n\n  def flatten(self):\n    pivot_mat = []\n    for i in range(self.w):\n      row = []\n      for j in range(self.h):\n        if self.mat[j][i] != -1:\n          row.append(self.mat[j][i])\n\n      short = self.h - len(row)\n      if short > 0:\n        row.reverse()\n        for k in range(short):\n          row.append(-1)\n        row.reverse()\n      \n      pivot_mat.append(row)\n\n    mat = [ [-1]*self.w for i in range(self.h) ]\n    for i in range(self.h):\n      for j in range(self.w):\n        mat[i][j] = pivot_mat[j][i]\n\n    self.mat = mat\n\nh,w,k = map(int,input().split())\nmat = []\nfor _ in range(h):\n  mat.append([int(e) for e in list(input())])\n\nres = 0\nfor i in range(h):\n  for j in range(w):\n    old = mat[i][j]\n    mat[i][j] = -1\n    puzzle = Puzzle(mat,h,w,k)\n    puzzle.flatten()\n    time = 0\n    while True:\n      if puzzle.calc(time):\n        puzzle.flatten()\n        time += 1\n      else:\n        break\n    res = max(res, puzzle.score)\n    mat[i][j] = old\n\nprint(res)"
  },
  {
    "language": "Python",
    "code": "def cont(a, K):\n    contL = []\n    j = 1\n    while j < W: \n        cnt = 1\n        while a[j] == a[j-1] and a[j] != None:\n            cnt += 1\n            j += 1\n        if cnt >= K:\n            contL.append((j-cnt, j, a[j-1]))\n        j += 1\n    return contL\n\ndef fall(d):\n    for j in range(W):\n        for k in range(H):\n            if d[k][j] == None:\n                for i in range(k, 0, -1):\n                    d[i][j] = d[i-1][j]\n                d[0][j] = None\n    return d\n\n\nimport copy \n\nH, W, K = map(int, input().split())\nc = [list(map(int, list(input().strip()))) + [0] for _ in range(H)] #; print2(c)\n\ncandL = [(i, j) for i in range(H) for j in range(W)]\n\nans = 0\nfor i_push, j_push in candL:   \n    d = copy.deepcopy(c)    #; print2(d); print()\n    d[i_push][j_push] = None\n    d = fall(d)             #; print2(d)\n    n = -1\n    ans0 = 0\n    while True:\n        flag = False\n        n += 1\n        for i in range(i_push, -1, -1):\n            cL = cont(d[i], K)       #;print(cL)\n            for j0, j1, val in cL:\n                d[i][j0:j1] = [None]*(j1-j0)                \n                ans0 += val *(j1-j0) * 2**(n)  #;print(val, val *(j1-j0) * 2**(n))\n                flag = True\n        if not flag: break\n        #print2(d); print()\n        d = fall(d)          #;print('i_push, j_push', i_push, j_push, ans0) ; print2(d);print() \n    ans = max(ans, ans0)    \nprint(ans)    "
  },
  {
    "language": "Python",
    "code": "import sys\nimport itertools\n# import numpy as np\nimport time\nimport math\nimport heapq\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 7)\n \nINF = 10 ** 9 + 7\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\n# map(int, input().split())\n\nH, W, K = map(int, input().split())\nC = [0] * H\nfor i in range(H):\n    C[i] = list(input())\n\ndef solve(y, x, B):\n    B[y][x] = '.'\n    score = 0\n    step = 0\n    while True:\n        updated = False\n        # drop step\n        for i in range(H - 1, -1, -1):\n            for j in range(W - 1, -1, -1):\n                if B[i][j] != '.':\n                    continue\n                k = i - 1\n                while k >= 0 and B[k][j] == '.':\n                    k -= 1\n                if k >= 0:\n                    B[i][j] = B[k][j]\n                    B[k][j] = '.'\n                    updated = True\n        if not updated:\n            break\n\n        # erase step\n        erased = 0\n        for i in range(H):\n            start = 0\n            while start < W:\n                count = 1\n                if B[i][start] == '.':\n                    start += 1\n                    continue\n                while start + count < W and B[i][start + count] == B[i][start]:\n                    count += 1\n                if count >= K:\n                    erased += count * int(B[i][start])\n                    for k in range(start, start + count):\n                        B[i][k] = '.'\n                start += count\n        score += (2 ** step) * erased\n        step += 1\n    return score\n\nans = 0\nfor i in range(H):\n    for j in range(W):\n        B = [[C[i][j] for j in range(W)] for i in range(H)]\n        ans = max(ans, solve(i, j, B))\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    h, w, k = map(int, raw_input().split())\n    c = [map(int, raw_input().strip()) for _ in xrange(h)]\n    def go(a):\n        for j in xrange(w):\n            st = [a[i][j] for i in xrange(h) if a[i][j]]\n            for i in xrange(h):\n                a[i][j] = 0\n            i = -1\n            for x in reversed(st):\n                a[i][j] = x\n                i -= 1\n        res = 0\n        for i in xrange(h):\n            j = 0\n            while j < w:\n                t = j\n                while t < w and a[i][j] == a[i][t]:\n                    t += 1\n                if t - j >= k:\n                    for j in xrange(j, t):\n                        res += a[i][j]\n                        a[i][j] = 0\n                j = t\n        if not res:\n            return 0\n        return go(a) * 2 + res\n    ans = 0\n    for i in xrange(h):\n        for j in xrange(w):\n            t = [c[ii][:] for ii in xrange(h)]\n            t[i][j] = 0\n            r = go(t)\n            if ans < r:\n                ans = r\n    print ans\nmain()\n"
  },
  {
    "language": "Python",
    "code": "H, W, K = map(int, input().split())\n\ndef clear(row, start, end, mult):\n    if end - start + 1 < K:\n        return 0\n    gain = 0\n    for i in range(start, end + 1):\n        gain += mult * row[i]\n        row[i] = 0\n    return gain\n\ndef drop(board):\n    for x in range(W):\n        wp = 0\n        for y in range(H):\n            if board[y][x] > 0:\n                board[wp][x] = board[y][x]\n                if wp != y:\n                    board[y][x] = 0\n                wp += 1\n\ndef proceed(board, mult):\n    gain = 0\n    for row in board:\n        start = -1\n        num = -1\n        for i in range(W):\n            if row[i] == num:\n                continue\n            else:\n                gain += clear(row, start, i-1, mult)\n                num = row[i]\n                start = i\n        if num > 0:\n            gain += clear(row, start, W-1, mult)\n    drop(board)\n    return gain\n\nboard_ = []\nfor _ in range(H):\n    board_.append(list(map(int, input())))\nboard_.reverse()\n\nans = 0\nfor y in range(H):\n    for x in range(W):\n        board = deepcopy(board_)\n        board[y][x] = 0\n        drop(board)\n        mult = 1\n        cand = 0\n        while True:\n            gain = proceed(board, mult)\n            if gain == 0:\n                break\n            cand += gain\n            mult *= 2\n        ans = max(ans, cand)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nH, W, K = [int(x) for x in input().split()]\nc = [[int(x) for x in list(input())] for _ in range(H)]\nc.reverse()\n\nmax_score = 0\nfor y in range(H):\n    for x in range(W):\n        board = deepcopy(c)\n        board[y][x] = None  # 消す\n        score = 0\n        erased = True\n        coeff = 1\n        while erased:\n            erased = False\n            # 落下させる\n            for i in range(1, H):\n                for j in range(W):\n                    k = i\n                    while k > 0 and board[k - 1][j] == None:\n                        k -= 1\n                    board[k][j], board[i][j] = board[i][j], board[k][j]\n\n            # 消す\n            for i in range(H):\n                cnt = 1\n                num = board[i][0]\n                for j in range(1, W):\n                    if board[i][j] != None and board[i][j] == board[i][j - 1]:\n                        num = board[i][j]\n                        cnt += 1\n                    else:\n                        if cnt >= K:\n                            erased = True\n                            score += coeff * cnt * num\n                            board[i][j - cnt : j] = [None] * cnt\n                        cnt = 1\n                if cnt >= K:\n                    erased = True\n                    score += coeff * cnt * num\n                    board[i][j - cnt + 1 : j + 1] = [None] * cnt\n\n            coeff *= 2\n\n        max_score = max(max_score, score)\n\nprint(max_score)"
  },
  {
    "language": "Python",
    "code": "def ABC120_D():\n    class UnionFind():\n        def __init__(self, n):\n            self.parent = [-1 for _ in range(n)]\n            # 正==子: 根の頂点番号 / 負==根: 連結頂点数\n\n        def find(self, x):\n            # 要素xが属するグループの根を返す\n            if self.parent[x] < 0:\n                return x\n            else:\n                self.parent[x] = self.find(self.parent[x])\n                return self.parent[x]\n\n        def unite(self, x, y):\n            # 要素xが属するグループと要素yが属するグループとを併合する\n            x, y = self.find(x), self.find(y)\n            if x == y:\n                return False\n            else:\n                if self.size(x) < self.size(y):\n                    x, y = y, x\n                self.parent[x] += self.parent[y]\n                self.parent[y] = x\n\n        def same(self, x, y):\n            # 要素x, yが同じグループに属するかどうかを返す\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            # 要素xが属するグループのサイズ（要素数）を返す\n            x = self.find(x)\n            return -self.parent[x]\n\n        def is_root(self, x):\n            # 要素の根をリストで返す\n            return self.parent[x] < 0\n\n        def roots(self):\n            # すべての根の要素をリストで返す\n            return [i for i, x in enumerate(self.parent) if x < 0]\n\n        def members(self, x):\n            # 要素xが属するグループに属する要素をリストで返す\n            root = self.find(x)\n            return [i for i in range(self.n) if self.find(i) == root]\n\n        def group_count(self):\n            # グループの数を返す\n            return len(self.roots())\n\n        def all_group_members(self):\n            # {ルート要素: [そのグループに含まれる要素のリスト], ...}の辞書を返す\n            return {r: self.members(r) for r in self.roots()}\n    N, M = LI()\n    P = [[]for _ in range(M)]\n    for i in range(M):\n        P[i] = LI()\n    uf = UnionFind(N)\n    ans = [N*(N-1)//2]*M\n    for i,[a,b] in enumerate(P[M-1:0:-1]):\n        #print(i,a,b)\n        a -= 1; b -= 1\n        if uf.same(a,b):\n            ans[i+1] = ans[i]\n        else:\n            cur = uf.size(a)*uf.size(b)\n            ans[i+1] = ans[i]-cur\n            uf.unite(a,b)\n    for v in ans[::-1]:\n        print(v)\n    return\n\ndef JOI8_1():\n    N = I()\n    C = [I()for _ in range(N)]\n    prev = C[0]\n    BW = [[1,prev]]\n    for i in range(1,N):\n        #print(BW)\n        if BW[-1][1]==C[i]:\n            BW[-1][0] += 1\n        else:\n            if i%2==0:\n                BW.append([1,C[i]])\n            else:\n                if len(BW) > 1:\n                    BW[-2][0] += (BW[-1][0] + 1)\n                    del BW[-1]\n                else:\n                    BW[0][0] += 1\n                    BW[0][1] = C[i]\n    ans = 0\n    #print(BW)\n    for i,s in BW:\n        if s==0:\n            ans += i\n    print(ans)\n    return\n\"\"\"\n8\n1\n0\n1\n1\n0\n0\n0\n1\n\"\"\"\ndef JOI13_A():\n    N = I()\n    A = LI()\n    S = []\n    cur = 1\n    prev = A[0]\n    for i in range(1,N):\n        if prev^A[i]==1:\n            cur += 1\n        else:\n            S.append(cur)\n            cur = 1\n        prev = A[i]\n    if cur>0:\n        S.append(cur)\n    #print(S)\n    ans = 0\n    for i in range(len(S)-2):\n        cur = S[i]+S[i+1]+S[i+2]\n        if ans<cur:\n            ans = cur\n    if len(S)<=2:\n        ans = N\n    print(ans)\n    return\n\"\"\"\n10 \n1 1 0 0 1 0 1 1 1 0\n\"\"\"\ndef square869120Contest5_B():\n    def length(a,b):\n        return ((a[0]-b[0])**2 + (a[1]-b[1])**2)**0.5\n    def check(r):\n        for i in range(M):\n            for j in range(N):\n                if length(X[i],A[j][0:2])<A[j][2]+r+_ep:\n                    return False\n            for j in range(M):\n                if i==j:\n                    continue\n                if length(X[i],X[j])<r+r+_ep:\n                    return False\n        return True\n    N, M = LI()\n    A = [LI()for _ in range(N)]\n    X = [LI()for _ in range(M)]\n    minA = inf\n    for i,j,a in A:\n        if minA>a:\n            minA = a\n    l = 0; r = 200\n    while(r-l>_ep):\n        now = (l+r)/2\n        if check(now):\n            l = now\n        else:\n            r = now\n    ans = min(l,minA)\n    print(ans)\n    return\n\ndef ABC144_D():\n    a, b, x = LI()\n    half = a*a*b/2\n    if x>=half:\n        y = (half*2-x)/(a*a/2)\n        deg = math.atan2(a,y)\n        #print(y,a,deg)\n        ans = 90-deg*180/math.pi\n    else:\n        y = x/(a*b/2)\n        deg = math.atan2(b,y)\n        ans = deg*180/math.pi\n    print(ans)\n    return\n\ndef square869120Contest3_B():\n    def check_del(S):\n        sco = 0\n        for h in range(H):\n            for w in range(W-K+1):\n                s = S[h][w]\n                if s==0:\n                    continue\n                if K==3 and s==S[h][w+1] and s==S[h][w+2]:\n                    d = 3\n                    for k in range(W-K+1-w):\n                        if S[h][w]!=S[h][w+2+k]:\n                            break\n                        d += 1\n                    t = S[h][w]\n                    sco += cal_score(t,d)\n                    del_stone(S,h,w,d)\n                elif K==2 and s==S[h][w+1]:\n                    d = 2\n                    for k in range(W-K-w):\n                        if S[h][w]!=S[h][w+2+k]:\n                            break\n                        d += 1\n                    t = S[h][w]\n                    sco += cal_score(t,d)\n                    del_stone(S,h,w,d)\n        return sco,S\n    def del_stone(S,y,x,k):\n        for i in range(k):\n            S[y][x+i] = 0\n        return S\n    def cal_score(t,c):\n        return (2**now)*(t*c)\n    def move_stone(S):\n        rep = deepcopy(S)\n        for w in range(W):\n            blank = -1\n            que = deque()\n            for h in range(H)[::-1]:\n                if rep[h][w]==0:\n                    if blank==-1:\n                        blank = h\n                else:\n                    if blank>=0:\n                        que.append(rep[h][w])\n                        rep[h][w] = 0\n            if blank==-1:\n                continue\n            for h,i in enumerate(que):\n                rep[blank-h][w] = i\n        return rep\n    H, W, K = LI()\n    A = [SI()for _ in range(H)]\n    C = [[]for _ in range(H)]\n    for h in range(H):\n        for w in range(W):\n            C[h].append(int(A[h][w]))\n    if K>=4:\n        print(0)\n        return\n    ans = 0\n    if K==1:\n        for c in C:\n            ans += sum(c)\n        print(ans)\n        return\n    for h in range(H):\n        for w in range(W):\n            nowC = deepcopy(C)\n            nowC[h][w] = 0\n            #print(nowC)\n            cur = 0\n            now = 0\n            while(True):\n                nowC = move_stone(nowC)\n                #print(nowC)\n                rep,nowC = check_del(nowC)\n                #print(nowC)\n                #print()\n                if rep==0:\n                    break\n                cur += rep\n                now += 1\n            #print(h,w,cur)\n            if ans<cur:\n                ans = cur\n    print(ans)\n    return\n\nimport sys,bisect,itertools,heapq,math,random\nfrom copy import deepcopy\nfrom heapq import heappop,heappush,heapify\nfrom collections import Counter,defaultdict,deque\n\ndef I(): return int(sys.stdin.readline())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef SI(): return sys.stdin.readline().strip()\nglobal mod,mod2,inf,alphabet,_ep\nmod = 10**9 + 7\nmod2 = 998244353\ninf = 10**18\n_ep = 10**(-12)\nalphabet = [chr(ord('a') + i) for i in range(26)]\n\nsys.setrecursionlimit(10**6)\n\nif __name__ == '__main__':\n    square869120Contest3_B()\n\"\"\"\n\n\"\"\"\n"
  },
  {
    "language": "Python",
    "code": "H,W,K = list(map(int,input().split()))\nC = [list(input()) for _ in range(H)]\n\ndef F1(c):\n    for i in range(W):\n        for j in range(H-1,-1,-1):\n            if c[j][i] != 'X': continue\n            for k in range(j-1,-1,-1):\n                if c[k][i] != 'X':\n                    c[j][i], c[k][i] = c[k][i], c[j][i]\n                    break\n    return c\n\ndef F2(c):\n    delete_sum = 0\n    for i in range(H):\n        for j in range(W):\n            if c[i][j] == 'X': continue\n            tmp = c[i][j]\n            count = 1\n            for k in range(j+1,W):\n                if c[i][k] == tmp:\n                    count += 1\n                else:\n                    break\n            if count >= K:\n                for k in range(j,W):\n                    if c[i][k] == tmp:\n                        delete_sum += int(c[i][k])\n                        c[i][k] = 'X'\n                    else:\n                        break\n    return c, delete_sum\n\nMAX = 0\nfor i in range(H):\n    for j in range(W):\n        tmpC = []\n        for k in range(H):\n            tmpC.append(C[k][:])\n        tmpC[i][j] = 'X'\n        tmpC = F1(tmpC)\n        point = 0\n        for k in range(1000):\n            tmpC, delete_sum = F2(tmpC)\n            if delete_sum == 0:\n                break\n            tmpC = F1(tmpC)\n            point += 2**k*delete_sum\n        MAX = max(MAX,point)\nprint(MAX)\n"
  },
  {
    "language": "Python",
    "code": "\nclass Game:\n    def __init__(self, mp, h, w, k):\n        self.mp = mp\n        self.H = h\n        self.W = w\n\n        self.K = k\n        self.score = 0\n        self.erase_flag = False\n        self.cnt = 0\n        \n    def erase(self):\n        tot = 0\n        for y in range(self.H):\n            line = self.mp[y]\n            new_line, add_score = self.fix(line)\n            self.mp[y] = new_line\n            tot += add_score\n            if add_score != 0:\n                self.erase_flag = True\n        if self.erase_flag:\n            self.score += tot*pow(2, self.cnt)\n            self.cnt += 1\n    \n    def fix(self, line):\n        add_score = 0\n        new_line = line\n        for length in range(self.W, self.K-1, -1):\n            for left in range(self.W - length+1):\n                if all(map(lambda x:x==new_line[left], new_line[left:left+length])):\n                    add_score += new_line[left]*length\n                    new_line = new_line[:left] + [0]*length + new_line[left+length:]\n                    # 最後の要素まで見たか？\n                    # if self.W == left+length:\n                    #     return new_line, add_score\n        return new_line, add_score\n    \n    def fall(self):\n        for x in range(self.W):\n            col = []\n            for y in range(self.H):\n                if self.mp[y][x] != 0:\n                    col.append(self.mp[y][x])\n            col = [0]*(self.H - len(col)) + col\n            for y in range(self.H):\n                self.mp[y][x] = col[y]\n\n    def run(self):\n        while True:\n            self.erase_flag = False\n            self.erase()\n            if not self.erase_flag:\n                break\n            self.fall()\n\nimport copy\ndef resolve():\n    def init_fall(grid, cell):\n        col = []\n        for y in range(H):\n            if grid[y][cell] != 0:\n                col.append(grid[y][cell])\n        col = [0] * (H - len(col)) + col\n        for y in range(H):\n            grid[y][cell] = col[y]\n        return grid\n\n    H, W, K = map(int, input().split())\n    mp = [list(map(int, input())) for _ in range(H)]\n\n    ans = 0\n    for i in range(1,H):\n        for j in range(W):\n            mp_copy = copy.deepcopy(mp)\n            mp_copy[i][j] = 0\n            mp_copy = init_fall(mp_copy,j)\n            game = Game(mp_copy, H, W, K)\n            game.run()\n            ans = max(ans, game.score)\n    print(ans)\n\nif __name__ == \"__main__\":\n    resolve()"
  },
  {
    "language": "Python",
    "code": "H, W, K = map(int, input().split())\nHW = [list(map(int, list(input()))) for _ in range(H)]\n\ndef blocks(hw):\n    score = 0\n    blank = -1\n    flg = True\n    delcnt = 0\n    while flg:\n        flg = False\n        for h in range(H):\n            cnt = 1\n            old = hw[h][:]\n            for w in range(1, W):\n                if hw[h][w-1]==hw[h][w]:\n                    cnt+=1\n                    flg = True\n                else:\n                    if cnt>=K:\n                        score += 2**delcnt*cnt*hw[h][w-1]\n                        for k in range(1, cnt+1):\n                            hw[h][w-k] = blank\n                            blank -= 1\n                    cnt = 1\n            if cnt>=K:\n                score += 2**delcnt*cnt*hw[h][W-1]\n                for k in range(1, cnt+1):\n                    hw[h][W-k] = blank\n                    blank -= 1\n        fall_flg = True\n        while fall_flg:\n            fall_flg = False\n            for h in range(H-1, 0, -1):\n                for w in range(W):\n                    if hw[h-1][w]>0 and hw[h][w]<=0:\n                        hw[h][w] = hw[h-1][w]\n                        hw[h-1][w] = blank\n                        blank -= 1\n                        fall_flg = True\n        delcnt += 1\n    return score\nimport copy\nans = []\nfor h in range(1, H):\n    for w in range(W):\n        hw = copy.deepcopy(HW)\n        for i in range(H-h, 0, -1):\n            hw[i][w] = hw[i-1][w]\n        hw[0][w] = 0\n        ans.append(blocks(hw))\nprint(max(ans))"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\ndef main():\n    import copy\n    h,w,K = map(int, input().split())\n    c = [[] for _ in range(w)]\n    for i in range(h):\n        a = input()\n        for j in range(w):\n            c[j].append(a[j])\n    #print(c)\n    ans = 0\n    for i in range(h):\n        for j in range(w):\n            C = copy.deepcopy(c)\n            C[j].pop(i)\n            ren = 0\n            point = 0\n            while True:\n                cnt = 0\n                for k in range(30,0,-1):\n                    #print(k)\n                    start = 0\n                    while start <= w-K:\n                        if (len(C[start]) < k):\n                            start += 1\n                            continue\n                        num = C[start][-k]\n                        end = start\n                        while True:\n                            #print(C,k,start,end)\n                            if (end<w-1 and len(C[end+1])>=k and C[end+1][-k]==num):\n                                end += 1\n                            else:\n                                break\n                        if (end+1-start >= K):\n                            point += (end+1-start)*int(C[start][-k])*(2**ren)\n                            for p in range(start,end+1):\n                                #print(C,p,k,start,end,point)\n                                C[p].pop(-k)\n                                cnt += 1\n                        start = end + 1\n                if (cnt == 0):\n                    break\n                ren += 1\n            if (point > ans):\n                ans = point\n    print(ans)\n    \nif __name__==\"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nH, W, K = map(int, input().split())\n\ndef clear(row, start, end, mult):\n    if end - start + 1 < K:\n        return 0\n    gain = 0\n    for i in range(start, end + 1):\n        gain += mult * row[i]\n        row[i] = 0\n    return gain\n\ndef drop(board):\n    for x in range(W):\n        wp = 0\n        for y in range(H):\n            if board[y][x] > 0:\n                board[wp][x] = board[y][x]\n                if wp != y:\n                    board[y][x] = 0\n                wp += 1\n\ndef proceed(board, mult):\n    gain = 0\n    for row in board:\n        start = -1\n        num = -1\n        for i in range(W):\n            if row[i] == num:\n                continue\n            else:\n                gain += clear(row, start, i-1, mult)\n                num = row[i]\n                start = i\n        if num > 0:\n            gain += clear(row, start, W-1, mult)\n    drop(board)\n    return gain\n\nboard_ = []\nfor _ in range(H):\n    board_.append(list(map(int, input())))\nboard_.reverse()\n\nans = 0\nfor y in range(H):\n    for x in range(W):\n        board = deepcopy(board_)\n        board[y][x] = 0\n        drop(board)\n        mult = 1\n        cand = 0\n        while True:\n            gain = proceed(board, mult)\n            if gain == 0:\n                break\n            cand += gain\n            mult *= 2\n        ans = max(ans, cand)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import copy\nh, w, k = map(int, input().split())\na = [[] for j in range(h)]\nfor i in range(h):\n    a[i] = [int(i) for i in input()]\nans = 0\nfor p in range(h):\n    for q in range(w):\n        cand = 0\n        b = copy.deepcopy(a)\n        b[p][q] = 0\n        disap = True\n        fall = True\n        disapnum = 0\n        while(disap):\n            disap=False\n            cur = 0\n            for i in range(h):\n                suc = 1\n                for j in range(w-1):\n                    if b[i][j] == b[i][j+1]:\n                        suc += 1\n                    else:\n                        if suc >= k:\n                            if b[i][j]:\n                                disap=True\n                                fall=True\n                                cur += b[i][j]*suc\n                            for m in range(j+1-suc, j+1):\n                                b[i][m] = 0\n                        suc = 1\n                if suc >= k:\n                    if b[i][w-1]:\n                        disap=True\n                        fall=True\n                        cur += b[i][w-1]*suc\n                    for m in range(w-suc, w):\n                        b[i][m] = 0\n            if disap:\n                cand += cur*(2**disapnum)\n                disapnum += 1\n            while(fall):\n                fall=False\n                for i in range(1, h):\n                    for j in range(w):\n                        if b[i][j] == 0 and b[i-1][j]:\n                            b[i][j], b[i-1][j] = b[i-1][j], b[i][j]\n                            fall = True\n                            disap = True\n        ans = max(cand, ans)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\n\nH, W, K = map(int, input().split())\nX = [list(map(int, list(input()))) for _ in range(H)]\n\n\ndef gen_mask(idx=None):\n    mask = [[True] * W for _ in range(H)]\n    if idx is not None:\n        i, j = idx\n        mask[i][j] = False\n        return mask\n    \n    # Erase mask\n    for i in range(H):\n        for j in range(W):\n            tmp = [False] * W\n            for k in range(j, W):\n                if X_tmp[i][j] == X_tmp[i][k]:\n                    tmp[k] = True\n                else:\n                    break\n            if sum(tmp) >= K:\n                mask[i] = [not v for v in tmp]\n                break\n    return mask\n\n\ndef erase(mask):\n    new = [[0] * W for _ in range(H)]\n    res = 0\n    for j in range(W):\n        idx = H - 1\n        for i in reversed(range(H)):\n            if mask[i][j]:\n                new[idx][j] = X_tmp[i][j]\n                idx -= 1\n            else:\n                res += X_tmp[i][j]\n\n    return new, res\n\nans = 0\nfor i in range(H):\n    for j in range(W):\n        X_tmp = deepcopy(X)\n        mask = gen_mask((i, j))\n        res = 0\n\n        for k in range(-1, 1000):\n            X_tmp, tmp = erase(mask)\n            if tmp == 0:\n                break\n\n            mask = gen_mask()        \n            if k >= 0:\n                res += 2 ** k * tmp\n\n        ans = max(ans, res)\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nh,w,k=map(int,input().split())\ngrid=[list(input()) for _ in range(h)]\ndef score(t):\n  total=0\n  for i in range(1,h):\n    for j in range(w-1):\n      cnt=1\n      ten=int(gc[i][j])\n      while gc[i][j+1]==gc[i][j]:\n        cnt+=1\n        j+=1\n        if j==w-1:\n          break\n      if cnt>=k:\n        total+=2**t*(ten*cnt)\n        gc[i][j-cnt+1:j+1]=['0']*cnt\n  return total\ndef upd():\n  while 1:\n    ok=True\n    for i in range(1,h):\n      for j in range(w):\n        if gc[i][j]=='0' and gc[i-1][j]!='0':\n          x=gc[i-1][j]\n          gc[i-1][j]='0'\n          gc[i][j]=x\n          ok=False\n    if ok:\n      return\nans=0\nfor i in range(1,h):\n  for j in range(w):\n    gc=deepcopy(grid)\n    gc[i][j]='0'\n    t=0\n    res=0\n    while 1:\n      upd()\n      total=score(t)\n      if total==0:\n        break\n      t+=1\n      res+=total\n    ans=max(ans,res)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nfrom copy import deepcopy\n\ndef input(): return sys.stdin.readline().strip()\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\nH,W,K=MAP()\norgn=[[0]*W for i in range(H)]\nfor i in range(H):\n    nums=input()\n    for j in range(W):\n        orgn[i][j]=int(nums[j])\n\n# ブロックが落ちる動き\ndef drop():\n    for i in range(H-1, 0, -1):\n        for j in range(W):\n            if grid[i][j]==0 and grid[i-1][j]!=0:\n                k=i\n                while k<H and grid[k][j]==0:     \n                    grid[k][j]=grid[k-1][j]\n                    grid[k-1][j]=0\n                    k+=1\n\n# 揃ったところを消して合計を計算\ndef check(times):\n    sm=0\n    for i in range(H):\n        st=0\n        cnt=1\n        for j in range(1, W):\n            if grid[i][j-1]==grid[i][j]:\n                cnt+=1\n            else:\n                if cnt>=K:\n                    sm+=grid[i][j-1]*cnt\n                    for k in range(st, j):\n                        grid[i][k]=0\n                cnt=1\n                st=j\n        else:\n            if cnt>=K:\n                sm+=grid[i][j]*cnt\n                for k in range(st, j+1):\n                    grid[i][k]=0\n    return 2**times*sm\n\nans=0\nfor i in range(H):\n    for j in range(W):\n        # 元の状態は保持しておいて、全部試す\n        grid=deepcopy(orgn)\n        grid[i][j]=0    \n        res=1\n        score=times=0\n        # 消えるところがある限りループ\n        while res:\n            drop()\n            res=check(times)\n            score+=res\n            times+=1\n        ans=max(ans, score)\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy as cp\n\nH,W,K = map(int,input().split())\nsrc = [input() for i in range(H)]\n\npanels = []\nfor cols in zip(*src):\n    panels.append(list(reversed(cols)))\n\nans = 0\nfor r0 in range(H):\n    for c0 in range(W):\n        ps = cp(panels)\n        del ps[c0][r0]\n        tmp = 0\n        bonus = 1\n        chaining = True\n        while chaining:\n            chaining = False\n            for r in reversed(range(H)):\n                seq = 0\n                prev = None\n                for c in range(W):\n                    if r >= len(ps[c]) or (prev and prev != ps[c][r]) or c == 0:\n                        if seq >= K:\n                            tmp += bonus * seq * int(prev)\n                            chaining = True\n                            for i in range(seq):\n                                del ps[c-i-1][r]\n                        if r >= len(ps[c]):\n                            seq,prev = 0,None\n                        else:\n                            seq,prev = 1,ps[c][r]\n                    elif prev:\n                        seq += 1\n                    else:\n                        prev = ps[c][r]\n                if seq >= K:\n                    tmp += bonus * seq * int(prev)\n                    chaining = True\n                    for i in range(seq):\n                        del ps[W-i-1][r]\n            bonus *= 2\n        ans = max(ans, tmp)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "h, w, k  = map(int, input().split())\n\npuyo_orig = [list(map(int, list(input()))) for _ in range(h)]\n\nimport copy\nmx = 0\nfor i1 in range(1,h):\n    for i2 in range(w):\n        puyo = copy.deepcopy(puyo_orig)\n        for l in range(i1,0,-1):\n            puyo[l][i2] = puyo[l-1][i2]\n        puyo[0][i2]=0\n        p = 0\n        fin = 0\n        turn = 0\n        while fin==0:\n            fin = 1\n            for i in range(1,h):\n                cnt = 1\n                for j in range(1, w):\n                    if puyo[i][j-1] == puyo[i][j] and puyo[i][j]>0:\n                        cnt += 1\n                    else:\n                        if cnt>=k:\n                            p += cnt * puyo[i][j-1] * 2**turn\n                            for l in range(i,0,-1):\n                                puyo[l][j-cnt:j] = puyo[l-1][j-cnt:j]\n                            puyo[0][j-cnt:j] = [0]*cnt\n                            fin = 0\n                        cnt = 1\n                    if j==w-1:\n                        if cnt>=k:\n                            p += cnt * puyo[i][j-1] * 2**turn\n                            for l in range(i,0,-1):\n                                puyo[l][j-cnt+1:j+1] = puyo[l-1][j-cnt+1:j+1]\n                            puyo[0][j-cnt+1:j+1] = [0]*cnt\n                            fin = 0\n            turn += 1\n        if p>mx:\n            mx=p\n            \nprint(mx)\n"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nh,w,n = (int(i) for i in input().split())\nc1,ans = [[] for i in range(w)],0\nfor i in range(h):\n\ts = input()\n\tfor j in range(w): c1[j].append(int(s[j]))\nif n<4:\n\tif h==30: z = 25\n\telse: z = h//2\n\tfor i in range(z,h):\n\t\tfor j in range(w):\n\t\t\tc,m,a = deepcopy(c1),0,0\n\t\t\tdel c[j][i]\n\t\t\tc[j].insert(0,0)\n\t\t\twhile 1:\n\t\t\t\td = []\n\t\t\t\tfor k in range(i-h,-h,-1):\n\t\t\t\t\tk2 = 0\n\t\t\t\t\twhile k2<w-n+1:\n\t\t\t\t\t\tif c[k2][k] and all(c[k2][k]==c[k2+k3][k] for k3 in range(1,n)):\n\t\t\t\t\t\t\tb = n\n\t\t\t\t\t\t\tfor k3 in range(k2+n,w):\n\t\t\t\t\t\t\t\tif c[k2][k]==c[k3][k]: b+=1\n\t\t\t\t\t\t\t\telse: break\n\t\t\t\t\t\t\td.append((h+k,k2,b))\n\t\t\t\t\t\t\tk2+=b\n\t\t\t\t\t\telse: k2+=1\n\t\t\t\tif d:\n\t\t\t\t\tfor k,k2,k3 in d:\n\t\t\t\t\t\ta+=(2**m)*c[k2][k]*k3\n\t\t\t\t\t\tfor k4 in range(k2,k2+k3): del c[k4][k]\n\t\t\t\t\tfor k,k2,k3 in d:\n\t\t\t\t\t\tfor k4 in range(k2,k2+k3): c[k4].insert(0,0)\n\t\t\t\telse: break\n\t\t\t\tm+=1\n\t\t\tans = max(ans,a)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1193&lang=jp\n\nimport sys\ninput=sys.stdin.readline\nfrom collections import deque\nfrom copy import deepcopy\n\ndef main():\n    H,W,K=map(int,input().split())\n    mas=[[-1]*W for i in range(H)]\n    for i in range(H):\n        t=input()\n        for j in range(W):\n            mas[H-1-i][j]=int(t[j])\n    maso=deepcopy(mas)\n    maxans=0       \n    for h in range(H):\n        for w in range(W):\n            mas=deepcopy(maso)\n            mas[h][w]=-1\n            for hh in range(h,H-1):\n                t=mas[hh][w]\n                mas[hh][w]=mas[hh+1][w]\n                mas[hh+1][w]=t\n            \n            ans=0\n            nankaime=0\n            while(1):\n                kiesum=0\n                mast=deepcopy(mas)\n                for i in range(H):\n                    for j in range(W):\n                        cnt=1\n                        for k in range(j+1,W):\n                            if mas[i][j]!=-1 and mas[i][k]!=-1 and mas[i][j]==mas[i][k]:\n                                cnt+=1\n                            else:\n                                break\n                        if cnt>=K:\n                            for k in range(cnt):\n                                kiesum+=mas[i][j+k]\n                                mas[i][j+k]=-1\n                            break\n                f=[deque() for i in range(W)]\n                for j in range(W):\n                    for i in range(H):\n                        if mas[i][j]!=-1:\n                            f[j].append(mas[i][j])\n                    for i in range(H-len(f[j])):\n                        f[j].append(-1)\n                for i in range(H):\n                    for j in range(W):\n                        mas[i][j]=f[j].popleft()\n                ans+=(2**nankaime)*kiesum\n                nankaime+=1\n                if mas==mast:\n                    break\n            maxans=max(maxans,ans)\n    print(maxans)\n                    \n                    \n                \n    \nif __name__==\"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nfrom collections import deque\nh,w,n = (int(i) for i in input().split())\nc1,ans = [deque([]) for i in range(w)],0\nfor i in range(h):\n\ts = input()\n\tfor j in range(w): c1[j].append(int(s[j]))\nif 1<n<4:\n\tfor i in range(1,h):\n\t\tfor j in range(w):\n\t\t\tc,m,a = deepcopy(c1),0,0\n\t\t\tdel c[j][i]\n\t\t\tc[j].appendleft(0)\n\t\t\twhile 1:\n\t\t\t\td = []\n\t\t\t\tfor k in range(i-h,-h,-1):\n\t\t\t\t\tk2 = 0\n\t\t\t\t\twhile k2<w-n+1:\n\t\t\t\t\t\tif c[k2][k] and all(c[k2][k]==c[k2+k3][k] for k3 in range(1,n)):\n\t\t\t\t\t\t\tb = n\n\t\t\t\t\t\t\tfor k3 in range(k2+n,w):\n\t\t\t\t\t\t\t\tif c[k2][k]==c[k3][k]: b+=1\n\t\t\t\t\t\t\t\telse: break\n\t\t\t\t\t\t\td.append((h+k,k2,b))\n\t\t\t\t\t\t\tk2+=b\n\t\t\t\t\t\telse: k2+=1\n\t\t\t\tif d:\n\t\t\t\t\tfor k,k2,k3 in d:\n\t\t\t\t\t\ta+=(2**m)*c[k2][k]*k3\n\t\t\t\t\t\tfor k4 in range(k2,k2+k3): del c[k4][k]\n\t\t\t\t\tfor k,k2,k3 in d:\n\t\t\t\t\t\tfor k4 in range(k2,k2+k3): c[k4].appendleft(0)\n\t\t\t\telse: break\n\t\t\t\tm+=1\n\t\t\tans = max(ans,a)\nelif n==1:\n\tm = 10\n\tfor i in c1: m,ans = min(min(i),m),ans+sum(i)\n\tans-=m\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nH,W,K = map(int,readline().split())\nS = np.array([list(line.rstrip()) for line in readlines()]).astype(np.int8) - ord('0')\n\n# 下から上の順に\nS = S[::-1].T\n\ndef drop(S):\n    for i in range(W):\n        col = S[i]\n        S[i] = drop_col(col)\n\ndef drop_col(col):\n    x = np.zeros(H,np.int8)\n    nonzero = col[col != 0]\n    x[:len(nonzero)] = nonzero\n    return x\n\ndef cnt_connection(S):\n    # 横につながっている個数\n    x = np.ones_like(S)\n    equal = (S[:-1] == S[1:])\n    for i in range(1,W):\n        x[i] = x[i-1] * equal[i-1] + 1\n    for i in range(W-2,-1,-1):\n        x[i][equal[i]] = x[i+1][equal[i]]\n    return x\n\ndef simulate(S,turn):\n    # 落とす -> 消去、で1セット\n    drop(S)\n    conn = cnt_connection(S)\n    remove = (conn >= K)\n    before = S.sum()\n    S *= (~remove)\n    after = S.sum()\n    if before == after:\n        # 消えなかった\n        return 0\n    else:\n        x = simulate(S,turn+1)\n        return x + ((before - after) << turn)\n\ndef calc(i,j):\n    T = S.copy()\n    T[j,i] = 0\n    return simulate(T,0)\n\nanswer = max(calc(i,j) for i in range(H) for j in range(W))\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom copy import deepcopy\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\n\n\ndef drop(H, W, G):\n    for i in range(1, H):\n        for j in range(W):\n            if G[i][j] == 0 and G[i - 1][j] != 0:\n                k = i\n                for k in range(i, 0, -1):\n                    if G[k][j] != 0:\n                        break\n                    G[k][j], G[k - 1][j] = G[k - 1][j], 0\n\n\ndef main():\n    H, W, K = map(int, readline().split())\n    G_init = [list(map(int, readline().strip())) for _ in range(H)]\n\n    ans = 0\n    for i in range(H):\n        for j in range(W):\n            G = deepcopy(G_init)\n            G[i][j] = 0\n            drop(H, W, G)\n\n            current_ans = 0\n            scale = 1\n            while True:\n                score = 0\n                for row in G:\n                    cnt = 1\n                    for k in range(1, W):\n                        if row[k] == row[k - 1]:\n                            cnt += 1\n                        else:\n                            if cnt >= K and row[k - 1] != 0:\n                                score += row[k - 1] * cnt\n                                row[k - cnt : k] = [0] * cnt\n                            cnt = 1\n                    if cnt >= K and row[W - 1] != 0:\n                        score += row[W - 1] * cnt\n                        row[W - cnt : W] = [0] * cnt\n\n                if score == 0:\n                    break\n\n                current_ans += score * scale\n                scale *= 2\n                drop(H, W, G)\n\n            if current_ans > ans:\n                ans = current_ans\n\n    print(ans)\n    return\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "from sys import setrecursionlimit, exit\nsetrecursionlimit(1000000000)\n\nfrom heapq import heapify, heappush, heappop, heappushpop, heapreplace\nfrom bisect import bisect_left, bisect_right\n\nfrom math import atan, degrees\n\nh, w, k = map(int, input().split())\nori = [list(map(int, list(input()))) for _ in range(h)]\nori.reverse()\nans = 0\nfor x in range(w):\n    for y in range(h - 1):\n        data = [[ori[i][j] for j in range(w)] for i in range(h)]\n        for i in range(y, h - 1):\n            data[i][x] = data[i+1][x]\n        data[h-1][x] = 0\n        score = 0\n        lc = 1\n        nxt = True\n        while nxt:\n            nxt = False\n            for i in range(h):\n                c = 1\n                for j in range(1, w):\n                    if data[i][j] != 0 and data[i][j] == data[i][j-1]:\n                        c += 1\n                    else:\n                        if c >= k:\n                            nxt = True\n                            score += data[i][j-1] * c * lc\n                            for l in range(j - c, j):\n                                data[i][l] = 0\n                        c = 1\n                if c >= k:\n                    nxt = True\n                    score += data[i][w-1] * c * lc\n                    for l in range(w - c, w):\n                        data[i][l] = 0\n            for j in range(w):\n                z = 0\n                for i in range(h):\n                    if data[i][j] == 0:\n                        z += 1\n                    elif z > 0:\n                        data[i-z][j] = data[i][j]\n                        data[i][j] = 0\n            lc *= 2\n        ans = max(ans, score)\n        if score == 0:\n            break\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import copy\nH,W,K = map(int,input().split())\nA = [list(map(int,list(input()))) for _ in range(H)]\nscrmax = 0\nfor i in range(1,H):\n    for j in range(W):\n        cnt = 0\n        scr = 0\n        B = copy.deepcopy(A)\n        B[i][j] = 0\n        for k in range(i,0,-1):\n            B[k][j] = B[k-1][j]\n            B[k-1][j] = 0\n        while True:\n            flg = 0\n            for i1 in range(H):\n                flg1 = 0\n                for m in range(W,K-1,-1):\n                    for j1 in range(W-m+1):\n                        if B[i1][j1]>0 and B[i1][j1:j1+m]==[B[i1][j1] for _ in range(m)]:\n                            scr += 2**cnt*(B[i1][j1]*m)\n                            flg = 1\n                            flg1 = 1\n                            B[i1][j1:j1+m] = [0 for _ in range(m)]\n                            for j2 in range(j1,j1+m):\n                                for k in range(i1,0,-1):\n                                    B[k][j2] = B[k-1][j2]\n                                    B[k-1][j2] = 0\n                            break\n                    if flg1==1:break\n            if flg==0:break\n            cnt += 1\n        scrmax = max(scrmax,scr)     \nprint(scrmax)"
  },
  {
    "language": "Python",
    "code": "from itertools import groupby\ndef calc():\n  s = 0\n  for i in range(h):\n    gr = groupby(g[i])\n    j = 0\n    for key,it in gr:\n      l = len(list(it))\n      if key!=-1:\n        if l >= K:\n          g[i][j:j+l] = [-1]*l\n          # for k in range(l):\n          #   g[i][j+k] = -1\n          s += key*l\n      j += l\n \n  return s\n\ndef flatten():\n  for j in range(w):\n    lst = []\n    for i in range(h-1, -1, -1):\n      if g[i][j] > 0:\n        lst.append(g[i][j])\n\n    lst += [-1] * (h - len(lst))\n\n    for i in range(h-1, -1, -1):\n      g[i][j] = lst[h-i-1]\n\nh,w,K = map(int,input().split())\nmat = [ [int(e) for e in list(input())] for _ in range(h) ]\n\nres = 0\nfor i in range(h):\n  for j in range(w):\n    score = 0\n    g = [ [ mat[n][m] for m in range(w) ] for n in range(h) ]\n    g[i][j] = -1\n    time = 0\n    flatten()\n    while True:\n      s = calc()\n      if s==0: break\n      score += (2**time)*s\n      flatten()\n      time += 1\n    res = max(res, score)\n\nprint(res)\n"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/env python3\n\ndef dropcell():\n    for i in range(W):\n        y = 0\n        for j in range(H):\n            a = gm[H-j-1][i]\n            if a != 0:\n                gm[H-y-1][i] = a\n                y += 1\n\ndef removecell():\n    global gp, gf\n    gf = False\n    p = 0\n    for y in range(H):\n        c = 1\n        t = 0\n        for i in range(W+1):\n            x = gm[y][i]\n            if x > 0 and x == t:\n                c += 1\n            else:\n                if c >= K:\n                    for j in range(c):\n                        gm[y][i-1-j] = 0\n                    p += (t * c)\n                    gf = True\n                t = x\n                c = 1\n    gp += p * (2**gi)\n\nH, W, K = map(int, input().split())\nM = [list(map(int, list(input())))+[0] for i in range(H)]\npoints = {}\nfor i in range(H):\n    for j in range(W):\n        gp = 0\n        gf = True\n        gi = 0\n        gm = [[j for j in i]for i in M]\n        gm[i][j] = 0\n        while gf:\n            dropcell()\n            removecell()\n            gi += 1\n        points[gp] = 1\nprint(min(max(points), 1000000000))"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nH, W, K = map(int, input().split())\nboard = [[0]*W for _ in range(H+1)]\nfor i in range(1,H+1):\n    board[i] = list(map(int, list(input())))\ndef drop(board):\n    change = True\n    score = 0\n    p = 0\n    while change==True:\n        change = False\n        for i in range(1,H+1):\n            ser = 1\n            for j in range(W-1):\n                if board[i][j]==0:\n                    ser = 1\n                    continue\n                if board[i][j]>0 and board[i][j]==board[i][j+1]:\n                    ser += 1\n                elif ser>=K:\n                    score += 2**p*sum(board[i][j-ser+1:j+1])\n                    change = True\n                    for k in range(i,0,-1):\n                        board[k][j-ser+1:j+1] = board[k-1][j-ser+1:j+1]\n                    ser = 1\n            if ser>=K:\n                score += 2**p*sum(board[i][-ser:])\n                change = True\n                for k in range(i,0,-1):\n                    board[k][-ser:] = board[k-1][-ser:]\n        p += 1\n    return score\nans = 0\nfor h in range(1,H+1):\n    for w in range(W):\n        board_copy = deepcopy(board)\n        for k in range(h,0,-1):\n            board_copy[k][w] = board_copy[k-1][w]\n        ans = max(ans,drop(board_copy))\nprint(ans)\n        \n            \n            \n                \n\n"
  },
  {
    "language": "Python",
    "code": "import sys, itertools, copy\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = 10**20\ndef I(): return int(input())\ndef F(): return float(input())\ndef S(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LS(): return input().split()\n\ndef resolve():\n    H, W, K = LI()\n    c = [[int(i) for i in S()] for _ in range(H)]\n\n    ans = 0\n    for i, j in itertools.product(range(H), range(W)):\n        c_tmp = copy.deepcopy(c)\n        c_tmp[i][j] = 0\n        score = 0\n        chain_cnt = 0\n        while True:\n            # 落下処理\n            # その石がどれだけ落下するかの算出\n            drop = [[0]*W for _ in range(H)]\n            for k in range(W):\n                for l in range(H-1):\n                    drop[H-l-2][k] = drop[H-l-1][k] + (1 if c_tmp[H-l-1][k]==0 else 0)\n            # print('drop')\n            # for i in drop:\n            #     print(i)\n            \n            # 落下先にコピー\n            for k in range(W):\n                for l in range(H):\n                    if drop[H-l-1][k]!=0:\n                        c_tmp[H-l-1+drop[H-l-1][k]][k] = c_tmp[H-l-1][k]\n                        c_tmp[H-l-1][k] = 0\n            # print('dropped s')\n            # for i in c_tmp:\n            #     print(i)\n\n            # 消滅判定\n            num_sum = 0\n            for k in range(H):\n                prev = 0\n                cnt = 1\n                for l in range(W):\n                    if c_tmp[k][l]==prev:\n                        cnt += 1\n                    else:\n                        if cnt>=K:\n                            num_sum += prev*cnt\n                            for m in range(cnt):\n                                c_tmp[k][l-cnt+m] = 0\n                        prev = c_tmp[k][l]\n                        cnt = 1\n                if cnt>=K:\n                    num_sum += prev*cnt\n                    for m in range(cnt):\n                        c_tmp[k][l+1-cnt+m] = 0\n            # print('s')\n            # for i in s:\n            #     print(i)\n            if num_sum==0:\n                break\n            score += (2**chain_cnt) * num_sum\n            chain_cnt += 1\n        ans = max(score, ans)\n\n    print(ans)\n\nif __name__ == '__main__':\n    resolve()"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nH, W, K = map(int, input().split())\nB = [list(map(int, input()[:-1])) for _ in [0]*H]\n\n\ndef calc(S):\n    gain = 0\n    for line in S:\n        gain += clear(line)\n    remove(S)\n    return gain\n\n\ndef clear(line):\n    gain = 0\n    cnt = 0\n    pre = line[0]\n    for i, c in enumerate(line):\n        if pre == c:\n            cnt += 1\n        else:\n            if cnt >= K:\n                gain += line[i-1]*cnt\n                for k in range(i-cnt, i):\n                    line[k] = 0\n            cnt = 1\n        pre = c\n\n    if cnt >= K:\n        gain += line[-1]*cnt\n        for k in range(W-cnt, W):\n            line[k] = 0\n    return gain\n\n\ndef remove(S):\n    for w in range(W):\n        i = H-1\n        for h in range(H-1, -1, -1):\n            if S[h][w]:\n                S[i][w] = S[h][w]\n                i -= 1\n        for i in range(i+1):\n            S[i][w] = 0\n\n\ndef remove_sq(S, i, j):\n    for h in range(i, 0, -1):\n        S[h][j] = S[h-1][j]\n    S[0][j] = 0\n\n\nans = 0\nfor i in range(H):\n    for j in range(W):\n        S = [b.copy() for b in B]\n        remove_sq(S, i, j)\n        score = 0\n        p = 1\n        while True:\n            gain = calc(S)\n            if gain == 0:\n                break\n            score += p * gain\n            p *= 2\n        if ans < score:\n            ans = score\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import copy\nh, w, k = map(int, input().split())\na = [[] for j in range(h)]\nfor i in range(h):\n    a[i] = [int(i) for i in input()]\nans = 0\nfor p in range(h):\n    for q in range(w):\n        cand = 0\n        b = copy.deepcopy(a)\n        b[p][q] = 0\n        disap = True\n        fall = True\n        disapnum = 0\n        while(disap):\n            disap=False\n            cur = 0\n            for i in range(h):\n                suc = 1\n                for j in range(w-1):\n                    if b[i][j] == b[i][j+1]:\n                        suc += 1\n                    else:\n                        if suc >= k:\n                            if b[i][j]:\n                                disap=True\n                                fall=True\n                                cur += b[i][j]*suc\n                            for m in range(j+1-suc, j+1):\n                                b[i][m] = 0\n                        suc = 1\n                if suc >= k:\n                    if b[i][w-1]:\n                        disap=True\n                        fall=True\n                        cur += b[i][w-1]*suc\n                    for m in range(w-suc, w):\n                        b[i][m] = 0\n            if disap:\n                cand += cur*(2**disapnum)\n                disapnum += 1\n            while(fall):\n                fall=False\n                for i in range(1, h):\n                    for j in range(w):\n                        if b[i][j] == 0 and b[i-1][j]:\n                            b[i][j], b[i-1][j] = b[i-1][j], b[i][j]\n                            fall = True\n                            disap = True\n        ans = max(cand, ans)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations, accumulate\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    def check(y,x):\n        a = s[x][y]\n        d = 0\n        for i in range(x,w):\n            if s[i][y] != a:\n                break\n            d += 1\n        if d < k:\n            return 0\n        else:\n            return d\n\n    def update(y,x,d):\n        for i in range(x,x+d):\n            s[i][y] = 0\n\n    def fall(s):\n        res = [[] for i in range(w)]\n        for x in range(w):\n            for y in range(h):\n                if s[x][y]:\n                    res[x].append(s[x][y])\n            for y in range(h-len(res[x])):\n                res[x].append(0)\n        return res\n\n    h,w,k = LI()\n    c = [list(map(int, input())) for i in range(h)]\n    c = [[c[-1-y][x] for y in range(h)] for x in range(w)]\n    ans = 0\n    for sy in range(h):\n        for sx in range(w):\n            s = [[i for i in j] for j in c]\n            s[sx][sy] = 0\n            s = fall(s)\n            m = 0\n            is_update = 1\n            p = 1\n            while is_update:\n                is_update = 0\n                for y in range(h):\n                    for x in range(w):\n                        if s[x][y]:\n                            d = check(y,x)\n                            if d:\n                                m += p*d*s[x][y]\n                                update(y,x,d)\n                                is_update = 1\n                if is_update:\n                    s = fall(s)\n                    p <<= 1\n            if ans < m:\n                ans = m\n    print(ans)\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nimport sys\nimport math\nimport string\nimport collections\nimport fractions\nimport random\nfrom operator import itemgetter\nimport itertools\nfrom collections import deque\nimport copy\nimport heapq\nimport bisect\n\nMOD = 10 ** 9 + 7\nINF = float('inf')\ninput = lambda: sys.stdin.readline().strip()\n\nsys.setrecursionlimit(10 ** 8)\n\nH, W, K = map(int, input().split())\nc = [list(map(int, list(input()))) for _ in range(H)]\nans = 0\ncc = copy.deepcopy(c)\nfor z in range(H):\n    for m in range(W):\n        c = copy.deepcopy(cc)\n        c[z][m] = 0\n        temp_ans = 0\n        repeat_num = -1\n        p = 1\n        while p:\n            p = 0\n            for i in range(H):\n                num = 1\n                for j in range(W):\n                    if j != W - 1:\n                        if c[i][j] == c[i][j + 1] and c[i][j] != -1:\n                            num += 1\n                        elif num >= K:\n                            temp_ans += 2 ** repeat_num * c[i][j] * num\n                            for k in range(j - num + 1, j + 1):\n                                c[i][k] = 0\n                            num = 1\n                            p = 1\n                        else:\n                            num = 1\n                    elif num >= K:\n                        temp_ans += 2 ** repeat_num * c[i][j] * num\n                        for k in range(j - num + 1, j + 1):\n                            c[i][k] = 0\n                        num = 1\n                        p = 1\n            for i in reversed(range(H)):\n                for j in reversed(range(W)):\n                    if not c[i][j]:\n                        if i == 0:\n                            c[i][j] = -1\n                        else:\n                            for k in reversed(range(i)):\n                                if c[k][j] != 0:\n                                    c[i][j] = c[k][j]\n                                    c[k][j] = 0\n                                    break\n            repeat_num += 1\n            if repeat_num == 0:\n                p = 1\n        ans = max(ans, temp_ans)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/env python3\n\ndef dropcell(h, w, rm):\n    for i in range(w):\n        y = 0\n        for j in range(h):\n            if rm[h-j-1][i] != 0:\n                rm[h-y-1][i] = rm[h-j-1][i]\n                y += 1\n\ndef removecell(h, w, k, rm, a):\n    p = 0\n    for y in range(h):\n        c, t = 1, 0\n        for i in range(w+1):\n            x = rm[y][i]\n            if x > 0 and x == t:\n                c += 1\n            else:\n                if c >= k:\n                    for j in range(c):\n                        rm[y][i-1-j] = 0\n                    p += (t * c)\n                t = x\n                c = 1\n    return p * (2**a)\n\ndef game(h, w, k, M, y, x):\n    f, p, a = 1, 0, 0\n    rm = [[j for j in i]for i in M[:y+1]]\n    rm[y][x] = 0\n    while f:\n        dropcell(len(rm), w, rm)\n        f = removecell(len(rm), w, k, rm, a)\n        p += f\n        a += 1\n    return p\n\ndef main():\n    H, W, K = map(int, input().split())\n    M = [list(map(int, list(input())))+[0] for i in range(H)]\n    ans = 0\n    for j in range(W):\n        t = 0\n        for i in range(1, H):\n            if M[i][j] != t:\n                ans = max(ans, game(H, W, K, M, i, j))\n                t = M[i][j]\n    print(ans)\n    \nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\n\nH, W, K = map(int, input().split())\npuzzle = [[-1] * H for _ in range(W)]\n\nfor i in range(H - 1, -1, -1):\n    for j, stone in enumerate(list(map(int, input()))):\n        puzzle[j][i] = stone\n\n\ndef solve(h, w):\n    pz = deepcopy(puzzle)\n    pz[w].pop(h)\n    pz[w].append(0)\n    ans = 0\n    cnt = 0\n    tmp_score = -1\n    while tmp_score != 0:\n        tmp_score = 0\n        tmp_sum = 0\n\n        # puzzle連鎖確認\n        for i in range(H - 1, -1, -1):\n            ch_cnt = 0\n            for j in range(W - 1):\n                if pz[j][i] == pz[j + 1][i]:\n                    ch_cnt += 1\n                else:\n                    if ch_cnt + 1 >= K:\n                        # 得点\n                        tmp_sum += pz[j][i] * (ch_cnt + 1)\n                        # puzzle消去\n                        for p in range(j, j - (ch_cnt + 1), -1):\n                            pz[p].pop(i)\n                            pz[p].append(0)\n                    ch_cnt = 0\n            else:\n                if ch_cnt + 1 >= K:\n                    # 得点\n                    tmp_sum += pz[j][i] * (ch_cnt + 1)\n                    # puzzle消去\n                    for p in range(j + 1, j - ch_cnt, -1):\n                        pz[p].pop(i)\n                        pz[p].append(0)\n        tmp_score += (2 ** cnt) * tmp_sum\n        cnt += 1\n        ans += tmp_score\n    return ans\n\n\nf_ans = 0\nfor i in range(H):\n    for j in range(W):\n        f_ans = max(f_ans, solve(i, j))\n\n\nprint(f_ans)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nfrom collections import deque, Counter\nfrom heapq import heappop, heappush\nfrom bisect import bisect_right\nimport copy\n\nH, W, K = map(int, input().split())\nif K > W:\n    exit(print(0))\n\n# 現在の盤面を生成する\nc = [[] for _ in range(W)]\nfor i in range(H):\n    S = input()\n    for j in range(W):\n        c[j].append(int(S[j]))\n\nfor j in range(W):\n    c[j] = c[j][::-1]\n# print(c)\n\n# 連鎖消滅後の得点を計算する\ndef cal_score(c,score,loop):\n    # 消滅\n    nextc = []\n    for j in range(W):\n        num0 = c[j].count(0)\n        tmp = [*filter(lambda x: x>0,c[j])]\n        nextc.append(tmp+[0]*num0)\n\n    # print(nextc)\n\n    # 連鎖\n    res = 0# 追加得点\n    for i in range(H):\n        j = 0\n        while j < W:\n            seq = 1\n            while j<W-1 and nextc[j][i] == nextc[j+1][i] > 0:\n                seq += 1\n                j += 1\n            if seq >= K:\n                res += seq * nextc[j][i]\n                for k in range(j-seq+1,j+1):\n                    nextc[k][i] = 0\n            j += 1\n    # print(nextc,res)\n    if res == 0:\n        return score\n    else:\n        return cal_score(nextc,score+res*pow(2,loop),loop+1)\n    \n\nans = 0\nfor p in range(H):\n    for q in range(W):\n        # p = 0\n        # q = 2\n        cc = copy.deepcopy(c)\n        cc[q][p] = 0\n        # print(p,q)\n        z = cal_score(cc,0,0)\n        # print(z)\n        ans = max(ans, z)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "h, w, k  = map(int, input().split())\n\npuyo_orig = [[0]*w for _ in range(h+1)]\nfor i in range(1,h+1):\n    puyo_orig[i] = list(map(int, list(input())))\n\nimport copy\nmx = 0\nfor i1 in range(2,h+1):\n    for i2 in range(w):\n        puyo = copy.deepcopy(puyo_orig)\n        for l in range(i1,0,-1):\n            puyo[l][i2] = puyo[l-1][i2]\n        p = 0\n        fin = 0\n        turn = 0\n        while fin==0:\n            fin = 1\n            for i in range(2,h+1):\n                cnt = 1\n                for j in range(w-1):\n                    if puyo[i][j+1] == puyo[i][j] and puyo[i][j]>0:\n                        cnt += 1\n                    else:\n                        if cnt>=k:\n                            p += cnt * puyo[i][j] * 2**turn\n                            for l in range(i,0,-1):\n                                puyo[l][j-cnt+1:j+1] = puyo[l-1][j-cnt+1:j+1]\n                            fin = 0\n                        cnt = 1\n                    if j==w-2:\n                        if cnt>=k:\n                            p += cnt * puyo[i][j] * 2**turn\n                            for l in range(i,0,-1):\n                                puyo[l][j-cnt+2:] = puyo[l-1][j-cnt+2:]\n                            fin = 0\n            turn += 1\n        if p>mx:\n            mx=p\n            \nprint(mx)\n"
  },
  {
    "language": "Python",
    "code": "from itertools import groupby\n\ndef calc(time):\n  t = 0\n  for i in range(h):\n    gr = groupby(g[i])\n    lst = []\n    p = 0\n    for key,it in gr:\n      j = len(list(it))\n      lst.append([p,key,j])\n      p += j\n    for j in range(len(lst)):\n      if lst[j][1] == -1:\n        continue\n      if lst[j][2] >= K:\n        t += (2**time)*lst[j][1]*lst[j][2]\n        for k in range(lst[j][0],lst[j][0]+lst[j][2]):\n          g[i][k] = 0\n\n  return t\n\ndef flatten():\n  for j in range(w):\n    lst = []\n    for i in range(h-1, -1, -1):\n      if g[i][j] > 0:\n        lst.append(g[i][j])\n\n    lst += [-1] * (h - len(lst))\n\n    for i in range(h-1, -1, -1):\n      g[i][j] = lst[h-i-1]\n\nh,w,K = map(int,input().split())\nmat = [ [int(e) for e in list(input())] for _ in range(h) ]\n\nres = 0\nfor i in range(h):\n  for j in range(w):\n    score = 0\n    g = [ [ mat[n][m] for m in range(w) ] for n in range(h) ]\n    g[i][j] = -1\n    time = 0\n    flatten()\n    while True:\n      s = calc(time)\n      if s==0: break\n      score += s\n      flatten()\n      time += 1\n    res = max(res, score)\n\nprint(res)\n"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nH, W, K = map(int, input().split())\nboard = [[0]*W for _ in range(H+1)]\nfor i in range(1,H+1):\n    board[i] = list(map(int, list(input())))\ndef drop(board_copy):\n    change = True\n    score = 0\n    p = 0\n    while change:\n        change = False\n        for i in range(1,H+1):\n            ser = 1\n            for j in range(W-1):\n                if board_copy[i][j]==0:\n                    ser = 1\n                    continue\n                if board_copy[i][j]>0 and board_copy[i][j]==board_copy[i][j+1]:\n                    ser += 1\n                elif ser>=K:\n                    score += 2**p*board_copy[i][j]*ser\n                    change = True\n                    for k in range(i,0,-1):\n                        board_copy[k][j-ser+1:j+1] = board_copy[k-1][j-ser+1:j+1]\n                    ser = 1\n                if j==W-2 and ser>K:\n                    score += 2**p*board_copy[i][-1]*ser\n                    change = True\n                    for k in range(i,0,-1):\n                        board_copy[k][-ser:] = board_copy[k-1][-ser:]\n        p += 1\n    return score\nans = 0\nfor h in range(1,H+1):\n    for w in range(W):\n        board_copy = deepcopy(board)\n        for k in range(h,0,-1):\n            board_copy[k][w] = board[k-1][w]\n        ans = max(ans,drop(board_copy))\nprint(ans)"
  },
  {
    "language": "Rust",
    "code": "#![allow(non_snake_case)]\n#![allow(dead_code)]\n#![allow(unused_macros)]\n#![allow(unused_imports)]\n\nuse std::str::FromStr;\nuse std::io::*;\nuse std::collections::*;\nuse std::cmp::*;\n\nstruct Scanner<I: Iterator<Item = char>> {\n    iter: std::iter::Peekable<I>,\n}\n\nmacro_rules! exit {\n    () => {{\n        exit!(0)\n    }};\n    ($code:expr) => {{\n        if cfg!(local) {\n            writeln!(std::io::stderr(), \"===== Terminated =====\")\n                .expect(\"failed printing to stderr\");\n        }\n        std::process::exit($code);\n    }}\n}\n\nimpl<I: Iterator<Item = char>> Scanner<I> {\n    pub fn new(iter: I) -> Scanner<I> {\n        Scanner {\n            iter: iter.peekable(),\n        }\n    }\n\n    pub fn safe_get_token(&mut self) -> Option<String> {\n        let token = self.iter\n            .by_ref()\n            .skip_while(|c| c.is_whitespace())\n            .take_while(|c| !c.is_whitespace())\n            .collect::<String>();\n        if token.is_empty() {\n            None\n        } else {\n            Some(token)\n        }\n    }\n\n    pub fn token(&mut self) -> String {\n        self.safe_get_token().unwrap_or_else(|| exit!())\n    }\n\n    pub fn get<T: FromStr>(&mut self) -> T {\n        self.token().parse::<T>().unwrap_or_else(|_| exit!())\n    }\n\n    pub fn vec<T: FromStr>(&mut self, len: usize) -> Vec<T> {\n        (0..len).map(|_| self.get()).collect()\n    }\n\n    pub fn mat<T: FromStr>(&mut self, row: usize, col: usize) -> Vec<Vec<T>> {\n        (0..row).map(|_| self.vec(col)).collect()\n    }\n\n    pub fn char(&mut self) -> char {\n        self.iter.next().unwrap_or_else(|| exit!())\n    }\n\n    pub fn chars(&mut self) -> Vec<char> {\n        self.get::<String>().chars().collect()\n    }\n\n    pub fn mat_chars(&mut self, row: usize) -> Vec<Vec<char>> {\n        (0..row).map(|_| self.chars()).collect()\n    }\n\n    pub fn line(&mut self) -> String {\n        if self.peek().is_some() {\n            self.iter\n                .by_ref()\n                .take_while(|&c| !(c == '\\n' || c == '\\r'))\n                .collect::<String>()\n        } else {\n            exit!();\n        }\n    }\n\n    pub fn peek(&mut self) -> Option<&char> {\n        self.iter.peek()\n    }\n}\n\nstruct Solver {\n    H: usize,\n    W: usize,\n    K: usize,\n    c: Vec<Vec<usize>>,\n}\n\nimpl Solver {\n    fn new(H: usize, W: usize, K: usize, c: Vec<Vec<usize>>) -> Self {\n        Solver {\n            H: H,\n            W: W,\n            K: K,\n            c: c,\n        }\n    }\n    fn check(&mut self, row: usize, col: usize, num: usize, clear: &mut Vec<Vec<bool>>,\n                visited: &mut Vec<Vec<bool>>) -> usize {\n        let mut conti = 0;\n        for c in col..self.W {\n            if self.c[row][c] == num {\n                visited[row][c] = true;\n                conti += 1;\n            } else {\n                break;\n            }\n        }\n        if conti >= self.K {\n            for c in col..col+conti {\n                clear[row][c] = true;\n            }\n            conti * num\n        } else {\n            0\n        }\n    }\n    fn solve(&mut self, row: usize, col: usize) -> usize {\n        let mut ret = 0;\n        let mut is_coutinued = true;\n        let mut i = 0;\n        while is_coutinued {\n            is_coutinued = false;\n            let mut clear = vec![vec![false; self.W]; self.H];\n            let mut visited = vec![vec![false; self.W]; self.H];\n            for row in 0..self.H {\n                for col in 0..self.W {\n                    let num = self.c[row][col];\n                    if visited[row][col] || num == 0 {\n                        continue;\n                    }\n                    let erased = self.check(row, col, num, &mut clear, &mut visited);\n                    is_coutinued |= erased != 0;\n                    if erased == 0 {\n                        continue;\n                    }\n                    let score = erased * usize::pow(2, i-1);\n                    ret += score;\n                }\n            }\n            if i == 0 {\n                clear[row][col] = true;\n                is_coutinued = true;\n            }\n            for row in 0..self.H {\n                for col in 0..self.W {\n                    if clear[row][col] {\n                        for r in (1..row+1).rev() {\n                            self.c[r][col] = self.c[r-1][col];\n                        }\n                        self.c[0][col] = 0;\n                    }\n                }\n            }\n            i += 1;\n        }\n        ret\n    }\n}\n\n\nfn main() {\n    let cin = stdin();\n    let cin = cin.lock();\n    let mut sc = Scanner::new(cin.bytes().map(|c| c.unwrap() as char));\n    let H: usize = sc.get();\n    let W: usize = sc.get();\n    let K: usize = sc.get();\n    let mut c = vec![vec![0; W]; H];\n    for row in 0..H {\n        let l: Vec<char> = sc.chars();\n        for col in 0..W {\n            let d = l[col] as u8 - b'0';\n            c[row][col] = d as usize;\n        }\n    }\n    let mut ans = 0;\n    for row in 0..H {\n        for col in 0..W {\n            let mut s = Solver::new(H, W, K, c.clone());\n            ans = max(ans, s.solve(row, col));\n        }\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports)]\n#![allow(non_snake_case)]\nuse std::cmp::*;\nuse std::collections::*;\nuse std::io::Write;\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($e:expr),*) => {\n        #[cfg(debug_assertions)]\n        $({\n            let (e, mut err) = (stringify!($e), std::io::stderr());\n            writeln!(err, \"{} = {:?}\", e, $e).unwrap()\n        })*\n    };\n}\n\nfn main() {\n    let v = read_vec::<usize>();\n    let (h, w, k) = (v[0], v[1], v[2]);\n    let mut grid = vec![vec![]; h];\n    for y in 0..h {\n        grid[y] = read::<String>()\n            .chars()\n            .map(|x| x.to_digit(10).unwrap() as i64)\n            .collect::<Vec<_>>();\n    }\n    grid.reverse();\n    let mut ans = 0;\n\n    for y in 0..h {\n        for x in 0..w {\n            let mut grid_clone = grid.clone();\n            for yy in y..h - 1 {\n                grid_clone[yy][x] = grid_clone[yy + 1][x];\n            }\n            grid_clone[h - 1][x] = 0;\n            ans = max(ans, solve(grid_clone, k));\n        }\n    }\n    println!(\"{}\", ans);\n}\n\nfn solve(mut grid: Vec<Vec<i64>>, k: usize) -> i64 {\n    let mut coef = 1i64;\n    let mut temp_ans = 0;\n    let h = grid.len();\n    let w = grid[0].len();\n    loop {\n        // for round\n        let mut marked = HashSet::new();\n        for y in 0..h {\n            for x in 0..w + 1 - k {\n                // 0 means not exists.\n                if grid[y][x] != 0 && grid[y][x..x + k].iter().all(|&cell| cell == grid[y][x]) {\n                    for i in 0..k {\n                        if !marked.contains(&(x + i, y)) {\n                            marked.insert((x + i, y));\n                            temp_ans += grid[y][x] * coef;\n                        }\n                    }\n                }\n            }\n        }\n        if marked.is_empty() {\n            break;\n        }\n\n        // reconstruct\n        let mut new_grid = vec![vec![0; w]; h];\n        let mut removed = vec![0; w];\n        for y in 0..h {\n            for x in 0..w {\n                while removed[x] + y < h && marked.contains(&(x, removed[x] + y)) {\n                    removed[x] += 1;\n                }\n                if removed[x] + y >= h {\n                    continue; // 0 is already set.\n                }\n                new_grid[y][x] = grid[removed[x] + y][x];\n            }\n        }\n        grid = new_grid;\n        coef *= 2;\n    }\n    temp_ans\n}\n\nfn read<T: std::str::FromStr>() -> T {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).ok();\n    s.trim().parse().ok().unwrap()\n}\n\nfn read_vec<T: std::str::FromStr>() -> Vec<T> {\n    read::<String>()\n        .split_whitespace()\n        .map(|e| e.parse().ok().unwrap())\n        .collect()\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(non_snake_case)]\n#![allow(dead_code)]\n#![allow(unused_macros)]\n#![allow(unused_imports)]\n\nuse std::str::FromStr;\nuse std::io::*;\nuse std::collections::*;\nuse std::cmp::*;\n\nstruct Scanner<I: Iterator<Item = char>> {\n    iter: std::iter::Peekable<I>,\n}\n\nmacro_rules! exit {\n    () => {{\n        exit!(0)\n    }};\n    ($code:expr) => {{\n        if cfg!(local) {\n            writeln!(std::io::stderr(), \"===== Terminated =====\")\n                .expect(\"failed printing to stderr\");\n        }\n        std::process::exit($code);\n    }}\n}\n\nimpl<I: Iterator<Item = char>> Scanner<I> {\n    pub fn new(iter: I) -> Scanner<I> {\n        Scanner {\n            iter: iter.peekable(),\n        }\n    }\n\n    pub fn safe_get_token(&mut self) -> Option<String> {\n        let token = self.iter\n            .by_ref()\n            .skip_while(|c| c.is_whitespace())\n            .take_while(|c| !c.is_whitespace())\n            .collect::<String>();\n        if token.is_empty() {\n            None\n        } else {\n            Some(token)\n        }\n    }\n\n    pub fn token(&mut self) -> String {\n        self.safe_get_token().unwrap_or_else(|| exit!())\n    }\n\n    pub fn get<T: FromStr>(&mut self) -> T {\n        self.token().parse::<T>().unwrap_or_else(|_| exit!())\n    }\n\n    pub fn vec<T: FromStr>(&mut self, len: usize) -> Vec<T> {\n        (0..len).map(|_| self.get()).collect()\n    }\n\n    pub fn mat<T: FromStr>(&mut self, row: usize, col: usize) -> Vec<Vec<T>> {\n        (0..row).map(|_| self.vec(col)).collect()\n    }\n\n    pub fn char(&mut self) -> char {\n        self.iter.next().unwrap_or_else(|| exit!())\n    }\n\n    pub fn chars(&mut self) -> Vec<char> {\n        self.get::<String>().chars().collect()\n    }\n\n    pub fn mat_chars(&mut self, row: usize) -> Vec<Vec<char>> {\n        (0..row).map(|_| self.chars()).collect()\n    }\n\n    pub fn line(&mut self) -> String {\n        if self.peek().is_some() {\n            self.iter\n                .by_ref()\n                .take_while(|&c| !(c == '\\n' || c == '\\r'))\n                .collect::<String>()\n        } else {\n            exit!();\n        }\n    }\n\n    pub fn peek(&mut self) -> Option<&char> {\n        self.iter.peek()\n    }\n}\n\nstruct Solver {\n    H: usize,\n    W: usize,\n    K: usize,\n    c: Vec<Vec<usize>>,\n}\n\nimpl Solver {\n    fn new(H: usize, W: usize, K: usize, c: Vec<Vec<usize>>) -> Self {\n        Solver {\n            H: H,\n            W: W,\n            K: K,\n            c: c,\n        }\n    }\n    fn check(&mut self, row: usize, col: usize, num: usize, clear: &mut Vec<Vec<bool>>,\n                visited: &mut Vec<Vec<bool>>) -> usize {\n        let mut conti = 0;\n        for c in col..self.W {\n            if self.c[row][c] == num {\n                visited[row][c] = true;\n                conti += 1;\n            } else {\n                break;\n            }\n        }\n        if conti >= self.K {\n            for c in col..col+conti {\n                clear[row][c] = true;\n            }\n            conti * num\n        } else {\n            0\n        }\n    }\n    fn solve(&mut self, row: usize, col: usize) -> usize {\n        let mut ret = 0;\n        let mut is_coutinued = true;\n        let mut i = 0;\n        let mut scores = Vec::new();\n        while is_coutinued {\n            is_coutinued = false;\n            let mut clear = vec![vec![false; self.W]; self.H];\n            let mut visited = vec![vec![false; self.W]; self.H];\n            for row in 0..self.H {\n                for col in 0..self.W {\n                    let num = self.c[row][col];\n                    if visited[row][col] || num == 0 {\n                        continue;\n                    }\n                    let erased = self.check(row, col, num, &mut clear, &mut visited);\n                    is_coutinued |= erased != 0;\n                    if erased == 0 {\n                        continue;\n                    }\n                    let score = erased * usize::pow(2, i-1);\n                    scores.push((num, score, i));\n                    ret += score;\n                }\n            }\n            if i == 0 {\n                clear[row][col] = true;\n                is_coutinued = true;\n            }\n            for row in 0..self.H {\n                for col in 0..self.W {\n                    if clear[row][col] {\n                        for r in (1..row+1).rev() {\n                            self.c[r][col] = self.c[r-1][col];\n                        }\n                        self.c[0][col] = 0;\n                    }\n                }\n            }\n            i += 1;\n        }\n        ret\n    }\n}\n\n\nfn main() {\n    let cin = stdin();\n    let cin = cin.lock();\n    let mut sc = Scanner::new(cin.bytes().map(|c| c.unwrap() as char));\n    let H: usize = sc.get();\n    let W: usize = sc.get();\n    let K: usize = sc.get();\n    let mut c = vec![vec![0; W]; H];\n    for row in 0..H {\n        let l: Vec<char> = sc.chars();\n        for col in 0..W {\n            let d = l[col] as u8 - b'0';\n            c[row][col] = d as usize;\n        }\n    }\n    let mut ans = 0;\n    for row in 0..H {\n        for col in 0..W {\n            let mut s = Solver::new(H, W, K, c.clone());\n            ans = max(ans, s.solve(row, col));\n        }\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports)]\nuse std::cmp::*;\nuse std::collections::*;\nuse itertools::Itertools;\nuse proconio::{input, marker::*, fastout};\nuse superslice::*;\n\n#[fastout()]\nfn main() {\n    input! {\n        h: usize, w: usize, k: usize,\n        ccc: [Chars; h],\n    }\n    let mut board = vec![vec![0i64; h*2]; w];\n    for y in (0..h).rev() {\n        for x in 0..w {\n            let c = ccc[y][x].to_digit(10).unwrap() as i64;\n            board[x][h-y-1] = c;\n        }\n    }\n\n    let mut ans = 0i64;\n    for sy in 0..h {\n        for sx in 0..w {\n            let mut board = board.clone();\n            let mut total = 0i64;\n            board[sx].remove(sy);\n\n            let mut ratio = 1i64;\n            while let Some(score) = cease(&mut board, k, h, w) {\n                total += ratio * score;\n                ratio *= 2;\n            }\n            ans = max(ans, total);\n        }\n    }\n\n    println!(\"{}\", ans);\n}\n\nfn cease(board: &mut Vec<Vec::<i64>>, k: usize, h: usize, w: usize) -> Option<i64> {\n    let mut dels = Vec::new();\n    for y in 0..h {\n        let mut start = 0;\n        let mut number = 1;\n        for x in 0..w {\n            if board[x][y] != number {\n                if x - start >= k && number != 0 {\n                    for i in start..x {\n                        dels.push((i, y, number));\n                    }\n                }\n                start = x;\n                number = board[x][y];\n            } else if x == w-1 {\n                if x + 1 - start >= k && number != 0 {\n                    for i in start..=x {\n                        dels.push((i, y, number));\n                    }\n                }\n            }\n        }\n    }\n    let mut score = 0;\n    while let Some((x, y, number)) = dels.pop() {\n        board[x].remove(y);\n        score += number;\n    }\n    if score == 0 {\n        None\n    } else {\n        Some(score)\n    }\n}"
  }
]