[
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nint dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; /* CSS order */\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nenum state {\n\tEMPTY,\n\tHL, HR,\n\tVT, VB\n};\nvector< vector<state> > field;\nint H, W;\n\nint rec(int i, int j)\n{\n\tif (i == H) {\n\t\treturn 1;\n\t}\n\tif (j >= W) {\n\t\treturn rec(i + 1, 0);\n\t}\n\tif (field[i][j] != EMPTY) {\n\t\treturn rec(i, j + 1);\n\t}\n\n\t// REP (y, H) {\n\t\t// REP (x, W) {\n\t\t\t// cerr << field[y][x] << \" \";\n\t\t// }\n\t\t// cerr << endl;\n\t// }\n\n\tint ret = 0;\n\t// horizontal\n\tif (i - 1 < 0 || j - 1 < 0 || field[i-1][j-1] == HL || field[i-1][j-1] == VT) {\n\t\tif (i - 1 < 0 || j + 2 == W || field[i-1][j+2] == HR || field[i-1][j+2] == VT) {\n\t\t\tif (j + 1 < W && field[i][j+1] == EMPTY) {\n\t\t\t\tfield[i][j] = HL, field[i][j+1] = HR;\n\t\t\t\tret += rec(i, j+1);\n\t\t\t\tfield[i][j] = EMPTY, field[i][j+1] = EMPTY;\n\t\t\t}\n\t\t}\n\t}\n\t// vertical\n\tif (i - 1 < 0 || j - 1 < 0 || field[i-1][j-1] == HL || field[i-1][j-1] == VT) {\n\t\tif (i - 1 < 0 || j + 1 == W || field[i-1][j+1] == HR || field[i-1][j+1] == VT) {\n\t\t\tif (i + 1 < H) {\n\t\t\t\tfield[i][j] = VT, field[i+1][j] = VB;\n\t\t\t\tret += rec(i, j+1);\n\t\t\t\tfield[i][j] = EMPTY, field[i+1][j] = EMPTY;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\twhile (cin >> H >> W, H | W) {\n\t\tfield = vector< vector<state> >(H, vector<state>(W, EMPTY));\n\t\tcout << rec(0, 0) << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint a[21][21],ans,c,h,w;\nvoid dfs(int x,int y);\nbool ch(int x,int y){\n  return !(a[y][x-1]!=a[y-1][x-1]&&a[y-1][x]!=a[y-1][x-1]&&a[y][x-1]!=a[y-1][x]);\n}\nvoid in(int x,int y){\n  if(x==w-1)dfs(0,y+1);\n  else dfs(x+1,y);\n}\nvoid dfs(int x,int y){\n  if(x==w-1&&y==h-1)ans++;\n  else{\n    if(a[y][x])in(x,y);\n    else if(!x||!y||(ch(x,y))){\n      int col=++c;\n      a[y][x]=col;\n      if(y!=h-1&&!a[y+1][x]){\n        a[y+1][x]=col;\n        in(x,y);\n        a[y+1][x]=0;\n      }\n      if(x!=w-1&&!a[y][x+1]){\n        a[y][x+1]=col;\n        in(x,y);\n        a[y][x+1]=0;\n      }\n      a[y][x]=0;\n    }\n  }\n}\nint main(){\n  while(cin>>h>>w,h){\n    memset(a,0,sizeof(a));\n    ans=c=0;\n    if(h%2==0&&w%2==0)dfs(0,0);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <stdio.h>\n\nusing namespace std;\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nint board[44][44];\nint h, w;\n\nint DFS(int x, int y, int n){\n\tint ret = 0;\n\twhile(board[x][y] != 0){\n\t\tx++;\n\t\tif(x > w){\n\t\t\ty++;\n\t\t\tx = 1;\n\t\t\tif(y > h)return 1;\n\t\t}\n\t}\n\t//たて向き\n\tif(board[x][y+1]==0){\n\t\tint check = 0;\n\t\tif(board[x][y-1] != board[x+1][y-1])check++;\n\t\tif(board[x+1][y-1] != board[x+1][y])check++;\n\t\tif(check != 2){\n\t\t\tboard[x][y] = n;\n\t\t\tboard[x][y+1] = n;\n\t\t\tret += DFS(x,y,n+1);\n\t\t\tboard[x][y] = 0;\n\t\t\tboard[x][y+1] = 0;\n\t\t}\n\t}\n\t//よこ向き\n\tif(board[x+1][y]==0){\n\t\tint check = 0;\n\t\tif(board[x+1][y-1] != board[x+2][y-1])check++;\n\t\tif(board[x+2][y] != board[x+2][y-1])check++;\n\t\tif(check != 2){\n\t\t\tboard[x][y] = n;\n\t\t\tboard[x+1][y] = n;\n\t\t\tret += DFS(x,y,n+1);\n\t\t\tboard[x][y] = 0;\n\t\t\tboard[x+1][y] = 0;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(1){\n\t\tmemset(board, 0, sizeof(board));\n\t\tcin >> h>> w;\n\t\tif(h==0)break;\n\t\tREP(i,w+2){\n\t\t\tboard[i][0] = 1000;\n\t\t\tboard[i][h+1] = 1000;\n\t\t}\n\t\tREP(i,h+2){\n\t\t\tboard[0][i] = 1000;\n\t\t\tboard[w+1][i] = 1000;\n\t\t}\n\t\tif(h==0)return 0;\n\t\tcout << DFS(1, 1, 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tbool ok2 = !((c1 * c2 * c3 * c4) && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\n\t\t\tok = ok && ok2;\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0, starts = count_ / W;\n\n\tfor (int i = starts; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (!tatami[i][j])\n\t\t\t{\n\t\t\t\tif (H - i - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i + 1][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (W - j - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i][j + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\", dfs(1, vector<vector<int> >(H, vector<int>(W, 0))));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\nint H, W;\n\nbool inside(int i, int j){\n     return 0 <= i && i < H && 0 <= j && j < W;\n}\n\nbool exist(vector<vector<int>>& field, int i, int j){\n    return !inside(i, j) || field[i][j] != 0;\n}\n\nbool different(vector<vector<int>>& field, int ai, int aj, int bi, int bj){\n    return inside(ai, aj) && inside(bi, bj) && field[ai][aj] != 0 && field[bi][bj] != 0 && field[ai][aj] != field[bi][bj];\n}\n\nbool able(vector<vector<int>>& field, int i, int j){\n    return !(different(field, i-1, j-1, i-1, j) && different(field, i, j-1, i-1, j-1)) && !(different(field, i+1, j-1, i+1, j) && different(field, i+1, j-1, i, j-1));\n}\n\nint dfs(vector<vector<int>>& field, int idx){\n    vector<vector<int>> next = field;\n\n    while(true){\n        bool change = false;\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if(next[i][j] == 0){\n                    if((exist(next, i-1, j) && exist(next, i, j-1) && exist(next, i+1, j))\n                        || (j + 1 < W && next[i][j+1] == 0 && (different(next, i-1, j, i-1, j+1) || different(next, i-1, j, i-1, j+1)))){\n                        if(j + 1 < W && next[i][j+1] == 0 && able(next, i, j) && able(next, i, j+1)){\n                            next[i][j] = idx;\n                            next[i][j+1] = idx;\n                            idx++;\n                            change = true;\n                            break;\n                        }else{\n                            return 0;\n                        }\n                    }\n                    if((exist(next, i-1, j) && exist(next, i, j-1) && exist(next, i, j+1))\n                        || (i + 1 < H && next[i+1][j] == 0 && (different(next, i, j-1, i+1, j-1) || different(next, i, j+1, i+1, j+1)))){\n                        if(i + 1 < H && next[i+1][j] == 0 && able(next, i, j) && able(next, i+1, j)){\n                            next[i][j] = idx;\n                            next[i+1][j] = idx;\n                            idx++;\n                            change = true;\n                            break;\n                        }else{\n                            return 0;\n                        }\n                    }\n                }\n            }\n            if(change) break;\n        }\n        if(!change) break;\n    }\n\n    if(idx == H * W / 2 + 1){\n        return 1;\n    }\n\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(next[i][j] == 0){\n                assert(i + 1 < H && next[i+1][j] == 0);\n                assert(j + 1 < W && next[i][j+1] == 0);\n                int ret = 0;\n                next[i][j] = idx;\n                next[i+1][j] = idx;\n                if(able(next, i, j) && able(next, i+1, j)) ret += dfs(next, idx+1);\n                next[i+1][j] = 0;\n                next[i][j+1] = idx;\n                if(able(next, i, j) && able(next, i, j+1)) ret += dfs(next, idx+1);\n                return ret;\n            }\n        }\n    }\n    assert(false);\n    return 0;\n}\n\nint main(){\n    while(true){\n        cin >> H >> W;\n        if(H == 0) break;\n        vector<vector<int>> field(H, vector<int>(W, 0));\n        cout << dfs(field, 1) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nint W,H,f[20][20];\nint rotx[]={1,0};\nint roty[]={0,1};\n\nint cdx[4][4]={\n\t{-1,-1,0,0},\n\t{0,0,1,1},\n\t{-1,-1,0,0},\n\t{0,0,1,1}\n};\n\nint cdy[4][4]={\n\t{-1,0,-1,0},\n\t{0,-1,-1,0},\n\t{0,1,0,1},\n\t{0,1,0,1}\n};\n\nbool check(int x, int y)\n{\n\tfor(int j=0; j<4; j++)\n\t{\n\t\tint cnt=0;\n\t\tbool ck[400]={0};\n\t\tfor(int i=0; i<4; i++)\n\t\t{\n\t\t\tint tx=x+cdx[j][i], ty=y+cdy[j][i];\n\t\t\tif(tx<0||ty<0||tx>=W||ty>=H) continue;\n\t\t\tif(f[tx][ty]==0) continue;\n\t\t\tif(!ck[f[tx][ty]]) cnt++;\n\t\t\tck[f[tx][ty]]=1;\n\t\t}\n\t\t\n\t\tif(cnt>3) return false;\n\t}\n\t\n\treturn true;\n}\n\nint dfs(int x, int y, int ccnt)\n{\n\tif((ccnt-1)*2==W*H) return 1;\n\tint ret=0;\n\tbool g=false;\n\tfor(int i=y; i<H; i++)\n\t{\n\t\tfor(int j=(i==y?x:0); j<W; j++)\n\t\t{\n\t\t\tif(f[j][i]) continue;\n\t\t\t\n\t\t\tg=true;\n\t\t\tfor(int k=0; k<2; k++)\n\t\t\t{\n\t\t\t\tint tx=j+rotx[k], ty=i+roty[k];\n\t\t\t\tif(tx<0||ty<0||tx>=W||ty>=H) continue;\n\t\t\t\tif(f[tx][ty]) continue;\n\n\t\t\t\tf[j][i]=ccnt;\n\t\t\t\tf[tx][ty]=ccnt;\n\t\t\t\tif(check(j,i)) ret+=dfs(j,i,ccnt+1);\n\t\t\t\tf[j][i]=0;\n\t\t\t\tf[tx][ty]=0;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(g) break;\n\t\t}\n\t\tif(g) break;\n\t}\n\t\n\treturn ret;\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d\", &H,&W), (H||W))\n\t{\n\t\tmemset(f,0,sizeof(f));\n\t\tprintf(\"%d\\n\", dfs(0,0,1));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint H,W;\nint t[30][30],u[30][30];\nll dfs(int y,int x){\n  if(x==W)return dfs(y+1,0);\n  if(y==H)return 1;\n  if(t[y][x]==1)return dfs(y,x+1);\n  ll res=0;\n  if(x+1<W&&t[y][x]==0&&t[y][x+1]==0){\n    if(u[y][x]<2&&u[y+1][x]<2&&u[y][x+2]<2&&u[y+1][x+2]<2){\n      u[y][x]++;u[y+1][x]++;u[y][x+2]++;u[y+1][x+2]++;\n      t[y][x]=t[y][x+1]=1;\n      res+=dfs(y,x+1);\n      t[y][x]=t[y][x+1]=0;\n      u[y][x]--;u[y+1][x]--;u[y][x+2]--;u[y+1][x+2]--;\n    }\n  }\n  if(y+1<H&&t[y][x]==0&&t[y+1][x]==0){\n    if(u[y][x]<2&&u[y+2][x]<2&&u[y][x+1]<2&&u[y+2][x+1]<2){\n      u[y][x]++;u[y+2][x]++;u[y][x+1]++;u[y+2][x+1]++;\n      t[y][x]=t[y+1][x]=1;\n      res+=dfs(y,x+1);\n      t[y][x]=t[y+1][x]=0;\n      u[y][x]--;u[y+2][x]--;u[y][x+1]--;u[y+2][x+1]--;\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0&&W==0)break;\n    cout<<dfs(0,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\nint main(){\n  for(int H,W;cin>>H>>W,H;){\n    map<vector<int>,int> m[21][21];\n    m[0][0][vector<int>(W)]=1;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tfor(auto e:m[i][j]){\n\t  auto v=e.first;\n\t  auto d=e.second;\n\t  if(j&&v[j-1]==2){\n\t    v[j]=3;\n\t    m[i][j+1][v]+=d;\n\t  }else if(i&&v[j]==0){\n\t    v[j]=1;\n\t    m[i][j+1][v]+=d;\n\t  }else if(i==0||v[j]==3||j==0||v[j-1]==1){\n\t    if(i+1<H){\n\t      auto nv=v;\n\t      nv[j]=0;\n\t      m[i][j+1][nv]+=d;\n\t    }\n\t    if(j+1<W&&(i==0||v[j+1]!=0)){\n\t      auto nv=v;\n\t      nv[j]=2;\n\t      m[i][j+1][nv]+=d;\n\t    }\n\t  }\n\t}\n\tm[i][j].clear();\n      }\n      m[i+1][0]=m[i][W];\n    }\n    int a=0;\n    for(auto e:m[H][0]){\n      a+=e.second;\n    }\n    cout<<a<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cassert>\n#include<climits>\n#include<iomanip>\n#define F first\n#define S second\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<int,bool> IB;\nint H,W;\nint cnt;\nint dx[] = {+0,+0,+1};\nint dy[] = {+1,-1,+0};\nmap<VVI,int> hope;\n\nP pdx[] = {P(0,1),P(0,0)};\nP pdy[] = {P(0,0),P(0,1)};\nint tdx[2][6] = {{+0,+1,+1,+1,+0,-1},{+0,-1,-1,+0,+1,+1}};\nint tdy[2][6] = {{+0,+0,+1,+2,+2,+1},{+0,+1,+3,+4,+3,+1}};\n\nvector<P> PtoVec(P p)\n{\n  vector<P> vec(4);\n  vec[0] = P(p.F,p.S*2-1);//top\n  vec[1] = P(p.F,p.S*2+1);//bottom\n  vec[2] = P(p.F-1,p.S*2);//left\n  vec[3] = P(p.F+0,p.S*2);//right\n  return vec;\n}\n\nvector<P> Union(vector<P> p1,vector<P> p2)\n{\n  vector<P> p3;\n  map<P,bool> exist;\n  rep(i,4)\n      exist[p1[i]] = true;\n\n  bool ok = false;\n  rep(i,4)\n    {\n      if(exist[p2[i]])\n\t{\n\t  ok = true;\n\t  exist[p2[i]] = false;\n\t  continue;\n\t}\n      exist[p2[i]] = true;    \n    }\n  assert(ok);\n  rep(i,4)\n    {\n      if(exist[p1[i]])\n\tp3.push_back(p1[i]);\n      if(exist[p2[i]])\n\tp3.push_back(p2[i]);\n    }\n  return p3;\n}\n\nvoid drawTatamiKai(VVI &tatami,vector<P> p3)\n{\n  rep(i,6)\n    {\n      if(!(0 <= p3[i].F && p3[i].F < W && 0 <= p3[i].S && p3[i].S <= H+(H-2))) continue;\n      tatami[p3[i].S][p3[i].F] = 1;\n    }\n}\n\nvoid eraseTatamiKai(VVI &tatami,vector<P> p3)\n{\n  rep(i,6)\n    {\n      if(!(0 <= p3[i].F && p3[i].F < W && 0 <= p3[i].S && p3[i].S <= H+(H-2))) continue;\n      tatami[p3[i].S][p3[i].F] = 0;\n    }\n}\n\nbool check1(VVI &G)// finish check\n{\n  rep(i,H)\n    rep(j,W)\n      if(G[i][j] == 0)\n\treturn false;\n\n  return true;\n}\n\nbool check2(VVI &tatami)//cross check\n{\n \n  rep(i,H+(H-2)+1)\n    rep(j,W)\n    {\n        if(!tatami[i][j])continue;\n        if(i%2 == 0)continue;\n        if(!tatami[i][j])continue;\n\t//cout << j << \" - \" << i << endl;\n     \n\t  int counter = 0;\n\t  rep(l,3)\n\t    {\n\t      int nx = j+dx[l];\n\t      int ny = i+dy[l];\n\t      if(!(0 <= nx && nx < W && 0 <= ny && ny <= H+(H-2)))continue;\n\t      if(tatami[ny][nx])counter++;\n\t      else break;\n\t    }\n\t  if(counter == 3)\n\t    return false;\n\t  //cout << \"counter = \"<< counter << endl;\n\t\n    }\n  return true;\n}\n\nbool check3(VVI &G,int x,int y,int type)\n{\n  int nx1 = x + pdx[type].F;\n  int ny1 = y + pdy[type].F;\n  if(!(0 <= nx1 && nx1 < W && 0 <= ny1 && ny1 < H))return false;\n  if(G[ny1][nx1])return false;\n  \n  int nx2 = x + pdx[type].S;\n  int ny2 = y + pdy[type].S;\n  if(!(0 <= nx2 && nx2 < W && 0 <= ny2 && ny2 < H))return false;\n  if(G[ny2][nx2])return false;\n    \n  return true;\n}\n\nvoid next(int &x,int &y)\n{\n  x++;\n  if(x >= W)\n    x = 0,y++;\n}\n\nvoid dfs(VVI &G,VVI &tatami,int x,int y,int dc)\n{  \n  //cout << x << \" \" <<y << endl;\n  if( dc < y*W+x)return;\n  if(x >= W-1 && y >= H-1)\n    {\n      if(dc != W*H)return;\n      //if(!check1(G))return;\n      if(!check2(tatami))return;\n      cnt++;\n      return;\n    }\n \n  if(G[y][x])\n    {\n      next(x,y);\n      dfs(G,tatami,x,y,dc);\n      return;\n    }\n  if(!check2(tatami))return;\n\n  for(int i=0;i<2;i++)\n    {\n      if(!(check3(G,x,y,i)))continue;\n      int nx1 = x + pdx[i].F;\n      int ny1 = y + pdy[i].F;\n     \n      int nx2 = x + pdx[i].S;\n      int ny2 = y + pdy[i].S;\n     \n      //assert(!G[ny1][nx1]);\n      //assert(!G[ny2][nx2]);\n      G[ny1][nx1] = 1;\n      G[ny2][nx2] = 1;\n      vector<P> p3;\n      if(1)\n\t{\n\t  vector<P> p1 = PtoVec(P(nx1,ny1));\n\t  vector<P> p2 = PtoVec(P(nx2,ny2));\n\t  p3 = Union(p1,p2);\n\t}\n      drawTatamiKai(tatami,p3);\n      int cpx,cpy;\n      cpx = x,cpy = y;\n      next(cpx,cpy);\n      \n      dfs(G,tatami,cpx,cpy,dc+2);\n      eraseTatamiKai(tatami,p3);\n      G[ny1][nx1] = 0;\n      G[ny2][nx2] = 0;\n    }\n}\n\n \nint main()\n{  \n  map<P,int> umekomi;\n  umekomi[P(20,20)] = umekomi[P(20,20)] = 2;\n  umekomi[P(20,19)] = umekomi[P(19,20)] = 2;\n  umekomi[P(20,18)] = umekomi[P(18,20)] = 1;\n  umekomi[P(20,17)] = umekomi[P(17,20)] = 0;\n  umekomi[P(20,16)] = umekomi[P(16,20)] = 0;\n  umekomi[P(20,15)] = umekomi[P(15,20)] = 0;\n  umekomi[P(20,14)] = umekomi[P(14,20)] = 0;\n  umekomi[P(20,13)] = umekomi[P(13,20)] = 0;\n  umekomi[P(20,12)] = umekomi[P(12,20)] = 0;\n  umekomi[P(20,11)] = umekomi[P(11,20)] = 2;\n  umekomi[P(19,18)] = umekomi[P(18,19)] = 2;\n  umekomi[P(19,16)] = umekomi[P(16,19)] = 0;\n  umekomi[P(19,14)] = umekomi[P(14,19)] = 0;\n  umekomi[P(19,12)] = umekomi[P(12,19)] = 0;\n  umekomi[P(18,18)] = umekomi[P(18,18)] = 2;\n  umekomi[P(18,17)] = umekomi[P(17,18)] = 2;\n  umekomi[P(18,16)] = umekomi[P(16,18)] = 1;\n  umekomi[P(18,15)] = umekomi[P(15,18)] = 0;\n  umekomi[P(18,14)] = umekomi[P(14,18)] = 0;\n  umekomi[P(18,13)] = umekomi[P(13,18)] = 0;\n  umekomi[P(18,12)] = umekomi[P(12,18)] = 0;\n  umekomi[P(18,11)] = umekomi[P(11,18)] = 0;\n  umekomi[P(17,16)] = umekomi[P(16,17)] = 2;\n  umekomi[P(17,14)] = umekomi[P(14,17)] = 0;\n  umekomi[P(16,16)] = umekomi[P(16,16)] = 2;\n  umekomi[P(16,15)] = umekomi[P(15,16)] = 2;\n  umekomi[P(16,14)] = umekomi[P(14,16)] = 1;\n  umekomi[P(16,13)] = umekomi[P(13,16)] = 0;\n  umekomi[P(15,14)] = umekomi[P(14,15)] = 2;\n  umekomi[P(15,12)] = umekomi[P(12,15)] = 0;\n\n  while(cin >> H >> W,H|W)\n    {\n      if((H*W)%2 != 0)\n\t{\n\t  cout << 0 << endl;\n\t  continue;\n\t}\n      //clock_t st,ed;\n      //st = clock();\n      if(umekomi.find(P(H,W)) != umekomi.end())\n\t{\n\t  cout << umekomi[P(H,W)] << endl;\n\t  continue;\n\t}\n      cnt = 0;\n      VVI G(H,VI(W,0));\n      VVI tatami(H+(H-2)+1,VI(W,0));\n      dfs(G,tatami,0,0,0);\n      cout << cnt << endl;\n      //cout << \"umekomi[P(\"<<H<<\",\"<<W<<\")] = umekomi[P(\"<<W<<\",\"<<H<<\")] = \" << cnt  << \";\"<< endl;\n      //cout << cnt << endl;\n      umekomi[P(H,W)] = umekomi[P(W,H)] = cnt;\n      //ed = clock();\n      //cout << setiosflags(ios::fixed) << setprecision(10) << (double)(ed-st)/CLOCKS_PER_SEC << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct data{\n\tint fie[23][23];\n\tbool dir[23][23][4];\n\tint cnt[23][23];\n};\n\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint h,w;\nint fie[23][23];\nbool dir[23][23][4];\nint cnt[23][23];\nint ans=0;\n\nstack<data> sta;\n\nvoid push(){\n\tdata dat;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tdat.fie[i][j]=fie[i][j];\n\t\t\tdat.cnt[i][j]=cnt[i][j];\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tdat.dir[i][j][k]=dir[i][j][k];\n\t\t\t}\n\t\t}\n\t}\n\tsta.push(dat);\n}\n\nvoid pop(){\n\tdata dat=sta.top();\n\tsta.pop();\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tfie[i][j]=dat.fie[i][j];\n\t\t\tcnt[i][j]=dat.cnt[i][j];\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tdir[i][j][k]=dat.dir[i][j][k];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid check(int y,int x){\n\tif(y<0 || y>=h || x<0 || x>=w)return;\n\tfor(int i=0;i<4;i++){\n\t\tif(dir[y][x][i])continue;\n\t\tif(fie[y][x] || fie[y+dy[i]][x+dx[i]]){\n\t\t\tdir[y][x][i]=true;\n\t\t\tcnt[y][x]++;\n\t\t}\n\t}\n}\n\nvoid dfs(int c){\n\tif(c*2==h*w){\n\t\tans++;\n\t\treturn;\n\t}\n\tint nx=0,ny=0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(fie[i][j])continue;\n\t\t\tif(cnt[i][j]==4 && !fie[i][j])return;\n\t\t\tif(fie[ny][nx] || cnt[ny][nx]<cnt[i][j]){\n\t\t\t\tny=i;\n\t\t\t\tnx=j;\n\t\t\t}\n\t\t}\n\t}\n\tif(fie[ny][nx] || cnt[ny][nx]==4)return;\n\tfor(int i=0;i<4;i++){\n\t\tif(dir[ny][nx][i])continue;\n\t\tpush();\n\t\tfie[ny][nx]=c+1;\n\t\tfie[ny+dy[i]][nx+dx[i]]=c+1;\n\t\tfor(int j=ny-2;j<=ny+2;j++){\n\t\t\tfor(int k=nx-2;k<=nx+2;k++){\n\t\t\t\tcheck(j,k);\n\t\t\t}\n\t\t}\n\t\tif(i%2==1){\n\t\t\tif(i>=2)nx--;\n\t\t\tif(ny-1>=0 && nx-1>=0){\n\t\t\t\tif(!dir[ny-1][nx-1][2]){\n\t\t\t\t\tcnt[ny-1][nx-1]++;\n\t\t\t\t}\n\t\t\t\tdir[ny-1][nx-1][2]=true;\n\t\t\t\tif(ny-2>=0){\n\t\t\t\t\tif(!dir[ny-2][nx-1][0]){\n\t\t\t\t\t\tcnt[ny-2][nx-1]++;\n\t\t\t\t\t}\n\t\t\t\t\tdir[ny-2][nx-1][0]=true;\n\t\t\t\t}\n\t\t\t\tif(!dir[ny-1][nx-1][3]){\n\t\t\t\t\tcnt[ny-1][nx-1]++;\n\t\t\t\t}\n\t\t\t\tdir[ny-1][nx-1][3]=true;\n\t\t\t\tif(nx-2>=0){\n\t\t\t\t\tif(!dir[ny-1][nx-2][1]){\n\t\t\t\t\t\tcnt[ny-1][nx-2]++;\n\t\t\t\t\t}\n\t\t\t\t\tdir[ny-1][nx-2][1]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ny-1>=0){\n\t\t\t\tif(!dir[ny-1][nx+2][2]){\n\t\t\t\t\tcnt[ny-1][nx+2]++;\n\t\t\t\t}\n\t\t\t\tdir[ny-1][nx+2][2]=true;\n\t\t\t\tif(ny-2>=0){\n\t\t\t\t\tif(!dir[ny-2][nx+2][0]){\n\t\t\t\t\t\tcnt[ny-2][nx+2]++;\n\t\t\t\t\t}\n\t\t\t\t\tdir[ny-2][nx+2][0]=true;\n\t\t\t\t}\n\t\t\t\tif(!dir[ny-1][nx+2][1]){\n\t\t\t\t\tcnt[ny-1][nx+2]++;\n\t\t\t\t}\n\t\t\t\tdir[ny-1][nx+2][1]=true;\n\n\t\t\t\tif(!dir[ny-1][nx+3][3]){\n\t\t\t\t\tcnt[ny-1][nx+3]++;\n\t\t\t\t}\n\t\t\t\tdir[ny-1][nx+3][3]=true;\n\t\t\t}\n\t\t\tif(nx-1>=0){\n\t\t\t\tif(!dir[ny+1][nx-1][0]){\n\t\t\t\t\tcnt[ny+1][nx-1]++;\n\t\t\t\t}\n\t\t\t\tdir[ny+1][nx-1][0]=true;\n\t\t\t\tif(!dir[ny+2][nx-1][2]){\n\t\t\t\t\tcnt[ny+2][nx-1]++;\n\t\t\t\t}\n\t\t\t\tdir[ny+2][nx-1][2]=true;\n\n\t\t\t\tif(!dir[ny+1][nx-1][3]){\n\t\t\t\t\tcnt[ny+1][nx-1]++;\n\t\t\t\t}\n\t\t\t\tdir[ny+1][nx-1][3]=true;\n\t\t\t\tif(nx-2>=0){\n\t\t\t\t\tif(!dir[ny+1][nx-2][1]){\n\t\t\t\t\t\tcnt[ny+1][nx-2]++;\n\t\t\t\t\t}\n\t\t\t\t\tdir[ny+1][nx-2][1]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!dir[ny+1][nx+2][0]){\n\t\t\t\tcnt[ny+1][nx+2]++;\n\t\t\t}\n\t\t\tdir[ny+1][nx+2][0]=true;\n\t\t\tif(!dir[ny+2][nx+2][2]){\n\t\t\t\tcnt[ny+2][nx+2]++;\n\t\t\t}\n\t\t\tdir[ny+2][nx+2][2]=true;\n\t\t\tif(!dir[ny+1][nx+2][1]){\n\t\t\t\tcnt[ny+1][nx+2]++;\n\t\t\t}\n\t\t\tdir[ny+1][nx+2][1]=true;\n\t\t\tif(!dir[ny+1][nx+3][3]){\n\t\t\t\tcnt[ny+1][nx+3]++;\n\t\t\t}\n\t\t\tdir[ny+1][nx+3][3]=true;\n\t\t}else{\n\t\t\tif(i>=2)ny--;\n\t\t\tif(ny-1>=0 && nx-1>=0){\n\t\t\t\tif(!dir[ny-1][nx-1][2]){\n\t\t\t\t\tcnt[ny-1][nx-1]++;\n\t\t\t\t}\n\t\t\t\tdir[ny-1][nx-1][2]=true;\n\t\t\t\tif(ny-2>=0){\n\t\t\t\t\tif(!dir[ny-2][nx-1][0]){\n\t\t\t\t\t\tcnt[ny-2][nx-1]++;\n\t\t\t\t\t}\n\t\t\t\t\tdir[ny-2][nx-1][0]=true;\n\t\t\t\t}\n\t\t\t\tif(!dir[ny-1][nx-1][3]){\n\t\t\t\t\tcnt[ny-1][nx-1]++;\n\t\t\t\t}\n\t\t\t\tdir[ny-1][nx-1][3]=true;\n\t\t\t\tif(nx-2>=0){\n\t\t\t\t\tif(!dir[ny-1][nx-2][1]){\n\t\t\t\t\t\tcnt[ny-1][nx-2]++;\n\t\t\t\t\t}\n\t\t\t\t\tdir[ny-1][nx-2][1]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ny-1>=0){\n\t\t\t\tif(!dir[ny-1][nx+1][2]){\n\t\t\t\t\tcnt[ny-1][nx+1]++;\n\t\t\t\t}\n\t\t\t\tdir[ny-1][nx+1][2]=true;\n\t\t\t\tif(ny-2>=0){\n\t\t\t\t\tif(!dir[ny-2][nx+1][0]){\n\t\t\t\t\t\tcnt[ny-2][nx+1]++;\n\t\t\t\t\t}\n\t\t\t\t\tdir[ny-2][nx+1][0]=true;\n\t\t\t\t}\n\t\t\t\tif(!dir[ny-1][nx+1][1]){\n\t\t\t\t\tcnt[ny-1][nx+1]++;\n\t\t\t\t}\n\t\t\t\tdir[ny-1][nx+1][1]=true;\n\n\t\t\t\tif(!dir[ny-1][nx+2][3]){\n\t\t\t\t\tcnt[ny-1][nx+2]++;\n\t\t\t\t}\n\t\t\t\tdir[ny-1][nx+2][3]=true;\n\t\t\t}\n\t\t\tif(nx-1>=0){\n\t\t\t\tif(!dir[ny+2][nx-1][0]){\n\t\t\t\t\tcnt[ny+2][nx-1]++;\n\t\t\t\t}\n\t\t\t\tdir[ny+2][nx-1][0]=true;\n\t\t\t\tif(!dir[ny+3][nx-1][2]){\n\t\t\t\t\tcnt[ny+3][nx-1]++;\n\t\t\t\t}\n\t\t\t\tdir[ny+3][nx-1][2]=true;\n\n\t\t\t\tif(!dir[ny+2][nx-1][3]){\n\t\t\t\t\tcnt[ny+2][nx-1]++;\n\t\t\t\t}\n\t\t\t\tdir[ny+2][nx-1][3]=true;\n\t\t\t\tif(nx-2>=0){\n\t\t\t\t\tif(!dir[ny+2][nx-2][1]){\n\t\t\t\t\t\tcnt[ny+2][nx-2]++;\n\t\t\t\t\t}\n\t\t\t\t\tdir[ny+2][nx-2][1]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!dir[ny+2][nx+1][0]){\n\t\t\t\tcnt[ny+2][nx+1]++;\n\t\t\t}\n\t\t\tdir[ny+2][nx+1][0]=true;\n\t\t\tif(!dir[ny+3][nx+1][2]){\n\t\t\t\tcnt[ny+3][nx+1]++;\n\t\t\t}\n\t\t\tdir[ny+3][nx+1][2]=true;\n\t\t\tif(!dir[ny+2][nx+1][1]){\n\t\t\t\tcnt[ny+2][nx+1]++;\n\t\t\t}\n\t\t\tdir[ny+2][nx+1][1]=true;\n\t\t\tif(!dir[ny+2][nx+2][3]){\n\t\t\t\tcnt[ny+2][nx+2]++;\n\t\t\t}\n\t\t\tdir[ny+2][nx+2][3]=true;\n\t\t}\n\t\tdfs(c+1);\n\t\tpop();\n\t}\n}\n\n\nvoid solve(){\n\tif(h*w%2==1){\n\t\tprintf(\"0\\n\");\n\t\treturn;\n\t}\n\tans=0;\n\tmemset(fie,false,sizeof(fie));\n\tmemset(dir,false,sizeof(dir));\n\tmemset(cnt,0,sizeof(cnt));\n\tfor(int i=0;i<h;i++){\n\t\tcnt[i][0]++;\n\t\tdir[i][0][3]=true;\n\t\tcnt[i][w-1]++;\n\t\tdir[i][w-1][1]=true;\n\t}\n\tfor(int i=0;i<w;i++){\n\t\tcnt[0][i]++;\n\t\tdir[0][i][2]=true;\n\t\tcnt[h-1][i]++;\n\t\tdir[h-1][i][0]=true;\n\t}\n\tdfs(0);\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&h,&w);\n\t\tif(h==0 && w==0)return 0;\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tYOKO,\n\tTATE,\n};\n\n\nint H,W;\nint ans,limit;\n\nbool check(Type type,int row,int col,int table[20][20]){ //新しく角が寄った点だけ調べる\n\n\tint start_row,end_row,start_col,end_col;\n\tif(type == YOKO){\n\t\tstart_col = col;\n\t\tend_col = min(W-1,col+2);\n\t\tstart_row = row;\n\t\tend_row = min(H-1,row+1);\n\n\t}else{ //type == TATE\n\n\t\tstart_col = col;\n\t\tend_col = min(W-1,col+1);\n\t\tstart_row = row;\n\t\tend_row = min(H-1,row+2);\n\t}\n\n\tfor(int row = start_row; row <= end_row; row++){\n\t\tfor(int col = start_col; col <= end_col; col++){\n\t\t\tif(table[row-1][col-1] == 0 || table[row-1][col] == 0 || table[row][col-1] == 0 || table[row][col] == 0)continue;\n\n\t\t\tif(table[row-1][col-1] != table[row-1][col] && table[row-1][col-1] != table[row][col-1] && table[row-1][col-1] != table[row][col] &&\n\t\t\t\ttable[row-1][col] != table[row][col-1] && table[row-1][col] != table[row][col] && table[row][col-1] != table[row][col])return false;\n\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid recursive(int count,int row,int col,int table[20][20]){ //重複計上を防ぐため、行ごとに畳を並べる\n\tif(row == H){\n\t\tif(count == limit+1)ans++;\n\t\treturn;\n\t}\n\tif(col == W){ //次の行へ\n\t\trecursive(count,row+1,0,table);\n\t\treturn;\n\t}\n\n\tif(table[row][col] != 0){ //既に畳が敷いてある(縦)\n\t\tif(col <= W-2){\n\t\t\trecursive(count,row,col+1,table);\n\t\t}else{ //col == W-1\n\t\t\trecursive(count,row+1,0,table); //次の行へ\n\t\t}\n\t\treturn;\n\t}\n\n\tif(col <= W-2 && table[row][col+1] == 0){ //右に敷ける場合\n\t\tint next_table[20][20];\n\t\tfor(int a = 0; a < H; a++){\n\t\t\tfor(int b = 0; b < W; b++)next_table[a][b] = table[a][b];\n\t\t}\n\t\tnext_table[row][col] = count;\n\t\tnext_table[row][col+1] = count;\n\n\t\tif(check(YOKO,row,col,next_table)){\n\t\t\trecursive(count+1,row,col+2,next_table);\n\t\t}\n\t}\n\tif(row <= H-2 && table[row+1][col] == 0){ //縦に敷ける場合\n\t\tint next_table[20][20];\n\t\tfor(int a = 0; a < H; a++){\n\t\t\tfor(int b = 0; b < W; b++)next_table[a][b] = table[a][b];\n\t\t}\n\t\tnext_table[row][col] = count;\n\t\tnext_table[row+1][col] = count;\n\n\t\tif(check(TATE,row,col,next_table)){\n\t\t\trecursive(count+1,row,col+1,next_table);\n\t\t}\n\n\t}\n\n}\n\n\nint main(){\n\n\tint first_table[20][20];\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tif(H == 0 && W == 0)break;\n\n\t\tif((H*W)%2 == 1){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tans = 0;\n\t\tlimit = (H*W)/2; //limit枚の畳が敷けるはず\n\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tfirst_table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t\trecursive(1,0,0,first_table);\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint h,w;\nint used[21][21];\nint mn=0;\n\nvoid dfs(int cur,int num){\n\tif(cur==h*w){\n\t\tmn++;\n\t\treturn;\n\t}\n\tint curh=cur/w;\n\tint curw=cur%w;\n\tif(used[curh][curw]!=-1){\n\t\tdfs(cur+1,num);\n\t\treturn;\n\t}\n\t// ツ可。ツづ可静敖置\n\tif(curw+1<w&&used[curh][curw+1]==-1){\n\t\tif(!(curw+2<w&&curh>=1&&used[curh-1][curw+1]!=used[curh-1][curw+2]&&used[curh][curw+2]==-1)){\n\t\t\tused[curh][curw]=num;\n\t\t\tused[curh][curw+1]=num;\n\t\t\tdfs(cur+1,num+1);\n\t\t\tused[curh][curw]=-1;\n\t\t\tused[curh][curw+1]=-1;\n\t\t}\n\t}\n\t// ツ縦ツづ可静敖置\n\tif(curh+1<h&&used[curh+1][curw]==-1){\n\t\tif(!(curw+1<w&&curh>=1&&used[curh-1][curw+1]!=used[curh-1][curw]&&used[curh][curw+1]==-1)){\n\t\t\tused[curh][curw]=num;\n\t\t\tused[curh+1][curw]=num;\n\t\t\tdfs(cur+1,num+1);\n\t\t\tused[curh][curw]=-1;\n\t\t\tused[curh+1][curw]=-1;\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(cin>>h>>w&&(h|w)){\n\t\tmn=0;\n\t\tmemset(used,-1,sizeof(used));\n\t\tdfs(0,0);\n\t\tcout<<mn<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cassert>\n#include<climits>\n#include<iomanip>\n#define F first\n#define S second\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<int,bool> IB;\nint H,W;\nint cnt;\nint dx[] = {+0,+0,+1};\nint dy[] = {+1,-1,+0};\nmap<VVI,int> hope;\n\nP pdx[] = {P(0,1),P(0,0)};\nP pdy[] = {P(0,0),P(0,1)};\nint tdx[2][6] = {{+0,+1,+1,+1,+0,-1},{+0,-1,-1,+0,+1,+1}};\nint tdy[2][6] = {{+0,+0,+1,+2,+2,+1},{+0,+1,+3,+4,+3,+1}};\n\nvector<P> PtoVec(P p)\n{\n  vector<P> vec(4);\n  vec[0] = P(p.F,p.S*2-1);//top\n  vec[1] = P(p.F,p.S*2+1);//bottom\n  vec[2] = P(p.F-1,p.S*2);//left\n  vec[3] = P(p.F+0,p.S*2);//right\n  return vec;\n}\n\nvector<P> Union(vector<P> p1,vector<P> p2)\n{\n  vector<P> p3;\n  map<P,bool> exist;\n  rep(i,4)\n      exist[p1[i]] = true;\n\n  bool ok = false;\n  rep(i,4)\n    {\n      if(exist[p2[i]])\n\t{\n\t  ok = true;\n\t  exist[p2[i]] = false;\n\t  continue;\n\t}\n      exist[p2[i]] = true;    \n    }\n  assert(ok);\n  rep(i,4)\n    {\n      if(exist[p1[i]])\n\tp3.push_back(p1[i]);\n      if(exist[p2[i]])\n\tp3.push_back(p2[i]);\n    }\n  return p3;\n}\n\nvoid drawTatamiKai(VVI &tatami,vector<P> p3)\n{\n  rep(i,6)\n    {\n      if(!(0 <= p3[i].F && p3[i].F < W && 0 <= p3[i].S && p3[i].S <= H+(H-2))) continue;\n      tatami[p3[i].S][p3[i].F] = 1;\n    }\n}\n\nvoid eraseTatamiKai(VVI &tatami,vector<P> p3)\n{\n  rep(i,6)\n    {\n      if(!(0 <= p3[i].F && p3[i].F < W && 0 <= p3[i].S && p3[i].S <= H+(H-2))) continue;\n      tatami[p3[i].S][p3[i].F] = 0;\n    }\n}\n\nbool check1(VVI &G)// finish check\n{\n  rep(i,H)\n    rep(j,W)\n      if(G[i][j] == 0)\n\treturn false;\n\n  return true;\n}\n\nbool check2(VVI &tatami)//cross check\n{\n \n  rep(i,H+(H-2)+1)\n    rep(j,W)\n    {\n        if(!tatami[i][j])continue;\n        if(i%2 == 0)continue;\n        if(!tatami[i][j])continue;\n\t//cout << j << \" - \" << i << endl;\n     \n\t  int counter = 0;\n\t  rep(l,3)\n\t    {\n\t      int nx = j+dx[l];\n\t      int ny = i+dy[l];\n\t      if(!(0 <= nx && nx < W && 0 <= ny && ny <= H+(H-2)))continue;\n\t      if(tatami[ny][nx])counter++;\n\t      else break;\n\t    }\n\t  if(counter == 3)\n\t    return false;\n\t  //cout << \"counter = \"<< counter << endl;\n\t\n    }\n  return true;\n}\n\nbool check3(VVI &G,int x,int y,int type)\n{\n  int nx1 = x + pdx[type].F;\n  int ny1 = y + pdy[type].F;\n  if(!(0 <= nx1 && nx1 < W && 0 <= ny1 && ny1 < H))return false;\n  if(G[ny1][nx1])return false;\n  \n  int nx2 = x + pdx[type].S;\n  int ny2 = y + pdy[type].S;\n  if(!(0 <= nx2 && nx2 < W && 0 <= ny2 && ny2 < H))return false;\n  if(G[ny2][nx2])return false;\n    \n  return true;\n}\n\nvoid next(int &x,int &y)\n{\n  x++;\n  if(x >= W)\n    x = 0,y++;\n}\n\nvoid dfs(VVI &G,VVI &tatami,int x,int y,int dc)\n{  \n  //cout << x << \" \" <<y << endl;\n  if( dc < y*W+x)return;\n  if(x >= W-1 && y >= H-1)\n    {\n      if(dc != W*H)return;\n      //if(!check1(G))return;\n      if(!check2(tatami))return;\n      cnt++;\n      return;\n    }\n \n  if(G[y][x])\n    {\n      next(x,y);\n      dfs(G,tatami,x,y,dc);\n      return;\n    }\n  if(!check2(tatami))return;\n\n  for(int i=0;i<2;i++)\n    {\n      if(!(check3(G,x,y,i)))continue;\n      int nx1 = x + pdx[i].F;\n      int ny1 = y + pdy[i].F;\n     \n      int nx2 = x + pdx[i].S;\n      int ny2 = y + pdy[i].S;\n     \n      //assert(!G[ny1][nx1]);\n      //assert(!G[ny2][nx2]);\n      G[ny1][nx1] = 1;\n      G[ny2][nx2] = 1;\n      vector<P> p3;\n      if(1)\n\t{\n\t  vector<P> p1 = PtoVec(P(nx1,ny1));\n\t  vector<P> p2 = PtoVec(P(nx2,ny2));\n\t  p3 = Union(p1,p2);\n\t}\n      drawTatamiKai(tatami,p3);\n      int cpx,cpy;\n      cpx = x,cpy = y;\n      next(cpx,cpy);\n      \n      dfs(G,tatami,cpx,cpy,dc+2);\n      eraseTatamiKai(tatami,p3);\n      G[ny1][nx1] = 0;\n      G[ny2][nx2] = 0;\n    }\n}\n\n \nint main()\n{  \n  map<P,int> umekomi;\n  /*\n   20*20テ」ツ?湘」ツつ嘉」ツ??」ツ?ォテ」ツ?ェテ」ツつ凝」ツ?ィ20テァツァツ津ィツソツ妥」ツ?湘」ツ?凝」ツ?凝」ツつ凝」ツ?ョテ」ツ?ァテ」ツ?敕」ツつ古」ツ?ッテ」ツ?づ」ツつ嘉」ツ?凝」ツ?佚」ツつ?・ツ淞凝」ツつ?ィツセツシテ」ツつ?\n   */\n  umekomi[P(20,20)] = umekomi[P(20,20)] = 2;\n  umekomi[P(20,19)] = umekomi[P(19,20)] = 2;\n  umekomi[P(20,18)] = umekomi[P(18,20)] = 1;\n  umekomi[P(20,17)] = umekomi[P(17,20)] = 0;\n  umekomi[P(20,16)] = umekomi[P(16,20)] = 0;\n  umekomi[P(20,15)] = umekomi[P(15,20)] = 0;\n  umekomi[P(20,14)] = umekomi[P(14,20)] = 0;\n  umekomi[P(20,13)] = umekomi[P(13,20)] = 0;\n  umekomi[P(20,12)] = umekomi[P(12,20)] = 0;\n  umekomi[P(20,11)] = umekomi[P(11,20)] = 2;\n  umekomi[P(19,18)] = umekomi[P(18,19)] = 2;\n  umekomi[P(19,16)] = umekomi[P(16,19)] = 0;\n  umekomi[P(19,14)] = umekomi[P(14,19)] = 0;\n  umekomi[P(19,12)] = umekomi[P(12,19)] = 0;\n  umekomi[P(18,18)] = umekomi[P(18,18)] = 2;\n  umekomi[P(18,17)] = umekomi[P(17,18)] = 2;\n  umekomi[P(18,16)] = umekomi[P(16,18)] = 1;\n  umekomi[P(18,15)] = umekomi[P(15,18)] = 0;\n  umekomi[P(18,14)] = umekomi[P(14,18)] = 0;\n  umekomi[P(18,13)] = umekomi[P(13,18)] = 0;\n  umekomi[P(18,12)] = umekomi[P(12,18)] = 0;\n  umekomi[P(18,11)] = umekomi[P(11,18)] = 0;\n  umekomi[P(17,16)] = umekomi[P(16,17)] = 2;\n  umekomi[P(17,14)] = umekomi[P(14,17)] = 0;\n  umekomi[P(16,16)] = umekomi[P(16,16)] = 2;\n  umekomi[P(16,15)] = umekomi[P(15,16)] = 2;\n  umekomi[P(16,14)] = umekomi[P(14,16)] = 1;\n  umekomi[P(16,13)] = umekomi[P(13,16)] = 0;\n  umekomi[P(15,14)] = umekomi[P(14,15)] = 2;\n  umekomi[P(15,12)] = umekomi[P(12,15)] = 0;\numekomi[P(10,20)] = umekomi[P(20,10)] = 4;\numekomi[P(19,19)] = umekomi[P(19,19)] = 0;\numekomi[P(17,19)] = umekomi[P(19,17)] = 0;\numekomi[P(15,19)] = umekomi[P(19,15)] = 0;\numekomi[P(13,19)] = umekomi[P(19,13)] = 0;\numekomi[P(11,19)] = umekomi[P(19,11)] = 0;\numekomi[P(10,19)] = umekomi[P(19,10)] = 3;\numekomi[P(10,18)] = umekomi[P(18,10)] = 2;\numekomi[P(17,17)] = umekomi[P(17,17)] = 0;\numekomi[P(15,17)] = umekomi[P(17,15)] = 0;\numekomi[P(13,17)] = umekomi[P(17,13)] = 0;\numekomi[P(12,17)] = umekomi[P(17,12)] = 0;\numekomi[P(11,17)] = umekomi[P(17,11)] = 0;\numekomi[P(10,17)] = umekomi[P(17,10)] = 1;\numekomi[P(12,16)] = umekomi[P(16,12)] = 0;\numekomi[P(11,16)] = umekomi[P(16,11)] = 0;\numekomi[P(10,16)] = umekomi[P(16,10)] = 0;\numekomi[P(15,15)] = umekomi[P(15,15)] = 0;\numekomi[P(13,15)] = umekomi[P(15,13)] = 0;\numekomi[P(11,15)] = umekomi[P(15,11)] = 0;\numekomi[P(10,15)] = umekomi[P(15,10)] = 0;\n\n\n  while(cin >> H >> W,H|W)\n    {\n      if((H*W)%2 != 0)\n\t{\n\t  //cout << \"umekomi[P(\"<< W<< \",\"<<H<<\")] = umekomi[P(\"<<H<<\",\"<<W<<\")] = \"<< 0<< \";\" << endl; \n\t  //continue;\n\t  cout << 0 << endl;\n\t  continue;\n\t}\n      //clock_t st,ed;\n      //st = clock();\n      if(umekomi.find(P(H,W)) != umekomi.end())\n\t{\n\t  //continue;\n\t  cout << umekomi[P(H,W)] << endl;\n\t  continue;\n\t}\n      cnt = 0;\n      VVI G(H,VI(W,0));\n      VVI tatami(H+(H-2)+1,VI(W,0));\n      dfs(G,tatami,0,0,0);\n      //cout << \"umekomi[P(\"<< W<< \",\"<<H<<\")] = umekomi[P(\"<<H<<\",\"<<W<<\")] = \"<< cnt<< \";\" << endl; \n  cout << cnt << endl;\n      umekomi[P(H,W)] = umekomi[P(W,H)] = cnt;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tYOKO,\n\tTATE,\n};\n\n\nint H,W;\nint ans,limit;\n\nbool check(Type type,int row,int col,int table[20][20]){ //新しく角が寄った点だけ調べる\n\n\tint start_row,end_row,start_col,end_col;\n\tif(type == YOKO){\n\t\tstart_col = max(1,col);\n\t\tend_col = min(W-1,col+2);\n\t\tstart_row = max(1,row);\n\t\tend_row = min(H-1,row+1);\n\n\t}else{ //type == TATE\n\n\t\tstart_col = max(1,col);\n\t\tend_col = min(W-1,col+1);\n\t\tstart_row = max(1,row);\n\t\tend_row = min(H-1,row+2);\n\t}\n\n\tfor(int row = start_row; row <= end_row; row++){\n\t\tfor(int col = start_col; col <= end_col; col++){\n\t\t\tif(table[row-1][col-1] == 0 || table[row-1][col] == 0 || table[row][col-1] == 0 || table[row][col] == 0)continue;\n\n\t\t\tif(table[row-1][col-1] != table[row-1][col] && table[row-1][col-1] != table[row][col-1] && table[row-1][col-1] != table[row][col] &&\n\t\t\t\ttable[row-1][col] != table[row][col-1] && table[row-1][col] != table[row][col] && table[row][col-1] != table[row][col])return false;\n\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid recursive(int count,int row,int col,int table[20][20]){ //重複計上を防ぐため、行ごとに畳を並べる\n\tif(row == H){\n\t\tif(count == limit+1)ans++;\n\t\treturn;\n\t}\n\tif(col == W){ //次の行へ\n\t\trecursive(count,row+1,0,table);\n\t\treturn;\n\t}\n\n\tif(table[row][col] != 0){ //既に畳が敷いてある(縦)\n\t\tif(col <= W-2){\n\t\t\trecursive(count,row,col+1,table);\n\t\t}else{ //col == W-1\n\t\t\trecursive(count,row+1,0,table); //次の行へ\n\t\t}\n\t\treturn;\n\t}\n\n\tif(col <= W-2 && table[row][col+1] == 0){ //右に敷ける場合\n\t\tint next_table[20][20];\n\t\tfor(int a = 0; a < H; a++){\n\t\t\tfor(int b = 0; b < W; b++)next_table[a][b] = table[a][b];\n\t\t}\n\t\tnext_table[row][col] = count;\n\t\tnext_table[row][col+1] = count;\n\n\t\tif(check(YOKO,row,col,next_table)){\n\t\t\trecursive(count+1,row,col+2,next_table);\n\t\t}\n\t}\n\tif(row <= H-2 && table[row+1][col] == 0){ //縦に敷ける場合\n\t\tint next_table[20][20];\n\t\tfor(int a = 0; a < H; a++){\n\t\t\tfor(int b = 0; b < W; b++)next_table[a][b] = table[a][b];\n\t\t}\n\t\tnext_table[row][col] = count;\n\t\tnext_table[row+1][col] = count;\n\n\t\tif(check(TATE,row,col,next_table)){\n\t\t\trecursive(count+1,row,col+1,next_table);\n\t\t}\n\n\t}\n\n}\n\n\nint main(){\n\n\tint first_table[20][20];\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tif(H == 0 && W == 0)break;\n\n\t\tif((H*W)%2 == 1){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tans = 0;\n\t\tlimit = (H*W)/2; //limit枚の畳が敷けるはず\n\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tfirst_table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t\trecursive(1,0,0,first_table);\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint h,w;\n\nint corner[21][21];\nchar tatami[20][20];\n\nint dfs(int i,int j){\n\tif(i==h) return 1;\n\tif(j==w) return dfs(i+1,0);\n\n\tif(tatami[i][j]=='#') return dfs(i,j+1);\n\n\tint res=0;\n\t// 縦に置く\n\tif(i+1<h && tatami[i+1][j]=='.'){\n\t\tcorner[ i ][ j ]++;\n\t\tcorner[ i ][j+1]++;\n\t\tcorner[i+2][ j ]++;\n\t\tcorner[i+2][j+1]++;\n\t\ttatami[i][j]=tatami[i+1][j]='#';\n\t\tif(corner[i][j]<4 && corner[i][j+1]<4 && corner[i+2][j]<4 && corner[i+2][j+1]<4){\n\t\t\tres+=dfs(i,j+1);\n\t\t}\n\t\ttatami[i][j]=tatami[i+1][j]='.';\n\t\tcorner[ i ][ j ]--;\n\t\tcorner[ i ][j+1]--;\n\t\tcorner[i+2][ j ]--;\n\t\tcorner[i+2][j+1]--;\n\t}\n\t// 横に置く\n\tif(j+1<w && tatami[i][j+1]=='.'){\n\t\tcorner[ i ][ j ]++;\n\t\tcorner[ i ][j+2]++;\n\t\tcorner[i+1][ j ]++;\n\t\tcorner[i+1][j+2]++;\n\t\ttatami[i][j]=tatami[i][j+1]='#';\n\t\tif(corner[i][j]<4 && corner[i][j+2]<4 && corner[i+1][j]<4 && corner[i+1][j+2]<4){\n\t\t\tres+=dfs(i,j+1);\n\t\t}\n\t\ttatami[i][j]=tatami[i][j+1]='.';\n\t\tcorner[ i ][ j ]--;\n\t\tcorner[ i ][j+2]--;\n\t\tcorner[i+1][ j ]--;\n\t\tcorner[i+1][j+2]--;\n\t}\n\treturn res;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&h,&w),h;){\n\t\trep(i,h) rep(j,w) tatami[i][j]='.';\n\t\tprintf(\"%d\\n\",dfs(0,0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint m, n, table[20][20];\n\nbool ifcrossed(){\n    bool flg = false;\n    for(int j = 0; j < m-1 && !flg; j++){\n        for(int k = 0; k < n-1 && !flg; k++){\n            if( table[j][k] != table[j+1][k] &&\n                    table[j][k] != table[j][k+1] &&\n                    table[j+1][k] != table[j+1][k+1] &&\n                    table[j][k+1] != table[j+1][k+1] ){\n                flg = true;\n            }\n        }\n    }\n    return flg;\n}\n\nint tatami(int d){\n    int i;\n    bool cross;\n    for(i = 0; i < m*n; i++){\n        if( table[i/n][i%n] == 0 ) break;\n    }\n    int ans = 0;\n    if( i%n < n-1 && !table[i/n][i%n]  && !table[i/n][i%n+1] ){\n        table[i/n][i%n] = d;\n        table[i/n][i%n+1] = d;\n        if( d == m*n/2 ){\n            bool flg = ifcrossed();\n            if( !flg ) ans++;\n            /*\n            if( !flg ){\n                for(int j = 0; j < m; j++){\n                    for(int k = 0; k < n; k++){\n                        cout << setw(3) << table[j][k];\n                    }\n                    cout << '\\n';\n                }\n                cout << '\\n';\n            }\n            */\n        }else{ \n            if( !ifcrossed() ){\n                ans += tatami(d+1);\n            }\n        }\n        table[i/n][i%n] = 0;\n        table[i/n][i%n+1] = 0;\n    }\n    if( i/n < m-1 && table[i/n][i%n] == 0 && table[i/n+1][i%n] == 0){\n        table[i/n][i%n] = d;\n        table[i/n+1][i%n] = d;\n        if( d == m*n/2 ){\n            bool flg = ifcrossed();\n            if( !flg ) ans++;\n            /*\n            if( !flg ){\n                for(int j = 0; j < m; j++){\n                    for(int k = 0; k < n; k++){\n                        cout << setw(3) << table[j][k];\n                    }\n                    cout << '\\n';\n                }\n                cout << '\\n';\n            }\n            */\n        }else{\n            if( !ifcrossed() ){\n                ans += tatami(d+1);\n            }\n        }\n        table[i/n][i%n] = 0;\n        table[i/n+1][i%n] = 0;\n    }\n    return ans;\n}\n\nint main(){\n    cin >> m >> n;\n    while(m + n > 0){\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                table[i][j] = 0;\n            }\n        }\n        if( m%2 && n%2 ){\n            cout << 0 << endl;\n        }else{\n            cout << tatami(1) << endl;\n        }\n        cin >> m >> n;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tok = ok && !(c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0 && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\tif (count_ >= 4)\n\t{\n\t\tif (!hantei(tatami))\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (tatami[i][j] == 0)\n\t\t\t{\n\t\t\t\tif (i + 1 < H)\n\t\t\t\t{\n\t\t\t\t\tif (tatami[i + 1][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (j + 1 < W)\n\t\t\t\t{\n\t\t\t\t\tif (tatami[i][j + 1] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\", dfs(1, vector<vector<int> >(H, vector<int>(W, 0))));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tbool ok2 = !((c1 * c2 * c3 * c4) && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\n\t\t\tok = ok & ok2;\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0, starty = count_ / W;\n\n\tfor (int i = starty; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (!tatami[i][j])\n\t\t\t{\n\t\t\t\tif (H - i - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i + 1][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (W - j - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i][j + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\", dfs(1, vector<vector<int> >(H, vector<int>(W, 0))));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define UNVISITED -1\n\nint cnt;\nint tatami[20][20];\n\nvoid solve(int r,int c,int now){\n  int y=now/c,x=now%c;\n  if ( r*c == now){\n    rep(i,c)\n      if (tatami[y-1][i]==UNVISITED)return;\n    cnt++;\n    return;\n  }\n\n  if( tatami[y][x]!=UNVISITED){\n    solve(r,c,now+1);\n    return;\n  }\n\n  if ( x==0 && y>0){\n    rep(i,c)if ( tatami[y-1][i]==UNVISITED)return;\n  }\n\n  if (y != 0 && x>0){\n    if ( tatami[y-1][x-1] != tatami[y-1][x] &&\n\t tatami[y-1][x-1] != tatami[y][x-1])return;\n  }\n\n  if (y != r-1 ){\n    tatami[y][x]=tatami[y+1][x]=now;\n    solve(r,c,now+1);\n    tatami[y][x]=tatami[y+1][x]=UNVISITED;\n  }\n  \n  if ( x !=c-1 && tatami[y][x+1]==UNVISITED){\n    tatami[y][x]=tatami[y][x+1]=now;\n    solve(r,c,now+2);\n    tatami[y][x]=tatami[y][x+1]=UNVISITED;\n  }\n  return;\n}\n\nmain(){\n  int r,c;\n  while(cin>>r>>c && r){\n    rep(i,r)rep(j,c)tatami[i][j]=-1;\n    cnt=0;\n    solve(r,c,0);\n    cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint H,W;\nint L=2;\nint tatami[25][25];\nint dfs(int x,int y){\n\tif( x == W ){ y++; x=0; }\n\tint K = y * W + x + 1;\n\tif( y == H ){\n\t\t/*for(int i = 0 ; i < H ; i++){\n\t\t\tfor(int j = 0 ; j < W ; j++) cout << (char)('A'+tatami[i][j]);\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t\treturn 1;\n\t}\n\tif( tatami[y][x] ) return dfs(x+1,y);\n\t\n\tif( x && y ){\n\t\tint a = tatami[y-1][x-1];\n\t\tint b = tatami[y][x-1];\n\t\tint c = tatami[y-1][x];\n\t\tif( a != b && a != c && b != c ){\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint ans = 0;\n\t{\n\t\tint l = L;\n\t\tint h = l / 2;\n\t\tif( l % 2 == 0 && x + l <= W &&  y + h <= H ){\n\t\t\tint f = 0;\n\t\t\tfor(int j = 0 ; j < h ; j++)\n\t\t\t\tfor(int k = 0 ; k < l ; k++)\n\t\t\t\t\tf += tatami[y+j][x+k];\n\t\t\tif(!f){\n\t\t\t\tfor(int j = 0 ; j < h ; j++)\n\t\t\t\t\tfor(int k = 0 ; k < l ; k++)\n\t\t\t\t\t\ttatami[y+j][x+k] = K;\n\t\t\t\tans += dfs(x+1,y);\n\t\t\t\tfor(int j = 0 ; j < h ; j++)\n\t\t\t\t\tfor(int k = 0 ; k < l ; k++)\n\t\t\t\t\t\ttatami[y+j][x+k] = 0;\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\t{\n\t\tint h = L;\n\t\tint l = h / 2;\n\t\tif( h % 2 == 0 && x + l <= W &&  y + h <= H ){\n\t\t\tint f = 0;\n\t\t\tfor(int j = 0 ; j < h ; j++)\n\t\t\t\tfor(int k = 0 ; k < l ; k++)\n\t\t\t\t\tf += tatami[y+j][x+k];\n\t\t\tif(!f){\n\t\t\t\tfor(int j = 0 ; j < h ; j++)\n\t\t\t\t\tfor(int k = 0 ; k < l ; k++)\n\t\t\t\t\t\ttatami[y+j][x+k] = K;\n\t\t\t\tans += dfs(x+1,y);\n\t\t\t\tfor(int j = 0 ; j < h ; j++)\n\t\t\t\t\tfor(int k = 0 ; k < l ; k++)\n\t\t\t\t\t\ttatami[y+j][x+k] = 0;\t\t\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\twhile(cin >> H >> W && H){\n\t\tint ans = 0;\n\t\tfor(int i = 2 ; i <= 2 ; i+=2){\n\t\t\tL = i;\n\t\t\tans += dfs(0,0);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\nint main(){\n  for(int H,W;cin>>H>>W,H;){\n    map<vector<char>,int> m[21][21];\n    m[0][0][vector<char>(W)]=1;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tfor(auto e:m[i][j]){\n\t  auto v=e.first;\n\t  auto d=e.second;\n\t  if(j&&v[j-1]==2){\n\t    v[j]=3;\n\t    m[i][j+1][v]+=d;\n\t  }else if(i&&v[j]==0){\n\t    v[j]=1;\n\t    m[i][j+1][v]+=d;\n\t  }else if(i==0||v[j]==3||j==0||v[j-1]==1){\n\t    if(i+1<H){\n\t      auto nv=v;\n\t      nv[j]=0;\n\t      m[i][j+1][nv]+=d;\n\t    }\n\t    if(j+1<W&&(i==0||v[j+1]!=0)){\n\t      auto nv=v;\n\t      nv[j]=2;\n\t      m[i][j+1][nv]+=d;\n\t    }\n\t  }\n\t}\n      }\n      m[i+1][0]=m[i][W];\n    }\n    int a=0;\n    for(auto e:m[H][0]){\n      a+=e.second;\n    }\n    cout<<a<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint m, n, table[20][20];\n\nint tatami(int d){\n    int i;\n    bool cross;\n    for(i = 0; i < m*n; i++){\n        if( table[i/n][i%n] == 0 ) break;\n    }\n    int ans = 0;\n    if( i%n < n-1 && !table[i/n][i%n]  && !table[i/n][i%n+1] ){\n        table[i/n][i%n] = d;\n        table[i/n][i%n+1] = d;\n        if( d == m*n/2 ){\n            cross = false;\n            for(int j = 0; j < m-1 && !cross; j++){\n                for(int k = 0; k < n-1 && !cross; k++){\n                    if( table[j][k] != table[j+1][k] &&\n                            table[j][k] != table[j][k+1] &&\n                            table[j+1][k] != table[j+1][k+1] &&\n                            table[j][k+1] != table[j+1][k+1] ){\n                        cross = true;\n                    }\n                }\n            }\n            if( !cross ) ans++;\n        }else{ \n            ans += tatami(d+1);\n        }\n        table[i/n][i%n] = 0;\n        table[i/n][i%n+1] = 0;\n    }\n    if( i/n < m-1 && table[i/n][i%n] == 0 && table[i/n+1][i%n] == 0){\n        table[i/n][i%n] = d;\n        table[i/n+1][i%n] = d;\n        if( d == m*n/2 ){\n            cross = false;\n            for(int j = 0; j < m-1 && !cross; j++){\n                for(int k = 0; k < n-1 && !cross; k++){\n                    if( table[j][k] != table[j+1][k] &&\n                            table[j][k] != table[j][k+1] &&\n                            table[j+1][k] != table[j+1][k+1] &&\n                            table[j][k+1] != table[j+1][k+1] ){\n                        cross = true;\n                    }\n                }\n            }\n            if( !cross ) ans++;\n        }else{\n            ans += tatami(d+1);\n        }\n        table[i/n][i%n] = 0;\n        table[i/n+1][i%n] = 0;\n    }\n    return ans;\n}\n\nint main(){\n    cin >> m >> n;\n    while(m + n > 0){\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                table[i][j] = 0;\n            }\n        }\n        if( m%2 && n%2 ){\n            cout << 0 << endl;\n        }else{\n            cout << tatami(1) << endl;\n        }\n        cin >> m >> n;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint ans;\nint h, w;\nint ttm[30][30];\n\nint c;\n\nbool ok(int x, int y){\n    return x == 0 ||\n        y == 0 ||\n        ttm[y][x] == ttm[y][x - 1] ||\n        ttm[y][x - 1] == ttm[y - 1][x - 1] ||\n        ttm[y - 1][x - 1] == ttm[y - 1][x] ||\n        ttm[y - 1][x] == ttm[y][x];\n}\n\nvoid dfs(int x, int y){\n    //cout << x << \" \" << y << endl;\n    //for (int i = 0; i < h; i++){\n    //    for (int j = 0; j < w; j++){\n    //        printf(\"%2d \", ttm[i][j]);\n    //    }\n    //    cout << endl;\n    //}\n    if (x == w){\n        if (y == h - 1){\n            ans++;\n            return;\n        }\n        else dfs(0, y + 1);\n        return;\n    }\n\n    if (ttm[y][x]) dfs(x + 1, y);\n    else{\n        if (x + 1 != w && ttm[y][x + 1] == 0){\n            ttm[y][x] = ttm[y][x + 1] = c++;\n            if (ok(x, y)) dfs(x + 2, y);\n            ttm[y][x] = ttm[y][x + 1] = 0;\n        }\n        if (y + 1 != h && ttm[y + 1][x] == 0){\n            ttm[y][x] = ttm[y + 1][x] = c++;\n            if (ok(x, y)) dfs(x + 1, y);\n            ttm[y][x] = ttm[y + 1][x] = 0;\n        }\n    }\n}\n\nint main(){\n    while (cin >> h >> w && h){\n        ans = 0;\n        c = 1;\n        memset(ttm, 0, sizeof(ttm));\n        dfs(0, 0);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint H, W;\n\nbool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tok = ok && !(c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0 && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\t\t}\n\t}\n\n\treturn ok;\n}\n\nint dfs(int count_, vector<vector<int> > tatami)\n{\n\tif (hantei(tatami) == false) { return 0; }\n\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (tatami[i][j] == 0)\n\t\t\t{\n\t\t\t\tif (i + 1 < H)\n\t\t\t\t{\n\t\t\t\t\tif (tatami[i + 1][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (j + 1 < W)\n\t\t\t\t{\n\t\t\t\t\tif (tatami[i][j + 1] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tcin >> H >> W;\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tcout << dfs(1, vector<vector<int> >(H, vector<int>(W, 0))) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint ans, w, h;\nint a[20][20];\n\nvoid search(int pos){\n\tfor(int i=pos;i<=w*h;i++){\n\t\tif(i==w*h) { ans++; return; }\n\t\tint x = i%w, y = i/w;\n\t\tif(a[x][y]!=-1) continue;\n\t\tif(x!=0&&y!=0&&a[x-1][y]!=a[x-1][y-1]&&a[x-1][y-1]!=a[x][y-1]) return;\n\t\ta[x][y] = i;\n\t\tif(y!=h-1&&a[x][y+1]==-1){\n\t\t\ta[x][y+1] = i;\n\t\t\tsearch(pos+1);\n\t\t\ta[x][y+1] = -1;\n\t\t}\n\t\tif(x!=w-1&&a[x+1][y]==-1){\n\t\t\ta[x+1][y] = i;\n\t\t\tsearch(pos+2);\n\t\t\ta[x+1][y]  = -1;\n\t\t}\n\t\ta[x][y] = -1;\n\t\tbreak;\n\t}\n}\n\nint main(){\n\twhile(cin >> w >> h, w){\n\t\tmemset(a, -1, sizeof(a));\n\t\tans = 0;\n\t\tsearch(0);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint H, W, t[20][20];\nint dy[] = {0, 1}, dx[] = {1,0}; // 横　縦\n\nint judge(int y, int x){\n  map<int, int>m;\n  for(int i = -1; i < 1; i++){\n    for(int j = -1; j < 1; j++){\n      int ny = y+i, nx = x+j;\n      if(ny < 0 || nx < 0 || t[ny][nx] == -1 || m.count(t[ny][nx])) continue;\n      m[t[ny][nx]] = 1;\n    }\n  }\n  if(m.size() < 4) return 1;\n  return 0;\n}\n\nint dfs(int n){\n  int i, j, res = 0;\n  for(i = 0; i < H; i++) for(j = 0; j < W; j++) if(t[i][j] == -1) goto b;\n b:\n\n  if(i == H && j == W) return 1;\n\n  //  int tmp[20][20];\n  //  rep(i, H) rep(j, W) tmp[i][j] = t[i][j];\n\n  t[i][j] = n;\n  rep(d, 2){\n    int x = j+dx[d], y = i+dy[d];\n    if(x < 0 || x >= W || y < 0 || y >= H || t[y][x] != -1) continue;\n    t[y][x] = n;\n    if(judge(i, j)) res += dfs(n+1);\n    t[y][x] = -1;\n  }\n  //  rep(i, H) rep(j, W) t[i][j] = tmp[i][j];\n  t[i][j] = -1;\n\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d%d\", &H, &W) && H+W){\n    memset(t, -1, sizeof(t));\n    printf(\"%d\\n\", dfs(0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint solve_any(int w, vector<int> a){\n    vector<int> dp(w+1, 0);\n    dp[0] = 1;\n    for(int i=0; i<w; i++){\n        for(int e: a){\n            if(i+e > w) continue;\n            dp[i+e] += dp[i];\n        }\n    }\n    return dp[w];\n}\nint solve_alter(int w, vector<vector<int>> a){\n    vector<vector<int>> dp(2, vector<int>(w+1,0));\n    for(int d=0; d<2; d++){\n        for(int e: a[d]){\n            if(e > w) continue;\n            dp[d][e] = 1;\n        }\n    }\n    for(int i=0; i<w; i++){\n        for(int d=0; d<2; d++){\n            for(int e: a[d]){\n                if(i+e > w) continue;\n                dp[d][i+e] += dp[1-d][i];\n            }\n        }\n    }\n    return dp[0][w] + dp[1][w];\n}\n\nint main(){\n    while(1){\n        int h,w;\n        cin >> h >> w;\n        if(h == 0) break;\n\n        if(h > w) swap(h, w);\n        if(h == 1){\n            cout << 1 - w%2 << endl;\n        }else if(h == 2){\n            vector<int> a(w);\n            for(int i=0; i<w; i++) a[i]=i+1;\n            cout << solve_alter(w, {a, {2}}) << endl;\n        }else if(h%2 == 0){\n            cout << solve_alter(w, {{1}, {h-2, h}}) << endl;\n        }else{\n            cout << 2*solve_any(w, {h-1, h+1}) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint H, W, t[20][20];\nint dy[] = {0, 1}, dx[] = {1,0}; // 横　縦\n\nint judge(int y, int x){\n  map<int, int>m;\n  for(int i = -1; i < 1; i++){\n    for(int j = -1; j < 1; j++){\n      int ny = y+i, nx = x+j;\n      if(ny < 0 || nx < 0 || t[ny][nx] == -1 || m.count(t[ny][nx])) continue;\n      m[t[ny][nx]] = 1;\n    }\n  }\n  if(m.size() < 4) return 1;\n  return 0;\n}\n\nint dfs(int n){\n  int i, j, res = 0;\n  for(i = 0; i < H; i++) for(j = 0; j < W; j++) if(t[i][j] == -1) goto b;\n b:\n\n  if(i == H && j == W) return 1;\n\n  t[i][j] = n;\n  rep(d, 2){\n    int x = j+dx[d], y = i+dy[d];\n    if(x < 0 || x >= W || y < 0 || y >= H || t[y][x] != -1) continue;\n    t[y][x] = n;\n    if(judge(i, j)) res += dfs(n+1);\n    t[y][x] = -1;\n  }\n  t[i][j] = -1;\n\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d%d\", &H, &W) && H+W){\n    memset(t, -1, sizeof(t));\n    if(H%2 && W&2) puts(\"0\");\n    else if(H == W) puts(\"2\");\n    else printf(\"%d\\n\", dfs(0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint ans;\nint h, w;\nint ttm[30][30];\n\nint c;\n\nbool ok(int x, int y){\n    return x == 0 ||\n        y == 0 ||\n        ttm[y][x] == ttm[y][x - 1] ||\n        ttm[y][x - 1] == ttm[y - 1][x - 1] ||\n        ttm[y - 1][x - 1] == ttm[y - 1][x] ||\n        ttm[y - 1][x] == ttm[y][x];\n}\n\nvoid dfs(int x, int y){\n    if (x == w){\n        if (y == h - 1){\n            ans++;\n        }\n        else dfs(0, y + 1);\n        return;\n    }\n\n    if (ttm[y][x]){\n        dfs(x + 1, y);\n        return;\n    }\n    if (x + 1 != w && ttm[y][x + 1] == 0){\n        ttm[y][x] = ttm[y][x + 1] = c++;\n        if (ok(x, y)) dfs(x + 2, y);\n        ttm[y][x] = ttm[y][x + 1] = 0;\n    }\n    if (y + 1 != h && ttm[y + 1][x] == 0){\n        ttm[y][x] = ttm[y + 1][x] = c++;\n        if (ok(x, y)) dfs(x + 1, y);\n        ttm[y][x] = ttm[y + 1][x] = 0;\n    }\n}\n\nint main(){\n    while (cin >> h >> w && h){\n        ans = 0;\n        c = 1;\n        for (int i = 0; i < h; i++)\n            for (int j = 0; j < w; j++)\n                ttm[i][j] = 0;\n        dfs(0, 0);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nint board[44][44];\nint h, w;\n\nint DFS(int x, int y, int n){\n\tint ret = 0;\n\twhile(board[x][y] != 0){\n\t\tx++;\n\t\tif(x > w){\n\t\t\ty++;\n\t\t\tx = 1;\n\t\t\tif(y > h)return 1;\n\t\t}\n\t}\n\t//たて向き\n\tif(board[x][y+1]==0){\n\t\tint check = 0;\n\t\tif(board[x][y-1] != board[x+1][y-1])check++;\n\t\tif(board[x+1][y-1] != board[x+1][y])check++;\n\t\tif(check != 2){\n\t\t\tboard[x][y] = n;\n\t\t\tboard[x][y+1] = n;\n\t\t\tret += DFS(x,y,n+1);\n\t\t\tboard[x][y] = 0;\n\t\t\tboard[x][y+1] = 0;\n\t\t}\n\t}\n\t//よこ向き\n\tif(board[x+1][y]==0){\n\t\tint check = 0;\n\t\tif(board[x+1][y-1] != board[x+2][y-1])check++;\n\t\tif(board[x+2][y] != board[x+2][y-1])check++;\n\t\tif(check != 2){\n\t\t\tboard[x][y] = n;\n\t\t\tboard[x+1][y] = n;\n\t\t\tret += DFS(x,y,n+1);\n\t\t\tboard[x][y] = 0;\n\t\t\tboard[x+1][y] = 0;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(1){\n\t\tmemset(board, 0, sizeof(board));\n\t\tcin >> h>> w;\n\t\tif(h==0)break;\n\t\tREP(i,w+2){\n\t\t\tboard[i][0] = 1000;\n\t\t\tboard[i][h+1] = 1000;\n\t\t}\n\t\tREP(i,h+2){\n\t\t\tboard[0][i] = 1000;\n\t\t\tboard[w+1][i] = 1000;\n\t\t}\n\t\tif(h==0)return 0;\n\t\tcout << DFS(1, 1, 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cassert>\n#include<climits>\n#include<iomanip>\n#define F first\n#define S second\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<int,bool> IB;\nint H,W;\nint cnt;\nint dx[] = {+0,+0,+1};\nint dy[] = {+1,-1,+0};\nmap<VVI,int> hope;\n\nP pdx[] = {P(0,1),P(0,0)};\nP pdy[] = {P(0,0),P(0,1)};\nint tdx[2][6] = {{+0,+1,+1,+1,+0,-1},{+0,-1,-1,+0,+1,+1}};\nint tdy[2][6] = {{+0,+0,+1,+2,+2,+1},{+0,+1,+3,+4,+3,+1}};\n\nvector<P> PtoVec(P p)\n{\n  vector<P> vec(4);\n  vec[0] = P(p.F,p.S*2-1);//top\n  vec[1] = P(p.F,p.S*2+1);//bottom\n  vec[2] = P(p.F-1,p.S*2);//left\n  vec[3] = P(p.F+0,p.S*2);//right\n  return vec;\n}\n\nvector<P> Union(vector<P> p1,vector<P> p2)\n{\n  vector<P> p3;\n  map<P,bool> exist;\n  rep(i,4)\n      exist[p1[i]] = true;\n\n  bool ok = false;\n  rep(i,4)\n    {\n      if(exist[p2[i]])\n\t{\n\t  ok = true;\n\t  exist[p2[i]] = false;\n\t  continue;\n\t}\n      exist[p2[i]] = true;    \n    }\n  assert(ok);\n  rep(i,4)\n    {\n      if(exist[p1[i]])\n\tp3.push_back(p1[i]);\n      if(exist[p2[i]])\n\tp3.push_back(p2[i]);\n    }\n  return p3;\n}\n\nvoid drawTatamiKai(VVI &tatami,vector<P> p3)\n{\n  rep(i,6)\n    {\n      if(!(0 <= p3[i].F && p3[i].F < W && 0 <= p3[i].S && p3[i].S <= H+(H-2))) continue;\n      tatami[p3[i].S][p3[i].F] = 1;\n    }\n}\n\nvoid eraseTatamiKai(VVI &tatami,vector<P> p3)\n{\n  rep(i,6)\n    {\n      if(!(0 <= p3[i].F && p3[i].F < W && 0 <= p3[i].S && p3[i].S <= H+(H-2))) continue;\n      tatami[p3[i].S][p3[i].F] = 0;\n    }\n}\n\nbool check1(VVI &G)// finish check\n{\n  rep(i,H)\n    rep(j,W)\n      if(G[i][j] == 0)\n\treturn false;\n\n  return true;\n}\n\nbool check2(VVI &tatami)//cross check\n{\n \n  rep(i,H+(H-2)+1)\n    rep(j,W)\n    {\n        if(!tatami[i][j])continue;\n        if(i%2 == 0)continue;\n        if(!tatami[i][j])continue;\n     \n\t  int counter = 0;\n\t  rep(l,3)\n\t    {\n\t      int nx = j+dx[l];\n\t      int ny = i+dy[l];\n\t      if(!(0 <= nx && nx < W && 0 <= ny && ny <= H+(H-2)))continue;\n\t      if(tatami[ny][nx])counter++;\n\t      else break;\n\t    }\n\t  if(counter == 3)\n\t    return false;\n\t\n    }\n  return true;\n}\n\nbool check3(VVI &G,int x,int y,int type)\n{\n  int nx1 = x + pdx[type].F;\n  int ny1 = y + pdy[type].F;\n  if(!(0 <= nx1 && nx1 < W && 0 <= ny1 && ny1 < H))return false;\n  if(G[ny1][nx1])return false;\n  \n  int nx2 = x + pdx[type].S;\n  int ny2 = y + pdy[type].S;\n  if(!(0 <= nx2 && nx2 < W && 0 <= ny2 && ny2 < H))return false;\n  if(G[ny2][nx2])return false;\n    \n  return true;\n}\n\nvoid next(int &x,int &y)\n{\n  x++;\n  if(x >= W)\n    x = 0,y++;\n}\n\nvoid dfs(VVI &G,VVI &tatami,int x,int y,int dc)\n{  \n  //cout << x << \" \" <<y << endl;\n  if( dc < y*W+x)return;\n  if(x >= W-1 && y >= H-1)\n    {\n      if(dc != W*H)return;\n      if(!check2(tatami))return;\n      cnt++;\n      return;\n    }\n \n  if(G[y][x])\n    {\n      next(x,y);\n      dfs(G,tatami,x,y,dc);\n      return;\n    }\n  if(!check2(tatami))return;\n\n  for(int i=0;i<2;i++)\n    {\n      if(!(check3(G,x,y,i)))continue;\n      int nx1 = x + pdx[i].F;\n      int ny1 = y + pdy[i].F;\n     \n      int nx2 = x + pdx[i].S;\n      int ny2 = y + pdy[i].S;\n     \n\n      G[ny1][nx1] = 1;\n      G[ny2][nx2] = 1;\n      vector<P> p3;\n      if(1)\n\t{\n\t  vector<P> p1 = PtoVec(P(nx1,ny1));\n\t  vector<P> p2 = PtoVec(P(nx2,ny2));\n\t  p3 = Union(p1,p2);\n\t}\n      drawTatamiKai(tatami,p3);\n      int cpx,cpy;\n      cpx = x,cpy = y;\n      next(cpx,cpy);\n      \n      dfs(G,tatami,cpx,cpy,dc+2);\n      eraseTatamiKai(tatami,p3);\n      G[ny1][nx1] = 0;\n      G[ny2][nx2] = 0;\n    }\n}\n\n \nint main()\n{  \n  map<P,int> umekomi;\n  umekomi[P(20,20)] = umekomi[P(20,20)] = 2;\n  umekomi[P(20,19)] = umekomi[P(19,20)] = 2;\n  umekomi[P(20,18)] = umekomi[P(18,20)] = 1;\n  umekomi[P(20,17)] = umekomi[P(17,20)] = 0;\n  umekomi[P(20,16)] = umekomi[P(16,20)] = 0;\n  umekomi[P(20,15)] = umekomi[P(15,20)] = 0;\n  umekomi[P(20,14)] = umekomi[P(14,20)] = 0;\n  umekomi[P(20,13)] = umekomi[P(13,20)] = 0;\n  umekomi[P(20,12)] = umekomi[P(12,20)] = 0;\n  umekomi[P(20,11)] = umekomi[P(11,20)] = 2;\n  umekomi[P(19,18)] = umekomi[P(18,19)] = 2;\n  umekomi[P(19,16)] = umekomi[P(16,19)] = 0;\n  umekomi[P(19,14)] = umekomi[P(14,19)] = 0;\n  umekomi[P(19,12)] = umekomi[P(12,19)] = 0;\n  umekomi[P(18,18)] = umekomi[P(18,18)] = 2;\n  umekomi[P(18,17)] = umekomi[P(17,18)] = 2;\n  umekomi[P(18,16)] = umekomi[P(16,18)] = 1;\n  umekomi[P(18,15)] = umekomi[P(15,18)] = 0;\n  umekomi[P(18,14)] = umekomi[P(14,18)] = 0;\n  umekomi[P(18,13)] = umekomi[P(13,18)] = 0;\n  umekomi[P(18,12)] = umekomi[P(12,18)] = 0;\n  umekomi[P(18,11)] = umekomi[P(11,18)] = 0;\n  umekomi[P(17,16)] = umekomi[P(16,17)] = 2;\n  umekomi[P(17,14)] = umekomi[P(14,17)] = 0;\n  umekomi[P(16,16)] = umekomi[P(16,16)] = 2;\n  umekomi[P(16,15)] = umekomi[P(15,16)] = 2;\n  umekomi[P(16,14)] = umekomi[P(14,16)] = 1;\n  umekomi[P(16,13)] = umekomi[P(13,16)] = 0;\n  umekomi[P(15,14)] = umekomi[P(14,15)] = 2;\n  umekomi[P(15,12)] = umekomi[P(12,15)] = 0;\n\n  while(cin >> H >> W,H|W)\n    {\n      if((H*W)%2 != 0)\n\t{\n\t  cout << 0 << endl;\n\t  continue;\n\t}\n  \n      if(umekomi.find(P(H,W)) != umekomi.end())\n\t{\n\t  cout << umekomi[P(H,W)] << endl;\n\t  continue;\n\t}\n      cnt = 0;\n      VVI G(H,VI(W,0));\n      VVI tatami(H+(H-2)+1,VI(W,0));\n      dfs(G,tatami,0,0,0);\n      cout << cnt << endl;\n  \n      umekomi[P(H,W)] = umekomi[P(W,H)] = cnt;\n      }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nvvi ta;\nint n,m,out;\nbool F(){\n\tbool h=true;\n\trep(i,n-1)rep(j,m-1){\n\t\tint a=ta[i][j],b=ta[i+1][j],c=ta[i][j+1],d=ta[i+1][j+1];\n\t\tif(a*b*c*d==0)break;\n\t\tif(a==b||a==c||a==d||b==c||b==d||c==d);\n\t\telse h=false;\n\t}\n\treturn h;\n}\nvoid f(int d,int a,int b){\n\tif(a==n){out+=F();return;}\n\tif(b==m){f(d,a+1,0);return;}\n\t\n\tif(ta[a][b]){f(d,a,b+1);return;}\n\t//tate\n\tif(a!=n-1&&ta[a+1][b]==0){\n\t\tta[a][b]=ta[a+1][b]=d;\n\t\tif(F())f(d+1,a,b+1);\n\t\tta[a][b]=ta[a+1][b]=0;\n\t}\n\t//yoko\n\tif(b!=m-1&&ta[a][b+1]==0){\n\t\tta[a][b]=ta[a][b+1]=d;\n\t\tif(F())f(d+1,a,b+2);\n\t\tta[a][b]=ta[a][b+1]=0;\t\n\t}\n}\nint main(){\n\twhile(cin>>n>>m,n+m){\n\t\tta=vvi(n,vi(m));\n\t\tout=0;\n\t\tf(1,0,0);\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint h,w;\nint ba[20][20];\n\n// horizontal -> 1:2\n// vartically -> 3\n//               4\nint solve(int x, int y) {\n//  cout << x << \" \"<< y << endl;\n//  REP(i,h) {REP(j,w)cout<<ba[i][j];cout<<endl;}\n  if (y==h) return 1;\n  if (x==w) return solve(0,y+1);\n  if (ba[y][x]) return solve(x+1,y);\n  // 横置き\n  int res = 0;\n  if (x<w-1&&ba[y][x+1]==0) {\n    if (x&&y &&\n        (ba[y-1][x-1]==2 || ba[y-1][x-1]==4) &&\n        (ba[y-1][x] == 1 || ba[y-1][x] == 4) &&\n        (ba[y][x-1] == 2 || ba[y][x-1] == 3)); // cross\n    else {\n      ba[y][x] = 1;\n      ba[y][x+1] = 2;\n      res += solve(x+1,y);\n      ba[y][x] = ba[y][x+1] = 0;\n    }\n  }\n  if (y<h-1&&ba[y+1][x]==0) {\n    if (x&&y &&\n        (ba[y-1][x-1]==2 || ba[y-1][x-1]==4) &&\n        (ba[y-1][x] == 1 || ba[y-1][x] == 4) &&\n        (ba[y][x-1] == 2 || ba[y][x-1] == 3)); // cross\n    else {\n      ba[y][x] = 3;\n      ba[y+1][x] = 4;\n      res += solve(x+1,y);\n      ba[y][x] = ba[y+1][x] = 0;\n    }\n  }\n  return res;\n}\nint main() {                    \n  \n  while(cin >> h >> w,h||w) {\n    cout << solve(0,0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nint h,w;\nint dfs(vvi &f,int x,int i);\nvi flags;\nbool check(const vvi &f,int k,int l){\n    for(int i=max(k-1,0);i+1<h && i<=k+1;i++){\n        for(int j=max(l-1,0);j+1<w && j<=l+1;j++){\n            int zcnt=0;\n            set<int> s;\n            for(int di=0;di<2;di++){\n                for(int dj=0;dj<2;dj++){\n                    if(f[i+di][j+dj]!=0) s.insert(f[i+di][j+dj]);                      \n                }\n            }\n            if(zcnt+s.size()==4) return false;\n        }\n    }\n    return true;\n}\nint impl(vvi &f,int i,int j,int x){\n    int res=0;\n    int k=1;\n    if(0<=i+k-1 && i+k<h && f[i+k-1][j]==f[i+k][j]){\n        f[i+k-1][j]=f[i+k][j]=x;\n        if(check(f,i,j)) res+=dfs(f,x+1,i);\n        f[i+k-1][j]=f[i+k][j]=0;\n    }\n    if(0<=j+k-1 && j+k<w && f[i][j+k-1]==f[i][j+k]){\n        f[i][j+k-1]=f[i][j+k]=x;\n        if(check(f,i,j)) res+=dfs(f,x+1,i);\n        f[i][j+k-1]=f[i][j+k]=0;\n    }\n    return res;\n}\nint dfs(vvi &f,int x,int i){\n    if(i==h) return 1;\n    for(int j=0;j<w;j++){\n        if(!f[i][j]){\n            return impl(f,i,j,x);\n        }\n    }\n    return dfs(f,x,i+1);\n}\nint solve(){\n    flags.assign(h*w,0);\n    vvi tmpf(h,vi(w,0));\n    return dfs(tmpf,1,0);\n}\n\nint main(){\n    while(cin>>h>>w,h){\n        cout<<solve()<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint H,W,ans;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\t//drul\nbool cand[20][20][4];\nbool done[20][20];\ntypedef vector<int> vi;\nvoid ers_(int x,int y,int d,vi &vx,vi &vy,vi &vd){\n\tif(0<=x&&x<H&&0<=y&&y<W&&!done[x][y]&&cand[x][y][d]){\n\t\tcand[x][y][d]=0;\n\t\tvx.pb(x),vy.pb(y),vd.pb(d);\n\t}\n}\nvoid ers(int x,int y,int d,vi &vx,vi &vy,vi &vd){\n\ters_(x,y,d,vx,vy,vd);\n\ters_(x+dx[d],y+dy[d],(d+2)%4,vx,vy,vd);\n}\nbool ok(int x,int y){\n\treturn 0<=x&&x<H&&0<=y&&y<W&&!done[x][y];\n}\nvoid dfs(int e,int f,int cnt){\n\t// printf(\"cnt=%d   %d,%d\\n\",cnt,e,f);\n\t// rep(i,H){\n\t// \trep(j,W) cout<<done[i][j];\n\t// \tputs(\"\");\n\t// }\n\tif(cnt==H*W/2){\n\t\tans++;\n\t\treturn;\n\t}\n\trep(d,4) if(ok(e+dx[d],f+dy[d])&&cand[e][f][d]){\n//\t\tshow(d);\n\t\tvector<int> vx,vy,vd;\n\t\tint E=e+dx[d],F=f+dy[d];\n\t\tint a=min(e,E),b=min(f,F),A=max(e,E),B=max(f,F);\n\t\ters(a-1,b-1,2,vx,vy,vd);\n\t\ters(a-1,b-1,3,vx,vy,vd);\n\t\ters(a-1,B+1,2,vx,vy,vd);\n\t\ters(a-1,B+1,1,vx,vy,vd);\n\t\ters(A+1,b-1,0,vx,vy,vd);\n\t\ters(A+1,b-1,3,vx,vy,vd);\n\t\ters(A+1,B+1,0,vx,vy,vd);\n\t\ters(A+1,B+1,1,vx,vy,vd);\n\t\tdone[e][f]=1,done[E][F]=1;\n\t\tint nx=-1,ny=-1;\n\t\t{\n\t\t\tint mn=5;\n\t\t\trep(x,H) rep(y,W) if(!done[x][y]){\n\t\t\t\tint cs=0;\n\t\t\t\trep(di,4) if(cand[x][y][di]) cs++;\n\t\t\t\tif(mn>cs){\n\t\t\t\t\tmn=cs;\n\t\t\t\t\tnx=x,ny=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(nx,ny,cnt+1);\n\t\t{\t//rmv\n\t\t\tdone[a][b]=0,done[A][B]=0;\n\t\t\trep(i,vx.size()){\n\t\t\t\tcand[vx[i]][vy[i]][vd[i]]=1;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin>>H>>W;\n\t\tif(H==0) break;\n\t\tif(H*W%2){\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\t\tans=0;\n\t\trep(i,H) rep(j,W){\n\t\t\tcand[i][j][0]=(i!=H-1);\n\t\t\tcand[i][j][1]=(j!=W-1);\n\t\t\tcand[i][j][2]=(i!=0);\n\t\t\tcand[i][j][3]=(j!=0);\n\t\t}\n\t\tdfs(0,0,0);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tok = ok && !(c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0 && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\tif (hantei(tatami) == false) { return 0; }\n\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (tatami[i][j] == 0)\n\t\t\t{\n\t\t\t\tif (i + 1 < H)\n\t\t\t\t{\n\t\t\t\t\tif (tatami[i + 1][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (j + 1 < W)\n\t\t\t\t{\n\t\t\t\t\tif (tatami[i][j + 1] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\", dfs(1, vector<vector<int> >(H, vector<int>(W, 0))));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tbool ok2 = !((c1 * c2 * c3 * c4) && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\n\t\t\tok = ok && ok2;\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\tif (hantei(tatami) == false) { return 0; }\n\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (!tatami[i][j])\n\t\t\t{\n\t\t\t\tif (H - i - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i + 1][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (W - j - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i][j + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\", dfs(1, vector<vector<int> >(H, vector<int>(W, 0))));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tok = ok && !(c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0 && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\tif (hantei(tatami) == false) { return 0; }\n\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (tatami[i][j] == 0)\n\t\t\t{\n\t\t\t\tif (i + 1 < H)\n\t\t\t\t{\n\t\t\t\t\tif (tatami[i + 1][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (j + 1 < W)\n\t\t\t\t{\n\t\t\t\t\tif (tatami[i][j + 1] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tcin >> H >> W;\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tcout << 1 << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << dfs(1, vector<vector<int> >(H, vector<int>(W, 0))) << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tok = ok && !(c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0 && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\tif (hantei(tatami) == false) { return 0; }\n\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (tatami[i][j] == 0)\n\t\t\t{\n\t\t\t\tif (i + 1 < H)\n\t\t\t\t{\n\t\t\t\t\tif (tatami[i + 1][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (j + 1 < W)\n\t\t\t\t{\n\t\t\t\t\tif (tatami[i][j + 1] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\", dfs(1, vector<vector<int> >(H, vector<int>(W, 0))));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint H, W;\n\nbool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tok = ok && !(c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0 && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\t\t}\n\t}\n\n\treturn ok;\n}\n\nint dfs(int count_, vector<vector<int> > tatami)\n{\n\tif (hantei(tatami) == false) { return 0; }\n\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (tatami[i][j] == 0)\n\t\t\t{\n\t\t\t\tif (i + 1 < H)\n\t\t\t\t{\n\t\t\t\t\tif (tatami[i + 1][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (j + 1 < W)\n\t\t\t\t{\n\t\t\t\t\tif (tatami[i][j + 1] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tcin >> H >> W;\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tcout << 1 << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << dfs(1, vector<vector<int> >(H, vector<int>(W, 0))) << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int H, W;\n    while(cin >> H >> W, H) {\n        vector<vector<int>> tatami(H, vector<int>(W, -1));\n\n        auto cond_check = [&](int y, int x) {\n            return y == 0 || x == 0\n            || tatami[y - 1][x - 1] == tatami[y - 1][x] || tatami[y][x - 1] == tatami[y][x]\n            || tatami[y - 1][x - 1] == tatami[y][x - 1] || tatami[y - 1][x] == tatami[y][x];\n        };\n\n        long long id = 0;\n        function<int(int, int)> solve = [&](int y, int x) {\n            if(y == H - 1 && x == W - 1 && tatami[y][x] != -1) return 1;\n            if(x >= W) return solve(y + 1, 0);\n            if(tatami[y][x] != -1) return solve(y, x + 1);\n            if(!cond_check(y, x)) return 0;\n\n            int res = 0;\n            if(y + 1 < H) { // put vert\n                tatami[y][x] = tatami[y + 1][x] = id++;\n                res += solve(y, x + 1);\n                tatami[y][x] = tatami[y + 1][x] = -1;\n            }\n            if(x + 1 < W && tatami[y][x + 1] == -1) { // put hori\n                tatami[y][x] = tatami[y][x + 1] = id++;\n                res += solve(y, x + 1);\n                tatami[y][x] = tatami[y][x + 1] = -1;\n            }\n\n            return res;\n        };\n\n        cout << solve(0, 0) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tbool ok2 = !((c1 * c2 * c3 * c4) && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\n\t\t\tok = ok && ok2;\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\tif (hantei(tatami) == false) { return 0; }\n\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (tatami[i][j] == 0)\n\t\t\t{\n\t\t\t\tif (i + 1 < H)\n\t\t\t\t{\n\t\t\t\t\tif (tatami[i + 1][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (j + 1 < W)\n\t\t\t\t{\n\t\t\t\t\tif (tatami[i][j + 1] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\", dfs(1, vector<vector<int> >(H, vector<int>(W, 0))));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt dp[30];\nInt fib(Int n,int x,int y){\n  if(n<0) return 0;\n  if(n<=1) return 1;\n  if(~dp[n]) return dp[n];\n  return dp[n]=fib(n-x,x,y)+fib(n-y,x,y);\n}\nsigned main(){\n  Int h,w;\n  while(cin>>h>>w,h){\n    memset(dp,-1,sizeof(dp));\n    if((h*w)&1){\n      cout<<0<<endl;\n      continue;\n    }\n    \n    if(h>w) swap(h,w);\n    if(h==1){\n      cout<<1<<endl;\n      continue;\n    }\n    if(h==3){\n      cout<<2*fib(w/2,1,2)<<endl;\n      continue;\n    }\n    \n    if(h&1) swap(h,w);\n    \n    cout<<fib(w,h-1,h+1)+fib(w+1,h-1,h+1)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tok = ok && !(c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0 && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\tif (hantei(tatami) == false) { return 0; }\n\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (tatami[i][j] == 0)\n\t\t\t{\n\t\t\t\tif (i + 1 < H)\n\t\t\t\t{\n\t\t\t\t\tif (tatami[i + 1][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (j + 1 < W)\n\t\t\t\t{\n\t\t\t\t\tif (tatami[i][j + 1] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\", dfs(1, vector<vector<int> >(H, vector<int>(W, 0))));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt dp[30];\nInt fib(Int n,int x,int y){\n  if(n<0) return 0;\n  if(n<=1) return 1;\n  if(~dp[n]) return dp[n];\n  return dp[n]=fib(n-x,x,y)+fib(n-y,x,y);\n}\nsigned main(){\n  Int h,w;\n  while(cin>>h>>w,h){\n    memset(dp,-1,sizeof(dp));\n    if((h*w)&1){\n      cout<<0<<endl;\n      continue;\n    }\n    \n    if(h>w) swap(h,w);\n    if(h==1){\n      cout<<1<<endl;\n      continue;\n    }\n    if(h==2){\n      cout<<fib(w,1,2)<<endl;\n      continue;\n    }\n    if(h==3){\n      cout<<2*fib(w/2,1,2)<<endl;\n      continue;\n    }\n    \n    if(h&1) swap(h,w);\n    \n    cout<<fib(w,h-1,h+1)+fib(w+1,h-1,h+1)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<array>\n#include<map>\n\nusing namespace std;\n\nint main(){\n  for(int H,W;cin>>H>>W,H;){\n    map<array<char,20>,int> m[21][21];\n    m[0][0][array<char,20>()]=1;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tfor(auto e:m[i][j]){\n\t  auto v=e.first;\n\t  auto d=e.second;\n\t  if(j&&v[j-1]==2){\n\t    v[j]=3;\n\t    m[i][j+1][v]+=d;\n\t  }else if(i&&v[j]==0){\n\t    v[j]=1;\n\t    m[i][j+1][v]+=d;\n\t  }else if(i==0||v[j]==3||j==0||v[j-1]==1){\n\t    if(i+1<H){\n\t      auto nv=v;\n\t      nv[j]=0;\n\t      m[i][j+1][nv]+=d;\n\t    }\n\t    if(j+1<W&&(i==0||v[j+1]!=0)){\n\t      auto nv=v;\n\t      nv[j]=2;\n\t      m[i][j+1][nv]+=d;\n\t    }\n\t  }\n\t}\n      }\n      m[i+1][0]=m[i][W];\n    }\n    int a=0;\n    for(auto e:m[H][0]){\n      a+=e.second;\n    }\n    cout<<a<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tbool ok2 = !((c1 * c2 * c3 * c4) && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\n\t\t\tok = ok & ok2;\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0, starty = count_ / W;\n\n\tfor (int i = starty; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (!tatami[i][j])\n\t\t\t{\n\t\t\t\tif (H - i - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i + 1][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (W - j - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i][j + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvector<vector<int> > start(H, vector<int>(W, 0)); start[0][0] = 1; start[0][1] = 1;\n\n\t\t\tprintf(\"%d\\n\", dfs(2, start) * 2);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <stdio.h>\n#include <string.h>\n\nusing namespace std;\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nint board[44][44];\nint h, w;\n\nint DFS(int x, int y, int n){\n\tint ret = 0;\n\twhile(board[x][y] != 0){\n\t\tx++;\n\t\tif(x > w){\n\t\t\ty++;\n\t\t\tx = 1;\n\t\t\tif(y > h)return 1;\n\t\t}\n\t}\n\t//たて向き\n\tif(board[x][y+1]==0){\n\t\tint check = 0;\n\t\tif(board[x][y-1] != board[x+1][y-1])check++;\n\t\tif(board[x+1][y-1] != board[x+1][y])check++;\n\t\tif(check != 2){\n\t\t\tboard[x][y] = n;\n\t\t\tboard[x][y+1] = n;\n\t\t\tret += DFS(x,y,n+1);\n\t\t\tboard[x][y] = 0;\n\t\t\tboard[x][y+1] = 0;\n\t\t}\n\t}\n\t//よこ向き\n\tif(board[x+1][y]==0){\n\t\tint check = 0;\n\t\tif(board[x+1][y-1] != board[x+2][y-1])check++;\n\t\tif(board[x+2][y] != board[x+2][y-1])check++;\n\t\tif(check != 2){\n\t\t\tboard[x][y] = n;\n\t\t\tboard[x+1][y] = n;\n\t\t\tret += DFS(x,y,n+1);\n\t\t\tboard[x][y] = 0;\n\t\t\tboard[x+1][y] = 0;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(1){\n\t\tmemset(board, 0, sizeof(board));\n\t\tcin >> h>> w;\n\t\tif(h==0)break;\n\t\tREP(i,w+2){\n\t\t\tboard[i][0] = 1000;\n\t\t\tboard[i][h+1] = 1000;\n\t\t}\n\t\tREP(i,h+2){\n\t\t\tboard[0][i] = 1000;\n\t\t\tboard[w+1][i] = 1000;\n\t\t}\n\t\tif(h==0)return 0;\n\t\tcout << DFS(1, 1, 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tbool ok2 = !((c1 * c2 * c3 * c4) && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\n\t\t\tok = ok & ok2;\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0, starty = count_ / W;\n\n\tfor (int i = starty; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (!tatami[i][j])\n\t\t\t{\n\t\t\t\tif (H - i - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i + 1][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (W - j - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i][j + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvector<vector<int> > start(H, vector<int>(W, 0));\n\n\t\t\tif (H == W)\n\t\t\t{\n\t\t\t\tstart[0][0] = 1; start[0][1] = 1;\n\n\t\t\t\tprintf(\"%d\\n\", dfs(2, start) * 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\", dfs(1, start));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\nint H, W;\n\nbool inside(int i, int j){\n     return 0 <= i && i < H && 0 <= j && j < W;\n}\n\nbool exist(vector<vector<int>>& field, int i, int j){\n    return !inside(i, j) || field[i][j] != 0;\n}\n\nbool different(vector<vector<int>>& field, int ai, int aj, int bi, int bj){\n    return inside(ai, aj) && inside(bi, bj) && field[ai][aj] != 0 && field[bi][bj] != 0 && field[ai][aj] != field[bi][bj];\n}\n\nbool able(vector<vector<int>>& field, int i, int j){\n    return !(different(field, i-1, j-1, i-1, j) && different(field, i, j-1, i-1, j-1)) && !(different(field, i+1, j-1, i+1, j) && different(field, i+1, j-1, i, j-1));\n}\n\nint dfs(vector<vector<int>>& field, int idx){\n    vector<vector<int>> next = field;\n\n    while(true){\n        bool change = false;\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if(next[i][j] == 0){\n                    if((exist(next, i-1, j) && exist(next, i, j-1) && exist(next, i+1, j))\n                        || (j + 1 < W && next[i][j+1] == 0 && (different(next, i-1, j, i-1, j+1) || different(next, i-1, j, i-1, j+1)))){\n                        if(j + 1 < W && next[i][j+1] == 0 && able(next, i, j) && able(next, i, j+1)){\n                            next[i][j] = idx;\n                            next[i][j+1] = idx;\n                            idx++;\n                            change = true;\n                            break;\n                        }else{\n                            return 0;\n                        }\n                    }\n                    if((exist(next, i-1, j) && exist(next, i, j-1) && exist(next, i, j+1))\n                        || (i + 1 < H && next[i+1][j] == 0 && (different(next, i, j-1, i+1, j-1) || different(next, i, j+1, i+1, j+1)))){\n                        if(i + 1 < H && next[i+1][j] == 0 && able(next, i, j) && able(next, i+1, j)){\n                            next[i][j] = idx;\n                            next[i+1][j] = idx;\n                            idx++;\n                            change = true;\n                            break;\n                        }else{\n                            return 0;\n                        }\n                    }\n                }\n            }\n            if(change) break;\n        }\n        if(!change) break;\n    }\n\n    if(idx == H * W / 2 + 1){\n        return 1;\n    }\n\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(next[i][j] == 0){\n                assert(i + 1 < H && next[i+1][j] == 0);\n                assert(j + 1 < W && next[i][j+1] == 0);\n                int ret = 0;\n                next[i][j] = idx;\n                next[i+1][j] = idx;\n                ret += dfs(next, idx+1);\n                next[i+1][j] = 0;\n                next[i][j+1] = idx;\n                ret += dfs(next, idx+1);\n                return ret;\n            }\n        }\n    }\n    assert(false);\n    return 0;\n}\n\nint main(){\n    while(true){\n        cin >> H >> W;\n        if(H == 0) break;\n        vector<vector<int>> field(H, vector<int>(W, 0));\n        cout << dfs(field, 1) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint W, H;\nint memo[21][21];\nint dfs(int x, int y, int i){\n  if(y == H)\n\treturn 1;\n  if(x == W)\n\treturn dfs(0, y+1, i);\n\n  if(memo[y][x])\n\treturn dfs(x+1, y, i);\n\n  int res = 0;\n  if(x+1 < W && !memo[y][x+1]){\n\tif(!(y > 0 && x > 0 && memo[y-1][x-1] != memo[y-1][x] && memo[y-1][x-1] != memo[y][x-1])){\n\t  memo[y][x] = memo[y][x+1] = i;\n\t  res += dfs(x+1, y, i+1);\n\t  memo[y][x] = memo[y][x+1] = 0;\n\t}\n  }\n  if(y+1 < H && !memo[y+1][x]){\n\tif(!(y > 0 && x > 0 && memo[y-1][x-1] != memo[y-1][x] && memo[y-1][x-1] != memo[y][x-1])){\n\t  memo[y][x] = memo[y+1][x] = i;\n\t  res += dfs(x+1, y, i+1);\n\t  memo[y][x] = memo[y+1][x] = 0;\n\t}\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>W>>H,W){\n\tcout << dfs(0,0,1) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tbool ok2 = !((c1 * c2 * c3 * c4) && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\n\t\t\tok = ok && ok2;\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0, starts = count_ / W;\n\n\tfor (int i = starts; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (!tatami[i][j])\n\t\t\t{\n\t\t\t\tif (H - i - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i + 1][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (W - j - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i][j + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\", dfs(1, vector<vector<int> >(H, vector<int>(W, 0))));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tbool ok2 = !((c1 * c2 * c3 * c4) && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\n\t\t\tok = ok && ok2;\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\tif (hantei(tatami) == false) { return 0; }\n\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (tatami[i][j] == 0)\n\t\t\t{\n\t\t\t\tif (H - i - 1)\n\t\t\t\t{\n\t\t\t\t\tif (tatami[i + 1][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (W - j - 1)\n\t\t\t\t{\n\t\t\t\t\tif (tatami[i][j + 1] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\", dfs(1, vector<vector<int> >(H, vector<int>(W, 0))));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nbool corner(vvi& grid,int i,int j)\n{\n\treturn i>0 && j>0 && grid[i-1][j-1]!=grid[i-1][j] && grid[i-1][j-1]!=grid[i][j-1];\n}\n\nint check(vvi& grid,int i,int j)\n{\n\tint h=grid.size(),w=grid[0].size(),res=0;\n\tif(0<=i && i<h && 0<=j && j+1<w && grid[i][j]==-1 && grid[i][j+1]==-1 && !corner(grid,i,j))\n\t\tres|=1;\n\tif(0<=i && i+1<h && 0<=j && j<w && grid[i][j]==-1 && grid[i+1][j]==-1 && !corner(grid,i,j))\n\t\tres|=2;\n\treturn res;\n}\n\nint dfs(vvi& grid,int i,int j,int cnt)\n{\n\tint h=grid.size(),w=grid[0].size();\n\tif(cnt*2==h*w) return 1;\n\tif(j==w) i++,j=0;\n\tif(i==h) return 0;\n\tif(grid[i][j]!=-1) return dfs(grid,i,j+1,cnt);\n\t\n\tint flg=check(grid,i,j),res=0;\n\t// 横\n\tif(flg&1){\n\t\tgrid[i][j]=grid[i][j+1]=cnt;\n\t\tres+=dfs(grid,i,j+1,cnt+1);\n\t\tgrid[i][j]=grid[i][j+1]=-1;\n\t}\n\t// 縦\n\tif(flg&2){\n\t\tgrid[i][j]=grid[i+1][j]=cnt;\n\t\tres+=dfs(grid,i,j+1,cnt+1);\n\t\tgrid[i][j]=grid[i+1][j]=-1;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvvi grid(h,vi(w,-1));\n\t\tcout<<dfs(grid,0,0,0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt dp[30];\nInt fib(Int n){\n  if(n<=2) return 1;\n  if(~dp[n]) return dp[n];\n  return dp[n]=fib(n-1)+fib(n-2);\n}\nsigned main(){\n  Int h,w;\n  memset(dp,-1,sizeof(dp));\n  while(cin>>h>>w,h){\n    if(h>w) swap(h,w);\n    if((h*w)&1){\n      cout<<0<<endl;\n      continue;\n    }\n    if(h==1){\n      cout<<1<<endl;\n      continue;\n    }\n    if(h==2){\n      cout<<fib(w)<<endl;\n      continue;\n    }\n    \n    Int res=0;\n    if(h==3) res+=2;\n    if(w==3) res+=2;\n    \n    if(h==4) res+=1+(w%3==0);\n    if(w==4) res+=1+(h%3==0);\n    \n    cout<<res<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <cstdio>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nusing namespace std;\n\nint t[20][20];\nint h, w;\n\nbool ok(int x, int y){\n  if(x < 0 || y < 0) return true;\n  if(x >= w - 1 || y >= h - 1) return true;\n  set<int> s;\n  REP(i,2) REP(j,2){\n    s.insert(t[y + i][x + j]);\n  }\n  if(s.count(0)) return true;\n  return s.size() != 4;\n}\n\nint solve(int pos, int id){\n  if(pos == h * w){\n    // REP(i,h){ REP(j,w) printf(\"%2d \", t[i][j]); puts(\"\"); } puts(\"\");\n    return 1;\n  }\n  int x = pos % w;\n  int y = pos / w;\n  if(t[y][x]) return solve(pos + 1, id);\n\n  int ret = 0;\n  if(x != w - 1 && !t[y][x + 1]){\n    t[y][x] = t[y][x + 1] = id;\n    if(ok(x - 1, y - 1))\n      ret += solve(pos + 1, id + 1);\n    t[y][x] = t[y][x + 1] = 0;\n  }\n  if(y != h - 1 && !t[y + 1][x]){\n    t[y][x] = t[y + 1][x] = id;\n    if(ok(x - 1, y - 1))\n      ret += solve(pos + 1, id + 1);\n    t[y][x] = t[y + 1][x] = 0;\n  }\n  return ret;\n}\n\nint main(){\n  while(true){\n    h = getInt();\n    w = getInt();\n\n    if(h + w == 0) break;\n\n    printf(\"%d\\n\", solve(0, 1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nld eps=1e-9;\n\nint H, W;\nint dx[4] = { -1,-1,0,0 };\nint dy[4] = { -1,0,0,-1 };\nbool check(const vector<vector<int>>&v,const int x, const int y) {\n\tif (!x || !y || x == W || y == H)return true;\n\tset<int>s;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tif (v[y + dy[i]][x + dx[i]]) {\n\t\t\ts.emplace(v[y + dy[i]][x + dx[i]]);\n\t\t}\n\t}\n\treturn s.size() != 4;\n}\nint getans(vector<vector<int>>&v,const int num) {\n\tfor (int y = 0; y < H; ++y) {\n\t\tfor (int x = 0; x < W; ++x) {\n\t\t\tif (!v[y][x]) {\n\t\t\t\tint ans = 0;\n\t\t\t\tv[y][x] = num;\n\t\t\t\tif(x!=W-1&&!v[y][x+1]){\n\t\t\t\t\tv[y][x + 1] = num;\n\t\t\t\t\tif (check(v, x, y) && check(v, x + 2, y) && check(v, x + 2, y + 1) && check(v, x, y + 1)) {\n\t\t\t\t\t\tans += getans(v, num + 1);\n\t\t\t\t\t}\n\t\t\t\t\tv[y][x + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif(y!=H-1){\n\t\t\t\t\tv[y+1][x] = num;\n\t\t\t\t\tif (check(v, x, y) && check(v, x + 1, y) && check(v, x + 1, y + 2) && check(v, x, y +2)) {\n\t\t\t\t\t\tans += getans(v, num + 1);\n\t\t\t\t\t}\n\t\t\t\t\tv[y+1][x] = 0;\n\t\t\t\t}\n\t\t\t\tv[y][x] = 0;\n\t\t\t\treturn ans;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\nint main() {\n\twhile (1) { cin >> H >> W;\n\t\tif (!H)break;\n\t\tvector < vector<int>>v(H, vector<int>(W));\n\t\tint ans = getans(v, 1);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\ntypedef vector<vi> mat;\nint h, w;\n\nint check(mat fld)\n{\n\tREP(i, h - 1)REP(j, w - 1)\n\t{\n\t\tset<int> st;\n\t\tst.insert(fld[i][j]);\n\t\tst.insert(fld[i+1][j]);\n\t\tst.insert(fld[i][j+1]);\n\t\tst.insert(fld[i+1][j+1]);\n\t\tif (st.size() == 4) return false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\twhile (cin >> h >> w, h)\n\t{\n\t\tmat fld(h, vi(w, -1));\n\t\tqueue<pair<mat, int>> que;\n\t\tque.push(make_pair(fld, 0));\n\t\tint cnt = 0;\n\t\twhile(que.size())\n\t\t{\n\t\t\tauto a = que.front();\n\t\t\tmat tmp = a.first;\n\t\t\tint p = a.second;\n\t\t\tint x = p / w, y = p % w;\n\t\t\tque.pop();\n\t\t\tif (p == h*w) cnt += check(tmp);\n\t\t\telse if (tmp[x][y] != -1) que.push(make_pair(tmp, p + 1));\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmp[x][y] = p;\n\t\t\t\tif (x != h - 1 && tmp[x + 1][y] == -1)\n\t\t\t\t{\n\t\t\t\t\ttmp[x + 1][y] = p;\n\t\t\t\t\tque.push(make_pair(tmp, p + 1));\n\t\t\t\t\ttmp[x + 1][y] = -1;\n\t\t\t\t}if (y != w - 1 && tmp[x][y + 1] == -1)\n\t\t\t\t{\n\t\t\t\t\ttmp[x][y + 1] = p;\n\t\t\t\t\tque.push(make_pair(tmp, p + 1));\n\t\t\t\t\ttmp[x][y + 1] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint m, n, ans[19][19]= {{2,3,4,6,9,13,19,28,41,60,88,129,189,277,406,595,872,1278,1873}, {3,0,4,0,6,0,10,0,16,0,26,0,42,0,68,0,110,0,178}, {4,4,2,3,3,3,5,5,6,8,8,11,13,14,19,21,25,32,35}, {6,0,3,0,2,0,2,0,4,0,4,0,6,0,8,0,10,0,14}, {9,6,3,2,2,2,1,1,2,3,4,3,3,3,4,6,6,7,6}, {13,0,3,0,2,0,2,0,0,0,2,0,4,0,2,0,2,0,6}, {19,10,5,2,1,2,2,2,1,0,0,1,2,3,4,3,2,1,1}, {28,0,5,0,1,0,2,0,2,0,0,0,0,0,2,0,4,0,2}, {41,16,6,4,2,0,1,2,2,2,1,0,0,0,0,1,2,3,4}, {60,0,8,0,3,0,0,0,2,0,2,0,0,0,0,0,0,0,2}, {88,26,8,4,4,2,0,0,1,2,2,2,1,0,0,0,0,0,0}, {129,0,11,0,3,0,1,0,0,0,2,0,2,0,0,0,0,0,0}, {189,42,13,6,3,4,2,0,0,0,1,2,2,2,1,0,0,0,0}, {277,0,14,0,3,0,3,0,0,0,0,0,2,0,2,0,0,0,0}, {406,68,19,8,4,2,4,2,0,0,0,0,1,2,2,2,1,0,0}, {595,0,21,0,6,0,3,0,1,0,0,0,0,0,2,0,2,0,0}, {872,110,25,10,6,2,2,4,2,0,0,0,0,0,1,2,2,2,1}, {1278,0,32,0,7,0,1,0,3,0,0,0,0,0,0,0,2,0,2}, {1873,178,35,14,6,6,1,2,4,2,0,0,0,0,0,0,1,2,2}};\n\nint main(){\n    cin >> m >> n;\n    while(m + n > 0){\n        if(m >= 2 && n >= 2){\n            cout << ans[m-2][n-2] << endl;\n        }else{\n            if(m > n) m = n;\n            cout << 1-m%2 << endl;\n        }\n        cin >> m >> n;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tbool ok2 = true;\n\n\t\t\tif (c1 > 0)\n\t\t\t{\n\t\t\t\tif (c2 > 0)\n\t\t\t\t{\n\t\t\t\t\tif (c3 > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (c4 > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (c1 != c2)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (c1 != c3)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (c1 != c4)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (c2 != c3)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif (c2 != c4)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif (c3 != c4)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tok2 = false;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tok = ok && ok2;\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\tif (hantei(tatami) == false) { return 0; }\n\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (tatami[i][j] == 0)\n\t\t\t{\n\t\t\t\tif (i + 1 < H)\n\t\t\t\t{\n\t\t\t\t\tif (tatami[i + 1][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (j + 1 < W)\n\t\t\t\t{\n\t\t\t\t\tif (tatami[i][j + 1] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\", dfs(1, vector<vector<int> >(H, vector<int>(W, 0))));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt dp[30];\nInt fib(Int n,Int x,Int y){\n  if(n<0) return 0;\n  if(n<=1) return 1;\n  if(~dp[n]) return dp[n];\n  return dp[n]=fib(n-x,x,y)+fib(n-y,x,y);\n}\nsigned main(){\n  Int h,w;\n  while(cin>>h>>w,h){\n    memset(dp,-1,sizeof(dp));\n    if((h*w)&1){\n      cout<<0<<endl;\n      continue;\n    }\n    \n    if(h>w) swap(h,w);\n    if(h==1){\n      cout<<1<<endl;\n      continue;\n    }\n    if(h==2){\n      Int dp2[100]={};\n      dp2[0]=1;\n      for(Int i=0;i<w;i++){\n\tdp2[i+1]+=dp2[i];\n\tdp2[i+3]+=dp2[i];\n      }\n      cout<<dp2[w]+dp2[w-2]<<endl;\n      continue;\n    }\n    if(h==3){\n      cout<<2*fib(w/2,1,2)<<endl;\n      continue;\n    }\n    \n    if(h&1) swap(h,w);\n    \n    cout<<fib(w,h-1,h+1)+fib(w+1,h-1,h+1)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<string> fix(vector<string> v){\n\tsort(v.begin(),v.end());\n\tv.erase(unique(v.begin(),v.end()),v.end());\n\tint bad[20] = {};\n\tfor(int i = 0 ; i < v.size() ; i++){\n\t\tfor(int j = 0 ; j < v.size() ; j++){\n\t\t\tif( i != j && ~v[i].find(v[j]) ){\n\t\t\t\tbad[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tvector<string> res;\n\tfor(int i = 0 ; i < v.size() ; i++){\n\t\tif( bad[i] == 0 ) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nint dp[1<<14][14];\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tvector<string> v(n);\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t\tcin >> v[i];\n\t\tv = fix(v);\n\t\tn = v.size();\n\t\tint g[20][20] = {};\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tint res = v[j].size();\n\t\t\t\tint len = min(v[i].size(),v[j].size());\n\t\t\t\tfor(int k = 0 ; k < v[i].size() ; k++){\n\t\t\t\t\tstring A = v[i].substr(k);\n\t\t\t\t\tif( A.size() > len ) continue;\n\t\t\t\t\tstring B = v[j].substr(0,A.size());\n\t\t\t\t\t//cout << A << \" \" << B << endl;\n\t\t\t\t\tif( A == B ){\n\t\t\t\t\t\tres = min( res , (int)(v[j].size() - A.size()) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tg[i][j] = res;\n\t\t\t\t//cout << i << \",\" << j << \" = \" << g[i][j] << endl;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < (1<<14) ; i++)\n\t\t\tfor(int j = 0 ; j < 14 ; j++)\n\t\t\t\tdp[i][j] = 1e9;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdp[(1<<i)][i] = v[i].size();\n\t\t}\n\t\tfor(int i = 0 ; i < (1<<n) ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tif( dp[i][j] > 1e8 ) continue;\n\t\t\t\tfor(int k = 0 ; k < n ; k++){\n\t\t\t\t\tdp[i|(1<<k)][k] = min( dp[i|(1<<k)][k] , dp[i][j] + g[j][k] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1e9;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tans = min(ans,dp[(1<<n)-1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <cctype>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define REP(i, n) for (int i(0); i < (int) (n); i++)\n\nconst int N = 20 + 2;\nconst int INF = 1000000;\n\nint n, m;\nint ret;\nint color[N][N];\n\nint ok(int x, int y)\n{\n\tstatic int c[4];\n\tc[0] = color[x][y];\n\tc[1] = color[x + 1][y];\n\tc[2] = color[x][y + 1];\n\tc[3] = color[x + 1][y + 1];\n\tfor(int i = 0; i < 4; ++ i)\n\t\tfor(int j = i + 1; j < 4; ++ j)\n\t\t\tif (c[i] == c[j])\n\t\t\t\treturn true;\n\treturn false;\n}\n\nint ok(int xa, int ya, int xb, int yb)\n{\n\tif (color[xb][yb] >= 0) return false;\n\tif (color[xa][ya] >= 0) return false;\n\tcolor[xa][ya] = color[xb][yb] = INF;\n\tfor(int cx = xa - 1; cx <= xb; ++ cx) {\n\t\tfor(int cy = ya - 1; cy <= yb; ++ cy) {\n\t\t\tif (! ok(cx, cy)) {\n\t\t\t\tcolor[xa][ya] = color[xb][yb] = -1;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tcolor[xa][ya] = color[xb][yb] = -1;\n\treturn true;\n}\n\nset<vector<vector<int> > > ss;\n\nvoid dfs(int cur)\n{\n\tif (cur * 2 == n * m) {\n\t\tvector<vector<int> > vec;\n\t\tfor(int i = 1; i <= n; ++ i) {\n\t\t\tvector<int> row;\n\t\t\tfor(int j = 1; j <= m; ++ j) {\n\t\t\t\tint value = 0;\n\t\t\t\tif (i + 1 <= n && color[i][j] == color[i + 1][j])\n\t\t\t\t\tvalue = 1;\n\t\t\t\tif (j + 1 <= m && color[i][j + 1] == color[i][j])\n\t\t\t\t\tvalue = 2;\n\t\t\t\trow.push_back(value);\n\t\t\t} \n\t\t\tvec.push_back(row);\n\t\t}\n\t\tss.insert(vec);\n\t\t++ ret;\n\t\treturn;\n\t}\n\tint ways = 5, rx, ry;\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = 1; j <= m; ++ j) {\n\t\t\tif (color[i][j] >= 0) continue;\n\t\t\tint curWays = 0;\n\t\t\tif (i + 1 <= n && ok(i, j, i + 1, j)) {\n\t\t\t\t++ curWays;\n\t\t\t}\n\t\t\tif (j + 1 <= m && ok(i, j, i, j + 1)) {\n\t\t\t\t++ curWays;\n\t\t\t}\n\t\t\tif (i - 1 >= 1 && ok(i - 1, j, i, j)) {\n\t\t\t\t++ curWays;\n\t\t\t}\n\t\t\tif (j - 1 >= 1 && ok(i, j - 1, i, j)) {\n\t\t\t\t++ curWays;\n\t\t\t}\n\t\t\tif (curWays < ways) {\n\t\t\t\tways = curWays;\n\t\t\t\trx = i;\n\t\t\t\try = j;\n\t\t\t}\n\t\t}\n\t}\n\tif (ways == 0 || ways == 5) {\n\t\treturn;\n\t}\n\tint i = rx, j = ry;\n\tif (i + 1 <= n && ok(i, j, i + 1, j)) {\n\t\tcolor[i][j] = color[i + 1][j] = cur;\n\t\tdfs(cur + 1);\n\t\tcolor[i][j] = color[i + 1][j] = -1;\n\t}\n\tif (i - 1 >= 1 && ok(i - 1, j, i, j)) {\n\t\tcolor[i - 1][j] = color[i][j] = cur;\n\t\tdfs(cur + 1);\n\t\tcolor[i - 1][j] = color[i][j] = -1;\n\t}\n\tif (j + 1 <= m && ok(i, j, i, j + 1)) {\n\t\tcolor[i][j] = color[i][j + 1] = cur;\n\t\tdfs(cur + 1);\n\t\tcolor[i][j] = color[i][j + 1] = -1;\n\t}\n\tif (j - 1 >= 1 && ok(i, j - 1, i, j)) {\n\t\tcolor[i][j - 1] = color[i][j] = cur;\n\t\tdfs(cur + 1);\n\t\tcolor[i][j - 1] = color[i][j] = -1;\n\t}\n}\n\nvoid solve() {\n\tmemset(color, -1, sizeof color);\n\tif (n * m & 1) {\n\t\tcout << 0 << endl;\n\t\treturn;\n\t}\n\tret = 0;\n\tss.clear();\n\tdfs(0);\n\tcout << ss.size() << endl;\n/*\tfor(set<vector<vector<int> > >::iterator it = ss.begin(); it != ss.end(); ++ it) {\n\t\tfor(int i = 0; i < n; ++ i) {\n\t\t\tfor(int j = 0; j < m; ++ j) {\n\t\t\t\tcout << (*it)[i][j] << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl << endl;\n\t}*/\n}\n\nint main() {\n\tfor( ; cin >> n >> m && (n || m); ) {\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<array>\n#include<map>\n\nusing namespace std;\n\nint main(){\n  for(int H,W;cin>>H>>W,H;){\n    map<array<int,20>,int> m[21][21];\n    m[0][0][array<int,20>()]=1;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tfor(auto e:m[i][j]){\n\t  auto v=e.first;\n\t  auto d=e.second;\n\t  if(j&&v[j-1]==2){\n\t    v[j]=3;\n\t    m[i][j+1][v]+=d;\n\t  }else if(i&&v[j]==0){\n\t    v[j]=1;\n\t    m[i][j+1][v]+=d;\n\t  }else if(i==0||v[j]==3||j==0||v[j-1]==1){\n\t    if(i+1<H){\n\t      auto nv=v;\n\t      nv[j]=0;\n\t      m[i][j+1][nv]+=d;\n\t    }\n\t    if(j+1<W&&(i==0||v[j+1]!=0)){\n\t      auto nv=v;\n\t      nv[j]=2;\n\t      m[i][j+1][nv]+=d;\n\t    }\n\t  }\n\t}\n\tm[i][j].clear();\n      }\n      m[i+1][0]=m[i][W];\n    }\n    int a=0;\n    for(auto e:m[H][0]){\n      a+=e.second;\n    }\n    cout<<a<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint ans[21][21];\n\nint main() {\n  ans[1][1] = 0;\n  ans[1][1] = 0;\n  ans[1][2] = 1;\n  ans[2][1] = 1;\n  ans[1][3] = 0;\n  ans[3][1] = 0;\n  ans[1][4] = 1;\n  ans[4][1] = 1;\n  ans[1][5] = 0;\n  ans[5][1] = 0;\n  ans[1][6] = 1;\n  ans[6][1] = 1;\n  ans[1][7] = 0;\n  ans[7][1] = 0;\n  ans[1][8] = 1;\n  ans[8][1] = 1;\n  ans[1][9] = 0;\n  ans[9][1] = 0;\n  ans[1][10] = 1;\n  ans[10][1] = 1;\n  ans[1][11] = 0;\n  ans[11][1] = 0;\n  ans[1][12] = 1;\n  ans[12][1] = 1;\n  ans[1][13] = 0;\n  ans[13][1] = 0;\n  ans[1][14] = 1;\n  ans[14][1] = 1;\n  ans[1][15] = 0;\n  ans[15][1] = 0;\n  ans[1][16] = 1;\n  ans[16][1] = 1;\n  ans[1][17] = 0;\n  ans[17][1] = 0;\n  ans[1][18] = 1;\n  ans[18][1] = 1;\n  ans[1][19] = 0;\n  ans[19][1] = 0;\n  ans[1][20] = 1;\n  ans[20][1] = 1;\n  ans[2][2] = 2;\n  ans[2][2] = 2;\n  ans[2][3] = 3;\n  ans[3][2] = 3;\n  ans[2][4] = 4;\n  ans[4][2] = 4;\n  ans[2][5] = 6;\n  ans[5][2] = 6;\n  ans[2][6] = 9;\n  ans[6][2] = 9;\n  ans[2][7] = 13;\n  ans[7][2] = 13;\n  ans[2][8] = 19;\n  ans[8][2] = 19;\n  ans[2][9] = 28;\n  ans[9][2] = 28;\n  ans[2][10] = 41;\n  ans[10][2] = 41;\n  ans[2][11] = 60;\n  ans[11][2] = 60;\n  ans[2][12] = 88;\n  ans[12][2] = 88;\n  ans[2][13] = 129;\n  ans[13][2] = 129;\n  ans[2][14] = 189;\n  ans[14][2] = 189;\n  ans[2][15] = 277;\n  ans[15][2] = 277;\n  ans[2][16] = 406;\n  ans[16][2] = 406;\n  ans[2][17] = 595;\n  ans[17][2] = 595;\n  ans[2][18] = 872;\n  ans[18][2] = 872;\n  ans[2][19] = 1278;\n  ans[19][2] = 1278;\n  ans[2][20] = 1873;\n  ans[20][2] = 1873;\n  ans[3][3] = 0;\n  ans[3][3] = 0;\n  ans[3][4] = 4;\n  ans[4][3] = 4;\n  ans[3][5] = 0;\n  ans[5][3] = 0;\n  ans[3][6] = 6;\n  ans[6][3] = 6;\n  ans[3][7] = 0;\n  ans[7][3] = 0;\n  ans[3][8] = 10;\n  ans[8][3] = 10;\n  ans[3][9] = 0;\n  ans[9][3] = 0;\n  ans[3][10] = 16;\n  ans[10][3] = 16;\n  ans[3][11] = 0;\n  ans[11][3] = 0;\n  ans[3][12] = 26;\n  ans[12][3] = 26;\n  ans[3][13] = 0;\n  ans[13][3] = 0;\n  ans[3][14] = 42;\n  ans[14][3] = 42;\n  ans[3][15] = 0;\n  ans[15][3] = 0;\n  ans[3][16] = 68;\n  ans[16][3] = 68;\n  ans[3][17] = 0;\n  ans[17][3] = 0;\n  ans[3][18] = 110;\n  ans[18][3] = 110;\n  ans[3][19] = 0;\n  ans[19][3] = 0;\n  ans[3][20] = 178;\n  ans[20][3] = 178;\n  ans[4][4] = 2;\n  ans[4][4] = 2;\n  ans[4][5] = 3;\n  ans[5][4] = 3;\n  ans[4][6] = 3;\n  ans[6][4] = 3;\n  ans[4][7] = 3;\n  ans[7][4] = 3;\n  ans[4][8] = 5;\n  ans[8][4] = 5;\n  ans[4][9] = 5;\n  ans[9][4] = 5;\n  ans[4][10] = 6;\n  ans[10][4] = 6;\n  ans[4][11] = 8;\n  ans[11][4] = 8;\n  ans[4][12] = 8;\n  ans[12][4] = 8;\n  ans[4][13] = 11;\n  ans[13][4] = 11;\n  ans[4][14] = 13;\n  ans[14][4] = 13;\n  ans[4][15] = 14;\n  ans[15][4] = 14;\n  ans[4][16] = 19;\n  ans[16][4] = 19;\n  ans[4][17] = 21;\n  ans[17][4] = 21;\n  ans[4][18] = 25;\n  ans[18][4] = 25;\n  ans[4][19] = 32;\n  ans[19][4] = 32;\n  ans[4][20] = 35;\n  ans[20][4] = 35;\n  ans[5][5] = 0;\n  ans[5][5] = 0;\n  ans[5][6] = 2;\n  ans[6][5] = 2;\n  ans[5][7] = 0;\n  ans[7][5] = 0;\n  ans[5][8] = 2;\n  ans[8][5] = 2;\n  ans[5][9] = 0;\n  ans[9][5] = 0;\n  ans[5][10] = 4;\n  ans[10][5] = 4;\n  ans[5][11] = 0;\n  ans[11][5] = 0;\n  ans[5][12] = 4;\n  ans[12][5] = 4;\n  ans[5][13] = 0;\n  ans[13][5] = 0;\n  ans[5][14] = 6;\n  ans[14][5] = 6;\n  ans[5][15] = 0;\n  ans[15][5] = 0;\n  ans[5][16] = 8;\n  ans[16][5] = 8;\n  ans[5][17] = 0;\n  ans[17][5] = 0;\n  ans[5][18] = 10;\n  ans[18][5] = 10;\n  ans[5][19] = 0;\n  ans[19][5] = 0;\n  ans[5][20] = 14;\n  ans[20][5] = 14;\n  ans[6][6] = 2;\n  ans[6][6] = 2;\n  ans[6][7] = 2;\n  ans[7][6] = 2;\n  ans[6][8] = 1;\n  ans[8][6] = 1;\n  ans[6][9] = 1;\n  ans[9][6] = 1;\n  ans[6][10] = 2;\n  ans[10][6] = 2;\n  ans[6][11] = 3;\n  ans[11][6] = 3;\n  ans[6][12] = 4;\n  ans[12][6] = 4;\n  ans[6][13] = 3;\n  ans[13][6] = 3;\n  ans[6][14] = 3;\n  ans[14][6] = 3;\n  ans[6][15] = 3;\n  ans[15][6] = 3;\n  ans[6][16] = 4;\n  ans[16][6] = 4;\n  ans[6][17] = 6;\n  ans[17][6] = 6;\n  ans[6][18] = 6;\n  ans[18][6] = 6;\n  ans[6][19] = 7;\n  ans[19][6] = 7;\n  ans[6][20] = 6;\n  ans[20][6] = 6;\n  ans[7][7] = 0;\n  ans[7][7] = 0;\n  ans[7][8] = 2;\n  ans[8][7] = 2;\n  ans[7][9] = 0;\n  ans[9][7] = 0;\n  ans[7][10] = 0;\n  ans[10][7] = 0;\n  ans[7][11] = 0;\n  ans[11][7] = 0;\n  ans[7][12] = 2;\n  ans[12][7] = 2;\n  ans[7][13] = 0;\n  ans[13][7] = 0;\n  ans[7][14] = 4;\n  ans[14][7] = 4;\n  ans[7][15] = 0;\n  ans[15][7] = 0;\n  ans[7][16] = 2;\n  ans[16][7] = 2;\n  ans[7][17] = 0;\n  ans[17][7] = 0;\n  ans[7][18] = 2;\n  ans[18][7] = 2;\n  ans[7][19] = 0;\n  ans[19][7] = 0;\n  ans[7][20] = 6;\n  ans[20][7] = 6;\n  ans[8][8] = 2;\n  ans[8][8] = 2;\n  ans[8][9] = 2;\n  ans[9][8] = 2;\n  ans[8][10] = 1;\n  ans[10][8] = 1;\n  ans[8][11] = 0;\n  ans[11][8] = 0;\n  ans[8][12] = 0;\n  ans[12][8] = 0;\n  ans[8][13] = 1;\n  ans[13][8] = 1;\n  ans[8][14] = 2;\n  ans[14][8] = 2;\n  ans[8][15] = 3;\n  ans[15][8] = 3;\n  ans[8][16] = 4;\n  ans[16][8] = 4;\n  ans[8][17] = 3;\n  ans[17][8] = 3;\n  ans[8][18] = 2;\n  ans[18][8] = 2;\n  ans[8][19] = 1;\n  ans[19][8] = 1;\n  ans[8][20] = 1;\n  ans[20][8] = 1;\n  ans[9][9] = 0;\n  ans[9][9] = 0;\n  ans[9][10] = 2;\n  ans[10][9] = 2;\n  ans[9][11] = 0;\n  ans[11][9] = 0;\n  ans[9][12] = 0;\n  ans[12][9] = 0;\n  ans[9][13] = 0;\n  ans[13][9] = 0;\n  ans[9][14] = 0;\n  ans[14][9] = 0;\n  ans[9][15] = 0;\n  ans[15][9] = 0;\n  ans[9][16] = 2;\n  ans[16][9] = 2;\n  ans[9][17] = 0;\n  ans[17][9] = 0;\n  ans[9][18] = 4;\n  ans[18][9] = 4;\n  ans[9][19] = 0;\n  ans[19][9] = 0;\n  ans[9][20] = 2;\n  ans[20][9] = 2;\n  ans[10][10] = 2;\n  ans[10][10] = 2;\n  ans[10][11] = 2;\n  ans[11][10] = 2;\n  ans[10][12] = 1;\n  ans[12][10] = 1;\n  ans[10][13] = 0;\n  ans[13][10] = 0;\n  ans[10][14] = 0;\n  ans[14][10] = 0;\n  ans[10][15] = 0;\n  ans[15][10] = 0;\n  ans[10][16] = 0;\n  ans[16][10] = 0;\n  ans[10][17] = 1;\n  ans[17][10] = 1;\n  ans[10][18] = 2;\n  ans[18][10] = 2;\n  ans[10][19] = 3;\n  ans[19][10] = 3;\n  ans[10][20] = 4;\n  ans[20][10] = 4;\n  ans[11][11] = 0;\n  ans[11][11] = 0;\n  ans[11][12] = 2;\n  ans[12][11] = 2;\n  ans[11][13] = 0;\n  ans[13][11] = 0;\n  ans[11][14] = 0;\n  ans[14][11] = 0;\n  ans[11][15] = 0;\n  ans[15][11] = 0;\n  ans[11][16] = 0;\n  ans[16][11] = 0;\n  ans[11][17] = 0;\n  ans[17][11] = 0;\n  ans[11][18] = 0;\n  ans[18][11] = 0;\n  ans[11][19] = 0;\n  ans[19][11] = 0;\n  ans[11][20] = 2;\n  ans[20][11] = 2;\n  ans[12][12] = 2;\n  ans[12][12] = 2;\n  ans[12][13] = 2;\n  ans[13][12] = 2;\n  ans[12][14] = 1;\n  ans[14][12] = 1;\n  ans[12][15] = 0;\n  ans[15][12] = 0;\n  ans[12][16] = 0;\n  ans[16][12] = 0;\n  ans[12][17] = 0;\n  ans[17][12] = 0;\n  ans[12][18] = 0;\n  ans[18][12] = 0;\n  ans[12][19] = 0;\n  ans[19][12] = 0;\n  ans[12][20] = 0;\n  ans[20][12] = 0;\n  ans[13][13] = 0;\n  ans[13][13] = 0;\n  ans[13][14] = 2;\n  ans[14][13] = 2;\n  ans[13][15] = 0;\n  ans[15][13] = 0;\n  ans[13][16] = 0;\n  ans[16][13] = 0;\n  ans[13][17] = 0;\n  ans[17][13] = 0;\n  ans[13][18] = 0;\n  ans[18][13] = 0;\n  ans[13][19] = 0;\n  ans[19][13] = 0;\n  ans[13][20] = 0;\n  ans[20][13] = 0;\n  ans[14][14] = 2;\n  ans[14][14] = 2;\n  ans[14][15] = 2;\n  ans[15][14] = 2;\n  ans[14][16] = 1;\n  ans[16][14] = 1;\n  ans[14][17] = 0;\n  ans[17][14] = 0;\n  ans[14][18] = 0;\n  ans[18][14] = 0;\n  ans[14][19] = 0;\n  ans[19][14] = 0;\n  ans[14][20] = 0;\n  ans[20][14] = 0;\n  ans[15][15] = 0;\n  ans[15][15] = 0;\n  ans[15][16] = 2;\n  ans[16][15] = 2;\n  ans[15][17] = 0;\n  ans[17][15] = 0;\n  ans[15][18] = 0;\n  ans[18][15] = 0;\n  ans[15][19] = 0;\n  ans[19][15] = 0;\n  ans[15][20] = 0;\n  ans[20][15] = 0;\n  ans[16][16] = 2;\n  ans[16][16] = 2;\n  ans[16][17] = 2;\n  ans[17][16] = 2;\n  ans[16][18] = 1;\n  ans[18][16] = 1;\n  ans[16][19] = 0;\n  ans[19][16] = 0;\n  ans[16][20] = 0;\n  ans[20][16] = 0;\n  ans[17][17] = 0;\n  ans[17][17] = 0;\n  ans[17][18] = 2;\n  ans[18][17] = 2;\n  ans[17][19] = 0;\n  ans[19][17] = 0;\n  ans[17][20] = 0;\n  ans[20][17] = 0;\n  ans[18][18] = 2;\n  ans[18][18] = 2;\n  ans[18][19] = 2;\n  ans[19][18] = 2;\n  ans[18][20] = 1;\n  ans[20][18] = 1;\n  ans[19][19] = 0;\n  ans[19][19] = 0;\n  ans[19][20] = 2;\n  ans[20][19] = 2;\n  ans[20][20] = 2;\n  ans[20][20] = 2;\n\n  for(int H, W; cin >> H >> W && (H|W); ) {\n    cout << ans[H][W] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tbool ok2 = !((c1 * c2 * c3 * c4) && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\n\t\t\tok = ok && ok2;\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (!tatami[i][j])\n\t\t\t{\n\t\t\t\tif (H - i - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i + 1][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (W - j - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i][j + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\", dfs(1, vector<vector<int> >(H, vector<int>(W, 0))));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <cctype>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define REP(i, n) for (int i(0); i < (int) (n); i++)\n\nconst int N = 20 + 2;\nconst int INF = 1000000;\n\nint n, m;\nint ret;\nint color[N][N];\n\nint ok(int x, int y)\n{\n\tstatic int c[4];\n\tc[0] = color[x][y];\n\tc[1] = color[x + 1][y];\n\tc[2] = color[x][y + 1];\n\tc[3] = color[x + 1][y + 1];\n\tfor(int i = 0; i < 4; ++ i)\n\t\tfor(int j = i + 1; j < 4; ++ j)\n\t\t\tif (c[i] == c[j])\n\t\t\t\treturn true;\n\treturn false;\n}\n\nint ok(int xa, int ya, int xb, int yb)\n{\n\tif (color[xb][yb] >= 0) return false;\n\tif (color[xa][ya] >= 0) return false;\n\tcolor[xa][ya] = color[xb][yb] = INF;\n\tfor(int cx = xa - 1; cx <= xb; ++ cx) {\n\t\tfor(int cy = ya - 1; cy <= yb; ++ cy) {\n\t\t\tif (! ok(cx, cy)) {\n\t\t\t\tcolor[xa][ya] = color[xb][yb] = -1;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tcolor[xa][ya] = color[xb][yb] = -1;\n\treturn true;\n}\n\nset<vector<vector<int> > > ss;\n\nvoid dfs(int cur)\n{\n\tif (cur * 2 == n * m) {\n\t\t++ ret;\n\t\treturn;\n\t}\n\tint ways = 5, rx, ry;\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = 1; j <= m; ++ j) {\n\t\t\tif (color[i][j] >= 0) continue;\n\t\t\tint curWays = 0;\n\t\t\tif (i + 1 <= n && ok(i, j, i + 1, j)) {\n\t\t\t\t++ curWays;\n\t\t\t}\n\t\t\tif (j + 1 <= m && ok(i, j, i, j + 1)) {\n\t\t\t\t++ curWays;\n\t\t\t}\n\t\t\tif (i - 1 >= 1 && ok(i - 1, j, i, j)) {\n\t\t\t\t++ curWays;\n\t\t\t}\n\t\t\tif (j - 1 >= 1 && ok(i, j - 1, i, j)) {\n\t\t\t\t++ curWays;\n\t\t\t}\n\t\t\tif (curWays < ways) {\n\t\t\t\tways = curWays;\n\t\t\t\trx = i;\n\t\t\t\try = j;\n\t\t\t}\n\t\t}\n\t}\n\tif (ways == 0 || ways == 5) {\n\t\treturn;\n\t}\n\tint i = rx, j = ry;\n\tif (i + 1 <= n && ok(i, j, i + 1, j)) {\n\t\tcolor[i][j] = color[i + 1][j] = cur;\n\t\tdfs(cur + 1);\n\t\tcolor[i][j] = color[i + 1][j] = -1;\n\t}\n\tif (i - 1 >= 1 && ok(i - 1, j, i, j)) {\n\t\tcolor[i - 1][j] = color[i][j] = cur;\n\t\tdfs(cur + 1);\n\t\tcolor[i - 1][j] = color[i][j] = -1;\n\t}\n\tif (j + 1 <= m && ok(i, j, i, j + 1)) {\n\t\tcolor[i][j] = color[i][j + 1] = cur;\n\t\tdfs(cur + 1);\n\t\tcolor[i][j] = color[i][j + 1] = -1;\n\t}\n\tif (j - 1 >= 1 && ok(i, j - 1, i, j)) {\n\t\tcolor[i][j - 1] = color[i][j] = cur;\n\t\tdfs(cur + 1);\n\t\tcolor[i][j - 1] = color[i][j] = -1;\n\t}\n}\n\nvoid solve() {\n\tmemset(color, -1, sizeof color);\n\tif (n * m & 1) {\n\t\tcout << 0 << endl;\n\t\treturn;\n\t}\n\tret = 0;\n\tss.clear();\n\tdfs(0);\n\tcout << ret << endl;\n\t/*  for(set<vector<vector<int> > >::iterator it = ss.begin(); it != ss.end(); ++ it) {\n\t\tfor(int i = 0; i < n; ++ i) {\n\t\tfor(int j = 0; j < m; ++ j) {\n\t\tcout << (*it)[i][j] << ' ';\n\t\t}\n\t\tcout << endl;\n\t\t}\n\t\tcout << endl << endl;\n\t\t}*/\n}\n\nint main() {\n\tfor( ; cin >> n >> m && (n || m); ) {\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint m[30][30];\nint a,b;\nint solve(int i,int j){\n\tif(j==b){\n\t\treturn solve(i+1,0);\n\t}\n\tif(i==a)return 1;\n\tif(m[i][j])return solve(i,j+1);\n\t//for(int k=0;k<a;k++){\n\t//\tfor(int l=0;l<b;l++){\n\t//\t\tprintf(\"%d \",m[k][l]);\n\t//\t}\n\t//\tprintf(\"\\n\");\n\t//}\n\t//printf(\"\\n\");\n\tint ret=0;\n\tif(i<a-1&&!m[i+1][j]){\n\t\tif(i==0||((j==0||m[i-1][j-1]!=3)&&(j==b-1||(m[i-1][j]<2||m[i-1][j+1]%2!=1)))){\n\t\t\tm[i][j]=2;\n\t\t\tm[i+1][j]=3;\n\t\t\tret+=solve(i,j+1);\n\t\t\tm[i][j]=m[i+1][j]=0;\n\t\t}\n\t}\n\tif(j<b-1&&!m[i][j+1]){\n\t\tif(i==0||((j==0||m[i-1][j-1]!=3)&&(j==b-2||(m[i-1][j+1]<2||m[i-1][j+2]%2!=1)))){\n\t\t\tm[i][j]=1;\n\t\t\tm[i][j+1]=3;\n\t\t\tret+=solve(i,j+1);\n\t\t\tm[i][j]=m[i][j+1]=0;\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\t//int a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<30;i++)\n\t\t\tfor(int j=0;j<30;j++)\n\t\t\t\tm[i][j]=0;\n\t\tprintf(\"%d\\n\",solve(0,0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\nint main(){\n  for(int H,W;cin>>H>>W,H;){\n    map<vector<char>,int> m[21][21];\n    m[0][0][vector<char>(W)]=1;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tfor(auto e:m[i][j]){\n\t  auto v=e.first;\n\t  auto d=e.second;\n\t  if(j&&v[j-1]==2){\n\t    v[j]=3;\n\t    m[i][j+1][v]+=d;\n\t  }else if(i&&v[j]==0){\n\t    v[j]=1;\n\t    m[i][j+1][v]+=d;\n\t  }else if(i==0||v[j]==3||j==0||v[j-1]==1){\n\t    if(i+1<H){\n\t      auto nv=v;\n\t      nv[j]=0;\n\t      m[i][j+1][nv]+=d;\n\t    }\n\t    if(j+1<W&&(i==0||v[j+1]!=0)){\n\t      auto nv=v;\n\t      nv[j]=2;\n\t      m[i][j+1][nv]+=d;\n\t    }\n\t  }\n\t}\n\tm[i][j].clear();\n      }\n      m[i+1][0]=m[i][W];\n    }\n    int a=0;\n    for(auto e:m[H][0]){\n      a+=e.second;\n    }\n    cout<<a<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint a[21][21],ans,c,h,w;\nvoid dfs(int x,int y);\nbool ch(int x,int y){\n  return !(a[y][x-1]!=a[y-1][x-1]&&a[y-1][x]!=a[y-1][x-1]&&a[y][x-1]!=a[y-1][x]);\n}\nvoid in(int x,int y){\n  if(x==w-1)dfs(0,y+1);\n  else dfs(x+1,y);\n}\nvoid dfs(int x,int y){\n  if(x==w-1&&y==h-1)ans++;\n  else{\n    if(a[y][x])in(x,y);\n    else if(!x||!y||(ch(x,y))){\n      int col=++c;\n      a[y][x]=col;\n      if(y!=h-1&&!a[y+1][x]){\n        a[y+1][x]=col;\n        in(x,y);\n        a[y+1][x]=0;\n      }\n      if(x!=w-1&&!a[y][x+1]){\n        a[y][x+1]=col;\n        in(x,y);\n        a[y][x+1]=0;\n      }\n      a[y][x]=0;\n    }\n  }\n}\nint main(){\n  while(cin>>h>>w,h){\n    memset(a,0,sizeof(a));\n    ans=c=0;\n    if(h%2==0||w%2==0)dfs(0,0);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nconst int MAX = 20;\nint data[MAX][MAX];\nint H,W;\n/*\nvoid display(){\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      cout << data[i][j];\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n*/\nbool isCanSpread(int x,int y){\n  if(x-1 < 0 || y-1 < 0)return true;\n  if(data[y-1][x] == 2 && data[y-1][x-1] == 1)return true;\n  if(data[y-1][x-1] == 1 && data[y][x-1] == 2)return true;\n  return false;\n}\n\nvoid dfs(int x,int y,int& res){\n\n  if(x == W){\n    if(y == H-1){\n      res++;\n      //display();\n    }\n    else {\n      dfs(0,y+1,res);\n    }\n    return;\n  }\n  if(data[y][x] != -1)dfs(x+1,y,res);\n  else {\n    if(!isCanSpread(x,y))return;\n\n    data[y][x] = 1;\n\n    // tate\n    if(y+1 < H){\n      data[y+1][x] = 2;\n      dfs(x+1,y,res);\n      data[y+1][x] = -1;    \n    }\n\n    // yoko\n    if(x+1 < W){\n      if(data[y][x+1] == -1){\n        data[y][x+1] = 2;\n        dfs(x+1,y,res);\n        data[y][x+1] = -1;\n      }\n    }\n    \n    data[y][x] = -1;\n  }\n}\n\nvoid solve(){\n  for(int i = 0 ; i < MAX ; i++){\n    for(int j = 0 ; j < MAX ; j++){\n      data[i][j] = -1;\n    }                                 \n  }\n  int res = 0;\n  dfs(0,0,res);\n  cout << res << endl;\n}\n\nint main(){\n  while(cin >> H >> W,H || W)solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt dp[30];\nInt fib(Int n,Int x,Int y,int z=1){\n  if(n<0) return 0;\n  if(n<=z) return 1;\n  if(dp[n]<0) dp[n]=fib(n-x,x,y,z)+fib(n-y,x,y,z);\n  return dp[n];\n}\nsigned main(){\n  Int h,w;\n  while(cin>>h>>w,h){\n    memset(dp,-1,sizeof(dp));\n    if((h*w)&1){\n      cout<<0<<endl;\n      continue;\n    }\n    \n    if(h>w) swap(h,w);\n    if(h==1){\n      cout<<1<<endl;\n      continue;\n    }\n    if(h==2){\n      cout<<fib(w,h-1,h+1)+fib(w-h,h-1,h+1)<<endl;\n      continue;\n    }\n    if(h&1) cout<<2*fib(w/2,(h-1)/2,(h+1)/2,0)<<endl;\n    else cout<<fib(w,h-1,h+1)+fib(w-(h-2),h-1,h+1)+fib(w-h,h-1,h+1)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint m, n, ans[19][19]= {{2,3,4,6,9,13,19,28,41,60,88,129,189,277,406,595,872,1278,1873}, {3,0,4,0,6,0,10,0,16,0,26,0,42,0,68,0,110,0,178}, {4,4,2,3,3,3,5,5,6,8,8,11,13,14,19,21,25,32,35}, {6,0,3,0,2,0,2,0,4,0,4,0,6,0,8,0,10,0,14}, {9,6,3,2,2,2,1,1,2,3,4,3,3,3,4,6,6,7,6}, {13,0,3,0,2,0,2,0,0,0,2,0,4,0,2,0,2,0,6}, {19,10,5,2,1,2,2,2,1,0,0,1,2,3,4,3,2,1,1}, {28,0,5,0,1,0,2,0,2,0,0,0,0,0,2,0,4,0,2}, {41,16,6,4,2,0,1,2,2,2,1,0,0,0,0,1,2,3,4}, {60,0,8,0,3,0,0,0,2,0,2,0,0,0,0,0,0,0,2}, {88,26,8,4,4,2,0,0,1,2,2,2,1,0,0,0,0,0,0}, {129,0,11,0,3,0,1,0,0,0,2,0,2,0,0,0,0,0,0}, {189,42,13,6,3,4,2,0,0,0,1,2,2,2,1,0,0,0,0}, {277,0,14,0,3,0,3,0,0,0,0,0,2,0,2,0,0,0,0}, {406,68,19,8,4,2,4,2,0,0,0,0,1,2,2,2,1,0,0}, {595,0,21,0,6,0,3,0,1,0,0,0,0,0,2,0,2,0,0}, {872,110,25,10,6,2,2,4,2,0,0,0,0,0,1,2,2,2,1}, {1278,0,32,0,7,0,1,0,3,0,0,0,0,0,0,0,2,0,2}, {1873,178,35,14,6,6,1,2,4,2,0,0,0,0,0,0,1,2,2}};\n\nint main(){\n    cin >> m >> n;\n    while(m + n > 0){\n        if(m >= 2 && n >= 2){\n            cout << ans[m-2][n-2] << endl;\n        }else{\n            cout << 1-m%2 << endl;\n        }\n        cin >> m >> n;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nint H,W;\nint ans,limit;\n\nbool check(int table[20][20]){\n\n\tfor(int row = 1; row <= H-1; row++){\n\t\tfor(int col = 1; col <= W-1; col++){\n\t\t\tif(table[row-1][col-1] == 0 || table[row-1][col] == 0 || table[row][col-1] == 0 || table[row][col] == 0)continue;\n\n\t\t\tif(table[row-1][col-1] != table[row-1][col] && table[row-1][col-1] != table[row][col-1] && table[row-1][col-1] != table[row][col] &&\n\t\t\t\ttable[row-1][col] != table[row][col-1] && table[row-1][col] != table[row][col] && table[row][col-1] != table[row][col])return false;\n\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid recursive(int count,int row,int col,int table[20][20]){ //重複計上を防ぐため、行ごとに畳を並べる\n\tif(row == H){\n\t\tif(count == limit+1)ans++;\n\t\treturn;\n\t}\n\tif(col == W){ //次の行へ\n\t\trecursive(count,row+1,0,table);\n\t\treturn;\n\t}\n\n\tif(table[row][col] != 0){ //既に畳が敷いてある(縦)\n\t\tif(col <= W-2){\n\t\t\trecursive(count,row,col+1,table);\n\t\t}else{ //col == W-1\n\t\t\trecursive(count,row+1,0,table); //次の行へ\n\t\t}\n\t\treturn;\n\t}\n\n\tif(col <= W-2 && table[row][col+1] == 0){ //右に敷ける場合\n\t\tint next_table[20][20];\n\t\tfor(int a = 0; a < H; a++){\n\t\t\tfor(int b = 0; b < W; b++)next_table[a][b] = table[a][b];\n\t\t}\n\t\tnext_table[row][col] = count;\n\t\tnext_table[row][col+1] = count;\n\n\t\tif(check(next_table)){\n\t\t\trecursive(count+1,row,col+2,next_table);\n\t\t}\n\t}\n\tif(row <= H-2 && table[row+1][col] == 0){ //縦に敷ける場合\n\t\tint next_table[20][20];\n\t\tfor(int a = 0; a < H; a++){\n\t\t\tfor(int b = 0; b < W; b++)next_table[a][b] = table[a][b];\n\t\t}\n\t\tnext_table[row][col] = count;\n\t\tnext_table[row+1][col] = count;\n\n\t\tif(check(next_table)){\n\t\t\trecursive(count+1,row,col+1,next_table);\n\t\t}\n\n\t}\n\n}\n\n\nint main(){\n\n\tint first_table[20][20];\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tif(H == 0 && W == 0)break;\n\n\t\tif((H*W)%2 == 1){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tans = 0;\n\t\tlimit = (H*W)/2; //limit枚の畳が敷けるはず\n\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tfirst_table[row][col] = 0;\n\t\t\t}\n\t\t}\n\t\trecursive(1,0,0,first_table);\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define ck(a,b) (0<=a&&a<b)\nusing namespace std;\nint w,h,c,ans,f[20][20];\nbool crs(int y1,int x1,int y2,int x2){\n\tfor(int y=y1;y<y2;y++)for(int x=x1;x<x2;x++)if(ck(y,h)&&ck(y+1,h)&&ck(x,w)&&ck(x+1,w)&&\n\t\tf[y][x]!=f[y][x+1]&&f[y][x]!=f[y+1][x]&&f[y][x]!=f[y+1][x+1]&&\n\t\tf[y][x+1]!=f[y+1][x]&&f[y][x+1]!=f[y+1][x+1]&&f[y+1][x]!=f[y+1][x+1])return 1;\n\treturn 0;\n}\nvoid dfs(int y,int x){\n\tfor(;y<h&&(x>=w||f[y][x]);x++)if(x>=w)x=-1,y++;\n\tif(y>=h&&c*2==w*h){\n\t\tans++;return;\n\t}\n\tif(ck(x+1,w)&&!f[y][x]&&!f[y][x+1]){\n\t\tf[y][x]=f[y][x+1]=++c;\n\t\tif(!crs(y-1,x-1,y+1,x+2))dfs(y,x+2);\n\t\tf[y][x]=f[y][x+1]=0;--c;\n\t}\n\tif(ck(y+1,h)&&!f[y][x]&&!f[y+1][x]){\n\t\tf[y][x]=f[y+1][x]=++c;\n\t\tif(!crs(y-1,x-1,y+2,x+1))dfs(y,x+1);\n\t\tf[y][x]=f[y+1][x]=0;--c;\n\t}\n}\nint main(){\n\twhile(cin>>w>>h,w){\n\t\tc=ans=0;\n\t\trep(i,h)rep(j,w)f[i][j]=0;\n\t\tdfs(0,0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define UNVISITED -1\n\nint cnt;\nint tatami[20][20];\n\nvoid solve(int r,int c,int now){\n  int y=now/c,x=now%c;\n  if ( r*c == now){\n    cnt++;\n    return;\n  }\n\n  if( tatami[y][x]!=UNVISITED){\n    solve(r,c,now+1);\n    return;\n  }\n\n  if (y != 0 && x>0){\n    if ( tatami[y-1][x-1] != tatami[y-1][x] &&\n\t tatami[y-1][x-1] != tatami[y][x-1])return;\n  }\n\n  if (y != r-1 ){\n    tatami[y][x]=tatami[y+1][x]=now;\n    solve(r,c,now+1);\n    tatami[y][x]=tatami[y+1][x]=UNVISITED;\n  }\n  \n  if ( x !=c-1 && tatami[y][x+1]==UNVISITED){\n    tatami[y][x]=tatami[y][x+1]=now;\n    solve(r,c,now+2);\n    tatami[y][x]=tatami[y][x+1]=UNVISITED;\n  }\n  return;\n}\n\nmain(){\n  int r,c;\n  while(cin>>r>>c && r){\n    rep(i,r)rep(j,c)tatami[i][j]=-1;\n    cnt=0;\n    solve(r,c,0);\n    cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nvvi ta;\nint n,m,out;\nbool F(){\n\tbool h=true;\n\trep(i,n-1)rep(j,m-1){\n\t\tint a=ta[i][j],b=ta[i+1][j],c=ta[i][j+1],d=ta[i+1][j+1];\n\t\tif(a==b||a==c||a==d||b==c||b==d||c==d);\n\t\telse h=false;\n\t}\n\treturn h;\n}\nvoid f(int d,int a,int b){\n\tif(a==n){out+=F();return;}\n\tif(b==m){f(d,a+1,0);return;}\n\tif(ta[a][b]){f(d,a,b+1);return;}\n\t//tate\n\tif(a!=n-1&&ta[a+1][b]==0){\n\t\tta[a][b]=ta[a+1][b]=d;\n\t\tf(d+1,a,b+1);\n\t\tta[a][b]=ta[a+1][b]=0;\n\t}\n\t//yoko\n\tif(b!=m-1&&ta[a][b+1]==0){\n\t\tta[a][b]=ta[a][b+1]=d;\n\t\tf(d+1,a,b+2);\n\t\tta[a][b]=ta[a][b+1]=0;\t\n\t}\n}\nint main(){\n\twhile(cin>>n>>m,n+m){\n\t\tta=vvi(n,vi(m));\n\t\tout=0;\n\t\tf(1,0,0);\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint H, W, t[20][20];\nint dy[] = {0, 1}, dx[] = {1,0}; // 横　縦\n\nint judge(int y, int x){\n  map<int, int>m;\n  for(int i = -1; i < 1; i++){\n    for(int j = -1; j < 1; j++){\n      int ny = y+i, nx = x+j;\n      if(ny < 0 || nx < 0 || t[ny][nx] == -1 || m.count(t[ny][nx])) continue;\n      m[t[ny][nx]] = 1;\n    }\n  }\n  if(m.size() < 4) return 1;\n  return 0;\n}\n\nint dfs(int n){\n  int i, j, res = 0;\n  for(i = 0; i < H; i++) for(j = 0; j < W; j++) if(t[i][j] == -1) goto b;\n b:\n\n  if(i == H && j == W) return 1;\n\n  t[i][j] = n;\n  rep(d, 2){\n    int x = j+dx[d], y = i+dy[d];\n    if(x < 0 || x >= W || y < 0 || y >= H || t[y][x] != -1) continue;\n    t[y][x] = n;\n    if(judge(i, j)) res += dfs(n+1);\n    t[y][x] = -1;\n  }\n  t[i][j] = -1;\n\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d%d\", &H, &W) && H+W){\n    memset(t, -1, sizeof(t));\n    if(H%2 && W%2) puts(\"0\");\n    else if(H == W) puts(\"2\");\n    else printf(\"%d\\n\", dfs(0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint ans;\nint h, w;\nint ttm[30][30];\n\nint c;\n\nbool ok(int x, int y){\n    return x == 0 ||\n        y == 0 ||\n        ttm[y][x] == ttm[y][x - 1] ||\n        ttm[y][x - 1] == ttm[y - 1][x - 1] ||\n        ttm[y - 1][x - 1] == ttm[y - 1][x] ||\n        ttm[y - 1][x] == ttm[y][x];\n}\n\nvoid dfs(int x, int y){\n    if (x == w){\n        if (y == h - 1){\n            ans++;\n        }\n        else dfs(0, y + 1);\n        return;\n    }\n\n    if (ttm[y][x]){\n        dfs(x + 1, y);\n        return;\n    }\n    if (x + 1 != w && ttm[y][x + 1] == 0){\n        ttm[y][x] = ttm[y][x + 1] = c++;\n        if (ok(x, y)) dfs(x + 2, y);\n        ttm[y][x] = ttm[y][x + 1] = 0;\n    }\n    if (y + 1 != h && ttm[y + 1][x] == 0){\n        ttm[y][x] = ttm[y + 1][x] = c++;\n        if (ok(x, y)) dfs(x + 1, y);\n        ttm[y][x] = ttm[y + 1][x] = 0;\n    }\n}\n\nint main(){\n    while (cin >> h >> w && h){\n        ans = 0;\n        c = 1;\n        memset(ttm, 0, sizeof(ttm));\n        dfs(0, 0);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<utility>\n#include<map>\n#include<complex>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define stop char nyaa;cin>>nyaa;\n#define per(i,n) for(int i=n-1;i>=0;i--)\ntypedef long double ld;\n\nint h, w;\nint a[20][20];\nint ans;\nvoid dfs(int i, int j,int cur) {\n\tif (i == h) {\n\t\t/*cout << endl;\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tcout << a[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tans++; return;\n\t}\n\tint ni = i, nj = j + 1; if (nj == w)ni = ni + 1, nj = 0;\n\tif (a[i][j]) {\n\t\tdfs(ni, nj, cur); return;\n\t}\n\t//oo\n\tif (j < w - 1&&!a[i][j+1]) {\n\t\ta[i][j] = a[i][j + 1] = cur;\n\t\tbool f = true;\n\t\tif (j < w - 2&&i>0) {\n\t\t\tvector<int> v = { a[i - 1][j + 1],a[i][j + 1],a[i - 1][j + 2],a[i][j + 2] };\n\t\t\tsort(v.begin(), v.end());\n\t\t\tint len = unique(v.begin(), v.end()) - v.begin();\n\t\t\tif (len == 4)f = false;\n\t\t}\n\t\tif (f) {\n\t\t\tdfs(ni, nj, cur + 1);\n\t\t}\n\t\ta[i][j] = a[i][j + 1] = 0;\n\t}\n\t//else\n\tif (i < h - 1 && !a[i + 1][j]) {\n\t\ta[i][j] = a[i + 1][j] = cur;\n\t\tbool f = true;\n\t\tif (j < w - 1 && i>0) {\n\t\t\tvector<int> v = { a[i][j],a[i - 1][j],a[i][j + 1],a[i - 1][j + 1] };\n\t\t\tsort(v.begin(), v.end());\n\t\t\tint len = unique(v.begin(), v.end()) - v.begin();\n\t\t\tif (len == 4)f = false;\n\t\t}\n\t\tif (f) {\n\t\t\tdfs(ni, nj, cur + 1);\n\t\t}\n\t\ta[i][j] = a[i + 1][j] = 0;\n\t}\n}\nvoid solve() {\n\tans = 0;\n\tdfs(0, 0, 1);\n\tcout << ans << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\twhile (cin >> h >> w, h) {\n\t\tsolve();\n\t}\n\t//stop\n\t\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nint dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; /* CSS order */\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nenum state {\n\tEMPTY,\n\tHL, HR,\n\tVT, VB\n};\nvector< vector<state> > field;\nint H, W;\n\nint rec(int i, int j)\n{\n\tif (i == H) {\n\t\treturn 1;\n\t}\n\tif (j >= W) {\n\t\treturn rec(i + 1, 0);\n\t}\n\tif (field[i][j] != EMPTY) {\n\t\treturn rec(i, j + 1);\n\t}\n\n\tREP (y, H) {\n\t\tREP (x, W) {\n\t\t\tcerr << field[y][x] << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}\n\n\tint ret = 0;\n\t// horizontal\n\tif (i - 1 < 0 || j - 1 < 0 || field[i-1][j-1] == HL || field[i-1][j-1] == VT) {\n\t\tif (i - 1 < 0 || j + 2 == W || field[i-1][j+2] == HR || field[i-1][j+2] == VT) {\n\t\t\tif (j + 1 < W && field[i][j+1] == EMPTY) {\n\t\t\t\tfield[i][j] = HL, field[i][j+1] = HR;\n\t\t\t\tret += rec(i, j+1);\n\t\t\t\tfield[i][j] = EMPTY, field[i][j+1] = EMPTY;\n\t\t\t}\n\t\t}\n\t}\n\t// vertical\n\tif (i - 1 < 0 || j - 1 < 0 || field[i-1][j-1] == HL || field[i-1][j-1] == VT) {\n\t\tif (i - 1 < 0 || j + 1 == W || field[i-1][j+1] == HR || field[i-1][j+1] == VT) {\n\t\t\tif (i + 1 < H) {\n\t\t\t\tfield[i][j] = VT, field[i+1][j] = VB;\n\t\t\t\tret += rec(i, j+1);\n\t\t\t\tfield[i][j] = EMPTY, field[i+1][j] = EMPTY;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\twhile (cin >> H >> W, H | W) {\n\t\tfield = vector< vector<state> >(H, vector<state>(W, EMPTY));\n\t\tcout << rec(0, 0) << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint H,W;\n \nint used[111][111];\n \nint dx[]={0,0,-1,-1};\nint dy[]={0,-1,0,-1};\n \ntypedef long long ll;\n \nbool check(int x,int y){\n  if( x < 1 || y < 1 ) return true;\n  vector<int> p;\n  for(int i=0;i<4;i++)\n    p.push_back( used[x+dx[i]][y+dy[i]] );\n  sort(p.begin(),p.end());\n  p.erase(unique(p.begin(),p.end()),p.end());\n \n  if( p.size() == 4 ) return false;\n  return true;\n}\n \nvoid view(){\n  cout << \"view\" << endl;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cout << used[j][i] << \" \";\n    }\n    cout << endl;\n  }\n}\n \nll dfs(int x,int y,int cnt){\n \n  if( x >= W ) return dfs(0,y+1,cnt);\n  //  view();\n  if( y >= H ){\n    return 1LL;\n  }\n  ll res = 0;\n \n  if( used[x][y] == -1 ){\n    if( x + 1 < W && used[x+1][y] == -1 ){\n      used[x][y] = cnt;\n      used[x+1][y] = cnt;\n      if( check( x, y ) ){\n    res += dfs(x+1,y,cnt+1);\n      }\n      used[x][y] = -1;\n      used[x+1][y] = -1;\n    }\n    if( y + 1 < H && used[x][y+1] == -1 ){\n      used[x][y] = cnt;\n      used[x][y+1] = cnt;\n      if( check( x, y ) ){\n    res += dfs(x+1,y,cnt+1);\n      }\n      used[x][y] = -1;\n      used[x][y+1] = -1;\n    }\n  } else if( check(x,y) )\n      return dfs(x+1,y,cnt);\n   \n  return res;\n}\n \nint main(){\n  while( cin >> H >> W &&(W||H) ){\n    memset(used,-1,sizeof(used));\n    cout << dfs(0,0,0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tbool ok2 = !((c1 * c2 * c3 * c4) && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\n\t\t\tok = ok & ok2;\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0, starty = count_ / W;\n\n\tfor (int i = starty; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (!tatami[i][j])\n\t\t\t{\n\t\t\t\tif (H - i - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i + 1][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (W - j - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i][j + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\", dfs(1, vector<vector<int> >(H, vector<int>(W, 0))));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tbool ok2 = !((c1 * c2 * c3 * c4) && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\n\t\t\tok = ok & ok2;\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0, starty = count_ / W;\n\n\tfor (int i = starty; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (!tatami[i][j])\n\t\t\t{\n\t\t\t\tif (H - i - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i + 1][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (W - j - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i][j + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\", dfs(1, vector<vector<int> >(H, vector<int>(W, 0))));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst int dy[][4] = {{0, 0, 1, 1}, {0, 0, 2, 2}};\nconst int dx[][4] = {{0, 2, 0, 2}, {0, 1, 0, 1}};\n\nint h, w;\nvector<vector<bool> > used;\nvector<vector<int> > corner;\n\nint solve(int y, int x)\n{\n    if(x > w){\n        ++ y;\n        x = 1;\n        if(y > h)\n            return 1;\n    }\n\n    if(used[y][x])\n        return solve(y, x+1);\n\n    int ret = 0;\n    for(int j=0; j<2; ++j){\n        if(!used[y+j][x+(j^1)]){\n            bool ok = true;\n            used[y][x] = used[y+j][x+(j^1)] = true;\n            for(int i=0; i<4; ++i){\n                if(++ corner[y+dy[j][i]][x+dx[j][i]] == 4)\n                    ok = false;\n            }\n        \n            if(ok)\n                ret += solve(y, x+1);\n\n            for(int i=0; i<4; ++i)\n                -- corner[y+dy[j][i]][x+dx[j][i]];\n            used[y][x] = used[y+j][x+(j^1)] = false;\n        }\n    }\n\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        cin >> h >> w;\n        if(h == 0)\n            return 0;\n\n        used.assign(h+2, vector<bool>(w+2, true));\n        for(int y=1; y<=h; ++y){\n            for(int x=1; x<=w; ++x){\n                used[y][x] = false;\n            }\n        }\n        corner.assign(h+2, vector<int>(w+2, 0));\n\n        cout << solve(1, 1) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\ntypedef vector<vi> mat;\nmat fld;\nint h, w;\n\nint check()\n{\n\tREP(i, h - 1)REP(j, w - 1)\n\t{\n\t\tset<int> st;\n\t\tst.insert(fld[i][j]);\n\t\tst.insert(fld[i+1][j]);\n\t\tst.insert(fld[i][j+1]);\n\t\tst.insert(fld[i+1][j+1]);\n\t\tif (st.size() == 4) return 0;\n\t}\n\treturn 1;\n}\n\nint cnt = 0;\nvoid solve(int p)\n{\n\tint x = p / w, y = p % w;\n\tif (p == h*w) cnt += check();\n\telse if (fld[x][y] != -1) solve(p + 1);\n\telse\n\t{\n\t\tfld[x][y] = p;\n\t\tif (x != h - 1 && fld[x + 1][y] == -1)\n\t\t{\n\t\t\tfld[x + 1][y] = p;\n\t\t\tsolve(p + 1);\n\t\t\tfld[x + 1][y] = -1;\n\t\t}\n\t\tif (y != w - 1 && fld[x][y + 1] == -1)\n\t\t{\n\t\t\tfld[x][y + 1] = p;\n\t\t\tsolve(p + 1);\n\t\t\tfld[x][y + 1] = -1;\n\t\t}\n\t\tfld[x][y] = -1;\n\t}\n}\n\nint main()\n{\n\twhile (cin >> h >> w, h)\n\t{\n\t\tfld.resize(h, vi(w, -1));\n\t\tqueue<pair<mat, int>> que;\n\t\tque.push(make_pair(fld, 0));\n\t\tcnt = 0;\n\t\tsolve(0);\n\t\tcout << cnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\nbool used[30][30];\nbool forbid[30][30];\nint H, W;\nint dfs(int x, int y){\n    if(x == W) return dfs(0, y + 1);\n    if(y == H) return 1;\n    if(used[y][x]) return dfs(x + 1, y);\n    if(forbid[y][x]) return 0;\n    int res = 0;\n    if(y + 1 < H && !used[y][x] && !used[y + 1][x]){\n        bool tmp = forbid[y + 2][x + 1];\n        used[y][x] = true;\n        used[y + 1][x] = true;\n        forbid[y + 2][x + 1] = true;\n        res += dfs(x + 1, y);\n        used[y][x] = false;\n        used[y + 1][x] = false;\n        forbid[y + 2][x + 1] = tmp;\n    }\n    if(x + 1 < W && !used[y][x] && !used[y][x + 1]){\n        bool tmp = forbid[y + 1][x + 2];\n        used[y][x] = true;\n        used[y][x + 1] = true;\n        forbid[y + 1][x + 2] = true;\n        res += dfs(x + 2, y);\n        used[y][x] = false;\n        used[y][x + 1] = false;\n        forbid[y + 1][x + 2] = tmp;\n    }\n    return res;\n}\nint main(){\n    while(cin >> H >> W && (H > 0 && W > 0)){\n        memset(used, 0, sizeof used);\n        memset(forbid, 0, sizeof forbid);\n        REP(y, 30) REP(x, 30) assert(!used[y][x]);\n        REP(y, 30) REP(x, 30) assert(!forbid[y][x]);\n        cout << dfs(0, 0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt dp[30];\nInt fib(Int n,Int x,Int y){\n  if(n<0) return 0;\n  if(n<=1) return 1;\n  if(~dp[n]) return dp[n];\n  return dp[n]=fib(n-x,x,y)+fib(n-y,x,y);\n}\nsigned main(){\n  Int h,w;\n  while(cin>>h>>w,h){\n    memset(dp,-1,sizeof(dp));\n    if((h*w)&1){\n      cout<<0<<endl;\n      continue;\n    }\n    \n    if(h>w) swap(h,w);\n    if(h==1){\n      cout<<1<<endl;\n      continue;\n    }\n    if(h==2){\n      cout<<fib(w,h-1,h+1)+fib(w-h,h-1,h+1)<<endl;\n      continue;\n    }\n    if(h==3){\n      cout<<2*fib(w/2,1,2)<<endl;\n      continue;\n    }\n    \n    if(h&1) swap(h,w);\n    \n    cout<<fib(w,h-1,h+1)+fib(w-(h-2),h-1,h+1)+fib(w-h,h-1,h+1)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nint h,w;\nint dfs(vvi f,int x);\nbool check(vvi f){\n    for(int i=0;i+1<h;i++){\n        for(int j=0;j+1<w;j++){\n            set<int> s;\n            for(int di=0;di<2;di++){\n                for(int dj=0;dj<2;dj++){\n                    if(f[i+di][j+dj]) s.insert(f[i+di][j+dj]);\n                }\n            }\n            if(s.size()==4) return false;\n        }\n    }\n    return true;\n}\nint impl(vvi f,int i,int j,int x){\n    int res=0;\n    for(int k=0;k<2;k++){\n        if(0<=i+k-1 && i+k<h && f[i+k-1][j]==f[i+k][j]){\n            f[i+k-1][j]=f[i+k][j]=x;\n            if(check(f)) res+=dfs(f,x+1);\n            f[i+k-1][j]=f[i+k][j]=0;\n        }\n        if(0<=j+k-1 && j+k<w && f[i][j+k-1]==f[i][j+k]){\n            f[i][j+k-1]=f[i][j+k]=x;\n            if(check(f)) res+=dfs(f,x+1);\n            f[i][j+k-1]=f[i][j+k]=0;\n        }\n    }\n    return res;\n}\nint dfs(vvi f,int x){\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(!f[i][j]){\n                return impl(f,i,j,x);\n            }\n        }\n    }\n    return 1;\n}\nint solve(){\n    vvi tmpf(h,vi(w,0));\n    return dfs(tmpf,1);\n}\n\nint main(){\n    while(cin>>h>>w,h){\n        cout<<solve()<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tok = ok && !(c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0 && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\t//if (hantei(tatami) == false) { return 0; }\n\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (tatami[i][j] == 0)\n\t\t\t{\n\t\t\t\tif (i + 1 < H)\n\t\t\t\t{\n\t\t\t\t\tif (tatami[i + 1][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (j + 1 < W)\n\t\t\t\t{\n\t\t\t\t\tif (tatami[i][j + 1] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\", dfs(1, vector<vector<int> >(H, vector<int>(W, 0))));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1;)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][++l];\n\n\t\t\tbool ok2 = !((c1 * c2 * c3 * c4) && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\n\t\t\tok = ok && ok2;\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0, starty = count_ / W;\n\n\tfor (int i = starty; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (!tatami[i][j])\n\t\t\t{\n\t\t\t\tif (H - i - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i + 1][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (W - j - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i][j + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\", dfs(1, vector<vector<int> >(H, vector<int>(W, 0))));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_H 20\n#define MAX_W 20\n \nint H,W;\nint id[MAX_H][MAX_W];\n \nbool check(int x,int y){\n    const int dx[4] = {-1,0,-1,0};\n    const int dy[4] = {-1,-1,0,0};\n    if(x < 1 || y < 1) return true;\n    set<int> st;\n    for(int i = 0 ; i < 4 ; i++){\n\tint nx = x + dx[i],ny = y + dy[i];\n\tst.insert(id[ny][nx]);\n    }\n    return (st.size() < 4);\n}\n \nint dfs(int x,int y,int num){\n    if(x == W) return dfs(0,y+1,num);\n    if(y == H) return 1;\n    if(id[y][x] >= 0) return dfs(x+1,y,num);\n    if(!check(x,y)) return 0;\n \n    int res = 0;\n    if(x+1 < W && id[y][x+1] == -1){\n\tid[y][x] = id[y][x+1] = num;\n\tres += dfs(x+2,y,num+1);\n\tid[y][x] = id[y][x+1] = -1;\n    }\n    if(y+1 < H && id[y+1][x] == -1){\n\tid[y][x] = id[y+1][x] = num;\n\tres += dfs(x+1,y,num+1);\n\tid[y][x] = id[y+1][x] = -1;\n    }\n    return res;\n}\n \nint main(){\n    while(cin >> H >> W,H){\n\tmemset(id,-1,sizeof(id));\n\tcout << dfs(0,0,0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<unsigned char> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tunsigned char c1 = tatami[k][l];\n\t\t\tunsigned char c2 = tatami[k][l + 1];\n\t\t\tunsigned char c3 = tatami[k + 1][l];\n\t\t\tunsigned char c4 = tatami[k + 1][l + 1];\n\n\t\t\tbool ok2 = !(c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0 && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\n\t\t\tok = ok && ok2;\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(unsigned char count_, vector<vector<unsigned char> > tatami)\n{\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0, starty = count_ / W;\n\n\tfor (int i = starty; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (!tatami[i][j])\n\t\t\t{\n\t\t\t\tif (H - i - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i + 1][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<unsigned char> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (W - j - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i][j + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<unsigned char> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\", dfs(1, vector<vector<unsigned char> >(H, vector<unsigned char>(W, 0))));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt dp[30];\nInt fib(Int n){\n  if(n<=2) return 1;\n  if(~dp[n]) return dp[n];\n  return dp[n]=fib(n-1)+fib(n-2);\n}\nsigned main(){\n  Int h,w;\n  memset(dp,-1,sizeof(dp));\n  while(cin>>h>>w,h){\n    if(h>w) swap(h,w);\n    if((h*w)&1){\n      cout<<0<<endl;\n      continue;\n    }\n    if(h==1){\n      cout<<1<<endl;\n      continue;\n    }\n    if(h==2){\n      cout<<fib(w)<<endl;\n      continue;\n    }\n    \n    Int res=0;\n    if(h==3) res+=2;\n    if(w==3) res+=2;\n    \n    if(h==4) res+=1+(w%3==0);\n    if(w==4) res+=1+(h%3==0);\n    \n    cout<<res<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint H, W;\n\nbool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tok = ok && !(c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0 && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\t\t}\n\t}\n\n\treturn ok;\n}\n\nint dfs(int count_, vector<vector<int> > tatami)\n{\n\tif ((count_ - 1) * 2 == H * W) { return (hantei(tatami) ? 1 : 0); }\n\n\tint sum = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (tatami[i][j] == 0)\n\t\t\t{\n\t\t\t\tbool ok = hantei(tatami);\n\n\t\t\t\tif (ok)\n\t\t\t\t{\n\t\t\t\t\tif (i + 1 < H)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tatami[i + 1][j] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (j + 1 < W)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tatami[i][j + 1] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tcin >> H >> W;\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tcout << dfs(1, vector<vector<int> >(H, vector<int>(W, 0))) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1;)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][++l];\n\n\t\t\tbool ok2 = !((c1 * c2 * c3 * c4) && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\n\t\t\tok = ok && ok2;\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0, starty = count_ / W;\n\n\tfor (int i = starty; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (!tatami[i][j])\n\t\t\t{\n\t\t\t\tif (H - i - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i + 1][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (W - j - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i][j + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\", dfs(1, vector<vector<int> >(H, vector<int>(W, 0))));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint H,W;\n\nint used[111][111];\n\nint dx[]={0,0,-1,-1};\nint dy[]={0,-1,0,-1};\n\ntypedef long long ll;\n\nbool check(int x,int y){\n  if( x < 1 || y < 1 ) return true;\n  vector<int> p;\n  for(int i=0;i<4;i++)\n    p.push_back( used[x+dx[i]][y+dy[i]] ); \n  sort(p.begin(),p.end());\n  p.erase(unique(p.begin(),p.end()),p.end());\n\n  if( p.size() == 4 ) return false;\n  return true;\n}\n\nvoid view(){\n  cout << \"view\" << endl;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cout << used[j][i] << \" \";\n    }\n    cout << endl;\n  }\n}\n\nll dfs(int x,int y,int cnt){\n\n  if( x >= W ) return dfs(0,y+1,cnt);\n  //  view();\n  if( y >= H ){\n    return 1LL;\n  }\n  ll res = 0;\n\n  if( used[x][y] == -1 ){\n    if( x + 1 < W && used[x+1][y] == -1 ){\n      used[x][y] = cnt;\n      used[x+1][y] = cnt;\n      if( check( x, y ) ){\n\tres += dfs(x+1,y,cnt+1);\n      }\n      used[x][y] = -1;\n      used[x+1][y] = -1;\n    }\n    if( y + 1 < H && used[x][y+1] == -1 ){\n      used[x][y] = cnt;\n      used[x][y+1] = cnt;\n      if( check( x, y ) ){\n\tres += dfs(x+1,y,cnt+1);\n      }\n      used[x][y] = -1;\n      used[x][y+1] = -1;\n    }\n  } else if( check(x,y) )\n      return dfs(x+1,y,cnt);\n  \n  return res;\n}\n\nint main(){\n  while( cin >> H >> W &&(W||H) ){\n    memset(used,-1,sizeof(used));\n    cout << dfs(0,0,0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lli;\n\nlli H, W;\nmap<deque<lli>, lli> dp[2];\n\nint main() {\n  while(cin >> H >> W && (H|W)) {\n    dp[0].clear(); dp[1].clear();\n    dp[0][deque<lli>(W+1, 0)] = 1;\n    lli now = 0, next = 1;\n    for(lli i = 0; i < H; ++i) {\n      for(lli j = 0; j < W; ++j) {\n\tfor(map<deque<lli>, lli>::iterator it = dp[now].begin();\n\t    it != dp[now].end(); ++it) {\n\t  deque<lli> d = it->first;\n\t  lli num = it->second;\n\t  if(d[1] == 1 && d[W] == 2) continue;\n\t  if(d[1] == 1 || d[W] == 2) {\n\t    d.pop_front();\n\t    d.push_back(0);\n\t    dp[next][d] += num;\n\t    continue;\n\t  }\n\t  if(i && j && !d[0]) {\n\t    continue;\n\t  }\n\t  if(i+1 != H) {\n\t    lli tmp = d.front();\n\t    d.pop_front();\n\t    d.push_back(1);\n\t    dp[next][d] += num;\n\t    d.push_front(tmp);\n\t    d.pop_back();\n\t  }\n\t  if(j+1 != W) {\n\t    lli tmp = d.front();\n\t    d.pop_front();\n\t    d.push_back(2);\n\t    dp[next][d] += num;\n\t    d.push_front(tmp);\n\t    d.pop_back();\n\t  }\n\t}\n\tswap(now, next);\n\tdp[next].clear();\n      }\n    }\n    lli res = 0;\n    for(map<deque<lli>, lli>::iterator it = dp[now].begin();\n\t    it != dp[now].end(); ++it) {\n      res += it->second;\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint H, W, t[20][20];\nint dy[] = {0, 1}, dx[] = {1,0}; // 横　縦\n\nint judge(int y, int x){\n  map<int, int>m;\n  for(int i = -1; i < 1; i++){\n    for(int j = -1; j < 1; j++){\n      int ny = y+i, nx = x+j;\n      if(ny < 0 || nx < 0 || t[ny][nx] == -1 || m.count(t[ny][nx])) continue;\n      m[t[ny][nx]] = 1;\n    }\n  }\n  if(m.size() < 4) return 1;\n  return 0;\n}\n\nint dfs(int n){\n  int i, j, res = 0;\n  for(i = 0; i < H; i++) for(j = 0; j < W; j++) if(t[i][j] == -1) goto b;\n b:\n\n  if(i == H && j == W) return 1;\n\n  int tmp[20][20];\n  rep(i, H) rep(j, W) tmp[i][j] = t[i][j];\n\n  t[i][j] = n;\n  rep(d, 2){\n    int x = j+dx[d], y = i+dy[d];\n    if(x < 0 || x >= W || y < 0 || y >= H || t[y][x] != -1) continue;\n    t[y][x] = n;\n    if(judge(i, j)) res += dfs(n+1);\n    t[y][x] = -1;\n  }\n  rep(i, H) rep(j, W) t[i][j] = tmp[i][j];\n\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d%d\", &H, &W) && H+W){\n    memset(t, -1, sizeof(t));\n    printf(\"%d\\n\", dfs(0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tbool ok2 = !((c1 * c2 * c3 * c4) & c1 != c2 & c1 != c3 & c1 != c4 & c2 != c3 & c2 != c4 & c3 != c4);\n\n\t\t\tok = ok & ok2;\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0, starty = count_ / W;\n\n\tfor (int i = starty; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (!tatami[i][j])\n\t\t\t{\n\t\t\t\tif (H - i - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i + 1][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (W - j - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i][j + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\", dfs(1, vector<vector<int> >(H, vector<int>(W, 0))));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tbool ok2 = !((c1 * c2 * c3 * c4) && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\n\t\t\tok = ok & ok2;\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0, starty = count_ / W;\n\n\tfor (int i = starty; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (!tatami[i][j])\n\t\t\t{\n\t\t\t\tif (H - i - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i + 1][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (W - j - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i][j + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\");\n\t\t}\n\t\telse if (H == W)\n\t\t{\n\t\t\tprintf(\"2\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvector<vector<int> > start(H, vector<int>(W, 0));\n\n\t\t\tprintf(\"%d\\n\", dfs(1, start));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint h,w;\nint res;\nint crtnum;\nint num[22][22];\n\nvoid dfs(int i,int j){\n  if(i==h){\n    bool ok=true;\n    rep(a,h-1){\n      rep(b,w-1){\n        vector<int> tmp;\n        tmp.push_back(num[a][b]); tmp.push_back(num[a][b+1]); tmp.push_back(num[a+1][b]); tmp.push_back(num[a+1][b+1]);\n        sort(all(tmp)); uni(tmp);\n        if(tmp.size()==4){\n          ok=false;\n          break;\n        }\n      }\n      if(!ok)break;\n    }\n    if(ok)res++;\n    return ;\n  }\n  int ni,nj;\n  if(j==w-1){\n    ni=i+1; nj=0;\n  }else{\n    ni=i; nj=j+1;\n  }\n\n  if(j+1<w&&num[i][j]==-1&&num[i][j+1]==-1){\n    num[i][j]=num[i][j+1]=crtnum++;\n\n    bool ok=true;\n    for(int ci=max(0,i-1);ci<=min(h-1,i);ci++){\n      for(int cj=max(0,j-1);cj<=min(w-1,j+1);cj++){\n        vector<int> tmp;\n        tmp.push_back(num[ci][cj]); tmp.push_back(num[ci][cj+1]); tmp.push_back(num[ci+1][cj]); tmp.push_back(num[ci+1][cj+1]);\n        sort(all(tmp)); uni(tmp);\n        if(tmp[0]!=-1&&tmp.size()==4){\n          ok=false;\n          break;\n        }\n      }\n      if(!ok)break;\n    }\n\n    if(ok)dfs(ni,nj);\n    num[i][j]=num[i][j+1]=-1;\n    crtnum--;\n  }\n  if(i+1<h&&num[i][j]==-1&&num[i+1][j]==-1){\n    num[i][j]=num[i+1][j]=crtnum++;\n    \n    bool ok=true;\n    for(int ci=max(0,i-1);ci<=min(h-1,i+1);ci++){\n      for(int cj=max(0,j-1);cj<=min(w-1,j);cj++){\n        vector<int> tmp;\n        tmp.push_back(num[ci][cj]); tmp.push_back(num[ci][cj+1]); tmp.push_back(num[ci+1][cj]); tmp.push_back(num[ci+1][cj+1]);\n        sort(all(tmp)); uni(tmp);\n        if(tmp[0]!=-1&&tmp.size()==4){\n          ok=false;\n          break;\n        }\n      }\n      if(!ok)break;\n    }\n\n    if(ok)dfs(ni,nj);\n\n    num[i][j]=num[i+1][j]=-1;\n    crtnum--;\n  }\n  if(num[i][j]!=-1){\n    dfs(ni,nj);\n  }\n}\n\nint main(){\n  while(1){\n    cin>>h>>w;\n    if(h==0)break;\n    crtnum=0; res=0;\n    memset(num,-1,sizeof(num));\n    dfs(0,0);\n    cout<<res<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nint ans;\nint h, w;\nint ttm[30][30];\nint c;\n\nbool ok(int x, int y){\n    return x==0 ||\n        y==0 ||\n        ttm[y][x]==ttm[y][x-1] ||\n        ttm[y][x-1]==ttm[y-1][x-1] ||\n        ttm[y-1][x-1]==ttm[y-1][x] ||\n        ttm[y-1][x]==ttm[y][x];\n}\n\nvoid dfs(int x, int y){\n    if(x==w){\n    if(y==h-1){\n            ans++;\n            return;\n        }\n        else dfs(0,y+1);\n        return;\n    }\n\n    if(ttm[y][x]) dfs(x+1,y);\n    else{\n        if(x+1!=w && ttm[y][x+1]==0){\n            ttm[y][x] = ttm[y][x+1] = c++;\n            if(ok(x,y)) dfs(x+2,y);\n            ttm[y][x] = ttm[y][x+1] = 0;\n        }\n        if(y+1!=h && ttm[y+1][x]==0){\n            ttm[y][x] = ttm[y+1][x] = c++;\n            if(ok(x,y)) dfs(x+1,y);\n            ttm[y][x] = ttm[y+1][x] = 0;\n        }\n    }\n}\nint main(){\n    while(cin >> h >> w && h){\n        ans = 0;\n        c = 1;\n        memset(ttm,0,sizeof(ttm));\n        dfs(0, 0);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tok = ok && !(c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0 && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\tif (count_ >= 4)\n\t{\n\t\tif (!hantei(tatami))\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (tatami[i][j] == 0)\n\t\t\t{\n\t\t\t\tif (i + 1 < H)\n\t\t\t\t{\n\t\t\t\t\tif (tatami[i + 1][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (j + 1 < W)\n\t\t\t\t{\n\t\t\t\t\tif (tatami[i][j + 1] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2 = tatami;\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\", dfs(1, vector<vector<int> >(H, vector<int>(W, 0))));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tbool ok2 = !(c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0 && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\n\t\t\tok = ok && ok2;\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\tif ((count_ - 1) * 2 == H * W)\n\t{\n\t\treturn 1;\n\t}\n\n\tint sum = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (!tatami[i][j])\n\t\t\t{\n\t\t\t\tif (H - i - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i + 1][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (W - j - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i][j + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\\n\");\n\t\t}\n\t\telse if (H == W)\n\t\t{\n\t\t\tprintf(\"2\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvector<vector<int> > start(H, vector<int>(W, 0));\n\n\t\t\tprintf(\"%d\\n\", dfs(1, start));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<char> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tunsigned char c1 = tatami[k][l];\n\t\t\tunsigned char c2 = tatami[k][l + 1];\n\t\t\tunsigned char c3 = tatami[k + 1][l];\n\t\t\tunsigned char c4 = tatami[k + 1][l + 1];\n\n\t\t\tbool ok2 = !(c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0 && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\n\t\t\tok = ok && ok2;\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(char count_, vector<vector<char> > tatami)\n{\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0, starty = count_ / W;\n\n\tfor (int i = starty; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (!tatami[i][j])\n\t\t\t{\n\t\t\t\tif (H - i - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i + 1][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<char> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (W - j - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i][j + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<char> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\", dfs(1, vector<vector<char> >(H, vector<char>(W, 0))));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt dp[30];\nInt fib(Int n,Int x,Int y){\n  if(n<0) return 0;\n  if(n<=1) return 1;\n  if(~dp[n]) return dp[n];\n  return dp[n]=fib(n-x,x,y)+fib(n-y,x,y);\n}\nsigned main(){\n  Int h,w;\n  while(cin>>h>>w,h){\n    memset(dp,-1,sizeof(dp));\n    if(h>w) swap(h,w);\n    if((h*w)&1){\n      cout<<0<<endl;\n      continue;\n    }\n    if(h==1){\n      cout<<1<<endl;\n      continue;\n    }\n    if(h==2){\n      cout<<fib(w,1,2)<<endl;\n      continue;\n    }\n    if(h&1){\n      cout<<2*fib(w/2,(h-1)/2,(h+1)/2)<<endl;\n      continue;\n    }\n    if(1){\n      Int dp2[100]={};\n      dp2[0]=1;\n      dp2[1]=1;\n      for(Int i=0;i<w;i++){\n\tdp2[i+(h-2)+1]+=dp2[i];\n\tdp2[i+(h-0)+1]+=dp2[i];\n      }\n      cout<<dp2[w-1]+dp2[w]<<endl;\n      continue;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint w, h;\nbool exist[30][30];\n\nint calc(int x, int y, int low, int high) {\n  //cout << x << \" \" << y << \" \"<< low << \" \" << high << endl;\n  if (y == h) { return 1; }\n  if (x == w + 1) { return 0; }\n  if (x == w) {\n    int nhigh = high & ~(1 << x);\n    return calc(0, y + 1, nhigh, 0);\n  }\n  if (exist[y][x]) {\n    int nhigh = high | (1 << x) | (1 << (x + 1));\n    return calc(x + 1, y, low, nhigh);\n  }\n  int ret = 0;\n  int prev = (low >> (x + 1)) & 1;\n  int next = (low >> (x + 2)) & 1;\n  exist[y][x] = true;\n  if (!exist[y][x + 1] && !next) {\n    int nhigh = high | (1 << (x + 2));\n    exist[y][x + 1] = true;\n    ret += calc(x + 2, y, low, nhigh);\n    exist[y][x + 1] = false;\n  }\n  if (!prev && y != h - 1) {\n    int nhigh = high & ~(1 << x);\n    exist[y + 1][x] = true;\n    ret += calc(x + 1, y, low, nhigh);\n    exist[y + 1][x] = false;\n  }\n  exist[y][x] = false;\n  return ret;\n}\n\nint main() {\n  MEMSET(exist, false);\n  while (scanf(\"%d %d\", &w, &h), w|h) {\n    if (w > h) { swap(w, h); }\n    printf(\"%d\\n\", calc(0, 0, 0, 0));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt dp[30];\nInt fib(Int n){\n  if(n<0) return 0;\n  if(n<=1) return 1;\n  if(~dp[n]) return dp[n];\n  return dp[n]=fib(n-1)+fib(n-2);\n}\nsigned main(){\n  Int h,w;\n  while(cin>>h>>w,h){\n    memset(dp,-1,sizeof(dp));\n    if((h*w)&1){\n      cout<<0<<endl;\n      continue;\n    }\n    \n    if(h>w) swap(h,w);\n    if(h==1){\n      cout<<1<<endl;\n      continue;\n    }\n    if(h==2){\n      cout<<fib(w)<<endl;\n      continue;\n    }\n    if(h==3){\n      cout<<2*fib(w/2)<<endl;\n      continue;\n    }\n    \n    if(h&1) swap(h,w);\n    \n    Int dp2[100]={};\n    dp2[0]=1;\n    dp2[1]=1;\n    for(Int i=0;i<=w;i++){\n      //cout<<i<<\":\"<<dp2[i]<<endl;\n      dp2[i+(h-2)+1]+=dp2[i];\n      dp2[i+(h-0)+1]+=dp2[i];\n    }\n    cout<<dp2[w]+dp2[w+1]<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nstruct State { int x[20][20]; };\nint H, W;\nint solve(State S, int cx, int cy, int depth) {\n\tif (cx == 30)return 1;\n\tint cnt = 0;\n\t//------------Yoko ni oku-------------\n\tif (cy < W - 1) {\n\t\tbool flag = true;\n\t\tif (cx >= 1 && cy >= 1 && S.x[cx][cy - 1] != S.x[cx - 1][cy] && S.x[cx - 1][cy - 1] != S.x[cx - 1][cy] && S.x[cx - 1][cy - 1] != S.x[cx][cy - 1])flag = false;\n\t\tif (cx >= 1 && cy <= W - 3 && S.x[cx][cy + 2] != S.x[cx - 1][cy + 1] && S.x[cx - 1][cy + 2] != S.x[cx - 1][cy + 1] && S.x[cx - 1][cy + 2] != S.x[cx][cy + 2])flag = false;\n\t\tif (cy == W - 1 || S.x[cx][cy + 1] >= 1)flag = false;\n\t\tif (flag == true) {\n\t\t\tState T = S; T.x[cx][cy] = depth; T.x[cx][cy + 1] = depth;\n\t\t\tint dx = cx, dy = cy;\n\t\t\twhile (T.x[dx][dy] >= 1) {\n\t\t\t\tdy++; if (dy == W) { dy = 0; dx++; }\n\t\t\t\tif (dx == H) { dx = 30; break; }\n\t\t\t}\n\t\t\tcnt += solve(T, dx, dy, depth + 1);\n\t\t}\n\t}\n\t//------------Tate ni oku--------------\n\tif (cx < H - 1) {\n\t\tbool flag = true;\n\t\tif (cx >= 1 && cy >= 1 && S.x[cx][cy - 1] != S.x[cx - 1][cy] && S.x[cx - 1][cy - 1] != S.x[cx - 1][cy] && S.x[cx - 1][cy - 1] != S.x[cx][cy - 1])flag = false;\n\t\tif (cx >= 1 && cy <= W - 2 && S.x[cx][cy + 1] != S.x[cx - 1][cy] && S.x[cx - 1][cy + 1] != S.x[cx - 1][cy] && S.x[cx - 1][cy + 1] != S.x[cx][cy + 1])flag = false;\n\t\tif (cx == H - 1 || S.x[cx + 1][cy] >= 1)flag = false;\n\t\tif (flag == true) {\n\t\t\tState T = S; T.x[cx][cy] = depth; T.x[cx + 1][cy] = depth;\n\t\t\tint dx = cx, dy = cy;\n\t\t\twhile (T.x[dx][dy] >= 1) {\n\t\t\t\tdy++; if (dy == W) { dy = 0; dx++; }\n\t\t\t\tif (dx == H) { dx = 30; break; }\n\t\t\t}\n\t\t\tcnt += solve(T, dx, dy, depth + 1);\n\t\t}\n\t}\n\treturn cnt;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> H >> W; if (H == 0 && W == 0)break;\n\t\tState r; for (int i = 0; i < H; i++) { for (int j = 0; j < W; j++)r.x[i][j] = 0; }\n\t\tint ans = solve(r, 0, 0, 1);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <stdio.h>\n#include <string>\n\nusing namespace std;\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nint board[44][44];\nint h, w;\n\nint DFS(int x, int y, int n){\n\tint ret = 0;\n\twhile(board[x][y] != 0){\n\t\tx++;\n\t\tif(x > w){\n\t\t\ty++;\n\t\t\tx = 1;\n\t\t\tif(y > h)return 1;\n\t\t}\n\t}\n\t//たて向き\n\tif(board[x][y+1]==0){\n\t\tint check = 0;\n\t\tif(board[x][y-1] != board[x+1][y-1])check++;\n\t\tif(board[x+1][y-1] != board[x+1][y])check++;\n\t\tif(check != 2){\n\t\t\tboard[x][y] = n;\n\t\t\tboard[x][y+1] = n;\n\t\t\tret += DFS(x,y,n+1);\n\t\t\tboard[x][y] = 0;\n\t\t\tboard[x][y+1] = 0;\n\t\t}\n\t}\n\t//よこ向き\n\tif(board[x+1][y]==0){\n\t\tint check = 0;\n\t\tif(board[x+1][y-1] != board[x+2][y-1])check++;\n\t\tif(board[x+2][y] != board[x+2][y-1])check++;\n\t\tif(check != 2){\n\t\t\tboard[x][y] = n;\n\t\t\tboard[x+1][y] = n;\n\t\t\tret += DFS(x,y,n+1);\n\t\t\tboard[x][y] = 0;\n\t\t\tboard[x+1][y] = 0;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(1){\n\t\tmemset(board, 0, sizeof(board));\n\t\tcin >> h>> w;\n\t\tif(h==0)break;\n\t\tREP(i,w+2){\n\t\t\tboard[i][0] = 1000;\n\t\t\tboard[i][h+1] = 1000;\n\t\t}\n\t\tREP(i,h+2){\n\t\t\tboard[0][i] = 1000;\n\t\t\tboard[w+1][i] = 1000;\n\t\t}\n\t\tif(h==0)return 0;\n\t\tcout << DFS(1, 1, 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint a[21][21],ans,c,h,w;\nbool ch(int x,int y){\n  return !(a[y][x-1]!=a[y-1][x-1]&&a[y-1][x]!=a[y-1][x-1]&&a[y][x-1]!=a[y-1][x]);\n}\nvoid dfs(int x,int y){\n  if(x==w-1&&y==h-1)ans++;\n  else{\n    if(a[y][x]){\n      if(x==w-1)dfs(0,y+1);\n      else dfs(x+1,y);\n    }\n    else if(!x||!y||(ch(x,y))){\n      int col=++c;\n      a[y][x]=col;\n      if(y!=h-1&&!a[y+1][x]){\n        a[y+1][x]=col;\n        if(x==w-1)dfs(0,y+1);\n        else dfs(x+1,y);\n        a[y+1][x]=0;\n      }\n      if(x!=w-1&&!a[y][x+1]){\n        a[y][x+1]=col;\n        if(x==w-1)dfs(0,y+1);\n        else dfs(x+1,y);\n        a[y][x+1]=0;\n      }\n      a[y][x]=0;\n    }\n  }\n}\nint main(){\n  while(cin>>h>>w,h){\n    memset(a,0,sizeof(a));\n    ans=c=0;\n    dfs(0,0);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_H 20\n#define MAX_W 20\n\nint H,W;\nint id[MAX_H][MAX_W];\n\nbool check(int x,int y){\n  const int dx[4] = {-1,0,-1,0};\n  const int dy[4] = {-1,-1,0,0};\n  if(x < 1 || y < 1){ return true; }\n  set<int> st;\n  for(int i = 0 ; i < 4 ; i++){\n    int nx = x + dx[i],ny = y + dy[i];\n    st.insert(id[ny][nx]);\n  }\n  return (st.size() < 4);\n}\n\nint dfs(int x,int y,int num){\n  if(x == W){ return dfs(0,y+1,num); }\n  if(y == H){   return 1; }\n  if(id[y][x] >= 0){ return dfs(x+1,y,num); }\n  if(!check(x,y)){ return 0; }\n\n  int res = 0;\n  if(x+1 < W && id[y][x+1] == -1){\n    id[y][x] = id[y][x+1] = num;\n    res += dfs(x+2,y,num+1);\n    id[y][x] = id[y][x+1] = -1;\n  }\n  if(y+1 < H && id[y+1][x] == -1){\n    id[y][x] = id[y+1][x] = num;\n    res += dfs(x+1,y,num+1);\n    id[y][x] = id[y+1][x] = -1;\n  }\n  return res;\n}\n\nint main(){\n  while(cin >> H >> W,H){\n    memset(id,-1,sizeof(id));\n    cout << dfs(0,0,0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint ans, w, h;\nint a[20][20];\n\nvoid search(int pos){\n\tfor(int i=pos;i<=w*h;i++){\n\t\tif(i==w*h) { ans++; return; }\n\t\tint x = i%w, y = i/w;\n\t\tif(a[x][y]!=-1) continue;\n\t\tif(x!=0&&y!=0&&a[x-1][y]!=a[x-1][y-1]&&a[x-1][y-1]!=a[x][y-1]) return;\n\t\ta[x][y] = i;\n\t\tif(y!=h-1&&a[x][y+1]==-1){\n\t\t\ta[x][y+1] = i;\n\t\t\tsearch(pos+1);\n\t\t\ta[x][y+1] = -1;\n\t\t}\n\t\tif(x!=w-1&&a[x+1][y]==-1){\n\t\t\ta[x+1][y] = i;\n\t\t\tsearch(pos+2);\n\t\t\ta[x+1][y]  = -1;\n\t\t}\n\t\ta[x][y] = -1;\n\t\tbreak;\n\t}\n}\n\nint main(){\n\twhile(cin >> w >> h, w){\n\t\tmemset(a, -1, sizeof(a));\n\t\tans = 0;\n\t\tsearch(0);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint H, W, t[20][20];\nint dy[] = {0, 1}, dx[] = {1,0}; // 横　縦\n\nint judge(int y, int x){\n  map<int, int>m;\n  for(int i = -1; i < 1; i++){\n    for(int j = -1; j < 1; j++){\n      int ny = y+i, nx = x+j;\n      if(ny < 0 || nx < 0 || t[ny][nx] == -1 || m.count(t[ny][nx])) continue;\n      m[t[ny][nx]] = 1;\n    }\n  }\n  //  printf(\"size %d\\n\", (int)m.size());\n  if(m.size() < 4) return 1;\n  return 0;\n}\n\nint dfs(int n){\n  //  fprintf(stderr, \"\\n%d\\n\", n);\n  int i, j, res = 0;\n  for(i = 0; i < H; i++) for(j = 0; j < W; j++) if(t[i][j] == -1) goto b;\n b:\n\n  if(i == H && j == W) return 1;\n\n  int tmp[20][20];\n  rep(i, 20) rep(j, 20) tmp[i][j] = t[i][j];\n\n  t[i][j] = n;\n  //  printf(\"i %d j %d\\n\", i, j); \n  rep(d, 2){\n    int x = j+dx[d], y = i+dy[d];\n    //    fprintf(stderr, \"%d %d\\n\", y, x);\n    if(x < 0 || x >= W || y < 0 || y >= H || t[y][x] != -1) continue;\n    t[y][x] = n;\n    if(judge(i, j)) res += dfs(n+1);\n    t[y][x] = -1;\n  }\n  rep(i, 20) rep(j, 20) t[i][j] = tmp[i][j];\n\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d%d\", &H, &W) && H+W){\n    memset(t, -1, sizeof(t));\n    printf(\"%d\\n\", dfs(0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\nint main(){\n  for(int H,W;cin>>H>>W,H;){\n    map<vector<int>,int> m[21][21];\n    m[0][0][vector<int>(W)]=1;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tfor(auto e:m[i][j]){\n\t  auto v=e.first;\n\t  auto d=e.second;\n\t  if(j&&v[j-1]==2){\n\t    v[j]=3;\n\t    m[i][j+1][v]+=d;\n\t  }else if(i&&v[j]==0){\n\t    v[j]=1;\n\t    m[i][j+1][v]+=d;\n\t  }else if(i==0||v[j]==3||j==0||v[j-1]==1){\n\t    if(i+1<H){\n\t      auto nv=v;\n\t      nv[j]=0;\n\t      m[i][j+1][nv]+=d;\n\t    }\n\t    if(j+1<W&&(i==0||v[j+1]!=0)){\n\t      auto nv=v;\n\t      nv[j]=2;\n\t      m[i][j+1][nv]+=d;\n\t    }\n\t  }\n\t}\n      }\n      m[i+1][0]=m[i][W];\n    }\n    int a=0;\n    for(auto e:m[H][0]){\n      a+=e.second;\n    }\n    cout<<a<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\ntypedef vector<vi> mat;\nmat fld;\nint h, w;\n\nint check(int x, int y)\n{\n\tint a = fld[x][y];\n\tint b = fld[x + 1][y];\n\tint c = fld[x][y + 1];\n\tint d = fld[x + 1][y + 1];\n\tif (a == -1 || b == -1 || c == -1 || d == -1) return 1;\n\tif (a != b&&a != c&&a != d&&b != c&&b != d&&c != d) return 0;\n\treturn 1;\n}\n\nint cnt = 0;\nvoid solve(int p)\n{\n\tint x = p / w, y = p % w;\n\tif (p == h*w) cnt++;\n\telse if (fld[x][y] != -1) solve(p + 1);\n\telse\n\t{\n\t\tfld[x][y] = p;\n\t\tif (x != h - 1 && fld[x + 1][y] == -1)\n\t\t{\n\t\t\tfld[x + 1][y] = p;\n\t\t\tif ((x > 0 && y > 0 && check(x - 1, y - 1) && check(x, y - 1)) || (x == 0 || y == 0)) solve(p + 1);\n\t\t\tfld[x + 1][y] = -1;\n\t\t}\n\t\tif (y != w - 1 && fld[x][y + 1] == -1)\n\t\t{\n\t\t\tfld[x][y + 1] = p;\n\t\t\tif ((x > 0 && y > 0 && check(x - 1, y - 1) && check(x - 1, y)) || (x == 0 || y == 0)) solve(p + 1);\n\t\t\tfld[x][y + 1] = -1;\n\t\t}\n\t\tfld[x][y] = -1;\n\t}\n}\n\nint main()\n{\n\twhile (cin >> h >> w, h)\n\t{\n\t\tfld.clear();\n\t\tfld.resize(h, vi(w, -1));\n\t\tqueue<pair<mat, int>> que;\n\t\tque.push(make_pair(fld, 0));\n\t\tcnt = 0;\n\t\tsolve(0);\n\t\tcout << cnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tbool ok2 = !((c1 * c2 * c3 * c4) && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\n\t\t\tok = ok && ok2;\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\tif (hantei(tatami) == false) { return 0; }\n\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (!tatami[i][j])\n\t\t\t{\n\t\t\t\tif (H - i - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i + 1][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (W - j - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i][j + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\", dfs(1, vector<vector<int> >(H, vector<int>(W, 0))));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tbool ok2 = !((c1 * c2 * c3 * c4) && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\n\t\t\tok = ok & ok2;\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0, starty = count_ / W;\n\n\tfor (int i = starty; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (!tatami[i][j])\n\t\t\t{\n\t\t\t\tif (H - i - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i + 1][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (W - j - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i][j + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tif (!hantei(tatami2)) { return 0; }\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\\n\");\n\t\t}\n\t\telse if (H == W)\n\t\t{\n\t\t\tprintf(\"2\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvector<vector<int> > start(H, vector<int>(W, 0));\n\n\t\t\tprintf(\"%d\\n\", dfs(1, start));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint H, W;\n\ninline bool hantei(vector<vector<int> > tatami)\n{\n\tbool ok = true;\n\n\tfor (int k = 0; k < H - 1; k++)\n\t{\n\t\tfor (int l = 0; l < W - 1; l++)\n\t\t{\n\t\t\tint c1 = tatami[k][l];\n\t\t\tint c2 = tatami[k][l + 1];\n\t\t\tint c3 = tatami[k + 1][l];\n\t\t\tint c4 = tatami[k + 1][l + 1];\n\n\t\t\tbool ok2 = !((c1 * c2 * c3 * c4) && c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4);\n\n\t\t\tok = ok && ok2;\n\t\t}\n\t}\n\n\treturn ok;\n}\n\ninline int dfs(int count_, vector<vector<int> > tatami)\n{\n\tif (hantei(tatami) == false) { return 0; }\n\n\tif ((count_ - 1) * 2 == H * W) { return 1; }\n\n\tint sum = 0;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (!tatami[i][j])\n\t\t\t{\n\t\t\t\tif (H - i - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i + 1][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i + 1][j] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (W - j - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!tatami[i][j + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tvector<vector<int> > tatami2(tatami.begin(), tatami.end());\n\n\t\t\t\t\t\ttatami2[i][j] = count_; tatami2[i][j + 1] = count_;\n\n\t\t\t\t\t\tsum += dfs(count_ + 1, tatami2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &H);\n\t\tscanf(\"%d\", &W);\n\n\t\tif (H == 0 && W == 0) { break; }\n\n\t\tif (H % 2 == 1 && W % 2 == 1)\n\t\t{\n\t\t\tprintf(\"0\");\n\t\t}\n\t\telse if (H == 1 || W == 1)\n\t\t{\n\t\t\tprintf(\"1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\", dfs(1, vector<vector<int> >(H, vector<int>(W, 0))));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nchar tatami[99][99];\nint corner[99][99],h,w;\nint D[2][3]={{0,1,'-'},{1,0,'|'}};\nint dfs(int i,int j){\n\tif(i==h)return 1;\n\tif(j==w)return dfs(i+1,0);\n\tif(tatami[i][j])return dfs(i,j+1);\n\tint k=0,l,r=0;\n\tfor(;k<2;k++)if(i+D[k][0]<h&&j+D[k][1]<w&&!tatami[i+D[k][0]][j+D[k][1]]){\n\t\ttatami[i][j]=tatami[i+D[k][0]][j+D[k][1]]=D[k][2];\n\t\tfor(l=0;l<4;l++)corner[i+l/2*(D[k][0]+1)][j+l/2*(D[k][1]+1)]++;\n\t\tfor(l=0;l<4;l++)if(corner[i+l/2*(D[k][0]+1)][j+l/2*(D[k][1]+1)]>3)break;\n\t\tif(l==4)r+=dfs(i,j+1);\n\t\tfor(l=0;l<4;l++)corner[i+l/2*(D[k][0]+1)][j+l/2*(D[k][1]+1)]--;\n\t\ttatami[i][j]=tatami[i+D[k][0]][j+D[k][1]]=0;\n\t}\n\treturn r;\n}\nint main(){for(;scanf(\"%d%d\",&h,&w),h;)printf(\"%d\\n\",dfs(0,0));return 0;}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2163\n  Title:\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n\nint H,W,T;\nint room[20][21];\n\nvoid search(int *y,int *x)\n{\n  int i,j;\n\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      if(room[i][j]==0)\n\t{\n\t  *y=i;*x=j;\n\t  return;\n\t}\n}\n\nint check_cross(int y, int x)\n{\n  int c[4],i,j,s;\n\n  if(y<0||x<0)\n    return(0);\n\n  for(i=0;i<2;i++)\n    for(j=0;j<2;j++)\n      c[i*2+j]=room[y+i][x+j];\n  \n  for(i=s=0;i<4;i++)\n    for(j=0;j<4;j++)\n      s += ((c[i]!=c[j])?1:0);\n\n  return((s==12)?1:0);\n}\n\nvoid dump()\n{\n  int i,j;\n\n  for(i=0;i<H;i++)\n    {\n      for(j=0;j<W;j++)\n\t{\n\t  printf (\"%02d|\",room[i][j]);\n\t}\n      printf(\"\\n\");\n    }\n  printf(\"-------\\n\");\n}\n\n\nint solve(int tatami)\n{\n  int ret,y,x;\n\n  if(tatami==T)\n    {\n      //dump();\n    return(1);\n    }\n  search(&y,&x);\n  //printf(\"EMPyx=%d %d\\n\",y,x);\n  ret=0;\n  if(x<W-1 && room[y][x+1]==0)\n    {\n      room[y][x]=room[y][x+1]=tatami+1;\n      if(!check_cross(y-1,x+1))\n\tret += solve(tatami+1);\n      room[y][x]=room[y][x+1]=0;\n    }\n  if(y<H-1 && room[y+1][x]==0)\n    {\n      room[y][x]=room[y+1][x]=tatami+1;\n      if(!check_cross(y-1,x))\n\tret += solve(tatami+1);\n      room[y][x]=room[y+1][x]=0;\n    }\n  return(ret);\n}\nmain()\n{\n  int ret,s;\n  \n  while(scanf(\"%d %d\",&H,&W)  && (H||W))\n    {\n      if(((s=H*W) & 1)==0)\n\t{\n\t  T=s/2;\n\t  memset(room,0,sizeof(room));\n\t  ret=solve(0);\n\t}\n      else\n\tret=0;\n      printf(\"%d\\n\",ret);\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2163 Tatami\n// 2019.3.10 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint h, w, ans;\nint map[22][22];\nint tbl[200], id;\n\nint ok(int r, int c)\n{\n\tif (r == 0 || c == 0) return 1;\n\ttbl[map[r][c]] = ++id;\n\tif (tbl[map[r][c - 1]] == id) return 1;\n\ttbl[map[r][c - 1]] = id;\n\tif (tbl[map[r - 1][c]] == id) return 1;\n\ttbl[map[r - 1][c]] = id;\n\treturn tbl[map[r - 1][c - 1]] == id;\n}\n\nvoid check(int k, int r, int c)\n{\n\tif (c == w) {\n\t\tif (r == h - 1) ans++;\n\t\telse check(k, r + 1, 0);\n\t\treturn;\n\t}\n\tif (map[r][c]) check(k, r, c + 1);\n\telse {\n\t\tif (r + 1 < h && !map[r + 1][c]) {\n\t\t\tmap[r][c] = map[r + 1][c] = k;\n\t\t\tif (ok(r, c)) check(k + 1, r, c + 1);\n\t\t\tmap[r][c] = map[r + 1][c] = 0;\n\t\t}\n\t\tif (c + 1 < w && !map[r][c + 1]) {\n\t\t\tmap[r][c] = map[r][c + 1] = k;\n\t\t\tif (ok(r, c)) check(k + 1, r, c + 2);\n\t\t\tmap[r][c] = map[r][c + 1] = 0;\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (scanf(\"%d%d\", &h, &w) && (h | w)) {\n\t\tif (h == w) putchar(h & 1 ? '0' : '2');\n\t\telse {\n\t\t\tans = id = 0;\n\t\t\tmemset(map, 0, sizeof(map));\n\t\t\tmemset(tbl, 0, sizeof(tbl));\n\t\t\tcheck(1, 0, 0);\n\t\t\tprintf(\"%d\", ans);\n\t\t}\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tint w, h;\n\tint[][] f;\n\tint[] dx = {0, 1};\n\tint[] dy = {1, 0};\n\tint count;\n\n\tvoid bt(int k, int x, int y) {\n\t\tif (x == 0 && y == h) {\n\t\t\tcount++;\n\t\t\treturn;\n\t\t}\n\t\tint nx = x + 1;\n\t\tint ny = y;\n\t\tif (w <= nx) {\n\t\t\tnx = 0;\n\t\t\tny++;\n\t\t}\n\t\tif (f[y][x] == 0) {\n\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\tint mx = x + dx[i];\n\t\t\t\tint my = y + dy[i];\n\t\t\t\tif (w <= mx || h <= my || f[my][mx] != 0) continue;\n\t\t\t\tf[y][x] = f[my][mx] = k;\n\t\t\t\tif (check(x, y)) {\n\t\t\t\t\tbt(k + 1, nx, ny);\n\t\t\t\t}\n\t\t\t\tf[y][x] = f[my][mx] = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tbt(k, nx, ny);\n\t\t}\n\t\treturn;\n\t}\n\n\tboolean check(int x, int y) {\n\t\tint[] dx = {-1, -1, 0, 0};\n\t\tint[] dy = {-1, 0, -1, 0};\n\t\tint[] color = new int[4];\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (nx < 0 || w <= nx || ny < 0 || h <= ny) return true;\n\t\t\tcolor[i] = f[ny][nx];\n\t\t}\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = i + 1; j < 4; j++) {\n\t\t\t\tif (color[i] == color[j]) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\tw = sc.nextInt();\n\t\th = sc.nextInt();\n\t\tcount = 0;\n\t\tf = new int[h][w];\n\t\tbt(1, 0, 0);\n\t\tSystem.out.println(count);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tint w, h;\n\tint[][] f;\n\tint[] dx = {0, 1};\n\tint[] dy = {1, 0};\n\tint count;\n\n\tvoid bt(int k, int x, int y) {\n\t\tif (x == 0 && y == h) {\n\t\t\tcount++;\n\t\t\treturn;\n\t\t}\n\t\tint nx = x + 1;\n\t\tint ny = y;\n\t\tif (w <= nx) {\n\t\t\tnx = 0;\n\t\t\tny++;\n\t\t}\n\t\tif (f[y][x] == 0) {\n\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\tint mx = x + dx[i];\n\t\t\t\tint my = y + dy[i];\n\t\t\t\tif (w <= mx || h <= my || f[my][mx] != 0) continue;\n\t\t\t\tf[y][x] = f[my][mx] = k;\n\t\t\t\tif (check(x, y)) {\n\t\t\t\t\tbt(k + 1, nx, ny);\n\t\t\t\t}\n\t\t\t\tf[y][x] = f[my][mx] = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tbt(k, nx, ny);\n\t\t}\n\t\treturn;\n\t}\n\n\tboolean check(int x, int y) {\n\t\tint[] dx = {-1, -1, 0, 0};\n\t\tint[] dy = {-1, 0, -1, 0};\n\t\tint[] color = new int[4];\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (nx < 0 || w <= nx || ny < 0 || h <= ny) return true;\n\t\t\tcolor[i] = f[ny][nx];\n\t\t}\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = i + 1; j < 4; j++) {\n\t\t\t\tif (color[i] == color[j]) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif ((w | h) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount = 0;\n\t\t\tf = new int[h][w];\n\t\t\tbt(1, 0, 0);\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Tatami\n */\npublic class Main {\n\n\tstatic int count = 0;\n\tstatic int H = 0;\n\tstatic int W = 0;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tcount = 0;\n\t\t\tH = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tW = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((H | W) == 0) break;\n\n\t\t\tboolean[][] floor = new boolean[H][W];\n\n\t\t\tsolve(floor);\n\n\t\t\tSystem.out.println(count);\n\n\t\t} //end while\n\t} //end main\n\n\tstatic void solve(boolean[][] f) {\n\t\tboolean[][] h = new boolean[H][W];//horizon\n\t\tboolean[][] v = new boolean[H][W];//vertical\n\n\t\tint y = -1, x = -1;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\th[i][j] = v[i][j] = f[i][j];\n\t\t\t\tif (y == -1 && !f[i][j]) {\n\t\t\t\t\ty = i;\n\t\t\t\t\tx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (y == -1 && x == -1) {\n\t\t\tcount++;\n\t\t\treturn;\n\t\t}\n\n\t\t//\n\t\tif (x + 1 < W && !f[y][x + 1]) {\n\t\t\th[y][x] = true;\n\t\t\th[y][x + 1] = true;\n\t\t\tsolve(h);\n\t\t}\n\n\t\t//\n\t\tif (y + 1 < H && !f[y + 1][x]) {\n\t\t\tv[y][x] = true;\n\t\t\tv[y + 1][x] = true;\n\t\t\tsolve(v);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nint ans;\nint h, w;\nint ttm[30][30];\nint c;\n\nbool ok(int x, int y){\n    return x==0 ||\n        y==0 ||\n        ttm[y][x]==ttm[y][x-1] ||\n        ttm[y][x-1]==ttm[y-1][x-1] ||\n        ttm[y-1][x-1]==ttm[y-1][x] ||\n        ttm[y-1][x]==ttm[y][x];\n}\n\nvoid dfs(int x, int y){\n    if(x==w){\n    if(y==h-1){\n            ans++;\n            return;\n        }\n        else dfs(0,y+1);\n        return;\n    }\n\n    if(ttm[y][x]) dfs(x+1,y);\n    else{\n        if(x+1!=w && ttm[y][x+1]==0){\n            ttm[y][x] = ttm[y][x+1] = c++;\n            if(ok(x,y)) dfs(x+2,y);\n            ttm[y][x] = ttm[y][x+1] = 0;\n        }\n        if(y+1!=h && ttm[y+1][x]==0){\n            ttm[y][x] = ttm[y+1][x] = c++;\n            if(ok(x,y)) dfs(x+1,y);\n            ttm[y][x] = ttm[y+1][x] = 0;\n        }\n    }\n}\nint main(){\n    while(cin >> h >> w && h){\n        ans = 0;\n        c = 1;\n        memset(ttm,0,sizeof(ttm));\n        dfs(0, 0);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "Ruby",
    "code": "def init(h, dict, i, a)\n  return if i > h\n  if i == h\n    dict[a * \"\"] = 1\n    return\n  end\n\n  a << ?H\n  init(h, dict, i + 1, a)\n  a.pop\n\n  a << ?V\n  a << ?v\n  init(h, dict, i + 2, a)\n  a.pop\n  a.pop\nend\n\ndef search(h, state, dict, i, a)\n  return if i > h\n  if i == h\n    dict[a * \"\"] = 1\n    return\n  end\n\n  if state[i] == ?H\n    a << ?L\n    search(h, state, dict, i + 1, a)\n    a.pop\n    return\n  end\n\n  if state[i] == ?L\n    if i == h - 1 || state[i + 1] == ?H\n      a << ?H\n      search(h, state, dict, i + 1, a)\n      a.pop\n    elsif i == h - 2 || state[i + 1] == ?V || state[i + 2] == ?H\n      a << ?V\n      a << ?v\n      search(h, state, dict, i + 2, a)\n      a.pop\n      a.pop\n    end\n    return\n  end\n\n  if state[i] == ?V\n    a << ?H\n    search(h, state, dict, i + 1, a)\n    a.pop\n    if i == h - 2 || state[i + 2] == ?H\n      a << ?V\n      a << ?v\n      search(h, state, dict, i + 2, a)\n      a.pop\n      a.pop\n    end\n    return\n  end\n\n  # state[i] == ?v\n  if i == h - 1 || state[i + 1] == ?H\n    a << ?H\n    search(h, state, dict, i + 1, a)\n    a.pop\n  elsif i == h - 2 || state[i + 1] == ?V || state[i + 2] == ?H\n    a << ?V\n    a << ?v\n    search(h, state, dict, i + 2, a)\n    a.pop\n    a.pop\n  end\nend\n\nloop do\n  h, w = gets.split.map(&:to_i)\n  break if h == 0\n  h, w = w, h if w < h\n  dict = {}\n  init(h, dict, 0, [])\n\n  trans = {}\n  (w - 1).times do\n    new_dict = Hash.new(0)\n    dict.each do |state, n|\n      if trans[state]\n        trans[state].each do |next_state, k|\n          new_dict[next_state] += n * k\n        end\n        next\n      end\n      t = {}\n      search(h, state, t, 0, [])\n      trans[state] = t\n      trans[state].each do |next_state, k|\n        new_dict[next_state] += n * k\n      end\n    end\n    dict = new_dict\n  end\n\n  p dict.keys.reject {|s| s.include?(?H)}.map {|s| dict[s]}.inject(:+) || 0\nend\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    H, W = map(int, input().split())\n    if H == 0:\n        return False\n    if H*W % 2 == 1:\n        print(0)\n        return True\n    state = [[-1]*W for i in range(H)]\n    def dfs(k):\n        if k == H*W:\n            return 1\n        i, j = divmod(k, W)\n        if state[i][j] != -1:\n            return dfs(k+1)\n        if i > 0 and j > 0 and state[i-1][j-1] != state[i-1][j] != state[i][j-1] != state[i-1][j-1]:\n            return 0\n        r = 0\n        state[i][j] = k\n        if i+1 < H:\n            state[i+1][j] = k\n            r += dfs(k+1)\n            state[i+1][j] = -1\n        if j+1 < W and state[i][j+1] == -1:\n            state[i][j+1] = k\n            r += dfs(k+1)\n            state[i][j+1] = -1\n        state[i][j] = -1\n        return r\n    print(dfs(0))\n    return True\nwhile solve():\n    ...\n"
  }
]