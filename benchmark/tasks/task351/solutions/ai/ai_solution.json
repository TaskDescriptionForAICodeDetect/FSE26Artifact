[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint H, W;\nint count = 0;\n\nvoid tatami(int x, int y, int used[16][16]) {\n    if (x == W) {\n        x = 0;\n        y++;\n    }\n    if (y == H) {\n        count++;\n        return;\n    }\n    if (used[y][x]) {\n        tatami(x + 1, y, used);\n        return;\n    }\n    \n    if (x + 1 < W && !used[y][x + 1]) {\n        used[y][x] = used[y][x + 1] = 1;\n        tatami(x + 2, y, used);\n        used[y][x] = used[y][x + 1] = 0;\n    }\n    if (y + 1 < H && !used[y + 1][x]) {\n        used[y][x] = used[y + 1][x] = 1;\n        tatami(x + 1, y, used);\n        used[y][x] = used[y + 1][x] = 0;\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    int used[16][16] = {0};\n    tatami(0, 0, used);\n    printf(\"%d\\n\", count);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:11:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint height, width;\nint total = 0;\n\nvoid cover(int row, int col, vector<vector<bool>>& covered) {\n    if (row == height) {\n        total++;\n        return;\n    }\n    if (col == width) {\n        cover(row + 1, 0, covered);\n        return;\n    }\n    if (covered[row][col]) {\n        cover(row, col + 1, covered);\n        return;\n    }\n\n    // Try horizontal tatami (1x2)\n    if (col + 1 < width && !covered[row][col + 1]) {\n        covered[row][col] = covered[row][col + 1] = true;\n        cover(row, col + 2, covered);\n        covered[row][col] = covered[row][col + 1] = false;\n    }\n\n    // Try vertical tatami (2x1)\n    if (row + 1 < height && !covered[row + 1][col]) {\n        covered[row][col] = covered[row + 1][col] = true;\n        cover(row, col + 1, covered);\n        covered[row][col] = covered[row + 1][col] = false;\n    }\n}\n\nint main() {\n    cin >> height >> width;\n    if ((height * width) % 2 != 0) {\n        cout << 0 << endl;\n        return 0;\n    }\n    vector<vector<bool>> covered(height, vector<bool>(width, false));\n    cover(0, 0, covered);\n    cout << total << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:11:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "public class Tatami {\n    private static int count = 0;\n\n    public static void main(String[] args) {\n        int height = 3; // Example height\n        int width = 4;  // Example width\n        if ((height * width) % 2 != 0) {\n            System.out.println(0);\n            return;\n        }\n        boolean[][] grid = new boolean[height][width];\n        solve(grid, 0, 0, height, width);\n        System.out.println(count);\n    }\n\n    private static void solve(boolean[][] grid, int row, int col, int height, int width) {\n        if (row == height) {\n            count++;\n            return;\n        }\n        if (col == width) {\n            solve(grid, row + 1, 0, height, width);\n            return;\n        }\n        if (grid[row][col]) {\n            solve(grid, row, col + 1, height, width);\n            return;\n        }\n\n        // Place horizontally if possible\n        if (col + 1 < width && !grid[row][col + 1]) {\n            grid[row][col] = grid[row][col + 1] = true;\n            solve(grid, row, col + 2, height, width);\n            grid[row][col] = grid[row][col + 1] = false;\n        }\n\n        // Place vertically if possible\n        if (row + 1 < height && !grid[row + 1][col]) {\n            grid[row][col] = grid[row + 1][col] = true;\n            solve(grid, row, col + 1, height, width);\n            grid[row][col] = grid[row + 1][col] = false;\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:11:40"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TatamiMats {\n    public static long countTatamiMats(int height, int width) {\n        int[][] dp = new int[height + 1][width + 1];\n        dp[0][0] = 1;\n\n        for (int i = 0; i <= height; i++) {\n            for (int j = 0; j <= width; j++) {\n                if (i > 0) {\n                    if (j >= 2) dp[i][j] += dp[i-1][j-2];\n                    if (j >= 1) dp[i][j] += dp[i-1][j-1];\n                }\n                if (j > 0) {\n                    if (i >= 2) dp[i][j] += dp[i-2][j-1];\n                    if (i >= 1) dp[i][j] += dp[i-1][j-1];\n                }\n            }\n        }\n\n        return dp[height][width];\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int height = scanner.nextInt();\n        int width = scanner.nextInt();\n        System.out.println(countTatamiMats(height, width));\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:11:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_SIZE 30\n\nint count_tatami_arrangements(int height, int width) {\n    int dp[MAX_SIZE + 1][MAX_SIZE + 1][2];\n    memset(dp, 0, sizeof(dp));\n\n    dp[0][0][0] = 1;\n\n    for (int i = 0; i < height; i++) {\n        for (int j = 0; j < width; j++) {\n            // Vertical placement\n            if (i + 2 <= height) {\n                dp[i + 2][j][0] += dp[i][j][0] + dp[i][j][1];\n            }\n\n            // Horizontal placement\n            if (j + 2 <= width) {\n                dp[i][j + 2][1] += dp[i][j][0] + dp[i][j][1];\n            }\n        }\n    }\n\n    return dp[height][width][0] + dp[height][width][1];\n}\n\nint main() {\n    int height, width;\n    scanf(\"%d %d\", &height, &width);\n    \n    int arrangements = count_tatami_arrangements(height, width);\n    printf(\"%d\\n\", arrangements);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:11:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nclass TatamiCounter {\nprivate:\n    int height, width;\n    std::vector<std::vector<int>> dp;\n\n    bool isValidPlacement(int row, int col, bool horizontal) {\n        if (horizontal) {\n            return col + 1 < width;\n        } else {\n            return row + 1 < height;\n        }\n    }\n\n    int countPlacements(int row, int col, int mask) {\n        if (row >= height) return 1;\n        if (col >= width) return countPlacements(row + 1, 0, mask);\n\n        if (dp[row][mask] != -1) return dp[row][mask];\n\n        int result = 0;\n        if (!(mask & (1 << col))) {\n            // Try horizontal placement\n            if (isValidPlacement(row, col, true) && !(mask & (1 << (col + 1)))) {\n                result += countPlacements(row, col + 2, mask | (1 << col) | (1 << (col + 1)));\n            }\n\n            // Try vertical placement\n            if (isValidPlacement(row, col, false)) {\n                result += countPlacements(row, col + 1, mask | (1 << col));\n            }\n        } else {\n            // Skip already covered cell\n            result += countPlacements(row, col + 1, mask);\n        }\n\n        return dp[row][mask] = result;\n    }\n\npublic:\n    TatamiCounter(int h, int w) : height(h), width(w) {\n        dp = std::vector<std::vector<int>>(h, std::vector<int>(1 << w, -1));\n    }\n\n    int solve() {\n        return countPlacements(0, 0, 0);\n    }\n};\n\nint main() {\n    int h, w;\n    std::cin >> h >> w;\n    \n    TatamiCounter counter(h, w);\n    std::cout << counter.solve() << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:11:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_tatami_ways(h, w):\n    # Ensure h is at least as big as w\n    if h < w:\n        h, w = w, h\n\n    # Handle base cases\n    if h * w % 2 != 0:\n        return 0\n    if w == 1:\n        return 1\n\n    # Using dynamic programming to count ways\n    dp_prev = [1] * (1 << w)\n    for row in range(h):\n        dp_next = [0] * (1 << w)\n        for mask in range(1 << w):\n            count = dp_prev[mask]\n            if count == 0:\n                continue\n            for next_mask in range(1 << w):\n                if is_valid_transition(mask, next_mask, w):\n                    dp_next[next_mask] += count\n        dp_prev = dp_next\n\n    return dp_prev[0]\n\ndef is_valid_transition(mask, next_mask, w):\n    prev = (~mask) & ((1 << w) - 1)\n    cur = next_mask\n    return ((prev ^ cur ^ ((prev >> 1) & cur) ^ ((prev << 1) & cur)) == 0)\n\ndef main():\n    # Example usage\n    height = 3\n    width = 4\n    print(count_tatami_ways(height, width))\n\nmain()",
    "timestamp": "2025-08-13 05:22:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "public class TatamiMats {\n    public static void main(String[] args) {\n        int height = 6; // Example height\n        int width = 4; // Example width\n        System.out.println(countWaysToCover(height, width));\n    }\n\n    private static int countWaysToCover(int height, int width) {\n        if (height > width) {\n            // Ensure height <= width for normalization\n            int temp = height;\n            height = width;\n            width = temp;\n        }\n        return cover(new boolean[height][width], 0, 0);\n    }\n    \n    private static int cover(boolean[][] floor, int row, int col) {\n        int m = floor.length;\n        int n = floor[0].length;\n\n        // Find the first unoccupied cell\n        while (row < m && col < n && floor[row][col]) {\n            col++;\n            if (col == n) {\n                col = 0;\n                row++;\n            }\n        }\n        \n        if (row == m) {\n            // If all cells are covered, count this as a valid layout\n            return 1;\n        }\n        \n        int count = 0;\n        \n        // Try placing a horizontal mat (1x2)\n        if (col + 1 < n && !floor[row][col] && !floor[row][col + 1]) {\n            floor[row][col] = floor[row][col + 1] = true;\n            count += cover(floor, row, col + 2);\n            floor[row][col] = floor[row][col + 1] = false;\n        }\n        \n        // Try placing a vertical mat (2x1)\n        if (row + 1 < m && !floor[row][col] && !floor[row + 1][col]) {\n            floor[row][col] = floor[row + 1][col] = true;\n            count += cover(floor, row, col + 1);\n            floor[row][col] = floor[row + 1][col] = false;\n        }\n        \n        return count;\n    }\n}",
    "timestamp": "2025-08-13 05:23:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_H 30\n#define MAX_W 30\n\nint dp[MAX_H + 1][MAX_W + 1][1 << (MAX_W + 1)];\n\nint dfs(int h, int w, int mask, int H, int W) {\n    if (h == H) return mask == 0;\n    if (w == W) return dfs(h + 1, 0, mask, H, W);\n    if (mask & (1 << w)) return dfs(h, w + 1, mask ^ (1 << w), H, W);\n\n    int res = 0;\n\n    // Place horizontal tile\n    if (w + 1 < W && !(mask & (1 << (w + 1)))) {\n        res += dfs(h, w + 2, mask, H, W);\n    }\n\n    // Place vertical tile\n    if (h + 1 < H) {\n        res += dfs(h, w + 1, mask | (1 << w), H, W);\n    }\n\n    return res;\n}\n\nint countTatami(int H, int W) {\n    memset(dp, -1, sizeof(dp));\n    return dfs(0, 0, 0, H, W);\n}\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n    printf(\"%d\\n\", countTatami(H, W));\n    return 0;\n}",
    "timestamp": "2025-08-13 05:23:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_tatami_ways(height, width):\n    def is_valid_placement(grid):\n        for i in range(height):\n            for j in range(width):\n                if grid[i][j] == 0:\n                    return False\n        return True\n\n    def backtrack(grid, remaining_mats):\n        if is_valid_placement(grid):\n            return 1\n\n        ways = 0\n        for i in range(height):\n            for j in range(width):\n                if grid[i][j] == 0:\n                    # Try horizontal placement\n                    if j + 1 < width and grid[i][j+1] == 0:\n                        grid[i][j] = grid[i][j+1] = 1\n                        ways += backtrack(grid, remaining_mats - 1)\n                        grid[i][j] = grid[i][j+1] = 0\n\n                    # Try vertical placement\n                    if i + 1 < height and grid[i+1][j] == 0:\n                        grid[i][j] = grid[i+1][j] = 1\n                        ways += backtrack(grid, remaining_mats - 1)\n                        grid[i][j] = grid[i+1][j] = 0\n\n                    return ways\n\n        return ways\n\n    total_area = height * width\n    max_mats = total_area // 2\n\n    grid = [[0] * width for _ in range(height)]\n    return backtrack(grid, max_mats)\n\n# Example usage\nprint(count_tatami_ways(3, 4))",
    "timestamp": "2025-08-13 05:23:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_tatami_arrangements(H, W):\n    if H * W % 2 != 0:\n        return 0\n    grid = [[0 for _ in range(W)] for _ in range(H)]\n    count = 0\n\n    def backtrack(x, y):\n        nonlocal count\n        if x == H:\n            count += 1\n            return\n        if y == W:\n            backtrack(x + 1, 0)\n            return\n        if grid[x][y] == 1:\n            backtrack(x, y + 1)\n            return\n\n        # Place horizontally if possible\n        if y + 1 < W and grid[x][y + 1] == 0:\n            grid[x][y] = grid[x][y + 1] = 1\n            backtrack(x, y + 2)\n            grid[x][y] = grid[x][y + 1] = 0\n\n        # Place vertically if possible\n        if x + 1 < H and grid[x + 1][y] == 0:\n            grid[x][y] = grid[x + 1][y] = 1\n            backtrack(x, y + 1)\n            grid[x][y] = grid[x + 1][y] = 0\n\n    backtrack(0, 0)\n    return count\n\nH, W = map(int, input().split())\nprint(count_tatami_arrangements(H, W))",
    "timestamp": "2025-08-13 05:23:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nconst int MAX_H = 16;\nconst int MAX_W = 16;\n\nint countWays(int h, int w) {\n    if ((h * w) % 2 != 0) return 0; // Odd area can't be completely covered\n\n    std::vector<std::vector<int>> dp(1 << w, std::vector<int>(h + 1, 0));\n    dp[0][0] = 1;\n\n    for (int row = 0; row < h; ++row) {\n        for (int mask = 0; mask < (1 << w); ++mask) {\n            if (dp[mask][row] == 0) continue;\n\n            for (int newmask = 0; newmask < (1 << w); ++newmask) {\n                bool valid = true;\n                for (int i = 0; i < w;) {\n                    if (mask & (1 << i)) {\n                        // Previous row needed a mat here, skip\n                        if (newmask & (1 << i)) {\n                            valid = false;\n                            break; // Conflict with previous row coverage\n                        }\n                        i++;\n                    } else {\n                        // Place horizontal mat\n                        if (i + 1 < w && !(mask & (1 << (i + 1))) && !(newmask & (1 << i)) && !(newmask & (1 << (i + 1)))) {\n                            i += 2; // Skip to next potential placement\n                        }\n                        // Place vertical mat\n                        else if (row + 1 < h && !(newmask & (1 << i))) {\n                            ++i; // Place vertically allows move to next place\n                        } else {\n                            valid = false;\n                            break;\n                        }\n                    }\n                }\n                if (valid) {\n                    dp[newmask][row + 1] += dp[mask][row];\n                }\n            }\n        }\n    }\n\n    return dp[0][h];\n}\n\nint main() {\n    int h, w;\n    std::cin >> h >> w;\n    std::cout << countWays(h, w) << std::endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:24:47"
  }
]