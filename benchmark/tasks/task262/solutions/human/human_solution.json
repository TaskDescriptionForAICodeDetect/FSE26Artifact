[
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iomanip>\n\n#define REP(i,n) for(i=0; i < (n); i++)\n#define REPONE(i, n) for(i=1; i <= (n); i++)\n#define LOOP(n) for(int loopCount=1; loopCount <= (n); loopCount++)\n#define ITER(c) __typeof((c).begin())\n#define EACH(c,it) for(ITER(c) it =(c).begin(); it!=(c).end(); it++)\n#define SZ(c) ((int) (c).size())\n#define ALL(c) c.begin(), c.end()\n#define SUM(c) accumulate(ALL(c), 0)\n#define EXIST(c,v) (find(ALL(c), (v)) != (c).end())\n#define PB push_back\n#define MP make_pair\n\nusing namespace std;\nstatic const double EPS = 1e-8;\nstatic const double PI = 3.141592653589793238462643383279;\n\ntypedef complex<double> point;\n\ntemplate<typename T>\nint sig2(T x){\n    if(abs(x)<EPS) return 0;\n    if(x>0) return 1;\n    return -1;\n}\n\ndouble det(point p1, point p2, point q){\n    return p2.real()*q.imag()+p1.real()*p2.imag()+q.real()*p1.imag()\n            -p2.real()*p1.imag()-q.real()*p2.imag()-q.imag()*p1.real();\n}\n\n/*\nint main(){\n    int i,j,k,n,m;\n    double x,y;\n    bool yes;\n    while(scanf(\"%d%d\",&n,&m)){\n        if(n==0 && m==0) break;\n        yes=false;\n        vector<point> bs(n), ws(m);\n        REP(i,n){\n            scanf(\"%lf%lf\",&x,&y);\n            bs[i]=point(x,y);\n        }\n        REP(i,m){\n            scanf(\"%lf%lf\",&x,&y);\n            ws[i]=point(x,y);\n        }\n        if(n==1 && m==1){\n            printf(\"YES\\n\");\n            continue;\n        }\n        int w=0, b;\n        REP(i,n)for(j=i+1;j<n;j++){\n            w = 0;\n            REP(k,m) w+=sig2(det(bs[i],bs[j],ws[k]));\n            if(abs(w)<m)break;\n            REP(k,n)if(sig2(det(bs[i],bs[j],bs[k]))==sig2(w))break;\n            if(k==n){\n                yes = true;\n                goto end;\n            }\n        }\n        swap(n,m);\n        swap(bs,ws);\n        REP(i,n)for(j=i+1;j<n;j++){\n            w = 0;\n            REP(k,m) w+=sig2(det(bs[i],bs[j],ws[k]));\n            if(abs(w)<m)break;\n            REP(k,n)if(sig2(det(bs[i],bs[j],bs[k]))==sig2(w))break;\n            if(k==n){\n                yes = true;\n                goto end;\n            }\n        }\n        end:;\n        if(yes)printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n    return 0;\n}\n*/\n\n#define N 10000\n\nint main(){\n    int i,j,n,m;\n    double x,y,bma,bmi,wma,wmi;\n    point tmp;\n    while(scanf(\"%d%d\",&n,&m)){\n        if(n==0 && m==0) break;\n        vector<point> bs(n), ws(m);\n        REP(i,n){\n            scanf(\"%lf%lf\",&x,&y);\n            bs[i] = point(x,y);\n        }\n        REP(i,m){\n            scanf(\"%lf%lf\",&x,&y);\n            ws[i] = point(x,y);\n        }\n        REP(i,N){\n            bma=wma=-1e99;\n            bmi=wmi=1e99;\n            REP(j,n){\n                tmp = bs[j]*polar(1.0,i*PI/(N>>1));\n                bma = max(bma,tmp.real());\n                bmi = min(bmi,tmp.real());\n            }\n            REP(j,m){\n                tmp = ws[j]*polar(1.0,i*PI/(N>>1));\n                wma = max(wma,tmp.real());\n                wmi = min(wmi,tmp.real());\n            }\n            if(bma < wmi || wma < bmi) break;\n        }\n        if(i==N)printf(\"NO\\n\");\n        else printf(\"YES\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nvector<xy_t> black;\nvector<xy_t> white;\nxy_t p;\n\ndouble cross(const xy_t &a, const xy_t &b){\n\treturn imag(a * conj(b));\n}\ndouble dot(const xy_t &a, const xy_t &b){\n\treturn real(a * conj(b));\n}\n\nint ccw(xy_t a, xy_t b, xy_t c){\n\tb -= a;\n\tc -= a;\n\tif(cross(b, c) > 0) return 1;\n\tif(cross(b, c) < 0) return -1;\n\tif(dot(b, c) < 0) return 2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool intersectSS(const line &s, const line &t){\n\treturn ccw(s.first, s.second, t.first) * ccw(s.first, s.second, t.second) <= 0 && \n\t\tccw(t.first, t.second, s.first) * ccw(t.first, t.second, s.second) <= 0;\n}\n\nint insidePol(const vector<xy_t> &Pol, const xy_t &pos){\n\tint n = Pol.size();\n\tbool f = false;\n\tfor(int i = 0; i < n; i++){\n\t\txy_t a = Pol[i] - pos;\n\t\txy_t b = Pol[(i+1)%n] - pos;\n\t\tif(imag(a) > imag(b)) swap(a, b);\n\t\tif(imag(a) < EPS && 0 < imag(b)){\n\t\t\tif(cross(a, b) > 0) f = !f;\n\t\t}\n\t\tif(abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 2; \n\t}\n\treturn f ? 1 : 0;\n}\n\nbool comp(const xy_t &p1, const xy_t &p2){\n\treturn cross(p1 - p, p2 - p) < 0;\n}\n\nvoid output(const vector<xy_t> &pol){\n\tcout <<\"****************\" << endl;\n\trep(i, (int)pol.size()) cout << pol[i] << endl;\n\tcout << \"******************\" << endl;\n}\n\nvector<xy_t> convex_hull(vector<xy_t> &pol){\n\tint n = pol.size();\n\tint m = 0;\n\tvector<xy_t> res;\n\tif(n <= 2) return pol;\n\trep(i, n){\n\t\tif(pol[i].imag() < pol[m].imag()) m = i;\n\t}\n\trep(i, n){\n\t\tif(abs(pol[i].imag() - pol[m].imag()) < EPS && pol[i].real() > pol[m].real()) m = i; \n\t}\n\tswap(pol[0], pol[m]);\n\tp = pol[0];\n\tsort(pol.begin() + 1, pol.end(), comp);\n\t//output(pol);\n\tres.push_back(pol[0]);\n\tres.push_back(pol[1]);\n\tfor(int i = 2; i < n; i++){\n\t\tint sz = res.size();\n\t\twhile(sz >= 2 && ccw(res[sz-1], res[sz-2], pol[i])  <= 0) res.pop_back(), sz--;\n\t\tres.push_back(pol[i]);\n\t}\n\n\treturn res;\n}\n\nbool intersect(const vector<xy_t> &A, const vector<xy_t> &B){\n\tint n = A.size();\n\tint m = B.size();\n\t//Óªð··é©\n\trep(i, n)rep(j, m){\n\t\tif(intersectSS(line(A[i], A[(i+1)%n]), line(B[j], B[(j+1)%m]))) return true;\n\t}\n\t// _ªà¤É é©\n\trep(i, n){\n\t\tif(insidePol(B, A[i])) return true;\n\t}\n\trep(i, m){\n\t\tif(insidePol(A, B[i])) return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tint n, m;\n\tdouble x, y;\n\twhile(cin >> n >> m && (n || m)){\n\t\twhite.clear();\n\t\tblack.clear();\n\t\trep(i, n){\n\t\t\tcin >> x >>y;\n\t\t\tblack.push_back(xy_t(x, y));\n\t\t}\n\t\trep(i, m){\n\t\t\tcin >> x >> y;\n\t\t\twhite.push_back(xy_t(x, y));\n\t\t}\n\t\tblack = convex_hull(black);\n\t\twhite = convex_hull(white);\n\t\n\t\tif(!intersect(black, white)){\n\t\t\tcout << \"YES\" << endl;\n\t\t}else{\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n\nstruct Point{\n  double x,y;\n\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n  Point operator / (const double &k)const{ return Point(x/k,y/k); }\n  bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\n\nistream &operator >> (istream &is,Point &p){ \n  return is >> p.x >> p.y;\n}\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS){ return COUNTER_CLOCKWISE; }\n  if(cross(a,b) < -EPS){ return CLOCKWISE; }\n  if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n  if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n  return ON_SEGMENT;\n}\n\nstruct Segment{\n  Point s,t;\n  Segment(){}\n  Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nbool isIntersectSP(const Segment &s,const Point &p){\n  return equal(ccw(s.s,s.t,p),0);\n}\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n  Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0\n    && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\n#define prev(G,i) (G[(i-1+G.size())%G.size()])\n#define curr(G,i) (G[i%G.size()])\n#define next(G,i) (G[(i+1)%G.size()])\ntypedef vector<Point> Polygon;\n\nbool check(const Polygon &pg,const Point &p){\n  int N = pg.size();\n  bool in = false;\n  for(int i = 0 ; i < N ; i++){\n    Point a = curr(pg,i)-p, b = next(pg,i)-p;\n    if(a.y > b.y){ swap(a,b); }\n    if(a.y <= 0 && 0 < b.y && cross(a,b) > 0){ in = !in; }\n    if(cross(a,b) == 0 && dot(a,b) <= 0){ return true; }\n  }\n  return in;\n}\n\nbool solve(Polygon &bp,Polygon &wp){\n  int N = bp.size(), M = wp.size();\n  if(N == 1 && M == 1){\n    return !(equal(bp[0].x,wp[0].x) && equal(bp[0].y,wp[0].y));\n  }\n  if(N == 2 && M == 1){\n    Segment s(bp[0],bp[1]);\n    return !isIntersectSP(s,wp[0]);\n  }\n  if(N == 1 && M == 2){\n    Segment s(wp[0],wp[1]);\n    return !isIntersectSP(s,bp[0]);\n  }\n  if(N == 2 && M == 2){\n    Segment s1(bp[0],bp[1]),s2(wp[0],wp[1]);\n    return !isIntersectSS(s1,s2);\n  }\n  if(N == 1 && M >= 3){\n    return !check(wp,bp[0]);\n  }\n  if(N >= 3 && M == 1){\n    return !check(bp,wp[0]);\n  }\n  if(N == 2 && M >= 3){\n    Segment s1(bp[0],bp[1]);\n    for(int i = 0 ; i < M ; i++){\n      for(int j = i+1 ; j < M ; j++){\n        Segment s2(wp[i],wp[j]);\n        if(isIntersectSS(s1,s2)){\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  if(N >= 3 && M == 2){\n    Segment s1(wp[0],wp[1]);\n    for(int i = 0 ; i < N ; i++){\n      for(int j = i+1 ; j < N ; j++){\n        Segment s2(bp[i],bp[j]);\n        if(isIntersectSS(s1,s2)){\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  for(int i = 0 ; i < N ; i++){\n    if(check(wp,bp[i])){\n      return false;\n    }\n  }\n  for(int i = 0 ; i < M ; i++){\n    if(check(bp,wp[i])){\n      return false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  int N,M;\n  while(cin >> N >> M,N){\n    Polygon bp(N),wp(M);\n    for(int i = 0 ; i < N ; i++){\n      cin >> bp[i];\n    }\n    for(int i = 0 ; i < M ; i++){\n      cin >> wp[i];\n    }\n    cout << (solve(bp,wp) ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  1\n//\n//  Created by dive5617 on 14-5-24.\n//  Copyright (c) 2014年 dive5617. All rights reserved.\n//\n\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef double DB;\n\nconst DB eps=1e-9;\n\n#define _sign(x) ((x)>eps?1:((x)<-eps?2:0))\n#define Max(a,b) (a>b?a:b)\n#define Min(a,b) (a<b?a:b)\n\nstruct point\n{\n\tDB x,y;\n}p[105],q[105];\n\nDB dist(point a,point b)\n{\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\nDB xmult(point p1,point p2,point p0)\n{\n\treturn (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);\n}\nint inside_convex(point q,int n,point *p)\n{\n\tint i,s[3]={1,1,1};\n\tfor(i=0;i<n && s[1]|s[2];i++)\ts[_sign(xmult(p[(i+1)%n],q,p[i]))]=0;\n\treturn s[1]|s[2];\n}\nbool isIntersected(point s1,point e1,point s2,point e2)\n{\n\treturn ( max(s1.x,e1.x)>=min(s2.x,e2.x)\t&&\n            max(s2.x,e2.x)>=min(s1.x,e1.x) &&\n            max(s1.y,e1.y)>=min(s2.y,e2.y) &&\n            max(s2.y,e2.y)>=min(s1.y,e1.y) &&\n            xmult(s2,e1,s1)*xmult(e1,e2,s1)>=0 &&\n            xmult(s1,e2,s2)*xmult(e2,e1,s2)>=0 );\n}\nstruct cmp\n{\n\tpoint p;\n\tcmp(const point &p0) {p=p0;};\n\tbool operator()(const point &a,const point &b)\n\t{\n\t\tif(fabs(xmult(a,b,p))<eps)\treturn dist(a,p)<dist(b,p);\n\t\treturn xmult(a,b,p)>0;\n\t}\n};\nint scan(point *p,int n){\n\tint i,k=0,top;\n\tfor(i=1;i<n;i++)\tif(p[i].y<p[k].y || (fabs(p[i].y-p[k].y)<eps && p[i].x<p[k].x))\tk=i;\n\tswap(p[0],p[k]);\n\tsort(p+1,p+n,cmp(p[0]));\n\ttop=1;\n\tfor(i=2;i<n;i++)\n\t{\n\t\twhile(top && xmult(p[i],p[top],p[top-1])>=0)\ttop--;\n\t\tp[++top]=p[i];\n\t}\n\treturn top+1;\n}\n\nbool judge(point *p,int n,point *q,int m){\n\tif(n==1)\tp[n++]=p[0];\n\tif(m==1)\tq[m++]=q[0];\n\tif(n==2 && m==2)\treturn !isIntersected(p[0],p[1],q[0],q[1]);\n\tif(m>2)\tfor(int i=0;i<n;i++)\tif(inside_convex(p[i],m,q))\treturn 0;\n\tif(n>2)\tfor(int i=0;i<m;i++)\tif(inside_convex(q[i],n,p))\treturn 0;\n\tfor(int i=0;i<n;i++)\tfor(int j=0;j<m;j++)\tif(isIntersected(p[i],p[(i+1)%n],q[j],q[(j+1)%m]))\treturn 0;\n\treturn 1;\n}\n\nint main(void){\n\tint n,m;\n\twhile(scanf(\"%d%d\",&n,&m)==2 && (n||m))\n\t{\n\t\tfor(int i=0;i<n;i++)\tscanf(\"%lf%lf\",&p[i].x,&p[i].y);\n\t\tfor(int i=0;i<m;i++)\tscanf(\"%lf%lf\",&q[i].x,&q[i].y);\n\t\tif(n*m==0 || n*m==1)\n\t\t{\n\t\t\tputs(\"YES\");\n\t\t\tcontinue;\n\t\t}\n\t\tn=scan(p,n);\n\t\tm=scan(q,m);\n\t\tputs(judge(p,n,q,m)?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res;\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps){\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d,  c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0,  1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n  int n = ps.size();\n  Polygon Q;\n  REP(i,n) {\n    Point A = ps[i], B = ps[(i+1)%n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n      Q.push_back(is_ll(l, m));\n  }\n  return Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n  for (Point q : ps) if (abs(q - p) < eps) return;\n  ps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n  g[from].push_back((Edge){from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n  int n = p.size(), m = s.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (isis_sp(s[i], p[j]))\n      vec.emplace_back(abs(s[i].a - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      add_edge(g, from, to, abs(p[from] - p[to]));\n    }\n  }\n  return g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n  int n = p.size(), m = c.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n      vec.emplace_back(arg(c[i].p - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      ld angle = vec[j+1].first - vec[j].first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n    if (vec.size() >= 2) {\n      int from = vec.back().second, to = vec.front().first;\n      ld angle = vec.front().first - vec.back().first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n  }\n  return g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n  int N = p.size();\n  polygon.clear();\n  REP(i,1024) REP(j,1024) seg2p[i][j].clear();\n  vector<vector<tuple<ld,int,bool>>> tup(N);\n  REP(i,s.size()) {\n    int a = -1, b = -1;\n    REP(j,N) if (abs(s[i].a - p[j]) < eps) a = j;\n    REP(j,N) if (abs(s[i].b - p[j]) < eps) b = j;\n    assert(a >= 0 && b >= 0);\n    tup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n    tup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n  }\n  REP(i,N) sort(ALL(tup[i]));\n  REP(i,N) {\n    REP(j,tup[i].size()) {\n      ld angle; int pos = j, from = i, to; bool flag;\n      tie(angle, to, flag) = tup[i][j];\n      if (flag) continue;\n      vector<int> ps;\n      while (!flag) {\n        ps.push_back(from);\n        get<2>(tup[from][pos]) = true;\n        seg2p[from][to].push_back(polygon.size());\n        seg2p[to][from].push_back(polygon.size());\n        angle += pi + eps;\n        if (angle > pi) angle -= 2 * pi;\n        auto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n        if (it == tup[to].end()) it = tup[to].begin();\n        from = to; tie(angle, to, flag) = *it;\n        pos = it - tup[from].begin();\n      }\n      polygon.push_back(ps);\n    }\n  }\n  Graph g(polygon.size());\n  REP(i,N) REP(j,i) {\n    if (seg2p[i][j].size() == 2) {\n      int from = seg2p[i][j][0], to = seg2p[i][j][1];\n      g[from].push_back((Edge){from, to});\n      g[to].push_back((Edge){to, from});\n    }\n  }\n  return g;\n}\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n  fprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n  Point v = l.b - l.a;\n  Line m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n  int n = p.size();\n  REP(i,n) draw_segment(Line(p[i], p[(i+1)%n]));\n}\n\nvoid draw_circle(Circle c) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nint main() {\n\tint N, M;\n\twhile ( cin >> N >> M, N || M ) {\n\t\tvector<Point> b, w;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\t\tb.push_back( Point(x, y) );\n\t\t}\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\t\tw.push_back( Point(x, y) );\n\t\t}\n\t\tsort(b.begin(), b.end());\n\t\tsort(w.begin(), w.end());\n\n\t\tbool ans = false;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < M; ++j) {\n\t\t\t\tif (b[i] != w[j]) {\n\t\t\t\t\tLine l(b[i], w[j]);\n\t\t\t\t\tint cntB = 0;\n\t\t\t\t\tvector<Point> onB;\n\t\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\t\tint c = ccw(l.a, l.b, b[k]);\n\t\t\t\t\t\tif (c == 1) {\n\t\t\t\t\t\t\t++cntB;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (c == 2 || c == -2 || c == 0) {\n\t\t\t\t\t\t\tonB.push_back(b[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint cntW = 0;\n\t\t\t\t\tvector<Point> onW;\n\t\t\t\t\tfor (int k = 0; k < M; ++k) {\n\t\t\t\t\t\tint c = ccw(l.a, l.b, w[k]);\n\t\t\t\t\t\tif (c == 1) {\n\t\t\t\t\t\t\t++cntW;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (c == 2 || c == -2 || c == 0) {\n\t\t\t\t\t\t\tonW.push_back(w[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ((cntB+onB.size() == N && cntW == 0) || (cntB == 0 && cntW+onW.size() == M)) {\n\t\t\t\t\t\tif (!((onW[0] < onB[0] && onB[0] < onW[onW.size()-1]) || (onW[0] < onB[onB.size()-1] && onB[onB.size()-1] < onW[onW.size()-1])\n\t\t\t\t\t\t\t|| (onB[0] < onW[0] && onW[0] < onB[onB.size()-1]) || (onB[0] < onW[onW.size()-1] && onW[onW.size()-1] < onB[onB.size()-1])) ) {\n\t\t\t\t\t\t\tans = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n/*\n\t\t\t\t\t\tbool f = true;\n\t\t\t\t\t\tfor (int i = 0; i < onB.size(); ++i) {\n\t\t\t\t\t\t\tfor (int j = 0; j < onB.size(); ++j) {\n\t\t\t\t\t\t\t\tfor (int k = 0; k < onW.size(); ++k) {\n\t\t\t\t\t\t\t\t\tif (i != j && ccw(onB[i], onB[j], onW[k]) == 0) {\n\t\t\t\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int i = 0; i < onW.size(); ++i) {\n\t\t\t\t\t\t\tfor (int j = 0; j < onW.size(); ++j) {\n\t\t\t\t\t\t\t\tfor (int k = 0; k < onB.size(); ++k) {\n\t\t\t\t\t\t\t\t\tif (i != j && ccw(onW[i], onW[j], onB[k]) == 0) {\n\t\t\t\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (f) {\n\t\t\t\t\t\t\tans = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n*/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\n#include <complex>\n#include <cmath>\n#define EPS 1.0e-10\n#define PI 3.1415926535897932384 \n\n// 実数の符号関数\ninline int signum(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n//XY座標\n#define X real()\n#define Y imag()\n// 点\ntypedef complex<double> P;\n \n\n// 線分・半直線・直線\nstruct L { P pos, dir; L(P p=P(), P d=P()):pos(p),dir(d){}};\n\n// 多角形\ntypedef vector<P> G;\n\n// std::norm はabs(p)*abs(p)なので遅い\ninline double norm(P p){\n\treturn p.X*p.X+p.Y*p.Y;\n}\n\n// 二つのベクトルの内積を計算する\ninline double inp(const P& a, const P& b) {\n\treturn (conj(a)*b).X;\n}\n \n// 二つのベクトルの外積を計算する\ninline double outp(const P& a, const P& b) {\n\treturn (conj(a)*b).Y;\n}\n\ninline int ccw(const P& p, const P& r, const P& s) {\n    P a(r-p), b(s-p);\n    int sgn = signum(outp(a, b));\n    if (sgn != 0)\n        return sgn;\n    if (a.X*b.X < -EPS || a.Y*b.Y < -EPS)\n        return -1;\n    if (norm(a) < norm(b) - EPS)\n        return 1;\n    return 0;\n}\n\n// ベクトルpをベクトルbに射影したベクトルを計算する\ninline P proj(const P& p, const P& b) {\n\treturn b*inp(p,b)/norm(b);\n}\n\n// 点pから直線lに引いた垂線の足となる点を計算する\ninline P perf(const L& l, const P& p) {\n\tL m(l.pos - p, l.dir);\n\treturn (p + (m.pos - proj(m.pos, m.dir)));\n}\nbool sp_intersects(const L& s, const P& p) {\n    return ( abs(s.pos - p) + abs(s.pos + s.dir - p) - abs(s.dir) < EPS );\n}\n//(凸とは限らない)多角形の内部に点が包含されているか判定する。\nbool gp_contains(const G& g, const P& p) {\n    double sum = 0.0;\n    int n = g.size();\n    if(n && g[0] == p) return true;\n    for(int i = 0; i < n; i++) {\n        int j = (i+1)%n;\n        if (sp_intersects((L){g[i], g[j]-g[i]}, p))\n            return true;\n        sum += arg((g[j]-p)/(g[i]-p));\n    }\n    return (abs(sum) > 1);\n}\n\nbool xy_less(const P& a, const P& b) {\n    if (abs(a.imag()-b.imag()) < EPS) return (a.real() < b.real());\n    return (a.imag() < b.imag());\n}\ntemplate<class IN>\nvoid walk_rightside(IN begin, IN end, vector<P>& v) {\n    IN cur = begin;\n    v.push_back(*cur++);\n    vector<P>::size_type s = v.size();\n    v.push_back(*cur++);\n    while(cur != end) {\n        if (v.size() == s || ccw(v[v.size()-2], v.back(), *cur) > EPS)\n            v.push_back(*cur++);\n        else\n            v.pop_back();\n    }\n    v.pop_back();\n}\n//凸包を求める\nvector<P> convex_hull(vector<P> v) {\n    if (v.size() <= 1)\n        return v; // EXCEPTIONAL\n    sort(v.begin(), v.end(), xy_less);\n    vector<P> cv;\n    walk_rightside(v.begin(), v.end(), cv);\n    walk_rightside(v.rbegin(), v.rend(), cv);\n    return cv;\n}\nbool ss_intersects(const L& s, const L& t) {\n    return (ccw(s.pos, s.pos+s.dir, t.pos) *\n            ccw(s.pos, s.pos+s.dir, t.pos+t.dir) <= 0 &&\n            ccw(t.pos, t.pos+t.dir, s.pos) *\n            ccw(t.pos, t.pos+t.dir, s.pos+s.dir) <= 0);\n}\ndouble sp_distance(const L& s, const P& p) {\n    const P r = perf(s, p);\n    const double pos = ((r-s.pos)/s.dir).real();\n    if (-EPS <= pos && pos <= 1 + EPS)\n        return abs(r - p);\n    return min(abs(s.pos - p),\n               abs(s.pos+s.dir - p));\n}\ndouble ss_distance(const L& s, const L& t) {\n    if (ss_intersects(s, t))\n        return 0;\n    return min(min(sp_distance(s, t.pos),\n            sp_distance(s, t.pos+t.dir)),\n            min(sp_distance(t, s.pos),\n            sp_distance(t, s.pos+s.dir)));\n}\nint n, m;\n\nbool check(vector<P> &a, vector<P> &b){\n\tif(b.size() > 2) REP(i, n) if(gp_contains(b, a[i])) return false;\n\tif(a.size() > 2) REP(i, m) if(gp_contains(a, b[i])) return false;\n\tREP(i, n){\n\t\tL l1(a[i], a[(i+1)%n] - a[i]);\n\t\tREP(j, m){\n\t\t\tL l2(b[j], b[(j+1)%m] - b[j]);\n\t\t\tif(ss_distance(l1, l2) < EPS) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m, n){\n\t\tvector<P> a(n), b(m);\n\t\tREP(i, n) cin >> a[i].X >> a[i].Y;\n\t\tREP(i, m) cin >> b[i].X >> b[i].Y;\n\t\ta = convex_hull(a);\n\t\tb = convex_hull(b);\n\t\tn = a.size(); m = b.size();\n\t\tcout << (check(a, b) ? \"YES\" : \"NO\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\n#define EQ(a,b) (abs((a)-(b))<eps)\n\nld dot (P a, P b) { return real(conj(a) * b); }\nld cross (P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n  bool operator<(const P &lhs, const P &rhs) {\n    return lhs.real() == rhs.real() ? lhs.imag() < rhs.imag()\n                                    : lhs.real() < rhs.real();\n  }\n}\n\nstruct L{ P a, b; };\nstruct C { P p; ld r; };\n\n// counter clockwise\nint ccw (P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;   // counter clockwise\n  if (cross(b, c) < -eps) return -1; // clockwise\n  if (dot(b, c) < 0) return 2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line\n  return 0;                          // a--c--b on line\n}\n\nvector<L> tangent_cp(C c, P p) {\n  vector<L> ret;\n  P v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  P v1 = v * P(l / d,  c.r / d);\n  P v2 = v * P(l / d, -c.r / d);\n  ret.push_back((L){p, p + v1});\n  if (l < eps) return ret;\n  ret.push_back((L){p, p + v2});\n  return ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n  vector<L> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    P center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    P out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<L> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    P v = c2.p - c1.p;\n    v /= abs(v);\n    P q1 = c1.p + v * P(0,  1) * c1.r;\n    P q2 = c1.p + v * P(0, -1) * c1.r;\n    ret.push_back((L){q1, q1 + v});\n    ret.push_back((L){q2, q2 + v});\n  }\n  return ret;\n}\n\nint main() {\n  while(1) {\n    int n,m;\n    cin>>n>>m;\n    if(!n) break;\n    VP vb, vw;\n    REP(i,n) {\n      int x,y;\n      cin>>x>>y;\n      vb.emplace_back(x,y);\n    }\n    REP(i,m) {\n      int x,y;\n      cin>>x>>y;\n      vw.emplace_back(x,y);\n    }\n    bool ok = false;\n    ld delta = 1e-4;\n    REP(i,n)REP(j,m) {\n      C ci = {vb[i], delta};\n      C cj = {vw[j], delta};\n      vector<L> vl = tangent_cc(ci, cj);\n      for (L l : vl) {\n        int ccwi = ccw(l.a, vb[i], l.b);\n        int ccwj = ccw(l.a, vw[j], l.b);\n        if (ccwi * ccwj >= 0) continue;\n        bool valid = true;\n        REP(k,n) {\n          if (ccw(l.a, vb[k], l.b) * ccwi <= 0) {\n            valid = false;\n            break;\n          }\n        }\n        if (!valid) continue;\n        REP(k,m) {\n          if (ccw(l.a, vw[k], l.b) * ccwi >= 0) {\n            valid = false;\n            break;\n          }\n        }\n        if (valid) ok = true;\n      }\n    }\n    if (ok) {\n      cout << \"YES\" << endl;\n    } else {\n      cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\n#define EPS 1e-5\n\ntypedef complex<double> point;\ntypedef const point &refpoint;\n\n\ndouble dot(refpoint a, refpoint b){\n\treturn real(a) * real(b) + imag(a) * imag(b);\n}\n\ndouble cross(refpoint a, refpoint b){\n\treturn real(a) * imag(b) - imag(a) * real(b);\n}\n\ndouble distance_l_p(refpoint a, refpoint b, refpoint c){\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\ndouble distance_ls_p(refpoint a, refpoint b, refpoint c){\n\tif( dot(b - a, c - a) <= 0.0 ) return abs(c - a);\n\tif( dot(a - b, c - b) <= 0.0 ) return abs(c - b);\n\treturn distance_l_p(a, b, c);\n}\n\nbool contains(const vector<point> &plg, refpoint pts){\n\tint cnt = 0;\n\tdouble y = imag(pts);\n\n\tfor(int i = 0; i < plg.size(); ++i){\n\t\tint j = (i + 1 == plg.size() ? 0: i + 1);\n\n\t\tdouble dyi = imag(plg[i]) - y;\n\t\tdouble dyj = y - imag(plg[j]);\n\t\tdouble tx = (dyi * real(plg[j]) + dyj * real(plg[i])) / (dyi + dyj);\n\n\t\tif(imag(plg[i]) >= y && imag(plg[j]) < y){\n\t\t\tif( tx < real(pts) ) ++cnt;\n\t\t}\n\t\telse if(imag(plg[i]) < y && imag(plg[j]) >= y){\n\t\t\tif( tx < real(pts) ) --cnt;\n\t\t}\n\t}\n\t\n\treturn (cnt % 2 != 0);\n}\n\nbool intersected(refpoint pa1, refpoint pa2, refpoint pb1, refpoint pb2){\n\tdouble a = cross(pa2 - pa1, pb1 - pa1);\n\tdouble b = cross(pa2 - pa1, pb2 - pa1);\n\tdouble c = cross(pb2 - pb1, pa1 - pb1);\n\tdouble d = cross(pb2 - pb1, pa2 - pb1);\n\n\tif( (a < -EPS && b > EPS) || (b < -EPS && a > EPS) ){\n\t\tif( (c < -EPS && d > EPS) || (d < -EPS && c > EPS) ){\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nbool contact(const vector<point> &plg1, const vector<point> &plg2){\n\tif( contains(plg1, plg2[0]) || contains(plg2, plg1[0]) ){\n\t\treturn true;\n\t}\n\n\tint n = plg1.size();\n\tint m = plg2.size();\n\tfor(int i = 0; i < n; ++i){\n\t\tfor(int j = 0; j < m; ++j){\n\t\t\tif( intersected(plg1[i], plg1[(i+1)%n], plg2[j], plg2[(j+1)%m]) ){\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif( distance_ls_p(plg1[i], plg1[(i+1)%n], plg2[j]) < EPS ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif( distance_ls_p(plg2[j], plg2[(j+1)%m], plg1[i]) < EPS ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n\nbool orderbyreal(refpoint p1, refpoint p2){\n\treturn real(p1) < real(p2);\n}\n\n\nvector<point> convex(vector<point> plg){\n\tint n = plg.size();\n\tif( n <= 3 ){\n\t\treturn plg;\n\t}\n\n\tsort(plg.begin(), plg.end(), orderbyreal);\n\n\tvector<point> ret(2 * n);\n\tint k = 0;\n\n\tfor(int i = 0; i < n; ++i){\n\t\twhile( k >= 2 && cross( ret[k-1] - ret[k-2], plg[i] - ret[k-2] ) <= 0.0 ){\n\t\t\t--k;\n\t\t}\n\t\tret[k++] = plg[i];\n\t}\n\n\tint t = k + 1;\n\tfor(int i = n - 2; i >= 0; --i){\n\t\twhile( k >= t && cross( ret[k-1] - ret[k-2], plg[i] - ret[k-2] ) <= 0.0 ){\n\t\t\t--k;\n\t\t}\n\t\tret[k++] = plg[i];\n\t}\n\tret.resize(k - 1);\n\t\n\treturn ret;\n}\n\n\nint main(){\n\tint n, m;\n\tdouble x, y;\n\t\n\twhile( scanf(\"%d%d\", &n, &m), n != 0 ){\n\t\tvector<point> black, white;\n\t\tblack.reserve(n);\n\t\twhite.reserve(m);\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\tblack.push_back( point(x, y) );\n\t\t}\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\twhite.push_back( point(x, y) );\n\t\t}\n\n\n\t\tblack = convex(black);\n\t\twhite = convex(white);\n\n\t\tif( contact(black, white) ){\n\t\t\tputs(\"NO\");\n\t\t}\n\t\telse{\n\t\t\tputs(\"YES\");\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#define next(P, i) P[(i+1) % P.size()]\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n};\n\nbool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n\n  if(cross(a1-a2,b1-b2)==0){\n    return is_point_on_line(a1,a2,b1) || is_point_on_line(a1,a2,b2) \n        || is_point_on_line(b1,b2,a1) || is_point_on_line(b1,b2,a2);\n  }\n  else {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n           ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n  }\n}\n\nint contain(point p, vector<point> ps){\n  point a(p.x,p.y),b(1000000,p.y);\n\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<ps.size();i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(a.y<=ymn||a.y>=ymx)return 0;\n\n  int cnt1=0;\n  for(int i=0;i<ps.size();i++)\n    if(is_point_on_line(a,b,ps[i]))cnt1++;\n  \n  int cnt=0;\n  for(int i=0;i<ps.size();i++)\n    if(is_intersected_ls(ps[i],ps[(i+1)%ps.size()],a,b))cnt++;\n\n  return (cnt-cnt1)%2;\n}\n\nint crossPol(vector<point> pol1, vector<point> pol2){\n\n  for(int i=0;i<pol1.size();i++)\n    if(contain(pol1[i],pol2))return 1;\n  \n  for(int i=0;i<pol2.size();i++)\n    if(contain(pol2[i],pol1))return 1;\n\n  for(int i=0;i<pol1.size();i++)\n    for(int j=0;j<pol2.size();j++)\n      if(is_intersected_ls(pol1[i],next(pol1,i),pol2[j],next(pol2,j)))return 1;\n  \n  return 0;\n}\n\nvector<point>convex_hull(point* ps, int n){\n  sort(ps,ps+n,cmp_x);\n  int k=0;\n  vector<point>qs(n*2);\n \n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0)k--;\n    qs[k++]=ps[i];\n  }\n \n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0)k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nint main(void){\n  int n,m;\n  point black[100],white[100];\n\n  while(cin >> n >> m,n|m){\n\n    for(int i=0;i<n;i++)\n      cin >> black[i].x >> black[i].y;\n    \n    for(int i=0;i<m;i++)\n      cin >> white[i].x >> white[i].y;\n\n    if(n<2||m<2){\n      if(n<2 && m<2)cout << \"YES\" << endl;\n      else {\n\tbool fg=false;\n\tfor(int i=0;i<n;i++){\n\t  for(int j=0;j<m;j++){\n\t    if(is_intersected_ls(black[i],black[(i+1)%n],white[j],white[(j+1)%n]))fg=true;\n\t  }\n\t}\n\tif(fg)cout <<\"NO\"<<endl;\n\telse cout << \"YES\" << endl;\n      }\n      continue;\n    }\n\n    vector<point>Black,White;\n\n    Black=convex_hull(black,n);\n    White=convex_hull(white,m);\n    \n    if(crossPol(Black,White))cout << \"NO\" << endl;\n    else cout << \"YES\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nconst double EPS = 1e-8;\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nvector<P> convex_hull(vector<P> v){\n  vector<P> c; //convex\n  sort(v.begin(),v.end());\n  c.assign(v.begin(),v.begin()+2);\n    \n  for(int i=2;i<v.size();i++){\n    P a = c[c.size()-1] - c[c.size()-2];\n    P b = v[i] - c[c.size()-2];\n        \n    while(cross(a,b) > EPS){\n      c.pop_back();\n      if(c.size() < 2) break;\n      a = c[c.size()-1] - c[c.size()-2];\n      b = v[i] - c[c.size()-2];\n    }\n        \n    c.push_back(v[i]);\n  }\n\t\n  int n = c.size();\n  c.push_back(v[v.size()-2]);\n\t\n  for(int i=v.size()-3;i>=0;i--){\n    P a = c[c.size()-1] - c[c.size()-2];\n    P b = v[i] - c[c.size()-2];\n        \n    while(cross(a,b) > EPS){\n      c.pop_back();\n      if(c.size() < n + 1) break;\n      a = c[c.size()-1] - c[c.size()-2];\n      b = v[i] - c[c.size()-2];\n    }\n        \n    c.push_back(v[i]);\n\t}\n  c.pop_back();\n  return c;\n}\n\nL get2points(vector<P> p){\n  \n  double dis=0;\n  int idx1, idx2;\n  \n  for(int i=0;i<p.size();i++){\n    for(int j=i+1;j<p.size();j++){\n      if(abs(p[j]-p[i])>dis){\n\tdis=abs(p[j]-p[i]);\n\tidx1=i;\n\tidx2=j;\n      }\n    }\n  }\n\n  return L(p[idx1],p[idx2]);\n}\n\nbool isIntersectSP(L s, P p){ \n  return abs(s.first-p) + abs(s.second-p) - abs(s.second-s.first) < EPS; \n}\n\nbool check(vector<P> p){\n  \n  L l=get2points(p);\n  \n  for(int i=0;i<p.size();i++)\n    if(!isIntersectSP(l,p[i])) return false;\n\n  return true;\n}\n\nbool isIntersect(L s1, L s2){\n  \n  //ccw ??????????????????????????¨, ????????????????????´?????????????????¨??????????????????????????????\n  if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\nint main(){\n  \n  while(1){\n    \n    int n, m;\n    cin>>n>>m;\n    \n    if(!n&&!m) break;\n    \n    vector<P> p1, p2;\n\n    for(int i=0;i<n;i++){\n      int a, b;\n      cin>>a>>b;\n      p1.push_back(P(a,b));\n    }\n    \n    for(int i=0;i<m;i++){\n      int a, b;\n      cin>>a>>b;\n      p2.push_back(P(a,b));\n    }\n\n    bool ans=true;\n\n    vector<P> v1, v2;\n    \n    if(p1.size()!=1){\n      \n      if(check(p1)){\n\tL l=get2points(p1);\n\tfor(int i=0;i<p2.size();i++)\n\t  if(isIntersectSP(l,p2[i])) ans=false;\n\tv1.push_back(l.first);\n\tv1.push_back(l.second);\n      }else{\n\tvector<P> p=convex_hull(p1);\n\t\n\tfor(int i=0;i<p2.size();i++){\n\t  int com=ccw(p[0],p[1],p2[i]);\n\t  int flag=0;\n\t  for(int j=0;j<p.size();j++)\n\t    if(com!=ccw(p[j],p[(j+1)%p.size()],p2[i])) flag=1;\n\t  if(flag==0) ans=false;\n\t}\n\t\n\tfor(int i=0;i<p.size();i++)\n\t  for(int j=0;j<p2.size();j++)\n\t    if(isIntersectSP(L(p[i],p[(i+1)%p.size()]),p2[j])) ans=false;\n\tv1=p;\n      }\n      \n    }\n    \n    if(p2.size()!=1){\n      \n      if(check(p2)){\n\tL l=get2points(p2);\n\tfor(int i=0;i<p1.size();i++)\n\t  if(isIntersectSP(l,p1[i])) ans=false;\n\tv2.push_back(l.first);\n\tv2.push_back(l.second);\n      }else{\n\tvector<P> p=convex_hull(p2);\n\t\n\tfor(int i=0;i<p1.size();i++){\n\t  int com=ccw(p[0],p[1],p1[i]);\n\t  int flag=0;\n\t  for(int j=0;j<p.size();j++)\n\t    if(com!=ccw(p[j],p[(j+1)%p.size()],p1[i])) flag=1;\n\t  if(flag==0) ans=false;\n\t}\n\n\tfor(int i=0;i<p.size();i++)\n\t  for(int j=0;j<p1.size();j++)\n\t    if(isIntersectSP(L(p[i],p[(i+1)%p.size()]),p1[j])) ans=false;\n\tv2=p;\n      }\n      \n    }\n    \n    /*    if(p1.size()!=1&&p2.size()!=1){\n      \n      for(int i=0;i<v1.size();i++)\n\tfor(int j=0;j<v2.size();j++){\n\t  L l1=L(v1[i],v1[(i+1)%v1.size()]);\n\t  L l2=L(v2[i],v2[(i+1)%v2.size()]);\n\t  if(isIntersect(l1,l2)) ans=false;\n\t}\n      \n\t}*/\n    \n    if(ans) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n    \n  }  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst double eps=1e-8;\nconst int  maxn=205;\nint dcmp(double d){\n    if(fabs(d)<eps)return 0;\n    return d>0?1:-1;\n}\nstruct pnt{\n    double x,y;\n    pnt():x(0),y(0){}\n    pnt(double tx,double ty):x(tx),y(ty){}\n    pnt operator -(pnt p2){\n        pnt newp(x-p2.x,y-p2.y);\n        return newp;\n    }\n    pnt operator +(pnt p2){\n        pnt newp(x+p2.x,y+p2.y);\n        return newp;\n    }\n    pnt operator *(double  d){\n        pnt newp(x*d,y*d);\n        return newp;\n    }\n    pnt operator /(double  d){\n        pnt newp(x/d,y/d);\n        return newp;\n    }\n    double dis(pnt p2){\n        return sqrt((x-p2.x)*(x-p2.x)+(y-p2.y)*(y-p2.y));\n    }\n    bool operator ==(pnt p2){\n        if(dcmp(x-p2.x)==0&&dcmp(y-p2.y)==0)return true;\n        return false;\n    }\n};\ndouble cross(pnt p1,pnt p2){\n    return p1.x*p2.y-p1.y*p2.x;\n}\nbool cmpx(pnt p1,pnt p2){\n    if(p1.x!=p2.x)return p1.x<p2.x;\n    return p1.y<p2.y;\n}\npnt base;\nbool cmp(pnt p1,pnt p2){\n    return cross(p1-  base,p2-base)<0;\n}\n\nint isPointInConvexPolygon(pnt p1,pnt * p,int n){\n    for(int i=0;i<n;i++){\n        pnt A=pnt(p[(i+1)%n].x-p[i].x,p[(i+1)%n].y-p[i].y);\n        pnt B=pnt(p1.x-p[i].x,p1.y-p[i].y);\n        int fl=dcmp(cross(A,B));\n        if(fl<0)return 0;\n        if(fl==0){\n            int maxx=max(p[(i+1)%n].x,p[i].x);\n            int minx=min(p[(i+1)%n].x,p[i].x);\n            int maxy=max(p[(i+1)%n].y,p[i].y);\n            int miny=min(p[(i+1)%n].y,p[i].y);\n            if(minx<=p1.x&&maxx>=p1.x&&miny<=p1.y&&maxy>=p1.y)return -1;//on the edge\n            else return 0;\n        }\n    }\n    return 1;\n}\nint graham(pnt * p,pnt * h,int n){\n\n        int m=0;\n        for(int i=0;i<n;i++){//隶。邂嶺ク雁?蛹?                while(m>1&&cross((h[m-1]-h[m-2]),(p[i]-h[m-2]))<=0){m--;}\n                h[m++]=p[i];\n        }\n        int tm=m;\n        for(int i=n-2;i>=0;i--){//隶。邂嶺ク句?蛹?                while(m>tm&&cross((h[m-1]-h[m-2]),(p[i]-h[m-2]))<=0){m--;}\n                h[m++]=p[i];\n        }\n        if(n>1)m--;\n        return m;\n}\n\nbool between(pnt p1,pnt p2,pnt p){\n        return (p.x<=max(p1.x,p2.x)&&p.x>=min(p1.x,p2.x))\n        &&  (p.y<=max(p1.y,p2.y)&&p.y>=min(p1.y,p2.y));\n}\nbool isInsert(pnt p11,pnt p12,pnt p21,pnt p22){\n        pnt v=p22-p21;\n        pnt w=p12-p11;\n        pnt u=p21-p11;\n        if(cross(v,w)==0){\n                if(cross(v,u)!=0)return false;\n                if(between(p11,p12,p21))return true;\n                if(between(p11,p12,p22))return true;\n                return false;\n        }\n        double t=cross(w,u)/cross(v,w);\n        double t2=cross(v,u)/cross(v,w);\n        if(t2>1||t2<0)return false;\n        if(t>1||t<0)return false;\n        return true;\n}\n\npnt bp[maxn],bh[maxn],wp[maxn],wh[maxn];\nint bn,wn,btop,wtop;\n\nint main(){\n        while(scanf(\"%d%d\",&bn,&wn)==2&&(bn||wn)){\n                for(int i=0;i<bn;i++){\n                        scanf(\"%lf%lf\",&bp[i].x,&bp[i].y);\n                }\n                for(int i=0;i<wn;i++){\n                        scanf(\"%lf%lf\",&wp[i].x,&wp[i].y);\n                }\n                bool fl=true;\n\n                if(bn>1){\n                        sort(bp,bp+bn,cmpx);\n                        base =bp[0];\n                        sort(bp+1,bp+bn,cmp);\n                        btop=graham(bp,bh,bn);\n\n                        if(fl)for(int i=0;i<wn;i++){\n                                if(isPointInConvexPolygon(wp[i],bh,btop)){\n                                        fl=false;\n                                        break;\n                                }\n                        }\n                }\n\n                if(wn>1){\n                        sort(wp,wp+wn,cmpx);\n                        base =wp[0];\n                        sort(wp+1,wp+wn,cmp);\n                        wtop=graham(wp,wh,wn);\n\n\n                        if(fl){\n                                for(int i=0;i<bn;i++){\n                                        if(isPointInConvexPolygon(bp[i],wh,wtop)){\n                                                fl=false;\n                                                break;\n                                        }\n                                }\n                        }\n                }\n\n                if(fl&&bn>1&&wn>1){\n                        for(int i=0;i<btop;i++){\n                                for(int j=0;j<wtop;j++){\n                                        if(isInsert(bh[i],bh[(i+1)%btop],wh[j],wh[(j+1)%wtop])){\n                                                fl=false;\n                                                break;\n                                        }\n                                }\n                        }\n                }\n                if(wn==1&&bn==1&&bp[0]==wp[0]){fl=false;}\n\n\n                if(fl)puts(\"YES\");\n                else puts(\"NO\");\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cassert>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-8\n#define F first\n#define S second\nusing namespace std;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point\n{\n  public:\n  double x,y;\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nbool isIntersect(Segment s1,Segment s2)\n{\nreturn isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool cmp(const vector<Point> &a,const vector<Point> &b)\n{\n  return a.size() < b.size();\n}\n\nPolygon andrewScan(Polygon s)\n{\n  Polygon u,l;\n  if(s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<s.size();i++)\n    {\n      for(int n=u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--)\n\tu.pop_back();\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3; i>=0 ; i--)\n    {\n      for(int n=l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--)\n\tl.pop_back();\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\nbool check(int p1,int p2,vector<Point> &black,vector<Point> &white)\n{\n  int n = black.size();\n  pair<bool,bool> Left,Right;\n  Left  = pair<bool,bool>(false,false); // F->black, S->white\n  Right = pair<bool,bool>(false,false);\n\n  rep(i,n)\n    {\n      if(i == p1 || i == p2)continue;\n      int res = ccw(black[p1],black[p2],black[i]);\n      if(res == CLOCKWISE) Right.F = true;\n      if(res == COUNTER_CLOCKWISE) Left.F = true;\n    }\n  \n  n = white.size();\n  rep(i,n)\n    {\n      int res = ccw(black[p1],black[p2],white[i]);\n      if(res == CLOCKWISE) Right.S = true;\n      if(res == COUNTER_CLOCKWISE) Left.S = true;\n    }\n\n  if(Left.F && Left.S)return false;\n  if(Right.F && Right.S)return false;\n  return true;\n}\n\nvoid printVP(vector<Point> a)\n{\n  cout << \"printVP-------\" << endl;\n  rep(i,a.size())cout << \"(\" << a[i].x << \",\" << a[i].y << \") \";\n  cout << endl;\n}\n\nint main()\n{\n  int n,m;\n  while(cin >> n >> m,n|m)\n    {\n      assert(n && m);\n      vector<Point> A(n),B(m);\n      rep(_,n)cin >> A[_].x >> A[_].y;\n      rep(_,m)cin >> B[_].x >> B[_].y;\n\n      vector<Point> black,white;\n      if(A.size() > B.size())\n\tblack = A,white = B;\n      else\n\tblack = B,white = A;\n\n      \n      if(n == 1 && m == 1)\n\t{\n\t  cout << \"YES\" << endl;\n\t  continue;\n\t}\n      \n      if(white.size() == 1)\n\t{\n\t  sort(black.begin(),black.end());\n\t  if(ccw(black[0],black[black.size()-1],white[0]) == ON_SEGMENT)\n\t    {\n\t      cout << \"NO\" << endl;\n\t      continue;\n\t    }\n\t  rep(i,black.size())\n\t    if(ccw(black[i],black[(i+1)%black.size()],white[0]) == ON_SEGMENT)\n\t      {\n\t\tcout << \"NO\" << endl;\n\t\tgoto FX;\n\t      }\n\t  cout << \"YES\" << endl;\n\tFX:;\n\t  continue;\n\t}\n    \n      if(black.size() == 2 && white.size() == 2)\n\t{\n\t  if(isIntersect(Segment(black[0],black[1]),Segment(white[0],white[1])))cout << \"NO\" << endl;\n\t  else                                                                  cout << \"YES\" << endl;\n\t  continue;\n\t}\n    \n      int N = black.size();\n      rep(i,N)\n\t{\n\t  REP(j,i+1,N)\n\t    {\n\t      if(check(i,j,black,white))\n\t\t{\n\t\t  //cout << black[i].x << \",\" << black[i].y << endl;\n\t\t  //cout << black[j].x << \",\" << black[j].y << endl;\n\t\t  cout << \"YES\" << endl;\n\t\t  goto F;\n\t\t}\n\t    }\n\t}\n      cout << \"NO\" << endl;\n    F:;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ------ Petr Mitrichev is Professional. ------ //\n\n#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// ------ Class ------ //\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tbool operator==(const Point& p) const { return px == p.px && py == p.py; }\n\tbool operator!=(const Point& p) const { return px != p.px || py != p.py; }\n\tbool operator<(const Point& p) const { return px < p.px ? true : (px == p.px && py < p.py); }\n\tbool operator>(const Point& p) const { return px > p.px ? true : (px == p.px && py > p.py); }\n\tbool operator<=(const Point& p) const { return !(Point(px, py) > p); }\n\tbool operator>=(const Point& p) const { return !(Point(px, py) < p); }\n\tPoint operator+(const Point& p) const { return Point(px + p.px, py + p.py); }\n\tPoint operator-(const Point& p) const { return Point(px - p.px, py - p.py); }\n\tPoint operator/(long double d) const { return Point(px / d, py / d); }\n\tfriend Point operator*(const Point p, long double d) { return Point(p.px * d, p.py * d); }\n\tfriend Point operator*(long double d, const Point& p) { return p * d; }\n\tPoint& operator+=(const Point& p1) { px += p1.px, py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px, py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d, py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d, py /= d; return *this; }\n};\n\n// ------ Functions ------ //\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint pol(long double r, long double d) { return Point(cosl(d) * r, sinl(d) * r); }\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nvector<Point> convex_hull(vector<Point> v) {\n\tif (v.size() < 3) return v;\n\tsort(v.begin(), v.end());\n\tvector<Point> u = { v[0], v[1] }, l = { v[v.size() - 1], v[v.size() - 2] };\n\tfor (int i = 2; i < v.size(); i++) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], v[i]) >= 0; n--) u.pop_back();\n\t\tu.push_back(v[i]);\n\t}\n\tfor (int i = v.size() - 3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], v[i]) >= 0; n--) l.pop_back();\n\t\tl.push_back(v[i]);\n\t}\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\n// ------ Main ------ //\nint n, m; vector<Point> v1, v2, v3, v4;\nbool ok(int i) {\n\tint u = (i + 1) % v3.size();\n\tfor (int j = 0; j < v4.size(); j++) {\n\t\tif (abs(ccw(v3[i], v3[u], v4[j])) != 1) return false;\n\t}\n\tfor (int j = 0; j < v3.size(); j++) {\n\t\tif (i == j || u == j) continue;\n\t\tfor (int k = 0; k < v4.size(); k++) {\n\t\t\tif (ccw(v3[i], v3[u], v3[j]) == ccw(v3[i], v3[u], v4[k])) return false;\n\t\t}\n\t}\n\tfor (int j = 0; j < v4.size(); j++) {\n\t\tfor (int k = j + 1; k < v4.size(); k++) {\n\t\t\tif (ccw(v3[i], v3[u], v4[j]) != ccw(v3[i], v3[u], v4[k])) return false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\twhile (cin >> n >> m, n + m) {\n\t\tv1.resize(n), v2.resize(m);\n\t\tfor (int i = 0; i < n; i++) cin >> v1[i].px >> v1[i].py;\n\t\tfor (int i = 0; i < m; i++) cin >> v2[i].px >> v2[i].py;\n\t\tv3 = convex_hull(v1), v4 = convex_hull(v2);\n\t\tint x = 0;\n\t\tif (v3.size() == 1 && v4.size() == 1) x = 1;\n\t\tif (!x && v3.size() > 1) {\n\t\t\tint w = ccw(v3[0], v3[1], v4[0]);\n\t\t\tif (abs(w) == 2) {\n\t\t\t\tint f = 1;\n\t\t\t\tfor (int i = 1; i < v4.size(); i++) {\n\t\t\t\t\tif (ccw(v3[0], v3[1], v4[i]) != w) {\n\t\t\t\t\t\tf = 0; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f) x = 1;\n\t\t\t}\n\t\t}\n\t\tif (!x && v4.size() > 1) {\n\t\t\tint w = ccw(v4[0], v4[1], v3[0]);\n\t\t\tif (abs(w) == 2) {\n\t\t\t\tint f = 1;\n\t\t\t\tfor (int i = 1; i < v3.size(); i++) {\n\t\t\t\t\tif (ccw(v4[0], v4[1], v3[i]) != w) {\n\t\t\t\t\t\tf = 0; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f) x = 1;\n\t\t\t}\n\t\t}\n\t\tif (!x) {\n\t\t\tfor (int i = 0; i < v3.size(); i++) {\n\t\t\t\tif (ok(i)) x = 1;\n\t\t\t}\n\t\t}\n\t\tif (!x) {\n\t\t\tswap(v3, v4);\n\t\t\tfor (int i = 0; i < v4.size(); i++) {\n\t\t\t\tif (ok(i)) x = 1;\n\t\t\t}\n\t\t}\n\t\tcout << (x ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  int b, w;\n  while(cin>>b>>w && (b != 0 || w != 0)){\n    srand(time(NULL));\n    vector<double> x1(b), y1(b);\n    vector<double> x2(w), y2(w);\n    REP(i, b)cin>>x1[i]>>y1[i];\n    REP(i, w)cin>>x2[i]>>y2[i];\n    bool ans = false;\n    REP(time, 40000){\n      const double D = 1e6;\n      double t = (double)rand()/RAND_MAX * D * ((rand() % 2) ?  1 : -1);\n      double min_b = 1e30, max_b = -1e30;\n      double min_w = 1e30, max_w = -1e30;\n      REP(i, b){\n        double d = (y1[i] + t)/(x1[i] + 1000.0);\n        min_b = min(min_b, d);\n        max_b = max(max_b, d);\n      }\n      REP(i, w){\n        double d = (y2[i] + t)/(x2[i] + 1000.0);\n        min_w = min(min_w, d);\n        max_w = max(max_w, d);\n      }\n      if(min_w > max_b) ans = true;\n      if(min_b > max_w) ans = true;\n      if(ans) break;\n    }\n    if(ans) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nconst double EPS = 1e-8;\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nP normal(P p){ return p / abs(p); }\n\nP rotate(P p, double rad){\n  double x = real(p) * cos(rad) - imag(p) * sin(rad);\n  double y = real(p) * sin(rad) + imag(p) * cos(rad);\n  return P(x,y);\n}\n\n\nint n[2];\nvector<P> v[2];\n\nbool solve(){\n  for(int i=0;i<n[0];i++){\n    for(int j=0;j<n[1];j++){\n      for(int k=-1;k<=1;k+=2){\n        P nor = normal(v[1][j] - v[0][j]) * EPS;\n        L line = L(v[0][i] + rotate(nor, M_PI/2.0*k), v[1][j] + rotate(nor, M_PI/2.0*(-k)));\n        int c[2] = {ccw(line.first, line.second, v[0][i]), ccw(line.first, line.second, v[1][j])};\n        bool res = true;\n        for(int l=0;l<2;l++){\n          for(int l2=0;l2<n[l];l2++){\n            if(ccw(line.first, line.second, v[l][l2]) != c[l]){\n              res = false;\n              break;\n            }\n          }\n          if(!res) break;\n        }\n        if(res) return true;\n      }\n    }\n  }\n  return false;\n}\n\nint main(){\n  double x, y;\n  while(cin >> n[0] >> n[1] && (n[0]|n[1])){\n    for(int i=0;i<2;i++){\n      v[i].clear();\n      for(int j=0;j<n[i];j++){\n        cin >> x >> y;\n        v[i].push_back(P(x, y));\n      }\n    }\n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a; i<(int)b; i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef complex<double> P;\n\nnamespace std {\n  bool operator < (P const& a, P const& b) {\n    if(real(a) != real(b)) return real(a) < real(b);\n    return imag(a) < imag(b);\n  }\n}\n\ndouble const EPS = 1e-8;\n\n#define prev(G, i) ( G[((i-1)+G.size())%G.size()] )\n#define curr(G, i) ( G[i%G.size()] )\n#define next(G, i) ( G[(i+1)%G.size()] )\n\ndouble dot(P const& a, P const& b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(P const& a, P const& b) {\n  return imag(conj(a)*b);\n}\n\ntypedef vector<P> Polygon;\n\nenum { counter_clock_wise=+1, clockwise=-1, cab_online=+2, abc_online=-2, on_segment = 0 };\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if(cross(b, c) > 0) return counter_clock_wise;\n  if(cross(b, c) < 0) return clockwise;\n  if(dot(b, c) < 0) return cab_online;\n  if(norm(b) < norm(c)) return abc_online;\n  return on_segment;\n}\n\nPolygon convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nstruct Line : public vector<P>\n{\n  Line(P const& a, P const& b) {\n    push_back(a), push_back(b);\n  }\n};\n\ntypedef Line Segment;\n\nbool is_intersect_ss(Segment const& s, Segment const& t) {\n  return ( ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) < EPS )\n    && ( ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) < EPS );\n}\n\n// contain: 2, on segment: 1, the other case: 0\nint contains(Polygon const& G, P const& p) {\n  bool x = false;\n  for(int i=0; i<(int)G.size(); i++) {\n    P v1 = curr(G, i)-p, v2 = next(G, i) - p;\n    if( v1.imag() > v2.imag() ) swap(v1, v2);\n    if( v1.imag() <= 0 && 0 < v2.imag() && cross(v1, v2) > 0 ) x = !x;\n    if( cross(v1, v2) == 0 && dot(v1, v2) <= 0 ) return 1;\n  }\n  return (x?2:0);\n}\n\nint main() {\n\n  int N, M;\n  while(cin >> N >> M && (N|M)) {\n    Polygon G1(N), G2(M);\n    rep(i, N) cin >> G1[i].real() >> G1[i].imag(); \n    rep(i, M) cin >> G2[i].real() >> G2[i].imag(); \n    \n    G1 = convex_hull(G1); N = G1.size();\n    G2 = convex_hull(G2); M = G2.size();\n    //    cout << \"convex hull\\n\";\n    bool ok = (!contains(G1, G2[0])) && (!contains(G2, G1[0]));\n    rep(i, N) {\n      rep(j, M) {\n\tSegment s1 = Segment(curr(G1, i), next(G1, i));\n\tSegment s2 = Segment(curr(G2, j), next(G2, j));\n\tif(is_intersect_ss(s1, s2)) { ok = 0; }\n      }\n    }\n    \n    cout << (ok ? \"YES\\n\" : \"NO\\n\");\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define EPS (1e-8)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\n\nclass Point{\n    public:\n    double x, y;\n    \n    Point ( double x = 0, double y = 0): x(x), y(y){}\n    \n    Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n    Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n    Point operator * ( double a ){ return Point(x*a, y*a); }\n    Point operator / ( double a ){ return Point(x/a, y/a); }\n\n    double abs() { return sqrt(norm());}\n    double norm() { return x*x + y*y; }\n\n    bool operator < ( const Point &p ) const {\n\treturn x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == ( const Point &p ) const {\n\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\nclass Segment{\n    public:\n    Point p1, p2;\n    Segment(Point s = Point(), Point t = Point()): p1(s), p2(t){}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\n\nbool isOnSegment( Point a, Point b, Point c){\n    if ( a == c || b == c ) return true;\n    return (abs(a-c) + abs(c-b) < abs(a-b) + EPS );\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n    return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t     ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\nbool isIntersect(Segment s1, Segment s2){\n    return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPolygon andrewScan( Polygon s ){\n    Polygon u, l;\n    if ( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n    int n;\n    for ( int i = 2; i < s.size(); i++ ){\n\tu.push_back(s[i]);\n\tfor ( int n = u.size(); n >= 3 && ccw(u[n-3], u[n-2], u[n-1]) != CLOCKWISE; n--){\n\t    u.erase(u.begin()+(n-2));\n\t}\n    }\n\n    for ( int i = s.size()-3; i >= 0; i-- ){\n\tl.push_back(s[i]);\n\tfor ( int n = l.size(); n >= 3 && ccw(l[n-3], l[n-2], l[n-1]) != CLOCKWISE; n--){\n\t    l.erase(l.begin()+(n-2));\n\t}\n\n    }\n    reverse(l.begin(), l.end());\n    for ( int i = u.size()-2; i >= 1; i-- ) l.push_back(u[i]);\n    return l;\n}\n\n// convec polygon with conter clockwise\nbool isInside(Polygon pol, Point p){\n    for ( int i = 0; i < pol.size(); i++ ){\n      if ( ccw(pol[i], pol[(i+1)%pol.size()], p) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\nbool check(int n, int m, Polygon b, Polygon w){\n  b = andrewScan(b);\n  w = andrewScan(w);\n  \n    int t = b.size() + w.size();\n    if ( t == 2 ) {\n      return false;\n    } else if ( t == 3 ){\n      if ( b.size() == 1 ) return isOnSegment(w[0], w[1], b[0] );\n      return isOnSegment(b[0], b[1], w[0]);\n    } else if ( t == 4 ){\n      if ( b.size() == 1 ) return isInside(w, b[0]);\n      else if ( w.size() == 1 ) return isInside(b, w[0]);\n      else return isIntersect(Segment(w[0], w[1]), Segment(b[0], b[1]));\n    }\n    \n    for ( int i = 0; i < b.size(); i++ )\n      if ( isInside(w, b[i]) ) return true;\n    for ( int i = 0; i < w.size(); i++ )\n      if ( isInside(b, w[i]) ) return true;\n    for ( int i = 0; i < b.size(); i++ ){\n      Segment s1 = Segment(b[i], b[(i+1)%b.size()]);\n      for ( int j = 0; j < w.size(); j++ ){\n\tSegment s2 = Segment(w[j], w[(j+1)%w.size()]);\n\tif ( isIntersect(s1, s2) ) return true;\n      }\n    }\n    return false;\n}\n\nint main(){\n  int n, m;\n  double x, y;\n  while(1){\n    cin >> n >> m;\n    if ( n == 0 && m == 0 ) break;\n    Polygon b, w;\n    for ( int i = 0; i < n; i++ ){\n      cin >> x >> y; b.push_back(Point(x, y));\n    }\n    for ( int i = 0; i < m; i++ ){\n      cin >> x >> y; w.push_back(Point(x, y));\n    }\n    if ( check(n, m, b, w) ) cout << \"NO\" << endl;\n    else cout << \"YES\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\n#include<complex>\n#include<vector>\n#include<stdlib.h>\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nusing namespace std;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\ntypedef P point;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nvector<point> convex_hull(vector<point> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\nenum { OUT, ON, IN };\nint contains(const vector<point>& P, const point& p) {\n  bool in = false;\n  for (int i = 0; i < P.size(); ++i) {\n    point a = curr(P,i) - p, b = next(P,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nint x[200];\nint y[200];\nP wolf[200];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a+b){\n\t\tfor(int i=0;i<a;i++)scanf(\"%d%d\",x+i,y+i);\n\t\tfor(int i=0;i<b;i++)scanf(\"%d%d\",x+a+i,y+a+i);\n\t\tbool ok=true;\n\t\tint n=a+b;\n\t\tfor(int i=0;i<n;i++)wolf[i]=P(x[i],y[i]);\n\t\tvector<point>A;\n\t\tvector<point>B;\n\t\tfor(int i=0;i<a;i++)A.push_back(wolf[i]);\n\t\tfor(int i=0;i<b;i++)B.push_back(wolf[a+i]);\n\t\tA=convex_hull(A);\n\t\tB=convex_hull(B);\n\t\tif(contains(A,B[0]))ok=false;\n\t\tif(contains(B,A[0]))ok=false;\n\t\tfor(int i=0;i<A.size();i++)\n\t\t\tfor(int j=0;j<B.size();j++)\n\t\t\t\tif(intersectSS(L(curr(A,i),next(A,i)),L(curr(B,j),next(B,j))))ok=false;\n\t\tif(ok)printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define EPS 0.00001\ntypedef long double ld;\n\n//FILE *in = freopen(\"input.txt\", \"r\", stdin);\n\nstruct P {\n\tld x, y;\n\tP(ld x, ld y):x(x),y(y){}\n\tP(){}\n};\n\nP operator -(const P &a, const P &b) { return P(a.x-b.x, a.y-b.y); }\nbool operator <(const P &a, const P &b){ return make_pair(a.x, a.y) < make_pair(b.x, b.y); }\n\nld cross(const P &a, const P &b) { return a.x*b.y-a.y*b.x; }\nld dot(const P &a, const P &b) { return a.x*b.x+a.y*b.y; }\nld norm(const P &a) { return dot(a,a); }\nint ccw(P a, P b, P c) {\n\tb = b - a; c = c - a;\n\tif(cross(b,c) > EPS) return 1;\n\tif(cross(b,c) < EPS) return -1;\n\tif(dot(b,c) < 0) return 2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nstruct L:vector<P>{\n\tL(P a=P(0,0), P b=P(0,0)) {\n\t\tthis->push_back(a);\n\t\tthis->push_back(b);\n\t}\n};\n\nbool is_intersect_SS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0],s[1],t[1]) <= 0 &&\n\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\n\nvector<P> convex_hull(vector<P> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<P> ch(2*n);\n\tfor(int i = 0; i < n; ch[k++]=ps[i++])\n\t\twhile(k >= 2 && ccw(ch[k-2],ch[k-1],ps[i]) <= 0)--k;\n\tfor(int i = n-2, t = k+1; i >= 0; ch[k++]=ps[i--])\n\t\twhile(k>=t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0)--k;\n\tif(k>=2)ch.resize(k-1);\n\treturn ch;\n}\n\nint n, m;\nvector<P> black;\nvector<P> white;\n\nvoid input() {\n\tblack.clear();\n\twhite.clear();\n\trep(i, n) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tblack.push_back(P(x,y));\n\t}\n\trep(i, m) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\twhite.push_back(P(x,y));\n\t}\n}\n\nvoid process() {\n\tblack = convex_hull(black);\n\twhite = convex_hull(white);\n\twhite.push_back(white[0]);\n\n\t// Check LP\n\trep(i,black.size()) {\n\t\tL x(black[i], P(black[i].x+1,black[i].y+10001));\n\t\tint cnt = 0;\n\t\trep(j,white.size()-1) {\n\t\t\tL y(white[j], white[j+1]);\n\t\t\tcnt += is_intersect_SS(x,y);\n\t\t}\n\t\tif(cnt%2 == 1) {\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tblack.push_back(black[0]);\n\n\t// Check cross LL\n\trep(i,black.size()-1) {\n\t\tL x(black[i],black[i+1]);\n\t\trep(j,white.size()-1){\n\t\t\tL y(white[j], white[j+1]);\n\t\t\tif(is_intersect_SS(x,y)) {\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"YES\\n\");\n}\n\nvoid output() {\n}\n\nint main() {\n\twhile(true) {\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(!n) break;\n\t\tinput();\n\t\tprocess();\n\t\toutput();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n    \nnamespace Geometry{\n    using namespace std;\n    using ld=long double;\n    using Point=complex<ld>;\n\n    struct Line{\n        Point a,b;\n    };\n\n    struct Circle{\n        Point p;\n        ld r;\n    };\n    const ld EPS=1e-9;\n    inline bool EQ(Point a,Point b){return abs(a-b)<EPS;}\n    ld dot(Point a,Point b){return real(a)*real(b)+imag(a)*imag(b);}\n    ld cross(Point a,Point b){return real(a)*imag(b)-imag(a)*real(b);}\n\n    const int CCW=1;\n    const int CW=-1;\n    const int BAC=2;\n    const int ACB=-2;\n    const int ABC=0;\n    int ccw(Point a,Point b,Point c){\n        b-=a,c-=a;\n        if(cross(b,c)>EPS) return CCW; // counter clockwise\n        if(cross(b,c)<-EPS) return CW; //clockwise\n        if(dot(b,c)<-EPS) return BAC; //b-a-c\n        if(abs(b)<abs(c)) return ACB; //a-c-b\n        return ABC; //a-b-c (abs(b)>abs(c))\n    }\n        bool isis_ss(Line x,Line y){\n        return ccw(x.a,x.b,y.a)*ccw(x.a,x.b,y.b)<=0 && ccw(y.a,y.b,x.a)*ccw(y.a,y.b,x.b)<=0;\n    }\n\n     vector<Point> convexFull(const vector<Point>& ps){\n        int n=ps.size();\n        if(n<=1) return ps;\n        auto cmp=[](const Point &lhs,const Point &rhs){\n            return lhs.real()==rhs.real() ? lhs.imag()<rhs.imag() : lhs.real()<rhs.real();\n        };\n        auto ps2=ps;\n        sort(ps2.begin(),ps2.end(),cmp);\n        int k=0;\n        vector<Point> qs(n*2);\n        for(int i=0;i<n;i++){\n            while(k>=2 && ccw(qs[k-2],qs[k-1],ps2[i])<=0) --k;\n            qs[k++]=ps2[i];\n        }\n        int t=k;\n        for(int i=n-2;i>=0;i--){\n            while(k>t && ccw(qs[k-2],qs[k-1],ps2[i])<=0) --k;\n            qs[k++]=ps2[i];\n        }\n        qs.resize(k-1);\n        return qs;\n    }\n\n    bool isis_sp(Line x,Point p){\n        return abs(x.a-p)+abs(x.b-p)-abs(x.a-x.b)<EPS;\n    }\n    using Polygon=vector<Point>;\n    const int OUT=0;\n    const int ON=1;\n    const int IN=2;\n    int is_in_polygon(const Polygon &poly,Point p){\n        ld angle=0;\n        int n=poly.size();\n        for(int i=0;i<n;i++){\n            Point a=poly[i],b=poly[(i+1)%n];\n            if(isis_sp(Line{a,b},p)) return ON;\n            angle+=arg((b-p)/(a-p));\n        }\n        if(abs(angle)<EPS) return OUT;\n        return IN;\n    }\n}\n\nusing namespace Geometry;\nbool solve(int n,int m){\n    \n    vector<Point> ws(n),bs(m);\n    for(int i=0;i<n;i++){\n        ld x,y;\n        cin>>x>>y;\n        ws[i]=Point{x,y};\n    }\n    for(int i=0;i<m;i++){\n        ld x,y;\n        cin>>x>>y;\n        bs[i]=Point{x,y};\n    }\n    \n    bool res=true;    \n    auto wcs=convexFull(ws);\n    auto bcs=convexFull(bs);\n    \n    for(int i=0;i<wcs.size();i++){\n        res&=(is_in_polygon(bcs,wcs[i])==OUT);\n    }\n    \n    for(int i=0;i<bcs.size();i++){\n        res&=(is_in_polygon(wcs,bcs[i])==OUT);\n    }\n\n    \n    vector<Line> wl(wcs.size());\n    for(int i=0;i<wcs.size();i++){\n        wl[i]=Line{wcs[i],wcs[(i+1)%wcs.size()]};\n    }\n    vector<Line> bl(bcs.size());\n    for(int i=0;i<bcs.size();i++){\n        bl[i]=Line{bcs[i],bcs[(i+1)%bcs.size()]};\n    }\n    \n    for(int i=0;i<wl.size();i++){\n        for(int j=0;j<bl.size();j++){\n            res&=!(isis_ss(wl[i],bl[j]));\n        }\n    }\n    return res;\n\n}\nint main(){\n    int n,m;\n    while(cin>>n>>m,!(n==0 && m==0)){\n        cout<<(solve(n,m) ? \"YES\" : \"NO\")<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef ___STD_GEOMETRY\n#define ___STD_GEOMETRY\n\n#include <cmath>\n\n#define EPS 1e-13L\n\n#endif\n\n#ifndef ___Class_Point\n#define ___Class_Point\n\nclass Point\n{\npublic:\n\n\t// ------ Variable ------ //\n\n\tlong double x, y;\n\n\n\t// ------ Constructor ------ //\n\n\tPoint() : x(0), y(0) { }\n\n\texplicit Point(long double x, long double y) : x(x), y(y) { }\n\n\n\t// ------ Operator ------ //\n\n\tfriend bool operator==(Point& p1, Point& p2) { return p1.x == p2.x && p1.y == p2.y; }\n\tfriend bool operator!=(Point& p1, Point& p2) { return p1.x != p2.x || p1.y != p2.y; }\n};\n\nlong double distance(const Point& p1, const Point& p2)\n{\n\treturn sqrtl((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));\n}\n\n#endif\n\n#ifndef ___Class_Vector\n#define ___Class_Vector\n\nclass Vector\n{\npublic:\n\n\t// ------ Variable ------ //\n\n\tlong double x, y;\n\n\n\t// ------ Constructor ------ //\n\n\tVector() : x(0), y(0) { }\n\n\texplicit Vector(long double x, long double y) : x(x), y(y) { }\n\n\texplicit Vector(Point p1, Point p2) : x(p2.x - p1.x), y(p2.y - p1.y) { }\n\n\texplicit Vector(long double sx, long double tx, long double sy, long double ty) : x(tx - sx), y(ty - sy) { }\n\n\n\t// ------ Operator ------ //\n\n\tVector operator+() const { return Vector(+x, +y); }\n\tVector operator-() const { return Vector(-x, -y); }\n\n\tVector& operator+=(const Vector& v) { x += v.x; y += v.y; return *this; }\n\tVector& operator-=(const Vector& v) { x -= v.x; y -= v.y; return *this; }\n\n\tfriend bool operator==(const Vector& v1, const Vector& v2) { return -EPS < v1.x - v2.x && v1.x - v2.x < EPS && -EPS < v1.y - v2.y && v1.y - v2.y < EPS; }\n\tfriend bool operator!=(const Vector& v1, const Vector& v2) { return !(v1 == v2); }\n\n\tfriend Vector operator+(const Vector& v1, const Vector& v2) { return Vector(v1.x + v2.x, v1.y + v2.y); }\n\tfriend Vector operator-(const Vector& v1, const Vector& v2) { return Vector(v1.x - v2.x, v1.y - v2.y); }\n\n\tfriend Vector operator*(double d, const Vector& v) { return Vector(d * v.x, d * v.y); }\n\tfriend Vector operator*(const Vector& v, double d) { return Vector(d * v.x, d * v.y); }\n\tfriend Vector operator/(const Vector& v, double d) { return Vector(v.x / d, v.y / d); }\n\n\n\t// ------ Function ------ //\n\n\tlong double norm() { return x * x + y * y; }\n\n\tlong double abs() { return sqrtl(x * x + y * y); }\n\n\tlong double angle() { return atan2l(y, x); }\n};\n\nlong double angle(const Vector& v1, const Vector& v2)\n{\n\tlong double A = atan2l(v2.y, v2.x) - atan2l(v1.y, v1.x);\n\n\tif (180.0L - EPS < A && A < 180.0L + EPS) { return 180.0L; }\n\n\tif (-180.0L - EPS < A && A < -180.0L + EPS) { return 180.0L; }\n\n\tif (A > 180.0L - EPS) { return A - 360.0L; }\n\n\tif (A < -180.0L + EPS) { return A + 360.0L; }\n\n\treturn A;\n}\n\nlong double norm(const Vector& v1)\n{\n\treturn v1.x * v1.x + v1.y * v1.y;\n}\n\nlong double abs(const Vector& v1)\n{\n\treturn sqrt(norm(v1));\n}\n\nlong double cross(const Vector& v1, const Vector& v2)\n{\n\treturn v1.x * v2.y - v1.y * v2.x;\n}\n\nlong double dot(const Vector& v1, const Vector& v2)\n{\n\treturn v1.x * v2.x + v1.y * v2.y;\n}\n\nlong double distance(const Vector& v1, const Vector& v2)\n{\n\treturn sqrtl((v2.x - v1.x) * (v2.x - v1.x) + (v2.y - v1.y) * (v2.y - v1.y));\n}\n\n#endif\n\nbool Triangle_Inside(Vector Tp1, Vector Tp2, Vector Tp3, Vector p) // Triangle is Counter-Clockwise\n{\n\tbool ok1 = !(angle(p - Tp1, Tp2 - Tp1) < 0 ^ angle(Tp2 - Tp1, p - Tp1) < angle(Tp2 - Tp1, Tp3 - Tp1));\n\tbool ok2 = !(angle(p - Tp2, Tp3 - Tp2) < 0 ^ angle(Tp3 - Tp2, p - Tp2) < angle(Tp3 - Tp2, Tp1 - Tp2));\n\tbool ok3 = !(angle(p - Tp3, Tp1 - Tp3) < 0 ^ angle(Tp1 - Tp3, p - Tp3) < angle(Tp1 - Tp3, Tp2 - Tp3));\n\n\treturn ok1 && ok2 && ok3;\n}\n\nbool On_Segment(Vector Sp1, Vector Sp2, Vector p)\n{\n\treturn (Sp1 + Sp2) / 2 == p;\n}\n\nint Counter_Clockwise(Vector p1, Vector p2, Vector p3)\n{\n\tVector a = p2 - p1;\n\tVector b = p3 - p1;\n\n\tif (cross(a, b) > EPS) { return 1; }\n\tif (cross(a, b) < -EPS) { return -1; }\n\n\tif (dot(a, b) < -EPS) { return 2; }\n\n\tif (a.norm() < b.norm()) { return -2; }\n\n\treturn 0;\n}\n\nbool Intersection(Vector p1, Vector p2, Vector p3, Vector p4)\n{\n\tint ok1 = Counter_Clockwise(p1, p2, p3) * Counter_Clockwise(p1, p2, p4);\n\tint ok2 = Counter_Clockwise(p3, p4, p1) * Counter_Clockwise(p3, p4, p2);\n\n\treturn ok1 <= 0 && ok2 <= 0;\n}\n\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tint N, M, X, Y;\n\n\twhile (true)\n\t{\n\t\tcin >> N >> M;\n\n\t\tif (N == 0 && M == 0) { break; }\n\n\t\tvector<Vector> W(N);\n\t\tvector<Vector> B(M);\n\n\t\tfor (int i = 0; i < N; i++) { cin >> X >> Y; W[i] = Vector(X, Y); }\n\t\tfor (int i = 0; i < M; i++) { cin >> X >> Y; B[i] = Vector(X, Y); }\n\n\t\tbool ok = true;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < M; k++)\n\t\t\t\t{\n\t\t\t\t\tif (On_Segment(W[i], W[j], B[k]) == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < M; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < M; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t\t{\n\t\t\t\t\tif (On_Segment(B[i], B[j], W[k]) == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ok == true)\n\t\t{\n\t\t\tif (N > 2 || M > 2)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int k = j + 1; k < N; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int l = 0; l < M; l++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (Triangle_Inside(W[i], W[j], W[k], B[l]))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tok = false; goto Exit;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < M; i++)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = i + 1; j < M; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int k = j + 1; k < M; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int l = 0; l < N; l++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (Triangle_Inside(B[i], B[j], B[k], W[l]))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tok = false; goto Exit;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (N == 2 && M == 2)\n\t\t\t{\n\t\t\t\tok = (Intersection(W[0], W[1], B[0], B[1]) == true ? false : true);\n\t\t\t}\n\t\t}\n\n\tExit:;\n\n\t\tcout << (ok == true ? \"YES\" : \"NO\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\n\nconst double EPS = 1e-8;\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\n// ???????????? a,b ???????????¢???\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\n// ????????¨?????????????????????????????????????????????true???\nbool isIntersect(L s1, L s2){\n  \n  //ccw ??????????????????????????¨, ????????????????????´?????????????????¨??????????????????????????????\n  if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\n// ????????¨??????????????????\nbool isIntersectSP(L s, P p){ \n  return abs(s.first-p) + abs(s.second-p) - abs(s.second-s.first) < EPS; \n}\n\nvector<P> convex_hull2(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nint main(){\n  \n  while(1){\n    \n    int n,m;\n    cin>>n>>m;\n    if(!n&&!m)break;\n  \n    vector<P> B(n),W(m);\n  \n    int x,y;\n  \n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      B[i]=P(x,y);\n    }\n\n    for(int i=0;i<m;i++){\n      cin>>x>>y;\n      W[i]=P(x,y);\n    }\n\n    bool ans=true;\n    \n    /*    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tif(i==j) continue;\n\t\n\tfor(int k=0;k<m;k++)\n\t  for(int l=0;l<m;l++){\n\t    if(k==l) continue;\n\t    \n\t    if(isIntersect(L(B[i],B[j]),L(W[k],W[l]))) ans=false;\n\t    \n\t  }\n\t  }*/\n\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tif(i==j) continue;\n\n\tfor(int k=0;k<m;k++)\n\t  if(isIntersectSP(L(B[i],B[j]),W[k])) ans=false;\n      }\n\n    for(int i=0;i<m;i++)\n      for(int j=0;j<m;j++){\n\tif(i==j) continue;\n\n\tfor(int k=0;k<n;k++)\n\t  if(isIntersectSP(L(W[i],W[j]),B[k])) ans=false;\n      }\n\n\n\n    vector<P> B2=convex_hull2(B);\n\n    int f=0,v,flag=1;\n      \n    for(int i=0;i<B2.size();i++){\n      for(int j=0;j<W.size();j++){\n\tint ip=(i+1)%B2.size();\n\tif(!f)v=ccw(B2[i],B2[ip],W[j]),f=1;\n\telse if(v!=ccw(B2[i],B2[ip],W[j])) flag=0;\n\t//\tcout<<ccw(B2[i],B2[ip],W[j])<<endl;\n      }\n    }\n    \n    if(B2.size()>=3&&flag) ans=false;\n    \n    vector<P> W2=convex_hull2(W);\n    \n    f=0;\n    flag=1;\n\n    for(int i=0;i<W2.size();i++){\n      for(int j=0;j<B.size();j++){\n\tint ip=(i+1)%W2.size();\n\tif(!f)v=ccw(W2[i],W2[ip],B[j]),f=1;\n\telse if(v!=ccw(W2[i],W2[ip],B[j])) flag=0;\n\t//\tcout<<ccw(W2[i],W2[ip],B[j])<<endl;\n      }\n    }\n    \n    if(W2.size()>=3&&flag) ans=false;\n    \n    if(ans) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n      \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing ld = long double;\nusing Point = std::complex<ld>;\nusing P = pair<int, int>;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std\n{\nbool operator<(const Point &lhs, const Point &rhs)\n{\n    if (lhs.real() < rhs.real() - eps)\n        return true;\n    if (lhs.real() > rhs.real() + eps)\n        return false;\n    return lhs.imag() < rhs.imag();\n}\n} // namespace std\n\nPoint input_point()\n{\n    ld x, y;\n    std::cin >> x >> y;\n    return Point(x, y);\n}\n\nbool eq(ld a, ld b)\n{\n    return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b)\n{\n    return real(conj(a) * b);\n}\n\nld cross(Point a, Point b)\n{\n    return imag(conj(a) * b);\n}\n\n// CCW::counter clockwise\nint ccw(Point a, Point b, Point c)\n{\n    b -= a;\n    c -= a;\n    if (cross(b, c) > eps)\n        return 2; // a,b,c : counter-clockwise\n    if (cross(b, c) < -eps)\n        return 0; // a,b,c : clockwise\n    return 1;\n}\n\nclass Line\n{\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n};\n\nld dot(Line l, Line m)\n{\n    return dot((l.a - l.b), (m.a - m.b));\n}\n\n// l, m が交点を持つか\nbool isis_ll(Line l, Line m)\n{\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// s : segment\nbool isis_ls(Line l, Line s)\n{\n    return isis_ll(l, s) &&\n           (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t)\n{\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n           ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// p が l 上に存在するか\nbool isis_lp(Line l, Point p)\n{\n    return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m;\n    while (cin >> n >> m, n || m)\n    {\n        vector<Point> bs(n), ws(m);\n        for (int i = 0; i < n; i++)\n        {\n            bs[i] = input_point();\n        }\n        for (int i = 0; i < m; i++)\n        {\n            ws[i] = input_point();\n        }\n        if (n == 1 && m == 1)\n        {\n            cout << \"YES\" << endl;\n            continue;\n        }\n        bool line = true;\n        for (int i = 0; i < n; i++)\n            if (!isis_lp(Line(bs[0], ws[0]), bs[i]))\n                line = false;\n        for (int i = 0; i < m; i++)\n            if (!isis_lp(Line(bs[0], ws[0]), ws[i]))\n                line = false;\n        if (line)\n        {\n            vector<P> ps;\n            for (int i = 0; i < n; i++)\n                ps.push_back(P(bs[i].real(), 0));\n            for (int i = 0; i < m; i++)\n                ps.push_back(P(ws[i].real(), 1));\n            sort(ps.begin(), ps.end());\n            int cnt = 0;\n            for (int i = 0; i < n + m; i++)\n                if (ps[i].second != ps[i - 1].second)\n                    cnt++;\n            cout << (cnt <= 1 ? \"YES\" : \"NO\") << endl;\n            continue;\n        }\n        bool f = false;\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = i + 1; j < n; j++)\n            {\n                bool tmp = true;\n                int bf = 0, wf = 0;\n                for (int k = 0; k < n; k++)\n                {\n                    bf |= (1 << ccw(bs[i], bs[j], bs[k]));\n                }\n                if ((bf & 4) && (bf & 1))\n                    continue;\n                for (int k = 0; k < m; k++)\n                {\n                    wf |= (1 << ccw(bs[i], bs[j], ws[k]));\n                }\n                if ((wf & 4) && (wf & 1))\n                    continue;\n                for (int k = 0; k < 3; k++)\n                {\n                    if (((bf >> k) & 1) & ((wf >> k) & 1))\n                        tmp = false;\n                }\n                if (tmp)\n                    f = true;\n            }\n        }\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = i + 1; j < m; j++)\n            {\n                bool tmp = true;\n                int bf = 0, wf = 0;\n                for (int k = 0; k < n; k++)\n                {\n                    bf |= (1 << ccw(ws[i], ws[j], bs[k]));\n                }\n                if ((bf & 4) && (bf & 1))\n                    continue;\n                for (int k = 0; k < m; k++)\n                {\n                    wf |= (1 << ccw(ws[i], ws[j], ws[k]));\n                }\n                if ((wf & 4) && (wf & 1))\n                    continue;\n                for (int k = 0; k < 3; k++)\n                {\n                    if (((bf >> k) & 1) & ((wf >> k) & 1))\n                        tmp = false;\n                }\n                if (tmp)\n                    f = true;\n            }\n        }\n        cout << (f ? \"YES\" : \"NO\") << '\\n';\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tvector<Polygon>polys;\n\tpolys.push_back(Q);\n\tpolys.push_back(R);\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\n#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\n\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<Point>wps, bps;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tPoint wp(input_point());\n\t\t\twps.push_back(wp);\n\t\t}\n\t\tfor (int i = 0; i <M; ++i) {\n\t\t\tPoint bp(input_point());\n\t\t\tbps.push_back(bp);\n\t\t}\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tLine wl(wps[i], wps[j]);\n\t\t\t\tfor (int k = 0; k < M; ++k) {\n\t\t\t\t\tif (isis_sp(wl, bps[k]))ok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tfor (int j = i + 1; j < M; ++j) {\n\t\t\t\tLine bl(bps[i], bps[j]);\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tif (isis_sp(bl, wps[k]))ok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tPolygon bpoly(convex_hull(bps));\n\t\tPolygon wpoly(convex_hull(wps));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (is_in_polygon(bpoly, wps[i]))ok = false;\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (is_in_polygon(wpoly, bps[i]))ok = false;\n\t\t}\n\t\tfor (int i = 0; i < wpoly.size(); ++i) {\n\t\t\tLine wl(wpoly[i], wpoly[(i + 1)% wpoly.size()]);\n\t\t\tfor (int j = 0; j < bpoly.size(); ++j) {\n\t\t\t\tLine bl(bpoly[j], bpoly[(j + 1) % bpoly.size()]);\n\t\t\t\tif (isis_ss(wl, bl))ok = false;\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\n#include <complex>\ntypedef complex<double> P;\n#define EQ(x, y) (abs((x)-(y)) < EPS)\ndouble dot(P a, P b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\ndouble cross(P a, P b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\nint is_point_on_line(P a, P b, P c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nint is_intersected_l_ls(P a1, P a2, P b1, P b2) {\n    if ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < -EPS )\n        return true;\n    return is_point_on_line(a1, a2, b1) || is_point_on_line(a1, a2, b2);\n}\nint is_point_on_ls(P a, P b, P c) {\n    // |a-c| + |c-b| <= |a-b| then true\n    return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n\n\ntypedef vector<P> vp;\n\nbool can_separate(int edge1,int edge2,int parent_o,int parent_t,vp &ours,vp &theirs){\n\tif(parent_o!=-1){\n\t\tif(!is_intersected_l_ls(ours[edge1],ours[edge2],ours[parent_o],theirs[parent_t])){\n\t\t\treturn false;\n\t\t}\n\t}\n\tif(parent_o!=-1){\n\t\tREP(i,ours.size()){\n\t\t\tif(i!=parent_o&&i!=edge1&&i!=edge2){\n\t\t\t\tif(is_intersected_l_ls(ours[edge1],ours[edge2],ours[i],ours[parent_o])){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,theirs.size()){\n\t\tif(i!=parent_t){\n\t\t\tif(is_intersected_l_ls(ours[edge1],ours[edge2],theirs[i],theirs[parent_t])){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n\t\tvp black,white;\n\t\tREP(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tblack.push_back(P(x,y));\n\t\t}\n\t\tREP(i,m){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\twhite.push_back(P(x,y));\n\t\t}\n\n\t\tbool ok=false;\n\t\tbool all_on_line=true;\n\t\tbool scrumbled=false;\n\t\tif(n==1&&m==1){\n\t\t\tok=true;\n\t\t\tgoto show;\n\t\t}else if(n==2&&m==1){\n\t\t\tok=!is_point_on_ls(black[0],black[1],white[0]);\n\t\t\tgoto show;\n\t\t}else if(n==1&&m==2){\n\t\t\tok=!is_point_on_ls(white[0],white[1],black[0]);\n\t\t\tgoto show;\n\t\t}\n\n\t\tREP(i,n+m){\n\t\t\tP ip=(i<n?black[i]:white[i-n]);\n\t\t\tif(!is_point_on_line(black[0],white[0],ip)){\n\t\t\t\tall_on_line=false;\n\t\t\t}\n\t\t}\n\t\tREP(i,m){\n\t\t\tif(is_point_on_ls(black[0],black[0],white[i])){\n\t\t\t\tscrumbled=true;\n\t\t\t}\n\t\t}\n\t\tREP(i,n){\n\t\t\tif(is_point_on_ls(white[0],white[0],black[i])){\n\t\t\t\tscrumbled=true;\n\t\t\t}\n\t\t}\n\t\tif(all_on_line){\n\t\t\tok=!scrumbled;\n\t\t\tgoto show;\n\t\t}\n\n\t\tREP(i1,n){\n\t\t\tFOR(i2,i1+1,n){\n\t\t\t\tint parent_o=-1;\n\t\t\t\tREP(j,n){\n\t\t\t\t\tif(j!=i1&&j!=i2){\n\t\t\t\t\t\tparent_o=j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(can_separate(i1,i2,parent_o,0,black,white)){\n\t\t\t\t\tok=true;\n\t\t\t\t\tgoto show;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i1,m){\n\t\t\tFOR(i2,i1+1,m){\n\t\t\t\tint parent_o=-1;\n\t\t\t\tREP(j,m){\n\t\t\t\t\tif(j!=i1&&j!=i2){\n\t\t\t\t\t\tparent_o=j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(can_separate(i1,i2,parent_o,0,white,black)){\n\t\t\t\t\tok=true;\n\t\t\t\t\tgoto show;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nshow:\n\t\tcout<<(ok?\"YES\":\"NO\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\ntypedef struct node{int x,y;};\nint n,m;\nnode a[110];\ndouble s(int i,int j,int k)\n{\n    return fabs(a[i].x*a[j].y+a[k].x*a[i].y+a[j].x*a[k].y-a[k].x*a[j].y-a[i].x*a[k].y-a[j].x*a[i].y);\n}\nbool tepan(int i,int j,int k,int l)\n{\n    if(max(a[i].x,a[j].x)<min(a[k].x,a[l].x)||min(a[i].x,a[j].x)>max(a[k].x,a[l].x))return false;\n    else return true;\n}\nbool ok(int i,int j,int k, int l)\n{\n    int a=s(i,j,k),b=s(l,i,j),c=s(l,k,i),d=s(l,j,k);\n    if(a==0&&b==0&&c==0&&d==0)return tepan(i,j,k,l);\n    if(a==b+c+d)return true;\n    else return false;\n}\nbool xing(int i,int j,int k)\n{\n    if((a[k].y-a[i].y)*(a[k].x-a[j].x)!=(a[k].x-a[i].x)*(a[k].y-a[j].y))return false;\n    if(a[k].y>max(a[i].y,a[j].y)||a[k].y<min(a[i].y,a[j].y))return false;\n    return true;\n}\nint main()\n{\n    while(~scanf(\"%d%d\",&n,&m),n+m)\n    {\n        for(int i=0;i<m+n;i++)\n            scanf(\"%d%d\",&a[i].x,&a[i].y);\n        int flag=1;\n        for(int i=0;i<n;i++)\n            for(int j=i+1;j<n;j++)\n                for(int k=j+1;k<n;k++)\n                    for(int l=n;l<n+m;l++)\n                        if(ok(i,j,k,l)){flag=0;cout<<i<<' '<<j<<' '<<k<<' '<<l<<endl;break;}\n        if(m<3&&n<3){\n            if(m==1&&n==2){\n                if(xing(0,1,2)){flag=0;}\n            }\n            else if(m==2&&n==1){\n                if(xing(1,2,0)){flag=0;}\n            }\n            else if(m==2&&n==2){\n                a[4].x=2*a[0].x-a[1].x;\n                a[4].y=2*a[0].y-a[1].y;\n                a[5].x=2*a[1].x-a[0].x;\n                a[5].y=2*a[1].y-a[0].y;\n                if(ok(2,3,4,0)&&ok(2,3,5,1)){flag=0;}\n            }\n        }\n        if(flag)printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n    return 0;\n}\n\n/*\n3 3\n100 700\n200 200\n600 600\n500 100\n500 300\n800 500\n3 3\n100 300\n400 600\n400 100\n600 400\n500 900\n300 300\n3 4\n300 300\n500 300\n400 600\n100 100\n200 900\n500 900\n800 100\n1 2\n300 300\n100 100\n500 500\n1 1\n100 100\n200 100\n2 2\n0 0\n500 700\n1000 1400\n1500 2100\n2 2\n0 0\n1000 1000\n1000 0\n0 1000\n3 3\n0 100\n4999 102\n10000 103\n5001 102\n10000 102\n0 101\n3 3\n100 100\n200 100\n100 200\n0 0\n400 0\n0 400\n3 3\n2813 1640\n2583 2892\n2967 1916\n541 3562\n9298 3686\n7443 7921\n0 0\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// ------ Class ------ //\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tbool operator==(const Point& p) const { return px == p.px && py == p.py; }\n\tbool operator!=(const Point& p) const { return px != p.px || py != p.py; }\n\tbool operator<(const Point& p) const { return px < p.px ? true : (px == p.px && py < p.py); }\n\tbool operator>(const Point& p) const { return px > p.px ? true : (px == p.px && py > p.py); }\n\tbool operator<=(const Point& p) const { return !(Point(px, py) > p); }\n\tbool operator>=(const Point& p) const { return !(Point(px, py) < p); }\n\tPoint operator+(const Point& p) const { return Point(px + p.px, py + p.py); }\n\tPoint operator-(const Point& p) const { return Point(px - p.px, py - p.py); }\n\tPoint operator/(long double d) const { return Point(px / d, py / d); }\n\tfriend Point operator*(const Point p, long double d) { return Point(p.px * d, p.py * d); }\n\tfriend Point operator*(long double d, const Point& p) { return p * d; }\n\tPoint& operator+=(const Point& p1) { px += p1.px, py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px, py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d, py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d, py /= d; return *this; }\n};\n\n// ------ Functions ------ //\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint pol(long double r, long double d) { return Point(cosl(d) * r, sinl(d) * r); }\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nvector<Point> convex_hull(vector<Point> v) {\n\tif (v.size() < 3) return v;\n\tsort(v.begin(), v.end());\n\tvector<Point> u = { v[0], v[1] }, l = { v[v.size() - 1], v[v.size() - 2] };\n\tfor (int i = 2; i < v.size(); i++) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], v[i]) >= 0; n--) u.pop_back();\n\t\tu.push_back(v[i]);\n\t}\n\tfor (int i = v.size() - 3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], v[i]) >= 0; n--) l.pop_back();\n\t\tl.push_back(v[i]);\n\t}\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\n// ------ Main ------ //\nint n, m; vector<Point> v1, v2, v3, v4;\nbool ok(int i) {\n\tint u = (i + 1) % v3.size();\n\tfor (int j = 0; j < v4.size(); j++) {\n\t\tif (abs(ccw(v3[i], v3[u], v4[j])) != 1) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tfor (int j = 0; j < v3.size(); j++) {\n\t\tif (i == j || u == j) continue;\n\t\tfor (int k = 0; k < v4.size(); k++) {\n\t\t\tif (ccw(v3[i], v3[u], v3[j]) == ccw(v3[i], v3[u], v4[k])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < v4.size(); j++) {\n\t\tfor (int k = j + 1; k < v4.size(); k++) {\n\t\t\tif (ccw(v3[i], v3[u], v4[j]) != ccw(v3[i], v3[u], v4[k])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\twhile (cin >> n >> m, n + m) {\n\t\tv1.resize(n), v2.resize(m);\n\t\tfor (int i = 0; i < n; i++) cin >> v1[i].px >> v1[i].py;\n\t\tfor (int i = 0; i < m; i++) cin >> v2[i].px >> v2[i].py;\n\t\tv3 = convex_hull(v1), v4 = convex_hull(v2);\n\t\tint x = 0;\n\t\tif (v3.size() == 1 && v4.size() == 1) x = 1;\n\t\tif (v3.size() > 1) {\n\t\t\tint w = ccw(v3[0], v3[1], v4[0]);\n\t\t\tif (abs(w) != 2) break;\n\t\t\tint f = 1;\n\t\t\tfor (int i = 1; i < v4.size(); i++) {\n\t\t\t\tif (ccw(v3[0], v3[1], v4[i]) != x) f = 0;\n\t\t\t}\n\t\t\tif (f) x = 1;\n\t\t}\n\t\tif (v4.size() > 1) {\n\t\t\tint w = ccw(v4[0], v4[1], v3[0]);\n\t\t\tif (abs(w) != 2) break;\n\t\t\tint f = 1;\n\t\t\tfor (int i = 1; i < v3.size(); i++) {\n\t\t\t\tif (ccw(v4[0], v4[1], v3[i]) != x) f = 0;\n\t\t\t}\n\t\t\tif (f) x = 1;\n\t\t}\n\t\tfor (int i = 0; i < v3.size(); i++) {\n\t\t\tif (ok(i)) x = 1;\n\t\t}\n\t\tswap(v3, v4);\n\t\tfor (int i = 0; i < v4.size(); i++) {\n\t\t\tif (ok(i)) x = 1;\n\t\t}\n\t\tcout << (x ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\nlong double EPS = (long double)1e-7;\nstruct Point { long double px, py; };\nPoint r1[100], r2[100]; int n, m;\nvector<pair<Point, int>>vec, vec2;\ninline bool solve(Point a1, Point a2) {\n\tif (a1.px > a2.px)swap(a1, a2);\n\tif (a1.px == a2.px) {\n\t\tint colour = 0; bool r[3] = { false,false,false };\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tif (r[1] == true && r[2] == true)return false;\n\t\t\tif (colour == 0) {\n\t\t\t\tif (vec2[i].first.px < a1.px) { colour = 3 - vec2[i].second; }\n\t\t\t\telse if (vec2[i].first.px == a1.px) { r[vec2[i].second] = true; }\n\t\t\t\telse if (vec2[i].first.px > a1.px) { colour = vec2[i].second; }\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (colour != 3 - vec2[i].second && vec2[i].first.px < a1.px) { return false; }\n\t\t\t\telse if (vec2[i].first.px == a1.px) { r[vec2[i].second] = true; }\n\t\t\t\telse if (colour != vec2[i].second && vec2[i].first.px > a1.px) { return false; }\n\t\t\t}\n\t\t}\n\t\tif (r[1] == true && r[2] == true)return false;\n\t\treturn true;\n\t}\n\telse {\n\t\tlong double KT = (a2.py - a1.py) / (a2.px - a1.px);\n\t\tlong double YY = a1.py - a1.px*KT;\n\t\tint colour = 0; bool r[3] = { false,false,false };\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tif (r[1] == true && r[2] == true)return false;\n\t\t\tlong double height = YY + KT*vec2[i].first.px;\n\t\t\tif (colour == 0) {\n\t\t\t\tif (vec2[i].first.py < height) { colour = 3 - vec2[i].second; }\n\t\t\t\telse if (vec2[i].first.py == height) { r[vec2[i].second] = true; }\n\t\t\t\telse if (vec2[i].first.py > height) { colour = vec2[i].second; }\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (colour != 3 - vec2[i].second && vec2[i].first.py < height) { return false; }\n\t\t\t\telse if (vec2[i].first.py == height) { r[vec2[i].second] = true; }\n\t\t\t\telse if (colour != vec2[i].second && vec2[i].first.py > height) { return false; }\n\t\t\t}\n\t\t}\n\t\tif (r[1] == true && r[2] == true)return false;\n\t\treturn true;\n\t}\n}\nint main() {\n\twhile (true) {\n\t\tvec.clear(); vec2.clear(); cin >> n >> m; if (n == 0 && m == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> r1[i].px >> r1[i].py; vec2.push_back(make_pair(r1[i], 1));\n\t\t\tfor (long double j = -1.0l; j <= 1.0l; j += 1.0l) {\n\t\t\t\tfor (long double k = -1.0l; k <= 1.0l; k += 1.0l) {\n\t\t\t\t\tvec.push_back(make_pair(Point{ r1[i].px + j*EPS,r1[i].py + k*EPS }, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> r2[i].px >> r2[i].py; vec2.push_back(make_pair(r2[i], 2));\n\t\t\tfor (long double j = -1.0l; j <= 1.0l; j += 1.0l) {\n\t\t\t\tfor (long double k = -1.0l; k <= 1.0l; k += 1.0l) {\n\t\t\t\t\tvec.push_back(make_pair(Point{ r2[i].px + j*EPS,r2[i].py + k*EPS }, 2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans = false;\n\t\tfor (int i = 0; i < vec.size(); i++) {\n\t\t\tfor (int j = i + 1; j < vec.size(); j++) {\n\t\t\t\tif (fabs(vec[i].first.px - vec[j].first.px) + fabs(vec[i].first.py - vec[j].first.py) < EPS * 6)continue;\n\t\t\t\tbool p1 = solve(vec[i].first, vec[j].first);\n\t\t\t\tif (p1 == true) {\n\t\t\t\t\tans = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == true)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ndouble ax[100],ay[100],bx[100],by[100];\ndouble dx[4]={1e-6,0,-1e-6,0},dy[4]={0,1e-6,0,-1e-6},eps=1e-9;\nint N,M;\nbool solve(){\n\trep(i,N) cin>>ax[i]>>ay[i];\n\trep(i,M) cin>>bx[i]>>by[i];\n\trep(i,N) rep(j,M){\n\t\tdouble xx=ax[i]-bx[j],yy=ay[i]-by[j];\n\t\trep(d,4){\n\t\t\tdouble x=xx+dx[d],y=yy+dy[d];\n\t\t\tdouble amn=1e50,amx=-1e50,bmn=1e50,bmx=-1e50;\n\t\t\trep(k,N){\n\t\t\t\tdouble z=ay[k]*x-ax[k]*y;\n\t\t\t\tchmin(amn,z);\n\t\t\t\tchmax(amx,z);\n\t\t\t}\n\t\t\trep(k,M){\n\t\t\t\tdouble z=by[k]*x-bx[k]*y;\n\t\t\t\tchmin(bmn,z);\n\t\t\t\tchmax(bmx,z);\n\t\t\t}\n\t\t\tif(amx+eps<bmn||bmx+eps<amn) return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(true){\n\t\tcin>>N>>M;\n\t\tif(N==0) break;\n\t\tif(solve()) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<complex>\n#define Re real()\n#define Im imag()\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\ntypedef vector<Point> Polygon;\nconst double eps = 1e-10;\n\nPoint black[105], white[105];\nPolygon bp, wp;\nint n, m, bpl, wpl;\n\nbool cmp(Point a, Point b)\n{\n    if(fabs(a.Re - b.Re) < eps) return a.Im < b.Im;\n    else return a.Re < b.Re;\n}\n\ndouble cross(const Point& a, const Point& b)\n{\n    return (conj(a) * b).Im;\n}\n\ndouble dot(const Point& a, const Point& b)\n{\n    return (conj(a) * b).Re;\n}\n\nvoid convex_hull()\n{\n    bp.resize(2 * n);\n    bpl = 0;\n    for(int i = 0; i < n; i++)\n    {\n        while(bpl > 1 && cross(bp[bpl - 1] - bp[bpl - 2], black[i] - bp[bpl - 1]) < 0) bpl--;\n        bp[bpl++] = black[i];\n    }\n    for(int i = n - 2, t = bpl; i >= 0; i--)\n    {\n        while(bpl > t && cross(bp[bpl - 1] - bp[bpl - 2], black[i] - bp[bpl - 1]) < 0) bpl--;\n        bp[bpl++] = black[i];\n    }\n    bp.resize(bpl - 1);\n    wp.resize(2 * m);\n    wpl = 0;\n    for(int i = 0; i < m; i++)\n    {\n        while(wpl > 1 && cross(wp[wpl - 1] - wp[wpl - 2], white[i] - wp[wpl - 1]) < 0) wpl--;\n        wp[wpl++] = white[i];\n    }\n    for(int i = m - 2, t = wpl; i >= 0; i--)\n    {\n        while(wpl > t && cross(wp[wpl - 1] - wp[wpl - 2], white[i] - wp[wpl - 1]) < 0) wpl--;\n        wp[wpl++] = white[i];\n    }\n    wp.resize(wpl - 1);\n}\n\nint ccw(Point& a, Point& b, Point& c)\n{\n    Point t1 = b - a, t2 = c - a;\n    if(cross(t1, t2) > 0)   return +1;        // counter clockwise\n    if(cross(t1, t2) < 0)   return -1;        // clockwise\n    if(dot(t1, t2) < 0)     return +2;        // c--a--b on line\n    if(norm(t1) < norm(t2)) return -2;        // a--b--c on line\n    return 0;\n}\n\nbool is_point_intersaction(Point a, pair <Point, Point> b)\n{\n    return (fabs( dot(b.first - a, b.second - a) - (-1.0 * sqrt(norm(b.first - a) * norm(b.second - a))) < eps));\n}\n\n       bool isintersaction(pair <Point, Point> a, pair <Point, Point> b)\n{\n    return (ccw(b.first, b.second, a.first) * ccw(b.first, b.second, a.second) <= 0 && ccw(a.first, a.second, b.first) * ccw(a.first, a.second, b.second) <= 0);\n}\n\n// 0 --- out of the polygon, 1 -- on the polygon, 2 -- in the polygon\nint checkin(const Point& t, Polygon s)\n{\n    int cnt = 0;\n    for(int i = 0; i < s.size(); i++)\n    {\n        Vector v1 = s[i] - t, v2 = s[(i + 1) % s.size()] - t;\n        if(v1.Im > v2.Im) swap(v1, v2);\n        if(v1.Im <= 0 && v2.Im > 0 && cross(v1, v2) < 0) cnt ^= 1;\n        if(cross(v1, v2) == 0 && dot(v1, v2) <= 0) return 1;\n    }\n    return cnt ? 2 : 0;\n}\n\nbool check()\n{\n    int flag = 0, f1 = 0, f2 = 0, f3 = 0;\n    for(int i = 0; i < bp.size(); i++)\n        if(checkin(wp[i], bp) == 1 || checkin(wp[i], bp) == 2) f1 = 1;\n    for(int i = 0; i < wp.size(); i++)\n        if(checkin(bp[i], wp) == 1 || checkin(bp[i], wp) == 2) f2 = 1;\n    flag = f1 | f2;\n    if(flag == 0) return true;\n    else return false;\n}\n\nint main()\n{\n    while(~scanf(\"%d%d\", &n, &m), n + m)\n    {\n        for(int i = 0; i < n; i++)\n        {\n            double tx, ty;\n            scanf(\"%lf %lf\", &tx, &ty);\n            black[i] = Point(tx, ty);\n        }\n        for(int i = 0; i < m; i++)\n        {\n            double tx, ty;\n            scanf(\"%lf %lf\", &tx, &ty);\n            white[i] = Point(tx, ty);\n        }\n        if(n >= 3 && m >= 3)\n        {\n            convex_hull();\n            if(check()) printf(\"YES\\n\");\n            else printf(\"NO\\n\");\n        }\n        else if(n == 1 && m == 1)\n            printf(\"YES\\n\");\n        else if(n == 1 && m == 2)\n        {\n            bool flag = is_point_intersaction(black[0], make_pair(white[0], white[1]));\n            if(flag) printf(\"NO\\n\");\n            else printf(\"YES\\n\");\n        }\n        else if(n == 2 && m == 1)\n        {\n            bool flag = is_point_intersaction(white[0], make_pair(black[0], black[1]));\n            if(flag) printf(\"NO\\n\");\n            else printf(\"YES\\n\");\n        }\n        else if(n == 2 && m == 2)\n        {\n            bool flag = isintersaction(make_pair(white[0], white[1]), make_pair(black[0], black[1]));\n            if(flag) printf(\"NO\\n\");\n            else printf(\"YES\\n\");\n        }\n    }\n    return 0;\n}\n/*\n\n3 3\n100 700\n200 200\n600 600\n500 100\n500 300\n800 500\n3 3\n100 300\n400 600\n400 100\n600 400\n500 900\n300 300\n3 4\n300 300\n500 300\n400 600\n100 100\n200 900\n500 900\n800 100\n1 2\n300 300\n100 100\n500 500\n1 1\n100 100\n200 100\n2 2\n0 0\n500 700\n1000 1400\n1500 2100\n2 2\n0 0\n1000 1000\n1000 0\n0 1000\n3 3\n0 100\n4999 102\n10000 103\n5001 102\n10000 102\n0 101\n3 3\n100 100\n200 100\n100 200\n0 0\n400 0\n0 400\n3 3\n2813 1640\n2583 2892\n2967 1916\n541 3562\n9298 3686\n7443 7921\n0 0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-10\n#define INF 1000000\n \nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n    Point operator *(const double d)const{\n        return Point(x*d,y*d);\n    }\n    bool operator <(const Point &p)const{\n        if(x==p.x) return y<p.y;\n        return x<p.x;\n    }\n    double norm(){\n        return x*x+y*y;\n    }\n\tbool input(){\n\t\tif(cin>>x>>y) return true;\n\t\treturn false;\n\t}\n};\n \nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n\tbool input(){\n\t\tif(a.input() && b.input()) return true;\n\t\treturn false;\n\t}\n};\n \nstruct Circle{\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point _c,double _r){\n        c=_c; r=_r;\n    }\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n \nint ccw(Point a,Point b,Point c){ //a,b,c,は全て異なる\n\tPoint v1 = b-a;\n\tPoint v2 = c-a;\n    if(cross(v1,v2)>EPS) return +1; //a->b->c が反時計回り\n    if(cross(v1,v2)<-EPS) return -1; //a->b->c が時計回り\n\tif(dot(v1,v2)<-EPS) return +2; //cがa-bより後ろ c<-a->b\n\tif(v1.norm()<v2.norm()) return -2; //cがa-bより前 a->b->c\n    return 0; //cがa-b上 a->c->b\n}\n \nbool intersect_ss(Line l,Line m){\n    return ccw(l.a,l.b,m.a)*ccw(l.a,l.b,m.b)<=0 && ccw(m.a,m.b,l.a)*ccw(m.a,m.b,l.b)<=0;\n}\n \nbool crosspoint_ll(Line l,Line m,Point &p){\n    Point a1,a2,b1,b2;\n    a1 = l.b-l.a; a2 = m.b-m.a;\n    b1 = m.a-l.a; b2 = l.a-m.b;\n    double s1,s2;\n    s1 = cross(a1,b1)/2; s2 = cross(a1,b2)/2;\n    if(s1+s2<EPS) return false; //平行\n    p = Point(m.a.x+a2.x*s1/(s1+s2),m.a.y+a2.y*s1/(s1+s2));\n    return true;\n}\n \nint crosspoint_ss(Line l,Line m,Point &p){\n    if(intersect_ss(l,m)==false) return 0; //交差していない\n    if(crosspoint_ll(l,m,p)==true) return 1;\n\treturn -1; //交点が無限個(平行かつ交差)\n}\n \nint crosspoint_cc(Circle c1,Circle c2,Point &p1,Point &p2){\n    double d,a,t;\n    d = sqrt((c2.c-c1.c).norm());\n\tif(abs(c1.c.x-c2.c.x)<EPS && abs(c1.c.y-c2.c.y)<EPS && abs(c1.r-c2.r)<EPS)\n\t\treturn -1; //2つの円が重なっている\n    if(d<abs(c1.r-c2.r) || c1.r+c2.r<d) return 0; //どちらかが内包している\n    a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    t = atan2(c2.c.y-c1.c.y,c2.c.x-c1.c.x);\n    p1 = Point(c1.c.x+c1.r*cos(t+a),c1.c.y+c1.r*sin(t+a));\n    p2 = Point(c1.c.x+c1.r*cos(t-a),c1.c.y+c1.r*sin(t-a));\n    if(abs(p1.x-p2.x)<EPS && abs(p1.y-p2.y)<EPS) return 1; //交点が1つ\n    return 2; //交点が2つ\n}\n\nint contains(Polygon g,Point p){\n\tLine l = Line(p,Point(INF,p.y));\n\tint cnt = 0, n = g.size();\n\tfor(int i=0;i<n;i++){\n\t\tPoint a = g[i]-p;\n\t\tPoint b = g[(i+1)%n]-p;\n\t\tif(ccw(g[i],g[(i+1)%n],p)==0) return 1; //線分上\n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<=EPS && EPS<b.y && cross(a,b)>EPS) cnt++;\n\t}\n\tif((cnt&1)==1) return 2; //内包している\n\treturn 0; //内包していない\n}\n\nPolygon andrewScan(Polygon s){\n\tif(s.size()<=2) return s;\n\tsort(s.begin(),s.end());\n\tPolygon g;\n\tfor(int i=0;i<s.size();i++){\n\t\tfor(int n=g.size(); n>=2 && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\tint upper_n = g.size();\n\tfor(int i=s.size()-2;i>=0;i--){\n\t\tfor(int n=g.size(); n>upper_n && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\treverse(g.begin(),g.end());\n\tg.pop_back();\n\treturn g;\n}\n\nint main(){\n\tint N,M;\n\tPolygon b,w,gb,gw;\n\twhile(cin>>N>>M,N||M){\n\t\tb.resize(N); w.resize(M);\n\t\tfor(int i=0;i<N;i++) b[i].input();\n\t\tfor(int i=0;i<M;i++) w[i].input();\n\t\tgb = andrewScan(b); gw = andrewScan(w);\n\t\tbool ans = true;\n\t\tif(gb.size()>=2 && gw.size()>=2){\n\t\t\tfor(int i=0;i<gb.size() && ans;i++){\n\t\t\t\tfor(int j=0;j<gw.size() && ans;j++){\n\t\t\t\t\tLine l(gb[i],gb[(i+1)%gb.size()]), m(gw[i],gw[(i+1)%gw.size()]);\n\t\t\t\t\tif(intersect_ss(l,m)==true) ans = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(gb.size()>=3){\n\t\t\tfor(int i=0;i<M && ans;i++){\n\t\t\t\tif(contains(gb,w[i])!=0) ans = false;\n\t\t\t}\n\t\t}\n\t\tif(gw.size()>=3){\n\t\t\tfor(int i=0;i<N && ans;i++){\n\t\t\t\tif(contains(gw,b[i])!=0) ans = false;\n\t\t\t}\n\t\t}\n\t\tif(gb.size()==2 && gw.size()==1){\n\t\t\tif(ccw(gb[0],gb[1],gw[0])==0) ans = false;\n\t\t}\n\t\tif(gw.size()==2 && gb.size()==1){\n\t\t\tif(ccw(gw[0],gw[1],gb[0])==0) ans = false;\n\t\t}\n\t\tif(ans==true) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n \nusing namespace std;\n \n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n \nstruct Point{\n  double x,y;\n \n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n \n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n  Point operator / (const double &k)const{ return Point(x/k,y/k); }\n  bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n \ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\n \nistream &operator >> (istream &is,Point &p){\n  return is >> p.x >> p.y;\n}\n \n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n \nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS){ return COUNTER_CLOCKWISE; }\n  if(cross(a,b) < -EPS){ return CLOCKWISE; }\n  if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n  if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n  return ON_SEGMENT;\n}\n \nstruct Segment{\n  Point s,t;\n  Segment(){}\n  Segment(Point s,Point t) : s(s),t(t) {}\n};\n \nbool isIntersectSP(const Segment &s,const Point &p){\n  return equal(ccw(s.s,s.t,p),0);\n}\n \nbool isIntersectSS(const Segment &a,const Segment &b){\n  Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0\n    && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n \n#define prev(G,i) (G[(i-1+G.size())%G.size()])\n#define curr(G,i) (G[i%G.size()])\n#define next(G,i) (G[(i+1)%G.size()])\ntypedef vector<Point> Polygon;\n \nbool check(const Polygon &pg,const Point &p){\n  int N = pg.size();\n  bool in = false;\n  for(int i = 0 ; i < N ; i++){\n    Point a = curr(pg,i)-p, b = next(pg,i)-p;\n    if(a.y > b.y){ swap(a,b); }\n    if(a.y <= 0 && 0 < b.y && cross(a,b) > 0){ in = !in; }\n    if(cross(a,b) == 0 && dot(a,b) <= 0){ return true; }\n  }\n  return in;\n}\n\nbool sortY(Point p1,Point p2){\n  if(p1.y != p2.y){\n    return (p1.y - p2.y < -EPS);\n  }else{ \n    return (p1.x - p2.x < -EPS);\n  }\n}\n\nPolygon convex_hull(Polygon &ps){\n  int N = ps.size(),j = 0;\n  Polygon pg(N*2);\n  sort(ps.begin(),ps.end(),sortY);\n  for(int i = 0 ; i < N ; i++,j++){\n    while(j >= 2 && ccw(pg[j-2],pg[j-1],ps[i]) == -1){\n      j--;\n    }\n    pg[j] = ps[i];\n  }\n  int k = j+1;\n  for(int i = N-2 ; i >= 0 ; i--,j++){\n    while(j >= k && ccw(pg[j-2],pg[j-1],ps[i]) == -1){\n      j--;\n    }\n    pg[j] = ps[i];\n  }\n  pg.resize(j-1);\n  return pg;\n}\n \nbool solve(Polygon &bp,Polygon &wp){\n  int N = bp.size(), M = wp.size();\n  if(N == 1 && M == 1){\n    return !(equal(bp[0].x,wp[0].x) && equal(bp[0].y,wp[0].y));\n  }\n  if(N == 2 && M == 1){\n    Segment s(bp[0],bp[1]);\n    return !isIntersectSP(s,wp[0]);\n  }\n  if(N == 1 && M == 2){\n    Segment s(wp[0],wp[1]);\n    return !isIntersectSP(s,bp[0]);\n  }\n  if(N == 2 && M == 2){\n    Segment s1(bp[0],bp[1]),s2(wp[0],wp[1]);\n    return !isIntersectSS(s1,s2);\n  }\n  bp = convex_hull(bp);\n  wp = convex_hull(wp);\n  if(N == 1 && M >= 3){\n    return !check(wp,bp[0]);\n  }\n  if(N >= 3 && M == 1){\n    return !check(bp,wp[0]);\n  }\n  if(N == 2 && M >= 3){\n    Segment s1(bp[0],bp[1]);\n    if(check(wp,bp[0]) || check(wp,bp[1])){\n      return false;\n    }\n    for(int i = 0 ; i < M ; i++){\n      for(int j = i+1 ; j < M ; j++){\n        Segment s2(wp[i],wp[j]);\n        if(isIntersectSS(s1,s2)){\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  if(N >= 3 && M == 2){\n    Segment s1(wp[0],wp[1]);\n    if(check(bp,wp[0]) || check(bp,wp[1])){\n      return false;\n    }\n    for(int i = 0 ; i < N ; i++){\n      for(int j = i+1 ; j < N ; j++){\n        Segment s2(bp[i],bp[j]);\n        if(isIntersectSS(s1,s2)){\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  for(int i = 0 ; i < N ; i++){\n    if(check(wp,bp[i])){\n      return false;\n    }\n  }\n  for(int i = 0 ; i < M ; i++){\n    if(check(bp,wp[i])){\n      return false;\n    }\n  }\n  return true;\n}\n \nint main(){\n  int N,M;\n  while(cin >> N >> M,N){\n    Polygon bp(N),wp(M);\n    for(int i = 0 ; i < N ; i++){\n      cin >> bp[i];\n    }\n    for(int i = 0 ; i < M ; i++){\n      cin >> wp[i];\n    }\n    cout << (solve(bp,wp) ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Hello. I'm Peter.\n//#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<functional>\n#include<cctype>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uin;\n#define peter cout<<\"i am peter\"<<endl\n#define input freopen(\"data.txt\",\"r\",stdin)\n#define randin srand((unsigned int)time(NULL))\n#define INT (0x3f3f3f3f)*2\n#define LL (0x3f3f3f3f3f3f3f3f)*2\n#define MAXN\n#define N 1024\n#define M\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nconst double eps=1e-9;\ninline int dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    else if(x<0) return -1;\n    else return 1;\n}\nint n,m;\nstruct Point{\n    double x,y;\n    Point(){};\n    Point(double xx,double yy){\n        x=xx,y=yy;\n    }\n};\ninline bool comp(const Point a,const Point b){\n    if(dcmp(a.x-b.x)) return a.x<b.x;\n    else return a.y<b.y;\n}\ntypedef Point Vector;\nVector operator+(const Vector a,const Vector b){\n    return Vector(a.x+b.x,a.y+b.y);\n}\nVector operator-(const Vector a,const Vector b){\n    return Vector(a.x-b.x,a.y-b.y);\n}\ndouble operator*(const Vector a,const Vector b){\n    return a.x*b.x+a.y*b.y;\n}\ndouble operator%(const Vector a,const Vector b){\n    return a.x*b.y-a.y*b.x;\n}\nVector operator*(const Vector a,const double b){\n    return Vector(a.x*b,a.y*b);\n}\nVector operator*(const double b,const Vector a){\n    return Vector(a.x*b,a.y*b);\n}\nbool operator ==(const Vector a,const Vector b){\n    return !dcmp(a.x-b.x)&&!dcmp(a.y-b.y);\n}\nVector operator/(const Vector a,const double b){\n    return Vector(a.x/b,a.y/b);\n}\ndouble Square_Triangle(Point p1,Point p2,Point p3){\n    //????§???¢??¢?§????????????????\n    return 0.5*fabs((p2-p1)%(p3-p1));\n}\n#define lenp res.size()\nvoid Convex_Hull(Point *p,int n,vector<Point>&res){\n    res.clear();\n    for(int i=0;i<n;i++){\n        while(lenp>1&&dcmp((res[lenp-1]-res[lenp-2])%(p[i]-res[lenp-2]))<0) res.pop_back();\n        res.push_back(p[i]);\n    }\n    int k=(int)lenp;\n    for(int i=n-2;i>=0;i--){\n        while(lenp>k&&dcmp((res[lenp-1]-res[lenp-2])%(p[i]-res[lenp-2]))<0) res.pop_back();\n        res.push_back(p[i]);\n    }\n    if(lenp>1) res.pop_back();\n}\nvoid readPointInt(Point &p){\n    int x,y;\n    x=read(),y=read();\n    p=Point(x,y);\n}\n\nPoint p1[N],p2[N];\n#define lenv1 v1.size()\n#define lenv2 v2.size()\n#define lenv v.size()\ndouble Square_ConvexHull(vector<Point>&v){//?????????????????¢?§?\n    //lenv>=3\n    double res=0.0;\n    for(int i=1;i<lenv-1;i++){\n        res+=Square_Triangle(v[0],v[i],v[i+1]);\n    }\n    return res;\n}\ndouble Square_PointWithConvexHull(Point p,vector<Point>&v){\n    //?±???????????????????????????¢????????¢?§?\n    v.push_back(v[0]);\n    double res=0.0;\n    for(int i=0;i<lenv-1;i++){\n        res+=Square_Triangle(p,v[i],v[i+1]);\n    }\n    v.pop_back();\n    return res;\n}\nbool PointOnSegment(Point p,Point p1,Point p2){\n//    Vector v1=p1-p,v2=p2-p;\n//    if(dcmp(v1%v2)) return false;\n//    else if(dcmp(v1*v2)>0) return false;\n//    else return true;\n    if(p==p1||p==p2) return true;\n    return dcmp((p1-p)%(p2-p))==0&&dcmp((p1-p)*(p2-p))<0;\n}\nbool PointInConvexHull1_In_ConvexHull2(vector<Point>&v1,vector<Point>&v2){\n    if(lenv1==1&&lenv2==1) return v1[0]==v2[0];\n    if(lenv1==1&&lenv2==2) return PointOnSegment(v1[0],v2[0],v2[1]);\n    if(lenv2>=3){\n        double Sv2=Square_ConvexHull(v2);\n        for(int i=0;i<lenv1;i++){\n            double St=Square_PointWithConvexHull(v1[i],v2);\n            if(!dcmp(St-Sv2)) return true;\n        }\n    }\n    return false;\n}\nbool Segment1_Inter_Segment2(Point p1,Point p2,Point q1,Point q2){\n//    if(!dcmp((p1-p2)%(q1-q2))){\n//        return PointOnSegment(p1,q1,q2)||PointOnSegment(p2,q1,q2)||PointOnSegment(q1,p1,p2)||PointOnSegment(q2,p1,p2);\n//    }\n//    else{\n//        int t1=dcmp((p2-p1)%(q1-p1));\n//        int t2=dcmp((p2-p1)%(q2-p1));\n//        int t3=dcmp((q2-q1)%(p1-q1));\n//        int t4=dcmp((q2-q1)%(p2-q1));\n//        return t1*t2<=0&&t3*t4<=0;\n//    }\n    if(PointOnSegment(p1,q1,q2)||PointOnSegment(p2,q1,q2)||PointOnSegment(q1,p1,p2)||PointOnSegment(q2,p1,p2))\n        return true;\n    double t1=(p2-p1)%(q1-p1);\n    double t2=(p2-p1)%(q2-p1);\n    double t3=(q2-q1)%(p1-q1);\n    double t4=(q2-q1)%(p2-q1);\n    return dcmp(t1)*dcmp(t2)<0&&dcmp(t3)*dcmp(t4)<0;\n}\nbool ConvexHull1_Inter_ConvexHull2(vector<Point>&v1,vector<Point>&v2){\n    //?????????????????¨??????????????????\n    if(PointInConvexHull1_In_ConvexHull2(v1,v2)) return true;\n    if(PointInConvexHull1_In_ConvexHull2(v2,v1)) return true;\n    //???????????????????????????\n    if(lenv1>=2&&lenv2>=2){\n        v1.push_back(v1[0]);\n        v2.push_back(v2[0]);\n        for(int i=0;i<lenv1-1;i++){\n            for(int j=0;j<lenv2-1;j++){\n                if(Segment1_Inter_Segment2(v1[i],v1[i+1],v2[j],v2[j+1])){\n                    v1.pop_back();\n                    v2.pop_back();\n                    return true;\n                }\n            }\n        }\n        v1.pop_back();\n        v2.pop_back();\n    }\n    return false;\n}\nint main(){\n    //input;\n    while(1){\n        n=read(),m=read();\n        if(!n&&!m) break;\n        if(!n||!m) while(1);\n        for(int i=0;i<n;i++){\n            readPointInt(p1[i]);\n        }\n        vector<Point>res1;\n        Convex_Hull(p1,n,res1);\n        for(int i=0;i<m;i++){\n            readPointInt(p2[i]);\n        }\n        vector<Point>res2;\n        Convex_Hull(p2,m,res2);\n        if(ConvexHull1_Inter_ConvexHull2(res1,res2)){\n            printf(\"NO\\n\");\n        }\n        else printf(\"YES\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// ------ Class ------ //\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tbool operator==(const Point& p) const { return px == p.px && py == p.py; }\n\tbool operator!=(const Point& p) const { return px != p.px || py != p.py; }\n\tbool operator<(const Point& p) const { return px < p.px ? true : (px == p.px && py < p.py); }\n\tbool operator>(const Point& p) const { return px > p.px ? true : (px == p.px && py > p.py); }\n\tbool operator<=(const Point& p) const { return !(Point(px, py) > p); }\n\tbool operator>=(const Point& p) const { return !(Point(px, py) < p); }\n\tPoint operator+(const Point& p) const { return Point(px + p.px, py + p.py); }\n\tPoint operator-(const Point& p) const { return Point(px - p.px, py - p.py); }\n\tPoint operator/(long double d) const { return Point(px / d, py / d); }\n\tfriend Point operator*(const Point p, long double d) { return Point(p.px * d, p.py * d); }\n\tfriend Point operator*(long double d, const Point& p) { return p * d; }\n\tPoint& operator+=(const Point& p1) { px += p1.px, py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px, py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d, py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d, py /= d; return *this; }\n};\n\n// ------ Functions ------ //\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint pol(long double r, long double d) { return Point(cosl(d) * r, sinl(d) * r); }\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nvector<Point> convex_hull(vector<Point> v) {\n\tif (v.size() < 3) return v;\n\tsort(v.begin(), v.end());\n\tvector<Point> u = { v[0], v[1] }, l = { v[v.size() - 1], v[v.size() - 2] };\n\tfor (int i = 2; i < v.size(); i++) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], v[i]) >= 0; n--) u.pop_back();\n\t\tu.push_back(v[i]);\n\t}\n\tfor (int i = v.size() - 3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], v[i]) >= 0; n--) l.pop_back();\n\t\tl.push_back(v[i]);\n\t}\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\n// ------ Main ------ //\nint n, m;\nint main() {\n\twhile (cin >> n >> m, n + m) {\n\t\tvector<Point> v1(n), v2(m);\n\t\tfor (int i = 0; i < n; i++) cin >> v1[i].px >> v1[i].py;\n\t\tfor (int i = 0; i < m; i++) cin >> v2[i].px >> v2[i].py;\n\t\tvector<Point> v3 = convex_hull(v1), v4 = convex_hull(v2);\n\t\tint x = 0;\n\t\tfor (int i = 0; i < v3.size(); i++) {\n\t\t\tint u = (i + 1) % v3.size(), f = 1;\n\t\t\tfor (int j = 0; j < v4.size(); j++) {\n\t\t\t\tif (abs(ccw(v3[i], v3[u], v4[j])) != 1) {\n\t\t\t\t\tf = 0; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f) continue;\n\t\t\tfor (int j = 0; j < v3.size(); j++) {\n\t\t\t\tif (i == j || u == j) continue;\n\t\t\t\tfor (int k = 0; k < v4.size(); k++) {\n\t\t\t\t\tif (ccw(v3[i], v3[u], v3[j]) == ccw(v3[i], v3[u], v4[k])) {\n\t\t\t\t\t\tf = 0; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!f) break;\n\t\t\t}\n\t\t\tif (!f) continue;\n\t\t\tfor (int j = 0; j < v4.size(); j++) {\n\t\t\t\tfor (int k = j + 1; k < v4.size(); k++) {\n\t\t\t\t\tif (ccw(v3[i], v3[u], v4[j]) != ccw(v3[i], v3[u], v4[k])) {\n\t\t\t\t\t\tf = 0; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tx = 1; break;\n\t\t\t}\n\t\t}\n\t\tcout << (x ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\n\nconst double EPS = 1e-9;\nconst double PI = 6.0 * asin(0.5);\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersect(L s1, L s2){\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\nvector<P> convex_hull(vector<P> v){\n  vector<P> c; \n  sort(v.begin(),v.end());\n  c.assign(v.begin(),v.begin()+2);\n    \n  for(int i=2;i<v.size();i++){\n    P a = c[c.size()-1] - c[c.size()-2];\n    P b = v[i] - c[c.size()-2];\n        \n    while(cross(a,b) > EPS){\n      c.pop_back();\n      if(c.size() < 2) break;\n      a = c[c.size()-1] - c[c.size()-2];\n      b = v[i] - c[c.size()-2];\n    }\n    c.push_back(v[i]);\n  }\n\t\n  int n = c.size();\n  c.push_back(v[v.size()-2]);\n\t\n  for(int i=v.size()-3;i>=0;i--){\n    P a = c[c.size()-1] - c[c.size()-2];\n    P b = v[i] - c[c.size()-2];\n        \n    while(cross(a,b) > EPS){\n      c.pop_back();\n      if(c.size() < n + 1) break;\n      a = c[c.size()-1] - c[c.size()-2];\n      b = v[i] - c[c.size()-2];\n    }\n    c.push_back(v[i]);\n  }\n  c.pop_back();\n  return c;\n}\n\n\nvector<P> p1,p2;\nint n,m;\nint solve(){\n  if(n+m<3) return 1;\n  if(m==1&&n==2) return ccw(p1[0],p1[1],p2[0])!=0;\n  if(n==2&&m==2) return !isIntersect(L(p1[0],p1[2]),L(p2[0],p2[1]));\n\n  if(n<3) return 0;\n  vector<P> t=convex_hull(p1);\n  for(int i=0;i<=(int)t.size();i++){\n    int flg=1;\n    for(int j=0;j<m&&flg;j++)\n      if(ccw(t[i],t[(i+1)%t.size()],p2[j])!=1)flg=0;\n    if(flg) return 1;\n    \n  }\n  return 0;  \n}\n\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)return 0;\n    p1.resize(n),p2.resize(m);\n    for(int i=0,a,b;i<n;i++)cin>>a>>b,p1[i]=P(a,b);\n    for(int i=0,a,b;i<m;i++)cin>>a>>b,p2[i]=P(a,b);\n    int ans=solve();\n    swap(p1,p2);\n    swap(n,m);\n    ans|=solve();\n    cout<<(ans?\"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Point\n{\npublic:\n    int y, x;\n    Point(){\n        y = x = 0;\n    }\n    Point(int y0, int x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(int a) const{\n        return Point(y * a, x * a);\n    }\n    double length2() const{\n        return y * y + x * x;\n    }\n    double dist2(const Point& p) const{\n        return (y - p.y) * (y - p.y) + (x - p.x) * (x - p.x);\n    }\n    int dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cosÆ\n    }\n    int cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sinÆ\n    }\n    bool operator<(const Point& p) const{\n        return x < p.x || (x == p.x && y < p.y);\n    }\n};\n\nvoid convexHull(const vector<Point>& p0, vector<Point>& cv)\n{\n    if(p0.size() < 3){\n        cv = p0;\n        return;\n    }\n\n    vector<Point> p = p0;\n    sort(p.begin(), p.end());\n    int n = p.size();\n\n    int j = 0;\n    cv.clear();\n    for(int i=0; i<2*n-1; ++i){\n        Point tmp = (i<n? p[i]:p[2*(n-1)-i]);\n        while(j >= 2 && (tmp-cv[j-2]).cross(cv[j-1]-cv[j-2]) < 0){\n            cv.pop_back();\n            -- j;\n        }\n        cv.push_back(tmp);\n        ++ j;\n    }\n    cv.pop_back();\n}\n\nbool segmentsCollide(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    if(min(a1.x, a2.x) > max(b1.x, b2.x) || min(b1.x, b2.x) > max(a1.x, a2.x) || min(a1.y, a2.y) > max(b1.y, b2.y) || min(b1.y, b2.y) > max(a1.y, a2.y))\n        return false;\n\n    return ((long long)((a2-a1).cross(b1-a1)) * (a2-a1).cross(b2-a1) <= 0) && ((long long)((b2-b1).cross(a1-b1)) * (b2-b1).cross(a2-b1) <= 0);\n}\n\nbool convexContain(const vector<Point>& cp, const Point& p)\n{\n    int n = cp.size();\n    bool ret1 = true;\n    bool ret2 = true;\n    for(int i=0; i<n; ++i){\n        int a = (cp[(i+1)%n] - cp[i]).cross(p - cp[i]);\n        if(a < 0)\n            ret1 = false;\n        if(a > 0)\n            ret2 = false;\n    }\n    return ret1 || ret2;\n}\n\nbool polygonsCollide(const vector<Point>& cp1, const vector<Point>& cp2)\n{\n    int n = cp1.size();\n    int m = cp2.size();\n    for(int i=0; i<n; ++i){\n        for(int j=0; j<m; ++j){\n            if(segmentsCollide(cp1[i], cp1[(i+1)%n], cp2[j], cp2[(j+1)%m]))\n                return true;\n        }\n    }\n\n    if(cp1.size() >= 3 && convexContain(cp1, cp2[0]))\n        return true;\n    if(cp2.size() >= 3 && convexContain(cp2, cp1[0]))\n        return true;\n    return false;\n}\n\nint main()\n{\n    for(;;){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        vector<Point> p1(n), p2(m);\n        for(int i=0; i<n; ++i)\n            cin >> p1[i].x >> p1[i].y;\n        for(int i=0; i<m; ++i)\n            cin >> p2[i].x >> p2[i].y;\n\n        vector<Point> cv1, cv2;\n        convexHull(p1, cv1);\n        convexHull(p2, cv2);\n\n        if(polygonsCollide(cv1, cv2))\n            cout << \"NO\" << endl;\n        else\n            cout << \"YES\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>  \n#include <cstdio>  \n#include <cstring>  \n#include <algorithm>  \n#include <cmath>  \nusing namespace std;  \n  \nstruct Point  \n{  \n    double x,y;  \n    Point (double x=0, double y=0) :x(x),y(y) {}  \n    void show() { cout<<\"(\"<<x<<\",\"<<y<<\")\"<<endl; }  \n};  \ntypedef Point Vector;  \n  \nbool operator < (const Point& A, const Point& B )  \n{  \n    return A.x < B.x || (A.x == B.x && A.y < B.y);  \n}  \nVector operator - ( Point A, Point B) { return Vector(A.x-B.x, A.y-B.y); }  \ndouble Cross(Vector A, Vector B) { return A.x*B.y - B.x*A.y; }  \n  \nconst double eps = 1e-10;  \nint dcmp(double x)  \n{  \n    if(fabs(x) < eps) return 0;  \n    return x>0? 1: -1;  \n}  \n  \nint ConvexHull ( Point* p, int n, Point* ch)  \n{  \n    sort(p, p+n);  \n    int m = 0;  \n    for(int i = 0; i<n; i++)  \n    {  \n        while(m > 1 && Cross( ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0) m--;  \n        ch[m++] = p[i];  \n    }  \n    int k = m;  \n    for(int i = n-2; i>=0; i--)  \n    {  \n        while(m > k && Cross( ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0) m--;  \n        ch[m++] = p[i];  \n    }  \n    ///霑倩ヲ∵隼荳?ク狗函謌仙、夊セケ蠖「縲? \n    ch[m++] = ch[0];  \n    if(n > 1) m--;  \n    return m;  \n}  \n  \nPoint black[120],white[120],cw[120],cb[120];  \nint nb,nw,n,m;  \n  \nvoid reset()  \n{  \n    memset(black,0,sizeof(black));  \n    memset(white,0,sizeof(white));  \n    memset(cw,0,sizeof(cw));  \n    memset(cb,0,sizeof(cb));  \n}  \n  \nbool SideCross(Point a1, Point a2, Point b1, Point b2)  \n{  \n    double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1),  \n           c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1);  \n    return dcmp(c1)*dcmp(c2)<0 && dcmp(c3)*dcmp(c4)<0;  \n}  \n  \nbool pInConvex(Point a, Point* ch, int n)  \n{  \n    int i;  \n    if(n==3)  \n    {  \n        if(a.x < min(ch[0].x, ch[1].x) || a.x > max(ch[0].x, ch[1].x)) return 0;  \n        if(a.y < min(ch[0].y, ch[1].y) || a.y > max(ch[0].y, ch[1].y)) return 0;  \n    }  \n    for(i=1;i<n;i++)  \n    {  \n        if(Cross( ch[i]-ch[i-1], a-ch[i-1] ) < 0 ) return 0;  \n    }  \n    return 1;  \n}  \n  \nint solve()  \n{  \n    int i,j;  \n    if(n==1&&m==1) return 1;  \n    else if(n==1)  \n    {  \n        ///謇セ逋ス蟄仙?蛹?、夊セケ蠖「縲ょ愛譁ュ霑吩クェ鮟大ュ先弍蜷ヲ蝨ィ逋ス蛹??  \n        nw=ConvexHull(white, m, cw);  \n        if(pInConvex(black[0], cw, nw)) return 0;  \n    }  \n    else if(m==1)  \n    {  \n        ///謇セ鮟大ュ仙?蛹?、夊セケ蠖「縲ょ愛譁ュ霑吩クェ逋ス蟄先弍蜷ヲ蝨ィ鮟大桁蜀? \n        nb=ConvexHull(black, n, cb);  \n        if(pInConvex(white[0], cb, nb)) return 0;  \n    }  \n    else  \n    {  \n        ///謇セ鮟醍區蜃ク蛹?、夊セケ蠖「縲ょ愛譁ュ譏ッ蜷ヲ譛臥コソ谿オ逶ク莠、謌也せ蝨ィ蜿ヲ荳?クェ蜃ク蛹??縲? \n        nb=ConvexHull(black, n, cb);  \n        nw=ConvexHull(white, m, cw);  \n        for(i=1;i<nb;i++)  \n        {  \n            for(j=1;j<nw;j++)  \n                if(SideCross( cb[i], cb[i-1], cw[j] ,cw[j-1] )) return 0;  \n        }  \n        for(i=0;i<n;i++)  \n            if(pInConvex(black[i], cw, nw)) return 0;  \n        for(i=0;i<m;i++)  \n            if(pInConvex(white[i], cb, nb)) return 0;  \n    }  \n    return 1;  \n}  \n  \nint main()  \n{  \n    freopen(\"input.txt\",\"r\",stdin);  \n    int i,tx,ty;  \n    while(cin>>n>>m,n||m)  \n    {  \n        reset();  \n        for(i=0;i<n;i++)  \n        {  \n            cin>>tx>>ty;  \n            black[i]=Point(tx,ty);  \n        }  \n        for(i=0;i<m;i++)  \n        {  \n            cin>>tx>>ty;  \n            white[i]=Point(tx,ty);  \n        }  \n        int ans=solve();  \n        if(ans)  \n            cout<<\"YES\"<<endl;  \n        else  \n            cout<<\"NO\"<<endl;  \n    }  \n    return 0;  \n}  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-10)\n#define eq(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\ndouble norm(Vector v) { return v.x*v.x + v.y*v.y; }\ndouble abs(Vector v) { return sqrt(norm(v)); }\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nbool isOrthogonal(Vector a, Vector b) {\n  return eq(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isParallel(Vector a, Vector b) {\n  return eq(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n  return isParallel(a1 - a2, b1 - b2);\n}\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\ndouble getDistance(Point a, Point b) { return abs(a - b); }\ndouble getAngle(Point a, Point b, Point c) {\n  Vector v = b - a, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha) * 180 / M_PI;\n  return min(theta, 360 - theta);\n}\n\nstruct Segment {\n  Point p1, p2;\n  Segment(Point p1 = Point(), Point p2 = Point()):p1(p1), p2(p2){}\n};\ntypedef Segment Line;\n\nbool isOrthogonal(Segment s1, Segment s2) {\n  return eq(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isParallel(Segment s1, Segment s2) {\n  return eq(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p) {\n  return p + (project(s, p) - p) * 2.0;\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) {\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\ndouble getDistance(Segment s1, Segment s2) {\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPoint getCrossPointLL(Line l1, Line l2) {\n  Vector v1 = l1.p2 - l1.p1, v2 = l2.p2 - l2.p1;\n  double d = cross(v2, v1);\n  if(abs(d) < EPS) return l2.p1;\n  return l1.p1 + v1 * cross(v2, l2.p2 - l1.p1) * (1.0 / d);\n}\nLine getPerpendicularBisector(Point p1, Point p2) {\n  Point c = (p1 + p2) / 2.0;\n  Point q = Point(c.x + (p1.y - p2.y), c.y + (p2.x - p1.x));\n  return Line(c, q);\n}\n\nstruct Circle {\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0):c(c), r(r){}\n};\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n  // assert(intersect(c, l));\n  Vector pr = project(l, c.c);\n  Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n  double base = sqrt(c.r*c.r - norm(pr - c.c));\n  return make_pair(pr + e * base, pr - e * base);\n}\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n  // assert(intersect(c1, c2));\n  double d = abs(c1.c - c2.c);\n  double a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2*c1.r*d));\n  double t = arg(c2.c - c1.c);\n  return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\ntypedef vector<Point> Polygon;\n\ndouble getArea(Polygon p) {\n  double ret = 0.0;\n  for(int i = 0; i < (int)p.size(); i++) {\n    ret += cross(p[i], p[(i+1)%p.size()]);\n  }\n  return abs(ret) / 2.0;\n}\n\n#define IN_POLYGON  2\n#define ON_POLYGON  1\n#define OUT_POLYGON 0\nint contains(Polygon g, Point p) {\n  int n = g.size();\n  bool x = false;\n  for(int i = 0; i < n; i++) {\n    Point a = g[i] - p, b = g[(i+1) % n] - p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON_POLYGON;\n    if(a.y > b.y) swap(a, b);\n    if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n  }\n  return (x ? IN_POLYGON : OUT_POLYGON);\n}\n\nPolygon convexHull(Polygon ps) {\n  int N = ps.size(), j = 0;\n  Polygon pg(N*2);\n\n  if(N < 3) return ps;\n\n  sort(ps.begin(), ps.end(), [](Point p1, Point p2) -> bool {\n      return p1.y != p2.y ? lt(p1.y, p2.y) : lt(p1.x, p2.x); });\n  for(int i = 0; i < N; i++, j++) {\n    while(j >= 2 && ccw(pg[j-2], pg[j-1], ps[i]) == -1) j--;\n    pg[j] = ps[i];\n  }\n  int k = j+1;\n  for(int i = N-2; i >= 0; i--, j++) {\n    while(j >= k && ccw(pg[j-2], pg[j-1], ps[i]) == -1) j--;\n    pg[j] = ps[i];\n  }\n  pg.resize(j-1);\n  return pg;\n}\n\nPolygon convexCut(Polygon s, Line l) {\n  Polygon t;\n  for(int i = 0; i < (int)s.size(); i++) {\n    Point a = s[i], b = s[(i+1)%s.size()];\n    if(ccw(l.p1, l.p2, a) != -1) t.push_back(a);\n    if(ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0) {\n      t.push_back(getCrossPointLL(Line(a, b), l));\n    }\n  }\n  return t;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n, m;\n  while(cin >> n >> m, n || m) {\n    Polygon s(n), t(m);\n    rep(i, n) cin >> s[i].x >> s[i].y;\n    rep(i, m) cin >> t[i].x >> t[i].y;\n\n    if(n < 2 && m < 2) {\n      puts(\"YES\"); continue;\n    }\n    if(n + m <= 3) {\n      if(n == 2 && ccw(s[0], s[1], t[0]) == ON_SEGMENT ||\n\t m == 2 && ccw(t[0], t[1], t[0]) == ON_SEGMENT) {\n\tputs(\"NO\"); continue;\n      }\n      puts(\"YES\"); continue;\n    }\n    if(n == 2 && m == 2) {\n      if(intersect(s[0], s[1], t[0], t[1])) {\n\tputs(\"NO\"); continue;\n      }\n      puts(\"YES\"); continue;\n    }\n\n    auto S = convexHull(s);\n    auto T = convexHull(t);\n    bool flag = true;\n    for(auto&& p : t) flag &= (contains(S, p) == 0);\n    for(auto&& p : s) flag &= (contains(T, p) == 0);\n    cout << (flag ? \"YES\" : \"NO\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(_,v.size()){rep(__,v[_].size())cout<<\" \"<<v[_][__];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(){;}\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble tmp=c.r*c.r-norm(pr-c.c);\n\tif(abs(tmp)<EPS)tmp=0;\n\tdouble t=sqrt(tmp);\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%0.9f %0.9f %0.9f %0.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\n\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tG g(n+m);\n\t\trep(i,n+m)g[i]=pin();\n\t\tbool h=false;\n\t\trep(i,n+m)rep(j,i){\n\t\t\tP p=g[i]-g[j];\n\t\t\tvvi cr(2,vi(2));\n\t\t\tvvd in;\n\t\t\trep(k,n+m){\n\t\t\t\tif(cross(p,g[k]-g[j])>EPS)cr[k<n][0]=1;\n\t\t\t\tif(cross(p,g[k]-g[j])<-EPS)cr[k<n][1]=1;\n\t\t\t\tif(abs(cross(p,g[k]-g[j]))<EPS){\n\t\t\t\t\tdouble dis=abs(g[j]-g[k]);\n\t\t\t\t\tif(dot(p,g[k]-g[j])<0)dis*=-1;\n\t\t\t\t\tin.pb({dis,k<n?1.:0.});\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool H=true;\n\t\t\tint co=0;\n\t\t\tsort(all(in));\n\t\t\trep(k,in.size()-1)if(abs(in[k][1]-in[k+1][1])>EPS)co++;\n\t\t\tif(co>=2)H=false;\n\t\t\tif(cr[0][0]&&cr[0][1])H=false;\n\t\t\tif(cr[1][0]&&cr[1][1])H=false;\n\t\t\tif(cr[0][0]&&cr[1][0])H=false;\n\t\t\tif(cr[0][1]&&cr[1][1])H=false;\n\t\t\tif(H)h=true;\n\t\t}\n\t\tif(h)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,char> PP;\nconst double EPS = 1e-8;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a)!=real(b)?real(a)<real(b):imag(a)<imag(b);}}\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\n\nint ccw(P a, P b, P c) {\n  b-=a;c-=a;\n  if(cross(b,c)>EPS)return +1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return +2;\n  if(norm(b)<norm(c))return -2;\n  return 0;\n}\n\nvector<P> convex_hull(vector<P> p) {\n  int n=p.size(),k=0;\n  if(n==1) return p;\n  sort(p.begin(),p.end());\n  vector<P> q(2*n);\n  for(int i=0;i<n;q[k++]=p[i++])while(k>=2&&ccw(q[k-2],q[k-1],p[i])<=0)--k;\n  for(int i=n-2,t=k+1;i>=0;q[k++]=p[i--])while(k>=t&&ccw(q[k-2],q[k-1],p[i])<=0)--k;\n  q.resize(k-1);\n  return q;\n}\n\nint contains(vector<P> v, P p){ \n  bool in=false; \n  for(int i=0;i<v.size();i++){ \n    P a=v[i]-p; \n    P b=v[(i+1)%v.size()]-p; \n    if(imag(a)>imag(b)) swap(a,b); \n    if((imag(a)<=0||fabs(imag(a))<=EPS)&&EPS<imag(b)) \n      if(cross(a,b)<-EPS) in=!in; \n    if(fabs(cross(a,b))<=EPS&&dot(a,b)<EPS) return 1; \n  } \n  return in?2:0; \n}\n\nbool intersect_1pt(P a,P b,P c,P d,P &r) {\n  double D=cross(b-a,d-c);\n  if(fabs(D)<EPS) return false;\n  double t=cross(c-a,d-c)/D;\n  double s=-1*cross(a-c,b-a)/D;\n  r=a+t*(b-a);\n  return((t > 0||fabs(t)<EPS)&&(t<1||fabs(t-1)<EPS)&&(s>0||fabs(s)<EPS)&&(s<1||fabs(s-1)<EPS));\n}\n\nvector<P> convex_intersect(vector<P> v1,vector<P> v2) {\n  int n=v1.size(),m=v2.size();\n  int a=0,b=0,aa=0,ba=0,in=2;\n  vector<P> v3;\n  do {\n    int a1=(a+n-1)%n,b1=(b+m-1)%m;\n    double A=cross(v1[a1]-v2[b],v1[a]-v2[b]);\n    double B=cross(v2[b1]-v1[a],v2[b]-v1[a]);\n    double C=cross(v1[a]-v1[a1],v2[b]-v2[b1]);\n    P r;\n    if(intersect_1pt(v1[a1],v1[a],v2[b1],v2[b],r)){\n      if(in==2) aa=ba=0;\n      v3.push_back(r);\n      in=B>0?0:A>0?1:in;\n    }\n    if(C==0&&B==0&&A==0){\n      if(in==0){b=(b+1)%m;ba++;}\n      else {a=(a+1)%n;aa++;}\n    } else if(C>=0){\n      if(A>0){\n        if(in==0) v3.push_back(v1[a]);\n        a=(a+1)%n;\n        aa++;\n      } else {\n        if(in==1) v3.push_back(v2[b]);\n        b=(b+1)%m;\n        ba++;\n      }\n    } else {\n      if(B>0){\n        if(in==1) v3.push_back(v2[b]);\n        b=(b+1)%m;\n        ba++;\n      } else {\n        if(in==0) v3.push_back(v1[a]);\n        a=(a+1)%n;\n        aa++;\n      }\n    }\n  } while((aa<n||ba<m)&&aa<2*n&&ba<2*m);\n  if(in==2){\n    if(contains(v2,v1[0])) return v1;\n    if(contains(v1,v2[0])) return v2;\n  }\n  return v3;\n}\n\nint main() {\n  int n,m;\n  while(cin >> n >> m && n) {\n    vector<P> v[2];\n    for(int i=0; i<n; i++) {\n      double x,y;\n      cin >> x >> y;\n      v[0].push_back(P(x,y));\n    }\n    for(int i=0; i<m; i++) {\n      double x,y;\n      cin >> x >> y;\n      v[1].push_back(P(x,y));\n    }\n    for(int i=0; i<2; i++) v[i]=convex_hull(v[i]);\n    if(!v[0].size()||!v[1].size()||v[0].size()==1&&v[1].size()==1) {\n      cout << \"YES\" << endl;\n      continue;\n    }\n    vector<P> ans=convex_intersect(v[0],v[1]);\n    if(ans.size()) cout << \"NO\" << endl;\n    else cout << \"YES\" << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n/* -----  2017/11/20  Problem: AOJ 1298 / Link: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1298  ----- */\n/* ------問題------\n\n\n\n-----問題ここまで----- */\n/* -----解説等-----\n\n\n\n----解説ここまで---- */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n// 内積\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\ntypedef vector<Point> Polygon;\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\n\n// 誤差つき等号判定\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 点が多角形に内包されているか? yes:2\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const Polygon& P, const Point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < P.size(); ++i) {\n\t\tPoint a = curr(P, i) - p, b = next(P, i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tLL N, M;\n\twhile (cin >> N >> M, N || M) {\n\t\tint yesf = 1;\n\t\tvector<Point>B(N);\n\t\tvector<Point>W(M);\n\t\tFOR(i, 0, N) {\n\t\t\tB[i] = input_point();\n\t\t}\n\t\tFOR(i, 0, M) {\n\t\t\tW[i] = input_point();\n\t\t}\n\t\tif (N <= 2 && M <= 2) {// line and dat\n\t\t\tLine L1(B[0], B[1]);\n\t\t\tLine L2(W[0], W[1]);\n\n\t\t\tif (N == 2 && M == 2) {\n\t\t\t\tyesf = !isis_ss(L1, L2);//交差してたらダメ\n\t\t\t}\n\t\t\telse if (N == 1 && M == 1) {\n\t\t\t\tyesf = 1;// 絶対分離できる\n\t\t\t}\n\t\t\telse if(N==1){// 2 and 1;\n\t\t\t\tyesf = !isis_sp(L2, B[0]);\n\t\t\t}\n\t\t\telse if (M == 1) {\n\t\t\t\tyesf = !isis_sp(L1, W[0]);\n\t\t\t}\n\t\t}\n\t\telse {// convex hull \n\t\t\t// B \n\n\t\t\tPolygon Bgraph = convex_hull(B);\n\t\t\t\t//線分交錯\n\t\t\tFOR(i, 0, SZ(Bgraph)) {\n\t\t\t\tLine BB(Bgraph[i], Bgraph[(i + 1) % (SZ(Bgraph))]);\n\t\t\t\tFOR(j, 0, SZ(W)) {\n\t\t\t\t\tFOR(k, j + 1, SZ(W)) {\n\t\t\t\t\t\tLine WW(W[j],W[k]);\n\t\t\t\t\t\tif (isis_ss(BB,WW)) {\n\t\t\t\t\t\t\tyesf = 0;// 交錯したらダメ\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t// 点内包\n\t\t\tFOR(i, 0, SZ(W)) {\n\t\t\t\tif (contains(Bgraph, W[i]) == 2) {\n\t\t\t\t\tyesf = 0;\n\t\t\t\t}\n\t\t\t}\n\n\n\n\n\t\t\t// N (copy)\n\t\t\tPolygon Wgraph = convex_hull(W);\n\t\t\t\t//線分交錯\n\t\t\tFOR(i, 0, SZ(Wgraph)) {\n\t\t\t\tLine WW(Wgraph[i], Wgraph[(i + 1) % (SZ(Wgraph))]);\n\t\t\t\tFOR(j, 0, SZ(B)) {\n\t\t\t\t\tFOR(k, j + 1, SZ(B)) {\n\t\t\t\t\t\tLine BB(B[j], B[k]);\n\t\t\t\t\t\tif (isis_ss(BB, WW)) {\n\t\t\t\t\t\t\tyesf = 0;// 交錯したらダメ\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 点内包\n\t\t\tFOR(i, 0, SZ(B)) {\n\t\t\t\tif (contains(Wgraph, B[i]) == 2) {\n\t\t\t\t\tyesf = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ((yesf) ? \"YES\" : \"NO\") << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  int b, w;\n  while(cin>>b>>w && (b != 0 || w != 0)){\n    vector<double> x1(b), y1(b);\n    vector<double> x2(w), y2(w);\n    REP(i, b)cin>>x1[i]>>y1[i];\n    REP(i, w)cin>>x2[i]>>y2[i];\n    bool ans = false;\n    REP(time, 1000000){\n      const double D = 100000.0;\n      double t = (double)rand()/RAND_MAX * D * ((rand() % 2) ?  1 : -1);\n      double min_b = 1e30, max_b = -1e30;\n      double min_w = 1e30, max_w = -1e30;\n      REP(i, b){\n        double d = (y1[i] + t)/x1[i];\n        min_b = min(min_b, d);\n        max_b = max(max_b, d);\n      }\n      REP(i, w){\n        double d = (y2[i] + t)/x2[i];\n        min_w = min(min_w, d);\n        max_w = max(max_w, d);\n      }\n      if(min_w > max_b) ans = true;\n      if(min_b > max_w) ans = true;\n      if(ans) break;\n    }\n    if(ans) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___STD_GEOMETRY\n#define ___STD_GEOMETRY\n\n#include <cmath>\n\n#define EPS 1e-13L\n\n#endif\n\n#ifndef ___Class_Point\n#define ___Class_Point\n\nclass Point\n{\npublic:\n\n\t// ------ Variable ------ //\n\n\tlong double x, y;\n\n\n\t// ------ Constructor ------ //\n\n\tPoint() : x(0), y(0) { }\n\n\texplicit Point(long double x, long double y) : x(x), y(y) { }\n\n\n\t// ------ Operator ------ //\n\n\tfriend bool operator==(Point& p1, Point& p2) { return p1.x == p2.x && p1.y == p2.y; }\n\tfriend bool operator!=(Point& p1, Point& p2) { return p1.x != p2.x || p1.y != p2.y; }\n};\n\nlong double distance(const Point& p1, const Point& p2)\n{\n\treturn sqrtl((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));\n}\n\n#endif\n\n#ifndef ___Class_Vector\n#define ___Class_Vector\n\nclass Vector\n{\npublic:\n\n\t// ------ Variable ------ //\n\n\tlong double x, y;\n\n\n\t// ------ Constructor ------ //\n\n\tVector() : x(0), y(0) { }\n\n\texplicit Vector(long double x, long double y) : x(x), y(y) { }\n\n\texplicit Vector(Point p1, Point p2) : x(p2.x - p1.x), y(p2.y - p1.y) { }\n\n\texplicit Vector(long double sx, long double tx, long double sy, long double ty) : x(tx - sx), y(ty - sy) { }\n\n\n\t// ------ Operator ------ //\n\n\tVector operator+() const { return Vector(+x, +y); }\n\tVector operator-() const { return Vector(-x, -y); }\n\n\tVector& operator+=(const Vector& v) { x += v.x; y += v.y; return *this; }\n\tVector& operator-=(const Vector& v) { x -= v.x; y -= v.y; return *this; }\n\n\tfriend bool operator==(const Vector& v1, const Vector& v2) { return -EPS < v1.x - v2.x && v1.x - v2.x < EPS && -EPS < v1.y - v2.y && v1.y - v2.y < EPS; }\n\tfriend bool operator!=(const Vector& v1, const Vector& v2) { return !(v1 == v2); }\n\n\tfriend Vector operator+(const Vector& v1, const Vector& v2) { return Vector(v1.x + v2.x, v1.y + v2.y); }\n\tfriend Vector operator-(const Vector& v1, const Vector& v2) { return Vector(v1.x - v2.x, v1.y - v2.y); }\n\n\tfriend Vector operator*(double d, const Vector& v) { return Vector(d * v.x, d * v.y); }\n\tfriend Vector operator*(const Vector& v, double d) { return Vector(d * v.x, d * v.y); }\n\tfriend Vector operator/(const Vector& v, double d) { return Vector(v.x / d, v.y / d); }\n\n\n\t// ------ Function ------ //\n\n\tlong double norm() { return x * x + y * y; }\n\n\tlong double abs() { return sqrtl(x * x + y * y); }\n\n\tlong double angle() { return atan2l(y, x); }\n};\n\nlong double angle(const Vector& v1, const Vector& v2)\n{\n\tlong double A = atan2l(v2.y, v2.x) - atan2l(v1.y, v1.x);\n\n\tif (180.0L - EPS < A && A < 180.0L + EPS) { return 180.0L; }\n\n\tif (-180.0L - EPS < A && A < -180.0L + EPS) { return 180.0L; }\n\n\tif (A > 180.0L - EPS) { return A - 360.0L; }\n\n\tif (A < -180.0L + EPS) { return A + 360.0L; }\n\n\treturn A;\n}\n\nlong double norm(const Vector& v1)\n{\n\treturn v1.x * v1.x + v1.y * v1.y;\n}\n\nlong double abs(const Vector& v1)\n{\n\treturn sqrt(norm(v1));\n}\n\nlong double cross(const Vector& v1, const Vector& v2)\n{\n\treturn v1.x * v2.y - v1.y * v2.x;\n}\n\nlong double dot(const Vector& v1, const Vector& v2)\n{\n\treturn v1.x * v2.x + v1.y * v2.y;\n}\n\nlong double distance(const Vector& v1, const Vector& v2)\n{\n\treturn sqrtl((v2.x - v1.x) * (v2.x - v1.x) + (v2.y - v1.y) * (v2.y - v1.y));\n}\n\n#endif\n\nbool Triangle_Inside(Vector Tp1, Vector Tp2, Vector Tp3, Vector p) // Triangle is Counter-Clockwise\n{\n\tbool ok1 = angle(p - Tp1, Tp2 - Tp1) < 0 && angle(Tp2 - Tp1, p - Tp1) < angle(Tp2 - Tp1, Tp3 - Tp1);\n\tbool ok2 = angle(p - Tp2, Tp3 - Tp2) < 0 && angle(Tp3 - Tp2, p - Tp2) < angle(Tp3 - Tp2, Tp1 - Tp2);\n\tbool ok3 = angle(p - Tp3, Tp1 - Tp3) < 0 && angle(Tp1 - Tp3, p - Tp3) < angle(Tp1 - Tp3, Tp2 - Tp3);\n\n\treturn ok1 && ok2 && ok3;\n}\n\nbool On_Segment(Vector Sp1, Vector Sp2, Vector p)\n{\n\treturn (Sp1 + Sp2) / 2 == p;\n}\n\nint Counter_Clockwise(Vector p1, Vector p2, Vector p3)\n{\n\tVector a = p2 - p1;\n\tVector b = p3 - p1;\n\n\tif (cross(a, b) > EPS) { return 1; }\n\tif (cross(a, b) < -EPS) { return -1; }\n\n\tif (dot(a, b) < -EPS) { return 2; }\n\n\tif (a.norm() < b.norm()) { return -2; }\n\n\treturn 0;\n}\n\nbool Intersection(Vector p1, Vector p2, Vector p3, Vector p4)\n{\n\tint ok1 = Counter_Clockwise(p1, p2, p3) * Counter_Clockwise(p1, p2, p4);\n\tint ok2 = Counter_Clockwise(p3, p4, p1) * Counter_Clockwise(p3, p4, p2);\n\n\treturn ok1 <= 0 && ok2 <= 0;\n}\n\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tint N, M, X, Y;\n\n\tcin >> N >> M;\n\n\tvector<Vector> W(N);\n\tvector<Vector> B(M);\n\n\tfor (int i = 0; i < N; i++) { cin >> X >> Y; W[i] = Vector(X, Y); }\n\tfor (int i = 0; i < M; i++) { cin >> X >> Y; B[i] = Vector(X, Y); }\n\n\tbool ok = true;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = i + 1; j < N; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < M; k++)\n\t\t\t{\n\t\t\t\tif (On_Segment(W[i], W[j], B[k]) == true)\n\t\t\t\t{\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < M; i++)\n\t{\n\t\tfor (int j = i + 1; j < M; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tif (On_Segment(B[i], B[j], W[k]) == true)\n\t\t\t\t{\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ok = true)\n\t{\n\t\tif (N > 2 || M > 2)\n\t\t{\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = j + 1; k < N; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int l = 0; l < M; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (Triangle_Inside(W[i], W[j], W[k], B[l]) == true)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < M; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < M; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = j + 1; k < M; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int l = 0; l < N; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (Triangle_Inside(B[i], B[j], B[k], W[l]) == true)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (N == 2 && M == 2)\n\t\t{\n\t\t\tok = (Intersection(W[0], W[1], B[0], B[1]) == true ? false : true);\n\t\t}\n\t}\n\n\tcout << (ok == true ? \"YES\" : \"NO\") << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//??????????????????????????????\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\nusing namespace std;\ntypedef complex<double> Point;\n \nnamespace std {\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n \ndouble cross(Point u, Point v) {\n    return u.real() * v.imag() - u.imag() * v.real();\n}\n \ndouble dot(Point u, Point v) {\n    return u.real() * v.real() + u.imag() * v.imag();\n}\n \n//Define : e_Re(???), e_Im(???)\n//a -> b -> counter clockwise -> c ???  1\n//a -> b -> clockwise -> c         ??? -1\n//c--a--b  ???  2\n//a--b--c  ??? -2\n//a--b(=c) ???  0\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0) return 1;\n    if (cross(b, c) < 0) return -1;\n    if (dot(b, c) < 0) return 2;\n    if (norm(b) < norm(c)) return -2;\n    return 0;\n}\n \n//counter clockwise, ring buffer(ch[0] == ch[last])\nvector<Point> convex_hull(vector<Point> points) {\n    int n = points.size();\n    int k = 0;\n    vector<Point> ch(2 * n);\n     \n    sort(points.begin(), points.end());\n     \n    //lower hull\n    for (int i = 0; i < n; i++) {\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], points[i]) <= 0) k--;\n        ch[k] = points[i];\n        k++;\n    }\n     \n    //upper hull\n    int low_k = k;\n    for (int i = n - 1; i >= 0; i--) {\n        while (k > low_k && ccw(ch[k - 2], ch[k - 1], points[i]) <= 0) k--;\n        ch[k] = points[i];\n        k++;\n    }\n    ch.resize(k);\n    return ch;\n}\n \n//If line (a->b), (c->d) are hit with a point, return true.\nbool is_hit_line(Point a, Point b, Point c, Point d) {\n    double u = cross(b - a, c - a) * cross(b - a, d - a);\n    double v = cross(d - c, a - c) * cross(d - c, b - c);\n    if (u > 0 || v > 0) return false;\n    if (u != 0 || v != 0) return true;\n     \n    if (b < a) swap(a, b);\n    if (d < c) swap(c, d);\n     \n    double eps = 1e-10;\n    if (abs(d - a) + eps > abs(b - a) + abs(d - c)) return false;\n    return true;\n}\n \n//poly1, poly2 is convex polygon.\nbool is_hit(vector<Point> poly1, vector<Point> poly2) {\n    for (int i = 0; i < (int)poly1.size() - 1; i++) {\n        for (int j = 0; j < (int)poly2.size() - 1; j++) {\n            if (is_hit_line(poly1[i], poly1[i + 1], poly2[j], poly2[j + 1])) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n \nbool is_cover(vector<Point> poly, Point point) {\n    bool in = false;\n    for (int i = 0; i < (int)poly.size() - 1; i++) {\n        Point a = poly[i] - point;\n        Point b = poly[i + 1] - point;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b) && cross(a, b) > 0) in = !in;\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return false;    //on poly\n    }\n    return in;\n}\n \nint main() {\n    int n, m;\n    while (cin >> n >> m) {\n        if (!n) break;\n         \n        vector<Point> poly1, poly2;\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            cin >> x >> y;\n            poly1.push_back(Point((double)x, (double)y));\n        }\n        for (int i = 0; i < m; i++) {\n            int x, y;\n            cin >> x >> y;\n            poly2.push_back(Point((double)x, (double)y));\n        }\n        poly1 = convex_hull(poly1);\n        poly2 = convex_hull(poly2);\n         \n        if (is_hit(poly1, poly2) || is_cover(poly1, poly2[0]) || is_cover(poly2, poly1[0])) { cout << \"NO\" << endl; }\n        else { cout << \"YES\" << endl; }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define EPS 0.000001\ntypedef long double ld;\n\n//FILE *in = freopen(\"input.txt\", \"r\", stdin);\n\nstruct P {\n\tld x, y;\n\tP(ld x, ld y):x(x),y(y){}\n\tP(){}\n};\n\nP operator -(const P &a, const P &b) { return P(a.x-b.x, a.y-b.y); }\nbool operator <(const P &a, const P &b){ return make_pair(a.x, a.y) < make_pair(b.x, b.y); }\n\nld cross(const P &a, const P &b) { return a.x*b.y-a.y*b.x; }\nld dot(const P &a, const P &b) { return a.x*b.x+a.y*b.y; }\nld norm(const P &a) { return dot(a,a); }\nint ccw(P a, P b, P c) {\n\tb = b - a; c = c - a;\n\tif(cross(b,c) > EPS) return 1;\n\tif(cross(b,c) < EPS) return -1;\n\tif(dot(b,c) < 0) return 2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nstruct L:vector<P>{\n\tL(P a=P(0,0), P b=P(0,0)) {\n\t\tthis->push_back(a);\n\t\tthis->push_back(b);\n\t}\n};\n\nbool is_intersect_SS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0],s[1],t[1]) <= 0 &&\n\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\n\nvector<P> convex_hull(vector<P> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<P> ch(2*n);\n\tfor(int i = 0; i < n; ch[k++]=ps[i++])\n\t\twhile(k >= 2 && ccw(ch[k-2],ch[k-1],ps[i]) <= 0)--k;\n\tfor(int i = n-2, t = k+1; i >= 0; ch[k++]=ps[i--])\n\t\twhile(k>=t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0)--k;\n\tch.resize(k-1);\n\treturn ch;\n}\n\nint n, m;\nvector<P> black;\nvector<P> white;\n\nvoid input() {\n\tblack.clear();\n\twhite.clear();\n\trep(i, n) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tblack.push_back(P(x,y));\n\t}\n\trep(i, m) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\twhite.push_back(P(x,y));\n\t}\n}\n\nvoid process() {\n\tauto b = convex_hull(black);\n\tauto w = convex_hull(white);\n\tblack = b.size() == 0 ? black : b;\n\twhite = w.size() == 0 ? white : w;\n\twhite.push_back(white[0]);\n\n\t// Check LP\n\trep(i,black.size()) {\n\t\tL x(black[i], P(black[i].x+1,black[i].y+20001));\n\t\tint cnt = 0;\n\t\trep(j,white.size()-1) {\n\t\t\tL y(white[j], white[j+1]);\n\t\t\tcnt += is_intersect_SS(x,y);\n\t\t}\n\t\tif(cnt%2 == 1) {\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tblack.push_back(black[0]);\n\n\t// Check cross LL\n\trep(i,black.size()-1) {\n\t\tL x(black[i],black[i+1]);\n\t\trep(j,white.size()-1){\n\t\t\tL y(white[j], white[j+1]);\n\t\t\tif(is_intersect_SS(x,y)) {\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"YES\\n\");\n}\n\nint main() {\n\twhile(true) {\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(!n) break;\n\t\tinput();\n\t\tprocess();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iomanip>\n\n#define REP(i,n) for(i=0; i < (n); i++)\n#define REPONE(i, n) for(i=1; i <= (n); i++)\n#define LOOP(n) for(int loopCount=1; loopCount <= (n); loopCount++)\n#define ITER(c) __typeof((c).begin())\n#define EACH(c,it) for(ITER(c) it =(c).begin(); it!=(c).end(); it++)\n#define SZ(c) ((int) (c).size())\n#define ALL(c) c.begin(), c.end()\n#define SUM(c) accumulate(ALL(c), 0)\n#define EXIST(c,v) (find(ALL(c), (v)) != (c).end())\n#define PB push_back\n#define MP make_pair\n\nusing namespace std;\nstatic const double EPS = 1e-8;\nstatic const double PI = 3.141592653589793238462643383279;\n\ntypedef complex<double> point;\n\ntemplate<typename T>\nint sig2(T x){\n    if(abs(x)<EPS) return 0;\n    if(x>0) return 1;\n    return -1;\n}\n\ndouble det(point p1, point p2, point q){\n    return p2.real()*q.imag()+p1.real()*p2.imag()+q.real()*p1.imag()\n            -p2.real()*p1.imag()-q.real()*p2.imag()-q.imag()*p1.real();\n}\n\nint main(){\n    int i,j,k,n,m;\n    double x,y,bxma,byma,bxmi,bymi,wxma,wyma,wxmi,wymi;\n    bool yes;\n    while(scanf(\"%d%d\",&n,&m)){\n        if(n==0 && m==0) break;\n        bxma=byma=wxma=wyma=-1e99;\n        bxmi=bymi=wxmi=wymi=1e99;\n        yes=false;\n        vector<point> bs(n), ws(m);\n        REP(i,n){\n            scanf(\"%lf%lf\",&x,&y);\n            bs[i]=point(x,y);\n            bxma=max(bxma, x);\n            byma=max(byma, y);\n            bxmi=min(bxmi, x);\n            bymi=min(bymi, y);\n        }\n        REP(i,m){\n            scanf(\"%lf%lf\",&x,&y);\n            ws[i]=point(x,y);\n            wxma=max(wxma, x);\n            wyma=max(wyma, y);\n            wxmi=min(wxmi, x);\n            wymi=min(wymi, y);\n        }\n        if(bxma<wxmi||bxmi>wxma||byma<wymi||bymi>wyma){\n            printf(\"YES\\n\");\n            continue;\n        }\n        if(n==1 && m==1){\n            printf(\"YES\\n\");\n            continue;\n        }\n        int w=0, b;\n        REP(i,n)for(j=i+1;j<n;j++){\n            w = 0;\n            REP(k,m) w+=sig2(det(bs[i],bs[j],ws[k]));\n            if(abs(w)<m)break;\n            REP(k,n)if(sig2(det(bs[i],bs[j],bs[k]))==sig2(w))break;\n            if(k==n){\n                yes = true;\n                goto end;\n            }\n        }\n        swap(n,m);\n        swap(bs,ws);\n        REP(i,n)for(j=i+1;j<n;j++){\n            w = 0;\n            REP(k,m) w+=sig2(det(bs[i],bs[j],ws[k]));\n            if(abs(w)<m)break;\n            REP(k,n)if(sig2(det(bs[i],bs[j],bs[k]))==sig2(w))break;\n            if(k==n){\n                yes = true;\n                goto end;\n            }\n        }\n        REP(i,n)REP(j,m){\n            w = b = 0;\n            REP(k,m) w+=sig2(det(bs[i],ws[j],ws[k]));\n            if(abs(w)<m-1)break;\n            REP(k,n) b+=sig2(det(bs[i],ws[j],bs[k]));\n            if(abs(b)<n-1)break;\n            if(w*b<0){\n                yes = true;\n                goto end;\n            }\n        }\n        end:;\n        if(yes)printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n    return 0;\n}\n\n/*\n#define N 10000\n\nint main(){\n    int i,j,n,m;\n    double x,y,bma,bmi,wma,wmi;\n    point tmp;\n    while(scanf(\"%d%d\",&n,&m)){\n        if(n==0 && m==0) break;\n        vector<point> bs(n), ws(m);\n        REP(i,n){\n            scanf(\"%lf%lf\",&x,&y);\n            bs[i] = point(x,y);\n        }\n        REP(i,m){\n            scanf(\"%lf%lf\",&x,&y);\n            ws[i] = point(x,y);\n        }\n        REP(i,N){\n            bma=wma=-1e99;\n            bmi=wmi=1e99;\n            REP(j,n){\n                tmp = bs[j]*polar(1.0,i*PI/(N>>1));\n                bma = max(bma,tmp.real());\n                bmi = min(bmi,tmp.real());\n            }\n            REP(j,m){\n                tmp = ws[j]*polar(1.0,i*PI/(N>>1));\n                wma = max(wma,tmp.real());\n                wmi = min(wmi,tmp.real());\n            }\n            if(bma < wmi || wma < bmi) break;\n        }\n        if(i==N)printf(\"NO\\n\");\n        else printf(\"YES\\n\");\n    }\n    return 0;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<complex>\n#define Re real()\n#define Im imag()\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\ntypedef vector<Point> Polygon;\nconst double eps = 1e-10;\n\nPoint black[105], white[105];\nPolygon bp, wp;\nint n, m, bpl, wpl;\n\nbool cmp(Point a, Point b)\n{\n    if(fabs(a.Re - b.Re) < eps) return a.Im < b.Im;\n    else return a.Re < b.Re;\n}\n\ndouble cross(const Point& a, const Point& b)\n{\n    return (conj(a) * b).Im;\n}\n\ndouble dot(const Point& a, const Point& b)\n{\n    return (conj(a) * b).Re;\n}\n\nvoid convex_hull()\n{\n    bp.resize(2 * n);\n    bpl = 0;\n    for(int i = 0; i < n; i++)\n    {\n        while(bpl > 1 && cross(bp[bpl - 1] - bp[bpl - 2], black[i] - bp[bpl - 1]) < 0) bpl--;\n        bp[bpl++] = black[i];\n    }\n    for(int i = n - 2, t = bpl; i >= 0; i--)\n    {\n        while(bpl > t && cross(bp[bpl - 1] - bp[bpl - 2], black[i] - bp[bpl - 1]) < 0) bpl--;\n        bp[bpl++] = black[i];\n    }\n    bp.resize(bpl - 1);\n    wp.resize(2 * m);\n    wpl = 0;\n    for(int i = 0; i < m; i++)\n    {\n        while(wpl > 1 && cross(wp[wpl - 1] - wp[wpl - 2], white[i] - wp[wpl - 1]) < 0) wpl--;\n        wp[wpl++] = white[i];\n    }\n    for(int i = m - 2, t = wpl; i >= 0; i--)\n    {\n        while(wpl > t && cross(wp[wpl - 1] - wp[wpl - 2], white[i] - wp[wpl - 1]) < 0) wpl--;\n        wp[wpl++] = white[i];\n    }\n    wp.resize(wpl - 1);\n}\n\nint ccw(Point& a, Point& b, Point& c)\n{\n    Point t1 = b - a, t2 = c - a;\n    if(cross(t1, t2) > 0)   return +1;        // counter clockwise\n    if(cross(t1, t2) < 0)   return -1;        // clockwise\n    if(dot(t1, t2) < 0)     return +2;        // c--a--b on line\n    if(norm(t1) < norm(t2)) return -2;        // a--b--c on line\n    return 0;\n}\n\nbool is_point_intersaction(Point a, pair <Point, Point> b)\n{\n    return (fabs( dot(b.first - a, b.second - a) - (-1.0 * sqrt(norm(b.first - a) * norm(b.second - a))) < eps));\n}\n\nbool isintersaction(pair <Point, Point> a, pair <Point, Point> b)\n{\n    return (ccw(b.first, b.second, a.first) * ccw(b.first, b.second, a.second) <= 0 && ccw(a.first, a.second, b.first) * ccw(a.first, a.second, b.second) <= 0);\n}\n\n// 0 --- out of the polygon, 1 -- on the polygon, 2 -- in the polygon\nint checkin(const Point& t, Polygon s)\n{\n    int cnt = 0;\n    for(int i = 0; i < s.size(); i++)\n    {\n        Vector v1 = s[i] - t, v2 = s[(i + 1) % s.size()] - t;\n        if(v1.Im > v2.Im) swap(v1, v2);\n        if(v1.Im <= 0 && v2.Im > 0 && cross(v1, v2) < 0) cnt ^= 1;\n        if(cross(v1, v2) == 0 && dot(v1, v2) <= 0) return 1;\n    }\n    return cnt ? 2 : 0;\n}\n\nbool check()\n{\n    int flag = 0, f1 = 0, f2 = 0;\n    for(int i = 0; i < bp.size(); i++)\n        if(checkin(wp[i], bp) == 1 || checkin(wp[i], bp) == 2) f1 = 1;\n    for(int i = 0; i < wp.size(); i++)\n        if(checkin(bp[i], wp) == 1 || checkin(bp[i], wp) == 2) f2 = 1;\n    flag = f1 | f2;\n    if(flag == 1) return false;\n    else\n    {\n        for(int i = 0; i < bp.size(); i++)\n        {\n            for(int j = 0; j< wp.size(); j++)\n            {\n                if( isintersaction( make_pair(bp[(i+1)%bp.size()],bp[i]), make_pair(wp[(j+1)%wp.size()],wp[j])))\n                    return false;\n            }\n        }\n        return true;\n    }\n}\n\nint main()\n{\n    while(~scanf(\"%d%d\", &n, &m), n + m)\n    {\n        for(int i = 0; i < n; i++)\n        {\n            double tx, ty;\n            scanf(\"%lf %lf\", &tx, &ty);\n            black[i] = Point(tx, ty);\n        }\n        for(int i = 0; i < m; i++)\n        {\n            double tx, ty;\n            scanf(\"%lf %lf\", &tx, &ty);\n            white[i] = Point(tx, ty);\n        }\n        if(n >= 3 || m >= 3)\n        {\n            convex_hull();\n            if(check()) printf(\"YES\\n\");\n            else printf(\"NO\\n\");\n        }\n        else if(n == 1 && m == 1)\n            printf(\"YES\\n\");\n        else if(n == 1 && m == 2)\n        {\n            bool flag = is_point_intersaction(black[0], make_pair(white[0], white[1]));\n            if(flag) printf(\"NO\\n\");\n            else printf(\"YES\\n\");\n        }\n        else if(n == 2 && m == 1)\n        {\n            bool flag = is_point_intersaction(white[0], make_pair(black[0], black[1]));\n            if(flag) printf(\"NO\\n\");\n            else printf(\"YES\\n\");\n        }\n        else if(n == 2 && m == 2)\n        {\n            bool flag = isintersaction(make_pair(white[0], white[1]), make_pair(black[0], black[1]));\n            if(flag) printf(\"NO\\n\");\n            else printf(\"YES\\n\");\n        }\n    }\n    return 0;\n}\n/*\n\n3 3\n100 700\n200 200\n600 600\n500 100\n500 300\n800 500\n3 3\n100 300\n400 600\n400 100\n600 400\n500 900\n300 300\n3 4\n300 300\n500 300\n400 600\n100 100\n200 900\n500 900\n800 100\n1 2\n300 300\n100 100\n500 500\n1 1\n100 100\n200 100\n2 2\n0 0\n500 700\n1000 1400\n1500 2100\n2 2\n0 0\n1000 1000\n1000 0\n0 1000\n3 3\n0 100\n4999 102\n10000 103\n5001 102\n10000 102\n0 101\n3 3\n100 100\n200 100\n100 200\n0 0\n400 0\n0 400\n3 3\n2813 1640\n2583 2892\n2967 1916\n541 3562\n9298 3686\n7443 7921\n0 0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\ntypedef int D;\nusing namespace std;\nconst D EPS = 0;\nstruct P {\n  D x, y;\n  P() {}\n  P(D x_, D y_) : x(x_), y(y_) {}\n};\n\nstruct L {\n  P a, b;\n  L() {}\n  L(P a_, P b_) : a(a_), b(b_) {}\n};\n\nstruct C {\n  P p; D r;\n  C() {}\n  C(P p_, D r_) : p(p_), r(r_) {}\n};\nP operator +(P a, P b) { return P(a.x + b.x, a.y + b.y);}\nP operator -(P a, P b) { return P(a.x-b.x, a.y-b.y);}\nP operator *(P a, D b) { return P(a.x * b, a.y * b); }\nP operator /(P a, D b) { return P(a.x / b, a.y/b); }\nP vec(P from, P to) { return to-from;}\nD inp(P a, P b) {return a.x*b.x + a.y*b.y;}\nD outp(P a, P b) {return a.x*b.y - a.y*b.x;}\nD norm(P p) {return inp(p, p);}\nD abs(P p) {return sqrt(norm(p)); }\nint sig(D a, D b) {\n  if (a<b - EPS) return -1;\n  if (a>b + EPS) return +1;\n  return 0;\n}\n\nint ccw(P a, P b, P c) {\n  b = vec(a, b); c = vec(a, c);\n  if(sig(outp(b, c), 0.0) > 0) return +1;\n  if(sig(outp(b, c), 0.0) < 0) return -1;\n  if(sig(inp(b, c), 0.0) < 0) return +2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\nbool iSP(L s, P p) {\n    return ccw(s.a, s.b, p) == 0;\n}\nbool iSS(L s, L t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\ntypedef vector<P> G;\nbool operator <(P a, P b) {\n  if(sig(a.x, b.x) != 0) return a.x < b.x;\n  return a.y < b.y;\n}\nG convex_hull(vector<P> ps) {\n  int N = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  G res(N*2);\n  for(int i = 0; i < N; i++) {\n    while(k >= 2 && ccw(res[k - 2], res[k - 1], ps[i]) <= 0) k--;\n    res[k++] = ps[i];\n  }\n  int t = k + 1;\n  for(int i = N - 2; i >= 0; i--) {\n    while(k >= t && ccw(res[k - 2], res[k - 1], ps[i]) <= 0) k--;\n    res[k++] = ps[i];\n  }\n  res.resize(k - 1);\n  return res;\n}\n\nint main() {\n  while(true) {\n    int N, M;\n    cin >> N >> M;\n    if(N == 0 && M == 0) break;\n    vector<P> black(N);\n    vector<P> white(M);\n    for(int i = 0; i < N; i++) {\n      cin >> black[i].x >> black[i].y;\n    }\n    for(int i = 0; i < M; i++) {\n      cin >> white[i].x >> white[i].y;\n    }\n    if(N == 1 && M == 1) {\n      cout << \"YES\" << endl;\n      continue;\n    }\n    bool ok = false;\n    G bh = convex_hull(black);\n    for(int i = 0; i < (int)bh.size(); i++) {\n      P a = bh[i]; P b = bh[(i + 1) % bh.size()];\n      // cerr << \"line(\" << a.x << \",\" << a.y << \",\" << b.x << \",\" << b.y << \");\" << endl;\n      bool f = true;\n      for(int j = 0; j < M; j++) {\n        if(ccw(a, b, white[j]) != -1) f = false;\n      }\n      if(f) ok = true;\n    }\n    G wh = convex_hull(white);\n    for(int i = 0; i < (int)wh.size(); i++) {\n      P a = wh[i]; P b = wh[(i + 1) % wh.size()];\n      // cerr << \"line(\" << a.x << \",\" << a.y << \",\" << b.x << \",\" << b.y << \");\" << endl;\n      bool f = true;\n      for(int j = 0; j < N; j++) {\n        if(ccw(a, b, black[j]) != -1) f = false;\n      }\n      if(f) ok = true;\n    }\n\n    if(bh.size()==2 && wh.size()==2) {\n      if(iSS(L(bh[0],bh[1]),L(wh[0],wh[1])) == false) ok = true;\n    }\n    if(bh.size()==1 && wh.size()==2) {\n      if(iSP(L(wh[0],wh[1]), bh[0]) == false) ok = true;\n    }\n    if(bh.size()==2 && wh.size()==1) {\n      if(iSP(L(bh[0],bh[1]), wh[0]) == false) ok = true;\n    }\n    cout << (ok?\"YES\":\"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\n\nconst double EPS = 1e-8;\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\n// ???????????? a,b ???????????¢???\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\n// ????????¨?????????????????????????????????????????????true???\nbool isIntersect(L s1, L s2){\n  \n  //ccw ??????????????????????????¨, ????????????????????´?????????????????¨??????????????????????????????\n  if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\n// ????????¨??????????????????\nbool isIntersectSP(L s, P p){ \n  return abs(s.first-p) + abs(s.second-p) - abs(s.second-s.first) < EPS; \n}\n\nvector<P> convex_hull2(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nint main(){\n  \n  while(1){\n    \n    int n,m;\n    cin>>n>>m;\n    if(!n&&!m)break;\n  \n    vector<P> B(n),W(m);\n  \n    int x,y;\n  \n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      B[i]=P(x,y);\n    }\n\n    for(int i=0;i<m;i++){\n      cin>>x>>y;\n      W[i]=P(x,y);\n    }\n    \n    bool ans=true;\n      \n    if(n<=3&&m<=3){\n        \n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++){\n\t  if(i==j) continue;\n\t\n\t  for(int k=0;k<m;k++)\n\t    for(int l=0;l<m;l++){\n\t      if(k==l) continue;\n\t    \n\t      if(isIntersect(L(B[i],B[j]),L(W[k],W[l]))) ans=false;\n\t    \n\t    }\n\t}\n    }\n    \n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tif(i==j) continue;\n\n\tfor(int k=0;k<m;k++)\n\t  if(isIntersectSP(L(B[i],B[j]),W[k])) ans=false;\n      }\n\n    for(int i=0;i<m;i++)\n      for(int j=0;j<m;j++){\n\tif(i==j) continue;\n\n\tfor(int k=0;k<n;k++)\n\t  if(isIntersectSP(L(W[i],W[j]),B[k])) ans=false;\n      }\n\n    vector<P> B2=convex_hull2(B);\n\n    int f=0,flag=1;\n      \n    for(int i=0;i<B2.size();i++){\n      for(int j=0;j<W.size();j++){\n\tint ip=(i+1)%B2.size();\n\tif(ccw(B2[i],B2[ip],W[j])==-1) flag=0;\n\t//\tcout<<ccw(B2[i],B2[ip],W[j])<<endl;\n      }\n    }\n\n    if(B2.size()>=3&&flag) ans=false;\n    \n    vector<P> W2=convex_hull2(W);\n    \n    f=0;\n    flag=1;\n    \n    for(int i=0;i<W2.size();i++){\n      for(int j=0;j<B.size();j++){\n\tint ip=(i+1)%W2.size();\n\tif(ccw(W2[i],W2[ip],B[j])==-1) flag=0;\n\t//\tcout<<ccw(W2[i],W2[ip],B[j])<<endl;\n      }\n    }\n    \n    if(W2.size()>=3&&flag) ans=false;\n    \n    if(ans) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n      \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-9;\n\n\ntemplate<typename T> T add(T x, T y){ if(abs(x+y) < EPS*(abs(x)+abs(y))) return 0; return x + y; }\ntemplate<typename T> inline bool semieq(T x, T y){ return abs(x - y) < EPS; }\ntemplate<typename T> inline bool semige(T x, T y){ return y - x < -EPS; }\ntemplate<typename T> inline bool semile(T x, T y){ return x - y < -EPS; }\n\n\nstruct Point : public complex<double>\n{\npublic:\n  Point(const double x = 0.0, const double y = 0.0) { this->real(x);  this->imag(y); }\n  Point(const complex<double> w)  { this->real(w.real());  this->imag(w.imag()); }\n  inline double dot(Point p){ return (conj(*this) * p).real(); }  // ??????\n  inline double det(Point p){ return (conj(*this) * p).imag(); }  // ??????\n};\n\nnamespace std\n{\n  inline bool operator < (const Point& a, const Point& b)\n  {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ntypedef vector<Point> Polygon;\ninline Point currPoint(vector<Point> P, int i){ return P[i]; }\ninline Point nextPoint(vector<Point> P, int i){ return P[(i+1)%P.size()]; }\ninline Point diffPoint(vector<Point> P, int i){ return nextPoint(P, i) - currPoint(P, i); }\n\nint ccw(Point a, Point b, Point c)\n{\n  b -= a;\n  c -= a;\n  if(b.det(c) > 0.0)    return  1;         // counter clockwise\n  if(b.det(c) < 0.0)    return -1;         // clockwise\n  if(b.dot(c) < 0.0)    return  2;         // c--a--b on line\n  if(norm(b) < norm(c)) return -2;         // a--b--c on line\n  return 0;\n}\n\n\nPolygon AndrewMonotoneChain(vector<Point> ps)\n{\n  int n = ps.size(), k = 0;\n  if(n <= 2) return ps;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2*n);\n  for(int i=0; i<n; ch[k++]=ps[i++]) // lower-hull\n    while(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for(int i=n-2, t=k+1; i>= 0; ch[k++]=ps[i--]) // upper-hull\n    while(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nenum { OUT, ON, IN };\nint convexContains(const Point p, const Polygon P)\n{\n  const int n = P.size();\n  Point g = (P[0] + P[n/3] + P[2*n/3]) / 3.0; // inner-Point\n  int a = 0, b = n;\n  while (a+1 < b) { // invariant: c is in fan g-P[a]-P[b]\n    int c = (a + b) / 2;\n    if (semige(Point(P[a]-g).det(P[c]-g), 0.0)) { // angle < 180 deg\n      if (semige(Point(P[a]-g).det(p-g), 0.0) && semile(Point(P[c]-g).det(p-g), 0.0)) b = c;\n      else a = c;\n    } else {\n      if (semile(Point(P[a]-g).det(p-g), 0.0) && semige(Point(P[c]-g).det(p-g), 0.0)) a = c;\n      else b = c;\n    }\n  }\n  b %= n;\n  if (semile(Point(P[a] - p).det(P[b] - p), 0.0)) return 0;\n  if (semige(Point(P[a] - p).det(P[b] - p), 0.0)) return 2;\n  return 1;\n}\n\n\nbool intersect_1pt(const Point a, const Point b,\n                   const Point c, const Point d, Point& r)\n{\n  double D =  Point(b - a).det(d - c);\n  if (semieq(D, 0.0)) return false;\n  double t =  Point(c - a).det(d - c) / D;\n  double s = -Point(a - c).det(b - a) / D;\n  r = a + t * (b - a);\n  return !semile(t, 0.0) && !semige(t, 1.0) && !semile(s, 0.0) && !semige(s, 1.0);\n}\n\nPolygon convexIntersect(const Polygon P, const Polygon Q)\n{\n  const int n = P.size(), m = Q.size();\n  int a = 0, b = 0, aa = 0, ba = 0;\n  enum { Pin, Qin, Unknown } in = Unknown;\n  Polygon R;\n  do {\n    int a1 = (a+n-1) % n, b1 = (b+m-1) % m;\n    double C = Point(P[a] - P[a1]).det(Q[b] - Q[b1]);\n    double A = Point(P[a1] - Q[b]).det(P[a] - Q[b]);\n    double B = Point(Q[b1] - P[a]).det(Q[b] - P[a]);\n    Point r;\n    if (intersect_1pt(P[a1], P[a], Q[b1], Q[b], r)) {\n      if (in == Unknown) aa = ba = 0;\n      R.push_back( r );\n      in = B > 0 ? Pin : A > 0 ? Qin : in;\n    }\n    if (C == 0 && B == 0 && A == 0) {\n      if (in == Pin) { b = (b + 1) % m; ++ba; }\n      else           { a = (a + 1) % m; ++aa; }\n    } else if (C >= 0) {\n      if (A > 0) { if (in == Pin) R.push_back(P[a]); a = (a+1)%n; ++aa; }\n      else       { if (in == Qin) R.push_back(Q[b]); b = (b+1)%m; ++ba; }\n    } else {\n      if (B > 0) { if (in == Qin) R.push_back(Q[b]); b = (b+1)%m; ++ba; }\n      else       { if (in == Pin) R.push_back(P[a]); a = (a+1)%n; ++aa; }\n    }\n  } while ( (aa < n || ba < m) && aa < 2*n && ba < 2*m );\n  if (in == Unknown) {\n    if (convexContains(P[0], Q)) return P;\n    if (convexContains(Q[0], P)) return Q;\n  }\n  return R;\n}\n\nstruct Line : public vector<Point>\n{\npublic:\n  Line(){ }\n  Line(const Point P, const Point Q){ this->pb(P);  this->pb(Q); }\n  Line(double px, double py, double qx, double qy){ this->pb(Point(px, py));  this->pb(Point(qx, qy)); }\n};\ntypedef Line Segment;\n\n\ninline bool intersectionDeterminationOfSS(Segment S, Segment T){return ccw(S[0],S[1],T[0])*ccw(S[0],S[1],T[1])<=0&&ccw(T[0],T[1],S[0])*ccw(T[0],T[1],S[1])<=0;}\ninline bool onSegment(Point P, Segment S){return semieq(Point(S[0]-P).det(S[1]-P),0.0)&&!semige(Point(S[0]-P).dot(S[1]-P),0.0);}\n\n\n\nint n, m;\ndouble x, y;\n\nint main(int argc, char *argv[])\n{\n  while(cin >> n >> m, n + m){\n    vector<Point> B(n);\n    vector<Point> W(m);\n    rep(i, n){\n      cin >> x >> y;\n      B[i] = Point(x, y);\n    }\n    rep(i, m){\n      cin >> x >> y;\n      W[i] = Point(x, y);\n    }\n\n    B = AndrewMonotoneChain(B);\n    W = AndrewMonotoneChain(W);\n    int b = B.size();\n    int w = W.size();\n    if(b > w){\n      swap(B, W);\n      swap(b, w);\n    }\n    if(b == 1 && w == 1){\n      puts(\"YES\");\n      continue;\n    }\n    if(b == 1){\n      bool ok;\n      if(w == 2) ok = onSegment(B[0], Segment(W[0], W[1]));\n      else ok = convexContains(B[0], W);\n      puts(ok ? \"NO\" : \"YES\");\n      continue;\n    }\n    if(b == 2){\n      bool ok = false;\n      if(w == 2) ok = intersectionDeterminationOfSS(Segment(B[0], B[1]), Segment(W[0], W[1]));\n      else{\n        ok = convexContains(B[0], W) || convexContains(B[1], W);\n      }\n      puts(ok ? \"NO\" : \"YES\");\n      continue;\n    }\n    puts(convexIntersect(B, W).size() ? \"NO\" : \"YES\");\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nlong double EPS = (long double)1e-8;\nstruct Point { long double px, py; };\nPoint r1[100], r2[100]; int n, m;\nvector<pair<Point, int>>vec, vec2;\nbool solve(Point a1, Point a2) {\n\tif (a1.px > a2.px)swap(a1, a2);\n\tif (a1.px == a2.px) {\n\t\tint colour = 0;\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tif (colour == 0) {\n\t\t\t\tif (vec2[i].first.px < a1.px) { colour = 3 - vec2[i].second; }\n\t\t\t\tif (vec2[i].first.px == a1.px) { return false; }\n\t\t\t\tif (vec2[i].first.px > a1.px) { colour = vec2[i].second; }\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (colour != 3 - vec2[i].second && vec2[i].first.px < a1.px) { return false; }\n\t\t\t\tif (vec2[i].first.px == a1.px) { return false; }\n\t\t\t\tif (colour != vec2[i].second && vec2[i].first.px > a1.px) { return false; }\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\telse {\n\t\tlong double KT = (a2.py - a1.py) / (a2.px - a1.px);\n\t\tlong double YY = a1.py - a1.px*KT;\n\t\tint colour = 0;\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tlong double height = YY + KT*vec2[i].first.px;\n\t\t\tif (colour == 0) {\n\t\t\t\tif (vec2[i].first.py < height) { colour = 3 - vec2[i].second; }\n\t\t\t\tif (vec2[i].first.py == height) { return false; }\n\t\t\t\tif (vec2[i].first.py > height) { colour = vec2[i].second; }\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (colour != 3 - vec2[i].second && vec2[i].first.py < height) { return false; }\n\t\t\t\tif (vec2[i].first.py == height) { return false; }\n\t\t\t\tif (colour != vec2[i].second && vec2[i].first.py > height) { return false; }\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n\twhile (true) {\n\t\tvec.clear(); vec2.clear(); cin >> n >> m; if (n == 0 && m == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> r1[i].px >> r1[i].py; r1[i].px += 1.0l; r1[i].py += 1.0l; vec2.push_back(make_pair(r1[i], 1));\n\t\t\tfor (long double j = -1.0l; j <= 1.0l; j += 1.0l) {\n\t\t\t\tfor (long double k = -1.0l; k <= 1.0l; k += 1.0l) {\n\t\t\t\t\tvec.push_back(make_pair(Point{ r1[i].px + j*EPS,r1[i].py + k*EPS }, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> r2[i].px >> r2[i].py; r2[i].px += 1.0l; r2[i].py += 1.0l; vec2.push_back(make_pair(r2[i], 2));\n\t\t\tfor (long double j = -1.0l; j <= 1.0l; j += 1.0l) {\n\t\t\t\tfor (long double k = -1.0l; k <= 1.0l; k += 1.0l) {\n\t\t\t\t\tvec.push_back(make_pair(Point{ r1[i].px + j*EPS,r1[i].py + k*EPS }, 2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans = false;\n\t\tfor (int i = 0; i < vec.size(); i++) {\n\t\t\tfor (int j = i + 1; j < vec.size(); j++) {\n\t\t\t\tbool p1 = solve(vec[i].first, vec[j].first);\n\t\t\t\tif (p1 == true)ans = true;\n\t\t\t}\n\t\t}\n\t\tif (ans == true)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return P(imag(a),-real(a));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n  return\n    min4(spdist(a,b.F),spdist(a,b.S),\n         spdist(b,a.F),spdist(b,a.S));\n}\n\n\nP inn[100],inm[100];\nint n,m;\n\nbool ok(line a){\n  //cout << a << endl;\n  rep(i,n){\n    line se(inn[i],inm[0]);\n    if(!onl(se,crspt(se,a))) return false;\n  }\n  rep(i,m){\n    line se(inn[0],inm[i]);\n    if(!onl(se,crspt(se,a))) return false;\n  }\n  return true;\n}\n\nvoid solve(){\n  rep(i,n) cin >> inn[i].real() >> inn[i].imag();\n  rep(i,m) cin >> inm[i].real() >> inm[i].imag();\n\n  rep(i,n)rep(j,m){\n    line a(inn[i],inm[j]);\n    P b=ortho(a);\n    b=b/abs(b)*EPS*10.;\n    a.F+=b;a.S-=b;\n    if(ok(a)){\n      cout << \"YES\" << endl;\n      return;\n    }\n    a.F-=b;a.S+=b;\n    a.F-=b;a.S+=b;\n    if(ok(a)){\n      cout << \"YES\" << endl;\n      return;\n    }\n  }\n  cout << \"NO\" << endl;\n}\n\nint main(){\n  while(cin >> n >> m && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\nstruct makehtml{\n\tvector<string> ss;\n\t\n\tmakehtml(){}\n\t/*\n\tctx.beginPath()\n\tctx.moveTo(50.000000,100.000000);\n\tctx.lineTo(150.000000,100.000000);\n\tctx.stroke();\n\t\n\tctx.fillStyle = \"rgb(0,0,0)\";\n\t\n\tctx.beginPath();\n\tctx.arc(168,59,3,0,360);\n\tctx.fill();\n\n\t*/\n\t\n\tvoid out(const char* name,double mag){\n\t\tchar fname[100];\n\t\tsprintf(fname,\"%s.html\",name);\n\t\tFILE* fp = fopen(fname,\"w\");\n\t\tif(fp==NULL){\n\t\t\teprintf(\"can't open %s\\b\",fname);\n\t\t\texit(-1);\n\t\t}\n\t\tfprintf(fp,\"<html>\\n<head>\\n<title>\");\n\t\tfprintf(fp,\"%s\",name);\n\t\tfprintf(fp,\"</title>\\n</head>\\n<body>\\n\");\n\t\tfprintf(fp,\"<p>name: %s</p>\",name);\n\t\tfprintf(fp,\"<canvas id=\\\"vis\\\" width=\\\"%d\\\" height=\\\"%d\\\"></canvas>\",2000,2000);\n\t\tfprintf(fp,\"<script>\\n\");\n\t\tfprintf(fp,\"var vis = document.getElementById('vis');\\nvar ctx = vis.getContext('2d');\\n\");\n\t\t\n\t\trep(i,ss.size()){\n\t\t\tfprintf(fp,\"%s\\n\",ss[i].c_str());\n\t\t}\n\t\t\n\t\tfprintf(fp,\"</script>\\n\");\n\t\tfprintf(fp,\"</body>\\n</html>\\n\");\n\t\tfclose(fp);\n\t}\n\n} makehtml_instance;\n\n\nvoid addhtml(string s){\n\tmakehtml_instance.ss.push_back(s);\n}\n\nvoid outhtml(string s,double mag){\n\tmakehtml_instance.out(s.c_str(),mag);\n}\n\nvoid randcolhtml(){\n\tchar ns[100];\n\tsprintf(ns,\"ctx.fillStyle = \\\"rgb(%d,%d,%d)\\\";\",rand()%256,rand()%256,rand()%256);\n\taddhtml(ns);\n\tsprintf(ns,\"ctx.strokeStyle = \\\"rgb(%d,%d,%d)\\\";\",rand()%256,rand()%256,rand()%256);\n\taddhtml(ns);\n}\n\nvoid inithtml(){\n\tmakehtml_instance.ss.clear();\n}\n\n\nconst double pi=3.14159265358979;\n\nstruct pos{\n\tdouble x,y;\n\tdouble norm,norm2;\n\tpos tov(pos a){\n\t\treturn (a-(*this));\n\t}\n\tpos operator+(pos a)const{\n\t\tpos res=a;\n\t\tres.x+=x; res.y+=y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos operator-(pos a)const{\n\t\tpos res=(*this);\n\t\tres.x-=a.x; res.y-=a.y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos scalar(double a){\n\t\tpos res=(*this);\n\t\tres.x*=a; res.y*=a;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tdouble dot(pos a){\n\t\treturn x*a.x + y*a.y;\n\t}\n\tdouble cross(pos a){\n\t\treturn x*a.y - y*a.x;\n\t}\n\tdouble theta(pos a){\n\t\tdouble nt=dot(a)/(norm*a.norm);\n\t\tnt=acos(max(-1.0,min(1.0,nt)));\n\t\tdouble ns=(cross(a)/(norm*a.norm));\n\t\tif(ns<0)nt*=-1;\n\t\treturn nt;\n\t}\n\tpos(double ix,double iy){\n\t\tx=ix; y=iy;\n\t\tnorm2=x*x+y*y;\n\t\tnorm=sqrt(norm2);\n\t}\n\tpos(){}\n\tstring str(){\n\t\tchar ns[50];\n\t\tsprintf(ns,\"(%lf %lf)\",x,y);\n\t\treturn\tstring(ns);\n\t}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\"); \n\t\tsprintf(ns,\"ctx.arc(%lf,%lf,%lf,0,360);\",x*mag,y*mag,5.0); addhtml(ns);\n\t\taddhtml(\"ctx.fill();\");\n\t}\n\tstatic pos polar(double r,double t){\n\t\treturn pos(r*cos(t),r*sin(t));\n\t}\n\tpos turn(double t){\n\t\t//t[rad]??????\n\t\treturn pos(x*cos(t)-y*sin(t),x*sin(t)+y*cos(t));\n\t}\n\tpos tolen(double a){\n\t\t//?????????a?????????\n\t\treturn this->scalar(a/norm);\n\t}\n\tbool  operator<(pos a) const{\n\t\t//if(x!=a.x)return (x<a.x);\n\t\t//return (y<a.y);\n\t\tif(y!=a.y)return (y<a.y);\n\t\treturn (x<a.x);\n\t}\t\n\tbool operator>(pos a)const{ return (a<(*this)); }\t\n};\nstruct line{\n\tpos p,q;\n\tpos vec;\n\tstring str(){\n\t\treturn (\"(\"+p.str()+\"-\"+q.str()+\")\");\n\t}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\");\n\t\tsprintf(ns,\"ctx.moveTo(%lf,%lf);\",p.x*mag,p.y*mag); addhtml(ns);\n\t\tsprintf(ns,\"ctx.lineTo(%lf,%lf);\",q.x*mag,q.y*mag); addhtml(ns);\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\tbool iscross(line a){\n\t\tdouble da,db;\n\t\tda=vec.cross( p.tov(a.p) );\n\t\tdb=vec.cross( p.tov(a.q) );\n\t\tif(da*db>=0)return false;\n\t\tda=a.vec.cross( a.p.tov(p) );\n\t\tdb=a.vec.cross( a.p.tov(q) );\n\t\treturn (da*db<0);\n\t}\n\tline(pos ip,pos iq){\n\t\tp=ip; q=iq;\n\t\tvec=p.tov(q);\n\t}\n\tline(){}\n\tdouble dist(pos a){\n\t\tif(p.tov(a).dot( p.tov(q) )<0)return p.tov(a).norm;\n\t\tif(q.tov(a).dot( q.tov(p) )<0)return q.tov(a).norm;\n\t\treturn abs(vec.cross(p.tov(a))/vec.norm);\n\t}\n\tdouble dist(line a){\n\t\tif(iscross(a))return 0;\n\t\treturn min( min(dist(a.p),dist(a.q)) , min(a.dist(this->p),a.dist(this->q)));\n\t}\n\tpos crosspos(line a){\n\t\t/*\n\t\tdouble d1=a.vec.cross(a.p.tov(p))/a.vec.norm;\n\t\tdouble d2=a.vec.cross(a.p.tov(q))/a.vec.norm;\n\t\tbool isc=(d1*d2<0);\n\t\td1=abs(d1); d2=abs(d2);\n\t\tdouble sc;\n\t\tif(!isc){\n\t\t\tif(d1>d2)sc = d1/(d1-d2);\n\t\t\telse sc=d1/(d2-d1);\n\t\t}\n\t\telse sc = d1/(d1+d2);\n\t\treturn (p+vec.scalar(sc));*/\n\t\t\n\t\tdouble t = a.vec.cross(a.p-p)/a.vec.cross(vec);\n\t\treturn (p+vec.scalar(t));\n\t}\n\tline bisection(){//?????´????????????\n\t\t//???????¨??????????90????????£???????????????\n\t\tpos fr=(p+q).scalar(0.5);\n\t\tpos to=fr+pos(-vec.y,vec.x);\n\t\treturn line(fr,to);\n\t}\n\tline toinf(double x){\n\t\t//??????????????????\n\t\treturn line(p-vec.tolen(x*2),p+vec.tolen(x*2));\n\t}\n};\ndouble lowofcos_getcos(double a,double b,double c){\n\treturn ((a*a+b*b-c*c)/(2*a*b));\n}\nstruct circle{\n\tpos p;\n\tdouble r;\n\tline koten(circle a){\n\t\tpos cv=p.tov(a.p);\n\t\tdouble br=atan2(cv.y,cv.x);\n\t\tdouble dr=acos(lowofcos_getcos( r, cv.norm, a.r));\n\t\tpos p1= p+pos::polar(r,br+dr);\n\t\tpos p2= p+pos::polar(r,br-dr);\n\t\tif(p1>p2)swap(p1,p2);\n\t\treturn line(p1,p2);\n\t}\n\tcircle(pos ip,double ir){\n\t\tp=ip; r=ir;\n\t}\n\tcircle(){}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\"); \n\t\tsprintf(ns,\"ctx.arc(%lf,%lf,%lf,0,360);\",p.x*mag,p.y*mag,r*mag); addhtml(ns);\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\t\n\tvector<line> tangs(circle a){ //??\\?????????\n\t\t//validate AOJ 2201\n\t\tcircle b(*this);\n\t\tif(a.r<b.r)swap(a,b);\n\t\tvector<line> res;\n\t\tif((a.p-b.p).norm-(a.r-b.r)<0.0)return res;\n\t\tif((a.p-b.p).norm-(a.r-b.r)<1e-6){\n\t\t\tif((b.p-a.p).norm<1e-6)return res; //??¨???????????????\n\t\t\tpos rv=(b.p-a.p).tolen(a.r);\n\t\t\tres.push_back(line(rv+a.p,rv+a.p+rv.turn(pi/2.0)));\n\t\t\treturn res;\n\t\t}\n\t\t{\n\t\t\tpos cv=b.p-a.p;\n\t\t\tdouble th=acos((a.r-b.r)/cv.norm);\n\t\t\tpos p1 = cv.turn(th);\n\t\t\tres.push_back(line(a.p+p1.tolen(a.r),b.p+p1.tolen(b.r)));\n\t\t\tpos p2 = cv.turn(-th);\n\t\t\tres.push_back(line(a.p+p2.tolen(a.r),b.p+p2.tolen(b.r)));\n\t\t}\n\t\tif((a.p-b.p).norm-(a.r+b.r)<0.0)return res;\n\t\tif((a.p-b.p).norm-(a.r+b.r)<1e-6){\n\t\t\tpos rv=(b.p-a.p).tolen(a.r);\n\t\t\tres.push_back(line(rv+a.p,rv+a.p+rv.turn(pi/2.0)));\n\t\t\treturn res;\n\t\t}\n\t\t{\n\t\t\tpos cv=b.p-a.p;\n\t\t\tdouble th=acos((a.r+b.r)/cv.norm);\n\t\t\tpos p1 = cv.turn(th);\n\t\t\tres.push_back(line(a.p+p1.tolen(a.r),b.p+p1.tolen(-b.r)));\n\t\t\tpos p2 = cv.turn(-th);\n\t\t\tres.push_back(line(a.p+p2.tolen(a.r),b.p+p2.tolen(-b.r)));\n\t\t}\n\t\treturn res;\n\t}\n};\n\nstruct polygon{\n\tvector<pos> ps;\n\tpolygon(){}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\");\n\t\tint ls=ps.size();\n\t\tsprintf(ns,\"ctx.moveTo(%lf,%lf);\",ps[ls-1].x*mag,ps[ls-1].y*mag); addhtml(ns);\n\t\trep(i,ps.size()){\n\t\t\tsprintf(ns,\"ctx.lineTo(%lf,%lf);\",ps[i].x*mag,ps[i].y*mag); addhtml(ns);\n\t\t}\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\tdouble area(){\n\t\tdouble res=0;\n\t\trep(i,ps.size()){\n\t\t\tpos no=ps[i],to=ps[(i+1)%ps.size()];\n\t\t\tres+=(no.x+to.x)*(no.y-to.y);\n\t\t}\n\t\tif(res<0)reverse(ps.begin(),ps.end());\n\t\treturn abs(res)/2;\n\t}\n\tpolygon(pos a,pos b){\n\t\tps.push_back(a);\n\t\tps.push_back(pos(a.x,b.y));\n\t\tps.push_back(b);\n\t\tps.push_back(pos(b.x,a.y));\n\t}\n\tline gete(int a){\n\t\ta%=ps.size();\n\t\treturn line(ps[a],ps[(a+1)%ps.size()]);\n\t}\n\tint isin(pos a){//?????´??????2,?????£????????????1,?????????0\n\t\tdouble as=0;\n\t\trep(i,ps.size()){\n\t\t\tline ne=gete(i);\n\t\t\tif(ne.dist(a)<=0)return 1;\n\t\t\tpos v1=a.tov(ne.p);\n\t\t\tpos v2=a.tov(ne.q);\n\t\t\tas+=v1.theta(v2);\n\t\t}\n\t\tif(abs(as)<1e-6)return 0;\n\t\treturn 2;\n\t}\n\tpolygon convex_full(){\n\t\tpolygon res;\n\t\tint ns=ps.size();\n\t\tvector<pos> vs(2*ns);\n\t\tsort(ps.begin(),ps.end());\n\t\tint k=0;\n\t\trep(i,ns){\n\t\t\tpos np=ps[i];\n\t\t\twhile(k>1 && vs[k-2].tov(vs[k-1]).cross(vs[k-1].tov(np))<-1e-6)k--;\n\t\t\tvs[k]=np; k++;\n\t\t}\n\t\tint t=k;\n\t\tireg(i,0,ns-2){\n\t\t\tpos np=ps[i];\n\t\t\twhile(k>t && vs[k-2].tov(vs[k-1]).cross(vs[k-1].tov(np))<-1e-6)k--;\n\t\t\tvs[k]=np; k++;\n\t\t}\n\t\tvs.resize(k-1);\n\t\tswap(vs,res.ps);\n\t\treturn res;\n\t}\n\tpolygon cut(line a){//???????????????????????????\n\t\tpolygon res;\n\t\trep(i,ps.size()){\n\t\t\tline ne=gete(i);\n\t\t\tdouble d1=a.vec.cross(a.p.tov(ne.p));\n\t\t\tdouble d2=a.vec.cross(a.p.tov(ne.q));\n\t\t\tif(d1<1e-6)res.ps.push_back(ne.p); //?????£????????£???eps\n\t\t\tif(d1*d2<-1e-6)res.ps.push_back(a.crosspos(ne)); //?????£????????????eps\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tvector<polygon> voronoi(vector<pos> ps){\n\t\t//validate AOJ 2160\n\t\tvector<polygon> res;\n\t\trep(i,ps.size()){\n\t\t\tpolygon np(*this);\n\t\t\trep(j,ps.size()){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tline nl = line(ps[j],ps[i]).bisection();\n\t\t\t\t\n\t\t\t\tnp = np.cut(nl);\n\t\t\t}\n\t\t\tres.push_back(np);\n\t\t}\n\t\treturn res;\t\t\n\t}\n\tpolygon mult(polygon a){\n\t\treturn a;\n\t}\n};\n\n\nint n,m;\nint main(void){\n\tint ct=0;\n\tfor(;;){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\t//inithtml();\n\t\tvector<pos> pa;\n\t\tvector<pos> pb;\n\t\trep(i,n+m){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf%lf\",&x,&y);\n\t\t\tpos np(x,y);\n\t\t\t//if(i==n)randcolhtml();\n\t\t\t//np.outh(0.1);\n\t\t\tif(i<n)pa.push_back(np);\n\t\t\telse pb.push_back(np);\n\t\t}\n\t\t\n\t\tbool ans=false;\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tline ne(pa[i],pb[j]);\n\t\t\t\tbool ok=true;\n\t\t\t\t\n\t\t\t\tint p=0,q=0;\n\t\t\t\trep(k,n){\n\t\t\t\t\tif(i==k)continue;\n\t\t\t\t\tpos tv=(pa[k]-pa[i]);\n\t\t\t\t\tif(abs(tv.cross(ne.vec))>1e-6){\n\t\t\t\t\t\tif(tv.cross(ne.vec)>0)p=1;\n\t\t\t\t\t\telse q=1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(tv.dot(ne.vec)>0)ok=false;\n\t\t\t\t}\n\t\t\t\tif(p*q>0)ok=false;\n\t\t\t\tint r=0,s=0;\n\t\t\t\trep(k,m){\n\t\t\t\t\tif(j==k)continue;\n\t\t\t\t\tpos tv=(pb[k]-pa[i]);\n\t\t\t\t\tif(abs(tv.cross(ne.vec))>1e-6){\n\t\t\t\t\t\tif(tv.cross(ne.vec)>0)r=1;\n\t\t\t\t\t\telse s=1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(tv.dot(ne.vec)<0)ok=false;\n\t\t\t\t\tif(tv.norm<=ne.vec.norm)ok=false;\n\t\t\t\t}\n\t\t\t\tif(r*s>0)ok=false;\n\t\t\t\tif(p*r>0)ok=false;\n\t\t\t\tif(q*s>0)ok=false;\n\t\t\t\t\n\t\t\t\tif(ok)ans=true;\n\t\t\t\t/*\n\t\t\t\tif(ok){\n\t\t\t\t\trandcolhtml();\n\t\t\t\t\tne.outh(0.1);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tchar buf[50];\n\t\tsprintf(buf,\"o_%d\",ct);\n\t\touthtml(buf,0.1);\n\t\tct++;*/\n\t\tif(n*m==0)ans=true;\n\t\tprintf(\"%s\\n\",ans?\"YES\":\"NO\");\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// ------ Class ------ //\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tbool operator==(const Point& p) const { return px == p.px && py == p.py; }\n\tbool operator!=(const Point& p) const { return px != p.px || py != p.py; }\n\tbool operator<(const Point& p) const { return px < p.px ? true : (px == p.px && py < p.py); }\n\tbool operator>(const Point& p) const { return px > p.px ? true : (px == p.px && py > p.py); }\n\tbool operator<=(const Point& p) const { return !(Point(px, py) > p); }\n\tbool operator>=(const Point& p) const { return !(Point(px, py) < p); }\n\tPoint operator+(const Point& p) const { return Point(px + p.px, py + p.py); }\n\tPoint operator-(const Point& p) const { return Point(px - p.px, py - p.py); }\n\tPoint operator/(long double d) const { return Point(px / d, py / d); }\n\tfriend Point operator*(const Point p, long double d) { return Point(p.px * d, p.py * d); }\n\tfriend Point operator*(long double d, const Point& p) { return p * d; }\n\tPoint& operator+=(const Point& p1) { px += p1.px, py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px, py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d, py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d, py /= d; return *this; }\n};\n\n// ------ Functions ------ //\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint pol(long double r, long double d) { return Point(cosl(d) * r, sinl(d) * r); }\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nvector<Point> convex_hull(vector<Point> v) {\n\tif (v.size() < 3) return v;\n\tsort(v.begin(), v.end());\n\tvector<Point> u = { v[0], v[1] }, l = { v[v.size() - 1], v[v.size() - 2] };\n\tfor (int i = 2; i < v.size(); i++) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], v[i]) >= 0; n--) u.pop_back();\n\t\tu.push_back(v[i]);\n\t}\n\tfor (int i = v.size() - 3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], v[i]) >= 0; n--) l.pop_back();\n\t\tl.push_back(v[i]);\n\t}\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\n// ------ Main ------ //\nint n, m; vector<Point> v1, v2, v3, v4;\nbool ok(int i) {\n\tint u = (i + 1) % v3.size();\n\tfor (int j = 0; j < v4.size(); j++) {\n\t\tif (abs(ccw(v3[i], v3[u], v4[j])) != 1) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tfor (int j = 0; j < v3.size(); j++) {\n\t\tif (i == j || u == j) continue;\n\t\tfor (int k = 0; k < v4.size(); k++) {\n\t\t\tif (ccw(v3[i], v3[u], v3[j]) == ccw(v3[i], v3[u], v4[k])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < v4.size(); j++) {\n\t\tfor (int k = j + 1; k < v4.size(); k++) {\n\t\t\tif (ccw(v3[i], v3[u], v4[j]) != ccw(v3[i], v3[u], v4[k])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\twhile (cin >> n >> m, n + m) {\n\t\tv1.resize(n), v2.resize(m);\n\t\tfor (int i = 0; i < n; i++) cin >> v1[i].px >> v1[i].py;\n\t\tfor (int i = 0; i < m; i++) cin >> v2[i].px >> v2[i].py;\n\t\tv3 = convex_hull(v1), v4 = convex_hull(v2);\n\t\tint x = 0;\n\t\tif (v3.size() == 1 && v4.size() == 1) x = 1;\n\t\tif (v3.size() > 1) {\n\t\t\tint w = ccw(v3[0], v3[1], v4[0]);\n\t\t\tif (abs(w) != 2) continue;\n\t\t\tint f = 1;\n\t\t\tfor (int i = 1; i < v4.size(); i++) {\n\t\t\t\tif (ccw(v3[0], v3[1], v4[i]) != x) f = 0;\n\t\t\t}\n\t\t\tif (f) x = 1;\n\t\t}\n\t\tif (v4.size() > 1) {\n\t\t\tint w = ccw(v4[0], v4[1], v3[0]);\n\t\t\tif (abs(w) != 2) continue;\n\t\t\tint f = 1;\n\t\t\tfor (int i = 1; i < v3.size(); i++) {\n\t\t\t\tif (ccw(v4[0], v4[1], v3[i]) != x) f = 0;\n\t\t\t}\n\t\t\tif (f) x = 1;\n\t\t}\n\t\tfor (int i = 0; i < v3.size(); i++) {\n\t\t\tif (ok(i)) x = 1;\n\t\t}\n\t\tswap(v3, v4);\n\t\tfor (int i = 0; i < v4.size(); i++) {\n\t\t\tif (ok(i)) x = 1;\n\t\t}\n\t\tcout << (x ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define x first\n#define y second\n\nconst int INF = 19191919;\n\nusing Point = pair<int,int>;\n\nbool solve(int n, int m){\n    vector<Point> b(n),w(m);\n    rep(i,n) cin >>b[i].x >>b[i].y;\n    rep(i,m) cin >>w[i].x >>w[i].y;\n\n    rep(i,n)rep(j,m){\n        int A = w[j].y - b[i].y;\n        int B = b[i].x - w[j].x;\n        int C = b[i].y*w[j].x - b[i].x*w[j].y;\n\n        bool ok = true;\n        vector<pair<Point,int>> on_line;\n\n        int bp = 0, bm = 0;\n        rep(k,n){\n            int v = A*b[k].x + B*b[k].y + C;\n\n            if(v>0) ++bp;\n            else if(v<0) ++bm;\n            else on_line.pb({b[k],0});\n        }\n\n        int wp = 0 , wm = 0;\n        rep(k,m){\n            int v = A*w[k].x + B*w[k].y + C;\n\n            if(v>0) ++wp;\n            else if(v<0) ++wm;\n            else on_line.pb({w[k],1});\n        }\n\n        if(bp>0 && bm>0) ok = false;\n        if(wp>0 && wm>0) ok = false;\n        if(bp>0 && wp>0) ok = false;\n        if(bm>0 && wm>0) ok = false;\n\n        sort(all(on_line));\n        int sz = on_line.size();\n        int ch = 0;\n        rep(k,sz-1) ch += (on_line[k].second != on_line[k+1].second);\n\n        if(ch>1) ok = false;\n        if(ok) return true;\n    }\n\n    return false;\n}\n\nint main(){\n    int n,m;\n    while(cin >>n >>m,n) cout << (solve(n,m)?\"YES\":\"NO\") << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <double,double> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nbool McCullochPitts(const vector<P>& white,const vector<P>& black){\n  vector<double> weight(3);\n  double alpha = 5.0;\n\n  bool res = false;\n  weight[0] = 0.0;\n  weight[1] = 0.0;\n  weight[2] = 0.0;\n\n  for(int round = 0; round < 5000000; round++){\n    bool isok = true;\n    for(int i = 0; i < white.size(); i++){\n      double o = (weight[0] + weight[1] * white[i].first + weight[2] * white[i].second);\n      //white == 0\n      //black == 1\n      if(o > 0){\n        weight[0] -= alpha;\n        weight[1] -= alpha * white[i].first;\n        weight[2] -= alpha * white[i].second;\n        isok = false;\n      }\n    }\n    for(int i = 0;i < black.size(); i++){\n      double o = (weight[0] + weight[1] * black[i].first + weight[2] * black[i].second);\n      //white == 0\n      //black == 1\n      if(o <= 0){\n        weight[0] += alpha;\n        weight[1] += alpha * black[i].first;\n        weight[2] += alpha * black[i].second;\n        isok = false;\n      }\n    }\n    if(isok){\n      res = true;\n      break;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n,m;\n  while(~scanf(\"%d %d\",&n,&m)){\n    if(n == 0 && m == 0) break;\n\n    vector<P> white;\n    for(int i = 0; i < n; i++){\n      double x,y;\n      scanf(\"%lf %lf\",&x,&y);\n      white.push_back(P(x,y));\n    }\n    vector<P> black;\n    for(int i = 0; i < m; i++){\n      double x,y;\n      scanf(\"%lf %lf\",&x,&y);\n      black.push_back(P(x,y));\n    }\n\n    printf(\"%s\\n\",McCullochPitts(white,black) ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cctype>\n#include <functional>\n#include <iterator>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <string>\n#include <utility>\n#define FOR(i, n) for(int i=0;i<n;i++)\n#define MP(a, b) make_pair(a, b)\n#define mod 1000000007\nusing namespace std;\n\ntypedef long long ull;\n\n\ntypedef long long ll;\n\nstruct Point {\n    ll x, y;\n    int id;\n    Point() {}\n    Point(ll _x, ll _y) : x(_x), y(_y) {};\n\n    bool operator < (const Point& b) const {\n        if (x == b.x) return y < b.y;\n        return x < b.x;\n    }\n} p1[1010], p2[1010], ch1[1010], ch2[1010];\n\ntypedef Point Vector;\n\nVector operator - (const Vector& A, const Vector& B) {\n    return Vector(B.x - A.x, B.y - A.y);\n}\n\nll Cross(Point A, Point B) {\n    return A.x*B.y - A.y*B.x;\n}\n\nbool vis[110];\n\nint ConvexHull(Point *p, int n, Point *ch) {\n    sort(p, p+n); // predefine operator <\n    int m = 0;\n    for (int i = 0; i < n; i++) {\n        if (vis[p[i].id]) continue;\n        while (m > 1 && Cross(ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0) m--;\n        ch[m++] = p[i];\n    }\n    int k = m;\n    for (int i = n-2; i >= 0; i--) {\n        if (vis[p[i].id]) continue;\n        while (m > k && Cross(ch[m-1] - ch[m-2], p[i] - ch[m-2]) <=0) m--;\n        ch[m++] = p[i];\n    }\n    if (n > 1) m--;\n    for (int i = 0; i < m; i++) vis[ch[i].id] = 1;\n    return m;\n}\nint n, m, c1, c2;\n\nbool gongxian(Point a1, Point a2, Point b1, Point b2) {\n    Point u = a2 - a1;\n    Point v = b2 - b1;\n    if (u.x * v.y == u.y * v.x) return 1;\n    return 0;\n}\n\nbool intersact(Point a1, Point a2, Point b1, Point b2) {\n    if (gongxian(a1, a2, b1, b2)) {\n//        printf(\"gongxian\\n\");\n        if (a2 < a1) swap(a1, a2);\n        if (b2 < b1) swap(b1, b2);\n        if (a2 < b1 || b2 < a1) return false;\n        else return true;\n    }\n    // printf(\"(%lld, %lld) - (%lld, %lld)     (%lld, %lld) - (%lld, %lld)\\n\",\n    //       a1.x, a1.y, a2.x, a2.y, b1.x, b1.y, b2.x, b2.y);\n   ll d1 = Cross(b1 - a1, a2 - a1), d2 = Cross(b2 - a1, a2 - a1);\n   ll d3 = Cross(a1 - b1, b2 - b1), d4 = Cross(a2 - b1, b2 - b1);\n//   printf(\"%lld, %lld, %lld, %lld\\n\", d1, d2, d3, d4);\n   if ((d1 * d2 > 0) || (d3 * d4 > 0)) {\n//       printf(\"away\\n\");\n\n       return false;\n    }\n    else {\n//        printf(\"inter\\n\");\n        return true;\n    }\n}\n\n\nint sss(ll x) {\n    if (x > 0) return 1;\n    if (x < 0) return -1;\n    return 0;\n}\n\nbool inin(Point p0, int n, Point* ch) {\n//    printf(\"%d, %d =>\\n\", p0.x, p0.y);\n    int f = sss(Cross(p0 - ch[n-1], ch[0] - ch[n-1]));\n    for (int i = 0; i < n; i++) {\n        ll res = Cross(p0 - ch[(i+n-1)%n], ch[i] - ch[(i+n-1)%n]);\n//        printf(\"res == %lld\\n\", res);\n        if (sss(res) != f) return false;\n    }\n    return true;\n}\n\nbool solve() {\n    if (c1 == 1 && c2 == 1) return true;\n    if (c1 == 1 && c2 == 2) {\n        if (Cross(ch1[0] - ch2[0], ch2[1] - ch2[0]) != 0) return true;\n        else return false;\n    }\n\n    if (c1 == 2 && c2 == 1) {\n        if (Cross(ch2[0] - ch1[0], ch1[1] - ch1[0]) != 0) return true;\n        else return false;\n    }\n\n\n    if (c1 == 2 && c2 == 2) {\n        return !intersact(ch1[0], ch1[1], ch2[0], ch2[1]);\n    }\n    \n    if (c2 > 2) {\n        for (int i = 0; i < c1; i++) {\n            if (inin(ch1[i], c2, ch2)) return false;\n        }\n    }\n    if (c1 > 2) {\n        for (int j = 0; j < c2; j++) {\n            if (inin(ch2[j], c1, ch1)) return false;\n        }\n    }\n    \n    for (int i = 0; i < c1; i++) {\n        for (int j = i + 1; j < c1; j++) {\n            for (int k = 0; k < c2; k++) {\n                for (int l = k + 1; l < c2; l++) {\n                    if (intersact(ch1[i], ch1[j], ch2[k], ch2[l])) return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    while (scanf(\"%d%d\", &n, &m) != EOF) {\n        if (n == 0 && m == 0) break;\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%lld%lld\", &p1[i].x, &p1[i].y);\n            p1[i].id = i;\n        }\n\n        for (int i = 0; i < m; i++) {\n            scanf(\"%lld%lld\", &p2[i].x, &p2[i].y);\n            p2[i].id = i;\n        }\n        \n        memset(vis, 0, sizeof(vis));\n        c1 = ConvexHull(p1, n, ch1);\n        memset(vis, 0, sizeof(vis));\n        c2 = ConvexHull(p2, m, ch2);\n\n        // puts(\"A:\");\n        // for (int i = 0; i < c1; i++) printf(\"(%lld, %lld)\\n\", ch1[i].x, ch1[i].y);\n        // puts(\"B:\");\n        // for (int i = 0; i < c2; i++) printf(\"(%lld, %lld)\\n\", ch2[i].x, ch2[i].y\n        //    );\n        printf(\"%s\\n\", solve()? \"YES\":\"NO\");\n    }\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n};\n\nbool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n\n  if(cross(a1-a2,b1-b2)==0){\n    return is_point_on_line(a1,a2,b1) || is_point_on_line(a1,a2,b2) \n        || is_point_on_line(b1,b2,a1) || is_point_on_line(b1,b2,a2);\n  }\n  else {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n           ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n  }\n}\n\nint contain(point p, vector<point> ps){\n  point a(p.x,p.y),b(1000000,p.y);\n\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<ps.size();i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(a.y<=ymn||a.y>=ymx)return 0;\n\n  int cnt1=0;\n  for(int i=0;i<ps.size();i++)\n    if(is_point_on_line(a,b,ps[i]))cnt1++;\n  \n  int cnt=0;\n  for(int i=0;i<ps.size();i++)\n    if(is_intersected_ls(ps[i],ps[(i+1)%ps.size()],a,b))cnt++;\n\n  return (cnt-cnt1)%2;\n}\n\nint crossPol(vector<point> pol1, vector<point> pol2){\n  int szpol1=pol1.size();\n  int szpol2=pol2.size();\n  \n  for(int i=0;i<szpol1;i++)\n    if(contain(pol1[i],pol2))return 1;\n  \n  for(int i=0;i<szpol2;i++)\n    if(contain(pol2[i],pol1))return 1;\n\n  pol1.push_back(pol1[0]);\n  pol2.push_back(pol2[0]);\n  \n  for(int i=0;i<szpol1;i++)\n    for(int j=0;j<szpol2;j++)\n      if(is_intersected_ls(pol1[i],pol1[i+1],pol2[j],pol2[j+1]))return 1;\n  \n  return 0;\n}\n\nvector<point>convex_hull(point* ps, int n){\n  sort(ps,ps+n,cmp_x);\n  int k=0;\n  vector<point>qs(n*2);\n \n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0)k--;\n    qs[k++]=ps[i];\n  }\n \n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0)k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nint main(void){\n  int n,m;\n  point black[100],white[100];\n\n  while(cin >> n >> m,n|m){\n\n    for(int i=0;i<n;i++)\n      cin >> black[i].x >> black[i].y;\n    \n    for(int i=0;i<m;i++)\n      cin >> white[i].x >> white[i].y;\n\n    if(n<2||m<2){\n      if(n<2 && m<2)cout << \"YES\" << endl;\n      else {\n\tbool fg=false;\n\tfor(int i=0;i<n;i++){\n\t  for(int j=0;j<m;j++){\n\t    if(is_intersected_ls(black[i],black[(i+1)%n],white[j],white[(j+1)%n]))fg=true;\n\t  }\n\t}\n\tif(fg)cout <<\"NO\"<<endl;\n\telse cout << \"YES\" << endl;\n      }\n      continue;\n    }\n\n    vector<point>Black,White;\n\n    Black=convex_hull(black,n);\n    White=convex_hull(white,m);\n    \n    if(crossPol(Black,White))cout << \"NO\" << endl;\n    else cout << \"YES\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\ntypedef long double ld;\nconst ld EPS = 1e-12;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine() {};\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle() {};\n\tCircle(Point a, ld b) :p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tld r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2, 0)*projection(l, p) - p;\n}\n\nld dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tld a = cross(s.b - s.a, t.b - t.a);\n\tld b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tld dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tld d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r > EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tld d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tld len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\n\nPolygon convex_hull(Polygon s)\n{\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(ALL(s));\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\tFOR(i, 2, s.size())\n\t{\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != -1; n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\tfor (int i = s.size() - 3; i >= 0; i--)\n\t{\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != -1; n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\nint contains(Polygon g, Point p)\n{\n\tbool f = false;\n\tREP(i, g.size())\n\t{\n\t\tPoint a = g[i] - p, b = g[(i + 1) % g.size()] - p;\n\t\tif (abs(cross(a, b)) < EPS&&dot(a, b) < EPS) return 0; //ON\n\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\tif (a.imag() < EPS&&b.imag() > EPS&&cross(a, b) > EPS) f = !f;\n\t}\n\tif (f) return 1; //IN\n\telse return -1; //OUT\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tPolygon a, b;\n\t\tREP(i, n)\n\t\t{\n\t\t\tld x, y; cin >> x >> y;\n\t\t\ta.emplace_back(x, y);\n\t\t}\n\t\tREP(i, m)\n\t\t{\n\t\t\tld x, y; cin >> x >> y;\n\t\t\tb.emplace_back(x, y);\n\t\t}\n\t\tif (n == 1 && m == 1)\n\t\t{\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse if (n + m == 3)\n\t\t{\n\t\t\tif (n > m) swap(a, b);\n\t\t\tif (ccw(a[0], b[0], b[1]) == 2) cout << \"NO\" << endl;\n\t\t\telse cout << \"YES\" << endl;\n\t\t}\n\t\telse if (n == 2 && m == 2)\n\t\t{\n\t\t\tcout << (isis_ss(Line(a[0], a[1]), Line(b[0], b[1])) ? \"NO\" : \"YES\") << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPolygon cha = convex_hull(a);\n\t\t\tPolygon chb = convex_hull(b);\n\t\t\tbool f = true;\n\t\t\tfor (auto p : a)\n\t\t\t{\n\t\t\t\tif (contains(chb, p) != -1) f = false;\n\t\t\t}\n\t\t\tfor (auto p : b)\n\t\t\t{\n\t\t\t\tif (contains(cha, p) != -1) f = false;\n\t\t\t}\n\t\t\tcout << (f ? \"YES\" : \"NO\") << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-10)\n#define eq(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\ndouble norm(Vector v) { return v.x*v.x + v.y*v.y; }\ndouble abs(Vector v) { return sqrt(norm(v)); }\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nbool isOrthogonal(Vector a, Vector b) {\n  return eq(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isParallel(Vector a, Vector b) {\n  return eq(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n  return isParallel(a1 - a2, b1 - b2);\n}\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\ndouble getDistance(Point a, Point b) { return abs(a - b); }\ndouble getAngle(Point a, Point b, Point c) {\n  Vector v = b - a, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha) * 180 / M_PI;\n  return min(theta, 360 - theta);\n}\n\nstruct Segment {\n  Point p1, p2;\n  Segment(Point p1 = Point(), Point p2 = Point()):p1(p1), p2(p2){}\n};\ntypedef Segment Line;\n\nbool isOrthogonal(Segment s1, Segment s2) {\n  return eq(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isParallel(Segment s1, Segment s2) {\n  return eq(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p) {\n  return p + (project(s, p) - p) * 2.0;\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) {\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\ndouble getDistance(Segment s1, Segment s2) {\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPoint getCrossPointLL(Line l1, Line l2) {\n  Vector v1 = l1.p2 - l1.p1, v2 = l2.p2 - l2.p1;\n  double d = cross(v2, v1);\n  if(abs(d) < EPS) return l2.p1;\n  return l1.p1 + v1 * cross(v2, l2.p2 - l1.p1) * (1.0 / d);\n}\nLine getPerpendicularBisector(Point p1, Point p2) {\n  Point c = (p1 + p2) / 2.0;\n  Point q = Point(c.x + (p1.y - p2.y), c.y + (p2.x - p1.x));\n  return Line(c, q);\n}\n\nstruct Circle {\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0):c(c), r(r){}\n};\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n  // assert(intersect(c, l));\n  Vector pr = project(l, c.c);\n  Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n  double base = sqrt(c.r*c.r - norm(pr - c.c));\n  return make_pair(pr + e * base, pr - e * base);\n}\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n  // assert(intersect(c1, c2));\n  double d = abs(c1.c - c2.c);\n  double a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2*c1.r*d));\n  double t = arg(c2.c - c1.c);\n  return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\ntypedef vector<Point> Polygon;\n\ndouble getArea(Polygon p) {\n  double ret = 0.0;\n  for(int i = 0; i < (int)p.size(); i++) {\n    ret += cross(p[i], p[(i+1)%p.size()]);\n  }\n  return abs(ret) / 2.0;\n}\n\n#define IN_POLYGON  2\n#define ON_POLYGON  1\n#define OUT_POLYGON 0\nint contains(Polygon g, Point p) {\n  int n = g.size();\n  bool x = false;\n  for(int i = 0; i < n; i++) {\n    Point a = g[i] - p, b = g[(i+1) % n] - p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON_POLYGON;\n    if(a.y > b.y) swap(a, b);\n    if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n  }\n  return (x ? IN_POLYGON : OUT_POLYGON);\n}\n\nPolygon convexHull(Polygon ps) {\n  int N = ps.size(), j = 0;\n  Polygon pg(N*2);\n\n  if(N < 3) return ps;\n\n  sort(ps.begin(), ps.end(), [](Point p1, Point p2) -> bool {\n      return p1.y != p2.y ? lt(p1.y, p2.y) : lt(p1.x, p2.x); });\n  for(int i = 0; i < N; i++, j++) {\n    while(j >= 2 && ccw(pg[j-2], pg[j-1], ps[i]) == -1) j--;\n    pg[j] = ps[i];\n  }\n  int k = j+1;\n  for(int i = N-2; i >= 0; i--, j++) {\n    while(j >= k && ccw(pg[j-2], pg[j-1], ps[i]) == -1) j--;\n    pg[j] = ps[i];\n  }\n  pg.resize(j-1);\n  return pg;\n}\n\nPolygon convexCut(Polygon s, Line l) {\n  Polygon t;\n  for(int i = 0; i < (int)s.size(); i++) {\n    Point a = s[i], b = s[(i+1)%s.size()];\n    if(ccw(l.p1, l.p2, a) != -1) t.push_back(a);\n    if(ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0) {\n      t.push_back(getCrossPointLL(Line(a, b), l));\n    }\n  }\n  return t;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n, m;\n  while(cin >> n >> m, n || m) {\n    Polygon s(n), t(m);\n    rep(i, n) cin >> s[i].x >> s[i].y;\n    rep(i, m) cin >> t[i].x >> t[i].y;\n\n    if(n + m <= 2) {\n      puts(\"YES\"); continue;\n    }\n    if(n + m <= 3) {\n      if(n == 2 && ccw(s[0], s[1], t[0]) == ON_SEGMENT) {\n\tputs(\"NO\"); continue;\n      }\n      if(m == 2 && ccw(t[0], t[1], s[0]) == ON_SEGMENT) {\n\tputs(\"NO\"); continue;\n      }\n      puts(\"YES\"); continue;\n    }\n    if(n == 2 && m == 2) {\n      if(intersect(s[0], s[1], t[0], t[1])) {\n\tputs(\"NO\"); continue;\n      }\n      puts(\"YES\"); continue;\n    }\n\n    auto S = convexHull(s);\n    auto T = convexHull(t);\n    bool flag = true;\n    rep(i, 2) {\n      if(s.size() <= 2) continue;\n      rep(j, t.size()) {\n\tif(contains(S, t[j]) != 0) {\n\t  flag = false;\n\t  break;\n\t}\n      }\n      swap(S, T);\n      swap(s, t);\n    }\n    cout << (flag ? \"YES\" : \"NO\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define each(i, c) for (__typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define chmin(a, b) a = min(a, b)\n#define chmax(a, b) a = max(a, b)\n#define pb push_back\n#define mp make_pair\n\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\n\ndouble SQ(double a){ return a * a; }\nbool EQ(double a, double b){ return abs(a - b) < EPS; }\nbool LT(double a, double b){ return a - b < -EPS; }\nbool LEQ(double a, double b){ return a - b < EPS; }\n\ndouble toRad(double t){ return t / 180 * PI; }\ndouble toDeg(double t){ return t * 180 / PI; }\n\ntypedef complex<double> Point;\nnamespace std {\n\tbool operator < (const Point &a, const Point &b){\n\t\tif (a.X != b.X) return a.X < b.X;\n\t\treturn a.Y < b.Y;\n\t}\n\t\n\tistream& operator >> (istream &is, Point &a){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\ta = Point(x, y);\n\t\treturn is;\n\t}\n\t\n\tostream& operator << (ostream &os, Point a){\n\t\treturn os << a.X << \" \" << a.Y;\n\t}\n}\n\nstruct Line {\n\tPoint p1, p2;\n};\n\ntypedef Line Segment;\n\nstruct Circle {\n\tPoint p;\n\tdouble r;\n};\n\ntypedef vector<Point> Polygon;\n\n\ndouble norm(Point p){ return SQ(p.X) + SQ(p.Y); }\n\ndouble dot(Point a, Point b){ return (conj(a) * b).X; }\ndouble cross(Point a, Point b){ return (conj(a) * b).Y; }\n\nenum {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0,\n};\n\nint ccw(Point p0, Point p1, Point p2){\n\tPoint a = p1 - p0;\n\tPoint b = p2 - p0;\n\tif (LT(0.0, cross(a, b))) return COUNTER_CLOCKWISE;\n\tif (LT(cross(a, b), 0.0)) return CLOCKWISE;\n\tif (LT(dot(a, b), 0.0)) return ONLINE_BACK;\n\tif (LT(norm(a), norm(b))) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool orthogonal(Line l1, Line l2){\n\treturn EQ(dot(l1.p2 - l1.p1, l2.p2 - l2.p1), 0.0);\n}\n\nbool parallel(Line l1, Line l2){\n\treturn EQ(cross(l1.p2 - l1.p1, l2.p2 - l2.p1), 0.0);\n}\n\nPoint project(Line l, Point p){\n\tPoint base = l.p2 - l.p1;\n\tdouble r = dot(p - l.p1, base) / norm(base);\n\treturn l.p1 + base * r;\n}\n\nPoint reflect(Line &l, Point &p){\n\treturn p + (project(l, p) - p) * 2.0;\n}\n\nbool sameLine(Line l1, Line l2){\n\treturn abs(cross(l1.p2 - l1.p1, l2.p1 - l1.p1)) < EPS;\n}\n\nbool intersectLP(Line l, Point p){\n\treturn LEQ(abs(cross(l.p1 - p, l.p2 - p)), 0.0);\n}\n\nbool intersectLL(Line l1, Line l2){\n\treturn !parallel(l1, l2) || sameLine(l1, l2);\n}\n\nbool intersectLS(Line l, Segment s){\n\treturn cross(l.p2 - l.p1, s.p1 - l.p1) * cross(l.p2 - l.p1, s.p2 - l.p1) < -EPS;\n}\n\nbool intersectSP(Segment s, Point p){\n\treturn norm(s.p1 - p) + norm(s.p2 - p) - norm(s.p2 - s.p1) < EPS;\n}\n\nbool intersectSS(Segment s1, Segment s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0\n\t\t&& ccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\n\ndouble distanceLP(Line l, Point p){\n\treturn abs(cross(l.p2 - l.p1, p - l.p1)) / abs(l.p2 - l.p1);\n}\n\ndouble distanceLL(Line l1, Line l2){\n\tif (intersectLL(l1, l2)) return 0.0;\n\treturn distanceLP(l1, l2.p1);\n}\n\ndouble distanceLS(Line l, Segment s){\n\tif (intersectLS(l, s)) return 0.0;\n\treturn min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\n\ndouble distanceSP(Segment s, Point p){\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\treturn distanceLP(s, p);\n}\n\ndouble distanceSS(Segment s1, Segment s2){\n\tif (intersectSS(s1, s2)) return 0.0;\n\treturn min(\n\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t);\n}\n\nPoint crossPointLL(Line l1, Line l2){\n\tassert(intersectLL(l1, l2));\n\tPoint base = l2.p2 - l2.p1;\n\tdouble d1 = abs(cross(base, l1.p1 - l2.p1));\n\tdouble d2 = abs(cross(base, l1.p2 - l2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn l1.p1 + (l1.p2 - l1.p1) * t;\n}\n\nPoint crossPointLS(Line l, Segment s){\n\tassert(intersectLS(l, s));\n\treturn crossPointLL(l, s);\n}\n\nPoint crossPointSS(Segment s1, Segment s2){\n\tassert(intersectSS(s1, s2));\n\treturn crossPointLL(s1, s2);\n}\n\ndouble area(Polygon &g){\n\tdouble res = 0.0;\n\trep(i, g.size()){\n\t\tres += cross(g[i], g[(i + 1) % g.size()]);\n\t}\n\treturn res / 2.0;\n}\n\nenum {\n\tIN = 2,\n\tON = 1,\n\tOUT = 0,\n};\n\nint contains(const Polygon &g, Point p){\n\tint n = g.size();\n\tbool x = false;\n\trep(i, n){\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.Y > b.Y) swap(a, b);\n\t\tif (a.Y < EPS && EPS < b.Y && cross(a, b) > EPS) x = !x;\n\t}\n\treturn x ? IN : OUT;\n}\n\nPolygon convexHull(Polygon &s){\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(s.begin(), s.end());\n\t\n\tu.pb(s[0]); u.pb(s[1]);\n\tl.pb(s[s.size() - 1]); l.pb(s[s.size() - 2]);\n\t\n\tfor (int i = 2; i < s.size(); i++){\n\t\tint n = u.size();\n\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\tu.pop_back();\n\t\t\tn--;\n\t\t}\n\t\tu.pb(s[i]);\n\t}\n\t\n\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\tint n = l.size();\n\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\tl.pop_back();\n\t\t\tn--;\n\t\t}\n\t\tl.pb(s[i]);\n\t}\n\t\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) l.pb(u[i]);\n\t\n\treturn l;\n}\n\nint n, m;\nPolygon g, h;\n\nbool solve()\n{\n\tg = convexHull(g);\n\th = convexHull(h);\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment s = {g[i], g[(i + 1) % g.size()]};\n\t\t\tSegment t = {h[j], h[(j + 1) % h.size()]};\n\t\t\tif (intersectSS(s, t)) return false;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return false;\n\t}\n\t\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return false;\n\t}\n\t\n\treturn true;\n}\n\nint main()\n{\n\tcout << fixed << setprecision(20);\n\t\n\twhile (scanf(\"%d %d\", &n, &m), n){\n\t\tg.resize(n);\n\t\th.resize(m);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> g[i];\n\t\t}\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tcin >> h[i];\n\t\t}\n\t\tputs(solve() ? \"YES\" : \"NO\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nlong double EPS = (long double)1e-6;\nstruct Point { long double px, py; };\nPoint r1[100], r2[100]; int n, m;\nvector<pair<Point, int>>vec, vec2;\nbool solve(Point a1, Point a2) {\n\tif (a1.px > a2.px)swap(a1, a2);\n\tif (a1.px == a2.px) {\n\t\tint colour = 0;\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tif (colour == 0) {\n\t\t\t\tif (vec2[i].first.px < a1.px) { colour = 3 - vec2[i].second; }\n\t\t\t\tif (vec2[i].first.px == a1.px) { return false; }\n\t\t\t\tif (vec2[i].first.px > a1.px) { colour = vec2[i].second; }\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (colour != 3 - vec2[i].second && vec2[i].first.px < a1.px) { return false; }\n\t\t\t\tif (vec2[i].first.px == a1.px) { return false; }\n\t\t\t\tif (colour != vec2[i].second && vec2[i].first.px > a1.px) { return false; }\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\telse {\n\t\tlong double KT = (a2.py - a1.py) / (a2.px - a1.px);\n\t\tlong double YY = a1.py - a1.px*KT;\n\t\tint colour = 0;\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tlong double height = YY + KT*vec2[i].first.px;\n\t\t\tif (colour == 0) {\n\t\t\t\tif (vec2[i].first.py < height) { colour = 3 - vec2[i].second; }\n\t\t\t\tif (vec2[i].first.py == height) { return false; }\n\t\t\t\tif (vec2[i].first.py > height) { colour = vec2[i].second; }\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (colour != 3 - vec2[i].second && vec2[i].first.py < height) { return false; }\n\t\t\t\tif (vec2[i].first.py == height) { return false; }\n\t\t\t\tif (colour != vec2[i].second && vec2[i].first.py > height) { return false; }\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n\twhile (true) {\n\t\tvec.clear(); vec2.clear(); cin >> n >> m; if (n == 0 && m == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> r1[i].px >> r1[i].py; vec2.push_back(make_pair(r1[i], 1));\n\t\t\tfor (long double j = -1.0l; j <= 1.0l; j += 1.0l) {\n\t\t\t\tfor (long double k = -1.0l; k <= 1.0l; k += 1.0l) {\n\t\t\t\t\tvec.push_back(make_pair(Point{ r1[i].px + j*EPS,r1[i].py + k*EPS }, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> r2[i].px >> r2[i].py; vec2.push_back(make_pair(r2[i], 2));\n\t\t\tfor (long double j = -1.0l; j <= 1.0l; j += 1.0l) {\n\t\t\t\tfor (long double k = -1.0l; k <= 1.0l; k += 1.0l) {\n\t\t\t\t\tvec.push_back(make_pair(Point{ r1[i].px + j*EPS,r1[i].py + k*EPS }, 2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans = false;\n\t\tfor (int i = 0; i < vec.size(); i++) {\n\t\t\tfor (int j = i + 1; j < vec.size(); j++) {\n\t\t\t\tbool p1 = solve(vec[i].first, vec[j].first);\n\t\t\t\tif (p1 == true)ans = true;\n\t\t\t}\n\t\t}\n\t\tif (ans == true)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cassert>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-10\n#define F first\n#define S second\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point\n{\n  public:\n  double x,y;\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nbool isIntersect(Segment s1,Segment s2)\n{\nreturn isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool cmp(const vector<Point> &a,const vector<Point> &b)\n{\n  return a.size() < b.size();\n}\n\nPolygon andrewScan(Polygon s)\n{\n  Polygon u,l;\n  if(s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<s.size();i++)\n    {\n      for(int n=u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--)\n\tu.pop_back();\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3; i>=0 ; i--)\n    {\n      for(int n=l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--)\n\tl.pop_back();\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\nbool check(int p1,int p2,vector<Point> &black,vector<Point> &white)\n{\n  int n = black.size();\n  pair<bool,bool> Left,Right;\n  Left  = pair<bool,bool>(false,false); // F->black, S->white\n  Right = pair<bool,bool>(false,false);\n\n  rep(i,n)\n    {\n      if(i == p1 || i == p2)continue;\n      int res = ccw(black[p1],black[p2],black[i]);\n      if(res == CLOCKWISE) Right.F = true;\n      if(res == COUNTER_CLOCKWISE) Left.F = true;\n    }\n  \n  n = white.size();\n  bool Front = false;\n  bool Back = false;\n  int OnSegment = 0;\n  rep(i,n)\n    {\n      int res = ccw(black[p1],black[p2],white[i]);\n      if(res == CLOCKWISE) Right.S = true;\n      if(res == COUNTER_CLOCKWISE) Left.S = true;\n      if(res == ONLINE_FRONT) Front = true;\n      if(res == ONLINE_BACK) Back = true;\n      if(res == ON_SEGMENT) OnSegment++;\n    }\n\n  //cout << black[p1].x << \",\" << black[p1].y << \" | \" << black[p2].x << \",\" << black[p2].y << endl;\n  //cout << \"Front = \" << Front << \" Back = \" << Back << \" OnSegment = \" << OnSegment << endl;\n  if(Front && Back)return false;\n  if(OnSegment && Front)return false;\n  if(OnSegment && Back)return false;\n  if(OnSegment >= 2)return false;\n  if(Left.F && Left.S)return false;\n  if(Right.F && Right.S)return false;\n  if(Left.S && Right.S)return false;\n  //cout << \"OK\" << endl;\n  return true;\n}\n\nvoid printVP(vector<Point> a)\n{\n  cout << \"printVP-------\" << endl;\n  rep(i,a.size())cout << \"(\" << a[i].x << \",\" << a[i].y << \") \";\n  cout << endl;\n}\n\nbool isParallel(Vector a,Vector b)\n{\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2)\n{\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2)\n{\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isAinB(Polygon A,Polygon B)\n{\n  int N = A.size();\n  int M = B.size();\n  for(int i=0;i<N;i++)\n    {\n      for(int j=0;j<M;j++)\n\t{\n\t  int res = ccw(A[i],A[(i+1)%N],B[j]);\n\t  if(res != COUNTER_CLOCKWISE)return false;\n\t}\n    }\n  return true;\n}\n\nint main()\n{\n  int n,m;\n  while(cin >> n >> m,n|m)\n    {\n      assert(n && m);\n      vector<Point> A(n),B(m);\n      rep(_,n)cin >> A[_].x >> A[_].y;\n      rep(_,m)cin >> B[_].x >> B[_].y;\n\n      vector<Point> black,white;\n      if(A.size() > B.size())\n\tblack = A,white = B;\n      else\n\tblack = B,white = A;\n\n      black = andrewScan(black);\n      white = andrewScan(white);\n\n      int N,M;\n      N = black.size();\n      M = white.size();\n      bool AUTO = false;\n      rep(i,N)\n\t{\n\t  rep(j,M)\n\t    {\n\t      if(isIntersect(Segment(black[i],black[(i+1)%N]),Segment(white[i],white[(i+1)%M])))\n\t\t{\n\t\t  AUTO = true;\n\t\t  goto OUT;\n\t\t}\n\t    }\n\t}\n    OUT:;\n\n      if(AUTO)\n\t{\n\t  cout << \"NO\" << endl;\n\t  continue;\n\t}\n      if(isAinB(black,white))\n\t{\n\t  cout << \"NO\" << endl;\n\t  continue;\n\t}\n      if(isAinB(white,black))\n\t{\n\t  cout << \"NO\" << endl;\n\t  continue;\n\t}\n      cout << \"YES\" << endl;\n\n\n      continue;\n      bool ch = true;\n      \n\n      if(n == 1 && m == 1)\n\t{\n\t  cout << \"YES\" << endl;\n\t  continue;\n\t}\n\n      \n      if(black.size() >= 3 && white.size() == 1)\n\t{\t  \t \n\t  bool aaa = false;\n\t  rep(i,black.size()-2)\n\t    {\n\t      if(!isParallel(Segment(black[i],black[i+1]),Segment(black[i+1],black[i+2])))\n\t\t{\n\t\t  aaa = true;\n\t\t  break;\n\t\t}\n\t    }\n\n\t  if(aaa)\n\t    {\n\t      bool fin = false;\n\t      rep(i,black.size())\n\t\t{\n\t\t  REP(j,i+1,black.size())\n\t\t    {\n\t\t      if(!check(i,j,black,white))\n\t\t\t{\n\t\t\t  cout << \"NO\" << endl;\n\t\t\t  fin = true;\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  if(fin)break;\n\t\t}\n\t      if(!fin)cout << \"YES\" << endl;\n\t      continue;\n\t    }\n\t}\n      \n      /*\n      if(white.size() == 1)\n\t{\n\n\t  sort(black.begin(),black.end());\n\t  if(ccw(black[0],black[black.size()-1],white[0]) == ON_SEGMENT)\n\t    {\n\t      cout << \"NO\" << endl;\n\t      continue;\n\t    }\n\t  rep(i,black.size())\n\t    if(ccw(black[i],black[(i+1)%black.size()],white[0]) == ON_SEGMENT)\n\t      {\n\t\tcout << \"NO\" << endl;\n\t\tgoto FX;\n\t      }\n\t  cout << \"YES\" << endl;\n\tFX:;\n\t  continue;\n\t}\n      */\n  \n\n      \n\tbool allPL = true;\n\t//vector<Point> gray = black;\n\t//rep(i,white.size())gray.push_back(white[i]);\n\trep(i,black.size())\n\t  {\n\t    REP(j,i+1,black.size())\n\t      {\n\t\trep(k,white.size())\n\t\t  {\n\t\t    REP(l,k+1,white.size())\n\t\t      {\n\t\t\tif(!isParallel(Segment(black[i],black[j]),Segment(white[k],white[l])))\n\t\t\t  {\n\t\t\t    allPL = false;\n\t\t\t    goto Next;\n\t\t\t  }\n\t\t      }\n\t\t  }\n\t      }\n\t  }\n      Next:;\n\tif(allPL)\n\t  {\n\t    int Front = 0;\n\t    int Back = 0;\n\t    int OnSegment = 0;\n\t    rep(i,black.size())\n\t      {\n\t\tREP(j,i+1,black.size())\n\t\t  {\n\t\t    rep(k,white.size())\n\t\t      {\n\t\t\tint res = ccw(black[i],black[j],white[k]);\n\t\t\tif(res == ONLINE_FRONT)Front++;\n\t\t\tif(res == ONLINE_BACK) Back++;\n\t\t\tif(res == ON_SEGMENT)  OnSegment++;\n\t\t      }\t\t\n\t\t  }\n\t      }\n\n\t    if(OnSegment)cout << \"NO\" << endl;\n\t    else if(Front && Back)cout << \"NO\" << endl;\t \n\t    else cout << \"YES\" << endl;\n\t \n\t    continue;\n\t  }\t\n\n      \n    \n\t//N = black.size();\n\trep(i,N)\n\t{\n\t  REP(j,i+1,N)\n\t    {\n\t      if(check(i,j,black,white))\n\t\t{\n\t\t  //cout << black[i].x << \",\" << black[i].y << \" \" << black[j].x << \",\" << black[j].y << endl;\n\t\t  cout << \"YES\" << endl;\n\t\t  goto F;\n\t\t}\n\t    }\n\t}\n      cout << \"NO\" << endl;\n    F:;\n    }\n  return 0;\n}\n\n\n/*\n  if(black.size() == 2 && white.size() == 1)\n  {\n  int res = ccw(black[0],black[1],white[0]);\n  if(res == ON_SEGMENT)cout << \"NO\" << endl;\n  else                 cout << \"YES\" << endl;\n  continue;\n  }\n*/\n\n/*\n  if(black.size() == 2 && white.size() == 2)\n  {\n  if(isIntersect(Segment(black[0],black[1]),Segment(white[0],white[1])))cout << \"NO\" << endl;\n  else                                                                  cout << \"YES\" << endl;\n  continue;\n  }\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\n\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\n\t\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\nint n,m;\nP bp[1000];\nP wp[1000];\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// E¤Ìvfª éFÅ é©Ç¤©`FbN\nbool checkRIghtincludeLine(P a,P b,bool isW){\n    if(isW){\n        for(int i = 0; i < m; i++){\n            if(EQ(a.real(),b.real())){\n                if(wp[i].real()<a.real()&&!EQ(wp[i].real(),a.real()))\n                    return false;\n            }\n            else{\n                // y=d*x+e\n                double d=(a.imag()-b.imag())/(a.real()-b.real());\n                double e=b.imag()-b.real()*d;\n                if(!(d*wp[i].real()+e>wp[i].imag()||EQ(d*wp[i].real()+e,wp[i].imag())))\n                    return false;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            if(EQ(a.real(),b.real())){\n                if(!(bp[i].real()<a.real()&&!EQ(bp[i].real(),a.real())))\n                    return false;\n            }\n            else{\n                // y=d*x+e\n                double d=(a.imag()-b.imag())/(a.real()-b.real());\n                double e=b.imag()-b.real()*d;\n                if((d*bp[i].real()+e>bp[i].imag()||EQ(d*bp[i].real()+e,bp[i].imag())))\n                    return false;\n            }\n        }\n        return true;\n    }\n    else{\n        for(int i = 0; i < n; i++){\n            if(EQ(a.real(),b.real())){\n                if((bp[i].real()<a.real()&&!EQ(bp[i].real(),a.real())))\n                    return false;\n            }\n            else{\n                // y=d*x+e\n                double d=(a.imag()-b.imag())/(a.real()-b.real());\n                double e=b.imag()-b.real()*d;\n                if(!(d*bp[i].real()+e>bp[i].imag()||EQ(d*bp[i].real()+e,bp[i].imag())))\n                    return false;\n            }\n        }\n        for(int i = 0; i < m; i++){\n            if(EQ(a.real(),b.real())){\n                if(!(wp[i].real()<a.real()&&!EQ(wp[i].real(),a.real())))\n                    return false;\n            }\n            else{\n                // y=d*x+e\n                double d=(a.imag()-b.imag())/(a.real()-b.real());\n                double e=b.imag()-b.real()*d;\n                if((d*wp[i].real()+e>wp[i].imag()||EQ(d*wp[i].real()+e,wp[i].imag())))\n                    return false;\n            }\n        }\n        return true;\n    }\n}\n// ¶¤Ìvfª éFÅ é©Ç¤©`FbN\nbool checkLeftincludeLine(P a,P b,bool isW){\n    if(isW){\n        for(int i = 0; i < m; i++){\n            if(EQ(a.real(),b.real())){\n                if(wp[i].real()>a.real()&&!EQ(wp[i].real(),a.real()))\n                    return false;\n            }\n            else{\n                // y=d*x+e\n                double d=(a.imag()-b.imag())/(a.real()-b.real());\n                double e=b.imag()-b.real()*d;\n                if(!(d*wp[i].real()+e<wp[i].imag()||EQ(d*wp[i].real()+e,wp[i].imag())))\n                    return false;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            if(EQ(a.real(),b.real())){\n                if(!(bp[i].real()>a.real()&&!EQ(bp[i].real(),a.real())))\n                    return false;\n            }\n            else{\n                // y=d*x+e\n                double d=(a.imag()-b.imag())/(a.real()-b.real());\n                double e=b.imag()-b.real()*d;\n                if((d*bp[i].real()+e<bp[i].imag()||EQ(d*bp[i].real()+e,bp[i].imag())))\n                    return false;\n            }\n        }\n        return true;\n    }\n    else{\n        for(int i = 0; i < n; i++){\n            if(EQ(a.real(),b.real())){\n                if((bp[i].real()>a.real()&&!EQ(bp[i].real(),a.real())))\n                    return false;\n            }\n            else{\n                // y=d*x+e\n                double d=(a.imag()-b.imag())/(a.real()-b.real());\n                double e=b.imag()-b.real()*d;\n                if(!(d*bp[i].real()+e<bp[i].imag()||EQ(d*bp[i].real()+e,bp[i].imag())))\n                    return false;\n            }\n        }\n        for(int i = 0; i < m; i++){\n            if(EQ(a.real(),b.real())){\n                if(!(wp[i].real()>a.real()&&!EQ(wp[i].real(),a.real())))\n                    return false;\n            }\n            else{\n                // y=d*x+e\n                double d=(a.imag()-b.imag())/(a.real()-b.real());\n                double e=b.imag()-b.real()*d;\n                if((d*wp[i].real()+e<wp[i].imag()||EQ(d*wp[i].real()+e,wp[i].imag())))\n                    return false;\n            }\n        }\n        return true;\n    }\n}\n\nint main(){\n\n    while(cin>>n>>m&&!(n==0&&m==0)){\n        for(int i = 0; i < n; i++){\n            int x,y;\n            cin>>x>>y;\n            bp[i]=P(x,y);\n        }\n        for(int i = 0; i < m; i++){\n            int x,y;\n            cin>>x>>y;\n            wp[i]=P(x,y);\n        }\n        if(n==1&&m==1){\n            cout<<\"YES\"<<endl;\n            continue;\n        }\n        if(m!=1){\n            // 2_ðIñÅ¼üðì¬µAe_ª»Ì¼üÅ®SÉªÅ«é©²×é\n            bool ok=false;\n            for(int i = 0; i < m; i++){\n                for(int j = 0; j < m; j++){\n                    bool isLeft=false;\n                    bool no=false;\n                    // xªêv\n                    if(EQ(wp[i].real(),wp[j].real())){\n                        // Ç¿çÌvfªÇ¿çÉ®·é©\n                        for(int k = 0; k < n; k++){\n                            if(EQ(bp[k].real(),wp[i].real())){\n                                no=true;\n                                break;\n                            }\n                            else{\n                                if(bp[k].real()<wp[i].real()){\n                                    isLeft=true;\n                                    break;\n                                }\n                                else{\n                                    isLeft=false;\n                                    break;\n                                }\n                            }\n                        }\n                        if(no)continue;\n                    }\n                    else{\n                        // y=d*x+e\n                        double d=(wp[i].imag()-wp[j].imag())/(wp[i].real()-wp[j].real());\n                        double e=wp[j].imag()-wp[j].real()*d;\n                        // Ç¿çÌvfªÇ¿çÉ®·é©\n                        for(int k = 0; k < n; k++){\n                            if(EQ(d*bp[k].real()+e,bp[k].imag())){\n                                no=true;\n                                break;\n                            }\n                            else{\n                                if(d*bp[k].real()+e<bp[k].imag()){\n                                    isLeft=true;\n                                    break;\n                                }\n                                else{\n                                    isLeft=false;\n                                    break;\n                                }\n                            }\n                        }\n                        if(no)continue;\n                    }\n                    // ¶Éª®\n                    if(isLeft){\n                        if(checkRIghtincludeLine(wp[i],wp[j],true)){\n                            // ok\n                            ok=true;\n                            break;\n                        }\n                    }\n                    // E\n                    else{\n                        if(checkLeftincludeLine(wp[i],wp[j],true)){\n                            // ok\n                            ok=true;\n                            break;\n                        }\n                    }\n                }\n                if(ok)break;\n            }\n            if(ok){\n                cout<<\"YES\"<<endl;\n                continue;\n            }\n        }\n        if(n!=1){\n            // 2_ðIñÅ¼üðì¬µAe_ª»Ì¼üÅ®SÉªÅ«é©²×é\n            bool ok=false;\n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                    bool isLeft=false;\n                    bool no=false;\n                    // xªêv\n                    if(EQ(bp[i].real(),bp[j].real())){\n                        // Ç¿çÌvfªÇ¿çÉ®·é©\n                        for(int k = 0; k < m; k++){\n                            if(EQ(wp[k].real(),bp[i].real())){\n                                no=true;\n                                break;\n                            }\n                            else{\n                                if(wp[k].real()<bp[i].real()){\n                                    isLeft=true;\n                                    break;\n                                }\n                                else{\n                                    isLeft=false;\n                                    break;\n                                }\n                            }\n                        }\n                        if(no)continue;\n                    }\n                    else{\n                        // y=d*x+e\n                        double d=(bp[i].imag()-bp[j].imag())/(bp[i].real()-bp[j].real());\n                        double e=bp[j].imag()-bp[j].real()*d;\n                        // Ç¿çÌvfªÇ¿çÉ®·é©\n                        for(int k = 0; k < m; k++){\n                            if(EQ(d*wp[k].real()+e,wp[k].imag())){\n                                no=true;\n                                break;\n                            }\n                            else{\n                                if(d*wp[k].real()+e<wp[k].imag()){\n                                    isLeft=true;\n                                    break;\n                                }\n                                else{\n                                    isLeft=false;\n                                    break;\n                                }\n                            }\n                        }\n                        if(no)continue;\n                    }\n                    // ¶Éª®\n                    if(isLeft){\n                        if(checkRIghtincludeLine(bp[i],bp[j],true)){\n                            // ok\n                            ok=true;\n                            break;\n                        }\n                    }\n                    // E\n                    else{\n                        if(checkLeftincludeLine(bp[i],bp[j],true)){\n                            // ok\n                            ok=true;\n                            break;\n                        }\n                    }\n                }\n                if(ok)break;\n            }\n            if(ok){\n                cout<<\"YES\"<<endl;\n                continue;\n            }\n        }\n        cout<<\"NO\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nlong double EPS = (long double)1e-8;\nstruct Point { long double px, py; };\nPoint r1[100], r2[100]; int n, m;\nvector<pair<Point, int>>vec, vec2;\nbool solve(Point a1, Point a2) {\n\tif (a1.px > a2.px)swap(a1, a2);\n\tif (a1.px == a2.px) {\n\t\tint colour = 0;\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tif (colour == 0) {\n\t\t\t\tif (vec2[i].first.px < a1.px) { colour = 3 - vec2[i].second; }\n\t\t\t\tif (vec2[i].first.px == a1.px) { return false; }\n\t\t\t\tif (vec2[i].first.px > a1.px) { colour = vec2[i].second; }\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (colour != 3 - vec2[i].second && vec2[i].first.px < a1.px) { return false; }\n\t\t\t\tif (vec2[i].first.px == a1.px) { return false; }\n\t\t\t\tif (colour != vec2[i].second && vec2[i].first.px > a1.px) { return false; }\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\telse {\n\t\tlong double KT = (a2.py - a1.py) / (a2.px - a1.px);\n\t\tlong double YY = a1.py - a1.px*KT;\n\t\tint colour = 0;\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tlong double height = YY + KT*vec2[i].first.px;\n\t\t\tif (colour == 0) {\n\t\t\t\tif (vec2[i].first.py < height) { colour = 3 - vec2[i].second; }\n\t\t\t\tif (vec2[i].first.py == height) { return false; }\n\t\t\t\tif (vec2[i].first.py > height) { colour = vec2[i].second; }\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (colour != 3 - vec2[i].second && vec2[i].first.py < height) { return false; }\n\t\t\t\tif (vec2[i].first.py == height) { return false; }\n\t\t\t\tif (colour != vec2[i].second && vec2[i].first.py > height) { return false; }\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n\twhile (true) {\n\t\tvec.clear(); vec2.clear(); cin >> n >> m; if (n == 0 && m == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> r1[i].px >> r1[i].py; vec2.push_back(make_pair(r1[i], 1));\n\t\t\tfor (long double j = -1.0l; j <= 1.0l; j += 1.0l) {\n\t\t\t\tfor (long double k = -1.0l; k <= 1.0l; k += 1.0l) {\n\t\t\t\t\tvec.push_back(make_pair(Point{ r1[i].px + j*EPS,r1[i].py + k*EPS }, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> r2[i].px >> r2[i].py; vec2.push_back(make_pair(r2[i], 2));\n\t\t\tfor (long double j = -1.0l; j <= 1.0l; j += 1.0l) {\n\t\t\t\tfor (long double k = -1.0l; k <= 1.0l; k += 1.0l) {\n\t\t\t\t\tvec.push_back(make_pair(Point{ r1[i].px + j*EPS,r1[i].py + k*EPS }, 2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans = false;\n\t\tfor (int i = 0; i < vec.size(); i++) {\n\t\t\tfor (int j = i + 1; j < vec.size(); j++) {\n\t\t\t\tbool p1 = solve(vec[i].first, vec[j].first);\n\t\t\t\tif (p1 == true)ans = true;\n\t\t\t}\n\t\t}\n\t\tif (ans == true)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Hello. I'm Peter.\n#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<functional>\n#include<cctype>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define peter cout<<\"i am peter\"<<endl\n#define input freopen(\"data.txt\",\"r\",stdin)\n#define randin srand((unsigned int)time(NULL))\n#define INT (0x3f3f3f3f)*2\n#define LL (0x3f3f3f3f3f3f3f3f)*2\n#define gsize(a) (int)a.size()\n#define len(a) (int)strlen(a)\n#define slen(s) (int)s.length()\n#define pb(a) push_back(a)\n#define clr(a) memset(a,0,sizeof(a))\n#define clr_minus1(a) memset(a,-1,sizeof(a))\n#define clr_INT(a) memset(a,INT,sizeof(a))\n#define clr_true(a) memset(a,true,sizeof(a))\n#define clr_false(a) memset(a,false,sizeof(a))\n#define clr_queue(q) while(!q.empty()) q.pop()\n#define clr_stack(s) while(!s.empty()) s.pop()\n#define rep(i, a, b) for (int i = a; i < b; i++)\n#define dep(i, a, b) for (int i = a; i > b; i--)\n#define repin(i, a, b) for (int i = a; i <= b; i++)\n#define depin(i, a, b) for (int i = a; i >= b; i--)\n#define pi acos(-1.0)\n#define eps 1e-10\n#define MOD 1000000007\n#define MAXN\n#define N 200\n#define M\nint dcmp(double x){//判断x正&#36127;或&#20026;0\n    if(fabs(x)<eps) return 0;\n    else if(x<0) return -1;\n    else return 1;\n}\nstruct Point{\n    double x,y;\n    Point(){};\n    Point(double xx,double yy):x(xx),y(yy){};\n    friend bool operator<(const Point A,const Point B){\n        return A.x < B.x || (A.x == B.x && A.y < B.y);\n    }\n};\ntypedef Point Vector;\nvoid readPoint(Point &a){//&#36755;入一个点\n    scanf(\"%lf %lf\",&a.x,&a.y);\n}\ndouble sq(double x){//x^2\n    return x*x;\n}\nVector operator +(const Vector a,const Vector b){//&#20004;向量相加\n    return Vector(a.x+b.x,a.y+b.y);\n}\nVector operator -(const Vector a,const Vector b){//&#20004;向量相&#20943;\n    return Vector(a.x-b.x,a.y-b.y);\n}\nbool operator ==(const Vector a,const Vector b){//判断&#20004;点或&#20004;向量是否一致\n    return dcmp(a.x-b.x)==0 && dcmp(a.y-b.y)==0;\n}\ndouble operator *(const Vector a,const Vector b){//&#20004;向量点乘\n    return a.x*b.x+a.y*b.y;\n}\ndouble operator &(const Vector a,const Vector b){//&#20004;向量叉&#31215;\n    return a.x*b.y-a.y*b.x;\n}\nVector operator *(const Vector b,const double a){//一个数*一个向量\n    return Vector(a*b.x,a*b.y);\n}\nVector operator *(const double a,const Vector b){//一个向量*一个数\n    return Vector(a*b.x,a*b.y);\n}\nPoint MiddlePoint(Point a,Point b){//求&#20004;点的中点\n    return Point((a.x+b.x)/2,(a.y+b.y)/2);\n}\ndouble Length(Vector b){//求一个向量的&#38271;度\n    return sqrt(b*b);\n}\ndouble DistancePointToPoint(Point a,Point b){//求点到点的无向距&#31163;\n    return Length(a-b);\n}\ndouble DistancePointToLine(Point p,Point a,Vector v){//求点到&#32447;的无向距&#31163;\n    Vector w=p-a;\n    return fabs((v&w)/Length(v));\n}\nPoint Point_LineBananaLine(Point p1,Vector v,Point p2,Vector w){//求&#20004;&#32447;的交点(前提是&#20004;向量不共&#32447;)\n    Vector u=p1-p2;\n    double t=(w&u)/(v&w);\n    return p1+v*t;\n}\ndouble polarAngle(Vector a,Vector b){//求&#20004;个向量的无向&#26497;角(0<=x<=pi)\n    double t=(a*b)/Length(a)/Length(b);\n    return acos(t);\n    //而atan2(double y,double x)求的是一个向量与x&#36724;的有向&#26497;角(-pi<x<=pi)\n}\nint ConvexHull(Point *p,int n,Point *ch){\n    sort(p,p+n);\n    int m=0;\n    rep(i,0,n){\n        while(m>1 && dcmp((ch[m-1]-ch[m-2])&(p[i]-ch[m-2]))<=0) m--;\n        ch[m++]=p[i];\n    }\n    int k=m;\n    depin(i,n-2,0){\n        while(m>k && dcmp((ch[m-1]-ch[m-2])&(p[i]-ch[m-2]))<=0) m--;\n        ch[m++]=p[i];\n    }\n    ch[m++] = ch[0];\n    if(n>1) m--;\n    return m;\n}\nbool SegmentStrictlyBananaSegment(Point p1,Point p2,Point w1,Point w2){//判断&#20004;&#32447;段是否&#20005;格香蕉(不包括端点)\n    double x1=(w2-w1)&(p1-w1);\n    double x2=(w2-w1)&(p2-w1);\n    double x3=(p2-p1)&(w1-p1);\n    double x4=(p2-p1)&(w2-p1);\n    return dcmp(x1)*dcmp(x2)<0 && dcmp(x3)*dcmp(x4)<0;\n}\nbool PointInConvex(Point a, Point* ch, int n){\n    int i;\n    if(n==3){\n        if(a.x < min(ch[0].x, ch[1].x) || a.x > max(ch[0].x, ch[1].x)) return false;\n        if(a.y < min(ch[0].y, ch[1].y) || a.y > max(ch[0].y, ch[1].y)) return false;\n    }\n    for(i=1;i<n;i++){\n        if( ((ch[i]-ch[i-1])&(a-ch[i-1])) < 0) return false;\n    }\n    return true;\n}\nint n,m,num_ch1,num_ch2;\nPoint black[N],ch1[N],white[N],ch2[N];\nint main(){\n//    input;\n    while(~scanf(\"%d%d\",&n,&m) && (n+m)){\n        clr(black);\n        clr(white);\n        clr(ch1);\n        clr(ch2);\n        rep(i,0,n){\n            readPoint(black[i]);\n        }\n        num_ch1=ConvexHull(black,n,ch1);\n        rep(i,0,m){\n            readPoint(white[i]);\n        }\n        num_ch2=ConvexHull(white,m,ch2);\n        bool ok=true;\n        if(n==1 && m==1) ok=true;\n        else if(n==1){\n            if(PointInConvex(black[0],ch2,num_ch2)) ok=false;\n            else ok=true;\n        }\n        else if(m==1){\n            if(PointInConvex(white[0],ch1,num_ch1)) ok=false;\n            else ok=true;\n        }\n        //n!=1 && m!=1\n        else{\n            rep(i,1,num_ch1){\n                if(!ok) break;\n                rep(j,1,num_ch2){\n                    if(SegmentStrictlyBananaSegment(ch1[i],ch1[i-1],ch2[j],ch2[j-1])){\n                        ok=false;\n                        break;\n                    }\n                }\n            }\n            rep(i,0,n){\n                if(!ok) break;\n                if(PointInConvex(black[i],ch2,num_ch2)) ok=false;\n            }\n            rep(i,0,m){\n                if(!ok) break;\n                if(PointInConvex(white[i],ch1,num_ch1)) ok=false;\n            }\n        }\n        printf(\"%s\\n\",ok?\"YES\":\"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n\nusing namespace std;\n\n#define EPS (1e-8)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\n\nclass Point{\n    public:\n    double x, y;\n    \n    Point ( double x = 0, double y = 0): x(x), y(y){}\n    \n    Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n    Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n    Point operator * ( double a ){ return Point(x*a, y*a); }\n    Point operator / ( double a ){ return Point(x/a, y/a); }\n\n    double abs() { return sqrt(norm());}\n    double norm() { return x*x + y*y; }\n\n    bool operator < ( const Point &p ) const {\n\treturn x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == ( const Point &p ) const {\n\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\nclass Segment{\n    public:\n    Point p1, p2;\n    Segment(Point s = Point(), Point t = Point()): p1(s), p2(t){}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\n\nbool isOnSegment( Point a, Point b, Point c){\n    if ( a == c || b == c ) return true;\n    return (abs(a-c) + abs(c-b) < abs(a-b) + EPS );\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n    return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t     ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\nbool isIntersect(Segment s1, Segment s2){\n    return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPolygon andrewScan( Polygon s ){\n    Polygon u, l;\n    if ( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n    int n;\n    for ( int i = 2; i < s.size(); i++ ){\n\tu.push_back(s[i]);\n\tfor ( int n = u.size(); n >= 3 && ccw(u[n-3], u[n-2], u[n-1]) != CLOCKWISE; n--){\n\t    u.erase(u.begin()+(n-2));\n\t}\n    }\n\n    for ( int i = s.size()-3; i >= 0; i-- ){\n\tl.push_back(s[i]);\n\tfor ( int n = l.size(); n >= 3 && ccw(l[n-3], l[n-2], l[n-1]) != CLOCKWISE; n--){\n\t    l.erase(l.begin()+(n-2));\n\t}\n\n    }\n    reverse(l.begin(), l.end());\n    for ( int i = u.size()-2; i >= 1; i-- ) l.push_back(u[i]);\n    return l;\n}\n\n// convec polygon with conter clockwise\nbool isInside(Polygon pol, Point p){\n    for ( int i = 0; i < pol.size(); i++ ){\n      if ( ccw(pol[i], pol[(i+1)%pol.size()], p) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\nbool check(int n, int m, Polygon b, Polygon w){\n  b = andrewScan(b);\n  w = andrewScan(w);\n  \n    int t = b.size() + w.size();\n    if ( t == 2 ) {\n      return false;\n    } else if ( t == 3 ){\n      if ( b.size() == 1 ) return isOnSegment(w[0], w[1], b[0] );\n      return isOnSegment(b[0], b[1], w[0]);\n    } else if ( t == 4 ){\n      if ( b.size() == 1 ) return isInside(w, b[0]);\n      else if ( w.size() == 1 ) return isInside(b, w[0]);\n      else return isIntersect(Segment(w[0], w[1]), Segment(b[0], b[1]));\n    }\n    \n    for ( int i = 0; i < b.size(); i++ )\n      if ( isInside(w, b[i]) ) return true;\n    for ( int i = 0; i < w.size(); i++ )\n      if ( isInside(b, w[i]) ) return true;\n    for ( int i = 0; i < b.size(); i++ ){\n      Segment s1 = Segment(b[i], b[(i+1)%b.size()]);\n      for ( int j = 0; j < w.size(); j++ ){\n\tSegment s2 = Segment(w[j], w[(j+1)%w.size()]);\n\tif ( isIntersect(s1, s2) ) return true;\n      }\n    }\n    return false;\n}\n\nint main(){\n  int n, m;\n  double x, y;\n  while(1){\n    cin >> n >> m;\n    if ( n == 0 && m == 0 ) break;\n    Polygon b, w;\n    for ( int i = 0; i < n; i++ ){\n      cin >> x >> y; b.push_back(Point(x, y));\n    }\n    for ( int i = 0; i < m; i++ ){\n      cin >> x >> y; w.push_back(Point(x, y));\n    }\n    if ( check(n, m, b, w) ) cout << \"NO\" << endl;\n    else cout << \"YES\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n  \nusing namespace std;\n  \n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n  \nstruct Point{\n    double x,y;\n  \n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n  \n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n    Point operator / (const double &k)const{ return Point(x/k,y/k); }\n    bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n  \ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\n  \nistream &operator >> (istream &is,Point &p){\n    return is >> p.x >> p.y;\n}\n  \n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n  \nint ccw(Point p0,Point p1,Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a,b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n  \nstruct Segment{\n    Point s,t;\n    Segment(){}\n    Segment(Point s,Point t) : s(s),t(t) {}\n};\n  \nbool isIntersectSP(const Segment &s,const Point &p){\n    return equal(ccw(s.s,s.t,p),0);\n}\n  \nbool isIntersectSS(const Segment &a,const Segment &b){\n    Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0\n\t&& ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n  \n#define prev(G,i) (G[(i-1+G.size())%G.size()])\n#define curr(G,i) (G[i%G.size()])\n#define next(G,i) (G[(i+1)%G.size()])\ntypedef vector<Point> Polygon;\n  \nbool check(const Polygon &pg,const Point &p){\n    int N = pg.size();\n    bool in = false;\n    for(int i = 0 ; i < N ; i++){\n\tPoint a = curr(pg,i)-p, b = next(pg,i)-p;\n\tif(a.y > b.y) swap(a,b);\n\tif(a.y <= 0 && 0 < b.y && cross(a,b) > 0) in = !in;\n\tif(cross(a,b) == 0 && dot(a,b) <= 0) return true;\n    }\n    return in;\n}\n \nbool sortY(Point p1,Point p2){\n    if(p1.y != p2.y){\n\treturn (p1.y - p2.y < -EPS);\n    }else{ \n\treturn (p1.x - p2.x < -EPS);\n    }\n}\n \nPolygon convex_hull(Polygon &ps){\n    int N = ps.size(),j = 0;\n    Polygon pg(N*2);\n    sort(ps.begin(),ps.end(),sortY);\n    for(int i = 0 ; i < N ; i++,j++){\n\twhile(j >= 2 && ccw(pg[j-2],pg[j-1],ps[i]) == -1){\n\t    j--;\n\t}\n\tpg[j] = ps[i];\n    }\n    int k = j+1;\n    for(int i = N-2 ; i >= 0 ; i--,j++){\n\twhile(j >= k && ccw(pg[j-2],pg[j-1],ps[i]) == -1){\n\t    j--;\n\t}\n\tpg[j] = ps[i];\n    }\n    pg.resize(j-1);\n    return pg;\n}\n  \nbool solve(Polygon &bp,Polygon &wp){\n    int N = bp.size(), M = wp.size();\n    if(N == 1 && M == 1){\n\treturn !(equal(bp[0].x,wp[0].x) && equal(bp[0].y,wp[0].y));\n    }\n    if(N == 2 && M == 1){\n\tSegment s(bp[0],bp[1]);\n\treturn !isIntersectSP(s,wp[0]);\n    }\n    if(N == 1 && M == 2){\n\tSegment s(wp[0],wp[1]);\n\treturn !isIntersectSP(s,bp[0]);\n    }\n    if(N == 2 && M == 2){\n\tSegment s1(bp[0],bp[1]),s2(wp[0],wp[1]);\n\treturn !isIntersectSS(s1,s2);\n    }\n    bp = convex_hull(bp);\n    wp = convex_hull(wp);\n    if(N == 1 && M >= 3){\n\treturn !check(wp,bp[0]);\n    }\n    if(N >= 3 && M == 1){\n\treturn !check(bp,wp[0]);\n    }\n    if(N == 2 && M >= 3){\n\tSegment s1(bp[0],bp[1]);\n\tif(check(wp,bp[0]) || check(wp,bp[1])){\n\t    return false;\n\t}\n\tfor(int i = 0 ; i < M ; i++){\n\t    for(int j = i+1 ; j < M ; j++){\n\t\tSegment s2(wp[i],wp[j]);\n\t\tif(isIntersectSS(s1,s2)){\n\t\t    return false;\n\t\t}\n\t    }\n\t}\n\treturn true;\n    }\n    if(N >= 3 && M == 2){\n\tSegment s1(wp[0],wp[1]);\n\tif(check(bp,wp[0]) || check(bp,wp[1])){\n\t    return false;\n\t}\n\tfor(int i = 0 ; i < N ; i++){\n\t    for(int j = i+1 ; j < N ; j++){\n\t\tSegment s2(bp[i],bp[j]);\n\t\tif(isIntersectSS(s1,s2)){\n\t\t    return false;\n\t\t}\n\t    }\n\t}\n\treturn true;\n    }\n    for(int i = 0 ; i < N ; i++){\n\tif(check(wp,bp[i])){\n\t    return false;\n\t}\n    }\n    for(int i = 0 ; i < M ; i++){\n\tif(check(bp,wp[i])){\n\t    return false;\n\t}\n    }\n    return true;\n}\n  \nint main(){\n    int N,M;\n    while(cin >> N >> M,N){\n\tPolygon bp(N),wp(M);\n\tfor(int i = 0 ; i < N ; i++){\n\t    cin >> bp[i];\n\t}\n\tfor(int i = 0 ; i < M ; i++){\n\t    cin >> wp[i];\n\t}\n\tcout << (solve(bp,wp) ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**** Geometrical Library (complex class version) ****/\n\n#include<cmath>\n#include<vector>\n#include<complex>\n#include<algorithm>\n\n#define\tEPS\t1e-9\n\nenum {CCW=1,CW=-1,ON=0};\n\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tcomplex<double>\tPoint;\n\nclass Line:public vector<Point>{\npublic:\n\tLine(){}\n\tLine(const Point &a,const Point &b){\n\t\tpb(a),pb(b);\n\t}\n};\n\nclass Segment:public Line{\npublic:\n\tSegment(){}\n\tSegment(const Point &a,const Point &b):Line(a,b){}\n};\n\ntypedef\tvector<Point>\tPolygon;\n\nnamespace std{\n\tbool operator <(const Point &a,const Point &b){\n\t\treturn (real(a)==real(b))?(imag(a)<imag(b)):(real(a)<real(b));\n\t}\n\tbool operator >(const Point &a,const Point &b){\n\t\treturn b<a;\n\t}\n}\n\ndouble dot(const Point &a,const Point &b){\n\treturn real(a)*real(b)+imag(a)*imag(b);\n}\n\ndouble cross(const Point &a,const Point &b){\n\treturn real(a)*imag(b)-imag(a)*real(b);\n}\n\nint ccw(const Point &a,Point b,Point c){\n\tb-=a,c-=a;\n\tdouble rotdir=cross(b,c);\n\tif(rotdir>EPS)\t\treturn CCW;\n\tif(rotdir<-EPS)\t\treturn CW;\n\treturn ON;\n}\n\nPolygon ConvexHull(vector<Point> ps){\t// Graham Scan\n\tint n=ps.size();\n\tsort(ps.begin(),ps.end());\n\n\tvector<Point> ch_u(n);\n\tint n_u=0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tch_u[n_u++]=ps[i];\n\t\twhile(n_u>=3 && ccw(ch_u[n_u-3],ch_u[n_u-2],ch_u[n_u-1])!=CCW){\n\t\t\tch_u[n_u-2]=ch_u[n_u-1];\n\t\t\tn_u--;\n\t\t}\n\t}\n\n\tvector<Point> ch_l(n);\n\tint n_l=0;\n\tfor(int i=0;i<n;i++){\n\t\tch_l[n_l++]=ps[i];\n\t\twhile(n_l>=3 && ccw(ch_l[n_l-3],ch_l[n_l-2],ch_l[n_l-1])!=CCW){\n\t\t\tch_l[n_l-2]=ch_l[n_l-1];\n\t\t\tn_l--;\n\t\t}\n\t}\n\n\tPolygon ch;\n\tfor(int i=0;i<n_u-1;i++)\tch.pb(ch_u[i]);\n\tfor(int i=0;i<n_l-1;i++)\tch.pb(ch_l[i]);\n\treturn ch;\n}\n\ninline void calc_abc(const Line &l,double &a,double &b,double &c){\t// l : ax+by+c=0\n\ta=imag(l[0])-imag(l[1]);\n\tb=real(l[1])-real(l[0]);\n\tc=cross(l[0],l[1]);\n}\n\nbool intersect(const Line &l,const Line &m,Point *p=NULL){\n\t// this routine also returns true in case \"M is on L\", etc,.\n\tif(abs(cross(l[1]-l[0],m[1]-m[0]))>EPS\n\t|| abs(cross(l[1]-l[0],m[0]-l[0]))<EPS){\n\t\tif(p){\n\t\t\tdouble a1,b1,c1,a2,b2,c2;\n\t\t\tcalc_abc(l,a1,b1,c1);\n\t\t\tcalc_abc(m,a2,b2,c2);\n\t\t\tdouble det=a1*b2-a2*b1;\n\t\t\tif(abs(det)<EPS)\t*p=l[0];\t// l==m\n\t\t\telse\t\t\t\t*p=Point(b1*c2-b2*c1,a2*c1-a1*c2)/det;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool intersect(const Segment &s,const Segment &t,Point *p=NULL){\n\tif(max(real(s[0]),real(s[1]))<min(real(t[0]),real(t[1]))\n\t|| max(real(t[0]),real(t[1]))<min(real(s[0]),real(s[1]))\n\t|| max(imag(s[0]),imag(s[1]))<min(imag(t[0]),imag(t[1]))\n\t|| max(imag(t[0]),imag(t[1]))<min(imag(s[0]),imag(s[1])))\treturn false;\n\n\tif(ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0\n\t&& ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0){\n\t\tif(p){\n\t\t\tdouble a1,b1,c1,a2,b2,c2;\n\t\t\tcalc_abc(s,a1,b1,c1);\n\t\t\tcalc_abc(t,a2,b2,c2);\n\t\t\tdouble det=a1*b2-a2*b1;\n\t\t\tif(abs(det)<EPS){\t// s is parallel to t\n\t\t\t\tPoint q[3]={s[0],s[1],t[0]};\n\t\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\t\tif(dot(q[i]-s[0],q[i]-s[1])<EPS && dot(q[i]-t[0],q[i]-t[1])<EPS){\n\t\t\t\t\t\t*p=q[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\t*p=Point(b1*c2-b2*c1,a2*c1-a1*c2)/det;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**************** Library END ****************/\n\n#include<cstdio>\n\n#define\trep(i,n)\tfor(int i=0;i<n;i++)\n\nbool contain(const Polygon &g,const Point &p){\n\tint n=g.size();\n\tint dir=ccw(g[n-1],g[0],p);\n\tif(dir==ON)\treturn (dot(g[0]-p,g[n-1]-p)<EPS);\n\tfor(int i=0;i<n-1;i++){\n\t\tint a=ccw(g[i],g[i+1],p);\n\t\tif(a==ON)\treturn (dot(g[i+1]-p,g[i]-p)<EPS);\n\t\tif(a!=dir)\treturn false;\n\t}\n\treturn true;\n}\n\nbool contain(const Polygon &g1,const Polygon &g2){\n\trep(i,g2.size()) if(contain(g1,g2[i])) return true;\n\treturn false;\n}\n\nbool intersect(const Polygon &g1,const Polygon &g2){\n\tint n1=g1.size(),n2=g2.size();\n\trep(i,n1)rep(j,n2){\n\t\tif(intersect(Segment(g1[i],g1[(i+1)%n1]),Segment(g2[j],g2[(j+1)%n2])))\treturn true;\n\t}\n\treturn contain(g1,g2) || contain(g2,g1);\n}\n\nint main(){\n\tfor(int nb,nw;scanf(\"%d%d\",&nb,&nw),nb;){\n\t\tvector<Point> b(nb),w(nw);\n\t\trep(i,nb){ int x,y; scanf(\"%d%d\",&x,&y); b[i]=Point(x,y); }\n\t\trep(i,nw){ int x,y; scanf(\"%d%d\",&x,&y); w[i]=Point(x,y); }\n\n\t\tPolygon ch_b,ch_w;\n\t\tch_b=(nb>1)?ConvexHull(b):b;\n\t\tch_w=(nw>1)?ConvexHull(w):w;\n\t\tputs(intersect(ch_b,ch_w)?\"NO\":\"YES\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#define eps 1e-9\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tdouble add(double a, double b){\n\t\tif(fabs(a+b) < eps * (fabs(a) + fabs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d operator+(vec2d ope){\n\t\treturn vec2d(add(x, ope.x), add(y, ope.y));\n\t}\n\tvec2d operator-(vec2d ope){\n\t\treturn vec2d(add(x, -ope.x), add(y, -ope.y));\n\t}\n\tvec2d operator*(double t){\n\t\treturn vec2d(x*t, y*t);\n\t}\n\tbool operator<(vec2d ope){\n\t\treturn x < ope.x || (x == ope.x && y < ope.y);\n\t}\n\tdouble dot(vec2d ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(vec2d ope){\n\t\treturn add(x*ope.y, -y*ope.x);\n\t}\n};\n\nbool isOnS(vec2d p, vec2d q, vec2d x)\n{\n\treturn (p-x).cross(q-x) == 0 && (p-x).dot(q-x) <= 0;\n}\n\nbool isCross(vec2d p, vec2d q, vec2d r, vec2d s)\n{\n\tif((q-p).cross(s-r) == 0){\n\t\treturn isOnS(p, q, r) || isOnS(p, q, s) || isOnS(r, s, p) || isOnS(r, s, q);\t\n\t}\n\tdouble t = (r-p).cross(s-r) / (q-p).cross(s-r);\n\tvec2d x = p + (q-p)*t;\n\treturn isOnS(p, q, x) && isOnS(r, s, x);\n}\n\nbool isInTriangle(vec2d a, vec2d b, vec2d p)\n{\n\tif(a.cross(b) == 0) return false;\n\tdouble s = a.cross(p) / a.cross(b);\n\tdouble t = p.cross(b) / a.cross(b);\n\t\n\treturn (s >= 0 && t >= 0 && s+t <= 1);\n}\n\nbool isInConvex(vector<vec2d> &vec, vec2d p)\n{\n\tif(vec.size() <= 1) return false;\n\tif(vec.size() == 2){\n\t\treturn isOnS(vec[0], vec[1], p);\n\t}\n\t\n\tfor(int i = 1; i <= vec.size()-2; i++){\n\t\tif(isInTriangle(vec[i] - vec[0], vec[i+1] - vec[0], p - vec[0])) return true;\n\t}\n\treturn false;\n}\n\nint n, m;\nvector<vec2d> bin, win;\nvector<vec2d> black, white;\n\nvoid GrahamScan(vector<vec2d> &vec, vector<vec2d> &poly)\n{\n\tif(vec.size() == 1){\n\t\tpoly = vec;\n\t\treturn;\n\t}\n\t\n\tsort(vec.begin(), vec.end());\n\tpoly.clear();\n\tpoly.resize( 2*vec.size() );\n\t\n\tint top = -1;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\twhile(top >= 1 && (vec[i] - poly[top]).cross(poly[top-1] - poly[top]) <= 0) top--;\n\t\ttop++;\n\t\tpoly[top] = vec[i];\n\t}\n\tfor(int i = vec.size()-2, t = top; i >= 0; i--){\n\t\twhile(t >= top+1 && (vec[i] - poly[top]).cross(poly[top-1] - poly[top]) <= 0) top--;\n\t\ttop++;\n\t\tpoly[top] = vec[i];\n\t}\n\tpoly.resize(top);\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0) break;\n\t\t\n\t\tbin.clear(), win.clear();\n\t\tdouble x, y;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x >> y;\n\t\t\tbin.push_back( vec2d(x, y) );\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin >> x >> y;\n\t\t\twin.push_back( vec2d(x, y) );\n\t\t}\n\t\t\n\t\tGrahamScan(bin, black);\n\t\tGrahamScan(win, white);\n\t\t\n\t\tbool ans = true;\n\t\tfor(int bs = 0; bs < black.size(); bs++){\n\t\t\tfor(int ws = 0; ws < white.size(); ws++){\n\t\t\t\tif(isCross(black[bs], black[(bs+1)%black.size()], white[ws], white[(ws+1)%white.size()])){\n\t\t\t\t\tans = false;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(isInConvex(black, white[0])) ans = false;\n\t\tif(isInConvex(white, black[0])) ans = false;\n\t\t\n\t\tend:;\n\t\tif(ans) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  int b, w;\n  while(cin>>b>>w && (b != 0 || w != 0)){\n    srand(time(NULL));\n    vector<double> x1(b), y1(b);\n    vector<double> x2(w), y2(w);\n    REP(i, b)cin>>x1[i]>>y1[i];\n    REP(i, w)cin>>x2[i]>>y2[i];\n    bool ans = false;\n    REP(time, 10100 * 3){\n      const double D = 1e6;\n      double t = (double)rand()/RAND_MAX * D * ((rand() % 2) ?  1 : -1);\n      double min_b = 1e30, max_b = -1e30;\n      double min_w = 1e30, max_w = -1e30;\n      REP(i, b){\n        double d = (y1[i] + t)/x1[i];\n        min_b = min(min_b, d);\n        max_b = max(max_b, d);\n      }\n      REP(i, w){\n        double d = (y2[i] + t)/x2[i];\n        min_w = min(min_w, d);\n        max_w = max(max_w, d);\n      }\n      if(min_w > max_b) ans = true;\n      if(min_b > max_w) ans = true;\n      if(ans) break;\n    }\n    if(ans) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\ntypedef complex < double > Point;\n\ntypedef vector < Point > Polygon;\nnamespace std {\n    bool operator < (Point a,Point b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\n\n\nstruct Line : Polygon{\n    Line(){};\n    Line(Point p,Point q){ push_back(p);push_back(q); }\n};\nstruct Circle{\n    Point p;\n    double r;\n    Circle(){};\n    Circle(Point a, double s){ p = a;r = s; }\n};\n\n// ベクタの長さ\ndouble VectorLength(Point a){\n    return abs(a);\n}\n\n// 二点間距離\ndouble DistancePP(Point a,Point b){\n    return abs(a-b);\n}\n\n// 単位ベクトル\nPoint UnitVector(Point a){\n    return a / abs(a);\n}\n\n// 法線ベクトル\npair<Point,Point> NormalVector(Point a){\n    Point n1 = a * Point(0,1);\n    Point n2 = a * Point(0,-1);\n    return make_pair(n1,n2);\n}\n\n//外積\ndouble cross(Point p,Point q){\n    return imag(conj(p)*q);\n}\n\n//内積\ndouble dot(Point p,Point q){\n    return real(conj(p)*q);\n}\n\nint ccw(Point a,Point b,Point c){\n    b-=a,c-=a;\n    if(cross(b,c)>0)return 1; //反時計回り\n    if(cross(b,c)<0)return -1; //時計回り\n    if(dot(b,c)<0)return 2; //直線上に c - a - b\n    if(norm(b)<norm(c))return -2; // 直線上に a - b - c\n    return 0; // 直線上に a - c - b\n}\n\nPoint normalize(Point P, double l){\n    double a = real(P), b = imag(P);\n    double y = sqrt(b*b/(a*a+b*b)*l*l);\n    double x = (a/b)*y;\n\n    return Point(x,y);\n}\n\n//三角形の面積\ndouble TriangleArea(Point A, Point B, Point C){\n    return abs(cross(B-A,C-A)/2);\n}\n\n//多角形の面積\ndouble VertexArea(Polygon v){\n    double ret = 0;\n    for(int i=1;i<v.size()-1;i++){\n        ret += TriangleArea(v[0],v[i],v[i+1]);\n    }\n    return abs(ret);\n}\n\nbool intersectLL(Line l, Line m) {\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // 平行でない\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // 同一の線\n}\nbool intersectLS(Line l, Line s) {\n    return cross(l[1]-l[0], s[0]-l[0])*       // s[0] が lの左\n           cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] が lの右\n}\nbool intersectLP(Line l, Point p) {\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(Line l, Point p);\nbool intersectCS(Circle C,Line l){\n    return (distanceLP(l,C.p) < C.r + EPS and\n             (C.r < abs(C.p-l[0]) + EPS or C.r < abs(C.p-l[1]) + EPS));\n}\n//↓2円の交点二つを返す（ポインタ）,戻り値は交点の個数\nint intersectCC(Circle A, Circle B, Point *p, Point *q){\n\n    Point P,Q;\n    if(B.p < A.p)swap(A.p,B.p);\n    Point dv = B.p - A.p;//ベクトル\n\n\n    double L = sqrt(norm(dv));\n    int num;\n    //距離がLの場合\n    if( L==(A.r + B.r) ){\n        num = 1;\n        //交点1つ\n        //虚数軸に沿って並んでいるとバグる？\n        dv = normalize(dv,A.r);\n        P = Q = Point(real(dv)+real(A.p),imag(dv)+imag(A.p));\n    }\n    else if( L<(A.r + B.r) && L > fabs(A.r - B.r) ){\n        num = 2;\n        //交点2つ\n        /*\n        交点の一方Qからベクトルdvに垂線を下ろしたところをptとする\n        ふたつの直角三角形p0-pt-Q、p1-pt-Qができる\n        p0-pt間の長さをtとすると、これらの三角形のQ-ptの長さは等しいため、\n\n        r0*r0 - t*t = r1*r1 - (L-t)*(L-t)\n        r0*r0 - t*t = r1*r1 - L*L - t*t + 2*L*t\n        t = (r0*r0 - r1*r1 + L*L)/(2*L)\n\n        tから、p0-Qベクトルとdvベクトルとの角度aを求め、\n        dvベクトルから、+a,-aの座標を求めれば交点となる\n        */\n\n        //tを求める\n        double t = 0.5*( A.r*A.r - B.r*B.r + L*L)/L;\n\n        //p0-Qベクトルとdvベクトルの角度\n        double a = acos( t/A.r );\n\n        //dvベクトルの角度\n        double a0 = atan2( imag(dv), real(dv) );\n\n        //交点\n        P = Point( real(A.p) + A.r*cos(a0+a), imag(A.p) + A.r*sin(a0+a) );\n        Q = Point( real(A.p) + A.r*cos(a0-a), imag(A.p) + A.r*sin(a0-a) );\n\n    }\n    else{\n        num = 0;\n        //交点なし\n    }\n\n    *p = P;\n    *q = Q;\n\n    return num;\n}\n/*\n// 直線と点の最短距離を実現する直線の点(垂線の足)(未検証)\npoint nearest_point_line_and_point(point a1,point a2,point b){\n    return a1 + (a2-a1) * dot((a2-a1),(b-a1)) / norm(a2-a1);\n}\n\n// 線分と点の最短距離を実現する線分嬢の点(未検証）\npoint nearest_point_linesegment_and_point(point a1,point a2,point b){\n    if(dot(a2-a1,b-a1) < EPS) return a1;\n    if(dot(a1-a2,b-a2) < EPS) return a2;\n    return nearest_point_line_and_point(a1,a2,b);\n}\n*/\nPoint projection(Line l, Point p) {//射影\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t * (l[0]-l[1]);\n}\nPoint reflection(Line l, Point p) {//反射\n    return p + (projection(l, p) - p) + (projection(l, p) - p);\n}\ndouble distanceLP(Line l, Point p) {\n    return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(Line l, Line s) {\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(Line s, Point p) {\n    const Point r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(Line s, Line t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nPoint crosspoint(Line l, Line m) {\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n    if (abs(A) < EPS);\n    return m[0] + B / A * (m[1] - m[0]);\n}\n/*\ndouble area(Polygon P) {//多角形の面積\n    double A = 0;\n    for (int i = 0; i < P.size(); ++i)\n        A += cross(curr(P, i), next(P, i));\n    return A;\n}\n*/\nPolygon ConvexHull(Polygon ps) {//凸包\n    int n = ps.size(), k = 0;\n    if(n == 1)return ps;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    ch.resize(k-1);\n    return ch;\n}\n\n// Point - Vertex\nenum{OUT, ON, IN};\nint IsInnerPointVertex(Polygon ps,Point a){\n    bool flg = false;\n    for(int i = 0;i < ps.size();i++){\n        Point p = ps[i] - a,q = ps[(i+1)%ps.size()] - a;\n        if(imag(p)>imag(q))swap(p,q);\n        if(imag(p)<=0&&0<imag(q)){\n            if(cross(p,q) < 0)flg = !flg;\n        }\n        if(cross(p,q) == 0 && dot(p,q) <= 0)return ON;\n    }\n    return flg ? IN : OUT;\n}\nint main(){\n    int n,m;\n    while(cin>>n>>m,n){\n        Polygon G,H;\n        for(int i = 0;i < n;i++){\n            double x,y;\n            cin>>x>>y;\n            G.push_back(Point(x,y));\n        }\n        for(int i = 0;i < m;i++){\n            double x,y;\n            cin>>x>>y;\n            H.push_back(Point(x,y));\n        }\n        G = ConvexHull(G);\n        H = ConvexHull(H);\n        int g = G.size(),h = H.size();\n        //cout<<g<<\" \"<<h<<endl;\n        if(g > h)swap(G,H);\n        bool flg = true;\n        for(int i = 0;i < g;i++){\n            if(IsInnerPointVertex(H,G[i]) != OUT){\n                flg = false;\n                break;\n            }\n        }\n        for(int i = 0;i < h;i++){\n            if(IsInnerPointVertex(G,H[i]) != OUT){\n                flg = false;\n                break;\n            }\n        }\n\n        if(h == 1)flg = true;\n        else if(g == 1 && h == 2){\n            flg = !(intersectSP(Line(H[0],H[1]),G[0]));\n        }\n        else if(g == 2 && h == 2){\n            flg = !(intersectSS(Line(G[0],G[1]),Line(H[0],H[1])));\n        }\n        else if(g == 2){\n            flg = true;\n            for(int i = 0;i < h;i++){\n                int j = (i+1)%h;\n                if(intersectSS(Line(G[0],G[1]),Line(H[i],H[j])))flg = false;\n            }\n        }\n        if(flg)cout<<\"YES\"<<endl;\n        else cout<<\"NO\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\n#include <complex>\n#include <vector>\n\nusing namespace std;\ntypedef complex<long long> Complex;\ntypedef vector<Complex> Polygon;\nclass Line : public vector<Complex> {\npublic:\n  Line(const Complex &a, const Complex &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nnamespace std {\n  bool operator<(const Complex &a, const Complex &b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\n\nlong long cross(const Complex &a, const Complex &b) {\n  return imag(conj(a) * b);\n}\n\nlong long dot(const Complex &a, const Complex &b) {\n  return real(conj(a) * b);\n}\n\nint ccw(Complex a, Complex b, Complex c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0) { return 1; }\n  if (cross(b, c) < 0) { return -1; }\n  if (dot(b, c) < 0) { return 2; }\n  if (norm(b) < norm(c)) { return -2; }\n  return 0;\n}\n\nPolygon convex_hull(Polygon ps) {\n  int n = ps.size();\n  int k = 0;\n  Polygon ch(2 * n);\n  sort(ps.begin(), ps.end());\n  for (int i = 0; i < n; ch[k++] = ps[i++]) {\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) { k--; }\n  }\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--]) {\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) { k--; }\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n    ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nbool intersectSP(const Line &s, const Complex &p) {\n  return ccw(s[0], s[1], p) == 0;\n}\n\nbool contains(const Polygon &P, const Complex &p) {\n  bool in = false;\n  for (int i = 0; i < (int)P.size(); i++) {\n    int next = (i + 1) % (int)P.size();\n    Line asegment(P[i], P[next]);\n    Line bsegment(p, p + Complex(100000, 1));\n    if (intersectSS(asegment, bsegment)) { in = !in; }\n    if (intersectSP(asegment, p)) { return true; }\n  }\n  return in;\n}\n\nbool intersectPP(const Polygon &a, const Polygon &b) {\n  if (a.size() <= 1 && b.size() <= 1) {\n    return a[0].real() == b[0].real() && a[0].imag() == b[0].imag();\n  }\n  if (a.size() != 1 || b.size() != 1) {\n    for (int i = 0; i < (int)a.size(); i++) {\n      int next = (i + 1) % (int)a.size();\n      Line asegment(a[i], a[next]);\n      for (int j = 0; j < (int)b.size(); j++) {\n        int next = (j + 1) % (int)b.size();\n        Line bsegment(b[j], b[next]);\n        if (intersectSS(asegment, bsegment)) { return true; }\n      }\n    }\n  }\n  if (b.size() != 1) {\n    if (contains(b, a[0])) { return true; }\n  }\n  if (a.size() != 1) {\n    if (contains(a, b[0])) { return true; }\n  }\n  return false;\n}\n\nint main() {\n  int n, m;\n  while (scanf(\"%d %d\", &n, &m), n|m) {\n    Polygon white;\n    Polygon black;\n    for (int i = 0; i < n; i++) {\n      int x, y;\n      scanf(\"%d %d\", &x, &y);\n      white.push_back(Complex(x, y));\n    }\n    if (n > 1) {\n      white = convex_hull(white);\n    }\n    for (int i = 0; i < (int)white.size(); i++) {\n      //cout << white[i] << endl;\n    }\n    //cout << endl;\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      scanf(\"%d %d\", &x, &y);\n      black.push_back(Complex(x, y));\n    }\n    if (m > 1) {\n      black = convex_hull(black);\n    }\n    for (int i = 0; i < (int)black.size(); i++) {\n      //cout << black[i] << endl;\n    }\n    if (!intersectPP(white, black)) {\n      puts(\"YES\");\n    } else {\n      puts(\"NO\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//Hello. I'm Peter.\n#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<functional>\n#include<cctype>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define peter cout<<\"i am peter\"<<endl\n#define input freopen(\"data.txt\",\"r\",stdin)\n#define randin srand((unsigned int)time(NULL))\n#define INT (0x3f3f3f3f)*2\n#define LL (0x3f3f3f3f3f3f3f3f)*2\n#define gsize(a) (int)a.size()\n#define len(a) (int)strlen(a)\n#define slen(s) (int)s.length()\n#define pb(a) push_back(a)\n#define clr(a) memset(a,0,sizeof(a))\n#define clr_minus1(a) memset(a,-1,sizeof(a))\n#define clr_INT(a) memset(a,INT,sizeof(a))\n#define clr_true(a) memset(a,true,sizeof(a))\n#define clr_false(a) memset(a,false,sizeof(a))\n#define clr_queue(q) while(!q.empty()) q.pop()\n#define clr_stack(s) while(!s.empty()) s.pop()\n#define rep(i, a, b) for (int i = a; i < b; i++)\n#define dep(i, a, b) for (int i = a; i > b; i--)\n#define repin(i, a, b) for (int i = a; i <= b; i++)\n#define depin(i, a, b) for (int i = a; i >= b; i--)\n#define pi acos(-1.0)\n#define eps 1e-10\n#define MOD 1000000007\n#define MAXN\n#define N 200\n#define M\nint dcmp(double x){//蛻、譁ュx豁」雍滓?荳コ0\n    if(fabs(x)<eps) return 0;\n    else if(x<0) return -1;\n    else return 1;\n}\nstruct Point{\n    double x,y;\n    Point(){};\n    Point(double xx,double yy):x(xx),y(yy){};\n    friend bool operator<(const Point A,const Point B){\n        return A.x < B.x || (A.x == B.x && A.y < B.y);\n    }\n};\ntypedef Point Vector;\nvoid readPoint(Point &a){//霎灘?荳?クェ轤ケ\n    scanf(\"%lf %lf\",&a.x,&a.y);\n}\ndouble sq(double x){//x^2\n    return x*x;\n}\nVector operator +(const Vector a,const Vector b){//荳、蜷鷹?逶ク蜉?    return Vector(a.x+b.x,a.y+b.y);\n}\nVector operator -(const Vector a,const Vector b){//荳、蜷鷹?逶ク蜃?    return Vector(a.x-b.x,a.y-b.y);\n}\nbool operator ==(const Vector a,const Vector b){//蛻、譁ュ荳、轤ケ謌紋ク、蜷鷹?譏ッ蜷ヲ荳??\n    return dcmp(a.x-b.x)==0 && dcmp(a.y-b.y)==0;\n}\ndouble operator *(const Vector a,const Vector b){//荳、蜷鷹?轤ケ荵?    return a.x*b.x+a.y*b.y;\n}\ndouble operator &(const Vector a,const Vector b){//荳、蜷鷹?蜿臥ァッ\n    return a.x*b.y-a.y*b.x;\n}\nVector operator *(const Vector b,const double a){//荳?クェ謨ー*荳?クェ蜷鷹?\n    return Vector(a*b.x,a*b.y);\n}\nVector operator *(const double a,const Vector b){//荳?クェ蜷鷹?*荳?クェ謨ー\n    return Vector(a*b.x,a*b.y);\n}\nPoint MiddlePoint(Point a,Point b){//豎ゆク、轤ケ逧?クュ轤ケ\n    return Point((a.x+b.x)/2,(a.y+b.y)/2);\n}\ndouble Length(Vector b){//豎ゆク?クェ蜷鷹?逧?柄蠎ヲ\n    return sqrt(b*b);\n}\ndouble DistancePointToPoint(Point a,Point b){//豎らせ蛻ー轤ケ逧?裏蜷題キ晉ヲサ\n    return Length(a-b);\n}\ndouble DistancePointToLine(Point p,Point a,Vector v){//豎らせ蛻ー郤ソ逧?裏蜷題キ晉ヲサ\n    Vector w=p-a;\n    return fabs((v&w)/Length(v));\n}\nPoint Point_LineBananaLine(Point p1,Vector v,Point p2,Vector w){//豎ゆク、郤ソ逧?コ、轤ケ(蜑肴署譏ッ荳、蜷鷹?荳榊?郤ソ)\n    Vector u=p1-p2;\n    double t=(w&u)/(v&w);\n    return p1+v*t;\n}\ndouble polarAngle(Vector a,Vector b){//豎ゆク、荳ェ蜷鷹?逧?裏蜷第栫隗?0<=x<=pi)\n    double t=(a*b)/Length(a)/Length(b);\n    return acos(t);\n    //閠径tan2(double y,double x)豎ら噪譏ッ荳?クェ蜷鷹?荳支霓エ逧?怏蜷第栫隗?-pi<x<=pi)\n}\nint ConvexHull(Point *p,int n,Point *ch){\n    sort(p,p+n);\n    int m=0;\n    rep(i,0,n){\n        while(m>1 && dcmp((ch[m-1]-ch[m-2])&(p[i]-ch[m-2]))<=0) m--;\n        ch[m++]=p[i];\n    }\n    int k=m;\n    depin(i,n-2,0){\n        while(m>k && dcmp((ch[m-1]-ch[m-2])&(p[i]-ch[m-2]))<=0) m--;\n        ch[m++]=p[i];\n    }\n    ch[m++] = ch[0];\n    if(n>1) m--;\n    return m;\n}\nbool SegmentStrictlyBananaSegment(Point p1,Point p2,Point w1,Point w2){//蛻、譁ュ荳、郤ソ谿オ譏ッ蜷ヲ荳・譬シ鬥呵負(荳榊桁諡ャ遶ッ轤ケ)\n    double x1=(w2-w1)&(p1-w1);\n    double x2=(w2-w1)&(p2-w1);\n    double x3=(p2-p1)&(w1-p1);\n    double x4=(p2-p1)&(w2-p1);\n    return dcmp(x1)*dcmp(x2)<0 && dcmp(x3)*dcmp(x4)<0;\n}\nbool PointInConvex(Point a, Point* ch, int n){\n    int i;\n    if(n==3){\n        if(a.x < min(ch[0].x, ch[1].x) || a.x > max(ch[0].x, ch[1].x)) return false;\n        if(a.y < min(ch[0].y, ch[1].y) || a.y > max(ch[0].y, ch[1].y)) return false;\n    }\n    for(i=1;i<n;i++){\n        if( ((ch[i]-ch[i-1])&(a-ch[i-1])) < 0) return false;\n    }\n    return true;\n}\nint n,m,num_ch1,num_ch2;\nPoint black[N],ch1[N],white[N],ch2[N];\nint main(){\n//    input;\n    while(~scanf(\"%d%d\",&n,&m) && (n+m)){\n        clr(black);\n        clr(white);\n        clr(ch1);\n        clr(ch2);\n        rep(i,0,n){\n            readPoint(black[i]);\n        }\n        num_ch1=ConvexHull(black,n,ch1);\n        rep(i,0,m){\n            readPoint(white[i]);\n        }\n        num_ch2=ConvexHull(white,m,ch2);\n        bool ok=true;\n        if(n==1 && m==1) ok=true;\n        else if(n==1){\n            if(PointInConvex(black[0],ch2,num_ch2)) ok=false;\n            else ok=true;\n        }\n        else if(m==1){\n            if(PointInConvex(white[0],ch1,num_ch1)) ok=false;\n            else ok=true;\n        }\n        //n!=1 && m!=1\n        else{\n            rep(i,1,num_ch1){\n                if(!ok) break;\n                rep(j,1,num_ch2){\n                    if(SegmentStrictlyBananaSegment(ch1[i],ch1[i-1],ch2[j],ch2[j-1])){\n                        ok=false;\n                        break;\n                    }\n                }\n            }\n            rep(i,0,n){\n                if(!ok) break;\n                if(PointInConvex(black[i],ch2,num_ch2)) ok=false;\n            }\n            rep(i,0,m){\n                if(!ok) break;\n                if(PointInConvex(white[i],ch1,num_ch1)) ok=false;\n            }\n        }\n        printf(\"%s\\n\",ok?\"YES\":\"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n\ntypedef long long ll;\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nint n[2];\nvector<vector<P>> p;\n\nbool solve(){\n    if(n[0]==1 && n[1]==1)return true;\n    if(n[0]==1){\n        swap(n[0],n[1]);\n        swap(p[0],p[1]);\n    }\n    vector<double> ths;\n\n    rep(i,n[0])rep(j,i){\n        P &p0=p[0][i], &p1=p[0][j];\n        double th=arg(p0-p1);\n        ths.push_back(th);\n    }\n\n    for(double th:ths){\n        auto before = p;\n        rep(i,2)rep(j,n[i]){\n            p[i][j] /= polar(1. ,th);\n        }\n        double M[2]={-INF,-INF}, m[2]={INF,INF};\n        rep(i,2){\n            rep(j,n[i]){\n                M[i] = max(M[i],p[i][j].imag());\n                m[i] = min(m[i],p[i][j].imag());\n            }\n        }\n        if(M[0] < m[1] || M[1] < m[0]) return true;\n        p = before;\n    }\n    return false;\n}\n\nint main(){\n    while(cin>>n[0]>>n[1] && n[0]){\n        // cout <<++c << endl;\n        p={{},{}};\n        rep(i,2){\n            p[i].resize(n[i]);\n            rep(j,n[i]){\n                int x,y;\n                cin>>x>>y;\n                p[i][j] = P(x,y);\n            }\n        }\n\n        puts(solve() ? \"YES\" : \"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n  \nusing namespace std;\n \nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n \nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n \n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n \n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n \nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n \nstruct Circle{\n  Point c;\n  double r;\n  Circle(Point c,double r):c(c),r(r){}\n};\n \ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n \nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n \nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n \nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n \nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n \nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n \nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n \nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n \nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n \nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n      ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n \nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n \ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n \ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n \ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n         min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n \nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n \n \npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n \n \ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n \nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n \npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n \nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n \nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n \ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n \n \nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n \nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n \nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  pair<Point,Point> p=getCrossPoints(c1,c2);\n  if(cross(p2-p1,p.first-p1)>0) swap(p.first,p.second);\n  return Line(p.first,p.second);\n}\n \nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    bool f=1;\n    Polygon b(n),w(m);\n    for(int i=0;i<n;i++) cin>>b[i].x>>b[i].y;\n    for(int i=0;i<m;i++) cin>>w[i].x>>w[i].y;\n    b=andrewScan(b);\n    w=andrewScan(w);\n    n=b.size();m=w.size();\n    if(n<m){\n      swap(n,m);\n      swap(b,w);\n    }\n    if(n==2){\n      if(m==1){\n    f=cross(b[1]-b[0],w[0]-b[0])!=0;\n      }else{\n    f=!intersect(b[0],b[1],w[0],w[1]);\n      }\n    }\n    if(n>2){\n      for(int i=0;i<m;i++)\n    f&=!contains(b,w[i]);\n      if(m>2)\n    for(int i=0;i<n;i++)\n      f&=!contains(w,b[i]);\n    }\n    cout<<(f?\"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n\nstruct Point{\n  double x,y;\n\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n  Point operator / (const double &k)const{ return Point(x/k,y/k); }\n  bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\n\nistream &operator >> (istream &is,Point &p){ \n  return is >> p.x >> p.y;\n}\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS){ return COUNTER_CLOCKWISE; }\n  if(cross(a,b) < -EPS){ return CLOCKWISE; }\n  if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n  if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n  return ON_SEGMENT;\n}\n\nstruct Segment{\n  Point s,t;\n  Segment(){}\n  Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nbool isIntersectSP(const Segment &s,const Point &p){\n  return equal(ccw(s.s,s.t,p),0);\n}\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n  Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n  return (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n          ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0);\n}\n\n#define prev(G,i) (G[(i-1+G.size())%G.size()])\n#define curr(G,i) (G[i%G.size()])\n#define next(G,i) (G[(i+1)%G.size()])\ntypedef vector<Point> Polygon;\n\nbool check(const Polygon &pg,const Point &p){\n  int N = pg.size();\n  bool in = false;\n  for(int i = 0 ; i < N ; i++){\n    Point a = curr(pg,i)-p, b = next(pg,i)-p;\n    if(a.y > b.y){ swap(a,b); }\n    if(a.y <= 0 && 0 < b.y && cross(a,b) > 0){ in = !in; }\n    if(cross(a,b) == 0 && dot(a,b) <= 0){ return true; }\n  }\n  return in;\n}\n\nbool solve(Polygon &bp,Polygon &wp){\n  int N = bp.size(), M = wp.size();\n  if(N == 1 && M == 1){\n    return !(equal(bp[0].x,wp[0].x) && equal(bp[0].y,wp[0].y));\n  }\n  if(N == 2 && M == 1){\n    Segment s(bp[0],bp[1]);\n    return !isIntersectSP(s,wp[0]);\n  }\n  if(N == 1 && M == 2){\n    Segment s(wp[0],wp[1]);\n    return !isIntersectSP(s,bp[0]);\n  }\n  if(N == 2 && M == 2){\n    Segment s1(bp[0],bp[1]),s2(wp[0],wp[1]);\n    return !isIntersectSS(s1,s2);\n  }\n  if(N == 1 && M >= 3){\n    return !check(wp,bp[0]);\n  }\n  if(N >= 3 && M == 1){\n    return !check(bp,wp[0]);\n  }\n  if(N == 2 && M >= 3){\n    Segment s1(bp[0],bp[1]);\n    if(check(wp,bp[0]) || check(wp,bp[1])){\n      return false;\n    }\n    for(int i = 0 ; i < M ; i++){\n      for(int j = i+1 ; j < M ; j++){\n        Segment s2(wp[i],wp[j]);\n        if(isIntersectSS(s1,s2)){\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  if(N >= 3 && M == 2){\n    Segment s1(wp[0],wp[1]);\n    if(check(bp,wp[0]) || check(bp,wp[1])){\n      return false;\n    }\n    for(int i = 0 ; i < N ; i++){\n      for(int j = i+1 ; j < N ; j++){\n        Segment s2(bp[i],bp[j]);\n        if(isIntersectSS(s1,s2)){\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  for(int i = 0 ; i < N ; i++){\n    if(check(wp,bp[i])){\n      return false;\n    }\n  }\n  for(int i = 0 ; i < M ; i++){\n    if(check(bp,wp[i])){\n      return false;\n    }\n  }\n  for(int i = 0 ; i < N ; i++){\n    for(int j = i+1 ; j < N ; j++){\n      for(int k = 0 ; k < M ; k++){\n        for(int l = k+1 ; l < M ; l++){\n          Segment s1(bp[i],bp[j]),s2(wp[k],wp[l]);\n          if(isIntersectSS(s1,s2)){\n            return false;\n          }\n        }\n      }\n    }\n  }\n  return true;\n}\n\nint main(){\n  int N,M;\n  while(cin >> N >> M, (N | M)){\n    Polygon bp(N),wp(M);\n    for(int i = 0 ; i < N ; i++){\n      cin >> bp[i];\n    }\n    for(int i = 0 ; i < M ; i++){\n      cin >> wp[i];\n    }\n    cout << (solve(bp,wp) ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst double eps=1e-8;\nconst int  maxn=205;\nint dcmp(double d){\n    if(fabs(d)<eps)return 0;\n    return d>0?1:-1;\n}\nstruct pnt{\n    double x,y;\n    pnt():x(0),y(0){}\n    pnt(double tx,double ty):x(tx),y(ty){}\n    pnt operator -(pnt p2){\n        pnt newp(x-p2.x,y-p2.y);\n        return newp;\n    }\n    pnt operator +(pnt p2){\n        pnt newp(x+p2.x,y+p2.y);\n        return newp;\n    }\n    pnt operator *(double  d){\n        pnt newp(x*d,y*d);\n        return newp;\n    }\n    pnt operator /(double  d){\n        pnt newp(x/d,y/d);\n        return newp;\n    }\n    double dis(pnt p2){\n        return sqrt((x-p2.x)*(x-p2.x)+(y-p2.y)*(y-p2.y));\n    }\n    bool operator ==(pnt p2){\n        if(dcmp(x-p2.x)==0&&dcmp(y-p2.y)==0)return true;\n        return false;\n    }\n};\ndouble cross(pnt p1,pnt p2){\n    return p1.x*p2.y-p1.y*p2.x;\n}\nbool cmpx(pnt p1,pnt p2){\n    if(p1.x!=p2.x)return p1.x<p2.x;\n    return p1.y<p2.y;\n}\npnt base;\nbool cmp(pnt p1,pnt p2){\n    return cross(p1-  base,p2-base)<0;\n}\n\nint isPointInConvexPolygon(pnt p1,pnt * p,int n){\n    for(int i=0;i<n;i++){\n        pnt A=pnt(p[(i+1)%n].x-p[i].x,p[(i+1)%n].y-p[i].y);\n        pnt B=pnt(p1.x-p[i].x,p1.y-p[i].y);\n        int fl=dcmp(cross(A,B));\n        if(fl<0)return 0;\n        if(fl==0){\n            int maxx=max(p[(i+1)%n].x,p[i].x);\n            int minx=min(p[(i+1)%n].x,p[i].x);\n            int maxy=max(p[(i+1)%n].y,p[i].y);\n            int miny=min(p[(i+1)%n].y,p[i].y);\n            if(minx<=p1.x&&maxx>=p1.x&&miny<=p1.y&&maxy>=p1.y)return -1;//on the edge\n            else return 0;\n        }\n    }\n    return 1;\n}\nint graham(pnt * p,pnt * h,int n){\n\n        int m=0;\n        for(int i=0;i<n;i++){//隶。邂嶺ク雁?蛹?                while(m>1&&cross((h[m-1]-h[m-2]),(p[i]-h[m-2]))<=0){m--;}\n                h[m++]=p[i];\n        }\n        int tm=m;\n        for(int i=n-2;i>=0;i--){//隶。邂嶺ク句?蛹?                while(m>tm&&cross((h[m-1]-h[m-2]),(p[i]-h[m-2]))<=0){m--;}\n                h[m++]=p[i];\n        }\n        if(n>1)m--;\n        return m;\n}\n\nbool between(pnt p1,pnt p2,pnt p){\n        return (p.x<=max(p1.x,p2.x)&&p.x>=min(p1.x,p2.x))\n        &&  (p.y<=max(p1.y,p2.y)&&p.y>=min(p1.y,p2.y));\n}\nbool isInsert(pnt p11,pnt p12,pnt p21,pnt p22){\n        pnt v=p22-p21;\n        pnt w=p12-p11;\n        pnt u=p21-p11;\n        if(cross(v,w)==0){\n                if(cross(v,u)!=0)return false;\n                if(between(p11,p12,p21))return true;\n                if(between(p11,p12,p22))return true;\n                return false;\n        }\n        double t=cross(w,u)/cross(v,w);\n        double t2=cross(v,u)/cross(v,w);\n        if(t2>1||t2<0)return false;\n        if(t>1||t<0)return false;\n        return true;\n}\n\npnt bp[maxn],bh[maxn],wp[maxn],wh[maxn];\nint bn,wn,btop,wtop;\n\nint main(){\n        while(scanf(\"%d%d\",&bn,&wn)==2&&(bn||wn)){\n                for(int i=0;i<bn;i++){\n                        scanf(\"%lf%lf\",&bp[i].x,&bp[i].y);\n                }\n                for(int i=0;i<wn;i++){\n                        scanf(\"%lf%lf\",&wp[i].x,&wp[i].y);\n                }\n                sort(bp,bp+bn,cmpx);\n                base =bp[0];\n                sort(bp+1,bp+bn,cmp);\n                sort(wp,wp+wn,cmpx);\n                base =wp[0];\n                sort(wp+1,wp+wn,cmp);\n                btop=graham(bp,bh,bn);\n                wtop=graham(wp,wh,wn);\n\n                bool fl=true;\n                for(int i=0;i<wn;i++){\n                        if(isPointInConvexPolygon(wp[i],bh,btop)){\n                                fl=false;\n                                break;\n                        }\n                }\n\n                if(fl){\n                        for(int i=0;i<bn;i++){\n                                if(isPointInConvexPolygon(bp[i],wh,wtop)){\n                                        fl=false;\n                                        break;\n                                }\n                        }\n                }\n\n                if(fl&&btop>1&&wtop>1){\n                        for(int i=0;i<btop;i++){\n                                for(int j=0;j<wtop;j++){\n                                        if(isInsert(bh[i],bh[(i+1)%btop],wh[j],wh[(j+1)%wtop])){\n                                                fl=false;\n                                                break;\n                                        }\n                                }\n                        }\n                }\n                if(wn==1&&bn==1&&bp[0]==wp[0]){fl=false;}\n\n\n                if(fl)puts(\"YES\");\n                else puts(\"NO\");\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <vector>\n#include <string>\n#include <stack>\n#include <bitset>\n#define INF 1000000005\n#define eps 1e-7\n#define PI acos(-1.0)\n#define LL long long\n\nusing namespace std;\n\nconst int maxn=105;\n\nint bx[maxn],by[maxn],hx[maxn],hy[maxn],m,n,tag;\n\nint maxhx,maxbx,minhx,minbx,maxhy,maxby,minhy,minby;\n\nvoid Solve(int sx,int sy,int ex,int ey)\n{\n    int A=ey-sy,B=sx-ex,C=ex*sy-sx*ey;\n    int bl=0,br=0,bm=0,hl=0,hr=0,hm=0;\n    for (int i=1;i<=n;i++)\n    {\n        long long D=A*1LL*bx[i]+B*1LL*by[i]+C*1LL;\n        if (D<0) bl++;\n        if (D==0) bm++;\n        if (D>0) br++;\n    }\n    for (int i=1;i<=m;i++)\n    {\n        long long D=A*1LL*hx[i]+B*1LL*hy[i]+C*1LL;\n        if (D<0) hl++;\n        if (D==0) hm++;\n        if (D>0) hr++;\n    }\n    if (bm!=0&&hm!=0) return;\n    if (bl==0&&hr==0) tag=1;\n    if (br==0&&hl==0) tag=1;\n    return;\n}\n\nint main()\n{\n    while(scanf(\"%d %d\",&n,&m)==2)\n    {\n        if (n==0&&m==0) break;\n        tag=0;\n        minhx=minhy=minbx=minby=INF;\n        maxhx=maxhy=maxbx=maxby=-INF;\n        for (int i=1;i<=n;i++)\n            {\n                scanf(\"%d %d\",&bx[i],&by[i]);\n                minby=min(minby,by[i]);\n                maxby=max(maxby,by[i]);\n                minbx=min(minbx,bx[i]);\n                maxbx=max(maxbx,bx[i]);\n            }\n        for (int i=1;i<=m;i++)\n            {\n                scanf(\"%d %d\",&hx[i],&hy[i]);\n                minhy=min(minhy,hy[i]);\n                maxhy=max(maxhy,hy[i]);\n                minhx=min(minhx,hx[i]);\n                maxhx=max(maxhx,hx[i]);\n            }\n        if (maxhx<minbx||maxbx<minhx||maxhy<minby||maxby<minhy) tag=1;\n        printf(\"%d %d\\n\",maxhx,minbx);\n        if (n<=1&&m<=1) tag=1;\n        else if (!tag)\n        {\n            if (n>=2)\n            {\n                for (int i=1;i<n;i++)\n                {\n                    for (int j=i+1;j<=n;j++)\n                    {\n                        Solve(bx[i],by[i],bx[j],by[j]);\n                        if (tag) break;\n                    }\n                    if (tag) break;\n                }\n            }\n            if (m>=2)\n            {\n                for (int i=1;i<m;i++)\n                {\n                    for (int j=i+1;j<=m;j++)\n                    {\n                        Solve(hx[i],hy[i],hx[j],hy[j]);\n                        if (tag) break;\n                    }\n                    if (tag) break;\n                }\n            }\n        }\n        if (tag) printf(\"YES\\n\"); else printf(\"NO\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Hello. I'm Peter.\n//#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<functional>\n#include<cctype>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uin;\n#define peter cout<<\"i am peter\"<<endl\n#define input freopen(\"data.txt\",\"r\",stdin)\n#define randin srand((unsigned int)time(NULL))\n#define INT (0x3f3f3f3f)*2\n#define LL (0x3f3f3f3f3f3f3f3f)*2\n#define MAXN\n#define N 510\n#define M\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nconst double eps=1e-9;\ninline int dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    else if(x<0) return -1;\n    else return 1;\n}\nint n,m;\nstruct Point{\n    double x,y;\n    Point(){};\n    Point(double xx,double yy){\n        x=xx,y=yy;\n    }\n};\ninline bool comp(const Point a,const Point b){\n    if(dcmp(a.x-b.x)) return a.x<b.x;\n    else return a.y<b.y;\n}\ntypedef Point Vector;\nVector operator+(const Vector a,const Vector b){\n    return Vector(a.x+b.x,a.y+b.y);\n}\nVector operator-(const Vector a,const Vector b){\n    return Vector(a.x-b.x,a.y-b.y);\n}\ndouble operator*(const Vector a,const Vector b){\n    return a.x*b.x+a.y*b.y;\n}\ndouble operator%(const Vector a,const Vector b){\n    return a.x*b.y-a.y*b.x;\n}\nVector operator*(const Vector a,const double b){\n    return Vector(a.x*b,a.y*b);\n}\nVector operator*(const double b,const Vector a){\n    return Vector(a.x*b,a.y*b);\n}\nbool operator ==(const Vector a,const Vector b){\n    return !dcmp(a.x-b.x)&&!dcmp(a.y-b.y);\n}\nVector operator/(const Vector a,const double b){\n    return Vector(a.x/b,a.y/b);\n}\ndouble Square_Triangle(Point p1,Point p2,Point p3){\n    //????§???¢??¢?§????????????????\n    return 0.5*fabs((p2-p1)%(p3-p1));\n}\n#define lenp res.size()\nvoid Convex_Hull(Point *p,int n,vector<Point>&res){\n    res.clear();\n    sort(p,p+n,comp);\n    for(int i=0;i<n;i++){\n        while(lenp>1&&dcmp((res[lenp-1]-res[lenp-2])%(p[i]-res[lenp-1]))<=0) res.pop_back();\n        res.push_back(p[i]);\n    }\n    int k=(int)lenp;\n    for(int i=n-2;i>=0;i--){\n        while(lenp>k&&dcmp((res[lenp-1]-res[lenp-2])%(p[i]-res[lenp-1]))<=0) res.pop_back();\n        res.push_back(p[i]);\n    }\n    if(lenp>1) res.pop_back();\n}\nvoid readPointInt(Point &p){\n    int x,y;\n    x=read(),y=read();\n    p=Point(x,y);\n}\nPoint p1[N],p2[N];\n#define lenv1 v1.size()\n#define lenv2 v2.size()\n#define lenv v.size()\ndouble Square_ConvexHull(vector<Point>&v){//?????????????????¢?§?\n    //lenv>=3\n    double res=0.0;\n    for(int i=1;i<lenv-1;i++){\n        res+=Square_Triangle(v[0],v[i],v[i+1]);\n    }\n    return res;\n}\ndouble Square_PointWithConvexHull(Point p,vector<Point>&v){\n    //?±???????????????????????????¢????????¢?§?\n    v.push_back(v[0]);\n    double res=0.0;\n    for(int i=0;i<lenv-1;i++){\n        res+=Square_Triangle(p,v[i],v[i+1]);\n    }\n    v.pop_back();\n    return res;\n}\nbool PointOnSegment(Point p,Point p1,Point p2){\n    Vector v1=p1-p,v2=p2-p;\n    if(dcmp(v1%v2)) return false;\n    else if(dcmp(v1*v2)>0) return false;\n    else return true;\n}\nbool PointInConvexHull1_In_ConvexHull2(vector<Point>&v1,vector<Point>&v2){\n    if(lenv1==1&&lenv2==1) return v1[0]==v2[0];\n    if(lenv1==1&&lenv2==2) return PointOnSegment(v1[0],v2[0],v2[1]);\n    if(lenv2>=3){\n        double Sv2=Square_ConvexHull(v2);\n        for(int i=0;i<lenv1;i++){\n            double St=Square_PointWithConvexHull(v1[i],v2);\n            if(!dcmp(St-Sv2)) return true;\n        }\n    }\n    return false;\n}\nbool Segment1_Inter_Segment2(Point p1,Point p2,Point q1,Point q2){\n    if(!dcmp((p1-p2)%(q1-q2))){\n        return PointOnSegment(p1,q1,q2)||PointOnSegment(p2,q1,q2)||PointOnSegment(q1,p1,p2)||PointOnSegment(q2,p1,p2);\n    }\n    else{\n        int t1=dcmp((p2-p1)%(q1-p1));\n        int t2=dcmp((p2-p1)%(q2-p1));\n        int t3=dcmp((q2-q1)%(p1-q1));\n        int t4=dcmp((q2-q1)%(p2-q1));\n        return t1*t2<=0&&t3*t4<=0;\n    }\n}\nbool ConvexHull1_Inter_ConvexHull2(vector<Point>&v1,vector<Point>&v2){\n    //?????????????????¨??????????????????\n    if(PointInConvexHull1_In_ConvexHull2(v1,v2)) return true;\n    if(PointInConvexHull1_In_ConvexHull2(v2,v1)) return true;\n    //???????????????????????????\n    if(lenv1>=2&&lenv2>=2){\n        v1.push_back(v1[0]);\n        v2.push_back(v2[0]);\n        for(int i=0;i<lenv1-1;i++){\n            for(int j=0;j<lenv2-1;j++){\n                if(Segment1_Inter_Segment2(v1[i],v1[i+1],v2[j],v2[j+1])){\n                    v1.pop_back();\n                    v2.pop_back();\n                    return true;\n                }\n            }\n        }\n        v1.pop_back();\n        v2.pop_back();\n    }\n    return false;\n}\nint main(){\n    while(1){\n        n=read(),m=read();\n        if(!n&&!m) break;\n        for(int i=0;i<n;i++){\n            readPointInt(p1[i]);\n        }\n        vector<Point>res1;\n        Convex_Hull(p1,n,res1);\n        for(int i=0;i<m;i++){\n            readPointInt(p2[i]);\n        }\n        vector<Point>res2;\n        Convex_Hull(p2,m,res2);\n        if(ConvexHull1_Inter_ConvexHull2(res1,res2)){\n            printf(\"NO\\n\");\n        }\n        else printf(\"YES\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tvector<Polygon>polys;\n\tpolys.push_back(Q);\n\tpolys.push_back(R);\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\n#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\n\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<Point>wps, bps;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tPoint wp(input_point());\n\t\t\twps.push_back(wp);\n\t\t}\n\t\tfor (int i = 0; i <M; ++i) {\n\t\t\tPoint bp(input_point());\n\t\t\tbps.push_back(bp);\n\t\t}\n\n\t\tPolygon bpoly(convex_hull(bps));\n\t\tPolygon wpoly(convex_hull(wps));\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tLine wl(wps[i], wps[j]);\n\t\t\t\tfor (int k = 0; k < M; ++k) {\n\t\t\t\t\tif (isis_sp(wl, bps[k])) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tgoto a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tfor (int j = i + 1; j < M; ++j) {\n\t\t\t\tLine bl(bps[i], bps[j]);\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tif (isis_sp(bl, wps[k])) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tgoto a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (is_in_polygon(bpoly, wps[i])) {\n\t\t\t\tok = false;\n\t\t\t\tgoto a;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (is_in_polygon(wpoly, bps[i])) {\n\t\t\t\tok = false;\n\t\t\t\tgoto a;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < wpoly.size(); ++i) {\n\t\t\tLine wl(wpoly[i], wpoly[(i + 1)% wpoly.size()]);\n\t\t\tfor (int j = 0; j < bpoly.size(); ++j) {\n\t\t\t\tLine bl(bpoly[j], bpoly[(j + 1) % bpoly.size()]);\n\t\t\t\tif (isis_ss(wl, bl))ok = false;\n\t\t\t}\n\t\t}\n\ta:0;\n\t\tif (ok)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Hello. I'm Peter.\n#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<functional>\n#include<cctype>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define peter cout<<\"i am peter\"<<endl\n#define input freopen(\"data.txt\",\"r\",stdin)\n#define randin srand((unsigned int)time(NULL))\n#define INT (0x3f3f3f3f)*2\n#define LL (0x3f3f3f3f3f3f3f3f)*2\n#define gsize(a) (int)a.size()\n#define len(a) (int)strlen(a)\n#define slen(s) (int)s.length()\n#define pb(a) push_back(a)\n#define clr(a) memset(a,0,sizeof(a))\n#define clr_minus1(a) memset(a,-1,sizeof(a))\n#define clr_INT(a) memset(a,INT,sizeof(a))\n#define clr_true(a) memset(a,true,sizeof(a))\n#define clr_false(a) memset(a,false,sizeof(a))\n#define clr_queue(q) while(!q.empty()) q.pop()\n#define clr_stack(s) while(!s.empty()) s.pop()\n#define rep(i, a, b) for (int i = a; i < b; i++)\n#define dep(i, a, b) for (int i = a; i > b; i--)\n#define repin(i, a, b) for (int i = a; i <= b; i++)\n#define depin(i, a, b) for (int i = a; i >= b; i--)\n#define pi acos(-1.0)\n#define eps 1e-10\n#define MOD 1000000007\n#define MAXN\n#define N 200\n#define M\nint dcmp(double x){//蛻、譁ュx豁」雍滓?荳コ0\n    if(fabs(x)<eps) return 0;\n    else if(x<0) return -1;\n    else return 1;\n}\nstruct Point{\n    double x,y;\n    Point(){};\n    Point(double xx,double yy):x(xx),y(yy){};\n    friend bool operator<(const Point A,const Point B){\n        return A.x < B.x || (A.x == B.x && A.y < B.y);\n    }\n};\ntypedef Point Vector;\nvoid readPoint(Point &a){//霎灘?荳?クェ轤ケ\n    scanf(\"%lf %lf\",&a.x,&a.y);\n}\ndouble sq(double x){//x^2\n    return x*x;\n}\nVector operator +(const Vector a,const Vector b){//荳、蜷鷹?逶ク蜉?    return Vector(a.x+b.x,a.y+b.y);\n}\nVector operator -(const Vector a,const Vector b){//荳、蜷鷹?逶ク蜃?    return Vector(a.x-b.x,a.y-b.y);\n}\nbool operator ==(const Vector a,const Vector b){//蛻、譁ュ荳、轤ケ謌紋ク、蜷鷹?譏ッ蜷ヲ荳??\n    return dcmp(a.x-b.x)==0 && dcmp(a.y-b.y)==0;\n}\ndouble operator *(const Vector a,const Vector b){//荳、蜷鷹?轤ケ荵?    return a.x*b.x+a.y*b.y;\n}\ndouble operator &(const Vector a,const Vector b){//荳、蜷鷹?蜿臥ァッ\n    return a.x*b.y-a.y*b.x;\n}\nVector operator *(const Vector b,const double a){//荳?クェ謨ー*荳?クェ蜷鷹?\n    return Vector(a*b.x,a*b.y);\n}\nVector operator *(const double a,const Vector b){//荳?クェ蜷鷹?*荳?クェ謨ー\n    return Vector(a*b.x,a*b.y);\n}\nPoint MiddlePoint(Point a,Point b){//豎ゆク、轤ケ逧?クュ轤ケ\n    return Point((a.x+b.x)/2,(a.y+b.y)/2);\n}\ndouble Length(Vector b){//豎ゆク?クェ蜷鷹?逧?柄蠎ヲ\n    return sqrt(b*b);\n}\ndouble DistancePointToPoint(Point a,Point b){//豎らせ蛻ー轤ケ逧?裏蜷題キ晉ヲサ\n    return Length(a-b);\n}\ndouble DistancePointToLine(Point p,Point a,Vector v){//豎らせ蛻ー郤ソ逧?裏蜷題キ晉ヲサ\n    Vector w=p-a;\n    return fabs((v&w)/Length(v));\n}\nPoint Point_LineBananaLine(Point p1,Vector v,Point p2,Vector w){//豎ゆク、郤ソ逧?コ、轤ケ(蜑肴署譏ッ荳、蜷鷹?荳榊?郤ソ)\n    Vector u=p1-p2;\n    double t=(w&u)/(v&w);\n    return p1+v*t;\n}\ndouble polarAngle(Vector a,Vector b){//豎ゆク、荳ェ蜷鷹?逧?裏蜷第栫隗?0<=x<=pi)\n    double t=(a*b)/Length(a)/Length(b);\n    return acos(t);\n    //閠径tan2(double y,double x)豎ら噪譏ッ荳?クェ蜷鷹?荳支霓エ逧?怏蜷第栫隗?-pi<x<=pi)\n}\nint ConvexHull(Point *p,int n,Point *ch){\n    sort(p,p+n);\n    int m=0;\n    rep(i,0,n){\n        while(m>1 && dcmp((ch[m-1]-ch[m-2])&(p[i]-ch[m-2]))<=0) m--;\n        ch[m++]=p[i];\n    }\n    int k=m;\n    depin(i,n-2,0){\n        while(m>k && dcmp((ch[m-1]-ch[m-2])&(p[i]-ch[m-2]))<=0) m--;\n        ch[m++]=p[i];\n    }\n    ch[m++] = ch[0];\n    if(n>1) m--;\n    return m;\n}\nbool SegmentStrictlyBananaSegment(Point p1,Point p2,Point w1,Point w2){//蛻、譁ュ荳、郤ソ谿オ譏ッ蜷ヲ荳・譬シ鬥呵負(荳榊桁諡ャ遶ッ轤ケ)\n    double x1=(w2-w1)&(p1-w1);\n    double x2=(w2-w1)&(p2-w1);\n    double x3=(p2-p1)&(w1-p1);\n    double x4=(p2-p1)&(w2-p1);\n    return dcmp(x1)*dcmp(x2)<0 && dcmp(x3)*dcmp(x4)<0;\n}\nbool PointInConvex(Point a, Point* ch, int n){\n    int i;\n    if(n==3){\n        if(a.x < min(ch[0].x, ch[1].x) || a.x > max(ch[0].x, ch[1].x)) return false;\n        if(a.y < min(ch[0].y, ch[1].y) || a.y > max(ch[0].y, ch[1].y)) return false;\n    }\n    for(i=1;i<n;i++){\n        if( ((ch[i]-ch[i-1])&(a-ch[i-1])) < 0) return false;\n    }\n    return true;\n}\nint n,m,num_ch1,num_ch2;\nPoint black[N],ch1[N],white[N],ch2[N];\nint main(){\n//    input;\n    while(~scanf(\"%d%d\",&n,&m) && (n+m)){\n        clr(black);\n        clr(white);\n        clr(ch1);\n        clr(ch2);\n        rep(i,0,n){\n            readPoint(black[i]);\n        }\n        num_ch1=ConvexHull(black,n,ch1);\n        rep(i,0,m){\n            readPoint(white[i]);\n        }\n        num_ch2=ConvexHull(white,m,ch2);\n        bool ok=true;\n        if(n==1 && m==1) ok=true;\n        else if(n==1){\n            if(PointInConvex(black[0],ch2,num_ch2)) ok=false;\n            else ok=true;\n        }\n        else if(m==1){\n            if(PointInConvex(white[0],ch1,num_ch1)) ok=false;\n            else ok=true;\n        }\n        //n!=1 && m!=1\n        else{\n            rep(i,1,num_ch1){\n                if(!ok) break;\n                rep(j,1,num_ch2){\n                    if(SegmentStrictlyBananaSegment(ch1[i],ch1[i-1],ch2[j],ch2[j-1])){\n                        ok=false;\n                        break;\n                    }\n                }\n            }\n            rep(i,0,n){\n                if(!ok) break;\n                if(PointInConvex(black[i],ch2,num_ch2)) ok=false;\n            }\n            rep(i,0,m){\n                if(!ok) break;\n                if(PointInConvex(white[i],ch1,num_ch1)) ok=false;\n            }\n        }\n        printf(\"%s\\n\",ok?\"YES\":\"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n};\n\nbool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n\n  if(cross(a1-a2,b1-b2)==0){\n    return is_point_on_line(a1,a2,b1) || is_point_on_line(a1,a2,b2) \n        || is_point_on_line(b1,b2,a1) || is_point_on_line(b1,b2,a2);\n  }\n  else {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n           ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n  }\n}\n\nint contain(point p, vector<point> ps){\n  point a(p.x,p.y),b(1000000,p.y);\n\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<ps.size();i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(a.y<=ymn||a.y>=ymx)return 0;\n\n  int cnt1=0;\n  for(int i=0;i<ps.size();i++)\n    if(is_point_on_line(a,b,ps[i]))cnt1++;\n  \n  int cnt=0;\n  for(int i=0;i<ps.size();i++)\n    if(is_intersected_ls(ps[i],ps[(i+1)%ps.size()],a,b))cnt++;\n\n  return (cnt-cnt1)%2;\n}\n\nint crossPol(vector<point> pol1, vector<point> pol2){\n  int szpol1=pol1.size();\n  int szpol2=pol2.size();\n  \n  for(int i=0;i<szpol1;i++)\n    if(contain(pol1[i],pol2))return 1;\n  \n  for(int i=0;i<szpol2;i++)\n    if(contain(pol2[i],pol1))return 1;\n\n  pol1.push_back(pol1[0]);\n  pol2.push_back(pol2[0]);\n  \n  for(int i=0;i<szpol1;i++)\n    for(int j=0;j<szpol2;j++)\n      if(is_intersected_ls(pol1[i],pol1[i+1],pol2[j],pol2[j+1]))return 1;\n  \n  return 0;\n}\n\nvector<point>convex_hull(point* ps, int n){\n  sort(ps,ps+n,cmp_x);\n  int k=0;\n  vector<point>qs(n*2);\n \n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0)k--;\n    qs[k++]=ps[i];\n  }\n \n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0)k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nint main(void){\n  int n,m;\n  point black[100],white[100];\n\n  while(cin >> n >> m,n|m){\n\n    for(int i=0;i<n;i++)\n      cin >> black[i].x >> black[i].y;\n    \n    for(int i=0;i<m;i++)\n      cin >> white[i].x >> white[i].y;\n\n    if(n<2||m<2){\n      if(n<2 && m<2)cout << \"YES\" << endl;\n      else {\n\tbool fg=false;\n\tfor(int i=0;i<n;i++){\n\t  for(int j=0;j<m;j++){\n\t    if(is_intersected_ls(black[i],black[(i+1)%n],white[j],white[(j+1)%n]))fg=true;\n\t  }\n\t}\n\tif(fg)cout <<\"NO\"<<endl;\n\telse cout << \"YES\" << endl;\n      }\n      continue;\n    }\n\n    vector<point>Black,White;\n\n    Black=convex_hull(black,n);\n    White=convex_hull(white,m);\n    \n    if(crossPol(Black,White))cout << \"NO\" << endl;\n    else cout << \"YES\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a; i<(int)b; i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef complex<double> P;\n\nnamespace std {\n  bool operator < (P const& a, P const& b) {\n    if(real(a) != real(b)) return real(a) < real(b);\n    return imag(a) < imag(b);\n  }\n}\n\ndouble const EPS = 1e-8;\n\n#define prev(G, i) ( G[((i-1)+G.size())%G.size()] )\n#define curr(G, i) ( G[i%G.size()] )\n#define next(G, i) ( G[(i+1)%G.size()] )\n\ndouble dot(P const& a, P const& b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(P const& a, P const& b) {\n  return imag(conj(a)*b);\n}\n\ntypedef vector<P> Polygon;\n\nPolygon convex_hull(vector<P> ps) {\n  sort(ps.begin(), ps.end());\n  int N = ps.size(), k = 0;\n  vector<P> qs(N*2);\n  rep(i, N) {\n    while(k > 1 && cross(qs[k-1]-qs[k-2], ps[i]-ps[k-1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  for(int i=N-2, t=k; i>=0; i--) {\n    while(k > t && cross(qs[k-1]-qs[k-2], ps[i]-qs[k-1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nenum { counter_clock_wise=+1, clockwise=-1, cab_online=+2, abc_online=-2, on_segment = 0 };\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if(cross(b, c) > 0) return counter_clock_wise;\n  if(cross(b, c) < 0) return clockwise;\n  if(dot(b, c) < 0) return cab_online;\n  if(norm(b) < norm(c)) return abc_online;\n  return on_segment;\n}\n\nstruct Line : public vector<P>\n{\n  Line(P const& a, P const& b) {\n    push_back(a), push_back(b);\n  }\n};\n\ntypedef Line Segment;\n\nbool is_intersect_ss(Segment const& s, Segment const& t) {\n  return ( ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 )\n    && ( ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0 );\n}\n\n// contain: 2, on segment: 1, the other case: 0\nint contains(Polygon const& G, P const& p) {\n  bool x = false;\n  for(int i=0; i<(int)G.size(); i++) {\n    P v1 = curr(G, i)-p, v2 = next(G, i) - p;\n    if( v1.imag() > v2.imag() ) swap(v1, v2);\n    if( v1.imag() <= 0 && 0 < v2.imag() && cross(v1, v2) > 0 ) x = !x;\n    if( cross(v1, v2) == 0 && dot(v1, v2) <= 0 ) return 1;\n  }\n  return (x?2:0);\n}\n\nint main() {\n\n  int N, M;\n  while(cin >> N >> M && (N|M)) {\n    Polygon G1(N), G2(M);\n    rep(i, N) cin >> G1[i].real() >> G1[i].imag(); \n    rep(i, M) cin >> G2[i].real() >> G2[i].imag(); \n    \n    G1 = convex_hull(G1); N = G1.size();\n    G2 = convex_hull(G2); M = G2.size();\n    //    cout << \"convex hull\\n\";\n    bool ok = (!contains(G1, G2[0])) && (!contains(G2, G1[0]));\n    rep(i, N) {\n      rep(j, M) {\n\tSegment s1 = Segment(curr(G1, i), next(G1, i));\n\tSegment s2 = Segment(curr(G2, j), next(G2, j));\n\tif(is_intersect_ss(s1, s2)) { ok = 0; }\n      }\n    }\n    \n    cout << (ok ? \"YES\\n\" : \"NO\\n\");\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint sign(double r){ return (r < -EPS) ? -1 : (r > EPS) ? 1 : 0; }\nbool eq(double a, double b){ return abs(b - a) < EPS; }\n\nstruct Point{\n  double x, y;\n  Point() {}\n  Point(double x, double y) : x(x), y(y) {}\n  Point operator+(const Point& b) const { return Point(x + b.x, y + b.y); }\n  Point operator-(const Point& b) const { return Point(x - b.x, y - b.y); }\n  Point operator*(const double b) const { return Point(x * b, y * b); }\n  Point operator*(const Point& b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n  Point operator/(const double b) const { return Point(x / b, y / b); }\n  bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y; }\n  bool operator==(const Point& b) const { return eq(x, b.x) && eq(y, b.y); }\n  double norm(){ return x * x + y * y; }\n  double arg(){ return atan2(x, y); }\n  double abs(){ return sqrt(norm()); }\n  Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n  Point rotate90(){ return Point(-y, x); }\n};\n\nostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\nistream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\ndouble dot(const Point& a, const Point& b){ return a.x * b.x + a.y * b.y; }\ndouble cross(const Point& a, const Point& b){ return a.x * b.y - a.y * b.x; }\nPoint polor(double rho, double theta){ return Point(rho * cos(theta), rho * sin(theta)); }\n\nstruct Line : public vector<Point> {\n  Line(const Point& a, const Point& b) {\n    push_back(a); push_back(b);\n  }\n  Point vector() const {\n    return back() - front();\n  }\n};\nstruct Circle : Point {\n  double r;\n  Circle(Point p, double r) : Point(p), r(r) { }\n};\ntypedef vector<Point> Polygon;\nPoint curr(const Polygon& a, int x){ return a[x]; }\nPoint next(const Polygon& a, int x){ return a[(x + 1) % a.size()]; }\nPoint prev(const Polygon& a, int x){ return a[(x - 1 + a.size()) % a.size()]; }\n\n//a->b->c\nint ccw(Point a, Point b, Point c) {\n  b = b - a; c = c - a;\n  if (cross(b, c) > EPS)   return +1; // 反時計回り\n  if (cross(b, c) < -EPS)   return -1; // 時計回り\n  if (dot(b, c) < 0)     return +2; // c--a--b の順番で一直線上\n  if (b.norm() < c.norm()) return -2; // a--b--c の順番で一直線上\n  return 0;                         // a--c--b の順番で一直線上 (aがbまたはcと重なる場合を含む)\n}\n// 二直線の交差判定\nbool intersectLL(const Line& l, const Line& m) {\n  // 直線lと直線mが平行でない\n  return abs(cross(l.vector(), m.vector())) > EPS;\n}\n// 二直線の同一判定\nbool equalLL(const Line& l, const Line& m){\n  // 直線lとl[0]からm[0]への直線が並行\n  return abs(cross(l.vector(), m[0] - l[0])) < EPS;\n}\n// 直線と線分の交差判定(注意: 同一直線上にある場合も含む)\nbool intersectLS(const Line& l, const Line& s) {\n  // 直線lについて、線分sの端点が異なる側にある\n  return cross(l.vector(), s[0] - l[0]) * cross(l.vector(), s[1] - l[0]) < EPS; \n}\n// 直線と点の交差判定\nbool intersectLP(const Line& l, const Point& p) {\n  // 直線lとl[0]からpへの直線が平行\n  return abs(cross(l.vector(), p - l[0])) < EPS;\n}\n// 二つの線分の交差判定\nbool intersectSS(const Line& s, const Line& t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n         ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n// 線分と点の交差判定(端点を含む)\nbool intersectSP(const Line& s, const Point& p) {\n  return ccw(s[0], s[1], p) == 0;\n}\n// 円と点の交差判定(EPS注意)\nbool intersectCP(const Circle& c, const Point& p){\n  // 円の中心と点の距離が、円の半径以下である\n  return (c - p).abs() < c.r + EPS;\n}\n// 二つの円の交差判定(EPS注意)\nbool intersectCC(const Circle& c, const Circle& d){\n  // 円の中心同士の距離が、半径の和以下であり、半径の差以上である\n  return (c - d).abs() < c.r + d.r + EPS && (c - d).abs() > abs(c.r - d.r) - EPS;\n}\n// 射影\nPoint projection(const Line& l, const Point& p){\n  double t = dot(p - l[0], l.vector()) / l.vector().norm();\n  return l[0] + l.vector() * t;\n}\n// 反射\nPoint reflection(const Line& l, const Point& p){\n  return p + (projection(l, p) - p) * 2;\n}\n// 直線と点の距離\ndouble distanceLP(const Line& l, const Point& p){\n  // pからlに下ろした垂線の長さ\n  return (p - projection(l, p)).abs();\n}\n// 二直線の距離\ndouble distanceLL(const Line& l, const Line& m){\n  // 平行でないときは0, 平行のときは垂線の長さ\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n// 直線と線分の距離\ndouble distanceLS(const Line& l, const Line& s){\n  if(intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n// 線分と点の距離\ndouble distanceSP(const Line& s, const Point& p){\n  const Point r = projection(s, p);\n  if(intersectSP(s, r)) return (r - p).abs(); // 垂線が線分に交わるとき\n  return min((s[0] - p).abs(), (s[1] - p).abs());\n}\n// 二つの線分の距離\ndouble distanceSS(const Line& s, const Line& t){\n  if(intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n// 二直線の交点\nPoint crosspointLL(const Line& l, const Line& m){\n  double d = cross(m.vector(), l.vector());\n  if(abs(d) < EPS) assert(false); // 直線が交わらない\n  return l[0] + l.vector() * cross(m.vector(), m[1] - l[0]) * (1.0 / d);\n}\n\n// 点が多角形のどこにあるのか判定する\nenum { OUT, ON, IN };\nint contains(const Polygon& P, const Point& p){\n  // 点pから半直線をひき、辺と交差する回数を数える\n  bool in = false;\n  REP(i, P.size()){\n    Point a = curr(P, i) - p;\n    Point b = next(P, i) - p;\n    if(a.y > b.y) swap(a, b);\n    // aからbの直線がy=0と交わり、その交点は原点の右側である\n    if(a.y <= 0 && 0 < b.y && cross(a, b) < 0){ \n      in = !in;\n    }\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n// 多角形の面積\ndouble area(const Polygon& P) {\n  double A = 0;\n  REP(i, P.size()){\n    A += cross(curr(P, i), next(P, i));\n  }\n  return A / 2.0;\n}\n\n// 凸多角形の直線による切断。直線の左側だけ残す\nPolygon convex_cut(const Polygon& P, const Line& l){\n  Polygon Q;\n  REP(i, P.size()){\n    Point A = curr(P, i), B = next(P, i);\n    if(ccw(l[0], l[1], A) != -1) Q.push_back(A); //Aが直線lの右側でない\n    if(ccw(l[0], l[1], A) * ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspointLL(l, Line(A, B)));\n  }\n  return Q;\n}\nint main(){\n  int N, M;\n  while(cin>>N>>M && N){\n    vector<Point> points(N + M);\n    vector<int> color(N + M, -1);\n    REP(i, N + M) cin>>points[i];\n    REP(i, M) color[N + i] = 1;\n    bool ans = false;\n    REP(i, N + M) REP(j, N + M) if(i != j){\n      // p[i]からp[j]への直線\n      Line l(points[i], points[j]);\n      bool ok = true;\n      REP(k, N + M) if(i != k && j != k) {\n        int c = ccw(l[0], l[1], points[k]);\n        if(abs(c) != 1 || c != color[k]) ok = false;\n        if(!ok) break;\n      }\n      if(ok){\n        ans = true;\n        break;\n      }\n\n      // p[i]とp[j]の中線\n      if(color[i] != -1 || color[j] != 1) continue; // 黒白を分断\n      Line l2((l[0] + l[1]) * 0.5, l.vector().rotate90());\n      ok = true;\n      REP(k, N + M) if(i != k && j != k) {\n        int c = ccw(l2[0], l2[1], points[k]);\n        if(k <  N && c != +1) ok = false;\n        if(k >= N && c != -1) ok = false;\n        if(!ok) break;\n      }\n      if(ok){\n        ans = true;\n        break;\n      }\n    }\n    if(ans) cout << \"YES\" << endl;\n    else    cout << \"NO\"  << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iomanip>\n\n#define REP(i,n) for(i=0; i < (n); i++)\n#define REPONE(i, n) for(i=1; i <= (n); i++)\n#define LOOP(n) for(int loopCount=1; loopCount <= (n); loopCount++)\n#define ITER(c) __typeof((c).begin())\n#define EACH(c,it) for(ITER(c) it =(c).begin(); it!=(c).end(); it++)\n#define SZ(c) ((int) (c).size())\n#define ALL(c) c.begin(), c.end()\n#define SUM(c) accumulate(ALL(c), 0)\n#define EXIST(c,v) (find(ALL(c), (v)) != (c).end())\n#define PB push_back\n#define MP make_pair\n\nusing namespace std;\nstatic const double EPS = 1e-8;\nstatic const double PI = 3.141592653589793238462643383279;\n\n/*\ntypedef complex<double> point;\n\ntemplate<typename T>\nint sig2(T x){\n    if(abs(x)<EPS) return 0;\n    if(x>0) return 1;\n    return -1;\n}\n\ndouble det(point p1, point p2, point q){\n    return p2.real()*q.imag()+p1.real()*p2.imag()+q.real()*p1.imag()\n            -p2.real()*p1.imag()-q.real()*p2.imag()-q.imag()*p1.real();\n}\nint main(){\n    int i,j,k,n,m;\n    double x,y,bxma,byma,bxmi,bymi,wxma,wyma,wxmi,wymi;\n    bool yes;\n    while(scanf(\"%d%d\",&n,&m)){\n        if(n==0 && m==0) break;\n        bxma=byma=wxma=wyma=-1e99;\n        bxmi=bymi=wxmi=wymi=1e99;\n        yes=false;\n        vector<point> bs(n), ws(m);\n        REP(i,n){\n            scanf(\"%lf%lf\",&x,&y);\n            bs[i]=point(x,y);\n            bxma=max(bxma, x);\n            byma=max(byma, y);\n            bxmi=min(bxmi, x);\n            bymi=min(bymi, y);\n        }\n        REP(i,m){\n            scanf(\"%lf%lf\",&x,&y);\n            ws[i]=point(x,y);\n            wxma=max(wxma, x);\n            wyma=max(wyma, y);\n            wxmi=min(wxmi, x);\n            wymi=min(wymi, y);\n        }\n        if(bxma<wxmi||bxmi>wxma||byma<wymi||bymi>wyma){\n            printf(\"YES\\n\");\n            continue;\n        }\n        if(n==1 && m==1){\n            printf(\"YES\\n\");\n            continue;\n        }\n        int w=0, b;\n        REP(i,n)for(j=i+1;j<n;j++){\n            w = 0;\n            REP(k,m) w+=sig2(det(bs[i],bs[j],ws[k]));\n            if(abs(w)<m)break;\n            REP(k,n)if(sig2(det(bs[i],bs[j],bs[k]))==sig2(w))break;\n            if(k==n){\n                yes = true;\n                goto end;\n            }\n        }\n        swap(n,m);\n        swap(bs,ws);\n        REP(i,n)for(j=i+1;j<n;j++){\n            w = 0;\n            REP(k,m) w+=sig2(det(bs[i],bs[j],ws[k]));\n            if(abs(w)<m)break;\n            REP(k,n)if(sig2(det(bs[i],bs[j],bs[k]))==sig2(w))break;\n            if(k==n){\n                yes = true;\n                goto end;\n            }\n        }\n        REP(i,n)REP(j,m){\n            w = b = 0;\n            REP(k,m) w+=sig2(det(bs[i],ws[j],ws[k]));\n            if(abs(w)<m-1)break;\n            REP(k,n) b+=sig2(det(bs[i],ws[j],bs[k]));\n            if(abs(b)<n-1)break;\n            if(w*b<0){\n                yes = true;\n                goto end;\n            }\n        }\n        end:;\n        if(yes)printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n    return 0;\n}\n*/\n\n#define N 80000\n\nint main(){\n    int i,j,n,m;\n    double bma,bmi,wma,wmi,ang=PI/N,tmp;\n    static double bxs[100], wxs[100], bys[100], wys[100];\n    while(scanf(\"%d%d\",&n,&m)){\n        if(n==0 && m==0) break;\n        REP(i,n)scanf(\"%lf%lf\",bxs+i,bys+i);\n        REP(i,m)scanf(\"%lf%lf\",wxs+i,wys+i);\n        REP(i,N){\n            bma=wma=-1e99;\n            bmi=wmi=1e99;\n            REP(j,n){\n                tmp = cos(ang*i)*bxs[j]-sin(ang*i)*bys[j];\n                if(tmp<bmi)bmi=tmp;\n                if(tmp>bma)bma=tmp;\n            }\n            REP(j,m){\n                tmp = cos(ang*i)*wxs[j]-sin(ang*i)*wys[j];\n                if(bmi<tmp && tmp<bma) goto mark;\n                if(tmp<wmi)wmi=tmp;\n                if(tmp>wma)wma=tmp;\n            }\n            if(bma < wmi || wma < bmi) break;\n            mark:;\n        }\n        if(i==N)printf(\"NO\\n\");\n        else printf(\"YES\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Hello. I'm Peter.\n#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<functional>\n#include<cctype>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define peter cout<<\"i am peter\"<<endl\n#define input freopen(\"data.txt\",\"r\",stdin)\n#define randin srand((unsigned int)time(NULL))\n#define INT (0x3f3f3f3f)*2\n#define LL (0x3f3f3f3f3f3f3f3f)*2\n#define gsize(a) (int)a.size()\n#define len(a) (int)strlen(a)\n#define slen(s) (int)s.length()\n#define pb(a) push_back(a)\n#define clr(a) memset(a,0,sizeof(a))\n#define clr_minus1(a) memset(a,-1,sizeof(a))\n#define clr_INT(a) memset(a,INT,sizeof(a))\n#define clr_true(a) memset(a,true,sizeof(a))\n#define clr_false(a) memset(a,false,sizeof(a))\n#define clr_queue(q) while(!q.empty()) q.pop()\n#define clr_stack(s) while(!s.empty()) s.pop()\n#define rep(i, a, b) for (int i = a; i < b; i++)\n#define dep(i, a, b) for (int i = a; i > b; i--)\n#define repin(i, a, b) for (int i = a; i <= b; i++)\n#define depin(i, a, b) for (int i = a; i >= b; i--)\n#define pi acos(-1.0)\n#define eps 1e-10\n#define MOD 1000000007\n#define MAXN\n#define N 10100\n#define M\nint dcmp(double x){//蛻、譁ュx豁」雍滓?荳コ0\n    if(fabs(x)<eps) return 0;\n    else if(x<0) return -1;\n    else return 1;\n}\nstruct Point{\n    double x,y;\n    Point(){};\n    Point(double xx,double yy):x(xx),y(yy){};\n    friend bool operator<(const Point a,const Point b){\n        if(dcmp(a.x-b.x)!=0) return a.x<b.x;\n        else return a.y<b.y;\n    }\n};\ntypedef Point Vector;\nvoid readPoint(Point &a){//霎灘?荳?クェ轤ケ\n    scanf(\"%lf %lf\",&a.x,&a.y);\n}\ndouble sq(double x){//x^2\n    return x*x;\n}\nVector operator +(const Vector a,const Vector b){//荳、蜷鷹?逶ク蜉?    return Vector(a.x+b.x,a.y+b.y);\n}\nVector operator -(const Vector a,const Vector b){//荳、蜷鷹?逶ク蜃?    return Vector(a.x-b.x,a.y-b.y);\n}\nbool operator ==(const Vector a,const Vector b){//蛻、譁ュ荳、轤ケ謌紋ク、蜷鷹?譏ッ蜷ヲ荳??\n    return dcmp(a.x-b.x)==0 && dcmp(a.y-b.y)==0;\n}\ndouble operator *(const Vector a,const Vector b){//荳、蜷鷹?轤ケ荵?    return a.x*b.x+a.y*b.y;\n}\ndouble operator &(const Vector a,const Vector b){//荳、蜷鷹?蜿臥ァッ\n    return a.x*b.y-a.y*b.x;\n}\nVector operator *(const Vector b,const double a){//荳?クェ謨ー*荳?クェ蜷鷹?\n    return Vector(a*b.x,a*b.y);\n}\nVector operator *(const double a,const Vector b){//荳?クェ蜷鷹?*荳?クェ謨ー\n    return Vector(a*b.x,a*b.y);\n}\nPoint MiddlePoint(Point a,Point b){//豎ゆク、轤ケ逧?クュ轤ケ\n    return Point((a.x+b.x)/2,(a.y+b.y)/2);\n}\ndouble Length(Vector b){//豎ゆク?クェ蜷鷹?逧?柄蠎ヲ\n    return sqrt(b*b);\n}\ndouble DistancePointToPoint(Point a,Point b){//豎らせ蛻ー轤ケ逧?裏蜷題キ晉ヲサ\n    return Length(a-b);\n}\ndouble DistancePointToLine(Point p,Point a,Vector v){//豎らせ蛻ー郤ソ逧?裏蜷題キ晉ヲサ\n    Vector w=p-a;\n    return fabs((v&w)/Length(v));\n}\nPoint Point_LineBananaLine(Point p1,Vector v,Point p2,Vector w){//豎ゆク、郤ソ逧?コ、轤ケ(蜑肴署譏ッ荳、蜷鷹?荳榊?郤ソ)\n    Vector u=p1-p2;\n    double t=(w&u)/(v&w);\n    return p1+v*t;\n}\ndouble polarAngle(Vector a,Vector b){//豎ゆク、荳ェ蜷鷹?逧?裏蜷第栫隗?0<=x<=pi)\n    double t=(a*b)/Length(a)/Length(b);\n    return acos(t);\n    //閠径tan2(double y,double x)豎ら噪譏ッ荳?クェ蜷鷹?荳支霓エ逧?怏蜷第栫隗?-pi<x<=pi)\n}\nint ConvexHull(Point *p,int n,Point *ch){\n    sort(p,p+n);\n    int m=0;\n    rep(i,0,n){\n        while(m>1 && dcmp((ch[m-1]-ch[m-2])&(p[i]-ch[m-2]))<=0) m--;\n        ch[m++]=p[i];\n    }\n    int k=m;\n    depin(i,n-2,0){\n        while(m>k && dcmp((ch[m-1]-ch[m-2])&(p[i]-ch[m-2]))<=0) m--;\n        ch[m++]=p[i];\n    }\n    if(n>1) m--;\n    return m;\n}\nbool SegmentStrictlyBananaSegment(Point p1,Point p2,Point w1,Point w2){//蛻、譁ュ荳、郤ソ谿オ譏ッ蜷ヲ荳・譬シ鬥呵負(荳榊桁諡ャ遶ッ轤ケ)\n    double x1=(w2-w1)&(p1-w1);\n    double x2=(w2-w1)&(p2-w1);\n    double x3=(p2-p1)&(w1-p1);\n    double x4=(p2-p1)&(w2-p1);\n    return dcmp(x1)*dcmp(x2)<0 && dcmp(x3)*dcmp(x4)<0;\n}\nbool ConvexHullIntersection(Point *ch1,int t1,Point *ch2,int t2){//蛻、譁ュ蜃ク蛹?弍蜷ヲ逶ク莠、\n    double angle[N],x;\n    int i,j,k,m;\n    if(t1==1) return true;\n    if(t1==2){\n        for(i=0;i<t2;i++){\n            k=dcmp((ch1[1]-ch1[0])&(ch2[i]-ch1[0]));\n            if(k==0&&(ch1[1]-ch1[0])*(ch2[i]-ch1[0])>0){\n                if(Length(ch2[i]-ch1[0])<Length(ch1[1]-ch1[0]))break;\n            }\n        }\n        if(i<t2)return false;\n        if(t2==2 && SegmentStrictlyBananaSegment(ch1[0],ch1[1],ch2[0],ch2[1]))return false;\n        return true;\n    }\n    angle[0]=0;\n    for(i=2;i<t1;i++)\n        angle[i-1]=polarAngle(ch1[1]-ch1[0],ch1[i]-ch1[0]);\n    for(i=0;i<t2;i++)\n    {\n        j=dcmp((ch1[1]-ch1[0])&(ch2[i]-ch1[0]));\n        if(j<0||(j==0&&(ch1[1]-ch1[0])*(ch2[i]-ch1[0])<0))continue;\n        j=dcmp((ch1[t1-1]-ch1[0])&(ch2[i]-ch1[0]));\n        if(j>0||(j==0&&(ch1[t1-1]-ch1[0])*(ch2[i]-ch1[0])<0))continue;\n        x=polarAngle(ch1[1]-ch1[0],ch2[i]-ch1[0]);\n        m=(int)(lower_bound(angle,angle+t1-1,x)-angle);\n        if(m==0)j=0;\n        else j=m-1;\n        k=dcmp((ch1[j+1]-ch2[i])&(ch1[j+2]-ch2[i]));\n        if(k>=0)break;\n    }\n    if(i<t2)return false;\n    return true;\n}\nbool PointInConvex(Point a, Point* ch, int n){\n    int i;\n    if(n==3){\n        if(a.x < min(ch[0].x, ch[1].x) || a.x > max(ch[0].x, ch[1].x)) return 0;\n        if(a.y < min(ch[0].y, ch[1].y) || a.y > max(ch[0].y, ch[1].y)) return 0;\n    }\n    for(i=1;i<n;i++){\n        if( ((ch[i]-ch[i-1])&(a-ch[i-1])) < 0) return 0;\n    }\n    return 1;\n}\nint n,m,num_ch1,num_ch2;\nPoint black[N],ch1[N],white[N],ch2[N];\nint main(){\n//    input;\n    while(~scanf(\"%d%d\",&n,&m) && (n+m)){\n        rep(i,0,n){\n            readPoint(black[i]);\n        }\n        num_ch1=ConvexHull(black,n,ch1);\n        rep(i,0,m){\n            readPoint(white[i]);\n        }\n        num_ch2=ConvexHull(white,m,ch2);\n        bool ok;\n        if(n==1 && m==1) ok=true;\n        else if(n==1){\n            if(PointInConvex(black[0],ch2,num_ch2)) ok=false;\n            else ok=true;\n        }\n        else if(m==1){\n            if(PointInConvex(white[0],ch1,num_ch1)) ok=false;\n            else ok=true;\n        }\n        //n!=1 && m!=1\n        else if(ConvexHullIntersection(ch1,num_ch1,ch2,num_ch2) && ConvexHullIntersection(ch2,num_ch2,ch1,num_ch1)){\n            ok=true;\n        }\n        else ok=false;\n        printf(\"%s\\n\",ok?\"YES\":\"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef pair<int,int> P;\n\n//for vector\ninline int norm(const P &a){ return a.fs*a.fs + a.sc*a.sc; }\ninline int dot(const P &a, const P &b){return a.fs*b.fs + a.sc*b.sc;}\ninline int cross(const P &a, const P &b){return a.fs*b.sc - a.sc*b.fs;}\n\ninline int ccw(const P &a,P b,P c){\n  b.fs -= a.fs; b.sc -= a.sc;\n  c.fs -= a.fs; c.sc -= a.sc;\n  if (cross(b,c)>0) return 1;   //counter clockwise\n  if (cross(b,c)<0) return -1; //clockwise\n  if (dot(b, c)<-0) return 2;   //c--a--b on line\n  if (norm(b)<norm(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n\n  int n,m;\n  P b[110],w[110];\n  while(cin >> n >> m){\n    if(n==0 && m==0)break;\n    rep(i,n)cin >> b[i].fs >> b[i].sc;\n    rep(i,m)cin >> w[i].fs >> w[i].sc;\n\n    bool ans = false;\n    rep(i,n)rep(j,i){\n      bool f = true;\n      set<int> dirb;\n      rep(k,n){\n\tif(k==i || k==j)continue;\n\tint tmp = ccw(b[i],b[j],b[k]);\n\tif(tmp == 0){f = false; break;}\n\tif(abs(tmp)==1)dirb.insert(tmp);\n      }\n      if(dirb.size()==2)f = false;\n\n      if(f){\n\tset<int> dirw;\n\trep(k,m){\n\t  int tmp = ccw(b[i],b[j],w[k]);\n\t  if(abs(tmp) != 1){f = false; break;}\n\t  dirw.insert(tmp);\n\t}\n\tif(dirw.size()==2)f = false;\n\tif(f && (dirb.size()==0 || dirw.size()==0\n\t\t || *dirb.begin() != *dirw.begin()))ans = true;\n      }\n    }\n\n    rep(i,m)rep(j,i){\n      bool f = true;\n      set<int> dirw;\n      rep(k,m){\n\tif(k==i || k==j)continue;\n\tint tmp = ccw(w[i],w[j],w[k]);\n\tif(tmp == 0){f = false; break;}\n\tif(abs(tmp)==1)dirw.insert(tmp);\n      }\n      if(dirw.size()==2)f = false;\n\n      if(f){\n\tset<int> dirb;\n\trep(k,n){\n\t  int tmp = ccw(w[i],w[j],b[k]);\n\t  if(abs(tmp) != 1){f = false; break;}\n\t  dirb.insert(tmp);\n\t}\n\tif(dirb.size()==2)f = false;\n\tif(f && (dirb.size()==0 || dirw.size()==0\n\t\t || *dirb.begin() != *dirw.begin()))ans = true;\n      }\n    }\n\n    rep(i,n)rep(j,m){\n      bool f = true;\n      set<int> dirb;\n      rep(k,n){\n\tif(k==i)continue;\n\tint tmp = ccw(b[i],w[j],b[k]);\n\tif(tmp == 0 || tmp == -2){f = false; break;}\n\tif(abs(tmp)==1)dirb.insert(tmp);\n\tdirb.insert(tmp);\n      }\n      if(dirb.size()==2)f = false;\n\n      if(f){\n\tset<int> dirw;\n\trep(k,m){\n\t  if(k==j)continue;\n\t  int tmp = ccw(b[i],w[j],w[k]);\n\t  if(tmp == 0 || tmp == 2){f = false; break;}\n\t  if(abs(tmp)==1)dirw.insert(tmp);\n\t}\n\tif(dirw.size()==2)f = false;\n\t\n\tif(f && (dirb.size()==0 || dirw.size()==0\n\t\t || *dirb.begin() != *dirw.begin()))ans = true;\n      }\n    }\n\n    cout << (ans?\"YES\":\"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing ld = long double;\nusing Point = std::complex<ld>;\nusing P = pair<int, int>;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std\n{\nbool operator<(const Point &lhs, const Point &rhs)\n{\n    if (lhs.real() < rhs.real() - eps)\n        return true;\n    if (lhs.real() > rhs.real() + eps)\n        return false;\n    return lhs.imag() < rhs.imag();\n}\n} // namespace std\n\nPoint input_point()\n{\n    ld x, y;\n    std::cin >> x >> y;\n    return Point(x, y);\n}\n\nbool eq(ld a, ld b)\n{\n    return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b)\n{\n    return real(conj(a) * b);\n}\n\nld cross(Point a, Point b)\n{\n    return imag(conj(a) * b);\n}\n\n// CCW::counter clockwise\nint ccw(Point a, Point b, Point c)\n{\n    b -= a;\n    c -= a;\n    if (cross(b, c) > eps)\n        return 2; // a,b,c : counter-clockwise\n    if (cross(b, c) < -eps)\n        return 0; // a,b,c : clockwise\n    return 1;\n}\n\nclass Line\n{\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n};\n\nld dot(Line l, Line m)\n{\n    return dot((l.a - l.b), (m.a - m.b));\n}\n\n// l, m が交点を持つか\nbool isis_ll(Line l, Line m)\n{\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// s : segment\nbool isis_ls(Line l, Line s)\n{\n    return isis_ll(l, s) &&\n           (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t)\n{\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n           ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// p が l 上に存在するか\nbool isis_lp(Line l, Point p)\n{\n    return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m;\n    while (cin >> n >> m, n || m)\n    {\n        vector<Point> bs(n), ws(m);\n        for (int i = 0; i < n; i++)\n        {\n            bs[i] = input_point();\n        }\n        for (int i = 0; i < m; i++)\n        {\n            ws[i] = input_point();\n        }\n        if (n == 1 && m == 1)\n        {\n            cout << \"YES\" << endl;\n            continue;\n        }\n        bool line = true;\n        for (int i = 0; i < n; i++)\n            if (!isis_lp(Line(bs[0], ws[0]), bs[i]))\n                line = false;\n        for (int i = 0; i < m; i++)\n            if (!isis_lp(Line(bs[0], ws[0]), ws[i]))\n                line = false;\n        if (line)\n        {\n            vector<P> ps;\n            for (int i = 0; i < n; i++)\n                ps.push_back(P(bs[i].real(), 0));\n            for (int i = 0; i < m; i++)\n                ps.push_back(P(ws[i].real(), 1));\n            sort(ps.begin(), ps.end());\n            int cnt = 0;\n            for (int i = 0; i < n + m; i++)\n                if (ps[i].second != ps[i-1].second)\n                    cnt++;\n            cout << (cnt <= 1 ? \"YES\" : \"NO\") << endl;\n            continue;\n        }\n        bool f = false;\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = i + 1; j < n; j++)\n            {\n                bool tmp = true;\n                int bf = 0, wf = 0;\n                for (int k = 0; k < n; k++)\n                {\n                    bf |= (1 << ccw(bs[i], bs[j], bs[k]));\n                }\n                for (int k = 0; k < m; k++)\n                {\n                    wf |= (1 << ccw(bs[i], bs[j], ws[k]));\n                }\n                for (int k = 0; k < 3; k++)\n                {\n                    if (((bf >> k) & 1) & ((wf >> k) & 1))\n                        tmp = false;\n                }\n                if ((bf & 4) && (bf & 1))\n                    tmp = false;\n                if ((wf & 4) && (wf & 1))\n                    tmp = false;\n                if (tmp)\n                    f = true;\n            }\n        }\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = i + 1; j < m; j++)\n            {\n                bool tmp = true;\n                int bf = 0, wf = 0;\n                for (int k = 0; k < n; k++)\n                {\n                    bf |= (1 << ccw(ws[i], ws[j], bs[k]));\n                }\n                for (int k = 0; k < m; k++)\n                {\n                    wf |= (1 << ccw(ws[i], ws[j], ws[k]));\n                }\n                for (int k = 0; k < 3; k++)\n                {\n                    if (((bf >> k) & 1) & ((wf >> k) & 1))\n                        tmp = false;\n                }\n                if ((bf & 4) && (bf & 1))\n                    tmp = false;\n                if ((wf & 4) && (wf & 1))\n                    tmp = false;\n                if (tmp)\n                    f = true;\n            }\n        }\n        cout << (f ? \"YES\" : \"NO\") << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cassert>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-8\n#define F first\n#define S second\nusing namespace std;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point\n{\n  public:\n  double x,y;\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nbool isIntersect(Segment s1,Segment s2)\n{\nreturn isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool cmp(const vector<Point> &a,const vector<Point> &b)\n{\n  return a.size() < b.size();\n}\n\nPolygon andrewScan(Polygon s)\n{\n  Polygon u,l;\n  if(s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<s.size();i++)\n    {\n      for(int n=u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--)\n\tu.pop_back();\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3; i>=0 ; i--)\n    {\n      for(int n=l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--)\n\tl.pop_back();\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\nbool check(int p1,int p2,vector<Point> &black,vector<Point> &white)\n{\n  int n = black.size();\n  pair<bool,bool> Left,Right;\n  Left  = pair<bool,bool>(false,false); // F->black, S->white\n  Right = pair<bool,bool>(false,false);\n\n  rep(i,n)\n    {\n      if(i == p1 || i == p2)continue;\n      int res = ccw(black[p1],black[p2],black[i]);\n      if(res == CLOCKWISE) Right.F = true;\n      if(res == COUNTER_CLOCKWISE) Left.F = true;\n    }\n  \n  n = white.size();\n  rep(i,n)\n    {\n      int res = ccw(black[p1],black[p2],white[i]);\n      if(res == CLOCKWISE) Right.S = true;\n      if(res == COUNTER_CLOCKWISE) Left.S = true;\n    }\n\n  if(Left.F && Left.S)return false;\n  if(Right.F && Right.S)return false;\n  return true;\n}\n\nvoid printVP(vector<Point> a)\n{\n  cout << \"printVP-------\" << endl;\n  rep(i,a.size())cout << \"(\" << a[i].x << \",\" << a[i].y << \") \";\n  cout << endl;\n}\n\nint main()\n{\n  int n,m;\n  while(cin >> n >> m,n|m)\n    {\n      assert(n && m);\n      vector<Point> A(n),B(m);\n      rep(_,n)cin >> A[_].x >> A[_].y;\n      rep(_,m)cin >> B[_].x >> B[_].y;\n\n      vector<Point> black,white;\n      if(A.size() > B.size())\n\tblack = A,white = B;\n      else\n\tblack = B,white = A;\n\n      \n      if(n == 1 && m == 1)\n\t{\n\t  cout << \"YES\" << endl;\n\t  continue;\n\t}\n\n      if(white.size() == 1)\n\t{\n\t  sort(black.begin(),black.end());\n\t  rep(i,black.size())\n\t    if(ccw(black[i],black[(i+1)%black.size()],white[0]) == ON_SEGMENT)\n\t      {\n\t\tcout << \"NO\" << endl;\n\t\tgoto FX;\n\t      }\n\t  cout << \"YES\" << endl;\n\tFX:;\n\t  continue;\n\t}\n    \n      if(black.size() == 2 && white.size() == 2)\n\t{\n\t  if(isIntersect(Segment(black[0],black[1]),Segment(white[0],white[1])))cout << \"NO\" << endl;\n\t  else                                                                  cout << \"YES\" << endl;\n\t  continue;\n\t}\n    \n      int N = black.size();\n      rep(i,N)\n\t{\n\t  if(check(i,(i+1)%N,black,white))\n\t    {\n\t      cout << \"YES\" << endl;\n\t      goto F;\n\t    }\n\t}\n      cout << \"NO\" << endl;\n    F:;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#define next(P, i) P[(i+1) % P.size()]\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n};\n\nbool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n\n  if(cross(a1-a2,b1-b2)==0){\n    return is_point_on_line(a1,a2,b1) || is_point_on_line(a1,a2,b2) \n        || is_point_on_line(b1,b2,a1) || is_point_on_line(b1,b2,a2);\n  }\n  else {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n           ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n  }\n}\n\nint contain(point p, vector<point> ps){\n  point a(p.x,p.y),b(1000000,p.y);\n\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<ps.size();i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(a.y<=ymn||a.y>=ymx)return 0;\n\n  int cnt1=0;\n  for(int i=0;i<ps.size();i++)\n    if(is_point_on_line(a,b,ps[i]))cnt1++;\n  \n  int cnt=0;\n  for(int i=0;i<ps.size();i++)\n    if(is_intersected_ls(ps[i],next(ps,i),a,b))cnt++;\n\n  return (cnt-cnt1)%2;\n}\n\nint crossPol(vector<point> pol1, vector<point> pol2){\n\n  for(int i=0;i<pol1.size();i++)\n    if(contain(pol1[i],pol2))return 1;\n  \n  for(int i=0;i<pol2.size();i++)\n    if(contain(pol2[i],pol1))return 1;\n\n  for(int i=0;i<pol1.size();i++)\n    for(int j=0;j<pol2.size();j++)\n      if(is_intersected_ls(pol1[i],next(pol1,i),pol2[j],next(pol2,j)))return 1;\n  \n  return 0;\n}\n\nvector<point>convex_hull(point* ps, int n){\n  sort(ps,ps+n,cmp_x);\n  int k=0;\n  vector<point>qs(n*2);\n \n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0)k--;\n    qs[k++]=ps[i];\n  }\n \n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0)k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nint main(void){\n  int n,m;\n  point black[100],white[100];\n\n  while(cin >> n >> m,n|m){\n\n    for(int i=0;i<n;i++)\n      cin >> black[i].x >> black[i].y;\n    \n    for(int i=0;i<m;i++)\n      cin >> white[i].x >> white[i].y;\n\n    if(n<2||m<2){\n      if(n<2 && m<2)cout << \"YES\" << endl;\n      else {\n\tbool fg=false;\n\tfor(int i=0;i<n;i++){\n\t  for(int j=0;j<m;j++){\n\t    if(is_intersected_ls(black[i],black[(i+1)%n],white[j],white[(j+1)%n]))fg=true;\n\t  }\n\t}\n\tif(fg)cout <<\"NO\"<<endl;\n\telse cout << \"YES\" << endl;\n      }\n      continue;\n    }\n\n    vector<point>Black,White;\n\n    Black=convex_hull(black,n);\n    White=convex_hull(white,m);\n    \n    if(crossPol(Black,White))cout << \"NO\" << endl;\n    else cout << \"YES\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst ld eps = 1e-9;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nusing Point = std::complex<ld>;\nconst ld pi = acos(-1.0);\nnamespace std {\nbool operator<(const Point &lhs, const Point &rhs) {\n  if (lhs.real() < rhs.real() - eps) return true;\n  if (lhs.real() > rhs.real() + eps) return false;\n  return lhs.imag() < rhs.imag();\n}\n}\nPoint input_point() {\n  ld x, y;\n  std::cin >> x >> y;\n  return Point(x, y);\n}\nbool eq(ld a, ld b) { return (abs(a - b) < eps); }\nld dot(Point a, Point b) { return real(conj(a) * b); }\nld cross(Point a, Point b) { return imag(conj(a) * b); }\nint ccw(Point a, Point b, Point c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\nclass Line {\n public:\n  Point a, b;\n  Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line(Point a, Point b) : a(a), b(b) {}\n};\nld dot(Line l, Line m) { return dot((l.a - l.b), (m.a - m.b)); }\nclass Circle {\n public:\n  Point p;\n  ld r;\n  Circle() : p(Point(0, 0)), r(0) {}\n  Circle(Point p, ld r) : p(p), r(r) {}\n};\nbool isis_ll(Line l, Line m) { return !eq(cross(l.b - l.a, m.b - m.a), 0); }\nbool isis_ls(Line l, Line s) {\n  return isis_ll(l, s) &&\n         (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n         ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\nbool isis_lp(Line l, Point p) { return (abs(cross(l.b - p, l.a - p)) < eps); }\nbool isis_sp(Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\nPoint proj(Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\nPoint is_ll(Line l, Line m) {\n  Point lv = l.b - l.a, mv = m.b - m.a;\n  assert(cross(lv, mv) != 0);\n  return l.a + lv * cross(mv, m.a - l.a) / cross(mv, lv);\n}\nld dist_lp(Line l, Point p) { return abs(p - proj(l, p)); }\nld dist_ll(Line l, Line m) { return isis_ll(l, m) ? 0 : dist_lp(l, m.a); }\nld dist_ls(Line l, Line s) {\n  return isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\nld dist_sp(Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : std::min(abs(s.a - p), abs(s.b - p));\n}\nld dist_ss(Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return std::min(\n      {dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\nLine bisector(Point a, Point b) {\n  Point mid = (a + b) * Point(0.5, 0);\n  return Line(mid, mid + (b - a) * Point(0, pi / 2));\n}\nld degree_ll(Line l, Line m) {\n  ld cos_shita = dot(l, m) / (abs(l.b - l.a) * abs(m.b - m.a));\n  if (cos_shita < -1.0) cos_shita = -1.0;\n  if (cos_shita > 1.0) cos_shita = 1.0;\n  ld shita = acos(cos_shita);\n  return shita;\n}\nstd::vector<Point> is_cc(Circle c1, Circle c2) {\n  std::vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps)\n    dfr = 0.0;\n  else if (dfr < 0.0)\n    return res;\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.emplace_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.emplace_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\nstd::vector<Point> is_lc(Circle c, Line l) {\n  std::vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps) {\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.emplace_back(proj(l, c.p) + len * nor);\n    res.emplace_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\nstd::vector<Point> is_sc(Circle c, Line l) {\n  std::vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.emplace_back(p);\n  return res;\n}\nstd::vector<Line> tangent_cp(Circle c, Point p) {\n  std::vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (std::isnan(l)) {\n    return ret;\n  }\n  Point v1 = v * Point(l / d, c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.emplace_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.emplace_back(Line(p, p + v2));\n  return ret;\n}\nstd::vector<Line> tangent_cc(Circle c1, Circle c2) {\n  std::vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    std::vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), nret.begin(), nret.end());\n  } else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0, 1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.emplace_back(Line(q1, q1 + v));\n    ret.emplace_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\nvoid solve(int n, int m) {\n  vector<Point> b(n), w(m);\n  for(int i=0;i<n;++i) {\n    b[i] = input_point();\n  }\n  for(int i=0;i<m;++i) {\n    w[i] = input_point();\n  }\n  if(n == 0 || m == 0) {\n    cout << \"YES\" << endl;\n    return;\n  }\n  bool ok = false;\n  for(int i=0;i<n;++i) {\n    if(ok) break;\n    for(int j=n;j<n+m;++j) {\n      if(ok) break;\n      Point p1, p2;\n      if(i < n) p1 = b[i];\n      else p1 = w[i-n];\n      if(j < n) p2 = b[j];\n      else p2 = w[j-n];\n      vector<int> on = {i, j};\n      int leb = -1, rib = -1;\n      bool oknow = true;\n      for(int k=0;k<n+m;++k) {\n        if(k == i || k == j ) continue;\n        Point p3 = (k < n ? b[k] : w[k-n]);\n        ld sin = cross(p3 - p1, p2 - p1);\n        if(abs(sin) < eps) {\n          on.push_back(k);\n        } else if(sin < -eps) {\n          if(leb == -1) leb = k < n;\n          else oknow &= leb == k < n;\n        } else {\n          if(rib == -1) rib = k < n;\n          else oknow &= rib == k < n;\n        }\n      }\n      oknow &= (leb == -1 || rib == -1 || leb != rib);\n      vector<pair<ld, int>> v((int)(on.size()));\n      for(int k=0;k<(int)(on.size());++k) {\n        if(on[k] < n) {\n          v[k] = {dot(b[on[k]] - p1, p2 - p1), on[k]};\n        } else {\n          v[k] = {dot(w[on[k]-n] - p1, p2 - p1), on[k]};\n        }\n      }\n      sort(v.begin(), v.end());\n      int cnt = 0;\n      for(int k=0;k<(int)(v.size())-1;++k) {\n        cnt += (v[k].second < n) != (v[k+1].second < n);\n      }\n      oknow &= cnt <= 1;\n      ok |= oknow;\n    }\n  }\n  cout << (ok ? \"YES\" : \"NO\") << endl;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int n, m; cin >> n >> m;\n    if(n == 0 && m == 0) break;\n    solve(n, m);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n\nstruct Point{\n  double x,y;\n\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n  Point operator / (const double &k)const{ return Point(x/k,y/k); }\n  bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\n\nistream &operator >> (istream &is,Point &p){ \n  return is >> p.x >> p.y;\n}\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS){ return COUNTER_CLOCKWISE; }\n  if(cross(a,b) < -EPS){ return CLOCKWISE; }\n  if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n  if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n  return ON_SEGMENT;\n}\n\nstruct Segment{\n  Point s,t;\n  Segment(){}\n  Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nbool isIntersectSP(const Segment &s,const Point &p){\n  return equal(ccw(s.s,s.t,p),0);\n}\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n  Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0\n    && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\n#define prev(G,i) (G[(i-1+G.size())%G.size()])\n#define curr(G,i) (G[i%G.size()])\n#define next(G,i) (G[(i+1)%G.size()])\ntypedef vector<Point> Polygon;\n\nbool check(const Polygon &pg,const Point &p){\n  int N = pg.size();\n  bool in = false;\n  for(int i = 0 ; i < N ; i++){\n    Point a = curr(pg,i)-p, b = next(pg,i)-p;\n    if(a.y > b.y){ swap(a,b); }\n    if(a.y <= 0 && 0 < b.y && cross(a,b) > 0){ in = !in; }\n    if(cross(a,b) == 0 && dot(a,b) <= 0){ return true; }\n  }\n  return in;\n}\n\nbool solve(Polygon &bp,Polygon &wp){\n  int N = bp.size(), M = wp.size();\n  if(N == 1 && M == 1){\n    return !(equal(bp[0].x,wp[0].x) && equal(bp[0].y,wp[0].y));\n  }\n  if(N == 2 && M == 1){\n    Segment s(bp[0],bp[1]);\n    return !isIntersectSP(s,wp[0]);\n  }\n  if(N == 1 && M == 2){\n    Segment s(wp[0],wp[1]);\n    return !isIntersectSP(s,bp[0]);\n  }\n  if(N == 2 && M == 2){\n    Segment s1(bp[0],bp[1]),s2(wp[0],wp[1]);\n    return !isIntersectSS(s1,s2);\n  }\n  if(N == 1 && M >= 3){\n    return !check(wp,bp[0]);\n  }\n  if(N >= 3 && M == 1){\n    return !check(bp,wp[0]);\n  }\n  if(N == 2 && M >= 3){\n    Segment s1(bp[0],bp[1]);\n    if(check(wp,bp[0]) || check(wp,bp[1])){\n      return false;\n    }\n    for(int i = 0 ; i < M ; i++){\n      for(int j = i+1 ; j < M ; j++){\n        Segment s2(wp[i],wp[j]);\n        if(isIntersectSS(s1,s2)){\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  if(N >= 3 && M == 2){\n    Segment s1(wp[0],wp[1]);\n    if(check(bp,wp[0]) || check(bp,wp[1])){\n      return false;\n    }\n    for(int i = 0 ; i < N ; i++){\n      for(int j = i+1 ; j < N ; j++){\n        Segment s2(bp[i],bp[j]);\n        if(isIntersectSS(s1,s2)){\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  for(int i = 0 ; i < N ; i++){\n    if(check(wp,bp[i])){\n      return false;\n    }\n  }\n  for(int i = 0 ; i < M ; i++){\n    if(check(bp,wp[i])){\n      return false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  int N,M;\n  while(cin >> N >> M,N){\n    Polygon bp(N),wp(M);\n    for(int i = 0 ; i < N ; i++){\n      cin >> bp[i];\n    }\n    for(int i = 0 ; i < M ; i++){\n      cin >> wp[i];\n    }\n    cout << (solve(bp,wp) ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___STD_GEOMETRY\n#define ___STD_GEOMETRY\n\n#include <cmath>\n\n#define EPS 1e-13L\n\n#endif\n\n#ifndef ___Class_Point\n#define ___Class_Point\n\nclass Point\n{\npublic:\n\n\t// ------ Variable ------ //\n\n\tlong double x, y;\n\n\n\t// ------ Constructor ------ //\n\n\tPoint() : x(0), y(0) { }\n\n\texplicit Point(long double x, long double y) : x(x), y(y) { }\n\n\n\t// ------ Operator ------ //\n\n\tfriend bool operator==(Point& p1, Point& p2) { return p1.x == p2.x && p1.y == p2.y; }\n\tfriend bool operator!=(Point& p1, Point& p2) { return p1.x != p2.x || p1.y != p2.y; }\n};\n\nlong double distance(const Point& p1, const Point& p2)\n{\n\treturn sqrtl((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));\n}\n\n#endif\n\n#ifndef ___Class_Vector\n#define ___Class_Vector\n\nclass Vector\n{\npublic:\n\n\t// ------ Variable ------ //\n\n\tlong double x, y;\n\n\n\t// ------ Constructor ------ //\n\n\tVector() : x(0), y(0) { }\n\n\texplicit Vector(long double x, long double y) : x(x), y(y) { }\n\n\texplicit Vector(Point p1, Point p2) : x(p2.x - p1.x), y(p2.y - p1.y) { }\n\n\texplicit Vector(long double sx, long double tx, long double sy, long double ty) : x(tx - sx), y(ty - sy) { }\n\n\n\t// ------ Operator ------ //\n\n\tVector operator+() const { return Vector(+x, +y); }\n\tVector operator-() const { return Vector(-x, -y); }\n\n\tVector& operator+=(const Vector& v) { x += v.x; y += v.y; return *this; }\n\tVector& operator-=(const Vector& v) { x -= v.x; y -= v.y; return *this; }\n\n\tfriend bool operator==(const Vector& v1, const Vector& v2) { return -EPS < v1.x - v2.x && v1.x - v2.x < EPS && -EPS < v1.y - v2.y && v1.y - v2.y < EPS; }\n\tfriend bool operator!=(const Vector& v1, const Vector& v2) { return !(v1 == v2); }\n\n\tfriend Vector operator+(const Vector& v1, const Vector& v2) { return Vector(v1.x + v2.x, v1.y + v2.y); }\n\tfriend Vector operator-(const Vector& v1, const Vector& v2) { return Vector(v1.x - v2.x, v1.y - v2.y); }\n\n\tfriend Vector operator*(double d, const Vector& v) { return Vector(d * v.x, d * v.y); }\n\tfriend Vector operator*(const Vector& v, double d) { return Vector(d * v.x, d * v.y); }\n\tfriend Vector operator/(const Vector& v, double d) { return Vector(v.x / d, v.y / d); }\n\n\n\t// ------ Function ------ //\n\n\tlong double norm() { return x * x + y * y; }\n\n\tlong double abs() { return sqrtl(x * x + y * y); }\n\n\tlong double angle() { return atan2l(y, x); }\n};\n\nlong double angle(const Vector& v1, const Vector& v2)\n{\n\tlong double A = atan2l(v2.y, v2.x) - atan2l(v1.y, v1.x);\n\n\tif (180.0L - EPS < A && A < 180.0L + EPS) { return 180.0L; }\n\n\tif (-180.0L - EPS < A && A < -180.0L + EPS) { return 180.0L; }\n\n\tif (A > 180.0L - EPS) { return A - 360.0L; }\n\n\tif (A < -180.0L + EPS) { return A + 360.0L; }\n\n\treturn A;\n}\n\nlong double norm(const Vector& v1)\n{\n\treturn v1.x * v1.x + v1.y * v1.y;\n}\n\nlong double abs(const Vector& v1)\n{\n\treturn sqrt(norm(v1));\n}\n\nlong double cross(const Vector& v1, const Vector& v2)\n{\n\treturn v1.x * v2.y - v1.y * v2.x;\n}\n\nlong double dot(const Vector& v1, const Vector& v2)\n{\n\treturn v1.x * v2.x + v1.y * v2.y;\n}\n\nlong double distance(const Vector& v1, const Vector& v2)\n{\n\treturn sqrtl((v2.x - v1.x) * (v2.x - v1.x) + (v2.y - v1.y) * (v2.y - v1.y));\n}\n\n#endif\n\nbool Triangle_Inside(Vector Tp1, Vector Tp2, Vector Tp3, Vector p) // Triangle is Counter-Clockwise\n{\n\tbool ok1 = !(angle(p - Tp1, Tp2 - Tp1) < 0 ^ angle(Tp2 - Tp1, p - Tp1) < angle(Tp2 - Tp1, Tp3 - Tp1));\n\tbool ok2 = !(angle(p - Tp2, Tp3 - Tp2) < 0 ^ angle(Tp3 - Tp2, p - Tp2) < angle(Tp3 - Tp2, Tp1 - Tp2));\n\tbool ok3 = !(angle(p - Tp3, Tp1 - Tp3) < 0 ^ angle(Tp1 - Tp3, p - Tp3) < angle(Tp1 - Tp3, Tp2 - Tp3));\n\n\treturn ok1 && ok2 && ok3;\n}\n\nbool On_Segment(Vector Sp1, Vector Sp2, Vector p)\n{\n\treturn (Sp1 + Sp2) / 2 == p;\n}\n\nint Counter_Clockwise(Vector p1, Vector p2, Vector p3)\n{\n\tVector a = p2 - p1;\n\tVector b = p3 - p1;\n\n\tif (cross(a, b) > EPS) { return 1; }\n\tif (cross(a, b) < -EPS) { return -1; }\n\n\tif (dot(a, b) < -EPS) { return 2; }\n\n\tif (a.norm() < b.norm()) { return -2; }\n\n\treturn 0;\n}\n\nbool Intersection(Vector p1, Vector p2, Vector p3, Vector p4)\n{\n\tint ok1 = Counter_Clockwise(p1, p2, p3) * Counter_Clockwise(p1, p2, p4);\n\tint ok2 = Counter_Clockwise(p3, p4, p1) * Counter_Clockwise(p3, p4, p2);\n\n\treturn ok1 <= 0 && ok2 <= 0;\n}\n\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tint N, M, X, Y;\n\n\twhile (true)\n\t{\n\t\tcin >> N >> M;\n\n\t\tif (N == 0 && M == 0) { break; }\n\n\t\tvector<Vector> W(N);\n\t\tvector<Vector> B(M);\n\n\t\tfor (int i = 0; i < N; i++) { cin >> X >> Y; W[i] = Vector(X, Y); }\n\t\tfor (int i = 0; i < M; i++) { cin >> X >> Y; B[i] = Vector(X, Y); }\n\n\t\tbool ok = true;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < M; k++)\n\t\t\t\t{\n\t\t\t\t\tif (On_Segment(W[i], W[j], B[k]) == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < M; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < M; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t\t{\n\t\t\t\t\tif (On_Segment(B[i], B[j], W[k]) == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ok == true)\n\t\t{\n\t\t\tif (N > 2 || M > 2)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int k = j + 1; k < N; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int l = 0; l < M; l++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (Triangle_Inside(W[i], W[j], W[k], B[l]) == true)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tok = false; goto Exit;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < M; i++)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = i + 1; j < M; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int k = j + 1; k < M; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int l = 0; l < N; l++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (Triangle_Inside(B[i], B[j], B[k], W[l]) == true)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tok = false; goto Exit;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (N == 2 && M == 2)\n\t\t\t{\n\t\t\t\tok = (Intersection(W[0], W[1], B[0], B[1]) == true ? false : true);\n\t\t\t}\n\t\t}\n\n\tExit:;\n\n\t\tcout << (ok == true ? \"YES\" : \"NO\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle(Point a, ld b) :p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tld r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2, 0)*projection(l, p) - p;\n}\n\nld dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tld a = cross(s.b - s.a, t.b - t.a);\n\tld b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tld dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tld d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tld d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tld len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\n\nPolygon convex_hull(Polygon s)\n{\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(ALL(s));\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\tFOR(i, 2, s.size())\n\t{\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != -1; n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\tfor (int i = s.size() - 3; i >= 0; i--)\n\t{\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != -1; n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\nint contains(Polygon g, Point p)\n{\n\tbool f = false;\n\tREP(i, g.size())\n\t{\n\t\tPoint a = g[i] - p, b = g[(i + 1) % g.size()] - p;\n\t\tif (abs(cross(a, b)) < EPS&&dot(a, b) < EPS) return 0; //ON\n\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\tif (a.imag() < EPS&&b.imag() > EPS&&cross(a, b) > EPS) f = !f;\n\t}\n\tif (f) return 1; //IN\n\telse return -1; //OUT\n}\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tPolygon b, w;\n\t\tREP(i, n)\n\t\t{\n\t\t\tld x, y; cin >> x >> y;\n\t\t\tb.emplace_back(x, y);\n\t\t}\n\t\tREP(i, m)\n\t\t{\n\t\t\tld x, y; cin >> x >> y;\n\t\t\tw.emplace_back(x, y);\n\t\t}\n\t\tbool res;\n\t\tif (n == 1 && m == 1) res = true;\n\t\telse if (n == 2 && m == 1)\n\t\t{\n\t\t\tres = !isis_sp(Line(b[0], b[1]), w[0]);\n\t\t}\n\t\telse if (n == 1 && m == 2)\n\t\t{\n\t\t\tres = !isis_sp(Line(w[0], w[1]), b[0]);\n\t\t}\n\t\telse if (n == 2 && m == 2)\n\t\t{\n\t\t\tres = !isis_ss(Line(b[0], b[1]), Line(w[0], w[1]));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPolygon cb = convex_hull(b);\n\t\t\tPolygon cw = convex_hull(w);\n\t\t\tres = true;\n\t\t\tif (cw.size() > 2)\n\t\t\t{\n\t\t\t\tREP(i, w.size())\n\t\t\t\t\tif (contains(cb, w[i]) == 1) res = false;\n\t\t\t}\n\t\t\tif (cb.size() > 2)\n\t\t\t{\n\t\t\t\tREP(i, b.size())\n\t\t\t\t\tif (contains(cw, b[i]) == 1) res = false;\n\t\t\t}\n\t\t}\n\t\tputs(res ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\n#define EPS 1e-9\n\ntypedef complex<double> point;\ntypedef const point &refpoint;\n\n\ndouble dot(refpoint a, refpoint b){\n\treturn real(a) * real(b) + imag(a) * imag(b);\n}\n\ndouble cross(refpoint a, refpoint b){\n\treturn real(a) * imag(b) - imag(a) * real(b);\n}\n\ndouble distance_l_p(refpoint a, refpoint b, refpoint c){\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\ndouble distance_ls_p(refpoint a, refpoint b, refpoint c){\n\tif( dot(b - a, c - a) <= 0.0 ) return abs(c - a);\n\tif( dot(a - b, c - b) <= 0.0 ) return abs(c - b);\n\treturn distance_l_p(a, b, c);\n}\n\nbool contains(const vector<point> &plg, refpoint pts){\n\tint cnt = 0;\n\tdouble y = imag(pts);\n\n\tfor(int i = 0; i < plg.size(); ++i){\n\t\tint j = (i + 1 == plg.size() ? 0: i + 1);\n\n\t\tdouble dyi = imag(plg[i]) - y;\n\t\tdouble dyj = y - imag(plg[j]);\n\t\tdouble tx = (dyi * real(plg[j]) + dyj * real(plg[i])) / (dyi + dyj);\n\n\t\tif(imag(plg[i]) >= y && imag(plg[j]) < y){\n\t\t\tif( tx < real(pts) ) ++cnt;\n\t\t}\n\t\telse if(imag(plg[i]) < y && imag(plg[j]) >= y){\n\t\t\tif( tx < real(pts) ) --cnt;\n\t\t}\n\t}\n\t\n\treturn (cnt % 2 != 0);\n}\n\nbool intersected(refpoint pa1, refpoint pa2, refpoint pb1, refpoint pb2){\n\tdouble a = cross(pa2 - pa1, pb1 - pa1);\n\tdouble b = cross(pa2 - pa1, pb2 - pa1);\n\tdouble c = cross(pb2 - pb1, pa1 - pb1);\n\tdouble d = cross(pb2 - pb1, pa2 - pb1);\n\n\tif( (a < -EPS && b > EPS) || (b < -EPS && a > EPS) ){\n\t\tif( (c < -EPS && d > EPS) || (d < -EPS && c > EPS) ){\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nbool contact(const vector<point> &plg1, const vector<point> &plg2){\n\tif( contains(plg1, plg2[0]) || contains(plg2, plg1[0]) ){\n\t\treturn true;\n\t}\n\n\tint n = plg1.size();\n\tint m = plg2.size();\n\tfor(int i = 0; i < n; ++i){\n\t\tfor(int j = 0; j < m; ++j){\n\t\t\tif( intersected(plg1[i], plg1[(i+1)%n], plg2[j], plg2[(j+1)%m]) ){\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif( distance_ls_p(plg1[i], plg1[(i+1)%n], plg2[j]) < EPS ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif( distance_ls_p(plg2[j], plg2[(j+1)%m], plg1[i]) < EPS ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n\nbool orderbyreal(refpoint p1, refpoint p2){\n\treturn real(p1) < real(p2);\n}\n\n\nvector<point> convex(vector<point> plg){\n\tint n = plg.size();\n\tif( n <= 3 ){\n\t\treturn plg;\n\t}\n\n\tsort(plg.begin(), plg.end(), orderbyreal);\n\n\tvector<point> ret(2 * n);\n\tint k = 0;\n\n\tfor(int i = 0; i < n; ++i){\n\t\twhile( k >= 2 && cross( ret[k-1] - ret[k-2], plg[i] - ret[k-2] ) <= 0.0 ){\n\t\t\t--k;\n\t\t}\n\t\tret[k++] = plg[i];\n\t}\n\n\tint t = k + 1;\n\tfor(int i = n - 2; i >= 0; --i){\n\t\twhile( k >= t && cross( ret[k-1] - ret[k-2], plg[i] - ret[k-2] ) <= 0.0 ){\n\t\t\t--k;\n\t\t}\n\t\tret[k++] = plg[i];\n\t}\n\tret.resize(k - 1);\n\t\n\treturn ret;\n}\n\n\nint main(){\n\tint n, m;\n\tdouble x, y;\n\t\n\twhile( scanf(\"%d%d\", &n, &m), n != 0 ){\n\t\tvector<point> black, white;\n\t\tblack.reserve(n);\n\t\twhite.reserve(m);\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\tblack.push_back( point(x, y) );\n\t\t}\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\twhite.push_back( point(x, y) );\n\t\t}\n\n\n\t\tblack = convex(black);\n\t\twhite = convex(white);\n\n\t\tif( contact(black, white) ){\n\t\t\tputs(\"NO\");\n\t\t}\n\t\telse{\n\t\t\tputs(\"YES\");\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> point;\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-8\n#define DEB 0\n\nclass ten{\npublic:\n  point p;\n  int c;\n  ten(point q, int _c){\n    p=q; c=_c;\n  }\n};\n\nbool cmp(ten a, ten b){\n  if( abs(a.p.real()-b.p.real())<EPS ) return a.p.imag() < b.p.imag();\n  return a.p.real() < b.p.real();\n}\ndouble cross(const point& a, const point& b){\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nvector<ten> dd;\n\nint main(){\n  int n,m;\n  while(cin>>n>>m,n|m){\n    int v = n+m;\n    rep(i,n){\n      point tmp; cin>>tmp.real()>>tmp.imag();\n      dd.push_back(ten(tmp,0)); // write\n    }\n    REP(i,n,v){\n      point tmp; cin>>tmp.real()>>tmp.imag();\n      dd.push_back(ten(tmp,1)); // black\n    }\n    bool ok = false;\n    rep(i,v){\n      REP(j,i+1,v){\n        int wup=0, wdo=0;\n        int bup=0, bdo=0;\n        vector<ten> tmp;\n        rep(k,v)if( i!=k && j!=k ){\n          double d = cross(dd[i].p - dd[j].p, dd[k].p);\n          if( d>0.0 ){\n            if( dd[k].c ) bup++; else wup++;\n          }else if( d<0.0 ){\n            if( dd[k].c ) bdo++; else wdo++;\n          }else{\n            tmp.push_back(dd[k]);\n          }\n        }\n        if( wup*wdo!=0 || bup*bdo!=0 )continue;\n        if( wup*bup!=0 || wdo*bdo!=0 )continue;\n        \n        tmp.push_back(dd[i]);\n        tmp.push_back(dd[j]);\n\n#if DEB\n        printf(\"wup:%d , wdo:%d,  bup:%d  , bdo:%d\\n\",wup,wdo,bup,bdo);\n#endif\n        sort(tmp.begin(), tmp.end(), cmp);\n        /*\n        int tbup=0, tbdo=0, twup=0, twdo=0;\n        rep(k,tmp.size()){\n          if( wup ){\n            if( tmp[k].c ) tbdo++; else twup++; \n          }else if( wdo ){\n            if( tmp[k].c ) tbup++; else twdo++;\n          }else if( dup ){\n            if( tmp[k].c ) tbup++; else twdo++;\n          }else if( bdo ){\n            if( tmp[k].c ) tbdo++; else twup++;\n          }\n        }\n        wup += twup; wdo += twdo;\n        bup += tdup; bdo += tbdo;\n        \n        \n        rep(k,tmp.size()){\n          if( wup+wdo==bup+dwo )ok=true;\n          if( wup ){\n            if( tmp[k].c ) bup++; else bdo++;\n          }else if( wdo ){\n            if( tmp[k].c ) wdo++; else bup++;\n          }else if( bup ){\n            if( tmp[k].c ) wdo++; else bup++;\n          }else{\n            if( tmp[k].c ) wup++; else bdo++;\n          }\n        }\n          */\n        if( ok ) goto end;\n      }\n    }\n  end:\n    puts( ok ? \"YES\" : \"NO\" );\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define op(a,b) (conj(a)*(b)).imag()\n#define ip(a,b) (conj(a)*(b)).real()\nusing namespace std;\ntypedef complex<int> P;\nint sign(P p,P d,P *a,int n,int s){\n\tint r=0,o;\n\trep(i,n){\n\t\to=-op(d,a[i]-p);\n\t\tif(o!=0){\n\t\t\tif(r*o<0){\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tr=o>0?1:-1;\n\t\t}else if(ip(d,a[i]-p)*s<0)return 2;\n\t}\n\treturn r!=0?r>0?1:-1:0;\n}\nint main(){\n\tint n,m; while(cin>>n>>m,n){\n\t\tP b[n],w[m];\n\t\trep(i,n)cin>>b[i].real()>>b[i].imag();\n\t\trep(i,m)cin>>w[i].real()>>w[i].imag();\n\t\trep(i,n)rep(j,m){\n\t\t\tP p=b[i],d=w[j]-b[i];\n\t\t\tint sb=sign(p,d,b,n,-1),sw=sign(p,d,w,m,1);\n\t\t\tif(sb!=2&&sw!=2&&sb*sw<=0){\n\t\t\t\tcout<<\"YES\"<<endl; goto END;\n\t\t\t}\n\t\t}\n\t\tcout<<\"NO\"<<endl; END:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  int b, w;\n  while(cin>>b>>w && (b != 0 || w != 0)){\n    srand(time(NULL));\n    vector<double> x1(b), y1(b);\n    vector<double> x2(w), y2(w);\n    REP(i, b)cin>>x1[i]>>y1[i];\n    REP(i, w)cin>>x2[i]>>y2[i];\n    bool ans = false;\n    REP(time, 35000){\n      const double D = 1e6;\n      double t = (double)rand()/RAND_MAX * D * ((rand() % 2) ?  1 : -1);\n      double min_b = 1e30, max_b = -1e30;\n      double min_w = 1e30, max_w = -1e30;\n      REP(i, b){\n        double d = (y1[i] + t)/(x1[i] + 1000.0);\n        min_b = min(min_b, d);\n        max_b = max(max_b, d);\n      }\n      REP(i, w){\n        double d = (y2[i] + t)/(x2[i] + 1000.0);\n        min_w = min(min_w, d);\n        max_w = max(max_w, d);\n      }\n      if(min_w > max_b) ans = true;\n      if(min_b > max_w) ans = true;\n      if(ans) break;\n    }\n    if(ans) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res;\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps){\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d,  c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0,  1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n  int n = ps.size();\n  Polygon Q;\n  REP(i,n) {\n    Point A = ps[i], B = ps[(i+1)%n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n      Q.push_back(is_ll(l, m));\n  }\n  return Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n  for (Point q : ps) if (abs(q - p) < eps) return;\n  ps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n  g[from].push_back((Edge){from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n  int n = p.size(), m = s.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (isis_sp(s[i], p[j]))\n      vec.emplace_back(abs(s[i].a - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      add_edge(g, from, to, abs(p[from] - p[to]));\n    }\n  }\n  return g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n  int n = p.size(), m = c.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n      vec.emplace_back(arg(c[i].p - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      ld angle = vec[j+1].first - vec[j].first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n    if (vec.size() >= 2) {\n      int from = vec.back().second, to = vec.front().first;\n      ld angle = vec.front().first - vec.back().first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n  }\n  return g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n  int N = p.size();\n  polygon.clear();\n  REP(i,1024) REP(j,1024) seg2p[i][j].clear();\n  vector<vector<tuple<ld,int,bool>>> tup(N);\n  REP(i,s.size()) {\n    int a = -1, b = -1;\n    REP(j,N) if (abs(s[i].a - p[j]) < eps) a = j;\n    REP(j,N) if (abs(s[i].b - p[j]) < eps) b = j;\n    assert(a >= 0 && b >= 0);\n    tup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n    tup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n  }\n  REP(i,N) sort(ALL(tup[i]));\n  REP(i,N) {\n    REP(j,tup[i].size()) {\n      ld angle; int pos = j, from = i, to; bool flag;\n      tie(angle, to, flag) = tup[i][j];\n      if (flag) continue;\n      vector<int> ps;\n      while (!flag) {\n        ps.push_back(from);\n        get<2>(tup[from][pos]) = true;\n        seg2p[from][to].push_back(polygon.size());\n        seg2p[to][from].push_back(polygon.size());\n        angle += pi + eps;\n        if (angle > pi) angle -= 2 * pi;\n        auto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n        if (it == tup[to].end()) it = tup[to].begin();\n        from = to; tie(angle, to, flag) = *it;\n        pos = it - tup[from].begin();\n      }\n      polygon.push_back(ps);\n    }\n  }\n  Graph g(polygon.size());\n  REP(i,N) REP(j,i) {\n    if (seg2p[i][j].size() == 2) {\n      int from = seg2p[i][j][0], to = seg2p[i][j][1];\n      g[from].push_back((Edge){from, to});\n      g[to].push_back((Edge){to, from});\n    }\n  }\n  return g;\n}\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n  fprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n  Point v = l.b - l.a;\n  Line m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n  int n = p.size();\n  REP(i,n) draw_segment(Line(p[i], p[(i+1)%n]));\n}\n\nvoid draw_circle(Circle c) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nint main() {\n\tint N, M;\n\twhile ( cin >> N >> M, N || M ) {\n\t\tvector<Point> b, w;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tb.push_back( Point(x, y) );\n\t\t}\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tw.push_back( Point(x, y) );\n\t\t}\n\t\tsort(b.begin(), b.end());\n\t\tsort(w.begin(), w.end());\n\n\t\tbool ans = false;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < M; ++j) {\n\t\t\t\tif (b[i] != w[j]) {\n\t\t\t\t\tLine l(b[i], w[j]);\n\t\t\t\t\tint cntB = 0;\n\t\t\t\t\tvector<Point> onB;\n\t\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\t\tint c = ccw(l.a, l.b, b[k]);\n\t\t\t\t\t\tif (c == 1) {\n\t\t\t\t\t\t\t++cntB;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (c == 2 || c == -2 || c == 0) {\n\t\t\t\t\t\t\tonB.push_back(b[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint cntW = 0;\n\t\t\t\t\tvector<Point> onW;\n\t\t\t\t\tfor (int k = 0; k < M; ++k) {\n\t\t\t\t\t\tint c = ccw(l.a, l.b, w[k]);\n\t\t\t\t\t\tif (c == 1) {\n\t\t\t\t\t\t\t++cntW;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (c == 2 || c == -2 || c == 0) {\n\t\t\t\t\t\t\tonW.push_back(w[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ((cntB+onB.size() == N && cntW == 0) || (cntB == 0 && cntW+onW.size() == M)) {\n\t\t\t\t\t\tif (!((onW[0] < onB[0] && onB[0] < onW[onW.size()-1]) || (onW[0] < onB[onB.size()-1] && onB[onB.size()-1] < onW[onW.size()-1])\n\t\t\t\t\t\t\t|| (onB[0] < onW[0] && onW[0] < onB[onB.size()-1]) || (onB[0] < onW[onW.size()-1] && onW[onW.size()-1] < onB[onB.size()-1])) ) {\n\t\t\t\t\t\t\tans = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n/*\n\t\t\t\t\t\tbool f = true;\n\t\t\t\t\t\tfor (int i = 0; i < onB.size(); ++i) {\n\t\t\t\t\t\t\tfor (int j = 0; j < onB.size(); ++j) {\n\t\t\t\t\t\t\t\tfor (int k = 0; k < onW.size(); ++k) {\n\t\t\t\t\t\t\t\t\tif (i != j && ccw(onB[i], onB[j], onW[k]) == 0) {\n\t\t\t\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int i = 0; i < onW.size(); ++i) {\n\t\t\t\t\t\t\tfor (int j = 0; j < onW.size(); ++j) {\n\t\t\t\t\t\t\t\tfor (int k = 0; k < onB.size(); ++k) {\n\t\t\t\t\t\t\t\t\tif (i != j && ccw(onW[i], onW[j], onB[k]) == 0) {\n\t\t\t\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (f) {\n\t\t\t\t\t\t\tans = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n*/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <climits>\nusing namespace std;\n\n#define wh while\n#define FOR(i, n) for(int i = 0; i < n; i++)\n#define REP(i,n) for(int i = 1; i <= n; i++)\n#define sf scanf\n#define pf printf\n#define PB(x) push_back(x)\n#define MP(x, y) make_pair(x, y)\n#define clr(abc,z) memset(abc,z,sizeof(abc))\n\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> pii;\n\nconst double PI = acos(-1.0);\n\n//蟆?ァ貞コヲ霓ャ蛹紋クコ蠑ァ蠎ヲ\ndouble torad(double deg) {\n    return deg/180 * PI;\n}\n//邊セ蠎ヲ\nconst double eps = 1e-10;\ndouble dcmp(double x) {\n    if(fabs(x) < eps) return 0;\n    else return x < 0 ? -1 : 1;\n}\n\nstruct Point {\n    double x, y;\n    Point(double x=0, double y=0):x(x),y(y) { }\n};\ntypedef Point Vector;\nVector operator + (const Vector& A, const Vector& B) {\n    return Vector(A.x+B.x, A.y+B.y);\n}\nVector operator - (const Point& A, const Point& B) {\n    return Vector(A.x-B.x, A.y-B.y);\n}\nVector operator * (const Vector& A, double p) {\n    return Vector(A.x*p, A.y*p);\n}\n\n//霑吩ク?摎譏ッ荳?ウサ蛻怜渕遑?桃菴?double Dot(const Vector& A, const Vector& B) {\n    return A.x*B.x + A.y*B.y;\n}\ndouble Cross(const Vector& A, const Vector& B) {\n    return A.x*B.y - A.y*B.x;    //蟆アA蜥沓逧?ァッ\n}\nbool operator < (const Point& p1, const Point& p2) {\n    return p1.x < p2.x || (p1.x == p2.x && p1.y < p2.y);\n}\nbool operator == (const Point& p1, const Point& p2) {\n    return p1.x == p2.x && p1.y == p2.y;\n}\nvector<Point> ConvexHull(vector<Point> p) {//豎る?譌カ髓亥?蛹?    sort(p.begin(), p.end()); // 鬚?、?炊?悟唖髯、驥榊、咲せ\n    p.erase(unique(p.begin(), p.end()), p.end());\n\n    int n = p.size();\n    int m = 0;\n    vector<Point> ch(n+1);\n    for(int i = 0; i < n; i++) {\n        while(m > 1 && Cross(ch[m-1]-ch[m-2], p[i]-ch[m-2]) <= 0) m--;\n        ch[m++] = p[i];\n    }\n    int k = m;\n    for(int i = n-2; i >= 0; i--) {\n        while(m > k && Cross(ch[m-1]-ch[m-2], p[i]-ch[m-2]) <= 0) m--;\n        ch[m++] = p[i];\n    }\n    if(n > 1) m--;\n    ch.resize(m);\n    return ch;\n}\nPoint GetLineIntersection(const Point& P, const Vector& v, const Point& Q, const Vector& w) {\n    Vector u = P-Q;\n    double t = Cross(w, u) / Cross(v, w);\n    return P+v*t;\n}\n\nbool SegmentProperIntersection(const Point& a1, const Point& a2, const Point& b1, const Point& b2) {\n    double c1 = Cross(a2-a1,b1-a1), c2 = Cross(a2-a1,b2-a1),\n           c3 = Cross(b2-b1,a1-b1), c4=Cross(b2-b1,a2-b1);\n    return dcmp(c1)*dcmp(c2)<0 && dcmp(c3)*dcmp(c4)<0;\n}\n\nbool OnSegment(const Point& p, const Point& a1, const Point& a2) {\n    return dcmp(Cross(a1-p, a2-p)) == 0 && dcmp(Dot(a1-p, a2-p)) < 0;\n}\nint IsPointInPolygon(const Point& p, const vector<Point>& poly) {\n    int wn = 0;\n    int n = poly.size();\n    for(int i = 0; i < n; i++) {\n        const Point& p1 = poly[i];\n        const Point& p2 = poly[(i+1)%n];\n        if(p1 == p || p2 == p || OnSegment(p, p1, p2)) return -1; // 蝨ィ霎ケ逡御ク?        int k = dcmp(Cross(p2-p1, p-p1));\n        int d1 = dcmp(p1.y - p.y);\n        int d2 = dcmp(p2.y - p.y);\n        if(k > 0 && d1 <= 0 && d2 > 0) wn++;\n        if(k < 0 && d2 <= 0 && d1 > 0) wn--;\n    }\n    if (wn != 0) return 1; // 蜀?Κ\n    return 0; // 螟夜Κ\n}\nbool ConvexPolygonDisjoint(const vector<Point> ch1, const vector<Point> ch2) {\n    int c1 = ch1.size();\n    int c2 = ch2.size();\n    for(int i = 0; i < c1; i++)\n        if(IsPointInPolygon(ch1[i], ch2) != 0) return false; // 蜀?Κ謌冶セケ逡御ク?    for(int i = 0; i < c2; i++)\n        if(IsPointInPolygon(ch2[i], ch1) != 0) return false; // 蜀?Κ謌冶セケ逡御ク?    for(int i = 0; i < c1; i++)\n        for(int j = 0; j < c2; j++)\n            if(SegmentProperIntersection(ch1[i], ch1[(i+1)%c1], ch2[j], ch2[(j+1)%c2])) return false;\n    return true;\n}\nint n, m;\n\nint main() {\n    wh(sf(\"%d%d\", &n, &m) != EOF) {\n        if(!n && !m) break;\n        vector<Point> _x, _y;\n        _x.clear();\n        _y.clear();\n        FOR(i, n) {\n            int x, y;\n            sf(\"%d%d\", &x, &y);\n            _x.PB(Point((double)x, (double)y));\n        }\n        FOR(i, m) {\n            int x, y;\n            sf(\"%d%d\", &x, &y);\n            _y.PB(Point((double)x, (double)y));\n        }\n        _x = ConvexHull(_x);\n        _y = ConvexHull(_y);\n        if(ConvexPolygonDisjoint(_x, _y)) puts(\"YES\");\n        else puts(\"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define EPS 0.000001\ntypedef long double ld;\n\n//FILE *in = freopen(\"input.txt\", \"r\", stdin);\n\nstruct P {\n\tld x, y;\n\tP(ld x, ld y):x(x),y(y){}\n\tP(){}\n};\n\nP operator -(const P &a, const P &b) { return P(a.x-b.x, a.y-b.y); }\nbool operator <(const P &a, const P &b){ return make_pair(a.x, a.y) < make_pair(b.x, b.y); }\n\nld cross(const P &a, const P &b) { return a.x*b.y-a.y*b.x; }\nld dot(const P &a, const P &b) { return a.x*b.x+a.y*b.y; }\nld norm(const P &a) { return dot(a,a); }\nint ccw(P a, P b, P c) {\n\tb = b - a; c = c - a;\n\tif(cross(b,c) > EPS) return 1;\n\tif(cross(b,c) < EPS) return -1;\n\tif(dot(b,c) < 0) return 2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nstruct L:vector<P>{\n\tL(P a=P(0,0), P b=P(0,0)) {\n\t\tthis->push_back(a);\n\t\tthis->push_back(b);\n\t}\n};\n\nbool is_intersect_SS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0],s[1],t[1]) <= 0 &&\n\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\n\nvector<P> convex_hull(vector<P> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<P> ch(2*n);\n\tfor(int i = 0; i < n; ch[k++]=ps[i++])\n\t\twhile(k >= 2 && ccw(ch[k-2],ch[k-1],ps[i]) <= 0)--k;\n\tfor(int i = n-2, t = k+1; i >= 0; ch[k++]=ps[i--])\n\t\twhile(k>=t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0)--k;\n\tif(k>2)ch.resize(k-1);\n\treturn ch;\n}\n\nint n, m;\nvector<P> black;\nvector<P> white;\n\nvoid input() {\n\tblack.clear();\n\twhite.clear();\n\trep(i, n) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tblack.push_back(P(x,y));\n\t}\n\trep(i, m) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\twhite.push_back(P(x,y));\n\t}\n}\n\nvoid process() {\n\tblack = convex_hull(black);\n\twhite = convex_hull(white);\n\twhite.push_back(white[0]);\n\n\t// Check LP\n\trep(i,black.size()) {\n\t\tL x(black[i], P(black[i].x+1,black[i].y+20001));\n\t\tint cnt = 0;\n\t\trep(j,white.size()-1) {\n\t\t\tL y(white[j], white[j+1]);\n\t\t\tcnt += is_intersect_SS(x,y);\n\t\t}\n\t\tif(cnt%2 == 1) {\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tblack.push_back(black[0]);\n\n\t// Check cross LL\n\trep(i,black.size()-1) {\n\t\tL x(black[i],black[i+1]);\n\t\trep(j,white.size()-1){\n\t\t\tL y(white[j], white[j+1]);\n\t\t\tif(is_intersect_SS(x,y)) {\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"YES\\n\");\n}\n\nint main() {\n\twhile(true) {\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(!n) break;\n\t\tinput();\n\t\tprocess();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ------ lib ------ //\n\n#include <cstdio>\n#include <string>\n\n#pragma warning(disable: 4996)\n\nusing namespace std;\nstring ID = \"1\";\n\nFILE *in = freopen((\"./in\" + ID + \".txt\").c_str(), \"r\", stdin);\nFILE *out = freopen((\"./out\" + ID + \".txt\").c_str(), \"w\", stdout);\n\n// ------ end ------ //\n\n#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\nlong double EPS = (long double)1e-7;\nstruct Point { long double px, py; };\nPoint r1[100], r2[100]; int n, m;\nvector<pair<Point, int>>vec, vec2;\ninline bool solve(Point a1, Point a2) {\n\tif (a1.px > a2.px)swap(a1, a2);\n\tif (a1.px == a2.px) {\n\t\tint colour = 0; bool r[3] = { false,false,false };\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tif (r[1] == true && r[2] == true)return false;\n\t\t\tif (colour == 0) {\n\t\t\t\tif (vec2[i].first.px < a1.px) { colour = 3 - vec2[i].second; }\n\t\t\t\telse if (vec2[i].first.px == a1.px) { r[vec2[i].second] = true; }\n\t\t\t\telse if (vec2[i].first.px > a1.px) { colour = vec2[i].second; }\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (colour != 3 - vec2[i].second && vec2[i].first.px < a1.px) { return false; }\n\t\t\t\telse if (vec2[i].first.px == a1.px) { r[vec2[i].second] = true; }\n\t\t\t\telse if (colour != vec2[i].second && vec2[i].first.px > a1.px) { return false; }\n\t\t\t}\n\t\t}\n\t\tif (r[1] == true && r[2] == true)return false;\n\t\treturn true;\n\t}\n\telse {\n\t\tlong double KT = (a2.py - a1.py) / (a2.px - a1.px);\n\t\tlong double YY = a1.py - a1.px*KT;\n\t\tint colour = 0; bool r[3] = { false,false,false };\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tif (r[1] == true && r[2] == true)return false;\n\t\t\tlong double height = YY + KT*vec2[i].first.px;\n\t\t\tif (colour == 0) {\n\t\t\t\tif (vec2[i].first.py < height) { colour = 3 - vec2[i].second; }\n\t\t\t\telse if (vec2[i].first.py == height) { r[vec2[i].second] = true; }\n\t\t\t\telse if (vec2[i].first.py > height) { colour = vec2[i].second; }\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (colour != 3 - vec2[i].second && vec2[i].first.py < height) { return false; }\n\t\t\t\telse if (vec2[i].first.py == height) { r[vec2[i].second] = true; }\n\t\t\t\telse if (colour != vec2[i].second && vec2[i].first.py > height) { return false; }\n\t\t\t}\n\t\t}\n\t\tif (r[1] == true && r[2] == true)return false;\n\t\treturn true;\n\t}\n}\nint main() {\n\twhile (true) {\n\t\tvec.clear(); vec2.clear(); cin >> n >> m; if (n == 0 && m == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> r1[i].px >> r1[i].py; vec2.push_back(make_pair(r1[i], 1));\n\t\t\tfor (long double j = -1.0l; j <= 1.0l; j += 1.0l) {\n\t\t\t\tfor (long double k = -1.0l; k <= 1.0l; k += 1.0l) {\n\t\t\t\t\tif (fabs(j) + fabs(k) > 1.9l)continue;\n\t\t\t\t\tvec.push_back(make_pair(Point{ r1[i].px + j*EPS,r1[i].py + k*EPS }, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> r2[i].px >> r2[i].py; vec2.push_back(make_pair(r2[i], 2));\n\t\t\tfor (long double j = -1.0l; j <= 1.0l; j += 1.0l) {\n\t\t\t\tfor (long double k = -1.0l; k <= 1.0l; k += 1.0l) {\n\t\t\t\t\tif (fabs(j) + fabs(k) > 1.9l)continue;\n\t\t\t\t\tvec.push_back(make_pair(Point{ r2[i].px + j*EPS,r2[i].py + k*EPS }, 2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans = false;\n\t\tfor (int i = 0; i < vec.size(); i++) {\n\t\t\tfor (int j = i + 1; j < vec.size(); j++) {\n\t\t\t\tif (fabs(vec[i].first.px - vec[j].first.px) + fabs(vec[i].first.py - vec[j].first.py) < EPS * 6)continue;\n\t\t\t\tbool p1 = solve(vec[i].first, vec[j].first);\n\t\t\t\tif (p1 == true) {\n\t\t\t\t\tans = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == true)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\n#include <complex>\ntypedef complex<double> P;\n#define EQ(x, y) (abs((x)-(y)) < EPS)\ndouble dot(P a, P b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\ndouble cross(P a, P b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\nint is_point_on_line(P a, P b, P c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nint is_intersected_l_ls(P a1, P a2, P b1, P b2) {\n    if ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < -EPS )\n        return true;\n    return is_point_on_line(a1, a2, b1) || is_point_on_line(a1, a2, b2);\n}\nint is_point_on_ls(P a, P b, P c) {\n    // |a-c| + |c-b| <= |a-b| then true\n    return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n\n\ntypedef vector<P> vp;\n\nbool can_separate(int edge1,int edge2,int parent_o,int parent_t,vp &ours,vp &theirs){\n\tif(parent_o!=-1){\n\t\tif(!is_intersected_l_ls(ours[edge1],ours[edge2],ours[parent_o],theirs[parent_t])){\n\t\t\treturn false;\n\t\t}\n\t}\n\tif(parent_o!=-1){\n\t\tREP(i,ours.size()){\n\t\t\tif(i!=parent_o&&i!=edge1&&i!=edge2){\n\t\t\t\tif(is_intersected_l_ls(ours[edge1],ours[edge2],ours[i],ours[parent_o])){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,theirs.size()){\n\t\tif(i!=parent_t){\n\t\t\tif(is_intersected_l_ls(ours[edge1],ours[edge2],theirs[i],theirs[parent_t])){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n\t\tvp black,white;\n\t\tREP(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tblack.push_back(P(x,y));\n\t\t}\n\t\tREP(i,m){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\twhite.push_back(P(x,y));\n\t\t}\n\n\t\tbool ok=false;\n\n\t\tif(n==1&&m==1){\n\t\t\tok=true;\n\t\t\tgoto show;\n\t\t}else if(n==2&&m==1){\n\t\t\tok=!is_point_on_ls(black[0],black[1],white[0]);\n\t\t\tgoto show;\n\t\t}else if(n==1&&m==2){\n\t\t\tok=!is_point_on_ls(white[0],white[1],black[0]);\n\t\t\tgoto show;\n\t\t}\n\n\t\tbool all_on_line=true;\n\t\tbool scrumbled=false;\n\t\tREP(i,n+m){\n\t\t\tP ip=(i<n?black[i]:white[i-n]);\n\t\t\tREP(j,n+m){\n\t\t\t\tP jp=(j<n?black[j]:white[j-n]);\n\t\t\t\tREP(k,n+m){\n\t\t\t\t\tP kp=(k<n?black[k]:white[k-n]);\n\t\t\t\t\tif(!is_point_on_line(ip,jp,kp)){\n\t\t\t\t\t\tall_on_line=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(is_point_on_ls(ip,jp,kp)){\n\t\t\t\t\t\tif((i<n)==(j<n)&&(i<n)!=(k<n)){\n\t\t\t\t\t\t\tscrumbled=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(all_on_line){\n\t\t\tok=!scrumbled;\n\t\t\tgoto show;\n\t\t}\n\n\t\tREP(i1,n){\n\t\t\tFOR(i2,i1+1,n){\n\t\t\t\tint parent_o=-1;\n\t\t\t\tREP(j,n){\n\t\t\t\t\tif(j!=i1&&j!=i2){\n\t\t\t\t\t\tparent_o=j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(can_separate(i1,i2,parent_o,0,black,white)){\n\t\t\t\t\tok=true;\n\t\t\t\t\tgoto show;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i1,m){\n\t\t\tFOR(i2,i1+1,m){\n\t\t\t\tint parent_o=-1;\n\t\t\t\tREP(j,m){\n\t\t\t\t\tif(j!=i1&&j!=i2){\n\t\t\t\t\t\tparent_o=j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(can_separate(i1,i2,parent_o,0,white,black)){\n\t\t\t\t\tok=true;\n\t\t\t\t\tgoto show;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nshow:\n\t\tcout<<(ok?\"YES\":\"NO\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\ntypedef complex<int> Vector;\n\n//Verified PKU 2812\ndouble cross(const Vector &v1, const Vector &v2) {\n    return (v1.real()*v2.imag()) - (v1.imag()*v2.real());\n}\ndouble dot(const Vector &v1, const Vector &v2) {\n    return v1.real()*v2.real() + v1.imag()*v2.imag();\n}\n\n//Verified AOJ 0012\n//Verified PKU 3348\nint ccw(const Vector &p1, const Vector &p2, const Vector &p3) {\n    const Vector &v1 = p2-p1;\n    const Vector &v2 = p3-p1;\n    double op = cross(v1, v2);\n    if(op > 0) return 1; //ccw\n    if(op < 0) return -1; //cw\n    if(dot(v1, v2) < 0) return 2; //p3-p1-p2\n    if(norm(v1) < norm(v2)) return -2; //p1-p2-p3\n    return 0;\n}\n\nbool on(const Vector &p11, const Vector &p12, const Vector &p) {\n    return ccw(p11, p, p12) == -2;\n}\n\nbool intersect(const Vector &p11, const Vector &p12, const Vector &p21, const Vector &p22) {\n    int c1 = ccw(p11, p12, p21);\n    int c2 = ccw(p11, p12, p22);\n    int c3 = ccw(p21, p22, p11);\n    int c4 = ccw(p21, p22, p12);\n    return (c1*c2 <= 0 && c3*c4 <= 0) || (on(p11, p12, p21) || on(p11, p12, p22) || on(p21, p22, p11) || on(p21, p22, p12));\n}\n\n\nbool cmp(const Vector &p1, const Vector &p2) {\n    return p1.real() < p2.real();\n}\n\nvector<Vector> convex_hull(const vector<Vector> &points) {\n    int N = points.size();\n    vector<Vector> v = points;\n    sort(v.begin(), v.end(), cmp);\n    vector<Vector> hull(2*N);\n    int pos = 0;\n    for(int i = 0; i < N; ++i) {\n        while(pos >= 2 && ccw(hull[pos-2], hull[pos-1], v[i]) <= 0) --pos;\n        hull[pos++] = v[i];\n    }\n    int lim = pos;\n    for(int i = N-2; i >= 0; --i) {\n        while(pos >= lim+1 && ccw(hull[pos-2], hull[pos-1], v[i]) <= 0) --pos;\n        hull[pos++] = v[i];\n    }\n    hull.erase(hull.begin()+pos, hull.end());\n    return hull;\n}\n\nint main() {\n    assert(on(Vector(100, 100), Vector(500, 500), Vector(300, 300)));\n    ios::sync_with_stdio(0);\n    while(true) {\n        int N, M;\n        cin >> N >> M;\n        if(!N && !M) break;\n\n        vector<Vector> bs, ws;\n        for(int i = 0; i < N; ++i) {\n            double x, y;\n            cin >> x >> y;\n            bs.push_back(Vector(x, y));\n        }\n        for(int i = 0; i < M; ++i) {\n            double x, y;\n            cin >> x >> y;\n            ws.push_back(Vector(x, y));\n        }\n\n        vector<Vector> bs_convex = convex_hull(bs);\n        vector<Vector> ws_convex = convex_hull(ws);\n\n        //check intersection\n        for(int i = 0; i < bs_convex.size(); ++i) {\n            const Vector &p1 = bs_convex[i];\n            const Vector &p2 = i+1==bs_convex.size() ? bs_convex[0] : bs_convex[i+1];\n            for(int j = 0; j+1 < ws_convex.size(); ++j) {\n                const Vector &p3 = ws_convex[i];\n                const Vector &p4 = j+1==ws_convex.size() ? ws_convex[0] : ws_convex[j+1];\n                if(intersect(p1, p2, p3, p4)) {\n                    goto fail;\n                }\n            }\n        }\n\n        //check inclusion\n        {\n            if(bs_convex.size() >= 4) {\n                bool ok = false;\n                int dir = 0;\n                for(int i = 0; i+1 < bs_convex.size(); ++i) {\n                    const Vector &p1 = bs_convex[i];\n                    const Vector &p2 = i+1==bs_convex.size() ? bs_convex[0] : bs_convex[i+1];\n                    int tmp = ccw(p1, p2, ws_convex[0]);\n                    if(dir*tmp < 0) {\n                        ok = true;\n                        break;\n                    }\n                    dir = tmp;\n                }\n                if(!ok) goto fail;\n            }\n\n            if(ws_convex.size() >= 4) {\n                bool ok = false;\n                int dir = 0;\n                for(int i = 0; i+1 < ws_convex.size(); ++i) {\n                    const Vector &p1 = ws_convex[i];\n                    const Vector &p2 = i+1==ws_convex.size() ? ws_convex[0] : ws_convex[i+1];\n                    int tmp = ccw(p1, p2, bs_convex[0]);\n                    if(dir*tmp < 0) {\n                        goto succ;\n                    }\n                    dir = tmp;\n                }\n                if(!ok) goto fail;\n            }\n        }\n        \nsucc:\n        cout << \"YES\" << endl;\n        continue;\nfail:\n        cout << \"NO\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct point{\n    int x;\n    int y;\n};\n\nconstexpr double e = numeric_limits<double>::epsilon();\n\nbool isOnLine(point sp, point gp, point p){\n    double l1 = (gp.x - sp.x)*(gp.x - sp.x) + (gp.y - sp.y)*(gp.y - sp.y);\n    double l2 = (p.x - sp.x)*(p.x - sp.x) + (p.y - sp.y)*(p.y - sp.y);\n    double c = (gp.x - sp.x)*(p.x - sp.x) + (gp.y - sp.y)*(p.y - sp.y);\n    return c >= 0 && c*c == l1*l2 && l1 >= l2;\n}\n\ndouble sinLinePoint(point sp, point gp, point p){\n    return sin(atan2(p.y - sp.y, p.x - sp.x) - atan2(gp.y - sp.y, gp.x - sp.x));\n}\n\nbool isLeft(point sp, point gp, point p){\n    if(sinLinePoint(sp, gp, p) >= 0){\n        return true;\n    }else{\n        return false;\n    }\n}\n\nbool isCrossed(point a, point b, point c, point d){\n    double ta=(c.x-d.x)*(a.y-c.y)+(c.y-d.y)*(c.x-a.x);\n    double tb=(c.x-d.x)*(b.y-c.y)+(c.y-d.y)*(c.x-b.x);\n    double tc=(a.x-b.x)*(c.y-a.y)+(a.y-b.y)*(a.x-c.x);\n    double td=(a.x-b.x)*(d.y-a.y)+(a.y-b.y)*(a.x-d.x);\n    \n    return (tc * td < 0 && ta * tb < 0) || isOnLine(a,b,c) || isOnLine(a,b,d) || isOnLine(c,d,a) || isOnLine(c,d,b);\n}\n\nvector<point> unite(vector<point> v, int x, int y){\n    int num = v.size();\n    point p = {x,y};\n    if(num <= 1){\n        v.push_back(p);\n        return v;\n    }\n    if(num == 2){\n        if(isLeft(v[0], v[1], p)){\n            v.push_back(p);\n        }else{\n            v.insert(v.begin()+1, p);\n        }\n        return v;\n    }\n    bool isInShape = true;\n    bool isActive = false;\n    int si=0,gi=0;\n    for(int i=0;i<num; i++){\n        if(isOnLine(v[i], v[(i+1)%num], p)){\n            isInShape = true;\n            break;\n        }\n        if(!isLeft(v[i], v[(i+1)%num], p) || fabs(sinLinePoint(v[i], v[(i+1)%num], p)) < e){\n            isInShape = false;\n            if(!isActive){\n                isActive = true;\n                si = i;\n            }\n        }else{\n            if(isActive){\n                isActive = false;\n                gi = i;\n            }\n        }\n    }\n    if(isInShape){\n        return v;\n    }else{\n        if((gi-si+num)%num==1){\n            if(gi-si==1){\n                v.insert(v.begin()+gi,p);\n                return v;\n            }else{\n                v.push_back(p);\n                return v;\n            }\n        }\n        if(gi>si){\n            v.erase(v.begin()+si+1, v.begin()+gi);\n            v.insert(v.begin()+si+1,p);\n        }else{\n            v.erase(v.begin()+si+1,v.end());\n            v.erase(v.begin(),v.begin()+gi);\n            v.push_back(p);\n        }\n        return v;\n    }\n}\n\nint main(void){\n    int m,n,x,y;\n    while(1){\n        cin>>n>>m;\n        if(n==0&&m==0)return 0;\n        vector<point> white;\n        vector<point> black;\n        for(int i=0;i<n;i++){\n            cin>>x>>y;\n            white=unite(white,x,y);\n        }\n        for(int i=0;i<m;i++){\n            cin>>x>>y;\n            black=unite(black,x,y);\n        }\n        \n        n=white.size();\n        m=black.size();\n        bool answer=true;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(isCrossed(white[i],white[(i+1)%n],black[j],black[(j+1)%m])){\n                    answer = false;\n                }\n            }\n        }\n        if(answer){\n            bool blackB=true, whiteB=true;\n            for(int i=0;i<n;i++){\n                for(int j=0;j<m;j++){\n                    double temp = sinLinePoint(white[i],white[(i+1)%n],black[j]);\n                    if(!isLeft(white[i],white[(i+1)%n],black[j]) && fabs(temp) > e){\n                        blackB = false;\n                    }\n                    temp = sinLinePoint(black[j],black[(j+1)%m],white[i]);\n                    if(!isLeft(black[j],black[(j+1)%m],white[i]) && fabs(temp) > e){\n                        whiteB = false;\n                    }\n                }\n            }\n            if(blackB ^ whiteB){\n                answer = false;\n            }\n        }\n        cout<<(answer?\"YES\":\"NO\")<<endl;\n        \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL() {}\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\n// assumption : 3 <= ps.size()\nG convex_hull(vector<P> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nbool intersectSP(const L &s, const P &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; // triangle inequality\n}\n\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\n\n#define curr(PP, i) PP[i]\n#define next(PP, i) PP[(i+1)%PP.size()]\nenum { OUT, ON, IN };\nint contains(const G& g, const P& p) {\n\tbool in = false;\n\tfor (int i = 0; i < g.size(); ++i) {\n\t\tP a = curr(g, i) - p, b = next(g, i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M;\n\twhile (cin >> N >> M)\n\t{\n\t\tif (N == 0) return 0;\n\n\t\tvector<P> BP(N);\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tBP[i] = P(x, y);\n\t\t}\n\n\t\tvector<P> WP(M);\n\t\trep(i, 0, M)\n\t\t{\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tWP[i] = P(x, y);\n\t\t}\n\n\t\tif (N == 1 && M == 1)\n\t\t{\n\t\t\tcout << \"YES\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (N == 2 && M == 1)\n\t\t{\n\t\t\tif (intersectSP(L(BP[0], BP[1]), WP[0]))\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\telse\n\t\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse if (N == 1 && M == 2)\n\t\t{\n\t\t\tif (intersectSP(L(WP[0], WP[1]), BP[0]))\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\telse\n\t\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse if (N == 2 && M == 2)\n\t\t{\n\t\t\tif (intersectSS(L(BP[0], BP[1]), L(WP[0], WP[1])))\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\telse\n\t\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbool ok = true;\n\t\t\tif (3 <= N)\n\t\t\t{\n\t\t\t\tG B = convex_hull(BP);\n\t\t\t\trep(i, 0, M)\n\t\t\t\t{\n\t\t\t\t\tif (contains(B, WP[i]) != OUT) ok = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (3 <= M)\n\t\t\t{\n\t\t\t\tG W = convex_hull(WP);\n\t\t\t\trep(i, 0, N)\n\t\t\t\t{\n\t\t\t\t\tif (contains(W, BP[i]) != OUT) ok = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ok)\n\t\t\t\tcout << \"YES\" << endl;\n\t\t\telse\n\t\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <ctime>\n#define INF 1000000007\n#define MP make_pair\nconst int NUM = 100010;\nconst double eps = 1e-10, pi = acos(-1.0);\nusing namespace std;\ntypedef pair <int, int> P;\ntypedef long long LL;\ntypedef unsigned long long uLL;\ninline int sgn(LL x)\n{\n\tif(x < 0)return -1;\n\treturn x > 0 ? 1 : 0;\n}\nclass Point\n{\npublic:\n\tLL x, y;\n\tPoint(LL _x = 0, LL _y = 0): x(_x), y(_y) {}\n\tPoint operator - (const Point b)const {return Point(x - b.x, y - b.y);}\n\tLL operator * (const Point b) const {return x * b.x + y * b.y;}\n\tLL operator ^ (const Point b)const {return x * b.y - y * b.x;}\n};\nvector<Point> black, white;\nint n, m;\nbool _cmp(Point a, Point b)\n{\n\tif(a.x != b.x) return a.x < b.x;\n\treturn a.y < b.y;\n}\n\nvector<Point> get_convex_hull(vector<Point> p, int pnum)\n{\n\tint i, limit = 1, cnt = 0;\n\tvector<Point> res(2 * pnum + 5);\n\tsort(p.begin(), p.end(), _cmp);\n\tfor(i = 0; i < pnum; i++)\n\t{\n\t\twhile(cnt > limit && sgn((res[cnt - 1] - res[cnt - 2]) ^ (p[i] - res[cnt - 1])) <= 0) cnt--;\n\t\tres[cnt++] = p[i];\n\t}\n\tlimit = cnt;\n\tfor(i = pnum - 2; i >= 0; i--)\n\t{\n\t\twhile(cnt > limit && sgn((res[cnt - 1] - res[cnt - 2]) ^ (p[i] - res[cnt - 1])) <= 0) cnt--;\n\t\tres[cnt++] = p[i];\n\t}\n\tres.resize(cnt);\n\treturn res;\n}\nbool onSeg(Point a, Point s, Point t)\n{\n\treturn sgn((a - s) ^ (a - t)) == 0 && sgn((a - s) * (a - t)) <= 0;\n}\n\nbool seg_seg_inter(Point a, Point b, Point s, Point t)\n{\n//\tLL c1 = (b - a) ^ (s - a), c2 = (b - a) ^ (t - a);\n//\tLL c3 = (t - s) ^ (a - s), c4 = (t - s) ^ (b - s);\n//\treturn (sgn(c1) * sgn(c2)) < 0 && (sgn(c3) * sgn(c4)) < 0;\n\treturn\n\t\tsgn((a - t) ^ (s - t)) * sgn((b - t) ^ (s - t)) < 0 &&\n\t\tsgn((s - b) ^ (a - b)) * sgn((t - b) ^ (a - b)) < 0;\n}\n\nLL area(Point a, vector<Point> p, int pnum)\n{\n\tLL res = 0;\n\tfor(int i = 0; i < pnum; i++)\n\t\tres += abs((p[i + 1] - p[i]) ^ (a - p[i]));\n\treturn abs(res);\n}\n\nbool convex_intersection()\n{\n\tint i, j;\n\tif(n == 0 || m == 0 || (n == 1 && m == 1))\n\t\treturn false;\n\tfor(i = 0; i < n; i++)\n\t\tfor(j = 0; j < m; j++)\n\t\t{\n\t\t\tif(seg_seg_inter(black[i], black[i + 1], white[j], white[j + 1])) return true;\n\t\t\tif(onSeg(black[i], white[j], white[j + 1])) return true;\n\t\t\tif(onSeg(white[j], black[i], black[i + 1])) return true;\n\t\t}\n\tif(n == 1)\n\t{\n\t\tfor(i = 0; i < m; i++)\n\t\t\tif(onSeg(black[0], white[i], white[i + 1]))\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\tif(m == 1)\n\t{\n\t\tfor(i = 0; i < n; i++)\n\t\t\tif(onSeg(white[0], black[i], black[i + 1]))\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n//\tcout << \"......\\n\";\n\tLL s = area(black[0], black, n);\n\t//cout << s << endl;\n\tif(s > 0)\n\t{\n\t\tfor(i = 0; i < m; i++)\n\t\t\tif(s == area(white[i], black, n))\n\t\t\t\treturn true;\n\t}\n\ts = area(white[0], white, m);\n\tif(s > 0)\n\t{\n\t\tfor(i = 0; i < n; i++)\n\t\t\tif(s == area(black[i], white, m))\n\t\t\t\treturn true;\n\t}\n\treturn false;\n}\nint main()\n{\n#ifdef ACM_TEST\n\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"in.txt\", \"w\", stdout);\n#endif\n\tint i, j;\n\tint x, y;\n\twhile(~scanf(\"%d%d\", &n, &m) && n + m)\n\t{\n\t\tblack.clear();\n\t\twhite.clear();\n\t\tfor(i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tblack.push_back(Point(x, y));\n\t\t}\n\t\tfor(i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\twhite.push_back(Point(x, y));\n\t\t}\n\t\tblack = get_convex_hull(black, n);\n\t\tn = black.size();\n\t\twhite = get_convex_hull(white, m);\n\t\tm = white.size();\n\t\tif(n > 1)n--;\n\t\telse black.push_back(black[0]);\n\t\tif(m > 1)m--;\n\t\telse white.push_back(white[0]);\n//\t\tcout << n << ' ' << m << endl;\n//\t\tfor(i = 0; i < n; i++)\n//\t\t\tprintf(\" (%lld, %lld) \", black[i].x, black[i].y);\n//\t\tputchar('\\n');\n//\t\tfor(i = 0; i < m; i++)\n//\t\t\tprintf(\" (%lld, %lld) \", white[i].x, white[i].y);\n//\t\tputchar('\\n');\n\t\tif(convex_intersection())\n\t\t\tprintf(\"NO\\n\");\n\t\telse\n\t\t\tprintf(\"YES\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-10\n#define INF 1000000\n \nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n    Point operator *(const double d)const{\n        return Point(x*d,y*d);\n    }\n    bool operator <(const Point &p)const{\n        if(x==p.x) return y<p.y;\n        return x<p.x;\n    }\n    double norm(){\n        return x*x+y*y;\n    }\n\tbool input(){\n\t\tif(cin>>x>>y) return true;\n\t\treturn false;\n\t}\n};\n \nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n\tbool input(){\n\t\tif(a.input() && b.input()) return true;\n\t\treturn false;\n\t}\n};\n \nstruct Circle{\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point _c,double _r){\n        c=_c; r=_r;\n    }\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n \nint ccw(Point a,Point b,Point c){ //a,b,c,縺ッ蜈ィ縺ヲ逡ー縺ェ繧?\tPoint v1 = b-a;\n\tPoint v2 = c-a;\n    if(cross(v1,v2)>EPS) return +1; //a->b->c 縺悟渚譎りィ亥屓繧?    if(cross(v1,v2)<-EPS) return -1; //a->b->c 縺梧凾險亥屓繧?\tif(dot(v1,v2)<-EPS) return +2; //c縺径-b繧医ｊ蠕後ｍ c<-a->b\n\tif(v1.norm()<v2.norm()) return -2; //c縺径-b繧医ｊ蜑?a->b->c\n    return 0; //c縺径-b荳?a->c->b\n}\n \nbool intersect_ss(Line l,Line m){\n    return ccw(l.a,l.b,m.a)*ccw(l.a,l.b,m.b)<=0 && ccw(m.a,m.b,l.a)*ccw(m.a,m.b,l.b)<=0;\n}\n \nbool crosspoint_ll(Line l,Line m,Point &p){\n    Point a1,a2,b1,b2;\n    a1 = l.b-l.a; a2 = m.b-m.a;\n    b1 = m.a-l.a; b2 = l.a-m.b;\n    double s1,s2;\n    s1 = cross(a1,b1)/2; s2 = cross(a1,b2)/2;\n    if(s1+s2<EPS) return false; //蟷ウ陦?    p = Point(m.a.x+a2.x*s1/(s1+s2),m.a.y+a2.y*s1/(s1+s2));\n    return true;\n}\n \nint crosspoint_ss(Line l,Line m,Point &p){\n    if(intersect_ss(l,m)==false) return 0; //莠、蟾ョ縺励※縺?↑縺?    if(crosspoint_ll(l,m,p)==true) return 1;\n\treturn -1; //莠、轤ケ縺檎┌髯仙?(蟷ウ陦後°縺、莠、蟾ョ)\n}\n \nint crosspoint_cc(Circle c1,Circle c2,Point &p1,Point &p2){\n    double d,a,t;\n    d = sqrt((c2.c-c1.c).norm());\n\tif(abs(c1.c.x-c2.c.x)<EPS && abs(c1.c.y-c2.c.y)<EPS && abs(c1.r-c2.r)<EPS)\n\t\treturn -1; //2縺、縺ョ蜀?′驥阪↑縺」縺ヲ縺?ｋ\n    if(d<abs(c1.r-c2.r) || c1.r+c2.r<d) return 0; //縺ゥ縺。繧峨°縺悟?蛹?＠縺ヲ縺?ｋ\n    a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    t = atan2(c2.c.y-c1.c.y,c2.c.x-c1.c.x);\n    p1 = Point(c1.c.x+c1.r*cos(t+a),c1.c.y+c1.r*sin(t+a));\n    p2 = Point(c1.c.x+c1.r*cos(t-a),c1.c.y+c1.r*sin(t-a));\n    if(abs(p1.x-p2.x)<EPS && abs(p1.y-p2.y)<EPS) return 1; //莠、轤ケ縺?縺、\n    return 2; //莠、轤ケ縺?縺、\n}\n\nint contains(Polygon g,Point p){\n\tLine l = Line(p,Point(INF,p.y));\n\tint cnt = 0, n = g.size();\n\tfor(int i=0;i<n;i++){\n\t\tPoint a = g[i]-p;\n\t\tPoint b = g[(i+1)%n]-p;\n\t\tif(ccw(g[i],g[(i+1)%n],p)==0) return 1; //邱壼?荳?\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<=EPS && EPS<b.y && cross(a,b)>EPS) cnt++;\n\t}\n\tif((cnt&1)==1) return 2; //蜀?桁縺励※縺?ｋ\n\treturn 0; //蜀?桁縺励※縺?↑縺?}\n\nPolygon andrewScan(Polygon s){\n\tif(s.size()<=2) return s;\n\tsort(s.begin(),s.end());\n\tPolygon g;\n\tfor(int i=0;i<s.size();i++){\n\t\tfor(int n=g.size(); n>=2 && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\tint upper_n = g.size();\n\tfor(int i=s.size()-2;i>=0;i--){\n\t\tfor(int n=g.size(); n>upper_n && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\treverse(g.begin(),g.end());\n\tg.pop_back();\n\treturn g;\n}\n\nint main(){\n\tint N,M;\n\tPolygon b,w,gb,gw;\n\twhile(cin>>N>>M,N||M){\n\t\tb.resize(N); w.resize(M);\n\t\tfor(int i=0;i<N;i++) b[i].input();\n\t\tfor(int i=0;i<M;i++) w[i].input();\n\t\tgb = andrewScan(b); gw = andrewScan(w);\n\t\tbool ans = true;\n\t\tfor(int i=0;i<gb.size() && ans;i++){\n\t\t\tfor(int j=0;j<gw.size() && ans;j++){\n\t\t\t\tLine l(gb[i],gb[(i+1)%gb.size()]), m(gw[i],gw[(i+1)%gw.size()]);\n\t\t\t\tif(intersect_ss(l,m)==true) ans = false;\n\t\t\t}\n\t\t}\n\t\tif(gb.size()>=2){\n\t\t\tfor(int i=0;i<M && ans;i++){\n\t\t\t\tif(contains(gb,w[i])!=0) ans = false;\n\t\t\t}\n\t\t}\n\t\tif(gw.size()>=2){\n\t\t\tfor(int i=0;i<N && ans;i++){\n\t\t\t\tif(contains(gw,b[i])!=0) ans = false;\n\t\t\t}\n\t\t}\n\t\tif(ans==true) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconstexpr double EPS = 1e-9;\n\nstruct point {\n    double x, y;\n    point(double x_ = 0.0, double y_ = 0.0):x(x_), y(y_) {}\n    point(const point& p):x(p.x), y(p.y) {}\n\n    point operator+ (const point& p) const {\n        return point(x + p.x, y + p.y);\n    }\n\n    point operator- (const point& p) const {\n        return point(x - p.x, y - p.y);\n    }\n\n    point operator* (double s) const {\n        return point(x * s, y * s);\n    }\n\n    point operator* (const point& p) const {\n        return point(x * p.x - y * p.y, x * p.y + y * p.x);\n    }\n\n    point operator/ (double s) const {\n        return point(x / s, y / s);\n    }\n\n    bool operator< (const point& p) const {\n        return x + EPS < p.x || (abs(x - p.x) < EPS && y + EPS < p.y);\n    }\n\n    bool operator== (const point& p) const {\n        return abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n    }\n};\n\ndouble norm(const point& p) {\n    return p.x * p.x + p.y * p.y;\n}\n\ndouble dot(const point& a, const point& b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const point& a, const point& b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nstruct segment {\n    point a, b;\n    segment(const point& a_, const point& b_):a(a_), b(b_){}\n};\n\ntypedef vector<point> polygon;\n\nint ccw(const point& a, point b, point c) {\n    b = b - a;\n    c = c - a;\n    const double tmp = cross(b, c);\n    if(tmp > EPS) return 1; // ccw\n    if(tmp < -EPS) return -1; // cw\n    if(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n    if(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n    return 0; //a, c, b 順で一直線上\n}\n\nbool intersect(const segment& s, const segment& t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n        && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool intersect(const segment& s, const point& p) {\n    return ccw(s.a, s.b, p) == 0;\n}\n\npolygon convex_hull(vector<point> points) {\n    const int n = points.size();\n    if(n <= 3) return points;\n\n    sort(points.begin(), points.end());\n    int k = 0;\n    polygon res;\n    res.resize(2 * n);\n    for(int i = 0; i < n; res[k++] = points[i++]) {\n        while(k >= 2 && ccw(res[k - 2], res[k - 1], points[i]) <= 0) --k;\n    }\n\n    const int t = k + 1;\n    for(int i = n - 2; i >= 0; res[k++] = points[i--]) {\n        while(k >= t && ccw(res[k - 2], res[k - 1], points[i]) <= 0) --k;\n    }\n\n    res.resize(k - 1);\n    return res;\n}\n\nbool intersect(const polygon& P, const point& p) {\n    const int n = P.size();\n    bool res = false;\n    for(int i = 0; i < n; ++i) {\n        point v1 = P[i] - p, v2 = P[(i + 1) % n] - p;\n        if(v1.y > v2.y) swap(v1, v2);\n        if(v1.y < EPS && EPS < v2.y && cross(v1, v2) > EPS) res = !res;\n        if(abs(cross(v1, v2)) < EPS && dot(v1, v2) < EPS) return true;\n    }\n\n    return res;\n}\n\nbool intersect(const polygon& P, const segment& s) {\n    const int n = P.size();\n    if(intersect(P, s.a) || intersect(P, s.b)) return true;\n\n    for(int i = 0; i < n; ++i) {\n        if(intersect(segment(P[i], P[(i + 1) % n]), s)) return true;\n    }\n\n    return false;\n}\n\nbool intersect(const polygon &a, const polygon &b) {\n    const int n = b.size();\n    for(int i = 0; i < n; ++i) {\n        if(intersect(a, segment(b[i], b[(i + 1) % n]))) return true;\n    }\n\n    for(const auto &p : a) {\n        if(intersect(b, p)) return true;\n    }\n\n    return false;\n}\n\nvector<point> input_points(int n) {\n    vector<point> res;\n    res.reserve(n);\n\n    for(int i = 0; i < n; ++i) {\n        double x, y;\n        cin >> x >> y;\n        res.emplace_back(x, y);\n    }\n\n    return res;\n}\n\nbool check(const vector<point> &a, const vector<point> &b) {\n\treturn !intersect(convex_hull(a), convex_hull(b));\n}\n\nint main() {\n    for(int n, m; cin >> n >> m && n;) {\n        const auto black_points = input_points(n);\n        const auto white_points = input_points(m);\n        cout << (check(black_points, white_points) ? \"YES\" : \"NO\") << endl;\n    }\n\n    return EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n  \nusing namespace std;\n  \n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n  \nstruct Point{\n    double x,y;\n  \n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n  \n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n    Point operator / (const double &k)const{ return Point(x/k,y/k); }\n    bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n  \ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\n  \nistream &operator >> (istream &is,Point &p){\n    return is >> p.x >> p.y;\n}\n  \n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n  \nint ccw(Point p0,Point p1,Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a,b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n  \nstruct Segment{\n    Point s,t;\n    Segment(){}\n    Segment(Point s,Point t) : s(s),t(t) {}\n};\n  \nbool isIntersectSP(const Segment &s,const Point &p){\n    return equal(ccw(s.s,s.t,p),0);\n}\n  \nbool isIntersectSS(const Segment &a,const Segment &b){\n    Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0\n\t&& ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n  \n#define prev(G,i) (G[(i-1+G.size())%G.size()])\n#define curr(G,i) (G[i%G.size()])\n#define next(G,i) (G[(i+1)%G.size()])\ntypedef vector<Point> Polygon;\n  \nbool check(const Polygon &pg,const Point &p){\n    int N = pg.size();\n    bool in = false;\n    for(int i = 0 ; i < N ; i++){\n\tPoint a = curr(pg,i)-p, b = next(pg,i)-p;\n\tif(a.y > b.y) swap(a,b);\n\tif(a.y <= 0 && 0 < b.y && cross(a,b) > 0) in = !in;\n\tif(cross(a,b) == 0 && dot(a,b) <= 0) return true;\n    }\n    return in;\n}\n \nbool sortY(Point p1,Point p2){\n    if(p1.y != p2.y){\n\treturn (p1.y - p2.y < -EPS);\n    }else{ \n\treturn (p1.x - p2.x < -EPS);\n    }\n}\n \nPolygon convex_hull(Polygon &ps){\n    int N = ps.size(),j = 0;\n    Polygon pg(N*2);\n    sort(ps.begin(),ps.end(),sortY);\n    for(int i = 0 ; i < N ; i++,j++){\n\twhile(j >= 2 && ccw(pg[j-2],pg[j-1],ps[i]) == -1){\n\t    j--;\n\t}\n\tpg[j] = ps[i];\n    }\n    int k = j+1;\n    for(int i = N-2 ; i >= 0 ; i--,j++){\n\twhile(j >= k && ccw(pg[j-2],pg[j-1],ps[i]) == -1){\n\t    j--;\n\t}\n\tpg[j] = ps[i];\n    }\n    pg.resize(j-1);\n    return pg;\n}\n  \nbool solve(Polygon &bp,Polygon &wp){\n    int N = bp.size(), M = wp.size();\n    if(N == 1 && M == 1){\n\treturn !(equal(bp[0].x,wp[0].x) && equal(bp[0].y,wp[0].y));\n    }\n    if(N == 2 && M == 1){\n\tSegment s(bp[0],bp[1]);\n\treturn !isIntersectSP(s,wp[0]);\n    }\n    if(N == 1 && M == 2){\n\tSegment s(wp[0],wp[1]);\n\treturn !isIntersectSP(s,bp[0]);\n    }\n    if(N == 2 && M == 2){\n\tSegment s1(bp[0],bp[1]),s2(wp[0],wp[1]);\n\treturn !isIntersectSS(s1,s2);\n    }\n    bp = convex_hull(bp);\n    wp = convex_hull(wp);\n    if(N == 1 && M >= 3){\n\treturn !check(wp,bp[0]);\n    }\n    if(N >= 3 && M == 1){\n\treturn !check(bp,wp[0]);\n    }\n    if(N == 2 && M >= 3){\n\tSegment s1(bp[0],bp[1]);\n\tif(check(wp,bp[0]) || check(wp,bp[1])){\n\t    return false;\n\t}\n\tfor(int i = 0 ; i < M ; i++){\n\t    for(int j = i+1 ; j < M ; j++){\n\t\tSegment s2(wp[i],wp[j]);\n\t\tif(isIntersectSS(s1,s2)){\n\t\t    return false;\n\t\t}\n\t    }\n\t}\n\treturn true;\n    }\n    if(N >= 3 && M == 2){\n\tSegment s1(wp[0],wp[1]);\n\tif(check(bp,wp[0]) || check(bp,wp[1])){\n\t    return false;\n\t}\n\tfor(int i = 0 ; i < N ; i++){\n\t    for(int j = i+1 ; j < N ; j++){\n\t\tSegment s2(bp[i],bp[j]);\n\t\tif(isIntersectSS(s1,s2)){\n\t\t    return false;\n\t\t}\n\t    }\n\t}\n\treturn true;\n    }\n    for(int i = 0 ; i < N ; i++){\n\tif(check(wp,bp[i])){\n\t    return false;\n\t}\n    }\n    for(int i = 0 ; i < M ; i++){\n\tif(check(bp,wp[i])){\n\t    return false;\n\t}\n    }\n    return true;\n}\n  \nint main(){\n    int N,M;\n    while(cin >> N >> M,N){\n\tPolygon bp(N),wp(M);\n\tfor(int i = 0 ; i < N ; i++){\n\t    cin >> bp[i];\n\t}\n\tfor(int i = 0 ; i < M ; i++){\n\t    cin >> wp[i];\n\t}\n\tcout << (solve(bp,wp) ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <double,double> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nbool McCullochPitts(const vector<P>& white,const vector<P>& black){\n  vector<double> weight(3);\n  double alpha = 0.01;\n\n  bool res = false;\n  weight[0] = 0.0;\n  weight[1] = 0.0;\n  weight[2] = 0.0;\n\n  for(int round = 0; round < 2800000; round++){\n    bool isok = true;\n    for(int i = 0; i < white.size(); i++){\n      double o = (weight[0] + weight[1] * white[i].first + weight[2] * white[i].second);\n      //white == 0\n      //black == 1\n      if(o > 0){\n        weight[0] -= alpha;\n        weight[1] -= alpha * white[i].first;\n        weight[2] -= alpha * white[i].second;\n        isok = false;\n      }\n    }\n    for(int i = 0;i < black.size(); i++){\n      double o = (weight[0] + weight[1] * black[i].first + weight[2] * black[i].second);\n      //white == 0\n      //black == 1\n      if(o <= 0){\n        weight[0] += alpha;\n        weight[1] += alpha * black[i].first;\n        weight[2] += alpha * black[i].second;\n        isok = false;\n      }\n    }\n    if(isok){\n      res = true;\n      break;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n,m;\n  while(~scanf(\"%d %d\",&n,&m)){\n    if(n == 0 && m == 0) break;\n\n    vector<P> white;\n    for(int i = 0; i < n; i++){\n      double x,y;\n      scanf(\"%lf %lf\",&x,&y);\n      white.push_back(P(x,y));\n    }\n    vector<P> black;\n    for(int i = 0; i < m; i++){\n      double x,y;\n      scanf(\"%lf %lf\",&x,&y);\n      black.push_back(P(x,y));\n    }\n\n    printf(\"%s\\n\",McCullochPitts(white,black) ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iomanip>\n\n#define REP(i,n) for(i=0; i < (n); i++)\n#define REPONE(i, n) for(i=1; i <= (n); i++)\n#define LOOP(n) for(int loopCount=1; loopCount <= (n); loopCount++)\n#define ITER(c) __typeof((c).begin())\n#define EACH(c,it) for(ITER(c) it =(c).begin(); it!=(c).end(); it++)\n#define SZ(c) ((int) (c).size())\n#define ALL(c) c.begin(), c.end()\n#define SUM(c) accumulate(ALL(c), 0)\n#define EXIST(c,v) (find(ALL(c), (v)) != (c).end())\n#define PB push_back\n#define MP make_pair\n\nusing namespace std;\nstatic const double EPS = 1e-8;\nstatic const double PI = 3.141592653589793238462643383279;\n\ntypedef complex<double> point;\n\ntemplate<typename T>\nint sig2(T x){\n    if(abs(x)<EPS) return 0;\n    if(x>0) return 1;\n    return -1;\n}\n\ndouble det(point p1, point p2, point q){\n    return p2.real()*q.imag()+p1.real()*p2.imag()+q.real()*p1.imag()\n            -p2.real()*p1.imag()-q.real()*p2.imag()-q.imag()*p1.real();\n}\n/*\nint main(){\n    int i,j,k,n,m;\n    double x,y,bxma,byma,bxmi,bymi,wxma,wyma,wxmi,wymi;\n    bool yes;\n    while(scanf(\"%d%d\",&n,&m)){\n        if(n==0 && m==0) break;\n        bxma=byma=wxma=wyma=-1e99;\n        bxmi=bymi=wxmi=wymi=1e99;\n        yes=false;\n        vector<point> bs(n), ws(m);\n        REP(i,n){\n            scanf(\"%lf%lf\",&x,&y);\n            bs[i]=point(x,y);\n            bxma=max(bxma, x);\n            byma=max(byma, y);\n            bxmi=min(bxmi, x);\n            bymi=min(bymi, y);\n        }\n        REP(i,m){\n            scanf(\"%lf%lf\",&x,&y);\n            ws[i]=point(x,y);\n            wxma=max(wxma, x);\n            wyma=max(wyma, y);\n            wxmi=min(wxmi, x);\n            wymi=min(wymi, y);\n        }\n        if(bxma<wxmi||bxmi>wxma||byma<wymi||bymi>wyma){\n            printf(\"YES\\n\");\n            continue;\n        }\n        if(n==1 && m==1){\n            printf(\"YES\\n\");\n            continue;\n        }\n        int w=0, b;\n        REP(i,n)for(j=i+1;j<n;j++){\n            w = 0;\n            REP(k,m) w+=sig2(det(bs[i],bs[j],ws[k]));\n            if(abs(w)<m)break;\n            REP(k,n)if(sig2(det(bs[i],bs[j],bs[k]))==sig2(w))break;\n            if(k==n){\n                yes = true;\n                goto end;\n            }\n        }\n        swap(n,m);\n        swap(bs,ws);\n        REP(i,n)for(j=i+1;j<n;j++){\n            w = 0;\n            REP(k,m) w+=sig2(det(bs[i],bs[j],ws[k]));\n            if(abs(w)<m)break;\n            REP(k,n)if(sig2(det(bs[i],bs[j],bs[k]))==sig2(w))break;\n            if(k==n){\n                yes = true;\n                goto end;\n            }\n        }\n        REP(i,n)REP(j,m){\n            w = b = 0;\n            REP(k,m) w+=sig2(det(bs[i],ws[j],ws[k]));\n            if(abs(w)<m-1)break;\n            REP(k,n) b+=sig2(det(bs[i],ws[j],bs[k]));\n            if(abs(b)<n-1)break;\n            if(w*b<0){\n                yes = true;\n                goto end;\n            }\n        }\n        end:;\n        if(yes)printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n    return 0;\n}\n*/\n\n#define N 20000\n\nint main(){\n    int i,j,n,m;\n    double bma,bmi,wma,wmi,ang=PI/N,tmp;\n    static double bxs[100], wxs[100], bys[100], wys[100];\n    while(scanf(\"%d%d\",&n,&m)){\n        if(n==0 && m==0) break;\n        REP(i,n)scanf(\"%lf%lf\",bxs+i,bys+i);\n        REP(i,m)scanf(\"%lf%lf\",wxs+i,wys+i);\n        REP(i,N){\n            bma=wma=-1e99;\n            bmi=wmi=1e99;\n            REP(j,n){\n                tmp = cos(ang*i)*bxs[j]-sin(ang*i)*bys[j];\n                if(tmp<bmi)bmi=tmp;\n                if(tmp>bma)bma=tmp;\n            }\n            REP(j,m){\n                tmp = cos(ang*i)*wxs[j]-sin(ang*i)*wys[j];\n                if(tmp<wmi)wmi=tmp;\n                if(tmp>wma)wma=tmp;\n            }\n            if(bma < wmi || wma < bmi) break;\n        }\n        if(i==N)printf(\"NO\\n\");\n        else printf(\"YES\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n\ntypedef double D;\ntypedef complex<D> P;\n#define X real()\n#define Y imag()\nconst D eps=1e-8;\nconst D inf=1e12;\nnamespace std{\n  bool operator<(const P& a,const P& b){\n    return a.X==b.X?a.Y<b.Y:a.X<b.X;\n  }\n}\nbool cmp_x(const P& a,const P& b){ return a.X==b.X?a.Y<b.Y:a.X<b.X; }\nD cross(P a,P b){ return (conj(a)*b).Y; }\nD dot(P a,P b){ return (conj(a)*b).X; }\n\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\n\nint ccw(P a,P b,P c) {\n  b=b-a;c=c-a;\n  if(cross(b,c)>0) return +1;       // counter clockwise\n  if(cross(b,c)<0) return -1;       // clockwise\n  if(dot(b,c)<0)   return +2;       // c--a--b on line\n  if(norm(b)<norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nvector<P> convex_hull(vector<P>& ps){\n  sort(ps.begin(),ps.end(),cmp_x);\n  int n=ps.size();\n  int k=0;\n  vector<P> qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0)k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0)k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nbool judge(P p,const vector<P>& poly){\n  int sz=poly.size();\n  if(sz==0)return true;\n  bool ok=false;\n  rep(i,sz){\n    int c=ccw(poly[i],p,poly[(i+1)%sz]);\n    if(c==-2)return false;\n    if(c!=-1)ok=true;\n  }\n  return ok;\n}\n\nbool intersectSS(L s,L t){\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0&&ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\n\nint main(){\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(n==0)break;\n    vector<P> a,b;\n    rep(i,n){\n      int x,y;\n      cin>>x>>y;\n      a.push_back(P(x,y));\n    }\n    rep(i,m){\n      int x,y;\n      cin>>x>>y;\n      b.push_back(P(x,y));\n    }\n    vector<P> pa;\n    if(a.size()>=2)pa=convex_hull(a);\n    vector<P> pb;\n    if(b.size()>=2)pb=convex_hull(b);\n    bool ok=true;\n    rep(i,n){\n      if(!judge(a[i],pb))ok=false;\n    }\n    rep(i,m){\n      if(!judge(b[i],pa))ok=false;\n    }\n    rep(i,n)rep(j,i){\n      int sz=pb.size();\n      rep(k,pb.size()){\n        if(intersectSS(L(pb[k],pb[(k+1)%sz]),L(a[i],a[j])))ok=false;\n      }\n    }\n    rep(i,m)rep(j,i){\n      int sz=pa.size();\n      rep(k,pa.size()){\n        if(intersectSS(L(pa[k],pa[(k+1)%sz]),L(b[i],b[j])))ok=false;\n      }\n    }\n    if(ok)cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-10)\n#define eq(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\ndouble norm(Vector v) { return v.x*v.x + v.y*v.y; }\ndouble abs(Vector v) { return sqrt(norm(v)); }\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nbool isOrthogonal(Vector a, Vector b) {\n  return eq(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isParallel(Vector a, Vector b) {\n  return eq(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n  return isParallel(a1 - a2, b1 - b2);\n}\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\ndouble getDistance(Point a, Point b) { return abs(a - b); }\ndouble getAngle(Point a, Point b, Point c) {\n  Vector v = b - a, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha) * 180 / M_PI;\n  return min(theta, 360 - theta);\n}\n\nstruct Segment {\n  Point p1, p2;\n  Segment(Point p1 = Point(), Point p2 = Point()):p1(p1), p2(p2){}\n};\ntypedef Segment Line;\n\nbool isOrthogonal(Segment s1, Segment s2) {\n  return eq(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isParallel(Segment s1, Segment s2) {\n  return eq(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p) {\n  return p + (project(s, p) - p) * 2.0;\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) {\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\ndouble getDistance(Segment s1, Segment s2) {\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPoint getCrossPointLL(Line l1, Line l2) {\n  Vector v1 = l1.p2 - l1.p1, v2 = l2.p2 - l2.p1;\n  double d = cross(v2, v1);\n  if(abs(d) < EPS) return l2.p1;\n  return l1.p1 + v1 * cross(v2, l2.p2 - l1.p1) * (1.0 / d);\n}\nLine getPerpendicularBisector(Point p1, Point p2) {\n  Point c = (p1 + p2) / 2.0;\n  Point q = Point(c.x + (p1.y - p2.y), c.y + (p2.x - p1.x));\n  return Line(c, q);\n}\n\nstruct Circle {\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0):c(c), r(r){}\n};\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n  // assert(intersect(c, l));\n  Vector pr = project(l, c.c);\n  Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n  double base = sqrt(c.r*c.r - norm(pr - c.c));\n  return make_pair(pr + e * base, pr - e * base);\n}\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n  // assert(intersect(c1, c2));\n  double d = abs(c1.c - c2.c);\n  double a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2*c1.r*d));\n  double t = arg(c2.c - c1.c);\n  return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\ntypedef vector<Point> Polygon;\n\ndouble getArea(Polygon p) {\n  double ret = 0.0;\n  for(int i = 0; i < (int)p.size(); i++) {\n    ret += cross(p[i], p[(i+1)%p.size()]);\n  }\n  return abs(ret) / 2.0;\n}\n\n#define IN_POLYGON  2\n#define ON_POLYGON  1\n#define OUT_POLYGON 0\nint contains(Polygon g, Point p) {\n  int n = g.size();\n  bool x = false;\n  for(int i = 0; i < n; i++) {\n    Point a = g[i] - p, b = g[(i+1) % n] - p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON_POLYGON;\n    if(a.y > b.y) swap(a, b);\n    if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n  }\n  return (x ? IN_POLYGON : OUT_POLYGON);\n}\n\nPolygon convexHull(Polygon ps) {\n  int N = ps.size(), j = 0;\n  Polygon pg(N*2);\n\n  if(N < 3) return ps;\n\n  sort(ps.begin(), ps.end(), [](Point p1, Point p2) -> bool {\n      return p1.y != p2.y ? lt(p1.y, p2.y) : lt(p1.x, p2.x); });\n  for(int i = 0; i < N; i++, j++) {\n    while(j >= 2 && ccw(pg[j-2], pg[j-1], ps[i]) == -1) j--;\n    pg[j] = ps[i];\n  }\n  int k = j+1;\n  for(int i = N-2; i >= 0; i--, j++) {\n    while(j >= k && ccw(pg[j-2], pg[j-1], ps[i]) == -1) j--;\n    pg[j] = ps[i];\n  }\n  pg.resize(j-1);\n  return pg;\n}\n\nPolygon convexCut(Polygon s, Line l) {\n  Polygon t;\n  for(int i = 0; i < (int)s.size(); i++) {\n    Point a = s[i], b = s[(i+1)%s.size()];\n    if(ccw(l.p1, l.p2, a) != -1) t.push_back(a);\n    if(ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0) {\n      t.push_back(getCrossPointLL(Line(a, b), l));\n    }\n  }\n  return t;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n, m;\n  while(cin >> n >> m, n || m) {\n    Polygon s(n), t(m);\n    rep(i, n) cin >> s[i].x >> s[i].y;\n    rep(i, m) cin >> t[i].x >> t[i].y;\n\n    if(n < 2 && m < 2) {\n      puts(\"YES\"); continue;\n    }\n    if(n + m <= 3) {\n      if(n == 2 && ccw(s[0], s[1], t[0]) == ON_SEGMENT ||\n\t m == 2 && ccw(t[0], t[1], t[0]) == ON_SEGMENT) {\n\tputs(\"NO\"); continue;\n      }\n      puts(\"YES\"); continue;\n    }\n    if(n == 2 && m == 2) {\n      if(intersect(s[0], s[1], t[0], t[1])) {\n\tputs(\"NO\"); continue;\n      }\n      puts(\"YES\"); continue;\n    }\n\n    auto S = convexHull(s);\n    auto T = convexHull(t);\n    bool flag = true;\n    rep(i, 2) {\n      if(s.size() <= 2) continue;\n      rep(j, t.size()) {\n\tif(contains(S, t[j]) != 0) {\n\t  flag = false;\n\t  break;\n\t}\n      }\n      swap(S, T);\n      swap(s, t);\n    }\n    cout << (flag ? \"YES\" : \"NO\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\n\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n \n// Check Funcs //\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\nbool intersectLS(const L &l, const L &s) {return cross(l[1]-l[0], s[0]-l[0])*cross(l[1]-l[0], s[1]-l[0]) < EPS;}\nbool intersectLP(const L &l, const P &p) {return abs(cross(l[1]-p, l[0]-p)) < EPS;}\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n \n// Where is Point in Polygon? //\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const polygon& P, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < P.size(); ++i) {\n\t\tpoint a = curr(P,i) - p, b = next(P,i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n\t}\n\treturn in ? IN : OUT;\n}\n// Area of Polygon //\ndouble area2(const polygon& P) {\n\tdouble A = 0;\n\tfor (int i = 0; i < P.size(); ++i)A += cross(curr(P, i), next(P, i));\n\treturn A;\n}\n// Totsuhou! Andrew's Monotone Chain //\n \nvector<point> convex_hull(vector<point> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\nP reflection(const L &l, const P &p) {return p + 2.0 * (projection(l, p) - p);}\n \ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n \nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n \nvector<P> C_cp(C a,C b){\n\tvector<P> ret;\n\tdouble L = abs(a.p-b.p);\n \n\t/* anma dekitenai */\n\tif(\tL-a.r-b.r > EPS || (abs(a.p-b.p)<EPS && fabs(a.r-b.r)<EPS) || \n\t\tabs(a.p-b.p) < abs(a.r-b.r)\n\t)return ret;\n \n\tdouble theta = atan2(b.p.imag()-a.p.imag(),b.p.real()-a.p.real());\n\tdouble c = (L*L+a.r*a.r-b.r*b.r)/(2*L*a.r);\n\tret.push_back(\n\t\tP(a.p.real()+a.r*cos(theta+acos(c)),\n\t\t  a.p.imag()+a.r*sin(theta+acos(c)))\n\t);\n\tif(fabs(L-a.r-b.r) > EPS)\n\t\tret.push_back(\n\t\t\tP(a.p.real()+a.r*cos(theta-acos(c)),\n\t\t\t  a.p.imag()+a.r*sin(theta-acos(c)))\n\t\t);\n\treturn ret;\n}\n \n \nP getPedal(L l, P p){\n\tdouble A;\n\tif(abs(l[1].real()-l[0].real()) < EPS){\n\t\treturn P(l[1].real(),p.imag()); // important\n\t}else{\n\t\tA = (l[1].imag()-l[0].imag())/(l[1].real()-l[0].real());\n\t}\n\tdouble a = -A , b = 1 , c = A*l[0].real() - l[0].imag();\n\tdouble t = (a*p.real() + b*p.imag() + c)/(a*a+b*b);\n\treturn p-t * P(a,b);\n}\n \nvector<P> crosspointCL(const L l, const C c){\n\tvector<P> ret;\n\tP p = getPedal(l,c.p);\n\tif(\tabs(p-c.p) > c.r+EPS)return ret;\n\tP e = P((l[1]-l[0])/abs(l[1]-l[0]));\n\tdouble S = sqrt(c.r*c.r-abs(p-c.p)*abs(p-c.p));\n\tret.push_back(p+S*e);\n\tret.push_back(p-S*e);\n\treturn ret;\n}\n \nP getCircumcenter(P a,P b,P c){\n\tdouble A1 = 2 * ( b.real() - a.real() );\n\tdouble B1 = 2 * ( b.imag() - a.imag() );\n\tdouble C1 = pow(a.real(),2)-pow(b.real(),2) + pow(a.imag(),2)-pow(b.imag(),2);\n\tdouble A2 = 2 * ( c.real() - a.real() );\n\tdouble B2 = 2 * ( c.imag() - a.imag() );\n\tdouble C2 = pow(a.real(),2)-pow(c.real(),2) + pow(a.imag(),2)-pow(c.imag(),2);\n\tdouble X = (B1 * C2 - B2 * C1) / (A1 * B2 - A2 * B1);\n\tdouble Y = (C1 * A2 - C2 * A1) / (A1 * B2 - A2 * B1);\n\treturn P(X,Y);\n}\n \ndouble AreaOfPolygon(vector<P> p){\n\tdouble S = 0 ; \n\tp.push_back(p[0]);\n\t/*　多角形の面積公式 (反時計回りの場合) */\n\tfor(int i = 0 ; i < p.size()-1 ; i++){\n\t\tS += (p[i].real() - p[i+1].real()) * (p[i].imag()+p[i+1].imag());\n\t}\n\tS /= 2.0;\n\treturn S;\n}\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m && n){\n\t\tvector<P> p;\n\t\tfor(int i = 0 ; i < n+m ; i++){\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tp.push_back(P(x,y));\n\t\t}\n\t\tvector<L> l;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < m ; j++){\n\t\t\t\tl.push_back( L(p[i],p[n+j]) );\n\t\t\t\tl.push_back( L(p[i],p[n+j]+P(0,EPS)) );\n\t\t\t\tl.push_back( L(p[i],p[n+j]+P(0,-EPS)) );\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < l.size() ; i++){\n\t\t\tint uw = 0 , ub = 0 , ew = 0 , eb = 0;\n\t\t\tfor(int j = 0 ; j < n+m ; j++){\n\t\t\t\tdouble v = cross(l[i][1]-l[i][0],p[j]-l[i][0]);\t\t\t\t\n\t\t\t\tif( v > 0 ){\n\t\t\t\t\tif( j < n ) uw++;\n\t\t\t\t\telse ub++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( uw == n && ub == 0 || uw == 0 && ub == m ){\n\t\t\t\tcout << \"YES\" << endl;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tcout << \"NO\" << endl;\n\t\texit:;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <string>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cassert>\n\n#define ATHFILE(f) freopen(f \".in\", \"r\", stdin), freopen(f \".my\", \"w\", stdout)\n#define DEBUGT(t) if (_t == t) _asm int 3\ntypedef long long LL;\ntypedef long double LD;\ninline int RD() { int x; scanf(\"%d\", &x); return x; }\ninline char RDA() { char ch; while ((ch = getchar()) && !isalpha(ch)); return ch; }\n#define Rush for (int tests = RD(), _t = 1; _t <= tests; ++_t)\n#define ZMV(x, v) memset((x), (v), sizeof(x))\n#define ZM(x) memset((x), 0, sizeof(x))\n#define SZ(v) (int)(v.size())\n#define ALL(v) v.begin(), v.end()\nconst int maxint = 0x7f7f7f7f;\nconst int mod = 1000000007;\nconst double eps = 1e-8, pi = acos(-1.0);\n\nusing namespace std;\n\nstruct point_t {\n\tdouble x, y;\n\tpoint_t() { }\n\tpoint_t(double tx, double ty) : x(tx), y(ty) { }\n\tpoint_t operator-(const point_t &r) const { return point_t(x - r.x, y - r.y); }\n\tpoint_t operator+(const point_t &r) const { return point_t(x + r.x, y + r.y); }\n\tpoint_t operator*(const double r) const { return point_t(x * r, y * r); }\n\tpoint_t operator/(const double r) const { return point_t(x / r, y / r); }\n\tpoint_t rot90() const { return point_t(-y, x); }\n\tdouble l() const { return sqrt(x * x + y * y); }\n\tvoid read() { scanf(\"%lf%lf\", &x, &y); }\n};\n\nint dblcmp(double x) {\n\treturn (x < -eps ? -1 : x > eps);\n}\n\ndouble dist(point_t p1, point_t p2) {\n\treturn sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\ndouble cross(point_t p1, point_t p2) {\n\treturn p1.x * p2.y - p2.x * p1.y;\n}\n\ndouble dot(point_t p1, point_t p2) {\n\treturn p1.x * p2.x + p1.y * p2.y;\n}\n\nbool cmp(const point_t p1, const point_t p2) {\n\treturn dblcmp(p1.y - p2.y) == 0 ? p1.x < p2.x : p1.y < p2.y;\n}\n\nbool onseg(point_t p, point_t s1, point_t s2) {\n\tif (dblcmp(cross(p - s1, p - s2)) != 0) return false;\n\treturn dblcmp(dot(s1 - p, s2 - p)) <= 0;\n}\n\nconst int maxn = 101;\nint graham(point_t *p, int n) {\n\tif (n <= 2) return n;\n\tsort(p + 1, p + 1 + n, cmp);\n\tint top; static point_t sk[maxn];\n\ttop = 2, sk[1] = p[1], sk[2] = p[2];\n\tfor (int i = 3; i <= n; ++i) {\n\t\twhile (top >= 2 && dblcmp(cross(p[i] - sk[top - 1], sk[top] - sk[top - 1])) >= 0) --top;\n\t\tsk[++top] = p[i];\n\t}\n\tint ttop = top;\n\tfor (int i = n - 1; i >= 1; --i) {\n\t\twhile (top > ttop && dblcmp(cross(p[i] - sk[top - 1], sk[top] - sk[top - 1])) >= 0) --top;\n\t\tsk[++top] = p[i];\n\t}\n\t--top;\n\tfor (int i = 1; i <= top; ++i) p[i] = sk[i];\n\treturn top;\n}\n\nint n, m;\npoint_t a[maxn], b[maxn];\n\nbool inside(point_t p, point_t *convex, int n) {\n\tbool hasN = false, hasP = false;\n\tconvex[0] = convex[n];\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint sgn = dblcmp(cross(p - convex[i - 1], convex[i] - convex[i - 1]));\n\t\tif (sgn == 1) hasP = true;\n\t\telse if (sgn == -1) hasN = true;\n\t\telse {\n\t\t\tif (onseg(p, convex[i - 1], convex[i])) return true;\n\t\t}\n\t}\n\tif (hasN && hasP) return false;\n\tif (!hasN && !hasP) return false;\n\treturn true;\n}\n\nint testSS(point_t a, point_t b, point_t c, point_t d) {\n\tif (dblcmp(max(a.x, b.x) - min(c.x, d.x)) < 0) return 0;\n\tif (dblcmp(max(c.x, d.x) - min(a.x, b.x)) < 0) return 0;\n\tif (dblcmp(max(a.y, b.y) - min(c.y, d.y)) < 0) return 0;\n\tif (dblcmp(max(c.y, d.y) - min(a.y, b.y)) < 0) return 0;\n\tint d1 = dblcmp(cross(c - a, b - a));\n\tint d2 = dblcmp(cross(d - a, b - a));\n\tint d3 = dblcmp(cross(a - c, d - c));\n\tint d4 = dblcmp(cross(b - c, d - c));\n\tif ((d1 * d2 < 0) && (d3 * d4 < 0)) return 1;\n\tif ((d1 * d2 <= 0 && d3 * d4 == 0) || (d1 * d2 == 0 && d3 * d4 <= 0)) return -1;\n\treturn 0;\n}\n\nint main() {\n\twhile (scanf(\"%d%d\", &n, &m) != EOF) {\n\t\tif (n + m == 0) break;\n\t\tfor (int i = 1; i <= n; ++i) a[i].read();\n\t\tfor (int i = 1; i <= m; ++i) b[i].read();\n\t\tn = graham(a, n);\n\t\tm = graham(b, m);\n\t\tbool ok = true;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif (inside(a[i], b, m)) ok = false;\n\t\t}\n\t\tfor (int i = 1; i <= m; ++i) {\n\t\t\tif (inside(b[i], a, n)) ok = false;\n\t\t}\n\t\ta[0] = a[n]; b[0] = b[m];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t\tif (testSS(a[i], a[i + 1], b[j], b[j + 1]) != 0) ok = false;\n\t\t\t}\n\t\t}\n\t\tputs(ok ? \"YES\" : \"NO\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\n \nconst double EPS = 1e-9;\nconst double PI = 6.0 * asin(0.5);\n \nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n \ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n \nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n \nbool isIntersect(L s1, L s2){\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n \nvector<P> convex_hull(vector<P> v){\n  vector<P> c; \n  sort(v.begin(),v.end());\n  c.assign(v.begin(),v.begin()+2);\n     \n  for(int i=2;i<v.size();i++){\n    P a = c[c.size()-1] - c[c.size()-2];\n    P b = v[i] - c[c.size()-2];\n         \n    while(cross(a,b) > EPS){\n      c.pop_back();\n      if(c.size() < 2) break;\n      a = c[c.size()-1] - c[c.size()-2];\n      b = v[i] - c[c.size()-2];\n    }\n    c.push_back(v[i]);\n  }\n     \n  int n = c.size();\n  c.push_back(v[v.size()-2]);\n     \n  for(int i=v.size()-3;i>=0;i--){\n    P a = c[c.size()-1] - c[c.size()-2];\n    P b = v[i] - c[c.size()-2];\n         \n    while(cross(a,b) > EPS){\n      c.pop_back();\n      if(c.size() < n + 1) break;\n      a = c[c.size()-1] - c[c.size()-2];\n      b = v[i] - c[c.size()-2];\n    }\n    c.push_back(v[i]);\n  }\n  c.pop_back();\n  return c;\n}\n \n \nvector<P> p1,p2;\nint n,m;\nint solve(){\n  if(n+m<3) return 1;\n  if(m==1&&n==2) return ccw(p1[0],p1[1],p2[0])!=0;\n  if(n==2&&m==2) return !isIntersect(L(p1[0],p1[2]),L(p2[0],p2[1]));\n \n  if(n<3) return 0;\n  vector<P> t=convex_hull(p1);\n  for(int i=0;i<=(int)t.size();i++){\n    int flg=1;\n    for(int j=0;j<m&&flg;j++)\n      if(ccw(t[i],t[(i+1)%t.size()],p2[j])!=1)flg=0;\n    if(flg) return 1;\n     \n  }\n  return 0;  \n}\n \n \nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)return 0;\n    p1.resize(n),p2.resize(m);\n    for(int i=0,a,b;i<n;i++)cin>>a>>b,p1[i]=P(a,b);\n    for(int i=0,a,b;i<m;i++)cin>>a>>b,p2[i]=P(a,b);\n    int ans=solve();\n    swap(p1,p2);\n    swap(n,m);\n    ans|=solve();\n    cout<<(ans?\"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Separate Points\n\n\n#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値, Polygonのメンバ変数\n#include<algorithm> // min(), sort(), reverse()\n\nconst double EPS = 1e-10;\nenum POSITION {ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\nclass Polygon;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    const Point normalize() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n    void print() const;\n};\nbool operator==(const Point& lhs, const Point& rhs);\nbool operator!=(const Point& lhs, const Point& rhs);\nbool operator<(const Point& lhs, const Point& rhs);\nbool operator>(const Point& lhs, const Point& rhs);\nbool operator<=(const Point& lhs, const Point& rhs);\nbool operator>=(const Point& lhs, const Point& rhs);\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Segment(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    bool parallel(const Segment&) const;\n    bool parallel(const Line&) const;\n    bool orthogonal(const Segment&) const;\n    bool orthogonal(const Line&) const;\n    POSITION ccw(const Point&) const;\n    void print() const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Line(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    bool parallel(const Segment&) const;\n    bool parallel(const Line&) const;\n    bool orthogonal(const Segment&) const;\n    bool orthogonal(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n    void print() const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool in(const Point&) const;\n    bool out(const Point&) const;\n    bool include(const Point&) const;\n    bool include(const Segment&) const;\n    bool include(const Line&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    std::vector<Point> crosspoint(const Circle&) const;\n    void print() const;\n};\nclass Polygon {\n    std::vector<Point> point;\npublic:\n    Polygon() {}\n    explicit Polygon(std::vector<Point> p) :point(p) {}\n    const std::vector<Point>& vertex() const {return point;}\n    const Point& vertex(int i) const {return point.at(i);}\n    const std::vector<Segment> edge() const {\n        std::vector<Segment> result;\n        for(int i = 0; i < size(); ++i) result.push_back(Segment(vertex(i), vertex((i + 1) % size())));\n        return result;\n    }\n    const Segment edge(int i) const {return Segment(vertex(i), vertex((i + 1) % size()));}\n    int size() const {return point.size();}\n    void add(const Point&);\n    double area() const;\n    bool convex() const;\n    bool include(const Point&) const;\n    bool intersect(const Polygon&) const;\n    bool on_edge(const Point&) const;\n    const Polygon convex_hull() const;\n    const std::vector<int> farthest_point_pair() const;\n    void print() const;\n};\n// Point\nbool operator==(const Point& lhs, const Point& rhs) {return lhs.x() == rhs.x() && lhs.y() == rhs.y();}\nbool operator!=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() || lhs.y() != rhs.y();}\nbool operator<(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() < rhs.x() : lhs.y() < rhs.y();}\nbool operator>(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() > rhs.x() : lhs.y() > rhs.y();}\nbool operator<=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() < rhs.x() : lhs.y() <= rhs.y();}\nbool operator>=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() > rhs.x() : lhs.y() >= rhs.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\nconst Point Point::normalize() const {return abs() == 0.0 ? Point(0.0, 0.0) : Point(x(), y()) / abs();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return COUNTER_CLOCKWISE;\n    if(v1.cross(v2) < -EPS) return CLOCKWISE;\n    if(v1.dot(v2) < -EPS) return ONLINE_BACK;\n    if(v2.norm() - v1.norm() > EPS) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nvoid Point::print() const {std::cout << x() << \", \" << y() << std::endl;}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    return std::min(source().distance(p), target().distance(p));\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    return std::min({a, b, c, d});\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {return source().distance(p) + target().distance(p) - target().distance(source()) <= EPS;}\nbool Segment::intersect(const Segment& s) const {\n    bool a = ccw(s.source()) * ccw(s.target()) <= 0;\n    bool b = s.ccw(source()) * s.ccw(target()) <= 0;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\nbool Segment::parallel(const Line& l) const {return line().parallel(l);}\nbool Segment::parallel(const Segment& s) const {return line().parallel(s.line());}\nbool Segment::orthogonal(const Line& l) const {return line().orthogonal(l);}\nbool Segment::orthogonal(const Segment& s) const {return line().orthogonal(s.line());}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\nvoid Segment::print() const {std::cout << \"source: \"; source().print(); std::cout << \"target: \"; target().print();}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nbool Line::parallel(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dxl - dyl * dx) <= EPS;\n}\nbool Line::parallel(const Segment& s) const {return parallel(s.line());}\nbool Line::orthogonal(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dyl + dxl * dx) <= EPS;\n}\nbool Line::orthogonal(const Segment& s) const {return orthogonal(s.line());}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + v2 * (v1.dot(v2) / v2.norm()));\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) return l.source();\n    return l.source() + v2 * (b / a);\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\nvoid Line::print() const {std::cout << \"source: \"; source().print(); std::cout << \"target: \"; target().print();}\n// Circle\nbool Circle::in(const Point& p) const {return center().distance(p) < r() - EPS;}\nbool Circle::out(const Point& p) const {return r() + EPS < center().distance(p);}\nbool Circle::include(const Point& p) const {return center().distance(p) <= r() + EPS;}\nbool Circle::include(const Segment& s) const {return center().distance(s) <= r() + EPS;}\nbool Circle::include(const Line& l) const {return center().distance(l) <= r() + EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) <= r() - c.r() + EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) <= r() + c.r() + EPS;}\nstd::vector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    std::vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\nvoid Circle::print() const {std::cout << \"radius: \" << r() << \" - point: \"; center().print();}\n// Polygon\nvoid Polygon::add(const Point& p) {point.push_back(p);}\ndouble Polygon::area() const {\n    double sum = 0.0;\n    for(int i = 0; i < size(); ++i) sum += vertex(i).cross(vertex((i+1) % size()));\n    return fabs(sum) / 2.0;\n}\nbool Polygon::convex() const {\n    POSITION direction = ONLINE_BACK;\n    for(int i = 1; i < size(); ++i) {\n        POSITION d = vertex(i - 1).ccw(vertex(i), vertex((i + 1) % size()));\n        if(d != CLOCKWISE && d != COUNTER_CLOCKWISE) continue;\n        if(direction == ONLINE_BACK) direction = d;\n        if(direction != d) return false;\n    }\n    return true;\n}\nbool Polygon::include(const Point& p) const {\n    bool in = false;\n    for(int i = 0; i < size(); ++i) {\n        Point a = vertex(i) - p;\n        Point b = vertex((i + 1) % size()) - p;\n        if(a.y() > b.y()) std::swap(a, b);\n        if(a.y() <= 0.0 && 0 < b.y() && a.cross(b) < 0.0) in = !in;\n        if(fabs(a.cross(b)) <= EPS && a.dot(b) <= EPS) return true;\n    }\n    return in;\n}\nbool Polygon::intersect(const Polygon& p) const {\n    for(const auto& e1: edge()) for(const auto& e2: p.edge()) if(e1.intersect(e2)) return true;\n    return false;\n}\nbool Polygon::on_edge(const Point& p) const {\n    for(int i = 0; i < size(); ++i) if(vertex(i).ccw(vertex((i + 1) % size()), p) == ON_SEGMENT) return true;\n    return false;\n}\nconst Polygon Polygon::convex_hull() const {                // Andrew's Monotone Chain\n    Polygon result;\n    std::vector<Point> res;\n    std::vector<Point> original = vertex();\n    sort(original.begin(), original.end());\n    original.insert(original.end(), original.rbegin() + 1, original.rend());\n    for(const auto& v: original) {\n        while(res.size() >= 2 && res[res.size() - 2].ccw(res[res.size() - 1], v) == CLOCKWISE) res.pop_back();\n        res.push_back(v);\n    }\n    res.pop_back();\n    for(const auto& v: res) result.add(v);\n    return result;\n}\nconst std::vector<int> Polygon::farthest_point_pair() const {  // Rotating calipers\n    auto v = vertex();\n    int p, q, start_p, start_q, max_p, max_q;\n    p = start_p = max_p = std::min_element(v.begin(), v.end()) - v.begin();\n    q = start_q = max_q = std::max_element(v.begin(), v.end()) - v.begin();\n    double max_d = (vertex(p) - vertex(q)).norm();\n    do {\n        if((vertex((p + 1) % size()) - vertex(p)).cross(vertex((q + 1) % size()) - vertex(q)) >= 0) q = (q + 1) % size();\n        else p = (p + 1) % size();\n        if((vertex(p) - vertex(q)).norm() > max_d) {\n            max_d = (vertex(p) - vertex(q)).norm();\n            max_p = p;\n            max_q = q;\n        }\n    } while(start_p != q || start_q != p);\n    return {max_p, max_q};\n}\nvoid Polygon::print() const {for(const auto& v: vertex()) std::cout << v.x() << \", \" << v.y() << std::endl;}\n\n////////////////////////////////////////////////////////////////////////////////\n\nusing namespace std;\nint main() {\n    int n, m;\n    while(cin >> n >> m, n | m) {\n        Polygon white, black;\n        for(int i = 0; i < n; ++i) {\n            double x, y;\n            cin >> x >> y;\n            white.add(Point(x, y));\n        }\n        for(int i = 0; i < m; ++i) {\n            double x, y;\n            cin >> x >> y;\n            black.add(Point(x, y));\n        }\n        if(white.vertex().size() > 2) white = white.convex_hull();\n        if(black.vertex().size() > 2) black = black.convex_hull();\n        bool ng = false;\n        for(const auto& ew: white.edge()) for(const auto& eb: black.edge()) ng |= ew.intersect(eb);\n        for(const auto& e: white.edge()) for(const auto& p: black.vertex()) ng |= e.intersect(p);\n        for(const auto& e: black.edge()) for(const auto& p: white.vertex()) ng |= e.intersect(p);\n        for(const auto& p: black.vertex()) ng |= white.include(p);\n        for(const auto& p: white.vertex()) ng |= black.include(p);\n        cout << (!ng ?  \"YES\" : \"NO\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\ntypedef pair<double, double> P;\nint f(double w[], P p){\n  double v = w[0] + w[1] * p.first + w[2] * p.second;\n  if(v >= 0) return 1;\n  else return 0;\n}\n\nint main(){\n  int b, w;\n  while(cin>>b>>w && (b != 0 || w != 0)){\n    vector<P> points_b, points_w;\n    REP(i, b){\n      double x, y; cin>>x>>y;\n      points_b.push_back(P(x, y));\n    }\n    REP(i, w){\n      double x, y; cin>>x>>y;\n      points_w.push_back(P(x, y));\n    }\n    double we[3] = {};\n    double rate = 1;\n    bool ans = false;\n    REP(iter, 22000000/(w + b)){\n      bool update = false;\n      REP(i, b){\n        int v = f(we, points_b[i]);\n        if(v == 1){\n          we[0] = we[0] + rate * -1;\n          we[1] = we[1] + rate * -1 * points_b[i].first;\n          we[2] = we[2] + rate * -1 * points_b[i].second;\n          update = true;\n        }\n      }\n      REP(i, w){\n        int v = f(we, points_w[i]);\n        if(v == 0){\n          we[0] = we[0] + rate * 1;\n          we[1] = we[1] + rate * 1 * points_w[i].first;\n          we[2] = we[2] + rate * 1 * points_w[i].second;\n          update = true;\n        }\n      }\n      if(!update){\n        ans = true;\n        break;\n      }\n    }\n    if(ans) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef pair<int,int> P;\n\n//for vector\ninline int norm(P a){ return a.fs*a.fs + a.sc*a.sc; }\ninline int dot(P a, P b){return a.fs*b.fs + a.sc*b.sc;}\ninline int cross(P a, P b){return a.fs*b.sc - a.sc*b.fs;}\n\nint ccw(P a,P b,P c){\n  b.fs -= a.fs; b.sc -= a.sc;\n  c.fs -= a.fs; c.sc -= a.sc;\n  if (cross(b,c)>0) return 1;   //counter clockwise\n  if (cross(b,c)<0) return -1; //clockwise\n  if (dot(b, c)<-0) return 2;   //c--a--b on line\n  if (norm(b)<norm(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n\n  int n,m;\n  P b[110],w[110];\n  while(cin >> n >> m, n||m){\n    rep(i,n)cin >> b[i].fs >> b[i].sc;\n    rep(i,m)cin >> w[i].fs >> w[i].sc;\n\n    bool ans = false;\n    rep(i,n)rep(j,i){\n      bool f = true;\n      set<int> dirb;\n      rep(k,n){\n\tif(k==i || k==j)continue;\n\tint tmp = ccw(b[i],b[j],b[k]);\n\tif(tmp == 0){f = false; break;}\n\tif(abs(tmp)==1)dirb.insert(tmp);\n      }\n      if(dirb.size()==2)f = false;\n\n      set<int> dirw;\n      rep(k,m){\n\tint tmp = ccw(b[i],b[j],w[k]);\n\tif(abs(tmp) != 1){f = false; break;}\n\tdirw.insert(tmp);\n      }\n      if(dirw.size()==2)f = false;\n      if(f && (dirb.size()==0 || dirw.size()==0\n\t       || *dirb.begin() != *dirw.begin()))ans = true;\n    }\n\n    rep(i,m)rep(j,i){\n      bool f = true;\n      set<int> dirw;\n      rep(k,m){\n\tif(k==i || k==j)continue;\n\tint tmp = ccw(w[i],w[j],w[k]);\n\tif(tmp == 0){f = false; break;}\n\tif(abs(tmp)==1)dirw.insert(tmp);\n      }\n      if(dirw.size()==2)f = false;\n\n      set<int> dirb;\n      rep(k,n){\n\tint tmp = ccw(w[i],w[j],b[k]);\n\tif(abs(tmp) != 1){f = false; break;}\n\tdirb.insert(tmp);\n      }\n      if(dirb.size()==2)f = false;\n      if(f && (dirb.size()==0 || dirw.size()==0\n\t       || *dirb.begin() != *dirw.begin()))ans = true;\n    }\n\n    rep(i,n)rep(j,m){\n      bool f = true;\n      set<int> dirb;\n      rep(k,n){\n\tif(k==i)continue;\n\tint tmp = ccw(b[i],w[j],b[k]);\n\tif(tmp == 0 || tmp == -2){f = false; break;}\n\tif(abs(tmp)==1)dirb.insert(tmp);\n\tdirb.insert(tmp);\n      }\n      if(dirb.size()==2)f = false;\n\n      set<int> dirw;\n      rep(k,m){\n\tif(k==j)continue;\n\tint tmp = ccw(b[i],w[j],w[k]);\n\tif(tmp == 0 || tmp == 2){f = false; break;}\n\tif(abs(tmp)==1)dirw.insert(tmp);\n      }\n      if(dirw.size()==2)f = false;\n\n      if(f && (dirb.size()==0 || dirw.size()==0\n\t       || *dirb.begin() != *dirw.begin()))ans = true;\n    }\n\n    cout << (ans?\"YES\":\"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nstruct Point\n{\n    double x,y;\n    Point (double x=0, double y=0) :x(x),y(y) {}\n    void show() { cout<<\"(\"<<x<<\",\"<<y<<\")\"<<endl; }\n};\ntypedef Point Vector;\n\nbool operator < (const Point& A, const Point& B )\n{\n    return A.x < B.x || (A.x == B.x && A.y < B.y);\n}\nVector operator - ( Point A, Point B) { return Vector(A.x-B.x, A.y-B.y); }\ndouble Cross(Vector A, Vector B) { return A.x*B.y - B.x*A.y; }\n\nconst double eps = 1e-10;\nint dcmp(double x)\n{\n    if(fabs(x) < eps) return 0;\n    return x>0? 1: -1;\n}\n\nint ConvexHull ( Point* p, int n, Point* ch)\n{\n    sort(p, p+n);\n    int m = 0;\n    for(int i = 0; i<n; i++)\n    {\n        while(m > 1 && Cross( ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0) m--;\n        ch[m++] = p[i];\n    }\n    int k = m;\n    for(int i = n-2; i>=0; i--)\n    {\n        while(m > k && Cross( ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0) m--;\n        ch[m++] = p[i];\n    }\n    ///霑倩ヲ∵隼荳?ク狗函謌仙、夊セケ蠖「縲?    ch[m++] = ch[0];\n    if(n > 1) m--;\n    return m;\n}\n\nPoint black[120],white[120],cw[120],cb[120];\nint nb,nw,n,m;\n\nvoid reset()\n{\n    memset(black,0,sizeof(black));\n    memset(white,0,sizeof(white));\n    memset(cw,0,sizeof(cw));\n    memset(cb,0,sizeof(cb));\n}\n\nbool SideCross(Point a1, Point a2, Point b1, Point b2)\n{\n    double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1),\n           c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1);\n    return dcmp(c1)*dcmp(c2)<0 && dcmp(c3)*dcmp(c4)<0;\n}\n\nbool pInConvex(Point a, Point* ch, int n)\n{\n    int i;\n    if(n==3)\n    {\n        if(a.x < min(ch[0].x, ch[1].x) || a.x > max(ch[0].x, ch[1].x)) return 0;\n        if(a.y < min(ch[0].y, ch[1].y) || a.y > max(ch[0].y, ch[1].y)) return 0;\n    }\n    for(i=1;i<n;i++)\n    {\n        if(Cross( ch[i]-ch[i-1], a-ch[i-1] ) < 0 ) return 0;\n    }\n    return 1;\n}\n\nint solve()\n{\n    int i,j;\n    if(n==1&&m==1) return 1;\n    else if(n==1)\n    {\n        ///謇セ逋ス蟄仙?蛹?、夊セケ蠖「縲ょ愛譁ュ霑吩クェ鮟大ュ先弍蜷ヲ蝨ィ逋ス蛹??\n        nw=ConvexHull(white, m, cw);\n        if(pInConvex(black[0], cw, nw)) return 0;\n    }\n    else if(m==1)\n    {\n        ///謇セ鮟大ュ仙?蛹?、夊セケ蠖「縲ょ愛譁ュ霑吩クェ逋ス蟄先弍蜷ヲ蝨ィ鮟大桁蜀?        nb=ConvexHull(black, n, cb);\n        if(pInConvex(white[0], cb, nb)) return 0;\n    }\n    else\n    {\n        ///謇セ鮟醍區蜃ク蛹?、夊セケ蠖「縲ょ愛譁ュ譏ッ蜷ヲ譛臥コソ谿オ逶ク莠、謌也せ蝨ィ蜿ヲ荳?クェ蜃ク蛹??縲?        nb=ConvexHull(black, n, cb);\n        nw=ConvexHull(white, m, cw);\n        for(i=1;i<nb;i++)\n        {\n            for(j=1;j<nw;j++)\n                if(SideCross( cb[i], cb[i-1], cw[j] ,cw[j-1] )) return 0;\n        }\n        for(i=0;i<n;i++)\n            if(pInConvex(black[i], cw, nw)) return 0;\n        for(i=0;i<m;i++)\n            if(pInConvex(white[i], cb, nb)) return 0;\n    }\n    return 1;\n}\n\nint main()\n{\n    //freopen(\"input.txt\",\"r\",stdin);\n    int i,tx,ty;\n    while(cin>>n>>m,n||m)\n    {\n        reset();\n        for(i=0;i<n;i++)\n        {\n            cin>>tx>>ty;\n            black[i]=Point(tx,ty);\n        }\n        for(i=0;i<m;i++)\n        {\n            cin>>tx>>ty;\n            white[i]=Point(tx,ty);\n        }\n        int ans=solve();\n        if(ans)\n            cout<<\"YES\"<<endl;\n        else\n            cout<<\"NO\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint Signum(double x){\n\treturn abs(x)<EPS?0:x<0?-1:1;\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n};\nbool operator==(Point a,Point b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\nbool operator!=(Point a,Point b){\n\treturn abs(a.x-b.x)>=EPS || abs(a.y-b.y)>=EPS;\n}\nPoint operator+(Point a,Point b){\n\treturn Point(a.x+b.x,a.y+b.y);\n}\nPoint operator-(Point a,Point b){\n\treturn Point(a.x-b.x,a.y-b.y);\n}\ndouble Abs2(Point p){\n\treturn p.x*p.x+p.y*p.y;\n}\ndouble Dot(Point a,Point b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble Cross(Point a,Point b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\nint CCW(Point a,Point b,Point c){\n\tPoint d1=b-a,d2=c-a;\n\tif(int sign=Signum(Cross(d1,d2)))\n\t\treturn sign;\t// 1:ccw,-1:cw\n\tif(Dot(d1,d2)<-EPS)\n\t\treturn -2;\t\t// c-a-b\n\tif(Abs2(d1)<Abs2(d2)-EPS)\n\t\treturn 2;\t\t// a-b-c\n\treturn 0;\t\t\t// a-c-b\n}\n\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n\tLine(double px,double py,double dx,double dy):pos(px,py),dir(dx,dy){}\n};\ntypedef Line Segment;\n\nbool IsInterSS(Segment a,Segment b){\n\tint c1=CCW(a.pos,a.pos+a.dir,b.pos),c2=CCW(a.pos,a.pos+a.dir,b.pos+b.dir);\n\tint c3=CCW(b.pos,b.pos+b.dir,a.pos),c4=CCW(b.pos,b.pos+b.dir,a.pos+a.dir);\n\treturn c1*c2<=0 && c3*c4<=0;\n}\n\nstruct LessX{\n\tbool operator()(Point a,Point b){\n\t\treturn a.x<b.x-EPS || a.x<b.x+EPS && a.y<b.y-EPS;\n\t}\n};\nvector<Point> ConvexHull(vector<Point> ps){\n\tif(ps.size()==1) return ps;\n\tsort(all(ps),LessX());\n\tvector<Point> res;\n\trep(_,2){\n\t\tint n=0;\n\t\tvector<Point> half(ps.size());\n\t\trep(i,ps.size()){\n\t\t\twhile(n>=2 && CCW(half[n-2],half[n-1],ps[i])!=1)\n\t\t\t\tn--;\n\t\t\thalf[n++]=ps[i];\n\t\t}\n\t\tres.insert(res.end(),half.begin(),half.begin()+n-1);\n\t\treverse(all(ps));\n\t}\n\treturn res;\n}\n\nbool IsCoverCP(const vector<Point>& ps,Point p){\n\trep(i,ps.size()){\n\t\tint ccw=CCW(ps[i],ps[(i+1)%ps.size()],p);\n\t\tif(!(ccw==1 || ccw==0))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nbool IsCoverCC(const vector<Point>& ps,vector<Point>& qs){\n\trep(i,qs.size())\n\t\tif(!IsCoverCP(ps,qs[i]))\n\t\t\treturn false;\n\treturn true;\n}\n\nint main()\n{\n\tfor(int m,n;cin>>m>>n,m|n;){\n\t\tvector<Point> bs(m),ws(n);\n\t\trep(i,m) cin>>bs[i].x>>bs[i].y;\n\t\trep(i,n) cin>>ws[i].x>>ws[i].y;\n\t\t\n\t\tvector<Point> bc=ConvexHull(bs),wc=ConvexHull(ws);\n\t\t\n\t\tif(IsCoverCC(bc,wc) || IsCoverCC(wc,bc)){\n\t\t\tputs(\"NO\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tbool inter=false;\n\t\trep(i,bc.size()) rep(j,wc.size()){\n\t\t\tSegment s1(bc[i],bc[(i+1)%bc.size()]-bc[i]);\n\t\t\tSegment s2(wc[j],wc[(j+1)%wc.size()]-wc[j]);\n\t\t\tif(IsInterSS(s1,s2))\n\t\t\t\tinter=true;\n\t\t}\n\t\tputs(inter?\"NO\":\"YES\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\ntypedef vector<string> svec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\n\n\nint ccw(LP v1, LP v2) {\n\tll z = v1.first*v2.second - v2.first*v1.second;\n\tif (z < 0)return -1;\n\tif (z > 0)return 1;\n\treturn 0;\n}\n\nint n, m;\nvoid solve() {\n\tif (n == 0 || m == 0 || n + m == 1) {\n\t\tcout << \"YES\" << endl; return;\n\t}\n\tvector<LP> w(n), b(m);\n\tvector<LP> v;\n\trep(i, n) {\n\t\tll x, y; cin >> x >> y;\n\t\tw[i] = { x,y };\n\t\tv.push_back({ x,y });\n\t}\n\trep(i, m) {\n\t\tll x, y; cin >> x >> y;\n\t\tb[i] = { x,y };\n\t\tv.push_back({ x,y });\n\t}\n\trep(i, n + m) {\n\t\trep(j, i) {\n\t\t\tll dx = v[j].first - v[i].first;\n\t\t\tll dy = v[j].second - v[i].second;\n\t\t\tvector<int> le, ri;\n\t\t\tvector<pair<LP, int>> z;\n\t\t\trep(k, n) {\n\t\t\t\tll difx = w[k].first - v[i].first;\n\t\t\t\tll dify = w[k].second - v[i].second;\n\t\t\t\tint t = ccw({ dx,dy }, { difx,dify });\n\t\t\t\tif (t == -1)le.push_back(0);\n\t\t\t\telse if (t == 1)ri.push_back(0);\n\t\t\t\telse {\n\t\t\t\t\tz.push_back({ w[k],0 });\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(k, m) {\n\t\t\t\tll difx = b[k].first - v[i].first;\n\t\t\t\tll dify = b[k].second - v[i].second;\n\t\t\t\tint t = ccw({ dx,dy }, { difx,dify });\n\t\t\t\tif (t == -1)le.push_back(1);\n\t\t\t\telse if (t == 1)ri.push_back(1);\n\t\t\t\telse {\n\t\t\t\t\tz.push_back({ b[k],1 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(le.begin(), le.end());\n\t\t\tsort(ri.begin(), ri.end());\n\t\t\tsort(z.begin(), z.end());\n\t\t\tif (!le.empty() && le[0] != le.back())continue;\n\t\t\tif (!ri.empty() && ri[0] != ri.back())continue;\n\t\t\tif (!le.empty() && !ri.empty()) {\n\t\t\t\tif (le[0] == 0 && ri[0] == 0) {\n\t\t\t\t\tbool f = true;\n\t\t\t\t\trep(k, z.size())if (z[k].second == 1)f = false;\n\t\t\t\t\tif (!f)continue;\n\t\t\t\t}\n\t\t\t\tif (le.back() == 1 && ri.back() == 1) {\n\t\t\t\t\tbool f = true;\n\t\t\t\t\trep(k, z.size())if (z[k].second == 0)f = false;\n\t\t\t\t\tif (!f)continue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 0;\n\t\t\trep(i, (int)z.size() - 1) {\n\t\t\t\tif (z[i].second != z[i + 1].second)cnt++;\n\t\t\t}\n\t\t\tif (cnt > 1)continue;\n\t\t\tcout << \"YES\" << endl; return;\n\t\t}\n\t}\n\tcout << \"NO\" << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\t//init();\n\twhile (cin >> n>>m, n|m) {\n\t\tsolve();\n\t}\n\t//solve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<stack>\n#include<vector>\n#include<queue>\n#include<string>\n#include<sstream>\n#define eps 1e-9\n#define ALL(x) x.begin(),x.end()\n#define INS(x) inserter(x,x.begin())\n#define FOR(i,j,k) for(int i=j;i<=k;i++)\n#define MAXN 105\n#define MAXM 40005\n#define INF 0x3fffffff\nusing namespace std;\ntypedef long long LL;\nstruct Point\n{\n    double x, y;\n    Point(double x=0, double y=0) :x(x),y(y) {}\n};\ntypedef Point Vector;\n\nPoint read_point(void)\n{\n    double x, y;\n    scanf(\"%lf%lf\", &x, &y);\n    return Point(x, y);\n}\n\nconst double EPS = 1e-10;\n\nVector operator + (Vector A, Vector B)    { return Vector(A.x + B.x, A.y + B.y); }\n\nVector operator - (Vector A, Vector B)    { return Vector(A.x - B.x, A.y - B.y); }\n\nVector operator * (Vector A, double p)    { return Vector(A.x*p, A.y*p); }\n\nVector operator / (Vector A, double p)    { return Vector(A.x/p, A.y/p); }\n\nbool operator < (const Point& a, const Point& b)\n{ return a.x < b.x || (a.x == b.x && a.y < b.y); }\n\nint dcmp(double x)\n{ if(fabs(x) < EPS) return 0; else return x < 0 ? -1 : 1; }\n\nbool operator == (const Point& a, const Point& b)\n{ return dcmp(a.x-b.x) == 0 && dcmp(a.y-b.y) == 0; }\n\ndouble Dot(Vector A, Vector B)\n{ return A.x*B.x + A.y*B.y; }\n\ndouble Length(Vector A)    { return sqrt(Dot(A, A)); }\n\n\ndouble Angle(Vector A, Vector B)\n{ return acos(Dot(A, B) / Length(A) / Length(B)); }\n\n\ndouble Cross(Vector A, Vector B)\n{ return A.x*B.y - A.y*B.x; }\n\n\ndouble Area2(Point A, Point B, Point C)\n{ return Cross(B-A, C-A); }\n\n\nVector VRotate(Vector A, double rad)\n{\n    return Vector(A.x*cos(rad) - A.y*sin(rad), A.x*sin(rad) + A.y*cos(rad));\n}\n\n\nPoint PRotate(Point A, Point B, double rad)\n{\n    return A + VRotate(B-A, rad);\n}\n\n\nVector Normal(Vector A)\n{\n    double l = Length(A);\n    return Vector(-A.y/l, A.x/l);\n}\n\n\nPoint GetLineIntersection(Point P, Vector v, Point Q, Vector w)\n{\n    Vector u = P - Q;\n    double t = Cross(w, u) / Cross(v, w);\n    return P + v*t;\n}\n\ndouble DistanceToLine(Point P, Point A, Point B)\n{\n    Vector v1 = B - A, v2 = P - A;\n    return fabs(Cross(v1, v2)) / Length(v1);\n}\n\n\ndouble DistanceToSegment(Point P, Point A, Point B)\n{\n    if(A == B)    return Length(P - A);\n    Vector v1 = B - A, v2 = P - A, v3 = P - B;\n    if(dcmp(Dot(v1, v2)) < 0)    return Length(v2);\n    else if(dcmp(Dot(v1, v3)) > 0)    return Length(v3);\n    else return fabs(Cross(v1, v2)) / Length(v1);\n}\n\n\nPoint GetLineProjection(Point P, Point A, Point B)\n{\n    Vector v = B - A;\n    return A + v * (Dot(v, P - A) / Dot(v, v));\n}\n\n\nbool SegmentProperIntersection(Point a1, Point a2, Point b1, Point b2)\n{\n    double c1 = Cross(a2-a1, b1-a1), c2 = Cross(a2-a1, b2-a1);\n    double c3 = Cross(b2-b1, a1-b1), c4 = Cross(b2-b1, a2-b1);\n    return dcmp(c1)*dcmp(c2)<0 && dcmp(c3)*dcmp(c4)<0;\n}\n\n\nbool OnSegment(Point P, Point a1, Point a2)\n{\n    Vector v1 = a1 - P, v2 = a2 - P;\n    return dcmp(Cross(v1, v2)) == 0 && dcmp(Dot(v1, v2)) < 0;\n}\n\n\ndouble PolygonArea(Point* P, int n)\n{\n    double ans = 0.0;\n    for(int i = 1; i < n - 1; ++i)\n        ans += Cross(P[i]-P[0], P[i+1]-P[0]);\n    return ans/2;\n}\n\nconst double PI = acos(-1.0);\nstruct Line\n{\n    Point p;\n    Vector v;\n    double ang;\n    Line()    { }\n    Line(Point p, Vector v): p(p), v(v)    { ang = atan2(v.y, v.x); }\n    Point point(double t)\n    {\n        return p + v*t;\n    }\n    bool operator < (const Line& L) const\n    {\n        return ang < L.ang;\n    }\n};\n\n\nint isPointInPolygon(Point P, Point* Poly, int n)\n{\n    int wn;\n    for(int i = 0; i < n; ++i)\n    {\n        if(OnSegment(P, Poly[i], Poly[(i+1)%n]))    return -1; \n        int k = dcmp(Cross(Poly[(i+1)%n] - Poly[i], P - Poly[i]));\n        int d1 = dcmp(Poly[i].y - P.y);\n        int d2 = dcmp(Poly[(i+1)%n].y - P.y);\n        if(k > 0 && d1 <= 0 && d2 > 0)    wn++;\n        if(k < 0 && d2 <= 0 && d1 > 0)    wn--;\n    }\n    if(wn != 0)  return 1;\n    return 0;\n}\n\nint ConvexHull(Point* p, int n, Point* ch)\n{\n    sort(p, p +n);\n    int m = 0;\n    for(int i = 0; i < n; ++i)\n    {\n        while(m > 1 && Cross(ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0)    m--;\n        ch[m++] = p[i];\n    }\n    int k = m;\n    for(int i = n-2; i >= 0; --i)\n    {\n        while(m > k && Cross(ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0)    m--;\n        ch[m++] = p[i];\n    }\n    if(n > 1)    m--;\n    return m;\n}\n\nbool ConvexHullIntersection(Point *ch1,int t1,Point *ch2,int t2)\n{\n    double angle[MAXN],x;\n    int i,j,k,m;\n    if(t1==1)return true;\n    if(t1==2)\n    {\n        for(i=0;i<t2;i++)\n        {\n            k=dcmp(Cross(ch1[1]-ch1[0],ch2[i]-ch1[0]));\n            if(k==0&&Dot(ch1[1]-ch1[0],ch2[i]-ch1[0])>0)\n            {\n                if(Length(ch2[i]-ch1[0])<Length(ch1[1]-ch1[0]))break;\n            }\n        }\n        if(i<t2)return false;\n        if(t2==2&&SegmentProperIntersection(ch1[0],ch1[1],ch2[0],ch2[1]))return false;\n        return true;\n    }\n\n    angle[0]=0;\n    for(i=2;i<t1;i++)\n    angle[i-1]=Angle(ch1[1]-ch1[0],ch1[i]-ch1[0]);\n    for(i=0;i<t2;i++)\n    {\n        j=dcmp(Cross(ch1[1]-ch1[0],ch2[i]-ch1[0]));\n        if(j<0||(j==0&&Dot(ch1[1]-ch1[0],ch2[i]-ch1[0])<0))continue;\n        j=dcmp(Cross(ch1[t1-1]-ch1[0],ch2[i]-ch1[0]));\n        if(j>0||(j==0&&Dot(ch1[t1-1]-ch1[0],ch2[i]-ch1[0])<0))continue;\n        x=Angle(ch1[1]-ch1[0],ch2[i]-ch1[0]);\n        m=lower_bound(angle,angle+t1-1,x)-angle;\n        if(m==0)j=0;\n        else j=m-1;\n        k=dcmp(Cross(ch1[j+1]-ch2[i],ch1[j+2]-ch2[i]));\n        if(k>=0)break;\n    }\n    if(i<t2)return false;\n    return true;\n}\n\n\n\nint i,j,k,n,m,x,y,T,ans,big,cas,num,len;\nbool flag;\nPoint a[105],b[105],cha[105],chb[105];\n\nint main()\n{\n\twhile (scanf(\"%d%d\",&n,&m),n+m)\n\t{\n\t\t\n\t\t\n\t\tfor (i=0;i<n;i++)\n\t\t{\n\t\t\tscanf(\"%lf%lf\",&a[i].x,&a[i].y);\n\t\t}\n\t\t\n\t\tint as=ConvexHull(a,n,cha); \n\t\t\n\t\tfor (i=0;i<m;i++)\n\t\t{\n\t\t\tscanf(\"%lf%lf\",&b[i].x,&b[i].y);\n\t\t}\n\t\t\n\t\t\n\t\tint bs=ConvexHull(b,m,chb); \n\t\t\n\t\tif (ConvexHullIntersection(cha,as,chb,bs)&&ConvexHullIntersection(chb,bs,cha,as)) printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\");\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-10\n#define INF 1000000\n \nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n    Point operator *(const double d)const{\n        return Point(x*d,y*d);\n    }\n    bool operator <(const Point &p)const{\n        if(x==p.x) return y<p.y;\n        return x<p.x;\n    }\n    double norm(){\n        return x*x+y*y;\n    }\n\tbool input(){\n\t\tif(cin>>x>>y) return true;\n\t\treturn false;\n\t}\n};\n \nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n\tbool input(){\n\t\tif(a.input() && b.input()) return true;\n\t\treturn false;\n\t}\n};\n \nstruct Circle{\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point _c,double _r){\n        c=_c; r=_r;\n    }\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n \nint ccw(Point a,Point b,Point c){ //a,b,c,は全て異なる\n\tPoint v1 = b-a;\n\tPoint v2 = c-a;\n    if(cross(v1,v2)>EPS) return +1; //a->b->c が反時計回り\n    if(cross(v1,v2)<-EPS) return -1; //a->b->c が時計回り\n\tif(dot(v1,v2)<-EPS) return +2; //cがa-bより後ろ c<-a->b\n\tif(v1.norm()<v2.norm()) return -2; //cがa-bより前 a->b->c\n    return 0; //cがa-b上 a->c->b\n}\n \nbool intersect_ss(Line l,Line m){\n    return ccw(l.a,l.b,m.a)*ccw(l.a,l.b,m.b)<=0 && ccw(m.a,m.b,l.a)*ccw(m.a,m.b,l.b)<=0;\n}\n \nbool crosspoint_ll(Line l,Line m,Point &p){\n    Point a1,a2,b1,b2;\n    a1 = l.b-l.a; a2 = m.b-m.a;\n    b1 = m.a-l.a; b2 = l.a-m.b;\n    double s1,s2;\n    s1 = cross(a1,b1)/2; s2 = cross(a1,b2)/2;\n    if(s1+s2<EPS) return false; //平行\n    p = Point(m.a.x+a2.x*s1/(s1+s2),m.a.y+a2.y*s1/(s1+s2));\n    return true;\n}\n \nint crosspoint_ss(Line l,Line m,Point &p){\n    if(intersect_ss(l,m)==false) return 0; //交差していない\n    if(crosspoint_ll(l,m,p)==true) return 1;\n\treturn -1; //交点が無限個(平行かつ交差)\n}\n \nint crosspoint_cc(Circle c1,Circle c2,Point &p1,Point &p2){\n    double d,a,t;\n    d = sqrt((c2.c-c1.c).norm());\n\tif(abs(c1.c.x-c2.c.x)<EPS && abs(c1.c.y-c2.c.y)<EPS && abs(c1.r-c2.r)<EPS)\n\t\treturn -1; //2つの円が重なっている\n    if(d<abs(c1.r-c2.r) || c1.r+c2.r<d) return 0; //どちらかが内包している\n    a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    t = atan2(c2.c.y-c1.c.y,c2.c.x-c1.c.x);\n    p1 = Point(c1.c.x+c1.r*cos(t+a),c1.c.y+c1.r*sin(t+a));\n    p2 = Point(c1.c.x+c1.r*cos(t-a),c1.c.y+c1.r*sin(t-a));\n    if(abs(p1.x-p2.x)<EPS && abs(p1.y-p2.y)<EPS) return 1; //交点が1つ\n    return 2; //交点が2つ\n}\n\nint contains(Polygon g,Point p){\n\tLine l = Line(p,Point(INF,p.y));\n\tint cnt = 0, n = g.size();\n\tfor(int i=0;i<n;i++){\n\t\tPoint a = g[i]-p;\n\t\tPoint b = g[(i+1)%n]-p;\n\t\tif(ccw(g[i],g[(i+1)%n],p)==0) return 1; //線分上\n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<=EPS && EPS<b.y && cross(a,b)>EPS) cnt++;\n\t}\n\tif((cnt&1)==1) return 2; //内包している\n\treturn 0; //内包していない\n}\n\nPolygon andrewScan(Polygon s){\n\tif(s.size()<=2) return s;\n\tsort(s.begin(),s.end());\n\tPolygon g;\n\tfor(int i=0;i<s.size();i++){\n\t\tfor(int n=g.size(); n>=2 && ccw(g[n-2],g[n-1],s[i])==1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\tint upper_n = g.size();\n\tfor(int i=s.size()-2;i>=0;i--){\n\t\tfor(int n=g.size(); n>upper_n && ccw(g[n-2],g[n-1],s[i])==1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\treverse(g.begin(),g.end());\n\tg.pop_back();\n\treturn g;\n}\n\nint main(){\n\tint N,M;\n\tPolygon b,w,gb,gw;\n\twhile(cin>>N>>M,N||M){\n\t\tb.resize(N); w.resize(M);\n\t\tfor(int i=0;i<N;i++) b[i].input();\n\t\tfor(int i=0;i<M;i++) w[i].input();\n\t\tgb = andrewScan(b); gw = andrewScan(w);\n\t\tbool ans = true;\n\t\tif(gb.size()>=2 && gw.size()>=2){\n\t\t\tfor(int i=0;i<gb.size() && ans;i++){\n\t\t\t\tfor(int j=0;j<gw.size() && ans;j++){\n\t\t\t\t\tLine l(gb[i],gb[(i+1)%gb.size()]), m(gw[i],gw[(i+1)%gw.size()]);\n\t\t\t\t\tif(intersect_ss(l,m)==true) ans = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(gb.size()>=3){\n\t\t\tfor(int i=0;i<M && ans;i++){\n\t\t\t\tif(contains(gb,w[i])!=0) ans = false;\n\t\t\t}\n\t\t}\n\t\tif(gw.size()>=3){\n\t\t\tfor(int i=0;i<N && ans;i++){\n\t\t\t\tif(contains(gw,b[i])!=0) ans = false;\n\t\t\t}\n\t\t}\n\t\tif(gb.size()==2 && gw.size()==1){\n\t\t\tif(ccw(gb[0],gb[1],gw[0])==0) ans = false;\n\t\t}\n\t\tif(gw.size()==2 && gb.size()==1){\n\t\t\tif(ccw(gw[0],gw[1],gb[0])==0) ans = false;\n\t\t}\n\t\tif(ans==true) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=150000;\nconst double inf=99999999;\ndouble delta=3.14159265358979*(1.0/(double)N);\nconst double C = cos(delta) , S=sin(delta);\n\nvoid delta_rotate(pair<double,double> &p){\n    pair<double,double> tmp;\n    tmp.first=p.first*C-p.second*S;\n    tmp.second=p.first*S+p.second*C;\n    p=tmp;\n}\n\nint main(void){\n    int n,m,i;\n    while(cin>>n>>m,n){\n        vector<pair<double,double>> bl;\n        vector<pair<double,double>> wh;\n        double a,b;\n        for(i=0;i<n;i++){\n            cin>>a>>b;\n            bl.emplace_back(a,b);\n        }\n        for(i=0;i<m;i++){\n            cin>>a>>b;\n            wh.emplace_back(a,b);\n        }\n        for(i=0;i<N+1;i++){\n            double blmax=-99999999,whmax=-99999999,whmin=inf,blmin=inf;\n            for(auto &p:bl){\n                delta_rotate(p);\n                blmax=max(blmax,p.first);\n                blmin=min(blmin,p.first);\n            }\n            for(auto &p:wh){\n                delta_rotate(p);\n                whmin=min(whmin,p.first);\n                whmax=max(whmax,p.first);\n            }\n            if(whmin-blmax>0.00000001 || blmin-whmax>0.00000001){\n                cout<<\"YES\"<<endl;\n                goto while_continue;\n            }\n        }\n        cout<<\"NO\"<<endl;\n        while_continue:;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#define eps 1e-8\n#define zero(x) (((x)>0?(x):-(x))<eps)\n#define _sign(x) ((x)>eps?1:((x)<-eps?2:0))\n\nusing namespace std;\n\ndouble add(double a,double b)\n{\n    if(abs(a+b)<eps*(abs(a)+abs(b))) return 0;\n    return a+b;\n}\n\nstruct P\n{\n    double x,y;\n    P(){}\n    P(double x,double y) :x(x),y(y){\n    }\n    P operator + (P p){\n        return P(add(x,p.x),add(y,p.y));\n    }\n    P operator - (P p){\n        return P(add(x,-p.x),add(y,-p.y));\n    }\n    P operator * (double d){\n        return P(x*d,y*d);\n    }\n    double dot(P p){\n        return add(x*p.x,y*p.y);\n    }\n    double det(P p){\n        return add(x*p.y,-y*p.x);\n    }\n};\n\nstruct line\n{\n    P a,b;\n};\n\ndouble xmult(P p1,P p2,P p0)\n{\n    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);\n}\n\ndouble dmult(P p0,P p1,P p2)\n{\n    return (p2.x-p0.x)*(p1.x-p0.x)+(p2.y-p0.y)*(p1.y-p0.y);\n}\n\nbool cmp_x(const P &p,const P &q)\n{\n    if(p.x!=p.x) return p.x<q.x;\n    return p.y<q.y;\n}\n\nint dblcmp(double d)\n{\n    if(fabs(d)<eps)\n    {\n        return 0;\n    }\n    return d>0? 1:-1;\n}\n\nvector<P> convex_hull(P*ps,int n)\n{\n    sort(ps,ps+n,cmp_x);\n    int k=0;\n    vector<P> qs(n*2);\n    for(int i=0;i<n;i++){\n        while(k>1&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0) k--;\n        qs[k++]=ps[i];\n    }\n    for(int i=n-2,t=k;i>=0;i--){\n        while(k>t&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0) k--;\n        qs[k++]=ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\n\nint inside_convex(P q,vector<P> p)\n{\n    int n=p.size();\n    int i,s[3]={1,1,1};\n    for(i=0;i<n&&s[1]|s[2];i++){\n        s[_sign(xmult(p[(i+1)%n],q,p[i]))]=0;\n    }\n    return s[1]|s[2];\n}\n\nint segcross(P a, P b, P c, P d)    //蛻、譁ュ郤ソ谿オ逶ク莠、\n{\n    double s1, s2, s3,s4;\n    int d1, d2, d3, d4;\n    d1=dblcmp(s1=xmult(a,b,c));\n    d2=dblcmp(s2=xmult(a,b,d));\n    d3=dblcmp(s3=xmult(c,d,a));\n    d4=dblcmp(s4=xmult(c,d,b));\n\n    if((d1^d2)==-2 && (d3^d4)==-2) return 1;\n\n    if((d1==0&&dblcmp(dmult(c,a,b))<=0)||\n       (d2==0&&dblcmp(dmult(d,a,b))<=0)||\n       (d3==0&&dblcmp(dmult(a,c,d))<=0)||\n       (d4==0&&dblcmp(dmult(b,c,d))<=0)) return 2;\n    return 0;\n}\n\nint dot_online_in(P p,line l)\n{\n    return zero(xmult(p,l.a,l.b))&&(l.a.x-p.x)*(l.b.x-p.x)<eps&&(l.a.y-p.y)*(l.b.y-p.y)<eps;\n}\nint dot_online_in(P p,P l1,P l2)\n{\n    return zero(xmult(p,l1,l2))&&(l1.x-p.x)*(l2.x-p.x)<eps&&(l1.y-p.y)*(l2.y-p.y)<eps;\n}\n//蛻、轤ケ譏ッ蜷ヲ蝨ィ郤ソ谿オ荳?荳榊桁諡ャ遶ッ轤ケ\nint dot_online_ex(P p,line l)\n{\n    return dot_online_in(p,l)&&(!zero(p.x-l.a.x)||!zero(p.y-l.a.y))&&(!zero(p.x-l.b.x)||!zero(p.y-l.b.y));\n}\n\nP m0[110],m1[110];\nvector<P> m2,m3;\nint main()\n{\n   // freopen(\"output.txt\",\"w\",stdout);\n    int n,m;\n    bool flag0,flag1;\n    while(scanf(\"%d%d\",&n,&m),n!=0||m!=0){\n        if(m>n){\n            for(int i=0;i<n;i++) scanf(\"%lf%lf\",&m1[i].x,&m1[i].y);\n            for(int i=0;i<m;i++) scanf(\"%lf%lf\",&m0[i].x,&m0[i].y);\n            swap(n,m);\n        }\n        else{\n            for(int i=0;i<n;i++) scanf(\"%lf%lf\",&m0[i].x,&m0[i].y);\n            for(int i=0;i<m;i++) scanf(\"%lf%lf\",&m1[i].x,&m1[i].y);\n        }\n        if((n<=1&&m<=1)||(n==0||m==0)){\n            printf(\"YES\\n\");\n            continue;\n        }\n        if(n==2&&m==2){\n            if(segcross(m0[0],m0[1],m1[0],m1[1])){\n                printf(\"NO\\n\");\n            }\n            else printf(\"YES\\n\");\n            continue;\n        }\n        if(n==2&&m==1){\n            line mid;\n            mid.a=m0[0]; mid.b=m0[1];\n            if(dot_online_ex(m1[0],mid)){\n                printf(\"NO\\n\");\n            }\n            else printf(\"YES\\n\");\n            continue;\n        }\n        m2=convex_hull(m0,n);\n        if(n>=3&&m<=2){\n            if(m==1){\n                if(inside_convex(m1[0],m2)) printf(\"NO\\n\");\n                else printf(\"YES\\n\");\n            }\n            else{\n                if(!inside_convex(m1[0],m2)&&!inside_convex(m1[1],m2)) flag0=true;\n                else flag0=false;\n                int tt=m2.size();\n                flag1=true;\n                for(int i=0;i<tt;i++){\n                    //printf(\"%f %f %f %f\\n\",m1[0].x,m1[0].y,m1[1].x,m1[1].y);\n                    //printf(\"%f %f %f %f\\n\",m2[i].x,m2[i].y,m2[(i+1)%tt].x,m2[(i+1)%tt].y);\n                    if(segcross(m1[0],m1[1],m2[i],m2[(i+1)%tt])){\n                        flag1=false;\n                        break;\n                    }\n                }\n                if(flag0&&flag1) printf(\"YES\\n\");\n                else printf(\"NO\\n\");\n            }\n            continue;\n        }\n        m3=convex_hull(m1,m);\n        flag0=flag1=true;\n        for(int i=0;i<m;i++){\n            if(inside_convex(m1[i],m2)){\n                flag0=false;\n                break;\n            }\n        }\n        for(int i=0;i<n;i++){\n            if(inside_convex(m0[i],m3)){\n                flag1=false;\n                break;\n            }\n        }\n        if(flag0&&flag1) printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <iostream>\n#include <cmath>\n#include <set>\nusing namespace std;\n\nconst double eps = 1e-9;\nint dcmp(double x)\n{\n    if (fabs(x) < eps) return 0;\n    return x < 0 ? -1 : 1;\n}\n\nstruct point\n{\n    double x, y;\n};\n\npoint operator + (const point&l, const point&r) { return { l.x + r.x,l.y + r.y }; }\npoint operator - (const point&l, const point&r) { return { l.x - r.x,l.y - r.y }; }\npoint operator * (const double k, const point&r) { return { k* r.x,k* r.y }; }\n\ndouble dot(const point&l, const point&r) { return l.x*r.x + l.y*r.y; }\ndouble cross(const point&l, const point&r) { return l.x*r.y - l.y*r.x; }\ndouble length(const point&l) { return sqrt(dot(l, l)); };\ndouble dis(const point&l, const point&r) { return length(l - r); }\n\nbool cmp(const point &p1, const point &p2)\n{\n    if (p1.y == p2.y) return p1.x < p2.x;\n    return p1.y < p2.y;\n}\nbool operator <(const point&p1, const point&p2)\n{\n    if (p1.y == p2.y) return p1.x < p2.x;\n    return p1.y < p2.y;\n}\nbool operator ==(const point&l, const point&r)\n{\n    return dcmp(l.x - r.x) == 0 && dcmp(l.y - r.y) == 0;\n}\n\nvector<point> jarvis(vector<point>& p)\n{\n    sort(p.begin(), p.end(), cmp);\n    p.erase(unique(p.begin(), p.end()), p.end());\n\n    int n = p.size();\n    int m = 0;\n    vector<point> ch(n + 1);\n    for (int i = 0; i < n; i++) {\n        while (m > 1 && cross(ch[m - 1] - ch[m - 2], p[i] - ch[m - 2]) <= 0) m--;\n        ch[m++] = p[i];\n    }\n    int k = m;\n    for (int i = n - 2; i >= 0; i--) {\n        while (m > k && cross(ch[m - 1] - ch[m - 2], p[i] - ch[m - 2]) <= 0) m--;\n        ch[m++] = p[i];\n    }\n    if (n > 1) m--;\n    ch.resize(m);\n    return ch;\n}\n\n//判断点p是否在边a1a2上\nbool OnSegment(const point& p, const point& a1, const point& a2)\n{\n    return dcmp(cross(a1 - p, a2 - p)) == 0 && dcmp(dot(a1 - p, a2 - p)) <= 0;//注意最后这个等于是端点重合的情况\n}\n//判断两条线段是否相交\nbool SegmentProperIntersection(const point& a1, const point& a2, const point& b1, const point& b2)\n{\n    //点在边上的情况\n    if (OnSegment(b1, a1, a2) || OnSegment(b2, a1, a2) || OnSegment(a1, b1, b2) || OnSegment(a2, b1, b2))\n        return true;\n    double c1 = cross(a2 - a1, b1 - a1), c2 = cross(a2 - a1, b2 - a1),\n        c3 = cross(b2 - b1, a1 - b1), c4 = cross(b2 - b1, a2 - b1);\n    return dcmp(c1)*dcmp(c2) < 0 && dcmp(c3)*dcmp(c4) < 0;\n}\n//判断点与凸多边形是否相离\nint IspointInPolygon(const point& p, const vector<point>& poly) {\n    int wn = 0;\n    int n = poly.size();\n    for (int i = 0; i < n; ++i)\n    {\n        const point& p1 = poly[i];\n        const point& p2 = poly[(i + 1) % n];\n        if (OnSegment(p, p1, p2)) return -1;//在边界上\n        int k = dcmp(cross(p2 - p1, p - p1));\n        int d1 = dcmp(p1.y - p.y);\n        int d2 = dcmp(p2.y - p.y);\n        if (k > 0 && d1 <= 0 && d2 > 0) wn++;\n        if (k < 0 && d2 <= 0 && d1 > 0) wn--;\n    }\n    if (wn != 0) return 1;//内部\n    return 0;//外部\n}\nbool ConvexPolygonDisjoint(const vector<point>& ch1, const vector<point>& ch2)\n{\n    int c1 = ch1.size();\n    int c2 = ch2.size();\n    for (int i = 0; i < c1; ++i)\n        if (IspointInPolygon(ch1[i], ch2) != 0) return false;\n    for (int i = 0; i < c2; ++i)\n        if (IspointInPolygon(ch2[i], ch1) != 0) return false;\n    for (int i = 0; i < c1; ++i)\n        for (int j = 0; j < c2; ++j)\n            if (SegmentProperIntersection(ch1[i], ch1[(i + 1) % c1], ch2[j], ch2[(j + 1) % c2])) return false;\n    return true;\n}\n\nint main()\n{\n    int n, m;\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n   \n    while (cin >> n >> m)\n    {\n        if (n == 0 && m == 0)break;\n        vector<point> p(n, { 0,0, });\n        vector<point> p2(m, { 0,0, });\n        for (int i = 0; i < n; ++i)\n        {\n            cin >> p[i].x >> p[i].y;\n        }\n        vector<point> ch1 = jarvis(p);\n        for (int i = 0; i < m; ++i)\n        {\n            cin >> p2[i].x >> p2[i].y;\n        }\n        vector<point> ch2 = jarvis(p2);\n         if (!ConvexPolygonDisjoint(ch1, ch2))\n        {\n            cout << \"NO\\n\";\n        }\n        else\n        {\n            cout << \"YES\\n\";\n        }\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nstruct Point\n{\n    double x,y;\n    Point (double x=0, double y=0) :x(x),y(y) {}\n    void show() { cout<<\"(\"<<x<<\",\"<<y<<\")\"<<endl; }\n};\ntypedef Point Vector;\n\nbool operator < (const Point& A, const Point& B )\n{\n    return A.x < B.x || (A.x == B.x && A.y < B.y);\n}\nVector operator - ( Point A, Point B) { return Vector(A.x-B.x, A.y-B.y); }\ndouble Cross(Vector A, Vector B) { return A.x*B.y - B.x*A.y; }\n\nconst double eps = 1e-10;\nint dcmp(double x)\n{\n    if(fabs(x) < eps) return 0;\n    return x>0? 1: -1;\n}\n\nint ConvexHull ( Point* p, int n, Point* ch)\n{\n    sort(p, p+n);\n    int m = 0;\n    for(int i = 0; i<n; i++)\n    {\n        while(m > 1 && Cross( ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0) m--;\n        ch[m++] = p[i];\n    }\n    int k = m;\n    for(int i = n-2; i>=0; i--)\n    {\n        while(m > k && Cross( ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0) m--;\n        ch[m++] = p[i];\n    }\n    ///霑倩ヲ∵隼荳?ク狗函謌仙、夊セケ蠖「縲?    ch[m++] = ch[0];\n    if(n > 1) m--;\n    return m;\n}\n\nPoint black[120],white[120],cw[120],cb[120];\nint nb,nw,n,m;\n\nvoid reset()\n{\n    memset(black,0,sizeof(black));\n    memset(white,0,sizeof(white));\n    memset(cw,0,sizeof(cw));\n    memset(cb,0,sizeof(cb));\n}\n\nbool SideCross(Point a1, Point a2, Point b1, Point b2)\n{\n    double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1),\n    c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1);\n    return dcmp(c1)*dcmp(c2)<0 && dcmp(c3)*dcmp(c4)<0;\n}\n\nbool pInConvex(Point a, Point* ch, int n)\n{\n    int i;\n    if(n==3)\n    {\n        if(a.x < min(ch[0].x, ch[1].x) || a.x > max(ch[0].x, ch[1].x)) return 0;\n        if(a.y < min(ch[0].y, ch[1].y) || a.y > max(ch[0].y, ch[1].y)) return 0;\n    }\n    for(i=1;i<n;i++)\n    {\n        if(Cross( ch[i]-ch[i-1], a-ch[i-1] ) < 0 ) return 0;\n    }\n    return 1;\n}\n\nint solve()\n{\n    int i,j;\n    if(n==1&&m==1) return 1;\n    else if(n==1)\n    {\n        ///謇セ逋ス蟄仙?蛹?、夊セケ蠖「縲ょ愛譁ュ霑吩クェ鮟大ュ先弍蜷ヲ蝨ィ逋ス蛹??\n        nw=ConvexHull(white, m, cw);\n        if(pInConvex(black[0], cw, nw)) return 0;\n    }\n    else if(m==1)\n    {\n        ///謇セ鮟大ュ仙?蛹?、夊セケ蠖「縲ょ愛譁ュ霑吩クェ逋ス蟄先弍蜷ヲ蝨ィ鮟大桁蜀?        nb=ConvexHull(black, n, cb);\n        if(pInConvex(white[0], cb, nb)) return 0;\n    }\n    else\n    {\n        ///謇セ鮟醍區蜃ク蛹?、夊セケ蠖「縲ょ愛譁ュ譏ッ蜷ヲ譛臥コソ谿オ逶ク莠、謌也せ蝨ィ蜿ヲ荳?クェ蜃ク蛹??縲?        nb=ConvexHull(black, n, cb);\n        nw=ConvexHull(white, m, cw);\n        for(i=1;i<nb;i++)\n        {\n            for(j=1;j<nw;j++)\n                if(SideCross( cb[i], cb[i-1], cw[j] ,cw[j-1] )) return 0;\n        }\n        for(i=0;i<n;i++)\n            if(pInConvex(black[i], cw, nw)) return 0;\n        for(i=0;i<m;i++)\n            if(pInConvex(white[i], cb, nb)) return 0;\n    }\n    return 1;\n}\n\nint main()\n{\n    int i,tx,ty;\n    while(cin>>n>>m,n||m)\n    {\n        reset();\n        for(i=0;i<n;i++)\n        {\n            cin>>tx>>ty;\n            black[i]=Point(tx,ty);\n        }\n        for(i=0;i<m;i++)\n        {\n            cin>>tx>>ty;\n            white[i]=Point(tx,ty);\n        }\n        int ans=solve();\n        if(ans)\n            cout<<\"YES\"<<endl;\n        else\n            cout<<\"NO\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ------ Petr Mitrichev is Professional. ------ //\n\n#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// ------ Class ------ //\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tbool operator==(const Point& p) const { return px == p.px && py == p.py; }\n\tbool operator!=(const Point& p) const { return px != p.px || py != p.py; }\n\tbool operator<(const Point& p) const { return px < p.px ? true : (px == p.px && py < p.py); }\n\tbool operator>(const Point& p) const { return px > p.px ? true : (px == p.px && py > p.py); }\n\tbool operator<=(const Point& p) const { return !(Point(px, py) > p); }\n\tbool operator>=(const Point& p) const { return !(Point(px, py) < p); }\n\tPoint operator+(const Point& p) const { return Point(px + p.px, py + p.py); }\n\tPoint operator-(const Point& p) const { return Point(px - p.px, py - p.py); }\n\tPoint operator/(long double d) const { return Point(px / d, py / d); }\n\tfriend Point operator*(const Point p, long double d) { return Point(p.px * d, p.py * d); }\n\tfriend Point operator*(long double d, const Point& p) { return p * d; }\n\tPoint& operator+=(const Point& p1) { px += p1.px, py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px, py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d, py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d, py /= d; return *this; }\n};\n\n// ------ Functions ------ //\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint pol(long double r, long double d) { return Point(cosl(d) * r, sinl(d) * r); }\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nvector<Point> convex_hull(vector<Point> v) {\n\tif (v.size() < 3) return v;\n\tsort(v.begin(), v.end());\n\tvector<Point> u = { v[0], v[1] }, l = { v[v.size() - 1], v[v.size() - 2] };\n\tfor (int i = 2; i < v.size(); i++) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], v[i]) >= 0; n--) u.pop_back();\n\t\tu.push_back(v[i]);\n\t}\n\tfor (int i = v.size() - 3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], v[i]) >= 0; n--) l.pop_back();\n\t\tl.push_back(v[i]);\n\t}\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\n// ------ Main ------ //\nint n, m; vector<Point> v1, v2, v3, v4;\nbool ok(int i) {\n\tint u = (i + 1) % v3.size();\n\tfor (int j = 0; j < v4.size(); j++) {\n\t\tif (abs(ccw(v3[i], v3[u], v4[j])) != 1) return false;\n\t}\n\tfor (int j = 0; j < v3.size(); j++) {\n\t\tif (i == j || u == j) continue;\n\t\tfor (int k = 0; k < v4.size(); k++) {\n\t\t\tif (ccw(v3[i], v3[u], v3[j]) == ccw(v3[i], v3[u], v4[k])) return false;\n\t\t}\n\t}\n\tfor (int j = 0; j < v4.size(); j++) {\n\t\tfor (int k = j + 1; k < v4.size(); k++) {\n\t\t\tif (ccw(v3[i], v3[u], v4[j]) != ccw(v3[i], v3[u], v4[k])) return false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\twhile (cin >> n >> m, n + m) {\n\t\tv1.resize(n), v2.resize(m);\n\t\tfor (int i = 0; i < n; i++) cin >> v1[i].px >> v1[i].py;\n\t\tfor (int i = 0; i < m; i++) cin >> v2[i].px >> v2[i].py;\n\t\tv3 = convex_hull(v1), v4 = convex_hull(v2);\n\t\tint x = 0;\n\t\tif (v3.size() == 1 && v4.size() == 1) x = 1;\n\t\tif (!x && v3.size() > 1) {\n\t\t\tint w = ccw(v3[0], v3[1], v4[0]);\n\t\t\tif (abs(w) == 2) {\n\t\t\t\tint f = 1;\n\t\t\t\tfor (int i = 1; i < v4.size(); i++) {\n\t\t\t\t\tif (ccw(v3[0], v3[1], v4[i]) != w) {\n\t\t\t\t\t\tf = 0; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f) x = 1;\n\t\t\t}\n\t\t}\n\t\tif (!x && v4.size() > 1) {\n\t\t\tint w = ccw(v4[0], v4[1], v3[0]);\n\t\t\tif (abs(w) == 2) {\n\t\t\t\tint f = 1;\n\t\t\t\tfor (int i = 1; i < v3.size(); i++) {\n\t\t\t\t\tif (ccw(v4[0], v4[1], v3[i]) != w) {\n\t\t\t\t\t\tf = 0; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f) x = 1;\n\t\t\t}\n\t\t}\n\t\tif (!x) {\n\t\t\tfor (int i = 0; i < v3.size(); i++) {\n\t\t\t\tif (ok(i)) {\n\t\t\t\t\tx = 1; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!x) {\n\t\t\tswap(v3, v4);\n\t\t\tfor (int i = 0; i < v4.size(); i++) {\n\t\t\t\tif (ok(i)) {\n\t\t\t\t\tx = 1; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (x ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iomanip>\n\n#define REP(i,n) for(i=0; i < (n); i++)\n#define REPONE(i, n) for(i=1; i <= (n); i++)\n#define LOOP(n) for(int loopCount=1; loopCount <= (n); loopCount++)\n#define ITER(c) __typeof((c).begin())\n#define EACH(c,it) for(ITER(c) it =(c).begin(); it!=(c).end(); it++)\n#define SZ(c) ((int) (c).size())\n#define ALL(c) c.begin(), c.end()\n#define SUM(c) accumulate(ALL(c), 0)\n#define EXIST(c,v) (find(ALL(c), (v)) != (c).end())\n#define PB push_back\n#define MP make_pair\n\nusing namespace std;\nstatic const double EPS = 1e-8;\nstatic const double PI = 3.141592653589793238462643383279;\n\n/*\ntypedef complex<double> point;\n\ntemplate<typename T>\nint sig2(T x){\n    if(abs(x)<EPS) return 0;\n    if(x>0) return 1;\n    return -1;\n}\n\ndouble det(point p1, point p2, point q){\n    return p2.real()*q.imag()+p1.real()*p2.imag()+q.real()*p1.imag()\n            -p2.real()*p1.imag()-q.real()*p2.imag()-q.imag()*p1.real();\n}\nint main(){\n    int i,j,k,n,m;\n    double x,y,bxma,byma,bxmi,bymi,wxma,wyma,wxmi,wymi;\n    bool yes;\n    while(scanf(\"%d%d\",&n,&m)){\n        if(n==0 && m==0) break;\n        bxma=byma=wxma=wyma=-1e99;\n        bxmi=bymi=wxmi=wymi=1e99;\n        yes=false;\n        vector<point> bs(n), ws(m);\n        REP(i,n){\n            scanf(\"%lf%lf\",&x,&y);\n            bs[i]=point(x,y);\n            bxma=max(bxma, x);\n            byma=max(byma, y);\n            bxmi=min(bxmi, x);\n            bymi=min(bymi, y);\n        }\n        REP(i,m){\n            scanf(\"%lf%lf\",&x,&y);\n            ws[i]=point(x,y);\n            wxma=max(wxma, x);\n            wyma=max(wyma, y);\n            wxmi=min(wxmi, x);\n            wymi=min(wymi, y);\n        }\n        if(bxma<wxmi||bxmi>wxma||byma<wymi||bymi>wyma){\n            printf(\"YES\\n\");\n            continue;\n        }\n        if(n==1 && m==1){\n            printf(\"YES\\n\");\n            continue;\n        }\n        int w=0, b;\n        REP(i,n)for(j=i+1;j<n;j++){\n            w = 0;\n            REP(k,m) w+=sig2(det(bs[i],bs[j],ws[k]));\n            if(abs(w)<m)break;\n            REP(k,n)if(sig2(det(bs[i],bs[j],bs[k]))==sig2(w))break;\n            if(k==n){\n                yes = true;\n                goto end;\n            }\n        }\n        swap(n,m);\n        swap(bs,ws);\n        REP(i,n)for(j=i+1;j<n;j++){\n            w = 0;\n            REP(k,m) w+=sig2(det(bs[i],bs[j],ws[k]));\n            if(abs(w)<m)break;\n            REP(k,n)if(sig2(det(bs[i],bs[j],bs[k]))==sig2(w))break;\n            if(k==n){\n                yes = true;\n                goto end;\n            }\n        }\n        REP(i,n)REP(j,m){\n            w = b = 0;\n            REP(k,m) w+=sig2(det(bs[i],ws[j],ws[k]));\n            if(abs(w)<m-1)break;\n            REP(k,n) b+=sig2(det(bs[i],ws[j],bs[k]));\n            if(abs(b)<n-1)break;\n            if(w*b<0){\n                yes = true;\n                goto end;\n            }\n        }\n        end:;\n        if(yes)printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n    return 0;\n}\n*/\n\n#define N 100000\n\nint main(){\n    int i,j,n,m;\n    double bma,bmi,wma,wmi,ang=PI/N,tmp;\n    static double bxs[100], wxs[100], bys[100], wys[100];\n    while(scanf(\"%d%d\",&n,&m)){\n        if(n==0 && m==0) break;\n        REP(i,n)scanf(\"%lf%lf\",bxs+i,bys+i);\n        REP(i,m)scanf(\"%lf%lf\",wxs+i,wys+i);\n        REP(i,N){\n            bma=wma=-1e99;\n            bmi=wmi=1e99;\n            REP(j,n){\n                tmp = cos(ang*i)*bxs[j]-sin(ang*i)*bys[j];\n                if(tmp<bmi)bmi=tmp;\n                if(tmp>bma)bma=tmp;\n            }\n            REP(j,m){\n                tmp = cos(ang*i)*wxs[j]-sin(ang*i)*wys[j];\n                if(bmi<tmp && tmp<bma) goto mark;\n                if(tmp<wmi)wmi=tmp;\n                if(tmp>wma)wma=tmp;\n            }\n            if(bma < wmi || wma < bmi) break;\n            mark:;\n        }\n        if(i==N)printf(\"NO\\n\");\n        else printf(\"YES\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// File Name: D.cpp\n// Author: YangYue\n// Created Time: Thu Oct 10 12:41:57 2013\n//headers \n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef pair<double,double> PDD;\ntypedef pair<LL, LL>PLL;\ntypedef pair<LL,int>PLI;\n\n#define lch(n) ((n<<1))\n#define rch(n) ((n<<1)+1)\n#define lowbit(i) (i&-i)\n#define sqr(x) ((x)*(x))\n#define fi first\n#define se second\n#define MP make_pair\n#define PB push_back\n\nconst int MaxN = 2005;\nconst double eps = 1e-8;\nconst double DINF = 1e100;\nconst int INF = 1000000006;\nconst LL LINF = 1000000000000000005ll;\n\nint dcmp(double x) { return x < -eps ? -1 : x > eps; }\nstruct Point {\n\tdouble x, y;\n\tPoint (){}\n\tPoint(double x, double y) : x(x), y(y) {}\n\tPoint operator - (const Point &b) { return Point(x - b.x, y - b.y); }\n\tPoint operator + (const Point &b) { return Point(x + b.x, y + b.y); }\n\tPoint operator * (const double &b) { return Point(x * b, y * b); }\n\tPoint operator / (const double &b) { return Point(x / b, y / b); }\n\tPoint rot90(int t) { return Point(-y, x) * t; }\n\tdouble operator * (const Point &b) { return x * b.y - y * b.x; }\n\tdouble operator % (const Point &b) { return x * b.x + y * b.y; }\n\tdouble len2() { return x * x + y * y; }\n\tdouble len() { return sqrt(x * x + y * y); }\n\tbool operator < (const Point &b) const {\n\t\tif (dcmp(x - b.x) != 0) return dcmp(x - b.x) < 0;\n\t\treturn dcmp(y - b.y) < 0;\n\t}\n\tvoid init() {\n\t\tscanf(\"%lf%lf\", &x, &y); \n\t}\n} p[MaxN];\nbool on_line(Point p, Point p1, Point p2) {\n\treturn dcmp((p - p1) * (p - p2)) == 0;\n}\npair<Point, int> keys[MaxN];\nbool yes[2][2];\nbool check(Point s, Point e, int n, int m) {\n\tint keysize = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (on_line(p[i], s, e)) keys[keysize++] = make_pair(p[i], i < m ? 0 : 1);\n\t}\n\tsort(keys, keys + keysize);\n\tint i = 0, j = 0;\n\tfor (; i < keysize && keys[i].second == keys[0].second; ++i);\n\tfor (j = i; j < keysize && keys[i].second == keys[j].second; ++j);\n\tif (j < keysize) return 0;\n\tmemset(yes, 0, sizeof yes);\n\tfor (int i = 0; i < n; ++i) {\n\t\tif ((e - s) * (p[i] - s) > eps) {\n\t\t\tint t = i < m ? 0 : 1;\n\t\t\tyes[0][t] = 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tif ((e - s) * (p[i] - s) < -eps) {\n\t\t\tint t = i < m ? 0 : 1;\n\t\t\tyes[1][t] = 1;\n\t\t}\n\t}\n\tif (yes[0][0] && yes[0][1]) return 0;\n\tif (yes[1][0] && yes[1][1]) return 0;\n\tif (yes[0][1] && yes[1][1]) return 0;\n\tif (yes[0][0] && yes[1][0]) return 0;\n\treturn 1;\n}\nint main()\n{\n\t//freopen(\"in\",\"r\",stdin);\n\n\tint n, m;\n\twhile (1) {\n\t\tscanf(\"%d%d\", &n,&m); if (n == 0 && m == 0) break;\n\t\tfor (int i = 0; i < n + m; ++i) p[i].init();\n\t\tbool yes = 0;\n\t\tfor (int i = 0; i < n + m; ++i) {\n\t\t\tfor (int j = i + 1; j < n + m; ++j) {\n\t\t\t\tif (check(p[i], p[j], n + m, n)) {\n\t\t\t\t\tyes = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (yes) break;\n\t\t}\n\t\tif (yes) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\n\treturn 0;\n}\n\n// hehe ~"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <complex>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\nusing std::complex;\ntypedef complex<double> P;\n\nconst double EPS = 1e-9;\n\nclass Line{\npublic:\n  P p; /* position */\n  P d; /* direction */\n  Line(){}\n  Line(P pos, P dir){p=pos; d=dir/abs(dir);}\n};\n\ninline double outp(const P &a, const P &b){\n  return (conj(a)*b).imag();\n}\n\ninline double inp(const P &a, const P &b){\n  return (conj(a)*b).real();\n}\n\ninline double sign(double a){ return a > 0.0 ? 1 : 0; }\n\nint main(){\n  while(true){\n    int n = getInt();\n    int m = getInt();\n    \n    if(n + m == 0) break;\n\n    vector<P> w(n);\n    vector<P> b(m);\n\n    REP(i,n){ w[i].real() = getInt(); w[i].imag() = getInt(); }\n    REP(i,m){ b[i].real() = getInt(); b[i].imag() = getInt(); }\n\n    bool ans = false;\n    const P dang[2] = {\n      P(cos(EPS), sin(EPS)),\n      P(cos(EPS), -sin(EPS))\n    };\n\n    REP(i,n) REP(j,m){\n      P mid = (w[i] + b[j]) / 2.0;\n      P dir = b[j] - mid;\n\n      REP(k,2){\n\tP dir2 = dir * dang[k];\n\tLine l = Line(mid, dir2);\n\n\tint expw = sign(outp(l.d, w[i] - l.p));\n\tint expb = sign(outp(l.d, b[j] - l.p));\n\n\tREP(ii,n) if(sign(outp(l.d, w[ii] - l.p)) != expw) goto next;\n\tREP(ii,m) if(sign(outp(l.d, b[ii] - l.p)) != expb) goto next;\n\n\tans = true;\n\tgoto fin;\n      next:;\n      }\n    }\n  fin:;\n    puts(ans ? \"YES\" : \"NO\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\n#define EPS 1e-7\n\ntypedef complex<double> point;\ntypedef const point &refpoint;\n\n\ndouble dot(refpoint a, refpoint b){\n\treturn real(a) * real(b) + imag(a) * imag(b);\n}\n\ndouble cross(refpoint a, refpoint b){\n\treturn real(a) * imag(b) - imag(a) * real(b);\n}\n\ndouble distance_l_p(refpoint a, refpoint b, refpoint c){\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\ndouble distance_ls_p(refpoint a, refpoint b, refpoint c){\n\tif( dot(b - a, c - a) <= 0.0 ) return abs(c - a);\n\tif( dot(a - b, c - b) <= 0.0 ) return abs(c - b);\n\treturn distance_l_p(a, b, c);\n}\n\nbool contains(const vector<point> &plg, refpoint pts){\n\tint cnt = 0;\n\tdouble y = imag(pts);\n\n\tfor(int i = 0; i < plg.size(); ++i){\n\t\tint j = (i + 1 == plg.size() ? 0: i + 1);\n\n\t\tdouble dyi = imag(plg[i]) - y;\n\t\tdouble dyj = y - imag(plg[j]);\n\t\tdouble tx = (dyi * real(plg[j]) + dyj * real(plg[i])) / (dyi + dyj);\n\n\t\tif(imag(plg[i]) >= y && imag(plg[j]) < y){\n\t\t\tif( tx < real(pts) ) ++cnt;\n\t\t}\n\t\telse if(imag(plg[i]) < y && imag(plg[j]) >= y){\n\t\t\tif( tx < real(pts) ) --cnt;\n\t\t}\n\t}\n\t\n\treturn (cnt % 2 != 0);\n}\n\nbool intersected(refpoint pa1, refpoint pa2, refpoint pb1, refpoint pb2){\n\tdouble a = cross(pa2 - pa1, pb1 - pa1);\n\tdouble b = cross(pa2 - pa1, pb2 - pa1);\n\tdouble c = cross(pb2 - pb1, pa1 - pb1);\n\tdouble d = cross(pb2 - pb1, pa2 - pb1);\n\n\tif( (a < -EPS && b > EPS) || (b < -EPS && a > EPS) ){\n\t\tif( (c < -EPS && d > EPS) || (d < -EPS && c > EPS) ){\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nbool contact(const vector<point> &plg1, const vector<point> &plg2){\n/*\n\tif( contains(plg1, plg2[0]) || contains(plg2, plg1[0]) ){\n\t\treturn true;\n\t}\n*/\n\n\tint n = plg1.size();\n\tint m = plg2.size();\n\tfor(int i = 0; i < n; ++i){\n\t\tfor(int j = 0; j < m; ++j){\n\t\t\tif( intersected(plg1[i], plg1[(i+1)%n], plg2[j], plg2[(j+1)%m]) ){\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif( distance_ls_p(plg1[i], plg1[(i+1)%n], plg2[j]) < EPS ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif( distance_ls_p(plg2[j], plg2[(j+1)%m], plg1[i]) < EPS ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor(int i = 0; i < n; ++i)\n\t\tif( contains(plg2, plg1[i]) ) return true;\n\tfor(int j = 0; j < m; ++j)\n\t\tif( contains(plg1, plg2[j]) ) return true;\n\n\treturn false;\n}\n\n\nbool orderbyreal(refpoint p1, refpoint p2){\n\treturn real(p1) < real(p2);\n}\n\n\nvector<point> convex(vector<point> plg){\n\tint n = plg.size();\n\tif( n <= 3 ){\n\t\treturn plg;\n\t}\n\n\tsort(plg.begin(), plg.end(), orderbyreal);\n\n\tvector<point> ret(2 * n);\n\tint k = 0;\n\n\tfor(int i = 0; i < n; ++i){\n\t\twhile( k >= 2 && cross( ret[k-1] - ret[k-2], plg[i] - ret[k-2] ) <= 0.0 ){\n\t\t\t--k;\n\t\t}\n\t\tret[k++] = plg[i];\n\t}\n\n\tint t = k + 1;\n\tfor(int i = n - 2; i >= 0; --i){\n\t\twhile( k >= t && cross( ret[k-1] - ret[k-2], plg[i] - ret[k-2] ) <= 0.0 ){\n\t\t\t--k;\n\t\t}\n\t\tret[k++] = plg[i];\n\t}\n\tret.resize(k - 1);\n\t\n\treturn ret;\n}\n\n\nint main(){\n\tint n, m;\n\tdouble x, y;\n\t\n\twhile( scanf(\"%d%d\", &n, &m), n != 0 ){\n\t\tvector<point> black, white;\n\t\tblack.reserve(n);\n\t\twhite.reserve(m);\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\tblack.push_back( point(x, y) );\n\t\t}\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\twhite.push_back( point(x, y) );\n\t\t}\n\n\n\t\tblack = convex(black);\n\t\twhite = convex(white);\n\n\t\tif( contact(black, white) ){\n\t\t\tputs(\"NO\");\n\t\t}\n\t\telse{\n\t\t\tputs(\"YES\");\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tvector<Polygon>polys;\n\tpolys.push_back(Q);\n\tpolys.push_back(R);\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\n#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\n\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<Point>wps, bps;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tPoint wp(input_point());\n\t\t\twps.push_back(wp);\n\t\t}\n\t\tfor (int i = 0; i <M; ++i) {\n\t\t\tPoint bp(input_point());\n\t\t\tbps.push_back(bp);\n\t\t}\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tLine wl(wps[i], wps[j]);\n\t\t\t\tfor (int k = 0; k < M; ++k) {\n\t\t\t\t\tif (isis_sp(wl, bps[k])) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tgoto a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tfor (int j = i + 1; j < M; ++j) {\n\t\t\t\tLine bl(bps[i], bps[j]);\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tif (isis_sp(bl, wps[k])) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tgoto a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tPolygon bpoly(convex_hull(bps));\n\t\tPolygon wpoly(convex_hull(wps));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (is_in_polygon(bpoly, wps[i])) {\n\t\t\t\tok = false;\n\t\t\t\tgoto a;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (is_in_polygon(wpoly, bps[i])) {\n\t\t\t\tok = false;\n\t\t\t\tgoto a;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < wpoly.size(); ++i) {\n\t\t\tLine wl(wpoly[i], wpoly[(i + 1)% wpoly.size()]);\n\t\t\tfor (int j = 0; j < bpoly.size(); ++j) {\n\t\t\t\tLine bl(bpoly[j], bpoly[(j + 1) % bpoly.size()]);\n\t\t\t\tif (isis_ss(wl, bl))ok = false;\n\t\t\t}\n\t\t}\n\ta:0;\n\t\tif (ok)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 100\n\nclass Point{\npublic:\n\tdouble x,y;\n\n\tPoint(double x = 0,double y = 0):x(x),y(y){}\n\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y); }\n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a){ return Point(a*x,a*y); }\n\tPoint operator / (double a){ return Point(x/a,y/a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator<(const Point &arg) const{ //sortする際にはこのメソッドが必要\n\t\tif(y != arg.y)return y < arg.y;\n\t\treturn x < arg.x;\n\t};\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n};\n\nstruct Line{\n\tLine(Point a,Point b){\n\t\tp[0] = a;\n\t\tp[1] = b;\n\t}\n\tPoint p[2];\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nint num_point,Q;\nint num_black,num_white;\nPoint black[NUM],white[NUM];\nvector<Point> UP_BLACK,DOWN_BLACK,UP_WHITE,DOWN_WHITE;\n\n\ndouble norm(Vector a){\n\treturn a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a){\n\treturn sqrt(norm(a));\n}\n\n//ベクトルaとbの外積を求める関数\ndouble cross(Vector a,Vector b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\n//ベクトルaとbの内積を求める関数\ndouble dot(Vector a,Vector b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\nPoint calc_minus(Point a,Point b){\n\tPoint ret;\n\n\tret.x = a.x-b.x;\n\tret.y = a.y-b.y;\n\n\treturn ret;\n}\n\n/*\n * IN 2\n * ON 1\n * OUT 0\n *\n */\nint contains(Polygon g,Point p){\n\tint n = g.size();\n\tbool x = false;\n\tfor(int i = 0; i < n; i++){\n\t\tPoint a = g[i]-p,b = g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b)) < EPS && dot(a,b) < EPS)return 1;\n\t\tif(a.y > b.y)swap(a,b);\n\t\tif(a.y < EPS && EPS < b.y && cross(a,b) > EPS) x = !x;\n\t}\n\treturn (x ? 2:0);\n}\n\n//trueなら凸\nbool calcGaiseki(Point left,Point base, Point right){\n\tdouble gaiseki = (left.x-base.x)*(right.y - base.y)-(left.y-base.y)*(right.x-base.x);\n\tif(gaiseki < -0.00000001)return false;\n\telse{\n\t\treturn true;\n\t}\n}\n\nint func(double x1,double y1,double x2, double y2, double xp, double yp){\n\tdouble naiseki,norm1,norm2,gaiseki;\n\tnorm1 = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n\tnorm2 = sqrt((xp-x1)*(xp-x1)+(yp-y1)*(yp-y1));\n\tnaiseki = (xp-x1)*(x2-x1)+(yp-y1)*(y2-y1);\n\tgaiseki = (x2-x1)*(yp-y1)-(xp-x1)*(y2-y1);\n\tif(gaiseki > EPS){\n\t\treturn 1;\n\t}else if(gaiseki < -EPS){\n\t\treturn -1;\n\t}\n\tif(naiseki < -EPS){\n\t\treturn 2;\n\t}\n\n\tif(norm1 < norm2){\n\t\treturn -2;\n\t}\n\treturn 0;\n}\n\nbool is_Cross(Line a,Line b){\n\n\tif(func(a.p[0].x,a.p[0].y,a.p[1].x,a.p[1].y,b.p[0].x,b.p[0].y)*\n\t\t\tfunc(a.p[0].x,a.p[0].y,a.p[1].x,a.p[1].y,b.p[1].x,b.p[1].y) <= 0 &&\n\t\t\tfunc(b.p[0].x,b.p[0].y,b.p[1].x,b.p[1].y,a.p[0].x,a.p[0].y)*\n\t\t\tfunc(b.p[0].x,b.p[0].y,b.p[1].x,b.p[1].y,a.p[1].x,a.p[1].y) <= 0){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n//他角形g1とg2が交差するかどうか調べる関数\nbool intersect(const Polygon g1,const Polygon g2){\n\n\tint size_1 = g1.size(),size_2 = g2.size();\n\n\tfor(int i = 0; i < size_1; i++){\n\t\tfor(int k = 0; k < size_2; k++){\n\t\t\tif(is_Cross(Line(g1[i],g1[(i+1)%size_1]),Line(g2[k],g2[(k+1)%size_2]))){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < size_1; i++){\n\t\tif(contains(g2,g1[i]))return true;\n\t}\n\n\tfor(int i = 0; i < size_2; i++){\n\t\tif(contains(g1,g2[i]))return true;\n\t}\n\n\treturn false;\n}\n\n\nvoid func(){\n\n\tUP_BLACK.clear();\n\tUP_WHITE.clear();\n\tDOWN_BLACK.clear();\n\tDOWN_WHITE.clear();\n\n\t//黒を線分で囲む\n\tfor(int i = 0; i < num_black; i++){\n\t\tscanf(\"%lf %lf\",&black[i].x,&black[i].y);\n\t}\n\n\tif(num_black > 1){\n\n\t\tsort(black,black+num_black);\n\n\t\tUP_BLACK.push_back(black[0]);\n\t\tUP_BLACK.push_back(black[1]);\n\n\t\tDOWN_BLACK.push_back(black[num_black-1]);\n\t\tDOWN_BLACK.push_back(black[num_black-2]);\n\n\t\tfor(int i = 2; i < num_black; i++){\n\t\t\twhile(UP_BLACK.size() > 1 && calcGaiseki(UP_BLACK[UP_BLACK.size()-2],UP_BLACK[UP_BLACK.size()-1],black[i]) == false)UP_BLACK.pop_back();\n\t\t\tUP_BLACK.push_back(black[i]);\n\t\t}\n\n\t\tfor(int i = num_black-3; i >= 0; i--){\n\t\t\twhile(DOWN_BLACK.size() > 1 && calcGaiseki(DOWN_BLACK[DOWN_BLACK.size()-2],DOWN_BLACK[DOWN_BLACK.size()-1],black[i]) == false){\n\t\t\t\tDOWN_BLACK.pop_back();\n\t\t\t}\n\t\t\tDOWN_BLACK.push_back(black[i]);\n\t\t}\n\t}\n\n\tPolygon g_black;\n\n\tfor(int i = DOWN_BLACK.size()-1; i >= 1;i--)g_black.push_back(DOWN_BLACK[i]);\n\tfor(int i = UP_BLACK.size()-1; i >= 1 ;i--)g_black.push_back(UP_BLACK[i]);\n\n\t//白を線分で囲む\n\tfor(int i = 0; i < num_white; i++){\n\t\tscanf(\"%lf %lf\",&white[i].x,&white[i].y);\n\t}\n\n\tif(num_white > 1){\n\t\tsort(white,white+num_white);\n\n\t\tUP_WHITE.push_back(white[0]);\n\t\tUP_WHITE.push_back(white[1]);\n\n\t\tDOWN_WHITE.push_back(white[num_white-1]);\n\t\tDOWN_WHITE.push_back(white[num_white-2]);\n\n\t\tfor(int i = 2; i < num_white; i++){\n\t\t\twhile(UP_WHITE.size() > 1 && calcGaiseki(UP_WHITE[UP_WHITE.size()-2],UP_WHITE[UP_WHITE.size()-1],white[i]) == false)UP_WHITE.pop_back();\n\t\t\tUP_WHITE.push_back(white[i]);\n\t\t}\n\n\t\tfor(int i = num_white-3; i >= 0; i--){\n\t\t\twhile(DOWN_WHITE.size() > 1 && calcGaiseki(DOWN_WHITE[DOWN_WHITE.size()-2],DOWN_WHITE[DOWN_WHITE.size()-1],white[i]) == false){\n\t\t\t\tDOWN_WHITE.pop_back();\n\t\t\t}\n\t\t\tDOWN_WHITE.push_back(white[i]);\n\t\t}\n\t}\n\n\tPolygon g_white;\n\n\tfor(int i = DOWN_WHITE.size()-1; i >= 1;i--)g_white.push_back(DOWN_WHITE[i]);\n\tfor(int i = UP_WHITE.size()-1; i >= 1 ;i--)g_white.push_back(UP_WHITE[i]);\n\n\tif(g_black.size() > 1){\n\t\tfor(int i = 0; i < num_white; i++){\n\t\t\tif(contains(g_black,white[i]) != 0){\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(g_white.size() > 1){\n\t\tfor(int i = 0; i < num_black; i++){\n\t\t\tif(contains(g_white,black[i]) != 0){\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(intersect(g_black,g_white)){\n\t\tprintf(\"NO\\n\");\n\t}else{\n\t\tprintf(\"YES\\n\");\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&num_black,&num_white);\n\t\tif(num_black == 0 && num_white == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-8;\n\nnamespace std {\n  bool operator < (const P &a, const P &b) {\n    return a.real() != b.real()\n      ? a.real() < b.real()\n      : a.imag() < b.imag();\n  }\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble norm(P a) {\n  return dot(a, a);\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\nint ccw(P p0, P a, P b) {\n  a -= p0;\n  b -= p0;\n  if(cross(a, b) > EPS) return 1;\n  if(cross(a, b) < -EPS) return -1;\n  if(dot(a, b) < -EPS) return 2;\n  if(norm(a) < norm(b)) return -2;\n  return 0;\n}\n\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for(int i = 0; i < n; ch[k++] = ps[i++])\n    while(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for(int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])\n    while(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t   ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0);\n}\n\nbool isIn(vector<P> &g, P p) {\n  int n = g.size();\n  for(int i = 0; i < g.size(); ++i) {\n    if(ccw(g[i], g[(i+1)%n], p) != 1) return false;\n  }\n  return true;\n}\n\nbool isIntersect(vector<P> &u, vector<P> &v) {\n  int n = u.size();\n  int m = v.size();\n  for(int i = 0; i < u.size(); ++i) {\n    for(int j = 0; j < v.size(); ++j) {\n      if(isIntersect(u[i], u[(i+1)%n], v[j], v[(j+1)%m])) return true;\n    }\n  }\n  for(int i = 0; i < u.size(); ++i) {\n    if(isIn(v, u[i])) return true;\n  }\n  for(int j = 0; j < v.size(); ++j) {\n    if(isIn(u, v[j])) return true;\n  }\n  return false;\n}\n\nbool solve(vector<P> &u, vector<P> &v) {\n  u = convex_hull(u);\n  v = convex_hull(v);\n  return !isIntersect(u, v);\n}\n\nint main() {\n  int n, m;\n  while(cin >> n >> m && (n || m)) {\n    vector<P> u, v;\n    P p;\n    for(int i = 0; i < n; ++i) {\n      cin >> p.real() >> p.imag();\n      u.push_back(p);\n    }\n    for(int i = 0; i < m; ++i) {\n      cin >> p.real() >> p.imag();\n      v.push_back(p);\n    }\n    if(solve(u, v)) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tvector<Polygon>polys;\n\tpolys.push_back(Q);\n\tpolys.push_back(R);\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\n#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\n\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<Point>wps, bps;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tPoint wp(input_point());\n\t\t\twps.push_back(wp);\n\t\t}\n\t\tfor (int i = 0; i <M; ++i) {\n\t\t\tPoint bp(input_point());\n\t\t\tbps.push_back(bp);\n\t\t}\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tfor (int k = 0; k < M; ++k) {\n\t\t\t\t\tLine wl(wps[i], wps[j]);\n\t\t\t\t\tif (isis_sp(wl, bps[k]))ok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tfor (int j = i + 1; j < M; ++j) {\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tLine bl(bps[i], bps[j]);\n\t\t\t\t\tif (isis_sp(bl, wps[k]))ok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tPolygon bpoly(convex_hull(bps));\n\t\tPolygon wpoly(convex_hull(wps));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (is_in_polygon(bpoly, wps[i]))ok = false;\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (is_in_polygon(wpoly, bps[i]))ok = false;\n\t\t}\n\t\tfor (int i = 0; i < wpoly.size(); ++i) {\n\t\t\tLine wl(wpoly[i], wpoly[(i + 1)% wpoly.size()]);\n\t\t\tfor (int j = 0; j < bpoly.size(); ++j) {\n\t\t\t\tLine bl(bpoly[j], bpoly[(j + 1) % bpoly.size()]);\n\t\t\t\tif (isis_ss(wl, bl))ok = false;\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nstruct Point\n{\n    double x,y;\n    Point (double x=0, double y=0) :x(x),y(y) {}\n    void show() { cout<<\"(\"<<x<<\",\"<<y<<\")\"<<endl; }\n};\ntypedef Point Vector;\n\nbool operator < (const Point& A, const Point& B )\n{\n    return A.x < B.x || (A.x == B.x && A.y < B.y);\n}\nVector operator - ( Point A, Point B) { return Vector(A.x-B.x, A.y-B.y); }\ndouble Cross(Vector A, Vector B) { return A.x*B.y - B.x*A.y; }\n\nconst double eps = 1e-10;\nint dcmp(double x)\n{\n    if(fabs(x) < eps) return 0;\n    return x>0? 1: -1;\n}\n\nint ConvexHull ( Point* p, int n, Point* ch)\n{\n    sort(p, p+n);\n    int m = 0;\n    for(int i = 0; i<n; i++)\n    {\n        while(m > 1 && Cross( ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0) m--;\n        ch[m++] = p[i];\n    }\n    int k = m;\n    for(int i = n-2; i>=0; i--)\n    {\n        while(m > k && Cross( ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0) m--;\n        ch[m++] = p[i];\n    }\n    ///霑倩ヲ∵隼荳?ク狗函謌仙、夊セケ蠖「縲?    ch[m++] = ch[0];\n    if(n > 1) m--;\n    return m;\n}\n\nPoint black[120],white[120],cw[120],cb[120];\nint nb,nw,n,m;\n\nvoid reset()\n{\n    memset(black,0,sizeof(black));\n    memset(white,0,sizeof(white));\n    memset(cw,0,sizeof(cw));\n    memset(cb,0,sizeof(cb));\n}\n\nbool SideCross(Point a1, Point a2, Point b1, Point b2)\n{\n    double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1),\n    c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1);\n    return dcmp(c1)*dcmp(c2)<0 && dcmp(c3)*dcmp(c4)<0;\n}\n\nbool pInConvex(Point a, Point* ch, int n)\n{\n    int i;\n    if(n==3)\n    {\n        if(a.x < min(ch[0].x, ch[1].x) || a.x > max(ch[0].x, ch[1].x)) return 0;\n        if(a.y < min(ch[0].y, ch[1].y) || a.y > max(ch[0].y, ch[1].y)) return 0;\n    }\n    for(i=1;i<n;i++)\n    {\n        if(Cross( ch[i]-ch[i-1], a-ch[i-1] ) < 0 ) return 0;\n    }\n    return 1;\n}\n\nint solve()\n{\n    int i,j;\n    if(n==1&&m==1) return 1;\n    else if(n==1)\n    {\n        ///謇セ逋ス蟄仙?蛹?、夊セケ蠖「縲ょ愛譁ュ霑吩クェ鮟大ュ先弍蜷ヲ蝨ィ逋ス蛹??\n        nw=ConvexHull(white, m, cw);\n        if(pInConvex(black[0], cw, nw)) return 0;\n    }\n    else if(m==1)\n    {\n        ///謇セ鮟大ュ仙?蛹?、夊セケ蠖「縲ょ愛譁ュ霑吩クェ逋ス蟄先弍蜷ヲ蝨ィ鮟大桁蜀?        nb=ConvexHull(black, n, cb);\n        if(pInConvex(white[0], cb, nb)) return 0;\n    }\n    else\n    {\n        ///謇セ鮟醍區蜃ク蛹?、夊セケ蠖「縲ょ愛譁ュ譏ッ蜷ヲ譛臥コソ谿オ逶ク莠、謌也せ蝨ィ蜿ヲ荳?クェ蜃ク蛹??縲?        nb=ConvexHull(black, n, cb);\n        nw=ConvexHull(white, m, cw);\n        for(i=1;i<nb;i++)\n        {\n            for(j=1;j<nw;j++)\n                if(SideCross( cb[i], cb[i-1], cw[j] ,cw[j-1] )) return 0;\n        }\n        for(i=0;i<n;i++)\n            if(pInConvex(black[i], cw, nw)) return 0;\n        for(i=0;i<m;i++)\n            if(pInConvex(white[i], cb, nb)) return 0;\n    }\n    return 1;\n}\n\nint main(){\n    int i,tx,ty;\n    while(cin>>n>>m,n||m){\n        reset();\n        for(i=0;i<n;i++){\n            cin>>tx>>ty;\n            black[i]=Point(tx,ty);\n        }\n        for(i=0;i<m;i++){\n            cin>>tx>>ty;\n            white[i]=Point(tx,ty);\n        }\n        int ans=solve();\n        if(ans)\n            cout<<\"YES\"<<endl;\n        else\n            cout<<\"NO\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\ntypedef pair<double, double> P;\nint f(double w[], P p){\n  double v = w[0] + w[1] * p.first + w[2] * p.second;\n  if(v >= 0) return 1;\n  else return 0;\n}\n\nint main(){\n  int b, w;\n  while(cin>>b>>w && (b != 0 || w != 0)){\n    vector<P> points_b, points_w;\n    REP(i, b){\n      double x, y; cin>>x>>y;\n      points_b.push_back(P(x, y));\n    }\n    REP(i, w){\n      double x, y; cin>>x>>y;\n      points_w.push_back(P(x, y));\n    }\n    double we[3] = {};\n    double rate = 1;\n    bool ans = false;\n    REP(iter, 28000000/(w + b)){\n      bool update = false;\n      REP(i, b){\n        int v = f(we, points_b[i]);\n        if(v == 1){\n          we[0] = we[0] + rate * -1;\n          we[1] = we[1] + rate * -1 * points_b[i].first;\n          we[2] = we[2] + rate * -1 * points_b[i].second;\n          update = true;\n        }\n      }\n      REP(i, w){\n        int v = f(we, points_w[i]);\n        if(v == 0){\n          we[0] = we[0] + rate * 1;\n          we[1] = we[1] + rate * 1 * points_w[i].first;\n          we[2] = we[2] + rate * 1 * points_w[i].second;\n          update = true;\n        }\n      }\n      if(!update){\n        ans = true;\n        break;\n      }\n    }\n    if(ans) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Hello. I'm Peter.\n#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<functional>\n#include<cctype>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define peter cout<<\"i am peter\"<<endl\n#define input freopen(\"data.txt\",\"r\",stdin)\n#define randin srand((unsigned int)time(NULL))\n#define INT (0x3f3f3f3f)*2\n#define LL (0x3f3f3f3f3f3f3f3f)*2\n#define gsize(a) (int)a.size()\n#define len(a) (int)strlen(a)\n#define slen(s) (int)s.length()\n#define pb(a) push_back(a)\n#define clr(a) memset(a,0,sizeof(a))\n#define clr_minus1(a) memset(a,-1,sizeof(a))\n#define clr_INT(a) memset(a,INT,sizeof(a))\n#define clr_true(a) memset(a,true,sizeof(a))\n#define clr_false(a) memset(a,false,sizeof(a))\n#define clr_queue(q) while(!q.empty()) q.pop()\n#define clr_stack(s) while(!s.empty()) s.pop()\n#define rep(i, a, b) for (int i = a; i < b; i++)\n#define dep(i, a, b) for (int i = a; i > b; i--)\n#define repin(i, a, b) for (int i = a; i <= b; i++)\n#define depin(i, a, b) for (int i = a; i >= b; i--)\n#define pi acos(-1.0)\n#define eps 1e-6\n#define MOD 1000000007\n#define MAXN\n#define N 10100\n#define M\nint dcmp(double x){//蛻、譁ュx豁」雍滓?荳コ0\n    if(fabs(x)<eps) return 0;\n    else if(x<0) return -1;\n    else return 1;\n}\nstruct Point{\n    double x,y;\n    Point(){};\n    Point(double xx,double yy):x(xx),y(yy){};\n    friend bool operator<(const Point a,const Point b){\n        if(dcmp(a.x-b.x)!=0) return a.x<b.x;\n        else return a.y<b.y;\n    }\n};\ntypedef Point Vector;\nvoid readPoint(Point &a){//霎灘?荳?クェ轤ケ\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    a.x=x;\n    a.y=y;\n}\ndouble sq(double x){//x^2\n    return x*x;\n}\nVector operator +(const Vector a,const Vector b){//荳、蜷鷹?逶ク蜉?    return Vector(a.x+b.x,a.y+b.y);\n}\nVector operator -(const Vector a,const Vector b){//荳、蜷鷹?逶ク蜃?    return Vector(a.x-b.x,a.y-b.y);\n}\nbool operator ==(const Vector a,const Vector b){//蛻、譁ュ荳、轤ケ謌紋ク、蜷鷹?譏ッ蜷ヲ荳??\n    return dcmp(a.x-b.x)==0 && dcmp(a.y-b.y)==0;\n}\ndouble operator *(const Vector a,const Vector b){//荳、蜷鷹?轤ケ荵?    return a.x*b.x+a.y*b.y;\n}\ndouble operator &(const Vector a,const Vector b){//荳、蜷鷹?蜿臥ァッ\n    return a.x*b.y-a.y*b.x;\n}\nVector operator *(const Vector b,const double a){//荳?クェ謨ー*荳?クェ蜷鷹?\n    return Vector(a*b.x,a*b.y);\n}\nVector operator *(const double a,const Vector b){//荳?クェ蜷鷹?*荳?クェ謨ー\n    return Vector(a*b.x,a*b.y);\n}\nPoint MiddlePoint(Point a,Point b){//豎ゆク、轤ケ逧?クュ轤ケ\n    return Point((a.x+b.x)/2,(a.y+b.y)/2);\n}\ndouble Length(Vector b){//豎ゆク?クェ蜷鷹?逧?柄蠎ヲ\n    return sqrt(b*b);\n}\ndouble DistancePointToPoint(Point a,Point b){//豎らせ蛻ー轤ケ逧?裏蜷題キ晉ヲサ\n    return Length(a-b);\n}\ndouble DistancePointToLine(Point p,Point a,Vector v){//豎らせ蛻ー郤ソ逧?裏蜷題キ晉ヲサ\n    Vector w=p-a;\n    return fabs((v&w)/Length(v));\n}\nPoint Point_LineBananaLine(Point p1,Vector v,Point p2,Vector w){//豎ゆク、郤ソ逧?コ、轤ケ(蜑肴署譏ッ荳、蜷鷹?荳榊?郤ソ)\n    Vector u=p1-p2;\n    double t=(w&u)/(v&w);\n    return p1+v*t;\n}\ndouble polarAngle(Vector a,Vector b){//豎ゆク、荳ェ蜷鷹?逧?裏蜷第栫隗?0<=x<=pi)\n    double t=(a*b)/Length(a)/Length(b);\n    return acos(t);\n    //閠径tan2(double y,double x)豎ら噪譏ッ荳?クェ蜷鷹?荳支霓エ逧?怏蜷第栫隗?-pi<x<=pi)\n}\nint ConvexHull(Point *p,int n,Point *ch){\n    sort(p,p+n);\n    int m=0;\n    rep(i,0,n){\n        while(m>1 && dcmp((ch[m-1]-ch[m-2])&(p[i]-ch[m-2]))<=0) m--;\n        ch[m++]=p[i];\n    }\n    int k=m;\n    depin(i,n-2,0){\n        while(m>k && dcmp((ch[m-1]-ch[m-2])&(p[i]-ch[m-2]))<=0) m--;\n        ch[m++]=p[i];\n    }\n    if(n>1) m--;\n    return m;\n}\nbool SegmentStrictlyBananaSegment(Point p1,Point p2,Point w1,Point w2){//蛻、譁ュ荳、郤ソ谿オ譏ッ蜷ヲ荳・譬シ鬥呵負(荳榊桁諡ャ遶ッ轤ケ)\n    double x1=(w2-w1)&(p1-w1);\n    double x2=(w2-w1)&(p2-w1);\n    double x3=(p2-p1)&(w1-p1);\n    double x4=(p2-p1)&(w2-p1);\n    return dcmp(x1)*dcmp(x2)<0 && dcmp(x3)*dcmp(x4)<0;\n}\nbool ConvexHullIntersection(Point *ch1,int t1,Point *ch2,int t2){//蛻、譁ュ蜃ク蛹?弍蜷ヲ逶ク莠、\n    double angle[N],x;\n    int i,j,k,m;\n    if(t1==1) return true;\n    if(t1==2){\n        for(i=0;i<t2;i++){\n            k=dcmp((ch1[1]-ch1[0])&(ch2[i]-ch1[0]));\n            if(k==0&&(ch1[1]-ch1[0])*(ch2[i]-ch1[0])>0){\n                if(Length(ch2[i]-ch1[0])<Length(ch1[1]-ch1[0]))break;\n            }\n        }\n        if(i<t2)return false;\n        if(t2==2 && SegmentStrictlyBananaSegment(ch1[0],ch1[1],ch2[0],ch2[1]))return false;\n        return true;\n    }\n    angle[0]=0;\n    for(i=2;i<t1;i++)\n        angle[i-1]=polarAngle(ch1[1]-ch1[0],ch1[i]-ch1[0]);\n    for(i=0;i<t2;i++)\n    {\n        j=dcmp((ch1[1]-ch1[0])&(ch2[i]-ch1[0]));\n        if(j<0||(j==0&&(ch1[1]-ch1[0])*(ch2[i]-ch1[0])<0))continue;\n        j=dcmp((ch1[t1-1]-ch1[0])&(ch2[i]-ch1[0]));\n        if(j>0||(j==0&&(ch1[t1-1]-ch1[0])*(ch2[i]-ch1[0])<0))continue;\n        x=polarAngle(ch1[1]-ch1[0],ch2[i]-ch1[0]);\n        m=(int)(lower_bound(angle,angle+t1-1,x)-angle);\n        if(m==0)j=0;\n        else j=m-1;\n        k=dcmp((ch1[j+1]-ch2[i])&(ch1[j+2]-ch2[i]));\n        if(k>=0)break;\n    }\n    if(i<t2)return false;\n    return true;\n}\nint n,m,num_ch1,num_ch2;\nPoint black[N],ch1[N],white[N],ch2[N];\nint main(){\n//    input;\n    while(~scanf(\"%d%d\",&n,&m) && (n+m)){\n        rep(i,0,n){\n            readPoint(black[i]);\n        }\n        num_ch1=ConvexHull(black,n,ch1);\n        rep(i,0,m){\n            readPoint(white[i]);\n        }\n        num_ch2=ConvexHull(white,m,ch2);\n        bool ok;\n        if(ConvexHullIntersection(ch1,num_ch1,ch2,num_ch2) && ConvexHullIntersection(ch2,num_ch2,ch1,num_ch1)){\n            ok=true;\n        }\n        else ok=false;\n        printf(\"%s\\n\",ok?\"YES\":\"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iomanip>\n\n#define REP(i,n) for(i=0; i < (n); i++)\n#define REPONE(i, n) for(i=1; i <= (n); i++)\n#define LOOP(n) for(int loopCount=1; loopCount <= (n); loopCount++)\n#define ITER(c) __typeof((c).begin())\n#define EACH(c,it) for(ITER(c) it =(c).begin(); it!=(c).end(); it++)\n#define SZ(c) ((int) (c).size())\n#define ALL(c) c.begin(), c.end()\n#define SUM(c) accumulate(ALL(c), 0)\n#define EXIST(c,v) (find(ALL(c), (v)) != (c).end())\n#define PB push_back\n#define MP make_pair\n\nusing namespace std;\nstatic const double EPS = 1e-8;\nstatic const double PI = 3.141592653589793238462643383279;\n\n/*\ntypedef complex<double> point;\n\ntemplate<typename T>\nint sig2(T x){\n    if(abs(x)<EPS) return 0;\n    if(x>0) return 1;\n    return -1;\n}\n\ndouble det(point p1, point p2, point q){\n    return p2.real()*q.imag()+p1.real()*p2.imag()+q.real()*p1.imag()\n            -p2.real()*p1.imag()-q.real()*p2.imag()-q.imag()*p1.real();\n}\nint main(){\n    int i,j,k,n,m;\n    double x,y,bxma,byma,bxmi,bymi,wxma,wyma,wxmi,wymi;\n    bool yes;\n    while(scanf(\"%d%d\",&n,&m)){\n        if(n==0 && m==0) break;\n        bxma=byma=wxma=wyma=-1e99;\n        bxmi=bymi=wxmi=wymi=1e99;\n        yes=false;\n        vector<point> bs(n), ws(m);\n        REP(i,n){\n            scanf(\"%lf%lf\",&x,&y);\n            bs[i]=point(x,y);\n            bxma=max(bxma, x);\n            byma=max(byma, y);\n            bxmi=min(bxmi, x);\n            bymi=min(bymi, y);\n        }\n        REP(i,m){\n            scanf(\"%lf%lf\",&x,&y);\n            ws[i]=point(x,y);\n            wxma=max(wxma, x);\n            wyma=max(wyma, y);\n            wxmi=min(wxmi, x);\n            wymi=min(wymi, y);\n        }\n        if(bxma<wxmi||bxmi>wxma||byma<wymi||bymi>wyma){\n            printf(\"YES\\n\");\n            continue;\n        }\n        if(n==1 && m==1){\n            printf(\"YES\\n\");\n            continue;\n        }\n        int w=0, b;\n        REP(i,n)for(j=i+1;j<n;j++){\n            w = 0;\n            REP(k,m) w+=sig2(det(bs[i],bs[j],ws[k]));\n            if(abs(w)<m)break;\n            REP(k,n)if(sig2(det(bs[i],bs[j],bs[k]))==sig2(w))break;\n            if(k==n){\n                yes = true;\n                goto end;\n            }\n        }\n        swap(n,m);\n        swap(bs,ws);\n        REP(i,n)for(j=i+1;j<n;j++){\n            w = 0;\n            REP(k,m) w+=sig2(det(bs[i],bs[j],ws[k]));\n            if(abs(w)<m)break;\n            REP(k,n)if(sig2(det(bs[i],bs[j],bs[k]))==sig2(w))break;\n            if(k==n){\n                yes = true;\n                goto end;\n            }\n        }\n        REP(i,n)REP(j,m){\n            w = b = 0;\n            REP(k,m) w+=sig2(det(bs[i],ws[j],ws[k]));\n            if(abs(w)<m-1)break;\n            REP(k,n) b+=sig2(det(bs[i],ws[j],bs[k]));\n            if(abs(b)<n-1)break;\n            if(w*b<0){\n                yes = true;\n                goto end;\n            }\n        }\n        end:;\n        if(yes)printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n    return 0;\n}\n*/\n\n#define N 50000\n\nint main(){\n    int i,j,n,m;\n    double bma,bmi,wma,wmi,ang=PI/N,tmp;\n    static double bxs[100], wxs[100], bys[100], wys[100];\n    while(scanf(\"%d%d\",&n,&m)){\n        if(n==0 && m==0) break;\n        REP(i,n)scanf(\"%lf%lf\",bxs+i,bys+i);\n        REP(i,m)scanf(\"%lf%lf\",wxs+i,wys+i);\n        REP(i,N){\n            bma=wma=-1e99;\n            bmi=wmi=1e99;\n            REP(j,n){\n                tmp = cos(ang*i)*bxs[j]-sin(ang*i)*bys[j];\n                if(tmp<bmi)bmi=tmp;\n                if(tmp>bma)bma=tmp;\n            }\n            REP(j,m){\n                tmp = cos(ang*i)*wxs[j]-sin(ang*i)*wys[j];\n                if(bmi<tmp && tmp<bmi) break;\n                if(tmp<wmi)wmi=tmp;\n                if(tmp>wma)wma=tmp;\n            }\n            if(bma < wmi || wma < bmi) break;\n        }\n        if(i==N)printf(\"NO\\n\");\n        else printf(\"YES\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nusing Point = complex<double>;\nnamespace std { bool operator<(const Point& a, const Point& b) { return real(a) == real(b) ? imag(a) < imag(b) : real(a) < real(b); } }\ndouble cross(const Point& a, const Point& b) { return imag(conj(a)*b); }\ndouble dot(const Point& a, const Point& b) { return real(conj(a)*b); }\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersects(const Point& p1, const Point& p2, const Point& q1, const Point& q2) {\n    return ccw(p1, p2, q1) * ccw(p1, p2, q2) <= 0 &&\n           ccw(q1, q2, p1) * ccw(q1, q2, p2) <= 0;\n}\n\nint contains(const vector<Point> polygon, const Point& p) {\n    bool in = false;\n    REP(i, polygon.size()) {\n        Point a = polygon[i] - p;\n        Point b = polygon[(i+1) % polygon.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b))\n            if (cross(a, b) < 0)\n                in = !in;\n        if (cross(a, b) == 0 && dot(a, b) <= 0)\n            return 1;   // on the edge\n    }\n    return in ? 2 : 0;\n}\n\nvector<Point> convex_hull(vector<Point>& points) {\n    assert(points.size() >= 3);\n    vector<Point> convex(points.size() * 2);\n    sort(points.begin(), points.end());\n    int k = 0;\n    REP(i, points.size()) {\n        while (k >= 2 && ccw(points[i], convex[k-1], convex[k-2]) >= 0) --k;\n        convex[k++] = points[i];\n    }\n    int t = k+1;\n    for (int i = points.size()-2; i >= 0; --i) {\n        while (k >= t && ccw(points[i], convex[k-1], convex[k-2]) >= 0) --k;\n        convex[k++] = points[i];\n    }\n    convex.resize(k-1);\n    return convex;\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int n, m;\n    while (cin >> n >> m, n | m) {\n        vector<Point> blacks(n), whites(m);\n        REP(i, n) {\n            double x, y; cin >> x >> y;\n            blacks[i] = Point(x, y);\n        }\n        REP(i, m) {\n            double x, y; cin >> x >> y;\n            whites[i] = Point(x, y);\n        }\n\n        if (blacks.size() > whites.size())\n            swap(blacks, whites);\n        if (whites.size() >= 3)\n            whites = convex_hull(whites);\n        if (blacks.size() >= 3)\n            blacks = convex_hull(blacks);\n\n        if (blacks.size() == 1 && whites.size() == 1) {\n            cout << \"YES\\n\";\n        } else if (blacks.size() == 1 && whites.size() == 2) {\n            Point a = whites[0] - blacks[0];\n            Point b = whites[1] - blacks[0];\n            if (cross(a, b) == 0 && dot(a, b) <= 0)\n                cout << \"NO\\n\";\n            else\n                cout << \"YES\\n\";\n        } else if (blacks.size() == 2 && whites.size() == 2) {\n            if (intersects(blacks[0], blacks[1], whites[0], whites[1]))\n                cout << \"NO\\n\";\n            else\n                cout << \"YES\\n\";\n        } else {\n            bool ok = true;\n            REP(i, blacks.size()) {\n                if (contains(whites, blacks[i])) {\n                    ok = false;\n                    break;\n                }\n            }\n            REP(i, whites.size()) {\n                if (contains(blacks, whites[i])) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok)\n                cout << \"YES\\n\";\n            else\n                cout << \"NO\\n\";\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef pair<int,int> P;\n\n//for vector\ninline int norm(const P &a){ return a.fs*a.fs + a.sc*a.sc; }\ninline int dot(const P &a, const P &b){return a.fs*b.fs + a.sc*b.sc;}\ninline int cross(const P &a, const P &b){return a.fs*b.sc - a.sc*b.fs;}\n\ninline int ccw(const P &a,P b,P c){\n  b.fs -= a.fs; b.sc -= a.sc;\n  c.fs -= a.fs; c.sc -= a.sc;\n  if (cross(b,c)>0) return 1;   //counter clockwise\n  if (cross(b,c)<0) return -1; //clockwise\n  if (dot(b, c)<-0) return 2;   //c--a--b on line\n  if (norm(b)<norm(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n\n  int n,m;\n  P b[110],w[110];\n  while(cin >> n >> m){\n    if(n==0 && m==0)break;\n    rep(i,n)cin >> b[i].fs >> b[i].sc;\n    rep(i,m)cin >> w[i].fs >> w[i].sc;\n\n    bool ans = false;\n    rep(i,n)rep(j,i){\n      bool f = true;\n      set<int> dirb;\n      rep(k,n){\n\tif(k==i || k==j)continue;\n\tint tmp = ccw(b[i],b[j],b[k]);\n\tif(tmp == 0){f = false; break;}\n\tif(abs(tmp)==1){\n\t  dirb.insert(tmp);\n\t  if(dirb.size()==2){f = false; break;}\n\t}\n      }\n\n      if(f){\n\tset<int> dirw;\n\trep(k,m){\n\t  int tmp = ccw(b[i],b[j],w[k]);\n\t  if(abs(tmp) != 1){f = false; break;}\n\t  dirw.insert(tmp);\n\t  if(dirw.size()==2){f = false; break;}\n\t}\n\tif(f && (dirb.size()==0 || dirw.size()==0\n\t\t || *dirb.begin() != *dirw.begin()))ans = true;\n      }\n      if(ans)break;\n    }\n\n    rep(i,m)rep(j,i){\n      bool f = true;\n      set<int> dirw;\n      rep(k,m){\n\tif(k==i || k==j)continue;\n\tint tmp = ccw(w[i],w[j],w[k]);\n\tif(tmp == 0){f = false; break;}\n\tif(abs(tmp)==1){\n\t  dirw.insert(tmp);\n\t  if(dirw.size()==2){f = false; break;}\n\t}\n      }\n\n      if(f){\n\tset<int> dirb;\n\trep(k,n){\n\t  int tmp = ccw(w[i],w[j],b[k]);\n\t  if(abs(tmp) != 1){f = false; break;}\n\t  dirb.insert(tmp);\n\t  if(dirb.size()==2){f = false; break;}\n\t}\n\tif(f && (dirb.size()==0 || dirw.size()==0\n\t\t || *dirb.begin() != *dirw.begin()))ans = true;\n      }\n      if(ans)break;\n    }\n\n    rep(i,n)rep(j,m){\n      bool f = true;\n      set<int> dirb;\n      rep(k,n){\n\tif(k==i)continue;\n\tint tmp = ccw(b[i],w[j],b[k]);\n\tif(tmp == 0 || tmp == -2){f = false; break;}\n\tif(abs(tmp)==1){\n\t  dirb.insert(tmp);\n\t  if(dirb.size()==2){f = false; break;}\n\t}\n      }\n\n      if(f){\n\tset<int> dirw;\n\trep(k,m){\n\t  if(k==j)continue;\n\t  int tmp = ccw(b[i],w[j],w[k]);\n\t  if(tmp == 0 || tmp == 2){f = false; break;}\n\t  if(abs(tmp)==1){\n\t    dirw.insert(tmp);\n\t    if(dirw.size()==2){f = false; break;}\n\t  }\n\t}\t\n\tif(f && (dirb.size()==0 || dirw.size()==0\n\t\t || *dirb.begin() != *dirw.begin()))ans = true;\n      }\n      if(ans)break;\n    }\n\n    cout << (ans?\"YES\":\"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cassert>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-8\n#define F first\n#define S second\nusing namespace std;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point\n{\n  public:\n  double x,y;\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nbool isIntersect(Segment s1,Segment s2)\n{\nreturn isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool cmp(const vector<Point> &a,const vector<Point> &b)\n{\n  return a.size() < b.size();\n}\n\nPolygon andrewScan(Polygon s)\n{\n  Polygon u,l;\n  if(s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<s.size();i++)\n    {\n      for(int n=u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--)\n\tu.pop_back();\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3; i>=0 ; i--)\n    {\n      for(int n=l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--)\n\tl.pop_back();\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\nbool check(int p1,int p2,vector<Point> &black,vector<Point> &white)\n{\n  int n = black.size();\n  pair<bool,bool> Left,Right;\n  Left  = pair<bool,bool>(false,false); // F->black, S->white\n  Right = pair<bool,bool>(false,false);\n\n  rep(i,n)\n    {\n      if(i == p1 || i == p2)continue;\n      int res = ccw(black[p1],black[p2],black[i]);\n      if(res == CLOCKWISE) Right.F = true;\n      if(res == COUNTER_CLOCKWISE) Left.F = true;\n    }\n  \n  n = white.size();\n  rep(i,n)\n    {\n      int res = ccw(black[p1],black[p2],white[i]);\n      if(res == CLOCKWISE) Right.S = true;\n      if(res == COUNTER_CLOCKWISE) Left.S = true;\n    }\n\n  if(Left.F && Left.S)return false;\n  if(Right.F && Right.S)return false;\n  return true;\n}\n\nvoid printVP(vector<Point> a)\n{\n  cout << \"printVP-------\" << endl;\n  rep(i,a.size())cout << \"(\" << a[i].x << \",\" << a[i].y << \") \";\n  cout << endl;\n}\n\nint main()\n{\n  int n,m;\n  while(cin >> n >> m,n|m)\n    {\n      assert(n && m);\n      vector<Point> A(n),B(m);\n      rep(_,n)cin >> A[_].x >> A[_].y;\n      rep(_,m)cin >> B[_].x >> B[_].y;\n\n      vector<Point> black,white;\n      if(A.size() > B.size())\n\tblack = A,white = B;\n      else\n\tblack = B,white = A;\n\n      \n      if(n == 1 && m == 1)\n\t{\n\t  cout << \"YES\" << endl;\n\t  continue;\n\t}\n\n      if(black.size() == 2 && white.size() == 1)\n\t{\n\t  int res = ccw(black[0],black[1],white[0]);\n\t  if(res == ON_SEGMENT)cout << \"NO\" << endl;\n\t  else                 cout << \"YES\" << endl;\n\t  continue;\n\t}\n\n      if(black.size() == 2 && white.size() == 2)\n\t{\n\t  if(isIntersect(Segment(black[0],black[1]),Segment(white[0],white[1])))cout << \"NO\" << endl;\n\t  else                                                                  cout << \"YES\" << endl;\n\t  continue;\n\t}\n    \n      int N = black.size();\n      rep(i,N)\n\t{\n\t  if(check(i,(i+1)%N,black,white))\n\t    {\n\t      cout << \"YES\" << endl;\n\t      goto F;\n\t    }\n\t}\n      cout << \"NO\" << endl;\n    F:;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nconst double EPS = 1e-8;\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nvector<P> convex_hull(vector<P> v){\n  vector<P> c; //convex\n  sort(v.begin(),v.end());\n  c.assign(v.begin(),v.begin()+2);\n    \n  for(int i=2;i<v.size();i++){\n    P a = c[c.size()-1] - c[c.size()-2];\n    P b = v[i] - c[c.size()-2];\n        \n    while(cross(a,b) > EPS){\n      c.pop_back();\n      if(c.size() < 2) break;\n      a = c[c.size()-1] - c[c.size()-2];\n      b = v[i] - c[c.size()-2];\n    }\n        \n    c.push_back(v[i]);\n  }\n\t\n  int n = c.size();\n  c.push_back(v[v.size()-2]);\n\t\n  for(int i=v.size()-3;i>=0;i--){\n    P a = c[c.size()-1] - c[c.size()-2];\n    P b = v[i] - c[c.size()-2];\n        \n    while(cross(a,b) > EPS){\n      c.pop_back();\n      if(c.size() < n + 1) break;\n      a = c[c.size()-1] - c[c.size()-2];\n      b = v[i] - c[c.size()-2];\n    }\n        \n    c.push_back(v[i]);\n\t}\n  c.pop_back();\n  return c;\n}\n\nL get2points(vector<P> p){\n  \n  double dis=0;\n  int idx1, idx2;\n  \n  for(int i=0;i<p.size();i++){\n    for(int j=i+1;j<p.size();j++){\n      if(abs(p[j]-p[i])>dis){\n\tdis=abs(p[j]-p[i]);\n\tidx1=i;\n\tidx2=j;\n      }\n    }\n  }\n\n  return L(p[idx1],p[idx2]);\n}\n\nbool isIntersectSP(L s, P p){ \n  return abs(s.first-p) + abs(s.second-p) - abs(s.second-s.first) < EPS; \n}\n\nbool check(vector<P> p){\n  \n  L l=get2points(p);\n  \n  for(int i=0;i<p.size();i++)\n    if(!isIntersectSP(l,p[i])) return false;\n\n  return true;\n}\n\nbool isIntersect(L s1, L s2){\n  \n  //ccw ??????????????????????????¨, ????????????????????´?????????????????¨??????????????????????????????\n  if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\nint main(){\n  \n  while(1){\n    \n    int n, m;\n    cin>>n>>m;\n    \n    if(!n&&!m) break;\n    \n    vector<P> p1, p2;\n\n    for(int i=0;i<n;i++){\n      int a, b;\n      cin>>a>>b;\n      p1.push_back(P(a,b));\n    }\n    \n    for(int i=0;i<m;i++){\n      int a, b;\n      cin>>a>>b;\n      p2.push_back(P(a,b));\n    }\n\n    bool ans=true;\n\n    vector<P> v1, v2;\n    \n    if(p1.size()!=1){\n      \n      if(check(p1)){\n\tL l=get2points(p1);\n\tfor(int i=0;i<p2.size();i++)\n\t  if(isIntersectSP(l,p2[i])) ans=false;\n\tv1.push_back(l.first);\n\tv1.push_back(l.second);\n      }else{\n\tvector<P> p=convex_hull(p1);\n\t\n\tfor(int i=0;i<p2.size();i++){\n\t  int com=ccw(p[0],p[1],p2[i]);\n\t  int flag=0;\n\t  for(int j=0;j<p.size();j++)\n\t    if(com!=ccw(p[j],p[(j+1)%p.size()],p2[i])) flag=1;\n\t  if(flag==0) ans=false;\n\t}\n\t\n\tfor(int i=0;i<p.size();i++)\n\t  for(int j=0;j<p2.size();j++)\n\t    if(isIntersectSP(L(p[i],p[(i+1)%p.size()]),p2[j])) ans=false;\n\tv1=p;\n      }\n      \n    }\n    \n    if(p2.size()!=1){\n      \n      if(check(p2)){\n\tL l=get2points(p2);\n\tfor(int i=0;i<p1.size();i++)\n\t  if(isIntersectSP(l,p1[i])) ans=false;\n\tv2.push_back(l.first);\n\tv2.push_back(l.second);\n      }else{\n\tvector<P> p=convex_hull(p2);\n\t\n\tfor(int i=0;i<p1.size();i++){\n\t  int com=ccw(p[0],p[1],p1[i]);\n\t  int flag=0;\n\t  for(int j=0;j<p.size();j++)\n\t    if(com!=ccw(p[j],p[(j+1)%p.size()],p1[i])) flag=1;\n\t  if(flag==0) ans=false;\n\t}\n\n\tfor(int i=0;i<p.size();i++)\n\t  for(int j=0;j<p1.size();j++)\n\t    if(isIntersectSP(L(p[i],p[(i+1)%p.size()]),p1[j])) ans=false;\n\tv2=p;\n      }\n      \n    }\n    \n    if(p1.size()!=1&&p2.size()!=1){\n      \n      for(int i=0;i<v1.size();i++)\n\tfor(int j=0;j<v2.size();j++){\n\t  L l1=L(v1[i],v1[(i+1)%v1.size()]);\n\t  L l2=L(v2[j],v2[(j+1)%v2.size()]);\n\t  if(isIntersect(l1,l2)) ans=false;\n\t}\n      \n    }\n    \n    if(ans) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n    \n  }  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#define next(P, i) P[(i+1) % P.size()]\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n};\n\nbool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n\n  if(cross(a1-a2,b1-b2)==0){\n    return is_point_on_line(a1,a2,b1) || is_point_on_line(a1,a2,b2) \n        || is_point_on_line(b1,b2,a1) || is_point_on_line(b1,b2,a2);\n  }\n  else {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n           ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n  }\n}\n\nint contain(point p, vector<point> ps){\n  point a(p.x,p.y),b(1000000,p.y);\n\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<ps.size();i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(a.y<=ymn||a.y>=ymx)return 0;\n\n  int cnt1=0;\n  for(int i=0;i<ps.size();i++)\n    if(is_point_on_line(a,b,ps[i]))cnt1++;\n  \n  int cnt=0;\n  for(int i=0;i<ps.size();i++)\n    if(is_intersected_ls(ps[i],next(ps,i),a,b))cnt++;\n\n  return (cnt-cnt1)%2;\n}\n\nint crossPol(vector<point> pol1, vector<point> pol2){\n  \n  for(int i=0;i<pol1.size();i++)\n    if(contain(pol1[i],pol2))return 1;\n  \n  for(int i=0;i<pol2.size();i++)\n    if(contain(pol2[i],pol1))return 1;\n  \n  for(int i=0;i<pol1.size();i++)\n    for(int j=0;j<pol2.size();j++)\n      if(is_intersected_ls(pol1[i],next(pol1,i),pol2[j],next(pol2,j)))return 1;\n  \n  return 0;\n}\n\nvector<point>convex_hull(point* ps, int n){\n  sort(ps,ps+n,cmp_x);\n  int k=0;\n  vector<point>qs(n*2);\n \n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0)k--;\n    qs[k++]=ps[i];\n  }\n \n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0)k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nint main(void){\n  int n,m;\n  point black[100],white[100];\n\n  while(cin >> n >> m,n|m){\n\n    for(int i=0;i<n;i++)\n      cin >> black[i].x >> black[i].y;\n    \n    for(int i=0;i<m;i++)\n      cin >> white[i].x >> white[i].y;\n\n    if(n<2||m<2){\n      if(n<2 && m<2)cout << \"YES\" << endl;\n      else {\n\tbool fg=false;\n\tfor(int i=0;i<n;i++){\n\t  for(int j=0;j<m;j++){\n\t    if(is_intersected_ls(black[i],black[(i+1)%n],white[j],white[(j+1)%n]))fg=true;\n\t  }\n\t}\n\tif(fg)cout <<\"NO\"<<endl;\n\telse cout << \"YES\" << endl;\n      }\n      continue;\n    }\n\n    vector<point>Black,White;\n\n    Black=convex_hull(black,n);\n    White=convex_hull(white,m);\n    \n    if(crossPol(Black,White))cout << \"NO\" << endl;\n    else cout << \"YES\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\n\nconstexpr ld eps = 1e-8;\n\n\nnamespace geometry2d {\n\n\nusing point = std::complex<long double>;\nusing polygon = std::vector<point>;\n\n\nbool eq(long double a, long double b) {\n    return (std::abs(a-b) < eps);\n}\n\nlong double dot(point a, point b) {\n    return std::real(std::conj(a) * b);\n}\n\nlong double cross(point a, point b) {\n    return std::imag(std::conj(a) * b);\n}\n\n\nclass segment {\npublic:\n    segment()\n        : a(point(0, 0)),\n          b(point(0, 0))\n    {}\n    segment(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n\n    point a, b;\n};\n\nclass line {\npublic:\n    line()\n        : a(point(0, 0)), b(point(0, 0))\n    {}\n    line(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n    line(segment s)\n        : a(s.a), b(s.b)\n    {}\n\n    point a, b;\n};\n\nclass circle {\npublic:\n    circle()\n        : p(point(0, 0)), r(0)\n    {}\n    circle(point p_, long double r_)\n        : p(p_), r(r_)\n    {}\n\n    point p;\n    long double r;\n};\n\n\nint ccw(point a, point b, point c) {\n    b -= a; c -= a;\n    if(cross(b, c) > eps)           return 1;  // a -> b -> c : counterclockwise\n    if(cross(b, c) < -eps)          return -1; // a -> b -> c : clockwise\n    if(dot(b, c) < 0)               return 2;  // c -> a -> b : line\n    if(std::norm(b) < std::norm(c)) return -2; // a -> b -> c : line\n    return 0;                                  // a -> c -> b : line\n}\n\n\nbool isis_ll(line l, line m) {\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(line l, segment s) {\n    return (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - s.a) < eps);\n}\n\nbool isis_lp(line l, point p) {\n    return (std::abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(segment s, point p) {\n    return (std::abs(s.a - p) + std::abs(s.b - p) - std::abs(s.b - s.a) < eps);\n}\n\nbool isis_ss(segment s, segment t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n        && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n\npoint proj(line l, point p) {\n    long double t = dot(p - l.a, l.a - l.b) / std::norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\npoint is_ll(line s, line t) {\n    point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nlong double dist_lp(line l, point p) {\n    return std::abs(p - proj(l, p));\n}\n\nlong double dist_ll(line l, line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nlong double dist_ls(line l, segment s) {\n    return isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nlong double dist_sp(segment s, point p) {\n    point r = proj(line(s), p);\n    return isis_sp(s, r) ? std::abs(r - p) : std::min(std::abs(s.a - p), std::abs(s.b - p));\n}\n\nlong double dist_ss(segment s, segment t) {\n    if(isis_ss(s, t)) return 0;\n    long double d1 = std::min(dist_sp(s, t.a), dist_sp(s, t.b));\n    long double d2 = std::min(dist_sp(t, s.a), dist_sp(t, s.b));\n    return std::min(d1, d2);\n}\n\n\nstd::vector<point> is_cc(circle const& c1, circle const& c2) {\n    std::vector<point> res;\n    long double d = std::abs(c1.p - c2.p);\n    long double rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    long double dfr = c1.r * c1.r - rc * rc;\n    if(std::abs(dfr) < eps) {\n        dfr = 0.0;\n    } else if(dfr < 0.0) {\n        return res;\n    }\n\n    long double rs = std::sqrt(dfr);\n    point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * point(rc, rs));\n    if(dfr != 0.0) {\n        res.push_back(c1.p + diff * point(rc, -rs));\n    }\n    return res;\n}\n\n// 0 -> on, 1 -> in, 2 -> out\nint is_in_polygon(polygon const& poly, point p) {\n    int N = poly.size();\n    ld sum = 0;\n    for(int i=0; i<N; ++i) {\n        point p1 = poly[i], p2 = poly[(i+1)%N];\n        if(isis_sp(segment(p1, p2), p)) {\n            return 0;\n        }\n        sum += arg((p2 - p) / (p1 - p));\n    }\n    return eq(sum, 0) ? 2 : 1;\n}\n\npoint reflection(line const& l, point p) {\n    auto pro = proj(l, p);\n    return p + (pro - p) + (pro - p);\n}\n\nld area(polygon const& p) {\n    const int N = p.size();\n    ld res = 0;\n    for(int i=0; i<N; ++i) {\n        res += cross(p[i], p[(i+1)%N]);\n    }\n    return res / 2;\n}\n\n// left side\npolygon convex_cut(polygon const& p, line l) {\n    const int N = p.size();\n    polygon res;\n    for(int i=0; i<N; ++i) {\n        auto a = p[i], b = p[(i+1)%N];\n        if(ccw(l.a, l.b, a) != -1) {\n            res.push_back(a);\n        }\n        if(ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0) {\n            res.push_back(is_ll(line(a, b), l));\n        }\n    }\n    return res;\n}\n\npolygon convex_hull(vector<point> ps) {\n    sort(ps.begin(), ps.end(), [&](point const& p1, point const& p2) {\n        if(real(p1) == real(p2)) {\n            return imag(p1) < imag(p2);\n        }\n        return real(p1) < real(p2);\n    });\n    const int n = ps.size();\n    int k = 0;\n    polygon qs(2*n);\n    for(int i=0; i<n; ++i) {\n        while(k > 1 && ccw(qs[k-2], qs[k-1], ps[i]) <= 0) {\n            k--;\n        }\n        qs[k++] = ps[i];\n    }\n    for(int i=n-2, t = k; i>=0; --i) {\n        while(k > t && ccw(qs[k-2], qs[k-1], ps[i]) <= 0) {\n            k--;\n        }\n        qs[k++] = ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\n\nline separate(point const& p1, point const& p2) {\n    assert(p1 != p2);\n    auto m = (p1 + p2) * point(0.5, 0);\n    line res;\n    res.a = m + (m - p1) * point(0, 1);\n    res.b = m + (m - p1) * point(0, -1);\n    return res;\n}\n\n\n} // namespace geometry2d\n\nusing namespace geometry2d;\n\nint main() {\n    int n, m;\n    while(cin >> n >> m, n) {\n        vector<point> b(n), w(m);\n        for(int i=0; i<n; ++i) {\n            ld x, y;\n            cin >> x >> y;\n            b[i] = point(x, y);\n        }\n        for(int i=0; i<m; ++i) {\n            ld x, y;\n            cin >> x >> y;\n            w[i] = point(x, y);\n        }\n        bool flag = false;\n        auto cb = convex_hull(b);\n        auto cw = convex_hull(w);\n        if(cb.size() == 0 && cw.size() == 2) {\n            flag |= isis_sp(segment(cw[0], cw[1]), b[0]);\n        } else if(cb.size() == 2 && cw.size() == 0) {\n            flag |= isis_sp(segment(cb[0], cb[1]), w[0]);\n        } else if(cb.size() == 2 && cw.size() == 2) {\n            flag |= isis_ss(segment(cb[0], cb[1]), segment(cw[0], cw[1]));\n        }\n        if(cw.size() > 2) {\n            for(auto& p : cb) {\n                flag |= is_in_polygon(cw, p) != 2;\n            }\n        }\n        if(cb.size() > 2) {\n            for(auto& p : cw) {\n                flag |= is_in_polygon(cb, p) != 2;\n            }\n        }\n        if(flag) {\n            cout << \"NO\" << endl;\n        } else {\n            cout << \"YES\" << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-8\n#define INF 1000000\n \nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n    Point operator *(const double d)const{\n        return Point(x*d,y*d);\n    }\n    bool operator <(const Point &p)const{\n        if(x==p.x) return y<p.y;\n        return x<p.x;\n    }\n    double norm(){\n        return x*x+y*y;\n    }\n\tbool input(){\n\t\tif(cin>>x>>y) return true;\n\t\treturn false;\n\t}\n};\n \nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n\tbool input(){\n\t\tif(a.input() && b.input()) return true;\n\t\treturn false;\n\t}\n};\n \nstruct Circle{\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point _c,double _r){\n        c=_c; r=_r;\n    }\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n \nint ccw(Point a,Point b,Point c){ //a,b,c,は全て異なる\n\tPoint v1 = b-a;\n\tPoint v2 = c-a;\n    if(cross(v1,v2)>EPS) return +1; //a->b->c が反時計回り\n    if(cross(v1,v2)<-EPS) return -1; //a->b->c が時計回り\n\tif(dot(v1,v2)<-EPS) return +2; //cがa-bより後ろ c<-a->b\n\tif(v1.norm()<v2.norm()) return -2; //cがa-bより前 a->b->c\n    return 0; //cがa-b上 a->c->b\n}\n \nbool intersect_ss(Line l,Line m){\n    return ccw(l.a,l.b,m.a)*ccw(l.a,l.b,m.b)<=0 && ccw(m.a,m.b,l.a)*ccw(m.a,m.b,l.b)<=0;\n}\n \nbool crosspoint_ll(Line l,Line m,Point &p){\n    Point a1,a2,b1,b2;\n    a1 = l.b-l.a; a2 = m.b-m.a;\n    b1 = m.a-l.a; b2 = l.a-m.b;\n    double s1,s2;\n    s1 = cross(a1,b1)/2; s2 = cross(a1,b2)/2;\n    if(s1+s2<EPS) return false; //平行\n    p = Point(m.a.x+a2.x*s1/(s1+s2),m.a.y+a2.y*s1/(s1+s2));\n    return true;\n}\n \nint crosspoint_ss(Line l,Line m,Point &p){\n    if(intersect_ss(l,m)==false) return 0; //交差していない\n    if(crosspoint_ll(l,m,p)==true) return 1;\n\treturn -1; //交点が無限個(平行かつ交差)\n}\n \nint crosspoint_cc(Circle c1,Circle c2,Point &p1,Point &p2){\n    double d,a,t;\n    d = sqrt((c2.c-c1.c).norm());\n\tif(abs(c1.c.x-c2.c.x)<EPS && abs(c1.c.y-c2.c.y)<EPS && abs(c1.r-c2.r)<EPS)\n\t\treturn -1; //2つの円が重なっている\n    if(d<abs(c1.r-c2.r) || c1.r+c2.r<d) return 0; //どちらかが内包している\n    a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    t = atan2(c2.c.y-c1.c.y,c2.c.x-c1.c.x);\n    p1 = Point(c1.c.x+c1.r*cos(t+a),c1.c.y+c1.r*sin(t+a));\n    p2 = Point(c1.c.x+c1.r*cos(t-a),c1.c.y+c1.r*sin(t-a));\n    if(abs(p1.x-p2.x)<EPS && abs(p1.y-p2.y)<EPS) return 1; //交点が1つ\n    return 2; //交点が2つ\n}\n\nint contains(Polygon g,Point p){\n\tLine l = Line(p,Point(INF,p.y));\n\tint cnt = 0, n = g.size();\n\tfor(int i=0;i<n;i++){\n\t\tPoint a = g[i]-p;\n\t\tPoint b = g[(i+1)%n]-p;\n\t\tif(ccw(g[i],g[(i+1)%n],p)==0) return 1; //線分上\n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<=EPS && EPS<b.y && cross(a,b)>EPS) cnt++;\n\t}\n\tif((cnt&1)==1) return 2; //内包している\n\treturn 0; //内包していない\n}\n\nPolygon andrewScan(Polygon s){\n\tif(s.size()<=2) return s;\n\tsort(s.begin(),s.end());\n\tPolygon g;\n\tfor(int i=0;i<s.size();i++){\n\t\tfor(int n=g.size(); n>=2 && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\tint upper_n = g.size();\n\tfor(int i=s.size()-2;i>=0;i--){\n\t\tfor(int n=g.size(); n>upper_n && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\treverse(g.begin(),g.end());\n\tg.pop_back();\n\treturn g;\n}\n\nint main(){\n\tint N,M;\n\tPolygon b,w,gb,gw;\n\twhile(cin>>N>>M,N||M){\n\t\tb.resize(N); w.resize(M);\n\t\tfor(int i=0;i<N;i++) b[i].input();\n\t\tfor(int i=0;i<M;i++) w[i].input();\n\t\tgb = andrewScan(b); gw = andrewScan(w);\n\t\tbool ans = true;\n\t\tfor(int i=0;i<gb.size() && ans;i++){\n\t\t\tfor(int j=0;j<gw.size() && ans;j++){\n\t\t\t\tLine l(gb[i],gb[(i+1)%gb.size()]), m(gw[i],gw[(i+1)%gw.size()]);\n\t\t\t\tif(intersect_ss(l,m)==true) ans = false;\n\t\t\t}\n\t\t}\n\t\tif(gb.size()>=3){\n\t\t\tfor(int i=0;i<M && ans;i++){\n\t\t\t\tif(contains(gb,w[i])!=0) ans = false;\n\t\t\t}\n\t\t}\n\t\tif(gw.size()>=3){\n\t\t\tfor(int i=0;i<N && ans;i++){\n\t\t\t\tif(contains(gw,b[i])!=0) ans = false;\n\t\t\t}\n\t\t}\n\t\t/*if(gb.size()==2 && gw.size()==1){\n\t\t\tif(ccw(gb[0],gb[1],gw[0])==0) ans = false;\n\t\t}\n\t\tif(gw.size()==2 && gb.size()==1){\n\t\t\tif(ccw(gw[0],gw[1],gb[0])==0) ans = false;\n\t\t}*/\n\t\tif(ans==true) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cassert>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-10\n#define F first\n#define S second\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point\n{\n  public:\n  double x,y;\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nbool isIntersect(Segment s1,Segment s2)\n{\nreturn isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool cmp(const vector<Point> &a,const vector<Point> &b)\n{\n  return a.size() < b.size();\n}\n\nPolygon andrewScan(Polygon s)\n{\n  Polygon u,l;\n  if(s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<s.size();i++)\n    {\n      for(int n=u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--)\n\tu.pop_back();\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3; i>=0 ; i--)\n    {\n      for(int n=l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--)\n\tl.pop_back();\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\nbool check(int p1,int p2,vector<Point> &black,vector<Point> &white)\n{\n  int n = black.size();\n  pair<bool,bool> Left,Right;\n  Left  = pair<bool,bool>(false,false); // F->black, S->white\n  Right = pair<bool,bool>(false,false);\n\n  rep(i,n)\n    {\n      if(i == p1 || i == p2)continue;\n      int res = ccw(black[p1],black[p2],black[i]);\n      if(res == CLOCKWISE) Right.F = true;\n      if(res == COUNTER_CLOCKWISE) Left.F = true;\n    }\n  \n  n = white.size();\n  bool Front = false;\n  bool Back = false;\n  int OnSegment = 0;\n  rep(i,n)\n    {\n      int res = ccw(black[p1],black[p2],white[i]);\n      if(res == CLOCKWISE) Right.S = true;\n      if(res == COUNTER_CLOCKWISE) Left.S = true;\n      if(res == ONLINE_FRONT) Front = true;\n      if(res == ONLINE_BACK) Back = true;\n      if(res == ON_SEGMENT) OnSegment++;\n    }\n\n  //cout << black[p1].x << \",\" << black[p1].y << \" | \" << black[p2].x << \",\" << black[p2].y << endl;\n  //cout << \"Front = \" << Front << \" Back = \" << Back << \" OnSegment = \" << OnSegment << endl;\n  if(Front && Back)return false;\n  if(OnSegment && Front)return false;\n  if(OnSegment && Back)return false;\n  if(OnSegment >= 2)return false;\n  if(Left.F && Left.S)return false;\n  if(Right.F && Right.S)return false;\n  if(Left.S && Right.S)return false;\n  //cout << \"OK\" << endl;\n  return true;\n}\n\nvoid printVP(vector<Point> a)\n{\n  cout << \"printVP-------\" << endl;\n  rep(i,a.size())cout << \"(\" << a[i].x << \",\" << a[i].y << \") \";\n  cout << endl;\n}\n\nbool isParallel(Vector a,Vector b)\n{\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2)\n{\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2)\n{\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isAinB(Polygon A,Polygon B)\n{\n  int N = A.size();\n  int M = B.size();\n  for(int i=0;i<N;i++)\n    {\n      for(int j=0;j<M;j++)\n\t{\n\t  int res = ccw(A[i],A[(i+1)%N],B[j]);\n\t  if(!(res == COUNTER_CLOCKWISE || res == ON_SEGMENT))return false;\n\t}\n    }\n  return true;\n}\n\nint main()\n{\n  int n,m;\n  while(cin >> n >> m,n|m)\n    {\n      assert(n && m);\n      vector<Point> A(n),B(m);\n      rep(_,n)cin >> A[_].x >> A[_].y;\n      rep(_,m)cin >> B[_].x >> B[_].y;\n\n      vector<Point> black,white;\n      if(A.size() > B.size())\n\tblack = A,white = B;\n      else\n\tblack = B,white = A;\n      black = andrewScan(black);      \n      white = andrewScan(white);\n      //cout << \"isAinB? \" << isAinB(black,white) << endl;\n\n      int N,M;\n      N = black.size();\n      M = white.size();\n      bool AUTO = false;\n      rep(i,N)\n\t{\n\t  REP(l,1,N)\n\t    {\n\t      rep(j,M)\n\t\t{\n\t\t  REP(k,1,M)\n\t\t    {\n\t\t      if(isIntersect(Segment(black[i],black[l]),Segment(white[j],white[k])))\n\t\t\t{\n\t\t\t  AUTO = true;\n\t\t\t  goto OUT;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n    OUT:;\n\n      if(AUTO)\n\t{\n\t  cout << \"NO\" << endl;\n\t  continue;\n\t}\n      if(isAinB(black,white))\n\t{\n\t  cout << \"NO\" << endl;\n\t  continue;\n\t}\n      if(isAinB(white,black))\n\t{\n\t  cout << \"NO\" << endl;\n\t  continue;\n\t}\n      cout << \"YES\" << endl;\n\n\n      continue;\n      bool ch = true;\n      \n\n      if(n == 1 && m == 1)\n\t{\n\t  cout << \"YES\" << endl;\n\t  continue;\n\t}\n\n      \n      if(black.size() >= 3 && white.size() == 1)\n\t{\t  \t \n\t  bool aaa = false;\n\t  rep(i,black.size()-2)\n\t    {\n\t      if(!isParallel(Segment(black[i],black[i+1]),Segment(black[i+1],black[i+2])))\n\t\t{\n\t\t  aaa = true;\n\t\t  break;\n\t\t}\n\t    }\n\n\t  if(aaa)\n\t    {\n\t      bool fin = false;\n\t      rep(i,black.size())\n\t\t{\n\t\t  REP(j,i+1,black.size())\n\t\t    {\n\t\t      if(!check(i,j,black,white))\n\t\t\t{\n\t\t\t  cout << \"NO\" << endl;\n\t\t\t  fin = true;\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  if(fin)break;\n\t\t}\n\t      if(!fin)cout << \"YES\" << endl;\n\t      continue;\n\t    }\n\t}\n      \n      /*\n      if(white.size() == 1)\n\t{\n\n\t  sort(black.begin(),black.end());\n\t  if(ccw(black[0],black[black.size()-1],white[0]) == ON_SEGMENT)\n\t    {\n\t      cout << \"NO\" << endl;\n\t      continue;\n\t    }\n\t  rep(i,black.size())\n\t    if(ccw(black[i],black[(i+1)%black.size()],white[0]) == ON_SEGMENT)\n\t      {\n\t\tcout << \"NO\" << endl;\n\t\tgoto FX;\n\t      }\n\t  cout << \"YES\" << endl;\n\tFX:;\n\t  continue;\n\t}\n      */\n  \n\n      \n\tbool allPL = true;\n\t//vector<Point> gray = black;\n\t//rep(i,white.size())gray.push_back(white[i]);\n\trep(i,black.size())\n\t  {\n\t    REP(j,i+1,black.size())\n\t      {\n\t\trep(k,white.size())\n\t\t  {\n\t\t    REP(l,k+1,white.size())\n\t\t      {\n\t\t\tif(!isParallel(Segment(black[i],black[j]),Segment(white[k],white[l])))\n\t\t\t  {\n\t\t\t    allPL = false;\n\t\t\t    goto Next;\n\t\t\t  }\n\t\t      }\n\t\t  }\n\t      }\n\t  }\n      Next:;\n\tif(allPL)\n\t  {\n\t    int Front = 0;\n\t    int Back = 0;\n\t    int OnSegment = 0;\n\t    rep(i,black.size())\n\t      {\n\t\tREP(j,i+1,black.size())\n\t\t  {\n\t\t    rep(k,white.size())\n\t\t      {\n\t\t\tint res = ccw(black[i],black[j],white[k]);\n\t\t\tif(res == ONLINE_FRONT)Front++;\n\t\t\tif(res == ONLINE_BACK) Back++;\n\t\t\tif(res == ON_SEGMENT)  OnSegment++;\n\t\t      }\t\t\n\t\t  }\n\t      }\n\n\t    if(OnSegment)cout << \"NO\" << endl;\n\t    else if(Front && Back)cout << \"NO\" << endl;\t \n\t    else cout << \"YES\" << endl;\n\t \n\t    continue;\n\t  }\t\n\n      \n    \n\t//N = black.size();\n\trep(i,N)\n\t{\n\t  REP(j,i+1,N)\n\t    {\n\t      if(check(i,j,black,white))\n\t\t{\n\t\t  //cout << black[i].x << \",\" << black[i].y << \" \" << black[j].x << \",\" << black[j].y << endl;\n\t\t  cout << \"YES\" << endl;\n\t\t  goto F;\n\t\t}\n\t    }\n\t}\n      cout << \"NO\" << endl;\n    F:;\n    }\n  return 0;\n}\n\n\n/*\n  if(black.size() == 2 && white.size() == 1)\n  {\n  int res = ccw(black[0],black[1],white[0]);\n  if(res == ON_SEGMENT)cout << \"NO\" << endl;\n  else                 cout << \"YES\" << endl;\n  continue;\n  }\n*/\n\n/*\n  if(black.size() == 2 && white.size() == 2)\n  {\n  if(isIntersect(Segment(black[0],black[1]),Segment(white[0],white[1])))cout << \"NO\" << endl;\n  else                                                                  cout << \"YES\" << endl;\n  continue;\n  }\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-8;\n\nnamespace std {\n  bool operator < (const P &a, const P &b) {\n    return a.real() != b.real()\n      ? a.real() < b.real()\n      : a.imag() < b.imag();\n  }\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble norm(P a) {\n  return dot(a, a);\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\nint ccw(P p0, P a, P b) {\n  a -= p0;\n  b -= p0;\n  if(cross(a, b) > EPS) return 1;\n  if(cross(a, b) < -EPS) return -1;\n  if(dot(a, b) < -EPS) return 2;\n  if(norm(a) < norm(b)) return -2;\n  return 0;\n}\n\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for(int i = 0; i < n; ch[k++] = ps[i++])\n    while(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for(int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])\n    while(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t   ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0);\n}\n\nbool isIn(vector<P> &g, P p) {\n  int n = g.size();\n  for(int i = 0; i < g.size(); ++i) {\n    if(ccw(g[i], g[(i+1)%n], p) != 1) return false;\n  }\n  return true;\n}\n\nbool isIntersect(vector<P> &u, vector<P> &v) {\n  int n = u.size();\n  int m = v.size();\n  for(int i = 0; i < u.size(); ++i) {\n    for(int j = 0; j < v.size(); ++j) {\n      if(isIntersect(u[i], u[(i+1)%n], v[j], v[(j+1)%n])) return true;\n    }\n  }\n  for(int i = 0; i < u.size(); ++i) {\n    if(isIn(v, u[i])) return true;\n  }\n  for(int j = 0; j < v.size(); ++j) {\n    if(isIn(u, v[j])) return true;\n  }\n  return false;\n}\n\nbool solve(vector<P> &u, vector<P> &v) {\n  u = convex_hull(u);\n  v = convex_hull(v);\n  return !isIntersect(u, v);\n}\n\nint main() {\n  int n, m;\n  while(cin >> n >> m && (n || m)) {\n    vector<P> u, v;\n    P p;\n    for(int i = 0; i < n; ++i) {\n      cin >> p.real() >> p.imag();\n      u.push_back(p);\n    }\n    for(int i = 0; i < m; ++i) {\n      cin >> p.real() >> p.imag();\n      v.push_back(p);\n    }\n    if(solve(u, v)) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 50000 + 10;\nconst double pi = acos(-1.0);\nconst double inf = 1e100;\nconst double eps = 1e-12;\n\ntypedef struct point vec;\nstruct point { //点的基本数据结构\n    double x, y;\n    double poe;\n    point(double _x = 0, double _y = 0)\n        : x(_x)\n        , y(_y)\n    {\n    }\n    double len() //模长\n    {\n        return sqrt(x * x + y * y);\n    }\n    vec chuizhi()\n    {\n        return vec(-y, x);\n    }\n    double operator*(const point& i_T) const //点积\n    {\n        return x * i_T.x + y * i_T.y;\n    }\n    double operator^(const point& i_T) const //叉积\n    {\n        return x * i_T.y - y * i_T.x;\n    }\n    point operator*(double u) const\n    {\n        return point(x * u, y * u);\n    }\n    bool operator==(const point& i_T) const\n    {\n        return fabs(x - i_T.x) < eps && fabs(y - i_T.y) < eps;\n    }\n    point operator/(double u) const\n    {\n        return point(x / u, y / u);\n    }\n    point operator+(const point& i_T)\n    {\n        return point(x + i_T.x, y + i_T.y);\n    }\n    point operator-(const point& i_T)\n    {\n        return point(x - i_T.x, y - i_T.y);\n    }\n    friend bool operator<(point a, point b)\n    {\n        return fabs(a.y - b.y) < eps ? a.x < b.x : a.y < b.y;\n    }\n    void atn2()\n    {\n        poe = atan2(y, x);\n    }\n    friend ostream& operator<<(ostream& out, point& a)\n    {\n        //cout << a.x << ' ' << a.y;\n        printf(\"%.8f %.8f\", a.x, a.y);\n        return out;\n    }\n    friend istream& operator>>(istream& in, point& a)\n    {\n        scanf(\"%lf%lf\", &a.x, &a.y);\n        return in;\n    }\n};\ntypedef struct Line Segment; //线段Segment\nstruct Line { //直线\n    point a, b;\n    double poe;\n    Line(point _a = point(), point _b = point())\n        : a(_a)\n        , b(_b)\n    {\n    }\n    friend istream& operator>>(istream& in, Line& a)\n    {\n        cin >> a.a >> a.b;\n        return in;\n    }\n    friend ostream& operator<<(ostream& out, Line& a)\n    {\n        out << a.a << ' ' << a.b;\n        return out;\n    }\n    void atn2()\n    {\n        poe = atan2(b.y - a.y, b.x - a.x);\n    }\n};\nint zhengfu(double x)\n{\n    if (fabs(x) < eps)\n        return 0;\n    return x > 0 ? 1 : -1;\n}\nbool bijiao3(vec a, vec b, vec c)\n{\n    if (a.x <= c.x && c.x <= b.x && ((a.y <= c.y && c.y <= b.y || b.y <= c.y && c.y <= a.y)))\n        return 1;\n    return 0;\n}\nbool xianduan_xiangjiao(Segment l1, Segment l2) //两线段是否有交点\n{\n    if (l1.a.x == l1.b.x) {\n        if (l1.a.y > l1.b.y)\n            swap(l1.a, l1.b);\n    } else if (l1.a.x > l1.b.x)\n        swap(l1.a, l1.b);\n    if (l2.a.x == l2.b.x) {\n        if (l2.a.y > l2.b.y)\n            swap(l2.a, l2.b);\n    } else if (l2.a.x > l2.b.x)\n        swap(l2.a, l2.b);\n\n    double c1 = (l1.b - l1.a) ^ (l2.a - l1.a), d1 = (l1.b - l1.a) ^ (l2.b - l1.a);\n    double c2 = (l2.b - l2.a) ^ (l1.a - l2.a), d2 = (l2.b - l2.a) ^ (l1.b - l2.a);\n\n    if (zhengfu(c1 * d1) < 0 && zhengfu(c2 * d2) < 0) //ab横穿cd\n        return 1;\n    else if (zhengfu(c1 * d1) != 0 && zhengfu(c2 * d2) == 0) { //ab不穿过cd\n        if (zhengfu(c2) == 0)\n            if (bijiao3(l2.a, l2.b, l1.a))\n                return 1;\n\n        if (zhengfu(d2) == 0)\n            if (bijiao3(l2.a, l2.b, l1.b))\n                return 1;\n    } else if (zhengfu(c1 * d1) == 0 && zhengfu(c2 * d2) != 0) { //cd不穿过ab\n        if (c1 == 0)\n            if (bijiao3(l1.a, l1.b, l2.a))\n                return 1;\n        if (d1 == 0)\n            if (bijiao3(l1.a, l1.b, l2.b))\n                return 1;\n    } else if (zhengfu(c1 * d1) == 0 && zhengfu(c2 * d2) == 0) { //平行\n        if (l1.a == l2.a || l1.a == l2.b || l1.b == l2.a || l1.b == l2.b)\n            return 1;\n        if (bijiao3(l1.a, l1.b, l2.a) == 1)\n            return 1;\n        if (bijiao3(l2.a, l2.b, l1.a) == 1)\n            return 1;\n    }\n    return 0;\n}\ndouble xuanzhuan(vec a, vec b, vec c) //求三点叉积\n{\n    return (b - a) ^ (c - a);\n}\npoint xianduan_jiaodian(Segment l1, Segment l2) //两线段交点\n{\n    double tmpLeft, tmpRight, x = inf, y = inf;\n    if (xianduan_xiangjiao(l1, l2)) {\n        tmpLeft = (l2.b.x - l2.a.x) * (l1.a.y - l1.b.y) - (l1.b.x - l1.a.x) * (l2.a.y - l2.b.y);\n        tmpRight = (l1.a.y - l2.a.y) * (l1.b.x - l1.a.x) * (l2.b.x - l2.a.x) + l2.a.x * (l2.b.y - l2.a.y) * (l1.b.x - l1.a.x) - l1.a.x * (l1.b.y - l1.a.y) * (l2.b.x - l2.a.x);\n\n        x = tmpRight / tmpLeft;\n\n        tmpLeft = (l1.a.x - l1.b.x) * (l2.b.y - l2.a.y) - (l1.b.y - l1.a.y) * (l2.a.x - l2.b.x);\n        tmpRight = l1.b.y * (l1.a.x - l1.b.x) * (l2.b.y - l2.a.y) + (l2.b.x - l1.b.x) * (l2.b.y - l2.a.y) * (l1.a.y - l1.b.y) - l2.b.y * (l2.a.x - l2.b.x) * (l1.b.y - l1.a.y);\n        y = tmpRight / tmpLeft;\n    }\n    return point(x, y);\n}\nvoid Andrew(point p[], point q[], int n, int& tail) //求凸包,<0则包含凸包边上的点,<=0则只输出拐点\n{\n    sort(p + 1, p + 1 + n);\n    tail = 1;\n    q[1] = p[1];\n    for (int i = 2; i <= n; i++) {\n        while (tail > 1 && xuanzhuan(q[tail - 1], q[tail], p[i]) <= 0)\n            tail--;\n        q[++tail] = p[i];\n    }\n    int basic = tail;\n    for (int i = n - 1; i >= 1; i--) {\n        while (tail > basic && xuanzhuan(q[tail - 1], q[tail], p[i]) <= 0)\n            tail--;\n        q[++tail] = p[i];\n    }\n}\nbool cmp2(point A, point B)\n{\n    return (A ^ B) > 0 || ((A ^ B) == 0 && A.len() < B.len());\n}\nbool dian_in_tubao(point a, point p[], int tail) //点在凸包内?包含边界  判断前需以p[1]为起点做向量,p[i]-=p[1]\n{\n    if ((a ^ p[1]) > 0 || (p[tail] ^ a) > 0)\n        return false;\n    int ps = lower_bound(p + 1, p + tail + 1, a, cmp2) - p - 1;\n    return ((a - p[ps]) ^ (p[ps % tail + 1] - p[ps])) <= 0;\n}\nbool dian_zai_xianshang(Segment l1, vec c) //点在线段上\n{\n    int x1 = l1.a.x, x2 = l1.b.x, y1 = l1.a.y, y2 = l1.b.y;\n    if (x1 > x2)\n        swap(x1, x2);\n    if (y1 > y2)\n        swap(y1, y2);\n    if (xuanzhuan(l1.a, l1.b, c) == 0 && x1 <= c.x && c.x <= x2 && y1 <= c.y && c.y <= y2)\n        return 1;\n    return 0;\n}\npoint p1[MAXN], p2[MAXN], q1[MAXN], q2[MAXN];\nint main()\n{\n    //freopen(\"txt.txt\", \"w\", stdout);\n    int n, m;\n    while (cin >> n >> m, n && m) {\n        for (int i = 1; i <= n; i++)\n            cin >> p1[i];\n        for (int i = 1; i <= m; i++)\n            cin >> p2[i];\n        if (n == 1) {\n            if (m == 1) {\n                if (p1[1] == p2[1])\n                    cout << \"NO\" << endl;\n                else\n                    cout << \"YES\" << endl;\n                continue;\n            } else if (m == 2) {\n                if (dian_zai_xianshang(Segment(p2[1], p2[2]), p1[1]))\n                    cout << \"NO\" << endl;\n                else\n                    cout << \"YES\" << endl;\n                continue;\n            }\n        }\n\n        int tail1, tail2;\n        Andrew(p1, q1, n, tail1);\n        Andrew(p2, q2, m, tail2);\n\n        if (tail1 == 1) {\n            if (tail2 == 1) {\n                if (q1[1] == q2[1])\n                    cout << \"NO\" << endl;\n                else\n                    cout << \"YES\" << endl;\n                continue;\n            } else if (tail2 == 3) {\n                if (dian_zai_xianshang(Segment(p2[1], p2[2]), p1[1]))\n                    cout << \"NO\" << endl;\n                else\n                    cout << \"YES\" << endl;\n                continue;\n            }\n        }\n        if (tail2 == 1) {\n            if (tail1 == 1) {\n                if (q2[1] == q1[1])\n                    cout << \"NO\" << endl;\n                else\n                    cout << \"YES\" << endl;\n                continue;\n            } else if (tail1 == 3) {\n                if (dian_zai_xianshang(Segment(p1[1], p1[2]), p2[1]))\n                    cout << \"NO\" << endl;\n                else\n                    cout << \"YES\" << endl;\n                continue;\n            }\n        }\n        tail1--, tail2--;\n        bool flag = 0;\n\n        for (int i = 1; i <= tail1; i++) {\n            Segment l1(q1[i], q1[i + 1]);\n            for (int j = 1; j <= tail2; j++)\n                if (xianduan_xiangjiao(l1, Segment(q2[j], q2[j + 1]))) {\n                    flag = 1;\n                    break;\n                }\n            if (flag)\n                break;\n        }\n\n        if (tail2 > 2 && tail1 > 2) {\n            point A = q1[1], B = q2[1];\n            if (!flag) {\n                for (int i = 1; i <= tail2; i++)\n                    q2[i] = q2[i] - B;\n                for (int i = 1; i <= tail1; i++)\n                    if (dian_in_tubao(q1[i] - B, q2, tail2)) {\n                        flag = 1;\n                        break;\n                    }\n                for (int i = 1; i <= tail2; i++)\n                    q2[i] = q2[i] + B;\n            }\n\n            if (!flag) {\n                for (int i = 1; i <= tail1; i++)\n                    q1[i] = q1[i] - A;\n                for (int i = 1; i <= tail2; i++)\n                    if (dian_in_tubao(q2[i]-A, q1, tail1)) {\n                        flag = 1;\n                        break;\n                    }\n                for (int i = 1; i <= tail1; i++)\n                    q1[i] = q1[i] + A;\n            }\n        }\n        cout << (flag ? \"NO\" : \"YES\") << '\\n';\n        /*for (int i = 1; i <= tail1; i++)\n            cout << '(' << q1[i].x << ',' << q1[i].y << ')' << endl;\n        cout << endl;\n        for (int i = 1; i <= tail2; i++)\n            cout << '(' << q2[i].x << ',' << q2[i].y << ')' << endl;*/\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  pair<Point,Point> p=getCrossPoints(c1,c2);\n  if(cross(p2-p1,p.first-p1)>0) swap(p.first,p.second);\n  return Line(p.first,p.second);\n}\n\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    bool f=1;\n    Polygon b(n),w(m);\n    for(int i=0;i<n;i++) cin>>b[i].x>>b[i].y;\n    for(int i=0;i<m;i++) cin>>w[i].x>>w[i].y;\n    b=andrewScan(b);\n    w=andrewScan(w);\n    n=b.size();m=w.size();\n    if(n<m){\n      swap(n,m);\n      swap(b,w);\n    }\n    if(n==2){\n      if(m==1){\n\tf=cross(b[1]-b[0],w[0]-b[0])!=0;\n      }else{\n\tf=!intersect(b[0],b[1],w[0],w[1]);\n      }\n    }\n    if(n>2){\n      for(int i=0;i<m;i++)\n\tf&=!contains(b,w[i]);\n      if(m>2)\n\tfor(int i=0;i<n;i++)\n\t  f&=!contains(w,b[i]);\n    }\n    cout<<(f?\"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <climits>\n#include <iomanip>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <tuple>\n#include <iostream>\n#include <deque>\n#include <array>\n#include <set>\n#include <functional>\n#include <memory>\n#include <stack>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nstruct Vector;\nstruct Point {\n\tint x, y;\n\tVector operator-(const Point& that) const;\n\tbool operator==(const Point& that) const;\n};\nstruct Vector {\n\tPoint from, to;\n\tint dx() const;\n\tint dy() const;\n\tint cross(const Vector& that) const;\n\tint dot(const Vector& that) const;\n\tbool is_left(const Point& that) const;\n\tbool is_right(const Point& that) const;\n\tbool is_on_line(const Point& that) const;\n\tbool is_forward(const Point& that) const;\n\tbool is_backward(const Point& that) const;\n};\n\nbool is_separated_by_white_to_white_line(const Vector& vec, const std::vector<Point>& black, const std::vector<Point>& white) {\n\treturn\n\t\t(std::all_of(black.begin(), black.end(), [vec](const Point& p) {return vec.is_left(p); }) && std::all_of(white.begin(), white.end(), [vec](const Point& p) {return vec.is_right(p) || vec.is_on_line(p); })) ||\n\t\t(std::all_of(black.begin(), black.end(), [vec](const Point& p) {return vec.is_right(p); }) && std::all_of(white.begin(), white.end(), [vec](const Point& p) {return vec.is_left(p) || vec.is_on_line(p); }));\n}\nbool is_separated_by_black_to_white_line(const Vector& vec, const std::vector<Point>& black, const std::vector<Point>& white) {\n\treturn\n\t\t(std::all_of(black.begin(), black.end(), [vec](const Point& p) {return vec.is_left(p) || vec.is_forward(p); }) && std::all_of(white.begin(), white.end(), [vec](const Point& p) {return vec.is_right(p) || vec.is_backward(p); })) ||\n\t\t(std::all_of(black.begin(), black.end(), [vec](const Point& p) {return vec.is_left(p) || vec.is_backward(p); }) && std::all_of(white.begin(), white.end(), [vec](const Point& p) {return vec.is_right(p) || vec.is_forward(p); })) ||\n\t\t(std::all_of(black.begin(), black.end(), [vec](const Point& p) {return vec.is_right(p) || vec.is_forward(p); }) && std::all_of(white.begin(), white.end(), [vec](const Point& p) {return vec.is_left(p) || vec.is_backward(p); })) ||\n\t\t(std::all_of(black.begin(), black.end(), [vec](const Point& p) {return vec.is_right(p) || vec.is_backward(p); }) && std::all_of(white.begin(), white.end(), [vec](const Point& p) {return vec.is_left(p) || vec.is_forward(p); }));\n}\nint main() {\n\twhile (true) {\n\t\tint n, m; std::cin >> n >> m; if (n == 0 && m == 0) break;\n\t\tstd::vector<Point> white(n), black(m); for (auto& w : white) std::cin >> w.x >> w.y; for (auto& b : black) std::cin >> b.x >> b.y;\n\t\tauto can_separate = false;\n\t\tfor (auto i = 0; i < n && !can_separate; ++i) {\n\t\t\tconst auto base = white[i];\n\t\t\tfor (auto j = i + 1; j < n && !can_separate; ++j) {\n\t\t\t\tconst auto vec = base - white[j];\n\t\t\t\tcan_separate |= is_separated_by_white_to_white_line(vec, black, white);\n\t\t\t}\n\t\t\tfor (auto j = 0; j < m && !can_separate; ++j) {\n\t\t\t\tconst auto vec = base - black[j];\n\t\t\t\tcan_separate |= is_separated_by_black_to_white_line(vec, black, white);\n\t\t\t}\n\t\t}\n\t\tif (can_separate) std::cout << \"YES\\n\";\n\t\telse std::cout << \"NO\\n\";\n\t}\n}\n\nint Vector::dx() const\n{\n\treturn to.x - from.x;\n}\n\nint Vector::dy() const\n{\n\treturn to.y - from.y;\n}\n\nint Vector::cross(const Vector& that) const { return dx() * that.dy() - dy() * that.dx(); }\n\nint Vector::dot(const Vector& that) const\n{\n\treturn dx() * that.dx() + dy() * that.dy();\n}\n\nbool Vector::is_left(const Point& that) const\n{\n\treturn cross(that - from) < 0;\n}\n\nbool Vector::is_right(const Point& that) const\n{\n\treturn cross(that - from) > 0;\n}\n\nbool Vector::is_on_line(const Point& that) const\n{\n\treturn cross(that - from) == 0;\n}\n\nbool Vector::is_forward(const Point& that) const\n{\n\treturn is_on_line(that) && dot(that - from) >= 0;\n}\n\nbool Vector::is_backward(const Point& that) const\n{\n\treturn is_on_line(that) && dot(that - from) <= 0;\n}\n\nVector Point::operator-(const Point& that) const { return Vector{ *this, that }; }\n\nbool Point::operator==(const Point& that) const { return x == that.x && y == that.y; }\n"
  },
  {
    "language": "C++",
    "code": "#ifndef ___STD_GEOMETRY\n#define ___STD_GEOMETRY\n\n#include <cmath>\n\n#define EPS 1e-13L\n\n#endif\n\n#ifndef ___Class_Point\n#define ___Class_Point\n\nclass Point\n{\npublic:\n\n\t// ------ Variable ------ //\n\n\tlong double x, y;\n\n\n\t// ------ Constructor ------ //\n\n\tPoint() : x(0), y(0) { }\n\n\texplicit Point(long double x, long double y) : x(x), y(y) { }\n\n\n\t// ------ Operator ------ //\n\n\tfriend bool operator==(Point& p1, Point& p2) { return p1.x == p2.x && p1.y == p2.y; }\n\tfriend bool operator!=(Point& p1, Point& p2) { return p1.x != p2.x || p1.y != p2.y; }\n};\n\nlong double distance(const Point& p1, const Point& p2)\n{\n\treturn sqrtl((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));\n}\n\n#endif\n\n#ifndef ___Class_Vector\n#define ___Class_Vector\n\nclass Vector\n{\npublic:\n\n\t// ------ Variable ------ //\n\n\tlong double x, y;\n\n\n\t// ------ Constructor ------ //\n\n\tVector() : x(0), y(0) { }\n\n\texplicit Vector(long double x, long double y) : x(x), y(y) { }\n\n\texplicit Vector(Point p1, Point p2) : x(p2.x - p1.x), y(p2.y - p1.y) { }\n\n\texplicit Vector(long double sx, long double tx, long double sy, long double ty) : x(tx - sx), y(ty - sy) { }\n\n\n\t// ------ Operator ------ //\n\n\tVector operator+() const { return Vector(+x, +y); }\n\tVector operator-() const { return Vector(-x, -y); }\n\n\tVector& operator+=(const Vector& v) { x += v.x; y += v.y; return *this; }\n\tVector& operator-=(const Vector& v) { x -= v.x; y -= v.y; return *this; }\n\n\tfriend bool operator==(const Vector& v1, const Vector& v2) { return -EPS < v1.x - v2.x && v1.x - v2.x < EPS && -EPS < v1.y - v2.y && v1.y - v2.y < EPS; }\n\tfriend bool operator!=(const Vector& v1, const Vector& v2) { return !(v1 == v2); }\n\n\tfriend Vector operator+(const Vector& v1, const Vector& v2) { return Vector(v1.x + v2.x, v1.y + v2.y); }\n\tfriend Vector operator-(const Vector& v1, const Vector& v2) { return Vector(v1.x - v2.x, v1.y - v2.y); }\n\n\tfriend Vector operator*(double d, const Vector& v) { return Vector(d * v.x, d * v.y); }\n\tfriend Vector operator*(const Vector& v, double d) { return Vector(d * v.x, d * v.y); }\n\tfriend Vector operator/(const Vector& v, double d) { return Vector(v.x / d, v.y / d); }\n\n\n\t// ------ Function ------ //\n\n\tlong double norm() { return x * x + y * y; }\n\n\tlong double abs() { return sqrtl(x * x + y * y); }\n\n\tlong double angle() { return atan2l(y, x); }\n};\n\nlong double angle(const Vector& v1, const Vector& v2)\n{\n\tlong double A = atan2l(v2.y, v2.x) - atan2l(v1.y, v1.x);\n\n\tif (180.0L - EPS < A && A < 180.0L + EPS) { return 180.0L; }\n\n\tif (-180.0L - EPS < A && A < -180.0L + EPS) { return 180.0L; }\n\n\tif (A > 180.0L - EPS) { return A - 360.0L; }\n\n\tif (A < -180.0L + EPS) { return A + 360.0L; }\n\n\treturn A;\n}\n\nlong double norm(const Vector& v1)\n{\n\treturn v1.x * v1.x + v1.y * v1.y;\n}\n\nlong double abs(const Vector& v1)\n{\n\treturn sqrt(norm(v1));\n}\n\nlong double cross(const Vector& v1, const Vector& v2)\n{\n\treturn v1.x * v2.y - v1.y * v2.x;\n}\n\nlong double dot(const Vector& v1, const Vector& v2)\n{\n\treturn v1.x * v2.x + v1.y * v2.y;\n}\n\nlong double distance(const Vector& v1, const Vector& v2)\n{\n\treturn sqrtl((v2.x - v1.x) * (v2.x - v1.x) + (v2.y - v1.y) * (v2.y - v1.y));\n}\n\n#endif\n\nbool Triangle_Inside(Vector Tp1, Vector Tp2, Vector Tp3, Vector p) // Triangle is Counter-Clockwise\n{\n\tbool ok1 = angle(p - Tp1, Tp2 - Tp1) < 0 && angle(Tp2 - Tp1, p - Tp1) < angle(Tp2 - Tp1, Tp3 - Tp1);\n\tbool ok2 = angle(p - Tp2, Tp3 - Tp2) < 0 && angle(Tp3 - Tp2, p - Tp2) < angle(Tp3 - Tp2, Tp1 - Tp2);\n\tbool ok3 = angle(p - Tp3, Tp1 - Tp3) < 0 && angle(Tp1 - Tp3, p - Tp3) < angle(Tp1 - Tp3, Tp2 - Tp3);\n\n\treturn ok1 && ok2 && ok3;\n}\n\nbool On_Segment(Vector Sp1, Vector Sp2, Vector p)\n{\n\treturn (Sp1 + Sp2) / 2 == p;\n}\n\nint Counter_Clockwise(Vector p1, Vector p2, Vector p3)\n{\n\tVector a = p2 - p1;\n\tVector b = p3 - p1;\n\n\tif (cross(a, b) > EPS) { return 1; }\n\tif (cross(a, b) < -EPS) { return -1; }\n\n\tif (dot(a, b) < -EPS) { return 2; }\n\n\tif (a.norm() < b.norm()) { return -2; }\n\n\treturn 0;\n}\n\nbool Intersection(Vector p1, Vector p2, Vector p3, Vector p4)\n{\n\tint ok1 = Counter_Clockwise(p1, p2, p3) * Counter_Clockwise(p1, p2, p4);\n\tint ok2 = Counter_Clockwise(p3, p4, p1) * Counter_Clockwise(p3, p4, p2);\n\n\treturn ok1 <= 0 && ok2 <= 0;\n}\n\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tint N, M, X, Y;\n\n\twhile (true)\n\t{\n\t\tcin >> N >> M;\n\n\t\tif (N == 0 && M == 0) { break; }\n\n\t\tvector<Vector> W(N);\n\t\tvector<Vector> B(M);\n\n\t\tfor (int i = 0; i < N; i++) { cin >> X >> Y; W[i] = Vector(X, Y); }\n\t\tfor (int i = 0; i < M; i++) { cin >> X >> Y; B[i] = Vector(X, Y); }\n\n\t\tbool ok = true;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < M; k++)\n\t\t\t\t{\n\t\t\t\t\tif (On_Segment(W[i], W[j], B[k]) == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < M; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < M; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t\t{\n\t\t\t\t\tif (On_Segment(B[i], B[j], W[k]) == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ok = true)\n\t\t{\n\t\t\tif (N > 2 || M > 2)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int k = j + 1; k < N; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int l = 0; l < M; l++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (Triangle_Inside(W[i], W[j], W[k], B[l]) == true)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < M; i++)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = i + 1; j < M; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int k = j + 1; k < M; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int l = 0; l < N; l++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (Triangle_Inside(B[i], B[j], B[k], W[l]) == true)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (N == 2 && M == 2)\n\t\t\t{\n\t\t\t\tok = (Intersection(W[0], W[1], B[0], B[1]) == true ? false : true);\n\t\t\t}\n\t\t}\n\n\t\tcout << (ok == true ? \"YES\" : \"NO\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\n#define EPS 1e-7\n\ntypedef complex<double> point;\ntypedef const point &refpoint;\n\n\ndouble dot(refpoint a, refpoint b){\n\treturn real(a) * real(b) + imag(a) * imag(b);\n}\n\ndouble cross(refpoint a, refpoint b){\n\treturn real(a) * imag(b) - imag(a) * real(b);\n}\n\ndouble distance_l_p(refpoint a, refpoint b, refpoint c){\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\ndouble distance_ls_p(refpoint a, refpoint b, refpoint c){\n\tif( dot(b - a, c - a) <= 0.0 ) return abs(c - a);\n\tif( dot(a - b, c - b) <= 0.0 ) return abs(c - b);\n\treturn distance_l_p(a, b, c);\n}\n\nbool contains(const vector<point> &plg, refpoint pts){\n\tint cnt = 0;\n\tdouble y = imag(pts);\n\n\tfor(int i = 0; i < plg.size(); ++i){\n\t\tint j = (i + 1 == plg.size() ? 0: i + 1);\n\n\t\tif( distance_ls_p(plg[i], plg[j], pts) <= EPS ){\n\t\t\treturn true;\n\t\t}\n\n\t\tdouble dyi = imag(plg[i]) - y;\n\t\tdouble dyj = y - imag(plg[j]);\n\t\tdouble tx = (dyi * real(plg[j]) + dyj * real(plg[i])) / (dyi + dyj);\n\n\t\tif(imag(plg[i]) >= y && imag(plg[j]) < y){\n\t\t\tif( tx < real(pts) ) ++cnt;\n\t\t}\n\t\telse if(imag(plg[i]) < y && imag(plg[j]) >= y){\n\t\t\tif( tx < real(pts) ) --cnt;\n\t\t}\n\t}\n\t\n\treturn (cnt % 2 != 0);\n}\n\nbool intersected(refpoint pa1, refpoint pa2, refpoint pb1, refpoint pb2){\n\tdouble a = cross(pa2 - pa1, pb1 - pa1);\n\tdouble b = cross(pa2 - pa1, pb2 - pa1);\n\tdouble c = cross(pb2 - pb1, pa1 - pb1);\n\tdouble d = cross(pb2 - pb1, pa2 - pb1);\n\n\tif( (a < -EPS && b > EPS) || (b < -EPS && a > EPS) ){\n\t\tif( (c < -EPS && d > EPS) || (d < -EPS && c > EPS) ){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool contact(const vector<point> &plg1, const vector<point> &plg2){\n\tif( contains(plg1, plg2[0]) || contains(plg2, plg1[0]) ){\n\t\treturn true;\n\t}\n\n\tint n = plg1.size();\n\tint m = plg2.size();\n\tfor(int i = 0; i < n; ++i){\n\t\tfor(int j = 0; j < m; ++j){\n\t\t\tif( intersected(plg1[i], plg1[(i+1)%n], plg2[j], plg2[(j+1)%m]) ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n\nvector<point> convex(const vector<point> plg){\n\tif( plg.size() <= 3 ){\n\t\treturn plg;\n\t}\n\n\tvector<point> ret;\n\n\tfor(int i = 0; i < plg.size(); ++i){\n\t\tint k = ret.size();\n\n\t\tif( k < 2 || cross( ret[k-1] - ret[k-2], plg[i] - ret[k-2] ) > 0.0 ){\n\t\t\tret.push_back( plg[i] );\n\t\t}\n\t\telse{\n\t\t\tret.back() = plg[i];\n\t\t}\n\t}\n\n\tint t = ret.size() + 1;\n\tfor(int i = plg.size() - 2; i >= 0; --i){\n\t\tint k = ret.size();\n\n\t\tif( k < t || cross( ret[k-1] - ret[k-2], plg[i] - ret[k-2] ) > 0.0 ){\n\t\t\tret.push_back( plg[i] );\n\t\t}\n\t\telse{\n\t\t\tret.back() = plg[i];\n\t\t}\n\t}\n\tret.pop_back();\n\t\n\treturn ret;\n}\n\n\nint main(){\n\tint n, m;\n\tdouble x, y;\n\t\n\twhile( scanf(\"%d%d\", &n, &m), n != 0 ){\n\t\tvector<point> black, white;\n\t\tblack.reserve(n);\n\t\twhite.reserve(m);\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\tblack.push_back( point(x, y) );\n\t\t}\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\twhite.push_back( point(x, y) );\n\t\t}\n\n\n\t\tblack = convex(black);\n\t\twhite = convex(white);\n\n\t\tif( contact(black, white) ){\n\t\t\tputs(\"NO\");\n\t\t}\n\t\telse{\n\t\t\tputs(\"YES\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define all(x) begin(x),end(x)\n\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld EPS = 1e-9;\n\nusing Real = double;\nconst Real PI = acos(-1);\n\nusing Point = complex<Real>;\nnamespace std {\n    bool operator<(const Point& a, const Point& b) {\n        if (a.real() == b.real()) return a.imag() < b.imag();\n        return a.real() < b.real();\n    }\n}\nstruct Line {\n    Point a, b;\n    Line() {}\n    Line(const Point& a, const Point& b) : a(a), b(b) {}\n    friend ostream& operator<<(ostream& os, const Line& l) {\n        return os << \"[\" << l.a << \",\" << l.b << \"]\";\n    }\n};\nstruct Segment : Line {\n    Segment() = default;\n\n    Segment(const Point& a, const Point& b) : Line(a, b) {}\n};\n\ninline bool eq(Real a, Real b) { return abs(b - a) < EPS; }\n\nReal radian_to_degree(Real r) {\n    return r * 180.0 / PI;\n}\n\nReal degree_to_radian(Real d) {\n    return d * PI / 180.0;\n}\n\nPoint rotate(const Point &p, Real theta) {\n    return p * polar((Real)1.0, theta);\n}\n\nReal cross(const Point& a, const Point& b) {\n    return a.real() * b.imag() - a.imag() * b.real();\n}\n\nReal dot(const Point& a, const Point& b) {\n    return a.real() * b.real() + a.imag() * b.imag();\n}\n\nPoint projection(const Line& l, const Point& p) {\n    Real A = dot(l.b - l.a, p - l.a),\n            B = dot(l.a - l.b, p - l.b);\n    return (A * l.b + B * l.a) / (A + B);\n}\n\nbool parallel(const Line& l1, const Line& l2) {\n    return eq(cross(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\n\nbool orthogonal(const Line& l1, const Line& l2) {\n    return eq(dot(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\n\nconst int COUNTER_CLOCKWISE = 1,\n        CLOCKWISE = -1,\n        ONLINE_BACK = 2,\n        ONLINE_FRONT = -2,\n        ON_SEGMENT = 0;\nint ccw(const Point& a, Point b, Point c) {\n    b = b - a, c = c - a;\n    if (cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if (cross(b, c) < -EPS) return CLOCKWISE;\n    if (dot(b, c) < 0) return ONLINE_BACK;\n    if (norm(b) < norm(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersected(const Line& l, const Point& p) {\n    return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersected(const Segment& s, const Point& p) {\n    return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersected(const Line& l, const Segment& s) {\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool intersected(const Segment& s1, const Segment& s2) {\n    return ccw(s1.a, s1.b, s2.a) * ccw(s1.a, s1.b, s2.b) <= 0 and\n           ccw(s2.a, s2.b, s1.a) * ccw(s2.a, s2.b, s1.b) <= 0;\n}\n\nReal distance(const Line& l, const Point& p) {\n    return abs(p - projection(l, p));\n}\n\nReal distance(const Segment& s, const Point& p) {\n    Point r = projection(s, p);\n    if (intersected(s, r)) return abs(r - p);\n    return min(abs(s.a - p), abs(s.b - p));\n}\n\nReal distance(const Line &l, const Segment &s) {\n    if (intersected(l, s)) return 0;\n    return min(distance(l, s.a), distance(l, s.b));\n}\n\nReal distance(const Segment& s1, const Segment& s2) {\n    if (intersected(s1, s2)) return 0.0;\n    return min({ distance(s1, s2.a), distance(s1, s2.b),\n                 distance(s2, s1.a), distance(s2, s1.b) });\n}\n\nPoint crosspoint(const Line& l1, const Line& l2) {\n    Real A = cross(l2.a - l1.a, l2.b - l1.a),\n            B = cross(l2.b - l1.b, l2.a - l1.b);\n    return (A * l1.b + B * l1.a) / (A + B);\n}\n\nusing Polygon = vector<Point>;\n\nReal area(const Polygon& U) {\n    Real area = 0;\n    for (int i = 0; i < U.size(); ++i) {\n        area += cross(U[i], U[(i + 1) % U.size()]);\n    }\n    return area / 2.0;\n}\n\nbool is_convex(const Polygon &U) {\n    int n = U.size();\n    for (int i = 0; i < n; ++i) {\n        if (ccw(U[i], U[(i + 1) % n], U[(i + 2) % n]) == -1) return false;\n    }\n    return true;\n}\n\nconst int OUT = 0,\n        ON = 1,\n        IN = 2;\nint contains(const Polygon &U, const Point &p) {\n    int in = 0;\n    for (int i = 0; i < U.size(); ++i) {\n        Point a = U[i] - p, b = U[(i + 1) % U.size()] - p;\n        if (cross(a, b) == 0 and dot(a, b) <= 0) return ON;\n        if (a.imag() > b.imag()) swap(a, b);\n        if (a.imag() <= 0 and 0 < b.imag() and cross(a, b) < 0) in ^= 1;\n    }\n    return in ? IN : OUT;\n}\n\nvector<Point> convex_hull(vector<Point>& p, bool includeOnLine = false) {\n    int n = p.size(), k = 0;\n    if (n <= 2) return p;\n    sort(p.begin(), p.end());\n    vector<Point> ch(n * 2);\n    const Real BOUND = includeOnLine ? -EPS : EPS;\n    for (int i = 0; i < n; ch[k++] = p[i++]) {\n        while (k >= 2 and cross(ch[k-1] - ch[k-2], p[i] - ch[k-1]) < BOUND) --k;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = p[i--]) {\n        while (k >= t and cross(ch[k-1] - ch[k-2], p[i] - ch[k-1]) < BOUND) --k;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n\n\n#define pcnt __builtin_popcount\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    for (;;) {\n        int n, m; cin >> n >> m;\n        if (n == 0 and m == 0) break;\n        vector<Point> black, white;\n        REP(i, n) {\n            double x, y; cin >> x >> y;\n            black.emplace_back(x, y);\n        }\n        REP(i, m) {\n            double x, y; cin >> x >> y;\n            white.emplace_back(x, y);\n        }\n\n        int ans = 1;\n\n\n        Polygon B = convex_hull(black), W = convex_hull(white);\n\n        REP(i, SZ(W)) {\n            if (contains(B, W[i])) ans = 0;\n        }\n        REP(i, SZ(B)) {\n            if (contains(W, B[i])) ans = 0;\n        }\n        REP(i, SZ(B)-1) {\n            REP(j, SZ(W) - 1) {\n                if (intersected(\n                        Segment{black[i], black[i+1]},\n                        Segment{white[j], white[j+1]}\n                )) {\n                    ans = 0;\n                }\n            }\n        }\n\n        cout << (ans ? \"YES\" : \"NO\") << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-8\n#define F first\n#define S second\nusing namespace std;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point\n{\n  public:\n  double x,y;\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nbool isIntersect(Segment s1,Segment s2)\n{\nreturn isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool cmp(const vector<Point> &a,const vector<Point> &b)\n{\n  return a.size() < b.size();\n}\n\nPolygon andrewScan(Polygon s)\n{\n  Polygon u,l;\n  if(s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<s.size();i++)\n    {\n      for(int n=u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--)\n\tu.pop_back();\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3; i>=0 ; i--)\n    {\n      for(int n=l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--)\n\tl.pop_back();\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\nbool check(int p1,int p2,vector<Point> &black,vector<Point> &white)\n{\n  int n = black.size();\n  pair<bool,bool> Left,Right;\n  Left  = pair<bool,bool>(false,false); // F->black, S->white\n  Right = pair<bool,bool>(false,false);\n\n  rep(i,n)\n    {\n      if(i == p1 || i == p2)continue;\n      int res = ccw(black[p1],black[p2],black[i]);\n      if(res == CLOCKWISE) Right.F = true;\n      if(res == COUNTER_CLOCKWISE) Left.F = true;\n    }\n  \n  n = white.size();\n  rep(i,n)\n    {\n      int res = ccw(black[p1],black[p2],white[i]);\n      if(res == CLOCKWISE) Right.S = true;\n      if(res == COUNTER_CLOCKWISE) Left.S = true;\n    }\n\n  if(Left.F && Left.S)return false;\n  if(Right.F && Right.S)return false;\n  return true;\n}\n\nvoid printVP(vector<Point> a)\n{\n  cout << \"printVP-------\" << endl;\n  rep(i,a.size())cout << \"(\" << a[i].x << \",\" << a[i].y << \") \";\n  cout << endl;\n}\n\nint main()\n{\n  int n,m;\n  while(cin >> n >> m,n|m)\n    {\n      vector<Point> A(n),B(m);\n      rep(_,n)cin >> A[_].x >> A[_].y;\n      rep(_,m)cin >> B[_].x >> B[_].y;\n\n      vector<Point> black,white;\n      if(A.size() > B.size())\n\tblack = A,white = B;\n      else\n\tblack = B,white = A;\n\n\n      if(n == 1 && m == 1)\n\t{\n\t  cout << \"YES\" << endl;\n\t  continue;\n\t}\n\n      if(black.size() == 2 && white.size() == 1)\n\t{\n\t  int res = ccw(black[0],black[1],white[0]);\n\t  if(res == ON_SEGMENT)cout << \"NO\" << endl;\n\t  else                 cout << \"YES\" << endl;\n\t  continue;\n\t}\n\n      if(black.size() == 2 && white.size() == 2)\n\t{\n\t  if(isIntersect(Segment(black[0],black[1]),Segment(white[0],white[1])))cout << \"NO\" << endl;\n\t  else                                                                  cout << \"YES\" << endl;\n\t  continue;\n\t}\n    \n      int N = black.size();\n      rep(i,N)\n\t{\n\t  if(check(i,(i+1)%N,black,white))\n\t    {\n\t      cout << \"YES\" << endl;\n\t      goto F;\n\t    }\n\t}\n      cout << \"NO\" << endl;\n    F:;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef vector<P> Pol;\n\nconst double INF = 1e40;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\n\nint sig(double r) {return (r < -EPS) ? -1 : (r > EPS) ? 1: 0;}\nbool eq(double a, double b) {return abs(a - b) < EPS;}\nbool near(P a, P b) {return abs(b - a) < EPS;}\ndouble dot(P a, P b) {return a.X * b.X + a.Y * b.Y;}\ndouble cross(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nP vec(L a) {return a.second - a.first;}\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\nint ccw(L s, P p) {\n  P a = vec(s);\n  p -= s.first;\n  double cr = cross(a, p);\n  if (eq(cr, 0)) {\n    if (sig(dot(a, p)) < 0) return BACK;\n    if (sig(norm(a) - norm(p)) < 0) return FRONT;\n    return ON;\n  }\n  return (cr > 0) ? LEFT : RIGHT;\n}\nbool iSS(L a, L b) {\n  int cwa = ccw(a, b.first) | ccw(a, b.second);\n  int cwb = ccw(b, a.first) | ccw(b, a.second);\n  if ((cwa | cwb) & ON) return true;\n  return (cwa & cwb) == (LEFT | RIGHT);\n}\nbool iLSs(L a, L b) {return sig(cross(vec(a), b.first - a.first)) * sig(cross(vec(a), b.second - a.first)) < 0;}\nP pLL(L a, L b) {return a.first + vec(a) * (cross(vec(b), b.first - a.first) / cross(vec(b), vec(a)));}\nbool lessX(P a, P b){\n  if(!eq(a.X, b.X)) return a.X < b.X;\n  if(!eq(a.Y, b.Y)) return a.Y < b.Y;\n  return false;\n}\nint sGP(Pol pol, P p) {\n  int side = -1;\n  rep (i, pol.size()) {\n    P p0 = pol[i] - p, p1 = pol[(i + 1) % pol.size()] - p;\n    if (sig(cross(p0, p1)) == 0 && sig(dot(p0, p1)) <= 0) return 0;\n    if (p0.Y > p1.Y) swap(p0, p1);\n    if (sig(p0.Y) <= 0 && 0 < sig(p1.Y) && sig(cross(p0, p1)) > 0) side *= -1;\n  }\n  return side;\n}\nint sVP(Pol pol, P p) {\n  int bit = 0;\n  rep (i, pol.size()) {\n    bit |= ccw(L(pol[i], pol[(i + 1) % pol.size()]), p);\n    if (bit & ON) return 0;\n  }\n  if (__builtin_popcount(bit) == 1) return 1;\n  return -1;\n}\nvector<P> convexHull(vector<P> p) {\n  int m = 0;\n  vector<P> q(p.size() * 2);\n  sort(p.begin(), p.end(), lessX);\n  for (int i = 0; i < int(p.size()); q[m++] = p[i++]) for (; m > 1 && sig(cross(q[m - 1] - q[m - 2], p[i] - q[m - 2])) <= 0; --m);\n  for (int i = p.size() - 2, r = m; i >= 0; q[m++] = p[i--]) for (; m > r && sig(cross(q[m - 1] - q[m - 2], p[i] - q[m - 2])) <= 0; --m);\n  q.resize(m - 1);\n  return q;\n}\n\nint main() {\n  int n, m;\n  for (;;) {\n    cin >> n >> m;\n    if (n == 0 && m == 0) break;\n    Pol white, black;\n    rep (i, n) {\n      P p;\n      cin >> p.X >> p.Y;\n      white.push_back(p);\n    }\n    rep (i, m) {\n      P p;\n      cin >> p.X >> p.Y;\n      black.push_back(p);\n    }\n    Pol wc = convexHull(white);\n    Pol bc = convexHull(black);\n    if (wc.size() == 0u) wc = white;\n    if (bc.size() == 0u) bc = black;\n        if (bc.size() >= 2u) {\n      rep (i, wc.size()) {\n\tif (sVP(bc, wc[i]) >= 0) goto aaa;\n      }\n    }\n    if (wc.size() >= 2u) {\n      rep (i, bc.size()) {\n\tif (sVP(wc, bc[i]) >= 0) goto aaa;\n      }\n    }\n    if (wc.size() >= 2u && bc.size() >= 2u) {\n      rep (i, wc.size()) rep (j, wc.size()) {\n\tif (iSS(L(wc[i], wc[(i + 1) % wc.size()]), L(bc[j], bc[(j + 1) % bc.size()]))) goto aaa;\n      }\n    } else if (wc.size() == 1u && bc.size() == 1u) {\n      if (near(wc[0], bc[0])) goto aaa;\n    }\n    cout << \"YES\" << endl;\n    continue;\n  aaa:;\n    cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Hello. I'm Peter.\n#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<functional>\n#include<cctype>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define peter cout<<\"i am peter\"<<endl\n#define input freopen(\"data.txt\",\"r\",stdin)\n#define randin srand((unsigned int)time(NULL))\n#define INT (0x3f3f3f3f)*2\n#define LL (0x3f3f3f3f3f3f3f3f)*2\n#define gsize(a) (int)a.size()\n#define len(a) (int)strlen(a)\n#define slen(s) (int)s.length()\n#define pb(a) push_back(a)\n#define clr(a) memset(a,0,sizeof(a))\n#define clr_minus1(a) memset(a,-1,sizeof(a))\n#define clr_INT(a) memset(a,INT,sizeof(a))\n#define clr_true(a) memset(a,true,sizeof(a))\n#define clr_false(a) memset(a,false,sizeof(a))\n#define clr_queue(q) while(!q.empty()) q.pop()\n#define clr_stack(s) while(!s.empty()) s.pop()\n#define rep(i, a, b) for (int i = a; i < b; i++)\n#define dep(i, a, b) for (int i = a; i > b; i--)\n#define repin(i, a, b) for (int i = a; i <= b; i++)\n#define depin(i, a, b) for (int i = a; i >= b; i--)\n#define pi acos(-1.0)\n#define eps 1e-10\n#define MOD 1000000007\n#define MAXN\n#define N 200\n#define M\nint dcmp(double x){//蛻、譁ュx豁」雍滓?荳コ0\n    if(fabs(x)<eps) return 0;\n    else if(x<0) return -1;\n    else return 1;\n}\nstruct Point{\n    double x,y;\n    Point(){};\n    Point(double xx,double yy):x(xx),y(yy){};\n};\nbool operator<(const Point A,const Point B){\n    return A.x < B.x || (A.x == B.x && A.y < B.y);\n}\ntypedef Point Vector;\nvoid readPoint(Point &a){//霎灘?荳?クェ轤ケ\n    cin>>a.x>>a.y;\n}\nVector operator -(const Vector a,const Vector b){//荳、蜷鷹?逶ク蜃?    return Vector(a.x-b.x,a.y-b.y);\n}\ndouble operator &(const Vector a,const Vector b){//荳、蜷鷹?蜿臥ァッ\n    return a.x*b.y-a.y*b.x;\n}\nint ConvexHull(Point *p,int n,Point *ch){\n    sort(p,p+n);\n    int m=0;\n    rep(i,0,n){\n        while(m>1 && dcmp((ch[m-1]-ch[m-2])&(p[i]-ch[m-2]))<=0) m--;\n        ch[m++]=p[i];\n    }\n    int k=m;\n    depin(i,n-2,0){\n        while(m>k && dcmp((ch[m-1]-ch[m-2])&(p[i]-ch[m-2]))<=0) m--;\n        ch[m++]=p[i];\n    }\n    ch[m++] = ch[0];\n    if(n>1) m--;\n    return m;\n}\nbool SegmentStrictlyBananaSegment(Point p1,Point p2,Point w1,Point w2){//蛻、譁ュ荳、郤ソ谿オ譏ッ蜷ヲ荳・譬シ鬥呵負(荳榊桁諡ャ遶ッ轤ケ)\n    double x1=(w2-w1)&(p1-w1);\n    double x2=(w2-w1)&(p2-w1);\n    double x3=(p2-p1)&(w1-p1);\n    double x4=(p2-p1)&(w2-p1);\n    return dcmp(x1)*dcmp(x2)<0 && dcmp(x3)*dcmp(x4)<0;\n}\nbool PointInConvex(Point a, Point* ch, int n){\n    int i;\n    if(n==3){\n        if(a.x < min(ch[0].x, ch[1].x) || a.x > max(ch[0].x, ch[1].x)) return false;\n        if(a.y < min(ch[0].y, ch[1].y) || a.y > max(ch[0].y, ch[1].y)) return false;\n    }\n    for(i=1;i<n;i++){\n        if( ((ch[i]-ch[i-1])&(a-ch[i-1])) < 0) return false;\n    }\n    return true;\n}\nint n,m,num_ch1,num_ch2;\nPoint black[N],ch1[N],white[N],ch2[N];\nint main(){\n//    input;\n    while(~scanf(\"%d %d\",&n,&m) && (n+m)){\n        clr(black);\n        clr(white);\n        clr(ch1);\n        clr(ch2);\n        rep(i,0,n){\n            readPoint(black[i]);\n        }\n        rep(i,0,m){\n            readPoint(white[i]);\n        }\n        bool ok=true;\n        if(n==1 && m==1) ok=true;\n        else if(n==1){\n            num_ch2=ConvexHull(white,m,ch2);\n            if(PointInConvex(black[0],ch2,num_ch2)) ok=false;\n            else ok=true;\n        }\n        else if(m==1){\n            num_ch1=ConvexHull(black,n,ch1);\n            if(PointInConvex(white[0],ch1,num_ch1)) ok=false;\n            else ok=true;\n        }\n        //n!=1 && m!=1\n        else{\n            num_ch1=ConvexHull(black,n,ch1);\n            num_ch2=ConvexHull(white,m,ch2);\n            rep(i,1,num_ch1){\n                if(!ok) break;\n                rep(j,1,num_ch2){\n                    if(SegmentStrictlyBananaSegment(ch1[i],ch1[i-1],ch2[j],ch2[j-1])){\n                        ok=false;\n                        break;\n                    }\n                }\n            }\n            rep(i,0,n){\n                if(!ok) break;\n                if(PointInConvex(black[i],ch2,num_ch2)) ok=false;\n            }\n            rep(i,0,m){\n                if(!ok) break;\n                if(PointInConvex(white[i],ch1,num_ch1)) ok=false;\n            }\n        }\n        printf(\"%s\\n\",ok?\"YES\":\"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//Hello. I'm Peter.\n#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<functional>\n#include<cctype>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define peter cout<<\"i am peter\"<<endl\n#define input freopen(\"data.txt\",\"r\",stdin)\n#define randin srand((unsigned int)time(NULL))\n#define INT (0x3f3f3f3f)*2\n#define LL (0x3f3f3f3f3f3f3f3f)*2\n#define gsize(a) (int)a.size()\n#define len(a) (int)strlen(a)\n#define slen(s) (int)s.length()\n#define pb(a) push_back(a)\n#define clr(a) memset(a,0,sizeof(a))\n#define clr_minus1(a) memset(a,-1,sizeof(a))\n#define clr_INT(a) memset(a,INT,sizeof(a))\n#define clr_true(a) memset(a,true,sizeof(a))\n#define clr_false(a) memset(a,false,sizeof(a))\n#define clr_queue(q) while(!q.empty()) q.pop()\n#define clr_stack(s) while(!s.empty()) s.pop()\n#define rep(i, a, b) for (int i = a; i < b; i++)\n#define dep(i, a, b) for (int i = a; i > b; i--)\n#define repin(i, a, b) for (int i = a; i <= b; i++)\n#define depin(i, a, b) for (int i = a; i >= b; i--)\n#define pi acos(-1.0)\n#define MOD 1000000007\n#define MAXN\n#define N 120\n#define M\nconst double eps = 1e-10;\nint dcmp(double x){//蛻、譁ュx豁」雍滓?荳コ0\n    if(fabs(x)<eps) return 0;\n    else if(x<0) return -1;\n    else return 1;\n}\nstruct Point{\n    double x,y;\n    Point(){};\n    Point(double xx,double yy):x(xx),y(yy){};\n    void show() { cout<<\"(\"<<x<<\",\"<<y<<\")\"<<endl; }\n};\nbool operator<(const Point A,const Point B){\n    return A.x < B.x || (A.x == B.x && A.y < B.y);\n}\ntypedef Point Vector;\nvoid readPoint(Point &a){//霎灘?荳?クェ轤ケ\n    cin>>a.x>>a.y;\n}\nVector operator - ( Point A, Point B) { return Vector(A.x-B.x, A.y-B.y); }\ndouble Cross(Vector A, Vector B) { return A.x*B.y - B.x*A.y; }\nint ConvexHull ( Point* p, int n, Point* ch)\n{\n    sort(p, p+n);\n    int m = 0;\n    for(int i = 0; i<n; i++)\n    {\n        while(m > 1 && Cross( ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0) m--;\n        ch[m++] = p[i];\n    }\n    int k = m;\n    for(int i = n-2; i>=0; i--)\n    {\n        while(m > k && Cross( ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0) m--;\n        ch[m++] = p[i];\n    }\n    ///霑倩ヲ∵隼荳?ク狗函謌仙、夊セケ蠖「縲?    ch[m++] = ch[0];\n    if(n > 1) m--;\n    return m;\n}\nbool SideCross(Point a1, Point a2, Point b1, Point b2)\n{\n    double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1),\n    c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1);\n    return dcmp(c1)*dcmp(c2)<0 && dcmp(c3)*dcmp(c4)<0;\n}\nbool pInConvex(Point a, Point* ch, int n)\n{\n    int i;\n    if(n==3)\n    {\n        if(a.x < min(ch[0].x, ch[1].x) || a.x > max(ch[0].x, ch[1].x)) return 0;\n        if(a.y < min(ch[0].y, ch[1].y) || a.y > max(ch[0].y, ch[1].y)) return 0;\n    }\n    for(i=1;i<n;i++)\n    {\n        if(Cross( ch[i]-ch[i-1], a-ch[i-1] ) < 0 ) return 0;\n    }\n    return 1;\n}\nint n,m,nb,nw;\nPoint black[N],cb[N],white[N],cw[N];\nint solve()\n{\n    int i,j;\n    if(n==1&&m==1) return 1;\n    else if(n==1)\n    {\n        ///謇セ逋ス蟄仙?蛹?、夊セケ蠖「縲ょ愛譁ュ霑吩クェ鮟大ュ先弍蜷ヲ蝨ィ逋ス蛹??\n        nw=ConvexHull(white, m, cw);\n        if(pInConvex(black[0], cw, nw)) return 0;\n    }\n    else if(m==1)\n    {\n        ///謇セ鮟大ュ仙?蛹?、夊セケ蠖「縲ょ愛譁ュ霑吩クェ逋ス蟄先弍蜷ヲ蝨ィ鮟大桁蜀?        nb=ConvexHull(black, n, cb);\n        if(pInConvex(white[0], cb, nb)) return 0;\n    }\n    else\n    {\n        ///謇セ鮟醍區蜃ク蛹?、夊セケ蠖「縲ょ愛譁ュ譏ッ蜷ヲ譛臥コソ谿オ逶ク莠、謌也せ蝨ィ蜿ヲ荳?クェ蜃ク蛹??縲?        nb=ConvexHull(black, n, cb);\n        nw=ConvexHull(white, m, cw);\n        for(i=1;i<nb;i++)\n        {\n            for(j=1;j<nw;j++)\n                if(SideCross( cb[i], cb[i-1], cw[j] ,cw[j-1] )) return 0;\n        }\n        for(i=0;i<n;i++)\n            if(pInConvex(black[i], cw, nw)) return 0;\n        for(i=0;i<m;i++)\n            if(pInConvex(white[i], cb, nb)) return 0;\n    }\n    return 1;\n}\nvoid reset()\n{\n    memset(black,0,sizeof(black));\n    memset(white,0,sizeof(white));\n    memset(cw,0,sizeof(cw));\n    memset(cb,0,sizeof(cb));\n}\nint main(){\n//    input;\n    while(cin>>n>>m && (n+m)){\n        reset();\n        rep(i,0,n){\n            cin>>black[i].x>>black[i].y;\n        }\n        rep(i,0,m){\n            cin>>white[i].x>>white[i].y;\n        }\n        int ans=solve();\n        if(ans)\n            cout<<\"YES\"<<endl;\n        else\n            cout<<\"NO\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef complex<double> point;\nvector<point> pol;\nvector<point> pol2;\n\nbool eq(double a, double b) {\n  return (fabs(a-b) <= (1e-9));\n}\n\nbool lt(double a, double b) {\n  return (a - b < -(1e-9));\n}\n\nbool on_segment(point a, point b, point c) {\n  return eq(abs(b-a), abs(a-c)+abs(b-c));\n}\n\ndouble norm(point v)\n{\n  return v.real()*v.real() + v.imag()*v.imag();\n}\ndouble dot(point a, point b)\n{\n  return a.real()*b.real() + a.imag()*b.imag();\n}\ndouble cross(point a, point b)\n{\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE         = -1;\nstatic const int ONLINE_BACK       = 2;\nstatic const int ONLINE_FRONT      = -2;\nstatic const int ON_SEGMENT        = 0;\nint ccw(point p0, point p1, point p2)\n{\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a, b) > 1e-9) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -1e-9) return CLOCKWISE;\n  if(dot(a, b) < -1e-9) return ONLINE_BACK;\n  if(norm(a) < norm(b)) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(point p1, point p2, point p3, point p4)\n{\n  return (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\n\nbool sortY(point p1, point p2)\n{\n  if(p1.imag() != p2.imag()) return lt(p1.imag(), p2.imag());\n  else return lt(p1.real(), p2.real());\n}\n\nvector<point> convexHull(vector<point> ps)\n{\n  int N = ps.size(), j = 0;\n  vector<point> pg(N*2);\n  \n  if(N < 3) return ps;\n  \n  sort(ps.begin(), ps.end(), sortY);\n\n  for(int i = 0; i < N; i++, j++) {\n    while(j >= 2 && ccw(pg[j-2], pg[j-1], ps[i]) == -1) {\n      j--;\n    }\n    pg[j] = ps[i];\n  }\n  int k = j+1;\n  for(int i = N-2; i >= 0; i--, j++) {\n    while(j >= k && ccw(pg[j-2], pg[j-1], ps[i]) == -1) {\n      j--;\n    }\n    pg[j] = ps[i];\n  }\n  pg.resize(j-1);\n  return pg;\n}\n\ndouble get_r(point a, point b, point c) \n{\n  b -= a, c -= a;\n  b *= conj(c);\n  return arg(b);\n}\n\nint solve(point a)\n{\n  for(int i = 0; i < (int)pol.size(); i++)\n    if(on_segment(pol[i], pol[(i+1)%pol.size()], a)) return 1;\n  \n  double sum = 0;\n  for(int i = 0; i < (int)pol.size(); i++)\n    sum += get_r(a, pol[i], pol[(i+1)%pol.size()]);\n  \n  if(eq(sum, 0)) return 0;\n  return 2;\n}\n\nint main()\n{\n  int n, m;\n  while(cin >> n >> m, n || m) {\n    vector<point> black, white;\n    for(int i = 0; i < n; i++) {\n      double x, y;\n      cin >> x >> y;\n      black.push_back(point(x, y));\n    }\n    pol = convexHull(black);\n    for(int i = 0; i < m; i++) {\n      double x, y;\n      cin >> x >> y;\n      white.push_back(point(x, y));\n    }\n    pol2 = convexHull(white);\n    if(n < 2 && m < 2) {\n      cout << \"YES\" << endl;\n      continue;\n    } else if(n + m == 3) {\n      if(n == 2 && ccw(black[0], black[1], white[0]) == ON_SEGMENT ||\n\t m == 2 && ccw(white[0], white[1], black[0]) == ON_SEGMENT) {\n\tcout << \"NO\" << endl;\n      } else {\n\tcout << \"YES\" << endl;\n      }\n      continue;\n    } else if(n == 2 && m == 2) {\n      if(intersect(black[0], black[1], white[0], white[1])) {\n\tcout << \"NO\" << endl;\n      } else {\n\tcout << \"YES\" << endl;\n      }\n      continue;\n    }\n    bool flag = true;\n    for(int i = 0; i < 2; i++) {\n      if((int)black.size() <= 2) continue;\n      for(int j = 0; j < (int)white.size(); j++) {\n\tif(solve(white[j]) != 0) {\n\t  flag = false;\n\t  break;\n\t}\n      }\n      swap(pol, pol2);\n      swap(black, white);\n    }\n    cout << (flag ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-10)\n#define eq(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\ndouble norm(Vector v) { return v.x*v.x + v.y*v.y; }\ndouble abs(Vector v) { return sqrt(norm(v)); }\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nbool isOrthogonal(Vector a, Vector b) {\n  return eq(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isParallel(Vector a, Vector b) {\n  return eq(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n  return isParallel(a1 - a2, b1 - b2);\n}\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\ndouble getDistance(Point a, Point b) { return abs(a - b); }\ndouble getAngle(Point a, Point b, Point c) {\n  Vector v = b - a, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha) * 180 / M_PI;\n  return min(theta, 360 - theta);\n}\n\nstruct Segment {\n  Point p1, p2;\n  Segment(Point p1 = Point(), Point p2 = Point()):p1(p1), p2(p2){}\n};\ntypedef Segment Line;\n\nbool isOrthogonal(Segment s1, Segment s2) {\n  return eq(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isParallel(Segment s1, Segment s2) {\n  return eq(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p) {\n  return p + (project(s, p) - p) * 2.0;\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) {\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\ndouble getDistance(Segment s1, Segment s2) {\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPoint getCrossPointLL(Line l1, Line l2) {\n  Vector v1 = l1.p2 - l1.p1, v2 = l2.p2 - l2.p1;\n  double d = cross(v2, v1);\n  if(abs(d) < EPS) return l2.p1;\n  return l1.p1 + v1 * cross(v2, l2.p2 - l1.p1) * (1.0 / d);\n}\nLine getPerpendicularBisector(Point p1, Point p2) {\n  Point c = (p1 + p2) / 2.0;\n  Point q = Point(c.x + (p1.y - p2.y), c.y + (p2.x - p1.x));\n  return Line(c, q);\n}\n\nstruct Circle {\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0):c(c), r(r){}\n};\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n  // assert(intersect(c, l));\n  Vector pr = project(l, c.c);\n  Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n  double base = sqrt(c.r*c.r - norm(pr - c.c));\n  return make_pair(pr + e * base, pr - e * base);\n}\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n  // assert(intersect(c1, c2));\n  double d = abs(c1.c - c2.c);\n  double a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2*c1.r*d));\n  double t = arg(c2.c - c1.c);\n  return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\ntypedef vector<Point> Polygon;\n\ndouble getArea(Polygon p) {\n  double ret = 0.0;\n  for(int i = 0; i < (int)p.size(); i++) {\n    ret += cross(p[i], p[(i+1)%p.size()]);\n  }\n  return abs(ret) / 2.0;\n}\n\n#define IN_POLYGON  2\n#define ON_POLYGON  1\n#define OUT_POLYGON 0\nint contains(Polygon g, Point p) {\n  int n = g.size();\n  bool x = false;\n  for(int i = 0; i < n; i++) {\n    Point a = g[i] - p, b = g[(i+1) % n] - p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON_POLYGON;\n    if(a.y > b.y) swap(a, b);\n    if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n  }\n  return (x ? IN_POLYGON : OUT_POLYGON);\n}\n\nPolygon convexHull(Polygon ps) {\n  int N = ps.size(), j = 0;\n  Polygon pg(N*2);\n\n  if(N < 3) return ps;\n\n  sort(ps.begin(), ps.end(), [](Point p1, Point p2) -> bool {\n      return p1.y != p2.y ? lt(p1.y, p2.y) : lt(p1.x, p2.x); });\n  for(int i = 0; i < N; i++, j++) {\n    while(j >= 2 && ccw(pg[j-2], pg[j-1], ps[i]) == -1) j--;\n    pg[j] = ps[i];\n  }\n  int k = j+1;\n  for(int i = N-2; i >= 0; i--, j++) {\n    while(j >= k && ccw(pg[j-2], pg[j-1], ps[i]) == -1) j--;\n    pg[j] = ps[i];\n  }\n  pg.resize(j-1);\n  return pg;\n}\n\nPolygon convexCut(Polygon s, Line l) {\n  Polygon t;\n  for(int i = 0; i < (int)s.size(); i++) {\n    Point a = s[i], b = s[(i+1)%s.size()];\n    if(ccw(l.p1, l.p2, a) != -1) t.push_back(a);\n    if(ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0) {\n      t.push_back(getCrossPointLL(Line(a, b), l));\n    }\n  }\n  return t;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n, m;\n  while(cin >> n >> m, n || m) {\n    Polygon s(n), t(m);\n    rep(i, n) cin >> s[i].x >> s[i].y;\n    rep(i, m) cin >> t[i].x >> t[i].y;\n\n    if(n < 2 && m < 2) {\n      puts(\"YES\"); continue;\n    }\n    if(n + m <= 3) {\n      if(n == 2 && ccw(s[0], s[1], t[0]) == ON_SEGMENT ||\n\t m == 2 && ccw(t[0], t[1], t[0]) == ON_SEGMENT) {\n\tputs(\"NO\"); continue;\n      }\n      puts(\"YES\"); continue;\n    }\n    if(n == 2 && m == 2) {\n      if(intersect(s[0], s[1], t[0], t[1])) {\n\tputs(\"NO\"); continue;\n      }\n      puts(\"YES\"); continue;\n    }\n\n    auto S = convexHull(s);\n    auto T = convexHull(t);\n    bool flag = true;\n    for(auto&& p : t) flag &= (contains(S, p) == 0);\n    for(auto&& p : s) flag &= (contains(T, p) == 0);\n    cout << (flag ? \"YES\" : \"NO\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = 1e9;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> P;\n\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n\n/** 幾何ライブラリ **/\n#include <complex>\n\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-8;\n\ntypedef double D;\ntypedef complex<D> P; // Point\n\nstruct L { // Line\n\tP a, b;\n\tL(){}\n\tL(P aa, P bb) : a(aa), b(bb){}\n};\n\n// 共役複素数 conj(a);\n\n// 符号\nint sig(D a, D b=0) { return a < b - EPS ? -1 : (a > b + EPS ? 1 : 0); }\n\n// 内積\nD dot(P a, P b) { return (conj(a)*b).real(); }\n\n// 外積\nD cross(P a, P b) { return (conj(a)*b).imag(); }\n\n// 線分abに対する点cの位置\nenum STATE{LEFT=1, RIGHT=-1, BACK=2, FRONT=-2, ON=0, IN=3, OUT=-3};\nint ccw(P a, P b, P c)\n{\n\tb -= a, c -= a;\n\tD s = sig(cross(b, c));\n\tif (s) return s>0 ? LEFT : RIGHT;\n\tif (sig(dot(b, c))<0) return BACK;\n\tif (sig(abs(c), abs(b))>0) return FRONT;\n\treturn ON;\n}\n\n// 直線lに対する点pの写像\nP projection(L l, P p)\n{\n\treturn l.a + (l.b-l.a)/abs(l.b-l.a) * dot(l.b-l.a, p-l.a)/abs(l.b-l.a);\n}\n\n// 直線lに対する点pの反射\nP reflection(L l, P p)\n{\n\treturn p + (projection(l, p)-p)*P(2, 0);\n}\n\n// 直線abと点cの距離\nD dLP(L l, P c)\n{\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分abと点cの距離\nD dSP(L l, P c)\n{\n\tif (sig(dot(l.b-l.a, c-l.a))<0) return abs(c-l.a);\n\tif (sig(dot(l.a-l.b, c-l.b))<0) return abs(c-l.b);\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分と線分の交差判定\nbool iSS(L s, L t)\n{\n\treturn (ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0)\n\t\t\t&& (ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0);\n}\n\n// 線分と線分の距離\nD dSS(L s, L t)\n{\n\tif (iSS(s, t)) return 0;\n\treturn min(min(dSP(t, s.a), dSP(t, s.b)), min(dSP(s, t.a), dSP(s, t.b)));\n}\n\n// 線分と線分の交点 (公差していることが前提)\nP cSS(L s, L t)\n{\n\tD d1 = dLP(t, s.a);\n\tD d2 = dLP(t, s.b);\n\tD tmp = d1 / (d1 + d2);\n\treturn s.a + (s.b-s.a)*tmp;\n}\n\n// 直線と直線の交差判定\nbool iLL(L s, L t)\n{\n\treturn sig(cross(s.b-s.a, t.b-t.a))!=0;\n}\n\n// 直線と直線の交点 iLLを確認してから使用\nP cLL(L s, L t)\n{\n\tP ss = s.b - s.a, tt = t.b - t.a;\n\treturn s.a + ss*cross(tt, t.a-s.a)/cross(tt, ss);\n}\n\n// 多角形\ntypedef vector<P> G;\n\n// 面積を求める (時計回りだと負になる)\nD area(G g)\n{\n\tD res = 0.0;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tres += cross(g[i], g[(i+1)%g.size()]);\n\t}\n\treturn res/2;\n}\n\n// 多角形gと点pの包含関係を求める\nint containsGP(G g, P p)\n{\n\tbool in=false;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tP a = g[i], b = g[(i+1)%g.size()];\n\t\tif (ccw(a, b, p) == ON) return ON;\n\t\t\n\t\ta -= p, b -= p;\n\t\tif (a.Y > b.Y) swap(a, b);\n\t\tif (a.Y<0 && b.Y>=0 && sig(cross(a, b))>0) in = !in;\n\t}\n\treturn in?IN:OUT;\n}\n\nbool cmp_convex_full(const P &a, const P &b)\n{\n\tif (sig(a.X, b.X) != 0) return a.X < b.X;\n\treturn a.Y < b.Y;\n}\n\n// 凸包を得る\n// 辺上を含めない場合は <= 0 にする\nG convex_hull(vector<P> ps)\n{\n\tif (ps.size()==1) return ps;\n\t\n\tint N = (int)ps.size(), k=0;\n\tsort(ps.begin(), ps.end(), cmp_convex_full);\n\tG res(2*N);\n\t\n\tfor (int i=0; i<N; i++) {\n\t\twhile (k>=2 && ccw(res[k-2], res[k-1], ps[i]) == RIGHT) k--;\n\t\tres[k++] = ps[i];\n\t}\n\t\n\tint t = k+1;\n\tfor (int i=N-2; i>=0; i--) {\n\t\twhile (k>=t && ccw(res[k-2], res[k-1], ps[i]) == RIGHT) k--;\n\t\tres[k++] = ps[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// 凸多角形を直線で切断し、左側を残す\nG convex_cut(G g, L l)\n{\n\tG res;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tP a = g[i], b = g[(i+1)%g.size()];\n\t\tif (ccw(l.a, l.b, a) != RIGHT) res.push_back(a);\n\t\tif (ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0) res.push_back(cLL(L(a, b), l));\n\t}\n\treturn res;\n}\n\n\n/** Problem1298 : Separate Points **/\nint main()\n{\n\tint N, M;\n\twhile (cin>>N>>M, N||M) {\n\t\tvector<P> bp(N), wp(M);\n\t\trep(i, N) cin>>bp[i].X>>bp[i].Y;\n\t\trep(i, M) cin>>wp[i].X>>wp[i].Y;\n\t\t\n\t\tG bc = convex_hull(bp);\n\t\tG wc = convex_hull(wp);\n\n\t\tbool ok = true;\n\n\t\tif (bc.size()==2 && wc.size()==2) {\n\t\t\tif (iSS(L(bc[0], bc[1]), L(wc[0], wc[1]))) ok=false;\n\t\t} if (bc.size()==1 && wc.size()==2) {\n\t\t\tif (ccw(wc[0], wc[1], bc[0]) == ON) ok=false;\n\t\t} else if (wc.size()==1 && bc.size()==2) {\n\t\t\tif (ccw(bc[0], bc[1], wc[0]) == ON) ok=false;\n\t\t} else {\n\t\t\tif (bc.size()>2) {\n\t\t\t\tfor (int i=0; i<wc.size(); i++) {\n\t\t\t\t\tif (containsGP(bc, wc[i]) == IN) ok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (wc.size()>2) {\n\t\t\t\tfor (int i=0; i<bc.size(); i++) {\n\t\t\t\t\tif (containsGP(wc, bc[i]) == IN) ok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (ok?\"YES\":\"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#define eps 1e-9\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tdouble add(double a, double b){\n\t\tif(fabs(a+b) < eps * (fabs(a) + fabs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d operator+(vec2d ope){\n\t\treturn vec2d(add(x, ope.x), add(y, ope.y));\n\t}\n\tvec2d operator-(vec2d ope){\n\t\treturn vec2d(add(x, -ope.x), add(y, -ope.y));\n\t}\n\tvec2d operator*(double t){\n\t\treturn vec2d(x*t, y*t);\n\t}\n\tbool operator<(vec2d ope){\n\t\treturn x < ope.x || (x == ope.x && y < ope.y);\n\t}\n\tdouble dot(vec2d ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(vec2d ope){\n\t\treturn add(x*ope.y, -y*ope.x);\n\t}\n};\n\nbool isOnS(vec2d p, vec2d q, vec2d x)\n{\n\treturn (p-x).cross(q-x) == 0 && (p-x).dot(q-x) <= eps;\n}\n\nbool isCross(vec2d p, vec2d q, vec2d r, vec2d s)\n{\n\tif((q-p).cross(s-r) == 0){\n\t\treturn isOnS(p, q, r) || isOnS(p, q, s) || isOnS(r, s, p) || isOnS(r, s, q);\t\n\t}\n\tdouble t = (r-p).cross(s-r) / (q-p).cross(s-r);\n\tvec2d x = p + (q-p)*t;\n\treturn isOnS(p, q, x) && isOnS(r, s, x);\n}\n\nbool isInTriangle(vec2d a, vec2d b, vec2d p)\n{\n\tif(a.cross(b) == 0) return false;\n\tdouble s = a.cross(p) / a.cross(b);\n\tdouble t = p.cross(b) / a.cross(b);\n\t\n\treturn (s >= 0 && t >= 0 && s+t <= 1);\n}\n\nbool isInConvex(vector<vec2d> &vec, vec2d p)\n{\n\tif(vec.size() <= 1) return false;\n\tif(vec.size() == 2){\n\t\treturn isOnS(vec[0], vec[1], p);\n\t}\n\t\n\tfor(int i = 1; i <= vec.size()-2; i++){\n\t\tif((vec[i] - vec[0]).cross(vec[i+1] - vec[0]) == 0){\n\t\t\tif(isOnS(vec[0], vec[i], p) || isOnS(vec[0], vec[i+1], p)) return true;\n\t\t}\n\t\telse if(isInTriangle(vec[i] - vec[0], vec[i+1] - vec[0], p - vec[0])) return true;\n\t}\n\treturn false;\n}\n\nint n, m;\nvector<vec2d> bin, win;\nvector<vec2d> black, white;\n\nvoid GrahamScan(vector<vec2d> &vec, vector<vec2d> &poly)\n{\n\tif(vec.size() == 1){\n\t\tpoly = vec;\n\t\treturn;\n\t}\n\t\n\tsort(vec.begin(), vec.end());\n\tpoly.clear();\n\tpoly.resize( 2*vec.size() );\n\t\n\tint top = -1;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\twhile(top >= 1 && (vec[i] - poly[top]).cross(poly[top-1] - poly[top]) <= 0) top--;\n\t\ttop++;\n\t\tpoly[top] = vec[i];\n\t}\n\tfor(int i = vec.size()-2, t = top; i >= 0; i--){\n\t\twhile(t >= top+1 && (vec[i] - poly[top]).cross(poly[top-1] - poly[top]) <= 0) top--;\n\t\ttop++;\n\t\tpoly[top] = vec[i];\n\t}\n\tpoly.resize(top);\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0) break;\n\t\t\n\t\tbin.clear(), win.clear();\n\t\tdouble x, y;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x >> y;\n\t\t\tbin.push_back( vec2d(x, y) );\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin >> x >> y;\n\t\t\twin.push_back( vec2d(x, y) );\n\t\t}\n\t\t\n\t\tGrahamScan(bin, black);\n\t\tGrahamScan(win, white);\n\t\t\n\t\tbool ans = true;\n\t\tfor(int bs = 0; bs < black.size(); bs++){\n\t\t\tfor(int ws = 0; ws < white.size(); ws++){\n\t\t\t\tif(isCross(black[bs], black[(bs+1)%black.size()], white[ws], white[(ws+1)%white.size()])){\n\t\t\t\t\tans = false;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(isInConvex(black, white[0])) ans = false;\n\t\tif(isInConvex(white, black[0])) ans = false;\n\t\t\n\t\tend:;\n\t\tif(ans) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Hello. I'm Peter.\n//#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<functional>\n#include<cctype>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uin;\n#define peter cout<<\"i am peter\"<<endl\n#define input freopen(\"data.txt\",\"r\",stdin)\n#define randin srand((unsigned int)time(NULL))\n#define INT (0x3f3f3f3f)*2\n#define LL (0x3f3f3f3f3f3f3f3f)*2\n#define MAXN\n#define N 510\n#define M\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nconst double eps=1e-9;\ninline int dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    else if(x<0) return -1;\n    else return 1;\n}\nint n,m;\nstruct Point{\n    double x,y;\n    Point(){};\n    Point(double xx,double yy){\n        x=xx,y=yy;\n    }\n};\ninline bool comp(const Point a,const Point b){\n    if(dcmp(a.x-b.x)) return a.x<b.x;\n    else return a.y<b.y;\n}\ntypedef Point Vector;\nVector operator+(const Vector a,const Vector b){\n    return Vector(a.x+b.x,a.y+b.y);\n}\nVector operator-(const Vector a,const Vector b){\n    return Vector(a.x-b.x,a.y-b.y);\n}\ndouble operator*(const Vector a,const Vector b){\n    return a.x*b.x+a.y*b.y;\n}\ndouble operator%(const Vector a,const Vector b){\n    return a.x*b.y-a.y*b.x;\n}\nVector operator*(const Vector a,const double b){\n    return Vector(a.x*b,a.y*b);\n}\nVector operator*(const double b,const Vector a){\n    return Vector(a.x*b,a.y*b);\n}\nbool operator ==(const Vector a,const Vector b){\n    return !dcmp(a.x-b.x)&&!dcmp(a.y-b.y);\n}\nVector operator/(const Vector a,const double b){\n    return Vector(a.x/b,a.y/b);\n}\ndouble Square_Triangle(Point p1,Point p2,Point p3){\n    //三角形面?（无方向）\n    return 0.5*fabs((p2-p1)%(p3-p1));\n}\n#define lenp res.size()\nvoid Convex_Hull(Point *p,int n,vector<Point>&res){\n    res.clear();\n    sort(p,p+n,comp);\n    for(int i=0;i<n;i++){\n        while(lenp>1&&dcmp((res[lenp-1]-res[lenp-2])%(p[i]-res[lenp-2]))<=0) res.pop_back();\n        res.push_back(p[i]);\n    }\n    int k=(int)lenp;\n    for(int i=n-2;i>=0;i--){\n        while(lenp>k&&dcmp((res[lenp-1]-res[lenp-2])%(p[i]-res[lenp-2]))<=0) res.pop_back();\n        res.push_back(p[i]);\n    }\n    if(lenp>1) res.pop_back();\n}\nvoid readPointInt(Point &p){\n    int x,y;\n    x=read(),y=read();\n    p=Point(x,y);\n}\nPoint p1[N],p2[N];\n#define lenv1 v1.size()\n#define lenv2 v2.size()\n#define lenv v.size()\ndouble Square_ConvexHull(vector<Point>&v){//?取凸包的面?\n    //lenv>=3\n    double res=0.0;\n    for(int i=1;i<lenv-1;i++){\n        res+=Square_Triangle(v[0],v[i],v[i+1]);\n    }\n    return res;\n}\ndouble Square_PointWithConvexHull(Point p,vector<Point>&v){\n    //求一点?凸包?一圈形成的面?\n    v.push_back(v[0]);\n    double res=0.0;\n    for(int i=0;i<lenv-1;i++){\n        res+=Square_Triangle(p,v[i],v[i+1]);\n    }\n    v.pop_back();\n    return res;\n}\nbool PointOnSegment(Point p,Point p1,Point p2){\n    Vector v1=p1-p,v2=p2-p;\n    if(dcmp(v1%v2)) return false;\n    else if(dcmp(v1*v2)>0) return false;\n    else return true;\n}\nbool PointInConvexHull1_In_ConvexHull2(vector<Point>&v1,vector<Point>&v2){\n    if(lenv1==1&&lenv2==1) return v1[0]==v2[0];\n    if(lenv1==1&&lenv2==2) return PointOnSegment(v1[0],v2[0],v2[1]);\n    if(lenv2>=3){\n        double Sv2=Square_ConvexHull(v2);\n        for(int i=0;i<lenv1;i++){\n            double St=Square_PointWithConvexHull(v1[i],v2);\n            if(!dcmp(St-Sv2)) return true;\n        }\n    }\n    return false;\n}\nbool Segment1_Inter_Segment2(Point p1,Point p2,Point q1,Point q2){\n    if(!dcmp((p1-p2)%(q1-q2))){\n        return PointOnSegment(p1,q1,q2)||PointOnSegment(p2,q1,q2)||PointOnSegment(q1,p1,p2)||PointOnSegment(q2,p1,p2);\n    }\n    else{\n        int t1=dcmp((p2-p1)%(q1-p1));\n        int t2=dcmp((p2-p1)%(q2-p1));\n        int t3=dcmp((q2-q1)%(p1-q1));\n        int t4=dcmp((q2-q1)%(p2-q1));\n        return t1*t2<=0&&t3*t4<=0;\n    }\n}\nbool ConvexHull1_Inter_ConvexHull2(vector<Point>&v1,vector<Point>&v2){\n    //凸包点是否在?一个凸包内\n    if(PointInConvexHull1_In_ConvexHull2(v1,v2)) return true;\n    if(PointInConvexHull1_In_ConvexHull2(v2,v1)) return true;\n    //?凸包?段是否相交\n    if(lenv1>=2&&lenv2>=2){\n        v1.push_back(v1[0]);\n        v2.push_back(v2[0]);\n        for(int i=0;i<lenv1-1;i++){\n            for(int j=0;j<lenv2-1;j++){\n                if(Segment1_Inter_Segment2(v1[i],v1[i+1],v2[j],v2[j+1])){\n                    v1.pop_back();\n                    v2.pop_back();\n                    return true;\n                }\n            }\n        }\n        v1.pop_back();\n        v2.pop_back();\n    }\n    return false;\n}\nint main(){\n    while(1){\n        n=read(),m=read();\n        if(!n&&!m) break;\n        for(int i=0;i<n;i++){\n            readPointInt(p1[i]);\n        }\n        vector<Point>res1;\n        Convex_Hull(p1,n,res1);\n        for(int i=0;i<m;i++){\n            readPointInt(p2[i]);\n        }\n        vector<Point>res2;\n        Convex_Hull(p2,m,res2);\n        if(ConvexHull1_Inter_ConvexHull2(res1,res2)){\n            printf(\"NO\\n\");\n        }\n        else printf(\"YES\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\n#include <complex>\ntypedef complex<double> P;\n#define EQ(x, y) (abs((x)-(y)) < EPS)\ndouble dot(P a, P b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\ndouble cross(P a, P b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\nint is_point_on_line(P a, P b, P c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nint is_intersected_l_ls(P a1, P a2, P b1, P b2) {\n    if ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < -EPS )\n        return true;\n    return is_point_on_line(a1, a2, b1) || is_point_on_line(a1, a2, b2);\n}\nint is_point_on_ls(P a, P b, P c) {\n    // |a-c| + |c-b| <= |a-b| then true\n    return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n\n\ntypedef vector<P> vp;\n\nbool can_separate(int edge1,int edge2,int parent_o,int parent_t,vp &ours,vp &theirs){\n\tif(parent_o!=-1){\n\t\tif(!is_intersected_l_ls(ours[edge1],ours[edge2],ours[parent_o],theirs[parent_t])){\n\t\t\treturn false;\n\t\t}\n\t}\n\tif(parent_o!=-1){\n\t\tREP(i,ours.size()){\n\t\t\tif(i!=parent_o&&i!=edge1&&i!=edge2){\n\t\t\t\tif(is_intersected_l_ls(ours[edge1],ours[edge2],ours[i],ours[parent_o])){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,theirs.size()){\n\t\tif(i!=parent_t){\n\t\t\tif(is_intersected_l_ls(ours[edge1],ours[edge2],theirs[i],theirs[parent_t])){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n\t\tvp black,white;\n\t\tREP(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tblack.push_back(P(x,y));\n\t\t}\n\t\tREP(i,m){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\twhite.push_back(P(x,y));\n\t\t}\n\n\t\tbool ok=false;\n\t\tbool all_on_line=true;\n\t\tbool scrumbled=false;\n\t\tif(n==1&&m==1){\n\t\t\tok=true;\n\t\t\tgoto show;\n\t\t}else if(n==2&&m==1){\n\t\t\tok=!is_point_on_ls(black[0],black[1],white[0]);\n\t\t\tgoto show;\n\t\t}else if(n==1&&m==2){\n\t\t\tok=!is_point_on_ls(white[0],white[1],black[0]);\n\t\t\tgoto show;\n\t\t}\n\n\n\t\tREP(i,n+m){\n\t\t\tP ip=(i<n?black[i]:white[i-n]);\n\t\t\tREP(j,n+m){\n\t\t\t\tP jp=(j<n?black[j]:white[j-n]);\n\t\t\t\tREP(k,n+m){\n\t\t\t\t\tP kp=(k<n?black[k]:white[k-n]);\n\t\t\t\t\tif(!is_point_on_line(ip,jp,kp)){\n\t\t\t\t\t\tall_on_line=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(is_point_on_ls(ip,jp,kp)){\n\t\t\t\t\t\tif((i<n)==(j<n)&&(i<n)!=(k<n)){\n\t\t\t\t\t\t\tscrumbled=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(all_on_line){\n\t\t\tok=!scrumbled;\n\t\t\tgoto show;\n\t\t}\n\n\t\tREP(i1,n){\n\t\t\tFOR(i2,i1+1,n){\n\t\t\t\tint parent_o=-1;\n\t\t\t\tREP(j,n){\n\t\t\t\t\tif(j!=i1&&j!=i2){\n\t\t\t\t\t\tparent_o=j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(can_separate(i1,i2,parent_o,0,black,white)){\n\t\t\t\t\tok=true;\n\t\t\t\t\tgoto show;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i1,m){\n\t\t\tFOR(i2,i1+1,m){\n\t\t\t\tint parent_o=-1;\n\t\t\t\tREP(j,m){\n\t\t\t\t\tif(j!=i1&&j!=i2){\n\t\t\t\t\t\tparent_o=j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(can_separate(i1,i2,parent_o,0,white,black)){\n\t\t\t\t\tok=true;\n\t\t\t\t\tgoto show;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nshow:\n\t\tcout<<(ok?\"YES\":\"NO\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//update 2009/6/21\n// uva accept 218.11626,681\n#include<iostream>\n#include<complex>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\n\ntypedef complex<double> P;\n//typedef complex<int> P;\nconst double eps = 1e-10;\n#define SIZE N\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n//ê¼üÌf[^ðÈ­Í<0,È«½­È¢Í<=0É·éÆ¢¢B\nint ccw(P a,P b){\n    if ( cross(a,b) <0)return 1;\n    else return -1;\n}\nbool cmp(const P&a,const P&b){\n  if ( a.real() != b.real())return a.real()<b.real();\n  else return a.imag() < b.imag();\n}\n\nvoid ConvexHull(int n,P *inp,P *out,int &p){\n  sort(inp,inp+n,cmp);\n  bool used[n];\n  int num[n];\n  fill(used,used+n,false);\n  p=0;\n  out[p++]=inp[0];out[p++]=inp[1];\n  used[1]=true;\n  num[0]=0;num[1]=1;\n  for(int i=2;i<n;i++){//upper bound\n    while(p>=2){\n      if ( ccw(out[p-1]-out[p-2],inp[i]-out[p-2]) ==1)break;\n      else {\n\tused[num[p-1]]=false;\n\tp--;\n      }\n    }\n    num[p]=i;\n    used[i]=true;\n    out[p++]=inp[i];\n  }\n  for(int i=n-2,t=p+1;i>=0;i--){\n    if ( used[i] == true)continue;\n    while(p>=t){//·ÅÉÊïÉÈÁ½_ðÁ³È¢æ¤É·éB\n      if ( ccw(out[p-1]-out[p-2],inp[i]-out[p-2]) ==1)break;\n      else p--;\n    }\n    out[p++]=inp[i];\n  }\n  return;\n}\n\nbool isp(P a,P b,P c){\n  return abs(a-c)+abs(b-c) < abs(a-b)+eps;\n}\n\nbool is_in(int n,P* in,P a){\n  int cnt =0;\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n\tcross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (  ( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<-eps ) && \n\t( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)<-eps))return true;\n  else return false;\n}\n\n\nbool solve(int n,P *in,int m,P *in2){\n  rep(i,n){\n    if (is_in(m,in2,in[i]))return false;\n  }\n  \n  rep(i,m){\n    if (is_in(n,in,in2[i]))return false;\n  }\n\n  rep(i,n){\n    rep(j,m){\n      if (is_intersected_ls(in[i],in[(i+1)%n],in2[j],in2[(j+1)%m]))\n\treturn false;\n    }\n  }\n\n\n\n  return true;\n}\n\nmain(){\n  int n,m;\n  P in[200],in2[200],gon[200],gon2[200];\n  while(cin>>n>>m &&n){\n    rep(i,n)cin>>in[i].real()>>in[i].imag();\n    rep(i,m)cin>>in2[i].real()>>in2[i].imag();\n\n    int nn=0,mm=0;\n    ConvexHull(n, in,gon, nn);\n    ConvexHull(m,in2,gon2,mm);\n    if (solve(nn,gon,mm,gon2))puts(\"YES\");\n    else puts(\"NO\");\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef pair<int,int> P;\n\n//for vector\ninline int norm(const P &a){ return a.fs*a.fs + a.sc*a.sc; }\ninline int dot(const P &a, const P &b){return a.fs*b.fs + a.sc*b.sc;}\ninline int cross(const P &a, const P &b){return a.fs*b.sc - a.sc*b.fs;}\n\ninline int ccw(const P &a,P b,P c){\n  b.fs -= a.fs; b.sc -= a.sc;\n  c.fs -= a.fs; c.sc -= a.sc;\n  if (cross(b,c)>0) return 1;   //counter clockwise\n  if (cross(b,c)<0) return -1; //clockwise\n  if (dot(b, c)<-0) return 2;   //c--a--b on line\n  if (norm(b)<norm(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n\n  int n,m;\n  P b[110],w[110];\n  while(cin >> n >> m, n||m){\n    rep(i,n)cin >> b[i].fs >> b[i].sc;\n    rep(i,m)cin >> w[i].fs >> w[i].sc;\n\n    bool ans = false;\n    rep(i,n)rep(j,i){\n      bool f = true;\n      set<int> dirb;\n      rep(k,n){\n\tif(k==i || k==j)continue;\n\tint tmp = ccw(b[i],b[j],b[k]);\n\tif(tmp == 0){f = false; break;}\n\tif(abs(tmp)==1)dirb.insert(tmp);\n      }\n      if(dirb.size()==2)f = false;\n\n      set<int> dirw;\n      rep(k,m){\n\tint tmp = ccw(b[i],b[j],w[k]);\n\tif(abs(tmp) != 1){f = false; break;}\n\tdirw.insert(tmp);\n      }\n      if(dirw.size()==2)f = false;\n      if(f && (dirb.size()==0 || dirw.size()==0\n\t       || *dirb.begin() != *dirw.begin()))ans = true;\n    }\n\n    rep(i,m)rep(j,i){\n      bool f = true;\n      set<int> dirw;\n      rep(k,m){\n\tif(k==i || k==j)continue;\n\tint tmp = ccw(w[i],w[j],w[k]);\n\tif(tmp == 0){f = false; break;}\n\tif(abs(tmp)==1)dirw.insert(tmp);\n      }\n      if(dirw.size()==2)f = false;\n\n      set<int> dirb;\n      rep(k,n){\n\tint tmp = ccw(w[i],w[j],b[k]);\n\tif(abs(tmp) != 1){f = false; break;}\n\tdirb.insert(tmp);\n      }\n      if(dirb.size()==2)f = false;\n      if(f && (dirb.size()==0 || dirw.size()==0\n\t       || *dirb.begin() != *dirw.begin()))ans = true;\n    }\n\n    rep(i,n)rep(j,m){\n      bool f = true;\n      set<int> dirb;\n      rep(k,n){\n\tif(k==i)continue;\n\tint tmp = ccw(b[i],w[j],b[k]);\n\tif(tmp == 0 || tmp == -2){f = false; break;}\n\tif(abs(tmp)==1)dirb.insert(tmp);\n\tdirb.insert(tmp);\n      }\n      if(dirb.size()==2)f = false;\n\n      set<int> dirw;\n      rep(k,m){\n\tif(k==j)continue;\n\tint tmp = ccw(b[i],w[j],w[k]);\n\tif(tmp == 0 || tmp == 2){f = false; break;}\n\tif(abs(tmp)==1)dirw.insert(tmp);\n      }\n      if(dirw.size()==2)f = false;\n\n      if(f && (dirb.size()==0 || dirw.size()==0\n\t       || *dirb.begin() != *dirw.begin()))ans = true;\n    }\n\n    cout << (ans?\"YES\":\"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<iomanip>\n#include<queue>\n#include<string>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\n\ndouble eps=1e-10;\n\ndouble add(double a,double b){\n\tif(abs(a+b)<eps*(abs(a)+abs(b))){\n\t\treturn 0;\n\t}else{\n\t\treturn a+b;\n\t}\n}\n\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y):x(x),y(y){\n\t}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator *(double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tdouble dot(P p){\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n};\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).det(p2-q)==0&&(p1-q).dot(p2-q)<=0;\n}\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1+(p2-p1)*((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));\n}\n\nbool cmp_x(const P& p,const P& q){\n\tif(p.x!=q.x){\n\t\treturn p.x<q.x;\n\t}else{\n\t\treturn p.y<q.y;\n\t}\n}\n\nvector<P> convex_hull(P* ps,int n){\n\tsort(ps,ps+n,cmp_x);\n\tint k=0;\n\tvector<P> qs(2*n);\n\tfor(int i=0;i<n;++i){\n\t\twhile(k>1&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0){\n\t\t\t--k;\n\t\t}\n\t\tqs[k++]=ps[i];\n\t}\n\tfor(int i=n-2,t=k;i>=0;--i){\n\t\twhile(k>t&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0){\n\t\t\t--k;\n\t\t}\n\t\tqs[k++]=ps[i];\n\t}\n\tqs.resize(k);\n\tqs[k-1]=qs[0];\n\treturn qs;\n}\n\nvoid solve(int s,int t){\n\tint n[2];\n\tvector<P> qs[2];\n\tn[0]=s;\n\tn[1]=t;\n\tfor(int k=0;k<2;++k){\n\t\tP ps[100];\n\t\tfor(int i=0;i<n[k];++i){\n\t\t\tcin>>ps[i].x>>ps[i].y;\n\t\t}\n\t\tqs[k]=convex_hull(ps,n[k]);\n\t\tif(qs[k].size()==1){\n\t\t\tqs[k].resize(2);\n\t\t\tqs[k][1]=qs[k][0];\n\t\t}\n\t}\n\tbool f=false;\n\tfor(int i=0;i<qs[0].size()-1;++i){\n\t\tfor(int j=0;j<qs[1].size()-1;++j){\n\t\t\tif((qs[0][i]-qs[0][i+1]).det(qs[1][j]-qs[1][j+1])==0){\n\t\t\t\tf=on_seg(qs[0][i],qs[0][i+1],qs[1][j])||on_seg(qs[0][i],qs[0][i+1],qs[1][j+1])||on_seg(qs[1][j],qs[1][j+1],qs[0][i])||on_seg(qs[1][j],qs[1][j+1],qs[0][i]);\n\t\t\t}else{\n\t\t\t\tP r=intersection(qs[0][i],qs[0][i+1],qs[1][j],qs[1][j+1]);\n\t\t\t\tf=on_seg(qs[0][i],qs[0][i+1],r)&&on_seg(qs[1][j],qs[1][j+1],r);\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(f){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t}\n\tif(f){\n\t\tcout<<\"NO\"<<endl;\n\t\treturn;\n\t}\n\tif(qs[0][0].x==qs[1][0].x){\n\t\tcout<<\"YES\"<<endl;\n\t\treturn;\n\t}else if(qs[0][0].x>qs[1][0].x){\n\t\tswap(qs[0],qs[1]);\n\t}\n\tP p0=qs[1][0],e2=((P){0,1});\n\tvector<P> r;\n\tfor(int i=0;i<qs[0].size()-1;++i){\n\t\tif((qs[0][i]-qs[0][i+1]).det(e2)==0){\n\t\t\tif(qs[0][i].x==p0.x&&qs[0][i].y<p0.y&&p0.y<qs[0][i+1].y){\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}else{\n\t\t\tP rc=intersection(qs[0][i],qs[0][i+1],p0,p0+e2);\n\t\t\tif(on_seg(qs[0][i],qs[0][i+1],rc)){\n\t\t\t\tif(rc.x!=qs[0][i+1].x){\n\t\t\t\t\tr.pb(rc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(f){\n\t\tcout<<\"NO\"<<endl;\n\t}else if(r.size()<2){\n\t\tcout<<\"YES\"<<endl;\n\t}else{\n\t\tif(r[0].y<p0.y&&p0.y<r[1].y){\n\t\t\tcout<<\"NO\"<<endl;\n\t\t}else{\n\t\t\tcout<<\"YES\"<<endl;\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tint s,t;\n\t\tcin>>s>>t;\n\t\tif(s==0&&t==0){\n\t\t\tbreak;\n\t\t}else{\n\t\t\tsolve(s,t);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\n#define EPS 1e-7\n\ntypedef complex<double> point;\ntypedef const point &refpoint;\n\n\ndouble dot(refpoint a, refpoint b){\n\treturn real(a) * real(b) + imag(a) * imag(b);\n}\n\ndouble cross(refpoint a, refpoint b){\n\treturn real(a) * imag(b) - imag(a) * real(b);\n}\n\ndouble distance_l_p(refpoint a, refpoint b, refpoint c){\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\ndouble distance_ls_p(refpoint a, refpoint b, refpoint c){\n\tif( dot(b - a, c - a) <= 0.0 ) return abs(c - a);\n\tif( dot(a - b, c - b) <= 0.0 ) return abs(c - b);\n\treturn distance_l_p(a, b, c);\n}\n\nbool contains(const vector<point> &plg, refpoint pts){\n\tint cnt = 0;\n\tdouble y = imag(pts);\n\n\tfor(int i = 0; i < plg.size(); ++i){\n\t\tint j = (i + 1 == plg.size() ? 0: i + 1);\n\n\t\tdouble dyi = imag(plg[i]) - y;\n\t\tdouble dyj = y - imag(plg[j]);\n\t\tdouble tx = (dyi * real(plg[j]) + dyj * real(plg[i])) / (dyi + dyj);\n\n\t\tif(imag(plg[i]) >= y && imag(plg[j]) < y){\n\t\t\tif( tx < real(pts) ) ++cnt;\n\t\t}\n\t\telse if(imag(plg[i]) < y && imag(plg[j]) >= y){\n\t\t\tif( tx < real(pts) ) --cnt;\n\t\t}\n\t}\n\t\n\treturn (cnt % 2 != 0);\n}\n\nbool intersected(refpoint pa1, refpoint pa2, refpoint pb1, refpoint pb2){\n\tdouble a = cross(pa2 - pa1, pb1 - pa1);\n\tdouble b = cross(pa2 - pa1, pb2 - pa1);\n\tdouble c = cross(pb2 - pb1, pa1 - pb1);\n\tdouble d = cross(pb2 - pb1, pa2 - pb1);\n\n\tif( (a < -EPS && b > EPS) || (b < -EPS && a > EPS) ){\n\t\tif( (c < -EPS && d > EPS) || (d < -EPS && c > EPS) ){\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nbool contact(const vector<point> &plg1, const vector<point> &plg2){\n\tif( contains(plg1, plg2[0]) || contains(plg2, plg1[0]) ){\n\t\treturn true;\n\t}\n\n\tint n = plg1.size();\n\tint m = plg2.size();\n\tfor(int i = 0; i < n; ++i){\n\t\tfor(int j = 0; j < m; ++j){\n\t\t\tif( intersected(plg1[i], plg1[(i+1)%n], plg2[j], plg2[(j+1)%m]) ){\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif( distance_ls_p(plg1[i], plg1[(i+1)%n], plg2[j]) < EPS ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif( distance_ls_p(plg2[j], plg2[(j+1)%m], plg1[i]) < EPS ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\n\nbool ordercomplex(refpoint p1, refpoint p2){\n\tif( real(p1) != real(p2) )\n\t\treturn real(p1) < real(p2);\n\treturn imag(p1) < imag(p2);\n}\n\n\nvector<point> convex(vector<point> plg){\n\tint n = plg.size();\n\tif( n <= 3 ){\n\t\treturn plg;\n\t}\n\n\tsort(plg.begin(), plg.end(), ordercomplex);\n\n\tvector<point> ret(2 * n);\n\tint k = 0;\n\n\tfor(int i = 0; i < n; ++i){\n\t\twhile( k >= 2 && cross( ret[k-1] - ret[k-2], plg[i] - ret[k-2] ) <= 0.0 ){\n\t\t\t--k;\n\t\t}\n\t\tret[k++] = plg[i];\n\t}\n\n\tint t = k + 1;\n\tfor(int i = n - 2; i >= 0; --i){\n\t\twhile( k >= t && cross( ret[k-1] - ret[k-2], plg[i] - ret[k-2] ) <= 0.0 ){\n\t\t\t--k;\n\t\t}\n\t\tret[k++] = plg[i];\n\t}\n\tret.resize(k - 1);\n\t\n\treturn ret;\n}\n\n\nint main(){\n\tint n, m;\n\tdouble x, y;\n\t\n\twhile( scanf(\"%d%d\", &n, &m), n != 0 ){\n\t\tvector<point> black, white;\n\t\tblack.reserve(n);\n\t\twhite.reserve(m);\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\tblack.push_back( point(x, y) );\n\t\t}\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\twhite.push_back( point(x, y) );\n\t\t}\n\n\n\t\tblack = convex(black);\n\t\twhite = convex(white);\n\n\t\tif( contact(black, white) ){\n\t\t\tputs(\"NO\");\n\t\t}\n\t\telse{\n\t\t\tputs(\"YES\");\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res;\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps){\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d,  c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0,  1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n  int n = ps.size();\n  Polygon Q;\n  REP(i,n) {\n    Point A = ps[i], B = ps[(i+1)%n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n      Q.push_back(is_ll(l, m));\n  }\n  return Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n  for (Point q : ps) if (abs(q - p) < eps) return;\n  ps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n  g[from].push_back((Edge){from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n  int n = p.size(), m = s.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (isis_sp(s[i], p[j]))\n      vec.emplace_back(abs(s[i].a - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      add_edge(g, from, to, abs(p[from] - p[to]));\n    }\n  }\n  return g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n  int n = p.size(), m = c.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n      vec.emplace_back(arg(c[i].p - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      ld angle = vec[j+1].first - vec[j].first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n    if (vec.size() >= 2) {\n      int from = vec.back().second, to = vec.front().first;\n      ld angle = vec.front().first - vec.back().first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n  }\n  return g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n  int N = p.size();\n  polygon.clear();\n  REP(i,1024) REP(j,1024) seg2p[i][j].clear();\n  vector<vector<tuple<ld,int,bool>>> tup(N);\n  REP(i,s.size()) {\n    int a = -1, b = -1;\n    REP(j,N) if (abs(s[i].a - p[j]) < eps) a = j;\n    REP(j,N) if (abs(s[i].b - p[j]) < eps) b = j;\n    assert(a >= 0 && b >= 0);\n    tup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n    tup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n  }\n  REP(i,N) sort(ALL(tup[i]));\n  REP(i,N) {\n    REP(j,tup[i].size()) {\n      ld angle; int pos = j, from = i, to; bool flag;\n      tie(angle, to, flag) = tup[i][j];\n      if (flag) continue;\n      vector<int> ps;\n      while (!flag) {\n        ps.push_back(from);\n        get<2>(tup[from][pos]) = true;\n        seg2p[from][to].push_back(polygon.size());\n        seg2p[to][from].push_back(polygon.size());\n        angle += pi + eps;\n        if (angle > pi) angle -= 2 * pi;\n        auto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n        if (it == tup[to].end()) it = tup[to].begin();\n        from = to; tie(angle, to, flag) = *it;\n        pos = it - tup[from].begin();\n      }\n      polygon.push_back(ps);\n    }\n  }\n  Graph g(polygon.size());\n  REP(i,N) REP(j,i) {\n    if (seg2p[i][j].size() == 2) {\n      int from = seg2p[i][j][0], to = seg2p[i][j][1];\n      g[from].push_back((Edge){from, to});\n      g[to].push_back((Edge){to, from});\n    }\n  }\n  return g;\n}\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n  fprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n  Point v = l.b - l.a;\n  Line m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n  int n = p.size();\n  REP(i,n) draw_segment(Line(p[i], p[(i+1)%n]));\n}\n\nvoid draw_circle(Circle c) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nint main() {\n\tint N, M;\n\twhile ( cin >> N >> M, N || M ) {\n\t\tvector<Point> b, w;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tb.push_back( Point(x, y) );\n\t\t}\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tw.push_back( Point(x, y) );\n\t\t}\n\t\tvector<Line> can;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < M; ++j) {\n\t\t\t\tif (b[i] != w[j]) {\n\t\t\t\t\tcan.push_back(Line(b[i], w[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans = false;\n\t\tfor (int i = 0; i < can.size(); ++i) {\n\t\t\tLine& l = can[i];\n\t\t\tint cntB = 0;\n\t\t\tvector<Point> onB;\n\t\t\tfor (int j = 0; j < b.size(); ++j) {\n\t\t\t\tint c = ccw(l.a, l.b, b[j]);\n\t\t\t\tif (c == 1) {\n\t\t\t\t\t++cntB;\n\t\t\t\t}\n\t\t\t\telse if (c == 2 || c == -2 || c == 0) {\n\t\t\t\t\tonB.push_back(b[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cntW = 0;\n\t\t\tvector<Point> onW;\n\t\t\tfor (int j = 0; j < w.size(); ++j) {\n\t\t\t\tint c = ccw(l.a, l.b, w[j]);\n\t\t\t\tif (c == 1) {\n\t\t\t\t\t++cntW;\n\t\t\t\t}\n\t\t\t\telse if (c == 2 || c == -2 || c == 0) {\n\t\t\t\t\tonW.push_back(w[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((cntB+onB.size() == b.size() && cntW == 0) || (cntB == 0 && cntW+onW.size() == w.size())) {\n\t\t\t\tbool f = true;\n\t\t\t\tfor (int i = 0; i < onB.size(); ++i) {\n\t\t\t\t\tfor (int j = 0; j < onB.size(); ++j) {\n\t\t\t\t\t\tfor (int k = 0; k < onW.size(); ++k) {\n\t\t\t\t\t\t\tif (i != j && ccw(onB[i], onB[j], onW[k]) == 0) {\n\t\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < onW.size(); ++i) {\n\t\t\t\t\tfor (int j = 0; j < onW.size(); ++j) {\n\t\t\t\t\t\tfor (int k = 0; k < onB.size(); ++k) {\n\t\t\t\t\t\t\tif (i != j && ccw(onW[i], onW[j], onB[k]) == 0) {\n\t\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f) {\n\t\t\t\t\tans = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\n#define X real()\n#define Y imag()\n#define EPS (1e-9)\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\n\ndouble dot(P a, P b){ return a.X*b.X + a.Y*b.Y;}\ndouble cross(P a, P b){ return a.X*b.Y - a.Y*b.X;}\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < 0) return 2;\n  if(abs(b) + EPS < abs(c)) return -2;\n  return 0;\n}\n\nint main(){\n  int n, m;\n  while(cin >> n >> m, n){\n    vector<P> B, W;\n    double x, y;\n    for(int i = 0; i < n; ++i){\n      cin >> x >> y;\n      B.emplace_back(x,y);\n    }\n    for(int i = 0; i < m; ++i){\n      cin >> x >> y;\n      W.emplace_back(x,y);\n    }\n    bool f = true;\n    int c[] = {1,-2,-1,2,1,-2};\n    map<int,int> mp;\n    mp[1] = 4;\n    mp[-2] = 1;\n    mp[-1] = 2;\n    mp[2] = 3;\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < m; ++j){\n        set<int> b_, w_;\n        f = true;\n        for(int k = 0; k < n; ++k){\n          if(k == i) continue;\n          int t = ccw(B[i],W[j],B[k]);\n          if((!t) || t == -2){\n            f = false;\n            break;\n          }\n          b_.insert(t);\n        }\n        if(!f) break;\n        for(int k = 0; k < m; ++k){\n          if(k == j) continue;\n          int t = ccw(B[i],W[j],W[k]);\n          if((!t) || t == 2){\n            f = false;\n            break;\n          }\n          w_.insert(t);\n        }\n        if(!f) continue;\n        vector<int> B_, W_;\n        for(auto itr = b_.begin(); itr != b_.end(); ++itr) B_.emplace_back(*itr);\n        for(auto itr = w_.begin(); itr != w_.end(); ++itr) W_.emplace_back(*itr);\n        if(W_.size() > 2){\n          f = false;\n          continue;\n        }\n        if(W_.size() == 2 && W_[1] != c[mp[W_[0]]+1] && W_[1] != c[mp[W_[0]]-1]){\n          f = false;\n          continue;\n        }\n        if(B_.size() > 2){\n          f = false;\n          continue;\n        }\n        if(B_.size() == 2 && B_[1] != c[mp[W_[0]]+1] && B_[1] != c[mp[B_[0]]-1]){\n          f = false;\n          continue;\n        }\n        f = true;\n        for(int i = 0; i < B_.size(); ++i){\n          for(int j = 0; j < W_.size(); ++j){\n            if(B_[i] == W_[j]){\n              f = false;\n              break;\n            }\n          }\n        }\n        if(f){\n          cout << \"YES\" << endl;\n          break;\n        }\n      }\n      if(f) break;\n    }\n    if(!f) cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconstexpr double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint(double x_ = 0.0, double y_ = 0.0):x(x_), y(y_) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || (abs(x - p.x) < EPS && y + EPS < p.y);\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\ndouble norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ndouble dot(const point& a, const point& b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const point& a, const point& b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nstruct segment {\n\tpoint a, b;\n\tsegment(const point& a_, const point& b_):a(a_), b(b_){}\n};\n\ntypedef vector<point> polygon;\n\nint ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double tmp = cross(b, c);\n\tif(tmp > EPS) return 1; // ccw\n\tif(tmp < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\nbool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n\t\t&& ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\npolygon convex_hull(vector<point> points) {\n\tconst int n = points.size();\n\tif(n <= 3) return points;\n\n\tsort(points.begin(), points.end());\n\tint k = 0;\n\tpolygon res;\n\tres.resize(2 * n);\n\tfor(int i = 0; i < n; res[k++] = points[i++]) {\n\t\twhile(k >= 2 && ccw(res[k - 2], res[k - 1], points[i]) <= 0) --k;\n\t}\n\n\tconst int t = k + 1;\n\tfor(int i = n - 2; i >= 0; res[k++] = points[i--]) {\n\t\twhile(k >= t && ccw(res[k - 2], res[k - 1], points[i]) <= 0) --k;\n\t}\n\n\tres.resize(k - 1);\n\treturn res;\n}\n\nbool intersect(const polygon& P, const point& p) {\n\tconst int n = P.size();\n\tbool res = false;\n\tfor(int i = 0; i < n; ++i) {\n\t\tpoint v1 = P[i] - p, v2 = P[(i + 1) % n] - p;\n\t\tif(v1.y > v2.y) swap(v1, v2);\n\t\tif(v1.y < EPS && EPS < v2.y && cross(v1, v2) > EPS) res = !res;\n\t\tif(abs(cross(v1, v2)) < EPS && dot(v1, v2) < EPS) return true;\n\t}\n\n\treturn res;\n}\n\nbool intersect(const polygon& P, const segment& s) {\n\tconst int n = P.size();\n\tif(intersect(P, s.a) || intersect(P, s.b)) return true;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(intersect(segment(P[i], P[(i + 1) % n]), s)) return true;\n\t}\n\n\treturn false;\n}\n\nbool intersect(const polygon &a, const polygon &b) {\n\tconst int n = b.size();\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(intersect(a, segment(b[i], b[(i + 1) % n]))) return true;\n\t}\n\n\tfor(const auto &p : a) {\n\t\tif(intersect(b, p)) return true;\n\t}\n\n\treturn false;\n}\n\nvector<point> input_points(int n) {\n\tvector<point> res;\n\tres.reserve(n);\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tres.emplace_back(x, y);\n\t}\n\n\treturn res;\n}\n\nbool check(const vector<point> &a, const vector<point> &b) {\n\tif(a.size() == 1) {\n\t\tif(b.size() == 1) return true;\n\t\telse if(b.size() == 2) return !intersect(segment(b[0], b[1]), a[0]);\n\t\telse return !intersect(convex_hull(b), a[0]);\n\t}\n\telse if(a.size() == 2) {\n\t\tconst segment s(a[0], a[1]);\n\t\tif(b.size() == 1) return !intersect(s, b[0]);\n\t\telse if(b.size() == 2) return !intersect(s, segment(b[0], b[1]));\n\t\telse return !intersect(convex_hull(b), s);\n\t}\n\telse {\n\t\tconst polygon P = convex_hull(a);\n\t\tif(b.size() == 1) return !intersect(P, b[0]);\n\t\telse if(b.size() == 2) return !intersect(P, segment(b[0], b[1]));\n\t\telse return !intersect(P, convex_hull(b));\n\t}\n}\n\nint main() {\n\tfor(int n, m; cin >> n >> m && n;) {\n\t\tconst auto black_points = input_points(n);\n\t\tconst auto white_points = input_points(m);\n\t\tcout << (check(black_points, white_points) ? \"YES\" : \"NO\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DEBUG 1\n\n#define INF (1.0/0.0)\n#define EPS 1e-8\n#define PI 3.1415926535\n#define EQ(x, y) (abs((x)-(y))<EPS)\n#define GE(x, y) ((x)>(y)||EQ(x, y))\n#define LE(x, y) ((x)<(y)||EQ(x, y))\n#define X real()\n#define Y imag()\n\ntypedef complex<double> Point;\ntypedef Point Vec;\ntypedef array<Point, 2> Line;\ntypedef vector<Point> Poly;\n\nstruct Circle {\n  Point c;\n  double r;\n};\n\nenum Geometory {ABC=-2, CW, ON_LINE, CCW, CAB, OUTSIDE, INSIDE, ERROR}; \n\nnamespace std {\n  bool operator<(Point a, Point b) {\n    if (!EQ(a.X, b.X)) return a.X < b.X;\n    if (!EQ(a.Y, b.Y)) return a.Y < b.Y;\n    return false;\n  }\n\n  bool operator>(Point a, Point b) {\n    return b<a;\n  }\n\n  bool operator<=(Point a, Point b) {\n    return !(a>b);\n  }\n}\n\ndouble dot(Point a, Point b) {\n  return (conj(a)*b).X;\n}\n\ndouble cross(Point a, Point b) {\n  return (conj(a)*b).Y;\n}\n\nGeometory ccw(Point a, Point b, Point c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > EPS) return CCW; // ccw\n  if (cross(b, c) < -EPS) return CW; // cw\n  if (dot(b, c) < 0) return CAB; // c - a - b\n  if (norm(b) < norm(c)) return ABC; // a - b - c\n  return ERROR;\n}\n\nPoint proj(Line l, Point p) {\n  Point v = l[1]-l[0];\n  double ratio = dot(v, p-l[0]) / norm(v);\n  return l[0] + ratio*v;\n}\n\nPoint refl(Line l, Point p) {\n  return p + (proj(l, p) - p) * 2.0;\n}\n\nVec rotate(Vec v, double r) {\n  return v*Vec(cos(r), sin(r));\n}\n\nbool IsOrthogonal(Line l, Line m) {\n  Vec v1 = l[1]-l[0];\n  Vec v2 = m[1]-m[0];\n  return EQ(dot(v1, v2), 0.0);\n}\n\nbool IsParallel(Line l, Line m) {\n  Vec v1 = l[1]-l[0];\n  Vec v2 = m[1]-m[0];\n  return EQ(cross(v1, v2), 0.0);\n}\n\nbool IntersectLL(Line l, Line m) {\n  if (!EQ(cross(l[1]-l[0], m[1]-m[0]), 0.0)) return true;\n  if (EQ(cross(l[1]-l[0], m[0]-l[0]), 0.0)) return true;\n  return false;\n}\n\nbool IntersectLS(Line l, Line s) {\n  Point b = l[0];\n  Vec v = l[1]-l[0];\n  return cross(v, s[0]-b)*cross(v, s[1]-b) < EPS;\n}\n\nbool IntersectSS(Line s, Line t) {\n  if (ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) > 0) return false;\n  if (ccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) > 0) return false;\n  return true;\n}\n\nbool IntersectLP(Line l, Point p) {\n  return EQ(cross(l[1]-p, l[0]-p), 0.0);\n}\n\nbool IntersectSP(Line s, Point p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n\ndouble DistL(Line l) {\n  return abs(l[0]-l[1]);\n}\n\ndouble DistLP(Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\ndouble DistLL(Line l, Line m) {\n  if (!IntersectLL(l, m)) return 0;\n  return DistLP(l, m[0]);\n}\n\ndouble DistLS(Line l, Line s) {\n  if (IntersectLS(l, s)) return 0;\n  return min(DistLP(l, s[0]), DistLP(l, s[1]));\n}\n\ndouble DistSP(Line s, Point p) {\n  Point r = proj(s, p);\n  if (IntersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0]-p), abs(s[1]-p));\n}\n\ndouble DistSS(Line s, Line t) {\n  if (IntersectSS(s, t)) return 0;\n\n  double a = min(DistSP(s, t[0]), DistSP(s, t[1]));\n  double b = min(DistSP(t, s[0]), DistSP(t, s[1]));\n  return min(a, b);\n}\n\nLine PerpendBisect(Line seg) {\n  Point mid = (seg[0]+seg[1])/2.0;\n  return Line{mid, mid+(seg[1]-seg[0])*Vec(0, 1)};\n}\n\nPoint CrossPointLL(Line l, Line m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0];\n  if (abs(A) < EPS) assert(0);\n  return m[0] + B / A * (m[1]-m[0]);\n}\n\nvector<Point> CrossPointCL(Circle c, Line l) {\n  vector<Point> ret;\n  double d = DistLP(l, c.c);\n  if (d < c.r + EPS) {\n    double ratio = (d > c.r) ? 0.0 : sqrt(c.r*c.r - d*d);\n    Vec sgn = (l[0]-l[1]) / abs(l[0]-l[1]);\n    ret.emplace_back(proj(l, c.c) + ratio*sgn);\n    ret.emplace_back(proj(l, c.c) - ratio*sgn);\n  }\n  return ret;\n}\n\nvector<Point> CrossPointCS(Circle c, Line s) {\n  vector<Point> ret;\n  vector<Point> res = CrossPointCL(c, s);\n  if (s[0] > s[1]) swap(s[0], s[1]);\n  for (Point p : res) {\n    if (s[0] <= p && p <= s[1]) ret.emplace_back(p);\n  }\n  return ret;\n}\n\nvector<Point> CrossPointCC(Circle c1, Circle c2) {\n  vector<Point> ret;\n  double d = abs(c1.c - c2.c);\n  double rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n  double dfr = c1.r*c1.r - rc*rc;\n\n  if (EQ(dfr, 0.0)) dfr = 0.0;\n  else if(dfr < 0.0) return ret;\n\n  double rs = sqrt(dfr);\n  Vec sgn = (c2.c - c1.c) / d;\n  ret.emplace_back(c1.c + sgn*Point(rc, rs));\n  if (dfr > 0.0) ret.emplace_back(c1.c + sgn*Point(rc, -rs));\n  return ret;\n}\n\n// Get the intersection of a circle and a segment, which is obviously a segment\nLine CapCS(Circle c, Line s) {\n  Point inf(INF, INF);\n  vector<Point> cros = CrossPointCS(c, s);\n  if (cros.empty()) return Line{inf, inf};\n\n  if (cros.size() == 1) {\n    double ad = abs(s[0]-c.c);\n    double bd = abs(s[1]-c.c);\n    if (ad < min(bd, c.r)) cros.push_back(s[0]);\n    else if (bd < min(ad, c.r)) cros.push_back(s[1]);\n    else {\n      Point p = cros[0];\n      cros.push_back(p); // avoid an undefined behavior\n    }\n  }\n\n  if (cros[1] < cros[0]) {\n    swap(cros[0], cros[1]);\n  }\n\n  return Line{cros[0], cros[1]};\n}\n\nGeometory ContainsPoint(Poly poly, Point p) {\n  bool in = false;\n  int n = poly.size();\n  for (int i=0; i<n; i++) {\n    Point a = poly[i];\n    Point b = poly[(i+1)%n];\n    Vec u = a - p;\n    Vec v = b - p;\n\n    if (u.Y > v.Y) swap(u, v);\n\n    double cr = cross(u, v);\n    if (u.Y <= 0 && 0 < v.Y && cr > EPS) in ^= 1;\n    if (IntersectSP({a, b}, p)) return ON_LINE;\n  }\n\n  if (in) return INSIDE;\n  return OUTSIDE;\n}\n\n// Note that ccw(a, b, c) != CCW when a, b, c are colinear\nPoly GrahamScan(vector<Point> ps) {\n  if (ps.size() <= 2) return ps;\n\n  int k = 0;\n  int n = ps.size();\n  Poly ret(n*2);\n\n  sort(ps.begin(), ps.end());\n  for (int i=0; i<n; i++) {\n    while (k > 1 && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n    ret[k++] = ps[i];\n  }\n\n  int k_ = k;\n  for (int i=n-1; i>=0; i--) {\n    while (k > k_ && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n    ret[k++] = ps[i];\n  }\n\n  ret.resize(k-1);\n  return ret;\n}\n\nbool IsConvex(Poly ps) {\n  return GrahamScan(ps).size() == ps.size();\n}\n\nPoly CapConvexes(Poly pp, Poly qq) {\n#if DEBUG\n  assert (IsConvex(pp));\n  assert (IsConvex(qq));\n#endif\n\n  Poly ret;\n  int a = 0;\n  int b = 0;\n  int aa = 0;\n  int bb = 0;\n  int n = pp.size();\n  int m = qq.size();\n  enum {PIN, QIN, UNKNOWN} in = UNKNOWN;\n\n  auto forward_a = [&](bool put) {\n    if (put && in == PIN) ret.emplace_back(pp[a]);\n    a = (a+1)%n;\n    aa++;\n  };\n\n  auto forward_b = [&](bool put) {\n    if (put && in == QIN) ret.emplace_back(qq[b]);\n    b = (b+1)%m;\n    bb++;\n  };\n\n  auto intersect_1pt = [](Point &a, Point &b, Point &c, Point &d, Point &r) {\n    double D =  cross(b - a, d - c);\n    if (EQ(D, 0)) return false;\n    double t =  cross(c - a, d - c) / D;\n    double s = -cross(a - c, b - a) / D;\n    r = a + t * (b - a);\n    return GE(t, 0) && LE(t, 1) && GE(s, 0) && LE(s, 1);\n  };\n\n  do {\n    int apre = (a+n-1)%n;\n    int bpre = (b+m-1)%m;\n    double C = cross(pp[a]-pp[apre], qq[b]-qq[bpre]);\n    double A = cross(pp[apre]-qq[b], pp[a]-qq[b]);\n    double B = cross(qq[bpre]-pp[a], qq[b]-pp[a]);\n    Point r;\n    if (intersect_1pt(pp[apre], pp[a], qq[bpre], qq[b], r)) {\n      if (in == UNKNOWN) aa = bb = 0;\n      ret.emplace_back(r);\n      if (B > 0) in = PIN;\n      else if (A > 0) in = QIN;\n    }\n\n    if (EQ(A, 0) && EQ(B, 0) && EQ(C, 0)) {\n      if (in == PIN) forward_b(false);\n      else forward_a(false);\n    } else if (C >= 0) {\n      if (A > 0) forward_a(true);\n      else forward_b(true);\n    } else {\n      if (B > 0) forward_b(true);\n      else forward_a(true);\n    }\n  } while ((aa < n || bb < m) && aa < 2*n && bb < 2*m);\n\n  if (in == UNKNOWN) {\n    if (ContainsPoint(qq, pp[0]) != OUTSIDE) return pp;\n    if (ContainsPoint(pp, qq[0]) != OUTSIDE) return qq;\n  }\n  return ret;\n}\n\ndouble CalcArea(Poly ps) {\n  double ret = 0.0;\n  for (int i=0; i<ps.size(); i++) {\n    ret += cross(ps[i], ps[(i+1)%ps.size()]);\n  }\n  return ret/2.0;\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\npair<int, int> ConvexDiameterApexes(Poly ps) {\n#if DEBUG\n  assert (IsConvex(ps));\n#endif\n\n  int n = ps.size();\n  int is = 0;\n  int js = 0;\n  for (int i=1; i<n; i++) {\n    if (ps[i].Y > ps[is].Y) is = i;\n    if (ps[i].Y < ps[js].Y) js = i;\n  }\n\n  int maxi, maxj;\n  double maxd = norm(ps[is]-ps[js]);\n  int i = is;\n  int j = js;\n  do {\n    Vec a = ps[i+1] - ps[i];\n    Vec b = ps[j+1] - ps[j];\n    if (cross(a, b) > -EPS) j = (j+1)%n;\n    else i = (i+1)%n;\n\n    double d = norm(ps[i]-ps[j]);\n    if (d > maxd) {\n      maxd = d;\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n\n  return make_pair(maxi, maxj);\n}\n\nLine ClosestPair(vector<Point> ps) {\n  auto CompareY = [](const Point &a, const Point &b) {\n    if (a.Y != b.Y) return a.Y < b.Y;\n    return a.X < b.X;\n  };\n\n  function<Line(Point*,int)> Rec = [&Rec, &CompareY](Point *ps, int n) {\n    if (n <= 1) return Line{Point(0, 0), Point(INF, INF)};\n    \n    int m = n/2;\n    double x = ps[m].X;\n    Line a = Rec(ps, m);\n    Line b = Rec(ps+m, n-m);\n    double mind = DistL(a);\n    Line ret = a;\n    if (DistL(b) < mind) {\n      mind = DistL(b);\n      ret = b;\n    }\n\n    sort(ps, ps+n, CompareY);\n    vector<Point> qs;\n    qs.reserve(n);\n    for (int i=0; i<n; i++) {\n      if (abs(ps[i].X - x) >= mind) continue;\n\n      for (int j=0; j<qs.size(); j++) {\n        Point p1 = ps[i];\n        Point p2 = qs[qs.size()-1-j];\n        if (p1.Y - p2.Y >= mind) break;\n\n        double d = abs(p1-p2);\n        if (mind > d) {\n          mind = d;\n          ret = Line{p1, p2};\n        }\n      }\n\n      qs.emplace_back(ps[i]);\n    }\n\n    return ret;\n  };\n\n  int n = ps.size();\n  assert (n >= 2);\n  sort(ps.begin(), ps.end());\n  return Rec(&ps[0], n);\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\n// <left, right> or <upper, lower>\npair<Poly, Poly> CutConvex(Poly ps, Line l) {\n#if DEBUG\n  assert (IsConvex(ps));\n#endif\n\n  //if (l[0].Y > l[1].Y) swap(l[0], l[1]);\n  //else if (EQ(l[0].Y, l[1].Y) && l[0].X > l[1].X) swap(l[0], l[1]);\n\n  Poly left;\n  Poly right;\n  for (int i=0; i<ps.size(); i++) {\n    Point a = ps[i];\n    Point b = ps[(i+1)%ps.size()];\n\n    if (ccw(l[0], l[1], a) != CW) left.emplace_back(a);\n    else right.emplace_back(a);\n\n    Line m{a, b};\n    if (IntersectLS(l, m)) {\n      Point p = CrossPointLL(l, m);\n      left.emplace_back(p);\n      right.emplace_back(p);\n    }\n  }\n\n  return make_pair(left, right);\n}\n\nCircle Circum(Point a, Point b, Point c) {\n  Circle ret{{INF, INF}, 0.0};\n  Line l{a, b};\n  Line m{b, c};\n  Line lp = PerpendBisect(l);\n  Line mp = PerpendBisect(m);\n  if (IsParallel(lp, mp)) return ret;\n\n  ret.c = CrossPointLL(lp, mp);\n  ret.r = abs(a-ret.c);\n  return ret;\n}\n\nint n;\nint m;\nvector<Point> as;\nvector<Point> bs;\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &n, &m);\n    if (n == 0 && m == 0) return 0;\n\n    as.resize(n);\n    for (int i=0; i<n; i++) {\n      int x, y;\n      scanf(\"%d%d\", &x, &y);\n      as[i] = Point(x, y);\n    }\n  \n    bs.resize(m);\n    for (int i=0; i<m; i++) {\n      int x, y;\n      scanf(\"%d%d\", &x, &y);\n      bs[i] = Point(x, y);\n    }\n\n    Poly ach = GrahamScan(as);\n    Poly bch = GrahamScan(bs);\n    bool ans = CapConvexes(ach, bch).empty();\n    if (ans) puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#define eps 1e-9\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tdouble add(double a, double b){\n\t\tif(fabs(a+b) < eps * (fabs(a) + fabs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d operator+(vec2d ope){\n\t\treturn vec2d(add(x, ope.x), add(y, ope.y));\n\t}\n\tvec2d operator-(vec2d ope){\n\t\treturn vec2d(add(x, -ope.x), add(y, -ope.y));\n\t}\n\tvec2d operator*(double t){\n\t\treturn vec2d(x*t, y*t);\n\t}\n\tbool operator<(vec2d ope){\n\t\treturn x < ope.x || (x == ope.x && y < ope.y);\n\t}\n\tdouble dot(vec2d ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(vec2d ope){\n\t\treturn add(x*ope.y, -y*ope.x);\n\t}\n};\n\nbool isOnS(vec2d p, vec2d q, vec2d x)\n{\n\treturn (p-x).cross(q-x) == 0 && (p-x).dot(q-x) <= 0;\n}\n\nbool isCross(vec2d p, vec2d q, vec2d r, vec2d s)\n{\n\tif((q-p).cross(s-r) == 0){\n\t\treturn isOnS(p, q, r) || isOnS(p, q, s) || isOnS(r, s, p) || isOnS(r, s, q);\t\n\t}\n\tdouble t = (r-p).cross(s-r) / (q-p).cross(s-r);\n\tvec2d x = p + (q-p)*t;\n\treturn isOnS(p, q, x) && isOnS(r, s, x);\n}\n\nbool isInTriangle(vec2d a, vec2d b, vec2d p)\n{\n\tif(a.cross(b) == 0) return false;\n\tdouble s = a.cross(p) / a.cross(b);\n\tdouble t = p.cross(b) / a.cross(b);\n\t\n\treturn (s >= 0 && t >= 0 && s+t <= 1);\n}\n\nbool isInConvex(vector<vec2d> &vec, vec2d p)\n{\n\tif(vec.size() <= 2) return false;\n\tfor(int i = 1; i <= vec.size()-2; i++){\n\t\tif(isInTriangle(vec[i] - vec[0], vec[i+1] - vec[0], p - vec[0])) return true;\n\t}\n\treturn false;\n}\n\nint n, m;\nvector<vec2d> bin, win;\nvector<vec2d> black, white;\n\nvoid GrahamScan(vector<vec2d> &vec, vector<vec2d> &poly)\n{\n\tif(vec.size() == 1){\n\t\tpoly = vec;\n\t\treturn;\n\t}\n\t\n\tsort(vec.begin(), vec.end());\n\tpoly.clear();\n\tpoly.resize( 2*vec.size() );\n\t\n\tint top = -1;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\twhile(top >= 1 && (vec[i] - poly[top]).cross(poly[top-1] - poly[top]) <= 0) top--;\n\t\ttop++;\n\t\tpoly[top] = vec[i];\n\t}\n\tfor(int i = vec.size()-2, t = top; i >= 0; i--){\n\t\twhile(t >= top+1 && (vec[i] - poly[top]).cross(poly[top-1] - poly[top]) <= 0) top--;\n\t\ttop++;\n\t\tpoly[top] = vec[i];\n\t}\n\tpoly.resize(top);\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0) break;\n\t\t\n\t\tbin.clear(), win.clear();\n\t\tdouble x, y;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x >> y;\n\t\t\tbin.push_back( vec2d(x, y) );\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin >> x >> y;\n\t\t\twin.push_back( vec2d(x, y) );\n\t\t}\n\t\t\n\t\tGrahamScan(bin, black);\n\t\tGrahamScan(win, white);\n\t\t\n\t\tbool ans = true;\n\t\tfor(int bs = 0; bs < black.size(); bs++){\n\t\t\tfor(int i = 0; i <= 1; i++){\n\t\t\t\tint bt = (bs+i) % black.size();\n\t\t\t\t\n\t\t\t\tfor(int ws = 0; ws < white.size(); ws++){\n\t\t\t\t\tfor(int j = 0; j <= 1; j++){\n\t\t\t\t\t\tint wt = (ws+j) % white.size();\n\t\t\t\t\t\tif(isCross(black[bs], black[bt], white[ws], white[wt])){\n\t\t\t\t\t\t\tans = false;\n\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(isInConvex(black, white[0])) ans = false;\n\t\tif(isInConvex(white, black[0])) ans = false;\n\t\t\n\t\tend:;\n\t\tif(ans) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//??????????????????????????????\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\nusing namespace std;\ntypedef complex<double> Point;\n\nnamespace std {\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(Point u, Point v) {\n\treturn u.real() * v.imag() - u.imag() * v.real();\n}\n\ndouble dot(Point u, Point v) {\n\treturn u.real() * v.real() + u.imag() * v.imag();\n}\n\n//Define : e_Re(???), e_Im(???)\n//a -> b -> counter clockwise -> c ???  1\n//a -> b -> clockwise -> c         ??? -1\n//c--a--b  ???  2\n//a--b--c  ??? -2\n//a--b(=c) ???  0\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0) return 1;\n\tif (cross(b, c) < 0) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\n//counter clockwise, ring buffer(ch[0] == ch[last])\nvector<Point> convex_hull(vector<Point> points) {\n\tint n = points.size();\n\tint k = 0;\n\tvector<Point> ch(2 * n);\n\t\n\tsort(points.begin(), points.end());\n\t\n\t//lower hull\n\tfor (int i = 0; i < n; i++) {\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], points[i]) <= 0) k--;\n\t\tch[k] = points[i];\n\t\tk++;\n\t}\n\t\n\t//upper hull\n\tint low_k = k;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\twhile (k > low_k && ccw(ch[k - 2], ch[k - 1], points[i]) <= 0) k--;\n\t\tch[k] = points[i];\n\t\tk++;\n\t}\n\tch.resize(k);\n\treturn ch;\n}\n\n//If line (a->b), (c->d) are hit with a point, return true.\nbool is_hit_line(Point a, Point b, Point c, Point d) {\n\tdouble u = cross(b - a, c - a) * cross(b - a, d - a);\n\tdouble v = cross(d - c, a - c) * cross(d - c, b - c);\n\tif (u > 0 || v > 0) return false;\n\tif (u != 0 || v != 0) return true;\n\t\n\tif (b < a) swap(a, b);\n\tif (d < c) swap(c, d);\n\t\n\tdouble eps = 1e-10;\n\tif (abs(d - a) + eps > abs(b - a) + abs(d - c)) return false;\n\treturn true;\n}\n\n//poly1, poly2 is convex polygon.\nbool is_hit(vector<Point> poly1, vector<Point> poly2) {\n\tfor (int i = 0; i < (int)poly1.size() - 1; i++) {\n\t\tfor (int j = 0; j < (int)poly2.size() - 1; j++) {\n\t\t\tif (is_hit_line(poly1[i], poly1[i + 1], poly2[j], poly2[j + 1])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nbool is_cover(vector<Point> poly, Point point) {\n\tbool in = false;\n\tfor (int i = 0; i < (int)poly.size() - 1; i++) {\n\t\tPoint a = poly[i] - point;\n\t\tPoint b = poly[i + 1] - point;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b)) if (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return false;\t//on poly\n\t}\n\treturn in;\n}\n\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m) {\n\t\tif (!n) break;\n\t\t\n\t\tvector<Point> poly1, poly2;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpoly1.push_back(Point((double)x, (double)y));\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpoly2.push_back(Point((double)x, (double)y));\n\t\t}\n\t\tpoly1 = convex_hull(poly1);\n\t\tpoly2 = convex_hull(poly2);\n\t\t\n\t\tif (is_hit(poly1, poly2) || is_cover(poly1, poly2[0]) || is_cover(poly2, poly1[0])) { cout << \"NO\" << endl; }\n\t\telse { cout << \"YES\" << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<complex>\n#define Re real()\n#define Im imag()\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\ntypedef vector<Point> Polygon;\nconst double eps = 1e-10;\n\nPoint black[105], white[105];\nPolygon bp, wp;\nint n, m, bpl, wpl;\n\nbool cmp(Point a, Point b)\n{\n    if(fabs(a.Re - b.Re) < eps) return a.Im < b.Im;\n    else return a.Re < b.Re;\n}\n\ndouble cross(const Point& a, const Point& b)\n{\n    return (conj(a) * b).Im;\n}\n\ndouble dot(const Point& a, const Point& b)\n{\n    return (conj(a) * b).Re;\n}\n\nvoid convex_hull()\n{\n    bp.resize(2 * n);\n    bpl = 0;\n    for(int i = 0; i < n; i++)\n    {\n        while(bpl > 1 && cross(bp[bpl - 1] - bp[bpl - 2], black[i] - bp[bpl - 1]) < 0) bpl--;\n        bp[bpl++] = black[i];\n    }\n    for(int i = n - 2, t = bpl; i >= 0; i--)\n    {\n        while(bpl > t && cross(bp[bpl - 1] - bp[bpl - 2], black[i] - bp[bpl - 1]) < 0) bpl--;\n        bp[bpl++] = black[i];\n    }\n    bp.resize(bpl - 1);\n    wp.resize(2 * m);\n    wpl = 0;\n    for(int i = 0; i < m; i++)\n    {\n        while(wpl > 1 && cross(wp[wpl - 1] - wp[wpl - 2], white[i] - wp[wpl - 1]) < 0) wpl--;\n        wp[wpl++] = white[i];\n    }\n    for(int i = m - 2, t = wpl; i >= 0; i--)\n    {\n        while(wpl > t && cross(wp[wpl - 1] - wp[wpl - 2], white[i] - wp[wpl - 1]) < 0) wpl--;\n        wp[wpl++] = white[i];\n    }\n    wp.resize(wpl - 1);\n}\n\nint ccw(Point& a, Point& b, Point& c)\n{\n    Point t1 = b - a, t2 = c - a;\n    if(cross(t1, t2) > 0)   return +1;        // counter clockwise\n    if(cross(t1, t2) < 0)   return -1;        // clockwise\n    if(dot(t1, t2) < 0)     return +2;        // c--a--b on line\n    if(norm(t1) < norm(t2)) return -2;        // a--b--c on line\n    return 0;\n}\n\nbool is_point_intersaction(Point a, pair <Point, Point> b)\n{\n    return (fabs( dot(b.first - a, b.second - a) - (-1.0 * sqrt(norm(b.first - a) * norm(b.second - a))) < eps));\n}\n\n       bool isintersaction(pair <Point, Point> a, pair <Point, Point> b)\n{\n    return (ccw(b.first, b.second, a.first) * ccw(b.first, b.second, a.second) <= 0 && ccw(a.first, a.second, b.first) * ccw(a.first, a.second, b.second) <= 0);\n}\n\n// 0 --- out of the polygon, 1 -- on the polygon, 2 -- in the polygon\nint checkin(const Point& t, Polygon s)\n{\n    int cnt = 0;\n    for(int i = 0; i < s.size(); i++)\n    {\n        Vector v1 = s[i] - t, v2 = s[(i + 1) % s.size()] - t;\n        if(v1.Im > v2.Im) swap(v1, v2);\n        if(v1.Im <= 0 && v2.Im > 0 && cross(v1, v2) < 0) cnt ^= 1;\n        if(cross(v1, v2) == 0 && dot(v1, v2) <= 0) return 1;\n    }\n    return cnt ? 2 : 0;\n}\n\nbool check()\n{\n    int flag = 0, f1 = 0, f2 = 0, f3 = 0;\n    for(int i = 0; i < bp.size(); i++)\n        if(checkin(wp[i], bp) == 1 || checkin(wp[i], bp) == 2) f1 = 1;\n    for(int i = 0; i < wp.size(); i++)\n        if(checkin(bp[i], wp) == 1 || checkin(bp[i], wp) == 2) f2 = 1;\n    flag = f1 | f2;\n    if(flag == 0) return true;\n    else return false;\n}\n\nint main()\n{\n    while(~scanf(\"%d%d\", &n, &m), n + m)\n    {\n        for(int i = 0; i < n; i++)\n        {\n            double tx, ty;\n            scanf(\"%lf %lf\", &tx, &ty);\n            black[i] = Point(tx, ty);\n        }\n        for(int i = 0; i < m; i++)\n        {\n            double tx, ty;\n            scanf(\"%lf %lf\", &tx, &ty);\n            white[i] = Point(tx, ty);\n        }\n        if(n >= 3 && m >= 3)\n        {\n            convex_hull();\n            if(check()) printf(\"YES\\n\");\n            else printf(\"NO\\n\");\n        }\n        else if(n == 1 && m == 1)\n            printf(\"NO\\n\");\n        else if(n == 1 && m == 2)\n        {\n            bool flag = is_point_intersaction(white[0], make_pair(black[0], black[1]));\n            if(flag) printf(\"NO\\n\");\n            else printf(\"YES\\n\");\n        }\n        else if(n == 2 && m == 1)\n        {\n            bool flag = is_point_intersaction(black[0], make_pair(white[0], white[1]));\n            if(flag) printf(\"NO\\n\");\n            else printf(\"YES\\n\");\n        }\n        else if(n == 2 && m == 2)\n        {\n            bool flag = isintersaction(make_pair(white[0], white[1]), make_pair(black[0], black[1]));\n            if(flag) printf(\"NO\\n\");\n            else printf(\"YES\\n\");\n        }\n    }\n    return 0;\n}\n/*\n\n3 3\n100 700\n200 200\n600 600\n500 100\n500 300\n800 500\n3 3\n100 300\n400 600\n400 100\n600 400\n500 900\n300 300\n3 4\n300 300\n500 300\n400 600\n100 100\n200 900\n500 900\n800 100\n1 2\n300 300\n100 100\n500 500\n1 1\n100 100\n200 100\n2 2\n0 0\n500 700\n1000 1400\n1500 2100\n2 2\n0 0\n1000 1000\n1000 0\n0 1000\n3 3\n0 100\n4999 102\n10000 103\n5001 102\n10000 102\n0 101\n3 3\n100 100\n200 100\n100 200\n0 0\n400 0\n0 400\n3 3\n2813 1640\n2583 2892\n2967 1916\n541 3562\n9298 3686\n7443 7921\n0 0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\n#define FOR(I, A, B) for (int I = int(A); I < int(B); ++I)\n\nconst int N(105);\nconst double EPS(1e-7);\n\nstruct Point {\n    int x, y;\n    Point(int _x = 0, int _y = 0) {\n        x = _x; y = _y;\n    }\n    void get() {\n        scanf(\"%d%d\", &x, &y);\n    }\n};\n\nint t;\nPoint p[N];\nPoint s[2 * N];\n\nvector<Point> ca, cb;\n\nbool cmp(Point p1, Point p2) {\n    return p1.x < p2.x || p1.x == p2.x && p1.y < p2.y;\n}\n\nint cross(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y);\n}\n\nvoid convexHull(int n, vector<Point> &c) {\n    sort(p, p + n, cmp);\n    t = 0;\n    FOR(i, 0, n) {\n        for(; t >= 2 && cross(s[t - 2], s[t - 1], p[i]) <= 0; --t);\n        s[t++] = p[i];\n    }\n    int tt = t - 1;\n    for (int i = n - 2; i != -1; --i) {\n        for (; t - tt >= 2 && cross(s[t - 2], s[t - 1], p[i]) <= 0; --t);\n        s[t++] = p[i];\n    }\n    c.clear();\n    FOR(i, 0, t)\n       c.push_back(s[i]);\n}\n\nint dcmp(int x) {\n    return x == 0 ? 0 : (x > 0 ? 1 : -1);\n}\n\ndouble dis(Point a, Point b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nbool online(Point a, Point b, Point c) {\n    return fabs(dis(a, c) + dis(c, b) - dis(a, b)) < EPS;\n}\n\nbool intersect(Point a, Point b, Point c, Point d) {\n    return dcmp(cross(a, b, c)) * dcmp(cross(a, b, d)) == -1 && dcmp(cross(c, d, a)) * dcmp(cross(c, d, b)) == -1;\n}\n\nbool check() {\n    FOR(i, 0, ca.size()) {\n        bool flag = true;\n        if (cb.size() == 1) {\n            if (dis(ca[i], cb[0]) < EPS) return false;\n            continue;\n        }\n        FOR(j, 1, cb.size()) {\n            if (online(cb[j - 1], cb[j], ca[i])) return false;\n            flag = flag && cross(cb[j - 1], cb[j], ca[i]) > 0;\n        }\n        if (flag) return false;\n    }\n    FOR(i, 0, cb.size()) {\n        bool flag = true;\n        if (ca.size() == 1) {\n            if (dis(cb[i], ca[0]) < EPS) return false;\n            continue;\n        }\n        FOR(j, 1, ca.size()) {\n            if (online(ca[j - 1], ca[j], cb[i])) return false;\n            flag = flag && cross(ca[j - 1], ca[j], cb[i]) > 0;\n        }\n        if (flag) return false;\n    }\n    FOR(i, 1, ca.size())\n        FOR(j, 1, cb.size())\n            if (intersect(ca[i - 1], ca[i], cb[j - 1], cb[j])) return false;\n    return true;\n}\n\nint main() {\n    int n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n + m) {\n\t    FOR(i, 0, n)\n\t        p[i].get();\n\t    convexHull(n, ca);\n\t    FOR(i, 0, m)\n\t        p[i].get();\n\t    convexHull(m, cb);\n\t    if (check()) printf(\"YES\\n\");\n\t    else printf(\"NO\\n\");\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cassert>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-10\n#define F first\n#define S second\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point\n{\n  public:\n  double x,y;\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nbool isIntersect(Segment s1,Segment s2)\n{\nreturn isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool cmp(const vector<Point> &a,const vector<Point> &b)\n{\n  return a.size() < b.size();\n}\n\nPolygon andrewScan(Polygon s)\n{\n  Polygon u,l;\n  if(s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<s.size();i++)\n    {\n      for(int n=u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--)\n\tu.pop_back();\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3; i>=0 ; i--)\n    {\n      for(int n=l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--)\n\tl.pop_back();\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\nbool check(int p1,int p2,vector<Point> &black,vector<Point> &white)\n{\n  int n = black.size();\n  pair<bool,bool> Left,Right;\n  Left  = pair<bool,bool>(false,false); // F->black, S->white\n  Right = pair<bool,bool>(false,false);\n\n  rep(i,n)\n    {\n      if(i == p1 || i == p2)continue;\n      int res = ccw(black[p1],black[p2],black[i]);\n      if(res == CLOCKWISE) Right.F = true;\n      if(res == COUNTER_CLOCKWISE) Left.F = true;\n    }\n  \n  n = white.size();\n  bool Front = false;\n  bool Back = false;\n  int OnSegment = 0;\n  rep(i,n)\n    {\n      int res = ccw(black[p1],black[p2],white[i]);\n      if(res == CLOCKWISE) Right.S = true;\n      if(res == COUNTER_CLOCKWISE) Left.S = true;\n      if(res == ONLINE_FRONT) Front = true;\n      if(res == ONLINE_BACK) Back = true;\n      if(res == ON_SEGMENT) OnSegment++;\n    }\n\n  //cout << black[p1].x << \",\" << black[p1].y << \" | \" << black[p2].x << \",\" << black[p2].y << endl;\n  //cout << \"Front = \" << Front << \" Back = \" << Back << \" OnSegment = \" << OnSegment << endl;\n  if(Front && Back)return false;\n  if(OnSegment && Front)return false;\n  if(OnSegment && Back)return false;\n  if(OnSegment >= 2)return false;\n  if(Left.F && Left.S)return false;\n  if(Right.F && Right.S)return false;\n  if(Left.S && Right.S)return false;\n  //cout << \"OK\" << endl;\n  return true;\n}\n\nvoid printVP(vector<Point> a)\n{\n  cout << \"printVP-------\" << endl;\n  rep(i,a.size())cout << \"(\" << a[i].x << \",\" << a[i].y << \") \";\n  cout << endl;\n}\n\nbool isParallel(Vector a,Vector b)\n{\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2)\n{\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2)\n{\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\n\nint main()\n{\n  int n,m;\n  while(cin >> n >> m,n|m)\n    {\n      assert(n && m);\n      vector<Point> A(n),B(m);\n      rep(_,n)cin >> A[_].x >> A[_].y;\n      rep(_,m)cin >> B[_].x >> B[_].y;\n\n      vector<Point> black,white;\n      if(A.size() > B.size())\n\tblack = A,white = B;\n      else\n\tblack = B,white = A;\n\n      \n      if(n == 1 && m == 1)\n\t{\n\t  cout << \"YES\" << endl;\n\t  continue;\n\t}\n\n      \n      if(black.size() >= 3 && white.size() == 1)\n\t{\t  \t \n\t  bool aaa = false;\n\t  rep(i,black.size()-2)\n\t    {\n\t      if(!isParallel(Segment(black[i],black[i+1]),Segment(black[i+1],black[i+2])))\n\t\t{\n\t\t  aaa = true;\n\t\t  break;\n\t\t}\n\t    }\n\n\t  if(aaa)\n\t    {\n\t      bool fin = false;\n\t      rep(i,black.size())\n\t\t{\n\t\t  REP(j,i+1,black.size())\n\t\t    {\n\t\t      if(!check(i,j,black,white))\n\t\t\t{\n\t\t\t  cout << \"NO\" << endl;\n\t\t\t  fin = true;\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  if(fin)break;\n\t\t}\n\t      if(!fin)cout << \"YES\" << endl;\n\t      continue;\n\t    }\n\t}\n      \n      /*\n      if(white.size() == 1)\n\t{\n\n\t  sort(black.begin(),black.end());\n\t  if(ccw(black[0],black[black.size()-1],white[0]) == ON_SEGMENT)\n\t    {\n\t      cout << \"NO\" << endl;\n\t      continue;\n\t    }\n\t  rep(i,black.size())\n\t    if(ccw(black[i],black[(i+1)%black.size()],white[0]) == ON_SEGMENT)\n\t      {\n\t\tcout << \"NO\" << endl;\n\t\tgoto FX;\n\t      }\n\t  cout << \"YES\" << endl;\n\tFX:;\n\t  continue;\n\t}\n      */\n  \n\n      \n\tbool allPL = true;\n\t//vector<Point> gray = black;\n\t//rep(i,white.size())gray.push_back(white[i]);\n\trep(i,black.size())\n\t  {\n\t    REP(j,i+1,black.size())\n\t      {\n\t\trep(k,white.size())\n\t\t  {\n\t\t    REP(l,k+1,white.size())\n\t\t      {\n\t\t\tif(!isParallel(Segment(black[i],black[j]),Segment(white[k],white[l])))\n\t\t\t  {\n\t\t\t    allPL = false;\n\t\t\t    goto Next;\n\t\t\t  }\n\t\t      }\n\t\t  }\n\t      }\n\t  }\n      Next:;\n\tif(allPL)\n\t  {\n\t    int Front = 0;\n\t    int Back = 0;\n\t    int OnSegment = 0;\n\t    rep(i,black.size())\n\t      {\n\t\tREP(j,i+1,black.size())\n\t\t  {\n\t\t    rep(k,white.size())\n\t\t      {\n\t\t\tint res = ccw(black[i],black[j],white[k]);\n\t\t\tif(res == ONLINE_FRONT)Front++;\n\t\t\tif(res == ONLINE_BACK) Back++;\n\t\t\tif(res == ON_SEGMENT)  OnSegment++;\n\t\t      }\t\t\n\t\t  }\n\t      }\n\n\t    if(OnSegment)cout << \"NO\" << endl;\n\t    else if(Front && Back)cout << \"NO\" << endl;\t \n\t    else cout << \"YES\" << endl;\n\t \n\t    continue;\n\t  }\t\n\n      \n    \n      int N = black.size();\n      rep(i,N)\n\t{\n\t  REP(j,i+1,N)\n\t    {\n\t      if(check(i,j,black,white))\n\t\t{\n\t\t  //cout << black[i].x << \",\" << black[i].y << \" \" << black[j].x << \",\" << black[j].y << endl;\n\t\t  cout << \"YES\" << endl;\n\t\t  goto F;\n\t\t}\n\t    }\n\t}\n      cout << \"NO\" << endl;\n    F:;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//15\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<complex>\n#include<cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nint crs(P a,P b){\n  double cr=a.real()*b.imag()-a.imag()*b.real();\n  return (fabs(cr)<1e-9)?1:\n    (cr<0)?0:2;\n}\n\nint main(){\n  for(int n[2];cin>>n[0]>>n[1],n[0]|n[1];){\n    vector<P> v[2];\n    int mx[2][2]={},mn[2][2];\n    fill(mn[0],mn[2],10000);\n    for(int i=0;i<2;i++){\n      for(int j=0;j<n[i];j++){\n\tint x,y;\n\tcin>>x>>y;\n\tmx[i][0]=max(mx[i][0],x);\n\tmx[i][1]=max(mx[i][1],y);\n\tmn[i][0]=min(mn[i][0],x);\n\tmn[i][1]=min(mn[i][1],y);\n\tv[i].push_back(P(x,y));\n      }\n    }\n    for(int i=0;i<2;i++){\n      for(int j=0;j<2;j++){\n\tif(mx[i][j]<mn[!i][j]){\n\t  cout<<\"YES\"<<endl;\n\t  goto next;\n\t}\n      }\n    }\n    if(max(v[0].size(),v[1].size())==1){\n      cout<<\"YES\"<<endl;\n    }else{\n      for(int o=0;o<2;o++){\n\tswap(v[0],v[1]);\n\tfor(int i=0;i<v[0].size();i++){\n\t  for(int j=0;j<i;j++){\n\t    bool f[2][3]={{}};\n\t    for(int k=0;k<2;k++){\n\t      for(int l=0;l<v[k].size();l++){\n\t\tf[k][crs(v[0][i]-v[0][j],v[k][l]-v[0][j])]=true;\n\t      }\n\t    }\n\t    if((!f[0][0]||!f[0][2])&&(!f[1][0]||!f[1][2])&&!f[1][1]&&!(f[0][2]&&f[1][2])&&!(f[0][0]&&f[1][0])){\n\t      cout<<\"YES\"<<endl;\n\t      goto next;\n\t    }\n\t  }\n\t}\n      }\n      cout<<\"NO\"<<endl;\n    }\n  next:\n    ;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\n#include <complex>\ntypedef complex<double> P;\n#define EQ(x, y) (abs((x)-(y)) < EPS)\ndouble dot(P a, P b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\ndouble cross(P a, P b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\nint is_point_on_line(P a, P b, P c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nint is_intersected_l_ls(P a1, P a2, P b1, P b2) {\n    if ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < -EPS )\n        return true;\n    return is_point_on_line(a1, a2, b1) || is_point_on_line(a1, a2, b2);\n}\nint is_point_on_ls(P a, P b, P c) {\n    // |a-c| + |c-b| <= |a-b| then true\n    return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n\n\ntypedef vector<P> vp;\n\nbool can_separate(int edge1,int edge2,int parent_o,int parent_t,vp &ours,vp &theirs){\n\tif(parent_o!=-1){\n\t\tif(!is_intersected_l_ls(ours[edge1],ours[edge2],ours[parent_o],theirs[parent_t])){\n\t\t\treturn false;\n\t\t}\n\t}\n\tif(parent_o!=-1){\n\t\tREP(i,ours.size()){\n\t\t\tif(i!=parent_o&&i!=edge1&&i!=edge2){\n\t\t\t\tif(is_intersected_l_ls(ours[edge1],ours[edge2],ours[i],ours[parent_o])){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,theirs.size()){\n\t\tif(i!=parent_t){\n\t\t\tif(is_intersected_l_ls(ours[edge1],ours[edge2],theirs[i],theirs[parent_t])){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nnamespace std{\n\tbool operator<(const P &l, const P &r){\n\t\tif(l.real()==r.real()){\n\t\t\treturn l.real()<r.real();\n\t\t}else{\n\t\t\treturn l.imag()<r.imag();\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n\t\tvp black,white;\n\t\tREP(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tblack.push_back(P(x,y));\n\t\t}\n\t\tREP(i,m){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\twhite.push_back(P(x,y));\n\t\t}\n\n\t\tbool ok=false;\n\t\tbool all_on_line=true;\n\t\tbool scrumbled=false;\n\t\tif(n==1&&m==1){\n\t\t\tok=true;\n\t\t\tgoto show;\n\t\t}else if(n==2&&m==1){\n\t\t\tok=!is_point_on_ls(black[0],black[1],white[0]);\n\t\t\tgoto show;\n\t\t}else if(n==1&&m==2){\n\t\t\tok=!is_point_on_ls(white[0],white[1],black[0]);\n\t\t\tgoto show;\n\t\t}\n\n\t\tsort(ALL(black));\n\t\tsort(ALL(white));\n\t\tREP(i,n+m){\n\t\t\tP ip=(i<n?black[i]:white[i-n]);\n\t\t\tif(!is_point_on_line(black[0],white[0],ip)){\n\t\t\t\tall_on_line=false;\n\t\t\t}\n\t\t}\n\t\tREP(i,n){\n\t\t\tif(black.size()>=2&&is_point_on_ls(black[0],black[black.size()-1],white[i])){\n\t\t\t\tscrumbled=true;\n\t\t\t}\n\t\t}\n\t\tREP(i,n){\n\t\t\tif(white.size()>=2&&is_point_on_ls(white[0],white[white.size()-1],black[i])){\n\t\t\t\tscrumbled=true;\n\t\t\t}\n\t\t}\n\t\tif(all_on_line){\n\t\t\tok=!scrumbled;\n\t\t\tgoto show;\n\t\t}\n\n\t\tREP(i1,n){\n\t\t\tFOR(i2,i1+1,n){\n\t\t\t\tint parent_o=-1;\n\t\t\t\tREP(j,n){\n\t\t\t\t\tif(j!=i1&&j!=i2){\n\t\t\t\t\t\tparent_o=j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(can_separate(i1,i2,parent_o,0,black,white)){\n\t\t\t\t\tok=true;\n\t\t\t\t\tgoto show;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i1,m){\n\t\t\tFOR(i2,i1+1,m){\n\t\t\t\tint parent_o=-1;\n\t\t\t\tREP(j,m){\n\t\t\t\t\tif(j!=i1&&j!=i2){\n\t\t\t\t\t\tparent_o=j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(can_separate(i1,i2,parent_o,0,white,black)){\n\t\t\t\t\tok=true;\n\t\t\t\t\tgoto show;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nshow:\n\t\tcout<<(ok?\"YES\":\"NO\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-6;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nclass Point{\npublic:\n  double x, y;\n\n  Point(double x = 0.0, double y = 0.0) : x(x), y(y){}\n\n  Point& operator += (const Point& p){ x += p.x; y += p.y; return *this;}\n  Point operator + (const Point& p) const{ Point q = *this;return q += p;}\n  Point& operator -= (const Point& p){ x -= p.x; y -= p.y; return *this;}\n  Point operator - (const Point& p) const{ Point q = *this; return q -= p;}\n  Point& operator *= (double a){ x *= a; y *= a; return *this;}\n  Point operator * (double a) const{ Point q = *this; return q *= a;}\n  Point& operator /= (double a){ x /= a; y /= a; return *this;}\n  Point operator / (double a) const{ Point q = *this; return q /= a;}\n\n  double abs() const { return sqrt(norm()); }\n  double norm() const { return x*x + y*y; }\n  Point& normalize(){ return *this /= abs(); }\n  \n  bool operator < (const Point &p) const{\n\treturn x != p.x ? x < p.x : y < p.y;\n  }\n  \n  //EPS??????????°??????????\n  bool operator == (const Point &p) const {\n\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n  friend ostream& operator <<(ostream& os, const Point& p);\n};\nostream& operator <<(ostream& os, const Point& p){\n  return os << \"(\" << p.x << \",\"<<p.y << \")\";\n}\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment(){}\n  Segment(const Point& p1_, const Point& p2_)\n\t: p1(p1_), p2(p2_)\n  {}\n};\ntypedef Point Vector;\ntypedef Segment Line;\n\ndouble cross(Vector a, Vector b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\nint sgn(double x){\n  if(x > 0) return 1;\n  else if(x < 0) return -1;\n  return 0;\n}\n\nVector dv[4] = {Point(EPS,0), Point(-EPS,0), Point(0,EPS), Point(0,-EPS)};\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M;\n  while(cin>>N>>M,N){\n\tvector<Point> a(N), b(M), al(N+M);\n\tREP(i,N){\n\t  cin >> a[i].x >> a[i].y;\n\t  al[i] = a[i];\n\t}\n\tREP(i,M){\n\t  cin >> b[i].x >> b[i].y;\n\t  al[N+i] = b[i];\n\t}\n\n\tbool ok = false;\n\tREP(i1,N+M) REP(i2,i1){\n\t  REP(d1,4) REP(d2,4){\n\t\tPoint orig = al[i1] + dv[d1];\n\t\tVector dl = (al[i2] + dv[d2]) - orig;\n\t\tint sg1 = sgn(cross(dl, a[0] - orig));\n\t\tif(sg1 == 0) continue;\n\t\tbool ng = false;\n\t\tREP(j,N){\n\t\t  if(sgn(cross(dl, a[j] - orig)) != sg1){\n\t\t\tng = true;\n\t\t\tbreak;\n\t\t  }\n\t\t}\n\t\tif(ng) continue;\n\t\tint sg2 = -sg1;\n\t\tREP(j,M){\n\t\t  if(sgn(cross(dl, b[j] - orig)) != sg2){\n\t\t\tng = true;\n\t\t\tbreak;\n\t\t  }\n\t\t}\n\t\tif(ng) continue;\n\n\t\tok = true;\n\t\ti1 = i2 = d1 = d2 = 1e9;\n\t  }\n\t}\n\tcout << (ok? \"YES\": \"NO\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\n\nconst double EPS = 1e-9;\nconst double PI = 6.0 * asin(0.5);\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersect(L s1, L s2){\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\nvector<P> convex_hull(vector<P> v){\n  vector<P> c; //convex\n  sort(v.begin(),v.end());\n  c.assign(v.begin(),v.begin()+2);\n    \n  for(int i=2;i<v.size();i++){\n    P a = c[c.size()-1] - c[c.size()-2];\n    P b = v[i] - c[c.size()-2];\n        \n    while(cross(a,b) > EPS){\n      c.pop_back();\n      if(c.size() < 2) break;\n      a = c[c.size()-1] - c[c.size()-2];\n      b = v[i] - c[c.size()-2];\n    }\n    c.push_back(v[i]);\n  }\n\t\n  int n = c.size();\n  c.push_back(v[v.size()-2]);\n\t\n  for(int i=v.size()-3;i>=0;i--){\n    P a = c[c.size()-1] - c[c.size()-2];\n    P b = v[i] - c[c.size()-2];\n        \n    while(cross(a,b) > EPS){\n      c.pop_back();\n      if(c.size() < n + 1) break;\n      a = c[c.size()-1] - c[c.size()-2];\n      b = v[i] - c[c.size()-2];\n    }\n    c.push_back(v[i]);\n  }\n  c.pop_back();\n  return c;\n}\n\n\nvector<P> p1,p2;\nint n,m;\nint solve(){\n  if(n+m<3) return 1;\n  if(m==1&&n==2) return ccw(p1[0],p1[1],p2[0])!=0;\n  if(n==2&&m==2) return !isIntersect(L(p1[0],p1[2]),L(p2[0],p2[1]));\n\n  vector<P> t=convex_hull(p1);\n  for(int i=0;i<=(int)t.size();i++){\n    int flg=1;\n    for(int j=0;j<m&&flg;j++)\n      if(ccw(t[i],t[(i+1)%t.size()],p2[j])!=1)flg=0;\n    if(flg) return 1;\n    \n  }\n  return 0;  \n}\n\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)return 0;\n    p1.resize(n),p2.resize(m);\n    for(int i=0,a,b;i<n;i++)cin>>a>>b,p1[i]=P(a,b);\n    for(int i=0,a,b;i<m;i++)cin>>a>>b,p2[i]=P(a,b);\n    int ans=solve();\n    swap(p1,p2);\n    swap(n,m);\n    ans|=solve();\n    cout<<(ans?\"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\ntypedef pair<double, double> P;\nint f(double w[], P p){\n  double v = w[0] + w[1] * p.first + w[2] * p.second;\n  if(v >= 0) return 1;\n  else return 0;\n}\n\nint main(){\n  int b, w;\n  while(cin>>b>>w && (b != 0 || w != 0)){\n    vector<P> points_b, points_w;\n    REP(i, b){\n      double x, y; cin>>x>>y;\n      points_b.push_back(P(x, y));\n    }\n    REP(i, w){\n      double x, y; cin>>x>>y;\n      points_w.push_back(P(x, y));\n    }\n    double we[3] = {};\n    double rate = 1;\n    bool ans = false;\n    REP(iter, 50000000/(w + b)){\n      bool update = false;\n      REP(i, b){\n        int v = f(we, points_b[i]);\n        if(v == 1){\n          we[0] = we[0] + rate * -1;\n          we[1] = we[1] + rate * -1 * points_b[i].first;\n          we[2] = we[2] + rate * -1 * points_b[i].second;\n          update = true;\n        }\n      }\n      REP(i, w){\n        int v = f(we, points_w[i]);\n        if(v == 0){\n          we[0] = we[0] + rate * 1;\n          we[1] = we[1] + rate * 1 * points_w[i].first;\n          we[2] = we[2] + rate * 1 * points_w[i].second;\n          update = true;\n        }\n      }\n      if(!update){\n        ans = true;\n        break;\n      }\n    }\n    if(ans) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = 1e9;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> P;\n\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n\n/** 幾何ライブラリ **/\n#include <complex>\n\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-11;\n\ntypedef double D;\ntypedef complex<D> P; // Point\n\nstruct L { // Line\n\tP a, b;\n\tL(){}\n\tL(P aa, P bb) : a(aa), b(bb){}\n};\n\n// 共役複素数 conj(a);\n\n// 符号\nint sig(D a, D b=0) { return a < b - EPS ? -1 : (a > b + EPS ? 1 : 0); }\n\n// 内積\nD dot(P a, P b) { return (conj(a)*b).real(); }\n\n// 外積\nD cross(P a, P b) { return (conj(a)*b).imag(); }\n\n// 線分abに対する点cの位置\nenum STATE{LEFT=1, RIGHT=-1, BACK=2, FRONT=-2, ON=0, IN=3, OUT=-3};\nint ccw(P a, P b, P c)\n{\n\tb -= a, c -= a;\n\tD s = sig(cross(b, c));\n\tif (s) return s>0 ? LEFT : RIGHT;\n\tif (sig(dot(b, c))<0) return BACK;\n\tif (sig(abs(c), abs(b))>0) return FRONT;\n\treturn ON;\n}\n\n// 直線lに対する点pの写像\nP projection(L l, P p)\n{\n\treturn l.a + (l.b-l.a)/abs(l.b-l.a) * dot(l.b-l.a, p-l.a)/abs(l.b-l.a);\n}\n\n// 直線lに対する点pの反射\nP reflection(L l, P p)\n{\n\treturn p + (projection(l, p)-p)*P(2, 0);\n}\n\n// 直線abと点cの距離\nD dLP(L l, P c)\n{\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分abと点cの距離\nD dSP(L l, P c)\n{\n\tif (sig(dot(l.b-l.a, c-l.a))<0) return abs(c-l.a);\n\tif (sig(dot(l.a-l.b, c-l.b))<0) return abs(c-l.b);\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分と線分の交差判定\nbool iSS(L s, L t)\n{\n\treturn (ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0)\n\t\t\t&& (ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0);\n}\n\n// 線分と線分の距離\nD dSS(L s, L t)\n{\n\tif (iSS(s, t)) return 0;\n\treturn min(min(dSP(t, s.a), dSP(t, s.b)), min(dSP(s, t.a), dSP(s, t.b)));\n}\n\n// 線分と線分の交点 (公差していることが前提)\nP cSS(L s, L t)\n{\n\tD d1 = dLP(t, s.a);\n\tD d2 = dLP(t, s.b);\n\tD tmp = d1 / (d1 + d2);\n\treturn s.a + (s.b-s.a)*tmp;\n}\n\n// 直線と直線の交差判定\nbool iLL(L s, L t)\n{\n\treturn sig(cross(s.b-s.a, t.b-t.a))!=0;\n}\n\n// 直線と直線の交点 iLLを確認してから使用\nP cLL(L s, L t)\n{\n\tP ss = s.b - s.a, tt = t.b - t.a;\n\treturn s.a + ss*cross(tt, t.a-s.a)/cross(tt, ss);\n}\n\n// 多角形\ntypedef vector<P> G;\n\n// 面積を求める (時計回りだと負になる)\nD area(G g)\n{\n\tD res = 0.0;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tres += cross(g[i], g[(i+1)%g.size()]);\n\t}\n\treturn res/2;\n}\n\n// 多角形gと点pの包含関係を求める\nint containsGP(G g, P p)\n{\n\tbool in=false;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tP a = g[i], b = g[(i+1)%g.size()];\n\t\tif (ccw(a, b, p) == ON) return ON;\n\t\t\n\t\ta -= p, b -= p;\n\t\tif (a.Y > b.Y) swap(a, b);\n\t\tif (a.Y<0 && b.Y>=0 && sig(cross(a, b))>0) in = !in;\n\t}\n\treturn in?IN:OUT;\n}\n\nbool cmp_convex_full(const P &a, const P &b)\n{\n\tif (sig(a.X, b.X) != 0) return a.X < b.X;\n\treturn a.Y < b.Y;\n}\n\n// 凸包を得る\n// 辺上を含めない場合は <= 0 にする\nG convex_hull(vector<P> ps)\n{\n\tif (ps.size()==1) return ps;\n\t\n\tint N = (int)ps.size(), k=0;\n\tsort(ps.begin(), ps.end(), cmp_convex_full);\n\tG res(2*N);\n\t\n\tfor (int i=0; i<N; i++) {\n\t\twhile (k>=2 && ccw(res[k-2], res[k-1], ps[i]) == RIGHT) k--;\n\t\tres[k++] = ps[i];\n\t}\n\t\n\tint t = k+1;\n\tfor (int i=N-2; i>=0; i--) {\n\t\twhile (k>=t && ccw(res[k-2], res[k-1], ps[i]) == RIGHT) k--;\n\t\tres[k++] = ps[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// 凸多角形を直線で切断し、左側を残す\nG convex_cut(G g, L l)\n{\n\tG res;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tP a = g[i], b = g[(i+1)%g.size()];\n\t\tif (ccw(l.a, l.b, a) != RIGHT) res.push_back(a);\n\t\tif (ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0) res.push_back(cLL(L(a, b), l));\n\t}\n\treturn res;\n}\n\n\n/** Problem1298 : Separate Points **/\nint main()\n{\n\tint N, M;\n\twhile (cin>>N>>M, N||M) {\n\t\tvector<P> bp(N), wp(M);\n\t\trep(i, N) cin>>bp[i].X>>bp[i].Y;\n\t\trep(i, M) cin>>wp[i].X>>wp[i].Y;\n\t\t\n\t\tG bc = convex_hull(bp);\n\t\tG wc = convex_hull(wp);\n\n\t\tbool ok = true;\n\n\t\tif (bc.size()==2 && wc.size()==2) {\n\t\t\tif (iSS(L(bc[0], bc[1]), L(wc[0], wc[1]))) ok=false;\n\t\t} if (bc.size()==1 && wc.size()==2) {\n\t\t\tif (ccw(wc[0], wc[1], bc[0]) == ON) ok=false;\n\t\t} else if (wc.size()==1 && bc.size()==2) {\n\t\t\tif (ccw(bc[0], bc[1], wc[0]) == ON) ok=false;\n\t\t} else {\n\t\t\tif (bc.size()>2) {\n\t\t\t\tfor (int i=0; i<wc.size(); i++) {\n\t\t\t\t\tif (containsGP(bc, wc[i]) == IN) ok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (wc.size()>2) {\n\t\t\t\tfor (int i=0; i<bc.size(); i++) {\n\t\t\t\t\tif (containsGP(wc, bc[i]) == IN) ok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (ok?\"YES\":\"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntypedef long double LL;\n\nusing namespace std;\n\n#define rep(i,n) for(auto i=0*(n);i<(n);++i)\ntypedef complex<LL> P;\ntypedef vector<P> Poly;\n\nLL dot(P a,P b){return real(conj(a)*b);}\nLL cross(P a,P b){return imag(conj(a)*b);}\nnamespace std{\n    bool operator<(const P &l,const P &r){\n        return l.real()==r.real()?l.imag()<r.imag():l.real()<r.real();\n    }\n};\nconst LL EPS=0;\nint cww(P a,P b,P c){\n    b-=a;\n    c-=a;\n    if(cross(b,c)>EPS)return 1;\n    if(cross(b,c)<-EPS)return -1;\n    if(dot(b,c)<0)return 2;\n    if(norm(b)<norm(c))return -2;\n    return 0;\n\n}\n\nPoly convex_hull(Poly p){\n    int n=p.size();\n    if(n==1)return p;\n    Poly res(2*n);\n    int k=0,t;\n    sort(p.begin(),p.end());\n    for(int i=0;i<n;i++){\n        while(k>1&&cww(res[k-2],res[k-1],p[i])!=1)k--;\n        res[k++]=p[i];\n    }\n    t=k;\n    for(int i=n-2;i>=0;i--){\n        while(k>t&&cww(res[k-2],res[k-1],p[i])!=1)k--;\n        res[k++]=p[i];\n    }\n    res.resize(k-1);\n    return res;\n}\nbool isis_ss(P sa,P sb,P ta, P tb){\n    return cww(sa,sb,ta)*cww(sa,sb,tb)<=0&&\n        cww(ta,tb,sa)*cww(ta,tb,sb)<=0;\n}\nbool intersected_Poly(Poly p,Poly q){\n    int n=p.size();\n    int m=q.size();\n    if(m>=3)\n    for(int i=0;i<n;i++){\n        bool f=true;\n        for(int j=0;j<m;j++){\n            if(cww(q[j],q[(j+1)%m],p[i])==-1)f=false;\n        }\n        if(f)return true;\n    }\n    if(n>=3)\n    for(int i=0;i<m;i++){\n        bool f=true;\n        for(int j=0;j<n;j++){\n            if(cww(p[j],p[(j+1)%n],q[i])==-1)f=false;\n        }\n        if(f)return true;\n    }\n    // cout<<n<<m<<endl;\n    if(n==1&&m==1){\n        return false;\n    }\n    else if(n==1){\n        for(int i=0;i<m;i++){\n            // cout<<cww(q[i],q[(i+1)%m],p[0])<<endl;\n            if(cww(q[i],q[(i+1)%m],p[0])==0)return true;\n        }\n    }\n    else if(m==1){\n        for(int i=0;i<n;i++){\n            if(cww(p[i],p[(i+1)%n],q[0])==0)return true;\n        }\n    }\n    else \n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(isis_ss(p[i],p[(i+1)%n],q[j],q[(j+1)%m]))return true;\n        }\n    }\n    return false;\n\n}\n#define PRO \"YES\"\n#define SHUMI \"NO\"\nint main(){\n    for(int n,m;cin>>n>>m,n+m;){\n        vector<P> b(n),w(m);\n        for(int i=0;i<n;i++){\n            LL x,y;cin>>x>>y;\n            b[i]=P(x,y);\n        }\n        for(int i=0;i<m;i++){\n             LL x,y;cin>>x>>y;\n            w[i]=P(x,y);\n        }\n        b=convex_hull(b);\n        w=convex_hull(w);\n        \n        if(intersected_Poly(b,w))cout<<SHUMI<<endl;\n        else cout<<PRO<<endl;\n        \n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return P(imag(a),-real(a));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n  return\n    min4(spdist(a,b.F),spdist(a,b.S),\n         spdist(b,a.F),spdist(b,a.S));\n}\n\n\nP inn[100],inm[100];\nint n,m;\n\nbool ok(line a){\n  //cout << a << endl;\n  rep(i,n){\n    line se(inn[i],inm[0]);\n    if(!onl(se,crspt(se,a))) return false;\n  }\n  rep(i,m){\n    line se(inn[0],inm[i]);\n    if(!onl(se,crspt(se,a))) return false;\n  }\n  return true;\n}\n\nvoid solve(){\n  rep(i,n) cin >> inn[i].real() >> inn[i].imag();\n  rep(i,m) cin >> inm[i].real() >> inm[i].imag();\n\n  rep(i,n)rep(j,m){\n    line a(inn[i],inm[j]);\n    P b=ortho(a);\n    b=b/abs(b)*0.2;\n    a.F+=b;a.S-=b;\n    if(ok(a)){\n      cout << \"YES\" << endl;\n      return;\n    }\n    a.F-=b;a.S+=b;\n    a.F-=b;a.S+=b;\n    if(ok(a)){\n      cout << \"YES\" << endl;\n      return;\n    }\n  }\n  cout << \"NO\" << endl;\n}\n\nint main(){\n  while(cin >> n >> m && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(P a,P b) {\n  return imag(conj(a)*b);\n}\n\ndouble dot(P a,P b) {\n  return real(conj(a)*b);\n}\n\nint ccw(P a,P b,P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(P a1,P a2,P b1,P b2){\n\treturn\n\t\tccw(a1,a2,b1)*ccw(a1,a2,b2) <= 0 &&\n\t\tccw(b1,b2,a1)*ccw(b1,b2,a2) <= 0;\n}\n\nbool intersectSP(P a1,P a2,P p) {\n\treturn abs(a1-p)+abs(a2-p)-abs(a1-a2) < EPS; // triangle inequality\n}\n\nvector<P> convex_hull(vector<P> ps) {\n\tif(ps.size() == 1) return ps;\n\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nint convex_contains(vector<P> ps,P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n/3] + ps[2*n/3]) / 3.0;\n  int a = 0, b = n;\n  while (a+1 < b) {\n    int c = (a + b) / 2;\n    if (cross(ps[a]-g, ps[c]-g) > 0) {\n      if (cross(ps[a]-g, p-g) > 0 && cross(ps[c]-g, p-g) < 0)\n\t\t\t\tb = c;\n      else\n\t\t\t\ta = c;\n    } else {\n      if (cross(ps[a]-g, p-g) < 0 && cross(ps[c]-g, p-g) > 0)\n\t\t\t\ta = c;\n      else\n\t\t\t\tb = c;\n    }\n  }\n  b %= n;\n  if (cross(ps[a] - p, ps[b] - p) < 0) return 0;\n  if (cross(ps[a] - p, ps[b] - p) > 0) return 2;\n  return 1;\n}\n\nint main(void){\n\tint n,m;\n\n\twhile(cin>>n>>m,n||m){\n\t\tvector<P> a(n);\n\t\tfor(int i=0;i<n;i++) cin>>a[i].real()>>a[i].imag();\n\t\tvector<P> b(m);\n\t\tfor(int i=0;i<m;i++) cin>>b[i].real()>>b[i].imag();\n\n\t\ta = convex_hull(a);\n\t\tb = convex_hull(b);\n\n\t\tbool flg = true;\n\n\t\tif(a.size() == 2 && b.size() == 2){\n\t\t\tflg = !intersectSS(a[0],a[1],b[0],b[1]);\n\t\t}\n\t\telse if(a.size() == 1 && b.size() == 2){\n\t\t\tflg = !intersectSP(b[0],b[1],a[0]);\n\t\t}\n\t\telse if(a.size() == 2 && b.size() == 1){\n\t\t\tflg = !intersectSP(a[0],a[1],b[0]);\n\t\t}\n\n\t\tif(b.size() >= 3){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(convex_contains(b,a[i])){\n\t\t\t\t\tflg = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(a.size() >= 3){\n\t\t\tfor(int i=0;flg && i<m;i++){\n\t\t\t\tif(convex_contains(a,b[i])){\n\t\t\t\t\tflg = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout<<(flg?\"YES\":\"NO\")<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define isYES(x) printf(\"%s\\n\",(x) ? \"YES\" : \"NO\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define isYes(x) printf(\"%s\\n\",(x) ? \"Yes\" : \"No\")\n#define isIn(x,y,h,w) (x >= 0 && x < h && y >= 0 && y < w)\n\n#define int long long\n//using ll = long long;\nusing P = pair<int,int>;\n\nostream &operator<<(ostream &os,const P &p){ return os << \"(\" << p.first << \",\" << p.second << \")\"; }\n\ntemplate<class T> T &chmin(T &a,const T &b){ return a = min(a,b); }\ntemplate<class T> T &chmax(T &a,const T &b){ return a = max(a,b); }\n \nconst int INF=1e+18;\nconst double EPS=1e-9;\nconst int MOD=1000000007;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nusing Float = double;\nusing Point = complex<Float>;\nstruct Line{\n\tPoint a,b;\n\tLine(Point a,Point b) : a(a),b(b){}\n};\nstruct Segment : Line{ Segment(Point a,Point b) : Line(a,b){} };\nstruct Circle{ Point p; Float r; };\n\nistream &operator>>(istream &is,Point &p){\n\tFloat a,b;\n\tis >> a >> b;\n\tp = Point(a,b);\n\treturn is;\n}\ninline bool eq(Float a,Float b) { return abs(a - b) < EPS; }\ninline Float dot(const Point &a,const Point &b){ return real(conj(a) * b); }\ninline Float cross(const Point &a,const Point &b){ return imag(conj(a) * b); }\n\nnamespace std{\n\tbool operator<(const Point &a,const Point &b){\n\t\treturn eq(real(a),real(b)) ? imag(a) < imag(b) : real(a) < real(b);\n\t}\n}\n\ninline bool intersect(const Line &s,const Point &p){\n\treturn abs(cross(s.a - p,s.b - p)) < EPS;\n}\n\nint ccw(const Point &a,Point b,Point c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > EPS) return +1; //ccw\n\tif(cross(b,c) < -EPS) return -1; //cw\n\tif(dot(b,c) < 0) return -2; //c-a-b\n\tif(norm(b) < norm(c)) return +2; //a-b-c\n\treturn 0; //a-c-b\n}\n\nint n,m;\n\nvoid solve(){\n\tPoint ps[210];\n\tfor(int i = 0;i < n + m;i++) cin >> ps[i];\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tint b = 0,w = 0;\n\t\t\tPoint bma(-INF,-INF),bmi(INF,INF),wma = bma,wmi = bmi;\n\t\t\tbool isOK = true;\n\t\t\tfor(int k = 0;k < n + m;k++){\n\t\t\t\tint c = ccw(ps[i],ps[n + j],ps[k]);\n\t\t\t\tif(abs(c) == 1){\n\t\t\t\t\tif(k < n){\n\t\t\t\t\t\tif(!b) b = c;\n\t\t\t\t\t\telse if(b != c) isOK = false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(!w) w = c;\n\t\t\t\t\t\telse if(w != c) isOK = false;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(k < n) chmax(bma,ps[k]),chmin(bmi,ps[k]);\n\t\t\t\t\telse chmax(wma,ps[k]),chmin(wmi,ps[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!(bma < wmi || wma < bmi) || (b && b == w)) isOK = false; \n\t\t\tif(isOK){\n\t\t\t\tYES();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tNO();\n\treturn;\n}\n\nsigned main(){\n\twhile(cin >> n >> m,n) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\n\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\n\t\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\nint n,m;\nP bp[1000];\nP wp[1000];\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// E¤Ìvfª éFÅ é©Ç¤©`FbN\nbool checkRIghtincludeLine(P a,P b,bool isW){\n    if(isW){\n        for(int i = 0; i < m; i++){\n            if(EQ(a.real(),b.real())){\n                if(wp[i].real()<a.real()&&!EQ(wp[i].real(),a.real()))\n                    return false;\n            }\n            else{\n                // y=d*x+e\n                double d=(a.imag()-b.imag())/(a.real()-b.real());\n                double e=b.imag()-b.real()*d;\n                if(!(d*wp[i].real()+e>wp[i].imag()||EQ(d*wp[i].real()+e,wp[i].imag())))\n                    return false;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            if(EQ(a.real(),b.real())){\n                if(!(bp[i].real()<a.real()&&!EQ(bp[i].real(),a.real())))\n                    return false;\n            }\n            else{\n                // y=d*x+e\n                double d=(a.imag()-b.imag())/(a.real()-b.real());\n                double e=b.imag()-b.real()*d;\n                if((d*bp[i].real()+e>bp[i].imag()||EQ(d*bp[i].real()+e,bp[i].imag())))\n                    return false;\n            }\n        }\n        return true;\n    }\n    else{\n        for(int i = 0; i < n; i++){\n            if(EQ(a.real(),b.real())){\n                if((bp[i].real()<a.real()&&!EQ(bp[i].real(),a.real())))\n                    return false;\n            }\n            else{\n                // y=d*x+e\n                double d=(a.imag()-b.imag())/(a.real()-b.real());\n                double e=b.imag()-b.real()*d;\n                if(!(d*bp[i].real()+e>bp[i].imag()||EQ(d*bp[i].real()+e,bp[i].imag())))\n                    return false;\n            }\n        }\n        for(int i = 0; i < m; i++){\n            if(EQ(a.real(),b.real())){\n                if(!(wp[i].real()<a.real()&&!EQ(wp[i].real(),a.real())))\n                    return false;\n            }\n            else{\n                // y=d*x+e\n                double d=(a.imag()-b.imag())/(a.real()-b.real());\n                double e=b.imag()-b.real()*d;\n                if((d*wp[i].real()+e>wp[i].imag()||EQ(d*wp[i].real()+e,wp[i].imag())))\n                    return false;\n            }\n        }\n        return true;\n    }\n}\n// ¶¤Ìvfª éFÅ é©Ç¤©`FbN\nbool checkLeftincludeLine(P a,P b,bool isW){\n    if(isW){\n        for(int i = 0; i < m; i++){\n            if(EQ(a.real(),b.real())){\n                if(wp[i].real()>a.real()&&!EQ(wp[i].real(),a.real()))\n                    return false;\n            }\n            else{\n                // y=d*x+e\n                double d=(a.imag()-b.imag())/(a.real()-b.real());\n                double e=b.imag()-b.real()*d;\n                if(!(d*wp[i].real()+e<wp[i].imag()||EQ(d*wp[i].real()+e,wp[i].imag())))\n                    return false;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            if(EQ(a.real(),b.real())){\n                if(!(bp[i].real()>a.real()&&!EQ(bp[i].real(),a.real())))\n                    return false;\n            }\n            else{\n                // y=d*x+e\n                double d=(a.imag()-b.imag())/(a.real()-b.real());\n                double e=b.imag()-b.real()*d;\n                if((d*bp[i].real()+e<bp[i].imag()||EQ(d*bp[i].real()+e,bp[i].imag())))\n                    return false;\n            }\n        }\n        return true;\n    }\n    else{\n        for(int i = 0; i < n; i++){\n            if(EQ(a.real(),b.real())){\n                if((bp[i].real()>a.real()&&!EQ(bp[i].real(),a.real())))\n                    return false;\n            }\n            else{\n                // y=d*x+e\n                double d=(a.imag()-b.imag())/(a.real()-b.real());\n                double e=b.imag()-b.real()*d;\n                if(!(d*bp[i].real()+e<bp[i].imag()||EQ(d*bp[i].real()+e,bp[i].imag())))\n                    return false;\n            }\n        }\n        for(int i = 0; i < m; i++){\n            if(EQ(a.real(),b.real())){\n                if(!(wp[i].real()>a.real()&&!EQ(wp[i].real(),a.real())))\n                    return false;\n            }\n            else{\n                // y=d*x+e\n                double d=(a.imag()-b.imag())/(a.real()-b.real());\n                double e=b.imag()-b.real()*d;\n                if((d*wp[i].real()+e<wp[i].imag()||EQ(d*wp[i].real()+e,wp[i].imag())))\n                    return false;\n            }\n        }\n        return true;\n    }\n}\n\nint main(){\n\n    while(cin>>n>>m&&!(n==0&&m==0)){\n        for(int i = 0; i < n; i++){\n            int x,y;\n            cin>>x>>y;\n            bp[i]=P(x,y);\n        }\n        for(int i = 0; i < m; i++){\n            int x,y;\n            cin>>x>>y;\n            wp[i]=P(x,y);\n        }\n        if(n==1&&m==1){\n            cout<<\"YES\"<<endl;\n            continue;\n        }\n        if(m!=1){\n            // 2_ðIñÅ¼üðì¬µAe_ª»Ì¼üÅ®SÉªÅ«é©²×é\n            bool ok=false;\n            for(int i = 0; i < m; i++){\n                for(int j = 0; j < m; j++){\n                    bool isLeft=false;\n                    bool no=false;\n                    // xªêv\n                    if(EQ(wp[i].real(),wp[j].real())){\n                        // Ç¿çÌvfªÇ¿çÉ®·é©\n                        for(int k = 0; k < n; k++){\n                            if(EQ(bp[k].real(),wp[i].real())){\n                                no=true;\n                                break;\n                            }\n                            else{\n                                if(bp[k].real()<wp[i].real()){\n                                    isLeft=true;\n                                    break;\n                                }\n                                else{\n                                    isLeft=false;\n                                    break;\n                                }\n                            }\n                        }\n                        if(no)continue;\n                    }\n                    else{\n                        // y=d*x+e\n                        double d=(wp[i].imag()-wp[j].imag())/(wp[i].real()-wp[j].real());\n                        double e=wp[j].imag()-wp[j].real()*d;\n                        // Ç¿çÌvfªÇ¿çÉ®·é©\n                        for(int k = 0; k < n; k++){\n                            if(EQ(d*bp[k].real()+e,bp[k].imag())){\n                                no=true;\n                                break;\n                            }\n                            else{\n                                if(d*bp[k].real()+e<bp[k].imag()){\n                                    isLeft=true;\n                                    break;\n                                }\n                                else{\n                                    isLeft=false;\n                                    break;\n                                }\n                            }\n                        }\n                        if(no)continue;\n                    }\n                    // ¶Éª®\n                    if(isLeft){\n                        if(checkRIghtincludeLine(wp[i],wp[j],true)){\n                            // ok\n                            ok=true;\n                            break;\n                        }\n                    }\n                    // E\n                    else{\n                        if(checkLeftincludeLine(wp[i],wp[j],true)){\n                            // ok\n                            ok=true;\n                            break;\n                        }\n                    }\n                }\n                if(ok)break;\n            }\n            if(ok){\n                cout<<\"YES\"<<endl;\n                continue;\n            }\n        }\n        if(n!=1){\n            // 2_ðIñÅ¼üðì¬µAe_ª»Ì¼üÅ®SÉªÅ«é©²×é\n            bool ok=false;\n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                    bool isLeft=false;\n                    bool no=false;\n                    // xªêv\n                    if(EQ(bp[i].real(),bp[j].real())){\n                        // Ç¿çÌvfªÇ¿çÉ®·é©\n                        for(int k = 0; k < m; k++){\n                            if(EQ(wp[k].real(),bp[i].real())){\n                                no=true;\n                                break;\n                            }\n                            else{\n                                if(wp[k].real()<bp[i].real()){\n                                    isLeft=true;\n                                    break;\n                                }\n                                else{\n                                    isLeft=false;\n                                    break;\n                                }\n                            }\n                        }\n                        if(no)continue;\n                    }\n                    else{\n                        // y=d*x+e\n                        double d=(bp[i].imag()-bp[j].imag())/(bp[i].real()-bp[j].real());\n                        double e=bp[j].imag()-bp[j].real()*d;\n                        // Ç¿çÌvfªÇ¿çÉ®·é©\n                        for(int k = 0; k < m; k++){\n                            if(EQ(d*wp[k].real()+e,wp[k].imag())){\n                                no=true;\n                                break;\n                            }\n                            else{\n                                if(d*wp[k].real()+e<wp[k].imag()){\n                                    isLeft=true;\n                                    break;\n                                }\n                                else{\n                                    isLeft=false;\n                                    break;\n                                }\n                            }\n                        }\n                        if(no)continue;\n                    }\n                    // ¶Éª®\n                    if(isLeft){\n                        if(checkRIghtincludeLine(bp[i],bp[j],false)){\n                            // ok\n                            ok=true;\n                            break;\n                        }\n                    }\n                    // E\n                    else{\n                        if(checkLeftincludeLine(bp[i],bp[j],false)){\n                            // ok\n                            ok=true;\n                            break;\n                        }\n                    }\n                }\n                if(ok)break;\n            }\n            if(ok){\n                cout<<\"YES\"<<endl;\n                continue;\n            }\n        }\n        cout<<\"NO\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nstruct Point\n{\n    double x,y;\n    Point (double x=0, double y=0) :x(x),y(y) {}\n    void show() { cout<<\"(\"<<x<<\",\"<<y<<\")\"<<endl; }\n};\ntypedef Point Vector;\n\nbool operator < (const Point& A, const Point& B )\n{\n    return A.x < B.x || (A.x == B.x && A.y < B.y);\n}\nVector operator - ( Point A, Point B) { return Vector(A.x-B.x, A.y-B.y); }\ndouble Cross(Vector A, Vector B) { return A.x*B.y - B.x*A.y; }\n\nconst double eps = 1e-10;\nint dcmp(double x)\n{\n    if(fabs(x) < eps) return 0;\n    return x>0? 1: -1;\n}\n\nint ConvexHull ( Point* p, int n, Point* ch)\n{\n    sort(p, p+n);\n    int m = 0;\n    for(int i = 0; i<n; i++)\n    {\n        while(m > 1 && Cross( ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0) m--;\n        ch[m++] = p[i];\n    }\n    int k = m;\n    for(int i = n-2; i>=0; i--)\n    {\n        while(m > k && Cross( ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0) m--;\n        ch[m++] = p[i];\n    }\n    ///&#36824;要改一下生成多&#36793;形。\n    ch[m++] = ch[0];\n    if(n > 1) m--;\n    return m;\n}\n\nPoint black[120],white[120],cw[120],cb[120];\nint nb,nw,n,m;\n\nvoid reset()\n{\n    memset(black,0,sizeof(black));\n    memset(white,0,sizeof(white));\n    memset(cw,0,sizeof(cw));\n    memset(cb,0,sizeof(cb));\n}\n\nbool SideCross(Point a1, Point a2, Point b1, Point b2)\n{\n    double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1),\n    c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1);\n    return dcmp(c1)*dcmp(c2)<0 && dcmp(c3)*dcmp(c4)<0;\n}\n\nbool pInConvex(Point a, Point* ch, int n)\n{\n    int i;\n    if(n==3)\n    {\n        if(a.x < min(ch[0].x, ch[1].x) || a.x > max(ch[0].x, ch[1].x)) return 0;\n        if(a.y < min(ch[0].y, ch[1].y) || a.y > max(ch[0].y, ch[1].y)) return 0;\n    }\n    for(i=1;i<n;i++)\n    {\n        if(Cross( ch[i]-ch[i-1], a-ch[i-1] ) < 0 ) return 0;\n    }\n    return 1;\n}\n\nint solve()\n{\n    int i,j;\n    if(n==1&&m==1) return 1;\n    else if(n==1)\n    {\n        ///找白子凸包多&#36793;形。判断&#36825;个?子是否在白包内\n        nw=ConvexHull(white, m, cw);\n        if(pInConvex(black[0], cw, nw)) return 0;\n    }\n    else if(m==1)\n    {\n        ///找?子凸包多&#36793;形。判断&#36825;个白子是否在?包内\n        nb=ConvexHull(black, n, cb);\n        if(pInConvex(white[0], cb, nb)) return 0;\n    }\n    else\n    {\n        ///找?白凸包多&#36793;形。判断是否有&#32447;段相交或点在&#21478;一个凸包内。\n        nb=ConvexHull(black, n, cb);\n        nw=ConvexHull(white, m, cw);\n        for(i=1;i<nb;i++)\n        {\n            for(j=1;j<nw;j++)\n                if(SideCross( cb[i], cb[i-1], cw[j] ,cw[j-1] )) return 0;\n        }\n        for(i=0;i<n;i++)\n            if(pInConvex(black[i], cw, nw)) return 0;\n        for(i=0;i<m;i++)\n            if(pInConvex(white[i], cb, nb)) return 0;\n    }\n    return 1;\n}\n\nint main()\n{\n    int i,tx,ty;\n    while(cin>>n>>m,n||m)\n    {\n        reset();\n        for(i=0;i<n;i++)\n        {\n            cin>>tx>>ty;\n            black[i]=Point(tx,ty);\n        }\n        for(i=0;i<m;i++)\n        {\n            cin>>tx>>ty;\n            white[i]=Point(tx,ty);\n        }\n        int ans=solve();\n        if(ans)\n            cout<<\"YES\"<<endl;\n        else\n            cout<<\"NO\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\ntypedef pair<double, double> P;\nint f(double w[], P p){\n  double v = w[0] + w[1] * p.first + w[2] * p.second;\n  if(v >= 0) return 1;\n  else return 0;\n}\n\nint main(){\n  int b, w;\n  while(cin>>b>>w && (b != 0 || w != 0)){\n    vector<P> points_b, points_w;\n    REP(i, b){\n      double x, y; cin>>x>>y;\n      points_b.push_back(P(x, y));\n    }\n    REP(i, w){\n      double x, y; cin>>x>>y;\n      points_w.push_back(P(x, y));\n    }\n    double we[3] = {};\n    double rate = 1;\n    bool ans = false;\n    REP(iter, 10000000/(w + b)){\n      bool update = false;\n      REP(i, b){\n        int v = f(we, points_b[i]);\n        if(v == 1){\n          we[0] = we[0] + rate * -1;\n          we[1] = we[1] + rate * -1 * points_b[i].first;\n          we[2] = we[2] + rate * -1 * points_b[i].second;\n          update = true;\n        }\n      }\n      REP(i, w){\n        int v = f(we, points_w[i]);\n        if(v == 0){\n          we[0] = we[0] + rate * 1;\n          we[1] = we[1] + rate * 1 * points_w[i].first;\n          we[2] = we[2] + rate * 1 * points_w[i].second;\n          update = true;\n        }\n      }\n      if(!update){\n        ans = true;\n        break;\n      }\n    }\n    if(ans) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a; i<(int)b; i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef complex<double> P;\n\nnamespace std {\n  bool operator < (P const& a, P const& b) {\n    if(real(a) != real(b)) return real(a) < real(b);\n    return imag(a) < imag(b);\n  }\n}\n\ndouble const EPS = 1e-8;\n\n#define prev(G, i) ( G[((i-1)+G.size())%G.size()] )\n#define curr(G, i) ( G[i%G.size()] )\n#define next(G, i) ( G[(i+1)%G.size()] )\n\ndouble dot(P const& a, P const& b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(P const& a, P const& b) {\n  return imag(conj(a)*b);\n}\n\ntypedef vector<P> Polygon;\n\nPolygon convex_hull(vector<P> ps) {\n  sort(ps.begin(), ps.end());\n  int N = ps.size(), k = 0;\n  vector<P> qs(N*2);\n  rep(i, N) {\n    while(k > 1 && cross(qs[k-1]-qs[k-2], ps[i]-ps[k-1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  for(int i=N-2, t=k; i>=0; i--) {\n    while(k > t && cross(qs[k-1]-qs[k-2], ps[i]-qs[k-1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nenum { counter_clock_wise=+1, clockwise=-1, cab_online=+2, abc_online=-2, on_segment = 0 };\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if(cross(b, c) > 0) return counter_clock_wise;\n  if(cross(b, c) < 0) return clockwise;\n  if(dot(b, c) < 0) return cab_online;\n  if(norm(b) < norm(c)) return abc_online;\n  return on_segment;\n}\n\nstruct Line : public vector<P>\n{\n  Line(P const& a, P const& b) {\n    push_back(a), push_back(b);\n  }\n};\n\ntypedef Line Segment;\n\nbool is_intersect_ss(Segment const& s, Segment const& t) {\n  return ( ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) < EPS )\n    && ( ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) < EPS );\n}\n\n// contain: 2, on segment: 1, the other case: 0\nint contains(Polygon const& G, P const& p) {\n  bool x = false;\n  for(int i=0; i<(int)G.size(); i++) {\n    P v1 = curr(G, i)-p, v2 = next(G, i) - p;\n    if( v1.imag() > v2.imag() ) swap(v1, v2);\n    if( v1.imag() <= 0 && 0 < v2.imag() && cross(v1, v2) > 0 ) x = !x;\n    if( cross(v1, v2) == 0 && dot(v1, v2) <= 0 ) return 1;\n  }\n  return (x?2:0);\n}\n\nint main() {\n\n  int N, M;\n  while(cin >> N >> M && (N|M)) {\n    Polygon G1(N), G2(M);\n    rep(i, N) cin >> G1[i].real() >> G1[i].imag(); \n    rep(i, M) cin >> G2[i].real() >> G2[i].imag(); \n    \n    G1 = convex_hull(G1); N = G1.size();\n    G2 = convex_hull(G2); M = G2.size();\n    //    cout << \"convex hull\\n\";\n    bool ok = (!contains(G1, G2[0])) && (!contains(G2, G1[0]));\n    rep(i, N) {\n      rep(j, M) {\n\tSegment s1 = Segment(curr(G1, i), next(G1, i));\n\tSegment s2 = Segment(curr(G2, j), next(G2, j));\n\tif(is_intersect_ss(s1, s2)) { ok = 0; }\n      }\n    }\n    \n    cout << (ok ? \"YES\\n\" : \"NO\\n\");\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\n\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersect(L s1, L s2){\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\nvector<P> convex_hull(vector<P> v){\n  vector<P> c; //convex\n  sort(v.begin(),v.end());\n  c.assign(v.begin(),v.begin()+2);\n    \n  for(int i=2;i<v.size();i++){\n    P a = c[c.size()-1] - c[c.size()-2];\n    P b = v[i] - c[c.size()-2];\n        \n    while(cross(a,b) > EPS){\n      c.pop_back();\n      if(c.size() < 2) break;\n      a = c[c.size()-1] - c[c.size()-2];\n      b = v[i] - c[c.size()-2];\n    }\n    c.push_back(v[i]);\n  }\n\t\n  int n = c.size();\n  c.push_back(v[v.size()-2]);\n\t\n  for(int i=v.size()-3;i>=0;i--){\n    P a = c[c.size()-1] - c[c.size()-2];\n    P b = v[i] - c[c.size()-2];\n        \n    while(cross(a,b) > EPS){\n      c.pop_back();\n      if(c.size() < n + 1) break;\n      a = c[c.size()-1] - c[c.size()-2];\n      b = v[i] - c[c.size()-2];\n    }\n    c.push_back(v[i]);\n  }\n  c.pop_back();\n  return c;\n}\n\n\nvector<P> p1,p2;\nint n,m;\nint solve(){\n  if(n+m<3) return 1;\n  if(m==1&&n==2) return ccw(p1[0],p1[1],p2[0])!=0;\n  if(n==2&&m==2) return !isIntersect(L(p1[0],p1[2]),L(p2[0],p2[1]));\n\n  vector<P> t=convex_hull(p1);\n  for(int i=0;i<=(int)t.size();i++){\n    int flg=1;\n    for(int j=0;j<m&&flg;j++)\n      if(ccw(t[i],t[(i+1)%t.size()],p2[j])!=1)flg=0;\n    if(flg) return 1;\n    \n  }\n  return 0;  \n}\n\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)return 0;\n    p1.resize(n),p2.resize(m);\n    for(int i=0,a,b;i<n;i++)cin>>a>>b,p1[i]=P(a,b);\n    for(int i=0,a,b;i<m;i++)cin>>a>>b,p2[i]=P(a,b);\n    int ans=solve();\n    swap(p1,p2);\n    swap(n,m);\n    ans|=solve();\n    cout<<(ans?\"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconstexpr double EPS = 1e-9;\n\nstruct point {\n    double x, y;\n    point(double x_ = 0.0, double y_ = 0.0):x(x_), y(y_) {}\n    point(const point& p):x(p.x), y(p.y) {}\n\n    inline point operator+ (const point& p) const {\n        return point(x + p.x, y + p.y);\n    }\n\n    inline point operator- (const point& p) const {\n        return point(x - p.x, y - p.y);\n    }\n\n    inline point operator* (double s) const {\n        return point(x * s, y * s);\n    }\n\n    inline point operator* (const point& p) const {\n        return point(x * p.x - y * p.y, x * p.y + y * p.x);\n    }\n\n    inline point operator/ (double s) const {\n        return point(x / s, y / s);\n    }\n\n    inline bool operator< (const point& p) const {\n        return x + EPS < p.x || (abs(x - p.x) < EPS && y + EPS < p.y);\n    }\n\n    inline bool operator== (const point& p) const {\n        return abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n    }\n};\n\ninline double norm(const point& p) {\n    return p.x * p.x + p.y * p.y;\n}\n\ninline double dot(const point& a, const point& b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ninline double cross(const point& a, const point& b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nstruct segment {\n    point a, b;\n    segment(const point& a_, const point& b_):a(a_), b(b_){}\n};\n\ntypedef vector<point> polygon;\n\ninline int ccw(const point& a, point b, point c) {\n    b = b - a;\n    c = c - a;\n    const double tmp = cross(b, c);\n    if(tmp > EPS) return 1; // ccw\n    if(tmp < -EPS) return -1; // cw\n    if(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n    if(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n    return 0; //a, c, b 順で一直線上\n}\n\ninline bool intersect(const segment& s, const segment& t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n        && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ninline bool intersect(const segment& s, const point& p) {\n    return ccw(s.a, s.b, p) == 0;\n}\n\ninline polygon convex_hull(vector<point> points) {\n    const int n = points.size();\n    if(n <= 3) return points;\n\n    sort(points.begin(), points.end());\n    int k = 0;\n    polygon res;\n    res.resize(2 * n);\n    for(int i = 0; i < n; res[k++] = points[i++]) {\n        while(k >= 2 && ccw(res[k - 2], res[k - 1], points[i]) <= 0) --k;\n    }\n\n    const int t = k + 1;\n    for(int i = n - 2; i >= 0; res[k++] = points[i--]) {\n        while(k >= t && ccw(res[k - 2], res[k - 1], points[i]) <= 0) --k;\n    }\n\n    res.resize(k - 1);\n    return res;\n}\n\ninline bool intersect(const polygon& P, const point& p) {\n    const int n = P.size();\n    bool res = false;\n    for(int i = 0; i < n; ++i) {\n        point v1 = P[i] - p, v2 = P[(i + 1) % n] - p;\n        if(v1.y > v2.y) swap(v1, v2);\n        if(v1.y < EPS && EPS < v2.y && cross(v1, v2) > EPS) res = !res;\n        if(abs(cross(v1, v2)) < EPS && dot(v1, v2) < EPS) return true;\n    }\n\n    return res;\n}\n\ninline bool intersect(const polygon& P, const segment& s) {\n    const int n = P.size();\n    if(intersect(P, s.a) || intersect(P, s.b)) return true;\n\n    for(int i = 0; i < n; ++i) {\n        if(intersect(segment(P[i], P[(i + 1) % n]), s)) return true;\n    }\n\n    return false;\n}\n\ninline bool intersect(const polygon &a, const polygon &b) {\n    const int n = b.size();\n    for(int i = 0; i < n; ++i) {\n        if(intersect(a, segment(b[i], b[(i + 1) % n]))) return true;\n    }\n\n    for(const auto &p : a) {\n        if(intersect(b, p)) return true;\n    }\n\n    return false;\n}\n\ninline vector<point> input_points(int n) {\n    vector<point> res;\n    res.reserve(n);\n\n    for(int i = 0; i < n; ++i) {\n        double x, y;\n        cin >> x >> y;\n        res.emplace_back(x, y);\n    }\n\n    return res;\n}\n\ninline bool check(const vector<point> &a, const vector<point> &b) {\n\treturn !intersect(convex_hull(a), convex_hull(b));\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n    for(int n, m; cin >> n >> m && n;) {\n        const auto black_points = input_points(n);\n        const auto white_points = input_points(m);\n        cout << (check(black_points, white_points) ? \"YES\" : \"NO\") << endl;\n    }\n\n    return EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-10\n#define INF 1000000\n \nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n    Point operator *(const double d)const{\n        return Point(x*d,y*d);\n    }\n    bool operator <(const Point &p)const{\n        if(x==p.x) return y<p.y;\n        return x<p.x;\n    }\n    double norm(){\n        return x*x+y*y;\n    }\n\tbool input(){\n\t\tif(cin>>x>>y) return true;\n\t\treturn false;\n\t}\n};\n \nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n\tbool input(){\n\t\tif(a.input() && b.input()) return true;\n\t\treturn false;\n\t}\n};\n \nstruct Circle{\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point _c,double _r){\n        c=_c; r=_r;\n    }\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n \nint ccw(Point a,Point b,Point c){\n\tPoint v1 = b-a;\n\tPoint v2 = c-a;\n    if(cross(v1,v2)>EPS) return +1;\n    if(cross(v1,v2)<-EPS) return -1;\n\tif(dot(v1,v2)<-EPS) return +2;\n\tif(v1.norm()<v2.norm()) return -2;\n    return 0;\n}\n \nbool intersect_ss(Line l,Line m){\n    return ccw(l.a,l.b,m.a)*ccw(l.a,l.b,m.b)<=0 && ccw(m.a,m.b,l.a)*ccw(m.a,m.b,l.b)<=0;\n}\n \nbool crosspoint_ll(Line l,Line m,Point &p){\n    Point a1,a2,b1,b2;\n    a1 = l.b-l.a; a2 = m.b-m.a;\n    b1 = m.a-l.a; b2 = l.a-m.b;\n    double s1,s2;\n    s1 = cross(a1,b1)/2; s2 = cross(a1,b2)/2;\n    if(s1+s2<EPS) return false;\n    p = Point(m.a.x+a2.x*s1/(s1+s2),m.a.y+a2.y*s1/(s1+s2));\n    return true;\n}\n \nint crosspoint_ss(Line l,Line m,Point &p){\n    if(intersect_ss(l,m)==false) return 0;\n    if(crosspoint_ll(l,m,p)==true) return 1;\n\treturn -1;\n}\n \nint crosspoint_cc(Circle c1,Circle c2,Point &p1,Point &p2){\n    double d,a,t;\n    d = sqrt((c2.c-c1.c).norm());\n\tif(abs(c1.c.x-c2.c.x)<EPS && abs(c1.c.y-c2.c.y)<EPS && abs(c1.r-c2.r)<EPS)\n\t\treturn -1;\n    if(d<abs(c1.r-c2.r) || c1.r+c2.r<d) return 0;\n    a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    t = atan2(c2.c.y-c1.c.y,c2.c.x-c1.c.x);\n    p1 = Point(c1.c.x+c1.r*cos(t+a),c1.c.y+c1.r*sin(t+a));\n    p2 = Point(c1.c.x+c1.r*cos(t-a),c1.c.y+c1.r*sin(t-a));\n    if(abs(p1.x-p2.x)<EPS && abs(p1.y-p2.y)<EPS) return 1;\n    return 2;\n}\n\nint contains(Polygon g,Point p){\n\tLine l = Line(p,Point(INF,p.y));\n\tint cnt = 0, n = g.size();\n\tfor(int i=0;i<n;i++){\n\t\tPoint a = g[i]-p;\n\t\tPoint b = g[(i+1)%n]-p;\n\t\tif(ccw(g[i],g[(i+1)%n],p)==0) return 1;\n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<=EPS && EPS<b.y && cross(a,b)>EPS) cnt++;\n\t}\n\tif((cnt&1)==1) return 2;\n\treturn 0;\n}\n\nPolygon andrewScan(Polygon s){\n\tif(s.size()<=2) return s;\n\tsort(s.begin(),s.end());\n\tPolygon g;\n\tfor(int i=0;i<s.size();i++){\n\t\tfor(int n=g.size(); n>=2 && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\tint upper_n = g.size();\n\tfor(int i=s.size()-2;i>=0;i--){\n\t\tfor(int n=g.size(); n>upper_n && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\treverse(g.begin(),g.end());\n\tg.pop_back();\n\treturn g;\n}\n\nint main(){\n\tint N,M;\n\tPolygon b,w,gb,gw;\n\twhile(cin>>N>>M,N||M){\n\t\tb.resize(N); w.resize(M);\n\t\tfor(int i=0;i<N;i++) b[i].input();\n\t\tfor(int i=0;i<M;i++) w[i].input();\n\t\tgb = andrewScan(b); gw = andrewScan(w);\n\t\tbool ans = true;\n\t\tfor(int i=0;i<gb.size() && ans;i++){\n\t\t\tfor(int j=0;j<gw.size() && ans;j++){\n\t\t\t\tLine l(gb[i],gb[(i+1)%gb.size()]), m(gw[i],gw[(i+1)%gw.size()]);\n\t\t\t\tif(intersect_ss(l,m)==true) ans = false;\n\t\t\t}\n\t\t}\n\t\tif(gb.size()>=2){\n\t\t\tfor(int i=0;i<M && ans;i++){\n\t\t\t\tif(contains(gb,w[i])!=0) ans = false;\n\t\t\t}\n\t\t}\n\t\tif(gw.size()>=2){\n\t\t\tfor(int i=0;i<N && ans;i++){\n\t\t\t\tif(contains(gw,b[i])!=0) ans = false;\n\t\t\t}\n\t\t}\n\t\tif(ans==true) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <stdio.h>\n\nusing namespace std;\n\n#define fo(i,n) for(int i=0; i<(int)n; i++)\n#define rep(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#define mp(a,b) make_pair(a,b)\n#define pb(x) push_back(x)\n#define pii pair<int,int>\n\ntypedef long long ll;\n\nstruct point{\n\tll x,y;\n\tpoint(){}\n\tpoint (ll x, ll y):x(x),y(y){}\n\tbool operator<(const point &p) const {\n\t\treturn x<p.x || (x==p.x && y<p.y);\n\t}\n};\n\nll cross(const point &O,const point &a, const point &b) {\n\treturn (a.x-O.x)*(b.y-O.y) - (a.y-O.y)*(b.x-O.x);\n}\t\n\nll dot(ll x1, ll y1, ll x2, ll y2) {\n\treturn x1*x2 + y1*y2;\n}\n\nvector<point> convex_hull(vector<point> &p) {\n\tint k = 0;\n\tint n = p.size();\n\tvector<point> ch(2*n);\n\tsort(p.begin(),p.end());\n\t\n\tfor (int i=0; i<n; i++) {\n\t\twhile (k>=2 && cross(ch[k-2], ch[k-1], p[i]) <= 0) k--;\n\t\tch[k++] = p[i];\n\t}\n\t\n\tfor (int i=n-2, t=k+1; i>=0; i--) {\n\t\twhile (k >= t && cross(ch[k-2], ch[k-1], p[i]) <= 0) k--;\n\t\tch[k++] = p[i];\n\t}\n\tch.resize(k);\n\treturn ch;\n}\n\nvector<point> hull;\nint n,m;\nint xb[110], yb[110];\nint xw[110], yw[110];\n\nbool inside(const point &a) {\n\tif (hull.size()<=2) return false;\n\tfor (int i=0; i<hull.size()-1; i++) {\n\t\tif (cross(a,hull[i],hull[i+1])<0) return false;\n\t\tif (cross(a,hull[i],hull[i+1])==0) {\n\t\t\tif (dot(hull[i].x-a.x,hull[i].y-a.y,hull[i+1].x-a.x,hull[i+1].y-a.y)<=0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool intersect(point a1, point a2, point b1, point b2) {\n\treturn a1.x<=b2.x && a2.x>=b1.x && a1.y<=b2.y && a2.y>=b1.y;\n}\n\nint main() {\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n\twhile (scanf(\"%d%d\",&n,&m) && n!=0 ) {\n\t\tfor (int i=0; i<n; i++) scanf(\"%d%d\",xb+i,yb+i);\n\t\tfor (int i=0; i<m; i++) scanf(\"%d%d\",xw+i,yw+i);\n\t\t\n\t\tvector<point> p(n);\n\t\tbool good = 1;\n\t\tif (m>2) {\n\t\t\tfor (int i=0; i<n; i++) p[i] = point(xb[i],yb[i]);\n\t\t\thull = convex_hull(p); \n\t\t\t\n\t\t\tfor (int i=0; i<m; i++) if (inside(point(xw[i],yw[i]))) {\n\t\t\t\tgood = 0;\n\t\t\t\tbreak;\n\t\t\t}\t\n\t\t}\n\t\telse {\n\t\t\tif (m==2) {\n\t\t\t\tfor (int i=0; i<m; i++) for (int j=i+1; j<m; j++) {\n\t\t\t\t\tif (intersect(point(xw[i],yw[i]),point(xw[j],yw[j]),point(xb[0],yb[0]),point(xb[1],yb[1]))) {\n\t\t\t\t\t\tgood = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i=0; i<m; i++) for (int j=i+1; j<m; j++) {\n\t\t\t\t\tif ((xb[0]==xw[i]&&yb[0]==yw[i])||(xb[0]==xw[j]&&yb[0]==yw[j])) {\n\t\t\t\t\t\tgood = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (dot(xw[i]-xb[0],yw[i]-yb[0],xw[j]-xb[0],yw[j]-yb[0])<0) {\n\t\t\t\t\t\t\tgood = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tp.clear();\n\t\tp.resize(m);\n\t\tif (m>2) {\n\t\t\tfor (int i=0; i<m; i++) p[i] = point(xw[i],yw[i]);\n\t\t\thull = convex_hull(p); \n\t\t\t\n\t\t\tfor (int i=0; i<n; i++) if (inside(point(xb[i],yb[i]))) {\n\t\t\t\tgood = 0;\n\t\t\t\tbreak;\n\t\t\t}\t\n\t\t}\n\t\telse {\n\t\t\tif (m==2) {\n\t\t\t\tfor (int i=0; i<n; i++) for (int j=i+1; j<n; j++) {\n\t\t\t\t\tif (intersect(point(xb[i],yb[i]),point(xb[j],yb[j]),point(xw[0],yw[0]),point(xw[1],yw[1]))) {\n\t\t\t\t\t\tgood = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i=0; i<n; i++) for (int j=i+1; j<n; j++) {\n\t\t\t\t\tif ((xw[0]==xb[i]&&yw[0]==yb[i])||(xw[0]==xb[j]&&yw[0]==yb[j])) {\n\t\t\t\t\t\tgood = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (dot(xb[i]-xw[0],yb[i]-yw[0],xb[j]-xw[0],yb[j]-yw[0])<0) {\n\t\t\t\t\t\t\tgood = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (good) printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\");\n\t}\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\n#define EPS 1e-7\n\ntypedef complex<double> point;\ntypedef const point &refpoint;\n\n\ndouble dot(refpoint a, refpoint b){\n\treturn real(a) * real(b) + imag(a) * imag(b);\n}\n\ndouble cross(refpoint a, refpoint b){\n\treturn real(a) * imag(b) - imag(a) * real(b);\n}\n\ndouble distance_l_p(refpoint a, refpoint b, refpoint c){\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\ndouble distance_ls_p(refpoint a, refpoint b, refpoint c){\n\tif( dot(b - a, c - a) <= 0.0 ) return abs(c - a);\n\tif( dot(a - b, c - b) <= 0.0 ) return abs(c - b);\n\treturn distance_l_p(a, b, c);\n}\n\nbool contains(const vector<point> &plg, refpoint pts){\n\tint cnt = 0;\n\tdouble y = imag(pts);\n\n\tfor(int i = 0; i < plg.size(); ++i){\n\t\tint j = (i + 1 == plg.size() ? 0: i + 1);\n\n\t\tdouble dyi = imag(plg[i]) - y;\n\t\tdouble dyj = y - imag(plg[j]);\n\t\tdouble tx = (dyi * real(plg[j]) + dyj * real(plg[i])) / (dyi + dyj);\n\n\t\tif(imag(plg[i]) >= y && imag(plg[j]) < y){\n\t\t\tif( tx < real(pts) ) ++cnt;\n\t\t}\n\t\telse if(imag(plg[i]) < y && imag(plg[j]) >= y){\n\t\t\tif( tx < real(pts) ) --cnt;\n\t\t}\n\t}\n\t\n\treturn (cnt % 2 != 0);\n}\n\nbool intersected(refpoint pa1, refpoint pa2, refpoint pb1, refpoint pb2){\n\tdouble a = cross(pa2 - pa1, pb1 - pa1);\n\tdouble b = cross(pa2 - pa1, pb2 - pa1);\n\tdouble c = cross(pb2 - pb1, pa1 - pb1);\n\tdouble d = cross(pb2 - pb1, pa2 - pb1);\n\n\tif( (a < -EPS && b > EPS) || (b < -EPS && a > EPS) ){\n\t\tif( (c < -EPS && d > EPS) || (d < -EPS && c > EPS) ){\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nbool contact(const vector<point> &plg1, const vector<point> &plg2){\n\tif( contains(plg1, plg2[0]) || contains(plg2, plg1[0]) ){\n\t\treturn true;\n\t}\n\n\tint n = plg1.size();\n\tint m = plg2.size();\n\tfor(int i = 0; i < n; ++i){\n\t\tfor(int j = 0; j < m; ++j){\n\t\t\tif( intersected(plg1[i], plg1[(i+1)%n], plg2[j], plg2[(j+1)%m]) ){\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif( distance_ls_p(plg1[i], plg1[(i+1)%n], plg2[j]) < EPS ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif( distance_ls_p(plg2[j], plg2[(j+1)%m], plg1[i]) < EPS ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n\nbool orderbyreal(refpoint p1, refpoint p2){\n\treturn real(p1) < real(p2);\n}\n\n\nvector<point> convex(vector<point> plg){\n\tint n = plg.size();\n\tif( n <= 3 ){\n\t\treturn plg;\n\t}\n\n\tsort(plg.begin(), plg.end(), orderbyreal);\n\n\tvector<point> ret(2 * n);\n\tint k = 0;\n\n\tfor(int i = 0; i < n; ++i){\n\t\twhile( k >= 2 && cross( ret[k-1] - ret[k-2], plg[i] - ret[k-2] ) <= 0.0 ){\n\t\t\t--k;\n\t\t}\n\t\tret[k++] = plg[i];\n\t}\n\n\tint t = k + 1;\n\tfor(int i = n - 2; i >= 0; --i){\n\t\twhile( k >= t && cross( ret[k-1] - ret[k-2], plg[i] - ret[k-2] ) <= 0.0 ){\n\t\t\t--k;\n\t\t}\n\t\tret[k++] = plg[i];\n\t}\n\tret.resize(k - 1);\n\t\n\treturn ret;\n}\n\n\nint main(){\n\tint n, m;\n\tdouble x, y;\n\t\n\twhile( scanf(\"%d%d\", &n, &m), n != 0 ){\n\t\tvector<point> black, white;\n\t\tblack.reserve(n);\n\t\twhite.reserve(m);\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\tblack.push_back( point(x, y) );\n\t\t}\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\twhite.push_back( point(x, y) );\n\t\t}\n\n\n\t\tblack = convex(black);\n\t\twhite = convex(white);\n\n\t\tif( contact(black, white) ){\n\t\t\tputs(\"NO\");\n\t\t}\n\t\telse{\n\t\t\tputs(\"YES\");\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tbool operator==(const Point& p) const { return px == p.px && py == p.py; }\n\tbool operator!=(const Point& p) const { return px != p.px || py != p.py; }\n\tbool operator<(const Point& p) const { return px < p.px ? true : (px == p.px && py < p.py); }\n\tbool operator>(const Point& p) const { return px > p.px ? true : (px == p.px && py > p.py); }\n\tbool operator<=(const Point& p) const { return !(Point(px, py) > p); }\n\tbool operator>=(const Point& p) const { return !(Point(px, py) < p); }\n\tPoint operator+(const Point& p) const { return Point(px + p.px, py + p.py); }\n\tPoint operator-(const Point& p) const { return Point(px - p.px, py - p.py); }\n\tPoint operator/(long double d) const { return Point(px / d, py / d); }\n\tfriend Point operator*(const Point p, long double d) { return Point(p.px * d, p.py * d); }\n\tfriend Point operator*(long double d, const Point& p) { return p * d; }\n\tPoint& operator+=(const Point& p1) { px += p1.px, py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px, py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d, py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d, py /= d; return *this; }\n};\n\n// ------ Functions ------ //\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint pol(long double r, long double d) { return Point(cosl(d) * r, sinl(d) * r); }\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nvector<Point> convex_hull(vector<Point> v) {\n\tif (v.size() < 3) return v;\n\tsort(v.begin(), v.end());\n\tvector<Point> u = { v[0], v[1] }, l = { v[v.size() - 1], v[v.size() - 2] };\n\tfor (int i = 2; i < v.size(); i++) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], v[i]) >= 0; n--) u.pop_back();\n\t\tu.push_back(v[i]);\n\t}\n\tfor (int i = v.size() - 3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], v[i]) >= 0; n--) l.pop_back();\n\t\tl.push_back(v[i]);\n\t}\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\n// ------ Main ------ //\nint n, m;\nint main() {\n\twhile (cin >> n >> m, n + m) {\n\t\tvector<Point> v1(n), v2(m);\n\t\tfor (int i = 0; i < n; i++) cin >> v1[i].px >> v1[i].py;\n\t\tfor (int i = 0; i < m; i++) cin >> v2[i].px >> v2[i].py;\n\t\tvector<Point> v3 = convex_hull(v1), v4 = convex_hull(v2);\n\t\tint x = 0;\n\t\tfor (int i = 0; i < v3.size(); i++) {\n\t\t\tint u = (i + 1) % v3.size(), f = 1;\n\t\t\tfor (int j = 0; j < v4.size(); j++) {\n\t\t\t\tif (abs(ccw(v3[i], v3[u], v4[j])) != 1) {\n\t\t\t\t\tf = 0; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f) continue;\n\t\t\tfor (int j = 0; j < v3.size(); j++) {\n\t\t\t\tif (i == j || u == j) continue;\n\t\t\t\tfor (int k = 0; k < v4.size(); k++) {\n\t\t\t\t\tif (ccw(v3[i], v3[u], v3[j]) == ccw(v3[i], v3[u], v4[k])) {\n\t\t\t\t\t\tf = 0; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!f) break;\n\t\t\t}\n\t\t\tif (!f) continue;\n\t\t\tfor (int j = 0; j < v4.size(); j++) {\n\t\t\t\tfor (int k = j + 1; k < v4.size(); k++) {\n\t\t\t\t\tif (ccw(v3[i], v3[u], v4[j]) == ccw(v3[i], v3[u], v4[k])) {\n\t\t\t\t\t\tf = 0; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tx = 1; break;\n\t\t\t}\n\t\t}\n\t\tcout << (x ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long int LL;\n\nstruct Vector {\n\tLL x, y;\n\n\tVector (LL x = 0, LL y = 0) : x(x), y(y) { }\n\n\tLL cross(const Vector &b) const {\n\t\treturn x * b.y - y * b.x;\n\t}\n\n\tVector operator-(const Vector &b) const {\n\t\treturn Vector(x - b.x, y - b.y);\n\t}\n\n\tLL dot(const Vector &b) const {\n\t\treturn x * b.x + y * b.y;\n\t}\n};\n\nconst int maxn = 1024;\n\nint N, M, all;\nVector P[maxn];\n\n\nstruct Cmp { \n\tVector s, t;\n\tbool operator() (const int a, const int b) {\n\t\treturn (P[a] - s).dot(t - s) < (P[b] - s).dot(t - s);\n\t}\n};\n\ninline bool getColor(int i) {\n\treturn (0 <= i && i < N);\n}\n\ninline bool judge(Vector a, Vector b) {\n\tint n = 0;\n\tstatic int tmp[maxn];\n\n\tif (a.x == b.x && a.y == b.y) {\n\t\treturn false ;\n\t}\n\tfor (int i = 0;i < N;i++) {\n\t\tif ((P[i] - b).cross(a - b) > 0)\n\t\t\treturn false ;\n\t}\n\tfor (int i = N;i < all;i++) {\n\t\tif ((P[i] - b).cross(a - b) < 0) {\n\t\t\treturn false ;\n\t\t}\n\t}\n\tfor (int i = 0;i < all;i++) {\n\t\tif ((P[i] - b).cross(a - b) == 0) {\n\t\t\ttmp[n++] = i;\n\t\t}\n\t}\n\tCmp cmp;\n\tcmp.s = a; cmp.t = b;\n\tsort(tmp, tmp + n, cmp);\n\n\tbool exp = 1;\n\tfor (int i = 0;i < n;i++) {\n\t\tint t = tmp[i];\n\t\tif (exp == 1 && getColor(t) != getColor(tmp[0])) {\n\t\t\texp = 0;\n\t\t}\n\t\tif ((getColor(t) == getColor(tmp[0])) != exp) {\n\t\t\treturn false ;\n\t\t}\n\t}\n\treturn true ;\n}\n\nint main() {\n\twhile (scanf(\"%d%d\", &N, &M), !(N == 0 && M == 0)) {\n\t\tfor (int i = 0;i < N;i++) {\n\t\t\tscanf(\"%lld%lld\", &P[i].x, &P[i].y);\n\t\t}\n\t\tfor (int i = N;i < N+M;i++) {\n\t\t\tscanf(\"%lld%lld\", &P[i].x, &P[i].y);\n\t\t}\n\t\tall = N + M;\n\t\tif (all <= 1) {\n\t\t\tputs(\"YES\");\n\t\t\tcontinue ;\n\t\t}\n\t\tfor (int i = 0;i < all;i++) {\n\t\t\tfor (int j = 0;j < i;j++) {\n\t\t\t\tif (judge(P[i], P[j]) || judge(P[j], P[i])) {\n\t\t\t\t\tputs(\"YES\");\n\t\t\t\t\tgoto OUT;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"NO\");\nOUT:\t\t;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define not_equal(a,b) (!equal(a,b))\n#define lt(a,b) (a-b < -EPS)\n#define PI acos(-1)\n\nstruct Point{\n  double x,y;\n\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n  Point operator / (const double &k)const{ return Point(x/k,y/k); }\n  bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\n\nistream &operator >> (istream &is,Point &p){ \n  return is >> p.x >> p.y;\n}\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS){ return COUNTER_CLOCKWISE; }\n  if(cross(a,b) < -EPS){ return CLOCKWISE; }\n  if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n  if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n  return ON_SEGMENT;\n}\n\nstruct Segment{\n  Point s,t;\n  Segment(){}\n  Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nbool isIntersectSP(const Segment &s,const Point &p){\n  return equal(ccw(s.s,s.t,p),0);\n}\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n  Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0\n    && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\n#define prev(G,i) (G[(i-1+G.size())%G.size()])\n#define curr(G,i) (G[i%G.size()])\n#define next(G,i) (G[(i+1)%G.size()])\ntypedef vector<Point> Polygon;\n\nbool check(const Polygon &pg,const Point &p){\n  int N = pg.size();\n  bool in = false;\n  for(int i = 0 ; i < N ; i++){\n    Point a = curr(pg,i)-p, b = next(pg,i)-p;\n    if(a.y > b.y){ swap(a,b); }\n    if(a.y <= 0 && 0 < b.y && cross(a,b) > 0){ in = !in; }\n    if(cross(a,b) == 0 && dot(a,b) <= 0){ return true; }\n  }\n  return in;\n}\n\nbool solve(Polygon &bp,Polygon &wp){\n  int N = bp.size(), M = wp.size();\n  if(N == 1 && M == 1){\n    return !(equal(bp[0].x,wp[0].x) && equal(bp[0].y,wp[0].y));\n  }\n  if(N == 2 && M == 1){\n    Segment s(bp[0],bp[1]);\n    return !isIntersectSP(s,wp[0]);\n  }\n  if(N == 1 && M == 2){\n    Segment s(wp[0],wp[1]);\n    return !isIntersectSP(s,bp[0]);\n  }\n  if(N == 2 && M == 2){\n    Segment s1(bp[0],bp[1]),s2(wp[0],wp[1]);\n    return !isIntersectSS(s1,s2);\n  }\n  if(N == 1 && M >= 3){\n    return !check(wp,bp[0]);\n  }\n  if(N >= 3 && M == 1){\n    return !check(bp,wp[0]);\n  }\n  if(N == 2 && M >= 3){\n    bool l = false,r = false;\n    if(!check(wp,bp[0]) || !check(wp,bp[1])){\n      return false;\n    }\n    for(int i = 0 ; i < M ; i++){\n      int res = ccw(bp[0],bp[1],wp[i]);\n      if(res == ON_SEGMENT){\n        return false;\n      }\n      if(res == COUNTER_CLOCKWISE){\n        l = true;\n      }\n      if(res == CLOCKWISE){\n        r = true;\n      }\n    }\n    if(l && r){ return false; }\n    return true;\n  }\n  if(N >= 3 && M == 2){\n    bool l = false,r = false;\n    if(check(bp,wp[0]) || check(bp,wp[1])){\n      return false;\n    }\n    for(int i = 0 ; i < N ; i++){\n      int res = ccw(wp[0],wp[1],bp[i]);\n      if(res == ON_SEGMENT){\n        return false;\n      }\n      if(res == COUNTER_CLOCKWISE){\n        l = true;\n      }\n      if(res == CLOCKWISE){\n        r = true;\n      }\n    }\n    if(l && r){ return false; }\n    return true;\n  }\n  for(int i = 0 ; i < N ; i++){\n    if(check(wp,bp[i])){\n      return false;\n    }\n  }\n  for(int i = 0 ; i < M ; i++){\n    if(check(bp,wp[i])){\n      return false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  int N,M;\n  while(cin >> N >> M,N){\n    Polygon bp(N),wp(M);\n    for(int i = 0 ; i < N ; i++){\n      cin >> bp[i];\n    }\n    for(int i = 0 ; i < M ; i++){\n      cin >> wp[i];\n    }\n    cout << (solve(bp,wp) ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D; \ntypedef complex<D> P;\ntypedef pair<P, P> L;\ntypedef vector<P> VP;\nconst D EPS = 1e-9; \n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1; \n  if (cross(b,c) < -EPS) return -1;\n  if (dot(b,c)   < -EPS) return +2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\nVP convexHull(VP ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\nint main(){\n  int n,m;\n  double x,y;\n  while(cin>>n>>m,n){\n    VP v1,v2,v3;\n    int f=0;\n    set<VP>se;\n    rep(i,n){\n      cin>>x>>y;\n      v1.push_back(P(x,y));\n    }\n    rep(i,m){\n      cin>>x>>y;\n      v2.push_back(P(x,y));\n    }\n    v1=convexHull(v1);\n    v2=convexHull(v2);\n    if(!v1.size()&&!v2.size())goto L;\n    se.insert(v1);\n    se.insert(v2);\n    rep(i,v1.size())v3.push_back(v1[i]);\n    rep(i,v2.size())v3.push_back(v2[i]);\n    v3=convexHull(v3);\n    if(se.count(v3))f++;\n    rep(i,v1.size())\n      rep(j,v2.size())\n        if(isecSS(v1[i],v1[(i+1)%(int)v1.size()],v2[j],v2[(i+1)%(int)v2.size()]))f++;\n    L:;cout<<(f?\"NO\":\"YES\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define EPS 0.000001\ntypedef long double ld;\n\n//FILE *in = freopen(\"input.txt\", \"r\", stdin);\n\nstruct P {\n\tld x, y;\n\tP(ld x, ld y):x(x),y(y){}\n\tP(){}\n};\n\nP operator -(const P &a, const P &b) { return P(a.x-b.x, a.y-b.y); }\nbool operator <(const P &a, const P &b){ return make_pair(a.x, a.y) < make_pair(b.x, b.y); }\n\nld cross(const P &a, const P &b) { return a.x*b.y-a.y*b.x; }\nld dot(const P &a, const P &b) { return a.x*b.x+a.y*b.y; }\nld norm(const P &a) { return dot(a,a); }\nint ccw(P a, P b, P c) {\n\tb = b - a; c = c - a;\n\tif(cross(b,c) > EPS) return 1;\n\tif(cross(b,c) < EPS) return -1;\n\tif(dot(b,c) < 0) return 2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nstruct L:vector<P>{\n\tL(P a=P(0,0), P b=P(0,0)) {\n\t\tthis->push_back(a);\n\t\tthis->push_back(b);\n\t}\n};\n\nbool is_intersect_SS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0],s[1],t[1]) <= 0 &&\n\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\n\nvector<P> convex_hull(vector<P> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<P> ch(2*n);\n\tfor(int i = 0; i < n; ch[k++]=ps[i++])\n\t\twhile(k >= 2 && ccw(ch[k-2],ch[k-1],ps[i]) <= 0)--k;\n\tfor(int i = n-2, t = k+1; i >= 0; ch[k++]=ps[i--])\n\t\twhile(k>=t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0)--k;\n\tif(k>2)ch.resize(k-1);\n\treturn ch;\n}\n\nint n, m;\nvector<P> black;\nvector<P> white;\n\nvoid input() {\n\tblack.clear();\n\twhite.clear();\n\trep(i, n) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tblack.push_back(P(x,y));\n\t}\n\trep(i, m) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\twhite.push_back(P(x,y));\n\t}\n}\n\nvoid process() {\n\tblack = convex_hull(black);\n\twhite = convex_hull(white);\n\twhite.push_back(white[0]);\n\n\t// Check LP\n\trep(i,black.size()) {\n\t\tL x(black[i], P(black[i].x+1,black[i].y+20001));\n\t\tint cnt = 0;\n\t\trep(j,white.size()-1) {\n\t\t\tL y(white[j], white[j+1]);\n\t\t\tcnt += is_intersect_SS(x,y);\n\t\t}\n\t\tif(cnt%2 == 1) {\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tblack.push_back(black[0]);\n\n\t// Check cross LL\n\trep(i,black.size()-1) {\n\t\tL x(black[i],black[i+1]);\n\t\trep(j,white.size()-1){\n\t\t\tL y(white[j], white[j+1]);\n\t\t\tif(is_intersect_SS(x,y)) {\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"YES\\n\");\n}\n\nint main() {\n\twhile(true) {\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(!n) break;\n\t\tinput();\n\t\tprocess();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint sign(double r){ return (r < -EPS) ? -1 : (r > EPS) ? 1 : 0; }\nbool eq(double a, double b){ return abs(b - a) < EPS; }\n\nstruct Point{\n  double x, y;\n  Point() {}\n  Point(double x, double y) : x(x), y(y) {}\n  Point operator+(const Point& b) const { return Point(x + b.x, y + b.y); }\n  Point operator-(const Point& b) const { return Point(x - b.x, y - b.y); }\n  Point operator*(const double b) const { return Point(x * b, y * b); }\n  Point operator*(const Point& b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n  Point operator/(const double b) const { return Point(x / b, y / b); }\n  bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y; }\n  bool operator==(const Point& b) const { return eq(x, b.x) && eq(y, b.y); }\n  double norm(){ return x * x + y * y; }\n  double arg(){ return atan2(x, y); }\n  double abs(){ return sqrt(norm()); }\n  Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n  Point rotate90(){ return Point(-y, x); }\n};\n\nostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\nistream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\ndouble dot(const Point& a, const Point& b){ return a.x * b.x + a.y * b.y; }\ndouble cross(const Point& a, const Point& b){ return a.x * b.y - a.y * b.x; }\nPoint polor(double rho, double theta){ return Point(rho * cos(theta), rho * sin(theta)); }\n\nstruct Line : public vector<Point> {\n  Line(const Point& a, const Point& b) {\n    push_back(a); push_back(b);\n  }\n  Point vector() const {\n    return back() - front();\n  }\n};\nstruct Circle : Point {\n  double r;\n  Circle(Point p, double r) : Point(p), r(r) { }\n};\ntypedef vector<Point> Polygon;\nPoint curr(const Polygon& a, int x){ return a[x]; }\nPoint next(const Polygon& a, int x){ return a[(x + 1) % a.size()]; }\nPoint prev(const Polygon& a, int x){ return a[(x - 1 + a.size()) % a.size()]; }\n\n//a->b->c\nint ccw(Point a, Point b, Point c) {\n  b = b - a; c = c - a;\n  if (cross(b, c) > EPS)   return +1; // 反時計回り\n  if (cross(b, c) < -EPS)   return -1; // 時計回り\n  if (dot(b, c) < 0)     return +2; // c--a--b の順番で一直線上\n  if (b.norm() < c.norm()) return -2; // a--b--c の順番で一直線上\n  return 0;                         // a--c--b の順番で一直線上 (aがbまたはcと重なる場合を含む)\n}\n// 二直線の交差判定\nbool intersectLL(const Line& l, const Line& m) {\n  // 直線lと直線mが平行でない\n  return abs(cross(l.vector(), m.vector())) > EPS;\n}\n// 二直線の同一判定\nbool equalLL(const Line& l, const Line& m){\n  // 直線lとl[0]からm[0]への直線が並行\n  return abs(cross(l.vector(), m[0] - l[0])) < EPS;\n}\n// 直線と線分の交差判定(注意: 同一直線上にある場合も含む)\nbool intersectLS(const Line& l, const Line& s) {\n  // 直線lについて、線分sの端点が異なる側にある\n  return cross(l.vector(), s[0] - l[0]) * cross(l.vector(), s[1] - l[0]) < EPS; \n}\n// 直線と点の交差判定\nbool intersectLP(const Line& l, const Point& p) {\n  // 直線lとl[0]からpへの直線が平行\n  return abs(cross(l.vector(), p - l[0])) < EPS;\n}\n// 二つの線分の交差判定\nbool intersectSS(const Line& s, const Line& t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n         ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n// 線分と点の交差判定(端点を含む)\nbool intersectSP(const Line& s, const Point& p) {\n  return ccw(s[0], s[1], p) == 0;\n}\n// 円と点の交差判定(EPS注意)\nbool intersectCP(const Circle& c, const Point& p){\n  // 円の中心と点の距離が、円の半径以下である\n  return (c - p).abs() < c.r + EPS;\n}\n// 二つの円の交差判定(EPS注意)\nbool intersectCC(const Circle& c, const Circle& d){\n  // 円の中心同士の距離が、半径の和以下であり、半径の差以上である\n  return (c - d).abs() < c.r + d.r + EPS && (c - d).abs() > abs(c.r - d.r) - EPS;\n}\n// 射影\nPoint projection(const Line& l, const Point& p){\n  double t = dot(p - l[0], l.vector()) / l.vector().norm();\n  return l[0] + l.vector() * t;\n}\n// 反射\nPoint reflection(const Line& l, const Point& p){\n  return p + (projection(l, p) - p) * 2;\n}\n// 直線と点の距離\ndouble distanceLP(const Line& l, const Point& p){\n  // pからlに下ろした垂線の長さ\n  return (p - projection(l, p)).abs();\n}\n// 二直線の距離\ndouble distanceLL(const Line& l, const Line& m){\n  // 平行でないときは0, 平行のときは垂線の長さ\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n// 直線と線分の距離\ndouble distanceLS(const Line& l, const Line& s){\n  if(intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n// 線分と点の距離\ndouble distanceSP(const Line& s, const Point& p){\n  const Point r = projection(s, p);\n  if(intersectSP(s, r)) return (r - p).abs(); // 垂線が線分に交わるとき\n  return min((s[0] - p).abs(), (s[1] - p).abs());\n}\n// 二つの線分の距離\ndouble distanceSS(const Line& s, const Line& t){\n  if(intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n// 二直線の交点\nPoint crosspointLL(const Line& l, const Line& m){\n  double d = cross(m.vector(), l.vector());\n  if(abs(d) < EPS) assert(false); // 直線が交わらない\n  return l[0] + l.vector() * cross(m.vector(), m[1] - l[0]) * (1.0 / d);\n}\n\n// 点が多角形のどこにあるのか判定する\nenum { OUT, ON, IN };\nint contains(const Polygon& P, const Point& p){\n  // 点pから半直線をひき、辺と交差する回数を数える\n  bool in = false;\n  REP(i, P.size()){\n    Point a = curr(P, i) - p;\n    Point b = next(P, i) - p;\n    if(a.y > b.y) swap(a, b);\n    // aからbの直線がy=0と交わり、その交点は原点の右側である\n    if(a.y <= 0 && 0 < b.y && cross(a, b) < 0){ \n      in = !in;\n    }\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n// 多角形の面積\ndouble area(const Polygon& P) {\n  double A = 0;\n  REP(i, P.size()){\n    A += cross(curr(P, i), next(P, i));\n  }\n  return A / 2.0;\n}\n\n// 凸多角形の直線による切断。直線の左側だけ残す\nPolygon convex_cut(const Polygon& P, const Line& l){\n  Polygon Q;\n  REP(i, P.size()){\n    Point A = curr(P, i), B = next(P, i);\n    if(ccw(l[0], l[1], A) != -1) Q.push_back(A); //Aが直線lの右側でない\n    if(ccw(l[0], l[1], A) * ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspointLL(l, Line(A, B)));\n  }\n  return Q;\n}\nint main(){\n  int N, M;\n  while(cin>>N>>M && N){\n    vector<Point> points(N + M);\n    vector<int> color(N + M, -1);\n    REP(i, N + M) cin>>points[i];\n    REP(i, M) color[N + i] = 1;\n    bool ans = false;\n    REP(i, N + M) REP(j, N + M) if(i != j){\n      // p[i]からp[j]への直線\n      Line l(points[i], points[j]);\n      bool ok = true;\n      REP(k, N + M) if(i != k && j != k) {\n        int c = ccw(l[0], l[1], points[k]);\n        if(abs(c) != 1 || c != color[k]) ok = false;\n      }\n      if(ok) ans = true;\n\n      // p[i]とp[j]の中線\n      if(color[i] != -1 || color[j] != 1) continue; // 黒白を分断\n      Line l2((l[0] + l[1]) * 0.5, l.vector().rotate90());\n      ok = true;\n      REP(k, N + M) if(i != k && j != k) {\n        int c = ccw(l2[0], l2[1], points[k]);\n        if(k <  N && c != +1) ok = false;\n        if(k >= N && c != -1) ok = false;\n      }\n      if(ok) ans = true;\n    }\n    if(ans) cout << \"YES\" << endl;\n    else    cout << \"NO\"  << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ------ Petr Mitrichev is Professional. ------ //\n\n#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// ------ Class ------ //\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tbool operator==(const Point& p) const { return px == p.px && py == p.py; }\n\tbool operator!=(const Point& p) const { return px != p.px || py != p.py; }\n\tbool operator<(const Point& p) const { return px < p.px ? true : (px == p.px && py < p.py); }\n\tbool operator>(const Point& p) const { return px > p.px ? true : (px == p.px && py > p.py); }\n\tbool operator<=(const Point& p) const { return !(Point(px, py) > p); }\n\tbool operator>=(const Point& p) const { return !(Point(px, py) < p); }\n\tPoint operator+(const Point& p) const { return Point(px + p.px, py + p.py); }\n\tPoint operator-(const Point& p) const { return Point(px - p.px, py - p.py); }\n\tPoint operator/(long double d) const { return Point(px / d, py / d); }\n\tfriend Point operator*(const Point p, long double d) { return Point(p.px * d, p.py * d); }\n\tfriend Point operator*(long double d, const Point& p) { return p * d; }\n\tPoint& operator+=(const Point& p1) { px += p1.px, py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px, py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d, py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d, py /= d; return *this; }\n};\n\n// ------ Functions ------ //\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint pol(long double r, long double d) { return Point(cosl(d) * r, sinl(d) * r); }\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nvector<Point> convex_hull(vector<Point> v) {\n\tif (v.size() < 3) return v;\n\tsort(v.begin(), v.end());\n\tvector<Point> u = { v[0], v[1] }, l = { v[v.size() - 1], v[v.size() - 2] };\n\tfor (int i = 2; i < v.size(); i++) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], v[i]) >= 0; n--) u.pop_back();\n\t\tu.push_back(v[i]);\n\t}\n\tfor (int i = v.size() - 3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], v[i]) >= 0; n--) l.pop_back();\n\t\tl.push_back(v[i]);\n\t}\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\n// ------ Main ------ //\nint n, m; vector<Point> v1, v2, v3, v4;\nbool ok(int i) {\n\tint u = (i + 1) % v3.size();\n\tfor (int j = 0; j < v4.size(); j++) {\n\t\tif (abs(ccw(v3[i], v3[u], v4[j])) != 1) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tfor (int j = 0; j < v3.size(); j++) {\n\t\tif (i == j || u == j) continue;\n\t\tfor (int k = 0; k < v4.size(); k++) {\n\t\t\tif (ccw(v3[i], v3[u], v3[j]) == ccw(v3[i], v3[u], v4[k])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < v4.size(); j++) {\n\t\tfor (int k = j + 1; k < v4.size(); k++) {\n\t\t\tif (ccw(v3[i], v3[u], v4[j]) != ccw(v3[i], v3[u], v4[k])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\twhile (cin >> n >> m, n + m) {\n\t\tv1.resize(n), v2.resize(m);\n\t\tfor (int i = 0; i < n; i++) cin >> v1[i].px >> v1[i].py;\n\t\tfor (int i = 0; i < m; i++) cin >> v2[i].px >> v2[i].py;\n\t\tv3 = convex_hull(v1), v4 = convex_hull(v2);\n\t\tint x = 0;\n\t\tif (v3.size() == 1 && v4.size() == 1) x = 1;\n\t\tif (!x && v3.size() > 1) {\n\t\t\tint w = ccw(v3[0], v3[1], v4[0]);\n\t\t\tif (abs(w) == 2) {\n\t\t\t\tint f = 1;\n\t\t\t\tfor (int i = 1; i < v4.size(); i++) {\n\t\t\t\t\tif (ccw(v3[0], v3[1], v4[i]) != w) {\n\t\t\t\t\t\tf = 0; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f) x = 1;\n\t\t\t}\n\t\t}\n\t\tif (!x && v4.size() > 1) {\n\t\t\tint w = ccw(v4[0], v4[1], v3[0]);\n\t\t\tif (abs(w) == 2) {\n\t\t\t\tint f = 1;\n\t\t\t\tfor (int i = 1; i < v3.size(); i++) {\n\t\t\t\t\tif (ccw(v4[0], v4[1], v3[i]) != w) {\n\t\t\t\t\t\tf = 0; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f) x = 1;\n\t\t\t}\n\t\t}\n\t\tif (!x) {\n\t\t\tfor (int i = 0; i < v3.size(); i++) {\n\t\t\t\tif (ok(i)) x = 1;\n\t\t\t}\n\t\t}\n\t\tif (!x) {\n\t\t\tswap(v3, v4);\n\t\t\tfor (int i = 0; i < v4.size(); i++) {\n\t\t\t\tif (ok(i)) x = 1;\n\t\t\t}\n\t\t}\n\t\tcout << (x ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-8\n#define INF 1000000\n \nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n    Point operator *(const double d)const{\n        return Point(x*d,y*d);\n    }\n    bool operator <(const Point &p)const{\n        if(x==p.x) return y<p.y;\n        return x<p.x;\n    }\n    double norm(){\n        return x*x+y*y;\n    }\n\tbool input(){\n\t\tif(cin>>x>>y) return true;\n\t\treturn false;\n\t}\n};\n \nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n\tbool input(){\n\t\tif(a.input() && b.input()) return true;\n\t\treturn false;\n\t}\n};\n \nstruct Circle{\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point _c,double _r){\n        c=_c; r=_r;\n    }\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n \nint ccw(Point a,Point b,Point c){\n\tPoint v1 = b-a;\n\tPoint v2 = c-a;\n    if(cross(v1,v2)>EPS) return +1;\n    if(cross(v1,v2)<-EPS) return -1;\n\tif(dot(v1,v2)<-EPS) return +2;\n\tif(v1.norm()<v2.norm()) return -2;\n    return 0;\n}\n \nbool intersect_ss(Line l,Line m){\n\treturn ccw(l.a,l.b,m.a)*ccw(l.a,l.b,m.b)<=0 && ccw(m.a,m.b,l.a)*ccw(m.a,m.b,l.b)<=0;\n}\n \nbool crosspoint_ll(Line l,Line m,Point &p){\n    Point a1,a2,b1,b2;\n    a1 = l.b-l.a; a2 = m.b-m.a;\n    b1 = m.a-l.a; b2 = l.a-m.b;\n    double s1,s2;\n    s1 = cross(a1,b1)/2; s2 = cross(a1,b2)/2;\n    if(s1+s2<EPS) return false;\n    p = Point(m.a.x+a2.x*s1/(s1+s2),m.a.y+a2.y*s1/(s1+s2));\n    return true;\n}\n \nint crosspoint_ss(Line l,Line m,Point &p){\n    if(intersect_ss(l,m)==false) return 0;\n    if(crosspoint_ll(l,m,p)==true) return 1;\n\treturn -1;\n}\n \nint crosspoint_cc(Circle c1,Circle c2,Point &p1,Point &p2){\n    double d,a,t;\n    d = sqrt((c2.c-c1.c).norm());\n\tif(abs(c1.c.x-c2.c.x)<EPS && abs(c1.c.y-c2.c.y)<EPS && abs(c1.r-c2.r)<EPS)\n\t\treturn -1;\n    if(d<abs(c1.r-c2.r) || c1.r+c2.r<d) return 0;\n    a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    t = atan2(c2.c.y-c1.c.y,c2.c.x-c1.c.x);\n    p1 = Point(c1.c.x+c1.r*cos(t+a),c1.c.y+c1.r*sin(t+a));\n    p2 = Point(c1.c.x+c1.r*cos(t-a),c1.c.y+c1.r*sin(t-a));\n    if(abs(p1.x-p2.x)<EPS && abs(p1.y-p2.y)<EPS) return 1;\n    return 2;\n}\n\nint contains(Polygon g,Point p){\n\tLine l = Line(p,Point(INF,p.y));\n\tint cnt = 0, n = g.size();\n\tfor(int i=0;i<n;i++){\n\t\tPoint a = g[i]-p;\n\t\tPoint b = g[(i+1)%n]-p;\n\t\tif(ccw(g[i],g[(i+1)%n],p)==0) return 1;\n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<=EPS && EPS<b.y && cross(a,b)>EPS) cnt++;\n\t}\n\tif((cnt&1)==1) return 2;\n\treturn 0;\n}\n\nPolygon andrewScan(Polygon s){\n\tif(s.size()<=2) return s;\n\tsort(s.begin(),s.end());\n\tPolygon g;\n\tfor(int i=0;i<s.size();i++){\n\t\tfor(int n=g.size(); n>=2 && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\tint upper_n = g.size();\n\tfor(int i=s.size()-2;i>=0;i--){\n\t\tfor(int n=g.size(); n>upper_n && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\treverse(g.begin(),g.end());\n\tg.pop_back();\n\treturn g;\n}\n\nint main(){\n\tint N,M;\n\tPolygon b,w,gb,gw;\n\twhile(cin>>N>>M,N||M){\n\t\tb.resize(N); w.resize(M);\n\t\tfor(int i=0;i<N;i++) b[i].input();\n\t\tfor(int i=0;i<M;i++) w[i].input();\n\t\tgb = andrewScan(b); gw = andrewScan(w);\n\t\t/*for(int i=0;i<gb.size();i++) printf(\"%f,%f \",gb[i].x,gb[i].y); puts(\"\");\n\t\tfor(int i=0;i<gw.size();i++) printf(\"%f,%f \",gw[i].x,gw[i].y); puts(\"\");*/\n\t\tbool ans = true;\n\t\tfor(int i=0;i<gb.size() && ans;i++){\n\t\t\tfor(int j=0;j<gw.size() && ans;j++){\n\t\t\t\tLine l(gb[i],gb[(i+1)%gb.size()]), m(gw[j],gw[(j+1)%gw.size()]);\n\t\t\t\tif(intersect_ss(l,m)==true) ans = false;\n\t\t\t}\n\t\t}\n\t\tif(gb.size()>=3){\n\t\t\tfor(int i=0;i<M && ans;i++){\n\t\t\t\tif(contains(gb,w[i])!=0) ans = false;\n\t\t\t}\n\t\t}\n\t\tif(gw.size()>=3){\n\t\t\tfor(int i=0;i<N && ans;i++){\n\t\t\t\tif(contains(gw,b[i])!=0) ans = false;\n\t\t\t}\n\t\t}\n\t\tif(gb.size()==2 && gw.size()==1){\n\t\t\tif(ccw(gb[0],gb[1],gw[0])==0) ans = false;\n\t\t}\n\t\tif(gw.size()==2 && gb.size()==1){\n\t\t\tif(ccw(gw[0],gw[1],gb[0])==0) ans = false;\n\t\t}\n\t\tif(ans==true) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iomanip>\n\n#define REP(i,n) for(i=0; i < (n); i++)\n#define REPONE(i, n) for(i=1; i <= (n); i++)\n#define LOOP(n) for(int loopCount=1; loopCount <= (n); loopCount++)\n#define ITER(c) __typeof((c).begin())\n#define EACH(c,it) for(ITER(c) it =(c).begin(); it!=(c).end(); it++)\n#define SZ(c) ((int) (c).size())\n#define ALL(c) c.begin(), c.end()\n#define SUM(c) accumulate(ALL(c), 0)\n#define EXIST(c,v) (find(ALL(c), (v)) != (c).end())\n#define PB push_back\n#define MP make_pair\n\nusing namespace std;\nstatic const double EPS = 1e-8;\nstatic const double PI = 3.141592653589793238462643383279;\n\n/*\ntypedef complex<double> point;\n\ntemplate<typename T>\nint sig2(T x){\n    if(abs(x)<EPS) return 0;\n    if(x>0) return 1;\n    return -1;\n}\n\ndouble det(point p1, point p2, point q){\n    return p2.real()*q.imag()+p1.real()*p2.imag()+q.real()*p1.imag()\n            -p2.real()*p1.imag()-q.real()*p2.imag()-q.imag()*p1.real();\n}\nint main(){\n    int i,j,k,n,m;\n    double x,y,bxma,byma,bxmi,bymi,wxma,wyma,wxmi,wymi;\n    bool yes;\n    while(scanf(\"%d%d\",&n,&m)){\n        if(n==0 && m==0) break;\n        bxma=byma=wxma=wyma=-1e99;\n        bxmi=bymi=wxmi=wymi=1e99;\n        yes=false;\n        vector<point> bs(n), ws(m);\n        REP(i,n){\n            scanf(\"%lf%lf\",&x,&y);\n            bs[i]=point(x,y);\n            bxma=max(bxma, x);\n            byma=max(byma, y);\n            bxmi=min(bxmi, x);\n            bymi=min(bymi, y);\n        }\n        REP(i,m){\n            scanf(\"%lf%lf\",&x,&y);\n            ws[i]=point(x,y);\n            wxma=max(wxma, x);\n            wyma=max(wyma, y);\n            wxmi=min(wxmi, x);\n            wymi=min(wymi, y);\n        }\n        if(bxma<wxmi||bxmi>wxma||byma<wymi||bymi>wyma){\n            printf(\"YES\\n\");\n            continue;\n        }\n        if(n==1 && m==1){\n            printf(\"YES\\n\");\n            continue;\n        }\n        int w=0, b;\n        REP(i,n)for(j=i+1;j<n;j++){\n            w = 0;\n            REP(k,m) w+=sig2(det(bs[i],bs[j],ws[k]));\n            if(abs(w)<m)break;\n            REP(k,n)if(sig2(det(bs[i],bs[j],bs[k]))==sig2(w))break;\n            if(k==n){\n                yes = true;\n                goto end;\n            }\n        }\n        swap(n,m);\n        swap(bs,ws);\n        REP(i,n)for(j=i+1;j<n;j++){\n            w = 0;\n            REP(k,m) w+=sig2(det(bs[i],bs[j],ws[k]));\n            if(abs(w)<m)break;\n            REP(k,n)if(sig2(det(bs[i],bs[j],bs[k]))==sig2(w))break;\n            if(k==n){\n                yes = true;\n                goto end;\n            }\n        }\n        REP(i,n)REP(j,m){\n            w = b = 0;\n            REP(k,m) w+=sig2(det(bs[i],ws[j],ws[k]));\n            if(abs(w)<m-1)break;\n            REP(k,n) b+=sig2(det(bs[i],ws[j],bs[k]));\n            if(abs(b)<n-1)break;\n            if(w*b<0){\n                yes = true;\n                goto end;\n            }\n        }\n        end:;\n        if(yes)printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n    return 0;\n}\n*/\n\n#define N 80000\n\nint main(){\n    int i,j,n,m;\n    double bma,bmi,wma,wmi,ang=PI/N,tmp;\n    static double bxs[100], wxs[100], bys[100], wys[100];\n    while(scanf(\"%d%d\",&n,&m)){\n        if(n==0 && m==0) break;\n        REP(i,n)scanf(\"%lf%lf\",bxs+i,bys+i);\n        REP(i,m)scanf(\"%lf%lf\",wxs+i,wys+i);\n        REP(i,N){\n            bma=wma=-1e99;\n            bmi=wmi=1e99;\n            REP(j,n){\n                tmp = cos(ang*i)*bxs[j]-sin(ang*i)*bys[j];\n                if(tmp<bmi)bmi=tmp;\n                if(tmp>bma)bma=tmp;\n            }\n            REP(j,m){\n                tmp = cos(ang*i)*wxs[j]-sin(ang*i)*wys[j];\n                if(bmi<tmp && tmp<bma) goto mark;\n                if(tmp<wmi)wmi=tmp;\n                if(tmp>wma)wma=tmp;\n            }\n            if((bma < wmi - EPS) || (wma < bmi - EPS)) break;\n            mark:;\n        }\n        if(i==N)printf(\"NO\\n\");\n        else printf(\"YES\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\ntypedef struct node{int x,y;};\nint n,m;\nnode a[110];\ndouble s(int i,int j,int k)\n{\n    return fabs(a[i].x*a[j].y+a[k].x*a[i].y+a[j].x*a[k].y-a[k].x*a[j].y-a[i].x*a[k].y-a[j].x*a[i].y);\n}\nbool tepan(int i,int j,int k,int l)\n{\n    if(max(a[i].x,a[j].x)<min(a[k].x,a[l].x)||min(a[i].x,a[j].x)>max(a[k].x,a[l].x))return false;\n    else return true;\n}\nbool ok(int i,int j,int k, int l)\n{\n    int a=s(i,j,k),b=s(l,i,j),c=s(l,k,i),d=s(l,j,k);\n    if(a==0&&b==0&&c==0&&d==0)return tepan(i,j,k,l);\n    if(a==b+c+d)return true;\n    else return false;\n}\nbool xing(int i,int j,int k)\n{\n    if(a[i].x==a[j].x){\n        if(a[i].x!=a[k].x)return false;\n        if(a[k].y>max(a[i].y,a[j].y)||a[k].y<min(a[i].y,a[j].y))return false;\n        return true;\n    }\n    if((double)(a[k].y-a[i].y)/(a[k].x-a[i].x)!=(double)(a[j].y-a[i].y)/(a[j].x-a[i].x))return false;\n    if(a[k].y>max(a[i].y,a[j].y)||a[k].y<min(a[i].y,a[j].y))return false;\n    return true;\n}\nint main()\n{\n    while(~scanf(\"%d%d\",&n,&m),n+m)\n    {\n        for(int i=0;i<m+n;i++)\n            scanf(\"%d%d\",&a[i].x,&a[i].y);\n        int flag=1;\n        if(n>=3)for(int i=0;i<n;i++)\n            for(int j=i+1;j<n;j++)\n                for(int k=j+1;k<n;k++)\n                    for(int l=n;l<n+m;l++)\n                        if(ok(i,j,k,l)){flag=0;cout<<i<<' '<<j<<' '<<k<<' '<<l<<endl;break;}\n        if(m>=3)for(int i=n;i<n+m;i++)\n            for(int j=i+1;j<n+m;j++)\n                for(int k=j+1;k<n+m;k++)\n                    for(int l=0;l<n;l++)\n                        if(ok(i,j,k,l)){flag=0;break;}\n        if(m<3&&n<3){\n            if(m==1&&n==2){\n                if(xing(0,1,2)){flag=0;}\n            }\n            else if(m==2&&n==1){\n                if(xing(1,2,0)){flag=0;}\n            }\n            else if(m==2&&n==2){\n                a[4].x=2*a[0].x-a[1].x;\n                a[4].y=2*a[0].y-a[1].y;\n                a[5].x=2*a[1].x-a[0].x;\n                a[5].y=2*a[1].y-a[0].y;\n                if(ok(2,3,4,0)&&ok(2,3,5,1)){flag=0;}\n            }\n        }\n        if(flag)printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n    return 0;\n}\n\n/*\n3 3\n100 700\n200 200\n600 600\n500 100\n500 300\n800 500\n3 3\n100 300\n400 600\n400 100\n600 400\n500 900\n300 300\n3 4\n300 300\n500 300\n400 600\n100 100\n200 900\n500 900\n800 100\n1 2\n300 300\n100 100\n500 500\n1 1\n100 100\n200 100\n2 2\n0 0\n500 700\n1000 1400\n1500 2100\n2 2\n0 0\n1000 1000\n1000 0\n0 1000\n3 3\n0 100\n4999 102\n10000 103\n5001 102\n10000 102\n0 101\n3 3\n100 100\n200 100\n100 200\n0 0\n400 0\n0 400\n3 3\n2813 1640\n2583 2892\n2967 1916\n541 3562\n9298 3686\n7443 7921\n0 0\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<complex>\n#define Re real()\n#define Im imag()\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\ntypedef vector<Point> Polygon;\nconst double eps = 1e-10;\n\nPoint black[105], white[105];\nPolygon bp, wp;\nint n, m, bpl, wpl;\n\nbool cmp(Point a, Point b)\n{\n    if(fabs(a.Re - b.Re) < eps) return a.Im < b.Im;\n    else return a.Re < b.Re;\n}\n\ndouble cross(const Point& a, const Point& b)\n{\n    return (conj(a) * b).Im;\n}\n\ndouble dot(const Point& a, const Point& b)\n{\n    return (conj(a) * b).Re;\n}\n\nvoid convex_hull()\n{\n    bp.resize(2 * n);\n    bpl = 0;\n    for(int i = 0; i < n; i++)\n    {\n        while(bpl > 1 && cross(bp[bpl - 1] - bp[bpl - 2], black[i] - bp[bpl - 1]) < 0) bpl--;\n        bp[bpl++] = black[i];\n    }\n    for(int i = n - 2, t = bpl; i >= 0; i--)\n    {\n        while(bpl > t && cross(bp[bpl - 1] - bp[bpl - 2], black[i] - bp[bpl - 1]) < 0) bpl--;\n        bp[bpl++] = black[i];\n    }\n    bp.resize(bpl - 1);\n    wp.resize(2 * m);\n    wpl = 0;\n    for(int i = 0; i < m; i++)\n    {\n        while(wpl > 1 && cross(wp[wpl - 1] - wp[wpl - 2], white[i] - wp[wpl - 1]) < 0) wpl--;\n        wp[wpl++] = white[i];\n    }\n    for(int i = m - 2, t = wpl; i >= 0; i--)\n    {\n        while(wpl > t && cross(wp[wpl - 1] - wp[wpl - 2], white[i] - wp[wpl - 1]) < 0) wpl--;\n        wp[wpl++] = white[i];\n    }\n    wp.resize(wpl - 1);\n}\n\nint ccw(Point& a, Point& b, Point& c)\n{\n    Point t1 = b - a, t2 = c - a;\n    if(cross(t1, t2) > 0)   return +1;        // counter clockwise\n    if(cross(t1, t2) < 0)   return -1;        // clockwise\n    if(dot(t1, t2) < 0)     return +2;        // c--a--b on line\n    if(norm(t1) < norm(t2)) return -2;        // a--b--c on line\n    return 0;\n}\n\nbool is_point_intersaction(Point a, pair <Point, Point> b)\n{\n    return (fabs( dot(b.first - a, b.second - a) - (-1.0 * sqrt(norm(b.first - a) * norm(b.second - a))) < eps));\n}\n\nbool isintersaction(pair <Point, Point> a, pair <Point, Point> b)\n{\n    return (ccw(b.first, b.second, a.first) * ccw(b.first, b.second, a.second) <= 0 && ccw(a.first, a.second, b.first) * ccw(a.first, a.second, b.second) <= 0);\n}\n\n// 0 --- out of the polygon, 1 -- on the polygon, 2 -- in the polygon\nint checkin(const Point& t, Polygon s)\n{\n    int cnt = 0;\n    for(int i = 0; i < s.size(); i++)\n    {\n        Vector v1 = s[i] - t, v2 = s[(i + 1) % s.size()] - t;\n        if(v1.Im > v2.Im) swap(v1, v2);\n        if(v1.Im <= 0 && v2.Im > 0 && cross(v1, v2) < 0) cnt ^= 1;\n        if(cross(v1, v2) == 0 && dot(v1, v2) <= 0) return 1;\n    }\n    return cnt ? 2 : 0;\n}\n\nbool check()\n{\n    int flag = 0, f1 = 0, f2 = 0;\n    for(int i = 0; i < bp.size(); i++)\n        if(checkin(wp[i], bp) == 1 || checkin(wp[i], bp) == 2) f1 = 1;\n    for(int i = 0; i < wp.size(); i++)\n        if(checkin(bp[i], wp) == 1 || checkin(bp[i], wp) == 2) f2 = 1;\n    flag = f1 | f2;\n    if(flag == 1) return false;\n    else\n    {\n        for(int i = 0; i < bp.size(); i++)\n        {\n            for(int j = 0; j< wp.size(); j++)\n            {\n                if( isintersaction( make_pair(bp[(i+1)%bp.size()],bp[i]), make_pair(wp[(j+1)%wp.size()],wp[j])))\n                    return false;\n            }\n        }\n        return true;\n    }\n}\n\nint main()\n{\n    while(~scanf(\"%d%d\", &n, &m), n + m)\n    {\n        for(int i = 0; i < n; i++)\n        {\n            double tx, ty;\n            scanf(\"%lf %lf\", &tx, &ty);\n            black[i] = Point(tx, ty);\n        }\n        for(int i = 0; i < m; i++)\n        {\n            double tx, ty;\n            scanf(\"%lf %lf\", &tx, &ty);\n            white[i] = Point(tx, ty);\n        }\n        if(n >= 3 && m >= 3)\n        {\n            convex_hull();\n            if(check()) printf(\"YES\\n\");\n            else printf(\"NO\\n\");\n        }\n        else if(n == 1 && m == 1)\n            printf(\"YES\\n\");\n        else if(n == 1 && m == 2)\n        {\n            bool flag = is_point_intersaction(black[0], make_pair(white[0], white[1]));\n            if(flag) printf(\"NO\\n\");\n            else printf(\"YES\\n\");\n        }\n        else if(n == 2 && m == 1)\n        {\n            bool flag = is_point_intersaction(white[0], make_pair(black[0], black[1]));\n            if(flag) printf(\"NO\\n\");\n            else printf(\"YES\\n\");\n        }\n        else if(n == 2 && m == 2)\n        {\n            bool flag = isintersaction(make_pair(white[0], white[1]), make_pair(black[0], black[1]));\n            if(flag) printf(\"NO\\n\");\n            else printf(\"YES\\n\");\n        }\n    }\n    return 0;\n}\n/*\n\n3 3\n100 700\n200 200\n600 600\n500 100\n500 300\n800 500\n3 3\n100 300\n400 600\n400 100\n600 400\n500 900\n300 300\n3 4\n300 300\n500 300\n400 600\n100 100\n200 900\n500 900\n800 100\n1 2\n300 300\n100 100\n500 500\n1 1\n100 100\n200 100\n2 2\n0 0\n500 700\n1000 1400\n1500 2100\n2 2\n0 0\n1000 1000\n1000 0\n0 1000\n3 3\n0 100\n4999 102\n10000 103\n5001 102\n10000 102\n0 101\n3 3\n100 100\n200 100\n100 200\n0 0\n400 0\n0 400\n3 3\n2813 1640\n2583 2892\n2967 1916\n541 3562\n9298 3686\n7443 7921\n0 0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <ctime>\n#define INF 1000000007\n#define MP make_pair\nconst int NUM = 100010;\nconst double eps = 1e-10, pi = acos(-1.0);\nusing namespace std;\ntypedef pair <int, int> P;\ntypedef long long LL;\ntypedef unsigned long long uLL;\ninline int sgn(LL x)\n{\n\tif(x < 0)return -1;\n\treturn x > 0 ? 1 : 0;\n}\nclass Point\n{\npublic:\n\tLL x, y;\n\tPoint(LL _x = 0, LL _y = 0): x(_x), y(_y) {}\n\tPoint operator - (const Point b)const {return Point(x - b.x, y - b.y);}\n\tLL operator * (const Point b) const {return x * b.x + y * b.y;}\n\tLL operator ^ (const Point b)const {return x * b.y - y * b.x;}\n};\nvector<Point> black, white;\nint n, m;\nbool _cmp(Point a, Point b)\n{\n\tif(a.x != b.x) return a.x < b.x;\n\treturn a.y < b.y;\n}\n\nvector<Point> get_convex_hull(vector<Point> p, int pnum)\n{\n\tint i, limit = 1, cnt = 0;\n\tvector<Point> res(2 * pnum + 5);\n\tsort(p.begin(), p.end(), _cmp);\n\tfor(i = 0; i < pnum; i++)\n\t{\n\t\twhile(cnt > limit && sgn((res[cnt - 1] - res[cnt - 2]) ^ (p[i] - res[cnt - 1])) <= 0) cnt--;\n\t\tres[cnt++] = p[i];\n\t}\n\tlimit = cnt;\n\tfor(i = pnum - 2; i >= 0; i--)\n\t{\n\t\twhile(cnt > limit && sgn((res[cnt - 1] - res[cnt - 2]) ^ (p[i] - res[cnt - 1])) <= 0) cnt--;\n\t\tres[cnt++] = p[i];\n\t}\n\tres.resize(cnt);\n\treturn res;\n}\nbool onSeg(Point a, Point s, Point t)\n{\n\treturn sgn((a - s) ^ (a - t)) == 0 && sgn((a - s) * (a - t)) <= 0;\n}\n\nbool seg_seg_inter(Point a, Point b, Point s, Point t)\n{\n//\tLL c1 = (b - a) ^ (s - a), c2 = (b - a) ^ (t - a);\n//\tLL c3 = (t - s) ^ (a - s), c4 = (t - s) ^ (b - s);\n//\treturn (sgn(c1) * sgn(c2)) < 0 && (sgn(c3) * sgn(c4)) < 0;\n\treturn\n\t\tsgn((a - t) ^ (s - t)) * sgn((b - t) ^ (s - t)) < 0 &&\n\t\tsgn((s - b) ^ (a - b)) * sgn((t - b) ^ (a - b)) < 0;\n}\n\nLL area(Point a, vector<Point> p, int pnum)\n{\n\tLL res = 0;\n\tfor(int i = 0; i < pnum; i++)\n\t\tres += abs((p[i + 1] - p[i]) ^ (a - p[i]));\n\treturn abs(res);\n}\n\nbool convex_intersection()\n{\n\tint i, j;\n\tif(n == 0 || m == 0 || (n == 1 && m == 1))\n\t\treturn false;\n\tfor(i = 0; i < n; i++)\n\t\tfor(j = 0; j < m; j++)\n\t\t{\n\t\t\tif(seg_seg_inter(black[i], black[i + 1], white[j], white[j + 1])) return true;\n\t\t\tif(onSeg(black[i], white[j], white[j + 1])) return true;\n\t\t\tif(onSeg(white[j], black[i], black[i + 1])) return true;\n\t\t}\n\tif(n == 1)\n\t{\n\t\tfor(i = 0; i < m; i++)\n\t\t\tif(onSeg(black[0], white[i], white[i + 1]))\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\tif(m == 1)\n\t{\n\t\tfor(i = 0; i < n; i++)\n\t\t\tif(onSeg(white[0], black[i], black[i + 1]))\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n//\tcout << \"......\\n\";\n\tLL s = area(black[0], black, n);\n\t//cout << s << endl;\n\tif(s > 0)\n\t{\n\t\tfor(i = 0; i < m; i++)\n\t\t\tif(s == area(white[i], black, n))\n\t\t\t\treturn true;\n\t}\n\ts = area(white[0], white, m);\n\tif(s > 0)\n\t{\n\t\tfor(i = 0; i < n; i++)\n\t\t\tif(s == area(black[i], white, m))\n\t\t\t\treturn true;\n\t}\n\treturn false;\n}\nint main()\n{\n#ifdef ACM_TEST\n\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"in.txt\", \"w\", stdout);\n#endif\n\tint i, j;\n\tint x, y;\n\twhile(~scanf(\"%d%d\", &n, &m) && n + m)\n\t{\n\t\tblack.clear();\n\t\twhite.clear();\n\t\tfor(i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tblack.push_back(Point(x, y));\n\t\t}\n\t\tfor(i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\twhite.push_back(Point(x, y));\n\t\t}\n\t\tblack = get_convex_hull(black, n);\n\t\tn = black.size();\n\t\twhite = get_convex_hull(white, m);\n\t\tm = white.size();\n\t\tif(n > 1)n--;\n\t\telse black.push_back(black[0]);\n\t\tif(m > 1)m--;\n\t\telse white.push_back(white[0]);\n//\t\tcout << n << ' ' << m << endl;\n//\t\tfor(i = 0; i < n; i++)\n//\t\t\tprintf(\" (%lld, %lld) \", black[i].x, black[i].y);\n//\t\tputchar('\\n');\n//\t\tfor(i = 0; i < m; i++)\n//\t\t\tprintf(\" (%lld, %lld) \", white[i].x, white[i].y);\n//\t\tputchar('\\n');\n\t\tif(convex_intersection())\n\t\t\tprintf(\"NO\\n\");\n\t\telse\n\t\t\tprintf(\"YES\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\n#define wh while\n#define FOR(i, n) for(int i = 0; i < n; i++)\n#define REP(i,n) for(int i = 1; i <= n; i++)\n#define sf scanf\n#define pf printf\n#define PB(x) push_back(x)\n#define MP(x, y) make_pair(x, y)\n#define clr(abc,z) memset(abc,z,sizeof(abc))\n\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> pii;\n\nconst double PI = acos(-1.0);\n\n//蟆?ァ貞コヲ霓ャ蛹紋クコ蠑ァ蠎ヲ\ndouble torad(double deg) {\n    return deg/180 * PI;\n}\n//邊セ蠎ヲ\nconst double eps = 1e-10;\ndouble dcmp(double x) {\n    if(fabs(x) < eps) return 0;\n    else return x < 0 ? -1 : 1;\n}\n\nstruct Point {\n    double x, y;\n    Point(double x=0, double y=0):x(x),y(y) { }\n};\ntypedef Point Vector;\nVector operator + (const Vector& A, const Vector& B) {\n    return Vector(A.x+B.x, A.y+B.y);\n}\nVector operator - (const Point& A, const Point& B) {\n    return Vector(A.x-B.x, A.y-B.y);\n}\nVector operator * (const Vector& A, double p) {\n    return Vector(A.x*p, A.y*p);\n}\n\n\n//霑吩ク?摎譏ッ荳?ウサ蛻怜渕遑?桃菴?double Dot(const Vector& A, const Vector& B) {\n    return A.x*B.x + A.y*B.y;\n}\ndouble Cross(const Vector& A, const Vector& B) {\n    return A.x*B.y - A.y*B.x;\n}\nbool operator < (const Point& p1, const Point& p2) {\n    return p1.x < p2.x || (p1.x == p2.x && p1.y < p2.y);\n}\nbool operator == (const Point& p1, const Point& p2) {\n    return p1.x == p2.x && p1.y == p2.y;\n}\nvector<Point> ConvexHull(vector<Point> p) {//豎る?譌カ髓亥?蛹?    sort(p.begin(), p.end()); // 鬚?、?炊?悟唖髯、驥榊、咲せ\n    p.erase(unique(p.begin(), p.end()), p.end());\n\n    int n = p.size();\n    int m = 0;\n    vector<Point> ch(n+1);\n    for(int i = 0; i < n; i++) {\n        while(m > 1 && Cross(ch[m-1]-ch[m-2], p[i]-ch[m-2]) <= 0) m--;\n        ch[m++] = p[i];\n    }\n    int k = m;\n    for(int i = n-2; i >= 0; i--) {\n        while(m > k && Cross(ch[m-1]-ch[m-2], p[i]-ch[m-2]) <= 0) m--;\n        ch[m++] = p[i];\n    }\n    if(n > 1) m--;\n    ch.resize(m);\n    return ch;\n}\nPoint GetLineIntersection(const Point& P, const Vector& v, const Point& Q, const Vector& w) {\n    Vector u = P-Q;\n    double t = Cross(w, u) / Cross(v, w);\n    return P+v*t;\n}\n\nbool SegmentProperIntersection(const Point& a1, const Point& a2, const Point& b1, const Point& b2) {\n    double c1 = Cross(a2-a1,b1-a1), c2 = Cross(a2-a1,b2-a1),\n           c3 = Cross(b2-b1,a1-b1), c4=Cross(b2-b1,a2-b1);\n    return dcmp(c1)*dcmp(c2)<0 && dcmp(c3)*dcmp(c4)<0;\n}\n\nbool OnSegment(const Point& p, const Point& a1, const Point& a2) {\n    return dcmp(Cross(a1-p, a2-p)) == 0 && dcmp(Dot(a1-p, a2-p)) < 0;\n}\nint IsPointInPolygon(const Point& p, const vector<Point>& poly) {\n    int wn = 0;\n    int n = poly.size();\n    for(int i = 0; i < n; i++) {\n        const Point& p1 = poly[i];\n        const Point& p2 = poly[(i+1)%n];\n        if(p1 == p || p2 == p || OnSegment(p, p1, p2)) return -1; // 蝨ィ霎ケ逡御ク?        int k = dcmp(Cross(p2-p1, p-p1));\n        int d1 = dcmp(p1.y - p.y);\n        int d2 = dcmp(p2.y - p.y);\n        if(k > 0 && d1 <= 0 && d2 > 0) wn++;\n        if(k < 0 && d2 <= 0 && d1 > 0) wn--;\n    }\n    if (wn != 0) return 1; // 蜀?Κ\n    return 0; // 螟夜Κ\n}\nbool ConvexPolygonDisjoint(const vector<Point> ch1, const vector<Point> ch2) {\n    int c1 = ch1.size();\n    int c2 = ch2.size();\n    for(int i = 0; i < c1; i++)\n        if(IsPointInPolygon(ch1[i], ch2) != 0) return false; // 蜀?Κ謌冶セケ逡御ク?    for(int i = 0; i < c2; i++)\n        if(IsPointInPolygon(ch2[i], ch1) != 0) return false; // 蜀?Κ謌冶セケ逡御ク?    for(int i = 0; i < c1; i++)\n        for(int j = 0; j < c2; j++)\n            if(SegmentProperIntersection(ch1[i], ch1[(i+1)%c1], ch2[j], ch2[(j+1)%c2])) return false;\n    return true;\n}\nint n, m;\n\nint main() {\n    wh(sf(\"%d%d\", &n, &m) != EOF) {\n        if(!n && !m) break;\n        vector<Point> t_x, t_y;\n        t_x.clear();\n        t_y.clear();\n        FOR(i, n) {\n            int x, y;\n            sf(\"%d%d\", &x, &y);\n            t_x.PB(Point((double)x, (double)y));\n        }\n        FOR(i, m) {\n            int x, y;\n            sf(\"%d%d\", &x, &y);\n            t_y.PB(Point((double)x, (double)y));\n        }\n        t_x = ConvexHull(t_x);\n        t_y = ConvexHull(t_y);\n        if(ConvexPolygonDisjoint(t_x, t_y)) puts(\"YES\");\n        else puts(\"NO\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//??????????????????????????????\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\nusing namespace std;\ntypedef complex<double> Point;\n\nnamespace std {\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(Point &u, Point &v) {\n\treturn u.real() * v.imag() - u.imag() * v.real();\n}\n\ndouble dot(Point &u, Point &v) {\n\treturn u.real() * v.real() + u.imag() * v.imag();\n}\n\n//Define : e_Re(???), e_Im(???)\n//a -> b -> counter clockwise -> c ???  1\n//a -> b -> clockwise -> c         ??? -1\n//c--a--b  ???  2\n//a--b--c  ??? -2\n//a--b(=c) ???  0\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0) return 1;\n\tif (cross(b, c) < 0) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\n//counter clockwise, ring buffer(ch[0] == ch[last])\nvector<Point> convex_hull(vector<Point> points) {\n\tint n = points.size();\n\tint k = 0;\n\tvector<Point> ch(2 * n);\n\t\n\tsort(points.begin(), points.end());\n\t\n\t//lower hull\n\tfor (int i = 0; i < n; i++) {\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], points[i]) <= 0) k--;\n\t\tch[k] = points[i];\n\t\tk++;\n\t}\n\t\n\t//upper hull\n\tint low_k = k;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\twhile (k > low_k && ccw(ch[k - 2], ch[k - 1], points[i]) <= 0) k--;\n\t\tch[k] = points[i];\n\t\tk++;\n\t}\n\tch.resize(k);\n\treturn ch;\n}\n\n//If line (a->b), (c->d) are hit with a point, return true.\nbool is_hit_line(Point a, Point b, Point c, Point d) {\n\tdouble u = cross(b - a, c - a) * cross(b - a, d - a);\n\tdouble v = cross(d - c, a - c) * cross(d - c, b - c);\n\tif (u > 0 || v > 0) return false;\n\tif (u != 0 || v != 0) return true;\n\t\n\tif (b < a) swap(a, b);\n\tif (d < c) swap(c, d);\n\t\n\tdouble eps = 1e-10;\n\tif (abs(d - a) + eps > abs(b - a) + abs(d - c)) return false;\n\treturn true;\n}\n\n//poly1, poly2 is convex polygon.\nbool is_hit(vector<Point> poly1, vector<Point> poly2) {\n\tfor (int i = 0; i < (int)poly1.size() - 1; i++) {\n\t\tfor (int j = 0; j < (int)poly2.size() - 1; j++) {\n\t\t\tif (is_hit_line(poly1[i], poly1[i + 1], poly2[j], poly2[j + 1])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nbool is_cover(vector<Point> poly, Point point) {\n\tbool in = false;\n\tfor (int i = 0; i < (int)poly.size() - 1; i++) {\n\t\tPoint a = poly[i] - point;\n\t\tPoint b = poly[i + 1] - point;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b)) if (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return false;\t//on poly\n\t}\n\treturn in;\n}\n\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m) {\n\t\tif (!n) break;\n\t\t\n\t\tvector<Point> poly1, poly2;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpoly1.push_back(Point((double)x, (double)y));\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpoly2.push_back(Point((double)x, (double)y));\n\t\t}\n\t\tpoly1 = convex_hull(poly1);\n\t\tpoly2 = convex_hull(poly2);\n\t\t\n\t\tif (is_hit(poly1, poly2) || is_cover(poly1, poly2[0]) || is_cover(poly2, poly1[0])) { cout << \"NO\" << endl; }\n\t\telse { cout << \"YES\" << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle(Point a, ld b) :p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tld r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2, 0)*projection(l, p) - p;\n}\n\nld dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tld a = cross(s.b - s.a, t.b - t.a);\n\tld b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tld dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tld d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tld d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tld len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\nPolygon convex_hull(Polygon s)\n{\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(ALL(s));\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\tFOR(i, 2, s.size())\n\t{\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != -1; n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\tfor (int i = s.size() - 3; i >= 0; i--)\n\t{\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != -1; n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\nint contains(Polygon g, Point p)\n{\n\tbool f = false;\n\tREP(i, g.size())\n\t{\n\t\tPoint a = g[i] - p, b = g[(i + 1) % g.size()] - p;\n\t\tif (abs(cross(a, b)) < EPS&&dot(a, b) < EPS) return 0; //ON\n\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\tif (a.imag() < EPS&&b.imag() > EPS&&cross(a, b) > EPS) f = !f;\n\t}\n\tif (f) return 1; //IN\n\telse return -1; //OUT\n}\n\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n) {\n\t\tPolygon b, w;\n\t\tREP(i, n)\n\t\t{\n\t\t\tld x, y; cin >> x >> y;\n\t\t\tb.emplace_back(x, y);\n\t\t}\n\t\tREP(i, m)\n\t\t{\n\t\t\tld x, y; cin >> x >> y;\n\t\t\tw.emplace_back(x, y);\n\t\t}\n\t\tPolygon chb = convex_hull(b);\n\t\tPolygon chw = convex_hull(w);\n\t\tif (n == 1 && m == 1)\n\t\t{\n\t\t\tputs(\"YES\");\n\t\t}\n\t\telse if(n==1&&m==2)\n\t\t{\n\t\t\tLine l(w[0], w[1]);\n\t\t\tputs(isis_sp(l, b[0]) ? \"NO\" : \"YES\");\n\t\t}\n\t\telse if (n == 2 && m == 1)\n\t\t{\n\t\t\tLine l(b[0], b[1]);\n\t\t\tputs(isis_sp(l, w[0]) ? \"NO\" : \"YES\");\n\t\t}\n\t\telse if (n == 2 && m == 2)\n\t\t{\n\t\t\tLine l1(w[0], w[1]);\n\t\t\tLine l2(b[0], b[1]);\n\t\t\tputs(isis_ss(l1, l2) ? \"NO\" : \"YES\");\n\t\t}\n\t\telse {\n\t\t\tbool f = true;\n\t\t\tREP(i, chb.size())\n\t\t\t{\n\t\t\t\tif (contains(chw, chb[i]) != -1) f = false;\n\t\t\t}\n\t\t\tREP(i, chw.size())\n\t\t\t{\n\t\t\t\tif (contains(chb, chw[i]) != -1) f = false;\n\t\t\t}\n\t\t\tputs(f ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst double eps = 1e-10;\nint dcmp(double x)\n{\n    if(fabs(x) < eps) return 0;\n    return x>0? 1: -1;\n}\nstruct Point\n{\n    double x,y;\n    Point (double x=0, double y=0) :x(x),y(y) {}\n    void show() { cout<<\"(\"<<x<<\",\"<<y<<\")\"<<endl; }\n};\nbool operator<(const Point A,const Point B){\n    return A.x < B.x || (A.x == B.x && A.y < B.y);\n}\ntypedef Point Vector;\nvoid readPoint(Point &a){//霎灘?荳?クェ轤ケ\n    cin>>a.x>>a.y;\n}\nVector operator - ( Point A, Point B) { return Vector(A.x-B.x, A.y-B.y); }\ndouble Cross(Vector A, Vector B) { return A.x*B.y - B.x*A.y; }\nint ConvexHull ( Point* p, int n, Point* ch)\n{\n    sort(p, p+n);\n    int m = 0;\n    for(int i = 0; i<n; i++)\n    {\n        while(m > 1 && Cross( ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0) m--;\n        ch[m++] = p[i];\n    }\n    int k = m;\n    for(int i = n-2; i>=0; i--)\n    {\n        while(m > k && Cross( ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0) m--;\n        ch[m++] = p[i];\n    }\n    ///霑倩ヲ∵隼荳?ク狗函謌仙、夊セケ蠖「縲?    ch[m++] = ch[0];\n    if(n > 1) m--;\n    return m;\n}\nint n,m,nb,nw;\nPoint black[120],cb[120],white[120],cw[120];\nvoid reset()\n{\n    memset(black,0,sizeof(black));\n    memset(white,0,sizeof(white));\n    memset(cw,0,sizeof(cw));\n    memset(cb,0,sizeof(cb));\n}\nbool SideCross(Point a1, Point a2, Point b1, Point b2)\n{\n    double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1),\n    c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1);\n    return dcmp(c1)*dcmp(c2)<0 && dcmp(c3)*dcmp(c4)<0;\n}\nbool pInConvex(Point a, Point* ch, int n)\n{\n    int i;\n    if(n==3)\n    {\n        if(a.x < min(ch[0].x, ch[1].x) || a.x > max(ch[0].x, ch[1].x)) return 0;\n        if(a.y < min(ch[0].y, ch[1].y) || a.y > max(ch[0].y, ch[1].y)) return 0;\n    }\n    for(i=1;i<n;i++)\n    {\n        if(Cross( ch[i]-ch[i-1], a-ch[i-1] ) < 0 ) return 0;\n    }\n    return 1;\n}\nint solve()\n{\n    int i,j;\n    if(n==1&&m==1) return 1;\n    else if(n==1)\n    {\n        ///謇セ逋ス蟄仙?蛹?、夊セケ蠖「縲ょ愛譁ュ霑吩クェ鮟大ュ先弍蜷ヲ蝨ィ逋ス蛹??\n        nw=ConvexHull(white, m, cw);\n        if(pInConvex(black[0], cw, nw)) return 0;\n    }\n    else if(m==1)\n    {\n        ///謇セ鮟大ュ仙?蛹?、夊セケ蠖「縲ょ愛譁ュ霑吩クェ逋ス蟄先弍蜷ヲ蝨ィ鮟大桁蜀?        nb=ConvexHull(black, n, cb);\n        if(pInConvex(white[0], cb, nb)) return 0;\n    }\n    else\n    {\n        ///謇セ鮟醍區蜃ク蛹?、夊セケ蠖「縲ょ愛譁ュ譏ッ蜷ヲ譛臥コソ谿オ逶ク莠、謌也せ蝨ィ蜿ヲ荳?クェ蜃ク蛹??縲?        nb=ConvexHull(black, n, cb);\n        nw=ConvexHull(white, m, cw);\n        for(i=1;i<nb;i++)\n        {\n            for(j=1;j<nw;j++)\n                if(SideCross( cb[i], cb[i-1], cw[j] ,cw[j-1] )) return 0;\n        }\n        for(i=0;i<n;i++)\n            if(pInConvex(black[i], cw, nw)) return 0;\n        for(i=0;i<m;i++)\n            if(pInConvex(white[i], cb, nb)) return 0;\n    }\n    return 1;\n}\nint main(){\n    int i,tx,ty;\n    while(cin>>n>>m,n||m){\n        reset();\n        for(i=0;i<n;i++){\n            cin>>tx>>ty;\n            black[i]=Point(tx,ty);\n        }\n        for(i=0;i<m;i++){\n            cin>>tx>>ty;\n            white[i]=Point(tx,ty);\n        }\n        int ans=solve();\n        if(ans)\n            cout<<\"YES\"<<endl;\n        else\n            cout<<\"NO\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  int b, w;\n  while(cin>>b>>w && (b != 0 || w != 0)){\n    srand(time(NULL));\n    vector<double> x1(b), y1(b);\n    vector<double> x2(w), y2(w);\n    REP(i, b)cin>>x1[i]>>y1[i];\n    REP(i, w)cin>>x2[i]>>y2[i];\n    bool ans = false;\n    REP(time, 10000 * 3){\n      const double D = 1e6;\n      double t = (double)rand()/RAND_MAX * D * ((rand() % 2) ?  1 : -1);\n      double min_b = 1e30, max_b = -1e30;\n      double min_w = 1e30, max_w = -1e30;\n      REP(i, b){\n        double d = (y1[i] + t)/x1[i];\n        min_b = min(min_b, d);\n        max_b = max(max_b, d);\n      }\n      REP(i, w){\n        double d = (y2[i] + t)/x2[i];\n        min_w = min(min_w, d);\n        max_w = max(max_w, d);\n      }\n      if(min_w > max_b) ans = true;\n      if(min_b > max_w) ans = true;\n      if(ans) break;\n    }\n    if(ans) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\ntypedef long long ll;\n\n// long long\nstruct P{\n    P(){}\n    P(ll _r, ll _i):r(_r), i(_i){}\n    void real(const ll& v){r = v;}\n    void imag(const ll& v){i = v;}\n    ll r, i;\n};\n\nll real(const P& p){return p.r;}\nll imag(const P& p){return p.i;}\nll norm(const P& p){ll r = real(p), i = imag(p); return r * r + i * i;}\n\nP operator+(const P& lhs, const P& rhs){\n    return P(real(lhs)+real(rhs), imag(lhs)+imag(rhs));\n}\nP operator-(const P& lhs, const P& rhs){\n    return P(real(lhs)-real(rhs), imag(lhs)-imag(rhs));\n}\nP operator-(const P& p){\n    return P(-real(p), -imag(p));\n}\nbool operator>(const P& lhs, const P& rhs){\n    if(imag(lhs) - imag(rhs)){return imag(lhs) > imag(rhs);}\n    return real(lhs) > real(rhs);\n}\nbool operator<(const P& lhs, const P& rhs){\n    if(imag(lhs) - imag(rhs)){return imag(lhs) < imag(rhs);}\n    return real(lhs) < real(rhs);    \n}\n\nll cross(const P& lhs, const P& rhs){\n    return real(lhs)*imag(rhs) - imag(lhs)*real(rhs);\n}\n\nll dot(const P& lhs, const P& rhs){\n    return real(lhs)*real(rhs) + imag(lhs)*imag(rhs);\n}\n\nint ccw(P a, P b, P c){\n    b = b - a; c = c - a;\n    if(cross(b, c) > 0)return 1; // counter clock wise\n    if(cross(b, c) < 0)return -1; // clock wise\n    if(dot(b, c) < 0)return 2; // B A C\n    if(norm(b) < norm(c))return -2; // A B C\n    return 0; // A C B\n}\n\n// Convex-Hull\nstd::vector<P> convex_hull(std::vector<P>& ps){\n    int n = ps.size(), k = 0;\n    std::sort(ps.begin(), ps.end());\n    \n    std::vector<P> ch(2*n);\n    for(int i=0;i<n;ch[k++]=ps[i++]){ // ???\n        while(k>=2&&ccw(ch[k-2], ch[k-1], ps[i])<=0){--k;} // ???????¨?????????????????????´\n    }\n    for(int i=n-2, t=k+1;i>=0;ch[k++]=ps[i--]){ // ???\n        while(k>=t&&ccw(ch[k-2], ch[k-1], ps[i])<=0){--k;}\n    }\n    \n    ch.resize(k-1); // ?????????????????¨???(????????¨??????)??????????????????\n    return ch;\n}\n\nbool isIn(const P& p, const std::vector<P>& polygon){\n    bool in = false;\n    int V = polygon.size();\n    for(int i=0;i<V;i++){\n        P p1 = polygon[i] - p, p2 = polygon[(i+1)%V] - p;\n        if(imag(p1) > imag(p2)){std::swap(p1, p2);}\n        if(imag(p1) <= 0 && 0 < imag(p2) && cross(p1, p2) > 0){\n            in = !in;\n        }\n        if(cross(p1, p2) == 0 && dot(p1, p2) <= 0){\n            return true;\n        }\n    }\n    return in;\n}\n\nbool areIntersectedLines(const P& p1, const P& p2, const P& q1, const P& q2){\n    if(cross(p1-p2, q1-p2) == 0 && dot(p1-p2, q1-p2) > 0 &&\n       0 <= norm(q1-p2) && norm(q1-p2) <= norm(p1-p2)){\n        return true;\n    }\n    if(cross(p1-p2, q2-p2) == 0 && dot(p1-p2, q2-p2) > 0 &&\n       0 <= norm(q2-p2) && norm(q2-p2) <= norm(p1-p2)){\n        return true;\n    }\n    if(cross(q1-q2, p1-q2) == 0 && dot(q1-q2, p1-q2) > 0 &&\n       0 <= norm(p1-q2) && norm(p1-q2) <= norm(q1-q2)){\n        return true;\n    }\n    if(cross(q1-q2, p2-q2) == 0 && dot(q1-q2, p2-q2) > 0 &&\n       0 <= norm(p2-q2) && norm(p2-q2) <= norm(q1-q2)){\n        return true;\n    }\n\n    return (cross(p1-p2, q1-p2) * cross(p1-p2, q2-p2) < 0) &&\n        (cross(q1-q2, p1-q2) * cross(q1-q2, p2-q2) < 0);\n}\n\nint N, M;\nstd::vector<P> bs, ws;\n\nint main(){\n    while(scanf(\"%d %d\", &N, &M), N || M){\n        bs.resize(N);\n        ws.resize(M);\n        \n        for(int i=0;i<N;i++){\n            ll x, y;\n            scanf(\"%lld %lld\", &x, &y);\n\n            bs[i].real(x);\n            bs[i].imag(y);\n        }\n        for(int i=0;i<M;i++){\n            ll x, y;\n            scanf(\"%lld %lld\", &x, &y);\n\n            ws[i].real(x);\n            ws[i].imag(y);        \n        }\n\n        if(N == 1 && M == 1){\n            puts(\"YES\");\n            continue;\n        }\n\n        if(N < M){std::swap(bs, ws); std::swap(N, M);}\n\n        if(N == 2){\n            if(M == 1){\n                puts(ccw(bs[0], bs[1], ws[0]) ? \"YES\" : \"NO\");\n                continue;\n            }else{\n                puts(!areIntersectedLines(bs[0], bs[1], ws[0], ws[1]) ? \"YES\" : \"NO\");\n                continue;\n            }\n        }\n        \n        std::vector<P> ch = convex_hull(bs);\n\n        bool res = true;\n        for(int i=0;i<M;i++){\n            if(isIn(ws[i], ch)){res = false; break;}\n        }\n\n        if(M >= 3){\n            ch = convex_hull(ws);\n\n            for(int i=0;i<N;i++){\n                if(isIn(bs[i], ch)){res = false; break;}\n            }\n        }\n\n        puts(res ? \"YES\" : \"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define x first\n#define y second\n\nconst int INF = 19191919;\n\nusing Point = pair<int,int>;\n\nbool solve(int n, int m){\n    vector<Point> b(n),w(m);\n    rep(i,n) cin >>b[i].x >>b[i].y;\n    rep(i,m) cin >>w[i].x >>w[i].y;\n\n    rep(i,n)rep(j,m){\n        int A = w[j].y - b[i].y;\n        int B = b[i].x - w[j].x;\n        int C = b[i].y*w[j].x - b[i].x*w[j].y;\n\n        bool ok = true;\n        vector<pair<Point,int>> on_line;\n\n        int bp = 0, bm = 0;\n        rep(k,n){\n            int v = A*b[k].x + B*b[k].y + C;\n\n            if(v>0) ++bp;\n            else if(v<0) ++bm;\n            else on_line.pb({b[k],0});\n        }\n\n        int wp = 0 , wm = 0;\n        rep(k,m){\n            int v = A*w[k].x + B*w[k].y + C;\n\n            if(v>0) ++wp;\n            else if(v<0) ++wm;\n            else on_line.pb({w[k],1});\n        }\n\n        if(bp>0 && bm>0) ok = false;\n        if(wp>0 && wm>0) ok = false;\n        if(bp>0 && wp>0) ok = false;\n        if(bm>0 && wm>0) ok = false;\n\n        if(!ok) continue;\n\n        sort(all(on_line));\n        int sz = on_line.size();\n        int ch = 0;\n        rep(k,sz-1) ch += (on_line[k].second != on_line[k+1].second);\n\n        if(ch>1) ok = false;\n        if(ok) return true;\n    }\n\n    return false;\n}\n\nint main(){\n    int n,m;\n    while(cin >>n >>m,n) cout << (solve(n,m)?\"YES\":\"NO\") << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n \nusing namespace std;\n \n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n \nstruct Point{\n  double x,y;\n \n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n \n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n  Point operator / (const double &k)const{ return Point(x/k,y/k); }\n  bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n \ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\n \nistream &operator >> (istream &is,Point &p){\n  return is >> p.x >> p.y;\n}\n \n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n \nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS){ return COUNTER_CLOCKWISE; }\n  if(cross(a,b) < -EPS){ return CLOCKWISE; }\n  if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n  if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n  return ON_SEGMENT;\n}\n \nstruct Segment{\n  Point s,t;\n  Segment(){}\n  Segment(Point s,Point t) : s(s),t(t) {}\n};\n \nbool isIntersectSP(const Segment &s,const Point &p){\n  return equal(ccw(s.s,s.t,p),0);\n}\n \nbool isIntersectSS(const Segment &a,const Segment &b){\n  Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0\n    && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n \n#define prev(G,i) (G[(i-1+G.size())%G.size()])\n#define curr(G,i) (G[i%G.size()])\n#define next(G,i) (G[(i+1)%G.size()])\ntypedef vector<Point> Polygon;\n \nbool check(const Polygon &pg,const Point &p){\n  int N = pg.size();\n  bool in = false;\n  for(int i = 0 ; i < N ; i++){\n    Point a = curr(pg,i)-p, b = next(pg,i)-p;\n    if(a.y > b.y){ swap(a,b); }\n    if(a.y <= 0 && 0 < b.y && cross(a,b) > 0){ in = !in; }\n    if(cross(a,b) == 0 && dot(a,b) <= 0){ return true; }\n  }\n  return in;\n}\n \nbool solve(Polygon &bp,Polygon &wp){\n  int N = bp.size(), M = wp.size();\n  if(N == 1 && M == 1){\n    return !(equal(bp[0].x,wp[0].x) && equal(bp[0].y,wp[0].y));\n  }\n  if(N == 2 && M == 1){\n    Segment s(bp[0],bp[1]);\n    return !isIntersectSP(s,wp[0]);\n  }\n  if(N == 1 && M == 2){\n    Segment s(wp[0],wp[1]);\n    return !isIntersectSP(s,bp[0]);\n  }\n  if(N == 2 && M == 2){\n    Segment s1(bp[0],bp[1]),s2(wp[0],wp[1]);\n    return !isIntersectSS(s1,s2);\n  }\n  if(N == 1 && M >= 3){\n    return !check(wp,bp[0]);\n  }\n  if(N >= 3 && M == 1){\n    return !check(bp,wp[0]);\n  }\n  if(N == 2 && M >= 3){\n    Segment s1(bp[0],bp[1]);\n    if(check(wp,bp[0]) || check(wp,bp[1])){\n      return false;\n    }\n    for(int i = 0 ; i < M ; i++){\n      for(int j = i+1 ; j < M ; j++){\n        Segment s2(wp[i],wp[j]);\n        if(isIntersectSS(s1,s2)){\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  if(N >= 3 && M == 2){\n    Segment s1(wp[0],wp[1]);\n    if(check(bp,wp[0]) || check(bp,wp[1])){\n      return false;\n    }\n    for(int i = 0 ; i < N ; i++){\n      for(int j = i+1 ; j < N ; j++){\n        Segment s2(bp[i],bp[j]);\n        if(isIntersectSS(s1,s2)){\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  for(int i = 0 ; i < N ; i++){\n    if(check(wp,bp[i])){\n      return false;\n    }\n  }\n  for(int i = 0 ; i < M ; i++){\n    if(check(bp,wp[i])){\n      return false;\n    }\n  }\n  return true;\n}\n \nint main(){\n  int N,M;\n  while(cin >> N >> M,N){\n    Polygon bp(N),wp(M);\n    for(int i = 0 ; i < N ; i++){\n      cin >> bp[i];\n    }\n    for(int i = 0 ; i < M ; i++){\n      cin >> wp[i];\n    }\n    sort(bp.begin(),bp.end());\n    sort(wp.begin(),wp.end());\n    cout << (solve(bp,wp) ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<stack>\n#include<vector>\n#include<queue>\n#include<string>\n#include<sstream>\n#define eps 1e-9\n#define ALL(x) x.begin(),x.end()\n#define INS(x) inserter(x,x.begin())\n#define FOR(i,j,k) for(int i=j;i<=k;i++)\n#define MAXN 105\n#define MAXM 40005\n#define INF 0x3fffffff\nusing namespace std;\ntypedef long long LL;\nstruct Point\n{\n    double x, y;\n    Point(double x=0, double y=0) :x(x),y(y) {}\n};\ntypedef Point Vector;\n\nPoint read_point(void)\n{\n    double x, y;\n    scanf(\"%lf%lf\", &x, &y);\n    return Point(x, y);\n}\n\nconst double EPS = 1e-10;\n\nVector operator + (Vector A, Vector B)    { return Vector(A.x + B.x, A.y + B.y); }\n\nVector operator - (Vector A, Vector B)    { return Vector(A.x - B.x, A.y - B.y); }\n\nVector operator * (Vector A, double p)    { return Vector(A.x*p, A.y*p); }\n\nVector operator / (Vector A, double p)    { return Vector(A.x/p, A.y/p); }\n\nbool operator < (const Point& a, const Point& b)\n{ return a.x < b.x || (a.x == b.x && a.y < b.y); }\n\nint dcmp(double x)\n{ if(fabs(x) < EPS) return 0; else return x < 0 ? -1 : 1; }\n\nbool operator == (const Point& a, const Point& b)\n{ return dcmp(a.x-b.x) == 0 && dcmp(a.y-b.y) == 0; }\n\ndouble Dot(Vector A, Vector B)\n{ return A.x*B.x + A.y*B.y; }\n\ndouble Length(Vector A)    { return sqrt(Dot(A, A)); }\n\n\ndouble Angle(Vector A, Vector B)\n{ return acos(Dot(A, B) / Length(A) / Length(B)); }\n\n\ndouble Cross(Vector A, Vector B)\n{ return A.x*B.y - A.y*B.x; }\n\n\ndouble Area2(Point A, Point B, Point C)\n{ return Cross(B-A, C-A); }\n\n\nVector VRotate(Vector A, double rad)\n{\n    return Vector(A.x*cos(rad) - A.y*sin(rad), A.x*sin(rad) + A.y*cos(rad));\n}\n\n\nPoint PRotate(Point A, Point B, double rad)\n{\n    return A + VRotate(B-A, rad);\n}\n\n\nVector Normal(Vector A)\n{\n    double l = Length(A);\n    return Vector(-A.y/l, A.x/l);\n}\n\n\nPoint GetLineIntersection(Point P, Vector v, Point Q, Vector w)\n{\n    Vector u = P - Q;\n    double t = Cross(w, u) / Cross(v, w);\n    return P + v*t;\n}\n\ndouble DistanceToLine(Point P, Point A, Point B)\n{\n    Vector v1 = B - A, v2 = P - A;\n    return fabs(Cross(v1, v2)) / Length(v1);\n}\n\n\ndouble DistanceToSegment(Point P, Point A, Point B)\n{\n    if(A == B)    return Length(P - A);\n    Vector v1 = B - A, v2 = P - A, v3 = P - B;\n    if(dcmp(Dot(v1, v2)) < 0)    return Length(v2);\n    else if(dcmp(Dot(v1, v3)) > 0)    return Length(v3);\n    else return fabs(Cross(v1, v2)) / Length(v1);\n}\n\n\nPoint GetLineProjection(Point P, Point A, Point B)\n{\n    Vector v = B - A;\n    return A + v * (Dot(v, P - A) / Dot(v, v));\n}\n\n\nbool SegmentProperIntersection(Point a1, Point a2, Point b1, Point b2)\n{\n    double c1 = Cross(a2-a1, b1-a1), c2 = Cross(a2-a1, b2-a1);\n    double c3 = Cross(b2-b1, a1-b1), c4 = Cross(b2-b1, a2-b1);\n    return dcmp(c1)*dcmp(c2)<0 && dcmp(c3)*dcmp(c4)<0;\n}\n\n\nbool OnSegment(Point P, Point a1, Point a2)\n{\n    Vector v1 = a1 - P, v2 = a2 - P;\n    return dcmp(Cross(v1, v2)) == 0 && dcmp(Dot(v1, v2)) < 0;\n}\n\n\ndouble PolygonArea(Point* P, int n)\n{\n    double ans = 0.0;\n    for(int i = 1; i < n - 1; ++i)\n        ans += Cross(P[i]-P[0], P[i+1]-P[0]);\n    return ans/2;\n}\n\nconst double PI = acos(-1.0);\nstruct Line\n{\n    Point p;\n    Vector v;\n    double ang;\n    Line()    { }\n    Line(Point p, Vector v): p(p), v(v)    { ang = atan2(v.y, v.x); }\n    Point point(double t)\n    {\n        return p + v*t;\n    }\n    bool operator < (const Line& L) const\n    {\n        return ang < L.ang;\n    }\n};\n\n\nint isPointInPolygon(Point P, Point* Poly, int n)\n{\n    int wn;\n    for(int i = 0; i < n; ++i)\n    {\n        if(OnSegment(P, Poly[i], Poly[(i+1)%n]))    return -1; \n        int k = dcmp(Cross(Poly[(i+1)%n] - Poly[i], P - Poly[i]));\n        int d1 = dcmp(Poly[i].y - P.y);\n        int d2 = dcmp(Poly[(i+1)%n].y - P.y);\n        if(k > 0 && d1 <= 0 && d2 > 0)    wn++;\n        if(k < 0 && d2 <= 0 && d1 > 0)    wn--;\n    }\n    if(wn != 0)  return 1;\n    return 0;\n}\n\nint ConvexHull(Point* p, int n, Point* ch)\n{\n    sort(p, p +n);\n    int m = 0;\n    for(int i = 0; i < n; ++i)\n    {\n        while(m > 1 && Cross(ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0)    m--;\n        ch[m++] = p[i];\n    }\n    int k = m;\n    for(int i = n-2; i >= 0; --i)\n    {\n        while(m > k && Cross(ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0)    m--;\n        ch[m++] = p[i];\n    }\n    if(n > 1)    m--;\n    return m;\n}\n\nbool ConvexHullIntersection(Point *ch1,int t1,Point *ch2,int t2)\n{\n    double angle[MAXN],x;\n    int i,j,k,m;\n    if(t1==1)return true;\n    if(t1==2)\n    {\n        for(i=0;i<t2;i++)\n        {\n            k=dcmp(Cross(ch1[1]-ch1[0],ch2[i]-ch1[0]));\n            if(k==0&&Dot(ch1[1]-ch1[0],ch2[i]-ch1[0])>0)\n            {\n                if(Length(ch2[i]-ch1[0])<Length(ch1[1]-ch1[0]))break;\n            }\n        }\n        if(i<t2)return false;\n        if(t2==2&&SegmentProperIntersection(ch1[0],ch1[1],ch2[0],ch2[1]))return false;\n        return true;\n    }\n\n    angle[0]=0;\n    for(i=2;i<t1;i++)\n    angle[i-1]=Angle(ch1[1]-ch1[0],ch1[i]-ch1[0]);\n    for(i=0;i<t2;i++)\n    {\n        j=dcmp(Cross(ch1[1]-ch1[0],ch2[i]-ch1[0]));\n        if(j<0||(j==0&&Dot(ch1[1]-ch1[0],ch2[i]-ch1[0])<0))continue;\n        j=dcmp(Cross(ch1[t1-1]-ch1[0],ch2[i]-ch1[0]));\n        if(j>0||(j==0&&Dot(ch1[t1-1]-ch1[0],ch2[i]-ch1[0])<0))continue;\n        x=Angle(ch1[1]-ch1[0],ch2[i]-ch1[0]);\n        m=lower_bound(angle,angle+t1-1,x)-angle;\n        if(m==0)j=0;\n        else j=m-1;\n        k=dcmp(Cross(ch1[j+1]-ch2[i],ch1[j+2]-ch2[i]));\n        if(k>=0)break;\n    }\n    if(i<t2)return false;\n    return true;\n}\n\n\n\nint i,j,k,n,m,x,y,T,ans,big,cas,num,len;\nbool flag;\nPoint a[105],b[105],cha[105],chb[105];\n\nint main()\n{\n\twhile (scanf(\"%d%d\",&n,&m),n+m)\n\t{\n\t\t\n\t\t\n\t\tfor (i=0;i<n;i++)\n\t\t{\n\t\t\tscanf(\"%lf%lf\",&a[i].x,&a[i].y);\n\t\t}\n\t\t\n\t\tint as=ConvexHull(a,n,cha); \n\t\t\n\t\tfor (i=0;i<m;i++)\n\t\t{\n\t\t\tscanf(\"%lf%lf\",&b[i].x,&b[i].y);\n\t\t}\n\t\t\n\t\t\n\t\tint bs=ConvexHull(b,m,chb); \n\t\t\n\t\tif (ConvexHullIntersection(cha,n,chb,m)&&ConvexHullIntersection(chb,m,cha,n)) printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\");\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nlong double EPS = (long double)1e-6;\nstruct Point { long double px, py; };\nPoint r1[100], r2[100]; int n, m;\nvector<pair<Point, int>>vec, vec2;\nbool solve(Point a1, Point a2) {\n\tif (a1.px > a2.px)swap(a1, a2);\n\tif (a1.px == a2.px) {\n\t\tint colour = 0;\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tif (colour == 0) {\n\t\t\t\tif (vec2[i].first.px < a1.px) { colour = 3 - vec2[i].second; }\n\t\t\t\tif (vec2[i].first.px == a1.px) { return false; }\n\t\t\t\tif (vec2[i].first.px > a1.px) { colour = vec2[i].second; }\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (colour != 3 - vec2[i].second && vec2[i].first.px < a1.px) { return false; }\n\t\t\t\tif (vec2[i].first.px == a1.px) { return false; }\n\t\t\t\tif (colour != vec2[i].second && vec2[i].first.px > a1.px) { return false; }\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\telse {\n\t\tlong double KT = (a2.py - a1.py) / (a2.px - a1.px);\n\t\tlong double YY = a1.py - a1.px*KT;\n\t\tint colour = 0;\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tlong double height = YY + KT*vec2[i].first.px;\n\t\t\tif (colour == 0) {\n\t\t\t\tif (vec2[i].first.py < height) { colour = 3 - vec2[i].second; }\n\t\t\t\tif (vec2[i].first.py == height) { return false; }\n\t\t\t\tif (vec2[i].first.py > height) { colour = vec2[i].second; }\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (colour != 3 - vec2[i].second && vec2[i].first.py < height) { return false; }\n\t\t\t\tif (vec2[i].first.py == height) { return false; }\n\t\t\t\tif (colour != vec2[i].second && vec2[i].first.py > height) { return false; }\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\nint main() {\n\twhile (true) {\n\t\tvec.clear(); vec2.clear(); cin >> n >> m; if (n == 0 && m == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> r1[i].px >> r1[i].py; vec2.push_back(make_pair(r1[i], 1));\n\t\t\tfor (long double j = -1.0l; j <= 1.0l; j += 1.0l) {\n\t\t\t\tfor (long double k = -1.0l; k <= 1.0l; k += 1.0l) {\n\t\t\t\t\tvec.push_back(make_pair(Point{ r1[i].px + j*EPS,r1[i].py + k*EPS }, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> r2[i].px >> r2[i].py; vec2.push_back(make_pair(r2[i], 2));\n\t\t\tfor (long double j = -1.0l; j <= 1.0l; j += 1.0l) {\n\t\t\t\tfor (long double k = -1.0l; k <= 1.0l; k += 1.0l) {\n\t\t\t\t\tvec.push_back(make_pair(Point{ r1[i].px + j*EPS,r1[i].py + k*EPS }, 2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans = false;\n\t\tfor (int i = 0; i < vec.size(); i++) {\n\t\t\tfor (int j = i + 1; j < vec.size(); j++) {\n\t\t\t\tbool p1 = solve(vec[i].first, vec[j].first);\n\t\t\t\tif (p1 == true)ans = true;\n\t\t\t}\n\t\t}\n\t\tif (ans == true)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-10)\n#define eq(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\ndouble norm(Vector v) { return v.x*v.x + v.y*v.y; }\ndouble abs(Vector v) { return sqrt(norm(v)); }\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nbool isOrthogonal(Vector a, Vector b) {\n  return eq(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isParallel(Vector a, Vector b) {\n  return eq(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n  return isParallel(a1 - a2, b1 - b2);\n}\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\ndouble getDistance(Point a, Point b) { return abs(a - b); }\ndouble getAngle(Point a, Point b, Point c) {\n  Vector v = b - a, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha) * 180 / M_PI;\n  return min(theta, 360 - theta);\n}\n\nstruct Segment {\n  Point p1, p2;\n  Segment(Point p1 = Point(), Point p2 = Point()):p1(p1), p2(p2){}\n};\ntypedef Segment Line;\n\nbool isOrthogonal(Segment s1, Segment s2) {\n  return eq(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isParallel(Segment s1, Segment s2) {\n  return eq(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p) {\n  return p + (project(s, p) - p) * 2.0;\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) {\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\ndouble getDistance(Segment s1, Segment s2) {\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPoint getCrossPointLL(Line l1, Line l2) {\n  Vector v1 = l1.p2 - l1.p1, v2 = l2.p2 - l2.p1;\n  double d = cross(v2, v1);\n  if(abs(d) < EPS) return l2.p1;\n  return l1.p1 + v1 * cross(v2, l2.p2 - l1.p1) * (1.0 / d);\n}\nLine getPerpendicularBisector(Point p1, Point p2) {\n  Point c = (p1 + p2) / 2.0;\n  Point q = Point(c.x + (p1.y - p2.y), c.y + (p2.x - p1.x));\n  return Line(c, q);\n}\n\nstruct Circle {\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0):c(c), r(r){}\n};\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n  // assert(intersect(c, l));\n  Vector pr = project(l, c.c);\n  Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n  double base = sqrt(c.r*c.r - norm(pr - c.c));\n  return make_pair(pr + e * base, pr - e * base);\n}\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n  // assert(intersect(c1, c2));\n  double d = abs(c1.c - c2.c);\n  double a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2*c1.r*d));\n  double t = arg(c2.c - c1.c);\n  return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\ntypedef vector<Point> Polygon;\n\ndouble getArea(Polygon p) {\n  double ret = 0.0;\n  for(int i = 0; i < (int)p.size(); i++) {\n    ret += cross(p[i], p[(i+1)%p.size()]);\n  }\n  return abs(ret) / 2.0;\n}\n\n#define IN_POLYGON  2\n#define ON_POLYGON  1\n#define OUT_POLYGON 0\nint contains(Polygon g, Point p) {\n  int n = g.size();\n  bool x = false;\n  for(int i = 0; i < n; i++) {\n    Point a = g[i] - p, b = g[(i+1) % n] - p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON_POLYGON;\n    if(a.y > b.y) swap(a, b);\n    if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n  }\n  return (x ? IN_POLYGON : OUT_POLYGON);\n}\n\nPolygon convexHull(Polygon ps) {\n  int N = ps.size(), j = 0;\n  Polygon pg(N*2);\n\n  if(N < 3) return ps;\n\n  sort(ps.begin(), ps.end(), [](Point p1, Point p2) -> bool {\n      return p1.y != p2.y ? lt(p1.y, p2.y) : lt(p1.x, p2.x); });\n  for(int i = 0; i < N; i++, j++) {\n    while(j >= 2 && ccw(pg[j-2], pg[j-1], ps[i]) == -1) j--;\n    pg[j] = ps[i];\n  }\n  int k = j+1;\n  for(int i = N-2; i >= 0; i--, j++) {\n    while(j >= k && ccw(pg[j-2], pg[j-1], ps[i]) == -1) j--;\n    pg[j] = ps[i];\n  }\n  pg.resize(j-1);\n  return pg;\n}\n\nPolygon convexCut(Polygon s, Line l) {\n  Polygon t;\n  for(int i = 0; i < (int)s.size(); i++) {\n    Point a = s[i], b = s[(i+1)%s.size()];\n    if(ccw(l.p1, l.p2, a) != -1) t.push_back(a);\n    if(ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0) {\n      t.push_back(getCrossPointLL(Line(a, b), l));\n    }\n  }\n  return t;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n, m;\n  while(cin >> n >> m, n || m) {\n    Polygon s(n), t(m);\n    rep(i, n) cin >> s[i].x >> s[i].y;\n    rep(i, m) cin >> t[i].x >> t[i].y;\n\n    auto S = convexHull(s);\n    auto T = convexHull(t);\n\n    bool flag = true;\n    rep(i, S.size()) rep(j, T.size()) {\n      if(intersect(S[i], S[(i+1)%n], T[j], T[(j+1)%m])) flag = false;\n    }\n\n    for(auto&& p : t) flag &= (contains(S, p) == 0);\n    for(auto&& p : s) flag &= (contains(T, p) == 0);\n    cout << (flag ? \"YES\" : \"NO\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\n\nconst double EPS = 1e-8;\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\n// ???????????? a,b ???????????¢???\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\n// ????????¨?????????????????????????????????????????????true???\nbool isIntersect(L s1, L s2){\n  \n  //ccw ??????????????????????????¨, ????????????????????´?????????????????¨??????????????????????????????\n  if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\n// ????????¨??????????????????\nbool isIntersectSP(L s, P p){ \n  return abs(s.first-p) + abs(s.second-p) - abs(s.second-s.first) < EPS; \n}\n\nvector<P> convex_hull2(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nint main(){\n  \n  while(1){\n    \n    int n,m;\n    cin>>n>>m;\n    if(!n&&!m)break;\n  \n    vector<P> B(n),W(m);\n  \n    int x,y;\n  \n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      B[i]=P(x,y);\n    }\n\n    for(int i=0;i<m;i++){\n      cin>>x>>y;\n      W[i]=P(x,y);\n    }\n\n    bool ans=true;\n    \n    /*    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tif(i==j) continue;\n\t\n\tfor(int k=0;k<m;k++)\n\t  for(int l=0;l<m;l++){\n\t    if(k==l) continue;\n\t    \n\t    if(isIntersect(L(B[i],B[j]),L(W[k],W[l]))) ans=false;\n\t    \n\t  }\n\t  }*/\n\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tif(i==j) continue;\n\n\tfor(int k=0;k<m;k++)\n\t  if(isIntersectSP(L(B[i],B[j]),W[k])) ans=false;\n      }\n\n    for(int i=0;i<m;i++)\n      for(int j=0;j<m;j++){\n\tif(i==j) continue;\n\n\tfor(int k=0;k<n;k++)\n\t  if(isIntersectSP(L(W[i],W[j]),B[k])) ans=false;\n      }\n\n    vector<P> B2=convex_hull2(B);\n\n    int f=0,flag=1;\n      \n    for(int i=0;i<B2.size();i++){\n      for(int j=0;j<W.size();j++){\n\tint ip=(i+1)%B2.size();\n\tif(ccw(B2[i],B2[ip],W[j])==-1) flag=0;\n\t//\tcout<<ccw(B2[i],B2[ip],W[j])<<endl;\n      }\n    }\n\n    if(B2.size()>=3&&flag) ans=false;\n    \n    vector<P> W2=convex_hull2(W);\n    \n    f=0;\n    flag=1;\n    \n    for(int i=0;i<W2.size();i++){\n      for(int j=0;j<B.size();j++){\n\tint ip=(i+1)%W2.size();\n\tif(ccw(W2[i],W2[ip],B[j])==-1) flag=0;\n\t//\tcout<<ccw(W2[i],W2[ip],B[j])<<endl;\n      }\n    }\n    \n    if(W2.size()>=3&&flag) ans=false;\n    \n    if(ans) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n      \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <set>\n#include <complex>\nusing namespace std;\n\nusing ld = long double;\nusing P = complex<ld>;\nusing G = vector<P>;\nconst ld pi = acos(-1);\nconst ld eps = 1e-10;\nconst ld inf = 1e12;\n\nld cross(const P& a, const P& b) { return a.real()*b.imag() - a.imag()*b.real(); }\nld dot(const P& a, const P& b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\nenum { CCW = +1, CW = -1, BEHIND = +2, FRONT = -2, ON = 0 };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > eps)  return CCW;    // counter clockwise\n\tif(cross(b, c) < -eps) return CW;     // clockwise\n\tif(dot(b, c) < 0)      return BEHIND; // c--a--b on line\n\tif(norm(b) < norm(c))  return FRONT;  // a--b--c on line\n\treturn ON;\n}\n\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn abs(real(a) - real(b)) > eps ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n\nG andrewScan(G ps) {\n\tint N = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tG res(N * 2);\n\tfor(int i = 0; i < N; i++) {\n\t\twhile(k >= 2 && ccw(res[k - 2], res[k - 1], ps[i]) == CW) k--;\n\t\tres[k++] = ps[i];\n\t}\n\tint t = k + 1;\n\tfor(int i = N - 2; i >= 0; i--) {\n\t\twhile(k >= t && ccw(res[k - 2], res[k - 1], ps[i]) == CW) k--;\n\t\tres[k++] = ps[i];\n\t}\n\tres.resize(k - 1);\n\treturn res;\n}\n\nstruct L : public vector<P> {\n\tL(const P &a = 0, const P &b = 0) {\n\t\tpush_back(a); push_back(b);\n\t}\n\tL(ld A, ld B, ld C) { // Ax + By + C = 0\n\t\tif(A < eps) *this = L(P(0, -C / B), P(1, -C / B));\n\t\telse if(B < eps) *this = L(P(-C / A, 0), P(-C / A, 1));\n\t\t*this = L(P(0, -C / B), P(-C / A, 0));\n\t}\n\tint ccw(const P& p) {\n\t\treturn ::ccw((*this)[0], (*this)[1], p);\n\t}\n};\n\nbool intersectSP(const L &s, const P &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < eps; // triangle inequality\n}\n\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\n\n\nint cnt = 0;\n\nbool in(P& p, G& g) {\n\tfor(int i = 0; i < g.size(); i++) {\n\t\tL l(g[i], g[(i + 1) % g.size()]);\n\t\tif(intersectSP(l, p)) return true;\n\t\tif(cross(l[1] - l[0], p - l[0]) < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool in(G& g1, G& g2) {\n\tfor(int i = 0; i < g1.size(); i++) {\n\t\tif(in(g1[i], g2)) return true;\n\t}\n\treturn false;\n}\n\nbool check(G& g1, G& g2) {\n\tint n = g1.size(), m = g2.size();\n\tif(n == 2 && m == 2) {\n\t\treturn !intersectSS(L(g1[0], g1[1]), L(g2[0], g2[1]));\n\t}\n\tif(in(g1, g2) || in(g2, g1)) return false;\n\tfor(int i = 0; i < n; i++) {\n\t\tL l1(g1[i], g1[(i + 1) % n]);\n\t\tfor(int j = 0; j < m; j++) {\n\t\t\tL l2(g2[j], g2[(j + 1) % m]);\n\t\t\tif(intersectSS(l1, l2)) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n, m;\n\twhile(cin >> n >> m, n | m) {\n\t\tG b(n), w(m);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tld x, y;\n\t\t\tcin >> x >> y;\n\t\t\tb[i] = P(x, y);\n\t\t}\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tld x, y;\n\t\t\tcin >> x >> y;\n\t\t\tw[i] = P(x, y);\n\t\t}\n\n\t\tif(n == 1 && m == 1) {\n\t\t\tcout << \"YES\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(n >= 3) {\n\t\t\tb = andrewScan(b);\n\t\t\tn = b.size();\n\t\t}\n\t\tif(m >= 3) {\n\t\t\tw = andrewScan(w);\n\t\t\tm = w.size();\n\t\t}\n\n\t\tcout << (check(b, w) ? \"YES\" : \"NO\") << endl;\n\t\tcnt++;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___STD_GEOMETRY\n#define ___STD_GEOMETRY\n\n#include <cmath>\n\n#define EPS 1e-13L\n\n#endif\n\n#ifndef ___Class_Point\n#define ___Class_Point\n\nclass Point\n{\npublic:\n\n\t// ------ Variable ------ //\n\n\tlong double x, y;\n\n\n\t// ------ Constructor ------ //\n\n\tPoint() : x(0), y(0) { }\n\n\texplicit Point(long double x, long double y) : x(x), y(y) { }\n\n\n\t// ------ Operator ------ //\n\n\tfriend bool operator==(Point& p1, Point& p2) { return p1.x == p2.x && p1.y == p2.y; }\n\tfriend bool operator!=(Point& p1, Point& p2) { return p1.x != p2.x || p1.y != p2.y; }\n};\n\nlong double distance(const Point& p1, const Point& p2)\n{\n\treturn sqrtl((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));\n}\n\n#endif\n\n#ifndef ___Class_Vector\n#define ___Class_Vector\n\nclass Vector\n{\npublic:\n\n\t// ------ Variable ------ //\n\n\tlong double x, y;\n\n\n\t// ------ Constructor ------ //\n\n\tVector() : x(0), y(0) { }\n\n\texplicit Vector(long double x, long double y) : x(x), y(y) { }\n\n\texplicit Vector(Point p1, Point p2) : x(p2.x - p1.x), y(p2.y - p1.y) { }\n\n\texplicit Vector(long double sx, long double tx, long double sy, long double ty) : x(tx - sx), y(ty - sy) { }\n\n\n\t// ------ Operator ------ //\n\n\tVector operator+() const { return Vector(+x, +y); }\n\tVector operator-() const { return Vector(-x, -y); }\n\n\tVector& operator+=(const Vector& v) { x += v.x; y += v.y; return *this; }\n\tVector& operator-=(const Vector& v) { x -= v.x; y -= v.y; return *this; }\n\n\tfriend bool operator==(const Vector& v1, const Vector& v2) { return -EPS < v1.x - v2.x && v1.x - v2.x < EPS && -EPS < v1.y - v2.y && v1.y - v2.y < EPS; }\n\tfriend bool operator!=(const Vector& v1, const Vector& v2) { return !(v1 == v2); }\n\n\tfriend Vector operator+(const Vector& v1, const Vector& v2) { return Vector(v1.x + v2.x, v1.y + v2.y); }\n\tfriend Vector operator-(const Vector& v1, const Vector& v2) { return Vector(v1.x - v2.x, v1.y - v2.y); }\n\n\tfriend Vector operator*(double d, const Vector& v) { return Vector(d * v.x, d * v.y); }\n\tfriend Vector operator*(const Vector& v, double d) { return Vector(d * v.x, d * v.y); }\n\tfriend Vector operator/(const Vector& v, double d) { return Vector(v.x / d, v.y / d); }\n\n\n\t// ------ Function ------ //\n\n\tlong double norm() { return x * x + y * y; }\n\n\tlong double abs() { return sqrtl(x * x + y * y); }\n\n\tlong double angle() { return atan2l(y, x); }\n};\n\nlong double angle(const Vector& v1, const Vector& v2)\n{\n\tlong double A = atan2l(v2.y, v2.x) - atan2l(v1.y, v1.x);\n\n\tif (180.0L - EPS < A && A < 180.0L + EPS) { return 180.0L; }\n\n\tif (-180.0L - EPS < A && A < -180.0L + EPS) { return 180.0L; }\n\n\tif (A > 180.0L - EPS) { return A - 360.0L; }\n\n\tif (A < -180.0L + EPS) { return A + 360.0L; }\n\n\treturn A;\n}\n\nlong double norm(const Vector& v1)\n{\n\treturn v1.x * v1.x + v1.y * v1.y;\n}\n\nlong double abs(const Vector& v1)\n{\n\treturn sqrt(norm(v1));\n}\n\nlong double cross(const Vector& v1, const Vector& v2)\n{\n\treturn v1.x * v2.y - v1.y * v2.x;\n}\n\nlong double dot(const Vector& v1, const Vector& v2)\n{\n\treturn v1.x * v2.x + v1.y * v2.y;\n}\n\nlong double distance(const Vector& v1, const Vector& v2)\n{\n\treturn sqrtl((v2.x - v1.x) * (v2.x - v1.x) + (v2.y - v1.y) * (v2.y - v1.y));\n}\n\n#endif\n\nbool Triangle_Inside(Vector Tp1, Vector Tp2, Vector Tp3, Vector p) // Triangle is Counter-Clockwise\n{\n\tbool ok1 = !(angle(p - Tp1, Tp2 - Tp1) < 0 ^ angle(Tp2 - Tp1, p - Tp1) < angle(Tp2 - Tp1, Tp3 - Tp1));\n\tbool ok2 = !(angle(p - Tp2, Tp3 - Tp2) < 0 ^ angle(Tp3 - Tp2, p - Tp2) < angle(Tp3 - Tp2, Tp1 - Tp2));\n\tbool ok3 = !(angle(p - Tp3, Tp1 - Tp3) < 0 ^ angle(Tp1 - Tp3, p - Tp3) < angle(Tp1 - Tp3, Tp2 - Tp3));\n\n\treturn ok1 && ok2 && ok3;\n}\n\nbool On_Segment(Vector Sp1, Vector Sp2, Vector p)\n{\n\treturn (Sp1 + Sp2) / 2 == p;\n}\n\nint Counter_Clockwise(Vector p1, Vector p2, Vector p3)\n{\n\tVector a = p2 - p1;\n\tVector b = p3 - p1;\n\n\tif (cross(a, b) > EPS) { return 1; }\n\tif (cross(a, b) < -EPS) { return -1; }\n\n\tif (dot(a, b) < -EPS) { return 2; }\n\n\tif (a.norm() < b.norm()) { return -2; }\n\n\treturn 0;\n}\n\nbool Intersection(Vector p1, Vector p2, Vector p3, Vector p4)\n{\n\tint ok1 = Counter_Clockwise(p1, p2, p3) * Counter_Clockwise(p1, p2, p4);\n\tint ok2 = Counter_Clockwise(p3, p4, p1) * Counter_Clockwise(p3, p4, p2);\n\n\treturn ok1 <= 0 && ok2 <= 0;\n}\n\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tint N, M, X, Y;\n\n\twhile (true)\n\t{\n\t\tcin >> N >> M;\n\n\t\tif (N == 0 && M == 0) { break; }\n\n\t\tvector<Vector> W(N);\n\t\tvector<Vector> B(M);\n\n\t\tfor (int i = 0; i < N; i++) { cin >> X >> Y; W[i] = Vector(X, Y); }\n\t\tfor (int i = 0; i < M; i++) { cin >> X >> Y; B[i] = Vector(X, Y); }\n\n\t\tbool ok = true;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < M; k++)\n\t\t\t\t{\n\t\t\t\t\tif (On_Segment(W[i], W[j], B[k]) == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < M; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < M; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t\t{\n\t\t\t\t\tif (On_Segment(B[i], B[j], W[k]) == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ok == true)\n\t\t{\n\t\t\tif (N > 2 || M > 2)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int k = j + 1; k < N; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int l = 0; l < M; l++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (Triangle_Inside(W[i], W[j], W[k], B[l]) == true)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < M; i++)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = i + 1; j < M; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int k = j + 1; k < M; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int l = 0; l < N; l++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (Triangle_Inside(B[i], B[j], B[k], W[l]) == true)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (N == 2 && M == 2)\n\t\t\t{\n\t\t\t\tok = (Intersection(W[0], W[1], B[0], B[1]) == true ? false : true);\n\t\t\t}\n\t\t}\n\n\t\tcout << (ok == true ? \"YES\" : \"NO\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\n#include <complex>\ntypedef complex<double> P;\n\nnamespace std {\n\tbool operator< (const P &a, const P &b) {\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n}\n\ndouble dot(P a, P b) {\n\treturn a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n\treturn a.real()*b.imag() - a.imag()*b.real();\n}\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0) return +1;\n\tif(cross(b, c) < 0) return -1;\n\tif(dot(b, c) < 0)   return +2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nvector<P> convex_full(vector<P> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ALL(ps));\n\tvector<P> ch(2*n);\n\tfor(int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\tfor(int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])\n\t\twhile(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\tch.resize(k-1);\n\treturn ch;\n}\n\nenum {OUT, ON, IN};\nint convex_contains(const vector<P> &pol, const P &p) {\n\tconst int n = pol.size();\n\tP g = (pol[0] + pol[n/3] + pol[2*n/3]) / 3.0;\n\tint a = 0, b = n;\n\twhile(a+1 < b) {\n\t\tint c = (a+b)/2;\n\t\tif(cross(pol[a]-g, pol[c]-g) > 0) {\n\t\t\tif(cross(pol[a]-g, p-g) > 0 && cross(pol[c]-g, p-g) < 0)\n\t\t\t\tb = c;\n\t\t\telse\n\t\t\t\ta = c;\n\t\t} else {\n\t\t\tif(cross(pol[a]-g, p-g) < 0 && cross(pol[c]-g, p-g) > 0)\n\t\t\t\ta = c;\n\t\t\telse\n\t\t\t\tb = c;\n\t\t}\n\t}\n\tb %= n;\n\tif(cross(pol[a]-p, pol[b]-p) < 0) return OUT;\n\tif(cross(pol[a]-p, pol[b]-p) > 0) return IN;\n\treturn ON;\n}\n\nbool is_point_on_ls(P a, P b, P c) {\n\treturn abs(a-c)+abs(c-b) < abs(a-b)+EPS;\n}\n\nbool is_intersected_ls(P a1, P a2, P b1, P b2) {\n\tif((cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < -EPS) &&\n\t   (cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < -EPS))\n\t   return true;\n\treturn is_point_on_ls(a1, a2, b1) || is_point_on_ls(a1, a2, b2) ||\n\t\tis_point_on_ls(b1, b2, a1) || is_point_on_ls(b1, b2, a2);\n}\n\nint main() {\n\tint n, m;\n\twhile(cin >> n >> m, n) {\n\t\tdouble x, y;\n\t\tvector<P> wp, bp;\n\t\tREP(i, n) {\n\t\t\tcin >> x >> y;\n\t\t\twp.push_back(P(x, y));\n\t\t}\n\t\tREP(i, m) {\n\t\t\tcin >> x >> y;\n\t\t\tbp.push_back(P(x, y));\n\t\t}\n\n\t\tint ok = true;\n\t\tif(n == 1) {\n\n\t\t} else if(n == 2) {\n\t\t\tREP(i, m) {\n\t\t\t\tif(is_intersected_ls(wp[0], wp[1], bp[i], bp[(i+1)%m])) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvector<P> wph = convex_full(wp);\n\t\t\tif(wph.size() != 0) {\n\t\t\t\tREP(i, m) {\n\t\t\t\t\tif(convex_contains(wph, bp[i]) != OUT) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(m == 1) {\n\n\t\t} else if(m == 2) {\n\t\t\tREP(i, n) {\n\t\t\t\tif(is_intersected_ls(bp[0], bp[1], wp[i], wp[(i+1)%n])) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvector<P> bph = convex_full(bp);\n\t\t\tif(bph.size() != 0) {\n\t\t\t\tREP(i, n) {\n\t\t\t\t\tif(convex_contains(bph, wp[i]) != OUT) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (ok ? \"YES\" : \"NO\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define EPS 1e-8\n\ninline int cmp(const double &x) {\n\tif (x < -EPS) return -1;\n\treturn x > EPS;\n}\n\nstruct point {\n\tdouble x, y;\n\tinline point() {}\n\tinline point (const double &x, const double &y) : x(x), y(y) {}\n\tinline void Read() { scanf(\"%lf%lf\", &x, &y); }\n\tinline point operator+ (const point &p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\tinline point operator- (const point &p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\tinline bool operator== (const point &p) const {\n\t\treturn cmp(x - p.x) == 0 && cmp(y - p.y) == 0;\n\t}\n\tinline bool operator!= (const point &p) const {\n\t\treturn ! (*this == p);\n\t}\n\tinline point operator* (const double &d) const {\n\t\treturn point(x * d, y * d);\n\t}\n\tinline point operator/ (const double &d) const {\n\t\treturn point(x / d, y / d);\n\t}\n};\n\ninline double det(const point &a, const point &b) {\n\treturn a.x * b.y - a.y * b.x; \n}\n\ninline double dot(const point &a, const point &b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\nstruct polygon_convex {\n\tvector<point> P;\n\tinline polygon_convex(const int size = 0) { P.resize(size); }\n};\n\ninline bool comp_less(const point &a, const point &b) {\n\treturn cmp(a.x - b.x) < 0 || cmp(a.x - b.x) == 0 && cmp(a.y - b.y) < 0;\n}\n\npolygon_convex convex_hull(vector<point> &a) {\n\tpolygon_convex res((a.size() << 1) + 5);\n\n\tregister int i = 0, m = 0;\n\tfor(; i < (int)a.size(); ++ i) {\n\t\twhile (m > 1 && cmp(det(res.P[m - 1] - res.P[m - 2], a[i] - res.P[m - 2])) <= 0) {\n\t\t\t-- m;\n\t\t}\n\t\tres.P[m ++] = a[i];\n\t}\n\tregister int k = m;\n\tfor(i = a.size() - 2; i >= 0; -- i) {\n\t\twhile (m > k && cmp(det(res.P[m - 1] - res.P[m - 2], a[i] - res.P[m - 2])) <= 0) {\n\t\t\t-- m;\n\t\t}\n\t\tres.P[m ++] = a[i];\n\t}\n\tres.P.resize(m);\n\tif (a.size() > 1) res.P.resize(m - 1);\n\treturn res;\n}\n\ninline bool PointOnSegment(const point &p, const point &s, const point &t) {\n\treturn cmp(det(p - s, t - s)) == 0 && cmp(dot(p - s, p - t)) <= 0;\n}\n\nbool containOn(const polygon_convex &a, const point &b) {\n\tregister int n = a.P.size();\n\tif(n == 2) {\n\t\treturn PointOnSegment(b, a.P[0], a.P[1]);\n\t}\n#define next(i) ((i + 1) % n)\n\tregister int sign = 0;\n\tregister int i;\n\tfor(i = 0; i < n; ++ i) {\n\t\tint cSign = cmp(det(a.P[i] - b, a.P[next(i)] - b));\n\t\tif(cSign) {\n\t\t\tif(sign) {\n\t\t\t\tif(sign != cSign) return false;\n\t\t\t} else {\n\t\t\t\tsign = cSign;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\ninline bool parallel(const point &xx, const point &xy, const point &yx, const point &yy) {\n\treturn !cmp(det(xx - xy, yx - yy));\n}\n\nbool line_make_point(const point &xx, const point &xy, const point &yx, const point &yy, point &cross) {\n\tif(parallel(xx, xy, yx, yy)) return false;\n\tstatic double s1, s2;\n\ts1 = det(xx - yx, yy - yx);\n\ts2 = det(xy - yx, yy - yx);\n\tcross = (xy * s1 - xx * s2) / (s1 - s2);\n\treturn true;\n}\n\nvector<point> white, black;\n\nint main() {\n\tint n, m;\n\twhile(scanf(\"%d%d\", &n, &m), n || m) {\n\t\tblack.clear(), white.clear();\n\t\tblack.reserve(n), white.reserve(m);\n\t\tregister int i;\n\t\tfor(i = 0; i < n; ++ i) {\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\tblack.push_back(point(x, y));\n\t\t}\n\t\tsort(black.begin(), black.end(), comp_less);\n\t\tblack.erase(unique(black.begin(), black.end()), black.end());\n\t\tfor(i = 0; i < m; ++ i) {\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\twhite.push_back(point(x, y));\n\t\t}\n\t\tsort(white.begin(), white.end(), comp_less);\n\t\twhite.erase(unique(white.begin(), white.end()), white.end());\n\t\tbool ok = true;\n\t\tstatic polygon_convex Black, White;\n\t\tif(white.size() == 1 && black.size() == 1) { puts(white[0] != black[0] ? \"YES\" : \"NO\"); continue; }\n\t\tif(black.size() > 1) {\n\t\t\tBlack = convex_hull(black);\n\t\t\tbool ok = true;\n\t\t\tfor(vector<point>::iterator it = white.begin(); it != white.end(); ++ it) {\n\t\t\t\tif(containOn(Black, *it)) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!ok) {\n\t\t\tputs(\"NO\");\n\t\t\tcontinue;\n\t\t}\n\t\tif(white.size() > 1) {\n\t\t\tWhite = convex_hull(white);\n\t\t\tfor(vector<point>::iterator it = black.begin(); it != black.end(); ++ it) {\n\t\t\t\tif(containOn(White, *it)) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint WSize = White.P.size(), BSize = Black.P.size();\n\t\tregister int j;\n#define nexti(i) ((i + 1) % WSize)\n#define nextj(j) ((j + 1) % BSize)\n#define PW(x) White.P[x]\n#define PB(x) Black.P[x]\n\t\tif(ok)\n\t\t\tfor(i = 0; i < WSize; ++ i){\n\t\t\t\tfor(j = 0; j < BSize; ++ j) {\n\t\t\t\t\tstatic point cross;\n\t\t\t\t\tif(!line_make_point(PW(i), PW(nexti(i)), PB(j), PB(nextj(j)), cross)) {\n\t\t\t\t\t\tif(parallel(PW(i), PB(j), PW(nexti(i)), PB(nextj(j))) && parallel(PW(nexti(i)), PB(j), PW(i), PB(nextj(j))) && (PointOnSegment(PW(i), PB(j), PB(nextj(j))) || PointOnSegment(PW(nexti(i)), PB(j), PB(nextj(j))))) ok = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(PointOnSegment(cross, PW(i), PW(nexti(i))) && PointOnSegment(cross, PB(j), PB(nextj(j)))) ok = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(!ok) break;\n\t\t\t\t}\n\t\t\t\tif(!ok) break;\n\t\t\t}\n\n\t\tputs(ok ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\n#define EPS 1e-7\n\ntypedef complex<double> point;\ntypedef const point &refpoint;\n\n\ndouble dot(refpoint a, refpoint b){\n\treturn real(a) * real(b) + imag(a) * imag(b);\n}\n\ndouble cross(refpoint a, refpoint b){\n\treturn real(a) * imag(b) - imag(a) * real(b);\n}\n\ndouble distance_l_p(refpoint a, refpoint b, refpoint c){\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\ndouble distance_ls_p(refpoint a, refpoint b, refpoint c){\n\tif( dot(b - a, c - a) <= 0.0 ) return abs(c - a);\n\tif( dot(a - b, c - b) <= 0.0 ) return abs(c - b);\n\treturn distance_l_p(a, b, c);\n}\n\nbool contains(const vector<point> &plg, refpoint pts){\n\tint cnt = 0;\n\tdouble y = imag(pts);\n\n\tfor(int i = 0; i < plg.size(); ++i){\n\t\tint j = (i + 1 == plg.size() ? 0: i + 1);\n\n\t\tdouble dyi = imag(plg[i]) - y;\n\t\tdouble dyj = y - imag(plg[j]);\n\t\tdouble tx = (dyi * real(plg[j]) + dyj * real(plg[i])) / (dyi + dyj);\n\n\t\tif(imag(plg[i]) >= y && imag(plg[j]) < y){\n\t\t\tif( tx < real(pts) ) ++cnt;\n\t\t}\n\t\telse if(imag(plg[i]) < y && imag(plg[j]) >= y){\n\t\t\tif( tx < real(pts) ) --cnt;\n\t\t}\n\t}\n\t\n\treturn (cnt % 2 != 0);\n}\n\nbool intersected(refpoint pa1, refpoint pa2, refpoint pb1, refpoint pb2){\n\tdouble a = cross(pa2 - pa1, pb1 - pa1);\n\tdouble b = cross(pa2 - pa1, pb2 - pa1);\n\tdouble c = cross(pb2 - pb1, pa1 - pb1);\n\tdouble d = cross(pb2 - pb1, pa2 - pb1);\n\n\tif( (a < -EPS && b > EPS) || (b < -EPS && a > EPS) ){\n\t\tif( (c < -EPS && d > EPS) || (d < -EPS && c > EPS) ){\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nbool contact(const vector<point> &plg1, const vector<point> &plg2){\n\tif( contains(plg1, plg2[0]) || contains(plg2, plg1[0]) ){\n\t\treturn true;\n\t}\n\n\tint n = plg1.size();\n\tint m = plg2.size();\n\tfor(int i = 0; i < n; ++i){\n\t\tfor(int j = 0; j < m; ++j){\n\t\t\tif( intersected(plg1[i], plg1[(i+1)%n], plg2[j], plg2[(j+1)%m]) ){\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif( distance_ls_p(plg1[i], plg1[(i+1)%n], plg2[j]) < EPS ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif( distance_ls_p(plg2[j], plg2[(j+1)%m], plg1[i]) < EPS ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\n\nbool orderbyreal(refpoint p1, refpoint p2){\n\treturn real(p1) < real(p2);\n}\n\n\nvector<point> convex(vector<point> plg){\n\tint n = plg.size();\n\tif( n <= 3 ){\n\t\treturn plg;\n\t}\n\n\tsort(plg.begin(), plg.end(), orderbyreal);\n\n\tvector<point> ret(2 * n);\n\tint k = 0;\n\n\tfor(int i = 0; i < n; ++i){\n\t\twhile( k >= 2 && cross( ret[k-1] - ret[k-2], plg[i] - ret[k-2] ) <= 0.0 ){\n\t\t\t--k;\n\t\t}\n\t\tret[k++] = plg[i];\n\t}\n\n\tint t = k + 1;\n\tfor(int i = n - 2; i >= 0; --i){\n\t\twhile( k >= t && cross( ret[k-1] - ret[k-2], plg[i] - ret[k-2] ) <= 0.0 ){\n\t\t\t--k;\n\t\t}\n\t\tret[k++] = plg[i];\n\t}\n\tret.resize(k - 1);\n\t\n\treturn ret;\n}\n\n\nint main(){\n\tint n, m;\n\tdouble x, y;\n\t\n\twhile( scanf(\"%d%d\", &n, &m), n != 0 ){\n\t\tvector<point> black, white;\n\t\tblack.reserve(n);\n\t\twhite.reserve(m);\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\tblack.push_back( point(x, y) );\n\t\t}\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\twhite.push_back( point(x, y) );\n\t\t}\n\n\n\t\tblack = convex(black);\n\t\twhite = convex(white);\n\n\t\tif( contact(black, white) ){\n\t\t\tputs(\"NO\");\n\t\t}\n\t\telse{\n\t\t\tputs(\"YES\");\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a; i<(int)b; i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef complex<double> P;\n\nnamespace std {\n  bool operator < (P const& a, P const& b) {\n    if(real(a) != real(b)) return real(a) < real(b);\n    return imag(a) < imag(b);\n  }\n}\n\ndouble const EPS = 1e-7;\n\n#define prev(G, i) ( G[((i-1)+G.size())%G.size()] )\n#define curr(G, i) ( G[i%G.size()] )\n#define next(G, i) ( G[(i+1)%G.size()] )\n\ndouble dot(P const& a, P const& b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(P const& a, P const& b) {\n  return imag(conj(a)*b);\n}\n\ntypedef vector<P> Polygon;\n\nPolygon convex_hull(vector<P> ps) {\n  sort(ps.begin(), ps.end());\n  int N = ps.size(), k = 0;\n  vector<P> qs(N*2);\n  rep(i, N) {\n    while(k > 1 && cross(qs[k-1]-qs[k-2], ps[i]-ps[k-1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  for(int i=N-2, t=k; i>=0; i--) {\n    while(k > t && cross(qs[k-1]-qs[k-2], ps[i]-qs[k-1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nenum { counter_clock_wise=+1, clockwise=-1, cab_online=+2, abc_online=-2 };\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if(cross(b, c) > 0) return counter_clock_wise;\n  if(cross(b, c) < 0) return clockwise;\n  if(dot(b, c) < 0) return cab_online;\n  if(norm(b) < norm(c)) return abc_online;\n  return 0;\n}\n\nstruct Line : public vector<P>\n{\n  Line(P const& a, P const& b) {\n    push_back(a), push_back(b);\n  }\n};\n\ntypedef Line Segment;\n\nbool is_intersect_ss(Segment const& s, Segment const& t) {\n  return ( ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) < EPS )\n    && ( ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) < EPS );\n}\n\n// contain: 2, on segment: 1, the other case: 0\nint contains(Polygon const& G, P const& p) {\n  bool x = false;\n  for(int i=0; i<(int)G.size(); i++) {\n    P v1 = curr(G, i)-p, v2 = next(G, i) - p;\n    if( v1.imag() > v2.imag() ) swap(v1, v2);\n    if( v1.imag() <= 0 && 0 < v2.imag() && cross(v1, v2) > 0 ) x = !x;\n    if( cross(v1, v2) == 0 && dot(v1, v2) <= 0 ) return 1;\n  }\n  return (x?2:0);\n}\n\nint main() {\n\n  int N, M;\n  while(cin >> N >> M && (N|M)) {\n    Polygon G1(N), G2(M);\n    rep(i, N) cin >> G1[i].real() >> G1[i].imag(); \n    rep(i, M) cin >> G2[i].real() >> G2[i].imag(); \n    \n    G1 = convex_hull(G1); N = G1.size();\n    G2 = convex_hull(G2); M = G2.size();\n    //    cout << \"convex hull\\n\";\n    bool ok = !contains(G1, G2[0]) && !contains(G2, G1[0]);\n    rep(i, N) {\n      rep(j, M) {\n\tSegment s1 = Segment(curr(G1, i), next(G1, i));\n\tSegment s2 = Segment(curr(G2, j), next(G2, j));\n\tif(is_intersect_ss(s1, s2)) { ok = 0; }\n      }\n    }\n    \n    cout << (ok ? \"YES\\n\" : \"NO\\n\");\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\n#define EPS 1e-7\n\ntypedef complex<double> point;\ntypedef const point &refpoint;\n\n\ndouble dot(refpoint a, refpoint b){\n\treturn real(a) * real(b) + imag(a) * imag(b);\n}\n\ndouble cross(refpoint a, refpoint b){\n\treturn real(a) * imag(b) - imag(a) * real(b);\n}\n\ndouble distance_l_p(refpoint a, refpoint b, refpoint c){\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\ndouble distance_ls_p(refpoint a, refpoint b, refpoint c){\n\tif( dot(b - a, c - a) <= 0.0 ) return abs(c - a);\n\tif( dot(a - b, c - b) <= 0.0 ) return abs(c - b);\n\treturn distance_l_p(a, b, c);\n}\n\nbool contains(const vector<point> &plg, refpoint pts){\n\tint cnt = 0;\n\tdouble y = imag(pts);\n\n\tfor(int i = 0; i < plg.size(); ++i){\n\t\tint j = (i + 1 == plg.size() ? 0: i + 1);\n\n\t\tdouble dyi = imag(plg[i]) - y;\n\t\tdouble dyj = y - imag(plg[j]);\n\t\tdouble tx = (dyi * real(plg[j]) + dyj * real(plg[i])) / (dyi + dyj);\n\n\t\tif(imag(plg[i]) >= y && imag(plg[j]) < y){\n\t\t\tif( tx < real(pts) ) ++cnt;\n\t\t}\n\t\telse if(imag(plg[i]) < y && imag(plg[j]) >= y){\n\t\t\tif( tx < real(pts) ) --cnt;\n\t\t}\n\t}\n\t\n\treturn (cnt % 2 != 0);\n}\n\nbool intersected(refpoint pa1, refpoint pa2, refpoint pb1, refpoint pb2){\n\tdouble a = cross(pa2 - pa1, pb1 - pa1);\n\tdouble b = cross(pa2 - pa1, pb2 - pa1);\n\tdouble c = cross(pb2 - pb1, pa1 - pb1);\n\tdouble d = cross(pb2 - pb1, pa2 - pb1);\n\n\tif( (a < -EPS && b > EPS) || (b < -EPS && a > EPS) ){\n\t\tif( (c < -EPS && d > EPS) || (d < -EPS && c > EPS) ){\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif( \tdistance_ls_p(pa1, pa2, pb1) < EPS\n\t\t || distance_ls_p(pa1, pa2, pb2) < EPS\n\t\t || distance_ls_p(pb1, pb2, pa1) < EPS\n\t\t || distance_ls_p(pb1, pb2, pa2) < EPS\n\t){\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool contact(const vector<point> &plg1, const vector<point> &plg2){\n\tif( contains(plg1, plg2[0]) || contains(plg2, plg1[0]) ){\n\t\treturn true;\n\t}\n\n\tint n = plg1.size();\n\tint m = plg2.size();\n\tfor(int i = 0; i < n; ++i){\n\t\tfor(int j = 0; j < m; ++j){\n\t\t\tif( intersected(plg1[i], plg1[(i+1)%n], plg2[j], plg2[(j+1)%m]) ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\n\nbool ordercomplex(refpoint p1, refpoint p2){\n\tif( real(p1) != real(p2) )\n\t\treturn real(p1) < real(p2);\n\treturn imag(p1) < imag(p2);\n}\n\n\nvector<point> convex(vector<point> plg){\n\tint n = plg.size();\n\tif( n <= 3 ){\n\t\treturn plg;\n\t}\n\n\tsort(plg.begin(), plg.end(), ordercomplex);\n\n\tvector<point> ret(2 * n);\n\tint k = 0;\n\n\tfor(int i = 0; i < n; ++i){\n\t\twhile( k >= 2 && cross( ret[k-1] - ret[k-2], plg[i] - ret[k-2] ) <= 0.0 ){\n\t\t\t--k;\n\t\t}\n\t\tret[k++] = plg[i];\n\t}\n\n\tint t = k + 1;\n\tfor(int i = n - 2; i >= 0; --i){\n\t\twhile( k >= t && cross( ret[k-1] - ret[k-2], plg[i] - ret[k-2] ) <= 0.0 ){\n\t\t\t--k;\n\t\t}\n\t\tret[k++] = plg[i];\n\t}\n\tret.resize(k - 1);\n\t\n\treturn ret;\n}\n\n\nint main(){\n\tint n, m;\n\tdouble x, y;\n\t\n\twhile( scanf(\"%d%d\", &n, &m), n != 0 ){\n\t\tvector<point> black, white;\n\t\tblack.reserve(n);\n\t\twhite.reserve(m);\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\tblack.push_back( point(x, y) );\n\t\t}\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\twhite.push_back( point(x, y) );\n\t\t}\n\n\n\t\tblack = convex(black);\n\t\twhite = convex(white);\n\n\t\tif( contact(black, white) ){\n\t\t\tputs(\"NO\");\n\t\t}\n\t\telse{\n\t\t\tputs(\"YES\");\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\ntypedef pair<double, double> P;\nint f(double w[], P p){\n  double v = w[0] + w[1] * p.first + w[2] * p.second;\n  if(v >= 0) return 1;\n  else return 0;\n}\n\nint main(){\n  int b, w;\n  while(cin>>b>>w && (b != 0 || w != 0)){\n    vector<P> points_b, points_w;\n    REP(i, b){\n      double x, y; cin>>x>>y;\n      points_b.push_back(P(x, y));\n    }\n    REP(i, w){\n      double x, y; cin>>x>>y;\n      points_w.push_back(P(x, y));\n    }\n    double we[3] = {};\n    double rate = 1;\n    bool ans = false;\n    REP(iter, 10000000){\n      bool update = false;\n      REP(i, b){\n        int v = f(we, points_b[i]);\n        if(v == 1){\n          we[0] = we[0] + rate * -1;\n          we[1] = we[1] + rate * -1 * points_b[i].first;\n          we[2] = we[2] + rate * -1 * points_b[i].second;\n          update = true;\n        }\n      }\n      REP(i, w){\n        int v = f(we, points_w[i]);\n        if(v == 0){\n          we[0] = we[0] + rate * 1;\n          we[1] = we[1] + rate * 1 * points_w[i].first;\n          we[2] = we[2] + rate * 1 * points_w[i].second;\n          update = true;\n        }\n      }\n      if(!update){\n        ans = true;\n        break;\n      }\n    }\n    if(ans) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\n\nstruct P{\n  double x, y;\n  bool f;\n  P(){}\n  P(double x, double y, bool f) :x(x), y(y), f(f) {}\n};\n\nbool const operator<(const P &a, const P &b) {\n  return a.x != b.x ? a.x < b.x : a.y != b.y ? a.y < b.y : a.f < b.f;\n}\n\nint main() {\n  int n, m;\n  while(cin >> n >> m, n||m) {\n    P p[n+m];\n    REP(i, n+m){\n      int x, y;\n      cin >> x >> y;\n      p[i] = P(x,y,i>=n);\n    }\n    bool dame = 0;\n    for (int i=1; i<n+m; ++i) {\n      REP(j, i) {\n//        cout << n << \" \" << m << endl;\n        dame = 0;\n        vector<P> v;\n        \n        if (p[i].x == p[j].x) {\n          int f = -1;\n          REP(k, n+m) {\n            if (p[i].x == p[k].x) v.push_back(p[k]);\n            else {\n              if (f == -1) {\n                f = (p[k].x > p[i].x) ^ p[k].f;\n              } else {\n                if (f != (p[k].x > p[i].x) ^ p[k].f) {\n                  dame = 1;\n                  break;\n                }\n              }\n            }\n          }\n        } else {\n          double a = (p[j].y-p[i].y) / (p[j].x-p[i].x);\n          double b = p[i].y - a*p[i].x;\n\n          //cout << a << \" \" << b << endl;\n          int f = -1;\n          REP(k, n+m) {\n            if (abs(p[k].y - a*p[k].x - b) < EPS) {\n              v.push_back(p[k]);\n            } else {\n              bool ue = p[k].y > a*p[k].x + b;\n              //cout << p[k].f << \" \" << ue  << endl;\n              //cout << ue << \" \" << k <<  \" \" << (p[k].f ^ ue) << endl;\n              if (f == -1) {\n                f = p[k].f ^ ue;\n              } else {\n                if (f != p[k].f ^ ue) {\n                  dame = 1;\n                  break;\n                }\n              }\n            }\n          }\n        }\n        if (!dame) {\n          sort(ALL(v));\n          int f = -1;\n          int state = 0;\n          REP(k, v.size()) {\n            //cout << v[k].x << \" \" << v[k].y << endl;\n            if (f == -1) {\n              f = v[k].f;\n            } else {\n              if (f != v[k].f) {\n                if (state == 0)\n                  state = 1;\n                else {\n                  dame = 1;\n                  break;\n                }\n              }\n            }\n            f = v[k].f;\n          }\n          if (!dame) {\n            //printf(\"%d %d (%f,%f) (%f,%f)\", i, j, p[i].x,p[i].y , p[j].x, p[j].y);\n            break;\n          }\n        }\n      }\n      if (!dame) break;\n    }\n    if (!dame) {\n      cout << \"YES\" << endl;\n    } else {\n      cout << \"NO\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\nusing namespace std;\n\ntypedef complex<double> P;\n\nint n[2];\nvector<vector<P>> p;\ndouble ths[100*50*3];\nbool solve(){\n    if(n[0]==1 && n[1]==1)return true;\n\n    int cnt=0;\n    rep(x,2){\n        rep(i,n[x])rep(j,i){\n            P &p0=p[x][i], &p1=p[x][j];\n            double th=arg(p0-p1);\n            ths[cnt++]=th;\n        }\n    }\n    rep(i,cnt){\n        double th=ths[i];\n        auto before = p;\n        rep(i,2)rep(j,n[i]){\n            p[i][j] /= polar(1. ,th);\n        }\n        double M[2]={-1e20,-1e20}, m[2]={1e20,1e20};\n        rep(i,2)rep(j,n[i]){\n            M[i] = max(M[i],p[i][j].imag());\n            m[i] = min(m[i],p[i][j].imag());\n        }\n        if(M[0] < m[1] || M[1] < m[0]) return true;\n        p = before;\n    }\n    return false;\n}\n\nint main(){\n    while(~scanf(\"%d%d\",&n[0],&n[1]) && n[0]){\n        p={{},{}};\n        rep(i,2){\n            p[i].resize(n[i]);\n            rep(j,n[i]){\n                int x,y;\n                scanf(\"%d%d\",&x,&y);\n                p[i][j] = P(x,y);\n            }\n        }\n        puts(solve() ? \"YES\" : \"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// ------ lib ------ //\n\n#include <cstdio>\n#include <string>\n\n#pragma warning(disable: 4996)\n\nusing namespace std;\nstring ID = \"1\";\n\nFILE *in = freopen((\"./in\" + ID + \".txt\").c_str(), \"r\", stdin);\nFILE *out = freopen((\"./out\" + ID + \".txt\").c_str(), \"w\", stdout);\n\n// ------ end ------ //\n\n#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\nlong double EPS = (long double)1e-7;\nstruct Point { long double px, py; };\nPoint r1[100], r2[100]; int n, m;\nvector<pair<Point, int>>vec, vec2;\ninline bool solve(Point a1, Point a2) {\n\tif (a1.px > a2.px)swap(a1, a2);\n\tif (a1.px == a2.px) {\n\t\tint colour = 0; bool r[3] = { false,false,false };\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tif (r[1] == true && r[2] == true)return false;\n\t\t\tif (colour == 0) {\n\t\t\t\tif (vec2[i].first.px < a1.px) { colour = 3 - vec2[i].second; }\n\t\t\t\telse if (vec2[i].first.px == a1.px) { r[vec2[i].second] = true; }\n\t\t\t\telse if (vec2[i].first.px > a1.px) { colour = vec2[i].second; }\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (colour != 3 - vec2[i].second && vec2[i].first.px < a1.px) { return false; }\n\t\t\t\telse if (vec2[i].first.px == a1.px) { r[vec2[i].second] = true; }\n\t\t\t\telse if (colour != vec2[i].second && vec2[i].first.px > a1.px) { return false; }\n\t\t\t}\n\t\t}\n\t\tif (r[1] == true && r[2] == true)return false;\n\t\treturn true;\n\t}\n\telse {\n\t\tlong double KT = (a2.py - a1.py) / (a2.px - a1.px);\n\t\tlong double YY = a1.py - a1.px*KT;\n\t\tint colour = 0; bool r[3] = { false,false,false };\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tif (r[1] == true && r[2] == true)return false;\n\t\t\tlong double height = YY + KT*vec2[i].first.px;\n\t\t\tif (colour == 0) {\n\t\t\t\tif (vec2[i].first.py < height) { colour = 3 - vec2[i].second; }\n\t\t\t\telse if (vec2[i].first.py == height) { r[vec2[i].second] = true; }\n\t\t\t\telse if (vec2[i].first.py > height) { colour = vec2[i].second; }\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (colour != 3 - vec2[i].second && vec2[i].first.py < height) { return false; }\n\t\t\t\telse if (vec2[i].first.py == height) { r[vec2[i].second] = true; }\n\t\t\t\telse if (colour != vec2[i].second && vec2[i].first.py > height) { return false; }\n\t\t\t}\n\t\t}\n\t\tif (r[1] == true && r[2] == true)return false;\n\t\treturn true;\n\t}\n}\nint main() {\n\twhile (true) {\n\t\tvec.clear(); vec2.clear(); cin >> n >> m; if (n == 0 && m == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> r1[i].px >> r1[i].py; vec2.push_back(make_pair(r1[i], 1));\n\t\t\tfor (long double j = -1.0l; j <= 1.0l; j += 1.0l) {\n\t\t\t\tfor (long double k = -1.0l; k <= 1.0l; k += 1.0l) {\n\t\t\t\t\tvec.push_back(make_pair(Point{ r1[i].px + j*EPS,r1[i].py + k*EPS }, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> r2[i].px >> r2[i].py; vec2.push_back(make_pair(r2[i], 2));\n\t\t\tfor (long double j = -1.0l; j <= 1.0l; j += 1.0l) {\n\t\t\t\tfor (long double k = -1.0l; k <= 1.0l; k += 1.0l) {\n\t\t\t\t\tvec.push_back(make_pair(Point{ r2[i].px + j*EPS,r2[i].py + k*EPS }, 2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans = false;\n\t\tfor (int i = 0; i < vec.size(); i++) {\n\t\t\tfor (int j = i + 1; j < vec.size(); j++) {\n\t\t\t\tif (fabs(vec[i].first.px - vec[j].first.px) + fabs(vec[i].first.py - vec[j].first.py) < EPS * 6)continue;\n\t\t\t\tbool p1 = solve(vec[i].first, vec[j].first);\n\t\t\t\tif (p1 == true) {\n\t\t\t\t\tans = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == true)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\ntypedef complex < double > Point;\n\ntypedef vector < Point > Polygon;\nnamespace std {\n    bool operator < (Point a,Point b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\n\n\nstruct Line : Polygon{\n    Line(){};\n    Line(Point p,Point q){ push_back(p);push_back(q); }\n};\nstruct Circle{\n    Point p;\n    double r;\n    Circle(){};\n    Circle(Point a, double s){ p = a;r = s; }\n};\n\n// ベクタの長さ\ndouble VectorLength(Point a){\n    return abs(a);\n}\n\n// 二点間距離\ndouble DistancePP(Point a,Point b){\n    return abs(a-b);\n}\n\n// 単位ベクトル\nPoint UnitVector(Point a){\n    return a / abs(a);\n}\n\n// 法線ベクトル\npair<Point,Point> NormalVector(Point a){\n    Point n1 = a * Point(0,1);\n    Point n2 = a * Point(0,-1);\n    return make_pair(n1,n2);\n}\n\n//外積\ndouble cross(Point p,Point q){\n    return imag(conj(p)*q);\n}\n\n//内積\ndouble dot(Point p,Point q){\n    return real(conj(p)*q);\n}\n\nint ccw(Point a,Point b,Point c){\n    b-=a,c-=a;\n    if(cross(b,c)>0)return 1; //反時計回り\n    if(cross(b,c)<0)return -1; //時計回り\n    if(dot(b,c)<0)return 2; //直線上に c - a - b\n    if(norm(b)<norm(c))return -2; // 直線上に a - b - c\n    return 0; // 直線上に a - c - b\n}\n\nPoint normalize(Point P, double l){\n    double a = real(P), b = imag(P);\n    double y = sqrt(b*b/(a*a+b*b)*l*l);\n    double x = (a/b)*y;\n\n    return Point(x,y);\n}\n\n//三角形の面積\ndouble TriangleArea(Point A, Point B, Point C){\n    return abs(cross(B-A,C-A)/2);\n}\n\n//多角形の面積\ndouble VertexArea(Polygon v){\n    double ret = 0;\n    for(int i=1;i<v.size()-1;i++){\n        ret += TriangleArea(v[0],v[i],v[i+1]);\n    }\n    return abs(ret);\n}\n\nbool intersectLL(Line l, Line m) {\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // 平行でない\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // 同一の線\n}\nbool intersectLS(Line l, Line s) {\n    return cross(l[1]-l[0], s[0]-l[0])*       // s[0] が lの左\n           cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] が lの右\n}\nbool intersectLP(Line l, Point p) {\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(Line l, Point p);\nbool intersectCS(Circle C,Line l){\n    return (distanceLP(l,C.p) < C.r + EPS and\n             (C.r < abs(C.p-l[0]) + EPS or C.r < abs(C.p-l[1]) + EPS));\n}\n//↓2円の交点二つを返す（ポインタ）,戻り値は交点の個数\nint intersectCC(Circle A, Circle B, Point *p, Point *q){\n\n    Point P,Q;\n    if(B.p < A.p)swap(A.p,B.p);\n    Point dv = B.p - A.p;//ベクトル\n\n\n    double L = sqrt(norm(dv));\n    int num;\n    //距離がLの場合\n    if( L==(A.r + B.r) ){\n        num = 1;\n        //交点1つ\n        //虚数軸に沿って並んでいるとバグる？\n        dv = normalize(dv,A.r);\n        P = Q = Point(real(dv)+real(A.p),imag(dv)+imag(A.p));\n    }\n    else if( L<(A.r + B.r) && L > fabs(A.r - B.r) ){\n        num = 2;\n        //交点2つ\n        /*\n        交点の一方Qからベクトルdvに垂線を下ろしたところをptとする\n        ふたつの直角三角形p0-pt-Q、p1-pt-Qができる\n        p0-pt間の長さをtとすると、これらの三角形のQ-ptの長さは等しいため、\n\n        r0*r0 - t*t = r1*r1 - (L-t)*(L-t)\n        r0*r0 - t*t = r1*r1 - L*L - t*t + 2*L*t\n        t = (r0*r0 - r1*r1 + L*L)/(2*L)\n\n        tから、p0-Qベクトルとdvベクトルとの角度aを求め、\n        dvベクトルから、+a,-aの座標を求めれば交点となる\n        */\n\n        //tを求める\n        double t = 0.5*( A.r*A.r - B.r*B.r + L*L)/L;\n\n        //p0-Qベクトルとdvベクトルの角度\n        double a = acos( t/A.r );\n\n        //dvベクトルの角度\n        double a0 = atan2( imag(dv), real(dv) );\n\n        //交点\n        P = Point( real(A.p) + A.r*cos(a0+a), imag(A.p) + A.r*sin(a0+a) );\n        Q = Point( real(A.p) + A.r*cos(a0-a), imag(A.p) + A.r*sin(a0-a) );\n\n    }\n    else{\n        num = 0;\n        //交点なし\n    }\n\n    *p = P;\n    *q = Q;\n\n    return num;\n}\n/*\n// 直線と点の最短距離を実現する直線の点(垂線の足)(未検証)\npoint nearest_point_line_and_point(point a1,point a2,point b){\n    return a1 + (a2-a1) * dot((a2-a1),(b-a1)) / norm(a2-a1);\n}\n\n// 線分と点の最短距離を実現する線分嬢の点(未検証）\npoint nearest_point_linesegment_and_point(point a1,point a2,point b){\n    if(dot(a2-a1,b-a1) < EPS) return a1;\n    if(dot(a1-a2,b-a2) < EPS) return a2;\n    return nearest_point_line_and_point(a1,a2,b);\n}\n*/\nPoint projection(Line l, Point p) {//射影\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t * (l[0]-l[1]);\n}\nPoint reflection(Line l, Point p) {//反射\n    return p + (projection(l, p) - p) + (projection(l, p) - p);\n}\ndouble distanceLP(Line l, Point p) {\n    return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(Line l, Line s) {\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(Line s, Point p) {\n    const Point r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(Line s, Line t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nPoint crosspoint(Line l, Line m) {\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n    if (abs(A) < EPS);\n    return m[0] + B / A * (m[1] - m[0]);\n}\n/*\ndouble area(Polygon P) {//多角形の面積\n    double A = 0;\n    for (int i = 0; i < P.size(); ++i)\n        A += cross(curr(P, i), next(P, i));\n    return A;\n}\n*/\nPolygon ConvexHull(Polygon ps) {//凸包\n    int n = ps.size(), k = 0;\n    if(n == 1)return ps;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    ch.resize(k-1);\n    return ch;\n}\n\n// Point - Vertex\nenum{OUT, ON, IN};\nint IsInnerPointVertex(Polygon ps,Point a){\n    bool flg = false;\n    for(int i = 0;i < ps.size();i++){\n        Point p = ps[i] - a,q = ps[(i+1)%ps.size()] - a;\n        if(imag(p)>imag(q))swap(p,q);\n        if(imag(p)<=0&&0<imag(q)){\n            if(cross(p,q) < 0)flg = !flg;\n        }\n        if(cross(p,q) == 0 && dot(p,q) <= 0)return ON;\n    }\n    return flg ? IN : OUT;\n}\nint main(){\n    int n,m;\n    while(cin>>n>>m,n){\n        Polygon G,H;\n        for(int i = 0;i < n;i++){\n            double x,y;\n            cin>>x>>y;\n            G.push_back(Point(x,y));\n        }\n        for(int i = 0;i < m;i++){\n            double x,y;\n            cin>>x>>y;\n            H.push_back(Point(x,y));\n        }\n        G = ConvexHull(G);\n        H = ConvexHull(H);\n        int g = G.size(),h = H.size();\n        //cout<<g<<\" \"<<h<<endl;\n        if(g > h)swap(G,H);\n        bool flg = true;\n        for(int i = 0;i < g;i++){\n            if(IsInnerPointVertex(H,G[i]) != OUT){\n                flg = false;\n                break;\n            }\n        }\n        for(int i = 0;i < h;i++){\n            if(IsInnerPointVertex(G,H[i]) != OUT){\n                flg = false;\n                break;\n            }\n        }\n\n        if(h == 1)flg = true;\n        else if(g == 1 && h == 2){\n            flg = !(intersectSP(Line(H[0],H[1]),G[0]));\n        }\n        else if(g == 2 && h == 2){\n            flg = !(intersectSS(Line(G[0],G[1]),Line(H[0],H[1])));\n        }\n        if(flg)cout<<\"YES\"<<endl;\n        else cout<<\"NO\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Hello. I'm Peter.\n#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<functional>\n#include<cctype>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define peter cout<<\"i am peter\"<<endl\n#define input freopen(\"data.txt\",\"r\",stdin)\n#define randin srand((unsigned int)time(NULL))\n#define INT (0x3f3f3f3f)*2\n#define LL (0x3f3f3f3f3f3f3f3f)*2\n#define gsize(a) (int)a.size()\n#define len(a) (int)strlen(a)\n#define slen(s) (int)s.length()\n#define pb(a) push_back(a)\n#define clr(a) memset(a,0,sizeof(a))\n#define clr_minus1(a) memset(a,-1,sizeof(a))\n#define clr_INT(a) memset(a,INT,sizeof(a))\n#define clr_true(a) memset(a,true,sizeof(a))\n#define clr_false(a) memset(a,false,sizeof(a))\n#define clr_queue(q) while(!q.empty()) q.pop()\n#define clr_stack(s) while(!s.empty()) s.pop()\n#define rep(i, a, b) for (int i = a; i < b; i++)\n#define dep(i, a, b) for (int i = a; i > b; i--)\n#define repin(i, a, b) for (int i = a; i <= b; i++)\n#define depin(i, a, b) for (int i = a; i >= b; i--)\n#define pi acos(-1.0)\n#define eps 1e-10\n#define MOD 1000000007\n#define MAXN\n#define N 10100\n#define M\nint dcmp(double x){//蛻、譁ュx豁」雍滓?荳コ0\n    if(fabs(x)<eps) return 0;\n    else if(x<0) return -1;\n    else return 1;\n}\nstruct Point{\n    double x,y;\n    Point(){};\n    Point(double xx,double yy):x(xx),y(yy){};\n    friend bool operator<(const Point a,const Point b){\n        if(dcmp(a.x-b.x)!=0) return a.x<b.x;\n        else return a.y<b.y;\n    }\n};\ntypedef Point Vector;\nvoid readPoint(Point &a){//霎灘?荳?クェ轤ケ\n    scanf(\"%lf %lf\",&a.x,&a.y);\n}\ndouble sq(double x){//x^2\n    return x*x;\n}\nVector operator +(const Vector a,const Vector b){//荳、蜷鷹?逶ク蜉?    return Vector(a.x+b.x,a.y+b.y);\n}\nVector operator -(const Vector a,const Vector b){//荳、蜷鷹?逶ク蜃?    return Vector(a.x-b.x,a.y-b.y);\n}\nbool operator ==(const Vector a,const Vector b){//蛻、譁ュ荳、轤ケ謌紋ク、蜷鷹?譏ッ蜷ヲ荳??\n    return dcmp(a.x-b.x)==0 && dcmp(a.y-b.y)==0;\n}\ndouble operator *(const Vector a,const Vector b){//荳、蜷鷹?轤ケ荵?    return a.x*b.x+a.y*b.y;\n}\ndouble operator &(const Vector a,const Vector b){//荳、蜷鷹?蜿臥ァッ\n    return a.x*b.y-a.y*b.x;\n}\nVector operator *(const Vector b,const double a){//荳?クェ謨ー*荳?クェ蜷鷹?\n    return Vector(a*b.x,a*b.y);\n}\nVector operator *(const double a,const Vector b){//荳?クェ蜷鷹?*荳?クェ謨ー\n    return Vector(a*b.x,a*b.y);\n}\nPoint MiddlePoint(Point a,Point b){//豎ゆク、轤ケ逧?クュ轤ケ\n    return Point((a.x+b.x)/2,(a.y+b.y)/2);\n}\ndouble Length(Vector b){//豎ゆク?クェ蜷鷹?逧?柄蠎ヲ\n    return sqrt(b*b);\n}\ndouble DistancePointToPoint(Point a,Point b){//豎らせ蛻ー轤ケ逧?裏蜷題キ晉ヲサ\n    return Length(a-b);\n}\ndouble DistancePointToLine(Point p,Point a,Vector v){//豎らせ蛻ー郤ソ逧?裏蜷題キ晉ヲサ\n    Vector w=p-a;\n    return fabs((v&w)/Length(v));\n}\nPoint Point_LineBananaLine(Point p1,Vector v,Point p2,Vector w){//豎ゆク、郤ソ逧?コ、轤ケ(蜑肴署譏ッ荳、蜷鷹?荳榊?郤ソ)\n    Vector u=p1-p2;\n    double t=(w&u)/(v&w);\n    return p1+v*t;\n}\ndouble polarAngle(Vector a,Vector b){//豎ゆク、荳ェ蜷鷹?逧?裏蜷第栫隗?0<=x<=pi)\n    double t=(a*b)/Length(a)/Length(b);\n    return acos(t);\n    //閠径tan2(double y,double x)豎ら噪譏ッ荳?クェ蜷鷹?荳支霓エ逧?怏蜷第栫隗?-pi<x<=pi)\n}\nint ConvexHull(Point *p,int n,Point *ch){\n    sort(p,p+n);\n    int m=0;\n    rep(i,0,n){\n        while(m>1 && dcmp((ch[m-1]-ch[m-2])&(p[i]-ch[m-2]))<=0) m--;\n        ch[m++]=p[i];\n    }\n    int k=m;\n    depin(i,n-2,0){\n        while(m>k && dcmp((ch[m-1]-ch[m-2])&(p[i]-ch[m-2]))<=0) m--;\n        ch[m++]=p[i];\n    }\n    ch[m++] = ch[0];\n    if(n>1) m--;\n    return m;\n}\nbool SegmentStrictlyBananaSegment(Point p1,Point p2,Point w1,Point w2){//蛻、譁ュ荳、郤ソ谿オ譏ッ蜷ヲ荳・譬シ鬥呵負(荳榊桁諡ャ遶ッ轤ケ)\n    double x1=(w2-w1)&(p1-w1);\n    double x2=(w2-w1)&(p2-w1);\n    double x3=(p2-p1)&(w1-p1);\n    double x4=(p2-p1)&(w2-p1);\n    return dcmp(x1)*dcmp(x2)<0 && dcmp(x3)*dcmp(x4)<0;\n}\nbool PointInConvex(Point a, Point* ch, int n){\n    int i;\n    if(n==3){\n        if(a.x < min(ch[0].x, ch[1].x) || a.x > max(ch[0].x, ch[1].x)) return false;\n        if(a.y < min(ch[0].y, ch[1].y) || a.y > max(ch[0].y, ch[1].y)) return false;\n    }\n    for(i=1;i<n;i++){\n        if( ((ch[i]-ch[i-1])&(a-ch[i-1])) < 0) return false;\n    }\n    return true;\n}\nint n,m,num_ch1,num_ch2;\nPoint black[N],ch1[N],white[N],ch2[N];\nint main(){\n//    input;\n    while(~scanf(\"%d%d\",&n,&m) && (n+m)){\n        rep(i,0,n){\n            readPoint(black[i]);\n        }\n        num_ch1=ConvexHull(black,n,ch1);\n        rep(i,0,m){\n            readPoint(white[i]);\n        }\n        num_ch2=ConvexHull(white,m,ch2);\n        bool ok=true;\n        if(n==1 && m==1) ok=true;\n        else if(n==1){\n            if(PointInConvex(black[0],ch2,num_ch2)) ok=false;\n            else ok=true;\n        }\n        else if(m==1){\n            if(PointInConvex(white[0],ch1,num_ch1)) ok=false;\n            else ok=true;\n        }\n        //n!=1 && m!=1\n        else{\n            rep(i,0,n){\n                if(!ok) break;\n                if(PointInConvex(black[i],ch2,num_ch2)) ok=false;\n            }\n            rep(i,0,m){\n                if(!ok) break;\n                if(PointInConvex(white[i],ch1,num_ch1)) ok=false;\n            }\n            rep(i,1,num_ch1){\n                if(!ok) break;\n                rep(j,1,num_ch2){\n                    if(SegmentStrictlyBananaSegment(ch1[i],ch1[i-1],ch2[j],ch2[j-1])){\n                        ok=false;\n                        break;\n                    }\n                }\n            }\n        }\n        printf(\"%s\\n\",ok?\"YES\":\"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// ------ Class ------ //\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tbool operator==(const Point& p) const { return px == p.px && py == p.py; }\n\tbool operator!=(const Point& p) const { return px != p.px || py != p.py; }\n\tbool operator<(const Point& p) const { return px < p.px ? true : (px == p.px && py < p.py); }\n\tbool operator>(const Point& p) const { return px > p.px ? true : (px == p.px && py > p.py); }\n\tbool operator<=(const Point& p) const { return !(Point(px, py) > p); }\n\tbool operator>=(const Point& p) const { return !(Point(px, py) < p); }\n\tPoint operator+(const Point& p) const { return Point(px + p.px, py + p.py); }\n\tPoint operator-(const Point& p) const { return Point(px - p.px, py - p.py); }\n\tPoint operator/(long double d) const { return Point(px / d, py / d); }\n\tfriend Point operator*(const Point p, long double d) { return Point(p.px * d, p.py * d); }\n\tfriend Point operator*(long double d, const Point& p) { return p * d; }\n\tPoint& operator+=(const Point& p1) { px += p1.px, py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px, py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d, py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d, py /= d; return *this; }\n};\n\n// ------ Functions ------ //\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint pol(long double r, long double d) { return Point(cosl(d) * r, sinl(d) * r); }\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nvector<Point> convex_hull(vector<Point> v) {\n\tif (v.size() < 3) return v;\n\tsort(v.begin(), v.end());\n\tvector<Point> u = { v[0], v[1] }, l = { v[v.size() - 1], v[v.size() - 2] };\n\tfor (int i = 2; i < v.size(); i++) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], v[i]) >= 0; n--) u.pop_back();\n\t\tu.push_back(v[i]);\n\t}\n\tfor (int i = v.size() - 3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], v[i]) >= 0; n--) l.pop_back();\n\t\tl.push_back(v[i]);\n\t}\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\n// ------ Main ------ //\nint n, m; vector<Point> v1, v2, v3, v4;\nbool ok(int i) {\n\tint u = (i + 1) % v3.size();\n\tfor (int j = 0; j < v4.size(); j++) {\n\t\tif (abs(ccw(v3[i], v3[u], v4[j])) != 1) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tfor (int j = 0; j < v3.size(); j++) {\n\t\tif (i == j || u == j) continue;\n\t\tfor (int k = 0; k < v4.size(); k++) {\n\t\t\tif (ccw(v3[i], v3[u], v3[j]) == ccw(v3[i], v3[u], v4[k])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < v4.size(); j++) {\n\t\tfor (int k = j + 1; k < v4.size(); k++) {\n\t\t\tif (ccw(v3[i], v3[u], v4[j]) != ccw(v3[i], v3[u], v4[k])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\twhile (cin >> n >> m, n + m) {\n\t\tv1.resize(n), v2.resize(m);\n\t\tfor (int i = 0; i < n; i++) cin >> v1[i].px >> v1[i].py;\n\t\tfor (int i = 0; i < m; i++) cin >> v2[i].px >> v2[i].py;\n\t\tv3 = convex_hull(v1), v4 = convex_hull(v2);\n\t\tint x = 0;\n\t\tif (v3.size() == 1 && v4.size() == 1) x = 1;\n\t\tif (v3.size() > 1) {\n\t\t\tint w = ccw(v3[0], v3[1], v4[0]);\n\t\t\tif (abs(w) == 2) {\n\t\t\t\tint f = 1;\n\t\t\t\tfor (int i = 1; i < v4.size(); i++) {\n\t\t\t\t\tif (ccw(v3[0], v3[1], v4[i]) != x) f = 0;\n\t\t\t\t}\n\t\t\t\tif (f) x = 1;\n\t\t\t}\n\t\t}\n\t\tif (v4.size() > 1) {\n\t\t\tint w = ccw(v4[0], v4[1], v3[0]);\n\t\t\tif (abs(w) == 2) {\n\t\t\t\tint f = 1;\n\t\t\t\tfor (int i = 1; i < v3.size(); i++) {\n\t\t\t\t\tif (ccw(v4[0], v4[1], v3[i]) != x) f = 0;\n\t\t\t\t}\n\t\t\t\tif (f) x = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < v3.size(); i++) {\n\t\t\tif (ok(i)) x = 1;\n\t\t}\n\t\tswap(v3, v4);\n\t\tfor (int i = 0; i < v4.size(); i++) {\n\t\t\tif (ok(i)) x = 1;\n\t\t}\n\t\tcout << (x ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tbool operator==(const Point& p) const { return px == p.px && py == p.py; }\n\tbool operator!=(const Point& p) const { return px != p.px || py != p.py; }\n\tbool operator<(const Point& p) const { return px < p.px ? true : (px == p.px && py < p.py); }\n\tbool operator>(const Point& p) const { return px > p.px ? true : (px == p.px && py > p.py); }\n\tbool operator<=(const Point& p) const { return !(Point(px, py) > p); }\n\tbool operator>=(const Point& p) const { return !(Point(px, py) < p); }\n\tPoint operator+(const Point& p) const { return Point(px + p.px, py + p.py); }\n\tPoint operator-(const Point& p) const { return Point(px - p.px, py - p.py); }\n\tPoint operator/(long double d) const { return Point(px / d, py / d); }\n\tfriend Point operator*(const Point p, long double d) { return Point(p.px * d, p.py * d); }\n\tfriend Point operator*(long double d, const Point& p) { return p * d; }\n\tPoint& operator+=(const Point& p1) { px += p1.px, py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px, py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d, py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d, py /= d; return *this; }\n};\n\n// ------ Functions ------ //\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint pol(long double r, long double d) { return Point(cosl(d) * r, sinl(d) * r); }\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nvector<Point> convex_hull(vector<Point> v) {\n\tif (v.size() < 3) return v;\n\tsort(v.begin(), v.end());\n\tvector<Point> u = { v[0], v[1] }, l = { v[v.size() - 1], v[v.size() - 2] };\n\tfor (int i = 2; i < v.size(); i++) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], v[i]) >= 0; n--) u.pop_back();\n\t\tu.push_back(v[i]);\n\t}\n\tfor (int i = v.size() - 3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], v[i]) >= 0; n--) l.pop_back();\n\t\tl.push_back(v[i]);\n\t}\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\n// ------ Main ------ //\nint n, m;\nint main() {\n\twhile (cin >> n >> m, n + m) {\n\t\tvector<Point> v1(n), v2(m);\n\t\tfor (int i = 0; i < n; i++) cin >> v1[i].px >> v1[i].py;\n\t\tfor (int i = 0; i < m; i++) cin >> v2[i].px >> v2[i].py;\n\t\tvector<Point> v3 = convex_hull(v1), v4 = convex_hull(v2);\n\t\tint x = 0;\n\t\tfor (int i = 0; i < v3.size(); i++) {\n\t\t\tint u = (i + 1) % v3.size(), f = 1;\n\t\t\tfor (int j = 0; j < v4.size(); j++) {\n\t\t\t\tif (abs(ccw(v3[i], v3[u], v4[j])) != 1) {\n\t\t\t\t\tf = 0; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f) continue;\n\t\t\tfor (int j = 0; j < v3.size(); j++) {\n\t\t\t\tif (i == j || u == j) continue;\n\t\t\t\tfor (int k = 0; k < v4.size(); k++) {\n\t\t\t\t\tif (ccw(v3[i], v3[u], v3[j]) == ccw(v3[i], v3[u], v4[k])) {\n\t\t\t\t\t\tf = 0; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!f) break;\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tx = 1; break;\n\t\t\t}\n\t\t}\n\t\tcout << (x ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\n\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\n\t\n#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\nint n,m;\nP bp[1000];\nP wp[1000];\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// E¤Ìvfª éFÅ é©Ç¤©`FbN\nbool checkRIghtincludeLine(P a,P b,bool isW){\n    if(isW){\n        for(int i = 0; i < m; i++){\n            if(EQ(a.real(),b.real())){\n                if(wp[i].real()<a.real()&&!EQ(wp[i].real(),a.real()))\n                    return false;\n            }\n            else{\n                // y=d*x+e\n                double d=(a.imag()-b.imag())/(a.real()-b.real());\n                double e=b.imag()-b.real()*d;\n                if(!(d*wp[i].real()+e>wp[i].imag()||EQ(d*wp[i].real()+e,wp[i].imag())))\n                    return false;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            if(EQ(a.real(),b.real())){\n                if(!(bp[i].real()<a.real()&&!EQ(bp[i].real(),a.real())))\n                    return false;\n            }\n            else{\n                // y=d*x+e\n                double d=(a.imag()-b.imag())/(a.real()-b.real());\n                double e=b.imag()-b.real()*d;\n                if((d*bp[i].real()+e>bp[i].imag()||EQ(d*bp[i].real()+e,bp[i].imag())))\n                    return false;\n            }\n        }\n        return true;\n    }\n    else{\n        for(int i = 0; i < n; i++){\n            if(EQ(a.real(),b.real())){\n                if((bp[i].real()<a.real()&&!EQ(bp[i].real(),a.real())))\n                    return false;\n            }\n            else{\n                // y=d*x+e\n                double d=(a.imag()-b.imag())/(a.real()-b.real());\n                double e=b.imag()-b.real()*d;\n                if(!(d*bp[i].real()+e>bp[i].imag()||EQ(d*bp[i].real()+e,bp[i].imag())))\n                    return false;\n            }\n        }\n        for(int i = 0; i < m; i++){\n            if(EQ(a.real(),b.real())){\n                if(!(wp[i].real()<a.real()&&!EQ(wp[i].real(),a.real())))\n                    return false;\n            }\n            else{\n                // y=d*x+e\n                double d=(a.imag()-b.imag())/(a.real()-b.real());\n                double e=b.imag()-b.real()*d;\n                if((d*wp[i].real()+e>wp[i].imag()||EQ(d*wp[i].real()+e,wp[i].imag())))\n                    return false;\n            }\n        }\n        return true;\n    }\n}\n// ¶¤Ìvfª éFÅ é©Ç¤©`FbN\nbool checkLeftincludeLine(P a,P b,bool isW){\n    if(isW){\n        for(int i = 0; i < m; i++){\n            if(EQ(a.real(),b.real())){\n                if(wp[i].real()>a.real()&&!EQ(wp[i].real(),a.real()))\n                    return false;\n            }\n            else{\n                // y=d*x+e\n                double d=(a.imag()-b.imag())/(a.real()-b.real());\n                double e=b.imag()-b.real()*d;\n                if(!(d*wp[i].real()+e<wp[i].imag()||EQ(d*wp[i].real()+e,wp[i].imag())))\n                    return false;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            if(EQ(a.real(),b.real())){\n                if(!(bp[i].real()>a.real()&&!EQ(bp[i].real(),a.real())))\n                    return false;\n            }\n            else{\n                // y=d*x+e\n                double d=(a.imag()-b.imag())/(a.real()-b.real());\n                double e=b.imag()-b.real()*d;\n                if((d*bp[i].real()+e<bp[i].imag()||EQ(d*bp[i].real()+e,bp[i].imag())))\n                    return false;\n            }\n        }\n        return true;\n    }\n    else{\n        for(int i = 0; i < n; i++){\n            if(EQ(a.real(),b.real())){\n                if((bp[i].real()>a.real()&&!EQ(bp[i].real(),a.real())))\n                    return false;\n            }\n            else{\n                // y=d*x+e\n                double d=(a.imag()-b.imag())/(a.real()-b.real());\n                double e=b.imag()-b.real()*d;\n                if(!(d*bp[i].real()+e<bp[i].imag()||EQ(d*bp[i].real()+e,bp[i].imag())))\n                    return false;\n            }\n        }\n        for(int i = 0; i < m; i++){\n            if(EQ(a.real(),b.real())){\n                if(!(wp[i].real()>a.real()&&!EQ(wp[i].real(),a.real())))\n                    return false;\n            }\n            else{\n                // y=d*x+e\n                double d=(a.imag()-b.imag())/(a.real()-b.real());\n                double e=b.imag()-b.real()*d;\n                if((d*wp[i].real()+e<wp[i].imag()||EQ(d*wp[i].real()+e,wp[i].imag())))\n                    return false;\n            }\n        }\n        return true;\n    }\n}\n\nint main(){\n\n    while(cin>>n>>m&&!(n==0&&m==0)){\n        for(int i = 0; i < n; i++){\n            int x,y;\n            cin>>x>>y;\n            bp[i]=P(x,y);\n        }\n        for(int i = 0; i < m; i++){\n            int x,y;\n            cin>>x>>y;\n            wp[i]=P(x,y);\n        }\n        if(n==1&&m==1){\n            cout<<\"YES\"<<endl;\n            continue;\n        }\n        if(m!=1){\n            // 2_ðIñÅ¼üðì¬µAe_ª»Ì¼üÅ®SÉªÅ«é©²×é\n            bool ok=false;\n            for(int i = 0; i < m; i++){\n                for(int j = 0; j < m; j++){\n                    bool isLeft=false;\n                    bool no=false;\n                    // xªêv\n                    if(EQ(wp[i].real(),wp[j].real())){\n                        // Ç¿çÌvfªÇ¿çÉ®·é©\n                        for(int k = 0; k < n; k++){\n                            if(EQ(bp[k].real(),wp[i].real())){\n                                no=true;\n                                break;\n                            }\n                            else{\n                                if(bp[k].real()<wp[i].real()){\n                                    isLeft=true;\n                                    break;\n                                }\n                                else{\n                                    isLeft=false;\n                                    break;\n                                }\n                            }\n                        }\n                        if(no)continue;\n                    }\n                    else{\n                        // y=d*x+e\n                        double d=(wp[i].imag()-wp[j].imag())/(wp[i].real()-wp[j].real());\n                        double e=wp[j].imag()-wp[j].real()*d;\n                        // Ç¿çÌvfªÇ¿çÉ®·é©\n                        for(int k = 0; k < n; k++){\n                            if(EQ(d*bp[k].real()+e,bp[k].imag())){\n                                no=true;\n                                break;\n                            }\n                            else{\n                                if(d*bp[k].real()+e<bp[k].imag()){\n                                    isLeft=true;\n                                    break;\n                                }\n                                else{\n                                    isLeft=false;\n                                    break;\n                                }\n                            }\n                        }\n                        if(no)continue;\n                    }\n                    // ¶Éª®\n                    if(isLeft){\n                        if(checkRIghtincludeLine(wp[i],wp[j],true)){\n                            // ok\n                            ok=true;\n                            break;\n                        }\n                    }\n                    // E\n                    else{\n                        if(checkLeftincludeLine(wp[i],wp[j],true)){\n                            // ok\n                            ok=true;\n                            break;\n                        }\n                    }\n                }\n                if(ok)break;\n            }\n            if(ok){\n                cout<<\"YES\"<<endl;\n                continue;\n            }\n        }\n        if(n!=1){\n            // 2_ðIñÅ¼üðì¬µAe_ª»Ì¼üÅ®SÉªÅ«é©²×é\n            bool ok=false;\n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                    bool isLeft=false;\n                    bool no=false;\n                    // xªêv\n                    if(EQ(bp[i].real(),bp[j].real())){\n                        // Ç¿çÌvfªÇ¿çÉ®·é©\n                        for(int k = 0; k < m; k++){\n                            if(EQ(wp[k].real(),bp[i].real())){\n                                no=true;\n                                break;\n                            }\n                            else{\n                                if(wp[k].real()<bp[i].real()){\n                                    isLeft=true;\n                                    break;\n                                }\n                                else{\n                                    isLeft=false;\n                                    break;\n                                }\n                            }\n                        }\n                        if(no)continue;\n                    }\n                    else{\n                        // y=d*x+e\n                        double d=(bp[i].imag()-bp[j].imag())/(bp[i].real()-bp[j].real());\n                        double e=bp[j].imag()-bp[j].real()*d;\n                        // Ç¿çÌvfªÇ¿çÉ®·é©\n                        for(int k = 0; k < m; k++){\n                            if(EQ(d*wp[k].real()+e,wp[k].imag())){\n                                no=true;\n                                break;\n                            }\n                            else{\n                                if(d*wp[k].real()+e<wp[k].imag()){\n                                    isLeft=true;\n                                    break;\n                                }\n                                else{\n                                    isLeft=false;\n                                    break;\n                                }\n                            }\n                        }\n                        if(no)continue;\n                    }\n                    // ¶Éª®\n                    if(isLeft){\n                        if(checkRIghtincludeLine(bp[i],bp[j],false)){\n                            // ok\n                            ok=true;\n                            break;\n                        }\n                    }\n                    // E\n                    else{\n                        if(checkLeftincludeLine(bp[i],bp[j],false)){\n                            // ok\n                            ok=true;\n                            break;\n                        }\n                    }\n                }\n                if(ok)break;\n            }\n            if(ok){\n                cout<<\"YES\"<<endl;\n                continue;\n            }\n        }\n        cout<<\"NO\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Hello. I'm Peter.\n#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<functional>\n#include<cctype>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define peter cout<<\"i am peter\"<<endl\n#define input freopen(\"data.txt\",\"r\",stdin)\n#define randin srand((unsigned int)time(NULL))\n#define INT (0x3f3f3f3f)*2\n#define LL (0x3f3f3f3f3f3f3f3f)*2\n#define gsize(a) (int)a.size()\n#define len(a) (int)strlen(a)\n#define slen(s) (int)s.length()\n#define pb(a) push_back(a)\n#define clr(a) memset(a,0,sizeof(a))\n#define clr_minus1(a) memset(a,-1,sizeof(a))\n#define clr_INT(a) memset(a,INT,sizeof(a))\n#define clr_true(a) memset(a,true,sizeof(a))\n#define clr_false(a) memset(a,false,sizeof(a))\n#define clr_queue(q) while(!q.empty()) q.pop()\n#define clr_stack(s) while(!s.empty()) s.pop()\n#define rep(i, a, b) for (int i = a; i < b; i++)\n#define dep(i, a, b) for (int i = a; i > b; i--)\n#define repin(i, a, b) for (int i = a; i <= b; i++)\n#define depin(i, a, b) for (int i = a; i >= b; i--)\n#define pi acos(-1.0)\n#define eps 1e-10\n#define MOD 1000000007\n#define MAXN\n#define N 200\n#define M\nint dcmp(double x){//蛻、譁ュx豁」雍滓?荳コ0\n    if(fabs(x)<eps) return 0;\n    else if(x<0) return -1;\n    else return 1;\n}\nstruct Point{\n    double x,y;\n    Point(){};\n    Point(double xx,double yy):x(xx),y(yy){};\n};\nbool operator<(const Point A,const Point B){\n    return A.x < B.x || (A.x == B.x && A.y < B.y);\n}\ntypedef Point Vector;\nvoid readPoint(Point &a){//霎灘?荳?クェ轤ケ\n    cin>>a.x>>a.y;\n}\nVector operator -(const Vector a,const Vector b){//荳、蜷鷹?逶ク蜃?    return Vector(a.x-b.x,a.y-b.y);\n}\ndouble operator &(const Vector a,const Vector b){//荳、蜷鷹?蜿臥ァッ\n    return a.x*b.y-a.y*b.x;\n}\ndouble Cross(Vector A, Vector B) { return A.x*B.y - B.x*A.y; }\nint ConvexHull ( Point* p, int n, Point* ch)\n{\n    sort(p, p+n);\n    int m = 0;\n    for(int i = 0; i<n; i++)\n    {\n        while(m > 1 && Cross( ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0) m--;\n        ch[m++] = p[i];\n    }\n    int k = m;\n    for(int i = n-2; i>=0; i--)\n    {\n        while(m > k && Cross( ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0) m--;\n        ch[m++] = p[i];\n    }\n    ///霑倩ヲ∵隼荳?ク狗函謌仙、夊セケ蠖「縲?    ch[m++] = ch[0];\n    if(n > 1) m--;\n    return m;\n}\nbool SideCross(Point a1, Point a2, Point b1, Point b2)\n{\n    double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1),\n    c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1);\n    return dcmp(c1)*dcmp(c2)<0 && dcmp(c3)*dcmp(c4)<0;\n}\nbool pInConvex(Point a, Point* ch, int n)\n{\n    int i;\n    if(n==3)\n    {\n        if(a.x < min(ch[0].x, ch[1].x) || a.x > max(ch[0].x, ch[1].x)) return 0;\n        if(a.y < min(ch[0].y, ch[1].y) || a.y > max(ch[0].y, ch[1].y)) return 0;\n    }\n    for(i=1;i<n;i++)\n    {\n        if(Cross( ch[i]-ch[i-1], a-ch[i-1] ) < 0 ) return 0;\n    }\n    return 1;\n}\nint n,m,nb,nw;\nPoint black[N],cb[N],white[N],cw[N];\nint solve()\n{\n    int i,j;\n    if(n==1&&m==1) return 1;\n    else if(n==1)\n    {\n        ///謇セ逋ス蟄仙?蛹?、夊セケ蠖「縲ょ愛譁ュ霑吩クェ鮟大ュ先弍蜷ヲ蝨ィ逋ス蛹??\n        nw=ConvexHull(white, m, cw);\n        if(pInConvex(black[0], cw, nw)) return 0;\n    }\n    else if(m==1)\n    {\n        ///謇セ鮟大ュ仙?蛹?、夊セケ蠖「縲ょ愛譁ュ霑吩クェ逋ス蟄先弍蜷ヲ蝨ィ鮟大桁蜀?        nb=ConvexHull(black, n, cb);\n        if(pInConvex(white[0], cb, nb)) return 0;\n    }\n    else\n    {\n        ///謇セ鮟醍區蜃ク蛹?、夊セケ蠖「縲ょ愛譁ュ譏ッ蜷ヲ譛臥コソ谿オ逶ク莠、謌也せ蝨ィ蜿ヲ荳?クェ蜃ク蛹??縲?        nb=ConvexHull(black, n, cb);\n        nw=ConvexHull(white, m, cw);\n        for(i=1;i<nb;i++)\n        {\n            for(j=1;j<nw;j++)\n                if(SideCross( cb[i], cb[i-1], cw[j] ,cw[j-1] )) return 0;\n        }\n        for(i=0;i<n;i++)\n            if(pInConvex(black[i], cw, nw)) return 0;\n        for(i=0;i<m;i++)\n            if(pInConvex(white[i], cb, nb)) return 0;\n    }\n    return 1;\n}\nint main(){\n//    input;\n    while(~scanf(\"%d %d\",&n,&m) && (n+m)){\n        clr(black);\n        clr(white);\n        clr(cb);\n        clr(cw);\n        rep(i,0,n){\n            cin>>black[i].x>>black[i].y;\n        }\n        rep(i,0,m){\n            cin>>white[i].x>>white[i].y;\n        }\n//        bool ok=true;\n//        if(n==1 && m==1) ok=true;\n//        else if(n==1){\n//            num_ch2=ConvexHull(white,m,ch2);\n//            if(pInConvex(black[0],ch2,num_ch2)) ok=false;\n//            else ok=true;\n//        }\n//        else if(m==1){\n//            num_ch1=ConvexHull(black,n,ch1);\n//            if(pInConvex(white[0],ch1,num_ch1)) ok=false;\n//            else ok=true;\n//        }\n//        //n!=1 && m!=1\n//        else{\n//            num_ch1=ConvexHull(black,n,ch1);\n//            num_ch2=ConvexHull(white,m,ch2);\n//            rep(i,1,num_ch1){\n//                if(!ok) break;\n//                rep(j,1,num_ch2){\n//                    if(SideCross(ch1[i],ch1[i-1],ch2[j],ch2[j-1])){\n//                        ok=false;\n//                        break;\n//                    }\n//                }\n//            }\n//            rep(i,0,n){\n//                if(!ok) break;\n//                if(pInConvex(black[i],ch2,num_ch2)) ok=false;\n//            }\n//            rep(i,0,m){\n//                if(!ok) break;\n//                if(pInConvex(white[i],ch1,num_ch1)) ok=false;\n//            }\n//        }\n        bool ok=solve();\n        printf(\"%s\\n\",ok?\"YES\":\"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a; i<(int)b; i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef complex<double> P;\n\nnamespace std {\n  bool operator < (P const& a, P const& b) {\n    if(real(a) != real(b)) return real(a) < real(b);\n    return imag(a) < imag(b);\n  }\n}\n\ndouble const EPS = 1e-10;\n\n#define prev(G, i) ( G[((i-1)+G.size())%G.size()] )\n#define curr(G, i) ( G[i%G.size()] )\n#define next(G, i) ( G[(i+1)%G.size()] )\n\ndouble dot(P const& a, P const& b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(P const& a, P const& b) {\n  return imag(conj(a)*b);\n}\n\ntypedef vector<P> Polygon;\n\nPolygon convex_hull(vector<P> ps) {\n  sort(ps.begin(), ps.end());\n  int N = ps.size(), k = 0;\n  vector<P> qs(N*2);\n  rep(i, N) {\n    while(k > 1 && cross(qs[k-1]-qs[k-2], ps[i]-ps[k-1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  for(int i=N-2, t=k; i>=0; i--) {\n    while(k > t && cross(qs[k-1]-qs[k-2], ps[i]-qs[k-1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nenum { counter_clock_wise=+1, clockwise=-1, cab_online=+2, abc_online=-2 };\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if(cross(b, c) > 0) return counter_clock_wise;\n  if(cross(b, c) < 0) return clockwise;\n  if(dot(b, c) < 0) return cab_online;\n  if(norm(b) < norm(c)) return abc_online;\n  return 0;\n}\n\nstruct Line : public vector<P>\n{\n  Line(P const& a, P const& b) {\n    push_back(a), push_back(b);\n  }\n};\n\ntypedef Line Segment;\n\nbool is_intersect_ss(Segment const& s, Segment const& t) {\n  return ( ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) < EPS )\n    && ( ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) < EPS );\n}\n\n// contain: 2, on segment: 1, the other case: 0\nint contains(Polygon const& G, P const& p) {\n  bool x = false;\n  for(int i=0; i<(int)G.size(); i++) {\n    P v1 = curr(G, i)-p, v2 = next(G, i) - p;\n    if( v1.imag() > v2.imag() ) swap(v1, v2);\n    if( v1.imag() <= 0 && 0 < v2.imag() && cross(v1, v2) > 0 ) x = !x;\n    if( cross(v1, v2) == 0 && dot(v1, v2) <= 0 ) return 1;\n  }\n  return (x?2:0);\n}\n\nint main() {\n\n  int N, M;\n  while(cin >> N >> M && (N|M)) {\n    Polygon G1(N), G2(M);\n    rep(i, N) cin >> G1[i].real() >> G1[i].imag(); \n    rep(i, M) cin >> G2[i].real() >> G2[i].imag(); \n    \n    G1 = convex_hull(G1); N = G1.size();\n    G2 = convex_hull(G2); M = G2.size();\n    //    cout << \"convex hull\\n\";\n    bool ok = !contains(G1, G2[0]) && !contains(G2, G1[0]);\n    rep(i, N) {\n      rep(j, M) {\n\tSegment s1 = Segment(curr(G1, i), next(G1, i));\n\tSegment s2 = Segment(curr(G2, j), next(G2, j));\n\tif(is_intersect_ss(s1, s2)) { ok = 0; }\n      }\n    }\n    \n    cout << (ok ? \"YES\\n\" : \"NO\\n\");\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int INF = 19191919;\n\nstruct Point{\n    int x,y;\n};\n\nbool solve(int n, int m){\n    vector<Point> b(n),w(m);\n    rep(i,n) cin >>b[i].x >>b[i].y;\n    rep(i,m) cin >>w[i].x >>w[i].y;\n\n    int blx = INF, brx = -INF;\n    int bly = INF, bry = -INF;\n    int wlx = INF, wrx = -INF;\n    int wly = INF, wry = -INF;\n    rep(i,n){\n        blx = min(blx, b[i].x);\n        brx = max(brx, b[i].x);\n        bly = min(bly, b[i].y);\n        bry = max(bry, b[i].y);\n    }\n    rep(i,m){\n        wlx = min(wlx, w[i].x);\n        wrx = max(wrx, w[i].x);\n        wly = min(wly, w[i].y);\n        wry = max(wry, w[i].y);\n    }\n\n    if(brx<wlx || wrx<blx) return true;\n    if(bry<wly || wry<bly) return true;\n\n    rep(i,n)rep(j,m){\n        int A = w[j].y - b[i].y;\n        int B = b[i].x - w[j].x;\n        int C = b[i].y*w[j].x - b[i].x*w[j].y;\n\n        bool ok = true;\n\n        int bp = 0, bm = 0;\n        rep(k,n)if(k != i){\n            int v = A*b[k].x + B*b[k].y + C;\n            if(v==0) ok = false;\n\n            if(v>0) ++bp;\n            else ++bm;\n        }\n\n        int wp = 0 , wm = 0;\n        rep(k,m)if(k != j){\n            int v = A*w[k].x + B*w[k].y + C;\n            if(v==0) ok = false;\n\n            if(v>0) ++wp;\n            else ++wm;\n        }\n\n        if(bp>0 && bm>0) ok = false;\n        if(wp>0 && wm>0) ok = false;\n        if(bp>0 && wp>0) ok = false;\n        if(bm>0 && wm>0) ok = false;\n\n        if(ok) return true;\n    }\n\n    return false;\n}\n\nint main(){\n    int n,m;\n    while(cin >>n >>m,n) cout << (solve(n,m)?\"YES\":\"NO\") << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){x=y=0;}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nbool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n\n  if(cross(a1-a2,b1-b2)==0){\n    return is_point_on_line(a1,a2,b1) || is_point_on_line(a1,a2,b2) \n        || is_point_on_line(b1,b2,a1) || is_point_on_line(b1,b2,a2);\n  }\n  else {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n           ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n  }\n}\n\nint contain(point p, vector<point> ps){\n  point a(p.x,p.y),b(1000000,p.y);//適当に大きな値に直す。\n\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<ps.size();i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(a.y<=ymn||a.y>=ymx)return 0;\n\n  int cnt1=0;\n  for(int i=0;i<ps.size();i++)\n    if(is_point_on_line(a,b,ps[i]))cnt1++;\n  \n  int cnt=0;\n  for(int i=0;i<ps.size();i++)\n    if(is_intersected_ls(ps[i],ps[(i+1)%ps.size()],a,b))cnt++;\n\n  return (cnt-cnt1)%2;\n}\n\n/*\n多角形の交差判定\n\n多角形同士が交差していれば 1\nそうでなければ 0\n\nを返す。\n*/\nint crossPol(vector<point> pol1, vector<point> pol2){\n  int szpol1=pol1.size();\n  int szpol2=pol2.size();\n  \n  for(int i=0;i<szpol1;i++)\n    if(contain(pol1[i],pol2))return 1;\n  \n  for(int i=0;i<szpol2;i++)\n    if(contain(pol2[i],pol1))return 1;\n\n  pol1.push_back(pol1[0]);\n  pol2.push_back(pol2[0]);\n  \n  for(int i=0;i<szpol1;i++)\n    for(int j=0;j<szpol2;j++)\n      if(is_intersected_ls(pol1[i],pol1[i+1],pol2[j],pol2[j+1]))return 1;\n  \n  return 0;\n}\n\nvector<point>convex_hull(point* ps, int n){\n  sort(ps,ps+n,cmp_x);\n  int k=0;\n  vector<point>qs(n*2);\n \n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0)k--;\n    qs[k++]=ps[i];\n  }\n \n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0)k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nint main(void){\n  int n,m;\n  point black[100],white[100];\n\n  while(cin >> n >> m,n|m){\n\n    for(int i=0;i<n;i++)\n      cin >> black[i].x >> black[i].y;\n    \n    for(int i=0;i<m;i++)\n      cin >> white[i].x >> white[i].y;\n\n    if(n<2||m<2){\n      if(n<2 && m<2)cout << \"YES\" << endl;\n      else {\n\tbool fg=false;\n\tfor(int i=0;i<n;i++){\n\t  for(int j=0;j<m;j++){\n\t    if(is_intersected_ls(black[i],black[(i+1)%n],\n\t\t\t\t white[j],white[(j+1)%n]))fg=true;\n\t  }\n\t}\n\tif(fg)cout <<\"NO\"<<endl;\n\telse cout << \"YES\" << endl;\n      }\n      continue;\n    }\n\n    vector<point>Black,White;\n\n    Black=convex_hull(black,n);\n    White=convex_hull(white,m);\n    \n    if(crossPol(Black,White))cout << \"NO\" << endl;\n    else cout << \"YES\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#define eps 1e-8\n#define LL long long\nusing namespace std;\ntypedef struct point {\n    LL x,y;\n    point(LL x=0,LL y=0):x(x),y(y) { }\n} Vector;\nVector operator  + (Vector A,Vector B) {\n    return Vector(A.x+B.x,A.y+B.y);\n}\nVector operator  -  (point A,point B) {\n    return Vector(A.x-B.x,A.y-B.y);\n}\nVector operator  *  (Vector A,double p) {\n    return Vector(A.x*p,A.y*p);\n}\nLL xmult(point a,point b,point c) {\n    return (a.x-c.x)*(b.y-c.y)-(a.y-c.y)*(b.x-c.x);\n}\nLL multi(point a,point b,point c) {\n    return (a.x-c.x)*(b.x-c.x)+(a.y-c.y)*(b.y-c.y);\n}\nint dcmp(LL x) {\n    if (x==0) return 0;\n    return x<0?-1:1;\n}\nbool cmp(point a,point b) {\n    if (a.y<b.y) return 1;\n    else if (a.y==b.y&&a.x<b.x) return 1;\n    else return 0;\n}\nint convex(point *p,point *con,int len) {\n    sort(p,p+len,cmp);\n    int top;\n    con[0]=p[0],con[1]=p[1],top=1;\n    for (int i=2; i<len; i++) {\n        while (xmult(con[top],p[i],con[top-1])<0&&top>0) top--;\n        con[++top]=p[i];\n    }\n    int top1=top;\n    con[++top]=p[len-2];\n    for (int i=len-3; i>=0; i--) {\n        while (xmult(con[top],p[i],con[top-1])<0&&top>top1) top--;\n        con[++top]=p[i];\n    }\n    return top;\n}\nLL area(point *p,int len) {\n    LL ans=0;\n    for (int i=2; i<len-1; i++) ans+=abs(xmult(p[i-1],p[i],p[i-2]));\n    return ans;\n}\nbool SegmentProperIntersection(point a1,point a2,point b1,point b2) {\n    LL c1=xmult(a2,b1,a1),c2=xmult(a2,b2,a1);\n    LL c3=xmult(b2,a1,b1),c4=xmult(b2,a2,b1);\n    return (dcmp(c1)*dcmp(c2)<0)&&(dcmp(c3)*dcmp(c4)<0);\n}\nbool Onsegment(point P,point a1,point a2) {\n    return dcmp(xmult(a1,a2,P))==0&&dcmp(multi(a1,a2,P))<0;\n}\nint n,m;\npoint p1[211],p2[211],c1[211],c2[211];\nint main() {\n    //freopen(\"1.txt\",\"w\",stdout);\n    while (~scanf(\"%d%d\",&n,&m)) {\n        if (n==0&&m==0) break;\n        for (int i=0; i<n; i++) scanf(\"%lld%lld\",&p1[i].x,&p1[i].y);\n        for (int i=0; i<m; i++) scanf(\"%lld%lld\",&p2[i].x,&p2[i].y);\n        if (n>1) n=convex(p1,c1,n);\n        else c1[0]=p1[0];\n        if (m>1) m=convex(p2,c2,m);\n        else c2[0]=p2[0];\n        //for (int i=0;i<n;i++) printf(\"%lld %lld\\n\",c1[i].x,c1[i].y);\n        if (n>2) c1[n++]=c1[0];\n        if (m>2) c2[m++]=c2[0];\n        bool flag=1;\n        for (int i=1; i<n; i++)\n            for (int j=1; j<m; j++) {\n                if (SegmentProperIntersection(c1[i],c1[i-1],c2[j],c2[j-1])) flag=0;\n                if (Onsegment(c1[i],c2[j],c2[j-1])) flag=0;\n                if (Onsegment(c1[i-1],c2[j],c2[j-1])) flag=0;\n                if (Onsegment(c2[j],c1[i],c1[i-1])) flag=0;\n                if (Onsegment(c2[j-1],c1[i],c1[i-1])) flag=0;\n            }\n        if (n==1) {\n            for (int i=1;i<m;i++)\n                if (Onsegment(c1[0],c2[i],c2[i-1])) flag=0;\n        }\n        if (m==1) {\n            for (int i=1;i<n;i++)\n                if (Onsegment(c2[0],c1[i],c1[i-1])) flag=0;\n        }\n        if (flag) {\n            LL s=area(c1,n);\n            if (s>0) {\n                LL cnt=0;\n                for (int i=1;i<n;i++) cnt+=abs(xmult(c1[i],c1[i-1],c2[0]));\n                if (cnt==s) flag=0;\n            }\n            s=area(c2,m);\n            if (s>0) {\n                LL cnt=0;\n                for (int i=1;i<m;i++) cnt+=abs(xmult(c2[i],c2[i-1],c1[0]));\n                if (cnt==s) flag=0;\n            }\n        }\n        if (flag) printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef vector<P> Pol;\n\nconst double INF = 1e40;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\n\nint sig(double r) {return (r < -EPS) ? -1 : (r > EPS) ? 1: 0;}\nbool eq(double a, double b) {return abs(a - b) < EPS;}\nbool near(P a, P b) {return abs(b - a) < EPS;}\ndouble dot(P a, P b) {return a.X * b.X + a.Y * b.Y;}\ndouble cross(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nP vec(L a) {return a.second - a.first;}\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\nint ccw(L s, P p) {\n  P a = vec(s);\n  p -= s.first;\n  double cr = cross(a, p);\n  if (eq(cr, 0)) {\n    if (sig(dot(a, p)) < 0) return BACK;\n    if (sig(norm(a) - norm(p)) < 0) return FRONT;\n    return ON;\n  }\n  return (cr > 0) ? LEFT : RIGHT;\n}\nbool iSS(L a, L b) {\n  int cwa = ccw(a, b.first) | ccw(a, b.second);\n  int cwb = ccw(b, a.first) | ccw(b, a.second);\n  if ((cwa | cwb) & ON) return true;\n  return (cwa & cwb) == (LEFT | RIGHT);\n}\nbool iLSs(L a, L b) {return sig(cross(vec(a), b.first - a.first)) * sig(cross(vec(a), b.second - a.first)) < 0;}\nP pLL(L a, L b) {return a.first + vec(a) * (cross(vec(b), b.first - a.first) / cross(vec(b), vec(a)));}\nbool lessX(P a, P b){\n  if(!eq(a.X, b.X)) return a.X < b.X;\n  if(!eq(a.Y, b.Y)) return a.Y < b.Y;\n  return false;\n}\nint sGP(Pol pol, P p) {\n  int side = -1;\n  rep (i, pol.size()) {\n    P p0 = pol[i] - p, p1 = pol[(i + 1) % pol.size()] - p;\n    if (sig(cross(p0, p1)) == 0 && sig(dot(p0, p1)) <= 0) return 0;\n    if (p0.Y > p1.Y) swap(p0, p1);\n    if (sig(p0.Y) <= 0 && 0 < sig(p1.Y) && sig(cross(p0, p1)) > 0) side *= -1;\n  }\n  return side;\n}\nint sVP(Pol pol, P p) {\n  int bit = 0;\n  rep (i, pol.size()) {\n    bit |= ccw(L(pol[i], pol[(i + 1) % pol.size()]), p);\n    if (bit & ON) return 0;\n  }\n  if (__builtin_popcount(bit) == 1) return 1;\n  return -1;\n}\nvector<P> convexHull(vector<P> p) {\n  int m = 0;\n  vector<P> q(p.size() * 2);\n  sort(p.begin(), p.end(), lessX);\n  for (int i = 0; i < int(p.size()); q[m++] = p[i++]) for (; m > 1 && sig(cross(q[m - 1] - q[m - 2], p[i] - q[m - 2])) <= 0; --m);\n  for (int i = p.size() - 2, r = m; i >= 0; q[m++] = p[i--]) for (; m > r && sig(cross(q[m - 1] - q[m - 2], p[i] - q[m - 2])) <= 0; --m);\n  q.resize(m - 1);\n  return q;\n}\n\nint main() {\n  int n, m;\n  for (;;) {\n    cin >> n >> m;\n    if (n == 0 && m == 0) break;\n    Pol white, black;\n    rep (i, n) {\n      P p;\n      cin >> p.X >> p.Y;\n      white.push_back(p);\n    }\n    rep (i, m) {\n      P p;\n      cin >> p.X >> p.Y;\n      black.push_back(p);\n    }\n    Pol wc = convexHull(white);\n    Pol bc = convexHull(black);\n    if (wc.size() == 0u) wc = white;\n    if (bc.size() == 0u) bc = black;\n    if (bc.size() >= 2u) {\n      rep (i, wc.size()) {\n\tif (sVP(bc, wc[i]) >= 0) goto aaa;\n      }\n    }\n    if (wc.size() >= 2u) {\n      rep (i, bc.size()) {\n\tif (sVP(wc, bc[i]) >= 0) goto aaa;\n      }\n    }\n    if (wc.size() >= 2u && bc.size() >= 2u) {\n      rep (i, wc.size()) rep (j, bc.size()) {\n\tif (iSS(L(wc[i], wc[(i + 1) % wc.size()]), L(bc[j], bc[(j + 1) % bc.size()]))) goto aaa;\n      }\n    } else if (wc.size() == 1u && bc.size() == 1u) {\n      if (near(wc[0], bc[0])) goto aaa;\n    }\n    cout << \"YES\" << endl;\n    continue;\n  aaa:;\n    cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef pair<int,int> P;\n\n//for vector\ninline int norm(P a){ return a.fs*a.fs + a.sc*a.sc; }\ninline int dot(P a, P b){return a.fs*b.fs + a.sc*b.sc;}\ninline int cross(P a, P b){return a.fs*b.sc - a.sc*b.fs;}\n\nint ccw(P a,P b,P c){\n  b.fs -= a.fs; b.sc -= a.sc;\n  c.fs -= a.fs; c.sc -= a.sc;\n  if (cross(b,c)>0) return 1;   //counter clockwise\n  if (cross(b,c)<0) return -1; //clockwise\n  if (dot(b, c)<-0) return 2;   //c--a--b on line\n  if (norm(b)<norm(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nint main(){\n  int n,m;\n  P b[110],w[110];\n  while(cin >> n >> m, n||m){\n    rep(i,n)cin >> b[i].fs >> b[i].sc;\n    rep(i,m)cin >> w[i].fs >> w[i].sc;\n\n    bool ans = false;\n    rep(i,n)rep(j,i){\n      bool f = true;\n      set<int> dirb;\n      rep(k,n){\n\tif(k==i || k==j)continue;\n\tint tmp = ccw(b[i],b[j],b[k]);\n\tif(tmp == 0){f = false; break;}\n\tif(abs(tmp)==1)dirb.insert(tmp);\n      }\n      if(dirb.size()==2)f = false;\n\n      set<int> dirw;\n      rep(k,m){\n\tint tmp = ccw(b[i],b[j],w[k]);\n\tif(abs(tmp) != 1){f = false; break;}\n\tdirw.insert(tmp);\n      }\n      if(dirw.size()==2)f = false;\n      if(f && (dirb.size()==0 || dirw.size()==0\n\t       || *dirb.begin() != *dirw.begin()))ans = true;\n    }\n\n    rep(i,m)rep(j,i){\n      bool f = true;\n      set<int> dirw;\n      rep(k,m){\n\tif(k==i || k==j)continue;\n\tint tmp = ccw(w[i],w[j],w[k]);\n\tif(tmp == 0){f = false; break;}\n\tif(abs(tmp)==1)dirw.insert(tmp);\n      }\n      if(dirw.size()==2)f = false;\n\n      set<int> dirb;\n      rep(k,n){\n\tint tmp = ccw(w[i],w[j],b[k]);\n\tif(abs(tmp) != 1){f = false; break;}\n\tdirb.insert(tmp);\n      }\n      if(dirb.size()==2)f = false;\n      if(f && (dirb.size()==0 || dirw.size()==0\n\t       || *dirb.begin() != *dirw.begin()))ans = true;\n    }\n\n    rep(i,n)rep(j,m){\n      bool f = true;\n      set<int> dirb;\n      rep(k,n){\n\tif(k==i)continue;\n\tint tmp = ccw(b[i],w[j],b[k]);\n\tif(tmp == 0 || tmp == -2){f = false; break;}\n\tif(abs(tmp)==1)dirb.insert(tmp);\n\tdirb.insert(tmp);\n      }\n      if(dirb.size()==2)f = false;\n\n      set<int> dirw;\n      rep(k,m){\n\tif(k==j)continue;\n\tint tmp = ccw(b[i],w[j],w[k]);\n\tif(tmp == 0 || tmp == 2){f = false; break;}\n\tif(abs(tmp)==1)dirw.insert(tmp);\n      }\n      if(dirw.size()==2)f = false;\n\n      if(f && (dirb.size()==0 || dirw.size()==0\n\t       || *dirb.begin() != *dirw.begin()))ans = true;\n    }\n\n    cout << (ans?\"YES\":\"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DEBUG 1\n\n#define INF (1.0/0.0)\n#define EPS 1e-8\n#define PI 3.1415926535\n#define EQ(x, y) (abs((x)-(y))<EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> Point;\ntypedef Point Vec;\ntypedef array<Point, 2> Line;\ntypedef vector<Point> Poly;\n\nstruct Circle {\n  Point c;\n  double r;\n};\n\nenum Geometory {ABC=-2, CW, ON_LINE, CCW, CAB, OUTSIDE, INSIDE, ERROR}; \n\nnamespace std {\n  bool operator<(Point a, Point b) {\n    if (!EQ(a.X, b.X)) return a.X < b.X;\n    if (!EQ(a.Y, b.Y)) return a.Y < b.Y;\n    return false;\n  }\n\n  bool operator>(Point a, Point b) {\n    return b<a;\n  }\n\n  bool operator<=(Point a, Point b) {\n    return !(a>b);\n  }\n}\n\ndouble dot(Point a, Point b) {\n  return (conj(a)*b).X;\n}\n\ndouble cross(Point a, Point b) {\n  return (conj(a)*b).Y;\n}\n\nGeometory ccw(Point a, Point b, Point c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > EPS) return CCW; // ccw\n  if (cross(b, c) < -EPS) return CW; // cw\n  if (dot(b, c) < 0) return CAB; // c - a - b\n  if (norm(b) < norm(c)) return ABC; // a - b - c\n  return ERROR;\n}\n\nPoint proj(Line l, Point p) {\n  Point v = l[1]-l[0];\n  double ratio = dot(v, p-l[0]) / norm(v);\n  return l[0] + ratio*v;\n}\n\nPoint refl(Line l, Point p) {\n  return p + (proj(l, p) - p) * 2.0;\n}\n\nVec rotate(Vec v, double r) {\n  return v*Vec(cos(r), sin(r));\n}\n\nbool IsOrthogonal(Line l, Line m) {\n  Vec v1 = l[1]-l[0];\n  Vec v2 = m[1]-m[0];\n  return EQ(dot(v1, v2), 0.0);\n}\n\nbool IsParallel(Line l, Line m) {\n  Vec v1 = l[1]-l[0];\n  Vec v2 = m[1]-m[0];\n  return EQ(cross(v1, v2), 0.0);\n}\n\nbool IntersectLL(Line l, Line m) {\n  if (!EQ(cross(l[1]-l[0], m[1]-m[0]), 0.0)) return true;\n  if (EQ(cross(l[1]-l[0], m[0]-l[0]), 0.0)) return true;\n  return false;\n}\n\nbool IntersectLS(Line l, Line s) {\n  Point b = l[0];\n  Vec v = l[1]-l[0];\n  return cross(v, s[0]-b)*cross(v, s[1]-b) < EPS;\n}\n\nbool IntersectSS(Line s, Line t) {\n  if (ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) > 0) return false;\n  if (ccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) > 0) return false;\n  return true;\n}\n\nbool IntersectLP(Line l, Point p) {\n  return EQ(cross(l[1]-p, l[0]-p), 0.0);\n}\n\nbool IntersectSP(Line s, Point p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n\ndouble DistL(Line l) {\n  return abs(l[0]-l[1]);\n}\n\ndouble DistLP(Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\ndouble DistLL(Line l, Line m) {\n  if (!IntersectLL(l, m)) return 0;\n  return DistLP(l, m[0]);\n}\n\ndouble DistLS(Line l, Line s) {\n  if (IntersectLS(l, s)) return 0;\n  return min(DistLP(l, s[0]), DistLP(l, s[1]));\n}\n\ndouble DistSP(Line s, Point p) {\n  Point r = proj(s, p);\n  if (IntersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0]-p), abs(s[1]-p));\n}\n\ndouble DistSS(Line s, Line t) {\n  if (IntersectSS(s, t)) return 0;\n\n  double a = min(DistSP(s, t[0]), DistSP(s, t[1]));\n  double b = min(DistSP(t, s[0]), DistSP(t, s[1]));\n  return min(a, b);\n}\n\nLine PerpendBisect(Line seg) {\n  Point mid = (seg[0]+seg[1])/2.0;\n  return Line{mid, mid+(seg[1]-seg[0])*Vec(0, 1)};\n}\n\nPoint CrossPointLL(Line l, Line m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0];\n  if (abs(A) < EPS) assert(0);\n  return m[0] + B / A * (m[1]-m[0]);\n}\n\nvector<Point> CrossPointCL(Circle c, Line l) {\n  vector<Point> ret;\n  double d = DistLP(l, c.c);\n  if (d < c.r + EPS) {\n    double ratio = (d > c.r) ? 0.0 : sqrt(c.r*c.r - d*d);\n    Vec sgn = (l[0]-l[1]) / abs(l[0]-l[1]);\n    ret.emplace_back(proj(l, c.c) + ratio*sgn);\n    ret.emplace_back(proj(l, c.c) - ratio*sgn);\n  }\n  return ret;\n}\n\nvector<Point> CrossPointCS(Circle c, Line s) {\n  vector<Point> ret;\n  vector<Point> res = CrossPointCL(c, s);\n  if (s[0] > s[1]) swap(s[0], s[1]);\n  for (Point p : res) {\n    if (s[0] <= p && p <= s[1]) ret.emplace_back(p);\n  }\n  return ret;\n}\n\nvector<Point> CrossPointCC(Circle c1, Circle c2) {\n  vector<Point> ret;\n  double d = abs(c1.c - c2.c);\n  double rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n  double dfr = c1.r*c1.r - rc*rc;\n\n  if (EQ(dfr, 0.0)) dfr = 0.0;\n  else if(dfr < 0.0) return ret;\n\n  double rs = sqrt(dfr);\n  Vec sgn = (c2.c - c1.c) / d;\n  ret.emplace_back(c1.c + sgn*Point(rc, rs));\n  if (dfr > 0.0) ret.emplace_back(c1.c + sgn*Point(rc, -rs));\n  return ret;\n}\n\n// Get the intersection of a circle and a segment, which is obviously a segment\nLine CapCS(Circle c, Line s) {\n  Point inf(INF, INF);\n  vector<Point> cros = CrossPointCS(c, s);\n  if (cros.empty()) return Line{inf, inf};\n\n  if (cros.size() == 1) {\n    double ad = abs(s[0]-c.c);\n    double bd = abs(s[1]-c.c);\n    if (ad < min(bd, c.r)) cros.push_back(s[0]);\n    else if (bd < min(ad, c.r)) cros.push_back(s[1]);\n    else {\n      Point p = cros[0];\n      cros.push_back(p); // avoid an undefined behavior\n    }\n  }\n\n  if (cros[1] < cros[0]) {\n    swap(cros[0], cros[1]);\n  }\n\n  return Line{cros[0], cros[1]};\n}\n\n// Note that ccw(a, b, c) != CCW when a, b, c are colinear\nPoly GrahamScan(vector<Point> ps) {\n  if (ps.size() <= 2) return ps;\n\n  int k = 0;\n  int n = ps.size();\n  Poly ret(n*2);\n\n  sort(ps.begin(), ps.end());\n  for (int i=0; i<n; i++) {\n    while (k > 1 && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n    ret[k++] = ps[i];\n  }\n\n  int k_ = k;\n  for (int i=n-1; i>=0; i--) {\n    while (k > k_ && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n    ret[k++] = ps[i];\n  }\n\n  ret.resize(k-1);\n  return ret;\n}\n\ndouble CalcArea(Poly ps) {\n  double ret = 0.0;\n  for (int i=0; i<ps.size(); i++) {\n    ret += cross(ps[i], ps[(i+1)%ps.size()]);\n  }\n  return ret/2.0;\n}\n\nbool IsConvex(Poly ps) {\n  return GrahamScan(ps).size() == ps.size();\n}\n\nGeometory ContainsPoint(Poly poly, Point p) {\n  bool in = false;\n  int n = poly.size();\n  for (int i=0; i<n; i++) {\n    Point a = poly[i];\n    Point b = poly[(i+1)%n];\n    Vec u = a - p;\n    Vec v = b - p;\n\n    if (u.Y > v.Y) swap(u, v);\n\n    double cr = cross(u, v);\n    if (u.Y <= 0 && 0 < v.Y && cr > EPS) in ^= 1;\n    if (IntersectSP({a, b}, p)) return ON_LINE;\n  }\n\n  if (in) return INSIDE;\n  return OUTSIDE;\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\npair<int, int> ConvexDiameterApexes(Poly ps) {\n#if DEBUG\n  assert (IsConvex(ps));\n#endif\n\n  int n = ps.size();\n  int is = 0;\n  int js = 0;\n  for (int i=1; i<n; i++) {\n    if (ps[i].Y > ps[is].Y) is = i;\n    if (ps[i].Y < ps[js].Y) js = i;\n  }\n\n  int maxi, maxj;\n  double maxd = norm(ps[is]-ps[js]);\n  int i = is;\n  int j = js;\n  do {\n    Vec a = ps[i+1] - ps[i];\n    Vec b = ps[j+1] - ps[j];\n    if (cross(a, b) > -EPS) j = (j+1)%n;\n    else i = (i+1)%n;\n\n    double d = norm(ps[i]-ps[j]);\n    if (d > maxd) {\n      maxd = d;\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n\n  return make_pair(maxi, maxj);\n}\n\nLine ClosestPair(vector<Point> ps) {\n  auto CompareY = [](const Point &a, const Point &b) {\n    if (a.Y != b.Y) return a.Y < b.Y;\n    return a.X < b.X;\n  };\n\n  function<Line(Point*,int)> Rec = [&Rec, &CompareY](Point *ps, int n) {\n    if (n <= 1) return Line{Point(0, 0), Point(INF, INF)};\n    \n    int m = n/2;\n    double x = ps[m].X;\n    Line a = Rec(ps, m);\n    Line b = Rec(ps+m, n-m);\n    double mind = DistL(a);\n    Line ret = a;\n    if (DistL(b) < mind) {\n      mind = DistL(b);\n      ret = b;\n    }\n\n    sort(ps, ps+n, CompareY);\n    vector<Point> qs;\n    qs.reserve(n);\n    for (int i=0; i<n; i++) {\n      if (abs(ps[i].X - x) >= mind) continue;\n\n      for (int j=0; j<qs.size(); j++) {\n        Point p1 = ps[i];\n        Point p2 = qs[qs.size()-1-j];\n        if (p1.Y - p2.Y >= mind) break;\n\n        double d = abs(p1-p2);\n        if (mind > d) {\n          mind = d;\n          ret = Line{p1, p2};\n        }\n      }\n\n      qs.emplace_back(ps[i]);\n    }\n\n    return ret;\n  };\n\n  int n = ps.size();\n  assert (n >= 2);\n  sort(ps.begin(), ps.end());\n  return Rec(&ps[0], n);\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\n// <left, right> or <upper, lower>\npair<Poly, Poly> CutConvex(Poly ps, Line l) {\n#if DEBUG\n  assert (IsConvex(ps));\n#endif\n\n  //if (l[0].Y > l[1].Y) swap(l[0], l[1]);\n  //else if (EQ(l[0].Y, l[1].Y) && l[0].X > l[1].X) swap(l[0], l[1]);\n\n  Poly left;\n  Poly right;\n  for (int i=0; i<ps.size(); i++) {\n    Point a = ps[i];\n    Point b = ps[(i+1)%ps.size()];\n\n    if (ccw(l[0], l[1], a) != CW) left.emplace_back(a);\n    else right.emplace_back(a);\n\n    Line m{a, b};\n    if (IntersectLS(l, m)) {\n      Point p = CrossPointLL(l, m);\n      left.emplace_back(p);\n      right.emplace_back(p);\n    }\n  }\n\n  return make_pair(left, right);\n}\n\nCircle Circum(Point a, Point b, Point c) {\n  Circle ret{{INF, INF}, 0.0};\n  Line l{a, b};\n  Line m{b, c};\n  Line lp = PerpendBisect(l);\n  Line mp = PerpendBisect(m);\n  if (IsParallel(lp, mp)) return ret;\n\n  ret.c = CrossPointLL(lp, mp);\n  ret.r = abs(a-ret.c);\n  return ret;\n}\n\nint n;\nint m;\nvector<Point> as;\nvector<Point> bs;\n\nbool check(Line &l) {\n  Geometory aprev = ERROR;\n  for (Point &p : as) {\n    Geometory ret = ccw(l[0], l[1], p);\n    if (aprev != ERROR && aprev != ret) return false;\n    aprev = ret;\n  }\n  if (aprev == ON_LINE) return false;\n\n  Geometory bprev = ERROR;\n  for (Point &p : bs) {\n    Geometory ret = ccw(l[0], l[1], p);\n    if (bprev != ERROR && bprev != ret) return false;\n    bprev = ret;\n  }\n  if (bprev == ON_LINE) return false;\n\n  return aprev != bprev;\n}\n\nbool FindLine(Poly &ch) {\n  if (ch.size() <= 1) return false;\n  for (int i=0; i<ch.size(); i++) {\n    Line l{ch[i], ch[(i+1)%ch.size()]};\n    Vec v = l[1]-l[0];\n    v = (v*Vec(0, -1))/abs(v)*EPS;\n    l[0] += v;\n    l[1] += v;\n    \n    if (check(l)) return true;\n  }\n\n  return false;\n}\n\nbool CheckVertical(vector<Point> &ps) {\n  if (ps.size() != 2) return false;\n\n  Vec v = ps[1]-ps[0];\n  Vec p = v*Vec(0, 1);\n  v = v/abs(v)*EPS;\n  Line l{ps[1]+v, ps[1]+v+p};\n  if (check(l)) return true;\n  l = {ps[0]-v, ps[0]-v+p};\n  return check(l);\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &n, &m);\n    if (n == 0 && m == 0) return 0;\n\n    as.resize(n);\n    for (int i=0; i<n; i++) {\n      int x, y;\n      scanf(\"%d%d\", &x, &y);\n      as[i] = Point(x, y);\n    }\n  \n    bs.resize(m);\n    for (int i=0; i<m; i++) {\n      int x, y;\n      scanf(\"%d%d\", &x, &y);\n      bs[i] = Point(x, y);\n    }\n\n    if (n == 1 && m == 1) {\n      puts(\"YES\");\n      continue;\n    }\n  \n    bool ans;\n    Poly ach = GrahamScan(as);\n    Poly bch = GrahamScan(bs);\n    ans = FindLine(ach);\n    if (ans) {\n      puts(\"YES\");\n      continue;\n    }\n\n    ans = FindLine(bch);\n    if (ans) {\n      puts(\"YES\");\n      continue;\n    }\n\n    ans = CheckVertical(as);\n    if (ans) {\n      puts(\"YES\");\n      continue;\n    }\n\n    ans = CheckVertical(bs);\n    if (ans) {\n      puts(\"YES\");\n      continue;\n    }\n\n    puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\ntypedef complex < double > Point;\n\ntypedef vector < Point > Polygon;\nnamespace std {\n    bool operator < (Point a,Point b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\n\n\nstruct Line : Polygon{\n    Line(){};\n    Line(Point p,Point q){ push_back(p);push_back(q); }\n};\nstruct Circle{\n    Point p;\n    double r;\n    Circle(){};\n    Circle(Point a, double s){ p = a;r = s; }\n};\n\n// ベクタの長さ\ndouble VectorLength(Point a){\n    return abs(a);\n}\n\n// 二点間距離\ndouble DistancePP(Point a,Point b){\n    return abs(a-b);\n}\n\n// 単位ベクトル\nPoint UnitVector(Point a){\n    return a / abs(a);\n}\n\n// 法線ベクトル\npair<Point,Point> NormalVector(Point a){\n    Point n1 = a * Point(0,1);\n    Point n2 = a * Point(0,-1);\n    return make_pair(n1,n2);\n}\n\n//外積\ndouble cross(Point p,Point q){\n    return imag(conj(p)*q);\n}\n\n//内積\ndouble dot(Point p,Point q){\n    return real(conj(p)*q);\n}\n\nint ccw(Point a,Point b,Point c){\n    b-=a,c-=a;\n    if(cross(b,c)>0)return 1; //反時計回り\n    if(cross(b,c)<0)return -1; //時計回り\n    if(dot(b,c)<0)return 2; //直線上に c - a - b\n    if(norm(b)<norm(c))return -2; // 直線上に a - b - c\n    return 0; // 直線上に a - c - b\n}\n\nPoint normalize(Point P, double l){\n    double a = real(P), b = imag(P);\n    double y = sqrt(b*b/(a*a+b*b)*l*l);\n    double x = (a/b)*y;\n\n    return Point(x,y);\n}\n\n//三角形の面積\ndouble TriangleArea(Point A, Point B, Point C){\n    return abs(cross(B-A,C-A)/2);\n}\n\n//多角形の面積\ndouble VertexArea(Polygon v){\n    double ret = 0;\n    for(int i=1;i<v.size()-1;i++){\n        ret += TriangleArea(v[0],v[i],v[i+1]);\n    }\n    return abs(ret);\n}\n\nbool intersectLL(Line l, Line m) {\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // 平行でない\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // 同一の線\n}\nbool intersectLS(Line l, Line s) {\n    return cross(l[1]-l[0], s[0]-l[0])*       // s[0] が lの左\n           cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] が lの右\n}\nbool intersectLP(Line l, Point p) {\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(Line l, Point p);\nbool intersectCS(Circle C,Line l){\n    return (distanceLP(l,C.p) < C.r + EPS and\n             (C.r < abs(C.p-l[0]) + EPS or C.r < abs(C.p-l[1]) + EPS));\n}\n//↓2円の交点二つを返す（ポインタ）,戻り値は交点の個数\nint intersectCC(Circle A, Circle B, Point *p, Point *q){\n\n    Point P,Q;\n    if(B.p < A.p)swap(A.p,B.p);\n    Point dv = B.p - A.p;//ベクトル\n\n\n    double L = sqrt(norm(dv));\n    int num;\n    //距離がLの場合\n    if( L==(A.r + B.r) ){\n        num = 1;\n        //交点1つ\n        //虚数軸に沿って並んでいるとバグる？\n        dv = normalize(dv,A.r);\n        P = Q = Point(real(dv)+real(A.p),imag(dv)+imag(A.p));\n    }\n    else if( L<(A.r + B.r) && L > fabs(A.r - B.r) ){\n        num = 2;\n        //交点2つ\n        /*\n        交点の一方Qからベクトルdvに垂線を下ろしたところをptとする\n        ふたつの直角三角形p0-pt-Q、p1-pt-Qができる\n        p0-pt間の長さをtとすると、これらの三角形のQ-ptの長さは等しいため、\n\n        r0*r0 - t*t = r1*r1 - (L-t)*(L-t)\n        r0*r0 - t*t = r1*r1 - L*L - t*t + 2*L*t\n        t = (r0*r0 - r1*r1 + L*L)/(2*L)\n\n        tから、p0-Qベクトルとdvベクトルとの角度aを求め、\n        dvベクトルから、+a,-aの座標を求めれば交点となる\n        */\n\n        //tを求める\n        double t = 0.5*( A.r*A.r - B.r*B.r + L*L)/L;\n\n        //p0-Qベクトルとdvベクトルの角度\n        double a = acos( t/A.r );\n\n        //dvベクトルの角度\n        double a0 = atan2( imag(dv), real(dv) );\n\n        //交点\n        P = Point( real(A.p) + A.r*cos(a0+a), imag(A.p) + A.r*sin(a0+a) );\n        Q = Point( real(A.p) + A.r*cos(a0-a), imag(A.p) + A.r*sin(a0-a) );\n\n    }\n    else{\n        num = 0;\n        //交点なし\n    }\n\n    *p = P;\n    *q = Q;\n\n    return num;\n}\n/*\n// 直線と点の最短距離を実現する直線の点(垂線の足)(未検証)\npoint nearest_point_line_and_point(point a1,point a2,point b){\n    return a1 + (a2-a1) * dot((a2-a1),(b-a1)) / norm(a2-a1);\n}\n\n// 線分と点の最短距離を実現する線分嬢の点(未検証）\npoint nearest_point_linesegment_and_point(point a1,point a2,point b){\n    if(dot(a2-a1,b-a1) < EPS) return a1;\n    if(dot(a1-a2,b-a2) < EPS) return a2;\n    return nearest_point_line_and_point(a1,a2,b);\n}\n*/\nPoint projection(Line l, Point p) {//射影\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t * (l[0]-l[1]);\n}\nPoint reflection(Line l, Point p) {//反射\n    return p + (projection(l, p) - p) + (projection(l, p) - p);\n}\ndouble distanceLP(Line l, Point p) {\n    return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(Line l, Line s) {\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(Line s, Point p) {\n    const Point r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(Line s, Line t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nPoint crosspoint(Line l, Line m) {\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n    if (abs(A) < EPS);\n    return m[0] + B / A * (m[1] - m[0]);\n}\n/*\ndouble area(Polygon P) {//多角形の面積\n    double A = 0;\n    for (int i = 0; i < P.size(); ++i)\n        A += cross(curr(P, i), next(P, i));\n    return A;\n}\n*/\nPolygon ConvexHull(Polygon ps) {//凸包\n    int n = ps.size(), k = 0;\n    if(n == 1)return ps;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    ch.resize(k-1);\n    return ch;\n}\n\n// Point - Vertex\nenum{OUT, ON, IN};\nint IsInnerPointVertex(Polygon ps,Point a){\n    bool flg = false;\n    for(int i = 0;i < ps.size();i++){\n        Point p = ps[i] - a,q = ps[(i+1)%ps.size()] - a;\n        if(imag(p)>imag(q))swap(p,q);\n        if(imag(p)<=0&&0<imag(q)){\n            if(cross(p,q) < 0)flg = !flg;\n        }\n        if(cross(p,q) == 0 && dot(p,q) <= 0)return ON;\n    }\n    return flg ? IN : OUT;\n}\nint main(){\n    int n,m;\n    while(cin>>n>>m,n){\n        Polygon G,H;\n        for(int i = 0;i < n;i++){\n            double x,y;\n            cin>>x>>y;\n            G.push_back(Point(x,y));\n        }\n        for(int i = 0;i < m;i++){\n            double x,y;\n            cin>>x>>y;\n            H.push_back(Point(x,y));\n        }\n        G = ConvexHull(G);\n        H = ConvexHull(H);\n        int g = G.size(),h = H.size();\n        //cout<<g<<\" \"<<h<<endl;\n        if(g > h)swap(G,H);\n        g = G.size(),h = H.size();\n        bool flg = true;\n        for(int i = 0;i < g;i++){\n            if(IsInnerPointVertex(H,G[i]) != OUT){\n                flg = false;\n                break;\n            }\n        }\n        for(int i = 0;i < h;i++){\n            if(IsInnerPointVertex(G,H[i]) != OUT){\n                flg = false;\n                break;\n            }\n        }\n\n        if(h == 1)flg = true;\n        else if(g == 1 && h == 2){\n            flg = !(intersectSP(Line(H[0],H[1]),G[0]));\n        }\n        else if(g == 2 && h == 2){\n            flg = !(intersectSS(Line(G[0],G[1]),Line(H[0],H[1])));\n        }\n        else if(g == 2){\n            flg = true;\n            for(int i = 0;i < h;i++){\n                int j = (i+1)%h;\n                if(intersectSS(Line(G[0],G[1]),Line(H[i],H[j])))flg = false;\n            }\n        }\n        if(flg)cout<<\"YES\"<<endl;\n        else cout<<\"NO\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\nusing namespace std;\ntypedef complex<long long> P;\n\ninline P::value_type cross(const P& a, const P& b) { return a.real()*b.imag() - b.real()*a.imag(); }\n\nbool ok(const vector<P>& ps, int N, int i1, int i2)\n{\n  const int NM = ps.size();\n  const int color = i1 < N;\n  int cnt[2][2] = {{0, 0}, {0, 0}};\n  for (int i = 0; i < NM; i++) {\n    const long long c = cross(ps[i2] - ps[i1], ps[i] - ps[i1]);\n    const int col = i < N;\n    if (c == 0) {\n      if (color != col) {\n        return false;\n      }\n    } else {\n      ++cnt[col][c < 0];\n    }\n  }\n  return (cnt[0][0] == 0 && cnt[1][1] == 0) || (cnt[0][1] == 0 && cnt[1][0] == 0);\n}\n\nbool check(const vector<P>& ps, int N)\n{\n  for (int i = 0; i < N; i++) {\n    for (int j = i+1; j < N; j++) {\n      if (ok(ps, N, i, j)) {\n        return true;\n      }\n    }\n  }\n  const int NM = ps.size();\n  for (int i = N; i < NM; i++) {\n    for (int j = i+1; j < NM; j++) {\n      if (ok(ps, N, i, j)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nbool check_edgecase(const vector<P>& ps, const int N)\n{\n  const int NM = ps.size();\n  int x = ps[0].real() - ps[N].real();\n  if (x != 0) {\n    x /= abs(x);\n  }\n  for (int i = 0; i < N; i++) {\n    for (int j = N; j < NM; j++) {\n      int xx = ps[i].real() - ps[j].real();\n      if (xx != 0) {\n        xx /= abs(xx);\n      }\n      if (x != xx) {\n        return false;\n      }\n    }\n  }\n  int y = ps[0].imag() - ps[N].imag();\n  if (y != 0) {\n    y /= abs(y);\n  }\n  for (int i = 0; i < N; i++) {\n    for (int j = N; j < NM; j++) {\n      int yy = ps[i].imag() - ps[j].imag();\n      if (yy != 0) {\n        yy /= abs(yy);\n      }\n      if (y != yy) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nint main()\n{\n  int N, M;\n  while (cin >> N >> M && N != 0) {\n    vector<P> ps(N+M);\n    for (int i = 0; i < N+M; i++) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n\n    bool straight = true;\n    if (N+M > 2) {\n      const long long c0 = cross(ps[2]-ps[0], ps[1]-ps[0]);\n      for (int i = 3; i < N+M; i++) {\n        const long long c = cross(ps[i]-ps[0], ps[1]-ps[0]);\n        if (c != c0) {\n          straight = false;\n          break;\n        }\n      }\n    }\n    if (straight) {\n      cout << (check_edgecase(ps, N) ? \"YES\" : \"NO\") << endl;\n    } else {\n      cout << (check(ps, N) ? \"YES\" : \"NO\") << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Hello. I'm Peter.\n#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<functional>\n#include<cctype>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define peter cout<<\"i am peter\"<<endl\n#define input freopen(\"data.txt\",\"r\",stdin)\n#define randin srand((unsigned int)time(NULL))\n#define INT (0x3f3f3f3f)*2\n#define LL (0x3f3f3f3f3f3f3f3f)*2\n#define gsize(a) (int)a.size()\n#define len(a) (int)strlen(a)\n#define slen(s) (int)s.length()\n#define pb(a) push_back(a)\n#define clr(a) memset(a,0,sizeof(a))\n#define clr_minus1(a) memset(a,-1,sizeof(a))\n#define clr_INT(a) memset(a,INT,sizeof(a))\n#define clr_true(a) memset(a,true,sizeof(a))\n#define clr_false(a) memset(a,false,sizeof(a))\n#define clr_queue(q) while(!q.empty()) q.pop()\n#define clr_stack(s) while(!s.empty()) s.pop()\n#define rep(i, a, b) for (int i = a; i < b; i++)\n#define dep(i, a, b) for (int i = a; i > b; i--)\n#define repin(i, a, b) for (int i = a; i <= b; i++)\n#define depin(i, a, b) for (int i = a; i >= b; i--)\n#define pi acos(-1.0)\n#define eps 1e-10\n#define MOD 1000000007\n#define MAXN\n#define N 200\n#define M\nint dcmp(double x){//蛻、譁ュx豁」雍滓?荳コ0\n    if(fabs(x)<eps) return 0;\n    else if(x<0) return -1;\n    else return 1;\n}\nstruct Point{\n    double x,y;\n    Point(){};\n    Point(double xx,double yy):x(xx),y(yy){};\n};\nbool operator<(const Point A,const Point B){\n    return A.x < B.x || (A.x == B.x && A.y < B.y);\n}\ntypedef Point Vector;\nvoid readPoint(Point &a){//霎灘?荳?クェ轤ケ\n    cin>>a.x>>a.y;\n}\nVector operator -(const Vector a,const Vector b){//荳、蜷鷹?逶ク蜃?    return Vector(a.x-b.x,a.y-b.y);\n}\ndouble operator &(const Vector a,const Vector b){//荳、蜷鷹?蜿臥ァッ\n    return a.x*b.y-a.y*b.x;\n}\ndouble Cross(Vector A, Vector B) { return A.x*B.y - B.x*A.y; }\nint ConvexHull ( Point* p, int n, Point* ch)\n{\n    sort(p, p+n);\n    int m = 0;\n    for(int i = 0; i<n; i++)\n    {\n        while(m > 1 && Cross( ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0) m--;\n        ch[m++] = p[i];\n    }\n    int k = m;\n    for(int i = n-2; i>=0; i--)\n    {\n        while(m > k && Cross( ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0) m--;\n        ch[m++] = p[i];\n    }\n    ///霑倩ヲ∵隼荳?ク狗函謌仙、夊セケ蠖「縲?    ch[m++] = ch[0];\n    if(n > 1) m--;\n    return m;\n}\nbool SideCross(Point a1, Point a2, Point b1, Point b2)\n{\n    double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1),\n    c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1);\n    return dcmp(c1)*dcmp(c2)<0 && dcmp(c3)*dcmp(c4)<0;\n}\nbool pInConvex(Point a, Point* ch, int n)\n{\n    int i;\n    if(n==3)\n    {\n        if(a.x < min(ch[0].x, ch[1].x) || a.x > max(ch[0].x, ch[1].x)) return 0;\n        if(a.y < min(ch[0].y, ch[1].y) || a.y > max(ch[0].y, ch[1].y)) return 0;\n    }\n    for(i=1;i<n;i++)\n    {\n        if(Cross( ch[i]-ch[i-1], a-ch[i-1] ) < 0 ) return 0;\n    }\n    return 1;\n}\nint n,m,num_ch1,num_ch2;\nPoint black[N],ch1[N],white[N],ch2[N];\nint main(){\n//    input;\n    while(~scanf(\"%d %d\",&n,&m) && (n+m)){\n        clr(black);\n        clr(white);\n        clr(ch1);\n        clr(ch2);\n        rep(i,0,n){\n            readPoint(black[i]);\n        }\n        rep(i,0,m){\n            readPoint(white[i]);\n        }\n        bool ok=true;\n        if(n==1 && m==1) ok=true;\n        else if(n==1){\n            num_ch2=ConvexHull(white,m,ch2);\n            if(pInConvex(black[0],ch2,num_ch2)) ok=false;\n            else ok=true;\n        }\n        else if(m==1){\n            num_ch1=ConvexHull(black,n,ch1);\n            if(pInConvex(white[0],ch1,num_ch1)) ok=false;\n            else ok=true;\n        }\n        //n!=1 && m!=1\n        else{\n            num_ch1=ConvexHull(black,n,ch1);\n            num_ch2=ConvexHull(white,m,ch2);\n            rep(i,1,num_ch1){\n                if(!ok) break;\n                rep(j,1,num_ch2){\n                    if(SideCross(ch1[i],ch1[i-1],ch2[j],ch2[j-1])){\n                        ok=false;\n                        break;\n                    }\n                }\n            }\n            rep(i,0,n){\n                if(!ok) break;\n                if(pInConvex(black[i],ch2,num_ch2)) ok=false;\n            }\n            rep(i,0,m){\n                if(!ok) break;\n                if(pInConvex(white[i],ch1,num_ch1)) ok=false;\n            }\n        }\n        printf(\"%s\\n\",ok?\"YES\":\"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <array>\nusing namespace std;\n\nconst double EPS = 1e-10;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\n\nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return (a.X!=b.X) ? a.X<b.X : a.Y<b.Y;\n    }\n    bool operator == (const P& a, const P& b){\n        return abs(a-b) < EPS;\n    }\n}\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) < -EPS) return -1; //cw\n    if(dot(b,c) < -EPS) return +2; //c-a-b\n    if(abs(c)-abs(b) > EPS) return -2; //a-b-c\n    return 0; //a-c-b\n}\n\nbool intersectSP(const L& s, const P &p){\n    return abs(cross(s[0]-p, s[1]-p))<EPS  && dot(s[0]-p, s[1]-p)<EPS;\n}\nbool intersectSS(const L& a, const L& b){\n    return ( ccw(a[0],a[1],b[0]) *ccw(a[0],a[1],b[1]) <= 0 ) &&\n        ( ccw(b[0],b[1],a[0]) *ccw(b[0],b[1],a[1]) <= 0 );\n}\n\nint in_poly(const P &p, const VP &poly){\n    int n = poly.size();\n    int ret = -1;\n    for(int i=0; i<n; i++){\n        P a = poly[i]-p;\n        P b = poly[(i+1)%n]-p;\n        if(a.Y > b.Y) swap(a,b);\n        if(intersectSP(L(a,b), P(0,0))) return 0;\n        if(a.Y<=0 && b.Y>0 && cross(a,b)<0) ret = 1-ret;\n    }\n    return ret;\n}\n\nVP convex(VP v){\n    VP ret;\n    int n = v.size();\n    sort(v.begin(), v.end());\n    for(int i=0; i<n; i++){\n        while((int)ret.size()>1 && cross(ret.back()-ret[ret.size()-2], v[i]-ret.back()) < EPS){\n            ret.pop_back();\n        }\n        ret.push_back(v[i]);\n    }\n    int t = ret.size();\n    for(int i=n-2; i>=0; i--){\n        while((int)ret.size()>t && cross(ret.back()-ret[ret.size()-2], v[i]-ret.back()) < EPS){\n            ret.pop_back();\n        }\n        ret.push_back(v[i]);\n    }\n    if((int)ret.size() > 1) ret.pop_back();\n    return ret;\n}\n\nint main(){\n    while(1){\n        int n,m;\n        cin >> n >> m;\n        if(n==0) break;\n\n        VP s(n), t(m);\n        for(int i=0; i<n; i++){\n            int x,y;\n            cin >> x >> y;\n            s[i] = P(x,y);\n        }\n        for(int i=0; i<m; i++){\n            int x,y;\n            cin >> x >> y;\n            t[i] = P(x,y);\n        }\n        VP cs = convex(s);\n        VP ct = convex(t);\n\n        bool ans = true;\n        int ns = cs.size(), nt = ct.size();\n        for(int r=0; r<2; r++){\n            for(int i=0; i<ns; i++){\n                for(int j=0; j<nt; j++){\n                    if(in_poly(cs[i], ct) >= 0){\n                        ans = false;\n                        i = ns;\n                        r = 2;\n                        break;\n                    }\n                }\n            }\n            swap(cs, ct);\n            swap(ns, nt);\n        }\n        for(int i=0; i<ns; i++){\n            for(int j=0; j<nt; j++){\n                if(intersectSS(L(cs[i], cs[(i+1)%ns]), L(ct[j], ct[(j+1)%nt]))){\n                    ans = false;\n                    i = ns;\n                    break;\n                }\n            }\n        }\n        \n        if(ans){\n            cout << \"YES\" << endl;\n        }else{\n            cout << \"NO\" << endl;\n        }       \n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res;\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps){\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d,  c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0,  1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n  int n = ps.size();\n  Polygon Q;\n  REP(i,n) {\n    Point A = ps[i], B = ps[(i+1)%n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n      Q.push_back(is_ll(l, m));\n  }\n  return Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n  for (Point q : ps) if (abs(q - p) < eps) return;\n  ps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n  g[from].push_back((Edge){from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n  int n = p.size(), m = s.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (isis_sp(s[i], p[j]))\n      vec.emplace_back(abs(s[i].a - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      add_edge(g, from, to, abs(p[from] - p[to]));\n    }\n  }\n  return g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n  int n = p.size(), m = c.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n      vec.emplace_back(arg(c[i].p - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      ld angle = vec[j+1].first - vec[j].first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n    if (vec.size() >= 2) {\n      int from = vec.back().second, to = vec.front().first;\n      ld angle = vec.front().first - vec.back().first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n  }\n  return g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n  int N = p.size();\n  polygon.clear();\n  REP(i,1024) REP(j,1024) seg2p[i][j].clear();\n  vector<vector<tuple<ld,int,bool>>> tup(N);\n  REP(i,s.size()) {\n    int a = -1, b = -1;\n    REP(j,N) if (abs(s[i].a - p[j]) < eps) a = j;\n    REP(j,N) if (abs(s[i].b - p[j]) < eps) b = j;\n    assert(a >= 0 && b >= 0);\n    tup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n    tup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n  }\n  REP(i,N) sort(ALL(tup[i]));\n  REP(i,N) {\n    REP(j,tup[i].size()) {\n      ld angle; int pos = j, from = i, to; bool flag;\n      tie(angle, to, flag) = tup[i][j];\n      if (flag) continue;\n      vector<int> ps;\n      while (!flag) {\n        ps.push_back(from);\n        get<2>(tup[from][pos]) = true;\n        seg2p[from][to].push_back(polygon.size());\n        seg2p[to][from].push_back(polygon.size());\n        angle += pi + eps;\n        if (angle > pi) angle -= 2 * pi;\n        auto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n        if (it == tup[to].end()) it = tup[to].begin();\n        from = to; tie(angle, to, flag) = *it;\n        pos = it - tup[from].begin();\n      }\n      polygon.push_back(ps);\n    }\n  }\n  Graph g(polygon.size());\n  REP(i,N) REP(j,i) {\n    if (seg2p[i][j].size() == 2) {\n      int from = seg2p[i][j][0], to = seg2p[i][j][1];\n      g[from].push_back((Edge){from, to});\n      g[to].push_back((Edge){to, from});\n    }\n  }\n  return g;\n}\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n  fprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n  Point v = l.b - l.a;\n  Line m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n  int n = p.size();\n  REP(i,n) draw_segment(Line(p[i], p[(i+1)%n]));\n}\n\nvoid draw_circle(Circle c) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nint main() {\n\tint N, M;\n\twhile ( cin >> N >> M, N || M ) {\n\t\tvector<Point> b, w;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tb.push_back( Point(x, y) );\n\t\t}\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tw.push_back( Point(x, y) );\n\t\t}\n\t\tsort(b.begin(), b.end());\n\t\tsort(w.begin(), w.end());\n\n\t\tvector<Line> can;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < M; ++j) {\n\t\t\t\tif (b[i] != w[j]) {\n\t\t\t\t\tcan.push_back(Line(b[i], w[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool f = true;\n\t\tfor (int i = 0; i < N; ++i) for (int j = 0; j < M; ++j) {\n\t\t\tif (b[i] == w[j]) f = false;\n\t\t}\n\t\tbool ans = false;\n\t\tif (f) {\n\t\t\tfor (int i = 0; i < can.size(); ++i) {\n\t\t\t\tLine& l = can[i];\n\t\t\t\tint cntB = 0;\n\t\t\t\tvector<Point> onB;\n\t\t\t\tfor (int j = 0; j < b.size(); ++j) {\n\t\t\t\t\tint c = ccw(l.a, l.b, b[j]);\n\t\t\t\t\tif (c == 1) {\n\t\t\t\t\t\t++cntB;\n\t\t\t\t\t}\n\t\t\t\t\telse if (c == 2 || c == -2 || c == 0) {\n\t\t\t\t\t\tonB.push_back(b[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint cntW = 0;\n\t\t\t\tvector<Point> onW;\n\t\t\t\tfor (int j = 0; j < w.size(); ++j) {\n\t\t\t\t\tint c = ccw(l.a, l.b, w[j]);\n\t\t\t\t\tif (c == 1) {\n\t\t\t\t\t\t++cntW;\n\t\t\t\t\t}\n\t\t\t\t\telse if (c == 2 || c == -2 || c == 0) {\n\t\t\t\t\t\tonW.push_back(w[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((cntB+onB.size() == b.size() && cntW == 0) || (cntB == 0 && cntW+onW.size() == w.size())) {\n\t\t\t\t\tvector<Point> c1, C1;\n\t\t\t\t\tc1.push_back(onB[0]);\n\t\t\t\t\tc1.push_back(onB[onB.size()-1]);\n\t\t\t\t\tc1.push_back(onW[0]);\n\t\t\t\t\tc1.push_back(onW[onW.size()-1]);\n\n\t\t\t\t\tvector<Point> c2, C2;\n\t\t\t\t\tc2.push_back(onW[0]);\n\t\t\t\t\tc2.push_back(onW[onW.size()-1]);\n\t\t\t\t\tc2.push_back(onB[0]);\n\t\t\t\t\tc2.push_back(onB[onB.size()-1]);\n\n\t\t\t\t\tC1 = c1, C2 = c2;\n\t\t\t\t\tsort(c1.begin(), c1.end());\n\t\t\t\t\tsort(c2.begin(), c2.end());\n\n\t\t\t\t\tif (c1 == C1 || c2 == C2) {\n\t\t\t\t\t\tans = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n/*\n\t\t\t\t\tbool f = true;\n\t\t\t\t\tfor (int i = 0; i < onB.size(); ++i) {\n\t\t\t\t\t\tfor (int j = 0; j < onB.size(); ++j) {\n\t\t\t\t\t\t\tfor (int k = 0; k < onW.size(); ++k) {\n\t\t\t\t\t\t\t\tif (i != j && ccw(onB[i], onB[j], onW[k]) == 0) {\n\t\t\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < onW.size(); ++i) {\n\t\t\t\t\t\tfor (int j = 0; j < onW.size(); ++j) {\n\t\t\t\t\t\t\tfor (int k = 0; k < onB.size(); ++k) {\n\t\t\t\t\t\t\t\tif (i != j && ccw(onW[i], onW[j], onB[k]) == 0) {\n\t\t\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\tans = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle(Point a, ld b) :p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tld r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2, 0)*projection(l, p) - p;\n}\n\nld dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tld a = cross(s.b - s.a, t.b - t.a);\n\tld b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tld dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tld d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tld d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tld len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\n\nPolygon convex_hull(Polygon s)\n{\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(ALL(s));\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\tFOR(i, 2, s.size())\n\t{\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != -1; n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\tfor (int i = s.size() - 3; i >= 0; i--)\n\t{\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != -1; n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\nint contains(Polygon g, Point p)\n{\n\tbool f = false;\n\tREP(i, g.size())\n\t{\n\t\tPoint a = g[i] - p, b = g[(i + 1) % g.size()] - p;\n\t\tif (abs(cross(a, b)) < EPS&&dot(a, b) < EPS) return 0; //ON\n\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\tif (a.imag() < EPS&&b.imag() > EPS&&cross(a, b) > EPS) f = !f;\n\t}\n\tif (f) return 1; //IN\n\telse return -1; //OUT\n}\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tPolygon b, w;\n\t\tREP(i, n)\n\t\t{\n\t\t\tld x, y; cin >> x >> y;\n\t\t\tb.emplace_back(x, y);\n\t\t}\n\t\tREP(i, m)\n\t\t{\n\t\t\tld x, y; cin >> x >> y;\n\t\t\tw.emplace_back(x, y);\n\t\t}\n\t\tbool res;\n\t\tif (n == 1 && m == 1) res = true;\n\t\telse if (n == 2 && m == 1)\n\t\t{\n\t\t\tres = !isis_sp(Line(b[0], b[1]), w[0]);\n\t\t}\n\t\telse if (n == 1 && m == 2)\n\t\t{\n\t\t\tres = !isis_sp(Line(w[0], w[1]), b[0]);\n\t\t}\n\t\telse if (n == 2 && m == 2)\n\t\t{\n\t\t\tres = !isis_ss(Line(b[0], b[1]), Line(w[0], w[1]));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPolygon cb = convex_hull(b);\n\t\t\tPolygon cw = convex_hull(w);\n\t\t\tres = true;\n\t\t\tif (cw.size() > 2)\n\t\t\t{\n\t\t\t\tREP(i, w.size())\n\t\t\t\t\tif (contains(cb, w[i]) != -1) res = false;\n\t\t\t}\n\t\t\tif (cb.size() > 2)\n\t\t\t{\n\t\t\t\tREP(i, b.size())\n\t\t\t\t\tif (contains(cw, b[i]) != -1) res = false;\n\t\t\t}\n\t\t}\n\t\tputs(res ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef vector<P> Pol;\n\nconst double INF = 1e40;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\n\nint sig(double r) {return (r < -EPS) ? -1 : (r > EPS) ? 1: 0;}\nbool eq(double a, double b) {return abs(a - b) < EPS;}\ndouble dot(P a, P b) {return a.X * b.X + a.Y * b.Y;}\ndouble cross(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nP vec(L a) {return a.second - a.first;}\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\nint ccw(L s, P p) {\n  P a = vec(s);\n  p -= s.first;\n  double cr = cross(a, p);\n  if (eq(cr, 0)) {\n    if (sig(dot(a, p)) < 0) return BACK;\n    if (sig(norm(a) - norm(p)) < 0) return FRONT;\n    return ON;\n  }\n  return (cr > 0) ? LEFT : RIGHT;\n}\nbool iSS(L a, L b) {\n  int cwa = ccw(a, b.first) | ccw(a, b.second);\n  int cwb = ccw(b, a.first) | ccw(b, a.second);\n  if ((cwa | cwb) & ON) return true;\n  return (cwa & cwb) == (LEFT | RIGHT);\n}\nbool iLSs(L a, L b) {return sig(cross(vec(a), b.first - a.first)) * sig(cross(vec(a), b.second - a.first)) < 0;}\nP pLL(L a, L b) {return a.first + vec(a) * (cross(vec(b), b.first - a.first) / cross(vec(b), vec(a)));}\nbool lessX(P a, P b){\n  if(!eq(a.X, b.X)) return a.X < b.X;\n  if(!eq(a.Y, b.Y)) return a.Y < b.Y;\n  return false;\n}\nint sGP(Pol pol, P p) {\n  int side = -1;\n  rep (i, pol.size()) {\n    P p0 = pol[i] - p, p1 = pol[(i + 1) % pol.size()] - p;\n    if (sig(cross(p0, p1)) == 0 && sig(dot(p0, p1)) <= 0) return 0;\n    if (p0.Y > p1.Y) swap(p0, p1);\n    if (sig(p0.Y) <= 0 && 0 < sig(p1.Y) && sig(cross(p0, p1)) > 0) side *= -1;\n  }\n  return side;\n}\nint sVP(Pol pol, P p) {\n  int bit = 0;\n  rep (i, pol.size()) {\n    bit |= ccw(L(pol[i], pol[(i + 1) % pol.size()]), p);\n    if (bit & ON) return 0;\n  }\n  if (__builtin_popcount(bit) == 1) return 1;\n  return -1;\n}\nvector<P> convexHull(vector<P> p) {\n  int m = 0;\n  vector<P> q(p.size() * 2);\n  sort(p.begin(), p.end(), lessX);\n  for (int i = 0; i < int(p.size()); q[m++] = p[i++]) for (; m > 1 && sig(cross(q[m - 1] - q[m - 2], p[i] - q[m - 2])) <= 0; --m);\n  for (int i = p.size() - 2, r = m; i >= 0; q[m++] = p[i--]) for (; m > r && sig(cross(q[m - 1] - q[m - 2], p[i] - q[m - 2])) <= 0; --m);\n  q.resize(m - 1);\n  return q;\n}\n\nint main() {\n  int n, m;\n  for (;;) {\n    cin >> n >> m;\n    if (n == 0 && m == 0) break;\n    Pol white, black;\n    rep (i, n) {\n      P p;\n      cin >> p.X >> p.Y;\n      white.push_back(p);\n    }\n    rep (i, m) {\n      P p;\n      cin >> p.X >> p.Y;\n      black.push_back(p);\n    }\n    Pol wc = convexHull(white);\n    Pol bc = convexHull(black);\n    if (wc.size() == 0u) wc = white;\n    if (bc.size() == 0u) bc = black;\n        if (bc.size() >= 2u) {\n      rep (i, wc.size()) {\n\tif (sVP(bc, wc[i]) >= 0) goto aaa;\n      }\n    }\n    if (wc.size() >= 2u) {\n      rep (i, bc.size()) {\n\tif (sVP(wc, bc[i]) >= 0) goto aaa;\n      }\n    }\n    if (wc.size() >= 2u && bc.size() >= 2u) {\n      rep (i, wc.size()) rep (j, wc.size()) {\n\tif (iSS(L(wc[i], wc[(i + 1) % wc.size()]), L(bc[j], bc[(j + 1) % bc.size()]))) goto aaa;\n      }\n    } else {\n    }\n    cout << \"YES\" << endl;\n    continue;\n  aaa:;\n    cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\nusing namespace std;\ntypedef complex<long long> P;\n\ninline P::value_type cross(const P& a, const P& b) { return a.real()*b.imag() - b.real()*a.imag(); }\n\nbool ok(const vector<P>& ps, int N, int i1, int i2)\n{\n  const int NM = ps.size();\n  const int color = i1 < N;\n  int cnt[2][2] = {{0, 0}, {0, 0}};\n  for (int i = 0; i < NM; i++) {\n    const long long c = cross(ps[i2] - ps[i1], ps[i] - ps[i1]);\n    const int col = i < N;\n    if (c == 0) {\n      if (color != col) {\n        return false;\n      }\n    } else {\n      ++cnt[col][c < 0];\n    }\n  }\n  return (cnt[0][0] == 0 && cnt[1][1] == 0) || (cnt[0][1] == 0 && cnt[1][0] == 0);\n}\n\nbool check(const vector<P>& ps, int N)\n{\n  for (int i = 0; i < N; i++) {\n    for (int j = i+1; j < N; j++) {\n      if (ok(ps, N, i, j)) {\n        return true;\n      }\n    }\n  }\n  const int NM = ps.size();\n  for (int i = N; i < NM; i++) {\n    for (int j = i+1; j < NM; j++) {\n      if (ok(ps, N, i, j)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nbool check_edgecase(const vector<P>& ps, const int N)\n{\n  const int NM = ps.size();\n  int x = ps[0].real() - ps[N].real();\n  if (x != 0) {\n    x /= abs<int>(x);\n  }\n  for (int i = 0; i < N; i++) {\n    for (int j = N; j < NM; j++) {\n      int xx = ps[i].real() - ps[j].real();\n      if (xx != 0) {\n        xx /= abs<int>(xx);\n      }\n      if (x != xx) {\n        return false;\n      }\n    }\n  }\n  int y = ps[0].imag() - ps[N].imag();\n  if (y != 0) {\n    y /= abs<int>(y);\n  }\n  for (int i = 0; i < N; i++) {\n    for (int j = N; j < NM; j++) {\n      int yy = ps[i].imag() - ps[j].imag();\n      if (yy != 0) {\n        yy /= abs<int>(yy);\n      }\n      if (y != yy) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nint main()\n{\n  int N, M;\n  while (cin >> N >> M && N != 0) {\n    vector<P> ps(N+M);\n    for (int i = 0; i < N+M; i++) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n\n    bool straight = true;\n    if (N+M > 2) {\n      const long long c0 = cross(ps[2]-ps[0], ps[1]-ps[0]);\n      for (int i = 3; i < N+M; i++) {\n        const long long c = cross(ps[i]-ps[0], ps[1]-ps[0]);\n        if (c != c0) {\n          straight = false;\n          break;\n        }\n      }\n    }\n    if (straight) {\n      cout << (check_edgecase(ps, N) ? \"YES\" : \"NO\") << endl;\n    } else {\n      cout << (check(ps, N) ? \"YES\" : \"NO\") << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\n\nconst double EPS = 1e-8;\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\n// ???????????? a,b ???????????¢???\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\n// ????????¨?????????????????????????????????????????????true???\nbool isIntersect(L s1, L s2){\n  \n  //ccw ??????????????????????????¨, ????????????????????´?????????????????¨??????????????????????????????\n  if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\n// ????????¨??????????????????\nbool isIntersectSP(L s, P p){ \n  return abs(s.first-p) + abs(s.second-p) - abs(s.second-s.first) < EPS; \n}\n\nvector<P> convex_hull2(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nint main(){\n  \n  while(1){\n    \n    int n,m;\n    cin>>n>>m;\n    if(!n&&!m)break;\n  \n    vector<P> B(n),W(m);\n  \n    int x,y;\n  \n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      B[i]=P(x,y);\n    }\n\n    for(int i=0;i<m;i++){\n      cin>>x>>y;\n      W[i]=P(x,y);\n    }\n\n    bool ans=true;\n    \n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tif(i==j) continue;\n\t\n\tfor(int k=0;k<m;k++)\n\t  for(int l=0;l<m;l++){\n\t    if(k==l) continue;\n\t    \n\t    if(isIntersect(L(B[i],B[j]),L(W[k],W[l]))) ans=false;\n\t    \n\t  }\n      }\n\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tif(i==j) continue;\n\n\tfor(int k=0;k<m;k++)\n\t  if(isIntersectSP(L(B[i],B[j]),W[k])) ans=false;\n      }\n\n    for(int i=0;i<m;i++)\n      for(int j=0;j<m;j++){\n\tif(i==j) continue;\n\n\tfor(int k=0;k<n;k++)\n\t  if(isIntersectSP(L(W[i],W[j]),B[k])) ans=false;\n      }\n\n\n\n    vector<P> B2=convex_hull2(B);\n\n    int f=0,v,flag=1;\n      \n    for(int i=0;i<B2.size();i++){\n      for(int j=0;j<W.size();j++){\n\tint ip=(i+1)%B2.size();\n\tif(!f)v=ccw(B2[i],B2[ip],W[j]),f=1;\n\telse if(v!=ccw(B2[i],B2[ip],W[j])) flag=0;\n\t//\tcout<<ccw(B2[i],B2[ip],W[j])<<endl;\n      }\n    }\n    \n    if(B2.size()>=3&&flag) ans=false;\n    \n    vector<P> W2=convex_hull2(W);\n      \n    f=0;\n    flag=1;\n\n    for(int i=0;i<W2.size();i++){\n      for(int j=0;j<B.size();j++){\n\tint ip=(i+1)%W2.size();\n\tif(!f)v=ccw(W2[i],W2[ip],B[j]),f=1;\n\telse if(v!=ccw(W2[i],W2[ip],B[j])) flag=0;\n\t//\tcout<<ccw(W2[i],W2[ip],B[j])<<endl;\n      }\n    }\n    \n    if(W2.size()>=3&&flag) ans=false;\n    \n    if(ans) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n      \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef pair<int,int> P;\n\n//for vector\ninline int norm(const P &a){ return a.fs*a.fs + a.sc*a.sc; }\ninline int dot(const P &a, const P &b){return a.fs*b.fs + a.sc*b.sc;}\ninline int cross(const P &a, const P &b){return a.fs*b.sc - a.sc*b.fs;}\n\ninline int ccw(const P &a,P b,P c){\n  b.fs -= a.fs; b.sc -= a.sc;\n  c.fs -= a.fs; c.sc -= a.sc;\n  if (cross(b,c)>0) return 1;   //counter clockwise\n  if (cross(b,c)<0) return -1; //clockwise\n  if (dot(b, c)<-0) return 2;   //c--a--b on line\n  if (norm(b)<norm(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n\n  int n,m;\n  P b[110],w[110];\n  while(cin >> n >> m){\n    if(n==0 && m==0)break;\n    rep(i,n)cin >> b[i].fs >> b[i].sc;\n    rep(i,m)cin >> w[i].fs >> w[i].sc;\n\n    bool ans = false;\n    rep(i,n)rep(j,i){\n      bool f = true;\n      set<int> dirb;\n      rep(k,n){\n\tif(k==i || k==j)continue;\n\tint tmp = ccw(b[i],b[j],b[k]);\n\tif(tmp == 0){f = false; break;}\n\tif(abs(tmp)==1){\n\t  dirb.insert(tmp);\n\t  if(dirb.size()==2){f = false; break;}\n\t}\n      }\n\n      if(f){\n\tset<int> dirw;\n\trep(k,m){\n\t  int tmp = ccw(b[i],b[j],w[k]);\n\t  if(abs(tmp) != 1){f = false; break;}\n\t  dirw.insert(tmp);\n\t  if(dirw.size()==2){f = false; break;}\n\t}\n\tif(f && (dirb.size()==0 || dirw.size()==0\n\t\t || *dirb.begin() != *dirw.begin()))ans = true;\n      }\n      if(ans)break;\n    }\n\n    if(!ans){\n      rep(i,m)rep(j,i){\n\tbool f = true;\n\tset<int> dirw;\n\trep(k,m){\n\t  if(k==i || k==j)continue;\n\t  int tmp = ccw(w[i],w[j],w[k]);\n\t  if(tmp == 0){f = false; break;}\n\t  if(abs(tmp)==1){\n\t    dirw.insert(tmp);\n\t    if(dirw.size()==2){f = false; break;}\n\t  }\n\t}\n\t\n\tif(f){\n\t  set<int> dirb;\n\t  rep(k,n){\n\t    int tmp = ccw(w[i],w[j],b[k]);\n\t    if(abs(tmp) != 1){f = false; break;}\n\t    dirb.insert(tmp);\n\t    if(dirb.size()==2){f = false; break;}\n\t  }\n\t  if(f && (dirb.size()==0 || dirw.size()==0\n\t\t   || *dirb.begin() != *dirw.begin()))ans = true;\n\t}\n\tif(ans)break;\n      }\n    }\n\n    if(!ans){\n      rep(i,n)rep(j,m){\n\tbool f = true;\n\tset<int> dirb;\n\trep(k,n){\n\t  if(k==i)continue;\n\t  int tmp = ccw(b[i],w[j],b[k]);\n\t  if(tmp == 0 || tmp == -2){f = false; break;}\n\t  if(abs(tmp)==1){\n\t    dirb.insert(tmp);\n\t    if(dirb.size()==2){f = false; break;}\n\t  }\n\t}\n\t\n\tif(f){\n\t  set<int> dirw;\n\t  rep(k,m){\n\t    if(k==j)continue;\n\t    int tmp = ccw(b[i],w[j],w[k]);\n\t    if(tmp == 0 || tmp == 2){f = false; break;}\n\t    if(abs(tmp)==1){\n\t      dirw.insert(tmp);\n\t    if(dirw.size()==2){f = false; break;}\n\t    }\n\t  }\t\n\t  if(f && (dirb.size()==0 || dirw.size()==0\n\t\t   || *dirb.begin() != *dirw.begin()))ans = true;\n\t}\n\tif(ans)break;\n      }\n    }\n\n    cout << (ans?\"YES\":\"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={-1,0,1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-15;\n#define PB push_back\n#define mk make_pair\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef pair<int,Pii> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x = _x;\n        y = _y;\n    }\n    Point operator + (Point p){\n        return Point(x+p.x,y+p.y);\n    }\n  \n    Point operator - (Point p){\n        return Point(x-p.x,y-p.y);\n    }\n  \n    Point operator * (double k){\n        return Point(k*x,k*y);\n    }\n  \n    Point operator / (double k){\n        return Point(x/k,y/k);\n    }\n \n    bool operator<(const Point &p)const{\n        return x!=p.x?x<p.x:y<p.y;\n    }\n  \n};\ndouble dot(Point p, Point q){\n    return p.x*q.x+p.y*q.y;\n}\n  \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n  \ndouble norm(Point p){\n    return p.x*p.x+p.y*p.y;\n}\n  \ndouble pabs(Point p){\n    return sqrt(norm(p));\n}\nPoint UnitVector(Point a){\n\treturn a/pabs(a);\n}\ntypedef vector<Point> Polygon;\nstruct Line : Polygon{\n    Line(){}\n    Line(Point p,Point q){\n        PB(p);\n        PB(q);  \n    }\n};\nstruct Circle{\n    Point p; //中心点\n    double r; //半径\n    Circle(){}\n    Circle(Point _p,double _r){\n        p = _p;\n        r = _r;\n    }\n};\nint ccw(Point a,Point b,Point c){\n    b = b-a;\n    c = c-a;\n    if(cross(b,c) > 0)return +1; //a→b で反時計に折れてc ccw\n    if(cross(b,c) < 0)return -1; //a→b で時計に折れてc ccw\n    if(dot(b,c) < 0)return +2; // c--a--b;\n    if(pabs(b)<pabs(c))return -2; //a--b--c\n    return 0; //a--c--b\n}\nbool intersectSS(Line l,Line m){\n    //lとmが交差してるかどうか\n    return (ccw(l[0],l[1],m[0])*ccw(l[0],l[1],m[1])<EPS)&&\n            (ccw(m[0],m[1],l[0])*ccw(m[0],m[1],l[1])<EPS);\n}\n\nbool intersectSP(Line l, Point p){\n\t//線分lと点pが交差してるか\n\treturn !ccw(l[0],l[1],p);\n}\n\nbool intersectLL(Line l,Line m){\n\treturn fabs(cross(l[1]-l[0],m[1]-m[0])) > EPS || //平行でない\n\t\t\tfabs(cross(l[1]-l[0],m[0]-l[0])) < EPS; //同一の線\n}\n\ndouble TriangleArea(Point a,Point b,Point c){\n    b = b - a;\n    c = c - a;\n    return cross(b,c)*0.5; //負になることもあるので注意\n}\n \ndouble VertexArea(Polygon v){\n    double subArea = 0.0;\n    rep(i,v.size()-1){\n        subArea += TriangleArea(v[0],v[i],v[i+1]);\n    }\n    return subArea; //負になることもあるので注意\n}\n\nPoint crosspoint(Line l,Line m){\n    if(intersectSS(l,m) == false)return Point(INF,INF);\n    return m[0]+(m[1]-m[0])*cross(l[1]-l[0],l[1]-m[0])/cross(l[1]-l[0],m[1]-m[0]);\n}\n \nPolygon ConvexHull(Polygon v){\n\tint n = v.size();\n\tint k = 0;\n\tsort(v.begin(),v.end());\n\tPolygon e(2*n);\n\tfor(int i=0;i<n;e[k++]=v[i++])\n\t\twhile(k>=2&&ccw(e[k-2],e[k-1],v[i])<=0)k--;\n\tfor(int i=n-2,t=k+1;i>=0;e[k++]=v[i--])\n\t\twhile(k>=t&&ccw(e[k-2],e[k-1],v[i])<=0)k--;\n\te.resize(k-1);\n\treturn e;\n}\n\nint main(){\n\tint N,M;\n\twhile(scanf(\"%d%d\",&N,&M),N,M){\n\t\tPolygon black,white;\n\t\trep(i,N){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf%lf\",&x,&y);\n\t\t\tblack.PB(Point(x,y));\n\t\t}\n\t\trep(i,M){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf%lf\",&x,&y);\n\t\t\twhite.PB(Point(x,y));\n\t\t}\n\n\t\tblack = ConvexHull(black);\n\t\twhite = ConvexHull(white);\n\n\t\tif(black.size() == 0 && white.size() == 0){\n\t\t\tputs(\"YES\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tblack.PB(black[0]);\n\t\twhite.PB(white[0]);\n\n\t\tint flg = 0;\n\n\t\trep(i,black.size()-1){\n\t\t\tLine l;\n\t\t\tl.PB(black[i]);\n\t\t\tl.PB(black[i+1]);\n\t\t\trep(j,white.size()-1){\n\t\t\t\tLine m;\n\t\t\t\tm.PB(white[j]);\n\t\t\t\tm.PB(white[j+1]);\n\t\t\t\tif(intersectSS(l,m)){\n\t\t\t\t\tflg++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(i,white.size()-1){\n\t\t\tLine l;\n\t\t\tl.PB(white[i]);\n\t\t\tl.PB(white[i+1]);\n\t\t\trep(j,black.size()-1){\n\t\t\t\tLine m;\n\t\t\t\tm.PB(black[j]);\n\t\t\t\tm.PB(black[j+1]);\n\t\t\t\tif(intersectSS(l,m)){\n\t\t\t\t\tflg++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flg){\n\t\t\tputs(\"NO\");\n\t\t\tcontinue;\n\t\t}\n\t\tflg = 0;\n\t\trep(i,black.size()-1){\n\t\t\tLine l;\n\t\t\tl.PB(black[i]);\n\t\t\tl.PB(black[i]+(black[i+1]-black[i])*1e15);\n\t\t\trep(j,white.size()-1){\n\t\t\t\tLine m;\n\t\t\t\tm.PB(white[j]);\n\t\t\t\tm.PB(white[j+1]);\n\t\t\t\tif(intersectSS(l,m)){\n\t\t\t\t\tflg++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flg == black.size()-1){\n\t\t\tputs(\"NO\");\n\t\t\tcontinue;\n\t\t}\n\t\tflg = 0;\n\t\trep(i,white.size()-1){\n\t\t\tLine l;\n\t\t\tl.PB(white[i]);\n\t\t\tl.PB(white[i]+(white[i+1]-white[i])*1e15);\n\t\t\trep(j,black.size()-1){\n\t\t\t\tLine m;\n\t\t\t\tm.PB(black[j]);\n\t\t\t\tm.PB(black[j+1]);\n\t\t\t\tif(intersectSS(l,m)){\n\t\t\t\t\tflg++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flg == white.size()-1){\n\t\t\tputs(\"NO\");\n\t\t\tcontinue;\n\t\t}\n\t\tputs(\"YES\");\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "import java.awt.*;\nimport java.util.*;\nimport java.awt.geom.*;\n\npublic class Main {\n    public static void main(String args[])throws Exception{\n        Scanner cin= new Scanner(System.in);\n\t\tint n,m;\n\t\tPoint2D.Double[] w = new Point2D.Double[200];\n\t\tPoint2D.Double[] b = new Point2D.Double[200];\n\t\tfor(;;){\n\t\t\tn=cin.nextInt();\n\t\t\tm=cin.nextInt();\n\t\t\t//\t\t\tSystem.out.printf(\"%d %d\\n\",n,m);\n\t\t\t\n\t\t\tif(n==0 && m==0) break;\n\t\t\t\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tw[i] = new Point2D.Double();\n\t\t\t\tw[i].x= cin.nextInt();\n\t\t\t\tw[i].y= cin.nextInt();\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tb[i] = new Point2D.Double();\n\t\t\t\tb[i].x= cin.nextInt();\n\t\t\t\tb[i].y= cin.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint f=0;\n\t\tout:\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\t\tint t1=0,t2=0;\n\t\t\t\t\t//\t\t\t\t\tSystem.out.printf(\"%d  %d\\n\",i,j);\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(k==i) continue;\n\t\t\t\t\t\tint ccw=Line2D.relativeCCW( w[k].x, w[k].y, w[i].x, w[i].y, b[j].x, b[j].y);\n\t\t\t\t\t\t//\t\t\t\t\t\tif(ccw==0) if(w[i].distance(b[j]) + w[i].distance(w[k]) <= w[k].distance(b[j])) ccw=1;\n\t\t\t\t\t\t//\t\t\t\t\t\tSystem.out.println(ccw);\n\t\t\t\t\t\tt1+=ccw;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<m;k++){\n\t\t\t\t\t\tif(k==j) continue;\n\t\t\t\t\t\tint ccw=Line2D.relativeCCW(b[k].x, b[k].y, b[j].x, b[j].y, w[i].x, w[i].y);\n\t\t\t\t\t\t//\t\t\t\t\t\tSystem.out.println(ccw);\n\t\t\t\t\t\t//\t\t\t\t\t\tif(ccw==0) if(b[j].distance(w[i]) + b[j].distance(b[k]) <= w[i].distance(b[k])) ccw=-1;\n\t\t\t\t\t\t//\t\t\t\t\t\tSystem.out.println(ccw);\n\t\t\t\t\t\tt2+=ccw;\n\t\t\t\t\t}\n\t\t\t\t\t//\t\t\t\t\tSystem.out.printf(\"t1,t2= %d,%d\\n\",t1,t2);\n\t\t\t\t\tif(t1>=0 && t2>=0 && Math.abs(t1)==n-1 && Math.abs(t2)==m-1){\n\t\t\t\t\t\tf=1;\n\t\t\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f==0) System.out.println(\"NO\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//??????????????????????????????\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\nusing namespace std;\ntypedef complex<double> Point;\n\nnamespace std {\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(Point &u, Point &v) {\n\treturn u.real() * v.imag() - u.imag() * v.real();\n}\n\ndouble dot(Point &u, Point &v) {\n\treturn u.real() * v.real() + u.imag() * v.imag();\n}\n\n//Define : e_Re(???), e_Im(???)\n//a -> b -> counter clockwise -> c ???  1\n//a -> b -> clockwise -> c         ??? -1\n//c--a--b  ???  2\n//a--b--c  ??? -2\n//a--b(=c) ???  0\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0) return 1;\n\tif (cross(b, c) < 0) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\n//counter clockwise, ring buffer(ch[0] == ch[last])\nvector<Point> convex_hull(vector<Point> points) {\n\tint n = points.size();\n\tint k = 0;\n\tvector<Point> ch(2 * n);\n\t\n\tsort(points.begin(), points.end());\n\t\n\t//lower hull\n\tfor (int i = 0; i < n; i++) {\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], points[i]) <= 0) k--;\n\t\tch[k] = points[i];\n\t\tk++;\n\t}\n\t\n\t//upper hull\n\tint low_k = k;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\twhile (k > low_k && ccw(ch[k - 2], ch[k - 1], points[i]) <= 0) k--;\n\t\tch[k] = points[i];\n\t\tk++;\n\t}\n\tch.resize(k);\n\treturn ch;\n}\n\n//If line (a->b), (c->d) are hit with a point, return true.\nbool is_hit_line(Point a, Point b, Point c, Point d) {\n\tdouble u = cross(b - a, c - a) * cross(b - a, d - a);\n\tdouble v = cross(d - c, a - c) * cross(d - c, b - c);\n\tif (u > 0 || v > 0) return false;\n\tif (u != 0 || v != 0) return true;\n\t\n\tif (b < a) swap(a, b);\n\tif (d < c) swap(c, d);\n\t\n\tdouble eps = 1e-10;\n\tif (abs(d - a) + eps > abs(b - a) + abs(d - c)) return false;\n\treturn true;\n}\n\n//poly1, poly2 is convex polygon.\nbool is_hit(vector<Point> poly1, vector<Point> poly2) {\n\tfor (int i = 0; i < (int)poly1.size() - 1; i++) {\n\t\tfor (int j = 0; j < (int)poly2.size() - 1; j++) {\n\t\t\tif (is_hit_line(poly1[i], poly1[i + 1], poly2[j], poly2[j + 1])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nbool is_cover(vector<Point> poly, Point point) {\n\tbool in = false;\n\tfor (int i = 0; i < (int)poly.size() - 1; i++) {\n\t\tPoint a = poly[i] - point;\n\t\tPoint b = poly[i + 1] - point;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b)) if (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return false;\t//on poly\n\t}\n\treturn in;\n}\n\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m) {\n\t\tif (!n) break;\n\t\t\n\t\tvector<Point> poly1, poly2;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpoly1.push_back(Point((double)x, (double)y));\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpoly2.push_back(Point((double)x, (double)y));\n\t\t}\n\t\tpoly1 = convex_hull(poly1);\n\t\tpoly2 = convex_hull(poly2);\n\t\t\n\t\tif (is_hit(poly1, poly2) || is_cover(poly1, poly2[0]) || is_cover(poly2, poly1[0])) { cout << \"NO\" << endl; }\n\t\telse { cout << \"YES\" << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  int b, w;\n  while(cin>>b>>w && (b != 0 || w != 0)){\n    vector<double> x1(b), y1(b);\n    vector<double> x2(w), y2(w);\n    REP(i, b)cin>>x1[i]>>y1[i];\n    REP(i, w)cin>>x2[i]>>y2[i];\n    bool ans = false;\n    REP(time, 10000){\n      const double D = 100000.0;\n      double t = (double)rand()/RAND_MAX * D * ((rand() % 2) ?  1 : -1);\n      double min_b = 1e30, max_b = -1e30;\n      double min_w = 1e30, max_w = -1e30;\n      REP(i, b){\n        double d = (y1[i] + t)/x1[i];\n        min_b = min(min_b, d);\n        max_b = max(max_b, d);\n      }\n      REP(i, w){\n        double d = (y2[i] + t)/x2[i];\n        min_w = min(min_w, d);\n        max_w = max(max_w, d);\n      }\n      if(min_w > max_b) ans = true;\n      if(min_b > max_w) ans = true;\n      if(ans) break;\n    }\n    if(ans) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define EPS 0.000001\ntypedef long double ld;\n\n//FILE *in = freopen(\"input.txt\", \"r\", stdin);\n\nstruct P {\n\tld x, y;\n\tP(ld x, ld y):x(x),y(y){}\n\tP(){}\n};\n\nP operator -(const P &a, const P &b) { return P(a.x-b.x, a.y-b.y); }\nbool operator <(const P &a, const P &b){ return make_pair(a.x, a.y) < make_pair(b.x, b.y); }\n\nld cross(const P &a, const P &b) { return a.x*b.y-a.y*b.x; }\nld dot(const P &a, const P &b) { return a.x*b.x+a.y*b.y; }\nld norm(const P &a) { return dot(a,a); }\nint ccw(P a, P b, P c) {\n\tb = b - a; c = c - a;\n\tif(cross(b,c) > EPS) return 1;\n\tif(cross(b,c) < EPS) return -1;\n\tif(dot(b,c) < 0) return 2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nstruct L:vector<P>{\n\tL(P a=P(0,0), P b=P(0,0)) {\n\t\tthis->push_back(a);\n\t\tthis->push_back(b);\n\t}\n};\n\nbool is_intersect_SS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0],s[1],t[1]) <= 0 &&\n\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\n\nvector<P> convex_hull(vector<P> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<P> ch(2*n);\n\tfor(int i = 0; i < n; ch[k++]=ps[i++])\n\t\twhile(k >= 2 && ccw(ch[k-2],ch[k-1],ps[i]) <= 0)--k;\n\tfor(int i = n-2, t = k+1; i >= 0; ch[k++]=ps[i--])\n\t\twhile(k>=t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0)--k;\n\tch.resize(k-1);\n\treturn ch;\n}\n\nP curr(const vector<P>& a, int x){ return a[x]; }\nP nex(const vector<P>& a, int x){ return a[(x + 1) % a.size()]; }\n\n// 点が多角形のどこにあるのか判定する\nenum Polygon{ OUT, ON, IN };\nint contains(const vector<P>& poly, const P& p){\n  // 点pから半直線をひき、辺と交差する回数を数える\n  bool in = false;\n  rep(i, poly.size()){\n    P a = curr(poly, i) - p;\n    P b = nex(poly, i) - p;\n    if(a.y > b.y) swap(a, b);\n    // aからbの直線がy=0と交わり、その交点は原点の右側である\n    if(a.y <= 0 && 0 < b.y && cross(a, b) < 0){ \n      in = !in;\n    }\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nint n, m;\nvector<P> black;\nvector<P> white;\n\nvoid input() {\n\tblack.clear();\n\twhite.clear();\n\trep(i, n) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tblack.push_back(P(x,y));\n\t}\n\trep(i, m) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\twhite.push_back(P(x,y));\n\t}\n}\n\nvoid process() {\n\tauto b = convex_hull(black);\n\tauto w = convex_hull(white);\n\tblack = b.size() == 0 ? black : b;\n\twhite = w.size() == 0 ? white : w;\n\t\n\t// Check LP\n\trep(i,black.size()) {\n\t\tif(contains(white, black[i]) != OUT) {\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Check cross LL\n\trep(i,black.size()) {\n\t\tL x(black[i],black[(i+1)%black.size()]);\n\t\trep(j,white.size()){\n\t\t\tL y(white[j], white[(j+1)%white.size()]);\n\t\t\tif(is_intersect_SS(x,y)) {\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"YES\\n\");\n}\n\nint main() {\n\twhile(true) {\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(!n) break;\n\t\tinput();\n\t\tprocess();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint main(void)\n{\n  for(;;){\n    int n,m;\n    cin >> n >> m;\n    if(!n&&!m) return 0;\n    int a[100][2],b[100][2];\n    REP(i,n) cin >> a[i][0] >> a[i][1];\n    REP(j,m) cin >> b[j][0] >> b[j][1];\n    if(n==1 && m==1){\n      cout << \"YES\" << endl;\n      continue;\n    }\n    int axmax=0,axmin=1048576,bxmax=0,bxmin=1048576;\n    REP(i,n){\n      axmax=max(axmax,(a[i][0]));\n      axmin=min(axmin,(a[i][0]));\n    }\n    REP(j,m){\n      bxmax=max(bxmax,(b[j][0]));\n      bxmin=min(bxmin,(b[j][0]));\n    }\n    if(axmax<bxmin || axmin>bxmax){\n      cout << \"YES\" << endl;\n      continue;\n    }\n    bool flag=false;\n    REP(i,n) REP(j,i){\n      if(flag) break;\n      LL ho=a[j][0]-a[i][0];\n      LL ve=a[j][1]-a[i][1];\n      bool aup=true,alo=true,bup=true,blo=true;\n      int val=a[i][0]*ve-a[i][1]*ho;\n      REP(k,n){\n\tif(a[k][0]*ve-a[k][1]*ho > val) alo=false;\n\tif(a[k][0]*ve-a[k][1]*ho < val) aup=false;\n      }\n      if(!alo&&!aup) continue;\n      REP(k,m){\n\tif(b[k][0]*ve-b[k][1]*ho >= val) blo=false;\n\tif(b[k][0]*ve-b[k][1]*ho <= val) bup=false;\n      }\n      if(aup&&blo || alo&&bup){\n\tflag=true;\n      }\n    }\n    REP(i,m) REP(j,i){\n      if(flag) break;\n      LL ho=b[j][0]-b[i][0];\n      LL ve=b[j][1]-b[i][1];\n      bool aup=true,alo=true,bup=true,blo=true;\n      int val=b[i][0]*ve-b[i][1]*ho;\n      REP(k,n){\n\tif(a[k][0]*ve-a[k][1]*ho >= val) alo=false;\n\tif(a[k][0]*ve-a[k][1]*ho <= val) aup=false;\n      }\n      if(!alo&&!aup) continue;\n      REP(k,m){\n\tif(b[k][0]*ve-b[k][1]*ho > val) blo=false;\n\tif(b[k][0]*ve-b[k][1]*ho < val) bup=false;\n      }\n      if(aup&&blo || alo&&bup){\n\tflag=true;\n      }\n    }\n    if(flag) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-8\n#define INF 1000000\n \nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n    Point operator *(const double d)const{\n        return Point(x*d,y*d);\n    }\n    bool operator <(const Point &p)const{\n        if(x==p.x) return y<p.y;\n        return x<p.x;\n    }\n    double norm(){\n        return x*x+y*y;\n    }\n\tbool input(){\n\t\tif(cin>>x>>y) return true;\n\t\treturn false;\n\t}\n};\n \nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n\tbool input(){\n\t\tif(a.input() && b.input()) return true;\n\t\treturn false;\n\t}\n};\n \nstruct Circle{\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point _c,double _r){\n        c=_c; r=_r;\n    }\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n \nint ccw(Point a,Point b,Point c){ //a,b,c,は全て異なる\n\tPoint v1 = b-a;\n\tPoint v2 = c-a;\n    if(cross(v1,v2)>EPS) return +1; //a->b->c が反時計回り\n    if(cross(v1,v2)<-EPS) return -1; //a->b->c が時計回り\n\tif(dot(v1,v2)<-EPS) return +2; //cがa-bより後ろ c<-a->b\n\tif(v1.norm()<v2.norm()) return -2; //cがa-bより前 a->b->c\n    return 0; //cがa-b上 a->c->b\n}\n \nbool intersect_ss(Line l,Line m){\n\treturn ccw(l.a,l.b,m.a)*ccw(l.a,l.b,m.b)<=0 && ccw(m.a,m.b,l.a)*ccw(m.a,m.b,l.b)<=0;\n}\n \nbool crosspoint_ll(Line l,Line m,Point &p){\n    Point a1,a2,b1,b2;\n    a1 = l.b-l.a; a2 = m.b-m.a;\n    b1 = m.a-l.a; b2 = l.a-m.b;\n    double s1,s2;\n    s1 = cross(a1,b1)/2; s2 = cross(a1,b2)/2;\n    if(s1+s2<EPS) return false; //平行\n    p = Point(m.a.x+a2.x*s1/(s1+s2),m.a.y+a2.y*s1/(s1+s2));\n    return true;\n}\n \nint crosspoint_ss(Line l,Line m,Point &p){\n    if(intersect_ss(l,m)==false) return 0; //交差していない\n    if(crosspoint_ll(l,m,p)==true) return 1;\n\treturn -1; //交点が無限個(平行かつ交差)\n}\n \nint crosspoint_cc(Circle c1,Circle c2,Point &p1,Point &p2){\n    double d,a,t;\n    d = sqrt((c2.c-c1.c).norm());\n\tif(abs(c1.c.x-c2.c.x)<EPS && abs(c1.c.y-c2.c.y)<EPS && abs(c1.r-c2.r)<EPS)\n\t\treturn -1; //2つの円が重なっている\n    if(d<abs(c1.r-c2.r) || c1.r+c2.r<d) return 0; //どちらかが内包している\n    a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    t = atan2(c2.c.y-c1.c.y,c2.c.x-c1.c.x);\n    p1 = Point(c1.c.x+c1.r*cos(t+a),c1.c.y+c1.r*sin(t+a));\n    p2 = Point(c1.c.x+c1.r*cos(t-a),c1.c.y+c1.r*sin(t-a));\n    if(abs(p1.x-p2.x)<EPS && abs(p1.y-p2.y)<EPS) return 1; //交点が1つ\n    return 2; //交点が2つ\n}\n\nint contains(Polygon g,Point p){\n\tLine l = Line(p,Point(INF,p.y));\n\tint cnt = 0, n = g.size();\n\tfor(int i=0;i<n;i++){\n\t\tPoint a = g[i]-p;\n\t\tPoint b = g[(i+1)%n]-p;\n\t\tif(ccw(g[i],g[(i+1)%n],p)==0) return 1; //線分上\n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<=EPS && EPS<b.y && cross(a,b)>EPS) cnt++;\n\t}\n\tif((cnt&1)==1) return 2; //内包している\n\treturn 0; //内包していない\n}\n\nPolygon andrewScan(Polygon s){\n\tif(s.size()<=2) return s;\n\tsort(s.begin(),s.end());\n\tPolygon g;\n\tfor(int i=0;i<s.size();i++){\n\t\tfor(int n=g.size(); n>=2 && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\tint upper_n = g.size();\n\tfor(int i=s.size()-2;i>=0;i--){\n\t\tfor(int n=g.size(); n>upper_n && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\treverse(g.begin(),g.end());\n\tg.pop_back();\n\treturn g;\n}\n\nint main(){\n\tint N,M;\n\tPolygon b,w,gb,gw;\n\twhile(cin>>N>>M,N||M){\n\t\tb.resize(N); w.resize(M);\n\t\tfor(int i=0;i<N;i++) b[i].input();\n\t\tfor(int i=0;i<M;i++) w[i].input();\n\t\tgb = andrewScan(b); gw = andrewScan(w);\n\t\t/*for(int i=0;i<gb.size();i++) printf(\"%f,%f \",gb[i].x,gb[i].y); puts(\"\");\n\t\tfor(int i=0;i<gw.size();i++) printf(\"%f,%f \",gw[i].x,gw[i].y); puts(\"\");*/\n\t\tbool ans = true;\n\t\tfor(int i=0;i<gb.size() && ans;i++){\n\t\t\tfor(int j=0;j<gw.size() && ans;j++){\n\t\t\t\tLine l(gb[i],gb[(i+1)%gb.size()]), m(gw[j],gw[(j+1)%gw.size()]);\n\t\t\t\tif(intersect_ss(l,m)==true) ans = false;\n\t\t\t}\n\t\t}\n\t\tif(gb.size()>=3){\n\t\t\tfor(int i=0;i<M && ans;i++){\n\t\t\t\tif(contains(gb,w[i])!=0) ans = false;\n\t\t\t}\n\t\t}\n\t\tif(gw.size()>=3){\n\t\t\tfor(int i=0;i<N && ans;i++){\n\t\t\t\tif(contains(gw,b[i])!=0) ans = false;\n\t\t\t}\n\t\t}\n\t\tif(gb.size()==2 && gw.size()==1){\n\t\t\tif(ccw(gb[0],gb[1],gw[0])==0) ans = false;\n\t\t}\n\t\tif(gw.size()==2 && gb.size()==1){\n\t\t\tif(ccw(gw[0],gw[1],gb[0])==0) ans = false;\n\t\t}\n\t\tif(ans==true) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(i,s)cout <<\" \"<<i;cout<<endl\n\nusing namespace std;\n\ntypedef complex<double> C;\ntypedef pair<int,int>P;\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\nstruct L : public vector<C>\n{\n    L(const C a, const C b) {\n        push_back(a); push_back(b);\n    }\n};\n\nbool eq(double a,double b)\n{\n  return (-EPS<a-b&&a-b<EPS);\n}\n\nbool eq(C c1,C c2)\n{\n  return (eq(c1.real(),c2.real()) && eq(c1.imag(),c2.imag()));\n}\n\n//?????¶??????sqrt\ndouble Sqrt(double x)\n{\n    if(x<0) return 0;\n    else    return sqrt(x);\n}\n\n//??£??????\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//?§????(rad)\ndouble getarg(C a,C b){\n    return  arg(b*conj(a));\n}\n\n//??????\ndouble cross(const C a, const C b)\n{\n    return  imag(conj(a)*b);\n}\n//??????\ndouble dot(const C a, const C b)\n{\n    return  real(conj(a)*b);\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;                               // a--c--b on line\n}\n//??´???????????????????????????(????????´??????True)\nbool intersectLL(const L &l, const L &m)\n{\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n//??´?????¨?????????????????????(????????±??????????????¨??????)\nbool intersectLS(const L &l, const L &s)\n{\n    return cross(l[1]-l[0], s[0]-l[0]) * cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\n//??´?????¨????????????(??±???)??????\nbool intersectLP(const L &l, const C p)\n{\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n//??????????????????????????????(????????±??????????????¨??????)\nbool intersectSS(const L &s, const L &t)\n{\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n//????????¨????????????(??±???)??????\nbool intersectSP(const L &s, const C p)\n{\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n//???p?????´???l???????°???±\nC projection(const L &l, const C p)\n{\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n//???p?????´???l????????¨??????????§°?§????\nC reflection(const L &l, const C p)\n{\n    return p + (projection(l, p) - p)*2.0;\n}\n//?????¨??´???????????¢\ndouble distanceLP(const L &l, const C p)\n{\n    return abs(p - projection(l, p));\n}\n//??´?????¨??´???????????¢\ndouble distanceLL(const L &l, const L &m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n//??´?????¨??????????????¢\ndouble distanceLS(const L &l, const L &s)\n{\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n//????????¨???????????¢\ndouble distanceSP(const L &s, const C p)\n{\n    const C r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n//????????¨??????????????¢\ndouble distanceSS(const L &s, const L &t)\n{\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n//??´???????????????????????????\nC crosspointLL(const L &l, const L &m)\n{\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    //????????´????????¨???\n    if(abs(A) < EPS && abs(B) < EPS){\n        return m[0];\n    }\n    return m[0] + B / A * (m[1] - m[0]);\n}\n//?????¨??´????????????\ndouble gettime(C c1,C c2)\n{\n  return (dot(c1,c2) < 0 ? -1.0 : 1.0 ) * abs(c2) / abs(c1);\n}\n//?????¨??´????????????\nvector<C> crosspointCL(C c1,double r1,L l)\n{\n    C a=l[0], b=l[1];\n    vector<C> res;\n    C base=b-a,  target=projection(L(a,b),c1);\n    double length=abs(base), h=abs(c1-target);\n    base/=length;\n    if(r1+EPS<h)    return res;\n    double w=Sqrt(r1*r1-h*h);\n    double LL=gettime(normalize(b-a),target-a)-w,RR=LL+w*2.0;\n    res.push_back(a+base*LL);\n    if(eq(LL,RR))   return res;\n    res.push_back(a+base*RR);\n    return res;\n}\n//?????¨???????????????\nvector<C> crosspointCS(C c1,double r1,L s)\n{\n    vector<C> tmp=crosspointCL(c1,r1,s);\n    vector<C> res;\n    rep(i,tmp.size()){\n        if(eq(abs(s[1]-s[0]),abs(s[0]-tmp[i])+abs(s[1]-tmp[i]))){\n            res.push_back(tmp[i]);\n        }\n    }\n    return res;\n}\n//?????????????????????\nL crosspointCC(const C c1, const double r1, const C c2, const double r2)\n{\n  C a = conj(c2-c1), b = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), c = r1*r1*(c2-c1);\n  C d = b*b-4.0*a*c;\n  C z1 = (-b+sqrt(d))/(2.0*a)+c1, z2 = (-b-sqrt(d))/(2.0*a)+c1;\n  return L(z1, z2);\n}\n//?????¨????§???¢?????±?????¨????????¢???\ndouble getarea(C c1,double r1,C a,C b)\n{\n    C va=c1-a,vb=c1-b;\n    double A=abs(va),B=abs(vb);\n    double f=cross(va,vb),d=distanceSP(L(a,b),c1),res=0;\n    if(eq(f,0.0))   return 0;\n    if(A < r1+EPS && B < r1+EPS)    return f*0.5;\n    if(d>r1-EPS)    return r1*r1*M_PI*getarg(va,vb)/(2.0*M_PI);\n    vector<C> u=crosspointCS(c1,r1,L(a,b));\n    u.insert(u.begin(),a),u.push_back(b);\n    for(int i=0;i+1<(int)u.size();i++){\n        res+=getarea(c1,r1,u[i],u[i+1]);\n    }\n    return res;\n}\ndouble getcrossarea(vector<C> t,C c1,double r1)\n{\n    int n=t.size();\n    if(n<3) return 0;\n    double res=0;\n    rep(i,n){\n      C a=t[i], b=t[(i+1)%n];\n      res += getarea(c1,r1,a,b);\n    }\n    return res;\n}\n//??????????±???????\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n//?????§??????\nbool isconvex(const vector<C> &ps)\n{\n    rep(i,ps.size()){\n        if (ccw(ps[(i+ps.size()-1) % ps.size()],ps[i],ps[(i+1) % ps.size()])) return false;\n    }\n    return true;\n}\n//????§???¢?????¢???\ndouble area(const vector<C> &ps)\n{\n    double A = 0;\n    rep(i,ps.size()){\n        A += cross(ps[i],ps[(i+1) % ps.size()]);\n    }\n    return A / 2.0;\n}\n//???????§???¢?????´?????§???????????????????????´????????¢\nvector<C> convex_cut(const vector<C> &ps, const L &l)\n{\n    vector<C> Q;\n    rep(i,ps.size()){\n        C A = ps[i], B = ps[(i+1)%ps.size()];\n        if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n        if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspointLL(L(A, B),l));\n    }\n    return Q;\n}\n//??????????§???¢???????????????????????????(0??????????????????,1?????????,2???????????????)\nint contains(const vector<C>& ps, const C p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n//???????§???¢?????´???????±???????(?????£????????????)\n//maxi,maxj?????????????????¨??????\ndouble convex_diameter(const vector<C> &ps)\n{\n    const int n = ps.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(ps[i]) > imag(ps[is])) is = i;\n        if (imag(ps[i]) < imag(ps[js])) js = i;\n    }\n    double maxd = abs(ps[is]-ps[js]);\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if (cross(ps[(i+1)%ps.size()]-ps[i],ps[(j+1)%ps.size()]-ps[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (abs(ps[i]-ps[j]) > maxd) {\n            maxd = abs(ps[i]-ps[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd;\n}\n\nbool compyx(C c1,C c2)\n{\n    return c1.imag() != c2.imag() ? c1.imag() < c2.imag() : c1.real() < c2.real();\n}\n\n//????????????????±???????\ndouble closest_pair(C *a, int n)\n{\n    if(n<=1) return INF;\n    int m=n/2;\n    double x=a[m].real();\n    double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n    inplace_merge(a,a+m,a+n,compyx);\n    vector<C> b;\n    rep(i,n){\n        if(abs(x-a[i].real())>=d) continue;\n        rep(j,b.size()){\n            C dp=a[i]-b[b.size()-1-j];\n            if(dp.imag()>=d) break;\n            d=min(d,abs(dp));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\ndouble compute_shortest(C *a,int n)\n{\n    sort(a,a+n);\n    return closest_pair(a,n);\n}\n//2??????????????¢????????????(????????????2??????????????±?????\\????????°)\nint getstateCC(C c1,double r1,C c2,double r2)\n{\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)return 4;\n    if(d>r1+r2-EPS)return 3;\n    if(d>abs(r1-r2)+EPS)return 2;\n    if(d>abs(r1-r2)-EPS)return 1;\n    return 0;\n}\n//?????????????????\\???????????????????????\\???\nC gettangentCP_(C c1,double r1,C p,int flg){\n    C base=c1-p;\n    double w=Sqrt(norm(base)-r1*r1);\n    C s=p+base*C(w,r1 * flg)/norm(base)*w;\n    return s;\n}\n//????????????????????\\???\nvector<L> gettangentCP(C c1,double r1,C p){\n    vector<L> res;\n    C s=gettangentCP_(c1,r1,p,1);\n    C t=gettangentCP_(c1,r1,p,-1);\n    //??????????????¨??????????????´???\n    if(eq(s,t)){\n        res.push_back(L(s,s+(c1-p)*C(0,1)));\n    }else{\n        res.push_back(L(p,s));\n        res.push_back(L(p,t));\n    }\n    return res;\n}\n\n//2????????±????????\\???????±???????\nL getintangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double w=r1+r2;\n    double h=Sqrt(norm(base)-w*w);\n    C k=base*C(w,h*flg)/norm(base);\n    return L(c1+k*r1,c2-k*r2);\n}\n//2????????±????????\\???????±???????\nL getouttangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double h=r2-r1;\n    double w=Sqrt(norm(base)-h*h);\n    C k=base*C(w,h*flg)/norm(base)*C(0,flg);\n    return L(c1+k*r1,c2+k*r2);\n}\n//2????????±?????\\???????±???????(?????´??????????????????????????????????????\\???)\nvector<L> gettangentCC(C c1,double r1,C c2,double r2)\n{\n    vector<L> res;\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)  res.push_back(getintangent(c1,r1,c2,r2,1));\n    if(d>r1+r2-EPS)  res.push_back(getintangent(c1,r1,c2,r2,-1));\n    if(d>abs(r1-r2)+EPS)    res.push_back(getouttangent(c1,r1,c2,r2,1));\n    if(d>abs(r1-r2)-EPS)    res.push_back(getouttangent(c1,r1,c2,r2,-1));\n    return res;\n}\n\nint main()\n{\n    while(1){\n        int n,m;\n        cin >> n >> m;\n        if(n == 0){\n            break;\n        }\n        vector<C> v1,v2;\n        rep(i,n){\n            int x,y;\n            cin >> x >> y;\n            v1.pb(C(x,y));\n        }\n        rep(i,m){\n            int x,y;\n            cin >> x >> y;\n            v2.pb(C(x,y));\n        }\n        bool line1=true,line2=true;\n        rep(i,n){\n            for(int j=i+1;j<n;j++){\n                for(int k=j+1;k<n;k++){\n                    int hoge = ccw(v1[i],v1[j],v1[k]);\n                    if(hoge == 1 || hoge == -1){\n                        line1 = false;\n                        break;\n                    }\n                }\n                if(!line1){\n                    break;\n                }\n            }\n            if(!line1){\n                break;\n            }\n        }\n        rep(i,m){\n            for(int j=i+1;j<m;j++){\n                for(int k=j+1;k<m;k++){\n                    int hoge = ccw(v2[i],v2[j],v2[k]);\n                    if(hoge == 1 || hoge == -1){\n                        line2 = false;\n                        break;\n                    }\n                }\n                if(!line2){\n                    break;\n                }\n            }\n            if(!line2){\n                break;\n            }\n        }\n        bool same;\n        if(line1 && line2){\n            if(n >= 2){\n                same = !(ccw(v1[0],v1[1],v2[0]) == 1 || ccw(v1[0],v1[1],v2[0]) == -1);\n            }else{\n                if(m >= 2){\n                    same = !(ccw(v2[0],v2[1],v1[0]) == 1 || ccw(v2[0],v2[1],v1[0]) == -1);\n                }else{\n                    cout << \"YES\\n\";\n                    continue;\n                }\n            }\n        }\n        if(line1 && line2 && same){\n            vector<P> vec;\n            rep(i,n){\n                vec.pb(P(v1[i].real(),0));\n            }\n            rep(i,m){\n                vec.pb(P(v2[i].real(),1));\n            }\n            sort(all(vec));\n            int bf = vec[0].se;\n            int check=0;\n            bool ans = true;\n            for(int i=1;i<vec.size();i++){\n                if(bf != vec[i].se){\n                    bf = vec[i].se;\n                    check++;\n                }\n                if(check>=2){\n                    ans = false;\n                    break;\n                }\n            }\n            if(ans){\n                cout << \"YES\\n\";\n            }else{\n                cout << \"NO\\n\";\n            }\n        }else{\n            if(m >= 2){\n                bool ans = false;\n                rep(i,m){\n                    for(int j=i+1;j<m;j++){\n                        bool flag = true;\n                        int bf = ccw(v2[i],v2[j],v1[0]);\n                        if(bf != 1 && bf != -1){\n                            continue;\n                        }\n                        for(int k=1;k<n;k++){\n                            if(bf == ccw(v2[i],v2[j],v1[k])){\n                                bf = ccw(v2[i],v2[j],v1[k]);\n                            }else{\n                                flag = false;\n                                break;\n                            }\n                        }\n                        if(!flag){\n                            continue;\n                        }\n                        rep(k,m){\n                            if(ccw(v2[i],v2[j],v2[k]) == bf){\n                                flag = false;\n                                break;\n                            }\n                        }\n                        if(flag){\n                            ans = true;\n                        }\n                    }\n                    if(ans){\n                        break;\n                    }\n                }\n                if(ans){\n                    cout << \"YES\\n\";\n                    continue;\n                }else if(n == 1){\n                    cout << \"No\\n\";\n                    continue;\n                }\n            }\n            if(n >= 2){\n                bool ans = false;\n                rep(i,n){\n                    for(int j=i+1;j<n;j++){\n                        bool flag = true;\n                        int bf = ccw(v1[i],v1[j],v2[0]);\n                        if(bf != 1 && bf != -1){\n                            continue;\n                        }\n                        for(int k=1;k<m;k++){\n                            if(bf == ccw(v1[i],v1[j],v2[k])){\n                                bf = ccw(v1[i],v1[j],v2[k]);\n                            }else{\n                                flag = false;\n                                break;\n                            }\n                        }\n                        if(!flag){\n                            continue;\n                        }\n                        rep(k,n){\n                            if(ccw(v1[i],v1[j],v1[k]) == bf){\n                                flag = false;\n                                break;\n                            }\n                        }\n                        if(flag){\n                            ans = true;\n                        }\n                    }\n                    if(ans){\n                        break;\n                    }\n                }\n                if(ans){\n                    cout << \"YES\\n\";\n                }else{\n                    cout << \"NO\\n\";\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\n\nusing R=long double; // __float128\nconst R EPS = 1E-11; // [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline int sgn(const R& a, const R &b){ return sgn(a-b); }\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n    bool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n    bool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\ninline bool cmp_x(const P& p,const P& q){return sgn(real(p-q))?real(p)<real(q):sgn(imag(p-q));}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){l.t-=l.s,p-=l.s;return l.s+l.t*real(p/l.t);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n    if (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n    if (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n    if (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n    if (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n    return ON;// base--b--a on line  a??¨b????????????????????????\n}\n\nint main(void){\n    for(int n, m; cin >> n >> m, n;){\n        VP ps(n + m);\n        for(auto& e : ps) cin >> e;\n\n        if(n == 1 and m == 1){\n            cout << \"YES\" << endl;\n            continue;\n        }\n\n        bool b = true;\n        rep(i, 2, n + m){\n            if(det(ps[0], ps[1], ps[i]) != 0){\n                b = false;\n                break;\n            }\n        }\n\n        if(b){\n            VP nps(2 * (n + m));\n            P p(-imag(ps[1] - ps[0]), real(ps[1] - ps[0]));\n            rep(i, n + m){\n                nps[2 * i    ] = ps[i];\n                nps[2 * i + 1] = ps[i] + p;\n            }\n            ps = nps;\n            n *= 2, m *= 2;\n        }\n\n        auto f = [&]{\n            rep(i, n + m){\n                rep(j, i, n + m){\n                    if(i < n and j >= n) break;\n\n                    L l = {ps[i], ps[j]};\n                    bool on1 = false, on2 = false;\n                    int sign1 = 0, sign2 = 0;\n\n                    bool ok = true;\n                    rep(k, n + m){\n                        R ret = det(l.s, l.t, ps[k]);\n                        if(ret == 0){\n                            if(k < n) on1 = true;\n                            else      on2 = true;\n                        }\n                        else {\n                            if(sign1 == 0){\n                                if(k < n){\n                                    sign1 = sgn(ret);\n                                    sign2 = -sign1;\n                                }\n                                else {\n                                    sign2 = sgn(ret);\n                                    sign1 = -sign2;\n                                }\n                            }\n                            else {\n                                if((k < n and sign1 != sgn(ret)) or (k >= n and sign2 != sgn(ret))){\n                                    ok = false;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    if(on1 and on2) ok = false;\n\n                    if(ok) return true;\n                }\n            }\n            return false;\n        };\n\n        if(f()){\n            cout << \"YES\" << endl;\n        }\n        else {\n            cout << \"NO\" << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\n\ndouble eps = 0.0000001;\n// asin(1.) * 2\ndouble pi = 3.14159265358979323846264338327950288;\nusing p2 = complex<double>;\n// x: real\n// y: imag\n\ndouble det(p2 v1, p2 v2) {\n  return v1.real() * v2.imag() - v1.imag() * v2.real();\n}\n\ndouble dot(p2 v1, p2 v2) {\n  return v1.real() * v2.real() + v1.imag() * v2.imag();\n}\n\ndouble dist2(p2 v) {\n  return dot(v, v);\n}\n\ndouble dist(p2 v) {\n  return sqrt(dist2(v));\n}\n\nbool same(double x, double y) { return abs(x - y) < eps; }\n\ndouble dist2(p2 l1, p2 l2) { return dot(l1 - l2, l1 - l2); }\n\ndouble dist(p2 l1, p2 l2) {\n  return sqrt(dist2(l1, l2));\n}\n\nint ccw(p2 a, p2 b, p2 c) {\n  b -= a;\n  c -= a;\n  if (det(b, c) > eps)return 1;\n  if (det(b, c) < -eps) return -1;\n  if (dot(b, c) < -eps) return 2;\n  if (dist2(b) < dist2(c)) return -2;\n  return 0;\n}\n\nauto p2comp = [](const p2 &l, const p2 &r) {\n  if (abs(l.real() - r.real()) > eps)\n    return l.real() < r.real();\n  return l.imag() < r.imag();\n};\n\nstruct Line {\n  p2 st, ed;\n\n  Line(p2 st, p2 ed) : st(st), ed(ed) {}\n\n  Line(double x1, double y1, double x2, double y2)\n    : st(p2(x1, y1)), ed(p2(x2, y2)) {}\n\n  Line(p2 st, double x, double y) : st(st), ed(p2(x, y)) {}\n\n  Line(double x, double y, p2 ed) : st(p2(x, y)), ed(ed) {}\n\n  double dist() { return sqrt(dist2(st, ed)); }\n\n  bool isPalla(Line l) { return abs(det(ed - st, l.ed - l.st)) < eps; }\n\n  double x() { return ed.real() - st.real(); }\n\n  double y() { return ed.imag() - st.imag(); }\n\n  p2 v() { return ed - st; }\n};\n\n// l1.st + (l1.st - l1.ed) * r.first = l2.st + (l2.st - l2.ed) * r.second\n// 方程式を満たす(r.first, r.second)を返す\n// l1.isPalla(l2) => (nan, nan)\npair<double, double> interP(Line l1, Line l2) {\n  double a = l1.x();\n  double b = -l2.x();\n  double c = l1.y();\n  double d = -l2.y();\n  double inv = 1. / (a * d - c * b);\n  double e1 = -l1.st.real() + l2.st.real();\n  double e2 = -l1.st.imag() + l2.st.imag();\n  return make_pair((d * e1 - b * e2) * inv, (-c * e1 + a * e2) * inv);\n}\n\nbool intersec(Line l1, Line l2) {\n  if (l1.isPalla(l2))\n    return false;\n  auto r = interP(l1, l2);\n  return -eps < r.first && r.first < 1. + eps && -eps < r.second &&\n         r.second < 1. + eps;\n}\n\ndouble inter_r(Line l, p2 c) {\n  p2 a = l.st, b = l.ed;\n  return dot(c - a, l.v()) / dist2(l.v());\n}\n\ndouble dist(Line l, p2 c) {\n  double r = inter_r(l, c);\n  if (r < -eps) return dist(l.st, c);\n  if (1. + eps < r) return dist(l.ed, c);\n  return dist(l.st + l.v() * r, c);\n}\n\np2 nearest(Line l, p2 c) {\n  double r = inter_r(l, c);\n  if (r < -eps) return l.st;\n  if (1. + eps < r) return l.ed;\n  return l.st + l.v() * r;\n}\n\ndouble dist(Line l1, Line l2) {\n  return min(min(dist(l1, l2.st), dist(l1, l2.ed)), min(dist(l2, l1.st), dist(l2, l1.ed)));\n}\n\nstruct Poly {\n  vector<p2> ps;\n  double d;\n\n  Poly(vector<p2> ps) : ps(ps) {\n    d = 0;\n    for (int i = 0; i < ps.size(); i++) d += dist(ps[i], ps[(i + 1) % ps.size()]);\n  }\n\n  // 頂点上/辺上は微妙\n  bool include(p2 p) {\n    // 半直線\n    Line l(p, p2(-10000, -1));\n    int c = 0;\n    for (int i = 0; i < ps.size(); i++) {\n      if (intersec(l, Line(ps[i], ps[(i + 1) % ps.size()]))) c++;\n    }\n    return c % 2 == 1;\n  }\n\n  bool include(p2 p, bool on_vert, bool on_edge) {\n    for (auto &q : ps) if (dist(p, q) < eps) return on_vert;\n    for (int i = 0; i < ps.size(); i++) {\n      if (ccw(ps[i], ps[(i + 1) % ps.size()], p) == 0) return on_edge;\n    }\n    return include(p);\n  }\n\n  bool intersecl(Line l) {\n    for (int i = 0; i < ps.size(); i++) {\n      if (intersec(l, Line(ps[i], ps[(i + 1) % ps.size()])))\n        return true;\n    }\n    return false;\n  }\n};\n\nstruct Circle {\n  p2 p;\n  double r;\n\n  Circle(p2 p, double r) : p(p), r(r) {}\n\n  bool include(p2 l) { return dist2(p, l) < r * r + eps; }\n\n  // 円同士の交点\n  // 存在すれば2つ\n  vector<p2> intersec(Circle c) {\n    p2 diff = c.p - p;\n    double dist = dot(diff, diff);\n    double a = (dist + r * r - c.r * c.r) / 2.;\n    double D = dist * r * r - a * a;\n    if (D < eps)\n      return vector<p2>();\n    double Dsqrt = sqrt(D);\n    vector<p2> ps;\n    ps.emplace_back((a * diff.real() + diff.imag() * Dsqrt) / dist + p.real(),\n                    (a * diff.imag() - diff.real() * Dsqrt) / dist + p.imag());\n    ps.emplace_back((a * diff.real() - diff.imag() * Dsqrt) / dist + p.real(),\n                    (a * diff.imag() + diff.real() * Dsqrt) / dist + p.imag());\n    return ps;\n  }\n};\n\n// Δabc contains p\nbool trig_contains(p2 a, p2 b, p2 c, p2 p) {\n  bool all_pos = true, all_neg = true;\n  int v = ccw(a, b, p);\n  if (v < 0) all_pos = false;\n  if (v > 0) all_neg = false;\n  v = ccw(b, c, p);\n  if (v < 0) all_pos = false;\n  if (v > 0) all_neg = false;\n  v = ccw(c, a, p);\n  if (v < 0) all_pos = false;\n  if (v > 0) all_neg = false;\n  return all_neg || all_pos;\n}\n\n// 半時計回り\nstruct ConX {\n  vector<p2> ps;\n  p2 g;\n\n  // graham scan\n  // ref: プログラミングコンテストチャレンジブック p233\n  ConX(vector<p2> v) {\n    sort(v.begin(), v.end(), p2comp);\n\n    int k = 0, n = v.size();\n    ps.resize(n * 2);\n    for (int i = 0; i < n; i++) {\n      while (k > 1 && det(ps[k - 1] - ps[k - 2], v[i] - ps[k - 1]) < eps)\n        k--;\n      ps[k++] = v[i];\n    }\n    for (int i = n - 2, t = k; i >= 0; i--) {\n      while (k > t && det(ps[k - 1] - ps[k - 2], v[i] - ps[k - 1]) < eps)\n        k--;\n      ps[k++] = v[i];\n    }\n    ps.resize(k - 1);\n    double sum_x = 0., sum_y = 0.;\n    for (auto &p : ps) {\n      sum_x += p.real();\n      sum_y += p.imag();\n    }\n    g = p2(sum_x / ps.size(), sum_y / ps.size());\n  }\n\n  Poly toPoly() {\n    return Poly(ps);\n  }\n\n  bool contains(p2 p) {\n    if (trig_contains(g, ps[0], ps.back(), p)) {\n      return true;\n    }\n    int l = 0, r = ps.size() - 1;\n    while (r - l > 1) {\n      int m = (l + r) / 2;\n      if (ccw(g, ps[m], p) >= 0) {\n        l = m;\n      } else {\n        r = m;\n      }\n    }\n    return trig_contains(g, ps[l], ps[l + 1], p);\n  }\n\n  size_t size() { return ps.size(); }\n};\n\nint n;\nvector<double> rs;\nvector<p2> ps;\nvector<Circle> cs;\n\nbool f(double l) {\n  cs.clear();\n  for (int i = 0; i < n; i++) {\n    double rr = rs[i] * rs[i] - l * l;\n    if (rr < eps)\n      return false;\n    cs.emplace_back(ps[i], sqrt(rr));\n  }\n  vector<p2> may;\n  for (int i = 0; i < n; i++) {\n    may.push_back(cs[i].p);\n    for (int j = i + 1; j < n; j++) {\n      auto v = cs[i].intersec(cs[j]);\n      if (v.size() == 0)\n        continue;\n      may.push_back(v[0]);\n      may.push_back(v[1]);\n    }\n  }\n  for (auto &p : may) {\n    bool ok = true;\n    for (auto &c : cs) {\n      if (!c.include(p)) {\n        ok = false;\n        break;\n      }\n    }\n    if (ok)\n      return true;\n  }\n  return false;\n}\n\nbool solve() {\n  int n, m;\n  cin >> n >> m;\n  if (n == 0 && m == 0) return false;\n  vector<p2> p, q;\n  for (int i = 0; i < n; i++) {\n    double x, y;\n    cin >> x >> y;\n    p.emplace_back(x, y);\n  }\n  for (int i = 0; i < m; i++) {\n    double x, y;\n    cin >> x >> y;\n    q.emplace_back(x, y);\n  }\n  if (n == 1 && m == 1) {\n    cout << \"YES\" << endl;\n    return true;\n  }\n  if (n == 2 && m == 1) {\n    if (ccw(p[0], p[1], q[0])) {\n      cout << \"YES\" << endl;\n    } else {\n      cout << \"NO\" << endl;\n    }\n    return true;\n  }\n  if (n == 1 && m == 2) {\n    if (ccw(q[0], q[1], p[0])) {\n      cout << \"YES\" << endl;\n    } else {\n      cout << \"NO\" << endl;\n    }\n    return true;\n  }\n  if (n == 2 && m == 2) {\n    if (intersec(Line(p[0], p[1]), Line(q[0], q[1]))) {\n      cout << \"NO\" << endl;\n    } else {\n      cout << \"YES\" << endl;\n    }\n    return true;\n  }\n\n  ConX pc(p), qc(q);\n  bool ans = true;\n  for (int i = 0; i < pc.size(); i++) {\n    for (int j = 0; j < qc.size(); j++) {\n      int i2 = (i + 1) % pc.size();\n      int j2 = (j + 1) % qc.size();\n      if (intersec(Line(pc.ps[i], pc.ps[i2]), Line(qc.ps[j], qc.ps[j2]))) {\n        ans = false;\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (qc.contains(p[i])) {\n      ans = false;\n    }\n  }\n  for (int i = 0; i < m; i++) {\n    if (pc.contains(q[i])) {\n      ans = false;\n    }\n  }\n  if (ans) {\n    cout << \"YES\" << endl;\n  } else {\n    cout << \"NO\" << endl;\n  }\n  return true;\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  while (solve());\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef complex<double> P;\ntypedef pair<P,P> L;\n \nconst double EPS = 1e-7;\nconst int MAX = 10000;\n \nnamespace std{\n  bool operator < (const P& a, const P& b) {\n    return fabs(real(a) - real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n \n \ndouble dot(P a, P b){ return real(conj(a)*b);}\ndouble cross(P a, P b){ return imag(conj(a)*b);}\n \nbool equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n \nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n \nbool isIntersectSS(L s1, L s2){\n  return (ccw(s1.first, s1.second, s2.first) * ccw(s1.first, s1.second, s2.second) <= 0 &&\n      ccw(s2.first, s2.second, s1.first) * ccw(s2.first, s2.second, s1.second) <= 0);\n}\n \nbool isIntersectSP(L s, P p){\n  return abs(s.first - p) + abs(s.second - p) - abs(s.second - s.first) < EPS;\n}\n \nP crosspoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first); \n}\n \nvector<P> convex_hull(vector<P> ps){\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for(int i=0; i<n; ch[k++] = ps[i++])\n    while(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for(int i=n-2, t=k+1; i>=0; ch[k++] = ps[i--])\n    while(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \nint contains(const vector<P> &v, P p){\n  bool in = false;\n  for(int i=0;i<v.size();i++){\n    P a = v[i] - p;\n    P b = v[(i+1)%v.size()] - p;\n    if(imag(a) > imag(b)) swap(a,b);\n    if(imag(a) <= EPS && EPS < imag(b))\n      if(cross(a,b) < -EPS) in = !in;\n    if(equal(cross(a,b), 0.0) && dot(a,b) < EPS) return 1;\n  }\n  return in ? 2 : 0;\n}\n \n \nint n,m;\nvector<P> v,w;\n \nbool solve(){\n  if(n == 1){\n    if(m == 1) return true;\n    else if(m == 2) return !isIntersectSP(L(w[0],w[1]),v[0]);\n    else {\n      w = convex_hull(w);\n      return contains(w, v[0]) == 0;\n    }   \n  } else if(n == 2){\n    if(m == 2) return !isIntersectSS(L(v[0],v[1]),L(w[0],w[1]));\n    else {\n      w = convex_hull(w);\n      if(contains(w,v[0]) != 0 || contains(w,v[1]) != 0) return false;\n      m = w.size();\n      for(int i=0;i<w.size();i++) if(isIntersectSS(L(v[0],v[1]),L(w[i],w[(i+1)%m]))) return false;\n      return true;\n    }\n  } else {\n    vector<P> v2 = convex_hull(v);\n    vector<P> w2 = convex_hull(w);\n     \n    for(int i=0;i<n;i++) if(contains(w2,v[i]) != 0) return false;\n    for(int i=0;i<m;i++) if(contains(v2,w[i]) != 0) return false;\n    for(int i=0;i<v2.size();i++){\n      for(int j=0;j<w2.size();j++){\n    if(isIntersectSS(L(v2[i],v2[(i+1)%v2.size()]), L(w2[j],w2[(j+1)%w2.size()]))) return false;\n      }\n    }\n    return true;\n  }\n}\n \nint main(){\n  while(cin >> n >> m && (n|m)){\n    v.clear();\n    w.clear();\n \n    for(int i=0;i<n;i++){\n      double x,y;\n      cin >> x >> y;\n      if(n > m) w.push_back(P(x,y));\n      else v.push_back(P(x,y));\n    }\n    for(int i=0;i<m;i++){\n      double x,y;\n      cin >> x >> y;\n      if(n > m) v.push_back(P(x,y));\n      else w.push_back(P(x,y));\n    }\n \n    n = v.size();\n    m = w.size();\n    assert(n <= m);\n \n    cout << (solve() ? \"YES\" : \"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<string>\n#define MAX_N 200\nusing namespace std;\nconst double eps = 1e-10;\nstruct P{\n    double x,y;\n    P(){}\n    P(double x,double y):x(x),y(y){}\n    bool operator<(const P &p)const{\n        if(fabs(x-p.x)<eps)return y<p.y;\n        return x<p.x;\n    }\n    P operator-(const P &p)const{\n        return P(x-p.x,y-p.y);\n    }\n}A[MAX_N],B[MAX_N];\nint N,M;\nstruct line{\n    double a,b,c;\n    line(){}\n    line(double a,double b,double c):a(a),b(b),c(c){}\n    void init(P p,P q)\n    {\n        if(fabs(p.x-q.x)<eps){\n            a=1.0,b=0;\n            c=p.x;\n        }\n        else if(fabs(p.y-q.y)<eps){\n            a=0;\n            b=1.0;\n            c=p.y;\n        }\n        else{\n            a=1.0;\n            b=(p.x-q.x)/(q.y-p.y);\n            c=a*p.x+b*p.y;\n        }\n    }\n};\nint dcmp(double x)\n{\n    if(fabs(x)<eps)return 0;\n    if(x<-eps)return -1;\n    return 1;\n}\ndouble cross(P p0, P p1, P p2)\n{\n    return (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y);\n}\nvector<P> convex_hull(P *ps,int n)\n{\n    vector<P> qs(2*n);\n    sort(ps,ps+n);\n    int k=0;\n    for(int i=0;i<n;i++){\n        while(k>1&&dcmp(cross(qs[k-2],qs[k-1],ps[i]))<=0)k--;\n        qs[k++]=ps[i];\n    }\n    int t=k;\n    for(int i=n-2;i>=0;i--){\n        while(k>t&&dcmp(cross(qs[k-2],qs[k-1],ps[i]))<=0)k--;\n        qs[k++]=ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\nint getequal(line p,line q)\n{\n    if(fabs(p.a)<eps&&fabs(q.a)<eps){\n        if(fabs(p.c/p.b-q.c/q.b)<eps)return 1;\n        else return -1;\n    }\n    else if(fabs(p.a)>eps&&fabs(q.a)>eps&&fabs(p.b/p.a-q.b/q.a)<eps){\n        if(fabs(p.c/p.a-q.c/q.a)<eps)return 1;\n        else return -1;\n    }\n    else return 0;\n}\nP getpoint(line p,line q)\n{\n    P v;\n    if(fabs(p.a)<eps){\n        v.y=p.c/p.b;\n        v.x=(q.c-q.b*v.y)/q.a;\n    }\n    else if(fabs(p.b)<eps){\n        v.x=p.c/p.a;\n        v.y=(q.c-q.a*v.x)/q.b;\n    }\n    else if(fabs(q.a)<eps){\n        v.y=q.c/q.b;\n        v.x=(p.c-p.b*v.y)/p.a;\n    }\n    else if(fabs(q.b)<eps){\n        v.x=q.c/q.a;\n        v.y=(p.c-p.a*v.x)/p.b;\n    }\n    else{\n        p.b*=q.a/p.a;\n        p.c*=q.a/p.a;\n        v.y=(p.c-q.c)/(p.b-q.b);\n        v.x=(p.c-p.b*v.y)/p.a;\n    }\n    return v;\n}\nbool include(P a,P b,P c)\n{\n    double xr=max(b.x,c.x);\n    double xl=min(b.x,c.x);\n    double yr=max(b.y,c.y);\n    double yl=min(b.y,c.y);\n    if(xl<a.x+eps&&a.x<xr+eps&&yl<a.y+eps&&a.y<yr+eps)return true;\n    return false;\n}\nbool Compl_inside_convex(const P& p,vector<P>con)\n{\n    int n=con.size();\n    if(n<3) return false;\n    if(cross(con[0],p,con[1])>-eps) return false;\n    if(cross(con[0],p,con[n-1])<eps) return false;\n    int i=2,j=n-1;\n    int line=-1;\n    while(i<=j)\n    {\n        int mid=(i+j)>>1;\n        if(cross(con[0],p,con[mid])>-eps)\n        {\n            line=mid;\n            j=mid-1;\n        }\n        else i=mid+1;\n    }\n    return cross(con[line-1],p,con[line])<-eps;\n}\nint main()\n{\n    while(scanf(\"%d%d\",&N,&M)!=EOF){\n        if(!N&&!M)break;\n        for(int i=0;i<N;i++){\n            scanf(\"%lf%lf\",&A[i].x,&A[i].y);\n        }\n        for(int i=0;i<M;i++){\n            scanf(\"%lf%lf\",&B[i].x,&B[i].y);\n        }\n        if(N==1&&M==1||!N||!M){\n            printf(\"YES\\n\");\n            continue;\n        }\n        vector<P> qs1,qs2;\n        if(N<3){\n            for(int i=0;i<N;i++)qs1.push_back(A[i]);\n        }\n        else\n        qs1=convex_hull(A,N);\n        if(M<3){\n            for(int i=0;i<M;i++)qs2.push_back(B[i]);\n        }\n        else qs2=convex_hull(B,M);\n    /*    for(int i=0;i<qs1.size();i++){\n            printf(\"(%lf,%lf)\\n\",qs1[i].x,qs1[i].y);\n        }\n        for(int i=0;i<qs2.size();i++){\n            printf(\"(%lf,%lf)\\n\",qs2[i].x,qs2[i].y);\n        }*/\n        bool flag=false;\n        if((qs1.size()==1&&qs2.size()==2)){\n            flag=include(qs1[0],qs2[0],qs2[1]);\n        }\n        else if((qs1.size()==2&&qs2.size()==1)){\n            flag=include(qs2[0],qs1[0],qs1[2]);\n        }\n        else{\n            flag=false;\n            if(qs1.size()>=2&&qs2.size()>=2)\n            for(int i=0;i<qs1.size()&&!flag;i++){\n                for(int j=0;j<qs2.size()&&!flag;j++){\n                    int ni=i+1,nj=j+1;\n                    if(i==qs1.size()-1)ni=0;\n                    if(j==qs2.size()-1)nj=0;\n                    line p,q;\n                    p.init(qs1[i],qs1[ni]);\n                    q.init(qs2[j],qs2[nj]);\n                    int update=getequal(p,q);\n                    if(update==1){\n                        if(include(qs2[j],qs1[i],qs1[ni])||include(qs2[nj],qs1[i],qs1[ni]))flag=true;\n                    }\n                    else if(update==-1){\n                        P v=getpoint(p,q);\n                     //   printf(\"(%.f,%.f)-(%.f,%.f):(%.f,%.f):\",qs1[i].x,qs1[i].y,qs2[j].x,qs2[j].y,v.x,v.y);\n                        if(include(v,qs1[i],qs1[ni])&&include(v,qs2[j],qs2[nj]))flag=true;\n                    }\n\n                 //   printf(\"%d\\n\",flag);\n               /*     if(flag){\n                        printf(\"(%.f,%.f)-(%.f,%.f):\\n\",qs1[i].x,qs1[i].y,qs1[ni].x,qs1[ni].y);\n                        printf(\"%.f %.f %.f\\n\",p.a,p.b,p.c);\n                        printf(\"(%.f,%.f)-(%.f,%.f):\\n\",qs2[j].x,qs2[j].y,qs2[nj].x,qs2[nj].y);\n                        printf(\"%.f %.f %.f\\n\",q.a,q.b,q.c);\n                    }*/\n                }\n            }\n            if(!flag){\n                if(qs2.size()>=3)for(int i=0;i<qs1.size()&&!flag;i++)flag=Compl_inside_convex(qs1[i],qs2);\n                if(qs1.size()>=3)for(int j=0;j<qs2.size()&&!flag;j++)flag=Compl_inside_convex(qs2[j],qs1);\n            }\n        }\n        if(flag){\n            printf(\"NO\\n\");\n        }\n        else printf(\"YES\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\ntypedef complex<double> pt;\ntypedef pair<pt,pt> L;\ntypedef vector<P> poly;\nconst double EPS = 1e-9;\n#define x real()\n#define y imag()\nbool eq(double a,double b){\n  return (-EPS < a-b && a-b < EPS);\n}\ndouble dot(pt a,pt b){\n\treturn (conj(a)*b).x;\n}\ndouble cross(pt a,pt b){\n\treturn (conj(a)*b).y;\n}\nint ccw(pt a,pt b,pt c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > EPS) return 1; // counter clockwise\n\tif(cross(b,c) < -EPS) return -1; // clockwise\n\tif(dot(b,c) < -EPS) return 2; //c-a-b\n\tif(norm(b) < norm(c)) return -2; //a-b-c\n\treturn 0; //a-c-b\n}\nbool cmp(const pt& a,const pt& b){\n\tif(-EPS < a.x-b.x && a.x-b.x < EPS) return a.y < b.y;\n\telse return a.x < b.x;\n}\nbool on_segment(pair<pt,pt> a,pt p){\n  return eq(abs(a.first-a.second)-abs(a.first-p)-abs(a.second-p),0);\n}\nvector<pt>convex_hull(vector<pt>ps){\n\tsort(ps.begin(),ps.end(),cmp);\n\tint k=0,n = ps.size();\n\tvector<pt>qs(n*2);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\twhile(k>1 && ccw(qs[k-2],qs[k-1],ps[i]) == -1) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tfor(int i=n-2,t=k;i>=0;i--)\n\t{\n\t\twhile(k>t && ccw(qs[k-2],qs[k-1],ps[i]) == -1) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\nbool contain_point(vector<pt>ps,pt p){\n\tdouble sum = 0;\n\t//arg no sum wo keisan\n\tfor(int i=0;i<ps.size();i++){\n\t\tif(on_segment(mp(ps[i],ps[ (i+1)%ps.size() ]),p)) return 1;\n\t\tsum += arg( (ps[ (i+1)%ps.size() ]-p) / (ps[i]-p) );\n\t}\n\treturn (abs(sum) > 1);\n}\nbool intersect(pt a,pt b,pt c,pt d){\n\treturn (ccw(a,b,c)*ccw(a,b,d) <= 0 && ccw(c,d,a)*ccw(c,d,b) <= 0);\n}\nint n,m;\nint main(){\n\twhile(1){\n\t\tcin >> n >> m; if(!n) return 0;\n\t\tvector<pt>A,B;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble xx,yy; scanf(\"%lf%lf\",&xx,&yy);\n\t\t\tA.pb(pt(xx,yy));\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tdouble xx,yy; scanf(\"%lf%lf\",&xx,&yy);\n\t\t\tB.pb(pt(xx,yy));\n\t\t}\n\t\tif(A.size() >= 3) A = convex_hull(A);\n\t\tif(B.size() >= 3) B = convex_hull(B);\n\t\tbool ok = 1;\n\t\trep(i,A.size()){\n\t\t\tif(contain_point(B,A[i])) ok = 0;\n\t\t}\n\t\trep(i,B.size()){\n\t\t\tif(contain_point(A,B[i])) ok = 0;\n\t\t}\n\t\tif(A.size()>=2 && B.size()>=2){\n    \t\trep(i,A.size()){\n    \t\t    rep(j,B.size()){\n    \t\t        if(intersect(A[i],A[(i+1)%A.size()],B[j],B[(j+1)%B.size()])) ok = 0;\n    \t\t    }\n    \t\t}\n\t\t}\n\t\tputs(ok?\"YES\":\"NO\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <double,double> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nbool McCullochPitts(const vector<P>& white,const vector<P>& black){\n  vector<double> weight(3);\n  double alpha = 5.0;\n\n  bool res = false;\n  weight[0] = 0.0;\n  weight[1] = 0.0;\n  weight[2] = 0.0;\n\n  for(int round = 0; round < 3000000; round++){\n    bool isok = true;\n    for(int i = 0; i < white.size(); i++){\n      double o = (weight[0] + weight[1] * white[i].first + weight[2] * white[i].second);\n      //white == 0\n      //black == 1\n      if(o > 0){\n        weight[0] -= alpha;\n        weight[1] -= alpha * white[i].first;\n        weight[2] -= alpha * white[i].second;\n        isok = false;\n      }\n    }\n    for(int i = 0;i < black.size(); i++){\n      double o = (weight[0] + weight[1] * black[i].first + weight[2] * black[i].second);\n      //white == 0\n      //black == 1\n      if(o <= 0){\n        weight[0] += alpha;\n        weight[1] += alpha * black[i].first;\n        weight[2] += alpha * black[i].second;\n        isok = false;\n      }\n    }\n    if(isok){\n      res = true;\n      break;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n,m;\n  while(~scanf(\"%d %d\",&n,&m)){\n    if(n == 0 && m == 0) break;\n\n    vector<P> white;\n    for(int i = 0; i < n; i++){\n      double x,y;\n      scanf(\"%lf %lf\",&x,&y);\n      white.push_back(P(x,y));\n    }\n    vector<P> black;\n    for(int i = 0; i < m; i++){\n      double x,y;\n      scanf(\"%lf %lf\",&x,&y);\n      black.push_back(P(x,y));\n    }\n\n    printf(\"%s\\n\",McCullochPitts(white,black) ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<complex>\n#include<algorithm>\n\n#define pb       push_back\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef vector<Point>   Polygon;\n\nconst double EPS=1e-9;\n\nclass Line:public vector<Point>{\npublic:\n\tLine(){}\n\tLine(const Point &a,const Point &b){ pb(a), pb(b); }\n};\n\nclass Segment:public Line{\npublic:\n\tSegment(){}\n\tSegment(const Point &a,const Point &b):Line(a,b){}\n};\n\nnamespace std{\n\tbool operator <(const Point &a,const Point &b){\n\t\treturn (real(a)==real(b))?(imag(a)<imag(b)):(real(a)<real(b));\n\t}\n}\n\ndouble dot(const Point &a,const Point &b){\n\treturn real(a)*real(b)+imag(a)*imag(b);\n}\n\ndouble cross(const Point &a,const Point &b){\n\treturn real(a)*imag(b)-imag(a)*real(b);\n}\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const Point &a,Point b,Point c){\n\tb-=a,c-=a;\n\tdouble rotdir=cross(b,c);\n\tif(rotdir>EPS)  return CCW;\n\tif(rotdir<-EPS) return CW;\n\treturn ON;\n}\n\nPolygon ConvexHull(vector<Point> ps){\n\tint n=ps.size();\n\tsort(ps.begin(),ps.end());\n\n\tvector<Point> ch_u(n);\n\tint n_u=0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tch_u[n_u++]=ps[i];\n\t\twhile(n_u>=3 && ccw(ch_u[n_u-3],ch_u[n_u-2],ch_u[n_u-1])!=CCW){\n\t\t\tch_u[n_u-2]=ch_u[n_u-1];\n\t\t\tn_u--;\n\t\t}\n\t}\n\n\tvector<Point> ch_l(n);\n\tint n_l=0;\n\tfor(int i=0;i<n;i++){\n\t\tch_l[n_l++]=ps[i];\n\t\twhile(n_l>=3 && ccw(ch_l[n_l-3],ch_l[n_l-2],ch_l[n_l-1])!=CCW){\n\t\t\tch_l[n_l-2]=ch_l[n_l-1];\n\t\t\tn_l--;\n\t\t}\n\t}\n\n\tPolygon ch;\n\trep(i,n_u-1) ch.pb(ch_u[i]);\n\trep(i,n_l-1) ch.pb(ch_l[i]);\n\treturn ch;\n}\n\ninline void calc_abc(const Line &l,double &a,double &b,double &c){\n\ta=imag(l[0])-imag(l[1]);\n\tb=real(l[1])-real(l[0]);\n\tc=cross(l[0],l[1]);\n}\n\nbool cover(const Polygon &g,const Point &p){\n\tint n=g.size();\n\tbool in=false;\n\trep(i,n){\n\t\tPoint v1=g[i]-p,v2=g[(i+1)%n]-p;\n\t\tif(imag(v1)>imag(v2)) swap(v1,v2);\n\t\tif(imag(v1)<EPS && EPS<imag(v2) && cross(v1,v2)>EPS) in=!in;\n\t\tif(abs(cross(v1,v2))<EPS && dot(v1,v2)<EPS) return true;\n\t}\n\treturn in;\n}\n\nbool cover(const Polygon &g1,const Polygon &g2){\n\trep(i,g2.size()) if(!cover(g1,g2[i])) return false;\n\treturn true;\n}\n\nbool intersect(const Segment &s,const Segment &t){\n\tif(abs(cross(s[1]-s[0],t[1]-t[0]))<EPS && abs(cross(s[1]-s[0],t[0]-s[0]))<EPS){\n\t\treturn cover(s,t[0]) || cover(s,t[1]) || cover(t,s[0]) || cover(t,s[1]);\n\t}\n\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0\n\t\t&& ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\n\nbool intersect(const Polygon &g1,const Polygon &g2){\n\tint n1=g1.size(),n2=g2.size();\n\trep(i,n1) rep(j,n2) {\n\t\tif(intersect(Segment(g1[i],g1[(i+1)%n1]),Segment(g2[j],g2[(j+1)%n2]))) return true;\n\t}\n\treturn cover(g1,g2) || cover(g2,g1);\n}\n\nint main(){\n\tfor(int nb,nw;scanf(\"%d%d\",&nb,&nw),nb;){\n\t\tvector<Point> b(nb),w(nw);\n\t\trep(i,nb){ int x,y; scanf(\"%d%d\",&x,&y); b[i]=Point(x,y); }\n\t\trep(i,nw){ int x,y; scanf(\"%d%d\",&x,&y); w[i]=Point(x,y); }\n\n\t\tPolygon ch_b,ch_w;\n\t\tch_b=(nb>1)?ConvexHull(b):b;\n\t\tch_w=(nw>1)?ConvexHull(w):w;\n\t\tputs(intersect(ch_b,ch_w)?\"NO\":\"YES\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <vector>\n#include <string>\n#include <stack>\n#include <bitset>\n#define INF 1000000005\n#define eps 1e-7\n#define PI acos(-1.0)\n#define LL long long\n\nusing namespace std;\n\nconst int maxn=105;\n\nint bx[maxn],by[maxn],hx[maxn],hy[maxn],m,n,tag;\n\nint maxhx,maxbx,minhx,minbx,maxhy,maxby,minhy,minby;\n\nvoid Solve(int sx,int sy,int ex,int ey)\n{\n    int A=ey-sy,B=sx-ex,C=ex*sy-sx*ey;\n    int bl=0,br=0,bm=0,hl=0,hr=0,hm=0;\n    for (int i=1;i<=n;i++)\n    {\n        long long D=A*1LL*bx[i]+B*1LL*by[i]+C*1LL;\n        if (D<0) bl++;\n        if (D==0) bm++;\n        if (D>0) br++;\n    }\n    for (int i=1;i<=m;i++)\n    {\n        long long D=A*1LL*hx[i]+B*1LL*hy[i]+C*1LL;\n        if (D<0) hl++;\n        if (D==0) hm++;\n        if (D>0) hr++;\n    }\n    if (bm!=0&&hm!=0) return;\n    if (bl==0&&hr==0) tag=1;\n    if (br==0&&hl==0) tag=1;\n    return;\n}\n\nint main()\n{\n    while(scanf(\"%d %d\",&n,&m)==2)\n    {\n        if (n==0&&m==0) break;\n        tag=0;\n        minhx=minhy=minbx=minby=INF;\n        maxhx=maxhy=maxbx=maxby=-INF;\n        for (int i=1;i<=n;i++)\n            {\n                scanf(\"%d %d\",&bx[i],&by[i]);\n                minby=min(minby,by[i]);\n                maxby=max(maxby,by[i]);\n                minbx=min(minbx,bx[i]);\n                maxbx=max(maxbx,bx[i]);\n            }\n        for (int i=1;i<=m;i++)\n            {\n                scanf(\"%d %d\",&hx[i],&hy[i]);\n                minhy=min(minhy,hy[i]);\n                maxhy=max(maxhy,hy[i]);\n                minhx=min(maxhx,hx[i]);\n                maxhx=max(maxhx,hx[i]);\n            }\n        if (maxhx<minbx||maxbx<minhx||maxhy<minby||maxby<minhy) tag=1;\n        printf(\"%d %d\\n\",maxhx,minbx);\n        if (n<=1&&m<=1) tag=1;\n        else if (!tag)\n        {\n            if (n>=2)\n            {\n                for (int i=1;i<n;i++)\n                {\n                    for (int j=i+1;j<=n;j++)\n                    {\n                        Solve(bx[i],by[i],bx[j],by[j]);\n                        if (tag) break;\n                    }\n                    if (tag) break;\n                }\n            }\n            if (m>=2)\n            {\n                for (int i=1;i<m;i++)\n                {\n                    for (int j=i+1;j<=m;j++)\n                    {\n                        Solve(hx[i],hy[i],hx[j],hy[j]);\n                        if (tag) break;\n                    }\n                    if (tag) break;\n                }\n            }\n        }\n        if (tag) printf(\"YES\\n\"); else printf(\"NO\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\n#define EPS 1e-4\n\ntypedef complex<double> point;\ntypedef const point &refpoint;\n\n\ndouble dot(refpoint a, refpoint b){\n\treturn real(a) * real(b) + imag(a) * imag(b);\n}\n\ndouble cross(refpoint a, refpoint b){\n\treturn real(a) * imag(b) - imag(a) * real(b);\n}\n\ndouble distance_l_p(refpoint a, refpoint b, refpoint c){\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\ndouble distance_ls_p(refpoint a, refpoint b, refpoint c){\n\tif( dot(b - a, c - a) <= 0.0 ) return abs(c - a);\n\tif( dot(a - b, c - b) <= 0.0 ) return abs(c - b);\n\treturn distance_l_p(a, b, c);\n}\n\nbool contains(const vector<point> &plg, refpoint pts){\n\tint cnt = 0;\n\tdouble y = imag(pts);\n\n\tfor(int i = 0; i < plg.size(); ++i){\n\t\tint j = (i + 1 == plg.size() ? 0: i + 1);\n\n\t\tdouble dyi = imag(plg[i]) - y;\n\t\tdouble dyj = y - imag(plg[j]);\n\t\tdouble tx = (dyi * real(plg[j]) + dyj * real(plg[i])) / (dyi + dyj);\n\n\t\tif(imag(plg[i]) >= y && imag(plg[j]) < y){\n\t\t\tif( tx < real(pts) ) ++cnt;\n\t\t}\n\t\telse if(imag(plg[i]) < y && imag(plg[j]) >= y){\n\t\t\tif( tx < real(pts) ) --cnt;\n\t\t}\n\t}\n\t\n\treturn (cnt % 2 != 0);\n}\n\nbool intersected(refpoint pa1, refpoint pa2, refpoint pb1, refpoint pb2){\n\tdouble a = cross(pa2 - pa1, pb1 - pa1);\n\tdouble b = cross(pa2 - pa1, pb2 - pa1);\n\tdouble c = cross(pb2 - pb1, pa1 - pb1);\n\tdouble d = cross(pb2 - pb1, pa2 - pb1);\n\n\tif( (a < -EPS && b > EPS) || (b < -EPS && a > EPS) ){\n\t\tif( (c < -EPS && d > EPS) || (d < -EPS && c > EPS) ){\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nbool contact(const vector<point> &plg1, const vector<point> &plg2){\n\tif( contains(plg1, plg2[0]) || contains(plg2, plg1[0]) ){\n\t\treturn true;\n\t}\n\n\tint n = plg1.size();\n\tint m = plg2.size();\n\tfor(int i = 0; i < n; ++i){\n\t\tfor(int j = 0; j < m; ++j){\n\t\t\tif( intersected(plg1[i], plg1[(i+1)%n], plg2[j], plg2[(j+1)%m]) ){\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif( distance_ls_p(plg1[i], plg1[(i+1)%n], plg2[j]) < EPS ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif( distance_ls_p(plg2[j], plg2[(j+1)%n], plg1[i]) < EPS ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n\nvector<point> convex(const vector<point> plg){\n\tif( plg.size() <= 3 ){\n\t\treturn plg;\n\t}\n\n\tvector<point> ret;\n\n\tfor(int i = 0; i < plg.size(); ++i){\n\t\tint k = ret.size();\n\n\t\tif( k < 2 || cross( ret[k-1] - ret[k-2], plg[i] - ret[k-2] ) > 0.0 ){\n\t\t\tret.push_back( plg[i] );\n\t\t}\n\t\telse{\n\t\t\tret.back() = plg[i];\n\t\t}\n\t}\n\n\tint t = ret.size() + 1;\n\tfor(int i = plg.size() - 2; i >= 0; --i){\n\t\tint k = ret.size();\n\n\t\tif( k < t || cross( ret[k-1] - ret[k-2], plg[i] - ret[k-2] ) > 0.0 ){\n\t\t\tret.push_back( plg[i] );\n\t\t}\n\t\telse{\n\t\t\tret.back() = plg[i];\n\t\t}\n\t}\n\tret.pop_back();\n\t\n\treturn ret;\n}\n\n\nint main(){\n\tint n, m;\n\tdouble x, y;\n\t\n\twhile( scanf(\"%d%d\", &n, &m), n != 0 ){\n\t\tvector<point> black, white;\n\t\tblack.reserve(n);\n\t\twhite.reserve(m);\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\tblack.push_back( point(x, y) );\n\t\t}\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\twhite.push_back( point(x, y) );\n\t\t}\n\n\n\t\tblack = convex(black);\n\t\twhite = convex(white);\n\n\t\tif( contact(black, white) ){\n\t\t\tputs(\"NO\");\n\t\t}\n\t\telse{\n\t\t\tputs(\"YES\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) { return abs(b - a) < EPS; }\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\nenum\n{\n  OUT, ON, IN\n};\nnamespace Geometory\n{\n  struct Point\n  {\n    double x, y;\n\n    Point() {};\n\n    Point(double x, double y) : x(x), y(y) {};\n\n    Point operator+(const Point &b) const { return Point(x + b.x, y + b.y); }\n\n    Point operator-(const Point &b) const { return Point(x - b.x, y - b.y); }\n\n    Point operator*(const double b) const { return Point(x * b, y * b); }\n\n    Point operator*(const Point &b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n\n    Point operator/(const double b) const { return Point(x / b, y / b); }\n\n    bool operator<(const Point &b) const { return x != b.x ? x < b.x : y < b.y; }\n\n    bool operator==(const Point &b) const { return eq(x, b.x) && eq(y, b.y); }\n\n    double norm() { return x * x + y * y; }\n\n    double arg() { return atan2(x, y); }\n\n    double abs() { return sqrt(norm()); }\n\n    Point rotate(double theta) { return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n\n    Point rotate90() { return Point(-y, x); }\n\n    friend ostream &operator<<(ostream &os, Point &p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Point &a) { return is >> a.x >> a.y; }\n  };\n\n  struct Line\n  {\n    Point a, b;\n\n    Line() {};\n\n    Line(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Line &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Line &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  struct Segment\n  {\n    Point a, b;\n\n    Segment() {};\n\n    Segment(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Segment &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Segment &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  struct Circle\n  {\n    Point p;\n    double r;\n\n    Circle() {};\n\n    Circle(Point p, double r) : p(p), r(r) {};\n  };\n\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef vector< Circle > Circles;\n  typedef pair< Point, Point > PointPoint;\n\n  double cross(const Point &a, const Point &b)\n  {\n    return a.x * b.y - a.y * b.x;\n  }\n\n  double dot(const Point &a, const Point &b)\n  {\n    return a.x * b.x + a.y * b.y;\n  }\n\n  int ccw(const Point &a, Point b, Point c)\n  {\n    b = b - a, c = c - a;\n    if(cross(b, c) > EPS) return +1;  // a ??? b ??§ ???????¨??????????????????? c\n    if(cross(b, c) < -EPS) return -1; // a ??? b ??§ ????¨??????????????????? c\n    if(dot(b, c) < 0) return +2;  // c -- a -- b??§?????´??????\n    if(b.norm() < c.norm()) return -2; // a -- b -- c??§?????´??????\n    return 0;  // a -- c -- b??§?????´??????\n  }\n\n  Point Projection(const Line &l, const Point &p)\n  {\n    double t = dot(p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n\n  Point Projection(const Segment &l, const Point &p)\n  {\n    double t = dot(p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n\n  Point Reflection(const Line &l, const Point &p)\n  {\n    return p + (Projection(l, p) - p) * 2.0;\n  }\n\n  double Distance(const Line &l, const Point &p)\n  { //OK\n    return (p - Projection(l, p)).abs();\n  }\n\n  bool Intersect(const Line &l, const Line &m)\n  {\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n  }\n\n  bool Intersect(const Line &l, const Segment &s)\n  {\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n  }\n\n  bool Intersect(const Line &l, const Point &p)\n  {\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n\n  bool Intersect(const Segment &s, const Segment &t)\n  {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n\n  bool Intersect(const Segment &s, const Point &p)\n  {\n    return ccw(s.a, s.b, p) == 0;\n  }\n\n  bool Intersect(const Circle &c, const Line &l)\n  {\n    return Distance(l, c.p) <= c.r + EPS;\n  }\n\n  bool Intersect(const Circle &c, const Point &p)\n  {\n    return abs((p - c.p).abs() - c.r) < EPS;\n  }\n\n  int Intersect(const Circle &c, const Segment &l)\n  {\n    if((Projection(l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;\n    const double d1 = (c.p - l.a).abs(), d2 = (c.p - l.b).abs();\n    if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n    const Point h = Projection(l, c.p);\n    if(dot(l.a - h, l.b - h) < 0) return 2;\n    return 0;\n  }\n\n  bool Intersect(const Circle &a, const Circle &b)\n  {\n    return ((a.p - b.p).norm() - (a.r + b.r) * (a.r + b.r) < EPS) &&\n           ((a.p - b.p).norm() - (a.r - b.r) * (a.r - b.r) > -EPS);\n  }\n\n  double Distance(const Segment &s, const Point &p)\n  {\n    Point r = Projection(s, p);\n    if(Intersect(s, r)) return (r - p).abs();\n    return min((s.a - p).abs(), (s.b - p).abs());\n  }\n\n  double Distance(const Segment &a, const Segment &b)\n  {\n    if(Intersect(a, b)) return 0;\n    return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n  }\n\n  double Distance(const Line &l, const Line &m)\n  {\n    return Intersect(l, m) ? 0 : Distance(l, m.a);\n  }\n\n  double Distance(const Line &l, const Segment &s)\n  { //OK\n    if(Intersect(l, s)) return 0;\n    return min(Distance(l, s.a), Distance(l, s.b));\n  }\n\n  double Distance(const Point &a, const Point &b)\n  { //OK\n    return (a - b).abs();\n  }\n\n  Point Crosspoint(const Segment &l, const Segment &m)\n  { //OK\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if(abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n\n  PointPoint Crosspoint(const Circle &c, const Line l)\n  {\n    Point hp = Projection(l, c.p), h = hp - c.p;\n    const double d2 = h.norm();\n    Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / (l.b - l.a).abs();\n    return PointPoint(hp - v, hp + v);\n  }\n\n  PointPoint Crosspoint(const Circle &c, const Segment &l)\n  {\n    Line aa = Line(l.a, l.b);\n    if(Intersect(c, l) == 2) return Crosspoint(c, aa);\n    PointPoint ret = Crosspoint(c, aa);\n    if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n  }\n\n  PointPoint Crosspoint(const Circle &c1, const Circle &c2)\n  { //OK\n    double d = (c1.p - c2.p).abs();\n    double s = (c1.r + c2.r + d) / 2;\n    double S = sqrt(s * (s - c1.r) * (s - c2.r) * (s - d));\n    double h = 2 * S / d;\n    Point v = (c2.p - c1.p) / (c2.p - c1.p).abs();\n    double m = sqrt(c1.r * c1.r - h * h);\n    return PointPoint(c1.p + v * m + Point(0, 1) * h * v, c1.p + v * m - Point(0, 1) * h * v);\n  }\n\n  bool parallel(const Line &a, const Line &b)\n  {\n    return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n  }\n\n  bool orthogonal(const Line &a, const Line &b)\n  {\n    return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n  }\n\n  int Contains(const Polygon &Q, const Point &p)\n  {\n    bool in = false;\n    for(int i = 0; i < Q.size(); i++) {\n      Point a = curr(Q, i) - p, b = next(Q, i) - p;\n      if(a.y > b.y) swap(a, b);\n      if(a.y <= 0 && 0 < b.y && cross(a, b) < 0) in = !in;\n      if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n  }\n\n  bool Contains(const Circle &c, const Point &p)\n  {\n    return (c.p - p).abs() < c.r + EPS;\n  }\n\n  double Area2(const Polygon &p)\n  { //OK\n    double A = 0;\n    for(int i = 0; i < p.size(); ++i) {\n      A += cross(curr(p, i), next(p, i));\n    }\n    return A;\n  }\n\n  bool IsConvex(const Polygon &p)\n  {\n    for(int i = 0; i < p.size(); i++) {\n      if(ccw(prev(p, i), curr(p, i), next(p, i)) == -1) return false;\n    }\n    return true;\n  }\n\n  Polygon Convex_Hull(Polygon &p)\n  {\n    int n = p.size(), k = 0;\n    if(n >= 3) {\n      sort(p.begin(), p.end());\n      vector< Point > ch(2 * n);\n      for(int i = 0; i < n; ch[k++] = p[i++]) {\n        while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n        while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      ch.resize(k - 1);\n      return ch;\n    } else {\n      return p;\n    }\n  }\n\n  double Convex_Diameter(Polygon &p)\n  {\n    int n = p.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++) {\n      if(p[i].y > p[is].y) is = i;\n      if(p[i].y < p[js].y) js = i;\n    }\n    double maxdis = (p[is] - p[js]).norm();\n\n    int maxi, maxj, i, j;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n      if(cross(next(p, i) - curr(p, i), next(p, j) - curr(p, j)) >= 0) {\n        j = (j + 1) % n;\n      } else {\n        i = (i + 1) % n;\n      }\n      if((p[i] - p[j]).norm() > maxdis) {\n        maxdis = (p[i] - p[j]).norm();\n        maxi = i;\n        maxj = j;\n      }\n    } while(i != is || j != js);\n    return maxdis;\n  }\n};\n\nusing namespace Geometory;\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nint main()\n{\n  int N, M;\n\n  while(cin >> N >> M, N) {\n    Polygon a(N), b(M);\n    rep(i, N) cin >> a[i];\n    rep(i, M) cin >> b[i];\n    a = Convex_Hull(a);\n    b = Convex_Hull(b);\n    bool isok = true;\n    for(auto &p : a) isok &= !Contains(b, p);\n    for(auto &p : b) isok &= !Contains(a, p);\n    for(int i = 0; i < a.size(); i++) {\n      for(int j = 0; j < b.size(); j++) {\n        Segment x(curr(a, i), next(a, i));\n        Segment y(curr(b, i), next(b, i));\n        isok &= !Intersect(x, y);\n      }\n    }\n    if(isok) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n#include <assert.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <double,double> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\ntypedef complex<double> Point;\n\nnamespace std {\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const Point& a, const Point& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const Point& a, const Point& b) {\n  return real(conj(a)*b);\n}\n\nstruct Line : public vector<Point> {\n  Line(const Point &a, const Point &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool is_inner(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  return (dot(b,c) <= 0);\n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nbool is_projection_on_line(const Line &l, const Point &p) {\n  Point pj = projection(l,p);\n  return is_inner(pj,l[0],l[1]);\n}\n\ndouble distanceLP(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\nbool is_equal(const Point &l,const Point &m){\n  return ((abs(real(l) - real(m)) < EPS) && (abs(imag(l) - imag(m) < EPS)));\n}\n\nbool cmp_x(const Point& p, const Point& q){\n  if(p.real() != q.real()) return p.real() < q.real();\n  return p.imag() < q.imag();\n}\n\nvector<Point> compute_convex_hull(vector<Point> ps){\n  sort(ps.begin(), ps.end(), cmp_x);\n  int k = 0;\n  vector<Point> qs(ps.size() * 2);\n  for(int i=0; i < ps.size(); i++){\n    while(k > 1 && cross(qs[k - 1] - qs[k - 2],ps[i] - qs[k - 1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  for(int i = ps.size() - 2,t = k; i >= 0; i--){\n    while(k > t && cross(qs[k - 1] - qs[k - 2],ps[i] - qs[k - 1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nbool is_convex_hull(vector<Point>& ps,const Point& c){\n  for(int i=0;i<ps.size();i++){\n    if(is_equal(ps[i],c)) return true;\n  }\n  return false;\n}\n\nbool is_inner_polygon(const vector<Point>& outer,const vector<Point>& inner){\n\n  Point center;\n  for(int i = 0; i < outer.size(); i++){\n    center += outer[i];\n    for(int j = 0; j < inner.size(); j++){\n      if(ccw(outer[i],outer[(i+1) % outer.size()],inner[j]) == 0){\n        return true;\n      }\n    }\n  }\n  center /= outer.size();\n  for(int i = 0; i < inner.size(); i++){\n    for(int j = 0; j < outer.size(); j++){\n      double a = cross(center - outer[j],inner[i] - center);\n      double b = cross(outer[j] - outer[(j+1) % outer.size()],inner[i] - outer[j]);\n      double c = cross(outer[(j+1) % outer.size()] - center,inner[i] - outer[(j+1) % outer.size()]);\n\n      if((a > 0 && b > 0 && c > 0)\n         || (a < 0 && b < 0 && c < 0)){\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nint main(){\n  int n,m;\n  while(~scanf(\"%d %d\",&n,&m)){\n    if(n == 0 && m == 0) break;\n\n    vector<Point> white;\n    for(int i = 0; i < n; i++){\n      double x,y;\n      scanf(\"%lf %lf\",&x,&y);\n      white.push_back(Point(x,y));\n    }\n    vector<Point> white_convex_hull = compute_convex_hull(white);\n\n    vector<Point> black;\n    for(int i = 0; i < m; i++){\n      double x,y;\n      scanf(\"%lf %lf\",&x,&y);\n      black.push_back(Point(x,y));\n    }\n    vector<Point> black_convex_hull = compute_convex_hull(black);\n\n    bool dividable = true;\n\n    if(black_convex_hull.size() == 1 && white_convex_hull.size() == 2){\n      if(ccw(white_convex_hull[0],white_convex_hull[1],black_convex_hull[0]) == 0){\n        dividable = false;\n      }\n    }\n    else if(black_convex_hull.size() == 2 && white_convex_hull.size() == 1){\n      if(ccw(black_convex_hull[0],black_convex_hull[1],white_convex_hull[0]) == 0){\n        dividable = false;\n      }\n    }\n    else if(black_convex_hull.size() == 2 && white_convex_hull.size() == 2){\n      if(intersectSS(Line(black_convex_hull[0],black_convex_hull[1]),\n                     Line(white_convex_hull[0],white_convex_hull[1]))){\n        dividable = false;\n      }\n    }\n    else {\n      if(black_convex_hull.size() >= 3 && is_inner_polygon(black_convex_hull,white_convex_hull)\n         || white_convex_hull.size() >= 3 && is_inner_polygon(white_convex_hull,black_convex_hull)){\n        dividable = false;\n      }\n    }\n    printf(\"%s\\n\", dividable ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nclass Point{\npublic:\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double xx,double yy){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tPoint operator+(Point p){\n\t\treturn Point(x+p.x,y+p.y);\n\t}\n\tPoint operator-(Point p){\n\t\treturn Point(x-p.x,y-p.y);\n\t}\n\tPoint operator*(double a){\n\t\treturn Point(a*x,a*y);\n\t}\n\tPoint operator/(double a){\n\t\treturn Point(x/a,y/a);\n\t}\n\n\tdouble abs(){\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm(){\n\t\treturn x*x+y*y;\n\t}\n\tbool operator<(const Point &p)const{\n\t\treturn x!=p.x ? x<p.x:y<p.y;\n\t}\n\tbool operator==(const Point &p)const{\n\t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n\t}\n};\n\ntypedef Point Vector;\nstruct Segment{\n\tPoint p1,p2;\n\tSegment(){}\n\tSegment(Point pp1,Point pp2){\n\t\tp1=pp1;\n\t\tp2=pp2;\n\t}\n};\n\ntypedef Segment Line;\n\ndouble norm(Vector v){\n\treturn v.x*v.x+v.y*v.y;\n}\n\ndouble abs(Vector v){\n\treturn sqrt(norm(v));\n}\n\ndouble dot(Vector a,Vector b){\n\treturn a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Vector a,Vector b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n\tVector a=p1-p0;\n\tVector b=p2-p0;\n\tif(cross(a,b)>EPS)return 1;\n\tif(cross(a,b)<-EPS)return -1;\n\tif(dot(a,b)<-EPS)return 2;\n\tif(a.norm()<b.norm())-2;\n\treturn 0;\n}\n\nint n,m;\nPoint p[2][101];\ntypedef pair<Point,int> PP;\n\nbool check(Point p0,Point p1){\n\tint side=0;\n\tvector<PP> vec;\n\tfor(int i=0;i<n;i++){\n\t\tint v=ccw(p0,p1,p[0][i]);\n\t\tif(abs(v)!=1)vec.push_back(PP(p[0][i],0));\n\t\telse{\n\t\t\tif(side!=0 && side!=v)return false;\n\t\t\tside=v;\n\t\t}\n\t}\n\tint side2=0;\n\tfor(int i=0;i<m;i++){\n\t\tint v=ccw(p0,p1,p[1][i]);\n\t\tif(abs(v)!=1)vec.push_back(PP(p[1][i],1));\n\t\telse{\n\t\t\tif(side2!=0 && side2!=v)return false;\n\t\t\tside2=v;\n\t\t}\n\t}\n\tif(side==side2 && side!=0)return false;\n\tsort(vec.begin(),vec.end());\n\tint ch=0;\n\tfor(int i=1;i<vec.size();i++){\n\t\tif(vec[i].second!=vec[i-1].second)ch++;\n\t}\n\treturn ch<=1;\n}\n\nbool solve(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(check(p[0][i],p[1][j]))return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf%lf\",&p[0][i].x,&p[0][i].y);\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%lf%lf\",&p[1][i].x,&p[1][i].y);\n\t\t}\n\t\tif(n==0 && m==0)break;\n\t\tprintf(\"%s\\n\",solve()?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\nusing namespace std;\ntypedef complex<long long> P;\n\ninline P::value_type cross(const P& a, const P& b) { return a.real()*b.imag() - b.real()*a.imag(); }\n\nbool ok(const vector<P>& ps, int N, int i1, int i2)\n{\n  const int NM = ps.size();\n  const int color = i1 < N;\n  int cnt[2][2] = {{0, 0}, {0, 0}};\n  for (int i = 0; i < NM; i++) {\n    const long long c = cross(ps[i2] - ps[i1], ps[i] - ps[i1]);\n    const int col = i < N;\n    if (c == 0) {\n      if (color != col) {\n        return false;\n      }\n    } else {\n      ++cnt[col][c < 0];\n    }\n  }\n  return (cnt[0][0] == 0 && cnt[1][1] == 0) || (cnt[0][1] == 0 && cnt[1][0] == 0);\n}\n\nbool check(const vector<P>& ps, int N)\n{\n  for (int i = 0; i < N; i++) {\n    for (int j = i+1; j < N; j++) {\n      if (ok(ps, N, i, j)) {\n        return true;\n      }\n    }\n  }\n  const int NM = ps.size();\n  for (int i = N; i < NM; i++) {\n    for (int j = i+1; j < NM; j++) {\n      if (ok(ps, N, i, j)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\ninline int cmp(long long x, long long y)\n{\n  if (x == y) {\n    return 0;\n  } else if (x < y) {\n    return -1;\n  } else {\n    return 1;\n  }\n}\n\nbool check_edgecase(const vector<P>& ps, const int N)\n{\n  const int NM = ps.size();\n  const int x = cmp(ps[0].real(), ps[N].real());\n  for (int i = 0; i < N; i++) {\n    for (int j = N; j < NM; j++) {\n      if (x != cmp(ps[i].real(), ps[j].real())) {\n        return false;\n      }\n    }\n  }\n  const int y = cmp(ps[0].imag(), ps[N].imag());\n  for (int i = 0; i < N; i++) {\n    for (int j = N; j < NM; j++) {\n      if (y != cmp(ps[i].imag(), ps[j].imag())) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nint main()\n{\n  int N, M;\n  while (cin >> N >> M && N != 0) {\n    vector<P> ps(N+M);\n    for (int i = 0; i < N+M; i++) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n\n    bool straight = true;\n    if (N+M > 2) {\n      const long long c0 = cross(ps[2]-ps[0], ps[1]-ps[0]);\n      for (int i = 3; i < N+M; i++) {\n        const long long c = cross(ps[i]-ps[0], ps[1]-ps[0]);\n        if (c != c0) {\n          straight = false;\n          break;\n        }\n      }\n    }\n    if (straight) {\n      cout << (check_edgecase(ps, N) ? \"YES\" : \"NO\") << endl;\n    } else {\n      cout << (check(ps, N) ? \"YES\" : \"NO\") << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\n\ntemplate<typename T> T add(T x, T y){ if(abs(x+y) < EPS*(abs(x)+abs(y))) return 0; return x + y; }\ntemplate<typename T> inline bool semieq(T x, T y){ return abs(x - y) < EPS; }\ntemplate<typename T> inline bool semige(T x, T y){ return y - x < -EPS; }\ntemplate<typename T> inline bool semile(T x, T y){ return x - y < -EPS; }\n\n\nstruct Point : public complex<double>\n{\npublic:\n  Point(const double x = 0.0, const double y = 0.0) { this->real(x);  this->imag(y); }\n  Point(const complex<double> w)  { this->real(w.real());  this->imag(w.imag()); }\n  inline double dot(Point p){ return (conj(*this) * p).real(); }  // ??????\n  inline double det(Point p){ return (conj(*this) * p).imag(); }  // ??????\n};\n\nnamespace std\n{\n  inline bool operator < (const Point& a, const Point& b)\n  {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ntypedef vector<Point> Polygon;\ninline Point currPoint(vector<Point> P, int i){ return P[i]; }\ninline Point nextPoint(vector<Point> P, int i){ return P[(i+1)%P.size()]; }\ninline Point diffPoint(vector<Point> P, int i){ return nextPoint(P, i) - currPoint(P, i); }\n\nint ccw(Point a, Point b, Point c)\n{\n  b -= a;\n  c -= a;\n  if(b.det(c) > 0.0)    return  1;         // counter clockwise\n  if(b.det(c) < 0.0)    return -1;         // clockwise\n  if(b.dot(c) < 0.0)    return  2;         // c--a--b on line\n  if(norm(b) < norm(c)) return -2;         // a--b--c on line\n  return 0;\n}\n\n\nPolygon AndrewMonotoneChain(vector<Point> ps)\n{\n  int n = ps.size(), k = 0;\n  if(n <= 2) return ps;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2*n);\n  for(int i=0; i<n; ch[k++]=ps[i++]) // lower-hull\n    while(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for(int i=n-2, t=k+1; i>= 0; ch[k++]=ps[i--]) // upper-hull\n    while(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nenum { OUT, ON, IN };\nint convexContains(const Point p, const Polygon P)\n{\n  const int n = P.size();\n  Point g = (P[0] + P[n/3] + P[2*n/3]) / 3.0; // inner-Point\n  int a = 0, b = n;\n  while (a+1 < b) { // invariant: c is in fan g-P[a]-P[b]\n    int c = (a + b) / 2;\n    if (semige(Point(P[a]-g).det(P[c]-g), 0.0)) { // angle < 180 deg\n      if (semige(Point(P[a]-g).det(p-g), 0.0) && semile(Point(P[c]-g).det(p-g), 0.0)) b = c;\n      else a = c;\n    } else {\n      if (semile(Point(P[a]-g).det(p-g), 0.0) && semige(Point(P[c]-g).det(p-g), 0.0)) a = c;\n      else b = c;\n    }\n  }\n  b %= n;\n  if (semile(Point(P[a] - p).det(P[b] - p), 0.0)) return 0;\n  if (semige(Point(P[a] - p).det(P[b] - p), 0.0)) return 2;\n  return 1;\n}\n\n\nbool intersect_1pt(const Point a, const Point b,\n                   const Point c, const Point d, Point r)\n{\n  double D =  Point(b - a).det(d - c);\n  if (semieq(D, 0.0)) return false;\n  double t =  Point(c - a).det(d - c) / D;\n  double s = -Point(a - c).det(b - a) / D;\n  r = a + t * (b - a);\n  return semige(t, 0.0) && semile(t, 1.0) && semige(s, 0.0) && semile(s, 1.0);\n}\n\nPolygon convexIntersect(const Polygon P, const Polygon Q)\n{\n  const int n = P.size(), m = Q.size();\n  int a = 0, b = 0, aa = 0, ba = 0;\n  enum { Pin, Qin, Unknown } in = Unknown;\n  Polygon R;\n  do {\n    int a1 = (a+n-1) % n, b1 = (b+m-1) % m;\n    double C = Point(P[a] - P[a1]).det(Q[b] - Q[b1]);\n    double A = Point(P[a1] - Q[b]).det(P[a] - Q[b]);\n    double B = Point(Q[b1] - P[a]).det(Q[b] - P[a]);\n    Point r;\n    if (intersect_1pt(P[a1], P[a], Q[b1], Q[b], r)) {\n      if (in == Unknown) aa = ba = 0;\n      R.push_back( r );\n      in = B > 0 ? Pin : A > 0 ? Qin : in;\n    }\n    if (C == 0 && B == 0 && A == 0) {\n      if (in == Pin) { b = (b + 1) % m; ++ba; }\n      else           { a = (a + 1) % m; ++aa; }\n    } else if (C >= 0) {\n      if (A > 0) { if (in == Pin) R.push_back(P[a]); a = (a+1)%n; ++aa; }\n      else       { if (in == Qin) R.push_back(Q[b]); b = (b+1)%m; ++ba; }\n    } else {\n      if (B > 0) { if (in == Qin) R.push_back(Q[b]); b = (b+1)%m; ++ba; }\n      else       { if (in == Pin) R.push_back(P[a]); a = (a+1)%n; ++aa; }\n    }\n  } while ( (aa < n || ba < m) && aa < 2*n && ba < 2*m );\n  if (in == Unknown) {\n    if (convexContains(P[0], Q)) return P;\n    if (convexContains(Q[0], P)) return Q;\n  }\n  return R;\n}\n\nstruct Line : public vector<Point>\n{\npublic:\n  Line(){ }\n  Line(const Point P, const Point Q){ this->pb(P);  this->pb(Q); }\n  Line(double px, double py, double qx, double qy){ this->pb(Point(px, py));  this->pb(Point(qx, qy)); }\n};\ntypedef Line Segment;\n\n\ninline bool intersectionDeterminationOfSS(Segment S, Segment T){return ccw(S[0],S[1],T[0])*ccw(S[0],S[1],T[1])<=0&&ccw(T[0],T[1],S[0])*ccw(T[0],T[1],S[1])<=0;}\ninline bool onLine(Point P, Line L){return semieq(Point(L[0]-P).det(L[1]-P),0.0);}\n\n\nint n, m;\ndouble x, y;\n\nint main(int argc, char *argv[])\n{\n  while(cin >> n >> m, n){\n    vector<Point> B(n);\n    vector<Point> W(m);\n    rep(i, n){\n      cin >> x >> y;\n      B[i] = Point(x, y);\n    }\n    rep(i, m){\n      cin >> x >> y;\n      W[i] = Point(x, y);\n    }\n\n    B = AndrewMonotoneChain(B);\n    W = AndrewMonotoneChain(W);\n\n    int b = B.size();\n    int w = W.size();\n    if(b == 1 && w == 1){\n      puts(\"YES\");\n      continue;\n    }\n    if(w == 1){\n      swap(B, W);\n      swap(b, w);\n    }\n    if(b == 1){\n      bool ok;\n      if(w == 2) ok = onLine(B[0], Line(W[0], W[1]));\n      else ok = convexContains(B[0], W);\n      puts(ok ? \"NO\" : \"YES\");\n      continue;\n    }\n    if(w == 2){\n      swap(B, W);\n      swap(b, w);\n    }\n    if(b == 2){\n      bool ok = false;\n      if(w == 2) ok = intersectionDeterminationOfSS(Line(B[0], B[1]), Line(W[0], W[1]));\n      else{\n        rep(i, w) ok |= intersectionDeterminationOfSS(Line(B[0], B[1]), Line(currPoint(W, i), nextPoint(W, i)));\n      }\n      puts(ok ? \"NO\" : \"YES\");\n      continue;\n    }\n    puts(convexIntersect(B, W).size() ? \"NO\" : \"YES\");\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = 1e9;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> P;\n\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n\n/** 幾何ライブラリ **/\n#include <complex>\n\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-8;\n\ntypedef double D;\ntypedef complex<D> P; // Point\n\nstruct L { // Line\n\tP a, b;\n\tL(){}\n\tL(P aa, P bb) : a(aa), b(bb){}\n};\n\n// 共役複素数 conj(a);\n\n// 符号\nint sig(D a, D b=0) { return a < b - EPS ? -1 : (a > b + EPS ? 1 : 0); }\n\n// 内積\nD dot(P a, P b) { return (conj(a)*b).real(); }\n\n// 外積\nD cross(P a, P b) { return (conj(a)*b).imag(); }\n\n// 線分abに対する点cの位置\nenum STATE{LEFT=1, RIGHT=-1, BACK=2, FRONT=-2, ON=0, IN=3, OUT=-3};\nint ccw(P a, P b, P c)\n{\n\tb -= a, c -= a;\n\tD s = sig(cross(b, c));\n\tif (s) return s>0 ? LEFT : RIGHT;\n\tif (sig(dot(b, c))<0) return BACK;\n\tif (sig(abs(c), abs(b))>0) return FRONT;\n\treturn ON;\n}\n\n// 直線lに対する点pの写像\nP projection(L l, P p)\n{\n\treturn l.a + (l.b-l.a)/abs(l.b-l.a) * dot(l.b-l.a, p-l.a)/abs(l.b-l.a);\n}\n\n// 直線lに対する点pの反射\nP reflection(L l, P p)\n{\n\treturn p + (projection(l, p)-p)*P(2, 0);\n}\n\n// 直線abと点cの距離\nD dLP(L l, P c)\n{\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分abと点cの距離\nD dSP(L l, P c)\n{\n\tif (sig(dot(l.b-l.a, c-l.a))<0) return abs(c-l.a);\n\tif (sig(dot(l.a-l.b, c-l.b))<0) return abs(c-l.b);\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分と線分の交差判定\nbool iSS(L s, L t)\n{\n\treturn (ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0)\n\t\t\t&& (ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0);\n}\n\n// 線分と線分の距離\nD dSS(L s, L t)\n{\n\tif (iSS(s, t)) return 0;\n\treturn min(min(dSP(t, s.a), dSP(t, s.b)), min(dSP(s, t.a), dSP(s, t.b)));\n}\n\n// 線分と線分の交点 (公差していることが前提)\nP cSS(L s, L t)\n{\n\tD d1 = dLP(t, s.a);\n\tD d2 = dLP(t, s.b);\n\tD tmp = d1 / (d1 + d2);\n\treturn s.a + (s.b-s.a)*tmp;\n}\n\n// 直線と直線の交差判定\nbool iLL(L s, L t)\n{\n\treturn sig(cross(s.b-s.a, t.b-t.a))!=0;\n}\n\n// 直線と直線の交点 iLLを確認してから使用\nP cLL(L s, L t)\n{\n\tP ss = s.b - s.a, tt = t.b - t.a;\n\treturn s.a + ss*cross(tt, t.a-s.a)/cross(tt, ss);\n}\n\n// 多角形\ntypedef vector<P> G;\n\n// 面積を求める (時計回りだと負になる)\nD area(G g)\n{\n\tD res = 0.0;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tres += cross(g[i], g[(i+1)%g.size()]);\n\t}\n\treturn res/2;\n}\n\n// 多角形gと点pの包含関係を求める\nint containsGP(G g, P p)\n{\n\tbool in=false;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tP a = g[i], b = g[(i+1)%g.size()];\n\t\tif (ccw(a, b, p) == ON) return ON;\n\t\t\n\t\ta -= p, b -= p;\n\t\tif (a.Y > b.Y) swap(a, b);\n\t\tif (a.Y<0 && b.Y>=0 && sig(cross(a, b))>0) in = !in;\n\t}\n\treturn in?IN:OUT;\n}\n\nbool cmp_convex_full(const P &a, const P &b)\n{\n\tif (sig(a.X, b.X) != 0) return a.X < b.X;\n\treturn a.Y < b.Y;\n}\n\n// 凸包を得る\n// 辺上を含めない場合は <= 0 にする\nG convex_hull(vector<P> ps)\n{\n\tif (ps.size()==1) return ps;\n\t\n\tint N = (int)ps.size(), k=0;\n\tsort(ps.begin(), ps.end(), cmp_convex_full);\n\tG res(2*N);\n\t\n\tfor (int i=0; i<N; i++) {\n\t\twhile (k>=2 && ccw(res[k-2], res[k-1], ps[i]) == RIGHT) k--;\n\t\tres[k++] = ps[i];\n\t}\n\t\n\tint t = k+1;\n\tfor (int i=N-2; i>=0; i--) {\n\t\twhile (k>=t && ccw(res[k-2], res[k-1], ps[i]) == RIGHT) k--;\n\t\tres[k++] = ps[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// 凸多角形を直線で切断し、左側を残す\nG convex_cut(G g, L l)\n{\n\tG res;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tP a = g[i], b = g[(i+1)%g.size()];\n\t\tif (ccw(l.a, l.b, a) != RIGHT) res.push_back(a);\n\t\tif (ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0) res.push_back(cLL(L(a, b), l));\n\t}\n\treturn res;\n}\n\n\n/** Problem1298 : Separate Points **/\nint main()\n{\n\tint N, M;\n\twhile (cin>>N>>M, N||M) {\n\t\tvector<P> bp(N), wp(M);\n\t\trep(i, N) cin>>bp[i].X>>bp[i].Y;\n\t\trep(i, M) cin>>wp[i].X>>wp[i].Y;\n\t\t\n\t\tG bc = convex_hull(bp);\n\t\tG wc = convex_hull(wp);\n\n\t\tbool ok = true;\n\n\t\tif (bc.size()==2 && wc.size()==2) {\n\t\t\tif (iSS(L(bc[0], bc[1]), L(wc[0], wc[1]))) ok=false;\n\t\t} if (bc.size()==1 && wc.size()==2) {\n\t\t\tif (ccw(wc[0], wc[1], bc[0]) == ON) ok=false;\n\t\t} else if (wc.size()==1 && bc.size()==2) {\n\t\t\tif (ccw(bc[0], bc[1], wc[0]) == ON) ok=false;\n\t\t} else {\n\t\t\tif (bc.size()>2) {\n\t\t\t\tfor (int i=0; i<wc.size(); i++) {\n\t\t\t\t\tif (containsGP(bc, wc[i]) == ON || containsGP(bc, wc[i]) == IN) ok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (wc.size()>2) {\n\t\t\t\tfor (int i=0; i<bc.size(); i++) {\n\t\t\t\t\tif (containsGP(wc, bc[i]) == ON || containsGP(wc, bc[i]) == IN) ok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (ok?\"YES\":\"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < (int)(n); i++)\n\ntypedef complex<double> P;\nconst double EPS = 1e-8;\n\ndouble dot(P a, P b) {return real( conj(a)*b);}\ndouble cross(P a, P b) {return imag( conj(a)*b);}\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > EPS)   return +1;       // counter clockwise\n  if (cross(b, c) < -EPS)   return -1;       // clockwise\n  if (dot(b, c) < -EPS)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c) - EPS) return -2; // a--b--c on line\n  return 0;                               // a--c--b on line (or b == c)\n}\n\nint WindingNumber (const vector<P>& g, P p) {\n  int wn = 0;\n  int n = g.size();\n  REP(i, n) {\n    int j = (i + 1) % n;\n    if( g[i].imag() <= p.imag() + EPS ) {\n      if( g[j].imag() > p.imag() + EPS && ccw(g[i], g[j], p) > 0 )\n        wn++;\n    }\n    else {\n      if( g[j].imag() <= p.imag() + EPS && ccw(g[i], g[j], p) < 0) {\n        wn--;\n      }\n    }\n  }\n  return wn;\n}\n\nbool IsIntersectSP(P a, P b, P c) {\n  return (abs(a-c) + abs(c-b) <= abs(a-b) + EPS);\n}\n\nenum {OUT, CROSS, IN};\nint ContainGS (const vector<P>& g, P p) {\n  REP(i, g.size()) {\n    if( IsIntersectSP( g[i], g[(i+1) % g.size()], p) )\n      return CROSS;\n  }\n  int wn = WindingNumber(g, p);\n  return wn > 0;\n}\n\nvector<P> ConvexHull(vector<P> g) {\n  int n = g.size();\n  if( n <= 1 ) return g;\n  sort(g.begin(), g.end());\n  vector<P> res(2 * n);\n  int k = 0;\n  for(int i = 0; i < n; res[k++] = g[i++] )\n    while( k >= 2 && ccw( res[k-2], res[k-1], g[i]) <= 0 ) k--;\n  for(int i = n - 2, t = k + 1; i >= 0; res[k++] = g[i--] )\n    while( k >= t && ccw( res[k-2], res[k-1], g[i]) <= 0 ) k--;\n  res.resize(k-1);\n  return res;\n}\n\nbool IsIntersectSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 &&\n    ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0;\n}\n\nint IsIntersectGG(const vector<P> &g1, const vector<P>& g2) {\n  if( g1.size() <= 1 ) {\n    if( ContainGS( g2, g1[0] ) ) return IN;\n    return OUT;\n  }\n\n  if( g2.size() <= 1 ) {\n    if( ContainGS( g1, g2[0] ) ) return IN;\n    return OUT;\n  }\n\n  REP(i, g1.size()) {\n    REP(j, g2.size()) {\n      if( IsIntersectSS( g1[i], g1[(i+1) % g1.size()],\n                         g2[j], g2[(j+1) % g2.size()]) )\n        return CROSS;\n    }\n  }\n  if( ContainGS( g1, g2[0] ) || ContainGS( g2, g1[0] )) {\n    return IN;\n  }\n  return OUT;\n}\n\nint main() {\n  int A, B;\n  while( cin >> A >> B ) {\n    if( !(A || B) ) break;\n    vector<P> a, b;\n    REP(i, A) {\n      int x, y; cin >> x >> y;\n      a.push_back( P(x,y) );\n    }\n    REP(i, B) {\n      int x, y; cin >> x >> y;\n      b.push_back( P(x,y) );      \n    }\n    a = ConvexHull(a);\n    b = ConvexHull(b);\n\n    int t = IsIntersectGG(a,b);\n    if( t == OUT ) puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tvector<Polygon>polys;\n\tpolys.push_back(Q);\n\tpolys.push_back(R);\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\n#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\n\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<Point>wps, bps;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tPoint wp(input_point());\n\t\t\twps.push_back(wp);\n\t\t}\n\t\tfor (int i = 0; i <M; ++i) {\n\t\t\tPoint bp(input_point());\n\t\t\tbps.push_back(bp);\n\t\t}\n\n\t\tPolygon bpoly(convex_hull(bps));\n\t\tPolygon wpoly(convex_hull(wps));\n\t\tbool ok = true;\n\t\t/*for (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tLine wl(wps[i], wps[j]);\n\t\t\t\tfor (int k = 0; k < M; ++k) {\n\t\t\t\t\tif (isis_sp(wl, bps[k])) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tgoto a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tfor (int j = i + 1; j < M; ++j) {\n\t\t\t\tLine bl(bps[i], bps[j]);\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tif (isis_sp(bl, wps[k])) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tgoto a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (is_in_polygon(bpoly, wps[i])) {\n\t\t\t\tok = false;\n\t\t\t\tgoto a;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (is_in_polygon(wpoly, bps[i])) {\n\t\t\t\tok = false;\n\t\t\t\tgoto a;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < wpoly.size(); ++i) {\n\t\t\tLine wl(wpoly[i], wpoly[(i + 1)% wpoly.size()]);\n\t\t\tfor (int j = 0; j < bpoly.size(); ++j) {\n\t\t\t\tLine bl(bpoly[j], bpoly[(j + 1) % bpoly.size()]);\n\t\t\t\tif (isis_ss(wl, bl))ok = false;\n\t\t\t}\n\t\t}\n\ta:0;\n\t\tif (ok)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#define eps 1e-8\nusing namespace std;\ntypedef struct point {\n    double x,y;\n    point(double x=0,double y=0):x(x),y(y) { }\n} Vector;\nint dcmp(double x) {\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\nVector operator  + (Vector A,Vector B) {\n    return Vector(A.x+B.x,A.y+B.y);\n}\nVector operator  -  (point A,point B) {\n    return Vector(A.x-B.x,A.y-B.y);\n}\nVector operator  *  (Vector A,double p) {\n    return Vector(A.x*p,A.y*p);\n}\nVector operator  /  (Vector A,double p) {\n    return Vector(A.x/p,A.y/p);\n}\ndouble xmult(point a,point b,point c) {\n    return (a.x-c.x)*(b.y-c.y)-(a.y-c.y)*(b.x-c.x);\n}\ndouble multi(point a,point b,point c) {\n    return (a.x-c.x)*(b.x-c.x)+(a.y-c.y)*(b.y-c.y);\n}\nbool cmp(point a,point b) {\n    if (a.y<b.y) return 1;\n    else if (fabs(a.y-b.y)<eps&&a.x<b.x) return 1;\n    else return 0;\n}\nint convex(point *p,point *con,int len) {\n    sort(p,p+len,cmp);\n    int top;\n    con[0]=p[0],con[1]=p[1],top=1;\n    for (int i=2; i<len; i++) {\n        while (xmult(con[top],p[i],con[top-1])<0&&top>0) top--;\n        con[++top]=p[i];\n    }\n    int top1=top;\n    con[++top]=p[len-2];\n    for (int i=len-3; i>=0; i--) {\n        while (xmult(con[top],p[i],con[top-1])<0&&top>top1) top--;\n        con[++top]=p[i];\n    }\n    return top;\n}\nbool SegmentProperIntersection(point a1,point a2,point b1,point b2) {\n    double c1=xmult(a2,b1,a1),c2=xmult(a2,b2,a1);\n    double c3=xmult(b2,a1,b1),c4=xmult(b2,a2,b1);\n    return (dcmp(c1)*dcmp(c2)<0)&&(dcmp(c3)*dcmp(c4)<0);\n}\nbool Onsegment(point P,point a1,point a2) {\n    return dcmp(xmult(a1,a2,P))==0&&dcmp(multi(a1,a2,P))<0;\n}\nbool check(point a1,point a2,point b1,point b2) {\n    if (SegmentProperIntersection(a1,a2,b1,b2)) return 1;\n    return Onsegment(a1,b1,b2)||Onsegment(a2,b1,b2)||Onsegment(b1,a1,a2)||Onsegment(b2,a1,a2);\n}\ndouble area(point *p,int len) {\n    if (len<3) return 0;\n    double ans=0;\n    for (int i=2;i<len;i++) ans+=abs(xmult(p[i],p[i-1],p[0]));\n    return ans;\n}\nint n,m;\npoint p1[211],p2[211],c1[211],c2[211];\nint main() {\n    //freopen(\"1.txt\",\"w\",stdout);\n    while (~scanf(\"%d%d\",&n,&m)) {\n        if (n==0&&m==0) break;\n        for (int i=0; i<n; i++) scanf(\"%lf%lf\",&p1[i].x,&p1[i].y);\n        for (int i=0; i<m; i++) scanf(\"%lf%lf\",&p2[i].x,&p2[i].y);\n        if (n>1) n=convex(p1,c1,n);\n        else c1[0]=p1[0];\n        if (m>1) m=convex(p2,c2,m);\n        else c2[0]=p2[0];\n        bool flag=1;\n        for (int i=0; i<n; i++) {\n            for (int j=0; j<m; j++) {\n                if (check(c1[i],c1[(i+1)%n],c2[j],c2[(j+1)%m])) {\n                    flag=0;\n                    break;\n                }\n            }\n            if (flag==0) break;\n        }\n        if (n==1) {\n            for (int i=0;i<m;i++)\n                if (Onsegment(c1[0],c2[i],c2[(i+1)%m])) flag=0;\n        }\n        if (m==1) {\n            for (int i=0;i<n;i++)\n                if (Onsegment(c2[0],c1[i],c1[(i+1)%n])) flag=0;\n        }\n        double s=area(c1,n);\n        if (s>0) {\n            for (int i=0;i<m;i++) {\n                double cnt=0;\n                for (int j=0;j<n;j++) cnt+=abs(xmult(c1[j],c1[(j+1)%n],c2[i]));\n                if (dcmp(cnt-s)==0) flag=0;\n            }\n        }\n        s=area(c2,m);\n        if (s>0) {\n            for (int i=0;i<n;i++) {\n                double cnt=0;\n                for (int j=0;j<m;j++) cnt+=abs(xmult(c2[j],c2[(j+1)%m],c1[i]));\n                if (dcmp(cnt-s)==0) flag=0;\n            }\n        }\n        if (flag) printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define EPS 0.000001\ntypedef long double ld;\n\nFILE *in = freopen(\"input.txt\", \"r\", stdin);\n\nstruct P {\n\tld x, y;\n\tP(ld x, ld y):x(x),y(y){}\n\tP(){}\n};\n\nP operator -(const P &a, const P &b) { return P(a.x-b.x, a.y-b.y); }\nbool operator <(const P &a, const P &b){ return make_pair(a.x, a.y) < make_pair(b.x, b.y); }\n\nld cross(const P &a, const P &b) { return a.x*b.y-a.y*b.x; }\nld dot(const P &a, const P &b) { return a.x*b.x+a.y*b.y; }\nld norm(const P &a) { return dot(a,a); }\nint ccw(P a, P b, P c) {\n\tb = b - a; c = c - a;\n\tif(cross(b,c) > EPS) return 1;\n\tif(cross(b,c) < EPS) return -1;\n\tif(dot(b,c) < 0) return 2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nstruct L:vector<P>{\n\tL(P a=P(0,0), P b=P(0,0)) {\n\t\tthis->push_back(a);\n\t\tthis->push_back(b);\n\t}\n};\n\nbool is_intersect_SS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0],s[1],t[1]) <= 0 &&\n\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\n\nvector<P> convex_hull(vector<P> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<P> ch(2*n);\n\tfor(int i = 0; i < n; ch[k++]=ps[i++])\n\t\twhile(k >= 2 && ccw(ch[k-2],ch[k-1],ps[i]) <= 0)--k;\n\tfor(int i = n-2, t = k+1; i >= 0; ch[k++]=ps[i--])\n\t\twhile(k>=t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0)--k;\n\tif(k>2)ch.resize(k-1);\n\treturn ch;\n}\n\nint n, m;\nvector<P> black;\nvector<P> white;\n\nvoid input() {\n\tblack.clear();\n\twhite.clear();\n\trep(i, n) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tblack.push_back(P(x,y));\n\t}\n\trep(i, m) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\twhite.push_back(P(x,y));\n\t}\n}\n\nvoid process() {\n\tblack = convex_hull(black);\n\twhite = convex_hull(white);\n\twhite.push_back(white[0]);\n\n\t// Check LP\n\trep(i,black.size()) {\n\t\tL x(black[i], P(black[i].x+1,black[i].y+10001));\n\t\tint cnt = 0;\n\t\trep(j,white.size()-1) {\n\t\t\tL y(white[j], white[j+1]);\n\t\t\tcnt += is_intersect_SS(x,y);\n\t\t}\n\t\tif(cnt%2 == 1) {\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tblack.push_back(black[0]);\n\n\t// Check cross LL\n\trep(i,black.size()-1) {\n\t\tL x(black[i],black[i+1]);\n\t\trep(j,white.size()-1){\n\t\t\tL y(white[j], white[j+1]);\n\t\t\tif(is_intersect_SS(x,y)) {\n\t\t\t\tprintf(\"NO\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"YES\\n\");\n}\n\nint main() {\n\twhile(true) {\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(!n) break;\n\t\tinput();\n\t\tprocess();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <utility>\n#define maxn 105\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nstruct Point{\n\tdouble x,y;\n\tPoint(double x = 0.0,double y = 0.0): x(x),y(y) {}\n\tPoint operator + (Point p){\n\t\treturn Point(x + p.x,y + p.y);\n\t}\n\tPoint operator - (Point p){\n\t\treturn Point(x - p.x,y - p.y);\n\t}\n\tPoint operator * (double lambda){\n\t\treturn Point(x * lambda,y * lambda);\n\t}\n\tPoint operator / (double lambda){\n\t\treturn Point(x / lambda,y / lambda);\n\t}\n\tPoint operator - (){\n\t\treturn Point(-x,-y);\n\t}\n\tdouble norm(){\n\t\treturn x * x + y * y;\n\t}\n\tdouble abs_(){\n\t\treturn sqrt(norm());\n\t}\n\tbool operator == (const Point &p)const\n\t{\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n\tbool operator < (const Point &p)const\n\t{\n\t\tif(abs(x - p.x) < EPS) return y < p.y;\n\t\telse return x < p.x;\n\t}\n};\ntypedef Point Vector;\nstruct Segment{\n\tPoint p1,p2;\n\tSegment(Point p1 = Point(),Point p2 = Point()): p1(p1),p2(p2) {}\n};\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\ndouble dot(Vector a,Vector b){ return a.x * b.x + a.y * b.y; }\ndouble det(Vector a,Vector b){ return a.x * b.y - a.y * b.x; }\nint ccw(Point p,Segment l){\n\tif(det(l.p2 - l.p1,p - l.p1) > EPS) return 1;\n\tif(det(l.p2 - l.p1,p - l.p1) < -EPS) return -1;\n\tif(dot(l.p2 - l.p1,p - l.p1) < -EPS) return 2;\n\tif((l.p2 - l.p1).norm() < (p - l.p1).norm()) return -2;\n\treturn 0;\n}\nbool cross(Segment s1,Segment s2){\n\treturn ccw(s1.p1,s2) * ccw(s1.p2,s2) <= 0 && ccw(s2.p1,s1) * ccw(s2.p2,s1) <= 0;\n}\nPolygon convexHull(int n,Point* p){\n\tsort(p + 1,p + n + 1);\n\tint k = 0;\n\tPolygon con(n << 1);\n\tfor(int i=1;i<=n;i++){\n\t\twhile(k > 1 && det(p[i] - con[k - 1],con[k - 2] - con[k - 1]) < EPS) k--;\n\t\tcon[k++] = p[i];\n\t}\n\tint t = k;\n\tfor(int i=n-1;i>=1;i--){\n\t\twhile(k > t && det(p[i] - con[k - 1],con[k - 2] - con[k - 1]) < EPS) k--;\n\t\tcon[k++] = p[i];\n\t}\n\tcon.resize(max(1,k - 1));\n\treturn con;\n}\nPoint bl[maxn],wh[maxn];\nint n,m;\nbool inside(Point p,Polygon po){\n\tint k = po.size();\n\tfor(int i=0;i<k;i++){\n\t\tint ind = ccw(p,Segment(po[i],po[(i + 1) % k]));\n\t\tif(ind != 1 && ind != 0) return false;\n\t}\n\treturn true;\n}\nint main(){\n\twhile(~scanf(\"%d%d\",&n,&m) && n){\n\t\tfor(int i=1;i<=n;i++) scanf(\"%lf%lf\",&bl[i].x,&bl[i].y);\n\t\tfor(int i=1;i<=m;i++) scanf(\"%lf%lf\",&wh[i].x,&wh[i].y);\n\t\tPolygon con1 = convexHull(n,bl);\n\t\tPolygon con2 = convexHull(m,wh);\n\t\tint k1 = con1.size(), k2 = con2.size();\n\t\tbool ok = true;\n\t\tok &= !inside(con1[0],con2);\n\t\tok &= !inside(con2[0],con1);\n\t\tif(k1 != 1 && k2 != 1)\n\t\t\tfor(int i=0;i<k1;i++){\n\t\t\t\tfor(int j=0;j<k2;j++){\n\t\t\t\t\tif(cross(Segment(con1[i],con1[(i + 1) % k1]),Segment(con2[j],con2[(j + 1) % k2]))) ok = false;\n\t\t\t\t}\n\t\t\t}\n\t\tif(ok) puts(\"YES\");\n\t\telse puts(\"NO\");\n \t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 2009ツアツジツアツ地ツ凝ヲツ予ツ選 D : Separate Points\n#include <iostream>\n#include <fstream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\ntypedef complex<double> P;\n\nstruct L { P p, q; L(P p, P q) : p(p), q(q) {} };\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\ndouble angle(P a, P b){ return arg(conj(a)*b); }\n\nbool compare(const P &a, const P &b){\n\treturn make_pair(real(a),imag(a)) < make_pair(real(b),imag(b));\n}\n\nvector<P> convexHull(vector<P> vp){\n\tif(vp.size() < 3) return vp;\n\tsort(vp.begin(), vp.end(), compare);\n\tvector< pair<double,int> > vi;\n\tfor(int i=1;i<vp.size();i++) vi.push_back(make_pair(angle(P(1,0),vp[i]-vp[0]), i));\n\tsort(vi.begin(), vi.end());\n\tvector<P> res(2);\n\tres[0] = vp[0]; res[1] = vp[vi[0].second];\n\tfor(int i=1;i<vi.size();i++){\n\t\tP next = vp[vi[i].second];\n\t\tint sz = res.size();\n\t\twhile(sz>=2&&cross(res[sz-1]-res[sz-2],next-res[sz-1])<EPS){\n\t\t\tres.pop_back(); sz--;\n\t\t}\n\t\tres.push_back(next);\n\t}\n\treturn res;\n}\n\nbool ssIntersect(L a, L b){\n\tif(imag((a.q-a.p)/(b.q-b.p))<EPS) return false;\n\treturn cross(a.q-a.p,b.p-a.p)*cross(a.q-a.p,b.q-a.p)<EPS&&\n\t\t   cross(b.q-b.p,a.p-b.p)*cross(b.q-b.p,a.q-b.p)<EPS;\n}\n\nbool contain(vector<P> vp, P p){\n\tif(vp.size()==1) return false;\n\tbool in = false;\n\tfor(int i=0;i<vp.size();i++){\n\t\tP a = vp[i]-p, b = vp[(i+1)%vp.size()]-p;\n\t\tif(imag(a) > imag(b)) swap(a,b);\n\t\tif(imag(a) < EPS && EPS < imag(b))\n\t\t\tif(cross(a,b) < 0) in = !in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS) return true;\n\t}\n\treturn in;\n}\n\nbool separate(vector<P> a, vector<P> b){\n\tif(a.size()!=1&&b.size()!=1)\n\t\tfor(int i=0;i<a.size();i++)\n\t\t\tfor(int j=0;j<b.size();j++)\n\t\t\t\tif(ssIntersect(L(a[i],a[(i+1)%a.size()]),L(b[j],b[(j+1)%b.size()]))) return false;\n\tfor(int i=0;i<a.size();i++)\n\t\tif(contain(b, a[i])) return false;\n\tfor(int i=0;i<b.size();i++)\n\t\tif(contain(a, b[i])) return false;\n\treturn true;\n}\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m, n){\n\t\tint x, y;\n\t\tvector<P> black, white;\n\t\tfor(int i=0;i<n;i++){ cin >> x >> y; black.push_back(P(x,y)); }\n\t\tfor(int i=0;i<m;i++){ cin >> x >> y; white.push_back(P(x,y)); }\n\t\tcout << (separate(convexHull(black), convexHull(white)) ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\nlong double EPS = (long double)1e-7;\nstruct Point { long double px, py; };\nPoint r1[100], r2[100]; int n, m;\nvector<pair<Point, int>>vec, vec2;\ninline bool solve(Point a1, Point a2) {\n\tif (a1.px > a2.px)swap(a1, a2);\n\tif (a1.px == a2.px) {\n\t\tint colour = 0; bool r[3] = { false,false,false };\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tif (r[1] == true && r[2] == true)return false;\n\t\t\tif (colour == 0) {\n\t\t\t\tif (vec2[i].first.px < a1.px) { colour = 3 - vec2[i].second; }\n\t\t\t\telse if (vec2[i].first.px == a1.px) { r[vec2[i].second] = true; }\n\t\t\t\telse if (vec2[i].first.px > a1.px) { colour = vec2[i].second; }\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (colour != 3 - vec2[i].second && vec2[i].first.px < a1.px) { return false; }\n\t\t\t\telse if (vec2[i].first.px == a1.px) { r[vec2[i].second] = true; }\n\t\t\t\telse if (colour != vec2[i].second && vec2[i].first.px > a1.px) { return false; }\n\t\t\t}\n\t\t}\n\t\tif (r[1] == true && r[2] == true)return false;\n\t\treturn true;\n\t}\n\telse {\n\t\tlong double KT = (a2.py - a1.py) / (a2.px - a1.px);\n\t\tlong double YY = a1.py - a1.px*KT;\n\t\tint colour = 0; bool r[3] = { false,false,false };\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tif (r[1] == true && r[2] == true)return false;\n\t\t\tlong double height = YY + KT*vec2[i].first.px;\n\t\t\tif (colour == 0) {\n\t\t\t\tif (vec2[i].first.py < height) { colour = 3 - vec2[i].second; }\n\t\t\t\telse if (vec2[i].first.py == height) { r[vec2[i].second] = true; }\n\t\t\t\telse if (vec2[i].first.py > height) { colour = vec2[i].second; }\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (colour != 3 - vec2[i].second && vec2[i].first.py < height) { return false; }\n\t\t\t\telse if (vec2[i].first.py == height) { r[vec2[i].second] = true; }\n\t\t\t\telse if (colour != vec2[i].second && vec2[i].first.py > height) { return false; }\n\t\t\t}\n\t\t}\n\t\tif (r[1] == true && r[2] == true)return false;\n\t\treturn true;\n\t}\n}\nint main() {\n\twhile (true) {\n\t\tvec.clear(); vec2.clear(); cin >> n >> m; if (n == 0 && m == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> r1[i].px >> r1[i].py; vec2.push_back(make_pair(r1[i], 1));\n\t\t\tfor (long double j = -1.0l; j <= 1.0l; j += 1.0l) {\n\t\t\t\tfor (long double k = -1.0l; k <= 1.0l; k += 1.0l) {\n\t\t\t\t\tif (fabs(j) + fabs(k) > 1.9l)continue;\n\t\t\t\t\tvec.push_back(make_pair(Point{ r1[i].px + j*EPS,r1[i].py + k*EPS }, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> r2[i].px >> r2[i].py; vec2.push_back(make_pair(r2[i], 2));\n\t\t\tfor (long double j = -1.0l; j <= 1.0l; j += 1.0l) {\n\t\t\t\tfor (long double k = -1.0l; k <= 1.0l; k += 1.0l) {\n\t\t\t\t\tif (fabs(j) + fabs(k) > 1.9l)continue;\n\t\t\t\t\tvec.push_back(make_pair(Point{ r2[i].px + j*EPS,r2[i].py + k*EPS }, 2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans = false;\n\t\tfor (int i = 0; i < vec.size(); i++) {\n\t\t\tfor (int j = i + 1; j < vec.size(); j++) {\n\t\t\t\tif (fabs(vec[i].first.px - vec[j].first.px) + fabs(vec[i].first.py - vec[j].first.py) < EPS * 6)continue;\n\t\t\t\tbool p1 = solve(vec[i].first, vec[j].first);\n\t\t\t\tif (p1 == true) {\n\t\t\t\t\tans = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == true)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <ctime>\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1.0);\n\n// 2つのスカラーが等しいかどうか\nbool equal(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\n// 点クラス\nstruct P {\n\tdouble x, y;\n\tP(double x_, double y_) { x = x_; y = y_; }\n\tP(){}\n\t// 加算, 減算, スカラー倍\n\tP operator+(const P& a) const {\n\t\treturn P(x + a.x, y + a.y);\n\t}\n\tP operator-(const P& a) const {\n\t\treturn P(x - a.x, y - a.y);\n\t}\n\tP operator*(const P& a) const {\n\t\treturn P(x * a.x - y * a.y, x * a.y + y * a.y);\n\t}\n\tP operator*(double c) const {\n\t\treturn P(x * c, y * c);\n\t}\n\tP operator/(const P& a) const {\n\t\tdouble norm = a.x * a.x + a.y * a.y;\n\t\tdouble x_ = (x * a.x + y * a.y) / norm;\n\t\tdouble y_ = (y * a.x - x * a.y) / norm;\n\t\treturn P(x_, y_);\n\t}\n\tP operator/(double c) const {\n\t\treturn P(x / c, y / c);\n\t}\n\tP& operator+=(const P& a) {\n\t\tx += a.x; y += a.y;\n\t}\n\tP& operator-=(const P& a) {\n\t\tx -= a.x; y -= a.y;\n\t}\n\tP& operator*=(const P& a) {\n\t\t*this = P(x * a.x - y * a.y, x * a.y + y * a.y);\n\t}\n\tP& operator*=(double c) {\n\t\t*this = P(x * c, y * c);\n\t}\n\tP& operator/=(const P& a) {\n\t\tdouble norm = a.x * a.x + a.y * a.y;\n\t\tdouble x_ = (x * a.x + y * a.y) / norm;\n\t\tdouble y_ = (y * a.x - x * a.y) / norm;\n\t\t*this = P(x_, y_);\n\t}\n\tP& operator/=(double c) {\n\t\t*this = P(x / c, y / c);\n\t}\n\t// デバッグ出力\n\tvoid print() { printf(\"(%f,%f)\", x, y); }\n};\nP operator*(double c, P a){\n\treturn P(a.x * c, a.y * c);\n}\n// 比較演算子\nbool operator==(const P& a, const P& b) {\n\treturn equal(a.x, b.x) && equal(a.y, b.y);\n}\nbool operator!=(const P& a, const P& b) {\n\treturn !(a == b);\n}\nbool operator<(const P& a, const P& b) {\n\treturn (a.x != b.x)? a.x < b.x : a.y < b.y;\n}\n\nconst P INF_P = P(INF, INF);\n\n// 原点からの距離(絶対値)\ndouble abs(P a) {\n\treturn sqrt(a.x * a.x + a.y * a.y);\n}\n// 2点間の距離\ndouble dist(P a, P b) {\n\treturn abs(a - b);\n}\n// ノルム\ndouble norm(const P& z){\n\treturn z.x * z.x + z.y * z.y;\n}\n// 偏角\ndouble arg(const P& z) {\n\treturn atan2(z.y, z.x);\n}\n// ベクトル a の単位ベクトルを求める\nP unit(P a) {\n\treturn a / abs(a);\n}\n// ベクトル a の法線ベクトルを求める\nvector<P> normal(P a) {\n\tvector<P> vp;\n\tvp.push_back( a * P(0, +1) );\n\tvp.push_back( a * P(0, -1) );\n\treturn vp;\n}\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// CCW : 反時計回り (Counter Clock Wise)\n// CW : 時計回り (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3点がどちら回りであるか返す, 3点が1直線に乗っているときは ON を返す\nint ccw(const P &a, P b, P c) {\n\tb -= a, c -= a;\n\tif( cross(b,c) >  EPS ) return CCW; // CCW : 反時計回り\n\tif( cross(b,c) < -EPS ) return CW;  // CW : 時計回り\n\tif( dot(b, c)  < -EPS ) return +2;  // c--a--b on line\n\tif( dot(b, b)  + EPS < dot(c, c) ) return -2; // a--b--c on line \n\treturn ON;\n}\n\n// ラジアンから度数へ変換して返す\ndouble to_deg(double rad) {\n\treturn rad * 180.0 / PI;\n}\n// 度数からラジアンに変換して返す\ndouble to_rad(double deg) {\n\treturn deg * PI / 180.0;\n}\n\n// 原点を軸に点 p を角度 a (ラジアン)だけ回転させた点を返す\nP rot(P p, double a){\n\treturn P(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n// 点 a を軸に点 b を角度 angle (ラジアン)だけ回転させた点を返す\nP rot(P a, P b, double angle){\n\treturn rot(b - a, angle) + a;\n}\n\n// 点 c を点 a, b を通る直線の線対称に移動させる\nP symmetry(P a, P b, P c) {\n\tP res;\n\tif( b.x == a.x ) {\n\t\tres.x = -c.x; res.y = c.y;\n\t}else{\n\t\tdouble m = (b.y - a.y) / (b.x - a.x);\n\t\tdouble z = b.y - m * b.x;\n\t\tres.x = (2 * m * c.y - c.x * (m * m - 1) - 2 * m * z) / (m * m + 1);\n\t\tres.y = (2 * m * c.x + c.y * (m * m - 1) + 2 * z) / (m * m + 1);\n\t}\n\treturn res;\n}\n\n// 直線クラス\nstruct Line : public vector<P> {\n\tLine(){}\n\tLine(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n\tLine(const vector<P>& vp){\n\t\t(*this) = vp;\n\t}\n\t// デバッグ出力 (線分を出力)\n\tvoid print_s() const {\n\t\tprintf(\"line(%f,%f,%f,%f); \\n\", (*this)[0].x, (*this)[0].y, (*this)[1].x, (*this)[1].y);\n\t}\n\t// デバッグ出力 (直線を出力, 途中で直線が途切れているときは適当にlenの値を大きくする)\n\tvoid print_l() const {\n\t\tconst double len = 100;\n\t\tP p1 = (*this)[0], p2 = (*this)[1];\n\t\tdouble dx = p1.x - p2.x, dy = p1.y - p2.y;\n\t\tp1.print();\n\t\tp2.print();\n\t\tp1.x += len * dx;\n\t\tp1.y += len * dy;\n\t\tp2.x -= len * dx;\n\t\tp2.y -= len * dy;\n\t\tLine l( p1 , p2 );\n\t\tl.print_s();\n\t}\n};\n\n// 2つの直線の直交判定\nbool is_orthogonal(const Line& a, const Line& b) {\n\treturn equal( dot( a[0] - a[1] , b[0] - b[1] ) , 0.0 );\n}\n// 2つの直線の平行判定\nbool is_parallel(const Line& a, const Line& b) {\n\treturn equal( cross( a[0] - a[1] , b[0] - b[1] ), 0.0 );\n}\n\n// 直線 a と直線 b の交差判定\nbool intersectLL(const Line& a, const Line& b) {\n\treturn abs(cross(a[1] - a[0], b[1] - b[0])) > EPS || abs(cross(a[1] - a[0], b[0] - a[0])) < EPS;\n}\n// 直線 l と 線分 s の交差判定\nbool intersectLS(const Line& l, const Line& s) {\n\treturn cross(l[1] - l[0], s[0] - l[0]) * cross(l[1] - l[0], s[1] - l[0]) < EPS;\n}\n// 直線 l 上に点 p があるかどうか\nbool intersectLP(const Line& l, const P& p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\n// 線分 s と 線分 t の交差判定\nbool intersectSS(const Line& s, const Line& t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t\t   ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n// 線分 s 上に点 p があるかどうか\nbool intersectSP(const Line& s, const P& p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS;\n}\n\nP projection(const Line& l, const P& p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + (l[0] - l[1]) * t;\n}\nP reflection(const Line& l, const P& p) {\n\treturn p + 2 * (projection(l, p) - p);\n}\n// 直線と点の距離\ndouble distanceLP(const Line& l, const P& p) {\n\treturn abs(p - projection(l, p));\n}\n// 直線と直線の距離\ndouble distanceLL(const Line& l, const Line& m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n// 直線と線分の距離\ndouble distanceLS(const Line& l, const Line& s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n// 線分と点の距離\ndouble distanceSP(const Line& s, const P& p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\n// 線分と線分の距離\ndouble distanceSS(const Line& s, const Line& t) {\n\tif (intersectSS(s, t)) return 0;\n\tdouble a = min(distanceSP(s, t[0]), distanceSP(s, t[1]));\n\tdouble b = min(distanceSP(t, s[0]), distanceSP(t, s[1]));\n\treturn min(a, b);\n}\n// 交点計算\nP crosspoint(const Line& l, const Line& m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\t// if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\n// 円クラス\nstruct Circle{\n\tP p;\n\tdouble r;\n\t// コンストラクタで初期化\n\tCircle(P p_, double r_) { p = p_; r = r_; }\n\t// 点 a が円の内部にあるかどうか\n\tbool is_inside(P a) const {\n\t\treturn dist(p, a) <= r;\n\t}\n\t// 点 a が円周上にあるかどうか\n\tbool on_boundary(P a) const {\n\t\treturn equal( dist(p, a) , r );\n\t}// 等しいかどうか\n\tbool operator==(const Circle& c) const {\n\t\treturn p == c.p && r == c.r;\n\t}// デバッグ出力\n\tvoid print() { printf(\"circle(%f,%f,%f); \\n\", p.x, p.y, r ); }\n};\n\nstruct Triangle{\nprivate:\n\t// 余弦定理から 3 つの角の角度を求める (内部の関数で使用)\n\tdouble law_of_cos(double a, double b, double c) {\n\t\treturn acos( (b*b + c*c - a*a) / (2.0 * b * c) );\n\t}\n\t// 点 a , b を端点とする線分に点 c が含まれているかどうか\n\tbool contain(P a, P b, P c) {\n\t\treturn abs(a - c) + abs(b - c) - abs(b - a) < EPS;\n\t}\npublic:\n\t// 3 つの頂点\n\tP a, b, c;\n\t// 3 つの辺の長さ\n\tdouble edgeA, edgeB, edgeC;\n\t// 3 つの角の角度 (ラジアン)\n\tdouble angleA,angleB,angleC;\n\t// コンストラクタで初期化\n\tTriangle(P p1, P p2, P p3) {\n\t\ta = p1; b = p2; c = p3;\n\t\tedgeB = abs(c-a);\n\t\tedgeA = abs(b-c);\n\t\tedgeC = abs(a-b);\n\t\tangleA = law_of_cos( edgeA, edgeB, edgeC );\n\t\tangleB = law_of_cos( edgeB, edgeC, edgeA );\n\t\tangleC = law_of_cos( edgeC, edgeA, edgeB );\n\t}\n\t// 三角形の面積を返す (ヘロンの公式)\n\tdouble get_area() {\n\t\tdouble s = 0.5 * (edgeA + edgeB + edgeC);\n\t\treturn sqrt( s * (s - edgeA) * (s - edgeB) * (s - edgeC) );\n\t}\n\t// 点 p が三角形の辺上にあるかどうか\n\tbool on_boundary(P p) {\n\t\treturn contain(a, b, p) || contain(b, c, p) || contain(c, a, p);\n\t}\n\t// 三角形の重心を返す\n\tP gravity() {\n\t\treturn P( (a.x + b.x + c.x) / 3.0 , (a.y + b.y + c.y) / 3.0 );\n\t}\n\t// 三角形の外接円を返す (AOJ 0010 で検証済み)\n\tCircle circumscribed_circle() {\n\t\tdouble r = ( edgeA / sin(angleA) / 2.0 );\n\t\tdouble A = sin( 2.0 * angleA );\n\t\tdouble B = sin( 2.0 * angleB );\n\t\tdouble C = sin( 2.0 * angleC );\n\t\tdouble cx = ( (a.x * A + b.x * B + c.x * C) / (A + B + C) );\n\t\tdouble cy = ( (a.y * A + b.y * B + c.y * C) / (A + B + C) );\n\t\treturn Circle( P(cx,cy) , r );\n\t}\n\t// 三角形の内接円を返す\n\tCircle inscribed_circle() {\n\t\t// 三角形の外周の長さ\n\t\tdouble ABC = edgeA + edgeB + edgeC;\n\t\t\n\t\tdouble cx = (a.x * edgeA + b.x * edgeB + c.x * edgeC) / ABC;\n\t\tdouble cy = (a.y * edgeA + b.y * edgeB + c.y * edgeC) / ABC;\n\t\tdouble r  = (2.0 * get_area()) / ABC ;\n\t\treturn Circle( P(cx,cy) , r );\n\t}\n\t// 点 p が三角形の内部にあるかどうか ( AOJ 0012 で検証済み )\n\tbool is_inside(P p) {\n\t\t// 辺上にあるとき\n\t\tif( this->on_boundary(p) ) return true;\n\t\t\n\t\tTriangle t1( a , b , p );\n\t\tTriangle t2( b , c , p );\n\t\tTriangle t3( c , a , p );\n\t\t// 角APB + 角BPB + 角CPA が 360度なら 点 p は三角形の内部にある\n\t\treturn equal( t1.angleC + t2.angleC + t3.angleC , 2.0*PI );\n\t}\n\t// デバッグ出力\n\tvoid print() {\n\t\tLine AB(a,b), BC(b,c), CA(c,a);\n\t\tAB.print_s();\n\t\tBC.print_s();\n\t\tCA.print_s();\n\t}\n};\n\ntypedef vector<P> Polygon;\n\n// 点 p が単純多角形の内部・外部・境界のどこにあるか判定する.\nenum { OUT, IN };\nint contains(const Polygon& g, const P& p) {\n\tint n = g.size();\n\tbool in = false;\n\tfor(int i = 0 ; i < n ; i++ ){\n\t\tP a = g[i] - p;\n\t\tP b = g[(i+1)%n] - p;\n\t\tif( a.y > b.y ){\n\t\t\tswap(a, b);\n\t\t}\n\t\tif( a.y <= 0 && 0 < b.y ){\n\t\t\tif( cross(a, b) < 0 ){\n\t\t\t\tin = !in;\n\t\t\t}\n\t\t}\n\t\tif( cross(a, b) == 0 && dot(a, b) <= 0 ){\n\t\t\treturn ON;\n\t\t}\n  }\n  return in? IN : OUT;\n}\n// (凸とは限らない) 多角形の面積を返す.\ndouble get_area(const Polygon& g) {\n\tint n = g.size();\n\tdouble s = 0;\n\tfor(int i = 0 ; i < n ; i++ )\n\t\ts += cross(g[i], g[(i+1) % n]);\n\treturn fabs(s) * 0.5;\n}\n\n// 凸多角形かどうか\nbool is_convex(const Polygon& g) {\n\tint n = g.size();\n\tfor(int i = 0 ; i < n ; i++ ){\n\t\tif( ccw(g[(i+n-1) % n], g[i % n], g[(i+1) % n]) > 0 )\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n// 凸包を求める. (ps.size() >= 3 と仮定する)\nvector<P> convex_hull(vector<P> ps) {\n\tint n = ps.size();\n    sort( ps.begin() , ps.end() );\n     \n    // 上部を求める\n    vector<P> ch_u( n );\n    int n_u = 0;\n    for(int i = n-1 ; i >= 0 ; i-- ) {\n        ch_u[n_u++] = ps[i];\n        while( n_u >= 3 && ccw( ch_u[n_u-3] , ch_u[n_u-2] , ch_u[n_u-1] ) != CCW ) {\n            ch_u[n_u-2] = ch_u[n_u-1];\n            n_u--;\n        }\n    }\n  \n    vector<P> ch_l( n );\n    int n_l = 0;\n    for(int i = 0 ; i < n ; i++ ) {\n        ch_l[n_l++] = ps[i];\n        while( n_l >= 3 && ccw( ch_l[n_l-3] , ch_l[n_l-2] , ch_l[n_l-1]) != CCW ) {\n            ch_l[n_l-2] = ch_l[n_l-1];\n            n_l--;\n        }\n    }\n  \n    Polygon ch;\n    for(int i=0 ; i<n_u-1 ; i++ ) ch.push_back(ch_u[i]);\n    for(int i=0 ; i<n_l-1 ; i++ ) ch.push_back(ch_l[i]);\n    return ch;\n}\n\n// 凸多角形をある直線で切断し，その左側だけ残す．\nPolygon convex_cut(const Polygon& g, const Line& l) {\n\tPolygon Q;\n\tint n = g.size();\n\tfor(int i = 0 ; i < n ; i++ ){\n\t\tP A = g[i], B = g[(i+1) % n];\n\t\tif( ccw(l[0], l[1], A) != -1 ){\n\t\t\tQ.push_back(A);\n\t\t}\n\t\tif( ccw(l[0], l[1], A) * ccw(l[0], l[1], B) < 0 ){\n\t\t\tQ.push_back(crosspoint(Line(A, B), l));\n\t\t}\n\t}\n\treturn Q;\n}\n// 凸多角形の重心を返す\nP gravity(const Polygon& g) {\n\tP sg(0,0);\n\tdouble s = 0.0;\n\tfor(int i=2 ; i < g.size() ; i++ ) {\n\t\tTriangle t( g[0] , g[i-1] , g[i] );\n\t\ts += t.get_area();\n\t\tsg += t.get_area() * t.gravity();\n\t};\n\treturn sg / s;\n}\n\n// 点 p が凸多角形の内部・外部・境界のどれにあるか判定する.\nint convex_contains(const Polygon& g, const P& p) {\n\tconst int n = g.size();\n\tP pp = (g[0] + g[n/3] + g[2*n/3]) / 3.0;\n\tint a = 0, b = n;\n\twhile( a + 1 < b ){\n\t\tint c = (a + b) / 2;\n\t\tif( cross(g[a] - pp, g[c] - pp) > 0 ){\n\t\t\tif( cross(g[a] - pp, p - pp) > 0 && cross(g[c] - pp, p - pp) < 0 ){\n\t\t\t\tb = c;\n\t\t\t}else{\n\t\t\t\ta = c;\n\t\t\t}\n\t\t}else{\n\t\t\tif( cross(g[a] - pp, p - pp) < 0 && cross(g[c] - pp, p - pp) > 0 ){\n\t\t\t\ta = c;\n\t\t\t}else{\n\t\t\t\tb = c;\n\t\t\t}\n\t\t}\n\t}\n\tb %= n;\n\tif( cross(g[a] - p, g[b] - p) < 0 ) return OUT;\n\tif( cross(g[a] - p, g[b] - p) > 0 ) return IN;\n\treturn ON;\n}\n\n// 2つの凸多角形の共通部分の凸多角形を返す\nbool intersect_1pt(const P& a, const P& b, const P& c, const P& d, P &r) {\n\tdouble D =  cross(b - a, d - c);\n\tif( equal(D,0) ) return false;\n\tdouble t =  cross(c - a, d - c) / D;\n\tdouble s = -cross(a - c, b - a) / D;\n\tr = a + t * (b - a);\n\treturn ( t >= 0 && t <= 1 && s >= 0 && s <= 1 );\n}\nPolygon convex_intersect(Polygon p, Polygon q) {\n\tconst int n = p.size();\n\tconst int m = q.size();\n\tint a = 0, b = 0, aa = 0, ba = 0;\n\tenum { Pin, Qin, Unknown } in = Unknown;\n\tPolygon R;\n\tdo {\n\t\tint a1 = (a+n-1) % n;\n\t\tint b1 = (b+m-1) % m;\n\t\tdouble C = cross( p[a] - p[a1] , q[b] - q[b1] );\n\t\tdouble A = cross( p[a1] - q[b], p[a] - q[b] );\n\t\tdouble B = cross( q[b1] - p[a], q[b] - p[a] );\n\t\tP r;\n\t\tif( intersect_1pt( p[a1], p[a], q[b1], q[b], r ) ) {\n\t\t\tif( in == Unknown ) aa = ba = 0;\n\t\t\tR.push_back( r );\n\t\t\tin = (B > 0) ? Pin : (A > 0)? Qin : in ;\n\t\t}\n\t\tif( C == 0 && B == 0 && A == 0 ) {\n\t\t\tif( in == Pin ) {\n\t\t\t\tb = (b + 1) % m;\n\t\t\t\t++ba;\n\t\t\t}else {\n\t\t\t\ta = (a + 1) % m;\n\t\t\t\t++aa;\n\t\t\t}\n\t\t}else if( C >= 0 ) {\n\t\t\tif( A > 0 ) {\n\t\t\t\tif( in == Pin ) R.push_back( p[a] );\n\t\t\t\ta = (a+1) % n;\n\t\t\t\t++aa;\n\t\t\t}else {\n\t\t\t\tif( in == Qin ) R.push_back( q[b] );\n\t\t\t\tb = (b+1) % m;\n\t\t\t\t++ba;\n\t\t\t}\n\t\t}else {\n\t\t\tif( B > 0 ) { \n\t\t\t\tif( in == Qin ) R.push_back( q[b] );\n\t\t\t\tb = (b+1) % m;\n\t\t\t\t++ba;\n\t\t\t}else {\n\t\t\t\tif( in == Pin ) R.push_back( p[a] );\n\t\t\t\ta = (a+1) % n;\n\t\t\t\t++aa;\n\t\t\t}\n\t\t}\n\t}while( (aa < n || ba < m) && aa < 2*n && ba < 2*m );\n\tif( in == Unknown ) {\n\t\tif( convex_contains(q, p[0]) ) return p;\n\t\tif( convex_contains(p, q[0]) ) return q;\n\t}\n\treturn R;\n}\n\n// 凸多角形の直径を求める. (最遠頂点対は pp に入る)\nP diff(const Polygon& g, int i){\n\treturn g[(i+1) % g.size()] - g[i];\n}\ndouble convex_diameter(const Polygon& pt, pair<P,P>& pp) {\n\tconst int n = pt.size();\n\tint is = 0, js = 0;\n\tfor(int i = 1 ; i < n ; i++ ){\n\t\tif( pt[i].y > pt[is].y ) is = i;\n\t\tif( pt[i].y < pt[js].y ) js = i;\n\t}\n\tdouble maxd = norm(pt[is] - pt[js]);\n\tint i, maxi, j, maxj;\n\ti = maxi = is;\n\tj = maxj = js;\n\tdo{\n\t\tif( cross(diff(pt,i), diff(pt,j)) >= 0){\n\t\t\tj = (j+1) % n;\n\t\t}else{\n\t\t\ti = (i+1) % n;\n\t\t}\n\t\t\n\t\tif( norm(pt[i] - pt[j]) > maxd ){\n\t\t\tmaxd = norm(pt[i] - pt[j]);\n\t\t\tmaxi = i;\n\t\t\tmaxj = j;\n\t\t}\n\t}while( i != is || j != js );\n\tpp = pair<P,P>(pt[maxi], pt[maxj]);\n\treturn sqrt(maxd);\n}\n\n// 直線 l の方向( l[0] から l[1] へのベクトル ) と 最も遠い点を返す\ndouble d(int k, const Polygon& g, const Line& l) {\n\treturn dot(g[k], l[1] - l[0]);\n}\nP convex_extreme(const Polygon& g, const Line& l) {\n\tint a = 0, b = g.size(), n = g.size();\n\tif( d(0,g,l) >= d(n-1,g,l) && d(0,g,l) >= d(1,g,l) ){\n\t\treturn g[0];\n\t}\n\twhile( a < b ) {\n\t\tint c = (a + b) / 2;\n\t\tif( d(c,g,l) >= d(c-1,g,l) && d(c,g,l) >= d(c+1,g,l) ){\n\t\t\treturn g[c];\n\t\t}\n\t\tif( d(a+1,g,l) > d(a,g,l) ){\n\t\t\tif( d(c+1,g,l) <= d(c,g,l) || d(a,g,l) > d(c,g,l) ){\n\t\t\t\tb = c;\n\t\t\t}else{\n\t\t\t\ta = c;\n\t\t\t}\n\t\t}else{\n\t\t\tif( d(c+1,g,l) > d(c,g,l) || d(a,g,l) >= d(c,g,l) ){\n\t\t\t\ta = c;\n\t\t\t}else{\n\t\t\t\tb = c;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m;\n\twhile( cin >> n >> m , n || m ){\n\t\tvector<P> black, white;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tblack.push_back( P(x,y) );\n\t\t}\n\t\tfor(int i=0 ; i < m ; i++ ){\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\twhite.push_back( P(x,y) );\n\t\t}\n\t\tif( 3 <= n && 3 <= m ){\n\t\t\tblack = convex_hull(black);\n\t\t\twhite = convex_hull(white);\n\t\t\tPolygon g = convex_intersect(black, white);\n\t\t\tbool ans = true;\n\t\t\tif( get_area(g) > EPS ){\n\t\t\t\tans = false;\n\t\t\t}\n\t\t\tcout << (ans? \"YES\" : \"NO\") << endl;\n\t\t}else{\n\t\t\tbool ans = true;\n\t\t\tif( n == 2 ){\n\t\t\t\tLine l(black[0], black[1]);\n\t\t\t\tif( m == 1 ){\n\t\t\t\t\tif( intersectSP(l, white[0]) ) ans = false;\n\t\t\t\t}else{\n\t\t\t\t\tLine l2(white[0], white[1]);\n\t\t\t\t\tif( intersectSS(l, l2) ) ans = false;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif( m == 2 ){\n\t\t\t\t\tLine l(white[0], white[1]);\n\t\t\t\t\tif( intersectSP(l, black[0]) ) ans = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << (ans? \"YES\" : \"NO\") << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D; \ntypedef complex<D> P;\ntypedef pair<P, P> L;\ntypedef vector<P> VP;\nconst D EPS = 1e-9; \n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1; \n  if (cross(b,c) < -EPS) return -1;\n  if (dot(b,c)   < -EPS) return +2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\nVP convexHull(VP ps) {\n  if(ps.size()==1)return ps;\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\nint main(){\n  int n,m;\n  double x,y;\n  while(cin>>n>>m,n){\n    VP v1,v2,v3;\n    int f=0;\n    set<VP>se;\n    rep(i,n){\n      cin>>x>>y;\n      v1.push_back(P(x,y));\n    }\n    rep(i,m){\n      cin>>x>>y;\n      v2.push_back(P(x,y));\n    }\n    v1=convexHull(v1);\n    v2=convexHull(v2);\n    se.insert(v1);\n    se.insert(v2);\n    rep(i,v1.size())v3.push_back(v1[i]);\n    rep(i,v2.size())v3.push_back(v2[i]);\n    v3=convexHull(v3);\n    if(se.count(v3))f++;\n    rep(i,v1.size())\n      rep(j,v2.size())\n        if(isecSS(v1[i],v1[(i+1)%(int)v1.size()],v2[j],v2[(j+1)%(int)v2.size()]))f++;\n    L:;cout<<(f?\"NO\":\"YES\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nconst double EPS = 1e-8;\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nvector<P> convex_hull(vector<P> v){\n  vector<P> c; //convex\n  sort(v.begin(),v.end());\n  c.assign(v.begin(),v.begin()+2);\n    \n  for(int i=2;i<v.size();i++){\n    P a = c[c.size()-1] - c[c.size()-2];\n    P b = v[i] - c[c.size()-2];\n        \n    while(cross(a,b) > EPS){\n      c.pop_back();\n      if(c.size() < 2) break;\n      a = c[c.size()-1] - c[c.size()-2];\n      b = v[i] - c[c.size()-2];\n    }\n        \n    c.push_back(v[i]);\n  }\n\t\n  int n = c.size();\n  c.push_back(v[v.size()-2]);\n\t\n  for(int i=v.size()-3;i>=0;i--){\n    P a = c[c.size()-1] - c[c.size()-2];\n    P b = v[i] - c[c.size()-2];\n        \n    while(cross(a,b) > EPS){\n      c.pop_back();\n      if(c.size() < n + 1) break;\n      a = c[c.size()-1] - c[c.size()-2];\n      b = v[i] - c[c.size()-2];\n    }\n        \n    c.push_back(v[i]);\n\t}\n  c.pop_back();\n  return c;\n}\n\nL get2points(vector<P> p){\n  \n  double dis=0;\n  int idx1, idx2;\n  \n  for(int i=0;i<p.size();i++){\n    for(int j=i+1;j<p.size();j++){\n      if(abs(p[j]-p[i])>dis){\n\tdis=abs(p[j]-p[i]);\n\tidx1=i;\n\tidx2=j;\n      }\n    }\n  }\n\n  return L(p[idx1],p[idx2]);\n}\n\nbool isIntersectSP(L s, P p){ \n  return abs(s.first-p) + abs(s.second-p) - abs(s.second-s.first) < EPS; \n}\n\nbool check(vector<P> p){\n  \n  L l=get2points(p);\n  \n  for(int i=0;i<p.size();i++)\n    if(!isIntersectSP(l,p[i])) return false;\n\n  return true;\n}\n\nbool isIntersect(L s1, L s2){\n  \n  //ccw ??????????????????????????¨, ????????????????????´?????????????????¨??????????????????????????????\n  if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\nint main(){\n  \n  while(1){\n    \n    int n, m;\n    cin>>n>>m;\n    \n    if(!n&&!m) break;\n    \n    vector<P> p1, p2;\n\n    for(int i=0;i<n;i++){\n      int a, b;\n      cin>>a>>b;\n      p1.push_back(P(a,b));\n    }\n    \n    for(int i=0;i<m;i++){\n      int a, b;\n      cin>>a>>b;\n      p2.push_back(P(a,b));\n    }\n\n    bool ans=true;\n\n    vector<P> v1, v2;\n    \n    if(p1.size()!=1){\n      \n      if(check(p1)){\n\tL l=get2points(p1);\n\tfor(int i=0;i<p2.size();i++)\n\t  if(isIntersectSP(l,p2[i])) ans=false;\n\tv1.push_back(l.first);\n\tv1.push_back(l.second);\n      }else{\n\tvector<P> p=convex_hull(p1);\n\t\n\tfor(int i=0;i<p2.size();i++){\n\t  int com=ccw(p[0],p[1],p2[i]);\n\t  int flag=0;\n\t  for(int j=0;j<p.size();j++)\n\t    if(com!=ccw(p[j],p[(j+1)%p.size()],p2[i])) flag=1;\n\t  if(flag==0) ans=false;\n\t}\n\t\n\tfor(int i=0;i<p.size();i++)\n\t  for(int j=0;j<p2.size();j++)\n\t    if(isIntersectSP(L(p[i],p[(i+1)%p.size()]),p2[j])) ans=false;\n\tv1=p;\n      }\n      \n    }\n    \n    if(p2.size()!=1){\n      \n      if(check(p2)){\n\tL l=get2points(p2);\n\tfor(int i=0;i<p1.size();i++)\n\t  if(isIntersectSP(l,p1[i])) ans=false;\n\tv2.push_back(l.first);\n\tv2.push_back(l.second);\n      }else{\n\tvector<P> p=convex_hull(p2);\n\t\n\tfor(int i=0;i<p1.size();i++){\n\t  int com=ccw(p[0],p[1],p1[i]);\n\t  int flag=0;\n\t  for(int j=0;j<p.size();j++)\n\t    if(com!=ccw(p[j],p[(j+1)%p.size()],p1[i])) flag=1;\n\t  if(flag==0) ans=false;\n\t}\n\n\tfor(int i=0;i<p.size();i++)\n\t  for(int j=0;j<p1.size();j++)\n\t    if(isIntersectSP(L(p[i],p[(i+1)%p.size()]),p1[j])) ans=false;\n\tv2=p;\n      }\n      \n    }\n    \n    if(p1.size()!=1&&p2.size()!=1){\n      \n      for(int i=0;i<v1.size();i++)\n\tfor(int j=0;j<v2.size();j++){\n\t  L l1=L(v1[i],v1[(i+1)%v1.size()]);\n\t  L l2=L(v2[i],v2[(i+1)%v2.size()]);\n\t  if(isIntersect(l1,l2)) ans=false;\n\t}\n      \n    }\n    \n    if(ans) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n    \n  }  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\ntypedef pair<double, double> P;\nint f(double w[], P p){\n  double v = w[0] + w[1] * p.first + w[2] * p.second;\n  if(v >= 0) return 1;\n  else return 0;\n}\n\nint main(){\n  int b, w;\n  while(cin>>b>>w && (b != 0 || w != 0)){\n    vector<P> points_b, points_w;\n    REP(i, b){\n      double x, y; cin>>x>>y;\n      points_b.push_back(P(x, y));\n    }\n    REP(i, w){\n      double x, y; cin>>x>>y;\n      points_w.push_back(P(x, y));\n    }\n    double we[3] = {};\n    double rate = 0.5;\n    bool ans = false;\n    REP(iter, 28000000/(w + b)){\n      bool update = false;\n      REP(i, b){\n        int v = f(we, points_b[i]);\n        if(v == 1){\n          we[0] = we[0] + rate * -1;\n          we[1] = we[1] + rate * -1 * points_b[i].first;\n          we[2] = we[2] + rate * -1 * points_b[i].second;\n          update = true;\n        }\n      }\n      REP(i, w){\n        int v = f(we, points_w[i]);\n        if(v == 0){\n          we[0] = we[0] + rate * 1;\n          we[1] = we[1] + rate * 1 * points_w[i].first;\n          we[2] = we[2] + rate * 1 * points_w[i].second;\n          update = true;\n        }\n      }\n      if(!update){\n        ans = true;\n        break;\n      }\n    }\n    if(ans) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\n#define EPS 1e-7\n\ntypedef complex<double> point;\ntypedef const point &refpoint;\n\n\ndouble dot(refpoint a, refpoint b){\n\treturn real(a) * real(b) + imag(a) * imag(b);\n}\n\ndouble cross(refpoint a, refpoint b){\n\treturn real(a) * imag(b) - imag(a) * real(b);\n}\n\ndouble distance_l_p(refpoint a, refpoint b, refpoint c){\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\ndouble distance_ls_p(refpoint a, refpoint b, refpoint c){\n\tif( dot(b - a, c - a) <= 0.0 ) return abs(c - a);\n\tif( dot(a - b, c - b) <= 0.0 ) return abs(c - b);\n\treturn distance_l_p(a, b, c);\n}\n\nbool contains(const vector<point> &plg, refpoint pts){\n\tint cnt = 0;\n\tdouble y = imag(pts);\n\n\tfor(int i = 0; i < plg.size(); ++i){\n\t\tint j = (i + 1 == plg.size() ? 0: i + 1);\n\n\t\tdouble dyi = imag(plg[i]) - y;\n\t\tdouble dyj = y - imag(plg[j]);\n\t\tdouble tx = (dyi * real(plg[j]) + dyj * real(plg[i])) / (dyi + dyj);\n\n\t\tif(imag(plg[i]) >= y && imag(plg[j]) < y){\n\t\t\tif( tx < real(pts) ) ++cnt;\n\t\t}\n\t\telse if(imag(plg[i]) < y && imag(plg[j]) >= y){\n\t\t\tif( tx < real(pts) ) --cnt;\n\t\t}\n\t}\n\t\n\treturn (cnt % 2 != 0);\n}\n\nbool intersected(refpoint pa1, refpoint pa2, refpoint pb1, refpoint pb2){\n\tdouble a = cross(pa2 - pa1, pb1 - pa1);\n\tdouble b = cross(pa2 - pa1, pb2 - pa1);\n\tdouble c = cross(pb2 - pb1, pa1 - pb1);\n\tdouble d = cross(pb2 - pb1, pa2 - pb1);\n\n\tif( (a < -EPS && b > EPS) || (b < -EPS && a > EPS) ){\n\t\tif( (c < -EPS && d > EPS) || (d < -EPS && c > EPS) ){\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nbool contact(const vector<point> &plg1, const vector<point> &plg2){\n\tif( contains(plg1, plg2[0]) || contains(plg2, plg1[0]) ){\n\t\treturn true;\n\t}\n\n\tint n = plg1.size();\n\tint m = plg2.size();\n\tfor(int i = 0; i < n; ++i){\n\t\tfor(int j = 0; j < m; ++j){\n\t\t\tif( intersected(plg1[i], plg1[(i+1)%n], plg2[j], plg2[(j+1)%m]) ){\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif( distance_ls_p(plg1[i], plg1[(i+1)%n], plg2[j]) < EPS ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif( distance_ls_p(plg2[j], plg2[(j+1)%n], plg1[i]) < EPS ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n\nvector<point> convex(const vector<point> plg){\n\tif( plg.size() <= 3 ){\n\t\treturn plg;\n\t}\n\n\tvector<point> ret;\n\n\tfor(int i = 0; i < plg.size(); ++i){\n\t\tint k = ret.size();\n\n\t\tif( k < 2 || cross( ret[k-1] - ret[k-2], plg[i] - ret[k-2] ) > 0.0 ){\n\t\t\tret.push_back( plg[i] );\n\t\t}\n\t\telse{\n\t\t\tret.back() = plg[i];\n\t\t}\n\t}\n\n\tint t = ret.size() + 1;\n\tfor(int i = plg.size() - 2; i >= 0; --i){\n\t\tint k = ret.size();\n\n\t\tif( k < t || cross( ret[k-1] - ret[k-2], plg[i] - ret[k-2] ) > 0.0 ){\n\t\t\tret.push_back( plg[i] );\n\t\t}\n\t\telse{\n\t\t\tret.back() = plg[i];\n\t\t}\n\t}\n\tret.pop_back();\n\t\n\treturn ret;\n}\n\n\nint main(){\n\tint n, m;\n\tdouble x, y;\n\t\n\twhile( scanf(\"%d%d\", &n, &m), n != 0 ){\n\t\tvector<point> black, white;\n\t\tblack.reserve(n);\n\t\twhite.reserve(m);\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\tblack.push_back( point(x, y) );\n\t\t}\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\twhite.push_back( point(x, y) );\n\t\t}\n\n\n\t\tblack = convex(black);\n\t\twhite = convex(white);\n\n\t\tif( contact(black, white) ){\n\t\t\tputs(\"NO\");\n\t\t}\n\t\telse{\n\t\t\tputs(\"YES\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-10)\n#define eq(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\ndouble norm(Vector v) { return v.x*v.x + v.y*v.y; }\ndouble abs(Vector v) { return sqrt(norm(v)); }\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nbool isOrthogonal(Vector a, Vector b) {\n  return eq(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isParallel(Vector a, Vector b) {\n  return eq(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n  return isParallel(a1 - a2, b1 - b2);\n}\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\ndouble getDistance(Point a, Point b) { return abs(a - b); }\ndouble getAngle(Point a, Point b, Point c) {\n  Vector v = b - a, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha) * 180 / M_PI;\n  return min(theta, 360 - theta);\n}\n\nstruct Segment {\n  Point p1, p2;\n  Segment(Point p1 = Point(), Point p2 = Point()):p1(p1), p2(p2){}\n};\ntypedef Segment Line;\n\nbool isOrthogonal(Segment s1, Segment s2) {\n  return eq(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isParallel(Segment s1, Segment s2) {\n  return eq(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p) {\n  return p + (project(s, p) - p) * 2.0;\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) {\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\ndouble getDistance(Segment s1, Segment s2) {\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPoint getCrossPointLL(Line l1, Line l2) {\n  Vector v1 = l1.p2 - l1.p1, v2 = l2.p2 - l2.p1;\n  double d = cross(v2, v1);\n  if(abs(d) < EPS) return l2.p1;\n  return l1.p1 + v1 * cross(v2, l2.p2 - l1.p1) * (1.0 / d);\n}\nLine getPerpendicularBisector(Point p1, Point p2) {\n  Point c = (p1 + p2) / 2.0;\n  Point q = Point(c.x + (p1.y - p2.y), c.y + (p2.x - p1.x));\n  return Line(c, q);\n}\n\nstruct Circle {\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0):c(c), r(r){}\n};\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n  // assert(intersect(c, l));\n  Vector pr = project(l, c.c);\n  Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n  double base = sqrt(c.r*c.r - norm(pr - c.c));\n  return make_pair(pr + e * base, pr - e * base);\n}\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n  // assert(intersect(c1, c2));\n  double d = abs(c1.c - c2.c);\n  double a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2*c1.r*d));\n  double t = arg(c2.c - c1.c);\n  return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\ntypedef vector<Point> Polygon;\n\ndouble getArea(Polygon p) {\n  double ret = 0.0;\n  for(int i = 0; i < (int)p.size(); i++) {\n    ret += cross(p[i], p[(i+1)%p.size()]);\n  }\n  return abs(ret) / 2.0;\n}\n\n#define IN_POLYGON  2\n#define ON_POLYGON  1\n#define OUT_POLYGON 0\nint contains(Polygon g, Point p) {\n  int n = g.size();\n  bool x = false;\n  for(int i = 0; i < n; i++) {\n    Point a = g[i] - p, b = g[(i+1) % n] - p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON_POLYGON;\n    if(a.y > b.y) swap(a, b);\n    if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n  }\n  return (x ? IN_POLYGON : OUT_POLYGON);\n}\n\nPolygon convexHull(Polygon ps) {\n  int N = ps.size(), j = 0;\n  Polygon pg(N*2);\n\n  if(N < 3) return ps;\n\n  sort(ps.begin(), ps.end(), [](Point p1, Point p2) -> bool {\n      return p1.y != p2.y ? lt(p1.y, p2.y) : lt(p1.x, p2.x); });\n  for(int i = 0; i < N; i++, j++) {\n    while(j >= 2 && ccw(pg[j-2], pg[j-1], ps[i]) == -1) j--;\n    pg[j] = ps[i];\n  }\n  int k = j+1;\n  for(int i = N-2; i >= 0; i--, j++) {\n    while(j >= k && ccw(pg[j-2], pg[j-1], ps[i]) == -1) j--;\n    pg[j] = ps[i];\n  }\n  pg.resize(j-1);\n  return pg;\n}\n\nPolygon convexCut(Polygon s, Line l) {\n  Polygon t;\n  for(int i = 0; i < (int)s.size(); i++) {\n    Point a = s[i], b = s[(i+1)%s.size()];\n    if(ccw(l.p1, l.p2, a) != -1) t.push_back(a);\n    if(ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0) {\n      t.push_back(getCrossPointLL(Line(a, b), l));\n    }\n  }\n  return t;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n, m;\n  while(cin >> n >> m, n || m) {\n    Polygon s(n), t(m);\n    rep(i, n) cin >> s[i].x >> s[i].y;\n    rep(i, m) cin >> t[i].x >> t[i].y;\n\n    if(n < 2 && m < 2) {\n      puts(\"YES\"); continue;\n    }\n    if(n + m <= 3) {\n      if(n == 2 && ccw(s[0], s[1], t[0]) == ON_SEGMENT ||\n\t m == 2 && ccw(t[0], t[1], s[0]) == ON_SEGMENT) {\n\tputs(\"NO\"); continue;\n      }\n      puts(\"YES\"); continue;\n    }\n    if(n == 2 && m == 2) {\n      if(intersect(s[0], s[1], t[0], t[1])) {\n\tputs(\"NO\"); continue;\n      }\n      puts(\"YES\"); continue;\n    }\n\n    auto S = convexHull(s);\n    auto T = convexHull(t);\n    bool flag = true;\n    for(auto&& p : t) flag &= (contains(S, p) == 0);\n    for(auto&& p : s) flag &= (contains(T, p) == 0);\n    cout << (flag ? \"YES\" : \"NO\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-10\n#define INF 1000000\n \nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n    Point operator *(const double d)const{\n        return Point(x*d,y*d);\n    }\n    bool operator <(const Point &p)const{\n        if(x==p.x) return y<p.y;\n        return x<p.x;\n    }\n    double norm(){\n        return x*x+y*y;\n    }\n\tbool input(){\n\t\tif(cin>>x>>y) return true;\n\t\treturn false;\n\t}\n};\n \nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n\tbool input(){\n\t\tif(a.input() && b.input()) return true;\n\t\treturn false;\n\t}\n};\n \nstruct Circle{\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point _c,double _r){\n        c=_c; r=_r;\n    }\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n \nint ccw(Point a,Point b,Point c){ //a,b,c,は全て異なる\n\tPoint v1 = b-a;\n\tPoint v2 = c-a;\n    if(cross(v1,v2)>EPS) return +1; //a->b->c が反時計回り\n    if(cross(v1,v2)<-EPS) return -1; //a->b->c が時計回り\n\tif(dot(v1,v2)<-EPS) return +2; //cがa-bより後ろ c<-a->b\n\tif(v1.norm()<v2.norm()) return -2; //cがa-bより前 a->b->c\n    return 0; //cがa-b上 a->c->b\n}\n \nbool intersect_ss(Line l,Line m){\n    return ccw(l.a,l.b,m.a)*ccw(l.a,l.b,m.b)<=0 && ccw(m.a,m.b,l.a)*ccw(m.a,m.b,l.b)<=0;\n}\n \nbool crosspoint_ll(Line l,Line m,Point &p){\n    Point a1,a2,b1,b2;\n    a1 = l.b-l.a; a2 = m.b-m.a;\n    b1 = m.a-l.a; b2 = l.a-m.b;\n    double s1,s2;\n    s1 = cross(a1,b1)/2; s2 = cross(a1,b2)/2;\n    if(s1+s2<EPS) return false; //平行\n    p = Point(m.a.x+a2.x*s1/(s1+s2),m.a.y+a2.y*s1/(s1+s2));\n    return true;\n}\n \nint crosspoint_ss(Line l,Line m,Point &p){\n    if(intersect_ss(l,m)==false) return 0; //交差していない\n    if(crosspoint_ll(l,m,p)==true) return 1;\n\treturn -1; //交点が無限個(平行かつ交差)\n}\n \nint crosspoint_cc(Circle c1,Circle c2,Point &p1,Point &p2){\n    double d,a,t;\n    d = sqrt((c2.c-c1.c).norm());\n\tif(abs(c1.c.x-c2.c.x)<EPS && abs(c1.c.y-c2.c.y)<EPS && abs(c1.r-c2.r)<EPS)\n\t\treturn -1; //2つの円が重なっている\n    if(d<abs(c1.r-c2.r) || c1.r+c2.r<d) return 0; //どちらかが内包している\n    a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    t = atan2(c2.c.y-c1.c.y,c2.c.x-c1.c.x);\n    p1 = Point(c1.c.x+c1.r*cos(t+a),c1.c.y+c1.r*sin(t+a));\n    p2 = Point(c1.c.x+c1.r*cos(t-a),c1.c.y+c1.r*sin(t-a));\n    if(abs(p1.x-p2.x)<EPS && abs(p1.y-p2.y)<EPS) return 1; //交点が1つ\n    return 2; //交点が2つ\n}\n\nint contains(Polygon g,Point p){\n\tLine l = Line(p,Point(INF,p.y));\n\tint cnt = 0, n = g.size();\n\tfor(int i=0;i<n;i++){\n\t\tPoint a = g[i]-p;\n\t\tPoint b = g[(i+1)%n]-p;\n\t\tif(ccw(g[i],g[(i+1)%n],p)==0) return 1; //線分上\n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<=EPS && EPS<b.y && cross(a,b)>EPS) cnt++;\n\t}\n\tif((cnt&1)==1) return 2; //内包している\n\treturn 0; //内包していない\n}\n\nPolygon andrewScan(Polygon s){\n\tif(s.size()<=2) return s;\n\tsort(s.begin(),s.end());\n\tPolygon g;\n\tfor(int i=0;i<s.size();i++){\n\t\tfor(int n=g.size(); n>=2 && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\tint upper_n = g.size();\n\tfor(int i=s.size()-2;i>=0;i--){\n\t\tfor(int n=g.size(); n>upper_n && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\treverse(g.begin(),g.end());\n\tg.pop_back();\n\treturn g;\n}\n\nint main(){\n\tint N,M;\n\tPolygon b,w,gb,gw;\n\twhile(cin>>N>>M,N||M){\n\t\tb.resize(N); w.resize(M);\n\t\tfor(int i=0;i<N;i++) b[i].input();\n\t\tfor(int i=0;i<M;i++) w[i].input();\n\t\tgb = andrewScan(b); gw = andrewScan(w);\n\t\tbool ans = true;\n\t\tif(gb.size()>=2 && gw.size()>=2){\n\t\t\tfor(int i=0;i<gb.size() && ans;i++){\n\t\t\t\tfor(int j=0;j<gw.size() && ans;j++){\n\t\t\t\t\tLine l(gb[i],gb[(i+1)%gb.size()]), m(gw[i],gw[(i+1)%gw.size()]);\n\t\t\t\t\tif(intersect_ss(l,m)==true) ans = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(gb.size()>=3){\n\t\t\tfor(int i=0;i<M && ans;i++){\n\t\t\t\tif(contains(gb,w[i])!=0) ans = false;\n\t\t\t}\n\t\t}\n\t\telse if(gw.size()==1){\n\t\t\tif(ccw(gb[0],gb[1],gw[0])==0) ans = false;\n\t\t}\n\t\tif(gw.size()>=3){\n\t\t\tfor(int i=0;i<N && ans;i++){\n\t\t\t\tif(contains(gw,b[i])!=0) ans = false;\n\t\t\t}\n\t\t}\n\t\telse if(gb.size()==1){\n\t\t\tif(ccw(gw[0],gw[1],gb[0])==0) ans = false;\n\t\t}\n\t\tif(ans==true) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a; i<(int)b; i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef complex<double> P;\n\nnamespace std {\n  bool operator < (P const& a, P const& b) {\n    if(real(a) != real(b)) return real(a) < real(b);\n    return imag(a) < imag(b);\n  }\n}\n\ndouble const EPS = 1e-8;\n\n#define prev(G, i) ( G[((i-1)+G.size())%G.size()] )\n#define curr(G, i) ( G[i%G.size()] )\n#define next(G, i) ( G[(i+1)%G.size()] )\n\ndouble dot(P const& a, P const& b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(P const& a, P const& b) {\n  return imag(conj(a)*b);\n}\n\ntypedef vector<P> Polygon;\n/*\nPolygon convex_hull(vector<P> ps) {\n  sort(ps.begin(), ps.end());\n  int N = ps.size(), k = 0;\n  vector<P> qs(N*2);\n  rep(i, N) {\n    while(k > 1 && cross(qs[k-1]-qs[k-2], ps[i]-ps[k-1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  for(int i=N-2, t=k; i>=0; i--) {\n    while(k > t && cross(qs[k-1]-qs[k-2], ps[i]-qs[k-1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n*/\n\nenum { counter_clock_wise=+1, clockwise=-1, cab_online=+2, abc_online=-2, on_segment = 0 };\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if(cross(b, c) > 0) return counter_clock_wise;\n  if(cross(b, c) < 0) return clockwise;\n  if(dot(b, c) < 0) return cab_online;\n  if(norm(b) < norm(c)) return abc_online;\n  return on_segment;\n}\n\nPolygon convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nstruct Line : public vector<P>\n{\n  Line(P const& a, P const& b) {\n    push_back(a), push_back(b);\n  }\n};\n\ntypedef Line Segment;\n\nbool is_intersect_ss(Segment const& s, Segment const& t) {\n  return ( ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) < EPS )\n    && ( ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) < EPS );\n}\n\n// contain: 2, on segment: 1, the other case: 0\nint contains(Polygon const& G, P const& p) {\n  bool x = false;\n  for(int i=0; i<(int)G.size(); i++) {\n    P v1 = curr(G, i)-p, v2 = next(G, i) - p;\n    if( v1.imag() > v2.imag() ) swap(v1, v2);\n    if( v1.imag() <= 0 && 0 < v2.imag() && cross(v1, v2) > 0 ) x = !x;\n    if( cross(v1, v2) == 0 && dot(v1, v2) <= 0 ) return 1;\n  }\n  return (x?2:0);\n}\n\nint main() {\n\n  int N, M;\n  while(cin >> N >> M && (N|M)) {\n    Polygon G1(N), G2(M);\n    rep(i, N) cin >> G1[i].real() >> G1[i].imag(); \n    rep(i, M) cin >> G2[i].real() >> G2[i].imag(); \n    \n    G1 = convex_hull(G1); N = G1.size();\n    G2 = convex_hull(G2); M = G2.size();\n    //    cout << \"convex hull\\n\";\n    bool ok = (!contains(G1, G2[0])) && (!contains(G2, G1[0]));\n    rep(i, N) {\n      rep(j, M) {\n\tSegment s1 = Segment(curr(G1, i), next(G1, i));\n\tSegment s2 = Segment(curr(G2, j), next(G2, j));\n\tif(is_intersect_ss(s1, s2)) { ok = 0; }\n      }\n    }\n    \n    cout << (ok ? \"YES\\n\" : \"NO\\n\");\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\n#include <complex>\ntypedef complex<double> P;\n#define EQ(x, y) (abs((x)-(y)) < EPS)\ndouble dot(P a, P b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\ndouble cross(P a, P b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\nint is_point_on_line(P a, P b, P c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nint is_intersected_l_ls(P a1, P a2, P b1, P b2) {\n    if ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < -EPS )\n        return true;\n    return is_point_on_line(a1, a2, b1) || is_point_on_line(a1, a2, b2);\n}\nint is_intersected_l_ls_strict(P a1, P a2, P b1, P b2) {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < -EPS );\n}\nint is_point_on_ls(P a, P b, P c) {\n    // |a-c| + |c-b| <= |a-b| then true\n    return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n\n\ntypedef vector<P> vp;\n\nbool can_separate(int edge1,int edge2,int parent_o,int parent_t,vp &ours,vp &theirs){\n\tif(parent_o!=-1){\n\t\tif(!is_intersected_l_ls(ours[edge1],ours[edge2],ours[parent_o],theirs[parent_t])){\n\t\t\treturn false;\n\t\t}\n\t}\n\tif(is_point_on_line(ours[edge1],ours[edge2],theirs[parent_t])){\n\t\treturn false;\n\t}\n\tif(parent_o!=-1){\n\t\tREP(i,ours.size()){\n\t\t\tif(i!=parent_o&&i!=edge1&&i!=edge2){\n\t\t\t\tif(is_intersected_l_ls_strict(ours[edge1],ours[edge2],ours[i],ours[parent_o])){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,theirs.size()){\n\t\tif(i!=parent_t){\n\t\t\tif(is_intersected_l_ls(ours[edge1],ours[edge2],theirs[i],theirs[parent_t])){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nnamespace std{\n\tbool operator<(const P &l, const P &r){\n\t\tif(l.real()==r.real()){\n\t\t\treturn l.real()<r.real();\n\t\t}else{\n\t\t\treturn l.imag()<r.imag();\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,m;\n\tint cnt=0;\n\twhile(cin>>n>>m,n|m){\n\t\tcnt++;\n\t\tvp black,white;\n\t\tREP(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tblack.push_back(P(x,y));\n\t\t}\n\t\tREP(i,m){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\twhite.push_back(P(x,y));\n\t\t}\n\n\t\tbool ok=false;\n\t\tbool all_on_line=true;\n\t\tbool scrumbled=false;\n\t\tif(n==1&&m==1){\n\t\t\tok=true;\n\t\t\tgoto show;\n\t\t}else if(n==2&&m==1){\n\t\t\tok=!is_point_on_ls(black[0],black[1],white[0]);\n\t\t\tgoto show;\n\t\t}else if(n==1&&m==2){\n\t\t\tok=!is_point_on_ls(white[0],white[1],black[0]);\n\t\t\tgoto show;\n\t\t}\n\n\t\tsort(ALL(black));\n\t\tsort(ALL(white));\n\t\tREP(i,n+m){\n\t\t\tP ip=(i<n?black[i]:white[i-n]);\n\t\t\tif(!is_point_on_line(black[0],white[0],ip)){\n\t\t\t\tall_on_line=false;\n\t\t\t}\n\t\t}\n\t\tREP(i,m){\n\t\t\tif(black.size()>=2&&is_point_on_ls(black[0],black[black.size()-1],white[i])){\n\t\t\t\tscrumbled=true;\n\t\t\t}\n\t\t}\n\t\tREP(i,n){\n\t\t\tif(white.size()>=2&&is_point_on_ls(white[0],white[white.size()-1],black[i])){\n\t\t\t\tscrumbled=true;\n\t\t\t}\n\t\t}\n\t\tif(all_on_line){\n\t\t\tok=!scrumbled;\n\t\t\tgoto show;\n\t\t}\n\n\t\tREP(i1,n){\n\t\t\tFOR(i2,i1+1,n){\n\t\t\t\tint parent_o=-1;\n\t\t\t\tREP(j,n){\n\t\t\t\t\tif(j!=i1&&j!=i2&&!is_point_on_line(black[i1],black[i2],black[j])){\n\t\t\t\t\t\tparent_o=j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(can_separate(i1,i2,parent_o,0,black,white)){\n\t\t\t\t\tok=true;\n\t\t\t\t\tgoto show;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i1,m){\n\t\t\tFOR(i2,i1+1,m){\n\t\t\t\tint parent_o=-1;\n\t\t\t\tREP(j,m){\n\t\t\t\t\tif(j!=i1&&j!=i2&&!is_point_on_line(white[i1],white[i2],white[j])){\n\t\t\t\t\t\tparent_o=j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(can_separate(i1,i2,parent_o,0,white,black)){\n\t\t\t\t\tok=true;\n\t\t\t\t\tgoto show;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nshow:\n\t\tcout<<(ok?\"YES\":\"NO\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1000000000\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps)return CLOCKWISE;\n  if(dot(a,b)<-eps)return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n// in 2,out 0,on 1\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\n// ??????\nPolygon convex_hull(Polygon s){\n  Polygon g;\n  int n=s.size();\n  if(n<3)return s;\n\n  sort(s.begin(),s.end());\n\n  for(int i=0;i<n;i++){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  for(int i=n-2;i>=0;i--){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  reverse(g.begin(),g.end());\n  g.pop_back();\n  return g;\n}\n\nint main()\n{\n  int n,m;\n\n  while(1){\n    cin>>n>>m;\n    if(n+m==0)return 0;\n    Polygon a,b;\n    a.resize(n);b.resize(m);\n    for(int i=0;i<n;i++)cin>>a[i].x>>a[i].y;\n    for(int i=0;i<m;i++)cin>>b[i].x>>b[i].y;\n    Polygon A=convex_hull(a),B=convex_hull(b);\n    bool flag=true;\n    int x=A.size(),y=B.size();\n    for(int i=0;i<x;i++){\n      for(int j=0;j<y;j++){\n\tif(intersect(Segment(A[i],A[(i+1)%x]),Segment(B[j],B[(j+1)%y])))flag=false;\n      }\n    }\n    for(int i=0;i<m;i++){\n      if(contains(A,b[i])!=0)flag=false;\n    }\n    for(int i=0;i<n;i++){\n      if(contains(B,a[i])!=0)flag=false;\n    }\n    if(flag)cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n\ntypedef long long ll;\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nint n[2];\nvector<vector<P>> p;\n\nbool solve(){\n    vector<double> ths;\n    rep(i,n[0])rep(j,n[1]){\n        P p0=p[0][i], p1=p[1][j];\n        double th=arg(p0-p1);\n        ths.push_back(th);\n    }\n\n    for(double th:ths){\n        auto before = p;\n        rep(i,2)rep(j,n[i]){\n            p[i][j] /= polar(1. ,th);\n        }\n        double M[2]={-INF,-INF}, m[2]={INF,INF};\n        rep(i,2){\n            rep(j,n[i]){\n                M[i] = max(M[i],p[i][j].imag());\n                m[i] = min(m[i],p[i][j].imag());\n            }\n        }\n        if(M[0] < m[1] || M[1] < m[0]) return true;\n        p = before;\n    }\n    return false;\n}\n\nint main(){\n    int c=0;\n    while(cin>>n[0]>>n[1] && n[0]){\n        // cout <<++c << endl;\n        p={{},{}};\n        rep(i,2){\n            p[i].resize(n[i]);\n            rep(j,n[i]){\n                int x,y;\n                cin>>x>>y;\n                p[i][j] = P(x,y);\n            }\n        }\n\n        puts(solve() ? \"YES\" : \"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cassert>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-10\n#define F first\n#define S second\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point\n{\n  public:\n  double x,y;\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nbool isIntersect(Segment s1,Segment s2)\n{\nreturn isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool cmp(const vector<Point> &a,const vector<Point> &b)\n{\n  return a.size() < b.size();\n}\n\nPolygon andrewScan(Polygon s)\n{\n  Polygon u,l;\n  if(s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<s.size();i++)\n    {\n      for(int n=u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--)\n\tu.pop_back();\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3; i>=0 ; i--)\n    {\n      for(int n=l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--)\n\tl.pop_back();\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\nbool check(int p1,int p2,vector<Point> &black,vector<Point> &white)\n{\n  int n = black.size();\n  pair<bool,bool> Left,Right;\n  Left  = pair<bool,bool>(false,false); // F->black, S->white\n  Right = pair<bool,bool>(false,false);\n\n  rep(i,n)\n    {\n      if(i == p1 || i == p2)continue;\n      int res = ccw(black[p1],black[p2],black[i]);\n      if(res == CLOCKWISE) Right.F = true;\n      if(res == COUNTER_CLOCKWISE) Left.F = true;\n    }\n  \n  n = white.size();\n  bool Front = false;\n  bool Back = false;\n  int OnSegment = 0;\n  rep(i,n)\n    {\n      int res = ccw(black[p1],black[p2],white[i]);\n      if(res == CLOCKWISE) Right.S = true;\n      if(res == COUNTER_CLOCKWISE) Left.S = true;\n      if(res == ONLINE_FRONT) Front = true;\n      if(res == ONLINE_BACK) Back = true;\n      if(res == ON_SEGMENT) OnSegment++;\n    }\n\n  //cout << black[p1].x << \",\" << black[p1].y << \" | \" << black[p2].x << \",\" << black[p2].y << endl;\n  //cout << \"Front = \" << Front << \" Back = \" << Back << \" OnSegment = \" << OnSegment << endl;\n  if(Front && Back)return false;\n  if(OnSegment && Front)return false;\n  if(OnSegment && Back)return false;\n  if(OnSegment >= 2)return false;\n  if(Left.F && Left.S)return false;\n  if(Right.F && Right.S)return false;\n  if(Left.S && Right.S)return false;\n  //cout << \"OK\" << endl;\n  return true;\n}\n\nvoid printVP(vector<Point> a)\n{\n  cout << \"printVP-------\" << endl;\n  rep(i,a.size())cout << \"(\" << a[i].x << \",\" << a[i].y << \") \";\n  cout << endl;\n}\n\nbool isParallel(Vector a,Vector b)\n{\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2)\n{\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2)\n{\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\n\nint main()\n{\n  int n,m;\n  while(cin >> n >> m,n|m)\n    {\n      assert(n && m);\n      vector<Point> A(n),B(m);\n      rep(_,n)cin >> A[_].x >> A[_].y;\n      rep(_,m)cin >> B[_].x >> B[_].y;\n\n      vector<Point> black,white;\n      if(A.size() > B.size())\n\tblack = A,white = B;\n      else\n\tblack = B,white = A;\n\n      \n      if(n == 1 && m == 1)\n\t{\n\t  cout << \"YES\" << endl;\n\t  continue;\n\t}\n      \n      if(white.size() == 1)\n\t{\n\t  sort(black.begin(),black.end());\n\t  if(ccw(black[0],black[black.size()-1],white[0]) == ON_SEGMENT)\n\t    {\n\t      cout << \"NO\" << endl;\n\t      continue;\n\t    }\n\t  rep(i,black.size())\n\t    if(ccw(black[i],black[(i+1)%black.size()],white[0]) == ON_SEGMENT)\n\t      {\n\t\tcout << \"NO\" << endl;\n\t\tgoto FX;\n\t      }\n\t  cout << \"YES\" << endl;\n\tFX:;\n\t  continue;\n\t}\n    \n      /*\n      if(black.size() == 2 && white.size() == 2)\n\t{\n\t  if(isIntersect(Segment(black[0],black[1]),Segment(white[0],white[1])))cout << \"NO\" << endl;\n\t  else                                                                  cout << \"YES\" << endl;\n\t  continue;\n\t}\n      */\n\n      bool allPL = true;\n      //vector<Point> gray = black;\n      //rep(i,white.size())gray.push_back(white[i]);\n      rep(i,black.size())\n\t{\n\t  REP(j,i+1,black.size())\n\t    {\n\t      rep(k,white.size())\n\t\t{\n\t\t  REP(l,k+1,white.size())\n\t\t    {\n\t\t      if(!isParallel(Segment(black[i],black[j]),Segment(white[k],white[l])))\n\t\t\t{\n\t\t\t  allPL = false;\n\t\t\t  goto Next;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n    Next:;\n      if(allPL)\n\t{\n\t  int Front = 0;\n\t  int Back = 0;\n\t  int OnSegment = 0;\n\t  rep(i,black.size())\n\t    {\n\t      REP(j,i+1,black.size())\n\t\t{\n\t\t  rep(k,white.size())\n\t\t    {\n\t\t      int res = ccw(black[i],black[j],white[k]);\n\t\t      if(res == ONLINE_FRONT)Front++;\n\t\t      if(res == ONLINE_BACK) Back++;\n\t\t      if(res == ON_SEGMENT)  OnSegment++;\n\t\t    }\t\t\n\t\t}\n\t    }\n\n\t  if(OnSegment)cout << \"NO\" << endl;\n\t  else if(Front && Back)cout << \"NO\" << endl;\t \n\t  else cout << \"YES\" << endl;\n\t  //black.push_back(Point(0,100000));\n\t  continue;\n\t}\t\n\n      int N = black.size();\n      rep(i,N)\n\t{\n\t  REP(j,i+1,N)\n\t    {\n\t      if(check(i,j,black,white))\n\t\t{\n\t\t  //cout << black[i].x << \",\" << black[i].y << \" \" << black[j].x << \",\" << black[j].y << endl;\n\t\t  cout << \"YES\" << endl;\n\t\t  goto F;\n\t\t}\n\t    }\n\t}\n      cout << \"NO\" << endl;\n    F:;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\n\nconst double EPS = 1e-9;\nconst double PI = 6.0 * asin(0.5);\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersect(L s1, L s2){\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\nvector<P> convex_hull(vector<P> v){\n  vector<P> c; \n  sort(v.begin(),v.end());\n  c.assign(v.begin(),v.begin()+2);\n    \n  for(int i=2;i<v.size();i++){\n    P a = c[c.size()-1] - c[c.size()-2];\n    P b = v[i] - c[c.size()-2];\n        \n    while(cross(a,b) > EPS){\n      c.pop_back();\n      if(c.size() < 2) break;\n      a = c[c.size()-1] - c[c.size()-2];\n      b = v[i] - c[c.size()-2];\n    }\n    c.push_back(v[i]);\n  }\n\t\n  int n = c.size();\n  c.push_back(v[v.size()-2]);\n\t\n  for(int i=v.size()-3;i>=0;i--){\n    P a = c[c.size()-1] - c[c.size()-2];\n    P b = v[i] - c[c.size()-2];\n        \n    while(cross(a,b) > EPS){\n      c.pop_back();\n      if(c.size() < n + 1) break;\n      a = c[c.size()-1] - c[c.size()-2];\n      b = v[i] - c[c.size()-2];\n    }\n    c.push_back(v[i]);\n  }\n  c.pop_back();\n  return c;\n}\n\n\nvector<P> p1,p2;\nint n,m;\nint solve(){\n  if(n+m<3) return 1;\n  if(m==1&&n==2) return ccw(p1[0],p1[1],p2[0])!=0;\n  if(n==2&&m==2) return !isIntersect(L(p1[0],p1[2]),L(p2[0],p2[1]));\n\n  if(n<3) return 0;\n  vector<P> t=convex_hull(p1);\n  for(int i=0;i<=(int)t.size();i++){\n    int flg=1;\n    for(int j=0;j<m&&flg;j++)\n      if(ccw(t[i],t[(i+1)%t.size()],p2[j])!=1)flg=0;\n    if(flg) return 1;\n    \n  }\n  return 0;  \n}\n\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)return 0;\n    p1.resize(n),p2.resize(m);\n    for(int i=0,a,b;i<n;i++)cin>>a>>b,p1[i]=P(a,b);\n    for(int i=0,a,b;i<m;i++)cin>>a>>b,p2[i]=P(a,b);\n    int ans=solve();\n    swap(p1,p2);\n    swap(n,m);\n    ans|=solve();\n    cout<<(ans?\"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\n\nconst double EPS = 1e-8;\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\n// ???????????? a,b ???????????¢???\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\n// ????????¨?????????????????????????????????????????????true???\nbool isIntersect(L s1, L s2){\n  \n  //ccw ??????????????????????????¨, ????????????????????´?????????????????¨??????????????????????????????\n  if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\n// ????????¨??????????????????\nbool isIntersectSP(L s, P p){ \n  return abs(s.first-p) + abs(s.second-p) - abs(s.second-s.first) < EPS; \n}\n\nvector<P> convex_hull2(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nint main(){\n  \n  while(1){\n    \n    int n,m;\n    cin>>n>>m;\n    if(!n&&!m)break;\n  \n    vector<P> B(n),W(m);\n  \n    int x,y;\n  \n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      B[i]=P(x,y);\n    }\n\n    for(int i=0;i<m;i++){\n      cin>>x>>y;\n      W[i]=P(x,y);\n    }\n\n    bool ans=true;\n    \n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tif(i==j) continue;\n\t\n\tfor(int k=0;k<m;k++)\n\t  for(int l=0;l<m;l++){\n\t    if(k==l) continue;\n\t    \n\t    if(isIntersect(L(B[i],B[j]),L(W[k],W[l]))) ans=false;\n\t    \n\t  }\n      }\n\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tif(i==j) continue;\n\n\tfor(int k=0;k<m;k++)\n\t  if(isIntersectSP(L(B[i],B[j]),W[k])) ans=false;\n      }\n\n    for(int i=0;i<m;i++)\n      for(int j=0;j<m;j++){\n\tif(i==j) continue;\n\n\tfor(int k=0;k<n;k++)\n\t  if(isIntersectSP(L(W[i],W[j]),B[k])) ans=false;\n      }\n\n    vector<P> B2=convex_hull2(B);\n\n    int f=0,flag=1;\n      \n    for(int i=0;i<B2.size();i++){\n      for(int j=0;j<W.size();j++){\n\tint ip=(i+1)%B2.size();\n\tif(ccw(B2[i],B2[ip],W[j])==-1) flag=0;\n\t//\tcout<<ccw(B2[i],B2[ip],W[j])<<endl;\n      }\n    }\n\n    if(B2.size()>=3&&flag) ans=false;\n    \n    vector<P> W2=convex_hull2(W);\n    \n    f=0;\n    flag=1;\n    \n    for(int i=0;i<W2.size();i++){\n      for(int j=0;j<B.size();j++){\n\tint ip=(i+1)%W2.size();\n\tif(ccw(W2[i],W2[ip],B[j])==-1) flag=0;\n\t//\tcout<<ccw(W2[i],W2[ip],B[j])<<endl;\n      }\n    }\n    \n    if(W2.size()>=3&&flag) ans=false;\n    \n    if(ans) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n      \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#define eps 1e-9\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tdouble add(double a, double b){\n\t\tif(fabs(a+b) < eps * (fabs(a) + fabs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d operator+(vec2d ope){\n\t\treturn vec2d(add(x, ope.x), add(y, ope.y));\n\t}\n\tvec2d operator-(vec2d ope){\n\t\treturn vec2d(add(x, -ope.x), add(y, -ope.y));\n\t}\n\tvec2d operator*(double t){\n\t\treturn vec2d(x*t, y*t);\n\t}\n\tbool operator<(vec2d ope){\n\t\treturn x < ope.x || (x == ope.x && y < ope.y);\n\t}\n\tdouble dot(vec2d ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(vec2d ope){\n\t\treturn add(x*ope.y, -y*ope.x);\n\t}\n};\n\nbool isOnS(vec2d p, vec2d q, vec2d x)\n{\n\treturn (p-x).cross(q-x) == 0 && (p-x).dot(q-x) <= eps;\n}\n\nbool isCross(vec2d p, vec2d q, vec2d r, vec2d s)\n{\n\tif((q-p).cross(s-r) == 0){\n\t\treturn isOnS(p, q, r) || isOnS(p, q, s) || isOnS(r, s, p) || isOnS(r, s, q);\t\n\t}\n\tdouble t = (r-p).cross(s-r) / (q-p).cross(s-r);\n\tvec2d x = p + (q-p)*t;\n\treturn isOnS(p, q, x) && isOnS(r, s, x);\n}\n\nbool isInTriangle(vec2d a, vec2d b, vec2d p)\n{\n\tif(a.cross(b) == 0){\n\t\treturn a.cross(p) == 0;\n\t}\n\tdouble s = a.cross(p) / a.cross(b);\n\tdouble t = p.cross(b) / a.cross(b);\n\t\n\treturn (s >= 0 && t >= 0 && s+t <= 1);\n}\n\nbool isInConvex(vector<vec2d> &vec, vec2d p)\n{\n\tif(vec.size() <= 1) return false;\n\tif(vec.size() == 2){\n\t\treturn isOnS(vec[0], vec[1], p);\n\t}\n\t\n\tfor(int i = 1; i <= vec.size()-2; i++){\n\t\tif(isInTriangle(vec[i] - vec[0], vec[i+1] - vec[0], p - vec[0])) return true;\n\t}\n\treturn false;\n}\n\nint n, m;\nvector<vec2d> bin, win;\nvector<vec2d> black, white;\n\nvoid GrahamScan(vector<vec2d> &vec, vector<vec2d> &poly)\n{\n\tif(vec.size() == 1){\n\t\tpoly = vec;\n\t\treturn;\n\t}\n\t\n\tsort(vec.begin(), vec.end());\n\tpoly.clear();\n\tpoly.resize( 2*vec.size() );\n\t\n\tint top = -1;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\twhile(top >= 1 && (vec[i] - poly[top]).cross(poly[top-1] - poly[top]) <= 0) top--;\n\t\ttop++;\n\t\tpoly[top] = vec[i];\n\t}\n\tfor(int i = vec.size()-2, t = top; i >= 0; i--){\n\t\twhile(t >= top+1 && (vec[i] - poly[top]).cross(poly[top-1] - poly[top]) <= 0) top--;\n\t\ttop++;\n\t\tpoly[top] = vec[i];\n\t}\n\tpoly.resize(top);\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0) break;\n\t\t\n\t\tbin.clear(), win.clear();\n\t\tdouble x, y;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x >> y;\n\t\t\tbin.push_back( vec2d(x, y) );\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin >> x >> y;\n\t\t\twin.push_back( vec2d(x, y) );\n\t\t}\n\t\t\n\t\tGrahamScan(bin, black);\n\t\tGrahamScan(win, white);\n\t\t\n\t\tbool ans = true;\n\t\tfor(int bs = 0; bs < black.size(); bs++){\n\t\t\tfor(int ws = 0; ws < white.size(); ws++){\n\t\t\t\tif(isCross(black[bs], black[(bs+1)%black.size()], white[ws], white[(ws+1)%white.size()])){\n\t\t\t\t\tans = false;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(isInConvex(black, white[0])) ans = false;\n\t\tif(isInConvex(white, black[0])) ans = false;\n\t\t\n\t\tend:;\n\t\tif(ans) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res;\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps){\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d,  c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0,  1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n  int n = ps.size();\n  Polygon Q;\n  REP(i,n) {\n    Point A = ps[i], B = ps[(i+1)%n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n      Q.push_back(is_ll(l, m));\n  }\n  return Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n  for (Point q : ps) if (abs(q - p) < eps) return;\n  ps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n  g[from].push_back((Edge){from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n  int n = p.size(), m = s.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (isis_sp(s[i], p[j]))\n      vec.emplace_back(abs(s[i].a - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      add_edge(g, from, to, abs(p[from] - p[to]));\n    }\n  }\n  return g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n  int n = p.size(), m = c.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n      vec.emplace_back(arg(c[i].p - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      ld angle = vec[j+1].first - vec[j].first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n    if (vec.size() >= 2) {\n      int from = vec.back().second, to = vec.front().first;\n      ld angle = vec.front().first - vec.back().first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n  }\n  return g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n  int N = p.size();\n  polygon.clear();\n  REP(i,1024) REP(j,1024) seg2p[i][j].clear();\n  vector<vector<tuple<ld,int,bool>>> tup(N);\n  REP(i,s.size()) {\n    int a = -1, b = -1;\n    REP(j,N) if (abs(s[i].a - p[j]) < eps) a = j;\n    REP(j,N) if (abs(s[i].b - p[j]) < eps) b = j;\n    assert(a >= 0 && b >= 0);\n    tup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n    tup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n  }\n  REP(i,N) sort(ALL(tup[i]));\n  REP(i,N) {\n    REP(j,tup[i].size()) {\n      ld angle; int pos = j, from = i, to; bool flag;\n      tie(angle, to, flag) = tup[i][j];\n      if (flag) continue;\n      vector<int> ps;\n      while (!flag) {\n        ps.push_back(from);\n        get<2>(tup[from][pos]) = true;\n        seg2p[from][to].push_back(polygon.size());\n        seg2p[to][from].push_back(polygon.size());\n        angle += pi + eps;\n        if (angle > pi) angle -= 2 * pi;\n        auto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n        if (it == tup[to].end()) it = tup[to].begin();\n        from = to; tie(angle, to, flag) = *it;\n        pos = it - tup[from].begin();\n      }\n      polygon.push_back(ps);\n    }\n  }\n  Graph g(polygon.size());\n  REP(i,N) REP(j,i) {\n    if (seg2p[i][j].size() == 2) {\n      int from = seg2p[i][j][0], to = seg2p[i][j][1];\n      g[from].push_back((Edge){from, to});\n      g[to].push_back((Edge){to, from});\n    }\n  }\n  return g;\n}\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n  fprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n  Point v = l.b - l.a;\n  Line m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n  int n = p.size();\n  REP(i,n) draw_segment(Line(p[i], p[(i+1)%n]));\n}\n\nvoid draw_circle(Circle c) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nint main() {\n\tint N, M;\n\twhile ( cin >> N >> M, N || M ) {\n\t\tvector<Point> b, w;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tb.push_back( Point(x, y) );\n\t\t}\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tw.push_back( Point(x, y) );\n\t\t}\n\t\tvector<Line> can;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < M; ++j) {\n\t\t\t\tif (b[i] != w[j]) {\n\t\t\t\t\tcan.push_back(Line(b[i], w[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool f = true;\n\t\tfor (int i = 0; i < N; ++i) for (int j = 0; j < M; ++j) {\n\t\t\tif (b[i] == w[j]) f = false;\n\t\t}\n\t\tbool ans = false;\n\t\tif (f) {\n\t\t\tfor (int i = 0; i < can.size(); ++i) {\n\t\t\t\tLine& l = can[i];\n\t\t\t\tint cntB = 0;\n\t\t\t\tvector<Point> onB;\n\t\t\t\tfor (int j = 0; j < b.size(); ++j) {\n\t\t\t\t\tint c = ccw(l.a, l.b, b[j]);\n\t\t\t\t\tif (c == 1) {\n\t\t\t\t\t\t++cntB;\n\t\t\t\t\t}\n\t\t\t\t\telse if (c == 2 || c == -2 || c == 0) {\n\t\t\t\t\t\tonB.push_back(b[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint cntW = 0;\n\t\t\t\tvector<Point> onW;\n\t\t\t\tfor (int j = 0; j < w.size(); ++j) {\n\t\t\t\t\tint c = ccw(l.a, l.b, w[j]);\n\t\t\t\t\tif (c == 1) {\n\t\t\t\t\t\t++cntW;\n\t\t\t\t\t}\n\t\t\t\t\telse if (c == 2 || c == -2 || c == 0) {\n\t\t\t\t\t\tonW.push_back(w[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((cntB+onB.size() == b.size() && cntW == 0) || (cntB == 0 && cntW+onW.size() == w.size())) {\n\t\t\t\t\tsort(onB.begin(), onB.end());\n\t\t\t\t\tsort(onW.begin(), onW.end());\n\n\t\t\t\t\tvector<Point> c1, C1;\n\t\t\t\t\tc1.push_back(onB[0]);\n\t\t\t\t\tc1.push_back(onB[onB.size()-1]);\n\t\t\t\t\tc1.push_back(onW[0]);\n\t\t\t\t\tc1.push_back(onW[onW.size()-1]);\n\n\t\t\t\t\tvector<Point> c2, C2;\n\t\t\t\t\tc2.push_back(onW[0]);\n\t\t\t\t\tc2.push_back(onW[onW.size()-1]);\n\t\t\t\t\tc2.push_back(onB[0]);\n\t\t\t\t\tc2.push_back(onB[onB.size()-1]);\n\n\t\t\t\t\tC1 = c1, C2 = c2;\n\t\t\t\t\tsort(c1.begin(), c1.end());\n\t\t\t\t\tsort(c2.begin(), c2.end());\n\n\t\t\t\t\tif (c1 == C1 || c2 == C2) {\n\t\t\t\t\t\tans = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n/*\n\t\t\t\t\tbool f = true;\n\t\t\t\t\tfor (int i = 0; i < onB.size(); ++i) {\n\t\t\t\t\t\tfor (int j = 0; j < onB.size(); ++j) {\n\t\t\t\t\t\t\tfor (int k = 0; k < onW.size(); ++k) {\n\t\t\t\t\t\t\t\tif (i != j && ccw(onB[i], onB[j], onW[k]) == 0) {\n\t\t\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < onW.size(); ++i) {\n\t\t\t\t\t\tfor (int j = 0; j < onW.size(); ++j) {\n\t\t\t\t\t\t\tfor (int k = 0; k < onB.size(); ++k) {\n\t\t\t\t\t\t\t\tif (i != j && ccw(onW[i], onW[j], onB[k]) == 0) {\n\t\t\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\tans = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define EPS 1e-8\n\ninline int cmp(const double &x) {\n\tif (x < -EPS) return -1;\n\treturn x > EPS;\n}\n\nstruct point {\n\tdouble x, y;\n\tinline point() {}\n\tinline point (const double &x, const double &y) : x(x), y(y) {}\n\tinline void Read() { scanf(\"%lf%lf\", &x, &y); }\n\tinline point operator+ (const point &p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\tinline point operator- (const point &p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\tinline bool operator== (const point &p) const {\n\t\treturn cmp(x - p.x) == 0 && cmp(y - p.y) == 0;\n\t}\n\tinline bool operator!= (const point &p) const {\n\t\treturn ! (*this == p);\n\t}\n\tinline point operator* (const double &d) const {\n\t\treturn point(x * d, y * d);\n\t}\n\tinline point operator/ (const double &d) const {\n\t\treturn point(x / d, y / d);\n\t}\n};\n\ninline double det(const point &a, const point &b) {\n\treturn a.x * b.y - a.y * b.x; \n}\n\ninline double dot(const point &a, const point &b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\nstruct polygon_convex {\n\tvector<point> P;\n\tinline polygon_convex(const int size = 0) { P.resize(size); }\n};\n\ninline bool comp_less(const point &a, const point &b) {\n\treturn cmp(a.x - b.x) < 0 || cmp(a.x - b.x) == 0 && cmp(a.y - b.y) < 0;\n}\n\npolygon_convex convex_hull(vector<point> &a) {\n\tpolygon_convex res((a.size() << 1) + 5);\n\n\tregister int i = 0, m = 0;\n\tfor(; i < (int)a.size(); ++ i) {\n\t\twhile (m > 1 && cmp(det(res.P[m - 1] - res.P[m - 2], a[i] - res.P[m - 2])) <= 0) {\n\t\t\t-- m;\n\t\t}\n\t\tres.P[m ++] = a[i];\n\t}\n\tregister int k = m;\n\tfor(i = a.size() - 2; i >= 0; -- i) {\n\t\twhile (m > k && cmp(det(res.P[m - 1] - res.P[m - 2], a[i] - res.P[m - 2])) <= 0) {\n\t\t\t-- m;\n\t\t}\n\t\tres.P[m ++] = a[i];\n\t}\n\tres.P.resize(m);\n\tif (a.size() > 1) res.P.resize(m - 1);\n\treturn res;\n}\n\ninline bool PointOnSegment(const point &p, const point &s, const point &t) {\n\treturn cmp(det(p - s, t - s)) == 0 && cmp(dot(p - s, p - t)) <= 0;\n}\n\nbool containOn(const polygon_convex &a, const point &b) {\n\tregister int n = a.P.size();\n\tif(n == 2) {\n\t\treturn PointOnSegment(b, a.P[0], a.P[1]);\n\t}\n#define next(i) ((i + 1) % n)\n\tregister int sign = 0;\n\tregister int i;\n\tfor(i = 0; i < n; ++ i) {\n\t\tint cSign = cmp(det(a.P[i] - b, a.P[next(i)] - b));\n\t\tif(cSign) {\n\t\t\tif(sign) {\n\t\t\t\tif(sign != cSign) return false;\n\t\t\t} else {\n\t\t\t\tsign = cSign;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\ninline bool parallel(const point &xx, const point &xy, const point &yx, const point &yy) {\n\treturn !cmp(det(xx - xy, yx - yy));\n}\n\nbool line_make_point(const point &xx, const point &xy, const point &yx, const point &yy, point &cross) {\n\tif(parallel(xx, xy, yx, yy)) return false;\n\tstatic double s1, s2;\n\ts1 = det(xx - yx, yy - yx);\n\ts2 = det(xy - yx, yy - yx);\n\tcross = (xy * s1 - xx * s2) / (s1 - s2);\n\treturn true;\n}\n\nvector<point> white, black;\n\nint main() {\n\tint n, m;\n\twhile(scanf(\"%d%d\", &n, &m), n || m) {\n\t\tblack.clear(), white.clear();\n\t\tblack.reserve(n), white.reserve(m);\n\t\tregister int i;\n\t\tfor(i = 0; i < n; ++ i) {\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\tblack.push_back(point(x, y));\n\t\t}\n\t\tsort(black.begin(), black.end(), comp_less);\n\t\tblack.erase(unique(black.begin(), black.end()), black.end());\n\t\tfor(i = 0; i < m; ++ i) {\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\twhite.push_back(point(x, y));\n\t\t}\n\t\tsort(white.begin(), white.end(), comp_less);\n\t\twhite.erase(unique(white.begin(), white.end()), white.end());\n\t\tbool ok = true;\n\t\tstatic polygon_convex Black, White;\n\t\tif(white.size() == 1 && black.size() == 1) { puts(white[0] != black[0] ? \"YES\" : \"NO\"); continue; }\n\t\tif(black.size() > 1) {\n\t\t\tBlack = convex_hull(black);\n\t\t\tfor(vector<point>::iterator it = white.begin(); it != white.end(); ++ it) {\n\t\t\t\tif(containOn(Black, *it)) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!ok) {\n\t\t\tputs(\"NO\");\n\t\t\tcontinue;\n\t\t}\n\t\tif(white.size() > 1) {\n\t\t\tWhite = convex_hull(white);\n\t\t\tfor(vector<point>::iterator it = black.begin(); it != black.end(); ++ it) {\n\t\t\t\tif(containOn(White, *it)) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint WSize = White.P.size(), BSize = Black.P.size();\n\t\tregister int j;\n#define nexti(i) ((i + 1) % WSize)\n#define nextj(j) ((j + 1) % BSize)\n#define PW(x) White.P[x]\n#define PB(x) Black.P[x]\n\t\tif(ok)\n\t\t\tfor(i = 0; i < WSize; ++ i){\n\t\t\t\tfor(j = 0; j < BSize; ++ j) {\n\t\t\t\t\tstatic point cross;\n\t\t\t\t\tif(!line_make_point(PW(i), PW(nexti(i)), PB(j), PB(nextj(j)), cross)) {\n\t\t\t\t\t\tif(parallel(PW(i), PB(j), PW(nexti(i)), PB(nextj(j))) && parallel(PW(nexti(i)), PB(j), PW(i), PB(nextj(j))) && (PointOnSegment(PW(i), PB(j), PB(nextj(j))) || PointOnSegment(PW(nexti(i)), PB(j), PB(nextj(j))))) ok = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(PointOnSegment(cross, PW(i), PW(nexti(i))) && PointOnSegment(cross, PB(j), PB(nextj(j)))) ok = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(!ok) break;\n\t\t\t\t}\n\t\t\t\tif(!ok) break;\n\t\t\t}\n\n\t\tputs(ok ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cassert>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-8\n#define F first\n#define S second\nusing namespace std;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point\n{\n  public:\n  double x,y;\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nbool isIntersect(Segment s1,Segment s2)\n{\nreturn isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool cmp(const vector<Point> &a,const vector<Point> &b)\n{\n  return a.size() < b.size();\n}\n\nPolygon andrewScan(Polygon s)\n{\n  Polygon u,l;\n  if(s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<s.size();i++)\n    {\n      for(int n=u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--)\n\tu.pop_back();\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3; i>=0 ; i--)\n    {\n      for(int n=l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--)\n\tl.pop_back();\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\nbool check(int p1,int p2,vector<Point> &black,vector<Point> &white)\n{\n  int n = black.size();\n  pair<bool,bool> Left,Right;\n  Left  = pair<bool,bool>(false,false); // F->black, S->white\n  Right = pair<bool,bool>(false,false);\n\n  rep(i,n)\n    {\n      if(i == p1 || i == p2)continue;\n      int res = ccw(black[p1],black[p2],black[i]);\n      if(res == CLOCKWISE) Right.F = true;\n      if(res == COUNTER_CLOCKWISE) Left.F = true;\n    }\n  \n  n = white.size();\n  rep(i,n)\n    {\n      int res = ccw(black[p1],black[p2],white[i]);\n      if(res == CLOCKWISE) Right.S = true;\n      if(res == COUNTER_CLOCKWISE) Left.S = true;\n    }\n\n  if(Left.F && Left.S)return false;\n  if(Right.F && Right.S)return false;\n  return true;\n}\n\nvoid printVP(vector<Point> a)\n{\n  cout << \"printVP-------\" << endl;\n  rep(i,a.size())cout << \"(\" << a[i].x << \",\" << a[i].y << \") \";\n  cout << endl;\n}\n\nint main()\n{\n  int n,m;\n  while(cin >> n >> m,n|m)\n    {\n      assert(n && m);\n      vector<Point> A(n),B(m);\n      rep(_,n)cin >> A[_].x >> A[_].y;\n      rep(_,m)cin >> B[_].x >> B[_].y;\n\n      vector<Point> black,white;\n      if(A.size() > B.size())\n\tblack = A,white = B;\n      else\n\tblack = B,white = A;\n\n      \n      if(n == 1 && m == 1)\n\t{\n\t  cout << \"YES\" << endl;\n\t  continue;\n\t}\n      \n      if(white.size() == 1)\n\t{\n\t  sort(black.begin(),black.end());\n\t  if(ccw(black[0],black[black.size()-1],white[0]) == ON_SEGMENT)\n\t    {\n\t      cout << \"NO\" << endl;\n\t      continue;\n\t    }\n\t  rep(i,black.size())\n\t    if(ccw(black[i],black[(i+1)%black.size()],white[0]) == ON_SEGMENT)\n\t      {\n\t\tcout << \"NO\" << endl;\n\t\tgoto FX;\n\t      }\n\t  cout << \"YES\" << endl;\n\tFX:;\n\t  continue;\n\t}\n    \n      if(black.size() == 2 && white.size() == 2)\n\t{\n\t  if(isIntersect(Segment(black[0],black[1]),Segment(white[0],white[1])))cout << \"NO\" << endl;\n\t  else                                                                  cout << \"YES\" << endl;\n\t  continue;\n\t}\n    \n      int N = black.size();\n      rep(i,N)\n\t{\n\t  if(check(i,(i+1)%N,black,white))\n\t    {\n\t      cout << \"YES\" << endl;\n\t      goto F;\n\t    }\n\t}\n      cout << \"NO\" << endl;\n    F:;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cassert>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-10\n#define F first\n#define S second\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point\n{\n  public:\n  double x,y;\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nbool isIntersect(Segment s1,Segment s2)\n{\nreturn isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool cmp(const vector<Point> &a,const vector<Point> &b)\n{\n  return a.size() < b.size();\n}\n\nPolygon andrewScan(Polygon s)\n{\n  Polygon u,l;\n  if(s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<s.size();i++)\n    {\n      for(int n=u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--)\n\tu.pop_back();\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3; i>=0 ; i--)\n    {\n      for(int n=l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--)\n\tl.pop_back();\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\nbool check(int p1,int p2,vector<Point> &black,vector<Point> &white)\n{\n  int n = black.size();\n  pair<bool,bool> Left,Right;\n  Left  = pair<bool,bool>(false,false); // F->black, S->white\n  Right = pair<bool,bool>(false,false);\n\n  rep(i,n)\n    {\n      if(i == p1 || i == p2)continue;\n      int res = ccw(black[p1],black[p2],black[i]);\n      if(res == CLOCKWISE) Right.F = true;\n      if(res == COUNTER_CLOCKWISE) Left.F = true;\n    }\n  \n  n = white.size();\n  bool Front = false;\n  bool Back = false;\n  int OnSegment = 0;\n  rep(i,n)\n    {\n      int res = ccw(black[p1],black[p2],white[i]);\n      if(res == CLOCKWISE) Right.S = true;\n      if(res == COUNTER_CLOCKWISE) Left.S = true;\n      if(res == ONLINE_FRONT) Front = true;\n      if(res == ONLINE_BACK) Back = true;\n      if(res == ON_SEGMENT) OnSegment++;\n    }\n\n  //cout << black[p1].x << \",\" << black[p1].y << \" | \" << black[p2].x << \",\" << black[p2].y << endl;\n  //cout << \"Front = \" << Front << \" Back = \" << Back << \" OnSegment = \" << OnSegment << endl;\n  if(Front && Back)return false;\n  if(OnSegment && Front)return false;\n  if(OnSegment && Back)return false;\n  if(OnSegment >= 2)return false;\n  if(Left.F && Left.S)return false;\n  if(Right.F && Right.S)return false;\n  if(Left.S && Right.S)return false;\n  //cout << \"OK\" << endl;\n  return true;\n}\n\nvoid printVP(vector<Point> a)\n{\n  cout << \"printVP-------\" << endl;\n  rep(i,a.size())cout << \"(\" << a[i].x << \",\" << a[i].y << \") \";\n  cout << endl;\n}\n\nbool isParallel(Vector a,Vector b)\n{\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2)\n{\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2)\n{\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isAinB(Polygon A,Polygon B)\n{\n  int N = A.size();\n  int M = B.size();\n  for(int i=0;i<N;i++)\n    {\n      for(int j=0;j<M;j++)\n\t{\n\t  int res = ccw(A[i],A[(i+1)%N],B[j]);\n\t  if(!(res == COUNTER_CLOCKWISE || res == ON_SEGMENT))return false;\n\t}\n    }\n  return true;\n}\n\nint main()\n{\n  int n,m;\n  while(cin >> n >> m,n|m)\n    {\n      assert(n && m);\n      vector<Point> A(n),B(m);\n      rep(_,n)cin >> A[_].x >> A[_].y;\n      rep(_,m)cin >> B[_].x >> B[_].y;\n\n      vector<Point> black,white;\n\n      black = andrewScan(A);\n      white = andrewScan(B);\n\n      int N,M;\n      N = black.size();\n      M = white.size();\n      bool AUTO = false;\n      rep(i,N)\n\t{\n\t  rep(j,M)\n\t    {\n\t      if(isIntersect(Segment(black[i],black[(i+1)%N]),Segment(white[i],white[(i+1)%M])))\n\t\t{\n\t\t  AUTO = true;\n\t\t  goto OUT;\n\t\t}\n\t    }\n\t}\n    OUT:;\n\n      if(AUTO)\n\t{\n\t  cout << \"NO\" << endl;\n\t  continue;\n\t}\n      if(isAinB(black,white))\n\t{\n\t  cout << \"NO\" << endl;\n\t  continue;\n\t}\n      if(isAinB(white,black))\n\t{\n\t  cout << \"NO\" << endl;\n\t  continue;\n\t}\n      cout << \"YES\" << endl;\n\n\n      continue;\n      bool ch = true;\n      \n\n      if(n == 1 && m == 1)\n\t{\n\t  cout << \"YES\" << endl;\n\t  continue;\n\t}\n\n      \n      if(black.size() >= 3 && white.size() == 1)\n\t{\t  \t \n\t  bool aaa = false;\n\t  rep(i,black.size()-2)\n\t    {\n\t      if(!isParallel(Segment(black[i],black[i+1]),Segment(black[i+1],black[i+2])))\n\t\t{\n\t\t  aaa = true;\n\t\t  break;\n\t\t}\n\t    }\n\n\t  if(aaa)\n\t    {\n\t      bool fin = false;\n\t      rep(i,black.size())\n\t\t{\n\t\t  REP(j,i+1,black.size())\n\t\t    {\n\t\t      if(!check(i,j,black,white))\n\t\t\t{\n\t\t\t  cout << \"NO\" << endl;\n\t\t\t  fin = true;\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  if(fin)break;\n\t\t}\n\t      if(!fin)cout << \"YES\" << endl;\n\t      continue;\n\t    }\n\t}\n      \n      /*\n      if(white.size() == 1)\n\t{\n\n\t  sort(black.begin(),black.end());\n\t  if(ccw(black[0],black[black.size()-1],white[0]) == ON_SEGMENT)\n\t    {\n\t      cout << \"NO\" << endl;\n\t      continue;\n\t    }\n\t  rep(i,black.size())\n\t    if(ccw(black[i],black[(i+1)%black.size()],white[0]) == ON_SEGMENT)\n\t      {\n\t\tcout << \"NO\" << endl;\n\t\tgoto FX;\n\t      }\n\t  cout << \"YES\" << endl;\n\tFX:;\n\t  continue;\n\t}\n      */\n  \n\n      \n\tbool allPL = true;\n\t//vector<Point> gray = black;\n\t//rep(i,white.size())gray.push_back(white[i]);\n\trep(i,black.size())\n\t  {\n\t    REP(j,i+1,black.size())\n\t      {\n\t\trep(k,white.size())\n\t\t  {\n\t\t    REP(l,k+1,white.size())\n\t\t      {\n\t\t\tif(!isParallel(Segment(black[i],black[j]),Segment(white[k],white[l])))\n\t\t\t  {\n\t\t\t    allPL = false;\n\t\t\t    goto Next;\n\t\t\t  }\n\t\t      }\n\t\t  }\n\t      }\n\t  }\n      Next:;\n\tif(allPL)\n\t  {\n\t    int Front = 0;\n\t    int Back = 0;\n\t    int OnSegment = 0;\n\t    rep(i,black.size())\n\t      {\n\t\tREP(j,i+1,black.size())\n\t\t  {\n\t\t    rep(k,white.size())\n\t\t      {\n\t\t\tint res = ccw(black[i],black[j],white[k]);\n\t\t\tif(res == ONLINE_FRONT)Front++;\n\t\t\tif(res == ONLINE_BACK) Back++;\n\t\t\tif(res == ON_SEGMENT)  OnSegment++;\n\t\t      }\t\t\n\t\t  }\n\t      }\n\n\t    if(OnSegment)cout << \"NO\" << endl;\n\t    else if(Front && Back)cout << \"NO\" << endl;\t \n\t    else cout << \"YES\" << endl;\n\t \n\t    continue;\n\t  }\t\n\n      \n    \n\t//N = black.size();\n\trep(i,N)\n\t{\n\t  REP(j,i+1,N)\n\t    {\n\t      if(check(i,j,black,white))\n\t\t{\n\t\t  //cout << black[i].x << \",\" << black[i].y << \" \" << black[j].x << \",\" << black[j].y << endl;\n\t\t  cout << \"YES\" << endl;\n\t\t  goto F;\n\t\t}\n\t    }\n\t}\n      cout << \"NO\" << endl;\n    F:;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nstruct Point\n{\n    double x,y;\n    Point (double x=0, double y=0) :x(x),y(y) {}\n    void show() { cout<<\"(\"<<x<<\",\"<<y<<\")\"<<endl; }\n};\ntypedef Point Vector;\n\nbool operator < (const Point& A, const Point& B )\n{\n    return A.x < B.x || (A.x == B.x && A.y < B.y);\n}\nVector operator - ( Point A, Point B) { return Vector(A.x-B.x, A.y-B.y); }\ndouble Cross(Vector A, Vector B) { return A.x*B.y - B.x*A.y; }\n\nconst double eps = 1e-10;\nint dcmp(double x)\n{\n    if(fabs(x) < eps) return 0;\n    return x>0? 1: -1;\n}\n\nint ConvexHull ( Point* p, int n, Point* ch)\n{\n    sort(p, p+n);\n    int m = 0;\n    for(int i = 0; i<n; i++)\n    {\n        while(m > 1 && Cross( ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0) m--;\n        ch[m++] = p[i];\n    }\n    int k = m;\n    for(int i = n-2; i>=0; i--)\n    {\n        while(m > k && Cross( ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0) m--;\n        ch[m++] = p[i];\n    }\n    ///&#36824;要改一下生成多&#36793;形。\n    ch[m++] = ch[0];\n    if(n > 1) m--;\n    return m;\n}\n\nPoint black[120],white[120],cw[120],cb[120];\nint nb,nw,n,m;\n\nvoid reset()\n{\n    memset(black,0,sizeof(black));\n    memset(white,0,sizeof(white));\n    memset(cw,0,sizeof(cw));\n    memset(cb,0,sizeof(cb));\n}\n\nbool SideCross(Point a1, Point a2, Point b1, Point b2)\n{\n    double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1),\n    c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1);\n    return dcmp(c1)*dcmp(c2)<0 && dcmp(c3)*dcmp(c4)<0;\n}\n\nbool pInConvex(Point a, Point* ch, int n)\n{\n    int i;\n    if(n==3)\n    {\n        if(a.x < min(ch[0].x, ch[1].x) || a.x > max(ch[0].x, ch[1].x)) return 0;\n        if(a.y < min(ch[0].y, ch[1].y) || a.y > max(ch[0].y, ch[1].y)) return 0;\n    }\n    for(i=1;i<n;i++)\n    {\n        if(Cross( ch[i]-ch[i-1], a-ch[i-1] ) < 0 ) return 0;\n    }\n    return 1;\n}\n\nint solve()\n{\n    int i,j;\n    if(n==1&&m==1) return 1;\n    else if(n==1)\n    {\n        ///找白子凸包多&#36793;形。判断&#36825;个?子是否在白包内\n        nw=ConvexHull(white, m, cw);\n        if(pInConvex(black[0], cw, nw)) return 0;\n    }\n    else if(m==1)\n    {\n        ///找?子凸包多&#36793;形。判断&#36825;个白子是否在?包内\n        nb=ConvexHull(black, n, cb);\n        if(pInConvex(white[0], cb, nb)) return 0;\n    }\n    else\n    {\n        ///找?白凸包多&#36793;形。判断是否有&#32447;段相交或点在&#21478;一个凸包内。\n        nb=ConvexHull(black, n, cb);\n        nw=ConvexHull(white, m, cw);\n        for(i=1;i<nb;i++)\n        {\n            for(j=1;j<nw;j++)\n                if(SideCross( cb[i], cb[i-1], cw[j] ,cw[j-1] )) return 0;\n        }\n        for(i=0;i<n;i++)\n            if(pInConvex(black[i], cw, nw)) return 0;\n        for(i=0;i<m;i++)\n            if(pInConvex(white[i], cb, nb)) return 0;\n    }\n    return 1;\n}\n\nint main()\n{\n    int i,tx,ty;\n    while(cin>>n>>m,n||m)\n    {\n        reset();\n        for(i=0;i<n;i++)\n        {\n            cin>>tx>>ty;\n            black[i]=Point(tx,ty);\n        }\n        for(i=0;i<m;i++)\n        {\n            cin>>tx>>ty;\n            white[i]=Point(tx,ty);\n        }\n        int ans=solve();\n        if(ans)\n            cout<<\"YES\"<<endl;\n        else\n            cout<<\"NO\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cassert>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-10\n#define F first\n#define S second\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point\n{\n  public:\n  double x,y;\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nbool isIntersect(Segment s1,Segment s2)\n{\nreturn isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool cmp(const vector<Point> &a,const vector<Point> &b)\n{\n  return a.size() < b.size();\n}\n\nPolygon andrewScan(Polygon s)\n{\n  Polygon u,l;\n  if(s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<s.size();i++)\n    {\n      for(int n=u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--)\n\tu.pop_back();\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3; i>=0 ; i--)\n    {\n      for(int n=l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--)\n\tl.pop_back();\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\nbool check(int p1,int p2,vector<Point> &black,vector<Point> &white)\n{\n  int n = black.size();\n  pair<bool,bool> Left,Right;\n  Left  = pair<bool,bool>(false,false); // F->black, S->white\n  Right = pair<bool,bool>(false,false);\n\n  rep(i,n)\n    {\n      if(i == p1 || i == p2)continue;\n      int res = ccw(black[p1],black[p2],black[i]);\n      if(res == CLOCKWISE) Right.F = true;\n      if(res == COUNTER_CLOCKWISE) Left.F = true;\n    }\n  \n  n = white.size();\n  bool Front = false;\n  bool Back = false;\n  int OnSegment = 0;\n  rep(i,n)\n    {\n      int res = ccw(black[p1],black[p2],white[i]);\n      if(res == CLOCKWISE) Right.S = true;\n      if(res == COUNTER_CLOCKWISE) Left.S = true;\n      if(res == ONLINE_FRONT) Front = true;\n      if(res == ONLINE_BACK) Back = true;\n      if(res == ON_SEGMENT) OnSegment++;\n    }\n\n  //cout << black[p1].x << \",\" << black[p1].y << \" | \" << black[p2].x << \",\" << black[p2].y << endl;\n  //cout << \"Front = \" << Front << \" Back = \" << Back << \" OnSegment = \" << OnSegment << endl;\n  if(Front && Back)return false;\n  if(OnSegment && Front)return false;\n  if(OnSegment && Back)return false;\n  if(OnSegment >= 2)return false;\n  if(Left.F && Left.S)return false;\n  if(Right.F && Right.S)return false;\n  //cout << \"OK\" << endl;\n  return true;\n}\n\nvoid printVP(vector<Point> a)\n{\n  cout << \"printVP-------\" << endl;\n  rep(i,a.size())cout << \"(\" << a[i].x << \",\" << a[i].y << \") \";\n  cout << endl;\n}\n\nbool isParallel(Vector a,Vector b)\n{\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2)\n{\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2)\n{\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\n\nint main()\n{\n  int n,m;\n  while(cin >> n >> m,n|m)\n    {\n      assert(n && m);\n      vector<Point> A(n),B(m);\n      rep(_,n)cin >> A[_].x >> A[_].y;\n      rep(_,m)cin >> B[_].x >> B[_].y;\n\n      vector<Point> black,white;\n      if(A.size() > B.size())\n\tblack = A,white = B;\n      else\n\tblack = B,white = A;\n\n      \n      if(n == 1 && m == 1)\n\t{\n\t  cout << \"YES\" << endl;\n\t  continue;\n\t}\n      \n      if(white.size() == 1)\n\t{\n\t  sort(black.begin(),black.end());\n\t  if(ccw(black[0],black[black.size()-1],white[0]) == ON_SEGMENT)\n\t    {\n\t      cout << \"NO\" << endl;\n\t      continue;\n\t    }\n\t  rep(i,black.size())\n\t    if(ccw(black[i],black[(i+1)%black.size()],white[0]) == ON_SEGMENT)\n\t      {\n\t\tcout << \"NO\" << endl;\n\t\tgoto FX;\n\t      }\n\t  cout << \"YES\" << endl;\n\tFX:;\n\t  continue;\n\t}\n    \n      \n      if(black.size() == 2 && white.size() == 2)\n\t{\n\t  if(isIntersect(Segment(black[0],black[1]),Segment(white[0],white[1])))cout << \"NO\" << endl;\n\t  else                                                                  cout << \"YES\" << endl;\n\t  continue;\n\t}\n        \n\n      bool allPL = true;\n      //vector<Point> gray = black;\n      //rep(i,white.size())gray.push_back(white[i]);\n      rep(i,black.size())\n\t{\n\t  REP(j,i+1,black.size())\n\t    {\n\t      rep(k,white.size())\n\t\t{\n\t\t  REP(l,k+1,white.size())\n\t\t    {\n\t\t      if(!isParallel(Segment(black[i],black[j]),Segment(white[k],white[l])))\n\t\t\t{\n\t\t\t  allPL = false;\n\t\t\t  goto Next;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n    Next:;\n      if(allPL)\n\t{\n\t  int Front = 0;\n\t  int Back = 0;\n\t  int OnSegment = 0;\n\t  rep(i,black.size())\n\t    {\n\t      REP(j,i+1,black.size())\n\t\t{\n\t\t  rep(k,white.size())\n\t\t    {\n\t\t      int res = ccw(black[i],black[j],white[k]);\n\t\t      if(res == ONLINE_FRONT)Front++;\n\t\t      if(res == ONLINE_BACK) Back++;\n\t\t      if(res == ON_SEGMENT)  OnSegment++;\n\t\t    }\t\t\n\t\t}\n\t    }\n\n\t  if(OnSegment)cout << \"NO\" << endl;\n\t  else if(Front && Back)cout << \"NO\" << endl;\t \n\t  else cout << \"YES\" << endl;\n\t  //black.push_back(Point(0,100000));\n\t  continue;\n\t}\t\n\n      int N = black.size();\n      rep(i,N)\n\t{\n\t  REP(j,i+1,N)\n\t    {\n\t      if(check(i,j,black,white))\n\t\t{\n\t\t  //cout << black[i].x << \",\" << black[i].y << \" \" << black[j].x << \",\" << black[j].y << endl;\n\t\t  cout << \"YES\" << endl;\n\t\t  goto F;\n\t\t}\n\t    }\n\t}\n      cout << \"NO\" << endl;\n    F:;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Hello. I'm Peter.\n#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<functional>\n#include<cctype>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define peter cout<<\"i am peter\"<<endl\n#define input freopen(\"data.txt\",\"r\",stdin)\n#define randin srand((unsigned int)time(NULL))\n#define INT (0x3f3f3f3f)*2\n#define LL (0x3f3f3f3f3f3f3f3f)*2\n#define gsize(a) (int)a.size()\n#define len(a) (int)strlen(a)\n#define slen(s) (int)s.length()\n#define pb(a) push_back(a)\n#define clr(a) memset(a,0,sizeof(a))\n#define clr_minus1(a) memset(a,-1,sizeof(a))\n#define clr_INT(a) memset(a,INT,sizeof(a))\n#define clr_true(a) memset(a,true,sizeof(a))\n#define clr_false(a) memset(a,false,sizeof(a))\n#define clr_queue(q) while(!q.empty()) q.pop()\n#define clr_stack(s) while(!s.empty()) s.pop()\n#define rep(i, a, b) for (int i = a; i < b; i++)\n#define dep(i, a, b) for (int i = a; i > b; i--)\n#define repin(i, a, b) for (int i = a; i <= b; i++)\n#define depin(i, a, b) for (int i = a; i >= b; i--)\n#define pi acos(-1.0)\n#define eps 1e-10\n#define MOD 1000000007\n#define MAXN\n#define N 200\n#define M\nint dcmp(double x){//蛻、譁ュx豁」雍滓?荳コ0\n    if(fabs(x)<eps) return 0;\n    else if(x<0) return -1;\n    else return 1;\n}\nstruct Point{\n    double x,y;\n    Point(){};\n    Point(double xx,double yy):x(xx),y(yy){};\n    friend bool operator<(const Point A,const Point B){\n        return A.x < B.x || (A.x == B.x && A.y < B.y);\n    }\n};\ntypedef Point Vector;\nvoid readPoint(Point &a){//霎灘?荳?クェ轤ケ\n    cin>>a.x>>a.y;\n}\ndouble sq(double x){//x^2\n    return x*x;\n}\nVector operator +(const Vector a,const Vector b){//荳、蜷鷹?逶ク蜉?    return Vector(a.x+b.x,a.y+b.y);\n}\nVector operator -(const Vector a,const Vector b){//荳、蜷鷹?逶ク蜃?    return Vector(a.x-b.x,a.y-b.y);\n}\nbool operator ==(const Vector a,const Vector b){//蛻、譁ュ荳、轤ケ謌紋ク、蜷鷹?譏ッ蜷ヲ荳??\n    return dcmp(a.x-b.x)==0 && dcmp(a.y-b.y)==0;\n}\ndouble operator *(const Vector a,const Vector b){//荳、蜷鷹?轤ケ荵?    return a.x*b.x+a.y*b.y;\n}\ndouble operator &(const Vector a,const Vector b){//荳、蜷鷹?蜿臥ァッ\n    return a.x*b.y-a.y*b.x;\n}\nVector operator *(const Vector b,const double a){//荳?クェ謨ー*荳?クェ蜷鷹?\n    return Vector(a*b.x,a*b.y);\n}\nVector operator *(const double a,const Vector b){//荳?クェ蜷鷹?*荳?クェ謨ー\n    return Vector(a*b.x,a*b.y);\n}\nPoint MiddlePoint(Point a,Point b){//豎ゆク、轤ケ逧?クュ轤ケ\n    return Point((a.x+b.x)/2,(a.y+b.y)/2);\n}\ndouble Length(Vector b){//豎ゆク?クェ蜷鷹?逧?柄蠎ヲ\n    return sqrt(b*b);\n}\ndouble DistancePointToPoint(Point a,Point b){//豎らせ蛻ー轤ケ逧?裏蜷題キ晉ヲサ\n    return Length(a-b);\n}\ndouble DistancePointToLine(Point p,Point a,Vector v){//豎らせ蛻ー郤ソ逧?裏蜷題キ晉ヲサ\n    Vector w=p-a;\n    return fabs((v&w)/Length(v));\n}\nPoint Point_LineBananaLine(Point p1,Vector v,Point p2,Vector w){//豎ゆク、郤ソ逧?コ、轤ケ(蜑肴署譏ッ荳、蜷鷹?荳榊?郤ソ)\n    Vector u=p1-p2;\n    double t=(w&u)/(v&w);\n    return p1+v*t;\n}\ndouble polarAngle(Vector a,Vector b){//豎ゆク、荳ェ蜷鷹?逧?裏蜷第栫隗?0<=x<=pi)\n    double t=(a*b)/Length(a)/Length(b);\n    return acos(t);\n    //閠径tan2(double y,double x)豎ら噪譏ッ荳?クェ蜷鷹?荳支霓エ逧?怏蜷第栫隗?-pi<x<=pi)\n}\nint ConvexHull(Point *p,int n,Point *ch){\n    sort(p,p+n);\n    int m=0;\n    rep(i,0,n){\n        while(m>1 && dcmp((ch[m-1]-ch[m-2])&(p[i]-ch[m-2]))<=0) m--;\n        ch[m++]=p[i];\n    }\n    int k=m;\n    depin(i,n-2,0){\n        while(m>k && dcmp((ch[m-1]-ch[m-2])&(p[i]-ch[m-2]))<=0) m--;\n        ch[m++]=p[i];\n    }\n    ch[m++] = ch[0];\n    if(n>1) m--;\n    return m;\n}\nbool SegmentStrictlyBananaSegment(Point p1,Point p2,Point w1,Point w2){//蛻、譁ュ荳、郤ソ谿オ譏ッ蜷ヲ荳・譬シ鬥呵負(荳榊桁諡ャ遶ッ轤ケ)\n    double x1=(w2-w1)&(p1-w1);\n    double x2=(w2-w1)&(p2-w1);\n    double x3=(p2-p1)&(w1-p1);\n    double x4=(p2-p1)&(w2-p1);\n    return dcmp(x1)*dcmp(x2)<0 && dcmp(x3)*dcmp(x4)<0;\n}\nbool PointInConvex(Point a, Point* ch, int n){\n    int i;\n    if(n==3){\n        if(a.x < min(ch[0].x, ch[1].x) || a.x > max(ch[0].x, ch[1].x)) return false;\n        if(a.y < min(ch[0].y, ch[1].y) || a.y > max(ch[0].y, ch[1].y)) return false;\n    }\n    for(i=1;i<n;i++){\n        if( ((ch[i]-ch[i-1])&(a-ch[i-1])) < 0) return false;\n    }\n    return true;\n}\nint n,m,num_ch1,num_ch2;\nPoint black[N],ch1[N],white[N],ch2[N];\nint main(){\n//    input;\n    while(~scanf(\"%d%d\",&n,&m) && (n+m)){\n        clr(black);\n        clr(white);\n        clr(ch1);\n        clr(ch2);\n        rep(i,0,n){\n            readPoint(black[i]);\n        }\n        num_ch1=ConvexHull(black,n,ch1);\n        rep(i,0,m){\n            readPoint(white[i]);\n        }\n        num_ch2=ConvexHull(white,m,ch2);\n        bool ok=true;\n        if(n==1 && m==1) ok=true;\n        else if(n==1){\n            if(PointInConvex(black[0],ch2,num_ch2)) ok=false;\n            else ok=true;\n        }\n        else if(m==1){\n            if(PointInConvex(white[0],ch1,num_ch1)) ok=false;\n            else ok=true;\n        }\n        //n!=1 && m!=1\n        else{\n            rep(i,1,num_ch1){\n                if(!ok) break;\n                rep(j,1,num_ch2){\n                    if(SegmentStrictlyBananaSegment(ch1[i],ch1[i-1],ch2[j],ch2[j-1])){\n                        ok=false;\n                        break;\n                    }\n                }\n            }\n            rep(i,0,n){\n                if(!ok) break;\n                if(PointInConvex(black[i],ch2,num_ch2)) ok=false;\n            }\n            rep(i,0,m){\n                if(!ok) break;\n                if(PointInConvex(white[i],ch1,num_ch1)) ok=false;\n            }\n        }\n        printf(\"%s\\n\",ok?\"YES\":\"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\nlong double EPS = (long double)1e-7;\nstruct Point { long double px, py; };\nPoint r1[100], r2[100]; int n, m;\nvector<pair<Point, int>>vec, vec2;\nbool solve(Point a1, Point a2) {\n\tif (a1.px > a2.px)swap(a1, a2);\n\tif (a1.px == a2.px) {\n\t\tint colour = 0; bool r[3] = { false,false,false };\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tif (r[1] == true && r[2] == true)return false;\n\t\t\tif (colour == 0) {\n\t\t\t\tif (vec2[i].first.px < a1.px) { colour = 3 - vec2[i].second; }\n\t\t\t\tif (vec2[i].first.px == a1.px) { r[vec2[i].second] = true; }\n\t\t\t\tif (vec2[i].first.px > a1.px) { colour = vec2[i].second; }\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (colour != 3 - vec2[i].second && vec2[i].first.px < a1.px) { return false; }\n\t\t\t\tif (vec2[i].first.px == a1.px) { r[vec2[i].second] = true; }\n\t\t\t\tif (colour != vec2[i].second && vec2[i].first.px > a1.px) { return false; }\n\t\t\t}\n\t\t}\n\t\tif (r[1] == true && r[2] == true)return false;\n\t\treturn true;\n\t}\n\telse {\n\t\tlong double KT = (a2.py - a1.py) / (a2.px - a1.px);\n\t\tlong double YY = a1.py - a1.px*KT;\n\t\tint colour = 0; bool r[3] = { false,false,false };\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tif (r[1] == true && r[2] == true)return false;\n\t\t\tlong double height = YY + KT*vec2[i].first.px;\n\t\t\tif (colour == 0) {\n\t\t\t\tif (vec2[i].first.py < height) { colour = 3 - vec2[i].second; }\n\t\t\t\tif (vec2[i].first.py == height) { r[vec2[i].second] = true; }\n\t\t\t\tif (vec2[i].first.py > height) { colour = vec2[i].second; }\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (colour != 3 - vec2[i].second && vec2[i].first.py < height) { return false; }\n\t\t\t\tif (vec2[i].first.py == height) { r[vec2[i].second] = true; }\n\t\t\t\tif (colour != vec2[i].second && vec2[i].first.py > height) { return false; }\n\t\t\t}\n\t\t}\n\t\tif (r[1] == true && r[2] == true)return false;\n\t\treturn true;\n\t}\n}\nint main() {\n\twhile (true) {\n\t\tvec.clear(); vec2.clear(); cin >> n >> m; if (n == 0 && m == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> r1[i].px >> r1[i].py; vec2.push_back(make_pair(r1[i], 1));\n\t\t\tfor (long double j = -1.0l; j <= 1.0l; j += 1.0l) {\n\t\t\t\tfor (long double k = -1.0l; k <= 1.0l; k += 1.0l) {\n\t\t\t\t\tvec.push_back(make_pair(Point{ r1[i].px + j*EPS,r1[i].py + k*EPS }, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> r2[i].px >> r2[i].py; vec2.push_back(make_pair(r2[i], 2));\n\t\t\tfor (long double j = -1.0l; j <= 1.0l; j += 1.0l) {\n\t\t\t\tfor (long double k = -1.0l; k <= 1.0l; k += 1.0l) {\n\t\t\t\t\tvec.push_back(make_pair(Point{ r2[i].px + j*EPS,r2[i].py + k*EPS }, 2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans = false;\n\t\tfor (int i = 0; i < vec.size(); i++) {\n\t\t\tfor (int j = i + 1; j < vec.size(); j++) {\n\t\t\t\tif (fabs(vec[i].first.px - vec[j].first.px) + fabs(vec[i].first.py - vec[j].first.py) < EPS * 6)continue;\n\t\t\t\tbool p1 = solve(vec[i].first, vec[j].first);\n\t\t\t\tif (p1 == true) {\n\t\t\t\t\tans = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == true)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Hello. I'm Peter.\n#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<functional>\n#include<cctype>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define peter cout<<\"i am peter\"<<endl\n#define input freopen(\"data.txt\",\"r\",stdin)\n#define randin srand((unsigned int)time(NULL))\n#define INT (0x3f3f3f3f)*2\n#define LL (0x3f3f3f3f3f3f3f3f)*2\n#define gsize(a) (int)a.size()\n#define len(a) (int)strlen(a)\n#define slen(s) (int)s.length()\n#define pb(a) push_back(a)\n#define clr(a) memset(a,0,sizeof(a))\n#define clr_minus1(a) memset(a,-1,sizeof(a))\n#define clr_INT(a) memset(a,INT,sizeof(a))\n#define clr_true(a) memset(a,true,sizeof(a))\n#define clr_false(a) memset(a,false,sizeof(a))\n#define clr_queue(q) while(!q.empty()) q.pop()\n#define clr_stack(s) while(!s.empty()) s.pop()\n#define rep(i, a, b) for (int i = a; i < b; i++)\n#define dep(i, a, b) for (int i = a; i > b; i--)\n#define repin(i, a, b) for (int i = a; i <= b; i++)\n#define depin(i, a, b) for (int i = a; i >= b; i--)\n#define pi acos(-1.0)\n#define eps 1e-10\n#define MOD 1000000007\n#define MAXN\n#define N 10100\n#define M\nint dcmp(double x){//蛻、譁ュx豁」雍滓?荳コ0\n    if(fabs(x)<eps) return 0;\n    else if(x<0) return -1;\n    else return 1;\n}\nstruct Point{\n    double x,y;\n    Point(){};\n    Point(double xx,double yy):x(xx),y(yy){};\n    friend bool operator<(const Point a,const Point b){\n        if(dcmp(a.x-b.x)!=0) return a.x<b.x;\n        else return a.y<b.y;\n    }\n};\ntypedef Point Vector;\nvoid readPoint(Point &a){//霎灘?荳?クェ轤ケ\n    scanf(\"%lf %lf\",&a.x,&a.y);\n}\ndouble sq(double x){//x^2\n    return x*x;\n}\nVector operator +(const Vector a,const Vector b){//荳、蜷鷹?逶ク蜉?    return Vector(a.x+b.x,a.y+b.y);\n}\nVector operator -(const Vector a,const Vector b){//荳、蜷鷹?逶ク蜃?    return Vector(a.x-b.x,a.y-b.y);\n}\nbool operator ==(const Vector a,const Vector b){//蛻、譁ュ荳、轤ケ謌紋ク、蜷鷹?譏ッ蜷ヲ荳??\n    return dcmp(a.x-b.x)==0 && dcmp(a.y-b.y)==0;\n}\ndouble operator *(const Vector a,const Vector b){//荳、蜷鷹?轤ケ荵?    return a.x*b.x+a.y*b.y;\n}\ndouble operator &(const Vector a,const Vector b){//荳、蜷鷹?蜿臥ァッ\n    return a.x*b.y-a.y*b.x;\n}\nVector operator *(const Vector b,const double a){//荳?クェ謨ー*荳?クェ蜷鷹?\n    return Vector(a*b.x,a*b.y);\n}\nVector operator *(const double a,const Vector b){//荳?クェ蜷鷹?*荳?クェ謨ー\n    return Vector(a*b.x,a*b.y);\n}\nPoint MiddlePoint(Point a,Point b){//豎ゆク、轤ケ逧?クュ轤ケ\n    return Point((a.x+b.x)/2,(a.y+b.y)/2);\n}\ndouble Length(Vector b){//豎ゆク?クェ蜷鷹?逧?柄蠎ヲ\n    return sqrt(b*b);\n}\ndouble DistancePointToPoint(Point a,Point b){//豎らせ蛻ー轤ケ逧?裏蜷題キ晉ヲサ\n    return Length(a-b);\n}\ndouble DistancePointToLine(Point p,Point a,Vector v){//豎らせ蛻ー郤ソ逧?裏蜷題キ晉ヲサ\n    Vector w=p-a;\n    return fabs((v&w)/Length(v));\n}\nPoint Point_LineBananaLine(Point p1,Vector v,Point p2,Vector w){//豎ゆク、郤ソ逧?コ、轤ケ(蜑肴署譏ッ荳、蜷鷹?荳榊?郤ソ)\n    Vector u=p1-p2;\n    double t=(w&u)/(v&w);\n    return p1+v*t;\n}\ndouble polarAngle(Vector a,Vector b){//豎ゆク、荳ェ蜷鷹?逧?裏蜷第栫隗?0<=x<=pi)\n    double t=(a*b)/Length(a)/Length(b);\n    return acos(t);\n    //閠径tan2(double y,double x)豎ら噪譏ッ荳?クェ蜷鷹?荳支霓エ逧?怏蜷第栫隗?-pi<x<=pi)\n}\nint ConvexHull(Point *p,int n,Point *ch){\n    sort(p,p+n);\n    int m=0;\n    rep(i,0,n){\n        while(m>1 && dcmp((ch[m-1]-ch[m-2])&(p[i]-ch[m-2]))<=0) m--;\n        ch[m++]=p[i];\n    }\n    int k=m;\n    depin(i,n-2,0){\n        while(m>k && dcmp((ch[m-1]-ch[m-2])&(p[i]-ch[m-2]))<=0) m--;\n        ch[m++]=p[i];\n    }\n    if(n>1) m--;\n    return m;\n}\nbool SegmentStrictlyBananaSegment(Point p1,Point p2,Point w1,Point w2){//蛻、譁ュ荳、郤ソ谿オ譏ッ蜷ヲ荳・譬シ鬥呵負(荳榊桁諡ャ遶ッ轤ケ)\n    double x1=(w2-w1)&(p1-w1);\n    double x2=(w2-w1)&(p2-w1);\n    double x3=(p2-p1)&(w1-p1);\n    double x4=(p2-p1)&(w2-p1);\n    return dcmp(x1)*dcmp(x2)<0 && dcmp(x3)*dcmp(x4)<0;\n}\nbool ConvexHullIntersection(Point *ch1,int t1,Point *ch2,int t2){//蛻、譁ュ蜃ク蛹?弍蜷ヲ逶ク莠、\n    double angle[N],x;\n    int i,j,k,m;\n    if(t1==1) return true;\n    if(t1==2){\n        for(i=0;i<t2;i++){\n            k=dcmp((ch1[1]-ch1[0])&(ch2[i]-ch1[0]));\n            if(k==0&&(ch1[1]-ch1[0])*(ch2[i]-ch1[0])>0){\n                if(Length(ch2[i]-ch1[0])<Length(ch1[1]-ch1[0]))break;\n            }\n        }\n        if(i<t2)return false;\n        if(t2==2 && SegmentStrictlyBananaSegment(ch1[0],ch1[1],ch2[0],ch2[1]))return false;\n        return true;\n    }\n    angle[0]=0;\n    for(i=2;i<t1;i++)\n        angle[i-1]=polarAngle(ch1[1]-ch1[0],ch1[i]-ch1[0]);\n    for(i=0;i<t2;i++)\n    {\n        j=dcmp((ch1[1]-ch1[0])&(ch2[i]-ch1[0]));\n        if(j<0||(j==0&&(ch1[1]-ch1[0])*(ch2[i]-ch1[0])<0))continue;\n        j=dcmp((ch1[t1-1]-ch1[0])&(ch2[i]-ch1[0]));\n        if(j>0||(j==0&&(ch1[t1-1]-ch1[0])*(ch2[i]-ch1[0])<0))continue;\n        x=polarAngle(ch1[1]-ch1[0],ch2[i]-ch1[0]);\n        m=(int)(lower_bound(angle,angle+t1-1,x)-angle);\n        if(m==0)j=0;\n        else j=m-1;\n        k=dcmp((ch1[j+1]-ch2[i])&(ch1[j+2]-ch2[i]));\n        if(k>=0)break;\n    }\n    if(i<t2)return false;\n    return true;\n}\nint n,m,num_ch1,num_ch2;\nPoint black[N],ch1[N],white[N],ch2[N];\nint main(){\n//    input;\n    while(~scanf(\"%d%d\",&n,&m) && (n+m)){\n        rep(i,0,n){\n            readPoint(black[i]);\n        }\n        num_ch1=ConvexHull(black,n,ch1);\n        rep(i,0,m){\n            readPoint(white[i]);\n        }\n        num_ch2=ConvexHull(white,m,ch2);\n        bool ok;\n        if(ConvexHullIntersection(ch1,num_ch1,ch2,num_ch2) && ConvexHullIntersection(ch2,num_ch2,ch1,num_ch1)){\n            ok=true;\n        }\n        else ok=false;\n        printf(\"%s\\n\",ok?\"YES\":\"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n\ntypedef long long ll;\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nint n[2];\nvector<vector<P>> p;\n\nbool solve(){\n    if(n[0]==1 && n[1]==1)return true;\n    vector<double> ths;\n\n    rep(i,n[0])rep(j,i){\n        P &p0=p[0][i], &p1=p[0][j];\n        double th=arg(p0-p1);\n        ths.push_back(th);\n    }\n\n    rep(i,n[1])rep(j,i){\n        P &p0=p[1][i], &p1=p[1][j];\n        double th=arg(p0-p1);\n        ths.push_back(th);\n    }\n\n    for(double th:ths){\n        auto before = p;\n        rep(i,2)rep(j,n[i]){\n            p[i][j] /= polar(1. ,th);\n        }\n        double M[2]={-INF,-INF}, m[2]={INF,INF};\n        rep(i,2){\n            rep(j,n[i]){\n                M[i] = max(M[i],p[i][j].imag());\n                m[i] = min(m[i],p[i][j].imag());\n            }\n        }\n        if(M[0] < m[1] || M[1] < m[0]) return true;\n        p = before;\n    }\n    return false;\n}\n\nint main(){\n    while(cin>>n[0]>>n[1] && n[0]){\n        // cout <<++c << endl;\n        p={{},{}};\n        rep(i,2){\n            p[i].resize(n[i]);\n            rep(j,n[i]){\n                int x,y;\n                cin>>x>>y;\n                p[i][j] = P(x,y);\n            }\n        }\n\n        puts(solve() ? \"YES\" : \"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\n#define EQ(a,b) (abs((a)-(b))<eps)\n\nld dot (P a, P b) { return real(conj(a) * b); }\nld cross (P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n  bool operator<(const P &lhs, const P &rhs) {\n    return lhs.real() == rhs.real() ? lhs.imag() < rhs.imag()\n                                    : lhs.real() < rhs.real();\n  }\n}\n\nstruct L{ P a, b; };\nstruct C { P p; ld r; };\n\n// counter clockwise\nint ccw (P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;   // counter clockwise\n  if (cross(b, c) < -eps) return -1; // clockwise\n  if (dot(b, c) < 0) return 2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line\n  return 0;                          // a--c--b on line\n}\n\nvector<L> tangent_cp(C c, P p) {\n  vector<L> ret;\n  P v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  P v1 = v * P(l / d,  c.r / d);\n  P v2 = v * P(l / d, -c.r / d);\n  ret.push_back((L){p, p + v1});\n  if (l < eps) return ret;\n  ret.push_back((L){p, p + v2});\n  return ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n  vector<L> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    P center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    P out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<L> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    P v = c2.p - c1.p;\n    v /= abs(v);\n    P q1 = c1.p + v * P(0,  1) * c1.r;\n    P q2 = c1.p + v * P(0, -1) * c1.r;\n    ret.push_back((L){q1, q1 + v});\n    ret.push_back((L){q2, q2 + v});\n  }\n  return ret;\n}\n\nint main() {\n  while(1) {\n    int n,m;\n    cin>>n>>m;\n    if(!n) break;\n    VP vb, vw;\n    REP(i,n) {\n      int x,y;\n      cin>>x>>y;\n      vb.emplace_back(x,y);\n    }\n    REP(i,m) {\n      int x,y;\n      cin>>x>>y;\n      vw.emplace_back(x,y);\n    }\n    bool ok = false;\n    ld delta = 1e-4;\n    REP(i,n)REP(j,m) {\n      C ci = {vb[i], delta};\n      C cj = {vw[j], delta};\n      vector<L> vl = tangent_cc(ci, cj);\n      for (L l : vl) {\n        ld ccwi = ccw(l.a, vb[i], l.b);\n        bool valid = true;\n        REP(k,n) {\n          if (ccw(l.a, vb[k], l.b) * ccwi <= 0) valid = false;\n        }\n        REP(k,m) {\n          if (ccw(l.a, vw[k], l.b) * ccwi >= 0) valid = false;\n        }\n        if (valid) ok = true;\n      }\n    }\n    if (ok) {\n      cout << \"YES\" << endl;\n    } else {\n      cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#define eps 1e-9\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tdouble add(double a, double b){\n\t\tif(fabs(a+b) < eps * (fabs(a) + fabs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d operator+(vec2d ope){\n\t\treturn vec2d(add(x, ope.x), add(y, ope.y));\n\t}\n\tvec2d operator-(vec2d ope){\n\t\treturn vec2d(add(x, -ope.x), add(y, -ope.y));\n\t}\n\tvec2d operator*(double t){\n\t\treturn vec2d(x*t, y*t);\n\t}\n\tbool operator<(vec2d ope){\n\t\treturn x < ope.x || (x == ope.x && y < ope.y);\n\t}\n\tdouble dot(vec2d ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(vec2d ope){\n\t\treturn add(x*ope.y, -y*ope.x);\n\t}\n};\n\nbool isOnS(vec2d p, vec2d q, vec2d x)\n{\n\treturn (p-x).cross(q-x) == 0 && (p-x).dot(q-x) <= 0;\n}\n\nbool isCross(vec2d p, vec2d q, vec2d r, vec2d s)\n{\n\tif((q-p).cross(s-r) == 0){\n\t\treturn isOnS(p, q, r) || isOnS(p, q, s) || isOnS(r, s, p) || isOnS(r, s, q);\t\n\t}\n\tdouble t = (r-p).cross(s-r) / (q-p).cross(s-r);\n\tvec2d x = p + (q-p)*t;\n\treturn isOnS(p, q, x) && isOnS(r, s, x);\n}\n\nbool isInTriangle(vec2d a, vec2d b, vec2d p)\n{\n\tif(a.cross(b) == 0) return false;\n\tdouble s = a.cross(p) / a.cross(b);\n\tdouble t = p.cross(b) / a.cross(b);\n\t\n\treturn (s >= 0 && t >= 0 && s+t <= 1);\n}\n\nbool isInConvex(vector<vec2d> &vec, vec2d p)\n{\n\tif(vec.size() <= 2) return false;\n\tfor(int i = 1; i <= vec.size()-2; i++){\n\t\tif(isInTriangle(vec[i] - vec[0], vec[i+1] - vec[0], p - vec[0])) return true;\n\t}\n\treturn false;\n}\n\nint n, m;\nvector<vec2d> bin, win;\nvector<vec2d> black, white;\n\nvoid GrahamScan(vector<vec2d> &vec, vector<vec2d> &poly)\n{\n\tif(vec.size() == 1){\n\t\tpoly = vec;\n\t\treturn;\n\t}\n\t\n\tsort(vec.begin(), vec.end());\n\tpoly.clear();\n\tpoly.resize( 2*vec.size() );\n\t\n\tint top = -1;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\twhile(top >= 1 && (vec[i] - poly[top]).cross(poly[top-1] - poly[top]) <= 0) top--;\n\t\ttop++;\n\t\tpoly[top] = vec[i];\n\t}\n\tfor(int i = vec.size()-2, t = top; i >= 0; i--){\n\t\twhile(t >= top+1 && (vec[i] - poly[top]).cross(poly[top-1] - poly[top]) <= 0) top--;\n\t\ttop++;\n\t\tpoly[top] = vec[i];\n\t}\n\tpoly.resize(top);\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0) break;\n\t\t\n\t\tbin.clear(), win.clear();\n\t\tdouble x, y;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x >> y;\n\t\t\tbin.push_back( vec2d(x, y) );\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin >> x >> y;\n\t\t\twin.push_back( vec2d(x, y) );\n\t\t}\n\t\t\n\t\tGrahamScan(bin, black);\n\t\tGrahamScan(win, white);\n\t\t\n\t\tbool ans = true;\n\t\tfor(int bs = 0; bs < black.size(); bs++){\n\t\t\tfor(int bt = 0; bt < black.size(); bt++){\n\t\t\t\tif(bs > bt) continue;\n\t\t\t\tfor(int ws = 0; ws < white.size(); ws++){\n\t\t\t\t\tfor(int wt = 0; wt < white.size(); wt++){\n\t\t\t\t\t\tif(ws > wt) continue;\n\t\t\t\t\t\tif(isCross(black[bs], black[bt], white[ws], white[wt])){\n\t\t\t\t\t\t\tans = false;\n\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(isInConvex(black, white[0])) ans = false;\n\t\tif(isInConvex(white, black[0])) ans = false;\n\t\t\n\t\tend:;\n\t\tif(ans) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<complex>\n#define Re real()\n#define Im imag()\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\ntypedef vector<Point> Polygon;\nconst double eps = 1e-7;\n\nPoint black[105], white[105];\nPolygon bp, wp;\nint n, m, bpl, wpl;\n\nbool cmp(Point a, Point b)\n{\n    if(fabs(a.Re - b.Re) < eps) return a.Im < b.Im;\n    else return a.Re < b.Re;\n}\n\ndouble cross(const Point& a, const Point& b)\n{\n    return (conj(a) * b).Im;\n}\n\ndouble dot(const Point& a, const Point& b)\n{\n    return (conj(a) * b).Re;\n}\n\nvoid convex_hull()\n{\n    bp.resize(2 * n);\n    bpl = 0;\n    for(int i = 0; i < n; i++)\n    {\n        while(bpl > 1 && cross(bp[bpl - 1] - bp[bpl - 2], black[i] - bp[bpl - 1]) < 0) bpl--;\n        bp[bpl++] = black[i];\n    }\n    for(int i = n - 2, t = bpl; i >= 0; i--)\n    {\n        while(bpl > t && cross(bp[bpl - 1] - bp[bpl - 2], black[i] - bp[bpl - 1]) < 0) bpl--;\n        bp[bpl++] = black[i];\n    }\n    bp.resize(bpl - 1);\n    wp.resize(2 * m);\n    wpl = 0;\n    for(int i = 0; i < m; i++)\n    {\n        while(wpl > 1 && cross(wp[wpl - 1] - wp[wpl - 2], white[i] - wp[wpl - 1]) < 0) wpl--;\n        wp[wpl++] = white[i];\n    }\n    for(int i = m - 2, t = wpl; i >= 0; i--)\n    {\n        while(wpl > t && cross(wp[wpl - 1] - wp[wpl - 2], white[i] - wp[wpl - 1]) < 0) wpl--;\n        wp[wpl++] = white[i];\n    }\n    wp.resize(wpl - 1);\n}\n\nint ccw(Point& a, Point& b, Point& c)\n{\n    Point t1 = b - a, t2 = c - a;\n    if(cross(t1, t2) > 0)   return +1;        // counter clockwise\n    if(cross(t1, t2) < 0)   return -1;        // clockwise\n    if(dot(t1, t2) < 0)     return +2;        // c--a--b on line\n    if(norm(t1) < norm(t2)) return -2;        // a--b--c on line\n    return 0;\n}\n\nbool is_point_intersaction(Point a, pair <Point, Point> b)\n{\n    return (cross(b.first - a, b.second - a) == 0);\n}\n\nbool isintersaction(pair <Point, Point> a, pair <Point, Point> b)\n{\n    return (ccw(b.first, b.second, a.first) * ccw(b.first, b.second, a.second) <= 0 && ccw(a.first, a.second, b.first) * ccw(a.first, a.second, b.second) <= 0);\n}\n\n// 0 --- out of the polygon, 1 -- on the polygon, 2 -- in the polygon\nint checkin(const Point& t, Polygon s)\n{\n    int cnt = 0;\n    for(int i = 0; i < s.size(); i++)\n    {\n        Vector v1 = s[i] - t, v2 = s[(i + 1) % s.size()] - t;\n        if(v1.Im > v2.Im) swap(v1, v2);\n        if(v1.Im <= 0 && v2.Im > 0 && cross(v1, v2) < 0) cnt ^= 1;\n        if(cross(v1, v2) == 0 && dot(v1, v2) <= 0) return 1;\n    }\n    return cnt ? 2 : 0;\n}\n\nbool check()\n{\n    int flag = 0, f1 = 0, f2 = 0, f3 = 0;\n    for(int i = 0; i < bp.size(); i++)\n        if(checkin(bp[i], wp) == 1 || checkin(bp[i], wp) == 2) f1 = 1;\n    for(int i = 0; i < wp.size(); i++)\n        if(checkin(wp[i], bp) == 1 || checkin(wp[i], bp) == 2) f2 = 1;\n    flag = f1 | f2;\n    if(flag == 1) return false;\n    else\n    {\n        for(int i = 0; i < bp.size(); i++)\n        {\n            for(int j = 0; j < wp.size(); j++)\n            {\n                if(isintersaction(make_pair(bp[i], bp[(i+1)%bp.size()]), make_pair(wp[j], wp[(j+1)%wp.size()])))\n                    return false;\n            }\n        }\n        return true;\n    }\n}\n\nint main()\n{\n    //freopen(\"1298-input.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    while(~scanf(\"%d%d\", &n, &m), n + m)\n    {\n        for(int i = 0; i < n; i++)\n        {\n            double tx, ty;\n            scanf(\"%lf %lf\", &tx, &ty);\n            black[i] = Point(tx, ty);\n        }\n        for(int i = 0; i < m; i++)\n        {\n            double tx, ty;\n            scanf(\"%lf %lf\", &tx, &ty);\n            white[i] = Point(tx, ty);\n        }\n        if(n >= 3 || m >= 3)\n        {\n            convex_hull();\n            if(check()) printf(\"YES\\n\");\n            else printf(\"NO\\n\");\n        }\n        else if(n == 1 && m == 1)\n            printf(\"YES\\n\");\n        else if(n == 1 && m == 2)\n        {\n            bool flag = is_point_intersaction(black[0], make_pair(white[0], white[1]));\n            if(flag) printf(\"NO\\n\");\n            else printf(\"YES\\n\");\n        }\n        else if(n == 2 && m == 1)\n        {\n            bool flag = is_point_intersaction(white[0], make_pair(black[0], black[1]));\n            if(flag) printf(\"NO\\n\");\n            else printf(\"YES\\n\");\n        }\n        else if(n == 2 && m == 2)\n        {\n            bool flag = isintersaction(make_pair(white[0], white[1]), make_pair(black[0], black[1]));\n            if(flag) printf(\"NO\\n\");\n            else printf(\"YES\\n\");\n        }\n    }\n    return 0;\n}\n/*\n3 3\n2813 1640\n2583 2892\n2967 1916\n541 3562\n9298 3686\n7443 7921\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res;\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps){\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d,  c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0,  1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n  int n = ps.size();\n  Polygon Q;\n  REP(i,n) {\n    Point A = ps[i], B = ps[(i+1)%n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n      Q.push_back(is_ll(l, m));\n  }\n  return Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n  for (Point q : ps) if (abs(q - p) < eps) return;\n  ps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n  g[from].push_back((Edge){from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n  int n = p.size(), m = s.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (isis_sp(s[i], p[j]))\n      vec.emplace_back(abs(s[i].a - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      add_edge(g, from, to, abs(p[from] - p[to]));\n    }\n  }\n  return g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n  int n = p.size(), m = c.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n      vec.emplace_back(arg(c[i].p - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      ld angle = vec[j+1].first - vec[j].first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n    if (vec.size() >= 2) {\n      int from = vec.back().second, to = vec.front().first;\n      ld angle = vec.front().first - vec.back().first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n  }\n  return g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n  int N = p.size();\n  polygon.clear();\n  REP(i,1024) REP(j,1024) seg2p[i][j].clear();\n  vector<vector<tuple<ld,int,bool>>> tup(N);\n  REP(i,s.size()) {\n    int a = -1, b = -1;\n    REP(j,N) if (abs(s[i].a - p[j]) < eps) a = j;\n    REP(j,N) if (abs(s[i].b - p[j]) < eps) b = j;\n    assert(a >= 0 && b >= 0);\n    tup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n    tup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n  }\n  REP(i,N) sort(ALL(tup[i]));\n  REP(i,N) {\n    REP(j,tup[i].size()) {\n      ld angle; int pos = j, from = i, to; bool flag;\n      tie(angle, to, flag) = tup[i][j];\n      if (flag) continue;\n      vector<int> ps;\n      while (!flag) {\n        ps.push_back(from);\n        get<2>(tup[from][pos]) = true;\n        seg2p[from][to].push_back(polygon.size());\n        seg2p[to][from].push_back(polygon.size());\n        angle += pi + eps;\n        if (angle > pi) angle -= 2 * pi;\n        auto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n        if (it == tup[to].end()) it = tup[to].begin();\n        from = to; tie(angle, to, flag) = *it;\n        pos = it - tup[from].begin();\n      }\n      polygon.push_back(ps);\n    }\n  }\n  Graph g(polygon.size());\n  REP(i,N) REP(j,i) {\n    if (seg2p[i][j].size() == 2) {\n      int from = seg2p[i][j][0], to = seg2p[i][j][1];\n      g[from].push_back((Edge){from, to});\n      g[to].push_back((Edge){to, from});\n    }\n  }\n  return g;\n}\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n  fprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n  Point v = l.b - l.a;\n  Line m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n  int n = p.size();\n  REP(i,n) draw_segment(Line(p[i], p[(i+1)%n]));\n}\n\nvoid draw_circle(Circle c) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nint main() {\n\tint N, M;\n\twhile ( cin >> N >> M, N || M ) {\n\t\tvector<Point> b, w;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\t\tb.push_back( Point(x, y) );\n\t\t}\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\t\tw.push_back( Point(x, y) );\n\t\t}\n\t\tsort(b.begin(), b.end());\n\t\tsort(w.begin(), w.end());\n\n\t\tbool ans = false;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < M; ++j) {\n\t\t\t\tif (b[i] != w[j]) {\n\t\t\t\t\tLine l(b[i], w[j]);\n\t\t\t\t\tint cntB = 0;\n\t\t\t\t\tvector<Point> onB;\n\t\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\t\tint c = ccw(l.a, l.b, b[k]);\n\t\t\t\t\t\tif (c == 1) {\n\t\t\t\t\t\t\t++cntB;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (c == 2 || c == -2 || c == 0) {\n\t\t\t\t\t\t\tonB.push_back(b[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint cntW = 0;\n\t\t\t\t\tvector<Point> onW;\n\t\t\t\t\tfor (int k = 0; k < M; ++k) {\n\t\t\t\t\t\tint c = ccw(l.a, l.b, w[k]);\n\t\t\t\t\t\tif (c == 1) {\n\t\t\t\t\t\t\t++cntW;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (c == 2 || c == -2 || c == 0) {\n\t\t\t\t\t\t\tonW.push_back(w[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ((cntB+onB.size() == N && cntW == 0) || (cntB == 0 && cntW+onW.size() == M)) {\n\t\t\t\t\t\tif (!((onW[0] < onB[0] && onB[0] < onW[onW.size()-1]) || (onW[0] < onB[onB.size()-1] && onB[onB.size()-1] < onW[onW.size()-1])\n\t\t\t\t\t\t\t|| (onB[0] < onW[0] && onW[0] < onB[onB.size()-1]) || (onB[0] < onW[onW.size()-1] && onW[onW.size()-1] < onB[onB.size()-1])) ) {\n\t\t\t\t\t\t\tans = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n/*\n\t\t\t\t\t\tbool f = true;\n\t\t\t\t\t\tfor (int i = 0; i < onB.size(); ++i) {\n\t\t\t\t\t\t\tfor (int j = 0; j < onB.size(); ++j) {\n\t\t\t\t\t\t\t\tfor (int k = 0; k < onW.size(); ++k) {\n\t\t\t\t\t\t\t\t\tif (i != j && ccw(onB[i], onB[j], onW[k]) == 0) {\n\t\t\t\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int i = 0; i < onW.size(); ++i) {\n\t\t\t\t\t\t\tfor (int j = 0; j < onW.size(); ++j) {\n\t\t\t\t\t\t\t\tfor (int k = 0; k < onB.size(); ++k) {\n\t\t\t\t\t\t\t\t\tif (i != j && ccw(onW[i], onW[j], onB[k]) == 0) {\n\t\t\t\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (f) {\n\t\t\t\t\t\t\tans = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n*/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// ------ Class ------ //\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tbool operator==(const Point& p) const { return px == p.px && py == p.py; }\n\tbool operator!=(const Point& p) const { return px != p.px || py != p.py; }\n\tbool operator<(const Point& p) const { return px < p.px ? true : (px == p.px && py < p.py); }\n\tbool operator>(const Point& p) const { return px > p.px ? true : (px == p.px && py > p.py); }\n\tbool operator<=(const Point& p) const { return !(Point(px, py) > p); }\n\tbool operator>=(const Point& p) const { return !(Point(px, py) < p); }\n\tPoint operator+(const Point& p) const { return Point(px + p.px, py + p.py); }\n\tPoint operator-(const Point& p) const { return Point(px - p.px, py - p.py); }\n\tPoint operator/(long double d) const { return Point(px / d, py / d); }\n\tfriend Point operator*(const Point p, long double d) { return Point(p.px * d, p.py * d); }\n\tfriend Point operator*(long double d, const Point& p) { return p * d; }\n\tPoint& operator+=(const Point& p1) { px += p1.px, py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px, py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d, py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d, py /= d; return *this; }\n};\n\n// ------ Functions ------ //\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint pol(long double r, long double d) { return Point(cosl(d) * r, sinl(d) * r); }\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nvector<Point> convex_hull(vector<Point> v) {\n\tif (v.size() < 3) return v;\n\tsort(v.begin(), v.end());\n\tvector<Point> u = { v[0], v[1] }, l = { v[v.size() - 1], v[v.size() - 2] };\n\tfor (int i = 2; i < v.size(); i++) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], v[i]) >= 0; n--) u.pop_back();\n\t\tu.push_back(v[i]);\n\t}\n\tfor (int i = v.size() - 3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], v[i]) >= 0; n--) l.pop_back();\n\t\tl.push_back(v[i]);\n\t}\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\n// ------ Main ------ //\nint n, m; vector<Point> v1, v2, v3, v4;\nbool ok(int i) {\n\tint u = (i + 1) % v3.size();\n\tfor (int j = 0; j < v4.size(); j++) {\n\t\tif (abs(ccw(v3[i], v3[u], v4[j])) != 1) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tfor (int j = 0; j < v3.size(); j++) {\n\t\tif (i == j || u == j) continue;\n\t\tfor (int k = 0; k < v4.size(); k++) {\n\t\t\tif (ccw(v3[i], v3[u], v3[j]) == ccw(v3[i], v3[u], v4[k])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < v4.size(); j++) {\n\t\tfor (int k = j + 1; k < v4.size(); k++) {\n\t\t\tif (ccw(v3[i], v3[u], v4[j]) != ccw(v3[i], v3[u], v4[k])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\twhile (cin >> n >> m, n + m) {\n\t\tv1.resize(n), v2.resize(m);\n\t\tfor (int i = 0; i < n; i++) cin >> v1[i].px >> v1[i].py;\n\t\tfor (int i = 0; i < m; i++) cin >> v2[i].px >> v2[i].py;\n\t\tv3 = convex_hull(v1), v4 = convex_hull(v2);\n\t\tint x = 0;\n\t\tif (v3.size() == 1 && v4.size() == 1) x = 1;\n\t\tif (v3.size() > 1) {\n\t\t\tint w = ccw(v3[0], v3[1], v4[0]);\n\t\t\tif (abs(w) == 2) {\n\t\t\t\tint f = 1;\n\t\t\t\tfor (int i = 1; i < v4.size(); i++) {\n\t\t\t\t\tif (ccw(v3[0], v3[1], v4[i]) != w) f = 0;\n\t\t\t\t}\n\t\t\t\tif (f) x = 1;\n\t\t\t}\n\t\t}\n\t\tif (v4.size() > 1) {\n\t\t\tint w = ccw(v4[0], v4[1], v3[0]);\n\t\t\tif (abs(w) == 2) {\n\t\t\t\tint f = 1;\n\t\t\t\tfor (int i = 1; i < v3.size(); i++) {\n\t\t\t\t\tif (ccw(v4[0], v4[1], v3[i]) != w) f = 0;\n\t\t\t\t}\n\t\t\t\tif (f) x = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < v3.size(); i++) {\n\t\t\tif (ok(i)) x = 1;\n\t\t}\n\t\tswap(v3, v4);\n\t\tfor (int i = 0; i < v4.size(); i++) {\n\t\t\tif (ok(i)) x = 1;\n\t\t}\n\t\tcout << (x ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#define eps 1e-9\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tdouble add(double a, double b){\n\t\tif(fabs(a+b) < eps * (fabs(a) + fabs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d operator+(vec2d ope){\n\t\treturn vec2d(add(x, ope.x), add(y, ope.y));\n\t}\n\tvec2d operator-(vec2d ope){\n\t\treturn vec2d(add(x, -ope.x), add(y, -ope.y));\n\t}\n\tvec2d operator*(double t){\n\t\treturn vec2d(x*t, y*t);\n\t}\n\tbool operator<(vec2d ope){\n\t\treturn x < ope.x || (x == ope.x && y < ope.y);\n\t}\n\tdouble dot(vec2d ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(vec2d ope){\n\t\treturn add(x*ope.y, -y*ope.x);\n\t}\n};\n\nbool isOnS(vec2d p, vec2d q, vec2d x)\n{\n\treturn (p-x).cross(q-x) == 0 && (p-x).dot(q-x) <= eps;\n}\n\nbool isCross(vec2d p, vec2d q, vec2d r, vec2d s)\n{\n\tif((q-p).cross(s-r) == 0){\n\t\treturn isOnS(p, q, r) || isOnS(p, q, s) || isOnS(r, s, p) || isOnS(r, s, q);\t\n\t}\n\tdouble t = (r-p).cross(s-r) / (q-p).cross(s-r);\n\tvec2d x = p + (q-p)*t;\n\treturn isOnS(p, q, x) && isOnS(r, s, x);\n}\n\nbool isInTriangle(vec2d a, vec2d b, vec2d p)\n{\n\tif(a.cross(b) == 0) return false;\n\tdouble s = a.cross(p) / a.cross(b);\n\tdouble t = p.cross(b) / a.cross(b);\n\t\n\treturn (s >= 0 && t >= 0 && s+t <= 1);\n}\n\nbool isInConvex(vector<vec2d> &vec, vec2d p)\n{\n\tif(vec.size() <= 1) return false;\n\tif(vec.size() == 2){\n\t\treturn isOnS(vec[0], vec[1], p);\n\t}\n\t\n\tfor(int i = 1; i <= vec.size()-2; i++){\n\t\tif(isInTriangle(vec[i] - vec[0], vec[i+1] - vec[0], p - vec[0])) return true;\n\t}\n\treturn false;\n}\n\nint n, m;\nvector<vec2d> bin, win;\nvector<vec2d> black, white;\n\nvoid GrahamScan(vector<vec2d> &vec, vector<vec2d> &poly)\n{\n\tif(vec.size() == 1){\n\t\tpoly = vec;\n\t\treturn;\n\t}\n\t\n\tsort(vec.begin(), vec.end());\n\tpoly.clear();\n\tpoly.resize( 2*vec.size() );\n\t\n\tint top = -1;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\twhile(top >= 1 && (vec[i] - poly[top]).cross(poly[top-1] - poly[top]) <= 0) top--;\n\t\ttop++;\n\t\tpoly[top] = vec[i];\n\t}\n\tfor(int i = vec.size()-2, t = top; i >= 0; i--){\n\t\twhile(t >= top+1 && (vec[i] - poly[top]).cross(poly[top-1] - poly[top]) <= 0) top--;\n\t\ttop++;\n\t\tpoly[top] = vec[i];\n\t}\n\tpoly.resize(top);\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0) break;\n\t\t\n\t\tbin.clear(), win.clear();\n\t\tdouble x, y;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x >> y;\n\t\t\tbin.push_back( vec2d(x, y) );\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin >> x >> y;\n\t\t\twin.push_back( vec2d(x, y) );\n\t\t}\n\t\t\n\t\tGrahamScan(bin, black);\n\t\tGrahamScan(win, white);\n\t\t\n\t\tbool ans = true;\n\t\tfor(int bs = 0; bs < black.size(); bs++){\n\t\t\tfor(int ws = 0; ws < white.size(); ws++){\n\t\t\t\tif(isCross(black[bs], black[(bs+1)%black.size()], white[ws], white[(ws+1)%white.size()])){\n\t\t\t\t\tans = false;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(isInConvex(black, white[0])) ans = false;\n\t\tif(isInConvex(white, black[0])) ans = false;\n\t\t\n\t\tend:;\n\t\tif(ans) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#define eps 1e-8\n#define LL long long\nusing namespace std;\ntypedef struct point {\n    LL x,y;\n    point(LL x=0,LL y=0):x(x),y(y) { }\n} Vector;\nVector operator  + (Vector A,Vector B) {\n    return Vector(A.x+B.x,A.y+B.y);\n}\nVector operator  -  (point A,point B) {\n    return Vector(A.x-B.x,A.y-B.y);\n}\nVector operator  *  (Vector A,double p) {\n    return Vector(A.x*p,A.y*p);\n}\nVector operator  /  (Vector A,double p) {\n    return Vector(A.x/p,A.y/p);\n}\nLL xmult(point a,point b,point c) {\n    return (a.x-c.x)*(b.y-c.y)-(a.y-c.y)*(b.x-c.x);\n}\nLL multi(point a,point b,point c) {\n    return (b.x-a.x)*(c.x-a.x)+(b.y-a.y)*(c.y-a.y);\n}\nint dcmp(double x) {\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n\nbool cmp(point a,point b) {\n    if (a.y<b.y) return 1;\n    else if (a.y==b.y&&a.x<b.x) return 1;\n    else return 0;\n}\nint convex(point *p,point *con,int len) {\n    sort(p,p+len,cmp);\n    int top;\n    con[0]=p[0],con[1]=p[1],top=1;\n    for (int i=2; i<len; i++) {\n        while (xmult(con[top],p[i],con[top-1])<0&&top>0) top--;\n        con[++top]=p[i];\n    }\n    int top1=top;\n    con[++top]=p[len-2];\n    for (int i=len-3; i>=0; i--) {\n        while (xmult(con[top],p[i],con[top-1])<0&&top>top1) top--;\n        con[++top]=p[i];\n    }\n    return top;\n}\nLL area(point *p,int len) {\n    LL ans=0;\n    for (int i=2; i<len; i++) ans+=xmult(p[i-1],p[i],p[i-2]);\n    return ans;\n}\nbool SegmentProperIntersection(point a1,point a2,point b1,point b2) {\n    double c1=xmult(a2,b1,a1),c2=xmult(a2,b2,a1);\n    double c3=xmult(b2,a1,b1),c4=xmult(b2,a2,b1);\n    return dcmp(c1)*dcmp(c2)<0&&dcmp(c3)*dcmp(c4)<0;\n}\nbool Onsegment(point P,point a1,point a2) {\n    return dcmp(xmult(a1,a2,P))==0&&dcmp(multi(P,a1,a2))<0;\n}\nint n,m;\npoint p1[111],p2[111],c1[111],c2[111];\nint main() {\n    while (~scanf(\"%d%d\",&n,&m)) {\n        if (n==0&&m==0) break;\n        for (int i=0; i<n; i++) scanf(\"%lld%lld\",&p1[i].x,&p1[i].y);\n        for (int i=0; i<m; i++) scanf(\"%lld%lld\",&p2[i].x,&p2[i].y);\n        if (n>1) n=convex(p1,c1,n);\n        else c1[0]=p1[0];\n        if (m>1) m=convex(p2,c2,m);\n        else c2[0]=p2[0];\n        bool flag=1;\n        if (n>2) {\n            LL s=area(c1,n);\n            for (int i=0; i<m; i++) {\n                LL cnt=0;\n                for (int j=1; j<n; j++) cnt+=abs(xmult(c1[j-1],c1[j],c2[i]));\n                cnt+=abs(xmult(c1[n-1],c1[0],c2[i]));\n                if (cnt==s) {\n                    flag=0;\n                    break;\n                }\n            }\n        }\n        if (m>2) {\n            LL s=area(c2,m);\n            for (int i=0; i<n; i++) {\n                LL cnt=0;\n                for (int j=1; j<m; j++) cnt+=abs(xmult(c2[j-1],c2[j],c1[i]));\n                cnt+=abs(xmult(c2[m-1],c2[0],c1[i]));\n                if (cnt==s) {\n                    flag=0;\n                    break;\n                }\n            }\n        }\n        if (n==2&&m==2)\n            if (SegmentProperIntersection(c1[0],c1[1],c2[0],c2[1])) flag=0;\n        if (n==1&&m==2)\n            if (Onsegment(c1[0],c2[0],c2[1])) flag=0;\n        if (n==2&&m==1)\n            if (Onsegment(c2[0],c1[0],c1[1])) flag=0;\n        if (flag) printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>  \n#include <cstdio>  \n#include <cstring>  \n#include <algorithm>  \n#include <cmath>  \nusing namespace std;  \n  \nstruct Point  \n{  \n    double x,y;  \n    Point (double x=0, double y=0) :x(x),y(y) {}  \n    void show() { cout<<\"(\"<<x<<\",\"<<y<<\")\"<<endl; }  \n};  \ntypedef Point Vector;  \n  \nbool operator < (const Point& A, const Point& B )  \n{  \n    return A.x < B.x || (A.x == B.x && A.y < B.y);  \n}  \nVector operator - ( Point A, Point B) { return Vector(A.x-B.x, A.y-B.y); }  \ndouble Cross(Vector A, Vector B) { return A.x*B.y - B.x*A.y; }  \n  \nconst double eps = 1e-10;  \nint dcmp(double x)  \n{  \n    if(fabs(x) < eps) return 0;  \n    return x>0? 1: -1;  \n}  \n  \nint ConvexHull ( Point* p, int n, Point* ch)  \n{  \n    sort(p, p+n);  \n    int m = 0;  \n    for(int i = 0; i<n; i++)  \n    {  \n        while(m > 1 && Cross( ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0) m--;  \n        ch[m++] = p[i];  \n    }  \n    int k = m;  \n    for(int i = n-2; i>=0; i--)  \n    {  \n        while(m > k && Cross( ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0) m--;  \n        ch[m++] = p[i];  \n    }  \n    ///霑倩ヲ∵隼荳?ク狗函謌仙、夊セケ蠖「縲? \n    ch[m++] = ch[0];  \n    if(n > 1) m--;  \n    return m;  \n}  \n  \nPoint black[120],white[120],cw[120],cb[120];  \nint nb,nw,n,m;  \n  \nvoid reset()  \n{  \n    memset(black,0,sizeof(black));  \n    memset(white,0,sizeof(white));  \n    memset(cw,0,sizeof(cw));  \n    memset(cb,0,sizeof(cb));  \n}  \n  \nbool SideCross(Point a1, Point a2, Point b1, Point b2)  \n{  \n    double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1),  \n           c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1);  \n    return dcmp(c1)*dcmp(c2)<0 && dcmp(c3)*dcmp(c4)<0;  \n}  \n  \nbool pInConvex(Point a, Point* ch, int n)  \n{  \n    int i;  \n    if(n==3)  \n    {  \n        if(a.x < min(ch[0].x, ch[1].x) || a.x > max(ch[0].x, ch[1].x)) return 0;  \n        if(a.y < min(ch[0].y, ch[1].y) || a.y > max(ch[0].y, ch[1].y)) return 0;  \n    }  \n    for(i=1;i<n;i++)  \n    {  \n        if(Cross( ch[i]-ch[i-1], a-ch[i-1] ) < 0 ) return 0;  \n    }  \n    return 1;  \n}  \n  \nint solve()  \n{  \n    int i,j;  \n    if(n==1&&m==1) return 1;  \n    else if(n==1)  \n    {  \n        ///謇セ逋ス蟄仙?蛹?、夊セケ蠖「縲ょ愛譁ュ霑吩クェ鮟大ュ先弍蜷ヲ蝨ィ逋ス蛹??  \n        nw=ConvexHull(white, m, cw);  \n        if(pInConvex(black[0], cw, nw)) return 0;  \n    }  \n    else if(m==1)  \n    {  \n        ///謇セ鮟大ュ仙?蛹?、夊セケ蠖「縲ょ愛譁ュ霑吩クェ逋ス蟄先弍蜷ヲ蝨ィ鮟大桁蜀? \n        nb=ConvexHull(black, n, cb);  \n        if(pInConvex(white[0], cb, nb)) return 0;  \n    }  \n    else  \n    {  \n        ///謇セ鮟醍區蜃ク蛹?、夊セケ蠖「縲ょ愛譁ュ譏ッ蜷ヲ譛臥コソ谿オ逶ク莠、謌也せ蝨ィ蜿ヲ荳?クェ蜃ク蛹??縲? \n        nb=ConvexHull(black, n, cb);  \n        nw=ConvexHull(white, m, cw);  \n        for(i=1;i<nb;i++)  \n        {  \n            for(j=1;j<nw;j++)  \n                if(SideCross( cb[i], cb[i-1], cw[j] ,cw[j-1] )) return 0;  \n        }  \n        for(i=0;i<n;i++)  \n            if(pInConvex(black[i], cw, nw)) return 0;  \n        for(i=0;i<m;i++)  \n            if(pInConvex(white[i], cb, nb)) return 0;  \n    }  \n    return 1;  \n}  \n  \nint main()  \n{  \n    int i,tx,ty;  \n    while(cin>>n>>m,n||m)  \n    {  \n        reset();  \n        for(i=0;i<n;i++)  \n        {  \n            cin>>tx>>ty;  \n            black[i]=Point(tx,ty);  \n        }  \n        for(i=0;i<m;i++)  \n        {  \n            cin>>tx>>ty;  \n            white[i]=Point(tx,ty);  \n        }  \n        int ans=solve();  \n        if(ans)  \n            cout<<\"YES\"<<endl;  \n        else  \n            cout<<\"NO\"<<endl;  \n    }  \n    return 0;  \n}  "
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n#include <assert.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <double,double> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\ntypedef complex<double> Point;\n\nnamespace std {\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const Point& a, const Point& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const Point& a, const Point& b) {\n  return real(conj(a)*b);\n}\n\nstruct Line : public vector<Point> {\n  Line(const Point &a, const Point &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool is_inner(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  return (dot(b,c) <= 0);\n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nbool is_projection_on_line(const Line &l, const Point &p) {\n  Point pj = projection(l,p);\n  return is_inner(pj,l[0],l[1]);\n}\n\ndouble distanceLP(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\nbool is_equal(const Point &l,const Point &m){\n  return ((abs(real(l) - real(m)) < EPS) && (abs(imag(l) - imag(m) < EPS)));\n}\n\nbool cmp_x(const Point& p, const Point& q){\n  if(p.real() != q.real()) return p.real() < q.real();\n  return p.imag() < q.imag();\n}\n\nvector<Point> compute_convex_hull(vector<Point> ps){\n  sort(ps.begin(), ps.end(), cmp_x);\n  int k = 0;\n  vector<Point> qs(ps.size() * 2);\n  for(int i=0; i < ps.size(); i++){\n    while(k > 1 && cross(qs[k - 1] - qs[k - 2],ps[i] - qs[k - 1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  for(int i = ps.size() - 2,t = k; i >= 0; i--){\n    while(k > t && cross(qs[k - 1] - qs[k - 2],ps[i] - qs[k - 1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nbool is_convex_hull(vector<Point>& ps,const Point& c){\n  for(int i=0;i<ps.size();i++){\n    if(is_equal(ps[i],c)) return true;\n  }\n  return false;\n}\n\nbool is_inner_polygon(const vector<Point>& outer,const vector<Point>& inner){\n\n  Point center;\n  for(int i = 0; i < outer.size(); i++){\n    center += outer[i];\n    for(int j = 0; j < inner.size(); j++){\n      if(ccw(outer[i],outer[(i+1) % outer.size()],inner[j]) == 0){\n        return true;\n      }\n    }\n  }\n  center /= outer.size();\n  for(int i = 0; i < inner.size(); i++){\n    for(int j = 0; j < outer.size(); j++){\n      double a = cross(center - outer[j],inner[i] - center);\n      double b = cross(outer[j] - outer[(j+1) % outer.size()],inner[i] - outer[j]);\n      double c = cross(outer[(j+1) % outer.size()] - center,inner[i] - outer[(j+1) % outer.size()]);\n\n      if((a > 0 && b > 0 && c > 0)\n         || (a < 0 && b < 0 && c < 0)){\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nint main(){\n  int n,m;\n  while(~scanf(\"%d %d\",&n,&m)){\n    if(n == 0 && m == 0) break;\n\n    vector<Point> black;\n    for(int i = 0; i < n; i++){\n      double x,y;\n      scanf(\"%lf %lf\",&x,&y);\n      black.push_back(Point(x,y));\n    }\n    vector<Point> black_convex_hull = compute_convex_hull(black);\n\n    vector<Point> white;\n    for(int i = 0; i < m; i++){\n      double x,y;\n      scanf(\"%lf %lf\",&x,&y);\n      white.push_back(Point(x,y));\n    }\n    vector<Point> white_convex_hull = compute_convex_hull(white);\n\n\n    bool dividable = true;\n\n    if(black.size() == 1 && white.size() == 2){\n      if(ccw(white[0],black[0],white[1]) == -2){\n        dividable = false;\n      }\n    }\n    else if(black.size() == 2 && white.size() == 1){\n      if(ccw(black[0],white[0],black[1]) == -2){\n        dividable = false;\n      }\n    }\n    else if(black.size() == 2 && white.size() == 2){\n      if(intersectSS(Line(black[0],black[1]),\n                     Line(white[0],white[1]))){\n        dividable = false;\n      }\n    }\n    else {\n      if(black_convex_hull.size() >= 3 && is_inner_polygon(black_convex_hull,white_convex_hull)\n         || white_convex_hull.size() >= 3 && is_inner_polygon(white_convex_hull,black_convex_hull)){\n        dividable = false;\n      }\n    }\n    printf(\"%s\\n\", dividable ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);++i)\n#define rep2(i,a,b) for (int i=(a);i<(b);++i)\n#define rrep(i,n) for (int i=(n)-1;i>=0;--i)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;--i)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ninline int sgn(double a, double b = 0) { return a < b - EPS ? -1 : a > b + EPS ? 1 : 0; }\n\nstruct L {\n    P a, b, v, h;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a), h(v / abs(v) * P(0, 1)) {}\n    L(double _ax, double _ay, double _bx, double _by) : L(P(_ax, _ay), P(_bx, _by)) {}\n    void trans(double d) {\n        a += d * h;\n        b += d * h;\n    }\n    void print() {\n        cerr << \"{(\" << a.real() << \", \" << a.imag() << \"), (\" << b.real() << \", \" << b.imag() << \")}\" << endl;\n    }\n};\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\nP readP() {\n    double x, y;\n    cin >> x >> y;\n    return P(x, y);\n}\n\nbool cmp_x(const P& p, const P& q) {\n    if (p.real() != q.real()) return p.real() < q.real();\n    return p.imag() < q.imag();\n}\n\nint ccw(P p0, P p1, P p2) {\n    p1 -= p0; p2 -= p0;\n    if (sgn(cross(p1, p2)) == 1) return +1;         // counter-clockwise\n    if (sgn(cross(p1, p2)) == -1) return -1;        // clockwise\n    if (sgn(dot(p1, p2)) == -1) return +2;          // p2 -- p0 -- p1\n    if (sgn(norm(p1), norm(p2)) == -1) return -2;   // p0 -- p1 -- p2\n    return 0;                                       // p0 -- p2 -- p1\n}\n\nG convex_hull(vector<P> ps) {\n    int n = ps.size();\n    sort(all(ps), cmp_x);\n    G qs(n * 2);\n    int k = 0;\n    rep(i, n) {\n        // ?????´?????????3?????\\?????????????????????????????´?????????<=?????????<??????\n        while (k > 1 && sgn(cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1])) <= 0) k--;\n        qs[k++] = ps[i];\n    }\n    for (int i = n - 2, t = k; i >= 0; i--) {\n        // ?????´?????????3?????\\?????????????????????????????´?????????<=?????????<??????\n        while (k > t && sgn(cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1])) <= 0) k--;\n        qs[k++] = ps[i];\n    }\n    qs.resize(k - 1);\n    return qs;\n}\n\nenum { OUT, ON, IN };\nint containPG(const P& p, const G& g) {\n    int n = g.size();\n    bool in = false;\n    rep(i, n) {\n        P a = here(g, i) - p, b = next(g, i) - p;\n        if (a.imag() > b.imag()) swap(a, b);\n        if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) > 0) in = !in;\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n\n// !! ???????????????????????¨?????? \"<\" !!\nbool intersectSS(L l1, L l2) {\n    return (ccw(l1.a, l1.b, l2.a) * ccw(l1.a, l1.b, l2.b) <= 0 &&\n            ccw(l2.a, l2.b, l1.a) * ccw(l2.a, l2.b, l1.b) <= 0);\n}\n\nbool solve(int n, int m) {\n    vector<P> v1, v2;\n    rep(i, n) {\n        v1.emplace_back(readP());\n    }\n    rep(i, m) {\n        v2.emplace_back(readP());\n    }\n\n    if (n == 1 && m == 1) return true;\n    if (n == 2 && m == 1) return abs(ccw(v1[0], v1[1], v2[0])) == 1;\n    if (n == 1 && m == 2) return abs(ccw(v2[0], v2[1], v1[0])) == 1;\n    if (n == 2 && m == 2) return !intersectSS(L(v1[0], v1[1]), L(v2[0], v2[1]));\n\n    auto g = convex_hull(v1);\n    auto h = convex_hull(v2);\n\n    // cerr << g.size() << \" \" << h.size() << endl;\n\n    rep(i, g.size()) {\n        if (containPG(here(g, i), h)) {\n            return false;\n        }\n    }\n    rep(i, h.size()) {\n        if (containPG(here(h, i), g)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nmain() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    while (cin >> n >> m, n) {\n        cout << (solve(n, m) ? \"YES\" : \"NO\") << endl;\n    }\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1298: Separate Points\n// 2017.10.30 bal4u@uu\n\n#include <stdio.h>\n#include <math.h>\n\n#define INF 0x3fffffff\n#define EPS 1e-7\n#define JUST_ON 1\n\nint insidePolygon(int x, int y, int pn, int *px, int *py)\n{\n    int i, j, inside;\n    double yy;\n\n    /* Point (x,y) just lies on the edge or vertex of polygon */\n    for (i = 0, j = pn-1; i < pn; j = i++) {\n        if (py[i] == py[j] && y == py[i] &&\n            ((px[i]<=x && x<=px[j]) || (px[j]<=x && x<=px[i])))\n            return JUST_ON;\n        else if (py[i] != py[j] &&\n            ((py[i]<=y && y<=py[j]) || (py[j]<=y && y<=py[i])) &&\n            x == (double)(px[j]-px[i])*(y-py[i])/(py[j]-py[i])+px[i])\n            return JUST_ON;\n    }\n\n    /* Point (x,y) is inside/outside polygon */\n    inside = 0;\n    yy = y + 0.5; /* shift y to avoid acrossing the poly's edges or vertices */\n    for (i = 0, j = pn-1; i < pn; j = i++) {\n        if (((py[i]<=y && y<py[j]) || (py[j]<=y && y<py[i])) &&\n            x < (double)(px[j]-px[i])*(yy-py[i])/(py[j]-py[i])+px[i]) {\n            inside = !inside;\n\t\t}\n    }\n    return inside;\n}\n\ndouble theta(int x1, int y1, int x2, int y2)\n{\n    int dx, dy, ax, ay;\n    double t;\n\n    dx = x2 - x1;\n    ax = dx < 0 ? -dx : dx;\n    dy = y2 - y1;\n    ay = dy < 0 ? -dy : dy;\n    t = (ax + ay == 0) ? 0 : (double)dy/(double)(ax+ay);\n    if (dx < 0) t = 2 - t;\n    else if (dy < 0) t = 4 + t;\n    return t * 90.0;\n}\n\nlong long distance(int x1, int y1, int x2, int y2)\n{\n    int dx = x1 - x2;\n    int dy = y1 - y2;\n    return (long long)dx*dx + (long long)dy*dy;\n}\n\nint convexHull(int pn, int *x, int *y)\n{\n    int i, j;\n    int min;\n    double minang, nowang;\n    long long dist;\n\n    min = 0;\n    for (i = 1; i < pn; i++) {\n        if (y[i] < y[min]) min = i;\n        else if (y[i] == y[min] && x[i] < x[min]) min = i;\n    }\n\n    minang = 0;\n    x[pn] = x[min], y[pn] = y[min];\n    for (j = 0; j < pn; j++) {\n        int tx, ty;\n        if (j != min) {\n            tx = x[j], x[j] = x[min], x[min] = tx;\n            ty = y[j], y[j] = y[min], y[min] = ty;\n        }\n        dist = 0x7ffffff;\n        min = pn; nowang = minang; minang = 360;\n        for (i = j+1; i <= pn; i++) {\n            long long d = distance(x[j], y[j], x[i], y[i]);\n            double rad = theta(x[j], y[j], x[i], y[i]);\n\n            if (d == 0) continue;\n            if (rad < nowang) continue;\n            if (rad > nowang + EPS) {\n                if (rad + EPS < minang) {\n                    dist = d;\n                    minang = rad;\n                    min = i;\n                } else if (fabs(rad-minang) < EPS && d > EPS && d > dist) {\n                    dist = d;\n                    minang = rad;\n                    min = i;\n                }\n            } else if (fabs(rad-nowang) < EPS && d > EPS &&\n                       fabs(rad-minang) > EPS || d > dist) {\n                dist = d;\n                minang = rad;\n                min = i;\n            }\n        }\n        if (min == pn) break;\n    }\n    return j+1;\n}\n\nint isPointOnSegment(int x, int y, int x1, int y1, int x2, int y2)\n{\n\tint d;\n\tif (x1 > x2) { d = x1, x1 = x2, x2 = d; d = y1, y1 = y2, y2 = d; }\n\treturn x1 <= x && x <= x2 && ((y1 <= y2 && y1 <= y && y <= y2) ||\n\t\t(y1 > y2 && y2 <= y && y <= y1))\n\t\t&& (long long)(y - y1)*(x2 - x1) == (long long)(y2 - y1)*(x - x1);\n}\n\nint intersection(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)\n{\n\tlong long t1, t2, t3, t4;\n\n//\tif ((long long)(y2 - y1)*(x4 - x3) == (long long)(y4 - y3)*(x2 - x1)) return 0;\n\n\tt1 = (long long)(y1 - y3)*(x3 - x4) - (long long)(x1 - x3)*(y3 - y4);\n\tt2 = (long long)(y2 - y3)*(x3 - x4) - (long long)(x2 - x3)*(y3 - y4);\n\tt3 = (long long)(y3 - y1)*(x1 - x2) - (long long)(x3 - x1)*(y1 - y2);\n\tt4 = (long long)(y4 - y1)*(x1 - x2) - (long long)(x4 - x1)*(y1 - y2);\n\n\tif (t1*t2 < 0 && t3*t4 < 0) return 1;\n\tt1 = isPointOnSegment(x1,y1,x3,y3,x4,y4), t2 = isPointOnSegment(x2,y2,x3,y3,x4,y3);\n\tt3 = isPointOnSegment(x3,y3,x1,y1,x2,y2), t4 = isPointOnSegment(x4,y4,x1,y1,x2,y2);\n\treturn t1 || t2 || t3 || t4;\n}\n\nint xb[102], yb[102], n;\nint xw[102], yw[102], m;\n\nint main()\n{\n\tint i, sb, sw;\n\tint xbmin, ybmin, xbmax, ybmax;\n\tint xwmin, ywmin, xwmax, ywmax;\n\n\twhile (scanf(\"%d%d\", &n, &m) && (n > 0 || m > 0)) {\n\t\tfor (i = 0; i < n; i++) scanf(\"%d%d\", xb+i, yb+i);\n\t\tsb = convexHull(n, xb, yb);\n\t\txb[sb] = xb[0], yb[sb] = yb[0];\n\n\t\tfor (i = 0; i < m; i++) scanf(\"%d%d\", xw+i, yw+i);\n\t\tsw = convexHull(m, xw, yw);\n\t\txw[sw] = xw[0], yw[sw] = yw[0];\n\n\t\tif (sb < 1 || sw < 1) goto yes;\n\t\tif (sb == 1 && sw == 1) goto yes;\n\t\tif (sb == 1 && sw == 2) {\n\t\t\tif(isPointOnSegment(xb[0], yb[0], xw[0], yw[0], xw[1], yw[1])) goto no;\n\t\t}\n\t\tif (sb == 2 && sw == 1) {\n\t\t\tif(isPointOnSegment(xw[0], yw[0], xb[0], yb[0], xb[1], yb[1])) goto no;\n\t\t}\n\t\tif (sb == 2 && sw == 2) {\n\t\t\tif (intersection(xb[0],yb[0],xb[1],yb[1],xw[0],yw[0],xw[1],yw[1])) goto no;\n\t\t}\n\n\t\tif (sw >= 3) for (i = 0; i < sb; i++)\n\t\t\tif (insidePolygon(xb[i], yb[i], sw, xw, yw)) goto no;\n\t\n\t\tif (sb >= 3) for (i = 0; i < sw; i++)\n\t\t\tif (insidePolygon(xw[i], yw[i], sb, xb, yb)) goto no;\n\n\t\txbmin = ybmin = INF, xbmax = ybmax = -INF;\n\t\tfor (i = 0; i < sb; i++) {\n\t\t\tif      (xb[i] < xbmin) xbmin = xb[i], ybmin = yb[i];\n\t\t\telse if (xb[i] > xbmax) xbmax = xb[i], ybmax = yb[i];\n\t\t}\n\t\txwmin = ywmin = INF, xwmax = ywmax = -INF;\n\t\tfor (i = 0; i < sw; i++) {\n\t\t\tif      (yw[i] < ywmin) xwmin = xw[i], ywmin = yw[i];\n\t\t\telse if (yw[i] > ywmax) xwmax = xw[i], ywmax = yw[i];\n\t\t}\n\t\tif (xbmin <= xwmin && xwmax <= xbmax && ywmin <= ybmin && ybmax <= ywmax) goto no;\n\t\tif (xwmin <= xbmin && xbmax <= xwmax && ybmin <= ywmin && ywmax <= ybmax) goto no;\n\nyes:\tputs(\"YES\"); continue;\nno:\t\tputs(\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1298: Separate Points\n// 2017.10.30 bal4u@uu\n\n#include <stdio.h>\n#include <math.h>\n\n#define INF 0x3fffffff\n#define EPS 1e-7\n#define JUST_ON 1\n\nlong long dot(int x1, int y1, int x2, int y2)\n{\n\treturn (long long)x1*x2 + (long long)y1*y2;\n}\n\nlong long cross(int x1, int y1, int x2, int y2)\n{\n\treturn (long long)x1*y2 - (long long)y1*x2; \n}\n\nint insidePolygon(int x, int y, int pn, int *px, int *py)\n{\n\tint i, xa, ya, xb, yb, t, f;\n\n\tf = 0;\n\tfor (i = 0; i < pn; i++) {\n\t\txa = px[i       ] - x, ya = py[i       ] - y;\n\t\txb = px[(i+1)%pn] - x, yb = py[(i+1)%pn] - y;\n\t\tif (fabs((double)cross(xa, ya, xb, yb)) < EPS && dot(xa, ya, xb, yb) < EPS) return 1;\n\t\tif (ya > yb) t = ya, ya = yb, yb = t, t = xa, xa = xb, xb = t;\n\t\tif (ya < EPS && EPS < yb && cross(xa, ya, xb, yb) > EPS) f = !f;\n\t}\n\treturn f;\n}\n\ndouble theta(int x1, int y1, int x2, int y2)\n{\n    int dx, dy, ax, ay;\n    double t;\n\n    dx = x2 - x1;\n    ax = dx < 0 ? -dx : dx;\n    dy = y2 - y1;\n    ay = dy < 0 ? -dy : dy;\n    t = (ax + ay == 0) ? 0 : (double)dy/(double)(ax+ay);\n    if (dx < 0) t = 2 - t;\n    else if (dy < 0) t = 4 + t;\n    return t * 90.0;\n}\n\nlong long distance(int x1, int y1, int x2, int y2)\n{\n    int dx = x1 - x2;\n    int dy = y1 - y2;\n    return (long long)dx*dx + (long long)dy*dy;\n}\n\nint convexHull(int pn, int *x, int *y)\n{\n    int i, j;\n    int min;\n    double minang, nowang;\n    long long dist;\n\n    min = 0;\n    for (i = 1; i < pn; i++) {\n        if (y[i] < y[min]) min = i;\n        else if (y[i] == y[min] && x[i] < x[min]) min = i;\n    }\n\n    minang = 0;\n    x[pn] = x[min], y[pn] = y[min];\n    for (j = 0; j < pn; j++) {\n        int tx, ty;\n        if (j != min) {\n            tx = x[j], x[j] = x[min], x[min] = tx;\n            ty = y[j], y[j] = y[min], y[min] = ty;\n        }\n        dist = 0x7ffffff;\n        min = pn; nowang = minang; minang = 360;\n        for (i = j+1; i <= pn; i++) {\n            long long d = distance(x[j], y[j], x[i], y[i]);\n            double rad = theta(x[j], y[j], x[i], y[i]);\n\n            if (d == 0) continue;\n            if (rad < nowang) continue;\n            if (rad > nowang + EPS) {\n                if (rad + EPS < minang) {\n                    dist = d;\n                    minang = rad;\n                    min = i;\n                } else if (fabs(rad-minang) < EPS && d > EPS && d > dist) {\n                    dist = d;\n                    minang = rad;\n                    min = i;\n                }\n            } else if (fabs(rad-nowang) < EPS && d > EPS &&\n                       fabs(rad-minang) > EPS || d > dist) {\n                dist = d;\n                minang = rad;\n                min = i;\n            }\n        }\n        if (min == pn) break;\n    }\n    return j+1;\n}\n\nint isPointOnSegment(int x, int y, int x1, int y1, int x2, int y2)\n{\n\tint d;\n\tif (x1 > x2) { d = x1, x1 = x2, x2 = d; d = y1, y1 = y2, y2 = d; }\n\treturn x1 <= x && x <= x2 && ((y1 <= y2 && y1 <= y && y <= y2) ||\n\t\t(y1 > y2 && y2 <= y && y <= y1))\n\t\t&& (long long)(y - y1)*(x2 - x1) == (long long)(y2 - y1)*(x - x1);\n}\n\nint intersection(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)\n{\n\tlong long t1, t2, t3, t4;\n\n\tif ((long long)(y2 - y1)*(x4 - x3) == (long long)(y4 - y3)*(x2 - x1)) return 0;\n\n\tt1 = (long long)(y1 - y3)*(x3 - x4) - (long long)(x1 - x3)*(y3 - y4);\n\tt2 = (long long)(y2 - y3)*(x3 - x4) - (long long)(x2 - x3)*(y3 - y4);\n\tt3 = (long long)(y3 - y1)*(x1 - x2) - (long long)(x3 - x1)*(y1 - y2);\n\tt4 = (long long)(y4 - y1)*(x1 - x2) - (long long)(x4 - x1)*(y1 - y2);\n\n\tif (t1*t2 < 0 && t3*t4 < 0) return 1;\n\tt1 = isPointOnSegment(x1,y1,x3,y3,x4,y4), t2 = isPointOnSegment(x2,y2,x3,y3,x4,y3);\n\tt3 = isPointOnSegment(x3,y3,x1,y1,x2,y2), t4 = isPointOnSegment(x4,y4,x1,y1,x2,y2);\n\treturn t1 || t2 || t3 || t4;\n}\n\nint xb[102], yb[102], n;\nint xw[102], yw[102], m;\n\nint main()\n{\n\tint i, sb, sw;\n\tint xbx0, ybx0, xbx9, ybx9, xby0, yby0, xby9, yby9;\n\tint xwx0, ywx0, xwx9, ywx9, xwy0, ywy0, xwy9, ywy9;\n\n\twhile (scanf(\"%d%d\", &n, &m) && (n > 0 || m > 0)) {\n\t\tfor (i = 0; i < n; i++) scanf(\"%d%d\", xb+i, yb+i);\n\t\tsb = convexHull(n, xb, yb);\n\t\txb[sb] = xb[0], yb[sb] = yb[0];\n\n\t\tfor (i = 0; i < m; i++) scanf(\"%d%d\", xw+i, yw+i);\n\t\tsw = convexHull(m, xw, yw);\n\t\txw[sw] = xw[0], yw[sw] = yw[0];\n\n\n\t\tif (sb < 1 || sw < 1) goto yes;\n\t\tif (sb == 1 && sw == 1) goto yes;\n\t\tif (sb == 1 && sw == 2) {\n\t\t\tif(isPointOnSegment(xb[0], yb[0], xw[0], yw[0], xw[1], yw[1])) goto no;\n\t\t}\n\t\tif (sb == 2 && sw == 1) {\n\t\t\tif(isPointOnSegment(xw[0], yw[0], xb[0], yb[0], xb[1], yb[1])) goto no;\n\t\t}\n\t\tif (sb == 2 && sw == 2) {\n\t\t\tif (intersection(xb[0],yb[0],xb[1],yb[1],xw[0],yw[0],xw[1],yw[1])) goto no;\n\t\t}\n\n\t\tif (sw >= 3) for (i = 0; i < sb; i++)\n\t\t\tif (insidePolygon(xb[i], yb[i], sw, xw, yw)) goto no;\n\t\tif (sb >= 3) for (i = 0; i < sw; i++)\n\t\t\tif (insidePolygon(xw[i], yw[i], sb, xb, yb)) goto no;\n\n\t\txbx0 = yby0 = INF, xbx9 = yby9 = -INF;\n\t\tfor (i = 0; i < sb; i++) {\n\t\t\tif      (xb[i] < xbx0) xbx0 = xb[i], ybx0 = yb[i];\n\t\t\telse if (xb[i] > xbx9) xbx9 = xb[i], ybx9 = yb[i];\n\t\t\tif      (yb[i] < yby0) xby0 = xb[i], yby0 = yb[i];\n\t\t\telse if (yb[i] > yby9) xby9 = xb[i], yby9 = yb[i];\n\t\t}\n\t\txwx0 = ywy0 = INF, xwx9 = ywy9 = -INF;\n\t\tfor (i = 0; i < sw; i++) {\n\t\t\tif      (xw[i] < xwx0) xwx0 = xw[i], ywx0 = yw[i];\n\t\t\telse if (xw[i] > xwx9) xwx9 = xw[i], ywx9 = yw[i];\n\t\t\tif      (yw[i] < ywy0) xwy0 = xw[i], ywy0 = yw[i];\n\t\t\telse if (yw[i] > ywy9) xwy9 = xw[i], ywy9 = yw[i];\n\t\t}\n\n\t\tif (xbx0 <= xwx0 && xwx9 <= xbx9 && ywy0 <= yby0 && yby9 <= ywy9) goto no;\n\t\tif (xwx0 <= xbx0 && xbx9 <= xwx9 && yby0 <= ywy0 && ywy9 <= yby9) goto no;\n\t\tif (xwx0 <= xbx0 && xbx9 <= xwx9 && yby0 <= ywy0 && ywy9 <= yby9) goto no;\n\t\tif (xbx0 <= xwx0 && xwx9 <= xbx9 && ywy0 <= yby0 && yby9 <= ywy9) goto no;\n\nyes:\tputs(\"YES\"); continue;\nno:\t\tputs(\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Separate Points\npublic class Main{\n\n\tint n, m;\n\tdouble delta = 1e-10, EPS = 1e-10;\n\tdouble[][] b, w;\n\t\n\tboolean isLeft(double[] s, double[] t, double[] r){\n\t\tdouble x1 = t[0]-s[0], y1 = t[1]-s[1], x2 = r[0]-s[0], y2 = r[1]-s[1];\n\t\treturn x1*y2-x2*y1>0;\n\t}\n\tboolean isRight(double[] s, double[] t, double[] r){\n\t\tdouble x1 = t[0]-s[0], y1 = t[1]-s[1], x2 = r[0]-s[0], y2 = r[1]-s[1];\n\t\treturn x1*y2-x2*y1<0;\n\t}\n\t\n\tboolean div(double[] s, double[] t){\n\t\tint br = 0, bl = 0, wr = 0, wl = 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(isLeft(s, t, b[i]))bl++;\n\t\t\tif(isRight(s, t, b[i]))br++;\n\t\t\tif(bl!=0&&br!=0)return false;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(isLeft(s, t, w[i]))wl++;\n\t\t\tif(isRight(s, t, w[i]))wr++;\n\t\t}\n//\t\tSystem.out.println(\"Black left:\"+bl+\" White right:\"+wr);\n//\t\tSystem.out.println(\"Black right:\"+br+\" White left:\"+wl);\n\t\tif(bl==n&&wr==m||br==n&&wl==m)return true;\n\t\tbr = bl = wr = wl = 0;\n\t\tdouble[] rs = new double[]{t[0], t[1]};\n\t\tdouble[] rt = new double[]{s[0], s[1]};\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(isLeft(rs, rt, b[i]))bl++;\n\t\t\tif(isRight(rs, rt, b[i]))br++;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(isLeft(rs, rt, w[i]))wl++;\n\t\t\tif(isRight(rs, rt, w[i]))wr++;\n\t\t}\n//\t\tSystem.out.println(\"Black left:\"+bl+\" White right:\"+wr);\n//\t\tSystem.out.println(\"Black right:\"+br+\" White left:\"+wl);\n\t\treturn bl==n&&wr==m||br==n&&wl==m;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn = sc.nextInt(); m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tb = new double[n][2]; w = new double[m][2];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<2;j++)b[i][j]=sc.nextDouble();\n\t\t\tfor(int i=0;i<m;i++)for(int j=0;j<2;j++)w[i][j]=sc.nextDouble();\n\t\t\tboolean f = false;\n\t\t\tfor(int i=0;i<n;i++)for(int j=i+1;j<n;j++){\n\t\t\t\tif(f)break;\n\t\t\t\tif(b[i][0]==b[i][1]){\n\t\t\t\t\tdouble[] s = new double[]{b[i][0]-delta, b[i][1]};\n\t\t\t\t\tdouble[] t = new double[]{b[j][0]-delta, b[j][1]};\n\t\t\t\t\tf |= div(s, t);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble[] s = new double[]{b[i][0], b[i][1]-delta};\n\t\t\t\tdouble[] t = new double[]{b[j][0], b[j][1]-delta};\n\t\t\t\tf |= div(s, t);\n\t\t\t\ts = new double[]{b[i][0], b[i][1]+delta};\n\t\t\t\tt = new double[]{b[j][0], b[j][1]+delta};\n\t\t\t\tf |= div(s, t);\n\t\t\t}\n\t\t\tif(!f)\n\t\t\tfor(int i=0;i<m;i++)for(int j=i+1;j<m;j++){\n\t\t\t\tif(f)break;\n\t\t\t\tif(w[i][0]==w[i][1]){\n\t\t\t\t\tdouble[] s = new double[]{w[i][0]-delta, w[i][1]};\n\t\t\t\t\tdouble[] t = new double[]{w[j][0]-delta, w[j][1]};\n\t\t\t\t\tf |= div(s, t);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble[] s = new double[]{w[i][0], w[i][1]-delta};\n\t\t\t\tdouble[] t = new double[]{w[j][0], w[j][1]-delta};\n\t\t\t\tf |= div(s, t);\n\t\t\t\ts = new double[]{w[i][0], w[i][1]+delta};\n\t\t\t\tt = new double[]{w[j][0], w[j][1]+delta};\n\t\t\t\tf |= div(s, t);\n\t\t\t}\n\t\t\tif(!f)\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<m;j++){\n\t\t\t\tdouble[] mid = new double[]{(b[i][0]+w[j][0])/2, (b[i][1]+w[j][1])/2};\n\t\t\t\tdouble x = b[i][0]-w[j][0], y = b[i][1]-w[j][1];\n\t\t\t\tdouble dx = -y, dy = x;\n\t\t\t\tdouble[] t = new double[]{mid[0]+dx, mid[1]+dy};\n\t\t\t\tf |= div(mid, t);\n\t\t\t\tt = new double[]{mid[0]-dx, mid[1]-dy};\n\t\t\t\tf |= div(mid, t);\n\t\t\t\tif(f)break;\n\t\t\t}\n\t\t\tSystem.out.println(f?\"YES\":\"NO\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.*;\nimport java.util.*;\nimport java.awt.geom.*;\n\npublic class Main {\n    public static void main(String args[])throws Exception{\n        Scanner cin= new Scanner(System.in);\n\t\tint n,m;\n\t\tfor(;;){\n\t\t\tn=cin.nextInt();\n\t\t\tm=cin.nextInt();\n\t\t\t//\t\t\tSystem.out.printf(\"%d %d\\n\",n,m);\n\t\t\tif(n==0 && m==0) break;\n\t\t\t\n\t\t\tPoint2D.Double[] w = new Point2D.Double[200];\n\t\t\tPoint2D.Double[] b = new Point2D.Double[200];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tw[i].x= cin.nextInt();\n\t\t\t\tw[i].y= cin.nextInt();\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tb[i].x= cin.nextInt();\n\t\t\t\tb[i].y= cin.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint f=0;\n\t\tout:\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\t\tint t1=0,t2=0;\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(k==i) continue;\n\t\t\t\t\t\tint ccw=Line2D.relativeCCW(w[i].x, w[i].y, b[i].x, b[i].y, w[k].x, w[k].y);\n\t\t\t\t\t\tif(ccw==0) if(w[i].distance(b[j]) + w[i].distance(w[k]) <= w[k].distance(b[j]) + 0.0000000001) ccw=1;\n\t\t\t\t\t\tt1+=ccw;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<m;k++){\n\t\t\t\t\t\tif(k==j) continue;\n\t\t\t\t\t\tint ccw=Line2D.relativeCCW(w[i].x, w[i].y, b[i].x, b[i].y, b[k].x, b[k].y);\n\t\t\t\t\t\tif(ccw==0) if(b[j].distance(w[i]) + b[j].distance(b[k]) <= w[i].distance(b[k]) + 0.0000000001) ccw=-1;\n\t\t\t\t\t\tt1+=ccw;\n\t\t\t\t\t}\n\t\t\t\t\tif(t1*t2<=0 && Math.abs(t1)==n && Math.abs(t2)==m){\n\t\t\t\t\t\tf=1;\n\t\t\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f==0) System.out.println(\"NO\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Separate Points\npublic class Main{\n\n\tint n, m;\n\tdouble delta = 1e-8, EPS = 1e-10;\n\tdouble[][] b, w;\n\t\n\tboolean isLeft(double[] s, double[] t, double[] r){\n\t\tdouble x1 = t[0]-s[0], y1 = t[1]-s[1], x2 = r[0]-s[0], y2 = r[1]-s[1];\n\t\treturn x1*y2-x2*y1>0;\n\t}\n\tboolean isRight(double[] s, double[] t, double[] r){\n\t\tdouble x1 = t[0]-s[0], y1 = t[1]-s[1], x2 = r[0]-s[0], y2 = r[1]-s[1];\n\t\treturn x1*y2-x2*y1<0;\n\t}\n\t\n\tboolean div(double[] s, double[] t){\n\t\tint br = 0, bl = 0, wr = 0, wl = 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(isLeft(s, t, b[i]))bl++;\n\t\t\tif(isRight(s, t, b[i]))br++;\n\t\t\tif(bl!=0&&br!=0)return false;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(isLeft(s, t, w[i]))wl++;\n\t\t\tif(isRight(s, t, w[i]))wr++;\n\t\t}\n//\t\tSystem.out.println(\"Black left:\"+bl+\" White right:\"+wr);\n//\t\tSystem.out.println(\"Black right:\"+br+\" White left:\"+wl);\n\t\tif(bl==n&&wr==m||br==n&&wl==m)return true;\n\t\tbr = bl = wr = wl = 0;\n\t\tdouble[] rs = new double[]{t[0], t[1]};\n\t\tdouble[] rt = new double[]{s[0], s[1]};\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(isLeft(rs, rt, b[i]))bl++;\n\t\t\tif(isRight(rs, rt, b[i]))br++;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(isLeft(rs, rt, w[i]))wl++;\n\t\t\tif(isRight(rs, rt, w[i]))wr++;\n\t\t}\n//\t\tSystem.out.println(\"Black left:\"+bl+\" White right:\"+wr);\n//\t\tSystem.out.println(\"Black right:\"+br+\" White left:\"+wl);\n\t\treturn bl==n&&wr==m||br==n&&wl==m;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn = sc.nextInt(); m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tb = new double[n][2]; w = new double[m][2];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<2;j++)b[i][j]=sc.nextDouble();\n\t\t\tfor(int i=0;i<m;i++)for(int j=0;j<2;j++)w[i][j]=sc.nextDouble();\n\t\t\tboolean f = false;\n\t\t\tfor(int i=0;i<n;i++)for(int j=i+1;j<n;j++){\n\t\t\t\tif(f)break;\n\t\t\t\tif(b[i][0]==b[i][1]){\n\t\t\t\t\tdouble[] s = new double[]{b[i][0]-delta, b[i][1]};\n\t\t\t\t\tdouble[] t = new double[]{b[j][0]-delta, b[j][1]};\n\t\t\t\t\tf |= div(s, t);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble[] s = new double[]{b[i][0], b[i][1]-delta};\n\t\t\t\tdouble[] t = new double[]{b[j][0], b[j][1]-delta};\n\t\t\t\tf |= div(s, t);\n\t\t\t\ts = new double[]{b[i][0], b[i][1]+delta};\n\t\t\t\tt = new double[]{b[j][0], b[j][1]+delta};\n\t\t\t\tf |= div(s, t);\n\t\t\t}\n\t\t\tif(!f)\n\t\t\tfor(int i=0;i<m;i++)for(int j=i+1;j<m;j++){\n\t\t\t\tif(f)break;\n\t\t\t\tif(w[i][0]==w[i][1]){\n\t\t\t\t\tdouble[] s = new double[]{w[i][0]-delta, w[i][1]};\n\t\t\t\t\tdouble[] t = new double[]{w[j][0]-delta, w[j][1]};\n\t\t\t\t\tf |= div(s, t);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble[] s = new double[]{w[i][0], w[i][1]-delta};\n\t\t\t\tdouble[] t = new double[]{w[j][0], w[j][1]-delta};\n\t\t\t\tf |= div(s, t);\n\t\t\t\ts = new double[]{w[i][0], w[i][1]+delta};\n\t\t\t\tt = new double[]{w[j][0], w[j][1]+delta};\n\t\t\t\tf |= div(s, t);\n\t\t\t}\n\t\t\tif(!f)\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<m;j++){\n\t\t\t\tdouble[] mid = new double[]{(b[i][0]+w[j][0])/2, (b[i][1]+w[j][1])/2};\n\t\t\t\tdouble x = b[i][0]-w[j][0], y = b[i][1]-w[j][1];\n\t\t\t\tdouble dx = -y, dy = x;\n\t\t\t\tdouble[] t = new double[]{mid[0]+dx, mid[1]+dy};\n\t\t\t\tf |= div(mid, t);\n\t\t\t\tt = new double[]{mid[0]-dx, mid[1]-dy};\n\t\t\t\tf |= div(mid, t);\n\t\t\t\t\n\t\t\t\tmid = new double[]{w[j][0]+delta*x, w[j][1]+delta*y};\n\t\t\t\tt = new double[]{mid[0]+dx, mid[1]+dy};\n\t\t\t\tf |= div(mid, t);\n\t\t\t\tt = new double[]{mid[0]-dx, mid[1]-dy};\n\t\t\t\tf |= div(mid, t);\n\t\t\t\t\n\t\t\t\tmid = new double[]{w[j][0]+(1-delta)*x, w[j][1]+(1-delta)*y};\n\t\t\t\tt = new double[]{mid[0]+dx, mid[1]+dy};\n\t\t\t\tf |= div(mid, t);\n\t\t\t\tt = new double[]{mid[0]-dx, mid[1]-dy};\n\t\t\t\tf |= div(mid, t);\n\t\t\t\t\n\t\t\t\tif(f)break;\n\t\t\t}\n\t\t\tSystem.out.println(f?\"YES\":\"NO\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\touter: while (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif (n == 0 && m == 0)\n\t\t\t\tbreak;\n\t\t\tdouble[] x = new double[n + m];\n\t\t\tdouble[] y = new double[n + m];\n\t\t\tfor (int i = 0; i < n + m; ++i) {\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = n; j < n + m; ++j) {\n\t\t\t\t\t/*\n\t\t\t\t\t * y-y1=(y2-y1)/(x2-x1)(x-x1) (y-y1)(x2-x1)=(x-x1)(y2-y1)\n\t\t\t\t\t * 0=(y2-y1)*x-(x2-x1)*y+y1(x2-x1)-x1(y2-y1)\n\t\t\t\t\t */\n\n\t\t\t\t\tdouble a = y[j] - y[i];\n\t\t\t\t\tdouble b = -(x[j] - x[i]);\n\t\t\t\t\tdouble c = -x[i] * (y[j] - y[i]) + y[i] * (x[j] - x[i]);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * ax+by+c=0;\n\t\t\t\t\t */\n\n\t\t\t\t\tArrayList<Integer> positive = new ArrayList<>();\n\t\t\t\t\tArrayList<Integer> negative = new ArrayList<>();\n\t\t\t\t\tArrayList<Integer> zero = new ArrayList<>();\n\t\t\t\t\tzero.add(i);\n\t\t\t\t\tzero.add(j);\n\t\t\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\t\t\tif (k == i)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tdouble sign1 = Math.signum(a * x[k] + b * y[k] + c);\n\t\t\t\t\t\tif (sign1 > 0)\n\t\t\t\t\t\t\tpositive.add(k);\n\t\t\t\t\t\telse if (sign1 == 0)\n\t\t\t\t\t\t\tzero.add(k);\n\t\t\t\t\t\telse if (sign1 < 0)\n\t\t\t\t\t\t\tnegative.add(k);\n\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = n; k < n + m; ++k) {\n\t\t\t\t\t\tif (k == j)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tdouble sign2 = Math.signum(a * x[k] + b * y[k] + c);\n\t\t\t\t\t\tif (sign2 > 0)\n\t\t\t\t\t\t\tpositive.add(k);\n\t\t\t\t\t\telse if (sign2 == 0)\n\t\t\t\t\t\t\tzero.add(k);\n\t\t\t\t\t\telse if (sign2 < 0)\n\t\t\t\t\t\t\tnegative.add(k);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (positive.size() > 0 && positive.get(0) < n && positive.get(positive.size() - 1) >= n) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (negative.size() > 0 && negative.get(0) < n && negative.get(negative.size() - 1) >= n) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (zero.size() > 0) {\n\t\t\t\t\t\tclass cor implements Comparable<cor> {\n\t\t\t\t\t\t\tdouble x;\n\t\t\t\t\t\t\tdouble y;\n\n\t\t\t\t\t\t\tpublic cor(double x, double y) {\n\t\t\t\t\t\t\t\tthis.x = x;\n\t\t\t\t\t\t\t\tthis.y = y;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpublic int compareTo(cor o) {\n\t\t\t\t\t\t\t\tif (x != o.x)\n\t\t\t\t\t\t\t\t\treturn Double.compare(x, o.x);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\treturn Double.compare(y, o.y);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tArrayList<cor> lis1 = new ArrayList<>();\n\t\t\t\t\t\tArrayList<cor> lis2 = new ArrayList<>();\n\t\t\t\t\t\tfor (int k : zero) {\n\t\t\t\t\t\t\tif (k < n) {\n\t\t\t\t\t\t\t\tlis1.add(new cor(x[k], y[k]));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlis2.add(new cor(x[k], y[k]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCollections.sort(lis1);\n\t\t\t\t\t\tCollections.sort(lis2);\n\t\t\t\t\t\tif (lis1.get(0).compareTo(lis2.get(lis2.size() - 1)) != lis1.get(lis1.size() - 1)\n\t\t\t\t\t\t\t\t.compareTo(lis2.get(0))) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tdouble EPS=1e-6;\n\n\tint n, m;\n\t// n:black\n\t// m:white\n\tint[] xs, ys;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tm=sc.nextInt();\n\t\t\tif((n|m)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\txs=new int[n+m];\n\t\t\tys=new int[n+m];\n\t\t\tfor(int i=0; i<n+m; i++){\n\t\t\t\txs[i]=sc.nextInt();\n\t\t\t\tys[i]=sc.nextInt();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tint[] s=new int[n+m];\n\t\tfor(int b=0; b<n; b++){\n\t\t\tfor(int w=n; w<n+m; w++){\n\t\t\t\tdouble xw=xs[w];\n\t\t\t\tdouble yw=ys[w];\n\t\t\t\tdouble xb=xs[b];\n\t\t\t\tdouble yb=ys[b];\n\n\t\t\t\tdouble a=xb==xw?0:(double)(yb-yw)/(xb-xw);\n\t\t\t\tdouble y1=yw;\n\t\t\t\tdouble x1=xw;\n\n\t\t\t\tboolean f=true;\n\t\t\t\tfor(int i=0; i<n+m; i++){\n\t\t\t\t\tdouble x=xs[i];\n\t\t\t\t\tdouble y=ys[i];\n\t\t\t\t\tboolean on=false;\n\t\t\t\t\tif(xb!=xw){\n\t\t\t\t\t\tdouble y2=a*(x-x1)+y1;\n\t\t\t\t\t\tif(y+EPS<y2){\n\t\t\t\t\t\t\t// º\n\t\t\t\t\t\t\ts[i]=-1;\n\t\t\t\t\t\t}else if(y2+EPS<y){\n\t\t\t\t\t\t\t// ã\n\t\t\t\t\t\t\ts[i]=1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ton=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// c\n\t\t\t\t\t\tif(x+EPS<x1){\n\t\t\t\t\t\t\t// ¶\n\t\t\t\t\t\t\ts[i]=-1;\n\t\t\t\t\t\t}else if(x1+EPS<x){\n\t\t\t\t\t\t\t// E\n\t\t\t\t\t\t\ts[i]=1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ton=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(on){\n\t\t\t\t\t\t// ¼üó\n\t\t\t\t\t\tboolean fx=false;\n\t\t\t\t\t\tboolean fy=false;\n\t\t\t\t\t\tif(i<n){\n\t\t\t\t\t\t\t// black\n\t\t\t\t\t\t\tfx|=c(xw, xb, x);\n\t\t\t\t\t\t\tfx|=c(x, xb, xw);\n\t\t\t\t\t\t\tfy|=c(yw, yb, y);\n\t\t\t\t\t\t\tfy|=c(y, yb, yw);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t// white\n\t\t\t\t\t\t\tfx|=c(xb, xw, x);\n\t\t\t\t\t\t\tfx|=c(x, xw, xb);\n\t\t\t\t\t\t\tfy|=c(yb, yw, y);\n\t\t\t\t\t\t\tfy|=c(y, yw, yb);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(fx&&fy){\n\t\t\t\t\t\t\ts[i]=0;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tf=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ã\\ÆÈé(Ìóâ)\n\t\t\t\tint s1=0, s2=0;\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(Math.abs(s[i])==1){\n\t\t\t\t\t\ts1=s[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i=n; i<n+m; i++){\n\t\t\t\t\tif(Math.abs(s[i])==1){\n\t\t\t\t\t\ts2=s[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 0©¯ê©Ì¸\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(s1*s[i]==-1){\n\t\t\t\t\t\tf=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i=n; i<n+m-1; i++){\n\t\t\t\t\tif(s2*s[i]==-1){\n\t\t\t\t\t\tf=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tf&=s1*s2!=1;\n\t\t\t\tif(f){\n\t\t\t\t\tprintln(\"YES\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(\"NO\");\n\t}\n\n\t// a<=b<=c\n\tboolean c(double a, double b, double c){\n\t\treturn a<b+EPS&&b<c+EPS;\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int TRY = 1000000;\n\tpublic static final double EPS = 1E-10;\n\tpublic static final double R = 1E-5;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] x_pos = new int[n + m];\n\t\t\tint[] y_pos = new int[n + m];\n\t\t\t\n\t\t\tfor(int i = 0; i < n + m; i++){\n\t\t\t\tx_pos[i] = sc.nextInt();\n\t\t\t\ty_pos[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tdouble weight_x = Math.random() * 5000;\n\t\t\tdouble weight_y = Math.random() * 5000;\n\t\t\tdouble weight_const = Math.random() * 5000;\n\t\t\t\n\t\t\tboolean failed = false;\n\t\t\tint count = 0;\n\t\t\tdo{\n\t\t\t\tfailed = false;\n\t\t\t\t\n\t\t\t\t//System.out.println(count + \" \" + EPS + \" \" + R);\n\t\t\t\t//System.out.println(weight_x);\n\t\t\t\t//System.out.println(weight_y);\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n + m; i++){\n\t\t\t\t\tdouble output = weight_x * x_pos[i] + weight_y * y_pos[i] + weight_const;\n\t\t\t\t\t\n\t\t\t\t\tif(i < n && output < EPS || i >= n && output > -EPS){\n\t\t\t\t\t\tfinal double diff = i < n ? 1 : -1;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//System.out.println(\"error => \" + i + \" \" + x_pos[i] + \" \" + y_pos[i] + \" \" + diff + \" \" + output);\n\t\t\t\t\t\t\n\t\t\t\t\t\tweight_x += R * diff * x_pos[i];\n\t\t\t\t\t\tweight_y += R * diff * y_pos[i];\n\t\t\t\t\t\tweight_const += R * diff * 1;\n\t\t\t\t\t\tfailed = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(count >= TRY){\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcount++;\n\t\t\t}while(failed);\n\t\t\t\n\t\t\tif(count < TRY){\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tdouble EPS=1e-6;\n\n\tint n, m;\n\t// n:black\n\t// m:white\n\tint[] xs, ys;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tm=sc.nextInt();\n\t\t\tif((n|m)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\txs=new int[n+m];\n\t\t\tys=new int[n+m];\n\t\t\tfor(int i=0; i<n+m; i++){\n\t\t\t\txs[i]=sc.nextInt();\n\t\t\t\tys[i]=sc.nextInt();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tint[] s=new int[n+m];\n\t\tfor(int b=0; b<n; b++){\n\t\t\tfor(int w=n; w<n+m; w++){\n\t\t\t\tdouble xw=xs[w];\n\t\t\t\tdouble yw=ys[w];\n\t\t\t\tdouble xb=xs[b];\n\t\t\t\tdouble yb=ys[b];\n\n\t\t\t\tdouble a=xb==xw?0:(double)(yb-yw)/(xb-xw);\n\t\t\t\tdouble y1=yw;\n\t\t\t\tdouble x1=xw;\n\n\t\t\t\tboolean f=true;\n\t\t\t\tfor(int i=0; i<n+m; i++){\n\t\t\t\t\tdouble x=xs[i];\n\t\t\t\t\tdouble y=ys[i];\n\t\t\t\t\tboolean on=false;\n\t\t\t\t\tif(xb!=xw){\n\t\t\t\t\t\tdouble y2=a*(x-x1)+y1;\n\t\t\t\t\t\tif(y+EPS<y2){\n\t\t\t\t\t\t\t// º\n\t\t\t\t\t\t\ts[i]=-1;\n\t\t\t\t\t\t}else if(y2+EPS<y){\n\t\t\t\t\t\t\t// ã\n\t\t\t\t\t\t\ts[i]=1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ton=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// c\n\t\t\t\t\t\tif(x+EPS<x1){\n\t\t\t\t\t\t\t// ¶\n\t\t\t\t\t\t\ts[i]=-1;\n\t\t\t\t\t\t}else if(x1+EPS<x){\n\t\t\t\t\t\t\t// E\n\t\t\t\t\t\t\ts[i]=1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ton=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(on){\n\t\t\t\t\t\t// ¼üó\n\t\t\t\t\t\tboolean fx=false;\n\t\t\t\t\t\tboolean fy=false;\n\t\t\t\t\t\tif(i<n){\n\t\t\t\t\t\t\t// black\n\t\t\t\t\t\t\tfx|=c(xw, xb, x);\n\t\t\t\t\t\t\tfx|=c(x, xb, xw);\n\t\t\t\t\t\t\tfy|=c(yw, yb, y);\n\t\t\t\t\t\t\tfy|=c(y, yb, yw);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t// white\n\t\t\t\t\t\t\tfx|=c(xb, xw, x);\n\t\t\t\t\t\t\tfx|=c(x, xw, xb);\n\t\t\t\t\t\t\tfy|=c(yb, yw, y);\n\t\t\t\t\t\t\tfy|=c(y, yw, yb);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(fx&&fy){\n\t\t\t\t\t\t\ts[i]=0;\n\t\t\t\t\t\t}else{\n/*\n  \t\t\t\t\t\t\tprintln(\"black:\"+xb+\",\"+yb);\n\t\t\t\t\t\t\tprintln(\"white:\"+xw+\",\"+yw);\n\t\t\t\t\t\t\tprintln(\"coor:\"+x+\",\"+y);\n\t\t\t\t\t\t\tprintln(\"NO\");\n\t\t\t\t\t\t\treturn;*/\n\t\t\t\t\t\t\tf=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// s[i]=(fx&&fy)?0:2;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// check\n\n\t\t\t\t// ã\\ÆÈé(Ìóâ)\n\t\t\t\tint s1=0, s2=0;\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(Math.abs(s[i])==1){\n\t\t\t\t\t\ts1=s[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i=n; i<n+m; i++){\n\t\t\t\t\tif(Math.abs(s[i])==1){\n\t\t\t\t\t\ts2=s[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 0©¯ê©Ì¸\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(s1*s[i]==-1){\n\t\t\t\t\t\tf=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i=n; i<n+m-1; i++){\n\t\t\t\t\tif(s2*s[i]==-1){\n\t\t\t\t\t\tf=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Ý¢Éá¤\n\t\t\t\t// Ðûª¼üó\n\t\t\t\t// 0,1\n\t\t\t\t// 0,-1\n\t\t\t\t// 1,-1\n\t\t\t\t// 1,1\n\t\t\t\t// -1,-1\n\t\t\t\tf&=s1*s2!=1;\n\t\t\t\tif(s1*s2!=1){\n\t\t\t\t\t// ok\n\t\t\t\t}\n\n\t\t\t\tif(f){\n/*\t\t\t\t\tprintln(\"s1:\"+s1);\n\t\t\t\t\tprintln(\"s2:\"+s2);\n\t\t\t\t\tprintln(\"black:\"+xb+\",\"+yb);\n\t\t\t\t\tprintln(\"white:\"+xw+\",\"+yw);\n\t\t\t\t\tprintln(Arrays.toString(s));*/\n\t\t\t\t\tprintln(\"YES\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(\"NO\");\n\t}\n\n\t// a<=b<=c\n\tboolean c(double a, double b, double c){\n\t\treturn a<b+EPS&&b<c+EPS;\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int TRY = 250000;\n\tpublic static final double EPS = 1E-10;\n\tpublic static final double R = 1E-4;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] x_pos = new int[n + m];\n\t\t\tint[] y_pos = new int[n + m];\n\t\t\t\n\t\t\tfor(int i = 0; i < n + m; i++){\n\t\t\t\tx_pos[i] = sc.nextInt();\n\t\t\t\ty_pos[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tdouble weight_x = Math.random() * 5000;\n\t\t\tdouble weight_y = Math.random() * 5000;\n\t\t\tdouble weight_const = Math.random() * 5000;\n\t\t\t\n\t\t\tboolean failed = false;\n\t\t\tint count = 0;\n\t\t\tdo{\n\t\t\t\tfailed = false;\n\t\t\t\t\n\t\t\t\t//System.out.println(count + \" \" + EPS + \" \" + R);\n\t\t\t\t//System.out.println(weight_x);\n\t\t\t\t//System.out.println(weight_y);\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n + m; i++){\n\t\t\t\t\tdouble output = weight_x * x_pos[i] + weight_y * y_pos[i] + weight_const;\n\t\t\t\t\t\n\t\t\t\t\tif(i < n && output < EPS || i >= n && output > -EPS){\n\t\t\t\t\t\tfinal double diff = i < n ? 1 : -1;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//System.out.println(\"error => \" + i + \" \" + x_pos[i] + \" \" + y_pos[i] + \" \" + diff + \" \" + output);\n\t\t\t\t\t\t\n\t\t\t\t\t\tweight_x += R * diff * x_pos[i];\n\t\t\t\t\t\tweight_y += R * diff * y_pos[i];\n\t\t\t\t\t\tweight_const += R * diff * 1;\n\t\t\t\t\t\tfailed = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(count >= TRY){\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcount++;\n\t\t\t}while(failed);\n\t\t\t\n\t\t\tif(count < TRY){\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\npublic class Main {\n\t\n\tComparator<Point2D> com = new Comparator<Point2D>() {\n\t\t\n\t\t@Override\n\t\tpublic int compare(Point2D o1, Point2D o2) {\n\t\t\tif(o1.getX() < o2.getX()) return -1;\n\t\t\telse if(o1.getX() < o2.getX()) return -1;\n\t\t\telse if(o1.getX() > o2.getX()) return 1;\n\t\t\telse if(o1.getY() < o2.getY()) return -1;\n\t\t\telse if(o1.getY() > o2.getY()) return 1;\n\t\t\telse  return 0;\n\t\t}\n\t};\n\t\n\t//1644 start\n\t//1726 sample match\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif((n | m) == 0) break;\n\t\t\tPoint2D [] nlist = new Point2D[n];\n\t\t\tPoint2D [] mlist = new Point2D[m];\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tnlist[i] = new Point2D.Double(x, y);\n\t\t\t}\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tmlist[i] = new Point2D.Double(x, y);\n\t\t\t}\n\t\t\t\n\t\t\tif(n == 1 && m == 1){\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(n == 1){\n\t\t\t\tPoint2D [] list2 = convexHull(mlist);\n\t\t\t\tboolean res1 = iscontains(list2, nlist[0]);\n\t\t\t\tif(res1){\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if(m == 1){\n\t\t\t\tPoint2D [] list1 = convexHull(nlist);\n\t\t\t\tboolean res1 = iscontains(list1, mlist[0]);\n\t\t\t\tif(res1){\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D [] list1 = convexHull(nlist);\n\t\t\tPoint2D [] list2 = convexHull(mlist);\n//\t\t\tSystem.out.println(Arrays.toString(list1));\n//\t\t\tSystem.out.println(Arrays.toString(list2));\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tboolean res = isintersect(list1, list2);\n\t\t\tif(res){\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.println(Arrays.toString(list1));\n\t\t\tboolean res1 = iscontains(list1, list2[0]);\n\t\t\tboolean res2 = iscontains(list2, list1[0]);\n\t\t\tif(res1 || res2){\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate boolean iscontains(Point2D[] list1, Point2D p) {\n\t\tint res = new Line2D.Double(list1[0], list1[1]).relativeCCW(p);\n\t\t//System.out.println(res+  \" res = \"  );\n\t\tint n = list1.length;\n\t\tfor(int i = 0 ; i < n; i++){\n\t\t\tint temp =  new Line2D.Double(list1[i], list1[(i+1) % n]).relativeCCW(p);\n\t\t\t//System.out.println(\"t = \" + temp);\n\t\t\tif(temp * res < 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate boolean isintersect(Point2D[] list1, Point2D[] list2) {\n\t\tint n = list1.length, m = list2.length;\n\t\tfor(int i = 0 ; i < list1.length; i++){\n\t\t\tfor(int j = 0 ; j < list2.length; j++){\n\t\t\t\tLine2D l1 = new Line2D.Double(list1[i], list1[(i+1) % n]);\n\t\t\t\tLine2D l2 = new Line2D.Double(list2[j], list2[(j+1) % m]);\n\t\t\t\tif(l1.intersectsLine(l2)){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate Point2D [] convexHull(Point2D [] plist){\n\t\tint n = plist.length;\n\t\tArrays.sort(plist, com);\n\t\tint k = 0;\n\t\tPoint2D [] qs = new Point2D[n*2];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\twhile(k > 1 && new Line2D.Double(qs[k-2], qs[k-1]).relativeCCW(plist[i]) > 0){\n\t\t\t\tk --;\n\t\t\t}\n\t\t\tqs[k++] = plist[i];\n\t\t}\n\t\tfor(int i = n-2, t = k; i >= 0; i--){\n\t\t\twhile(k > t && new Line2D.Double(qs[k-2], qs[k-1]).relativeCCW(plist[i]) > 0){\n\t\t\t\tk--;\n\t\t\t}\n\t\t\tqs[k++] = plist[i];\n\t\t}\n\t\tPoint2D [] res = Arrays.copyOf(qs, k-1);\n\t\treturn res;\n\t}\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Separate Points\npublic class Main{\n\n\tint n, m;\n\tdouble delta = 1e-10, EPS = 1e-10;\n\tdouble[][] b, w;\n\t\n\tboolean isLeft(double[] s, double[] t, double[] r){\n\t\tdouble x1 = t[0]-s[0], y1 = t[1]-s[1], x2 = r[0]-s[0], y2 = r[1]-s[1];\n\t\treturn x1*y2-x2*y1>0;\n\t}\n\tboolean isRight(double[] s, double[] t, double[] r){\n\t\tdouble x1 = t[0]-s[0], y1 = t[1]-s[1], x2 = r[0]-s[0], y2 = r[1]-s[1];\n\t\treturn x1*y2-x2*y1<0;\n\t}\n\t\n\tboolean div(double[] s, double[] t){\n\t\tint br = 0, bl = 0, wr = 0, wl = 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(isLeft(s, t, b[i]))bl++;\n\t\t\tif(isRight(s, t, b[i]))br++;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(isLeft(s, t, w[i]))wl++;\n\t\t\tif(isRight(s, t, w[i]))wr++;\n\t\t}\n//\t\tSystem.out.println(\"Black left:\"+bl+\" White right:\"+wr);\n//\t\tSystem.out.println(\"Black right:\"+br+\" White left:\"+wl);\n\t\tif(bl==n&&wr==m||br==n&&wl==m)return true;\n\t\tbr = bl = wr = wl = 0;\n\t\tdouble[] rs = new double[]{t[0], t[1]};\n\t\tdouble[] rt = new double[]{s[0], s[1]};\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(isLeft(rs, rt, b[i]))bl++;\n\t\t\tif(isRight(rs, rt, b[i]))br++;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(isLeft(rs, rt, w[i]))wl++;\n\t\t\tif(isRight(rs, rt, w[i]))wr++;\n\t\t}\n//\t\tSystem.out.println(\"Black left:\"+bl+\" White right:\"+wr);\n//\t\tSystem.out.println(\"Black right:\"+br+\" White left:\"+wl);\n\t\treturn bl==n&&wr==m||br==n&&wl==m;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn = sc.nextInt(); m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tb = new double[n][2]; w = new double[m][2];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<2;j++)b[i][j]=sc.nextDouble();\n\t\t\tfor(int i=0;i<m;i++)for(int j=0;j<2;j++)w[i][j]=sc.nextDouble();\n\t\t\tboolean f = false;\n\t\t\tfor(int i=0;i<n;i++)for(int j=i+1;j<n;j++){\n\t\t\t\tif(f)break;\n\t\t\t\tif(b[i][0]==b[i][1]){\n\t\t\t\t\tdouble[] s = new double[]{b[i][0]-delta, b[i][1]};\n\t\t\t\t\tdouble[] t = new double[]{b[j][0]-delta, b[j][1]};\n\t\t\t\t\tf |= div(s, t);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble[] s = new double[]{b[i][0], b[i][1]-delta};\n\t\t\t\tdouble[] t = new double[]{b[j][0], b[j][1]-delta};\n\t\t\t\tf |= div(s, t);\n\t\t\t\ts = new double[]{b[i][0], b[i][1]+delta};\n\t\t\t\tt = new double[]{b[j][0], b[j][1]+delta};\n\t\t\t\tf |= div(s, t);\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++)for(int j=i+1;j<m;j++){\n\t\t\t\tif(f)break;\n\t\t\t\tif(w[i][0]==w[i][1]){\n\t\t\t\t\tdouble[] s = new double[]{w[i][0]-delta, w[i][1]};\n\t\t\t\t\tdouble[] t = new double[]{w[j][0]-delta, w[j][1]};\n\t\t\t\t\tf |= div(s, t);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble[] s = new double[]{w[i][0], w[i][1]-delta};\n\t\t\t\tdouble[] t = new double[]{w[j][0], w[j][1]-delta};\n\t\t\t\tf |= div(s, t);\n\t\t\t\ts = new double[]{w[i][0], w[i][1]+delta};\n\t\t\t\tt = new double[]{w[j][0], w[j][1]+delta};\n\t\t\t\tf |= div(s, t);\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<m;j++){\n\t\t\t\tdouble[] mid = new double[]{(b[i][0]+w[j][0])/2, (b[i][1]+w[j][1])/2};\n\t\t\t\tdouble x = b[i][0]-w[j][0], y = b[i][1]-w[j][1];\n\t\t\t\tdouble dx = -y, dy = x;\n\t\t\t\tdouble[] t = new double[]{mid[0]+dx, mid[1]+dy};\n\t\t\t\tf |= div(mid, t);\n\t\t\t\tt = new double[]{mid[0]-dx, mid[1]-dy};\n\t\t\t\tf |= div(mid, t);\n\t\t\t\tif(f)break;\n\t\t\t}\n\t\t\tSystem.out.println(f?\"YES\":\"NO\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.*;\nimport java.util.*;\nimport java.awt.geom.*;\n\npublic class Main {\n    public static void main(String args[])throws Exception{\n        Scanner cin= new Scanner(System.in);\n\t\tint n,m;\n\t\tPoint2D.Double[] w = new Point2D.Double[200];\n\t\tPoint2D.Double[] b = new Point2D.Double[200];\n\t\tfor(;;){\n\t\t\tn=cin.nextInt();\n\t\t\tm=cin.nextInt();\n\t\t\t//\t\t\tSystem.out.printf(\"%d %d\\n\",n,m);\n\t\t\t\n\t\t\tif(n==0 && m==0) break;\n\t\t\t\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tw[i] = new Point2D.Double();\n\t\t\t\tw[i].x= cin.nextInt();\n\t\t\t\tw[i].y= cin.nextInt();\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tb[i] = new Point2D.Double();\n\t\t\t\tb[i].x= cin.nextInt();\n\t\t\t\tb[i].y= cin.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint f=0;\n\t\tout:\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\t\tint t1=0,t2=0;\n\t\t\t\t\t//\t\t\t\t\tSystem.out.printf(\"%d  %d\\n\",i,j);\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(k==i) continue;\n\t\t\t\t\t\tint ccw=Line2D.relativeCCW( w[k].x, w[k].y, w[i].x, w[i].y, b[j].x, b[j].y);\n\t\t\t\t\t\t//\t\t\t\t\t\tif(ccw==0) if(w[i].distance(b[j]) + w[i].distance(w[k]) <= w[k].distance(b[j])) ccw=1;\n\t\t\t\t\t\t//\t\t\t\t\t\tSystem.out.println(ccw);\n\t\t\t\t\t\tt1+=ccw;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<m;k++){\n\t\t\t\t\t\tif(k==j) continue;\n\t\t\t\t\t\tint ccw=Line2D.relativeCCW(b[k].x, b[k].y, b[j].x, b[j].y, w[i].x, w[i].y);\n\t\t\t\t\t\t//\t\t\t\t\t\tSystem.out.println(ccw);\n\t\t\t\t\t\t//\t\t\t\t\t\tif(ccw==0) if(b[j].distance(w[i]) + b[j].distance(b[k]) <= w[i].distance(b[k])) ccw=-1;\n\t\t\t\t\t\t//\t\t\t\t\t\tSystem.out.println(ccw);\n\t\t\t\t\t\tt2+=ccw;\n\t\t\t\t\t}\n\t\t\t\t\t//\t\t\t\t\tSystem.out.printf(\"t1,t2= %d,%d\\n\",t1,t2);\n\t\t\t\t\tif(t1>=0 && t2>=0 && Math.abs(t1)==n-1 && Math.abs(t2)==m-1){\n\t\t\t\t\t\tf=1;\n\t\t\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f==0) System.out.println(\"NO\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\npublic class Main {\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif((n|m) == 0) break;\n\t\t\t\n\t\t\tPoint2D [] p1 = new Point2D[n];\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tp1[i] = new Point2D.Double(x, y);\n\t\t\t}\n\t\t\tPoint2D [] p2 = new Point2D[m];\n\t\t\tfor(int i = 0 ; i < m; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tp2[i] = new Point2D.Double(x, y);\n\t\t\t}\n\t\t\t\n\t\t\tif(n == 1 && m == 1){\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(n == 1){\n\t\t\t\tp2 = convexHull(p2);\n\t\t\t\tif(iscontains(p2, p1)){\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(m == 1){\n\t\t\t\tp1 = convexHull(p1);\n\t\t\t\tif(iscontains(p1, p2)){\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tp1 = convexHull(p1);\n\t\t\tp2 = convexHull(p2);\n//\t\t\t\n//\t\t\t//debug\n//\t\t\tSystem.out.println(Arrays.toString(p1));\n//\t\t\tSystem.out.println(Arrays.toString(p2));\n\t\t\t\n\t\t\tif(isintersect(p1, p2)){\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(iscontains(p1, p2) || iscontains(p2, p1)){\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSystem.out.println(\"YES\");\n\t\t}\n\t}\n\n\tprivate boolean iscontains(Point2D[] p1, Point2D[] p2) {\n\t\tPoint2D p = p2[0];\n\t\tint prev = 1 << 24;;\n\t\tfor(int i = 0 ; i < p1.length; i++) {\n\t\t\tLine2D l = new Line2D.Double(p1[i], p1[(i+1) % p1.length]);\n\t\t\t\n\t\t\tint now = l.relativeCCW(p);\n\t\t\tif(prev != 1 << 24){\n\t\t\t\tif(now * prev  <= 0){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(now == 0){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tprev = now;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate boolean isintersect(Point2D[] p1, Point2D[] p2) {\n\t\tint n = p1.length;\n\t\tint m = p2.length;\n\t\tfor(int i = 0 ; i < n; i++){\n\t\t\tfor(int j = 0 ; j < m; j++){\n\t\t\t\tLine2D l = new Line2D.Double(p1[i], p1[(i + 1) % n]);\n\t\t\t\tLine2D l2 = new Line2D.Double(p2[j], p2[(j + 1) % m]);\n\t\t\t\tif(l.intersectsLine(l2)){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate Point2D[] convexHull(Point2D[] p) {\n\t\tint n = p.length;\n\t\tComparator<Point2D> com = new Comparator<Point2D>() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic int compare(Point2D a, Point2D b) {\n\t\t\t\tif(a.getX() < b.getX()) return -1;\n\t\t\t\tif(a.getX() > b.getX()) return 1;\n\t\t\t\tif(a.getY() < b.getY()) return -1;\n\t\t\t\tif(a.getY() > b.getY()) return 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t};\n\t\tArrays.sort(p, com );\n\t\tint k = 0;\n\t\tPoint2D [] qs = new Point2D[n * 2];\n\t\tfor(int i = 0 ; i  < n; i++){\n\t\t\twhile(k > 1 && new Line2D.Double(qs[k-2], qs[k-1]).relativeCCW(p[i]) > 0){\n\t\t\t\tk--;\n\t\t\t}\n\t\t\tqs[k++] = p[i];\n\t\t}\n\t\t\n\t\tfor(int i = n - 2, t = k; i >= 0; i--){\n\t\t\twhile(k > t && new Line2D.Double(qs[k-2], qs[k-1]).relativeCCW(p[i]) > 0){\n\t\t\t\tk--;\n\t\t\t}\n\t\t\tqs[k++] = p[i];\n\t\t}\n\t\tPoint2D [] res = Arrays.copyOf(qs, k-1);\n\t\treturn res;\n\t}\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tclass P {\n\t\tlong x;\n\t\tlong y;\n\n\t\tP(long x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tP org(P a) {\n\t\t\treturn new P(x - a.x, y - a.y);\n\t\t}\n\t\t\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tP b[] = new P[n];\n\t\t\tP w[] = new P[m];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tb[i] = new P(sc.nextLong(), sc.nextLong());\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tw[i] = new P(sc.nextLong(), sc.nextLong());\n\t\t\t}\n\n\t\t\tboolean ok = false;\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\n\t\t\t\t\tboolean check = true;\n\t\t\t\t\tP rot = b[i].org(w[j]);\n\t\t\t\t\t\n\t\t\t\t\tfor (int x = 0; x < n && check; x++) {\n\t\t\t\t\t\tif(i == x){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tP org = b[x].org(w[j]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tlong v = org.y * rot.x - org.x *rot.y;\n\t\t\t\t\t\tif(v < 0){\n\t\t\t\t\t\t\tcheck = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(v == 0){\n\t\t\t\t\t\t\tlong v2 =rot.x * org.x + rot.y*org.y;\n\t\t\t\t\t\t\tif(v2 < 0){\n\t\t\t\t\t\t\t\tcheck = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tfor (int x = 0; x < m && check; x++) {\n\t\t\t\t\t\tif(j == x){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tP org = w[x].org(w[j]);\n\t\t\t\t\t\tlong v = org.y * rot.x - org.x *rot.y;\n\t\t\t\t\t\tif(v > 0){\n\t\t\t\t\t\t\tcheck = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(v == 0){\n\t\t\t\t\t\t\tlong v2 =rot.x * org.x + rot.y*org.y;\n\t\t\t\t\t\t\tif(v2 > 0){\n\t\t\t\t\t\t\t\tcheck = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\n\t\t\t\t\tif(check){\n//\t\t\t\t\t\tSystem.out.println(i+\" \" + j);\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ok ? \"YES\" : \"NO\");\n\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] a) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tclass P {\n\t\tlong x;\n\t\tlong y;\n\n\t\tP(long x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tP org(P a) {\n\t\t\treturn new P(x - a.x, y - a.y);\n\t\t}\n\t\t\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tP b[] = new P[n];\n\t\t\tP w[] = new P[m];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tb[i] = new P(sc.nextLong(), sc.nextLong());\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tw[i] = new P(sc.nextLong(), sc.nextLong());\n\t\t\t}\n\n\t\t\tboolean ok = false;\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\n\t\t\t\t\tboolean check = true;\n\t\t\t\t\tP rot = b[i].org(w[j]);\n\t\t\t\t\t\n\t\t\t\t\tfor (int x = 0; x < n && check; x++) {\n\t\t\t\t\t\tif(i == x){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tP org = b[x].org(w[j]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tlong v = org.y * rot.x - org.x *rot.y;\n\t\t\t\t\t\tif(v < 0){\n\t\t\t\t\t\t\tcheck = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(v == 0){\n\t\t\t\t\t\t\tlong v2 =rot.x * org.x + rot.y*org.y;\n\t\t\t\t\t\t\tif(v2 < 0){\n\t\t\t\t\t\t\t\tcheck = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tfor (int x = 0; x < m && check; x++) {\n\t\t\t\t\t\tif(j == x){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tP org = w[x].org(w[j]);\n\t\t\t\t\t\tlong v = org.y * rot.x - org.x *rot.y;\n\t\t\t\t\t\tif(v > 0){\n\t\t\t\t\t\t\tcheck = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(v == 0){\n\t\t\t\t\t\t\tlong v2 =rot.x * org.x + rot.y*org.y;\n\t\t\t\t\t\t\tif(v2 > 0){\n\t\t\t\t\t\t\t\tcheck = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\n\t\t\t\t\tif(check){\n//\t\t\t\t\t\tSystem.out.println(i+\" \" + j);\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ok ? \"YES\" : \"NO\");\n\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] a) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.*;\nimport java.util.*;\nimport java.awt.geom.*;\n\npublic class mattya_1203_1 {\n    public static void main(String args[])throws Exception{\n        Scanner cin= new Scanner(System.in);\n\t\tint n,m;\n\t\tfor(;;){\n\t\t\tn=cin.nextInt();\n\t\t\tm=cin.nextInt();\n//\t\t\tSystem.out.printf(\"%d %d\\n\",n,m);\n\t\t\tif(n==0 && m==0) break;\n\t\t\t\n\t\t\tPoint2D.Double[] w = new Point2D.Double[200];\n\t\t\tPoint2D.Double[] b = new Point2D.Double[200];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tw[i].x= cin.nextInt();\n\t\t\t\tw[i].y= cin.nextInt();\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tb[i].x= cin.nextInt();\n\t\t\t\tb[i].y= cin.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint f=0;\n\t\t\tout:\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\t\tint t1=0,t2=0;\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(k==i) continue;\n\t\t\t\t\t\tint ccw=Line2D.relativeCCW(w[i].x, w[i].y, b[i].x, b[i].y, w[k].x, w[k].y);\n\t\t\t\t\t\tif(ccw==0) if(w[i].distance(b[j]) + w[i].distance(w[k]) <= w[k].distance(b[j]) + 0.0000000001) ccw=1;\n\t\t\t\t\t\tt1+=ccw;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<m;k++){\n\t\t\t\t\t\tif(k==j) continue;\n\t\t\t\t\t\tint ccw=Line2D.relativeCCW(w[i].x, w[i].y, b[i].x, b[i].y, b[k].x, b[k].y);\n\t\t\t\t\t\tif(ccw==0) if(b[j].distance(w[i]) + b[j].distance(b[k]) <= w[i].distance(b[k]) + 0.0000000001) ccw=-1;\n\t\t\t\t\t\tt1+=ccw;\n\t\t\t\t\t}\n\t\t\t\t\tif(t1*t2<=0 && Math.abs(t1)==n && Math.abs(t2)==m){\n\t\t\t\t\t\tf=1;\n\t\t\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f==0) System.out.println(\"NO\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Separate Points\npublic class Main{\n\n\tint n, m;\n\tdouble delta = 1e-10, EPS = 1e-10;\n\tdouble[][] b, w;\n\t\n\tboolean isLeft(double[] s, double[] t, double[] r){\n\t\tdouble x1 = t[0]-s[0], y1 = t[1]-s[1], x2 = r[0]-s[0], y2 = r[1]-s[1];\n\t\treturn x1*y2-x2*y1>0;\n\t}\n\tboolean isRight(double[] s, double[] t, double[] r){\n\t\tdouble x1 = t[0]-s[0], y1 = t[1]-s[1], x2 = r[0]-s[0], y2 = r[1]-s[1];\n\t\treturn x1*y2-x2*y1<0;\n\t}\n\t\n\tboolean div(double[] s, double[] t){\n\t\tint br = 0, bl = 0, wr = 0, wl = 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(isLeft(s, t, b[i]))bl++;\n\t\t\tif(isRight(s, t, b[i]))br++;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(isLeft(s, t, w[i]))wl++;\n\t\t\tif(isRight(s, t, w[i]))wr++;\n\t\t}\n//\t\tSystem.out.println(\"Black left:\"+bl+\" White right:\"+wr);\n//\t\tSystem.out.println(\"Black right:\"+br+\" White left:\"+wl);\n\t\tif(bl==n&&wr==m||br==n&&wl==m)return true;\n\t\tif(bl!=0&&br!=0&&wl!=0&&wr!=0)return false;\n\t\tbr = bl = wr = wl = 0;\n\t\tdouble[] rs = new double[]{t[0], t[1]};\n\t\tdouble[] rt = new double[]{s[0], s[1]};\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(isLeft(rs, rt, b[i]))bl++;\n\t\t\tif(isRight(rs, rt, b[i]))br++;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(isLeft(rs, rt, w[i]))wl++;\n\t\t\tif(isRight(rs, rt, w[i]))wr++;\n\t\t}\n//\t\tSystem.out.println(\"Black left:\"+bl+\" White right:\"+wr);\n//\t\tSystem.out.println(\"Black right:\"+br+\" White left:\"+wl);\n\t\treturn bl==n&&wr==m||br==n&&wl==m;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn = sc.nextInt(); m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tb = new double[n][2]; w = new double[m][2];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<2;j++)b[i][j]=sc.nextDouble();\n\t\t\tfor(int i=0;i<m;i++)for(int j=0;j<2;j++)w[i][j]=sc.nextDouble();\n\t\t\tboolean f = false;\n\t\t\tfor(int i=0;i<n;i++)for(int j=i+1;j<n;j++){\n\t\t\t\tif(f)break;\n\t\t\t\tif(b[i][0]==b[i][1]){\n\t\t\t\t\tdouble[] s = new double[]{b[i][0]-delta, b[i][1]};\n\t\t\t\t\tdouble[] t = new double[]{b[j][0]-delta, b[j][1]};\n\t\t\t\t\tf |= div(s, t);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble[] s = new double[]{b[i][0], b[i][1]-delta};\n\t\t\t\tdouble[] t = new double[]{b[j][0], b[j][1]-delta};\n\t\t\t\tf |= div(s, t);\n\t\t\t\ts = new double[]{b[i][0], b[i][1]+delta};\n\t\t\t\tt = new double[]{b[j][0], b[j][1]+delta};\n\t\t\t\tf |= div(s, t);\n\t\t\t}\n\t\t\tif(!f)\n\t\t\tfor(int i=0;i<m;i++)for(int j=i+1;j<m;j++){\n\t\t\t\tif(f)break;\n\t\t\t\tif(w[i][0]==w[i][1]){\n\t\t\t\t\tdouble[] s = new double[]{w[i][0]-delta, w[i][1]};\n\t\t\t\t\tdouble[] t = new double[]{w[j][0]-delta, w[j][1]};\n\t\t\t\t\tf |= div(s, t);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble[] s = new double[]{w[i][0], w[i][1]-delta};\n\t\t\t\tdouble[] t = new double[]{w[j][0], w[j][1]-delta};\n\t\t\t\tf |= div(s, t);\n\t\t\t\ts = new double[]{w[i][0], w[i][1]+delta};\n\t\t\t\tt = new double[]{w[j][0], w[j][1]+delta};\n\t\t\t\tf |= div(s, t);\n\t\t\t}\n\t\t\tif(!f)\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<m;j++){\n\t\t\t\tdouble[] mid = new double[]{(b[i][0]+w[j][0])/2, (b[i][1]+w[j][1])/2};\n\t\t\t\tdouble x = b[i][0]-w[j][0], y = b[i][1]-w[j][1];\n\t\t\t\tdouble dx = -y, dy = x;\n\t\t\t\tdouble[] t = new double[]{mid[0]+dx, mid[1]+dy};\n\t\t\t\tf |= div(mid, t);\n\t\t\t\tt = new double[]{mid[0]-dx, mid[1]-dy};\n\t\t\t\tf |= div(mid, t);\n\t\t\t\tif(f)break;\n\t\t\t}\n\t\t\tSystem.out.println(f?\"YES\":\"NO\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedWriter;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic class Main {\n\tpublic static void main(String[] args) throws NumberFormatException,\n\tIOException {Solve solve = new Solve();solve.solve();}\n}\nclass Solve{\n\tvoid dump(int[]a){for(int i=0;i<a.length;i++)System.out.print(a[i]+\" \");System.out.println();}\n\tvoid dump(int[]a,int n){for(int i=0;i<a.length;i++)System.out.printf(\"%\"+n+\"d\",a[i]);System.out.println();}\n\tvoid dump(long[]a){for(int i=0;i<a.length;i++)System.out.print(a[i]+\" \");System.out.println();}\n\tvoid dump(char[]a){for(int i=0;i<a.length;i++)System.out.print(a[i]);System.out.println();}\n\tString itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tfinal ContestScanner in = new ContestScanner();\n\t\tWriter out = new Writer();\n\t\tfinal double EPS = 1e-9;\n\t\twhile(true){\n\t\t\tint[] n = new int[2];\n\t\t\tfor(int i=0; i<2; i++) n[i] = in.nextInt();\n\t\t\tif(n[0]==n[1] && n[0]==0) break;\n\t\t\tint[][] x = new int[2][];\n\t\t\tint[][] y = new int[2][];\n\t\t\tCircle[][] c = new Circle[2][];\n\t\t\tfor(int i=0; i<2; i++){\n\t\t\t\tc[i] = new Circle[n[i]];\n\t\t\t\tx[i] = new int[n[i]];\n\t\t\t\ty[i] = new int[n[i]];\n\t\t\t\tfor(int j=0; j<n[i]; j++){\n\t\t\t\t\tx[i][j] = in.nextInt();\n\t\t\t\t\ty[i][j] = in.nextInt();\n\t\t\t\t\tc[i][j] = new Circle(x[i][j], y[i][j], 1e-6);\n\t\t\t\t}\n\t\t\t}\n\t\t\tList<SLine> line = new ArrayList<>();\n\t\t\tfor(int i=0; i<n[0]; i++){\n\t\t\t\tfor(int j=0; j<n[1]; j++){\n\t\t\t\t\tline.addAll(Circle.innerTangent(c[0][i], c[1][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean ok = false;\n\t\t\tout:for(SLine l: line){\n\t\t\t\tfor(int i=0; i<2; i++){\n\t\t\t\t\tif(n[i]==0) continue;\n\t\t\t\t\tboolean sign = l.sign(c[i][0].p);\n\t\t\t\t\tfor(int j=1; j<n[i]; j++){\n\t\t\t\t\t\tif(sign != l.sign(c[i][j].p)) continue out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(ok) System.out.println(\"YES\");\n\t\t\telse System.out.println(\"NO\");\n\t\t}\n\t}\n}\n\nclass Circle{\n\tfinal static double EPS = 1e-8;\n\tPos p;\n\tdouble r;\n\tpublic Circle(double x, double y, double r){\n\t\tp = new Pos(x, y);\n\t\tthis.r = r;\n\t}\n\tCircle copy(){\n\t\treturn new Circle(p.x, p.y, r);\n\t}\n\tpublic Pos[] crossPos(Circle c){\n\t\tif(!cross(c)) return null;\n\t\tdouble x1 = c.p.x - p.x;\n\t\tdouble y1 = c.p.y - p.y;\n\t\tdouble a = (x1*x1+y1*y1+r*r-c.r*c.r)/2.0;\n\t\tPos[] res = {\n\t\t\t\tnew Pos(culc(x1, y1, r, a, true)+p.x, culc(y1, x1, r, a, false)+p.y),\n\t\t\t\tnew Pos(culc(x1, y1, r, a, false)+p.x, culc(y1, x1, r, a, true)+p.y),\n\t\t};\n\t\treturn res;\n\t}\n\tprivate static double culc(double x, double y, double r, double a, boolean sign){\n\t\treturn (a*x + (sign?1:-1)*y*Math.sqrt((x*x+y*y)*r*r-a*a)+EPS)/(x*x+y*y);\n\t}\n\tpublic boolean cross(Circle c){\n\t\treturn p.dist2(c.p) <= (r+c.r)*(r+c.r) + EPS;\n\t}\n\tpublic static List<SLine> tangent(Circle c1, Circle c2){return tangent(c1, c2, 0, 2);}\n\tpublic static List<SLine> innerTangent(Circle c1, Circle c2){return tangent(c1, c2, 0, 1);}\n\tpublic static List<SLine> outerTangent(Circle c1, Circle c2){return tangent(c1, c2, 1, 2);}\n\tprivate static List<SLine> tangent(Circle c1, Circle c2, final int s, final int t){\n\t\tCircle co1 = new Circle(0, 0, c1.r);\n\t\tCircle co2 = new Circle(c2.p.x-c1.p.x, c2.p.y-c1.p.y, c2.r);\n\t\tfinal double[] rd = {c1.r+c2.r, c1.r-c2.r};\n\t\tList<SLine> res = new ArrayList<>();\n\t\tfinal int[] signX = {1, -1};\n\t\tfinal int[] signY = {-1, 1};\n\t\tfor(int i=s; i<t; i++){\n\t\t\tfinal double norm2 = co1.p.dist2(co2.p);\n\t\t\tfinal double D = norm2-sq(rd[i]);\n\t\t\tif(D<0) continue;\n\t\t\tfor(int j=0; j<2; j++)\n\t\t\t\tres.add(tangent(co1,\n\t\t\t\t\t\tnew Pos(c1.r*(co2.p.x*rd[i]+signX[j]*co2.p.y*Math.sqrt(D))/norm2,\n\t\t\t\t\t\t\t\tc1.r*(co2.p.y*rd[i]+signY[j]*co2.p.x*Math.sqrt(D))/norm2\n\t\t\t\t\t\t\t\t)).move(c1.p.x, c1.p.y)\n\t\t\t\t\t\t);\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static SLine tangent(Circle c1, Pos p){\n\t\treturn new SLine(p.x-c1.p.x, p.y-c1.p.y\n\t\t\t\t, -(c1.p.x*(p.x-c1.p.x)+c1.p.y*(p.y-c1.p.y)+c1.r*c1.r));\n\t}\n\tpublic static double sq(double a){\n\t\treturn a*a;\n\t}\n}\n\nclass SLine{\n\t// ??´???\n\tdouble a, b, c;\n\tSLine(double a, double b, double c){\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t\tif(a==0 && b==0) throw new ArithmeticException();\n\t}\n\tdouble dist(Pos p){\n\t\treturn Math.abs(a*p.x+b*p.y+c)/Math.sqrt(a*a+b*b);\n\t}\n\tSLine move(double dx, double dy){\n\t\t// dx, dy?????????????§????\n\t\tc += -dx*a-dy*b;\n\t\treturn this;\n\t}\n\tboolean sign(Pos p){\n\t\tif(b==0) return p.x<-c/a;\n\t\tdouble y = (-a*p.x-c)/b;\n\t\treturn p.y>y;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn a+\"x + \"+b+\"y + \"+c+\" = 0\\t( y = \"+(-a/b)+\"x + \"+(-c/b)+\")\";\n\t}\n}\n\nclass Pos implements Comparable<Pos>{\n\tstatic final double EPS = 1e-10;\n\tdouble x, y;\n\tpublic Pos(double x, double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\tpublic Pos copy(){\n\t\treturn new Pos(x, y);\n\t}\n\tpublic Pos resizeVec(double size){\n\t\tdouble sq = Math.sqrt(x*x+y*y);\n\t\treturn new Pos(x*size/sq, y*size/sq);\n\t}\n\tpublic double dist2(Pos p){\n\t\treturn (x-p.x)*(x-p.x) + (y-p.y)*(y-p.y);\n\t}\n\t@Override\n\tpublic int compareTo(Pos o) {\n\t\tif(Math.abs(x-o.x) >= EPS) return Double.compare(x, o.x);\n\t\tif(Math.abs(y-o.y) >= EPS) return Double.compare(y, o.y);\n\t\treturn 0;\n\t}\n}\n\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override\n\tpublic Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key)\n\t{final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n}\nclass Timer{\n\tlong time;\n\tpublic void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print()\n\t{System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner {\n\tprivate InputStreamReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new InputStreamReader(System.in);}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new InputStreamReader(new FileInputStream(filename));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif((n|m) == 0) break;\n\t\t\t\n\t\t\tint[] wx = new int[n], wy = new int[n];\n\t\t\tint[] bx = new int[m], by = new int[m];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\twx[i] = sc.nextInt(); wy[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tbx[i] = sc.nextInt(); by[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tboolean ok = false;\n\t\t\tfor(int i=0;i<n;i++) for(int j=0;j<m;j++) {\n\t\t\t\tboolean flg = true;\n\t\t\t\tArrayList<P> on = new ArrayList<P>();\n\t\t\t\t\n\t\t\t\tint v = 0;\n\t\t\t\tfor(int k=0;k<n;k++) {\n\t\t\t\t\tint tmp = cross(wx[i], wy[i], bx[j], by[j], wx[k], wy[k]);\n\t\t\t\t\tif(tmp == 0) on.add(new P(wx[k], wy[k], true));\n\t\t\t\t\tif(tmp == -v && v != 0) { flg = false; break; }\n\t\t\t\t\tif(tmp != 0) v = tmp;\n\t\t\t\t}\n\t\t\t\tif(!flg) continue;\n\t\t\t\tv = -v;\n\t\t\t\tfor(int k=0;k<m;k++) {\n\t\t\t\t\tint tmp = cross(wx[i], wy[i], bx[j], by[j], bx[k], by[k]);\n\t\t\t\t\tif(tmp == 0) on.add(new P(bx[k], by[k], false));\n\t\t\t\t\tif(tmp == -v && v != 0) { flg = false; break; }\n\t\t\t\t\tif(tmp != 0) v = tmp;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!flg) continue;\n\t\t\t\tsort(on);\n//\t\t\t\tfor(P p: on) debug(p.x, p.y, p.c);\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor(int k=1;k<on.size();k++) if(on.get(k).c ^ on.get(k-1).c) cnt++;\n\t\t\t\t\n\t\t\t\tif(cnt <= 1) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println((ok? \"YES\": \"NO\"));\n\t\t}\n\t}\n\t\n\tint cross( int x1, int y1, int x2, int y2, int x, int y ) {\n\t\tif( (x1 - x2) * (y - y1) ==  (x - x1) * (y1 - y2)) return 0;\n\t\treturn (x1 - x2) * (y - y1) < (x - x1) * (y1 - y2)? -1: 1;\n\t}\n\t\n\tclass P implements Comparable<P> {\n\t\tint x, y; boolean c;\n\t\tP(int x, int y, boolean c) {\n\t\t\tthis.x = x; this.y = y; this.c = c;\n\t\t}\n\t\t\n\t\tpublic int compareTo(P arg0) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\tif(x != arg0.x) return x - arg0.x;\n\t\t\treturn y - arg0.y;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int TRY = 50000000;\n\tpublic static final double EPS = 1E-10;\n\tpublic static final double R = 1E-0;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] x_pos = new int[n + m];\n\t\t\tint[] y_pos = new int[n + m];\n\t\t\t\n\t\t\tfor(int i = 0; i < n + m; i++){\n\t\t\t\tx_pos[i] = sc.nextInt();\n\t\t\t\ty_pos[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tdouble weight_x = Math.random() * 5000;\n\t\t\tdouble weight_y = Math.random() * 5000;\n\t\t\tdouble weight_const = Math.random() * 5000;\n\t\t\t\n\t\t\tboolean failed = false;\n\t\t\tint count = 0;\n\t\t\tdo{\n\t\t\t\tfailed = false;\n\t\t\t\t\n\t\t\t\t//System.out.println(count + \" \" + EPS + \" \" + R);\n\t\t\t\t//System.out.println(weight_x);\n\t\t\t\t//System.out.println(weight_y);\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n + m; i++){\n\t\t\t\t\tdouble output = weight_x * x_pos[i] + weight_y * y_pos[i] + weight_const;\n\t\t\t\t\t\n\t\t\t\t\tif(i < n && output < EPS || i >= n && output > -EPS){\n\t\t\t\t\t\tfinal double diff = i < n ? 1 : -1;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//System.out.println(\"error => \" + i + \" \" + x_pos[i] + \" \" + y_pos[i] + \" \" + diff + \" \" + output);\n\t\t\t\t\t\t\n\t\t\t\t\t\tweight_x += R * diff * x_pos[i];\n\t\t\t\t\t\tweight_y += R * diff * y_pos[i];\n\t\t\t\t\t\tweight_const += R * diff * 1;\n\t\t\t\t\t\tfailed = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(count >= TRY){\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcount++;\n\t\t\t}while(failed);\n\t\t\t\n\t\t\tif(count < TRY){\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tMain(){\n\t\tnew AOJ1298();\n//\t\tSystem.out.println(Line2D.relativeCCW(0, 0, 0, 2, 0.00000001, 1));\n\t}\n\t\n\t\n\tclass AOJ1298{\n\t\tint N,M;\n\t\tAOJ1298(){\n//\t\t\tSystem.out.println(CCW(new Point2D.Double(0,0), new Point2D.Double(0, 2), new Point2D.Double(-1, 0) ));\n\t\t\twhile(true){\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tM=sc.nextInt();\n\t\t\t\tif((N|M)==0)\tbreak;\n\t\t\t\tSystem.out.println( solve()? \"YES\": \"NO\");\n\t\t\t}\n\t\t}\n\t\tboolean solve(){\n\t\t\tPoint2D[] b=new Point2D[N],\n\t\t\t\t\tw=new Point2D[M];\n\t\t\tfor(int i=0; i<N; ++i)\tb[i]=new Point2D.Double(sc.nextInt(), sc.nextInt());\n\t\t\tfor(int i=0; i<M; ++i)\tw[i]=new Point2D.Double(sc.nextInt(), sc.nextInt());\n\t\t\t\n\t\t\tif(N==1 && M==1){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tif(N>=3)\tb = convexHull(b);\n\t\t\tif(M>=3)\tw = convexHull(w);\n\t\t\t\n\t\t\tN=b.length;\tM=w.length;\n\t\t\t\n//\t\t\treturn f(b,w)&&f(w,b);\n\t\t\tif(N>M)\treturn f(b,w);\n\t\t\telse\treturn f(w,b);\n\t\t}\n\t\t\n\t\tboolean f(Point2D[] n,Point2D[] m){\n\t\t\tN=n.length;\tM=m.length;\n\t\t\t\n//\t\t\tSystem.out.println(Arrays.toString(n));\n//\t\t\tSystem.out.println(Arrays.toString(m));\n\t\t\t\n\t\t\tif(M==1&&N==2){\n\t\t\t\tLine2D l = new Line2D.Double(n[0], n[1]);\n\t\t\t\tif(CCW(l, m[0]) == 0 && l.ptLineDist(m[0]) < EPS)\treturn false;\n\t\t\t\telse\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t}else if(N==2 && M==2){\n\t\t\t\tLine2D l1 = new Line2D.Double(n[0],n[1]),\n\t\t\t\t\t\tl2 = new Line2D.Double(m[0],m[1]);\n\t\t\t\tif(l1.intersectsLine(l2)){\n\t\t\t\t\treturn false;\n\t\t\t\t}else{\n\t\t\t\t\tif( segSegDist(l1, l2) < EPS)\treturn false;\n\t\t\t\t\telse\t\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// N>=3 \n\t\t\t\tfor(int i=0; i<M; ++i){\n\t\t\t\t\tboolean b = false;\n\t\t\t\t\tfor(int j=0; j<N; ++j){\n//\t\t\t\t\t\tSystem.out.println(CCW(n[j], n[(j+1)%N], m[i]));\n//\t\t\t\t\t\tSystem.out.println(n[j]+\" \"+n[(j+1)%N]+\" \"+m[i]);\n\t\t\t\t\t\tif(CCW(n[j], n[(j+1)%N], m[i]) > 0){\n\t\t\t\t\t\t\tb = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println(m[i]+\" \"+b);\n\t\t\t\t\tif(!b)\treturn false;\n\t\t\t\t}\n\t\t\t\tif(M>=3){\n\t\t\t\t\tfor(int i=0; i<N; ++i){\n\t\t\t\t\t\tboolean b = false;\n\t\t\t\t\t\tfor(int j=0; j<M; ++j){\n//\t\t\t\t\t\t\tSystem.out.println(CCW(m[j], m[(j+1)%M], n[i]));\n//\t\t\t\t\t\t\tSystem.out.println(m[j]+\" \"+m[(j+1)%M]+\" \"+n[i]);\n\t\t\t\t\t\t\tif(CCW(m[j], m[(j+1)%M], n[i]) > 0){\n\t\t\t\t\t\t\t\tb = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n//\t\t\t\t\t\tSystem.out.println(n[i]+\" \"+b);\n\t\t\t\t\t\tif(!b)\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal double EPS=1.0e-8;\n\t\tdouble segSegDist(Line2D l1,Line2D l2){\n\t\t\treturn l1.intersectsLine(l2)? 0 :Math.min(Math.min(l1.ptSegDist(l2.getP1()), l1.ptSegDist(l2.getP2())) , Math.min(l2.ptSegDist(l1.getP1()), l2.ptSegDist(l1.getP2())));\n\t\t}\n\t\tint CCW(Line2D l, Point2D p3){\n\t\t\treturn CCW(l.getP1(), l.getP2(), p3);\n\t\t}\n\t\tprivate int CCW(Point2D p1, Point2D p2, Point2D p3){\n\t\t\tPoint2D p3p1 = sub(p3, p1);\n\t\t\tPoint2D p3p2 = sub(p3, p2);\n\t\t\tdouble res = cross(p3p1, p3p2);\n\t\t\tif(Math.abs(res) < EPS) return 0;\n\t\t\telse if(res < EPS) return 1;\n\t\t\telse return -1;\n\t\t}\n\t\tdouble cross(Point2D p1,Point2D p2){\n\t\t\treturn p1.getX()*p2.getY() - p2.getX()*p1.getY();\n\t\t}\n\t\tdouble dot(Point2D p1,Point2D p2){\n\t\t\treturn p1.getX()*p2.getX() + p1.getY()*p2.getY();\n\t\t}\n\t\tPoint2D sum(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()+p2.getX(), p1.getY()+p2.getY());\n\t\t}\n\t\tPoint2D add(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()+p2.getX(), p1.getY()+p2.getY());\n\t\t}\n\t\tPoint2D diff(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(), p1.getY()-p2.getY());\n\t\t}\n\t\tPoint2D sub(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(), p1.getY()-p2.getY());\n\t\t}\n\t\tPoint2D mid(Line2D l1){\n\t\t\treturn mid(l1.getP1(),l1.getP2());\n\t\t}\n\t\tPoint2D mid(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double((p1.getX()+p2.getX())/2, (p1.getY()+p2.getY())/2);\n\t\t}\n\t\tPoint2D mul(double n,Point2D p1){\n\t\t\treturn new Point2D.Double(p1.getX()*n, p1.getY()*n);\n\t\t}\n\t\tComparator< Point2D > com = new Comparator< Point2D >() {\n\t\t\tpublic int compare(Point2D o1, Point2D o2) {\n\t\t\t\tif(o1.getX() < o2.getX()) return -1;\n\t\t\t\telse if(o1.getX() > o2.getX()) return 1;\n\t\t\t\telse if(o1.getY() < o2.getY()) return -1;\n\t\t\t\telse if(o1.getY() > o2.getY()) return 1;\n\t\t\t\telse return 0;\n\t\t\t}\n\t\t};\n\t\tprivate Point2D [] convexHull(Point2D [] plist) {\n\t\t\tint n = plist.length;\n\t\t\tArrays.sort(plist, com);\n\t\t\tint k = 0;\n\t\t\tPoint2D [] qs = new Point2D[n * 2];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\twhile(k > 1 && new Line2D.Double(qs[k-2] , qs[k-1]).relativeCCW(plist[i]) > 0){\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t\tqs[k++] = plist[i];\n\t\t\t}\n\t\t\tfor(int i = n - 2, t = k; i >= 0; i--){\n\t\t\t\twhile(k > t && new Line2D.Double(qs[k-2] , qs[k-1]).relativeCCW(plist[i]) > 0){\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t\tqs[k++] = plist[i];\n\t\t\t}\n\t\t\tPoint2D [] res = Arrays.copyOf(qs, k-1);\n\t\t\treturn res;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int TRY = 500000;\n\tpublic static final double EPS = 1E-10;\n\tpublic static final double R = 1E-4;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] x_pos = new int[n + m];\n\t\t\tint[] y_pos = new int[n + m];\n\t\t\t\n\t\t\tfor(int i = 0; i < n + m; i++){\n\t\t\t\tx_pos[i] = sc.nextInt();\n\t\t\t\ty_pos[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tdouble weight_x = Math.random() * 5000;\n\t\t\tdouble weight_y = Math.random() * 5000;\n\t\t\tdouble weight_const = Math.random() * 5000;\n\t\t\t\n\t\t\tboolean failed = false;\n\t\t\tint count = 0;\n\t\t\tdo{\n\t\t\t\tfailed = false;\n\t\t\t\t\n\t\t\t\t//System.out.println(count + \" \" + EPS + \" \" + R);\n\t\t\t\t//System.out.println(weight_x);\n\t\t\t\t//System.out.println(weight_y);\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n + m; i++){\n\t\t\t\t\tdouble output = weight_x * x_pos[i] + weight_y * y_pos[i] + weight_const;\n\t\t\t\t\t\n\t\t\t\t\tif(i < n && output < EPS || i >= n && output > -EPS){\n\t\t\t\t\t\tfinal double diff = i < n ? 1 : -1;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//System.out.println(\"error => \" + i + \" \" + x_pos[i] + \" \" + y_pos[i] + \" \" + diff + \" \" + output);\n\t\t\t\t\t\t\n\t\t\t\t\t\tweight_x += R * diff * x_pos[i];\n\t\t\t\t\t\tweight_y += R * diff * y_pos[i];\n\t\t\t\t\t\tweight_const += R * diff * 1;\n\t\t\t\t\t\tfailed = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(count >= TRY){\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcount++;\n\t\t\t}while(failed);\n\t\t\t\n\t\t\tif(count < TRY){\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Ruby",
    "code": "loop do\n\tn, m = gets.split.map(&:to_i)\n\tbreak if n == 0\n\tpoints = []\n\tn.times do\n\t\tpoints << [*gets.split.map(&:to_i), 1]\n\tend\n\tm.times do\n\t\tpoints << [*gets.split.map(&:to_i), -1]\n\tend\n\tpoints.sort_by!(&:first)\n\t\n\tok = false\n\tpoints.combination(2) do |(x1, y1, _), (x2, y2, _)|\n\t\tcatch(:exit) do\n\t\t\ta = y1 - y2\n\t\t\tb = x2 - x1\n\t\t\tc = a * x1 + b * y1\n\t\t\ton_line = []\n\n\t\t\tchange = false\n\t\t\tprev_sign = nil\n\t\t\tpoints.each do |x, y, color|\n\t\t\t\tsign = (a * x + b * y - c) * color\n\t\t\t\tif sign == 0\n\t\t\t\t\ton_line << color\n\t\t\t\telse\n\t\t\t\t\tif prev_sign\n\t\t\t\t\t\tthrow :exit if prev_sign * sign < 0\n\t\t\t\t\telse\n\t\t\t\t\t\tprev_sign = sign\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\ton_line.reverse! if on_line.size > 0 && on_line[0] > 0\t\t\n\t\t\tif on_line == on_line.sort\n\t\t\t\tok = true\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\n\tputs ok ? 'YES' : 'NO'\nend"
  },
  {
    "language": "Ruby",
    "code": "### classes\n\nclass Pt\n  attr_accessor :x, :y\n\n  def initialize() end\n  def initialize(x, y) @x = x; @y = y end\n\n  def ==(pt) @x == pt.x && @y == pt.y end\n  def +(pt) Pt.new(@x + pt.x, @y + pt.y) end\n  def -(pt) Pt.new(@x - pt.x, @y - pt.y) end\n  def -@() Pt.new(-@x, -@y) end\n  def *(t) Pt.new(@x * t, @y * t) end\n  def /(t) Pt.new(@x / t, @y / t) end\n  def dot(v) @x * v.x + @y * v.y end\n  def cross(v) @x * v.y - @y * v.x end\n  def d2() @x * @x + @y * @y end\n  def d() Math.sqrt(d2()) end\n  def normalize() self / d() end\n  def to_s() \"(#{@x},#{@y})\" end\nend\n\n### subroutines\n\ndef extract_convex(pts)\n  n = pts.length\n  return pts if n == 1\n\n  ci = sti = (0...n).min{|a, b| pts[a].y <=> pts[b].y}\n  cpt = pts[ci]\n  cv = Pt.new(1, 0)\n  cvd = 1.0\n  #p [ci, cpt.to_s, cv.to_s, cvd]\n  \n  cvx = [cpt]\n  used = Array.new(n){false}\n\n  loop do\n    max_cos = -2.0\n    max_i = nil\n    \n    for i in (0...n)\n      next if used[i] || i == ci\n      vi = pts[i] - cpt\n\n      if cv.cross(vi) >= 0\n        vid = vi.d\n        cos = cv.dot(vi) / (cvd * vid)\n        if max_cos < cos\n          max_cos = cos\n          max_i = i\n        end\n      end\n      #p [max_cos, max_i]\n    end\n\n    break if max_i == sti\n\n    npt = pts[max_i]\n    cvx << npt\n    cv = npt - cpt\n    cvd = cv.d\n    cpt = npt\n    ci = max_i\n    #p [ci, cpt.to_s, cv.to_s, cvd]\n  end\n\n  cvx\nend\n\ndef outer?(pts, cvx)\n  ncvx = cvx.length\n\n  for i in (0...ncvx)\n    vi = cvx[(i + 1) % ncvx] - cvx[i]\n    out = true\n    for pt in pts\n      if vi.cross(pt - cvx[i]) >= 0\n        out = false\n        break\n      end\n    end\n    return true if out\n  end\n  false\nend\n\ndef cross_segs?(seg0, seg1)\n  p0, p1 = seg0\n  q0, q1 = seg1\n  pv = p1 - p0\n  qv = q1 - q0\n\n  crpq = pv.cross(q0 - p0) * pv.cross(q1 - p0)\n  crqp = qv.cross(p0 - q0) * qv.cross(p1 - q0)\n\n  if crpq != 0 || crqp != 0\n    return (crpq < 0 && crqp < 0)\n  end\n\n  (q0 - p0).dot(q1 - p0) < 0 ||\n    (q0 - p1).dot(q1 - p1) < 0 ||\n    (p0 - q0).dot(p1 - q0) < 0 ||\n    (p0 - q1).dot(p1 - q1) < 0\nend\n\n### main\n\nloop do\n  n, m = gets.split.map(&:to_i)\n  break if (n | m) == 0\n\n  bs = n.times.map{Pt.new(*gets.split.map(&:to_i))}\n  ws = m.times.map{Pt.new(*gets.split.map(&:to_i))}\n  #p bs.map{|pt| pt.to_s}\n  #p ws.map{|pt| pt.to_s}\n\n  bcvx = extract_convex(bs)\n  wcvx = extract_convex(ws)\n  nbcvx = bcvx.length\n  nwcvx = wcvx.length\n  #p [\"bcvx\", bcvx.map{|pt| pt.to_s}]\n  #p [\"wcvx\", wcvx.map{|pt| pt.to_s}]\n\n  if nbcvx == 1 && nwcvx == 1\n    puts 'YES'\n  elsif nbcvx == 1\n    puts outer?(bcvx, wcvx) ? 'YES' : 'NO'\n  elsif nwcvx == 1\n    puts outer?(wcvx, bcvx) ? 'YES' : 'NO'\n  elsif nbcvx == 2 && nwcvx == 2\n    puts (! cross_segs?(bcvx, wcvx)) ? 'YES' : 'NO'\n  else\n    puts (outer?(bcvx, wcvx) || outer?(wcvx, bcvx)) ? 'YES' : 'NO'\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    n, m = gets.split.map(&:to_i)\n    break if n == 0\n    points = []\n    n.times do\n        points << [*gets.split.map(&:to_i), 1]\n    end \n    m.times do\n        points << [*gets.split.map(&:to_i), -1] \n    end \n    \n    ok = false\n    points.combination(2) do |(x1, y1, _), (x2, y2, _)| \n        a = y1 - y2\n        b = x2 - x1\n        c = a * x1 + b * y1\n        on_line = []\n        signs = []\n        points.each do |x, y, color|\n            sign = (a * x + b * y - c) * color\n            if sign == 0\n                on_line << [x, color]\n            else\n                signs << sign\n            end\n        end\n        next unless signs.all? {|s| s >= 0} or signs.all? {|s| s <= 0}\n    \n        on_line = on_line.sort_by(&:first).map(&:last)\n        on_line.reverse! if on_line.size > 0 && on_line[0] > 0    \n        if on_line == on_line.sort\n            ok = true\n            break\n        end\n    end \n\n    puts ok ? 'YES' : 'NO'\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n\tn, m = gets.split.map(&:to_i)\n\tbreak if n == 0\n\tpoints = []\n\tn.times do\n\t\tpoints << [*gets.split.map(&:to_i), 1]\n\tend\n\tm.times do\n\t\tpoints << [*gets.split.map(&:to_i), -1]\n\tend\n\tpoints.sort!\n\t\n\tok = false\n\tcatch(:exit1) do\n\t\tpoints.combination(2) do |(x1, y1, _), (x2, y2, _)|\n\t\t\tcatch(:exit2) do\n\t\t\t\ta = y1 - y2\n\t\t\t\tb = x2 - x1\n\t\t\t\tc = a * x1 + b * y1\n\t\t\t\ton_line = []\n\n\t\t\t\tprev_sign = nil\n\t\t\t\tpoints.each do |x, y, color|\n\t\t\t\t\tsign = (a * x + b * y - c) * color\n\t\t\t\t\tif sign == 0\n\t\t\t\t\t\ton_line << color\n\t\t\t\t\telse\n\t\t\t\t\t\tif prev_sign\n\t\t\t\t\t\t\tthrow :exit2 if prev_sign * sign < 0\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tprev_sign = sign\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\t\ton_line.reverse! if on_line.size > 0 && on_line[0] > 0\t\t\n\t\t\t\tif on_line == on_line.sort\n\t\t\t\t\tok = true\n\t\t\t\t\tthrow :exit1\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\tputs ok ? 'YES' : 'NO'\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst EPS = 1e-9;\n\nstruct Point {\n    double x, y;\n    double norm() const { return sqrt(x * x + y * y); }\n    Point unit() const {\n        double l = norm();\n        return Point(x / l, y / l);\n    }\n    Point opBinary(alias op)(in Point p) const {\n        return Point(mixin(\"x\" ~ op ~ \"p.x\"), mixin(\"y\" ~ op ~ \"p.y\"));\n    }\n    Point opBinary(alias op)(double a) const {\n        return Point(mixin(\"x\" ~ op ~ \"a\"), mixin(\"y\" ~ op ~ \"a\"));\n    }\n    static double Distance(in Point a, in Point b) {\n        return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n    }\n    static double Dot(in Point a, in Point b) { return a.x * b.x + a.y * b.y; }\n    static double Cross(in Point a, in Point b) { return a.x * b.y - a.y * b.x; }\n    static int CCW(Point a, Point b, Point c){\n        b = b - a; c = c - a;\n        if (Cross(b, c) > EPS) return +1; // テ・ツ渉催ヲツ卍づィツィツ暗・ツ堕ィテ」ツつ?\n        if (Cross(b, c) < -EPS) return -1; // テヲツ卍づィツィツ暗・ツ堕ィテ」ツつ?\n        if (Dot(b, c) < 0) return +2; // c--a--b テァツ崢エテァツキツ?\n        if (b.norm() < c.norm()) return -2; // a--b--c テァツ崢エテァツキツ?\n        return 0; // a--c--b テァツ崢エテァツキツ?\n    }\n};\n\nstruct Segment {\n    Point a, b;\n    bool contains(in Point p) const {\n        return Point.CCW(a, b, p) == 0;\n    }\n    bool intersect(in Segment s) const {\n        return Point.CCW(a, b, s.a) * Point.CCW(a, b, s.b) <= 0 &&\n            Point.CCW(s.a, s.b, a) * Point.CCW(s.a, s.b, b) <= 0;\n    }\n}\n\nstruct Polygon {\n    Point[] vs;\n    bool edgesContain(in Point p) const {\n        foreach (i; 0 .. vs.length) {\n            auto s = Segment(vs[i], vs[next(i)]);\n            if (s.contains(p)) return true;\n        }\n        return false;\n    }\n    bool contains(in Point p) const {\n        if (edgesContain(p)) return false;\n        int Count = 0;\n        foreach (i; 0 .. vs.length) {\n            Point p1 = vs[i],\n                  p2 = vs[next(i)];\n            if (p1.y > p2.y) swap(p1, p2);\n            if ( (p1.y - p.y) <= 0 && 0 < (p2.y - p.y) && Point.CCW(p1, p2, p) == 1)\n                Count++;\n        }\n        return Count % 2 == 1;\n    }\n    bool isConvex() {\n        foreach (i; 0 .. vs.length) {\n            Point a = vs[prev(i)], b = vs[i], c = vs[next(i)];\n            if (Point.CCW(a, b, c) != 1) return false;\n        }\n        return true;\n    }\n    size_t next(size_t i) const {\n        return (i + 1) % vs.length;\n    }\n    size_t prev(size_t i) const {\n        return (i + vs.length - 1) % vs.length;\n    }\n    /* テ、ツクツ偲」ツ?暗」ツつ嘉」ツつ古」ツ?淌ァツつケテゥツ崢?・ツ青暗」ツ?ョテ・ツ?クテ・ツ個?」ツつ津」ツ?凝」ツ?暗」ツ??\n     * psテ」ツ?ッ3テ」ツ?、テ、ツサツ・テ、ツクツ甘」ツ?ョティツヲツ?ァツエツ?」ツつ津ヲツ個?」ツ?淌」ツ?ュテ」ツ?ーテ」ツ?ェテ」ツつ嘉」ツ?ェテ」ツ??\n     *\n     * テ」ツ?禿」ツ?ョテ・ツョツ淌ィツ」ツ?」ツ?ッテ・ツ?クテ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ョティツソツ氾、ツクツ甘」ツ?ォテ・ツュツ佚・ツ慊ィテ」ツ?凖」ツつ凝ァツつケテ」ツつづ・ツ青ォテ」ツつ?」ツつ?\n     * テ・ツ?クテ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ョテゥツ?づァツつケテ」ツ?ョテ」ツ?ソテ」ツ?古・ツソツ?ィツヲツ?」ツ?ェテ・ツ?エテ・ツ青暗」ツ?ッ 144, 148ティツ。ツ古ァツ崢ョテ」ツ?ョ2テ」ツ?、テァツ崢ョテ」ツ?ョテヲツ敖。テ、ツサツカテ」ツつ?\n     * Point::CCW(Ret[k - 2], Ret[k - 1], ps[i] <= 0)テ」ツ?ォテ・ツ、ツ嘉ヲツ崢エテ」ツ?凖」ツつ?*/\n    static Polygon convexHull(Point[] ps) {\n        ps.sort!\"a.x < b.x\";\n        auto N = ps.length;\n        int k = 0;\n        auto Ret = new Point[N * 2];\n        for (int i = 0; i < N; Ret[k++] = ps[i++]) {\n            while (k >= 2 && Point.CCW(Ret[k - 2], Ret[k - 1], ps[i]) == -1)\n                k--;\n        }\n        for (int i = cast(int)N - 2, t = k + 1; i >= 0; Ret[k++] = ps[i--]) {\n            while (k >= t && Point.CCW(Ret[k - 2], Ret[k - 1], ps[i]) == -1)\n                k--;\n        }\n        Ret = Ret[0 .. k - 1];\n        return Polygon(Ret);\n    }\n};\n\nvoid main() {\n    int N, M;\n    Point[] B, W;\n    bool input() {\n        scanf(\"%d %d\\n\", &N, &M);\n        if (N == 0 && M == 0) return false;\n        B.clear; W.clear;\n        foreach (i; 0 .. N) {\n            int x, y;\n            scanf(\"%d %d\\n\", &x, &y);\n            B ~= Point(x, y);\n        }\n        foreach (i; 0 .. M) {\n            int x, y;\n            scanf(\"%d %d\\n\", &x, &y);\n            W ~= Point(x, y);\n        }\n        return true;\n    }\n    bool check(in Polygon a, in Polygon b) {\n        foreach (i; 0 .. a.vs.length) {\n            foreach (j; 0 .. b.vs.length) {\n                if (a.contains(b.vs[j])) return false;\n                if (b.contains(a.vs[i])) return false;\n                auto s = Segment(a.vs[i], a.vs[(i + 1) % a.vs.length]);\n                auto t = Segment(b.vs[j], b.vs[(j + 1) % b.vs.length]);\n                if (s.intersect(t)) return false;\n            }\n        }\n        return true;\n    }\n    void solve() {\n        static if (false) {\n            writeln([N, M]);\n            writeln(B);\n            writeln(W);\n        }\n        if (N < M) {\n            swap(N, M);\n            swap(B, W);\n        }\n        if (N == 1) {\n            writeln(\"YES\");\n        } else if (N == 2) {\n            if (M == 1) {\n                writeln(Segment(B[0], B[1]).contains(W[0]) ? \"NO\" : \"YES\");\n            } else {\n                writeln(Segment(B[0], B[1]).intersect(Segment(W[0], W[1])) ? \"NO\" : \"YES\");\n            }\n        } else {\n            Polygon a = Polygon.convexHull(B);\n            Polygon b = Polygon.convexHull(W);\n            writeln(check(a, b) ? \"YES\" : \"NO\");\n        }\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\ndef dot3(O, A, B):\n    ox, oy = O; ax, ay = A; bx, by = B\n    return (ax - ox) * (bx - ox) + (ay - oy) * (by - oy)\ndef cross3(O, A, B):\n    ox, oy = O; ax, ay = A; bx, by = B\n    return (ax - ox) * (by - oy) - (bx - ox) * (ay - oy)\ndef dist2(A, B):\n    ax, ay = A; bx, by = B\n    return (ax - bx) ** 2 + (ay - by) ** 2\ndef is_intersection(P0, P1, Q0, Q1):\n    C0 = cross3(P0, P1, Q0)\n    C1 = cross3(P0, P1, Q1)\n    if C0 == C1 == 0:\n        E0 = dot3(P0, P1, Q0)\n        E1 = dot3(P0, P1, Q1)\n        if not E0 < E1:\n            E0, E1 = E1, E0\n        return 0 <= E1 and E0 <= dist2(P0, P1)\n    D0 = cross3(Q0, Q1, P0)\n    D1 = cross3(Q0, Q1, P1)\n    return C0 * C1 <= 0 and D0 * D1 <= 0\n\ndef convex_polygons_intersection(ps, qs):\n    pl = len(ps); ql = len(qs)\n    i = j = 0\n    while (i < pl or j < ql) and (i < 2*pl) and (j < 2*ql):\n        px0, py0 = ps0 = ps[(i-1)%pl]; px1, py1 = ps1 = ps[i%pl]\n        qx0, qy0 = qs0 = qs[(j-1)%ql]; qx1, qy1 = qs1 = qs[j%ql]\n\n        if is_intersection(ps0, ps1, qs0, qs1):\n            return 1\n\n        ax = px1 - px0; ay = py1 - py0\n        bx = qx1 - qx0; by = qy1 - qy0\n\n        v = (ax*by - bx*ay)\n        va = cross3(qs0, qs1, ps1)\n        vb = cross3(ps0, ps1, qs1)\n\n        if v == 0 and va < 0 and vb < 0:\n            return 0\n        if v == 0 and va == 0 and vb == 0:\n            i += 1\n        elif v >= 0:\n            if vb > 0:\n                i += 1\n            else:\n                j += 1\n        else:\n            if va > 0:\n                j += 1\n            else:\n                i += 1\n    return 0\n\ndef convex_hull(ps):\n    qs = []\n    n = len(ps)\n    for p in ps:\n        while len(qs)>1 and cross3(qs[-1], qs[-2], p) >= 0:\n            qs.pop()\n        qs.append(p)\n    t = len(qs)\n    for i in range(n-2, -1, -1):\n        p = ps[i]\n        while len(qs)>t and cross3(qs[-1], qs[-2], p) >= 0:\n            qs.pop()\n        qs.append(p)\n    return qs\n\ndef inside_convex_polygon(p0, qs):\n    L = len(qs)\n    left = 1; right = L\n    q0 = qs[0]\n    while left+1 < right:\n        mid = (left + right) >> 1\n        if cross3(q0, p0, qs[mid]) <= 0:\n            left = mid\n        else:\n            right = mid\n    if left == L-1:\n        left -= 1\n    qi = qs[left]; qj = qs[left+1]\n    v0 = cross3(q0, qi, qj)\n    v1 = cross3(q0, p0, qj)\n    v2 = cross3(q0, qi, p0)\n    if v0 < 0:\n        v1 = -v1; v2 = -v2\n    return 0 <= v1 and 0 <= v2 and v1 + v2 <= v0\n\ndef solve():\n    N, M = map(int, readline().split())\n    if N == M == 0:\n        return False\n\n    P = [list(map(int, readline().split())) for i in range(N)]\n    Q = [list(map(int, readline().split())) for i in range(M)]\n\n    P.sort()\n    Q.sort()\n    if N > 2:\n        P = convex_hull(P)[:-1]\n    if M > 2:\n        Q = convex_hull(Q)[:-1]\n\n    if N < 3 or M < 3:\n        if not N < M:\n            N, M = M, N\n            P, Q = Q, P\n        ok = 0\n        if N == 1:\n            if M == 1:\n                ok = 1\n            elif M == 2:\n                ok = not is_intersection(P[0], P[0], Q[0], Q[1])\n            else:\n                ok = not inside_convex_polygon(P[0], Q)\n        elif N == 2:\n            if M == 2:\n                ok = not is_intersection(P[0], P[1], Q[0], Q[1])\n            else:\n                ok = not (inside_convex_polygon(P[0], Q) or inside_convex_polygon(P[1], Q))\n                for i in range(M):\n                    ok &= not is_intersection(P[0], P[1], Q[i-1], Q[i])\n        write(\"YES\\n\" if ok else \"NO\\n\")\n        return True\n\n\n    if (convex_polygons_intersection(P, Q)\n            or inside_convex_polygon(P[0], Q)\n            or inside_convex_polygon(Q[0], P)):\n        write(\"NO\\n\")\n    else:\n        write(\"YES\\n\")\n    return True\nwhile solve():\n    ...\n"
  },
  {
    "language": "Python",
    "code": "def dot(c1, c2):\n    return c1.real * c2.real + c1.imag * c2.imag\n\ndef cross(c1, c2):\n    return c1.real * c2.imag - c1.imag * c2.real\n\ndef on_segment(p, a, b):\n    # whether p is on segment ab\n    v1 = a - p\n    v2 = b - p\n    return cross(v1, v2) == 0 and dot(v1, v2) < 0\n\ndef ccw(p0, p1, p2):\n    return cross(p1 - p0, p2 - p0) > 0\n\ndef intersect(p1, p2, p3, p4):\n    crs1 = cross(p2 - p1, p3 - p1)\n    crs2 = cross(p2 - p1, p4 - p1)\n    if crs1 == 0 and crs2 == 0:\n        return dot(p1 - p3, p2 - p3) < 0 or dot(p1 - p4, p2 - p4) < 0\n    crs3 = cross(p4 - p3, p1 - p3)\n    crs4 = cross(p4 - p3, p2 - p3)\n    return crs1 * crs2 <= 0 and crs3 * crs4 <= 0\n\ndef andrew(point_list):\n    # assume that point_list has been sorted\n    u = []\n    l = []\n    u.append(point_list[0])\n    u.append(point_list[1])\n    l.append(point_list[-1])\n    l.append(point_list[-2])\n    # outward\n    for p in point_list[2:]:\n        while ccw(u[-2], u[-1], p):\n            u.pop()\n            if len(u) == 1:\n                break\n        u.append(p)\n    # homeward\n    for p in point_list[-3::-1]:\n        while ccw(l[-2], l[-1], p):\n            l.pop()\n            if len(l) == 1:\n                break\n        l.append(p)\n    # concatenate\n    u.pop()\n    l.pop()    \n    return u + l\n\ndef contains(polygon, point):\n    for p1, p2 in zip(polygon, polygon[1:] + polygon[:1]):\n        a = p1 - point\n        b = p2 - point\n        cross_ab = cross(a, b)\n        if cross_ab > 0:\n            return False\n        elif cross_ab == 0 and dot(a, b) > 0:\n            return False\n    return True\n\ndef string_to_complex(s):\n    x, y = map(int, s.split())\n    return x + y * 1j\n\ndef solve():\n    from sys import stdin\n    file_input = stdin\n    lines = file_input.readlines()\n    while True:\n        n, m = map(int, lines[0].split())\n        if n == 0 and m == 0:\n            break\n        \n        if n == 1 and m == 1:\n            print('YES')\n            lines = lines[1+n+m:]\n            continue\n        \n        pts1 = map(string_to_complex, lines[1:1+n])\n        pts2 = map(string_to_complex, lines[1+n:1+n+m])\n        \n        if n == 1 and m == 2:\n            if on_segment(next(pts1), *pts2):\n                print('NO')\n            else:\n                print('YES')\n                \n        elif n == 2 and m == 1:\n            if on_segment(next(pts2), *pts1):\n                print('NO')\n            else:\n                print('YES')\n                \n        elif n == 2 and m == 2:\n            if intersect(*pts1, *pts2):\n                print('NO')\n            else:\n                print('YES')\n        \n        elif n == 1:\n            p = next(pts1)\n            cvx = andrew(sorted(pts2, key=lambda c: (c.real, c.imag)))\n            if contains(cvx, p):\n                print('NO')\n            else:\n                print('YES')\n        \n        elif m == 1:\n            p = next(pts1)\n            cvx = andrew(sorted(pts1, key=lambda c: (c.real, c.imag)))\n            if contains(cvx, p):\n                print('NO')\n            else:\n                print('YES')\n        \n        elif n == 2:\n            p1, p2 = pts1\n            cvx = andrew(sorted(pts2, key=lambda c: (c.real, c.imag)))\n            if contains(cvx, p1) or contains(cvx, p2):\n                print('NO')\n            else:\n                for p3, p4 in zip(cvx, cvx[1:] + cvx[:1]):\n                    if intersect(p1, p2, p3, p4):\n                        print('NO')\n                        break\n                else:\n                    print('YES')\n        \n        elif m == 2:\n            p1, p2 = pts2\n            cvx = andrew(sorted(pts1, key=lambda c: (c.real, c.imag)))\n            if contains(cvx, p1) or contains(cvx, p2):\n                print('NO')\n            else:\n                for p3, p4 in zip(cvx, cvx[1:] + cvx[:1]):\n                    if intersect(p1, p2, p3, p4):\n                        print('NO')\n                        break\n                else:\n                    print('YES')\n        \n        else:\n            cvx1 = andrew(sorted(pts1, key=lambda c: (c.real, c.imag)))\n            cvx2 = andrew(sorted(pts2, key=lambda c: (c.real, c.imag)))\n            for p in cvx2:\n                if contains(cvx1, p):\n                    print('NO')\n                    break\n            else:\n                for p in cvx1:\n                    if contains(cvx2, p):\n                        print('NO')\n                        break\n                else:\n                    for p1, p2 in zip(cvx1, cvx1[1:] + cvx1[:1]):\n                        for p3, p4 in zip(cvx2, cvx2[1:] + cvx2[:1]):\n                            if intersect(p1, p2, p3, p4):\n                                print('NO')\n                                break\n                        else:\n                            continue\n                        break\n                    else:\n                        print('YES')\n        \n        lines = lines[1+n+m:]\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef _kosa(a1, a2, b1, b2):\n    x1,y1 = a1\n    x2,y2 = a2\n    x3,y3 = b1\n    x4,y4 = b2\n\n    tc = (x1-x2)*(y3-y1)+(y1-y2)*(x1-x3)\n    td = (x1-x2)*(y4-y1)+(y1-y2)*(x1-x4)\n    return tc*td < 0\n\ndef kosa(a1, a2, b1, b2):\n    return _kosa(a1,a2,b1,b2) and _kosa(b1,b2,a1,a2)\n\ndef distance(x1, y1, x2, y2):\n    return math.sqrt((x1-x2)**2 + (y1-y2)**2)\n\ndef distance_p(a, b):\n    return distance(a[0], a[1], b[0], b[1])\n\ndef distance3(p1, p2, p3):\n    x1,y1 = p1\n    x2,y2 = p2\n    x3,y3 = p3\n\n    ax = x2 - x1\n    ay = y2 - y1\n    bx = x3 - x1\n    by = y3 - y1\n\n    r = (ax*bx + ay*by) / (ax*ax + ay*ay)\n    if r <= 0:\n        return distance_p(p1, p3)\n    if r >= 1:\n        return distance_p(p2, p3)\n    pt = (x1 + r*ax, y1 + r*ay, 0)\n    return distance_p(pt, p3)\n\ndef ccw(a, b, c):\n    ax = b[0] - a[0]\n    ay = b[1] - a[1]\n    bx = c[0] - a[0]\n    by = c[1] - a[1]\n    t = ax*by - ay*bx;\n    if t > 0:\n        return 1\n    if t < 0:\n        return -1\n    if ax*bx + ay*by < 0:\n        return 2\n    if ax*ax + ay*ay < bx*bx + by*by:\n        return -2\n    return 0\n\ndef convex_hull(ps):\n    n = len(ps)\n    if n < 3:\n        return ps[:]\n    k = 0\n    ps.sort()\n    ch = [None] * (n*2)\n    for i in range(n):\n        while k >= 2 and ccw(ch[k-2], ch[k-1], ps[i]) <= 0:\n            k -= 1\n        ch[k] = ps[i]\n        k += 1\n    t = k + 1\n    for i in range(n-2,-1,-1):\n        while k >= t and ccw(ch[k-2], ch[k-1], ps[i]) <= 0:\n            k -= 1\n        ch[k] = ps[i]\n        k += 1\n\n    return ch[:k-1]\n\ndef main():\n    rr = []\n\n    def f(n,m):\n        a = [LI() for _ in range(n)]\n        b = [LI() for _ in range(m)]\n        t = convex_hull(a + b)\n        af = bf = False\n        for c in t:\n            if c in a:\n                af = True\n            else:\n                bf = True\n        if not af or not bf:\n            return 'NO'\n        d = convex_hull(a)\n        e = convex_hull(b)\n        dl = len(d)\n        el = len(e)\n        if dl > 1:\n            for i in range(dl):\n                d1 = d[i]\n                d2 = d[(i+1) % dl]\n                for j in range(el):\n                    k = distance3(d1,d2,e[j])\n                    if k < eps:\n                        return 'NO'\n                    if el > 1 and kosa(d1,d2,e[j],e[(j+1)%el]):\n                        return 'NO'\n        if el > 1:\n            for i in range(el):\n                e1 = e[i]\n                e2 = e[(i+1) % el]\n                for j in range(dl):\n                    k = distance3(e1,e2,d[j])\n                    if k < eps:\n                        return 'NO'\n\n\n        return 'YES'\n\n    while 1:\n        n,m = LI()\n        if n == 0:\n            break\n        rr.append(f(n,m))\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  }
]