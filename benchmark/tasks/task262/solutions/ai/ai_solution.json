[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint check_line(Point a, Point b, Point c) {\n    return (b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y);\n}\n\nint can_separate(Point* black, int black_count, Point* white, int white_count) {\n    if (black_count == 0 || white_count == 0) return 1;\n\n    for (int i = 0; i < black_count; i++) {\n        for (int j = 0; j < black_count; j++) {\n            if (i == j) continue;\n            int valid = 1;\n            int side_black = 0, side_white = 0;\n\n            for (int k = 0; k < black_count; k++) {\n                int res = check_line(black[i], black[j], black[k]);\n                if (res != 0) {\n                    if (side_black == 0) {\n                        side_black = res > 0 ? 1 : -1;\n                    } else if ((res > 0 && side_black == -1) || (res < 0 && side_black == 1)) {\n                        valid = 0;\n                        break;\n                    }\n                }\n            }\n\n            if (!valid) continue;\n\n            for (int k = 0; k < white_count; k++) {\n                int res = check_line(black[i], black[j], white[k]);\n                if (res != 0) {\n                    if (side_white == 0) {\n                        side_white = res > 0 ? 1 : -1;\n                    } else if ((res > 0 && side_white == -1) || (res < 0 && side_white == 1)) {\n                        valid = 0;\n                        break;\n                    }\n                } else {\n                    valid = 0;\n                    break;\n                }\n            }\n\n            if (!valid) continue;\n\n            if (side_black * side_white <= 0) {\n                return 1;\n            }\n        }\n    }\n\n    for (int i = 0; i < white_count; i++) {\n        for (int j = 0; j < white_count; j++) {\n            if (i == j) continue;\n            int valid = 1;\n            int side_black = 0, side_white = 0;\n\n            for (int k = 0; k < white_count; k++) {\n                int res = check_line(white[i], white[j], white[k]);\n                if (res != 0) {\n                    if (side_white == 0) {\n                        side_white = res > 0 ? 1 : -1;\n                    } else if ((res > 0 && side_white == -1) || (res < 0 && side_white == 1)) {\n                        valid = 0;\n                        break;\n                    }\n                }\n            }\n\n            if (!valid) continue;\n\n            for (int k = 0; k < black_count; k++) {\n                int res = check_line(white[i], white[j], black[k]);\n                if (res != 0) {\n                    if (side_black == 0) {\n                        side_black = res > 0 ? 1 : -1;\n                    } else if ((res > 0 && side_black == -1) || (res < 0 && side_black == 1)) {\n                        valid = 0;\n                        break;\n                    }\n                } else {\n                    valid = 0;\n                    break;\n                }\n            }\n\n            if (!valid) continue;\n\n            if (side_black * side_white <= 0) {\n                return 1;\n            }\n        }\n    }\n\n    return 0;\n}\n\nint main() {\n    int black_count, white_count;\n    scanf(\"%d %d\", &black_count, &white_count);\n\n    Point black[black_count], white[white_count];\n    for (int i = 0; i < black_count; i++) {\n        scanf(\"%d %d\", &black[i].x, &black[i].y);\n    }\n    for (int i = 0; i < white_count; i++) {\n        scanf(\"%d %d\", &white[i].x, &white[i].y);\n    }\n\n    printf(\"%s\\n\", can_separate(black, black_count, white, white_count) ? \"YES\" : \"NO\");\n    return 0;\n}",
    "timestamp": "2025-08-05 20:48:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <utility>\nusing namespace std;\n\nbool isSeparable(const vector<pair<int, int>>& blackPoints, const vector<pair<int, int>>& whitePoints) {\n    if (blackPoints.empty() || whitePoints.empty()) return true;\n\n    auto checkLine = [](const pair<int, int>& p1, const pair<int, int>& p2, const pair<int, int>& p) {\n        return (p2.first - p1.first) * (p.second - p1.second) - (p2.second - p1.second) * (p.first - p1.first);\n    };\n\n    for (size_t i = 0; i < blackPoints.size(); ++i) {\n        for (size_t j = i + 1; j < blackPoints.size(); ++j) {\n            const auto& p1 = blackPoints[i];\n            const auto& p2 = blackPoints[j];\n            int side = 0;\n            bool valid = true;\n\n            for (const auto& p : blackPoints) {\n                int s = checkLine(p1, p2, p);\n                if (s == 0) continue;\n                if (side == 0) side = s;\n                else if (s * side < 0) { valid = false; break; }\n            }\n\n            if (valid) {\n                side = 0;\n                for (const auto& p : whitePoints) {\n                    int s = checkLine(p1, p2, p);\n                    if (s == 0) continue;\n                    if (side == 0) side = -s;\n                    else if (s * side < 0) { valid = false; break; }\n                }\n                if (valid) return true;\n            }\n        }\n    }\n\n    for (size_t i = 0; i < whitePoints.size(); ++i) {\n        for (size_t j = i + 1; j < whitePoints.size(); ++j) {\n            const auto& p1 = whitePoints[i];\n            const auto& p2 = whitePoints[j];\n            int side = 0;\n            bool valid = true;\n\n            for (const auto& p : whitePoints) {\n                int s = checkLine(p1, p2, p);\n                if (s == 0) continue;\n                if (side == 0) side = s;\n                else if (s * side < 0) { valid = false; break; }\n            }\n\n            if (valid) {\n                side = 0;\n                for (const auto& p : blackPoints) {\n                    int s = checkLine(p1, p2, p);\n                    if (s == 0) continue;\n                    if (side == 0) side = -s;\n                    else if (s * side < 0) { valid = false; break; }\n                }\n                if (valid) return true;\n            }\n        }\n    }\n\n    return false;\n}",
    "timestamp": "2025-08-05 20:49:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class LineSeparator {\n    public static boolean isLineSeparable(int[][] blackPoints, int[][] whitePoints) {\n        if (blackPoints.length == 0 || whitePoints.length == 0) {\n            return true;\n        }\n        \n        // Check all possible lines between pairs of points from different colors\n        for (int[] black : blackPoints) {\n            for (int[] white : whitePoints) {\n                int x1 = black[0], y1 = black[1];\n                int x2 = white[0], y2 = white[1];\n                \n                // Line equation: (y2 - y1)(x - x1) - (x2 - x1)(y - y1) = 0\n                // Compute for all points\n                int a = y2 - y1;\n                int b = x1 - x2;\n                int c = x2 * y1 - x1 * y2;\n                \n                int sideBlack = 0;\n                boolean valid = true;\n                \n                // Check black points\n                for (int[] p : blackPoints) {\n                    int val = a * p[0] + b * p[1] + c;\n                    if (sideBlack == 0) {\n                        sideBlack = val > 0 ? 1 : (val < 0 ? -1 : 0);\n                    } else {\n                        if ((val > 0 && sideBlack == -1) || (val < 0 && sideBlack == 1)) {\n                            valid = false;\n                            break;\n                        }\n                    }\n                }\n                \n                if (!valid) continue;\n                \n                // Check white points\n                int sideWhite = 0;\n                for (int[] p : whitePoints) {\n                    int val = a * p[0] + b * p[1] + c;\n                    if (sideWhite == 0) {\n                        sideWhite = val > 0 ? 1 : (val < 0 ? -1 : 0);\n                    } else {\n                        if ((val > 0 && sideWhite == -1) || (val < 0 && sideWhite == 1)) {\n                            valid = false;\n                            break;\n                        }\n                    }\n                }\n                \n                if (!valid) continue;\n                \n                // Check if all points are not on the line and sides are opposite\n                if (sideBlack * sideWhite <= 0) {\n                    continue;\n                }\n                \n                return true;\n            }\n        }\n        \n        // Check if all points are colinear\n        if (areAllColinear(blackPoints) && areAllColinear(whitePoints)) {\n            int[] lineBlack = getLine(blackPoints);\n            int[] lineWhite = getLine(whitePoints);\n            if (lineBlack[0] * lineWhite[0] + lineBlack[1] * lineWhite[1] == 0) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    private static boolean areAllColinear(int[][] points) {\n        if (points.length <= 2) {\n            return true;\n        }\n        int[] p1 = points[0];\n        int[] p2 = points[1];\n        int a = p2[1] - p1[1];\n        int b = p1[0] - p2[0];\n        int c = p2[0] * p1[1] - p1[0] * p2[1];\n        \n        for (int i = 2; i < points.length; i++) {\n            int[] p = points[i];\n            if (a * p[0] + b * p[1] + c != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    private static int[] getLine(int[][] points) {\n        int[] p1 = points[0];\n        int[] p2 = points[1];\n        int a = p2[1] - p1[1];\n        int b = p1[0] - p2[0];\n        return new int[]{a, b};\n    }\n}",
    "timestamp": "2025-08-05 20:49:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "class Solution {\n    public boolean canSeparate(int[][] points, boolean[] colors) {\n        int n = points.length;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (canLineSeparate(points, colors, points[i], points[j])) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    private boolean canLineSeparate(int[][] points, boolean[] colors, int[] p1, int[] p2) {\n        int n = points.length;\n        boolean blackOnOneSide = true;\n        boolean whiteOnOneSide = true;\n        \n        for (int i = 0; i < n; i++) {\n            int side = crossProduct(p1, p2, points[i]);\n            \n            if (side > 0) {\n                if (!colors[i]) {\n                    blackOnOneSide = false;\n                }\n            } else if (side < 0) {\n                if (colors[i]) {\n                    whiteOnOneSide = false;\n                }\n            }\n            \n            if (!blackOnOneSide && !whiteOnOneSide) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    private int crossProduct(int[] p1, int[] p2, int[] p3) {\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0]);\n    }\n}",
    "timestamp": "2025-08-05 20:49:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdbool.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y;\n    bool is_black;\n} Point;\n\nint cross_product(Point p1, Point p2, Point p3) {\n    return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);\n}\n\nbool can_separate_points(Point* points, int n) {\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            bool all_black_one_side = true;\n            bool all_white_one_side = true;\n\n            for (int k = 0; k < n; k++) {\n                if (k == i || k == j) continue;\n\n                int cp = cross_product(points[i], points[j], points[k]);\n                \n                if (cp > 0) {\n                    if (points[k].is_black) all_black_one_side = false;\n                    else all_white_one_side = false;\n                } else if (cp < 0) {\n                    if (!points[k].is_black) all_black_one_side = false;\n                    else all_white_one_side = false;\n                }\n\n                if (!all_black_one_side && !all_white_one_side) break;\n            }\n\n            if (all_black_one_side || all_white_one_side) return true;\n        }\n    }\n    return false;\n}",
    "timestamp": "2025-08-05 20:50:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <cmath>\n\nclass Solution {\npublic:\n    bool separatePoints(std::vector<std::pair<int, int>>& blackPoints, \n                        std::vector<std::pair<int, int>>& whitePoints) {\n        int n = blackPoints.size();\n        int m = whitePoints.size();\n        \n        if (n == 0 || m == 0) return true;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == j) continue;\n                \n                for (int k = 0; k < m; k++) {\n                    for (int l = 0; l < m; l++) {\n                        if (k == l) continue;\n                        \n                        if (canSeparate(blackPoints[i], blackPoints[j], \n                                        whitePoints[k], whitePoints[l])) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n    \nprivate:\n    double crossProduct(const std::pair<int, int>& p1, \n                        const std::pair<int, int>& p2, \n                        const std::pair<int, int>& p3) {\n        return (p2.first - p1.first) * (p3.second - p1.second) - \n               (p2.second - p1.second) * (p3.first - p1.first);\n    }\n    \n    bool canSeparate(const std::pair<int, int>& b1, \n                     const std::pair<int, int>& b2, \n                     const std::pair<int, int>& w1, \n                     const std::pair<int, int>& w2) {\n        double c1 = crossProduct(b1, b2, w1);\n        double c2 = crossProduct(b1, b2, w2);\n        \n        return (c1 * c2 <= 0);\n    }\n};",
    "timestamp": "2025-08-05 20:50:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import numpy as np\n\ndef can_separate_points(black_points, white_points):\n    points = black_points + white_points\n    colors = [1] * len(black_points) + [-1] * len(white_points)\n    \n    def check_separation(line):\n        return all((np.dot(line, p) * c > 0) for p, c in zip(points, colors))\n    \n    for i in range(len(points)):\n        for j in range(i+1, len(points)):\n            a, b = points[i], points[j]\n            line = np.array([a[1] - b[1], b[0] - a[0]])  # Line between a and b perpendicular\n            if check_separation(line):\n                return True\n    return False\n\n# Example usage:\nblack_points = [(0, 0), (1, 1), (2, 2)]\nwhite_points = [(0, 1), (1, 2), (2, 3)]\nprint(can_separate_points(black_points, white_points))  # Output: True or False",
    "timestamp": "2025-08-13 03:38:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.List;\n\nclass Point {\n    double x, y;\n    boolean isBlack;\n    \n    Point(double x, double y, boolean isBlack) {\n        this.x = x;\n        this.y = y;\n        this.isBlack = isBlack;\n    }\n}\n\npublic class LineSeparator {\n\n    public static boolean canSeparate(List<Point> points) {\n        int n = points.size();\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                Point p1 = points.get(i);\n                Point p2 = points.get(j);\n                boolean isPossible = true;\n                \n                int sign = 0; // to keep track of which side each point is on\n                for (Point p : points) {\n                    if (p == p1 || p == p2) continue;\n                    int currentSign = getOrientation(p1, p2, p);\n                    if (sign == 0) {\n                        sign = currentSign;\n                    } else if (sign * currentSign < 0) {\n                        isPossible = false;\n                        break;\n                    }\n                }\n\n                if (isPossible) {\n                    // Check if p1 and p2 are of different colors\n                    return p1.isBlack != p2.isBlack;\n                }\n            }\n        }\n        return false;\n    }\n\n    private static int getOrientation(Point p1, Point p2, Point p) {\n        // Cross product of vectors (p2 - p1) x (p - p1)\n        double val = (p2.y - p1.y) * (p.x - p1.x) - (p2.x - p1.x) * (p.y - p1.y);\n        return (val > 0) ? 1 : (val < 0) ? -1 : 0;  // 1 -> counter-clockwise, -1 -> clockwise, 0 -> collinear\n    }\n}",
    "timestamp": "2025-08-13 03:38:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\ntypedef struct {\n    int x, y;\n    int color; // 0 for black, 1 for white\n} Point;\n\nint sign(int a) {\n    return (a > 0) - (a < 0);\n}\n\nint canSeparate(Point points[], int n) {\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int a = points[j].y - points[i].y;\n            int b = points[i].x - points[j].x;\n            int c = -(a * points[i].x + b * points[i].y);\n            \n            int black_side = 0, white_side = 0;\n            for (int k = 0; k < n; k++) {\n                int side = sign(a * points[k].x + b * points[k].y + c);\n                if (points[k].color == 0) {\n                    black_side |= side;\n                } else {\n                    white_side |= side;\n                }\n                if ((black_side & white_side) != 0)\n                    break;\n            }\n            if ((black_side & white_side) == 0)\n                return 1;\n        }\n    }\n    return 0;\n}\n\nint main() {\n    Point points[] = {\n        {0, 0, 0},\n        {1, 1, 1},\n        {1, 0, 0},\n        {0, 1, 1}\n    };\n    int n = sizeof(points) / sizeof(points[0]);\n\n    if (canSeparate(points, n))\n        printf(\"Yes, a line can separate the points.\\n\");\n    else\n        printf(\"No, a line cannot separate the points.\\n\");\n\n    return 0;\n}",
    "timestamp": "2025-08-13 03:38:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_separate_points(points):\n    black_points = [p for p in points if p[2] == 'B']\n    white_points = [p for p in points if p[2] == 'W']\n    \n    def cross_product(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n    \n    for i in range(len(black_points)):\n        for j in range(len(white_points)):\n            for k in range(len(points)):\n                if k != i and k != j:\n                    cross1 = cross_product(black_points[i], white_points[j], points[k])\n                    \n                    all_black_same_side = all(\n                        cross_product(black_points[i], white_points[j], bp) * cross1 >= 0\n                        for bp in black_points\n                    )\n                    \n                    all_white_same_side = all(\n                        cross_product(black_points[i], white_points[j], wp) * cross1 >= 0\n                        for wp in white_points\n                    )\n                    \n                    if all_black_same_side and all_white_same_side:\n                        return True\n    \n    return False",
    "timestamp": "2025-08-13 03:38:46"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_separable(black_points, white_points):\n    if not black_points or not white_points:\n        return True\n    \n    def check_all_points_on_same_side(points, a, b, c):\n        if not points:\n            return True\n        # Determine the sign of the first point\n        x, y = points[0]\n        sign = a * x + b * y + c\n        if sign == 0:\n            return False\n        for x, y in points[1:]:\n            current_sign = a * x + b * y + c\n            if current_sign * sign <= 0:\n                return False\n        return True\n    \n    # Try all possible lines between pairs of points (one from black, one from white)\n    for (x1, y1), (x2, y2) in [(b, w) for b in black_points for w in white_points]:\n        # Line equation: (y2 - y1)(x - x1) - (x2 - x1)(y - y1) = 0\n        # => (y1 - y2)x + (x2 - x1)y + (x1 y2 - x2 y1) = 0\n        a = y1 - y2\n        b = x2 - x1\n        c = x1 * y2 - x2 * y1\n        \n        # Check if all black points are on one side and all white points on the other\n        black_side = check_all_points_on_same_side(black_points, a, b, c)\n        white_side = check_all_points_on_same_side(white_points, a, b, c)\n        \n        if black_side and white_side:\n            # Check if they are on opposite sides\n            # Compare the sign of any black point and any white point\n            x_black, y_black = black_points[0]\n            x_white, y_white = white_points[0]\n            sign_black = a * x_black + b * y_black + c\n            sign_white = a * x_white + b * y_white + c\n            if sign_black * sign_white < 0:\n                return True\n    \n    return False",
    "timestamp": "2025-08-13 03:39:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nstruct Point {\n    int x, y;\n    char color;\n};\n\nbool canSeparate(std::vector<Point>& points) {\n    for (size_t i = 0; i < points.size(); ++i) {\n        for (size_t j = i + 1; j < points.size(); ++j) {\n            if (points[i].color != points[j].color) {\n                int a = points[j].y - points[i].y;\n                int b = points[i].x - points[j].x;\n                int c = points[i].y * points[j].x - points[i].x * points[j].y;\n\n                int sides[2] = {0, 0};\n                for (const auto& p : points) {\n                    int d = a * p.x + b * p.y + c;\n                    if (d > 0) sides[(p.color == 'W') ? 0 : 1]++;\n                    if (d < 0) sides[(p.color == 'W') ? 1 : 0]++;\n                }\n\n                if (sides[0] == 0 || sides[1] == 0) return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    std::vector<Point> points(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> points[i].x >> points[i].y >> points[i].color;\n    }\n\n    if (canSeparate(points)) {\n        std::cout << \"Yes\\n\";\n    } else {\n        std::cout << \"No\\n\";\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:14:02"
  }
]