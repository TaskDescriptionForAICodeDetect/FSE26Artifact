[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid reconstructPostorder(int* preorder, int* inorder, int* postorder, int n, int preStart, int preEnd, int inStart, int inEnd, int postStart, int postEnd) {\n    if (preStart > preEnd) return;\n\n    int rootVal = preorder[preStart];\n    postorder[postEnd] = rootVal;\n\n    int rootIndex;\n    for (rootIndex = inStart; rootIndex <= inEnd; rootIndex++) {\n        if (inorder[rootIndex] == rootVal) break;\n    }\n\n    int leftSubtreeSize = rootIndex - inStart;\n\n    reconstructPostorder(preorder, inorder, postorder, n, preStart + 1, preStart + leftSubtreeSize, \n                         inStart, rootIndex - 1, postStart, postStart + leftSubtreeSize - 1);\n    \n    reconstructPostorder(preorder, inorder, postorder, n, preStart + leftSubtreeSize + 1, preEnd, \n                         rootIndex + 1, inEnd, postStart + leftSubtreeSize, postEnd - 1);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int* preorder = malloc(n * sizeof(int));\n    int* inorder = malloc(n * sizeof(int));\n    int* postorder = malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &preorder[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &inorder[i]);\n    }\n\n    reconstructPostorder(preorder, inorder, postorder, n, 0, n-1, 0, n-1, 0, n-1);\n\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", postorder[i]);\n    }\n    printf(\"\\n\");\n\n    free(preorder);\n    free(inorder);\n    free(postorder);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:12:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint search(int arr[], int start, int end, int value) {\n    for (int i = start; i <= end; i++) {\n        if (arr[i] == value) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvoid printPostOrder(int in[], int pre[], int inStart, int inEnd, int *preIndex) {\n    if (inStart > inEnd) {\n        return;\n    }\n\n    int rootIndex = search(in, inStart, inEnd, pre[*preIndex]);\n    (*preIndex)++;\n\n    printPostOrder(in, pre, inStart, rootIndex - 1, preIndex);\n    printPostOrder(in, pre, rootIndex + 1, inEnd, preIndex);\n\n    printf(\"%d \", in[rootIndex]);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *pre = (int *)malloc(n * sizeof(int));\n    int *in = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &pre[i]);\n    }\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &in[i]);\n    }\n\n    int preIndex = 0;\n    printPostOrder(in, pre, 0, n - 1, &preIndex);\n    printf(\"\\n\");\n\n    free(pre);\n    free(in);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:13:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nunordered_map<int, int> in_map;\n\nvector<int> postorder;\n\nvoid build_postorder(vector<int>& pre, int pre_start, int pre_end, vector<int>& in, int in_start, int in_end) {\n    if (pre_start > pre_end) return;\n    int root_val = pre[pre_start];\n    int root_pos = in_map[root_val];\n    int left_size = root_pos - in_start;\n    \n    build_postorder(pre, pre_start + 1, pre_start + left_size, in, in_start, root_pos - 1);\n    build_postorder(pre, pre_start + left_size + 1, pre_end, in, root_pos + 1, in_end);\n    postorder.push_back(root_val);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> pre(n), in(n);\n    for (int i = 0; i < n; ++i) cin >> pre[i];\n    for (int i = 0; i < n; ++i) {\n        cin >> in[i];\n        in_map[in[i]] = i;\n    }\n    \n    build_postorder(pre, 0, n - 1, in, 0, n - 1);\n    \n    for (int i = 0; i < n; ++i) {\n        if (i > 0) cout << \" \";\n        cout << postorder[i];\n    }\n    cout << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:13:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static int preIndex = 0;\n\n    static int search(int[] in, int start, int end, int value) {\n        for (int i = start; i <= end; i++) {\n            if (in[i] == value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    static void printPostOrder(int[] in, int[] pre, int inStart, int inEnd) {\n        if (inStart > inEnd) {\n            return;\n        }\n\n        int rootIndex = search(in, inStart, inEnd, pre[preIndex++]);\n        printPostOrder(in, pre, inStart, rootIndex - 1);\n        printPostOrder(in, pre, rootIndex + 1, inEnd);\n        System.out.print(in[rootIndex] + \" \");\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] pre = new int[n];\n        int[] in = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            pre[i] = scanner.nextInt();\n        }\n        for (int i = 0; i < n; i++) {\n            in[i] = scanner.nextInt();\n        }\n\n        printPostOrder(in, pre, 0, n - 1);\n    }\n}",
    "timestamp": "2025-08-05 22:13:40"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TreeReconstruction {\n    static class Node {\n        int val;\n        Node left, right;\n        \n        Node(int val) {\n            this.val = val;\n        }\n    }\n    \n    static int preIndex = 0;\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // Read preorder sequence\n        int n = scanner.nextInt();\n        int[] preorder = new int[n];\n        for (int i = 0; i < n; i++) {\n            preorder[i] = scanner.nextInt();\n        }\n        \n        // Read inorder sequence\n        int[] inorder = new int[n];\n        for (int i = 0; i < n; i++) {\n            inorder[i] = scanner.nextInt();\n        }\n        \n        preIndex = 0;\n        Node root = buildTree(preorder, inorder, 0, n - 1);\n        \n        // Perform postorder traversal and print\n        List<Integer> postorder = new ArrayList<>();\n        postorderTraversal(root, postorder);\n        \n        for (int val : postorder) {\n            System.out.print(val + \" \");\n        }\n        \n        scanner.close();\n    }\n    \n    static Node buildTree(int[] preorder, int[] inorder, int inStart, int inEnd) {\n        if (inStart > inEnd) {\n            return null;\n        }\n        \n        Node root = new Node(preorder[preIndex++]);\n        \n        if (inStart == inEnd) {\n            return root;\n        }\n        \n        int inIndex = search(inorder, inStart, inEnd, root.val);\n        \n        root.left = buildTree(preorder, inorder, inStart, inIndex - 1);\n        root.right = buildTree(preorder, inorder, inIndex + 1, inEnd);\n        \n        return root;\n    }\n    \n    static int search(int[] inorder, int start, int end, int value) {\n        for (int i = start; i <= end; i++) {\n            if (inorder[i] == value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    \n    static void postorderTraversal(Node node, List<Integer> postorder) {\n        if (node == null) {\n            return;\n        }\n        \n        postorderTraversal(node.left, postorder);\n        postorderTraversal(node.right, postorder);\n        postorder.add(node.val);\n    }\n}",
    "timestamp": "2025-08-05 22:13:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvoid reconstructPostorder(vector<int>& preorder, vector<int>& inorder, \n                          unordered_map<int, int>& inorderPositions, \n                          int preStart, int preEnd, \n                          int inStart, int inEnd, \n                          vector<int>& postorder) {\n    if (preStart > preEnd) return;\n    \n    int rootValue = preorder[preStart];\n    int rootIndex = inorderPositions[rootValue];\n    int leftSubtreeSize = rootIndex - inStart;\n    \n    reconstructPostorder(preorder, inorder, inorderPositions, \n                         preStart + 1, preStart + leftSubtreeSize, \n                         inStart, rootIndex - 1, postorder);\n    \n    reconstructPostorder(preorder, inorder, inorderPositions, \n                         preStart + leftSubtreeSize + 1, preEnd, \n                         rootIndex + 1, inEnd, postorder);\n    \n    postorder.push_back(rootValue);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<int> preorder(n), inorder(n), postorder;\n    unordered_map<int, int> inorderPositions;\n    \n    for (int i = 0; i < n; i++) {\n        cin >> preorder[i];\n    }\n    \n    for (int i = 0; i < n; i++) {\n        cin >> inorder[i];\n        inorderPositions[inorder[i]] = i;\n    }\n    \n    reconstructPostorder(preorder, inorder, inorderPositions, \n                         0, n - 1, 0, n - 1, postorder);\n    \n    for (int node : postorder) {\n        cout << node << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:13:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def build_tree(preorder, inorder):\n    if not preorder or not inorder:\n        return None\n    \n    root_val = preorder.pop(0)\n    root_index = inorder.index(root_val)\n    \n    root = TreeNode(root_val)\n    root.left = build_tree(preorder, inorder[:root_index])\n    root.right = build_tree(preorder, inorder[root_index+1:])\n    \n    return root\n\ndef postorder_traverse(root, result):\n    if not root:\n        return\n    \n    postorder_traverse(root.left, result)\n    postorder_traverse(root.right, result)\n    result.append(root.val)\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef find_postorder(preorder, inorder):\n    root = build_tree(preorder[:], inorder[:])\n    postorder_result = []\n    postorder_traverse(root, postorder_result)\n    return postorder_result\n\n# Example usage\npreorder = list(map(int, input().strip().split()))\ninorder = list(map(int, input().strip().split()))\npostorder = find_postorder(preorder, inorder)\nprint(postorder)",
    "timestamp": "2025-08-13 09:30:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class BinaryTreePostorder {\n\n    private static int preorderIndex;\n\n    public static void main(String[] args) {\n        int[] preorder = {3, 9, 20, 15, 7};  // Example preorder sequence\n        int[] inorder = {9, 3, 15, 20, 7};   // Example inorder sequence\n\n        int[] postorder = buildPostorder(preorder, inorder);\n        \n        for (int id : postorder) {\n            System.out.print(id + \" \");\n        }\n    }\n\n    public static int[] buildPostorder(int[] preorder, int[] inorder) {\n        preorderIndex = 0;\n        Map<Integer, Integer> inorderMap = new HashMap<>();\n        for (int i = 0; i < inorder.length; i++) {\n            inorderMap.put(inorder[i], i);\n        }\n        \n        int[] postorder = new int[inorder.length];\n        buildPostorderHelper(preorder, 0, inorder.length - 1, inorderMap, postorder, new int[]{0});\n        return postorder;\n    }\n\n    private static void buildPostorderHelper(int[] preorder, int inorderStart, int inorderEnd,\n                                             Map<Integer, Integer> inorderMap, int[] postorder, int[] postIndex) {\n        if (inorderStart > inorderEnd) {\n            return;\n        }\n\n        int rootValue = preorder[preorderIndex++];\n        int inorderIndex = inorderMap.get(rootValue);\n\n        buildPostorderHelper(preorder, inorderStart, inorderIndex - 1, inorderMap, postorder, postIndex);\n        buildPostorderHelper(preorder, inorderIndex + 1, inorderEnd, inorderMap, postorder, postIndex);\n\n        postorder[postIndex[0]++] = rootValue;\n    }\n}",
    "timestamp": "2025-08-13 09:30:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Node {\n    int value;\n    struct Node* left;\n    struct Node* right;\n} Node;\n\nNode* buildTree(int* preorder, int* inorder, int inorderStart, int inorderEnd, int* preorderIndex) {\n    if (inorderStart > inorderEnd) {\n        return NULL;\n    }\n\n    int nodeValue = preorder[(*preorderIndex)++];\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->value = nodeValue;\n    node->left = node->right = NULL;\n\n    if (inorderStart == inorderEnd) {\n        return node;\n    }\n\n    int inorderIndex;\n    for (inorderIndex = inorderStart; inorderIndex <= inorderEnd; inorderIndex++) {\n        if (inorder[inorderIndex] == nodeValue) {\n            break;\n        }\n    }\n\n    node->left = buildTree(preorder, inorder, inorderStart, inorderIndex - 1, preorderIndex);\n    node->right = buildTree(preorder, inorder, inorderIndex + 1, inorderEnd, preorderIndex);\n\n    return node;\n}\n\nvoid printPostorder(Node* node) {\n    if (node == NULL) {\n        return;\n    }\n    printPostorder(node->left);\n    printPostorder(node->right);\n    printf(\"%d \", node->value);\n}\n\nvoid freeTree(Node* node) {\n    if (node == NULL) {\n        return;\n    }\n    freeTree(node->left);\n    freeTree(node->right);\n    free(node);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int* preorder = (int*)malloc(n * sizeof(int));\n    int* inorder = (int*)malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &preorder[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &inorder[i]);\n    }\n\n    int preorderIndex = 0;\n    Node* root = buildTree(preorder, inorder, 0, n - 1, &preorderIndex);\n    \n    printPostorder(root);\n    printf(\"\\n\");\n\n    freeTree(root);\n    free(preorder);\n    free(inorder);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 09:31:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def build_tree(preorder, inorder):\n    if not preorder or not inorder:\n        return None\n    \n    root = preorder[0]\n    root_index = inorder.index(root)\n    \n    left_inorder = inorder[:root_index]\n    right_inorder = inorder[root_index+1:]\n    \n    left_preorder = preorder[1:root_index+1]\n    right_preorder = preorder[root_index+1:]\n    \n    root_node = {'value': root, 'left': None, 'right': None}\n    root_node['left'] = build_tree(left_preorder, left_inorder)\n    root_node['right'] = build_tree(right_preorder, right_inorder)\n    \n    return root_node\n\ndef postorder_traversal(root):\n    result = []\n    \n    def traverse(node):\n        if node is None:\n            return\n        \n        traverse(node['left'])\n        traverse(node['right'])\n        result.append(node['value'])\n    \n    traverse(root)\n    return result\n\ndef main():\n    preorder = list(map(int, input().split()))\n    inorder = list(map(int, input().split()))\n    \n    root = build_tree(preorder, inorder)\n    postorder = postorder_traversal(root)\n    \n    print(' '.join(map(str, postorder)))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 09:31:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def postorder(preorder, inorder):\n    if not preorder:\n        return []\n    root = preorder[0]\n    root_pos = inorder.index(root)\n    left_in = inorder[:root_pos]\n    right_in = inorder[root_pos+1:]\n    left_pre = preorder[1:1+len(left_in)]\n    right_pre = preorder[1+len(left_in):]\n    left_post = postorder(left_pre, left_in)\n    right_post = postorder(right_pre, right_in)\n    return left_post + right_post + [root]\n\nn = int(input())\npreorder = list(map(int, input().split()))\ninorder = list(map(int, input().split()))\npost = postorder(preorder, inorder)\nprint(' '.join(map(str, post)))",
    "timestamp": "2025-08-13 09:31:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint preIndex = 0;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nTreeNode* buildTreeHelper(const vector<int>& preorder, const vector<int>& inorder, int inStart, int inEnd, unordered_map<int, int>& inMap) {\n    if (inStart > inEnd) {\n        return NULL;\n    }\n    \n    int rootVal = preorder[preIndex++];\n    TreeNode* root = new TreeNode(rootVal);\n    \n    int inIndex = inMap[rootVal];\n    root->left = buildTreeHelper(preorder, inorder, inStart, inIndex - 1, inMap);\n    root->right = buildTreeHelper(preorder, inorder, inIndex + 1, inEnd, inMap);\n    \n    return root;\n}\n\nTreeNode* buildTree(const vector<int>& preorder, const vector<int>& inorder) {\n    unordered_map<int, int> inMap;\n    for (int i = 0; i < inorder.size(); i++) {\n        inMap[inorder[i]] = i;\n    }\n    return buildTreeHelper(preorder, inorder, 0, inorder.size() - 1, inMap);\n}\n\nvoid postorderTraversal(TreeNode* root, vector<int>& postorder) {\n    if (root == NULL) {\n        return;\n    }\n    postorderTraversal(root->left, postorder);\n    postorderTraversal(root->right, postorder);\n    postorder.push_back(root->val);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> preorder(n), inorder(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> preorder[i];\n    }\n    for (int i = 0; i < n; ++i) {\n        cin >> inorder[i];\n    }\n    \n    TreeNode* root = buildTree(preorder, inorder);\n    \n    vector<int> postorder;\n    postorderTraversal(root, postorder);\n    \n    for (const int& val : postorder) {\n        cout << val << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:52:17"
  }
]