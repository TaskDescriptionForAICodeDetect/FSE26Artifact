[
  {
    "language": "Scala",
    "code": "import scala.io.StdIn\n\nobject Main extends App {\n\n  val n = StdIn.readLine().trim.toInt\n  \n  val preorders = StdIn.readLine().split(' ').map(_.toInt)\n  val inorders = StdIn.readLine().split(' ').map(_.toInt)\n  val postorders = Array.fill[Int](n)(0)\n  \n  var position = 0\n  var positionResult = 0\n\n  def reconstruction(left: Int, right: Int): Unit = {\n    if(left < right){\n      val current = preorders(position)\n      position += 1\n      val middleIdx = inorders.indexOf(current)\n      reconstruction(left, middleIdx)\n      reconstruction(middleIdx + 1, right)\n      postorders(positionResult) = current\n      positionResult += 1\n      \n    } else ()\n  }\n  \n  reconstruction(0, n)\n  \n  println(postorders.mkString(\" \"))\n  \n}\n\n"
  },
  {
    "language": "Scala",
    "code": "object Main extends App {\n  val n: Int = io.StdIn.readInt()\n  val preorder: Vector[Int] = io.StdIn.readLine().split(\" \").map(_.toInt).toVector\n  val inorder: Vector[Int] = io.StdIn.readLine().split(\" \").map(_.toInt).toVector\n  val postorder = toPostOrder(inorder)\n  println(postorder.mkString(\" \"))\n\n  def toPostOrder(l: Vector[Int]): Vector[Int] = l match {\n    case Vector() | Vector(_) => l\n    case _ => {\n      val p: Int = l.indices.minBy(i => preorder.indexOf(l(i)))\n      val left: Vector[Int] = l.take(p)\n      val right: Vector[Int] = l.drop(p+1)\n      toPostOrder(left) ++ toPostOrder(right) ++ Vector(l(p))\n    }\n  }\n}\n"
  },
  {
    "language": "Scala",
    "code": "import scala.collection.mutable.Stack\nimport scala.io.StdIn.{readInt, readLine}\n\nobject Main extends App {\n\n  class Node {\n    var id = -1\n    var parent = -1\n    var left = -1\n    var right = -1\n    var preOrderPos = -1\n    var inOrderPos = -1\n  }\n\n  val n = readInt\n  val nodes = Array.fill[Node](n)(new Node)\n  val pre = readLine.split(\" \").map(_.toInt)\n  val in = readLine.split(\" \").map(_.toInt)\n  for (i <- 0 to n - 1) {\n    nodes(i).id = pre(i)\n    nodes(i).preOrderPos = i\n    for (j <- 0 to n - 1) {\n      if (nodes(i).id == in(j)) {\n        nodes(i).inOrderPos = j\n      }\n    }\n  }\n\n  val root = nodes(0)\n  for (i <- 1 to n - 1) {\n    addChild(nodes, 0, i)\n  }\n\n  postOrderTraversal(nodes)\n\n  def addChild(nodes: Array[Node], parentIdx: Int, idx: Int): Unit = {\n    val parent = nodes(parentIdx)\n    val left = nodes(parentIdx).left\n    val right = nodes(parentIdx).right\n    val node = nodes(idx)\n    if (parent.inOrderPos > node.inOrderPos) {\n      if (left == -1) parent.left = idx\n      else addChild(nodes, left, idx)\n    } else {\n      if (right == -1) parent.right = idx\n      else addChild(nodes, right, idx)\n    }\n  }\n\n  def postOrderTraversal(nodes: Array[Node]): Unit = {\n    val n = nodes.length\n    val visited = Array.fill[Boolean](n)(false)\n    val postOrder = Array.fill[Int](n)(-1)\n    var cnt = 0\n    val stack = new Stack[Int]\n    stack.push(0)\n    while(!stack.isEmpty) {\n      val idx = stack.top\n      val left = nodes(idx).left\n      val right = nodes(idx).right\n      if (right != -1 && !visited(right)) {\n        stack.push(right)\n      }\n      if (left != -1 && !visited(left)) {\n        stack.push(left)\n      }\n      if (isLeaf(left, right) || childrenVisited(visited, left, right)) {\n        postOrder(cnt) = nodes(idx).id\n        cnt += 1\n        visited(idx) = true\n        stack.pop\n      }\n    }\n    println(postOrder.mkString(\" \"))\n  }\n\n  def isLeaf(left: Int, right: Int): Boolean = {\n    left == -1 && right == -1\n  }\n\n  def childrenVisited(visited: Array[Boolean], left: Int, right: Int): Boolean = {\n    val leftVisited = if (left == -1) true else visited(left)\n    val rightVisited = if (right == -1) true else visited(right)\n    leftVisited && rightVisited\n  }\n}\n\n"
  },
  {
    "language": "Scala",
    "code": "object Main extends App {\n  val n: Int = io.StdIn.readInt()\n  val preorder: Array[Int] = io.StdIn.readLine().split(\" \").map(_.toInt)\n  val inorder: Vector[Int] = io.StdIn.readLine().split(\" \").map(_.toInt).toVector\n  val postorder = in2post(inorder)\n  println(postorder.mkString(\" \"))\n\n  def in2post(l: Vector[Int]): Vector[Int] =\n    if (l.length < 2) l\n    else {\n      val p: Int = l.indices.minBy(i => preorder.indexOf(l(i)))\n      val left: Vector[Int] = l.take(p)\n      val right: Vector[Int] = l.drop(p+1)\n      in2post(left) ++ in2post(right) ++ Vector(l(p))\n    }\n}\n"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt, readLine};\n\nobject Main {\n    def main(args: Array[String]): Unit = {\n        val n = readInt;\n        val preorder = readLine.split(\" \").map(_.toInt);\n        val inorder = readLine.split(\" \").map(_.toInt);\n        val (root, tree) = buildTree(n, preorder, inorder);\n        println(\" \" + postorder(root, tree).mkString(\" \"));\n        \n    }\n    \n    def buildTree(size: Int, preorder: Array[Int], inorder: Array[Int]): (Int, Array[Node]) = {\n        val tree = new Array[Node](size + 1);\n        def go(prePtr: Int, inFirst: Int, inLast: Int): (Int, Int) = {\n            if (prePtr >= size) {\n                (-1, prePtr);\n            } else {\n                val pivot = preorder(prePtr);\n                val pivotIdx = inorder.indexOf(pivot);\n                val (left, prePtr1) = if (inFirst == pivotIdx) (-1, prePtr) else go(prePtr + 1, inFirst, pivotIdx - 1);\n                val (right, prePtr2) = if (inLast == pivotIdx) (-1, prePtr1) else go(prePtr1 + 1, pivotIdx + 1, inLast);\n                tree(pivot) = Node(pivot, left, right);\n                (pivot, prePtr2);\n            }\n        }\n        go(0, 0, size - 1);\n        (preorder(0), tree);\n    }\n    \n    def postorder(root: Int, tree: Array[Node]): List[Int] = {\n        def go(curr: Int, ret: List[Int]): List[Int] = {\n            if (curr == -1) {\n                ret;\n            } else {\n                val Node(id, left, right) = tree(curr);\n                val ret1 = go(left, ret);\n                val ret2 = go(right, ret1);\n                val ret3 = id :: ret2;\n                ret3;\n            }\n            \n        }\n        go(root, Nil).reverse;\n    }\n}\ncase class Node(id: Int, left: Int, right: Int);\n"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt,readLine}\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n  def main(args:Array[String]) = {\n    val n = readInt\n    val pre = readLine.split(\" \").map(_.toInt)\n    val in = readLine.split(\" \").map(_.toInt)\n    val post = new ArrayBuffer[Int]\n\n    var pos = 0\n    def scan(l:Int, r:Int):Unit = {\n      if(l<r) {\n        val root = pre(pos)\n        pos += 1\n        val m = in.indexWhere(_==root)\n        scan(l,m)\n        scan(m+1,r)\n        post += root\n      }\n    }\n\n    scan(0, pre.length)\n    println(post.toArray.mkString(\" \"))\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt, readLine}\nobject Main {\n    def main(args: Array[String]): Unit = {\n        val n = readInt;\n        val pre = readLine.split(\" \").map(_.toInt);\n        val in = readLine.split(\" \").map(_.toInt);\n        val tree = Tree();\n        tree.build(n, pre, in);\n        println(tree.postorder().mkString(\" \"));\n    }\n}\n\ncase class Tree() {\n    case class TreeNode(value: Int, left: TreeNode, right: TreeNode);\n    var root: TreeNode = null;\n    \n    def preorder(): List[Int] = {\n        def _preorder(node: TreeNode, ret: List[Int]): List[Int] = {\n            if (node == null) {\n                ret;\n            } else {\n                val ret1 = node.value :: ret;\n                val ret2 = _preorder(node.left, ret1);\n                val ret3 = _preorder(node.right, ret2);\n                ret3;\n            }\n        }\n        _preorder(root, Nil).reverse;\n    }\n    \n    def postorder(): List[Int] = {\n        def _preorder(node: TreeNode, ret: List[Int]): List[Int] = {\n            if (node == null) {\n                ret;\n            } else {\n                val ret1 = _preorder(node.left, ret);\n                val ret2 = _preorder(node.right, ret1);\n                val ret3 = node.value :: ret2;\n                ret3;\n            }\n        }\n        _preorder(root, Nil).reverse;\n    }\n    \n    def build(size: Int, pre: Array[Int], in: Array[Int]): Unit = {\n        // pre の index を示すポインタ\n        //  pre(prePtr) を value にもつノードが生成されたときにインクリメントする。\n        var prePtr = 0\n        def buildSubTree(lip: Int, rip: Int): TreeNode = {\n            if (lip > rip) {\n                // 探索するノードが存在しない場合はnullを返す\n                null;\n            } else if (lip == rip) {\n                //  探索するノードが1つしかない場合は、子ノードが null の部分木を返す\n                val value: Int = pre(prePtr);\n                prePtr += 1;\n                TreeNode(value, null, null);\n            } else {\n                val value: Int = pre(prePtr);\n                val pivot: Int = (lip to rip).find(i => in(i) == value).get; // 無いわけない\n                prePtr += 1;\n                //println(s\"[${value}]  prePtr : ${prePtr}\");\n                //if (lip == pivot) println(s\"[${value}]  left: null\") else println(s\"[${value}]  left: \" + (lip to pivot - 1).map(in(_)).mkString(\" \"));\n                val leftSubTree = buildSubTree(lip, pivot - 1);\n                //if (rip == pivot) println(s\"[${value}]  right: null\") else println(s\"[${value}]  right: \" + (pivot + 1 to rip).map(in(_)).mkString(\" \"));\n                val rightSubTree = buildSubTree(pivot + 1,  rip);\n                TreeNode(value, leftSubTree, rightSubTree);\n            }\n        }\n        root = if (size < 1) null else {buildSubTree(0, size - 1)};\n    }\n}\n\n"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt, readLine}\nobject Main {\n    def main(args: Array[String]): Unit = {\n        val n = readInt;\n        val pre = readLine.split(\" \").map(_.toInt);\n        val in = readLine.split(\" \").map(_.toInt);\n        val tree = Tree();\n        tree.build(n, pre, in);\n        println(tree.postorder().mkString(\" \"));\n    }\n}\n\ncase class Tree() {\n    case class TreeNode(value: Int, left: TreeNode, right: TreeNode);\n    var root: TreeNode = null;\n    \n    def isEmpty(): Boolean = root == null;\n    \n    def preorder(): List[Int] = {\n        def _preorder(node: TreeNode, ret: List[Int]): List[Int] = {\n            if (node == null) {\n                ret;\n            } else {\n                val ret1 = node.value :: ret;\n                val ret2 = _preorder(node.left, ret1);\n                val ret3 = _preorder(node.right, ret2);\n                ret3;\n            }\n        }\n        _preorder(root, Nil).reverse;\n    }\n    \n    def postorder(): List[Int] = {\n        def _preorder(node: TreeNode, ret: List[Int]): List[Int] = {\n            if (node == null) {\n                ret;\n            } else {\n                val ret1 = _preorder(node.left, ret);\n                val ret2 = _preorder(node.right, ret1);\n                val ret3 = node.value :: ret2;\n                ret3;\n            }\n        }\n        _preorder(root, Nil).reverse;\n    }\n    \n    def build(size: Int, pre: Array[Int], in: Array[Int]): Unit = {\n        // pre の index を示すポインタ\n        var prePtr = 0\n        def buildSubTree(lip: Int, rip: Int): TreeNode = {\n            if (lip > rip) {\n                // 探索するノードが存在しない場合はnullを返す\n                null;\n            } else if (lip == rip) {\n                //  探索するノードが1つしかない場合は、子ノードが null の部分木を返す\n                val value: Int = pre(prePtr);\n                TreeNode(value, null, null);\n            } else {\n                val value: Int = pre(prePtr);\n                val pivot: Int = (lip to rip).find(i => in(i) == value).get; // 無いわけない\n                prePtr += 1;\n                val leftSubTree = buildSubTree(lip, pivot - 1);\n                prePtr += 1;\n                val rightSubTree = buildSubTree(pivot + 1,  rip);\n                TreeNode(value, leftSubTree, rightSubTree);\n            }\n        }\n        root = if (size < 1) null else {buildSubTree(0, size - 1)};\n    }\n}\n\n"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt, readLine};\n\nobject Main {\n    def main(args: Array[String]): Unit = {\n        val n = readInt;\n        val preorder = readLine.split(\" \").map(_.toInt);\n        val inorder = readLine.split(\" \").map(_.toInt);\n        val (root, tree) = buildTree(n, preorder, inorder);\n        println(postorder(root, tree).mkString(\" \"));\n        \n    }\n    \n    def buildTree(size: Int, preorder: Array[Int], inorder: Array[Int]): (Int, Array[Node]) = {\n        val tree = new Array[Node](size + 1);\n        def go(prePtr: Int, inFirst: Int, inLast: Int): (Int, Int) = {\n            if (prePtr >= size) {\n                (-1, prePtr);\n            } else {\n                val pivot = preorder(prePtr);\n                val pivotIdx = inorder.indexOf(pivot);\n                val (left, prePtr1) = if (inFirst == pivotIdx) (-1, prePtr) else go(prePtr + 1, inFirst, pivotIdx - 1);\n                val (right, prePtr2) = if (inLast == pivotIdx) (-1, prePtr1) else go(prePtr1 + 1, pivotIdx + 1, inLast);\n                tree(pivot) = Node(pivot, left, right);\n                (pivot, prePtr2);\n            }\n        }\n        go(0, 0, size - 1);\n        (preorder(0), tree);\n    }\n    \n    def postorder(root: Int, tree: Array[Node]): List[Int] = {\n        def go(curr: Int, ret: List[Int]): List[Int] = {\n            if (curr == -1) {\n                ret;\n            } else {\n                val Node(id, left, right) = tree(curr);\n                val ret1 = go(left, ret);\n                val ret2 = go(right, ret1);\n                val ret3 = id :: ret2;\n                ret3;\n            }\n            \n        }\n        go(root, Nil).reverse;\n    }\n}\ncase class Node(id: Int, left: Int, right: Int);\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nstruct node{\n    int left,right;\n}nodes[100];\n\nint n,pre[105],in[105],inloc[105],cnt=0;\n\nint rec(int s,int e){\n    if(s<e){\n        int m=inloc[pre[cnt++]];\n        int l=rec(s,m-1);\n        int r=rec(m+1,e);\n        nodes[in[m]].left=in[l];\n        nodes[in[m]].right=in[r];\n        return m;\n    }\n    else if(s==e){return s;}\n    else {return 0;}\n}\n\nvoid post(int r){\n    if(nodes[r].left!=0)post(nodes[r].left);\n    if(nodes[r].right!=0)post(nodes[r].right);\n    cout<<r;\n    if(r!=pre[0])cout<<\" \";\n}\n\nint main()\n{\n    memset(nodes,0,sizeof(nodes));\n    cin>>n;\n    int i;\n    for(i=0;i<n;i++){\n        cin>>pre[i];\n    }\n    for(i=0;i<n;i++){\n        cin>>in[i];\n        inloc[in[i]]=i;\n    }\n    int mm=rec(0,n-1);\n    cout<<endl;\n    post(pre[0]);\n    cout<<endl;\n    return 0;\n}\n//\n//int main(){\n//    int a[10]={1,2,3,4,5,32,62,23,8,33};\n//    int *b=find(a,a+10,62);\n//    int c=distance(a,b);\n//    cout<<c;\n//}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r)\n{\n\tif (l >= r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\nvoid solve()\n{\n\tpos = 0;\n\trec(0, pre.size());\n\tfor (int i = 0; i < post.size(); i++){\n\t\tif (i) printf(\" \");\n\t\tprintf(\"%d\", post[i]);\n\t}\n\tputs(\"\");\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\tpre.push_back(k);\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\tin.push_back(k);\n\t}\n\t\n\tsolve();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r){\n    if(l>=r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(),in.end(),root));\n    rec(l,m);\n    rec(m+1,r);\n    post.push_back(root);\n}\n\nvoid solve(){\n    pos = 0;\n    rec(0,pre.size());\n    for(int i=0;i<n;i++){\n        if(i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main(){\n    int num;\n    cin >> n;\n    \n    for(int i=0;i<n;i++){\n        cin >> num;\n        pre.push_back(num);\n    }\n    \n    for(int i=0;i<n;i++){\n        cin >> num;\n        in.push_back(num);\n    }\n    \n    solve();\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct Vertex{\n\tint left;\n\tint right;\n};\n\nvoid Postorder(vector<Vertex> &T,int root){\n\tif(T[root].left!=-1) Postorder(T,T[root].left);\n\tif(T[root].right!=-1) Postorder(T,T[root].right);\n\tcout << root+1 << \" \";\n\treturn;\n}\n\nvoid Reconstruction(vector<Vertex> &T, vector<int> &Pre,vector<int> &In,int p,int q,int s,int t){\n\tint root = Pre[p];\n\tif(p==q){\n\t\tT[root].left=-1;\n\t\tT[root].right=-1;\n\t\treturn ;\n\t}\n\t\n\tvector<bool> check(1000000,false);\n\t\n\t//k???In????????????root?????????????????????\n\tint k=-1;\n\tfor(int i=s;i<t+1;i++){\n\t\tcheck[In[i]]=true;\n\t\tif (In[i]==root){\n\t\t\tk=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t//l???Pre?????????????????´?????¨???????????????????????????????????????\n\tint l;\n\tfor(int i=p;i<q+1;i++){\n\t\tif(check[Pre[i+1]]==false){\n\t\t\tl=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif(s==k){\n\t\tT[root].left=-1;\n\t\tT[root].right=Pre[l+1];\n\t\n\t\tReconstruction(T,Pre,In,l+1,q,k+1,t);\n\t}else if(t==k){\n\t\tT[root].left=Pre[p+1];\n\t\tT[root].right=-1;\n\t\n\t\tReconstruction(T,Pre,In,p+1,l,s,k-1);\n\t}else{\n\t\tT[root].left=Pre[p+1];\n\t\tT[root].right=Pre[l+1];\n\t\n\t\tReconstruction(T,Pre,In,p+1,l,s,k-1);\n\t\tReconstruction(T,Pre,In,l+1,q,k+1,t);\n\t}\n}\n\nint main(){\n\tint n,x;\n\tcin >> n;\n\tvector<int> Pre(n);\n\tvector<int> In(n);\n\tfor (int i=0;i<n;i++){\n\t\tcin >> x;\n\t\tPre[i]=x-1;\n\t}\n\t\n\tfor (int i=0;i<n;i++){\n\t\tcin >> x;\n\t\tIn[i]=x-1;\n\t}\n\t\n\tvector<Vertex> T(n);\n\tReconstruction(T,Pre,In,0,n-1,0,n-1);\n\tPostorder(T,Pre[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Up, Down?????????????????????????????????????????£?????????\n//?????????pre_0?????????in_i = pre_0 (i>=0)??¨??????i????????????, ???pre_0????????´??????i????????????????????¨???\n//??¨?????¨v??????????????????????????????, ??????????????????dfs????????°?°???????????????§????????????\n//??????????????????, ???????????????????????????????????????1????????????????????????????????°???????????????\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint n;\nint pre[40];\nint in[40];\nvector<int> past;\n\n//pre[id]??????????????????, in[l, r)?????¨?????¨v???????????????\nvoid dfs(int id, int l, int r) {\n\tif (r - l == 1) {\n\t\tpast.push_back(pre[id]);\n\t\treturn;\n\t}\n\t\n\tint i;\n\tfor (i = 0; i < r - l; i++) {\n\t\tif (in[l + i] == pre[id]) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i > 0) {\n\t\tdfs(id + 1, l, l + i);\n\t}\n\tdfs(id + 1 + i, l + i + 1, r);\n\tpast.push_back(pre[id]);\n}\n\nint main() {\n\tint i;\n\tcin >> n;\n\tfor (i = 0; i < n; i++) cin >> pre[i];\n\tfor (i = 0; i < n; i++) cin >> in[i];\n\tdfs(0, 0, n);\n\t\n\tfor (i = 0; i < past.size(); i++) {\n\t\tcout << past[i];\n\t\tif (i + 1 < past.size()) cout << \" \";\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\nusing namespace std;\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for(int i = int(a); i < int(b); ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\nconst long long INFLL = 1LL << 60;\nconst int INFINT = 1 << 30;\nconst long long MOD = 1e9 + 7;\n\ntemplate <class T> void vecout(T V) {\n    auto t = V.begin();\n    while(t != V.end()) {\n        cout << *t++;\n        if(t != V.end()) cout << \" \";\n    }\n    cout << endl;\n};\n\nconst int MAX_N = 41;\n\nclass node {\n  public:\n    int p = -1;\n    int l = -1;\n    int r = -1;\n};\nnode nod[MAX_N];\n\nvector<int> preorder(MAX_N);\nvector<int> inorder(MAX_N);\nvector<int> postorder(0);\n\nvoid setpostorder(int now) {\n    if(nod[now].l != -1) setpostorder(nod[now].l);\n    if(nod[now].r != -1) setpostorder(nod[now].r);\n    postorder.push_back(now);\n}\n\nint recon(int left, int right, int size) {\n    if(left == right)\n        return inorder[left];\n    else if(left > right)\n        return -1;\n    else {\n        rep(i, 1, size + 1) {\n            rep(j, left, right + 1) {\n                if(preorder[i] == inorder[j]) {\n                    nod[preorder[i]].l = recon(left, j - 1, size);\n                    nod[preorder[i]].r = recon(j + 1, right, size);\n                    return preorder[i];\n                }\n            }\n        }\n    }\n    return -2;\n}\n\nint main() {\n    int n, id, l, r, root;\n    cin >> n;\n    rep(i, 1, n + 1) cin >> preorder[i];\n    rep(i, 1, n + 1) cin >> inorder[i];\n\n    root = recon(1, n, n);\n\n    setpostorder(root);\n    vecout(postorder);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nint n;\nint P[42];\nint Pi[42];\nint K[42];\nint Ki[42];\n\n\nstruct N {\n\tint id,l, r;\n\tvoid setid(int pi);\n\tvoid pre();\n\tvoid in();\n\tvoid post();\n};\n\nint root;\nN T[25];\n\n/*\n5\n1 2 3 4 5\n3 2 4 1 5\n\n         1\n   2        5\n 3   4\n*/\n\n// I think this is a O(n) algorizm\n\nvoid N::setid(int _id)\n{\n\tid = _id;\n\tint pid=Pi[id]; // 1\n\tint kid=Ki[id]; // 1\n\tint idl=P[pid+1]; // 2\n\tint kidl=Ki[idl]; // 2\n\tif (kid>kidl) {\n\t\tl=idl;\n\t\tT[l].setid(l);\n\t}\n\tint idr=K[kid+1];\n\tint pidr=Pi[idr];\n\tif(pidr>pid){\n\t\tr=idr;\n\t\tT[r].setid(r);\n\t}\n//\tcout<<id<<' '<<l<<' '<<r<<endl;\n}\n\n\nint main()\n{\n\tmemset(T, 0, sizeof(T));\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>P[i];\n\tP[0]=P[n+1]=0;\n\tfor(int i=1;i<=n;i++) Pi[P[i]]=i;\n\tPi[0]=Pi[n+1]=0;\n\tfor(int i=1;i<=n;i++) cin>>K[i];\n\tK[0]=K[n+1]=0;\n\tfor(int i=1;i<=n;i++) Ki[K[i]]=i;\n\tKi[0]=Ki[n+1]=0;\n\troot = P[1];\n\t\n\tT[root].setid(root);\n\t/*\n\tcout<<\"Preorder\"<<endl;\n\tT[root].pre();\n\tcout<<endl;\n\t\n\tcout<<\"Inorder\"<<endl;\n\tT[root].in();\n\tcout<<endl;\n\t*/\n\tcout<<\"Postorder\"<<endl;\n\tT[root].post();\n\tcout<<endl;\n}\n\n\t\nvoid N::pre()\n{\n\tcout<<' '<<id;\n\tif(l)T[l].pre();\n\tif(r)T[r].pre();\n}\n\nvoid N::in()\n{\n\tif(l)T[l].in();\n\tcout<<' '<<id;\n\tif(r)T[r].in();\n}\n\nvoid N::post()\n{\n\tif(l)T[l].post();\n\tif(r)T[r].post();\n\tcout<<' '<<id;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nstruct node{\n\tint parent_id;\n\tint left_child_id;\n\tint right_child_id;\n};\n\nvoid create_node(int *preorder, int *inorder, node *b, int root_pos, int num);\nint get_left_child(int *inorder, int root_pos, int root_id, int num);\nvoid print_postorder(node* b, int root_id, bool* is_first);\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tnode* b = (node*)calloc((n+1), sizeof(node));\n\tint* preorder = (int*)malloc((n+1) * sizeof(int));\n\tint* inorder  = (int*)malloc((n+1) * sizeof(int));\n\tint* postorder  = (int*)malloc((n+1) * sizeof(int));\n\tfor(int i = 0; i < n+1; ++i){\n\t\tb[i].parent_id      = -1;\n\t\tb[i].left_child_id  = -1;\n\t\tb[i].right_child_id = -1;\n\t}\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%d\", &preorder[i]);\n\t}\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%d\", &inorder[i]);\n\t}\n\tbool *is_first;\n\t*is_first = true;\n\tcreate_node(preorder, inorder, b, 0, n);\n\tint root_id = preorder[0];\n\tprint_postorder(b, root_id, is_first);\n\tputchar('\\n');\n\treturn 0;\n}\nvoid print_postorder(node* b, int root_id, bool* is_first){\n\tif(b[root_id].left_child_id  != -1) print_postorder(b, b[root_id].left_child_id, is_first);\n\tif(b[root_id].right_child_id != -1) print_postorder(b, b[root_id].right_child_id, is_first);\n\tif(*is_first){\n\t\tprintf(\"%d\", root_id);\n\t\t*is_first = false;\n\t}else{\n\t\tprintf(\" %d\", root_id);\n\t}\n}\nvoid create_node(int *preorder, int *inorder, node *b, int root_pos, int num){\n\tint root_id = preorder[root_pos];\n\tint left_pos = get_left_child(inorder, root_pos, root_id, num);\n\tif(left_pos == -1) return;\n\tif(root_pos < left_pos){\n\t\tint left_id = preorder[root_pos+1];\n\t\tb[root_id].left_child_id = left_id;\n\t\tb[left_id].parent_id = root_id;\n\t\tcreate_node(preorder, inorder, b, root_pos+1, left_pos);\n\t\tif(left_pos+1 < num){\n\t\t\tint right_id = preorder[left_pos+1];\n\t\t\tb[root_id].right_child_id = right_id;\n\t\t\tb[right_id].parent_id = root_id;\n\t\t\tcreate_node(preorder, inorder, b, left_pos+1, num);\n\t\t}\n\t}else{\n\t\tif(left_pos+1 >= num) return;\n\t\tint left_id  = inorder[root_pos-1];\n\t\tint right_id = inorder[root_pos+1];\n\t\tb[root_id].right_child_id = right_id;\n\t\tb[right_id].parent_id = root_id;\n\t\tif(left_id == 0 || b[left_id].right_child_id != -1){\n\t\t\tcreate_node(preorder, inorder, b, root_pos+1, num);\n\t\t\treturn;\n\t\t}\n\t\tb[root_id].left_child_id = left_id;\n\t\tb[left_id].parent_id = root_id;\n\t}\n}\n\nint get_left_child(int *inorder, int root_pos, int root_id, int num){\n\tint left_num = -1;\n\tfor(int i = 0; i < num; ++i){\n\t\tif(inorder[i] == root_id){\n\t\t\tleft_num = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn left_num;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdint.h>\n#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <climits>\n#include <vector>\nusing namespace std;\n\n#define DEBUG (0)\n\n#if DEBUG\n#define DPRINTF(...) do { \\\n    printf(\"D(L%d) %s: \", __LINE__, __func__); \\\n    printf(__VA_ARGS__); \\\n  } while (false)\n#else\n#define DPRINTF(...)\n#endif // DEBUG\n\n/* binary tree */\nstruct Node {\n  Node() :\n    left_(-1),\n    right_(-1) { }\n\n  int left_;\n  int right_;\n};\n\n\nint findIdxOf(int val, int start, int end, const int array[])\n{\n  for (int i = start; i <= end; i++)\n  {\n    if (array[i] == val)\n      return i;\n  }\n\n  // The val must be found between start to end index\n  assert(false);\n}\n\nint reconstructTree(Node *node, int start, int end, const int preorder[], const int inorder[])\n{\n  DPRINTF(\"start %d  end %d\\n\", start, end);\n\n#if DEBUG\n  if (true) {\n    for (int i = start; i <= end; i++)\n    {\n      if (i == start) DPRINTF(\"%d\", preorder[i]);\n      else            printf(\" %d\", preorder[i]);\n    }\n    cout << endl;\n\n    for (int i = start; i <= end; i++)\n    {\n      if (i == start) DPRINTF(\"%d\", inorder[i]);\n      else            printf(\" %d\", inorder[i]);\n    }\n    cout << endl;\n  }\n#endif\n\n  if (start == end)\n    return preorder[start];\n\n  if (start > end)\n    return -1;\n\n  // Determine which one is the root node\n  int root = preorder[start];\n  int center = findIdxOf(root, start, end, inorder);\n\n  DPRINTF(\"root %d  center  %d\\n\", root, center);\n\n  // Similarly, determine the root nodes of both the left and right trees\n  // Note that pre-order array has to be alligned before dive into recursively\n  //int newPreorder[center - start - 1];\n  int newPreorder[center];\n  for (int i = start; i < center; i++)\n  {\n    newPreorder[i] = preorder[i+1];\n    DPRINTF(\"newPreorder[%d] %d\\n\", i, newPreorder[i]);\n  }\n\n  node[root].left_ = reconstructTree(node, start, center - 1, newPreorder, inorder);\n  node[root].right_ = reconstructTree(node, center + 1, end, preorder, inorder);\n\n  return root;\n}\n\nvoid traversePostorder(const Node *node, int idx, bool &first)\n{\n  //DPRINTF(\"idx %d\\n\", idx);\n\n  if (&node[idx] == nullptr)\n    return ;\n\n  if (node[idx].left_ > -1)\n    traversePostorder(node, node[idx].left_, first);\n\n  if (node[idx].right_ > -1)\n    traversePostorder(node, node[idx].right_, first);\n\n  if (first)\n  {\n    printf(\"%d\", idx);\n    first = false;\n  }\n  else\n    printf(\" %d\", idx);\n}\n\n\nint main()\n{\n  int numOfNode;\n  cin >> numOfNode; cin.ignore();\n\n  int arrayOfPreorder[numOfNode];\n  int arrayOfInorder[numOfNode];\n\n  for (int i = 0; i < numOfNode; i++)\n    cin >> arrayOfPreorder[i];\n\n  for (int i = 0; i < numOfNode; i++)\n    cin >> arrayOfInorder[i];\n\n#if DEBUG\n  for (int i = 0; i < numOfNode; i++)\n  {\n    if (i == 0) DPRINTF(\"%d\", arrayOfPreorder[i]);\n    else        printf(\" %d\", arrayOfPreorder[i]);\n  }\n  cout << endl;\n\n  for (int i = 0; i < numOfNode; i++)\n  {\n    if (i == 0) DPRINTF(\"%d\", arrayOfInorder[i]);\n    else        printf(\" %d\", arrayOfInorder[i]);\n  }\n  cout << endl;\n#endif\n\n  Node *nodes = new Node[numOfNode];\n\n  int start = 0;\n  int end = numOfNode - 1;\n  int rootIdx = reconstructTree(nodes, start, end, arrayOfPreorder, arrayOfInorder);\n\n  bool first = true;\n  traversePostorder(nodes, rootIdx, first);\n  cout << endl;\n\n  delete[] nodes;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define NUL -1\nconst int N_MAX = 45;\nint root;\nstruct Node{\n    int parent, left, right;\n};\nNode tree[N_MAX];\nint pre[N_MAX], in[N_MAX];\n\nvoid reConstruct(int parent, int * preP, int * inP, int n, bool isLeft){\n    if(n==0) return;\n    int nowRoot = preP[0];\n    tree[nowRoot].parent = parent;\n    //getchar();\n    //cout<<\"-- nowRoot: \"<<nowRoot<<endl;\n    if(parent==NUL){\n        root=nowRoot;\n    }else if(isLeft){\n        tree[parent].left=nowRoot;\n    }else{\n        tree[parent].right=nowRoot;\n    }\n    if(n==1)return;\n    int flag = 0;\n    for(;flag<n;flag++){\n        if(inP[flag]==nowRoot) break;\n    }\n    //cout<<\"nowRoot: \"<<nowRoot<<\" flag: \"<<flag<<endl;\n    reConstruct(nowRoot, preP+1, inP, flag, true);\n    reConstruct(nowRoot, preP+1+flag, inP+1+flag, n-flag-1, false);\n}\n\nvoid post(int id){\n    if(id==NUL) return;\n    if(tree[id].left==NUL&&tree[id].right==NUL){\n        cout<<id<<\" \";\n        return;\n    }\n    post(tree[id].left);\n    post(tree[id].right);\n    if(id==root){\n        cout<<id<<endl;\n    }else{\n        cout<<id<<\" \";\n    }\n}\n\nint main(){\n    int n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>pre[i];\n        tree[i].parent=tree[i].left=tree[i].right=NUL;\n    }\n    tree[n].parent=tree[n].left=tree[n].right=NUL;\n    for(int i=0;i<n;i++){\n        cin>>in[i];\n    }\n    reConstruct(NUL, pre, in, n, true);\n    /*//Debugging/\n    for(int i=1;i<=n;i++){\n        cout<<\"node\"<<i<<\": p: \"<<tree[i].parent<<\"  l: \"<<tree[i].left<<\"  r: \"<<tree[i].right<<endl;\n    }\n    ///Debugging*/\n    post(root);\n\n    //cout<<\"root: \"<<root<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r);\nvoid solve();\n\n\nint main() {\n    int k;\n    cin >> n;\n\n    for (int i = 0; i < n; i++) {\n        cin >> k;\n        pre.push_back(k);\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> k;\n        in.push_back(k);\n    }\n\n    solve();\n}\n\n\nvoid rec(int l, int r) {\n    if (l >= r) return ;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m + 1, r);\n    post.push_back(root);\n}\n\nvoid solve() {\n    pos = 0;\n    rec(0, pre.size());\n    for (int i = 0; i < n; i++) {\n        if ( i ) cout << \" \";\n        cout << post[i];\n    }\n    cout << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstdint>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i, start, end) for(int i = (start); i < (end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nvoid read_problem(vector<int>& preorder, vector<int>& inorder)\n{\n    int n;\n    scanf(\"%d\\n\", &n);\n\n    preorder.resize(n);\n    inorder.resize(n);\n    REP(i, n) {\n        scanf(\"%d\", &preorder[i]);\n    }\n    REP(i, n) {\n        scanf(\"%d\", &inorder[i]);\n    }\n}\n\nstruct Node {\n    int id;\n    //Node* parent;\n    Node* left;\n    Node* right;\n\n    //Node(int i) : id(i), parent(nullptr), left(nullptr), right(nullptr) {}\n    Node(int i) : id(i), left(nullptr), right(nullptr) {}\n};\n\nbool find_in_vector(const vector<int>& v, int x)\n{\n    return find(v.begin(), v.end(), x) != v.end();\n}\n\nvoid solve(Node* root, const vector<int>& preorder, const vector<int>& inorder)\n{\n    // inorder ?????§ root ????????????????????????????????¨?????¨?????????????????????????????¨?????¨\n    auto it_inorder = find(inorder.begin(), inorder.end(), root->id);\n    vector<int> inorder_l(inorder.begin(), it_inorder);\n    vector<int> inorder_r(it_inorder+1,    inorder.end());\n\n    // preorder ?????§ root ??????????????¨?????¨?????????????????????????????????????´??????¢???\n    // ??????????????????????????? idx ??¨????????¨\n    // preorder[1..idx-1] ????????¨?????¨???preorder[idx..] ????????¨?????¨\n    auto it_preorder = find_if(preorder.begin(), preorder.end(),\n                               [root, &inorder_l](int id) { return id != root->id && !find_in_vector(inorder_l, id); });\n    vector<int> preorder_l(preorder.begin()+1, it_preorder);\n    vector<int> preorder_r(it_preorder, preorder.end());\n\n    // ?????¨?????¨????????§???????????° preorder_l[0] ??? root->left\n    // ?????¨?????¨????????§???????????° preorder_r[0] ??? root->right\n    if(!inorder_l.empty()) {\n        Node* left = new Node(preorder_l[0]);\n        root->left = left;\n        solve(left, preorder_l, inorder_l);\n    }\n    if(!inorder_r.empty()) {\n        Node* right = new Node(preorder_r[0]);\n        root->right = right;\n        solve(right, preorder_r, inorder_r);\n    }\n}\n\nvoid postorder(vector<int>& result, const Node* node)\n{\n    if(node->left)\n        postorder(result, node->left);\n    if(node->right)\n        postorder(result, node->right);\n    result.emplace_back(node->id);\n}\n\nint main()\n{\n    vector<int> preorder;\n    vector<int> inorder;\n    read_problem(preorder, inorder);\n    int n = preorder.size();\n\n    Node root(preorder[0]);\n    solve(&root, preorder, inorder);\n\n    vector<int> result;\n    postorder(result, &root);\n    REP(i, n) {\n        printf(\"%d%c\", result[i], i == n-1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <climits>\n#include <cstring>\n#define rep(i, begin, end) for (__typeof(end) i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))\n\nusing namespace std;\n\nconst int N_MAX = 1000000;\nstring ans = \"\";\n/*\n pre: 4 2 3 1 5\n in:  3 2 4 5 1\n\n*/\nstruct Node{\n  int data;\n  Node* left;\n  Node* right;\n};\n\nvoid postorder(Node* root){\n  if(root == NULL) return;\n  postorder(root->left);\n  postorder(root->right);\n  //cout << root->data << \" \";\n  ans += (to_string(root->data) + \" \");\n}\n\n\nvoid print_array(int* arr, int len){\n  rep(i, 0, len){\n    cout << arr[i];\n    if(i==len-1) cout << endl;\n    else cout << \" \";\n  }\n}\n\nNode* solve(int* inorder, int* preorder, int len){\n  cout << \"inorder: \" << endl;\n  print_array(inorder, len);\n  \n  cout << \"preorder: \" << endl;\n  print_array(preorder, len);\n  \n  // find root\n  int root_data = preorder[0];\n  Node* root_node = new Node;\n  root_node->data = root_data;\n  if(len==1) return root_node;\n  \n  // count all the num left\n  int left_num=0;\n  while(inorder[left_num] != root_data) left_num++;\n  int right_num = len - left_num - 1;\n  \n  int* left_inorder = new int[left_num];\n  int* right_inorder = new int[right_num];\n  \n  int* left_preorder = new int[left_num];\n  int* right_preorder = new int[right_num];\n\n  int ix=0;\n  int l_ix=0, r_ix=0;\n\n  rep(ix, 0, len){\n    if(inorder[ix] == root_data) continue;\n    if(l_ix<left_num){\n      left_inorder[l_ix] = inorder[ix];\n      l_ix++;\n    }\n    else if(r_ix<right_num){\n      right_inorder[r_ix] = inorder[ix];\n      r_ix++;\n    }\n  }\n  \n  ix = 0; l_ix = 0; r_ix = 0;\n  \n  rep(ix, 1, len){\n    if(l_ix < left_num){\n      left_preorder[l_ix] = preorder[ix];\n      l_ix++;\n    }\n    else if(r_ix < right_num){\n      right_preorder[r_ix] = preorder[ix];\n      r_ix++;\n    }\n  }\n\n  if(left_num>0) root_node->left = solve(left_inorder, left_preorder, left_num);\n  if(right_num>0) root_node->right = solve(right_inorder, right_preorder, right_num);\n  \n  delete[] left_inorder;\n  delete[] right_inorder;\n  delete[] left_preorder;\n  delete[] right_preorder;\n  \n  return root_node;\n  \n}\n\nint main(){\n  int n; cin >> n;\n  int* inorder = new int[n];\n  int* preorder = new int[n];\n  \n  int tmp;\n  rep(i, 0, n){\n    cin >> tmp;\n    preorder[i] = tmp;\n  }\n  rep(i, 0, n){\n    cin >> tmp;\n    inorder[i] = tmp;\n  }\n\n  Node* root = NULL;\n  root = solve(inorder, preorder, n);\n  postorder(root);\n  rep(i, 0, 2*n-1) cout << ans[i]; \n  cout << endl;\n\n  delete[] inorder;\n  delete[] preorder;\n  delete root;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\nvector <int> pre, in, ans;\n\nvoid rec(int lp, int rp, int li, int ri) {\n    int root = pre[lp];\n    int i = 0;\n    while(in[li+i] != root) i++;\n    if (i != 0) rec(lp+1, lp+i, li, li+i-1);\n    if (li + i != ri) rec(lp+i+1, rp, li+i+1, ri);\n\n    ans.pb(root);\n}\n\nvoid solve(void){\n    int N;\n    cin >> N;\n    pre.resize(N), in.resize(N);\n    rep(N, i) cin >> pre[i];\n    rep(N, i) cin >> in[i];\n    rec(0, N-1, 0, N-1);\n    for (int v : ans) {\n        cout << v << ' ';\n    }\n    cout << endl;\n}\n\nint main(void){\n  solve();\n  //cout << \"yui(*-v・)yui\" << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint n;\nvector<int> pre;\nvector<int> in;\nvector<int> post;\nvector<int> child[42];\nint tree[42]; //store parent\nvoid postorder(int i, vector<int> child[]){\n\tif(i==-1) return;\n\tif(child[i].size()==0){\n\t\tpost.push_back(i);return;\n\t} \n\tvector<int> temp = child[i];\n\tpostorder(temp.at(0),child);\n\tpostorder(temp.at(1),child);\n\tpost.push_back(i);\n}\nvoid inorder(int i, vector<int> child[]){\n\tif(i==-1) return;\n\t//if(child[i]==NULL) return;\n\tvector<int> temp = child[i];\n\tinorder(temp.at(0),child);\n\tin.push_back(i);\n\tinorder(temp.at(1),child);\n}\nvoid preorder(int i, vector<int> child[]){\n\tif(i==-1) return;\n\tpre.push_back(i);\n\tvector<int> temp = child[i];\n\tpreorder(temp.at(0),child);\n\tpreorder(temp.at(1),child);\n}\nint reconstruct(int pre[], int in[], int lp,int rp, int li,int ri){\n\t//printf(\"%d %d %d %d\\n\",lp,rp,li,ri);\n\tif(li==ri){\n\t\t lp++;\n\t\t return in[li];\n\t}\n\tif(li>ri) return -1;\n\t//printf(\"%d \",lp);\n\tint p = pre[lp++];\n\tint index = 0;\n\tfor(int i = li; i<=ri; i++){\n\t\tif(in[i] == p){\n\t\t\tindex = i; break;\n\t\t}\n\t}\n\t\n\t\n\tfor(int i = li; i<=ri; i++){\n\t\tif(i!=index)\n\t\ttree[in[i]] = p;\n\t}\n\t/*for(int i = lp; i<=rp; i++){\n\t\ttree[pre[i]] = p;\n\t}*/\n\t\n\t//inifitivve loop\n\tchild[p].push_back(reconstruct(pre,in,lp,rp,li,index-1));\n\tchild[p].push_back(reconstruct(pre,in,lp+(index-li),rp,index+1,ri));\n\treturn p;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i = 0; i<n; i++){\n\t\ttree[i] = -1;\n\t}\n\tint pre[n];\n\tint in[n];\n\tfor(int i = 0; i<n; i++) {\n\t\tscanf(\"%d\",&pre[i]);\n\t\tpre[i]-=1;\n\t}\n\tfor(int i = 0; i<n; i++) {\n\t\tscanf(\"%d\",&in[i]);\n\t\tin[i]-=1;\t\n\t}\n\t\n\treconstruct(pre,in,0,n-1,0,n-1);\n\t//printf(\"%d %d\\n\",child[4].at(0),child[4].at(1));\n\t\n\t/*for(int i = 0; i<n; i++){\n\t\tprintf(\"%d \",tree[i]);\n\t}printf(\"\\n\");*/\n\t//printf(\"%d\",child[4].size());\n\t/*printf(\"Preorder\\n\");\n\tpreorder(root,child);\n\tfor(int i = 0; i<pre.size(); i++){\n\t\tif(i==pre.size()-1)\n\t\tprintf(\" %d\\n\",pre.at(i));\n\t\telse printf(\" %d\",pre.at(i));\n\t}\n\tprintf(\"Inorder\\n\");\n\tinorder(root,child);\n\tfor(int i = 0; i<in.size(); i++){\n\t\tif(i==in.size()-1)\n\t\tprintf(\" %d\\n\",in.at(i));\n\t\telse printf(\" %d\",in.at(i));\n\t}*/\n\t//printf(\"Postorder\\n\");\n\tpostorder(pre[0],child);\n\tfor(int i = 0; i<post.size(); i++){\n\t\tif(i==post.size()-1)\n\t\tprintf(\"%d\\n\",post.at(i)+1);\n\t\telse printf(\"%d \",post.at(i)+1);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macro_and_Function\n#pragma region Basic\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define FOR(i, a, b) for (int i = (a), i##_len = (b); i < i##_len; i++)\n#define FORD(i, a, b) for (int i = (a), i##_len = (b); i > i##_len; i--)\n#define FORR(t, a) for (auto t : a)\n#define ALL(x) (x).begin(), (x).end()  // sortなどの引数を省略したい\n#define INSERTER(x) inserter((x), (x).end())  // inserter\n#define GET(i, j) get<j>(i)\n#define MT(x, ...) make_tuple(x, __VA_ARGS__)\n#define SZ(x) ((int)(x).size())\n#define PB push_back\n#ifdef _DEBUG\n#define PRE_COMMAND             \\\n    std::cin.rdbuf(in.rdbuf()); \\\n    cout << fixed << setprecision(15);\n#else\n#define PRE_COMMAND cout << fixed << setprecision(15);\n#endif\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\ntemplate <class T>\nT DEG_2_RAD(T deg) {\n    return deg * PI / 180;\n}\ntemplate <class T>\nT RAD_2_DEG(T rad) {\n    return rad * 180 / PI;\n}\ntemplate <class T>\nauto MAX(T& seq) {\n    return *max_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto MIN(T& seq) {\n    return *min_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto SUM(T& seq) {\n    T temp{0};\n    auto& temp2 = temp[0];\n    return accumulate(seq.begin(), seq.end(), temp2);\n}\ntemplate <class T>\nvoid SORT(T& seq) {\n    sort(seq.begin(), seq.end());\n}\ntemplate <class T, class S>\nvoid SORT(T& seq, S sort_order) {\n    sort(seq.begin(), seq.end(), sort_order);\n}\ntemplate <class T>\nvoid SORTR(vector<T>& seq) {\n    sort(seq.begin(), seq.end(), greater<T>());\n}\ntemplate <class T>\nvoid CHMAX(T& a, const T& b) {\n    if (a < b) { a = b; }\n}\ntemplate <class T>\nvoid CHMIN(T& a, const T& b) {\n    if (b < a) { a = b; }\n}\ntemplate <class T>\nset<T> VECTOR_2_SET(vector<T>& v) {\n    set<T> s;\n    for (auto ele : v) { s.insert(ele); }\n    return s;\n}\ntemplate <class T>\nvector<T> SET_2_VECTOR(set<T>& s) {\n    vector<T> v;\n    for (auto ele : s) { v.push_back(ele); }\n    return v;\n}\ntemplate <class T, class S, class R>\nlong long pow(T n_0, S k_0, R mod_0) {\n    long long n = n_0;\n    long long k = k_0;\n    long long mod = mod_0;\n    long long now = 1;\n    while (true) {\n        if (k & 1) { now = now * n % mod; }\n        k >>= 1;\n        if (k == 0) { return now; }\n        n = (n * n) % mod;\n    }\n}\n#pragma endregion Basic\n#pragma region overload\ntemplate <class T, class S>\nvoid operator+=(vector<T>& l, S& r) {\n    for (auto i : r) { l.push_back(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(set<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(multiset<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\nvoid operator*=(string& l, const size_t& r) {\n    string str = l;\n    for (size_t i = 0; i < r - 1; i++) { l += str; }\n}\ntemplate <class T, class S>\nvector<T> operator+(vector<T>& l, S& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T>\nvector<T> operator+(const vector<T> l, const vector<T>& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nset<T> operator+(set<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nset<T> operator+(const set<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nmultiset<T> operator+(multiset<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nmultiset<T> operator+(const multiset<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\nstring operator*(const string l, const size_t& r) {\n    string str = l;\n    for (size_t i = 0; i < r - 1; i++) { str += l; }\n    return str;\n}\n#pragma endregion overload\n#pragma region Input\ntemplate <class Head>\nvoid INPUT(vector<Head>& head);\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head);\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t);\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t);\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t);\ntemplate <class Head>\nvoid INPUT(Head& head);\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail);\n//本体\ntemplate <class Head>\nvoid INPUT(vector<Head>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t) {\n    cin >> get<0>(t);\n}\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t) {\n    cin >> get<0>(t) >> get<1>(t);\n}\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t);\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t);\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);\n}\ntemplate <class Head>\nvoid INPUT(Head& head) {\n    cin >> head;\n}\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail) {\n    INPUT(head);\n    INPUT((tail)...);\n}\n#pragma endregion Input\n#pragma region Print\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t);\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t);\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t);\ntemplate <class Head>\nvoid PRINT2(vector<Head> head);\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head);\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head);\ntemplate <class Head>\nvoid PRINT2(Head head);\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail);\ntemplate <class Head>\nvoid PRINT(Head head);\ntemplate <class... Head>\nvoid PRINT(Head... head);\ntemplate <int N, class Head>\nvoid PRINT(Head head);\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t) {\n    PRINT2(get<0>(t));\n}\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t) {\n    PRINT2(get<0>(t), get<1>(t));\n}\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t));\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t));\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t), get<4>(t));\n}\ntemplate <class Head>\nvoid PRINT2(vector<Head> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(Head head) {\n    cout << head;\n}\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail) {\n    PRINT2(head);\n    cout << \" \";\n    PRINT2((tail)...);\n}\ntemplate <class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\ntemplate <class... Head>\nvoid PRINT(Head... head) {\n    PRINT2((head)...);\n    cout << endl;\n}\ntemplate <int N, class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\n#pragma endregion Print\n#pragma endregion Macro_and_Function\n\ntemplate <class T>\nvector<int> argsort(vector<T>& seq, bool reverse = false) {\n    int sz = (int)seq.size();\n    vector<tuple<T, int>> seq2(sz);\n    for (int i = 0; i < sz; i++) { seq2[i] = make_tuple(seq[i], i); }\n    if (reverse == false) {\n        sort(seq2.begin(), seq2.end(), [](const auto& x, const auto& y) {\n            return get<0>(x) < get<0>(y);\n        });\n    } else {\n        sort(seq2.begin(), seq2.end(), [](const auto& x, const auto& y) {\n            return get<0>(x) > get<0>(y);\n        });\n    }\n    vector<int> ret(sz);\n    for (int i = 0; i < sz; i++) { ret[i] = get<1>(seq2[i]); }\n    return ret;\n}\n\ntemplate <class T>\nvector<int> argsort(vector<T>& seq, auto sort_order) {\n    int sz = (int)seq.size();\n    vector<tuple<T, int>> seq2(sz);\n    for (int i = 0; i < sz; i++) { seq2[i] = make_tuple(seq[i], i); }\n    sort(seq2.begin(), seq2.end(), [&sort_order](const auto& x, const auto& y) {\n        return sort_order(get<0>(x), get<0>(y));\n    });\n    vector<int> ret(sz);\n    for (int i = 0; i < sz; i++) { ret[i] = get<1>(seq2[i]); }\n    return ret;\n}\n\nvector<tuple<int, int, char>> memory;\n\nvoid separate(vector<int> v, int c, int& i, vector<int>& a) {\n    auto idx = find(v.begin(), v.end(), c) - v.begin();\n    vi left_v, right_v;\n    if (idx > 0) { copy(v.begin(), v.begin() + idx, back_inserter(left_v)); }\n    if (idx < SZ(v) - 1) {\n        copy(v.begin() + idx + 1, v.end(), back_inserter(right_v));\n    }\n    if (idx > 0) {\n        i++;\n        memory.PB(MT(c, a[i], 'L'));\n        separate(left_v, a[i], i, a);\n    }\n    if (idx < SZ(v) - 1) {\n        i++;\n        memory.PB(MT(c, a[i], 'R'));\n        separate(right_v, a[i], i, a);\n    }\n}\n\nint main() {\n    PRE_COMMAND\n    int n;\n    int root = 0;\n    INPUT(n);\n    vi a(n), b(n);\n    INPUT(a, b);\n    vi left(n, -1);\n    vi right(n, -1);\n    vi parent(n, -1);\n    vi postorder;\n\n    int idx = 0;\n    while (idx < n) {\n        separate(b, a[idx], idx, a);\n        break;\n    }\n\n    FORR(l, memory) {\n        int i, j;\n        char k;\n        tie(i, j, k) = l;\n        i--;\n        j--;\n        if (k == 'L') {\n            left[i] = j;\n            parent[j] = i;\n        } else {\n            right[i] = j;\n            parent[j] = i;\n        }\n    }\n    REP(i, n) {\n        if (parent[i] == -1) { root = i; }\n    }\n    vector<bool> visited(n, false);\n    int now = root;\n    vector<int> ans(0);\n\n    while (now != -1) {\n        if (left[now] != -1 and visited[left[now]] == false) {\n            now = left[now];\n            continue;\n        }\n        if (right[now] != -1 and visited[right[now]] == false) {\n            now = right[now];\n            continue;\n        }\n        if (visited[now] == false) {\n            visited[now] = true;\n            ans.PB(now+1);\n        }\n        now = parent[now];\n    }\n    PRINT(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint preorder[40],inorder[40];\n\nvoid print_postorder(int lp,int rp,int li,int ri);\n\n\nint main(){\n  int n;\n  cin >> n;\n  for(int i=0;i<n;++i)\n    cin >> preorder[i];\n  for(int i=0;i<n;++i)\n    cin >> inorder[i];\n\n  print_postorder(0,n,0,n);\n\n  return 0;\n}\n\n// lp<= i&&i<rp\nvoid print_postorder(int lp,int rp,int li,int ri){\n  int root = preorder[lp];\n  int num = 0;\n  for(int i=li;inorder[i]!=root;++i){\n    num++;\n  }\n  if(num!=0){\n    print_postorder(lp+1,lp+1+num,li,li+num);\n    print_postorder(lp+1+num,rp,li+num+1,ri);\n  }\n  cout << preorder[lp];\n  if(lp == 0){\n    cout << endl;\n  }else{\n    cout << \" \";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define rep(i, n) for (ll i = 0; i < n; ++i)\nll dx[4] = { 0, 1, 0, -1 };\nll dy[4] = { 1, 0, -1, 0 };\nconst ll INF = LLONG_MAX;\nconst ll MOD = 1e9 + 7;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid recon(int l, int r)\n{\n    // 左部分木と右部分木に分ける\n    if (l >= r) {\n        return;\n    }\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    recon(l, m);\n    recon(m + 1, r);\n    post.push_back(root);\n}\n\nvoid solve()\n{\n    pos = 0;\n    recon(0, (int)pre.size());\n    rep(i, n)\n    {\n        if (i)\n            cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int k;\n    cin >> n;\n    rep(i, n)\n    {\n        cin >> k;\n        pre.push_back(k);\n    }\n\n    rep(i, n)\n    {\n        cin >> k;\n        in.push_back(k);\n    }\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Reconstruction of tree by pre-order and in-order\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\nvoid reconstruction(int, int);\nint n;\nstd::vector<int> in,post;\nstd::queue<int> pre;\nint main(){\n  std::cin>>n;\n  for(int i=0, tmp;i<n;i++) std::cin>>tmp, pre.push(tmp);\n  for(int i=0, tmp;i<n;i++) std::cin>>tmp, in.push_back(tmp);\n  reconstruction(0, n);\n  for(int i=0;i<n;i++){\n    if(i) std::cout<<\" \";\n    std::cout<<post[i];\n  }\n  std::cout<<std::endl;\n  return 0;\n}\nvoid reconstruction(int l, int r){\n  if(l >= r) return;\n  int c;\n  c=pre.front(), pre.pop();\n  int m=distance(in.begin(), find(in.begin(), in.end(),c));\n  reconstruction(l, m), reconstruction(m+1, r);\n  post.push_back(c);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#define N_MAX 40\n#define NIL -1\n\nstruct Node{int p, l, r;}; //parent, left, right\n\nNode T[N_MAX];\nint pre[N_MAX], in[N_MAX];\nint pre_idx = 0;\nint shit_counter = 0;\n\nvoid rec(int parent, int l, int r);\nvoid preorder_treeWalk(int v);\nvoid inorder_treeWalk(int v);\nvoid postorder_treeWalk(int v);\n\n//??¨??????????????????index??¨????????????????????¨????????????????????????????????§????°?????????´????????????\n\nint main()\n{\n    int n, i;\n    cin >> n;\n\n    //input preorder_treeWalk, inorder_treeWalk\n    for (i = 0; i < n; i++) cin >> pre[i];\n    for (i = 0; i < n; i++) cin >> in[i];\n\n    //??¨????????????\n    for (i = 0; i < n; i++)\n        T[i].p = T[i].r = T[i].l = NIL;\n\n    //??¨???????§????\n    rec(-1, 0, n-1);\n\n    /*\n    cout << \"tree aray dump [Complete]\" << endl;\n    for (i = 0; i < 5; i++) {\n        cout << i << \" (v=\" << i+1 << \") \" << T[i].p << \", \" << T[i].l << \", \" << T[i].r << endl;\n    }\n    */\n\n    //??¨?????????\n    /*\n    cout << \"Preorder\" << endl;\n    preorder_treeWalk(pre[0]);\n    cout << endl;\n\n    cout << \"Inorder\" << endl;\n    inorder_treeWalk(pre[0]);\n    cout << endl;\n    */\n//    cout << \"Postorder\" << endl;\n    postorder_treeWalk(pre[0]);\n    cout << endl;\n\n    return 0;\n}\n\n//inorder???????????????l????????????r?????§?????¨?????¨???????§?????????????\nvoid rec(int parent, int l, int r) {\n    int i, p, in_idx, parent_in_idx;\n\n    /*\n    cout << \"pre_idx = \" << pre_idx << \", rec \" << l << \", \" << r << endl;\n    cout << \"tree aray dump\" << endl;\n    for (i = 0; i < 5; i++) {\n        cout << i << \" (v=\" << i+1 << \") \" << T[i].p << \", \" << T[i].l << \", \" << T[i].r << endl;\n    }\n    */\n\n    p = pre[pre_idx];\n\n    in_idx = 0;\n    while (in[in_idx] != p) in_idx++;\n\n    //???????????¨????????????\n    if (parent == -1) {\n        T[p - 1].p = -1;\n    } else {\n        T[p - 1].p = parent;\n\n        //???????????????????????????????????????????????????\n        parent_in_idx = 0;\n        while (in[parent_in_idx] != parent) parent_in_idx++;\n\n        if (in_idx < parent_in_idx)\n            T[parent - 1].l = p;\n        else\n            T[parent - 1].r = p;\n    }\n\n    pre_idx++;\n\n    //??¨?????¨???????????¨??????????????´??????????????????\n    if (l == r) {\n        return;\n    }\n\n    if (l < in_idx)\n        rec(p, l, in_idx - 1); //p????????¨?????¨???????§??????????.\n    if (in_idx < r)\n        rec(p, in_idx + 1, r); //p????????¨?????¨???????§??????????.\n}\n\n//root????????????\nvoid preorder_treeWalk(int v) {\n    cout << \" \" << v;\n\n    if (T[v - 1].l == NIL && T[v - 1].r == NIL) return;\n    if (T[v - 1].l != NIL)\n        preorder_treeWalk(T[v - 1].l);\n    if (T[v - 1].r != NIL)\n        preorder_treeWalk(T[v - 1].r);\n}\n\nvoid inorder_treeWalk(int v) {\n    if (T[v - 1].l != NIL) inorder_treeWalk(T[v - 1].l);\n    cout << \" \" << v;\n    if (T[v - 1].r != NIL) inorder_treeWalk(T[v - 1].r);\n}\n\nvoid postorder_treeWalk(int v) {\n    if (T[v - 1].l != NIL) postorder_treeWalk(T[v - 1].l);\n    if (T[v - 1].r != NIL) postorder_treeWalk(T[v - 1].r);\n\n    if (shit_counter == 0) {\n        cout << v;\n        shit_counter++;\n    } else {\n        cout << \" \" << v;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <iterator>\n#include<algorithm>\nstatic const int NIL = -1;\nstatic const int NumberChild = 2;\nclass Tree {\nprivate:\n\tint id;\n\tint parent;\n\tint child[NumberChild];\n\npublic:\n\tTree() {\n\t\tid = child[0] = child[1] = parent = NIL;\n\t}\n\tvoid AddParent(int ID) {\n\t\tparent = ID;\n\t\treturn;\n\t}\n\tvoid AddID(int ID) {\n\t\tid = ID;\n\t\treturn;\n\t}\n\tvoid AddChild(std::vector<int>&Child) {\n\t\tfor (unsigned int i = 0; i < Child.size(); ++i) {\n\t\t\tchild[i] = Child[i];\n\n\t\t}\n\n\t\treturn;\n\t}\n\tint GetRoot(std::vector<Tree> nodes, int ID) {\n\t\tint RootID = ID;\n\t\tif (RootID != NIL&&nodes[RootID].parent != NIL) {\n\t\t\tRootID = GetRoot(nodes, nodes[RootID].parent);\n\t\t}\n\t\treturn RootID;\n\t}\n\tvoid PreorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid InorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid PostorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t\tif(nodes[ID].id!=NIL)std::cout << \" \" << nodes[ID].id;\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid Reconstruct(const std::vector<int>Pre, const std::vector<int>In, std::vector<Tree> &nodes, const int Root,int &cnt) {\n\t\t\n\t\tint m = std::distance(In.begin(), std::find(In.begin(), In.end(), Root));\n\t\n\t\t//nodes[cnt].AddID(Root);\n\t\tnodes[Root].AddID(Root);\n\t\tif (m == 0||Root==NIL) { return; }\n\t\tstd::vector<int>PreLeft;\n\t\n\t\tstd::copy(&Pre[1], &Pre[m]+1, std::back_inserter(PreLeft));\n\t\t\n\t\tstd::vector<int>PreRight;\n\t\t\n\t\tstd::copy(&Pre[m+1 ], &Pre[Pre.size()-1]+1, std::back_inserter(PreRight));\n\t\t\n\t\tstd::vector<int>InLeft;\n\t\tstd::copy(&In[0], &In[m-1]+1, std::back_inserter(InLeft));\n\t\t\n\n\t\tstd::vector<int>InRight;\n\t\tstd::copy(&In[m]+1, &In[In.size() - 1]+1, std::back_inserter(InRight));\n\t\t\n\n\t\tstd::vector<int>child{ PreLeft.empty() ? NIL : PreLeft[0], PreRight.empty() ? NIL : PreRight[0] };\n\t\t//nodes[cnt].AddChild(child);\n\t\tnodes[Root].AddChild(child);\n\t\tfor (unsigned int i = 0; i < child.size(); ++i) {\n\n\t\t\tnodes[child[i]].AddParent(Root);\n\t\t}\n\t\tReconstruct(PreLeft, InLeft, nodes, PreLeft[0], ++cnt);\n\t\tReconstruct(PreRight, InRight, nodes, PreRight[0], ++cnt);\n\t}\n};\n\nvoid SetVector(std::vector<int>&InputVector) {\n\tfor (unsigned int i = 0; i < InputVector.size(); ++i) {\n\t\tstd::cin >> InputVector[i];\n\t}\n\treturn;\n}\nint main(void) {\n\n\tint n;\n\tstd::cin >> n;\n\tstd::vector<int>Pre(n);\n\tstd::vector<int>In(n);\n\tSetVector(Pre);\n\tSetVector(In);\n\tstd::vector<Tree> nodes(n+1);\n\t//ReconstructWithNoParent\n\tint cnt = 0;\n\tnodes[1].Reconstruct(Pre, In, nodes, Pre[0],cnt);\n\n\tnodes[1].PostorderTreeWalk(nodes, 1);\n\tstd::cout << std::endl;\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Order = vector<int>;\nint pos = 0;\nvoid recon(int left, int right, deque<int> &post, Order pre, Order in) {\n  if ((right - left) == 0) return;\n  auto root = pre[pos];\n  pos += 1;\n  auto mid = distance(in.begin(), find(in.begin(), in.end(), root));\n  recon(left, mid, post, pre, in);\n  recon(mid + 1, right, post, pre, in);\n  post.push_back(root);\n}\nint main() {\n  int n;\n  cin >> n;\n  Order preOrder(n), inOrder(n);\n  deque<int> postOrder;\n\n  for (size_t i = 0; i < n; i++) {\n    cin >> preOrder[i];\n  }\n\n  for (size_t i = 0; i < n; i++) {\n    cin >> inOrder[i];\n  }\n  recon(0, n, postOrder, preOrder, inOrder);\n  for (size_t i = 0; i < n; i++) {\n    if (i == 0) {\n      cout << postOrder[i];\n    } else {\n      cout << ' ' << postOrder[i];\n    }\n  }\n\n  cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <climits>\nusing namespace std;\nint n;\nint P[42];\nint Pi[42];\nint K[42];\nint Ki[42];\n\n\nstruct N {\n\tint id,l, r;\n\tvoid setid(int pi);\n\tvoid pre();\n\tvoid in();\n\tvoid post();\n};\n\nint root;\nN T[25];\n\n/*\n5\n1 2 3 4 5\n3 2 4 1 5\n\n         1\n   2        5\n 3   4\n \n 4 \n 1 2 3 4 \n 4 3 2 1\n        1\n     2\n   3\n 4\n*/\n\n// I think this is a O(n) algorizm\n\nvoid N::setid(int _id)\n{\n//\tcout <<id<<endl;\n\tid = _id; // 4\n\tint pid=Pi[id]; // 4\n\tint kid=Ki[id]; // 1\n\tint idl=P[pid+1]; // 2\n\tint kidl=Ki[idl]; // 3\n\tif (kid>kidl) {\n\t\tl=idl;\n\t\tT[l].setid(l);\n\t}\n\tint idr=K[kid+1];\n\tint pidr=Pi[idr];\n\tif(pidr>pid){\n\t\tr=idr;\n\t\tT[r].setid(r);\n\t}\n//\tcout<<id<<' '<<l<<' '<<r<<endl;\n}\n\n\nint main()\n{\n\tmemset(T, 0, sizeof(T));\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>P[i];\n\tP[0]=P[n+1]=0;\n\tfor(int i=1;i<=n;i++) Pi[P[i]]=i;\n\tPi[0]=Pi[n+1]=-1;\n\tfor(int i=1;i<=n;i++) cin>>K[i];\n\tK[0]=K[n+1]=0;\n\tfor(int i=1;i<=n;i++) Ki[K[i]]=i;\n\tKi[0]=Ki[n+1]=INT_MAX;\n\troot = P[1];\n\t\n\tT[root].setid(root);\n\t/*\n\tcout<<\"Preorder\"<<endl;\n\tT[root].pre();\n\tcout<<endl;\n\t\n\tcout<<\"Inorder\"<<endl;\n\tT[root].in();\n\tcout<<endl;\n\t*/\n//\tcout<<\"Postorder\"<<endl;\n\tT[root].post();\n\tcout<<endl;\n}\n\n\t\nvoid N::pre()\n{\n\tcout<<' '<<id;\n\tif(l)T[l].pre();\n\tif(r)T[r].pre();\n}\n\nvoid N::in()\n{\n\tif(l)T[l].in();\n\tcout<<' '<<id;\n\tif(r)T[r].in();\n}\nbool first = false;\nvoid N::post()\n{\n\tif(l)T[l].post();\n\tif(r)T[r].post();\n\tif (first) cout<<' '; else first = true;\n\tcout<<id;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r)\n{\n    if (l >= r)\n        return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m + 1, r);\n    post.push_back(root);\n}\n\nvoid solve()\n{\n    pos = 0;\n    rec(0, pre.size());\n    for (int i = 0; i < n; i++)\n    {\n        if (i)\n            cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main()\n{\n    int k;\n    cin >> n;\n\n    for (int i = 0; i < n; i++)\n    {\n        cin >> k;\n        pre.push_back(k);\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n        cin >> k;\n        in.push_back(k);\n    }\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cmath>\n#include<vector>\n#include<list>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nvector<int> preorder;\nvector<int> inorder;\nvector<int> postorder;\n\nint pos;\n\nvoid reconstruction(int l, int r) {\n    if (l >= r) {\n        return;\n    }\n\n    int root = preorder[pos];\n    pos++;\n    int m = distance(inorder.begin(), find(inorder.begin(), inorder.end(), root));\n    reconstruction(l, m);\n    reconstruction(m + 1, r);\n    postorder.push_back(root);\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n\n    for (int i = 0; i < n; i++) {\n        int tmp;\n        cin >> tmp;\n        preorder.push_back(tmp);\n    }\n    for (int i = 0; i < n; i++) {\n        int tmp;\n        cin >> tmp;\n        inorder.push_back(tmp);\n    }\n\n    pos = 0;\n    reconstruction(0, n);\n\n    for (int i = 0; i < n; i++) {\n        if (i) {\n            cout << \" \";\n        }\n        cout << postorder[i];\n    }\n    cout << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n    if (l>=r) return;\n    int root=pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(1, m);\n    rec(m+1, r);\n    post.push_back(root);\n}\n\nvoid solve() {\n    pos = 0;\n    rec(1, pre.size());\n    for (int i=0; i<n; i++) {\n        if(i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main() {\n    int k;\n    cin >> n;\n    \n    for (int i=0; i<n; i++) {\n        cin >> k;\n        pre.push_back(k);\n    }\n    \n    for (int i=0; i<n; i++) {\n        cin >> k;\n        in.push_back(k);\n    }\n    \n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct node{\n    int parent;\n    int left;\n    int right;\n    node(){\n        parent = 0;\n        left   = 0;\n        right  = 0;\n    }\n};\n\nvoid restore(vector<int>& pre_o, vector<int>& in_o, vector<node>& T){\n    if (pre_o.size() <= 2) return;\n    int parent = pre_o[1];\n    vector<int> left_in_o;\n    left_in_o.push_back(0);\n    vector<int> right_in_o;\n    right_in_o.push_back(0);\n    int id;\n    for (id = 1; in_o[id] != parent; id++) {\n        left_in_o.push_back(in_o[id]);\n    }\n    for (id++; id < in_o.size(); id++) {\n        right_in_o.push_back(in_o[id]);\n    }\n\n    vector<int> left_pre_o;\n    left_pre_o.push_back(0);\n    vector<int> right_pre_o;\n    right_pre_o.push_back(0);\n    for (id = 2; id <= left_in_o.size(); id++) {\n        left_pre_o.push_back(pre_o[id]);\n    }\n    for (; id < pre_o.size(); id++) {\n        right_pre_o.push_back(pre_o[id]);\n    }\n\n    restore(left_pre_o , left_in_o , T);\n    restore(right_pre_o, right_in_o, T);\n\n    if (left_pre_o.size() > 1) {\n        T[parent].left  = left_pre_o[1];\n        T[left_pre_o[1]].parent  = parent;\n    }\n    if (right_pre_o.size() > 1) {\n        T[parent].right = right_pre_o[1];\n        T[right_pre_o[1]].parent = parent;\n    }\n}\n\nint find_root(vector<node>& T){\n    for (int i = 1; i < T.size(); i++) {\n        if (T[i].parent == 0) return i;\n    }\n}\n\nvoid do_post_order(int id, vector<node>& T, queue<int>& Q){\n    if (id == 0) return;\n    do_post_order(T[id].left , T, Q);\n    do_post_order(T[id].right, T, Q);\n    Q.push(id);\n}\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int> pre_o(n + 1);\n    for (int i = 1; i <= n; i++) {\n        cin >> pre_o[i];\n    }\n    vector<int> in_o(n + 1);\n    for (int i = 1; i <= n; i++) {\n        cin >> in_o[i];\n    }\n\n    vector<node> T(n + 1);\n    restore(pre_o, in_o, T);\n\n    int root = find_root(T);\n    queue<int> Q;\n    do_post_order(root, T, Q);\n    while (!Q.empty()) {\n        cout << \" \" << Q.front();\n        Q.pop();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint pos, n;\n\nvector <int> post, in, pre;\nvoid rec(int left,int right)\n{\n\tif(left >= right)\n\t{\n\t\treturn ;\n\t}\n\tint root = pre[pos++];\n\tint m = distance(in.begin(),find(in.begin(),in.end(),root));\n\trec(left,m);\n\trec(m + 1,right);\n\tpost.push_back(root);\n}\n\nvoid solve()\n{\n\tpos = 0;\n\trec(0,pre.size());\n\tint i;\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tif(i)\n\t\t{\n\t\t\tcout << \" \"; \n\t\t}\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\n\nint main()\n{\n\tcin >> n;\n\tint k;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\t\n\tsolve();\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nvector<int> pre, in, post;\nint n;\n\nvoid rec(int p, int s, int t){\n        if(t<=0) return;\n        int v = pre[p];\n        int i = s;\n        while(in[i]!=v) i++;\n        rec(p+1, s, i-s);\n        rec(p+i-s+1, i+1, t-(i-s)-1);\n        post.push_back(v);\n}\n\n\nint main(){\n        cin>>n;\n        pre.resize(n);\n        in.resize(n);\n        for(int i=0;i<n;i++) cin>>pre[i];\n        for(int i=0;i<n;i++) cin>>in[i];\n\n        rec(0,0,n);\n\n        for(int i=0;i<post.size();i++){\n                cout<<post[i];\n                if(i==post.size()-1) cout<<endl;\n                else cout<<\" \";\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * 给定一个二叉树的前序遍历和中序遍历的结果。\n * 输出该二叉树后序遍历的结点序列.\n * Preorder按照　根>左子树>右子树　顺序递归遍历　例如:{1,2,3,4,5,6,7,8,9}\n * Inorder按照 左子树>根>右子树　顺序递归遍历  例如:{3,2,5,4,6,1,8,7,9}\n * 可以生成如下的二叉树\n *                            (1)\n *                 (2)                    (7)\n *            (3)       (4)            (8)   (9)\n *                   (5)   (6)\n * 首先按Preorder遍历的顺序依次访问各结点.访问过程中,我们能通过in得知各子树内Inorder遍历的顺序,从而重建以当前结点c为根的左子树与右子树.\n * 也就是说,设Preorder遍历的当前结点为c,c在in中的位置为m,m左侧就是c的左子树,右侧就是右子树,然后同理递归.\n * 例如当前结点为1,其在in中的位置为 3 2 5 4 6 [1] 8 7 9,那么当前树的根就是1,左右子树就是 3 2 5 4 6和8 7 9.\n * 接下来在3 2 5 4 6 组成的树中,Preorder遍历的下一个结点2是根(3 [2] 5 4 6), 3 和5 4 6是两个子树.\n * 如果用in的下标l和r表示Preorder当前访问的子树的范围(不包含r),那么这个递归函数可以用如下方法实现.\n * reconstruction(l,r)\n *    if l >= r\n *       return\n *    c = next(pre) //Preorder遍历的下一个结点\n *    M = in.find(c) //在Inorder中的位置\n *\n *    reconstruction(l,m) //重建左子树\n *    reconstruction(m+1,r) //重建右子树\n *\n *    print c //以Posrorder遍历的顺序输出c\n */\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre ,in, post;\n\nvoid rec(int l,int r){\n    if(l>=r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(),find(in.begin(),in.end(),root));\n    rec(l,m);\n    rec(m+1,r);\n    post.push_back(root);\n}\n\nvoid solve(){\n    pos = 0;\n    rec(0,pre.size());\n    for(int i=0;  i<n; i++){\n        if(i) cout<<\" \";\n        cout<<post[i];\n    }\n    cout<<endl;\n}\n\n\nint main(){\n    int k;\n    cin >> n;\n\n    for (int i=0; i<n; i++){\n        cin>>k;\n        pre.push_back(k);\n    }\n\n\n    for(int i=0; i<n; i++){\n        cin>>k;\n        in.push_back(k);\n    }\n\n    solve ();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> pre(1000);\nvector<int> in(1000);\nvector<int> post;\nint rootPoint = 0;\n\nint getNext(){\n    return pre[rootPoint++];\n}\n\nint findInin(int c){\n    return distance(in.begin(), find(in.begin(), in.end(), c));\n}\n\nvoid print(){\n    for(int i = 0; i < post.size(); i++){\n        if(i){\n            cout << \" \";\n        }\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nvoid reconstruction(int l, int r){\n    if(l >= r){\n        return;\n    }\n    int root = getNext(); // preorderの次の節店\n    int m = findInin(root); // inorderにおけるrootの位置\n    reconstruction(l,m);\n    reconstruction(m + 1,r);\n\n    post.push_back(root);\n}\n\nint main(void){\n    int n; cin >> n;\n    for(int i = 0; i < n; i++){\n        cin >> pre[i];\n    }\n    for(int i = 0; i < n; i++){\n        cin >> in[i];\n    }\n    reconstruction(0,n);\n    print();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<stdio.h>\n#include<stdlib.h>\n\nvoid to_post(int* A, int* B, int* C, int h)\n{\n    int x = A[0];\n    C[h - 1] = x;\n    if(h < 2) return;\n    int m = 0;\n    while(B[m] != x) m++; \n    if(m > 0) to_post(A + 1, B, C, m);\n    if(h - m - 1 > 0) to_post(A + m + 1, B + m + 1, C + m, h - m - 1);\n}\n\nint main()\n{\n    int *A, *B, *C;\n    int i, n; scanf(\"%d\", &n);\n\n    A = new int [n]; B = new int [n]; C = new int [n];\n    if(A == NULL || B == NULL || C == NULL) exit(EXIT_FAILURE);\n\n    for(i = 0; i < n; i++){ scanf(\"%d\", &A[i]); C[i] = 0; }\n    for(i = 0; i < n; i++){ scanf(\"%d\", &B[i]); }\n\n    to_post(A, B, C, n);\n\n    printf(\"%d\", C[0]); for(i = 1; i < n; i++){ printf(\" %d\", C[i]); } printf(\"\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n \nstruct node{\n    int l,r;\n};\nnode v[41];\nvector<int> postord;\nvoid dfs(int vi){\n    if(v[vi].l!=0)dfs(v[vi].l);\n    if(v[vi].r!=0)dfs(v[vi].r);\n    postord.pb(vi);\n}\nint pre[41],in[41];\nint main(){\n    int n,root;\n    cin>>n;\n    rep(i,n) cin>>pre[i];\n    rep(i,n) cin>>in[i];\n    rep(i,41) v[i].l=v[i].r=0;\n    root=pre[0];\n    int cp=0,ci=0;\n    while(cp<n-1){\n        v[pre[cp]].l=pre[cp+1];++cp;\n        while(cp<n&&pre[cp]==in[ci]){\n            ++ci;\n            while(ci<n-1&&v[in[ci]].l==in[ci+1]) ++ci;\n            if(n>=n-1) break;\n            v[in[ci]].r=in[ci+1];++ci;\n            ++cp;\n        } \n    }\n    dfs(root);\n    rep(i,n) cout<<postord[i]<<(i==n-1?\"\":\" \");\n    cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nconst ll mod2 = 998244353;\nconst int INF = 1000000005;\n\nint n, pos = 0;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n  if (l >= r) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(l, m);\n  rec(m+1, r);\n  post.push_back(root);\n}\n\nint main() {\n  cin >> n;\n  int k;\n  rep(i, n) {\n    cin >> k;\n    pre.push_back(k);\n  }\n  rep(i, n) {\n    cin >> k;\n    in.push_back(k);\n  }\n\n  rec(0, n);\n\n  rep(i, n) {\n    if (i) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nvoid reconstruction(int left,int right);\nint find(int c);\nvector<int> post;\n\nint n,*pre,*in,i;\n\nint main(){\n\tcin>>n;\n\tpre = new int[n]; in = new int[n];\n\tfor(int i=0;i<n;i++) cin>>pre[i]; for(int i=0;i<n;i++) cin>>in[i];\n\n\treconstruction(0,n);\n\tfor(int i=0;i<n;i++){\n\t\tif(i) cout<<\" \";\n\t\tcout<<post[i];\n\t}\n\tcout<<endl;\n\n\tdelete [] pre; delete [] in;\n\tcin.sync(); cin.get();\n}\n\nvoid reconstruction(int left,int right){\n\tif(left>=right) return;\n\tif(i<n){\n\t\tint c = pre[i++];\n\t\tint m = find(c);\n\t\treconstruction(left,m);\n\t\treconstruction(m+1,right);\n\t\tpost.push_back(c);\n\t}\n}\n\nint find(int c){\n\tfor(int i=0;i<n;i++)\n\t\tif(c==in[i]) return i;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<string>\n#include<sstream>\n#include<cmath>\n#include<numeric>\n#include<map>\n#include<stack>\n#include<queue>\nusing namespace std;\nint inf = 1000000000;\n\nclass tree{\npublic:\n  int parent = -1;\n  int left = -1;\n  int right = -1;\n};\n\nvector<tree> t;\n\nint maketree(int pos, vector<int> pre, vector<int> ino){\n  if( pre.size() == 0 ) return -1;\n  t[pre[0]].parent = pos;\n  if( pre.size() == 1 ) return pre[0];\n  int p = pre[0];\n\n  vector<int> lino;\n  vector<int> rino;\n  bool f = false;\n  for(int i=0; i<ino.size(); i++){\n    if( ino[i] == p ){\n      f = true;\n      continue;\n    }\n    if( !f ) lino.push_back(ino[i]);\n    else rino.push_back(ino[i]);\n  }\n  vector<int> lpre;\n  vector<int> rpre;\n  for(int i=0; i<pre.size(); i++){\n    for(int j=0; j<lino.size(); j++){\n      if( pre[i] == lino[j] ) lpre.push_back(pre[i]);\n    }\n    for(int j=0; j<rino.size(); j++){\n      if( pre[i] == rino[j] ) rpre.push_back(pre[i]);\n    }\n  }\n\n  t[p].left = maketree(p, lpre, lino);\n  t[p].right = maketree(p, rpre, rino);\n  return pre[0];\n}\nvector<int> po;\nvoid postorder(int pos){\n  if( pos == -1 ) return;\n  postorder(t[pos].left);\n  postorder(t[pos].right);\n  po.push_back(pos+1);\n}\n\nint main(void) {\n\n  int n;\n  cin >> n;\n  t.resize(n);\n  vector<int> pre(n);\n  vector<int> ino(n);\n  for(int i=0; i<n; i++) cin >> pre[i];\n  for(int i=0; i<n; i++) cin >> ino[i];\n  for(int i=0; i<n; i++) pre[i]--;\n  for(int i=0; i<n; i++) ino[i]--;\n\n  maketree(-1, pre, ino);\n  postorder(pre[0]);\n\n  for(int i=0; i<po.size(); i++){\n    if( i == po.size() - 1 ) cout << po[i] << endl;\n    else cout << po[i] << \" \";\n  }\n\n\n  return 0;\n}\n\n// EOF"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nstruct Node{int l, r, p, d, h;};\n\nNode T[100];\nint Preorder[100] = {};\nint Inorder[100] = {};\nint Postorder[100] = {};\nint n = 0;\n\nvoid SetDepth(int id, int d = 0) {\n    T[id].d = d;\n    if (T[id].l < 0) {\n    }\n}\n\nint pos = 0;\n\nint Reconstruct(int l, int r, int o = 0) {\n    if (l >= r) {\n        return o;\n    }\n    if (pos == n) {\n        return o;\n    }\n    int tgt = Preorder[pos++];\n    int idx = -1;\n    for (int i = 0; i < n; i++) {\n        if (Inorder[i] == tgt) {\n            idx = i;\n            break;\n        }\n    }\n    o = Reconstruct(l, idx, o);\n    o = Reconstruct(idx + 1, r, o);\n    Postorder[o] = tgt;\n    return ++o;\n}\n\n\nint main() {\n    std::cin >> n;\n    for (int i = 0; i < n; i++) {\n        T[i] = {-1, -1 ,-1, -1, -1};\n    }\n\n    for (int i = 0; i < n; i++) {\n        std::cin >> Preorder[i];\n    }\n\n    for (int i = 0; i < n; i++) {\n        std::cin >> Inorder[i];\n    }\n\n    Reconstruct(0, n, 0);\n    for (int i = 0; i < n; i++) {\n        if (i) std::cout << \" \";\n        std::cout << Postorder[i];\n    }\n    std::cout << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define MAX 40\nint pre[MAX] ={0};\nint in[MAX] = {0};\nint cnt = 0;\nint n;\n\nint next(int A[]) {\n\tint ret;\n\tret = A[cnt];\n\t++cnt;\n\treturn ret;\n}\n\nint in_find(int c) {\n\tint i = 0;\n\twhile (in[i] != c) {\n\t\t++i;\n\t}\n\treturn i;\n}\n\nvoid reconstruction(int l, int r) {\n\tint c, m;\n\t\n\tif (l >= r) return;\n\tc = next(pre);\n\tm = in_find(c);\n\n\treconstruction(l, m);\n\treconstruction(m + 1, r);\n\tif (c != pre[0]) {\n\t\tprintf(\"%d \", c);\n\t} else {\n\t\tprintf(\"%d\\n\", c);\n\t}\n\treturn;\n}\n\nint main(void) {\n\tint i;\n\n\tscanf(\"%d\", &n);\n\n\tfor (i = 0; i < n; ++i) {\n\t\tscanf(\" %d\", &pre[i]);\n\t}\n\n\tfor (i = 0; i < n; ++i) {\n\t\tscanf(\" %d\", &in[i]);\n\t}\n\n\treconstruction(0, n);\n//\tprintf(\"\\n\");\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define NUL -1\nconst int N_MAX = 45;\nint root;\nstruct Node{\n    int parent, left, right;\n};\nNode tree[N_MAX];\nint pre[N_MAX], in[N_MAX];\n\nvoid reConstruct(int parent, int * preP, int * inP, int n, bool isLeft){\n    if(n==0) return;\n    int nowRoot = preP[0];\n    tree[nowRoot].parent = parent;\n    //getchar();\n    //cout<<\"-- nowRoot: \"<<nowRoot<<endl;\n    if(parent==NUL){\n        root=nowRoot;\n    }else if(isLeft){\n        tree[parent].left=nowRoot;\n    }else{\n        tree[parent].right=nowRoot;\n    }\n    if(n==1)return;\n    int flag = 0;\n    for(;flag<n;flag++){\n        if(inP[flag]==nowRoot) break;\n    }\n    //cout<<\"nowRoot: \"<<nowRoot<<\" flag: \"<<flag<<endl;\n    reConstruct(nowRoot, preP+1, inP, flag, true);\n    reConstruct(nowRoot, preP+1+flag, inP+1+flag, n-flag-1, false);\n}\n\nvoid post(int id){\n    if(id==NUL) return;\n    if(tree[id].left==NUL&&tree[id].right==NUL&&id!=root){\n        cout<<id<<\" \";\n        return;\n    }\n    post(tree[id].left);\n    post(tree[id].right);\n    if(id==root){\n        cout<<id<<endl;\n    }else{\n        cout<<id<<\" \";\n    }\n}\n\nint main(){\n    int n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>pre[i];\n        tree[i].parent=tree[i].left=tree[i].right=NUL;\n    }\n    tree[n].parent=tree[n].left=tree[n].right=NUL;\n    for(int i=0;i<n;i++){\n        cin>>in[i];\n    }\n    reConstruct(NUL, pre, in, n, true);\n    /*//Debugging/\n    for(int i=1;i<=n;i++){\n        cout<<\"node\"<<i<<\": p: \"<<tree[i].parent<<\"  l: \"<<tree[i].left<<\"  r: \"<<tree[i].right<<endl;\n    }\n    ///Debugging*/\n    post(root);\n    //cout<<\"root: \"<<root<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l, int r){\n  if(l>=r) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(),in.end(),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\n\nvoid solve(){\n  int i;\n  pos = 0;\n  rec(0,pre.size());\n  for(i=0;i<n;i++){\n    if(i) cout << \" \";\n    cout << post[i];;\n  }\n  cout << endl;\n}\n\nint main(){\n  int k;\n  cin >> n;\n\n  for(int i =0;i<n;i++){\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for(int i=0;i<n;i++){\n    cin >> k;\n    in.push_push(k);\n  }\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r){\n    if(l >= r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(),find(in.begin(),in.end(),root));\n    rec(l,m);\n    rec(m + 1,r);\n    post.push_back(root);\n}\n\nvoid solve(){\n    pos = 0;\n    rec(0,pre.size());\n    for (int i = 0; i < n ; ++i) {\n        if(i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main(){\n    int k;\n    cin >> n;\n\n    for (int i = 0; i < n ; ++i) {\n        cin >> k;\n        pre.push_back(k);\n    }\n    for (int i = 0; i < n ; ++i) {\n        cin >> k;\n        in.push_back(k);\n    }\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nvoid reconstruct(int pb, int pe, int ib, int ie, int* left, int* right, int* preorder, int* inorder) {\n    if (pe != pb) {\n        for (int i=ib; i<=ie; i++) {\n            if (inorder[i] == preorder[pb]) {\n                if (i==ib) {\n                    left[preorder[pb]] = -1;\n                } else {\n                    left[preorder[pb]] = preorder[pb+1];\n                    reconstruct(pb+1, pb+i-ib, ib, i-1, left, right, preorder, inorder);\n                }\n                if (i==ie) {\n                    right[preorder[pb]] = -1;\n                } else {\n                    right[preorder[pb]] = preorder[pb+1+i-ib];\n                    reconstruct(pb+i+1-ib, pe, i+1, ie, left, right, preorder, inorder);\n                }\n            }\n        }\n    } else {\n        left[preorder[pb]] = -1;\n        right[preorder[pb]] = -1;\n    }\n}\n\nvoid postorder(int root, int id, int* left, int* right) {\n    if (left[id] >= 0) {\n        postorder(root, left[id], left, right);\n    }\n    if (right[id] >= 0) {\n        postorder(root, right[id], left, right);\n    }\n    std::cout << id;\n    if (id != root) {\n        std::cout << \" \";\n    }\n}\n\nint main() {\n    int n;\n    int left[41], right[41], preorder[41], inorder[41];\n    std::cin >> n;\n    \n    for (int i=0; i<n; i++) {\n        std::cin >> preorder[i];\n    }\n    for (int i=0; i<n; i++) {\n        std::cin >> inorder[i];\n    }\n\n    reconstruct(0, n-1, 0, n-1, left, right, preorder, inorder);\n\n    postorder(preorder[0], preorder[0], left, right);\n    std::cout << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n\nint n;\nint pre[40], in[40];\nint c[41], p;\n\nvoid rec( int l, int r )\n{\n\tif( l > r )\n\t\treturn;\n\n\tint x = pre[p++];\n\n\trec( l, c[x]-1 );\n\trec( c[x]+1, r );\n\n\tprintf( \"%d%c\", x, x==*pre?'\\n':' ' );\n\n\treturn;\n}\n\nint main()\n{\n\tscanf( \"%d\", &n );\n\n\trep( i, n )\n\t\tscanf( \"%d\", pre+i );\n\trep( i, n )\n\t\tscanf( \"%d\", in+i ), c[in[i]] = i;\n\n\trec( 0, n-1 );\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, n) FOR(i, 0, n)\n#define FOR(i, a, b) for(int i=a; i<b; i++)\n\n#define N 45\nint a[N], b[N]; // first info, second info\nint c[N]; // first index -> comfortable index\nint d[N]; // b gyakubiki\nint e[N]; // comfortable index -> first index\n\nbool first=true;\nvoid tadori(int p, int q, int r, int s){ // [p, q): comfortable, [r, s): index of b, p is also root of this subtree\n    if(q-p==0) return;\n    int mid=d[p]; // koreha index of b\n    int x=mid-r, y=s-mid-1; // left and right size\n    // printf(\"tadori[%d, %d)[%d, %d) -> %d %d\\n\", p, q, r, s, x, y);\n    tadori(p+1, p+1+x, r, r+x); //migigawa\n    tadori(p+1+x, p+1+x+y, r+x+1, r+x+1+y); // hidarigawa tte eigo de left da\n    if(first) first=false; else printf(\" \");\n    printf(\"%d\", e[p]);\n}\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    REP(i, n) scanf(\"%d\", a+i);\n    REP(i, n) scanf(\"%d\", b+i);\n    REP(i, n) c[a[i]]=i;\n    FOR(i, 1, n+1) e[c[i]]=i;\n    REP(i, n) b[i]=c[b[i]];\n    REP(i, n) d[b[i]]=i;\n    tadori(0, n, 0, n);\n    printf(\"\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n  int m, root;\n\n  if (l >= r) return;\n\n  root = pre[pos++];\n  m = distance(in.begin(), find(in.begin(), in.end(), root));\n\n  rec(l, m);\n  rec(m + 1, r);\n  post.push_back(root);\n}\n\nvoid solve(){\n  pos = 0;\n\n  rec(0, pre.size());\n\n  for (int i=0; i<n; i++){\n    if (i) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main(){\n  int k;\n\n  cin >> n;\n  for (int i=0; i<n; i++){\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for (int i=0; i<n; i++){\n    cin >> k;\n    in.push_back(k);\n  }\n\n  solve();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// -*- mode:c++; coding:utf-8; c-basic-offset:2; -*-\n// ALDS1_7_D: Reconstruction of a Tree\n\n#include <cstdio>\n\nusing uint = unsigned int;\nusing uintp = uint*;\n\nstatic void solve(const uintp i_begin, const uintp i_end,\n                  const uintp p_begin, const uintp indices[],\n                  const char* sep = \"\\n\")\n{\n  if (i_begin >= i_end) {\n    return;\n  }\n  const auto i_index = indices[*p_begin];\n  const auto len = i_index-i_begin;\n  auto i_begin1 = i_begin,   i_end1 = i_index, p_begin1 = p_begin+1;\n  auto i_begin2 = i_index+1, i_end2 = i_end,   p_begin2 = p_begin+1+len;\n  solve(i_begin1, i_end1, p_begin1, indices, \" \");\n  solve(i_begin2, i_end2, p_begin2, indices, \" \");\n  std::printf(\"%u%s\", *i_index, sep);\n}\n\nint main()\n{\n  uint n;\n  std::scanf(\"%u\", &n);\n  uint preorders[n];\n  uint inorders[n];\n  uintp indices[n+1]; // 0 not used.\n  uint k;\n  for (auto i = 0u; i < n; ++i) {\n    std::scanf(\"%u\", &k);\n    preorders[i] = k;\n  }\n  for (auto i = 0u; i < n; ++i) {\n    std::scanf(\"%u\", &k);\n    inorders[i] = k;\n    indices[k] = &(inorders[i]);\n  }\n\n  solve(inorders, inorders+n, preorders, indices);\n}\n\n// eof"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) (a)>(b)?(b):(a)\n#define max(a,b) (a)>(b)?(a):(b)\n\nusing namespace std;\n\nenum struct Type\n{\n\tROOT,\n\tINTERNAL,\n\tLEAF\n};\n\nstruct OwnNode\n{\n\tint id;\n\tint parent;\n\tint depth;\n\tint height;\n\tint sibling;\n\tType type;\n\tint left;\n\tint right;\n};\n\nOwnNode tree[100001];\nbool isChild[100001];\nconst string typeStr[] = { \"root\",\"internal node\",\"leaf\" };\n\nint TrackTree(int parentid,int id, int depth)\n{\n\t/*int height = 0;\n\ttree[id].parent = parentid;\n\ttree[id].depth = depth;\n\tfor (int i = 0; i != tree[id].children.size(); i++)\n\t{\n\t\theight = max(height, TrackTree(id, tree[id].children[i], depth + 1));\n\t}\n\tif (tree[id].children.size() == 2)\n\t{\n\t\ttree[tree[id].children[0]].sibling = tree[tree[id].children[1]].id;\n\t\ttree[tree[id].children[1]].sibling = tree[tree[id].children[0]].id;\n\t}\n\ttree[id].height = height;\n\treturn height + 1;*/\n\treturn 0;\n}\n\nvoid PreOrder(int id)\n{\n\tprintf(\" %d\", id);\n\tif (tree[id].left!=-1)\n\t{\n\t\tPreOrder(tree[id].left);\n\t}\n\tif (tree[id].right!=-1)\n\t{\n\t\tPreOrder(tree[id].right);\n\t}\n}\n\nvoid InOrder(int id)\n{\n\tif (tree[id].left != -1)\n\t{\n\t\tInOrder(tree[id].left);\n\t}\n\tprintf(\" %d\", id);\n\tif (tree[id].right != -1)\n\t{\n\t\tInOrder(tree[id].right);\n\t}\n}\n\nvoid PostOrder(int id, int cnt)\n{\n\tif (tree[id].left != -1)\n\t{\n\t\tPostOrder(tree[id].left,1);\n\t}\n\tif (tree[id].right != -1)\n\t{\n\t\tPostOrder(tree[id].right,1);\n\t}\n\tif (cnt == 0)\n\t{\n\t\tprintf(\"%d\", id);\n\t}\n\telse\n\t{\n\t\tprintf(\"%d \", id);\n\t}\n}\n\nint Reconstruct(int a[], int b[], int n)\n{\n\tif (n == 1)\n\t{\n\t\ttree[a[0]].left = -1;\n\t\ttree[a[0]].right = -1;\n\t\treturn a[0];\n\t}\n\n\tint tempi = -1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (b[i] == a[0])\n\t\t{\n\t\t\ttempi = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tint* a1 = new int[tempi];\n\tint* a2 = new int[n - tempi - 1];\n\tint* b1 = new int[tempi];\n\tint* b2 = new int[n - tempi - 1];\n\n\tfor (int i = 0; i < tempi; i++)\n\t{\n\t\ta1[i] = a[i + 1];\n\t\tb1[i] = b[i];\n\t}\n\tfor (int i = 0; i < (n - tempi - 1); i++)\n\t{\n\t\ta2[i] = a[tempi + 1 + i];\n\t\tb2[i] = b[tempi + 1 + i];\n\t}\n\n\tint left, right;\n\tif (tempi != 0)\n\t{\n\t\tleft = Reconstruct(a1, b1, tempi);\n\t\tisChild[left] = true;\n\t\t//printf(\"left:%d\\n\", left);\n\t}\n\telse\n\t{\n\t\tleft = -1;\n\t}\n\tif ((n - tempi - 1) != 0)\n\t{\n\t\tright = Reconstruct(a2, b2, n - tempi - 1);\n\t\tisChild[right] = true;\n\t\t//printf(\"right:%d\\n\", right);\n\t}\n\telse\n\t{\n\t\tright = -1;\n\t}\n\n\ttree[b[tempi]].left = left;\n\ttree[b[tempi]].right = right;\n\n\tdelete[] a1;\n\tdelete[] a2;\n\tdelete[] b1;\n\tdelete[] b2;\n\n\treturn b[tempi];\n}\n\nint main()\n{\n\tint n;\n\tint a[50], b[50];\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> b[i];\n\t}\n\n\t/*for (int i = 0; i < n; i++)\n\t{\n\t\tint id,left,right;\n\t\tscanf(\"%d %d %d\", &id, &left, &right);\n\n\t\ttree[id].id = id;\n\t\ttree[id].depth = 0;\n\t\ttree[id].sibling = -1;\n\t\ttree[id].parent = -1;\n\t\ttree[id].left = left;\n\t\ttree[id].right = right;\n\n\t\tif (left != -1)\n\t\t{\n\t\t\tisChild[left] = true;\n\t\t}\n\t\tif (right != -1)\n\t\t{\n\t\t\tisChild[right] = true;\n\t\t}\n\t}*/\n\n\tReconstruct(a, b, n);\n\n\tint rootID = -1;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (!isChild[i])\n\t\t{\n\t\t\trootID = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*TrackTree(-1, rootID, 0);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (tree[i].parent == -1)\n\t\t{\n\t\t\ttree[i].type = Type::ROOT;\n\t\t}\n\t\telse if (tree[i].children.size() == 0)\n\t\t{\n\t\t\ttree[i].type = Type::LEAF;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttree[i].type = Type::INTERNAL;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tprintf(\"node %d: parent = %d, sibling = %d, degree = %d, depth = %d, height = %d, %s\\n\", tree[i].id, tree[i].parent, tree[i].sibling,tree[i].children.size(),tree[i].depth, tree[i].height,typeStr[(int)tree[i].type].c_str());\n\t}*/\n\n\t/*printf(\"Preorder\\n\");\n\tPreOrder(rootID);\n\tprintf(\"\\nInorder\\n\");\n\tInOrder(rootID);\n\tprintf(\"\\nPostorder\\n\");*/\n\tPostOrder(rootID, 0);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint tree(int k,int l, int n);\n\nint a[50],b[50];\n\nint main(void){\n//??\\???\n\tint i,j,n;\n\t\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&b[i]);\n\t}\n\ttree(0,0,n);\n\tprintf(\"\\b\\n\");\n\treturn 0;\n}\n\nint tree(int k,int l, int n){\n\tif(n==0){\n\t} else \n\tif(n==1){\n\t\tprintf(\"%d \",a[k]);\n\t}else{\n\t\tint i=0;\n\t\twhile(b[l+i]!=a[k]){\n\t\t\ti++;\n\t\t}\n\t\t\n\t\ttree(k+1,l,i);\n\t\ttree(k+i+1,l+i+1,n-i-1);\n\t\tprintf(\"%d \",a[k]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nvector<int> pre,in,post;\nint n,pos;\n\nvoid reconstruction(int l,int r)\n{\n\tif(l>=r)return;\n\tint c=pre[pos++];\n\tint m=distance(in.begin(),find(in.begin(),in.end(),c));\n\treconstruction(l,m);\n\treconstruction(m+1,r);\n\tpost.push_back(c);\n}\n\nint main()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint j;\n\t\tcin>>j;\n\t\tpre.push_back(j);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tint k;\n\t\tcin>>k;\n\t\tin.push_back(k);\n\t}\n\treconstruction(0,n);\n\tfor(int i=0;i<n;i++){\n\t\tif(i)cout<<\" \";\n\t\tcout<<post[i];\n\t}\n\tcout<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n, pos = 0;\nvector<int> pre, in, post;\n\nvoid reconstruction(int left, int right) {\n    if (left >= right) return;\n\n    int r = pre[pos++];\n    int mid = distance(in.begin(), find(in.begin(), in.end(), r));\n    reconstruction(left, mid);\n    reconstruction(mid+1, right);\n    post.push_back(r);\n}\n\nint main(void) {\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        int num; cin >> num;\n        pre.push_back(num);\n    }\n    for (int i = 0; i < n; i++) {\n        int num; cin >> num;\n        in.push_back(num);\n    }\n\n    reconstruction(0, n);\n    for (int i = 0; i < n; i++) {\n        cout << (i ? \" \":\"\") << post[i];\n    }\n    cout << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\nvector <int> pre, in;\n\nvoid rec(int lp, int rp, int li, int ri) {\n    int root = pre[lp];\n    int i = 0;\n    while(in[li+i] != root) i++;\n    if (i != 0) rec(lp+1, lp+i, li, li+i-1);\n    if (li + i != ri) rec(lp+i+1, rp, li+i+1, ri);\n\n    cout << root << ' ';\n}\n\nvoid solve(void){\n    int N;\n    cin >> N;\n    pre.resize(N), in.resize(N);\n    rep(N, i) cin >> pre[i];\n    rep(N, i) cin >> in[i];\n    rec(0, N-1, 0, N-1);\n    printf(\"\\n\");\n}\n\nint main(void){\n  solve();\n  //cout << \"yui(*-v・)yui\" << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n  if(l >= r) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(l, m);\n  rec(m + 1, r);\n  post.push_back(root);\n}\n\nvoid solve() {\n  pos = 0;\n  rec(0, pre.size());\n  for(int i = 0; i < n; i++) {\n    if(i) cout << \" \";\n    cout<<post[i];\n  }\n\n  cout<<endl;\n}\n\nint main(){\n  int k;\n  cin >> n;\n\n  for(int i = 0; i < n; i++) {\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for(int i = 0; i < n; i++) {\n    cin >> k;\n    in.push_back(k);\n  }\n\n  solve();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nclass Node\n{\npublic:\n    Node() {\n        this->_id = 0;\n        this->_left = 0;\n        this->_right = 0;\n        this->_parent = 0;\n    }\n\n    Node(int id) {\n        this->_id = id;\n        this->_left = 0;\n        this->_right = 0;\n        this->_parent = 0;\n    }\n\n    ~Node() {\n        ;\n    }\n\n    // Accessor\n    const int& id() const {\n        return this->_id;\n    }\n\n    int& id() {\n        return this->_id;\n    }\n\n    const int& left() const {\n        return this->_left;\n    }\n\n    int& left() {\n        return this->_left;\n    }\n\n    const int& right() const {\n        return this->_right;\n    }\n\n    int& right() {\n        return this->_right;\n    }\n\n    const int& parent() const {\n        return this->_parent;\n    }\n\n    int& parent() {\n        return this->_parent;\n    }\n\nprivate:\n    int _id;\n    int _left;\n    int _right;\n    int _parent;\n};\n\nstd::vector<Node> nodelist;\nstd::vector<int> post;\n\nvoid postorder(int id)\n{\n    int l = nodelist[id].left();\n    int r = nodelist[id].right();\n    if (l != 0)\n        postorder(l);\n    if (r != 0)\n        postorder(r);\n    // cout << id << \" \";\n    post.push_back(id);\n\n    return;\n}\n\nvoid maketree(std::vector<int>& pre, std::vector<int>& in)\n{\n    // cout << endl;\n\n    int root = pre[0];\n\n    std::vector<int> leftin;\n    std::vector<int> rightin;\n\n    // find root index in inorder\n    auto rootitr = std::find(in.begin(), in.end(), root);\n\n    // copy left and right subtrees\n    std::copy(in.begin(), rootitr, std::back_inserter(leftin));\n    std::copy(rootitr + 1, in.end(), std::back_inserter(rightin));\n\n    // Debug print\n    // cout << \"pre-order : \";\n    // for (int i = 0; i < pre.size(); i++) {\n    //     cout << pre[i] << \" \";\n    // }\n    // cout << endl;\n    // cout << \"in-order : \";\n    // for (int i = 0; i < in.size(); i++) {\n    //     cout << in[i] << \" \";\n    // }\n    // cout << endl;\n    // cout << \"root = \" << root << endl;\n    // cout << \"left subtree : \";\n    // for (int i = 0; i < leftin.size(); i++) {\n    //     cout << leftin[i] << \" \";\n    // }\n    // cout << endl;\n    // cout << \"right subtree : \";\n    // for (int i = 0; i < rightin.size(); i++) {\n    //     cout << rightin[i] << \" \";\n    // }\n    // cout << endl;\n\n    // construct pre-order from two subtrees\n    // pre-order of left subtree\n    std::vector<int> leftpre;\n    if (leftin.size() > 0) {\n        int limin = *std::min_element(leftin.begin(), leftin.end());\n        int limax = *std::max_element(leftin.begin(), leftin.end());\n        std::copy(std::find(pre.begin(), pre.end(), limin),\n                  std::find(pre.begin(), pre.end(), limax) + 1,\n                  std::back_inserter(leftpre));\n    }\n\n    // pre-order of right subtree\n    std::vector<int> rightpre;\n    if (rightin.size() > 0) {\n        int rimin = *std::min_element(rightin.begin(), rightin.end());\n        int rimax = *std::max_element(rightin.begin(), rightin.end());\n        std::copy(std::find(pre.begin(), pre.end(), rimin),\n                  std::find(pre.begin(), pre.end(), rimax) + 1,\n                  std::back_inserter(rightpre));\n    }\n\n    // Debug print\n    // cout << \"pre-order of left subtree : \";\n    // for (int i = 0; i < leftpre.size(); i++) {\n    //     cout << leftpre[i] << \" \";\n    // }\n    // cout << endl;\n    // cout << \"pre-order of right subtree : \";\n    // for (int i = 0; i < rightpre.size(); i++) {\n    //     cout << rightpre[i] << \" \";\n    // }\n    // cout << endl;\n\n    // set children\n    if (leftpre.size() > 0) {\n        // cout << \"Left child of \" << root << \" = \" << leftpre[0] << endl;\n        nodelist[root].left() = leftpre[0];\n    }\n    if (rightpre.size() > 0) {\n        // cout << \"Right child of \" << root << \" = \" << rightpre[0] << endl;\n        nodelist[root].right() = rightpre[0];\n    }\n\n    if (leftpre.size() > 1)\n        maketree(leftpre, leftin);\n    if (rightpre.size() > 1)\n        maketree(rightpre, rightin);\n\n    // cout << endl;\n}\n\nint main(int argc, char const *argv[])\n{\n    int n;\n    cin >> n;\n\n    // initialize nodelist\n    nodelist.resize(n + 1);\n\n    std::vector<int> pre(n);\n    std::vector<int> in(n);\n    // input\n    for (int i = 0; i < n; i++) {\n        cin >> pre[i];\n        // set node id\n        nodelist[i + 1].id() = i + 1;\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> in[i];\n    }\n\n    // construct tree\n    maketree(pre, in);\n\n    // Debug print\n    // cout << endl;\n    // for (int i = 1; i <= n; i++) {\n    //     cout << \"id: \" << nodelist[i].id() << \", left: \" << nodelist[i].left() << \", right: \" << nodelist[i].right() << endl;\n    // }\n\n    // print post-order (argument is id of root)\n    postorder(pre[0]);\n    for (int i = 0; i < post.size() - 1; i++) {\n        cout << post[i] << \" \";\n    }\n    cout << post[post.size() - 1] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nstruct node{\n    int left,right;\n}nodes[100];\n\nint n,pre[100],in[100],inloc[100];\n\nvoid post(int r){\n    if(nodes[r].left!=0)post(nodes[r].left);\n    if(nodes[r].right!=0)post(nodes[r].right);\n    cout<<r;\n    if(r!=pre[0])cout<<\" \";\n}\n\nint main()\n{\n    memset(nodes,0,sizeof(nodes));\n    cin>>n;\n    int i;\n    for(i=0;i<n;i++){\n        cin>>pre[i];\n    }\n    for(i=0;i<n;i++){\n        cin>>in[i];\n        inloc[in[i]]=i;\n    }\n    for(i=0;i<n-1;i++){\n        if(inloc[pre[i+1]]<inloc[pre[i]])nodes[pre[i]].left=pre[i+1];\n        else nodes[in[inloc[pre[i+1]]-1]].right=pre[i+1];\n    }\n    post(pre[0]);\n    cout<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n    if ( l >= r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m + 1, r);\n    post.push_back(root);\n}\n\nvoid solve() {\n    pos = 0;\n    rec(0, pre.size());\n    for ( int i = 0; i < n; i++) {\n        if ( i ) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main() {\n    int k;\n    cin >> n;\n\n    for ( int i = 0; i < n; i++ ) {\n        cin >> k;\n        pre.push_back(k);\n    }\n\n    for ( int i = 0; i < n; i++ ) {\n        cin >> k;\n        in.push_back(k);\n    }\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n// Created by 李青坪 on 2018/10/20.\n//\n\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint pos;\nvector<int > pre, in, back;\n\nvoid reconstruction(int left, int right){\n    if (left >= right) return;\n    int root = pre[pos++];\n    int index = find(in.begin(), in.end(), root) - in.begin();\n    reconstruction(left, index);\n    reconstruction(index+1, right);\n    back.push_back(root);\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    int num;\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &num);\n        pre.push_back(num);\n    }\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &num);\n        in.push_back(num);\n    }\n    pos = 0;\n    reconstruction(0, in.size());\n    for (int j = 0; j < back.size(); ++j) {\n        if (j) printf(\" \");\n        printf(\"%d\", back[j]);\n    }\n    printf(\"\\n\");\n}\n\n/*\n5\n1 2 3 4 5\n3 2 4 1 5\n */\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint n;\nint PRE[100];\nint MID[100];\nint POS[100];\nint idx = 0;\n\nvoid solve(int pre_start, int pre_end, int mid_start, int mid_end) {\n  if (pre_start == pre_end) {\n    return;\n  }\n  if (pre_start + 1 == pre_end) {\n    POS[idx++] = PRE[pre_start];\n    return;\n  }\n\n  int i = 0;\n  while(1) {\n    if(PRE[pre_start] == MID[mid_start+i]) {\n      break;\n    } else {\n      i++;\n    }\n  }\n\n  solve(pre_start+1, pre_start+i+1, mid_start, mid_start+i);\n  solve(pre_start+i+1, pre_end, mid_start+i+1, mid_end);\n\n  POS[idx++] = PRE[pre_start];\n}\n\n\nint main() {\n  cin >> n;\n  for(int i = 0; i < n; i++) cin >> PRE[i];\n  for(int i = 0; i < n; i++) cin >> MID[i];\n\n  solve(0, n, 0, n);\n\n  cout << POS[0];\n  for (int i = 1; i < n; i++) cout << \" \" << POS[i];\n  cout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n \nstruct node{\n    int l,r;\n};\nnode v[41];\nvector<int> postord;\nvoid dfs(int vi){\n    if(v[vi].l>0)dfs(v[vi].l);\n    if(v[vi].r>0)dfs(v[vi].r);\n    postord.pb(vi);\n}\nint pre[41],in[41];\nint main(){\n    int n,root;\n    cin>>n;\n    rep(i,n) cin>>pre[i];\n    rep(i,n) cin>>in[i];\n    rep(i,41) v[i].l=v[i].r=-1;\n    root=pre[0];\n    int cp=0,ci=0;\n    while(cp<n-1&&pre[cp]>0){\n        v[pre[cp]].l=pre[cp+1];++cp;\n        while(cp<n&&pre[cp]==in[ci]){\n            ++ci;\n            while(ci<n-1&&in[ci]>0&&v[in[ci]].l==in[ci+1]) ++ci;\n            if(ci>=n-1){\n                cp=n;break;\n            }\n            v[in[ci]].r=in[ci+1];++ci;\n            ++cp;\n        } \n    }\n    dfs(root);\n    rep(i,n) cout<<postord[i]<<(i==n-1?\"\":\" \");\n    cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define MAX 40\nvector<int> pre, in, post;\nint n, pos;\n\nvoid rec(int l, int r){\n    if(l >= r)  return;\n    int next = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), next));\n    rec(l, m);\n    rec(m+1, r);\n    post.push_back(next);\n}\n\nvoid solve(){\n    pos = 0;\n    rec(0, pre.size());\n    for(int i = 0; i < post.size(); i++){\n        if(i)   cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main(){\n    cin >> n;\n\n    int k;\n    for(int i = 0; i < n; i++){\n        cin >> k;\n        pre.push_back(k);\n    }\n\n    for(int i = 0; i < n; i++){\n        cin >> k;\n        in.push_back(k);\n    }\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define N 42\nint n;\nint a[N];\nint b[N];\nint c[N];\nint ai = 1;\nint ci = 1;\nint used[N];\nvoid rebuild(int left, int right){\n    if(left == right) {\n//        printf(\"%d \", b[left]);\n        c[ci++] = b[left];\n        used[b[left]] = 1;\n         return ;\n    }\n//    int ax = a[ai++];\n    int ax;\n    if(used[a[ai]] == 0){\n        ax = a[ai++];\n    }\n    else{\n        while(used[a[ai]] != 0){\n            ai++;\n        }\n        ax = a[ai++];\n    }\n    int m = 1;\n    for(int i = 1; i <= n; i++){\n        if(b[i] == ax) {\n            m = i;\n            break;\n        }\n    }\n    if(m - 1 >= left) rebuild(left, m-1);\n    if(m + 1 <= right) rebuild(m+1, right);\n//    printf(\"%d \", ax);\n    c[ci++] = ax;\n    used[ax] = 1;\n    return ;\n}\nint main(){\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    for(int i = 1; i <= n; i++) scanf(\"%d\", &b[i]);\n    for(int i = 1; i <= n; i++) used[i] = 0;\n    rebuild(1, n);\n    for(int i = 1; i <= n; i++){\n        if(i == n) printf(\"%d\\n\", c[i]);\n        else printf(\"%d \", c[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// #include {{{\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <forward_list>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <regex>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#ifdef DEBUG\n#include <fmt/format.h>\n#include <fmt/ostream.h>\n#endif\n\nusing namespace std;\n// }}}\n\n// type {{{\nusing  s8 =   int8_t;\nusing  u8 =  uint8_t;\nusing s16 =  int16_t;\nusing u16 = uint16_t;\nusing s32 =  int32_t;\nusing u32 = uint32_t;\nusing s64 =  int64_t;\nusing u64 = uint64_t;\n\ntemplate<typename T>\nusing max_heap = priority_queue<T, vector<T>, less<T>>;\ntemplate<typename T>\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\n// }}}\n\n// hide {{{\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-const-variable\"\n#endif\n// }}}\n\n// ???????????´\n//#define int s64\n\nconstexpr bool AUTOFLUSH = false;\n\nconstexpr bool STDIO_ENABLE = false;\n\nconstexpr int IOS_PREC = 10;\n\nconstexpr int INF_S32 =             1'010'000'000;\nconstexpr s64 INF_S64 = 1'010'000'000'000'000'000LL;\n\nconstexpr auto   INF = INF_S64;\nconstexpr double EPS = 1e-9;\n\nconstexpr s64 MOD = 1'000'000'007;\n\n// hide {{{\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n// }}}\n\n// util {{{\ntemplate<typename T>\nconstexpr bool is_odd(T x)\n{\n    return x % 2 == 1;\n}\n\ntemplate<typename T>\nconstexpr bool is_even(T x)\n{\n    return x % 2 == 0;\n}\n\ntemplate<typename T>\nconstexpr int cmp(T x, T y)\n{\n    return (x > y) - (x < y);\n}\n\ntemplate<typename T>\nconstexpr int sgn(T x)\n{\n    return cmp(x, T(0));\n}\n\ntemplate<typename T>\nconstexpr typename enable_if<is_signed<T>::value,T>::type modulo(T a, T b)\n{\n    assert(b > 0);\n    T r = a % b;\n    return r >= 0 ? r : r+b;\n}\n\ntemplate<typename T>\nconstexpr T clamp(T x, T lo, T hi)\n{\n    assert(lo <= hi);\n    if(x < lo)\n        return lo;\n    else if(x > hi)\n        return hi;\n    else\n        return x;\n}\n\nint sqrti(int x)\n{\n    assert(x >= 0);\n    return static_cast<int>(sqrt(x));\n}\n\ns64 sqrtl(s64 x)\n{\n    assert(x >= 0);\n    return static_cast<s64>(sqrtl(x));\n}\n\ntemplate<typename T>\nbool chmax(T& xmax, const T& x)\n{\n    if(x > xmax) {\n        xmax = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T>\nbool chmin(T& xmin, const T& x)\n{\n    if(x < xmin) {\n        xmin = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T>\nconstexpr int SIZE(const T& c)\n{\n    return static_cast<int>(c.size());\n}\n\ntemplate<typename T, size_t N>\nconstexpr int SIZE(const T (&)[N])\n{\n    return static_cast<int>(N);\n}\n\ntemplate<typename InputIt, typename T>\nint argfind(InputIt first, InputIt last, const T& x)\n{\n    auto it = find(first, last, x);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nint argmax(InputIt first, InputIt last)\n{\n    auto it = max_element(first, last);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nint argmin(InputIt first, InputIt last)\n{\n    auto it = min_element(first, last);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nbool alltrue(InputIt first, InputIt last)\n{\n    return all_of(first, last, [](bool b) { return b; });\n}\n\ntemplate<typename InputIt>\nbool anytrue(InputIt first, InputIt last)\n{\n    return any_of(first, last, [](bool b) { return b; });\n}\n\ntemplate<typename InputIt>\nbool allfalse(InputIt first, InputIt last)\n{\n    return !anytrue(first, last);\n}\n\ntemplate<typename InputIt>\nbool anyfalse(InputIt first, InputIt last)\n{\n    return !alltrue(first, last);\n}\n\nstruct pairhash {\n    template<typename T1, typename T2>\n    size_t operator()(const pair<T1,T2>& p) const\n    {\n        size_t ans = 17;\n        ans = 31*ans + hash<T1>()(p.first);\n        ans = 31*ans + hash<T2>()(p.second);\n        return ans;\n    }\n};\n\ntemplate<typename K, typename V>\npair<typename map<K,V>::iterator, bool> insert_or_assign(map<K,V>& m, const K& k, const V& v)\n{\n    auto it = m.lower_bound(k);\n    if(it != end(m) && !m.key_comp()(k,it->first)) {\n        it->second = v;\n        return make_pair(it, false);\n    }\n    else {\n        auto it_ins = m.insert(it, make_pair(k,v));\n        return make_pair(it_ins, true);\n    }\n}\n\ntemplate<typename K, typename V>\npair<typename unordered_map<K,V>::iterator, bool>\ninsert_or_assign(unordered_map<K,V>& m, const K& k, const V& v)\n{\n    auto it = m.find(k);\n    if(it != end(m)) {\n        it->second = v;\n        return make_pair(it, false);\n    }\n    else {\n        auto it_ins = m.insert(it, make_pair(k,v));\n        return make_pair(it_ins, true);\n    }\n}\n\ntemplate<typename T>\nstring TO_STRING(const T& x)\n{\n    ostringstream out;\n    out << x;\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring JOIN(InputIt first, InputIt last, const string& sep)\n{\n    ostringstream out;\n    while(first != last) {\n        out << *first++;\n        if(first != last)\n            out << sep;\n    }\n    return out.str();\n}\n\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last)\n{\n    using T = typename iterator_traits<InputIt>::value_type;\n    return accumulate(first, last, T());\n}\n\ntemplate<typename T>\nvoid UNIQ(T& c)\n{\n    c.erase(unique(begin(c), end(c)), end(c));\n}\n\ntemplate<typename T, typename C>\nT POP(stack<T,C>& stk)\n{\n    T x = stk.top(); stk.pop();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(queue<T,C>& que)\n{\n    T x = que.front(); que.pop();\n    return x;\n}\n\ntemplate<typename T, typename Cont, typename Cmp>\nT POP(priority_queue<T,Cont,Cmp>& que)\n{\n    T x = que.top(); que.pop();\n    return x;\n}\n\ntemplate<typename T>\nvoid RD(T& x)\n{\n    cin >> x;\n#ifdef DEBUG\n    if(!cin) assert(false);\n#endif\n}\n\n// ?????? {{{\n// FPRINTSEQ {{{\ntemplate<typename InputIt>\nostream& FPRINTSEQ(ostream& out, InputIt first, InputIt last)\n{\n    for(InputIt it = first; it != last; ++it) {\n        if(it != first) out << ' ';\n        out << *it;\n    }\n    return out;\n}\ntemplate<typename InputIt>\nostream& PRINTSEQ(InputIt first, InputIt last)\n{\n    return FPRINTSEQ(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTSEQ(InputIt first, InputIt last)\n{\n    return FPRINTSEQ(cerr, first, last);\n}\n// }}}\n\n// 1?¬????????????? {{{\ntemplate<typename T, size_t N>\nostream& FPRINTARRAY1(ostream& out, const T (&c)[N])\n{\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename T, size_t N>\nostream& PRINTARRAY1(const T (&c)[N])\n{\n    return FPRINTARRAY1(cout, c);\n}\ntemplate<typename T, size_t N>\nostream& DPRINTARRAY1(const T (&c)[N])\n{\n    return FPRINTARRAY1(cerr, c);\n}\n// }}}\n\n// 2?¬????????????? {{{\ntemplate<typename T, size_t N1, size_t N2>\nostream& FPRINTARRAY2(ostream& out, const T (&c)[N1][N2])\n{\n    out << '\\n';\n    for(const auto& e : c) {\n        FPRINTARRAY1(out, e) << '\\n';\n    }\n    return out;\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& PRINTARRAY2(const T (&c)[N1][N2])\n{\n    return FPRINTARRAY2(cout, c);\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& DPRINTARRAY2(const T (&c)[N1][N2])\n{\n    return FPRINTARRAY2(cerr, c);\n}\n// }}}\n\n// ???map???????????? {{{\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& c)\n{\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\n// ?????\\??±???\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T>>& c)\n{\n    out << '\\n';\n    for(const auto& e : c) {\n        out << e << '\\n';\n    }\n    return out;\n}\n\n// ?????\\??±???\nostream& operator<<(ostream& out, const vector<string>& c)\n{\n    out << '\\n';\n    for(const string& e : c) {\n        out << e << '\\n';\n    }\n    return out;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const deque<T>& c)\n{\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const list<T>& c)\n{\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const forward_list<T>& c)\n{\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const set<T>& c)\n{\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const unordered_set<T>& c)\n{\n    return out << set<T>(cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const multiset<T>& c)\n{\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const unordered_multiset<T>& c)\n{\n    return out << multiset<T>(cbegin(c), cend(c));\n}\n\ntemplate<typename T, size_t N>\nostream& operator<<(ostream& out, const array<T,N>& c)\n{\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n// }}}\n\n// map???????????? {{{\ntemplate<typename InputIt>\nostream& FPRINTMAP(ostream& out, InputIt first, InputIt last)\n{\n    out << \"{\\n\";\n    for(auto it = first; it != last; ++it) {\n        out << \"  \" << it->first << \" : \" << it->second << '\\n';\n    }\n    out << \"}\\n\";\n    return out;\n}\ntemplate<typename InputIt>\nostream& PRINTMAP(InputIt first, InputIt last)\n{\n    return FPRINTMAP(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTMAP(InputIt first, InputIt last)\n{\n    return FPRINTMAP(cerr, first, last);\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const map<K,V>& c)\n{\n    return FPRINTMAP(out, cbegin(c), cend(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const unordered_map<K,V>& c)\n{\n    return out << map<K,V>(cbegin(c), cend(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const multimap<K,V>& c)\n{\n    return FPRINTMAP(out, cbegin(c), cend(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const unordered_multimap<K,V>& c)\n{\n    return out << multimap<K,V>(cbegin(c), cend(c));\n}\n// }}}\n\n// stack/queue/priority_queue {{{\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, stack<T,C> c)\n{\n    while(!c.empty()) {\n        out << c.top();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, queue<T,C> c)\n{\n    while(!c.empty()) {\n        out << c.front();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n\ntemplate<typename T, typename Cont, typename Cmp>\nostream& operator<<(ostream& out, priority_queue<T,Cont,Cmp> c)\n{\n    while(!c.empty()) {\n        out << c.top();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n// }}}\n\n// pair/tuple {{{\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1,T2>& p)\n{\n    return out << '(' << p.first << ',' << p.second << ')';\n}\n\ntemplate<typename Tuple, size_t Pos>\nostream& FPRINTTUPLE(ostream& out, const Tuple&)\n{\n    return out;\n}\n\ntemplate<typename Tuple, size_t Pos, typename T, typename... TS>\nostream& FPRINTTUPLE(ostream& out, const Tuple& t)\n{\n    if(Pos != 0)\n        out << ',';\n    out << get<Pos>(t);\n    return FPRINTTUPLE<Tuple,Pos+1,TS...>(out, t);\n}\n\ntemplate<typename... TS>\nostream& operator<<(ostream& out, const tuple<TS...>& t)\n{\n    out << '(';\n    FPRINTTUPLE<tuple<TS...>,0,TS...>(out, t);\n    out << ')';\n    return out;\n}\n// }}}\n\n// PRINT {{{\nostream& FPRINT(ostream& out) { return out; }\n\ntemplate<typename T, typename... TS>\nostream& FPRINT(ostream& out, const T& x, const TS& ...args)\n{\n    out << x;\n    if(sizeof...(args))\n        out << ' ';\n    return FPRINT(out, args...);\n}\n\ntemplate<typename... TS>\nostream& FPRINTLN(ostream& out, const TS& ...args)\n{\n    FPRINT(out, args...);\n    return out << '\\n';\n}\n\ntemplate<typename... TS>\nostream& PRINT(const TS& ...args)\n{\n    return FPRINT(cout, args...);\n}\n\ntemplate<typename... TS>\nostream& PRINTLN(const TS& ...args)\n{\n    return FPRINTLN(cout, args...);\n}\n\ntemplate<typename... TS>\nostream& DPRINT(const TS& ...args)\n{\n    return FPRINT(cerr, args...);\n}\n\ntemplate<typename... TS>\nostream& DPRINTLN(const TS& ...args)\n{\n    return FPRINTLN(cerr, args...);\n}\n// }}}\n// }}}\n\nvoid FLUSH()\n{\n    if(STDIO_ENABLE)\n        fflush(stdout);\n    else\n        cout.flush();\n}\n\n[[noreturn]] void EXIT()\n{\n#ifdef DEBUG\n    fflush(stdout);\n    fflush(stderr);\n    cout.flush();\n    cerr.flush();\n#else\n    FLUSH();\n#endif\n    //quick_exit(0); // does not work on codeforces\n    _Exit(0);\n}\n\nstruct IoInit {\n    IoInit()\n    {\n#ifndef DEBUG\n        cin.tie(nullptr);\n        if(!STDIO_ENABLE)\n            ios::sync_with_stdio(false);\n#endif\n        cout << fixed << setprecision(IOS_PREC);\n\n        if(AUTOFLUSH) {\n            if(STDIO_ENABLE)\n                setvbuf(stdout, nullptr, _IONBF, 0);\n            cout << unitbuf;\n        }\n    }\n} IOINIT;\n\n#define FOR(i, start, end) for(int i = (start); i < (end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cc) { return (f)(begin(cc), end(cc), ## __VA_ARGS__); })(c))\n\n#define MEMSET(a,v) memset((a), (v), sizeof(a))\n\n#define DBG(x) DPRINTLN('L', __LINE__, ':', #x, ':', (x))\n// }}}\n\nint N;\n\nvector<int> preorder;\nvector<int> inorder;\n\nint pre_i = 0;\nvector<int> postorder;\n\nvoid rec(int l, int r)\n{\n    if(l >= r) return;\n\n    int root = preorder[pre_i++];\n    int mid = l + argfind(begin(inorder)+l, begin(inorder)+r, root);\n    rec(l, mid);\n    rec(mid+1, r);\n    postorder.emplace_back(root);\n}\n\nvoid solve()\n{\n    rec(0, N);\n\n    PRINTLN(postorder);\n}\n\nsigned main(signed /*argc*/, char** /*argv*/)\n{\n    RD(N);\n    preorder.resize(N);\n    inorder.resize(N);\n\n    REP(i, N) {\n        RD(preorder[i]);\n    }\n\n    REP(i, N) {\n        RD(inorder[i]);\n    }\n\n    solve();\n\n    EXIT();\n}"
  },
  {
    "language": "C++",
    "code": "// ALDS1_7_D.cpp\n// Tree - Reconstruction of a Tree\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid reconst(vector<int>& pre, vector<int>& in, vector<int>& post)\n{\n    if (pre.empty()) return;\n    int root = pre[0];\n    int in_root = 0;\n    for (int i = 0; i < in.size(); i++) {\n        if (in[i] == root) {\n            in_root = i;\n            break;\n        }\n    }\n    vector<int> in_left(in.begin(), in.begin() + in_root);\n    vector<int> in_right(in.begin() + in_root + 1, in.end());\n    vector<int> pre_left(pre.begin() + 1, pre.begin() + in_root + 1);\n    vector<int> pre_right(pre.begin() + in_root + 1, pre.end());\n    reconst(pre_left, in_left, post);\n    reconst(pre_right, in_right, post);\n    post.push_back(root);\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<int> preorder(n);\n    vector<int> inorder(n);\n    vector<int> postorder;\n    for (int i = 0; i < n; i++) {\n        cin >> preorder[i];\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> inorder[i];\n    }\n    reconst(preorder, inorder, postorder);\n    for (int i = 0; i < n; i++) {\n        if (i > 0) cout << \" \";\n        cout << postorder[i];\n    }\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing ll = long long;\nusing namespace std;\n\n/* initialize */\nint pos;\nvector<int> A, B, C;\n/* main */\nvoid recon(int l, int r){\n    if (l >= r) return;\n    int root = A[pos++];\n    int m;\n    m = distance(B.begin(), find(B.begin(), B.end(), root));\n    recon(l, m);\n    recon(m+1, r);\n    C.push_back(root);\n}\nint main() {\n    int n;\n    cin >> n;\n    int k;\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &k);\n        A.push_back(k);\n    }\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &k);\n        B.push_back(k);\n    }\n\n    int pos = 0;\n    recon(0, A.size());\n    for (int j = 0; j < n; ++j) {\n        if (j) cout << \" \";\n        cout << C[j];\n    }\n    cout << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n\nusing namespace std;\n\nint pre[41], in[41], n, _index = 0;\n\nint findInInOrder (int u) {\n  int result = -1;\n\n  for (int i = 0; i < n; i++) {\n    if (in[i] == u) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nvoid reconstruction (int l, int r) {\n  if (l >= r)\n    return;\n\n  int c = pre[_index++];\n  int m = findInInOrder(c); // middle\n\n  // printf(\"c = %d, m = %d\\n\", c, m);\n  \n  reconstruction(l, m);\n  reconstruction(m + 1, r);\n\n  printf(\"%d\", c);\n  if (c == pre[0])\n    printf(\"\\n\");\n  else\n    printf(\" \");\n}\n\nint main () {\n  cin >> n;\n\n  for (int i = 0; i < n; i++)\n    cin >> pre[i];\n\n  for (int i = 0; i < n; i++)\n    cin >> in[i];\n\n  reconstruction(0, n);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n  if(l >= r) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(l, m);\n  rec(m + 1, r);\n  post.push_back(root);\n}\n\nvoid solve(){\n  pos = 0;\n  rec(0, pre.size());\n  for(int i = 0; i < n; i++){\n    if(i) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main(void){\n  int k;\n  cin >> n;\n\n  for(int i = 0; i < n; i++){\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for(int i = 0; i < n; i++){\n    cin >> k;\n    in.push_back(k);\n  }\n\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdint>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstatic uint32_t index = 0;\nvoid reconstruction(vector<int32_t> pre, vector<int32_t> in, uint32_t l, uint32_t r, void (*postorder)(int32_t))\n{\n  if (l >= r) return;\n\n  int32_t root = pre[index];\n  index++;\n\n  uint32_t root_index = 0;\n  for (uint32_t i = 0; i < in.size(); i++) {\n    if (in[i] == root) {\n      root_index = i;\n      break;\n    }\n  }\n\n  reconstruction(pre, in, l, root_index, postorder);\n  reconstruction(pre, in, root_index + 1, r, postorder);\n\n  if (postorder != nullptr) {\n    postorder(root);\n  }\n}\n\n#if !defined(TEST)\n\nstatic vector<int32_t> pre, in, post;\n\nstatic void postorder(int32_t index)\n{\n  post.push_back(index);\n}\n\nint32_t main()\n{\n  uint32_t len;\n  cin >> len;\n\n  for (uint32_t i = 0; i < len; i++) {\n    int32_t index;\n    cin >> index;\n    pre.push_back(index);\n  }\n\n  for (uint32_t i = 0; i < len; i++) {\n    int32_t index;\n    cin >> index;\n    in.push_back(index);\n  }\n\n  reconstruction(pre, in, 0, in.size(), postorder);\n\n  for (uint32_t i = 0; i < post.size(); i++) {\n    if (i != 0) {\n      cout << \" \";\n    }\n\n    cout << post[i];\n  }\n  cout << endl;\n\n  return 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n    if(l >= r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m + 1, r);\n    post.push_back(root);\n}\n\nvoid solve() {\n    pos = 0;\n    rec(0, pre.size());\n    for(int i = 0; i < n; i++) {\n        if(i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main() {\n    int k;\n    cin >> n;\n    for(int i = 0; i < n; i++) {\n        cin >> k;\n        pre.push_back(k);\n    }\n    \n    for(int i = 0; i < n; i++) {\n        cin >> k;\n        in.push_back(k);\n    }\n    \n    solve();\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n    if (l >= r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m + 1, r);\n    post.push_back(root);\n}\n\nvoid solve() {\n    rec(0, n);\n    for (int i = 0; i < n; i++) {\n        if (i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main(void) {\n    int k;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> k;\n        pre.push_back(k);\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> k;\n        in.push_back(k);\n    }\n\n    solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Reconstruction of a Tree\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\ntypedef pair<int,int> pii;\n#define MAX_N 40\npii g[MAX_N];\nvector<int> p;\n\nvoid f(vector<int> p,vector<int> m){\n\tvector<int> np[2],nm[2];\n\tint ind=0;\n\tfor(int i=0;i<m.size();++i){\n\t\tif(p[0]==m[i]){\n\t\t\t++ind;\n\t\t\tcontinue;\n\t\t}\n\t\tnm[ind].pb(m[i]);\n\t}\n\tfor(int i=1;i<=nm[0].size();++i) np[0].pb(p[i]);\n\tfor(int i=nm[0].size()+1;i<p.size();++i) np[1].pb(p[i]);\n\tif(np[0].size()>0){\n\t\tg[p[0]].fi=np[0][0];\n\t\tf(np[0],nm[0]);\n\t}else g[p[0]].fi=-1;\n\tif(np[1].size()>0){\n\t\tg[p[0]].sc=np[1][0];\n\t\tf(np[1],nm[1]);\n\t}else g[p[0]].sc=-1;\n}\n\nvoid dfs(int u){\n\tint v=g[u].fi,w=g[u].sc;\n\tif(v>=0){\n\t\tdfs(v);\n\t\tcout<<v<<\" \";\n\t}\n\tif(w>=0){\n\t\tdfs(w);\n\t\tcout<<w<<\" \";\n\t}\n}\n\nint main(){\n\tint n;\n\tvector<int> m;\n\tcin>>n;\n\tfor(int i=0;i<n;++i){\n\t\tint a;\n\t\tcin>>a;\n\t\tp.pb(a);\n\t}\n\tfor(int i=0;i<n;++i){\n\t\tint a;\n\t\tcin>>a;\n\t\tm.pb(a);\n\t}\n\tf(p,m);\n\tdfs(p[0]);\n\tcout<<p[0]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector< int > preorder;\nvector< int > inorder;\n\nvoid printPost(int n,\n\t       int inBegin,\n\t       int inEnd) {\n  if (inBegin == inEnd)\n    return;\n  if (inBegin == (inEnd-1)) {\n    cout << inorder[inBegin];\n    if (inorder[inBegin] == preorder[0])\n      cout << endl;\n    else\n      cout << ' ';\n    return;\n  }\n  for (int j = 0; j < n; j++) {\n    for (int i = inBegin; i < inEnd; i++)\n      if (inorder[i] == preorder[j]) {\n\tprintPost(n, inBegin, i);\n\tprintPost(n, i+1, inEnd);\n\tcout << inorder[i];\n\tif (inorder[i] == preorder[0])\n\t  cout << endl;\n\telse\n\t  cout << ' ';\n\treturn;\n      }\n  }\n}\n  \n\nint main(int argc, char **argv) {\n  ios_base::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  preorder = vector< int > (n, 0);\n  for (int i = 0; i < n; i++)\n    cin >> preorder[i];\n  inorder = vector< int > (n, 0);\n  for (int i = 0; i < n; i++)\n    cin >> inorder[i];\n  printPost(n, 0, n);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct Node {\n  int id;\n  int left;\n  int right;\n  Node(int id) {\n    this->id = id;\n    this->left = -1;\n    this->right = -1;\n  }\n};\nvoid crawl_postorder(vector<Node*> &node_list, vector<int> &order_list, Node* node) {\n  if(node->left != -1) {\n    crawl_postorder(node_list,order_list,node_list[node->left]);\n  }\n  if(node->right != -1) {\n    crawl_postorder(node_list,order_list,node_list[node->right]);\n  }\n  order_list.push_back(node->id);\n  return;\n}\n\nint main() {\n  /* input */\n  int n; cin >> n;\n  vector<int> pre_list(n);\n  vector<int> in_list(n);\n  for(int i=0;i<n;i++)\n    cin >> pre_list[i];\n  for(int i=0;i<n;i++)\n    cin >> in_list[i];\n\n  /* construct tree */\n  vector<Node*> node_list(n+1,NULL);\n  int root_id = pre_list[0];\n  node_list[root_id] = new Node(root_id);\n  for(int i=1;i<n;i++) {\n    int pre_id = pre_list[i];\n    node_list[pre_id] = new Node(pre_id);\n\n    int pre2in_index;\n    for(int j=0;j<n;j++) {\n      if(pre_list[i] == in_list[j]) {\n        pre2in_index = j;\n        break;\n      }\n    }\n\n    int in_left_index = -1;\n    for(int j=pre2in_index-1;j>=0;j--) {\n      if(node_list[in_list[j]] != NULL) {\n        in_left_index = j;\n        break;\n      }\n    }\n    int in_right_index = -1;\n    for(int j=pre2in_index+1;j<n;j++) {\n      if(node_list[in_list[j]] != NULL) {\n        in_right_index = j;\n        break;\n      }\n    }\n\n    int pre_left_index = -1;\n    if(in_left_index != -1) {\n      for(int j=0;j<n;j++) {\n        if(pre_list[j] == in_list[in_left_index]) {\n          pre_left_index = j;\n          break;\n        }\n      }\n    }\n    int pre_right_index = -1;\n    if(in_right_index != -1) {\n      for(int j=0;j<n;j++) {\n        if(pre_list[j] == in_list[in_right_index]) {\n          pre_right_index = j;\n          break;\n        }\n      }\n    }\n\n    int parent_id;\n    if(pre_right_index > pre_left_index)\n      parent_id = pre_list[pre_right_index];\n    else\n      parent_id = pre_list[pre_left_index];\n\n    if(in_list[in_right_index] == parent_id)\n      node_list[parent_id]->left = pre_id;\n    else\n      node_list[parent_id]->right = pre_id;\n\n  }\n  vector<int> order_list;\n  crawl_postorder(node_list,order_list,node_list[root_id]);\n  for(int i=0;i<n-1;i++) {\n    cout << order_list[i] << \" \";\n  }\n  cout << order_list[n-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nvector<int> pre, in;\nint pos = 0;\n\nvoid postorder(int l, int r) { //???????????§???????????¨??????\n\tif (l >= r) return;\n\tint root = pre[pos++]; //????±??????°???????????????????????????????????????????????????????????????\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root)); //in?????????root????????????\n\tpostorder(l, m); //m???l????????£?????????\n\tpostorder(m + 1, r);\n\tcout << root << ' ';\n}\n\nint main() {\n\tint n, k;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\t{\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\tfor (int i = 0; i < n; i++)\t{\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\n\tpostorder(0, pre.size());\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//compiledef\n#include <bits/stdc++.h>\n#define rep(i, n) for(i=0;i<(n);i++)\n#define per(i, n) for(i=(n);i>0;i--)\n#define repx(i, n, x) for(i=(x);i<(n);i++)\n#define xper(i, n, x) for(i=(n);i>(x);i--)\n#define pback push_back\n\n//c++def\nusing namespace std;\ntypedef long long int ll;\nconst ll MOD = 1e9+7;\nconst ll MOD2 = 998244353;\nvector<int> preo, ino;\n\n//memo\n/*\n   3 - 4 - 1\n   p = [4] 3 1\n   i = 3 [4] 1\n   pos = 3 1 [4]\n\n  \t\t\t\t\t\t\t*fake binary search?* \n   4(root) -> in.4(root) -> p.(hidari)(ppos:1) range:inpos:0-1\n   \t\t\t  (orpos:1)  -> p.(migi)(ppos:2) range:inpos:2-(3)\n\t\t\t  \t\t\t -> print: 3 1 4\n   */\nvoid search(int l, int r){\n\tif(l >= r)return;\n\tstatic int i = 0;\n\tint j;\n\tint orpos;\n\tstatic bool zero = true; \n\tint root = preo[i++];\n\tfor(j=0;j<(int)ino.size();j++){\n\t\tif(ino[j] == root)\n\t\t\tbreak;\n\t}\n\tsearch(l, j);\n\tsearch(j+1, r);\n\tif(!zero) printf(\" \");\n\telse zero = false;\n\tprintf(\"%d\", root);\n}\n\nint main(){\n\tint i, n;\n\tcin >> n;\n\tint tmp;\n\trep(i, n){\n\t\tcin >> tmp;\n\t\tpreo.pback(tmp);\n\t}\n\trep(i, n){\n\t\tcin >> tmp;\n\t\tino.pback(tmp);\n\t}\n\tsearch(0, n);\n\tcout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(int post[], int pre[], int in[], int l, int r, int *pos, int n, int *s)\n{\n    if (l >= r)\n        return;\n    int root = pre[*pos];\n    *pos += 1;\n    int m;\n    for (int i = 0; i < n; i++)\n    {\n        if (root == in[i])\n        {\n            m = i;\n            break;\n        }\n    }\n    solve(post, pre, in, l, m, pos, n, s);\n    solve(post, pre, in, m + 1, r, pos, n, s);\n    post[*s] = root;\n    *s += 1;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    int pre[n];\n    int in[n];\n    for (int i = 0; i < n; i++)\n        cin >> pre[i];\n    for (int i = 0; i < n; i++)\n        cin >> in[i];\n    int post[n];\n    int pos = 0;\n    int s = 0;\n    solve(post, pre, in, 0, n, &pos, n, &s);\n    for (int i = 0; i < n; i++)\n    {\n        cout << post[i];\n        if (i != n - 1)\n            cout << ' ';\n    }\n    cout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n\nusing namespace std;\n\nint n, pos;\nint pre[40], in[40], post[40];\nbool preused[40];\n\ninline int toinnode(int prenode) {\n    for (int i = 0; i < n; ++i) {\n        if (in[i] == pre[prenode]) {\n            return i;\n        }\n    }\n}\n\ninline int toprenode(int innode) {\n    for (int i = 0; i < n; ++i) {\n        if (pre[i] == in[innode]) {\n            return i;\n        }\n    }\n}\n\ninline int getpreleft(int prenode) {\n    int innode = toinnode(prenode);\n\n    bool ng = innode == 0;\n    if (ng) { return -1; }\n\n    if (preused[toprenode(innode - 1)]) {\n        return -1;\n    }\n\n    int preleft = prenode + 1;\n    ng = preleft < 0 || preleft >= n || preused[preleft];\n    if (ng) {\n        return -1;\n    }\n    else {\n//        printf(\"[getpreleft] preleft = %d, pre[preleft] = %d\\n\",\n//                             preleft, pre[preleft]);\n        return preleft;\n    }\n}\n\ninline int getpreright(int prenode) {\n    int innode = toinnode(prenode);\n    bool nolefttree = innode == 0;\n    if (!nolefttree) {\n//        printf(\"[getpreright] pre[%d] = %d, preused[%d] = %s\\n\",\n        nolefttree = preused[toprenode(innode - 1)];\n    }\n    if (nolefttree && innode + 1 < n && !preused[toprenode(innode + 1)]) {\n//        printf(\"[getpreright] No Left Tree\\n\");\n        return prenode + 1 < n ? prenode + 1 : -1;\n    }\n\n    int preright = 1 + toprenode(innode - 1);\n    bool ng = (preright < 0 || preright >= n || preused[preright]);\n    if (ng) {\n        return -1;\n    }\n//    printf(\"[getpreright] preright = %d, pre[preright] = %d\\n\",\n//            preright, pre[preright]);\n    return preright;\n//    for (int i = 0; i < n; ++i) {\n//        if (pre[i] == in[innode - 1]) {\n//            int preright = i + 1;\n//            bool ng = (preright < 0 || preright >= n || preused[preright]);\n//            if (ng) {\n//                return -1;\n//            }\n//            printf(\"[getpreright] preright = %d, pre[preright] = %d\\n\",\n//                    preright, pre[preright]);\n//            return preright;\n//        }\n//    }\n}\n\ninline void topost(int prenode) {\n\n    int preleft  = getpreleft(prenode);\n    int preright = getpreright(prenode);\n    if (preleft != -1) preused[preleft] = true;\n    if (preright != -1) preused[preright] = true;\n\n//    printf(\"[topost] #index: root = %d, left = %d, right = %d\\n\",\n//                     prenode, preleft, preright);\n//    printf(\"[topost] #value: root = %d, left = %d, right = %d\\n\\n\",\n//                     pre[prenode],\n//                     preleft != -1 ? pre[preleft] : -1,\n//                     preright != -1 ? pre[preright] : -1);\n\n    if (preleft != -1) {\n        topost(preleft);\n    }\n\n    if (preright != -1) {\n        topost(preright);\n    }\n\n    post[pos++] = pre[prenode];\n}\n\nint main(void) {\n\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &pre[i]);\n    }\n\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &in[i]);\n    }\n\n    preused[0] = true;\n    topost(0);\n\n    printf(\"%d\", post[0]);\n    for (int i = 1; i < n; ++i) {\n        printf(\" %d\", post[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint N;\nint left_c[64], right_c[64];\n\nint pre[64], in[64], idx[64];\nint recon(int& x, int l, int r){\n  if(l >= r) return -1;\n  int i = pre[x++];\n  int mid = idx[i];\n\n  if(r - l == 1){\n\tleft_c[i] = right_c[i] = -1;\n\treturn i;\n  }\n\n  left_c[i] = recon(x, l, mid);\n  right_c[i] = recon(x, mid+1, r);\n  return i;\n}\n\nbool first = true;\nvoid print_post(int i){\n  if(i <= 0) return;\n  print_post(left_c[i]);\n  print_post(right_c[i]);\n  if(!first)\n\tcout << \" \";\n  cout << i;\n  first = false;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> N;\n  REP(i,N) cin >> pre[i];\n  REP(i,N){\n\tcin >> in[i];\n\tidx[in[i]] = i;\n  }\n\n  int i = 0;\n  recon(i, 0, N);\n  //FOR(i,1,N+1) cout << i << \": \" << left_c[i] << \", \" << right_c[i] << endl;\n  \n  print_post(pre[0]);\n  cout << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nint ret[30];\nint map[30];\nint count2 = 0;\n\nstruct treenode{\n\tint data;\n\ttreenode* leftchild;\n\ttreenode* rightchild;\n\ttreenode(int v) {\n\t\tdata = v;\n\t\tleftchild = NULL;\n\t\trightchild = NULL;\n\t}\n};\n\nvoid remap(int inorder[],int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tmap[inorder[i]] = i;\n\t}\n}\n\ntreenode* bip(int pre[], int n, int offset) {\n\tif (n == 0) return NULL;\n\tint rootval = pre[0];\n\tint i = map[rootval] - offset;\n\ttreenode* root = new treenode(rootval);\n\troot->leftchild = bip(pre + 1, i, offset);\n\troot->rightchild = bip(pre + i + 1, n - i - 1, offset + i + 1);\n\treturn root;\n}\n\nvoid lastorder(treenode* ptr) {\n\tif (ptr) {\n\t\tlastorder(ptr->leftchild);\n\t\tlastorder(ptr->rightchild);\n\t\tret[count2++] = ptr->data  ;\n\t}\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tint pre[30];\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> pre[i];\n\t}\n\tint inorder[30];\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> inorder[i];\n\t}\n\tremap(inorder, n);\n\ttreenode* root;\n\troot = bip(pre, n, 0);\n\tlastorder(root);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i) cout << \" \";\n\t\tcout << ret[i];\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\n//木を再構築して、postorderの列を作る\nvoid rec(int l,int r){\n\tif(l>=r) return;\n\tint root=pre[pos++];\n\tint m=distance(in.begin(),find(in.begin(),in.end(),root));\n\trec(l,m); //左部分木\n\trec(m+1,r); //右部分木\n\tpost.push_back(root); //根を追加\n}\n\nvoid solve(){\n\tpos=0;\n\trec(0,pre.size());\n\tfor(int i=0;i<n;i++){\n\t\tif(i!=0) cout<<\" \";\n\t\tcout<<post[i];\n\t}\n\tcout<<endl;\n}\n\nint main(){\n\tint k;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>k;\n\t\tpre.push_back(k);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tcin>>k;\n\t\tin.push_back(k);\n\t}\n\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nnamespace ns {\n\tint N;\n\tvector<int> left;\n\tvector<int> mid;\n\n\tvector<int> right(int lp, int mp, int w) {\n\t\tif (w <= 0) return vector<int>(0);\n\t\tint root = left[lp];\n\t\tFOR(i, 0, w) {\n\t\t\tif (mid[mp+i] == root) {\n\t\t\t\tint wl = i, wr = w-wl-1;\n\t\t\t\tvector<int> la = right(lp+1, mp, wl);\n\t\t\t\tvector<int> ra = right(lp+1+wl, mp+i+1, wr);\n\t\t\t\tvector<int> res;\n\t\t\t\tREP(j, la.size()) res.pb(la[j]);\n\t\t\t\tREP(j, ra.size()) res.pb(ra[j]);\n\t\t\t\tres.pb(root);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\tassert(false);\n\t\treturn vector<int>();\n\t}\n\n\tvoid main() {\n\t\tstd::ios::sync_with_stdio(false);\n\t\tstd::cin.tie(0);\n\t\tcin >> N;\n\t\tleft.resize(N); cin >> left;\n\t\tmid.resize(N); cin >> mid;\n\t\tvector<int> ans = right(0, 0, N);\n\t\tREP(i, N) {\n\t\t\tif (i) cout << \" \";\n\t\t\tcout << ans[i];\n\t\t}\n\t\tcout << endl;\n\t}\n}\nint main() {\n\tns::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> pre, in;\nint n;\n\nvoid solve(int l, int r) {\n\tif (r - l == 1) {\n\t\tcout << in[l];\n\t\tif (in[l] != pre[0]) {\n\t\t\tcout << \" \";\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = l; j < r; j++) {\n\t\t\t\tif (pre[i] == in[j]) {\n\t\t\t\t\tsolve(l, j);\n\t\t\t\t\tsolve(j + 1, r);\n\t\t\t\t\tcout << in[j];\n\t\t\t\t\tif (in[j] != pre[0]) {\n\t\t\t\t\t\tcout << \" \";\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tpre.resize(n);\n\tin.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> pre[i];\t\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> in[i];\n\t}\n\n\tsolve(0, n);\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct Node{\n    int left;\n    int right;\n};\n\nclass Tree{\n    vector<Node> node;\npublic:\n    Tree(int n){\n        node.resize(n);\n    }\n    int make_tree(vector<int>& pre, vector<int>& in){\n        if (pre.empty()) return -1;\n        int obj = pre[0];\n        vector<int> in_left;\n        vector<int> in_right;\n        vector<int>::iterator it = in.begin();\n        while (*it != obj) {\n            in_left.push_back(*it);\n            it++;\n        }\n        it++;\n        while (it < in.end()) {\n            in_right.push_back(*it);\n            it++;\n        }\n        vector<int> pre_left;\n        vector<int> pre_right;\n        it = pre.begin() + 1;\n        for (int i = 0; i < in_left.size(); i++) {\n            pre_left.push_back(*it);\n            it++;\n        }\n        while (it < pre.end()) {\n            pre_right.push_back(*it);\n            it++;\n        }\n        node[obj].left  = make_tree(pre_left , in_left );\n        node[obj].right = make_tree(pre_right, in_right);\n        return obj;\n    }\n    void post_order(int p, vector<int>& post){\n        if (p == -1) return;\n        post_order(node[p].left , post);\n        post_order(node[p].right, post);\n        post.push_back(p);\n    }\n};\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int> pre(n);\n    vector<int> in(n);\n    for (int i = 0; i < n; i++) {\n        cin >> pre[i];\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> in[i];\n    }\n    Tree T(n + 1);\n    T.make_tree(pre, in);\n    vector<int> post;\n    T.post_order(pre[0], post);\n    for (int i = 0; i < post.size(); i++) {\n        cout << post[i] << (i == post.size() ? '\\n' : ' ');\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n\nusing namespace std;\n\nint        n, inputed_order[41] = {0};\nqueue<int> Queue;\n\nstruct Node {\n    Node() { left_child = right_child = -1; };\n    int left_child, right_child;\n};\n\nvoid postORDER(Node order[], int id) {\n    if (order[id].left_child != -1) postORDER(order, order[id].left_child);\n    if (order[id].right_child != -1) postORDER(order, order[id].right_child);\n    Queue.push(id + 1);\n}\n\nint findRoot(int inorder[], int left, int right) {\n    int root = inorder[left];\n    for (int i = left + 1; i <= right; i++) {\n        if (inputed_order[root] > inputed_order[inorder[i]]) {\n            root = inorder[i];\n        }\n    }\n    return root;\n}\n\nvoid reconstruct(int inorder[], Node order[], int root, int left, int right) {\n    int root_index;\n    for (root_index = left; inorder[root_index] != root; root_index++)\n        ;\n    if (left < root_index) {\n        int new_root               = findRoot(inorder, left, root_index - 1);\n        order[root - 1].left_child = new_root - 1;\n        if (left < root_index - 1)\n            reconstruct(inorder, order, new_root, left, root_index - 1);\n    }\n    if (root_index < right) {\n        int new_root                = findRoot(inorder, root_index + 1, right);\n        order[root - 1].right_child = new_root - 1;\n        if (root_index + 1 < right)\n            reconstruct(inorder, order, new_root, root_index + 1, right);\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    int  preorder[n], inorder[n];\n    Node order[n];\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &preorder[i]);\n        inputed_order[preorder[i]] = i;\n    }\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &inorder[i]);\n    }\n\n    if (n == 1) {\n        printf(\"%d\\n\", preorder[0]);\n    } else {\n        reconstruct(inorder, order, preorder[0], 0, n - 1);\n        postORDER(order, preorder[0] - 1);\n        while (!Queue.empty()) {\n            if (Queue.size() != 1) {\n                printf(\"%d \", Queue.front());\n                Queue.pop();\n            } else {\n                printf(\"%d\\n\", Queue.front());\n                Queue.pop();\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <tuple>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\n\nstruct node{\n    int id;\n    vector<int> left, right;\n};\n\nnode n[40];\nint v;\n\nvoid post_order(vector<int> root, vector<int> target, int start){\n    int i = 0;\n    while(target[i] != root[start]){\n        n[start].left.push_back(target[i]);\n        i++;\n    }\n    if(n[start].left.size() != 0)\n        post_order(root, n[start].left, start + 1);\n    i++;\n    while(i < target.size()){\n        n[start].right.push_back(target[i]);\n        i++;\n    }\n    if(n[start].right.size() != 0)\n        post_order(root, n[start].right, start + n[start].left.size() + 1);\n    cout << root[start] << \" \";\n}\n\nint main() {\n    cin >> v;\n    vector<int> pre(v);\n    vector<int> in(v);\n    int x;\n    REP(i, v){\n        cin >> x;\n        pre[i] = x;\n    }\n    REP(i, v){\n        cin >> x;\n        in[i] = x;\n    }\n    post_order(pre, in, 0);\n    cout << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace  std;\n\nconst int END = -1;\nstruct StNod\n{\n  int m_nParnt;\n  int m_nLeft;\n  int m_nRigt;\n\n  StNod() :\n     m_nParnt(END), m_nLeft(END), m_nRigt(END)\n  { }\n};\n\nenum EnDir\n{\n  D_Left,\n  D_Right,\n};\n\nvoid fnInput(vector<int> &rvnPodr, vector<int> &rvnIodrSeq)\n{\n  int nMaxSiz;\n\n  cin >> nMaxSiz;\n  rvnPodr.resize(nMaxSiz);\n  rvnIodrSeq.resize(nMaxSiz + 1);\n\n  for (int i = 0; i < nMaxSiz; i++)\n    cin >> rvnPodr[i];\n\n  int nNode;\n  for (int i = 1; i < nMaxSiz + 1; i++)\n  {\n    cin >> nNode;\n    rvnIodrSeq[nNode] = i;\n  }\n}\n\nvoid fnStructTree(const vector<int> &cnrvnPodr, const vector<int> &cnrvnIodrSeq, vector<StNod> &rvoNod)\n{\n  int nParnt, nx;\n  EnDir enDir;\n  for (int i = 1; i < cnrvnPodr.size(); i++)\n  {\n    nParnt = END;\n    nx = cnrvnPodr[0];\n    while (nx != END)\n    {\n      nParnt = nx;\n      if (cnrvnIodrSeq[ cnrvnPodr[i] ] < cnrvnIodrSeq[nx])\n      {\n        nx = rvoNod[nx].m_nLeft;\n        enDir = D_Left;\n      }\n      else\n      {\n        nx = rvoNod[nx].m_nRigt;\n        enDir = D_Right;\n      }\n    }\n\n    rvoNod[ cnrvnPodr[i] ].m_nParnt = nParnt;\n    if (enDir == D_Left)\n      rvoNod[nParnt].m_nLeft = cnrvnPodr[i];\n    else\n      rvoNod[nParnt].m_nRigt = cnrvnPodr[i];\n  }\n}\n\nvoid fnPostOrder(const vector<StNod> &cnrvoNod, int nx)\n{\n  static int stnPrt = 0;\n  if (nx == END)  return;\n\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nLeft);\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nRigt);\n\n  if (stnPrt++) cout << \" \";\n  cout << nx;\n}\n\nvoid fnResult(const vector<StNod> &cnrvoNod)\n{\n  int nx = 1;\n  while (cnrvoNod[nx].m_nParnt != END)\n    nx = cnrvoNod[nx].m_nParnt;\n\n  fnPostOrder(cnrvoNod, nx);\n  cout << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vector<int> vnPodr, vnIodrSeq;\n  fnInput(vnPodr, vnIodrSeq);\n\n  StNod oNod;\n  vector<StNod> voNod(vnIodrSeq.size(), oNod);\n  fnStructTree(vnPodr, vnIodrSeq, voNod);\n  \n  fnResult(voNod);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nint ret[50];\nint map[50];\nint count2 = 0;\n\nstruct treenode{\n\tint data;\n\ttreenode* leftchild;\n\ttreenode* rightchild;\n\ttreenode(int v) {\n\t\tdata = v;\n\t\tleftchild = NULL;\n\t\trightchild = NULL;\n\t}\n};\n\nvoid remap(int inorder[],int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tmap[inorder[i]] = i;\n\t}\n}\n\ntreenode* bip(int pre[], int n, int offset) {\n\tif (n == 0) return NULL;\n\tint rootval = pre[0];\n\tint i = map[rootval] - offset;\n\ttreenode* root = new treenode(rootval);\n\troot->leftchild = bip(pre + 1, i, offset);\n\troot->rightchild = bip(pre + i + 1, n - i - 1, offset + i + 1);\n\treturn root;\n}\n\nvoid lastorder(treenode* ptr) {\n\tif (ptr) {\n\t\tlastorder(ptr->leftchild);\n\t\tlastorder(ptr->rightchild);\n\t\tret[count2++] = ptr->data  ;\n\t}\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tint pre[50];\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> pre[i];\n\t}\n\tint inorder[50];\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> inorder[i];\n\t}\n\tremap(inorder, n);\n\ttreenode* root;\n\troot = bip(pre, n, 0);\n\tlastorder(root);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i) cout << \" \";\n\t\tcout << ret[i];\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define N 40\n\nvector<int> a, b, c;\n\nvoid postOrder(vector<int>::iterator a1, vector<int>::iterator a2, vector<int>::iterator b1, vector<int>::iterator b2)\n{\n    //printf(\"%d %d %d %d\\n\", *a1, *(a2 - 1), *b1, *(b2 - 1));\n    vector<int>::iterator itr;\n    c.push_back(*a1);\n    printf(\"%d\\n\", *a1);\n    itr = find(b1, b2, *a1); //itrator of root on inorder tree walk\n    int d = itr - b1;\n    if (a1 + d + 1 < a2 && itr + 1 < b2)\n        postOrder(a1 + d + 1, a2, itr + 1, b2);\n    if (a1 + 1 < a1 + d + 1 && b1 < itr)\n        postOrder(a1 + 1, a1 + d + 1, b1, itr);\n}\n\nint main()\n{\n    int n, x;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> x;\n        a.push_back(x);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        cin >> x;\n        b.push_back(x);\n    }\n\n    postOrder(a.begin(), a.end(), b.begin(), b.end());\n\n    for (int i = 0; i < c.size(); i++)\n    {\n        if (i != 0)\n            cout << \" \";\n        cout << c[c.size() - 1 - i];\n    }\n    cout << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 45\nusing namespace std;\nint pre[N], p = 0;\nint in[N];\nint n;\nvector<int> post;\nvoid rec(int l, int r){\n    if (l >= r) return ;\n    int c = pre[p++];\n    int m;\n    for(m = 0; m < n; m++){\n        if(in[m] == c) break;\n    }\n    rec(l, m);\n    rec(m+1, r);\n    post.push_back(c);\n}\nint main() {\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++) scanf(\"%d\", &pre[i]);\n    for(int i = 0; i < n; i++) scanf(\"%d\", &in[i]);\n    rec(0, n);\n    for(int i = 0; i < post.size(); i++){\n        printf(\"%d\", post[i]);\n        i == post.size()-1 ? printf(\"\\n\") : printf(\" \");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconst int NIL = -1; \n\ntypedef struct {\n\tint degree; //度 \n\tint parent; \n\tint left;\n\tint right;\n} Node;\n\nint *preSeq; //前序序列 \nint *inSeq;//中序序列 \n\nNode *Tree; //树 \n\nint root;\n\nint searchIn(int node,int n) {\n\tfor(int i=0;i<n;i++) {\n\t\tif (inSeq[i] == node) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nint nextParent() {\n\tstatic int pIndex = 0;\n\treturn preSeq[pIndex++];\n}\n\nvoid buildTree(int n,int p,int l,int r) {\n\tif (l >= r) {\n\t\treturn;\n\t}\n\tint c = nextParent();\n\tint m = searchIn(c,n);\n\tbuildTree(n,m,l,m);\n\tbuildTree(n,m,m+1,r);\n\tTree[c].parent = (p == NIL ? p : inSeq[p]);\n\t\n\tif (p != NIL) {\n\t  int parent = Tree[c].parent;\n\t  if (p>l) {\n\t\t Tree[parent].left = c;\n\t\t //cout << parent << \".l\" << c << endl;\n \t  }\n\t  if (r > p) {\n\t  \tTree[parent].right = c;\n\t  \t//cout << parent << \".r\" << c << endl;\n\t  }\n    }\n}\n\n\nvoid Postorder(int node) {\n\tif (Tree[node].left != NIL) {\n\t  Postorder(Tree[node].left);\n    }\n    if (Tree[node].right != NIL) {\n\t  Postorder(Tree[node].right);\n    }\n    cout << node;\n    if (node != root) {\n    \tcout << \" \";\n\t} else {\n\t\tcout << endl;\n\t}\n}\n\n\nint main() {\n\tint n;\n\tcin >> n;\n\tTree = new Node[n+1];\n\tpreSeq = new int[n+1];\n\tinSeq = new int[n+1];\n\t\n\tfor (int i=0;i<=n;i++) {\n\t\tTree[i].parent = Tree[i].left = Tree[i].right = NIL;\n\t}\n\t\n\tfor (int i=0;i<n;i++) {\n\t\tcin >> preSeq[i];\n\t}\n\t\n\tfor (int i=0;i<n;i++) {\n\t\tcin >> inSeq[i];\n\t}\n\t\n\t\n\tbuildTree(n,NIL,0,n);\n\t\n\tfor (int i=1;i<=n;i++) {\n\t\tif (Tree[i].parent == NIL) {\n\t\t\troot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tPostorder(root);\n\t\n\tdelete[] Tree;\n\tdelete[] preSeq;\n\tdelete[] inSeq;\n\t/*delete[] Depth;\n\tdelete[] Heigh;*/\n\t\n\treturn 0;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n, pos = 0;\nvector<int> pre, in, post;\nvoid rec(int l, int r);\nint main()\n{\n\tcin >> n;\n\tpre.resize(n);\n\tin.resize(n);\n\tfor(int i = 0; i < n; i++)\n\t\tcin >> pre[i];\n\tfor(int i = 0; i < n; i++)\n\t\tcin >> in[i];\n\trec(0, pre.size());\n\tfor(int i = 0; i< n; i++)\n\t{\n\t\tif(i)\n\t\t\tcout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\nvoid rec(int l, int r)\n{\n\tif(l >= r)\n\t\treturn;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n  if ( l >= r ) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(l, m);\n  rec(m + 1, r);\n  post.push_back(root);\n}\n\nvoid solve() {\n  pos = 0;\n  rec(0, pre.size());\n  for ( int i = 0; i < n; i++ ) {\n    if ( i ) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main() {\n  int k;\n  cin >> n;\n\n  for ( int i = 0; i < n; i++ ) {\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for ( int i = 0; i < n; i++ ) {\n    cin >> k;\n    in.push_back(k);\n  }\n\n  solve();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <list>\n\nlong long int INF = 1e18;\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\n\nvector<int> E[1100];\n\nvector<int> v3;\nint A[100], B[100];\n\nint f(int l1, int r1, int l2, int r2){\n\t//cout << l1 <<\" \"<< r1 <<\" \"<< l2 <<\" \"<< r2 << endl;\n\tif(l1 > r1 || l2 > r2){\n\t\treturn -1;\n\t}\n\tint id = A[l1];\n\tint piv = l2;\n\tfor(int i = l2; i <= r2; i++){\n\t\tif(B[i] == id){\n\t\t\tpiv = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint len = piv - l2;\n\tE[id].push_back(f(l1 + 1, l1 + len, l2, piv - 1));\n\tE[id].push_back(f(l1 + len + 1, r1, piv + 1, r2));\n\treturn id;\n}\n\nvoid f3(int u){\n\tif(E[u][0] != -1){\n\t\tf3(E[u][0]);\n\t}\n\tif(E[u][1] != -1){\n\t\tf3(E[u][1]);\n\t}\n\tv3.push_back(u);\n}\n\n\nint main(){\n\t\n\tint n;\n\tcin >> n;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> A[i];\n\t\tA[i]--;\n\t}\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> B[i];\n\t\tB[i]--;\n\t}\n\t\n\tf(0, n - 1, 0, n - 1);\n\t\n\tfor(int i = 0; i < n; i++){\n\t\t//cout << E[i][0] << \" \" << E[i][1] << endl;\n\t}\n\t\n\tf3(A[0]);\n\t\n\tcout << v3[0] + 1;\n\tfor(int i = 1; i < v3.size(); i++){\n\t\tcout << \" \" << v3[i] + 1;\n\t}\n\tcout << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\nvector <int> pre, in;\n\nvoid rec(int lp, int rp, int li, int ri) {\n    int root = pre[lp];\n    int i = 0;\n    while(in[li+i] != root) i++;\n    if (i != 0) rec(lp+1, lp+i, li, li+i-1);\n    if (li + i != ri) rec(lp+i+1, rp, li+i+1, ri);\n\n    printf(\"%d \", root);\n}\n\nvoid solve(void){\n    int N;\n    cin >> N;\n    pre.resize(N), in.resize(N);\n    rep(N, i) cin >> pre[i];\n    rep(N, i) cin >> in[i];\n    rec(0, N-1, 0, N-1);\n    printf(\"\\n\");\n}\n\nint main(void){\n  solve();\n  //cout << \"yui(*-v・)yui\" << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 100\n\nint n, pre, pos;\nint Preorder[MAX], Inorder[MAX], Postorder[MAX];\n\nint find_parent(int key){\n  for(int i=0; i<n; i++){\n    if(key == Inorder[i]) return i;\n  }\n}\n\nvoid reconstruction(int left, int right){\n  if(left >= right) return;\n  \n  int key=Preorder[pre++];\n  int position=find_parent(key);\n  \n  reconstruction(left, position);\n  reconstruction(position+1, right);\n  \n  Postorder[pos++]=key;\n}\n\nint main(void){\n  scanf(\"%d\", &n);\n\n  for(int i=0; i<n; i++) scanf(\"%d\", &Preorder[i]);\n  for(int i=0; i<n; i++) scanf(\"%d\", &Inorder[i]);\n\n  reconstruction(0, n);\n\n  for(int i=0; i<n; i++){\n    if(i) printf(\" \");\n    printf(\"%d\", Postorder[i]);\n  }\n\n  printf(\"\\n\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint pre[40],in[40],n;\n\nvoid solve(int main,int left,int right){\n\tif(left+1>=right){\n\t\tcout<<in[left]<<\" \";\n\t\treturn;\n\t}\n\tfor(int i=left;i<right;i++){\n\t\tif(pre[main]==in[i]){\n\t\t\tif(left!=i)\tsolve(main+1,left,i);\n\t\t\tif(right-1!=i)\tsolve(i+1,i+1,right);\n\t\t\tcout<<in[i]<<\" \";\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\tcin>>pre[i];\n\tfor(int i=0;i<n;i++)\tcin>>in[i];\n\t\n\tfor(int i=0;i<n;i++){\n\t\tif(pre[0]==in[i]){\n\t\t\tif(i!=0)\tsolve(1,0,i);\n\t\t\tif(i!=n-1)\tsolve(i+1,i+1,n);\n\t\t\tcout<<pre[0]<<endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <random>\n#include <cstdlib>\n#define INT_MAX 2147483647\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i < (int)n; i++)\n#define Loopr(i, n) for(int i= (int)n - 1; i >= 0; i--)\nusing namespace std;\ntypedef long long int ll;\n\nstruct node {\n\tint parent, left, right;\n};\n\nint n, root, buf;\nvector<node> nodes(40, { -1,-1,-1 });\nvector<int> pre(40, -1), in(40, -1);\n\nvoid finding(int p, int l, int r) {\n\tint a = pre[buf];\n\tnodes[a].parent = p;\n\tbuf++;\n\tif (r - l != 1) {\n\t\tfor (int i = l;i < r;i++) {\n\t\t\tif (in[i] == a) {\n\t\t\t\tif (l != i) {\n\t\t\t\t\tnodes[a].left = pre[buf];\n\t\t\t\t\tfinding(a, l, i);\n\t\t\t\t}\n\t\t\t\tif (i + 1 != r) {\n\t\t\t\t\tnodes[a].right = pre[buf];\n\t\t\t\t\tfinding(a, i + 1, r);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid print_post(int a) {\n\tif (a != -1) {\n\t\tprint_post(nodes[a].left);\n\t\tprint_post(nodes[a].right);\n\t\tif (a == root) \tcout << a << endl;\n\t\telse cout << a << \" \";\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tLoop(i, n) cin >> pre[i];\n\tLoop(i, n) cin >> in[i];\n\troot = pre[0];\n\tbuf = 0;\n\tfinding(-1, 0, n);\n\tprint_post(root);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> pre,in,post;\nint root,pos=0;\n\nvoid rec(int left,int right){\n\tif(left>=right) return ;\n\tint root=pre[pos++];\n\tint m=distance(in.begin(), find(in.begin(), in.end(),root));\n\trec(left,m);\n\trec(m+1,right);\n\tpost.push_back(root);\n\treturn ;\n}\n\nvoid solve(int n){\n\trec(0,n);\n\tfor(int i=0;i<n;i++) {\n\t\tif(i) cout<<\" \"<<post[i];\n\t\telse cout<<post[i];\n\t}\n\treturn ;\n}\n\nint main (){\n\tint n;\n\tcin>>n;\n\tint a;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a;\n\t\tpre.push_back(a);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a;\n\t\tin.push_back(a);\n\t}\n\tsolve(n);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace  std;\n\nconst int END = -1;\nstruct StNod\n{\n  bool m_bBe;\n  int  m_nParnt;\n  int  m_nLeft;\n  int  m_nRigt;\n\n  StNod() :\n    m_bBe(false), m_nParnt(END), m_nLeft(END), m_nRigt(END)\n  { }\n};\n\nenum EnDir\n{\n  D_Left,\n  D_Right,\n};\n\nvoid fnInput(vector<int> &rvnPodr, vector<int> &rvnIodrSeq)\n{\n  StNod oNod;\n  int nMaxSiz;\n\n  cin >> nMaxSiz;\n  rvnPodr.resize(nMaxSiz + 1);\n  rvnIodrSeq.resize(nMaxSiz + 1);\n\n  for (int i = 1; i < nMaxSiz + 1; i++)\n  {\n    int nNode;\n    cin >> nNode;\n    rvnPodr[i] = nNode;\n  }\n\n  for (int i = 1; i < nMaxSiz + 1; i++)\n  {\n    int nNode;\n    cin >> nNode;\n    rvnIodrSeq[nNode] = i;\n  }\n}\n\nvoid fnStructTree(const vector<int> &cnrvnPodr, const vector<int> &cnrvnIodrSeq, vector<StNod> &rvoNod)\n{\n  int nRoot = cnrvnPodr[1];\n  rvoNod[nRoot].m_bBe = true;\n\n  for (int i = 2; i < cnrvnPodr.size(); i++)\n  {\n    int nParnt = END;\n    int nx = nRoot;\n    EnDir enDir;\n    while (nx != END)\n    {\n      nParnt = nx;\n      if (cnrvnIodrSeq[i] < cnrvnIodrSeq[nx])\n      {\n        nx = rvoNod[nx].m_nLeft;\n        enDir = D_Left;\n      }\n      else\n      {\n        nx = rvoNod[nx].m_nRigt;\n        enDir = D_Right;\n      }\n    }\n\n    int  nNode = cnrvnPodr[i];\n    rvoNod[nNode].m_bBe = true;\n    rvoNod[nNode].m_nParnt = nParnt;\n    if (enDir == D_Left)\n      rvoNod[nParnt].m_nLeft = nNode;\n    else\n      rvoNod[nParnt].m_nRigt = nNode;\n  }\n}\n\nvoid fnPostOrder(const vector<StNod> &cnrvoNod, int nx)\n{\n  if (nx == END)  return;\n\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nLeft);\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nRigt);\n  cout << \" \" << nx;\n}\n\nvoid fnResult(const vector<StNod> &cnrvoNod)\n{\n  int nx = 1;\n  while (cnrvoNod[nx].m_nParnt != END)\n    nx = cnrvoNod[nx].m_nParnt;\n\n  fnPostOrder(cnrvoNod, nx);\n  cout << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vector<int> vnPodr, vnIodrSeq;\n  vector<StNod> voNod;\n\n  fnInput(vnPodr, vnIodrSeq);\n\n  StNod oNod;\n  voNod.resize(vnPodr.size(), oNod);\n  fnStructTree(vnPodr, vnIodrSeq, voNod);\n\n  fnResult(voNod);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <unordered_set>\n\n#define REP(i, n) for(decltype(n) i = 0; i < (n); i++)\n#define REP2(i, x, n) for(decltype(x) i = (x); i < (n); i++)\n#define REP3(i, x, n) for(decltype(x) i = (x); i <= (n); i++)\n#define RREP(i, n) for (decltype(n) i = (n) - 1;i >= 0; i--)\n\n#define ALL(a) (a).begin(),(a).end()\n#define SORT(c) sort((c).begin(),(c).end())\n#define DESCSORT(c) sort(c.begin(), c.end(), greater<int>())\n\n#define LL long long int\n#define LD long double\n\n#define INF 1000000000\n#define PI 3.14159265358979323846\n\n#define _CRT_SECURE_NO_WARNINGS\n\nusing namespace std;\n\n// N, E, S, W\nconst int dx[4] = { -1, 0,  1,  0 };\nconst int dy[4] = { 0, 1,  0, -1 };\n\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<LL> vll;\n\n//==============================================\n\nvi pre, in, post;\nint pos = 0;\n\nint rec(int l, int r) {\n\tif (l >= r) return 0;\n\n\tint root = pre[pos++];\n\tint mid = distance(in.begin(), find(ALL(in), root));\n\n\trec(l, mid);\n\trec(mid + 1, r);\n\n\tpost.push_back(root);\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tpre.resize(n);\n\tin.resize(n);\n\n\tint tmpN;\n\tREP(i, n) cin >> tmpN, pre[i] = tmpN;\n\tREP(i, n) cin >> tmpN, in[i] = tmpN;\n\n\trec(0, pre.size());\n\n\tREP(i, n) {\n\t\tif (i) cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> pre, in;\nint n;\n\nvoid solve(int l, int r) {\n\tif (r - l == 1) {\n\t\tcout << in[l] << \" \";\n\t}\n\telse {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = l; j < r; j++) {\n\t\t\t\tif (pre[i] == in[j]) {\n\t\t\t\t\tsolve(l, j);\n\t\t\t\t\tsolve(j + 1, r);\n\t\t\t\t\tcout << in[j] << \" \";\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tpre.resize(n);\n\tin.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> pre[i];\t\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> in[i];\n\t}\n\n\tsolve(0, n);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++>\nusing namespace std;\nint n,pos;\nvector<int>pre,in,post;\nvoid rec(int l,int r){\nif(l>=r)return 0;\nint root=pre[pos++];\nint m=distance(in.begin(),find(in.begin(),in.end(),root));\nrec(l,m);\nrec(m+1,r);\npost.push_back(root);\n}\nvoid solve(){\npos=0;\nrec(0,pre.size());\nfor(int i=0;i<n;i++){\nif(i)cout<<\" \";\ncout<<post[i];\n}\ncout<<endl;\n}\nint main(){\nint k;\ncin>>n;\nfor(int i=0;i<n;i++){\ncin>>k;\npre.push_back(k);\n}\nfor(int i=0;i<n;i++){\ncin>>k;\nin.push_back(k);\n}\nsolve();\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nint n,pos;\nvector<int> pre,in,post;\nvoid solve(int l,int r){\n  if(l>=r)return ;\n  int root=pre[pos++];\n  int m=distance(in.begin(),find(in.begin(),in.end(),root));\n \n  solve(l,m);\n  solve(m+1,r);\n  post.push_back(root);\n}\n\nint main(){\n  cin >> n;\n  for(int i=0;i<n;i++){int u;cin >> u;pre.push_back(u);};\n  for(int i=0;i<n;i++){int u;cin >> u;in.push_back(u);}\n  \n  solve(0,pre.size());\n  for(int i=0;i<n;i++){\n    if(i)cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Reconstruction of tree by pre-order and in-order\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\nvoid reconstruction(int, int);\nint n;\nstd::vector<int> in;\nstd::queue<int> pre,post;\nint main(){\n  std::cin>>n;\n  for(int i=0, tmp;i<n;i++) std::cin>>tmp, pre.push(tmp);\n  for(int i=0, tmp;i<n;i++) std::cin>>tmp, in.push_back(tmp);\n  reconstruction(0, n);\n  for(int i=0;i<n;i++){\n    std::cout<<post.front();\n    post.pop();\n    std::cout<<(i!=n-1?\" \":\"\\n\");\n  }\n  return 0;\n}\nvoid reconstruction(int l, int r){\n  if(l >= r) return;\n  int c=pre.front();\n  pre.pop();\n  int m=distance(in.begin(), find(in.begin(), in.end(),c));\n  reconstruction(l, m);\n  reconstruction(m+1, r);\n  post.push(c);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <iterator>\n#include<algorithm>\nstatic const int NIL = -1;\nstatic const int NumberChild = 2;\nclass Tree {\nprivate:\n\tint id;\n\tint parent;\n\tint child[NumberChild];\n\npublic:\n\tTree() {\n\t\tid = child[0] = child[1] = parent = NIL;\n\t}\n\tvoid AddParent(int ID) {\n\t\tparent = ID;\n\t\treturn;\n\t}\n\tvoid AddID(int ID) {\n\t\tid = ID;\n\t\treturn;\n\t}\n\tvoid AddChild(std::vector<int>&Child) {\n\t\tfor (unsigned int i = 0; i < Child.size(); ++i) {\n\t\t\tchild[i] = Child[i];\n\n\t\t}\n\n\t\treturn;\n\t}\n\tint GetRoot(std::vector<Tree> nodes, int ID) {\n\t\tint RootID = ID;\n\t\tif (RootID != NIL&&nodes[RootID].parent != NIL) {\n\t\t\tRootID = GetRoot(nodes, nodes[RootID].parent);\n\t\t}\n\t\treturn RootID;\n\t}\n\tvoid PreorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid InorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid PostorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t\tif(nodes[ID].id!=NIL)std::cout << \" \" << nodes[ID].id;\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid Reconstruct(const std::vector<int>Pre, const std::vector<int>In, std::vector<Tree> &nodes, const int Root,int &cnt) {\n\t\t\n\t\tint m = std::distance(In.begin(), std::find(In.begin(), In.end(), Root));\n\t\n\t\t//nodes[cnt].AddID(Root);\n\t\tnodes[Root].AddID(Root);\n\t\tif (m == 0||Root==NIL) { return; }\n\t\tstd::vector<int>PreLeft;\n\t\n\t\tstd::copy(&Pre[1], &Pre[m]+1, std::back_inserter(PreLeft));\n\t\t\n\t\tstd::vector<int>PreRight;\n\t\t\n\t\tstd::copy(&Pre[m+1 ], &Pre[Pre.size()-1]+1, std::back_inserter(PreRight));\n\t\t\n\t\tstd::vector<int>InLeft;\n\t\tstd::copy(&In[0], &In[m-1]+1, std::back_inserter(InLeft));\n\t\t\n\n\t\tstd::vector<int> InRight;\n\t\tstd::copy(&In[m]+1, &In[In.size() - 1]+1, std::back_inserter(InRight));\n\t\t\n\n\t\tstd::vector<int> child(2);\n\t\tchild = { PreLeft.empty() ? NIL : PreLeft[0], PreRight.empty() ? NIL : PreRight[0] };\n\t\t//nodes[cnt].AddChild(child);\n\t\tnodes[Root].AddChild(child);\n\t\tfor (unsigned int i = 0; i < child.size(); ++i) {\n\n\t\t\tnodes[child[i]].AddParent(Root);\n\t\t}\n\t\tReconstruct(PreLeft, InLeft, nodes, PreLeft[0], ++cnt);\n\t\tReconstruct(PreRight, InRight, nodes, PreRight[0], ++cnt);\n\t}\n};\n\nvoid SetVector(std::vector<int>&InputVector) {\n\tfor (unsigned int i = 0; i < InputVector.size(); ++i) {\n\t\tstd::cin >> InputVector[i];\n\t}\n\treturn;\n}\nint main(void) {\n\n\tint n;\n\tstd::cin >> n;\n\tstd::vector<int>Pre(n);\n\tstd::vector<int>In(n);\n\tSetVector(Pre);\n\tSetVector(In);\n\tstd::vector<Tree> nodes(n+1);\n\t//ReconstructWithNoParent\n\tint cnt = 0;\n\tnodes[1].Reconstruct(Pre, In, nodes, Pre[0],cnt);\n\n\tnodes[1].PostorderTreeWalk(nodes, 1);\n\tstd::cout << std::endl;\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector> \n#include <algorithm>\nusing namespace std;\n#define NIL -1\nconst int maxn = 110;\nint n,pos;\nvector<int> pre,in,post;\nvoid rec(int l,int r){\n\tif(l>=r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(),find(in.begin(),in.end(),root));\n\trec(l,m);\n\trec(m+1,r);\n\tpost.push_back(root);\n}\nvoid solve(){\n\tpos = 0;\n\trec(0,pre.size());\n\tfor(int i=0;i<n;i++){\n\t    if(i) cout<<\" \";\n\t    cout<<post[i];\n\t}\n\t\t\n\tcout<<endl;\n}\nint main() {\n\tint i,m;\n\tcin>>n;\n\tfor(i=0;i<n;i++){\n\t\tcin>>m;\n\t\tpre.push_back(m);\n\t}\n\tfor(i=0;i<n;i++){\n\t\tcin>>m;\n\t\tin.push_back(m);\n\t}\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector< int > preorder;\nvector< int > inorder;\n\nvoid printPost(int n,\n\t       int inBegin,\n\t       int inEnd) {\n  if (inBegin == inEnd)\n    return;\n  if (inBegin == (inEnd-1)) {\n    cout << inorder[inBegin];\n    cout << ' ';\n    return;\n  }\n  for (int j = 0; j < n; j++) {\n    for (int i = inBegin; i < inEnd; i++)\n      if (inorder[i] == preorder[j]) {\n\tprintPost(n, inBegin, i);\n\tprintPost(n, i+1, inEnd);\n\tcout << inorder[i];\n\tif (inorder[i] == preorder[0])\n\t  cout << endl;\n\telse\n\t  cout << ' ';\n\treturn;\n      }\n  }\n}\n  \n\nint main(int argc, char **argv) {\n  ios_base::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  preorder = vector< int > (n, 0);\n  for (int i = 0; i < n; i++)\n    cin >> preorder[i];\n  inorder = vector< int > (n, 0);\n  for (int i = 0; i < n; i++)\n    cin >> inorder[i];\n  printPost(n, 0, n);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n\tif(l >= r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m+1, r);\n\tpost.push_back(root);\n}\n\nvoid solve() {\n\tpos = 0;\n\trec(0, pre.size());\n\tfor(int i = 0; i < n; i++) {\n\t\tif(i) cout << \" \";\n\t\tcout << post[i]; \n\t}\n\tcout << endl;\n}\n\nint main() {\n\tint k;\n\tcin >> n;\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\t\n\tsolve();\n    \n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\nusing namespace std;\n\nclass Node {\nprivate:\n\tint id;\n\tNode *parent;\n\tNode *child_l;\n\tNode *child_r;\npublic:\n\tNode(int id){ this->id = id; parent = NULL; child_l = NULL; child_r = NULL;}\n\tvoid setChildl(Node *nl);\n\tvoid setChildr(Node *nr);\n\tvoid setParent(Node *np){ parent = np; }\n\tNode *searchNode(int id);\n\tNode *searchRight();\n\tint getId(){ return id; }\n\tNode *getParent(){ return parent; }\n\tNode *getChildl(){ return child_l; }\n\tNode *getChildr(){ return child_r; }\n};\n\nvoid Node::setChildl(Node *nl)\n{\n\tchild_l = nl;\n\tif (child_l != NULL) child_l->setParent(this);\n}\n\nvoid Node::setChildr(Node *nr)\n{\n\tchild_r = nr;\n\tif (child_r != NULL) child_r->setParent(this);\n}\n\nNode *Node::searchNode(int id)\n{\n\tif (this->id == id) return this;\n\tif (child_l != NULL) {\n\t\tNode *sl = child_l->searchNode(id);\n\t\tif (sl != NULL) return sl;\n\t}\n\tif (child_r != NULL) {\n\t\tNode *sr = child_r->searchNode(id);\n\t\tif (sr != NULL) return sr;\n\t}\n\treturn NULL;\n};\n\nNode *Node::searchRight()\n{\n\tif (child_r == NULL) return this;\n\treturn child_r->searchRight();\n}\n\nclass BinaryTree {\nprivate:\n\tNode *preroot;\n\tNode *root;\n\tchar flag;\npublic:\n\tBinaryTree(){ preroot = NULL; root = NULL; flag = 'l'; }\n\tvoid setNodePreorder(int id);\n\tvoid setNodeInorder(int id);\n\tvoid walkPostorder();\n\tvoid walkPostorder(Node *node);\n};\n\nvoid BinaryTree::setNodePreorder(int id)\n{\n\tif (preroot == NULL) {\n\t\tpreroot = new Node(id);\n\t\troot = new Node(id);\n\t\treturn;\n\t}\n\n\tNode *node = preroot;\n\tNode *nr;\n\twhile ((nr = node->getChildr()) != NULL) node = nr;\n\tnode->setChildr(new Node(id));\n\treturn;\n}\n\nvoid BinaryTree::setNodeInorder(int id)\n{\n\tif (root == NULL) {\n\t\tcout << \"!!!\" << endl;\n\t\treturn;\n\t}\n\n\tif (id == root->getId()) {\n\t\tflag = 'r';\n\t\treturn;\n\t}\n\n\tif (flag == 'l' && root->getChildl() == NULL) {\n\t\troot->setChildl(new Node(id));\n\t\treturn;\n\t}\n\n\tif (flag == 'r' && root->getChildr() == NULL) {\n\t\troot->setChildr(new Node(id));\n\t\treturn;\n\t}\n\n\tNode *new_subroot;\n\tif (flag == 'l') new_subroot = root->getChildl();\n\telse new_subroot = root->getChildr();\n\tNode *pre_child = preroot->searchNode(id);\n\tNode *new_child = NULL;\n\twhile (pre_child != NULL) {\n\t\tnew_child = new_subroot->searchNode(pre_child->getId());\n\t\tif (new_child != NULL) break;\n\t\tpre_child = pre_child->getChildr();\n\t}\n\tNode *node = new Node(id);\n\tif (new_child == NULL) {\n\t\t(new_subroot->searchRight())->setChildr(node);\n\t}\n\telse {\n\t\tNode *new_parent = new_child->getParent();\n\t\tif (new_parent->getChildl() == new_child) new_parent->setChildl(node);\n\t\telse new_parent->setChildr(node);\n\t\tnode->setChildl(new_child);\n\t}\n}\n\nvoid BinaryTree::walkPostorder()\n{\n\twalkPostorder(root);\n}\n\nvoid BinaryTree::walkPostorder(Node *node)\n{\n\tif (node == NULL) return;\n\twalkPostorder(node->getChildl());\n\twalkPostorder(node->getChildr());\n\tcout << node->getId();\n\tif (node != root) cout << \" \";\n\telse cout << endl;\n}\n\nint main(void)\n{\n\tBinaryTree bt;\n\n\tint n, id;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> id;\n\t\tbt.setNodePreorder(id);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> id;\n\t\tbt.setNodeInorder(id);\n\t}\n\t\t\n\tbt.walkPostorder();\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,m=0,a[40],b[40],c[41];\nvoid solve(int l,int r){\n  if(l>r)return;\n  int x=a[m++];\n  solve(l,c[x]-1);\n  solve(c[x]+1,r);\n  cout<<x<<(x==a[0]?\"\\n\":\" \");\n}\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>a[i];\n  for(int i=0;i<n;i++)cin>>b[i],c[b[i]]=i;\n  solve(0,n-1);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define MAX 40\n\nint n, pos;\nvector<int> pre, in, post;\nint order_in[MAX+1];\n\nvoid detectTree(int left, int right){\n    if(left >= right) return;\n    int root = pre[pos++];\n    int m = order_in[root];\n    detectTree(left, m);\n    detectTree(m+1, right);\n    post.push_back(root);\n}\n\n\nint main(void){\n    int id;\n    pos = 0;\n    \n    cin >> n;\n    \n    for(int i = 0; i < n; i++){\n        cin >> id;\n        pre.push_back(id);\n    }\n    for(int i = 0; i < n; i++){\n        cin >> id;\n        in.push_back(id);\n        order_in[id] = i;\n    }\n    \n    detectTree(0, n);\n    for(int i = 0; i < n; i++){\n        if(i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#define _USE_MATH_DEFINES\n#include <cmath>\n\n#define rep(i, n)     for (int (i) = 0; (i) < (n); (i)++)\n#define rep1(i, n)    for (int i = 1; i <= (int)(n); i++)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 50;\nconst int NIL  = -1;\n\nstruct Node {\n   int p, l, r;\n};\n\nNode T[MAXN];\nint  P[MAXN], I[MAXN], root;\nint  cnt = 0;\n\nvoid postorder(int u) {\n   if (T[u].l != NIL) postorder(T[u].l);\n   if (T[u].r != NIL) postorder(T[u].r);\n   if (cnt != 0) cout << \" \";\n   cout << u;\n   cnt++;\n}\n\nvoid makeT(int u, int n, int head, int tail) {\n   int p_place, i_place;\n\n   rep(i, n) {\n      if (P[i] == u)\n         p_place = i;\n      if (I[i] == u)\n         i_place = i;\n   }\n   if (head != i_place) {\n      T[u].l = P[p_place + 1];\n      T[P[p_place + 1]].p = u;\n      makeT(P[p_place + 1], n, head, i_place);\n   }\n   if (i_place + 1 != tail) {\n      T[u].r = P[p_place + 1 + i_place - head];\n      T[P[p_place + 1 + i_place - head]].p = u;\n      makeT(P[p_place + 1 + i_place - head], n, i_place + 1, tail);\n   }\n}\n\nint main() {\n   int n;\n\n   cin >> n;\n   rep1(i, n) T[i].p = T[i].r = T[i].l = NIL;\n   rep(i, n) cin >> P[i];\n   rep(i, n) cin >> I[i];\n   makeT(P[0], n, 0, n);\n\n   rep1(i, n) {\n      if (T[i].p == NIL) root = i;\n   }\n   postorder(root);\n   cout << endl;\n   return(0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<utility>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<map>\n#include<set>\n#include<cstring>\n#include<string>\n#include<stack>\n#include<malloc.h>\n#include<math.h>\nusing namespace std;\n//#define int long long\ntypedef pair<int, int> pii;\ntypedef pair<int, char> pic;\ntypedef priority_queue<pii, vector<pii>, greater<pii> > RPQ;\n#define mk make_pair\n#define INF (1 << 30)\n#define INFL (1ll << 60ll)\n#define mod 1000000007\n\nint N, a[100], b[100];\nstruct node{\n    int left = -1;\n    int right = -1;\n};\nnode chi[100];\n\nvoid dfs(int l, int r, int p, int q){\n    if(r - l <= 1 || q - p <= 1)return;\n    //printf(\"called [%d, %d)[%d, %d)\\n\", l, r, p, q);\n    //return;\n    int pos = -1;\n    int v = a[l];\n    for(int i = p; i < q; i++){\n        if(v == b[i])pos = i;\n    }\n    if(pos < 0)return;\n    if(pos == p){\n        chi[v].left = -1;\n        chi[v].right = a[l + 1];\n    }\n    else if(pos == q - 1){\n        chi[v].right = -1;\n        chi[v].left = a[l + 1];\n    }\n    else {\n        chi[v].left = a[l + 1];\n        chi[v].right = a[l + pos - p + 1];\n    }\n    //printf(\"call [%d, %d)[%d, %d)\\n\", l + 1, l + pos - p + 1, p, pos + 1);\n    //printf(\"call [%d, %d)[%d, %d)\\n\", l + pos - p + 1, r, pos + 1, q);\n    dfs(l + 1, l + pos - p + 1, p, pos);\n    dfs(l + pos - p + 1, r, pos + 1, q);\n}\n\nvector<int> post;\n\nvoid dfs2(int v){\n    if(v < 0)return;\n    dfs2(chi[v].left);\n    dfs2(chi[v].right);\n    post.push_back(v);\n}\n\nsigned main(){\n    cin >> N;\n    for(int i = 0; i < N; i++){\n        cin >> a[i];\n    }\n    for(int i = 0; i < N; i++){\n        cin >> b[i];\n    }\n    int root = a[0];\n    dfs(0, N, 0, N);\n    dfs2(root);\n    for(int i = 0; i < N; i++){\n        cout << post[i] << ((i == N - 1) ? \"\\n\" : \" \");\n    }\n\n    return 0;\n}\n\n/*\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nstruct node{\n\tint parent_id;\n\tint left_child_id;\n\tint right_child_id;\n};\n\nvoid create_node(int *preorder, int *inorder, node *b, int root_pos, int num);\nint get_left_child(int *inorder, int root_pos, int root_id, int num);\nvoid print_postorder(node* b, int root_id, bool* is_first);\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tnode* b = (node*)calloc((n+1), sizeof(node));\n\tint* preorder = (int*)malloc((n+1) * sizeof(int));\n\tint* inorder  = (int*)malloc((n+1) * sizeof(int));\n\tint* postorder  = (int*)malloc((n+1) * sizeof(int));\n\tfor(int i = 0; i < n+1; ++i){\n\t\tb[i].parent_id      = -1;\n\t\tb[i].left_child_id  = -1;\n\t\tb[i].right_child_id = -1;\n\t}\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%d\", &preorder[i]);\n\t}\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%d\", &inorder[i]);\n\t}\n\tcreate_node(preorder, inorder, b, 0, n);\n\tint root_id = preorder[0];\n\tbool *is_first = (bool*)calloc(1, sizeof(bool));\n\t*is_first = true;\n\tprint_postorder(b, root_id, is_first);\n\tputchar('\\n');\n\treturn 0;\n}\nvoid print_postorder(node* b, int root_id, bool* is_first){\n\tif(b[root_id].left_child_id  != -1) print_postorder(b, b[root_id].left_child_id, is_first);\n\tif(b[root_id].right_child_id != -1) print_postorder(b, b[root_id].right_child_id, is_first);\n\tif(*is_first){\n\t\tprintf(\"%d\", root_id);\n\t\t*is_first = false;\n\t}else{\n\t\tprintf(\" %d\", root_id);\n\t}\n}\nvoid create_node(int *preorder, int *inorder, node *b, int root_pos, int num){\n\tint root_id = preorder[root_pos];\n\tint left_pos = get_left_child(inorder, root_pos, root_id, num);\n\tif(left_pos == -1) return;\n\tif(root_pos < left_pos){\n\t\tint left_id = preorder[root_pos+1];\n\t\tb[root_id].left_child_id = left_id;\n\t\tb[left_id].parent_id = root_id;\n\t\tcreate_node(preorder, inorder, b, root_pos+1, left_pos);\n\t\tif(left_pos+1 < num){\n\t\t\tint right_id = preorder[left_pos+1];\n\t\t\tb[root_id].right_child_id = right_id;\n\t\t\tb[right_id].parent_id = root_id;\n\t\t\tcreate_node(preorder, inorder, b, left_pos+1, num);\n\t\t}\n\t}else{\n\t\tif(left_pos+1 >= num) return;\n\t\tint left_id  = inorder[root_pos-1];\n\t\tint right_id = inorder[root_pos+1];\n\t\tb[root_id].right_child_id = right_id;\n\t\tb[right_id].parent_id = root_id;\n\t\tif(left_id == 0 || b[left_id].right_child_id != -1){\n\t\t\tcreate_node(preorder, inorder, b, root_pos+1, num);\n\t\t\treturn;\n\t\t}\n\t\tb[root_id].left_child_id = left_id;\n\t\tb[left_id].parent_id = root_id;\n\t}\n}\n\nint get_left_child(int *inorder, int root_pos, int root_id, int num){\n\tint left_num = -1;\n\tfor(int i = 0; i < num; ++i){\n\t\tif(inorder[i] == root_id){\n\t\t\tleft_num = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn left_num;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 10000\n#define NIL -1\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r)\n{\n    if(l>=r)return;\n    int root=pre[pos++];\n    int m=distance(in.begin(),find(in.begin(),in.end(),root));\n    rec(l,m);\n    rec(m+1,r);\n    post.push_back(root);\n}\n\nvoid solve()\n{\n    pos=0;\n    rec(0,pre.size());\n    for(int i=0;i<n;i++)\n    {\n        if(i)cout<<\" \";\n        cout<<post[i];\n    }\n    cout<<endl;\n}\n\nint main()\n{\n    int k;\n    cin>>n;\n    for(int i=0;i<n;i++)\n    {\n        cin>>k;\n        pre.push_back(k);\n    }\n    for(int i=0;i<n;i++)\n    {\n        cin>>k;\n        in.push_back(k);\n    }\n\n    solve();\n\n \treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <functional>\n#define _USE_MATH_DEFINES\n#include <math.h>\n\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r)\n{\n\tif (l >= r)\n\t{\n\t\treturn;\n\t}\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\nvoid solve()\n{\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tint k;\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tint k;\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\tpos = 0;\n\trec(0, pre.size());\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tif (i)\n\t\t{\n\t\t\tcout << \" \";\n\t\t}\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint pre[100000], in[100000], post[100000], n, pos, cnt;\nint rec(int l, int r) { if (l >= r) { return; }int root = pre[pos++]; int m = 0; for (int i = 0; i < n; i++) { if (in[i] == root) { m = i; } }rec(l, m); rec(m + 1, r); post[cnt] = root; cnt++; }\nint main() { cin >> n; for (int i = 0; i < n; i++) { cin >> pre[i]; }for (int i = 0; i < n; i++) { cin >> in[i]; }rec(0, n); for (int i = 0; i < n; i++) { if (i) { cout << ' '; }cout << post[i]; }cout << endl; return 0; }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 40;\n\nint l[MAX], r[MAX];\n\nvoid dfs(int v, vector<int>& res) {\n\tif (l[v] != -1) dfs(l[v], res);\n\tif (r[v] != -1) dfs(r[v], res);\n\tres.push_back(v);\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<int> p(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> p[i]; p[i]--;\n\t}\n\tvector<int> c(n), rc(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> c[i]; c[i]--;\n\t\trc[c[i]] = i;\n\t}\n\tfill(l, l + n, -1);\n\tfill(r, r + n, -1);\n\tint id = 0;\n\tset<int> vs;\n\tfor (int i = 1; i < n; i++) {\n\t\tvs.insert(rc[p[id]]);\n\t\twhile (*vs.upper_bound(min(rc[p[i]], rc[p[id]])) < max(rc[p[i]], rc[p[id]])) id--;\n\t\tif (rc[p[id]] > rc[p[i]]) {\n\t\t\tl[p[id]] = p[i];\n\t\t}\n\t\telse {\n\t\t\tr[p[id]] = p[i];\n\t\t}\n\t\tid = i;\n\t}\n\tvector<int> res;\n\tdfs(p[0], res);\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << res[i] + 1 << \" \\n\"[i + 1 == n];\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <iterator>\n#include<algorithm>\nstatic const int NIL = -1;\nstatic const int NumberChild = 2;\nclass Tree {\nprivate:\n\tint id;\n\tint parent;\n\tint child[NumberChild];\n\npublic:\n\tTree() {\n\t\tid = child[0] = child[1] = parent = NIL;\n\t}\n\tvoid AddParent(int ID) {\n\t\tparent = ID;\n\t\treturn;\n\t}\n\tvoid AddID(int ID) {\n\t\tid = ID;\n\t\treturn;\n\t}\n\tvoid AddChild(std::vector<int>&Child) {\n\t\tfor (unsigned int i = 0; i < Child.size(); ++i) {\n\t\t\tchild[i] = Child[i];\n\n\t\t}\n\n\t\treturn;\n\t}\n\tint GetRoot(std::vector<Tree> nodes, int ID) {\n\t\tint RootID = ID;\n\t\tif (RootID != NIL&&nodes[RootID].parent != NIL) {\n\t\t\tRootID = GetRoot(nodes, nodes[RootID].parent);\n\t\t}\n\t\treturn RootID;\n\t}\n\tvoid PreorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid InorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid PostorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t\tif(nodes[ID].id!=NIL)std::cout << \" \" << nodes[ID].id;\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid GetVctorPostorderTreeWalk(std::vector<Tree> nodes, std::vector<int>& returnvector, int ID) {\n\t\t\n\t\tif (ID != NIL) {\n\n\t\t\tGetVctorPostorderTreeWalk(nodes,  returnvector, nodes[ID].child[0]);\n\t\t\tGetVctorPostorderTreeWalk(nodes, returnvector, nodes[ID].child[1]);\n\t\t\tif (nodes[ID].id != NIL)returnvector.push_back(nodes[ID].id) ;\n\t\t}\n\n\t\treturn ;\n\t}\n\tvoid Reconstruct( std::vector<int>Pre,  std::vector<int>In, std::vector<Tree> &nodes, const int Root, int &cnt) {\n\n\t\tunsigned int m = std::distance(In.begin(), std::find(In.begin(), In.end(), Root));\n\n\t\t//nodes[cnt].AddID(Root);\n\t\tif ( Root == NIL) { return; }\n\t\tnodes[Root].AddID(Root);\n\t\tif ( m ==0 ) { return; }\n\t\tstd::vector<int>PreLeft;\n\n\t\tstd::copy(&Pre[1], &Pre[m] + 1, std::back_inserter(PreLeft));\n\n\n\n\n\t\tstd::vector<int>InLeft;\n\t\tstd::vector<int>PreRight;\n\t\tPreRight.push_back(NIL);\n\t\t//PreRight={NIL};\n\t\tstd::vector<int> InRight;\n\t\tInRight.push_back(NIL);\n\t\t//InRight={NIL};\n\t\tstd::copy(&In[0], &In[m-1]+1, std::back_inserter(InLeft));\n\t\t\n\t\tif (m<Pre.size()-1){\n\t\t\tstd::copy(&Pre[m] + 1, &Pre[Pre.size() - 1] + 1, std::back_inserter(PreRight));\n\t\t}\n\t\tif (m<In.size()-1) {\n\t\t\tstd::copy(&In[m] + 1, &In[In.size() - 1] + 1, std::back_inserter(InRight));\n\t\t\t}\n\t\t\n\t\t\n\t\t\n\n\t\tstd::vector<int> child(2);\n\t\tchild[0] =  PreLeft.empty() ? NIL : PreLeft[0] ;\n\t\tchild[1] = PreRight.empty() ? NIL : PreRight[0] ;\n\t\t//nodes[cnt].AddChild(child);\n\t\tnodes[Root].AddChild(child);\n\t\tfor (unsigned int i = 0; i < child.size(); ++i) {\n\n\t\t\tif (child[i] != NIL) { nodes[child[i]].AddParent(Root); }\n\t\t}\n\t\tReconstruct(PreLeft, InLeft, nodes, PreLeft[0], ++cnt);\n\t\tReconstruct(PreRight, InRight, nodes, PreRight[0], ++cnt);\n\t}\n};\n\nvoid SetVector(std::vector<int>&InputVector) {\n\tfor (unsigned int i = 0; i < InputVector.size(); ++i) {\n\t\tstd::cin >> InputVector[i];\n\t}\n\treturn;\n}\nint main(void) {\n\n\tint n;\n\tstd::cin >> n;\n\tstd::vector<int>Pre(n);\n\tstd::vector<int>In(n);\n\tSetVector(Pre);\n\tSetVector(In);\n\tstd::vector<Tree> nodes(n+1);\n\t//ReconstructWithNoParent\n\tint cnt = 0;\n\tnodes[1].Reconstruct(Pre, In, nodes, Pre[0],cnt);\n\n\t//nodes[1].PostorderTreeWalk(nodes, 1);\n\tstd::vector<int>Print;\n\tnodes[1].GetVctorPostorderTreeWalk(nodes, Print, 1);\n//Print=nodes[1].GetVctorPostorderTreeWalk(nodes, 1);\nfor (unsigned int i = 0; i < Print.size(); ++i) {\n\tif (i) { std::cout << \" \"; }\n\tstd::cout<<Print[i];\n\tif(i==Print.size()-1){ std::cout << std::endl; }\n}\n\t\n\t\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cmath>\n#include<string>\n#include<algorithm>\n#include<stdio.h>\n#include<vector>\n#define NIL -1\nusing namespace std;\n\nstruct Node {\n\tint parent = NIL;\n\tint left = NIL;\n\tint right = NIL;\n};\n\nNode node[25];\n\n\n/*void initDepth(int k,int d) {\n\tdepth[k] = d;\n\tif (node[k].left != NIL) {\n\t\tinitDepth(node[k].left, d + 1);\n\t}\n\tif (node[k].right != NIL) {\n\t\tinitDepth(node[k].right, d + 1);\n\t}\n\treturn;\n}\n\nint initHeight(int k) {\n\tint h1 = 0, h2 = 0;\n\tif (node[k].left != NIL) {\n\t\th1 = initHeight(node[k].left) + 1;\n\t}\n\tif (node[k].right != NIL) {\n\t\th2 = initHeight(node[k].right) + 1;\n\t}\n\n\treturn height[k] = max(h1, h2); \n\t}*/\n\n\nint getBro(int k) {\n\tif (node[k].parent == NIL) { return NIL; }\n\tif (node[node[k].parent].left == k) {\n\t\treturn node[node[k].parent].right;\n\t}\n\treturn node[node[k].parent].left;\n}\n\nvoid getType(int k) {\n\tif (node[k].parent == NIL) { cout << \"root\"; return; }\n\tif (node[k].left == NIL && node[k].right == NIL) { cout << \"leaf\"; return; }\n\tcout << \"internal node\";\n}\n\nint getDegree(int k) {\n\tint num = 0;\n\tif (node[k].left != NIL) { num++; }\n\tif (node[k].right != NIL) { num++; }\n\treturn num;\n}\n\nint root(int k=0) {\n\tint root = 0;\n\twhile (node[root].parent != NIL) {\n\t\troot = node[root].parent;\n\t}\n\treturn root;\n}\n\nvoid p(int k) {\n\tif (k == NIL) { return; }\n\tcout << \" \"<<k;\n\tp(node[k].left);\n\tp(node[k].right);\n}\n\nvoid ml(int k) {\n\tif (k == NIL) { return; }\n\tml(node[k].left);\n\tcout << \" \"<< k;\n\tml(node[k].right);\n}\n\nvoid a(int k) {\n\tif (k == NIL) { return; }\n\ta(node[k].left);\n\ta(node[k].right);\n\tcout << \" \"<<k;\n}\n\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n\tif (l >= r) { return; }\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\nvoid solve() {\n\tpos = 0;\n\trec(0, pre.size());\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i) cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\n\n\n\n\n\nint main() \n{\n\tint m;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> m;\n\t\tpre.push_back(m);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> m;\n\t\tin.push_back(m);\n\t}\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n\n#define NIL -1\n#define LEN 26\nusing namespace std;\nint pre[100],in[100],cnt=0,q = 0;\n\nint infinda(int c){\n    int i = 0;\n    while(in[i]!=c)\n        i++;\n    return i;\n}\nvoid print(int u)\n{\n    if(q++)putchar(' ');\n    printf(\"%d\",u);\n}\nvoid reconstruction(int l,int r){\n    if(l>=r)return;\n    int c = pre[cnt++];\n    int m = infinda(c);\n    reconstruction(l,m);\n    reconstruction(m+1,r);\n    print(in[m]);\n}\n\nint main()\n{\n    int n,i;\n    cin >> n;\n\n    for(i = 0;i < n;i++){\n        scanf(\"%d\",&pre[i]);\n    }\n    for(i = 0;i < n;i++){\n        scanf(\"%d\",&in[i]);\n    }\n    reconstruction(0,n);\n    putchar('\\n');\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> pre, in, post;\nint preidx;\n\nvoid func(int l, int r){\n  //cout << l << \" \" << r << endl;\n  if(r-l == 1){\n    post.push_back(in[l]);\n    return;\n  }\n  if(r-l < 1) return;\n  //find pre[preidx] in in[begin:end]\n  int mid;\n  for(int i = l; i < r; i++){\n    if(in[i] == pre[preidx]){\n      mid = i;\n      break;\n    }\n  }\n  preidx++;\n  func(l, mid);\n  func(mid+1, r);\n  post.push_back(in[mid]);\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n; cin >> n;\n  pre.resize(n);\n  in.resize(n);\n  post.clear();\n  preidx = 0;\n\n  for(int i = 0; i < n; i++) cin >> pre[i];\n  for(int i = 0; i < n; i++) cin >> in[i];\n  func(0, n);\n\n  for(int i = 0; i < n; i++){\n    cout << post[i];\n    if(i == n-1) cout << endl;\n    else cout << \" \";\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r){\n    if(l>=r)\n        return;\n    int root = pre[pos++];\n    int m = distance(in.begin(),find(in.begin(),in.end(),root));\n    rec(l,m);\n    rec(m+1,r);\n    post.push_back(root);\n}\n\nvoid solve(){\n    pos = 0;\n    rec(0,pre.size());\n    for(int i=0;i<n;i++){\n        if(i)\n            cout<<\" \";\n        cout<<post[i];\n    }\n    cout<<endl;\n}\n\nint main(){\n    int k;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>k;\n        pre.push_back(k);\n    }\n\n    for(int i=0;i<n;i++){\n        cin>>k;\n        in.push_back(k);\n    }\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid Rec( int L, int R );\nvoid Solve();\n\nint main() {\n    cin >> n;\n    \n    int k;\n    for ( int i = 0; i < n; i++ ) {\n        cin >> k;\n        pre.push_back( k );\n    }\n    for ( int i = 0; i < n; i++ ) {\n        cin >> k;\n        in.push_back( k );\n    }\n    \n    Solve();\n    \n    return 0;\n}\n\nvoid Rec( int L, int R ) {\n    if ( L >= R ) return;\n    int root = pre[pos++];\n    int m = distance( in.begin(), find(in.begin(), in.end(), root) );\n    Rec( L, m );\n    Rec( m+1, R );\n    post.push_back( root );\n}\n\nvoid Solve() {\n    pos = 0;\n    Rec( 0, pre.size() );\n    for ( int i = 0; i < n; i++ ) {\n        if ( i ) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <random>\n#include <cstdlib>\n#define INT_MAX 2147483647\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i < (int)n; i++)\n#define Loopr(i, n) for(int i= (int)n - 1; i >= 0; i--)\nusing namespace std;\ntypedef long long int ll;\n\nstruct node {\n\tint parent, left, right;\n};\n\nint n, root, buf;\nvector<node> nodes(41, { -1,-1,-1 });\nvector<int> pre(41, -1), in(41, -1);\n\nvoid finding(int p, int l, int r) {\n\tint a = pre[buf];\n\tnodes[a].parent = p;\n\tbuf++;\n\tif (r - l != 1) {\n\t\tfor (int i = l;i < r;i++) {\n\t\t\tif (in[i] == a) {\n\t\t\t\tif (l != i) {\n\t\t\t\t\tnodes[a].left = pre[buf];\n\t\t\t\t\tfinding(a, l, i);\n\t\t\t\t}\n\t\t\t\tif (i + 1 != r) {\n\t\t\t\t\tnodes[a].right = pre[buf];\n\t\t\t\t\tfinding(a, i + 1, r);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid print_post(int a) {\n\tif (a != -1) {\n\t\tprint_post(nodes[a].left);\n\t\tprint_post(nodes[a].right);\n\t\tif (a == root) \tcout << a << endl;\n\t\telse cout << a << \" \";\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tLoop(i, n) cin >> pre[i];\n\tLoop(i, n) cin >> in[i];\n\troot = pre[0];\n\tbuf = 0;\n\tfinding(-1, 0, n);\n\tprint_post(root);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<stack>\n#include<cmath>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<sstream>\n#include<random>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\n//const int inf = 1e9 + 7;\nint dy[] = {0, 0, -1, 1};\nint dx[] = {1, -1, 0, 0};\n\nint n, pos;\nvector<int> pre, in;\nint flg;\nvoid rec(int l, int r) { //reconstruct\n    if (l >= r) return;\n    int c = pre[pos++];\n    int m = (int)distance(in.begin(), find(in.begin(), in.end(), c));\n    rec(l, m);\n    rec(m + 1, r);\n    if (flg) cout << \" \";\n    flg = 1;\n    cout << c;\n    \n}\nint main() {\n    cin >> n;\n    rep(i, n) {int v; cin >> v; pre.push_back(v);}\n    rep(i, n) {int v; cin >> v; in.push_back(v);}\n    rec(0, (int)pre.size());\n    cout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\nvector <int> pre, in;\n\nvoid rec(int lp, int rp, int li, int ri) {\n    int root = pre[lp];\n    int i = 0;\n    while(in[li+i] != root) i++;\n    if (i != 0) rec(lp+1, lp+i, li, li+i-1);\n    if (li + i != ri) rec(lp+i+1, rp, li+i+1, ri);\n\n    printf(\"%d \", root);\n}\n\nvoid solve(void){\n    int N;\n    cin >> N;\n    pre.resize(N), in.resize(N);\n    rep(N, i) cin >> pre[i];\n    rep(N, i) cin >> in[i];\n    rec(0, N-1, 0, N-1);\n}\n\nint main(void){\n  solve();\n  //cout << \"yui(*-v・)yui\" << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define N 40\n\nvector<int> a, b, c;\n\nvoid postOrder(vector<int>::iterator a1, vector<int>::iterator a2, vector<int>::iterator b1, vector<int>::iterator b2)\n{\n    //printf(\"%d %d %d %d\\n\", *a1, *(a2 - 1), *b1, *(b2 - 1));\n    vector<int>::iterator itr1, itr2;\n    c.push_back(*a1);\n    //printf(\"%d\\n\", *a1);\n    itr1 = find(b1, b2, *a1); //itrator of root on inorder tree walk\n    if (itr1 > b1)\n        itr2 = find(a1, a2, *(itr1 - 1)); //itrator of left subtree's the most right node on preorder tree walk\n    else\n        itr2 = a1;\n    if (itr2 + 1 < a2 && itr1 + 1 < b2)\n        postOrder(itr2 + 1, a2, itr1 + 1, b2);\n    if (a1 + 1 < itr2+1 && b1 < itr1)\n        postOrder(a1 + 1, itr2+1, b1, itr1);\n}\n\nint main()\n{\n    int n, x;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> x;\n        a.push_back(x);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        cin >> x;\n        b.push_back(x);\n    }\n\n    postOrder(a.begin(), a.end(), b.begin(), b.end());\n\n    for (int i = 0; i < c.size(); i++)\n    {\n        if (i != 0)\n            cout << \" \";\n        cout << c[c.size() - 1 - i];\n    }\n    cout << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r) {\n    if(l>=r) return;\n    int root=pre[pos++];\n    int m=distance(in.begin(),find(all(in),root));\n    rec(l,m);\n    rec(m+1,r);\n    post.pb(root);\n}\nvoid solve() {\n    pos=0;\n    rec(0,pre.size());\n    rep(i,n) printf(\"%d%c\",post[i],i==n-1?'\\n':' ');\n}\n\n\nint main() {\n    int k;\n    cin>>n;\n    rep(i,n) {\n        cin>>k;\n        pre.pb(k);\n    }\n    rep(i,n) {\n        cin>>k;\n        in.pb(k);\n    }\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconstexpr int di[] = { 0, 1, 0, -1 }, dj[] = { 1, 0, -1, 0 };\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define repr(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define all(v) (v).begin(), (v).end()\n#define MAX 10000\n#define nil -1\n#define vmax 10000\n#define sentinel 2000000000\nconstexpr long long int inf = 1000000000000;\nconstexpr long long int rinf = -(INT64_MAX);\n//cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);\n\nint pos,n;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r){\n    if(l==r) return;\n    int root=pre[pos++];\n    int m=distance(in.begin(),find(in.begin(),in.end(),root));\n    rec(l,m);\n    rec(m+1,r);\n    post.push_back(root);\n}\n\nvoid solve(){\n    pos=0;\n    rec(0,n);\n    rep(i,n){\n        if(i){\n            cout<<\" \";\n        }\n        cout<<post[i];\n    }\n    cout<<endl;\n}\n\nint main() {\n    int k;\n    cin>>n;\n    rep(i,n){\n        cin>>k;\n        pre.push_back(k);\n    }\n    rep(i,n){\n        cin>>k;\n        in.push_back(k);\n    }\n\n    solve();\n    \n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n//#include \"libs.h\"\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n//#include <opencv2/core.hpp>\n//#include <opencv2/highgui.hpp>\n//#include <opencv2/imgproc.hpp>\n\nusing namespace std;\n\n//呪文\n#define DUMPOUT cerr\n#define dump(...) DUMPOUT<<\"  \";DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl;DUMPOUT<<\"    \";dump_func(__VA_ARGS__)\n\ntypedef unsigned uint; typedef long long ll; typedef unsigned long long ull; typedef pair<int, int> pii; typedef pair<ll, ll> pll; typedef pair<double, double> pdd; typedef pair<string, string> pss;\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const pair<_KTy, _Ty>& m) { o << \"{\" << m.first << \", \" << m.second << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const unordered_map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const vector<_Ty>& v) { if (v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const unordered_set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; }\to << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const stack<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } stack<_Ty> t(s); o << \"{\" << t.top(); t.pop(); while (!t.empty()) { o << \", \" << t.top(); t.pop(); } o << \"}\";\treturn o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const list<_Ty>& l) { if (l.empty()) { o << \"{ }\"; return o; } o << \"{\" << l.front(); for (auto itr = ++l.begin(); itr != l.end(); ++itr) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> istream& operator >> (istream& is, pair<_KTy, _Ty>& m) { is >> m.first >> m.second; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, vector<_Ty>& v) { for (size_t i = 0; i < v.size(); i++) is >> v[i]; return is; }\nnamespace aux { // print tuple\n\ttemplate<typename Ty, unsigned N, unsigned L> struct tp { static void print(ostream& os, const Ty& v) { os << get<N>(v) << \", \"; tp<Ty, N + 1, L>::print(os, v); } };\n\ttemplate<typename Ty, unsigned N> struct tp<Ty, N, N> { static void print(ostream& os, const Ty& v) { os << get<N>(v); } };\n}\ntemplate<typename... Tys> ostream& operator<<(ostream& os, const tuple<Tys...>& t) { os << \"{\"; aux::tp<tuple<Tys...>, 0, sizeof...(Tys)-1>::print(os, t); os << \"}\"; return os; }\n\ntemplate<typename A, size_t N, typename T> inline void Fill(A(&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\n\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) { DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(std::move(tail)...); }\n\n#define PI 3.14159265358979323846\n#define EPS 1e-10\n#define FOR(is,a,n) for(int is=(a);is<(n);++is)\n#define REP(is,n)  FOR(is,0,n)\n#define all(j) (j).begin(), (j).end()\n#define SZ(j) ((int)(j).size())\n#define fake false\n\n\n\nconst int NIL = -1;\n\ntemplate<typename T> void printVec(const vector<T>& v, char delim = ' ', ostream& os = cout) {\n\tos << v[0];\n\tfor (int i = 1; i < v.size(); i++)\n\t\tos << delim << v[i];\n\tos << endl;\n}\n\ntypedef struct Node {\n\tint val;\n\tint left;\n\tint right;\n\tNode() : val(NIL), left(NIL), right(NIL) {}\n}* NodePtr;\n\nostream& operator<<(ostream& os, const Node& obj) {\n\tos << \"{val: \" << obj.val << \", left: \" << obj.left << \", right: \" << obj.right << \"}\";\n\treturn os;\n}\n\nvector<int> pre, in;\nvector<Node> nodes;\n\nint recon(int& pos, int begin, int end, Node& target) {\n\tif (pos == nodes.size() || end - begin < 1)\n\t\treturn NIL;\n\n\tint v = pre[pos];\n\tint idx = NIL;\n\tfor (int i = begin; i < end; i++)\n\t\tif (in[i] == v)\n\t\t\tidx = i;\n\n\tif (idx == NIL)\n\t\treturn NIL;\n\n\ttarget.val = v;\n\tpos++;\n\tif (pos == nodes.size())\n\t\treturn v;\n\n\ttarget.left = recon(pos, begin, idx, nodes[pre[pos]]);\n\ttarget.right = recon(pos, idx + 1, end, nodes[pre[pos]]);\n\n\treturn v;\n}\n\nvoid postOrder(vector<int>& order, int v) {\n\tif (v == NIL)\n\t\treturn;\n\n\tpostOrder(order, nodes[v].left);\n\tpostOrder(order, nodes[v].right);\n\torder.push_back(v);\n}\n\nint main() {\n\t\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\t\n\tpre.resize(n);\n\tin.resize(n);\n\tcin >> pre >> in;\n\tfor (int i = 0; i < n; i++) {\n\t\tpre[i]--; in[i]--;\n\t}\n\n\tnodes.resize(n);\n\n\tint pos = 0;\n\tint v = pre[pos];\n\tNode& root = nodes[v];\n\n\trecon(pos, 0, n, root);\n\n\tvector<int> order;\n\tpostOrder(order, v);\n\tfor (auto& e : order)\n\t\te++;\n\n\tprintVec(order);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string> \n#include<algorithm> \n#include<vector> \nusing namespace std; \nint n, pos; \nvector<int> pre, in, post; \nvoid rec(int 1, int r) { \nif (1 >= r) return; \nint root = pre[pos++]; \nint m = distance(in.begin() , find(in .begin() , in . end() , root)) ; \nrec(l, m) ;\nrec(m + 1 , r);\npost.push_back(root); \n} \nvoid solve() { \npos = 0; \nrec(0, pre . size()) ;\n for ( int i = 0; i < n; i++ ) { \nif ( i ) cout << \" \" ; \ncout << post [i] ; \n} \ncout << endl; \n } \nint main() {\nint k;\ncin >>n;\nfor(int i = 0; i < n; i++){\ncin >> k;\npre.push_back(k);\n}\nfor(int i = 0; i < n; i++){\ncin >> k;\nin.push_back(k);\n}\nsolve();\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\nvector<int>pre, in, post;\nint n, pos;\nvoid rec(int l, int r) {\n\tif (!(l < r))return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\nvoid solve() {\n\tpos = 0;\n\trec(0, pre.size());\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i)cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\trep(i, 0, n) {\n\t\tint x; cin >> x;\n\t\tpre.push_back(x);\n\t}\n\trep(i, 0, n) {\n\t\tint x; cin >> x;\n\t\tin.push_back(x);\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define NIL -1\n\nint pre[100],in[100],ans[100],n,pos;\n\nvoid solve(int L,int R){\n\tif(!(L<R))return;\n\tint m,root=pre[pos++];\n\n\tfor(m=0;m<n;m++){\n\t\tif(in[m]==root)break;\n\t}\n\n\tsolve(L,m);\n\tsolve(m+1,R);\n\n\t//printf(\"%d\",root);\n\tans[ ++ans[0] ]=root;\n\n\treturn;\n}\n\nint main(){\n\tpos=0;\n\tint i;\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++)scanf(\"%d\",&pre[i]);\n\tfor(i=0;i<n;i++)scanf(\"%d\",&in[i]);\n\n\tsolve(0,n);\n\tfor(i=1;i<=ans[0];i++){\n\t\tif(i>1)printf(\" \");\n\t\tprintf(\"%d\",ans[i]);\n\t}\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nstruct data{\n\tint par,left,right;\n};\n\nint n;\nint a[41],b[41],c[41];\ndata dat[41];\nint cnt;\n\nvoid dfs(int v){\n\tif(dat[v].left>0)dfs(dat[v].left);\n\tif(dat[v].right>0)dfs(dat[v].right);\n\tprintf(\"%d%c\",v,cnt==n-1?'\\n':' ');\n\tcnt++;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&b[i]);\n\t\tc[b[i]]=i;\n\t}\n\tc[0]=n;\n\tfor(int i=1;i<=n;i++){\n\t\tdat[i].par=-1;\n\t\tdat[i].left=-1;\n\t\tdat[i].right=-1;\n\t}\n\tdat[a[0]].par=0;\n\tint p=a[0];\n\tint mostr=c[a[0]];\n\tfor(int i=1;i<n;i++){\n\t\tfor(int j=c[a[i]]-1;j>=0;j--){\n\t\t\tif(dat[b[j]].par!=-1 && dat[b[j]].right==-1){\n\t\t\t\tdat[b[j]].right=a[i];\n\t\t\t\tdat[a[i]].par=b[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(dat[b[j]].par!=-1)break;\n\t\t}\n\t\tfor(int j=c[a[i]]+1;j<n;j++){\n\t\t\tif(dat[b[j]].par!=-1 && dat[b[j]].left==-1){\n\t\t\t\tdat[b[j]].left=a[i];\n\t\t\t\tdat[a[i]].par=b[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(dat[b[j]].par!=-1)break;\n\t\t}\n\t}\n\tdfs(a[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define ms(s,x) memset(s,x,sizeof(s))\n#define pb push_back\n#define inf 0x3f3f3f3f\n#define IOS ios::sync_with_stdio(false);cin.tie(0)\ntypedef long long ll;\nusing namespace std;\n\nconst double PI = acos(-1.0);\nconst double eps = 1e-8;\nconst int MAXN = 1e5+5;\nconst ll MOD = 1e9+7;\n\nint n, pos = 0;\nvector <int> pre, in, post;\n\nvoid rec(int l, int r) //由先序和中序推出后序\n{\n    if (l >= r) return;\n    int root = pre[pos++];\n    int sign = find(in.begin(), in.end(), root) - in.begin();\n    rec(l, sign);\n    rec(sign+1, r);\n    post.pb(in[sign]);\n}\n\nvoid postorder()\n{\n    rep(i, 0, n-1){\n        if (i) putchar(' ');\n        printf(\"%d\", post[i]);\n    }\n    putchar('\\n');\n    return;\n}\n\nint main()\n{\n    int id;\n    cin >> n;\n    rep(i, 0, n-1){\n        cin >> id;\n        pre.pb(id);\n    }\n    rep(i, 0, n-1){\n        cin >> id;\n        in.pb(id);\n    }\n    rec(0, n);\n    postorder();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>    // std::copy\n#include <iterator>     // std::back_inserter\nusing namespace std;\n\nstruct TNode\n{\n\tint Id;\n\tTNode* Parent;\n\tTNode* LChild;\n\tTNode* RChild;\n};\n\nvector<int> Input(int n)\n{\n\tvector<int> Tree(n);\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> Tree[i];\n\t}\n\treturn Tree;\n}\n\nvoid PostorderOutput(const TNode* Node)\n{\n\tif(Node == NULL) return;\n\tPostorderOutput(Node->LChild);\n\tPostorderOutput(Node->RChild);\n\tcout << Node->Id;\n\tif(Node->Parent){\n\t\tcout << ' ';\n\t}else{\n\t\tcout << endl;\n\t}\n}\n\nvoid Delete(const TNode* Node)\n{\n\tif(Node == NULL) return;\n\tDelete(Node->LChild);\n\tDelete(Node->RChild);\n\tdelete Node;\n}\n\nvector<int> Subvec(vector<int> X, int m, int n)\n{\n\tvector<int> Y;\n\tfor(int i = m; i <= n; i++){\n\t\tY.push_back(X[i]);\n\t}\n\treturn Y;\n}\n\nTNode* MakeTree(const vector<int>& PreorderRow, const vector<int>& InorderRow)\n{\n\t//PreorderRow????????????????´?Root?????¨???*\n\tint Root = PreorderRow[0];\n\t\n\t//InorderRow??????????????????Root??????InorderRowLeft?????¨???\n\tvector<int>::const_iterator it = find(InorderRow.begin(), InorderRow.end(), Root);\n\tint RootIndex = it - InorderRow.begin();\n\t\n\tvector<int> InorderRowLeft;\n\tcopy(InorderRow.begin(), InorderRow.begin() + RootIndex, back_inserter(InorderRowLeft));\n\t\n\t//PreorderRow???2??????????????????InorderRowLeft??¨???????????°???PreorderRowLeft?????¨???\n\tvector<int> PreorderRowLeft;\n\t\n\tcopy(PreorderRow.begin() + 1, PreorderRow.begin() + RootIndex + 1, back_inserter(PreorderRowLeft));\n\t\n\t//PreorderRow??¨InorderRow???????????????PreorderRowRight,InorderRowRight?????¨???\n\tvector<int> PreorderRowRight;\n\tcopy(PreorderRow.begin() + RootIndex + 1, PreorderRow.begin() + PreorderRow.size(), back_inserter(PreorderRowRight));\n\tvector<int> InorderRowRight;\n\tcopy(InorderRow.begin() + RootIndex + 1, InorderRow.begin() + InorderRow.size(), back_inserter(InorderRowRight));\n\t\n\t//ID???Root??¨????????????????????????**\n\tTNode* RootNode;\n\tRootNode = new TNode;\n\t*RootNode = {Root, NULL, NULL, NULL};\n\t\n\t//PreorderRowLeft,InorderRowLeft??????*~**??¨????§???????????????????(?????????????´????RootLeft??¨??????)\n\tif(PreorderRowLeft.size() > 0){\n\t\tTNode* LeftNode = MakeTree(PreorderRowLeft, InorderRowLeft);\n\t\t//Root??¨RootLeft???????????????\n\t\tRootNode->LChild = LeftNode;\n\t\tLeftNode->Parent = RootNode;\n\t}\n\t\n\t//PreorderRowRight,InorderRowRight??????*~**??¨????§???????????????????(?????????????´????RootRight??¨??????)\n\tif(PreorderRowRight.size() > 0){\n\t\tTNode* RightNode = MakeTree(PreorderRowRight, InorderRowRight);\n\t\t//Root??¨RootRight???????????????\n\t\tRootNode->RChild = RightNode;\n\t\tRightNode->Parent = RootNode;\n\t}\n\t\n\treturn RootNode;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<int> PreorderRow = Input(n);\n\tvector<int> InorderRow  = Input(n);\n\tTNode* RootNode = MakeTree(PreorderRow, InorderRow);\n\tPostorderOutput(RootNode);\n\tDelete(RootNode);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nint main() {\n\tint N;\n\tcin >> N;\n\tvector<int> A(N), B(N);\n\tfor(int i = 0; i < N; ++i) cin >> A[i];\n\tfor(int i = 0; i < N; ++i) cin >> B[i];\n\tint cnt = 0;\n\tfunction<void(int, int, int, int)> dfs = [&](int la, int ra, int lb, int rb) {\n\t\tif(la == ra) return;\n\t\tint sep = find(B.begin(), B.end(), A[la]) - B.begin();\n\t\tdfs(la + 1, la + 1 + (sep - lb), lb, sep);\n\t\tdfs(la + 1 + (sep - lb), ra, sep + 1, rb);\n\t\tcout << A[la] << (++cnt != N ? ' ' : '\\n');\n\t};\n\tdfs(0, N, 0, N);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l , int r) {\n  if(l >= r)return ;\n  int root = pre[pos++];\n  int m = distance(in.begin(),find(in.begin(), in.end(),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\n\nvoid solve() {\n  pos = 0;\n  rec(0,pre.size());\n  for(int i = 00;i<n;i++) {\n    if(i) cout << \" \";\n    cout << post[i];\n  }\n  cout <<endl;\n}\n\nint main() {\n  int k;\n  cin >> n;\n\n  for(int i  = 0; i<n;i++) {\n    cin >>k;\n    pre.push_back(k);\n  }\n  for(int i=0;i<n;i++){\n    cin >> k;\n    in.push_back(k);\n  }\n\n  solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n,pos;\nvector<int>pre,in,post;\nvoid rec(int l,int r){\nif(l>=r)return 0;\nint root=pre[pos++];\nint m=distance(in.begin(),find(in.begin(),in.end(),root));\nrec(l,m);\nrec(m+1,r);\npost.push_back(root);\n}\nvoid solve(){\npos=0;\nrec(0,pre.size());\nfor(int i=0;i<n;i++){\nif(i)cout<<\" \";\ncout<<post[i];\n}\ncout<<endl;\n}\nint main(){\nint k;\ncin>>n;\nfor(int i=0;i<n;i++){\ncin>>k;\npre.push_back(k);\n}\nfor(int i=0;i<n;i++){\ncin>>k;\nin.push_back(k);\n}\nsolve();\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l, int r){\n  if(l>=r) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(),in.end(),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\n\nvoid solve(){\n  int i;\n  pos = 0;\n  rec(0,pre.size());\n  for(i=0;i<n;i++){\n    if(i) cout << \" \";\n    cout << post[i];;\n  }\n  cout << endl;\n}\n\nint main(){\n  int k;\n  cin >> n;\n\n  for(int i =0;i<n;i++){\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for(int i=0;i<n;i++){\n    cin >> k;\n    in.push_push(k);\n  }\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid reconstruction(int l, int r) {\n  if ( l >= r ) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  reconstruction(l, m);\n  reconstruction(m + 1, r);\n  post.push_back(root);\n}\n\nvoid solve() {\n  pos = 0;\n  reconstruction(pos, pre.size());\n  for ( int i = 0; i < n; i++ ) {\n    if ( i ) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n\n\nint main() {\n  int v;\n  cin >> n;\n\n  for ( int i = 0; i < n; i++ ) {\n    cin >> v;\n    pre.push_back(v);\n  }\n\n  for ( int i = 0; i < n; i++ ) {\n    cin >> v;\n    in.push_back(v);\n  }\n\n  solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace  std;\n\nconst int END = -1;\nstruct StNod\n{\n  int m_nParnt;\n  int m_nLeft;\n  int m_nRigt;\n\n  StNod() :\n     m_nParnt(END), m_nLeft(END), m_nRigt(END)\n  { }\n};\n\nvoid fnInput(vector<int> &rvnPodr, vector<int> &rvnIodrSeq)\n{\n  int nMaxSiz;\n\n  cin >> nMaxSiz;\n  rvnPodr.resize(nMaxSiz + 1);\n  rvnIodrSeq.resize(nMaxSiz + 1);\n\n  for (int i = 1; i < nMaxSiz + 1; i++)\n    cin >> rvnPodr[i];\n\n  int nNode;\n  for (int i = 1; i < nMaxSiz + 1; i++)\n  {\n    cin >> nNode;\n    rvnIodrSeq[nNode] = i;\n  }\n}\n\nvoid fnPostOrder(const vector<int> &cnrvnPodr, const vector<int> &cnrvnIodrSeq, int nLeft, int nRight)\n{\n  static int stnx = 1;\n  static int stnPrt = 0;\n\n  if (nLeft == nRight) return;\n\n  int nNode = cnrvnPodr[stnx++];\n  int nMid = cnrvnIodrSeq[nNode];\n\n  fnPostOrder(cnrvnPodr, cnrvnIodrSeq, nLeft, nMid);\n  fnPostOrder(cnrvnPodr, cnrvnIodrSeq, nMid + 1, nRight);\n\n  if (stnPrt++) cout << \" \";\n  cout << nNode;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vector<int> vnPodr, vnIodrSeq;\n  fnInput(vnPodr, vnIodrSeq);\n\n  fnPostOrder(vnPodr, vnIodrSeq, 1, vnPodr.size());\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct Node {\n  int id;\n  Node* parent = nullptr;\n  Node* left = nullptr;\n  Node* right = nullptr;\n  int depth;\n  int height;\n\n  int calcHeight() {\n    int leftHeight = left ? left->calcHeight() : -1;\n    int rightHeight = right ? right->calcHeight() : -1;\n    height = max(leftHeight, rightHeight) + 1;\n    return height;\n  }\n\n  void calcDepth() {\n    depth = parent ? parent->depth + 1 : 0;\n    if (left) left->calcDepth();\n    if (right) right->calcDepth();\n  }\n\n  int degree() {\n    int d = 0;\n    if (left) ++d;\n    if (right) ++d;\n    return d;\n  }\n\n  Node* sibling() {\n    if (!parent) {\n      return nullptr;\n    }\n    if (parent->left == this) {\n      return parent->right;\n    } else {\n      return parent->left;\n    }\n  }\n\n  void walkPostorder() {\n    static bool isFirst = true;\n    if (left) left->walkPostorder();\n    if (right) right->walkPostorder();\n    if (isFirst) {\n      cout << (id + 1);\n      isFirst = false;\n    } else {\n      cout << \" \" << (id + 1);\n    }\n  }\n\n  static Node* reconstruct(\n    vector<Node>& nodes,\n    vector<int>::const_iterator preorderBegin, vector<int>::const_iterator preorderEnd,\n    vector<int>::const_iterator inorderBegin, vector<int>::const_iterator inorderEnd\n  ) {\n    if (inorderBegin == inorderEnd) {\n      return nullptr;\n    }\n    auto root = &nodes[*preorderBegin];\n    auto inorderMid = std::find_if(inorderBegin, inorderEnd, [&](int id){ return id == *preorderBegin; });\n    auto leftCount = inorderMid - inorderBegin;\n    auto left = reconstruct(nodes, preorderBegin + 1, preorderBegin + 1 + leftCount, inorderBegin, inorderMid);\n    auto right = reconstruct(nodes, preorderBegin + 1 + leftCount, preorderEnd, inorderMid + 1, inorderEnd);\n    root->left = left;\n    root->right = right;\n    return root;\n  }\n};\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int nodeCount;\n  cin >> nodeCount;\n  vector<Node> nodes(nodeCount);\n  for (int i = 0; i < nodeCount; ++i) {\n    nodes[i].id = i;\n  }\n\n  std::vector<int> preorderIDs, inorderIDs;\n\n  for (int i = 0; i < nodeCount; ++i) {\n    int id;\n    cin >> id;\n    preorderIDs.push_back(id - 1);\n  }\n\n  for (int i = 0; i < nodeCount; ++i) {\n    int id;\n    cin >> id;\n    inorderIDs.push_back(id - 1);\n  }\n\n  auto root = Node::reconstruct(nodes, preorderIDs.begin(), preorderIDs.end(), inorderIDs.begin(), inorderIDs.end());\n\n  root->walkPostorder();\n  cout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    size_t n;\n    cin >> n;\n    vector<size_t> in(n), invpre(n), hoge(n);\n    for(size_t i = 0, a; i < n; ++i){\n        cin >> a;\n        invpre[--a] = i;\n    }\n    for(size_t i = 0; i < n; ++i){\n        cin >> in[i];\n        hoge[i] = invpre[in[i] - 1];\n    }\n    vector<size_t> ans;\n    stack<pair<size_t, size_t>> st;\n    st.emplace(0, n);\n    while(!st.empty()){\n        auto a = st.top().first, b = st.top().second;\n        st.pop();\n        if(a == b)continue;\n        auto k = min_element(hoge.begin() + a, hoge.begin() + b) - hoge.begin();\n        ans.push_back(in[k]);\n        st.emplace(a, k);\n        st.emplace(k + 1, b);\n    }\n    for(auto i = n; i; cout << \" \\n\"[!i])cout << ans[--i];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <algorithm>\n \nenum TNodeType {ntRoot, ntInternal, ntLeaf};\ntemplate<typename T>\nclass TTree;\n \ntemplate<typename T>\nclass TNode\n{\n    const T FValue;\n    TNode* FParent;\n    TNode* FLeft;\n    TNode* FRight;\n\npublic:\n    TNode(const T& Value)\n     : FValue(Value)\n    {\n        FParent = NULL;\n        FLeft   = NULL;\n        FRight  = NULL;\n    }\n    T Value()const\n    {\n        return FValue;\n    }\n    void AddNode(TNode* Node)\n    {\n        Node->FParent = this;\n        if(FValue < Node->FValue){\n            assert(FRight);\n            FRight = Node;\n        }else{\n            assert(FLeft);\n            FLeft  = Node;\n        }\n    }\n    void SetLeft(TNode* Node)\n    {\n        Node->FParent = this;\n        FLeft = Node;\n    }\n    void SetRight(TNode* Node)\n    {\n        Node->FParent = this;\n        FRight = Node;\n    }\n    TNode* CreateLeft(const T& Value)\n    {\n        assert(FLeft == NULL);\n        SetLeft(new TNode(Value));\n        return FLeft;\n    }\n    TNode* CreateRight(const T& Value)\n    {\n        assert(FRight == NULL);\n        SetRight(new TNode(Value));\n        return FRight;\n    }\n    const TNode* Parent()const\n    {\n        return FParent;\n    }\n    const TNode* Left()const\n    {\n        return FLeft;\n    }\n    const TNode* Right()const\n    {\n        return FRight;\n    }\n    const TNode* Find(const T& Value)const\n    {\n        // std::cout << \"Find(\" << Value << \")\" << std::endl;\n        if(FValue == Value) return this;\n        TNode* Node = FValue < Value ? FRight : FLeft;\n        if(Node) return Node->Find(Value);\n        return NULL;\n    }\n    TNode* Find(const T& Value)\n    {\n        return const_cast<TNode*>(const_cast<const TNode*>(this)->Find(Value));\n    }\n};\n\ntemplate<typename T>\nint GetNodeDepth(const TNode<T>* Node)\n{\n    assert(Node);\n    int Depth = 0;\n    while(Node->Parent()){\n        Node = Node->Parent();\n        Depth++;\n    }\n    return Depth;\n}\n \ntemplate<typename T>\nTNodeType GetNodeType(const TNode<T>* Node)\n{\n    assert(Node);\n    if(Node->Parent() == NULL) return ntRoot;\n    if(Node->Left() || Node->Right()) return ntInternal;\n    return ntLeaf;\n}\nstd::string GetNodeTypeText(const TNodeType& Type)\n{\n    switch(Type){\n    case ntRoot:     return \"root\";\n    case ntInternal: return \"internal node\";\n    case ntLeaf:     return \"leaf\";\n    }\n    assert(false);\n    return \"\";\n}\n \ntemplate<typename T>\nconst TNode<T>* GetSibling(const TNode<T>* Node)\n{\n    assert(Node);\n    const TNode<T>* Parent = Node->Parent();\n    if(Parent == NULL) return NULL;\n    if(Parent->Left()  && Parent->Left()  != Node) return Parent->Left();\n    if(Parent->Right() && Parent->Right() != Node) return Parent->Right();\n    return NULL;\n}\ntemplate<typename T>\nconst TNode<T>* GetRoot(const TNode<T>* Node)\n{\n    if(Node->Parent()) return GetRoot(Node->Parent());\n    return Node;\n}\ntemplate<typename T>\nint GetDegree(const TNode<T>* Node)\n{\n    return (Node->Left() ? 1 : 0) + (Node->Right() ? 1 : 0);\n}\n\ntemplate<typename T>\nint GetHeight(const TNode<T>* Node)\n{\n    if(Node == NULL) return -1;\n    return 1 + std::max(GetHeight(Node->Left()), GetHeight(Node->Right()));\n}\ntemplate<typename T>\nvoid PrintNode(const TNode<T>* Node)\n{\n    assert(Node);\n// node 0: parent = -1, sibling = -1, degree = 2, depth = 0, height = 3, root    \n    std::cout << \n    \"node \"       << Node->Value() <<\n    \": parent = \" << (Node->Parent() ? Node->Parent()->Value() : -1) <<\n    \", sibling = \"<< (GetSibling(Node) ? GetSibling(Node)->Value() : -1) <<\n    \", degree = \" << GetDegree(Node) <<\n    \", depth = \"  << GetNodeDepth(Node) <<\n    \", height = \"  << GetHeight(Node) << \n    \", \"          << GetNodeTypeText(GetNodeType(Node)) <<\n    std::endl;\n}\n// template<typename T>\n// void PrintPreorder(const TNode<T>* Node)\n// {\n// //  0 1 2 3 4 5 6 7 8\n//     if(Node == NULL) return;\n//     std::cout << \" \" << Node->Value();\n//     PrintPreorder(Node->Left());\n//     PrintPreorder(Node->Right());\n// }\n// template<typename T>\n// void PrintInorder(const TNode<T>* Node)\n// {\n// //  2 1 3 0 6 5 7 4 8\n//     if(Node == NULL) return;\n//     PrintInorder(Node->Left());\n//     std::cout << \" \" << Node->Value();\n//     PrintInorder(Node->Right());\n// }\ntemplate<typename T>\nvoid PrintPostorder(const TNode<T>* Node)\n{\n//  2 3 1 6 7 5 8 4 0\n    if(Node == NULL) return;\n    PrintPostorder(Node->Left());\n    PrintPostorder(Node->Right());\n    std::cout << Node->Value();\n    if(Node->Parent()){\n        std::cout << \" \";\n    }\n}\n\ntemplate<typename T, typename TIt>\nvoid AddNode(TNode<T>* Node, TIt& PreBegin, TIt PreEnd, TIt InBegin, TIt InEnd);\n\ntemplate<typename T, typename TIt>\nvoid AddLeftNode(TNode<T>* Node, TIt& PreBegin, TIt PreEnd, TIt InBegin, TIt InEnd)\n{\n    assert(PreBegin != PreEnd);\n    if(InBegin == InEnd) return;\n    TNode<T>* New = new TNode<T>(*PreBegin);\n    Node->SetLeft(New);\n    AddNode(New, ++PreBegin, PreEnd, InBegin, InEnd);\n}\n\ntemplate<typename T, typename TIt>\nvoid AddRightNode(TNode<T>* Node, TIt& PreBegin, TIt PreEnd, TIt InBegin, TIt InEnd)\n{\n    assert(PreBegin != PreEnd);\n    if(InBegin == InEnd) return;\n    TNode<T>* New = new TNode<T>(*PreBegin);\n    Node->SetRight(New);\n    AddNode(New, ++PreBegin, PreEnd, InBegin, InEnd);\n}\n\ntemplate<typename T, typename TIt>\nvoid AddNode(TNode<T>* Node, TIt& PreBegin, TIt PreEnd, TIt InBegin, TIt InEnd)\n{\n    if(PreBegin == PreEnd)  return;\n    TIt It = std::find(InBegin, InEnd, Node->Value());\n    assert(It != InEnd);\n    AddLeftNode(Node, PreBegin, PreEnd, InBegin, It);\n    AddRightNode(Node, PreBegin, PreEnd, It+1, InEnd);\n}\n\nint main()\n{\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    int n;\n    std::cin >> n;\n    std::vector<int> PreOrderIdList(n);\n    for(int i = 0; i < n; ++i){\n        std::cin >> PreOrderIdList[i];\n    }\n    std::vector<int> InOrderIdList(n);\n    for(int i = 0; i < n; ++i){\n        std::cin >> InOrderIdList[i];\n    }\n    \n    TNode<int> Node(PreOrderIdList[0]);\n    std::vector<int>::iterator It = PreOrderIdList.begin();\n    AddNode(&Node, ++It, PreOrderIdList.end(), InOrderIdList.begin(), InOrderIdList.end());\n\n    PrintPostorder(&Node);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include  <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n    if(l >= r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m+1, r);\n    post.push_back(root);\n}\n\nvoid solve() {\n    pos = 0;\n    rec(0, pre.size());\n    for (int i = 0; i < n; i++) {\n        if (i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main() {\n\n    int k;\n    cin >> n;\n\n    for (int i = 0; i < n; i++) {\n        cin >> k;\n        pre.push_back(k);\n    }\n\n    for (int i = 0; i < n; i++) {\n        cin >> k;\n        in.push_back(k);\n    }\n\n    solve();\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\n#define MAX_V 41\nstruct node{\n  int id,parent,left,right,sibling;\n  node():id(0),parent(-1),left(-1),right(-1),sibling(-1){}\n};\nnode nodes[MAX_V]{};\n\nvoid set_node(int id, int left,int right){\n  nodes[id].id=id;\n  nodes[id].left=left;\n  nodes[id].right=right;\n  if(left>=0){\n    nodes[left].id=left;\n    nodes[left].parent=id;\n    nodes[left].sibling=right;\n  }\n  if(right>=0){\n    nodes[right].id=right;\n    nodes[right].parent=id;\n    nodes[right].sibling=left;\n  }\n}\nvoid printPostorder(node n,bool last=false){\n  if(n.left>=0) printPostorder(nodes[n.left]);\n  if(n.right>=0) printPostorder(nodes[n.right]);\n  cout<<n.id<<(last?\"\\n\":\" \");\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  vector<int> pre;\n  vector<int> in;\n  int n; cin>>n;\n  REP(i,n) {int tmp; cin>>tmp; pre.push_back(tmp);}\n  REP(i,n) {int tmp; cin>>tmp; in.push_back(tmp);}\n  if(n==1) {cout<<pre[0]<<endl;return 0;}\n  while(true){\n    bool found=false;\n    for(int i=pre.size()-2;i>=0;i--){\n      for(int j=in.size()-2;j>=0;j--){\n\tif(i<(int)pre.size()-2&&j<(int)in.size()-2){\n\t  if(pre[i]==in[j+1]&&pre[i+1]==in[j]&&pre[i+2]==in[j+2]){\n\t    set_node(pre[i],pre[i+1],pre[i+2]);\n\t    auto iter=pre.begin();\n\t    REP(k,i+1) iter++;\n\t    pre.erase(iter); pre.erase(iter);\n\t    iter=in.begin();\n\t    REP(k,j) iter++;\n\t    in.erase(iter);iter++;in.erase(iter);\n\t    found=true; break;\n\t  }\n\t}\n\tif(pre[i]==in[j]&&pre[i+1]==in[j+1]){\n\t  set_node(pre[i],-1,pre[i+1]);\n\t  auto iter=pre.begin();\n\t  REP(k,i+1) iter++;\n\t  pre.erase(iter);\n\t  iter=in.begin();\n\t  REP(k,j+1) iter++;\n\t  in.erase(iter);\n\t  found=true; break;\n\t}\n\tif(pre[i]==in[j+1]&&pre[i+1]==in[j]){\n\t  set_node(pre[i],pre[i+1],-1);\n\t  auto iter=pre.begin();\n\t  REP(k,i+1) iter++;\n\t  pre.erase(iter);\n\t  iter=in.begin();\n\t  REP(k,j) iter++;\n\t  in.erase(iter);\n\t  found=true; break;\n\t}\n      }\n      if(found){break;}\n    }\n    if((int)pre.size()==1){break;}\n  }\n  int root=1;\n  while(nodes[root].parent!=-1)\n    root=nodes[root].parent;\n  printPostorder(nodes[root],true);\n}"
  },
  {
    "language": "C++",
    "code": " #include<stdio.h>\n\nint n, p;\nint a1[40], a2[40];\n\nvoid solve(int l,int r){\n\n  if(l>r) return;\n\n  if(l==r){\n    if(a2[l]==a1[0])printf(\"%d\", a2[l]);\n    else printf(\"%d \", a2[l]);\n    p++;\n    return;\n  }\n\n  int x=a1[p], i;\n  p++;\n\n  for(i=l; i<=r; i++)\n    if(a2[i]==x) break;\n\n  solve(l,i-1);\n  solve(i+1,r);\n\n  if(x==a1[0]) printf(\"%d\",x);\n  else printf(\"%d \",x);\n}\n\nint main(){\n\n  int i;\n\n  scanf(\"%d\",&n);\n\n  for(i=0; i<n; i++) scanf(\"%d\",&a1[i]);\n  for(i=0; i<n; i++) scanf(\"%d\",&a2[i]);\n  p=0;\n  solve(0, n-1);\n  printf(\"\\n\");\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> pre, in, pos;\nint p=0;\n\nvoid rec(int l, int r){\n   if(l>=r) return;\n   int root=pre[p++];\n   int m=distance(in.begin(), find(in.begin(), in.end(), root));\n   rec(l, m);\n   rec(m+1, r);\n   pos.push_back(in[m]);\n}\n\nint main(){\n   int n, num;\n   cin >> n;\n   for(int i=0; i<n; i++){\n      cin >> num;\n      pre.push_back(num);\n   }\n   for(int i=0; i<n; i++){\n      cin >> num;\n      in.push_back(num);\n   }\n\n   rec(0, n);\n\n   for(int i=0; i<n; i++){\n      if(i) cout << \" \";\n      cout << pos[i];\n   }\n   cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 100\n\nint n, pre, pos;\nint Preorder[MAX], Inorder[MAX], Postorder[MAX];\n\nint find_parent(int key){\n  for(int i=0; i<n; i++){\n    if(key == Inorder[i]) return i;\n  }\n}\n\nvoid reconstruction(int left, int right){\n  if(left >= right) return;\n  \n  int key=Preorder[pre++];\n  int position=find_parent(key);\n\n  printf(\"%d\\n\", key);\n  \n  reconstruction(left, position);\n  reconstruction(position+1, right);\n  \n  Postorder[pos++]=key;\n}\n\nint main(void){\n  scanf(\"%d\", &n);\n\n  for(int i=0; i<n; i++) scanf(\"%d\", &Preorder[i]);\n  for(int i=0; i<n; i++) scanf(\"%d\", &Inorder[i]);\n\n  reconstruction(0, n);\n\n  for(int i=0; i<n; i++){\n    if(i) printf(\" \");\n    printf(\"%d\", Postorder[i]);\n  }\n\n  printf(\"\\n\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <iterator>\n#include<algorithm>\nstatic const int NIL = -1;\nstatic const int NumberChild = 2;\nclass Tree {\nprivate:\n\tint id;\n\tint parent;\n\tint child[NumberChild];\n\npublic:\n\tTree() {\n\t\tid = child[0] = child[1] = parent = NIL;\n\t}\n\tvoid AddParent(int ID) {\n\t\tparent = ID;\n\t\treturn;\n\t}\n\tvoid AddID(int ID) {\n\t\tid = ID;\n\t\treturn;\n\t}\n\tvoid AddChild(std::vector<int>&Child) {\n\t\tfor (unsigned int i = 0; i < Child.size(); ++i) {\n\t\t\tchild[i] = Child[i];\n\n\t\t}\n\n\t\treturn;\n\t}\n\tint GetRoot(std::vector<Tree> nodes, int ID) {\n\t\tint RootID = ID;\n\t\tif (RootID != NIL&&nodes[RootID].parent != NIL) {\n\t\t\tRootID = GetRoot(nodes, nodes[RootID].parent);\n\t\t}\n\t\treturn RootID;\n\t}\n\tvoid PreorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid InorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid PostorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t\tif(nodes[ID].id!=NIL)std::cout << \" \" << nodes[ID].id;\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid Reconstruct(const std::vector<int>Pre, const std::vector<int>In, std::vector<Tree> &nodes, const int Root,int &cnt) {\n\t\t\n\t\tint m = std::distance(In.begin(), std::find(In.begin(), In.end(), Root));\n\t\n\t\t//nodes[cnt].AddID(Root);\n\t\tnodes[Root].AddID(Root);\n\t\tif (m == 0||Root==NIL) { return; }\n\t\tstd::vector<int>PreLeft;\n\t\n\t\tstd::copy(&Pre[1], &Pre[m]+1, std::back_inserter(PreLeft));\n\t\t\n\t\tstd::vector<int>PreRight;\n\t\t\n\t\tstd::copy(&Pre[m+1 ], &Pre[Pre.size()-1]+1, std::back_inserter(PreRight));\n\t\t\n\t\tstd::vector<int>InLeft;\n\t\tstd::copy(&In[0], &In[m-1]+1, std::back_inserter(InLeft));\n\t\t\n\n\t\tstd::vector<int>InRight;\n\t\tstd::copy(&In[m]+1, &In[In.size() - 1]+1, std::back_inserter(InRight));\n\t\t\n\n\t\tstd::vector<int>child={ PreLeft.empty() ? NIL : PreLeft[0], PreRight.empty() ? NIL : PreRight[0] };\n\t\t//nodes[cnt].AddChild(child);\n\t\tnodes[Root].AddChild(child);\n\t\tfor (unsigned int i = 0; i < child.size(); ++i) {\n\n\t\t\tnodes[child[i]].AddParent(Root);\n\t\t}\n\t\tReconstruct(PreLeft, InLeft, nodes, PreLeft[0], ++cnt);\n\t\tReconstruct(PreRight, InRight, nodes, PreRight[0], ++cnt);\n\t}\n};\n\nvoid SetVector(std::vector<int>&InputVector) {\n\tfor (unsigned int i = 0; i < InputVector.size(); ++i) {\n\t\tstd::cin >> InputVector[i];\n\t}\n\treturn;\n}\nint main(void) {\n\n\tint n;\n\tstd::cin >> n;\n\tstd::vector<int>Pre(n);\n\tstd::vector<int>In(n);\n\tSetVector(Pre);\n\tSetVector(In);\n\tstd::vector<Tree> nodes(n+1);\n\t//ReconstructWithNoParent\n\tint cnt = 0;\n\tnodes[1].Reconstruct(Pre, In, nodes, Pre[0],cnt);\n\n\tnodes[1].PostorderTreeWalk(nodes, 1);\n\tstd::cout << std::endl;\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <iterator>\n#include<algorithm>\nstatic const int NIL = -1;\nstatic const int NumberChild = 2;\nclass Tree {\nprivate:\n\tint id;\n\tint parent;\n\tint child[NumberChild];\n\npublic:\n\tTree() {\n\t\tid = child[0] = child[1] = parent = NIL;\n\t}\n\tvoid AddParent(int ID) {\n\t\tparent = ID;\n\t\treturn;\n\t}\n\tvoid AddID(int ID) {\n\t\tid = ID;\n\t\treturn;\n\t}\n\tvoid AddChild(std::vector<int>&Child) {\n\t\tfor (unsigned int i = 0; i < Child.size(); ++i) {\n\t\t\tchild[i] = Child[i];\n\n\t\t}\n\n\t\treturn;\n\t}\n\tint GetRoot(std::vector<Tree> nodes, int ID) {\n\t\tint RootID = ID;\n\t\tif (RootID != NIL&&nodes[RootID].parent != NIL) {\n\t\t\tRootID = GetRoot(nodes, nodes[RootID].parent);\n\t\t}\n\t\treturn RootID;\n\t}\n\tvoid PreorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid InorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid PostorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t\tif(nodes[ID].id!=NIL)std::cout << \" \" << nodes[ID].id;\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid GetVctorPostorderTreeWalk(std::vector<Tree> nodes, std::vector<int>& returnvector, int ID) {\n\t\t\n\t\tif (ID != NIL) {\n\n\t\t\tGetVctorPostorderTreeWalk(nodes,  returnvector, nodes[ID].child[0]);\n\t\t\tGetVctorPostorderTreeWalk(nodes, returnvector, nodes[ID].child[1]);\n\t\t\tif (nodes[ID].id != NIL)returnvector.push_back(nodes[ID].id) ;\n\t\t}\n\n\t\treturn ;\n\t}\n\tvoid Reconstruct( std::vector<int>Pre,  std::vector<int>In, std::vector<Tree> &nodes, const int Root, int &cnt) {\n\n\t\tunsigned int m = std::distance(In.begin(), std::find(In.begin(), In.end(), Root));\n\n\t\t//nodes[cnt].AddID(Root);\n\t\tif ( Root == NIL) { return; }\n\t\tnodes[Root].AddID(Root);\n\t\tif ( m ==0 ) { return; }\n\t\tstd::vector<int>PreLeft;\n\n\t\tstd::copy(&Pre[1], &Pre[m] + 1, std::back_inserter(PreLeft));\n\n\n\n\n\t\tstd::vector<int>InLeft;\n\t\tstd::vector<int>PreRight;\n\t\tPreRight={NIL};\n\t\tstd::vector<int> InRight;\n\t\tInRight={NIL};\n\t\tstd::copy(&In[0], &In[m-1]+1, std::back_inserter(InLeft));\n\t\t\n\t\tif (m<Pre.size()-1){\n\t\t\tstd::copy(&Pre[m] + 1, &Pre[Pre.size() - 1] + 1, std::back_inserter(PreRight));\n\t\t}\n\t\tif (m<In.size()-1) {\n\t\t\tstd::copy(&In[m] + 1, &In[In.size() - 1] + 1, std::back_inserter(InRight));\n\t\t\t}\n\t\t\n\t\t\n\t\t\n\n\t\tstd::vector<int> child(2);\n\t\tchild[0] =  PreLeft.empty() ? NIL : PreLeft[0] ;\n\t\tchild[1] = PreRight.empty() ? NIL : PreRight[0] ;\n\t\t//nodes[cnt].AddChild(child);\n\t\tnodes[Root].AddChild(child);\n\t\tfor (unsigned int i = 0; i < child.size(); ++i) {\n\n\t\t\tif (child[i] != NIL) { nodes[child[i]].AddParent(Root); }\n\t\t}\n\t\tReconstruct(PreLeft, InLeft, nodes, PreLeft[0], ++cnt);\n\t\tReconstruct(PreRight, InRight, nodes, PreRight[0], ++cnt);\n\t}\n};\n\nvoid SetVector(std::vector<int>&InputVector) {\n\tfor (unsigned int i = 0; i < InputVector.size(); ++i) {\n\t\tstd::cin >> InputVector[i];\n\t}\n\treturn;\n}\nint main(void) {\n\n\tint n;\n\tstd::cin >> n;\n\tstd::vector<int>Pre(n);\n\tstd::vector<int>In(n);\n\tSetVector(Pre);\n\tSetVector(In);\n\tstd::vector<Tree> nodes(n+1);\n\t//ReconstructWithNoParent\n\tint cnt = 0;\n\tnodes[1].Reconstruct(Pre, In, nodes, Pre[0],cnt);\n\n\t//nodes[1].PostorderTreeWalk(nodes, 1);\n\tstd::vector<int>Print;\n\tnodes[1].GetVctorPostorderTreeWalk(nodes, Print, 1);\n//Print=nodes[1].GetVctorPostorderTreeWalk(nodes, 1);\nfor (unsigned int i = 0; i < Print.size(); ++i) {\n\tif (i) { std::cout << \" \"; }\n\tstd::cout<<Print[i];\n\tif(i==Print.size()-1){ std::cout << std::endl; }\n}\n\t\n\t\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define _GLIBCXX_DEBUG\n\nint n;\nvector<int> pre, in, ans;\n\ntemplate <typename Itr> void postorder(Itr ps, Itr pe, Itr is, Itr ie) {\n  if (ps == pe) {\n    ans.push_back(*ps);\n    return;\n  }\n  auto root_pos = find(in.begin(), in.end(), *ps);\n  if (root_pos == is)\n    postorder(ps + 1, pe, is + 1, ie);\n  else if (root_pos == ie)\n    postorder(ps+1, pe, is, ie - 1);\n  else {\n    postorder(ps + 1, ps + distance(is, root_pos), is, root_pos - 1);\n    postorder(ps + distance(is, root_pos) + 1, pe, root_pos + 1, ie);\n  }\n  ans.push_back(*ps);\n}\n\nint main() {\n  cin >> n;\n  pre = vector<int>(n);\n  in = vector<int>(n);\n  for (int i = 0; i < n; i++)\n    cin >> pre[i];\n  for (int i = 0; i < n; i++)\n    cin >> in[i];\n  postorder(pre.begin(), --pre.end(), in.begin(), --in.end());\n  for (int i = 0; i < n; i++)\n    cout << ans[i] << ((i == n - 1) ? \"\" : \" \");\n  cout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nstruct node {\n\tint left;\n\tint right;\n};\n\nint n,ind,nop;\nvector<node> tree;\nvector<int> pre,in;\n\nvoid reconstruct(int left, int right) {\n\tif (ind > n || left == right) {\n\t\treturn;\n\t}\n\tint rind,root = pre[ind];\n\t++ind;\n\tfor (int i = left; i < right; ++i) {\n\t\tif (root == in[i]) {\n\t\t\tif (i > left) {\n\t\t\t\ttree[root].left = pre[ind]; \n\t\t\t}\n\t\t\telse {\n\t\t\t\ttree[root].left = -1;\n\t\t\t}\n\t\t\trind = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treconstruct(left,rind);\n\tif (rind < right-1) {\n\t\ttree[root].right = pre[ind];\n\t\treconstruct(rind+1,right);\n\t}\n\telse {\n\t\ttree[root].right = -1;\n\t}\n\treturn;\n}\n\nvoid postorder_walk(int now) {\n\tif (now < 0) {\n\t\treturn;\n\t}\n\tpostorder_walk(tree[now].left);\n\tpostorder_walk(tree[now].right);\n\tcout << now+1;\n\t++nop;\n\tif (nop < n) {\n\t\tcout << \" \";\n\t}\n\telse {\n\t\tcout << endl;\n\t}\n\treturn;\n}\n\n\nint main(void) {\n\tcin >> n;\n\ttree = vector<node>(n);\n\n\tpre = in = vector<int>(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> pre[i];\n\t\t--pre[i];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> in[i];\n\t\t--in[i];\n\t}\n\n\tind = 0;\n\treconstruct(0,n);\n\tnop = 0;\n\tpostorder_walk(pre[0]);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <iterator>\n#include<algorithm>\nstatic const int NIL = -1;\nstatic const int NumberChild = 2;\nclass Tree {\nprivate:\n\tint id;\n\tint parent;\n\tint child[NumberChild];\n\npublic:\n\tTree() {\n\t\tid = child[0] = child[1] = parent = NIL;\n\t}\n\tvoid AddParent(int ID) {\n\t\tparent = ID;\n\t\treturn;\n\t}\n\tvoid AddID(int ID) {\n\t\tid = ID;\n\t\treturn;\n\t}\n\tvoid AddChild(std::vector<int>&Child) {\n\t\tfor (unsigned int i = 0; i < Child.size(); ++i) {\n\t\t\tchild[i] = Child[i];\n\n\t\t}\n\n\t\treturn;\n\t}\n\tint GetRoot(std::vector<Tree> nodes, int ID) {\n\t\tint RootID = ID;\n\t\tif (RootID != NIL&&nodes[RootID].parent != NIL) {\n\t\t\tRootID = GetRoot(nodes, nodes[RootID].parent);\n\t\t}\n\t\treturn RootID;\n\t}\n\tvoid PreorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid InorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid PostorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t\tif(nodes[ID].id!=NIL)std::cout << \" \" << nodes[ID].id;\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid GetVctorPostorderTreeWalk(std::vector<Tree> nodes, std::vector<int>& returnvector, int ID) {\n\t\t\n\t\tif (ID != NIL) {\n\n\t\t\tGetVctorPostorderTreeWalk(nodes,  returnvector, nodes[ID].child[0]);\n\t\t\tGetVctorPostorderTreeWalk(nodes, returnvector, nodes[ID].child[1]);\n\t\t\tif (nodes[ID].id != NIL)returnvector.push_back(nodes[ID].id) ;\n\t\t}\n\n\t\treturn ;\n\t}\n\tvoid Reconstruct( std::vector<int>Pre,  std::vector<int>In, std::vector<Tree> &nodes, const int Root, int &cnt) {\n\n\t\tunsigned int m = std::distance(In.begin(), std::find(In.begin(), In.end(), Root));\n\n\t\t//nodes[cnt].AddID(Root);\n\t\tif ( Root == NIL) { return; }\n\t\tnodes[Root].AddID(Root);\n\t\tif ( m ==0 ) { return; }\n\t\tstd::vector<int>PreLeft;\n\n\t\tstd::copy(&Pre[1], &Pre[m] + 1, std::back_inserter(PreLeft));\n\n\n\n\n\t\tstd::vector<int>InLeft;\n\t\tstd::vector<int>PreRight;\n\t\tPreRight.push_back(NIL);\n\t\t//PreRight={NIL};\n\t\tstd::vector<int> InRight;\n\t\tInRight.push_back(NIL);\n\t\t//InRight={NIL};\n\t\tstd::copy(&In[0], &In[m-1]+1, std::back_inserter(InLeft));\n\t\t\n\t\tif (m<Pre.size()-1){\n\t\t\tPreRight.pop_back();\n\t\t\tstd::copy(&Pre[m] + 1, &Pre[Pre.size() - 1] + 1, std::back_inserter(PreRight));\n\t\t}\n\t\tif (m<In.size()-1) {\n\t\t\tInRight.pop_back();\n\t\t\tstd::copy(&In[m] + 1, &In[In.size() - 1] + 1, std::back_inserter(InRight));\n\t\t\t}\n\t\t\n\t\t\n\t\t\n\n\t\tstd::vector<int> child(2);\n\t\tchild[0] =  PreLeft.empty() ? NIL : PreLeft[0] ;\n\t\tchild[1] = PreRight.empty() ? NIL : PreRight[0] ;\n\t\t//nodes[cnt].AddChild(child);\n\t\tnodes[Root].AddChild(child);\n\t\tfor (unsigned int i = 0; i < child.size(); ++i) {\n\n\t\t\tif (child[i] != NIL) { nodes[child[i]].AddParent(Root); }\n\t\t}\n\t\tReconstruct(PreLeft, InLeft, nodes, PreLeft[0], ++cnt);\n\t\tReconstruct(PreRight, InRight, nodes, PreRight[0], ++cnt);\n\t}\n};\n\nvoid SetVector(std::vector<int>&InputVector) {\n\tfor (unsigned int i = 0; i < InputVector.size(); ++i) {\n\t\tstd::cin >> InputVector[i];\n\t}\n\treturn;\n}\nint main(void) {\n\n\tint n;\n\tstd::cin >> n;\n\tstd::vector<int>Pre(n);\n\tstd::vector<int>In(n);\n\tSetVector(Pre);\n\tSetVector(In);\n\tstd::vector<Tree> nodes(n+1);\n\t//ReconstructWithNoParent\n\tint cnt = 0;\n\tnodes[1].Reconstruct(Pre, In, nodes, Pre[0],cnt);\n\n\t//nodes[1].PostorderTreeWalk(nodes, 1);\n\tstd::vector<int>Print;\n\tnodes[1].GetVctorPostorderTreeWalk(nodes, Print, 1);\n//Print=nodes[1].GetVctorPostorderTreeWalk(nodes, 1);\nfor (unsigned int i = 0; i < Print.size(); ++i) {\n\tif (i) { std::cout << \" \"; }\n\tstd::cout<<Print[i];\n\tif(i==Print.size()-1){ std::cout << std::endl; }\n}\n\t\n\t\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @file main.cpp\n * @author Kentaro Sugimoto (tarotene@gmail.com)\n * @brief Input a pre-order traversal array and a in-order traversal array and output the post-order array by reconstructing the corresponding binary tree.\n * @version 0.1\n * @date 2019-03-24\n * \n * @copyright Copyright (c) 2019\n * \n */\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid reconstruct(int, int, vector<int> &, vector<int> &, map<int, int> &, vector<int> &);\n\nint main(int argc, char const *argv[])\n{\n    int n = 0;\n    cin >> n;\n\n    vector<int> a_pre(n, 0), a_in(n, 0);\n    map<int, int> b_pre, b_in;\n    for (int i = 0; i < n; ++i)\n    {\n        cin >> a_pre[i];\n        b_pre[a_pre[i]] = i;\n    }\n    for (int i = 0; i < n; ++i)\n    {\n        cin >> a_in[i];\n        b_in[a_in[i]] = i;\n    }\n\n    vector<int> a_post;\n    reconstruct(0, n, a_pre, a_in, b_in, a_post);\n\n    for (int i = 0; i < n - 1; ++i) {\n        cout << a_post[i] << \" \";\n    }\n    cout << a_post[n - 1] << endl;\n\n    return 0;\n}\n\nint pos = 0;\n\n// [lb, rb)\nvoid reconstruct(int lb, int rb, vector<int> &a_pre, vector<int> &a_in, map<int, int> &b_in, vector<int> &a_post)\n{\n    if (lb >= rb)\n    {\n        return;\n    }\n    else\n    {\n        int sub_root = a_pre[pos++];\n        reconstruct(lb, b_in[sub_root], a_pre, a_in, b_in, a_post);\n        reconstruct(b_in[sub_root] + 1, rb, a_pre, a_in, b_in, a_post);\n        a_post.push_back(sub_root);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nstruct node{\n    int l,r;\n};\nnode v[41];\nvector<int> postord;\nvoid dfs(int vi){\n    if(v[vi].l!=0)dfs(v[vi].l);\n    if(v[vi].r!=0)dfs(v[vi].r);\n    postord.pb(vi);\n}\nint pre[41],in[41];\nint main(){\n    int n,root;\n    cin>>n;\n    rep(i,n) cin>>pre[i];\n    rep(i,n) cin>>in[i];\n    root=pre[0];\n    int cp=0,ci=0;\n    while(cp<n-1){\n        v[pre[cp]].l=pre[cp+1];++cp;\n        while(cp<n&&pre[cp]==in[ci]){\n            ++ci;\n            v[in[ci]].r=in[ci+1];++ci;\n            ++cp;\n        } \n    }\n    dfs(root);\n    rep(i,n) cout<<postord[i]<<(i==n-1?\"\":\" \");\n    cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r) {\n  if (l>=r) {\n    return;\n  }\n  int root=pre[pos++];\n  int m=distance(in.begin(),find(in.begin(),in.end(),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\nvoid solve() {\n  pos=0;\n  rec(0,n);\n  for (int i=0; i<n; i++) {\n    if (i) {\n      cout<<\" \"<<flush;\n    }\n    cout<<post[i]<<flush;\n  }\n  cout<<endl;\n}\nint main() {\n  cin>>n;\n  int k;\n  for (int i=0; i<n; i++) {\n    cin>>k;\n    pre.push_back(k);\n  }\n  for (int i=0; i<n; i++) {\n    cin>>k;\n    in.push_back(k);\n  }\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nusing namespace std;\n\nint j=0,k=0;\nvector<int> in,pre;\n\nint search(int n)\n{\n\tint i=0;\n\twhile(in[i]!=n)\n\t{\n\t\ti++;\n\t}\n\treturn i;\n}\n\nvoid rec(int l,int r)\n{\n\tint c,m;\n\t\n\tif(l>r) return;\n\tc=pre[j];\n\tj++;\n\tif(l==r)\n\t{\n\t\tif(++k>1) printf(\" \");\n\t\tprintf(\"%d\",in[l]);\n\t\treturn;\n\t}\n\tm=search(c);\n\trec(l,m-1);\n\trec(m+1,r);\n\tif(++k>1) printf(\" \");\n\tprintf(\"%d\",in[m]);\n\treturn;\n}\n\nint main()\n{\n\tint i,n,temp;\n\t\n\tcin >> n;\n\t\n\tfor(i=0;i<=n-1;i++)\n\t{\n\t\tcin >> temp;\n\t\tpre.push_back(temp);\n\t}\n\tfor(i=0;i<=n-1;i++)\n\t{\n\t\tcin >> temp;\n\t\tin.push_back(temp);\n\t}\n\trec(0,n-1);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define N 42\nint n;\nint a[N];\nint b[N];\nint c[N];\nint ai = 1;\nint ci = 1;\nvoid rebuild(int left, int right){\n    if(left == right) {\n//        printf(\"%d \", b[left]);\n        c[ci++] = b[left];\n        return ;\n    }\n    int ax = a[ai++];\n    int m = 1;\n    for(int i = 1; i <= n; i++){\n        if(b[i] == ax) m = i;\n    }\n    if(m - 1 >= left) rebuild(left, m-1);\n    if(m + 1 <= right) rebuild(m+1, right);\n//    printf(\"%d \", ax);\n    c[ci++] = ax;\n}\nint main(){\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    for(int i = 1; i <= n; i++) scanf(\"%d\", &b[i]);\n    rebuild(1, n);\n    for(int i = 1; i <= n; i++){\n        if(i == n) printf(\"%d\\n\", c[i]);\n        else printf(\"%d \", c[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r){\n  if(l>=r)return;\n  int root=pre[pos++];\n  int m=distance(in.begin(),find(in.begin(),in.end(),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\n\nvoid solve(){\n  pos=0;\n  rec(0,pre.size());\n  for(int i=0;i<n;i++){\n    if(i)cout<<\" \";\n    cout<< post[i];\n  }\n  cout<<endl;\n}\n\nint main(){\n  int op;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>op;\n    pre.push_back(op);\n  }\n  for(int i=0;i<n;i++){\n    cin>>op;\n    in.push_back(op);\n  }\n\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nusing namespace std;\n\n#define MAX 10000\n#define NIL -1\n\nstruct Node { int parent, left, right;};\n\nNode T[MAX];\nint n, D[MAX], H[MAX];\n\nvoid setDepth(int u,int d) {\n\tif(u == NIL) return;\n\tD[u] = d;\n\tsetDepth(T[u].left, d+1);\n\tsetDepth(T[u].right,d+1);\n}\n\nint setHeight(int u) {\n\tint h1 = 0, h2 = 0;\n\tif(T[u].left != NIL)\n\t\th1 = setHeight(T[u].left)  + 1;\n\tif(T[u].right != NIL)\n\t\th2 = setHeight(T[u].right) + 1;\n\treturn H[u] = (h1 > h2 ? h1 : h2);\n}\n\n// 接点 u の兄弟を返す\nint getSibling(int u) {\n\tif( T[u].parent == NIL ) return NIL;\n\tif(T[T[u].parent].left != u && T[T[u].parent].left != NIL )\n\t\treturn T[T[u].parent].left;\n\tif(T[T[u].parent].right != u && T[T[u].parent].right != NIL )\n\t\treturn T[T[u].parent].right;\n\treturn NIL;\n}\n\nvoid print(int u) {\n\tprintf(\"node %d: \",u);\n\tprintf(\"parent = %d, \",T[u].parent);\n\tprintf(\"sibling = %d, \",getSibling(u));\n\tint deg = 0;\n\tif(T[u].left  != NIL) deg++;\n\tif(T[u].right != NIL) deg++;\n\tprintf(\"degree = %d, \",deg);\n\tprintf(\"depth = %d, \",D[u]);\n\tprintf(\"height = %d, \",H[u]);\n\t\n\tif(T[u].parent == NIL) {\n\t\tprintf(\"root\\n\");\n\t} else if(T[u].left == NIL && T[u].right == NIL) {\n\t\tprintf(\"leaf\\n\");\n\t} else {\n\t\tprintf(\"internal node\\n\");\n\t}\n}\n\nint main(void) {\n\tint v, l, r, root = 0;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) T[i].parent = NIL;\n\tfor(int i=0;i<n;i++) {\n\t\tscanf(\"%d %d %d\",&v,&l,&r);\n\t\tT[v].left  = l;\n\t\tT[v].right = r;\n\t\tif(l != NIL) T[l].parent = v;\n\t\tif(r != NIL) T[r].parent = v;\n\t}\n\t\n\tfor(int i=0; i<n; i++)\n\tif(T[i].parent == NIL) root = i;\n\t\n\tsetDepth(root,0);\n\tsetHeight(root);\n\t\n\tfor(int i=0;i<n;i++) print(i);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> pre,in,post;\nint root,pos=0;\n\nvoid rec(int left,int right){\n\tif(left>=right) return ;\n\tint root=pre[pos++];\n\tint m=distance(in.begin(), find(in.begin(), in.end(),root));\n\trec(left,m);\n\trec(m+1,right);\n\tpost.push_back(root);\n\treturn ;\n}\n\nvoid solve(int n){\n\trec(0,n);\n\tfor(int i=0;i<n;i++) {\n\t\tif(i) cout<<\" \"<<post[i];\n\t\telse cout<<post[i];\n\t}\n\tcout<<endl;\n\treturn ;\n}\n\nint main (){\n\tint n;\n\tcin>>n;\n\tint a;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a;\n\t\tpre.push_back(a);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a;\n\t\tin.push_back(a);\n\t}\n\tsolve(n);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <cstdio>\n\nusing namespace std;\n\nstruct Node {\n\tint left;\n\tint right;\n};\n\nNode T[100];\nint PreOrder[100], InOrder[100];\nint NumOfNode;\n\n\n\nvoid printPost(int node) {\n\tif (node == -1) {\n\t\t;\n\t}\n\telse {\n\t\tprintPost(T[node].left);\n\t\tprintPost(T[node].right);\n\t\tif (NumOfNode-- != 1) {\n\t\t\tprintf(\"%d \", node);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%d\\n\", node);\n\t\t}\n\t}\n}\n\n\n\nvoid makeTree(int PreBegin, int PreEnd, int InBegin, int InEnd) {\n\tint root = PreOrder[PreBegin];\n\tint PreLeftSubtreeBegin, PreLeftSubtreeEnd, PreRightSubtreeBegin, PreRightSubtreeEnd, InLeftSubtreeBegin, InLeftSubtreeEnd, InRightSubtreeBegin, InRightSubtreeEnd;\n\tfor (int i = InBegin; i <= InEnd; ++i) {\n\t\tif (InOrder[i] == root) {\n\t\t\tPreLeftSubtreeBegin = PreBegin + 1;\n\t\t\tPreLeftSubtreeEnd = PreBegin + i - InBegin;\n\t\t\tPreRightSubtreeBegin = PreLeftSubtreeEnd + 1;\n\t\t\tPreRightSubtreeEnd = PreEnd;\n\t\t\tInLeftSubtreeBegin = InBegin;\n\t\t\tInLeftSubtreeEnd = i - 1;\n\t\t\tInRightSubtreeBegin = i + 1;\n\t\t\tInRightSubtreeEnd = InEnd;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (PreLeftSubtreeBegin > PreLeftSubtreeEnd) {\n\t\t//the left subtree is empty\n\t\tT[root].left = -1;\n\t}\n\telse {\n\t\t//the left subtree is not empty\n\t\tT[root].left = PreOrder[PreLeftSubtreeBegin];\n\t\tmakeTree(PreLeftSubtreeBegin, PreLeftSubtreeEnd, InLeftSubtreeBegin, InLeftSubtreeEnd);\n\t}\n\n\tif (PreRightSubtreeBegin > PreRightSubtreeEnd) {\n\t\t//the right subtree is empty\n\t\tT[root].right = -1;\n\t}\n\telse {\n\t\t//the right subtree is not empty\n\t\tT[root].right = PreOrder[PreRightSubtreeBegin];\n\t\tmakeTree(PreRightSubtreeBegin, PreRightSubtreeEnd, InRightSubtreeBegin, InRightSubtreeEnd);\n\t}\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tNumOfNode = n;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &PreOrder[i]);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &InOrder[i]);\n\t}\n\n\tmakeTree(0, n - 1, 0, n - 1);\n\tprintPost(PreOrder[0]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n \nint n, pos;\nvector<int> pre, in, post;\n \nvoid rec(int l, int r) \n{\n    if (l == r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m + 1, r);\n    post.push_back(root);\n}\n \nvoid solve()\n{\n    pos = 0;\n    rec(0, pre.size());\n    for (int i = 0; i < n; i++)\n    {\n        if (i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n \nint main()\n{\n    int key;\n    cin >> n;\n\n    for (int i = 0; i < n; i++) \n    {\n        cin >> key;\n        pre.push_back(key);\n    }\n \n    for (int i = 0; i < n; i++) \n    {\n        cin >> key;\n        in.push_back(key);\n    }\n \n    solve();\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nconst int N = 100;\nint pos;\nint In[N], Pre[N];\n\nvoid construct_tree(int left, int right) {\n  if (left < right) {\n    int i, root = Pre[pos++];\n    for (i = left; i < right; i++) {\n      if (In[i] == root) break;\n    }\n    // left subtree\n    construct_tree(left, i);\n    // right subtree\n    construct_tree(i+1, right);\n    // print nodes in postorder\n    cout << \" \" << root;\n  }\n}\n\nint main() {\n  int i, n;\n\n  cin >> n;\n  // input\n  for (i = 0; i < n; i++) cin >> Pre[i];\n  for (i = 0; i < n; i++) cin >> In[i];\n\n  pos = 0;\n  // output\n  construct_tree(0, n);\n  cout << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Problem Description: Reconstruction of a Tree\n * Category: Tree\n * Author: Khan\n * Date: 23th October, 2017\n */\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r)\n{\n    if(l >= r)\n        return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m + 1, r);\n    post.push_back(root);\n}\n\nint main(int argc, char const *argv[])\n{\n    //freopen(\"sample.txt\", \"r\", stdin);\n    int k;\n    cin >> n;\n    for (int i = 0; i < n; ++i)\n    {\n        cin >> k;\n        pre.push_back(k);\n    }\n\n    for (int i = 0; i < n; ++i)\n    {\n        cin >> k;\n        in.push_back(k);\n    }\n\n    pos = 0;\n    rec(0, pre.size());\n    for (int i = 0; i < n; ++i)\n    {\n        if(i)\n            cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint c = 1;\n\nvoid solve(int A[], int B[], int p, int q, int n) {\n    int r = 0;\n    for(int i = 0; i < n; i++) {\n        if(B[q + i] == A[p]) {r = i; break;}\n    }\n    if(r > 0) {\n        solve(A, B, p + 1, q, r);\n    }\n    if(r + 1 < n) {\n        solve(A, B, p + r + 1, q + r + 1, n - 1- r);\n    }\n    if(c != 0) c--;\n    else cout << \" \";\n    cout <<  A[p];\n}\n\n\n\nint main() {\n    int n;\n    cin >> n;\n\n    int A[n], B[n];\n    for(int i = 0; i < n; i++) cin >> A[i];\n    for(int i = 0; i < n; i++) cin >> B[i];\n\n    solve(A, B, 0, 0, n);\n\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nvector<int> pre, in, post;\nint pos;\n\nvoid reconstruction(int l, int r)\n{\n\tif (l >= r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\n\treconstruction(l, m);\n\treconstruction(m + 1, r);\n\n\tpost.push_back(root);\n}\n\nint main()\n{\n\tint n, x;\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &x);\n\t\tpre.push_back(x);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &x);\n\t\tin.push_back(x);\n\t}\n\tpos = 0;\n\treconstruction(0, n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i) printf(\" \");\n\t\tprintf(\"%d\", post[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l,int r){\n\tif(l >= r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l,m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\nvoid solve(){\n\tpos = 0;\n\trec(0, pre.size());\n\tfor(int i = 0; i < n; i++){\n\t\tif(i)cout << \" \";\n\t\tcout << post[i];\n\t}\n\t\n\tcout << endl;\n}\n\n\nint main(){\n\tint k;\n\tcin >> n;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\t\n\tfor(int i=0; i<n; i++){\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\t\n\tsolve();\n\t\n\treturn 0;\n}\n\n\n\n\n\t\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nint N;\nint count;\nstd::vector<int> answer;\nint find(int* inorder, int c)\n{\n    for (int i = 0; i < N; i++) {\n\tif (inorder[i] == c) {\n\t    return i;\n\t}\n    }\n    return 0;\n}\nvoid rec(int* preorder, int* inorder, int l, int r)\n{\n    if (l >= r) {\n\treturn;\n    }\n    int c = preorder[count++];\n    int m = find(inorder, c);\n    rec(preorder, inorder, l, m);\n    rec(preorder, inorder, m + 1, r);\n    answer.push_back(c);\n}\nint main()\n{\n    std::cin >> N;\n    int* preorder = (int*)malloc(N * sizeof(int));\n    int* inorder = (int*)malloc(N * sizeof(int));\n    count = 0;\n    for (int i = 0; i < N; i++) {\n\tstd::cin >> preorder[i];\n    }\n    for (int i = 0; i < N; i++) {\n\tstd::cin >> inorder[i];\n    }\n    rec(preorder, inorder, 0, N);\n    for (int i = 0; i < N; i++) {\n\tstd::cout << answer[i];\n\tif (i + 1 < N) {\n\t    std::cout << \" \";\n\t}\n    }\n    std::cout << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <map>\n#include <memory>\n#include <set>\n#include <vector>\n#include <deque>\n#include <list>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\nclass ReconTree\n{\npublic:\n  int solve();\n  void check(int& x, int l, int r, vector<int>& pre, vector<int>& in, vector<int>& po);\n};\n\nint ReconTree::solve()\n{\n  int n;\n  cin >> n;\n\n  vector<int> preo(n);\n  vector<int> ino(n);\n  vector<int> poo;\n\n  for ( int i = 0; i < n; ++i )\n    cin >> preo[i];\n  \n  for ( int i = 0; i < n; ++i )\n    cin >> ino[i];\n  \n  int x = 0;\n  check( x, 0, n, preo, ino, poo );\n\n  for ( auto i = 0; i < n; ++i )\n    {\n      if ( i ) cout << \" \";\n      cout << poo[i];\n    }\n  cout << endl;\n\n  return 0;\n}\n\nvoid ReconTree::check(int& x, int l, int r, vector<int>& pre, vector<int>& in, vector<int>& po)\n{\n  if ( l >= r ) return;\n  \n  int s = 0;\n  \n  for ( auto i = l; i < r; ++i )\n    {\n      if ( pre[x] == in[i] )\n        {\n          s = i;\n          break;\n        }\n    }\n  \n  ++x;\n  \n  check(x, l, s, pre, in, po);\n  check(x, s+1, r, pre, in, po);\n  po.push_back(in[s]);\n  return;\n}\n\nint main()\n{\n\n  ReconTree rt;\n\n  rt.solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, ino, post;\n\nvoid rec(int l, int r) {\n    if (l>=r) return;\n    int root = pre[pos++];\n    int m = distance(ino.begin(), find(ino.begin(), ino.end(), root));\n    rec(1, m);\n    rec(m+1, r);\n    post.push_back(root);\n}\n\nvoid solve() {\n    pos = 0;\n    rec(0, pre.size());\n    for (int i=0; i<n; i++) {\n        if(i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main() {\n    int k;\n    cin >> n;\n    \n    for (int i=0; i<n; i++) {\n        cin >> k;\n        pre.push_back(k);\n    }\n    \n    for (int i=0; i<n; i++) {\n        cin >> k;\n        ino.push_back(k);\n    }\n    \n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 40;\n\nint N;\nint POS = 0;\n\nvector<int> PRE;\nvector<int> IN;\nvector<int> POST;\n\nvoid restore(int l, int r) {\n  if (l >= r) return;\n  int root = PRE[POS++];\n  int m = distance(IN.begin(), find(IN.begin(), IN.end(), root));\n  restore(l, m);\n  restore(m+1, r);\n  POST.push_back(root);\n}\n\nvoid solve() {\n  restore(0, N);\n}\n\nint main() {\n  int t; cin >> N;\n  for (int i = 0; i < N; i++) {\n    cin >> t;\n    PRE.push_back(t);\n  }\n\n  for (int i = 0; i < N; i++) {\n    cin >> t;\n    IN.push_back(t);\n  }\n\n  solve();\n  for (int i = 0; i < N; i++) {\n    if (i) cout << ' ';\n    cout << POST[i];\n  }\n  cout << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, pCount;\nvoid repair(int *preList, int *inList)\n{\n    if (!preList[0]) return;\n    \n    int preL[40] = {0}, preR[40] = {0};\n    int inL[40] = {0}, inR[40] = {0};\n    \n    int i;\n    for (i = 0; inList[i] != preList[0]; i++){\n        inL[i] = inList[i];\n    }\n    for (int j = i + 1; inList[j] != 0; j++){\n        inR[j - (i + 1)] = inList[j];\n    }\n    int lcnt = 0, rcnt = 0;\n    for (i = 1; preList[i] != 0; i++){\n        bool found = false;\n        for (int j = 0; inL[j] != 0; j++){\n            if (preList[i] == inL[j]){\n                preL[lcnt++] = preList[i];\n                found = true;\n            }\n        }\n        if (!found) preR[rcnt++] = preList[i];\n    }\n    \n    repair(preL, inL);\n    repair(preR, inR);\n    printf(\"%d%c\", preList[0], \" \\n\"[++pCount == n]);\n}\n\nint main()\n{\n    int preList[41] = {0}, inList[41] = {0};\n    \n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++){\n        scanf(\"%d\", preList + i);\n    }\n    for (int i = 0; i < n; i++){\n        scanf(\"%d\", inList + i);\n    }\n    \n    repair(preList, inList);\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<stdlib.h>\n\nint *P, *L, *R;\nbool output;\n\nvoid maketree(int* A, int* B, int h)\n{\n    int x, m;\n    x = A[0];\n    if(h == 1){\n        L[x] = 0; R[x] = 0; return;\n    }else{\n        m = 0;\n        while(B[m] != A[0]) m++;\n        m++;\n        if(m == 1){\n            L[x] = 0; R[x] = A[1]; P[A[1]] = x;\n            maketree(A + 1, B + 1, h - 1);\n        }else if(m == h){\n            L[x] = A[1]; P[A[1]] = x; R[x] = 0;\n            maketree(A + 1, B, h - 1);\n        }else{\n            L[x] = A[1]; P[A[1]] = x; R[x] = A[m]; P[A[m]] = x;\n            maketree(A + 1, B, m - 1);\n            maketree(A + m, B + m, h - m);\n        }\n    }\n}\n\nvoid postorder(int i)\n{\n    if(i == 0) return;\n    postorder(L[i]);\n    postorder(R[i]);\n    if(output) cout << \" \";\n    cout << i;\n    output = true;\n}\n\nint main()\n{\n    int i, n;\n    cin >> n;\n    P = new int [n + 1]; L = new int [n + 1]; R = new int [n + 1];\n    if(P == NULL || L == NULL || R == NULL) exit(EXIT_FAILURE);\n\n    int *A, *B;\n    A = new int [n + 1]; B = new int [n + 1];\n    if(A == NULL || B == NULL) exit(EXIT_FAILURE);\n\n    for(i = 1; i <= n; i++){ cin >> A[i]; P[i] = L[i] = R[i] = 0; }\n    for(i = 1; i <= n; i++){ cin >> B[i]; }\n\n    maketree(A + 1, B + 1, n);\n    delete [] A; delete [] B;\n\n    // where is root?\n    i = 1; while(P[i] > 0) i++;\n\n    output = false;\n    postorder(i);\n    cout << endl;\n\n    delete [] P; delete [] L; delete [] R;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_7_D\n// Tree - Reconstruction of a Tree\n// TODO: review\n\n#define SUBMIT\n\n#include <utility>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <limits>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <cmath>\n#include <cstring>\n#include <climits>\n\nusing namespace std;\nusing ui64 = unsigned long long;\nusing i64 = long long;\n\nconst int NIL = -1;\nconst int MAX_T = 40;\n\nint n;\nint pos;\nvector<int> pre;\nvector<int> in;\nvector<int> post;\n\nvoid reconstruct(int left, int right) {\n    if (left >= right) return;\n    int root = pre[pos];\n    pos++;\n\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    reconstruct(left, m);\n    reconstruct(m + 1, right);\n    post.push_back(root);\n}\n\nvoid solve() {\n    pos = 0;\n    reconstruct(0, pre.size());\n    for (int i = 0; i < n; ++i) {\n        cout << post[i];\n\n        if (i != n - 1) cout << \" \";\n        else cout << endl;\n    }\n}\n\n\nint main() {\n#ifdef SUBMIT\n    cin >> n;\n    pre.resize(n);\n    in.resize(n);\n    for (int i = 0; i < n; ++i) cin >> pre[i];\n    for (int i = 0; i < n; ++i) cin >> in[i];\n#else\n    n = 5;\n    pre = {1, 2, 3, 4, 5};\n    in = {3, 2, 4, 1, 5};\n#endif\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n\tif (l >= r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\nvoid solve() {\n\tpos = 0;\n\trec(0, pre.size());\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i) cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\n\n\nint main() {\n\tint k;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid reconstruction(int l, int r)\n{\n  if (l >= r)\n    return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  reconstruction(l, m);\n  reconstruction(m + 1, r);\n  post.push_back(root);\n}\n\nvoid solve()\n{\n  pos = 0;\n  reconstruction(0, n);\n  for (int i = 0; i < n - 1; i++)\n    printf(\"%d \", post[i]);\n  printf(\"%d\\n\", post[n - 1]);\n}\n\nint main()\n{\n  int tmp;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++)\n  {\n    scanf(\"%d\", &tmp);\n    pre.push_back(tmp);\n  }\n  for (int i = 0; i < n; i++)\n  {\n    scanf(\"%d\", &tmp);\n    in.push_back(tmp);\n  }\n\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n//#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\n//typedef pair<ll, ll> P;\n//const double INF = 1e10;\n//const ll INF = LONG_LONG_MAX / 10;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\nconst int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n\nbool contain(set<char> &s, int a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\n\ntypedef pair<int, int> P;\n\nvoid print_line(vector<int> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\n\ntypedef priority_queue<long long, vector<long long>, greater<long long> > PQ_ASK;\nconst int mod = 1000000007;\n\n\nint rec(int l, int r, int pos, vector<int> &preorders, vector<int> &inorders, vector<int> &postorders) {\n    if (l >= r) return pos;\n    int root = preorders[pos];\n    pos++;\n    int m = distance(inorders.begin(), find(inorders.begin(), inorders.end(), root));\n    pos = rec(l, m, pos, preorders, inorders, postorders);\n    pos = rec(m + 1, r, pos, preorders, inorders, postorders);\n\n    postorders.push_back(root);\n    return pos;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> preorders(n);\n    vector<int> inorders(n);\n    vector<int> postorders;\n    rep(i, n) cin >> preorders[i];\n    rep(i, n) cin >> inorders[i];\n\n    rec(0, n, 0, preorders, inorders, postorders);\n\n    print_line(postorders);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n    if (l>=r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m+1, r);\n    post.push_back(root);\n}\n\nvoid solve() {\n    pos = 0;\n    rec(0, pre.size());\n    for (int i=0; i<n; i++) {\n        if(i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main() {\n    int k;\n    cin >> n;\n    \n    for (int i=0; i<n; i++) {\n        cin >> k;\n        pre.push_back(k);\n    }\n    \n    for (int i=0; i<n; i++) {\n        cin >> k;\n        in.push_back(k);\n    }\n    \n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nvoid re(int ,int);\nint pre[100],in[100],n,pos;\nint main(){\n  int i,root;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)scanf(\"%d\",&pre[i]);\n  for(i=0;i<n;i++)scanf(\"%d\",&in[i]);\n  re(0,n);\n  printf(\"\\n\");\n  return 0;\n}\n\nvoid re(int l,int r){\n  int m,c,i;\n  if(l>=r)return;\n  c=pre[pos++];\n  for(i=0;i<n;i++){\n    if(c==in[i]){\n      m=i;\n    }\n  }\n  re(l,m);\n  re(m+1,r);\n  printf(\"%d \",c);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Node {\n  int id;\n  int parent;\n  int left;\n  int right;\n\n  Node() : id(), parent(-1), left(-1), right(-1) {}\n  };\n\nstatic vector<Node> TREE(25);\n\nstatic void inputNode(Node& node, int id) {\n  node.id = id;\n  cin >> node.left >> node.right;\n}\n\nstatic vector<int> preorder(25), inorder(25);\n\nstatic void inputOrder(vector<int>& order, int num) {\n  for (int i = 0; i < num; i++) {\n    cin >> order[i];\n  }\n}\n\nstatic int current = 0, outIndex = 0;\n\nstatic int next() {\n  int c = preorder[current];\n  current++;\n  return c;\n}\n\nstatic int find(int c) {\n  auto it = find(inorder.begin(), inorder.end(), c); \n  return distance(inorder.begin(), it);\n}\n\nstatic void reconstruction(int l, int r) {\n  if (l >= r) {\n    return;\n  } \n  int c = next();\n  int m = find(c);\n  reconstruction(l, m);\n  reconstruction(m + 1, r);\n\n  if (outIndex != 0) {\n    cout << \" \" << c;\n  } else {\n    cout << c;\n  }\n  outIndex++;\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  inputOrder(preorder, n);\n  inputOrder(inorder, n);\n  reconstruction(0, n);\n\n  cout << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nint ret[25];\nint map[25];\nint count2 = 0;\n\nstruct treenode{\n\tint data;\n\ttreenode* leftchild;\n\ttreenode* rightchild;\n\ttreenode(int v) {\n\t\tdata = v;\n\t\tleftchild = NULL;\n\t\trightchild = NULL;\n\t}\n};\n\nvoid remap(int inorder[],int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tmap[inorder[i]] = i;\n\t}\n}\n\ntreenode* bip(int pre[], int n, int offset) {\n\tif (n == 0) return NULL;\n\tint rootval = pre[0];\n\tint i = map[rootval] - offset;\n\ttreenode* root =new treenode(rootval);\n\troot->leftchild = bip(pre + 1, i, offset);\n\troot->rightchild = bip(pre + i + 1, n - i - 1, offset + i + 1);\n\treturn root;\n}\n\nvoid lastorder(treenode* ptr) {\n\tif (ptr) {\n\t\tlastorder(ptr->leftchild);\n\t\tlastorder(ptr->rightchild);\n\t\tret[count2++] = ptr->data  ;\n\t}\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tint* pre = new int(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> pre[i];\n\t}\n\tint* inorder = new int(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> inorder[i];\n\t}\n\tremap(inorder, n);\n\ttreenode* root;\n\troot = bip(pre, n, 0);\n\tlastorder(root);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i) cout << \" \";\n\t\tcout << ret[i];\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\nusing namespace std;\nstatic const int MAX = 41;\nint measure[MAX];\nstruct node {\n  node *left;\n  node *right;\n  int key;\n};\n\nnode *root = NULL;\n\nvoid insert(int key) {\n  node *nd = (node *)malloc(sizeof(node));\n  nd->key = key;\n  nd->left = NULL;\n  nd->right = NULL;\n\n  if (root == NULL) {\n    root = nd;\n    return;\n  }\n\n  node *x = root;\n  while (1) {\n    if (measure[x->key] < measure[nd->key]) {\n      if (x->right == NULL) {\n        x->right = nd;\n        break;\n      } else {\n        x = x->right;\n      }\n    } else {\n      if (x->left == NULL) {\n        x->left = nd;\n        break;\n      } else {\n        x = x->left;\n      }\n    }\n  }\n}\n\nint buf[MAX];\nint bufp =0;\nvoid walk(node *n) {\n  if (!n)\n    return;\n  walk(n->left);\n  walk(n->right);\n  buf[bufp++] = n->key;\n}\n\nint main() {\n  int keys[MAX];\n  int n, idx;\n  cin >> n;\n\n  for (int i = 0; i < n; i++) {\n    cin >> keys[i];\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> idx;\n    measure[idx] = i;\n  }\n\n  for (int i = 0; i < n; i++) {\n    insert(keys[i]);\n  }\n\n  walk(root);\n  cout << buf[0];\n  for (int i=1; i<n; i++) {\n    cout << \" \" << buf[i];\n  }\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\nint n;\nint p[40];\nint q[40];\nint l[41];\nint r[41];\nint k;\nvector<int> v;\n\nint dfs(int a, int b){\n\tif(a == b){\n\t\treturn 0;\n\t}\n\tint s = p[k++];\n\t// printf(\"%d [%d, %d)\\n\", s, a, b);\n\tfor(int i = a; i < b; ++i){\n\t\tif(q[i] == s){\n\t\t\tl[s] = dfs(a, i);\n\t\t\tr[s] = dfs(i + 1, b);\n\t\t\treturn s;\n\t\t}\n\t}\n}\n\nvoid reconstruct(int x){\n\tif(x == 0){\n\t\treturn;\n\t}\n\treconstruct(l[x]);\n\treconstruct(r[x]);\n\tv.push_back(x);\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\trep(i, n){\n\t\tscanf(\"%d\", &p[i]);\n\t}\n\trep(i, n){\n\t\tscanf(\"%d\", &q[i]);\n\t}\n\n\tint r = dfs(0, n);\n\treconstruct(r);\n\n\trep(i, v.size()){\n\t\tif(i != 0){\n\t\t\tputchar(' ');\n\t\t}\n\t\tprintf(\"%d\", v[i]);\n\t}\n\tputchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n\tif (l >= r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\nvoid solve() {\n\tpos = 0;\n\trec(0, n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (i) cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tcin >> n;\n\tint k;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <sstream>\n#include <string.h>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <deque>\n#include <limits>\n#include <iomanip>\n#include <ctype.h>\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <math.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, char> pic;\n#define bit(x,v) ((ll)x << v)\n\nconst ll INF = 1000000007;\nconst int MAX = 210000;\nconst int MOD = 1000000007;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit() {\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n}\n\n// 二項係数計算\nlong long COM(int n, int k) {\n\tif (n < k) return 0;\n\tif (n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\nint pr[100010];\nvoid uini(int n) {\n\tfor (size_t i = 0; i <= n; i++)\n\t{\n\t\tpr[i] = i;\n\t}\n}\n\nint parent(int x) {\n\tif (x == pr[x]) return x;\n\treturn pr[x] = parent(pr[x]);\n}\n\nbool unit(int x, int y) {\n\tint px = parent(x);\n\tint py = parent(y);\n\n\tif (px == py) return false;\n\tif (px < py) {\n\t\tpr[py] = px;\n\t}\n\telse {\n\t\tpr[px] = py;\n\t}\n\treturn true;\n}\n\nll bit[200010];\nint max_n = 200000;\nint pm = 0;\nvoid add(int x) {\n\n\twhile (max_n >= x)\n\t{\n\t\tbit[x]++;\n\t\tx += x & -x;\n\t}\n}\nvoid sub(int x) {\n\twhile (max_n >= x)\n\t{\n\t\tbit[x]--;\n\t\tx += x & -x;\n\t}\n}\nll merge(ll *a, int left, int mid, int right) {\n\tll n1 = mid - left;\n\tll n2 = right - mid;\n\tvector<int> L(n1 + 1);\n\tvector<int> R(n2 + 1);\n\tfor (size_t i = 0; i < n1; i++)\n\t{\n\t\tL[i] = a[left + i];\n\t}\n\tfor (size_t i = 0; i < n2; i++)\n\t{\n\t\tR[i] = a[mid + i];\n\t}\n\n\tL[n1] = INF;\n\tR[n2] = INF;\n\tll i = 0;\n\tll j = 0;\n\tll r = 0;\n\tfor (size_t k = left; k < right; k++)\n\t{\n\t\tif (L[i] <= R[j]) {\n\t\t\ta[k] = L[i];\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\ta[k] = R[j];\n\t\t\tr += n1 - i;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn r;\n}\nll merge2(pair<int,char> *a, int left, int mid, int right) {\n\tll n1 = mid - left;\n\tll n2 = right - mid;\n\tvector<pair<int, char>> L(n1 + 1);\n\tvector<pair<int, char>> R(n2 + 1);\n\tfor (size_t i = 0; i < n1; i++)\n\t{\n\t\tL[i] = a[left + i];\n\t}\n\tfor (size_t i = 0; i < n2; i++)\n\t{\n\t\tR[i] = a[mid + i];\n\t}\n\n\tL[n1] = make_pair(INF,' ');\n\tR[n2] = make_pair(INF,' ');\n\tll i = 0;\n\tll j = 0;\n\tll r = 0;\n\tfor (size_t k = left; k < right; k++)\n\t{\n\t\tif (L[i].first <= R[j].first) {\n\t\t\ta[k] = L[i];\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\ta[k] = R[j];\n\t\t\tr += n1 - i;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn r;\n}\nll mergeSort2(pair<int, char> *a, int left, int right) {\n\tll res = 0;\n\tif (left + 1 < right) {\n\t\tint mid = (left + right) / 2;\n\t\tres = mergeSort2(a, left, mid);\n\t\tres += mergeSort2(a, mid, right);\n\t\tres += merge2(a, left, mid, right);\n\t}\n\treturn res;\n}\nll mergeSort(ll *a, int left, int right) {\n\tll res = 0;\n\tif (left + 1 < right) {\n\t\tint mid = (left + right) / 2;\n\t\tres = mergeSort(a, left, mid);\n\t\tres += mergeSort(a, mid, right);\n\t\tres += merge(a, left, mid, right);\n\t}\n\treturn res;\n}\nint partition(pair<int,char> *a, int p, int r) {\n\tpair<int, char> x = a[r];\n\tint i = p - 1;\n\tfor (size_t j = p; j < r; j++)\n\t{\n\t\tif (a[j].first <= x.first) {\n\t\t\ti++;\n\t\t\tswap(a[i], a[j]);\n\t\t}\n\t}\n\tswap(a[i + 1], a[r]);\n\treturn i + 1;\n}\nvoid quick(pair<int, char> *a, int p, int r) {\n\tif (p < r) {\n\t\tint q = partition(a, p, r);\n\t\tquick(a, p, q - 1);\n\t\tquick(a, q + 1, r);\n\t}\n}\nint n;\nvector<pii> es[100010];\nvector<int> res;\nint rec(pii x,int par,int dep,int type)\n{\n\tif (x.first == -1) {\n\t\treturn -1;\n\t}\n\n\t// node 0: parent = -1, depth = 0, root, [1, 4, 10]\n\t// node id: parent = p , sibling = s , degree = deg, depth = dep, height = h, type\n\t//int height = max(rec(es[x.first][0], x.first, dep + 1), rec(es[x.first][1], x.first, dep + 1)) + 1;\n\t//int deg = (es[x.first][0].first != -1 && es[x.first][1].first != -1) ? 2  :\n\t//\tes[x.first][0].first != -1 || es[x.first][1].first != -1 ? 1 : 0;\n\t//string r = \"node \" + to_string(x.first) + \": parent = \" + to_string(par)\n\t//\t+ \", sibling = \" + to_string(x.second) \n\t//\t+ \", degree = \" + to_string(deg)\n\t//\t+ \", depth = \" + to_string(dep) \n\t//\t+ \", height = \" + to_string(height) + \", \";\n\t//if (par == -1) r+= \"root\";\n\t//else if (es[x.first][0].first != -1 || es[x.first][1].first != -1) r += \"internal node\";\n\t//else r += \"leaf\";\n\trec(es[x.first][0], 0, 0, type);\n\trec(es[x.first][1], 0, 0, type);\n\tres.push_back(x.first);\n\t\n}\nint a[51];\nint b[45];\nint mp[45];\nint inf = 50;\nvoid make(int x,int s,int t) {\n\n\n\tint sp = 0;\n\tfor (size_t i = 0; i < n; i++)\n\t{\n\t\tif (b[i] == x) {\n\t\t\tsp = i;\n\t\t}\n\t}\n\tint mi = inf;\n\n\tfor (size_t i = s; i < sp; i++)\n\t{\n\t\tmi = min(mp[b[i]], mi);\n\t}\n\tif (mi != inf) {\n\t\tmake(a[mi], s, sp - 1);\n\t}\n\tint m2 = inf;\n\tfor (size_t i = sp + 1; i <= t; i++)\n\t{\n\t\tm2 = min(mp[b[i]], m2);\n\t}\n\tif (m2 != inf)\n\t\tmake(a[m2], sp + 1, t);\n\tes[x].push_back(make_pair(a[mi], a[m2]));\n\tes[x].push_back(make_pair(a[m2], a[mi]));\n}\nvoid solv() {\n\tcin >> n;\n\ta[inf] = -1;\n\tfor (size_t i = 0; i < n; i++)\n\t{\n\t\tcin >> a[i];\n\t\tmp[a[i]] = i;\n\t}\n\t\n\tfor (size_t i = 0; i < n; i++)\n\t{\n\t\tcin >> b[i];\n\t}\n\n\tmake(a[0], 0, n - 1);\n\trec(make_pair(a[0], -1), -1, 0, 3);\n\tfor (size_t i = 0; i < n; i++)\n\t{\n\t\tif (i > 0) cout << \" \";\n\t\tcout  << res[i];\n\t}\n\tcout << endl;\n}\nint main() {\n\t//\tCOMinit();\n\tsolv();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//https://onlinejudge.u-aizu.ac.jp/problems/ALDS1_7_D\n//p205.cpp\n\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n\tif ( l >= r ) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root ));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\nvoid solve(){\n\tpos = 0;\n\trec(0, pre.size() );\n\tfor ( int i = 0; i < n; i++ ){\n\t\tif ( i ) cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\n\nint main(){\n\tint k;\n\tcin >> n;\n\n\tfor ( int i = 0; i < n; i++ ){\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\n\tfor ( int i = 0; i < n; i++ ){\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\n\tsolve();\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace  std;\n\nconst int END = -1;\nstruct StNod\n{\n  int m_nParnt;\n  int m_nLeft;\n  int m_nRigt;\n\n  StNod() :\n     m_nParnt(END), m_nLeft(END), m_nRigt(END)\n  { }\n};\n\nenum EnDir\n{\n  D_Left,\n  D_Right,\n};\n\nvoid fnInput(vector<int> &rvnPodr, vector<int> &rvnIodrSeq)\n{\n  int nMaxSiz;\n\n  cin >> nMaxSiz;\n  rvnPodr.resize(nMaxSiz);\n  rvnIodrSeq.resize(nMaxSiz + 1);\n\n  for (int i = 0; i < nMaxSiz; i++)\n    cin >> rvnPodr[i];\n\n  int nNode;\n  for (int i = 1; i < nMaxSiz + 1; i++)\n  {\n    cin >> nNode;\n    rvnIodrSeq[nNode] = i;\n  }\n}\n\nvoid fnStructTree(const vector<int> &cnrvnPodr, const vector<int> &cnrvnIodrSeq, vector<StNod> &rvoNod)\n{\n  for (int i = 1; i < cnrvnPodr.size(); i++)\n  {\n    int nParnt = END;\n    int nx = cnrvnPodr[0];\n    EnDir enDir;\n    while (nx != END)\n    {\n      nParnt = nx;\n      if (cnrvnIodrSeq[ cnrvnPodr[i] ] < cnrvnIodrSeq[nx])\n      {\n        nx = rvoNod[nx].m_nLeft;\n        enDir = D_Left;\n      }\n      else\n      {\n        nx = rvoNod[nx].m_nRigt;\n        enDir = D_Right;\n      }\n    }\n\n    rvoNod[ cnrvnPodr[i] ].m_nParnt = nParnt;\n    if (enDir == D_Left)\n      rvoNod[nParnt].m_nLeft = cnrvnPodr[i];\n    else\n      rvoNod[nParnt].m_nRigt = cnrvnPodr[i];\n  }\n}\n\nvoid fnPostOrder(const vector<StNod> &cnrvoNod, int nx)\n{\n  static int stnPrt = 0;\n  if (nx == END)  return;\n\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nLeft);\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nRigt);\n\n  if (stnPrt++) cout << \" \";\n  cout << nx;\n}\n\nvoid fnResult(const vector<StNod> &cnrvoNod)\n{\n  int nx = 1;\n  while (cnrvoNod[nx].m_nParnt != END)\n    nx = cnrvoNod[nx].m_nParnt;\n\n  fnPostOrder(cnrvoNod, nx);\n  cout << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vector<int> vnPodr, vnIodrSeq;\n  fnInput(vnPodr, vnIodrSeq);\n\n  StNod oNod;\n  vector<StNod> voNod(vnIodrSeq.size(), oNod);\n  fnStructTree(vnPodr, vnIodrSeq, voNod);\n  \n  fnResult(voNod);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nstruct binary_tree{\n  int parent;\n  int left,right;\n  int pre_num,in_num;\n  static void preorder(binary_tree [],int);\n  static void inorder(binary_tree [],int);\n  static void llpostorder(binary_tree [],int);\n  static void postorder(binary_tree [],int,int [],int *);\n  static void w_info(int *,binary_tree [],int,int,int,int [],int []);\n};\n\nvoid binary_tree::preorder(binary_tree T[],int root){\n  std::cout<<\" \"<<root;\n  int left=T[root].left;\n  int right=T[root].right;\n  if(left==-1&&right==-1){\n  }else if(right==-1){\n    preorder(T,left);\n  }else if(left==-1){\n    preorder(T,right);\n  }else{\n    preorder(T,left);\n    preorder(T,right);\n  }\n}\n\nvoid binary_tree::inorder(binary_tree T[],int root){\n  int left=T[root].left;\n  int right=T[root].right;\n  if(left==-1&&right==-1){\n    std::cout<<\" \"<<root;\n    }else if(right==-1){\n    inorder(T,left);\n    std::cout<<\" \"<<root;\n  }else if(left==-1){\n    std::cout<<\" \"<<root;\n    inorder(T,right);\n  }else{\n    inorder(T,left);\n    std::cout<<\" \"<<root;\n    inorder(T,right);\n  }\n}\n\nvoid binary_tree::llpostorder(binary_tree T[],int root){\n  int left=T[root].left;\n  int right=T[root].right;\n  if(left==-1&&right==-1){\n    std::cout<<\" \"<<root;\n    }else if(right==-1){\n    llpostorder(T,left);\n    std::cout<<\" \"<<root;\n  }else if(left==-1){\n    llpostorder(T,right);\n    std::cout<<\" \"<<root;\n  }else{\n    llpostorder(T,left);\n    llpostorder(T,right);\n    std::cout<<\" \"<<root;\n  }\n}\n\nvoid binary_tree::postorder(binary_tree T[],int root,int R[],int *count){\n\n  int left=T[root].left;\n  int right=T[root].right;\n  if(left==-1&&right==-1){\n    R[*count]=root;\n    *count=*count+1;\n    //std::cout<<\" \"<<*count;\n    }else if(right==-1){\n    postorder(T,left,R,count);\n    //std::cout<<\" \"<<*count;\n    R[*count]=root;\n    *count=*count+1;;\n  }else if(left==-1){\n    postorder(T,right,R,count);\n    //std::cout<<\" \"<<*count;\n    R[*count]=root;\n    *count=*count+1;;\n  }else{\n    postorder(T,left,R,count);\n    postorder(T,right,R,count);\n    //std::cout<<\" \"<<*count;\n    R[*count]=root;\n    *count=*count+1;;\n  }\n}\n\nvoid binary_tree::w_info(int* count,binary_tree T[],int start_point,int last_point,int root,int pre[],int in[]){\n  *count=*count+1;\n  int pre_num=T[root].pre_num;\n  int in_num=T[root].in_num;\n  if(start_point==last_point){\n    T[root].left=-1;\n    T[root].right=-1;\n  }else if(in_num==start_point){\n    T[root].left=-1;\n    int right=pre[*count];\n    T[root].right=right;\n    T[right].parent=root;\n    w_info(count,T,in_num+1,last_point,right,pre,in);\n  }else if(in_num==last_point){\n    T[root].right=-1;\n    int left=pre[pre_num+1];\n    T[root].left=left;\n    T[left].parent=root;\n    w_info(count,T,start_point,in_num-1,left,pre,in);\n  }else{\n    int left=pre[pre_num+1];\n    T[root].left=left;\n    T[left].parent=root;\n    w_info(count,T,start_point,in_num-1,left,pre,in);\n    int right=pre[*count];\n    T[root].right=right;\n    T[right].parent=root;\n    w_info(count,T,in_num+1,last_point,right,pre,in);\n  }\n}\n\nint main(){\n  int n;\n  std::cin>>n;\n  binary_tree T[n+1];\n  int pre[n],in[n];\n  for(int i=0;i<n;i++){\n    std::cin>>pre[i];\n    T[pre[i]].pre_num=i;\n  }\n  for(int i=0;i<n;i++){\n    std::cin>>in[i];\n    T[in[i]].in_num=i;\n  }\n  int root=pre[0];\n  T[root].parent=-1;\n  int a=0;\n  int *cc=&a;\n  binary_tree::w_info(cc,T,0,n-1,root,pre,in);\n  int R[n],c=0;\n  int *count=&c;\n  binary_tree::postorder(T,root,R,count);\n  //binary_tree::llpostorder(T,root);\n  for(int i=0;i<n;i++){\n    std::cout<<R[i];\n    if(i==n-1){\n      std::cout<<std::endl;\n    }else{\n      std::cout<<\" \";\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>    // std::copy\n#include <iterator>     // std::back_inserter\nusing namespace std;\n\nstruct TNode\n{\n\tint Id;\n\tTNode* Parent;\n\tTNode* LChild;\n\tTNode* RChild;\n};\n\nvector<int> Input(int n)\n{\n\tvector<int> Tree(n);\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> Tree[i];\n\t}\n\treturn Tree;\n}\n\nvoid PostorderOutput(const TNode* Node)\n{\n\tif(Node == NULL) return;\n\tPostorderOutput(Node->LChild);\n\tPostorderOutput(Node->RChild);\n\tcout << Node->Id;\n\tif(Node->Parent){\n\t\tcout << ' ';\n\t}else{\n\t\tcout << endl;\n\t}\n}\n\nint FindIndex(vector<int> X, int a)\n{\n\tint Count = 0;\n\twhile(Count < X.size()){\n\t\tif(X[Count] == a){\n\t\t\treturn Count;\n\t\t}\n\t\tCount++;\n\t}\n\treturn Count;\n}\n\nvector<int> Subvec(vector<int> X, int m, int n)\n{\n\tvector<int> Y;\n\tfor(int i = m; i <= n; i++){\n\t\tY.push_back(X[i]);\n\t}\n\treturn Y;\n}\n\nTNode* MakeTree(const vector<int>& PreorderRow, const vector<int>& InorderRow)\n{\n\t//PreorderRow????????????????´?Root?????¨???*\n\tint Root = PreorderRow[0];\n\t\n\t//InorderRow??????????????????Root??????InorderRowLeft?????¨???\n\tint RootIndex = FindIndex(InorderRow, Root);\n\tvector<int> InorderRowLeft = Subvec(InorderRow, 0, RootIndex-1);\n\t\n\t//PreorderRow???2??????????????????InorderRowLeft??¨???????????°???PreorderRowLeft?????¨???\n\tvector<int> PreorderRowLeft = Subvec(PreorderRow, 1, RootIndex);\n\t\n\t//PreorderRow??¨InorderRow???????????????PreorderRowRight,InorderRowRight?????¨???\n\tvector<int> PreorderRowRight = Subvec(PreorderRow, RootIndex+1, PreorderRow.size()-1);\n\tvector<int> InorderRowRight  = Subvec(InorderRow, RootIndex+1, InorderRow.size()-1);\n\t\n\t//ID???Root??¨????????????????????????**\n\tTNode* RootNode;\n\tRootNode = new TNode;\n\t*RootNode = {Root, NULL, NULL, NULL};\n\t\n\t//PreorderRowLeft,InorderRowLeft??????*~**??¨????§???????????????????(?????????????´????RootLeft??¨??????)\n\tif(PreorderRowLeft.size() > 0){\n\t\tTNode* LeftNode = MakeTree(PreorderRowLeft, InorderRowLeft);\n\t\t//Root??¨RootLeft???????????????\n\t\tRootNode->LChild = LeftNode;\n\t\tLeftNode->Parent = RootNode;\n\t}\n\t\n\t//PreorderRowRight,InorderRowRight??????*~**??¨????§???????????????????(?????????????´????RootRight??¨??????)\n\tif(PreorderRowRight.size() > 0){\n\t\tTNode* RightNode = MakeTree(PreorderRowRight, InorderRowRight);\n\t\t//Root??¨RootRight???????????????\n\t\tRootNode->RChild = RightNode;\n\t\tRightNode->Parent = RootNode;\n\t}\n\t\n\treturn RootNode;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<int> PreorderRow = Input(n);\n\tvector<int> InorderRow  = Input(n);\n\tTNode* RootNode = MakeTree(PreorderRow, InorderRow);\n\tPostorderOutput(RootNode);\n//\tDeleteNode(RootNode);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>    // find\nusing namespace std;\n\nvector<int> pre, in, post;\n\n// preorder の [fp, lp) の範囲と，inorder の [fi, li) の範囲について\n// 木を postorder で表示\nvoid recover(int fp, int lp, int fi, int li) {\n    // preoder[fp] == inorder[root] となるような root を求める\n    int root = distance(in.begin(), find(in.begin(), in.end(), pre[fp]));\n    if (fi != root) {       // 左側が存在すれば\n        recover(fp + 1, fp + 1 + (root - fi), fi, root);    // 左側を表示\n    }\n    if (root + 1 != li) {   // 右側が存在すれば\n        recover(fp + 1 + (root - fi), lp, root + 1, li);    // 右側を表示\n    }\n    post.push_back(in[root]);   // root を表示\n}\n\nint main() {\n    int n; cin >> n;\n    for (int i = 0; i < n; i++) {\n        int t; cin >> t; pre.push_back(t);\n    }\n    for (int i = 0; i < n; i++) {\n        int t; cin >> t; in.push_back(t);\n    }\n    recover(0, n, 0, n);\n    for (int i = 0; i < n; i++) {\n        cout << post[i] << \" \\n\"[i == n - 1];\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n  \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n  \nusing namespace std;\n  \ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n  \nconst int INF=1<<29;\nconst double EPS=1e-9;\n  \nconst int dx[]={1,0,-1,0,1,1,-1,-1},dy[]={0,-1,0,1,1,-1,-1,1};\n\nint N;\nstd::vector<vector<int> > G;\n\n\nvoid preorder(int i) {\n    cout << \" \" << i;\n    if (G[i][0] != -1) preorder(G[i][0]);\n    if (G[i][1] != -1) preorder(G[i][1]);\n}\n\nvoid inorder(int i) {\n    if (G[i][0] != -1) inorder(G[i][0]);\n    cout << \" \" << i;\n    if (G[i][1] != -1) inorder(G[i][1]);\n}\n\nvoid postorder(int i) {\n    if (G[i][0] != -1) postorder(G[i][0]);\n    if (G[i][1] != -1) postorder(G[i][1]);\n    cout << i + 1;\n    if (i != N) cout << \" \";\n}\n\nstd::vector<int> in;\nstd::vector<int> mid;\n\nint nowpoint = 0;\n\nint dfs(int l, int r) {\n    if (l == r) {\n        return -1;\n    }\n    //cout << \"l : \" << l << \", r : \" << r << endl;\n    int now = in[nowpoint++];\n\n    int j = 0;\n    for (int i = l; i < r; i++) {\n        if (now == mid[i]) {\n            j = i;\n            break;\n        }\n    }\n    //cout << \" j : \" << j << endl;\n    G[now][0] = dfs(l, j);\n    G[now][1] = dfs(j + 1, r);\n    return now;\n}\n\nint main() {\n\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        int temp;\n        cin >> temp;\n        temp--;\n        in.push_back(temp);\n    }\n\n    for (int i = 0; i < N; i++) {\n        int temp;\n        cin >> temp;\n        temp--;\n        mid.push_back(temp);\n        G.push_back(vector<int>(2));\n    }\n\n    postorder(dfs(0, N));\n    cout << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n  if ( l >= r ) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(l, m);\n  rec(m + 1, r);\n  post.push_back(root);\n}\n\nvoid solve() {\n  pos = 0;\n  rec(0, pre.size());\n  for ( int i = 0; i < n; i++ ) {\n    if ( i ) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main() {\n  int k;\n  cin >> n;\n\n  for ( int i = 0; i < n; i++ ) {\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for ( int i = 0; i < n; i++ ) {\n    cin >> k;\n    in.push_back(k);\n  }\n\n  solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvoid reconstruction(const vector<int>& pre, const vector<int>& in, \n                    vector<int>& post, int left, int right){\n    if(left >= right){\n        return;\n    }\n    static int position = 0;    // 再帰中でも順番に取り出すためにstatic\n    int value = pre[position++];\n    int middle = distance(in.begin(), find(in.begin(), in.end(), value));\n    reconstruction(pre, in, post, left, middle);\n    reconstruction(pre, in, post, middle+1, right);\n    post.push_back(value);  // 後行順巡回なので最後に値を追加する\n}\n\nint main(){\n\n    int n;\n    cin >> n;\n    \n    vector<int> pre(n), in(n);\n    // 先行順巡回\n    for(int i = 0; i < n; ++i){\n        cin >> pre[i];\n    }\n    // 中間順巡回\n    for(int i = 0; i < n; ++i){\n        cin >> in[i];\n    }\n\n    vector<int> post;   // 後行順巡回を入れるため配列\n\n    reconstruction(pre, in, post, 0, n);\n\n    for(int i = 0; i < n; ++i){\n        if(i){\n            cout << \" \";\n        }\n        cout << post[i];\n    }\n    cout << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n\nusing namespace std;\n\nint n, pos;\nint pre[40], in[40], post[40];\nbool preused[40];\n\ninline int toinnode(int prenode) {\n    for (int i = 0; i < n; ++i) {\n        if (in[i] == pre[prenode]) {\n            return i;\n        }\n    }\n}\n\ninline int toprenode(int innode) {\n    for (int i = 0; i < n; ++i) {\n        if (pre[i] == in[innode]) {\n            return i;\n        }\n    }\n}\n\ninline int getpreleft(int prenode) {\n    int innode = toinnode(prenode);\n\n    bool ng = innode == 0;\n    if (ng) { return -1; }\n\n    if (preused[toprenode(innode - 1)]) {\n        return -1;\n    }\n\n    int preleft = prenode + 1;\n    ng = preleft < 0 || preleft >= n || preused[preleft];\n    if (ng) {\n        return -1;\n    }\n    else {\n//        printf(\"[getpreleft] preleft = %d, pre[preleft] = %d\\n\",\n//                             preleft, pre[preleft]);\n        return preleft;\n    }\n}\n\ninline int getpreright(int prenode) {\n    int innode = toinnode(prenode);\n    bool nolefttree = innode == 0;\n    if (!nolefttree) {\n//        printf(\"[getpreright] pre[%d] = %d, preused[%d] = %s\\n\",\n        nolefttree = preused[toprenode(innode - 1)];\n    }\n    if (nolefttree && innode + 1 < n && !preused[toprenode(innode + 1)]) {\n//        printf(\"[getpreright] No Left Tree\\n\");\n        return prenode + 1 < n ? prenode + 1 : -1;\n    }\n\n    int preright = 1 + toprenode(innode - 1);\n    bool ng = (innode == n - 1 || preused[toprenode(innode + 1)])\n           || (preright < 0 || preright >= n || preused[preright]);\n    if (ng) {\n        return -1;\n    }\n//    printf(\"[getpreright] preright = %d, pre[preright] = %d\\n\",\n//            preright, pre[preright]);\n    return preright;\n}\n\ninline void topost(int prenode) {\n\n    int preleft  = getpreleft(prenode);\n    int preright = getpreright(prenode);\n    if (preleft != -1) preused[preleft] = true;\n    if (preright != -1) preused[preright] = true;\n\n//    printf(\"[topost] #index: root = %d, left = %d, right = %d\\n\",\n//                     prenode, preleft, preright);\n//    printf(\"[topost] #value: root = %d, left = %d, right = %d\\n\\n\",\n//                     pre[prenode],\n//                     preleft != -1 ? pre[preleft] : -1,\n//                     preright != -1 ? pre[preright] : -1);\n\n    if (preleft != -1) {\n        topost(preleft);\n    }\n\n    if (preright != -1) {\n        topost(preright);\n    }\n\n    post[pos++] = pre[prenode];\n}\n\nint main(void) {\n\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &pre[i]);\n    }\n\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &in[i]);\n    }\n\n    preused[0] = true;\n    topost(0);\n\n    printf(\"%d\", post[0]);\n    for (int i = 1; i < n; ++i) {\n        printf(\" %d\", post[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\n\nusing namespace std;\n\ntypedef long long LL;\n\ntypedef vector<int> VI;\n\nvector<int> pre, in, post;\nint pos = 0;\n\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"[\";\n    REP(i, vec.size()) {\n        if (i > 0) cout << \", \";\n        os << vec[i];\n    }\n    os << \"]\";\n\n    return os;\n}\n\n\nvoid reconstruct(int l, int r) {\n    if(l >= r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n\n    reconstruct(l, m);\n    reconstruct(m+1, r);\n\n    post.push_back(root);\n}\n\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n\n    int k;\n\n    REP(i, n) {\n        cin >> k;\n        pre.push_back(k);\n    }\n\n    REP(i, n) {\n        cin >> k;\n        in.push_back(k);\n    }\n\n    reconstruct(0, n);\n\n    REP(i, n) {\n        if (i) cout << \" \";\n        cout << post[i];\n    }\n\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r)\n{\n\tif (l >= r)\n\t\treturn;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\nvoid solve() {\n\tpos = 0;\n\trec(0, pre.size());\n\n\tint i;\n\tfor (i = 0; i < post.size(); i++) {\n\t\tif (i) cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\n\nint main(void) {\n\tint n, i, k;\n\tcin >> n;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\tsolve();\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r)\n{\n\tif(l >= r)\n\t{\n\t\treturn;\n\t}\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\t//printf(\"----%d\\n\", m);\n\trec(l, m);\n\trec(m+1, r);\n\tpost.push_back(root);\n}\n\nvoid solve()\n{\n\tpos = 0;\n\trec(0, pre.size());\n//\tfor(int i = 0; i < n; i++)\n//\t{\n//\t\tif(i)\n//\t\t{\n//\t\t\tprintf(\" \");\n//\t\t}\n//\t\tprintf(\"%d\", post[i]);\n//\t}\n//\tprintf(\"\\n\");\n}\n\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tint d;\n\tfor(int i = 0; i < n; i++)\n\t{\t\n\t\tscanf(\"%d\", &d);\n\t\tpre.push_back(d);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\t\n\t\tscanf(\"%d\", &d);\n\t\tin.push_back(d);\n\t}\n\tsolve();\n\t\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(i)\n\t\t{\n\t\t\tprintf(\" \");\n\t\t}\n\t\tprintf(\"%d\", post[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct node {\n    int key;\n    bool confirmed;\n    node *left;\n    node *right;\n    node *parent;\n\n    node *reconstruction() {\n        if (parent->confirmed) return this->parent;\n        node *pNode = parent->reconstruction();\n        parent->parent = this;\n        if (this == parent->right) {\n            parent->right = nullptr;\n            left = parent;\n            pNode->right = this;\n        } else {\n            parent->left = nullptr;\n            right = parent;\n            pNode->left = this;\n        }\n        parent = pNode;\n        return pNode;\n    }\n};\n\nqueue<node *> postOrder;\n\nvoid walkPostOrder(node *cur) {\n    if (cur == nullptr) return;\n    walkPostOrder(cur->left);\n    walkPostOrder(cur->right);\n    postOrder.push(cur);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<node *> preOrder(n);\n    vector<node> inOrder(n + 1);\n    inOrder[0].confirmed = true;\n    for (int i = 0; i < n; ++i) {\n        int key;\n        cin >> key;\n        preOrder[i] = &inOrder[key];\n    }\n    int key, pre;\n    pre = 0;\n    for (int i = 1; i <= n; ++i) {\n        cin >> key;\n        inOrder[key].key = key;\n        inOrder[key].parent = &inOrder[pre];\n        inOrder[pre].right = &inOrder[key];\n        pre = key;\n    }\n    for (int i = 0; i < n; ++i) {\n        preOrder[i]->reconstruction();\n        preOrder[i]->confirmed = true;\n    }\n    walkPostOrder(preOrder[0]);\n    while (postOrder.size() > 1) {\n        cout << postOrder.front()->key << ' ';\n        postOrder.pop();\n    }\n    if (!postOrder.empty()) cout << postOrder.front()->key;\n    cout << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct node{\n  int id;\n  struct node *parent;\n  struct node *left;\n  struct node *right;\n}Node;\n\nvoid print_tree(Node *x,int t);\nNode *make_tree(int *pre, int * in, int i, int j, int n, Node *p);\n\nint main()\n{\n  int i,n,*preorder,*inorder;\n  scanf(\"%d\",&n);\n  preorder = (int*)malloc(sizeof(int) * n);\n  inorder = (int*)malloc(sizeof(int) * n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\",preorder+i);\n  }\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\",inorder+i);\n  }\n  Node *root = make_tree(preorder,inorder,0,0,n,NULL);\n  print_tree(root,0);\n  return 0;\n}\n\n\nvoid print_tree(Node *x,int t) {\n  if(x->left != NULL) print_tree(x->left,1);\n  if(x->right != NULL) print_tree(x->right,1);\n  if(t == 1)printf(\"%d \", x->id);\n  if(t == 0)printf(\"%d\\n\", x->id);\n}\n\nNode *make_tree(int *pre, int * in, int i, int j, int n, Node *p) {\n  if(i >= n) return NULL;\n  Node *p1 = (Node*)malloc(sizeof(Node));\n  p1->id = pre[i];\n  p1->parent = p;\n  p1->left = NULL;\n  p1->right = NULL;\n  if(pre[i] != in[j]) {\n    p1->left = make_tree(pre,in,i+1,j,n,p1);\n  }else{\n    Node *tmp = p1;\n    while(1) {\n      if(p == NULL) {\n\tbreak;\n      }\n      if(p->id == in[j+1]) {\n\tj++;\n\ttmp = p;\n      }\n      p = p->parent;\n    }\n    tmp->right = make_tree(pre,in,i+1,j+1,n,tmp);\n  }\n  return p1;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\n#define MAX 40\n\nint n, pos, k;\nint PRE[MAX];\nint IN[MAX];\nint POS[MAX];\n\nvoid Postorder (int l, int r) {\n    if (l >= r) return;\n    int root = PRE[pos++];\n    int target = 0;\n    for (int i = 0; i < n; ++i) {\n        if (IN[i] == root) {\n            target = i;\n            break;\n        }\n    }\n\n    Postorder(l, target);\n    Postorder(target + 1, r);\n    POS[k++] = root;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &PRE[i]);\n    }\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &IN[i]);\n    }\n\n    k = pos = 0;\n    Postorder(0, n);\n\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", POS[i]);\n    }\n    printf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdlib>\n#define _USE_MATH_DEFINES // M_PI????????????????????????\n#include<math.h>\n#pragma warning(disable:4996)\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n\tif( l>=r ) return;\n\tint root = pre[pos++];\n\tint m = distance( in.begin(), find(in.begin(), in.end(), root) );\n\trec(l,m);\n\trec(m+1,r);\n\tpost.push_back(root);\n}\n\n\nvoid solve(){\n\tpos = 0;\n\trec(0,pre.size());\n\tfor(int i=0; i<n; i++){\n\t\tif(i) cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << \"\\n\";\n}\n\n\nint main(){\n\tint k;\n\tcin >> n;\n\n\tfor(int i=0; i<n; i++){\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\n\tfor(int i=0; i<n; i++){\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\nusing ll = long long ;\nusing P = pair<int,int> ;\nusing pll = pair<long long,long long>;\nconstexpr int INF = 1e9;\nconstexpr long long LINF = 1e17;\nconstexpr int MOD = 1000000007;\nint n = 42;\nvector<int> a(n),b(n);\nvector<vector<int>> tree(n,vector<int>());\nvector<int> ans;\n\nvoid maketree(int top,int L,int R,int par=-1){\n    if(L==R) return;\n\n    if(par!=-1) tree[par].push_back(a[top]);\n\n    if(L+1==R){\n        return;\n    }\n\n    int idx = 0;\n    for(int i=L;i<R;i++){\n        if(b[i]==a[top]){\n            idx = i;\n            break;\n        }\n    }\n\n\n    int top1 = top+1;\n    int top2 = top+idx-L+1;\n    maketree(top1,L,idx,a[top]);\n    maketree(top2,idx+1,R,a[top]);\n\n    return;\n}\n\nvoid dfs(int i){\n\n    for(int c:tree[i]){\n        dfs(c);\n    }\n\n    ans.push_back(i);\n    return;\n}\n\nint main(){\n    cin >> n;\n    rep(i,n) cin >> a[i];\n    rep(i,n) cin >> b[i];\n\n    maketree(0,0,n);\n    /*\n    rep(i,n){\n        rep(j,tree[i].size()) cout << tree[i][j] <<\"  \";\n        cout <<endl;\n    }\n    */\n\n    dfs(a[0]);\n\n    rep(i,n){\n        cout << ans[i] << (i==n-1?'\\n':' ');\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  ALDS1_7_D\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#define rep(i,n) for(int i=0;i<(n);++i)\nusing namespace std;\nvector<int> pre,in,post;\nint pos;\nint n;\nvoid rec(int l,int r){\n    if(l>=r) return;\n    int root=pre[pos];\n    pos++;\n    int m=(int)distance(in.begin(),find(in.begin(),in.end(),root));\n    rec(l,m);\n    rec(m+1,r);\n    post.push_back(root);\n}\nvoid solve(){ // preとinからpostを作る\n    pos=0;\n    rec(0,(int)pre.size());\n    rep(i,n){\n        if (i) cout<<\" \";\n        cout<<post[i];\n    }\n    cout<<endl;\n}\nint main(int argc, const char * argv[]) {\n    cin>>n;\n    int k;\n    rep(i,n){\n        cin>>k;\n        pre.push_back(k); // 先行順のデータ\n    }\n    rep(i, n){\n        cin>>k;\n        in.push_back(k); // 中間順のデータ\n    }\n    solve(); // 後行順のデータを作る\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(obj) (obj).begin(),(obj).end()\ntypedef long long ll;\nll mod=2e12;\nll cnt=0;\n#define max 100005\n#define nil -1\n\nvector<int> pre,in,post;\nint key=0;\nint n;\n\nvoid sort(int l,int r){\n  if(l>=r)return;\n  int root=pre.at(key++);\n  int m=distance(in.begin(),find(in.begin(),in.end(),root));\n  sort(l,m);\n  sort(m+1,r);\n  post.push_back(in.at(m));\n}\n\nvoid solve(){\n  sort(0,pre.size());\n  rep(i,n){\n    if(i)cout<<\" \";\n    cout<<post[i];\n  }\n  cout<<endl;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin>>n;\n    int q;\n    rep(i,n){\n      cin>>q;\n      pre.push_back(q);\n    }\n    rep(i,n){\n      cin>>q;\n      in.push_back(q);\n    }\n    solve();\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include<vector>\nusing namespace std;\n\nint n;\nint pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n  if(l >= r) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(l, m);\n  rec(m+1, r);\n  post.push_back(root);\n}\n\nvoid solve() {\n  pos = 0;\n  rec(0, pre.size());\n  for(int i=0; i<n; i++){\n    if(i) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main(){\n  int k;\n  cin >> n;\n\n  for(int i=0; i<n; i++){\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for(int i=0; i<n; i++){\n    cin >> k;\n    in.push_back(k);\n  }\n  \n  solve();\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define N 40\n\nvector<int> a, b, c;\n\nvoid postOrder(vector<int>::iterator a1, vector<int>::iterator a2, vector<int>::iterator b1, vector<int>::iterator b2)\n{\n    //printf(\"%d %d %d %d\\n\", *a1, *(a2 - 1), *b1, *(b2 - 1));\n    vector<int>::iterator itr;\n    c.push_back(*a1);\n    //printf(\"%d\\n\", *a1);\n    itr = find(b1, b2, *a1); //itrator of root on inorder tree walk\n    int d = itr - b1;\n    if (a1 + d + 1 < a2 && itr + 1 < b2)\n        postOrder(a1 + d + 1, a2, itr + 1, b2);\n    if (a1 + 1 < a1 + d + 1 && b1 < itr)\n        postOrder(a1 + 1, a1 + d + 1, b1, itr);\n}\n\nint main()\n{\n    int n, x;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> x;\n        a.push_back(x);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        cin >> x;\n        b.push_back(x);\n    }\n\n    postOrder(a.begin(), a.end(), b.begin(), b.end());\n\n    for (int i = 0; i < c.size(); i++)\n    {\n        if (i != 0)\n            cout << \" \";\n        cout << c[c.size() - 1 - i];\n    }\n    cout << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing vi = vector<int>;\nusing vic = vector<int> const;\n\nint reconstruct_a_tree(int n, vic & preorder, vic & inorder, vi & parent, vi & left, vi & right);\nint process_subtree(int preL, int preR, int inL, int inR, vic & preorder, vic & inorder, vic & val2inorder_idx, vi & parent, vi & left, vi & right);\nvoid postorder_walk(int root, vi & postorder, vic & parent, vic & left, vic & right);\n\nvoid pprint(vector<int> vs){\n    cout << vs[0];\n    for (auto it = vs.begin()+1; it != vs.end(); ++it) cout << ' ' << *it;\n    cout << endl;\n}\n\nint main()\n{\n    // read data\n    int n = 0;\n    cin >> n;\n    vector<int> preorder(n);\n    for (auto & val : preorder) cin >> val;\n    vector<int> inorder(n);\n    for (auto & val : inorder) cin >> val;\n    \n    // reconstruct a tree\n    vector<int> parent(n + 1);\n    vector<int> left(n + 1);\n    vector<int> right(n + 1);\n    int root = reconstruct_a_tree(n, preorder, inorder, parent, left, right);\n    parent[0] = 0;\n    \n    // post_order walk\n    vector<int> postorder;\n    postorder_walk(root, postorder, parent, left, right);\n    pprint(postorder);\n    return 0;\n}\n\nint reconstruct_a_tree(int n, vic & preorder, vic & inorder, vi & parent, vi & left, vi & right){\n    vector<int> val2inorder_idx(n + 1);\n    for (int idx = 0; idx != n; ++idx) val2inorder_idx[inorder[idx]] = idx;\n    return process_subtree(0, n, 0, n, preorder, inorder, val2inorder_idx, parent, left, right);\n}\n\nint process_subtree(int preL, int preR, int inL, int inR, vic & preorder, vic & inorder, vic & val2inorder_idx, vi & parent, vi & left, vi & right){\n    if (preL == preR) return 0;\n    int root = preorder[preL];\n    int inM = val2inorder_idx[root];\n    int preM = preL + 1 + inM - inL;\n    int left_child = process_subtree(preL + 1, preM, inL, inM, preorder, inorder, val2inorder_idx, parent, left, right);\n    int right_child = process_subtree(preM, preR, inM + 1, inR, preorder, inorder, val2inorder_idx, parent, left, right);\n    left[root] = left_child;\n    right[root] = right_child;\n    parent[left_child] = root;\n    parent[right_child] = root;\n    return root;\n}\n\n\nvoid postorder_walk(int root, vi & postorder, vic & parent, vic & left, vic & right){\n    if (root == 0) return;\n    postorder_walk(left[root], postorder, parent, left, right);\n    postorder_walk(right[root], postorder, parent, left, right);\n    postorder.push_back(root);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace  std;\n\nvoid fnInput(vector<int> &rvnPodr, vector<int> &rvnIodrSeq)\n{\n  int nMaxSiz;\n\n  cin >> nMaxSiz;\n  rvnPodr.resize(nMaxSiz);\n  rvnIodrSeq.resize(nMaxSiz + 1);\n\n  for (int i = 0; i < nMaxSiz; i++)\n    cin >> rvnPodr[i];\n\n  int nNode;\n  for (int i = 1; i < nMaxSiz + 1; i++)\n  {\n    cin >> nNode;\n    rvnIodrSeq[nNode] = i;\n  }\n}\n\nvoid fnPostOrder(const vector<int> &cnrvnPodr, const vector<int> &cnrvnIodrSeq, int nLeft, int nRight)\n{\n  static int stnx = 0;\n  static int stnPrt = 0;\n\n  if (nLeft == nRight) return;\n\n  int nNode = cnrvnPodr[stnx++];\n  int nMid = cnrvnIodrSeq[nNode];\n\n  fnPostOrder(cnrvnPodr, cnrvnIodrSeq, nLeft, nMid);\n  fnPostOrder(cnrvnPodr, cnrvnIodrSeq, nMid + 1, nRight);\n\n  if (stnPrt++) cout << \" \";\n  cout << nNode;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vector<int> vnPodr, vnIodrSeq;\n  fnInput(vnPodr, vnIodrSeq);\n\n  fnPostOrder(vnPodr, vnIodrSeq, 1, vnPodr.size());\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n#define P(x) cout << (x) << endl\n#define p(x) cout << (x)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define vv(type, c, m, n, i) vector<vector<type>> c(m, vector<type>(n, i));\n#define rep(i,a,n) for(int i=(a), i##_len=(n); i<i##_len; ++i)\n#define rrep(i,a,n) for(int i=(a), i##_len=(n); i>i##_len; --i)\n#define len(x) ((int)(x).size())\n#define mp make_pair\n#define eb emplace_back\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\nint n, pos{0};\nvi pre, in, post;\ninline void rec(int l, int r) {\n\tif(l >= r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(all(in), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.eb(root);\n}\ninline void solve() {\n\trec(0, len(pre));\n\tcout << post[0];\n\trep(i, 1, n) cout << \" \" << post[i];\n\tcout << endl;\n}\nint main() {\n\tcin >> n;\n\tpre.resize(n); in.resize(n); post.reserve(n);\n\trep(i, 0, n) cin >> pre[i];\n\trep(i, 0, n) cin >> in[i];\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r)\n{\n    if(l>=r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m+1, r);\n    post.push_back(root);\n}\nvoid solve()\n{\n    pos = 0;\n    rec(0, n);\n    for(int i=0; i<n; i++)\n    {\n        if(i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\nint main()\n{\n    cin >> n;\n    int s1, s2;\n    for(int i=0; i<n; i++)\n    {\n        cin >> s1;\n        pre.push_back(s1);\n    }\n    for(int i=0; i<n; i++)\n    {\n        cin >> s2;\n        in.push_back(s2);\n    }\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint count = 0;\nint search(int arr[], int x, int n) {\n    for (int i = 0; i < n; i++)\n        if (arr[i] == x) return i;\n    return -1;\n}\nvoid printPostOrder(int in[], int pre[], int n, int arr5[]) {\n    int root = search(in, pre[0], n);\n    if (root != 0) printPostOrder(in, pre+1, root, arr5);\n    if (root != n-1) printPostOrder(in+root+1, pre+root+1, n-root-1, arr5);\n    arr5[count] = pre[0];\n    count++;\n}\n\nint main() {\n    int num;\n    cin >> num;\n    int arr[num];\n    int arr2[num];\n    int arr5[num];\n    for (int i = 0; i < num; i++) cin >> arr[i];\n    for (int i = 0; i < num; i++) cin >> arr2[i];\n    printPostOrder(arr2, arr, num, arr5);\n    for (int i = 0; i < num; i++) {\n        if (i != num - 1) cout << arr5[i] << \" \";\n        else cout << arr5[i] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n    if ( l >= r ) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m + 1, r);\n    post.push_back(root);\n}\n\nvoid solve() {\n    pos = 0;\n    rec(0, pre.size());\n    for (int i = 0;i < n; i++) {\n        if (i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main() {\n    int k;\n    cin >> n;\n    \n    for (int i = 0; i <n; i++) {\n        cin >> k;\n        pre.push_back(k);\n    }\n    \n    for (int i = 0; i < n; i++) {\n        cin >> k;\n        in.push_back(k);\n    }\n    \n    solve();\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*! if g++ -g alds_1_7_d.cpp -o alds_1_7_d.out; then ./alds_1_7_d.out < alds_1_7_d.test; fi\n */\n\n#include <sstream>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iterator>\n#include <numeric>\n#include <functional>\n#include <climits>\n\n\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\nvector<int> pre(0);\nvector<int> ipre(0);\nvector<int> mid(0);\nvector<int> imid(0);\n\nclass node{\npublic:\n  int id, left, right;\n  node(): id(-1), left(-1), right(-1){}\n};\n\nvector<node> tree(0);\n\nint doit(int pl, int pr, int ml, int mr){\n  if(pl == pr) return -1;\n  int root_id = pre[pl];\n\n  int ml1 = ml;\n  int mr1 = imid[root_id];\n  int ml2 = mr1 + 1;\n  int mr2 = mr;\n\n  int pl1 = pl + 1;\n  int pr1 = pl1 + mr1 - ml1;\n  int pl2 = pr1;\n  int pr2 = pr;\n\n  node& nd = tree[root_id-1];\n  nd.id = root_id;\n  nd.left = doit(pl1, pr1, ml1, mr1);\n  nd.right = doit(pl2, pr2, ml2, mr2);\n  return root_id;\n}\n\nvector<int> ret;\n\nvoid post(int root){\n  node& nd = tree[root-1];\n  if(nd.left > 0) post(nd.left);\n  if(nd.right > 0) post(nd.right);\n  ret.push_back(nd.id);\n}\n\nint main(){\n  int n;\n  cin >> n;\n  pre.resize(n);\n  mid.resize(n);\n  ipre.resize(n);\n  imid.resize(n);\n  tree.resize(n);\n  for (int i = 0; i < n; i++) {\n    cin >> pre[i];\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> mid[i];\n  }\n  for (int i = 0; i < n; i++) {\n    ipre[pre[i]] = i;\n    imid[mid[i]] = i;\n  }\n  int root_id = doit(0, n, 0, n);\n  post(root_id);\n  for (int i = 0; i < n-1; i++) {\n    cout << ret[i] << \" \";\n  }\n  cout << ret.back() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint pos=0;\n\nvoid solve(const vector<int> &preorder, const vector<int> &inorder, vector<int> &postorder, \n\tint L, int R) {\n    if(L<R) {\n    int root=preorder[pos++];\n    int m = distance(inorder.begin(), find(inorder.begin(), \n    \tinorder.end() ,root) );\n\n   solve(preorder, inorder, postorder, L, m);\n   solve(preorder, inorder, postorder, m+1, R);\n   postorder.push_back(root);\n   }\n }\n\nint main(){\n\n\tint n;\n\tcin>>n;\n\tvector<int> preorder, inorder, postorder;\n\tint k;    \n    for( int i = 0; i < n; ++i ) { \n    \tcin >> k; preorder.push_back(k); \n    }\n    for( int i = 0; i < n; ++i ) { \n    \tcin >> k; inorder.push_back(k); \n    }\n    pos=0;\n    solve(preorder, inorder, postorder, 0, n);\n    \n    for( int i = 0; i < postorder.size(); ++i ) {\n    \tif ( i ) cout << \" \";\n    \tcout << postorder[i];\n    }\n    cout<<endl;\n    \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 45\nusing namespace std;\nint pre[N], p = 0;\nint in[N];\nint n;\nvector<int> post;\nvoid rec(int l, int r){\n    if (l >= r) return ;\n    int c = pre[p++];\n    int m;\n    for(m = 0; m < n; m++){\n        if(in[m] == c) break;\n    }\n    rec(l, m);\n    rec(m+1, r);\n    post.push_back(c);\n}\nint main() {\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++) scanf(\"%d\", &pre[i]);\n    for(int i = 0; i < n; i++) scanf(\"%d\", &in[i]);\n    rec(0, n);\n    for(int i = 0; i < post.size(); i++){\n        printf(\"%d\", post[i]);\n        i == post.size()-1 ? printf(\"\\n\") : printf(\" \");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n    if(l >= r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m+1, r);\n    post.push_back(root);\n}\n\nvoid solve(){\n    pos = 0;\n    rec(0, pre.size());\n    for(int i=0; i<n; i++){\n        if(i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main(){\n    int k;\n    cin >> n;\n\n    for(int i=0; i<n; i++){\n        cin >> k;\n        pre.push_back(k);\n    }\n\n    for(int i=0; i<n; i++){\n        cin >> k;\n        in.push_back(k);\n    }\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nvector<int> in;\nvector<int> pre;\nvector<int> post;\n\nint p = 0;\nvoid reconstruction(int l, int r)\n{\n\n\tif (l >= r)\n\t\treturn;\n\tint a, m;\n\t a = pre[p++];\n\t m = distance(in.begin(), find(in.begin(), in.end(), a));\n\t reconstruction(l,m);\n\t reconstruction(m+1, r);\n\n\t post.push_back(a);\n\n}\nint main()\n{\n\tint n,k;\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\n\treconstruction(0, n);\n\n\tcout << post[0];\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tcout << ' '<<post[i];\n\t}\n\tcout << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint tree(int k,int l, int n);\n\nint a[50],b[50];\n\nint main(void){\n//??\\???\n\tint i,j,n;\n\t\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&b[i]);\n\t}\n\ttree(0,0,n);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n\nint tree(int k,int l, int n){\n\tif(n==0){\n\t} else \n\tif(n==1){\n\t\tprintf(\"%d \",a[k]);\n\t}else{\n\t\tint i=0;\n\t\twhile(b[l+i]!=a[k]){\n\t\t\ti++;\n\t\t}\n\t\t\n\t\ttree(k+1,l,i);\n\t\ttree(k+i+1,l+i+1,n-i-1);\n\t\tprintf(\"%d \",a[k]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint le[100005];\nint ri[100005];\nint a[100005];\nint b[100005];\nint n;\nvoid solve(int i,int l,int r){\n\tint j;\n\tfor(j=l;b[j]!=a[i];j++);\n\tle[i]=ri[i]=-1;\n\tif(j-l>0){// 存在左树 \n\t\tle[i]=i+1;\n\t\tsolve(i+1,l,j-1);\t\n\t}\n\tif(r-j>0){\n\t\tri[i]=i+j-l+1;\n\t\tsolve(i+j-l+1,j+1,r);\n\t}\n}\nvector<int>res;\nvoid dfs(int i){\n\tif(le[i]!=-1)dfs(le[i]);\n\tif(ri[i]!=-1)dfs(ri[i]);\n\tres.push_back(a[i]);\n}\nint main(){\n\tios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\tcin>>n;\n\tfor(int i=0;i<n;i++)cin>>a[i];\n\tfor(int i=0;i<n;i++)cin>>b[i];\n\tsolve(0,0,n-1);\n\tdfs(0);\n\tfor(int i=0;i<res.size()-1;i++){\n\t\tcout<<res[i]<<' ';\n\t}cout<<res[res.size()-1]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n\tif(l == r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m+1, r);\n\tpost.push_back(root);\n}\n\nvoid solve() {\n\tpos = 0;\n\trec(0, pre.size());\n\tfor(int i = 0; i < n; i++) {\n\t\tif(i) cout << \" \";\n\t\tcout << post[i]; \n\t}\n\tcout << endl;\n}\n\nint main() {\n\tint k;\n\tcin >> n;\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\t\n\tsolve();\n    \n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\nusing namespace std;\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r){\n//\tprintf(\"\tl=%d r=%d\\n\",l,r);\n\tif(l>=r)return;\n\tint root = pre[pos++];//visit in Preorder\n\tint m = distance(in.begin(),find(in.begin(),in.end(),root));//return distance between two iterators\n//\tprintf(\"l = %d root = %d m = %d r = %d\\n\",l,root,m,r);\n\n\trec(l,m);\t\n\trec(m+1,r);\n\tpost.push_back(root);//left-right-root,if inOrder,put this above\n//\tprintf(\"push %d\\n\\n\",root);\n}\nint main()\n{\n\tint n,k;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;++i){\n\t\tscanf(\"%d\",&k);\n\t\tpre.push_back(k);\n\t}\n\tfor(int i=0;i<n;++i){\n\t\tscanf(\"%d\",&k);\n\t\tin.push_back(k);\n\t}\n \tpos = 0;\n \trec(0,pre.size());\n \tfor(int i=0;i<n;++i){\n\t \tif(i)printf(\" \");\n\t \tprintf(\"%d\",post[i]);\n \t}\n    printf(\"\\n\");\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nusing Weight=int;\nusing DArray=vector<Weight>;\nusing DMatrix=vector<DArray>;\n\nstatic const Weight INF=1<<29;\n\nstruct Edge {\n    size_t src, dst;\n    Weight weight;\n    Edge() {}\n    Edge(size_t src, size_t dst, Weight weight=1):\n        src(src), dst(dst), weight(weight)\n    {}\n};\n\nbool operator<(const Edge &e, const Edge &f) {\n    if (e.weight != f.weight) {\n        return e.weight > f.weight;\n    } else {\n        return e.src!=f.src? e.src<f.src : e.dst<f.dst;\n    }\n}\n\nusing Edges=vector<Edge>;\nusing Vertex=vector<Edge>;\nusing Graph=vector<Vertex>;\n\nvoid join(Graph &g, size_t s, size_t d, Weight w=1) {\n    // non-directed\n    g[s].push_back(Edge(s, d, w));\n    g[d].push_back(Edge(d, s, w));\n}\n\nvoid connect(Graph &g, size_t s, size_t d, Weight w=1) {\n    // directed\n    g[s].push_back(Edge(s, d, w));\n}\n\nsize_t get_root(const Graph &g) {\n    // stores the node type\n    size_t V=g.size();\n    vector<Weight> indeg(V);\n    for (size_t i=0; i<V; ++i)\n        for (const Edge &e: g[i])\n            indeg[e.dst] += e.weight;\n\n    for (size_t i=0; i<V; ++i)\n        if (!indeg[i])\n            return i;\n\n    return 0;\n}\n\ntemplate <class Functor>\nvoid walk_postorder(const Graph &g, size_t root, Functor F) {\n    if (root >= g.size()-1) return;\n\n    for (const Edge &e: g[root])\n        walk_postorder(g, e.dst, F);\n\n    F(root);\n}\n\nvoid reconstruct_tree(\n    vector<size_t>::iterator first1, vector<size_t>::iterator last1,\n    vector<size_t>::iterator first2, vector<size_t>::iterator last2,\n    Graph &g\n) {\n    vector<size_t>::iterator root=find(first2, last2, *first1);\n    if (first1+1 > first1+(root-first2)) {\n        connect(g, *root, g.size()-1);\n    } else {\n        connect(g, *root, first1[1]);\n        reconstruct_tree(first1+1, first1+(root-first2)+1, first2, root, g);\n    }\n\n    if (first1+(root-first2)+1 > last1-1) {\n        connect(g, *root, g.size()-1);\n    } else {\n        connect(g, *root, first1[(root-first2)+1]);\n        reconstruct_tree(first1+(root-first2)+1, last1, root+1, last2, g);\n    }\n}\n\nint main() {\n    size_t n;\n    scanf(\"%zu\", &n);\n\n    vector<size_t> preorder(n);\n    for (size_t i=0; i<n; ++i) {\n        scanf(\"%zu\", &preorder[i]);\n        --preorder[i];\n    }\n\n    vector<size_t> inorder(n);\n    for (size_t i=0; i<n; ++i){\n        scanf(\"%zu\", &inorder[i]);\n        --inorder[i];\n    }\n\n    Graph g(n+1);\n    reconstruct_tree(\n        preorder.begin(), preorder.end(), inorder.begin(), inorder.end(), g\n    );\n\n    size_t r=get_root(g);\n\n    vector<size_t> postorder;\n    auto postpush=[=, &postorder](size_t v)->void {\n        if (v < n)\n            postorder.push_back(v+1);\n    };\n\n    walk_postorder(g, r, postpush);\n    for (size_t i=0; i<n; ++i)\n        printf(\"%zu%c\", postorder[i], i<n-1? ' ':'\\n');\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nusing VI = vector<int>;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define IN(v) int v;cin>>v;\n#define OUT(v) cout<<v<<endl\n\nint pos = 0;\nVI pre_order, in_order, post_order;\n\ntemplate <typename T> void print(T v) {\n  cout << *(v.begin());\n  for (auto it = v.begin() + 1; it != v.end(); ++it)\n    cout << \" \" << *it;\n  cout << endl;\n}\nvoid make_tree(VI::iterator s, VI::iterator t) {\n  if (s == t)\n    return;\n  auto root = pre_order[pos++];\n  auto it = find(s, t, root);\n  make_tree(s, it);\n  make_tree(it + 1, t);\n  post_order.push_back(root);\n}\nint main() {\n  IN(N);\n\n  REP(i, N) {\n    IN(a); pre_order.push_back(a);\n  }\n  REP(i, N) {\n    IN(a); in_order.push_back(a);\n  }\n  make_tree(in_order.begin(), in_order.end());\n\n  print(post_order);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <climits>\n#include <cstring>\n#define rep(i, begin, end) for (__typeof(end) i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))\n\nusing namespace std;\n\nconst int N_MAX = 1000000;\nstring ans = \"\";\n/*\n pre: 4 2 3 1 5\n in:  3 2 4 5 1\n\n*/\nstruct Node{\n  int data;\n  Node* left;\n  Node* right;\n};\n\nvoid postorder(Node* root){\n  if(root == NULL) return;\n  postorder(root->left);\n  postorder(root->right);\n  //cout << root->data << \" \";\n  ans += (to_string(root->data) + \" \");\n}\n\n\nvoid print_array(int* arr, int len){\n  rep(i, 0, len){\n    cout << arr[i];\n    if(i==len-1) cout << endl;\n    else cout << \" \";\n  }\n}\n\nNode* solve(int* inorder, int* preorder, int len){\n  // cout << \"inorder: \" << endl;\n  // print_array(inorder, len);\n  \n  // cout << \"preorder: \" << endl;\n  // print_array(preorder, len);\n  // find root\n  int root_data = preorder[0];\n  Node* root_node = new Node;\n  root_node->data = root_data;\n  if(len==1) return root_node;\n  \n  // count all the num left\n  int left_num=0;\n  while(inorder[left_num] != root_data) left_num++;\n  int right_num = len - left_num - 1;\n  \n  int* left_inorder = new int[left_num];\n  int* right_inorder = new int[right_num];\n  \n  int* left_preorder = new int[left_num];\n  int* right_preorder = new int[right_num];\n\n  int ix=0;\n  int l_ix=0, r_ix=0;\n\n  rep(ix, 0, len){\n    if(inorder[ix] == root_data) continue;\n    if(l_ix<left_num){\n      left_inorder[l_ix] = inorder[ix];\n      l_ix++;\n    }\n    else if(r_ix<right_num){\n      right_inorder[r_ix] = inorder[ix];\n      r_ix++;\n    }\n  }\n  \n  ix = 0; l_ix = 0; r_ix = 0;\n  \n  rep(ix, 1, len){\n    if(l_ix < left_num){\n      left_preorder[l_ix] = preorder[ix];\n      l_ix++;\n    }\n    else if(r_ix < right_num){\n      right_preorder[r_ix] = preorder[ix];\n      r_ix++;\n    }\n  }\n\n  if(left_num>0) root_node->left = solve(left_inorder, left_preorder, left_num);\n  if(right_num>0) root_node->right = solve(right_inorder, right_preorder, right_num);  \n  \n  delete[] left_inorder;\n  delete[] right_inorder;\n\n  return root_node;\n  \n}\n\nint main(){\n  int n; cin >> n;\n\n  int* inorder = new int[n];\n  int* preorder = new int[n];\n  \n  int tmp;\n  rep(i, 0, n){\n    cin >> tmp;\n    preorder[i] = tmp;\n  }\n  rep(i, 0, n){\n    cin >> tmp;\n    inorder[i] = tmp;\n  }\n  Node* root = solve(inorder, preorder, n);\n  postorder(root);\n  rep(i, 0, 2*n-1) cout << ans[i]; \n  cout << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n\tif(l = r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m+1, r);\n\tpost.push_back(root);\n}\n\nvoid solve() {\n\tpos = 0;\n\trec(0, pre.size());\n\tfor(int i = 0; i < n; i++) {\n\t\tif(i) cout << \" \";\n\t\tcout << post[i]; \n\t}\n\tcout << endl;\n}\n\nint main() {\n\tint k;\n\tcin >> n;\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\t\n\tsolve();\n    \n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include\"stdio.h\"\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nclass Tree\n{\npublic:\n\tqueue <int> Pre;\n\tvector <int> In;\n\tvector <int> Post;\n\tvoid Reconstruction(int L, int R)\n\t{\n\t\tif (L >= R);\n\t\telse\n\t\t{\n\t\t\tint c = Pre.front();\n\t\t\tPre.pop();\n\t\t\tint m = distance(In.begin(), find(In.begin(), In.end(), c));\n\t\t\tReconstruction(L, m);\n\t\t\tReconstruction(m + 1, R);\n\t\t\tPost.push_back(c);\n\t\t}\n\t}\n};\n\nint main()\n{\n\tTree T;\n\tint n,t;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &t);\n\t\tT.Pre.push(t);\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &t);\n\t\tT.In.push_back(t);\n\t}\n\tT.Reconstruction(0, n);\n\tfor (int i = 0; i < n-1; i++)\n\t{\n\t\tprintf(\"%d \", T.Post[i]);\n\t}\n\tprintf(\"%d\\n\", T.Post[n - 1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int MAX=105;\nstruct Node{\n\tint parent,left,right;\n\tNode():parent(-1),left(-1),right(-1){}\n}T[MAX];\nint pre[MAX],in[MAX];\nint n,cnt=0;\nint build(int pl,int pr,int il,int ir){\n\tif(ir<il||pr<pl||pl<0||pr>=n) return -1;\n\tif(pr==pl) return pre[pl];\n\tint root=pre[pl];\n\tint p;\n\tfor(int i=il;i<=ir;i++)\n\t\tif(in[i]==root)p=i;\n\tint left=build(pl+1,pl+p-il,il,p-1);\n\tT[root].left=left;\n\tif(left!=-1)T[left].parent=root;\n\tint right=build(pl+p-il+1,pr,p+1,ir);\n\tT[root].right=right;\n\tif(right!=-1)T[right].parent=root;\n\treturn root;\n}\nvoid postorder(int i){\n\tif(T[i].left!=-1)postorder(T[i].left);\n\tif(T[i].right!=-1)postorder(T[i].right);\n\tprintf(\"%d\",i);\n\tif(cnt!=n-1)cout<<\" \";\n\tcnt++;\n}\nint main(){\n\tcin>>n;\n\tfor(int i=0;i<n;i++) cin>>pre[i];\n\tfor(int i=0;i<n;i++) cin>>in[i];\n\tbuild(0,n-1,0,n-1);\n\tint p=1;\n\twhile(T[p].parent!=-1)p=T[p].parent;\n\tpostorder(p);\n\tcout<<endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nstruct Node{int l, r, p, d, h;};\n\nNode T[100];\nint Preorder[100] = {};\nint Inorder[100] = {};\nint Postorder[100] = {};\nint n = 0;\n\nvoid SetDepth(int id, int d = 0) {\n    T[id].d = d;\n    if (T[id].l < 0) {\n    }\n}\n\nint pos = 0;\n\nint Reconstruct(int l, int r, int o = 0) {\n    if (l >= r) {\n        return o;\n    }\n    if (pos == n) {\n        return o;\n    }\n    int tgt = Preorder[pos++];\n    int idx = -1;\n    for (int i = 0; i < n; i++) {\n        if (Inorder[i] == tgt) {\n            idx = i;\n            break;\n        }\n    }\n    o = Reconstruct(l, idx, o);\n    o = Reconstruct(idx + 1, r, o);\n    Postorder[o] = tgt;\n    return ++o;\n}\n\n\nint main() {\n    std::cin >> n;\n    for (int i = 0; i < n; i++) {\n        T[i] = {-1, -1 ,-1, -1, -1};\n    }\n\n    for (int i = 0; i < n; i++) {\n        std::cin >> Preorder[i];\n    }\n\n    for (int i = 0; i < n; i++) {\n        std::cin >> Inorder[i];\n    }\n\n    Reconstruct(0, n, 0);\n    for (int i = 0; i < n; i++) {\n        if (i) std::cout << \" \";\n        std::cout << Postorder[i];\n    }\n    std::cout << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nstruct BINNODE {\n\tint parent;\n\tint left;\n\tint right;\n\n\tBINNODE () { // default constructor\n\t\tparent=-1;\n\t\tleft=-1;\n\t\tright=-1;\n\t}\n};\n\nvoid make_node(vector<int>& pre, vector<int>& in, pair<int,int> pre_indx, pair<int,int> in_indx, int parent, vector<BINNODE>& node) {\n\tint pre_found=pre_indx.first, in_found=in_indx.first;\n\n\tnode[pre[pre_indx.first]].parent=parent;\n\n\twhile(pre[pre_indx.first]!=in[in_found]) {\n\t\t++in_found;\n\t\t++pre_found;\n\t}\n\n\tif(in_found==in_indx.first) {\n\t\tnode[pre[pre_indx.first]].left=-1;\n\t} else {\n\t\tnode[pre[pre_indx.first]].left=pre[pre_indx.first+1];\n\t\tmake_node(pre,in,{pre_indx.first+1,pre_found},{in_indx.first,in_found-1},pre[0],node);\n\t}\n\tif(in_found==in_indx.second) {\n\t\tnode[pre[pre_indx.first]].right=-1;\n\t} else {\n\t\tnode[pre[pre_indx.first]].right=pre[pre_found+1];\n\t\tmake_node(pre,in,{pre_found+1,pre_indx.second},{in_found+1,in_indx.second},pre[0],node);\n\t}\n\treturn;\n}\n\n\nvoid postorderwalk(vector<BINNODE>&node, int root) {\n\tif(root==-1) return;\n\tpostorderwalk(node,node[root].left);\n\tpostorderwalk(node,node[root].right);\n\tif(node[root].parent==-1) {\n\t\tprintf(\"%d\\n\",root);\n\t} else {\n\t\tprintf(\"%d \",root);\n\t}\n\treturn;\n}\n\nint main() {\n\tint n;\n\tint i;\n\tint root;\n\tvector<int> pre,in;\n\tvector<BINNODE> node;\n\tscanf(\"%d\",&n);\n\tnode.resize(n+1);\n\tpre.resize(n);\n\tin.resize(n);\n\tfor(i=0; i<n; ++i) {\n\t\tscanf(\"%d\",&pre[i]);\n\t}\n\tfor(i=0; i<n; ++i) {\n\t\tscanf(\"%d\",&in[i]);\n\t}\n\troot=pre[0];\n\tmake_node(pre,in,{0,n-1},{0,n-1},-1,node);\n\tpostorderwalk(node,root);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//ALDS1_7D\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r){\n if(l>=r) return;\n int root=pre[pos++];\n int m=distance(in.begin(),find(in.begin(),in.end(),root));\n rec(l,m);\n rec(m+1,r);\n post.push_back(root);\n}\n\nvoid solve(){\n pos=0;\n rec(0,pre.size());\n for(int i=0;i<n;i++){\n  if(i) cout<<\" \";\n  cout<<post[i];\n }\n cout<<endl;\n}\n\nint main(){\n int k;\n cin>>n;\n for(int i=0;i<n;i++){\n  cin>>k;\n  pre.push_back(k);\n }\n for(int i=0;i<n;i++){\n  cin>>k;\n  in.push_back(k);\n }\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint N, counta;\n\nvoid print(vector<int> x, vector<int> y){\n\tint size = x.size(), temi;\n\tif(!size) return;\n\tvector<int> temp1, temp2, temp3, temp4;\n\tfor(int i = 0; i < size; i++){\n\t\tif(i)temp1.push_back(x[i]);\n\t\tif(y[i] == x[0]){ temi = i; break;}\n\t\ttemp2.push_back(y[i]);\n\t}\n\tfor(int i = temi+1; i < size; i++)temp4.push_back(y[i]),temp3.push_back(x[i]);\n\tprint(temp1,temp2);\n\tprint(temp3,temp4);\n\t\n\tcout<<(counta++?\" \":\"\")<<x[0];\n}\n\nint main(){\n\tint a;\n\tvector<int> n, m;\n\tcin>>N;\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tcin>>a;\n\t\tn.push_back(a);\n\t}\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tcin>>a;\n\t\tm.push_back(a);\n\t}\n\t\n\tprint(n,m);\n\t\n\tcout<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#incldude<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n,pos;\nvector<int>pre,in,post;\nvoid rec(int l,int r){\nif(l>=r)return 0;\nint root=pre[pos++];\nint m=distance(in.begin(),find(in.begin(),in.end(),root));\nrec(l,m);\nrec(m+1,r);\npost.push_back(root);\n}\nvoid solve(){\npos=0;\nrec(0,pre.size());\nfor(int i=0;i<n;i++){\nif(i)cout<<\" \";\ncout<<post[i];\n}\ncout<<endl;\n}\nint main(){\nint k;\ncin>>n;\nfor(int i=0;i<n;i++){\ncin>>k;\npre.push_back(k);\n}\nfor(int i=0;i<n;i++){\ncin>>k;\nin.push_back(k);\n}\nsolve();\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> pre, in;\nint n;\n\nvoid solve(int l, int r) {\n\tif (r - l == 1) {\n\t\tcout << in[l] << \" \";\n\t\tif (in[l] != pre[0]) {\n\t\t\tcout << \" \";\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = l; j < r; j++) {\n\t\t\t\tif (pre[i] == in[j]) {\n\t\t\t\t\tsolve(l, j);\n\t\t\t\t\tsolve(j + 1, r);\n\t\t\t\t\tcout << in[j];\n\t\t\t\t\tif (in[j] != pre[0]) {\n\t\t\t\t\t\tcout << \" \";\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tpre.resize(n);\n\tin.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> pre[i];\t\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> in[i];\n\t}\n\n\tsolve(0, n);\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int MAX = 50;\nconst int NIL = -1;\n\nstruct Node {\n  int parent;\n  int left;\n  int right;\n};\n\nvector<int> PRE, IN, POST;\nint pos;\n\nint find_root_idx(int A[], int n, int r) {\n  int root_idx {NIL};\n  for (root_idx = 0; root_idx < n; root_idx++) {\n    if (A[root_idx] == r) {\n      break;\n    }\n  }\n  return root_idx;\n}\n\nvoid reconstruction(int left, int right) {\n  if (left >= right) return;\n  int root = PRE[pos++];\n  int mid = distance(IN.begin(), find(IN.begin(), IN.end(), root));\n  reconstruction(left, mid);\n  reconstruction(mid + 1, right);\n  POST.push_back(root);\n}\n\n\nint main() {\n  int n, k;\n  cin >> n;\n\n  for (int i = 0; i < n; i++) {\n    cin >> k;\n    PRE.push_back(k);\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> k;\n    IN.push_back(k);\n  }\n\n  reconstruction(0, PRE.size());\n  for (int i = 0; i < n; i++) {\n    if (i) cout << \" \";\n    cout << POST.at(i);\n  }\n  cout << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint n;\nint all = 0;\nint a[200], b[200];\nvector<int> v;\nvoid depart(int left, int right) {\n\tif (left >= right)\n\t{\n\t\treturn;\n\t}\n\tint k=0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[all] == b[i]) {\n\t\t\tk = i;\n\t\t\t/*depart(i+1, right);\n\t\t\tcout << \" \";\n\t\t\tcout <<b[i];*/\n\t\t}\n\t}\n\tint t = a[all++];\n\tdepart(left, k);\n\tdepart(k+1, right);\n\tv.push_back(t);\n}\nint main(void) {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> b[i];\n\t}\n\tdepart(0, n);\n\tfor (int i = 0; i != v.size(); i++) {\n\t\tif (i) cout << \" \";\n\t\tcout << v[i];\n\t}\n\tcout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,pos;\nvector<int> pre,in,post;\nvoid rec(int l,int r){\n  if(l>=r) return;\n  int root=pre[pos++];\n  int m=distance(in.begin(),find(int.begin(),in.end(),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\nvoid solve(){\n  pos=0;\n  rec(0,pre.size());\n  REP(i,n){\n    if(i) printf(\" \");\n    printf(\"%d\",post[i]);\n  }\n  printf(\"\\n\");\n}\nint main(){\n  int k;\n  scanf(\"%d\",&n);\n  REP(i,n) {scanf(\"%d\",&k);pre.pusf_back(k);}\n  REP(i,n) {scanf(\"%d\",&k);in.pusf_back(k);}\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,pos;\nvector<int> pre,in,post;\nvoid rec(int l,int r){\n  if(l>=r) return;\n  int root=pre[pos++];\n  int m=distance(in.begin(),find(in.begin(),in.end(),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\nvoid solve(){\n  pos=0;\n  rec(0,pre.size());\n  REP(i,n){\n    if(i) printf(\" \");\n    printf(\"%d\",post[i]);\n  }\n  printf(\"\\n\");\n}\nint main(){\n  int k;\n  scanf(\"%d\",&n);\n  REP(i,n) {scanf(\"%d\",&k);pre.push_back(k);}\n  REP(i,n) {scanf(\"%d\",&k);in.push_back(k);}\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nvector<int> pre,in,post;\nint i = 0;\n\nvoid recon(int left,int right){\n    if (left >= right) return;\n    int parent = pre[i];\n    i++;\n    int mid = distance(in.begin(), find(in.begin(), in.end(), parent));\n    \n    recon(left,mid);\n    recon(mid+1,right);\n    \n    post.push_back(parent);\n}\n\nvoid solve(int size){\n    recon(0,size);\n    int n = post.size();\n    cout << post[0];\n    for (int i = 1; i < n; i++) {\n        printf(\" %d\",post[i]);\n    }\n    cout << endl;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        int a;\n        scanf(\"%d\",&a);\n        pre.push_back(a);\n    }\n    for (int i = 0; i < n; i++) {\n        int a;\n        scanf(\"%d\",&a);\n        in.push_back(a);\n    }\n    \n    solve(n);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n \n#define rep(i, n) REP(i, 0, n)\n#define REP(i, a, n) for(int i = a ; i < (int)n ; i++)\n#define pb push_back\n \nusing namespace std;\n \nvector<int> pre, in, ans;\nint n;\nint pos;\n \n \nvoid solve(int l, int r){\n  if(l - r >= 0) return;\n  int root = pre[pos];\n  pos++;\n  int d = distance(in.begin(), find(in.begin(), in.end(), root));\n  solve(l, d);\n  solve(d+1, r);\n  ans.pb(root);\n}\n \nsigned main(){\n \n  cin >> n;\n   \n  int m;\n  rep(i,n){\n    cin >> m;\n    pre.pb(m);\n  }\n  rep(i,n){\n    cin >> m;\n    in.pb(m);    \n  }\n \n  solve(0, pre.size());\n \n  cout << ans[0];\n  REP(i,1, n){\n    cout << \" \" << ans[i];\n  }\n  cout << \"\\n\";\n   \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nstruct node{\n    int left,right;\n}nodes[100];\n\nint n,pre[105],in[105],inloc[105],cnt=0;\n\nint rec(int s,int e){\n    if(s<e){\n        int m=inloc[pre[cnt++]];\n        int l=rec(s,m-1);\n        int r=rec(m+1,e);\n        nodes[in[m]].left=in[l];\n        nodes[in[m]].right=in[r];\n        return m;\n    }\n    else if(s==e){return s;}\n    else {return 0;}\n}\n\nvoid post(int r){\n    if(nodes[r].left!=0)post(nodes[r].left);\n    if(nodes[r].right!=0)post(nodes[r].right);\n    cout<<r;\n    if(r!=pre[0])cout<<\" \";\n}\n\nint main()\n{\n    memset(nodes,0,sizeof(nodes));\n    cin>>n;\n    int i;\n    for(i=0;i<n;i++){\n        cin>>pre[i];\n    }\n    for(i=0;i<n;i++){\n        cin>>in[i];\n        inloc[in[i]]=i;\n    }\n    int mm=rec(0,n-1);\n    post(pre[0]);\n    cout<<endl;\n    return 0;\n}\n//\n//int main(){\n//    int a[10]={1,2,3,4,5,32,62,23,8,33};\n//    int *b=find(a,a+10,62);\n//    int c=distance(a,b);\n//    cout<<c;\n//}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n\nint n, pos;\nstd::vector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n\tif (l >= r) return;\n\tint root = pre[pos++];\n\tint m = std::distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\nvoid solve() {\n\tpos = 0;\n\trec(0, pre.size());\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i)std::cout << \" \";\n\t\tstd::cout << post[i];\n\t}\n\tstd::cout << std::endl;\n}\n\nint main() {\n\tint k;\n\tstd::cin >> n;\n\n\tfor (int  i = 0; i < n; i++) {\n\t\tstd::cin >> k;\n\t\tpre.push_back(k);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tstd::cin >> k;\n\t\tin.push_back(k);\n\t}\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define MAX 100\n\nstruct Node {\n    int p, r, l;\n};\n\nNode T[MAX];\nint Pre[MAX], In[MAX], Post[MAX];\nint n;\n\nint postorder(int i, int n) {\n    if (T[n].l!=-1) {\n        i = postorder(i, T[n].l);\n    }\n    if (T[n].r!=-1) {\n        i = postorder(i, T[n].r);\n    }\n    Post[i] = n;\n    return i+1;\n}\n\nvoid recurcive_search(int node, int root) {\n    for (int i=0; i<n; i++) {\n        if (In[i]==node) {\n            if (T[root].l==-1) {\n                T[root].l=node;\n                T[node].p=root;\n                return;\n            } else {\n                recurcive_search(node, T[root].l);\n                return;\n            }\n        } else if (In[i]==root) {\n            if(T[root].r==-1) {\n                T[root].r=node;\n                T[root].p=root;\n                return;\n            } else {\n                recurcive_search(node, T[root].r);\n                return;\n            }\n        }\n    }\n}\n\nint reconstruct_tree() {\n    int i, root;\n    for (i=0; i<n; i++) {\n        if (i==0) root = Pre[0];\n        else {\n            recurcive_search(Pre[i], root);\n        }\n    }\n    return root;\n}\n\nint main() {\n    int i, root;\n    for (i=0; i<MAX; i++) T[i].p=T[i].l=T[i].r=-1;\n    scanf(\"%d\", &n);\n    for (i=0; i<n; i++) scanf(\"%d\", &Pre[i]);\n    for (i=0; i<n; i++) scanf(\"%d\", &In[i]);\n    \n    root = reconstruct_tree();\n    postorder(0, root);\n\n    for (i=0; i<n; i++) {\n        if (i==0) printf(\"%d\", Post[i]);\n        else printf(\" %d\", Post[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\n//preorder ??¨ inorder ?????? postorder ????§????\nvector<int> reconstruct_tree(const vector<int> &pre, const vector<int> &in) {\n\tvector<int> post;\n\tint pos = 0;\n\tfunction<void(int, int)> rec = [&](int l, int r) {\n\t\tif (l >= r)return;\n\t\tint root = pre[pos++];\n\t\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\t\trec(l, m);\n\t\trec(m + 1, r);\n\t\tpost.emplace_back(root);\n\t};\n\trec(0, pre.size());\n\treturn post;\n}\n\nsigned main() {\n\tint n; cin >> n;\n\tvector<int> pre(n), in(n);\n\trep(i, 0, n)cin >> pre[i];\n\trep(i, 0, n)cin >> in[i];\n\tvector<int> post = reconstruct_tree(pre, in);\n\tcout << post[0]; rep(i, 1, post.size()) { cout << \" \" << post[i]; } cout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, pos; vector<int> pre, in, post;\nvoid rec(int l, int r) {\n  if ( l >= r ) return;\n  int root = pre[pos++];\n  int m = distance(in.begin( ) , find(in .begin( ) , in . end( ) , root) ) ;\n  rec(l, m) ;\n  rec(m + 1 , r);\n  post.push_back(root);\n}\nvoid solve() {\n  pos = 0;\n  rec(0, pre . size()) ;\n  for ( int i = 0; i < n; i++ ) {\n    if ( i ) cout << \" \" ;\n    cout << post[i] ;\n  }\n  cout << endl;\n}\nint main() {\n  int k;\n  cin >> n;\n  for ( int i = 0; i < n; i++ ) {\n    cin >> k;\n    pre.push_back(k);\n  }\n  for ( int i = 0; i < n; i++ ) {\n    cin >> k;\n    in.push_back(k);\n  }\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,pos;\nvector<int>pre,in,post;\n\nvoid rec(int l,int r){\n  if(l>=r)return;\n  int root=pre[pos++];\n  int m=distance(in.begin(),find(in.begin(),in.end(),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\n\nvoid solve(){\n  pos=0;\n  rec(0,pre.size());\n  for(int i=0;i<n;i++){\n    if(i)cout<<\" \";\n    cout<<post[i];\n  }\n  cout<<endl;\n}\n\nint main(){\n  int k;\n  cin>>n;\n\n  for(int i=0;i<n;i++)\n    {\n      cin>>k;\n      pre.push_back(k);\n    }\n  for(int i=0;i<n;i++){\n    cin>>k;\n    in.push_back(k);\n  }\n  solve();\n\n  return 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define N 42\nint n;\nint a[N];\nint b[N];\nint c[N];\nint ai = 1;\nint ci = 1;\nvoid rebuild(int left, int right){\n    if(left == right) {\n//        printf(\"%d \", b[left]);\n        c[ci++] = b[left];\n        return ;\n    }\n    int ax = a[ai++];\n    int m = 1;\n    for(int i = 1; i <= n; i++){\n        if(b[i] == ax) m = i;\n    }\n    if(m - 1 >= left) rebuild(left, m-1);\n    if(m + 1 <= right) rebuild(m+1, right);\n//    printf(\"%d \", ax);\n    c[ci++] = ax;\n}\nint main(){\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    for(int i = 1; i <= n; i++) scanf(\"%d\", &b[i]);\n    rebuild(1, n);\n    for(int i = 1; i <= n; i++){\n        if(i == n) printf(\"%d\\n\", c[i]);\n        else printf(\"%d \", c[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nvoid rec(vector<int> &pre, vector<int> &in, vector<int> &post, int *posIndex, int l, int r)\n{\n    if (l >= r)\n    {\n        return;\n    }\n\n    int root = pre[*posIndex];\n    *posIndex = *posIndex + 1;\n\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n\n    rec(pre, in, post, posIndex, l, m);\n    rec(pre, in, post, posIndex, m+1, r);\n\n    post.push_back(root);\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n\n    vector<int> pre(N);\n    vector<int> in(N);\n    vector<int> post(0);\n\n    for (int i = 0; i < N; i++)\n    {\n        cin >> pre[i];\n    }\n\n    for (int i = 0; i < N; i++)\n    {\n        cin >> in[i];\n    }\n\n/*\n    for (int i = 0; i < N; i++)\n    {\n        cout << pre[i];\n    }\n*/\n    int *pos = new int;\n    *pos = 0;\n\n    rec(pre, in, post, pos, 0, pre.size());\n\n    for (int i = 0; i < N; i++)\n    {\n        if (i != 0)\n        {\n            cout << \" \";\n        }\n\n        cout << post[i];\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n\nusing namespace std;\n\nint n,inputed_order[41] = {0};\nqueue<int> Queue;\n\nstruct Node{\n\tNode(){\n\t\tleft_child = right_child = -1;\n\t};\n\tint left_child,right_child;\n};\n\nvoid postORDER(Node order[],int id){\n\tif(order[id].left_child != -1) postORDER(order,order[id].left_child );\n\tif(order[id].right_child != -1) postORDER(order,order[id].right_child );\n\tQueue.push(id+1);\n}\n\nint findRoot(int inorder[],int left,int right){\n\tint root = inorder[left];\n\tfor(int i = left+1; i <= right; i++){\n\t\tif(inputed_order[root] > inputed_order[inorder[i]]){\n\t\t\troot = inorder[i];\n\t\t}\n\t}\n\treturn root;\n}\n\nvoid reconstruct(int inorder[],Node order[],int root,int left,int right){\n\tint root_index;\n\tfor(root_index = left; inorder[root_index] != root; root_index++);\n\tif(left < root_index){\n\t\tint new_root = findRoot(inorder,left,root_index-1);\n\t\torder[root-1].left_child = new_root-1;\n\t\tif(left < root_index-1)\treconstruct(inorder,order,new_root,left,root_index-1);\n\t}\n\tif(root_index < right){\n\t\tint new_root = findRoot(inorder,root_index+1,right);\n\t\torder[root-1].right_child = new_root-1;\n\t\tif(root_index+1 < right) reconstruct(inorder,order,new_root,root_index+1,right);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tint preorder[n],inorder[n];\n\tNode order[n];\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\",&preorder[i]);\n\t\tinputed_order[preorder[i]] = i;\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\",&inorder[i]);\n\t}\n\n\tif(n == 1){\n\t\tprintf(\"%d\\n\",preorder[0]);\n\t}else{\n\t\treconstruct(inorder,order,preorder[0],0,n-1);\n\t\tpostORDER(order,preorder[0]-1);\n\t\twhile(!Queue.empty()){\n\t\t\tif(Queue.size() != 1){\n\t\t\t\tprintf(\"%d \",Queue.front());\n\t\t\t\tQueue.pop();\n\t\t\t}else{\n\t\t\t\tprintf(\"%d\\n\",Queue.front());\n\t\t\t\tQueue.pop();\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <assert.h>\n#include <string>\n\nusing namespace std;\n\nint tempmarge[1000100];\n\nint N, A[10000000];\n\nint preorder[1000], inorder[1000];\n\nbool bsearch(const int array[], int left, int right, int value) {\n\twhile (left + 1 < right) {\n\t\tint med = (left + right) / 2;\n\t\tif (array[med] > value)right = med;\n\t\telse left = med;\n\t}\n\treturn left < right  && array[left] == value;\n}\n\nlong long int MargeSort(int x[], int left, int right) {\n\tlong long int mid, i, j, k, cl, cr, c;\n\n\tif (left >= right)\n\t\treturn 0;\n\n\tmid = (left + right) / 2;\n\tcl = MargeSort(x, left, mid);\n\tcr = MargeSort(x, mid + 1, right);\n\n\n\tfor (i = left; i <= mid; i++)\n\t\ttempmarge[i] = x[i];\n\tfor (i = mid + 1, j = right; i <= right; i++, j--)\n\t\ttempmarge[i] = x[j];\n\n\ti = left;\n\tj = right;\n\tc = 0;\n\tfor (k = left; k <= right; k++)\n\t\tif (tempmarge[i] <= tempmarge[j])\n\t\t\tx[k] = tempmarge[i++];\n\t\telse {\n\t\t\tc += mid + 1 - i;\n\t\t\tx[k] = tempmarge[j--];\n\t\t}\n\n\treturn c + cl + cr;\n}\n\nvoid recover(int fp, int lp, int fi, int li) {\n\tint root, i;\n\tfor (i = fi; i < li + 1; i++) {\n\t\tif (preorder[fp] == inorder[i]) break;\n\t}\n\troot = i;\n\tif (fi < root) {\n\t\trecover(fp + 1, fp + root - fi, fi, root - 1);\n\t\tcout << \" \";\n\t}\n\tif (root < li) {\n\t\trecover(fp + root - fi + 1, lp, root + 1, li);\n\t\tcout << \" \";\n\t}\n\tcout << inorder[root];\n}\n\nint main() {\n\t\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> preorder[i];\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> inorder[i];\n\t}\n\n\trecover(0, N - 1, 0, N - 1);\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nqueue<int> pre;\nvector<int> in, post;\nvoid reconstruction(int left, int right)\n{\n\n\tif (left >= right)\n\t\treturn;\n\tint root = pre.front();\n\tpre.pop();\n\tint idx = distance(in.begin(), find(in.begin(), in.end(), root));\n\treconstruction(left, idx);\n\treconstruction(idx + 1, right);\n\tpost.push_back(root);\n}\nint main()\n{\n\tint n;\n\tcin >> n;\n\tin.resize(n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint t;\n\t\tcin >> t;\n\t\tpre.push(t);\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> in[i];\n\treconstruction(0, n);\n\tfor (int i = 0; i < post.size(); i++)\n\t\tif (i != post.size() - 1)\n\t\t\tcout << post[i] << \" \";\n\t\telse\n\t\t\tcout << post[i] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define NIL -1\n\nvector<int> pre, ino;\n\nclass Node\n{\n  public:\n  int p = NIL, l = NIL, r = NIL;\n};\n\nvoid postorder(vector<Node>& nodes, vector<int>& out, int cur)\n{\n    if (cur == NIL) return;\n    postorder(nodes, out, nodes.at(cur).l);\n    postorder(nodes, out, nodes.at(cur).r);\n    out.push_back(cur);\n}\n\nvoid itr_print(vector<int>& out)\n{\n    for (auto itr = out.begin(); itr != out.end(); ++itr) {\n        if (itr != out.begin()) cout << \" \";\n        cout << *itr + 1;\n    }\n    cout << endl;\n}\n\nint crt(vector<Node>& nodes, vector<int>::iterator ino_b, vector<int>::iterator ino_e, vector<int>::iterator pre_cur)\n{\n    if (ino_b == ino_e) return NIL;\n    vector<int>::iterator root;\n    while(pre_cur != ino.end()) {\n        if (ino_e == (root = find(ino_b, ino_e, *pre_cur++))) continue;\n        int l = crt(nodes, ino_b, root, pre_cur);\n        nodes.at(*root).l = l;\n        if (NIL != l) nodes.at(l).p = *root;\n        int r = crt(nodes, root + 1, ino_e, pre_cur);\n        nodes.at(*root).r = r;\n        if (NIL != r) nodes.at(r).p = *root;\n        return *root;\n    }\n    cout << \"error\" << endl;\n    return NIL;\n}\n\nint main()\n{\n    int i, n, r, el;\n    cin >> n;\n    vector<Node> nodes(n);\n    vector<int> out;\n    for (i = 0; i < n; i++) {\n        cin >> el;\n        if (i == 0) r = el - 1;\n        pre.push_back(el - 1);\n    }\n    for (i = 0; i < n; i++) {\n        cin >> el;\n        ino.push_back(el - 1);\n    }\n\n    crt(nodes, ino.begin(), ino.end(), pre.begin());\n    postorder(nodes, out, r);\n    itr_print(out);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n//ALDS1_7_B:   Binary Trees\n//ALDS1_7_C:   Tree Walk\n//ALDS1_7_D:   Reconstruction of a Tree\n//D???????????°??£????????±????§£?????§?????\\???for?????§?§£??????????????????????§£?????????\n////////////////////////////////////////\n\n#include <iostream>\n#include <algorithm> // next_permutation\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <list>\n#include <numeric> //accumulate\n//#include <unordered_map> //???????????\\??¢??°\n#include <fstream> //ifstream, ofstream\n\n//#define NDEBUG //NDEBUG???#include <cassert>???????????????????????????????????´???assert?????????????????????????????????NDEBUG?????????????????????????????????????????????\n#include <cassert> //assert\n\n\nusing namespace std;\n\n//???????????°??????TEST????????????????????¬???????????????????????????????????¢????????????\n#define TEST //*******************************************************************************************************************************************\n//?????????????????¨??§?????\\????????????????????????????????°?????????????¨???????????????????dout???????????????????????§???????????¬??????????????????????????????????????????\n//??????????????????????????????????????????????????????????§?CPU???????£??????????????????§???TLE?????????????????????????????????????????§????????¨???                           ????????????????????????cerr????????£????????????????????????????????????\n#ifdef TEST\n#define dout cout\n#else\nstringstream dummy; //???????????°??????dout?????????????????????????????????\n#define dout dummy.str(\"\"); dummy.clear(stringstream::goodbit); dummy //dummy?????????????????????????????????????????¨?????¢?????¢???????????????\n//???????????¨??????????????????goodbit?????????????????????????????¨???????????´????????????????????????????????¨?????°?????????????????§???????????????????????????????????? http://d.hatena.ne.jp/linden/20060427/p1\n#endif\n\n//?¨??????????????????????????????????????????????????????´??????OUTPUT2TEXTFILE????????????????????¬???????????????????????????????????¢????????????\n//#define OUTPUT2TEXTFILE //*******************************************************************************************************************************************\n#ifdef OUTPUT2TEXTFILE\n#define dout outputfile //??¨????????????TLE????????§?????????dout?????¨??¨??????????????¢????????????????????????????????????????????§????¨????????????´??????????????£??????????????????????¨?????????????????????????????????????????????§?????????????????????\n//TEST??????????????????????????¨???outputfile??????????????????????????????\n#define OUTPUTFILENAME \"output.txt\"\nofstream outputfile(OUTPUTFILENAME);\n#define OutputFilePath \"/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt\"\n#endif\n\n#define disp(A) dout << #A << \" = \" << (A) << endl\n#define disP(A) dout << setw(3) << (A) << \" \" // << setw(3) ??????????????\\????????????\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n\n#define dispAll(A,n) dout << #A << \" = \"; rep(j, 0, (n)) {disP(A[j]);} dout << endl\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef unsigned long long ll;\n\nconst int INF = 1e9-1;\n\nclass Node;\n\nconst int N_MAX = 25;\nvector<Node> node;\n//vi printer;\n\nint preorder[N_MAX], inorder[N_MAX];\nint x2inindex[N_MAX]; //????????°x???inorder????????§???x2inindex[x]????????????????????¨?????????\n\nint N; //num of node\nint targetPreorderIndex = 1; //????????¨??????????????????preorder[x]???index??§??????x?????????\n\nclass Node {\npublic:\n    Node() {\n        parent = -1;\n        left = -1;\n        right = -1;\n    }\n    \n    int parent;\n    int left;\n    int right;\n    \n    \n    int depth() {\n        int p = this->parent;\n        int d = 0;\n        \n        while( p != -1 ) {\n            d++;\n            p = node[p].parent;\n        }\n        \n        return d;\n    }\n    \n    static int height(int id) {\n        if(id == -1) return -1;\n        \n        return max( height(node[id].left), height(node[id].right)) + 1;\n    }\n    \n    static void printNodePreorder(int id) {\n        if(id==-1) return;\n        \n        cout << \" \" << id;\n        printNodePreorder(node[id].left);\n        printNodePreorder(node[id].right);\n    }\n    \n    static void printNodeInorder(int id) {\n        if(id==-1) return;\n        \n        printNodeInorder(node[id].left);\n        cout << \" \" << id;\n        printNodeInorder(node[id].right);\n    }\n    \n    static void printNodePostorder(int id) {\n        if(id==-1) return;\n        \n        printNodePostorder(node[id].left);\n        printNodePostorder(node[id].right);\n//        printer.push_back(id);\n                cout << \" \" << id;\n    }\n    \n    static int findTopNodeFromInorder(int left, int right) { //inorder[left ... right]??????????????????????????????????????????????????¢????????????index?????????\n        if( left > right ) return -1;\n        \n        int x = preorder[targetPreorderIndex];\n        targetPreorderIndex++;\n        \n        //inorder???2????????°?????????????????????????????°????????????\n        int leftChild = findTopNodeFromInorder(left, x2inindex[x]-1); //x?????????????????????????????°?????????\n        int rightChild = findTopNodeFromInorder(x2inindex[x]+1, right); //x?????????????????????????????°?????????\n        \n        node[x].left = leftChild;\n        node[x].right = rightChild;\n        \n        node[leftChild].parent = x;\n        node[rightChild].parent = x;\n        \n        cout << x << (x==preorder[1] ? \"\\n\" : \" \");\n        return x;\n    }\n};\n\n\n\nint main(){ //?????????1???based index??§???\n    cin >> N;\n    rep(i,0,N+1) node.push_back(*new Node()); //node[0]????????????????????????\n    \n    rep(i,1,N+1) cin >> preorder[i];\n    rep(i,1,N+1) { cin >> inorder[i]; x2inindex[ inorder[i] ] = i; }\n    \n//        //test display\n//        dispAll(preorder, N+1);\n//        dispAll(inorder, N+1);\n//        dispAll(x2inindex, N+1);\n    \n    //reconstruct the tree\n    Node::findTopNodeFromInorder(1,N);\n    \n//    //test display\n//    dout<<\"-----------------\\n\";\n//    dout << \"  i   l   r   p\\n\";\n//    rep(i,0,N+1) {\n//        disP(i);\n//        disP(node[i].left); disP(node[i].right); disP(node[i].parent);\n//        dout << endl;\n//    }\n    \n        \n//    //output\n//    rep(i,0,N+1) {\n//        cout << \"node \" << i << \": parent = \" << node[i].parent\n//        << \", sibling = \" << (node[i].parent==-1 ? -1 : (node[node[i].parent].left==i ? node[node[i].parent].right : node[node[i].parent].left) )\n//        << \", degree = \" << (node[i].left==-1 ? (node[i].right==-1 ? 0 : 1) : (node[i].right==-1 ? 1 : 2))\n//        << \", depth = \" << node[i].depth()\n//        << \", height = \" << Node::height(i) << \", \"\n//        << (node[i].parent==-1 ? \"root\" : (node[i].left==-1 && node[i].right==-1 ? \"leaf\" : \"internal node\") ) << endl;\n//    }\n\n    \n    \n//    //find root\n//    int root_i = -1;\n//    rep(i,1,N+1) {\n//        if(node[i].parent==-1) {\n//            root_i = i;\n//            break;\n//        }\n//    }\n//    assert(root_i!=-1);\n//    \n//    //print tree\n//    //    cout << \"Preorder\\n\";\n//    //    Node::printNodePreorder(root_i);\n//    //    cout << endl;\n//    //\n//    //    cout << \"Inorder\\n\";\n//    //    Node::printNodeInorder(root_i);\n//    //    cout << endl;\n//    //\n//    //    cout << \"Postorder\\n\";\n//    Node::printNodePostorder(root_i);\n//    \n//    rep(i,0,N) {\n//        if(i==0) cout << printer[i];\n//        else cout << \" \" << printer[i];\n//    }\n//    cout << endl;\n    \n    \n#ifdef OUTPUT2TEXTFILE\n    outputfile.close();\n    cout << \"\\\"\" << OutputFilePath << \"\\\"\" << endl;\n#endif\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint m=0,ans[100000],i=0;\nvoid solve(int a[],int c[],int l,int r){\n    if(l>r){\n        return;\n    }\n    int x=a[m];\n    m++;\n    solve(a,c,l,c[x]-1);\n    solve(a,c,c[x]+1,r);\n    ans[i]=x;\n    i++;\n}\nint main(){\n    int n,m,a[10000]={},b[100000]={},c[100000]={};\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>a[i];\n    }\n    for(int i=0;i<n;i++){\n        cin>>m;\n        b[i]=m;\n        c[m]=i;\n    }\n    solve(a,c,0,n-1);\n    for(int i=0;i<n-1;i++){\n        cout<<ans[i]<<\" \";\n    }\n    cout<<ans[n-1]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n\tif (l >= r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\nvoid solve() {\n\tpos = 0;\n\trec(0, pre.size());\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i) cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tint k;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define N 40\n\nvector<int> a, b, c;\n\nvoid postOrder(vector<int>::iterator a1, vector<int>::iterator a2, vector<int>::iterator b1, vector<int>::iterator b2)\n{\n    //printf(\"%d %d %d %d\\n\", *a1, *(a2 - 1), *b1, *(b2 - 1));\n    vector<int>::iterator itr;\n    c.push_back(*a1);\n    //printf(\"%d\\n\", *a1);\n    itr = find(b1, b2, *a1); //itrator of root on inorder tree walk\n    int d = itr - b1;\n    if (a1 + d + 1 < a2 && itr + 1 < b2)\n        postOrder(a1 + d + 1, a2, itr + 1, b2);\n    if (a1 + 1 < a1 + d + 1 && b1 < itr)\n        postOrder(a1 + 1, a1 + d + 1, b1, itr);\n}\n\nint main()\n{\n    int n, x;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> x;\n        a.push_back(x);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        cin >> x;\n        b.push_back(x);\n    }\n\n    postOrder(a.begin(), a.end(), b.begin(), b.end());\n\n    for (int i = 0; i < c.size(); i++)\n    {\n        if (i != 0)\n            cout << \" \";\n        cout << c[c.size() - 1 - i];\n    }\n    cout << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "///\n// File:  alds1_7_d.cpp\n// Author: ymiyamoto\n//\n// Created on Sat Oct 14 19:07:05 2017\n//\n\n#include <cstdint>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n#define SIZE 100\n\nstruct tree_t {\n  uint32_t left;\n  uint32_t right;\n};\n\nstatic vector<uint32_t> pre;\nstatic vector<uint32_t> in;\nstatic vector<uint32_t> post;\nstatic uint32_t pos;\n\nvoid reconstruct(uint32_t l, uint32_t r)\n{\n  if (l >= r) {\n    return;\n  }\n\n  uint32_t top = pre[pos];\n  pos++;\n  uint32_t mid = 0;\n  for (uint32_t i = 0; i < in.size(); i++) {\n    if (in[i] == top) {\n      mid = i;\n    }\n  }\n\n  reconstruct(l, mid);\n  reconstruct(mid + 1, r);\n\n  post.push_back(top);\n}\n\nint32_t main()\n{\n  uint32_t n;\n  cin >> n;\n\n  for (uint32_t i = 0; i < n; i++) {\n    uint32_t n;\n    cin >> n;\n    pre.push_back(n);\n  }\n\n  for (uint32_t i = 0; i < n; i++) {\n    uint32_t n;\n    cin >> n;\n    in.push_back(n);\n  }\n\n  reconstruct(0, pre.size());\n\n  for (uint32_t i = 0; i < post.size(); i++) {\n    if (i != 0) cout << \" \";\n    cout << post[i];\n  }\n\n  cout << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nint pos,n;\nvector<int> pre,in,post;\n\nvoid rec(int lo,int hi) //??????????????????\n{\n    if(lo>=hi)  //?????????\n    return;\n    int root=pre[pos++];\n    int m=distance(in.begin(),find(in.begin(),in.end(),root));\n\n    rec(lo,m);\n    rec(m+1,hi);\n\n    post.push_back(root);\n}\n\nvoid solve()\n{\n    pos=0;\n    rec(0,pre.size());\n    for(int i=0;i<n;i++)\n    {\n        if(i) cout<<\" \";\n        cout<<post[i];\n    }\n    cout<<endl;\n}\nint main()\n{\n    while(cin>>n)\n    {\n        for(int i=0;i<n;i++)\n        {\n            int j;cin>>j;\n            pre.push_back(j);\n        }\n        for(int i=0;i<n;i++)\n        {\n            int j;cin>>j;\n            in.push_back(j);\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace  std;\n\nconst int END = -1;\nstruct StNod\n{\n  int m_nParnt;\n  int m_nLeft;\n  int m_nRigt;\n\n  StNod() :\n     m_nParnt(END), m_nLeft(END), m_nRigt(END)\n  { }\n};\n\nenum EnDir\n{\n  D_Left,\n  D_Right,\n};\n\nvoid fnInput(vector<int> &rvnPodr, vector<int> &rvnIodrSeq)\n{\n  int nMaxSiz;\n\n  cin >> nMaxSiz;\n  rvnPodr.resize(nMaxSiz);\n  rvnIodrSeq.resize(nMaxSiz + 1);\n\n  for (int i = 0; i < nMaxSiz; i++)\n    cin >> rvnPodr[i];\n\n  for (int i = 1; i < nMaxSiz + 1; i++)\n  {\n    int nNode;\n    cin >> nNode;\n    rvnIodrSeq[nNode] = i;\n  }\n}\n\nvoid fnStructTree(const vector<int> &cnrvnPodr, const vector<int> &cnrvnIodrSeq, vector<StNod> &rvoNod)\n{\n  for (int i = 1; i < cnrvnPodr.size(); i++)\n  {\n    int nParnt = END;\n    int nx = cnrvnPodr[0];\n    EnDir enDir;\n    while (nx != END)\n    {\n      nParnt = nx;\n      if (cnrvnIodrSeq[ cnrvnPodr[i] ] < cnrvnIodrSeq[nx])\n      {\n        nx = rvoNod[nx].m_nLeft;\n        enDir = D_Left;\n      }\n      else\n      {\n        nx = rvoNod[nx].m_nRigt;\n        enDir = D_Right;\n      }\n    }\n\n    rvoNod[ cnrvnPodr[i] ].m_nParnt = nParnt;\n    if (enDir == D_Left)\n      rvoNod[nParnt].m_nLeft = cnrvnPodr[i];\n    else\n      rvoNod[nParnt].m_nRigt = cnrvnPodr[i];\n  }\n}\n\nvoid fnPostOrder(const vector<StNod> &cnrvoNod, int nx)\n{\n  static int stnPrt = 0;\n  if (nx == END)  return;\n\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nLeft, nOCnt);\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nRigt, nOCnt);\n  if (stnPrt++) cout << \" \";\n  cout << nx;\n}\n\nvoid fnResult(const vector<StNod> &cnrvoNod)\n{\n  int nx = 1;\n  while (cnrvoNod[nx].m_nParnt != END)\n    nx = cnrvoNod[nx].m_nParnt;\n\n  fnPostOrder(cnrvoNod, nx);\n  cout << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vector<int> vnPodr, vnIodrSeq;\n  vector<StNod> voNod;\n\n  fnInput(vnPodr, vnIodrSeq);\n\n  StNod oNod;\n  voNod.resize(vnIodrSeq.size(), oNod);\n  fnStructTree(vnPodr, vnIodrSeq, voNod);\n  \n  int nOCnt = 0;\n  fnResult(voNod);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define MAX 100\n\nstruct Node {\n    int p, r, l;\n};\n\nNode T[MAX];\nint Pre[MAX], In[MAX], Post[MAX];\nint n;\n\nint postorder(int i, int n) {\n    if (T[n].l!=-1) {\n        i = postorder(i, T[n].l);\n    }\n    if (T[n].r!=-1) {\n        i = postorder(i, T[n].r);\n    }\n    Post[i] = n;\n    return i+1;\n}\n\nvoid recurcive_search(int node, int root) {\n    for (int i=0; i<n; i++) {\n        if (In[i]==node) {\n            if (T[root].l==-1) {\n                T[root].l=node;\n                T[node].p=root;\n                return;\n            } else {\n                recurcive_search(node, T[root].l);\n                return;\n            }\n        } else {\n            if(T[root].r==-1) {\n                T[root].r=node;\n                T[root].p=root;\n                return;\n            } else {\n                recurcive_search(node, T[root].r);\n            }\n        }\n    }\n}\n\nint reconstruct_tree() {\n    int i, root;\n    for (i=0; i<n; i++) {\n        if (i==0) root = Pre[0];\n        else {\n            recurcive_search(Pre[i], root);\n        }\n    }\n    return root;\n}\n\nint main() {\n    int i, root;\n    scanf(\"%d\", &n);\n    for (i=0; i<n; i++) scanf(\"%d\", &Pre[i]);\n    for (i=0; i<n; i++) scanf(\"%d\", &In[i]);\n    for (i=0; i<n; i++) T[i].p=T[i].l=T[i].r=-1;\n    \n    root = reconstruct_tree();\n    postorder(0, root);\n\n    for (i=0; i<n; i++) {\n        if (i==0) printf(\"%d\", Post[i]);\n        else printf(\" %d\", Post[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\nconst int NIL = -1;\n\nstruct node {\n\tint parent;\n\tint left;\n\tint right;\n};\n\nvector<int> pre;\nvector<int> ino;\nint n;\n\nvoid reconstruct(int l, int r)\n{\n\tstatic int k = 0;\n\tif (l >= r) return;\n\tint c = pre[k];\n\tk++;\n\tint i = 0;\n\tfor (i = 0; i < n; ++i) {\n\t\tif (ino[i] == c) break;\n\t}\n\treconstruct(l, i);\n\treconstruct(i + 1, r);\n\tstatic int m = 0;\n\tif (m++ > 0) printf(\" \");\n\tprintf(\"%d\", c);\n\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint v;\n\t\tscanf(\"%d\", &v);\n\t\tpre.push_back(v);\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tint v;\n\t\tscanf(\"%d\", &v);\n\t\tino.push_back(v);\n\t}\n\treconstruct(0, n);\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n    if(l>= r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root)); // inorderにおけるrootの位置\n    rec(l,m);\n    rec(m+1, r);\n    post.push_back(root);\n}\n\nvoid solve(){\n    pos = 0;\n    rec(0, pre.size());\n\n    for(int i=0; i<n; i++){\n        if(i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main(int argc, char const *argv[])\n{\n    int k;\n    cin >> n;\n    for(int i=0; i<n;i++){\n        cin >> k;\n        pre.push_back(k);\n    }\n    for(int i=0; i<n; i++){\n        cin >> k;\n        in.push_back(k);\n    }\n\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nvoid getpost(int n, int *pre, int *in, int *post){\n    int m;\n    for(int i=0;i<n;i++){\n        if(in[i]==pre[0]){\n            m=i;\n            break;\n        }\n    }\n    post[n-1]=pre[0];\n    if(m>0) getpost(m, pre+1, in, post);\n    if(m<n-1) getpost(n-1-m, pre+m+1, in+m+1, post+m);\n}\n\nint main(){\n    int n;\n    cin >> n;\n    int pre[40], in[40], post[40];\n    for(int i=0;i<n;i++) cin >> pre[i];\n    for(int i=0;i<n;i++) cin >> in[i];\n    \n    getpost(n, pre, in ,post);\n    cout << post[0];\n    for(int i=1;i<n;i++) cout << ' ' << post[i];\n    cout << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n    if (l >= r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m + 1, r);\n    post.push_back(root);\n}\n\nvoid solve() {\n    pos = 0;\n    rec(0, pre.size());\n    for (int i = 0; i < n; i++) {\n        if (i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main() {\n    int k;\n    cin >> n;\n\n    for (int i = 0; i < n; i++) {\n        cin >> k;\n        pre.push_back(k);\n    }\n\n    for (int i = 0; i < n; i++) {\n        cin >> k;\n        in.push_back(k);\n    }\n\n    solve();\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstatic int pos = 0;\nstatic vector<int> pre;\nstatic vector<int> in;\nstatic vector<int> post;\n\nstatic void recursive(int left, int right)\n{\n    if (left >= right)\n        return;\n\n    int index = pre[pos++];\n    int m = (int)distance(in.begin(), find(in.begin(), in.end(), index));\n    recursive(left, m);\n    recursive(m + 1, right);\n    post.push_back(index);\n}\n\nstatic void solve()\n{\n    recursive(0, (int)pre.size());\n\n    for (int i = 0; i < post.size(); i++) {\n        if (i > 0)\n            cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main()\n{\n    int n, k;\n\n    cin >> n;\n\n    for (int i = 0; i < n; i++) {\n        cin >> k;\n        pre.push_back(k);\n    }\n\n    for (int i = 0; i < n; i++) {\n        cin >> k;\n        in.push_back(k);\n    }\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n,pos;\nvector<int>pre,in,post;\nvoid rec(int l,int r){\nif(l>=r)return;\nint root=pre[pos++];\nint m=distance(in.begin(),find(in.begin(),in.end(),root));\nrec(l,m);\nrec(m+1,r);\npost.push_back(root);\n}\nvoid solve(){\npos=0;\nrec(0,pre.size());\nfor(int i=0;i<n;i++){\nif(i)cout<<\" \";\ncout<<post[i];\n}\nint main(){\nint k;\ncin>>n;\nfor(int i=0;i<n;i++){\ncin>>k;\npre.push_back(k);\n}\nfor(int i=0;i<n;i++){\ncin>>k;\nin.push_back(k);\n}\nsolve();\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define null -1\n\nint Pre[105], In[105], cur;\n\nvector<int> post;\n\nvoid restruct( int n, int left, int right){\n\n    if( left >= right ) return;\n\n    int root = Pre[cur++];\n\n    int mid;\n\n    for( int j = 0; j < n; j++ ){\n\n        if( In[j] == root ){\n\n            mid = j;\n\n            break;\n\n        }\n\n    }\n\n    restruct( n, left, mid );\n\n    restruct( n, mid + 1, right);\n\n    post.push_back( root );\n\n}\n\nvoid solve( int n ){\n\n    cur = 0;\n\n    restruct( n, 0, n );\n\n    for( int i = 0; i < n; i++ ){\n\n        if(i) printf(\" \");\n\n        printf(\"%d\", post[i] );\n\n    }\n\n    printf(\"\\n\");\n\n}\n\n\n\nint main(){\n\n    int n, i;\n\n    scanf(\"%d\", &n);\n\n    for( i = 0; i < n; i++){\n\n        scanf(\"%d\", &Pre[i]);\n\n    }\n\n    for( i = 0; i < n; i++){\n\n        scanf(\"%d\", &In[i]);\n\n    }\n\n    solve( n );\n\n    return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n\nusing namespace std;\n\n#define mod 1000000007\nvector<int> preorder(41), inorder(41);\n\nvector<int> getpostorder(int pl, int pr, int il, int ir)\n{\n\t// pl??????pr-1????????????????¨????\n\tint root = preorder[pl];\n\tfor(int i = 0; il + i < ir; i++){\n\t\tif(inorder[il + i] == root){\n\t\t\tvector<int> left = getpostorder(pl + 1, pl + i + 1, il, il + i);\n\t\t\tvector<int> right = getpostorder(pl + i + 1, pr, il + i + 1, ir);\n\t\t\tcopy(right.begin(), right.end(), back_inserter(left));\n\t\t\tleft.push_back(root);\n\t\t\treturn left;\n\t\t}\n\t}\n\treturn vector<int>();\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> preorder[i];\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> inorder[i];\n\t}\n\tvector<int> postorder = getpostorder(0, n, 0, n);\n\tfor(int i = 0; i < n; i++){\n\t\tcout << postorder[i];\n\t\tif(i == n - 1) cout << endl;\n\t\telse cout << \" \";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ?????¬???????????¬??????\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint N, a[110], b[110];\nint l[110], r[110];\nvector<int> v;\n\n// ?????? a ??§?????? [s, t)????????? b ??§?????? [x, y) ????????? (??¨?????¨)\nvoid solve(int s, int t, int x, int y) {\n    if(t - s <= 1) return;\n    int root = a[s];\n    int idx = find(b, b+N, root) - b; // b ?????????????????????????????????\n\n    bool exist[110] = {};\n    rep(i,idx+1,y) exist[ b[i] ] = true;\n    int mi = INF; // a ?????????????????¨?????¨????§???????????????????\n    rep(i,s,t) if(exist[ a[i] ]) chmin(mi, i);\n\n    // printf(\"s = %lld, t = %lld, x = %lld, y = %lld\\n\", s, t, x, y);\n    // printf(\"root = %lld, idx = %lld, mi = %lld\\n\", root, idx, mi);\n\n    if(idx != x && idx != y-1) l[root] = a[s+1], r[root] = a[mi];\n    else if(idx == x) r[root] = a[mi];\n    else if(idx == y-1) l[root] = a[s+1];\n\n    // printf(\"l = %lld, r = %lld\\n\", l[root], r[root]);\n\n    chmin(mi, t);\n    solve(s+1, mi, x, idx);\n    solve(mi, t, idx+1, y);\n}\n\nvoid pushans(int p) {\n    if(l[p] != -1) pushans(l[p]);\n    if(r[p] != -1) pushans(r[p]);\n    v.push_back(p);\n}\n\nsigned main() {\n    cin >> N;\n    rep(i,0,N) cin >> a[i];\n    rep(i,0,N) cin >> b[i];\n\n    memset(l, -1, sizeof(l));\n    memset(r, -1, sizeof(r));\n    solve(0, N, 0, N);\n    pushans(a[0]);\n\n    rep(i,0,N) cout << (i == 0 ? \"\" : \" \") << v[i];\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<stack>\n#include<queue>\n#include<list>\n#include<set>\n#include<cmath>\n\n#define REP(i,n) for(int (i) = 0;(i) < (n);(i)++)\nusing namespace std;\nint n;\n\nclass node {\npublic:\n\tint id;\n\tint parent, child1, child2, sibling;\n\tint degree, depth, height;\n\tnode() :id(-1), parent(-1), child1(-1), child2(-1), sibling(-1), degree(0), depth(0), height(0) {};\n\n\tfriend ostream& operator<<(ostream& os, const node& N) {\n\t\tcout << \"node \" << N.id;\n\t\tcout << \": parent = \" << N.parent;\n\t\tcout << \", sibling = \" << N.sibling;\n\t\tcout << \", degree = \" << N.degree;\n\t\tcout << \", depth = \" << N.depth;\n\t\tcout << \", height = \" << N.height;\n\t\tcout << \", \";\n\t\tif (N.parent == -1) cout << \"root\";\n\t\telse if (N.child1 == -1 && N.child2 == -1) cout << \"leaf\";\n\t\telse cout << \"internal node\";\n\t\tcout << endl;\n\t}\n};\n\nvoid Pos(int n, vector<node> N) {\n\tint c1 = N[n].child1, c2 = N[n].child2;\n\tif (c1 != -1) Pos(c1-1, N);\n\tif (c2 != -1) Pos(c2-1, N);\n\tcout <<  n+1 << \" \";\n}\nvoid solve(vector<int> P, vector<int> S, vector<node> &N) {\n\tN[P[0]-1].id = P[0];\n\tint i = 0;\n\twhile (P[0] != S[i])i++;\n\tif (i>0) {\n\t\tN[P[0]-1].child1 = P[1];\n\t\tvector<int> P1, S1;\n\t\tP1.assign(P.begin() + 1, P.begin() + i + 1);\n\t\tS1.assign(S.begin(), S.begin() + i);\n\t\tsolve(P1, S1, N);\n\t}\n\tif (i<P.size() - 1) {\n\t\tN[P[0]-1].child2 = P[i + 1];\n\t\tvector<int> P1, S1;\n\t\tP1.assign(P.begin() + i + 1, P.end());\n\t\tS1.assign(S.begin() + i + 1, S.end());\n\t\tsolve(P1, S1, N);\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tvector<node> N(n);\n\tvector<int> P(n), S(n);\n\tREP(i, n) cin >> P[i];\n\tREP(i, n) cin >> S[i];\n\tsolve(P, S, N);\n\tn = P[0]-1;\n\tint c1 = N[n].child1, c2 = N[n].child2;\n\tif (c1 != -1) Pos(c1-1, N);\n\tif (c2 != -1) Pos(c2-1, N);\n\tcout << n+1 <<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing std::scanf;\nusing std::printf;\n\nstruct Node { int left, right; };\n\nint Reconstruction(int n, int preorder[], int *ppre_i,\n                   int inorder[], int in_left, int in_right, Node tree[]) {\n  int current = preorder[*ppre_i];\n  int in_mid;\n  for (int i = in_left; i < in_right; ++i) {\n    if (inorder[i] == current) {\n      in_mid = i;\n      break;\n    }\n  }\n\n  if (in_left != in_mid) {\n    *ppre_i += 1;\n    int left_child = Reconstruction(n, preorder, ppre_i,\n                                    inorder, in_left, in_mid, tree);\n    tree[current].left = left_child;\n  }\n  if (in_mid + 1 != in_right) {\n    *ppre_i += 1;\n    int right_child = Reconstruction(n, preorder, ppre_i,\n                                     inorder, in_mid + 1, in_right, tree);\n    tree[current].right = right_child;\n  }\n\n  return current;\n}\n\nvoid PrintPostorder(Node tree[], int i, int *pfirst) {\n  if (tree[i].left != -1) { PrintPostorder(tree, tree[i].left, pfirst); }\n  if (tree[i].right != -1) { PrintPostorder(tree, tree[i].right, pfirst); }\n  if (*pfirst) {\n    printf(\"%d\", i);\n    *pfirst = 0;\n  } else {\n    printf(\" %d\", i);\n  }\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  int preorder[n], inorder[n];\n  for (int i = 0; i < n; ++i) { scanf(\"%d\", &preorder[i]); }\n  for (int i = 0; i < n; ++i) { scanf(\"%d\", &inorder[i]); }\n  int pre_i = 0;\n  Node tree[n + 1];\n  for (int i = 1; i < n + 1; ++i) {\n    tree[i].left = -1;\n    tree[i].right = -1;\n  }\n  int root = Reconstruction(n, preorder, &pre_i, inorder, 0, n, tree);\n  int first = 1;\n  PrintPostorder(tree, root, &first);\n  printf(\"\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#define ll long long\n#define eps 1e-7\nusing namespace std;\n\n#define MAX 100005\n#define NIL -1\nstruct Node { int l, r, p; };\nNode T[MAX];\nint n, pos;\nvector<int> pre, in, post;\nvoid rec(int l, int r) {\n\tif (l >= r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\nvoid solve() {\n\tpos = 0;\n\trec(0, pre.size());\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (i) cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\nint main() {\n\tint k;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nclass BinaryTree {\nprivate:\n    static const int NIL = -1;\n    struct Node {\n        int parent, sibling, left, right, degree, depth, height;\n        Node() { parent = sibling = left = right = depth = height = NIL; degree = 0; }\n    };\n    std::vector<Node> T;\n    const int N = T.size();\n    int root;\npublic:\n    BinaryTree(int N) :T(N) { root = NIL; }\n    void addNode(int p, int l, int r) {\n        T[p].left = l;\n        T[p].right = r;\n        if(l != NIL) T[l].parent = p;\n        if(r != NIL) T[r].parent = p;\n    }\n    void buildPreIn(std::vector<int> &pre, std::vector<int> &in) {\n        setPreIn(pre, in, 0, pre.size());\n    }\n    void initTree() {\n        setRoot();\n        //setDepth(root, 0);\n        //setHeight(root);\n        //setSibling();\n    }\n    int getDegree(int v) {\n        return T[v].degree;\n    }\n    int getDepth(int v) {\n        return T[v].depth;\n    }\n    int getHeight(int v) {\n        return T[v].height;\n    }\n    int getParent(int v) {\n        return T[v].parent;\n    }\n    std::pair<int, int> getChildren(int v) {\n        return { T[v].left, T[v].right };\n    }\n    int getSibling(int v) {\n        return T[v].sibling;\n    }\n    int getType(int v) {\n        if (T[v].parent == NIL) return NIL;\n        if (T[v].left == NIL && T[v].right == NIL) return 1;\n        else return 0;\n    }\n    std::vector<int> getInOrder(){\n        std::vector<int> S;\n        setInOrder(S, root);\n        return S;\n    }\n    std::vector<int> getPostOrder(){\n        std::vector<int> S;\n        setPostOrder(S, root);\n        return S;\n    }\n    std::vector<int> getPreOrder(){\n        std::vector<int> S;\n        setPreOrder(S, root);\n        return S;\n    }\nprivate:\n    void setRoot() {\n        for (int i = 0; i < N; ++i)\n            if (T[i].parent == NIL) root = i;\n    }\n    void setDepth(int v, int d) {\n        if (v == NIL) return;\n        T[v].depth = d;\n        setDepth(T[v].right, d + 1);\n        setDepth(T[v].left, d + 1);\n    }\n    int setHeight(int v) {\n        int h1 = 0, h2 = 0;\n        if (T[v].left != NIL) h1 = setHeight(T[v].left) + 1;\n        if (T[v].right != NIL) h2 = setHeight(T[v].right) + 1;\n        return T[v].height = std::max(h1, h2);\n    }\n    void setSibling() {\n        for (int i = 0; i < N; ++i) {\n            if (T[i].parent == NIL) continue;\n            if (T[T[i].parent].left != i && T[T[i].parent].left != NIL)\n                T[i].sibling = T[T[i].parent].left;\n            else if (T[T[i].parent].right != i && T[T[i].parent].right != NIL)\n                T[i].sibling = T[T[i].parent].right;\n            ++T[T[i].parent].degree;\n        }\n    }\n    int setPreIn(std::vector<int> &pre, std::vector<int> &in, int l, int r) {\n        static int pos = 0;\n        if(l>=r) return NIL;\n        int root = pre[pos++];\n        int mid = std::distance(in.begin(), std::find(in.begin(), in.end(), root));\n        int ln = setPreIn(pre, in, l, mid);\n        int rn = setPreIn(pre, in, mid+1, r);\n        addNode(root, ln, rn);\n        return root;\n    }\n    void setInOrder(std::vector<int> &S, int v){\n        if(v == NIL) return;\n        setInOrder(S, T[v].left);\n        S.push_back(v);\n        setInOrder(S, T[v].right);\n    }\n    void setPostOrder(std::vector<int> &S, int v){\n        if(v == NIL) return;\n        setPostOrder(S, T[v].left);\n        setPostOrder(S, T[v].right);\n        S.push_back(v);\n    }\n    void setPreOrder(std::vector<int> &S, int v){\n        if(v == NIL) return;\n        S.push_back(v);\n        setPreOrder(S, T[v].left);\n        setPreOrder(S, T[v].right);\n    }\n};\n#include<iostream>\nusing namespace std;\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin>>n;\n    vector<int> pre(n), in(n);\n    for(int i=0;i<n;++i){\n        int v;\n        cin>>v;\n        pre[i]=v-1;\n    }\n    for(int i=0;i<n;++i){\n        int v;\n        cin>>v;\n        in[i]=v-1;\n    }\n    BinaryTree T(n);\n    T.buildPreIn(pre, in);\n    T.initTree();\n    std::vector<int> v = T.getPostOrder();\n    for(int i=0;i<v.size();++i) cout<<(i?\" \":\"\")<<v[i]+1;\n    cout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\nusing namespace std;\n#define NIL -1\n\nstruct Node {int left=NIL, right=NIL; bool visited=false;};\n\nint findPos(int n, int in[], int target) {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (in[i] == target) return i;\n\t}\n\treturn -1;\n}\n\nvoid reconstructTree(int n, Node T[], int pre[], int in[]) {\n\tint root = pre[0];\n\tfor (int i = 1; i < n; i++) {\n\t\tint target = pre[i];\n\t\tint targetPos = findPos(n, in, target);\n\t\tstack<int> st;\n\t\tst.push(root);\n\t\twhile (st.size() != 0) {\n\t\t\tint cur = st.top(); st.pop();\n\t\t\tint curPos = findPos(n, in, cur);\n\t\t\tif (targetPos < curPos) {\n\t\t\t\tif (T[cur].left == NIL) T[cur].left = target;\n\t\t\t\telse st.push(T[cur].left);\n\t\t\t} else {\n\t\t\t\tif (T[cur].right == NIL) T[cur].right = target;\n\t\t\t\telse st.push(T[cur].right);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid preOrder(Node T[], int root) {\n\tstack<int> st;\n\tst.push(root);\n\twhile (st.size() != 0) {\n\t\tint cur = T[st.top()].left;\n\t\twhile (cur != NIL && !T[cur].visited) {\n\t\t\tst.push(cur);\n\t\t\tcur = T[cur].left;\n\t\t}\n\t\tint right = T[st.top()].right;\n\t\tif (right != NIL && !T[right].visited) {\n\t\t\tst.push(right);\n\t\t} else {\n\t\t\tcur = st.top(); st.pop();\n\t\t\tcout << cur;\n\t\t\tif (st.size() != 0) cout << \" \";\n\t\t\tT[cur].visited = true;\n\t\t}\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tint pre[n], in[n];\n\tfor (int i = 0; i < n; i++) cin >> pre[i];\n\tfor (int i = 0; i < n; i++) cin >> in[i];\n\tNode T[n+1];\n\treconstructTree(n, T, pre, in);\n\tpreOrder(T, pre[0]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <iterator>\n#include<algorithm>\nstatic const int NIL = -1;\nstatic const int NumberChild = 2;\nclass Tree {\nprivate:\n\tint id;\n\tint parent;\n\tint child[NumberChild];\n\npublic:\n\tTree() {\n\t\tid = child[0] = child[1] = parent = NIL;\n\t}\n\tvoid AddParent(int ID) {\n\t\tparent = ID;\n\t\treturn;\n\t}\n\tvoid AddID(int ID) {\n\t\tid = ID;\n\t\treturn;\n\t}\n\tvoid AddChild(std::vector<int>&Child) {\n\t\tfor (unsigned int i = 0; i < Child.size(); ++i) {\n\t\t\tchild[i] = Child[i];\n\n\t\t}\n\n\t\treturn;\n\t}\n\tint GetRoot(std::vector<Tree> nodes, int ID) {\n\t\tint RootID = ID;\n\t\tif (RootID != NIL&&nodes[RootID].parent != NIL) {\n\t\t\tRootID = GetRoot(nodes, nodes[RootID].parent);\n\t\t}\n\t\treturn RootID;\n\t}\n\tvoid PreorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid InorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid PostorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t\tif(nodes[ID].id!=NIL)std::cout << \" \" << nodes[ID].id;\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid GetVctorPostorderTreeWalk(std::vector<Tree> nodes, std::vector<int>& returnvector, int ID) {\n\t\t\n\t\tif (ID != NIL) {\n\n\t\t\tGetVctorPostorderTreeWalk(nodes,  returnvector, nodes[ID].child[0]);\n\t\t\tGetVctorPostorderTreeWalk(nodes, returnvector, nodes[ID].child[1]);\n\t\t\tif (nodes[ID].id != NIL)returnvector.push_back(nodes[ID].id) ;\n\t\t}\n\n\t\treturn ;\n\t}\n\tvoid Reconstruct(const std::vector<int>Pre, const std::vector<int>In, std::vector<Tree> &nodes, const int Root,int &cnt) {\n\t\t\n\t\tint m = std::distance(In.begin(), std::find(In.begin(), In.end(), Root));\n\t\n\t\t//nodes[cnt].AddID(Root);\n\t\tnodes[Root].AddID(Root);\n\t\tif (m == 0||Root==NIL) { return; }\n\t\tstd::vector<int>PreLeft;\n\t\n\t\tstd::copy(&Pre[1], &Pre[m]+1, std::back_inserter(PreLeft));\n\t\t\n\t\tstd::vector<int>PreRight;\n\t\t\n\t\tstd::copy(&Pre[m+1 ], &Pre[Pre.size()-1]+1, std::back_inserter(PreRight));\n\t\t\n\t\tstd::vector<int>InLeft;\n\t\tstd::copy(&In[0], &In[m-1]+1, std::back_inserter(InLeft));\n\t\t\n\n\t\tstd::vector<int> InRight;\n\t\tstd::copy(&In[m]+1, &In[In.size() - 1]+1, std::back_inserter(InRight));\n\t\t\n\n\t\tstd::vector<int> child(2);\n\t\tchild = { PreLeft.empty() ? NIL : PreLeft[0], PreRight.empty() ? NIL : PreRight[0] };\n\t\t//nodes[cnt].AddChild(child);\n\t\tnodes[Root].AddChild(child);\n\t\tfor (unsigned int i = 0; i < child.size(); ++i) {\n\n\t\t\tnodes[child[i]].AddParent(Root);\n\t\t}\n\t\tReconstruct(PreLeft, InLeft, nodes, PreLeft[0], ++cnt);\n\t\tReconstruct(PreRight, InRight, nodes, PreRight[0], ++cnt);\n\t}\n};\n\nvoid SetVector(std::vector<int>&InputVector) {\n\tfor (unsigned int i = 0; i < InputVector.size(); ++i) {\n\t\tstd::cin >> InputVector[i];\n\t}\n\treturn;\n}\nint main(void) {\n\n\tint n;\n\tstd::cin >> n;\n\tstd::vector<int>Pre(n);\n\tstd::vector<int>In(n);\n\tSetVector(Pre);\n\tSetVector(In);\n\tstd::vector<Tree> nodes(n+1);\n\t//ReconstructWithNoParent\n\tint cnt = 0;\n\tnodes[1].Reconstruct(Pre, In, nodes, Pre[0],cnt);\n\n\t//nodes[1].PostorderTreeWalk(nodes, 1);\n\tstd::vector<int>Print;\n\tnodes[1].GetVctorPostorderTreeWalk(nodes, Print, 1);\n//Print=nodes[1].GetVctorPostorderTreeWalk(nodes, 1);\nfor (unsigned int i = 0; i < Print.size(); ++i) {\n\tif (i) { std::cout << \" \"; }\n\tstd::cout<<Print[i];\n\tif(i==Print.size()-1){ std::cout << std::endl; }\n}\n\t\n\t\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : ReconstructTree.cpp\n// Author      : Ken\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <vector>\n#include <sstream>\n#include <map>\nusing namespace std;\n\nclass Node{\npublic:\n\tint id;\n\tNode* p_parent;\n\tNode* p_left_child;\n\tNode* p_right_child;\n\n\tNode(): id(-1), p_parent(NULL), p_left_child(NULL), p_right_child(NULL){};\n\tNode(const int n):id(n), p_parent(NULL), p_left_child(NULL), p_right_child(NULL){}\n};\n\nvoid initializeMap(int n, map<int, Node>& nodeMap, map<int, int>& preOrderMap, map<int, int>& preOrderMapInv){\n\tfor(int i=0; i<n; i++){\n\t\tint input;\n\t\tcin >> input;\n\t\tnodeMap[input] = Node(input);\n\t\tpreOrderMap[i] = input;\n\t\tpreOrderMapInv[input] = i;\n\t}\n}\n\nvoid readInOrderList(int n, map<int, int>& inOrderMap, map<int, int>& inOrderMapInv){\n\tfor(int i=0; i<n; i++){\n\t\tint input;\n\t\tcin >> input;\n\t\tinOrderMap[i] = input;\n\t\tinOrderMapInv[input] = i;\n\t}\n}\n\nvoid reconstructTree(map<int, Node>& nodeMap,\n\t\t             map<int, int>& preOrderMap, map<int, int>& preOrderMapInv, int pre_start, int pre_end,\n\t\t             map<int, int>& inOrderMap, map<int, int>& inOrderMapInv, int in_start, int in_end){\n\tif(pre_start == pre_end - 1){\n\t\treturn;\n\t}\n\n\tint leftMaxPos = pre_start;\n\tNode& root = nodeMap[preOrderMap[pre_start]];\n    int rootPosInOrder = inOrderMapInv[preOrderMap[pre_start]];\n\n\tif(preOrderMap[pre_start] != inOrderMap[in_start]){\n\t    Node& left_child = nodeMap[preOrderMap[pre_start + 1]];\n\t    root.p_left_child = &left_child;\n\t    //cout << \"root: \" << root.id << \"\\n\";\n\t    left_child.p_parent = &root;\n\t    //cout << \"left_child: \" << left_child.id << \"\\n\";\n\n\n\t    for(int i=in_start; i<rootPosInOrder; i++){\n\t    \tint position = preOrderMapInv[inOrderMap[i]];\n\t\t    if(position > leftMaxPos){\n\t\t\t    leftMaxPos = position;\n\t\t    }\n\t    }\n\t\t//cout << \"reconstructTree \" << pre_start+1 << \" \" << leftMaxPos+1 << \" \" << in_start << \" \" << rootPosInOrder << \"\\n\";\n\t\treconstructTree(nodeMap,\n\t                    preOrderMap, preOrderMapInv, pre_start+1, leftMaxPos+1,\n\t\t\t\t\t\tinOrderMap, inOrderMapInv, in_start, rootPosInOrder);\n\t}\n\n\tif(preOrderMap[pre_start] != inOrderMap[in_end-1]){\n\t    Node& right_child = nodeMap[preOrderMap[leftMaxPos+1]];\n\t    root.p_right_child = &right_child;\n\t    right_child.p_parent = &root;\n\t//cout << \"right_child: \" << right_child.id << \"\\n\";\n\n\n\t//cout << \"reconstructTree \" << leftMaxPos+1 << \" \" << pre_end << \" \" << rootPosInOrder+1 << \" \" << in_end << \"\\n\";\n\t    reconstructTree(nodeMap,\n\t\t\t        preOrderMap, preOrderMapInv, leftMaxPos+1, pre_end,\n\t\t\t\t\tinOrderMap, inOrderMapInv, rootPosInOrder+1, in_end);\n\t}\n}\n\nvoid writeMap(map<int, int> int_map){\n\tfor(pair<int, int> element: int_map){\n\t\tcout << element.first << \"->\" << element.second << \"\\n\";\n\t}\n\tcout << \"\\n\";\n}\n\nvoid writeMap(map<int, Node> nodeMap){\n\tfor(pair<int, Node> element:nodeMap){\n\t\tNode& node = element.second;\n\t\tint parent = -1, left_child = -1, right_child = -1;\n\t\tif(node.p_parent != NULL){\n\t\t\tparent = node.p_parent->id;\n\t\t}\n\t\tif(node.p_left_child != NULL){\n\t\t\tleft_child = node.p_left_child->id;\n\t\t}\n\t\tif(node.p_right_child != NULL){\n\t\t\tright_child = node.p_right_child->id;\n\t\t}\n\n\t\t//cout << \"id:\" << node.id << \" parent:\" << parent << \" left_child:\" << left_child\n\t\t//\t << \" right_child:\" << right_child << \"\\n\";\n\t}\n}\n\nvoid writePostOrder(Node& node, stringstream& ss){\n\tif(node.p_left_child != NULL){\n\t    writePostOrder(*(node.p_left_child), ss);\n\t}\n\n\tif(node.p_right_child != NULL){\n\t    writePostOrder(*(node.p_right_child), ss);\n\t}\n\tss << node.id << \" \";\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tmap<int, Node> nodeMap;\n\tmap<int, int> preOrderMap;\n\tmap<int, int> preOrderMapInv;\n\tmap<int, int> inOrderMap;\n\tmap<int, int> inOrderMapInv;\n\n\t//cout << \"initializeMap\\n\";\n    initializeMap(n, nodeMap, preOrderMap, preOrderMapInv);\n    //cout << \"readInOrderList\\n\";\n\treadInOrderList(n, inOrderMap, inOrderMapInv);\n\n\t//writeMap(preOrderMap);\n\t//writeMap(preOrderMapInv);\n\t//writeMap(inOrderMap);\n\t//writeMap(inOrderMapInv);\n\n\t//cout << \"reconstructTree\\n\";\n\treconstructTree(nodeMap, preOrderMap, preOrderMapInv, 0, n, inOrderMap, inOrderMapInv, 0, n);\n\t//writeMap(nodeMap);\n\n\tstringstream ss;\n\tNode& root = nodeMap[preOrderMap[0]];\n\n\n\twritePostOrder(root, ss);\n\tstring str = ss.str();\n\tcout << str.substr(0, str.size()-1) << \"\\n\";\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,a,b) for(int i=a;i<=b;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define vi vector<int>\n#define pb push_back\n#define pi pair<int,int>\n#define vp vector<pair<int,int> >\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\n\nvi pre,in,post;\nint root;\n\nvoid rec(int l,int r){\n    if(r-l<1)return;\n    int m;\n    Rep(i,l,r){\n        if(in[i]==pre[root]){\n            m=i;\n            root++;\n            break;\n        }\n    }\n    rec(l,m);\n    rec(m+1,r);\n    post.pb(in[m]);\n}\n\nsigned main(){\n    int n;\n    cin>>n;\n    int v;\n    rep(i,n){\n        cin>>v;\n        pre.pb(v);\n    }\n    rep(i,n){\n        cin>>v;\n        in.pb(v);\n    }\n    rec(0,n);\n    rep(i,n){\n        cout<<post[i]<<(i!=n-1?' ':'\\n');\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define MAX 101\n#define NIL -1\n\nint pre[MAX],in[MAX];\nvector<int> post;\nint n,pos;\nvoid rec(int l,int r){\n    if(l>=r)\n        return ;\n    int c = pre[pos++];\n    int m;\n    for(int i=0;i<n;i++){\n        if(in[i]== c)\n            m = i;\n    }\n    rec(l,m);\n    rec(m+1,r);\n    post.push_back(c);\n}\nvoid solve(){\n    pos = 0;\n    rec(0,n);\n    for(int i=0;i<n;i++){\n        if(i) cout<<\" \";\n        cout<<post[i];\n    }\n    cout<<endl;\n}\nint main()\n{\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>pre[i];\n    }\n    for(int i=0;i<n;i++){\n        cin>>in[i];\n    }\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nvector<int> L;\n\nstruct Vertex{\n\tint left;\n\tint right;\n};\n\nvoid Postorder(vector<Vertex> &T,int root){\n\tif(T[root].left!=-1) Postorder(T,T[root].left);\n\tif(T[root].right!=-1) Postorder(T,T[root].right);\n\tL.push_back(root+1);\n\treturn;\n}\n\nvoid Reconstruction(vector<Vertex> &T, vector<int> &Pre,vector<int> &In,int p,int q,int s,int t){\n\tint root = Pre[p];\n\tif(p==q){\n\t\tT[root].left=-1;\n\t\tT[root].right=-1;\n\t\treturn ;\n\t}\n\t\n\tvector<bool> check(1000000,false);\n\t\n\t//k???In????????????root?????????????????????\n\tint k=-1;\n\tfor(int i=s;i<t+1;i++){\n\t\tcheck[In[i]]=true;\n\t\tif (In[i]==root){\n\t\t\tk=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//l???Pre?????????????????´?????¨???????????????????????????????????????\n\tint l=p;\n\twhile(l<q){\n\t\tl++;\n\t\tif(check[Pre[l]]==false){\n\t\t\tl--;\n\t\t\tbreak;\n\t\t}\n\t\tif(l==q) break;\n\t}\n\t\n\tif(s==k){\n\t\tT[root].left=-1;\n\t\tT[root].right=Pre[l+1];\n\t\n\t\tReconstruction(T,Pre,In,l+1,q,k+1,t);\n\t}else if(t==k){\n\t\tT[root].left=Pre[p+1];\n\t\tT[root].right=-1;\n\t\n\t\tReconstruction(T,Pre,In,p+1,l,s,k-1);\n\t}else{\n\t\tT[root].left=Pre[p+1];\n\t\tT[root].right=Pre[l+1];\n\t\n\t\tReconstruction(T,Pre,In,p+1,l,s,k-1);\n\t\tReconstruction(T,Pre,In,l+1,q,k+1,t);\n\t}\n}\n\nint main(){\n\tint n,x;\n\tcin >> n;\n\tvector<int> Pre(n);\n\tvector<int> In(n);\n\tfor (int i=0;i<n;i++){\n\t\tcin >> x;\n\t\tPre[i]=x-1;\n\t}\n\t\n\tfor (int i=0;i<n;i++){\n\t\tcin >> x;\n\t\tIn[i]=x-1;\n\t}\n\t\n\tvector<Vertex> T(n);\n\tReconstruction(T,Pre,In,0,n-1,0,n-1);\n\tPostorder(T,Pre[0]);\n\t\n\tfor (int i=0;i<L.size();i++){\n\t\tif(i==L.size()-1){\n\t\t\tcout << L[i] <<endl;\n\t\t}else{\n\t\t\tcout << L[i] <<\" \";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h> #include <queue> using namespace std; int n,inputed_order[41] = {0}; queue<int> Queue; struct Node{ Node(){ left_child = right_child = -1; }; int left_child,right_child; }; void postORDER(Node order[],int id){ if(order[id].left_child != -1) postORDER(order,order[id].left_child ); if(order[id].right_child != -1) postORDER(order,order[id].right_child ); Queue.push(id+1); } int findRoot(int inorder[],int left,int right){ int root = inorder[left]; for(int i = left+1; i <= right; i++){ if(inputed_order[root] > inputed_order[inorder[i]]){ root = inorder[i]; } } return root; } void reconstruct(int inorder[],Node order[],int root,int left,int right){ int root_index; for(root_index = left; inorder[root_index] != root; root_index++); if(left < root_index){ int new_root = findRoot(inorder,left,root_index-1); order[root-1].left_child = new_root-1; if(left < root_index-1) reconstruct(inorder,order,new_root,left,root_index-1); } if(root_index < right){ int new_root = findRoot(inorder,root_index+1,right); order[root-1].right_child = new_root-1; if(root_index+1 < right) reconstruct(inorder,order,new_root,root_index+1,right); } } int main(){ scanf(\"%d\",&n); int preorder[n],inorder[n]; Node order[n]; for(int i = 0; i < n; i++){ scanf(\"%d\",&preorder[i]); inputed_order[preorder[i]] = i; } for(int i = 0; i < n; i++){ scanf(\"%d\",&inorder[i]); } if(n == 1){ printf(\"%d\\n\",preorder[0]); }else{ reconstruct(inorder,order,preorder[0],0,n-1); postORDER(order,preorder[0]-1); while(!Queue.empty()){ if(Queue.size() != 1){ printf(\"%d \",Queue.front()); Queue.pop(); }else{ printf(\"%d\\n\",Queue.front()); Queue.pop(); } } } } \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\nint n;\nvector<int> pre, in, post;\nint pos = 0;\n\nvoid rec(int l, int r) {\n    if (l >= r) {\n        return;\n    }\n    int root = pre[pos++];\n    int m;\n    int d = 0;\n    for (vector<int>::iterator i = in.begin(); i != in.end(); i++, d++) {\n        if (*i == root) {\n            m = d;\n            break;\n        }\n    }\n    rec(l, m);\n    rec(m + 1, r);\n    post.push_back(root);\n}\n\nvoid solve() {\n    rec(0, n);\n    for (int i = 0; i < n; i++) {\n        if (i) {\n            cout << \" \";\n        }\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main() {\n    cin >> n;\n    int k;\n    for (int i = 0; i < n; i++) {\n        cin >> k;\n        pre.push_back(k);\n    }\n    for (int j = 0; j < n; j++) {\n        cin >> k;\n        in.push_back(k);\n    }\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(int i=0;i<(num);++i)\n#define ALL(c) c.begin(),c.end()\n#define PRINTALL(c) for(auto& x:c){cout<<x<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=int>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=int,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in<T>();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\nclass RootedNode{\npublic:\n\tvector<ll> parent;\n\tll depth,dist;\n\tRootedNode():depth(0),dist(0){}\n};\n\nclass ConnectNodeInfo{\n\tvector<vector<pair<ll,ll>>> graph;\npublic:\n\tmap<int,int> input;\n\tConnectNodeInfo(int node_num){\n\t\tgraph.resize(node_num);\n\t}\n\tvoid AddNonDirectionalConnection(ll u,ll v,ll w){\n\t\tgraph[u].emplace_back(v,w);\n\t\tgraph[v].emplace_back(u,w);\n\t}\n\tvoid AddDirectionalConnection(ll u,ll v,ll w){\n\t\tgraph[u].emplace_back(v,w);\n\t\tinput[v]++;\n\t}\n\tvector<pair<ll,ll>>& operator[](ll index){\n\t\treturn graph[index];\n\t}\n\tsize_t size(){return graph.size();}\n};\n\nclass RootedTree{\n\tint parent_size;\n\n\tvoid DFS(ConnectNodeInfo& connection,ll child,ll parent,ll dep,ll dist){\n\t\tnode[child].parent[0] = parent;\n\t\tnode[child].depth = dep;\n\t\tnode[child].dist = dist;\n\n\t\tint num=0;\n\t\tfor(int i = 0;i < connection[child].size();i++){\n\t\t\tint cn = connection[child][i].first;\n\t\t\tDFS(connection,connection[child][i].first,child,dep+1,dist+connection[child][i].second);\n\t\t}\n\t\tpostorder.push_back(child);\n\t}\npublic:\n\tvector<RootedNode> node;\n\tvector<int> postorder;\n\n\tRootedTree(ConnectNodeInfo& connection,int root){\n\t\tauto connection_size = connection.size();\n\t\tparent_size = 1;\n\t\twhile((1LL<<parent_size)<connection_size) parent_size++;\n\n\t\tnode.resize(connection_size);\n\t\tfor(auto& x:node) x.parent.resize(parent_size,-1);\n\t\tDFS(connection,root,-1,0,0);\n\t\tfor(int k=0;k<parent_size-1;k++){\n\t\t\tfor(int v=0,ev=connection_size;v<ev;v++){\n\t\t\t\tif(node[v].parent[k] < 0) node[v].parent[k+1] = -1;\n\t\t\t\telse node[v].parent[k+1] = node[node[v].parent[k]].parent[k];\n\t\t\t}\n\t\t}\n\t}\n};\n\nint DivideTree(ConnectNodeInfo& connect,vector<int>& preorder,vector<int> inorder){\n\tint root = preorder[0];\n\tauto pos = find(ALL(inorder),root);\n\n\tvector<int> left_inorder(inorder.begin(),pos);\n\tvector<int> left_preorder(preorder.begin()+1,preorder.begin()+1+left_inorder.size());\n\n\tif(!left_inorder.empty()){\n\t\tint left_node = DivideTree(connect,left_preorder,left_inorder);\n\t\tconnect.AddDirectionalConnection(root-1,left_node-1,1);\n\t}\n\n\tvector<int> right_inorder(pos+1,inorder.end());\n\tvector<int> right_preorder(preorder.begin()+1+left_inorder.size(),preorder.end());\n\n\tif(!right_inorder.empty()){\n\t\tint right_node = DivideTree(connect,right_preorder,right_inorder);\n\t\tconnect.AddDirectionalConnection(root-1,right_node-1,1);\n\t}\n\n\treturn root;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N=in();\n\tauto preorder=vecin(N);\n\tauto inorder=vecin(N);\n\tConnectNodeInfo connect(N);\n\n\tint root = DivideTree(connect,preorder,inorder);\n\tRootedTree tree(connect,root-1);\n\n\tREP(i,N-1){\n\t\tcout << tree.postorder[i]+1 << ' ';\n\t}\n\tout(tree.postorder.back()+1);\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n \nint n,pos;\nvector<int> pre,in,post;\n \nvoid rec(int l,int r){\n    if(l>=r)\n        return;\n    int root = pre[pos++];\n    int m = distance(in.begin(),find(in.begin(),in.end(),root));\n    rec(l,m);\n    rec(m+1,r);\n    post.push_back(root);\n}\n \nvoid solve(){\n    pos = 0;\n    rec(0,pre.size());\n    for(int i=0;i<n;i++){\n        if(i)\n            cout<<\" \";\n        cout<<post[i];\n    }\n    cout<<endl;\n}\n \nint main(){\n    int k;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>k;\n        pre.push_back(k);\n    }\n \n    for(int i=0;i<n;i++){\n        cin>>k;\n        in.push_back(k);\n    }\n    solve();\n}\n \n\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<int> pre, in, post;\nint position = 0;\n\nvoid reconstruction(int left, int right) {\n  if (left >= right) return;\n  int root = pre[position];\n  position++;\n  int in_pos = distance(in.begin(), find(in.begin(), in.end(), root));\n  reconstruction(left, in_pos);\n  reconstruction(in_pos + 1, right);\n  post.push_back(root);\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n\n  int id;\n  for (int i = 0; i < n; i++) {\n    cin >> id;\n    pre.push_back(id);\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> id;\n    in.push_back(id);\n  }\n\n  reconstruction(0, n);\n\n  for (int i = 0; i < n; i++) {\n    if (i != 0) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector <int> pre,in,post;\nint pos=0;\nvoid rec(int l,int r){\n    if (l>=r)\n        return;\n    int root=pre[pos++];\n    int mid=distance(in.begin(),find(in.begin(),in.end(),root));\n    rec(l,mid);\n    rec(mid+1,r);\n    post.push_back(root);\n}\nint main(){\n    int n;\n    cin>>n;\n    int temp;\n    for(int i=0;i<n;i++){\n        cin>>temp;\n        pre.push_back(temp);\n    }\n    for(int i=0;i<n;i++){\n        cin>>temp;\n        in.push_back(temp);\n    }\n    rec(0,n);\n    for(int i=0;i<n-1;i++)\n        cout<<post[i]<<\" \";\n    cout<<post[n-1]<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (ll i = 0; i < n; i++)\n#define PI 3.14159265358979323846\n#define vll vector<long long>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\n// ----本問について----\n// 問題：Reconstruction of a Tree\n// 問題文URL：https://onlinejudge.u-aizu.ac.jp/problems/ALDS1_7_D\n// 所要時間：\n// 学んだこと：\n// ------------------\n\n// ----ここから本問のソースコード----\n\n// グローバル変数（入力）\nll n;\nvll pre, in;\n\n// 二分木をpostorderで出力する\n// 木はpreorderの[pl,pr)，inorderの[il,ir)を情報として利用する．\nvoid ReconstructTree(ll pl, ll pr, ll il, ll ir) {\n  ll root = pre[pl]; // 根の値\n  ll rootIndex;\n\n  // inorder中の根のインデックスを探る\n  for (ll i = il; i < ir; i++) {\n    if (in[i] == root) {\n      rootIndex = i;\n      break;\n    }\n  }\n\n  if (rootIndex > il) { // 左側が存在したら\n    ReconstructTree(pl + 1, pl + 1 + rootIndex - il, il, rootIndex);\n  }\n\n  if (rootIndex < ir - 1) { // 右側が存在したら\n    ReconstructTree(pr - ir + rootIndex + 1, pr, rootIndex + 1, ir);\n  }\n\n  // 根を出力\n  cout << root;\n  if (!(pl == 0 && pr == n)) { cout << \" \"; } // 最後以外空白を入れる\n}\n\nvoid solve() {\n  ReconstructTree(0, n, 0, n);\n  cout << endl;\n}\n\nint main() {\n  cin >> n;\n  rep(i, n) {\n    ll a;\n    cin >> a;\n    pre.push_back(a);\n  }\n  rep(i, n) {\n    ll a;\n    cin >> a;\n    in.push_back(a);\n  }\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n \nstruct node{\n    int l,r;\n};\nnode v[41];\nvector<int> postord;\nvoid dfs(int vi){\n    if(v[vi].l!=-1)dfs(v[vi].l);\n    if(v[vi].r!=-1)dfs(v[vi].r);\n    postord.pb(vi);\n}\nint pre[41],in[41];\nint main(){\n    int n,root;\n    cin>>n;\n    rep(i,n) cin>>pre[i];\n    rep(i,n) cin>>in[i];\n    rep(i,41) v[i].l=v[i].r=-1;\n    root=pre[0];\n    int cp=0,ci=0;\n    while(cp<n-1&&pre[cp]>0){\n        v[pre[cp]].l=pre[cp+1];++cp;\n        while(cp<n&&pre[cp]==in[ci]){\n            ++ci;\n            while(ci<n-1&&in[ci]>0&&v[in[ci]].l==in[ci+1]) ++ci;\n            if(ci>=n-1){\n                cp=n;break;\n            }\n            v[in[ci]].r=in[ci+1];++ci;\n            ++cp;\n        } \n    }\n    dfs(root);\n    rep(i,n) cout<<postord[i]<<(i==n-1?\"\":\" \");\n    cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, a, b) for (int i = a; i < (int)(b); ++i)\n#define rrep(i, a, b) for (int i = b - 1; i >= (int)(a); --i)\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\n\nvoid check(const vi& pre, const vi& in, int& pos, int l, int r) {\n    int n = pre.size();\n\n    if (l < r && pos < n) {\n        int root = pre[pos++];\n        int mid = distance(in.begin(), find(in.begin(), in.end(), root));\n\n        check(pre, in, pos, l, mid);\n        check(pre, in, pos, mid + 1, r);\n\n        cout << root + 1;\n        if (!(l == 0 && r == n)) { cout << \" \"; }\n        else { cout << endl; }\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vi pre(n), in(n);\n\n    rep(i, 0, n) {\n        int k;\n        cin >> k;\n        pre[i] = k - 1;\n    }\n\n    rep(i, 0, n) {\n        int k;\n        cin >> k;\n        in[i] = k - 1;\n    }\n\n    int pos = 0;\n    check(pre, in, pos, 0, n);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n// find(pointer1,pointer2,val) => find the first value == val in the range pointer1 to pointer 2, return the address\n// distance(pointer1, pointer2) => return the integer that represent how many entries between the 2 pointers\n\nint cnt = 0;\nvector<int> pre, in, post;\n\nvoid rec(int lo, int hi) {\n\tif (lo >= hi) return;\n\tint root = pre[cnt++];\n\tint\tinpos = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(lo, inpos);\n\trec(inpos + 1, hi);\n\tpost.push_back(root);\n}\n\nint main() {\n\tint len;\n\tcin >> len;\n\tint id;\n\tfor (int i = 0; i < len; i++) {\n\t\tcin >> id;\n\t\tpre.push_back(id);\n\t}\n\tfor (int i = 0; i < len; i++) {\n\t\tcin >> id;\n\t\tin.push_back(id);\n\t}\n\trec(0, len);\n\tfor (int i = 0; i < len; i++) {\n\t\tif (i) cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n,s[50],ans[50],a;\n  vector<int> t;\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>a,s[a]=i,ans[i]=a;\n  for(int i=0;i<n;i++)cin>>a,t.push_back(s[a]);\n  t.push_back(100);\n  while(1){\n    if(t.size()==2){\n      cout<<ans[0]<<endl;\n      break;\n    }\n    for(int i=0;i<t.size()-1;i++){\n      if(t[i]>t[i+1]){\n        cout<<ans[t[i]]<<\" \";\n        t.erase(t.begin()+i);\n        break;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nvector<int> pre,in,post;\nint id;\n\nvoid rec(int l,int r){\n    if(l<r){\n    int root=pre[id++];\n    int m=distance(in.begin(),find(in.begin(),in.end(),root));\n    rec(l,m);\n    rec(m+1,r);\n    post.push_back(root);\n    }\n    return;\n}\n\nvoid solve(){\n    id=0;\n    rec(0,pre.size());\n    rep(i,pre.size()){\n        if(i!=0)printf(\" \");\n        printf(\"%d\",post[i]);\n    }\n    printf(\"\\n\");\n    return;\n}\n\nint main(){\n    int n,key;cin>>n;\n    rep(i,n){\n        scanf(\"%d\",&key);\n        pre.push_back(key);\n    }\n    rep(i,n){\n        scanf(\"%d\",&key);\n        in.push_back(key);\n    }\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l,int r){\n\tif(l >= r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l,m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\nvoid solve(){\n\tpos = 0;\n\trec(0, pre.size());\n\tfor(int i = 0; i < n; i++){\n\t\tif(i)cout << \" \";\n\t\tcout << post[i];\n\t}\n\t\n\tcout << endl;\n}\n\n\nint main(){\n\tint k;\n\tcin >> n;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\t\n\tfor(int i=0; i<n; i++){\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\t\n\tsolve();\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n \nusing namespace std;\n \nint n,inputed_order[41] = {0};\nqueue<int> Queue;\n \nstruct Node{\n    Node(){\n        left_child = right_child = -1;\n    };\n    int left_child,right_child;\n};\n \nvoid postORDER(Node order[],int id){\n    if(order[id].left_child != -1) postORDER(order,order[id].left_child );\n    if(order[id].right_child != -1) postORDER(order,order[id].right_child );\n    Queue.push(id+1);\n}\n \nint findRoot(int inorder[],int left,int right){\n    int root = inorder[left];\n    for(int i = left+1; i <= right; i++){\n        if(inputed_order[root] > inputed_order[inorder[i]]){\n            root = inorder[i];\n        }\n    }\n    return root;\n}\n \nvoid reconstruct(int inorder[],Node order[],int root,int left,int right){\n    int root_index;\n    for(root_index = left; inorder[root_index] != root; root_index++);\n    if(left < root_index){\n        int new_root = findRoot(inorder,left,root_index-1);\n        order[root-1].left_child = new_root-1;\n        if(left < root_index-1)  reconstruct(inorder,order,new_root,left,root_index-1);\n    }\n    if(root_index < right){\n        int new_root = findRoot(inorder,root_index+1,right);\n        order[root-1].right_child = new_root-1;\n        if(root_index+1 < right) reconstruct(inorder,order,new_root,root_index+1,right);\n    }\n}\n \nint main(){\n    scanf(\"%d\",&n);\n    int preorder[n],inorder[n];\n    Node order[n];\n \n    for(int i = 0; i < n; i++){\n        scanf(\"%d\",&preorder[i]);\n        inputed_order[preorder[i]] = i;\n    }\n    for(int i = 0; i < n; i++){\n        scanf(\"%d\",&inorder[i]);\n    }\n \n    if(n == 1){\n        printf(\"%d\\n\",preorder[0]);\n    }else{\n        reconstruct(inorder,order,preorder[0],0,n-1);\n        postORDER(order,preorder[0]-1);\n        while(!Queue.empty()){\n            if(Queue.size() != 1){\n                printf(\"%d \",Queue.front());\n                Queue.pop();\n            }else{\n                printf(\"%d\\n\",Queue.front());\n                Queue.pop();\n            }\n        }\n    }\n \n}\n"
  },
  {
    "language": "C++",
    "code": "/////////////////////////////////////////////////////////\n//\n//  ~/Izumi_Chiharu/c/temp.cpp file\n//  Last Updated: 2018-06-17 ...Maybe\n//\n//    I hope you adding this code to the setting file\n//    alias g++='g++ -std=c++1y -DDEBUG_LOCAL'\n//\n//  My sweet heart Chiharu Izumi\n//\n/////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid print_Qbey(){cout<<\n\"           H                                           M#5J~d              \"  <<endl<<\n\"         Hm.?WMM                                   MMB^ .Z  d              \"  <<endl<<\n\"         MZS.` ?7WMM                             M#=`` (!`` d              \"  <<endl<<\n\"         HP?X,```  ?TMM                       MMY! ` .d: `` d              \"  <<endl<<\n\"         Hb;<U,`````` (TMM                 HM ^ ``` .V>_` `.W              \"  <<endl<<\n\"           ;><?n. `` ````?WHHMMHHHMMMMMM MMY```` ` (3<< `` .M              \"  <<endl<<\n\"         HN<>>>?W,`` `` ` (77!~`  ```~!?7'``` `` .d>>><``  .M              \"  <<endl<<\n\"          M2<>>>>?n.`` `` `` `` ``` `` ```` `` `.X>1++< `` (H              \"  <<endl<<\n\"          MK<>>>>+?S.``` `` ```` ``` ``` `` `` .Z``` ?4-.` jM              \"  <<endl<<\n\"           N2><+d=(Y^ `` `` ` ` ` ` `` `` `` `` T~.`````?=(dM              \"  <<endl<<\n\"           MR;JY~`~``` `` `` ``` ``` `` `` `` ``` u, `` `` 7M              \"  <<endl<<\n\"            NV!_`` `` `` ```` ``` `` `` `` ``` ``` C& ` ```` TMM           \"  <<endl<<\n\"           MY.(-`` ` `` ``  `` ` `` `` `` `` ``  `` (n ` ` ``` 7M          \"  <<endl<<\n\"         HMD-(D`` ``` `` ``` `` `` `` `` `` ` ``` ```(n ` `` `` (WM        \"  <<endl<<\n\"         M _(d```` `` ``` ``` ``` `` `` `` ``` ``` `` .b.`` `` ```?MH      \"  <<endl<<\n\"        MM!_(%` `` `` `` ` ` `` `` `` ``` `` `` ` `` ` (l`` ``````` TMH    \"  <<endl<<\n\"       H#>__d:`` .JXVS, ``` `` ` `` `` `.JXWH&.``` ```` O; `` ` ` `` -WM   \"  <<endl<<\n\"       M%.~(k ``.HXH[ dr ```` ``` `` `` dWWN- u. `` ``` ,M,``` ``` ``` ?MMM\"  <<endl<<\n\"      MF_~~($`` .WXMMWX$ ` ``` `` ``` ` dXM HHK````` `` ,HN-``````````.-=jg\"  <<endl<<\n\"MMMMHMY.~~~(R ``` 799Y!```` ``` `` `` `` ?UUUY!`` ````` (M N, `` ```.Z3J=``\"  <<endl<<\n\"gaJJdD.~~::_X|`````````````` `````` `` ` ``` ````` ``` .H  MN,``` .Yiv! ```\"  <<endl<<\n\"   MD_:~:~:~(T.`````````` ``` ` ` ````` ``` ``` ``````.M     N, .Ziv!`` ._~\"  <<endl<<\n\" MM'_:::::::~(N+.`````````` .`.(.` .` ``` ```` ```` .dM       NZ1v! .-_~~``\"  <<endl<<\n\" #:(::::::::~(HMNa..  ``````_?!`?7! `` ````  ...-(+7WMM     HM3(b _:<``..`.\"  <<endl<<\n\"=_;::::::::<(H    MMHaJ--_--........-.__~~~~(&v7<~``` ?MM   M>gM9h,_.......\"  <<endl<<\n\";;;;;;;:;::(drWM          HHmgggg&gzOtOzz<<~~~~~_`` ``` ?MMMH+ggM Mm-......\"  <<endl<<\n\"e<>>;>>;;><dMMJM                  Nc_~~~~~~~~~~_ ``  ` `` 7H&-...?THNe-_._(\"  <<endl<<\n\",4m+>>>>>>j MM(W                   N-~~~~~~~~:_`` ``` ` ``  ?7UHHqqHWHMm+__\"  <<endl<<\n\"vX+vT4k&&dMMD!+M                   MR_~~~~~:_````` ```` ````````` ````  ?We\"  <<endl<<\n\"???zTwiJ-(((JdM                    MK_~~~~:_``` ` ` ` `` ` ` ` ``` ```````?\"  <<endl<<\n\"1uukgHM                            MH_~~~_``` `` ``` `` `` `` ` `` ` `  ```\"  <<endl<<\n\"CugM                                N;~~:_ ` `` `` ``` `` ````` ``` ``` ` `\"  <<endl<<\n\"H                                   M[~~~_4, `   ` `` `` ``  ``` `` `` ``` \"  <<endl<<\n\"                                    Hb~~~~~?n  (: `` `` `` `` ` ` `` `` ```\"  <<endl<<\n\"                                    Hb~~~~~~(4,J_ `` ```  ```` ``` `` `` ` \"  <<endl<<\n\"                                     N-~~~~~~(MM_` `` ` (}  `` `` `` `` ```\"  <<endl<<\n\"                                     Mr_~~~~~(HH: `` `` j!`` `` `` `` `` ``\"  <<endl<<\n\"                                     Mb~~~~~~(WH:`` `` .Z `` `` `` ``` `` `\"  <<endl<<\n\"                                      N:~~~~~(WM{ `` ` .H+.. `` `  .``` `` \"  <<endl;}\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n//#define int long long\n\n#define _overload3(_1,_2,_3,name,...) name\n#define _REP(i,n) REAP(i,0,n)\n#define REAP(i,a,b) for(int i=int(a);i<int(b);++i)\n#define REP(...) _overload3(__VA_ARGS__,REAP,_REP,)(__VA_ARGS__)\n\n#define _REPR(i,n) REAPR(i,n,0)\n#define REAPR(i,a,b) for(int i=int(a-1);i>=int(b);--i)\n#define REPR(...) _overload3(__VA_ARGS__,REAPR,_REPR,)(__VA_ARGS__)\n\n#define ALL(a) a.begin(),a.end()\n#define rALL(a) a.rbegin(),a.rend()\n\n#define coutALL(a) {int loop_coutALL=0;for(auto e:a) cout<<(loop_coutALL++?\" \":\"\")<<e; cout<<endl;}\n#define coutYN(a) cout<<(a?\"Yes\":\"No\")<<endl;\n#define coutyn(a) cout<<(a?\"yes\":\"no\")<<endl;\n\n#define pcnt __builtin_popcount\n#define buli(x) __builtin_popcountll(x)\n\nconst int INF=1145141919;\nconst int MOD=(int)1e9+7;\nconst double EPS=1e-12;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const int dx[]={-1,-1,-1,0,1,1,1,0},dy[]={-1,0,1,1,1,0,-1,-1};\n\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\n\ntypedef pair<int,int> pii;\ntypedef pair<int,string> pis;\ntypedef pair<string,int> psi;\ntypedef pair<string,string> pss;\n\ntypedef long long ll;\n\ntemplate<class T> ll upper(T n,T m){return (n+m-1)/m;};\ntemplate<class T> ll rounding(T n){return (long double)n+0.5;};\n\ninline int qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a;a=1ll*a*a;}while(b>>=1);return ans;}\ninline int qp(int a,ll b,int mo){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}\n\nstruct Arithmetic{Arithmetic(){cin.tie(0);ios::sync_with_stdio(0);cout<<fixed<<setprecision(20);}};\n\n//#define DEBUG_LOCAL\n\n#ifdef DEBUG_LOCAL\ntemplate<typename T> void deb(T a){cerr<<\"deb: \"<<a<<\"ですねぇ！\"<<endl;}\n#define debl {cerr<<\"debug: \"<<__LINE__<<\"行目だよーんおほほ\"<<endl;}\nvoid what_cr(){cout<<__GCC_ATOMIC_CHAR16_T_LOCK_FREE<<\" ←なんだろーこの数字？\"<<endl;}\nvoid t_t(){cout\n    <<endl\n    <<\"------------------------\"<<endl\n    <<\"| Presented by         |\"<<\" Compiled \"<<__FILE__<<endl\n    <<\"| \"<<__DATE__<<\" \"<<__TIME__<<\" |\"<<endl\n    <<\"|        Chiharu Izumi |\"<<\"      to get the AC :)\"<<endl\n    <<\"------------------------\"<<endl;\n}\n#else\ntemplate<typename T>void deb(T a){}\n#define debl ;\nvoid what_cr(){}void t_t(){}\n#endif\n\nint n,pos;\nvi pre,in,post;\n\nvoid rec(int l,int r){\n\n  if(l>=r) return ;\n\n  int root=pre[pos++];\n  int m=distance(in.begin(),find(ALL(in),root));\n\n  rec(l,m);\n  rec(m+1,r);\n\n  post.pb(root);\n\n}\n\nsigned main(){\n\n  Arithmetic Exception;\n\n  cin>>n;\n\n  REP(i,n){\n\n    int k;\n    cin>>k;\n    pre.pb(k);\n\n  }\n\n  REP(i,n){\n\n    int k;\n    cin>>k;\n    in.pb(k);\n\n  }\n\n  pos=0;\n  rec(0,(int)pre.size());\n\n  coutALL(post);\n\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\nstruct node{\n    int parent;\n    int l;\n    int r;\n    int val;\n};\nstruct tree{\n    vector<node>map;\n    bool first;\n    int root;\n    void insert(int n,int now){\n        if(map[n].val>map[now].val){\n            map[n].parent=now;\n            map[now].r=n;\n        }\n        else{\n            if(now==root){\n                root=n;\n                map[n].l=now;\n                map[now].parent=n;\n            }\n            else{\n                insert(n,map[now].parent);\n                if(map[map[now].parent].r!=now){\n                    map[now].parent=n;\n                    map[n].l=now;\n                }\n            }\n        }\n        return ;\n    }\n    void postorder(int n){\n        if(n==-1)return ;\n        postorder(map[n].l);\n        postorder(map[n].r);\n        if(first)printf(\" \");\n        else first=true;\n        printf(\"%d\",map[n].val);\n        return ;\n    }\n};\nnode int_to_node(int n){\n    node temp;\n    temp.val=n;\n    temp.l=temp.r=temp.parent=-1;\n    return temp;\n}\nint main(){\n    int n,a[100],temp;\n    tree t;\n    t.first=false;\n    t.root=0;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%d\",&temp);\n        a[temp]=i;\n    }\n    scanf(\"%d\",&temp);\n    t.map.push_back(int_to_node(temp));\n    for(int i=1;i<n;i++){\n        scanf(\"%d\",&temp);\n        t.map.push_back(int_to_node(a[temp]));\n        t.insert(i,i-1);\n    }\n    t.postorder(t.root);\n    printf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <string>\n#pragma warning(disable : 4996)\n\n#define MAX_N 40\n\nint P[MAX_N];\nint I[MAX_N];\n\nstruct Node {\n\tint id;\n\tint parent;\n\tint left;\n\tint right;\n\tint depth;\n\tint hight;\n\tNode() : id(-1), parent(-1), depth(-1), left(-1), right(-1), hight(-1) {}\n};\n\nNode nodes[MAX_N+1];\n\nNode *GetRoot(int n) {\n\tfor (int i = 1; i < n+1; ++i) {\n\t\tif ((nodes[i].parent == -1) && (nodes[i].id != -1)){\n\t\t\treturn &nodes[i];\n\t\t}\n\t}\n\treturn NULL;\n}\nint CalcDHr(Node *n, int depth) {\n\tn->depth = depth;\n\tint md = n->depth;\n\tif (n->left != -1) {\n\t\tNode *l = &nodes[n->left];\n\t\tint cd = CalcDHr(l, depth+1);\n\t\tif (md < cd) md = cd;\n\t}\n\tif (n->right != -1) {\n\t\tNode *r = &nodes[n->right];\n\t\tint cd = CalcDHr(r, depth+1);\n\t\tif (md < cd) md = cd;\n\t}\n\tn->hight = md - n->depth;\n\treturn md;\n}\nvoid CalcDH(int n) {\n\tNode *root = GetRoot(n);\n\tCalcDHr(root, 0);\n}\nvoid Preorder(Node *node) {\n\tprintf(\" %d\", node->id);\n\tif(node->left != -1) Preorder(&nodes[node->left]);\n\tif(node->right != -1) Preorder(&nodes[node->right]);\n}\nvoid Inorder(Node *node) {\n\tif (node->left != -1) Inorder(&nodes[node->left]);\n\tprintf(\" %d\", node->id);\n\tif (node->right != -1) Inorder(&nodes[node->right]);\n}\nvoid Postorder(Node *node) {\n\tif (node->left != -1) Postorder(&nodes[node->left]);\n\tif (node->right != -1) Postorder(&nodes[node->right]);\n\tstatic bool isFirst = true;\n\tif (isFirst == true) {\n\t\tisFirst = false;\n\t}\n\telse {\n\t\tprintf(\" \");\n\t}\n\tprintf(\"%d\", node->id);\n}\n\nvoid Reconstruct(int pre[], int pl, int in[], int il) {\n\tNode *root = &nodes[pre[0]];\n\tint index = -1;\n\tfor (int i = 0; i < il; ++i) {\n\t\tif (in[i] == pre[0]) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (index == 1) {\n\t\troot->left = in[index-1];\n\t\tnodes[root->left].parent = pre[0];\n\t}\n\telse if (index > 1) {\n\t\troot->left = pre[1];\n\t\tnodes[root->left].parent = pre[0];\n\t\tReconstruct(&pre[1], index, in, index);\n\t}\n\tif (il - index - 1 == 1) {\n\t\troot->right = in[index + 1];\n\t\tnodes[root->right].parent = pre[0];\n\t}\n\telse if (il - index - 1 > 1) {\n\t\troot->right = pre[1+index];\n\t\tnodes[root->right].parent = pre[0];\n\t\tReconstruct(&pre[1+index], pl-index-1, &in[1+index], il-index-1);\n\t}\n}\nint main(void) {\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &P[i]);\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &I[i]);\n\t}\n\tfor (int i = 1; i < n+1; ++i) {\n\t\tnodes[i].id = i;\n\t}\n\tReconstruct(P, n, I, n);\n\tNode *root = GetRoot(n);\n\tPostorder(root);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint N, pos;\nvector<int> pre, in, post;\n\nvoid rec(int left, int right) {\n  if (left >= right) {\n    return;\n  }\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(left, m);\n  rec(left + 1, right);\n  post.push_back(root);\n}\n\nvoid solve() {\n  pos = 0;\n  rec(0, pre.size());\n  for (int i = 0; i < N; i++) {\n    if (i) {\n      cout << \" \";\n    }\n    cout << post[i]\n  }\n  cout << endl;\n}\n\nint main() {\n  int N;\n  cin >> N;\n\n  int k;\n  for (int i = 0; i < N; i++) {\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for (int i = 0; i < N; i++) {\n    cin >> k;\n    in.push_back(k);\n  }\n\n  solve();\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <climits>\n#include <cstring>\n#define rep(i, begin, end) for (__typeof(end) i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))\n\nusing namespace std;\n\nconst int N_MAX = 1000000;\nstring ans = \"\";\n/*\n pre: 4 2 3 1 5\n in:  3 2 4 5 1\n\n*/\nstruct Node{\n  int data;\n  Node* left;\n  Node* right;\n};\n\nvoid postorder(Node* root){\n  if(root == NULL) return;\n  postorder(root->left);\n  postorder(root->right);\n  //cout << root->data << \" \";\n  ans += (to_string(root->data) + \" \");\n}\n\n\nvoid print_array(int* arr, int len){\n  rep(i, 0, len){\n    cout << arr[i];\n    if(i==len-1) cout << endl;\n    else cout << \" \";\n  }\n}\n\nNode* solve(int* inorder, int* preorder, int len){\n  // cout << \"inorder: \" << endl;\n  // print_array(inorder, len);\n  \n  // cout << \"preorder: \" << endl;\n  // print_array(preorder, len);\n  // find root\n  int root_data = preorder[0];\n  Node* root_node = new Node;\n  root_node->data = root_data;\n  if(len==1) return root_node;\n  \n  // count all the num left\n  int left_num=0;\n  while(inorder[left_num] != root_data) left_num++;\n  int right_num = len - left_num - 1;\n  \n  int* left_inorder = new int[left_num];\n  int* right_inorder = new int[right_num];\n  \n  int* left_preorder = new int[left_num];\n  int* right_preorder = new int[right_num];\n\n  int ix=0;\n  int l_ix=0, r_ix=0;\n\n  rep(ix, 0, len){\n    if(inorder[ix] == root_data) continue;\n    if(l_ix<left_num){\n      left_inorder[l_ix] = inorder[ix];\n      l_ix++;\n    }\n    else if(r_ix<right_num){\n      right_inorder[r_ix] = inorder[ix];\n      r_ix++;\n    }\n  }\n  \n  ix = 0; l_ix = 0; r_ix = 0;\n  \n  rep(ix, 1, len){\n    if(l_ix < left_num){\n      left_preorder[l_ix] = preorder[ix];\n      l_ix++;\n    }\n    else if(r_ix < right_num){\n      right_preorder[r_ix] = preorder[ix];\n      r_ix++;\n    }\n  }\n\n  if(left_num>0) root_node->left = solve(left_inorder, left_preorder, left_num);\n  if(right_num>0) root_node->right = solve(right_inorder, right_preorder, right_num);  \n  \n  delete[] left_inorder;\n  delete[] right_inorder;\n\n  return root_node;\n  \n}\n\nint main(){\n  int n; cin >> n;\n\n  int* inorder = new int[n];\n  int* preorder = new int[n];\n  \n  int tmp;\n  rep(i, 0, n){\n    cin >> tmp;\n    preorder[i] = tmp;\n  }\n  rep(i, 0, n){\n    cin >> tmp;\n    inorder[i] = tmp;\n  }\n  Node* root = solve(inorder, preorder, n);\n  postorder(root);\n  rep(i, 0, 2*n-1) cout << ans[i]; \n  cout << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r) {\n  if (l>=r) {\n    return ;\n  }\n  int root=pre[pos++];\n  int m=distance(in.begin(),find(in.begin(),in.end(),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\nvoid solve() {\n  pos=0;\n  rec(0,pre.size());\n  for (int i=0; i<n; i++) {\n    if (i) {\n      cout<<\" \"<<flush;\n    }\n    cout<<post[i]<<flush;\n  }\n  cout<<endl;\n}\nint main() {\n  std::ios::sync_with_stdio(false);\n  cout.tie(0);\n  cin.tie(0);\n  cin>>n;\n  int s;\n  for (int i=0; i<n; i++) {\n    cin>>s;\n    pre.push_back(s);\n  }\n  for (int i=0; i<n; i++) {\n    cin>>s;\n    in.push_back(s);\n  }\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace  std;\n\nconst int END = -1;\nstruct StNod\n{\n  int m_nParnt;\n  int m_nLeft;\n  int m_nRigt;\n\n  StNod() :\n     m_nParnt(END), m_nLeft(END), m_nRigt(END)\n  { }\n};\n\nenum EnDir\n{\n  D_Left,\n  D_Right,\n};\n\nvoid fnInput(vector<int> &rvnPodr, vector<int> &rvnIodrSeq)\n{\n  int nMaxSiz;\n\n  cin >> nMaxSiz;\n  rvnPodr.resize(nMaxSiz);\n  rvnIodrSeq.resize(nMaxSiz + 1);\n\n  for (int i = 0; i < nMaxSiz; i++)\n    cin >> rvnPodr[i];\n\n  int nNode;\n  for (int i = 1; i < nMaxSiz + 1; i++)\n  {\n    cin >> nNode;\n    rvnIodrSeq[nNode] = i;\n  }\n}\n\nvoid fnStructTree(const vector<int> &cnrvnPodr, const vector<int> &cnrvnIodrSeq, vector<StNod> &rvoNod)\n{\n  for (int i = 1; i < cnrvnPodr.size(); i++)\n  {\n    int nParnt = END;\n    int nx = cnrvnPodr[0];\n    EnDir enDir;\n    while (nx != END)\n    {\n      nParnt = nx;\n      if (cnrvnIodrSeq[ cnrvnPodr[i] ] < cnrvnIodrSeq[nx])\n      {\n        nx = rvoNod[nx].m_nLeft;\n        enDir = D_Left;\n      }\n      else\n      {\n        nx = rvoNod[nx].m_nRigt;\n        enDir = D_Right;\n      }\n    }\n\n    rvoNod[ cnrvnPodr[i] ].m_nParnt = nParnt;\n    if (enDir == D_Left)\n      rvoNod[nParnt].m_nLeft = cnrvnPodr[i];\n    else\n      rvoNod[nParnt].m_nRigt = cnrvnPodr[i];\n  }\n}\n\nvoid fnPostOrder(const vector<StNod> &cnrvoNod, int nx)\n{\n  static int stnPrt = 0;\n  if (nx == END)  return;\n\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nLeft);\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nRigt);\n\n  if (stnPrt++) cout << \" \";\n  cout << nx;\n}\n\nvoid fnResult(const vector<StNod> &cnrvoNod)\n{\n  int nx = 1;\n  while (cnrvoNod[nx].m_nParnt != END)\n    nx = cnrvoNod[nx].m_nParnt;\n\n  fnPostOrder(cnrvoNod, nx);\n  cout << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vector<int> vnPodr, vnIodrSeq;\n  fnInput(vnPodr, vnIodrSeq);\n\n  StNod oNod;\n  vector<StNod> voNod(vnIodrSeq.size(), oNod);\n  fnStructTree(vnPodr, vnIodrSeq, voNod);\n  \n  fnResult(voNod);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ?????¬???????????¬??????\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint N, a[110], b[110];\nint l[110], r[110];\nvector<int> v;\n\n// ?????? a ??§?????? [s, t)????????? b ??§?????? [x, y) ????????? (??¨?????¨)\nvoid solve(int s, int t, int x, int y) {\n    if(t - s <= 1) return;\n    int root = a[s];\n    int idx = find(b, b+N, root) - b; // b ?????????????????????????????????\n\n    bool exist[110] = {};\n    rep(i,idx+1,y) exist[ b[i] ] = true;\n    int mi = INF; // a ?????????????????¨?????¨????§???????????????????\n    rep(i,s,t) if(exist[ a[i] ]) chmin(mi, i);\n    if(mi == INF) return;\n\n    if(idx != x && idx != y-1) l[root] = a[s+1], r[root] = a[mi];\n    if(idx == x) r[root] = a[mi];\n    if(idx == y-1) l[root] = a[s+1];\n\n    solve(s+1, mi, x, idx);\n    solve(mi, t, idx+1, y);\n}\n\nvoid pushans(int p) {\n    if(l[p] != -1) pushans(l[p]);\n    if(r[p] != -1) pushans(r[p]);\n    v.push_back(p);\n}\n\nsigned main() {\n    cin >> N;\n    rep(i,0,N) cin >> a[i];\n    rep(i,0,N) cin >> b[i];\n\n    memset(l, -1, sizeof(l));\n    memset(r, -1, sizeof(r));\n    solve(0, N, 0, N);\n    pushans(a[0]);\n\n    rep(i,0,N) cout << (i == 0 ? \"\" : \" \") << v[i];\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n//ALDS1_7_B:   Binary Trees\n//ALDS1_7_C:   Tree Walk\n//ALDS1_7_D:   Reconstruction of a Tree\n//D???????????°??£????????±????§£?????§?????\\???for?????§?§£??????????????????????§£?????????\n////////////////////////////////////////\n\n#include <iostream>\n#include <algorithm> // next_permutation\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <list>\n#include <numeric> //accumulate\n//#include <unordered_map> //???????????\\??¢??°\n#include <fstream> //ifstream, ofstream\n\n//#define NDEBUG //NDEBUG???#include <cassert>???????????????????????????????????´???assert?????????????????????????????????NDEBUG?????????????????????????????????????????????\n#include <cassert> //assert\n\n\nusing namespace std;\n\n//???????????°??????TEST????????????????????¬???????????????????????????????????¢????????????\n#define TEST //*******************************************************************************************************************************************\n//?????????????????¨??§?????\\????????????????????????????????°?????????????¨???????????????????dout???????????????????????§???????????¬??????????????????????????????????????????\n//??????????????????????????????????????????????????????????§?CPU???????£??????????????????§???TLE?????????????????????????????????????????§????????¨???                           ????????????????????????cerr????????£????????????????????????????????????\n#ifdef TEST\n#define dout cout\n#else\nstringstream dummy; //???????????°??????dout?????????????????????????????????\n#define dout dummy.str(\"\"); dummy.clear(stringstream::goodbit); dummy //dummy?????????????????????????????????????????¨?????¢?????¢???????????????\n//???????????¨??????????????????goodbit?????????????????????????????¨???????????´????????????????????????????????¨?????°?????????????????§???????????????????????????????????? http://d.hatena.ne.jp/linden/20060427/p1\n#endif\n\n//?¨??????????????????????????????????????????????????????´??????OUTPUT2TEXTFILE????????????????????¬???????????????????????????????????¢????????????\n//#define OUTPUT2TEXTFILE //*******************************************************************************************************************************************\n#ifdef OUTPUT2TEXTFILE\n#define dout outputfile //??¨????????????TLE????????§?????????dout?????¨??¨??????????????¢????????????????????????????????????????????§????¨????????????´??????????????£??????????????????????¨?????????????????????????????????????????????§?????????????????????\n//TEST??????????????????????????¨???outputfile??????????????????????????????\n#define OUTPUTFILENAME \"output.txt\"\nofstream outputfile(OUTPUTFILENAME);\n#define OutputFilePath \"/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt\"\n#endif\n\n#define disp(A) dout << #A << \" = \" << (A) << endl\n#define disP(A) dout << setw(3) << (A) << \" \" // << setw(3) ??????????????\\????????????\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n\n#define dispAll(A,n) dout << #A << \" = \"; rep(j, 0, (n)) {disP(A[j]);} dout << endl\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef unsigned long long ll;\n\nconst int INF = 1e9-1;\n\nclass Node;\n\nconst int N_MAX = 40;\nvector<Node> node;\n//vi printer;\n\nint preorder[N_MAX], inorder[N_MAX];\nint x2inindex[N_MAX]; //????????°x???inorder????????§???x2inindex[x]????????????????????¨?????????\n\nint N; //num of node\nint targetPreorderIndex = 1; //????????¨??????????????????preorder[x]???index??§??????x?????????\n\nclass Node {\npublic:\n    Node() {\n        parent = -1;\n        left = -1;\n        right = -1;\n    }\n    \n    int parent;\n    int left;\n    int right;\n    \n    \n    int depth() {\n        int p = this->parent;\n        int d = 0;\n        \n        while( p != -1 ) {\n            d++;\n            p = node[p].parent;\n        }\n        \n        return d;\n    }\n    \n    static int height(int id) {\n        if(id == -1) return -1;\n        \n        return max( height(node[id].left), height(node[id].right)) + 1;\n    }\n    \n    static void printNodePreorder(int id) {\n        if(id==-1) return;\n        \n        cout << \" \" << id;\n        printNodePreorder(node[id].left);\n        printNodePreorder(node[id].right);\n    }\n    \n    static void printNodeInorder(int id) {\n        if(id==-1) return;\n        \n        printNodeInorder(node[id].left);\n        cout << \" \" << id;\n        printNodeInorder(node[id].right);\n    }\n    \n    static void printNodePostorder(int id) {\n        if(id==-1) return;\n        \n        printNodePostorder(node[id].left);\n        printNodePostorder(node[id].right);\n//        printer.push_back(id);\n                cout << \" \" << id;\n    }\n    \n    static int findTopNodeFromInorder(int left, int right) { //inorder[left ... right]??????????????????????????????????????????????????¢????????????index?????????\n        if( left > right ) return -1;\n        \n        int x = preorder[targetPreorderIndex];\n        targetPreorderIndex++;\n        \n        //inorder???2????????°?????????????????????????????°????????????\n        int leftChild = findTopNodeFromInorder(left, x2inindex[x]-1); //x?????????????????????????????°?????????\n        int rightChild = findTopNodeFromInorder(x2inindex[x]+1, right); //x?????????????????????????????°?????????\n        \n        node[x].left = leftChild;\n        node[x].right = rightChild;\n        \n        node[leftChild].parent = x;\n        node[rightChild].parent = x;\n        \n        cout << x << (x==preorder[1] ? \"\\n\" : \" \");\n        return x;\n    }\n};\n\n\n\nint main(){ //?????????1???based index??§???\n    cin >> N;\n    rep(i,0,N+1) node.push_back(*new Node()); //node[0]????????????????????????\n    \n    rep(i,1,N+1) cin >> preorder[i];\n    rep(i,1,N+1) { cin >> inorder[i]; x2inindex[ inorder[i] ] = i; }\n    \n//        //test display\n//        dispAll(preorder, N+1);\n//        dispAll(inorder, N+1);\n//        dispAll(x2inindex, N+1);\n    \n    //reconstruct the tree\n    Node::findTopNodeFromInorder(1,N);\n    \n//    //test display\n//    dout<<\"-----------------\\n\";\n//    dout << \"  i   l   r   p\\n\";\n//    rep(i,0,N+1) {\n//        disP(i);\n//        disP(node[i].left); disP(node[i].right); disP(node[i].parent);\n//        dout << endl;\n//    }\n    \n        \n//    //output\n//    rep(i,0,N+1) {\n//        cout << \"node \" << i << \": parent = \" << node[i].parent\n//        << \", sibling = \" << (node[i].parent==-1 ? -1 : (node[node[i].parent].left==i ? node[node[i].parent].right : node[node[i].parent].left) )\n//        << \", degree = \" << (node[i].left==-1 ? (node[i].right==-1 ? 0 : 1) : (node[i].right==-1 ? 1 : 2))\n//        << \", depth = \" << node[i].depth()\n//        << \", height = \" << Node::height(i) << \", \"\n//        << (node[i].parent==-1 ? \"root\" : (node[i].left==-1 && node[i].right==-1 ? \"leaf\" : \"internal node\") ) << endl;\n//    }\n\n    \n    \n//    //find root\n//    int root_i = -1;\n//    rep(i,1,N+1) {\n//        if(node[i].parent==-1) {\n//            root_i = i;\n//            break;\n//        }\n//    }\n//    assert(root_i!=-1);\n//    \n//    //print tree\n//    //    cout << \"Preorder\\n\";\n//    //    Node::printNodePreorder(root_i);\n//    //    cout << endl;\n//    //\n//    //    cout << \"Inorder\\n\";\n//    //    Node::printNodeInorder(root_i);\n//    //    cout << endl;\n//    //\n//    //    cout << \"Postorder\\n\";\n//    Node::printNodePostorder(root_i);\n//    \n//    rep(i,0,N) {\n//        if(i==0) cout << printer[i];\n//        else cout << \" \" << printer[i];\n//    }\n//    cout << endl;\n    \n    \n#ifdef OUTPUT2TEXTFILE\n    outputfile.close();\n    cout << \"\\\"\" << OutputFilePath << \"\\\"\" << endl;\n#endif\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> pre, in, post;\nint preidx;\n\nvoid func(int l, int r){\n  if(r-l<1) return;\n  //cout << l << \" \" << r << endl;\n  //find pre[preidx] in in[begin:end]\n  int mid = -1;\n  for(int i = l; i < r; i++){\n    if(in[i] == pre[preidx]){\n      mid = i;\n      break;\n    }\n  }\n  assert(mid != -1);\n  preidx++;\n  if(mid != l){\n    func(l, mid);\n  }\n  func(mid+1, r);\n  post.push_back(in[mid]);\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n; cin >> n;\n  pre.resize(n);\n  in.resize(n);\n  post.clear();\n  preidx = 0;\n\n  for(int i = 0; i < n; i++) cin >> pre[i];\n  for(int i = 0; i < n; i++) cin >> in[i];\n  func(0, n);\n\n  for(int i = 0; i < n; i++){\n    cout << post[i];\n    if(i == n-1) cout << endl;\n    else cout << \" \";\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _GLIBCXX_DEBUG\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rrep(i, n) for (int i = 1; i < (n+1); ++i)\nusing namespace std;\nusing ll = long long;\n// const int INF = +100100100;\ntypedef pair<int,int> P;\n\nint n,pos;\nvector<int> pre,post,in;\n\n\nvoid rec(int l, int r){\n    if(l>=r)return;\n    int root = pre[pos];\n    pos++;\n    int m = distance(in.begin(),find(in.begin(),in.end(),root));\n    rec(l,m);\n    rec(m+1,r);\n    post.push_back(root);\n}\n\nvoid solve(){\n    pos=0;\n    rec(0,pre.size());\n    rep(i,n){\n        if(i)cout<<\" \";\n        cout<<post[i];\n    }\n    cout<<endl;\n}\n\nint main(){\n    cin >> n;\n    rep(i,n){\n        int k;\n        cin >> k;\n        pre.push_back(k);\n    }\n    rep(i,n){\n        int k;\n        cin >> k;\n        in.push_back(k);\n    }\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <iterator>\n#include<algorithm>\nstatic const int NIL = -1;\nstatic const int NumberChild = 2;\nclass Tree {\nprivate:\n\tint id;\n\tint parent;\n\tint child[NumberChild];\n\npublic:\n\tTree() {\n\t\tid = child[0] = child[1] = parent = NIL;\n\t}\n\tvoid AddParent(int ID) {\n\t\tparent = ID;\n\t\treturn;\n\t}\n\tvoid AddID(int ID) {\n\t\tid = ID;\n\t\treturn;\n\t}\n\tvoid AddChild(std::vector<int>&Child) {\n\t\tfor (unsigned int i = 0; i < Child.size(); ++i) {\n\t\t\tchild[i] = Child[i];\n\n\t\t}\n\n\t\treturn;\n\t}\n\tint GetRoot(std::vector<Tree> nodes, int ID) {\n\t\tint RootID = ID;\n\t\tif (RootID != NIL&&nodes[RootID].parent != NIL) {\n\t\t\tRootID = GetRoot(nodes, nodes[RootID].parent);\n\t\t}\n\t\treturn RootID;\n\t}\n\tvoid PreorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid InorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid PostorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t\tif(nodes[ID].id!=NIL)std::cout << \" \" << nodes[ID].id;\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid GetVctorPostorderTreeWalk(std::vector<Tree> nodes, std::vector<int>& returnvector, int ID) {\n\t\t\n\t\tif (ID != NIL) {\n\n\t\t\tGetVctorPostorderTreeWalk(nodes,  returnvector, nodes[ID].child[0]);\n\t\t\tGetVctorPostorderTreeWalk(nodes, returnvector, nodes[ID].child[1]);\n\t\t\tif (nodes[ID].id != NIL)returnvector.push_back(nodes[ID].id) ;\n\t\t}\n\n\t\treturn ;\n\t}\n\tvoid Reconstruct(const std::vector<int>Pre, const std::vector<int>In, std::vector<Tree> &nodes, const int Root, int &cnt) {\n\n\t\tunsigned int m = std::distance(In.begin(), std::find(In.begin(), In.end(), Root));\n\n\t\t//nodes[cnt].AddID(Root);\n\t\tif ( Root == NIL) { return; }\n\t\tnodes[Root].AddID(Root);\n\t\tif ( m ==0 ) { return; }\n\t\tstd::vector<int>PreLeft;\n\n\t\tstd::copy(&Pre[1], &Pre[m] + 1, std::back_inserter(PreLeft));\n\n\n\n\n\t\tstd::vector<int>InLeft(1);\n\t\tstd::vector<int>PreRight(1);\n\t\tPreRight={NIL};\n\t\tstd::vector<int> InRight;\n\t\tInRight={NIL};\n\t\tstd::copy(&In[0], &In[m-1]+1, std::back_inserter(InLeft));\n\t\t\n\t\tif (m<Pre.size()-1){\n\t\t\tstd::copy(&Pre[m] + 1, &Pre[Pre.size() - 1] + 1, std::back_inserter(PreRight));\n\t\t}\n\t\tif (m<In.size()-1) {\n\t\t\tstd::copy(&In[m] + 1, &In[In.size() - 1] + 1, std::back_inserter(InRight));\n\t\t\t}\n\t\t\n\t\t\n\t\t\n\n\t\tstd::vector<int> child(2);\n\t\tchild[0] =  PreLeft.empty() ? NIL : PreLeft[0] ;\n\t\tchild[1] = PreRight.empty() ? NIL : PreRight[0] ;\n\t\t//nodes[cnt].AddChild(child);\n\t\tnodes[Root].AddChild(child);\n\t\tfor (unsigned int i = 0; i < child.size(); ++i) {\n\n\t\t\tif (child[i] != NIL) { nodes[child[i]].AddParent(Root); }\n\t\t}\n\t\tReconstruct(PreLeft, InLeft, nodes, PreLeft[0], ++cnt);\n\t\tReconstruct(PreRight, InRight, nodes, PreRight[0], ++cnt);\n\t}\n};\n\nvoid SetVector(std::vector<int>&InputVector) {\n\tfor (unsigned int i = 0; i < InputVector.size(); ++i) {\n\t\tstd::cin >> InputVector[i];\n\t}\n\treturn;\n}\nint main(void) {\n\n\tint n;\n\tstd::cin >> n;\n\tstd::vector<int>Pre(n);\n\tstd::vector<int>In(n);\n\tSetVector(Pre);\n\tSetVector(In);\n\tstd::vector<Tree> nodes(n+1);\n\t//ReconstructWithNoParent\n\tint cnt = 0;\n\tnodes[1].Reconstruct(Pre, In, nodes, Pre[0],cnt);\n\n\t//nodes[1].PostorderTreeWalk(nodes, 1);\n\tstd::vector<int>Print;\n\tnodes[1].GetVctorPostorderTreeWalk(nodes, Print, 1);\n//Print=nodes[1].GetVctorPostorderTreeWalk(nodes, 1);\nfor (unsigned int i = 0; i < Print.size(); ++i) {\n\tif (i) { std::cout << \" \"; }\n\tstd::cout<<Print[i];\n\tif(i==Print.size()-1){ std::cout << std::endl; }\n}\n\t\n\t\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nstruct node{\n    int l,r;\n};\nnode v[41];\nvector<int> postord;\nvoid dfs(int vi){\n    if(v[vi].l!=0)dfs(v[vi].l);\n    if(v[vi].r!=0)dfs(v[vi].r);\n    postord.pb(vi);\n}\nint pre[41],in[41];\nint main(){\n    int n,root;\n    cin>>n;\n    rep(i,n) cin>>pre[i];\n    rep(i,n) cin>>in[i];\n    root=pre[0];\n    int cp=0,ci=0;\n    while(cp<n-1){\n        v[pre[cp]].l=pre[cp+1];++cp;\n        while(cp<n&&pre[cp]==in[ci]){\n            ++ci;\n            while(ci<n&&v[in[ci+1]].l==in[ci]) ++ci;\n            if(ci==n) break;\n            v[in[ci]].r=in[ci+1];++ci;\n            ++cp;\n        } \n    }\n    dfs(root);\n    rep(i,n) cout<<postord[i]<<(i==n-1?\"\":\" \");\n    cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define N 42\nint n;\nint a[N];\nint b[N];\nint c[N];\nint ai = 1;\nint ci = 1;\nint used[N];\nvoid rebuild(int left, int right){\n    if(left == right) {\n//        printf(\"%d \", b[left]);\n        c[ci++] = b[left];\n        used[b[left]] = 1;\n         return ;\n    }\n//    int ax = a[ai++];\n    int ax;\n    if(used[a[ai]] == 0){\n        ax = a[ai++];\n    }\n    else{\n        while(used[a[ai]] != 0){\n            ai++;\n        }\n        ax = a[ai];\n    }\n    int m = 1;\n    for(int i = 1; i <= n; i++){\n        if(b[i] == ax) m = i;\n    }\n    if(m - 1 >= left) rebuild(left, m-1);\n    if(m + 1 <= right) rebuild(m+1, right);\n//    printf(\"%d \", ax);\n    c[ci++] = ax;\n    used[ax] = 1;\n    return ;\n}\nint main(){\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    for(int i = 1; i <= n; i++) scanf(\"%d\", &b[i]);\n    for(int i = 1; i <= n; i++) used[i] = 0;\n    rebuild(1, n);\n    for(int i = 1; i <= n; i++){\n        if(i == n) printf(\"%d\\n\", c[i]);\n        else printf(\"%d \", c[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define eol '\\n';\nusing namespace std;\n\nclass Node {\npublic:\n  int id;\n  int l;\n  int r;\n  int p;\n  Node(): id(-1),l(-1),r(-1),p(-1){};\n};\n\nNode* tree;\n\nint create_tree(int parent, vector<int> pre, vector<int> in) {\n    if (pre.size() == 0 && in.size() == 0) {\n      return -1;\n    }\n\n    int root_id = pre[0];\n    if (root_id == -1) {\n      return -1;\n    }\n\n    Node* node = &tree[root_id];\n    node->p = parent;\n    \n    // left\n    vector<int> left_pre;\n    vector<int> left_in;\n\n    int i = 0;\n    int size = in.size();\n    for (; i < size; i++) {\n      if (in[i] == root_id) {\n        break;\n      }\n      left_pre.push_back(pre[i+1]);\n      left_in.push_back(in[i]);\n    }\n    node->l = create_tree(root_id, left_pre, left_in);\n\n    vector<int> right_pre;\n    vector<int> right_in;\n\n    i++;\n    for (;i < size; i++) {\n      right_pre.push_back(pre[i]);\n      right_in.push_back(in[i]);\n    }\n    node->r = create_tree(root_id, right_pre, right_in);\n\n    return root_id;\n}\n\nvector<int> postorder(int id, vector<int> post) {\n  Node* node = &tree[id];\n  if (node->l != -1) {\n    post = postorder(node->l, post);\n  }\n  if (node->r != -1) {\n    post = postorder(node->r, post);\n  }\n  post.push_back(id);\n\n  return post;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  \n  int n,i;\n  cin >> n;\n\n  tree = new Node[n+1];\n\n  vector<int> preorder(n);\n  vector<int> inorder(n);\n\n  for (i = 0; i < n; i++) {\n    cin >> preorder[i];\n  }\n  for (i = 0; i < n; i++) {\n    cin >> inorder[i];\n  }\n\n  int root = create_tree(-1, preorder, inorder);\n\n  // post order\n  vector<int> post;\n  post = postorder(root, post);\n\n  // output\n  cout << post[0];\n  for (i = 1; i < n; i++) {\n    cout << \" \" << post[i];\n  }\n  cout << eol;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdint.h>\n#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <climits>\n#include <vector>\nusing namespace std;\n\n#define DEBUG (0)\n\n#if DEBUG\n#define DPRINTF(...) do { \\\n    printf(\"D(L%d) %s: \", __LINE__, __func__); \\\n    printf(__VA_ARGS__); \\\n  } while (false)\n#else\n#define DPRINTF(...)\n#endif // DEBUG\n\n/* binary tree */\nstruct Node {\n  Node() :\n    left_(-1),\n    right_(-1) { }\n\n  int left_;\n  int right_;\n};\n\n\nint findIdxOf(int val, int start, int end, const int array[])\n{\n  for (int i = start; i <= end; i++)\n  {\n    if (array[i] == val)\n      return i;\n  }\n\n  // The val must be found between start to end index\n  assert(false);\n}\n\nint reconstructTree(Node *node, int start, int end, const int preorder[], const int inorder[])\n{\n  DPRINTF(\"start %d  end %d\\n\", start, end);\n\n  if (true) {\n    for (int i = start; i <= end; i++)\n    {\n      if (i == start) DPRINTF(\"%d\", preorder[i]);\n      else            printf(\" %d\", preorder[i]);\n    }\n    cout << endl;\n\n    for (int i = start; i <= end; i++)\n    {\n      if (i == start) DPRINTF(\"%d\", inorder[i]);\n      else            printf(\" %d\", inorder[i]);\n    }\n    cout << endl;\n  }\n\n  if (start == end)\n    return preorder[start];\n\n  if (start > end)\n    return -1;\n\n  // Determine which one is the root node\n  int root = preorder[start];\n  int center = findIdxOf(root, start, end, inorder);\n\n  DPRINTF(\"root %d  center  %d\\n\", root, center);\n\n  // Similarly, determine the root nodes of both the left and right trees\n  // Note that pre-order array has to be alligned before dive into recursively\n  //int newPreorder[center - start - 1];\n  int newPreorder[center];\n  for (int i = start; i < center; i++)\n  {\n    newPreorder[i] = preorder[i+1];\n    DPRINTF(\"newPreorder[%d] %d\\n\", i, newPreorder[i]);\n  }\n\n  node[root].left_ = reconstructTree(node, start, center - 1, newPreorder, inorder);\n  node[root].right_ = reconstructTree(node, center + 1, end, preorder, inorder);\n\n  return root;\n}\n\nvoid traversePostorder(const Node *node, int idx, bool &first)\n{\n  //DPRINTF(\"idx %d\\n\", idx);\n\n  if (&node[idx] == nullptr)\n    return ;\n\n  if (node[idx].left_ > -1)\n    traversePostorder(node, node[idx].left_, first);\n\n  if (node[idx].right_ > -1)\n    traversePostorder(node, node[idx].right_, first);\n\n  if (first)\n  {\n    printf(\"%d\", idx);\n    first = false;\n  }\n  else\n    printf(\" %d\", idx);\n}\n\n\nint main()\n{\n  int numOfNode;\n  cin >> numOfNode; cin.ignore();\n\n  int arrayOfPreorder[numOfNode];\n  int arrayOfInorder[numOfNode];\n\n  for (int i = 0; i < numOfNode; i++)\n    cin >> arrayOfPreorder[i];\n\n  for (int i = 0; i < numOfNode; i++)\n    cin >> arrayOfInorder[i];\n\n#if DEBUG\n  for (int i = 0; i < numOfNode; i++)\n  {\n    if (i == 0) DPRINTF(\"%d\", arrayOfPreorder[i]);\n    else        printf(\" %d\", arrayOfPreorder[i]);\n  }\n  cout << endl;\n\n  for (int i = 0; i < numOfNode; i++)\n  {\n    if (i == 0) DPRINTF(\"%d\", arrayOfInorder[i]);\n    else        printf(\" %d\", arrayOfInorder[i]);\n  }\n  cout << endl;\n#endif\n\n  Node *nodes = new Node[numOfNode];\n\n  int start = 0;\n  int end = numOfNode - 1;\n  int rootIdx = reconstructTree(nodes, start, end, arrayOfPreorder, arrayOfInorder);\n\n  bool first = true;\n  traversePostorder(nodes, rootIdx, first);\n  cout << endl;\n\n  delete[] nodes;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\nstruct Node {\n  int id;\n  Node* parent = nullptr;\n  Node* left = nullptr;\n  Node* right = nullptr;\n  int depth;\n  int height;\n\n  int calcHeight() {\n    int leftHeight = left ? left->calcHeight() : -1;\n    int rightHeight = right ? right->calcHeight() : -1;\n    height = max(leftHeight, rightHeight) + 1;\n    return height;\n  }\n\n  void calcDepth() {\n    depth = parent ? parent->depth + 1 : 0;\n    if (left) left->calcDepth();\n    if (right) right->calcDepth();\n  }\n\n  int degree() {\n    int d = 0;\n    if (left) ++d;\n    if (right) ++d;\n    return d;\n  }\n\n  Node* sibling() {\n    if (!parent) {\n      return nullptr;\n    }\n    if (parent->left == this) {\n      return parent->right;\n    } else {\n      return parent->left;\n    }\n  }\n\n  void walkPostorder() {\n    static bool isFirst = true;\n    if (left) left->walkPostorder();\n    if (right) right->walkPostorder();\n    if (isFirst) {\n      cout << (id + 1);\n      isFirst = false;\n    } else {\n      cout << \" \" << (id + 1);\n    }\n  }\n\n  static Node* reconstruct(\n    vector<Node>& nodes,\n    vector<int>::const_iterator preorderBegin, vector<int>::const_iterator preorderEnd,\n    vector<int>::const_iterator inorderBegin, vector<int>::const_iterator inorderEnd\n  ) {\n    if (inorderBegin == inorderEnd) {\n      return nullptr;\n    }\n    auto root = &nodes[*preorderBegin];\n    auto inorderMid = std::find_if(inorderBegin, inorderEnd, [&](int id){ return id == *preorderBegin; });\n    auto leftCount = inorderMid - inorderBegin;\n    auto left = reconstruct(nodes, preorderBegin + 1, preorderBegin + 1 + leftCount, inorderBegin, inorderMid);\n    auto right = reconstruct(nodes, preorderBegin + 1 + leftCount, preorderEnd, inorderMid + 1, inorderEnd);\n    root->left = left;\n    root->right = right;\n    return root;\n  }\n};\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int nodeCount;\n  cin >> nodeCount;\n  vector<Node> nodes(nodeCount);\n  for (int i = 0; i < nodeCount; ++i) {\n    nodes[i].id = i;\n  }\n\n  std::vector<int> preorderIDs, inorderIDs;\n\n  for (int i = 0; i < nodeCount; ++i) {\n    int id;\n    cin >> id;\n    preorderIDs.push_back(id - 1);\n  }\n\n  for (int i = 0; i < nodeCount; ++i) {\n    int id;\n    cin >> id;\n    inorderIDs.push_back(id - 1);\n  }\n\n  auto root = Node::reconstruct(nodes, preorderIDs.begin(), preorderIDs.end(), inorderIDs.begin(), inorderIDs.end());\n\n  root->walkPostorder();\n  cout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define eol '\\n';\nusing namespace std;\n\nclass Node {\npublic:\n  int id;\n  int l;\n  int r;\n  int p;\n  Node(): id(-1),l(-1),r(-1),p(-1){};\n};\n\nNode* tree;\n\nint create_tree(int parent, vector<int> pre, vector<int> in) {\n    if (pre.size() == 0 && in.size() == 0) {\n      return -1;\n    }\n\n    int root_id = pre[0];\n    if (root_id == -1)\n      return -1;\n\n    Node* node = &tree[root_id];\n    node->p = parent;\n    \n    // left\n    vector<int> left_pre;\n    vector<int> left_in;\n\n    int i = 0;\n    int size = in.size();\n    for (; i < size; i++) {\n      if (in[i] == root_id) {\n        break;\n      }\n      left_pre.push_back(pre[i+1]);\n      left_in.push_back(in[i]);\n    }\n    node->l = create_tree(root_id, left_pre, left_in);\n\n    vector<int> right_pre;\n    vector<int> right_in;\n\n    i++;\n    for (;i < size; i++) {\n      right_pre.push_back(pre[i]);\n      right_in.push_back(in[i]);\n    }\n    node->r = create_tree(root_id, right_pre, right_in);\n\n    return root_id;\n}\n\nvector<int> postorder(int id, vector<int> post) {\n  Node* node = &tree[id];\n  if (node->l != -1) {\n    post = postorder(node->l, post);\n  }\n  if (node->r != -1) {\n    post = postorder(node->r, post);\n  }\n  post.push_back(id);\n\n  return post;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  \n  int n,i;\n  cin >> n;\n\n  tree = new Node[n];\n\n  vector<int> preorder(n);\n  vector<int> inorder(n);\n\n  for (i = 0; i < n; i++) {\n    cin >> preorder[i];\n  }\n  for (i = 0; i < n; i++) {\n    cin >> inorder[i];\n  }\n\n  int root = create_tree(-1, preorder, inorder);\n\n  // post order\n  vector<int> post;\n  post = postorder(root, post);\n\n  // output\n  cout << post[0];\n  for (i = 1; i < n; i++) {\n    cout << \" \" << post[i];\n  }\n  cout << eol;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint pos;\nvector<int> in, pre, post;\n\nvoid rec(int left, int right){ //不包括right\n\tif(left>=right) return;\n\tint m = pre[pos++];\n\n\tint position = distance(in.begin(),find(in.begin(), in.end(), m));\n\t\n\trec(left, position);\n\trec(position+1, right);\n\tpost.push_back(m);\n}\n\nvoid sovle(){\n\tpos=0;\n\trec(0, pre.size());\n\tfor(int i=0; i<post.size(); i++){\n\t\tif(i) cout<<\" \";\n\t\tcout<<post[i];\n\t}\n}\n\nint main(){\n\tint n;\n\n\tcin>>n;\n\tint tem1, tem2;\n\tfor(int i=0; i<n; i++){\n\t\tcin>>tem1;\n\t\tpre.push_back(tem1);\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tcin>>tem2;\n\t\tin.push_back(tem2);\n\t}\n\tsovle();\n\tcout<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <climits>\n#include <cstring>\n#define rep(i, begin, end) for (__typeof(end) i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))\n\nusing namespace std;\n\nconst int N_MAX = 1000000;\nstring ans = \"\";\n/*\n pre: 4 2 3 1 5\n in:  3 2 4 5 1\n\n*/\nstruct Node{\n  int data;\n  Node* left = NULL;\n  Node* right = NULL;\n};\n\nvoid postorder(Node* root){\n\n  if(root == NULL) return;\n  postorder(root->left);\n  postorder(root->right);\n\n  ans += (to_string(root->data) + \" \");\n}\n\n\nvoid print_array(int* arr, int len){\n  rep(i, 0, len){\n    cout << arr[i];\n    if(i==len-1) cout << endl;\n    else cout << \" \";\n  }\n}\n\nNode* solve(int* inorder, int* preorder, int len){\n\n\n  // find root\n  int root_data = preorder[0];\n  Node* root_node = new Node;\n  root_node->data = root_data;\n  if(len==1) return root_node;\n  \n  // count all the num left\n  int left_num=0;\n  while(inorder[left_num] != root_data) left_num++;\n  int right_num = len - left_num - 1;\n  \n  int* left_inorder = new int[left_num];\n  int* right_inorder = new int[right_num];\n  \n  int* left_preorder = new int[left_num];\n  int* right_preorder = new int[right_num];\n\n  int ix=0;\n  int l_ix=0, r_ix=0;\n\n  rep(ix, 0, len){\n    if(inorder[ix] == root_data) continue;\n    if(l_ix<left_num){\n      left_inorder[l_ix] = inorder[ix];\n      l_ix++;\n    }\n    else if(r_ix<right_num){\n      right_inorder[r_ix] = inorder[ix];\n      r_ix++;\n    }\n  }\n  \n  ix = 0; l_ix = 0; r_ix = 0;\n  \n  rep(ix, 1, len){\n    if(l_ix < left_num){\n      left_preorder[l_ix] = preorder[ix];\n      l_ix++;\n    }\n    else if(r_ix < right_num){\n      right_preorder[r_ix] = preorder[ix];\n      r_ix++;\n    }\n  }\n\n  if(left_num>0) root_node->left = solve(left_inorder, left_preorder, left_num);\n  if(right_num>0) root_node->right = solve(right_inorder, right_preorder, right_num);\n  \n  delete[] left_inorder;\n  delete[] right_inorder;\n  delete[] left_preorder;\n  delete[] right_preorder;\n  \n  return root_node;\n  \n}\n\nint main(){\n  int n; cin >> n;\n  int* inorder = new int[n];\n  int* preorder = new int[n];\n  \n  int tmp;\n  rep(i, 0, n){\n    cin >> tmp;\n    preorder[i] = tmp;\n  }\n  rep(i, 0, n){\n    cin >> tmp;\n    inorder[i] = tmp;\n  }\n\n  Node* root = NULL;\n  root = solve(inorder, preorder, n);\n  postorder(root);\n  rep(i, 0, 2*n-1) cout << ans[i]; \n  cout << endl;\n\n  delete[] inorder;\n  delete[] preorder;\n  delete root;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <set>\n#include <vector>\n\n#define FOR(i, l, r) for (i = (l); i < r; i++ )\n\nusing namespace std;\ntypedef long long ll;\n#define MAX_N (105)\nint n;\n\nint pre[MAX_N];\nint in[MAX_N];\nint pos;\nint printed;\n\nvoid dfs(int l, int r) {\n    if ( r - l <= 0 ) return;\n    int num = pre[pos++];\n    int pos_in;\n    // linear search.\n    for ( int i = l; i < r; i++ ) {\n\tif ( in[i] == num ) {\n\t    pos_in = i;\n\t    break;\n\t}\n    }\n\n    dfs( l, pos_in );\n    dfs( pos_in + 1, r );\n    printf(\"%d%c\", num, ((printed == n - 1) ? '\\n' : ' '));\n    printed++;\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for ( int i = 0; i < n; i++ ) scanf(\"%d\", &pre[i]);\n    for ( int i = 0; i < n; i++ ) scanf(\"%d\", &in[i]);\n\n    dfs(0, n);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> c;\nvector<int> pre, in;\n\nvoid post(int id) {\n\tif (id == -1)\n\t\treturn;\n\tpost(c[id][0]);\n\tpost(c[id][1]);\n\tcout << id + 1;\n\tif (id == pre[0] - 1)\n\t\tcout << endl;\n\telse\n\t\tcout << \" \";\n}\n\nint main()\n{\n\tint n = 0, t = 0;\n\n\tcin >> n;\n\n\tc.assign(n, {-1, -1});\t\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> t;\n\t\tpre.push_back(t);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> t;\n\t\tin.push_back(t);\n\t}\n\n\tvector<int>::iterator it1, it2;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tit1 = find(in.begin(), in.end(), pre[i]);\n\t\tit2 = find(in.begin(), in.end(), pre[i + 1]);\n\n\t\tif (it1 > it2)\n\t\t\tc[pre[i] - 1][0] = pre[i + 1] - 1;\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tit1 = find(pre.begin(), pre.end(), in[i]);\n\t\tit2 = find(pre.begin(), pre.end(), in[i + 1]);\n\n\t\tif (it1 < it2)\n\t\t\tc[in[i] - 1][1] = in[i + 1] - 1;\n\t}\n\n\tpost(pre[0] - 1);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace  std;\n\nconst int END = -1;\nstruct StNod\n{\n  int m_nParnt;\n  int m_nLeft;\n  int m_nRigt;\n\n  StNod() :\n     m_nParnt(END), m_nLeft(END), m_nRigt(END)\n  { }\n};\n\nvoid fnInput(vector<int> &rvnPodr, vector<int> &rvnIodrSeq)\n{\n  int nMaxSiz;\n\n  cin >> nMaxSiz;\n  rvnPodr.resize(nMaxSiz + 1);\n  rvnIodrSeq.resize(nMaxSiz + 1);\n\n  for (int i = 1; i < nMaxSiz + 1; i++)\n    cin >> rvnPodr[i];\n\n  int nNode;\n  for (int i = 1; i < nMaxSiz + 1; i++)\n  {\n    cin >> nNode;\n    rvnIodrSeq[nNode] = i;\n  }\n}\n\nvoid fnPostOrder(const vector<int> &cnrvnPodr, const vector<int> &cnrvnIodrSeq, int nLeft, int nRight)\n{\n  static int stnx = 1;\n  static int stnPrt = 0;\n\n  if (nLeft == nRight) return;\n\n  int nNode = cnrvnPodr[stnx++];\n  int nMid = cnrvnIodrSeq[nNode];\n\n  fnPostOrder(cnrvnPodr, cnrvnIodrSeq, nLeft, nMid);\n  fnPostOrder(cnrvnPodr, cnrvnIodrSeq, nMid + 1, nRight);\n\n  if (stnPrt++) cout << \" \";\n  cout << nNode;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vector<int> vnPodr, vnIodrSeq;\n  fnInput(vnPodr, vnIodrSeq);\n\n  fnPostOrder(vnPodr, vnIodrSeq, 1, vnPodr.size());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "package Main;\n\nimport java.util.Scanner;\n\nclass Node {\n\tint id, left, right, parent = -1;\n\n\tpublic Node(int Id, int l, int r) {\n\t\tid = Id;\n\t\tleft = l;\n\t\tright = r;\n\t}\n}\n\npublic class Main {\n\n\tpublic static void preorder(int i, Node[] node) {\n\t\tSystem.out.print(\" \" + node[i].id);\n\t\tif (node[i].left != -1) {\n\t\t\tpreorder(node[i].left, node);\n\t\t}\n\t\tif (node[i].right != -1) {\n\t\t\tpreorder(node[i].right, node);\n\t\t}\n\t}\n\n\tpublic static void inorder(int i, Node[] node) {\n\t\tif (node[i].left != -1) {\n\t\t\tinorder(node[i].left, node);\n\t\t}\n\t\tSystem.out.print(\" \" + node[i].id);\n\t\tif (node[i].right != -1) {\n\t\t\tinorder(node[i].right, node);\n\t\t}\n\t}\n\n\tpublic static void postorder(int i, Node[] node) {\n\t\tif (node[i].left != -1) {\n\t\t\tpostorder(node[i].left, node);\n\t\t}\n\t\tif (node[i].right != -1) {\n\t\t\tpostorder(node[i].right, node);\n\t\t}\n\t\tSystem.out.print(\" \" + node[i].id);\n\t}\n\n\tpublic static void PrIn(int[] pr, int[] in, Node[] node) {\n\t\tint i=0;\n\t\twhile(true){\n\t\t\tif(pr[i]==in[0])break;\n\t\t\t\n\t\t\ti++;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint i, n;\n\t\tn = scan.nextInt();\n\t\tNode[] node = new Node[n];\n\t\tint[] pr = new int[n];\n\t\tint[] in = new int[n];\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tpr[i] = scan.nextInt();\n\t\t\tin[i] = scan.nextInt();\n\t\t\tnode[i] = new Node(i, -1, -1);\n\t\t}\n\t\tPrIn(pr, in, node);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (node[i].parent == -1) {\n\t\t\t\tpostorder(i, node);\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tscan.close();\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nstatic const int MAX = 100;\nint pre[MAX], in[MAX];\nint preidx = 0;\n\n\nvoid reconstruction(int l, int r, int n) {\n    if (l >= r) return;\n    int c = pre[preidx++];\n    int m;\n    for (int i = 0; i < n; i++) {\n        if (in[i] == c) {\n            m = i;\n            break;\n        }\n    }\n    reconstruction(l, m, n); // 左部分木を復元\n    reconstruction(m + 1, r, n); // 右部分木を復元\n    if (c == pre[0]) cout << c << endl;\n    else cout << c << \" \";\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) cin >> pre[i];\n    for (int i = 0; i < n; i++) cin >> in[i];\n    reconstruction(0, n, n);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*! if g++ -g alds_1_7_d.cpp -o alds_1_7_d.out; then ./alds_1_7_d.out < alds_1_7_d.test; fi\n */\n\n#include <sstream>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iterator>\n#include <numeric>\n#include <functional>\n#include <climits>\n\n\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\nvector<int> pre(0);\nvector<int> ipre(0);\nvector<int> mid(0);\nvector<int> imid(0);\n\nclass node{\npublic:\n  int id, left, right;\n  node(): id(-1), left(-1), right(-1){}\n};\n\nvector<node> tree(0);\n\nint doit(int pl, int pr, int ml, int mr){\n  if(pl == pr) return -1;\n  int root_id = pre[pl];\n\n  int ml1 = ml;\n  int mr1 = imid[root_id];\n  int ml2 = mr1 + 1;\n  int mr2 = mr;\n\n  int pl1 = pl + 1;\n  int pr1 = pl1 + mr1 - ml1;\n  int pl2 = pr1;\n  int pr2 = pr;\n\n  node& nd = tree[root_id-1];\n  nd.id = root_id;\n  nd.left = doit(pl1, pr1, ml1, mr1);\n  nd.right = doit(pl2, pr2, ml2, mr2);\n  return root_id;\n}\n\nvector<int> ret;\n\nvoid post(int root){\n  node& nd = tree[root-1];\n  if(nd.left > 0) post(nd.left);\n  if(nd.right > 0) post(nd.right);\n  ret.push_back(nd.id);\n}\n\nint main(){\n  int n;\n  cin >> n;\n  pre.resize(n);\n  mid.resize(n);\n  ipre.resize(n);\n  imid.resize(n);\n  tree.resize(n);\n  for (int i = 0; i < n; i++) {\n    cin >> pre[i];\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> mid[i];\n  }\n  for (int i = 0; i < n; i++) {\n    ipre[pre[i]] = i;\n    imid[mid[i]] = i;\n  }\n  int root_id = doit(0, n, 0, n);\n  post(root_id);\n  for (int i = 0; i < n-1; i++) {\n    cout << ret[i] << \" \";\n  }\n  cout << ret.back() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdint.h>\n#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <climits>\n#include <vector>\nusing namespace std;\n\n#define DEBUG (0)\n\n#if DEBUG\n#define DPRINTF(...) do { \\\n    printf(\"D(L%d) %s: \", __LINE__, __func__); \\\n    printf(__VA_ARGS__); \\\n  } while (false)\n#else\n#define DPRINTF(...)\n#endif // DEBUG\n\n\nstruct Node {\n  Node() :\n    id_(-1),\n    left_(nullptr),\n    right_(nullptr) { }\n\n  int id_;\n  Node* left_;\n  Node* right_;\n};\n\n\nint findIndexOf(int val, int start, int end, const int array[])\n{\n  for (int i = start; i <= end; i++)\n  {\n    if (array[i] == val)\n      return i;\n  }\n\n  // The val must be found between start to end index\n  assert(false);\n}\n\nNode* reconstructTree(Node *node, int start, int end, const int preorder[], const int inorder[])\n{\n  DPRINTF(\"start %d  end %d\\n\", start, end);\n\n#if DEBUG\n  if (true) {\n    for (int i = start; i <= end; i++)\n    {\n      if (i == start) DPRINTF(\"preorder: %d\", preorder[i]);\n      else            printf(\" %d\", preorder[i]);\n    }\n    cout << endl;\n\n    for (int i = start; i <= end; i++)\n    {\n      if (i == start) DPRINTF(\"inorder:  %d\", inorder[i]);\n      else            printf(\" %d\", inorder[i]);\n    }\n    cout << endl;\n  }\n#endif\n\n  // Index conversion needed because node index ranges from 0 to N-1, while given index from input ranges from 1 to N\n  const int kOffset = 1;\n  const int rootNodeId = preorder[start];\n  const int nodeIndex = rootNodeId - kOffset;\n\n  // leaf\n  if (start == end)\n    return &node[nodeIndex];\n\n  // nullptr\n  if (start > end)\n    return nullptr;\n\n  // Determine which node is the root in this sub-tree\n  const int rootIndexOfInorder = findIndexOf(rootNodeId, start, end, inorder);\n\n  DPRINTF(\"rootNodeId %d  rootIndexOfInorder %d\\n\", rootNodeId, rootIndexOfInorder);\n\n  // Similarly, determine the root nodes of both the left and right sub-tree.\n  // Note that pre-order array has to be alligned before dive into recursively left side sub-tree.\n  int newPreorder[rootIndexOfInorder];\n\n  for (int i = start; i < rootIndexOfInorder; i++)\n    newPreorder[i] = preorder[i+1];\n\n#if DEBUG\n  if (false) {\n    for (int i = start; i < rootIndexOfInorder; i++)\n    {\n      if (i == start) DPRINTF(\"newPreorder: %d\", newPreorder[i]);\n      else            printf(\" %d\", newPreorder[i]);\n    }\n    cout << endl;\n  }\n#endif\n\n  node[nodeIndex].left_ = reconstructTree(node, start, rootIndexOfInorder-1, newPreorder, inorder);\n  node[nodeIndex].right_ = reconstructTree(node, rootIndexOfInorder+1, end, preorder, inorder);\n\n  if (true) {\n    int leftIndex = -1, rightIndex = -1;\n\n    if (node[nodeIndex].left_)\n      leftIndex = node[nodeIndex].left_->id_;\n\n    if (node[nodeIndex].right_)\n      rightIndex = node[nodeIndex].right_->id_;\n\n    DPRINTF(\"node %d / left %d / right %d\\n\", node[nodeIndex].id_, leftIndex, rightIndex);\n  }\n\n  return &node[nodeIndex];\n}\n\n\nvoid traversePostorder(const Node *node)\n{\n  static bool isCalledAlready = false;\n\n  if (node == nullptr)\n    return ;\n\n  if (node->left_ != nullptr)\n    traversePostorder(node->left_);\n\n  if (node->right_ != nullptr)\n    traversePostorder(node->right_);\n\n  if (isCalledAlready)\n    printf(\" \");\n  else\n    isCalledAlready = true;\n\n  printf(\"%d\", node->id_);\n\n}\n\n\nint main()\n{\n  int numOfNode;\n  cin >> numOfNode; cin.ignore();\n  DPRINTF(\"numOfNode %d\\n\", numOfNode);\n\n  int arrayOfPreorder[numOfNode];\n  int arrayOfInorder[numOfNode];\n\n  for (int i = 0; i < numOfNode; i++)\n  {\n    cin >> arrayOfPreorder[i];\n    assert(arrayOfPreorder[i] <= numOfNode);\n  }\n\n  for (int i = 0; i < numOfNode; i++)\n  {\n    cin >> arrayOfInorder[i];\n    assert(arrayOfPreorder[i] <= numOfNode);\n  }\n\n#if DEBUG\n  for (int i = 0; i < numOfNode; i++)\n  {\n    if (i == 0) DPRINTF(\"%d\", arrayOfPreorder[i]);\n    else        printf(\" %d\", arrayOfPreorder[i]);\n  }\n  cout << endl;\n\n  for (int i = 0; i < numOfNode; i++)\n  {\n    if (i == 0) DPRINTF(\"%d\", arrayOfInorder[i]);\n    else        printf(\" %d\", arrayOfInorder[i]);\n  }\n  cout << endl;\n#endif\n\n  Node *nodes = new Node[numOfNode];\n\n  // Assue input index ranges from 1 to N, while node index ranges from 0 to N-1\n  for (int i = 0; i < numOfNode; i++)\n    nodes[i].id_ = i + 1;\n\n  int start = 0;\n  int end = numOfNode - 1;\n  Node *root = reconstructTree(nodes, start, end, arrayOfPreorder, arrayOfInorder);\n\n  traversePostorder(root);\n  cout << endl;\n\n  delete[] nodes;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r){\n    if(l >= r) return;\n    int root = pre[pos];\n    int m = distance(in.begin(),find(in.begin(),in.end(),root));\n    rec(1,m);\n    rec(m + 1,r);\n    post.push_back(root);\n}\n\nvoid solve(){\n    pos = 0;\n    for (int i = 0; i < n ; ++i) {\n        if(i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main(){\n    int k;\n    cin >> n;\n\n    for (int i = 0; i < n ; ++i) {\n        cin >> k;\n        pre.push_back(k);\n    }\n    for (int i = 0; i < n ; ++i) {\n        in.push_back(k);\n    }\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, position;\nvector<int> pre;\nvector<int> in;\nvector<int> post;\n\nvoid rec (int l, int r) {\n  if (r <= l) {\n    return;\n  }\n  int root = pre[position++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(l, m);\n  rec(m + 1, r);\n  post.push_back(root);\n}\n\nvoid f () {\n  position = 0;\n  rec(0, pre.size());\n  for (int i = 0; i < n; i++) {\n    cout << post[i];\n    if (i != n - 1) {\n      cout << \" \";\n    }\n  }\n  cout << endl;\n}\n\nint main() {\n\n  cin >> n;\n\n  for (int i = 0; i < n; i++) {\n    int k;\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for (int i = 0; i < n; i++) {\n    int k;\n    cin >> k;\n    in.push_back(k);\n  }\n\n  f();\n\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nbool first_output = true;\n\nvoid output(std::vector<int> pre, std::vector<int> in, int pre_left, int pre_right, int in_left, int in_right)\n{\n\tif (pre_left == pre_right) return;\n\tif (pre_left + 1 == pre_right) {\n\t\tif (!first_output) std::cout << \" \";\n\t\telse first_output = false;\n\t\tstd::cout << pre[pre_left];\n\t\treturn;\n\t}\n\t\n\tint root = pre[pre_left];\n\tint root_pos_in_in;\n\tfor (int i=in_left; i<in_right; i++) {\n\t\tif (in[i] == root) { root_pos_in_in = i; break; }\n\t}\n\tint left_len = root_pos_in_in - in_left;\n\tint right_len = in_right - root_pos_in_in - 1;\n\toutput(pre, in, pre_left + 1, pre_left + 1 + left_len, in_left, in_left + left_len);\n\toutput(pre, in, pre_right - right_len, pre_right, in_right - right_len, in_right);\n\t\n\tif (!first_output) std::cout << \" \";\n\telse first_output = false;\n\tstd::cout << root;\n}\n\t\n\nint main()\n{\n\tint n;\n\tstd::cin >> n;\n\tstd::vector<int> pre, in;\n\tfor (int i=0; i<n; i++) {\n\t\tint node;\n\t\tstd::cin >> node;\n\t\tpre.push_back(node);\n\t}\n\tfor (int i=0; i<n; i++) {\n\t\tint node;\n\t\tstd::cin >> node;\n\t\tin.push_back(node);\n\t}\n\t\n\toutput(pre, in, 0, n, 0, n);\n\tstd::cout << std::endl;\n\t\n\treturn 0;\n}\n\t\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define NIL -1\nusing namespace std;\n\nint countp, A[101], B[101];\n\nint linearSearch(int S[], int key){\n\tint i = 0;\n\twhile(S[i] != key)\n\t\ti++;\n\treturn i;\n}\n\nvoid reconstruction(int l, int r){\n\tint c = 200, m, i;\n\tif(l >= r)\n\t\treturn;\n\tfor(i = l;i < r;i++)\n\t\tc = min(c, linearSearch(A, B[i]));\n\tm = linearSearch(B, A[c]);\n\treconstruction(l, m);\n\treconstruction(m + 1, r);\n\tif(countp)\n\t\tprintf(\" \");\n\tcountp++;\n\tprintf(\"%d\", A[c]);\n}\n\nint main(void){\n\tint n, i;\n\tscanf(\"%d\", &n);\n\tfor(i = 0;i < n;i++)\n\t\tscanf(\"%d\", &A[i]);\n\tfor(i = 0;i < n;i++)\n\t\tscanf(\"%d\", &B[i]);\n\treconstruction(0, n);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint preorder[40],inorder[40];\nvoid recover(int fp,int lp,int fi,int li){\n\tint root=fi;\n\tfor(;root<li;root++)if(preorder[fp]==inorder[root])break;\n\tif(fi<root)recover(fp+1,fp+(root-fi)+1,fi,root);\n\tif(root<li-1)recover(fp+(root-fi)+1,lp,root+1,li);\n\tprintf(inorder[root]==preorder[0]?\"%d\\n\":\"%d \",inorder[root]);\n}\nmain(){\n\tint n,i;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++)scanf(\"%d\",preorder+i);\n\tfor(i=0;i<n;i++)scanf(\"%d\",inorder+i);\n\trecover(0,n,0,n);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define NIL -1\n#define MAX 40\n\nint A[MAX], B[MAX];\nqueue<int> C;\n\nvoid Preorder(int start, int end) {\n  int i = 0;\n  for (i = start; i <= end-start; i++) {\n    if (A[start] == B[i]) {\n      for (int j = i; j > start; j--) {\n        swap(B[j-1], B[j]);\n      }\n      break;\n    }\n  }\n  //for ( int i = 0; i < 5; i++ ) printf(\"%d \", B[i]);\n  if (i-(start+1) >= 0 ) Preorder(start+1, i);\n  if (end-(i+1) >= 0 ) Preorder(i+1, end);\n  C.push(A[start]);\n}\n\nint main() {\n\tint n;\n  scanf(\"%d\", &n);\n  for ( int i = 0; i < n; i++ ) scanf(\"%d\", &A[i]);\n  for ( int i = 0; i < n; i++ ) scanf(\"%d\", &B[i]);\n  Preorder(0, n-1);\n\n  while ( !C.empty() ) {\n    if (C.size() == 1) {\n      printf(\"%d\", C.front());\n      break;\n    }\n    printf(\"%d \", C.front());\n    C.pop();\n  }\n  printf(\"\\n\");\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define NMAX 110\n\nint A[NMAX]; // preorder seq\nint B[NMAX]; // inorder seq\nint k = 0;   // A[k] is the root of B[l:r), why?\nint n;\n\nvoid solve(int l, int r) {\n    // range: [l, r)\n    if (r - l <= 0) {\n        return;\n    }\n    int m = 0, root = A[k++];\n    while (B[m] != root)\n        m++;\n    solve(l, m);\n    solve(m + 1, r);\n    printf(\"%d\", root);\n    if (root == A[0]) {\n        printf(\"\\n\");\n    } else {\n        printf(\" \");\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &B[i]);\n    }\n    solve(0, n);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <algorithm>\n \nenum TNodeType {ntRoot, ntInternal, ntLeaf};\ntemplate<typename T>\nclass TTree;\n \ntemplate<typename T>\nclass TNode\n{\n    const T FValue;\n    TNode* FParent;\n    TNode* FLeft;\n    TNode* FRight;\n\npublic:\n    TNode(const T& Value)\n     : FValue(Value)\n    {\n        FParent = NULL;\n        FLeft   = NULL;\n        FRight  = NULL;\n    }\n    T Value()const\n    {\n        return FValue;\n    }\n    void AddNode(TNode* Node)\n    {\n        Node->FParent = this;\n        if(FValue < Node->FValue){\n            assert(FRight);\n            FRight = Node;\n        }else{\n            assert(FLeft);\n            FLeft  = Node;\n        }\n    }\n    void SetLeft(TNode* Node)\n    {\n        Node->FParent = this;\n        FLeft = Node;\n    }\n    void SetRight(TNode* Node)\n    {\n        Node->FParent = this;\n        FRight = Node;\n    }\n    TNode* CreateLeft(const T& Value)\n    {\n        assert(FLeft == NULL);\n        SetLeft(new TNode(Value));\n        return FLeft;\n    }\n    TNode* CreateRight(const T& Value)\n    {\n        assert(FRight == NULL);\n        SetRight(new TNode(Value));\n        return FRight;\n    }\n    const TNode* Parent()const\n    {\n        return FParent;\n    }\n    const TNode* Left()const\n    {\n        return FLeft;\n    }\n    const TNode* Right()const\n    {\n        return FRight;\n    }\n    const TNode* Find(const T& Value)const\n    {\n        // std::cout << \"Find(\" << Value << \")\" << std::endl;\n        if(FValue == Value) return this;\n        TNode* Node = FValue < Value ? FRight : FLeft;\n        if(Node) return Node->Find(Value);\n        return NULL;\n    }\n    TNode* Find(const T& Value)\n    {\n        return const_cast<TNode*>(const_cast<const TNode*>(this)->Find(Value));\n    }\n};\n\ntemplate<typename T>\nint GetNodeDepth(const TNode<T>* Node)\n{\n    assert(Node);\n    int Depth = 0;\n    while(Node->Parent()){\n        Node = Node->Parent();\n        Depth++;\n    }\n    return Depth;\n}\n \ntemplate<typename T>\nTNodeType GetNodeType(const TNode<T>* Node)\n{\n    assert(Node);\n    if(Node->Parent() == NULL) return ntRoot;\n    if(Node->Left() || Node->Right()) return ntInternal;\n    return ntLeaf;\n}\nstd::string GetNodeTypeText(const TNodeType& Type)\n{\n    switch(Type){\n    case ntRoot:     return \"root\";\n    case ntInternal: return \"internal node\";\n    case ntLeaf:     return \"leaf\";\n    }\n    assert(false);\n    return \"\";\n}\n \ntemplate<typename T>\nconst TNode<T>* GetSibling(const TNode<T>* Node)\n{\n    assert(Node);\n    const TNode<T>* Parent = Node->Parent();\n    if(Parent == NULL) return NULL;\n    if(Parent->Left()  && Parent->Left()  != Node) return Parent->Left();\n    if(Parent->Right() && Parent->Right() != Node) return Parent->Right();\n    return NULL;\n}\ntemplate<typename T>\nconst TNode<T>* GetRoot(const TNode<T>* Node)\n{\n    if(Node->Parent()) return GetRoot(Node->Parent());\n    return Node;\n}\ntemplate<typename T>\nint GetDegree(const TNode<T>* Node)\n{\n    return (Node->Left() ? 1 : 0) + (Node->Right() ? 1 : 0);\n}\n\ntemplate<typename T>\nint GetHeight(const TNode<T>* Node)\n{\n    if(Node == NULL) return -1;\n    return 1 + std::max(GetHeight(Node->Left()), GetHeight(Node->Right()));\n}\ntemplate<typename T>\nvoid PrintNode(const TNode<T>* Node)\n{\n    assert(Node);\n// node 0: parent = -1, sibling = -1, degree = 2, depth = 0, height = 3, root    \n    std::cout << \n    \"node \"       << Node->Value() <<\n    \": parent = \" << (Node->Parent() ? Node->Parent()->Value() : -1) <<\n    \", sibling = \"<< (GetSibling(Node) ? GetSibling(Node)->Value() : -1) <<\n    \", degree = \" << GetDegree(Node) <<\n    \", depth = \"  << GetNodeDepth(Node) <<\n    \", height = \"  << GetHeight(Node) << \n    \", \"          << GetNodeTypeText(GetNodeType(Node)) <<\n    std::endl;\n}\n// template<typename T>\n// void PrintPreorder(const TNode<T>* Node)\n// {\n// //  0 1 2 3 4 5 6 7 8\n//     if(Node == NULL) return;\n//     std::cout << \" \" << Node->Value();\n//     PrintPreorder(Node->Left());\n//     PrintPreorder(Node->Right());\n// }\n// template<typename T>\n// void PrintInorder(const TNode<T>* Node)\n// {\n// //  2 1 3 0 6 5 7 4 8\n//     if(Node == NULL) return;\n//     PrintInorder(Node->Left());\n//     std::cout << \" \" << Node->Value();\n//     PrintInorder(Node->Right());\n// }\ntemplate<typename T>\nvoid PrintPostorder(const TNode<T>* Node)\n{\n//  2 3 1 6 7 5 8 4 0\n    if(Node == NULL) return;\n    PrintPostorder(Node->Left());\n    PrintPostorder(Node->Right());\n    std::cout << Node->Value();\n    if(Node->Parent()){\n        std::cout << \" \";\n    }else{\n        std::cout << std::endl;\n    }\n}\n\ntemplate<typename T, typename TIt>\nvoid AddNode(TNode<T>* Node, TIt& PreBegin, TIt PreEnd, TIt InBegin, TIt InEnd);\n\ntemplate<typename T, typename TIt>\nvoid AddLeftNode(TNode<T>* Node, TIt& PreBegin, TIt PreEnd, TIt InBegin, TIt InEnd)\n{\n    assert(PreBegin != PreEnd);\n    if(InBegin == InEnd) return;\n    TNode<T>* New = new TNode<T>(*PreBegin);\n    Node->SetLeft(New);\n    AddNode(New, ++PreBegin, PreEnd, InBegin, InEnd);\n}\n\ntemplate<typename T, typename TIt>\nvoid AddRightNode(TNode<T>* Node, TIt& PreBegin, TIt PreEnd, TIt InBegin, TIt InEnd)\n{\n    assert(PreBegin != PreEnd);\n    if(InBegin == InEnd) return;\n    TNode<T>* New = new TNode<T>(*PreBegin);\n    Node->SetRight(New);\n    AddNode(New, ++PreBegin, PreEnd, InBegin, InEnd);\n}\n\ntemplate<typename T, typename TIt>\nvoid AddNode(TNode<T>* Node, TIt& PreBegin, TIt PreEnd, TIt InBegin, TIt InEnd)\n{\n    if(PreBegin == PreEnd)  return;\n    TIt It = std::find(InBegin, InEnd, Node->Value());\n    assert(It != InEnd);\n    AddLeftNode(Node, PreBegin, PreEnd, InBegin, It);\n    AddRightNode(Node, PreBegin, PreEnd, It+1, InEnd);\n}\n\nint main()\n{\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    int n;\n    std::cin >> n;\n    std::vector<int> PreOrderIdList(n);\n    for(int i = 0; i < n; ++i){\n        std::cin >> PreOrderIdList[i];\n    }\n    std::vector<int> InOrderIdList(n);\n    for(int i = 0; i < n; ++i){\n        std::cin >> InOrderIdList[i];\n    }\n    \n    TNode<int> Node(PreOrderIdList[0]);\n    std::vector<int>::iterator It = PreOrderIdList.begin();\n    AddNode(&Node, ++It, PreOrderIdList.end(), InOrderIdList.begin(), InOrderIdList.end());\n\n    PrintPostorder(&Node);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define NIL -1\n#define MAX 40\n\nint A[MAX], B[MAX];\nqueue<int> C;\n\nvoid Preorder(int start, int end) {\n  int i = 0;\n  for (i = start; i <= end; i++) {\n    if (A[start] == B[i]) {\n      for (int j = i; j > start; j--) {\n        swap(B[j-1], B[j]);\n      }\n      break;\n    }\n  }\n\n  if (i-(start+1) >= 0 ) Preorder(start+1, i);\n  if (end-(i+1) >= 0 ) Preorder(i+1, end);\n  C.push(A[start]);\n}\n\nint main() {\n\tint n;\n  scanf(\"%d\", &n);\n  for ( int i = 0; i < n; i++ ) scanf(\"%d\", &A[i]);\n  for ( int i = 0; i < n; i++ ) scanf(\"%d\", &B[i]);\n  Preorder(0, n-1);\n\n  while ( !C.empty() ) {\n    if (C.size() == 1) {\n      printf(\"%d\", C.front());\n      break;\n    }\n    printf(\"%d \", C.front());\n    C.pop();\n  }\n  printf(\"\\n\");\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define eol '\\n';\nusing namespace std;\n\nclass Node {\npublic:\n  int id;\n  int l;\n  int r;\n  int p;\n  Node(): id(-1),l(-1),r(-1),p(-1){};\n};\n\nNode* tree;\n\nint create_tree(int parent, vector<int> pre, vector<int> in) {\n    if (pre.size() == 0 && in.size() == 0) {\n      return -1;\n    }\n\n    int root_id = pre[0];\n\n    Node* node = &tree[root_id];\n    node->p = parent;\n    \n    // left\n    vector<int> left_pre;\n    vector<int> left_in;\n\n    int i = 0;\n    int size = in.size();\n    for (; i < size; i++) {\n      if (in[i] == root_id) {\n        break;\n      }\n      left_pre.push_back(pre[i+1]);\n      left_in.push_back(in[i]);\n    }\n    node->l = create_tree(root_id, left_pre, left_in);\n\n    vector<int> right_pre;\n    vector<int> right_in;\n\n    i++;\n    for (;i < size; i++) {\n      right_pre.push_back(pre[i]);\n      right_in.push_back(in[i]);\n    }\n/*\n    node->r = create_tree(root_id, right_pre, right_in);\n*/\n    return root_id;\n}\n\nvector<int> postorder(int id, vector<int> post) {\n  Node* node = &tree[id];\n  if (node->l != -1) {\n    post = postorder(node->l, post);\n  }\n  if (node->r != -1) {\n    post = postorder(node->r, post);\n  }\n  post.push_back(id);\n\n  return post;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  \n  int n,i;\n  cin >> n;\n\n  tree = new Node[n];\n\n  vector<int> preorder(n);\n  vector<int> inorder(n);\n\n  for (i = 0; i < n; i++) {\n    cin >> preorder[i];\n  }\n  for (i = 0; i < n; i++) {\n    cin >> inorder[i];\n  }\n\n  int root = create_tree(-1, preorder, inorder);\n\n  // post order\n  vector<int> post;\n  post = postorder(root, post);\n\n  // output\n  cout << post[0];\n  for (i = 1; i < n; i++) {\n    cout << \" \" << post[i];\n  }\n  cout << eol;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r){ \n    if(l>=r)return;\n    int root=pre[pos++];\n    int m=distance(in.begin(),find(in.begin(),in.end(),root));        \n    rec(l,m);\n    rec(m+1,r);\n    post.push_back(root);\n}\nvoid solve(){\n    pos=0;\n    rec(0,pre.size());\n    for(int i=0;i<n;i++){\n        if(i)cout<<\" \";\n        cout<<post[i];\n    }   \n    cout<<\"\\n\";\n}\nint main(){\n    int k;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>k;\n        pre.push_back(k);\n    }   \n    for(int i=0;i<n;i++){\n        cin>>k;\n        in.push_back(k);\n    }   \n    solve();\n    return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint pre[40],in[40],n;\n\nvoid solve(int main,int left,int right){\n\tif(left+1>=right){\n\t\tcout<<in[left]<<\" \";\n\t\treturn;\n\t}\n\tfor(int i=left;i<right;i++){\n\t\tif(pre[main]==in[i]){\n\t\t\tif(left!=i)\tsolve(main+1,left,i);\n\t\t\tif(right-1!=i)\tsolve(i+1,i+1,right);\n\t\t\tcout<<in[i]<<\" \";\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\tcin>>pre[i];\n\tfor(int i=0;i<n;i++)\tcin>>in[i];\n\t\n\tfor(int i=0;i<n;i++){\n\t\tif(pre[0]==in[i]){\n\t\t\tif(i!=0)\tsolve(1,0,i);\n\t\t\tif(i!=n-1)\tsolve(i+1,i+1,n);\n\t\t\tcout<<pre[0]<<\" \";\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout<<\"\\b\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint NIL=-1;\nint n,pos=0;\nvector<int> pre,in,post;\n\nvoid set_tree(int idx,int idy){//右端は含まないクチ.\n    if(idy<=idx)return;\n    int root=pre[pos++];\n    int m=distance(in.begin(),find(in.begin(),in.end(),root));\n    set_tree(idx,m);\n    set_tree(m+1,idy);\n    post.push_back(root);\n}\nint main(){\n    cin>>n;\n    for(int i=0;i<n;i++){int k;cin>>k;pre.push_back(k);}\n    for(int i=0;i<n;i++){int k;cin>>k;in.push_back(k);}\n    set_tree(0,n);\n    for(int i=0;i<n;i++){\n        if(i)cout<<\" \";\n        cout<<post[i];\n    }\n    cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nstd::vector<int> readVector(int n) {\n  std::vector<int> v;\n  for (int i = 0; i < n; ++i) {\n    int id;\n    std::cin >> id;\n    v.push_back(id);\n  }\n  return v;\n}\n\nstruct Tree {\n  int left = -1;\n  int right = -1;\n};\n\nstruct SubVector {\n  int begin;\n  int end;\n};\n\nclass Trees {\nprivate:\n  int root;\n  std::vector<Tree> trees;\n  std::vector<int> preordered;\n  std::vector<int> inordered;\n  int r_makeTree(SubVector pre, SubVector in);\n  void r_postorderTreeWalk(int n);\npublic:\n  Trees(std::vector<int>& pre, std::vector<int>& in, int n);\n  void makeTree();\n  void postorderTreeWalk();\n};\n\nTrees::Trees(std::vector<int>& pre, std::vector<int>& in, int n) {\n  trees = std::vector<Tree>(n);\n  preordered = pre;\n  inordered = in;\n}\n\nint Trees::r_makeTree(SubVector pre, SubVector in) {\n  if (pre.end - pre.begin == 0)\n    return -1;\n  int r = preordered[pre.begin];\n  if (pre.end - pre.begin == 1) {\n    return r;\n  }\n  int partition = 0;\n  for (int i = 0; i < in.end - in.begin; ++i) {\n    if (inordered[in.begin + i] == r) {\n      partition = i;\n      break;\n    }\n  }\n  trees[r-1].left = r_makeTree({pre.begin + 1, pre.begin + 1 + partition},\n                             {in.begin, in.begin + partition});\n  trees[r-1].right = r_makeTree({pre.begin + partition + 1, pre.end},\n                              {in.begin + partition + 1, in.end});\n  return r;\n}\n\nvoid Trees::makeTree() {\n  root = r_makeTree({0, (int)preordered.size()}, {0, (int)inordered.size()});\n}\n\n\nvoid Trees::r_postorderTreeWalk(int n) {\n  if (trees[n-1].left != -1)\n    r_postorderTreeWalk(trees[n-1].left);\n  if (trees[n-1].right != -1) {\n    r_postorderTreeWalk(trees[n-1].right);\n  }\n  std::cout << \" \" << n;\n}\n\nvoid Trees::postorderTreeWalk() {\n  r_postorderTreeWalk(root);\n  std::cout << std::endl;\n}\n\nint main() {\n  int n;\n  std::cin >> n;\n  std::vector<int> preordered = readVector(n);\n  std::vector<int> inordered = readVector(n);\n  Trees t(preordered, inordered, n);\n  t.makeTree();\n  t.postorderTreeWalk();\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n//ALDS1_7_B:   Binary Trees\n//\n//??????????????????????????¨\n////////////////////////////////////////\n\n#include <iostream>\n#include <algorithm> // next_permutation\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <list>\n#include <numeric> //accumulate\n//#include <unordered_map> //???????????\\??¢??°\n#include <fstream> //ifstream, ofstream\n\n//#define NDEBUG //NDEBUG???#include <cassert>???????????????????????????????????´???assert?????????????????????????????????NDEBUG?????????????????????????????????????????????\n#include <cassert> //assert\n\n\nusing namespace std;\n\n//???????????°??????TEST????????????????????¬???????????????????????????????????¢????????????\n#define TEST //*******************************************************************************************************************************************\n//?????????????????¨??§?????\\????????????????????????????????°?????????????¨???????????????????dout???????????????????????§???????????¬??????????????????????????????????????????\n//??????????????????????????????????????????????????????????§?CPU???????£??????????????????§???TLE?????????????????????????????????????????§????????¨???                           ????????????????????????cerr????????£????????????????????????????????????\n#ifdef TEST\n#define dout cout\n#else\nstringstream dummy; //???????????°??????dout?????????????????????????????????\n#define dout dummy.str(\"\"); dummy.clear(stringstream::goodbit); dummy //dummy?????????????????????????????????????????¨?????¢?????¢???????????????\n//???????????¨??????????????????goodbit?????????????????????????????¨???????????´????????????????????????????????¨?????°?????????????????§???????????????????????????????????? http://d.hatena.ne.jp/linden/20060427/p1\n#endif\n\n//?¨??????????????????????????????????????????????????????´??????OUTPUT2TEXTFILE????????????????????¬???????????????????????????????????¢????????????\n//#define OUTPUT2TEXTFILE //*******************************************************************************************************************************************\n#ifdef OUTPUT2TEXTFILE\n#define dout outputfile //??¨????????????TLE????????§?????????dout?????¨??¨??????????????¢????????????????????????????????????????????§????¨????????????´??????????????£??????????????????????¨?????????????????????????????????????????????§?????????????????????\n//TEST??????????????????????????¨???outputfile??????????????????????????????\n#define OUTPUTFILENAME \"output.txt\"\nofstream outputfile(OUTPUTFILENAME);\n#define OutputFilePath \"/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt\"\n#endif\n\n#define disp(A) dout << #A << \" = \" << (A) << endl\n#define disP(A) dout << setw(3) << (A) << \" \" // << setw(3) ??????????????\\????????????\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n\n#define dispAll(A,n) dout << #A << \" = \"; rep(j, 0, (n)) {disP(A[j]);} dout << endl\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef unsigned long long ll;\n\nconst int INF = 1e9-1;\n\nclass Node;\n\nvector<Node> node;\nvi printer;\n\n\nclass Node {\npublic:\n    Node() {\n        parent = -1;\n        left = -1;\n        right = -1;\n    }\n    \n    int parent;\n    int left;\n    int right;\n    \n    \n    int depth() {\n        int p = this->parent;\n        int d = 0;\n        \n        while( p != -1 ) {\n            d++;\n            p = node[p].parent;\n        }\n        \n        return d;\n    }\n    \n    static int height(int id) {\n        if(id == -1) return -1;\n        \n        return max( height(node[id].left), height(node[id].right)) + 1;\n    }\n    \n    static void printNodePreorder(int id) {\n        if(id==-1) return;\n        \n        cout << \" \" << id;\n        printNodePreorder(node[id].left);\n        printNodePreorder(node[id].right);\n    }\n    \n    static void printNodeInorder(int id) {\n        if(id==-1) return;\n        \n        printNodeInorder(node[id].left);\n        cout << \" \" << id;\n        printNodeInorder(node[id].right);\n    }\n    \n    static void printNodePostorder(int id) {\n        if(id==-1) return;\n        \n        printNodePostorder(node[id].left);\n        printNodePostorder(node[id].right);\n        printer.push_back(id);\n//        cout << \" \" << id;\n    }\n    \n    \n};\n\n\n\nint main(){\n    int N; cin >> N;\n    rep(i,0,N+1) node.push_back(*new Node());\n    \n    //read input data\n//    int p, c1, c2;\n//    rep(i,0,N) {\n//        //        dout<<\"------\";\n//        //        disp(i);\n//        cin >> p >> c1 >> c2;\n//        \n//        node[p].left = c1;\n//        node[p].right = c2;\n//        \n//        if(c1!=-1) node[c1].parent = p;\n//        if(c2!=-1) node[c2].parent = p;\n//    }\n    int preorder[N+1], inorder[N+1], indexOfInorder[N+1];\n    \n    rep(i,1,N+1) cin >> preorder[i];\n    rep(i,1,N+1) cin >> inorder[i];\n\n\n    rep(i,1,N+1) { //preorder[i]???inorder[]????????????????????????????????????indexOfInorder[i]???????´???????\n        int key = preorder[i];\n        rep(j,1,N+1) {\n            if(key == inorder[j]) {\n                indexOfInorder[i] = j;\n                break;\n            }\n        }\n    }\n    \n\n    \n    //reconstruct tree\n    //Preorder?????°???????????????????????????????????????????????????????????????\n    //????????¨??????Inorder????????±????????????????????????????????????????±????????????????\n    \n    rep(i,2,N+1) { //?????????preorder[i]???????????????\n        if( indexOfInorder[i] < indexOfInorder[i-1] ) {\n            node[ preorder[i-1] ].left = preorder[i];\n            node[ preorder[i] ].parent = preorder[i-1];\n        } else {\n            node[ inorder[ indexOfInorder[i] - 1 ] ].right = preorder[i];\n            node[ preorder[i] ].parent = inorder[ indexOfInorder[i] - 1 ];\n        }\n        \n//        //test display\n//        dout<<\"-----------------\\n\";\n//        dout << \"  i   l   r   p\\n\";\n//        rep(i,0,N+1) {\n//            disP(i);\n//            disP(node[i].left); disP(node[i].right); disP(node[i].parent);\n//            dout << endl;\n//        }\n    }\n    \n    \n    \n    \n    \n//    //output\n//    rep(i,0,N+1) {\n//        cout << \"node \" << i << \": parent = \" << node[i].parent\n//        << \", sibling = \" << (node[i].parent==-1 ? -1 : (node[node[i].parent].left==i ? node[node[i].parent].right : node[node[i].parent].left) )\n//        << \", degree = \" << (node[i].left==-1 ? (node[i].right==-1 ? 0 : 1) : (node[i].right==-1 ? 1 : 2))\n//        << \", depth = \" << node[i].depth()\n//        << \", height = \" << Node::height(i) << \", \"\n//        << (node[i].parent==-1 ? \"root\" : (node[i].left==-1 && node[i].right==-1 ? \"leaf\" : \"internal node\") ) << endl;\n//    }\n    \n    \n    //find root\n    int root_i = -1;\n    rep(i,1,N+1) {\n        if(node[i].parent==-1) {\n            root_i = i;\n            break;\n        }\n    }\n    assert(root_i!=-1);\n    \n    //print tree\n//    cout << \"Preorder\\n\";\n//    Node::printNodePreorder(root_i);\n//    cout << endl;\n//    \n//    cout << \"Inorder\\n\";\n//    Node::printNodeInorder(root_i);\n//    cout << endl;\n//    \n//    cout << \"Postorder\\n\";\n    Node::printNodePostorder(root_i);\n    \n    rep(i,0,N) {\n        if(i==0) cout << printer[i];\n        else cout << \" \" << printer[i];\n    }\n    cout << endl;\n    \n    \n#ifdef OUTPUT2TEXTFILE\n    outputfile.close();\n    cout << \"\\\"\" << OutputFilePath << \"\\\"\" << endl;\n#endif\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream> using namespace std; int n,m=0,a[40],b[40],c[41]; void solve(int l,int r){ if(l>r)return; int x=a[m++]; solve(l,c[x]-1); solve(c[x]+1,r); cout<<x<<(x==a[0]?\"\\n\":\" \"); } int main(){ cin>>n; for(int i=0;i<n;i++)cin>>a[i]; for(int i=0;i<n;i++)cin>>b[i],c[b[i]]=i; solve(0,n-1); return 0; } \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n  if(l >= r) return;\n     int root = pre[pos++];\n     int m = distance(in.begin(), find(in.begin(), in.end(), root));\n     rec(l,m);\n     rec(m + 1,r);\n     post.push_back(root);\n}\n\nvoid solve(){\n  pos = 0;\n  rec(0, pre.size());\n  for(int i = ; i < n ; i++){\n    if(i) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main(){\n  int k;\n  cin >> n;\n\n  for(int i = 0 ; i < n ; i++){\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for(int i = 0 ; i < n ; i++){\n    cin >> k;\n    in.push_back(k);\n  }\n\n  solve();\n\n  return 0;\n}\n     \n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstring>\n\nusing namespace std;\n\nconst double PI = 3.14159265358979;\n\nstruct Node {\n\tint parent = -1;\n\tint left = -1, right = -1;\n\n};\n\nNode* tree;\nint* pre;\nint* mid;\nint pos;\nint n;\nint first = 1;\n\nvoid postorder(int root) {\n\n\tif (root != -1) {\n\t\tpostorder(tree[root].left);\n\t\tpostorder(tree[root].right);\n\t\tif (first) {\n\t\t\tprintf(\"%d\", root);\n\t\t\tfirst = 0;\n\t\t}\n\t\telse printf(\" %d\", root);\n\n\t}\n}\n\nint find_root(int key) {\n\tfor (int i = 0; i < n; i++)\t{\n\t\tif (mid[i] == key) \n\t\t\treturn i;\n\t}\n}\n\n\nint reconstruct(int left, int right) {\n\n\tif (right - left == 1) \n\t\treturn pre[pos++];\n\telse if (left + 1 < right) {\n\t\tint root = pre[pos++];\n\t\tint xxx = find_root(root);\n\t\ttree[root].left = reconstruct(left, xxx);\n\t\ttree[root].right = reconstruct(xxx + 1, right);\n\t\treturn root;\n\t}\n\telse {\n\t\treturn -1;\n\t}\n}\n\nint main() {\n\n\tcin >> n; \n\n\ttree = new Node[n + 1];\n\n\tpre = new int[n];\n\tmid = new int[n];\n\n\tfor (int i = 0; i < n; i++)\t{\n\t\tscanf(\"%d\", &pre[i]);\n\t}\n\n\tfor (int i = 0; i < n; i++)\t{\n\t\tscanf(\"%d\", &mid[i]);\n\t}\n\tpos = 0;\n\n\treconstruct(0, n);\n\tpostorder(pre[0]);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n    if (l>=r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(1, m);\n    rec(m+1, r);\n    post.push_back(root);\n}\n\nvoid solve() {\n    pos = 0;\n    rec(0, pre.size());\n    for (int i=0; i<n; i++) {\n        if(i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main() {\n    int k;\n    cin >> n;\n    \n    for (int i=0; i<n; i++) {\n        cin >> k;\n        pre.push_back(k);\n    }\n    \n    for (int i=0; i<n; i++) {\n        cin >> k;\n        in.push_back(k);\n    }\n    \n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nstatic const int MAX = 100;\nstatic const int NIL = -1;\n\nstruct Node\n{\n  int left;\n  int right;\n\n  Node():\n    left(NIL),\n    right(NIL)\n  {}\n};\n\nNode tree[MAX];\nint preorder[MAX];\nint inorder[MAX];\nint postorder[MAX];\n\nint reconstruct(int n, int pre_begin, int in_begin)\n{\n  if (n <= 0)\n    return -1;\n\n  int root = preorder[pre_begin];\n\n  int in_root_id = 0;\n  for (int i = in_begin; i < in_begin + n; ++i)\n  {\n    if (inorder[i] == root)\n    {\n      in_root_id = i;\n      break;\n    }\n  }\n\n  tree[root].left = reconstruct(in_root_id - in_begin,\n                                pre_begin + 1,\n                                in_begin);\n  tree[root].right = reconstruct(in_begin - in_root_id + n - 1,\n                                 pre_begin - in_begin + in_root_id + 1,\n                                 in_root_id + 1);\n\n  return root;\n}\n\nvoid genaratePostorder(int id)\n{\n  static int i = 0;\n\n  if (id == NIL)\n    return;\n\n  genaratePostorder(tree[id].left);\n  genaratePostorder(tree[id].right);\n  postorder[i] = id;\n  ++i;\n}\n\nint main()\n{\n  int n;\n  scanf(\"%d\", &n);\n\n  for (int i = 0; i < n; ++i)\n    scanf(\"%d\", &preorder[i]);\n  for (int i = 0; i < n; ++i)\n    scanf(\"%d\", &inorder[i]);\n\n  reconstruct(n, 0, 0);\n\n  genaratePostorder(preorder[0]);\n\n  for (int i = 0; i < n; ++i)\n  {\n    printf(\"%d\", postorder[i]);\n    if (i < n - 1)\n      printf(\" \");\n  }\n  printf(\"\\n\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nconst int NIL = -1;\nstruct node\n{\n  int parent = NIL;\n  int left = NIL;\n  int right = NIL;\n};\n\n\n\nusing vector = std::vector<int>;\nusing iterator = vector::iterator;\n\nvoid populate_tree(vector pre_order, iterator& itr_key, iterator in_begin, iterator in_end, vector& post_order)\n{\n  if (in_begin >= in_end)\n    {\n      return;\n    }\n  auto key= *itr_key;\n  auto itr = in_begin;\n  while (itr != in_end)\n    {\n      if (*itr == *itr_key)\n        {\n          break;\n        }\n      ++itr;\n    }\n\n  ++itr_key;\n\n  populate_tree(pre_order, itr_key, in_begin, itr, post_order);\n  populate_tree(pre_order, itr_key, itr+1, in_end, post_order);\n  //std::cout << key << \" \";\n  post_order.push_back(key);\n\n}\n\nauto print_vector = [](iterator begin, iterator end){\n                      while(begin != end)\n                        {\n                          std::cout << *begin;\n                          ++begin;\n                          if (begin == end) std::cout << std::endl;\n                          else std::cout << \" \";\n                        }\n                    };\n\nint main()\n{\n  int n;\n  std::cin >> n;\n\n  vector pre_order, in_order, post_order;\n  for(int i=0; i<n; ++i)\n    {\n      int tmp;\n      std::cin >>tmp;\n      pre_order.push_back(tmp);\n    }\n  for(int i=0; i<n; ++i)\n    {\n      int tmp;\n      std::cin >>tmp;\n      in_order.push_back(tmp);\n    }\n\n  auto itr_key = pre_order.begin();\n  populate_tree(pre_order, itr_key, in_order.begin(), in_order.end(), post_order);\n  print_vector(post_order.begin(), post_order.end());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include<algorithm>\n#include <vector>\n\nusing namespace std;\nvector<int> pre,in,post;\nint n,pos;\n\nvoid rec(int l,int r){\n    if(l>=r) return;\n    int root=pre[pos++];\n    int m=distance(in.begin(),find(in.begin(),in.end(),root));\n    rec(l,m);\n    rec(m+1,r);\n    post.push_back(root);\n}\n\nvoid solve(){\n    pos=0;\n    rec(0,pre.size());\n    for(int i=0;i<n;i++){\n        if(i) cout<<\" \";\n        cout<< post[i];\n    }\n    cout<<endl;\n}\n\nint main()\n{\n    int k;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>k;\n        pre.push_back(k);\n    }\n\n    for(int i=0;i<n;i++){\n        cin>>k;\n        in.push_back(k);\n    }\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\n\nint n, pos;\nvector<int>pre, in, post;\n\nvoid rec(int l, int r) {\n\tif (l >= r)return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\nvoid solve() {\n\tpos = 0;\n\trec(0, pre.size());\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i)cout << \" \";\n\t\tcout << post[i];\n\n\t}cout << endl;\n}\n\nint main() {\n\tint k;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\nusing namespace std;\n\n\nclass PostorderReconstructor {\n\npublic:\n    int *preIds;\n    int *inIds;\n    int *postIds;\n    int count;\n    int currentPrePos = 0;\n    int currentPostPos = 0;\n\n    PostorderReconstructor(int preorderIds[], int inorderIds[], int cnt) {\n        preIds = preorderIds;\n        inIds = inorderIds;\n        count = cnt;\n        postIds = (int *)malloc(sizeof(int) * cnt);\n    }\n\n    ~PostorderReconstructor() {\n        free(postIds);\n    }\n\n    void reconstruct(int leftPos, int rightPos) {\n        if (leftPos >= rightPos)\n            return;\n\n        auto nextRoot = preIds[currentPrePos];\n        currentPrePos += 1;\n        auto middlePos = findInorderPos(nextRoot);\n\n        reconstruct(leftPos, middlePos);\n        reconstruct(middlePos + 1, rightPos);\n\n        postIds[currentPostPos] = nextRoot;\n        currentPostPos += 1;\n    }\n\nprivate:\n    \n    int findInorderPos(int id) {\n        for (int i = 0; i < count; i++)\n        {\n            if (inIds[i] == id)\n                return i;\n        }\n        throw \"can`t find index in inorder ids\";\n    }\n};\n\n\nint main() {\n    int N, i;\n\n    cin >> N;\n\n    int preorderIds[N], inorderIds[N];\n\n    for (i = 0; i < N; i++)\n    {\n        cin >> preorderIds[i];\n    }\n\n    for (i = 0; i < N; i++)\n    {\n        cin >> inorderIds[i];\n    }\n\n    unique_ptr<PostorderReconstructor> reconstructor(new PostorderReconstructor(preorderIds, inorderIds, N));\n\n    reconstructor->reconstruct(0, N);\n\n    for (i = 0; i < N; i++)\n    {\n        if (i > 0)\n            cout << \" \";\n\n        cout << reconstructor->postIds[i];\n    }\n    \n    cout << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define MAX 40\n#include <vector>\n\nusing namespace std;\n\nint idx=0;\nint n;\nint pre[MAX],in[MAX+1];\nvector<int> ans;\n\nint find(int x){\n  for(int i=0;i<n;i++){\n    if(x==in[i]) return i;\n  }\n  return -1;\n}\n\nvoid reconstruction(int l,int r){\n  if(l>=r) return;\n  int c=pre[idx++];\n  int m=find(c);\n  reconstruction(l,m);\n  reconstruction(m+1,r);\n  ans.push_back(c);\n}\n\nint main(){\n  cin >> n;\n  for(int i=0;i<n;i++) cin >> pre[i];\n  for(int i=0;i<n;i++) cin >> in[i];\n  in[n]=0;\n  reconstruction(0,n);\n  for(int i=0;i<n;i++){\n    if(i) cout << \" \";\n    cout << ans[i];\n  }\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n    if ( l >= r ) return;\n     int root = pre[pos++];\n    \n     int m = distance(in.begin(), \n     find(in.begin(), \n     in.end(),\n     root));\n    \n    \n     \n     rec(l, m);\n     rec(m + 1, r);\n     post.push_back(root);\n}\n\nvoid s() {\n     pos = 0;\n     rec(0, pre.size());\n    \n     for ( int i = 0; i < n; i++ ) {\n        if ( i ) cout << \" \";\n         cout << post[i];\n         }\n    \n     cout << endl;\n}\n\n\n\nint main(){\n    int k; \n    cin >> n;\n    for ( int i = 0; i < n; i++ ) {\n        cin >> k;\n        pre.push_back(k);\n    }\n    \n    for ( int i = 0; i < n; i++ ) {\n        cin >> k;\n        in.push_back(k);\n}\n    \n    s();\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\ntypedef long long lli;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<vector<lli> > mat;\ntypedef vector<vector<bool> > matb;\ntypedef vector<string> vst;\ntypedef pair<lli,lli> pll;\ntypedef pair<double,double> pdd;\n\nlli n;\nmat t;\nvll a;\nvll b;\nstring ans;\n\nvoid dfs(lli& i,lli r,lli l){\n    for(lli j = r;j <= l;j++){\n        if(b[j] == a[i]){\n            i++;\n            dfs(i,r,j-1);\n            dfs(i,j+1,l);\n            ans += to_string(b[j]) + \" \";\n        }\n    }\n}\n\nint main(){\n    cin >> n;\n    t = mat(n+1,vll(2));\n    a = vll(n);b = vll(n);\n    for(lli i = 0;i < n;i++) cin >> a[i];\n    for(lli i = 0;i < n;i++) cin >> b[i];\n    for(lli i = 0;i < n;i++){\n        if(b[i] == a[0]){\n            lli x = 0;\n            dfs(x,0,n-1);\n        }\n    }\n    ans.pop_back();\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*! if g++ -g alds_1_7_d.cpp -o alds_1_7_d.out; then ./alds_1_7_d.out < alds_1_7_d.test; fi\n */\n\n#include <sstream>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iterator>\n#include <numeric>\n#include <functional>\n#include <climits>\n\n\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\nvector<int> pre(0);\nvector<int> ipre(0);\nvector<int> mid(0);\nvector<int> imid(0);\n\nclass node{\npublic:\n  int id, left, right;\n  node(): id(-1), left(-1), right(-1){}\n};\n\nvector<node> tree(0);\n\nint doit(int pl, int pr, int ml, int mr){\n  if(pl == pr) return -1;\n  int root_id = pre[pl];\n\n  int ml1 = ml;\n  int mr1 = imid[root_id];\n  int ml2 = mr1 + 1;\n  int mr2 = mr;\n\n  int pl1 = pl + 1;\n  int pr1 = pl1 + mr1 - ml1;\n  int pl2 = pr1;\n  int pr2 = pr;\n\n  node& nd = tree[root_id-1];\n  nd.id = root_id;\n  nd.left = doit(pl1, pr1, ml1, mr1);\n  nd.right = doit(pl2, pr2, ml2, mr2);\n  return root_id;\n}\n\nvector<int> ret(0);\n\nvoid post(int root){\n  node& nd = tree[root-1];\n  if(nd.left > 0) post(nd.left);\n  if(nd.right > 0) post(nd.right);\n  ret.push_back(nd.id);\n}\n\nint main(){\n  int n;\n  cin >> n;\n  pre.resize(n);\n  mid.resize(n);\n  ipre.resize(n);\n  imid.resize(n);\n  tree.resize(n);\n  for (int i = 0; i < n; i++) {\n    cin >> pre[i];\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> mid[i];\n  }\n  for (int i = 0; i < n; i++) {\n    ipre[pre[i]] = i;\n    imid[mid[i]] = i;\n  }\n  int root_id = doit(0, n, 0, n);\n  post(root_id);\n  for (int i = 0; i < n-1; i++) {\n    cout << ret[i] << \" \";\n  }\n  cout << ret.back() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define MAX 50\nint Pre[MAX];\nint In[MAX];\nint Post[MAX];\nint pos = 0;\nint p = 0;\nint n;\nvoid reconstruction(int l, int r)\n{\n\tif(l >= r)\n\t\treturn;\n\tint root = Pre[pos++];\n\tint m;\n\tfor(int i=0; i<n; i++)\n\t{\n\t\tif(In[i] == root)\n\t\t{\n\t\t\tm = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treconstruction(l,m);\n\treconstruction(m+1,r);\n\tPost[p++] = root;\n}\n\nint main()\n{\n\t//int n;\n\tscanf(\"%d\", &n);\n\tfor(int i=0; i<n; i++)\n\t\tscanf(\"%d\", &Pre[i]);\n\tfor(int i=0; i<n; i++)\n\t\tscanf(\"%d\", &In[i]);\n\n\treconstruction(0,n);\n\n\tfor(int i=0; i<p; i++)\n\t{\n\t\tif(i) printf(\" \");\n\t\tprintf(\"%d\",Post[i]);\n\t}\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define N 40\nvoid Postorder(int *,int *,int);\nint n,post[N],count=0;\n\nvoid Postorder(int *pre,int *in,int n)\n{\n  int k,p;\n\n  for(k=0;k<n;k++){\n    if(pre[0]==in[k]){\n      p=k;\n      break;\n    }\n  }\n\n  if(p!=0) Postorder(pre+1,in,p);\n\n  if(p!=n-1) Postorder(pre+p+1,in+p+1,n-p-1);\n\n  post[count]=pre[0];\n  count++;\n}\n    \n\nint main()\n{\n  int i,pre[N],in[N];\n\n  scanf(\"%d\",&n);\n\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&pre[i]);\n  }\n\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&in[i]);\n  }\n\n  Postorder(pre,in,n);\n\n  for(i=0;i<n;i++){\n    if(i==n-1) printf(\"%d\\n\",post[i]);\n    else printf(\"%d \",post[i]);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n  if( l >= r ) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(l, m);\n  rec(m+1, r);\n  post.push_back(root);\n}\n\nvoid solve(){\n  int i;\n  pos = 0;\n  rec(0, pre.size());\n  for( i = 0 ; i < n ; i++ ){\n    if(i) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main(){\n  int i, k;\n\n  cin >> n;\n\n  for( i = 0 ; i < n ; i++ ){\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for( i = 0 ; i < n ; i++ ){\n    cin >> k;\n    in.push_back(k);\n  }\n\n  solve();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include<vector>\nusing namespace std;\n\nint n;\nint pos;\nvector<int>pre,in,post;\n\nvoid rec(int l, int r){\n  if(l >= r) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(),find(in.begin(),in.end(),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\n\n\n\n\n\nvoid solve(){\n  pos=0;\n  rec(0,pre.size());\n  for(int i=0; i<n; i++){\n    if(i) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n\n\n\n\nint main(){\n  int k;\n  cin >> n;\n\n  for(int i=0; i<n; i++){\n    cin >> k;\n    pre.push_back(k);\n  }\n  for(int i=0; i<n; i++){\n    cin >> k;\n    in.push_back(k);\n  }\n  \n  solve();\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint N,P[45],I[45],i,j,G[45][3],p,f[45]={0},c=0,nd;\n\nvoid dfs(int p)\n{\n\tif(G[p][0]!=-1)\n\t\tdfs(G[p][0]);\n\tif(G[p][1]!=-1)\n\t\tdfs(G[p][1]);\n\tprintf(\"%s%d\",c++==0?\"\":\" \",p);\n\n}\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tmemset(G,-1,sizeof(G));\n\tfor(i=0;i<N;i++)scanf(\"%d\",&P[i]);\n\tfor(i=0;i<N;i++)scanf(\"%d\",&I[i]);\n\tp=P[0];\n\tfor(int np=0,ip=0;np<N;)\n\t{\n\t\tfor(;;)\n\t\t{\n\t\t\tf[P[np]]=1;\n\t\t\tif(P[np]==I[ip])break;\n\t\t\tif(np<N-1)\n\t\t\t{\n\t\t\t\tG[P[np]][0]=P[np+1];\n\t\t\t\tf[P[np+1]]=1;\n\t\t\t}\n\t\t\tnp++;\n\t\t}\n\t\twhile(f[I[ip]])\n\t\t{\n\t\t\tip++;\n\t\t}\n\t\tif(np<N-1)\n\t\t\tG[I[ip-1]][1]=P[np+1];\n\t\tnp++;\n\t}\n\tdfs(P[0]);\n\tputs(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\nvector <int> pre, in;\n\nvoid rec(int lp, int rp, int li, int ri) {\n    int root = pre[lp];\n    int i = 0;\n    while(in[li+i] != root) i++;\n    if (i != 0) rec(lp+1, lp+i, li, li+i-1);\n    if (li + i != ri) rec(lp+i+1, rp, li+i+1, ri);\n\n    printf(\"　%d\", root);\n}\n\nvoid solve(void){\n    int N;\n    cin >> N;\n    pre.resize(N), in.resize(N);\n    rep(N, i) cin >> pre[i];\n    rep(N, i) cin >> in[i];\n    rec(0, N-1, 0, N-1);\n    printf(\"\\n\");\n}\n\nint main(void){\n  solve();\n  //cout << \"yui(*-v・)yui\" << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdint.h>\n#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <climits>\n#include <vector>\nusing namespace std;\n\n#define DEBUG (0)\n\n#if DEBUG\n#define DPRINTF(...) do { \\\n    printf(\"D(L%d) %s: \", __LINE__, __func__); \\\n    printf(__VA_ARGS__); \\\n  } while (false)\n#else\n#define DPRINTF(...)\n#endif // DEBUG\n\n/* binary tree */\nstruct Node {\n  Node() :\n    left_(-1),\n    right_(-1) { }\n\n  int left_;\n  int right_;\n};\n\n\nint findIdxOf(int val, int start, int end, const int array[])\n{\n  for (int i = start; i <= end; i++)\n  {\n    if (array[i] == val)\n      return i;\n  }\n\n  // The val must be found between start to end index\n  assert(false);\n}\n\nint reconstructTree(Node *node, int start, int end, const int preorder[], const int inorder[])\n{\n  DPRINTF(\"start %d  end %d\\n\", start, end);\n\n#if DEBUG\n  if (true) {\n    for (int i = start; i <= end; i++)\n    {\n      if (i == start) DPRINTF(\"preorder: %d\", preorder[i]);\n      else            printf(\" %d\", preorder[i]);\n    }\n    cout << endl;\n\n    for (int i = start; i <= end; i++)\n    {\n      if (i == start) DPRINTF(\"inorder:  %d\", inorder[i]);\n      else            printf(\" %d\", inorder[i]);\n    }\n    cout << endl;\n  }\n#endif\n\n  if (start == end)\n    return preorder[start];\n\n  if (start > end)\n    return -1;\n\n  // Determine which one is the root node\n  int root = preorder[start];\n  int center = findIdxOf(root, start, end, inorder);\n\n  DPRINTF(\"root %d  center  %d\\n\", root, center);\n\n  // Similarly, determine the root nodes of both the left and right trees\n  // Note that pre-order array has to be alligned before dive into recursively\n  //int newPreorder[center - start - 1];\n  int newPreorder[center];\n  for (int i = start; i < center; i++)\n  {\n    newPreorder[i] = preorder[i+1];\n    DPRINTF(\"newPreorder[%d] %d\\n\", i, newPreorder[i]);\n  }\n\n  node[root].left_ = reconstructTree(node, start, center - 1, newPreorder, inorder);\n  node[root].right_ = reconstructTree(node, center + 1, end, preorder, inorder);\n\n  DPRINTF(\"node %d / left %d / right %d\\n\", root, node[root].left_, node[root].right_);\n\n  return root;\n}\n\nvoid traversePostorder(const Node *node, int idx, bool &first)\n{\n  DPRINTF(\"idx %d\\n\", idx);\n\n  if (&node[idx] == nullptr)\n    return ;\n\n  if (node[idx].left_ > -1)\n    traversePostorder(node, node[idx].left_, first);\n\n  if (node[idx].right_ > -1)\n    traversePostorder(node, node[idx].right_, first);\n\n  if (first)\n  {\n    printf(\"%d\", idx);\n    first = false;\n  }\n  else\n    printf(\" %d\", idx);\n}\n\n\nint main()\n{\n  int numOfNode;\n  cin >> numOfNode; cin.ignore();\n\n  int arrayOfPreorder[numOfNode];\n  int arrayOfInorder[numOfNode];\n\n  for (int i = 0; i < numOfNode; i++)\n    cin >> arrayOfPreorder[i];\n\n  for (int i = 0; i < numOfNode; i++)\n    cin >> arrayOfInorder[i];\n\n#if DEBUG\n  for (int i = 0; i < numOfNode; i++)\n  {\n    if (i == 0) DPRINTF(\"%d\", arrayOfPreorder[i]);\n    else        printf(\" %d\", arrayOfPreorder[i]);\n  }\n  cout << endl;\n\n  for (int i = 0; i < numOfNode; i++)\n  {\n    if (i == 0) DPRINTF(\"%d\", arrayOfInorder[i]);\n    else        printf(\" %d\", arrayOfInorder[i]);\n  }\n  cout << endl;\n#endif\n\n  Node *nodes = new Node[numOfNode + 1];\n\n  int start = 0;\n  int end = numOfNode - 1;\n  int rootIdx = reconstructTree(nodes, start, end, arrayOfPreorder, arrayOfInorder);\n\n  bool first = true;\n  traversePostorder(nodes, rootIdx, first);\n  cout << endl;\n\n  delete[] nodes;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n\tif(l >= r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m+1, r);\n\tpost.push_back(root);\n}\n\nvoid solve() {\n\tpos = 0;\n\trec(0, pre.size());\n\tfor(int i = 0; i < n; i++) {\n\t\tif(i) cout << \" \";\n\t\tcout << post[i]; \n\t}\n\tcout << endl;\n}\n\nint main() {\n\tint k;\n\tcin >> n;\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> pre[i];\n\t}\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\t\n\tsolve();\n    \n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nclass Node\n{\npublic:\n    Node() {\n        this->_id = 0;\n        this->_left = 0;\n        this->_right = 0;\n        this->_parent = 0;\n    }\n\n    Node(int id) {\n        this->_id = id;\n        this->_left = 0;\n        this->_right = 0;\n        this->_parent = 0;\n    }\n\n    ~Node() {\n        ;\n    }\n\n    // Accessor\n    const int& id() const {\n        return this->_id;\n    }\n\n    int& id() {\n        return this->_id;\n    }\n\n    const int& left() const {\n        return this->_left;\n    }\n\n    int& left() {\n        return this->_left;\n    }\n\n    const int& right() const {\n        return this->_right;\n    }\n\n    int& right() {\n        return this->_right;\n    }\n\n    const int& parent() const {\n        return this->_parent;\n    }\n\n    int& parent() {\n        return this->_parent;\n    }\n\nprivate:\n    int _id;\n    int _left;\n    int _right;\n    int _parent;\n};\n\nstd::vector<Node> nodelist;\n\nvoid postorder(int id)\n{\n    int l = nodelist[id].left();\n    int r = nodelist[id].right();\n    if (l != 0)\n        postorder(l);\n    if (r != 0)\n        postorder(r);\n    cout << id << \" \";\n\n    return;\n}\n\nvoid maketree(std::vector<int>& pre, std::vector<int>& in)\n{\n    // cout << endl;\n\n    int root = pre[0];\n\n    std::vector<int> leftin;\n    std::vector<int> rightin;\n\n    // find root index in inorder\n    auto rootitr = std::find(in.begin(), in.end(), root);\n\n    // copy left and right subtrees\n    std::copy(in.begin(), rootitr, std::back_inserter(leftin));\n    std::copy(rootitr + 1, in.end(), std::back_inserter(rightin));\n\n    // Debug print\n    // cout << \"pre-order : \";\n    // for (int i = 0; i < pre.size(); i++) {\n    //     cout << pre[i] << \" \";\n    // }\n    // cout << endl;\n    // cout << \"in-order : \";\n    // for (int i = 0; i < in.size(); i++) {\n    //     cout << in[i] << \" \";\n    // }\n    // cout << endl;\n    // cout << \"root = \" << root << endl;\n    // cout << \"left subtree : \";\n    // for (int i = 0; i < leftin.size(); i++) {\n    //     cout << leftin[i] << \" \";\n    // }\n    // cout << endl;\n    // cout << \"right subtree : \";\n    // for (int i = 0; i < rightin.size(); i++) {\n    //     cout << rightin[i] << \" \";\n    // }\n    // cout << endl;\n\n    // construct pre-order from two subtrees\n    // pre-order of left subtree\n    std::vector<int> leftpre;\n    if (leftin.size() > 0) {\n        int limin = *std::min_element(leftin.begin(), leftin.end());\n        int limax = *std::max_element(leftin.begin(), leftin.end());\n        std::copy(std::find(pre.begin(), pre.end(), limin),\n                  std::find(pre.begin(), pre.end(), limax) + 1,\n                  std::back_inserter(leftpre));\n    }\n\n    // pre-order of right subtree\n    std::vector<int> rightpre;\n    if (rightin.size() > 0) {\n        int rimin = *std::min_element(rightin.begin(), rightin.end());\n        int rimax = *std::max_element(rightin.begin(), rightin.end());\n        std::copy(std::find(pre.begin(), pre.end(), rimin),\n                  std::find(pre.begin(), pre.end(), rimax) + 1,\n                  std::back_inserter(rightpre));\n    }\n\n    // Debug print\n    // cout << \"pre-order of left subtree : \";\n    // for (int i = 0; i < leftpre.size(); i++) {\n    //     cout << leftpre[i] << \" \";\n    // }\n    // cout << endl;\n    // cout << \"pre-order of right subtree : \";\n    // for (int i = 0; i < rightpre.size(); i++) {\n    //     cout << rightpre[i] << \" \";\n    // }\n    // cout << endl;\n\n    // set children\n    if (leftpre.size() > 0) {\n        // cout << \"Left child of \" << root << \" = \" << leftpre[0] << endl;\n        nodelist[root].left() = leftpre[0];\n    }\n    if (rightpre.size() > 0) {\n        // cout << \"Right child of \" << root << \" = \" << rightpre[0] << endl;\n        nodelist[root].right() = rightpre[0];\n    }\n\n    if (leftpre.size() > 1)\n        maketree(leftpre, leftin);\n    if (rightpre.size() > 1)\n        maketree(rightpre, rightin);\n\n    // cout << endl;\n}\n\nint main(int argc, char const *argv[])\n{\n    int n;\n    cin >> n;\n\n    // initialize nodelist\n    nodelist.resize(n + 1);\n\n    std::vector<int> pre(n);\n    std::vector<int> in(n);\n    // input\n    for (int i = 0; i < n; i++) {\n        cin >> pre[i];\n        // set node id\n        nodelist[i + 1].id() = i + 1;\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> in[i];\n    }\n\n    // construct tree\n    maketree(pre, in);\n\n    // Debug print\n    // cout << endl;\n    // for (int i = 1; i <= n; i++) {\n    //     cout << \"id: \" << nodelist[i].id() << \", left: \" << nodelist[i].left() << \", right: \" << nodelist[i].right() << endl;\n    // }\n\n    // print post-order (argument is id of root)\n    postorder(pre[0]);\n    cout << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAX = 100;\n\nint pre[MAX], in[MAX];\nint n, pre_idx;\n\nvoid reconstruction(int l, int r) {\n\tif (l >= r) return;\n\tint node = pre[pre_idx];\n\tpre_idx++;\n\tint m = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (node != in[i]) continue;\n\t\tm = i;\n\t\tbreak;\n\t}\n\treconstruction(l, m);\n\treconstruction(m+1, r);\n\tcout << node;\n\tif (node != pre[0]) cout << ' ';\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> pre[i];\n\tfor (int i = 0; i < n; i++) cin >> in[i];\n\tpre_idx = 0;\n\treconstruction(0, n);\n\tcout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint pos;\nvector<int> pre, in ,post;\n\nvoid rec(int l, int r)\n{\n    if( l>=r )\n        return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l,m);\n    rec(m+1,r);\n    post.push_back(root);\n}\n\nvoid solve()\n{\n    pos = 0;\n    rec( 0, pre.size() );\n    for(int i=0; i<pre.size(); ++i){\n        if( i )\n            cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\n\nint main()\n{\n    int n, k;\n    cin >> n;\n    for(int i=0; i<n; ++i){\n        cin >> k;\n        pre.push_back(k);\n    }\n\n    for(int i=0; i<n; i++){\n        cin >>k;\n        in.push_back(k);\n    }\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <limits>\n#include <fstream>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\nvector<int> pre, in;\nint n, idx;\nvector<int> ans;\nvoid f(int l, int r){\n  if(r-l<=0) return;\n  int root = pre[idx++];\n  int d = find(in.begin(), in.end(), root) - in.begin();\n  f(l, d);\n  f(d + 1, r);\n  ans.push_back(root);\n}\nint main()\n{\n  cin >> n;\n  FOR(i,0,n){\n    int p;\n    cin >> p;\n    pre.push_back(p);\n  }\n  FOR(i,0,n){\n    int p;\n    cin >> p;\n    in.push_back(p);\n  }\n  f(0, n);\n  FOR(i,0,n)printf(\"%d%c\",ans[i],i==n-1?'\\n':' ');\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nvoid postorder(int pre[], int in[], int post[], int n)\n{\n    if(n<=0) return;\n    post[n-1]=pre[0];\n    int i;\n    for(i=0; in[i]!=pre[0]; i++);\n    postorder(pre+1, in, post, i);\n    postorder(pre+i+1, in+i+1, post+i, n-i-1);\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int pre[40], in[40];\n    int post[40]={};\n    int n;\n    cin>>n;\n    for(int i=0; i<n; i++) cin>>pre[i];\n    for(int i=0; i<n; i++) cin>>in[i];\n    postorder(pre, in, post, n);\n    cout<<post[0];\n    for(int i=1; i<n; i++) cout<<' '<<post[i];\n    cout<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct node\n{\n\tint ls,rs;\n\tnode()\n\t{\n\t\tls=rs=-1;\n\t}\n}T[41];\n\nint n,Pre[40],In[40];\n\nvector<int> Post;\n\nint make(int Ins,int Int,int Pres)\n{\n\t//\n\tif(Ins>Int) return -1;\n\tint r;\n\tfor(r=Ins;In[r]!=Pre[Pres];r++);\n\tT[Pre[Pres]].ls=make(Ins,r-1,Pres+1);\n\tT[Pre[Pres]].rs=make(r+1,Int,Pres+1+r-Ins);\n\t//printf(\"%d %d %d %d\\n\",Ins,Int,Pres,r);\n\treturn Pre[Pres];\n}\n\nvoid Postorder(int t)\n{\n\tif(t==-1) return;\n\tPostorder(T[t].ls);\n\tPostorder(T[t].rs);\n\tPost.push_back(t);\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)\n\t\tscanf(\"%d\",&Pre[i]);\n\tfor(int i=0;i<n;i++)\n\t\tscanf(\"%d\",&In[i]);\n\tint r=make(0,n-1,0);\n\tPostorder(r);\n\tfor(int i=0;i<Post.size();i++)\n\t\tprintf(\"%d%c\",Post[i],i+1==n?'\\n':' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace  std;\n\nvoid fnInput(vector<int>& rvnPodr, vector<int>& rvnIodrSeq)\n{\n  int nMaxSiz;\n\n  cin >> nMaxSiz;\n  rvnPodr.resize(nMaxSiz + 1);\n  rvnIodrSeq.resize(nMaxSiz + 1);\n\n  for (int i = 1; i < nMaxSiz + 1; i++)\n    cin >> rvnPodr[i];\n\n  int nNode;\n  for (int i = 1; i < nMaxSiz + 1; i++)\n  {\n    cin >> nNode;\n    rvnIodrSeq[nNode] = i;\n  }\n}\n\nvoid fnPostOrder(const vector<int>& cnrvnPodr, const vector<int>& cnrvnIodrSeq, int nLeft, int nRight)\n{\n  static int stnx = 1;\n  static int stnPrt = 0;\n\n  if (nLeft == nRight) return;\n\n  int nNode = cnrvnPodr[stnx++];\n  int nMid = cnrvnIodrSeq[nNode];\n\n  fnPostOrder(cnrvnPodr, cnrvnIodrSeq, nLeft, nMid);\n  fnPostOrder(cnrvnPodr, cnrvnIodrSeq, nMid + 1, nRight);\n\n  if (stnPrt++) cout << \" \";\n  cout << nNode;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vector<int> vnPodr, vnIodrSeq;\n  fnInput(vnPodr, vnIodrSeq);\n\n  fnPostOrder(vnPodr, vnIodrSeq, 1, vnPodr.size());\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint N;\nvector<int> preorder;\nmap<int, int> inorderPos;\n\nstruct Node {\n  int id;\n  Node *left;\n  Node *right;\n\n  Node(int id) : id(id), left(NULL), right(NULL) {};\n\n  ~Node() {\n    delete left;\n    delete right;\n  }\n};\n\nNode *construct(int &idx, Node *lastLeftParent) {\n  int id = preorder[idx];\n  Node *node = new Node(id);\n\n  ++idx;\n  if (idx < N && inorderPos[preorder[idx]] < inorderPos[id]) {\n    node->left = construct(idx, node);\n  }\n\n  if (idx < N && (!lastLeftParent || inorderPos[preorder[idx]] < inorderPos[lastLeftParent->id])) {\n    node->right = construct(idx, lastLeftParent);\n  }\n\n  return node;\n}\n\nvoid generatePostorder(Node *node, vector<int> &vec) {\n  if (node->left) {\n    generatePostorder(node->left, vec);\n  }\n  if (node->right) {\n    generatePostorder(node->right, vec);\n  }\n  vec.push_back(node->id);\n}\n\nint main() {\n  cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n\n  cin >> N;\n\n  for (auto i = 0; i < N; ++i) {\n    int t;\n    cin >> t;\n    preorder.push_back(t);\n  }\n  for (auto i = 0; i < N; ++i) {\n    int t;\n    cin >> t;\n    inorderPos[t] = i;\n  }\n\n  int idx = 0;\n  Node *root = construct(idx, NULL);\n\n  vector<int> postorder;\n  generatePostorder(root, postorder);\n\n  for (auto i = 0; i < N; ++i) {\n    if (i) {\n      cout << \" \";\n    }\n    cout << postorder[i];\n  }\n  cout << endl;\n\n  delete root;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define MAX 10000\n#define NIL -1\n\nstruct Node{int parent, left, right;};\nNode node[MAX];\nint n, pre[100], in[100], nowroot = -1;\nvector<int> post;\n\nint getRootPos(int nowroot){\n  for(int i = 0; i < n; i++){\n    if(pre[nowroot] == in[i]) return i;\n  }\n}\n\nint makeTree(int l, int r){\n  if(r == l) return in[l];\n  if(r < l) return NIL;\n  \n  int rootpos = getRootPos(++nowroot);\n  node[in[rootpos]].left = makeTree(l, rootpos - 1);\n  node[in[rootpos]].right = makeTree(rootpos + 1, r);\n  node[node[in[rootpos]].left].parent = in[rootpos];\n  node[node[in[rootpos]].right].parent = in[rootpos];\n  return in[rootpos];\n}\n\n/*\nvoid printNodeInf(int n){\n  cout << \"node : \" << n << \", \";\n  cout << \"left : \" << node[n].left << \", \";\n  cout << \"right : \" << node[n].right << \", \";\n  cout << \"parent : \" << node[n].parent << endl;\n}\n*/\n\nvoid postParse(int u){\n  if(u == NIL) return;\n  postParse(node[u].left);\n  postParse(node[u].right);\n  post.push_back(u);\n}\n\nint main(void){\n  cin >> n;\n  for(int i = 1; i <= n; i++) node[i].parent = node[i].left = node[i].right = NIL;\n  for(int i = 0; i < n; i++) cin >> pre[i];\n  for(int i = 0; i < n; i++) cin >> in[i];\n  makeTree(0, n - 1);\n  //for(int i = 1; i <= n; i++) printNodeInf(i);\n  postParse(pre[0]);\n  for(int i = 0; i < post.size(); i++){\n    cout << post[i];\n    if(i < post.size() - 1) cout << \" \";\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\nusing namespace std;\nvector<int> a,b,ans;\nint pos = 0;\nvoid dfs(int l,int r)\n{\n\tif(l >= r) return ;\n\tint root = a[pos++];\n\tint dis = distance(b.begin(),find(b.begin(),b.end(),root));\n\tdfs(l,dis); dfs(dis+1,r);\n\tans.push_back(root); \n}\nint main(void)\n{\n\tint n,k;\n\tscanf(\"%d\",&n);\n\tfor(int i = 0;i < n;i++) scanf(\"%d\",&k),a.push_back(k);\n\tfor(int i = 0;i < n;i++) scanf(\"%d\",&k),b.push_back(k);\n\tdfs(0,n);\n\tfor(int i = 0;i < n;i++) printf(\"%d%c\",ans[i],(i == n-1)?'\\n':' ');\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int MAX = 105;\nconst int NIL = -1;\n\nint pre[MAX];\nint in[MAX];\nint post[MAX];\nint pre_i = 0;\nint post_i = 0;\n\n\nint n;\n\nvoid build_tree(int, int);\n\nint main()\n{\n\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> pre[i];\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> in[i];\n\n\tbuild_tree(0, n);\n\tfor (int i = 0; i < n - 1; i++)\n\t\tcout << post[i] << \" \";\n\tcout << post[n - 1] << endl;\n\n// \tcin.get();\n// \tcin.get();\n\treturn 0;\n}\n\nvoid build_tree(int l, int r)\n{\n\tif (l >= r)\n\t\treturn;\n\n\tint root = pre[pre_i++];\n\tint mark = 0;\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tif (in[i] == root)\n\t\t{\n\t\t\tmark = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//post-order\n\tbuild_tree(l, mark);\n\tbuild_tree(mark + 1, r);\n\tpost[post_i++] = root;\n\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\n#define MAX 100005\n#define INF INT_MAX\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n// 行きがけ順は(親)(左部分木)(右部分木)の並び\n// 通り掛け順は(左部分木)(親)(右部分木)の並び\n// それぞれ分割して再帰に突っ込む\n// 帰りがけ順は(左部分木)(右部分木)(親)の順で返せばOK\nvector<int> toPostOrder(vector<int> preorder, vector<int> inorder)\n{\n    if (preorder.size() == 0) {\n        return vector<int>(0);\n    }\n\n    int parent = preorder[0];\n    auto itr = find(inorder.begin(), inorder.end(), parent);\n    int l_cnt = distance(inorder.begin(), itr);\n    int r_cnt = inorder.size() - l_cnt - 1;\n\n    vector<int> pre_left, pre_right;\n    vector<int> in_left, in_right;\n    rep(i,l_cnt) {\n        pre_left.push_back(preorder[i+1]);\n        in_left.push_back(inorder[i]);\n    }\n    rep(i,r_cnt) {\n        pre_right.push_back(preorder[l_cnt+1+i]);\n        in_right.push_back(inorder[l_cnt+1+i]);\n    }\n    vector<int> post_left = toPostOrder(pre_left, in_left);\n    vector<int> post_right = toPostOrder(pre_right, in_right);\n\n    vector<int> postorder;\n    postorder.insert(postorder.end(), post_left.begin(), post_left.end());\n    postorder.insert(postorder.end(), post_right.begin(), post_right.end());\n    postorder.push_back(parent);\n\n    return postorder;\n}\n\nint main(int, char**)\n{\n    int n;\n    cin >> n;\n\n    vector<int> preorder(n);\n    vector<int> inorder(n);\n\n    rep(i,n) cin >> preorder[i];\n    rep(i,n) cin >> inorder[i];\n\n    vector<int> postorder = toPostOrder(preorder, inorder);\n\n    rep(i,n) { if(i) cout << \" \"; cout << postorder[i]; }\n    cout << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <list>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <ostream>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n\n#define N 45\n#define INF (1 << 30)\n#define NIL -1\nconst int mod = 1e9 + 7;\nusing namespace std;\nint pre[N];\nint in[N];\nint post[N];\nvoid rebuild(int preL, int inL, int postL, int n)\n{\n\tif (n == 0)\n\t\treturn;\n\tif (n == 1)\n\t{\n\t\tpost[postL] = pre[preL];\n\t\treturn;\n\t}\n\tpost[postL + n - 1] = pre[preL];\n\tint i;\n\tfor (i = 0; i < n; ++i)\n\t{\n\t\tif (in[i + inL] == pre[preL])\n\t\t\tbreak;\n\t}\n\trebuild(preL + 1, inL, postL, i);\n\trebuild(preL + i + 1, inL + i + 1, postL + i, n - i - 1);\n}\nint main()\n{\n\tint T, n, k;\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> pre[i];\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> in[i];\n\trebuild(0, 0, 0, n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << post[i] << ' ';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct Node {\n  int parent, left, right;\n};\nint pos = 0;\nvector<int> pre, in, post;\n\nvoid reconst(int l, int r) {\n  if (l >= r) return;\n  int c = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), c));\n  reconst(l, m);\n  reconst(m+1, r);\n  post.push_back(c);\n}\n\nint main() {\n  int n;\n  cin >> n;\n  int val;\n  for (int i = 0; i < n; i++) {\n    cin >> val;\n    pre.push_back(val);\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> val;\n    in.push_back(val);\n  }\n  reconst(0, n);\n  for (int i = 0; i < n; i++) {\n    if(i) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> c;\nvector<int> pre, in;\n\nvoid post(int id) {\n\tif (id == -1)\n\t\treturn;\n\tpost(c[id][0]);\n\tpost(c[id][1]);\n\tcout << id + 1;\n\tif (id == pre[0] - 1)\n\t\tcout << endl;\n\telse\n\t\tcout << \" \";\n}\n\nint main()\n{\n\tint n = 0, t = 0;\n\n\tcin >> n;\n\n\tc.assign(n, {-1, -1});\t\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> t;\n\t\tpre.push_back(t);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> t;\n\t\tin.push_back(t);\n\t}\n\n\tvector<int>::iterator it1, it2;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tit1 = find(in.begin(), in.end(), pre[i]);\n\t\tit2 = find(in.begin(), in.end(), pre[i + 1]);\n\n\t\tif (it1 > it2)\n\t\t\tc[pre[i] - 1][0] = pre[i + 1] - 1;\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tit1 = find(pre.begin(), pre.end(), in[i]);\n\t\tit2 = find(pre.begin(), pre.end(), in[i + 1]);\n\n\t\tif (it1 < it2)\n\t\t\tc[in[i] - 1][1] = in[i + 1] - 1;\n\t}\n\n\tpost(pre[0] - 1);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint pre[40],in[40],n,count;\nvector<int> out;\n\nvoid rep(int left,int right){\n\tif(left>=right)\treturn;\n\tint root=pre[count++];\n\tint next;\n\tfor(int i=0;i<n;i++){\n\t\tif(in[i]==root){\n\t\t\tnext=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\trep(left,next);\trep(next+1,right);\n\tout.push_back(root);\n}\n\nvoid solve(){\n\tcount=0;\n\trep(0,n);\n\tfor(int i=0;i<(int)out.size();i++){\n\t\tif(i)\tcout<<\" \";\n\t\tcout<<out[i];\n\t}\n\tcout<<endl;\n}\n\n\nint main(){\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\tcin>>pre[i];\n\tfor(int i=0;i<n;i++)\tcin>>in[i];\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define NUL -1\nconst int N_MAX = 45;\nint root;\nstruct Node{\n    int parent, left, right;\n};\nNode tree[N_MAX];\nint pre[N_MAX], in[N_MAX];\n\nvoid reConstruct(int parent, int * preP, int * inP, int n, bool isLeft){\n    if(n==0) return;\n    int nowRoot = preP[0];\n    tree[nowRoot].parent = parent;\n    //getchar();\n    //cout<<\"-- nowRoot: \"<<nowRoot<<endl;\n    if(parent==NUL){\n        root=nowRoot;\n    }else if(isLeft){\n        tree[parent].left=nowRoot;\n    }else{\n        tree[parent].right=nowRoot;\n    }\n    if(n==1)return;\n    int flag = 0;\n    for(;flag<n;flag++){\n        if(inP[flag]==nowRoot) break;\n    }\n    //cout<<\"nowRoot: \"<<nowRoot<<\" flag: \"<<flag<<endl;\n    reConstruct(nowRoot, preP+1, inP, flag, true);\n    reConstruct(nowRoot, preP+1+flag, inP+1+flag, n-flag-1, false);\n}\n\nvoid post(int id){\n    if(id==NUL) return;\n    if(tree[id].left==NUL&&tree[id].right==NUL&&id!=root){\n        printf(\"%d \", id);\n        //cout<<id<<\" \";\n        return;\n    }\n    post(tree[id].left);\n    post(tree[id].right);\n    if(id==root){\n        printf(\"%d\", id);\n        //cout<<id<<endl;\n    }else{\n        printf(\"%d \", id);\n        //cout<<id<<\" \";\n    }\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    //cin>>n;\n    for(int i=0;i<n;i++){\n        scanf(\"%d\", &pre[i]);\n        //cin>>pre[i];\n        tree[i].parent=tree[i].left=tree[i].right=NUL;\n    }\n    tree[n].parent=tree[n].left=tree[n].right=NUL;\n    for(int i=0;i<n;i++){\n        scanf(\"%d\", &in[i]);\n        //cin>>in[i];\n    }\n    reConstruct(NUL, pre, in, n, true);\n    /*//Debugging/\n    for(int i=1;i<=n;i++){\n        cout<<\"node\"<<i<<\": p: \"<<tree[i].parent<<\"  l: \"<<tree[i].left<<\"  r: \"<<tree[i].right<<endl;\n    }\n    ///Debugging*/\n    post(root);\n    //cout<<\"root: \"<<root<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace  std;\n\nconst int END = -1;\nstruct StNod\n{\n  int m_nParnt;\n  int m_nLeft;\n  int m_nRigt;\n\n  StNod() :\n     m_nParnt(END), m_nLeft(END), m_nRigt(END)\n  { }\n};\n\nenum EnDir\n{\n  D_Left,\n  D_Right,\n};\n\nvoid fnInput(vector<int> &rvnPodr, vector<int> &rvnIodrSeq)\n{\n  int nMaxSiz;\n\n  cin >> nMaxSiz;\n  rvnPodr.resize(nMaxSiz);\n  rvnIodrSeq.resize(nMaxSiz + 1);\n\n  for (int i = 0; i < nMaxSiz; i++)\n  {\n    int nNode;\n    cin >> nNode;\n    rvnPodr[i] = nNode;\n  }\n\n  for (int i = 1; i < nMaxSiz + 1; i++)\n  {\n    int nNode;\n    cin >> nNode;\n    rvnIodrSeq[nNode] = i;\n  }\n}\n\nvoid fnStructTree(const vector<int> &cnrvnPodr, const vector<int> &cnrvnIodrSeq, vector<StNod> &rvoNod)\n{\n  int nRoot = cnrvnPodr[0];\n\n  for (int i = 1; i < cnrvnPodr.size(); i++)\n  {\n    int nParnt = END;\n    int nx = nRoot;\n    EnDir enDir;\n    while (nx != END)\n    {\n      nParnt = nx;\n      if (cnrvnIodrSeq[ cnrvnPodr[i] ] < cnrvnIodrSeq[nx])\n      {\n        nx = rvoNod[nx].m_nLeft;\n        enDir = D_Left;\n      }\n      else\n      {\n        nx = rvoNod[nx].m_nRigt;\n        enDir = D_Right;\n      }\n    }\n\n    rvoNod[ cnrvnPodr[i] ].m_nParnt = nParnt;\n    if (enDir == D_Left)\n      rvoNod[nParnt].m_nLeft = cnrvnPodr[i];\n    else\n      rvoNod[nParnt].m_nRigt = cnrvnPodr[i];\n  }\n}\n\nvoid fnPostOrder(const vector<StNod> &cnrvoNod, int nx, int &nOCnt)\n{\n  if (nx == END)  return;\n\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nLeft, nOCnt);\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nRigt, nOCnt);\n  if (nOCnt++) cout << \" \";\n  cout << nx;\n}\n\nvoid fnResult(const vector<StNod> &cnrvoNod, int &nOCnt)\n{\n  int nx = 1;\n  while (cnrvoNod[nx].m_nParnt != END)\n    nx = cnrvoNod[nx].m_nParnt;\n\n  fnPostOrder(cnrvoNod, nx, nOCnt);\n  cout << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vector<int> vnPodr, vnIodrSeq;\n  vector<StNod> voNod;\n\n  fnInput(vnPodr, vnIodrSeq);\n\n  StNod oNod;\n  voNod.resize(vnIodrSeq.size(), oNod);\n  fnStructTree(vnPodr, vnIodrSeq, voNod);\n  \n  int nOCnt = 0;\n  fnResult(voNod, nOCnt);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*Reconstruction of a Tree\nWrite a program which reads two sequences of nodes obtained by the preorder tree walk and the inorder tree walk on a binary tree respectively, and prints a sequence of the nodes obtained by the postorder tree walk on the binary tree.\n\nInput\nIn the first line, an integer n, which is the number of nodes in the binary tree, is given.\nIn the second line, the sequence of node IDs obtained by the preorder tree walk is given separated by space characters.\nIn the second line, the sequence of node IDs obtained by the inorder tree walk is given separated by space characters.\n\nEvery node has a unique ID from 1 to n. Note that the root does not always correspond to 1.\n\nOutput\nPrint the sequence of node IDs obtained by the postorder tree walk in a line. Put a single space character between adjacent IDs.\n\nConstraints\n1≤n≤40*/ \n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r){\n\tif(l>=r)\n\t\treturn;\n\tint root=pre[pos++];\n\tint m=distance(in.begin(),find(in.begin(),in.end(),root));\n\trec(l,m);\n\trec(m+1,r);\n\tpost.push_back(root);\n}\n\nvoid slove(){\n\tpos=0;\n\trec(0,pre.size());\n\tfor(int i=0;i<n;i++){\n\t\tif(i)\n\t\t\tcout<<\" \";\n\t\tcout<<post[i];\n\t} \n\tcout<<endl;\n}\n\nint main(){\n\tint k;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>k;\n\t\tpre.push_back(k);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tcin>>k;\n\t\tin.push_back(k);\n\t}\n\t\n\tslove();\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace  std;\n\nconst int END = -1;\nstruct StNod\n{\n  int m_nParnt;\n  int m_nLeft;\n  int m_nRigt;\n\n  StNod() :\n     m_nParnt(END), m_nLeft(END), m_nRigt(END)\n  { }\n};\n\nenum EnDir\n{\n  D_Left,\n  D_Right,\n};\n\nvoid fnInput(vector<int> &rvnPodr, vector<int> &rvnIodrSeq)\n{\n  int nMaxSiz;\n\n  cin >> nMaxSiz;\n  rvnPodr.resize(nMaxSiz);\n  rvnIodrSeq.resize(nMaxSiz + 1);\n\n  for (int i = 0; i < nMaxSiz; i++)\n    cin >> rvnPodr[i];\n\n  for (int i = 1; i < nMaxSiz + 1; i++)\n  {\n    int nNode;\n    cin >> nNode;\n    rvnIodrSeq[nNode] = i;\n  }\n}\n\nvoid fnStructTree(const vector<int> &cnrvnPodr, const vector<int> &cnrvnIodrSeq, vector<StNod> &rvoNod)\n{\n  for (int i = 1; i < cnrvnPodr.size(); i++)\n  {\n    int nParnt = END;\n    int nx = cnrvnPodr[0];\n    EnDir enDir;\n    while (nx != END)\n    {\n      nParnt = nx;\n      if (cnrvnIodrSeq[ cnrvnPodr[i] ] < cnrvnIodrSeq[nx])\n      {\n        nx = rvoNod[nx].m_nLeft;\n        enDir = D_Left;\n      }\n      else\n      {\n        nx = rvoNod[nx].m_nRigt;\n        enDir = D_Right;\n      }\n    }\n\n    rvoNod[ cnrvnPodr[i] ].m_nParnt = nParnt;\n    if (enDir == D_Left)\n      rvoNod[nParnt].m_nLeft = cnrvnPodr[i];\n    else\n      rvoNod[nParnt].m_nRigt = cnrvnPodr[i];\n  }\n}\n\nvoid fnPostOrder(const vector<StNod> &cnrvoNod, int nx, int &nOCnt)\n{\n  if (nx == END)  return;\n\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nLeft, nOCnt);\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nRigt, nOCnt);\n  if (nOCnt++) cout << \" \";\n  cout << nx;\n}\n\nvoid fnResult(const vector<StNod> &cnrvoNod, int &nOCnt)\n{\n  int nx = 1;\n  while (cnrvoNod[nx].m_nParnt != END)\n    nx = cnrvoNod[nx].m_nParnt;\n\n  fnPostOrder(cnrvoNod, nx, nOCnt);\n  cout << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vector<int> vnPodr, vnIodrSeq;\n  vector<StNod> voNod;\n\n  fnInput(vnPodr, vnIodrSeq);\n\n  StNod oNod;\n  voNod.resize(vnIodrSeq.size(), oNod);\n  fnStructTree(vnPodr, vnIodrSeq, voNod);\n  \n  int nOCnt = 0;\n  fnResult(voNod, nOCnt);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> in, pre;\n\ntypedef struct _node {\n  int id;\n  struct _node *left;\n  struct _node *right;\n} node;\n\nnode *new_node(int id, node *l, node *r)\n{\n  node *v = (node *)malloc(sizeof(node));\n  v->id = id;\n  v->left = l;\n  v->right = r;\n  return v;\n}\n\npair<node *, int> tree(int pre_i, int in_l, int in_r)\n{\n  if (in_l+1 == in_r) {\n    if (in[in_l] != pre[pre_i]) {\n      cerr << \"error\" << endl;\n      return make_pair((node *)NULL, pre_i);\n    }\n    return make_pair(\n             new_node(in[in_l], NULL, NULL),\n             pre_i+1\n           );\n  } else {\n    int root = pre[pre_i];\n    int sep = -1;\n    for (int i = in_l; i < in_r; i++) {\n      if (root == in[i]) {\n        sep = i;\n        break;\n      }\n    }\n    if (sep == -1)\n      return make_pair((node *)NULL, pre_i);\n\n    pair<node *, int> p = tree(pre_i+1, in_l, sep);\n    node *l = p.first;\n    pair<node *, int> q = tree(p.second, sep+1, in_r);\n    node *r = q.first;\n    return make_pair(\n             new_node(root, l, r),\n             q.second\n           );\n  }\n}\n\nvoid postorder(node *v, vector<int> &out)\n{\n  if (v == NULL) return;\n  postorder(v->left, out);\n  postorder(v->right, out);\n  out.push_back(v->id);\n}\nvoid output(node *v)\n{\n  if (v == NULL) {\n    cout << \"*\";\n    return;\n  }\n  cout << \"(\" << v->id << \" \";\n  output(v->left);\n  cout << \" \";\n  output(v->right);\n  cout << \")\";\n}\n\n\nint main()\n{\n  int n; cin >> n;\n  pre = vector<int>(n);\n  for (int i = 0; i < n; i++)\n    cin >> pre[i];\n  in = vector<int>(n);\n  for (int i = 0; i < n; i++)\n    cin >> in[i];\n\n  node *v = tree(0, 0, n).first;\n  // output(v);\n  vector<int> out;\n  postorder(v, out);\n  for (int i = 0; i < out.size(); i++)\n    cout << out[i] << (i==out.size()-1?'\\n':' ');\n\n  return EXIT_SUCCESS;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n#define rrep(ri,n) for(int ri = (int)(n-1); ri >= 0; ri--)\n#define rep2(i,x,n) for(int i = (int)(x); i < (int)(n); i++)\n#define repit(itr,x) for(auto itr = x.begin(); itr != x.end(); itr++)\n#define rrepit(ritr,x) for(auto ritr = x.rbegin(); ritr != x.rend(); ritr++)\n#define ALL(n) begin(n), end(n)\nusing ll = long long;\nusing namespace std;\n\n// struct node{\n//   int data;\n//   node *l, *r;\n// };\n\n// node *new_node(int in){\n//   node *n = new node;\n//   n->data = in;\n//   n->l = NULL;\n//   n->r = NULL;\n//   return n;\n// }\n\n// node *dfs(int k, vector<int> &pr, vector<int> &in, int prl, int prr, int inl, int inr){\n//   cerr << k << endl;\n//   if(inr <= inl) return NULL;\n//   node *ret = new_node(k);\n//   int lprr, linr, rprl, rinl;\n//   bool m = false;\n//   int co = 0;\n//   rep2(i, inl, inr){\n//     if(in.at(i) == k){\n//       linr = i;\n//       rinl = i + 1;\n//       break;\n//     }\n//     co++;\n//   }\n//   lprr = prl + co;\n//   rprl = lprr + 1;\n//   int lk = pr.at(prl), rk = pr.at(rprl);\n//   ret->l = dfs(lk, pr, in, prl+1, lprr, inl, linr);\n//   ret->r = dfs(rk, pr, in, rprl+1, prr, rinl, inr);\n//   return ret;\n// }\n\n// void print_post_order(node *root){\n//   if(root->l != NULL)print_post_order(root->l);\n//   if(root->r != NULL)print_post_order(root->r);\n//   cout << root->data << endl;\n// }\n\nint fd(vector<int> &in, int c){\n  int ret = -1;\n  rep(i, in.size()){\n    if(in.at(i) == c){\n      ret = i;\n      break;\n    }\n  }\n  return ret;\n}\n\nvoid rec(int l, int r, vector<int> &pr, vector<int> &in){\n  static int prindex = 0;\n  static bool sp = false;\n  if(r <= l) return ;\n  int c = pr.at(prindex++);\n  int m = fd(in, c);\n  rec(l, m, pr, in);\n  rec(m+1, r, pr, in);\n  if(sp == true){\n    cout << \" \";\n  }else{\n    sp = true;\n  }\n  cout << c;\n}\n\nint main(){\n  int n;\n  cin >> n;\n  vector<int> pr(n), in(n);\n  rep(i, n){\n    int a;\n    cin >> a;\n    pr.at(i) = a;\n  }\n  rep(i, n){\n    int a;\n    cin >> a;\n    in.at(i) = a;\n  }\n\n  rec(0, n, pr, in);\n  cout << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream> \nusing namespace std;\nint n,m=0,a[40],b[40],c[41]; \nvoid solve(int l,int r){ if(l>r)return; \nint x=a[m++]; \nsolve(l,c[x]-1); solve(c[x]+1,r); \ncout<<x<<(x==a[0]?\"\\n\":\" \"); \n} \nint main(){ cin>>n; \nfor(int i=0;i<n;i++)cin>>a[i]; \nfor(int i=0;i<n;i++)cin>>b[i],c[b[i]]=i; \nsolve(0,n-1);\n \nreturn 0; \n} \n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint pos;\nvector<int> pre, in, post;\n\nvoid Reconst (int left, int right) {\n\tif (left >= right) {\n\t\treturn;\n\t}\n\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\n\tReconst(left, m);\n\tReconst(m + 1, right);\n\n\tpost.push_back(root);\n}\n\nvoid Solve (int n) {\n\tpos = 0;\n\tReconst(0, pre.size());\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif(i) cout << \" \";\n\t\tcout << post[i];\n\t}\n\n\tcout << endl;\n}\n\n\nint main() {\n\tint n, k;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\n\tSolve(n);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cassert>\n#include<cstring>\n#define maxn 50\nusing namespace std;\nint n;\nint order[3][maxn],post[maxn];\nbool vis[maxn];\n\nint find(int num,int c)\n{\n    for(int i=1; i<=n; ++i)\n        if(order[c][i]==num)\n        {\n            vis[i]=true;\n            return i;\n        }\n    return -1;\n}\n\nvoid postorder(int s,int e)\n{\n//\tcout<<\"s=\"<<s<<\" e=\"<<e<<endl;\n    if(s>e) return ;\n\tif(s==e)\n    {\n        post[++post[0]]=order[1][e];\n//        cout<<post[post[0]]<<\" \";\n        return;\n    }\n    int num=order[1][s],pre_num=0,pos_num=0;\n    post[++post[0]]=order[1][s];\n//    cout<<post[post[0]]<<\" \";\n    int p=find(num,2);\n    for(int i=p+1;i<=n;++i)\n      if(vis[i])\n        break;\n      else\n        pos_num++;\n    for(int i=p-1;i>=1;--i)\n      if(vis[i])\n        break;\n      else\n        pre_num++;\n//    cout<<\"'\"<<pre_num<<\"'-'\"<<pos_num<<\"'\"<<endl; \n    postorder(e-pos_num+1,e);\n    postorder(s+1,s+pre_num);\n    return;\n}\n\nint main()\n{\n    memset(vis,0,sizeof(vis));\n    scanf(\"%d\",&n);\n    for(int j=1; j<=2; ++j)\n        for(int i=1; i<=n; ++i)\n            scanf(\"%d\",&order[j][i]);\n    post[0]=0;\n    postorder(1,n);\n    printf(\"%d\",post[post[0]]);\n    for(int i=post[0]-1; i>=1; --i)\n        printf(\" %d\",post[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\nvector<int> pre, in, post;\nint pos;\nint n, k;\n\nvoid reconstruction(int left, int right) {\n    // 遍历到叶结点\n    if (left >= right)\n        return;\n\n    // 当前子树的根\n    int root = pre[pos++];\n    // 找出当前根的值在中序数组里的下标\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n\n    reconstruction(left, m);\n    reconstruction(m + 1, right);\n\n    //存入到后序数组\n    post.push_back(root);\n\n}\nvoid solve() {\n    pos = 0;\n    reconstruction(0, pre.size());\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", post[i], i == n-1?'\\n':' ');\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &k);\n        pre.push_back(k);\n    }\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &k);\n        in.push_back(k);\n    }\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int>Pre,In,Post;\nint pos,n,x;\nvoid Rebuild(int l,int r)\n{\n    if(l>=r)return ;\n    int root=Pre[pos++];\n   // int m=distance(In.begin(),find(In.begin(),In.end(),root));\n    int m=find(In.begin(),In.end(),root)-In.begin();\n    Rebuild(l,m);\n    Rebuild(m+1,r);\n    Post.push_back(root);\n}\nvoid Solve()\n{\n    pos=0;\n    Rebuild(0,n);\n    for(int i=0;i<n;i++)\n    {\n        if(i)cout<<' ';\n        cout<<Post[i];\n    }\n    cout<<endl;\n}\nint main()\n{\n    cin>>n;\n    for(int i=0;i<n;i++)cin>>x,Pre.push_back(x);\n    for(int i=0;i<n;i++)cin>>x,In.push_back(x);\n    Solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define NIL -1\nstruct Node{int parent,left,right;};\nstruct Node T[41];\nint n,P[41],I[41];\nint search(int x[],int target,int size){\n    for(int i=0;i<size;i++){\n        if(x[i]==target) return i;\n    }\n    return 0;\n}\nbool tansaku(int target,int x[],int size){\n    for(int i=0;i<size;i++){\n        if(x[i]==target) return true;\n    }\n    return false;\n}\nvoid Postorder(int x){\n    if(x!=NIL){\n        Postorder(T[x].left);\n        Postorder(T[x].right);\n        if(x==P[0]) cout<<x;\n        else cout<<x<<\" \";\n    }\n}\nvoid saisei(int x[],int s,int p,int size){\n    int l=0,r=0,mid=search(x,s,size);\n    int L[40],R[40];\n    \n    for(int i=0;i<size;i++){\n        if(i<mid){L[l]=x[i];l++;}\n        else if(i>mid){R[r]=x[i];r++;}\n    }\n    if(l!=0){\n        \n            T[P[p]].left=P[p+1];\n            T[P[p+1]].parent=P[p];\n            saisei(L,P[p+1],p+1,l);\n        \n    }\n    if(r!=0){\n       \n            T[P[p]].right=P[p+l+1];\n            T[P[p+l+1]].parent=P[p];\n            saisei(R,P[p+l+1],p+l+1,r);\n        \n    }\n    \n}\nint main(){\n    cin>>n;\n    for(int i=0;i<n;i++) cin>>P[i];\n    for(int i=0;i<n;i++) {\n        cin>>I[i];\n        T[i+1].parent=T[i+1].left=T[i+1].right=NIL;\n    }\n    saisei(I,P[0],0,n);\n    Postorder(P[0]); cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Maxn 110\nusing namespace std;\nint pos = 0;\nvector<int> Pre, In, Post;\nvoid rec(int l, int r){\n\tif(l >= r) return;\n\tint root = Pre[pos++];\n\tint m = distance(In.begin(), find(In.begin(), In.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tPost.push_back(root);\n}\nint main()\n{\t\n\tint n, k;\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++){\n\t\tscanf(\"%d\", &k);\n\t\tPre.push_back(k);\n\t} \n\tfor(int i = 1; i <= n; i++){\n\t\tscanf(\"%d\", &k);\n\t\tIn.push_back(k);\n\t}\n\t\n\trec(0, Pre.size());\n\tfor(int i = 0; i < n; i++){\n\t\tif(i) printf(\" \");\n\t\tprintf(\"%d\", Post[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<int> pre, in, post;\nint pos=0;\n\nvoid reconstruct(int l, int r) {\n\tif (l >= r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\treconstruct(l, m);\n\treconstruct(m + 1, r);\n\tpost.push_back(root);\n\treturn;\n}\n\nvoid solve() {\n\tpos = 0;\n\treconstruct(0, pre.size());\n\tfor (int i = 0; i < pre.size(); i++){\n\t\tif (i) cout << ' ';\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n\treturn;\n}\n\nint main() {\n\tint n = 0;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint tmp;\n\t\tcin >> tmp;\n\t\tpre.push_back(tmp);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tint tmp;\n\t\tcin >> tmp;\n\t\tin.push_back(tmp);\n\t}\n\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n    if (l >= r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);//left subtree\n    rec(m+1, r);//right subtree\n\n    post.push_back(root);\n}\n\nvoid solve(){\n    pos = 0;\n    rec(0, pre.size());\n    for(int i=0; i<n; i++){\n        if (i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main(){\n    int k;\n    cin >> n;\n\n    for (int i=0; i<n; i++){\n        cin >> k;\n        pre.push_back(k);\n    }\n\n    for (int i=0; i<n; i++){\n        cin >> k;\n        in.push_back(k);\n    }\n\n    solve();\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n\tif (l >= r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\nvoid solve() {\n\tpos = 0;\n\trec(0, pre.size());\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i) cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\n\nint main()\n{\n\tint k;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <limits.h>\n#include <bitset>\n\n#include <tuple>\n#include <unordered_map>\n\n#define mp       make_pair\n#define mt       make_tuple\n#define pb       push_back\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint N;\nvector<int> pre;\nmap<int, int> in;\nvector<int> ans;\nint pos;\nvoid rec(int l, int r){\n\tif (l >= r){\n\t\treturn ;\n\t}\n\tint node = pre[pos++];\n\tint index = in[node];\n\trec(l, index);\n\trec(index + 1, r);\n\tans.push_back(node);\n}\n\nint main(){\n\tcin >> N;\n\tpre.resize(N);\n\tpos = 0;\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> pre[i];\n\t}\n\tfor (int i = 0; i < N; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\tin[x] = i;\n\t}\n\trec(0, N);\n\tfor (auto &val : ans){\n\t\tcout << val << \" \";\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 40+7;\nint pre[MAXN];\nint in[MAXN];\nstruct node{\n\tint parent;\n\tint left;\n\tint right;\n};\nnode tree[MAXN];\nvector<int> v;\nvoid post(int root){\n\tif(root == -1) return;\n\tpost(tree[root].left);\n\tpost(tree[root].right);\n\tv.push_back(root);\n}\nint buildTree(int parent, int l1, int r1, int l2, int r2){\n\tif(l1 > r1 || l2 > r2) return -1;\n\tint root = pre[l1];\n\ttree[root].parent = parent;\n\tint p;\n\tfor(int i = l2; i <= r2; i++){\n\t\tif(in[i] == root){\n\t\t\tp = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\ttree[root].left = buildTree(root, l1+1, l1+p-l2, l2, p-1);\n\ttree[root].right = buildTree(root, l1+p-l2+1, r1, p+1, r2);\n\treturn root;\n\t\n}\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &pre[i]);\n\t}\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &in[i]);\n\t}\n\t\n\tint r = buildTree(-1, 0, n-1, 0, n-1);\n\tpost(r);\n\tfor(int i = 0; i < v.size(); i++){\n\t\tif(i!=0) printf(\" \");\n\t\tprintf(\"%d\", v[i]);\n\t}\n\tprintf(\"\\n\");\n\t\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define N 42\nint n;\nint a[N];\nint b[N];\nint c[N];\nint ai = 1;\nint ci = 1;\nint used[N];\nvoid rebuild(int left, int right){\n    if(left == right) {\n//        printf(\"%d \", b[left]);\n        c[ci++] = b[left];\n        used[b[left]] = 1;\n         return ;\n    }\n//    int ax = a[ai++];\n    int ax;\n    if(used[a[ai]] == 0){\n        ax = a[ai++];\n    }\n    else{\n        while(used[a[ai]] != 0){\n            ai++;\n        }\n        ax = a[ai];\n    }\n    int m = 1;\n    for(int i = 1; i <= n; i++){\n        if(b[i] == ax) m = i;\n    }\n    if(m - 1 >= left) rebuild(left, m-1);\n    if(m + 1 <= right) rebuild(m+1, right);\n//    printf(\"%d \", ax);\n    c[ci++] = ax;\n    used[ax] = 1;\n    return ;\n}\nint main(){\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    for(int i = 1; i <= n; i++) scanf(\"%d\", &b[i]);\n    for(int i = 1; i <= n; i++) used[i] = 0;\n    rebuild(1, n);\n    for(int i = 1; i <= n; i++){\n        if(i == n) printf(\"%d\\n\", c[i]);\n        else printf(\"%d \", c[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nstd::vector<int> readVector(int n) {\n  std::vector<int> v;\n  for (int i = 0; i < n; ++i) {\n    int id;\n    std::cin >> id;\n    v.push_back(id);\n  }\n  return v;\n}\n\nstruct Tree {\n  int left = -1;\n  int right = -1;\n};\n\nstruct SubVector {\n  int begin;\n  int end;\n};\n\nclass Trees {\nprivate:\n  int root;\n  std::vector<Tree> trees;\n  std::vector<int> preordered;\n  std::vector<int> inordered;\n  int r_makeTree(SubVector pre, SubVector in);\n  void r_postorderTreeWalk(int n);\npublic:\n  Trees(std::vector<int>& pre, std::vector<int>& in, int n);\n  std::vector<int> postordered;\n  void makeTree();\n  void postorderTreeWalk();\n};\n\nTrees::Trees(std::vector<int>& pre, std::vector<int>& in, int n) {\n  trees = std::vector<Tree>(n);\n  preordered = pre;\n  inordered = in;\n}\n\nint Trees::r_makeTree(SubVector pre, SubVector in) {\n  if (pre.end - pre.begin == 0)\n    return -1;\n  int r = preordered[pre.begin];\n  if (pre.end - pre.begin == 1) {\n    return r;\n  }\n  int partition = 0;\n  for (int i = 0; i < in.end - in.begin; ++i) {\n    if (inordered[in.begin + i] == r) {\n      partition = i;\n      break;\n    }\n  }\n  trees[r-1].left = r_makeTree({pre.begin + 1, pre.begin + 1 + partition},\n                             {in.begin, in.begin + partition});\n  trees[r-1].right = r_makeTree({pre.begin + partition + 1, pre.end},\n                              {in.begin + partition + 1, in.end});\n  return r;\n}\n\nvoid Trees::makeTree() {\n  root = r_makeTree({0, (int)preordered.size()}, {0, (int)inordered.size()});\n}\n\n\nvoid Trees::r_postorderTreeWalk(int n) {\n  if (trees[n-1].left != -1)\n    r_postorderTreeWalk(trees[n-1].left);\n  if (trees[n-1].right != -1) {\n    r_postorderTreeWalk(trees[n-1].right);\n  }\n  postordered.push_back(n);\n}\n\nvoid Trees::postorderTreeWalk() {\n  r_postorderTreeWalk(root);\n}\n\nint main() {\n  int n;\n  std::cin >> n;\n  std::vector<int> preordered = readVector(n);\n  std::vector<int> inordered = readVector(n);\n  Trees t(preordered, inordered, n);\n  t.makeTree();\n  t.postorderTreeWalk();\n  for (int i = 0; i < n; ++i)\n    std::cout << t.postordered[i] << (i == n-1 ? \"\\n\" : \" \");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main()\n{\n\tint i, j, d, n, k,m, l, cnt = 0;\n\tchar a[100][100];\n\tscanf(\"%d%d%d\", &n, &m, &d);\n\t\tfor (i= 0; i < m; i++) {\n\t\t\tscanf(\"%s\", a[i]);\n\t}\n\t\tfor (i = 0; i < n-d; i++) {\n\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\tfor (k = 0; k < d ; k++) {\n\t\t\t\t\tif (a[i + k][j] == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (k == d) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = 0; j < m-d; j++) {\n\t\t\t\tfor (k = 0; k < d ; k++) {\n\t\t\t\t\tif (a[i][j + k] == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tif (k == d) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", cnt);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS 1e-9\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\ntypedef pair<int, pair<int, int> > Edge;\ntypedef vector<Edge> vE;\ntypedef priority_queue<Edge, vector<Edge>, greater<Edge> > pqlE;\n\nint cnt = 0;\n\nvoid dfs(vi preorder, vi inorder) {\n\tif (inorder.size() == 0) {\n\t\treturn;\n\t}\n\tif (inorder.size() == 1) {\n\t\tcnt++;\n\t\tcout << inorder[0];\n\t\tif (cnt == preorder.size()) {\n\t\t\tcout << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ' ';\n\t\t}\n\t\treturn;\n\t}\n\tint pos = 0;\n\tbool flag = false;\n\trep(i, preorder.size()) {\n\t\trep(j, inorder.size()) {\n\t\t\tif (inorder[j] == preorder[i]) {\n\t\t\t\tpos = j;\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag)break;\n\t}\n\tdfs(preorder, vi(inorder.begin(), inorder.begin() + pos));\n\tdfs(preorder, vi(inorder.begin() + pos + 1, inorder.end()));\n\tcnt++;\n\tcout << inorder[pos];\n\tif (cnt == preorder.size()) {\n\t\tcout << endl;\n\t}\n\telse {\n\t\tcout << ' ';\n\t}\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\tvi preorder(N), inorder(N);\n\trep(i, N) {\n\t\tcin >> preorder[i];\n\t}\n\trep(i, N) {\n\t\tcin >> inorder[i];\n\t}\n\n\tdfs(preorder, inorder);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nstruct data{\n\tint par,left,right;\n};\n\nint n;\nint a[41],b[41],c[41];\ndata dat[41];\nint cnt;\n\nvoid dfs(int v){\n\tif(dat[v].left>0)dfs(dat[v].left);\n\tif(dat[v].right>0)dfs(dat[v].right);\n\tprintf(\"%d%c\",v,cnt==n-1?'\\n':' ');\n\tcnt++;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&b[i]);\n\t\tc[b[i]]=i;\n\t}\n\tc[0]=n;\n\tfor(int i=1;i<=n;i++){\n\t\tdat[i].par=-1;\n\t\tdat[i].left=-1;\n\t\tdat[i].right=-1;\n\t}\n\tdat[a[0]].par=0;\n\tint p=a[0];\n\tint mostr=c[a[0]];\n\tfor(int i=1;i<n;i++){\n\t\tfor(int j=c[a[i]]-1;j>=0;j--){\n\t\t\tif(dat[b[j]].par!=-1 && dat[b[j]].right==-1){\n\t\t\t\tdat[b[j]].right=a[i];\n\t\t\t\tdat[a[i]].par=b[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int j=c[a[i]]+1;j<n;j++){\n\t\t\tif(dat[b[j]].par!=-1 && dat[b[j]].left==-1){\n\t\t\t\tdat[b[j]].left=a[i];\n\t\t\t\tdat[a[i]].par=b[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tdfs(a[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<string>\n\nusing namespace std;\n\nclass node{\npublic:\n\tint id;\n\tnode* left, * right;\n\tint parent;\n\tint sibling;\n\tint depth;\n\tint height;\n};\n\nbool operator<=(node a, node b) {\n\treturn a.id <= b.id;\n}\nbool operator<(node a, node b) {\n\treturn a.id < b.id;\n}\n\nbool operator==(node a, node b) {\n\treturn a.id == b.id;\n}\n\nbool operator!=(node a, node b) {\n\treturn a.id != b.id;\n}\n\nnode* MakeTreeFromPreAndInOrder(int* pre, int* in, int n) {\n\tnode* root= new node;\n\tint* pretmp, * intmp;\n\troot->id = pre[0];\n\tint i;\n\tfor (i = 0;i <n;i++) {\n\t\tif (in[i] == pre[0])break;\n\t}\n\tif (i != 0) {\n\t\tpretmp = new int[i];\n\t\tintmp = new int[i];\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\tpretmp[j] = pre[j + 1];\n\t\t\tintmp[j] = in[j];\n\t\t}\n\t\troot->left = MakeTreeFromPreAndInOrder(pretmp, intmp, i);\n\t}\n\telse {\n\t\tnode *ntemp = new node;\n\t\tntemp->id = -1;\n\t\troot->left = ntemp;\n\t}\n\tif (i != n - 1) {\n\t\tpretmp = new int[n - 1 - i];\n\t\tintmp = new int[n - 1 - i];\n\t\tfor (int j = 0;j < n - 1 - i;j++) {\n\t\t\tpretmp[j] = pre[i + j + 1];\n\t\t\tintmp[j] = in[i + j + 1];\n\t\t}\n\n\t\troot->right = MakeTreeFromPreAndInOrder(pretmp, intmp, n - i - 1);\n\t}\n\telse {\n\t\tnode *ntemp = new node;\n\t\tntemp->id = -1;\n\t\troot->right = ntemp;\n\t}\n\treturn root;\n}\n\nstring postorder(node* nod) {\n\tstring msg=\"\";\n\tif (nod->left->id != -1) {\n\t\tmsg += postorder(nod->left);\t\n\t}\n\tif (nod->right->id != -1) {\n\t\tmsg += postorder(nod->right);\t\n\t}\n\tmsg += to_string(nod->id) + \" \";\n\treturn msg;\n}\n\n\n\nint main() {\n\tint  n,tmp2,index_root;\n\tcin >> n;\n\tint* pre = new int[n];\n\tint* in = new int[n];\n\tfor (int i = 0;i < n;i++) {\n\t\tcin >> pre[i];\n\t}\n\tfor (int i = 0;i < n;i++) {\n\t\tcin >> in[i];\n\t}\n\tnode* root = MakeTreeFromPreAndInOrder(pre, in, n);\n\tstring msg = postorder(root);\n\t\n\tcout << msg.substr(0, msg.size() - 1) << endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n\tif (l >= r)return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\nvoid solve() {\n\tpos = 0;\n\trec(0, pre.size());\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i)cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\n\nint main()\n{\n\tint k;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n  if( l >= r ) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(l, m);\n  rec(m+1, r);\n  post.push_back(root);\n}\n\nvoid solve(){\n  int i;\n  pos = 0;\n  rec(0, pre.size());\n  for( i = 0 ; i < n ; i++ ){\n    if(i) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main(){\n  int i, k;\n\n  cin >> n;\n\n  for( i = 0 ; i < n ; i++ ){\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for( i = 0 ; i < n ; i++ ){\n    cin >> k;\n    in.push_back(k);\n  }\n\n  solve();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint N,P[45],I[45],i,j,G[45][3],p,f[45]={0},c=0;\n\nvoid dfs(int p)\n{\n\tif(G[p][0]!=-1)\n\t\tdfs(G[p][0]);\n\tif(G[p][1]!=-1)\n\t\tdfs(G[p][1]);\n\tprintf(\"%s%d\",c++==0?\"\":\" \",p);\n\n}\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tmemset(G,-1,sizeof(G));\n\tfor(i=0;i<N;i++)scanf(\"%d\",&P[i]);\n\tfor(i=0;i<N;i++)scanf(\"%d\",&I[i]);\n\tp=P[0];\n\tfor(int np=0,ip=0;np<N;)\n\t{\n\t\twhile(P[np]!=I[ip])\n\t\t{\n\t\t\tG[P[np]][0]=P[np+1];\n\t\t\tG[P[np+1]][2]=P[np];\n\t\t\tf[P[np]]=1;f[P[np+1]]=1;\n\t\t\tnp++;\n\t\t}\n\t\twhile(f[I[ip]])\n\t\t{\n\t\t\tip++;\n\t\t}\n\t\tif(ip>0&&ip<N)\n\t\t{\n\t\t\tG[I[ip-1]][1]=I[ip];\n\t\t\tG[I[ip]][2]=I[ip-1];\n\t\t\tf[I[ip]]=1;\n\t\t}\n\t\tif(I[ip]==P[np])ip++;\n\t\tnp++;\n\t}\n\tdfs(P[0]);\n\tputs(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int left, int right) {\n  if ( left >= right ) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(left, m);\n  rec(m + 1, right);\n  post.push_back(root);\n}\n\nvoid solve() {\n  pos = 0;\n  rec(0, pre.size());\n  for ( int i = 0; i < n; i++ ) {\n    if ( i ) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main() {\n  int k;\n  cin >> n;\n\n  for ( int i = 0; i < n; i++ ) {\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for ( int i = 0; i < n; i++ ) {\n    cin >> k;\n    in.push_back(k);\n  }\n\n  solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>    // std::copy\n#include <iterator>     // std::back_inserter\nusing namespace std;\n\nstruct TNode\n{\n\tint Id;\n\tTNode* Parent;\n\tTNode* LChild;\n\tTNode* RChild;\n};\n\nvector<int> Input(int n)\n{\n\tvector<int> Tree(n);\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> Tree[i];\n\t}\n\treturn Tree;\n}\n\nvoid PostorderOutput(const TNode* Node)\n{\n\tif(Node == NULL) return;\n\tPostorderOutput(Node->LChild);\n\tPostorderOutput(Node->RChild);\n\tcout << Node->Id;\n\tif(Node->Parent){\n\t\tcout << ' '\n\t}else{\n\t\tcout << endl;\n\t}\n}\n\nint FindIndex(vector<int> X, int a)\n{\n\tint Count = 0;\n\twhile(Count < X.size()){\n\t\tif(X[Count] == a){\n\t\t\treturn Count;\n\t\t}\n\t\tCount++;\n\t}\n\treturn Count;\n}\n\nvector<int> Subvec(vector<int> X, int m, int n)\n{\n\tvector<int> Y;\n\tfor(int i = m; i <= n; i++){\n\t\tY.push_back(X[i]);\n\t}\n\treturn Y;\n}\n\nTNode* MakeTree(const vector<int>& PreorderRow, const vector<int>& InorderRow)\n{\n\t//PreorderRow????????????????´?Root?????¨???*\n\tint Root = PreorderRow[0];\n\t\n\t//InorderRow??????????????????Root??????InorderRowLeft?????¨???\n\tint RootIndex = FindIndex(InorderRow, Root);\n\tvector<int> InorderRowLeft = Subvec(InorderRow, 0, RootIndex-1);\n\t\n\t//PreorderRow???2??????????????????InorderRowLeft??¨???????????°???PreorderRowLeft?????¨???\n\tvector<int> PreorderRowLeft = Subvec(PreorderRow, 1, RootIndex);\n\t\n\t//PreorderRow??¨InorderRow???????????????PreorderRowRight,InorderRowRight?????¨???\n\tvector<int> PreorderRowRight = Subvec(PreorderRow, RootIndex+1, PreorderRow.size()-1);\n\tvector<int> InorderRowRight  = Subvec(InorderRow, RootIndex+1, InorderRow.size()-1);\n\t\n\t//ID???Root??¨????????????????????????**\n\tTNode* RootNode;\n\tRootNode = new TNode;\n\t*RootNode = {Root, NULL, NULL, NULL};\n\t\n\t//PreorderRowLeft,InorderRowLeft??????*~**??¨????§???????????????????(?????????????´????RootLeft??¨??????)\n\tif(PreorderRowLeft.size() > 0){\n\t\tTNode* LeftNode = MakeTree(PreorderRowLeft, InorderRowLeft);\n\t\t//Root??¨RootLeft???????????????\n\t\tRootNode->LChild = LeftNode;\n\t\tLeftNode->Parent = RootNode;\n\t}\n\t\n\t//PreorderRowRight,InorderRowRight??????*~**??¨????§???????????????????(?????????????´????RootRight??¨??????)\n\tif(PreorderRowRight.size() > 0){\n\t\tTNode* RightNode = MakeTree(PreorderRowRight, InorderRowRight);\n\t\t//Root??¨RootRight???????????????\n\t\tRootNode->RChild = RightNode;\n\t\tRightNode->Parent = RootNode;\n\t}\n\t\n\treturn RootNode;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<int> PreorderRow = Input(n);\n\tvector<int> InorderRow  = Input(n);\n\tTNode* RootNode = MakeTree(PreorderRow, InorderRow);\n\tPostorderOutput(RootNode);\n//\tDeleteNode(RootNode);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*! if g++ -g alds_1_7_d.cpp -o alds_1_7_d.out; then ./alds_1_7_d.out < alds_1_7_d.test; fi\n */\n\n#include <sstream>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iterator>\n#include <numeric>\n#include <functional>\n#include <climits>\n\n\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\nvector<int> pre(0);\nvector<int> ipre(0);\nvector<int> mid(0);\nvector<int> imid(0);\n\nclass node{\npublic:\n  int id, left, right;\n  node(): id(-1), left(-1), right(-1){}\n};\n\nvector<node> tree(0);\n\nint doit(int pl, int pr, int ml, int mr){\n  if(pl == pr) return -1;\n  int root_id = pre[pl];\n\n  int ml1 = ml;\n  int mr1 = imid[root_id];\n  int ml2 = mr1 + 1;\n  int mr2 = mr;\n\n  int pl1 = pl + 1;\n  int pr1 = pl1 + mr1 - ml1;\n  int pl2 = pr1;\n  int pr2 = pr;\n\n  node& nd = tree[root_id-1];\n  nd.id = root_id;\n  nd.left = doit(pl1, pr1, ml1, mr1);\n  nd.right = doit(pl2, pr2, ml2, mr2);\n  return root_id;\n}\n\nvector<int> ret(0);\n\nvoid post(int root){\n  node& nd = tree[root-1];\n  if(nd.left > 0) post(nd.left);\n  if(nd.right > 0) post(nd.right);\n  ret.push_back(nd.id);\n}\n\nint main(){\n  int n;\n  cin >> n;\n  pre.resize(n);\n  mid.resize(n);\n  ipre.resize(n);\n  imid.resize(n);\n  tree.resize(n);\n  for (int i = 0; i < n; i++) {\n    cin >> pre[i];\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> mid[i];\n  }\n  for (int i = 0; i < n; i++) {\n    ipre[pre[i]] = i;\n    imid[mid[i]] = i;\n  }\n  int root_id = doit(0, n, 0, n);\n  post(root_id);\n  for (int i = 0; i < n-1; i++) {\n    cout << ret[i] << \" \";\n  }\n  cout << ret.back() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef _DEBUG\n#define ASSERT(x) assert(x)\n#define DLOG(x) cout << __LINE__ << \": \" << x << endl;\n#else\n#define ASSERT(x)\n#define DLOG(x)\n#endif\n#define DLOG_V(x) DLOG(#x << \": \" << x)\n\nusing namespace std;\n\nvector<int> read(int n) {\n  vector<int> res;\n  for (int i = 0; i < n; ++i) {\n    int t;\n    cin >> t;\n    res.push_back(t - 1);\n  }\n  return res;\n}\n\ntemplate <typename It> class Node {\npublic:\n  Node(It begin, It end) : begin_{begin}, end_{end} {\n    DLOG_V(*begin);\n    DLOG_V(*(end - 1));\n  }\n\n  template <typename IndexMap> void setRoot(It root, IndexMap& m) {\n    ASSERT(root != end_);\n    root_ = *root;\n    if (begin_ != root) {\n      left_ = make_unique<Node>(begin_, root);\n      for (auto c = begin_; c != root; ++c) {\n        m[*c] = left();\n      }\n    }\n    if (root + 1 != end_) {\n      right_ = make_unique<Node>(root + 1, end_);\n      for (auto c = root + 1; c != end_; ++c) {\n        m[*c] = right();\n      }\n    }\n  }\n\n  int root() const { return root_; }\n\n  auto left() const { return left_.get(); }\n  auto right() const { return right_.get(); }\n\nprivate:\n  It begin_;\n  It end_;\n  int root_{-1};\n  unique_ptr<Node> left_;\n  unique_ptr<Node> right_;\n};\n\ntemplate <typename Container>\nstatic Node<typename Container::const_iterator> makeNode(Container& container) {\n  return {container.begin(), container.end()};\n}\n\ntemplate <typename T, typename C>\nauto postOrder(T& result, const Node<C>* node) {\n  if (!node)\n    return;\n  postOrder(result, node->left());\n  postOrder(result, node->right());\n  result.push_back(node->root());\n}\n\nint main() {\n  int n;\n  cin >> n;\n  auto pre = read(n);\n  auto in = read(n);\n  auto root = makeNode(in);\n  vector<decltype(root)*> nodes(n, &root);\n  for (auto&& i : pre) {\n    auto it = std::find(in.begin(), in.end(), i);\n    ASSERT(it != in.end());\n    auto& node = *nodes[*it];\n    node.setRoot(it, nodes);\n  }\n  vector<int> result;\n  postOrder(result, &root);\n\n  bool first{true};\n  for (auto&& r : result) {\n    if (first) {\n      first = false;\n    } else {\n      cout << \" \";\n    }\n    cout << (r + 1);\n  }\n  cout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <clocale>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(false); cin.tie(0);\n#define FOR(i, s, n) for(int i = (s), i##_len=(n); i < i##_len; ++i)\n#define FORS(i, s, n) for(int i = (s), i##_len=(n); i <= i##_len; ++i)\n#define VFOR(i, s, n) for(int i = (s); i < (n); ++i)\n#define VFORS(i, s, n) for(int i = (s); i <= (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPS(i, n) FORS(i, 0, n)\n#define VREP(i, n) VFOR(i, 0, n)\n#define VREPS(i, n) VFORS(i, 0, n)\n#define RFOR(i, s, n) for(int i = (s), i##_len=(n); i >= i##_len; --i)\n#define RFORS(i, s, n) for(int i = (s), i##_len=(n); i > i##_len; --i)\n#define RREP(i, n) RFOR(i, n, 0)\n#define RREPS(i, n) RFORS(i, n, 0)\n#define ALL(v) (v).begin(), (v).end()\n#define SORT(v) sort(ALL(v))\n#define RSORT(v) sort(ALL(v), greater<decltype(v[0])>())\n#define SZ(x) ((int)(x).size())\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n\nusing ll = long long;\nusing Pi_i = pair<int, int>;\nusing VB = vector<bool>;\nusing VC = vector<char>;\nusing VD = vector<double>;\nusing VI = vector<int>;\nusing VLL = vector<ll>;\nusing VS = vector<string>;\nusing VSH = vector<short>;\n\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst int NIL = -1;\n\ntemplate<class T>\nbool chmax(T &a, const T &b){\n    if(a < b){\n        a = b; return true;\n    }\n    return false;\n}\ntemplate<class T>\nbool chmin(T &a, const T &b){\n    if(b < a){\n        a = b; return true;\n    }\n    return false;\n}\n\n\n\n\nclass BinaryTree{\n    struct Node{//par :親, lt:左の子, rt:右の子\n        int par, lt, rt, d, h;\n        Node(): par(NIL), lt(NIL), rt(NIL), d(0), h(0){};\n        Node(int P, int L, int R): par(P), lt(L), rt(R), d(0), h(0){};\n    };\n    vector<Node> T;\n    int pos = 0; //rec用\npublic:\n    BinaryTree(int n){\n        T.resize(n, Node(NIL, NIL, NIL));\n    }\n\n    void addNode(int p, int l, int r) {\n        T[p].lt = l;\n        T[p].rt = r;\n        if(l != NIL) T[l].par = p;\n        if(r != NIL) T[r].par = p;\n    }\n\n    void setParent(int v, int p){\n        T[v].par = p;\n    }\n\n    int getParent(int v){\n        return T[v].par;\n    }\n\n    void setLeft(int v, int l){\n        T[v].lt = l;\n    }\n\n    int getLeft(int v){\n        return T[v].lt;\n    }\n\n    void setRight(int v, int r){\n        T[v].rt = r;\n    }\n\n    int getRight(int v){\n        return T[v].rt;\n    }\n\n    void setDepth(int v, int dd){\n        T[v].d = dd;\n        if(T[v].rt != NIL) setDepth(T[v].rt, dd+1);\n        if(T[v].lt != NIL) setDepth(T[v].lt, dd+1);\n    }\n\n    int setHeight(int v){\n        int hl = 0, hr = 0;\n        if(T[v].lt != NIL) hl = setHeight(T[v].lt) + 1;\n        if(T[v].rt != NIL) hr = setHeight(T[v].rt) + 1;\n        return T[v].h = max(hl, hr);\n    }\n\n    int getSibling(int v){\n        if(T[v].par == NIL) return NIL;\n        if(T[T[v].par].lt != v && T[T[v].par].lt != NIL)\n            return T[T[v].par].lt;\n        if(T[T[v].par].rt != v && T[T[v].par].rt != NIL)\n            return T[T[v].par].rt;\n        return NIL;\n    }\n\n    void printTree(int v){\n        cout << \"node \" << v << \": \";\n        cout << \"parent = \" << T[v].par << \", \";\n        cout << \"sibling = \" << getSibling(v) << \", \";\n        int dg = 0;\n        if(T[v].lt != NIL) ++dg;\n        if(T[v].rt != NIL) ++dg;\n        cout << \"degree = \" << dg << \", \";\n        cout << \"depth = \" << T[v].d << \", \";\n        cout << \"height = \" << T[v].h << \", \";\n\n        if(T[v].par == NIL) cout << \"root\";\n        else if(T[v].lt == NIL && T[v].rt == NIL)\n            cout << \"leaf\";\n        else cout << \"internal node\";\n        cout << \"\\n\";\n    }\n\n    void preParse(int v){\n        if(v == NIL) return;\n        cout << \" \" << v;\n        preParse(T[v].lt);\n        preParse(T[v].rt);\n    }\n\n    void inParse(int v){\n        if(v == NIL) return;\n        inParse(T[v].lt);\n        cout << \" \" << v;\n        inParse(T[v].rt);\n    }\n\n    void postParse(int v){\n        if(v == NIL) return;\n        postParse(T[v].lt);\n        postParse(T[v].rt);\n        cout << \" \" << v;\n    }\n\n    void postParse1index(int &i, int v){\n        if(v == NIL) return;\n        postParse1index(i, T[v].lt);\n        postParse1index(i, T[v].rt);\n        cout << (i ? \" \" : \"\") << v + 1;\n        ++i;\n    }\n\n    int reconstFromPreIn(VI &pre, VI &in, int l, int r){\n        if(l >= r) return NIL;\n        int root = pre[pos++];\n        int m = distance(in.begin(), find(ALL(in), root));\n        int lc = reconstFromPreIn(pre, in, l, m);\n        int rc = reconstFromPreIn(pre, in, m+1, r);\n        addNode(root, lc, rc);\n        return root;\n    }\n};\n\n\nint main(){\n    int n; cin >> n;\n    VI pre(n), in(n);\n    REP(i, n){\n        cin >> pre[i];\n        --pre[i];\n    }\n    REP(i, n){\n        cin >> in[i];\n        --in[i];\n    }\n    BinaryTree T(n);\n    int root = pre[0];\n    T.reconstFromPreIn(pre, in, 0, n);\n    int cnt = 0;\n    T.postParse1index(cnt, root);\n    cout << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>    // std::copy\n#include <iterator>     // std::back_inserter\nusing namespace std;\n\nstruct TNode\n{\n\tint Id;\n\tTNode* Parent;\n\tTNode* LChild;\n\tTNode* RChild;\n};\n\nvector<int> Input(int n)\n{\n\tvector<int> Tree(n);\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> Tree[i];\n\t}\n\treturn Tree;\n}\n\nvoid PostorderOutput(const TNode* Node)\n{\n\tif(Node == NULL) return;\n\tPostorderOutput(Node->LChild);\n\tPostorderOutput(Node->RChild);\n\tcout << ' ' << Node->Id;\n}\n\nint FindIndex(vector<int> X, int a)\n{\n\tint Count = 0;\n\twhile(Count < X.size()){\n\t\tif(X[Count] == a){\n\t\t\treturn Count;\n\t\t}\n\t\tCount++;\n\t}\n\treturn Count;\n}\n\nvector<int> Subvec(vector<int> X, int m, int n)\n{\n\tvector<int> Y;\n\tfor(int i = m; i <= n; i++){\n\t\tY.push_back(X[i]);\n\t}\n\treturn Y;\n}\n\nTNode* MakeTree(const vector<int>& PreorderRow, const vector<int>& InorderRow)\n{\n\t//PreorderRow????????????????´?Root?????¨???*\n\tint Root = PreorderRow[0];\n\t\n\t//InorderRow??????????????????Root??????InorderRowLeft?????¨???\n\tint RootIndex = FindIndex(InorderRow, Root);\n\tvector<int> InorderRowLeft = Subvec(InorderRow, 0, RootIndex-1);\n\t\n\t//PreorderRow???2??????????????????InorderRowLeft??¨???????????°???PreorderRowLeft?????¨???\n\tvector<int> PreorderRowLeft = Subvec(PreorderRow, 1, RootIndex);\n\t\n\t//PreorderRow??¨InorderRow???????????????PreorderRowRight,InorderRowRight?????¨???\n\tvector<int> PreorderRowRight = Subvec(PreorderRow, RootIndex+1, PreorderRow.size()-1);\n\tvector<int> InorderRowRight  = Subvec(InorderRow, RootIndex+1, InorderRow.size()-1);\n\t\n\t//ID???Root??¨????????????????????????**\n\tTNode* RootNode;\n\tRootNode = new TNode;\n\t*RootNode = {Root, NULL, NULL, NULL};\n\t\n\t//PreorderRowLeft,InorderRowLeft??????*~**??¨????§???????????????????(?????????????´????RootLeft??¨??????)\n\tif(PreorderRowLeft.size() > 0){\n\t\tTNode* LeftNode = MakeTree(PreorderRowLeft, InorderRowLeft);\n\t\t//Root??¨RootLeft???????????????\n\t\tRootNode->LChild = LeftNode;\n\t\tLeftNode->Parent = RootNode;\n\t}\n\t\n\t//PreorderRowRight,InorderRowRight??????*~**??¨????§???????????????????(?????????????´????RootRight??¨??????)\n\tif(PreorderRowRight.size() > 0){\n\t\tTNode* RightNode = MakeTree(PreorderRowRight, InorderRowRight);\n\t\t//Root??¨RootRight???????????????\n\t\tRootNode->RChild = RightNode;\n\t\tRightNode->Parent = RootNode;\n\t}\n\t\n\treturn RootNode;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<int> PreorderRow = Input(n);\n\tvector<int> InorderRow  = Input(n);\n\tTNode* RootNode = MakeTree(PreorderRow, InorderRow);\n\tPostorderOutput(RootNode);\n\tcout << endl;\n//\tDeleteNode(RootNode);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\n\nstd::vector<int> pre;\nstd::vector<int> in;\nstd::vector<int> post;\n\nint count = 0;\nint next(std::vector<int>& v)\n{\n    int res = v[count];\n    count++;\n    return res;\n}\n\nvoid reconstruction(int l, int r)\n{\n    if (l >= r) return;\n\n    int c = next(pre);\n    int m = std::distance(in.begin(), std::find(in.begin(), in.end(), c));\n\n    reconstruction(l, m);\n    reconstruction(m + 1, r);\n\n    post.push_back(c);\n}\n\nint main(int argc, char const *argv[])\n{\n    int n;\n    cin >> n;\n    pre.resize(n);\n    in.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> pre[i];\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> in[i];\n    }\n\n    reconstruction(0, n);\n\n    for (int i = 0; i < n - 1; i++) {\n        cout << post[i] << \" \";\n    }\n    cout << post[n - 1] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nconst int maxn = 105;\n\nint lnode[maxn], rnode[maxn];\nint pre_order[maxn], in_order[maxn];\nint n;\n\nint build(int pl, int pr, int il, int ir){\n\tif(il > ir) return -1;\n\tint root = pre_order[pl];\n\tint p = il;\n\twhile(in_order[p] != root) p++;\n\tlnode[root] = build(pl + 1, pl + p - il, il, p - 1);\n\trnode[root] = build(pl + p - il + 1, pr, p + 1, ir);\n\treturn root;\n}\n\n\nvoid post_order(int now, int &first) {\n\tif (now == -1) return;\n\tpost_order(lnode[now], first);\n\tpost_order(rnode[now], first);\n\tif(first) first = 0;\n\telse printf(\" \");\n\tprintf(\"%d\", now);\n}\n\nint main(){\n\twhile(~scanf(\"%d\", &n)){\n\t\tfor(int i = 0; i < n; i ++){\n\t\t\tscanf(\"%d\", &pre_order[i]);\n\t\t}\n\n\t\tfor(int i = 0; i < n; i ++){\n\t\t\tscanf(\"%d\", &in_order[i]);\n\t\t}\n\t\tint first = 1;\n\t\tbuild(0, n - 1, 0, n - 1);\n\t\tpost_order(pre_order[0], first);\n\t\tputs(\"\");\n\t}\t\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n// https://onlinejudge.u-aizu.ac.jp/problems/ALDS1_7_D\n\nint n;\nvector<int> preorder, inorder, inorder_rev, postorder;\nvector<pair<int, int>> tree;\n\nint make_tree(int left, int right) {  // preorderでの左端と右端\n  if (left == right) return -1;\n  int top_ltree = left + 1, top_rtree = left + 1;\n  int iroot = inorder_rev[preorder[left]];\n  for (int i = left + 1; i < right; i++) {\n    if (iroot < inorder_rev[preorder[i]]) {\n      top_rtree = i;\n      break;\n    }\n  }\n  tree[preorder[left]].first = make_tree(top_ltree, top_rtree);\n  tree[preorder[left]].second = make_tree(top_rtree, right);\n  return preorder[left];\n}\n\nvoid make_postorder(int p) {\n  if (p < 0) return;\n  make_postorder(tree[p].first);\n  make_postorder(tree[p].second);\n  postorder.push_back(p);\n  return;\n}\n\nint main() {\n  cin >> n;\n  preorder.resize(n);\n  inorder.resize(n);\n  inorder_rev.resize(n);\n  tree.resize(n, make_pair(-1, -1));\n  for (int i = 0; i < n; i++) {\n    cin >> preorder[i];\n    preorder[i]--;\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> inorder[i];\n    inorder[i]--;\n    inorder_rev[inorder[i]] = i;\n  }\n  int root = make_tree(0, n);\n\n  postorder.resize(0);\n  make_postorder(root);\n\n  for (int i = 0; i < n; i++) {\n    cout << postorder[i] + 1 << (i == n - 1 ? \"\" : \" \");\n  }\n  cout << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint N;\nint preorder[41], inorder[41], postorder[41];\nvoid make_postorder(int pre[], int in[], int post[], int num) {\n    if (num == 0) return;\n    if (num == 1) {\n        post[0] = pre[0];\n        return;\n    }\n    int v1[41],v2[41];\n    int num1 = find(in, in+num, pre[0]) - in;\n    int num2 = num - num1 - 1;\n    make_postorder(pre+1, in, v1, num1);\n    make_postorder(pre+1+num1, in+num1+1, v2, num2);\n    copy(v1, v1+num1, post);\n    copy(v2, v2+num2, post+num1);\n    post[num1+num2] = pre[0];\n}\n\nint main() {\n    cin>>N;\n    for (int n = 0; n < N; n++) cin>>preorder[n];\n    for (int n = 0; n < N; n++) cin>>inorder[n];\n    make_postorder(preorder, inorder, postorder, N);\n    for (int n = 0; n < N-1; n++) cout<<postorder[n]<<\" \";\n    cout<<postorder[N-1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * ALDS1_7_D.cpp\n *\n *  Created on: May 3, 2018\n *      Author: 13743\n */\n\n#include<iostream>\n#include<stack>\n\nusing namespace std;\n\nint n;\nint pre[42];\nint in[42];\nint preInv[42];\nint inInv[42];\n\nstack<int> post;\n\nvoid reconstruct(int key, int l, int r) {\n\tif(l > r) return;\n\tpost.push(key);\n\tint c = inInv[key];\n\tint leftT = c - l;\n\treconstruct(pre[preInv[key]+leftT+1], c+1, r);\n\treconstruct(pre[preInv[key]+1], l, c-1);\n}\n\nint main() {\n\tcin >> n;\n\tfor(int i=1; i<=n; i++) {\n\t\tcin >> pre[i];\n\t\tpreInv[pre[i]] = i;\n\t}\n\tfor(int i=1; i<=n; i++) {\n\t\tcin >> in[i];\n\t\tinInv[in[i]] = i;\n\t}\n\n\treconstruct(pre[1], 1, n);\n\n\tcout << post.top();\n\tpost.pop();\n\twhile(!post.empty()) {\n\t\tcout << \" \" << post.top();\n\t\tpost.pop();\n\t}\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nclass BinaryTree {\nprivate:\n    static const int NIL = -1;\n    struct Node {\n        int parent, sibling, left, right, degree, depth, height;\n        Node() { parent = sibling = left = right = depth = height = NIL; degree = 0; }\n    };\n    std::vector<Node> T;\n    const int N = T.size();\n    int root;\npublic:\n    BinaryTree(int N) :T(N) { root = NIL; }\n    void addNode(int p, int l, int r) {\n        T[p].left = l;\n        T[p].right = r;\n        T[l].parent = T[r].parent = p;\n    }\n    void buildPreIn(std::vector<int> &pre, std::vector<int> &in) {\n        setPreIn(pre, in, 0, pre.size());\n    }\n    void initTree() {\n        setRoot();\n        //setDepth(root, 0);\n        //setHeight(root);\n        //setSibling();\n    }\n    int getDegree(int v) {\n        return T[v].degree;\n    }\n    int getDepth(int v) {\n        return T[v].depth;\n    }\n    int getHeight(int v) {\n        return T[v].height;\n    }\n    int getParent(int v) {\n        return T[v].parent;\n    }\n    std::pair<int, int> getChildren(int v) {\n        return { T[v].left, T[v].right };\n    }\n    int getSibling(int v) {\n        return T[v].sibling;\n    }\n    int getType(int v) {\n        if (T[v].parent == NIL) return NIL;\n        if (T[v].left == NIL && T[v].right == NIL) return 1;\n        else return 0;\n    }\n    std::vector<int> getInOrder(){\n        std::vector<int> S;\n        setInOrder(S, root);\n        return S;\n    }\n    std::vector<int> getPostOrder(){\n        std::vector<int> S;\n        setPostOrder(S, root);\n        return S;\n    }\n    std::vector<int> getPreOrder(){\n        std::vector<int> S;\n        setPreOrder(S, root);\n        return S;\n    }\nprivate:\n    void setRoot() {\n        for (int i = 0; i < N; ++i)\n            if (T[i].parent == NIL) root = i;\n    }\n    void setDepth(int v, int d) {\n        if (v == NIL) return;\n        T[v].depth = d;\n        setDepth(T[v].right, d + 1);\n        setDepth(T[v].left, d + 1);\n    }\n    int setHeight(int v) {\n        int h1 = 0, h2 = 0;\n        if (T[v].left != NIL) h1 = setHeight(T[v].left) + 1;\n        if (T[v].right != NIL) h2 = setHeight(T[v].right) + 1;\n        return T[v].height = std::max(h1, h2);\n    }\n    void setSibling() {\n        for (int i = 0; i < N; ++i) {\n            if (T[i].parent == NIL) continue;\n            if (T[T[i].parent].left != i && T[T[i].parent].left != NIL)\n                T[i].sibling = T[T[i].parent].left;\n            else if (T[T[i].parent].right != i && T[T[i].parent].right != NIL)\n                T[i].sibling = T[T[i].parent].right;\n            ++T[T[i].parent].degree;\n        }\n    }\n    int setPreIn(std::vector<int> &pre, std::vector<int> &in, int l, int r) {\n        static int pos = 0;\n        if(l>=r) return NIL;\n        int root = pre[pos++];\n        int mid = std::distance(in.begin(), std::find(in.begin(), in.end(), root));\n        int ln = setPreIn(pre, in, l, mid);\n        int rn = setPreIn(pre, in, mid+1, r);\n        addNode(root, ln, rn);\n        return root;\n    }\n    void setInOrder(std::vector<int> &S, int v){\n        if(v == NIL) return;\n        setInOrder(S, T[v].left);\n        S.push_back(v);\n        setInOrder(S, T[v].right);\n    }\n    void setPostOrder(std::vector<int> &S, int v){\n        if(v == NIL) return;\n        setPostOrder(S, T[v].left);\n        setPostOrder(S, T[v].right);\n        S.push_back(v);\n    }\n    void setPreOrder(std::vector<int> &S, int v){\n        if(v == NIL) return;\n        S.push_back(v);\n        setPreOrder(S, T[v].left);\n        setPreOrder(S, T[v].right);\n    }\n};\n#include<iostream>\nusing namespace std;\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin>>n;\n    vector<int> pre(n), in(n);\n    for(int i=0;i<n;++i){\n        int v;\n        cin>>v;\n        pre[i]=v-1;\n    }\n    for(int i=0;i<n;++i){\n        int v;\n        cin>>v;\n        in[i]=v-1;\n    }\n    BinaryTree T(n);\n    T.buildPreIn(pre, in);\n    T.initTree();\n    std::vector<int> v = T.getPostOrder();\n    for(int i=0;i<v.size();++i) cout<<(i?\" \":\"\")<<v[i]+1;\n    cout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <list>\n\nconst int MAX_N = 25;\nconst int SINGLE_NODE = 1;\nconst int NONE = -1;\n\nstruct Node {\n  int parent;\n  int left;\n  int right;\n  bool visited;\n};\n\nint reconstruct(std::list<int> *preorderNodes,\n\t\t std::list<int> *inorderNodes,\n\t\t int parent,\n\t\t struct Node *nodes[]) {\n  if (inorderNodes->size() == SINGLE_NODE) {\n    int v = inorderNodes->front();\n    inorderNodes->pop_front();\n\n    nodes[v]->parent = parent;\n\n    preorderNodes->pop_front();\n\n    return v;\n  }\n\n  int v = preorderNodes->front();\n  preorderNodes->pop_front();\n\n  std::list<int> *leftNodes = new std::list<int>();\n  std::list<int> *rightNodes = new std::list<int>();\n\n  while (!inorderNodes->empty()) {\n    int k = inorderNodes->front();\n    inorderNodes->pop_front();\n\n    if (k == v) {\n      break;\n    } else {\n      leftNodes->push_back(k);\n    }\n  }\n\n  while (!inorderNodes->empty()) {\n    int k = inorderNodes->front();\n    inorderNodes->pop_front();\n\n    //    if (k == v) {\n    //      break;\n    //    } else {\n      rightNodes->push_back(k);\n      //    }\n  }\n\n  //  std::cout << v << std::endl;\n  \n  if (!leftNodes->empty()) {\n    // std::cout << \"Left: \";\n\n    // for (std::list<int>::iterator i = leftNodes->begin(); i != leftNodes->end(); ++i) {\n    //   std::cout << (*i) << \" \";\n    // }\n\n    // std::cout << std::endl;\n    \n      nodes[v]->left = reconstruct(preorderNodes, leftNodes, v, nodes);\n  }\n\n  if (!rightNodes->empty()) {\n    // std::cout << \"Right: \";\n\n    // for (std::list<int>::iterator i = rightNodes->begin(); i != rightNodes->end(); ++i) {\n    //   std::cout << (*i) << \" \";\n    // }    \n\n    // std::cout << std::endl;\n    \n    nodes[v]->right = reconstruct(preorderNodes, rightNodes, v, nodes);\n  }\n\n  nodes[v]->parent = parent;\n\n  return v;\n}\n\nvoid printByPostorder(struct Node *nodes[], int n, int rootID) {\n  std::list<int> list;\n\n  list.push_front(rootID);\n\n  bool first = true;\n  \n  while (!list.empty()) {\n    int id = list.front();\n    list.pop_front();\n    \n    if (id < 0) {\n      continue;\n    }\n    \n    struct Node *node = nodes[id];\n\n    if (!node->visited) {\n      node->visited = true;\n      \n      list.push_front(id);      \n      list.push_front(node->right);\n      list.push_front(node->left);\n    } else {\n      if (first) {\n\tstd::cout << id;\n\t\n\tfirst = false;\n      } else {\n\tstd::cout << \" \" << id;\n      }\n    }\n  }\n\n  std::cout << std::endl;      \n}\n\nint main(void) {\n  int n;\n\n  std::cin >> n;\n\n  struct Node *nodes[MAX_N];\n\n  for (int i = 0; i <= n; i++) {\n    struct Node *node = (struct Node *) std::malloc(sizeof(struct Node));\n    \n    node->parent = NONE;\n    node->left = NONE;\n    node->right = NONE;\n    node->visited = false;\n\n    nodes[i] = node;\n  }\n\n  std::list<int> *preorderNodes = new std::list<int>();\n  std::list<int> *inorderNodes = new std::list<int>();\n\n  for (int i = 0; i < n; i++) {\n    int v = 0;\n\n    std::cin >> v;\n\n    preorderNodes->push_back(v);\n  }\n\n  for (int i = 0; i < n; i++) {\n    int v = 0;\n\n    std::cin >> v;\n\n    inorderNodes->push_back(v);\n  }  \n  \n  int rootID = preorderNodes->front();\n\n  reconstruct(preorderNodes, inorderNodes, -1, nodes);\n  \n  printByPostorder(nodes, n, rootID);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n\tif(l >= r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l,m);\n\trec(m+1,r);\n\tpost.push_back(root);\n}\n\nvoid solve(){\n\tpos = 0;\n\trec(0, pre.size());\n\tfor(int i=0;i<n;i++){\n\t\tif(i) cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\n\nint main(){\n\tint k;\n\tcin >> n;\n\n\tfor(int i=0;i<n;i++){\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\n\tfor(int i=0;i<n;i++){\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define eol '\\n';\nusing namespace std;\n\nclass Node {\npublic:\n  int id;\n  int l;\n  int r;\n  int p;\n  Node(): id(-1),l(-1),r(-1),p(-1){};\n};\n\nNode* tree;\n\nint create_tree(int parent, vector<int> pre, vector<int> in) {\n    if (pre.size() == 0 && in.size() == 0) {\n      return -1;\n    }\n\n    int root_id = pre[0];\n\n    Node* node = &tree[root_id];\n    node->p = parent;\n    \n    // left\n    vector<int> left_pre;\n    vector<int> left_in;\n\n    int i = 0;\n    int size = in.size();\n    for (; i < size; i++) {\n      if (in[i] == root_id) {\n        break;\n      }\n      if (i+1 < size) {\n        left_pre.push_back(pre[i+1]);\n        left_in.push_back(in[i]);\n      }\n    }\n    node->l = create_tree(root_id, left_pre, left_in);\n\n    vector<int> right_pre;\n    vector<int> right_in;\n\n    i++;\n    for (;i < size; i++) {\n      right_pre.push_back(pre[i]);\n      right_in.push_back(in[i]);\n    }\n    node->r = create_tree(root_id, right_pre, right_in);\n\n    return root_id;\n}\n\nvector<int> postorder(int id, vector<int> post) {\n  Node* node = &tree[id];\n  if (node->l != -1) {\n    post = postorder(node->l, post);\n  }\n  if (node->r != -1) {\n    post = postorder(node->r, post);\n  }\n  post.push_back(id);\n\n  return post;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  \n  int n,i;\n  cin >> n;\n\n  tree = new Node[n];\n\n  vector<int> preorder(n);\n  vector<int> inorder(n);\n\n  for (i = 0; i < n; i++) {\n    cin >> preorder[i];\n  }\n  for (i = 0; i < n; i++) {\n    cin >> inorder[i];\n  }\n\n  int root = create_tree(-1, preorder, inorder);\n\n  // post order\n  vector<int> post;\n  post = postorder(root, post);\n\n  // output\n  cout << post[0];\n  for (i = 1; i < n; i++) {\n    cout << \" \" << post[i];\n  }\n  cout << eol;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define NIL -1\nstruct Node{int parent,left,right;};\nstruct Node T[41];\nint n,P[41],I[41];\nint search(int x[],int target,int size){\n    for(int i=0;i<size;i++){\n        if(x[i]==target) return i;\n    }\n    return 0;\n}\nvoid Postorder(int x){\n    if(x!=NIL){\n        Postorder(T[x].left);\n        Postorder(T[x].right);\n        if(x==P[0]) cout<<x;\n        else cout<<x<<\" \";\n    }\n}\nvoid saisei(int x[],int p,int size){\n    int l=0,r=0,mid=search(x,P[p],size);\n    int L[40],R[40];\n    \n    for(int i=0;i<size;i++){\n        if(i<mid){L[l]=x[i];l++;}\n        else if(i>mid){R[r]=x[i];r++;}\n    }\n    if(l!=0){\n            T[P[p]].left=P[p+1];\n            T[P[p+1]].parent=P[p];\n            saisei(L,p+1,l);\n    }\n    if(r!=0){\n            T[P[p]].right=P[p+l+1];\n            T[P[p+l+1]].parent=P[p];\n            saisei(R,p+l+1,r);\n    }\n    \n}\nint main(){\n    cin>>n;\n    for(int i=0;i<n;i++) cin>>P[i];\n    for(int i=0;i<n;i++) {\n        cin>>I[i];\n        T[i+1].parent=T[i+1].left=T[i+1].right=NIL;\n    }\n    saisei(I,0,n);\n    Postorder(P[0]); cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\nvector<int> solve(const vector<int>& preorder0, const vector<int>& inorder0) {\n    if (preorder0.size() <= 1) {\n        return preorder0;\n    }\n    const int root = preorder0[0];\n    auto boundary = find(inorder0.begin(), inorder0.end(), root);\n\n    vector<int> inorderL;\n    for (auto i = inorder0.begin(); i != boundary; ++i) {\n        inorderL.push_back(*i);\n    }\n    vector<int> inorderR;\n    auto tmp = boundary;\n    ++tmp;\n    for (auto i = tmp; i != inorder0.end(); ++i) {\n        inorderR.push_back(*i);\n    }\n\n    vector<int> preorderL;\n    auto tmp2 = preorder0.begin();\n    ++tmp2;\n    for (int i = 0; i < inorderL.size(); ++i) {\n        preorderL.push_back(*tmp2);\n        ++tmp2;\n    }\n    vector<int> preorderR;\n    for (int i = 0; i < inorderR.size(); ++i) {\n        preorderR.push_back(*tmp2);\n        ++tmp2;\n    }\n\n    vector<int> postorderTreeWalk = solve(preorderL, inorderL);\n    vector<int> rightSubtree = solve(preorderR, inorderR);\n    for (auto item : rightSubtree) {\n        postorderTreeWalk.push_back(item);\n    }\n    postorderTreeWalk.push_back(root);\n\n    return postorderTreeWalk;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<int> preorderTreeWalk;\n    for (int i = 0; i < n; ++i) {\n        int x;\n        cin >> x;\n        preorderTreeWalk.push_back(x);\n    }\n\n    vector<int> inorderTreeWalk;\n    for (int i = 0; i < n; ++i) {\n        int x;\n        cin >> x;\n        inorderTreeWalk.push_back(x);\n    }\n\n    vector<int> postorderTreeWalk = solve(preorderTreeWalk, inorderTreeWalk);\n\n    std::cout << postorderTreeWalk[0];\n    for (int i = 1; i < postorderTreeWalk.size(); ++i) {\n        std::cout << \" \" << postorderTreeWalk[i];\n    }\n    cout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int i=0; i<(n); ++i)\nusing ll = long long;\nusing P = pair<int, int>;\n\nint n, pos=0;\nvector<int> pre, in, post;\n\nvoid reconstruction(int l, int r) {\n  if (l >= r) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  reconstruction(l, m);\n  reconstruction(m+1, r);\n  post.push_back(root);\n}\n\nint main() {\n  cin >> n;\n  rep(i,n) {\n    int t;\n    cin >> t;\n    pre.push_back(t);\n  }\n  rep(i,n) {\n    int t;\n    cin >> t;\n    in.push_back(t);\n  }\n  \n  reconstruction(0, n);\n\n  rep(i,n) printf(\"%d%c\", post[i], (i==n-1?'\\n':' '));\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n// #include <stack>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint N = 0;\nint pos = 0;\nvector<int> pre, in, post;\n\nvoid reconstruction(int s, int e) {\n    if (s > e) { return; }\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n\n    reconstruction(s, m - 1);\n    reconstruction(m + 1, e);\n    post.push_back(root);\n}\n\nint main() {\n    int t;\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        cin >> t;\n        pre.push_back(t);\n    }\n    for (int i = 0; i < N; i++) {\n        cin >> t;\n        in.push_back(t);\n    }\n    \n    reconstruction(0, N - 1);\n    \n    for (int i = 0; i < N; i++) {\n        if (i != 0) {\n            cout << \" \";\n        }\n        cout << post[i];\n    }\n    cout << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define NIL -1\n\nvector<int> pre, ino;\n\nclass Node\n{\n  public:\n  int p = NIL, l = NIL, r = NIL;\n};\n\nvoid postorder(vector<Node>& nodes, vector<int>& out, int cur)\n{\n    if (cur == NIL) return;\n    postorder(nodes, out, nodes.at(cur).l);\n    postorder(nodes, out, nodes.at(cur).r);\n    out.push_back(cur);\n}\n\nvoid itr_print(vector<int>& out)\n{\n    for (auto itr = out.begin(); itr != out.end(); ++itr) {\n        if (itr != out.begin()) cout << \" \";\n        cout << *itr + 1;\n    }\n    cout << endl;\n}\n\nint crt(vector<Node>& nodes, vector<int>::iterator ino_b, vector<int>::iterator ino_e, vector<int>::iterator pre_cur)\n{\n    if (ino_b == ino_e) return NIL;\n    vector<int>::iterator root;\n    while(pre_cur != ino.end()) {\n        if (ino_e == (root = find(ino_b, ino_e, *pre_cur++))) continue;\n        int l = crt(nodes, ino_b, root, pre_cur);\n        nodes.at(*root).l = l;\n        if (NIL != l) nodes.at(l).p = *root;\n        int r = crt(nodes, root + 1, ino_e, pre_cur);\n        nodes.at(*root).r = r;\n        if (NIL != r) nodes.at(r).p = *root;\n        return *root;\n    }\n    cout << \"error\" << endl;\n    return NIL;\n}\n\nint main()\n{\n    int i, n, r, el;\n    cin >> n;\n    vector<Node> nodes(n);\n    vector<int> out;\n    for (i = 0; i < n; i++) {\n        cin >> el;\n        if (i == 0) r = el - 1;\n        pre.push_back(el - 1);\n    }\n    for (i = 0; i < n; i++) {\n        cin >> el;\n        ino.push_back(el - 1);\n    }\n\n    crt(nodes, ino.begin(), ino.end(), pre.begin());\n    postorder(nodes, out, r);\n    itr_print(out);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r){\n  if(l>=r)\n    return;\n  int root=pre[pos++];\n  int m=distance(in.begin(),find(in.begin(),in.end(),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\n\nvoid solve(){\n  pos=0;\n\n  rec(0,pre.size());\n  int i;\n  for(i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<post[i];\n  }\n  cout<<endl;\n}\n\nint main(){\n  int k;\n  cin>>n;\n  int i;\n  for(i=0;i<n;i++){\n    cin>>k;\n    pre.push_back(k);\n  }\n\n  for(i=0;i<n;i++){\n    cin>>k;\n    in.push_back(k);\n  }\n  solve();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <tuple>\n#include <cassert>\n#include <exception>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << endl\n#define fprint(NUM,X) cout << fixed << setprecision(NUM) << (X) << endl\n#define fprints(NUM,X,Y) cout << fixed << setprecision(NUM) << (X) << \" \" << (Y) << endl\nconst ll INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nll d[200010],dp[550][550];\ndouble w[1000],v[1000];\ndouble box[200010];\n\n\nint N,Pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r){\n  if(l >= r)return;\n  int root = pre[Pos++];\n  int m = distance(in.begin(),find(in.begin(),in.end(),root));\n  rec(l,m);\n  rec(m + 1,r);\n  post.push_back(root);\n}\n\nvoid solve(){\n  Pos = 0;\n  rec(0,pre.size());\n  for(int i = 0;i < N;i++){\n    if(i)cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main(){\n  int k;\n  cin >> N;\n  for(int i = 0;i < N;i++){\n    cin >> k;\n    pre.push_back(k);\n  }\n  for(int i = 0;i < N;i++){\n    cin >> k;\n    in.push_back(k);\n  }\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n \nvector<int> postord;\nint cur,n;\nint pre[41],in[41];\nvoid dfs(int l,int r){\n    if(l>=r) return;\n    int vi=pre[cur];\n    ++cur;\n    int m=distance(in,find(in,in+n,vi));\n    dfs(l,m);\n    dfs(m+1,r);\n    postord.pb(vi);\n}\nint main(){\n    int root;\n    cin>>n;\n    rep(i,n) cin>>pre[i];\n    rep(i,n) cin>>in[i];\n    root=pre[0];\n    dfs(0,n);\n    rep(i,n) cout<<postord[i]<<(i==n-1?\"\":\" \");\n    cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int>pre, in, post;\n\nvoid rec(int l, int r)\n{\n\tif(l >= r)\n\t\treturn;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l ,m);\n\trec(m + 1, r);\n\tpost.push_back(root);\t\n} \n \nvoid solve()\n{\n\tpos = 0;\n\trec(0, pre.size());\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(i)\n\t\t cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\nint main()\n{\n\tint  x;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin >> x;\n\t\tpre.push_back(x);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin >> x;\n\t\tin.push_back(x);\n\t}\n\tsolve();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define eol '\\n';\nusing namespace std;\n\nclass Node {\npublic:\n  int id;\n  int l;\n  int r;\n  int p;\n  Node(): id(-1),l(-1),r(-1),p(-1){};\n};\n\nNode* tree;\n\nint create_tree(int parent, vector<int> pre, vector<int> in) {\n    if (pre.size() == 0 && in.size() == 0) {\n      return -1;\n    }\n\n    int root_id = pre[0];\n\n    Node* node = &tree[root_id];\n    node->p = parent;\n    \n    // left\n    vector<int> left_pre;\n    vector<int> left_in;\n\n    int i = 0;\n    int size = in.size();\n    for (; i < size; i++) {\n      if (in[i] == root_id) {\n        break;\n      }\n      left_pre.push_back(pre[i+1]);\n      left_in.push_back(in[i]);\n    }\n    node->l = create_tree(root_id, left_pre, left_in);\n\n    vector<int> right_pre;\n    vector<int> right_in;\n\n    i++;\n    for (;i < size; i++) {\n      right_pre.push_back(pre[i]);\n      right_in.push_back(in[i]);\n    }\n    node->r = create_tree(root_id, right_pre, right_in);\n\n    return root_id;\n}\n\nvector<int> postorder(int id, vector<int> post) {\n  Node* node = &tree[id];\n  if (node->l != -1) {\n    post = postorder(node->l, post);\n  }\n  if (node->r != -1) {\n    post = postorder(node->r, post);\n  }\n  post.push_back(id);\n\n  return post;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  \n  int n,i;\n  cin >> n;\n\n  tree = new Node[n];\n\n  vector<int> preorder(n);\n  vector<int> inorder(n);\n\n  for (i = 0; i < n; i++) {\n    cin >> preorder[i];\n  }\n  for (i = 0; i < n; i++) {\n    cin >> inorder[i];\n  }\n\n  int root = create_tree(-1, preorder, inorder);\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < n; i++)\n\nvector<int> pre, in, post ;\nint pos = 0;\n\nvoid rec(int left, int right, int &i) {\n    if (left < right) {\n        int root = pre[i];\n        i++;\n        int m = distance(in.begin(), find(in.begin(), in.end(), root));\n        rec(left, m, i);\n        rec(m+1, right, i);\n        post.push_back(root);\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    pre.resize(n);\n    in.resize(n);\n    rep(i, n) {\n        scanf(\"%d\", &pre[i]);\n    }\n    rep(i, n) {\n        scanf(\"%d\", &in[i]);\n    }\n\n    int i = 0;\n    rec(0, n, i);\n    rep(i, n) {\n        printf(\"%d\", post[i]);\n        if (i != n-1) printf(\" \");\n        else printf(\"\\n\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// c lib\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n\n// container\n#include <vector>\n#include <string>\n#include <map>\n#include <list>\n#include <queue>\n#include <array>\n\n// Convenience\n#include <algorithm>\n#include <functional>\n\n// IO\n#include <iostream>\n\nusing namespace std;\n\nusing llong = long long;\nstruct Node {\n    llong p, l, r;\n};\n\nvoid print_tree_rec(Node* tree, llong idx)\n{\n    if (tree[idx].l != 0ll) print_tree_rec(tree, tree[idx].l);\n    if (tree[idx].r != 0ll) print_tree_rec(tree, tree[idx].r);\n    cout << idx << \" \";\n}\n\nvoid print_tree_pos(Node* tree)\n{\n    auto idx = tree->l;\n    if (tree[idx].l != 0ll) print_tree_rec(tree, tree[idx].l);\n    if (tree[idx].r != 0ll) print_tree_rec(tree, tree[idx].r);\n    cout << idx << endl;\n}\n\nint main()\n{\n    auto n = 0ll;\n    cin >> n;\n\n    auto pre = new llong[n];\n    for (auto i = 0ll; i < n; i++)\n    {\n        cin >> pre[i];\n    }\n\n    auto in = new llong[n];\n    for (auto i = 0ll; i < n; i++)\n    {\n        cin >> in[i];\n    }\n\n    auto tree = new Node[n + 1];\n    for (auto i = 0ll; i < n + 1ll; i++)\n    {\n        tree[i].p = 0ll;\n        tree[i].l = 0ll;\n        tree[i].r = 0ll;\n    }\n\n    auto pre_visit_idx = 0ll;\n    auto pre_pre_index = -1ll;\n    for (auto i = 0ll; i < n; i++)\n    {\n        auto pre_idx = 0ll;\n        for (; pre[pre_idx] != in[i]; pre_idx++) {}\n        auto pre_visit_idx_fst = pre_visit_idx;\n        for (auto j = pre_visit_idx; j <= pre_idx; j++, pre_visit_idx++)\n        {\n            if (j != pre_visit_idx_fst) \n            {\n                tree[pre[j]].p = pre[j - 1];\n                tree[pre[j - 1]].l = pre[j];\n            }\n            else if (j != 0ll)\n            {\n                tree[pre[j]].p = pre[pre_pre_index];\n                tree[pre[pre_pre_index]].r = pre[j];\n            }\n            else\n            {\n                tree[0].l = pre[j];\n            }\n        }\n        pre_pre_index = pre_idx;\n    }\n\n    print_tree_pos(tree);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n    if (l >= r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m+1, r);\n    post.push_back(root);\n}\n\nvoid solve(){\n    pos = 0;\n    rec(0, pre.size());\n    for (int i = 0; i < n; i++)\n    {\n        if(i) cout << \" \";\n        cout << post[i]; \n    }\n    cout << endl;\n}\nint main(){\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        int x;\n        cin >> x;\n        pre.emplace_back(x);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        int x;\n        cin >> x;\n        in.emplace_back(x);\n    }\n    \n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nconst int N = 100;\nint pos, cnt;\nint In[N], Pre[N];\n\nvoid construct_tree(int left, int right) {\n  if (left < right) {\n    int i, root = Pre[pos++];\n    for (i = left; i < right; i++) {\n      if (In[i] == root) break;\n    }\n    // left subtree\n    construct_tree(left, i);\n    // right subtree\n    construct_tree(i+1, right);\n    // print nodes in postorder\n    if (cnt > 0) cout << \" \";\n    cout << root;\n    cnt++;\n  }\n}\n\nint main() {\n  int i, n;\n\n  cin >> n;\n  // input\n  for (i = 0; i < n; i++) cin >> Pre[i];\n  for (i = 0; i < n; i++) cin >> In[i];\n\n  // initialize\n  cnt = 0;\n  pos = 0;\n  // output\n  construct_tree(0, n);\n  cout << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in ,post;\n\nvoid rec(int l, int r) {\n    if(l >= r) return ;\n    int root = pre[pos++];\n    int m = distance(in.begin(),find(in.begin(), in.end(), root));\n    rec(l,m);\n    rec(m+1, r);\n    post.push_back(root);\n}\n\nvoid solve() {\n    pos = 0;\n    rec(0,pre.size());\n    for(int i = 0; i<n; i++) {\n        if(i) cout << \" \";\n        cout << post [i];\n    }\n    cout << endl;\n}\n\nint main() {\n    int k;\n    cin >> n;\n    for (int i = 0; i<n; i++) {\n        cin >> k;\n        pre.push_back(k);\n    }\n    for(int i = 0; i<n; i++) {\n        cin >> k;\n        in.push_back(k);\n    }\n    \n    solve();\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n \nstruct node{\n    int l,r;\n};\nnode v[41];\nvector<int> postord;\nvoid dfs(int vi){\n    if(v[vi].l!=0)dfs(v[vi].l);\n    if(v[vi].r!=0)dfs(v[vi].r);\n    postord.pb(vi);\n}\nint pre[41],in[41];\nint main(){\n    int n,root;\n    cin>>n;\n    rep(i,n) cin>>pre[i];\n    rep(i,n) cin>>in[i];\n    rep(i,41) v[i].l=v[i].r=0;\n    root=pre[0];\n    int cp=0,ci=0;\n    while(cp<n-1){\n        v[pre[cp]].l=pre[cp+1];++cp;\n        while(cp<n&&pre[cp]==in[ci]){\n            ++ci;\n            while(ci<n-1&&v[in[ci]].l==in[ci+1]) ++ci;\n            if(ci>=n-1) break;\n            v[in[ci]].r=in[ci+1];++ci;\n            ++cp;\n        } \n    }\n    dfs(root);\n    rep(i,n) cout<<postord[i]<<(i==n-1?\"\":\" \");\n    cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace  std;\n\nvoid fnInput(vector<int> &rvnPodr, vector<int> &rvnIodrSeq)\n{\n  int nMaxSiz;\n\n  cin >> nMaxSiz;\n  rvnPodr.resize(nMaxSiz);\n  rvnIodrSeq.resize(nMaxSiz + 1);\n\n  for (int i = 0; i < nMaxSiz; i++)\n    cin >> rvnPodr[i];\n\n  int nNode;\n  for (int i = 1; i < nMaxSiz + 1; i++)\n  {\n    cin >> nNode;\n    rvnIodrSeq[nNode] = i;\n  }\n}\n\nvoid fnPostOrder(const vector<int> &cnrvnPodr, const vector<int> &cnrvnIodrSeq, int nLeft, int nRight)\n{\n  static int stnx = 0;\n  static int stnPrt = 0;\n\n  if (nLeft == nRight) return;\n\n  int nNode = cnrvnPodr[stnx++];\n  int nMid = cnrvnIodrSeq[nNode];\n\n  fnPostOrder(cnrvnPodr, cnrvnIodrSeq, nLeft, nMid);\n  fnPostOrder(cnrvnPodr, cnrvnIodrSeq, nMid + 1, nRight);\n\n  if (stnPrt++) cout << \" \";\n  cout << nNode;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vector<int> vnPodr, vnIodrSeq;\n  fnInput(vnPodr, vnIodrSeq);\n\n  fnPostOrder(vnPodr, vnIodrSeq, 0, vnPodr.size());\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <iterator>\n#include <vector>\n\nusing namespace std;\n\nvector<int> pre, in, post;\n\nint pos = 0;\n\nvoid constructPost(int l, int r) {\n\tif (l >= r)\n\t\treturn;\n\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\tconstructPost(l, m);\n\tconstructPost(m + 1, r);\n\n\tpost.push_back(root);\n}\n\nint main() {\n\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint v;\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &v);\n\t\tpre.push_back(v);\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &v);\n\t\tin.push_back(v);\n\t}\n\n\n\tconstructPost(0, pre.size());\n\n\tint i = 0;\n\tfor (auto itr = post.begin(); itr != post.end(); ++itr) {\n\t\tif (i)\n\t\t\tcout << \" \";\n\t\tcout << *itr;\n\t}\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAX 102\n#define NIL -1\nint n, pos = 0;\nint Pre[MAX], In[MAX];\n\nvector<int> Post;\n\nint find(int id){\n    for(int i=0;i<n;++i){\n        if(In[i]==id) return i;\n    }\n}\n\nvoid rebuild(int l, int r){\n    if(l>=r) return;\n    int id = Pre[pos];\n    pos++;\n    int m = find(id);\n    rebuild(l,m);\n    rebuild(m+1,r);\n    Post.push_back(id);\n}\n\nint main(){\n\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;++i){\n        scanf(\"%d\",&Pre[i]);\n    }\n    for(int i=0;i<n;++i){\n        scanf(\"%d\",&In[i]);\n    }\n    rebuild(0,n);\n    vector<int>::iterator it;\n    for(it=Post.begin();it!=Post.end()-1;++it){\n        printf(\"%d \",*it);\n    }\n    printf(\"%d\\n\",*it);\n\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define N 40\n\nvector<int> a, b, c;\n\nvoid postOrder(vector<int>::iterator a1, vector<int>::iterator a2, vector<int>::iterator b1, vector<int>::iterator b2)\n{\n    //printf(\"%d %d %d %d\\n\", *a1, *(a2 - 1), *b1, *(b2 - 1));\n    vector<int>::iterator itr;\n    c.push_back(*a1);\n    printf(\"%d\\n\", *a1);\n    itr = find(b1, b2, *a1); //itrator of root on inorder tree walk\n    int d = itr - b1;\n    if (a1 + d + 1 < a2 && itr + 1 < b2)\n        postOrder(a1 + d + 1, a2, itr + 1, b2);\n    if (a1 + 1 < a1 + d + 1 && b1 < itr)\n        postOrder(a1 + 1, a1 + d + 1, b1, itr);\n}\n\nint main()\n{\n    int n, x;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> x;\n        a.push_back(x);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        cin >> x;\n        b.push_back(x);\n    }\n\n    postOrder(a.begin(), a.end(), b.begin(), b.end());\n\n    for (int i = 0; i < c.size(); i++)\n    {\n        if (i != 0)\n            cout << \" \";\n        cout << c[c.size() - 1 - i];\n    }\n    cout << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <iterator>\n#include<algorithm>\nstatic const int NIL = -1;\nstatic const int NumberChild = 2;\nclass Tree {\nprivate:\n\tint id;\n\tint parent;\n\tint child[NumberChild];\n\npublic:\n\tTree() {\n\t\tid = child[0] = child[1] = parent = NIL;\n\t}\n\tvoid AddParent(int ID) {\n\t\tparent = ID;\n\t\treturn;\n\t}\n\tvoid AddID(int ID) {\n\t\tid = ID;\n\t\treturn;\n\t}\n\tvoid AddChild(std::vector<int>&Child) {\n\t\tfor (unsigned int i = 0; i < Child.size(); ++i) {\n\t\t\tchild[i] = Child[i];\n\n\t\t}\n\n\t\treturn;\n\t}\n\tint GetRoot(std::vector<Tree> nodes, int ID) {\n\t\tint RootID = ID;\n\t\tif (RootID != NIL&&nodes[RootID].parent != NIL) {\n\t\t\tRootID = GetRoot(nodes, nodes[RootID].parent);\n\t\t}\n\t\treturn RootID;\n\t}\n\tvoid PreorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid InorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid PostorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t\tif(nodes[ID].id!=NIL)std::cout << \" \" << nodes[ID].id;\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid GetVctorPostorderTreeWalk(std::vector<Tree> nodes, std::vector<int>& returnvector, int ID) {\n\t\t\n\t\tif (ID != NIL) {\n\n\t\t\tGetVctorPostorderTreeWalk(nodes,  returnvector, nodes[ID].child[0]);\n\t\t\tGetVctorPostorderTreeWalk(nodes, returnvector, nodes[ID].child[1]);\n\t\t\tif (nodes[ID].id != NIL)returnvector.push_back(nodes[ID].id) ;\n\t\t}\n\n\t\treturn ;\n\t}\n\tvoid Reconstruct(const std::vector<int>Pre, const std::vector<int>In, std::vector<Tree> &nodes, const int Root, int &cnt) {\n\n\t\tunsigned int m = std::distance(In.begin(), std::find(In.begin(), In.end(), Root));\n\n\t\t//nodes[cnt].AddID(Root);\n\t\tif ( Root == NIL) { return; }\n\t\tnodes[Root].AddID(Root);\n\t\tif ( m ==0 ) { return; }\n\t\tstd::vector<int>PreLeft;\n\n\t\tstd::copy(&Pre[1], &Pre[m] + 1, std::back_inserter(PreLeft));\n\n\n\n\n\t\tstd::vector<int>InLeft;\n\t\tstd::vector<int>PreRight{NIL\n\t};\n\t\tstd::vector<int> InRight{NIL};\n\t\tstd::copy(&In[0], &In[m-1]+1, std::back_inserter(InLeft));\n\t\t\n\t\tif (m<Pre.size()-1){\n\t\t\tstd::copy(&Pre[m] + 1, &Pre[Pre.size() - 1] + 1, std::back_inserter(PreRight));\n\t\t}\n\t\tif (m<In.size()-1) {\n\t\t\tstd::copy(&In[m] + 1, &In[In.size() - 1] + 1, std::back_inserter(InRight));\n\t\t\t}\n\t\t\n\t\t\n\t\t\n\n\t\tstd::vector<int> child(2);\n\t\tchild[0] =  PreLeft.empty() ? NIL : PreLeft[0] ;\n\t\tchild[1] = PreRight.empty() ? NIL : PreRight[0] ;\n\t\t//nodes[cnt].AddChild(child);\n\t\tnodes[Root].AddChild(child);\n\t\tfor (unsigned int i = 0; i < child.size(); ++i) {\n\n\t\t\tif (child[i] != NIL) { nodes[child[i]].AddParent(Root); }\n\t\t}\n\t\tReconstruct(PreLeft, InLeft, nodes, PreLeft[0], ++cnt);\n\t\tReconstruct(PreRight, InRight, nodes, PreRight[0], ++cnt);\n\t}\n};\n\nvoid SetVector(std::vector<int>&InputVector) {\n\tfor (unsigned int i = 0; i < InputVector.size(); ++i) {\n\t\tstd::cin >> InputVector[i];\n\t}\n\treturn;\n}\nint main(void) {\n\n\tint n;\n\tstd::cin >> n;\n\tstd::vector<int>Pre(n);\n\tstd::vector<int>In(n);\n\tSetVector(Pre);\n\tSetVector(In);\n\tstd::vector<Tree> nodes(n+1);\n\t//ReconstructWithNoParent\n\tint cnt = 0;\n\tnodes[1].Reconstruct(Pre, In, nodes, Pre[0],cnt);\n\n\t//nodes[1].PostorderTreeWalk(nodes, 1);\n\tstd::vector<int>Print;\n\tnodes[1].GetVctorPostorderTreeWalk(nodes, Print, 1);\n//Print=nodes[1].GetVctorPostorderTreeWalk(nodes, 1);\nfor (unsigned int i = 0; i < Print.size(); ++i) {\n\tif (i) { std::cout << \" \"; }\n\tstd::cout<<Print[i];\n\tif(i==Print.size()-1){ std::cout << std::endl; }\n}\n\t\n\t\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nstd::vector<int> preordered, inordered, postordered;\nint N, pos;\n\nvoid reconstruct(int left, int right) {\n    if (left >= right) return;\n    int root = preordered[pos++];\n    int mid = std::distance(inordered.begin(), std::find(inordered.begin(), inordered.end(), root));\n    reconstruct(left, mid);\n    reconstruct(mid+1, right);\n    postordered.push_back(root);\n}\n\n\nint main() {\n    int tmp;\n    pos = 0;\n    std::scanf(\"%d\", &N);\n    for (int i = 0; i < N; i++) {\n        std::scanf(\"%d\", &tmp);\n        preordered.push_back(tmp);\n    }\n    for (int i = 0; i < N; i++) {\n        std::scanf(\"%d\", &tmp);\n        inordered.push_back(tmp);\n    }\n    reconstruct(0, N);\n    for (unsigned long i = 0; i < N; i++) {\n        if (i) std::printf(\" \");\n        std::printf(\"%d\", postordered[i]);\n    }\n    std::printf(\"\\n\");\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//  Created by conan1024hao on 2019/11/18.\n//  Copyright © 2019 conan1024hao. All rights reserved.\n//  専用ライブラリです、自由にコピーして構いません。\n//  感谢看我的代码！Wechat:conan1024hao QQ:810396815\n#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll>P;\n#define INF 10e16\n#define MOD 1000000007\n#define rep(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define fi first\n#define se second\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define PI acos(-1.0)\nlong long GCD(long long a, long long b) { return b ? GCD(b, a%b) : a; }\nlong long LCM(long long a, long long b)  {return a/GCD(a,b)*b;}\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nll cmp(pair<ll,string>a,pair<ll,string> b){\n        if(a.fi!=b.fi)\n        return a.fi<b.fi;\n        else\n        return a.se<b.se;\n}\n//---------------------------------------------------------------------------\n#define MAX 10000\nstruct Node{int p,l,r;};\nstruct Node T[MAX];\nint a[100],b[100];\nint n;\nint cnt=0;\nvoid postparse(int u){\n    if(T[u].l!=-1)\n        postparse(T[u].l);\n    if(T[u].r!=-1)\n        postparse(T[u].r);\n    if(cnt<n-1)\n        printf(\"%d \",u);\n    else\n        printf(\"%d\\n\",u);\n    cnt++;\n    \n}\nvoid reconstruction(int c,int in){\n    if(c==in){\n        cout<<\"error\"<<endl;\n        return;\n    }\n    int cnt1=0,cnt2=0;\n    \n    for(int i=1;i<=n;i++){\n        if(c==b[i])\n            cnt1=i;\n        if(in==b[i])\n            cnt2=i;\n    }\n    if(cnt1<cnt2&&T[in].l==-1){\n        T[in].l=c;\n        T[c].p=in;\n    }\n    else if(cnt1>cnt2&&T[in].r==-1){\n        T[in].r=c;\n        T[c].p=in;\n    }\n    else if(cnt1<cnt2&&T[in].l!=-1)\n        reconstruction(c,T[in].l);\n    else if(cnt1>cnt2&&T[in].r!=-1)\n        reconstruction(c,T[in].r);\n    return;\n}\n//---------------------------------------------------------------------------\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------\n    cin>>n;\n    for(int i=1;i<=n;i++)\n        cin>>a[i];\n    for(int i=1;i<=n;i++)\n        cin>>b[i];\n    for(int i=1;i<=n;i++){\n        T[i].p=-1;\n        T[i].l=-1;\n        T[i].r=-1;\n    }\n    if(n==1){\n        cout<<a[1]<<endl;\n        return 0;\n    }\n    int root=a[1];\n    T[a[2]].p=a[1];\n    //T[b[1]].p=b[2];\n    //T[b[2]].l=b[1];\n    for(int i=2;i<=n;i++){\n            reconstruction(a[i],root);\n    }\n    postparse(root);\n    \n    //-------------------------------\n    return 0;\n}\n//---------------------------------------------------------------------------\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\n\nint j=0,k=0;\nvector<int> in,pre;\n\nint search(int n)\n{\n\tint i=0;\n\twhile(in[i]!=n)\n\t{\n\t\ti++;\n\t}\n\treturn i;\n}\n\nvoid rec(int l,int r)\n{\n\tint c,m;\n\tif(l>r) return;\n\tif(l==r)\n\t{\n\t\tif(++k>1) printf(\" \");\n\t\tprintf(\"%d\",in[l]);\n\t\treturn;\n\t}\n\tc=pre[j];\n\tj++;\n\tm=search(c);\n\trec(l,m-1);\n\trec(m+1,r);\n\tif(++k>1) printf(\" \");\n\tprintf(\"%d\",in[m]);\n\treturn;\n}\n\nint main()\n{\n\tint i,n,temp;\n\t\n\tcin >> n;\n\t\n\tfor(i=0;i<=n-1;i++)\n\t{\n\t\tcin >> temp;\n\t\tpre.push_back(temp);\n\t}\n\tfor(i=0;i<=n-1;i++)\n\t{\n\t\tcin >> temp;\n\t\tin.push_back(temp);\n\t}\n\trec(0,n-1);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n  \nint n,pos;\nvector<int> pre,in,post;\n  \nvoid rec(int l,int r){\n    if(l>=r)\n        return;\n    int root = pre[pos++];\n    int m = distance(in.begin(),find(in.begin(),in.end(),root));\n    rec(l,m);\n    rec(m+1,r);\n    post.push_back(root);\n}\n  \nvoid solve(){\n    pos = 0;\n    rec(0,pre.size());\n    for(int i=0;i<n;i++){\n        if(i)\n            cout<<\" \";\n        cout<<post[i];\n    }\n    cout<<endl;\n}\n  \nint main(){\n    int k;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>k;\n        pre.push_back(k);\n    }\n  \n    for(int i=0;i<n;i++){\n        cin>>k;\n        in.push_back(k);\n    }\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int left, int right)\n{\n  if (left >= right)\n  {\n    return;\n  }\n\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(left, m);\n  rec(m + 1, right);\n  post.push_back(root);\n}\n\nvoid solve()\n{\n  pos = 0;\n  rec(0, pre.size());\n  for (int i = 0; i < n; i++)\n  {\n    if (i)\n    {\n      cout << \" \";\n    }\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main()\n{\n  int c;\n  cin >> n;\n  for (int i = 0; i < n; i++)\n  {\n    cin >> c;\n    pre.push_back(c);\n  }\n  for (int i = 0; i < n; i++)\n  {\n    cin >> c;\n    in.push_back(c);\n  }\n\n  solve();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define eol '\\n';\nusing namespace std;\n\nclass Node {\npublic:\n  int id;\n  int l;\n  int r;\n  int p;\n  Node(): id(-1),l(-1),r(-1),p(-1){};\n};\n\nNode* tree;\n\nint create_tree(int parent, vector<int> pre, vector<int> in) {\n    if (pre.size() == 0 && in.size() == 0) {\n      return -1;\n    }\n\n    int root_id = pre[0];\n\n    Node* node = &tree[root_id];\n    node->p = parent;\n    \n    // left\n    vector<int> left_pre(0);\n    vector<int> left_in(0);\n\n    int i = 0;\n    int size = in.size();\n    for (; i < size; i++) {\n      if (in[i] == root_id) {\n        break;\n      }\n      left_pre.push_back(pre[i+1]);\n      left_in.push_back(in[i]);\n    }\n    node->l = create_tree(root_id, left_pre, left_in);\n\n    vector<int> right_pre(0);\n    vector<int> right_in(0);\n\n    i++;\n    for (;i < size; i++) {\n      right_pre.push_back(pre[i]);\n      right_in.push_back(in[i]);\n    }\n    node->r = create_tree(root_id, right_pre, right_in);\n\n    return root_id;\n}\n\nvector<int> postorder(int id, vector<int> post) {\n  Node* node = &tree[id];\n  if (node->l != -1) {\n    post = postorder(node->l, post);\n  }\n  if (node->r != -1) {\n    post = postorder(node->r, post);\n  }\n  post.push_back(id);\n\n  return post;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  \n  int n,i;\n  cin >> n;\n\n  tree = new Node[n];\n\n  vector<int> preorder(n);\n  vector<int> inorder(n);\n\n  for (i = 0; i < n; i++) {\n    cin >> preorder[i];\n  }\n  for (i = 0; i < n; i++) {\n    cin >> inorder[i];\n  }\n\n  int root = create_tree(-1, preorder, inorder);\n\n  // post order\n  vector<int> post;\n  post = postorder(root, post);\n\n  // output\n  cout << post[0];\n  for (i = 1; i < n; i++) {\n    cout << \" \" << post[i];\n  }\n  cout << eol;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nvector<int > pre,inorder,post;\nint pos;\nvoid rec(int l,int r){\n    if(l>=r)return;\n    int root = pre[pos++];\n    int m = distance(inorder.begin(),find(inorder.begin(),inorder.end(),root));\n    rec(l,m);\n    rec(m+1,r);\n    post.push_back(root);\n}\nint main(){\n    int n,k;\n    pos=0;\n    cin>>n;\n    for(int i=0;i<n;i++)\n    {\n        cin>>k;\n        pre.push_back(k);\n    }\n    for(int i=0;i<n;i++)\n    {\n        cin>>k;\n        inorder.push_back(k);\n    }\n    rec(0,n);\n    int isn=0;\n    for(int i=0;i<n;i++)\n    {\n        if(isn++>0)\n            cout<<' ';\n        cout<<post[i];\n    }\n    cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, ino, post;\n\nvoid rec(int l, int r) {\n    if (l>=r) return;\n    int root = pre[pos++];\n    int m = distance(ino.begin(), find(ino.begin(), ino.end(), root));\n    rec(1, m);\n    rec(m+1, r);\n    post.push_back(root);\n}\n\nvoid solve() {\n    pos = 0;\n    rec(0, pre.size());\n    for (int i=0; i<n; i++) {\n        if(i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main() {\n    int k;\n    cin >> n;\n    \n    for (int i=0; i<n; i++) {\n        cin >> k;\n        pre.push_back(k);\n    }\n    \n    for (int i=0; i<n; i++) {\n        cin >> k;\n        ino.push_back(k);\n    }\n    \n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,m=0,a[40],b[40],c[41];\nvoid solve(int l,int r){\n  if(l>r)return;\n  int x=a[m++];\n  solve(l,c[x]-1);\n  solve(c[x]+1,r);\n  cout<<x<<(x==a[0]?\"\\n\":\" \");\n}\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>a[i];\n  for(int i=0;i<n;i++)cin>>b[i],c[b[i]]=i;\n  solve(0,n-1);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\nusing namespace std;\n\nvector<int> ans;\nint pre[40];\nint in[40];\nint N;\n\nstruct Node {\n\tint left;\n\tint right;\n};\n\nvoid solve(int begin, int end, int& j) {\n\tint mid;\n\tfor (int i = begin; i < end; i++) {\n\t\tif (in[i] == pre[j]) {\n\t\t\tmid = i;\n\t\t}\n\t}\n\n\tif(begin != mid)solve(begin, mid, ++j);\n\tif(mid + 1 != end)solve(mid + 1, end, ++j);\n\tans.push_back(in[mid]);\n}\n\nint main() {\n\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> pre[i];\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> in[i];\n\t}\n\n\tint j = 0;\n\tsolve(0, N, j);\n\t\n\tfor (int i = 0; i < N; i++) {\n\t\tcout << ans[i];\n\t\tif (i < N - 1)cout << \" \";\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nvector<int>pre,in,post;\n\nint n;\nint pos;\nvoid rec(int l,int r){\n    if(l>=r) return;\n    int root=pre[pos++];\n    vector<int>::iterator dist=find(in.begin(),in.end(),root);\n    int m=distance(in.begin(),dist);\n    rec(l,m);\n    rec(m+1,r);\n    post.push_back(root);\n}\n\n\nvoid solve(){\n    pos=0;\n    rec(0,pre.size());\n    for(int i=0;i<n;i++){\n        if(i) cout<<\" \";\n        cout<<post[i];\n    }\n\n    cout<<endl;\n}\n\nint main(){\n   // freopen(\"data.in\",\"r\",stdin);\n    cin>>n;\n    int k;\n    for(int i=0;i<n;i++) {\n        cin>>k;\n        pre.push_back(k);\n    }\n    for( int i=0;i<n;i++){\n        cin>>k;\n        in.push_back(k);\n    }\n\n\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n \nint n, pos;\nvector<int>pre, in, post;\n \nvoid rec(int l, int r) {\n    if (l >= r)return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m + 1, r);\n    post.push_back(root);\n}\n \nvoid solve() {\n    pos = 0;\n    rec(0, pre.size());\n    for(int i = 0; i < n; i++) {\n        if (i)cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n \nint main() {\n    int k;\n    cin >> n;\n     \n    for (int i = 0; i < n; i++) {\n        cin >> k;\n        pre.push_back(k);\n    }\n \n    for (int i = 0; i < n; i++) {\n        cin >> k;\n        in.push_back(k);\n    }\n \n    solve();\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace  std;\n\nconst int END = -1;\nstruct StNod\n{\n  int m_nParnt;\n  int m_nLeft;\n  int m_nRigt;\n\n  StNod() :\n     m_nParnt(END), m_nLeft(END), m_nRigt(END)\n  { }\n};\n\nvoid fnInput(vector<int> &rvnPodr, vector<int> &rvnIodrSeq)\n{\n  int nMaxSiz;\n\n  cin >> nMaxSiz;\n  rvnPodr.resize(nMaxSiz);\n  rvnIodrSeq.resize(nMaxSiz);\n\n  for (int i = 0; i < nMaxSiz; i++)\n    cin >> rvnPodr[i];\n\n  int nNode;\n  for (int i = 0; i < nMaxSiz; i++)\n  {\n    cin >> nNode;\n    rvnIodrSeq[nNode] = i;\n  }\n}\n\nvoid fnPostOrder(const vector<int> &cnrvnPodr, const vector<int> &cnrvnIodrSeq, int nLeft, int nRight)\n{\n  static int stnx = 0;\n\n  if (nLeft == nRight) return;\n\n  int nNode = cnrvnPodr[stnx++];\n  int nMid = cnrvnIodrSeq[nNode];\n\n  fnPostOrder(cnrvnPodr, cnrvnIodrSeq, nLeft, nMid);\n  fnPostOrder(cnrvnPodr, cnrvnIodrSeq, nMid + 1, nRight);\n\n  if (nNode != cnrvnIodrSeq[1]) cout << \" \";\n  cout << nNode;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vector<int> vnPodr, vnIodrSeq;\n  fnInput(vnPodr, vnIodrSeq);\n\n  fnPostOrder(vnPodr, vnIodrSeq, 0, vnPodr.size());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n  if(l >= r) return;\n     int root = pre[pos++];\n     int m = distance(in.begin(), find(in.begin(), in.end(), root));\n     rec(l,m);\n     rec(m + 1,r);\n     post.push_back(root);\n}\n\nvoid solve(){\n  pos = 0;\n  rec(0, pre.size());\n  for(int i = ; i < n ; i++){\n    if(i) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main(){\n  int k;\n  cin >> n;\n\n  for(int i = 0 ; i < n ; i++){\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for(int i = 0 ; i < n ; i++){\n    cin >> k;\n    in.push_back(k);\n  }\n\n  solve();\n\n  return 0;\n}\n     \n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define si static inline\n#define gcu getchar_unlocked\nsi int in() {\n\tint c, n = 0;\n\tbool minus = false;\n\tif ((c = gcu()) == '-') minus = true;\n\telse ungetc(c, stdin);\n\twhile ((c = gcu()) >= '0' && c <= '9') n = 10 * n + (c - '0');\n\treturn minus ? -n : n; }\n#define pcu putchar_unlocked\n#define svo si void out\nsvo(int n) {\n\tstatic char buf[20];\n\tchar *p = buf;\n\tbool minus = false;\n\tif(n < 0) minus = true, n *= -1;\n\tif (!n) *p++ = '0';\n\telse while (n) *p++ = n % 10 + '0', n /= 10;\n\tif (minus) *p++ = '-';\n\twhile (p != buf) pcu(*--p); }\nsvo(const char *s){while(*s)pcu(*s++);}\nsvo(char c){pcu(c);}\ntemplate <typename head, typename... tail>\nsvo(head&& h, tail&&... t){out(h);out(move(t)...);}\n\ntypedef vector<int> v;\ntypedef v::iterator vi;\nbool first = true;\nvoid walk(vi &b, vi l, vi r)\n{\n\tvi c = find(l, r, *b);\n\tif (c == r)\n\t\treturn;\n\tb++;\n\twalk(b, l, c);\n\twalk(b, c + 1, r);\n\tout(first ? first = false, \"\" : \" \", *c);\n}\n\nint main()\n{\n\tint n = in();\n\tv p(n), i(n);\n\tfor (int &x: p) x = in();\n\tfor (int &x: i) x = in();\n\n\tvi b = p.begin();\n\twalk(b, i.begin(), i.end());\n\tout('\\n');\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n \nstruct node{\n    int l,r;\n};\nnode v[41];\nvector<int> postord;\nvoid dfs(int vi){\n    if(v[vi].l!=-1)dfs(v[vi].l);\n    if(v[vi].r!=-1)dfs(v[vi].r);\n    postord.pb(vi);\n}\nint pre[41],in[41];\nint main(){\n    int n,root;\n    cin>>n;\n    rep(i,n) cin>>pre[i];\n    rep(i,n) cin>>in[i];\n    rep(i,41) v[i].l=v[i].r=-1;\n    root=pre[0];\n    int cp=0,ci=0;\n    while(cp<n-1&&pre[cp]>0){\n        v[pre[cp]].l=pre[cp+1];++cp;\n        while(cp<n&&pre[cp]==in[ci]){\n            ++ci;\n            while(ci<n-1&&in[ci]>0&&v[in[ci]].l==in[ci+1]) ++ci;\n            if(ci>=n-1){\n                ++cp;break;\n            }\n            v[in[ci]].r=in[ci+1];++ci;\n            ++cp;\n        } \n    }\n    dfs(root);\n    rep(i,n) cout<<postord[i]<<(i==n-1?\"\":\" \");\n    cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Node {\n  int id;\n  int parent;\n  int left;\n  int right;\n\n  Node() : id(), parent(-1), left(-1), right(-1) {}\n  };\n\nstatic vector<Node> TREE(25);\n\nstatic void inputNode(Node& node, int id) {\n  node.id = id;\n  cin >> node.left >> node.right;\n}\n\nstatic vector<int> preorder(25), inorder(25);\n\nstatic void inputOrder(vector<int>& order, int num) {\n  for (int i = 0; i < num; i++) {\n    cin >> order[i];\n  }\n}\n\nstatic int current = 0, outIndex = 0;\n\nstatic int next() {\n  int c = preorder[current];\n  current++;\n  return c;\n}\n\nstatic int find(int c) {\n  auto it = find(inorder.begin(), inorder.end(), c); \n  return distance(inorder.begin(), it);\n}\n\nstatic void reconstruction(int l, int r) {\n  if (l >= r) {\n    return;\n  } \n  int c = next();\n  int m = find(c);\n  reconstruction(l, m);\n  reconstruction(m + 1, r);\n\n  if (outIndex != 0) {\n    cout << \" \" << c;\n  } else {\n    cout << c;\n  }\n  outIndex++;\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  inputOrder(preorder, n);\n  inputOrder(inorder, n);\n  reconstruction(0, n);\n\n  cout << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\nstruct node{\n    int parent;\n    int l;\n    int r;\n    int val;\n    int real;\n};\nstruct tree{\n    vector<node>map;\n    bool first;\n    int root;\n    void insert(int n,int now){\n        if(map[n].val>map[now].val){\n            map[n].parent=now;\n            map[now].r=n;\n        }\n        else{\n            if(now==root){\n                root=n;\n                map[n].l=now;\n                map[now].parent=n;\n            }\n            else{\n                insert(n,map[now].parent);\n                if(map[map[now].parent].r!=now){\n                    map[now].parent=n;\n                    map[n].l=now;\n                }\n            }\n        }\n        return ;\n    }\n    void postorder(int n){\n        if(n==-1)return ;\n        postorder(map[n].l);\n        postorder(map[n].r);\n        if(first)printf(\" \");\n        else first=true;\n        printf(\"%d\",map[n].real);\n        return ;\n    }\n};\nnode int_to_node(int n,int a){\n    node temp;\n    temp.val=a;\n    temp.real=n;\n    temp.l=temp.r=temp.parent=-1;\n    return temp;\n}\nint main(){\n    int n,a[100],temp;\n    tree t;\n    t.first=false;\n    t.root=0;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%d\",&temp);\n        a[temp]=i;\n    }\n    scanf(\"%d\",&temp);\n    t.map.push_back(int_to_node(temp,a[temp]));\n    for(int i=1;i<n;i++){\n        scanf(\"%d\",&temp);\n        t.map.push_back(int_to_node(temp,a[temp]));\n        t.insert(i,i-1);\n    }\n    t.postorder(t.root);\n    printf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <queue>\n#include <map>\n#include <list>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <climits>\nusing namespace std;\n\nstruct node {\n\tint id, parent, left, right;\n};\n\nint reconstruct(queue<node> &nodes, queue<int> &pre, queue<int> &in, int parent){\n\tif(!in.size()) return -1;\n\t\n\tnode n;\n\tn.parent = parent;\n\tn.id = pre.front();\n\tpre.pop();\n\t\n\tbool toA = true;\n\tqueue<int> inA, inB;\n\twhile(in.size()){\n\t\tif(in.front() == n.id){\n\t\t\tin.pop();\n\t\t\ttoA = false;\n\t\t\tcontinue;\n\t\t}\n\t\t(toA ? inA : inB).push(in.front());\n\t\tin.pop();\n\t}\n\t\n\tn.left = reconstruct(nodes, pre, inA, n.id);\n\tn.right = reconstruct(nodes, pre, inB, n.id);\n\t\n\tnodes.push(n);\n\treturn n.id;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\t\n\tqueue<int> pre;\n\tfor(int i = 0; i < n; i++){\n\t\tint num;\n\t\tscanf(\"%d\", &num);\n\t\tpre.push(num);\n\t}\n\t\n\tqueue<int> in;\n\tfor(int i = 0; i < n; i++){\n\t\tint num;\n\t\tscanf(\"%d\", &num);\n\t\tin.push(num);\n\t}\n\t\n\tqueue<node> nodes;\n\treconstruct(nodes, pre, in, -1);\n\t\n\twhile(nodes.size()){\n\t\tprintf(\"%d%c\", nodes.front().id, nodes.size() == 1 ? '\\n' : ' ');\n\t\tnodes.pop();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n\tif (l >= r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\nvoid solve() {\n\tpos = 0;\n\trec(0, pre.size());\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i) cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tint k;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nvector<int> L;\n\nstruct Vertex{\n\tint left;\n\tint right;\n};\n\nvoid Postorder(vector<Vertex> &T,int root){\n\tif(T[root].left!=-1) Postorder(T,T[root].left);\n\tif(T[root].right!=-1) Postorder(T,T[root].right);\n\tL.push_back(root+1);\n\treturn;\n}\n\nvoid Reconstruction(vector<Vertex> &T, vector<int> &Pre,vector<int> &In,int p,int q,int s,int t){\n\tint root = Pre[p];\n\tif(p==q){\n\t\tT[root].left=-1;\n\t\tT[root].right=-1;\n\t\treturn ;\n\t}\n\t\n\tvector<bool> check(1000000,false);\n\t\n\t//k???In????????????root?????????????????????\n\tint k=-1;\n\tfor(int i=s;i<t+1;i++){\n\t\tcheck[In[i]]=true;\n\t\tif (In[i]==root){\n\t\t\tk=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t//l???Pre?????????????????´?????¨???????????????????????????????????????\n\tint l=p;\n\twhile(l<q){\n\t\tl++;\n\t\tif(l==q) break;\n\t\tif(check[Pre[l]]=false){\n\t\t\tl--;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif(s==k){\n\t\tT[root].left=-1;\n\t\tT[root].right=Pre[l+1];\n\t\n\t\tReconstruction(T,Pre,In,l+1,q,k+1,t);\n\t}else if(t==k){\n\t\tT[root].left=Pre[p+1];\n\t\tT[root].right=-1;\n\t\n\t\tReconstruction(T,Pre,In,p+1,l,s,k-1);\n\t}else{\n\t\tT[root].left=Pre[p+1];\n\t\tT[root].right=Pre[l+1];\n\t\n\t\tReconstruction(T,Pre,In,p+1,l,s,k-1);\n\t\tReconstruction(T,Pre,In,l+1,q,k+1,t);\n\t}\n}\n\nint main(){\n\tint n,x;\n\tcin >> n;\n\tvector<int> Pre(n);\n\tvector<int> In(n);\n\tfor (int i=0;i<n;i++){\n\t\tcin >> x;\n\t\tPre[i]=x-1;\n\t}\n\t\n\tfor (int i=0;i<n;i++){\n\t\tcin >> x;\n\t\tIn[i]=x-1;\n\t}\n\t\n\tvector<Vertex> T(n);\n\tReconstruction(T,Pre,In,0,n-1,0,n-1);\n\tPostorder(T,Pre[0]);\n\t\n\tfor (int i=0;i<L.size();i++){\n\t\tif(i==L.size()-1){\n\t\t\tcout << L[i] <<endl;\n\t\t}else{\n\t\t\tcout << L[i] <<\" \";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <climits>\n#include <cstring>\n#define rep(i, begin, end) for (__typeof(end) i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))\n\nusing namespace std;\n\nconst int N_MAX = 1000000;\nstring ans = \"\";\n/*\n pre: 4 2 3 1 5\n in:  3 2 4 5 1\n\n*/\nstruct Node{\n  int data;\n  Node* left;\n  Node* right;\n};\n\nvoid postorder(Node* root){\n  if(root == NULL) return;\n  postorder(root->left);\n  postorder(root->right);\n  //cout << root->data << \" \";\n  ans += (to_string(root->data) + \" \");\n}\n\n\nvoid print_array(int* arr, int len){\n  rep(i, 0, len){\n    cout << arr[i];\n    if(i==len-1) cout << endl;\n    else cout << \" \";\n  }\n}\n\nNode* solve(int* inorder, int* preorder, int len){\n  // cout << \"inorder: \" << endl;\n  // print_array(inorder, len);\n  \n  // cout << \"preorder: \" << endl;\n  // print_array(preorder, len);\n  // find root\n  int root_data = preorder[0];\n  Node* root_node = new Node;\n  root_node->data = root_data;\n  if(len==1) return root_node;\n  \n  // count all the num left\n  int left_num=0;\n  while(inorder[left_num] != root_data) left_num++;\n  int right_num = len - left_num - 1;\n  \n  int* left_inorder = new int[left_num];\n  int* right_inorder = new int[right_num];\n  \n  int* left_preorder = new int[left_num];\n  int* right_preorder = new int[right_num];\n\n  int ix=0;\n  int l_ix=0, r_ix=0;\n\n  rep(ix, 0, len){\n    if(inorder[ix] == root_data) continue;\n    if(l_ix<left_num){\n      left_inorder[l_ix] = inorder[ix];\n      l_ix++;\n    }\n    else if(r_ix<right_num){\n      right_inorder[r_ix] = inorder[ix];\n      r_ix++;\n    }\n  }\n  \n  ix = 0; l_ix = 0; r_ix = 0;\n  \n  rep(ix, 1, len){\n    if(l_ix < left_num){\n      left_preorder[l_ix] = preorder[ix];\n      l_ix++;\n    }\n    else if(r_ix < right_num){\n      right_preorder[r_ix] = preorder[ix];\n      r_ix++;\n    }\n  }\n\n  if(left_num>0) root_node->left = solve(left_inorder, left_preorder, left_num);\n  if(right_num>0) root_node->right = solve(right_inorder, right_preorder, right_num);  \n  \n  delete[] left_inorder;\n  delete[] right_inorder;\n\n  return root_node;\n  \n}\n\nint main(){\n  int n; cin >> n;\n\n  int* inorder = new int[n];\n  int* preorder = new int[n];\n  \n  int tmp;\n  rep(i, 0, n){\n    cin >> tmp;\n    preorder[i] = tmp;\n  }\n  rep(i, 0, n){\n    cin >> tmp;\n    inorder[i] = tmp;\n  }\n  Node* root = solve(inorder, preorder, n);\n  postorder(root);\n  rep(i, 0, 2*n-1) cout << ans[i]; \n  cout << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n\nusing namespace std;\n\ntypedef struct tree {\n\tint item;\n\ttree* right = NULL;\n\ttree* left = NULL;\n}tree;\n\nint n;\nint k = 0;\nint a[101];\nint b[101];\n\nvoid print(tree* p) {\n\tif (p->left != NULL) {\n\t\tprint(p->left);\n\t}\n\tif (p->right != NULL) {\n\t\t//cout << ' ';\n\t\tprint(p->right);\n\t}\n\tcout << p->item << ' ';\n}\n\nvoid rebuild(int root, int begin, int left, tree * p) {\n\tp->item = b[root];\n\tk++;\n\t\n\tif(root != begin)\n\t\tfor (int i = begin; i < root; ++i) {\n\t\t\tif (a[k] == b[i]) {\n\n\t\t\t\tp->left = new tree();\n\t\t\t\trebuild(i, begin, root - 1, p->left);\n\t\t\t}\n\t\t}\n\tif(root != left)\n\t\tfor (int i = root+1; i < left+1; ++i) {\n\t\t\tif (a[k] == b[i]) {\n\t\t\t\tp->right = new tree();\n\t\t\t\trebuild(i, root+1, left, p->right);\n\t\t\t}\n\t\t}\n}\n\nint main() {\n\tcin >> n;\n\ttree trees;\n\ttree* p1 = &trees;\n\tstack<tree> T;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> b[i];\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (b[i] == a[0]) {\n\t\t\trebuild(i, 0, n - 1, p1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tp1 = &trees;\n\tif (p1->left != NULL) {\n\t\tprint(p1->left);\n\t}\n\tif (p1->right != NULL) {\n\t\t//cout << ' ';\n\t\tprint(p1->right);\n\t}\n\tcout << p1->item<<endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int NIL = -1;\n\nvoid reconstruct(vector<int>& preorder, vector<int>& inorder, int l, int r, int& pre, vector<int>& postorder)\n{\n    if (r - l <= 0) {\n        return;\n    }\n    int m = distance(inorder.begin(), find(inorder.begin(), inorder.end(), preorder[pre++]));\n    reconstruct(preorder, inorder, l, m, pre, postorder);\n    reconstruct(preorder, inorder, m + 1, r, pre, postorder);\n    postorder.push_back(inorder[m]);\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<int> preorder(n);\n    vector<int> inorder(n);\n    for (int i = 0; i < n; i++) {\n        cin >> preorder[i];\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> inorder[i];\n    }\n    vector<int> postorder;\n    int pre = 0;\n    reconstruct(preorder, inorder, 0, inorder.size(), pre, postorder);\n\n    for (int i = 0; i < postorder.size(); i++) {\n        if (i > 0) {\n            cout << \" \";\n        }\n        cout << postorder[i];\n    }\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint pre[40], in[40], post[40];\nint pos = 0, n, p = 0;\nvoid rec(int left,int right) {\n  if (left < right) {\n    int root = pre[pos++], i;\n    for (i = 0; root != in[i]; ++i);\n    rec(left, i);\n    rec(i + 1, right);\n    post[p++] = root;\n  }\n}\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; ++i) cin >> pre[i];\n  for (int i = 0; i < n; ++i) cin >> in[i];\n  rec(0,n);\n  for (int i = 0; i < n; ++i) {\n    if (i) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <unordered_set>\n\n#define REP(i, n) for(decltype(n) i = 0; i < (n); i++)\n#define REP2(i, x, n) for(decltype(x) i = (x); i < (n); i++)\n#define REP3(i, x, n) for(decltype(x) i = (x); i <= (n); i++)\n#define RREP(i, n) for (decltype(n) i = (n) - 1;i >= 0; i--)\n\n#define ALL(a) (a).begin(),(a).end()\n#define SORT(c) sort((c).begin(),(c).end())\n#define DESCSORT(c) sort(c.begin(), c.end(), greater<int>())\n\n#define LL long long int\n#define LD long double\n\n#define INF 1000000000\n#define PI 3.14159265358979323846\n\n#define _CRT_SECURE_NO_WARNINGS\n\nusing namespace std;\n\n// N, E, S, W\nconst int dx[4] = { -1, 0,  1,  0 };\nconst int dy[4] = { 0, 1,  0, -1 };\n\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<LL> vll;\n\n//==============================================\nvi pre, in, post;\nint pos = 0;\n\nint rec(int l, int r) {\n\tif (l >= r) return 0;\n\tint root = pre[pos++];\n\tint mid = distance(in.begin(), find(ALL(in), root));\n\n\trec(l, mid);\n\trec(mid + 1, r);\n\tpost.push_back(root);\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tpre.resize(n);\n\tin.resize(n);\n\n\tREP(i, n) cin >> pre[i];\n\tREP(i, n) cin >> in[i];\n\n\trec(0, pre.size());\n\n\tREP(i, n) {\n\t\tif (i) cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nvoid rec(vector<int> &pre, vector<int> &in, int *posIndex, int l, int r)\n{\n    if (l >= r)\n    {\n        return;\n    }\n\n    int root = pre[*posIndex];\n    *posIndex = *posIndex + 1;\n\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n\n    rec(pre, in, posIndex, l, m);\n    rec(pre, in, posIndex, m+1, r);\n\n    cout << root << \" \";\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n\n    vector<int> pre(N);\n    vector<int> in(N);\n\n    for (int i = 0; i < N; i++)\n    {\n        cin >> pre[i];\n    }\n\n    for (int i = 0; i < N; i++)\n    {\n        cin >> in[i];\n    }\n\n/*\n    for (int i = 0; i < N; i++)\n    {\n        cout << pre[i];\n    }\n*/\n    int *pos = new int;\n    *pos = 0;\n\n    rec(pre, in, pos, 0, pre.size());\n    cout << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n#define MAXN 100\nstruct node{\n\tint data;\n\tnode *lchild, *rchild;\n};\n\nint pre[MAXN], in[MAXN], post[MAXN];\n\nnode* create(int preL, int preR, int inL, int inR)\n{\n\tif (preL > preR) {\n\t\treturn NULL;\n\t}\n\tnode* root = new node;\n\troot->data = pre[preL];\n\tint k;\n\tfor (k = inL; k <= inR; k++) {\n\t\tif (in[k] == pre[preL]) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tint numLeft = k - inL;\n\troot->lchild = create(preL + 1, preL + numLeft, inL, k-1);\n\troot->rchild = create(preL + numLeft + 1, preR, k+1, inR);\n\treturn root;\n}\n\nint cnt = 0;\nvoid postOrder(node* root)\n{\n\tif (root == NULL) {\n\t\treturn;\n\t}\n\tpostOrder(root->lchild);\n\tpostOrder(root->rchild);\n\tif (cnt) {\n\t\tprintf(\" \");\n\t}\n\tcnt++;\n\tprintf(\"%d\", root->data);\n}\n\nint main(int argc, char *argv[]) {\n\tint n;\n\tscanf(\"%d\", &n);\n\tint d;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &d);\n\t\tpre[i] = d;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &in[i]);\n\t}\n\tnode* root = create(0, n-1, 0, n-1);\n\tpostOrder(root);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint pos = 0;\nvector<int> pre, in, post;\n\nvoid reconstruct(int l, int r) {\n    if(l >= r) return;\n    int root = pre[pos++];\n    int index = distance(in.begin(), find(in.begin(), in.end(), root));\n    reconstruct(l, index);\n    reconstruct(index+1, r);\n    post.push_back(root);\n}\n\nvoid solve() {\n    reconstruct(0, pre.size());\n    vector<int>::iterator it;\n    for(it = post.begin(); it != post.end(); it++) {\n        printf(\"%d\", *it);\n        if(it != (post.end() - 1)) printf(\" \");\n    }\n    printf(\"\\n\");\n}\n\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n\n    int temp1, temp2;\n    for(int i = 0; i < n; i++) {\n        scanf(\"%d\", &temp1);\n        pre.push_back(temp1);\n    }\n\n    for(int i = 0; i < n; i++) {\n        scanf(\"%d\", &temp2);\n        in.push_back(temp2);\n    }\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n,pos;\nvector<int> pre,in,post;\nvoid rec(int l,int r){\n if(l>=r)return;\n int root=pre[pos++];\n int m=distance(in.begin(),find(in.begin(),in.end(),root));\n rec(l,m);\n rec(m+1,r);\n post.push_back(root);\n}\nvoid solve(){\n pos=0;\n rec(0,pre.size());\n for(int i=0;i<n;i++){\n  if(i)cout<<\" \";\n  cout<<post[i];\n }\n cout<<endl;\n}\nint main(){\n int k;\n cin>>n;\n for(int i=0;i<n;i++){\n  cin>>k;\n  pre.push_back(k);\n }\n for(int i=0;i<n;i++){\n  cin>>k;\n  in.push_back(k);\n }\n solve();\n return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nvector<int> pre,in,post;\nint n,pos;\n\nint findx(int root){\n    for(int i=0;i<n;i++){\n        if(in[i]==root)return i;\n    }\n    return n;\n}\n\n\nvoid solve(int l,int r){\n    if(l>=r)return;\n    int root=pre[pos++];\n    int m=findx(root);\n    solve(l,m);\n    solve(m+1,r);\n    post.push_back(root);\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n;\n    for(int i=0;i<n;i++){\n        int k;\n        cin >> k;\n        pre.push_back(k);\n    }\n    for(int i=0;i<n;i++){\n        int k;\n        cin >> k;\n        in.push_back(k);\n    }\n    solve(0,pre.size());\n    for(int i=0;i<n;i++){\n        if(i)cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\nvector <int> pre, in, ans;\n\nvoid rec(int lp, int rp, int li, int ri) {\n    int root = pre[lp];\n    int i = 0;\n    while(in[li+i] != root) i++;\n    if (i != 0) rec(lp+1, lp+i, li, li+i-1);\n    if (li + i != ri) rec(lp+i+1, rp, li+i+1, ri);\n\n    ans.pb(root);\n}\n\nvoid solve(void){\n    int N;\n    cin >> N;\n    pre.resize(N), in.resize(N), ans.resize(N);\n    rep(N, i) cin >> pre[i];\n    rep(N, i) cin >> in[i];\n    rec(0, N-1, 0, N-1);\n    for (int v : ans) {\n        cout << v << ' ';\n    }\n    cout << endl;\n}\n\nint main(void){\n  solve();\n  //cout << \"yui(*-v・)yui\" << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n\nstruct TNode\n{\n\tint Index;\n\tTNode* Parent;\n\tTNode* Left;\n\tTNode* Right;\n\t\n\tTNode* PreOrderNext;\n\tstd::vector<int>::iterator InOrder;\n\t\n\tTNode();\n};\n\nTNode::TNode()\n{\n\tIndex  = -1;\n\tParent = NULL;\n\tLeft   = NULL;\n\tRight  = NULL;\n\tPreOrderNext = NULL;\n}\n\ntypedef std::vector<TNode> TBinaryTree;\nconst TNode* GetRoot(const TBinaryTree& Tree)\n{\n\tconst TNode* Node = &(Tree[0]);\n\twhile(Node->Parent){\n\t\tNode = Node->Parent;\n\t}\n\treturn Node;\n}\n\nvoid InputNodes(TBinaryTree& Tree, std::vector<int>& InOrder)\n{\n\tTNode* Temp = NULL;\n\tfor(unsigned int i = 0; i < Tree.size(); ++i){\n\t\tint Index;\n\t\tstd::cin >> Index;\n\t\tTree[Index - 1].Index = Index;\n\t\tif(Temp) Temp->PreOrderNext = &(Tree[Index - 1]);\n\t\tTemp = &(Tree[Index - 1]);\n\t}\n\t\n\tstd::vector<int>::iterator It = InOrder.begin();\n\tfor(unsigned int i = 0; i < Tree.size(); ++i){\n\t\tint Index;\n\t\tstd::cin >> Index;\n\t\tTree[Index - 1].InOrder = It;\n\t\tInOrder[i] = Index;\n\t\t++It;\n\t}\n}\n\nTNode* GetPreOrderNext(TNode* Node, int Count)\n{\n\tTNode* Next = Node;\n\tfor(int i = 0; i < Count && Next != NULL; ++i) Next = Next->PreOrderNext;\n\treturn Next;\n}\n\nvoid SetChildren(TNode* Root, std::vector<int>::iterator InOrderBegin, std::vector<int>::iterator InOrderEnd)\n{\n\tif(Root->PreOrderNext == NULL) return;\n\tint Position = distance(InOrderBegin, Root->InOrder);\n\tif(Root->PreOrderNext->Parent == NULL && Position > 0){\n\t\tRoot->Left = Root->PreOrderNext;\n\t\tRoot->PreOrderNext->Parent = Root;\n\t\tSetChildren(Root->Left, InOrderBegin, Root->InOrder);\n\t}\n\tif(Root->InOrder != InOrderEnd - 1){\n\t\tRoot->Right = GetPreOrderNext(Root, 1 + distance(InOrderBegin, Root->InOrder));\n\t\tRoot->Right->Parent = Root;\n\t\tSetChildren(Root->Right, Root->InOrder + 1, InOrderEnd);\n\t}\n}\n\nvoid OutputPostOrder(const TNode* Root, const TNode* End)\n{\n\tif(Root == NULL) return;\n\tOutputPostOrder(Root->Left, End);\n\tOutputPostOrder(Root->Right, End);\n\tstd::cout << Root->Index;\n\tif(Root != End){\n\t\tstd::cout << \" \";\n\t}else{\n\t\tstd::cout << std::endl;\n\t}\n}\n\nvoid OutputWalkOrder(const TBinaryTree& Tree)\n{\n\tOutputPostOrder(GetRoot(Tree), GetRoot(Tree));\n}\n\nint main()\n{\n\tint Count;\n\tstd::cin >> Count;\n\tTBinaryTree BinaryTree(Count);\n\tstd::vector<int> InOrder(Count);\n\n\tInputNodes(BinaryTree, InOrder);\n\n\tSetChildren(&(BinaryTree[0]), InOrder.begin(), InOrder.end());\n\n\tOutputWalkOrder(BinaryTree);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct Vertex{\n\tint left;\n\tint right;\n};\n\nvoid Postorder(vector<Vertex> &T,int root){\n\tif(T[root].left!=-1) Postorder(T,T[root].left);\n\tif(T[root].right!=-1) Postorder(T,T[root].right);\n\tcout << root+1 << \" \";\n\treturn;\n}\n\nvoid Reconstruction(vector<Vertex> &T, vector<int> &Pre,vector<int> &In,int p,int q,int s,int t){\n\t\n\tcout<<p<<q<<s<<t<<endl;\n\tint root = Pre[p];\n\tif(p==q){\n\t\tT[root].left=-1;\n\t\tT[root].right=-1;\n\t\treturn ;\n\t}\n\t\n\tvector<bool> check(1000000,false);\n\t\n\t//k???In????????????root?????????????????????\n\tint k=-1;\n\tfor(int i=s;i<t+1;i++){\n\t\tcheck[In[i]]=true;\n\t\tif (In[i]==root){\n\t\t\tk=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t//l???Pre?????????????????´?????¨???????????????????????????????????????\n\tint l;\n\tfor(int i=p;i<q+1;i++){\n\t\tif(check[Pre[i+1]]==false){\n\t\t\tl=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif(s==k){\n\t\tT[root].left=-1;\n\t\tT[root].right=Pre[l+1];\n\t\n\t\tReconstruction(T,Pre,In,l+1,q,k+1,t);\n\t}else if(t==k){\n\t\tT[root].left=Pre[p+1];\n\t\tT[root].right=-1;\n\t\n\t\tReconstruction(T,Pre,In,p+1,l,s,k-1);\n\t}else{\n\t\tT[root].left=Pre[p+1];\n\t\tT[root].right=Pre[l+1];\n\t\n\t\tReconstruction(T,Pre,In,p+1,l,s,k-1);\n\t\tReconstruction(T,Pre,In,l+1,q,k+1,t);\n\t}\n}\n\nint main(){\n\tint n,x;\n\tcin >> n;\n\tvector<int> Pre(n);\n\tvector<int> In(n);\n\tfor (int i=0;i<n;i++){\n\t\tcin >> x;\n\t\tPre[i]=x-1;\n\t}\n\t\n\tfor (int i=0;i<n;i++){\n\t\tcin >> x;\n\t\tIn[i]=x-1;\n\t}\n\t\n\tvector<Vertex> T(n);\n\tReconstruction(T,Pre,In,0,n-1,0,n-1);\n\tPostorder(T,Pre[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < n; i++)\nusing namespace std;\nusing ll = long long;\n\nint n;\nint preorder[40], inorder[40];\n\nvoid reconstruct(int fp, int lp, int fi, int li)\n{\n    int root;\n    rep(i, n)\n    {\n        if (preorder[fp] == inorder[i])\n            root = i;\n    }\n    if (root != fi)\n    {\n        reconstruct(fp + 1, fp + (root - fi) + 1, fi, root);\n        cout << \" \";\n    }\n    if (root != li - 1)\n    {\n        reconstruct(fp + (root - fi) + 1, lp, root + 1, li);\n        cout << \" \";\n    }\n    cout << inorder[root];\n}\n\nint main()\n{\n    cin >> n;\n    rep(i, n) cin >> preorder[i];\n    rep(i, n) cin >> inorder[i];\n    reconstruct(0, n, 0, n);\n    cout << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint A[105],B[105],in=0,flg=1;\nvoid f(int l,int r){\n\tif(l>=r) return;\n\tint c = A[in++];\n\tint m = B[c];\n\tf(l,m);\n\tf(m+1,r);\n\tif(flg) cout<<c,flg = 0;\n\telse cout<<' '<<c;\n}\nint main()\n{\n\tint n,u; cin>>n;\n\tfor(int i=0;i<n;i++) cin>>A[i];\n\tfor(int i=0;i<n;i++){\n\t\tcin>>u;\n\t\tB[u] = i;\n\t}\n\tf(0,n);\n\tcout<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<stdlib.h>\n\n// I did it!\nint *P, *L, *R;\n\nvoid maketree(int* A, int* B, int h)\n{\n    int x, m;\n    x = A[0];\n    if(h == 1){\n        L[x] = -1; R[x] = -1; return;\n    }else{\n        m = 0;\n        while(B[m] != A[0]) m++;\n        m++;\n        if(m == 1){\n            L[x] = -1; R[x] = A[1]; P[A[1]] = x;\n            maketree(A + 1, B + 1, h - 1);\n        }else if(m == h){\n            L[x] = A[1]; P[A[1]] = x; R[x] = -1;\n            maketree(A + 1, B, h - 1);\n        }else{\n            L[x] = A[1]; P[A[1]] = x; R[x] = A[m]; P[A[m]] = x;\n            maketree(A + 1, B, m - 1);\n            maketree(A + m, B + m, h - m);\n        }\n    }\n}\n\nvoid postorder(int i)\n{\n    if(i < 0) return;\n    postorder(L[i]);\n    postorder(R[i]);\n    cout << \" \" << i;\n}\n\nint main()\n{\n    int i, n;\n    cin >> n;\n    P = new int [n]; L = new int [n]; R = new int [n];\n    if(P == NULL || L == NULL || R == NULL) exit(EXIT_FAILURE);\n\n    int *A, *B;\n    A = new int [n]; B = new int [n];\n    if(A == NULL || B == NULL) exit(EXIT_FAILURE);\n\n    for(i = 0; i < n; i++){ cin >> A[i]; P[i] = L[i] = R[i] = -1; }\n    for(i = 0; i < n; i++){ cin >> B[i]; }\n\n    maketree(A, B, n);\n\tdelete [] A; delete [] B;\n\n    // where is root?\n    i = 0; while(P[i] >= 0) i++;\n    postorder(i);\n    cout << endl;\n\tdelete [] P; delete [] L; delete [] R;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\ntypedef long long ll;\nusing namespace std;\n\nint pre[105];\nint in[105];\nint post[105];\n\nvoid rebuild(int preL, int inL, int postL, int N)\n{\n\tif (N == 0)\n\t\treturn;\n\tpost[postL + N - 1] = pre[preL];\n\tif (N > 1)\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < N; ++i)\n\t\t{\n\t\t\tif (pre[preL] == in[inL + i])\n\t\t\t\tbreak;\n\t\t}\n\t\trebuild(preL + 1, inL, postL, i);\n\t\trebuild(preL + i + 1, inL + i + 1, postL + i, N - i - 1);\n\t}\n}\n\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> pre[i];\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> in[i];\n\trebuild(0, 0, 0, n);\n\tfor (int i = 0; i < n - 1; ++i)\n\t\tcout << post[i] << ' ';\n\tcout << post[n - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r){\n  if(l>=r) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(),find(in.begin(),in.end(),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\n\nvoid solve(){\n  pos = 0;\n  rec(0,pre.size());\n  for(int i=0;i<n;i++){\n    if(i) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main(){\n  int k;cin >> n;\n\n  for(int i=0;i<n;i++){\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for(int i=0;i<n;i++){\n    cin >> k;\n    in.push_back(k);\n  }\n\n  solve();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define N 40\nvoid Postorder(int *,int *,int);\nint n,post[N],count=0;\n\nvoid Postorder(int *pre,int *in,int n)\n{\n  int k,p;\n\n  for(k=0;k<n;k++){\n    if(pre[0]==in[k]){\n      p=k;\n      break;\n    }\n  }\n\n  if(p!=0) Postorder(pre+1,in,p);\n\n  if(p!=n-1) Postorder(pre+p+1,in+p+1,n-p-1);\n\n  post[count]=pre[0];\n  count++;\n}\n    \n\nint main()\n{\n  int i,pre[N],in[N];\n\n  scanf(\"%d\",&n);\n\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&pre[i]);\n  }\n\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&in[i]);\n  }\n\n  Postorder(pre,in,n);\n\n  for(i=0;i<n;i++){\n    printf(\"%d \",post[i]);\n  }\n\n  printf(\"\\n\");\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (n) ; i++)\nconstexpr auto INF = 2147483647;\ntypedef long long ll;\n\nint n, pos ;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n  if(l >= r) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(),find(in.begin(), in.end(), root));\n  rec(l, m);\n  rec(m + 1, r);\n  post.push_back(root);\n}\n\nvoid solve(){\n  pos = 0;\n  rec(0, pre.size());\n  for ( int i = 0; i < n; i++ ){\n    if(i) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main(){\n  \n  int k;\n  cin >> n;\n\n  for(int i = 0; i < n ; i++){\n    cin >> k;\n    pre.push_back(k);\n  }\nrep(i,n){\n  cin >> k;\n  in.push_back(k);\n}\n\nsolve();\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 40;\n\nint N;\nint POS = 0;\n\nvector<int> PRE;\nvector<int> IN;\nvector<int> POST;\n\nvoid restore(int l, int r) {\n  if (l >= r) return;\n  int root = PRE[POS++];\n  int m = distance(IN.begin(), find(IN.begin(), IN.end(), root));\n  restore(l, m);\n  restore(m+1, r);\n  POST.push_back(root);\n}\n\nvoid solve() {\n  restore(0, N);\n}\n\nint main() {\n  int t; cin >> N;\n  for (int i = 0; i < N; i++) {\n    cin >> t;\n    PRE.push_back(t);\n  }\n\n  for (int i = 0; i < N; i++) {\n    cin >> t;\n    IN.push_back(t);\n  }\n\n  solve();\n  for (int i = 0; i < N; i++) {\n    if (i) cout << ' ';\n    cout << POST[i];\n  }\n  cout << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX = 100005;\nconst int nil = -1;\n\nint n, pos; // pre配列のみている位置\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n    if(l >= r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m+1, r);\n    post.push_back(root);\n}\n\nvoid solve(){\n    pos = 0;\n    rec(0, pre.size());\n    for(int i=0; i<n; ++i){\n        if(i) cout << ' ';\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main(){\n    int k;\n    cin >> n;\n\n    for(int i=0; i<n; ++i){\n        cin >> k;\n        pre.push_back(k);\n    }\n\n    for(int i=0; i<n; ++i){\n        cin >> k;\n        in.push_back(k);\n    }\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm> // next_permutation\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <list>\n#include <numeric> //accumulate\n//#include <unordered_map> //???????????\\??¢??°\n#include <fstream> //ifstream, ofstream\n\n//#define NDEBUG //NDEBUG???#include <cassert>???????????????????????????????????´???assert?????????????????????????????????NDEBUG?????????????????????????????????????????????\n#include <cassert> //assert\n\n\nusing namespace std;\n\n//???????????°??????TEST????????????????????¬???????????????????????????????????¢????????????\n#define TEST //*******************************************************************************************************************************************\n//?????????????????¨??§?????\\????????????????????????????????°?????????????¨???????????????????dout???????????????????????§???????????¬??????????????????????????????????????????\n//??????????????????????????????????????????????????????????§?CPU???????£??????????????????§???TLE?????????????????????????????????????????§????????¨???                           ????????????????????????cerr????????£????????????????????????????????????\n#ifdef TEST\n#define dout cout\n#else\nstringstream dummy; //???????????°??????dout?????????????????????????????????\n#define dout dummy.str(\"\"); dummy.clear(stringstream::goodbit); dummy //dummy?????????????????????????????????????????¨?????¢?????¢???????????????\n//???????????¨??????????????????goodbit?????????????????????????????¨???????????´????????????????????????????????¨?????°?????????????????§???????????????????????????????????? http://d.hatena.ne.jp/linden/20060427/p1\n#endif\n\n//?¨??????????????????????????????????????????????????????´??????OUTPUT2TEXTFILE????????????????????¬???????????????????????????????????¢????????????\n//#define OUTPUT2TEXTFILE //*******************************************************************************************************************************************\n#ifdef OUTPUT2TEXTFILE\n#define dout outputfile //??¨????????????TLE????????§?????????dout?????¨??¨??????????????¢????????????????????????????????????????????§????¨????????????´??????????????£??????????????????????¨?????????????????????????????????????????????§?????????????????????\n//TEST??????????????????????????¨???outputfile??????????????????????????????\n#define OUTPUTFILENAME \"output.txt\"\nofstream outputfile(OUTPUTFILENAME);\n#define OutputFilePath \"/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt\"\n#endif\n\n#define disp(A) dout << #A << \" = \" << (A) << endl\n#define disP(A) dout << setw(3) << (A) << \" \" // << setw(3) ??????????????\\????????????\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n\n#define dispAll(A,n) dout << #A << \" = \"; rep(j, 0, (n)) {disP(A[j]);} dout << endl\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef unsigned long long ll;\n\nconst int INF = 1e9-1;\n\nclass Node;\n\nvector<Node> node;\nvi printer;\n\n\nclass Node {\npublic:\n    Node() {\n        parent = -1;\n        left = -1;\n        right = -1;\n    }\n    \n    int parent;\n    int left;\n    int right;\n    \n    \n    int depth() {\n        int p = this->parent;\n        int d = 0;\n        \n        while( p != -1 ) {\n            d++;\n            p = node[p].parent;\n        }\n        \n        return d;\n    }\n    \n    static int height(int id) {\n        if(id == -1) return -1;\n        \n        return max( height(node[id].left), height(node[id].right)) + 1;\n    }\n    \n    static void printNodePreorder(int id) {\n        if(id==-1) return;\n        \n        cout << \" \" << id;\n        printNodePreorder(node[id].left);\n        printNodePreorder(node[id].right);\n    }\n    \n    static void printNodeInorder(int id) {\n        if(id==-1) return;\n        \n        printNodeInorder(node[id].left);\n        cout << \" \" << id;\n        printNodeInorder(node[id].right);\n    }\n    \n    static void printNodePostorder(int id) {\n        if(id==-1) return;\n        \n        printNodePostorder(node[id].left);\n        printNodePostorder(node[id].right);\n        printer.push_back(id);\n//        cout << \" \" << id;\n    }\n    \n    \n};\n\n\n\nint main(){\n    int N; cin >> N;\n    rep(i,0,N+1) node.push_back(*new Node());\n    \n    //read input data\n//    int p, c1, c2;\n//    rep(i,0,N) {\n//        //        dout<<\"------\";\n//        //        disp(i);\n//        cin >> p >> c1 >> c2;\n//        \n//        node[p].left = c1;\n//        node[p].right = c2;\n//        \n//        if(c1!=-1) node[c1].parent = p;\n//        if(c2!=-1) node[c2].parent = p;\n//    }\n    int preorder[N+1], inorder[N+1];\n    int preindex2inindex[N+1]; //pre[i]=in[j]?????¨??????preindex2inindex[i]=j??¨??????????????????????????????in[j] = in[ preindex2inindex[i] ] = pre[i]\n    bool registered[N+1]; //node[i]????????§????????????????????¨??????1????????????\n    \n    rep(i,1,N+1) cin >> preorder[i];\n    rep(i,1,N+1) cin >> inorder[i];\n    rep(i,1,N+1) registered[i] = 0;\n\n    rep(i,1,N+1) { //preorder[i]???inorder[]????????????????????????????????????preindex2inindex[i]???????´???????\n        int key = preorder[i];\n        rep(j,1,N+1) {\n            if(key == inorder[j]) {\n                preindex2inindex[i] = j;\n                break;\n            }\n        }\n    }\n    \n//    //test display\n//    dispAll(preorder, N+1);\n//    dispAll(inorder, N+1);\n//    dispAll(preindex2inindex, N+1);\n//    dispAll(registered, N+1);\n\n    \n    //reconstruct tree\n    //Preorder?????°???????????????????????????????????????????????????????????????\n    //????????¨??????Inorder????????±????????????????????????????????????????±????????????????\n    int x;\n    \n    //preorder[1] = root??¨?????????root?????????????????????????????¢?????????????????????????????????????????§?????±??´??°???????????????????????????????????°??????????????????????????????\n    registered[ preorder[1] ] = 1;\n    \n    rep(i,2,N+1) { //?????????preorder[i]???????????????\n        if( preindex2inindex[i] < preindex2inindex[i-1] ) { //inorder????????????preorder[i]???preorder[i-1]???????????´???????????°???preorder[i]???preorder[i-1]????????´????????¨???????????¨?????????\n            node[ preorder[i-1] ].left = preorder[i];\n            node[ preorder[i] ].parent = preorder[i-1];\n            registered[preorder[i]] = 1; //????????????????????°????????????\n        }\n        else { //????????§????????£?????´???????????????????????´????????¨???????????????????????????????????¢??????????????????preorder??§????????¨??????????????????????????´????????????????????????????????????????????????????????§??????\n            x = preindex2inindex[i] - 1; //x = inorder???????????????preorder[i]???1???????????°?????????index\n            while( registered[ inorder[x] ]==0 ) x--; //inorder???????????????preorder[i]??????????????????????????§????????????????????????????????¢????????????????????????????????£???inorder[x]??????preorder[i]????????§??????????????´?????????preorder[i]??¨???????????¨?????????\n            //??¶?????????????????????????????????????????????????????§??????????????????????????\\???????????????????°?????????¨???root????????????????????????root?????????????????????????????????????????????????????????else?????¶?????\\??£????????????????????????\n            \n            node[ inorder[x] ].right = preorder[i];\n            node[ preorder[i] ].parent = inorder[x];\n            registered[preorder[i]] = 1; //????????????????????°????????????\n        }\n        \n//        //test display\n//        dout<<\"-----------------\\n\";\n//        dout << \"  i   l   r   p\\n\";\n//        rep(i,0,N+1) {\n//            disP(i);\n//            disP(node[i].left); disP(node[i].right); disP(node[i].parent);\n//            dout << endl;\n//        }\n    }\n    \n    \n    \n    \n    \n//    //output\n//    rep(i,0,N+1) {\n//        cout << \"node \" << i << \": parent = \" << node[i].parent\n//        << \", sibling = \" << (node[i].parent==-1 ? -1 : (node[node[i].parent].left==i ? node[node[i].parent].right : node[node[i].parent].left) )\n//        << \", degree = \" << (node[i].left==-1 ? (node[i].right==-1 ? 0 : 1) : (node[i].right==-1 ? 1 : 2))\n//        << \", depth = \" << node[i].depth()\n//        << \", height = \" << Node::height(i) << \", \"\n//        << (node[i].parent==-1 ? \"root\" : (node[i].left==-1 && node[i].right==-1 ? \"leaf\" : \"internal node\") ) << endl;\n//    }\n    \n    \n    //find root\n    int root_i = -1;\n    rep(i,1,N+1) {\n        if(node[i].parent==-1) {\n            root_i = i;\n            break;\n        }\n    }\n    assert(root_i!=-1);\n    \n    //print tree\n//    cout << \"Preorder\\n\";\n//    Node::printNodePreorder(root_i);\n//    cout << endl;\n//    \n//    cout << \"Inorder\\n\";\n//    Node::printNodeInorder(root_i);\n//    cout << endl;\n//    \n//    cout << \"Postorder\\n\";\n    Node::printNodePostorder(root_i);\n    \n    rep(i,0,N) {\n        if(i==0) cout << printer[i];\n        else cout << \" \" << printer[i];\n    }\n    cout << endl;\n    \n    \n#ifdef OUTPUT2TEXTFILE\n    outputfile.close();\n    cout << \"\\\"\" << OutputFilePath << \"\\\"\" << endl;\n#endif\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define double long double\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mod (ll)(1e9+7)\n#define inf (ll)(3e18+7)\n#define P pair<int,int>\n#define PiP pair<int,pair<int,int>>\n#define all(x) x.begin(),x.end()\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n  if(l >= r) return;\n  int root = pre.at(pos++);\n  int m = distance(in.begin(), find(all(in), root));\n  rec(l, m);\n  rec(m+1, r);\n  post.push_back(root);\n}\n\nvoid solve(){\n  pos = 0;\n  rec(0, pre.size());\n  rep(i, n) {\n      if(i != 0) cout << \" \";\n      cout << post.at(i);\n  }\n  cout << endl;\n}\n\nint main() {\n  int k;\n  cin >> n;\n  rep(i, n) {\n      cin >> k;    \n      pre.push_back(k);\n  }\n  rep(i, n) {\n      cin >> k;\n      in.push_back(k);\n  }\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <boost/multi_array.hpp>\n#include <boost/optional.hpp>\n#include <boost/range/adaptors.hpp>\n#include <boost/range/algorithm.hpp>\n#include <boost/range/irange.hpp>\n#include \"bits/stdc++.h\"\n\nnamespace adaptor = boost::adaptors;\n\nint64_t n, position;\nstd::vector<int64_t> pre, in, post;\n\nvoid rec(int64_t l, int64_t r) {\n    if (l >= r) return;\n    int64_t root, m;\n    root = pre[position++];\n    m = std::distance(in.begin(), std::find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m + 1, r);\n    post.push_back(root);\n}\n\nvoid solve() {\n    std::cin >> n;\n    for (int64_t i = 0; i < n; i++) {\n        int64_t tmp;\n        std::cin >> tmp;\n        pre.push_back(tmp);\n    }\n    for (int64_t i = 0; i < n; i++) {\n        int64_t tmp;\n        std::cin >> tmp;\n        in.push_back(tmp);\n    }\n\n    position = 0;\n    rec(0, pre.size());\n    for (int64_t i = 0; i < n; i++) {\n        if (i > 0) std::cout << \" \";\n        std::cout << post[i];\n    }\n    std::cout << std::endl;\n\n    return;\n}\n\nint main() {\n    std::cin.tie(0);\n    std::ios_base::sync_with_stdio(false);\n    std::cout << std::fixed << std::setprecision(15);\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nconst int N = 100;\nint Pre[N], In[N];\nint root, cnt;\n\nvoid construct_tree(int left, int right) {\n  if (left < right) {\n    int node = Pre[root++];\n    for (int i = left; i < right; i++) {\n      if (In[i] == node) {\n        // left subtree\n        construct_tree(left, i);\n        // right subtree\n        construct_tree(i+1, right);\n        // print nodes in postorder\n        if (cnt++ > 0) cout << \" \";\n        cout << node;\n        break;\n      }\n    }\n  }\n}\n\nint main() {\n  int i, n;\n\n\n  // input\n  cin >> n;\n  for (i = 0; i < n; i++) cin >> Pre[i];\n  for (i = 0; i < n; i++) cin >> In[i];\n  // initialize\n  root = 0;\n  cnt = 0;\n  // output\n  construct_tree(0, n);\n  cout << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n\nstruct TNode\n{\n\tint Index;\n\tTNode* Parent;\n\tTNode* Left;\n\tTNode* Right;\n\t\n\tTNode* PreOrderNext;\n\tstd::vector<int>::iterator InOrder;\n\t\n\tTNode();\n};\n\nTNode::TNode()\n{\n\tIndex  = -1;\n\tParent = NULL;\n\tLeft   = NULL;\n\tRight  = NULL;\n\tPreOrderNext = NULL;\n}\n\ntypedef std::vector<TNode> TBinaryTree;\n\nTNode* InputNodes(TBinaryTree& Tree, std::vector<int>& InOrder)\n{\n\tTNode* Temp = NULL;\n\tTNode* Root = NULL;\n\tfor(unsigned int i = 0; i < Tree.size(); ++i){\n\t\tint Index;\n\t\tstd::cin >> Index;\n\t\tTree[Index - 1].Index = Index;\n\t\tif(Temp) Temp->PreOrderNext = &(Tree[Index - 1]);\n\t\tTemp = &(Tree[Index - 1]);\n\t\tif(i == 0) Root = Temp;\n\t}\n\t\n\tstd::vector<int>::iterator It = InOrder.begin();\n\tfor(unsigned int i = 0; i < Tree.size(); ++i){\n\t\tint Index;\n\t\tstd::cin >> Index;\n\t\tTree[Index - 1].InOrder = It;\n\t\tInOrder[i] = Index;\n\t\t++It;\n\t}\n\treturn Root;\n}\n\nTNode* GetPreOrderNext(TNode* Node, int Count)\n{\n\tTNode* Next = Node;\n\tfor(int i = 0; i < Count && Next != NULL; ++i) Next = Next->PreOrderNext;\n\treturn Next;\n}\n\nvoid SetChildren(TNode* Root, std::vector<int>::iterator InOrderBegin, std::vector<int>::iterator InOrderEnd)\n{\n\tif(Root->PreOrderNext == NULL) return;\n\tint Position = distance(InOrderBegin, Root->InOrder);\n\tif(Root->PreOrderNext->Parent == NULL && Position > 0){\n\t\tRoot->Left = Root->PreOrderNext;\n\t\tRoot->PreOrderNext->Parent = Root;\n\t\tSetChildren(Root->Left, InOrderBegin, Root->InOrder);\n\t}\n\tif(Root->InOrder != InOrderEnd - 1){\n\t\tRoot->Right = GetPreOrderNext(Root, 1 + distance(InOrderBegin, Root->InOrder));\n\t\tRoot->Right->Parent = Root;\n\t\tSetChildren(Root->Right, Root->InOrder + 1, InOrderEnd);\n\t}\n}\n\nvoid OutputPostOrder(const TNode* Root, const TNode* End)\n{\n\tif(Root == NULL) return;\n\tOutputPostOrder(Root->Left, End);\n\tOutputPostOrder(Root->Right, End);\n\tstd::cout << Root->Index;\n\tif(Root != End){\n\t\tstd::cout << \" \";\n\t}else{\n\t\tstd::cout << std::endl;\n\t}\n}\n\nint main()\n{\n\tint Count;\n\tstd::cin >> Count;\n\tTBinaryTree BinaryTree(Count);\n\tstd::vector<int> InOrder(Count);\n\t\n\tTNode* Root = InputNodes(BinaryTree, InOrder);\n\t\n\tSetChildren(Root, InOrder.begin(), InOrder.end());\n\n\tOutputPostOrder(Root, Root);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nusing namespace std;\n\nvoid rc(int[], int[], int[], int, int, int);\nstatic bool flag;\n\nint main()\n{\n\tint pre[41], in[41], revi[41], n;\n\tflag = false;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", pre + i);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tscanf(\"%d\", in + i);\n\t\trevi[in[i]] = i;\n\t}\n\n\trc(pre, in, revi, 1, n + 1, 1);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n\nvoid rc(int pre[], int in[], int revi[], int ileft, int iright, int pleft)\n{\n\tif (ileft < iright)\n\t{\n\t\tint imid = revi[pre[pleft]];\n\t\trc(pre, in, revi, ileft, imid, pleft + 1);\n\t\trc(pre, in, revi, imid + 1, iright, pleft + imid - ileft + 1);\n\t\tif (flag)\n\t\t\tprintf(\" \");\n\t\telse\n\t\t\tflag = true;\n\t\tprintf(\"%d\", pre[pleft]);\n\t}\n\treturn;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define repr(i, n) for (int i = (int)(n); i >= 0; i--)\n#define REP(i, m, n) for (int i = (int)(m); i <= (int)(n); i++)\n#define REPR(i, m, n) for (int i = (int)(m); i >= (int)(n); i--)\n#define all(v) v.begin(), v.end()\ntypedef long long ll;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n  if(l >= r) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(l, m);\n  rec(m+1, r);\n  post.push_back(root);\n}\n\nvoid solve(){\n  pos = 0;\n  rec(0, pre.size());\n  rep(i, n){\n    if(i) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main(){\n  cin >> n;\n  rep(i, n){\n    int a; cin >> a;\n    pre.push_back(a);\n  }\n  rep(i, n){\n    int a; cin >> a;\n    in.push_back(a);\n  }\n\n  solve();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n\tif(l >= r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m+1, r);\n\tpost.push_back(root);\n}\n\nvoid solve() {\n\tpos = 0;\n\trec(0, pre.size());\n\tfor(int i = 0; i < n; i++) {\n\t\tif(i) cout << \" \";\n\t\tcout << post[i]; \n\t}\n\tcout << endl;\n}\n\nint main() {\n\tint k;\n\tcin >> k;\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> pre[i];\n\t}\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\t\n\tsolve();\n    \n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nint n;\nint P[42];\nint Pi[42];\nint K[42];\nint Ki[42];\n\n\nstruct N {\n\tint id,l, r;\n\tvoid setid(int pi);\n\tvoid pre();\n\tvoid in();\n\tvoid post();\n};\n\nint root;\nN T[25];\n\n/*\n5\n1 2 3 4 5\n3 2 4 1 5\n\n         1\n   2        5\n 3   4\n*/\n\n// I think this is a O(n) algorizm\n\nvoid N::setid(int _id)\n{\n\tid = _id;\n\tint pid=Pi[id]; // 1\n\tint kid=Ki[id]; // 1\n\tint idl=P[pid+1]; // 2\n\tint kidl=Ki[idl]; // 2\n\tif (kid>kidl) {\n\t\tl=idl;\n\t\tT[l].setid(l);\n\t}\n\tint idr=K[kid+1];\n\tint pidr=Pi[idr];\n\tif(pidr>pid){\n\t\tr=idr;\n\t\tT[r].setid(r);\n\t}\n//\tcout<<id<<' '<<l<<' '<<r<<endl;\n}\n\n\nint main()\n{\n\tmemset(T, 0, sizeof(T));\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>P[i];\n\tP[0]=P[n+1]=0;\n\tfor(int i=1;i<=n;i++) Pi[P[i]]=i;\n\tPi[0]=Pi[n+1]=0;\n\tfor(int i=1;i<=n;i++) cin>>K[i];\n\tK[0]=K[n+1]=0;\n\tfor(int i=1;i<=n;i++) Ki[K[i]]=i;\n\tKi[0]=Ki[n+1]=0;\n\troot = P[1];\n\t\n\tT[root].setid(root);\n\t/*\n\tcout<<\"Preorder\"<<endl;\n\tT[root].pre();\n\tcout<<endl;\n\t\n\tcout<<\"Inorder\"<<endl;\n\tT[root].in();\n\tcout<<endl;\n\t*/\n//\tcout<<\"Postorder\"<<endl;\n\tT[root].post();\n\tcout<<endl;\n}\n\n\t\nvoid N::pre()\n{\n\tcout<<' '<<id;\n\tif(l)T[l].pre();\n\tif(r)T[r].pre();\n}\n\nvoid N::in()\n{\n\tif(l)T[l].in();\n\tcout<<' '<<id;\n\tif(r)T[r].in();\n}\nbool first = false;\nvoid N::post()\n{\n\tif(l)T[l].post();\n\tif(r)T[r].post();\n\tif (first) cout<<' '; else first = true;\n\tcout<<id;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,pos;\nvector<int>pre,in,post;\nvoid rec(int l,int r){\nif(l>=r)return 0;\nint root=pre[pos++];\nint m=distance(in.begin(),find(in.begin(),in.end(),root));\nrec(l,m);\nrec(m+1,r);\npost.push_back(root);\n}\nvoid solve(){\npos=0;\nrec(0,pre.size());\nfor(int i=0;i<n;i++){\nif(i)cout<<\" \";\ncout<<post[i];\n}\ncout<<endl;\n}\nint main(){\nint k;\ncin>>n;\nfor(int i=0;i<n;i++){\ncin>>k;\npre.push_back(k);\n}\nfor(int i=0;i<n;i++){\ncin>>k;\nin.push_back(k);\n}\nsolve();\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint n, pre[50], in[50], post[50], p = 0, cnt = 0;\n\nvoid reconstruction(int left, int right){\n  \n  if(left >= right) return ;\n  \n  int c = pre[p++], m;\n  for(int i = 0;;i++){\n    if(c == in[i]){\n      m = i;\n      break;\n    }\n  }\n  \n  reconstruction(left, m);\n  reconstruction(m + 1, right);\n  \n  post[cnt++] = c;\n}\n\nint main(){\n  \n  cin >> n;\n  for(int i = 0;i < n;i++) cin >> pre[i];\n  for(int i = 0;i < n;i++) cin >> in[i];\n  \n  reconstruction(0, n);\n  \n  for(int i = 0;i < n;i++){\n    cout << (i?\" \":\"\");\n    cout << post[i];\n  }\n  cout << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define eol '\\n';\nusing namespace std;\n\nclass Node {\npublic:\n  int id;\n  int l;\n  int r;\n  int p;\n  Node(): id(-1),l(-1),r(-1),p(-1){};\n};\n\nNode* tree;\n\nint create_tree(int parent, vector<int> pre, vector<int> in) {\n    if (pre.size() == 0 && in.size() == 0) {\n      return -1;\n    }\n\n    int root_id = pre[0];\n\n    Node* node = &tree[root_id];\n    node->p = parent;\n    \n    // left\n    vector<int> left_pre;\n    vector<int> left_in;\n\n    int i = 0;\n    int size = in.size();\n    for (; i < size; i++) {\n      if (in[i] == root_id) {\n        break;\n      }\n      left_pre.push_back(pre[i+1]);\n      left_in.push_back(in[i]);\n    }\n    node->l = create_tree(root_id, left_pre, left_in);\n\n    vector<int> right_pre;\n    vector<int> right_in;\n\n    i++;\n    for (;i < size; i++) {\n      right_pre.push_back(pre[i]);\n      right_in.push_back(in[i]);\n    }\n    node->r = create_tree(root_id, right_pre, right_in);\n\n    return root_id;\n}\n\nvector<int> postorder(int id, vector<int> post) {\n  Node* node = &tree[id];\n  if (node->l != -1) {\n    post = postorder(node->l, post);\n  }\n  if (node->r != -1) {\n    post = postorder(node->r, post);\n  }\n  post.push_back(id);\n\n  return post;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  \n  int n,i;\n  cin >> n;\n\n  tree = new Node[n];\n\n  vector<int> preorder(n);\n  vector<int> inorder(n);\n\n  for (i = 0; i < n; i++) {\n    cin >> preorder[i];\n  }\n  for (i = 0; i < n; i++) {\n    cin >> inorder[i];\n  }\n\n  int root = create_tree(-1, preorder, inorder);\n\n  // post order\n  vector<int> post;\n  post = postorder(root, post);\n\n  // output\n  cout << post[0];\n  for (i = 1; i < n; i++) {\n    cout << \" \" << post[i];\n  }\n  cout << eol;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace  std;\n\nvoid fnInput(vector<int> &rvnPodr, vector<int> &rvnIodrSeq)\n{\n  int nMaxSiz;\n\n  cin >> nMaxSiz;\n  rvnPodr.resize(nMaxSiz + 1);\n  rvnIodrSeq.resize(nMaxSiz + 1);\n\n  for (int i = 1; i < nMaxSiz + 1; i++)\n    cin >> rvnPodr[i];\n\n  int nNode;\n  for (int i = 1; i < nMaxSiz + 1; i++)\n  {\n    cin >> nNode;\n    rvnIodrSeq[nNode] = i;\n  }\n}\n\nvoid fnPostOrder(const vector<int> &cnrvnPodr, const vector<int> &cnrvnIodrSeq, int nLeft, int nRight)\n{\n  static int stnx = 1;\n  static int stnPrt = 0;\n\n  if (nLeft == nRight) return;\n\n  int nNode = cnrvnPodr[stnx++];\n  int nMid = cnrvnIodrSeq[nNode];\n\n  fnPostOrder(cnrvnPodr, cnrvnIodrSeq, nLeft, nMid);\n  fnPostOrder(cnrvnPodr, cnrvnIodrSeq, nMid + 1, nRight);\n\n  if (stnPrt++) cout << \" \";\n  cout << nNode;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vector<int> vnPodr, vnIodrSeq;\n  fnInput(vnPodr, vnIodrSeq);\n\n  fnPostOrder(vnPodr, vnIodrSeq, 1, vnPodr.size());\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n \nusing namespace std;\n\nvoid reconstruct_tree\n(vector<pair<int, int> >& nodes, \n const int s, const int t, const int r,\n const vector<int>& preo,  const vector<int>& inv_preo,\n const vector<int>& ino,   const vector<int>& inv_ino)\n{\n  // r is in ino[s,t)\n  int left_subtree_size  = inv_ino[r] - s;\n  int right_subtree_size = t - inv_ino[r] -1;\n  if(left_subtree_size > 0){\n    nodes[r].first = preo[inv_preo[r]+1];\n    reconstruct_tree(nodes, s, inv_ino[r], nodes[r].first,\n\t\t     preo, inv_preo, ino, inv_ino);\n  }\n  else{\n    nodes[r].first = -1;\n  }\n\n  if(right_subtree_size > 0){\n    nodes[r].second = preo[inv_preo[r]+left_subtree_size+1];\n    reconstruct_tree(nodes, inv_ino[r]+1, t, nodes[r].second,\n\t\t     preo, inv_preo, ino, inv_ino);\n  }\n  else{\n    nodes[r].second = -1;\n  }\n}\n \nvoid print_preorder(const vector<pair<int, int> >& nodes, const int r){\n  //cout << '?' << endl;\n  if(r<0) return;\n  //cout << '?' << endl;\n  cout << ' ' << r;\n  print_preorder(nodes, nodes[r].first);\n  print_preorder(nodes, nodes[r].second);\n}\n \nvoid print_inorder(const vector<pair<int, int> >& nodes, const int r){\n  if(r<0) return;\n  print_inorder(nodes, nodes[r].first);\n  cout << ' ' << r;\n  print_inorder(nodes, nodes[r].second);\n}\n   \n \nvoid print_postorder(const vector<pair<int, int> >& nodes, const int r, int geta, bool& first_print){\n  if(r<0) return;\n  print_postorder(nodes, nodes[r].first, geta, first_print);\n  print_postorder(nodes, nodes[r].second, geta, first_print);\n  \n  cout << (first_print ? \"\": \" \")  << (r+geta);\n  first_print = false;\n}\n \nint main(){\n  std::ios_base::sync_with_stdio(false);\n \n  int n;\n  cin >> n;\n  vector<pair<int, int> > nodes(n);\n  vector<int> preo(n); //0 .. n-1\n  vector<int> inv_preo(n);\n  vector<int> ino(n);  //0 .. n-1\n  vector<int> inv_ino(n);\n \n  for(int i=0; i<n; ++i){\n    int v;\n    cin >> v;\n    preo[i] = v-1;\n    inv_preo[v-1] = i;\n  }\n  for(int i=0; i<n; ++i){\n    int v;\n    cin >> v;\n    ino[i] = v-1;\n    inv_ino[v-1] = i;\n  }\n  \n  reconstruct_tree(nodes, 0, nodes.size(), preo[0],\n\t\t   preo, inv_preo, ino, inv_ino);\n  \n  bool fp = true;\n  print_postorder(nodes, preo[0], 1, fp); cout << endl; \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#define rep(i,k,n) for(int i=(int)(k);i<(int)(n);i++)\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r){\n    if(l>=r) return;\n    int root=pre[pos++];\n    int m=distance(in.begin(),find(in.begin(),in.end(),root));\n    rec(l,m);\n    rec(m+1,r);\n    post.push_back(root);\n}\n\nvoid solve(){\n    pos=0;\n    rec(0,pre.size());\n    rep(i,0,n){\n        if(i) cout<<\" \";\n        cout<<post[i];\n    }\n    cout<<endl;\n}\n\nint main(){\n    int k;\n    cin>>n;\n\n    rep(i,0,n){\n        cin>>k;\n        pre.push_back(k);\n    }\n\n    rep(i,0,n){\n        cin>>k;\n        in.push_back(k);\n    }\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct TNode\n{\n\tint Id;\n\tTNode* Parent;\n\tTNode* LChild;\n\tTNode* RChild;\n};\n\nvector<int> Input(int n)\n{\n\tvector<int> Tree(n);\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> Tree[i];\n\t}\n\treturn Tree;\n}\n\nvoid PostorderOutput(const TNode* Node)\n{\n\tif(Node == NULL) return;\n\tPostorderOutput(Node->LChild);\n\tPostorderOutput(Node->RChild);\n\tcout << ' ' << Node->Id;\n}\n\nTNode* MakeTree(const vector<int>& PreorderRow, const vector<int>& InorderRow)\n{\n\t\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<int> PreorderRow = Input(n);\n\tvector<int> InorderRow  = Input(n);\n\tTNode* RootNode = MakeTree(PreorderRow, InorderRow);\n\tPostorderOutput(RootNode);\n\tcout << endl;\n\tDeleteNode(RootNode);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <utility>\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n\nusing namespace std;\n\ntypedef uint64_t u64;\ntypedef int64_t s64;\ntypedef uint32_t u32;\ntypedef int32_t s32;\ntypedef vector<s32> vs32;\ntypedef vector<u32> vu32;\ntypedef vector<s64> vs64;\ntypedef vector<u64> vu64;\n\nconst double PI=3.14159265358979323846;\n\n#define MAX(x, y) ((x) < (y) ? (y) : (x))\n#define MIN(x, y) ((x) > (y) ? (y) : (x))\n\n#define rep(i, N) for(int i = 0; i < N; ++i)\n\n#define CEIL(x, y) (((x) + (y) - 1) / (y))\n#define MOD 1000000007ULL\n\nvs32 pre;\nvs32 in;\nvs32 ans;\n\nvoid solve(int prel, int prer, int inl, int inr)\n{\n    if (prel >= prer)\n    {\n        return;\n    }\n    int div = inr;\n    for (int i = inl; i < inr; ++i)\n    {\n        if (in[i] == pre[prel])\n        {\n            div = i;\n            break;\n        }\n    }\n    // cout << \"prel, prer, inl, inr, div = \" << prel << \", \" << prer << \", \" << inl << \", \" << inr << \", \" << div << \"\\n\";\n    solve(prel + 1, prel + 1 + div - inl, inl, div);\n    solve(prel + 1 + div - inl, prer, div + 1, inr);\n    // cout << \"push ans2 = \" << pre[prel] << \", \" << prel << \"\\n\";\n    ans.push_back(pre[prel]);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n\n    pre.resize(n);\n    in.resize(n);\n    rep (i, n) cin >> pre[i];\n    rep (i, n) cin >> in[i];\n\n    solve(0, n, 0, n);\n\n    rep (i, n)\n    {\n        if (i > 0) cout << \" \";\n        cout << ans[i];\n    }\n    cout << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r)\n{\n\tif (l >= r)return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\nvoid solve()\n{\n\tpos = 0;\n\trec(0, pre.size());\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tif (i)putchar(' ');\n\t\tcout << post[i];\n\t}\n\tputchar('\\n');\n}\n\nint main()\n{\n\tint k;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nstruct node{\n    int left,right;\n}nodes[100];\n\nint n,pre[105],in[105],inloc[105],cnt=0;\n\nint rec(int s,int e){\n    if(s<e){\n        int m=inloc[pre[cnt++]];\n        int l=rec(s,m-1);\n        int r=rec(m+1,e);\n        nodes[in[m]].left=l;\n        nodes[in[m]].right=r;\n        return in[m];\n    }\n    else if(s==e){cnt++;return in[s];}\n    else {return 0;}\n}\n\nvoid post(int r){\n    if(nodes[r].left!=0)post(nodes[r].left);\n    if(nodes[r].right!=0)post(nodes[r].right);\n    cout<<r;\n    if(r!=pre[0])cout<<\" \";\n}\n\nint main()\n{\n    memset(nodes,0,sizeof(nodes));\n    cin>>n;\n    int i;\n    for(i=0;i<n;i++){\n        cin>>pre[i];\n    }\n    for(i=0;i<n;i++){\n        cin>>in[i];\n        inloc[in[i]]=i;\n    }\n    int mm=rec(0,n-1);\n    post(pre[0]);\n    cout<<endl;\n    return 0;\n}\n//\n//int main(){\n//    int a[10]={1,2,3,4,5,32,62,23,8,33};\n//    int *b=find(a,a+10,62);\n//    int c=distance(a,b);\n//    cout<<c;\n//}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <climits>\n#include <cstring>\n#define rep(i, begin, end) for (__typeof(end) i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))\n\nusing namespace std;\n\nconst int N_MAX = 1000000;\nstring ans = \"\";\n/*\n pre: 4 2 3 1 5\n in:  3 2 4 5 1\n\n*/\nstruct Node{\n  int data;\n  Node* left;\n  Node* right;\n};\n\nvoid postorder(Node* root){\n  if(root == NULL) return;\n  postorder(root->left);\n  postorder(root->right);\n  //cout << root->data << \" \";\n  ans += (to_string(root->data) + \" \");\n}\n\n\nvoid print_array(int* arr, int len){\n  rep(i, 0, len){\n    cout << arr[i];\n    if(i==len-1) cout << endl;\n    else cout << \" \";\n  }\n}\n\nNode* solve(int* inorder, int* preorder, int len){\n  cout << \"inorder: \" << endl;\n  print_array(inorder, len);\n  \n  cout << \"preorder: \" << endl;\n  print_array(preorder, len);\n  \n  // find root\n  int root_data = preorder[0];\n  Node* root_node = new Node;\n  root_node->data = root_data;\n  if(len==1) return root_node;\n  \n  // count all the num left\n  int left_num=0;\n  while(inorder[left_num] != root_data) left_num++;\n  int right_num = len - left_num - 1;\n  \n  int* left_inorder = new int[left_num];\n  int* right_inorder = new int[right_num];\n  \n  int* left_preorder = new int[left_num];\n  int* right_preorder = new int[right_num];\n\n  int ix=0;\n  int l_ix=0, r_ix=0;\n\n  rep(ix, 0, len){\n    if(inorder[ix] == root_data) continue;\n    if(l_ix<left_num){\n      left_inorder[l_ix] = inorder[ix];\n      l_ix++;\n    }\n    else if(r_ix<right_num){\n      right_inorder[r_ix] = inorder[ix];\n      r_ix++;\n    }\n  }\n  \n  ix = 0; l_ix = 0; r_ix = 0;\n  \n  rep(ix, 1, len){\n    if(l_ix < left_num){\n      left_preorder[l_ix] = preorder[ix];\n      l_ix++;\n    }\n    else if(r_ix < right_num){\n      right_preorder[r_ix] = preorder[ix];\n      r_ix++;\n    }\n  }\n\n  if(left_num>0) root_node->left = solve(left_inorder, left_preorder, left_num);\n  if(right_num>0) root_node->right = solve(right_inorder, right_preorder, right_num);\n  \n  delete[] left_inorder;\n  delete[] right_inorder;\n  delete[] left_preorder;\n  delete[] right_preorder;\n  \n  return root_node;\n  \n}\n\nint main(){\n  int n; cin >> n;\n  int* inorder = new int[n];\n  int* preorder = new int[n];\n  \n  int tmp;\n  rep(i, 0, n){\n    cin >> tmp;\n    preorder[i] = tmp;\n  }\n  rep(i, 0, n){\n    cin >> tmp;\n    inorder[i] = tmp;\n  }\n\n  Node* root = NULL;\n  root = solve(inorder, preorder, n);\n  postorder(root);\n  rep(i, 0, 2*n-1) cout << ans[i]; \n  cout << endl;\n\n  delete[] inorder;\n  delete[] preorder;\n  delete root;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r){\n    if(l>=r)\n        return;\n    int root = pre[post++];\n    int m = distance(in.begin(),find(in.begin(),in.end(),root));\n    rec(l,m);\n    rec(m+l,r);\n    post.push_back(root);\n}\n\nvoid solve(){\n    pos = 0;\n    rec(0,pre.size());\n    for(int i=0;i<n;i++){\n        if(i)\n            cout<<\" \";\n        cout<<post[i];\n    }\n    cout<<endl;\n}\n\nint main(){\n    int k;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>k;\n        pre.push_back(k);\n    }\n    \n    for(int i=0;i<n;i++){\n        cin>>k;\n        in.push_back(k);\n    }\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nstruct TNode\n{\n\tint Index;\n\tTNode* Parent;\n\tTNode* Left;\n\tTNode* Right;\n\t\n\tTNode();\n};\n\nTNode::TNode()\n{\n\tIndex  = -1;\n\tParent = NULL;\n\tLeft   = NULL;\n\tRight  = NULL;\n}\n\ntypedef std::vector<TNode> TBinaryTree;\nvoid Initialize(TBinaryTree& BinaryTree)\n{\n\tfor(unsigned int i = 0; i < BinaryTree.size(); ++i){\n\t\tBinaryTree[i].Index = i + 1;\n\t}\n}\n\ntypedef std::vector<TNode*> TOrder;\n\nvoid InputNodes(TBinaryTree& Tree, TOrder& PreOrder, TOrder& InOrder)\n{\n\tfor(unsigned int i = 0; i < Tree.size(); ++i){\n\t\tint Index;\n\t\tstd::cin >> Index;\n\t\tPreOrder[i] = &(Tree[Index - 1]);\n\t}\n\tfor(unsigned int i = 0; i < Tree.size(); ++i){\n\t\tint Index;\n\t\tstd::cin >> Index;\n\t\tInOrder[i] = &(Tree[Index - 1]);\n\t}\n}\n\nvoid ReconstructTree(TOrder::iterator PreOrderPos,\n\t                 TOrder::iterator PreOrderLast,\n\t                 TOrder::iterator InOrderBegin,\n\t                 TOrder::iterator InOrderLast)\n{\n\tif(PreOrderPos == PreOrderLast) return;\n\tTOrder::iterator Position = std::find(InOrderBegin, InOrderLast + 1, *PreOrderPos);\n\tTOrder::iterator Left  = PreOrderPos + 1;\n\tTOrder::iterator Right = PreOrderPos + 1 + distance(InOrderBegin, Position);\n\tif(Position != InOrderBegin){\n\t\t(*PreOrderPos)->Left = *Left;\n\t\t(*Left)->Parent = *PreOrderPos;\n\t\tReconstructTree(Left, Right - 1, InOrderBegin, Position - 1);\n\t}\n\tif(Position != InOrderLast){\n\t\t(*PreOrderPos)->Right = *Right;\n\t\t(*Right)->Parent = *PreOrderPos;\n\t\tReconstructTree(Right, PreOrderLast, Position + 1, InOrderLast);\n\t}\n}\n\nvoid OutputPostOrder(const TNode* Root)\n{\n\tif(Root == NULL) return;\n\tOutputPostOrder(Root->Left);\n\tOutputPostOrder(Root->Right);\n\tstd::cout << Root->Index;\n\tif(Root->Parent != NULL){\n\t\tstd::cout << \" \";\n\t}else{\n\t\tstd::cout << std::endl;\n\t}\n}\n\nint main()\n{\n\tint Count;\n\tstd::cin >> Count;\n\tTBinaryTree BinaryTree(Count);\n\tInitialize(BinaryTree);\n\tTOrder PreOrder(Count);\n\tTOrder InOrder(Count);\n\t\n\tInputNodes(BinaryTree, PreOrder, InOrder);\n\t\n\tReconstructTree(PreOrder.begin(), PreOrder.end() - 1, InOrder.begin(), InOrder.end() - 1);\n\t\n\tTNode* Root = *(PreOrder.begin());\n\tOutputPostOrder(Root);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define PER(i,n) for(int i=n-1;i>=0;--i)\n#define REPA(i,n) for(int i=1;i<(n);++i)\n#define foreach(i, n) for(auto &i:(n))\n#define PII pair<int,int>\n#define PLI pair<long long, int>\n#define PLL pair<long long, long long>\n#define MOD ((LL)998244353) \n#define INF ((int)1e9+7)\n#define INFLL ((LL)1e18)\n#define ALL(x) (x).begin(),(x).end()\n#define BIT(x) (1LL << (x))\nusing namespace std;\n\nclass Tree{\npublic:\n\tint n;\n\tvector<int> p;\n\tvector<int> l;\n\tvector<int> r;\n\tvector<int> d;\n\tvector<int> h;\n\n\tTree(int N){\n\t\tn=N;\n\t\tp.resize(N, -1);\n\t\tl.resize(N, -1);\n\t\tr.resize(N, -1);\n\t\td.resize(N, -1);\n\t\th.resize(N, -1);\n\t}\n\n\tvoid add(int pa, int left, int right){\n\t\tif(left>=0){\n\t\t\tl[pa]=left;\n\t\t\tp[left]=pa;\n\t\t}\n\t\tif(right>=0){\n\t\t\tr[pa]=right;\n\t\t\tp[right]=pa;\n\t\t}\n\t}\n\n\tint get_brother(int id){\n\t\tif(p[id]==-1)return -1;\n\t\tint ll = l[p[id]];\n\t\tif(ll>=0&&ll!=id)return ll;\n\t\tint rr = r[p[id]];\n\t\tif(rr>=0&&rr!=id)return rr;\n\t\treturn -1;\n\t}\n\t\n\tint get_depth(int id){\n\t\tif(p[id] == -1)return 0;\n\t\tif(d[id] >= 0)return d[id];\n\t\treturn d[id] = get_depth(p[id]) + 1;\n\t}\n\n\tint get_height(int id){\n\t\tif(h[id]>=0)return h[id];\n\t\tint res = 0;\n\t\tif(r[id]>=0)res=max(res, get_height(r[id])+1);\n\t\tif(l[id]>=0)res=max(res, get_height(l[id])+1);\n\t\treturn h[id]=res;\n\t}\n\n\tint get_degree(int id){\n\t\tint res = 0;\n\t\tif(r[id]>=0)++res;\n\t\tif(l[id]>=0)++res;\n\t\treturn res;\n\t}\n\n\tint get_parent(int id){\n\t\treturn p[id];\n\t}\n\n\tint get_root(int id){\n\t\tif(p[id]==-1)return id;\n\t\treturn get_root(p[id]);\n\t}\n\n\tvector<int> get_preorder(int id){\n\t\tif(id==-1)return vector<int>(0);\n\t\tvector<int> res;\n\t\tres.push_back(id);\n\t\tvector<int> d;\n\t\td = get_preorder(l[id]);\n\t\tres.insert(res.end(), ALL(d));\n\t\td = get_preorder(r[id]);\n\t\tres.insert(res.end(), ALL(d));\n\t\treturn res;\n\t}\n\t\n\tvector<int> get_inorder(int id){\n\t\tif(id==-1)return vector<int>(0);\n\t\tvector<int> res;\n\t\tvector<int> d;\n\t\td = get_inorder(l[id]);\n\t\tres.insert(res.end(), ALL(d));\n\t\tres.push_back(id);\n\t\td = get_inorder(r[id]);\n\t\tres.insert(res.end(), ALL(d));\n\t\treturn res;\n\t}\n\tvector<int> get_postorder(int id){\n\t\tif(id==-1)return vector<int>(0);\n\t\tvector<int> res;\n\t\tvector<int> d;\n\t\td = get_postorder(l[id]);\n\t\tres.insert(res.end(), ALL(d));\n\t\td = get_postorder(r[id]);\n\t\tres.insert(res.end(), ALL(d));\n\t\tres.push_back(id);\n\t\treturn res;\n\t}\n};\n\nvoid output(int d){\n\tstatic bool used = false;\n\tif(used)cout << \" \";\n\tcout << d;\n\tused=true;\n}\n\nvector<int> pr;\nvector<int> in;\nint p = -1;\n\nvoid func(int l, int r){\n\tif(l==r)return;\n\tint j;\n\t++p;\n\tint tmp = pr[p];\n\tfor(j=l;j<r;++j){\n\t\tif(pr[p]==in[j]){\n\t\t\tfunc(l, j);\n\t\t\tfunc(j+1, r);\n\t\t\tbreak;\n\t\t}\n\t}\n\toutput(tmp);\n}\n\nint main(){\n\tint N;\n\tcin >> N;\n\tpr.resize(N);\n\tin.resize(N);\n\tforeach(i, pr)cin>>i;\n\tforeach(i, in)cin>>i;\n\tfunc(0, N);\n\tcout << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iterator>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\nvoid print_postorder(size_t, size_t, size_t, size_t);\n\nvector<int> pre;\nvector<int> in;\nbool printed = false;\n\nint main() {\n  int n; cin >> n;\n  pre = vector<int>(n);\n  in = vector<int>(n);\n  for (int i = 0; i < n; ++i)\n    cin >> pre[i];\n  for (int i = 0; i < n; ++i)\n    cin >> in[i];\n  print_postorder(0, n, 0, n);\n  cout << endl;\n}\n\nvoid pprint(int val) {\n  if (!printed) {\n    cout << val;\n    printed = true;\n  } else {\n    cout << ' ' << val;\n  }\n}\n\n// ranges: [start, end)\nvoid print_postorder(size_t pidx, size_t pend, size_t iidx, size_t iend) {\n  if (pidx >= pend) {\n    return;\n  } else if (pidx + 1 >= pend) {\n    pprint(pre[pidx]);\n    return;\n  }\n  int root_id = pre[pidx];\n  auto root_it = find(in.begin(), in.end(), root_id);\n  int left_subtree_size = distance(in.begin() + iidx, root_it);\n  print_postorder(pidx + 1, pidx + 1 + left_subtree_size, iidx, iidx + left_subtree_size);\n  print_postorder(pidx + left_subtree_size + 1, pend, iidx + left_subtree_size + 1, iend);\n  pprint(root_id);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\n#define MAX_V 41\nstruct node{\n  int id,parent,left,right,sibling;\n  node():id(0),parent(-1),left(-1),right(-1),sibling(-1){}\n};\nnode nodes[MAX_V]{};\n\nvoid set_node(int id, int left,int right){\n  nodes[id].id=id;\n  nodes[id].left=left;\n  nodes[id].right=right;\n  if(left>=0){\n    nodes[left].id=left;\n    nodes[left].parent=id;\n    nodes[left].sibling=right;\n  }\n  if(right>=0){\n    nodes[right].id=right;\n    nodes[right].parent=id;\n    nodes[right].sibling=left;\n  }\n}\nvoid printPostorder(node n,bool last=false){\n  if(n.left>=0) printPostorder(nodes[n.left]);\n  if(n.right>=0) printPostorder(nodes[n.right]);\n  cout<<n.id<<(last?\"\\n\":\" \");\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  vector<int> pre;\n  vector<int> in;\n  int n; cin>>n;\n  REP(i,n) {int tmp; cin>>tmp; pre.push_back(tmp);}\n  REP(i,n) {int tmp; cin>>tmp; in.push_back(tmp);}\n\n  while(true){\n    bool found=false;\n    for(int i=pre.size()-2;i>=0;i--){\n      for(int j=in.size()-2;j>=0;j--){\n\tif(i<(int)pre.size()-2&&j<(int)in.size()-2){\n\t  if(pre[i]==in[j+1]&&pre[i+1]==in[j]&&pre[i+2]==in[j+2]){\n\t    set_node(pre[i],pre[i+1],pre[i+2]);\n\t    auto iter=pre.begin();\n\t    REP(k,i+1) iter++;\n\t    pre.erase(iter); pre.erase(iter);\n\t    iter=in.begin();\n\t    REP(k,j) iter++;\n\t    in.erase(iter);iter++;in.erase(iter);\n\t    found=true; break;\n\t  }\n\t}\n\tif(pre[i]==in[j]&&pre[i+1]==in[j+1]){\n\t  set_node(pre[i],-1,pre[i+1]);\n\t  auto iter=pre.begin();\n\t  REP(k,i+1) iter++;\n\t  pre.erase(iter);\n\t  iter=in.begin();\n\t  REP(k,j+1) iter++;\n\t  in.erase(iter);\n\t  found=true; break;\n\t}\n\tif(pre[i]==in[j+1]&&pre[i+1]==in[j]){\n\t  set_node(pre[i],pre[i+1],-1);\n\t  auto iter=pre.begin();\n\t  REP(k,i+1) iter++;\n\t  pre.erase(iter);\n\t  iter=in.begin();\n\t  REP(k,j+1) iter++;\n\t  in.erase(iter);\n\t  found=true; break;\n\t}\n      }\n      if(found){break;}\n    }\n    if((int)pre.size()==1){break;}\n  }\n  int root=1;\n  while(nodes[root].parent!=-1)\n    root=nodes[root].parent;\n  printPostorder(nodes[root],true);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace  std;\n\nvoid fnInput(vector<int> &rvnPodr, vector<int> &rvnIodrSeq)\n{\n  int nMaxSiz;\n\n  cin >> nMaxSiz;\n  rvnPodr.resize(nMaxSiz + 1);\n  rvnIodrSeq.resize(nMaxSiz + 1);\n\n  for (int i = 1; i < nMaxSiz + 1; i++)\n    cin >> rvnPodr[i];\n\n  int nNode;\n  for (int i = 1; i < nMaxSiz + 1; i++)\n  {\n    cin >> nNode;\n    rvnIodrSeq[nNode] = i;\n  }\n}\n\nvoid fnPostOrder(const vector<int> &cnrvnPodr, const vector<int> &cnrvnIodrSeq, int nLeft, int nRight)\n{\n  static int stnx = 1;\n  static int stnPrt = 0;\n\n  if (nLeft == nRight) return;\n\n  int nNode = cnrvnPodr[stnx++];\n  int nMid = cnrvnIodrSeq[nNode];\n\n  fnPostOrder(cnrvnPodr, cnrvnIodrSeq, nLeft, nMid);\n  fnPostOrder(cnrvnPodr, cnrvnIodrSeq, nMid + 1, nRight);\n\n  if (stnPrt++) cout << \" \";\n  cout << nNode;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vector<int> vnPodr, vnIodrSeq;\n  fnInput(vnPodr, vnIodrSeq);\n\n  fnPostOrder(vnPodr, vnIodrSeq, 1, vnPodr.size());\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <sstream>\n#include <vector>\n#include <stack>\n#include <memory>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\nvoid rec(int l,int r);\nvoid solve();\nint main(){\n    //freopen(\"/Users/mac/Desktop/C++?¨????/test/test.txt\", \"r\", stdin);\n    int k;\n    cin>>n;\n    for (int i=0; i<n; i++) {\n        cin>>k;\n        pre.push_back(k);\n    }\n    for (int i=0; i<n; i++) {\n        cin>>k;\n        in.push_back(k);\n    }\n    solve();\n    return 0;\n}\n\nvoid rec(int l,int r)\n{\n    if (l>=r) {\n        return;\n    }\n    int root=pre[pos++];\n    int m=(int)distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m+1, r);\n    post.push_back(root);\n}\nvoid solve()\n{\n    pos=0;\n    rec(0, (int)pre.size());\n    for (int i=0; i<n; i++) {\n        if (i) {\n            cout<<\" \";\n        }\n        cout<<post[i];\n    }\n    cout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n    if ( l >= r ) return;\n     int root = pre[pos++];\n     int m = distance(in.begin(), find(in.begin(), in.end(), root));\n     rec(l, m);\n     rec(m + 1, r);\n     post.push_back(root);\n     }\n\nvoid solve() {\n     pos = 0;\n     rec(0, pre.size());\n     for ( int i = 0; i < n; i++ ) {\n        if ( i ) cout << \" \";\n         cout << post[i];\n         }\n     cout << endl;\n}\n\nint main(){\n    int k; cin >> n;\n    for ( int i = 0; i < n; i++ ) {\n        cin >> k;\n        pre.push_back(k);\n    }\n    for ( int i = 0; i < n; i++ ) {\n        cin >> k;\n        in.push_back(k);\n}\n    \n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\n\nint j=0,k=0;\nvector<int> in,pre;\n\nint search(int n)\n{\n\tint i=0;\n\twhile(in[i]!=n)\n\t{\n\t\ti++;\n\t}\n\treturn i;\n}\n\nvoid rec(int l,int r)\n{\n\tint c,m;\n\t\n\tc=pre[j];\n\tj++;\n\tif(l>r) return;\n\tif(l==r)\n\t{\n\t\tif(++k>1) printf(\" \");\n\t\tprintf(\"%d\",in[l]);\n\t\treturn;\n\t}\n\tm=search(c);\n\trec(l,m-1);\n\trec(m+1,r);\n\tif(++k>1) printf(\" \");\n\tprintf(\"%d\",in[m]);\n\treturn;\n}\n\nint main()\n{\n\tint i,n,temp;\n\t\n\tcin >> n;\n\t\n\tfor(i=0;i<=n-1;i++)\n\t{\n\t\tcin >> temp;\n\t\tpre.push_back(temp);\n\t}\n\tfor(i=0;i<=n-1;i++)\n\t{\n\t\tcin >> temp;\n\t\tin.push_back(temp);\n\t}\n\trec(0,n-1);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//?????????????????????: Reconstruction of a Tree\n//????????????: ???????????¨?§????????????????????????????????±??????°??????????????????????????????????????????\n//????????????: 57-15,\n//?????´?????????:\n\n#include <iostream>\nusing namespace std;\n\nvoid tree(int n,int pre[],int in[],bool top){\n  if(n==0) return;\n  if(n==1){\n    cout << pre[0];\n    if(top) cout << endl;\n    else cout << ' ';\n    return;\n  }\n  \n  int r_index;\n  for(r_index=0;in[r_index]!=pre[0];r_index++) ;\n\n  int rpre[40], rin[40], lpre[40], lin[40];\n  for(int i=0;i<r_index;i++){\n    lpre[i]=pre[i+1];\n    lin[i]=in[i];\n  }\n  for(int i=r_index+1;i<n;i++){\n    rpre[i-r_index]=pre[i];\n    rin[i-r_index]=in[i];\n  }\n\n  tree(r_index,lpre,lin,false);\n  tree(n-r_index-1,rpre,rin,false);\n  cout << pre[0];\n  if(top)\n    cout << endl;\n  else\n    cout << ' ';\n}\n\nint main(){\n  int n;\n  cin >> n;\n\n  int pre[40], in[40];\n  for(int i=0;i<n;i++)\n    cin >> pre[i];\n  for(int i=0;i<n;i++)\n    cin >> in[i];\n\n  tree(n,pre,in,true);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define NIL -1\n\ntypedef struct node {\n    int p, l, r;\n}Node;\n\nNode T[100];\nint pre[100];\nint in[100];\nint post[99];\nint pos = 0;\nint pos2 = 0;\nint findPos(){\n    for (int i = 1; i < 100; i++)\n        if (in[i] == pre[pos])\n            return i;\n    return NIL;\n}\n\nvoid rebuild(int l, int r){\n    if (l >= r) return ;\n\n    int c = pre[++pos];\n\n    int mid = findPos(); \n    rebuild (l, mid);\n    rebuild (mid+1, r);\n    post[pos2++] = c;\n}\n\nint main(){\n    int n, num, p;\n    int root;\n    \n    scanf(\"%d\", &n);\n    for (int i = 1 ; i <= n; i++){\n        T[i].p = NIL;\n    }\n    for(int i = 1; i <= n; i++){\n        scanf (\"%d\", &pre[i]);\n    }\n    for(int i = 1; i <= n; i++){\n        scanf (\"%d\", &in[i]);\n        // if (in[i] == pre[1]) root = in[i];\n    }\n\n    rebuild(1, n+1);\n    // printPostorder();\n    for (int i= 0; i < n; i++){\n        if (i) printf(\" \");\n        printf(\"%d\", post[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint n;\nint pre[40];\nint in[40];\nvector<int> past;\n\n//pre[id]??????????????????, in[l, r)?????¨?????¨v???????????????\nvoid dfs(int id, int l, int r) {\n\tif (r - l == 1) {\n\t\tpast.push_back(pre[id]);\n\t\treturn;\n\t}\n\t\n\tint i;\n\tfor (i = 0; i < r - l; i++) {\n\t\tif (in[l + i] == pre[id]) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i > 0) {\n\t\tdfs(id + 1, l, l + i);\n\t}\n\tif (l + i + 1 < r) {\n\t\tdfs(id + 1 + i, l + i + 1, r);\n\t}\n\tpast.push_back(pre[id]);\n}\n\nint main() {\n\tint i;\n\tcin >> n;\n\tfor (i = 0; i < n; i++) cin >> pre[i];\n\tfor (i = 0; i < n; i++) cin >> in[i];\n\tdfs(0, 0, n);\n\t\n\tfor (i = 0; i < past.size(); i++) {\n\t\tcout << past[i];\n\t\tif (i + 1 < past.size()) cout << \" \";\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nclass Node\n{\npublic:\n    Node() {\n        this->_id = 0;\n        this->_left = 0;\n        this->_right = 0;\n        this->_parent = 0;\n    }\n\n    Node(int id) {\n        this->_id = id;\n        this->_left = 0;\n        this->_right = 0;\n        this->_parent = 0;\n    }\n\n    ~Node() {\n        ;\n    }\n\n    // Accessor\n    const int& id() const {\n        return this->_id;\n    }\n\n    int& id() {\n        return this->_id;\n    }\n\n    const int& left() const {\n        return this->_left;\n    }\n\n    int& left() {\n        return this->_left;\n    }\n\n    const int& right() const {\n        return this->_right;\n    }\n\n    int& right() {\n        return this->_right;\n    }\n\n    const int& parent() const {\n        return this->_parent;\n    }\n\n    int& parent() {\n        return this->_parent;\n    }\n\nprivate:\n    int _id;\n    int _left;\n    int _right;\n    int _parent;\n};\n\nstd::vector<Node> nodelist;\n\nvoid postorder(int id)\n{\n    int l = nodelist[id].left();\n    int r = nodelist[id].right();\n    if (l != 0)\n        postorder(l);\n    if (r != 0)\n        postorder(r);\n    cout << id << \" \";\n\n    return;\n}\n\nvoid maketree(std::vector<int>& pre, std::vector<int>& in)\n{\n    // cout << endl;\n\n    int root = pre[0];\n\n    std::vector<int> leftin;\n    std::vector<int> rightin;\n\n    // find root index in inorder\n    auto rootitr = std::find(in.begin(), in.end(), root);\n\n    // copy left and right subtrees\n    std::copy(in.begin(), rootitr, std::back_inserter(leftin));\n    std::copy(rootitr + 1, in.end(), std::back_inserter(rightin));\n\n    // Debug print\n    // cout << \"pre-order : \";\n    // for (int i = 0; i < pre.size(); i++) {\n    //     cout << pre[i] << \" \";\n    // }\n    // cout << endl;\n    // cout << \"in-order : \";\n    // for (int i = 0; i < in.size(); i++) {\n    //     cout << in[i] << \" \";\n    // }\n    // cout << endl;\n    // cout << \"root = \" << root << endl;\n    // cout << \"left subtree : \";\n    // for (int i = 0; i < leftin.size(); i++) {\n    //     cout << leftin[i] << \" \";\n    // }\n    // cout << endl;\n    // cout << \"right subtree : \";\n    // for (int i = 0; i < rightin.size(); i++) {\n    //     cout << rightin[i] << \" \";\n    // }\n    // cout << endl;\n\n    // construct pre-order from two subtrees\n    // pre-order of left subtree\n    std::vector<int> leftpre;\n    if (leftin.size() > 0) {\n        int limin = *std::min_element(leftin.begin(), leftin.end());\n        int limax = *std::max_element(leftin.begin(), leftin.end());\n        std::copy(std::find(pre.begin(), pre.end(), limin),\n                  std::find(pre.begin(), pre.end(), limax) + 1,\n                  std::back_inserter(leftpre));\n    }\n\n    // pre-order of right subtree\n    std::vector<int> rightpre;\n    if (rightin.size() > 0) {\n        int rimin = *std::min_element(rightin.begin(), rightin.end());\n        int rimax = *std::max_element(rightin.begin(), rightin.end());\n        std::copy(std::find(pre.begin(), pre.end(), rimin),\n                  std::find(pre.begin(), pre.end(), rimax) + 1,\n                  std::back_inserter(rightpre));\n    }\n\n    // Debug print\n    // cout << \"pre-order of left subtree : \";\n    // for (int i = 0; i < leftpre.size(); i++) {\n    //     cout << leftpre[i] << \" \";\n    // }\n    // cout << endl;\n    // cout << \"pre-order of right subtree : \";\n    // for (int i = 0; i < rightpre.size(); i++) {\n    //     cout << rightpre[i] << \" \";\n    // }\n    // cout << endl;\n\n    // set children\n    if (leftpre.size() > 0) {\n        // cout << \"Left child of \" << root << \" = \" << leftpre[0] << endl;\n        nodelist[root].left() = leftpre[0];\n    }\n    if (rightpre.size() > 0) {\n        // cout << \"Right child of \" << root << \" = \" << rightpre[0] << endl;\n        nodelist[root].right() = rightpre[0];\n    }\n\n    if (leftpre.size() > 1)\n        maketree(leftpre, leftin);\n    if (rightpre.size() > 1)\n        maketree(rightpre, rightin);\n\n    // cout << endl;\n}\n\nint main(int argc, char const *argv[])\n{\n    int n;\n    cin >> n;\n\n    // initialize nodelist\n    nodelist.resize(n + 1);\n\n    std::vector<int> pre(n);\n    std::vector<int> in(n);\n    // input\n    for (int i = 0; i < n; i++) {\n        cin >> pre[i];\n        // set node id\n        nodelist[i + 1].id() = i + 1;\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> in[i];\n    }\n\n    // construct tree\n    maketree(pre, in);\n\n    // Debug print\n    // cout << endl;\n    // for (int i = 1; i <= n; i++) {\n    //     cout << \"id: \" << nodelist[i].id() << \", left: \" << nodelist[i].left() << \", right: \" << nodelist[i].right() << endl;\n    // }\n\n    // print post-order (argument is id of root)\n    postorder(pre[0]);\n    cout << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define NIL -1\nstruct Node{int parent,left,right;};\nstruct Node T[41];\nint n,P[41],I[41];\nint search(int x[],int target,int size){\n    for(int i=0;i<size;i++){\n        if(x[i]==target) return i;\n    }\n    return 0;\n}\nbool tansaku(int target,int x[],int size){\n    for(int i=0;i<size;i++){\n        if(x[i]==target) return true;\n    }\n    return false;\n}\nvoid Postorder(int x){\n    if(x!=NIL){\n        Postorder(T[x].left);\n        Postorder(T[x].right);\n        if(x==P[0]) cout<<x;\n        else cout<<x<<\" \";\n    }\n}\nvoid saisei(int x[],int s,int p,int size){\n    int l=0,r=0,mid=search(x,s,size);\n    int L[40],R[40];\n    \n    for(int i=0;i<size;i++){\n        if(i<mid){L[l]=x[i];l++;}\n        else if(i>mid){R[r]=x[i];r++;}\n    }\n    if(l!=0){\n        if(tansaku(P[p+1],L,l)){\n            T[P[p]].left=P[p+1];\n            T[P[p+1]].parent=P[p];\n            saisei(L,P[p+1],p+1,l);\n        }\n    }\n    if(r!=0){\n        if(tansaku(P[p+l+1],R,r)){\n            T[P[p]].right=P[p+l+1];\n            T[P[p+l+1]].parent=P[p];\n            saisei(R,P[p+l+1],p+l+1,r);\n        }\n    }\n    \n}\nint main(){\n    cin>>n;\n    for(int i=0;i<n;i++) cin>>P[i];\n    for(int i=0;i<n;i++) {\n        cin>>I[i];\n        T[i+1].parent=T[i+1].left=T[i+1].right=NIL;\n    }\n    saisei(I,P[0],0,n);\n    Postorder(P[0]); cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(auto i=0;i<n;i++)\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n\tif(l >= r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m+1, r);\n\tpost.push_back(root);\n}\n\nvoid solve(){\n\tpos = 0;\n\trec(0, pre.size());\n\tcout << post[0];\n\tfor(int i = 1; i < n; i++){\n\t\tcout << ' ' << post[i];\n\t}\n\tcout << endl;\n}\n\nint main(){\n\tint k;\n\tcin >> n;\n\tr(i, n){\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\tr(i, n){\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define P pair<int,int>\n#define FOR(I,A,B) for(int I = int(A); I < int(B); ++I)\n\nP tree[55];\nint A[55],B[55],indexA[55],indexB[55];\nint n;\n\nbool fir = true;\nvoid Postorder(int i=A[0]){\n\tif(~tree[i].first)Postorder(tree[i].first);\n\tif(~tree[i].second)Postorder(tree[i].second);\n\tcout << (fir?\"\":\" \") << i;\n\tfir = false;\n}\n\nvoid make_tree(int l=0,int r=n,int p=A[0]){\n\tint left,right,indl=1000,indr=1000;\n\tFOR(i,l,indexB[p]){\n\t\tif(indl>indexA[B[i]]){\n\t\t\tindl = indexA[B[i]];\n\t\t\tleft = B[i];\n\t\t}\n\t}\n\tFOR(i,indexB[p]+1,r){\n\t\tif(indr>indexA[B[i]]){\n\t\t\tindr = indexA[B[i]];\n\t\t\tright = B[i];\n\t\t}\n\t}\n\tif(indl!=1000)tree[p].first = left;\n\tif(indr!=1000)tree[p].second = right;\n\tif(indl!=1000)make_tree(l,indexB[p],left);\n\tif(indr!=1000)make_tree(indexB[p]+1,r,right);\n}\n\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tFOR(i,0,55) tree[i].first=tree[i].second=-1;\n\tmemset(A,-1,sizeof(A));\n\tmemset(B,-1,sizeof(B));\n\tmemset(indexA,-1,sizeof(indexA));\n\tmemset(indexB,-1,sizeof(indexB));\n\n\tcin >> n;\n\tFOR(i,0,n){\n\t\tcin >> A[i];\n\t\tindexA[A[i]] = i;\n\t}\n\tFOR(i,0,n){\n\t\tcin >> B[i];\n\t\tindexB[B[i]] = i;\n\t}\n\tmake_tree();\n\tPostorder();\n\tcout << '\\n';\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 40;\n\nint l[MAX], r[MAX];\n\nvoid dfs(int v, vector<int>& res) {\n\tif (l[v] != -1) dfs(l[v], res);\n\tif (r[v] != -1) dfs(r[v], res);\n\tres.push_back(v);\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<int> p(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> p[i]; p[i]--;\n\t}\n\tvector<int> c(n), rc(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> c[i]; c[i]--;\n\t\trc[c[i]] = i;\n\t}\n\tfill(l, l + n, -1);\n\tfill(r, r + n, -1);\n\tint id = 0;\n\tset<int> vs;\n\tfor (int i = 1; i < n; i++) {\n\t\tvs.insert(rc[p[id]]);\n\t\twhile (true) {\n\t\t\tauto it = vs.upper_bound(min(rc[p[i]], rc[p[id]]));\n\t\t\tif (it == vs.end() || *it >= max(rc[p[i]], rc[p[id]])) break;\n\t\t\tid--;\n\t\t}\n\t\tif (rc[p[id]] > rc[p[i]]) {\n\t\t\tl[p[id]] = p[i];\n\t\t}\n\t\telse {\n\t\t\tr[p[id]] = p[i];\n\t\t}\n\t\tid = i;\n\t}\n\tvector<int> res;\n\tdfs(p[0], res);\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << res[i] + 1 << \" \\n\"[i + 1 == n];\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\n#define MAX_V 40\nstruct node{\n  int id,parent,left,right,sibling;\n  node():id(0),parent(-1),left(-1),right(-1),sibling(-1){}\n};\nnode nodes[MAX_V]{};\n\nvoid set_node(int id, int left,int right){\n  nodes[id].id=id;\n  nodes[id].left=left;\n  nodes[id].right=right;\n  if(left>=0){\n    nodes[left].parent=id;\n    nodes[left].sibling=right;\n  }\n  if(right>=0){\n    nodes[right].parent=id;\n    nodes[right].sibling=left;\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  vector<int> pre;\n  vector<int> in;\n  vector<int> post;\n  int n; cin>>n;\n  REP(i,n) {\n    int tmp; cin>>tmp;\n    pre.push_back(tmp);\n  }\n  REP(i,n) {\n    int tmp; cin>>tmp;\n    in.push_back(tmp);\n  }\n  int looked=-1;\n  while(true){\n    bool b=false;\n    for(int i=0;i<n-2;i++){\n      for(int j=0;j<n-2;j++){\n\tif(pre[i]==in[j+1]&&pre[i+1]==in[j]&&pre[i+2]==in[j+2]){\n\t  if(pre[i+1]>0) post.push_back(pre[i+1]);\n\t  if(pre[i+2]>0) post.push_back(pre[i+2]);\n\t  if(pre[i]>0) post.push_back(pre[i]);\n\t  auto iter=pre.begin();\n\t  REP(k,i) iter++;\n\t  pre.erase(iter);\n\t  pre.erase(iter);\n\t  (*iter)=looked;\n\t  iter=in.begin();\n\t  REP(k,j) iter++;\n\t  in.erase(iter);\n\t  in.erase(iter);\n\t  (*iter)=looked;\n\t  looked--;\n\t  b=true; break;\n\t}\n      }\n      if(b) break;\n    }\n    if(pre.size()==1) break;\n  }\n  for(int a:post){\n    if(a==*(--post.end())) cout<<a<<endl;\n    else cout<<a<<\" \";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define NUL -1\nconst int N_MAX = 45;\nint root;\nstruct Node{\n    int parent, left, right;\n};\nNode tree[N_MAX];\nint pre[N_MAX], in[N_MAX];\n\nvoid reConstruct(int parent, int * preP, int * inP, int n, bool isLeft){\n    if(n==0) return;\n    int nowRoot = preP[0];\n    tree[nowRoot].parent = parent;\n    //getchar();\n    //cout<<\"-- nowRoot: \"<<nowRoot<<endl;\n    if(parent==NUL){\n        root=nowRoot;\n    }else if(isLeft){\n        tree[parent].left=nowRoot;\n    }else{\n        tree[parent].right=nowRoot;\n    }\n    if(n==1)return;\n    int flag = 0;\n    for(;flag<n;flag++){\n        if(inP[flag]==nowRoot) break;\n    }\n    //cout<<\"nowRoot: \"<<nowRoot<<\" flag: \"<<flag<<endl;\n    reConstruct(nowRoot, preP+1, inP, flag, true);\n    reConstruct(nowRoot, preP+1+flag, inP+1+flag, n-flag-1, false);\n}\n\nvoid post(int id){\n    if(id==NUL) return;\n    if(tree[id].left==NUL&&tree[id].right==NUL&&id!=root){\n        cout<<id<<\" \";\n        return;\n    }\n    post(tree[id].left);\n    post(tree[id].right);\n    if(id==root){\n        cout<<id<<endl;\n    }else{\n        cout<<id<<\" \";\n    }\n}\n\nint main(){\n    int n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>pre[i];\n        tree[i].parent=tree[i].left=tree[i].right=NUL;\n    }\n    tree[n].parent=tree[n].left=tree[n].right=NUL;\n    for(int i=0;i<n;i++){\n        cin>>in[i];\n    }\n    reConstruct(NUL, pre, in, n, true);\n    /*//Debugging/\n    for(int i=1;i<=n;i++){\n        cout<<\"node\"<<i<<\": p: \"<<tree[i].parent<<\"  l: \"<<tree[i].left<<\"  r: \"<<tree[i].right<<endl;\n    }\n    ///Debugging*/\n    post(root);\n    //cout<<\"root: \"<<root<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,m,a[40],b[40],c[41];\nvoid solve(int l,int r){\n  //cout<<\"l:\"<<l<<\",r:\"<<r<<\",m:\"<<m<<endl;//確認用\n  if(l>r)return;\n  int x=a[m++];\n  //cout<<\"x:\"<<x<<\",c[x]-1:\"<<c[x]-1<<\",c[x]+1:\"<<c[x]+1<<endl;//確認用\n  solve(l,c[x]-1);\n  solve(c[x]+1,r);\n  cout<<x<<\" \\n\"[x==a[0]];\n}\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>a[i];\n  for(int i=0;i<n;i++)cin>>b[i],c[b[i]]=i;\n  solve(0,n-1);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint pre[100000], in[100000], post[100000], n, pos, cnt;\nvoid rec(int l, int r) { if (l >= r) { return; }int root = pre[pos++]; int m = 0; for (int i = 0; i < n; i++) { if (in[i] == root) { m = i; } }rec(l, m); rec(m + 1, r); post[cnt] = root; cnt++; }\nint main() { cin >> n; for (int i = 0; i < n; i++) { cin >> pre[i]; }for (int i = 0; i < n; i++) { cin >> in[i]; }rec(0, n); for (int i = 0; i < n; i++) { if (i) { cout << ' '; }cout << post[i]; }cout << endl; return 0; }"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) (a)>(b)?(b):(a)\n#define max(a,b) (a)>(b)?(a):(b)\n\nusing namespace std;\n\nenum struct Type\n{\n\tROOT,\n\tINTERNAL,\n\tLEAF\n};\n\nstruct OwnNode\n{\n\tint id;\n\tint parent;\n\tint depth;\n\tint height;\n\tint sibling;\n\tType type;\n\tint left;\n\tint right;\n};\n\nOwnNode tree[100001];\nbool isChild[100001];\nconst string typeStr[] = { \"root\",\"internal node\",\"leaf\" };\n\nint TrackTree(int parentid,int id, int depth)\n{\n\t/*int height = 0;\n\ttree[id].parent = parentid;\n\ttree[id].depth = depth;\n\tfor (int i = 0; i != tree[id].children.size(); i++)\n\t{\n\t\theight = max(height, TrackTree(id, tree[id].children[i], depth + 1));\n\t}\n\tif (tree[id].children.size() == 2)\n\t{\n\t\ttree[tree[id].children[0]].sibling = tree[tree[id].children[1]].id;\n\t\ttree[tree[id].children[1]].sibling = tree[tree[id].children[0]].id;\n\t}\n\ttree[id].height = height;\n\treturn height + 1;*/\n\treturn 0;\n}\n\nvoid PreOrder(int id)\n{\n\tprintf(\" %d\", id);\n\tif (tree[id].left!=-1)\n\t{\n\t\tPreOrder(tree[id].left);\n\t}\n\tif (tree[id].right!=-1)\n\t{\n\t\tPreOrder(tree[id].right);\n\t}\n}\n\nvoid InOrder(int id)\n{\n\tif (tree[id].left != -1)\n\t{\n\t\tInOrder(tree[id].left);\n\t}\n\tprintf(\" %d\", id);\n\tif (tree[id].right != -1)\n\t{\n\t\tInOrder(tree[id].right);\n\t}\n}\n\nvoid PostOrder(int id, int cnt)\n{\n\tif (tree[id].left != -1)\n\t{\n\t\tPostOrder(tree[id].left,1);\n\t}\n\tif (tree[id].right != -1)\n\t{\n\t\tPostOrder(tree[id].right,1);\n\t}\n\tif (cnt == 0)\n\t{\n\t\tprintf(\"%d\", id);\n\t}\n\telse\n\t{\n\t\tprintf(\"%d \", id);\n\t}\n}\n\nint Reconstruct(int a[], int b[], int n)\n{\n\tif (n == 1)\n\t{\n\t\ttree[a[0]].left = -1;\n\t\ttree[a[0]].right = -1;\n\t\treturn a[0];\n\t}\n\n\tint tempi = -1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (b[i] == a[0])\n\t\t{\n\t\t\ttempi = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tint* a1 = new int[tempi];\n\tint* a2 = new int[n - tempi - 1];\n\tint* b1 = new int[tempi];\n\tint* b2 = new int[n - tempi - 1];\n\n\tfor (int i = 0; i < tempi; i++)\n\t{\n\t\ta1[i] = a[i + 1];\n\t\tb1[i] = b[i];\n\t}\n\tfor (int i = 0; i < (n - tempi - 1); i++)\n\t{\n\t\ta2[i] = a[tempi + 1 + i];\n\t\tb2[i] = b[tempi + 1 + i];\n\t}\n\n\tint left, right;\n\tif (tempi != 0)\n\t{\n\t\tleft = Reconstruct(a1, b1, tempi);\n\t\tisChild[left] = true;\n\t\t//printf(\"left:%d\\n\", left);\n\t}\n\telse\n\t{\n\t\tleft = -1;\n\t}\n\tif ((n - tempi - 1) != 0)\n\t{\n\t\tright = Reconstruct(a2, b2, n - tempi - 1);\n\t\tisChild[right] = true;\n\t\t//printf(\"right:%d\\n\", right);\n\t}\n\telse\n\t{\n\t\tright = -1;\n\t}\n\n\ttree[b[tempi]].left = left;\n\ttree[b[tempi]].right = right;\n\n\tdelete[] a1;\n\tdelete[] a2;\n\tdelete[] b1;\n\tdelete[] b2;\n\n\treturn b[tempi];\n}\n\nint main()\n{\n\tint n;\n\tint a[50], b[50];\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> b[i];\n\t}\n\n\t/*for (int i = 0; i < n; i++)\n\t{\n\t\tint id,left,right;\n\t\tscanf(\"%d %d %d\", &id, &left, &right);\n\n\t\ttree[id].id = id;\n\t\ttree[id].depth = 0;\n\t\ttree[id].sibling = -1;\n\t\ttree[id].parent = -1;\n\t\ttree[id].left = left;\n\t\ttree[id].right = right;\n\n\t\tif (left != -1)\n\t\t{\n\t\t\tisChild[left] = true;\n\t\t}\n\t\tif (right != -1)\n\t\t{\n\t\t\tisChild[right] = true;\n\t\t}\n\t}*/\n\n\tReconstruct(a, b, n);\n\n\tint rootID = -1;\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tif (!isChild[i])\n\t\t{\n\t\t\trootID = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*TrackTree(-1, rootID, 0);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (tree[i].parent == -1)\n\t\t{\n\t\t\ttree[i].type = Type::ROOT;\n\t\t}\n\t\telse if (tree[i].children.size() == 0)\n\t\t{\n\t\t\ttree[i].type = Type::LEAF;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttree[i].type = Type::INTERNAL;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tprintf(\"node %d: parent = %d, sibling = %d, degree = %d, depth = %d, height = %d, %s\\n\", tree[i].id, tree[i].parent, tree[i].sibling,tree[i].children.size(),tree[i].depth, tree[i].height,typeStr[(int)tree[i].type].c_str());\n\t}*/\n\n\t/*printf(\"Preorder\\n\");\n\tPreOrder(rootID);\n\tprintf(\"\\nInorder\\n\");\n\tInOrder(rootID);\n\tprintf(\"\\nPostorder\\n\");*/\n\tPostOrder(rootID, 0);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//By Vlgd\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100;\nint pre[N],in[N],post[N],n,cnt=0,pos=0;\nint chl[N][2];\n//no tree:\nvoid rec(int x,int y){\n\tif (x>=y) return;\n\tint root=pre[cnt++],cur;\n\tfor (cur=x;cur<y;cur++) if (in[cur]==root) break;\n\trec(x,cur);\n\trec(cur+1,y);\n\tpost[pos++]=root;\n}\n//tree:\n//int rec(int x,int y){\n//\tif (x>=y) return -1;\n//\tint root=pre[cnt++],cur;\n//\tfor (cur=x;cur<y;cur++) if (in[cur]==root) break;\n//\tchl[root][0]=rec(x,cur);\n//\tchl[root][1]=rec(cur+1,y);\n//\treturn root;\n//}\n//void posto(int v){\n//\tif (v==-1) return;\n//\tposto(chl[v][0]);\n//\tposto(chl[v][1]);\n//\tif(cnt++)printf(\" \");\n//\tprintf(\"%d\",v);\n//}\nmain(){\n\tscanf(\"%d\",&n);\n\tmemset(chl,-1,sizeof(chl));\n\tfor (int i=0;i<n;i++) scanf(\"%d\",&pre[i]);\n\tfor (int i=0;i<n;i++) scanf(\"%d\",&in[i]);\n\t\n\trec(0,n);\n//\tcnt=0;posto(pre[0]);\n//\tprintf(\"\\n\");\n\tfor (int i=0;i<n;i++){\n\t\tprintf(\"%d\",post[i]);\n\t\tif (i!=n-1) printf(\" \");\n\t\telse printf(\"\\n\");\n\t}\n}\n//5\n//1 2 3 4 5\n//3 2 4 1 5\n"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <iostream>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#define INTINF 2147483647\n#define LLINF 9223372036854775807\ntypedef long long ll;\nusing namespace std;\n\nint n,pos;\nstd::vector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n  if (l>=r) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(),in.end(), root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\n\nvoid solve(){\n  pos=0;\n  rec(0, pre.size());\n  for (size_t i = 0; i < n; i++) {\n    if (i) std::cout << \" \";\n    std::cout << post[i];\n  }\n  std::cout << '\\n';\n}\n\nvoid input(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int k;\n  std::cin >> n;\n  for (size_t i = 0; i < n; i++) {\n    std::cin >> k;\n    pre.push_back(k);\n  }\n  for (size_t i = 0; i < n; i++) {\n    std::cin >> k;\n    in.push_back(k);\n  }\n}\n\nint main(int argc, char const *argv[]) {\n  input();\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r){\n\tif(l >= r) return;\n\tpos++;\n\tint root = pre[pos];\n\tint m = distance(in.begin(),find(in.begin(),in.end(),root));\n\trec(l,m);\n\trec(m+1,r);\n\tpost.push_back(root);\n}\n\nvoid solve(){\n\tpos = 0;\n\trec(0, pre.size());\n\tfor(int i = 0;i < n;i++){\n\t\tif( i )cout <<\" \";\n\t\tcout <<post[i];\n\t}\n\tcout <<endl;\n}\n\n\nint main(){\n\tint k;\n\tcin >>n;\n\n\tfor(int i = 0;i < n;i++){\n\t\tcin >>k;\n\t\tpre.push_back(k);\n\t}\n\n\tfor(int i = 0;i < n;i++){\n\t\tcin >>k;\n\t\tin.push_back(k);\n\t}\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <climits>\n#include <cstring>\n#define rep(i, begin, end) for (__typeof(end) i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))\n\nusing namespace std;\n\nconst int N_MAX = 1000000;\nstring ans = \"\";\n/*\n pre: 4 2 3 1 5\n in:  3 2 4 5 1\n\n*/\nstruct Node{\n  int data;\n  Node* left;\n  Node* right;\n};\n\nvoid postorder(Node* root){\n  if(root == NULL) return;\n  postorder(root->left);\n  postorder(root->right);\n  //cout << root->data << \" \";\n  ans += (to_string(root->data) + \" \");\n}\n\n\nvoid print_array(int* arr, int len){\n  rep(i, 0, len){\n    cout << arr[i];\n    if(i==len-1) cout << endl;\n    else cout << \" \";\n  }\n}\n\nNode* solve(int* inorder, int* preorder, int len){\n  // cout << \"inorder: \" << endl;\n  // print_array(inorder, len);\n  \n  // cout << \"preorder: \" << endl;\n  // print_array(preorder, len);\n  // find root\n  int root_data = preorder[0];\n  Node* root_node = new Node;\n  root_node->data = root_data;\n  if(len==1) return root_node;\n  \n  // count all the num left\n  int left_num=0;\n  while(inorder[left_num] != root_data) left_num++;\n  int right_num = len - left_num - 1;\n  \n  int* left_inorder = new int[left_num];\n  int* right_inorder = new int[right_num];\n  \n  int* left_preorder = new int[left_num];\n  int* right_preorder = new int[right_num];\n\n  int ix=0;\n  int l_ix=0, r_ix=0;\n\n  rep(ix, 0, len){\n    if(inorder[ix] == root_data) continue;\n    if(l_ix<left_num){\n      left_inorder[l_ix] = inorder[ix];\n      l_ix++;\n    }\n    else if(r_ix<right_num){\n      right_inorder[r_ix] = inorder[ix];\n      r_ix++;\n    }\n  }\n  \n  ix = 0; l_ix = 0; r_ix = 0;\n  \n  rep(ix, 1, len){\n    if(l_ix < left_num){\n      left_preorder[l_ix] = preorder[ix];\n      l_ix++;\n    }\n    else if(r_ix < right_num){\n      right_preorder[r_ix] = preorder[ix];\n      r_ix++;\n    }\n  }\n\n  if(left_num>0) root_node->left = solve(left_inorder, left_preorder, left_num);\n  if(right_num>0) root_node->right = solve(right_inorder, right_preorder, right_num);  \n  \n  delete[] left_inorder;\n  delete[] right_inorder;\n\n  return root_node;\n  \n}\n\nint main(){\n  int n; cin >> n;\n\n  int* inorder = new int[n];\n  int* preorder = new int[n];\n  \n  int tmp;\n  rep(i, 0, n){\n    cin >> tmp;\n    preorder[i] = tmp;\n  }\n  rep(i, 0, n){\n    cin >> tmp;\n    inorder[i] = tmp;\n  }\n  Node* root = solve(inorder, preorder, n);\n  postorder(root);\n  rep(i, 0, 2*n-1) cout << ans[i]; \n  cout << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n  if ( l >= r ) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(l, m);\n  rec(m + 1, r);\n  post.push_back(root);\n}\n\nvoid solve() {\n  pos = 0;\n  rec(0, pre.size());\n  for ( int i = 0; i < n; i++ ) {\n    if ( i ) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main() {\n  int k;\n  cin >> n;\n\n  for ( int i = 0; i < n; i++ ) {\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for ( int i = 0; i < n; i++ ) {\n    cin >> k;\n    in.push_back(k);\n  }\n\n  solve();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int>pre, in, post;\n\nvoid rec(int l, int r) {\n\tif (l >= r)return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\nvoid solve() {\n\tpos = 0;\n\trec(0, pre.size());\n\tfor(int i = 0; i < n; i++) {\n\t\tif (i)cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tint k;\n\tcin >> n;\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define N 42\nint n;\nint a[N];\nint b[N];\nint c[N];\nint ai = 1;\nint ci = 1;\nint used[N];\nvoid rebuild(int left, int right){\n    if(left == right) {\n        printf(\"%d \", b[left]);\n        c[ci++] = b[left];\n        used[b[left]] = 1;\n         return ;\n    }\n//    int ax = a[ai++];\n    int ax;\n    if(used[a[ai]] == 0){\n        ax = a[ai++];\n    }\n    else{\n        while(used[a[ai]] != 0){\n            ai++;\n        }\n        ax = a[ai++];\n    }\n    int m = 1;\n    for(int i = 1; i <= n; i++){\n        if(b[i] == ax) {\n            m = i;\n            break;\n        }\n    }\n    if(m - 1 >= left) rebuild(left, m-1);\n    if(m + 1 <= right) rebuild(m+1, right);\n    printf(\"%d \", ax);\n    c[ci++] = ax;\n    used[ax] = 1;\n    return ;\n}\nint main(){\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    for(int i = 1; i <= n; i++) scanf(\"%d\", &b[i]);\n    for(int i = 1; i <= n; i++) used[i] = 0;\n    rebuild(1, n);\n//    for(int i = 1; i <= n; i++){\n//        if(i == n) printf(\"%d\\n\", c[i]);\n//        else printf(\"%d \", c[i]);\n//    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n//树的重建\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n    if ( l >= r ) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m + 1, r);\n    post.push_back(root);\n}\n\nvoid solve() {\n    pos = 0;\n    rec(0, pre.size());\n    for (int i = 0; i < n; i++) {\n        if ( i ) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main() {\n    int v;\n    cin >> n;\n    \n    for (int i = 0; i < n; i++) {\n        cin >> v;\n        pre.push_back(v);\n    }\n\n    for (int i = 0; i < n; i++) {\n        cin >> v;\n        in.push_back(v);\n    }\n\n    solve();\n    \n    return 0;  \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n\tif(l >= r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m+1, r);\n\tpost.push_back(root);\n}\n\nvoid solve() {\n\tpos = 0;\n\trec(0, pre.size());\n\tfor(int i = 0; i < n; i++) {\n\t\tif(i) cout << \" \";\n\t\tcout << post[i]; \n\t}\n\tcout << endl;\n}\n\nint main() {\n\tint k;\n\tcin >> k;\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\t\n\tsolve();\n    \n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> pre;\nvector<int> in;\nint p=0;\n\nint recon(int l, int r) {\n\tif (l >= r) { return 0; }\n\t\n\tint c = pre[p++ ];\n\tint m = 0;\n\tfor (int i = l; i <= r; i++) {\n\t\tif (in[i] == c) {\n\t\t\tm = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trecon(l, m);\n\trecon(m + 1, r);\n\tif (c != pre[0]) {\n\t\tcout << c << \" \";\n\t}\n\telse {\n\t\tcout << c << endl;\n\t}\n\treturn 0;\n}\n\nint main() {\n\n\tint n;\n\tcin >> n ;\n\n\tpre=vector<int> (n, 0);\n\tin=vector<int> (n, 0);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> pre[i];\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> in[i];\n\t}\n\n\trecon(0, pre.size());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nstd::vector<int> preorder;\nstd::vector<int> inorder;\nstd::vector<int> postorder;\n\nstruct Sibling\n{\n    int left, right;\n    Sibling(){left = -1; right = -1;}\n};\nSibling sibling[41];\n\nvoid dfs(const int index, const int parent_index)\n{\n    //cout << \"dfs \" << index << \", \" << parent_index << endl;\n    //preorder.push_back(index);\n    if(sibling[index].left == -1 && sibling[index].right == -1){\n        //inorder.push_back(index);\n        postorder.push_back(index);\n        return;\n    }\n    if(sibling[index].left != -1){\n        dfs(sibling[index].left, index);\n    }\n    //inorder.push_back(index);\n    if(sibling[index].right != -1){\n        dfs(sibling[index].right, index);\n    }\n    postorder.push_back(index);\n}\n\nint pos = 0;\nvoid Reconstruct(int left, int right)\n{\n    int root = preorder[pos];\n    //cout << \"Reconstruct \" << root << \": \" << left << \", \" << right << endl;\n    \n    std::vector<int>::iterator itr, start, end;\n    start = inorder.begin()+left;\n    end   = (right==inorder.size())? inorder.end():(inorder.begin()+right+1);\n    itr = std::find(start, end, root);\n    if(itr == inorder.end()) return; // error\n    \n    int distl = std::distance(start, itr);\n    int distr = std::distance(itr+1, end);\n    if(distl != 0){  // 左の部分木がなければそのまま右へ\n        pos++;  // 左の部分木のルートを設定\n        sibling[root].left = preorder[pos];\n        if(distl > 1){  // 左の部分木が2つ以上なら再帰（1つなら葉で確定）\n            Reconstruct(left, left+(distl-1)); // rootは含まない\n        }\n    }\n    if(distr != 0){\n        pos++;  // 右の部分木のルートを設定\n        sibling[root].right = preorder[pos];\n        if(distr != 1){\n             Reconstruct(left+(distl+1), right); // rootは含まない\n        }\n    }\n}\nint main()\n{\n    int n, id;\n    cin >> n;\n    std::vector<int> childlist;\n    for(int i=0; i<n; i++){\n        cin >> id;\n        preorder.push_back(id);\n    }\n    for(int i=0; i<n; i++){\n        cin >> id;\n        inorder.push_back(id);\n    }\n    Reconstruct(0, n-1);\n    dfs(preorder[0], -1);\n\n    std::vector<int>::iterator itr = postorder.begin();\n    while(itr != postorder.end()){\n        cout << *itr; ++itr;\n        if(itr != postorder.end()) cout << \" \";\n    }\n    cout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n    if (l >= r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m + 1, r);\n    post.push_back(root);\n}\n\nvoid solve(){\n    pos = 0;\n    rec(0, pre.size());\n    for (int i = 0; i < n; i++){\n        if (i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main(){\n    int k;\n    cin >> n;\n\n    for (int i = 0; i < n; i++){\n        cin >> k;\n        pre.push_back(k);\n    }\n\n    for (int i = 0; i < n; i++){\n        cin >> k;\n        in.push_back(k);\n    }\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n,pos;\n\nvector<int> pre,in,post;\n\nvoid rec(int l, int r)\n{\n    if(l>=r) return;\n    int root=pre[pos++];\n    int m=distance(in.begin(), find(in.begin(),in.end(),root));\n    rec(l,m);\n    rec(m+1,r);\n    post.push_back(root);\n}\n\nvoid solve()\n{\n    pos=0;\n    rec(0,pre.size());\n    for(int i=0;i<n;i++){\n        if(i) cout<<\" \";\n        cout<< post[i];\n    }\n    cout<<endl;\n}\n\nint main()\n{\n    int k;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>k;\n        pre.push_back(k);\n    }\n    for(int i=0;i<n;i++){\n        cin>>k;\n        in.push_back(k);\n    }\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int MAXt=10000;\n\nint n,pos=0,poss=0;\nint pre[MAXt],in[MAXt],post[MAXt];\n\nvoid rec(int l,int r)\n{\n\tif(l>=r)return;\n\tint root=pre[pos++];\n\tint i;\n\tfor(i=0;i<n;i++)if(in[i]==root)break;\n\trec(l,i);\n\trec(i+1,r);\n\tpost[poss++]=root;\n}\n\nint main() {\n\tcin>>n;\n\tfor(int i=0;i<n;i++)cin>>pre[i];\n\tfor(int i=0;i<n;i++)cin>>in[i];\n\trec(0,n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(i)cout<<\" \";\n\t\tcout<<post[i];\n\t}\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\ntypedef struct tree_{\n    int parent;\n    int left;\n    int right;\n}tree;\n\nvoid postorder(tree *node, int id){\n    if(node[id].left!=-1){\n        postorder(node, node[id].left);\n        printf(\" \");\n    }\n    if(node[id].right!=-1){\n        postorder(node, node[id].right);\n        printf(\" \");\n    }\n    printf(\"%d\",id);\n}\n\nint reconstruct(int *pre, int *in, tree *node, int n){\n    if(n==0)return -1;\n    int root = pre[0];\n    int n1, n2;\n    for(n1=0;n1<n;n1++){\n        if(in[n1]==root)break;\n    }\n    n2 = n - n1 - 1;\n    node[root].left = reconstruct(pre+1, in, node, n1);\n    node[root].right = reconstruct(pre+1+n1, in+1+n1, node, n2);\n    return root;\n}\n\nint main(){\n    int i, n;\n    scanf(\"%d\",&n);\n    int pre[n];\n    int in[n];\n    tree node[n];\n    for(i=0;i<n;i++)scanf(\"%d\",pre+i);\n    for(i=0;i<n;i++)scanf(\"%d\",in+i);\n    int root = reconstruct(pre, in, node, n);\n    postorder(node, root);\n    printf(\"\\n\");\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * d.cc: \n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n\nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 40;\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef pair<int,int> pii;\n\n/* global variables */\n\nint as[MAX_N], bs[MAX_N], cs[MAX_N];\n\n/* subroutines */\n\nvoid check(int ai, int aj, int as[],\n\t   int bi, int bj, int bs[],\n\t   int ci, int cj, int cs[]) {\n  if (ai == aj) {\n    cs[ci] = as[ai];\n    return;\n  }\n\n  int root = as[ai], k;\n  for (k = bi; k <= bj; k++)\n    if (bs[k] == root) break;\n  // bs -> [bi, k - 1], [k + 1, bj]\n  int ln = k - bi, rn = bj - k;\n\n  // as -> [ai + 1, ai + ln], [ai + ln + 1, aj]\n  // cs -> [ci, ci + ln - 1], [ci + ln, cj - 1]\n\n  cs[cj] = root;\n  if (ln > 0) check(ai + 1, ai + ln, as, bi, k - 1, bs, ci, ci + ln - 1, cs);\n  if (rn > 0) check(ai + ln + 1, aj, as, k + 1, bj, bs, ci + ln, cj - 1, cs);\n}\n\n/* main */\n\nint main() {\n  int n;\n  cin >> n;\n\n  for (int i = 0; i < n; i++) cin >> as[i];\n  for (int i = 0; i < n; i++) cin >> bs[i];\n\n  check(0, n - 1, as, 0, n - 1, bs, 0, n - 1, cs);\n\n  for (int i = 0; i < n; i++) {\n    if (i) putchar(' ');\n    printf(\"%d\", cs[i]);\n  }\n  putchar('\\n');\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> pre,in,post;\nint n,x,p=0; //p一定要设置成全局变量 \nvoid reconstruct(int l,int r){\n\t int c,m;\n\t if (l>=r)\n\t    return;\n\t c=pre[p++];\n\t for (int i=0; i<n; i++)\n\t     if (in[i]==c){\n\t     \t m=i; break;\n\t\t }\n     reconstruct(l,m);\n\t reconstruct(m+1,r);\n\t post.push_back(c);\t\t\n}\nint main(){\n\tcin>>n;\n\tfor (int i=0; i<n; i++){\n\t\tcin>>x;\n\t\tpre.push_back(x);\n\t}\n\tfor (int i=0; i<n; i++){\n\t\tcin>>x;\n\t\tin.push_back(x);\n\t}   \n    reconstruct(0,n);\n    cout<<post[0];\n    for (int i=1; i<n; i++)\n        cout<<\" \"<<post[i];\n    cout<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> c;\nvector<int> pre, in;\n\nvoid recon(vector<int> pre, vector<int> in) {\n\tif (pre.size() < 2)\n\t\treturn;\n\tint j = 0;\n\twhile (in[j] != pre[0])\n\t\tj++;\n\tif (j == pre.size() - 1) {\n\t\tc[pre[0] - 1][0] = pre[1] - 1;\n\t\tpre.erase(pre.begin());\n\t\tin.pop_back();\n\t\trecon(pre, in);\n\t}\n\telse if (j == 0) {\n\t\tc[pre[0] - 1][1] = pre[1] - 1;\n\t\tpre.erase(pre.begin());\n\t\tin.erase(in.begin());\n\t\trecon(pre, in);\n\t}\n\telse {\n\t\tc[pre[0] - 1][0] = pre[1] - 1;\n\t\tc[pre[0] - 1][1] = pre[j + 1] - 1;\n\n\t\tvector<int> pre1, in1;\n\n\t\tpre1.assign(pre.begin() + 1, pre.begin() + j + 1);\n\t\tin1.assign(in.begin(), in.begin() + j + 1);\n\t\tpre.erase(pre.begin(), pre.begin() + j + 1);\n\t\tin.erase(in.begin(), in.begin() + j + 1);\n\t\trecon(pre1, in1);\n\t\trecon(pre, in);\n\t}\n}\n\nvoid post(int id) {\n\tif (id == -1)\n\t\treturn;\n\tpost(c[id][0]);\n\tpost(c[id][1]);\n\tcout << id + 1;\n\tif (id == pre[0] - 1)\n\t\tcout << endl;\n\telse\n\t\tcout << \" \";\n}\n\nint main()\n{\n\tint n = 0, t = 0;\n\n\tcin >> n;\n\n\tc.assign(n, { -1, -1 });\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> t;\n\t\tpre.push_back(t);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> t;\n\t\tin.push_back(t);\n\t}\n\n\trecon(pre, in);\n\n\tpost(pre[0] - 1);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r)\n{\n    if(l >= r) return ;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m+1, r);\n    post.push_back(root);\n}\n\nvoid solve()\n{\n    pos = 0;\n    rec(0, pre.size());\n    for(int i=0; i<n; i++)\n    {\n        if(i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main()\n{\n    int k;\n    cin >> n;\n    for(int i=0; i<n; i++)\n    {\n        cin >> k;\n        pre.push_back(k);\n    }\n    for(int i=0; i<n; i++)\n    {\n        cin >> k;\n        in.push_back(k);\n    }\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint N, pos;\nvector<int> pre, in, post;\n\nvoid rec(int left, int right) {\n  if (left >= right) {\n    return;\n  }\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(left, m);\n  rec(m + 1, right);\n  post.push_back(root);\n}\n\nvoid solve() {\n  pos = 0;\n  rec(0, pre.size());\n  for (int i = 0; i < N; i++) {\n    if (i) {\n      cout << \" \";\n    }\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main() {\n  cin >> N;\n\n  int k;\n  for (int i = 0; i < N; i++) {\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for (int i = 0; i < N; i++) {\n    cin >> k;\n    in.push_back(k);\n  }\n\n  solve();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define NIL -1\n\nint n;\nqueue<int> pre;\nvector<int> in;\nqueue<int> post;\n\nint findin(int u) {\n\tfor (int i = 0; i < n; i++)\n\t\tif (in[i] == u)\n\t\t\treturn i;\n\treturn NIL;\n}\n\nvoid rec(int l, int r) {\n\tif (l >= r)\n\t\treturn;\n\tint c = pre.front();\n\tpre.pop();\n\tint m = findin(c);\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push(c);\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\tpre.push(a);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\tin.push_back(a);\n\t}\n\trec(0, n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tcout << post.front() << \" \";\n\t\tpost.pop();\n\t}\n\tcout << post.front() << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 45\nusing namespace std;\nint pre[N], p = 0;\nint in[N];\nint n;\nvector<int> post;\nvoid rec(int l, int r){\n    if (l >= r) return ;\n    int c = pre[p++];\n    int m;\n    for(m = 0; m < n; m++){\n        if(in[m] == c) break;\n    }\n    rec(l, m);\n    rec(m+1, r);\n    post.push_back(c);\n}\nint main() {\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++) scanf(\"%d\", &pre[i]);\n    for(int i = 0; i < n; i++) scanf(\"%d\", &in[i]);\n    rec(0, n);\n    for(int i = 0; i < post.size(); i++){\n        printf(\"%d\", post[i]);\n        i == post.size()-1 ? printf(\" \") : printf(\"\\n\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nconst int MAXSIZE = 45;\nint num_node;\nint Pre_orider[MAXSIZE], In_Order[MAXSIZE], Post_Order[MAXSIZE];\nint pre_position, post_position;\nvoid Re_struct(int left, int right) {\n\tif (left >= right)\treturn;\n\tint value = Pre_orider[pre_position++];\n\tint  in_postition = -1;\n\tfor (int i = 0; i < num_node; i++) {\n\t\tif (In_Order[i] == value) {\n\t\t\tin_postition = i; break;\n\t\t}\n\t}\n\tRe_struct(left, in_postition);\n\tRe_struct(in_postition + 1, right);\n\tPost_Order[post_position++] = value;\n}\nint main() {\n\tpre_position = post_position = 0;\n\tscanf(\"%d\", &num_node);\n\tfor (int i = 0; i < num_node; i++) {\n\t\tscanf(\"%d\", &Pre_orider[i]);\n\t}\n\tfor (int i = 0; i < num_node; i++) {\n\t\tscanf(\"%d\", &In_Order[i]);\n\t}\n\tRe_struct(0, num_node);\n\tfor (int i = 0; i < num_node; i++) {\n\t\tif (i) printf(\" \");\n\t\tprintf(\"%d\",Post_Order[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n,s[50],ans[50],a;\n  vector<int> t;\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>a,s[a]=i,ans[i]=a;\n  for(int i=0;i<n;i++)cin>>a,t.push_back(s[a]);\n  t.push_back(100);\n  while(1){\n    if(t.size()==2){\n      cout<<ans[0]<<endl;\n      break;\n    }\n    for(int i=0;i<t.size();i++){\n      if(t[i]>t[i+1]){\n        cout<<ans[t[i]]<<\" \";\n        t.erase(t.begin()+i);\n        break;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint pre[50],in[50],post[50];\nint n,pos,idx;\nvoid dfs(int l,int r){\n  if(l>=r) return;\n  int root=pre[pos++];\n  int m=-1;\n  for(int i=l;i<r;i++)\n    if(in[i]==root) m=i;\n  dfs(l,m);\n  dfs(m+1,r);\n  post[idx++]=root;\n}\nsigned main(){\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>pre[i];\n  for(int i=0;i<n;i++) cin>>in[i];\n  pos=idx=0;\n  dfs(0,n);\n  for(int i=0;i<n;i++)\n    cout<<post[i]<<\" \\n\"[i==n-1];\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace  std;\n\nconst int END = -1;\nstruct StNod\n{\n  int m_nParnt;\n  int m_nLeft;\n  int m_nRigt;\n\n  StNod() :\n     m_nParnt(END), m_nLeft(END), m_nRigt(END)\n  { }\n};\n\nenum EnDir\n{\n  D_Left,\n  D_Right,\n};\n\nvoid fnInput(vector<int> &rvnPodr, vector<int> &rvnIodrSeq)\n{\n  int nMaxSiz;\n\n  cin >> nMaxSiz;\n  rvnPodr.resize(nMaxSiz);\n  rvnIodrSeq.resize(nMaxSiz + 1);\n\n  for (int i = 0; i < nMaxSiz; i++)\n    cin >> rvnPodr[i];\n\n  for (int i = 1; i < nMaxSiz + 1; i++)\n  {\n    int nNode;\n    cin >> nNode;\n    rvnIodrSeq[nNode] = i;\n  }\n}\n\nvoid fnStructTree(const vector<int> &cnrvnPodr, const vector<int> &cnrvnIodrSeq, vector<StNod> &rvoNod)\n{\n  for (int i = 1; i < cnrvnPodr.size(); i++)\n  {\n    int nParnt = END;\n    int nx = cnrvnPodr[0];\n    EnDir enDir;\n    while (nx != END)\n    {\n      nParnt = nx;\n      if (cnrvnIodrSeq[ cnrvnPodr[i] ] < cnrvnIodrSeq[nx])\n      {\n        nx = rvoNod[nx].m_nLeft;\n        enDir = D_Left;\n      }\n      else\n      {\n        nx = rvoNod[nx].m_nRigt;\n        enDir = D_Right;\n      }\n    }\n\n    rvoNod[ cnrvnPodr[i] ].m_nParnt = nParnt;\n    if (enDir == D_Left)\n      rvoNod[nParnt].m_nLeft = cnrvnPodr[i];\n    else\n      rvoNod[nParnt].m_nRigt = cnrvnPodr[i];\n  }\n}\n\nvoid fnPostOrder(const vector<StNod> &cnrvoNod, int nx)\n{\n  static int stnPrt = 0;\n  if (nx == END)  return;\n\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nLeft);\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nRigt);\n\n  if (stnPrt++) cout << \" \";\n  cout << nx;\n}\n\nvoid fnResult(const vector<StNod> &cnrvoNod)\n{\n  int nx = 1;\n  while (cnrvoNod[nx].m_nParnt != END)\n    nx = cnrvoNod[nx].m_nParnt;\n\n  fnPostOrder(cnrvoNod, nx);\n  cout << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vector<int> vnPodr, vnIodrSeq;\n  vector<StNod> voNod;\n\n  fnInput(vnPodr, vnIodrSeq);\n\n  StNod oNod;\n  voNod.resize(vnIodrSeq.size(), oNod);\n  fnStructTree(vnPodr, vnIodrSeq, voNod);\n  \n  int nOCnt = 0;\n  fnResult(voNod);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\nusing namespace std;\nstatic const int MAX = 41;\nint measure[MAX];\nstruct node {\n  node *left;\n  node *right;\n  int key;\n};\n\nnode *root = NULL;\n\nvoid insert(int key) {\n  node *nd = (node *)malloc(sizeof(node));\n  nd->key = key;\n  nd->left = NULL;\n  nd->right = NULL;\n\n  if (root == NULL) {\n    root = nd;\n    return;\n  }\n\n  node *x = root;\n  while (1) {\n    if (measure[x->key] < measure[nd->key]) {\n      if (x->right == NULL) {\n        x->right = nd;\n        break;\n      } else {\n        x = x->right;\n      }\n    } else {\n      if (x->left == NULL) {\n        x->left = nd;\n        break;\n      } else {\n        x = x->left;\n      }\n    }\n  }\n}\n\nvoid print(node *n) {\n  if (!n)\n    return;\n  print(n->left);\n  print(n->right);\n  cout << n->key << \" \";\n}\n\nint main() {\n  int keys[MAX];\n  int n, idx;\n  cin >> n;\n\n  for (int i = 0; i < n; i++) {\n    cin >> keys[i];\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> idx;\n    measure[idx] = i;\n  }\n\n  for (int i = 0; i < n; i++) {\n    insert(keys[i]);\n  }\n\n  print(root);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint N,P[45],I[45],i,j,G[45][3],p,f[45]={0};\n\nvoid dfs(int p)\n{\n\tif(G[p][0]!=-1)\n\t\tdfs(G[p][0]);\n\tif(G[p][1]!=-1)\n\t\tdfs(G[p][1]);\n\tprintf(\"%d \",p);\n\n}\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tmemset(G,-1,sizeof(G));\n\tfor(i=0;i<N;i++)scanf(\"%d\",&P[i]);\n\tfor(i=0;i<N;i++)scanf(\"%d\",&I[i]);\n\tp=P[0];\n\tfor(int np=0,ip=0;np<N;)\n\t{\n\t\twhile(P[np]!=I[ip])\n\t\t{\n\t\t\tG[P[np]][0]=P[np+1];\n\t\t\tG[P[np+1]][2]=P[np];\n\t\t\tf[P[np]]=1;f[P[np+1]]=1;\n\t\t\tnp++;\n\t\t}\n\t\twhile(f[I[ip]])\n\t\t{\n\t\t\tip++;\n\t\t}\n\t\tif(ip>0&&ip<N)\n\t\t{\n\t\t\tG[I[ip-1]][1]=I[ip];\n\t\t\tG[I[ip]][2]=I[ip-1];\n\t\t\tf[I[ip]]=1;\n\t\t}\n\t\tif(I[ip]==P[np])ip++;\n\t\tnp++;\n\t}\n\tdfs(P[0]);\n\tputs(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n    if(l>= r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m+1, r);\n    post.push_back(root);\n}\n\nvoid solve(){\n    pos = 0;\n    rec(0, pre.size());\n    for(int i=0;i<n;i++){\n        if(i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main(){\n    int k;\n    cin >> n;\n\n    for(int i=0;i<n;i++){\n        cin >> k;\n        pre.push_back(k);\n    }\n\n    for(int i=0;i<n;i++){\n        cin >> k;\n        in.push_back(k);\n    }\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <list>\n#include <map>\nusing namespace std;\n\nbool flg=false;\n\nint solve(vector<int> pre,vector<int> in){\n    if(pre.size() == 0) return 0;\n    if(pre.size() == 1){\n        if(flg) cout << ' ';\n        cout << pre.at(0);\n        flg = true;\n    }\n    else{\n        int root=pre.at(0);\n        vector<int> left,right,Lin,Rin;\n        for(int i=0;i<in.size();i++){\n            if(in.at(i) == root){\n                for(int j=0;j<i;j++) left.push_back(in.at(j));\n                for(int j=i+1;j<in.size();j++) right.push_back(in.at(j));\n                Lin=left,Rin=right;\n                sort(left.begin(),left.end());\n                sort(right.begin(),right.end());\n            }\n        }\n        for(int i=0;i<pre.size();i++){\n            vector<int> l,r,Lpre,Rpre;\n            l.clear();\n            r.clear();\n            for(int j=1;j<i+1;j++) l.push_back(pre.at(j));\n            for(int j=i+1;j<pre.size();j++) r.push_back(pre.at(j));\n            Lpre=l,Rpre=r;\n            sort(l.begin(),l.end());\n            sort(r.begin(),r.end());\n            bool match=true;\n            if(l.size() != left.size()) match=false;\n            else{\n                for(int k=0;k<l.size();k++){\n                    if(l.at(k) != left.at(k)) match=false;\n                }\n            }\n            if(r.size() != right.size()) match=false;\n            else{\n                for(int k=0;k<r.size();k++){\n                    if(r.at(k) != right.at(k)) match=false;\n                }\n            }\n            if(match){\n                solve(Lpre,Lin);\n                solve(Rpre,Rin);\n                cout << ' ' << root;\n            }\n        }\n    }\n    return 0;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int> pre(n),in(n);\n    for(int i=0;i<n;i++) cin >> pre[i];\n    for(int i=0;i<n;i++) cin >> in[i];\n    solve(pre, in);\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n \nusing namespace std;\nconst int NIL = -1;\n \nstruct node {\n    int parent;\n    int left;\n    int right;\n};\n \nvector<int> pre;\nvector<int> ino;\nint n;\n \nvoid reconstruct(int l, int r)\n{\n    static int k = 0;\n    if (l >= r) return;\n    int c = pre[k];\n    k++;\n    int i = 0;\n    for (i = 0; i < n; ++i) {\n        if (ino[i] == c) break;\n    }\n    reconstruct(l, i);\n    reconstruct(i + 1, r);\n    static int m = 0;\n    if (m++ > 0) printf(\" \");\n    printf(\"%d\", c);\n \n}\n \nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) {\n        int v;\n        scanf(\"%d\", &v);\n        pre.push_back(v);\n    }\n    for (int i = 0; i < n; ++i) {\n        int v;\n        scanf(\"%d\", &v);\n        ino.push_back(v);\n    }\n    reconstruct(0, n);\n    printf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int> pre, in, post;\nint pos = 0;\n\nvoid reconstruction(int l, int r)\n{\n  if(l >= r)  return ;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  reconstruction(l, m);\n  reconstruction(m+1, r);\n  post.push_back(root);\n}\n\nvoid solve()\n{\n  int n = in.size();\n  reconstruction(0, n);\n  for(int i=0; i < n; i++)\n  {\n    if(i) printf(\" \");\n    cout << post[i] ;\n  }\n  printf(\"\\n\");\n}\n\nint main()\n{\n  int n;\n  scanf(\"%d\", &n);\n  for(int i=0; i<n; i++)\n  {\n    int t;\n    scanf(\"%d\", &t);\n    pre.push_back(t);\n  }\n  for(int i=0; i<n; i++)\n  {\n    int t;\n    scanf(\"%d\", &t);\n    in.push_back(t);\n  }\n  solve();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <array>\n#include <algorithm>\n\nusing namespace std;\n\nconst int32_t N = 40;\narray<int32_t, N> preorder, inorder;\nvector<int32_t> postorder;\n\nvoid construct_postorder(int32_t s_pre, int32_t s_in, int32_t l) {\n    if (l > 1) {\n        int32_t r_pre = s_pre, r_in = s_in;\n        while (inorder[r_in] != preorder[r_pre]) r_in++;\n\n        construct_postorder(s_pre + 1, s_in, r_in - s_in);\n        construct_postorder(s_pre + r_in + 1 - s_in, r_in + 1, s_in + l - r_in - 1);\n    }\n\n    if (l >= 1) {\n        postorder.push_back(preorder[s_pre]);\n    }\n\n    return;\n}\n\nint main() {\n    int32_t n;\n    scanf(\"%d\", &n);\n\n    for (int32_t i = 0; i < n; i++) {\n        scanf(\"%d\", &preorder[i]);\n    }\n    for (int32_t i = 0; i < n; i++) {\n        scanf(\"%d\", &inorder[i]);\n    }\n\n    construct_postorder(0, 0, n);\n\n    for (int32_t i = 0; i < n; i++) {\n        if (i != 0) printf(\" \");\n        printf(\"%d\", postorder[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n//#include \"libs.h\"\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n//#include <opencv2/core.hpp>\n//#include <opencv2/highgui.hpp>\n//#include <opencv2/imgproc.hpp>\n\nusing namespace std;\n\n//呪文\n#define DUMPOUT cerr\n#define dump(...) DUMPOUT<<\"  \";DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl;DUMPOUT<<\"    \";dump_func(__VA_ARGS__)\n\ntypedef unsigned uint; typedef long long ll; typedef unsigned long long ull; typedef pair<int, int> pii; typedef pair<ll, ll> pll; typedef pair<double, double> pdd; typedef pair<string, string> pss;\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const pair<_KTy, _Ty>& m) { o << \"{\" << m.first << \", \" << m.second << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const unordered_map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const vector<_Ty>& v) { if (v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const unordered_set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; }\to << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const stack<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } stack<_Ty> t(s); o << \"{\" << t.top(); t.pop(); while (!t.empty()) { o << \", \" << t.top(); t.pop(); } o << \"}\";\treturn o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const list<_Ty>& l) { if (l.empty()) { o << \"{ }\"; return o; } o << \"{\" << l.front(); for (auto itr = ++l.begin(); itr != l.end(); ++itr) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> istream& operator >> (istream& is, pair<_KTy, _Ty>& m) { is >> m.first >> m.second; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, vector<_Ty>& v) { for (size_t i = 0; i < v.size(); i++) is >> v[i]; return is; }\nnamespace aux { // print tuple\n\ttemplate<typename Ty, unsigned N, unsigned L> struct tp { static void print(ostream& os, const Ty& v) { os << get<N>(v) << \", \"; tp<Ty, N + 1, L>::print(os, v); } };\n\ttemplate<typename Ty, unsigned N> struct tp<Ty, N, N> { static void print(ostream& os, const Ty& v) { os << get<N>(v); } };\n}\ntemplate<typename... Tys> ostream& operator<<(ostream& os, const tuple<Tys...>& t) { os << \"{\"; aux::tp<tuple<Tys...>, 0, sizeof...(Tys) - 1>::print(os, t); os << \"}\"; return os; }\n\ntemplate<typename A, size_t N, typename T> inline void Fill(A(&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\n\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) { DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(std::move(tail)...); }\n\n#define PI 3.14159265358979323846\n#define EPS 1e-10\n#define FOR(i,a,n) for(int i=(a);i<(n);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define all(j) (j).begin(), (j).end()\n#define SZ(j) ((int)(j).size())\n#define fake false\n\n\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n\tif (l >= r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\nvoid solve() {\n\tpos = 0;\n\trec(0, n);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i) cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\n\nint main() {\n\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> n;\n\tpre = in = vector<int>(n);\n\tcin >> pre >> in;\n\n\tsolve();\t\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n** 通过先序遍历和中序遍历，重建树，并输出后序遍历\n** 本例题的解法并没有生成树，而是一次到位生成了后序遍历\n*/\n\n# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <cstdio>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid init() {\n    scanf(\"%d\", &n);\n    int node;\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &node);\n        pre.push_back(node);\n    }\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &node);\n        in.push_back(node);\n    }\n}\n\nvoid rec(int l, int r) {\n    if (l >= r)\n        return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m + 1, r);\n    post.push_back(root);\n}\n\nvoid solve() {\n    pos = 0;\n    rec(0, pre.size());\n    for (int i = 0; i < n - 1; i++) {\n        printf(\"%d \", post[i]);\n    }\n    printf(\"%d\\n\", post[n - 1]);\n}\n\nint main() {\n    // freopen(\"infile\", \"r\", stdin);\n    // freopen(\"outfile\", \"w\", stdout);\n    init();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n\nint pr[40], in[40], post[40], n;\nint pos, id;\nvoid dfs(int left, int right){\n    if(left >= right)return;\n    int root = pr[pos++], it;\n    rep(i,n)if(in[i] == root)it = i;\n    dfs(left, it);\n    dfs(it + 1, right);\n    post[id++] = root;\n}\nint main(){\n    cin >> n;\n    rep(i,n)cin >> pr[i];\n    rep(i,n)cin >> in[i];\n    dfs(0, n);\n    rep(i,n)cout << post[i] << ((i < n-1)? \" \": \"\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r){\n\tif(l>=r)return ;\n\tint root=pre[pos++];//preorder??§????¬??????????\n\t//inorder????????????c?????????\n\tint m=distance(in.begin(),find(in.begin(),in.end(),root));\n\trec(l,m);//?????¨?????¨?????????\n\trec(m+1,r);//?????¨?????¨?????????\n\tpost.push_back(root);\n}\nvoid solve(){\n\tpos=0;\n\trec(0,pre.size());\n\tfor (int i = 0; i < n; ++i) {\n\t\tif(i)cout<<\" \";\n\t\tcout<<post[i];\n\t}\n\tcout<<endl;\n}\n\nint main(){\n\tint k;\n\tcin>>n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin>>k;\n\t\tpre.push_back(k);\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\t\tcin>>k;\n\t\t\tin.push_back(k);\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int>pre, in, post;\n\nvoid rec(int l, int r)\n{\n    if(l >= r)   return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(),in.end(), root));\n    rec(l, m);\n    rec(m+1, r);\n    post.push_back(root);\n}\nvoid solve()\n{\n    pos = 0;\n    rec(0, pre.size());\n    for(int i=0; i<n; i++)\n    {\n        if(i)   cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\nint main()\n{\n    int k;\n    cin >> n;\n    for(int i=0; i<n; i++)\n    {\n        cin >> k;\n        pre.push_back(k);\n    }\n    for(int i=0; i<n; i++)\n    {\n        cin >> k;\n        in.push_back(k);\n    }\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nclass node{\npublic:\n  int p = -1, l, r;\n};\n\n\nvector<node> t(100);\nvector<int> s(100), c(100);\n\nvoid pr(vector<node>& t, int i){\n  if(i == -1) return;\n  cout << \" \" << i;\n  pr(t, t[i].l);\n  pr(t, t[i].r);\n  return;\n}\nvoid in(vector<node>& t, int i){\n  if(i == -1) return;\n  in(t, t[i].l);\n  cout << \" \" << i;\n  in(t, t[i].r);\n  return;\n}\nvoid po(vector<node>& t, int i){\n  if(i == -1) return;\n  po(t, t[i].l);\n  po(t, t[i].r);\n  cout << \" \" << i;\n  return;\n}\n\nint num = 0;\nvector<int> ans;\nvoid func(int l, int r){\n  if(l >= r) return;\n  int p = s[num];\n  num++;\n  for(int i = l; i < r; i++){\n    if(p == c[i]){\n      func(l, i);\n      func(i + 1, r);\n      ans.push_back(p);\n    }\n  }\n  return;\n}\n\nvoid solve(){\n  int n; cin >> n;\n  for(int i = 0; i < n; i++){\n    cin >> s[i];\n  }\n  for(int i = 0; i < n; i++){\n    cin >> c[i];\n  }\n  func(0, n);\n  for(int i = 0; i < ans.size() - 1; i++){\n    cout << ans[i] << \" \";\n  }\n  cout << ans[n - 1] << endl;\n  return;\n}\n\nint main(){\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> pre, in, post;\nint p;\n\nvoid dfs(int l, int r) {\n  if ( l >= r ) return;\n  int root = pre[p++];\n  int mid = find(in.begin(), in.end(), root)-in.begin();  \n  dfs(l, mid);\n  dfs(mid+1, r);\n  post.push_back(root);\n}\n\nint main() {\n  cin >> n;\n\n  pre = vector<int>(n);  \n  for ( int i = 0; i < n; i++ ) cin >> pre[i];\n\n  in = vector<int>(n);\n  for ( int i = 0; i < n; i++ ) cin >> in[i];\n\n  dfs(0, n);\n\n  for ( int i = 0; i < n; i++ ) {\n    if ( i ) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <stdlib.h>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n#define ms(x, n) memset(x,n,sizeof(x));\ntypedef  long long LL;\nconst int inf = 1<<30;\nconst LL maxn = 45;\n\nint N, pre[maxn], in[maxn], post[maxn];\nint postPos = 1, prePos = 1;\nvoid rec(int l, int r){\n    if(l >= r) return;\n    //pre的下一个节点\n    int c = pre[prePos++], m;\n    //c在in中的位置\n    for(int i = 1; i <= N; i++)\n        if(in[i] == c){\n            m = i; break;\n        }\n    rec(l, m);  //重建左子树\n    rec(m+1, r);//重建右子树\n    post[postPos++] = c;\n}\nint main()\n{\n    cin >> N;\n    for(int i = 1; i <= N; i++)\n        cin >> pre[i];\n    for(int i = 1; i <= N; i++)\n        cin >> in[i];\n\n    rec(1, N+1);//右边界要略大一点\n    cout << post[1];\n    for(int i = 2 ; i <= N; i++)\n        cout << \" \" << post[i];\n    cout << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\ntemplate<typename F>\ninline constexpr decltype(auto) fix(F&& f) noexcept {\n\treturn[f = std::forward<F>(f)](auto&&... args) {\n\t\treturn f(f, std::forward<decltype(args)>(args)...);\n\t};\n}\n\nint main() {\n\tint n;\n\tstd::cin >> n;\n\n\tstd::vector<int> preord(n), inord(n);\n\tfor (auto&& e : preord) {\n\t\tstd::cin >> e;\n\t\t--e;\n\t}\n\tfor (auto&& e : inord) {\n\t\tstd::cin >> e;\n\t\t--e;\n\t}\n\n\tstd::vector<int> ans;\n\tans.reserve(n);\n\n\tfix([&](auto solve, int ps, int is, int len) -> void {\n\t\tconst int root = preord[ps];\n\n\t\tint ir = is;\n\t\twhile (inord[ir] != root)\n\t\t\t++ir;\n\n\t\tconst int leftLen = ir - is;\n\t\tif (leftLen != 0)\n\t\t\tsolve(solve, ps + 1, is, leftLen);\n\t\t\n\t\tconst int rightLen = len - (ir - is + 1);\n\t\tif (rightLen != 0)\n\t\t\tsolve(solve, ps + leftLen + 1, ir + 1, rightLen);\n\n\t\tans.push_back(root);\n\t})(0, 0, n);\n\n\tstd::cout << ans[0] + 1;\n\tfor (int i = 1; i < n; ++i)\n\t\tstd::cout << \" \" << ans[i] + 1;\n\n\tstd::cout << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cfloat>\n#include<climits>\n#include<cmath>\n#include<deque>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<string>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<vector>\n#include<complex>\n#include<list>\n#include<cstdio>\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\n\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n\n\n\nconst int INF = 1e9 + 7;\n\n\n/******************************************************************************************/\nvector<int> pre, in, post;\nint pos = 0;\n\nvoid dfs(int l, int r) {\n\n\tif (l >= r)return;\n\n\tint root = pre[pos++];\n\tint id = 0;\n\n\tfor (int i = 0; i < in.size(); i++)\n\t{\n\t\tif (in[i] == root) {\n\t\t\tid = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdfs(l, id);\n\tdfs(id + 1, r);\n\n\tpost.push_back(root);\n\n}\n\nvoid solve() {\n\n\tint pos = 0;\n\n\tdfs(0, pre.size());\n\n\tfor (int i = 0; i < post.size(); i++)\n\t{\n\t\tif (i)cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n\n}\n\n\n\nint main() {\n\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(10);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint c;\n\t\tcin >> c;\n\t\tpre.push_back(c);\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint c;\n\t\tcin >> c;\n\t\tin.push_back(c);\n\t}\n\n\tsolve();\n\n\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <iterator>\nstatic const int NIL = -1;\nstatic const int NumberChild = 2;\nclass Tree {\nprivate:\n\tint id;\n\tint parent;\n\tint child[NumberChild];\n\npublic:\n\tTree() {\n\t\tid = child[0] = child[1] = parent = NIL;\n\t}\n\tvoid AddParent(int ID) {\n\t\tparent = ID;\n\t\treturn;\n\t}\n\tvoid AddID(int ID) {\n\t\tid = ID;\n\t\treturn;\n\t}\n\tvoid AddChild(std::vector<int>&Child) {\n\t\tfor (unsigned int i = 0; i < Child.size(); ++i) {\n\t\t\tchild[i] = Child[i];\n\n\t\t}\n\n\t\treturn;\n\t}\n\tint GetRoot(std::vector<Tree> nodes, int ID) {\n\t\tint RootID = ID;\n\t\tif (RootID != NIL&&nodes[RootID].parent != NIL) {\n\t\t\tRootID = GetRoot(nodes, nodes[RootID].parent);\n\t\t}\n\t\treturn RootID;\n\t}\n\tvoid PreorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid InorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid PostorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t\tif(nodes[ID].id!=NIL)std::cout << \" \" << nodes[ID].id;\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid Reconstruct(const std::vector<int>Pre, const std::vector<int>In, std::vector<Tree> &nodes, const int Root,int &cnt) {\n\t\t\n\t\tint m = std::distance(In.begin(), std::find(In.begin(), In.end(), Root));\n\t\n\t\t//nodes[cnt].AddID(Root);\n\t\tnodes[Root].AddID(Root);\n\t\tif (m == 0||Root==NIL) { return; }\n\t\tstd::vector<int>PreLeft;\n\t\n\t\tstd::copy(&Pre[1], &Pre[m]+1, std::back_inserter(PreLeft));\n\t\t\n\t\tstd::vector<int>PreRight;\n\t\t\n\t\tstd::copy(&Pre[m+1 ], &Pre[Pre.size()-1]+1, std::back_inserter(PreRight));\n\t\t\n\t\tstd::vector<int>InLeft;\n\t\tstd::copy(&In[0], &In[m-1]+1, std::back_inserter(InLeft));\n\t\t\n\n\t\tstd::vector<int>InRight;\n\t\tstd::copy(&In[m]+1, &In[In.size() - 1]+1, std::back_inserter(InRight));\n\t\t\n\n\t\tstd::vector<int>child{ PreLeft.empty() ? NIL : PreLeft[0], PreRight.empty() ? NIL : PreRight[0] };\n\t\t//nodes[cnt].AddChild(child);\n\t\tnodes[Root].AddChild(child);\n\t\tfor (unsigned int i = 0; i < child.size(); ++i) {\n\n\t\t\tnodes[child[i]].AddParent(Root);\n\t\t}\n\t\tReconstruct(PreLeft, InLeft, nodes, PreLeft[0], ++cnt);\n\t\tReconstruct(PreRight, InRight, nodes, PreRight[0], ++cnt);\n\t}\n};\n\nvoid SetVector(std::vector<int>&InputVector) {\n\tfor (unsigned int i = 0; i < InputVector.size(); ++i) {\n\t\tstd::cin >> InputVector[i];\n\t}\n\treturn;\n}\nint main(void) {\n\n\tint n;\n\tstd::cin >> n;\n\tstd::vector<int>Pre(n);\n\tstd::vector<int>In(n);\n\tSetVector(Pre);\n\tSetVector(In);\n\tstd::vector<Tree> nodes(n+1);\n\t//ReconstructWithNoParent\n\tint cnt = 0;\n\tnodes[1].Reconstruct(Pre, In, nodes, Pre[0],cnt);\n\n\tnodes[1].PostorderTreeWalk(nodes, 1);\n\tstd::cout << std::endl;\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid reconstruction(int l, int r){\n    if(l >= r){\n        return;\n    }\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    reconstruction(l, m);\n    reconstruction(m + 1, r);\n    post.push_back(root);\n}\nvoid solve(){\n    pos = 0;\n    reconstruction(0, pre.size());\n    for(int i=0; i<n; i++){\n        if(i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main(){\n    int k;\n    cin >> n;\n    for(int i=0; i<n; i++){\n        cin >> k;\n        pre.push_back(k);\n    }\n    for(int i=0; i<n; i++){\n        cin >> k;\n        in.push_back(k);\n    }\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n \nstruct node{\n    int l,r;\n};\nnode v[41];\nvector<int> postord;\nvoid dfs(int vi){\n    if(v[vi].l!=0)dfs(v[vi].l);\n    if(v[vi].r!=0)dfs(v[vi].r);\n    postord.pb(vi);\n}\nint pre[41],in[41];\nint main(){\n    int n,root;\n    cin>>n;\n    rep(i,n) cin>>pre[i];\n    rep(i,n) cin>>in[i];\n    rep(i,41) v[i].l=v[i].r=0;\n    root=pre[0];\n    int cp=0,ci=0;\n    while(cp<n-1){\n        v[pre[cp]].l=pre[cp+1];++cp;\n        while(cp<n&&pre[cp]==in[ci]){\n            ++ci;\n            while(ci<n-1&&v[in[ci]].l==in[ci+1]) ++ci;\n            v[in[ci]].r=in[ci+1];++ci;\n            ++cp;\n        } \n    }\n    dfs(root);\n    rep(i,n) cout<<postord[i]<<(i==n-1?\"\":\" \");\n    cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint N, pos;\nvector<int> pre, in, post;\n\nvoid rec(int left, int right) {\n  if (left >= right) {\n    return;\n  }\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(left, m);\n  rec(m + 1, right);\n  post.push_back(root);\n}\n\nvoid solve() {\n  pos = 0;\n  rec(0, pre.size());\n  for (int i = 0; i < N; i++) {\n    if (i) {\n      cout << \" \";\n    }\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main() {\n  int N;\n  cin >> N;\n\n  int k;\n  for (int i = 0; i < N; i++) {\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for (int i = 0; i < N; i++) {\n    cin >> k;\n    in.push_back(k);\n  }\n\n  solve();\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n    if(l>=r) return;\n    int root=pre[pos++];\n    int m = distance(in.begin(),find(in.begin(), in.end(), root));\n    rec(l,m);\n    rec(m+1,r);\n    post.push_back(root);\n}\n\nvoid solve(){\n    pos=0;\n    rec(0,pre.size());\n    for(int i=0; i<n; i++){\n        if( i )cout<<\" \";\n        cout << post[i];\n    }\n    cout <<endl;\n}\n\nint main(){\n    int k;\n    cin >> n;\n    for(int i=0; i<n; i++){\n        cin >> k;\n        pre.push_back(k);\n        \n    }\n    \n    for(int i=0; i<n; i++){\n        cin >> k;\n        in.push_back(k);\n    }\n    \n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n    if (l>=r) return;\n    int root=pre[pos++];\n    int m=distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m+1, r);\n    post.push_back(root);\n}\n\nvoid solve() {\n    pos = 0;\n    rec(0, pre.size());\n    for(int i=0; i<n; i++){\n        if(i) cout<<\" \";\n        cout << post[i];\n    }\n    cout<<endl;\n}\n\nint main(){\n    int k;\n    cin>>n;\n    \n    for(int i=0; i<n; i++){\n        cin>>k;\n        pre.push_back(k);\n    }\n    \n    for (int i=0;i<n;i++){\n        cin>>k;\n        in.push_back(k);\n    }\n    solve();\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <iterator>\n#include<algorithm>\nstatic const int NIL = -1;\nstatic const int NumberChild = 2;\nclass Tree {\nprivate:\n\tint id;\n\tint parent;\n\tint child[NumberChild];\n\npublic:\n\tTree() {\n\t\tid = child[0] = child[1] = parent = NIL;\n\t}\n\tvoid AddParent(int ID) {\n\t\tparent = ID;\n\t\treturn;\n\t}\n\tvoid AddID(int ID) {\n\t\tid = ID;\n\t\treturn;\n\t}\n\tvoid AddChild(std::vector<int>&Child) {\n\t\tfor (unsigned int i = 0; i < Child.size(); ++i) {\n\t\t\tchild[i] = Child[i];\n\n\t\t}\n\n\t\treturn;\n\t}\n\tint GetRoot(std::vector<Tree> nodes, int ID) {\n\t\tint RootID = ID;\n\t\tif (RootID != NIL&&nodes[RootID].parent != NIL) {\n\t\t\tRootID = GetRoot(nodes, nodes[RootID].parent);\n\t\t}\n\t\treturn RootID;\n\t}\n\tvoid PreorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid InorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid PostorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t\tif (nodes[ID].id != NIL)std::cout << \" \" << nodes[ID].id;\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid GetVctorPostorderTreeWalk(std::vector<Tree> nodes, std::vector<int>& returnvector, int ID) {\n\n\t\tif (ID != NIL) {\n\n\t\t\tGetVctorPostorderTreeWalk(nodes, returnvector, nodes[ID].child[0]);\n\t\t\tGetVctorPostorderTreeWalk(nodes, returnvector, nodes[ID].child[1]);\n\t\t\tif (nodes[ID].id != NIL)returnvector.push_back(nodes[ID].id);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid Reconstruct(std::vector<int>Pre, std::vector<int>In, std::vector<Tree> &nodes, const int Root, int &cnt) {\n\n\t\tunsigned int m = std::distance(In.begin(), std::find(In.begin(), In.end(), Root));\n\n\t\t//nodes[cnt].AddID(Root);\n\t\tif (Root == NIL) { return; }\n\t\tnodes[Root].AddID(Root);\n\n\t\tif (m == 0) {\n\t\t\tstd::vector<int>RestPre;\n\t\t\tRestPre.push_back(NIL);\n\t\t\tif (m < Pre.size() - 1) {\n\t\t\t\tRestPre.pop_back();\n\t\t\t\tstd::copy(&Pre[m] + 1, &Pre[Pre.size() - 1] + 1, std::back_inserter(RestPre));\n\t\t\t}\n\t\t\tstd::vector<int> RestIn;\n\t\t\tRestIn.push_back(NIL);\n\t\t\tif (m < In.size() - 1) {\n\t\t\t\tRestIn.pop_back();\n\t\t\t\tstd::copy(&In[m] + 1, &In[In.size() - 1] + 1, std::back_inserter(RestIn));\n\t\t\t}\n\t\t\tstd::vector<int> child(2);\n\t\t\tchild[0] = NIL;\n\t\t\tchild[1] = RestPre.empty() ? NIL : RestPre[0];\n\t\t\tnodes[Root].AddChild(child);\n\t\t\tReconstruct(RestPre, RestIn, nodes, RestPre[0], ++cnt);\n\t\t\treturn;\n\t\t}\n\t\tstd::vector<int>PreLeft;\n\t\tstd::copy(&Pre[1], &Pre[m] + 1, std::back_inserter(PreLeft));\n\t\tstd::vector<int>InLeft;\n\t\tstd::vector<int>PreRight;\n\t\tPreRight.push_back(NIL);\n\t\t//PreRight={NIL};\n\t\tstd::vector<int> InRight;\n\t\tInRight.push_back(NIL);\n\t\t//InRight={NIL};\n\t\tstd::copy(&In[0], &In[m - 1] + 1, std::back_inserter(InLeft));\n\n\t\tif (m < Pre.size() - 1) {\n\t\t\tPreRight.pop_back();\n\t\t\tstd::copy(&Pre[m] + 1, &Pre[Pre.size() - 1] + 1, std::back_inserter(PreRight));\n\t\t}\n\t\tif (m < In.size() - 1) {\n\t\t\tInRight.pop_back();\n\t\t\tstd::copy(&In[m] + 1, &In[In.size() - 1] + 1, std::back_inserter(InRight));\n\t\t}\n\n\n\n\n\t\tstd::vector<int> child(2);\n\t\tchild[0] = PreLeft.empty() ? NIL : PreLeft[0];\n\t\tchild[1] = PreRight.empty() ? NIL : PreRight[0];\n\t\t//nodes[cnt].AddChild(child);\n\t\tnodes[Root].AddChild(child);\n\t\tfor (unsigned int i = 0; i < child.size(); ++i) {\n\n\t\t\tif (child[i] != NIL) { nodes[child[i]].AddParent(Root); }\n\t\t}\n\t\tReconstruct(PreLeft, InLeft, nodes, PreLeft[0], ++cnt);\n\t\tReconstruct(PreRight, InRight, nodes, PreRight[0], ++cnt);\n\t}\n};\n\nvoid SetVector(std::vector<int>&InputVector) {\n\tfor (unsigned int i = 0; i < InputVector.size(); ++i) {\n\t\tstd::cin >> InputVector[i];\n\t}\n\treturn;\n}\nint main(void) {\n\n\tint n;\n\tstd::cin >> n;\n\tstd::vector<int>Pre(n);\n\tstd::vector<int>In(n);\n\tSetVector(Pre);\n\tSetVector(In);\n\tstd::vector<Tree> nodes(n + 1);\n\t//ReconstructWithNoParent\n\tint cnt = 0;\n\tnodes[1].Reconstruct(Pre, In, nodes, Pre[0], cnt);\n\n\t//nodes[1].PostorderTreeWalk(nodes, 1);\n\tstd::vector<int>Print;\n\tnodes[1].GetVctorPostorderTreeWalk(nodes, Print, 1);\n\t//Print=nodes[1].GetVctorPostorderTreeWalk(nodes, 1);\n\tfor (unsigned int i = 0; i < Print.size(); ++i) {\n\t\tif (i) { std::cout << \" \"; }\n\t\tstd::cout << Print[i];\n\t\tif (i == Print.size() - 1) { std::cout << std::endl; }\n\t}\n\n\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint N, pos;\nvector<int> pre, in, post\n\nvoid rec(int left, int right) {\n  if (left >= right) {\n    return;\n  }\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(left, m);\n  rec(left + 1, right);\n  post.push_back(root);\n}\n\nvoid solve() {\n  pos = 0;\n  rec(0, pre.size());\n  for (int i = 0; i < N; i++) {\n    if (i) {\n      cout << \" \";\n    }\n    cout << post[i]\n  }\n  cout << endl;\n}\n\nint main() {\n  int N;\n  cin >> N;\n\n  int k;\n  for (int i = 0; i < N; i++) {\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for (int i = 0; i < N; i++) {\n    cin >> k;\n    in.push_back(k);\n  }\n\n  solve();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <list>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <ostream>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n\n#define N 45\n#define INF (1 << 30)\n#define NIL -1\nconst int mod = 1e9 + 7;\nusing namespace std;\nint pre[N];\nint in[N];\nint post[N];\nvoid rebuild(int preL, int inL, int postL, int n)\n{\n\tif (n == 0)\n\t\treturn;\n\tif (n == 1)\n\t{\n\t\tpost[postL] = pre[preL];\n\t\treturn;\n\t}\n\tpost[postL + n - 1] = pre[preL];\n\tint i;\n\tfor (i = 0; i < n; ++i)\n\t{\n\t\tif (in[i + inL] == pre[preL])\n\t\t\tbreak;\n\t}\n\trebuild(preL + 1, inL, postL, i);\n\trebuild(preL + i + 1, inL + i + 1, postL + i, n - i - 1);\n}\nint main()\n{\n\tint T, n, k;\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> pre[i];\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> in[i];\n\trebuild(0, 0, 0, n);\n\tfor (int i = 0; i < n - 1; ++i)\n\t\tcout << post[i] << ' ';\n\tcout << post[n - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<list>\nusing namespace std;\n\nint a[110],preo[110],ino[110];\nvector <int> posto;\nint pos;\nvoid reco(int l,int r)\n{\n\tif(l>=r)return;\n\tint root=preo[pos++];\n\tint i;\n\tfor(i=0;ino[i]!=root;i++);\n\treco(l,i);\n\treco(i+1,r);\n\tposto.push_back(root);\n}\n\nint main()\n{\n\tint n;cin>>n;\n\tfor(int i=0;i<n;cin>>preo[i++]);\n\tfor(int i=0;i<n;cin>>ino[i++]);\n\tpos=0;\n\treco(0,n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(i)cout<<\" \";\n\t\tcout<<posto[i];\n\t}\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * ALDS1_7_D.cpp\n *\n *  Created on: May 3, 2018\n *      Author: 13743\n */\n\n#include<iostream>\n#include<stack>\n\nusing namespace std;\n\nint n;\nint pre[42];\nint in[42];\nint preInv[42];\nint inInv[42];\n\nstack<int> post;\n\nvoid reconstruct(int key, int l, int r) {\n\tif(l > r) return;\n\tpost.push(key);\n\tint c = inInv[key];\n\tint leftT = c - l;\n\treconstruct(pre[preInv[key]+leftT+1], c+1, r);\n\treconstruct(pre[preInv[key]+1], l, c-1);\n}\n\nint main() {\n\tcin >> n;\n\tfor(int i=1; i<=n; i++) {\n\t\tcin >> pre[i];\n\t\tpreInv[pre[i]] = i;\n\t}\n\tfor(int i=1; i<=n; i++) {\n\t\tcin >> in[i];\n\t\tinInv[in[i]] = i;\n\t}\n\n\treconstruct(pre[1], 1, n);\n\n\tcout << post.top();\n\tpost.pop();\n\twhile(!post.empty()) {\n\t\tcout << \" \" << post.top();\n\t\tpost.pop();\n\t}\n\tcout << endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n,pos=0;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r){\n\tif(r<=l) return;\n\tint root=pre[pos++];\n\tint m=distance(in.begin(),find(in.begin(),in.end(),root));\n\trec(l,m);\n\trec(m+1,r);\n\tpost.push_back(root);\n}\n\nint main(){\n\tint k;\n\tcin>>n;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tcin>>k;\n\t\tpre.push_back(k);\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tcin>>k;\n\t\tin.push_back(k);\n\t}\n\t\n\trec(0,n);\n\tfor(int i=0;i<n;i++){\n\t\tif(i) cout<<\" \";\n\t\tcout<<post[i];\n\t}\n\tcout<<endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nint N;\nint count;\nint find(int* inorder, int c)\n{\n    for (int i = 0; i < N; i++) {\n\tif (inorder[i] == c) {\n\t    return i;\n\t}\n    }\n    return 0;\n}\nvoid rec(int* preorder, int* inorder, int l, int r)\n{\n    if (l >= r) {\n\treturn;\n    }\n    int c = preorder[count++];\n    int m = find(inorder, c);\n    rec(preorder, inorder, l, m);\n    rec(preorder, inorder, m + 1, r);\n    std::cout << \" \" << c;\n}\nint main()\n{\n    std::cin >> N;\n    int* preorder = (int*)malloc(N * sizeof(int));\n    int* inorder = (int*)malloc(N * sizeof(int));\n    count = 0;\n    for (int i = 0; i < N; i++) {\n\tstd::cin >> preorder[i];\n    }\n    for (int i = 0; i < N; i++) {\n\tstd::cin >> inorder[i];\n    }\n    rec(preorder, inorder, 0, N);\n    std::cout << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<int> pre, in, post;\nint position = 0;\n\nvoid reconstruction(int left, int right) {\n  if (left >= right) return;\n  int root = pre[position];\n  position++;\n  int in_pos = distance(in.begin(), find(in.begin(), in.end(), root));\n  reconstruction(left, in_pos);\n  reconstruction(in_pos + 1, right);\n  post.push_back(root);\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n\n  int id;\n  for (int i = 0; i < n; i++) {\n    cin >> id;\n    pre.push_back(id);\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> id;\n    in.push_back(id);\n  }\n\n  reconstruction(0, n);\n\n  for (int i = 0; i < n; i++) {\n    if (i != 0) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nstruct BINNODE {\n\tint parent;\n\tint left;\n\tint right;\n\n\tBINNODE () { // default constructor\n\t\tparent=-1;\n\t\tleft=-1;\n\t\tright=-1;\n\t}\n};\n\nvoid make_node(vector<int>& pre, vector<int>& in, pair<int,int> pre_indx, pair<int,int> in_indx, int parent, vector<BINNODE>& node) {\n\tint pre_found=pre_indx.first, in_found=in_indx.first;\n\n\tnode[pre[pre_indx.first]].parent=parent;\n\n\twhile(pre[pre_indx.first]!=in[in_found]) {\n\t\t++in_found;\n\t\t++pre_found;\n\t}\n\n\tif(in_found==in_indx.first) {\n\t\tnode[pre[pre_indx.first]].left=-1;\n\t} else {\n\t\tnode[pre[pre_indx.first]].left=pre[pre_indx.first+1];\n\t\tmake_node(pre,in,{pre_indx.first+1,pre_found},{in_indx.first,in_found-1},pre[0],node);\n\t}\n\tif(in_found==in_indx.second) {\n\t\tnode[pre[pre_indx.first]].right=-1;\n\t} else {\n\t\tnode[pre[pre_indx.first]].right=pre[pre_found+1];\n\t\tmake_node(pre,in,{pre_found+1,pre_indx.second},{in_found+1,in_indx.second},pre[0],node);\n\t}\n\treturn;\n}\n\n\nvoid postorderwalk(vector<BINNODE>&node, int root) {\n\tif(root==-1) return;\n\tpostorderwalk(node,node[root].left);\n\tpostorderwalk(node,node[root].right);\n\tif(node[root].parent==-1) {\n\t\tprintf(\"%d\\n\",root);\n\t} else {\n\t\tprintf(\"%d \",root);\n\t}\n\treturn;\n}\n\nint main() {\n\tint n;\n\tint i;\n\tint root;\n\tvector<int> pre,in;\n\tvector<BINNODE> node;\n\tscanf(\"%d\",&n);\n\tnode.resize(n+1);\n\tpre.resize(n);\n\tin.resize(n);\n\tfor(i=0; i<n; ++i) {\n\t\tscanf(\"%d\",&pre[i]);\n\t}\n\tfor(i=0; i<n; ++i) {\n\t\tscanf(\"%d\",&in[i]);\n\t}\n\troot=pre[0];\n\tmake_node(pre,in,{0,n-1},{0,n-1},-1,node);\n\tpostorderwalk(node,root);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n\nusing namespace std;\n\nint n, pos;\nint pre[40], in[40], post[40], pre_to_in[40], in_to_pre[40];\nbool pre_used[40];\n\ninline void to_post(int pre_root, int num) {\n\n//    printf(\"[to_post] pre_root = %d, num = %d\\n\", pre_root, num);\n\n    int in_root = pre_to_in[pre_root], left_tree_node_num = 0;\n\n    // whether pre_root has a left tree or not. \n    if (in_root - 1 >= 0 && !pre_used[in_to_pre[in_root - 1]]) {\n        pre_used[pre_root + 1] = true;\n        int i = pre_to_in[pre_root + 1];    // in-left root\n        while (--i >= 0 && !pre_used[in_to_pre[i]])\n            ++left_tree_node_num;\n        i = pre_to_in[pre_root + 1];\n        while (++i < n && !pre_used[in_to_pre[i]])\n            ++left_tree_node_num;\n        ++left_tree_node_num;\n        to_post(pre_root + 1, in_to_pre[in_root - 1] - pre_root);\n    }\n\n    // whether pre_root has a right tree or not. \n    if (in_root + 1 < n && !pre_used[in_to_pre[in_root + 1]]) {\n        int pre_right_root = pre_root + left_tree_node_num + 1;\n        pre_used[pre_right_root] = true;\n        to_post(pre_right_root, num - left_tree_node_num);\n    }\n\n    post[pos++] = pre[pre_root];\n}\n\nint main(void) {\n\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &pre[i]);\n    }\n\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &in[i]);\n        for (int j = 0; j < n; ++j) {\n            if (pre[j] == in[i]) {\n                pre_to_in[j] = i;\n                in_to_pre[i] = j;\n            }\n        }\n    }\n\n    pre_used[0] = true;\n    to_post(0, n);\n\n    printf(\"%d\", post[0]);\n    for (int i = 1; i < n; ++i) {\n        printf(\" %d\", post[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <limits.h>\n#include <bitset>\n\n#include <tuple>\n#include <unordered_map>\n\n#define mp       make_pair\n#define mt       make_tuple\n#define pb       push_back\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint N;\nvector<int> pre;\nmap<int, int> in;\nvector<int> ans;\nint pos;\nvoid rec(int l, int r){\n\tif (l >= r){\n\t\treturn ;\n\t}\n\tint node = pre[pos++];\n\tint index = in[node];\n\trec(l, index);\n\trec(index + 1, r);\n\tans.push_back(node);\n}\n\nint main(){\n\tcin >> N;\n\tpre.resize(N);\n\tpos = 0;\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> pre[i];\n\t}\n\tfor (int i = 0; i < N; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\tin[x] = i;\n\t}\n\trec(0, N);\n\tfor (int i = 0; i < ans.size(); i++){\n\t\tif (i != ans.size() - 1){\n\t\t\tcout << ans[i] << \" \";\n\t\t}else{\n\t\t\tcout << ans[i] << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define UNDEF -1\n\nstruct node{\n\tint parent = 0;\n\tint left = 0;\n\tint right = 0;\n};\n\nvoid Postorder_Rec(vector<node> tree, int root, bool &isFirst){\n\tif (tree[root].left != UNDEF) Postorder_Rec(tree, tree[root].left, isFirst);\n\tif (tree[root].right != UNDEF) Postorder_Rec(tree, tree[root].right, isFirst);\n\tcout << (isFirst ? \"\" : \" \") << root;\n\tisFirst = false;\n\treturn;\n}\n\nint Reconstruct(vector<node> &tree, vector<int> preorder, vector<int> inorder, int start, int end){ //0, n-1\n\tif (start > end) return UNDEF;\n\tif (start == end ) return inorder[start];\n\tint mini, minj;\n\tint cur;\n\tfor (int i = start; i <= end; i++){\n\t\tfor (int j = 0; j <= preorder.size(); j++){\n\t\t\tif (preorder[j] == inorder[i]){\n\t\t\t\tcur = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == start || cur < minj){\n\t\t\tminj = cur;\n\t\t\tmini = i;\n\t\t}\n\t}\n\ttree[inorder[mini]].left = Reconstruct(tree, preorder, inorder, start, mini - 1);\n\ttree[inorder[mini]].right = Reconstruct(tree, preorder, inorder, mini + 1, end);\n\treturn inorder[mini];\n}\n\nint height(vector<node> tree, const int id){\n\tif (tree[id].left == UNDEF && tree[id].right == UNDEF) return 0;\n\tif (tree[id].left == UNDEF) return height(tree, tree[id].right) + 1;\n\tif (tree[id].right == UNDEF) return height(tree, tree[id].left) + 1;\n\tint r = height(tree, tree[id].right);\n\tint l = height(tree, tree[id].left);\n\treturn r > l ? r + 1 : l + 1;\n}\n\nint main(){\n\n\tint n;\n\tcin >> n;\n\tvector<int> preorder(n), inorder(n);\n\tint id;\n\tnode nullnode;\n\tnullnode.parent = UNDEF;\n\tnullnode.left = UNDEF;\n\tnullnode.right = UNDEF;\n\tvector<node> tree(n+1, nullnode);\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> id;\n\t\tpreorder[i] = id;\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> id;\n\t\tinorder[i] = id;\n\t}\n\n\tReconstruct(tree, preorder, inorder, 0, n-1);\n\n\tint maxheight = height(tree, 1);\n\tint root = 1;\n\tfor (int i = 1; i < tree.size(); i++){\n\t\tif (maxheight < height(tree, i)){\n\t\t\tmaxheight = height(tree, i);\n\t\t\troot = i;\n\t\t}\n\t}\n\tbool isFirst = true;\n\tPostorder_Rec(tree, root, isFirst);\n\tcout << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid reconstruction(int l, int r) {\n  if ( l >= r ) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  reconstruction(l, m);\n  reconstruction(m + 1, r);\n  post.push_back(root);\n}\n\nvoid solve() {\n  pos = 0;\n  reconstruction(pos, pre.size());\n  for ( int i = 0; i < n; i++ ) {\n    if ( i ) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n\n\nint main() {\n  int v;\n  cin >> n;\n\n  for ( int i = 0; i < n; i++ ) {\n    cin >> v;\n    pre.push_back(v);\n  }\n\n  for ( int i = 0; i < n; i++ ) {\n    cin >> v;\n    in.push_back(v);\n  }\n\n  solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n \nstruct node{\n    int l,r;\n};\nnode v[41];\nvector<int> postord;\nvoid dfs(int vi){\n    if(v[vi].l!=0)dfs(v[vi].l);\n    if(v[vi].r!=0)dfs(v[vi].r);\n    postord.pb(vi);\n}\nint pre[41],in[41];\nint main(){\n    int n,root;\n    cin>>n;\n    rep(i,n) cin>>pre[i];\n    rep(i,n) cin>>in[i];\n    root=pre[0];\n    int cp=0,ci=0;\n    while(cp<n-1){\n        v[pre[cp]].l=pre[cp+1];++cp;\n        while(cp<n&&pre[cp]==in[ci]){\n            ++ci;\n            while(ci<n-1&&v[in[ci]].l==in[ci+1]) ++ci;\n            v[in[ci]].r=in[ci+1];++ci;\n            ++cp;\n        } \n    }\n    dfs(root);\n    rep(i,n) cout<<postord[i]<<(i==n-1?\"\":\" \");\n    cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nvector<int> L;\n\nstruct Vertex{\n\tint left;\n\tint right;\n};\n\nvoid Postorder(vector<Vertex> &T,int root){\n\tif(T[root].left!=-1) Postorder(T,T[root].left);\n\tif(T[root].right!=-1) Postorder(T,T[root].right);\n\tL.push_back(root+1);\n\treturn;\n}\n\nvoid Reconstruction(vector<Vertex> &T, vector<int> &Pre,vector<int> &In,int p,int q,int s,int t){\n\tint root = Pre[p];\n\tif(p==q){\n\t\tT[root].left=-1;\n\t\tT[root].right=-1;\n\t\treturn ;\n\t}\n\t\n\tvector<bool> check(1000000,false);\n\t\n\t//k???In????????????root?????????????????????\n\tint k=-1;\n\tfor(int i=s;i<t+1;i++){\n\t\tcheck[In[i]]=true;\n\t\tif (In[i]==root){\n\t\t\tk=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t//l???Pre?????????????????´?????¨???????????????????????????????????????\n\tint l;\n\tfor(int i=p;i<q+1;i++){\n\t\tif(check[Pre[i+1]]==false){\n\t\t\tl=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif(s==k){\n\t\tT[root].left=-1;\n\t\tT[root].right=Pre[l+1];\n\t\n\t\tReconstruction(T,Pre,In,l+1,q,k+1,t);\n\t}else if(t==k){\n\t\tT[root].left=Pre[p+1];\n\t\tT[root].right=-1;\n\t\n\t\tReconstruction(T,Pre,In,p+1,l,s,k-1);\n\t}else{\n\t\tT[root].left=Pre[p+1];\n\t\tT[root].right=Pre[l+1];\n\t\n\t\tReconstruction(T,Pre,In,p+1,l,s,k-1);\n\t\tReconstruction(T,Pre,In,l+1,q,k+1,t);\n\t}\n}\n\nint main(){\n\tint n,x;\n\tcin >> n;\n\tvector<int> Pre(n);\n\tvector<int> In(n);\n\tfor (int i=0;i<n;i++){\n\t\tcin >> x;\n\t\tPre[i]=x-1;\n\t}\n\t\n\tfor (int i=0;i<n;i++){\n\t\tcin >> x;\n\t\tIn[i]=x-1;\n\t}\n\t\n\tvector<Vertex> T(n);\n\tReconstruction(T,Pre,In,0,n-1,0,n-1);\n\tPostorder(T,Pre[0]);\n\t\n\tfor (int i=0;i<L.size();i++){\n\t\tif(i==L.size()-1){\n\t\t\tcout << L[i] <<endl;\n\t\t}else{\n\t\t\tcout << L[i] <<\" \";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <vector>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\n\nint n, pos;\nvector<int > pre, in, post;\n\nvoid rec(int l, int r){\n\tif(l >= r)\treturn ;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\nvoid solve(){\n\tpos = 0;\n\trec(0, pre.size());\n\tfor(int i = 0; i < n; i++){\n\t\tif(i)\tprintf(\" \");\n\t\tcout << post[i];\n\t}\n\tprintf(\"\\n\");\n}\n\nint main(){\n\tint temp;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> temp;\n\t\tpre.push_back(temp);\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> temp;\n\t\tin.push_back(temp);\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct node{\n    int parent;\n    int left;\n    int right;\n    node(){\n        parent = 0;\n        left   = 0;\n        right  = 0;\n    }\n};\n\nvoid restore(vector<int>& pre_o, vector<int>& in_o, vector<node>& T){\n    if (pre_o.size() <= 2) return;\n    int parent = pre_o[1];\n    vector<int> left_in_o;\n    left_in_o.push_back(0);\n    vector<int> right_in_o;\n    right_in_o.push_back(0);\n    int id;\n    for (id = 1; in_o[id] != parent; id++) {\n        left_in_o.push_back(in_o[id]);\n    }\n    for (id++; id < in_o.size(); id++) {\n        right_in_o.push_back(in_o[id]);\n    }\n\n    vector<int> left_pre_o;\n    left_pre_o.push_back(0);\n    vector<int> right_pre_o;\n    right_pre_o.push_back(0);\n    for (id = 2; id <= left_in_o.size(); id++) {\n        left_pre_o.push_back(pre_o[id]);\n    }\n    for (; id < pre_o.size(); id++) {\n        right_pre_o.push_back(pre_o[id]);\n    }\n\n    restore(left_pre_o , left_in_o , T);\n    restore(right_pre_o, right_in_o, T);\n\n    if (left_pre_o.size() > 1) {\n        T[parent].left  = left_pre_o[1];\n        T[left_pre_o[1]].parent  = parent;\n    }\n    if (right_pre_o.size() > 1) {\n        T[parent].right = right_pre_o[1];\n        T[right_pre_o[1]].parent = parent;\n    }\n}\n\nint find_root(vector<node>& T){\n    for (int i = 1; i < T.size(); i++) {\n        if (T[i].parent == 0) return i;\n    }\n}\n\nvoid do_post_order(int id, vector<node>& T, queue<int>& Q){\n    if (id == 0) return;\n    do_post_order(T[id].left , T, Q);\n    do_post_order(T[id].right, T, Q);\n    Q.push(id);\n}\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int> pre_o(n + 1);\n    for (int i = 1; i <= n; i++) {\n        cin >> pre_o[i];\n    }\n    vector<int> in_o(n + 1);\n    for (int i = 1; i <= n; i++) {\n        cin >> in_o[i];\n    }\n\n    vector<node> T(n + 1);\n    restore(pre_o, in_o, T);\n\n    int root = find_root(T);\n    queue<int> Q;\n    do_post_order(root, T, Q);\n    cout << Q.front();\n    Q.pop();\n    while (!Q.empty()) {\n        cout << \" \" << Q.front();\n        Q.pop();\n    }\n    cout << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define N 40\n\nvector<int> a, b, c;\n\nvoid postOrder(vector<int>::iterator a1, vector<int>::iterator a2, vector<int>::iterator b1, vector<int>::iterator b2)\n{\n    //printf(\"%d %d %d %d\\n\", *a1, *(a2 - 1), *b1, *(b2 - 1));\n    vector<int>::iterator itr;\n    c.push_back(*a1);\n    //printf(\"%d\\n\", *a1);\n    itr = find(b1, b2, *a1); //itrator of root on inorder tree walk\n    int d = itr - b1;\n    if (a1 + d + 1 < a2 && itr + 1 < b2)\n        postOrder(a1 + d + 1, a2, itr + 1, b2);\n    if (a1 + 1 < a1 + d + 1 && b1 < itr)\n        postOrder(a1 + 1, a1 + d + 1, b1, itr);\n}\n\nint main()\n{\n    int n, x;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> x;\n        a.push_back(x);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        cin >> x;\n        b.push_back(x);\n    }\n\n    postOrder(a.begin(), a.end(), b.begin(), b.end());\n\n    for (int i = 0; i < c.size(); i++)\n    {\n        if (i != 0)\n            cout << \" \";\n        cout << c[c.size() - 1 - i];\n    }\n    cout << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n\nstruct TNode\n{\n\tint Index;\n\tTNode* Parent;\n\tTNode* Left;\n\tTNode* Right;\n\t\n\tTNode();\n};\n\nTNode::TNode()\n{\n\tIndex  = -1;\n\tParent = NULL;\n\tLeft   = NULL;\n\tRight  = NULL;\n}\n\ntypedef std::vector<TNode> TBinaryTree;\nvoid Initialize(TBinaryTree& BinaryTree)\n{\n\tfor(unsigned int i = 0; i < BinaryTree.size(); ++i){\n\t\tBinaryTree[i].Index = i + 1;\n\t}\n}\n\ntypedef std::vector<TNode*> TOrder;\n\nvoid InputNodes(TBinaryTree& Tree, TOrder& PreOrder, TOrder& InOrder)\n{\n\tfor(unsigned int i = 0; i < Tree.size(); ++i){\n\t\tint Index;\n\t\tstd::cin >> Index;\n\t\tPreOrder[i] = &(Tree[Index - 1]);\n\t}\n\tfor(unsigned int i = 0; i < Tree.size(); ++i){\n\t\tint Index;\n\t\tstd::cin >> Index;\n\t\tInOrder[i] = &(Tree[Index - 1]);\n\t}\n}\n\nTOrder::iterator GetPreOrderNext(TOrder::iterator Node, int Count)\n{\n\tTOrder::iterator Next = Node;\n\tfor(int i = 0; i < Count; ++i) ++Next;\n\treturn Next;\n}\n\nvoid ReconstructTree(TOrder::iterator PreOrderPos,\n\t                 TOrder::iterator PreOrderLast,\n\t                 TOrder::iterator InOrderBegin,\n\t                 TOrder::iterator InOrderLast)\n{\n\tif(PreOrderPos == PreOrderLast) return;\n\tTOrder::iterator Position = std::find(InOrderBegin, InOrderLast + 1, *PreOrderPos);\n\tTOrder::iterator Left  = GetPreOrderNext(PreOrderPos, 1);\n\tTOrder::iterator Right = GetPreOrderNext(PreOrderPos, 1 + distance(InOrderBegin, Position));\n\tif(Position != InOrderBegin){\n\t\t(*PreOrderPos)->Left = *Left;\n\t\t(*Left)->Parent = *PreOrderPos;\n\t\tReconstructTree(Left, Right - 1, InOrderBegin, Position - 1);\n\t}\n\tif(Position != InOrderLast){\n\t\t(*PreOrderPos)->Right = *Right;\n\t\t(*Right)->Parent = *PreOrderPos;\n\t\tReconstructTree(Right, PreOrderLast, Position + 1, InOrderLast);\n\t}\n}\n\nvoid OutputPostOrder(const TNode* Root, const TNode* End)\n{\n\tif(Root == NULL) return;\n\tOutputPostOrder(Root->Left, End);\n\tOutputPostOrder(Root->Right, End);\n\tstd::cout << Root->Index;\n\tif(Root != End){\n\t\tstd::cout << \" \";\n\t}else{\n\t\tstd::cout << std::endl;\n\t}\n}\n\nint main()\n{\n\tint Count;\n\tstd::cin >> Count;\n\tTBinaryTree BinaryTree(Count);\n\tInitialize(BinaryTree);\n\tTOrder PreOrder(Count);\n\tTOrder InOrder(Count);\n\t\n\tInputNodes(BinaryTree, PreOrder, InOrder);\n\t\n\tReconstructTree(PreOrder.begin(), PreOrder.end() - 1, InOrder.begin(), InOrder.end() - 1);\n\t\n\tTNode* Root = *(PreOrder.begin());\n\tOutputPostOrder(Root, Root);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Reconstruction of a Tree\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid solve(int l, int r) {\n    if(l >= r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    solve(l, m);\n    solve(m+1, r);\n    post.push_back(root);\n}\n\nint main() {\n    cin >> n;\n\n    int k;\n    for(int i=0; i<n; i++) {\n        cin >> k;\n        pre.push_back(k);\n    }\n    for(int i=0; i<n; i++) {\n        cin >> k;\n        in.push_back(k);\n    }\n\n    pos = 0;\n    solve(0, n);\n\n    for(int i=0; i<n-1; i++) cout << post[i] << \" \";\n    cout << post[n-1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<stdlib.h>\n\n// I did it!\nint *P, *L, *R;\n\nvoid maketree(int* A, int* B, int h)\n{\n    int x, m;\n    x = A[0];\n    if(h == 1){\n        L[x] = -1; R[x] = -1; return;\n    }else{\n        m = 0;\n        while(B[m] != A[0]) m++;\n        m++;\n        if(m == 1){\n            L[x] = -1; R[x] = A[1]; P[A[1]] = x;\n            maketree(A + 1, B + 1, h - 1);\n        }else if(m == h){\n            L[x] = A[1]; P[A[1]] = x; R[x] = -1;\n            maketree(A + 1, B, h - 1);\n        }else{\n            L[x] = A[1]; P[A[1]] = x; R[x] = A[m]; P[A[m]] = x;\n            maketree(A + 1, B, m - 1);\n            maketree(A + m, B + m, h - m);\n        }\n    }\n}\n\nvoid postorder(int i, int f)\n{\n    if(i < 0) return;\n    postorder(L[i], f);\n    postorder(R[i], f);\n    if(i != f) cout << \" \";\n    cout << i;\n}\n\nint main()\n{\n    int i, n, first;\n    cin >> n;\n    P = new int [n]; L = new int [n]; R = new int [n];\n    if(P == NULL || L == NULL || R == NULL) exit(EXIT_FAILURE);\n\n    int *A, *B;\n    A = new int [n]; B = new int [n];\n    if(A == NULL || B == NULL) exit(EXIT_FAILURE);\n\n    for(i = 0; i < n; i++){ cin >> A[i]; P[i] = L[i] = R[i] = -1; }\n    for(i = 0; i < n; i++){ cin >> B[i]; }\n\n    maketree(A, B, n);\n    delete [] A; delete [] B;\n\n    // where is root?\n    i = 0; while(P[i] >= 0) i++;\n    // where is the first output?\n    first = i; while(L[first] >= 0){ first = L[first]; }\n\n    postorder(i, first);\n    cout << endl;\n    delete [] P; delete [] L; delete [] R;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n  if(l >= r)\n    return;\n  int root = pre[pos++];\n  int m = distance(in.begin(),find(in.begin(),in.end(),root));\n  rec(l,m);\n  rec(m+1, r);\n  post.push_back(root);\n}\n\nvoid solve(){\n  pos = 0;\n  rec(0,pre.size());\n  for(int i = 0; i < n; i++){\n    if(i)\n      cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main(){\n  int k;\n  cin >> n;\n  for(int i = 0; i < n; i++){\n    cin >> k;\n    pre.push_back(k);\n  }\n  for(int i = 0; i < n; i++){\n    cin >> k;\n    in.push_back(k);\n  }\n  solve();\n  return 0;\n}\n\t\t      "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int MAXt=10000;\n\nint n,pos=0;\nint pre[MAXt],in[MAXt];\n\nvoid rec(int l,int r)\n{\n\tif(l>=r)return;\n\tint root=pre[pos++];\n\tint i;\n\tfor(i=0;i<n;i++)if(in[i]==root)break;\n\trec(l,i);\n\trec(i+1,r);\n\tcout<<\" \"<<root;\n}\n\nint main() {\n\tcin>>n;\n\tfor(int i=0;i<n;i++)cin>>pre[i];\n\tfor(int i=0;i<n;i++)cin>>in[i];\n\trec(0,n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct Node{\n    int left;\n    int right;\n};\n\nclass Tree{\n    vector<Node> node;\npublic:\n    Tree(int n){\n        node.resize(n);\n    }\n    int make_tree(vector<int>& pre, vector<int>& in){\n        if (pre.empty()) return -1;\n        int obj = pre[0];\n        vector<int> in_left;\n        vector<int> in_right;\n        vector<int>::iterator it = in.begin();\n        while (*it != obj) {\n            in_left.push_back(*it);\n            it++;\n        }\n        it++;\n        while (it < in.end()) {\n            in_right.push_back(*it);\n            it++;\n        }\n        vector<int> pre_left;\n        vector<int> pre_right;\n        it = pre.begin() + 1;\n        for (int i = 0; i < in_left.size(); i++) {\n            pre_left.push_back(*it);\n            it++;\n        }\n        while (it < pre.end()) {\n            pre_right.push_back(*it);\n            it++;\n        }\n        node[obj].left  = make_tree(pre_left , in_left );\n        node[obj].right = make_tree(pre_right, in_right);\n        return obj;\n    }\n    void post_order(int p, vector<int>& post){\n        if (p == -1) return;\n        post_order(node[p].left , post);\n        post_order(node[p].right, post);\n        post.push_back(p);\n    }\n};\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int> pre(n);\n    vector<int> in(n);\n    for (int i = 0; i < n; i++) {\n        cin >> pre[i];\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> in[i];\n    }\n    Tree T(n + 1);\n    T.make_tree(pre, in);\n    vector<int> post;\n    T.post_order(pre[0], post);\n    for (int i = 0; i < post.size(); i++) {\n        cout << post[i] << (i == post.size() - 1 ? '\\n' : ' ');\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> Pre, In, Post;\nint pos;\n\nvoid reconstruction(int l, int r){\n    if(l>=r) return;    //葉が来るまで\n    int root = Pre[pos++];  //次の節点\n    int m = distance(In.begin(), find(In.begin(), In.end(), root));\n    reconstruction(l, m);\n    reconstruction(m+1, r);\n    Post.push_back(root);\n}\n\nvoid solve(){\n    pos = 0;\n    reconstruction(0, Pre.size());\n    for(int i=0, size = Pre.size(); i<size; i++){\n        if(i) printf(\" \");\n        printf(\"%d\", Post[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main(){\n\n    int n;\n    scanf(\"%d\", &n);\n\n    for(int i=0; i<n; i++){\n        int k;\n        scanf(\"%d\", &k);\n        Pre.push_back(k);\n    }\n    for(int i=0; i<n; i++){\n        int k;\n        scanf(\"%d\", &k);\n        In.push_back(k);\n    }\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<siostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l, int r){\n  if(l>=r) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(),in.end(),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\n\nvoid solve(){\n  int i;\n  pos = 0;\n  rec(0,pre.size());\n  for(i=0;i<n;i++){\n    if(i) cout << \" \";\n    cout << post[i];;\n  }\n  cout << endl;\n}\n\nint main(){\n  int k;\n  cin >> n;\n\n  for(int i =0;i<n;i++){\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for(int i=0;i<n;i++){\n    cin >> k;\n    in.push_push(k);\n  }\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\nusing namespace std;\n\nclass Node {\nprivate:\n\tint id;\n\tNode *parent;\n\tNode *child_l;\n\tNode *child_r;\npublic:\n\tNode(int id){ this->id = id; parent = NULL; child_l = NULL; child_r = NULL;}\n\tvoid setChildl(Node *nl);\n\tvoid setChildr(Node *nr);\n\tvoid setParent(Node *np){ parent = np; }\n\tvoid setSibling(Node *ns);\n\tNode *searchNode(int id);\n\tint getId(){ return id; }\n\tNode *getParent(){ return parent; }\n\tNode *getChildl(){ return child_l; }\n\tNode *getChildr(){ return child_r; }\n\tNode *getSibling();\n};\n\nvoid Node::setChildl(Node *nl)\n{\n\tchild_l = nl;\n\tif (child_l != NULL) child_l->setParent(this);\n}\n\nvoid Node::setChildr(Node *nr)\n{\n\tchild_r = nr;\n\tif (child_r != NULL) child_r->setParent(this);\n}\n\nvoid Node::setSibling(Node *ns)\n{\n\tif (parent == NULL) return;\n\tif (parent->getChildl() == this) return parent->setChildr(ns);\n\tif (parent->getChildr() == this) return parent->setChildl(ns);\n}\n\nNode *Node::searchNode(int id)\n{\n\tif (this->id == id) return this;\n\tif (child_l != NULL) {\n\t\tNode *sl = child_l->searchNode(id);\n\t\tif (sl != NULL) return sl;\n\t}\n\tif (child_r != NULL) {\n\t\tNode *sr = child_r->searchNode(id);\n\t\tif (sr != NULL) return sr;\n\t}\n\treturn NULL;\n};\n\nNode *Node::getSibling()\n{\n\tif (parent == NULL) return NULL;\n\tif (parent->getChildl() == this) return parent->getChildr();\n\tif (parent->getChildr() == this) return parent->getChildl();\n}\n\nclass BinaryTree {\nprivate:\n\tNode *preroot;\n\tNode *root;\n\tchar flag;\npublic:\n\tBinaryTree(){ preroot = NULL; root = NULL; flag = 'l'; }\n\tvoid setNodePreorder(int id);\n\tvoid setNodeInorder(int id);\n\tvoid walkPostorder();\n\tvoid walkPostorder(Node *node);\n};\n\nvoid BinaryTree::setNodePreorder(int id)\n{\n\tif (preroot == NULL) {\n\t\tpreroot = new Node(id);\n\t\troot = new Node(id);\n\t\treturn;\n\t}\n\n\tNode *node = preroot;\n\tNode *nr;\n\twhile ((nr = node->getChildr()) != NULL) node = nr;\n\tnode->setChildr(new Node(id));\n\treturn;\n}\n\nvoid BinaryTree::setNodeInorder(int id)\n{\n\tif (root == NULL) {\n\t\tcout << \"!!!\" << endl;\n\t\treturn;\n\t}\n\n\tif (id == root->getId()) {\n\t\tflag = 'r';\n\t\treturn;\n\t}\n\n\tif (flag == 'l') {\n\t\tNode *node1 = preroot->searchNode(id);\n\t\tNode *node2;\n\t\tdo {\n\t\t\tnode1 = node1->getParent();\n\t\t\tnode2 = root->searchNode(node1->getId());\n\t\t} while (node2 == NULL);\n\t\tif (node2 == root) {\n\t\t\tNode *node = new Node(id);\n\t\t\tnode->setChildl(node2->getChildl());\n\t\t\troot->setChildl(node);\n\t\t}\n\t\telse if (node2->getParent() != root && node2->getSibling() == NULL) {\n\t\t\tnode2->setSibling(new Node(id));\n\t\t}\n\t\telse {\n\t\t\tnode2->setChildr(new Node(id));\n\t\t}\n\t\treturn;\n\t}\n\n\tif (flag == 'r') {\n\t\tNode *node1 = preroot->searchNode(id);\n\t\tNode *node2 = NULL;\n\t\tdo {\n\t\t\tnode1 = node1->getChildr();\n\t\t\tif (node1 == NULL) break;\n\t\t\tnode2 = root->searchNode(node1->getId());\n\t\t} while (node2 == NULL);\n\t\tif (node2 != NULL) {\n\t\t\tNode *node = new Node(id);\n\t\t\t(node2->getParent())->setChildr(node);\n\t\t\tnode->setChildl(node2);\n\t\t}\n\t\telse {\n\t\t\tNode *node = root;\n\t\t\twhile (node->getChildr() != NULL) node = node->getChildr();\n\t\t\tnode->setChildr(new Node(id));\n\t\t}\n\t\treturn;\n\t}\n}\n\nvoid BinaryTree::walkPostorder()\n{\n\twalkPostorder(root);\n}\n\nvoid BinaryTree::walkPostorder(Node *node)\n{\n\tif (node == NULL) return;\n\twalkPostorder(node->getChildl());\n\twalkPostorder(node->getChildr());\n\tcout << node->getId();\n\tif (node != root) cout << \" \";\n\telse cout << endl;\n}\n\nint main(void)\n{\n\tBinaryTree bt;\n\n\tint n, id;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> id;\n\t\tbt.setNodePreorder(id);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> id;\n\t\tbt.setNodeInorder(id);\n\t}\n\t\t\n\tbt.walkPostorder();\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n\nusing namespace std;\n\nint n,inputed_order[41] = {0};\nqueue<int> Queue;\n\nstruct Node{\n\tNode(){\n\t\tleft_child = right_child = -1;\n\t};\n\tint left_child,right_child;\n};\n\nvoid postORDER(Node order[],int id){\n\tif(order[id].left_child != -1) postORDER(order,order[id].left_child );\n\tif(order[id].right_child != -1) postORDER(order,order[id].right_child );\n\tQueue.push(id+1);\n}\n\nint findRoot(int inorder[],int left,int right){\n\tint root = inorder[left];\n\tfor(int i = left+1; i <= right; i++){\n\t\tif(inputed_order[root] > inputed_order[inorder[i]]){\n\t\t\troot = inorder[i];\n\t\t}\n\t}\n\treturn root;\n}\n\nvoid reconstruct(int inorder[],Node order[],int root,int left,int right){\n\tint root_index;\n\tfor(root_index = left; inorder[root_index] != root; root_index++);\n\tif(left < root_index){\n\t\tint new_root = findRoot(inorder,left,root_index-1);\n\t\torder[root-1].left_child = new_root-1;\n\t\tif(left < root_index-1)\treconstruct(inorder,order,new_root,left,root_index-1);\n\t}\n\tif(root_index < right){\n\t\tint new_root = findRoot(inorder,root_index+1,right);\n\t\torder[root-1].right_child = new_root-1;\n\t\tif(root_index+1 < right) reconstruct(inorder,order,new_root,root_index+1,right);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tint preorder[n],inorder[n];\n\tNode order[n];\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\",&preorder[i]);\n\t\tinputed_order[preorder[i]] = i;\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\",&inorder[i]);\n\t}\n\n\tif(n == 1){\n\t\tprintf(\"%d\\n\",preorder[0]);\n\t}else{\n\t\treconstruct(inorder,order,preorder[0],0,n-1);\n\t\tpostORDER(order,preorder[0]-1);\n\t\twhile(!Queue.empty()){\n\t\t\tif(Queue.size() != 1){\n\t\t\t\tprintf(\"%d \",Queue.front());\n\t\t\t\tQueue.pop();\n\t\t\t}else{\n\t\t\t\tprintf(\"%d\\n\",Queue.front());\n\t\t\t\tQueue.pop();\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n\nint *pre;\nint *in;\nint *post;\n\nint postorder(int prel, int inl,int n, int p){\n    if(n==0)return p;\n    p--;\n    int i;\n    int value = pre[prel];\n    post[p]=value;\n    for(i=0;i<n;i++)if(in[inl + i]==value)break;\n    if(i==n){perror(\"tree error\\n\");return -1;}\n    p = postorder(prel+1+i,inl+1+i,n-1-i,p);\n    p = postorder(prel+1,inl,i,p);\n    return p;\n}\n\nint main(){\n    int i, n;\n    scanf(\"%d\",&n);\n    pre = (int*)malloc(sizeof(int)*n);\n    in = (int*)malloc(sizeof(int)*n);\n    post = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++)scanf(\"%d\",pre+i);\n    for(i=0;i<n;i++)scanf(\"%d\",in+i);\n    if(postorder(0,0,n,n)!=0){perror(\"error\\n\");return -1;}\n    for(i=0;i<n;i++){\n        printf(\"%d\",post[i]);\n        if(i<n-1)printf(\" \");\n        else printf(\"\\n\");\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint num;\nint cnt=0;\n#define MAX 45\nint qian[MAX],zhong[MAX];\nvector<int> hou;\nvoid restruction(int l ,int r){\n\t if(l>=r) return ;\n\t int a=qian[cnt++];\n\t int pos_in;\n\t for(int i =l;i<r;i++){\n\t \tif(zhong[i]==a) {pos_in=i;break;}\n\t }\n\t restruction(l,pos_in);\n\t restruction(pos_in+1,r);\n\t hou.push_back(a);\n}\nint main(){\nscanf(\"%d\",&num);\nfor(int i=0;i<num;i++){scanf(\"%d\",&qian[i]);}\nfor(int i=0;i<num;i++){scanf(\"%d\",&zhong[i]);}\nrestruction(0,num);\nvector <int>::iterator it;\ncout<<*(hou.begin());\nfor(it=hou.begin()+1;it!=hou.end();it++){\n\tcout<<\" \"<<*it;\n}\ncout<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace  std;\n\nvoid fnInput(vector<int> &rvnPodr, vector<int> &rvnIodrSeq)\n{\n  int nMaxSiz;\n\n  cin >> nMaxSiz;\n  rvnPodr.resize(nMaxSiz + 1);\n  rvnIodrSeq.resize(nMaxSiz + 1);\n\n  for (int i = 1; i < nMaxSiz + 1; i++)\n    cin >> rvnPodr[i];\n\n  int nNode;\n  for (int i = 1; i < nMaxSiz + 1; i++)\n  {\n    cin >> nNode;\n    rvnIodrSeq[nNode] = i;\n  }\n}\n\nvoid fnPostOrder(const vector<int> &cnrvnPodr, const vector<int> &cnrvnIodrSeq, int nLeft, int nRight)\n{\n  static int stnx = 1;\n  static int stnPrt = 0;\n\n  if (nLeft == nRight) return;\n\n  int nNode = cnrvnPodr[stnx++];\n  int nMid = cnrvnIodrSeq[nNode];\n\n  fnPostOrder(cnrvnPodr, cnrvnIodrSeq, nLeft, nMid);\n  fnPostOrder(cnrvnPodr, cnrvnIodrSeq, nMid + 1, nRight);\n\n  if (stnPrt++) cout << \" \";\n  cout << nNode;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vector<int> vnPodr, vnIodrSeq;\n  fnInput(vnPodr, vnIodrSeq);\n\n  fnPostOrder(vnPodr, vnIodrSeq, 1, vnPodr.size());\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int>pre,in,post;\nint pos,n; \nvoid res(int l,int r){\n\tif(l>=r)return ;\n\tint root =pre[pos++];\n\tint m=distance(in.begin(),find(in.begin(),in.end(),root));\n\tres(l,m);\n\tres(m+1,r);\n\tpost.push_back(root);\n}\nint main(){\n\tscanf(\"%d\",&n);int k;\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&k);pre.push_back(k);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&k);in.push_back(k);\n  }\n  res(0,n); \n  for(int i=0;i<n;i++){\n \t\tif(i==0)printf(\"%d\",post[i]);\n \t\telse printf(\" %d\",post[i]);\n  } printf(\"\\n\");\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n    if (l >= r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m + 1, r);\n    post.push_back(root);\n}\n\nvoid solve() {\n    pos = 0;\n    rec(0, pre.size());\n    for (int i = 0; i < n; i++) {\n        if (i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main() {\n    int k;\n    cin >> n;\n\n    for (int i = 0; i < n; i++) {\n        cin >> k;\n        pre.push_back(k);\n    }\n\n    for (int i = 0; i < n; i++) {\n        cin >> k;\n        in.push_back(k);\n    }\n\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <numeric>\n#include <algorithm>\n#include <vector>\n#include <functional>\n\nusing namespace std;\n\nstruct Node {\n    int v, lnode, rnode;\n    Node(int v) : v(v), lnode(-1), rnode(-1){};\n};\n\nint main() {\n    int N;\n    cin >> N;\n\n    vector<int> preorder(N);\n    for (int i = 0; i < N; ++i) {\n        int v;\n        cin >> v;\n        preorder[--v] = i;\n    }\n    vector<int> inorder(N);\n    for (int i = 0; i < N; ++i) {\n        int v;\n        cin >> v;\n        inorder[--v] = i;\n    }\n\n    vector<int> id(N);\n    iota(id.begin(), id.end(), 0);\n    sort(id.begin(), id.end(), [&](int i, int j) { return preorder[i] < preorder[j]; });\n\n    vector<Node> tree({Node(id[0])});\n    for (int v : id) {\n        int cur = 0;\n        if (tree[cur].v == v) continue;\n        while (true) {\n            int& to = (inorder[v] < inorder[tree[cur].v] ? tree[cur].lnode : tree[cur].rnode);\n            if (to >= 0) {\n                cur = to;\n            } else {\n                to = tree.size();\n                tree.push_back(Node(v));\n                break;\n            }\n        }\n    }\n\n    vector<int> postorder;\n    function<void(int)> dfs = [&](int v) {\n        if (v < 0) return;\n        dfs(tree[v].lnode);\n        dfs(tree[v].rnode);\n        postorder.push_back(tree[v].v);\n    };\n    dfs(0);\n\n    for (int v : postorder) cout << v + 1 << \" \\n\"[v == postorder.back()];\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\n\nvoid rec(int l,int r){\n\tif(l>=r) return;\n\tint root = pre[pos++];\n\tint m=distance(in.begin(),find(in.begin(),in.end(),root));\n\trec(l,m);\n\trec(m+1,r);\n\tpost.push_back(root);\n}\n\nvoid solve(){\n\tpos=0;\n\trec(0,pre.size());\n\tfor(int i=0;i<n;i++){\n\t\tif(i) cout<<\" \";\n\t\tcout<<post[i];\n\t}\n\tcout<<endl;\n}\n\nint main() {\n\t\n\tint k;\n\tcin>>n;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tcin>>k;\n\t\tpre.push_back(k);\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tcin>>k;\n\t\tin.push_back(k);\n\t}\n\t\n\tsolve();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint n,pos;\nvector<int>pre,in,post;\n\nvoid rec(int l,int r){\n    if(l >= r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(),find(in.begin(),in.end(),root));\n    rec(l,m);\n    rec(m + 1,r);\n    post.push_back(root);\n}\n\nvoid solve(){\n    pos = 0;\n    rec(0,pre.size());\n    for(int i = 0;i < n;++i){\n        if(i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\n\nint main(){\n    int k;\n    cin >> n;\n    \n    for(int i = 0;i < n;++i){\n        cin >> k;\n        pre.push_back(k);\n    }\n    \n    for(int i = 0;i < n;++i){\n        cin >> k;\n        in.push_back(k);\n    }\n    \n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n  if ( l >= r ) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root))\n  rec(l, m);\n  rec(m + 1, r);\n  post.push_back(root);\n}\n\nvoid solve() {\n  pos = 0;\n  rec(0, pre.size());\n  for ( int i = 0; i < n; i++ ) {\n    if ( i ) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main() {\n  int k;\n  cin >> n;\n\n  for ( int i = 0; i < n; i++ ) {\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for ( int i = 0; i < n; i++ ) {\n    cin >> k;\n    in.push_back(k);\n  }\n\n  solve();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e6 + 100;\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n\nvoid rwFile() {\n    freopen(\"OB.inp\", \"r\", stdin);\n    freopen(\"OB.out\", \"w\", stdout);\n}\n\nint n, P[maxN], Q[maxN], d[maxN];\nvector<int> a[maxN], c;\nbool Kt[maxN];\n\nvoid DFS(int u){\n    if (a[u].size() >= 1) DFS(a[u][0]);\n    if (a[u].size() >= 2) DFS(a[u][1]);\n    c.push_back(u);\n}\n\nvoid solve() {\n    cin >> n;\n    for(int i = 0; i < n; i++){\n        cin >> P[i];\n\n    }\n    for(int i = 0; i < n; i++){\n        cin >> Q[i];\n        d[Q[i]] = i;\n    }\n    memset(Kt, true, sizeof(Kt));\n\n    for(int i = 0; i < n; i++){\n        int last = d[P[i - 1]];\n        int s = d[P[i]];\n        if (s < last) {\n            int k = s + 1;\n            while (k < n && Kt[Q[k]]) k++;\n            a[Q[k]].push_back(P[i]);\n           // cout << P[i] << \" \" << Q[k] << '\\n';\n        }\n        else{\n            int k = s - 1;\n            while (k >= 0 && Kt[Q[k]]) k--;\n            a[Q[k]].push_back(P[i]);\n           // cout << P[i] << \" \" << Q[k] << '\\n';\n        }\n        Kt[P[i]] = false;\n    }\n\n    DFS(P[0]);\n    cout << c[0];\n    for(int i = 1; i < c.size(); i++)\n        cout << \" \" << c[i];\n    cout << '\\n';\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr); cout.tie(nullptr);\n   // rwFile();\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint pre[50];\nint in[50];\nint pre_now=0;\nint n;\nvector<int>pos;\n\nint in_find(int terget){\n  int rec;\n  for(int i=0;i<n;i++){\n    if(in[i]==terget){\n      rec=i;\n      break;\n    }\n  }\n  return rec;\n}\n\nvoid fukugen(int l,int r){\n  if(l>=r)\n    return;\n\n  int root=pre[pre_now];pre_now++;\n  int point=in_find(root);\n\n  fukugen(l,point);\n  fukugen(point+1,r);\n  pos.push_back(root);\n\n}\n\nmain(){\n\n  cin >> n;\n  for(int i=0;i<n;i++)\n    cin >> pre[i];\n  for(int i=0;i<n;i++)\n    cin >> in[i];\n\n  fukugen(0,n);\n\n  for(int i=0;i<pos.size();i++){\n    if(i)\n      cout << \" \";\n    cout << pos[i];\n  }\n  cout << endl;\n\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <climits>\n#include <cstring>\n#define rep(i, begin, end) for (__typeof(end) i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))\n\nusing namespace std;\n\nconst int N_MAX = 1000000;\nstring ans = \"\";\n/*\n pre: 4 2 3 1 5\n in:  3 2 4 5 1\n\n*/\nstruct Node{\n  int data;\n  Node* left = NULL;\n  Node* right = NULL;\n};\n\nvoid postorder(Node* root){\n\n  if(root == NULL) return;\n  postorder(root->left);\n  postorder(root->right);\n\n  ans += (to_string(root->data) + \" \");\n}\n\n\nvoid print_array(int* arr, int len){\n  rep(i, 0, len){\n    cout << arr[i];\n    if(i==len-1) cout << endl;\n    else cout << \" \";\n  }\n}\n\nNode* solve(int* inorder, int* preorder, int len){\n\n\n  // find root\n  int root_data = preorder[0];\n  Node* root_node = new Node;\n  root_node->data = root_data;\n  if(len==1) return root_node;\n  \n  // count all the num left\n  int left_num=0;\n  while(inorder[left_num] != root_data) left_num++;\n  int right_num = len - left_num - 1;\n  \n  int* left_inorder = new int[left_num];\n  int* right_inorder = new int[right_num];\n  \n  int* left_preorder = new int[left_num];\n  int* right_preorder = new int[right_num];\n\n  int ix=0;\n  int l_ix=0, r_ix=0;\n\n  rep(ix, 0, len){\n    if(inorder[ix] == root_data) continue;\n    if(l_ix<left_num){\n      left_inorder[l_ix] = inorder[ix];\n      l_ix++;\n    }\n    else if(r_ix<right_num){\n      right_inorder[r_ix] = inorder[ix];\n      r_ix++;\n    }\n  }\n  \n  ix = 0; l_ix = 0; r_ix = 0;\n  \n  rep(ix, 1, len){\n    if(l_ix < left_num){\n      left_preorder[l_ix] = preorder[ix];\n      l_ix++;\n    }\n    else if(r_ix < right_num){\n      right_preorder[r_ix] = preorder[ix];\n      r_ix++;\n    }\n  }\n\n  if(left_num>0) root_node->left = solve(left_inorder, left_preorder, left_num);\n  if(right_num>0) root_node->right = solve(right_inorder, right_preorder, right_num);\n  \n  delete[] left_inorder;\n  delete[] right_inorder;\n  delete[] left_preorder;\n  delete[] right_preorder;\n  \n  return root_node;\n  \n}\n\nint main(){\n  int n; cin >> n;\n  int* inorder = new int[n];\n  int* preorder = new int[n];\n  \n  int tmp;\n  rep(i, 0, n){\n    cin >> tmp;\n    preorder[i] = tmp;\n  }\n  rep(i, 0, n){\n    cin >> tmp;\n    inorder[i] = tmp;\n  }\n\n  Node* root = NULL;\n  root = solve(inorder, preorder, n);\n  postorder(root);\n  rep(i, 0, 2*n-1) cout << ans[i]; \n  cout << endl;\n\n  delete[] inorder;\n  delete[] preorder;\n  delete root;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint n, pos;\nstd::vector<int> preorder, inorder, postorder;\n\nvoid rec(int left, int right) {\n    if (left >= right) return;\n    int root = preorder.at(pos++);\n    int criterion = std::distance(inorder.begin(), std::find(inorder.begin(), inorder.end(), root));\n    rec(left, criterion);\n    rec(criterion+1, right);\n    postorder.push_back(root);\n}\n\nvoid solve() {\n    pos = 0;\n    rec(0, preorder.size());\n    for (int i=0; i<n; i++) {\n        if (i) std::cout << \" \";\n        std::cout << postorder.at(i);\n    }\n    std::cout << \"\\n\";\n}\n\nint main() {\n    int k;\n    std::cin >> n;\n    for (int i=0; i<n; i++) {\n        std::cin >> k;\n        preorder.push_back(k);\n    }\n    for (int i=0; i<n; i++) {\n        std::cin >> k;\n        inorder.push_back(k);\n    }\n\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nvector<int> pre,in,post;\nint i = 0;\n\nvoid recon(int left,int right){\n    if (left >= right) return;\n    int parent = pre[i];\n    i++;\n    int mid = distance(in.begin(),find(in.begin,in,end(),parent));\n    \n    recon(left,mid);\n    recon(mid+1,right);\n    \n    post.push_back(parent);\n}\n\nvoid solve(){\n    recon();\n    int n = post.size();\n    cout << post[0];\n    for (int i = 1; i < n; i++) {\n        printf(\" %d\",post[i]);\n    }\n    cout << endl;\n}\n\nint main(){\n    int n;\n    for (int i = 0; i < n; i++) {\n        int a;\n        scanf(\"%d\",&a);\n        pre.push_back(a);\n    }\n    for (int i = 0; i < n; i++) {\n        int a;\n        scanf(\"%d\",&a);\n        in.push_back(a);\n    }\n    \n    solve();\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\nvector<int> pre, in, post;\nint pos;\nint n, k;\n\nvoid reconstruction(int left, int right) {\n\t// ????????°??¶??????\n\tif (left >= right)\n\t\treturn;\n\n\t// ??????????????????\n\tint root = pre[pos++];\n\t// ???????????????????????¨????????°???????????????\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\n\treconstruction(left, m);\n\treconstruction(m + 1, right);\n\n\t//?????\\??°????????°???\n\tpost.push_back(root);\n\n}\nvoid solve() {\n\tpos = 0;\n\treconstruction(0, pre.size());\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d%c\", post[i], i == n-1?'\\n':' ');\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &k);\n\t\tpre.push_back(k);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &k);\n\t\tin.push_back(k);\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nvoid rec(vector<int> &pre, vector<int> &in, int *posIndex, int l, int r)\n{\n    if (l >= r)\n    {\n        return;\n    }\n\n    int root = pre[*posIndex];\n    *posIndex = *posIndex + 1;\n\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n\n    rec(pre, in, posIndex, l, m);\n    rec(pre, in, posIndex, m+1, r);\n\n    cout << \" \" << root;\n   \n}\n\nint main()\n{\n    int N;\n    cin >> N;\n\n    vector<int> pre(N);\n    vector<int> in(N);\n\n    for (int i = 0; i < N; i++)\n    {\n        cin >> pre[i];\n    }\n\n    for (int i = 0; i < N; i++)\n    {\n        cin >> in[i];\n    }\n\n/*\n    for (int i = 0; i < N; i++)\n    {\n        cout << pre[i];\n    }\n*/\n    int *pos = new int;\n    *pos = 0;\n\n    rec(pre, in, pos, 0, pre.size());\n    //cout << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> c;\nvector<int> pre, in;\n\nvoid post(int id) {\n\tif (id == -1)\n\t\treturn;\n\tpost(c[id][0]);\n\tpost(c[id][1]);\n\tcout << id + 1;\n\tif (id == pre[0] - 1)\n\t\tcout << endl;\n\telse\n\t\tcout << \" \";\n}\n\nint main()\n{\n\tint n = 0, t = 0;\n\n\tcin >> n;\n\n\tc.assign(n, {-1, -1});\t\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> t;\n\t\tpre.push_back(t);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> t;\n\t\tin.push_back(t);\n\t}\n\n\tvector<int>::iterator it1, it2;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tit1 = find(in.begin(), in.end(), pre[i]);\n\t\tit2 = find(in.begin(), in.end(), pre[i + 1]);\n\n\t\tif (it1 > it2)\n\t\t\tc[pre[i] - 1][0] = pre[i + 1] - 1;\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tit1 = find(pre.begin(), pre.end(), in[i]);\n\t\tit2 = find(pre.begin(), pre.end(), in[i + 1]);\n\n\t\tif (it1 < it2)\n\t\t\tc[in[i] - 1][1] = in[i + 1] - 1;\n\t}\n\n\tpost(pre[0] - 1);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r)\n{\n\tif (l >= r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\nvoid solve()\n{\n\tpos = 0;\n\trec(0, pre.size());\n\tfor (int i; i < n; i++)\n\t{\n\t\tif (i) cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\n\nint main()\n{\n\tint k = 0;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <queue>\n#include <map>\n#include <list>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <climits>\nusing namespace std;\n \nstruct node {\n    int id, parent, left, right;\n};\n \nint reconstruct(queue<node> &nodes, queue<int> &pre, queue<int> &in, int parent){\n    if(!in.size()) return -1;\n     \n    node n;\n    n.parent = parent;\n    n.id = pre.front();\n    pre.pop();\n     \n    bool toA = true;\n    queue<int> inA, inB;\n    while(in.size()){\n        if(in.front() == n.id){\n            in.pop();\n            toA = false;\n            continue;\n        }\n        (toA ? inA : inB).push(in.front());\n        in.pop();\n    }\n     \n    n.left = reconstruct(nodes, pre, inA, n.id);\n    n.right = reconstruct(nodes, pre, inB, n.id);\n     \n    nodes.push(n);\n    return n.id;\n}\n \nint main() {\n    int n;\n    scanf(\"%d\", &n);\n     \n    queue<int> pre;\n    for(int i = 0; i < n; i++){\n        int num;\n        scanf(\"%d\", &num);\n        pre.push(num);\n    }\n     \n    queue<int> in;\n    for(int i = 0; i < n; i++){\n        int num;\n        scanf(\"%d\", &num);\n        in.push(num);\n    }\n     \n    queue<node> nodes;\n    reconstruct(nodes, pre, in, -1);\n     \n    while(nodes.size()){\n        printf(\"%d%c\", nodes.front().id, nodes.size() == 1 ? '\\n' : ' ');\n        nodes.pop();\n    }\n     \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint N, pos;\nvector<int> pre, in, post;\n\nvoid rec(int left, int right) {\n  if (left >= right) {\n    return;\n  }\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(left, m);\n  rec(left + 1, right);\n  post.push_back(root);\n}\n\nvoid solve() {\n  pos = 0;\n  rec(0, pre.size());\n  for (int i = 0; i < N; i++) {\n    if (i) {\n      cout << \" \";\n    }\n    cout << post[i]\n  }\n  cout << endl;\n}\n\nint main() {\n  int N;\n  cin >> N;\n\n  int k;\n  for (int i = 0; i < N; i++) {\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for (int i = 0; i < N; i++) {\n    cin >> k;\n    in.push_back(k);\n  }\n\n  solve();\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct Node {\n  int id;\n  Node* parent = nullptr;\n  Node* left = nullptr;\n  Node* right = nullptr;\n  int depth;\n  int height;\n\n  int calcHeight() {\n    int leftHeight = left ? left->calcHeight() : -1;\n    int rightHeight = right ? right->calcHeight() : -1;\n    height = max(leftHeight, rightHeight) + 1;\n    return height;\n  }\n\n  void calcDepth() {\n    depth = parent ? parent->depth + 1 : 0;\n    if (left) left->calcDepth();\n    if (right) right->calcDepth();\n  }\n\n  int degree() {\n    int d = 0;\n    if (left) ++d;\n    if (right) ++d;\n    return d;\n  }\n\n  Node* sibling() {\n    if (!parent) {\n      return nullptr;\n    }\n    if (parent->left == this) {\n      return parent->right;\n    } else {\n      return parent->left;\n    }\n  }\n\n  void walkPostorder() {\n    static bool isFirst = true;\n    if (left) left->walkPostorder();\n    if (right) right->walkPostorder();\n    if (isFirst) {\n      cout << (id + 1);\n      isFirst = false;\n    } else {\n      cout << \" \" << (id + 1);\n    }\n  }\n\n  static Node* reconstruct(\n    vector<Node>& nodes,\n    vector<int>::const_iterator preorderBegin, vector<int>::const_iterator preorderEnd,\n    vector<int>::const_iterator inorderBegin, vector<int>::const_iterator inorderEnd\n  ) {\n    if (inorderBegin == inorderEnd) {\n      return nullptr;\n    }\n    auto root = &nodes[*preorderBegin];\n    auto inorderMid = std::find_if(inorderBegin, inorderEnd, [&](int id){ return id == *preorderBegin; });\n    auto leftCount = inorderMid - inorderBegin;\n    auto left = reconstruct(nodes, preorderBegin + 1, preorderBegin + 1 + leftCount, inorderBegin, inorderMid);\n    auto right = reconstruct(nodes, preorderBegin + 1 + leftCount, preorderEnd, inorderMid + 1, inorderEnd);\n    root->left = left;\n    root->right = right;\n    return root;\n  }\n};\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int nodeCount;\n  cin >> nodeCount;\n  vector<Node> nodes(nodeCount);\n  for (int i = 0; i < nodeCount; ++i) {\n    nodes[i].id = i;\n  }\n\n  std::vector<int> preorderIDs, inorderIDs;\n\n  for (int i = 0; i < nodeCount; ++i) {\n    int id;\n    cin >> id;\n    preorderIDs.push_back(id - 1);\n  }\n\n  for (int i = 0; i < nodeCount; ++i) {\n    int id;\n    cin >> id;\n    inorderIDs.push_back(id - 1);\n  }\n\n  auto root = Node::reconstruct(nodes, preorderIDs.begin(), preorderIDs.end(), inorderIDs.begin(), inorderIDs.end());\n\n  root->walkPostorder();\n  cout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define NUL -1\nconst int N_MAX = 45;\nint root;\nstruct Node{\n    int parent, left, right;\n};\nNode tree[N_MAX];\nint pre[N_MAX], in[N_MAX];\n\nvoid reConstruct(int parent, int * preP, int * inP, int n, bool isLeft){\n    if(n==0) return;\n    int nowRoot = preP[0];\n    tree[nowRoot].parent = parent;\n    //getchar();\n    //cout<<\"-- nowRoot: \"<<nowRoot<<endl;\n    if(parent==NUL){\n        root=nowRoot;\n    }else if(isLeft){\n        tree[parent].left=nowRoot;\n    }else{\n        tree[parent].right=nowRoot;\n    }\n    if(n==1)return;\n    int flag = 0;\n    for(;flag<n;flag++){\n        if(inP[flag]==nowRoot) break;\n    }\n    //cout<<\"nowRoot: \"<<nowRoot<<\" flag: \"<<flag<<endl;\n    reConstruct(nowRoot, preP+1, inP, flag, true);\n    reConstruct(nowRoot, preP+1+flag, inP+1+flag, n-flag-1, false);\n}\n\nvoid post(int id){\n    if(id==NUL) return;\n    if(tree[id].left==NUL&&tree[id].right==NUL){\n        cout<<id<<\" \";\n        return;\n    }\n    post(tree[id].left);\n    post(tree[id].right);\n    if(id==root){\n        cout<<id<<endl;\n    }else{\n        cout<<id<<\" \";\n    }\n}\n\nint main(){\n    int n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>pre[i];\n        tree[i].parent=tree[i].left=tree[i].right=NUL;\n    }\n    tree[n].parent=tree[n].left=tree[n].right=NUL;\n    for(int i=0;i<n;i++){\n        cin>>in[i];\n    }\n    reConstruct(NUL, pre, in, n, true);\n    /*//Debugging/\n    for(int i=1;i<=n;i++){\n        cout<<\"node\"<<i<<\": p: \"<<tree[i].parent<<\"  l: \"<<tree[i].left<<\"  r: \"<<tree[i].right<<endl;\n    }\n    ///Debugging*/\n    post(root);\n\n    //cout<<\"root: \"<<root<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint prei = 0;\nvector<int> ans;\n\nvoid rec(int pre[], int in[], int l, int r, int n){\n    if(l >= r) return;\n    int c = pre[prei++];\n    int m = find(in, in + n, c) - in;\n    rec(pre, in, l, m, n);\n    rec(pre, in, m+1, r, n);\n    ans.push_back(c);\n    return;\n}\n\nint main(){\n    int n; cin >> n;\n    int pre[n], in[n];\n    rep(i, 0, n) cin >> pre[i];\n    rep(i, 0, n) cin >> in[i];\n\n    rec(pre, in, 0, n, n);\n    rep(i, 0, ans.size()) cout << ans[i] << ((i + 1 == n) ? '\\n' : ' ');\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace  std;\n\nconst int END = -1;\nstruct StNod\n{\n  int m_nParnt;\n  int m_nLeft;\n  int m_nRigt;\n\n  StNod() :\n     m_nParnt(END), m_nLeft(END), m_nRigt(END)\n  { }\n};\n\nenum EnDir\n{\n  D_Left,\n  D_Right,\n};\n\nvoid fnInput(vector<int> &rvnPodr, vector<int> &rvnIodrSeq)\n{\n  int nMaxSiz;\n\n  cin >> nMaxSiz;\n  rvnPodr.resize(nMaxSiz);\n  rvnIodrSeq.resize(nMaxSiz + 1);\n\n  for (int i = 0; i < nMaxSiz; i++)\n    cin >> rvnPodr[i];\n\n  int nNode;\n  for (int i = 1; i < nMaxSiz + 1; i++)\n  {\n    cin >> nNode;\n    rvnIodrSeq[nNode] = i;\n  }\n}\n\nvoid fnStructTree(const vector<int> &cnrvnPodr, const vector<int> &cnrvnIodrSeq, vector<StNod> &rvoNod)\n{\n  for (int i = 1; i < cnrvnPodr.size(); i++)\n  {\n    int nParnt = END;\n    int nx = cnrvnPodr[0];\n    EnDir enDir;\n    while (nx != END)\n    {\n      nParnt = nx;\n      if (cnrvnIodrSeq[ cnrvnPodr[i] ] < cnrvnIodrSeq[nx])\n      {\n        nx = rvoNod[nx].m_nLeft;\n        enDir = D_Left;\n      }\n      else\n      {\n        nx = rvoNod[nx].m_nRigt;\n        enDir = D_Right;\n      }\n    }\n\n    rvoNod[ cnrvnPodr[i] ].m_nParnt = nParnt;\n    if (enDir == D_Left)\n      rvoNod[nParnt].m_nLeft = cnrvnPodr[i];\n    else\n      rvoNod[nParnt].m_nRigt = cnrvnPodr[i];\n  }\n}\n\nvoid fnPostOrder(const vector<StNod> &cnrvoNod, int nx)\n{\n  static int stnPrt = 0;\n  if (nx == END)  return;\n\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nLeft);\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nRigt);\n\n  if (stnPrt++) cout << \" \";\n  cout << nx;\n}\n\nvoid fnResult(const vector<StNod> &cnrvoNod)\n{\n  int nx = 1;\n  while (cnrvoNod[nx].m_nParnt != END)\n    nx = cnrvoNod[nx].m_nParnt;\n\n  fnPostOrder(cnrvoNod, nx);\n  cout << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vector<int> vnPodr, vnIodrSeq;\n  fnInput(vnPodr, vnIodrSeq);\n\n  StNod oNod;\n  vector<StNod> voNod(vnIodrSeq.size(), oNod);\n  fnStructTree(vnPodr, vnIodrSeq, voNod);\n  \n  fnResult(voNod);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#define _USE_MATH_DEFINES\n#include <cmath>\n\n#define rep(i, n)     for (int (i) = 0; (i) < (n); (i)++)\n#define rep1(i, n)    for (int i = 1; i <= (int)(n); i++)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 25;\nconst int NIL  = -1;\n\nstruct Node {\n   int p, l, r;\n};\n\nNode T[MAXN];\nint  P[MAXN], I[MAXN], root;\nint  cnt = 0;\n\nvoid postorder(int u) {\n   if (T[u].l != NIL) postorder(T[u].l);\n   if (T[u].r != NIL) postorder(T[u].r);\n   if (cnt != 0) cout << \" \";\n   cout << u;\n   cnt++;\n}\n\nvoid makeT(int u, int n, int head, int tail) {\n   int p_place, i_place;\n\n   rep(i, n) {\n      if (P[i] == u)\n         p_place = i;\n      if (I[i] == u)\n         i_place = i;\n   }\n   if (head != i_place) {\n      T[u].l = P[p_place + 1];\n      T[P[p_place + 1]].p = u;\n      makeT(P[p_place + 1], n, head, i_place);\n   }\n   if (i_place + 1 != tail) {\n      T[u].r = P[p_place + 1 + i_place - head];\n      T[P[p_place + 1 + i_place - head]].p = u;\n      makeT(P[p_place + 1 + i_place - head], n, i_place + 1, tail);\n   }\n}\n\nint main() {\n   int n;\n\n   cin >> n;\n   rep1(i, n) T[i].p = T[i].r = T[i].l = NIL;\n   rep(i, n) cin >> P[i];\n   rep(i, n) cin >> I[i];\n   makeT(P[0], n, 0, n);\n\n   rep1(i, n) {\n      if (T[i].p == NIL) root = i;\n   }\n   postorder(root);\n   cout << endl;\n   return(0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <iterator>\n#include<algorithm>\nstatic const int NIL = -1;\nstatic const int NumberChild = 2;\nclass Tree {\nprivate:\n    int id;\n    int parent;\n    int child[NumberChild];\n \npublic:\n    Tree() {\n        id = child[0] = child[1] = parent = NIL;\n    }\n    void AddParent(int ID) {\n        parent = ID;\n        return;\n    }\n    void AddID(int ID) {\n        id = ID;\n        return;\n    }\n    void AddChild(std::vector<int>&Child) {\n        for (unsigned int i = 0; i < Child.size(); ++i) {\n            child[i] = Child[i];\n \n        }\n \n        return;\n    }\n    int GetRoot(std::vector<Tree> nodes, int ID) {\n        int RootID = ID;\n        if (RootID != NIL&&nodes[RootID].parent != NIL) {\n            RootID = GetRoot(nodes, nodes[RootID].parent);\n        }\n        return RootID;\n    }\n    void PreorderTreeWalk(std::vector<Tree> nodes, int ID) {\n        if (ID != NIL) {\n            std::cout << \" \" << nodes[ID].id;\n            PreorderTreeWalk(nodes, nodes[ID].child[0]);\n            PreorderTreeWalk(nodes, nodes[ID].child[1]);\n        }\n \n        return;\n    }\n    void InorderTreeWalk(std::vector<Tree> nodes, int ID) {\n        if (ID != NIL) {\n            InorderTreeWalk(nodes, nodes[ID].child[0]);\n            std::cout << \" \" << nodes[ID].id;\n            InorderTreeWalk(nodes, nodes[ID].child[1]);\n        }\n \n        return;\n    }\n    void PostorderTreeWalk(std::vector<Tree> nodes, int ID) {\n        if (ID != NIL) {\n \n            PostorderTreeWalk(nodes, nodes[ID].child[0]);\n            PostorderTreeWalk(nodes, nodes[ID].child[1]);\n            if (nodes[ID].id != NIL)std::cout << \" \" << nodes[ID].id;\n        }\n \n        return;\n    }\n    void GetVctorPostorderTreeWalk(std::vector<Tree> nodes, std::vector<int>& returnvector, int ID) {\n \n        if (ID != NIL) {\n \n            GetVctorPostorderTreeWalk(nodes, returnvector, nodes[ID].child[0]);\n            GetVctorPostorderTreeWalk(nodes, returnvector, nodes[ID].child[1]);\n            if (nodes[ID].id != NIL)returnvector.push_back(nodes[ID].id);\n        }\n \n        return;\n    }\n    void Reconstruct(std::vector<int>Pre, std::vector<int>In, std::vector<Tree> &nodes, const int Root, int &cnt) {\n \n        unsigned int m = std::distance(In.begin(), std::find(In.begin(), In.end(), Root));\n \n        //nodes[cnt].AddID(Root);\n        if (Root == NIL) { return; }\n        nodes[Root].AddID(Root);\n \n        if (m == 0) {\n            std::vector<int>RestPre;\n            RestPre.push_back(NIL);\n            if (m < Pre.size() - 1) {\n                RestPre.pop_back();\n                std::copy(&Pre[m] + 1, &Pre[Pre.size() - 1] + 1, std::back_inserter(RestPre));\n            }\n            std::vector<int> RestIn;\n            RestIn.push_back(NIL);\n            if (m < In.size() - 1) {\n                RestIn.pop_back();\n                std::copy(&In[m] + 1, &In[In.size() - 1] + 1, std::back_inserter(RestIn));\n            }\n            std::vector<int> child(2);\n            child[0] = NIL;\n            child[1] = RestPre.empty() ? NIL : RestPre[0];\n            nodes[Root].AddChild(child);\n            for (unsigned int i = 0; i < child.size(); ++i) {\n \n                if (child[i] != NIL) { nodes[child[i]].AddParent(Root); }\n            }\n            Reconstruct(RestPre, RestIn, nodes, RestPre[0], ++cnt);\n            return;\n        }\n        std::vector<int>PreLeft;\n        std::copy(&Pre[1], &Pre[m] + 1, std::back_inserter(PreLeft));\n        std::vector<int>InLeft;\n        std::vector<int>PreRight;\n        PreRight.push_back(NIL);\n        //PreRight={NIL};\n        std::vector<int> InRight;\n        InRight.push_back(NIL);\n        //InRight={NIL};\n        std::copy(&In[0], &In[m - 1] + 1, std::back_inserter(InLeft));\n \n        if (m < Pre.size() - 1) {\n            PreRight.pop_back();\n            std::copy(&Pre[m] + 1, &Pre[Pre.size() - 1] + 1, std::back_inserter(PreRight));\n        }\n        if (m < In.size() - 1) {\n            InRight.pop_back();\n            std::copy(&In[m] + 1, &In[In.size() - 1] + 1, std::back_inserter(InRight));\n        }\n \n \n \n \n        std::vector<int> child(2);\n        child[0] = PreLeft.empty() ? NIL : PreLeft[0];\n        child[1] = PreRight.empty() ? NIL : PreRight[0];\n        //nodes[cnt].AddChild(child);\n        nodes[Root].AddChild(child);\n        for (unsigned int i = 0; i < child.size(); ++i) {\n \n            if (child[i] != NIL) { nodes[child[i]].AddParent(Root); }\n        }\n        Reconstruct(PreLeft, InLeft, nodes, PreLeft[0], ++cnt);\n        Reconstruct(PreRight, InRight, nodes, PreRight[0], ++cnt);\n    }\n};\n \nvoid SetVector(std::vector<int>&InputVector) {\n    for (unsigned int i = 0; i < InputVector.size(); ++i) {\n        std::cin >> InputVector[i];\n    }\n    return;\n}\nint main(void) {\n \n    int n;\n    std::cin >> n;\n    std::vector<int>Pre(n);\n    std::vector<int>In(n);\n    SetVector(Pre);\n    SetVector(In);\n    std::vector<Tree> nodes(n + 1);\n    //ReconstructWithNoParent\n    int cnt = 0;\n    nodes[1].Reconstruct(Pre, In, nodes, Pre[0], cnt);\n \n    //nodes[1].PostorderTreeWalk(nodes, 1);\n    std::vector<int>Print;\n    nodes[1].GetVctorPostorderTreeWalk(nodes, Print, nodes[1].GetRoot(nodes, 1));\n    //Print=nodes[1].GetVctorPostorderTreeWalk(nodes, 1);\n    for (unsigned int i = 0; i < Print.size(); ++i) {\n        if (i) { std::cout << \" \"; }\n        std::cout << Print[i];\n        if (i == Print.size() - 1) { std::cout << std::endl; }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <cstdio>\nusing namespace std;\nstruct Node {\n    int left;\n    int right;\n};\n \nNode T[100];\nint PreOrder[100], InOrder[100];\nint NumOfNode;\n \n \n \nvoid printPost(int node) {\n    if (node == -1) {\n        ;\n    }\n    else {\n        printPost(T[node].left);\n        printPost(T[node].right);\n        if (NumOfNode-- != 1) {\n            printf(\"%d \", node);\n        }\n        else {\n            printf(\"%d\\n\", node);\n        }\n    }\n}\n \n \n \nvoid makeTree(int PreBegin, int PreEnd, int InBegin, int InEnd) {\n    int root = PreOrder[PreBegin];\n    int PreLeftSubtreeBegin, PreLeftSubtreeEnd, PreRightSubtreeBegin, PreRightSubtreeEnd, InLeftSubtreeBegin, InLeftSubtreeEnd, InRightSubtreeBegin, InRightSubtreeEnd;\n    for (int i = InBegin; i <= InEnd; ++i) {\n        if (InOrder[i] == root) {\n            PreLeftSubtreeBegin = PreBegin + 1;\n            PreLeftSubtreeEnd = PreBegin + i - InBegin;\n            PreRightSubtreeBegin = PreLeftSubtreeEnd + 1;\n            PreRightSubtreeEnd = PreEnd;\n            InLeftSubtreeBegin = InBegin;\n            InLeftSubtreeEnd = i - 1;\n            InRightSubtreeBegin = i + 1;\n            InRightSubtreeEnd = InEnd;\n            break;\n        }\n    }\n    if (PreLeftSubtreeBegin > PreLeftSubtreeEnd) {\n        //the left subtree is empty\n        T[root].left = -1;\n    }\n    else {\n        //the left subtree is not empty\n        T[root].left = PreOrder[PreLeftSubtreeBegin];\n        makeTree(PreLeftSubtreeBegin, PreLeftSubtreeEnd, InLeftSubtreeBegin, InLeftSubtreeEnd);\n    }\n \n    if (PreRightSubtreeBegin > PreRightSubtreeEnd) {\n        //the right subtree is empty\n        T[root].right = -1;\n    }\n    else {\n        //the right subtree is not empty\n        T[root].right = PreOrder[PreRightSubtreeBegin];\n        makeTree(PreRightSubtreeBegin, PreRightSubtreeEnd, InRightSubtreeBegin, InRightSubtreeEnd);\n    }\n}\n \nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    NumOfNode = n;\n \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &PreOrder[i]);\n    }\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &InOrder[i]);\n    }\n \n    makeTree(0, n - 1, 0, n - 1);\n    printPost(PreOrder[0]);\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define MAX 40\n\nusing namespace std;\n\nint idx=0;\nint n;\nint pre[MAX],in[MAX+1];\n\nint find(int x){\n  for(int i=0;i<n;i++){\n    if(x==in[i]) return i;\n  }\n  return -1;\n}\n\nvoid reconstruction(int l,int r){\n  if(l>=r) return;\n  int c=pre[idx++];\n  int m=find(c);\n  reconstruction(l,m);\n  reconstruction(m+1,r);\n  cout << c;\n}\n\nint main(){\n  cin >> n;\n  for(int i=0;i<n;i++) cin >> pre[i];\n  for(int i=0;i<n;i++) cin >> in[i];\n  in[n]=0;\n  reconstruction(0,n);\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nint n,a=0;\n\nstd::vector<int> pre,in,post;\n\nvoid rec(int left,int right){\n\tif(left>=right)\n\t\treturn;\n\tint root=pre[++a];\n\tint m=distance(in.begin(),find(in.begin(),in.end(),root));\n\trec(left,m);\n\trec(m+1,right);\n\tpost.push_back(n);\n}\n\nint main(){\n\tint k;\n\tstd::cin>>n;\n\tfor(int i=0;i<n;++i){\n\t\tstd::cin>>k;\n\t\tpre.push_back(k);\n\t}\n\tfor(int i=0;i<n;++i){\n\t\tstd::cin>>k;\n\t\tin.push_back(k);\n\t}\n\trec(0,n);\n\tfor(int i=0;i<n;++i)\n\t\tstd::cout<<post[i];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define max 41\nint n,in[max],pre[max],t[max];\nint j,k;\nvoid noderest(int l,int r){\n  if(l>=r)return;\n  int i =pre[j++];\n  //cout<<\"in:\"<<in[i]<<endl;\n  noderest(l,in[i]);\n  noderest(in[i]+1,r);\n  t[k++]=i;\n}\nint main(){\n  int i,root;\n  cin>>n;\n  for(i=0;i<n;i++)cin>>pre[i];\n  for(i=0;i<n;i++){\n    cin>>root;\n    in[root]=i;\n  }\n  root=in[i];\n  noderest(0,n);\n  for(i=0;i<k-1;i++){\n    cout<<t[i]<<\" \";\n  }\n  cout<<t[i]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nint n,a=0;\n\nstd::vector<int> pre,in,post;\n\nvoid rec(int left,int right){\n\tif(left>=right)\n\t\treturn;\n\tint root=pre[++a];\n\tint m=distance(in.begin(),find(in.begin(),in.end(),root));\n\trec(left,m);\n\trec(m+1,right);\n\tpost.push_back(n);\n}\n\nint main(){\n\tint k;\n\tstd::cin>>n;\n\tfor(int i=0;i<n;++i){\n\t\tstd::cin>>k;\n\t\tpre.push_back(k);\n\t}\n\tfor(int i=0;i<n;++i){\n\t\tstd::cin>>k;\n\t\tin.push_back(k);\n\t}\n\trec(0,n);\n\tfor(int i=0;i<n;++i)\n\t\tstd::cout<<post[i];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nvector<int> pre, in, post;\nint n, pos;\n\nint FindRoot(int key, int left, int right) {\n    for (int i = left; i < right; ++i) {\n        if (in[i] == key) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\nvoid ReBuild(int left, int right) {\n    if (left >= right) {\n        return;\n    }\n\n    int root = pre[pos++];\n    int index = FindRoot(root, left, right);\n    ReBuild(left, index);\n    ReBuild(index + 1, right);\n    post.push_back(root);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) {\n        int x;\n        cin >> x;\n        pre.push_back(x);\n    }\n\n    for (int i = 0; i < n; ++i) {\n        int x;\n        cin >> x;\n        in.push_back(x);\n    }\n\n    ReBuild(0, n);\n\n    for (int i = 0; i < post.size(); ++i) {\n        if (i > 0) {\n            cout << \" \";\n        }\n\n        cout << post[i];\n    }\n\n    cout << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> pre, in;\nint n;\n\nvoid solve(int l, int r) {\n\tif (r - l == 1) {\n\t\tcout << in[l] << \" \";\n\t}\n\telse {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = l; j < r; j++) {\n\t\t\t\tif (pre[i] == in[j]) {\n\t\t\t\t\tsolve(l, j);\n\t\t\t\t\tsolve(j + 1, r);\n\t\t\t\t\tcout << in[j] << \" \";\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tpre.resize(n);\n\tin.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> pre[i];\t\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> in[i];\n\t}\n\n\tsolve(0, n);\n\tcout << \"\\b\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nvector<int> pre,in,post;\nint n,pos;\n\nvoid solve(int l,int r){\n    if(l>=r)return;\n    int root=pre[pos++];\n    int m=distance(in.begin(),find(in.begin(),in.end(),root));\n    solve(l,m);\n    solve(m+1,r);\n    post.push_back(root);\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n;\n    for(int i=0;i<n;i++){\n        int k;\n        cin >> k;\n        pre.push_back(k);\n    }\n    for(int i=0;i<n;i++){\n        int k;\n        cin >> k;\n        in.push_back(k);\n    }\n    solve(0,pre.size());\n    for(int i=0;i<n;i++){\n        if(i)cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstatic vector<int> preorder(100), inorder(100);\n\nstatic void inputOrder(vector<int>& order, int num) {\n  for (int i = 0; i < num; i++) {\n    cin >> order[i];\n  }\n}\n\nstatic int current = 0, outIndex = 0;\n\nstatic int next() {\n  int c = preorder[current];\n  current++;\n  return c;\n}\n\nstatic int find(int c) {\n  auto it = find(inorder.begin(), inorder.end(), c); \n  return distance(inorder.begin(), it);\n}\n\nstatic void reconstruction(int l, int r) {\n  if (l >= r) {\n    return;\n  } \n  int c = next();\n  int m = find(c);\n  reconstruction(l, m);\n  reconstruction(m + 1, r);\n\n  if (outIndex != 0) {\n    cout << \" \" << c;\n  } else {\n    cout << c;\n  }\n  outIndex++;\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  inputOrder(preorder, n);\n  inputOrder(inorder, n);\n  reconstruction(0, n);\n\n  cout << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\n#define MAX 10000\n#define NIL -1\n\nstruct Node { int parent, left, right;};\n\nNode T[MAX];\nint n, D[MAX], H[MAX];\n\nvoid setDepth(int u,int d) {\n\tif(u == NIL) return;\n\tD[u] = d;\n\tsetDepth(T[u].left, d+1);\n\tsetDepth(T[u].right,d+1);\n}\n\nint setHeight(int u) {\n\tint h1 = 0, h2 = 0;\n\tif(T[u].left != NIL)\n\t\th1 = setHeight(T[u].left)  + 1;\n\tif(T[u].right != NIL)\n\t\th2 = setHeight(T[u].right) + 1;\n\treturn H[u] = (h1 > h2 ? h1 : h2);\n}\n\n// 接点 u の兄弟を返す\nint getSibling(int u) {\n\tif( T[u].parent == NIL ) return NIL;\n\tif(T[T[u].parent].left != u && T[T[u].parent].left != NIL )\n\t\treturn T[T[u].parent].left;\n\tif(T[T[u].parent].right != u && T[T[u].parent].right != NIL )\n\t\treturn T[T[u].parent].right;\n\treturn NIL;\n}\n\nvoid print(int u) {\n\tprintf(\"node %d: \",u);\n\tprintf(\"parent = %d, \",T[u].parent);\n\tprintf(\"sibling = %d, \",getSibling(u));\n\tint deg = 0;\n\tif(T[u].left  != NIL) deg++;\n\tif(T[u].right != NIL) deg++;\n\tprintf(\"degree = %d, \",deg);\n\tprintf(\"depth = %d, \",D[u]);\n\tprintf(\"height = %d, \",H[u]);\n\t\n\tif(T[u].parent == NIL) {\n\t\tprintf(\"root\\n\");\n\t} else if(T[u].left == NIL && T[u].right == NIL) {\n\t\tprintf(\"leaf\\n\");\n\t} else {\n\t\tprintf(\"internal node\\n\");\n\t}\n}\n\nint main(void) {\n\tint v, l, r, root = 0;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) T[i].parent = NIL;\n\tfor(int i=0;i<n;i++) {\n\t\tscanf(\"%d %d %d\",&v,&l,&r);\n\t\tT[v].left  = l;\n\t\tT[v].right = r;\n\t\tif(l != NIL) T[l].parent = v;\n\t\tif(r != NIL) T[r].parent = v;\n\t}\n\t\n\tfor(int i=0; i<n; i++)\n\tif(T[i].parent == NIL) root = i;\n\t\n\tsetDepth(root,0);\n\tsetHeight(root);\n\t\n\tfor(int i=0;i<n;i++) print(i);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n\nint p;\nstd::vector<int> pre, in, pos;\n\nvoid partRecon(int l, int r){\n\tif (l >= r) return;\n\tint root = pre[p++];\n\tint m = 0;\n\tfor (int i = 0; i < r - l; i++){\n\t\tif (in[l + i] == root) m = l + i;\n\t}\n\tpartRecon(l, m);\n\tpartRecon(m + 1, r);\n\tpos.push_back(root);\n}\n\nint main(){\n\tint n = 0;\n\tscanf(\"%d\", &n);\n\tint c = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &c);\n\t\tpre.push_back(c);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &c);\n\t\tin.push_back(c);\n\t}\n\tpartRecon(0, pre.size());\n\tfor(int i = 0; i < n; i++){\n\t\tprintf(\"%d\", pos[i]);\n\t\tif (i != n-1) printf(\" \");\n\t}\n\tprintf(\"\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//________\n#define pb push_back\n#define fi first\n#define se second\n#define mkp make_pair\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0; i<(n); ++i)\n#define reps(i,f,n) for(int i=(f); i<=(n); ++i)\n#define show(x) cerr << #x << ':' << (x) << endl\n#define outl(x) cout << (x) << '\\n'\n#define FAST() cin.tie(0), ios::sync_with_stdio(false)\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntemplate<class A, class B>inline bool chmax(A &a, B b){return b>a ? a=b,1 : 0;}\ntemplate<class A, class B>inline bool chmin(A &a, B b){return b<a ? a=b,1 : 0;}\ninline bool inside(int y, int x, int H, int W){return(y>=0 && x>=0 && y<H && x<W);}\ninline int updiv(int a, int b){return((a+b-1) / b);}\nconst int INF = 1 << 29;\nconst int dx[] = {1, 0, -1, 0,  1, 1, -1, -1};\nconst int dy[] = {0, 1, 0, -1,  -1, 1, 1, -1};\n#define Size 1000011\n#define NIL -1\n//________\n\nint N;\nint pre[42], in[42];\nint pos = 0;\nvector<int> post;\n\nint search(int a[], int n)\n{\n    int i = 0;\n    while(a[i] != n)++i;\n    return(i);\n}\nvoid reconst(int l, int r){\n    if(l >= r)return;\n\n    int root = pre[pos++];\n    int m = search(in, root);\n\n    reconst(l, m);\n    reconst(m+1, r);\n\n    post.pb(root);\n}\nvoid slv()\n{\n    pos = 0;\n    reconst(0, N);\n    cout << post[0];\n    for(int i=1; i<N; ++i)cout << ' ' << post[i];\n    outl(\"\");\n}\nsigned main()\n{\n    FAST();\n    cin >> N;\n    rep(i,N)cin >> pre[i];\n    rep(i,N)cin >> in[i];\n\n    slv();\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <limits>\n#include <string>\n#include <stack>\n#include <queue>\n\n#define INT_MAX 2147483647\n#define INT_MIN -2147483647\n\n#define NUM 10000\n#define INVALID_IDX -1\nusing namespace std;\n\nvector<int> pre, in, post;\nint pos = 0;\n\nvoid traverse(int l, int r)\n{\n\tif (l >= r) return;\n\n\tint rootVal = pre[pos++];\n\tint rootPos = distance(in.begin(), find(in.begin(), in.end(), rootVal));\n\n\ttraverse(l, rootPos);\n\ttraverse(rootPos+1, r);\n\n\tpost.push_back(rootVal);\n}\n\nvoid solve()\n{\n\tpos = 0;\n\ttraverse(0, pre.size());\n\n\tfor (int i = 0; i < post.size() - 1; ++i)\n\t{\n\t\tcout << post[i] << \" \";\n\t}\n\tif (!post.empty()) cout << post.back();\n        cout << endl;\n}\n\n\nint main()\n{\n\tint num;\n\tcin >> num;\n\tpre.resize(num);\n\tin.resize(num);\n\t\n\tfor (int i = 0; i < num; ++i) cin >> pre[i];\n\tfor (int i = 0; i < num; ++i) cin >> in[i];\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nvoid rec(vector<int> &pre, vector<int> &in, vector<int> &post, int *posIndex, int l, int r)\n{\n    if (l >= r)\n    {\n        return;\n    }\n\n    int root = pre[*posIndex];\n    *posIndex = *posIndex + 1;\n\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n\n    rec(pre, in, post, posIndex, l, m);\n    rec(pre, in, post, posIndex, m+1, r);\n\n    post.push_back(root);\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n\n    vector<int> pre(N);\n    vector<int> in(N);\n    vector<int> post(0);\n\n    for (int i = 0; i < N; i++)\n    {\n        cin >> pre[i];\n    }\n\n    for (int i = 0; i < N; i++)\n    {\n        cin >> in[i];\n    }\n\n/*\n    for (int i = 0; i < N; i++)\n    {\n        cout << pre[i];\n    }\n*/\n    int *pos = new int;\n    *pos = 0;\n\n    rec(pre, in, post, pos, 0, pre.size());\n\n    for (int i = 0; i < N; i++)\n    {\n        if (i != 0)\n        {\n            cout << \" \";\n        }\n\n        cout << post[i];\n    }\n    cout << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<siostream\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l, int r){\n  if(l>=r) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(),in.end(),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\n\nvoid solve(){\n  int i;\n  pos = 0;\n  rec(0,pre.size());\n  for(i=0;i<n;i++){\n    if(i) cout << \" \";\n    cout << post[i];;\n  }\n  cout << endl;\n}\n\nint main(){\n  int k;\n  cin >> n;\n\n  for(int i =0;i<n;i++){\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for(int i=0;i<n;i++){\n    cin >> k;\n    in.push_push(k);\n  }\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r){\n    if(l>=r)\n        return;\n    int root = pre[pos++];\n    int m = distance(in.begin(),find(in.begin(),in.end(),root));\n    rec(l,m);\n    rec(m+l,r);\n    post.push_back(root);\n}\n\nvoid solve(){\n    pos = 0;\n    rec(0,pre.size());\n    for(int i=0;i<n;i++){\n        if(i)\n            cout<<\" \";\n        cout<<post[i];\n    }\n    cout<<endl;\n}\n\nint main(){\n    int k;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>k;\n        pre.push_back(k);\n    }\n\n    for(int i=0;i<n;i++){\n        cin>>k;\n        in.push_back(k);\n    }\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <array>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <utility>\n#include <tuple>\n#include <algorithm>\n#include <limits>\n#include <fstream>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <list>\n#include <cstring>\n#include <unordered_set>\n#include <cmath>\n#include <iomanip>\n\nnamespace\n{\n\ttemplate<int N>\n\tstd::array<int, N> GetValue(std::istream& stream)\n\t{\n\t\tstd::string buf;\n\t\tstd::getline(stream, buf);\n\n\t\tstd::stringstream sstr(buf);\n\t\tstd::array<int, N> retval;\n\n\t\tfor (int i = 0; i < N; ++i)\n\t\t{\n\t\t\tstd::getline(sstr, buf, ' ');\n\t\t\tretval[i] = std::stoi(buf);\n\t\t}\n\n\t\treturn retval;\n\t}\n\n\tstd::vector<int> GetValue(std::istream& stream, int num, char delim)\n\t{\n\t\tstd::string buf;\n\t\tstd::getline(stream, buf);\n\t\tstd::stringstream sstr(buf);\n\n\t\tstd::vector<int> retval;\n\t\tretval.reserve(num);\n\n\t\tstd::string input;;\n\t\tfor (int i = 0; i < num && std::getline(sstr, input, delim); ++i)\n\t\t{\n\t\t\tretval.push_back(std::stoi(input));\n\t\t}\n\n\t\treturn retval;\n\t}\n\n\tint GetValue(std::istream& stream)\n\t{\n\t\tint in;\n\t\tstream >> in;\n\n\t\treturn in;\n\t}\n\n\tstd::vector<std::string> GetValueString(std::istream& stream, int num, char delim)\n\t{\n\t\tstd::string buf;\n\t\tstd::vector<std::string> retval;\n\t\tretval.reserve(num);\n\n\t\tstd::getline(stream, buf);\n\t\tstd::stringstream sstr(buf);\n\n\t\tfor (int i = 0; i < num && std::getline(sstr, buf, delim); ++i)\n\t\t{\n\t\t\tretval.push_back(std::move(buf));\n\t\t}\n\n\t\treturn retval;\n\t}\n\n\ttemplate<typename Itr>\n\tvoid PrintLine(Itr begin, Itr end)\n\t{\n\t\tbool first = true;\n\n\t\tfor (int i = 0; begin != end; ++begin, ++i)\n\t\t{\n\t\t\tif (!first)\n\t\t\t{\n\t\t\t\tstd::cout << ' ';\n\t\t\t}\n\n\t\t\tstd::cout << (*begin);\n\n\t\t\tfirst = false;\n\t\t}\n\t\tstd::cout << std::endl;\n\t}\n\n\ttemplate<typename T>\n\tvoid Print(const std::vector<T>& sequence)\n\t{\n\t\tfor (const auto& e : sequence)\n\t\t{\n\t\t\tstd::cout << e << '\\n';\n\t\t}\n\n\t\tstd::cout << std::flush;\n\t}\n\n\tconst int kNil = -1;\n\n\tstruct Node\n\t{\n\t\tint parent;\n\t\tint left;\n\t\tint right;\n\n\t\tNode()\n\t\t\t: parent(kNil)\n\t\t\t, left(kNil)\n\t\t\t, right(kNil)\n\t\t{}\n\t};\n\n\tNode node[25];\n\n\tstd::vector<int> pre;\n\tstd::vector<int> in;\n\tstd::vector<int> post;\n\n\tvoid Construction(int left, int right)\n\t{\n\t\tif (right <= left)\n\t\t\treturn;\n\n\t\tstatic int pos = 0;\n\n\t\tint root = pre[pos];\n\t\t++pos;\n\n\t\tint middle = std::distance(in.begin(), find(in.begin(), in.end(), root));\n\n\t\tConstruction(left, middle);\n\t\tConstruction(middle + 1, right);\n\n\t\tpost.push_back(root);\n\t}\n}\n\nint main(int argc, char* argv[])\n{\n\tauto file = (argc == 1) ? std::ifstream() : std::ifstream(argv[1]);\n\tstd::istream& stream = (argc == 1) ? std::cin : file;\n\tif (argc == 1)\n\t{\n\t\tstd::cin.tie(0);\n\t\tstd::ios::sync_with_stdio(false);\n\t}\n\n\tint num = GetValue<1>(stream)[0];\n\tpre = GetValue(stream, num, ' ');\n\tin = GetValue(stream, num, ' ');\n\n\tConstruction(0, pre.size());\n\n\tbool first = true;\n\tfor (int e : post)\n\t{\n\t\tif (!first)\n\t\t{\n\t\t\tstd::cout << ' ';\n\t\t}\n\n\t\tfirst = false;\n\t\t\n\t\tstd::cout << e;\n\t}\n\n\tstd::cout << std::endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n#define _CRT_SECURE_NO_WARNINGS\n#include <cstdio>\n \nusing namespace std;\n \nstruct Node {\n    int left;\n    int right;\n};\n \nNode T[100];\nint PreOrder[100], InOrder[100];\nint NumOfNode;\n \n \n \nvoid printPost(int node) {\n    if (node == -1) {\n        ;\n    }\n    else {\n        printPost(T[node].left);\n        printPost(T[node].right);\n        if (NumOfNode-- != 1) {\n            printf(\"%d \", node);\n        }\n        else {\n            printf(\"%d\\n\", node);\n        }\n    }\n}\n \n \n \nvoid makeTree(int PreBegin, int PreEnd, int InBegin, int InEnd) {\n    int root = PreOrder[PreBegin];\n    int PreLeftSubtreeBegin, PreLeftSubtreeEnd, PreRightSubtreeBegin, PreRightSubtreeEnd, InLeftSubtreeBegin, InLeftSubtreeEnd, InRightSubtreeBegin, InRightSubtreeEnd;\n    for (int i = InBegin; i <= InEnd; ++i) {\n        if (InOrder[i] == root) {\n            PreLeftSubtreeBegin = PreBegin + 1;\n            PreLeftSubtreeEnd = PreBegin + i - InBegin;\n            PreRightSubtreeBegin = PreLeftSubtreeEnd + 1;\n            PreRightSubtreeEnd = PreEnd;\n            InLeftSubtreeBegin = InBegin;\n            InLeftSubtreeEnd = i - 1;\n            InRightSubtreeBegin = i + 1;\n            InRightSubtreeEnd = InEnd;\n            break;\n        }\n    }\n    if (PreLeftSubtreeBegin > PreLeftSubtreeEnd) {\n        //the left subtree is empty\n        T[root].left = -1;\n    }\n    else {\n        //the left subtree is not empty\n        T[root].left = PreOrder[PreLeftSubtreeBegin];\n        makeTree(PreLeftSubtreeBegin, PreLeftSubtreeEnd, InLeftSubtreeBegin, InLeftSubtreeEnd);\n    }\n \n    if (PreRightSubtreeBegin > PreRightSubtreeEnd) {\n        //the right subtree is empty\n        T[root].right = -1;\n    }\n    else {\n        //the right subtree is not empty\n        T[root].right = PreOrder[PreRightSubtreeBegin];\n        makeTree(PreRightSubtreeBegin, PreRightSubtreeEnd, InRightSubtreeBegin, InRightSubtreeEnd);\n    }\n}\n \nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    NumOfNode = n;\n \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &PreOrder[i]);\n    }\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &InOrder[i]);\n    }\n \n    makeTree(0, n - 1, 0, n - 1);\n    printPost(PreOrder[0]);\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<stdlib.h>\n\nvoid to_post(int* A, int* B, int* C, int h)\n{\n    int x = A[0];\n    C[h - 1] = x;\n    if(h < 2) return;\n    int m = 0;\n    while(B[m] != x) m++; \n    if(m > 0) to_post(A + 1, B, C, m);\n    if(h - m - 1 > 0) to_post(A + m + 1, B + m + 1, C + m, h - m - 1);\n}\n\nint main()\n{\n    int *A, *B, *C;\n    int i, n; cin >> n;\n\n    A = new int [n]; B = new int [n]; C = new int [n];\n    if(A == NULL || B == NULL || C == NULL) exit(EXIT_FAILURE);\n\n    for(i = 0; i < n; i++){ cin >> A[i]; C[i] = 0; }\n    for(i = 0; i < n; i++){ cin >> B[i]; }\n\n    to_post(A, B, C, n);\n\n    cout << C[0]; for(i = 1; i < n; i++){ cout << \" \" << C[i]; } cout << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// -*- mode:c++; coding:utf-8; c-basic-offset:2; -*-\n// ALDS1_7_D: Reconstruction of a Tree\n\n#include <cstdio>\n\nusing uint = unsigned int;\nusing uintp = uint*;\n\nstatic void solve(const uintp i_begin, const uintp i_end,\n                  uintp p_begin, const uintp indices[],\n                  const char* sep = \"\\n\")\n{\n  if (i_begin >= i_end) {\n    return;\n  }\n  const auto i_index = indices[*p_begin++];\n  const auto len = i_index-i_begin;\n  solve(i_begin, i_index, p_begin, indices, \" \");\n  solve(i_index+1, i_end, p_begin+len, indices, \" \");\n  std::printf(\"%u%s\", *i_index, sep);\n}\n\nint main()\n{\n  uint n;\n  std::scanf(\"%u\", &n);\n  uint preorders[n];\n  uint inorders[n];\n  uintp indices[n+1]; // 0 not used.\n  uint k;\n  for (auto i = 0u; i < n; ++i) {\n    std::scanf(\"%u\", &k);\n    preorders[i] = k;\n  }\n  for (auto i = 0u; i < n; ++i) {\n    std::scanf(\"%u\", &k);\n    inorders[i] = k;\n    indices[k] = &(inorders[i]);\n  }\n\n  solve(inorders, inorders+n, preorders, indices);\n}\n\n// eof"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_7_C\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<string.h>\n#include<math.h>\n#include<stdlib.h>\n#include<vector>\n#include<queue>\n#include<map>\n#include<iomanip>\n#include<set>\n#define rep(index,num) for(int index=0;index<num;index++)\n#define rep1(index,num) for(int index=1;index<=num;index++)\n#define scan(argument) cin>>argument\n#define prin(argument) cout<<argument<<endl\n#define kaigyo cout<<endl\n#define eps 1e-7\n#define mp(a1,a2) make_pair(a1,a2)\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef vector<pint> vpint;\ntypedef vector<pll> vpll;\nll INFl=1e+18+1;\nint INF=1e+9+1;\nstruct Node{\n\tint p,l,r;//親、左の子、右の子\n};\nNode T[100001];\nint N,pos;\nvint pre,in,post;\nvoid rec(int l,int r){\n\tif(l>=r) return ;\n\tint root=pre[pos];\n\tpos++;\n\tint m;\n\trep(i,in.size()){\n\t\tif(in[i]==root){\n\t\t\tm=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\trec(l,m);\n\trec(m+1,r);\n\tpost.push_back(root);\n}\nvoid solve(){\n\tpos=0;\n\trec(0,pre.size());\n\trep(i,N){\n\t\tprintf(\"%d\",post[i]);\n\t\tif(i!=N-1) printf(\" \");\n\t}\n\tkaigyo;\n}\nint main(){\n\tscan(N);\n\trep(i,N){\n\t\tint k;\n\t\tscan(k);\n\t\tpre.push_back(k);\n\t}\n\trep(i,N){\n\t\tint k;\n\t\tscan(k);\n\t\tin.push_back(k);\n\t}\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nvoid print_vector(vector<int>& vec){\n    for(auto x : vec){\n        cout << x << \" \";\n    }\n    cout << endl;\n}\n\nvoid postorder(vector<int>& pre, vector<int>& in, vector<int>& ret){\n    if(in.size() <= 1){\n        for(auto it = in.begin(); it != in.end(); ++it){\n            ret.push_back(*it);\n        }\n        return;\n    }\n    //print_vector(pre);\n    //print_vector(in);\n    //cout << endl;\n    int root = pre[0];\n    int ln = find(in.begin(), in.end(), root) - in.begin();\n\n    vector<int> pre_left {};\n    pre_left.insert(pre_left.begin(), pre.begin()+1, pre.begin()+ln+1);\n    vector<int>in_left {};\n    in_left.insert(in_left.begin(), in.begin(), in.begin()+ln);\n\n    vector<int> pre_right {};\n    pre_right.insert(pre_right.begin(), pre.begin()+ln+1, pre.end());\n    vector<int> in_right {};\n    in_right.insert(in_right.begin(), in.begin()+ln+1, in.end());\n\n    vector<int> pre_mid {root};\n    vector<int> in_mid {root};\n\n    postorder(pre_left, in_left, ret);\n    postorder(pre_right, in_right, ret);\n    postorder(pre_mid, in_mid, ret);\n}\nint main(){\n    int n;\n    cin >> n;\n    vector<int> pre {};\n    vector<int> in {};\n    for(int i = 0; i < n; ++i){\n        int temp;\n        cin >> temp;\n        pre.push_back(temp);\n    }\n    for(int i = 0; i < n; ++i){\n        int temp;\n        cin >> temp;\n        in.push_back(temp);\n    }\n    vector<int> post {};\n    postorder(pre, in, post);\n    for(auto it = post.begin(); it != post.end(); ++it){\n        if(it == post.begin()){\n            cout << *it;\n        } else {\n            cout << \" \" << *it;\n        }\n    }\n    cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> pre,in,post;\n\nint pos;\n\nvoid dfs(int l,int r)\n{\n    if(l>=r)\n    {\n        return;\n    }\n\n    int root=pre[pos++];\n\n    int idx=find(in.begin(),in.end(),root)-in.begin();\n\n    dfs(l,idx);\n    dfs(idx+1,r);\n    post.push_back(root);\n}\n\nint main()\n{\n\n    int n;\n\n    while(cin>>n)\n    {\n        pre.clear();in.clear();post.clear();\n\n        int a;\n        for(int i=0;i<n;i++)\n        {\n            cin>>a;\n            pre.push_back(a);\n        }\n\n        for(int i=0;i<n;i++)\n        {\n            cin>>a;\n            in.push_back(a);\n        }\n\n        pos=0;\n        dfs(0,n);\n\n        for(int i=0;i<n;i++)\n        {\n            if(i)\n            {\n                cout<<\" \";\n            }\n\n            cout<<post[i];\n        }\n        cout<<endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> preorder, inorder;\nbool f = false;\nvoid recover(int fp, int lp, int fi, int li){\n        int root;\n        for(int i = fi; i < li; i++){\n                if(preorder[fp] == inorder[i]){\n                        root = i;\n                        break;\n                }\n        }\n        if(fi < root) recover(fp + 1, fp + root - fi + 1, fi, root);//左側を表示\n        if(root < li - 1) recover(fp + root - fi + 1, lp, root + 1, li);//右側を表示\n        if(f == true) cout << ' ';\n        cout << inorder[root];\n        f = 1;\n}\n\nint main(){\n        int n, tmp;\n        cin >> n;\n        for(int i = 0; i < n; i++){\n                cin >> tmp;\n                preorder.push_back(tmp);\n        }\n        for(int i = 0; i < n; i++){\n                cin >> tmp;\n                inorder.push_back(tmp);\n        }\n        recover(0, preorder.size(), 0, inorder.size());\n        cout << endl;\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint pre[50],in[50],post[50];\nint n,pos,idx;\nvoid dfs(int l,int r){\n  if(l>=r) return;\n  int root=pre[pos++];\n  int m=-1;\n  for(int i=l;i<r;i++)\n    if(in[i]==root) m=i;\n  dfs(l,m);\n  dfs(m+1,r);\n  post[idx++]=root;\n}\nsigned main(){\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>pre[i];\n  for(int i=0;i<n;i++) cin>>in[i];\n  pos=idx=0;\n  dfs(0,n);\n  for(int i=0;i<n;i++)\n    cout<<post[i]<<\" \\n\"[i==n-1];\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nvoid rec(vi &pre, vi &in, vi &post, int l, int r, int &pos) {\n  if (l >= r) return;\n\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(pre, in, post, l, m, pos);\n  rec(pre, in, post, m + 1, r, pos);\n  post.push_back(root);\n}\n\nint main() {\n  int n, pos = 0;\n  cin >> n;\n\n  vi pre(n), in(n), post;\n  rep(i, n) cin >> pre[i];\n  rep(i, n) cin >> in[i];\n  \n  rec(pre, in, post, 0, n, pos);\n\n  rep(i, n) printf(i != n - 1 ? \"%d \" : \"%d\\n\", post[i]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint pos = 0;\nvector<int> pre, in, post;\n\nvoid reconstruction(int left, int right)\n{\n    if (left >= right)\n        return;\n    int root = pre[pos++];\n    int mid = distance(in.begin(), find(in.begin(), in.end(), root));\n    reconstruction(left, mid);\n    reconstruction(mid+1, right);\n    post.push_back(root);\n}\n\nint main()\n{\n    int n, v;\n    cin >> n;\n\n    for (int i = 0; i != n; ++i)\n    {\n        cin >> v;\n        pre.push_back(v);\n    }\n\n    for (int i = 0; i != n; ++i)\n    {\n        cin >> v;\n        in.push_back(v);\n    }\n\n    reconstruction(0, n);\n\n    for (vector<int>::iterator it = post.begin(); it != post.end(); ++it)\n    {\n        if (it != post.begin()) cout << \" \";\n        cout << *it;\n    }\n\n    cout << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,pos;\nvector<int>pre,in,post;\n\nvoid rec(int l,int r){\n  if(l>=r) return;\n  int root=pre[pos++];\n  int m=distance(in.begin(),find(in.begin(),in.end(),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\n\nvoid slove(){\n  pos=0;\n  rec(0,pre.size());\n  for(int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<post[i];\n  }\n  cout<<endl;\n}\nint main(){\n  int k;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>k;\n    pre.push_back(k);\n  }\n  for(int i=0;i<n;i++){\n    cin>>k;\n    in.push_back(k);\n  }\n  slove();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nqueue<int> Q;\n\nvoid solve(vector<int> P, vector<int> I)\n{\n  int n = P.size();\n  if (n != I.size())\n  {\n    cout << \"Size Error!\" << endl;\n  }\n  // ベースケース\n  if (n == 1)\n  {\n    Q.push(P.at(0));\n    return;\n  }\n  // 再帰ステップ\n  int pivot_value = P.at(0);\n  int index;\n  for (int i = 0; i < n; i++)\n  {\n    if (I.at(i) == pivot_value)\n    {\n      index = i;\n      break;\n    }\n  }\n  vector<int> LI, RI, LP, RP;\n  bool flagL = false, flagR = false;\n  for (int i = 0; i < index; i++)\n  {\n    LI.push_back(I.at(i));\n    LP.push_back(P.at(i + 1));\n    flagL = true;\n  }\n  for (int i = index + 1; i < n; i++)\n  {\n    RI.push_back(I.at(i));\n    RP.push_back(P.at(i));\n    flagR = true;\n  }\n  if (flagL)\n  {\n    solve(LP, LI);\n  }\n  if (flagR)\n  {\n    solve(RP, RI);\n  }\n  Q.push(pivot_value);\n  return;\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  vector<int> P(n), I(n);\n  for (int i = 0; i < n; i++)\n  {\n    cin >> P.at(i);\n  }\n  for (int i = 0; i < n; i++)\n  {\n    cin >> I.at(i);\n  }\n\n  solve(P, I);\n\n  for (int i = 0; i < n; i++)\n  {\n    cout << Q.front();\n    Q.pop();\n    if (i == n - 1)\n    {\n      cout << endl;\n    }\n    else\n    {\n      cout << \" \";\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint search(int arr[], int x, int n) {\n    for (int i = 0; i < n; i++)\n        if (arr[i] == x) return i;\n    return -1;\n}\nvoid printPostOrder(int in[], int pre[], int n) {\n    int root = search(in, pre[0], n);\n    if (root != 0) printPostOrder(in, pre+1, root);\n    if (root != n-1) printPostOrder(in+root+1, pre+root+1, n-root-1);\n    cout << pre[0] << \" \";\n}\n\nint main() {\n    int num;\n    cin >> num;\n    int arr[num];\n    int arr2[num];\n    for (int i = 0; i < num; i++) cin >> arr[i];\n    for (int i = 0; i < num; i++) cin >> arr2[i];\n    printPostOrder(arr2, arr, num);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> pre, in;\nint n;\n\nvoid solve(int l, int r) {\n\tif (r - l == 1) {\n\t\tcout << in[l] << \" \";\n\t}\n\telse {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = l; j < r; j++) {\n\t\t\t\tif (pre[i] == in[j]) {\n\t\t\t\t\tsolve(l, j);\n\t\t\t\t\tsolve(j + 1, r);\n\t\t\t\t\tcout << in[j];\n\t\t\t\t\tif (in[j] != pre[0]) {\n\t\t\t\t\t\tcout << \" \";\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tpre.resize(n);\n\tin.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> pre[i];\t\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> in[i];\n\t}\n\n\tsolve(0, n);\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nvector<int> pre,in,post;\nint n,pos;\n\nvoid solve(int l,int r){\n    if(l>=r)return;\n    int root=pre[pos++];\n    int m=distance(in.begin(),find(in.begin(),in.end(),root));\n    solve(l,m);\n    solve(m+1,r);\n    post.push_back(root);\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n;\n    for(int i=0;i<n;i++){\n        int k;\n        cin >> k;\n        pre.push_back(k);\n    }\n    for(int i=0;i<n;i++){\n        int k;\n        cin >> k;\n        in.push_back(k);\n    }\n    solve(0,pre.size());\n    for(int i=0;i<n;i++){\n        if(i)cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <tuple>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\n\nstruct node{\n    int id;\n    vector<int> left, right;\n};\n\nnode n[40];\nint v;\nvector<int> res;\n\nvoid post_order(vector<int> root, vector<int> target, int start){\n    int i = 0;\n    while(target[i] != root[start]){\n        n[start].left.push_back(target[i]);\n        i++;\n    }\n    if(n[start].left.size() != 0)\n        post_order(root, n[start].left, start + 1);\n    i++;\n    while(i < target.size()){\n        n[start].right.push_back(target[i]);\n        i++;\n    }\n    if(n[start].right.size() != 0)\n        post_order(root, n[start].right, start + n[start].left.size() + 1);\n    res.push_back(root[start]);\n}\n\nint main() {\n    cin >> v;\n    vector<int> pre(v);\n    vector<int> in(v);\n    int x;\n    REP(i, v){\n        cin >> x;\n        pre[i] = x;\n    }\n    REP(i, v){\n        cin >> x;\n        in[i] = x;\n    }\n    post_order(pre, in, 0);\n\n    REP(i, v){\n        if(i != 0)\n            cout << \" \";\n        cout << res[i];\n    }\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint N, pos;\nvector<int> pre, in, post;\n\nvoid rec(int left, int right) {\n  if (left >= right) {\n    return;\n  }\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(left, m);\n  rec(left + 1, right);\n  post.push_back(root);\n}\n\nvoid solve() {\n  pos = 0;\n  rec(0, pre.size());\n  for (int i = 0; i < N; i++) {\n    if (i) {\n      cout << \" \";\n    }\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main() {\n  int N;\n  cin >> N;\n\n  int k;\n  for (int i = 0; i < N; i++) {\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for (int i = 0; i < N; i++) {\n    cin >> k;\n    in.push_back(k);\n  }\n\n  solve();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> pre, in, hint;\n\nvoid postorder(vector<int>& res, int pl, int pr, int il, int ir) {\n    if(pl==pr) return;\n    int root = pre[pl];\n    int im = hint[root];\n    int ll = im - il;\n    postorder(res, pl+1, pl+1+ll, il, im);\n    postorder(res, pl+1+ll, pr, im+1, ir);\n    res.push_back(root);\n}\n\n\nint main() {\n    int n;\n    cin >> n;\n    pre.resize(n);\n    in.resize(n);\n    hint.resize(n+1);\n    for(int i=0; i<n; i++) {\n        cin >> pre[i];\n    }\n    for(int i=0; i<n; i++) {\n        cin >> in[i];\n        hint[in[i]] = i;\n    }\n    vector<int> post;\n    postorder(post, 0, n, 0, n);\n    for(int i=0; i<n; i++) {\n        cout << post[i] << (i==n-1 ? \"\\n\" : \" \");\n    }\n    \n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <list>\n\nconst int MAX_N = 41;\nconst int SINGLE_NODE = 1;\nconst int NONE = -1;\n\nstruct Node {\n  int parent;\n  int left;\n  int right;\n  bool visited;\n};\n\nint reconstruct(std::list<int> *preorderNodes,\n\t\t std::list<int> *inorderNodes,\n\t\t int parent,\n\t\t struct Node *nodes[]) {\n  if (inorderNodes->size() == SINGLE_NODE) {\n    int v = inorderNodes->front();\n    inorderNodes->pop_front();\n\n    nodes[v]->parent = parent;\n\n    preorderNodes->pop_front();\n\n    return v;\n  }\n\n  int v = preorderNodes->front();\n  preorderNodes->pop_front();\n\n  std::list<int> *leftNodes = new std::list<int>();\n  std::list<int> *rightNodes = new std::list<int>();\n\n  while (!inorderNodes->empty()) {\n    int k = inorderNodes->front();\n    inorderNodes->pop_front();\n\n    if (k == v) {\n      break;\n    } else {\n      leftNodes->push_back(k);\n    }\n  }\n\n  while (!inorderNodes->empty()) {\n    int k = inorderNodes->front();\n    inorderNodes->pop_front();\n\n    //    if (k == v) {\n    //      break;\n    //    } else {\n      rightNodes->push_back(k);\n      //    }\n  }\n\n  //  std::cout << v << std::endl;\n  \n  if (!leftNodes->empty()) {\n    // std::cout << \"Left: \";\n\n    // for (std::list<int>::iterator i = leftNodes->begin(); i != leftNodes->end(); ++i) {\n    //   std::cout << (*i) << \" \";\n    // }\n\n    // std::cout << std::endl;\n    \n      nodes[v]->left = reconstruct(preorderNodes, leftNodes, v, nodes);\n  }\n\n  if (!rightNodes->empty()) {\n    // std::cout << \"Right: \";\n\n    // for (std::list<int>::iterator i = rightNodes->begin(); i != rightNodes->end(); ++i) {\n    //   std::cout << (*i) << \" \";\n    // }    \n\n    // std::cout << std::endl;\n    \n    nodes[v]->right = reconstruct(preorderNodes, rightNodes, v, nodes);\n  }\n\n  nodes[v]->parent = parent;\n\n  return v;\n}\n\nvoid printByPostorder(struct Node *nodes[], int n, int rootID) {\n  std::list<int> list;\n\n  list.push_front(rootID);\n\n  bool first = true;\n  \n  while (!list.empty()) {\n    int id = list.front();\n    list.pop_front();\n    \n    if (id < 0) {\n      continue;\n    }\n    \n    struct Node *node = nodes[id];\n\n    if (!node->visited) {\n      node->visited = true;\n      \n      list.push_front(id);      \n      list.push_front(node->right);\n      list.push_front(node->left);\n    } else {\n      if (first) {\n\tstd::cout << id;\n\t\n\tfirst = false;\n      } else {\n\tstd::cout << \" \" << id;\n      }\n    }\n  }\n\n  std::cout << std::endl;      \n}\n\nint main(void) {\n  int n;\n\n  std::cin >> n;\n\n  struct Node *nodes[MAX_N];\n\n  for (int i = 0; i <= n; i++) {\n    struct Node *node = (struct Node *) std::malloc(sizeof(struct Node));\n    \n    node->parent = NONE;\n    node->left = NONE;\n    node->right = NONE;\n    node->visited = false;\n\n    nodes[i] = node;\n  }\n\n  std::list<int> *preorderNodes = new std::list<int>();\n  std::list<int> *inorderNodes = new std::list<int>();\n\n  for (int i = 0; i < n; i++) {\n    int v = 0;\n\n    std::cin >> v;\n\n    preorderNodes->push_back(v);\n  }\n\n  for (int i = 0; i < n; i++) {\n    int v = 0;\n\n    std::cin >> v;\n\n    inorderNodes->push_back(v);\n  }  \n  \n  int rootID = preorderNodes->front();\n\n  reconstruct(preorderNodes, inorderNodes, -1, nodes);\n  \n  printByPostorder(nodes, n, rootID);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nint n;\nint P[42];\nint Pi[42];\nint K[42];\nint Ki[42];\n\n\nstruct N {\n\tint id,l, r;\n\tvoid setid(int pi);\n\tvoid pre();\n\tvoid in();\n\tvoid post();\n};\n\nint root;\nN T[25];\n\n/*\n5\n1 2 3 4 5\n3 2 4 1 5\n\n         1\n   2        5\n 3   4\n \n 4 \n 1 2 3 4 \n 4 3 2 1\n        1\n     2\n   3\n 4\n*/\n\n// I think this is a O(n) algorizm\n\nvoid N::setid(int _id)\n{\n//\tcout <<id<<endl;\n\tid = _id; // 4\n\tint pid=Pi[id]; // 4\n\tint kid=Ki[id]; // 1\n\tint idl=P[pid+1]; // 2\n\tint kidl=Ki[idl]; // 3\n\tif (kid>kidl) {\n\t\tl=idl;\n\t\tT[l].setid(l);\n\t}\n\tint idr=K[kid+1];\n\tint pidr=Pi[idr];\n\tif(pidr>pid){\n\t\tr=idr;\n\t\tT[r].setid(r);\n\t}\n//\tcout<<id<<' '<<l<<' '<<r<<endl;\n}\n\n\nint main()\n{\n\tmemset(T, 0, sizeof(T));\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>P[i];\n\tP[0]=P[n+1]=0;\n\tfor(int i=1;i<=n;i++) Pi[P[i]]=i;\n\tPi[0]=Pi[n+1]=-1;\n\tfor(int i=1;i<=n;i++) cin>>K[i];\n\tK[0]=K[n+1]=0;\n\tfor(int i=1;i<=n;i++) Ki[K[i]]=i;\n\tKi[0]=Ki[n+1]=INT_MAX;\n\troot = P[1];\n\t\n\tT[root].setid(root);\n\t/*\n\tcout<<\"Preorder\"<<endl;\n\tT[root].pre();\n\tcout<<endl;\n\t\n\tcout<<\"Inorder\"<<endl;\n\tT[root].in();\n\tcout<<endl;\n\t*/\n//\tcout<<\"Postorder\"<<endl;\n\tT[root].post();\n\tcout<<endl;\n}\n\n\t\nvoid N::pre()\n{\n\tcout<<' '<<id;\n\tif(l)T[l].pre();\n\tif(r)T[r].pre();\n}\n\nvoid N::in()\n{\n\tif(l)T[l].in();\n\tcout<<' '<<id;\n\tif(r)T[r].in();\n}\nbool first = false;\nvoid N::post()\n{\n\tif(l)T[l].post();\n\tif(r)T[r].post();\n\tif (first) cout<<' '; else first = true;\n\tcout<<id;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\nusing namespace std;\n#define NIL -1\n\nstruct Node {int left=NIL, right=NIL; bool visited=false;};\n\nint findPos(int n, int in[], int target) {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (in[i] == target) return i;\n\t}\n\treturn -1;\n}\n\nvoid reconstructTree(int n, Node T[], int pre[], int in[]) {\n\tint root = pre[0];\n\tfor (int i = 1; i < n; i++) {\n\t\tint target = pre[i];\n\t\tint targetPos = findPos(n, in, target);\n\t\tstack<int> st;\n\t\tst.push(root);\n\t\twhile (st.size() != 0) {\n\t\t\tint cur = st.top(); st.pop();\n\t\t\tint curPos = findPos(n, in, cur);\n\t\t\tif (targetPos < curPos) {\n\t\t\t\tif (T[cur].left == NIL) T[cur].left = target;\n\t\t\t\telse st.push(T[cur].left);\n\t\t\t} else {\n\t\t\t\tif (T[cur].right == NIL) T[cur].right = target;\n\t\t\t\telse st.push(T[cur].right);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid preOrder(Node T[], int root) {\n\tstack<int> st;\n\tst.push(root);\n\twhile (st.size() != 0) {\n\t\tint cur = T[st.top()].left;\n\t\twhile (cur != NIL && !T[cur].visited) {\n\t\t\tst.push(cur);\n\t\t\tcur = T[cur].left;\n\t\t}\n\t\tint right = T[st.top()].right;\n\t\tif (right != NIL && !T[right].visited) {\n\t\t\tst.push(right);\n\t\t} else {\n\t\t\tcur = st.top(); st.pop();\n\t\t\tcout << cur;\n\t\t\tif (st.size() != 0) cout << \" \";\n\t\t\tT[cur].visited = true;\n\t\t}\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tint pre[n], in[n];\n\tfor (int i = 0; i < n; i++) cin >> pre[i];\n\tfor (int i = 0; i < n; i++) cin >> in[i];\n\tNode T[n+1];\n\treconstructTree(n, T, pre, in);\n\tpreOrder(T, pre[0]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<stdlib.h>\n#include<vector>\nusing namespace std;\n\nint pind=0;\nvector<int> s;\n\nint find(int u, int *H){\n    int i=0;\n    while(H[i]!=u){\n        i++;\n    }\n    return i;\n}\n\nvoid reconstruction(int l, int r, int *Pr, int *In){\n    if(l>=r) return;\n    int ind = find(Pr[pind], In);\n    int k=pind;\n    pind++;\n    reconstruction(l, ind, Pr, In); \n    reconstruction(ind+1, r, Pr, In);\n    //printf(\" %d\", Pr[k]);\n    s.push_back(Pr[k]);\n}\n\n\n\nint main(){\n    int n, i, k, j;\n    int *Pr, *In;\n    scanf(\"%d\", &n);\n    Pr = (int*)malloc(sizeof(int)*n);\n    In = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        scanf(\"%d\", &Pr[i]);\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\", &In[i]);\n    }\n\n    reconstruction(0, n, Pr, In);\n    for(j=0;j<n;j++){\n        if(j==n-1) printf(\"%d\\n\", s[j]);\n        else printf(\"%d \", s[j]);\n    }\n\n    free(Pr);\n    free(In);\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace  std;\n\nconst int END = -1;\nstruct StNod\n{\n  int m_nParnt;\n  int m_nLeft;\n  int m_nRigt;\n\n  StNod() :\n     m_nParnt(END), m_nLeft(END), m_nRigt(END)\n  { }\n};\n\nenum EnDir\n{\n  D_Left,\n  D_Right,\n};\n\nvoid fnInput(vector<int> &rvnPodr, vector<int> &rvnIodrSeq)\n{\n  int nMaxSiz;\n\n  cin >> nMaxSiz;\n  rvnPodr.resize(nMaxSiz + 1);\n  rvnIodrSeq.resize(nMaxSiz + 1);\n\n  for (int i = 1; i < nMaxSiz + 1; i++)\n  {\n    int nNode;\n    cin >> nNode;\n    rvnPodr[i] = nNode;\n  }\n\n  for (int i = 1; i < nMaxSiz + 1; i++)\n  {\n    int nNode;\n    cin >> nNode;\n    rvnIodrSeq[nNode] = i;\n  }\n}\n\nvoid fnStructTree(const vector<int> &cnrvnPodr, const vector<int> &cnrvnIodrSeq, vector<StNod> &rvoNod)\n{\n  int nRoot = cnrvnPodr[1];\n\n  for (int i = 2; i < cnrvnPodr.size(); i++)\n  {\n    int nParnt = END;\n    int nx = nRoot;\n    EnDir enDir;\n    while (nx != END)\n    {\n      nParnt = nx;\n      if (cnrvnIodrSeq[ cnrvnPodr[i] ] < cnrvnIodrSeq[nx])\n      {\n        nx = rvoNod[nx].m_nLeft;\n        enDir = D_Left;\n      }\n      else\n      {\n        nx = rvoNod[nx].m_nRigt;\n        enDir = D_Right;\n      }\n    }\n\n    rvoNod[ cnrvnPodr[i] ].m_nParnt = nParnt;\n    if (enDir == D_Left)\n      rvoNod[nParnt].m_nLeft = cnrvnPodr[i];\n    else\n      rvoNod[nParnt].m_nRigt = cnrvnPodr[i];\n  }\n}\n\nvoid fnPostOrder(const vector<StNod> &cnrvoNod, int nx, int &nOCnt)\n{\n  if (nx == END)  return;\n\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nLeft, nOCnt);\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nRigt, nOCnt);\n  if (nOCnt++) cout << \" \";\n  cout << nx;\n}\n\nvoid fnResult(const vector<StNod> &cnrvoNod, int &nOCnt)\n{\n  int nx = 1;\n  while (cnrvoNod[nx].m_nParnt != END)\n    nx = cnrvoNod[nx].m_nParnt;\n\n  fnPostOrder(cnrvoNod, nx, nOCnt);\n  cout << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vector<int> vnPodr, vnIodrSeq;\n  vector<StNod> voNod;\n\n  fnInput(vnPodr, vnIodrSeq);\n\n  StNod oNod;\n  voNod.resize(vnPodr.size(), oNod);\n  fnStructTree(vnPodr, vnIodrSeq, voNod);\n\n  int nOCnt = 0;\n  fnResult(voNod, nOCnt);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define MAX 50\nusing namespace std;\n\nint n, pre[MAX], in[MAX], post[MAX];\nint pre_index = 0, post_index = 0, in_index[MAX];\n\nvoid Reconstruction(int left, int right)\n{\n\tif (left >= right) return;\n\t\n\tint root = pre[pre_index++];\n\tReconstruction(left, in_index[root]);\n\tReconstruction(in_index[root]+1, right);\n\t\n\tpost[post_index++] = root;\n}\n\nint main ()\n{\n\t\n\tcin >> n;\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tcin >> pre[i];\n\t}\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tcin >> in[i];\n\t\tin_index[in[i]] = i;\n\t}\n\t\n\tReconstruction(0, n);\n\t\n\tcout << post[0];\n\tfor (int i = 1;i < n;i++)\n\t{\n\t\tcout << \" \" << post[i];\n\t}\n    cout << endl;\n\treturn 0;\n } \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n/*\nalias g='g++ -std=c++17 -O2 pra.cpp'\nalias a='./a.out'\ncd programming\ncd cpp\ncd practice\n\n*/\n/*\nclock_t start = clock();\n処理\ncout<<\"cpu時間: \"<<(double)(end-start)/CLOCKS_PER_SEC<<\"秒\"<< endl;\nclock_t end = clock();\n*/\n#define rep(i, n) for(int i=0; i<(n); i++)\n//if (i) cout << \" \"; で最初のみ空白文字を出力することができる\n#define Sort(v) sort((v).begin(), (v).end())\n#define pb push_back\nusing veci = vector<int>;\nveci pre, in, ans;\nint pos=0;\nvoid reconstruction(int l, int r, int n){\n    if (r <= l) return;\n    int root = pre[pos];\n    pos++;\n    int d=distance(in.begin(), find(in.begin(), in.end(), root));//inの中からrootと同じ値を見つけて、そのイテレータを返す\n    reconstruction(l, d, n);//まず左側から分割していく\n    reconstruction(d+1, r, n);\n    ans.pb(root);//根までいくのは分割した部分が全てリターンされたとき\n}\nint main(){\n    int n; cin >> n;\n    int m;\n    rep(i, n){\n        cin >> m;\n        pre.pb(m);\n    }\n    rep(i, n){\n        cin >> m;\n        in.pb(m);\n    }\n    reconstruction(0, n, n);\n    rep(i, n){\n        if (i) cout << \" \";\n        cout << ans[i];\n    }\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nclass Node\n{\npublic:\n    Node() {\n        this->_id = 0;\n        this->_left = 0;\n        this->_right = 0;\n        this->_parent = 0;\n    }\n\n    Node(int id) {\n        this->_id = id;\n        this->_left = 0;\n        this->_right = 0;\n        this->_parent = 0;\n    }\n\n    ~Node() {\n        ;\n    }\n\n    // Accessor\n    const int& id() const {\n        return this->_id;\n    }\n\n    int& id() {\n        return this->_id;\n    }\n\n    const int& left() const {\n        return this->_left;\n    }\n\n    int& left() {\n        return this->_left;\n    }\n\n    const int& right() const {\n        return this->_right;\n    }\n\n    int& right() {\n        return this->_right;\n    }\n\n    const int& parent() const {\n        return this->_parent;\n    }\n\n    int& parent() {\n        return this->_parent;\n    }\n\nprivate:\n    int _id;\n    int _left;\n    int _right;\n    int _parent;\n};\n\nstd::vector<Node> nodelist;\n\nvoid postorder(int id)\n{\n    int l = nodelist[id].left();\n    int r = nodelist[id].right();\n    if (l != 0)\n        postorder(l);\n    if (r != 0)\n        postorder(r);\n    cout << id << \" \";\n\n    return;\n}\n\nvoid maketree(std::vector<int>& pre, std::vector<int>& in)\n{\n    // cout << endl;\n\n    int root = pre[0];\n\n    std::vector<int> leftin;\n    std::vector<int> rightin;\n\n    // find root index in inorder\n    auto rootitr = std::find(in.begin(), in.end(), root);\n\n    // copy left and right subtrees\n    std::copy(in.begin(), rootitr, std::back_inserter(leftin));\n    std::copy(rootitr + 1, in.end(), std::back_inserter(rightin));\n\n    // Debug print\n    // cout << \"pre-order : \";\n    // for (int i = 0; i < pre.size(); i++) {\n    //     cout << pre[i] << \" \";\n    // }\n    // cout << endl;\n    // cout << \"in-order : \";\n    // for (int i = 0; i < in.size(); i++) {\n    //     cout << in[i] << \" \";\n    // }\n    // cout << endl;\n    // cout << \"root = \" << root << endl;\n    // cout << \"left subtree : \";\n    // for (int i = 0; i < leftin.size(); i++) {\n    //     cout << leftin[i] << \" \";\n    // }\n    // cout << endl;\n    // cout << \"right subtree : \";\n    // for (int i = 0; i < rightin.size(); i++) {\n    //     cout << rightin[i] << \" \";\n    // }\n    // cout << endl;\n\n    // construct pre-order from two subtrees\n    // pre-order of left subtree\n    std::vector<int> leftpre;\n    if (leftin.size() > 0) {\n        int limin = *std::min_element(leftin.begin(), leftin.end());\n        int limax = *std::max_element(leftin.begin(), leftin.end());\n        std::copy(std::find(pre.begin(), pre.end(), limin),\n                  std::find(pre.begin(), pre.end(), limax) + 1,\n                  std::back_inserter(leftpre));\n    }\n\n    // pre-order of right subtree\n    std::vector<int> rightpre;\n    if (rightin.size() > 0) {\n        int rimin = *std::min_element(rightin.begin(), rightin.end());\n        int rimax = *std::max_element(rightin.begin(), rightin.end());\n        std::copy(std::find(pre.begin(), pre.end(), rimin),\n                  std::find(pre.begin(), pre.end(), rimax) + 1,\n                  std::back_inserter(rightpre));\n    }\n\n    // Debug print\n    // cout << \"pre-order of left subtree : \";\n    // for (int i = 0; i < leftpre.size(); i++) {\n    //     cout << leftpre[i] << \" \";\n    // }\n    // cout << endl;\n    // cout << \"pre-order of right subtree : \";\n    // for (int i = 0; i < rightpre.size(); i++) {\n    //     cout << rightpre[i] << \" \";\n    // }\n    // cout << endl;\n\n    // set children\n    if (leftpre.size() > 0) {\n        // cout << \"Left child of \" << root << \" = \" << leftpre[0] << endl;\n        nodelist[root].left() = leftpre[0];\n    }\n    if (rightpre.size() > 0) {\n        // cout << \"Right child of \" << root << \" = \" << rightpre[0] << endl;\n        nodelist[root].right() = rightpre[0];\n    }\n\n    if (leftpre.size() > 1)\n        maketree(leftpre, leftin);\n    if (rightpre.size() > 1)\n        maketree(rightpre, rightin);\n\n    // cout << endl;\n}\n\nint main(int argc, char const *argv[])\n{\n    int n;\n    cin >> n;\n\n    // initialize nodelist\n    nodelist.resize(n + 1);\n\n    std::vector<int> pre(n);\n    std::vector<int> in(n);\n    // input\n    for (int i = 0; i < n; i++) {\n        cin >> pre[i];\n        // set node id\n        nodelist[i + 1].id() = i + 1;\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> in[i];\n    }\n\n    // construct tree\n    maketree(pre, in);\n\n    // Debug print\n    // cout << endl;\n    // for (int i = 1; i <= n; i++) {\n    //     cout << \"id: \" << nodelist[i].id() << \", left: \" << nodelist[i].left() << \", right: \" << nodelist[i].right() << endl;\n    // }\n\n    // print post-order (argument is id of root)\n    postorder(pre[0]);\n    cout << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define MAX_N (42)\nint n;\nint Pre[MAX_N];\nint In[MAX_N];\nint Post[MAX_N];\n\nint pre_i;\nint count;\nvoid dfs(int l, int r);\n\nint findIn(int l, int r, int v);\n\n\nint main()\n{\n    scanf(\"%d\", &n);\n\n    for ( int i = 0; i < n; i++ ) {\n\tscanf(\"%d\", &Pre[i]);\n    }\n\n    for ( int i = 0; i < n; i++ ) {\n\tscanf(\"%d\", &In[i]);\n    }\n\n    pre_i = 0;\n    count = 0;\n\n    dfs( 0, n );\n\n    return 0;\n}\n\n\nvoid dfs(int l, int r)\n{\n    if ( l < r ) {\n\tint cur = Pre[pre_i++];\n\tint m = findIn( l, r, cur );\n\tdfs( l, m );\t\t// ?????¨?????¨\n\tdfs( m + 1, r );\t// ?????¨?????¨\n\tprintf(\"%d%c\", cur, (count == n-1) ? '\\n' : ' ');\n\tcount++;\n    }\n}\n\n\nint findIn(int l, int r, int v)\n{\n    for ( int i = l; i < r; i++ ) {\n\tif ( In[i] == v ) return i;\n    }\n\n    return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in_, post;\n\nvoid rec(int l, int r) {\n    if (l>=r) return;\n    int root = pre[pos++];\n    int m = distance(in_.begin(), find(in_.begin(), in_.end(), root));\n    rec(1, m);\n    rec(m+1, r);\n    post.push_back(root);\n}\n\nvoid solve() {\n    pos = 0;\n    rec(0, pre.size());\n    for (int i=0; i<n; i++) {\n        if(i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main() {\n    int k;\n    cin >> n;\n    \n    for (int i=0; i<n; i++) {\n        cin >> k;\n        pre.push_back(k);\n    }\n    \n    for (int i=0; i<n; i++) {\n        cin >> k;\n        in_.push_back(k);\n    }\n    \n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <list>\n\nconst int MAX_N = 25;\nconst int SINGLE_NODE = 1;\nconst int NONE = -1;\n\nstruct Node {\n  int parent;\n  int left;\n  int right;\n  bool visited;\n};\n\nint reconstruct(std::list<int> *preorderNodes,\n\t\t std::list<int> *inorderNodes,\n\t\t int parent,\n\t\t struct Node *nodes[]) {\n  if (preorderNodes->empty()) {\n    return NONE;\n  }\n  \n  if (inorderNodes->size() == SINGLE_NODE) {\n    int v = inorderNodes->front();\n    inorderNodes->pop_front();\n\n    nodes[v]->parent = parent;\n\n    return v;\n  }\n\n  int v = preorderNodes->front();\n  preorderNodes->pop_front();\n\n  std::list<int> *leftNodes = new std::list<int>();\n  std::list<int> *rightNodes = new std::list<int>();\n\n  while (!inorderNodes->empty()) {\n    int k = inorderNodes->front();\n    inorderNodes->pop_front();\n\n    if (k == v) {\n      break;\n    } else {\n      leftNodes->push_back(k);\n    }\n  }\n\n  while (!inorderNodes->empty()) {\n    int k = inorderNodes->front();\n    inorderNodes->pop_front();\n\n    if (k == v) {\n      break;\n    } else {\n      rightNodes->push_back(k);\n    }\n  }\n\n  if (!leftNodes->empty()) {\n    nodes[v]->left = reconstruct(preorderNodes, leftNodes, v, nodes);\n  }\n\n  if (!rightNodes->empty()) {\n    nodes[v]->right = reconstruct(preorderNodes, rightNodes, v, nodes);\n  }\n\n  return v;\n}\n\nvoid printByPostorder(struct Node *nodes[], int n, int rootID) {\n  std::list<int> list;\n\n  list.push_front(rootID);\n\n  bool first = true;\n  \n  while (!list.empty()) {\n    int id = list.front();\n    list.pop_front();\n    \n    if (id < 0) {\n      continue;\n    }\n    \n    struct Node *node = nodes[id];\n\n    if (!node->visited) {\n      node->visited = true;\n      \n      list.push_front(id);      \n      list.push_front(node->right);\n      list.push_front(node->left);\n    } else {\n      if (first) {\n\tstd::cout << id;\n\t\n\tfirst = false;\n      } else {\n\tstd::cout << \" \" << id;\n      }\n    }\n  }\n\n  std::cout << std::endl;      \n}\n\nint main(void) {\n  int n;\n\n  std::cin >> n;\n\n  struct Node *nodes[MAX_N];\n\n  for (int i = 0; i <= n; i++) {\n    struct Node *node = (struct Node *) std::malloc(sizeof(struct Node));\n    \n    node->parent = NONE;\n    node->left = NONE;\n    node->right = NONE;\n    node->visited = false;\n\n    nodes[i] = node;\n  }\n\n  std::list<int> *preorderNodes = new std::list<int>();\n  std::list<int> *inorderNodes = new std::list<int>();\n\n  for (int i = 0; i < n; i++) {\n    int v = 0;\n\n    std::cin >> v;\n\n    preorderNodes->push_back(v);\n  }\n\n  for (int i = 0; i < n; i++) {\n    int v = 0;\n\n    std::cin >> v;\n\n    inorderNodes->push_back(v);\n  }  \n  \n  int rootID = preorderNodes->front();\n\n  reconstruct(preorderNodes, inorderNodes, rootID, nodes);\n  \n  printByPostorder(nodes, n, rootID);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, s, n) for (int i = s; i < n; i++)\n#define rp(i,n) for (int i=0;i<n;i++)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define all_acc(x) (x).begin(), (x).end(), 0LL\n#define int long long\n#define absSort(v) sort(a.begin(), a.end(), [](int i, int j) -> bool { return abs(i) < abs(j); });\nusing namespace std;\nusing P = pair<int, int>;\nusing Graph = vector<vector<int>>;\nusing ll = long long;\ndouble pi=3.14159265359;\n\n//出力するよ\nvoid output_tate(vector<int> s){\n    int n = s.size();\n    for (int i = 0; i < n; i++){\n        //if (i != 0)\n        //    cout << \" \";\n        cout << s[i]<<endl;\n    }\n    //cout << endl;\n}\n\nvoid output_yoko(vector<int> s){\n    int n = s.size();\n    for (int i = 0; i < n; i++){\n        if (i != 0)\n            cout << \" \";\n        cout << s[i];//<<endl;\n    }\n    cout << endl;\n}\n\nint MOD = pow(10, 9) + 7;\n\nint kaijou(int n){\n    if(n==0) return 1;\n    else{\n        return ((n%MOD)*(kaijou(n-1)%MOD))%MOD;\n    }\n}\n\nbool ispow(int n){\n    int rn=sqrt(n);\n    if(rn*rn==n) return true;\n    else return false;\n}\n\nint n,pos;\nvector<int> preorder(n),inorder(n);\nvector<int> post;\n\nvoid rec(int l,int r){\n    if(l>=r) return;\n    int root =preorder[pos++];\n    int m=distance(inorder.begin(),find(all(inorder),root));\n    rec(l,m);\n    rec(m+1,r);\n    post.push_back(root);\n}\n\nvoid solve(){\n    pos=0;\n    rec(0,preorder.size());\n    output_yoko(post);\n}\n\nsigned main() {\n    cin>>n;\n    preorder.assign(n,0);\n    inorder.assign(n,0);\n    \n    rp(i,n) cin>>preorder[i];\n    rp(i,n) cin>>inorder[i];\n\n    solve();\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n \nusing namespace std;\n\nvoid reconstruct_tree\n(vector<pair<int, int> >& nodes, \n const int s, const int t, const int r,\n const vector<int>& preo,  const vector<int>& inv_preo,\n const vector<int>& ino,   const vector<int>& inv_ino)\n{\n  // r is in ino[s,t)\n  int left_subtree_size  = inv_ino[r] - s;\n  int right_subtree_size = t - inv_ino[r] -1;\n  if(left_subtree_size > 0){\n    nodes[r].first = preo[inv_preo[r]+1];\n    reconstruct_tree(nodes, s, inv_ino[r], nodes[r].first,\n\t\t     preo, inv_preo, ino, inv_ino);\n  }\n  else{\n    nodes[r].first = -1;\n  }\n\n  if(right_subtree_size > 0){\n    nodes[r].second = preo[inv_preo[r]+left_subtree_size+1];\n    reconstruct_tree(nodes, inv_ino[r]+1, t, nodes[r].second,\n\t\t     preo, inv_preo, ino, inv_ino);\n  }\n  else{\n    nodes[r].second = -1;\n  }\n}\n \nvoid print_preorder(const vector<pair<int, int> >& nodes, const int r){\n  //cout << '?' << endl;\n  if(r<0) return;\n  //cout << '?' << endl;\n  cout << ' ' << r;\n  print_preorder(nodes, nodes[r].first);\n  print_preorder(nodes, nodes[r].second);\n}\n \nvoid print_inorder(const vector<pair<int, int> >& nodes, const int r){\n  if(r<0) return;\n  print_inorder(nodes, nodes[r].first);\n  cout << ' ' << r;\n  print_inorder(nodes, nodes[r].second);\n}\n   \n \nvoid print_postorder(const vector<pair<int, int> >& nodes, const int r, int geta = 0){\n  if(r<0) return;  \n  print_postorder(nodes, nodes[r].first, geta);\n  print_postorder(nodes, nodes[r].second, geta);\n  cout << ' ' << (r+geta);\n}\n \nint main(){\n  std::ios_base::sync_with_stdio(false);\n \n  int n;\n  cin >> n;\n  vector<pair<int, int> > nodes(n);\n  vector<int> preo(n); //0 .. n-1\n  vector<int> inv_preo(n);\n  vector<int> ino(n);  //0 .. n-1\n  vector<int> inv_ino(n);\n \n  for(int i=0; i<n; ++i){\n    int v;\n    cin >> v;\n    preo[i] = v-1;\n    inv_preo[v-1] = i;\n  }\n  for(int i=0; i<n; ++i){\n    int v;\n    cin >> v;\n    ino[i] = v-1;\n    inv_ino[v-1] = i;\n  }\n  \n  reconstruct_tree(nodes, 0, nodes.size(), preo[0],\n\t\t   preo, inv_preo, ino, inv_ino);\n  \n  print_postorder(nodes, preo[0], 1); cout << endl; \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Ref : https://book.mynavi.jp/ec/products/detail/id=35408\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n\tif (l >= r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\nvoid solve() {\n\tpos = 0;\n\trec(0, pre.size());\n\tfor (int i = 0; i < n; i++) {\n\t\tif ( i ) cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tint cache;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> cache;\n\t\tpre.push_back(cache);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> cache;\n\t\tin.push_back(cache);\n\t}\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <limits>\n#include <string>\n#include <stack>\n#include <queue>\n\n#define INT_MAX 2147483647\n#define INT_MIN -2147483647\n\n#define NUM 10000\n#define INVALID_IDX -1\nusing namespace std;\n\nvector<int> pre, in, post;\nint pos = 0;\n\nvoid traverse(int l, int r)\n{\n\tif (l >= r) return;\n\n\tint rootVal = pre[pos++];\n\tint rootPos = distance(in.begin(), find(in.begin(), in.end(), rootVal));\n\n\ttraverse(l, rootPos);\n\ttraverse(rootPos+1, r);\n\n\tpost.push_back(rootVal);\n}\n\nvoid solve()\n{\n\tpos = 0;\n\ttraverse(0, pre.size());\n\n\tfor (int i = 0; i < post.size() - 1; ++i)\n\t{\n\t\tcout << post[i] << \" \";\n\t}\n\tif (!post.empty()) cout << post.back();\n}\n\n\nint main()\n{\n\tint num;\n\tcin >> num;\n\tpre.resize(num);\n\tin.resize(num);\n\t\n\tfor (int i = 0; i < num; ++i) cin >> pre[i];\n\tfor (int i = 0; i < num; ++i) cin >> in[i];\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define MAX 45\n#define NIL -1\n\ntypedef struct {\n\tint parent;\n\tint left;\n\tint right; \n} Tree; \n\nint index = 0;\nvector<int> v;\n\n\nvoid rebuild(Tree T[], int pre[], int in[], int left, int right, int n)\n{\n\tint rootIndex;\n\t\n//\tif (index+1 > n-1)\n//\t\treturn;\n\tif (left >= right)\n\t\treturn;\n\t\n\tfor (int i = left; i < right; i++) {\n\t\tif (pre[index] == in[i]) {\n\t\t\trootIndex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif (rootIndex != left) {\n\t\tif (index+1 > n-1)\n\t\t\treturn;\n\t\tindex++;\n\t\tT[in[rootIndex]].left = pre[index];\n\t\tT[pre[index]].parent = in[rootIndex];\n\t\trebuild(T, pre, in, left, rootIndex, n);\n\t}\n\tif (rootIndex+1 != right) {\n\t\tif (index+1 > n-1)\n\t\t\treturn;\n\t\tindex++;\n\t\tT[in[rootIndex]].right = pre[index];\n\t\tT[pre[index]].parent = in[rootIndex];\n\t\trebuild(T, pre, in, rootIndex+1, right, n);\n\t}\n}\n\nvoid Postorder(Tree T[], int rootId)\n{\n\tif (rootId == NIL)\n\t\treturn;\n\t\t\n\tPostorder(T, T[rootId].left);\n\tPostorder(T, T[rootId].right);\n\t//cout << rootId << \" \";\n\tv.push_back(rootId);\n}\n\nint main(void)\n{\n\tTree T[MAX];\n\tint pre[MAX];\n\tint in[MAX];\n\tint n;\n\t\n\tcin >> n;\n\tfor (int i = 0; i <= n; i++) {\n\t\tT[i].parent = NIL;\n\t\tT[i].left = NIL;\n\t\tT[i].right = NIL;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> pre[i];\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> in[i];\n\t}\n\trebuild(T, pre, in, 0, n, n);\n\tPostorder(T, pre[0]);\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tif (i > 0)\n\t\t\tcout << \" \";\n\t\tcout << v[i];\n\t}\n\tcout << '\\n';\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint map[25];\nstruct treenode{\n\tint data;\n\ttreenode* leftchild;\n\ttreenode* rightchild;\n\ttreenode(int v) {\n\t\tdata = v;\n\t\tleftchild = NULL;\n\t\trightchild = NULL;\n\t}\n};\n\nvoid remap(int inorder[],int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tmap[inorder[i]] = i;\n\t}\n}\n\ntreenode* bip(int pre[], int n, int offset) {\n\tif (n == 0) return NULL;\n\tint rootval = pre[0];\n\tint i = map[rootval] - offset;\n\ttreenode* root =new treenode(rootval);\n\troot->leftchild = bip(pre + 1, i, offset);\n\troot->rightchild = bip(pre + i + 1, n - i - 1, offset + i + 1);\n\treturn root;\n}\n\nvoid lastorder(treenode* ptr) {\n\tif (ptr) {\n\t\tlastorder(ptr->leftchild);\n\t\tlastorder(ptr->rightchild);\n\t\tcout << ptr->data<< \" \" ;\n\n\t}\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tint* pre = new int(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> pre[i];\n\t}\n\tint* inorder = new int(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> inorder[i];\n\t}\n\tremap(inorder, n);\n\ttreenode* root;\n\troot = bip(pre, n, 0);\n\tlastorder(root);\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <iterator>\n#include<algorithm>\nstatic const int NIL = -1;\nstatic const int NumberChild = 2;\nclass Tree {\nprivate:\n\tint id;\n\tint parent;\n\tint child[NumberChild];\n\npublic:\n\tTree() {\n\t\tid = child[0] = child[1] = parent = NIL;\n\t}\n\tvoid AddParent(int ID) {\n\t\tparent = ID;\n\t\treturn;\n\t}\n\tvoid AddID(int ID) {\n\t\tid = ID;\n\t\treturn;\n\t}\n\tvoid AddChild(std::vector<int>&Child) {\n\t\tfor (unsigned int i = 0; i < Child.size(); ++i) {\n\t\t\tchild[i] = Child[i];\n\n\t\t}\n\n\t\treturn;\n\t}\n\tint GetRoot(std::vector<Tree> nodes, int ID) {\n\t\tint RootID = ID;\n\t\tif (RootID != NIL&&nodes[RootID].parent != NIL) {\n\t\t\tRootID = GetRoot(nodes, nodes[RootID].parent);\n\t\t}\n\t\treturn RootID;\n\t}\n\tvoid PreorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid InorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid PostorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t\tif(nodes[ID].id!=NIL)std::cout << \" \" << nodes[ID].id;\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid Reconstruct(const std::vector<int>Pre, const std::vector<int>In, std::vector<Tree> &nodes, const int Root,int &cnt) {\n\t\t\n\t\tint m = std::distance(In.begin(), std::find(In.begin(), In.end(), Root));\n\t\n\t\t//nodes[cnt].AddID(Root);\n\t\tnodes[Root].AddID(Root);\n\t\tif (m == 0||Root==NIL) { return; }\n\t\tstd::vector<int>PreLeft;\n\t\n\t\tstd::copy(&Pre[1], &Pre[m]+1, std::back_inserter(PreLeft));\n\t\t\n\t\tstd::vector<int>PreRight;\n\t\t\n\t\tstd::copy(&Pre[m+1 ], &Pre[Pre.size()-1]+1, std::back_inserter(PreRight));\n\t\t\n\t\tstd::vector<int>InLeft;\n\t\tstd::copy(&In[0], &In[m-1]+1, std::back_inserter(InLeft));\n\t\t\n\n\t\tstd::vector<int> InRight;\n\t\tstd::copy(&In[m]+1, &In[In.size() - 1]+1, std::back_inserter(InRight));\n\t\t\n\n\t\tstd::vector<int> child{ PreLeft.empty() ? NIL : PreLeft[0], PreRight.empty() ? NIL : PreRight[0] };\n\t\t//nodes[cnt].AddChild(child);\n\t\tnodes[Root].AddChild(child);\n\t\tfor (unsigned int i = 0; i < child.size(); ++i) {\n\n\t\t\tnodes[child[i]].AddParent(Root);\n\t\t}\n\t\tReconstruct(PreLeft, InLeft, nodes, PreLeft[0], ++cnt);\n\t\tReconstruct(PreRight, InRight, nodes, PreRight[0], ++cnt);\n\t}\n};\n\nvoid SetVector(std::vector<int>&InputVector) {\n\tfor (unsigned int i = 0; i < InputVector.size(); ++i) {\n\t\tstd::cin >> InputVector[i];\n\t}\n\treturn;\n}\nint main(void) {\n\n\tint n;\n\tstd::cin >> n;\n\tstd::vector<int>Pre(n);\n\tstd::vector<int>In(n);\n\tSetVector(Pre);\n\tSetVector(In);\n\tstd::vector<Tree> nodes(n+1);\n\t//ReconstructWithNoParent\n\tint cnt = 0;\n\tnodes[1].Reconstruct(Pre, In, nodes, Pre[0],cnt);\n\n\tnodes[1].PostorderTreeWalk(nodes, 1);\n\tstd::cout << std::endl;\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace  std;\n\nconst int END = -1;\nstruct StNod\n{\n  int m_nParnt;\n  int m_nLeft;\n  int m_nRigt;\n\n  StNod() :\n     m_nParnt(END), m_nLeft(END), m_nRigt(END)\n  { }\n};\n\nenum EnDir\n{\n  D_Left,\n  D_Right,\n};\n\nvoid fnInput(vector<int> &rvnPodr, vector<int> &rvnIodrSeq)\n{\n  int nMaxSiz;\n\n  cin >> nMaxSiz;\n  rvnPodr.resize(nMaxSiz);\n  rvnIodrSeq.resize(nMaxSiz + 1);\n\n  for (int i = 0; i < nMaxSiz; i++)\n    cin >> rvnPodr[i];\n\n  for (int i = 1; i < nMaxSiz + 1; i++)\n  {\n    int nNode;\n    cin >> nNode;\n    rvnIodrSeq[nNode] = i;\n  }\n}\n\nvoid fnStructTree(const vector<int> &cnrvnPodr, const vector<int> &cnrvnIodrSeq, vector<StNod> &rvoNod)\n{\n  for (int i = 1; i < cnrvnPodr.size(); i++)\n  {\n    int nParnt = END;\n    int nx = cnrvnPodr[0];\n    EnDir enDir;\n    while (nx != END)\n    {\n      nParnt = nx;\n      if (cnrvnIodrSeq[ cnrvnPodr[i] ] < cnrvnIodrSeq[nx])\n      {\n        nx = rvoNod[nx].m_nLeft;\n        enDir = D_Left;\n      }\n      else\n      {\n        nx = rvoNod[nx].m_nRigt;\n        enDir = D_Right;\n      }\n    }\n\n    rvoNod[ cnrvnPodr[i] ].m_nParnt = nParnt;\n    if (enDir == D_Left)\n      rvoNod[nParnt].m_nLeft = cnrvnPodr[i];\n    else\n      rvoNod[nParnt].m_nRigt = cnrvnPodr[i];\n  }\n}\n\nvoid fnPostOrder(const vector<StNod> &cnrvoNod, int nx)\n{\n  static int stnPrt = 0;\n  if (nx == END)  return;\n\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nLeft);\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nRigt);\n  if (stnPrt++) cout << \" \";\n  cout << nx;\n}\n\nvoid fnResult(const vector<StNod> &cnrvoNod)\n{\n  int nx = 1;\n  while (cnrvoNod[nx].m_nParnt != END)\n    nx = cnrvoNod[nx].m_nParnt;\n\n  fnPostOrder(cnrvoNod, nx);\n  cout << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vector<int> vnPodr, vnIodrSeq;\n  vector<StNod> voNod;\n\n  fnInput(vnPodr, vnIodrSeq);\n\n  StNod oNod;\n  voNod.resize(vnIodrSeq.size(), oNod);\n  fnStructTree(vnPodr, vnIodrSeq, voNod);\n  \n  int nOCnt = 0;\n  fnResult(voNod);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r)\n{\n  if (l >= r)\n  {\n    return;\n  }\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(l, m);\n  rec(m + 1, r);\n  post.push_back(root);\n}\n\nvoid solve()\n{\n  pos = 0;\n  rec(0, pre.size());\n  for (int i = 0; i < n; i++)\n  {\n    if (i)\n    {\n      cout << \" \";\n    }\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main()\n{\n  int k;\n  cin >> n;\n  for (int i = 0; i < n; i++)\n  {\n    cin >> k;\n    pre.push_back(k);\n  }\n  for (int i = 0; i < n; i++)\n  {\n    cin >> k;\n    in.push_back(k);\n  }\n\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define MAX 105\n#define NIL -1\n\nstruct node {\n\tint prnt, left, right;\n};\nint n;\nnode tr[MAX];\n\nvector<int> preord(MAX);\nvector<int> inord(MAX);\nvector<int> pstord;\n\nvector<int> preIdx(500);\nvector<int> inIdx(500);\n\nvoid setPst(int me) {\n\n\tif (me == NIL) return;\n\tsetPst(tr[me].left);\n\tsetPst(tr[me].right);\n\tpstord.push_back(me);\n\n}\n\n\nvoid dfs(int pr, int st, int ed, bool isLeft) {\n\tint lftEd, rgtSt, nrIdx, tmp, nrt, mn;\n\n\tif (ed - st <= 1) {\n\t\ttmp = inord[st];\n\n\t\ttr[tmp].prnt = pr;\n\t\tif (isLeft) tr[pr].left = tmp;\n\t\telse tr[pr].right = tmp;\n\n\t}\n\telse\n\t{\n\t\tmn = 999;\n\t\tfor (int i = st; i < ed; i++)\n\t\t{\n\t\t\ttmp = preIdx[inord[i]];\n\t\t\tif (mn > tmp) mn = tmp;\n\t\t}\n\t\tnrt = preord[mn];\n\t\tnrIdx = inIdx[nrt];\n\n\t\tlftEd = nrIdx;\n\t\trgtSt = nrIdx + 1;\n\n\t\ttr[nrt].prnt = pr;\n\t\tif (isLeft) tr[pr].left = nrt;\n\t\telse tr[pr].right = nrt;\n\n\t\t// left\n\t\tif (lftEd - st > 0)\t\tdfs(nrt, st, lftEd, true);\n\n\t\t// right\n\t\tif (ed - rgtSt > 0)\t\tdfs(nrt, rgtSt, ed, false);\n\n\t}\n}\n\n\n\nint main() {\n\n\n\tint i, rt, left, right, rtIdx;\n\tcin >> n;\n\tfor (i = 0; i < MAX; i++) tr[i].prnt = tr[i].left = tr[i].right = NIL;\n\n\tfor (i = 0; i < n; i++) \t\tcin >> preord[i];\n\tfor (i = 0; i < n; i++) \t\tcin >> inord[i];\n\n\tfor (int i = 0;i < n;i++) {\n\t\tpreIdx[preord[i]] = i;\n\t}\n\n\tfor (int i = 0;i < n;i++) {\n\t\tinIdx[inord[i]] = i;\n\t}\n\n\n\trt = preord[0];\n\trtIdx = inIdx[rt];\n\n\tif (rtIdx - 0 > 0)\tdfs(rt, 0, rtIdx, true);\n\tif (n - (rtIdx + 1) > 0)\tdfs(rt, rtIdx + 1, n, false);\n\n\trt = 1;\n\twhile (tr[rt].prnt != NIL)\n\t{\n\t\trt = tr[rt].prnt;\n\t}\n\n\tsetPst(rt);\n\n\tint isf = 0;\n\tfor (int i = 0;i < n;i++) {\n\t\tif (isf++) printf(\" \");\n\t\tprintf(\"%d\", pstord[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n,pos;\nvector<int>pre,in,post;\nvoid rec(int l,int r){\n\tif(l>=r)\n\t\treturn ;\n\t//将树一分为二的节点 \n\tint root = pre[pos++];\n\t//寻找root在中序中的位置 \n\tint m = distance(in.begin(),find(in.begin(),in.end(),root));\n\trec(l,m);\n\trec(m+1,r);\n\t//每一个子树的根节点最后输出 \n\tpost.push_back(root); \n}\nvoid solve(){\n\tpos=0;\n\trec(0,pre.size());\n\tfor(int i=0;i<n;i++){\n\t\tif(i)\n\t\t\tcout<<\" \";\n\t\tcout<<post[i];\n\t}\n\tcout<<endl;\n}\nint main(){\n\tcin>>n;\n\tint k;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>k;\n\t\tpre.push_back(k);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tcin>>k;\n\t\tin.push_back(k);\n\t} \n\tsolve();\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l. int r) {\n    if (l>=r) return;\n    int root=pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(1, m);\n    rec(m+1, r);\n    post.push_back(root);\n}\n\nvoid solve() {\n    pos = 0;\n    rec(1, pre.size());\n    for (int i=0; i<n; i++) {\n        if(i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main() {\n    int k;\n    cin >> n;\n    \n    for (int i=0; i<n; i++) {\n        cin >> k;\n        pre.push_back(k);\n    }\n    \n    for (int i=0; i<n; i++) {\n        cin >> k;\n        in.push_back(k);\n    }\n    \n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <stack>\n\ntypedef struct Node {\n    int id;\n    int parent;\n    int c[2];\n    Node(){ id = 0; parent = -1; c[0] = -1; c[1] = -1;};\n    Node(int i){ id = i; parent = -1; c[0] = -1; c[1] = -1;};\n    ~Node(){};\n} Node;\n\nvoid postorder_iter(std::vector<Node> &nodes, int id){\n    if(id == -1) return;\n    postorder_iter(nodes, nodes[id].c[0]);\n    postorder_iter(nodes, nodes[id].c[1]);\n    std::printf(\"%d\", id+1);\n    if(nodes[id].parent == -1) std::printf(\"\\n\");\n    else std::printf(\" \");\n}\n\nint main(){\n    int n;\n    std::scanf(\"%d\", &n);\n    std::vector<int> preorder;\n    std::vector<int> inorder;\n\n    for(int i = 0; i < n; ++i){\n        int v;\n        std::scanf(\"%d\", &v);\n        --v;//adjust value                                                                                                                                                                                                          \n        preorder.push_back(v);\n    }\n    for(int i = 0; i < n; ++i){\n        int v;\n        std::scanf(\"%d\", &v);\n        --v;//adjust value                                                                                                                                                                                                          \n        inorder.push_back(v);\n    }\n\n    std::vector<Node> nodes;\n    for(int i = 0; i < n; ++i){\n        Node node(i);\n        nodes.push_back(node);\n    }\n    std::vector<bool> isExist(n, 0);\n    int i = 0;\n    int j = 0;\n    int p = -1;\n    while(i < n && j < n){\n        while(preorder[i] != inorder[j]){\n            nodes[preorder[i]].c[0] = preorder[i+1];\n            nodes[preorder[i]].parent = p;\n            isExist[preorder[i]] = true;\n            p = preorder[i];\n            ++i;\n        }\n        nodes[preorder[i]].parent = p;\n\tisExist[preorder[i]] = true;\n        ++i;\n        if(i == n) break;\n        while(isExist[inorder[j]]) ++j;\n        p = inorder[j - 1];\n        nodes[p].c[1] = preorder[i];\n\n    }\n\n    postorder_iter(nodes, preorder[0]);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n\nusing namespace std;\n\nint n, pos;\nint pre[40], in[40], post[40];\nbool preused[40];\n\ninline int toinnode(int prenode) {\n    for (int i = 0; i < n; ++i) {\n        if (in[i] == pre[prenode]) {\n            return i;\n        }\n    }\n}\n\ninline int toprenode(int innode) {\n    for (int i = 0; i < n; ++i) {\n        if (pre[i] == in[innode]) {\n            return i;\n        }\n    }\n}\n\ninline void topost(int preroot, int num) {\n\n//    printf(\"[topost] preroot = %d, num = %d\\n\", preroot, num);\n\n    int inroot = toinnode(preroot), leftnodenum = 0;\n\n    // whether preroot has a left tree or not. \n    if (inroot - 1 >= 0 && !preused[toprenode(inroot - 1)]) {\n        preused[preroot + 1] = true;\n        int inleftroot = toinnode(preroot + 1);\n        for (int i = inleftroot - 1;\n                i >= 0 && !preused[toprenode(i)]; --i, ++leftnodenum) { };\n        for (int i = inleftroot + 1;\n                i < n && !preused[toprenode(i)]; ++i, ++leftnodenum) { };\n        ++leftnodenum;\n        topost(preroot + 1, toprenode(inroot - 1) - preroot);\n    }\n\n    // whether preroot has a right tree or not. \n    if (inroot + 1 < n && !preused[toprenode(inroot + 1)]) {\n        int prerightroot = preroot + leftnodenum + 1;\n        preused[prerightroot] = true;\n        topost(prerightroot, num - leftnodenum);\n    }\n\n    post[pos++] = pre[preroot];\n}\n\nint main(void) {\n\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &pre[i]);\n    }\n\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &in[i]);\n    }\n\n    preused[0] = true;\n    topost(0, n);\n\n    printf(\"%d\", post[0]);\n    for (int i = 1; i < n; ++i) {\n        printf(\" %d\", post[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define MAX 40\nvector<int> pre, in, post;\nint n, pos;\n\nvoid rec(int l, int r){\n    if(l >= r)  return;\n    int next = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), next));\n    rec(l, m);\n    rec(m+1, r);\n    post.push_back(next);\n}\n\nvoid solve(){\n    pos = 0;\n    rec(0, pre.size());\n    for(int i = 0; i < post.size(); i++){\n        if(i)   cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main(){\n    cin >> n;\n\n    int k;\n    for(int i = 0; i < n; i++){\n        cin >> k;\n        pre.push_back(k);\n    }\n\n    for(int i = 0; i < n; i++){\n        cin >> k;\n        in.push_back(k);\n    }\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <numeric>\n#include <string>\n#include <cmath>\n#include <iomanip>\n#include <queue>\n#include <list>\n#include <stack>\n#include <cctype>\n#include <cmath>\n\nusing namespace std;\n\n/* typedef */\n\ntypedef long long ll;\n\n/* constant */\n\nconst int INF = 1 << 30;\nconst int MAX = 40;\nconst int MOD = 1000000007;\nconst int NIL = -1;\nconst double pi = 3.141592653589;\n/* global variables */\nstruct Node {\n    int parent,\n        left,\n        right;\n};\nNode T[MAX];\nvector<int> Pre(MAX), In(MAX), Post;\nint pos = 0;\n\n/* function */\nvoid reconstruction(int l, int r);\nvoid postorder(int u);\n\n/* main */\nint main(){\n\n    int n; cin >> n;\n    for (int i = 0; i <= n; i++)\n        T[i].parent = T[i].left = T[i].right = NIL;\n\n    for (int i = 0; i < n; i++)\n        cin >> Pre[i];\n    for (int i = 0; i < n; i++)\n        cin >> In[i];\n\n    reconstruction(0, n);\n\n    for (int i = 0; i < n; i++) {\n        if (i) cout << ' ';\n        cout << Post[i];\n    }cout << '\\n';\n    return 0;\n}\n\nvoid reconstruction(int l, int r) {\n    if (l >= r) return;\n    int root = Pre[pos++];\n    vector<int>::iterator itr = find(In.begin(), In.end(), root);\n    int m = distance(In.begin(), itr);\n    reconstruction(l, m);\n    reconstruction(m+1, r);\n    Post.push_back(root);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct Node{\n    int left;\n    int right;\n};\n\nclass Tree{\n    vector<Node> node;\npublic:\n    Tree(int n){\n        node.resize(n);\n    }\n    int make_tree(vector<int>& pre, int head_p,\n                  vector<int>& in , int head_i, int len){\n        if (len == 0) return -1;\n        int obj = pre[head_p];\n        int pos;\n        for (pos = head_i; in[pos] != obj; pos++);\n        node[obj].left  = make_tree(pre, head_p + 1, in, head_i, pos - head_i);\n        node[obj].right = make_tree(pre, head_p + 1 + pos - head_i,\n                                    in, pos + 1, head_i + len - 1 - pos);\n        return obj;\n    }\n    void post_order(int p, vector<int>& post){\n        if (p == -1) return;\n        post_order(node[p].left , post);\n        post_order(node[p].right, post);\n        post.push_back(p);\n    }\n};\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int> pre(n);\n    vector<int> in(n);\n    for (int i = 0; i < n; i++) cin >> pre[i];\n    for (int i = 0; i < n; i++) cin >> in[i];\n    Tree T(n + 1);\n    T.make_tree(pre, 0, in, 0, pre.size());\n    vector<int> post;\n    T.post_order(pre[0], post);\n    for (int i = 0; i < post.size(); i++) {\n        cout << post[i] << (i == post.size() - 1 ? '\\n' : ' ');\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n#define MAX 100\nint I[MAX];\n\nclass TreeNode\n{\npublic:\n\tint data;\n\tTreeNode* pLeftChild;\n\tTreeNode* pRightChild;\n};\n\nclass BinaryTree\n{\npublic:\n\tBinaryTree(TreeNode* pRoot, int n) : m_pRoot(pRoot), m_n(n) {}\n\tvoid PostOrder()\n\t{\n\t\tm_count = 0;\n\t\tPostOrder(m_pRoot);\n\t}\n\nprivate:\n\tvoid PostOrder(TreeNode* currentNode)\n\t{\n\t\tif (!currentNode) return;\n\n\t\tPostOrder(currentNode->pLeftChild);\n\t\tPostOrder(currentNode->pRightChild);\n\t\t++m_count;\n\t\tcout << currentNode->data << (m_count != m_n ? \" \": \"\\n\");\n\t}\n\nprivate:\n\tTreeNode* m_pRoot;\n\tint m_n;\n\tint m_count;\n};\n\nTreeNode* RebuildTree(queue<int> &P, int *i, int l, int r)\n{\n\tif (l == r) return 0;\n\n\tint v = P.front();\n\tP.pop();\n\tTreeNode* node = new TreeNode();\n\tnode->data = v;\n\tint f = -1;\n\tfor (int j = l; j < r; ++j)\n\t{\n\t\tif (v == i[j])\n\t\t{\n\t\t\tf = j;\n\t\t\tbreak;\n\t\t}\n\t}\n\tnode->pLeftChild = RebuildTree(P, i, l, f);\n\tnode->pRightChild = RebuildTree(P, i, f + 1, r);\n\n\treturn node;\n}\n\nint main()\n{\n\tint n; cin >> n;\n\tqueue<int> P;\n\tint v;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tcin >> v;\n\t\tP.push(v);\n\t}\n\tfor (int i = 0; i < n; ++i) cin >> I[i];\n\tTreeNode* pRoot = RebuildTree(P, I, 0, n);\n\tBinaryTree tree(pRoot, n);\n\ttree.PostOrder();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <functional>\n#define _USE_MATH_DEFINES\n#include <math.h>\n \nusing namespace std;\n \nint n, pos;\nvector<int> pre, in, post;\n \nvoid rec(int l, int r)\n{\n    if (l >= r)\n    {\n        return;\n    }\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m + 1, r);\n    post.push_back(root);\n}\n \nvoid solve()\n{\n    cin >> n;\n    for (int i = 0; i < n; ++i)\n    {\n        int k;\n        cin >> k;\n        pre.push_back(k);\n    }\n    for (int i = 0; i < n; ++i)\n    {\n        int k;\n        cin >> k;\n        in.push_back(k);\n    }\n    pos = 0;\n    rec(0, pre.size());\n    for (int i = 0; i < n; ++i)\n    {\n        if (i)\n        {\n            cout << \" \";\n        }\n        cout << post[i];\n    }\n    cout << endl;\n}\n \nint main()\n{\n    solve();\n    return(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <algorithm>\n \nenum TNodeType {ntRoot, ntInternal, ntLeaf};\ntemplate<typename T>\nclass TTree;\n \ntemplate<typename T>\nclass TNode\n{\n    const T FValue;\n    TNode* FParent;\n    TNode* FLeft;\n    TNode* FRight;\n\npublic:\n    TNode(const T& Value)\n     : FValue(Value)\n    {\n        FParent = NULL;\n        FLeft   = NULL;\n        FRight  = NULL;\n    }\n    T Value()const\n    {\n        return FValue;\n    }\n    void AddNode(TNode* Node)\n    {\n        Node->FParent = this;\n        if(FValue < Node->FValue){\n            assert(FRight);\n            FRight = Node;\n        }else{\n            assert(FLeft);\n            FLeft  = Node;\n        }\n    }\n    void SetLeft(TNode* Node)\n    {\n        Node->FParent = this;\n        FLeft = Node;\n    }\n    void SetRight(TNode* Node)\n    {\n        Node->FParent = this;\n        FRight = Node;\n    }\n    TNode* CreateLeft(const T& Value)\n    {\n        assert(FLeft == NULL);\n        SetLeft(new TNode(Value));\n        return FLeft;\n    }\n    TNode* CreateRight(const T& Value)\n    {\n        assert(FRight == NULL);\n        SetRight(new TNode(Value));\n        return FRight;\n    }\n    const TNode* Parent()const\n    {\n        return FParent;\n    }\n    const TNode* Left()const\n    {\n        return FLeft;\n    }\n    const TNode* Right()const\n    {\n        return FRight;\n    }\n    const TNode* Find(const T& Value)const\n    {\n        // std::cout << \"Find(\" << Value << \")\" << std::endl;\n        if(FValue == Value) return this;\n        TNode* Node = FValue < Value ? FRight : FLeft;\n        if(Node) return Node->Find(Value);\n        return NULL;\n    }\n    TNode* Find(const T& Value)\n    {\n        return const_cast<TNode*>(const_cast<const TNode*>(this)->Find(Value));\n    }\n};\n\ntemplate<typename T>\nint GetNodeDepth(const TNode<T>* Node)\n{\n    assert(Node);\n    int Depth = 0;\n    while(Node->Parent()){\n        Node = Node->Parent();\n        Depth++;\n    }\n    return Depth;\n}\n \ntemplate<typename T>\nTNodeType GetNodeType(const TNode<T>* Node)\n{\n    assert(Node);\n    if(Node->Parent() == NULL) return ntRoot;\n    if(Node->Left() || Node->Right()) return ntInternal;\n    return ntLeaf;\n}\nstd::string GetNodeTypeText(const TNodeType& Type)\n{\n    switch(Type){\n    case ntRoot:     return \"root\";\n    case ntInternal: return \"internal node\";\n    case ntLeaf:     return \"leaf\";\n    }\n    assert(false);\n    return \"\";\n}\n \ntemplate<typename T>\nconst TNode<T>* GetSibling(const TNode<T>* Node)\n{\n    assert(Node);\n    const TNode<T>* Parent = Node->Parent();\n    if(Parent == NULL) return NULL;\n    if(Parent->Left()  && Parent->Left()  != Node) return Parent->Left();\n    if(Parent->Right() && Parent->Right() != Node) return Parent->Right();\n    return NULL;\n}\ntemplate<typename T>\nconst TNode<T>* GetRoot(const TNode<T>* Node)\n{\n    if(Node->Parent()) return GetRoot(Node->Parent());\n    return Node;\n}\ntemplate<typename T>\nint GetDegree(const TNode<T>* Node)\n{\n    return (Node->Left() ? 1 : 0) + (Node->Right() ? 1 : 0);\n}\n\ntemplate<typename T>\nint GetHeight(const TNode<T>* Node)\n{\n    if(Node == NULL) return -1;\n    return 1 + std::max(GetHeight(Node->Left()), GetHeight(Node->Right()));\n}\ntemplate<typename T>\nvoid PrintNode(const TNode<T>* Node)\n{\n    assert(Node);\n// node 0: parent = -1, sibling = -1, degree = 2, depth = 0, height = 3, root    \n    std::cout << \n    \"node \"       << Node->Value() <<\n    \": parent = \" << (Node->Parent() ? Node->Parent()->Value() : -1) <<\n    \", sibling = \"<< (GetSibling(Node) ? GetSibling(Node)->Value() : -1) <<\n    \", degree = \" << GetDegree(Node) <<\n    \", depth = \"  << GetNodeDepth(Node) <<\n    \", height = \"  << GetHeight(Node) << \n    \", \"          << GetNodeTypeText(GetNodeType(Node)) <<\n    std::endl;\n}\n// template<typename T>\n// void PrintPreorder(const TNode<T>* Node)\n// {\n// //  0 1 2 3 4 5 6 7 8\n//     if(Node == NULL) return;\n//     std::cout << \" \" << Node->Value();\n//     PrintPreorder(Node->Left());\n//     PrintPreorder(Node->Right());\n// }\n// template<typename T>\n// void PrintInorder(const TNode<T>* Node)\n// {\n// //  2 1 3 0 6 5 7 4 8\n//     if(Node == NULL) return;\n//     PrintInorder(Node->Left());\n//     std::cout << \" \" << Node->Value();\n//     PrintInorder(Node->Right());\n// }\ntemplate<typename T>\nvoid PrintPostorder(const TNode<T>* Node)\n{\n//  2 3 1 6 7 5 8 4 0\n    if(Node == NULL) return;\n    PrintPostorder(Node->Left());\n    PrintPostorder(Node->Right());\n    std::cout << Node->Value();\n    if(Node->Parent()){\n        std::cout << \" \";\n    }else{\n        std::cout << std::endl;\n    }\n}\n\ntemplate<typename T, typename TIt>\nvoid AddNode(TNode<T>* Node, TIt& PreBegin, TIt PreEnd, TIt InBegin, TIt InEnd);\n\ntemplate<typename T, typename TIt>\nvoid AddLeftNode(TNode<T>* Node, TIt& PreBegin, TIt PreEnd, TIt InBegin, TIt InEnd)\n{\n    if(PreBegin == PreEnd) return;\n    if(InBegin == InEnd) return;\n    TNode<T>* New = new TNode<T>(*PreBegin);\n    Node->SetLeft(New);\n    AddNode(New, ++PreBegin, PreEnd, InBegin, InEnd);\n}\n\ntemplate<typename T, typename TIt>\nvoid AddRightNode(TNode<T>* Node, TIt& PreBegin, TIt PreEnd, TIt InBegin, TIt InEnd)\n{\n    if(PreBegin == PreEnd) return;\n    if(InBegin == InEnd) return;\n    TNode<T>* New = new TNode<T>(*PreBegin);\n    Node->SetRight(New);\n    AddNode(New, ++PreBegin, PreEnd, InBegin, InEnd);\n}\n\ntemplate<typename T, typename TIt>\nvoid AddNode(TNode<T>* Node, TIt& PreBegin, TIt PreEnd, TIt InBegin, TIt InEnd)\n{\n    if(PreBegin == PreEnd)  return;\n    TIt It = std::find(InBegin, InEnd, Node->Value());\n    assert(It != InEnd);\n    AddLeftNode(Node, PreBegin, PreEnd, InBegin, It);\n    AddRightNode(Node, PreBegin, PreEnd, It+1, InEnd);\n}\n\nint main()\n{\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    int n;\n    std::cin >> n;\n    std::vector<int> PreOrderIdList(n);\n    for(int i = 0; i < n; ++i){\n        std::cin >> PreOrderIdList[i];\n    }\n    std::vector<int> InOrderIdList(n);\n    for(int i = 0; i < n; ++i){\n        std::cin >> InOrderIdList[i];\n    }\n    \n    TNode<int> Node(PreOrderIdList[0]);\n    std::vector<int>::iterator It = PreOrderIdList.begin();\n    AddNode(&Node, ++It, PreOrderIdList.end(), InOrderIdList.begin(), InOrderIdList.end());\n\n    PrintPostorder(&Node);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// include\n//------------------------------------------\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// conversion\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\ntemplate <class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\n// math\n//-------------------------------------------\ntemplate <class T>\ninline T sqr(T x) {\n    return x * x;\n}\n\n// typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n// container util\n//------------------------------------------\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i, c) \\\n    for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort((c).begin(), (c).end())\n\n// repetition\n//------------------------------------------\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)\n\n// constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF_INT = 2147483647;\nconst LL INF_LL = 9223372036854775807;\n\n// clear memory\n//--------------------------------------------\n#define CLR(a) memset((a), 0, sizeof(a))\n\n// vector\n//--------------------------------------------\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\n// pair\n//--------------------------------------------\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, pair<T, U> &pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\n// vector\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"{\";\n    for (int i = 0; i < vec.size(); i++) {\n        os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");\n    }\n    os << \"}\";\n    return os;\n}\n\n// list\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, const list<T> &lst) {\n    os << \"{\";\n    REPI(itr, lst) {\n        os << *itr;\n        itr++;\n        if (itr != lst.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// map\n//--------------------------------------------\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, map<T, U> &map_var) {\n    os << \"{\";\n    REPI(itr, map_var) {\n        os << *itr;\n        itr++;\n        if (itr != map_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// set\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, set<T> &set_var) {\n    os << \"{\";\n    REPI(itr, set_var) {\n        os << *itr;\n        itr++;\n        if (itr != set_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// dump\n//--------------------------------------------\n#define DUMPOUT cerr\n\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail>\nvoid dump_func(Head &&head, Tail &&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) > 0) {\n        DUMPOUT << \", \";\n    }\n    dump_func(std::move(tail)...);\n}\n#ifdef DEBUG_\n#define DEB\n#define dump(...)                                                       \\\n    DUMPOUT << \"  \" << string(#__VA_ARGS__) << \": \"                     \\\n            << \"[\" << to_string(__LINE__) << \":\" << __FUNCTION__ << \"]\" \\\n            << endl                                                     \\\n            << \"    \",                                                  \\\n        dump_func(__VA_ARGS__)\n#else\n#define DEB if (false)\n#define dump(...)\n#endif\n\nint n, pos;\nVI pre, in, post;\n\nvoid rec(int l, int r) {\n    if (l >= r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m + 1, r);\n    post.PB(root);\n}\n\nvoid solve() {\n    pos = 0;\n    rec(0, pre.size());\n    REPI(it, post) {\n        if (it != post.begin()) cout << \" \";\n        cout << *it;\n    }\n    cout << endl;\n}\n\nint main(void) {\n    cin >> n;\n    REP(i, n) {\n        int x;\n        cin >> x;\n        pre.PB(x);\n    }\n    REP(i, n) {\n        int x;\n        cin >> x;\n        in.PB(x);\n    }\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint n, pos;\n\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n    if (l >= r) return;\n\n    int root=pre[pos++];\n    int m=distance(in.begin(),find(in.begin(),in.end(),root));\n    rec(1,m);\n    rec(m+1,r);\n    post.push_back(root);\n}\n\nvoid slove(){\n    pos=0;\n    rec(0,pre.size());\n    for(int i=0;i<n;i++){\n        if(i) cout<<\" \";\n        cout<<post[i];\n    }\n    cout<<endl;\n}\nint main(){\n    int k;\n    cin>>n;\n     for(int i=0;i<n;i++){\n         cin>>k;\n         pre.push_back(k);\n     }\n     for(int i=0;i<n;i++){\n         cin>>k;\n         in.push_back(k);\n     }\n     slove();\n\n     return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n  if(l >= r) return;\n     int root = pre[pos++];\n     int m = distance(in.begin(), find(in.begin(), in.end(), root));\n     rec(l,m);\n     rec(m + 1,r);\n     post.push_back(root);\n}\n\nvoid solve(){\n  pos = 0;\n  rec(0, pre.size());\n  for(int i = 0 ; i < n ; i++){\n    if(i) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main(){\n  int k;\n  cin >> n;\n\n  for(int i = 0 ; i < n ; i++){\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for(int i = 0 ; i < n ; i++){\n    cin >> k;\n    in.push_back(k);\n  }\n\n  solve();\n\n  return 0;\n}\n     \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n#define P(x) cout << (x) << endl\n#define p(x) cout << (x)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define vv(type, c, m, n, i) vector<vector<type>> c(m, vector<type>(n, i));\n#define rep(i,a,n) for(int i=(a), i##_len=(n); i<i##_len; ++i)\n#define rrep(i,a,n) for(int i=(a), i##_len=(n); i>i##_len; --i)\n#define len(x) ((int)(x).size())\n#define mp make_pair\n#define eb emplace_back\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\nint n, pos{0};\nvi pre, in, post;\ninline void rec(int l, int r) {\n\tif(l >= r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(all(in), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.eb(root);\n}\nint main() {\n\tcin >> n;\n\tpre.resize(n); in.resize(n); post.reserve(n);\n\trep(i, 0, n) cin >> pre[i];\n\trep(i, 0, n) cin >> in[i];\n\trec(0, len(pre));\n\tcout << post[0];\n\trep(i, 1, n) cout << \" \" << post[i];\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <fstream>\n\nusing namespace std;\n\nint n, pos;\nvector<int> pre, ina, post;\n\nvoid rec(int l, int r){\n    if(l>=r)return;\n    int root = pre[pos++];\n    int m = distance(ina.begin(), find(ina.begin(), ina.end(), root));\n    rec(l, m);\n    rec(m+1, r);\n    post.push_back(root);\n}\n\nvoid solve(){\n    pos = 0;\n    rec(0,pre.size());\n    for(int i=0; i<n; i++){\n        if(i)cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main(void){\n    \n    /////////\n    //write//\n    /////////\n\n    \n    int k;\n    cin >> n;\n    \n    for(int i=0; i<n; i++){\n        cin >> k;\n        pre.push_back(k);\n    }\n    \n    for(int i=0; i<n; i++){\n        cin >> k;\n        ina.push_back(k);\n    }\n    \n    solve();\n    \n    return  0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n  if( l >= r ) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(l, m);\n  rec(m+1, r);\n  post.push_back(root);\n}\n\nvoid solve(){\n  int i;\n  pos = 0;\n  rec(0, pre.size());\n  for( i = 0 ; i < n ; i++ ){\n    if(i) printf(\" \");\n    printf(\"%d\", post[i]);\n  }\n  printf(\"\\n\");\n}\n\nint main(){\n  int i, k;\n\n  scanf(\"%d\", &n);\n\n  for( i = 0 ; i < n ; i++ ){\n    scanf(\"%d\", &k);\n    pre.push_back(k);\n  }\n\n  for( i = 0 ; i < n ; i++ ){\n    scanf(\"%d\", &k);\n    in.push_back(k);\n  }\n\n  solve();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <list>\n\nconst int MAX_N = 25;\nconst int SINGLE_NODE = 1;\nconst int NONE = -1;\n\nstruct Node {\n  int parent;\n  int left;\n  int right;\n  bool visited;\n};\n\nint reconstruct(std::list<int> *preorderNodes,\n\t\t std::list<int> *inorderNodes,\n\t\t int parent,\n\t\t struct Node *nodes[]) {\n  if (preorderNodes->empty()) {\n    return NONE;\n  }\n  \n  if (inorderNodes->size() == SINGLE_NODE) {\n    int v = inorderNodes->front();\n    inorderNodes->pop_front();\n\n    nodes[v]->parent = parent;\n\n    return v;\n  }\n\n  int v = preorderNodes->front();\n  preorderNodes->pop_front();\n\n  std::list<int> *leftNodes = new std::list<int>();\n  std::list<int> *rightNodes = new std::list<int>();\n\n  while (!inorderNodes->empty()) {\n    int k = inorderNodes->front();\n    inorderNodes->pop_front();\n\n    if (k == v) {\n      break;\n    } else {\n      leftNodes->push_back(k);\n    }\n  }\n\n  while (!inorderNodes->empty()) {\n    int k = inorderNodes->front();\n    inorderNodes->pop_front();\n\n    if (k == v) {\n      break;\n    } else {\n      rightNodes->push_back(k);\n    }\n  }\n\n  if (!leftNodes->empty()) {\n    nodes[v]->left = reconstruct(preorderNodes, leftNodes, v, nodes);\n  }\n\n  if (!rightNodes->empty()) {\n    nodes[v]->right = reconstruct(preorderNodes, rightNodes, v, nodes);\n  }\n\n  return v;\n}\n\nvoid printByPostorder(struct Node *nodes[], int n, int rootID) {\n  std::list<int> list;\n\n  list.push_front(rootID);\n  \n  //std::cout << \"Postorder\" << std::endl;\n  \n  while (!list.empty()) {\n    int id = list.front();\n    list.pop_front();\n    \n    if (id < 0) {\n      continue;\n    }\n    \n    struct Node *node = nodes[id];\n\n    if (!node->visited) {\n      node->visited = true;\n      \n      list.push_front(id);      \n      list.push_front(node->right);\n      list.push_front(node->left);\n    } else {\n      std::cout << \" \" << id;\n    }\n  }\n\n  std::cout << std::endl;      \n}\n\nint main(void) {\n  int n;\n\n  std::cin >> n;\n\n  struct Node *nodes[MAX_N];\n\n  for (int i = 0; i <= n; i++) {\n    struct Node *node = (struct Node *) std::malloc(sizeof(struct Node));\n    \n    node->parent = NONE;\n    node->left = NONE;\n    node->right = NONE;\n    node->visited = false;\n\n    nodes[i] = node;\n  }\n\n  std::list<int> *preorderNodes = new std::list<int>();\n  std::list<int> *inorderNodes = new std::list<int>();\n\n  for (int i = 0; i < n; i++) {\n    int v = 0;\n\n    std::cin >> v;\n\n    preorderNodes->push_back(v);\n  }\n\n  for (int i = 0; i < n; i++) {\n    int v = 0;\n\n    std::cin >> v;\n\n    inorderNodes->push_back(v);\n  }  \n  \n  int rootID = preorderNodes->front();\n\n  reconstruct(preorderNodes, inorderNodes, rootID, nodes);\n  \n  printByPostorder(nodes, n, rootID);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n\nvoid MakePost(vector<int> &post, vector<int> pre, vector<int> in, int start, int end, int* posi)\n{\n    int mid;\n    int root;\n\n    if (start < end) {\n        root = pre[*posi];\n        mid = distance(in.begin(), find(in.begin(), in.end(), root));\n        ++(*posi);\n        MakePost(post, pre, in, start, mid, posi);\n        MakePost(post, pre, in, mid+1, end, posi);\n        post.push_back(root);\n    }\n\n    return;\n}\n\nint main(void)\n{\n    int i;\n    int key;\n    int num;\n    int posi = 0;\n    vector<int> inorder;\n    vector<int> preorder;\n    vector<int> postorder;\n\n    scanf(\"%d\", &num);\n    for (i = 0; i < num; i++) {\n        scanf(\"%d\", &key);\n        preorder.push_back(key);\n    }\n    for (i = 0; i < num; i++) {\n        scanf(\"%d\", &key);\n        inorder.push_back(key);\n    }\n\n    MakePost(postorder, preorder, inorder, 0, preorder.size(), &posi);\n    printf(\"%d\", postorder[0]);\n    for (i = 1; i < num; i++) {\n        printf(\" %d\", postorder[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 45\nusing namespace std;\nint pre[N], p = 0;\nint in[N];\nint n;\nvector<int> post;\nvoid rec(int l, int r){\n    if (l >= r) return ;\n    int c = pre[p++];\n    int m;\n    for(m = 0; m < n; m++){\n        if(in[m] == c) break;\n    }\n    rec(l, m);\n    rec(m+1, r);\n    post.push_back(c);\n}\nint main() {\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++) scanf(\"%d\", &pre[i]);\n    for(int i = 0; i < n; i++) scanf(\"%d\", &in[i]);\n    rec(0, n);\n    for(int i = 0; i < post.size(); i++){\n        if(i) printf(\" \");\n        printf(\"%d\", post[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint n, pos;\nvector<int>pre, in, post;\n\nvoid rec(int l, int r)\n{\n\tif (l >= r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\nvoid solve()\n{\n\tpos = 0;\n\trec(0, pre.size());\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (i)cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\n\nint main()\n{\n\tint k;\n\tcin >>n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<iostream>\nusing namespace std;\n\n#define A_MAX 100\n\ntypedef struct _order {\n    int i;\n    int buf[A_MAX];\n} Order;\n\nOrder preorder;\nOrder inorder;\nOrder postorder;\n\n\nint find(int *inorder, int id)\n{\n    int i = 0;\n    while (1) {\n        if (inorder[i] == id) return i;\n        i++;\n    }\n}\n\nvoid reconstruction(int left, int right)\n{\n//    printf(\"left %d right %d\\n\", left ,right);\n    if (left >= right) return;\n\n    int root = preorder.buf[preorder.i];\n    int mid = find(inorder.buf, root);\n//    printf(\"  root %d mid %d\\n\", root ,mid);\n//    printf(\"  preorder.i %d %d\\n\", preorder.i, preorder.buf[preorder.i]);\n    preorder.i++;\n    reconstruction(left, mid);\n    reconstruction(mid+1, right);\n    postorder.buf[postorder.i++] = inorder.buf[mid];\n//    printf(\"  postorder.i %d %d\\n\", postorder.i ,postorder.buf[postorder.i-1]);\n}\n\nint main() {\n    int n;\n    preorder.i = 0;\n    inorder.i = 0;\n    postorder.i = 0;\n\n    cin >> n;\n\n    for (int i = 0; i < n; i++) {\n        cin >> preorder.buf[i];\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> inorder.buf[i];\n    }\n\n    // input\n    reconstruction(0, n);\n\n    for(int i = 0; i < n-1; i++) {\n        cout << postorder.buf[i] << \" \";\n    }\n    cout << postorder.buf[n-1] << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> pre, in;\nint n;\n\nvoid solve(int l, int r) {\n\tif (r - l == 1) {\n\t\tcout << in[l] << \" \";\n\t}\n\telse {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = l; j < r; j++) {\n\t\t\t\tif (pre[i] == in[j]) {\n\t\t\t\t\tsolve(l, j);\n\t\t\t\t\tsolve(j + 1, r);\n\t\t\t\t\tcout << in[j] << \" \";\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tpre.resize(n);\n\tin.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> pre[i];\t\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> in[i];\n\t}\n\n\tsolve(0, n);\n\tcout << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int,int> P;\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repi(i,a,b) for(int i=int(a);i<(b);i++)\n#define repr(i,b,a) for(int i=int(b);i>=(a);i--)\n#define all(x) x.begin(),x.end()\n\nconst ll mod = 1e9+7;\nconst ll INF = 1e9;\n\ntypedef struct node{\n\tint self,left,right;\n\tnode(){};\n\tnode(int s, int l, int r):self(s),left(l),right(r){};\n}node;\n\nvoid printVector(vector<int> a){\n\trep(i,a.size()) cout<<a[i]+1<<(i==a.size()-1?\"\":\" \");\n\tcout<<endl;\n}\n\nvector<int> preorder, inorder, postorder;\nvector<node> g;\n\nvoid dfs(node x){\n\t// preorder.push_back(x.self);\n\tif(x.left>=0)dfs(g[x.left]);\n\t// inorder.push_back(x.self);\n\tif(x.right>=0)dfs(g[x.right]);\n\tpostorder.push_back(x.self);\n\treturn;\n}\n\nvoid solve(vector<int> pre, vector<int> in){\n\tint parent=pre[0];\n\tint pos=-1;\n\trep(i,in.size())if(in[i]==parent)pos=i;\n\tvector<int> pre_left, pre_right, in_left, in_right;\n\trepi(i,1,pos+1)pre_left.push_back(pre[i]);\n\trepi(i,pos+1,pre.size())pre_right.push_back(pre[i]);\n\trepi(i,0,pos)in_left.push_back(in[i]);\n\trepi(i,pos+1,in.size())in_right.push_back(in[i]);\n\n\tg[parent]=node(parent,(pre_left.size()>0?pre_left[0]:-1),(pre_right.size()>0?pre_right[0]:-1));\n\n\tif(pre_left.size()>0) solve(pre_left, in_left);\n\tif(pre_right.size()>0) solve(pre_right,in_right);\n}\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\tg.resize(n);\n\tpreorder.resize(n);\n\tinorder.resize(n);\n\trep(i,n)cin>>preorder[i],preorder[i]--;;\n\trep(i,n)cin>>inorder[i],inorder[i]--;\n\n\tsolve(preorder,inorder);\n\n\tdfs(g[preorder[0]]);\n\n\tprintVector(postorder);\n\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <iterator>\n#include<algorithm>\nstatic const int NIL = -1;\nstatic const int NumberChild = 2;\nclass Tree {\nprivate:\n\tint id;\n\tint parent;\n\tint child[NumberChild];\n\npublic:\n\tTree() {\n\t\tid = child[0] = child[1] = parent = NIL;\n\t}\n\tvoid AddParent(int ID) {\n\t\tparent = ID;\n\t\treturn;\n\t}\n\tvoid AddID(int ID) {\n\t\tid = ID;\n\t\treturn;\n\t}\n\tvoid AddChild(std::vector<int>&Child) {\n\t\tfor (unsigned int i = 0; i < Child.size(); ++i) {\n\t\t\tchild[i] = Child[i];\n\n\t\t}\n\n\t\treturn;\n\t}\n\tint GetRoot(std::vector<Tree> nodes, int ID) {\n\t\tint RootID = ID;\n\t\tif (RootID != NIL&&nodes[RootID].parent != NIL) {\n\t\t\tRootID = GetRoot(nodes, nodes[RootID].parent);\n\t\t}\n\t\treturn RootID;\n\t}\n\tvoid PreorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid InorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid PostorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t\tif(nodes[ID].id!=NIL)std::cout << \" \" << nodes[ID].id;\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid GetVctorPostorderTreeWalk(std::vector<Tree> nodes, std::vector<int>& returnvector, int ID) {\n\t\t\n\t\tif (ID != NIL) {\n\n\t\t\tGetVctorPostorderTreeWalk(nodes,  returnvector, nodes[ID].child[0]);\n\t\t\tGetVctorPostorderTreeWalk(nodes, returnvector, nodes[ID].child[1]);\n\t\t\tif (nodes[ID].id != NIL)returnvector.push_back(nodes[ID].id) ;\n\t\t}\n\n\t\treturn ;\n\t}\n\tvoid Reconstruct(const std::vector<int>Pre, const std::vector<int>In, std::vector<Tree> &nodes, const int Root, int &cnt) {\n\n\t\tunsigned int m = std::distance(In.begin(), std::find(In.begin(), In.end(), Root));\n\n\t\t//nodes[cnt].AddID(Root);\n\t\tif ( Root == NIL) { return; }\n\t\tnodes[Root].AddID(Root);\n\t\tif ( m ==0 ) { return; }\n\t\tstd::vector<int>PreLeft;\n\n\t\tstd::copy(&Pre[1], &Pre[m] + 1, std::back_inserter(PreLeft));\n\n\n\n\n\t\tstd::vector<int>InLeft;\n\t\tstd::vector<int>PreRight;\n\t\tPreRight={NIL};\n\t\tstd::vector<int> InRight;\n\t\tInRight={NIL};\n\t\tstd::copy(&In[0], &In[m-1]+1, std::back_inserter(InLeft));\n\t\t\n\t\tif (m<Pre.size()-1){\n\t\t\tstd::copy(&Pre[m] + 1, &Pre[Pre.size() - 1] + 1, std::back_inserter(PreRight));\n\t\t}\n\t\tif (m<In.size()-1) {\n\t\t\tstd::copy(&In[m] + 1, &In[In.size() - 1] + 1, std::back_inserter(InRight));\n\t\t\t}\n\t\t\n\t\t\n\t\t\n\n\t\tstd::vector<int> child(2);\n\t\tchild[0] =  PreLeft.empty() ? NIL : PreLeft[0] ;\n\t\tchild[1] = PreRight.empty() ? NIL : PreRight[0] ;\n\t\t//nodes[cnt].AddChild(child);\n\t\tnodes[Root].AddChild(child);\n\t\tfor (unsigned int i = 0; i < child.size(); ++i) {\n\n\t\t\tif (child[i] != NIL) { nodes[child[i]].AddParent(Root); }\n\t\t}\n\t\tReconstruct(PreLeft, InLeft, nodes, PreLeft[0], ++cnt);\n\t\tReconstruct(PreRight, InRight, nodes, PreRight[0], ++cnt);\n\t}\n};\n\nvoid SetVector(std::vector<int>&InputVector) {\n\tfor (unsigned int i = 0; i < InputVector.size(); ++i) {\n\t\tstd::cin >> InputVector[i];\n\t}\n\treturn;\n}\nint main(void) {\n\n\tint n;\n\tstd::cin >> n;\n\tstd::vector<int>Pre(n);\n\tstd::vector<int>In(n);\n\tSetVector(Pre);\n\tSetVector(In);\n\tstd::vector<Tree> nodes(n+1);\n\t//ReconstructWithNoParent\n\tint cnt = 0;\n\tnodes[1].Reconstruct(Pre, In, nodes, Pre[0],cnt);\n\n\t//nodes[1].PostorderTreeWalk(nodes, 1);\n\tstd::vector<int>Print;\n\tnodes[1].GetVctorPostorderTreeWalk(nodes, Print, 1);\n//Print=nodes[1].GetVctorPostorderTreeWalk(nodes, 1);\nfor (unsigned int i = 0; i < Print.size(); ++i) {\n\tif (i) { std::cout << \" \"; }\n\tstd::cout<<Print[i];\n\tif(i==Print.size()-1){ std::cout << std::endl; }\n}\n\t\n\t\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*! if g++ -g alds_1_7_d.cpp -o alds_1_7_d.out; then ./alds_1_7_d.out < alds_1_7_d.test; fi\n */\n\n#include <sstream>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iterator>\n#include <numeric>\n#include <functional>\n#include <climits>\n\n\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\nvector<int> pre(0);\nvector<int> ipre(0);\nvector<int> mid(0);\nvector<int> imid(0);\n\nclass node{\npublic:\n  int id, left, right;\n  node(): id(-1), left(-1), right(-1){}\n};\n\nvector<node> tree(0);\n\nint doit(int pl, int pr, int ml, int mr){\n  if(pl == pr) return -1;\n  int root_id = pre[pl];\n\n  int ml1 = ml;\n  int mr1 = imid[root_id];\n  int ml2 = mr1 + 1;\n  int mr2 = mr;\n\n  int pl1 = pl + 1;\n  int pr1 = pl1 + mr1 - ml1;\n  int pl2 = pr1;\n  int pr2 = pr;\n\n  node& nd = tree[root_id-1];\n  nd.id = root_id;\n  nd.left = doit(pl1, pr1, ml1, mr1);\n  nd.right = doit(pl2, pr2, ml2, mr2);\n  return root_id;\n}\n\nvector<int> ret(0);\n\nvoid post(int root){\n  node& nd = tree[root-1];\n  if(nd.left > 0) post(nd.left);\n  if(nd.right > 0) post(nd.right);\n  ret.push_back(nd.id);\n}\n\nint main(){\n  int n;\n  cin >> n;\n  pre.resize(n);\n  mid.resize(n);\n  ipre.resize(n+1);\n  imid.resize(n+1);\n  tree.resize(n);\n  for (int i = 0; i < n; i++) {\n    cin >> pre[i];\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> mid[i];\n  }\n  for (int i = 0; i < n; i++) {\n    ipre[pre[i]] = i;\n    imid[mid[i]] = i;\n  }\n  int root_id = doit(0, n, 0, n);\n  post(root_id);\n  for (int i = 0; i < n-1; i++) {\n    cout << ret[i] << \" \";\n  }\n  cout << ret.back() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r)\n{\n    if (l >= r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m + 1, r);\n    post.push_back(root);\n}\n\nvoid solve()\n{\n    pos = 0;\n    rec(0, pre.size());\n    for (int i = 0; i < n; i++) {\n        if (i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\n\nint main(int argc, char const *argv[])\n{\n    int k;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> k;\n        pre.push_back(k);\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> k;\n        in.push_back(k);\n    }\n\n    solve();\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> pre, in;\nint n;\n\nvoid solve(int l, int r) {\n\tif (r - l == 1) {\n\t\tcout << in[l] << \" \";\n\t}\n\telse {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = l; j < r; j++) {\n\t\t\t\tif (pre[i] == in[j]) {\n\t\t\t\t\tsolve(l, j);\n\t\t\t\t\tsolve(j + 1, r);\n\t\t\t\t\tcout << in[j] << \" \";\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tpre.resize(n);\n\tin.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> pre[i];\t\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> in[i];\n\t}\n\n\tsolve(0, n);\n\tcout << \"\\b\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<int> pre, in, post;\nint position = 0;\n\nvoid reconstruction(int left, int right) {\n  if (left >= right) return;\n  int root = pre[position];\n  position++;\n  int in_pos = distance(in.begin(), find(in.begin(), in.end(), root));\n  reconstruction(left, in_pos);\n  reconstruction(in_pos + 1, right);\n  post.push_back(root);\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n\n  int id;\n  for (int i = 0; i < n; i++) {\n    cin >> id;\n    pre.push_back(id);\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> id;\n    in.push_back(id);\n  }\n\n  reconstruction(0, n);\n\n  for (int i = 0; i < n; i++) {\n    if (i != 0) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\nusing namespace std;\n\n\nvoid solve(int *preorder, int *inorder, int *root_pos, int left, int right, int total_num);\nint get_left_child(int *inorder, int root_id, int num);\n\nvector<int> result;\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tint* preorder = (int*)malloc((n+1) * sizeof(int));\n\tint* inorder  = (int*)malloc((n+1) * sizeof(int));\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%d\", &preorder[i]);\n\t}\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%d\", &inorder[i]);\n\t}\n\tint* root  = (int*)calloc(1, sizeof(int));\n\tsolve(preorder, inorder, root, 0, n, n);\n\tfor(int i = 0; i < n; ++i){\n\t\tif(i) putchar(' ');\n\t\tprintf(\"%d\", result[i]);\n\t}\n\n\tputchar('\\n');\n\treturn 0;\n}\nvoid solve(int *preorder, int *inorder, int *root_pos, int left, int right, int total_num){\n\tif(left >= right) return;\n\tint root_id = preorder[*root_pos];\n\tint mid = get_left_child(inorder, root_id, total_num);\n\t(*root_pos)++;\n\tsolve(preorder, inorder, root_pos, left, mid,  total_num);\n\tsolve(preorder, inorder, root_pos, mid+1, right, total_num);\n\tresult.push_back(root_id);\n}\n\nint get_left_child(int *inorder, int root_id, int num){\n\tint left_num = -1;\n\tfor(int i = 0; i < num; ++i){\n\t\tif(inorder[i] == root_id){\n\t\t\tleft_num = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn left_num;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) \n{\n\tif (l == r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\nvoid solve() {\n\tpos = 0;\n\trec(0, pre.size());\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (i) cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tint k;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) \n\t{\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\n\tfor (int i = 0; i < n; i++) \n\t{\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\nusing namespace std;\n\nvector<int> ans;\nint pre[40];\nint in[40];\nint N;\n\nstruct Node {\n\tint left;\n\tint right;\n};\n\nvoid solve(int begin, int end, int& j) {\n\tint mid;\n\tfor (int i = begin; i < end; i++) {\n\t\tif (in[i] == pre[j]) {\n\t\t\tmid = i;\n\t\t}\n\t}\n\n\tif(begin != mid)solve(begin, mid, ++j);\n\tif(mid + 1 != end)solve(mid + 1, end, ++j);\n\tans.push_back(in[mid]);\n}\n\nint main() {\n\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> pre[i];\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> in[i];\n\t}\n\n\tint j = 0;\n\tsolve(0, N, j);\n\t\n\tfor (int i = 0; i < N; i++) {\n\t\tcout << ans[i];\n\t\tif (i < N - 1)cout << \" \";\n\t}\n\tcout << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n  \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n  \nusing namespace std;\n  \ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n  \nconst int INF=1<<29;\nconst double EPS=1e-9;\n  \nconst int dx[]={1,0,-1,0,1,1,-1,-1},dy[]={0,-1,0,1,1,-1,-1,1};\n\nint N;\nstd::vector<vector<int> > G;\n\nint postcount = 0;\nint nowpoint = 0;\nstd::vector<int> in;\nstd::vector<int> mid;\n\nvoid postorder(int i) {\n    if (G[i][0] != -1) postorder(G[i][0]);\n    if (G[i][1] != -1) postorder(G[i][1]);\n    cout << i + 1;\n    postcount++;\n    if (postcount != N) {\n        cout << \" \";\n    }\n}\n\n\nint dfs(int l, int r) {\n    if (l == r) {\n        return -1;\n    }\n    //cout << \"l : \" << l << \", r : \" << r << endl;\n    int now = in[nowpoint++];\n\n    int j = 0;\n    for (int i = l; i < r; i++) {\n        if (now == mid[i]) {\n            j = i;\n            break;\n        }\n    }\n    //cout << \" j : \" << j << endl;\n    G[now][0] = dfs(l, j);\n    G[now][1] = dfs(j + 1, r);\n    return now;\n}\n\nint main() {\n\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        int temp;\n        cin >> temp;\n        temp--;\n        in.push_back(temp);\n    }\n\n    for (int i = 0; i < N; i++) {\n        int temp;\n        cin >> temp;\n        temp--;\n        mid.push_back(temp);\n        G.push_back(vector<int>(2));\n    }\n\n    postorder(dfs(0, N));\n    cout << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nvoid rec(vector<int> &pre, vector<int> &in, int *posIndex, int l, int r)\n{\n    if (l >= r)\n    {\n        return;\n    }\n\n    int root = pre[*posIndex];\n    *posIndex = *posIndex + 1;\n\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n\n    rec(pre, in, posIndex, l, m);\n    rec(pre, in, posIndex, m+1, r);\n\n    cout << root << \" \";\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n\n    vector<int> pre(N);\n    vector<int> in(N);\n\n    for (int i = 0; i < N; i++)\n    {\n        cin >> pre[i];\n    }\n\n    for (int i = 0; i < N; i++)\n    {\n        cin >> in[i];\n    }\n\n/*\n    for (int i = 0; i < N; i++)\n    {\n        cout << pre[i];\n    }\n*/\n    int *pos = new int;\n    *pos = 0;\n\n    rec(pre, in, pos, 0, pre.size());\n    //cout << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i) \n#define PI acos(-1)\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nvoid reconstruct(vector<int> preorder, vector<int> inorder, vector<int>& postorder) {\n    if (preorder.size() == 0) return;\n    if (preorder.size() == 1) {\n        postorder.push_back(preorder[0]);\n        return;\n    }\n\n    int root = preorder[0];\n    int left = distance(inorder.begin(), find(inorder.begin(), inorder.end(), root));\n    reconstruct(vector<int>(preorder.begin() + 1, preorder.begin() + left + 1),\n                vector<int>(inorder.begin(), inorder.begin() + left),\n                postorder);\n    reconstruct(vector<int>(preorder.begin() + left + 1, preorder.end()),\n                vector<int>(inorder.begin() + left + 1, inorder.end()),\n                postorder);\n    postorder.push_back(root);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin>>n;\n    vector<int> preorder(n), inorder(n), postorder;\n    rep(i, n) cin>>preorder[i];\n    rep(i, n) cin>>inorder[i];\n    reconstruct(preorder, inorder, postorder);\n    rep(i, n - 1) cout<<postorder[i]<<\" \";\n    cout<<postorder[n - 1]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n\tif(l >= r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m+1, r);\n\tpost.push_back(root);\n}\n\nvoid solve() {\n\tpos = 0;\n\trec(0, pre.size());\n\tfor(int i = 0; i < n; i++) {\n\t\tif(i) cout << \" \";\n\t\tcout << post[i]; \n\t}\n\tcout << endl;\n}\n\nint main() {\n\tint k;\n\tcin >> n;\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\t\n\tsolve();\n    \n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MOD = 1e9+7,MAX = 1e5;\n\nvector<int> P(100),I(100);\nint h;\nint poiu;\nvoid res(int l,int r)\n{\n\tif(l>=r)return;\n\tint c = P[h++];\n\tint m = -1;\n\tfor(int i =0;i<r;i++)\n\t{\n\t\tif(I[i]==c)\n\t\t{\n\t\t\tm = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cout<<m<<endl;\n\t//if(m==-1)return;\n\tres(l,m);\n\tres(m+1,r);\n\tif(poiu++)cout<<' ';\n\tcout<<c;\n\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\t\n\tfor(int i =0;i<n;i++)cin >> P[i];\n\tfor(int i =0;i<n;i++)cin >> I[i];\n\tres(0,n);cout<<endl;\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n\tif(l >= r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m+1, r);\n\tpost.push_back(root);\n}\n\nvoid solve() {\n\tpos = 0;\n\trec(0, pre.size());\n\tfor(int i = 0; i < n; i++) {\n\t\tif(i) cout << \" \";\n\t\tcout << post[i]; \n\t}\n\tcout << endl;\n}\n\nint main() {\n\tint k;\n\tcin >> ;\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\t\n\tsolve();\n    \n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint pos = 0;\nvector<int> ans;\n\nvoid reconstruction(vector<int> &pre, vector<int> &in, int left, int right)\n{\n    // cout << \"left = \" << left << \", right = \" << right << endl;\n    if (left >= right)\n    {\n        return;\n    }\n\n    int next_root = pre[pos++];\n    auto ite = find(in.begin(), in.end(), next_root);\n    if (ite == in.end())\n    {\n        return;\n    }\n    int next_root_idx = ite - in.begin();\n\n    reconstruction(pre, in, left, next_root_idx);\n    reconstruction(pre, in, next_root_idx + 1, right);\n\n    // cout << next_root << endl;\n    ans.push_back(next_root);\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n\n    vector<int> pre_order(n);\n    vector<int> in_order(n);\n    for (int i = 0; i < n; i++)\n    {\n        cin >> pre_order[i];\n    }\n    for (int i = 0; i < n; i++)\n    {\n        cin >> in_order[i];\n    }\n\n    reconstruction(pre_order, in_order, 0, n);\n\n    for (int i = 0; i < n; i++)\n    {\n        cout << ans[i];\n        if (i < n - 1)\n        {\n            cout << \" \";\n        }\n    }\n    cout << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;\ntypedef vector<ld> vd;\ntypedef vector<ll> vll;\ntypedef vector<string> vstr;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<pair<ll, ll>> vpll;\ntypedef priority_queue<ll, vector<ll>, greater<ll>> spqll;  // 小さい順に取り出し\ntypedef priority_queue<ll, vector<ll>, less<ll>> bpqll;     // 大きい順に取り出し\n\n#define REP(i, n) for (ll i = 0; i < (ll)(n); i++)\n#define FOR(i, a, b) for (ll i = (ll)a; i < (ll)b; i++)\n#define IREP(i, v) for (auto i = (v).begin(); i != (v).end(); i++)\n#define FI first\n#define SE second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define TS to_string\n#define NP next_permutation\n#define ALL(v) (v).begin(), (v).end()\n#define SZ(x) (ll) x.size()\n#define SP(x) setprecision((ll)x)\n\n\nll INF = 1e9;\nll NIL = -1;\nll MOD = 1000000007;\nll LINF = 1e18;\nld EPS = 1e-9;\nld PI = M_PI;\nvll dx = {1, 0, -1, 0, 1, -1, -1, 1};\nvll dy = {0, 1, 0, -1, 1, 1, -1, -1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a;} //最大公約数\nll lcm(ll a, ll b) { return a / gcd(a, b) * b;}     //最小公倍数\n\nvoid yes(){ cout << \"yes\" << endl;}\nvoid no(){ cout << \"no\" << endl;}\n\n//-----------------------------------------\nint a[100 + 10];\nint b[100 + 10];\n\n\nstruct Node{\n  int par, rig, lef;\n};\n\nNode T[100];\n\nint par(int i){\n  return T[i].par;\n}\nint sib(int i){\n  int p = T[i].par;\n  if(p == NIL) return NIL;\n  Node t = T[p];\n  if(t.lef == i) return t.rig;\n  return t.lef;\n}\nint deg(int i){\n  int res = 0;\n  if(T[i].lef != NIL) res++;\n  if(T[i].rig != NIL) res++;\n  return res;\n}\nint dep(int i){\n  int p = T[i].par;\n  if(p == NIL) return 0;\n  return dep(p) + 1;\n}\nint hei(int i){\n  if(i == NIL) return -1;\n  Node t = T[i];\n  return max(hei(t.lef),hei(t.rig)) + 1;\n}\nstring tag(int i){\n  if(T[i].par == NIL) return \"root\";\n  if(T[i].lef == NIL && T[i].rig == NIL) return \"leaf\";\n  return \"internal node\";\n}\nvoid print(int i){\n  cout << \"node \" << i <<\":\";\n  cout << \" parent = \" << par(i) << \",\";\n  cout << \" sibling = \" << sib(i) << \",\";\n  cout << \" degree = \" << deg(i) << \",\";\n  cout << \" depth = \" << dep(i) << \",\";\n  cout << \" height = \" << hei(i) << \", \";\n  cout << tag(i) <<endl;\n}\nvoid prepri(int i){\n  cout << \" \" << i;\n  if(T[i].lef != NIL) prepri(T[i].lef);\n  if(T[i].rig != NIL) prepri(T[i].rig);\n}\nvoid inpri(int i){\n  if(T[i].lef != NIL) inpri(T[i].lef);\n  cout << \" \" << i;\n  if(T[i].rig != NIL) inpri(T[i].rig);\n}\nvoid pospri(int i){\n  if(T[i].lef != NIL) pospri(T[i].lef);\n  if(T[i].rig != NIL) pospri(T[i].rig);\n  cout << i+1 ;\n  if(tag(i)!=\"root\") cout << \" \";\n}\n\nint n;\nint make(int *A,int m){\n  if(m == 0) return NIL; \n  if(m == 1) return A[0];\n\n  int mini = INF;\n  int tmp = INF;\n  int len = 100;\n  for(int i=0;i<m;i++){\n    if(a[A[i]]<tmp){\n      tmp = a[A[i]];\n      mini = A[i];\n      len = i;\n    }\n  }\n\n  int l = make(A,len);\n  int r = make(A+(len+1),m-len-1);\n  if(r != NIL){\n    T[r].par = mini;\n    T[mini].rig = r;\n  }\n  if(l != NIL){\n    T[l].par = mini;\n    T[mini].lef = l;\n  }\n  return mini;\n}\n\n//-----------------------------------------\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> n;\n  for(int i=0;i<=n;i++){\n    T[i].par = NIL;\n    T[i].lef = NIL;\n    T[i].rig = NIL;\n  }\n\n  REP(i,n){\n    int k;\n    cin >> k;\n    a[k-1] = i;\n  }\n  REP(i,n){\n    cin >> b[i];\n    b[i]--;\n  }\n\n  make(b,n);\n\n  for(int i=0;i<n;i++){\n    if(tag(i)==\"root\"){\n      pospri(i);\n      cout << endl;\n    }\n  }\n\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nvoid postorder(vector<int>& pre, vector<int>& in, vector<int>& ret){\n    if(in.size() <= 1){\n        for(auto it = in.begin(); it != in.end(); ++it){\n            ret.push_back(*it);\n        }\n        return;\n    }\n    int root = pre[0];\n    int ln = find(in.begin(), in.end(), root) - in.begin();\n\n    vector<int> pre_left {};\n    pre_left.insert(pre_left.begin(), pre.begin()+1, pre.begin()+ln+1);\n    vector<int>in_left {};\n    in_left.insert(in_left.begin(), in.begin(), in.begin()+ln);\n\n    vector<int> pre_right {};\n    pre_right.insert(pre_right.begin(), pre.begin()+ln+1, pre.end());\n    vector<int> in_right {};\n    in_right.insert(in_right.begin(), in.begin()+ln+1, in.end());\n\n    vector<int> pre_mid {root};\n    vector<int> in_mid {root};\n\n    postorder(pre_left, in_left, ret);\n    postorder(pre_right, in_right, ret);\n    postorder(pre_mid, in_mid, ret);\n}\nint main(){\n    int n;\n    cin >> n;\n    vector<int> pre {};\n    vector<int> in {};\n    for(int i = 0; i < n; ++i){\n        int temp;\n        cin >> temp;\n        pre.push_back(temp);\n    }\n    for(int i = 0; i < n; ++i){\n        int temp;\n        cin >> temp;\n        in.push_back(temp);\n    }\n    vector<int> post {};\n    postorder(pre, in, post);\n    for(auto it = post.begin(); it != post.end(); ++it){\n        if(it == post.begin()){\n            cout << *it;\n        } else {\n            cout << \" \" << *it;\n        }\n    }\n    cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// C++ 14\n#include <bits/stdc++.h>\n#include <iostream>\n#include <vector>\n#include <array>\n#include <list>\n#include <algorithm>\n#include <queue>\n#include <stack>\n\n#define ll long long\n#define loop(x, start, end) for(ll x = start; x < end; x++)\n\nusing namespace std;\n\nint n, pos;\nvector<int> in, pre, post;\n    \n\nvoid rec(int l, int r) {\n    if (l >= r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m + 1, r);\n    post.push_back(root);\n}\n\nvoid solve() {\n    pos = 0;\n    rec(0, pre.size());\n    int i;\n    loop(i, 0, n) {\n        if (i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\n\nint main(void) {\n    int x;\n    cin >> n;\n    loop(i, 0, n) {\n        cin >> x;\n        pre.push_back(x);\n    }\n    \n    loop(i, 0, n) {\n        cin >> x;\n        in.push_back(x);\n    }\n    \n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include        <bits/stdc++.h>\nusing   namespace       std;\n\n#define Rep0(i, n)      for (int i=0; i<n; i++)\n#define Rep1(i, n)      for (int i=1; i<=n; i++)\n#define Sort(P) sort(P.begin(), P.end())\n\nvoid    F(const vector<int> &A, const int &ia, const int &l, const vector<int> &B, const int &ib, vector<int> &C) {\n        if (1==l) {\n                C.push_back(A.at(ia));\n                return;\n        }\n        int K=A.at(ia);\n        int ibK=ib;\n        while (K!=B.at(ibK))\n                ibK++;\n        int ll=ibK-ib;\n        if (ll>0)\n                F(A, ia+1, ll, B, ib, C);\n        if (l-ll-1>0)\n                F(A, ia+ll+1, l-ll-1, B, ib+ll+1, C);\n        C.push_back(K);\n        return;\n}\n\nint     main() {\n        int n;\n        cin >>n;\n        vector<int> A(n, 0);\n        vector<int> B(n, 0);\n        Rep0(i, n)\n                cin >>A.at(i);\n        Rep0(i, n)\n                cin >>B.at(i);\n        vector<int> C;\n        F(A, 0, n, B, 0, C);\n        Rep0(i, n)\n                if (i<n-1)\n                        cout <<C.at(i) <<' ';\n                else\n                        cout <<C.at(i) <<endl;\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define eol '\\n';\nusing namespace std;\n\nclass Node {\npublic:\n  int id;\n  int l;\n  int r;\n  int p;\n  Node(): id(-1),l(-1),r(-1),p(-1){};\n};\n\nNode* tree;\n\nint create_tree(int parent, vector<int> pre, vector<int> in) {\n    if (pre.size() == 0 && in.size() == 0) {\n      return -1;\n    }\n\n    int root_id = pre[0];\n\n    Node* node = &tree[root_id];\n    node->p = parent;\n    \n    // left\n    vector<int> left_pre;\n    vector<int> left_in;\n\n    int i = 0;\n    int size = in.size();\n    for (; i < size; i++) {\n      if (in[i] == root_id) {\n        break;\n      }\n      left_pre.push_back(pre[i+1]);\n      left_in.push_back(in[i]);\n    }\n    if (left_pre.size()) {\n      node->l = create_tree(root_id, left_pre, left_in);\n    }\n\n    vector<int> right_pre;\n    vector<int> right_in;\n\n    i++;\n    for (;i < size; i++) {\n      right_pre.push_back(pre[i]);\n      right_in.push_back(in[i]);\n    }\n    if (right_pre.size()) {\n      node->r = create_tree(root_id, right_pre, right_in);\n    }\n\n    return root_id;\n}\n\nvector<int> postorder(int id, vector<int> post) {\n  Node* node = &tree[id];\n  if (node->l != -1) {\n    post = postorder(node->l, post);\n  }\n  if (node->r != -1) {\n    post = postorder(node->r, post);\n  }\n  post.push_back(id);\n\n  return post;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  \n  int n,i;\n  cin >> n;\n\n  tree = new Node[n];\n\n  vector<int> preorder(n);\n  vector<int> inorder(n);\n\n  for (i = 0; i < n; i++) {\n    cin >> preorder[i];\n  }\n  for (i = 0; i < n; i++) {\n    cin >> inorder[i];\n  }\n\n  int root = create_tree(-1, preorder, inorder);\n\n  // post order\n  vector<int> post;\n  post = postorder(root, post);\n\n  // output\n  cout << post[0];\n  for (i = 1; i < n; i++) {\n    cout << \" \" << post[i];\n  }\n  cout << eol;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define N 42\nint n;\nint a[N];\nint b[N];\nint c[N];\nint ai = 1;\nint ci = 1;\nint used[N];\nvoid rebuild(int left, int right){\n    if(left == right) {\n//        printf(\"%d \", b[left]);\n        c[ci++] = b[left];\n        used[b[left]] = 1;\n         return ;\n    }\n//    int ax = a[ai++];\n    int ax;\n    if(used[a[ai]] == 0){\n        ax = a[ai++];\n    }\n    else{\n        while(used[a[ai]] != 0){\n            ai++;\n        }\n        ax = a[ai++];\n    }\n    int m = 1;\n    for(int i = 1; i <= n; i++){\n        if(b[i] == ax) {\n            m = i;\n            break;\n        }\n    }\n    if(m - 1 >= left) rebuild(left, m-1);\n    if(m + 1 <= right) rebuild(m+1, right);\n//    printf(\"%d \", ax);\n    c[ci++] = ax;\n    used[ax] = 1;\n    return ;\n}\nint main(){\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    for(int i = 1; i <= n; i++) scanf(\"%d\", &b[i]);\n    for(int i = 1; i <= n; i++) used[i] = 0;\n    rebuild(1, n);\n    for(int i = 1; i <= n; i++){\n        if(i == n) printf(\"%d\\n\", c[i]);\n        else printf(\"%d \", c[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <array>\n#include <memory>\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cmath>\n#include <unordered_map>\n#include <stdexcept>\n\n\nusing std::string;\nusing std::vector;\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// util\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nstd::vector<std::string> split(const std::string& input, char delimiter)\n{\n    std::istringstream stream(input);\n\n    std::string field;\n    std::vector<std::string> result;\n    while (std::getline(stream, field, delimiter)) {\n        result.push_back(field);\n    }\n    return result;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// user func\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nvoid printList(const vector<int>& list) {\n    // print\n    for(int i = 0; i < list.size(); i++){\n        printf(\"%d\", list[i]);\n        if(i != list.size() -1){\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// logic\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nclass Node;\nusing Container = std::map<int, std::shared_ptr<Node>>;\nclass Node{\nprivate:\n    Container *container;\n    int id;\n    int left;\n    int right;\n    int parentId;\npublic:\n    Node(Container* container, int id, int left, int right)\n        : container(container)\n        , id(id)\n        , left(left)\n        , right(right)\n        , parentId(-1)\n    {\n    }\n\n    int Id(){\n        return this->id;\n    }\n    int Left(){\n        return this->left;\n    }\n    int Right(){\n        return this->right;\n    }\n\n    void ParentId(int id){\n        this->parentId = id;\n    }\n\n    int ParentId(){\n        return this->parentId;\n    }\n\n    int Sibling(){\n        // root\n        if (this->parentId == -1) return -1;\n        if (this->Parent()->Left() == this->id) {\n            return this->Parent()->Right();\n        } else {\n            return this->Parent()->Left();\n        }\n    }\n\n    int Degree(){\n        int result = this->left == -1 ? 0 : 1;\n        result   += this->right == -1 ? 0 : 1;\n        return result;\n    }\n\n    int Depth(){\n        if(this->parentId == -1){\n            return 0;\n        }else{\n            return this->Parent()->Depth() + 1;\n        }\n    }\n\n    int Height(){\n        if(this->left + this->right == -2) return 0;\n        int lHeight = this->left == -1 ? 0 : (*this->container)[this->left]->Height();\n        int rHeight = this->right == -1 ? 0 : (*this->container)[this->right]->Height();\n        return std::max(lHeight, rHeight) + 1;\n    }\n\n    string Type(){\n        if(this->parentId == -1)\n        {\n            return \"root\";\n        }\n        if(this->left + this->right == -2)\n        {\n            return \"leaf\";\n        }\n        else\n        {\n            return \"internal node\";\n        }\n    }\n\n    std::shared_ptr<Node> Parent(){\n        if(this->parentId == -1) return nullptr;\n        return (*this->container)[this->parentId];\n    }\n    bool HasLeft(){\n        return this->left != -1;\n    }\n    bool HasRight(){\n        return this->right != -1;\n    }\n    \n};\n\nvoid Preorder(const Container& container, int id){\n    auto cur = container.at(id);\n    printf(\" %d\", cur->Id());\n    if (cur->HasLeft()) Preorder(container, cur->Left());\n    if (cur->HasRight()) Preorder(container, cur->Right());\n}\n\n\nvoid Inorder(const Container& container, int id){\n    auto cur = container.at(id);\n    if(!cur->HasLeft() && !cur->HasRight()){\n        printf(\" %d\", cur->Id());\n        return;\n    }\n    if (cur->HasLeft()) Inorder(container, cur->Left());\n    printf(\" %d\", cur->Id());\n    if (cur->HasRight()) Inorder(container, cur->Right());\n}\n\nvoid StackPostorder(vector<int>& stack, const Container& container, int id){\n    auto cur = container.at(id);\n    if(!cur->HasLeft() && !cur->HasRight()){\n        stack.push_back(cur->Id());\n        return;\n    }\n    if (cur->HasLeft()){\n        StackPostorder(stack, container, cur->Left());\n    }\n    if (cur->HasRight()) {\n        StackPostorder(stack, container, cur->Right());\n    }\n    stack.push_back(cur->Id());\n}\n\nint FindRoot(const Container& container){\n    for(auto each: container){\n        if(each.second->ParentId() == -1){\n            return each.first;\n        }\n    }\n    return -1;\n}\n\n// return left , rite\n// input parent ( and each list)\n// sepalate left and right\n// find highest node\n// return\n\n// 結局ツリーを作るしかないかな\n// pre 範囲を決める？\n// pre 範囲の中で一番先に出てくるのが親\n// 再帰で子を受け取る\n// リストを作る\n// in 範囲の中で親を起点に分割\n// 戻る？\n\n// 面倒なので static\nstatic Container container;\n\nint FindFirstValue(const vector<int>& p, const vector<int>& s){\n    for(int i = 0; i < p.size(); i++){\n        for(auto needle: s){\n            if(needle == p[i]) return needle;\n        }\n    }\n    // printf(\"Error\\n\");\n    return -1;\n}\n\ntypedef struct _siblings{\n    int Left;\n    int Right;\n} Siblings;\n\nSiblings GetChild(const vector<int>& preorder, const vector<int>& inorder, int parent, int begin, int end){\n    // printf(\"begin: %d, end: %d, parent: %d\\n\", begin, end, parent);\n    if(end == begin) {\n        return { -1, -1 };\n    }\n\n    // index in inorder\n    int p = -1;\n    for(int i = 0; i < inorder.size(); i++){\n        if (parent == inorder[i]) {\n            p = i;\n            break;\n        }\n    }\n    // left, right\n    int leftId = -1;\n    int rightId = -1;\n    vector<int> left;\n    for(int i = begin; i < p; i++){\n        left.push_back(inorder[i]);\n    }\n    vector<int> right;\n    for(int i = p + 1; i <= end; i++){\n        right.push_back(inorder[i]);\n    }\n    leftId = FindFirstValue(preorder, left);\n    rightId = FindFirstValue(preorder, right);\n    // printf(\"left:%d right: %d\\n\", leftId, rightId);\n\n    if (leftId != -1){\n        auto children = GetChild(preorder, inorder, leftId, begin, p - 1);\n        auto child = std::make_shared<Node>(&container, leftId, children.Left, children.Right);\n        child->ParentId(parent);\n        container.insert(std::make_pair(leftId, child));\n    } \n    if (rightId != -1){\n        auto children = GetChild(preorder, inorder, rightId, p + 1, end);\n        auto child = std::make_shared<Node>(&container, rightId, children.Left, children.Right);\n        child->ParentId(parent);\n        container.insert(std::make_pair(rightId, child));\n    }\n    return {leftId, rightId};\n}\n\nvoid CreateTree(const vector<int>& preorder, const vector<int>& inorder){\n    int rootId = preorder[0];\n    auto siblings = GetChild(preorder, inorder, rootId, 0, preorder.size() - 1);\n    auto root = std::make_shared<Node>(&container, rootId, siblings.Left, siblings.Right);\n    container.insert(std::make_pair(rootId, root));\n}\n\nvoid solve() {\n    // reconstruction of a tree\n    int n;\n    scanf(\"%d\", &n);\n    vector<int> preorder(n);\n    vector<int> inorder(n);\n    for(int i = 0; i < n; i++){\n        int v;\n        scanf(\"%d\", &v);\n        preorder[i] = v;\n    }\n    for(int i = 0; i < n; i++){\n        int v;\n        scanf(\"%d\", &v);\n        inorder[i] = v;\n    }\n\n    CreateTree(preorder, inorder);\n    vector<int> stack;\n    StackPostorder(stack, container, FindRoot(container));\n    printList(stack);\n    // for(auto each: container){\n    //     printf(\"node %d: parent = %d, sibling = %d, degree = %d, depth = %d, %s [%d, %d]\\n\", \n    //         each.first,\n    //         each.second->ParentId(),\n    //         each.second->Sibling(),\n    //         each.second->Degree(),\n    //         each.second->Depth(),\n    //         each.second->Type().c_str(),\n    //         each.second->Left(), each.second->Right()\n    //     );\n    // }\n\n\n    \n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// main\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nint main() {\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Reconstruction of tree by pre-order and in-order\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\nvoid reconstruction(int, int);\nint n;\nstd::vector<int> in,post;\nstd::queue<int> pre;\nint main(){\n  std::cin>>n;\n  for(int i=0, tmp;i<n;i++) std::cin>>tmp, pre.push(tmp);\n  for(int i=0, tmp;i<n;i++) std::cin>>tmp, in.push_back(tmp);\n  reconstruction(0, n);\n  for(int i=0;i<n;i++){\n    if(i) std::cout<<\" \";\n    std::cout<<post[i];\n  }\n  std::cout<<std::endl;\n  return 0;\n}\nvoid reconstruction(int l, int r){\n  if(l >= r) return;\n  int c;\n  c=pre.front(), pre.pop();\n  int m=distance(in.begin(), find(in.begin(), in.end(),c));\n  reconstruction(l, m), reconstruction(m+1, r);\n  post.push_back(c);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF = 1e9;\n\nstruct Node_t {\n  int id_, left_, right_;\n  Node_t() : id_(-1), left_(-1), right_(-1) {}\n};\n\nNode_t nodes[50];\nint visited[50] = { 0 };\n\nint rec(vector<int> ids, vector<int>& pre, vector<int>& in)\n{\n  if (ids.empty()) { return -1; }\n  int root_id = -1;\n  int n = ids.size(), m = pre.size();\n  for (int i = 0; i < m; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if (ids[j] == pre[i]) {\n        root_id = ids[j];\n        break;\n      }\n    }\n    if (root_id != -1) { break; }\n  }\n  visited[root_id] = 1;\n  vector<int> lsub, rsub;\n  bool left_done = false;\n  for (int i = 0; i < m; ++i) {\n    int id = in[i];\n    if (id == root_id) {\n      left_done = true;\n      continue;\n    }\n    if (visited[id]) { continue; }\n    for (int j = 0; j < n; ++j) {\n      if (id == ids[j]) {\n        if (left_done) { rsub.push_back(id); }\n        else { lsub.push_back(id); }\n        break;\n      }\n    }\n  }\n  nodes[root_id].left_ = rec(lsub, pre, in);\n  nodes[root_id].right_ = rec(rsub, pre, in);\n  return root_id;\n}\n\nvoid postorder(int id, vector<int>& ids)\n{\n  if (id == -1) { return; }\n  postorder(nodes[id].left_, ids);\n  postorder(nodes[id].right_, ids);\n  ids.push_back(id);\n}\n\nint main()\n{\n  int n = 0;\n  fscanf(stdin, \"%d\", &n);\n  vector<int> ids(n), pre(n), in(n);\n  for (int i = 0; i < n; ++i) {\n    fscanf(stdin, \"%d\", &pre[i]);\n    ids[i] = i + 1;\n  }\n  for (int i = 0; i < n; ++i) {\n    fscanf(stdin, \"%d\", &in[i]);\n  }\n  int root_id = rec(ids, pre, in);\n  vector<int> post_ids;\n  postorder(root_id, post_ids);\n  for (int i = 0; i < n; ++i) {\n    if (i) { fprintf(stdout, \" \"); }\n    fprintf(stdout, \"%d\", post_ids[i]);\n  }\n  fprintf(stdout, \"\\n\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<int>pre, in, post;\nint n,pos=0;\n\nvoid rec(int l, int r) {\n\tif (l >= r)return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n\n\n}\n\n\n\nvoid solve()\n{\n\trec(0, pre.size());\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i)cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\n\nint main()\n{\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\tpre.push_back(x);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\tin.push_back(x);\n\t}\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\n#define MAX 10000\n#define NIL -1\n\nstruct Node { int parent, left, right;};\n\nNode T[MAX];\nint n, D[MAX], H[MAX];\n\nvoid setDepth(int u,int d) {\n\tif(u == NIL) return;\n\tD[u] = d;\n\tsetDepth(T[u].left, d+1);\n\tsetDepth(T[u].right,d+1);\n}\n\nint setHeight(int u) {\n\tint h1 = 0, h2 = 0;\n\tif(T[u].left != NIL)\n\t\th1 = setHeight(T[u].left)  + 1;\n\tif(T[u].right != NIL)\n\t\th2 = setHeight(T[u].right) + 1;\n\treturn H[u] = (h1 > h2 ? h1 : h2);\n}\n\n// 接点 u の兄弟を返す\nint getSibling(int u) {\n\tif( T[u].parent == NIL ) return NIL;\n\tif(T[T[u].parent].left != u && T[T[u].parent].left != NIL )\n\t\treturn T[T[u].parent].left;\n\tif(T[T[u].parent].right != u && T[T[u].parent].right != NIL )\n\t\treturn T[T[u].parent].right;\n\treturn NIL;\n}\n\nvoid print(int u) {\n\tprintf(\"node %d: \",u);\n\tprintf(\"parent = %d, \",T[u].parent);\n\tprintf(\"sibling = %d, \",getSibling(u));\n\tint deg = 0;\n\tif(T[u].left  != NIL) deg++;\n\tif(T[u].right != NIL) deg++;\n\tprintf(\"degree = %d, \",deg);\n\tprintf(\"depth = %d, \",D[u]);\n\tprintf(\"height = %d, \",H[u]);\n\t\n\tif(T[u].parent == NIL) {\n\t\tprintf(\"root\\n\");\n\t} else if(T[u].left == NIL && T[u].right == NIL) {\n\t\tprintf(\"leaf\\n\");\n\t} else {\n\t\tprintf(\"internal node\\n\");\n\t}\n}\n\nint main(void) {\n\tint v, l, r, root = 0;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) T[i].parent = NIL;\n\tfor(int i=0;i<n;i++) {\n\t\tscanf(\"%d %d %d\",&v,&l,&r);\n\t\tT[v].left  = l;\n\t\tT[v].right = r;\n\t\tif(l != NIL) T[l].parent = v;\n\t\tif(r != NIL) T[r].parent = v;\n\t}\n\t\n\tfor(int i=0; i<n; i++)\n\tif(T[i].parent == NIL) root = i;\n\t\n\tsetDepth(root,0);\n\tsetHeight(root);\n\t\n\tfor(int i=0;i<n;i++) print(i);\n\t\n\treturn 0;\n}\n\n/*\n9\n0 1 4\n1 2 3\n2 -1 -1\n3 -1 -1\n4 5 8\n5 6 7\n6 -1 -1\n7 -1 -1\n8 -1 -1\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\nvector <int> pre, in, ans;\n\nvoid rec(int lp, int rp, int li, int ri) {\n    int root = pre[lp];\n    int i = 0;\n    while(in[li+i] != root) i++;\n    if (i != 0) rec(lp+1, lp+i, li, li+i-1);\n    if (li + i != ri) rec(lp+i+1, rp, li+i+1, ri);\n\n    ans.pb(root);\n}\n\nvoid solve(void){\n    int N;\n    cin >> N;\n    pre.resize(N), in.resize(N);\n    rep(N, i) cin >> pre[i];\n    rep(N, i) cin >> in[i];\n    rec(0, N-1, 0, N-1);\n    for (int v : ans) {\n        printf(\"%d \", v);\n    }\n    cout << endl;\n}\n\nint main(void){\n  solve();\n  //cout << \"yui(*-v・)yui\" << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint Index;\nint PostOrderStr[40];\n\nvoid getOrderInfo(int *p, int n) {\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> p[i];\n\t}\n}\n\nvoid solve(int *preOrder, int *inOrder, int len) {\n\tint curRootPos;\n\n\tif (len == 0) {\n\t\treturn;\n\t}\n\tcurRootPos = find(inOrder, inOrder + 40, *preOrder) - inOrder;\n\t//left\n\tsolve(preOrder + 1, inOrder, curRootPos);\n\t//right\n\tsolve(preOrder + curRootPos + 1, inOrder + curRootPos + 1, len - curRootPos - 1);\n\t\n\tPostOrderStr[Index++] = *preOrder;\n}\n\nint main() {\n\tint n;\n\tint preorderStr[40], inorderStr[40];\n\n\tIndex = 0;\n\tmemset(preorderStr, 0, sizeof(preorderStr));\n\tmemset(inorderStr, 0, sizeof(inorderStr));\n\tmemset(PostOrderStr, 0, sizeof(PostOrderStr));\n\tcin >> n;\n\tgetOrderInfo(preorderStr, n);\n\tgetOrderInfo(inorderStr, n);\n\tsolve(preorderStr, inorderStr, n);\n\n\tcout << PostOrderStr[0];\n\tfor (int i = 1; i < n; ++i) {\n\t\tcout << \" \" << PostOrderStr[i];\n\t}\n\tcout << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define eol '\\n';\nusing namespace std;\n\nclass Node {\npublic:\n  int id;\n  int l;\n  int r;\n  int p;\n  Node(): id(-1),l(-1),r(-1),p(-1){};\n};\n\nNode* tree;\n\nint create_tree(int parent, vector<int> pre, vector<int> in) {\n    if (pre.size() == 0 && in.size() == 0) {\n      return -1;\n    }\n\n    int root_id = pre[0];\n\n    Node* node = &tree[root_id];\n    node->p = parent;\n/*    \n    // left\n    vector<int> left_pre;\n    vector<int> left_in;\n\n    int i = 0;\n    int size = in.size();\n    for (; i < size; i++) {\n      if (in[i] == root_id) {\n        break;\n      }\n      left_pre.push_back(pre[i+1]);\n      left_in.push_back(in[i]);\n    }\n    node->l = create_tree(root_id, left_pre, left_in);\n\n    vector<int> right_pre;\n    vector<int> right_in;\n\n    i++;\n    for (;i < size; i++) {\n      right_pre.push_back(pre[i]);\n      right_in.push_back(in[i]);\n    }\n    node->r = create_tree(root_id, right_pre, right_in);\n*/\n    return root_id;\n}\n\nvector<int> postorder(int id, vector<int> post) {\n  Node* node = &tree[id];\n  if (node->l != -1) {\n    post = postorder(node->l, post);\n  }\n  if (node->r != -1) {\n    post = postorder(node->r, post);\n  }\n  post.push_back(id);\n\n  return post;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  \n  int n,i;\n  cin >> n;\n\n  tree = new Node[n];\n\n  vector<int> preorder(n);\n  vector<int> inorder(n);\n\n  for (i = 0; i < n; i++) {\n    cin >> preorder[i];\n  }\n  for (i = 0; i < n; i++) {\n    cin >> inorder[i];\n  }\n\n  int root = create_tree(-1, preorder, inorder);\n\n  // post order\n  vector<int> post;\n  post = postorder(root, post);\n\n  // output\n  cout << post[0];\n  for (i = 1; i < n; i++) {\n    cout << \" \" << post[i];\n  }\n  cout << eol;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> pre, in, pos;\nint p=0;\n\nvoid rec(int l, int r){\n   if(l>=r){\n      pos.push_back(in[l]);\n      return;\n   }\n   int root=pre[p++];\n   int m=distance(in.begin(), find(in.begin(), in.end(), root));\n   rec(l, m-1);\n   rec(m+1, r);\n   pos.push_back(in[m]);\n}\n\nint main(){\n   int n, num;\n   cin >> n;\n   for(int i=0; i<n; i++){\n      cin >> num;\n      pre.push_back(num);\n   }\n   for(int i=0; i<n; i++){\n      cin >> num;\n      in.push_back(num);\n   }\n\n   rec(0, n-1);\n\n   for(int i=0; i<n; i++){\n      if(i) cout << \" \";\n      cout << pos[i];\n   }\n   cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,pos;\nvector< int > pre,in,post;\nvoid rec(int l,int r){\n    if(l>=r) return;\n    int root=pre[pos++];\n    int p=0; while(in[p]!=root) p++;\n    rec(l,p);\n    rec(p+1,r);\n    post.push_back(root);\n}\nint main(){\n    scanf(\"%d\",&n);\n    int temp;\n    for(int i=0;i<n;++i){\n        scanf(\"%d\",&temp);\n        pre.push_back(temp);\n    }\n    for(int i=0;i<n;++i){\n        scanf(\"%d\",&temp);\n        in.push_back(temp);\n    }\n    pos=0;\n    rec(0,n);\n    printf(\"%d\",post[0]);\n    for(int i=1;i<n;++i){\n        printf(\" %d\",post[i]);\n    }\n    putchar('\\n');\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct It{int it;const bool rev;explicit constexpr It(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(It& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const It i,n;public:explicit constexpr in(int n):i(0),n(n<0?0:n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const It& begin(){return i;}const It& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<int> pre(n), ino(n);\n    for(int& x : pre) cin >> x, --x;\n    for(int& x : ino) cin >> x, --x;\n    vector<int> find(n, 0);\n    for(int i : in(n)) find[ino[i]] = i;\n    vector<int> ans;\n    function<void(int, int, int, int)>\n      dfs = [&](int pl, int pr, int il, int ir) { // [pl, pr)\n          if(pl >= pr) return;\n          int root = pre[pl];\n          int mid = find[root];\n          int bound = pl + 1 + mid - il;\n          dfs(pl + 1, bound, il, mid);\n          dfs(bound, pr, mid + 1, ir);\n          ans.emplace_back(root);\n    };\n    dfs(0, n, 0, n);\n    for(int i : in(n))\n      cout << ans[i] + 1 << (i == n - 1 ? '\\n' : ' ');\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,pos,iop;\nvector<int> pre,in,post;\nvoid rec(int l,int r){\n  if(l>=r) return;\n  int root=pre[pos++];\n  int m=distance(in.begin(),find(in.begin(),in.end(),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\nvoid solve(){\n  pos=0;\n  rec(0,pre.size());\n  REP(i,n){\n    if(i) printf(\" \");\n    printf(\"%d\",post[i]);\n  }\n  printf(\"\\n\");\n}\nint main(){\n  int k;\n  scanf(\"%d\",&n);\n  REP(i,n) {scanf(\"%d\",&k);pre.push_back(k);}\n  REP(i,n) {scanf(\"%d\",&k);in.push_back(k);}\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <iterator>\n#include<algorithm>\nstatic const int NIL = -1;\nstatic const int NumberChild = 2;\nclass Tree {\nprivate:\n\tint id;\n\tint parent;\n\tint child[NumberChild];\n\npublic:\n\tTree() {\n\t\tid = child[0] = child[1] = parent = NIL;\n\t}\n\tvoid AddParent(int ID) {\n\t\tparent = ID;\n\t\treturn;\n\t}\n\tvoid AddID(int ID) {\n\t\tid = ID;\n\t\treturn;\n\t}\n\tvoid AddChild(std::vector<int>&Child) {\n\t\tfor (unsigned int i = 0; i < Child.size(); ++i) {\n\t\t\tchild[i] = Child[i];\n\n\t\t}\n\n\t\treturn;\n\t}\n\tint GetRoot(std::vector<Tree> nodes, int ID) {\n\t\tint RootID = ID;\n\t\tif (RootID != NIL&&nodes[RootID].parent != NIL) {\n\t\t\tRootID = GetRoot(nodes, nodes[RootID].parent);\n\t\t}\n\t\treturn RootID;\n\t}\n\tvoid PreorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid InorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid PostorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t\tif (nodes[ID].id != NIL)std::cout << \" \" << nodes[ID].id;\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid GetVctorPostorderTreeWalk(std::vector<Tree> nodes, std::vector<int>& returnvector, int ID) {\n\n\t\tif (ID != NIL) {\n\n\t\t\tGetVctorPostorderTreeWalk(nodes, returnvector, nodes[ID].child[0]);\n\t\t\tGetVctorPostorderTreeWalk(nodes, returnvector, nodes[ID].child[1]);\n\t\t\tif (nodes[ID].id != NIL)returnvector.push_back(nodes[ID].id);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid Reconstruct(std::vector<int>Pre, std::vector<int>In, std::vector<Tree> &nodes, const int Root, int &cnt) {\n\n\t\tunsigned int m = std::distance(In.begin(), std::find(In.begin(), In.end(), Root));\n\n\t\t//nodes[cnt].AddID(Root);\n\t\tif (Root == NIL) { return; }\n\t\tnodes[Root].AddID(Root);\n\n\t\tif (m == 0) {\n\t\t\tstd::vector<int>RestPre;\n\t\t\tRestPre.push_back(NIL);\n\t\t\tif (m < Pre.size() - 1) {\n\t\t\t\tRestPre.pop_back();\n\t\t\t\tstd::copy(&Pre[m] + 1, &Pre[Pre.size() - 1] + 1, std::back_inserter(RestPre));\n\t\t\t}\n\t\t\tstd::vector<int> RestIn;\n\t\t\tRestIn.push_back(NIL);\n\t\t\tif (m < In.size() - 1) {\n\t\t\t\tRestIn.pop_back();\n\t\t\t\tstd::copy(&In[m] + 1, &In[In.size() - 1] + 1, std::back_inserter(RestIn));\n\t\t\t}\n\t\t\tstd::vector<int> child(2);\n\t\t\tchild[0] = NIL;\n\t\t\tchild[1] = RestPre.empty() ? NIL : RestPre[0];\n\t\t\tnodes[Root].AddChild(child);\n\t\t\tfor (unsigned int i = 0; i < child.size(); ++i) {\n\n\t\t\t\tif (child[i] != NIL) { nodes[child[i]].AddParent(Root); }\n\t\t\t}\n\t\t\tReconstruct(RestPre, RestIn, nodes, RestPre[0], ++cnt);\n\t\t\treturn;\n\t\t}\n\t\tstd::vector<int>PreLeft;\n\t\tstd::copy(&Pre[1], &Pre[m] + 1, std::back_inserter(PreLeft));\n\t\tstd::vector<int>InLeft;\n\t\tstd::vector<int>PreRight;\n\t\tPreRight.push_back(NIL);\n\t\t//PreRight={NIL};\n\t\tstd::vector<int> InRight;\n\t\tInRight.push_back(NIL);\n\t\t//InRight={NIL};\n\t\tstd::copy(&In[0], &In[m - 1] + 1, std::back_inserter(InLeft));\n\n\t\tif (m < Pre.size() - 1) {\n\t\t\tPreRight.pop_back();\n\t\t\tstd::copy(&Pre[m] + 1, &Pre[Pre.size() - 1] + 1, std::back_inserter(PreRight));\n\t\t}\n\t\tif (m < In.size() - 1) {\n\t\t\tInRight.pop_back();\n\t\t\tstd::copy(&In[m] + 1, &In[In.size() - 1] + 1, std::back_inserter(InRight));\n\t\t}\n\n\n\n\n\t\tstd::vector<int> child(2);\n\t\tchild[0] = PreLeft.empty() ? NIL : PreLeft[0];\n\t\tchild[1] = PreRight.empty() ? NIL : PreRight[0];\n\t\t//nodes[cnt].AddChild(child);\n\t\tnodes[Root].AddChild(child);\n\t\tfor (unsigned int i = 0; i < child.size(); ++i) {\n\n\t\t\tif (child[i] != NIL) { nodes[child[i]].AddParent(Root); }\n\t\t}\n\t\tReconstruct(PreLeft, InLeft, nodes, PreLeft[0], ++cnt);\n\t\tReconstruct(PreRight, InRight, nodes, PreRight[0], ++cnt);\n\t}\n};\n\nvoid SetVector(std::vector<int>&InputVector) {\n\tfor (unsigned int i = 0; i < InputVector.size(); ++i) {\n\t\tstd::cin >> InputVector[i];\n\t}\n\treturn;\n}\nint main(void) {\n\n\tint n;\n\tstd::cin >> n;\n\tstd::vector<int>Pre(n);\n\tstd::vector<int>In(n);\n\tSetVector(Pre);\n\tSetVector(In);\n\tstd::vector<Tree> nodes(n + 1);\n\t//ReconstructWithNoParent\n\tint cnt = 0;\n\tnodes[1].Reconstruct(Pre, In, nodes, Pre[0], cnt);\n\n\t//nodes[1].PostorderTreeWalk(nodes, 1);\n\tstd::vector<int>Print;\n\tnodes[1].GetVctorPostorderTreeWalk(nodes, Print, nodes[1].GetRoot(nodes, 1));\n\t//Print=nodes[1].GetVctorPostorderTreeWalk(nodes, 1);\n\tfor (unsigned int i = 0; i < Print.size(); ++i) {\n\t\tif (i) { std::cout << \" \"; }\n\t\tstd::cout << Print[i];\n\t\tif (i == Print.size() - 1) { std::cout << std::endl; }\n\t}\n\n\n//\tsystem(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <malloc.h>\nusing namespace std;\nint n;\nint preorder[102];\nint visit[102];\nint inorder[102];\nbool first = true;\n\nstruct Node {\n\tint id;\n\tNode* left;\n\tNode* right;\n};\n\npair<int, int > findRoot(int left, int right) {//中序遍历中，这颗树所有节点的范围\n\t//返回第一个数为找到的根节点的节点号，后一个数为根节点在后序遍历的下标\n\tfor (int i = 0; i < n; i++) {\n\t\tif (visit[preorder[i]] == 0) {\n\t\t\tfor (int j = left; j <= right; j++) {\n\t\t\t\tif (inorder[j] == preorder[i]) {\n\t\t\t\t\treturn make_pair(preorder[i], j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn make_pair(0, 0);\n}\nNode* buildTree(int left, int right) {\n\tif (left > right) {\n\t\treturn NULL;\n\t}\n\n\tpair<int, int> rootInfo = findRoot(left, right);\n\tNode* root = (Node *)malloc(sizeof(Node));\n\troot->id = rootInfo.first;\n\n\troot->left = buildTree(left, rootInfo.second - 1);\n\troot->right = buildTree(rootInfo.second + 1, right);\n\n\treturn root;\n}\n\nvoid postorder(Node* root) {\n\tif (root == NULL) {\n\t\treturn;\n\t}\n\tpostorder(root->left);\n\tpostorder(root->right);\n\tif (first) {\n\t\tcout << root->id;\n\t\tfirst = false;\n\t}\n\telse {\n\t\tcout << \" \";\n\t\tcout << root->id;\n\t}\n}\n\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> preorder[i];\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> inorder[i];\n\t}\n\tNode* root = buildTree(0,n-1);\n\tpostorder(root);\n\n\tcout << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<stdlib.h>\n\n// I did it!\nint *P, *L, *R;\n\nvoid maketree(int* A, int* B, int h)\n{\n    int x, m;\n    x = A[0];\n    if(h == 1){\n        L[x] = -1; R[x] = -1; return;\n    }else{\n        m = 0;\n        while(B[m] != A[0]) m++;\n        m++;\n        if(m == 1){\n            L[x] = -1; R[x] = A[1]; P[A[1]] = x;\n            maketree(A + 1, B + 1, h - 1);\n        }else if(m == h){\n            L[x] = A[1]; P[A[1]] = x; R[x] = -1;\n            maketree(A + 1, B, h - 1);\n        }else{\n            L[x] = A[1]; P[A[1]] = x; R[x] = A[m]; P[A[m]] = x;\n            maketree(A + 1, B, m - 1);\n            maketree(A + m, B + m, h - m);\n        }\n    }\n}\n\nvoid postorder(int i, int f)\n{\n    if(i < 0) return;\n    postorder(L[i], f);\n    postorder(R[i], f);\n    if(i != f) cout << \" \";\n    cout << i;\n}\n\nint main()\n{\n    int i, n, first;\n    cin >> n;\n    P = new int [n]; L = new int [n]; R = new int [n];\n    if(P == NULL || L == NULL || R == NULL) exit(EXIT_FAILURE);\n\n    int *A, *B;\n    A = new int [n]; B = new int [n];\n    if(A == NULL || B == NULL) exit(EXIT_FAILURE);\n\n    for(i = 0; i < n; i++){ cin >> A[i]; P[i] = L[i] = R[i] = -1; }\n    for(i = 0; i < n; i++){ cin >> B[i]; }\n\n    maketree(A, B, n);\n    delete [] A; delete [] B;\n\n    // where is root?\n    i = 0; while(P[i] >= 0) i++;\n    // where is the first output?\n    first = i; while(L[first] >= 0) first++;\n\n    postorder(i, first);\n    cout << endl;\n    delete [] P; delete [] L; delete [] R;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <list>\n#include <map>\n#include <math.h>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <stdio.h>\n#include <string>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define all(a) a.begin(),a.end()\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst int inf=1e+9;\nconst ll mod=1000000007;\nconst double PI=3.14159265358979323846;\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\nll gcd(ll a, ll b){\n  if (b==0) return a;\n  else return gcd(b,a%b);\n}\nint cans(bool f){\n  if(f) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n  return 0;\n}\n\n#define NIL -1\n#define MAX 100005\n\nint n,pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n  if(l >= r) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(all(in),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\n\nvoid solve() {\n  rec(0,n);\n  rep(i,n){\n    if(i) {\n      cout << \" \" <<  post[i];\n    }\n    else cout << post[i];\n  }\n  cout << endl;\n}\n\n\nint main() {\n  cin >> n;\n  pre.resize(n);\n  in.resize(n);\n  rep(i,n) cin >> pre[i];\n  rep(i,n) cin >> in[i];\n\n  solve();\n  \n  return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r){\n\tif(l>=r)return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(),find(in.begin(),in.end(),root));\n\trec(l,m);\n\trec(m+1,r);\n\tpost.push_back(root);\n}\n\nvoid solve(){\n\tpos=0;\n\trec(0,pre.size());\n\tfor(int i=0;i<n;i++){\n\t\tif(i>0)cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\n\nint main(){\n\tint r,l,a;\n\tcin >> n;\n\tfor(int s=0;s<n;s++){\n\t\tcin >> a;\n\t\tpre.push_back(a);\n\t}\n\tfor(int s=0;s<n;s++){\n\t\tcin >> a;\n\t\tin.push_back(a);\n\t}\n\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n, pre[45], in[45];\nint solve(int i, int s, int e){\n    //cout << i << \" \" << s << \" \" << e << endl;\n    if(s == e){\n        if(in[s] == pre[0]){\n            cout << in[s];\n        }\n        else{\n            cout << in[s] << \" \";\n        }\n        return i;\n    }\n    for(int j = s; j <= e; j++){\n        if(pre[i] == in[j]){\n            if(j - 1 >= s)\n                i = solve(i + 1, s, j - 1);\n            if(j + 1 <= e)\n                i = solve(i + 1, j + 1, e);\n            if(in[j] == pre[0]){\n                cout << in[j];\n            }\n            else{\n                cout << in[j] << \" \";\n            }\n            break;\n        }\n    }\n    return i;\n}\nint main(){\n\n    cin >> n;\n    for(int i = 0; i < n; i++){\n        cin >> pre[i];\n    }\n    for(int i = 0; i < n; i++){\n        cin >> in[i];\n    }\n    solve(0, 0, n - 1);\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nvoid reorder(int Preorder[], int Inorder[], int Postorder[], int l, int a, int b, int c) {\n  if (l == 0) return;\n\n  int num = Preorder[a];\n  Postorder[c + l - 1] = num;\n  // if (l == 1) return;\n  // if (l == 0) {\n  //   cout << \"l==0\" << endl;\n  //   return;  // should not happen\n  // }\n\n  for (int i = 0; i < l; i++) {\n    if (Inorder[b + i] == num) {\n      reorder(Preorder, Inorder, Postorder, i, a + 1, b, c);\n      reorder(Preorder, Inorder, Postorder, l - i - 1, a + i + 1, b + i + 1, c + i);\n      break;\n    }\n  }\n}\n\nint main() {\n  int N;\n  cin >> N;\n\n  int Preorder[N];\n  int Inorder[N];\n  int Postorder[N];\n\n  for (int i = 0; i < N; i++) {\n    cin >> Preorder[i];\n  }\n  for (int i = 0; i < N; i++) {\n    cin >> Inorder[i];\n  }\n\n  reorder(Preorder, Inorder, Postorder, N, 0, 0, 0);\n\n  for (int i = 0; i < N; i++) {\n    if (i != 0) cout << \" \";\n    cout << Postorder[i];\n  }\n  cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace  std;\n\nconst int END = -1;\nstruct StNod\n{\n  int m_nParnt;\n  int m_nLeft;\n  int m_nRigt;\n\n  StNod() :\n     m_nParnt(END), m_nLeft(END), m_nRigt(END)\n  { }\n};\n\nenum EnDir\n{\n  D_Left,\n  D_Right,\n};\n\nvoid fnInput(vector<int>& rvnPodr, vector<int>& rvnIodrSeq)\n{\n  int nMaxSiz;\n\n  cin >> nMaxSiz;\n  rvnPodr.resize(nMaxSiz);\n  rvnIodrSeq.resize(nMaxSiz + 1);\n\n  for (int i = 0; i < nMaxSiz; i++)\n    cin >> rvnPodr[i];\n\n  int nNode;\n  for (int i = 1; i < nMaxSiz + 1; i++)\n  {\n    cin >> nNode;\n    rvnIodrSeq[nNode] = i;\n  }\n}\n\nvoid fnStructTree(const vector<int>& cnrvnPodr, const vector<int>& cnrvnIodrSeq, vector<StNod>& rvoNod)\n{\n  for (int i = 1; i < cnrvnPodr.size(); i++)\n  {\n    int nParnt = END;\n    int nx = cnrvnPodr[0];\n    EnDir enDir;\n    while (nx != END)\n    {\n      nParnt = nx;\n      if (cnrvnIodrSeq[ cnrvnPodr[i] ] < cnrvnIodrSeq[nx])\n      {\n        nx = rvoNod[nx].m_nLeft;\n        enDir = D_Left;\n      }\n      else\n      {\n        nx = rvoNod[nx].m_nRigt;\n        enDir = D_Right;\n      }\n    }\n\n    rvoNod[ cnrvnPodr[i] ].m_nParnt = nParnt;\n    if (enDir == D_Left)\n      rvoNod[nParnt].m_nLeft = cnrvnPodr[i];\n    else\n      rvoNod[nParnt].m_nRigt = cnrvnPodr[i];\n  }\n}\n\nvoid fnPostOrder(const vector<StNod>& cnrvoNod, int nx)\n{\n  static int stnPrt = 0;\n  if (nx == END)  return;\n\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nLeft);\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nRigt);\n\n  if (stnPrt++) cout << \" \";\n  cout << nx;\n}\n\nvoid fnResult(const vector<StNod>& cnrvoNod)\n{\n  int nx = 1;\n  while (cnrvoNod[nx].m_nParnt != END)\n    nx = cnrvoNod[nx].m_nParnt;\n\n  fnPostOrder(cnrvoNod, nx);\n  cout << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vector<int> vnPodr, vnIodrSeq;\n  fnInput(vnPodr, vnIodrSeq);\n\n  StNod oNod;\n  vector<StNod> voNod(vnIodrSeq.size(), oNod);\n  fnStructTree(vnPodr, vnIodrSeq, voNod);\n  \n  fnResult(voNod);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cassert>\n#include<cstring>\n#define maxn 50\nusing namespace std;\nint n;\nint order[3][maxn],post[maxn];\nbool vis[maxn];\n\nint find(int num,int c)\n{\n    for(int i=1; i<=n; ++i)\n        if(order[c][i]==num)\n        {\n            vis[i]=true;\n            return i;\n        }\n    return -1;\n}\n\nvoid postorder(int s,int e)\n{\n//\tcout<<\"s=\"<<s<<\" e=\"<<e<<endl;\n    if(s>e) return ;\n\tif(s==e)\n    {\n        post[++post[0]]=order[1][e];\n//        cout<<post[post[0]]<<\" \";\n        return;\n    }\n    int num=order[1][s],pre_num=0,pos_num=0;\n    post[++post[0]]=order[1][s];\n//    cout<<post[post[0]]<<\" \";\n    int p=find(num,2);\n    for(int i=p+1;i<=n;++i)\n      if(vis[i])\n        break;\n      else\n        pos_num++;\n    for(int i=p-1;i>=1;--i)\n      if(vis[i])\n        break;\n      else\n        pre_num++;\n//    cout<<\"'\"<<pre_num<<\"'-'\"<<pos_num<<\"'\"<<endl; \n    postorder(e-pos_num+1,e);\n    postorder(s+1,s+pre_num);\n    return;\n}\n\nint main()\n{\n    memset(vis,0,sizeof(vis));\n    scanf(\"%d\",&n);\n    for(int j=1; j<=2; ++j)\n        for(int i=1; i<=n; ++i)\n            scanf(\"%d\",&order[j][i]);\n    post[0]=0;\n    postorder(1,n);\n    printf(\"%d\",post[post[0]]);\n    for(int i=post[0]-1; i>=1; --i)\n        printf(\" %d\",post[i]);\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <climits>\n#include <cstring>\n#define rep(i, begin, end) for (__typeof(end) i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))\n\nusing namespace std;\n\nconst int N_MAX = 1000000;\n\n/*\n pre: 4 2 3 1 5\n in:  3 2 4 5 1\n\n*/\nstruct Node{\n  int data;\n  Node* left;\n  Node* right;\n};\n\nvoid postorder(Node* root){\n  if(root == NULL) return;\n  postorder(root->left);\n  postorder(root->right);\n  cout << \" \" << root->data;\n}\n\n\nvoid print_array(int* arr, int len){\n  rep(i, 0, len){\n    cout << arr[i];\n    if(i==len-1) cout << endl;\n    else cout << \" \";\n  }\n}\n\nNode* solve(int* inorder, int* preorder, int len){\n  // cout << \"inorder: \" << endl;\n  // print_array(inorder, len);\n  \n  // cout << \"preorder: \" << endl;\n  // print_array(preorder, len);\n  // find root\n  int root_data = preorder[0];\n  Node* root_node = new Node;\n  root_node->data = root_data;\n  if(len==1) return root_node;\n  \n  // count all the num left\n  int left_num=0;\n  while(inorder[left_num] != root_data) left_num++;\n  int right_num = len - left_num - 1;\n  \n  int* left_inorder = new int[left_num];\n  int* right_inorder = new int[right_num];\n  \n  int* left_preorder = new int[left_num];\n  int* right_preorder = new int[right_num];\n\n  int ix=0;\n  int l_ix=0, r_ix=0;\n\n  rep(ix, 0, len){\n    if(inorder[ix] == root_data) continue;\n    if(l_ix<left_num){\n      left_inorder[l_ix] = inorder[ix];\n      l_ix++;\n    }\n    else if(r_ix<right_num){\n      right_inorder[r_ix] = inorder[ix];\n      r_ix++;\n    }\n  }\n  \n  ix = 0; l_ix = 0; r_ix = 0;\n  \n  rep(ix, 1, len){\n    if(l_ix < left_num){\n      left_preorder[l_ix] = preorder[ix];\n      l_ix++;\n    }\n    else if(r_ix < right_num){\n      right_preorder[r_ix] = preorder[ix];\n      r_ix++;\n    }\n  }\n\n  if(left_num>0) root_node->left = solve(left_inorder, left_preorder, left_num);\n  if(right_num>0) root_node->right = solve(right_inorder, right_preorder, right_num);  \n  \n  delete[] left_inorder;\n  delete[] right_inorder;\n\n  return root_node;\n  \n}\n\nint main(){\n  int n; cin >> n;\n\n  int* inorder = new int[n];\n  int* preorder = new int[n];\n  \n  int tmp;\n  rep(i, 0, n){\n    cin >> tmp;\n    preorder[i] = tmp;\n  }\n  rep(i, 0, n){\n    cin >> tmp;\n    inorder[i] = tmp;\n  }\n  Node* root = solve(inorder, preorder, n);\n\n  postorder(root);\n  cout << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n\nusing namespace std;\n\nint n,inputed_order[41] = {0};\nqueue<int> Queue;\n\nstruct Node{\n\tNode(){\n\t\tleft_child = right_child = -1;\n\t};\n\tint left_child,right_child;\n};\n\nvoid postORDER(Node order[],int id){\n\tif(order[id].left_child != -1) postORDER(order,order[id].left_child );\n\tif(order[id].right_child != -1) postORDER(order,order[id].right_child );\n\tQueue.push(id+1);\n}\n\nint findRoot(int inorder[],int left,int right){\n\tint root = inorder[left];\n\tfor(int i = left+1; i <= right; i++){\n\t\tif(inputed_order[root] > inputed_order[inorder[i]]){\n\t\t\troot = inorder[i];\n\t\t}\n\t}\n\treturn root;\n}\n\nvoid reconstruct(int inorder[],Node order[],int root,int left,int right){\n\tint root_index;\n\tfor(root_index = left; inorder[root_index] != root; root_index++);\n\tif(left < root_index){\n\t\tint new_root = findRoot(inorder,left,root_index-1);\n\t\torder[root-1].left_child = new_root-1;\n\t\tif(left < root_index-1)\treconstruct(inorder,order,new_root,left,root_index-1);\n\t}\n\tif(root_index < right){\n\t\tint new_root = findRoot(inorder,root_index+1,right);\n\t\torder[root-1].right_child = new_root-1;\n\t\tif(root_index+1 < right) reconstruct(inorder,order,new_root,root_index+1,right);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tint preorder[n],inorder[n];\n\tNode order[n];\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\",&preorder[i]);\n\t\tinputed_order[preorder[i]] = i;\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\",&inorder[i]);\n\t}\n\n\tif(n == 1){\n\t\tprintf(\"%d\\n\",preorder[0]);\n\t}else{\n\t\treconstruct(inorder,order,preorder[0],0,n-1);\n\t\tpostORDER(order,preorder[0]-1);\n\t\twhile(!Queue.empty()){\n\t\t\tif(Queue.size() != 1){\n\t\t\t\tprintf(\"%d \",Queue.front());\n\t\t\t\tQueue.pop();\n\t\t\t}else{\n\t\t\t\tprintf(\"%d\\n\",Queue.front());\n\t\t\t\tQueue.pop();\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> pre, in, post;\nint n, pos;\n\nvoid reconstruction(int left, int right) {\n    if (left >= right) return;\n    int root = pre[pos++];\n    int idx = distance(in.begin(), find(in.begin(), in.end(), root));\n    reconstruction(left, idx);\n    reconstruction(idx + 1, right);\n    post.push_back(root);\n    return;\n}\n\nvoid solve() {\n    pos = 0;\n    reconstruction(0, n);\n    for (int i = 0; i < n; i++) {\n        if (i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n    return;\n}\n\nint main() {\n    cin >> n;\n\n    int node;\n    for (int i = 0; i < n; i++) {\n        cin >> node;\n        pre.push_back(node);\n    }\n\n    for (int i = 0; i < n; i++) {\n        cin >> node;\n        in.push_back(node);\n    }\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define NUL -1\nconst int N_MAX = 45;\nint root;\nstruct Node{\n    int parent, left, right;\n};\nNode tree[N_MAX];\nint pre[N_MAX], in[N_MAX];\n\nvoid reConstruct(int parent, int * preP, int * inP, int n, bool isLeft){\n    if(n==0) return;\n    int nowRoot = preP[0];\n    tree[nowRoot].parent = parent;\n    //getchar();\n    //cout<<\"-- nowRoot: \"<<nowRoot<<endl;\n    if(parent==NUL){\n        root=nowRoot;\n    }else if(isLeft){\n        tree[parent].left=nowRoot;\n    }else{\n        tree[parent].right=nowRoot;\n    }\n    if(n==1)return;\n    int flag = 0;\n    for(;flag<n;flag++){\n        if(inP[flag]==nowRoot) break;\n    }\n    //cout<<\"nowRoot: \"<<nowRoot<<\" flag: \"<<flag<<endl;\n    reConstruct(nowRoot, preP+1, inP, flag, true);\n    reConstruct(nowRoot, preP+1+flag, inP+1+flag, n-flag-1, false);\n}\n\nvoid post(int id){\n    if(id==NUL) return;\n    if(tree[id].left==NUL&&tree[id].right==NUL&&id!=root){\n        printf(\"%d \", id);\n        //cout<<id<<\" \";\n        return;\n    }\n    post(tree[id].left);\n    post(tree[id].right);\n    if(id==root){\n        printf(\"%d\", id);\n        //cout<<id<<endl;\n    }else{\n        printf(\"%d \", id);\n        //cout<<id<<\" \";\n    }\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    //cin>>n;\n    for(int i=0;i<n;i++){\n        scanf(\"%d\", &pre[i]);\n        //cin>>pre[i];\n        tree[i].parent=tree[i].left=tree[i].right=NUL;\n    }\n    tree[n].parent=tree[n].left=tree[n].right=NUL;\n    for(int i=0;i<n;i++){\n        scanf(\"%d\", &in[i]);\n        //cin>>in[i];\n    }\n    reConstruct(NUL, pre, in, n, true);\n    /*//Debugging/\n    for(int i=1;i<=n;i++){\n        cout<<\"node\"<<i<<\": p: \"<<tree[i].parent<<\"  l: \"<<tree[i].left<<\"  r: \"<<tree[i].right<<endl;\n    }\n    ///Debugging*/\n    post(root);\n    printf(\"\\n\");\n    //cout<<\"root: \"<<root<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l,int r){\n\tif( l >= r ) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(),find(in.begin(),in.end(),root));\n\trec(l,m);\n\trec(m+1,r);\n\tpost.push_back(root);\n}\n\nvoid solve(){\n\tpos = 0;\n\trec(0,n);\n\tfor( int i = 0; i < n; i++ ) {\n\t\tif(i) cout << \" \" ;\n\t\tcout << post[i] ;\n\t}\n\tcout << endl;\n}\n\nint main(){\n\tcin >> n;\n\tint k;\n\tfor( int i = 0; i < n; i++ ){\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t} \n\tfor( int i = 0; i < n; i++ ){\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nvector<int> pre,in,post;\nint n,pos;\n\nint findx(int root){\n    for(int i=0;i<n;i++){\n        if(in[i]==root)return i;\n    }\n    return n;\n}\n\n\nvoid solve(int l,int r){\n    if(l>=r)return;\n    int root=pre[pos++];\n    int m=findx(root);\n    solve(l,m);\n    solve(m+1,r);\n    post.push_back(root);\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n;\n    for(int i=0;i<n;i++){\n        int k;\n        cin >> k;\n        pre.push_back(k);\n    }\n    for(int i=0;i<n;i++){\n        int k;\n        cin >> k;\n        in.push_back(k);\n    }\n    solve(0,pre.size());\n    for(int i=0;i<n;i++){\n        if(i)cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n\tif (l >= r) return;\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\nvoid solve(){\n\tpos = 0;\n\trec(0, pre.size());\n\tfor (int i = 0; i < n; i++){\n\t\tif (i) cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\n\nint main(){\n\tint k;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> k;\n\t\tpre.push_back(k);\n\t}\n\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> k;\n\t\tin.push_back(k);\n\t}\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r){\n//\tprintf(\"\tl=%d r=%d\\n\",l,r);\n\tif(l>=r)return;\n\tint root = pre[pos++];//visit in Preorder\n\tint m = distance(in.begin(),find(in.begin(),in.end(),root));//return distance between two iterators\n//\tprintf(\"l = %d root = %d m = %d r = %d\\n\",l,root,m,r);\n\n\trec(l,m);\t\n\trec(m+1,r);\n\tpost.push_back(root);//left-right-root,if inOrder,put this above\n//\tprintf(\"push %d\\n\\n\",root);\n}\nint main()\n{\n\tint n,k;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;++i){\n\t\tscanf(\"%d\",&k);\n\t\tpre.push_back(k);\n\t}\n\tfor(int i=0;i<n;++i){\n\t\tscanf(\"%d\",&k);\n\t\tin.push_back(k);\n\t}\n \tpos = 0;\n \trec(0,pre.size());\n \tfor(int i=0;i<n;++i){\n\t \tif(i)printf(\" \");\n\t \tprintf(\"%d\",post[i]);\n \t}\n    printf(\"\\n\");\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n\nstd::vector<int> pre, in;\nint pos;\nstd::vector<int> tmp;\n\nint reconstruction(int l, int r){\n    if(l == r){\n        return 0;\n    }\n\n    int c = pre[pos++];\n    int m = std::distance(in.begin(), find(in.begin(), in.end(), c));\n    reconstruction(l, m);\n    reconstruction(m+1, r);\n\n    //std::cout << c << std::endl;\n    tmp.push_back(c);\n}\n\nint main(void){\n\n    int n;\n    std::cin >> n;\n    pos = 0;\n    pre.resize(n);\n    in.resize(n);\n    for(int i = 0; i < n; i++){\n        std::cin >> pre[i];\n    }\n\n    for(int i = 0; i < n; i++){\n        std::cin >> in[i];\n    }\n\n    reconstruction(0, n);\n    for(int i = 0; i < n; i++){\n        if(i != 0) std::cout << \" \";\n        std::cout << tmp[i];\n    }\n    std::cout << std::endl;\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<stack>\n#include<queue>\n#include<list>\n#include<set>\n#include<cmath>\n\n#define REP(i,n) for(int (i) = 0;(i) < (n);(i)++)\nusing namespace std;\nint n;\n\nclass node {\npublic:\n\tint id;\n\tint parent, child1, child2, sibling;\n\tint degree, depth, height;\n\tnode() :id(-1), parent(-1), child1(-1), child2(-1), sibling(-1), degree(0), depth(0), height(0) {};\n\n\tfriend ostream& operator<<(ostream& os, const node& N) {\n\t\tcout << \"node \" << N.id;\n\t\tcout << \": parent = \" << N.parent;\n\t\tcout << \", sibling = \" << N.sibling;\n\t\tcout << \", degree = \" << N.degree;\n\t\tcout << \", depth = \" << N.depth;\n\t\tcout << \", height = \" << N.height;\n\t\tcout << \", \";\n\t\tif (N.parent == -1) cout << \"root\";\n\t\telse if (N.child1 == -1 && N.child2 == -1) cout << \"leaf\";\n\t\telse cout << \"internal node\";\n\t\tcout << endl;\n\t}\n};\n\nvoid Pos(int n, vector<node> N) {\n\tint c1 = N[n].child1, c2 = N[n].child2;\n\tif (c1 != -1) Pos(c1-1, N);\n\tif (c2 != -1) Pos(c2-1, N);\n\tcout <<  n+1 << \" \";\n}\nvoid solve(vector<int> P, vector<int> S, vector<node> &N) {\n\tN[P[0]-1].id = P[0];\n\tint i = 0;\n\twhile (P[0] != S[i])i++;\n\tif (i>0) {\n\t\tN[P[0]-1].child1 = P[1];\n\t\tvector<int> P1, S1;\n\t\tP1.assign(P.begin() + 1, P.begin() + i + 1);\n\t\tS1.assign(S.begin(), S.begin() + i);\n\t\tsolve(P1, S1, N);\n\t}\n\tif (i<P.size() - 1) {\n\t\tN[P[0]-1].child2 = P[i + 1];\n\t\tvector<int> P1, S1;\n\t\tP1.assign(P.begin() + i + 1, P.end());\n\t\tS1.assign(S.begin() + i + 1, S.end());\n\t\tsolve(P1, S1, N);\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tvector<node> N(n);\n\tvector<int> P(n), S(n);\n\tREP(i, n) cin >> P[i];\n\tREP(i, n) cin >> S[i];\n\tsolve(P, S, N);\n\tn = P[0]-1;\n\tint c1 = N[n].child1, c2 = N[n].child2;\n\tif (c1 != -1) Pos(c1-1, N);\n\tif (c2 != -1) Pos(c2-1, N);\n\tcout << n+1 ;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\n#define MAX_V 41\nstruct node{\n  int id,parent,left,right,sibling;\n  node():id(0),parent(-1),left(-1),right(-1),sibling(-1){}\n};\nnode nodes[MAX_V]{};\n\nvoid set_node(int id, int left,int right){\n  nodes[id].id=id;\n  nodes[id].left=left;\n  nodes[id].right=right;\n  if(left>=0){\n    nodes[left].id=left;\n    nodes[left].parent=id;\n    nodes[left].sibling=right;\n  }\n  if(right>=0){\n    nodes[right].id=right;\n    nodes[right].parent=id;\n    nodes[right].sibling=left;\n  }\n}\nvoid printPostorder(node n,bool last=false){\n  if(n.left>=0) printPostorder(nodes[n.left]);\n  if(n.right>=0) printPostorder(nodes[n.right]);\n  cout<<n.id<<(last?\"\\n\":\" \");\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  vector<int> pre;\n  vector<int> in;\n  int n; cin>>n;\n  REP(i,n) {int tmp; cin>>tmp; pre.push_back(tmp);}\n  REP(i,n) {int tmp; cin>>tmp; in.push_back(tmp);}\n\n  while(true){\n    bool found=false;\n    for(int i=pre.size()-2;i>=0;i--){\n      for(int j=in.size()-2;j>=0;j--){\n\tif(i<(int)pre.size()-2&&j<(int)in.size()-2){\n\t  if(pre[i]==in[j+1]&&pre[i+1]==in[j]&&pre[i+2]==in[j+2]){\n\t    set_node(pre[i],pre[i+1],pre[i+2]);\n\t    auto iter=pre.begin();\n\t    REP(k,i+1) iter++;\n\t    pre.erase(iter); pre.erase(iter);\n\t    iter=in.begin();\n\t    REP(k,j) iter++;\n\t    in.erase(iter);iter++;in.erase(iter);\n\t    found=true; break;\n\t  }\n\t}\n\tif(pre[i]==in[j]&&pre[i+1]==in[j+1]){\n\t  set_node(pre[i],-1,pre[i+1]);\n\t  auto iter=pre.begin();\n\t  REP(k,i+1) iter++;\n\t  pre.erase(iter);\n\t  iter=in.begin();\n\t  REP(k,j+1) iter++;\n\t  in.erase(iter);\n\t  found=true; break;\n\t}\n\tif(pre[i]==in[j+1]&&pre[i+1]==in[j]){\n\t  set_node(pre[i],pre[i+1],-1);\n\t  auto iter=pre.begin();\n\t  REP(k,i+1) iter++;\n\t  pre.erase(iter);\n\t  iter=in.begin();\n\t  REP(k,j+1) iter++;\n\t  in.erase(iter);\n\t  found=true; break;\n\t}\n      }\n      if(found){break;}\n    }\n    for(int a:pre) cout <<a;\n    cout<<endl;\n    for(int a:in) cout <<a;\n    cout<<endl;\n    if((int)pre.size()==1){break;}\n  }\n  int root=1;\n  while(nodes[root].parent!=-1)\n    root=nodes[root].parent;\n  printPostorder(nodes[root],true);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,a,b) for(int i=a;i<=b;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define vi vector<int>\n#define pb push_back\n#define pi pair<int,int>\n#define vp vector<pair<int,int> >\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\n\nstruct Node{\n    int p,l,r;\n};\n\nNode t[40];\nvi pre,in,post;\nint root;\n\nvoid rec(int l,int r){\n    if(r-l<1)return;\n    if(r-l==1){\n        post.pb(in[l]);\n        return;\n    }\n    int m;\n    Rep(i,l,r){\n        if(in[i]==pre[root]){\n            m=i;\n            root++;\n            break;\n        }\n    }\n    rec(l,m);\n    rec(m+1,r);\n    post.pb(in[m]);\n}\n\nsigned main(){\n    int n;\n    cin>>n;\n    int v;\n    rep(i,n){\n        cin>>v;\n        pre.pb(v);\n    }\n    rep(i,n){\n        cin>>v;\n        in.pb(v);\n    }\n    rec(0,n);\n    rep(i,n){\n        cout<<post[i]<<(i!=n-1?' ':'\\n');\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\nint pre[105],in[105];\nint pos=-1;\nvoid rec (int l,int r) {\n\tif (l>=r) return;\n\tint cur=pre[++pos],cpos=l;\n\twhile (in[cpos]!=cur) cpos++;\n\trec (l,cpos);\n\trec (cpos+1,r);\n\tprintf (\"%d\",cur);\n\tif (cur!=pre[0]) printf (\" \");\n\telse printf (\"\\n\");\n}\nint main () {\n\tint n;\n\tscanf (\"%d\",&n);\n\tfor (int i=0;i<n;i++) {\n\t\tscanf (\"%d\",&pre[i]);\n\t}\n\tfor (int i=0;i<n;i++) {\n\t\tscanf (\"%d\",&in[i]);\n\t}\n\trec(0,n);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector <int> pre, in, post;\n\nvoid rec(int l, int r){\n  if(l >= r)return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(l, m);\n  rec(m + 1, r);\n  post.push_back(root);\n}\n\nvoid solve(){\n  pos = 0;\n  rec(0, pre.size());\n  for(int i=0;i<n;i++){\n    if(i) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n  \nint main(){\n  int k, i;\n  cin >> n;\n  for(i=0;i<n;i++){\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for(i=0;i<n;i++){\n    cin >> k;\n    in.push_back(k);\n  }\n  \n  solve();\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r)\n{\n  if(l>=r) return ;\n  int root = pre[pos++];\n  int m = distance(in.begin(),find(in.begin(),in.end(),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\n\nvoid solve()\n{\n  pos = 0;\n  rec(0,pre.size());\n  for(int i=0;i<n;i++)\n    {\n      if(i) cout << \" \";\n      cout << post[i];\n    }\n  cout << endl;\n}\n\nint main ()\n{\n  int k;\n  cin >> n;\n\n  for (int i=0;i<n;i++)\n    {\n      cin >> k;\n      pre.push_back(k);\n    }\n\n  for(int i=0;i<n;i++)\n    {\n      cin >> k;\n      in.push_back(k);\n    }\n\n  solve();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define sz(x) int(x.size())\n#define pb push_back\n#define eb emplace_back\nusing ll=long long;\nusing P = pair<ll,int>;\n#define chmax(x,y) x = max(x,y)\n#define chmin(x,y) x = min(x,y)\nconst ll MOD=1000000007,MOD2=998244353;\n\nint n;\nvector<int> inorder;\nvector<int> ans;\nvoid dfscreate(int p,int from,int to){//親と区間\n    if(from>to){return;}\n    //区間の最小値が親\n    int newp;\n    for(int i=from;i<=to;i++){\n        if(i==from)newp=i;\n        if(inorder.at(newp)>inorder.at(i)){\n            newp=i;\n        }\n    }\n    dfscreate(inorder.at(newp),from,newp-1);\n    dfscreate(inorder.at(newp),newp+1,to);\n    ans.pb(inorder.at(newp));\n    return;\n}\n\nint main() {\n    cin>>n;\n    vector<int> change(n+1),rchange(n+1);\n    inorder.resize(n);\n    rep(i,n){\n        cin>>rchange.at(i+1);\n        change.at(rchange.at(i+1))=i+1;\n    }\n    rep(i,n){\n        int a;\n        cin>>a;\n        inorder.at(i)=change.at(a);\n    }\n    //入力2行目が123...の時3行目がinorder\n\n    dfscreate(0,0,n-1);\n\n    rep(i,n){\n        if(i)cout<<\" \";\n        cout<<rchange.at(ans.at(i));\n    }\n    cout<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n\nstatic const size_t n_max = 40;\nstatic int A[n_max], B[n_max], C[n_max], c;\n\nvoid rec(size_t l, size_t i, size_t j) {\n  switch (l) {\n    case 0:\n      break;\n    case 1:\n      C[c++] = A[i];\n      break;\n    default:\n      // locate the root of this subtree\n      size_t k = std::find(B + j, B + j + l, A[i]) - (B + j);\n      rec(k, i + 1, j);\n      rec(l - k - 1, i + k + 1, j + k + 1);\n      C[c++] = A[i];\n      break;\n  }\n}\n\nint main() {\n  size_t n;\n  scanf(\"%zu\\n\", &n);\n  for (size_t i = 0; i < n; i++)\n    scanf(\"%d\", A + i);\n  for (size_t i = 0; i < n; i++)\n    scanf(\"%d\", B + i);\n  rec(n, 0, 0);\n  for (size_t i = 0; i < n - 1; i++)\n    printf(\"%d \", C[i]);\n  printf(\"%d\\n\", C[n-1]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nstruct node{\n    int l,r;\n};\nnode v[41];\nvector<int> postord;\nvoid dfs(int vi){\n    if(v[vi].l!=0)dfs(v[vi].l);\n    if(v[vi].r!=0)dfs(v[vi].r);\n    postord.pb(vi);\n}\nint pre[41],in[41];\nint main(){\n    int n,root;\n    cin>>n;\n    rep(i,n) cin>>pre[i];\n    rep(i,n) cin>>in[i];\n    root=pre[0];\n    int cp=0,ci=0;\n    while(cp<n-1){\n        v[pre[cp]].l=pre[++cp];\n        while(cp<n&&pre[cp]==in[ci]){\n            ++ci;\n            v[in[ci]].r=in[++ci];\n            ++cp;\n        } \n    }\n    dfs(root);\n    rep(i,n) cout<<postord[i]<<(i==n-1?\"\":\" \");\n    cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint pre[50];\nint in[50];\nint ans[50];\nint N;\nint cur = 0;\nint ansIndex = 0;\n\nvoid solve( int l, int r ){\n  if( r - l > 0 ){\n    int root = pre[cur++];\n    int d;\n    for( int i = 0; i < N; i++ ){\n      if( in[i] == root ){\n\td = i;\n\tbreak;\n      }\n    }\n\n    solve( l, d );\n    solve( d + 1, r );\n    ans[ansIndex++] = root;\n  }\n}\n\nint main(){\n  cin >> N;\n  for( int i = 0; i < N; i++ ) cin >> pre[i];\n  for( int i = 0; i < N; i++ ) cin >> in[i];\n\n  solve( 0, N );\n\n  for( int i = 0; i < N; i++ ){\n    cout << ans[i];\n    if( i == N - 1 ) cout << endl;\n    else cout << \" \";\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nstruct node{\n    int left,right;\n}nodes[100];\n\nint n,pre[105],in[105],inloc[105],cnt=0;\n\nint rec(int s,int e){\n    if(s<e){\n        int m=inloc[pre[cnt++]];\n        int l=rec(s,m-1);\n        int r=rec(m+1,e);\n        nodes[in[m]].left=l;\n        nodes[in[m]].right=r;\n        return in[m];\n    }\n    else if(s==e){return in[s];}\n    else {return 0;}\n}\n\nvoid post(int r){\n    if(nodes[r].left!=0)post(nodes[r].left);\n    if(nodes[r].right!=0)post(nodes[r].right);\n    cout<<r;\n    if(r!=pre[0])cout<<\" \";\n}\n\nint main()\n{\n    memset(nodes,0,sizeof(nodes));\n    cin>>n;\n    int i;\n    for(i=0;i<n;i++){\n        cin>>pre[i];\n    }\n    for(i=0;i<n;i++){\n        cin>>in[i];\n        inloc[in[i]]=i;\n    }\n    int mm=rec(0,n-1);\n    post(pre[0]);\n    cout<<endl;\n    return 0;\n}\n//\n//int main(){\n//    int a[10]={1,2,3,4,5,32,62,23,8,33};\n//    int *b=find(a,a+10,62);\n//    int c=distance(a,b);\n//    cout<<c;\n//}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\nvector <int> pre, in;\n\nvoid rec(int lp, int rp, int li, int ri) {\n    int root = pre[lp];\n    int i = 0;\n    while(in[li+i] != root) i++;\n    if (i != 0) rec(lp+1, lp+i, li, li+i-1);\n    if (li + i != ri) rec(lp+i+1, rp, li+i+1, ri);\n\n    printf(\"%d \", root);\n}\n\nvoid solve(void){\n    int N;\n    cin >> N;\n    pre.resize(N), in.resize(N);\n    rep(N, i) cin >> pre[i];\n    rep(N, i) cin >> in[i];\n    rec(0, N-1, 0, N-1);\n    printf(\"\\n\");\n}\n\nint main(void){\n  solve();\n  //cout << \"yui(*-v・)yui\" << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define MAX 40\nint pre[MAX] ={0};\nint in[MAX] = {0};\nint cnt = 0;\nint n;\n\nint next(int A[]) {\n\tint ret;\n\tret = A[cnt];\n\t++cnt;\n\treturn ret;\n}\n\nint in_find(int c) {\n\tint i = 0;\n\twhile (in[i] != c) {\n\t\t++i;\n\t}\n\treturn i;\n}\n\nvoid reconstruction(int l, int r) {\n\tint c, m;\n\t\n\tif (l >= r) return;\n\tc = next(pre);\n\tm = in_find(c);\n\n\treconstruction(l, m);\n\treconstruction(m + 1, r);\n\tprintf(\" %d\", c);\n\treturn;\n}\n\nint main(void) {\n\tint i;\n\n\tscanf(\"%d\", &n);\n\n\tfor (i = 0; i < n; ++i) {\n\t\tscanf(\" %d\", &pre[i]);\n\t}\n\n\tfor (i = 0; i < n; ++i) {\n\t\tscanf(\" %d\", &in[i]);\n\t}\n\n\treconstruction(0, n);\n\tprintf(\"\\n\");\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n,s[50],ans[50],a;\n  vector<int> t;\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>a,s[a]=i,ans[i]=a;\n  for(int i=0;i<n;i++)cin>>a,t.push_back(s[a]);\n  t.push_back(-1);\n  while(t.size()!=2){\n    for(int i=0;i<t.size()-1;i++){\n      if(t[i]>t[i+1]){\n\tcout<<ans[t[i]]<<\" \";\n\tt.erase(t.begin()+i);\n\tbreak;\n      }\n    }\n  }\n  cout<<ans[0]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define N 40\n\nvector<int> a, b, c;\n\nvoid postOrder(vector<int>::iterator a1, vector<int>::iterator a2, vector<int>::iterator b1, vector<int>::iterator b2)\n{\n    //printf(\"%d %d %d %d\\n\", *a1, *(a2 - 1), *b1, *(b2 - 1));\n    vector<int>::iterator itr1, itr2;\n    c.push_back(*a1);\n    printf(\"%d\\n\", *a1);\n    itr1 = find(b1, b2, *a1); //itrator of root on inorder tree walk\n    if (itr1 > b1)\n        itr2 = find(a1, a2, *(itr1 - 1)); //itrator of left subtree's the most right node on preorder tree walk\n    else\n        itr2 = a1;\n    if (itr2 + 1 < a2 && itr1 + 1 < b2)\n        postOrder(itr2 + 1, a2, itr1 + 1, b2);\n    if (a1 + 1 < itr2+1 && b1 < itr1)\n        postOrder(a1 + 1, itr2+1, b1, itr1);\n}\n\nint main()\n{\n    int n, x;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> x;\n        a.push_back(x);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        cin >> x;\n        b.push_back(x);\n    }\n\n    postOrder(a.begin(), a.end(), b.begin(), b.end());\n\n    for (int i = 0; i < c.size(); i++)\n    {\n        if (i != 0)\n            cout << \" \";\n        cout << c[c.size() - 1 - i];\n    }\n    cout << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n \nstruct node{\n    int l,r;\n};\nnode v[41];\nvector<int> postord;\nvoid dfs(int vi){\n    if(v[vi].l!=-1)dfs(v[vi].l);\n    if(v[vi].r!=-1)dfs(v[vi].r);\n    postord.pb(vi);\n}\nint pre[41],in[41];\nint main(){\n    int n,root;\n    cin>>n;\n    rep(i,n) cin>>pre[i];\n    rep(i,n) cin>>in[i];\n    rep(i,41) v[i].l=v[i].r=-1;\n    root=pre[0];\n    int cp=0,ci=0;\n    while(cp<n-1){\n        v[pre[cp]].l=pre[cp+1];++cp;\n        while(cp<n&&pre[cp]==in[ci]){\n            ++ci;\n            while(ci<n-1&&in[ci]>0&&v[in[ci]].l==in[ci+1]) ++ci;\n            if(ci>=n-1){\n                ++cp;break;\n            }\n            v[in[ci]].r=in[ci+1];++ci;\n            ++cp;\n        } \n    }\n    dfs(root);\n    rep(i,n) cout<<postord[i]<<(i==n-1?\"\":\" \");\n    cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<stdio.h>\n#include<stdlib.h>\n\nvoid to_post(int* A, int* B, int* C, int h)\n{\n    int x = A[0];\n    C[h - 1] = x;\n    if(h < 2) return;\n    int m = 0;\n    while(B[m] != x) m++; \n    if(m > 0) to_post(A + 1, B, C, m);\n    if(h - m - 1 > 0) to_post(A + m + 1, B + m + 1, C + m, h - m - 1);\n}\n\nint main()\n{\n    int *A, *B, *C;\n    int i, n; scanf(\"%d\", &n);\n\n    A = new int [n]; B = new int [n]; C = new int [n];\n    if(A == NULL || B == NULL || C == NULL) exit(EXIT_FAILURE);\n\n    for(i = 0; i < n; i++){ scanf(\"%d\", &A[i]); C[i] = 0; }\n    for(i = 0; i < n; i++){ scanf(\"%d\", &B[n]); }\n\n    to_post(A, B, C, n);\n\n    printf(\"%d\", C[0]); for(i = 1; i < n; i++){ printf(\" %d\", C[i]); } printf(\"\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   for(int i=0;i<(n);++i)\n#define SORT(c)    sort((c).begin(),(c).end())\n#define EPS        1e-10//sample:if((double)>=(double)+EPS)\n#define CLR(a)     memset((&a), 0 ,sizeof(a))//clear memory\n#define dump(x)    cerr << #x << \" = \" << (x) << endl;//debug\n#define debug(x)   cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n//cin,cout release\n//std::cin.tie(0);\n//ios::sync_with_stdio(false);\n\nusing namespace std;\n\nint n,u=0,h=0,m=0;\nint pre[40],in[40],post[40];\n\nvoid reconstruction(int l,int r){\n  if(l>r) return;\n  int root=pre[u++];\n  reconstruction(l,post[root]-1);\n  reconstruction(post[root]+1,r);\n  cout<<root;\n  if(++m!=n)cout<<\" \";\n}\nint main(){\n  cin>>n;\n  rep(i,n)cin>>pre[i];\n  rep(i,n)cin>>in[i];\n  rep(i,n)post[in[i]]=i;\n  reconstruction(0,n-1);\n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint tree(int k,int l, int n);\n\nint a[40],b[40];\n\nint main(void){\n//??\\???\n\tint i,j,n;\n\t\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&b[i]);\n\t}\n\ttree(0,0,n);\n\tprintf(\"\\b\\n\");\n\treturn 0;\n}\n\nint tree(int k,int l, int n){\n\tif(n==0){\n\t} else \n\tif(n==1){\n\t\tprintf(\"%d \",a[k]);\n\t}else{\n\t\tint i=0;\n\t\twhile(b[l+i]!=a[k]){\n\t\t\ti++;\n\t\t}\n\t\t\n\t\ttree(k+1,l,i);\n\t\ttree(k+i+1,l+i+1,n-i-1);\n\t\tprintf(\"%d \",a[k]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nint n;\nint P[42];\nint Pi[42];\nint K[42];\nint Ki[42];\n\n\nstruct N {\n\tint id,l, r;\n\tvoid setid(int pi);\n\tvoid pre();\n\tvoid in();\n\tvoid post();\n};\n\nint root;\nN T[25];\n\n/*\n5\n1 2 3 4 5\n3 2 4 1 5\n\n         1\n   2        5\n 3   4\n*/\n\n// I think this is a O(n) algorizm\n\nvoid N::setid(int _id)\n{\n\tid = _id;\n\tint pid=Pi[id]; // 1\n\tint kid=Ki[id]; // 1\n\tint idl=P[pid+1]; // 2\n\tint kidl=Ki[idl]; // 2\n\tif (kid>kidl) {\n\t\tl=idl;\n\t\tT[l].setid(l);\n\t}\n\tint idr=K[kid+1];\n\tint pidr=Pi[idr];\n\tif(pidr>pid){\n\t\tr=idr;\n\t\tT[r].setid(r);\n\t}\n//\tcout<<id<<' '<<l<<' '<<r<<endl;\n}\n\n\nint main()\n{\n\tmemset(T, 0, sizeof(T));\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>P[i];\n\tP[0]=P[n+1]=0;\n\tfor(int i=1;i<=n;i++) Pi[P[i]]=i;\n\tPi[0]=Pi[n+1]=0;\n\tfor(int i=1;i<=n;i++) cin>>K[i];\n\tK[0]=K[n+1]=0;\n\tfor(int i=1;i<=n;i++) Ki[K[i]]=i;\n\tKi[0]=Ki[n+1]=0;\n\troot = P[1];\n\t\n\tT[root].setid(root);\n\t/*\n\tcout<<\"Preorder\"<<endl;\n\tT[root].pre();\n\tcout<<endl;\n\t\n\tcout<<\"Inorder\"<<endl;\n\tT[root].in();\n\tcout<<endl;\n\t*/\n//\tcout<<\"Postorder\"<<endl;\n\tT[root].post();\n\tcout<<endl;\n}\n\n\t\nvoid N::pre()\n{\n\tcout<<' '<<id;\n\tif(l)T[l].pre();\n\tif(r)T[r].pre();\n}\n\nvoid N::in()\n{\n\tif(l)T[l].in();\n\tcout<<' '<<id;\n\tif(r)T[r].in();\n}\n\nvoid N::post()\n{\n\tif(l)T[l].post();\n\tif(r)T[r].post();\n\tcout<<' '<<id;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \n\nusing namespace std;\n\n\nconst int MAX = 100005;\nconst int NIL = -1;\ntypedef long long ll;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n    if (l >= r)\n        return;\n    int root = pre[pos++];\n    int m = distance(begin(in), find(begin(in), end(in), root));\n    rec(l, m);\n    rec(m + 1, r);\n    post.push_back(root);\n}\n\nvoid solve() {\n    pos = 0;\n    rec(0, pre.size());\n    for (int i = 0; i < n; i++) {\n        if (i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main() {\n    cin >> n;\n\n    for (int i = 0; i < n; i++) {\n        int k; cin >> k; pre.push_back(k);\n    }\n\n    for (int i = 0; i < n; i++) {\n        int k; cin >> k; in.push_back(k);\n    }\n\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAX 102\n#define NIL -1\nint n, pos = 0;\nint Pre[MAX], In[MAX];\n\nvector<int> Post;\n\nint find(int id){\n    for(int i=0;i<n;++i){\n        if(In[i]==id) return i;\n    }\n}\n\nvoid rebuild(int l, int r){\n    if(l>=r) return;\n    int id = Pre[pos];\n    pos++;\n    int m = find(id);\n    rebuild(l,m);\n    rebuild(m+1,r);\n    Post.push_back(id);\n}\n\nint main(){\n\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;++i){\n        scanf(\"%d\",&Pre[i]);\n    }\n    for(int i=0;i<n;++i){\n        scanf(\"%d\",&In[i]);\n    }\n    rebuild(0,n);\n    vector<int>::iterator it;\n    for(it=Post.begin();it!=Post.end()-1;++it){\n        printf(\"%d \",*it);\n    }\n    printf(\"%d\",*it);\n\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\ntemplate<typename T>\nstruct node\n{\n    T n;\n    node<T> *l;\n    node<T> *r;\n    //node(T a, node<T> b, node<T> c){ n = a; l = b; r = c; }\n};\n\ntemplate<typename T>\nnode<T>* reconstruct(T *p, T *i, int l)\n{\n    if (l == 0) return NULL;\n    node<T> *ans = new node<T>;\n    ans->n = *p;\n    if (l == 1) ans->l = ans->r = NULL;\n    else\n    {\n        int j = 0;\n        while (j < l && *p != *(i + j)) j++;\n        ans->l = reconstruct<T>(p + 1, i , j);\n        ans->r = reconstruct<T>(p + j + 1, i + j + 1, l - j - 1);\n    }\n    return ans;\n}\n\ntemplate<typename T>\nT* postsearch(node<T>* root, T *p)\n{\n    if (root->l) p = postsearch(root->l, p);\n    if (root->r) p = postsearch(root->r, p);\n    *p = root->n;\n    return ++p;\n}\n\nint main(void)\n{\n    int N;\n    cin >> N;\n    int pre[40], in[40], post[40];\n    for (int i = 0; i < N; i++) cin >> pre[i];\n    for (int i = 0; i < N; i++) cin >> in[i];\n    node<int> *root = reconstruct<int>(pre, in, N);\n    postsearch<int>(root, post);\n    cout << post[0];\n    for (int i = 1; i < N; i++) cout << \" \" << post[i];\n    cout << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l, int r){\n  if(l>=r) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(),in.end(),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\n\nvoid solve(){\n  int i;\n  pos = 0;\n  rec(0,pre.size());\n  for(i=0;i<n;i++){\n    if(i) cout << \" \";\n    cout << post[i];;\n  }\n  cout << endl;\n}\n\nint main(){\n  int k;\n  cin >> n;\n\n  for(int i =0;i<n;i++){\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for(int i=0;i<n;i++){\n    cin >> k;\n    in.push_back(k);\n  }\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r){\n  if(l>=r)return;\n  int root=pre[pos++];\n  int m=distance(in.begin(),find(in.begin(),in.end(),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\n\nvoid solve(){\n  pos=0;\n  rec(0,pre.size());\n  for(int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<post[i];\n  }\n  cout<<endl;\n}\n\nint main(){\n  int k;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>k;\n    pre.push_back(k);\n  }\n  for(int i=0;i<n;i++){\n    cin>>k;\n    in.push_back(k);\n  }\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint memo;\nint index(int a[], int n, int x){\n    for(int i=0; i<n; i++){\n        if(a[i]==x)\n            return i;\n    }\n    return -1;\n}\nvoid print(int pre[], int in[], int n){\n    int m=index(in, n, pre[0]);\n    if(m>0){\n        print(pre+1, in, m);\n    }\n    if(m<n-1){\n        print(pre+m+1, in+m+1, n-1-m);\n    }\n    cout<<pre[0];\n    if(pre[0]!=memo)  cout<<\" \";\n}\n\nint main(){\n    int n;\n    cin>>n;\n    int pre[n], in[n];\n    for(int i=0; i<n; i++)\n        cin>>pre[i];\n    for(int i=0; i<n; i++)\n        cin>>in[i];\n    memo=pre[0];\n    print(pre, in, n);\n    cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<typeinfo>\n#include<functional>\n#include<complex>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n//0-index\ntemplate<typename T,typename U> //T::要素,U::作用素\nclass late_seg_tree{\nprivate:\n    typedef pair<T,U> node;\n    vector<vector<node>> tree;\n    ll high;\n    T err_T;\n    U err_U;\n    ll err;\n    \n    T F(T,T); //要素のマージ (要素,要素)\n    T G(T,U,ll); //作用素->要素 (要素,作用素,場所)\n    U H(U,U); //作用素のマージ (作用素,作用素)\n    T I(T,U,ll,ll); //作用素->区間要素 (要素,作用素,l,r) [l,r)\n    \n    ll bit_size(ll a){\n        for(int i=1;i<63;i++){\n            if(1<<i >= a){return i;}\n        }\n        return err;\n    }\n    \n    //[l,r)\n    void update(ll h,ll where,ll l,ll r,U u){\n        ll L=where<<(high-h-1);\n        ll R=(where+1)<<(high-h-1);\n        if(r<=L || R<=l){return;}\n        if(h==high-1){tree[h][where].F=G(tree[h][where].F,u,where); return;}\n        if(l<=L && R<=r){\n            tree[h][where].S=H(tree[h][where].S,u);\n            tree[h][where].F=F(tree[h+1][where*2].F,tree[h+1][where*2+1].F);\n            tree[h][where].F=I(tree[h][where].F,tree[h][where].S,L,R);\n        }\n        else{\n            update(h+1,where*2,l,r,u);\n            update(h+1,where*2+1,l,r,u);\n            tree[h][where].F=F(tree[h+1][where*2].F,tree[h+1][where*2+1].F);\n            tree[h][where].F=I(tree[h][where].F,tree[h][where].S,L,R);\n        }\n    }\n    \n    T search(ll h,ll where,ll l,ll r){\n        ll L=where<<(high-h-1);\n        ll R=(where+1)<<(high-h-1);\n        if(r<=L || R<=l){return err_T;}\n        if(h==high-1){return tree[h][where].F;}\n        if(l<=L && R<=r){return tree[h][where].F;}\n        else{\n            update(h+1,where*2,L,R,tree[h][where].S);\n            update(h+1,where*2+1,L,R,tree[h][where].S);\n            tree[h][where].S=err_U;\n            T ret=err_T;\n            ret=F(ret,search(h+1,where*2,l,r));\n            ret=F(ret,search(h+1,where*2+1,l,r));\n            return ret;\n        }\n        return err_T;\n    }\n    \npublic:\n    late_seg_tree(ull size,T err_T,U err_U):err_T(err_T),err_U(err_U){\n        err=1e18+7;\n        high=bit_size(size)+1;\n        tree.resize(high);\n        for(int i=0;i<high;i++){\n            tree[i].resize(1<<i,{err_T,err_U});\n        }\n    }\n    \n    late_seg_tree(vector<T> t,T err_T,U err_U):err_T(err_T),err_U(err_U){\n        err=1e18+7;\n        high=bit_size(t.size())+1;\n        tree.resize(high);\n        for(int i=0;i<high;i++){\n            tree[i].resize(1<<i,{err_T,err_U});\n        }\n        for(int i=0;i<t.size();i++){\n            tree[high-1][i]={t[i],err_U};\n        }\n        for(ll h=high-2;h>=0;h--){\n            for(int i=0;i<tree[h].size();i++){\n                tree[h][i].F=F(tree[h+1][i*2].F,tree[h+1][i*2+1].F);\n            }\n        }\n    }\n    \n    void update(ll l,ll r,U u){\n        update(0,0,l,r,u);\n    }\n    \n    T search(ll l,ll r){\n        return search(0,0,l,r);\n    }\n};\n\n\nlate_seg_tree<pll,pll> T(50,{E,-1},{E,E});\nvector<ll> node;\n\nbool f=true;\n\n//[s,t)\nvoid dfs(ll s,ll t){\n    if(t-s<=0){return;}\n    if(s+1==t){\n        if(f){cout<<node[s]; f=false;}\n        else{cout<<\" \"<<node[s];}\n        return;\n    }\n    pll k=T.search(s,t);\n    ll w=k.S;\n    dfs(s,w);\n    dfs(w+1,t);\n    if(f){cout<<node[w]; f=false;}\n    else{cout<<\" \"<<node[w];}\n}\n\n\nint main(){\n    ll n;\n    cin>>n;\n    vector<ll> a(n);\n    node.resize(n);\n    for(int i=0;i<n;i++){\n        ll b;\n        cin>>b;\n        a[--b]=i;\n    }\n    for(int i=0;i<n;i++){\n        ll b;\n        cin>>b;\n        node[i]=b;\n        T.update(i,i+1,{a[b-1],i});\n    }\n    dfs(0,n);\n    cout<<endl;\n    \n    \n    return 0;\n}\n\n\n\ntemplate<typename T,typename U>\nT late_seg_tree<T,U>::F(T a,T b){\n    return min(a,b);\n}\n\ntemplate<typename T,typename U>\nT late_seg_tree<T,U>::G(T a,U b,ll where){\n    if(b==pll(E,E)){return a;}\n    return b;\n}\n\ntemplate<typename T,typename U>\nU late_seg_tree<T,U>::H(U a,U b){\n    if(a==pll(E,E)){a=b;}\n    return a;\n}\n\ntemplate<typename T,typename U>\nT late_seg_tree<T,U>::I(T a,U b,ll l,ll r){\n    if(b==pll(E,E)){return a;}\n    return b;\n}\n\n"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\nusing namespace std;\n#define NIL -1\nstruct Node{int parent,left,right;};\nstruct Node T[41];\nint n,P[41],I[41];\nint search(int x[],int m,int size){\n    for(int i=0;i<size;i++){\n        if(x[i]==m) return i;\n    }\n    return 0;\n}\nbool tansaku(int target,int x[],int size){\n    for(int i=0;i<size;i++){\n        if(x[i]==target) return true;\n    }\n    return false;\n}\nvoid Postorder(int x){\n    if(x!=NIL){\n        Postorder(T[x].left);\n        Postorder(T[x].right);\n        if(x==P[0]) cout<<x;\n        else cout<<x<<\" \";\n    }\n}\nvoid saisei(int x[],int s,int p,int n){\n    int l=0,r=0,mid=search(x,s,n+1);\n    int L[40],R[40];\n    for(int i=0;i<n+1;i++){\n        if(i<mid){L[l]=x[i];l++;}\n        else if(i>mid){R[r]=x[i];r++;}\n    }\n    if(tansaku(P[p+1],L,l)){\n        T[P[p]].left=P[p+1];\n        T[P[p+1]].parent=P[p];\n        saisei(L,P[p+1],p+1,l);\n    }\n    if(tansaku(P[p+l+1],R,r)){\n        T[P[p]].right=P[p+l+1];\n        T[P[p+l+1]].parent=P[p];\n        saisei(R,P[p+l+1],p+l+1,r);\n    }\n}\nint main(){\n    cin>>n;\n    for(int i=0;i<n;i++) cin>>P[i];\n    for(int i=0;i<n;i++) {\n        cin>>I[i];\n        T[i+1].parent=T[i+1].left=T[i+1].right=NIL;\n    }\n    saisei(I,P[0],0,n-1);\n    Postorder(P[0]); cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r) {\n  if (l>=r) \n    return ;\n  int root=pre[pos++];\n  int m=distance(in.begin(),find(in.begin(),in.end(),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n  \n}\nvoid solve() {\n  pos=0;\n  rec(0,pre.size());\n  for (int i=0; i<n; i++) {\n    if (i) \n      cout<<\" \"<<flush;\n    cout<<post[i]<<flush;\n  }\n  cout<<endl;\n}\nint main() {\n  std::ios::sync_with_stdio(false);\n  cout.tie(0);\n  cin.tie(0);\n  cin>>n;\n  int s;\n  for (int i=0; i<n; i++) {\n    cin>>s;\n    pre.push_back(s);\n  }\n  for (int i=0; i<n; i++) {\n    cin>>s;\n    in.push_back(s);\n  }\n  \n  \n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nusing Weight=int;\nusing DArray=vector<Weight>;\nusing DMatrix=vector<DArray>;\n\nstatic const Weight INF=1<<29;\n\nstruct Edge {\n    size_t src, dst;\n    Weight weight;\n    Edge() {}\n    Edge(size_t src, size_t dst, Weight weight=1):\n        src(src), dst(dst), weight(weight)\n    {}\n};\n\nbool operator<(const Edge &e, const Edge &f) {\n    if (e.weight != f.weight) {\n        return e.weight > f.weight;\n    } else {\n        return e.src!=f.src? e.src<f.src : e.dst<f.dst;\n    }\n}\n\nusing Edges=vector<Edge>;\nusing Vertex=vector<Edge>;\nusing Graph=vector<Vertex>;\n\nvoid join(Graph &g, size_t s, size_t d, Weight w=1) {\n    // non-directed\n    g[s].push_back(Edge(s, d, w));\n    g[d].push_back(Edge(d, s, w));\n}\n\nvoid connect(Graph &g, size_t s, size_t d, Weight w=1) {\n    // directed\n    g[s].push_back(Edge(s, d, w));\n}\n\nsize_t get_root(const Graph &g) {\n    // stores the node type\n    size_t V=g.size();\n    vector<Weight> indeg(V);\n    for (size_t i=0; i<V; ++i)\n        for (const Edge &e: g[i])\n            indeg[e.dst] += e.weight;\n\n    for (size_t i=0; i<V; ++i)\n        if (!indeg[i])\n            return i;\n\n    return 0;\n}\n\ntemplate <class Functor>\nvoid walk_postorder(const Graph &g, size_t root, Functor F) {\n    if (root >= g.size()-1) return;\n\n    for (const Edge &e: g[root])\n        walk_postorder(g, e.dst, F);\n\n    F(root);\n}\n\nvoid reconstruct_tree(\n    vector<size_t>::iterator first1, vector<size_t>::iterator last1,\n    vector<size_t>::iterator first2, vector<size_t>::iterator last2,\n    Graph &g\n) {\n    vector<size_t>::iterator root=find(first2, last2, *first1);\n    if (root <= first2) {\n        connect(g, *root, g.size()-1);\n    } else {\n        connect(g, *root, first1[1]);\n        reconstruct_tree(first1+1, first1+(root-first2)+1, first2, root, g);\n    }\n\n    if (last1-first1 <= root-first2+1) {\n        connect(g, *root, g.size()-1);\n    } else {\n        connect(g, *root, first1[(root-first2)+1]);\n        reconstruct_tree(first1+(root-first2)+1, last1, root+1, last2, g);\n    }\n}\n\nint main() {\n    size_t n;\n    scanf(\"%zu\", &n);\n\n    vector<size_t> preorder(n);\n    for (size_t i=0; i<n; ++i) {\n        scanf(\"%zu\", &preorder[i]);\n        --preorder[i];\n    }\n\n    vector<size_t> inorder(n);\n    for (size_t i=0; i<n; ++i){\n        scanf(\"%zu\", &inorder[i]);\n        --inorder[i];\n    }\n\n    Graph g(n+1);\n    reconstruct_tree(\n        preorder.begin(), preorder.end(), inorder.begin(), inorder.end(), g\n    );\n\n    size_t r=get_root(g);\n\n    vector<size_t> postorder;\n    auto postpush=[=, &postorder](size_t v)->void {\n        if (v < n)\n            postorder.push_back(v+1);\n    };\n\n    walk_postorder(g, r, postpush);\n    for (size_t i=0; i<n; ++i)\n        printf(\"%zu%c\", postorder[i], i<n-1? ' ':'\\n');\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// -*- mode:c++; coding:utf-8; c-basic-offset:2; -*-\n// ALDS1_7_D: Reconstruction of a Tree\n\n#include <cstdio>\nusing uint = unsigned int;\n\nstatic void solve(const uint preorders[], const uint inorders[], const uint indices[],\n                  const uint p_index, const uint i_begin, const uint i_end)\n{\n  if (i_begin >= i_end) {\n    return;\n  }\n  const auto root = preorders[p_index];\n  const auto i_index = indices[root];\n  const auto len = i_index - i_begin;\n  solve(preorders, inorders, indices, (p_index+1), i_begin, i_index);\n  solve(preorders, inorders, indices, (p_index+len+1), (i_index+1), i_end);\n  std::printf(\"%u\", root);\n  std::printf(\"%s\", (p_index == 0) ? \"\\n\" : \" \");\n}\n\nint main()\n{\n  uint n;\n  std::scanf(\"%u\", &n);\n  uint preorders[n];\n  uint inorders[n];\n  uint indices[n+1]; // 0 not used.\n  uint k;\n  for (auto i = 0u; i < n; ++i) {\n    std::scanf(\"%u\", &k);\n    preorders[i] = k;\n  }\n  for (auto i = 0u; i < n; ++i) {\n    std::scanf(\"%u\", &k);\n    inorders[i] = k;\n    indices[k] = i;\n  }\n\n  solve(preorders, inorders, indices, 0, 0, n);\n}\n\n// eof"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n    if(l >= r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(l, m);\n    rec(m+1, r);\n    post.push_back(root);\n}\n\nvoid solve(){\n    pos = 0;\n    rec(0, pre.size());\n    for(int i=0; i<n; ++i){\n        if(i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\n\nint main(){\n    cin >> n;\n    pre.reserve(n); in.reserve(n); post.reserve(n); \n    int k;\n    for(int i=0; i<n; ++i){\n        cin >> k;\n        pre.emplace_back(k);\n    }\n\n    for(int i=0; i<n; ++i){\n        cin >> k;\n        in.emplace_back(k);\n    }\n\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nvector<int> pre, in, post;\nint position = 0;\n\nvoid reconstruction(int left, int right) {\n  if (left >= right) return;\n  int root = pre[position];\n  position++;\n  int in_pos = distance(in.begin(), find(in.begin(), in.end(), root));\n  reconstruction(left, in_pos);\n  reconstruction(in_pos + 1, right);\n  post.push_back(root);\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n\n  int id;\n  for (int i = 0; i < n; i++) {\n    cin >> id;\n    pre.push_back(id);\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> id;\n    in.push_back(id);\n  }\n\n  reconstruction(0, n);\n\n  for (int i = 0; i < n; i++) {\n    if (i != 0) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector< int > preorder;\nvector< int > inorder;\n\nvoid printPost(int preBegin,\n\t       int preEnd,\n\t       int inBegin,\n\t       int inEnd) {\n  if (inBegin == inEnd)\n    return;\n  if (inBegin == (inEnd-1)) {\n    cout << inorder[inBegin];\n    cout << ' ';\n    return;\n  }\n  for (int i = inBegin; i < inEnd; i++)\n    if (inorder[i] == preorder[preBegin]) {\n      printPost(preBegin+1, preEnd, inBegin, i);\n      printPost(preBegin+1, preEnd, i+1, inEnd);\n      cout << inorder[i];\n      if (inorder[i] == preorder[0])\n\tcout << endl;\n      else\n\tcout << ' ';\n      return;\n    }\n}\n  \n\nint main(int argc, char **argv) {\n  ios_base::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  preorder = vector< int > (n, 0);\n  for (int i = 0; i < n; i++)\n    cin >> preorder[i];\n  inorder = vector< int > (n, 0);\n  for (int i = 0; i < n; i++)\n    cin >> inorder[i];\n  printPost(0, n, 0, n);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<list>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\nconst int MAX = 100001;\nconst int NIL = -1;\nstruct Node {\n\tint parent, left, right;\n};\nstruct Node T[MAX];\n\nvector<int> pre, in;\nint p = 0, n;\nbool ok = false;\n\nvoid reconstruction(int l, int r)\n{\n\tif (l >= r)\n\t\treturn;\n\tint c = pre[p++];\n\tint m = find(in.begin(), in.end(), c) - in.begin();\n\treconstruction(l, m);\n\treconstruction(m + 1, r);\n\tif (ok == true)\n\t\tcout << \" \" << c;\n\telse {\n\t\tcout << c;\n\t\tok = true;\n\t}\n}\n\nint main(void)\n{\n\tint node;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> node;\n\t\tpre.push_back(node);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> node;\n\t\tin.push_back(node);\n\t}\n\treconstruction(0, n);\n\tcout << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define NIL -1\nstruct Node{int parent,left,right;};\nstruct Node T[41];\nint n,P[41],I[41];\nint search(int x[],int target,int size){\n    for(int i=0;i<size;i++){\n        if(x[i]==target) return i;\n    }\n    return 0;\n}\nvoid Postorder(int x){\n    if(x!=NIL){\n        Postorder(T[x].left);\n        Postorder(T[x].right);\n        if(x==P[0]) cout<<x;\n        else cout<<x<<\" \";\n    }\n}\nvoid saisei(int x[],int s,int p,int size){\n    int l=0,r=0,mid=search(x,s,size);\n    int L[40],R[40];\n    \n    for(int i=0;i<size;i++){\n        if(i<mid){L[l]=x[i];l++;}\n        else if(i>mid){R[r]=x[i];r++;}\n    }\n    if(l!=0){\n            T[P[p]].left=P[p+1];\n            T[P[p+1]].parent=P[p];\n            saisei(L,P[p+1],p+1,l);\n    }\n    if(r!=0){\n            T[P[p]].right=P[p+l+1];\n            T[P[p+l+1]].parent=P[p];\n            saisei(R,P[p+l+1],p+l+1,r);\n    }\n    \n}\nint main(){\n    cin>>n;\n    for(int i=0;i<n;i++) cin>>P[i];\n    for(int i=0;i<n;i++) {\n        cin>>I[i];\n        T[i+1].parent=T[i+1].left=T[i+1].right=NIL;\n    }\n    saisei(I,P[0],0,n);\n    Postorder(P[0]); cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n  \nint n,pos;\nvector<int> pre,in,post;\n  \nvoid rec(int l,int r){\n    if(l>=r)\n        return;\n    int root = pre[pos++];\n    int m = distance(in.begin(),find(in.begin(),in.end(),root));\n    rec(l,m);\n    rec(m+1,r);\n    post.push_back(root);\n}\n  \nvoid solve(){\n    pos = 0;\n    rec(0,pre.size());\n    for(int i=0;i<n;i++){\n        if(i)\n            cout<<\" \";\n        cout<<post[i];\n    }\n    cout<<endl;\n}\n  \nint main(){\n    int k;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>k;\n        pre.push_back(k);\n    }\n  \n    for(int i=0;i<n;i++){\n        cin>>k;\n        in.push_back(k);\n    }\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include \"pch.h\"\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <climits>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <complex>\n#include <functional>\n#include <ctime>\n#include <cassert>\n#include <fstream>\n#include <stack>\n#include <random>\n\ntypedef long long ll;\ntypedef std::pair<int, int> Pii;\ntypedef std::pair<long long, long long> Pll;\ntypedef std::pair<double, double> Pdd;\n\n#define rip(i, n, s) for (int i = (s);i < (int)( n ); i++)\n#define all(a) a.begin(), a.end()\n#define MM << \" \" <<\n\ntemplate<typename T>\nusing MaxHeap = std::priority_queue<T>;\ntemplate<typename T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\ntemplate<typename T>\ninline bool chmax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T>\ninline bool chmin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T>\nvoid vdeb(std::vector<T> &da) {\n    for (int i = 0;i < da.size();i++) {\n        if (i == da.size() - 1) std::cout << da[i];\n        else std::cout << da[i] << ' ';\n    }\n    std::cout << '\\n';\n}\ntemplate<typename T>\nvoid vdeb(std::vector<std::vector<T>> &da) {\n    for (int i = 0;i < da.size();i++) {\n        std::cout << i << ' ';\n        vdeb(da[i]);\n    }\n    std::cout << '\\n';\n}\n\nusing namespace std;\n\nstruct Node\n{\n    int num;\n    Node *left, *right, *parent;\n    Node(int _num) : num(_num){\n        left = nullptr;\n        right = nullptr;\n        parent = nullptr;\n    }\n    int construct(vector<int> &pre, vector<int> &mid, int le, int ri, int cnt) {\n        if(le <= mid[pre[cnt+1]] && mid[pre[cnt+1]] < mid[num]) {\n            left = new Node(pre[cnt+1]);\n            ++cnt;\n            cnt = left->construct(pre, mid, le, mid[num], cnt);\n        }\n        if(mid[num]+1 <= mid[pre[cnt+1]] && mid[pre[cnt+1]] < ri) {\n            right = new Node(pre[cnt+1]);\n            ++cnt;\n            cnt = right->construct(pre, mid, mid[num]+1, ri, cnt);\n        }\n        return cnt;\n    }\n    void postoder(vector<int> &ret) {\n        if(left) left->postoder(ret);\n        if(right) right->postoder(ret);\n        ret.push_back(num+1);\n    }\n};\n\n\nint main() {\n    int n; cin >> n;;\n    vector<int> pre(n);\n    rip(i,n,0) {\n        cin >> pre[i];\n        --pre[i];\n    }\n    vector<int> mid(n);\n    rip(i,n,0) {\n        int tmp;\n        cin >> tmp;\n        mid[tmp-1] = i;\n    }\n    Node root(pre[0]);\n    pre.push_back(n);\n    mid.push_back(-1);\n    root.construct(pre, mid, 0, n, 0);\n    vector<int> ans(0);\n    root.postoder(ans);\n    vdeb(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nstruct node{\n    int left,right;\n}nodes[100];\n\nint n,pre[100],in[100],inloc[100];\n\nvoid post(int r){\n    if(nodes[r].left!=0)post(nodes[r].left);\n    if(nodes[r].right!=0)post(nodes[r].right);\n    cout<<r;\n    if(r!=pre[0])cout<<\" \";\n}\n\nint main()\n{\n    memset(nodes,0,sizeof(nodes));\n    cin>>n;\n    int i;\n    for(i=0;i<n;i++){\n        cin>>pre[i];\n    }\n    for(i=0;i<n;i++){\n        cin>>in[i];\n        inloc[in[i]]=i;\n    }\n    for(i=0;i<n-1;i++){\n        if(inloc[pre[i+1]]<inloc[pre[i]])nodes[pre[i]].left=pre[i+1];\n        else nodes[in[inloc[pre[i+1]]-1]].right=pre[i+1];\n    }\n    post(pre[0]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nconst int maxn=50;\nint n;\nint dd;\nvector<int> pre,mid,post;\nint l,r;\nint pos;\nvoid rec(int l,int r)\n{\n    if(l>=r) return;\n    int root=pre[pos++];\n    int m=distance(mid.begin(),find(mid.begin(),mid.end(),root));\n    rec(l,m);\n    rec(m+1,r);\n    post.push_back(root);\n}\nint main()\n{\n//    freopen(\"in.txt\",\"r\",stdin);\n    scanf(\"%d\",&n);\n    for(int i=0; i<n; i++)\n    {\n        scanf(\"%d\",&dd);\n        pre.push_back(dd);\n    }\n    for(int i=0; i<n; i++)\n    {\n        scanf(\"%d\",&dd);\n        mid.push_back(dd);\n    }\n    pos=0;\n    rec(0,pre.size());\n    for(int i=0;i<n;i++)\n    {\n        if(i) printf(\" \");\n        printf(\"%d\",post[i]);\n    }\n    printf(\"\\n\");\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\n\nint j=0,k=0;\nvector<int> in,pre;\n\nint search(int n)\n{\n\tint i=0;\n\twhile(in[i]!=n)\n\t{\n\t\ti++;\n\t}\n\treturn i;\n}\n\nvoid rec(int l,int r)\n{\n\tint c,m;\n\t\n\tif(l>r) return;\n\tc=pre[j];\n\tj++;\n\tif(l==r)\n\t{\n\t\tif(++k>1) printf(\" \");\n\t\tprintf(\"%d\",in[l]);\n\t\treturn;\n\t}\n\tm=search(c);\n\trec(l,m-1);\n\trec(m+1,r);\n\tif(++k>1) printf(\" \");\n\tprintf(\"%d\",in[m]);\n\treturn;\n}\n\nint main()\n{\n\tint i,n;\n\t\n\tcin >> n;\n\t\n\tfor(i=0;i<=n-1;i++)\n\t{\n\t\tcin >> pre[i];\n\t}\n\tfor(i=0;i<=n-1;i++)\n\t{\n\t\tcin >> in[i];\n\t}\n\trec(0,n-1);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#pragma GCC optimize (\"O0\")\n#else\n#pragma GCC optimize (\"O3\")\n#endif\n\n\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\nusing ll = long long;\nconst int INF = 1e9 + 7;\nconst int MOD = INF;\nconst ll INF_LL = 1e18 + 7;\n\n#define __overload3(_1, _2, _3, name,...) name\n#define rep(...) __overload3(__VA_ARGS__, repFromUntil, repUntil, repeat)(__VA_ARGS__)\n#define repeat(times) repFromUntil(__name, 0, times)\n#define repUntil(name, times) repFromUntil(name, 0, times)\n#define repFromUntil(name, from, until) for (int name = from, name##__until = (until); name < name##__until; name++)\n#define repFromTo(name, from, to) repFromUntil(name, from, to + 1)\n#define repr(...) __overload3(__VA_ARGS__, reprFromUntil, reprUntil, repeat)(__VA_ARGS__)\n#define reprUntil(name, times) reprFromUntil(name, 0, times)\n#define reprFromUntil(name, from, until) for (int name = until - 1, name##__from = (from); name >= name##__from; name--)\n#define reprFromTo(name, from, to) reprFromUntil(name, from, to + 1)\n\n#define debugos OUT\n#ifdef LOCAL\n#define debug(v) {printf(\"L%d %s > \",__LINE__,#v);debugos<<(v)<<newl;}\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:(v)){debugos<<e<<\" \";}debugos<<newl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){debugos<<(m)[x]<<\" \";}debugos<<newl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){debugos<<(m)[y][x]<<\" \";}debugos<<newl;}}\n#else\n#define debug(v) {\n#define debugv(v) {}\n#define debuga(m,w) {}\n#define debugaa(m,h,w) {}\n#endif\n\n#define newl \"\\n\"\n\n#define all(iter) begin(iter), end(iter)\n\n\ntemplate <class T> bool chmin(T& var, T x) {\n  if (var > x) {\n    var = x;\n    return true;\n  } else return false;\n}\ntemplate <class T> bool chmax(T& var, T x) {\n  if (var < x) {\n    var = x;\n    return true;\n  } else return false;\n}\n\nclass MyScanner {\n  public:\n    template<typename T> void input_integer(T& var) {\n        var = 0; T sign = 1;\n        int cc = getchar();\n        for (; cc<'0' || '9'<cc; cc = getchar())\n            if (cc == '-') sign = -1;\n        for (; '0' <= cc && cc <= '9'; cc = getchar())\n            var = (var << 3) + (var << 1) + cc - '0';\n        var = var * sign;\n    }\n    int c() { char c; while (c = getchar(), c == ' ' or c == '\\n'); return c; }\n    MyScanner& operator>>(char& var) { var = c(); return *this; }\n    MyScanner& operator>>(int& var) { input_integer<int>(var); return *this; }\n    MyScanner& operator>>(ll& var) { input_integer<ll>(var); return *this; }\n    MyScanner& operator>>(string& var) {\n        int cc = getchar();\n        for (; !isvisiblechar(cc); cc = getchar());\n        for (; isvisiblechar(cc); cc = getchar())\n            var.push_back(cc);\n        return *this;\n    }\n    operator int() {\n      int n;\n      *this >> n;\n      return n;\n    }\n    operator ll() {\n      ll n;\n      *this >> n;\n      return n;\n    }\n    private:\n      int isvisiblechar(int c) {\n        return 0x21 <= c && c <= 0x7E;\n      }\n};\nclass MyPrinter {\n  public:\n    template<typename T>\n    void output_integer(T var) {\n        if (var == 0) { putchar('0'); return; }\n        if (var < 0)\n            putchar('-'),\n            var = -var;\n        char stack[32]; int stack_p = 0;\n        while (var)\n            stack[stack_p++] = '0' + (var % 10),\n            var /= 10;\n        while (stack_p)\n            putchar(stack[--stack_p]);\n    }\n    MyPrinter& operator<<(char c) { putchar(c); return *this; }\n    template <typename T>\n    MyPrinter& operator<<(T var) { output_integer<T>(var); return *this; }\n    MyPrinter& operator<<(char* str_p) { while (*str_p) putchar(*(str_p++)); return *this; }\n    MyPrinter& operator<<(const char* str_p) { while (*str_p) putchar(*(str_p++)); return *this; }\n    MyPrinter& operator<<(const string& str) {\n        const char* p = str.c_str();\n        const char* l = p + str.size();\n        while (p < l) putchar(*p++);\n        return *this;\n    }\n    // MyPrinter& operator<<(const modint& var) { output_integer<ll>(var.value); return *this; }\n    template <typename T>\n    void operator()(T x) {\n        *this << x << newl;\n    }\n    template <typename T>\n    void iter(T x, size_t l = -1) {\n      if (l == -1) l = x.size();\n      rep(i, l) *this << x[i] << \" \\n\"[i == l-1];\n    }\n};\nMyScanner IN;\nMyPrinter OUT;\n\nstruct Tree {\n  int id;\n  Tree *left = nullptr, *right = nullptr;\n};\n\nTree *ans = nullptr;\n\nint n;\nvector<int> pre, in;\n\nvoid go(Tree *&root, vector<int>::iterator pre_begin, vector<int>::iterator pre_end, vector<int>::iterator in_begin, vector<int>::iterator in_end) {\n  if (pre_begin == pre_end) {\n    root = new Tree{-1, nullptr, nullptr};\n    return;\n  }\n\n  root = new Tree;\n  root->id = *pre_begin;\n  debug(root->id);\n\n  vector<int>::iterator in_root = find(in_begin, in_end, root->id);\n\n  size_t left_size = in_root - in_begin;\n  vector<int>::iterator pre_mid = pre_begin + 1 + left_size;\n\n  go(root->left, pre_begin + 1, pre_mid, in_begin, in_root);\n  go(root->right, pre_mid, pre_end, in_root + 1, in_end);\n}}\n\nvector<int> res;\n\nvoid acc(Tree *t) {\n  if (t->id == -1) return;\n  acc(t->left);\n  acc(t->right);\n  res.push_back(t->id);\n}\n\nint main() {\n  IN >> n;\n  rep(n) pre.push_back(IN);\n  rep(n) in.push_back(IN);\n  go(ans, all(pre), all(in));\n  acc(ans);\n  OUT.iter(res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\n\nint j=0,k=0;\nvector<int> in,pre;\n\nint search(int n)\n{\n\tint i=0;\n\twhile(in[i]!=n)\n\t{\n\t\ti++;\n\t}\n\treturn i;\n}\n\nvoid rec(int l,int r)\n{\n\tint c,m;\n\tif(l>r) return;\n\tif(l==r)\n\t{\n\t\tif(++k>1) printf(\" \");\n\t\tprintf(\"%d\",in[l]);\n\t\treturn;\n\t}\n\tc=pre[j];\n\tj++;\n\tm=search(c);\n\trec(l,m-1);\n\trec(m+1,r);\n\tif(++k>1) printf(\" \");\n\tprintf(\"%d\",in[m]);\n\treturn;\n}\n\nint main()\n{\n\tint i,n,temp;\n\t\n\tcin >> n;\n\t\n\tfor(i=0;i<=n-1;i++)\n\t{\n\t\tcin >> temp;\n\t\tpre.push_back(temp);\n\t}\n\tfor(i=0;i<=n-1;i++)\n\t{\n\t\tcin >> temp;\n\t\tin.push_back(temp);\n\t}\n\trec(0,n-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, ino, post;\n\nvoid rec(int l, int r) {\n    if (l>=r) return;\n    int root = pre[pos++];\n    int m = distance(ino.begin(), find(ino.begin(), ino.end(), root));\n    rec(1, m);\n    rec(m+1, r);\n    post.push_back(root);\n}\n\nvoid solve() {\n    pos = 0;\n    rec(0, pre.size());\n    for (int i=0; i<n; i++) {\n        if(i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main() {\n    int k;\n    cin >> n;\n    \n    for (int i=0; i<n; i++) {\n        cin >> k;\n        pre.push_back(k);\n    }\n    \n    for (int i=0; i<n; i++) {\n        cin >> k;\n        ino.push_back(k);\n    }\n    \n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <iterator>\n#include <vector>\n\nusing namespace std;\n\nvector<int> pre, in, post;\n\nint pos = 0;\n\nvoid constructPost(int l, int r) {\n\tif (l >= r)\n\t\treturn;\n\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\tconstructPost(l, m);\n\tconstructPost(m + 1, r);\n\n\tpost.push_back(root);\n}\n\nint main() {\n\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint v;\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &v);\n\t\tpre.push_back(v);\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &v);\n\t\tin.push_back(v);\n\t}\n\n\n\tconstructPost(0, pre.size());\n\n\tint i = 0;\n\tfor (auto itr = post.begin(); itr != post.end(); ++itr) {\n\t\tif (i)\n\t\t\tcout << \" \";\n\t\tcout << *itr;\n\t\t++i;\n\t}\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define eol '\\n';\nusing namespace std;\n\nclass Node {\npublic:\n  int id;\n  int l;\n  int r;\n  int p;\n  Node(): id(-1),l(-1),r(-1),p(-1){};\n};\n\nNode* tree;\n\nint create_tree(int parent, vector<int> pre, vector<int> in) {\n    if (pre.size() == 0 && in.size() == 0) {\n      return -1;\n    }\n\n    int root_id = pre[0];\n\n    Node* node = &tree[root_id];\n    node->p = parent;\n    \n    // left\n    vector<int> left_pre;\n    vector<int> left_in;\n\n    int i = 0;\n    int size = in.size();\n    for (; i < size; i++) {\n      if (in[i] == root_id) {\n        break;\n      }\n      left_pre.push_back(pre[i+1]);\n      left_in.push_back(in[i]);\n    }\n    node->l = create_tree(root_id, left_pre, left_in);\n/*\n    vector<int> right_pre;\n    vector<int> right_in;\n\n    i++;\n    for (;i < size; i++) {\n      right_pre.push_back(pre[i]);\n      right_in.push_back(in[i]);\n    }\n    node->r = create_tree(root_id, right_pre, right_in);\n*/\n    return root_id;\n}\n\nvector<int> postorder(int id, vector<int> post) {\n  Node* node = &tree[id];\n  if (node->l != -1) {\n    post = postorder(node->l, post);\n  }\n  if (node->r != -1) {\n    post = postorder(node->r, post);\n  }\n  post.push_back(id);\n\n  return post;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  \n  int n,i;\n  cin >> n;\n\n  tree = new Node[n];\n\n  vector<int> preorder(n);\n  vector<int> inorder(n);\n\n  for (i = 0; i < n; i++) {\n    cin >> preorder[i];\n  }\n  for (i = 0; i < n; i++) {\n    cin >> inorder[i];\n  }\n\n  int root = create_tree(-1, preorder, inorder);\n\n  // post order\n  vector<int> post;\n  post = postorder(root, post);\n\n  // output\n  cout << post[0];\n  for (i = 1; i < n; i++) {\n    cout << \" \" << post[i];\n  }\n  cout << eol;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <vector>\n#include <algorithm>\n\nclass BinaryTree {\npublic:\n    struct Node { int parent = -1, left = -1, right = -1; };\n\n    BinaryTree(int n) : node_num(n) {\n\n        nodes = std::vector<std::unique_ptr<Node>>(node_num);\n        for (int i = 0; i < node_num; i++) {\n            nodes[i] = std::make_unique<Node>();\n        }\n\n        preorder = std::vector<int>(node_num);\n        inorder = std::vector<int>(node_num);\n        for (int i = 0; i < node_num; i++) {\n            std::cin >> preorder[i];\n        }\n        for (int i = 0; i < node_num; i++) {\n            std::cin >> inorder[i];\n        }\n\n        root = preorder[0];\n    }\n    \n    void reconstructTree(int n, int start, int end) {\n        int pos =\n            std::find(inorder.begin() + start, inorder.begin() + end, preorder[n]) - (inorder.begin() + start);\n\n        if (pos + start > start) {\n            nodes[preorder[n] - 1]->left = preorder[n + 1];\n            nodes[preorder[n + 1] - 1]->parent = preorder[n];\n            reconstructTree(n + 1, start, start + pos);\n        }\n        if (pos + start < end - 1) {\n            nodes[preorder[n] - 1]->right = preorder[n + pos + 1];\n            nodes[preorder[n + pos + 1] - 1]->parent = preorder[n];\n            reconstructTree(n + pos + 1, start + pos + 1, end);\n        }\n    }\n\n    void linePostOrder(int i) {\n        if (i == -1) return;\n\n        linePostOrder(nodes[i - 1]->left);\n        linePostOrder(nodes[i - 1]->right);\n\n        postorder.push_back(i);\n    }\n\n    void print() {\n        int i = 0;\n        for (; i < node_num - 1; i++) {\n            std::cout << postorder[i] << \" \";\n        }\n        std::cout << postorder[i] << std::endl;\n    }\n\n    int node_num, root;\n    std::vector<int> preorder, inorder, postorder;\n    std::vector<std::unique_ptr<Node>> nodes;\n};\n\nint main() {\n    int n;\n    std::cin >> n;\n    \n    BinaryTree tree(n);\n    tree.reconstructTree(0, 0, n);\n    tree.linePostOrder(tree.root);\n    tree.print();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nint n,a=0;\nint* pre=new int[n];\nint* in=new int[n];\n\nint distance(int key){\n\tint b;\n\tfor(int i=0;i<n;++i){\n\t\tif(in[i]==key){\n\t\t\tb=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn b;\n}\n\nvoid rec(int left,int right){\n\tif(left>=right)\n\t\treturn;\n\tint root=pre[++a];\n\tint m=distance(root);\n\trec(left,m);\n\trec(m+1,right);\n\tstd::cout<<root<<' ';\n}\n\nint main(){\n\tstd::cin>>n;\n\tfor(int i=0;i<n;++i)\n\t\tstd::cin>>pre[i];\n\tfor(int i=0;i<n;++i)\n\t\tstd::cin>>in[i];\n\trec(0,n);\n\tdelete pre;\n\tdelete in;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define fordebug int hoge;cin>>hoge;\n#define DEKAI 1000000007\n#define INF (1<<28)\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,j,n) for(int i=j;i<n;i++)\n#define floot10 cout<<fixed<<setprecision(10);\n#define int long long\n\nint n;\nint p[50],in[50],ans[50];\n\nint s=0,nsr=0;\nvoid solve(int lit,int rit){\n\tif(lit>=rit) return;\n\tint hoge=p[s];\n\ts++;\n\tlp(i,n){\n\t\tif(in[i]==hoge){\n\t\t\tsolve(lit,i);\n\t\t\tsolve(i+1,rit);\n\t\t\tbreak;\n\t\t}\n\t}\n\tans[nsr]=hoge;\n\tnsr++;\n}\n\nsigned main(){\n\tcin>>n;\n\tlp(i,n)cin>>p[i];\n\tlp(i,n)cin>>in[i];\n\tsolve(0,n);\n\tlp(i,n){\n\t\tif(i!=0) cout<<\" \";\n\t\tcout<<ans[i];\n\t}\n\tcout<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nclass node{\npublic:\n  int parent, left, right;\n};\n\nnode t[25];\n\nvoid pre(int u){\n  if(u == -1) return;\n  cout << \" \" << u;\n  pre(t[u].left);\n  pre(t[u].right);\n}\n\nvoid in(int u){\n  if(u == -1) return;\n  in(t[u].left);\n  cout << \" \" <<  u;\n  in(t[u].right);\n}\n\nvoid po(int u){\n  if(u == -1) return;\n  po(t[u].left);\n  po(t[u].right);\n  cout << \" \" << u;\n}\n\nint s = 0;\nint n;\n\nvoid solve(int l, int r, int pre[], int in[]){\n  if(l >= r) return;\n  int m = pre[s], j;\n  s++;\n  for(j = l; j < r; j++){\n    if(m == in[j]){\n      break;\n    }\n  }\n  solve(l, j, pre, in);\n  solve(j + 1, r, pre, in);\n  if(m == pre[0]) cout << m << endl;\n  else cout << m << \" \";\n}\n\nint main(){\n  cin >> n;\n  int pre[n], in[n];\n\n  for(int i = 0; i < n; i++){\n    cin >> pre[i];\n  }\n  for(int i = 0; i < n; i++){\n    cin >> in[i];\n  }\n\n\n\n  solve(0, n, pre, in);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace  std;\n\nconst int END = -1;\nstruct StNod\n{\n  bool m_bBe;\n  int  m_nParnt;\n  int  m_nLeft;\n  int  m_nRigt;\n\n  StNod() :\n    m_bBe(false), m_nParnt(END), m_nLeft(END), m_nRigt(END)\n  { }\n};\n\nenum EnDir\n{\n  D_Left,\n  D_Right,\n};\n\nvoid fnInput(vector<int> &rvnPodr, vector<int> &rvnIodrSeq)\n{\n  StNod oNod;\n  int nMaxSiz;\n\n  cin >> nMaxSiz;\n  rvnPodr.resize(nMaxSiz + 1);\n  rvnIodrSeq.resize(nMaxSiz + 1);\n\n  for (int i = 1; i < nMaxSiz + 1; i++)\n  {\n    int nNode;\n    cin >> nNode;\n    rvnPodr[i] = nNode;\n  }\n\n  for (int i = 1; i < nMaxSiz + 1; i++)\n  {\n    int nNode;\n    cin >> nNode;\n    rvnIodrSeq[nNode] = i;\n  }\n}\n\nvoid fnStructTree(const vector<int> &cnrvnPodr, const vector<int> &cnrvnIodrSeq, vector<StNod> &rvoNod)\n{\n  int nRoot = cnrvnPodr[1];\n  rvoNod[nRoot].m_bBe = true;\n\n  for (int i = 2; i < cnrvnPodr.size(); i++)\n  {\n    int nParnt = END;\n    int nx = nRoot;\n    EnDir enDir;\n    while (nx != END)\n    {\n      nParnt = nx;\n      if (cnrvnIodrSeq[i] < cnrvnIodrSeq[nx])\n      {\n        nx = rvoNod[nx].m_nLeft;\n        enDir = D_Left;\n      }\n      else\n      {\n        nx = rvoNod[nx].m_nRigt;\n        enDir = D_Right;\n      }\n    }\n\n    int  nNode = cnrvnPodr[i];\n    rvoNod[nNode].m_bBe = true;\n    rvoNod[nNode].m_nParnt = nParnt;\n    if (enDir == D_Left)\n      rvoNod[nParnt].m_nLeft = nNode;\n    else\n      rvoNod[nParnt].m_nRigt = nNode;\n  }\n}\n\nvoid fnPostOrder(const vector<StNod> &cnrvoNod, int nx, int &nOCnt)\n{\n  if (nx == END)  return;\n\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nLeft, nOCnt);\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nRigt, nOCnt);\n  if (nOCnt++) cout << \" \";\n  cout << nx;\n}\n\nvoid fnResult(const vector<StNod> &cnrvoNod, int &nOCnt)\n{\n  int nx = 1;\n  while (cnrvoNod[nx].m_nParnt != END)\n    nx = cnrvoNod[nx].m_nParnt;\n\n  fnPostOrder(cnrvoNod, nx, nOCnt);\n  cout << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vector<int> vnPodr, vnIodrSeq;\n  vector<StNod> voNod;\n\n  fnInput(vnPodr, vnIodrSeq);\n\n  StNod oNod;\n  voNod.resize(vnPodr.size(), oNod);\n  fnStructTree(vnPodr, vnIodrSeq, voNod);\n\n  int nOCnt = 0;\n  fnResult(voNod, nOCnt);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i,n) for(UL i=0; i<(n); i++)\n\nstruct Node{ int l=-1,r=-1,p=-1; };\n\nint N;\nint Pre[100];\nint In[100];\nint Post[100];\n\nvoid MakePost(int pIn, int pPre, int pPost, int size){\n if(size==0) return;\n int v=Pre[pPre];\n int leftsize=0;\n rep(i,size) if(In[pIn+i]==v) leftsize=i;\n MakePost(pIn,pPre+1,pPost,leftsize);\n MakePost(pIn+1+leftsize,pPre+1+leftsize,pPost+leftsize,size-leftsize-1);\n Post[pPost+size-1]=v;\n}\n\nint main() {\n scanf(\"%d\",&N);\n rep(i,N) scanf(\"%d\",&Pre[i]);\n rep(i,N) scanf(\"%d\",&In[i]);\n MakePost(0,0,0,N);\n rep(i,N){ if(i)printf(\" \"); printf(\"%u\",Post[i]); } printf(\"\\n\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\nvi func(vi a, vi b) {\n  int n = a.size();\n  if (n == 0) return vector<int>();\n  int pos = find(b.begin(), b.end(), a[0]) - b.begin();\n  vi na1, nb1, na2, nb2;\n  for (int i = 0; i < pos; i++) {\n    na1.emplace_back(a[i + 1]);\n    nb1.emplace_back(b[i]);\n  }\n  for (int i = 0; i < n - pos - 1; i++) {\n    na2.emplace_back(a[pos + i + 1]);\n    nb2.emplace_back(b[pos + i + 1]);\n  }\n  vi res;\n  for (int i : func(na1, nb1)) {\n    res.emplace_back(i);\n  }\n  for (int i : func(na2, nb2)) {\n    res.emplace_back(i);\n  }\n  res.emplace_back(a[0]);\n  return res;\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  int n;\n  cin >> n;\n  vi a(n), b(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> b[i];\n  }\n  vi ans = func(a, b);\n  for (int i = 0; i < n; i++) {\n    cout << ans[i] << \" \\n\"[i + 1 == n];\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint position;\nvector<int> pre, in, post;\n\nvoid reconstruction(int left, int right)\n{\n    if(left >= right)\n        return;\n    int root = pre[position++];\n    int mid = distance(in.begin(), find(in.begin(), in.end(), root));\n    reconstruction(left, mid);\n    reconstruction(mid + 1, right);\n    post.push_back(root);\n}\n\nvoid solve(int n)\n{\n    position = 0;\n    reconstruction(0, pre.size());\n    for(int i = 0; i < n; i++)\n    {\n        if (i != 0) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    int input;\n    for(int i = 0; i < n; i++)\n    {\n        cin >> input;\n        pre.push_back(input);\n    }\n    for(int i = 0; i < n; i++)\n    {\n        cin >> input;\n        in.push_back(input);\n    }\n    solve(n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int NIL = -1;\nclass Node {\npublic:\n\tint p, l, r;\n\tNode(int pp, int ll, int rr) { p = pp; l = ll; r = rr; }\n};\n\nvector<int> pre;\nvector<int> in;\nvector<int> post;\nint pos;\n\nvoid build( int l, int r )\n{\n\tif( l >= r ) return;\n\tint n = pre[pos];\n\tpos++;\n\tint m = distance( in.begin(), find( in.begin(), in.end(), n ) );\n\tbuild( l, m );\n\tbuild( m + 1, r );\n\tpost.push_back( n );\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tpre = vector<int>( n );\n\tin = vector<int>( n );\n\tfor( int i = 0; i < n; i++ ) {\n\t\tcin >> pre[i];\n\t}\n\tfor( int i = 0; i < n; i++ ) {\n\t\tcin >> in[i];\n\t}\n\n\tbuild( 0, n );\n\n\tfor( int i = 0; i < post.size(); i++ ) {\n\t\tif( i ) cout << \" \";\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n \nstruct node{\n    int l,r;\n};\nnode v[41];\nvector<int> postord;\nvoid dfs(int vi){\n    if(v[vi].l!=0)dfs(v[vi].l);\n    if(v[vi].r!=0)dfs(v[vi].r);\n    postord.pb(vi);\n}\nint pre[41],in[41];\nint main(){\n    int n,root;\n    cin>>n;\n    rep(i,n) cin>>pre[i];\n    rep(i,n) cin>>in[i];\n    rep(i,41) v[i].l=v[i].r=0;\n    root=pre[0];\n    int cp=0,ci=0;\n    while(cp<n-1){\n        v[pre[cp]].l=pre[cp+1];++cp;\n        while(cp<n&&pre[cp]==in[ci]){\n            ++ci;\n            while(ci<n-1&&v[in[ci]].l==in[ci+1]) ++ci;\n            if(ci>=n-1){\n                ++cp;break;\n            }\n            v[in[ci]].r=in[ci+1];++ci;\n            ++cp;\n        } \n    }\n    dfs(root);\n    rep(i,n) cout<<postord[i]<<(i==n-1?\"\":\" \");\n    cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre, in, post;\n\nvec rec(int l, int r){\n  if(l >= r) return;\n     int root = pre[pos++];\n     int m = distance(in.begin(), find(in.begin(), in.end(), root));\n     rec(l,m);\n     rec(m + 1,r);\n     post.push_back(root);\n}\n\nvoid solve(){\n  pos = 0;\n  rec(0, pre.size());\n  for(int i = ; i < n ; i++){\n    if(i) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main(){\n  int k;\n  cin >> n;\n\n  for(int i = 0 ; i < n ; i++){\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for(int i = 0 ; i < n ; i++){\n    cin >> k;\n    in.push_back(k);\n  }\n\n  solve();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n    if (l>=r) return;\n    int root = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));\n    rec(1, m);\n    rec(m+1, r);\n    post.push_back(root);\n}\n\nvoid solve() {\n    pos = 0;\n    rec(0, pre.size());\n    for (int i=0; i<n; i++) {\n        if(i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main() {\n    int k;\n    cin >> n;\n    \n    for (int i=0; i<n; i++) {\n        cin >> k;\n        pre.push_back(k);\n    }\n    \n    for (int i=0; i<n; i++) {\n        cin >> k;\n        in.push_back(k);\n    }\n    \n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define eol '\\n';\nusing namespace std;\n\nclass Node {\npublic:\n  int id;\n  int l;\n  int r;\n  int p;\n  Node(): id(-1),l(-1),r(-1),p(-1){};\n};\n\nNode* tree;\n\nint create_tree(int parent, vector<int> pre, vector<int> in) {\n    if (pre.size() == 0 && in.size() == 0) {\n      return -1;\n    }\n\n    int root_id = pre[0];\n\n    Node* node = &tree[root_id];\n    node->p = parent;\n    \n    // left\n    vector<int> left_pre;\n    vector<int> left_in;\n\n    int i = 0;\n    int size = in.size();\n    for (; i < size; i++) {\n      if (in[i] == root_id) {\n        break;\n      }\n      left_pre.push_back(pre[i+1]);\n      left_in.push_back(in[i]);\n    }\n    node->l = create_tree(root_id, left_pre, left_in);\n\n    vector<int> right_pre;\n    vector<int> right_in;\n\n    i++;\n    for (;i < size; i++) {\n      right_pre.push_back(pre[i]);\n      right_in.push_back(in[i]);\n    }\n    node->r = create_tree(root_id, right_pre, right_in);\n\n    return root_id;\n}\n\nvector<int> postorder(int id, vector<int> post) {\n  Node* node = &tree[id];\n  if (node->l != -1) {\n    post = postorder(node->l, post);\n  }\n  if (node->r != -1) {\n    post = postorder(node->r, post);\n  }\n  post.push_back(id);\n\n  return post;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  \n  int n,i;\n  cin >> n;\n\n  tree = new Node[n];\n\n  vector<int> preorder(n);\n  vector<int> inorder(n);\n\n  for (i = 0; i < n; i++) {\n    cin >> preorder[i];\n  }\n  for (i = 0; i < n; i++) {\n    cin >> inorder[i];\n  }\n\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @copyright (c) 2020 Daisuke Hashimoto\n */\n\n#include <cstdint>\n#include <iostream>\n#include <string>\n\nconstexpr int32_t kMaxNumberOfNodes = 100;\nconstexpr int32_t kTop = -1;\nconstexpr int32_t kInvalid = -2;\n\nenum class NodeType : int32_t { kInternal = 0, kLeaf, kRoot };\n\nvoid CallTreeReconstruction(std::istream &input_stream);\n\nint32_t ConvertFromNodeNumberToNodeIndex(const int32_t node_number);\nint32_t ConvertFromNodeIndexToNodeNumber(const int32_t node_index);\n\nclass Node {\n public:\n  Node() noexcept;\n  ~Node() noexcept;\n  Node(const Node &obj) noexcept;\n  Node &operator=(const Node &rhs) noexcept;\n  Node(Node &&obj) noexcept;\n  Node &operator=(Node &&rhs) noexcept;\n\n  void Activate() noexcept;\n  bool IsValid() const noexcept;\n  void Reset() noexcept;\n  void SetParent(const int32_t parent);\n  int32_t GetParent() const noexcept;\n  void SetChildLeft(const int32_t child_left);\n  int32_t GetChildLeft() const noexcept;\n  void SetChildRight(const int32_t child_right);\n  int32_t GetChildRight() const noexcept;\n  NodeType GetNodeType() const;\n  bool DoesNotHaveAnyChildren() const noexcept;\n  int32_t GetDegree() const noexcept;\n\n  static bool IsInvalidNodeIndex(const int32_t index) noexcept;\n  static bool IsValidNodeIndex(const int32_t index) noexcept;\n  static bool IsInvalidParent(const int32_t parent_index) noexcept;\n\n private:\n  bool is_valid_;\n  int32_t parent_;\n  int32_t child_left_;\n  int32_t child_right_;\n};\n\nstruct IndexRange {\n  int32_t start{-1};\n  int32_t end{-1};\n};\n\nclass TreeReconstruction {\n public:\n  TreeReconstruction() noexcept;\n  ~TreeReconstruction() noexcept;\n\n  void AddResultOfPreorder(const int32_t node_index);\n  void AddResultOfInorder(const int32_t node_index);\n  void ReconstructTree();\n  void ReconstructSubTree(const IndexRange &range_preorder, const IndexRange &range_inorder);\n\n  void AddNode(const int32_t node_index);\n  void MapLeftChild(const int32_t parent_index, const int32_t left_child_index);\n  void MapRightChild(const int32_t parent_index, const int32_t right_child_index);\n  void ConfigureRoot();\n  void Print() const;\n  void Debug() const;\n\n private:\n  TreeReconstruction(const TreeReconstruction &obj) = delete;\n  TreeReconstruction &operator=(const TreeReconstruction &obj) = delete;\n  TreeReconstruction(TreeReconstruction &&obj) = delete;\n  TreeReconstruction &operator=(TreeReconstruction &&obj) = delete;\n\n  static bool OnlyOneNode(const IndexRange &range);\n\n  int32_t CalculateDepth(const int32_t index_node) const;\n  int32_t CalculateHeight(const int32_t index_node) const;\n  void SetTopNode(const int32_t top_node_index);\n  int32_t GetSibling(const int32_t index) const;\n  int32_t FindLocalRootIndexAtInorderResults(const int32_t local_root, const int32_t start_index_in_inorder) const;\n\n  void WalkPostorder(const int32_t node_index) const;\n\n private:\n  int32_t root_;\n  int32_t size_;\n  Node nodes_[kMaxNumberOfNodes];\n  int32_t outputs_preorder_[kMaxNumberOfNodes];\n  int32_t size_outputs_preorder_;\n  int32_t outputs_inorder_[kMaxNumberOfNodes];\n  int32_t size_outputs_inorder_;\n};\n\nnamespace {\nint32_t count;\n} // namespace\n\nvoid CallTreeReconstruction(std::istream &input_stream) {\n  count = 0;\n  input_stream.tie(0);\n  std::ios::sync_with_stdio(false);\n  TreeReconstruction *reconstruct_tree = new TreeReconstruction();\n  try {\n    int32_t number_of_nodes;\n    input_stream >> number_of_nodes;\n\n    for (int32_t i = 0; i < number_of_nodes; ++i) {\n      int32_t node_number;\n      input_stream >> node_number;\n      const int32_t node_index = ConvertFromNodeNumberToNodeIndex(node_number);\n      reconstruct_tree->AddResultOfPreorder(node_index);\n    }\n    for (int32_t i = 0; i < number_of_nodes; ++i) {\n      int32_t node_number;\n      input_stream >> node_number;\n      const int32_t node_index = ConvertFromNodeNumberToNodeIndex(node_number);\n      reconstruct_tree->AddResultOfInorder(node_index);\n    }\n    reconstruct_tree->ReconstructTree();\n    reconstruct_tree->Print();\n  } catch (...) {\n    std::cerr << \"ERROR: CallTreeReconstruction()\" << std::endl;\n    reconstruct_tree->Debug();\n    throw;\n  }\n  delete reconstruct_tree;\n}\n\n// ****************************************************\n\nTreeReconstruction::TreeReconstruction() noexcept\n    : root_(kInvalid), size_(0), size_outputs_preorder_(0), size_outputs_inorder_(0) {}\nTreeReconstruction::~TreeReconstruction() noexcept {}\n\nvoid TreeReconstruction::ReconstructTree() {\n  IndexRange range_preorder;\n  range_preorder.start = 0;\n  range_preorder.end = size_outputs_preorder_ - 1;\n  IndexRange range_inorder;\n  range_inorder.start = 0;\n  range_inorder.end = size_outputs_preorder_ - 1;\n  ReconstructSubTree(range_preorder, range_inorder);\n  ConfigureRoot();\n}\n\nvoid TreeReconstruction::ReconstructSubTree(const IndexRange &range_preorder, const IndexRange &range_inorder) {\n  try {\n    const int32_t local_root_index_in_preorder = range_preorder.start;\n    const int32_t local_root = outputs_preorder_[local_root_index_in_preorder];\n    AddNode(local_root);\n    const int32_t local_root_index_in_inorder = FindLocalRootIndexAtInorderResults(local_root, range_inorder.start);\n\n    const int32_t size_left_subtree = local_root_index_in_inorder - range_inorder.start;\n    if (size_left_subtree == 0) {\n      // DO NOTHING\n    } else if (size_left_subtree == 1) {\n      int32_t left_child = outputs_inorder_[range_inorder.start];\n      AddNode(left_child);\n      MapLeftChild(local_root, left_child);\n    } else {\n      int32_t next_sub_root = outputs_preorder_[local_root_index_in_preorder + 1];\n      MapLeftChild(local_root, next_sub_root);\n      IndexRange next_range_preorder;\n      next_range_preorder.start = local_root_index_in_preorder + 1;\n      next_range_preorder.end = local_root_index_in_preorder + size_left_subtree;\n      IndexRange next_range_inorder;\n      next_range_inorder.start = range_inorder.start;\n      next_range_inorder.end = local_root_index_in_inorder - 1;\n      ReconstructSubTree(next_range_preorder, next_range_inorder);\n    }\n\n    const int32_t size_right_subtree = range_inorder.end - local_root_index_in_inorder;\n    if (size_right_subtree == 0) {\n      // DO NOTHING\n    } else if (size_right_subtree == 1) {\n      int32_t right_child = outputs_inorder_[range_inorder.end];\n      AddNode(right_child);\n      MapRightChild(local_root, right_child);\n    } else {\n      int32_t next_sub_root = outputs_preorder_[local_root_index_in_preorder + 1 + size_left_subtree];\n      MapRightChild(local_root, next_sub_root);\n      IndexRange next_range_preorder;\n      next_range_preorder.start = range_preorder.end - size_right_subtree + 1;\n      next_range_preorder.end = range_preorder.end;\n      IndexRange next_range_inorder;\n      next_range_inorder.start = local_root_index_in_inorder + 1;\n      next_range_inorder.end = range_inorder.end;\n      ReconstructSubTree(next_range_preorder, next_range_inorder);\n    }\n  } catch (...) {\n    std::cerr << \"ERROR: ReconstructSubTree()\" << std::endl;\n    throw;\n  }\n}\n\nvoid TreeReconstruction::Print() const {\n  try {\n    WalkPostorder(root_);\n    std::cout << std::endl;\n  } catch (...) {\n    std::cerr << \"ERROR: Print()\" << std::endl;\n    throw;\n  }\n}\n\nint32_t TreeReconstruction::FindLocalRootIndexAtInorderResults(const int32_t local_root,\n                                                               const int32_t start_index_in_inorder) const {\n  int32_t found_index = -1;\n  for (int32_t index = start_index_in_inorder; index < size_outputs_inorder_; ++index) {\n    if (outputs_inorder_[index] == local_root) {\n      found_index = index;\n      break;\n    }\n  }\n  if (found_index < 0) {\n    std::cerr << \"ERROR: FindLocalRootIndexAtInorderResults(): Not found. local_root=\" << local_root\n              << \", start_index_in_inorder=\" << start_index_in_inorder\n              << \", size_outputs_inorder_=\" << size_outputs_inorder_ << std::endl;\n    throw 1;\n  }\n  return found_index;\n}\n\nbool TreeReconstruction::OnlyOneNode(const IndexRange &range) {\n  if (Node::IsInvalidNodeIndex(range.start)) {\n    std::cerr << \"ERROR: AddResultOfPreorder(): Invalid arg: range.start = \" << range.start << std::endl;\n    throw 1;\n  } else if (Node::IsInvalidNodeIndex(range.end)) {\n    std::cerr << \"ERROR: AddResultOfPreorder(): Invalid arg: range.end = \" << range.end << std::endl;\n    throw 1;\n  } else if (range.end < range.start) {\n    std::cerr << \"ERROR: AddResultOfPreorder(): Invalid arg: range.start = \" << range.start\n              << \", range.start = \" << range.start << std::endl;\n    throw 1;\n  }\n  return (range.start == range.end);\n}\n\nvoid TreeReconstruction::AddResultOfPreorder(const int32_t node_index) {\n  if (Node::IsInvalidNodeIndex(node_index)) {\n    std::cerr << \"ERROR: AddResultOfPreorder(): Invalid arg: node_index = \" << node_index << std::endl;\n    throw 1;\n  } else if (size_outputs_preorder_ >= kMaxNumberOfNodes) {\n    std::cerr << \"ERROR: AddResultOfPreorder(): Data size exceeded a limit = \" << kMaxNumberOfNodes << std::endl;\n    throw 1;\n  }\n  outputs_preorder_[size_outputs_preorder_] = node_index;\n  ++size_outputs_preorder_;\n}\n\nvoid TreeReconstruction::AddResultOfInorder(const int32_t node_index) {\n  if (Node::IsInvalidNodeIndex(node_index)) {\n    std::cerr << \"ERROR: AddResultOfInorder(): Invalid arg: node_index = \" << node_index << std::endl;\n    throw 1;\n  } else if (size_outputs_inorder_ >= kMaxNumberOfNodes) {\n    std::cerr << \"ERROR: AddResultOfInorder(): Data size exceeded a limit = \" << kMaxNumberOfNodes << std::endl;\n    throw 1;\n  }\n  outputs_inorder_[size_outputs_inorder_] = node_index;\n  ++size_outputs_inorder_;\n}\n\nvoid TreeReconstruction::AddNode(const int32_t node_index) {\n  if (Node::IsInvalidNodeIndex(node_index)) {\n    std::cerr << \"ERROR: AddNode(): Invalid arg: node_index = \" << node_index << std::endl;\n    throw 1;\n  } else if (nodes_[node_index].IsValid()) {\n    std::cerr << \"ERROR: AddNode(): Node \" << node_index << \"was already added.\" << std::endl;\n    throw 1;\n  } else if (size_ >= kMaxNumberOfNodes) {\n    std::cerr << \"ERROR: AddNode(): Data size exceeded a limit = \" << kMaxNumberOfNodes << std::endl;\n    throw 1;\n  } else {\n    nodes_[node_index].Activate();\n    size_++;\n  }\n}\n\nvoid TreeReconstruction::MapLeftChild(const int32_t parent_index, const int32_t left_child_index) {\n  if (Node::IsInvalidNodeIndex(parent_index)) {\n    std::cerr << \"ERROR: MapLeftChild(): Invalid arg: parent_index = \" << parent_index << std::endl;\n    throw 1;\n  } else if (Node::IsInvalidNodeIndex(left_child_index)) {\n    std::cerr << \"ERROR: MapLeftChild(): Invalid arg: left_child_index = \" << left_child_index << std::endl;\n    throw 1;\n  } else {\n    try {\n      nodes_[left_child_index].SetParent(parent_index);\n      nodes_[parent_index].SetChildLeft(left_child_index);\n    } catch (...) {\n      std::cerr << \"ERROR: MapLeftChild()\" << std::endl;\n      throw;\n    }\n  }\n}\n\nvoid TreeReconstruction::MapRightChild(const int32_t parent_index, const int32_t right_child_index) {\n  if (Node::IsInvalidNodeIndex(parent_index)) {\n    std::cerr << \"ERROR: MapRightChild(): Invalid arg: parent_index = \" << parent_index << std::endl;\n    throw 1;\n  } else if (Node::IsInvalidNodeIndex(right_child_index)) {\n    std::cerr << \"ERROR: MapRightChild(): Invalid arg: right_child_index = \" << right_child_index << std::endl;\n    throw 1;\n  } else {\n    try {\n      nodes_[right_child_index].SetParent(parent_index);\n      nodes_[parent_index].SetChildRight(right_child_index);\n    } catch (...) {\n      std::cerr << \"ERROR: MapRightChild()\" << std::endl;\n      throw;\n    }\n  }\n}\n\nvoid TreeReconstruction::ConfigureRoot() {\n  int32_t number_of_root = 0;\n  try {\n    for (int32_t node_index = 0; node_index < size_; ++node_index) {\n      if (nodes_[node_index].GetParent() == kInvalid) {\n        SetTopNode(node_index);\n        ++number_of_root;\n      }\n    }\n  } catch (...) {\n    std::cerr << \"ERROR: ConfigureRoot()\" << std::endl;\n    throw;\n  }\n  if (number_of_root != 1) {\n    std::cerr << \"ERROR: ConfigureRoot(): Invalid number_of_root = \" << number_of_root << std::endl;\n    throw 1;\n  }\n}\n\nvoid TreeReconstruction::WalkPostorder(const int32_t node_index) const {\n  // Postorder Tree Walk (後行順巡回)\n  if (Node::IsInvalidNodeIndex(node_index)) {\n    std::cerr << \"ERROR: WalkPostorder(): Invalid arg node_index = \" << node_index << std::endl;\n    throw 1;\n  }\n  try {\n    const int32_t left_child = nodes_[node_index].GetChildLeft();\n    if (Node::IsValidNodeIndex(left_child)) {\n      WalkPostorder(left_child);\n    }\n\n    const int32_t right_child = nodes_[node_index].GetChildRight();\n    if (Node::IsValidNodeIndex(right_child)) {\n      WalkPostorder(right_child);\n    }\n\n    if (count != 0) {\n      std::cout << \" \";\n    }\n    std::cout << ConvertFromNodeIndexToNodeNumber(node_index);\n    ++count;\n  } catch (...) {\n    std::cerr << \"ERROR: WalkPostorder()\" << std::endl;\n    throw 1;\n  }\n}\n\nint32_t TreeReconstruction::GetSibling(const int32_t index) const {\n  int32_t sibling;\n  if (Node::IsInvalidNodeIndex(index)) {\n    std::cerr << \"ERROR: GetSibling(): Invalid arg index = \" << index << std::endl;\n    throw 1;\n  }\n  try {\n    const int32_t parent_index = nodes_[index].GetParent();\n    if (parent_index == kTop) {\n      sibling = -1;\n    } else {\n      const Node &parent = nodes_[parent_index];\n      if (parent.GetChildLeft() == index) {\n        sibling = parent.GetChildRight() >= 0 ? parent.GetChildRight() : -1;\n      } else {\n        sibling = parent.GetChildLeft() >= 0 ? parent.GetChildLeft() : -1;\n      }\n    }\n  } catch (...) {\n    std::cerr << \"ERROR: GetSibling()\" << std::endl;\n    throw;\n  }\n  return sibling;\n}\n\nint32_t TreeReconstruction::CalculateDepth(const int32_t index_node) const {\n  if (Node::IsInvalidNodeIndex(index_node)) {\n    std::cerr << \"ERROR: CalculateDepth(): Invalid arg index = \" << index_node << std::endl;\n    throw 1;\n  }\n  int32_t depth = 0;\n  int32_t current_index_node = index_node;\n  bool was_found = false;\n  try {\n    for (int32_t i = 0; i < size_; ++i) {\n      const int32_t parent_node_index = nodes_[current_index_node].GetParent();\n      if (parent_node_index == kTop) {\n        was_found = true;\n        break;\n      } else {\n        current_index_node = parent_node_index;\n        ++depth;\n      }\n    }\n  } catch (...) {\n    std::cerr << \"ERROR: CalculateDepth()\" << std::endl;\n    throw;\n  }\n  if (!was_found) {\n    std::cerr << \"ERROR: CalculateDepth(): root was not found. index=\" << index_node << std::endl;\n    throw 1;\n  }\n  return depth;\n}\n\nint32_t TreeReconstruction::CalculateHeight(const int32_t index_node) const {\n  if (Node::IsInvalidNodeIndex(index_node)) {\n    std::cerr << \"ERROR: CalculateHeight(): Invalid arg index = \" << index_node << std::endl;\n    throw 1;\n  }\n  int32_t height = 0;\n  try {\n    const int32_t index_child_left = nodes_[index_node].GetChildLeft();\n    int32_t height_from_left = 0;\n    if (Node::IsValidNodeIndex(index_child_left)) {\n      height_from_left = 1 + CalculateHeight(index_child_left);\n    }\n\n    const int32_t index_child_right = nodes_[index_node].GetChildRight();\n    int32_t height_from_right = 0;\n    if (Node::IsValidNodeIndex(index_child_right)) {\n      height_from_right = 1 + CalculateHeight(index_child_right);\n    }\n    height = height_from_left > height_from_right ? height_from_left : height_from_right;\n  } catch (...) {\n    std::cerr << \"ERROR: CalculateHeight()\" << std::endl;\n    throw;\n  }\n  return height;\n}\n\nvoid TreeReconstruction::SetTopNode(const int32_t top_node_index) {\n  try {\n    nodes_[top_node_index].SetParent(kTop);\n    root_ = top_node_index;\n  } catch (...) {\n    std::cerr << \"ERROR: SetTopNode()\" << std::endl;\n    throw;\n  }\n}\n\nvoid TreeReconstruction::Debug() const {\n  const char node_type_str[][20] = {\"internal node\", \"leaf\", \"root\"};\n  try {\n    for (int32_t current_node_index = 0; current_node_index < size_; ++current_node_index) {\n      const Node &cnode = nodes_[current_node_index];\n      std::cerr << \"node \" << ConvertFromNodeIndexToNodeNumber(current_node_index) << \": \";\n      std::cerr << \"parent = \" << ConvertFromNodeIndexToNodeNumber(cnode.GetParent()) << \", \";\n      std::cerr << \"sibling = \" << ConvertFromNodeIndexToNodeNumber(GetSibling(current_node_index)) << \", \";\n      std::cerr << \"degree = \" << cnode.GetDegree() << \", \";\n      std::cerr << \"depth = \" << CalculateDepth(current_node_index) << \", \";\n      std::cerr << \"height = \" << CalculateHeight(current_node_index) << \", \";\n      std::cerr << node_type_str[static_cast<int32_t>(cnode.GetNodeType())] << std::endl;\n    }\n  } catch (...) {\n    std::cerr << \"ERROR: Print()\" << std::endl;\n    throw;\n  }\n}\n\n// ****************************************************\nNode::Node() noexcept : is_valid_(false), parent_(kInvalid), child_left_(kInvalid), child_right_(kInvalid) {}\n\nNode::~Node() noexcept {}\n\nNode::Node(const Node &obj) noexcept\n    : is_valid_(obj.is_valid_), parent_(obj.parent_), child_left_(obj.child_left_), child_right_(obj.child_right_) {}\n\nNode &Node::operator=(const Node &rhs) noexcept {\n  if (this != &rhs) {\n    this->is_valid_ = rhs.is_valid_;\n    this->parent_ = rhs.parent_;\n    this->child_left_ = rhs.child_left_;\n    this->child_right_ = rhs.child_right_;\n  }\n  return *this;\n}\n\nNode::Node(Node &&obj) noexcept\n    : is_valid_(obj.is_valid_), parent_(obj.parent_), child_left_(obj.child_left_), child_right_(obj.child_right_) {\n  obj.Reset();\n}\n\nNode &Node::operator=(Node &&rhs) noexcept {\n  if (this != &rhs) {\n    this->is_valid_ = rhs.is_valid_;\n    this->parent_ = rhs.parent_;\n    this->child_left_ = rhs.child_left_;\n    this->child_right_ = rhs.child_right_;\n    rhs.Reset();  // 無効化\n  }\n  return *this;\n}\n\nvoid Node::Reset() noexcept {\n  this->is_valid_ = false;\n  this->parent_ = kInvalid;\n  this->child_left_ = kInvalid;\n  this->child_right_ = kInvalid;\n}\n\nvoid Node::Activate() noexcept {\n  is_valid_ = true;\n}\n\nbool Node::IsValid() const noexcept {\n  return is_valid_;\n}\n\nvoid Node::SetParent(const int32_t parent) {\n  try {\n    if (IsInvalidParent(parent)) {\n      std::cerr << \"ERROR: SetParent(): Invalid arg: parent = \" << parent << std::endl;\n      throw 1;\n    }\n    parent_ = parent;\n  } catch (...) {\n    std::cerr << \"ERROR: SetParent()\" << std::endl;\n    throw;\n  }\n}\n\nint32_t Node::GetParent() const noexcept {\n  return parent_;\n}\n\nbool Node::IsInvalidParent(const int32_t parent_index) noexcept {\n  return ((parent_index != kTop) && IsInvalidNodeIndex(parent_index));\n}\n\nvoid Node::SetChildLeft(const int32_t child_left) {\n  if (IsInvalidNodeIndex(child_left)) {\n    std::cerr << \"ERROR: SetChildLeft(): Invalid arg: child_left = \" << child_left << std::endl;\n    throw 1;\n  } else {\n    child_left_ = child_left;\n  }\n}\n\nint32_t Node::GetChildLeft() const noexcept {\n  return child_left_;\n}\n\nvoid Node::SetChildRight(const int32_t child_right) {\n  if (IsInvalidNodeIndex(child_right)) {\n    std::cerr << \"ERROR: SetChildRight(): Invalid arg: child_right = \" << child_right << std::endl;\n    throw 1;\n  } else {\n    child_right_ = child_right;\n  }\n}\n\nint32_t Node::GetChildRight() const noexcept {\n  return child_right_;\n}\n\nint32_t Node::GetDegree() const noexcept {\n  int32_t degree = 0;\n  degree += IsValidNodeIndex(GetChildLeft()) ? 1 : 0;\n  degree += IsValidNodeIndex(GetChildRight()) ? 1 : 0;\n  return degree;\n}\n\nbool Node::DoesNotHaveAnyChildren() const noexcept {\n  const bool does_not_have_left_child = IsInvalidNodeIndex(GetChildLeft());\n  const bool does_not_have_right_child = IsInvalidNodeIndex(GetChildRight());\n  return (does_not_have_left_child && does_not_have_right_child);\n}\n\nNodeType Node::GetNodeType() const {\n  if (!IsValid()) {\n    std::cerr << \"ERROR: GetNodeType(): Not valid node.\" << std::endl;\n    throw 1;\n  }\n  NodeType node_type;\n  if (parent_ == kTop) {\n    node_type = NodeType::kRoot;\n  } else if (parent_ == kInvalid) {\n    std::cerr << \"ERROR: GetNodeType(): Invalid parent.\" << std::endl;\n    throw 1;\n  } else if (DoesNotHaveAnyChildren()) {\n    node_type = NodeType::kLeaf;\n  } else {\n    node_type = NodeType::kInternal;\n  }\n  return node_type;\n}\n\nbool Node::IsInvalidNodeIndex(const int32_t index) noexcept {\n  return ((index < 0) || (index >= kMaxNumberOfNodes));\n}\n\nbool Node::IsValidNodeIndex(const int32_t index) noexcept {\n  return !IsInvalidNodeIndex(index);\n}\n\nint32_t ConvertFromNodeNumberToNodeIndex(const int32_t node_number) {\n  if (node_number <= 0) {\n    std::cerr << \"ERROR: ConvertFromNodeNumberToNodeIndex(): Invalid node_number = \" << node_number << std::endl;\n    throw 1;\n  }\n  return node_number - 1;\n}\n\nint32_t ConvertFromNodeIndexToNodeNumber(const int32_t node_index) {\n  int32_t number;\n  try {\n    if (node_index == kTop) {\n      number = -1;\n    } else if (node_index == kInvalid) {\n      number = -1;\n    } else if (Node::IsInvalidNodeIndex(node_index)) {\n      std::cerr << \"ERROR: ConvertFromNodeIndexToNodeNumber(): Invalid node_index = \" << node_index << std::endl;\n      throw 1;\n    } else {\n      number = node_index + 1;\n    }\n  } catch (...) {\n    std::cerr << \"ERROR: ConvertFromNodeIndexToNodeNumber()\" << std::endl;\n    throw;\n  }\n  return number;\n}\n\nint main(int argc, char *argv[]) {\n  try {\n    CallTreeReconstruction(std::cin);\n  } catch (...) {\n    std::cerr << \"ERROR: main()\" << std::endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r){\n  if(l>=r)return;\n  int root=pre[pos];\n  pos++;\n  int m=distance(in.begin(),find(in.begin(),in.end(),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\n\nvoid slove(){\n  pos=0;\n  rec(0,pre.size());\n  for(int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<post[i];\n  }\n  cout<<endl;\n}\n\nint main(){\n  int k;\n\n  cin>>n;\n  \n  for(int i=0;i<n;i++){\n    cin>>k;\n    pre.push_back(k);\n  }\n\n  for(int i=0;i<n;i++){\n    cin>>k;\n    in.push_back(k);\n  }\n\n  slove();\n\n  return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace  std;\n\nconst int END = -1;\nstruct StNod\n{\n  int m_nParnt;\n  int m_nLeft;\n  int m_nRigt;\n\n  StNod() :\n     m_nParnt(END), m_nLeft(END), m_nRigt(END)\n  { }\n};\n\nenum EnDir\n{\n  D_Left,\n  D_Right,\n};\n\nvoid fnInput(vector<int> &rvnPodr, vector<int> &rvnIodrSeq)\n{\n  int nMaxSiz;\n\n  cin >> nMaxSiz;\n  rvnPodr.resize(nMaxSiz);\n  rvnIodrSeq.resize(nMaxSiz + 1);\n\n  for (int i = 0; i < nMaxSiz; i++)\n    cin >> rvnPodr[i];\n\n  for (int i = 1; i < nMaxSiz + 1; i++)\n  {\n    int nNode;\n    cin >> nNode;\n    rvnIodrSeq[nNode] = i;\n  }\n}\n\nvoid fnStructTree(const vector<int> &cnrvnPodr, const vector<int> &cnrvnIodrSeq, vector<StNod> &rvoNod)\n{\n  for (int i = 1; i < cnrvnPodr.size(); i++)\n  {\n    int nParnt = END;\n    int nx = cnrvnPodr[0];\n    EnDir enDir;\n    while (nx != END)\n    {\n      nParnt = nx;\n      if (cnrvnIodrSeq[ cnrvnPodr[i] ] < cnrvnIodrSeq[nx])\n      {\n        nx = rvoNod[nx].m_nLeft;\n        enDir = D_Left;\n      }\n      else\n      {\n        nx = rvoNod[nx].m_nRigt;\n        enDir = D_Right;\n      }\n    }\n\n    rvoNod[ cnrvnPodr[i] ].m_nParnt = nParnt;\n    if (enDir == D_Left)\n      rvoNod[nParnt].m_nLeft = cnrvnPodr[i];\n    else\n      rvoNod[nParnt].m_nRigt = cnrvnPodr[i];\n  }\n}\n\nvoid fnPostOrder(const vector<StNod> &cnrvoNod, int nx)\n{\n  static int stnPrt = 0;\n  if (nx == END)  return;\n\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nLeft);\n  fnPostOrder(cnrvoNod, cnrvoNod[nx].m_nRigt);\n\n  if (stnPrt++) cout << \" \";\n  cout << nx;\n}\n\nvoid fnResult(const vector<StNod> &cnrvoNod)\n{\n  int nx = 1;\n  while (cnrvoNod[nx].m_nParnt != END)\n    nx = cnrvoNod[nx].m_nParnt;\n\n  fnPostOrder(cnrvoNod, nx);\n  cout << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vector<int> vnPodr, vnIodrSeq;\n  fnInput(vnPodr, vnIodrSeq);\n\n  StNod oNod;\n  vector<StNod> voNod(vnIodrSeq.size(), oNod);\n  fnStructTree(vnPodr, vnIodrSeq, voNod);\n  \n  fnResult(voNod);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<string>\n#include<iomanip>\n#include<cstdio>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)   FOR(i,0,n)\n#define MOD 1000000007\n#define MAXS(x,y) (x = max(x,y))\n#define MINS(x,y) (x = min(x,y))\n\nusing namespace std;\n\ntypedef long long int ll;\n\nconst ll INF=(ll)1e18;\n\nvector<int> pre, in, post;\n\nint N;\nint pos = 0;\n\nvoid rec(int l, int r){\n  if(l>=r)return;\n\n  int root = pre[pos];\n  pos++;\n  int m = distance(in.begin(), find(in.begin(),in.end(), root));\n\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\n\nint main(){\n  cin >> N;\n\n  pre.resize(N);\n  in.resize(N);\n  post.resize(0);\n\n  REP(i,N)cin >> pre[i];\n  REP(i,N)cin >> in[i];\n\n  rec(0,N);\n\n  REP(i,N){\n    if(i!=0){\n      cout << \" \";\n    }\n    cout << post[i];\n  }\n  cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint map[25];\nstruct treenode{\n\tint data;\n\ttreenode* leftchild;\n\ttreenode* rightchild;\n\ttreenode(int v) {\n\t\tdata = v;\n\t\tleftchild = NULL;\n\t\trightchild = NULL;\n\t}\n};\n\nvoid remap(int inorder[],int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tmap[inorder[i]] = i;\n\t}\n}\n\ntreenode* bip(int pre[], int n, int offset) {\n\tif (n == 0) return NULL;\n\tint rootval = pre[0];\n\tint i = map[rootval] - offset;\n\ttreenode* root =new treenode(rootval);\n\troot->leftchild = bip(pre + 1, i, offset);\n\troot->rightchild = bip(pre + i + 1, n - i - 1, offset + i + 1);\n\treturn root;\n}\n\nvoid lastorder(treenode* ptr) {\n\tif (ptr) {\n\t\tlastorder(ptr->leftchild);\n\t\tlastorder(ptr->rightchild);\n\t\tcout<< \" \" << ptr->data ;\n\n\t}\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tint* pre = new int(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> pre[i];\n\t}\n\tint* inorder = new int(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> inorder[i];\n\t}\n\tremap(inorder, n);\n\ttreenode* root;\n\troot = bip(pre, n, 0);\n\tlastorder(root);\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define rep(i, n) for(int i=0; i<n; i++)\n#define REP(i, n) for(int i=0; i<=n; i++)\n#define repr(i, n) for(int i=n; i>0; i--)\n#define REPR(i, n) for(int i=n; i>=0; i--)\nconst ll INF = 1LL<<60;\nconst int INT_INF = 1e9;\nconst ll MOD = 1e9+7;\ntemplate<class T> void puts(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nusing namespace std;\n\nint n;\nint pre[41], in[41];\nvector<int> post;\nint pos = 0;\n\n// 木a[left..right]を左と右の部分木に分ける\nvoid recon(int left, int right) {\n    // 終了条件\n    if (left >= right) return;\n\n    int root, root_pos;\n    root = pre[pos++];\n    for (int i = left; i < right; i++) {\n        if (in[i] == root) {\n            root_pos = i;\n        }\n    }\n    recon(left, root_pos);      // 左部分木\n    recon(root_pos + 1, right); // 右部分木\n    post.emplace_back(root);\n}\n\nint main() {\n    cin >> n;\n    rep(i, n) cin >> pre[i];\n    rep(i, n) cin >> in[i];\n\n    recon(0, n);\n    for (int i = 0; i < post.size(); i++) {\n        if (i != post.size() - 1) {\n            cout << post[i] << ' ';\n        } else {\n            cout << post[i] << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,m=0,a[40],b[40],c[41];\nvoid solve(int l,int r){\n  if(l>r)return;\n  int x=a[m++];\n  solve(l,c[x]-1);\n  solve(c[x]+1,r);\n  cout<<x<<(x==a[0]?\"\\n\":\" \");\n}\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>a[i];\n  for(int i=0;i<n;i++)cin>>b[i],c[b[i]]=i;\n  solve(0,n-1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\n\nint j=0,k=0;\nvector<int> in,pre;\n\nint search(int n)\n{\n\tint i=0;\n\twhile(in[i]!=n)\n\t{\n\t\ti++;\n\t}\n\treturn i;\n}\n\nvoid rec(int l,int r)\n{\n\tint c,m;\n\t\n\tif(l>r) return;\n\tc=pre[j];\n\tj++;\n\tif(l==r)\n\t{\n\t\tif(++k>1) printf(\" \");\n\t\tprintf(\"%d\",in[l]);\n\t\treturn;\n\t}\n\tm=search(c);\n\trec(l,m-1);\n\trec(m+1,r);\n\tif(++k>1) printf(\" \");\n\tprintf(\"%d\",in[m]);\n\treturn;\n}\n\nint main()\n{\n\tint i,n,temp;\n\t\n\tcin >> n;\n\t\n\tfor(i=0;i<=n-1;i++)\n\t{\n\t\tcin >> temp;\n\t\tpre.push_back(temp);\n\t}\n\tfor(i=0;i<=n-1;i++)\n\t{\n\t\tcin >> temp;\n\t\tin.push_back(temp);\n\t}\n\trec(0,n-1);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing msi = map<string, int>;\nusing mii = map<int, int>;\nusing psi = pair<string, int>;\nusing pii = pair<int, int>;\nusing vlai = valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1E9\n#define EPS 1E-9\n#define MOD (1E9+7)\n#define PI 3.1415926535897932384626433832795\n\nstd::ostream &operator<<(std::ostream &out, const vector<int> &tgt)\n{\n\tstring s;\n\tfor (int i = 0; i<tgt.size(); i++) {\n\t\ts += (to_string(tgt[i]) + ((i != tgt.size() - 1) ? \" \" : \"\"));\n\t}\n\tout << s;\n\treturn out;\n}\n\nint main() {\n\tint n,in;\n\tcin >> n;\n\tqueue<int> pre;\n\tstack<int> tree;\n\tvector<int> pos;\n\tvector<bool> visited(n+1,false);\n\trep(i, n) {\n\t\tcin >> in;\n\t\tpre.push(in);\n\t}\n\trep(i, n) {\n\t\tcin >> in;\n\t\tif (!visited[in]) {\n\t\t\twhile (1) {\n\t\t\t\tint t = pre.front(); pre.pop();\n\t\t\t\tvisited[t] = true;\n\t\t\t\ttree.push(t);\n\t\t\t\tif (t == in)break;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\twhile (1) {\n\t\t\t\tint t = tree.top();\n\t\t\t\tif (t == in)break;\n\t\t\t\tpos.push_back(t);\n\t\t\t\ttree.pop();\n\t\t\t}\n\t\t}\n\t}\n\twhile (!tree.empty()) {\n\t\tint t = tree.top(); tree.pop();\n\t\tpos.push_back(t);\n\t}\n\tcout << pos << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nstruct BINNODE {\n\tint parent;\n\tint left;\n\tint right;\n\n\tBINNODE () { // default constructor\n\t\tparent=-1;\n\t\tleft=-1;\n\t\tright=-1;\n\t}\n};\n\nvoid make_node(vector<int>& pre, vector<int>& in, pair<int,int> pre_indx, pair<int,int> in_indx, int parent, vector<BINNODE>& node) {\n\tint pre_found=pre_indx.first, in_found=in_indx.first;\n\n\tnode[pre[pre_indx.first]].parent=parent;\n\n\twhile(pre[pre_indx.first]!=in[in_found]) {\n\t\t++in_found;\n\t\t++pre_found;\n\t}\n\n\tif(in_found==in_indx.first) {\n\t\tnode[pre[pre_indx.first]].left=-1;\n\t} else {\n\t\tnode[pre[pre_indx.first]].left=pre[pre_indx.first+1];\n\t\tmake_node(pre,in,{pre_indx.first+1,pre_found},{in_indx.first,in_found-1},pre[0],node);\n\t}\n\tif(in_found==in_indx.second) {\n\t\tnode[pre[pre_indx.first]].right=-1;\n\t} else {\n\t\tnode[pre[pre_indx.first]].right=pre[pre_found+1];\n\t\tmake_node(pre,in,{pre_found+1,pre_indx.second},{in_found+1,in_indx.second},pre[0],node);\n\t}\n\treturn;\n}\n\n\nvoid postorderwalk(vector<BINNODE>&node, int root) {\n\tif(root==-1) return;\n\tpostorderwalk(node,node[root].left);\n\tpostorderwalk(node,node[root].right);\n\tif(node[root].parent==-1) {\n\t\tprintf(\"%d\\n\",root);\n\t} else {\n\t\tprintf(\"%d \",root);\n\t}\n\treturn;\n}\n\nint main() {\n\tint n;\n\tint i;\n\tint root;\n\tvector<int> pre,in;\n\tvector<BINNODE> node;\n\tscanf(\"%d\",&n);\n\tnode.resize(n+1);\n\tpre.resize(n);\n\tin.resize(n);\n\tfor(i=0; i<n; ++i) {\n\t\tscanf(\"%d\",&pre[i]);\n\t}\n\tfor(i=0; i<n; ++i) {\n\t\tscanf(\"%d\",&in[i]);\n\t}\n\troot=pre[0];\n\tmake_node(pre,in,{0,n-1},{0,n-1},-1,node);\n\tpostorderwalk(node,root);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n  if (l >= r) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(l, m);\n  rec(m + 1, r);\n  post.push_back(root);\n};\n\nvoid solve() {\n  pos = 0;\n  rec(0, pre.size());\n  for (int i = 0; i < n; i++) {\n    if (i < n - 1) cout << post[i] << ' ';\n    else cout << post[i] << endl;\n  }\n};\n\nint main() {\n  int k;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> k;\n    pre.push_back(k);\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> k;\n    in.push_back(k);\n  }\n\n  solve();\n};\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define eol '\\n';\nusing namespace std;\n\nclass Node {\npublic:\n  int id;\n  int l;\n  int r;\n  int p;\n  Node(): id(-1),l(-1),r(-1),p(-1){};\n};\n\nNode* tree;\n\nint create_tree(int parent, vector<int> pre, vector<int> in) {\n    if (pre.size() == 0 && in.size() == 0) {\n      return -1;\n    }\n\n    int root_id = pre[0];\n\n    Node* node = &tree[root_id];\n    node->p = parent;\n    \n    // left\n    vector<int> left_pre;\n    vector<int> left_in;\n\n    int i = 0;\n    int size = in.size();\n    for (; i < size; i++) {\n      if (in[i] == root_id) {\n        break;\n      }\n      if (i+1 < size) {\n        left_pre.push_back(pre[i+1]);\n        left_in.push_back(in[i]);\n      }\n    }\n    node->l = create_tree(root_id, left_pre, left_in);\n\n    vector<int> right_pre;\n    vector<int> right_in;\n\n    i++;\n    for (;i < size; i++) {\n      right_pre.push_back(pre[i]);\n      right_in.push_back(in[i]);\n    }\n    node->r = create_tree(root_id, right_pre, right_in);\n\n    return root_id;\n}\n\nvector<int> postorder(int id, vector<int> post) {\n  Node* node = &tree[id];\n  if (node->l != -1) {\n    post = postorder(node->l, post);\n  }\n  if (node->r != -1) {\n    post = postorder(node->r, post);\n  }\n  post.push_back(id);\n\n  return post;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  \n  int n,i;\n  cin >> n;\n\n  tree = new Node[n];\n\n  vector<int> preorder(n);\n  vector<int> inorder(n);\n\n  for (i = 0; i < n; i++) {\n    cin >> preorder[i];\n  }\n  for (i = 0; i < n; i++) {\n    cin >> inorder[i];\n  }\n\n  int root = create_tree(-1, preorder, inorder);\n\n  // post order\n  vector<int> post;\n  post = postorder(root, post);\n\n  // output\n  cout << post[0];\n  for (i = 1; i < n; i++) {\n    cout << \" \" << post[i];\n  }\n  cout << eol;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\n\n\nclass Node{\n//ノードはポインタでもっておこう\npublic:\n  ///ノードの番号\n  int num;\n  //そのノードの親\n  //rootの場合はnullptr\n  Node* p=nullptr;\n  //そのノードの子\n  //葉でなければ少なくとも一つ持つ\n  Node* l=nullptr;Node*r=nullptr;\n};\n\n\n\n//vpはpreorderな配列\n//viはinorderな配列\n//次の配列呼ぼうとした時に0または1なら終了\n//nは配列の長さ\n\nint vec_find(vector<int> v,int x,int v_begin,int n){\n  for(int i=v_begin;i<n+v_begin;i++){\n    if(v[i]==x){return i;}\n  }\n}\n\n\n//確実にindexを間違えているのはわかる\n\nvoid reconstruct_tree(vector<int> vp,int vp_begin,vector<int> vi,int vi_begin,vector<Node>& vn,int n){\n  int c=vec_find(vi,vp[vp_begin],vi_begin,n);\n  //cout << c << endl;\n  if(vi_begin<=c<=vi_begin+n-1){\n    if(c!=vi_begin){\n      //cout << vi[c] << \" \" << vi[vi_begin] << endl;\n      vn[vi[c]-1].l=&vn[vp[vp_begin+1]-1];\n      vn[vp[vp_begin+1]-1].p=&vn[vi[c]-1];\n      reconstruct_tree(vp,vp_begin+1,vi,vi_begin,vn,c-vi_begin);\n    }\n    if(c!=vi_begin+n-1){\n      //cout << vi[c] << \" \" << vi[c+1] << endl;\n      vn[vi[c]-1].r=&vn[vp[vp_begin+(c-vi_begin+1)]-1];\n      vn[vp[vp_begin+(c-vi_begin+1)]-1].p=&vn[vi[c]-1]; reconstruct_tree(vp,vp_begin+(c-vi_begin+1),vi,c+1,vn,n-(c-vi_begin)-1);\n    }\n  }\n}\n\nvoid pos_calc(Node n,vector<int>& v){\n  if(n.l!=nullptr){\n    pos_calc(*(n.l),v);\n  }\n  if(n.r!=nullptr){\n    pos_calc(*(n.r),v);\n  }\n  v.push_back(n.num);\n}\n\nNode root_Node(vector<Node> vn){\n  int lv=(int)(vn.size());\n  for(int i=0;i<lv;i++){\n    if(vn[i].p==nullptr){return vn[i];}\n  }\n}\n\nint main(){\n  int n;cin >> n;\n  vector<Node>v(n);for(int i=0;i<n;i++){v[i].num=i+1;}\n  vector<int>v1(n);for(int i=0;i<n;i++){cin >> v1[i];}\n  vector<int>v2(n);for(int i=0;i<n;i++){cin >> v2[i];}\n  //どのイテレータの範囲(なんばんめか)の部分木を見るかを考える\n  reconstruct_tree(v1,0,v2,0,v,n);\n  /*\n  for(int i=0;i<n;i++){\n    if(v[i].l!=nullptr){cout << i+1 << \" \" << v[i].l->num <<  \" \";}\n    if(v[i].r!=nullptr){cout << v[i].r->num << endl;}\n  }\n  */\n  //cout << 0;\n  vector<int> pos;\n  pos_calc(root_Node(v),pos);\n  for(int i=0;i<n;i++){\n    if(i!=n-1)cout << pos[i] << \" \";\n    else cout << pos[i] << endl;\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int MAX_N = 50;\nvector<int> Preorder(MAX_N), Inorder(MAX_N);\nvector<int> ans;\nint n, pos = 0;\nvoid Solve(int left, int right)\n{\n    if(left >= right) return;\n    int node = Preorder[pos];\n    pos++;\n    for(int i = left; i < right; i++)\n    {\n        if(Inorder[i] == node)\n        {\n            Solve(left, i);\n            Solve(i + 1, right);\n        }\n    }\n    ans.push_back(node);\n}\nint main()\n{\n    cin >> n;\n    for(int i = 0; i < n; i++) cin >> Preorder[i];\n    for(int i = 0; i < n; i++) cin >> Inorder[i];\n    Solve(0, n);\n    for(int i = 0; i < ans.size(); i++)\n    {\n        if(i != 0) cout << \" \";\n        cout << ans[i];\n    }\n    cout << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string> \n#include<algorithm> \n#include<vector> \nusing namespace std; \nint n, pos; \nvector<int> pre, in, post; \nvoid rec(int 1, int r) { \nif ( 1 >= r ) return; \nint root = pre[pos++]; \nint m = distance(in.begin( ) , find(in .begin( ) , in . end( ) , root) ) ; \nrec(l, m) ;\nrec(m + 1 , r);\npost.push_back(root); \n} \nvoid solve() { \npos = 0; \nrec(0, pre . size()) ;\n for ( int i = 0; i < n; i++ ) { \nif ( i ) cout << \" \" ; \ncout << post [i] ; \n} \ncout << endl; \n } \nint main() {\nint k;\ncin >>n;\nfor(int i = 0; i < n; i++){\ncin >> k;\npre.push_back(k);\n}\nfor(int i = 0; i < n; i++){\ncin >> k;\nin.push_back(k);\n}\nsolve();\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,pos;\nvector<int> pre,in,post;\nvoid rec(int l,int r){\n  if(l>=r) return;\n  int root=pre[pos++]:\n  int m=distance(in.begin(),find(int.begin(),in.end(),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\nvoid solve(){\n  pos=0;\n  rec(0,pre.size());\n  REP(int i=0;i<n;i++){\n    if(i) printf(\" \");\n    printf(\"%d\",post[i]);\n  }\n  printf(\"\\n\");\n}\nint main(){\n  int k;\n  scanf(\"%d\",&n);\n  REP(i,n) {scanf(\"%d\",&k);pre.pusf_back(k);}\n  REP(i,n) {scanf(\"%d\",&k);in.pusf_back(k);}\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n\nvoid treeReconstruction(int** pre, int* in, int** post, int left, int right, int size);\nint binarySearch(int* arr, int val, int left, int right);\n\nint main(int argc, char** argv) {\n    int len, *pre, *in, *post, *preTmp, *postTmp;\n\n    scanf(\"%d\", &len);\n    pre = (int *) calloc(sizeof(int), len + 1);\n    in = (int *) calloc(sizeof(int), len + 1);\n    post = (int *) calloc(sizeof(int), len + 1);\n    preTmp = pre;\n    postTmp = post;\n    for (int i = 0; i < len; i++) {\n        scanf(\"%d\", pre + i);\n    }\n    for (int i = 0; i < len; i++) {\n        scanf(\"%d\", in + i);\n    }\n\n    treeReconstruction(&preTmp, in, &postTmp, 0, len, len);\n\n    for (int i = 0; i < len; i++) {\n        if (i) {\n            printf(\" \");\n        }\n        printf(\"%d\", post[i]);\n    }\n    printf(\"\\n\");\n\n    free(pre);\n    free(in);\n    free(post);\n    return 0;\n}\n\nvoid treeReconstruction(int** pre, int* in, int** post, int left, int right, int size) {\n    // printf(\"%p\\n\", pre);\n\n    if (left >= right) {\n        return;\n    }\n\n    int root = *(*pre)++;\n    int posIn = binarySearch(in, root, 0, size);\n\n    if (posIn >= 0) {\n        treeReconstruction(pre, in, post, left, posIn, size);\n        treeReconstruction(pre, in, post, posIn + 1, right, size);\n\n        *(*post)++ = root;\n    } else {\n        return;\n    }\n}\n\nint binarySearch(int* arr, int val, int left, int right) {\n    if (left >= right) {\n        return -1;\n    }\n\n    int halfPos = left + (right - left) / 2;\n\n    if (*(arr + halfPos) == val) {\n        return halfPos;\n    }\n\n    int foundLeft = binarySearch(arr, val, left, halfPos);\n\n    if (foundLeft < 0) {\n        return binarySearch(arr, val, halfPos + 1, right);\n    } else {\n        return foundLeft;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\nusing namespace std;\ntypedef long long ll;\n\nint n, pos;\nvector<int> pre, post, in;\n\nvoid recon(int l, int r){\n    if(l >= r){\n        return;\n    }\n    int c = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(), in.end(), c));\n    recon(l, m);\n    recon(m+1, r);\n    post.push_back(c);\n}\n\nint main() {\n    cin >> n;\n    rep(i,n){\n        int k; cin >> k;\n        pre.push_back(k);\n    }\n    rep(i, n){\n        int k; cin >> k;\n        in.push_back(k);\n    }\n\n    pos = 0;\n    recon(0, n);\n\n    rep(i, n){\n        cout << post[i];\n        if(i != n-1){\n            cout << \" \";\n        } else {\n            cout << endl;\n        }\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint pos = 0;\nvector<int> post_orders;\n\nvoid reconstruct(vector<int> pre, vector<int> in, int L, int R){\n    if(L >= R) return;\n    int c = pre[pos++];\n    int m = distance(in.begin(), find(in.begin(),in.end(), c)); \n    reconstruct(pre, in, L, m);\n    reconstruct(pre, in, m+1, R);\n    post_orders.push_back(c);\n}\n\nint main(){\n    int const N_MAX = 40;\n    int n;\n    cin >> n;\n        \n    vector<int> pre_orders, in_orders;\n    pre_orders.resize(n);\n    in_orders.resize(n);\n    \n    for(size_t i = 0; i < n; i++){\n        cin >> pre_orders[i];\n    }\n    for(size_t i = 0; i < n; i++){\n        cin >> in_orders[i];\n    }    \n    \n    reconstruct(pre_orders, in_orders, 0, pre_orders.size());\n    \n    for(size_t i = 0; i < n; i++){\n        cout << ((i==0)? \"\" : \" \" ) << post_orders[i];\n    }\n    cout << endl;\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <climits>\n#include <cstring>\n#define rep(i, begin, end) for (__typeof(end) i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))\n\nusing namespace std;\n\nconst int N_MAX = 1000000;\n/*\n pre: 4 2 3 1 5\n in:  3 2 4 5 1\n\n*/\nstruct Node{\n  int data;\n  Node* left = NULL;\n  Node* right = NULL;\n};\n\nint ans[N_MAX];\nint ans_ix = 0 ;\nvoid append_to_answer(int n){\n  ans[ans_ix] = n;\n  ans_ix++;\n}\n\nvoid postorder(Node* root){\n\n  if(root == NULL) return;\n  postorder(root->left);\n  postorder(root->right);\n\n  append_to_answer(root->data);\n  // ans += (to_string(root->data) + \" \");\n}\n\n\nvoid print_array(int* arr, int len){\n  rep(i, 0, len){\n    cout << arr[i];\n    if(i==len-1) cout << endl;\n    else cout << \" \";\n  }\n}\n\nNode* solve(int* inorder, int* preorder, int len){\n\n\n  // find root\n  int root_data = preorder[0];\n  Node* root_node = new Node;\n  root_node->data = root_data;\n  if(len==1) return root_node;\n  \n  // count all the num left\n  int left_num=0;\n  while(inorder[left_num] != root_data) left_num++;\n  int right_num = len - left_num - 1;\n  \n  int* left_inorder = new int[left_num];\n  int* right_inorder = new int[right_num];\n  \n  int* left_preorder = new int[left_num];\n  int* right_preorder = new int[right_num];\n\n  int ix=0;\n  int l_ix=0, r_ix=0;\n\n  rep(ix, 0, len){\n    if(inorder[ix] == root_data) continue;\n    if(l_ix<left_num){\n      left_inorder[l_ix] = inorder[ix];\n      l_ix++;\n    }\n    else if(r_ix<right_num){\n      right_inorder[r_ix] = inorder[ix];\n      r_ix++;\n    }\n  }\n  \n  ix = 0; l_ix = 0; r_ix = 0;\n  \n  rep(ix, 1, len){\n    if(l_ix < left_num){\n      left_preorder[l_ix] = preorder[ix];\n      l_ix++;\n    }\n    else if(r_ix < right_num){\n      right_preorder[r_ix] = preorder[ix];\n      r_ix++;\n    }\n  }\n\n  if(left_num>0) root_node->left = solve(left_inorder, left_preorder, left_num);\n  if(right_num>0) root_node->right = solve(right_inorder, right_preorder, right_num);\n  \n  delete[] left_inorder;\n  delete[] right_inorder;\n  delete[] left_preorder;\n  delete[] right_preorder;\n  \n  return root_node;\n  \n}\n\nint main(){\n  int n; cin >> n;\n  int* inorder = new int[n];\n  int* preorder = new int[n];\n  \n  int tmp;\n  rep(i, 0, n){\n    cin >> tmp;\n    preorder[i] = tmp;\n  }\n  rep(i, 0, n){\n    cin >> tmp;\n    inorder[i] = tmp;\n  }\n\n  Node* root = NULL;\n  root = solve(inorder, preorder, n);\n  postorder(root);\n  //rep(i, 0, 2*n-1) cout << ans[i];\n  rep(i, 0, n){\n    cout << ans[i];\n    if(i==n-1) cout << endl;\n    else cout << \" \";\n  }\n\n  delete[] inorder;\n  delete[] preorder;\n  delete root;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint n, pre[50], in[50], post[50], p = 0, cnt = 0;\n\nvoid reconstruction(int left, int right){\n\n  if(left >= right) return ;\n\n  int c = pre[p++]; //next node in preorder                                                                                                                                                                 \n  int m; //the position of variable c in inorder                                                                                                                                                            \n  for(int i = 0;;i++){\n    if(c == in[i]){\n      m = i;\n      break;\n    }\n  }\n\n  reconstruction(left, m); //reconstruction left part tree                                                                                                                                                  \n  reconstruction(m + 1, right); //resonstruction right part tree                                                                                                                                            \n\n  post[cnt++] = c; //store c as postorder                                                                                                                                                                   \n}\n\nint main(){\n\n  //input                                                                                                                                                                                                   \n  cin >> n;\n  for(int i = 0;i < n;i++) cin >> pre[i];\n  for(int i = 0;i < n;i++) cin >> in[i];\n\n  //reconstruction                                                                                                                                                                                          \n  reconstruction(0, n);\n\n  //output                                                                                                                                                                                                  \n  for(int i = 0;i < n;i++){\n    cout << (i?\" \":\"\");\n    cout << post[i];\n  }\n  cout << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct node{\n    int parent;\n    int left;\n    int right;\n    node(){\n        parent = 0;\n        left   = 0;\n        right  = 0;\n    }\n};\n\nvoid restore(vector<int>& pre_o, vector<int>& in_o, vector<node>& T){\n    if (pre_o.size() <= 2) return;\n    int parent = pre_o[1];\n    vector<int> left_in_o;\n    left_in_o.push_back(0);\n    vector<int> right_in_o;\n    right_in_o.push_back(0);\n    int id;\n    for (id = 1; in_o[id] != parent; id++) {\n        left_in_o.push_back(in_o[id]);\n    }\n    for (id++; id < in_o.size(); id++) {\n        right_in_o.push_back(in_o[id]);\n    }\n\n    vector<int> left_pre_o;\n    left_pre_o.push_back(0);\n    vector<int> right_pre_o;\n    right_pre_o.push_back(0);\n    for (id = 2; id <= left_in_o.size(); id++) {\n        left_pre_o.push_back(pre_o[id]);\n    }\n    for (; id < pre_o.size(); id++) {\n        right_pre_o.push_back(pre_o[id]);\n    }\n\n    restore(left_pre_o , left_in_o , T);\n    restore(right_pre_o, right_in_o, T);\n\n    if (left_pre_o.size() > 1) {\n        T[parent].left  = left_pre_o[1];\n        T[left_pre_o[1]].parent  = parent;\n    }\n    if (right_pre_o.size() > 1) {\n        T[parent].right = right_pre_o[1];\n        T[right_pre_o[1]].parent = parent;\n    }\n}\n\nint find_root(vector<node>& T){\n    for (int i = 1; i < T.size(); i++) {\n        if (T[i].parent == 0) return i;\n    }\n}\n\nvoid do_post_order(int id, vector<node>& T, queue<int>& Q){\n    if (id == 0) return;\n    do_post_order(T[id].left , T, Q);\n    do_post_order(T[id].right, T, Q);\n    Q.push(id);\n}\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int> pre_o(n + 1);\n    for (int i = 1; i <= n; i++) {\n        cin >> pre_o[i];\n    }\n    vector<int> in_o(n + 1);\n    for (int i = 1; i <= n; i++) {\n        cin >> in_o[i];\n    }\n\n    vector<node> T(n + 1);\n    restore(pre_o, in_o, T);\n\n    int root = find_root(T);\n    queue<int> Q;\n    do_post_order(root, T, Q);\n    cout << Q.front();\n    Q.pop();\n    while (!Q.empty()) {\n        cout << \" \" << Q.front();\n        Q.pop();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n) - 1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\n#define unless(c) if (!(c))\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing ll = long long;\t\tusing LD = long double;\nusing VB = vector<bool>;\tusing VVB = vector<VB>;\nusing VI = vector<int>;\t\tusing VVI = vector<VI>;\nusing VL = vector<ll>;\t\tusing VVL = vector<VL>;\nusing VS = vector<string>;\tusing VD = vector<LD>;\nusing PII = pair<int, int>;\tusing VP = vector<PII>;\nusing PLL = pair<ll, ll>;\tusing VPL = vector<PLL>;\ntemplate<class T>using PQ = priority_queue<T>;\ntemplate<class T>using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = (int)1e9;\nconstexpr ll inf_ll = (ll)1e18, MOD = 1000000007;\nconstexpr LD PI = M_PI, EPS = 1e-12;\n\n// --- input --- //\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked fwrite\n#define fflush_unlocked fflush\n#endif\nclass Input {\n\tstatic int gc() {\n\t\treturn getchar_unlocked();\n\t}\n\ttemplate<class T>static void i(T& v) {\n\t\tcin >> v;\n\t}\n\tstatic void i(char& v) {\n\t\twhile (isspace(v = gc()));\n\t}\n\tstatic void i(bool& v) {\n\t\tv = in<char>() != '0';\n\t}\n\tstatic void i(string& v) {\n\t\tv.clear(); char c; for (i(c); !isspace(c); c = gc())v += c;\n\t}\n\tstatic void i(int& v) {\n\t\tbool neg = false; v = 0; char c; i(c);\n\t\tif (c == '-') { neg = true; c = gc(); }\n\t\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\t\tif (neg)v = -v;\n\t}\n\tstatic void i(long long& v) {\n\t\tbool neg = false; v = 0; char c; i(c);\n\t\tif (c == '-') { neg = true; c = gc(); }\n\t\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\t\tif (neg)v = -v;\n\t}\n\tstatic void i(double& v) {\n\t\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; i(c);\n\t\tif (c == '-') { neg = true; c = gc(); }\n\t\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\t\tif (c == '.')adp = true;\n\t\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\t\telse v = v * 10 + (c - '0');\n\t\t}\n\t\tif (neg)v = -v;\n\t}\n\tstatic void i(long double& v) {\n\t\tlong double dp = 1; bool neg = false, adp = false; v = 0; char c; i(c);\n\t\tif (c == '-') { neg = true; c = gc(); }\n\t\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\t\tif (c == '.')adp = true;\n\t\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\t\telse v = v * 10 + (c - '0');\n\t\t}\n\t\tif (neg)v = -v;\n\t}\n\ttemplate<class T, class U>static void i(pair<T, U>& v) {\n\t\ti(v.first); i(v.second);\n\t}\n\ttemplate<class T>static void i(vector<T>& v) {\n\t\tfor (auto& e : v)i(e);\n\t}\n\tstruct InputV {\n\t\tint n, id;\n\t\tInputV(int _n) :n(_n), id(0) {}\n\t\tInputV(const pair<int, int>& nm) :n(nm.first), id(nm.second) {}\n\t\ttemplate<class T>operator vector<T>() {\n\t\t\tvector<T> v(n); i(v); return v;\n\t\t}\n\t\ttemplate<class T>operator vector<vector<T>>() {\n\t\t\tvector<vector<T>> v(n, vector<T>(id)); i(v); return v;\n\t\t}\n\t};\npublic:\n\tstatic string get_line() {\n\t\tstring v; char c;\n\t\tfor (i(c); c != '\\n' && c != '\\0'; c = gc())v += c;\n\t\treturn v;\n\t}\n\ttemplate<class T>static T in() {\n\t\tT v; i(v); return v;\n\t}\n\ttemplate<class T>operator T()const {\n\t\treturn in<T>();\n\t}\n\tint operator--(int)const {\n\t\treturn in<int>() - 1;\n\t}\n\tInputV operator[](int n)const {\n\t\treturn InputV(n);\n\t}\n\tInputV operator[](const pair<int, int>& n)const {\n\t\treturn InputV(n);\n\t}\n\tvoid operator()()const {}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t)const {\n\t\ti(h); operator()(forward<T>(t)...);\n\t}\n#define input(T) Input::in<T>()\n#define INT input(int)\n#define LL input(ll)\n#define STR input(string)\n#define inputs(T, ...) T __VA_ARGS__; in(__VA_ARGS__)\n#define ini(...) inputs(int, __VA_ARGS__)\n#define inl(...) inputs(ll, __VA_ARGS__)\n#define ins(...) inputs(string, __VA_ARGS__)\n}in;\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc };\n\tvoid p(int v)const {\n\t\tif (v < 0)p('-'), v = -v;\n\t\tchar b[10]; int i = 0;\n\t\twhile (v)b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i)b[i++] = '0';\n\t\twhile (i--)p(b[i]);\n\t}\n\tvoid p(long long v)const {\n\t\tif (v < 0)p('-'), v = -v;\n\t\tchar b[20]; int i = 0;\n\t\twhile (v)b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i)b[i++] = '0';\n\t\twhile (i--)p(b[i]);\n\t}\n\tvoid p(bool v)const {\n\t\tp(v ? B.t : B.f);\n\t}\n\tvoid p(char v)const {\n\t\tputchar_unlocked(v);\n\t}\n\tvoid p(const char* v)const {\n\t\tfwrite_unlocked(v, 1, strlen(v), stdout);\n\t}\n\tvoid p(double v)const {\n\t\tprintf(\"%.20f\", v);\n\t}\n\tvoid p(long double v)const {\n\t\tprintf(\"%.20Lf\", v);\n\t}\n\ttemplate<class T> void p(const T& v)const {\n\t\tcout << v;\n\t}\n\ttemplate<class T, class U>void p(const pair<T, U>& v)const {\n\t\tp(v.first); p(D.d); p(v.second);\n\t}\n\ttemplate<class T>void p(const vector<T>& v)const {\n\t\trep(i, sz(v)) { if (i)p(D.d); p(v[i]); }\n\t}\n\ttemplate<class T>void p(const vector<vector<T>>& v)const {\n\t\trep(i, sz(v)) { if (i)p(D.l); p(v[i]); }\n\t}\npublic:\n\tOutput& operator()() {\n\t\tp(D.l); return *this;\n\t}\n\ttemplate<class H>Output& operator()(H&& h) {\n\t\tp(h); p(D.l);\n\t\treturn *this;\n\t}\n\ttemplate<class H, class...T>Output& operator()(H&& h, T&& ...t) {\n\t\tp(h); p(D.d);\n\t\treturn operator()(forward<T>(t)...);\n\t}\n\ttemplate<class It>Output& range(const It& l, const It& r) {\n\t\tfor (It i = l; i != r; i++) { if (i != l)p(D.d); p(*i); } p(D.l);\n\t\treturn *this;\n\t}\n\ttemplate<class T>Output& range(const T& a) {\n\t\trange(a.begin(), a.end());\n\t\treturn *this;\n\t}\n\ttemplate<class...T>void exit(T&& ...t) {\n\t\toperator()(forward<T>(t)...);\n\t\tstd::exit(EXIT_SUCCESS);\n\t}\n\tOutput& flush() {\n\t\tfflush_unlocked(stdout);\n\t\treturn *this;\n\t}\n\tOutput& set(const BoolStr& b) {\n\t\tB = b; return *this;\n\t}\n\tOutput& set(const DivStr& d) {\n\t\tD = d; return *this;\n\t}\n\tOutput& set(const char* t, const char* f) {\n\t\tB = BoolStr(t, f); return *this;\n\t}\n}out;\n\n// --- step --- //\ntemplate<class T>struct Step {\n\tclass It {\n\t\tT a, b, c;\n\tpublic:\n\t\tconstexpr It() : a(T()), b(T()), c(T()) {}\n\t\tconstexpr It(T _b, T _c, T _s) : a(_b), b(_c), c(_s) {}\n\t\tconstexpr It& operator++() {\n\t\t\t--b; a += c; return *this;\n\t\t}\n\t\tconstexpr It operator++(int) {\n\t\t\tIt tmp = *this; --b; a += c; return tmp;\n\t\t}\n\t\tconstexpr const T& operator*()const {\n\t\t\treturn a;\n\t\t}\n\t\tconstexpr const T* operator->()const {\n\t\t\treturn &a;\n\t\t}\n\t\tconstexpr bool operator==(const It& i)const {\n\t\t\treturn b == i.b;\n\t\t}\n\t\tconstexpr bool operator!=(const It& i)const {\n\t\t\treturn !(b == i.b);\n\t\t}\n\t\tconstexpr T start()const {\n\t\t\treturn a;\n\t\t}\n\t\tconstexpr T count()const {\n\t\t\treturn b;\n\t\t}\n\t\tconstexpr T step()const {\n\t\t\treturn c;\n\t\t}\n\t};\n\tconstexpr Step(T b, T c, T s) : be(b, c, s) {}\n\tconstexpr It begin()const {\n\t\treturn be;\n\t}\n\tconstexpr It end()const {\n\t\treturn en;\n\t}\n\tconstexpr T start()const {\n\t\treturn be.start();\n\t}\n\tconstexpr T count()const {\n\t\treturn be.count();\n\t}\n\tconstexpr T step()const {\n\t\treturn be.step();\n\t}\n\tconstexpr T sum()const {\n\t\treturn start() * count() + step() * (count() * (count() - 1) / 2);\n\t}\n\toperator vector<T>()const {\n\t\treturn as_vector();\n\t}\n\ttemplate<class F>void each(const F& f)const {\n\t\tfor (T i : *this)f(i);\n\t}\n\tauto as_vector()const {\n\t\tvector<T> res; res.reserve(count()); each([&](T i) {res.push_back(i); }); return res;\n\t}\n\ttemplate<class F, class U = decay_t<result_of_t<F(T)>>>auto map(const F& f)const {\n\t\tvector<U> res; res.reserve(count()); each([&](T i) {res.push_back(f(i)); }); return res;\n\t}\n\ttemplate<class F>auto select(const F& f)const {\n\t\tvector<T> res; each([&](T i) {if (f(i))res.push_back(i); }); return res;\n\t}\n\ttemplate<class F>int count_if(const F& f)const {\n\t\tint res = 0; each([&](T i) {if (f(i))++res; }); return res;\n\t}\n\ttemplate<class F>T find_if(const F& f)const {\n\t\tfor (T i : *this)if (f(i))return i; return 0;\n\t}\n\ttemplate<class F>auto max_by(const F& f)const {\n\t\tauto v = map(f); return *max_element(v.begin(), v.end());\n\t}\n\ttemplate<class F>auto min_by(const F& f)const {\n\t\tauto v = map(f); return *min_element(v.begin(), v.end());\n\t}\n\ttemplate<class F>bool all_of(const F& f)const {\n\t\tfor (T i : *this)if (!f(i))return false; return true;\n\t}\n\ttemplate<class F>bool any_of(const F& f)const {\n\t\tfor (T i : *this)if (f(i))return true; return false;\n\t}\n\ttemplate<class F, class U = decay_t<result_of_t<F(T)>>>auto sum(const F& f)const {\n\t\tU res = 0; each([&](T i) {res += static_cast<U>(f(i)); }); return res;\n\t}\n\tusing value_type = T;\n\tusing iterator = It;\nprivate:\n\tIt be, en;\n};\ntemplate<class T>inline constexpr auto step(T a) {\n\treturn Step<T>(0, a, 1);\n}\ntemplate<class T>inline constexpr auto step(T a, T b) {\n\treturn Step<T>(a, b - a, 1);\n}\ntemplate<class T>inline constexpr auto step(T a, T b, T c) {\n\treturn Step<T>(a, a < b ? (b - a - 1) / c + 1 : 0, c);\n}\n\n// --- functions --- //\ninline namespace {\n\ttemplate<class T>inline void Sort(T& a) {\n\t\tsort(all(a));\n\t}\n\ttemplate<class T>inline void RSort(T& a) {\n\t\tsort(rall(a));\n\t}\n\ttemplate<class T, class F>inline void Sort(T& a, const F& f) {\n\t\tsort(all(a), f);\n\t}\n\ttemplate<class T, class F>inline void RSort(T& a, const F& f) {\n\t\tsort(rall(a), f);\n\t}\n\ttemplate<class T>inline T Sorted(T a) {\n\t\tSort(a); return a;\n\t}\n\ttemplate<class T>inline T RSorted(T a) {\n\t\tRSort(a); return a;\n\t}\n\ttemplate<class T, class F>inline T Sorted(T& a, const F& f) {\n\t\tSort(a, f); return a;\n\t}\n\ttemplate<class T, class F>inline T RSorted(T& a, const F& f) {\n\t\tRSort(a, f); return a;\n\t}\n\ttemplate<class T, class F>inline void SortBy(T& a, const F& f) {\n\t\tsort(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline void RSortBy(T& a, const F& f) {\n\t\tsort(rall(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T>inline void Reverse(T& a) {\n\t\treverse(all(a));\n\t}\n\ttemplate<class T>inline void Unique(T& a) {\n\t\ta.erase(unique(all(a)), a.end());\n\t}\n\ttemplate<class T>inline void Uniq(T& a) {\n\t\tSort(a); Unique(a);\n\t}\n\ttemplate<class T>inline void Rotate(T& a, int left) {\n\t\trotate(a.begin(), a.begin() + left, a.end());\n\t}\n\ttemplate<class T>inline T Reversed(T a) {\n\t\tReverse(a); return a;\n\t}\n\ttemplate<class T>inline T Uniqued(T a) {\n\t\tUnique(a); return a;\n\t}\n\ttemplate<class T>inline T Uniqed(T a) {\n\t\tUniq(a); return a;\n\t}\n\ttemplate<class T>inline T Rotated(T a, int left) {\n\t\tRotate(a, left); return a;\n\t}\n\ttemplate<class T>inline auto Max(const T& a) {\n\t\treturn *max_element(all(a));\n\t}\n\ttemplate<class T>inline auto Min(const T& a) {\n\t\treturn *min_element(all(a));\n\t}\n\ttemplate<class T>inline int MaxPos(const T& a) {\n\t\treturn max_element(all(a)) - a.begin();\n\t}\n\ttemplate<class T>inline int MinPos(const T& a) {\n\t\treturn min_element(all(a)) - a.begin();\n\t}\n\ttemplate<class T, class F>inline auto MaxBy(const T& a, const F& f) {\n\t\treturn *max_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline auto MinBy(const T& a, const F& f) {\n\t\treturn *min_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class U>inline int Count(const T& a, const U& v) {\n\t\treturn count(all(a), v);\n\t}\n\ttemplate<class T, class F>inline int CountIf(const T& a, const F& f) {\n\t\treturn count_if(all(a), f);\n\t}\n\ttemplate<class T, class U>inline int Find(const T& a, const U& v) {\n\t\treturn find(all(a), v) - a.begin();\n\t}\n\ttemplate<class T, class F>inline int FindIf(const T& a, const F& f) {\n\t\treturn find_if(all(a), f) - a.begin();\n\t}\n\ttemplate<class T, class U = typename T::value_type>inline U Sum(const T& a) {\n\t\treturn accumulate(all(a), U());\n\t}\n\ttemplate<class T, class U>inline bool Includes(const T& a, const U& v) {\n\t\treturn find(all(a), v) != a.end();\n\t}\n\ttemplate<class T, class F>inline auto Sum(const T& v, const F& f) {\n\t\treturn accumulate(next(v.begin()), v.end(), f(*v.begin()), [&](auto a, auto b) {return a + f(b); });\n\t}\n\ttemplate<class T, class U>inline int Lower(const T& a, const U& v) {\n\t\treturn lower_bound(all(a), v) - a.begin();\n\t}\n\ttemplate<class T, class U>inline int Upper(const T& a, const U& v) {\n\t\treturn upper_bound(all(a), v) - a.begin();\n\t}\n\ttemplate<class T, class F>inline void RemoveIf(T& a, const F& f) {\n\t\ta.erase(remove_if(all(a), f), a.end());\n\t}\n\ttemplate<class F>inline auto Vector(size_t size, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t)>>> res(size);\n\t\tfor (size_t i = 0; i < size; ++i)res[i] = f(i);\n\t\treturn res;\n\t}\n\ttemplate<class T>inline auto Grid(size_t h, size_t w, const T& v = T()) {\n\t\treturn vector<vector<T>>(h, vector<T>(w, v));\n\t}\n\ttemplate<class T>inline auto Slice(const T& v, size_t i, size_t len) {\n\t\treturn i < v.size() ? T(v.begin() + i, v.begin() + min(i + len, v.size())) : T();\n\t}\n\ttemplate<class T, class F>inline auto Each(T& v, F&& f) {\n\t\tfor (auto& i : v)f(i);\n\t}\n\ttemplate<class T, class F>inline auto Each(const T& v, F&& f) {\n\t\tfor (const auto& i : v)f(i);\n\t}\n\ttemplate<class T, class F>inline auto Select(const T& v, const F& f) {\n\t\tT res;\n\t\tfor (const auto& e : v)if (f(e))res.push_back(e);\n\t\treturn res;\n\t}\n\ttemplate<class T, class F>inline auto Map(const T& v, F&& f) {\n\t\tvector<decay_t<result_of_t<F(typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (const auto& e : v)res[i++] = f(e);\n\t\treturn res;\n\t}\n\ttemplate<class T, class F>inline auto MapIndex(const T& v, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t, typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (auto it = v.begin(); it != v.end(); ++it, ++i)res[i] = f(i, *it);\n\t\treturn res;\n\t}\n\ttemplate<class T, class F>inline auto TrueIndex(const T& v, const F& f) {\n\t\tvector<size_t> res;\n\t\tfor (size_t i = 0; i < v.size(); ++i)if (f(v[i]))res.push_back(i);\n\t\treturn res;\n\t}\n\ttemplate<class T, class U = typename T::value_type>inline auto Indexed(const T& v) {\n\t\tvector<pair<U, int>> res(v.size());\n\t\tfor (int i = 0; i < (int)v.size(); ++i)res[i] = make_pair(static_cast<U>(v[i]), i);\n\t\treturn res;\n\t}\n\tinline auto operator*(string s, size_t n) {\n\t\tstring res;\n\t\tfor (size_t i = 0; i < n; ++i)res += s;\n\t\treturn res;\n\t}\n\ttemplate<class T>inline auto& operator<<(vector<T>& v, const vector<T>& v2) {\n\t\tv.insert(v.end(), all(v2)); return v;\n\t}\n\ttemplate<class T>inline T Ceil(T n, T id) {\n\t\treturn (n + id - 1) / id;\n\t}\n\ttemplate<class T>inline T Ceil2(T n, T id) {\n\t\treturn Ceil(n, id) * id;\n\t}\n\ttemplate<class T>inline T Tri(T n) {\n\t\treturn (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1);\n\t}\n\ttemplate<class T>inline T nC2(T n) {\n\t\treturn (n & 1) ? (n - 1) / 2 * n : n / 2 * (n - 1);\n\t}\n\ttemplate<class T>inline T Mid(const T& l, const T& r) {\n\t\treturn l + (r - l) / 2;\n\t}\n\tinline int pop_count(int n) {\n\t\treturn bitset<32>(n).count();\n\t}\n\tinline int pop_count(ll n) {\n\t\treturn bitset<64>(n).count();\n\t}\n\ttemplate<class T>inline bool chmax(T& a, const T& b) {\n\t\tif (a < b) { a = b; return true; } return false;\n\t}\n\ttemplate<class T>inline bool chmin(T& a, const T& b) {\n\t\tif (a > b) { a = b; return true; } return false;\n\t}\n\ttemplate<class T>inline bool inRange(const T& v, const T& min, const T& max) {\n\t\treturn min <= v && v < max;\n\t}\n\ttemplate<class T>inline bool isSquere(T n) {\n\t\tT s = sqrt(n); return s * s == n || (s + 1) * (s + 1) == n;\n\t}\n\ttemplate<class T = ll>inline T BIT(int b) {\n\t\treturn T(1) << b;\n\t}\n\ttemplate<class T>inline T Gcd(T n, T id) {\n\t\treturn id ? Gcd(id, n % id) : n;\n\t}\n\ttemplate<class T>inline T Lcm(T n, T id) {\n\t\treturn n / Gcd(n, id) * id;\n\t}\n\ttemplate<class T, class U = typename T::value_type>inline U Gcdv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Gcd<U>);\n\t}\n\ttemplate<class T, class U = typename T::value_type>inline U Lcmv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Lcm<U>);\n\t}\n\ttemplate<class T>inline T Pow(T a, T n) {\n\t\tT r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; } return r;\n\t}\n\ttemplate<class T>inline T Powmod(T a, T n, T id = MOD) {\n\t\tT r = 1; while (n > 0) { if (n & 1)r = r * a % id, n--; else a = a * a % id, n /= 2; }return r;\n\t}\n}\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// ---------------------------------------------------------------- //\n\nint main() {\n\tint n = in;\n\tVI A = in[n], B = in[n];\n\n\tauto dfs = [&](auto&& f, VI a, VI b)->VI {\n\t\tassert(sz(a) == sz(b));\n\t\tif (a.empty()) {\n\t\t\treturn {};\n\t\t}\n\n\t\tint v = a.front(), m = sz(a);\n\t\tint left = Find(b, v),right = n - 1 - left;\n\t\tVI L = f(f, VI(range_it(a, 1, 1 + left)), VI(range_it(b, 0, left)));\n\t\tVI R = f(f, VI(range_it(a, 1 + left, m)), VI(range_it(b, 1 + left, m)));\n\t\tVI res; res << L << R << VI{ v };\n\t\treturn res;\n\t};\n\n\tout(dfs(dfs, A, B));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid reconstruction(int l, int r){\n  if ( l >= r){return ;}\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  reconstruction(l, m);\n  reconstruction(m + 1, r);\n\n  post.push_back(root);\n}\n\nvoid solve() {\n  pos = 0;\n  reconstruction(0, n);\n  for ( int i = 0; i < n; i++){\n    if (i) { cout << \" \";}\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main(){\n  cin >> n;\n\n  int tmp;\n  for ( int i = 0; i < n; i++){ cin >> tmp; pre.push_back(tmp); }\n  for ( int i = 0; i < n; i++){ cin >> tmp; in.push_back(tmp); }\n\n  solve();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint preorder[40],inorder[40];\n\nvoid print_postorder(int lp,int rp,int li,int ri);\n\nint main(){\n  int n;\n  cin >> n;\n  for(int i=0;i<n;++i)\n    cin >> preorder[i];\n  for(int i=0;i<n;++i)\n    cin >> inorder[i];\n\n  print_postorder(0,n,0,n);\n\n  return 0;\n}\n\n\n// lp<= i&&i<rp\nvoid print_postorder(int lp,int rp,int li,int ri){\n  if(lp==rp) return;\n  //cout << \"[\" << lp << \",\" << rp << \"] [\" << li << \",\" << ri << \"]\" << endl;\n  int root = preorder[lp];\n  int num = 0;\n  for(int i=li;i<ri&&inorder[i]!=root;++i){\n    num++;\n  }\n  print_postorder(lp+1,lp+1+num,li,li+num);\n  print_postorder(lp+1+num,rp,li+num+1,ri);\n\n  cout << preorder[lp];\n  if(lp == 0){\n    cout << endl;\n  }else{\n    cout << \" \";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct Node {\n  int id;\n  int parent;\n  int left;\n  int right;\n\n  Node() : id(), parent(-1), left(-1), right(-1) {}\n  };\n\nstatic vector<Node> TREE(25);\n\nstatic void inputNode(Node& node, int id) {\n  node.id = id;\n  cin >> node.left >> node.right;\n}\n\nstatic vector<int> preorder(25), inorder(25);\n\nstatic void inputOrder(vector<int>& order, int num) {\n  for (int i = 0; i < num; i++) {\n    cin >> order[i];\n  }\n}\n\nstatic int current = 0, outIndex = 0;\n\nstatic int next() {\n  int c = preorder[current];\n  current++;\n  return c;\n}\n\nstatic int find(int c) {\n  auto it = find(inorder.begin(), inorder.end(), c); \n  return distance(inorder.begin(), it);\n}\n\nstatic void reconstruction(int l, int r) {\n  if (l >= r) {\n    return;\n  } \n  int c = next();\n  int m = find(c);\n  reconstruction(l, m);\n  reconstruction(m + 1, r);\n\n  if (outIndex != 0) {\n    cout << \" \" << c;\n  } else {\n    cout << c;\n  }\n  outIndex++;\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  inputOrder(preorder, n);\n  inputOrder(inorder, n);\n  reconstruction(0, n);\n\n  cout << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r)\n{\n  if(l >= r) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(l, m);\n  rec(m+1,r);\n  post.push_back(root);\n}\n\nvoid solve()\n{\n  pos = 0;\n  rec(0, pre.size());\n  for(int i = 0; i < n; i++)\n  {\n    if(i) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main()\n{\n  int k;\n  cin >> n;\n\n  for(int i = 0; i < n; i++)\n  {\n    cin >> k;\n    pre.push_back(k);\n  }\n  for(int i = 0; i < n; i++)\n  {\n    cin >> k;\n    in.push_back(k);\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\nusing ll = long long;\nusing v1 = vector<int>;\nusing v2 = vector<vector<int>>;\nusing v3 = vector<vector<char>>;\n\nint N;\nv1 pre, in, post;\nint pos = 0;\nvoid sep(int i, int e){//i, j, eはin用, pはpre\n\tif(i>e) return;\n\tif(i == e){\n\t\tpost.push_back(in[i]);\n\t\tpos++;\n\t\treturn;\n\t}\n\tint root = pre[pos];\n\tpos++;\n\tint j = 0;\n\twhile(in[j] != root){\n\t\tj++;\n\t}\n\tsep(i, j-1);\n\tsep(j+1, e);\n\tpost.push_back(root);\n}\n\nvoid solve(){\n\tsep(0, N-1);\n\trep(i, N){\n\t\tcout << post[i];\n\t\tif(i != N-1) cout << \" \";\n\t\tif(i == N-1) cout << endl;\n\t}\n}\n\nint main(){\n\t cin >> N;\n\t rep(i, N){\n\t\t int x;\n\t\t cin >> x;\n\t\t pre.push_back(x);\n\t }\n\t rep(i, N){\n\t\t int x;\n\t\t cin >> x;\n\t\t in.push_back(x);\n\t }\n\t solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;  // nは木の数，posは位置情報\nvector<int> pre, in, post;\n\nvoid rec(int l, int r)\n{\n    // preで出てきた節点をmとする\n    // この節点mに対してinで探索をすると，左部分木(mより前の木)と右部分木(mより後の木)がわかる\n    if (l >= r) { // lがr以上の時探索ができないので終了\n        return;\n    }\n    int root = pre[pos++];  // preで出てきた節点をmとする\n    int m = distance(in.begin(), find(in.begin(), in.end(), root));  // inにおけるmの位置\n    rec(l, m);  // そのnodeより左側を探索する．左側から探索\n    rec(m + 1, r);  // 右側を探索．右側はあとで探索\n    post.push_back(root);  // leafまで行けばもう探索できずpostの中に入る\n}\n\nvoid solve()\n{\n    pos = 0;\n    rec(0, pre.size());  // postを復元する\n    for (int i = 0; i < n; i++) {\n        if (i) cout << \" \";\n        cout << post[i];\n    }\n    cout << endl;\n}\n\nint main()\n{\n    int k;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> k;\n        pre.push_back(k);  // preorderで通ったnodeをpreに入れる\n    }\n\n    for (int i = 0; i < n; i++) {\n        cin >> k;\n        in.push_back(k);  // inorderで通ったnodeをinに入れる\n    }\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <iterator>\n#include<algorithm>\nstatic const int NIL = -1;\nstatic const int NumberChild = 2;\nclass Tree {\nprivate:\n\tint id;\n\tint parent;\n\tint child[NumberChild];\n\npublic:\n\tTree() {\n\t\tid = child[0] = child[1] = parent = NIL;\n\t}\n\tvoid AddParent(int ID) {\n\t\tparent = ID;\n\t\treturn;\n\t}\n\tvoid AddID(int ID) {\n\t\tid = ID;\n\t\treturn;\n\t}\n\tvoid AddChild(std::vector<int>&Child) {\n\t\tfor (unsigned int i = 0; i < Child.size(); ++i) {\n\t\t\tchild[i] = Child[i];\n\n\t\t}\n\n\t\treturn;\n\t}\n\tint GetRoot(std::vector<Tree> nodes, int ID) {\n\t\tint RootID = ID;\n\t\tif (RootID != NIL&&nodes[RootID].parent != NIL) {\n\t\t\tRootID = GetRoot(nodes, nodes[RootID].parent);\n\t\t}\n\t\treturn RootID;\n\t}\n\tvoid PreorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPreorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid InorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tstd::cout << \" \" << nodes[ID].id;\n\t\t\tInorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid PostorderTreeWalk(std::vector<Tree> nodes, int ID) {\n\t\tif (ID != NIL) {\n\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[0]);\n\t\t\tPostorderTreeWalk(nodes, nodes[ID].child[1]);\n\t\t\tif(nodes[ID].id!=NIL)std::cout << \" \" << nodes[ID].id;\n\t\t}\n\n\t\treturn;\n\t}\n\tvoid GetVctorPostorderTreeWalk(std::vector<Tree> nodes, std::vector<int>& returnvector, int ID) {\n\t\t\n\t\tif (ID != NIL) {\n\n\t\t\tGetVctorPostorderTreeWalk(nodes,  returnvector, nodes[ID].child[0]);\n\t\t\tGetVctorPostorderTreeWalk(nodes, returnvector, nodes[ID].child[1]);\n\t\t\tif (nodes[ID].id != NIL)returnvector.push_back(nodes[ID].id) ;\n\t\t}\n\n\t\treturn ;\n\t}\n\tvoid Reconstruct(const std::vector<int>Pre, const std::vector<int>In, std::vector<Tree> &nodes, const int Root,int &cnt) {\n\t\t\n\t\tint m = std::distance(In.begin(), std::find(In.begin(), In.end(), Root));\n\t\n\t\t//nodes[cnt].AddID(Root);\n\t\tnodes[Root].AddID(Root);\n\t\tif (m == 0||Root==NIL) { return; }\n\t\tstd::vector<int>PreLeft;\n\t\n\t\tstd::copy(&Pre[1], &Pre[m]+1, std::back_inserter(PreLeft));\n\t\t\n\t\tstd::vector<int>PreRight;\n\t\t\n\t\tstd::copy(&Pre[m+1 ], &Pre[Pre.size()-1]+1, std::back_inserter(PreRight));\n\t\t\n\t\tstd::vector<int>InLeft;\n\t\tstd::copy(&In[0], &In[m-1]+1, std::back_inserter(InLeft));\n\t\t\n\n\t\tstd::vector<int> InRight;\n\t\tstd::copy(&In[m]+1, &In[In.size() - 1]+1, std::back_inserter(InRight));\n\t\t\n\n\t\tstd::vector<int> child(2);\n\t\tchild[0] =  PreLeft.empty() ? NIL : PreLeft[0] ;\n\t\tchild[1] = PreRight.empty() ? NIL : PreRight[0] ;\n\t\t//nodes[cnt].AddChild(child);\n\t\tnodes[Root].AddChild(child);\n\t\tfor (unsigned int i = 0; i < child.size(); ++i) {\n\n\t\t\tnodes[child[i]].AddParent(Root);\n\t\t}\n\t\tReconstruct(PreLeft, InLeft, nodes, PreLeft[0], ++cnt);\n\t\tReconstruct(PreRight, InRight, nodes, PreRight[0], ++cnt);\n\t}\n};\n\nvoid SetVector(std::vector<int>&InputVector) {\n\tfor (unsigned int i = 0; i < InputVector.size(); ++i) {\n\t\tstd::cin >> InputVector[i];\n\t}\n\treturn;\n}\nint main(void) {\n\n\tint n;\n\tstd::cin >> n;\n\tstd::vector<int>Pre(n);\n\tstd::vector<int>In(n);\n\tSetVector(Pre);\n\tSetVector(In);\n\tstd::vector<Tree> nodes(n+1);\n\t//ReconstructWithNoParent\n\tint cnt = 0;\n\tnodes[1].Reconstruct(Pre, In, nodes, Pre[0],cnt);\n\n\t//nodes[1].PostorderTreeWalk(nodes, 1);\n\tstd::vector<int>Print;\n\tnodes[1].GetVctorPostorderTreeWalk(nodes, Print, 1);\n//Print=nodes[1].GetVctorPostorderTreeWalk(nodes, 1);\nfor (unsigned int i = 0; i < Print.size(); ++i) {\n\tif (i) { std::cout << \" \"; }\n\tstd::cout<<Print[i];\n\tif(i==Print.size()-1){ std::cout << std::endl; }\n}\n\t\n\t\n//\tsystem(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n_node, pos;\nvector<int> pre, in, post;\n\n#if LOCAL\n// Split Function\nvector<int> split_int(string input,char del){\n    vector<int> output;\n    string substr;\n    for(const char c : input){\n        if(c == del){\n          output.push_back(atoi(substr.c_str()));\n          substr.clear();\n        } else {\n          substr += c;\n        }\n    }\n    output.push_back(atoi(substr.c_str()));\n    return output;\n}\n\nvector<string> split_str(string input,char del){\n    vector<string> output;\n    string substr;\n    for(const char c : input){\n        if(c == del){\n          output.push_back(substr);\n          substr.clear();\n        } else {\n          substr += c;\n        }\n    }\n    output.push_back(substr);\n    return output;\n}\n#endif // for local test\n\n\nvoid rec(int l, int r) {\n\tif (l >= r) {\n\t\treturn;\n\t}\n\tint root = pre[pos++];\n\tint m = distance(in.begin(), find(in.begin(), in.end(), root));\n\trec(l, m);\n\trec(m + 1, r);\n\tpost.push_back(root);\n}\n\nvoid solve() {\n\tpos = 0;\n\trec(0, pre.size());\n\tfor (int i = 0; i < n_node; i++) {\n\t\tif (i) {\n\t\t\tcout << ' ';\n\t\t}\n\t\tcout << post[i];\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tint id_node, right, left;\n\tscanf(\"%d\", &n_node);\n\n#if LOCAL // for local test\n\tvector<string> input = {\"1 2 3 4 5\",\n\t \t\t\t\t\t\t\"3 2 4 1 5\"};\n\t// input for local test\n\tvector<int> vec_tmp;\n\tpre = split_int(input[0], ' ');\n\tin = split_int(input[1], ' ');\n#endif // for local test\n\n#ifndef LOCAL // for online test\n\tfor (int i = 0; i < 2; i++) {\n\t\tint input;\n    \tfor (int j = 0; j < n_node; j++) {\n\t\t\tscanf(\"%d\", &input);\n\t\t\tif (i == 0) {\n\t\t\t\tpre.push_back(input);\n\t\t\t} else {\n\t\t\t\tin.push_back(input);\n\t\t\t}\n\t\t}\n    }\n#endif // for online test\n\tsolve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r){\n  if(l>=r)return;\n  int root=pre[pos++];\n  //cout<<\"root\"<<root<<endl;\n  int m=distance(in.begin(),find(in.begin(),in.end(),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\n\nvoid solve(){\n  pos=0;\n  rec(0,pre.size());\n  for(int i=0;i<n;i++){\n    if(i)cout<<\" \";\n    cout<<post[i];\n  }\n  cout<<endl;\n}\n\nint main(){\n  int k;\n  cin>>n;\n\n  for(int i=0;i<n;i++){\n    cin>>k;\n    pre.push_back(k);\n  }\n\n  for(int i=0;i<n;i++){\n    cin>>k;\n    in.push_back(k);\n  }\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint pre[50],in[50],post[50];\nint n,pos,idx;\nvoid dfs(int l,int r){\n  if(l>=r) return;\n  int root=pre[pos++];\n  int m=-1;\n  for(int i=l;i<r;i++)\n    if(in[i]==root) m=i;\n  dfs(l,m);\n  dfs(m+1,r);\n  post[idx++]=root;\n}\nsigned main(){\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>pre[i];\n  for(int i=0;i<n;i++) cin>>in[i];\n  pos=idx=0;\n  dfs(0,n);\n  for(int i=0;i<n;i++)\n    cout<<post[i]<<\" \\n\"[i==n-1];\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <algorithm>\n \nenum TNodeType {ntRoot, ntInternal, ntLeaf};\ntemplate<typename T>\nclass TTree;\n \ntemplate<typename T>\nclass TNode\n{\n    const T FValue;\n    TNode* FParent;\n    TNode* FLeft;\n    TNode* FRight;\n\npublic:\n    TNode(const T& Value)\n     : FValue(Value)\n    {\n        FParent = NULL;\n        FLeft   = NULL;\n        FRight  = NULL;\n    }\n    T Value()const\n    {\n        return FValue;\n    }\n    void AddNode(TNode* Node)\n    {\n        Node->FParent = this;\n        if(FValue < Node->FValue){\n            assert(FRight);\n            FRight = Node;\n        }else{\n            assert(FLeft);\n            FLeft  = Node;\n        }\n    }\n    void SetLeft(TNode* Node)\n    {\n        Node->FParent = this;\n        FLeft = Node;\n    }\n    void SetRight(TNode* Node)\n    {\n        Node->FParent = this;\n        FRight = Node;\n    }\n    TNode* CreateLeft(const T& Value)\n    {\n        assert(FLeft == NULL);\n        SetLeft(new TNode(Value));\n        return FLeft;\n    }\n    TNode* CreateRight(const T& Value)\n    {\n        assert(FRight == NULL);\n        SetRight(new TNode(Value));\n        return FRight;\n    }\n    const TNode* Parent()const\n    {\n        return FParent;\n    }\n    const TNode* Left()const\n    {\n        return FLeft;\n    }\n    const TNode* Right()const\n    {\n        return FRight;\n    }\n    const TNode* Find(const T& Value)const\n    {\n        // std::cout << \"Find(\" << Value << \")\" << std::endl;\n        if(FValue == Value) return this;\n        TNode* Node = FValue < Value ? FRight : FLeft;\n        if(Node) return Node->Find(Value);\n        return NULL;\n    }\n    TNode* Find(const T& Value)\n    {\n        return const_cast<TNode*>(const_cast<const TNode*>(this)->Find(Value));\n    }\n};\n\ntemplate<typename T>\nint GetNodeDepth(const TNode<T>* Node)\n{\n    assert(Node);\n    int Depth = 0;\n    while(Node->Parent()){\n        Node = Node->Parent();\n        Depth++;\n    }\n    return Depth;\n}\n \ntemplate<typename T>\nTNodeType GetNodeType(const TNode<T>* Node)\n{\n    assert(Node);\n    if(Node->Parent() == NULL) return ntRoot;\n    if(Node->Left() || Node->Right()) return ntInternal;\n    return ntLeaf;\n}\nstd::string GetNodeTypeText(const TNodeType& Type)\n{\n    switch(Type){\n    case ntRoot:     return \"root\";\n    case ntInternal: return \"internal node\";\n    case ntLeaf:     return \"leaf\";\n    }\n    assert(false);\n    return \"\";\n}\n \ntemplate<typename T>\nconst TNode<T>* GetSibling(const TNode<T>* Node)\n{\n    assert(Node);\n    const TNode<T>* Parent = Node->Parent();\n    if(Parent == NULL) return NULL;\n    if(Parent->Left()  && Parent->Left()  != Node) return Parent->Left();\n    if(Parent->Right() && Parent->Right() != Node) return Parent->Right();\n    return NULL;\n}\ntemplate<typename T>\nconst TNode<T>* GetRoot(const TNode<T>* Node)\n{\n    if(Node->Parent()) return GetRoot(Node->Parent());\n    return Node;\n}\ntemplate<typename T>\nint GetDegree(const TNode<T>* Node)\n{\n    return (Node->Left() ? 1 : 0) + (Node->Right() ? 1 : 0);\n}\n\ntemplate<typename T>\nint GetHeight(const TNode<T>* Node)\n{\n    if(Node == NULL) return -1;\n    return 1 + std::max(GetHeight(Node->Left()), GetHeight(Node->Right()));\n}\ntemplate<typename T>\nvoid PrintNode(const TNode<T>* Node)\n{\n    assert(Node);\n// node 0: parent = -1, sibling = -1, degree = 2, depth = 0, height = 3, root    \n    std::cout << \n    \"node \"       << Node->Value() <<\n    \": parent = \" << (Node->Parent() ? Node->Parent()->Value() : -1) <<\n    \", sibling = \"<< (GetSibling(Node) ? GetSibling(Node)->Value() : -1) <<\n    \", degree = \" << GetDegree(Node) <<\n    \", depth = \"  << GetNodeDepth(Node) <<\n    \", height = \"  << GetHeight(Node) << \n    \", \"          << GetNodeTypeText(GetNodeType(Node)) <<\n    std::endl;\n}\ntemplate<typename T>\nvoid PrintPostorder(const TNode<T>* Node)\n{\n//  2 3 1 6 7 5 8 4 0\n    if(Node == NULL) return;\n    PrintPostorder(Node->Left());\n    PrintPostorder(Node->Right());\n    std::cout << Node->Value();\n    if(Node->Parent()){\n        std::cout << \" \";\n    }else{\n        std::cout << std::endl;\n    }\n}\n\ntemplate<typename T, typename TIt>\nvoid AddNode(TNode<T>* Node, TIt& PreBegin, TIt PreEnd, TIt InBegin, TIt InEnd);\n\ntemplate<typename T, typename TIt>\nvoid AddLeftNode(TNode<T>* Node, TIt& PreBegin, TIt PreEnd, TIt InBegin, TIt InEnd)\n{\n    if(PreBegin == PreEnd) return;\n    if(InBegin == InEnd) return;\n    TNode<T>* New = new TNode<T>(*PreBegin);\n    Node->SetLeft(New);\n    AddNode(New, ++PreBegin, PreEnd, InBegin, InEnd);\n}\n\ntemplate<typename T, typename TIt>\nvoid AddRightNode(TNode<T>* Node, TIt& PreBegin, TIt PreEnd, TIt InBegin, TIt InEnd)\n{\n    if(PreBegin == PreEnd) return;\n    if(InBegin == InEnd) return;\n    TNode<T>* New = new TNode<T>(*PreBegin);\n    Node->SetRight(New);\n    AddNode(New, ++PreBegin, PreEnd, InBegin, InEnd);\n}\n\ntemplate<typename T, typename TIt>\nvoid AddNode(TNode<T>* Node, TIt& PreBegin, TIt PreEnd, TIt InBegin, TIt InEnd)\n{\n    if(PreBegin == PreEnd)  return;\n    TIt It = std::find(InBegin, InEnd, Node->Value());\n    assert(It != InEnd);\n    AddLeftNode(Node, PreBegin, PreEnd, InBegin, It);\n    AddRightNode(Node, PreBegin, PreEnd, It+1, InEnd);\n}\n\nint main()\n{\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    int n;\n    std::cin >> n;\n    std::vector<int> PreOrderIdList(n);\n    for(int i = 0; i < n; ++i){\n        std::cin >> PreOrderIdList[i];\n    }\n    std::vector<int> InOrderIdList(n);\n    for(int i = 0; i < n; ++i){\n        std::cin >> InOrderIdList[i];\n    }\n    \n    TNode<int> Node(PreOrderIdList[0]);\n    std::vector<int>::iterator It = PreOrderIdList.begin();\n    AddNode(&Node, ++It, PreOrderIdList.end(), InOrderIdList.begin(), InOrderIdList.end());\n\n    PrintPostorder(&Node);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, b) for (int i = (a), i##_max = (b); i < i##_max; ++i)\n#define RFOR(i, a, b) for (int i = (b)-1, i##_min = (a); i >= i##_min; --i)\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define RREP(i, n) for (int i = (n)-1; i >= 0; --i)\n#define ALL(obj) (obj).begin(), (obj).end()\n\nusing namespace std;\nusing vi = vector<int>;\nusing i64 = int64_t;\n\nconstexpr int INF = 1 << 30;\nconstexpr int MOD = 1000000007;\n\ntemplate <typename T>\nvoid print(vector<T> &v) {\n  REP(i, v.size()) {\n    if (i) cout << \" \";\n    cout << v[i];\n  }\n  cout << endl;\n}\n\nvoid rec(vi &pre, vi &in, vi &post, int l, int r, int &pos) {\n  if (l >= r) return;\n  auto root = pre[pos++];\n  int m = distance(in.begin(), find(ALL(in), root));\n  rec(pre, in, post, l, m, pos);\n  rec(pre, in, post, m + 1, r, pos);\n  post.push_back(root);\n}\n\nint main() {\n  int n;\n  cin >> n;\n  vi pre(n), in(n), post(0);\n  REP(i, n) cin >> pre[i];\n  REP(i, n) cin >> in[i];\n  int pos = 0;\n  rec(pre, in, post, 0, pre.size(), pos);\n  print(post);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\nvector <int> pre, in, ans;\n\nvoid rec(int lp, int rp, int li, int ri) {\n    int root = pre[lp];\n    int i = 0;\n    while(in[li+i] != root) i++;\n    if (i != 0) rec(lp+1, lp+i, li, li+i-1);\n    if (li + i != ri) rec(lp+i+1, rp, li+i+1, ri);\n\n    ans.pb(root);\n}\n\nvoid solve(void){\n    int N;\n    cin >> N;\n    pre.resize(N), in.resize(N);\n    rep(N, i) cin >> pre[i];\n    rep(N, i) cin >> in[i];\n    rec(0, N-1, 0, N-1);\n    rep(N, i) {\n        if (i < N-1) printf(\"%d \", ans[i]);\n        else printf(\"%d\\n\", ans[i]);\n    }\n}\n\nint main(void){\n  solve();\n  //cout << \"yui(*-v・)yui\" << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nvector<int> post,pre,mid;\nint loc=0;\n\nvoid reBuild(int l,int r){\n    if(l>=r) return;\n    int root=pre[loc++];\n    int m=distance(mid.begin(),find(mid.begin(),mid.end(),root));\n    reBuild(l,m);\n    reBuild(m+1,r);\n    post.push_back(root);\n}\n\nvoid solve(){\n    loc=0;\n    reBuild(0,pre.size());\n    for(int i=0;i<post.size();i++){\n        if(i) cout<<' ';\n        cout<<post[i];\n    }\n    cout<<endl;\n\n}\n\nint main(){\n    int n,k;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&k);\n        pre.push_back(k);\n    }\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&k);\n        mid.push_back(k);\n    }\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n//ALDS1_7_B:   Binary Trees\n//ALDS1_7_C:   Tree Walk\n//ALDS1_7_D:   Reconstruction of a Tree\n//D???????????°??£????????±????§£?????§?????\\???for?????§?§£??????????????????????§£?????????\n////////////////////////////////////////\n\n#include <iostream>\n#include <algorithm> // next_permutation\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <list>\n#include <numeric> //accumulate\n//#include <unordered_map> //???????????\\??¢??°\n#include <fstream> //ifstream, ofstream\n\n//#define NDEBUG //NDEBUG???#include <cassert>???????????????????????????????????´???assert?????????????????????????????????NDEBUG?????????????????????????????????????????????\n#include <cassert> //assert\n\n\nusing namespace std;\n\n//???????????°??????TEST????????????????????¬???????????????????????????????????¢????????????\n#define TEST //*******************************************************************************************************************************************\n//?????????????????¨??§?????\\????????????????????????????????°?????????????¨???????????????????dout???????????????????????§???????????¬??????????????????????????????????????????\n//??????????????????????????????????????????????????????????§?CPU???????£??????????????????§???TLE?????????????????????????????????????????§????????¨???                           ????????????????????????cerr????????£????????????????????????????????????\n#ifdef TEST\n#define dout cout\n#else\nstringstream dummy; //???????????°??????dout?????????????????????????????????\n#define dout dummy.str(\"\"); dummy.clear(stringstream::goodbit); dummy //dummy?????????????????????????????????????????¨?????¢?????¢???????????????\n//???????????¨??????????????????goodbit?????????????????????????????¨???????????´????????????????????????????????¨?????°?????????????????§???????????????????????????????????? http://d.hatena.ne.jp/linden/20060427/p1\n#endif\n\n//?¨??????????????????????????????????????????????????????´??????OUTPUT2TEXTFILE????????????????????¬???????????????????????????????????¢????????????\n//#define OUTPUT2TEXTFILE //*******************************************************************************************************************************************\n#ifdef OUTPUT2TEXTFILE\n#define dout outputfile //??¨????????????TLE????????§?????????dout?????¨??¨??????????????¢????????????????????????????????????????????§????¨????????????´??????????????£??????????????????????¨?????????????????????????????????????????????§?????????????????????\n//TEST??????????????????????????¨???outputfile??????????????????????????????\n#define OUTPUTFILENAME \"output.txt\"\nofstream outputfile(OUTPUTFILENAME);\n#define OutputFilePath \"/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt\"\n#endif\n\n#define disp(A) dout << #A << \" = \" << (A) << endl\n#define disP(A) dout << setw(3) << (A) << \" \" // << setw(3) ??????????????\\????????????\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n\n#define dispAll(A,n) dout << #A << \" = \"; rep(j, 0, (n)) {disP(A[j]);} dout << endl\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef unsigned long long ll;\n\nconst int INF = 1e9-1;\n\nclass Node;\n\nconst int N_MAX = 40;\nvector<Node> node;\n//vi printer;\n\nint preorder[N_MAX+1], inorder[N_MAX+1];\nint x2inindex[N_MAX+1]; //????????°x???inorder????????§???x2inindex[x]????????????????????¨?????????\n\nint N; //num of node\nint targetPreorderIndex = 1; //????????¨??????????????????preorder[x]???index??§??????x?????????\n\nclass Node {\npublic:\n    Node() {\n        parent = -1;\n        left = -1;\n        right = -1;\n    }\n    \n    int parent;\n    int left;\n    int right;\n    \n    \n    int depth() {\n        int p = this->parent;\n        int d = 0;\n        \n        while( p != -1 ) {\n            d++;\n            p = node[p].parent;\n        }\n        \n        return d;\n    }\n    \n    static int height(int id) {\n        if(id == -1) return -1;\n        \n        return max( height(node[id].left), height(node[id].right)) + 1;\n    }\n    \n    static void printNodePreorder(int id) {\n        if(id==-1) return;\n        \n        cout << \" \" << id;\n        printNodePreorder(node[id].left);\n        printNodePreorder(node[id].right);\n    }\n    \n    static void printNodeInorder(int id) {\n        if(id==-1) return;\n        \n        printNodeInorder(node[id].left);\n        cout << \" \" << id;\n        printNodeInorder(node[id].right);\n    }\n    \n    static void printNodePostorder(int id) {\n        if(id==-1) return;\n        \n        printNodePostorder(node[id].left);\n        printNodePostorder(node[id].right);\n//        printer.push_back(id);\n                cout << \" \" << id;\n    }\n    \n    static int findTopNodeFromInorder(int left, int right) { //inorder[left ... right]??????????????????????????????????????????????????¢????????????index?????????\n        if( left > right ) return -1;\n        \n        int x = preorder[targetPreorderIndex];\n        targetPreorderIndex++;\n        \n        //inorder???2????????°?????????????????????????????°????????????\n        int leftChild = findTopNodeFromInorder(left, x2inindex[x]-1); //x?????????????????????????????°?????????\n        int rightChild = findTopNodeFromInorder(x2inindex[x]+1, right); //x?????????????????????????????°?????????\n        \n        node[x].left = leftChild;\n        node[x].right = rightChild;\n        \n        node[leftChild].parent = x;\n        node[rightChild].parent = x;\n        \n        cout << x << (x==preorder[1] ? \"\\n\" : \" \");\n        return x;\n    }\n};\n\n\n\nint main(){ //?????????1???based index??§???\n    cin >> N;\n    rep(i,0,N+1) node.push_back(*new Node()); //node[0]????????????????????????\n    \n    rep(i,1,N+1) cin >> preorder[i];\n    rep(i,1,N+1) { cin >> inorder[i]; x2inindex[ inorder[i] ] = i; }\n    \n//        //test display\n//        dispAll(preorder, N+1);\n//        dispAll(inorder, N+1);\n//        dispAll(x2inindex, N+1);\n    \n    //reconstruct the tree\n    Node::findTopNodeFromInorder(1,N);\n    \n//    //test display\n//    dout<<\"-----------------\\n\";\n//    dout << \"  i   l   r   p\\n\";\n//    rep(i,0,N+1) {\n//        disP(i);\n//        disP(node[i].left); disP(node[i].right); disP(node[i].parent);\n//        dout << endl;\n//    }\n    \n        \n//    //output\n//    rep(i,0,N+1) {\n//        cout << \"node \" << i << \": parent = \" << node[i].parent\n//        << \", sibling = \" << (node[i].parent==-1 ? -1 : (node[node[i].parent].left==i ? node[node[i].parent].right : node[node[i].parent].left) )\n//        << \", degree = \" << (node[i].left==-1 ? (node[i].right==-1 ? 0 : 1) : (node[i].right==-1 ? 1 : 2))\n//        << \", depth = \" << node[i].depth()\n//        << \", height = \" << Node::height(i) << \", \"\n//        << (node[i].parent==-1 ? \"root\" : (node[i].left==-1 && node[i].right==-1 ? \"leaf\" : \"internal node\") ) << endl;\n//    }\n\n    \n    \n//    //find root\n//    int root_i = -1;\n//    rep(i,1,N+1) {\n//        if(node[i].parent==-1) {\n//            root_i = i;\n//            break;\n//        }\n//    }\n//    assert(root_i!=-1);\n//    \n//    //print tree\n//    //    cout << \"Preorder\\n\";\n//    //    Node::printNodePreorder(root_i);\n//    //    cout << endl;\n//    //\n//    //    cout << \"Inorder\\n\";\n//    //    Node::printNodeInorder(root_i);\n//    //    cout << endl;\n//    //\n//    //    cout << \"Postorder\\n\";\n//    Node::printNodePostorder(root_i);\n//    \n//    rep(i,0,N) {\n//        if(i==0) cout << printer[i];\n//        else cout << \" \" << printer[i];\n//    }\n//    cout << endl;\n    \n    \n#ifdef OUTPUT2TEXTFILE\n    outputfile.close();\n    cout << \"\\\"\" << OutputFilePath << \"\\\"\" << endl;\n#endif\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint it;\n\nvoid reconstruction(vector<int> &pre,vector<int> &in,vector<int> &post,int l,int r){\n    if(l>=r){\n        return;\n    }\n    int c=pre[it];\n    it++;\n    int m=distance(in.begin(),find(in.begin(),in.end(),c));\n    reconstruction(pre,in,post,l,m);\n    reconstruction(pre,in,post,m+1,r);\n    post.push_back(c);\n}\n\nint main(){\n    int n;\n    cin>>n;\n    vector<int> pre(n),in(n),post(0);\n    for(int i=0;i<n;i++){\n        cin>>pre[i];\n    }\n    for(int i=0;i<n;i++){\n        cin>>in[i];\n    }\n    it=0;\n    reconstruction(pre,in,post,0,n);\n    for(int i=0;i<n;i++){\n        if(i) cout<<' ';\n        cout<<post[i];\n    }\n    cout<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 100\n\nint n, pre, pos;\nint Preorder[MAX], Inorder[MAX], Postorder[MAX];\n\nint find_parent(int key){\n  for(int i=0; i<n; i++){\n    if(key == Inorder[i]) return i;\n  }\n}\n\nvoid reconstruction(int left, int right){\n  if(left >= right) return;\n  \n  int key=Preorder[pre++];\n  int position=find_parent(key);\n\n  printf(\"%d\\n\", key);\n  \n  reconstruction(left, position);\n  reconstruction(position+1, right);\n  \n  Postorder[pos++]=key;\n}\n\nint main(void){\n  scanf(\"%d\", &n);\n\n  for(int i=0; i<n; i++) scanf(\"%d\", &Preorder[i]);\n  for(int i=0; i<n; i++) scanf(\"%d\", &Inorder[i]);\n\n  reconstruction(0, n);\n\n  for(int i=0; i<n; i++){\n    if(i) printf(\" \");\n    printf(\"%d\", Postorder[i]);\n  }\n\n  printf(\"\\n\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r){\n  if(l >= r) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(),find(in.begin(),in.end(),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\n\nvoid solve(){\n  pos = 0;\n  rec(0,pre.size());\n\n  for(int i=0;i<n;i++){\n    if(i) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main(){\n  int k;\n  cin >> n;\n\n  for(int i=0;i<n;i++)\n  {\n    cin >> k;\n    pre.push_back(k);\n  }\n  for(int i=0;i<n;i++){\n    cin >> k;\n    in.push_back(k);\n  }\n\n  solve();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint n;\nvector<int> pre;\nvector<int> in;\nvector<int> post;\nvector<int> child[42];\n\tint tree[40]; //store parent\nvoid postorder(int i, vector<int> child[]){\n\tif(i==-1) return;\n\tif(child[i].size()==0){\n\t\tpost.push_back(i);return;\n\t} \n\tvector<int> temp = child[i];\n\tpostorder(temp.at(0),child);\n\tpostorder(temp.at(1),child);\n\tpost.push_back(i);\n}\nvoid inorder(int i, vector<int> child[]){\n\tif(i==-1) return;\n\t//if(child[i]==NULL) return;\n\tvector<int> temp = child[i];\n\tinorder(temp.at(0),child);\n\tin.push_back(i);\n\tinorder(temp.at(1),child);\n}\nvoid preorder(int i, vector<int> child[]){\n\tif(i==-1) return;\n\tpre.push_back(i);\n\tvector<int> temp = child[i];\n\tpreorder(temp.at(0),child);\n\tpreorder(temp.at(1),child);\n}\nint reconstruct(int pre[], int in[], int lp,int rp, int li,int ri){\n\tif(li==ri) return in[li];\n\tif(li>ri) return -1;\n\t\n\tint p = pre[lp++];\n\tint index = 0;\n\tfor(int i = li; i<=ri; i++){\n\t\tif(in[i] == p){\n\t\t\tindex = i; break;\n\t\t}\n\t}\n\tfor(int i = li; i<=ri; i++){\n\t\tif(i!=index)\n\t\ttree[in[i]] = p;\n\t}\n\t/*for(int i = lp; i<=rp; i++){\n\t\ttree[pre[i]] = p;\n\t}*/\n\t\n\tchild[p].push_back(reconstruct(pre,in,lp,rp,li,index-1));\n\tchild[p].push_back(reconstruct(pre,in,lp,rp,index+1,ri));\n\treturn p;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i = 0; i<n; i++){\n\t\ttree[i] = -1;\n\t}\n\tint pre[n];\n\tint in[n];\n\tfor(int i = 0; i<n; i++) {\n\t\tscanf(\"%d\",&pre[i]);\n\t\tpre[i]-=1;\n\t}\n\tfor(int i = 0; i<n; i++) {\n\t\tscanf(\"%d\",&in[i]);\n\t\tin[i]-=1;\t\n\t}\n\t\n\treconstruct(pre,in,0,n-1,0,n-1);\n\t//printf(\"%d %d\\n\",child[4].at(0),child[4].at(1));\n\t\n\t/*for(int i = 0; i<n; i++){\n\t\tprintf(\"%d \",tree[i]);\n\t}printf(\"\\n\");*/\n\t//printf(\"%d\",child[4].size());\n\t/*printf(\"Preorder\\n\");\n\tpreorder(root,child);\n\tfor(int i = 0; i<pre.size(); i++){\n\t\tif(i==pre.size()-1)\n\t\tprintf(\" %d\\n\",pre.at(i));\n\t\telse printf(\" %d\",pre.at(i));\n\t}\n\tprintf(\"Inorder\\n\");\n\tinorder(root,child);\n\tfor(int i = 0; i<in.size(); i++){\n\t\tif(i==in.size()-1)\n\t\tprintf(\" %d\\n\",in.at(i));\n\t\telse printf(\" %d\",in.at(i));\n\t}*/\n\t//printf(\"Postorder\\n\");\n\tpostorder(pre[0],child);\n\tfor(int i = 0; i<post.size(); i++){\n\t\tif(i==post.size()-1)\n\t\tprintf(\"%d\\n\",post.at(i)+1);\n\t\telse printf(\"%d \",post.at(i)+1);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAX 10000\n#define NIL -1\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r) {\n  if (l >= r) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\n\nvoid solve() {\n  pos = 0;\n  rec(0, pre.size());\n  for (int i = 0;i < n; i++) {\n    if (i) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main() {\n  int k;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> k;\n    pre.push_back(k);\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> k;\n    in.push_back(k);\n  }\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "Haskell",
    "code": "import qualified Control.Applicative as A\n\nmain = do\n    _ <- getLine\n    p <- map read . words A.<$> getLine\n    i <- map read . words A.<$> getLine\n    putStrLn $ unwords $ map show $ solve p i\n\ntype Node = Int\ntype Nodes = [Node]\ndata Tree = Branch Nodes Tree Tree | Empty\n\nsolve :: Nodes -> Nodes -> Nodes\nsolve p i = postOrder t\n    where (_, t) = reconstruct p (Branch i Empty Empty)\n\npostOrder :: Tree -> Nodes\npostOrder Empty = []\npostOrder (Branch n l r) = postOrder l ++ postOrder r ++ n\n\nreconstruct :: Nodes -> Tree -> (Nodes, Tree)\nreconstruct [] t = ([], t)\nreconstruct (p:ps) t = reconstruct ps (splitBranch p t)\n\nsplitBranch :: Node -> Tree -> Tree\nsplitBranch p t@(Branch n Empty Empty) =\n    if p `elem` n\n       then let (l, r) = splitNodes n p\n                in (Branch [p] (Branch l Empty Empty) (Branch r Empty Empty))\n       else t\nsplitBranch p (Branch n l r) = (Branch n (splitBranch p l) (splitBranch p r))\n\nsplitNodes :: Nodes -> Node -> (Nodes, Nodes)\nsplitNodes [] p = ([], [])\nsplitNodes (n:ns) p =\n    if n == p\n       then ([], ns)\n       else let (l, r) = splitNodes ns p in ((n:l), r)\n"
  },
  {
    "language": "Haskell",
    "code": "module Main where\n\nimport Debug.Trace\nimport Data.List\nimport qualified Data.Sequence as S\nimport qualified Data.ByteString.Char8 as B\nimport Data.Int\nimport Data.Char\nimport Data.Array\nimport Data.Maybe\nimport qualified Data.Map as M\nimport Data.Ord\nimport Data.Functor\nimport Control.Applicative\nimport Control.Monad\nimport Text.Printf\n\ndata Tree = Nil | Node Int Tree Tree deriving (Eq, Show)\n\nsolve :: [Int] -> [Int] -> [Int]\nsolve pro ino = iter root where\n    iter Nil = []\n    iter (Node id left right) = iter left ++ iter right ++ [id]    \n\n    root = iter pro ino where\n        iter [] [] = Nil\n        iter (p:pol) iol = Node p (iter lpro lino) (iter rpro rino) where\n            (lino, ri) = break (==p) iol\n            rino = drop 1 ri\n            lpro = intersect pol lino\n            rpro = intersect pol rino\n\n            \nreadIntLn:: IO Int\nreadIntLn = (fst . fromJust . B.readInt) <$> B.getLine\n\nreadIntList:: IO [Int]\nreadIntList = map (fst . fromJust . B.readInt) . B.words <$> B.getLine\n\nprint':: [Int] -> IO ()\nprint' [x] = putStrLn (show x)\nprint' (x:xs) = do\n    putStr $ show x ++ \" \"\n    print' xs\n\nmain :: IO() \nmain = do\n    _ <- readIntLn\n    l <- readIntList\n    m <- readIntList\n    print' $ solve l m\n\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative ((<$>), (<*>))\nimport Data.List ((\\\\), intersect)\n\nmain :: IO ()\nmain = solve <$> (getLine >> f) <*> f >>= putStrLn\n  where f = map read <$> words <$> getLine\n\nsolve :: [Int] -> [Int] -> String\nsolve ps is = unwords . map show . postOrder $ mkBTree ps is\n\ndata BTree a = Leaf | Node a (BTree a) (BTree a) deriving Show\n\nmkBTree :: [Int] -> [Int] -> BTree Int\nmkBTree [] [] = Leaf\nmkBTree (p:ps) is = Node p (mkBTree lp li) (mkBTree rp ri)\n  where (li,(_:ri)) = break (==p) is\n        lp = ps `intersect` li\n        rp = ps \\\\ lp\n\nfoldPost :: (a -> b -> b) -> b -> BTree a -> b\nfoldPost f z Leaf = z\nfoldPost f z (Node x l r) = let y1 = f x z\n                                y2 = foldPost f y1 r\n                            in foldPost f y2 l\n\npostOrder :: BTree a -> [a]\npostOrder = foldPost (:) []\n\n"
  },
  {
    "language": "Haskell",
    "code": "import           Control.Applicative\nimport           Control.Monad\nimport qualified Data.ByteString.Char8 as B\nimport           Data.Sequence         ((<|), (><), (|>))\nimport qualified Data.Sequence         as S\n\nimport           Data.Foldable         (toList)\nimport           Data.List             (foldl')\n\nreadi :: B.ByteString -> Int\nreadi bs | Just (n, _) <- B.readInt bs = n\n\nsplitElem :: Int -> S.Seq Int -> [S.Seq Int]\nsplitElem n s\n    | Nothing <- midx = [s]\n    | Just i <- midx =\n        let (l, r) = S.splitAt i s\n            (m S.:< r') = S.viewl r\n         in [l, r', S.singleton m]\n  where\n    midx = S.elemIndexL n s\n\nmain :: IO ()\nmain = do\n    n <- readLn :: IO Int\n    ps <- fmap readi . B.words <$> B.getLine\n    is <- S.fromList . fmap readi . B.words <$> B.getLine\n\n    let as = foldl' (\\acc p -> concatMap (splitElem p) acc) [is] ps\n    let as' = foldr (><) S.empty as\n    putStrLn . unwords . fmap show $ toList as'\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns #-}\nimport Control.Monad\nimport Data.Maybe\nimport Debug.Trace\nimport Data.List\nimport qualified Data.Map.Strict as Map\nimport qualified Data.IntMap.Strict as IntMap\nimport qualified Data.Set as Set\nimport qualified Data.IntSet as IntSet\nimport Data.Functor\nimport Data.Array\n\nmain :: IO ()\nmain = do\n  n <- readLn :: IO Int\n  pos <- fmap (map read . words) getLine :: IO [Int]\n  ios <- fmap (map read . words) getLine :: IO [Int]\n  solve pos ios\n\ndata Tree a = Leaf | Node a (Tree a) (Tree a) \n\nsolve pos ios = postOrder $ reconstruct pos ios\n  where\n    reconstruct :: [Int] -> [Int] -> Tree Int\n    reconstruct pos [] = Leaf\n    reconstruct [] ios = Leaf\n    reconstruct pos ios = Node p (reconstruct pos l) (reconstruct pos r)\n      where\n        (l, p, r) = fromJust . head . filter isJust $ map (flip splitIfEqual ios) pos\n\nsplitIfEqual :: (Eq a) => a -> [a] -> Maybe ([a], a, [a])\nsplitIfEqual k as = go k [] as\n  where\n    go _ _ [] = Nothing\n    go k bs (a:as) = if k == a \n                     then Just (reverse bs, k, as)\n                     else go k (a:bs) as\n\n\npostOrder :: Tree Int -> IO ()\npostOrder = putStrLn . unwords . map show . postOrderedList \n  where\n    postOrderedList :: Tree Int -> [Int]\n    postOrderedList Leaf = []\n    postOrderedList (Node x left right) = (postOrderedList left) ++ (postOrderedList right) ++ [x]\n\n\n\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-\n?????????: Tree - Reconstruction of a Tree\nURL: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_7_D\n?????°:\n19:39:05 koch_curve???Haskell?\\?????????°??§?\\??????????????????§?????????????????£???????????????\n19:42:47 ??¨??????????????\\???????????????????????????????????¨read???????????????\n19:51:01 ????????§?????????????????????????????????\n19:52:44 ?????????????????£???\n-}\n\nimport Control.Applicative\nimport Control.Monad\n\nmain = do\n _ <- getLine\n arr1 <- fmap words getLine\n arr2 <- fmap words getLine\n putStrLn . unwords $ foo arr1 arr2\n\nfoo :: (Eq a) => [a] -> [a] -> [a]\nfoo [] [] = []\nfoo preorder@(a:l1r1) inorder = l3 ++ r3 ++ [a] where\n (l2, _:r2) = break (== a) inorder\n (l1,r1) = splitAt (length l2) l1r1\n l3 = foo l1 l2\n r3 = foo r1 r2"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 40\n\nint n,pos;\nint a[N],b[N];\n\nvoid solve(int, int);\n\nvoid solve(int l,int r){\n  int x,i;\n\n  x = a[pos];\n  if( l > r ) return;\n  if( l == r ){\n    if( b[l] == a[0] ) printf(\"%d\", b[l]);\n    else printf(\"%d \", b[l]);\n    pos++;\n\n    return;\n  }\n  pos++;\n\n  for( i = l ; i <= r ; i++){\n    if( b[i] == x ) break;\n  }\n  solve( l, i-1);\n  solve( i+1, r);\n\n  if( x == a[0]) printf(\"%d\", x);\n  else printf(\"%d \", x);\n}\n\n\nint main(){\n  int i;\n\n  scanf(\"%d\", &n);\n  for( i = 0 ; i < n ; i++){\n    scanf(\"%d\", &a[i]);\n  }\n  for( i = 0 ; i < n ; i++){\n    scanf(\"%d\", &b[i]);\n  }\n  pos = 0;\n  solve( 0, n-1);\n  printf(\"\\n\");\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 40\n\ntypedef struct node_t {\n\tint key;\n\tstruct node_t *parent;\n\tstruct node_t *left;\n\tstruct node_t *right;\n} node;\n\nnode* newNode(int);\nvoid reTree(int, int, int, node *, char);\nvoid postorder(node *);\n\nint pre[MAX], in[MAX];\nint flag=0;\n\nint main(void)\n{\n\tint i, n;\n\tnode *root;\n\t\n\tscanf(\"%d\",&n);\n\tfor (i=0; i<n; i++) {\n\t\tscanf(\"%d\",&pre[i]);\n\t}\n\tfor (i=0; i<n; i++) {\n\t\tscanf(\"%d\",&in[i]);\n\t}\n\t\n\troot = newNode(0);\n\t\n\treTree(n, 0, 0, root, 'l');\n\t\n\tpostorder(root->left);\n\tprintf(\"\\n\");\n\t\n\treturn 0;\n}\n\nnode* newNode(int key)\n{\n\tnode *tmp;\n\t\n\ttmp = (node *)malloc(sizeof(node));\n\tif (tmp == NULL) exit(0);\n\t\n\ttmp->key = key;\n\ttmp->parent = NULL;\n\ttmp->left = NULL;\n\ttmp->right = NULL;\n\t\n\treturn tmp;\n}\n\nvoid reTree(int n, int phead, int ihead, node *parent, char ch)\n{\n\tint cnt, key;\n\tnode *node;\n\t\n\tif(n==0) return;\n\t\n\tkey = pre[phead];\n\tcnt = 0;\n\t\n\twhile (in[ihead + cnt] != key) {\n\t\tcnt++;\n\t}\n\t\n\t\n\tnode = newNode(key);\n\tnode->parent = parent;\n\tif(ch == 'l') parent->left = node;\n\telse if(ch == 'r') parent->right = node;\n\t\n\treTree(cnt, phead+1, ihead, node, 'l');\n\treTree(n-cnt-1, phead+cnt+1, ihead+cnt+1, node, 'r');\n}\n\nvoid postorder(node *node)\n{\n\t\n\tif(node->left != NULL) postorder(node->left);\n\tif(node->right != NULL) postorder(node->right);\n\tif (flag==0) {\n\t\tprintf(\"%d\",node->key);\n\t\tflag = 1;\n\t} else {\n\t\tprintf(\" %d\",node->key);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define MAX 100\n\nint n,c,k=0;\nint pre[MAX],in[MAX],post[MAX];\n\n\nint find(int x);\nvoid rec(int l,int r);\n\nint main(){\n\tint i;\n\tscanf(\"%d\",&n);\n\t\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&pre[i]);\n\t}\n\t\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&in[i]);\n\t}\n\t\n\trec(0,n);\n\t\n\tfor(i=0;i<n;i++){\n\t\tif(i != n-1)printf(\"%d \",post[i]);\n\t\telse printf(\"%d\\n\",post[i]);\n\t}\n\t\n\treturn 0;\n}\n\nint find(int x){\n\tint i;\n\tfor(i=0;i<n;i++){\n\t\tif(x==in[i]) return i;\n\t}\n\treturn 0;\n}\n\nvoid rec(int l,int r){\n\tint x,y;\n\tif(l >= r) return;\n\t\n\tx=pre[k++];\n\ty=find(x);\n\trec(l,y);\n\trec(y+1,r);\n\tpost[c++]=x;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct node{\n  int id;\n  struct node *parent;\n  struct node *left;\n  struct node *right;\n}Node;\n\nvoid print_tree(Node *x,int t) {\n  if(x->left != NULL) print_tree(x->left,1);\n  if(x->right != NULL) print_tree(x->right,1);\n  if(t == 1)printf(\"%d \", x->id);\n  if(t == 0)printf(\"%d\\n\", x->id);\n}\n\nNode *make_tree(int *pre, int * in, int i, int j, int n, Node *p) {\n  if(i >= n) return NULL;\n  Node *p1 = (Node*)malloc(sizeof(Node));\n  p1->id = pre[i];\n  p1->parent = p;\n  p1->left = NULL;\n  p1->right = NULL;\n  if(pre[i] != in[j]) {\n    p1->left = make_tree(pre,in,i+1,j,n,p1);\n  }else{\n    Node *tmp = p1;\n    while(1) {\n      if(p == NULL) {\n\tbreak;\n      }\n      if(p->id == in[j+1]) {\n\tj++;\n\ttmp = p;\n      }\n      p = p->parent;\n    }\n    tmp->right = make_tree(pre,in,i+1,j+1,n,tmp);\n  }\n  return p1;\n}\n\nint main()\n{\n  int i,n,*preorder,*inorder;\n  scanf(\"%d\",&n);\n  preorder = (int*)malloc(sizeof(int) * n);\n  inorder = (int*)malloc(sizeof(int) * n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\",preorder+i);\n  }\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\",inorder+i);\n  }\n  Node *root = make_tree(preorder,inorder,0,0,n,NULL);\n  print_tree(root,0);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 40\n\nint n,pos;\nint a[N],b[N];\n\nvoid solve(int, int);\n\nvoid solve(int l,int r){\n  int x,i;\n\n  x = a[pos];\n  if( l > r ) return;\n  if( l == r ){\n    if( b[l] == a[0] ) printf(\"%d\", b[l]);\n    else printf(\"%d \", b[l]);\n    pos++;\n\n    return;\n  }\n  pos++;\n\n  for( i = l ; i <= r ; i++){\n    if( b[i] == x ) break;\n  }\n  solve( l, i-1);\n  solve( i+1, r);\n\n  if( x == a[0]) printf(\"%d\", x);\n  else printf(\"%d \", x);\n}\n\n\nint main(){\n  int i;\n\n  scanf(\"%d\", &n);\n  for( i = 0 ; i < n ; i++){\n    scanf(\"%d\", &a[i]);\n  }\n  for( i = 0 ; i < n ; i++){\n    scanf(\"%d\", &b[i]);\n  }\n  pos = 0;\n  solve( 0, n-1);\n  printf(\"\\n\");\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct {\n\tint parent;\n\tint left, right;\n}Node;\n\nint linear_search(int* xs, int size, int x)\n{\n\tint i;\n\tfor (i = 0; i < size; i++) {\n\t\tif (xs[i] == x) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nNode tree[50];\n\nint prewalked[50];\nint inwalked[50];\n\nint n;\n\nint reconstruction_tree(int from, int to, int root_pos, int parent)\n{\n\tint i;\n\tint v;\n\n\tfor (i = from; i < to; i++) {\n\t\tif ((v = inwalked[i]) == prewalked[root_pos]) {\n\t\t\ttree[v].parent = parent;\n\n\t\t\ttree[v].left = reconstruction_tree(from, i, root_pos + 1, v);\n\t\t\ttree[v].right = reconstruction_tree(i+1, to, root_pos +  (i - from) + 1, v);\n\n\t\t\treturn v;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint result[50];\nint resultcnt;\n\nvoid postorder_walk(int p)\n{\n\tif (p > n || p < 0) {\n\t\treturn;\n\t}\n\tpostorder_walk(tree[p].left);\n\tpostorder_walk(tree[p].right);\n\n\tresult[resultcnt++] = p;\n}\n\nint main()\n{\n\tint i;\n\tint root;\n\n\tfor (i = 0; i < 50; i++) {\n\t\ttree[i].parent = -1;\n\t}\n\n\tscanf(\"%d\", &n);\n\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &(prewalked[i]));\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &(inwalked[i]));\n\t}\n\n\troot = reconstruction_tree(0, n, 0, -1);\n\n\tpostorder_walk(root);\n\n\tfor (i = 0; i < resultcnt; i++) {\n\t\tif (i == 0) {\n\t\t\tprintf(\"%d\", result[i]);\n\t\t}\n\t\telse {\n\t\t\tprintf(\" %d\", result[i]);\n\t\t}\n\t}\n\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 40\n   \nint n,pos;\nint a[N],b[N];\n \nvoid solve(int, int);\n \nint main(){\n   \n  int i;\n \n  scanf(\"%d\",&n);\n \n  for(i=0;i<n;i++){\n    scanf(\"%d\",&a[i]);\n  }\n \n  for(i=0;i<n;i++){\n    scanf(\"%d\",&b[i]);\n  }\n   \n  pos=0;\n \n  solve(0,n-1);\n \n  printf(\"\\n\");\n \n  return 0;\n}\n   \nvoid solve(int l,int r){\n   \n  int x,i;\n \n  x=a[pos];\n   \n  if(l>r)return;\n  if(l==r){\n    if(b[l]==a[0]) printf(\"%d\",b[l]);\n    else printf(\"%d \",b[l]);\n    pos++;\n    return;\n  }\n   \n  pos++;\n  for(i=l;i<=r;i++){\n    if(b[i]==x)break;\n  }\n  solve(l,i-1);\n  solve(i+1,r);\n     \n  if(x==a[0])printf(\"%d\",x);\n  else printf(\"%d \",x);\n}"
  },
  {
    "language": "C",
    "code": "#define dbg(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#define dpri(x) dbg(#x \": %d\\n\", x)\n#define dprs(x) dbg(#x \": %s\\n\", x)\n#include <stdio.h>\n#include <string.h>\ntypedef long long ll;\nconst int MYINF = 1e9+7;\ntypedef int bool;\nconst bool true = 1;\nconst bool false = 0;\n \n#define MAX_N 64\n \ntypedef struct node_st {\n    int left, right;\n    int pre, in;\n} node_t;\n \nint n;\nint preorder[MAX_N];\nint inorder[MAX_N];\nnode_t nd[MAX_N];\n \nvoid recons(int id, int base , int n) {\n    int pre, in, remain_left, remain_right;\n    if (id == 0) return;\n \n    pre = nd[id].pre;\n    in = nd[id].in;\n    remain_left = (in - base);\n    remain_right = n - remain_left - 1;\n \n    if (remain_left > 0) {\n        nd[id].left = preorder[pre+1];\n        recons(nd[id].left, base, remain_left);\n    }\n \n    if (remain_right > 0) {\n        nd[id].right = preorder[pre+remain_left+1];\n        recons(nd[id].right, in+1, remain_right);\n    }\n}\n \nvoid postorder(int id) {\n    static const char *sp = \"\";\n    if (!id) return;\n    if (nd[id].left) postorder(nd[id].left);\n    if (nd[id].right) postorder(nd[id].right);\n    printf(\"%s%d\", sp, id);\n    sp = \" \";\n}\n \nint main(int argc, char **argv)\n{\n    int i;\n \n    memset(nd, 0, sizeof(node_t) * MAX_N);\n    scanf(\"%d\", &n);\n    for (i = 0; i < n; i++) {\n        scanf(\"%d\", &preorder[i]);\n        nd[preorder[i]].pre = i;\n    }\n    for (i = 0; i < n; i++) {\n        scanf(\"%d\", &inorder[i]);\n        nd[inorder[i]].in = i;\n    }\n \n    recons(preorder[0], 0, n);\n    postorder(preorder[0]);\n    puts(\"\");\n \n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 10000\n#define NIL -1\n\ntypedef struct{\n  int parent,left,right;\n}Node;\n\nNode T[M];\nint n,D[M], H[M];\n\nvoid setDepth(int a,int b){\n  if(a == NIL)return;\n  D[a] = b;\n  setDepth(T[a].left,b+1);\n  setDepth(T[a].right,b+1);\n}\n\nint setHeight(int a){\n  int h1 = 0;\n  int h2 = 0;\n  if(T[a].left != NIL)\n    h1 = setHeight(T[a].left)+1;\n  if(T[a].right != NIL)\n    h2 = setHeight(T[a].right)+1;\n  if(h1>h2)\n    {\n      H[a]=h1;\n    }\n  else\n    {\n      H[a]= h2;\n    }\n  return H[a];\n}\nint gSibling(int s)\n{\n  if(T[s].parent == NIL)return NIL;\n  if(T[T[s].parent].left != s && T[T[s].parent].left != NIL)\n    return T[T[s].parent].left;\n  if(T[T[s].parent].right != s && T[T[s].parent].right != NIL)\n    return T[T[s].parent].right;\n\n  return NIL;\n}\nint main()\n{\n  int i,j,v,l,r,deg,root = 0;\n\n  scanf(\"%d\",&n);\n\n  for(i=0;i<n;i++)\n    {\n      T[i].parent = NIL;\n    }\n  for(i = 0;i<n;i++)\n    {\n      scanf(\"%d %d %d\",&v,&l,&r);\n      T[v].left = l;\n      T[v].right = r;\n      if(l != NIL)T[l].parent = v;\n      if(r != NIL)T[r].parent = v;\n    }\n\n  for(i = 0;i<n;i++)\n    {\n      if(T[i].parent == NIL)root = i;\n    }\n\n  setDepth(root, 0);\n  setHeight(root);\n\n  for(i = 0;i<n;i++)\n    {\n      printf(\"node %d: \", i);\n      printf(\"parent = %d, \", T[i].parent);\n      printf(\"sibling = %d, \",gSibling(i));\n      deg = 0;\n      if(T[i].left != NIL)deg++;\n      if(T[i].right != NIL)deg++;\n      printf(\"degree = %d, \",deg);\n      printf(\"depth = %d, \",D[i]);\n      printf(\"height = %d, \",H[i]);\n\n      if(T[i].parent == NIL){\n\tprintf(\"root\\n\");\n      }\n      else if(T[i].left == NIL && T[i].right == NIL)\n\t{\n\t  printf(\"lesf\\n\");\n\t}\n      else \n\t{\n\t  printf(\"internal node\\n\");\n\t}\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n  \nint preOrder[40],inOrder[40];\n \nvoid solve(int x,int y){\n  int i;\n  static int p=0;\n  if(x>y) return;\n  if(x==y){\n    if(inOrder[x]==preOrder[0]) printf(\"%d\",inOrder[x]);  \n    else printf(\"%d \",inOrder[x]);\n    p++;\n    return;\n  }\n  int a=preOrder[p];\n  p++;\n  for(i=x;i<=y;i++){\n    if(inOrder[i]==a) break;\n  }\n  solve(x,i-1);\n  solve(i+1,y);\n  if(a==preOrder[0]) printf(\"%d\",a);\n  else printf(\"%d \",a);\n}\n  \nint main(){\n  int i,n;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++) scanf(\"%d\",&preOrder[i]);\n  for(i=0;i<n;i++) scanf(\"%d\",&inOrder[i]);\n  solve(0,n-1);\n  printf(\"\\n\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "\n\n#include<stdio.h>\n#define N 100\n \nint n, pos, count = 0;\nint pre[N], in[N], post[N];\n \nint find(int in[n], int root){\n  int i;\n  for(i = 0; i < n; i++){\n    if(in[i] ==  root) return i;\n  }\n  return in[n - 1];\n}\n\n void rec(int l,int r){\n      int root,m;\n      if(l>=r)return;\n      root=pre[pos++];\n      m=find(in,root);\n      rec(l,m);\n      rec(m+l,r);\n      post[count++]=root;\n      }\n\n void solve(){\n      int i;\n      pos=0;\n      rec(0,n);\n      for(i=0;i<n;i++){\n              if(i)printf(\" \");\n              printf(\"%d\",post[i]);\n              }\n      printf(\"\\n\");\n      }\n\n int main(){\n      int i,k;\n      scanf(\"%d\",&n);\n\n      for(i=0;i<n;i++){\n              scanf(\"%d\",&k);\n              pre[i]=k;\n              }\n      for(i=0;i<n;i++){\n              scanf(\"%d\",&k);\n              in[i]=k;\n              }\n      solve();\n      return 0;\n      }\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 100\n\n\n int n,pos,count=0;\n int pre[N],in[N],post[N];\n \n int find(int in[n],int root){\n     int i;\n     for(i=0;i<n;i++){\n            if(in[i]==root)return i;\n            }\n     return in[n-1];\n     }\n\n void rec(int l,int r){\n      int root,m;\n      if(l>=r)return;\n      root=pre[pos++];\n      m=find(in,root);\n      rec(l,m);\n      rec(m+l,r);\n      post[count++]=root;\n      }\n\n void solve(){\n      int i;\n      pos=0;\n      rec(0,n);\n      for(i=0;i<n;i++){\n              if(i)printf(\" \");\n              printf(\"%d\",post[i]);\n              }\n      printf(\"\\n\");\n      }\n\n int main(){\n  int i, k;\n  scanf(\"%d\", &n);\n \n  for(i = 0; i < n; i++){\n    scanf(\"%d\", &k);\n    pre[i] = k;\n  }\n \n  for(i = 0; i < n; i++){\n    scanf(\"%d\", &k);\n    in[i] = k;\n  }\n \n  solve();\n \n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n \nint preOrder[40],inOrder[40];\n\nvoid solve(int l,int r){\n  int i;\n  static int p=0;\n  // int x=preOrder[p];\n\n  if(l>r) return;\n  if(l==r){\n    if(inOrder[l]==preOrder[0]){\n      printf(\"%d\",inOrder[l]);\n    }\n    else{\n      printf(\"%d \",inOrder[l]);\n    } \n    p++;\n    return;\n  }\n  //printf(\"aaa\");\n  int x=preOrder[p];\n  p++;\n  for(i=l;i<=r;i++){\n    if(inOrder[i]==x) break;\n  }\n  solve(l,i-1);\n  solve(i+1,r);\n   \n  if(x==preOrder[0]) printf(\"%d\",x);\n  else printf(\"%d \",x);\n}\n \nint main(){\n  int i,n;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++) scanf(\"%d\",&preOrder[i]);\n  for(i=0;i<n;i++) scanf(\"%d\",&inOrder[i]);\n  solve(0,n-1);\n  printf(\"\\n\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct {\n\tint parent;\n\tint left, right;\n}Node;\n\nint linear_search(int* xs, int size, int x)\n{\n\tint i;\n\tfor (i = 0; i < size; i++) {\n\t\tif (xs[i] == x) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nNode tree[50];\n\nint prewalked[50];\nint inwalked[50];\n\nint n;\n\nint reconstruction_tree(int from, int to, int root_pos, int parent)\n{\n\tint i;\n\tint v;\n\n\tfor (i = from; i < to; i++) {\n\t\tif ((v = inwalked[i]) == prewalked[root_pos]) {\n\t\t\ttree[v].parent = parent;\n\n\t\t\ttree[v].left = reconstruction_tree(from, i, root_pos + 1, v);\n\t\t\ttree[v].right = reconstruction_tree(i+1, to, root_pos +  (i - from) + 1, v);\n\n\t\t\treturn v;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nvoid postorder_walk(int p)\n{\n\tif (p > n || p < 0) {\n\t\treturn;\n\t}\n\tpostorder_walk(tree[p].left);\n\tpostorder_walk(tree[p].right);\n\tprintf(\" %d\", p);\n}\n\nint main()\n{\n\tint i;\n\tint root;\n\n\tfor (i = 0; i < 50; i++) {\n\t\ttree[i].parent = -1;\n\t}\n\n\tscanf(\"%d\", &n);\n\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &(prewalked[i]));\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &(inwalked[i]));\n\t}\n\n\troot = reconstruction_tree(0, n, 0, -1);\n\n\tpostorder_walk(root);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 100\n\n\n int n,pos,count=0;\n int pre[N],in[N],post[N];\n \n int find(int in[n],int root){\n     int i;\n     for(i=0;i<n;i++){\n            if(in[i]==root)return i;\n            }\n     return in[n-1];\n     }\n\n void rec(int l,int r){\n      int root,m;\n      if(l>=r)return;\n      root=pre[pos++];\n      m=find(in,root);\n      rec(l,m);\n      rec(m+1,r);\n      post[count++]=root;\n      }\n\n void solve(){\n      int i;\n      pos=0;\n      rec(0,n);\n      for(i=0;i<n;i++){\n              if(i)printf(\" \");\n              printf(\"%d\",post[i]);\n              }\n      printf(\"\\n\");\n      }\n\n int main(){\n      int i,k;\n      scanf(\"%d\",&n);\n\n      for(i=0;i<n;i++){\n              scanf(\"%d\",&k);\n              pre[i]=k;\n              }\n      for(i=0;i<n;i++){\n              scanf(\"%d\",&k);\n              in[i]=k;\n              }\n      solve();\n      return 0;\n      }\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint search(int arr[], int val, int n)\n{\n  int i;\n\n  for (i = 0; i < n; i++)\n    if (arr[i] == val)\n      return i;\n  return -1;\n}\n\nint postorder[45];\n\nvoid po(int inorder[], int preorder[], int n) {\n\n  int rootIndex = search(inorder, preorder[0], n);\n\n  if (rootIndex > 0)\n    po(inorder, preorder + 1, rootIndex);\n\n  if (rootIndex != n - 1)\n    po(inorder + rootIndex + 1, preorder + rootIndex + 1, n - rootIndex - 1);\n\n  printf(\"%d \", preorder[0]);\n}\n\nint main() {\n  int n, i;\n\n  scanf(\"%d\", &n);\n\n  int preorder[n];\n  int inorder[n];\n\n  for (i = 0; i < n; i++)\n    scanf(\"%d\", &preorder[i]);\n\n  for (i = 0; i < n; i++)\n    scanf(\"%d\", &inorder[i]);\n\n  po(inorder, preorder, n);\n  printf(\"\\n\");\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n \n#define MAX 40\n \nvoid solve(int*,int*,int);\n \nint n, post[MAX], idx;\n \nint main(){\n  int pre[MAX], in[MAX], i;\n \n  scanf(\"%d\",&n);\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\",pre+i);\n  }\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\",in+i); \n  }\n \n  solve(pre, in, n);\n \n  for(i = 0 ; i < n ; i++){\n    printf(\"%d%c\",post[i],(i != n-1 ? ' ':'\\n'));\n  }\n \n  return 0;\n}\n \nvoid solve(int pre[], int in[], int N){\n  int i, p;\n \n  for(i = 0 ; i < N ; i++){\n    if(in[i] == pre[0]){\n      p = i;\n      break;\n    }\n  }\n \n  if(p != 0){\n    solve(pre+1, in, p);\n  }\n  if(p != N-1){\n    solve(pre+p+1, in+p+1, N-p-1);\n  }\n  post[idx++] = pre[0]; \n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n\ntypedef struct{\n\tint left;\n\tint right;\n}TREE_T;\n\ntypedef struct{\n\tint num;\n\tint h;\n}STRUCT;\n\n\nTREE_T *TREE;\nSTRUCT *IN_ORDER;\nint *MEM;\n\nint COUNT = 0;\n\n\nvoid Make_tree(int left, int right)\n{\n\tint id;\n\tint soeji;\n\tint l_max, l_pos, r_max, r_pos;\n\tint i;\n\n\tsoeji = MEM[COUNT++];\n\tid = IN_ORDER[soeji].num;\n\n\tl_max = r_max = -1;\n\tfor(i = left; i < soeji; i++){\n\t\tif(l_max < IN_ORDER[i].h){\n\t\t\tl_max = IN_ORDER[i].h;\n\t\t\tl_pos = i;\n\t\t}\n\t}\n\tif(l_max == -1)\n\t\tTREE[id].left = -1;\n\telse\n\t\tTREE[id].left = IN_ORDER[l_pos].num;\n\n\tfor(i = soeji + 1; i <= right; i++){\n\t\tif(r_max < IN_ORDER[i].h){\n\t\t\tr_max = IN_ORDER[i].h;\n\t\t\tr_pos = i;\n\t\t}\n\t}\n\tif(r_max == -1)\n\t\tTREE[id].right = -1;\n\telse\n\t\tTREE[id].right = IN_ORDER[r_pos].num;\n\n\t// 左側の処理\n\tif(l_max != -1)\n\t\tMake_tree(left, soeji - 1);\n\n\t// 右側の処理\n\tif(r_max != -1)\n\t\tMake_tree(soeji + 1, right);\n}\n\n\n// 帰りがけなぞり\nint WALK_COUNT = 0;\nvoid Walk_tree(int soeji)\n{\n\tif(TREE[soeji].left != -1)\n\t\tWalk_tree(TREE[soeji].left);\n\n\tif(TREE[soeji].right != -1)\n\t\tWalk_tree(TREE[soeji].right);\n\n\n\tprintf(\"%d\", soeji);\n\tWALK_COUNT++;\n\tif(WALK_COUNT != COUNT)\n\t\tprintf(\" \");\n\telse\n\t\tprintf(\"\\n\");\n}\n\n\nint main()\n{\n\tint n;\n\tint *pre_order;\n\tint i, j;\n\n\tscanf(\"%d\", &n);\n\n\t// 初期化\n\tpre_order = (int *)malloc(sizeof(int) * n);\n\tIN_ORDER = (STRUCT *)malloc(sizeof(STRUCT) * n);\n\n\tTREE = (TREE_T *)malloc(sizeof(TREE_T) * (n + 1));\n\tMEM = (int *)malloc(sizeof(int) * n);\n\n\t// データ入力\n\tfor(i = 0;i < n; i++)\n\t\tscanf(\"%d\", &pre_order[i]);\n\tfor(i = 0; i < n; i++)\n\t\tscanf(\"%d\", &IN_ORDER[i].num);\n\n\t//　必要なデータの前準備\n\tfor(i = 0; i < n; i++){\n\t\tfor(j = 0; j < n; j++){\n\t\t\tif(pre_order[i] == IN_ORDER[j].num){\n\t\t\t\t//printf(\"●\");\n\t\t\t\tMEM[i] = j;\n\t\t\t\tIN_ORDER[j].h = n - i;\n\t\t\t}//else\n\t\t\t\t//printf(\"×\");\n\t\t}\n\t\t//printf(\"\\n\");\n\t}\n\n\t// 木の作成\n\tMake_tree(0, n - 1);\n\n/*\tfor(i = 1; i < n + 1; i++)\n\t\tprintf(\"%d l:%d r:%d\\n\", i, TREE[i].left, TREE[i].right);\n*/\n\t// 帰りがけなぞり\n\tWalk_tree(IN_ORDER[MEM[0]].num);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 40\n\nint n,pos;\nint a[M],b[M];\n\nvoid solve(int, int);\n\n\n\n\n\nint main(){\n  int i;\n\n  scanf(\"%d\", &n);\n  for( i = 0 ; i < n ; i++){\n    scanf(\"%d\", &a[i]);\n  }\n  for( i = 0 ; i < n ; i++){\n    scanf(\"%d\", &b[i]);\n  }\n  pos = 0;\n  solve( 0, n-1);\n  printf(\"\\n\");\n\n\n  return 0;\n}\n\n\nvoid solve(int l, int r) {\n\tint x, i;\n\n\n\n\n\tx = a[pos];\n\tif (l > r) return;\n\tif (l == r) {\n\t\tif (b[l] == a[0]) printf(\"%d\", b[l]);\n\t\telse printf(\"%d \", b[l]);\n\t\tpos++;\n\n\n\n\n\t\treturn;\n\t}\n\tpos++;\n\n\n\n\n\tfor (i = l; i <= r; i++) {\n\t\tif (b[i] == x) break;\n\t}\n\tsolve(l, i - 1);\n\tsolve(i + 1, r);\n\n\n\n\n\tif (x == a[0]) printf(\"%d\", x);\n\telse printf(\"%d \", x);\n}\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 40\nint n,s;\nint a[M],b[M];\nvoid solve(int, int);\nint main(){\n  int i;\n  scanf(\"%d\",&n);\n  for(i = 0; i<n; i++){\n    scanf(\"%d\", &a[i]);\n  }\n  for(i = 0; i<n; i++){\n    scanf(\"%d\",&b[i]);\n  }\n  s = 0;\n  solve(0,n-1);\n  printf(\"\\n\");\n  return 0;\n}\n\nvoid solve(int l, int r){\n  int x,i;\n  x = a[s];\n  if( l > r){\n    return;\n  }\n  if(l == r){\n    if( b[l] == a[0]){\n      printf(\"%d\",b[l]);\n    }\n    else{\n      printf(\"%d \",b[l]);\n    }\n      s++;\n      return;\n    }\n    \n    s++;\n    for(i = l ; i<=r ;i ++){\n      if(b[i] == x)break;\n    }\n    solve(l,i - 1);\n    solve(i + 1,r);\n\n    if(x == a[0]){\n      printf(\"%d\",x);\n    }\n\n    else{\n      printf(\"%d \",x);\n    }\n    }\n\n"
  },
  {
    "language": "C",
    "code": "\n\nint preorder[40],inorder[40];\nvoid recover(int fp,int lp,int fi,int li){\n    int root=fi;\n    for(;root<li;root++)if(preorder[fp]==inorder[root])break;\n    if(fi<root)recover(fp+1,fp+(root-fi)+1,fi,root);\n    if(root<li-1)recover(fp+(root-fi)+1,lp,root+1,li);\n    printf(inorder[root]==preorder[0]?\"%d\\n\":\"%d \",inorder[root]);\n}\nmain(){\n    int n,i;\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)scanf(\"%d\",preorder+i);\n    for(i=0;i<n;i++)scanf(\"%d\",inorder+i);\n    recover(0,n,0,n);\n    return 0;\n}\n \n\n "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define MAX 100\n\nint n,c,k=0;\nint pre[MAX],in[MAX],post[MAX];\n\n\nint find(int x){\n\tint i;\n\tfor(i=0;i<n;i++)if(x==in[i])return i;\n\treturn 0;\n}\n\nvoid rec(int l,int r){\n\tint x,y;\n\tif(l >= r)return;\n\t\n\tx=pre[k++];\n\ty=find(x);\n\trec(l,y);\n\trec(y+1,r);\n\tpost[c++]=x;\n}\n\nint main(void){\n\tint i;\n\tscanf(\"%d\",&n);\n\t\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&pre[i]);\n\t}\n\t\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&in[i]);\n\t}\n\t\n\trec(0,n);\n\t\n\tfor(i=0;i<n;i++){\n\t\tif(i != n-1)printf(\"%d \",post[i]);\n\t\telse printf(\"%d\\n\",post[i]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint num;\nint pre[40],in[40];\nvoid post(int l,int r)\n{\n\tif(l>r)return;\n\t/*if(l==r)\n\t{\n\tif(in[l]==pre[0])\n\tprintf(\"%d\",in[l]);\n\telse\n\tprintf(\"%d \",in[l]);\n\tnum++;\n\treturn;\t\t\n\t}*/\n\tint x=pre[num],i;\n\tnum++;\n\tfor(i=l;i<=r;i++)\n\tif(in[i]==x)\n\tbreak;\n\tpost(l,i-1);\n\tpost(i+1,r);\n\tif(x==pre[0])\n\tprintf(\"%d\",x);\n\telse\n\tprintf(\"%d \",x);\t\n}\nint main(int argc, char *argv[])\n{\n\tint n,i;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++)\n\tscanf(\"%d\",&pre[i]);\n\tfor(i=0;i<n;i++)\n\tscanf(\"%d\",&in[i]);\n\tnum=0;\n\tpost(0,n-1);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define mymalloc(p,n) {p = malloc((n)*sizeof(*p));if ((p)==NULL) {printf(\"not enough memory?\\n\"); exit(1);};}\n\nvoid print(int fact, int flag){\n\tif(flag==0){\n\t\tprintf(\"%d\\n\",fact);\n\t}else{\n\t\tprintf(\"%d \",fact);\n\t}\n}\n\nint divide(int root,int *A,int *B,int p,int q,int flag){\n\tint i;\n\tif(q-p==0){\n\t\tprint(B[q],flag);\n\t\treturn root;\n\t}\n\tfor(i=p;i<=q;i++){\n\t\tif(B[i]==A[root]){\n\t\t\tif(i>p){root=divide(root+1,A,B,p,i-1,1);}\n\t\t\tif(i<q){root=divide(root+1,A,B,i+1,q,1);}\n\t\t\tprint(B[i],flag);\n\t\t\treturn root;\n\t\t}\n\t}\n}\n\nmain(){\n\tint i,n;\n\tint *A,*B;\n\tscanf(\"%d\",&n);\n\tmymalloc(A,n);\n\tmymalloc(B,n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\" %d\",&A[i]);\n\t}\n\tfor(i=0;i<n;i++){\n\t\tscanf(\" %d\",&B[i]);\n\t}\n\tdivide(0,A,B,0,n-1,0);\n\tfree(A);free(B);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n\n int P[41],I[41],Po[41],n,s,next=0;\n\n int find(int c){\n       int i;\n       for(i=0;i<n;i++){\n                if(I[i]==c)return i;\n                }\n       return 0;\n       }\n\n void rec(int l,int r){\n       int m,c;\n       if(l>=r)return;\n       c=P[next++];\n       m=find(c);\n       rec(l,m);\n       rec(m+1,r);\n       Po[s++]=c;\n       }\n\n int main(){\n       int i;\n       scanf(\"%d\",&n);\n       for(i=0;i<n;i++){\n               scanf(\"%d\",&P[i]);\n               }\n       for(i=0;i<n;i++){\n               scanf(\"%d\",&I[i]);\n               }\n       rec(0,n);\n       for(i=0;i<n-1;i++){\n               printf(\"%d \",Po[i]);\n               }\n       printf(\"%d\\n\",Po[i]);\n       return 0;\n       }\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 100\n\nint cnt = 0;\nint post_cnt = 0;\nint n;\nint pre[MAX], in[MAX], post[MAX];\n\nint find(int u){\n    int i;\n    for(i = 0; i < n; i++){\n        if(u == in[i]){\n            return i;\n        }\n    }\n\n\n    return -1;\n}\n\nvoid reconstruct(int l, int r){\n    if (l >= r) return;\n    int root = pre[cnt++];\n    int mid = find(root);\n\n    reconstruct(l, mid);\n    reconstruct(mid + 1, r);\n    post[post_cnt++] = root;\n}\n\nint main(){\n    int i;\n    scanf(\"%d\", &n);\n\n    for(i = 0; i < n; i++) scanf(\"%d\", &pre[i]);\n    for(i = 0; i < n; i++) scanf(\"%d\", &in[i]);\n\n    reconstruct(0, n);\n    \n    for(i = 0; i < n; i++){\n        if(i != n) printf(\"%d \", post[i]);\n        else printf(\"%d\", post[i]);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define POINT 41\n\nint P[POINT], I[POINT], Po[POINT];\nint n, now = 0, s = 0;\n\nvoid Rec(int, int);\n\nvoid Rec(int l, int r) {\n    int c,m;\n    \n//    printf(\"0\");\n    if(l >= r) {\n        return;\n    }\n    c = P[now++];\n    m = Find(c);\n    Rec(l, m);\n//    printf(\"1\");\n    Rec(m + 1, r);\n  //  printf(\"2\");\n    Po[s++] = c;\n}\n\nint Find(int c) {\n    int i;\n    \n    //接点番号が一致したIndexを返す\n    for(i = 0 ; i < n ; i++) {\n        if(c == I[i]) {\n            return i;\n        }\n    }\n    return 0;\n}\n\nint main(void){\n    int i;\n    \n    scanf(\"%d\",&n);\n    \n    //preoder include\n    for(i = 0 ; i < n ; i++) {\n        scanf(\"%d\",&P[i]);\n    }\n    \n    //inoder include\n    for(i = 0 ; i < n ; i++) {\n        scanf(\"%d\",&I[i]);\n    }\n    \n    Rec(0,n);\n    \n    for(i = 0 ; i < n-1 ; i++) {\n        printf(\"%d\",Po[i]);\n    }\n    printf(\"%d\\n\", Po[i]);\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "int preorder[40],inorder[40];\nvoid recover(int fp,int lp,int fi,int li){\n    int root=fi;\n    for(;root<li;root++)if(preorder[fp]==inorder[root])break;\n    if(fi<root)recover(fp+1,fp+(root-fi)+1,fi,root);\n    if(root<li-1)recover(fp+(root-fi)+1,lp,root+1,li);\n    printf(inorder[root]==preorder[0]?\"%d\\n\":\"%d \",inorder[root]);\n}\nmain(){\n    int n,i;\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)scanf(\"%d\",preorder+i);\n    for(i=0;i<n;i++)scanf(\"%d\",inorder+i);\n    recover(0,n,0,n);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX 40\n\nint n,pre[MAX],in[MAX];\n\nvoid Retree(int,int);\n\nint main()\n{\n  int i;\n\n  scanf(\"%d\",&n);\n\n  for(i=0;i<n;i++)\n    {\n      scanf(\"%d\",&pre[i]);\n    }\n  for(i=0;i<n;i++)\n    {\n      scanf(\"%d\",&in[i]);\n    }\n  \n  Retree(0,n);\n\n  return 0;\n}\n\nvoid Retree(int L,int R)\n{\n  static int i,k;\n  int c,m,j;\n  \n  if(L>=R)return;\n\n  c=pre[i++];\n\n  for(j=L;j<R;j++)\n    {\n      if(c==in[j])break;\n    }\n\n  Retree(L,j);\n  Retree(j+1,R);\n  \n  if(k==n-1)printf(\"%d\\n\",c);\n  else printf(\"%d \",c);\n  k++;\n}\n\n\n\n  \n  \n\n  \n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 50\n\nstruct NODE { int parent, left, right; };\n\nstruct NODE Tree[MAX];\nint N;\nint pre[MAX];\nint ino[MAX];\n\nint cnt = 0;\n\nint Top(int sp, int ep) {\n\tint ans;\n\tfor (int i = 0; i < 50; i++) {\n\t\tfor (int j = sp; j < ep; j++) {\n\t\t\tif (pre[i] == ino[j]) {\n\t\t\t\tans = j;\n\t\t\t\treturn ans;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Hierarchy(int sp, int top, int ep) {\n\tint lTop, rTop;\n\tif (ep - sp != 1) {\n\t\tif (sp != top) {\n\t\t\tlTop = Top(sp, top);\n\t\t\tTree[ino[top]].left = ino[lTop];\n\t\t\tTree[ino[lTop]].parent = ino[top];\n\t\t\tHierarchy(sp, lTop, top);\n\t\t}\n\t\tif (top + 1 != ep) {\n\t\t\trTop = Top(top + 1, ep);\n\t\t\tTree[ino[top]].right = ino[rTop];\n\t\t\tTree[ino[rTop]].parent = ino[top];\n\t\t\tHierarchy(top + 1, rTop, ep);\n\t\t}\n\t}\n\n}\n\nvoid Postorder(int id) {\n\tif (id == -1)return;\n\tPostorder(Tree[id].left);\n\tPostorder(Tree[id].right);\n\tprintf(\"%d\", id);\n\tcnt++;\n\tif (cnt != N)printf(\" \");\n}\n\nint main() {\n\tint root;\n\tfor (int i = 0; i < 50; i++) {\n\t\tTree[i].parent = -1; Tree[i].left = -1; Tree[i].right = -1;\n\t\tpre[i] = -1; ino[i] = -1;\n\t}\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d\", &pre[i]);\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d\", &ino[i]);\n\t}\n\troot = ino[Top(0, N)];\n\tHierarchy(0, Top(0, N), N);\n\n\tPostorder(root); printf(\"\\n\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint search(int arr[], int val, int n)\n{\n  int i;\n\n  for (i = 0; i < n; i++)\n    if (arr[i] == val)\n      return i;\n  return -1;\n}\n\nint postorder[45];\n\nint N;\n\n\nvoid po(int inorder[], int preorder[], int n) {\n\n  int rootIndex = search(inorder, preorder[0], n);\n\n  if (rootIndex > 0)\n    po(inorder, preorder + 1, rootIndex);\n\n  if (rootIndex != n - 1)\n    po(inorder + rootIndex + 1, preorder + rootIndex + 1, n - rootIndex - 1);\n\n  if (n == N)\n    printf(\"%d\\n\", preorder[0]);\n  else\n    printf(\"%d \", preorder[0]);\n}\n\nint main() {\n  int i;\n\n  scanf(\"%d\", &N);\n\n  int preorder[N];\n  int inorder[N];\n\n  for (i = 0; i < N; i++)\n    scanf(\"%d\", &preorder[i]);\n\n  for (i = 0; i < N; i++)\n    scanf(\"%d\", &inorder[i]);\n\n  po(inorder, preorder, N);\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n  if(l >= r) return;\n     int root = pre[pos++];\n     int m = distance(in.begin(), find(in.begin(), in.end(), root));\n     rec(l,m);\n     rec(m + 1,r);\n     post.push_back(root);\n}\n\nvoid solve(){\n  pos = 0;\n  rec(0, pre.size());\n  for(int i = ; i < n ; i++){\n    if(i) cout << \" \";\n    cout << post[i];\n  }\n  cout << endl;\n}\n\nint main(){\n  int k;\n  cin >> n;\n\n  for(int i = 0 ; i < n ; i++){\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for(int i = 0 ; i < n ; i++){\n    cin >> k;\n    in.push_back(k);\n  }\n\n  solve();\n\n  return 0;\n}\n     \n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define CHECK printf(\"check\\n\");\ntypedef struct node\n{\n  int id;\n  struct node *parent;\n  struct node *sibling;\n  struct node *child[2];\n  int degree;\n  int depth;\n  int height;\n  char *type;\n} *nodePointer;\nvoid init(nodePointer*,int);\nnodePointer make1node(void);\nvoid relationSet(nodePointer*,int,int*);\nvoid calcStatus(nodePointer*,int);\nint getDegree(nodePointer*,int);\nint getDepth(nodePointer*,int);\nint getHeight(nodePointer*,int);\nchar *getType(nodePointer*,int);\nvoid printNodeArray(nodePointer*,int);\nnodePointer getRoot(nodePointer*);\nvoid postorderWalkP1(nodePointer,nodePointer);\nvoid printWalk(int);\nvoid reconstructTree(nodePointer*,int*,int*,int);\nint main(void)\n{\n  int i;//counter\n  int n;//the number of nodes\n  nodePointer *arr;//array of nodePointer\n  nodePointer root;//used for postorderWalk\n  int *pre;//preorderWalk\n  int *in;//inorderWalk\n  scanf(\"%d\",&n);\n  arr=(nodePointer*)malloc(sizeof(nodePointer)*n);\n  init(arr,n);\n  pre=(int*)malloc(sizeof(int)*n);\n  in=(int*)malloc(sizeof(int)*n);\n  for(i=0;i<n;i++)\n    {\n      scanf(\"%d\",&pre[i]);\n      pre[i]--;\n    }\n  for(i=0;i<n;i++)\n    {\n      scanf(\"%d\",&in[i]);\n      in[i]--;\n    }\n  reconstructTree(arr,pre,in,n);\n  root=getRoot(arr);\n  postorderWalkP1(root,root);\n  return 0;\n}\nvoid init(nodePointer *arr,int n)\n{\n  int i;//counter\n  for(i=0;i<n;i++)\n    {\n      arr[i]=make1node();\n      arr[i]->id=i;\n      arr[i]->parent=NULL;\n      arr[i]->sibling=NULL;\n      arr[i]->child[0]=NULL;\n      arr[i]->child[1]=NULL;\n      arr[i]->degree=-1;\n      arr[i]->depth=-1;\n      arr[i]->height=-1;\n      arr[i]->type=\"\";\n    }\n}\nnodePointer make1node(void)\n{\n  nodePointer p=(nodePointer)malloc(sizeof(struct node));\n  return p;\n}\nvoid relationSet(nodePointer *arr,int id,int *childID)\n{\n  int i;//counter\n  for(i=0;i<2;i++)\n    {\n      if(childID[i]==-1) arr[id]->child[i]=NULL;\n      else\n\t{\n\t  arr[id]->child[i]=arr[childID[i]];\n\t  arr[childID[i]]->parent=arr[id];\n\t}\n    }\n  if(arr[id]->child[0]!=NULL&&arr[id]->child[1]!=NULL)\n    {\n      arr[childID[0]]->sibling=arr[childID[1]];\n      arr[childID[1]]->sibling=arr[childID[0]];\n    }\n}\nvoid calcStatus(nodePointer *arr,int n)\n{\n  int i;//counter\n  nodePointer p;\n  for(i=0;i<n;i++)\n    {\n      p=arr[i];\n      p->degree=getDegree(arr,i);\n      p->depth=getDepth(arr,i);\n      p->height=getHeight(arr,i);\n      p->type=getType(arr,i);\n    }\n}\nint getDegree(nodePointer *arr,int id)\n{\n  int i;//counter\n  int ret=0;//return number\n  for(i=0;i<2;i++)\n    {\n      if(arr[id]->child[i]!=NULL) ret++;\n    }\n  return ret;\n}\nint getDepth(nodePointer *arr,int id)\n{\n  int ret=0;//return value\n  nodePointer p;\n  for(p=arr[id];p->parent!=NULL;p=p->parent) ret++;\n  return ret;\n}\nint getHeight(nodePointer *arr,int id)\n{\n  int i;//counter\n  int ret[2];//return value(bigger one)\n  for(i=0;i<2;i++)\n    {\n      if(arr[id]->child[i]==NULL) ret[i]=0;\n      else ret[i]=1+getHeight(arr,arr[id]->child[i]->id);\n    }\n  if(ret[0]>ret[1]) return ret[0];\n  else return ret[1];\n}\nchar *getType(nodePointer *arr,int id)\n{\n  char *str[3]={\"root\",\"leaf\",\"internal node\"};\n  if(arr[id]->parent==NULL) return str[0];\n  if(arr[id]->child[0]==NULL&&arr[id]->child[1]==NULL) return str[1];\n  return str[2];\n}\nvoid printNodeArray(nodePointer *arr,int n)\n{\n  int i;//counter\n  for(i=0;i<n;i++)\n    {\n      printf(\"node %d: \",arr[i]->id);\n      if(arr[i]->parent==NULL) printf(\"parent = -1, \");\n      else printf(\"parent = %d, \",arr[i]->parent->id);\n      if(arr[i]->sibling==NULL) printf(\"sibling = -1, \");\n      else printf(\"sibling = %d, \",arr[i]->sibling->id);\n      printf(\"degree = %d, \",arr[i]->degree);\n      printf(\"depth = %d, \",arr[i]->depth);\n      printf(\"height = %d, \",arr[i]->height);\n      printf(\"%s\",arr[i]->type);\n      printf(\"\\n\");\n    }\n}\nnodePointer getRoot(nodePointer *arr)\n{\n  int i;\n  for(i=0;;i++)\n    {\n      if(arr[i]->parent==NULL) break;\n    }\n  return arr[i];\n}\nvoid postorderWalkP1(nodePointer p,nodePointer root)\n{\n  if(p!=NULL)\n    {\n      postorderWalkP1(p->child[0],root);\n      postorderWalkP1(p->child[1],root);\n      printWalk((p->id)+1);\n      if(p->id==root->id)\n\t{\n\t  printf(\"\\n\");\n\t}\n    }\n}\nvoid printWalk(int id)\n{\n  printf(\" %d\",id);\n}\n\nvoid reconstructTree(nodePointer *arr,int *pre,int *in,int n)\n{\n  int preIndex,inIndex;\n  if(n<=1) return;\n  for(preIndex=0;pre[preIndex]!=in[0];preIndex++)\n    {\n      arr[pre[preIndex]]->child[0]=arr[pre[preIndex+1]];\n      arr[pre[preIndex+1]]->parent=arr[pre[preIndex]];\n    }\n  if(pre[preIndex+1]==in[1]) inIndex=0;\n  else inIndex=1;\n  arr[in[inIndex]]->child[1]=arr[pre[preIndex+1]];\n  arr[pre[preIndex+1]]->parent=arr[in[inIndex]];\n  reconstructTree(arr,pre+preIndex+1,in+2,n-preIndex-1);\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define CHECK printf(\"check\\n\");\ntypedef struct node\n{\n  int id;\n  struct node *parent;\n  struct node *sibling;\n  struct node *child[2];\n  int degree;\n  int depth;\n  int height;\n  char *type;\n} *nodePointer;\nvoid init(nodePointer*,int);\nnodePointer make1node(void);\nvoid relationSet(nodePointer*,int,int*);\nvoid calcStatus(nodePointer*,int);\nint getDegree(nodePointer*,int);\nint getDepth(nodePointer*,int);\nint getHeight(nodePointer*,int);\nchar *getType(nodePointer*,int);\nvoid printNodeArray(nodePointer*,int);\nnodePointer getRoot(nodePointer*);\nint getPreorder(nodePointer,int);\nint getInorder(nodePointer,int);\nvoid postorderWalkP1(nodePointer,nodePointer);\nvoid printWalk(int);\nint reconstructTree(nodePointer*,int,int*,int*,int,int);\nint judge(nodePointer*,int);\nvoid printArray(int*,int);\nint *preWalk;//preorderWalk\nint *tempPreWalk;\nint *inWalk;//inorderWalk\nint *tempInWalk;\nint main(void)\n{\n  int i;//counter\n  int n;//the number of nodes\n  nodePointer *arr;//array of nodePointer\n  nodePointer root;//used for postorderWalk\n  scanf(\"%d\",&n);\n  arr=(nodePointer*)malloc(sizeof(nodePointer)*n);\n  init(arr,n);\n  preWalk=(int*)malloc(sizeof(int)*n);\n  tempPreWalk=(int*)malloc(sizeof(int)*n);\n  inWalk=(int*)malloc(sizeof(int)*n);\n  tempInWalk=(int*)malloc(sizeof(int)*n);\n  for(i=0;i<n;i++)\n    {\n      scanf(\"%d\",&preWalk[i]);\n      preWalk[i]--;\n    }\n  for(i=0;i<n;i++)\n    {\n      scanf(\"%d\",&inWalk[i]);\n      inWalk[i]--;\n    }\n  reconstructTree(arr,n,preWalk,inWalk,n,n);\n  root=getRoot(arr);\n  postorderWalkP1(root,root);\n  return 0;\n}\nvoid init(nodePointer *arr,int n)\n{\n  int i;//counter\n  for(i=0;i<n;i++)\n    {\n      arr[i]=make1node();\n      arr[i]->id=i;\n      arr[i]->parent=NULL;\n      arr[i]->sibling=NULL;\n      arr[i]->child[0]=NULL;\n      arr[i]->child[1]=NULL;\n      arr[i]->degree=-1;\n      arr[i]->depth=-1;\n      arr[i]->height=-1;\n      arr[i]->type=\"\";\n    }\n}\nnodePointer make1node(void)\n{\n  nodePointer p=(nodePointer)malloc(sizeof(struct node));\n  return p;\n}\nvoid relationSet(nodePointer *arr,int id,int *childID)\n{\n  int i;//counter\n  for(i=0;i<2;i++)\n    {\n      if(childID[i]==-1) arr[id]->child[i]=NULL;\n      else\n        {\n          arr[id]->child[i]=arr[childID[i]];\n          arr[childID[i]]->parent=arr[id];\n        }\n    }\n  if(arr[id]->child[0]!=NULL&&arr[id]->child[1]!=NULL)\n    {\n      arr[childID[0]]->sibling=arr[childID[1]];\n      arr[childID[1]]->sibling=arr[childID[0]];\n    }\n}\nvoid calcStatus(nodePointer *arr,int n)\n{\n  int i;//counter\n  nodePointer p;\n  for(i=0;i<n;i++)\n    {\n      p=arr[i];\n      p->degree=getDegree(arr,i);\n      p->depth=getDepth(arr,i);\n      p->height=getHeight(arr,i);\n      p->type=getType(arr,i);\n    }\n}\nint getDegree(nodePointer *arr,int id)\n{\n  int i;//counter\n  int ret=0;//return number\n  for(i=0;i<2;i++)\n    {\n      if(arr[id]->child[i]!=NULL) ret++;\n    }\n  return ret;\n}\nint getDepth(nodePointer *arr,int id)\n{\n  int ret=0;//return value\n  nodePointer p;\n  for(p=arr[id];p->parent!=NULL;p=p->parent) ret++;\n  return ret;\n}\nint getHeight(nodePointer *arr,int id)\n{\n  int i;//counter\n  int ret[2];//return value(bigger one)\n  for(i=0;i<2;i++)\n    {\n      if(arr[id]->child[i]==NULL) ret[i]=0;\n      else ret[i]=1+getHeight(arr,arr[id]->child[i]->id);\n    }\n  if(ret[0]>ret[1]) return ret[0];\n  else return ret[1];\n}\nchar *getType(nodePointer *arr,int id)\n{\n  char *str[3]={\"root\",\"leaf\",\"internal node\"};\n  if(arr[id]->parent==NULL) return str[0];\n  if(arr[id]->child[0]==NULL&&arr[id]->child[1]==NULL) return str[1];\n  return str[2];\n}\nvoid printNodeArray(nodePointer *arr,int n)\n{\n  int i;//counter\n  for(i=0;i<n;i++)\n    {\n      printf(\"node %d: \",arr[i]->id);\n      if(arr[i]->parent==NULL) printf(\"parent = -1, \");\n      else printf(\"parent = %d, \",arr[i]->parent->id);\n      if(arr[i]->sibling==NULL) printf(\"sibling = -1, \");\n      else printf(\"sibling = %d, \",arr[i]->sibling->id);\n      printf(\"degree = %d, \",arr[i]->degree);\n      printf(\"depth = %d, \",arr[i]->depth);\n      printf(\"height = %d, \",arr[i]->height);\n      printf(\"%s\",arr[i]->type);\n      printf(\"\\n\");\n    }\n}\nnodePointer getRoot(nodePointer *arr)\n{\n  int i;\n  for(i=0;;i++)\n    {\n      if(arr[i]->parent==NULL) break;\n    }\n  return arr[i];\n}\nvoid postorderWalkP1(nodePointer p,nodePointer root)\n{\n  if(p!=NULL)\n    {\n      if(p->id==root->id) printWalk(-1);\n      postorderWalkP1(p->child[0],root);\n      postorderWalkP1(p->child[1],root);\n      printWalk((p->id)+1);\n      if(p->id==root->id) printf(\"\\n\");\n    }\n}\nvoid printWalk(int id)\n{\n  static int flag=0;\n  if(id==-1) flag=0;\n  else\n    {\n      if(flag==1) printf(\" \");\n      else flag=1;\n      printf(\"%d\",id);\n    }\n}\n\nint reconstructTree(nodePointer *arr,int n,int *pre,int *in,int pNum,int iNum)\n{\n  int preIndex,inIndex;\n  //printf(\"p:%d..., \",pre[0]+1);\n  //printf(\"i:%d..., n=%d\\n\",in[0]+1,pNum);\n  for(preIndex=0;pre[preIndex]!=in[0]&&preIndex<pNum-1;preIndex++)\n    {\n      //printf(\"%d->%d\\n\",pre[preIndex]+1,pre[preIndex+1]+1);\n      arr[pre[preIndex]]->child[0]=arr[pre[preIndex+1]];\n      arr[pre[preIndex+1]]->parent=arr[pre[preIndex]];\n    }\n  //printf(\"n=%d,preIndex=%d\\n\",pNum,preIndex);\n  if(preIndex==pNum-1)\n    {\n      if(judge(arr,n)==0)\n        {\n          for(preIndex=0;pre[preIndex]!=in[0]&&preIndex<pNum-1;preIndex++)\n            {\n              //printf(\"%d-/->%d\\n\",pre[preIndex]+1,pre[preIndex+1]+1);\n              arr[pre[preIndex]]->child[0]=NULL;\n              arr[pre[preIndex+1]]->parent=NULL;\n            }\n          return 0;\n        }\n      else return 1;\n    }\n  if(in[1]==pre[preIndex+1]||preIndex==0) inIndex=0;\n  else inIndex=1;\n  for(;;inIndex++)\n    {\n      //printf(\"*%d->%d\\n\",in[inIndex]+1,pre[preIndex+1]+1);\n      arr[in[inIndex]]->child[1]=arr[pre[preIndex+1]];\n      arr[pre[preIndex+1]]->parent=arr[in[inIndex]];\n      if(reconstructTree(arr,n,pre+preIndex+1,in+inIndex+1,pNum-preIndex-1,iNum-inIndex-1)==1) break;\n      else\n        {\n          //printf(\"*%d-/->%d\\n\",in[inIndex]+1,pre[preIndex+1]+1);\n          arr[in[inIndex]]->child[1]=NULL;\n          arr[pre[preIndex+1]]->parent=NULL;\n        }\n    }\n  return 1;\n}\nint judge(nodePointer *arr,int n)\n{\n  int i;//counter\n  nodePointer p=getRoot(arr);\n  getPreorder(p,0);\n  getInorder(p,0);\n  //printf(\"[Preorder]\\n\");\n  //printArray(preWalk,n);\n  //printArray(tempPreWalk,n);\n  //printf(\"[Inorder]\\n\");\n  //printArray(inWalk,n);\n  //printArray(tempInWalk,n);\n  for(i=0;i<n;i++)\n    {\n      if(preWalk[i]!=tempPreWalk[i]) return 0;\n    }\n  for(i=0;i<n;i++)\n    {\n      if(inWalk[i]!=tempInWalk[i]) return 0;\n    }\n  return 1;\n}\nint getPreorder(nodePointer p,int index)\n{\n  if(p!=NULL)\n    {\n      tempPreWalk[index]=p->id;\n      index++;\n      index=getPreorder(p->child[0],index);\n      index=getPreorder(p->child[1],index);\n    }\n  return index;\n}\nint getInorder(nodePointer p,int index)\n{\n  if(p!=NULL)\n    {\n      index=getInorder(p->child[0],index);\n      tempInWalk[index]=p->id;\n      index++;\n      index=getInorder(p->child[1],index);\n    }\n  return index;\n}\nvoid printArray(int *arr,int n)\n{\n  int i;\n  for(i=0;i<n;i++)\n    {\n      if(i>0) printf(\" \");\n      printf(\"%d\",arr[i]);\n    }\n  printf(\"\\n\");\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n \nint n,pos;\nint a[40],b[40];\n \nvoid solve(int l,int r){\n  if(l>r)return;\n  if(l==r){\n    if(b[l]==a[0])printf(\"%d\",b[l]);\n    else printf(\"%d \",b[l]);\n    pos++;\n    return;\n  }\n \n  int x=a[pos],i;\n  pos++;\n  for(i=l;i<=r;i++){\n    if(b[i]==x)break;\n  }\n  solve(l,i-1);\n  solve(i+1,r);\n   \n  if(x==a[0])printf(\"%d\",x);\n  else printf(\"%d \",x);\n}\n \nint main(){\n  int i;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)scanf(\"%d\",&a[i]);\n  for(i=0;i<n;i++)scanf(\"%d\",&b[i]);\n  pos=0;\n  solve(0,n-1);\n  printf(\"\\n\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint n, pos, c;\nint pre[100], in[100], post[100];\n\nvoid rec(int left, int right){\n\tif( left >= right ){ return; }\n\tint root = pre[pos++];\n\tint m, i;\n\tfor(i=0; i<n; i++){\n\t\tif( root==in[i]){ m = i; break; }\n\t}\n\trec(left, m);\n\trec(m+1, right);\n\tpost[c++] = root;\n}\n\nint main(void){\n\tint i;\n\tscanf(\"%d\", &n);\n\tfor(i=0; i<n; i++){ scanf(\"%d\", &pre[i]); }\n\tfor(i=0; i<n; i++){ scanf(\"%d\", &in[i]); }\n\trec(0, n);\n\tfor(i=0; i<n-1; i++){ printf(\"%d \", post[i]); }\n\tprintf(\"%d\\n\", post[i]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l,int r) {\n  if (l>=r) \n    return ;\n  int root=pre[pos++];\n  int m=distance(in.begin(),find(in.begin(),in.end(),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n  \n}\nvoid solve() {\n  pos=0;\n  rec(0,pre.size());\n  for (int i=0; i<n; i++) {\n    if (i) \n      cout<<\" \"<<flush;\n    cout<<post[i]<<flush;\n  }\n  cout<<endl;\n}\nint main() {\n  std::ios::sync_with_stdio(false);\n  cout.tie(0);\n  cin.tie(0);\n  cin>>n;\n  int s;\n  for (int i=0; i<n; i++) {\n    cin>>s;\n    pre.push_back(s);\n  }\n  for (int i=0; i<n; i++) {\n    cin>>s;\n    in.push_back(s);\n  }\n  \n  \n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define MAX 100\n\n\nint n , pos , c , d = 0;\nint pre[1000] , in[1000],post[1000];\n\nint find(int a)\n{\n\tint i ;\n\tfor( i = 0; i < n; i++)\n\t{\n\t\tif(a == in[i]) return i;\n\t}\n\treturn 0;\n}\n\nvoid rec(int l , int r)\n{\n\tint a , b;\n\tif(l >= r) return;\n\ta = pre[d++];\n\tb = find(a);\n\trec(l,b);\n\trec(b+1,r);\n\tpost[c++] = a;\n}\n\n\n\nint main(void)\n{\n\tint i;\n\tscanf(\"%d\",&n);\n\t\n\tfor( i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\",&pre[i]);\n\t}\n\tfor( i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\",&in[i]);\n\t}\n\trec(0,n);\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tif(i != n-1)printf(\"%d \",post[i]);\n\t\telse printf(\"%d\\n\",post[i]);\n\t}\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define NIL -1\n\ntypedef struct{\n  int l;\n  int r;\n  short put;\n} Node;\n\nNode *T;\nshort *P,*I;\nint n;\n\nvoid Postorder(int u,short a){  \n  if(T[u].l!=NIL) Postorder(T[u].l,0);\n  if(T[u].r!=NIL) Postorder(T[u].r,0);\n  \n  printf(\"%d\",u);\n  if(a!=NIL)printf(\" \");\n}\n\nvoid reverse(int root,int p){\n  int i,j,u; //i=P,j=I\n\n  //printf(\"root=%d,p=%d,n=%d || \",root,p,n);\n  //for(i=0;i<n;i++) printf(\"P[i]=%d,P[i].put=%hd \",P[i],T[P[i]].put);\n  \n    for(i=root;i<n;i++){\n      T[ P[i] ].put=1;\n      if(P[i]==I[p]) break;\n      T[ P[i] ].l=P[i+1];\n    }\n\n    //printf(\" i=%d\\n\",i);\n\n  if(i!=n-1){\n    for(j=p ;j<n; j++){\n    \n      if(T[ I[j] ].put == NIL){\n\tT[ I[j-1] ].r = P[i+1];\n\treverse(i+1,j);\n\treturn;\t\n      }\n      \n    }\n  }\n  \n}\n    \n\nint main(){\n  int i,j,a=0,u;  \n\n  scanf(\"%d\",&n);\n\n  P=(short *)malloc(sizeof(short) * n);\n  I=(short *)malloc(sizeof(short) * n);\n\n  for(i=0;i<n;i++) scanf(\"%hd\",&P[i]);\n  for(i=0;i<n;i++){\n    scanf(\"%hd\",&I[i]);\n    if(I[i]>a) a=I[i];\n  }\n\n  T=(Node *)malloc(sizeof(Node) * a);\n  for(i=0;i<n;i++) T[ P[i] ].l = T[ P[i] ].r = T[ P[i] ].put = NIL;\n\n  reverse(0,0);\n\n  //for(i=0;i<n;i++) printf(\"i=%d,P[i]=%hd,T[ P[i] ].l=%d,T[ P[i] ].r=%d\\n\",i,P[i],T[P[i]].l,T[P[i]].r);\n\n  Postorder(P[0],NIL);  \n  printf(\"\\n\"); \n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct node{\n  int id;\n  struct node *parent;\n  struct node *left;\n  struct node *right;\n}Node;\n\nvoid print_tree(Node *x) {\n  if(x->left != NULL) print_tree(x->left);\n  if(x->right != NULL) print_tree(x->right);\n    printf(\"%d \", x->id);    \n}\n\nNode *make_tree(int *pre, int * in, int i, int j, int n, Node *p) {\n  if(i >= n) return NULL;\n  Node *p1 = (Node*)malloc(sizeof(Node));\n  p1->id = pre[i];\n  p1->parent = p;\n  p1->left = NULL;\n  p1->right = NULL;\n  if(pre[i] != in[j]) {\n    p1->left = make_tree(pre,in,i+1,j,n,p1);\n  }else{\n    Node *tmp = p;\n    while(1) {\n      if(tmp == NULL) {\n\ttmp = p1;\n\tbreak;\n      }\n      if(tmp->id == in[j+1]) {\n\tj++;\n\tbreak;\n      }\n      tmp = tmp->parent;\n    }\n    tmp->right = make_tree(pre,in,i+1,j+1,n,tmp);\n  }\n  return p1;\n}\n\nint main()\n{\n  int i,n,*preorder,*inorder;\n  scanf(\"%d\",&n);\n  preorder = (int*)malloc(sizeof(int) * n);\n  inorder = (int*)malloc(sizeof(int) * n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\",preorder+i);\n  }\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\",inorder+i);\n  }\n  Node *root = make_tree(preorder,inorder,0,0,n,NULL);\n  print_tree(root);\n  printf(\"\\b\\n\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define CHECK printf(\"check\\n\");\ntypedef struct node\n{\n  int id;\n  struct node *parent;\n  struct node *sibling;\n  struct node *child[2];\n  int degree;\n  int depth;\n  int height;\n  char *type;\n} *nodePointer;\nvoid init(nodePointer*,int);\nnodePointer make1node(void);\nvoid relationSet(nodePointer*,int,int*);\nvoid calcStatus(nodePointer*,int);\nint getDegree(nodePointer*,int);\nint getDepth(nodePointer*,int);\nint getHeight(nodePointer*,int);\nchar *getType(nodePointer*,int);\nvoid printNodeArray(nodePointer*,int);\nnodePointer getRoot(nodePointer*);\nint getPreorder(nodePointer,int);\nint getInorder(nodePointer,int);\nvoid postorderWalkP1(nodePointer,nodePointer);\nvoid printWalk(int);\nint reconstructTree(nodePointer*,int,int*,int*,int,int);\nint judge(nodePointer*,int);\nvoid printArray(int*,int);\nint *preWalk;//preorderWalk\nint *tempPreWalk;\nint *inWalk;//inorderWalk\nint *tempInWalk;\nint main(void)\n{\n  int i;//counter\n  int n;//the number of nodes\n  nodePointer *arr;//array of nodePointer\n  nodePointer root;//used for postorderWalk\n  scanf(\"%d\",&n);\n  arr=(nodePointer*)malloc(sizeof(nodePointer)*n);\n  init(arr,n);\n  preWalk=(int*)malloc(sizeof(int)*n);\n  tempPreWalk=(int*)malloc(sizeof(int)*n);\n  inWalk=(int*)malloc(sizeof(int)*n);\n  tempInWalk=(int*)malloc(sizeof(int)*n);\n  for(i=0;i<n;i++)\n    {\n      scanf(\"%d\",&preWalk[i]);\n      preWalk[i]--;\n    }\n  for(i=0;i<n;i++)\n    {\n      scanf(\"%d\",&inWalk[i]);\n      inWalk[i]--;\n    }\n  reconstructTree(arr,n,preWalk,inWalk,n,n);\n  root=getRoot(arr);\n  postorderWalkP1(root,root);\n  return 0;\n}\nvoid init(nodePointer *arr,int n)\n{\n  int i;//counter\n  for(i=0;i<n;i++)\n    {\n      arr[i]=make1node();\n      arr[i]->id=i;\n      arr[i]->parent=NULL;\n      arr[i]->sibling=NULL;\n      arr[i]->child[0]=NULL;\n      arr[i]->child[1]=NULL;\n      arr[i]->degree=-1;\n      arr[i]->depth=-1;\n      arr[i]->height=-1;\n      arr[i]->type=\"\";\n    }\n}\nnodePointer make1node(void)\n{\n  nodePointer p=(nodePointer)malloc(sizeof(struct node));\n  return p;\n}\nvoid relationSet(nodePointer *arr,int id,int *childID)\n{\n  int i;//counter\n  for(i=0;i<2;i++)\n    {\n      if(childID[i]==-1) arr[id]->child[i]=NULL;\n      else\n        {\n          arr[id]->child[i]=arr[childID[i]];\n          arr[childID[i]]->parent=arr[id];\n        }\n    }\n  if(arr[id]->child[0]!=NULL&&arr[id]->child[1]!=NULL)\n    {\n      arr[childID[0]]->sibling=arr[childID[1]];\n      arr[childID[1]]->sibling=arr[childID[0]];\n    }\n}\nvoid calcStatus(nodePointer *arr,int n)\n{\n  int i;//counter\n  nodePointer p;\n  for(i=0;i<n;i++)\n    {\n      p=arr[i];\n      p->degree=getDegree(arr,i);\n      p->depth=getDepth(arr,i);\n      p->height=getHeight(arr,i);\n      p->type=getType(arr,i);\n    }\n}\nint getDegree(nodePointer *arr,int id)\n{\n  int i;//counter\n  int ret=0;//return number\n  for(i=0;i<2;i++)\n    {\n      if(arr[id]->child[i]!=NULL) ret++;\n    }\n  return ret;\n}\nint getDepth(nodePointer *arr,int id)\n{\n  int ret=0;//return value\n  nodePointer p;\n  for(p=arr[id];p->parent!=NULL;p=p->parent) ret++;\n  return ret;\n}\nint getHeight(nodePointer *arr,int id)\n{\n  int i;//counter\n  int ret[2];//return value(bigger one)\n  for(i=0;i<2;i++)\n    {\n      if(arr[id]->child[i]==NULL) ret[i]=0;\n      else ret[i]=1+getHeight(arr,arr[id]->child[i]->id);\n    }\n  if(ret[0]>ret[1]) return ret[0];\n  else return ret[1];\n}\nchar *getType(nodePointer *arr,int id)\n{\n  char *str[3]={\"root\",\"leaf\",\"internal node\"};\n  if(arr[id]->parent==NULL) return str[0];\n  if(arr[id]->child[0]==NULL&&arr[id]->child[1]==NULL) return str[1];\n  return str[2];\n}\nvoid printNodeArray(nodePointer *arr,int n)\n{\n  int i;//counter\n  for(i=0;i<n;i++)\n    {\n      printf(\"node %d: \",arr[i]->id);\n      if(arr[i]->parent==NULL) printf(\"parent = -1, \");\n      else printf(\"parent = %d, \",arr[i]->parent->id);\n      if(arr[i]->sibling==NULL) printf(\"sibling = -1, \");\n      else printf(\"sibling = %d, \",arr[i]->sibling->id);\n      printf(\"degree = %d, \",arr[i]->degree);\n      printf(\"depth = %d, \",arr[i]->depth);\n      printf(\"height = %d, \",arr[i]->height);\n      printf(\"%s\",arr[i]->type);\n      printf(\"\\n\");\n    }\n}\nnodePointer getRoot(nodePointer *arr)\n{\n  int i;\n  for(i=0;;i++)\n    {\n      if(arr[i]->parent==NULL) break;\n    }\n  return arr[i];\n}\nvoid postorderWalkP1(nodePointer p,nodePointer root)\n{\n  if(p!=NULL)\n    {\n      if(p->id==root->id) printWalk(-1);\n      postorderWalkP1(p->child[0],root);\n      postorderWalkP1(p->child[1],root);\n      printWalk((p->id)+1);\n      if(p->id==root->id) printf(\"\\n\");\n    }\n}\nvoid printWalk(int id)\n{\n  static int flag=0;\n  if(id==-1) flag=0;\n  else\n    {\n      if(flag==1) printf(\" \");\n      else flag=1;\n      printf(\"%d\",id);\n    }\n}\n\nint reconstructTree(nodePointer *arr,int n,int *pre,int *in,int pNum,int iNum)\n{\n  int preIndex,inIndex;\n  //printf(\"p:%d..., \",pre[0]+1);\n  //printf(\"i:%d..., n=%d\\n\",in[0]+1,pNum);\n  for(preIndex=0;pre[preIndex]!=in[0]&&preIndex<pNum-1;preIndex++)\n    {\n      //printf(\"%d->%d\\n\",pre[preIndex]+1,pre[preIndex+1]+1);\n      arr[pre[preIndex]]->child[0]=arr[pre[preIndex+1]];\n      arr[pre[preIndex+1]]->parent=arr[pre[preIndex]];\n    }\n  //printf(\"n=%d,preIndex=%d\\n\",pNum,preIndex);\n  if(preIndex==pNum-1)\n    {\n      if(judge(arr,n)==0)\n        {\n          for(preIndex=0;pre[preIndex]!=in[0]&&preIndex<pNum-1;preIndex++)\n            {\n              //printf(\"%d-/->%d\\n\",pre[preIndex]+1,pre[preIndex+1]+1);\n              arr[pre[preIndex]]->child[0]=NULL;\n              arr[pre[preIndex+1]]->parent=NULL;\n            }\n          return 0;\n        }\n      else return 1;\n    }\n  if(in[1]==pre[preIndex+1]||preIndex==0) inIndex=0;\n  else inIndex=1;\n  for(;;inIndex++)\n    {\n      //printf(\"*%d->%d\\n\",in[inIndex]+1,pre[preIndex+1]+1);\n      arr[in[inIndex]]->child[1]=arr[pre[preIndex+1]];\n      arr[pre[preIndex+1]]->parent=arr[in[inIndex]];\n      if(reconstructTree(arr,n,pre+preIndex+1,in+inIndex+1,pNum-preIndex-1,iNum-inIndex-1)==1) break;\n      else\n        {\n          //printf(\"*%d-/->%d\\n\",in[inIndex]+1,pre[preIndex+1]+1);\n          arr[in[inIndex]]->child[1]=NULL;\n          arr[pre[preIndex+1]]->parent=NULL;\n        }\n    }\n  return 1;\n}\nint judge(nodePointer *arr,int n)\n{\n  int i;//counter\n  nodePointer p=getRoot(arr);\n  getPreorder(p,0);\n  getInorder(p,0);\n  //printf(\"[Preorder]\\n\");\n  //printArray(preWalk,n);\n  //printArray(tempPreWalk,n);\n  //printf(\"[Inorder]\\n\");\n  //printArray(inWalk,n);\n  //printArray(tempInWalk,n);\n  for(i=0;i<n;i++)\n    {\n      if(preWalk[i]!=tempPreWalk[i]) return 0;\n    }\n  for(i=0;i<n;i++)\n    {\n      if(inWalk[i]!=tempInWalk[i]) return 0;\n    }\n  return 1;\n}\nint getPreorder(nodePointer p,int index)\n{\n  if(p!=NULL)\n    {\n      tempPreWalk[index]=p->id;\n      index++;\n      index=getPreorder(p->child[0],index);\n      index=getPreorder(p->child[1],index);\n    }\n  return index;\n}\nint getInorder(nodePointer p,int index)\n{\n  if(p!=NULL)\n    {\n      index=getInorder(p->child[0],index);\n      tempInWalk[index]=p->id;\n      index++;\n      index=getInorder(p->child[1],index);\n    }\n  return index;\n}\nvoid printArray(int *arr,int n)\n{\n  int i;\n  for(i=0;i<n;i++)\n    {\n      if(i>0) printf(\" \");\n      printf(\"%d\",arr[i]);\n    }\n  printf(\"\\n\");\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nstruct BinaryTree\n{\n\tint data;\n\tBinaryTree *lchild,*rchild;\n};\nint post[40],i;\nvoid pre_in_order(int *pre,int l1,int r1,int *in,int l2,int r2,BinaryTree **root)\n{\n\tint m;\n\ti=0;\n\t*root=(BinaryTree *)malloc(sizeof(BinaryTree));\n\t(*root)->data=pre[l1];\n\tm=l2;\n\twhile(pre[l1]!=in[m])\n\tm++;\n\tif(m==l2)\n\t(*root)->lchild=NULL;\n\telse\n\tpre_in_order(pre,l1+1,m-l2+l1,in,l2,m-1,&(*root)->lchild);\n\tif(m==r2)\n\t(*root)->rchild=NULL;\n\telse\n\tpre_in_order(pre,m-l2+l1+1,r1,in,m+1,r2,&(*root)->rchild);\n}\nvoid postorder(BinaryTree *root)\n{\nif(root)\n{\npostorder(root->lchild);\npostorder(root->rchild);\npost[i]=root->data;\ni++;\n}\n}\nint main(int argc, char *argv[])\n{\n\tint pre[40];\n\tint in[40];\n\tint n,i;\n\tBinaryTree *root;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++)\n\tscanf(\"%d\",&pre[i]);\n\tfor(i=0;i<n;i++)\n\tscanf(\"%d\",&in[i]);\n\tpre_in_order(pre,0,n-1,in,0,n-1,&root);\n\tpostorder(root);\n\tfor(i=0;i<n;i++)\n\t{\n\t\tprintf(\"%d\",post[i]);\n\t\tif(i+1==n)\n\t\tprintf(\"\\n\");\n\t\telse\n\t\tprintf(\" \");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct node {\n  int id;\n  struct node *parent;\n  struct node *child[2];\n};\n\nstruct node *tree;\nint *pre, *in, *post, n;\n\nvoid reconstruction(int root, int l, int r);\nvoid postorder(struct node *p);\n\nint main(int argc, char *argv[])\n{\n  int i, j;\n\n  scanf(\"%d\", &n);\n\n  tree = (struct node *)malloc(sizeof(struct node) * (n + 1));\n  for (i = 0; i <= n; i++) {\n    tree[i].id = i;\n    tree[i].parent = NULL;\n    for (j = 0; j < 2; j++) tree[i].child[j] = NULL;\n  }\n  pre = (int *)malloc(sizeof(int) * n);\n  in = (int *)malloc(sizeof(int) * n);\n  post = (int *)malloc(sizeof(int) * n);\n\n  for (i = 0; i < n; i++) scanf(\"%d\", &pre[i]);\n  for (i = 0; i < n; i++) scanf(\"%d\", &in[i]);\n\n  for (i = 0; i < n; i++) {\n    if (in[i] == pre[0]) break;\n  }\n  reconstruction(i, 0, n - 1);\n\n  for (i = 1; i <= n; i++) {\n    if (tree[i].parent == NULL) break;\n  }\n  postorder(&tree[i]);\n  printf(\"\\n\");\n\n  return 0;\n}\n\nvoid reconstruction(int in_root, int l, int r)\n{\n  int i, j, pre_root, pre_left, pre_right, in_left, in_right;\n\n  if (l == r) return;\n\n  if (in_root != l) {\n    for (i = 0; i < n; i++) {\n      if (pre[i] == in[in_root]) break;\n    }\n    pre_left = i + 1;\n    for (i = 0; i < n; i++) {\n      if (in[i] == pre[pre_left]) break;\n    }\n    in_left = i;\n    tree[in[in_root]].child[0] = &tree[in[in_left]];\n    tree[in[in_left]].parent = &tree[in[in_root]];\n    reconstruction(in_left, l, in_root-1);\n  }\n\n  if (in_root != r) {\n    for (i = 0; i < n; i++) {\n      if (pre[i] == in[in_root]) break;\n    }\n    pre_right = i + (in_root - l) + 1;\n    for (i = 0; i < n; i++) {\n      if (in[i] == pre[pre_right]) break;\n    }\n    in_right = i;\n    tree[in[in_root]].child[1] = &tree[in[in_right]];\n    tree[in[in_right]].parent = &tree[in[in_root]];\n    reconstruction(in_right, in_root+1, r);\n  }  \n}\n\nvoid postorder(struct node *p)\n{\n  if (p->child[0] != NULL) postorder(p->child[0]);\n  if (p->child[1] != NULL) postorder(p->child[1]);\n  if (p->parent != NULL) printf(\"%d \", p->id);\n  else printf(\"%d\", p->id);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint pre[50], in[50], post[50];\nint k = 0, j = 0;\n\nvoid rec(int left, int right)\n{\n\tif (left >= right)\n\t\treturn;\n\tint root, p;\n\troot = pre[j++];\n\tfor (int i = left; i < right; i++)\n\t\tif (in[i] == root)\n\t\t\tp = i;\n\n\trec(left, p);\n\trec(p + 1, right);\n\tpost[k++] = root;\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &pre[i]);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &in[i]);\n\trec(0, n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (i)\n\t\t\tprintf(\" \");\n\t\tprintf(\"%d\", post[i]);\n\t}\n\tprintf(\"\\n\");\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 50\n\nstruct NODE { int parent, left, right; };\n\nstruct NODE Tree[MAX];\nint N;\nint pre[MAX];\nint ino[MAX];\n\nint cnt = 0;\n\nint Top(int sp, int ep) {\n\tint ans;\n\tfor (int i = 0; i < 50; i++) {\n\t\tfor (int j = sp; j < ep; j++) {\n\t\t\tif (pre[i] == ino[j]) {\n\t\t\t\tans = j;\n\t\t\t\treturn ans;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Hierarchy(int sp, int top, int ep) {\n\tint lTop, rTop;\n\tif (ep - sp != 1) {\n\t\tif (sp != top) {\n\t\t\tlTop = Top(sp, top);\n\t\t\tTree[ino[top]].left = ino[lTop];\n\t\t\tTree[ino[lTop]].parent = ino[top];\n\t\t\tif (sp != lTop)Hierarchy(sp, lTop, top);\n\t\t}\n\t\tif (top + 1 != ep) {\n\t\t\trTop = Top(top + 1, ep);\n\t\t\tTree[ino[top]].right = ino[rTop];\n\t\t\tTree[ino[rTop]].parent = ino[top];\n\t\t\tif (ep != rTop + 1)Hierarchy(top + 1, rTop, ep);\n\t\t}\n\t}\n\n}\n\nvoid Postorder(int id) {\n\tif (id == -1)return;\n\tPostorder(Tree[id].left);\n\tPostorder(Tree[id].right);\n\tprintf(\"%d\", id);\n\tcnt++;\n\tif (cnt != N)printf(\" \");\n}\n\nint main() {\n\tint root;\n\tfor (int i = 0; i < 50; i++) {\n\t\tTree[i].parent = -1; Tree[i].left = -1; Tree[i].right = -1;\n\t\tpre[i] = -1; ino[i] = -1;\n\t}\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d\", &pre[i]);\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d\", &ino[i]);\n\t}\n\troot = ino[Top(0, N)];\n\tHierarchy(0, Top(0, N), N);\n\n\tPostorder(root); printf(\"\\n\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define MAX 100\n\nint n,c,d=0;\nint i;\nint pre[1000],in[1000],post[1000];\n\nint find(int x){\n  for(i=0; i<n;i++){\n    if(x==in[i]){return i;}\n  }\n\n  return 0;\n}\n\nvoid rec(int l, int r){\n  int a,b;\n  if(l>=r){return;}\n\n  a=pre[d++];\n  b=find(a);\n\n  rec(l,b);\n  rec(b+1,r);\n  post[c++]=a;\n}\n\nint main(void){\n  scanf(\"%d\",&n);\n\n  for(i=0; i<n;i++){\n    scanf(\"%d\",&pre[i]);\n  }\n\n  for(i=0; i<n;i++){\n    scanf(\"%d\",&in[i]);\n  }\n\n  rec(0,n);\n\n  for(i=0; i<n;i++){\n    if(i!=n-1){\n      printf(\"%d \",post[i]);\n    }else{\n      printf(\"%d\\n\",post[i]);\n    }\n\n  }\n\n  return 0;\n\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint search(int arr[], int val, int n)\n{\n  int i;\n\n  for (i = 0; i < n; i++)\n    if (arr[i] == val)\n      return i;\n  return -1;\n}\n\nint postorder[45];\n\nvoid po(int inorder[], int preorder[], int n) {\n\n  int rootIndex = search(inorder, preorder[0], n);\n\n  if (rootIndex > 0)\n    po(inorder, preorder + 1, rootIndex);\n\n  if (rootIndex != n - 1)\n    po(inorder + rootIndex + 1, preorder + rootIndex + 1, n - rootIndex - 1);\n\n  printf(\"%d \", preorder[0]);\n}\n\nint main() {\n  int n, i;\n\n  scanf(\"%d\", &n);\n\n  int preorder[n];\n  int inorder[n];\n\n  for (i = 0; i < n; i++)\n    scanf(\"%d\", &preorder[i]);\n\n  for (i = 0; i < n; i++)\n    scanf(\"%d\", &inorder[i]);\n\n  po(inorder, preorder, n);\n  printf(\"\\n\");\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stddef.h>\n\nint indent = 0;\n\nint search(int *data, int left, int right, int x)\n{\n\tfor(int i = left; i <= right; ++i)\n\t{\n\t\tif(data[i] == x) { return i; }\n\t}\n\treturn -1;\n}\n\nvoid reconstruct(int *pre, int pre_idx, int *in, int in_left, int in_right)\n{\n\tif(in_left <= in_right)\n\t{\n\t\tint pos = search(in, in_left, in_right, pre[pre_idx]);\n\t\tif(pos != -1)\n\t\t{\n\t\t\tint pre_left  = pre_idx + 1;\n\t\t\tint pre_right = pre_idx + 1 + (pos - in_left);\n\n\t\t\treconstruct(pre, pre_left,  in, in_left, pos - 1);\n\t\t\treconstruct(pre, pre_right, in, pos + 1, in_right);\n\t\t}\n\t\t\n\t\tprintf(\"%d\", pre[pre_idx]);\n\t\tif(pre_idx != 0) { printf(\" \"); }\n\t}\n}\n\nint main()\n{\n\tint n, pre[40], in[40];\n\t\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tscanf(\"%d\", &pre[i]);\n\t}\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tscanf(\"%d\", &in[i]);\n\t}\n\n\treconstruct(pre, 0, in, 0, n-1);\n\tprintf(\"\\n\");\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "int preorder[40],inorder[40];\nvoid recover(int fp,int lp,int fi,int li){\n    int root=fi;\n    for(;root<li;root++)if(preorder[fp]==inorder[root])break;\n    if(fi<root)recover(fp+1,fp+(root-fi)+1,fi,root);\n    if(root<li-1)recover(fp+(root-fi)+1,lp,root+1,li);\n    printf(inorder[root]==preorder[0]?\"%d\\n\":\"%d \",inorder[root]);\n}\nmain(){\n    int n,i;\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)scanf(\"%d\",preorder+i);\n    for(i=0;i<n;i++)scanf(\"%d\",inorder+i);\n    recover(0,n,0,n);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "      #include<stdio.h>\n\n\n      int P[41],I[41],Q[41],n,now=0,s;\n\n      int Find(int c)\n      {\n\n        int i;\n\n        for(i=0;i<n;i++){\n          if(c==I[i])return i;\n        }\n\n        return 0;\n\n      }\n\n      void Rec(int l,int r)\n      {\n        int c,n;\n\n        if(l>=r)return;\n\n        c=P[now++];\n        n=Find(c);\n\n        Rec(l,n);\n        Rec(n+1,r);\n\n        Q[s++]=c;\n\n      }\n\n\n\n      int main()\n      {\n        int i;\n\n        scanf(\"%d\",&n);\n\n        for(i=0;i<n;i++){\n          scanf(\"%d\",&P[i]);\n        }\n\n        for(i=0;i<n;i++){\n          scanf(\"%d\",&I[i]);\n        }\n\n        Rec(0,n);\n\n        for(i=0;i<n-1;i++){\n          printf(\"%d \",Q[i]);\n        }\n\n        printf(\"%d\\n\",Q[i]);\n\n      return 0;\n      }\n\n"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, pos;\nvector<int> pre, in, post;\n\nvoid rec(int l, int r){\n  if( l >= r ) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(), in.end(), root));\n  rec(l, m);\n  rec(m+1, r);\n  post.push_back(root);\n}\n\nvoid solve(){\n  int i;\n  pos = 0;\n  rec(0, pre.size());\n  for( i = 0 ; i < n ; i++ ){\n    if(i) printf(\" \");\n    printf(\"%d\", post[i]);\n  }\n  printf(\"\\n\");\n}\n\nint main(){\n  int i, k;\n\n  scanf(\"%d\", &n);\n\n  for( i = 0 ; i < n ; i++ ){\n    scanf(\"%d\", &k);\n    pre.push_back(k);\n  }\n\n  for( i = 0 ; i < n ; i++ ){\n    scanf(\"%d\", &k);\n    in.push_back(k);\n  }\n\n  solve();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nstruct BinaryTree\n{\n\tint data;\n\tBinaryTree *lchild,*rchild;\n};\nint post[40],i;\nvoid pre_in_order(int *pre,int l1,int r1,int *in,int l2,int r2,BinaryTree **root)\n{\n\tint m;\n\ti=0;\n\t*root=(BinaryTree *)malloc(sizeof(BinaryTree));\n\t(*root)->data=pre[l1];\n\tm=l2;\n\twhile(pre[l1]!=in[m])\n\tm++;\n\tif(m==l2)\n\t(*root)->lchild=NULL;\n\telse\n\tpre_in_order(pre,l1+1,m-l2+l1,in,l2,m-1,&(*root)->lchild);\n\tif(m==r2)\n\t(*root)->rchild=NULL;\n\telse\n\tpre_in_order(pre,m-l2+l1+1,r1,in,m+1,r2,&(*root)->rchild);\n}\nvoid postorder(BinaryTree *root)\n{\nif(root)\n{\npostorder(root->lchild);\npostorder(root->rchild);\npost[i]=root->data;\ni++;\n}\n}\nint main(int argc, char *argv[])\n{\n\tint pre[40];\n\tint in[40];\n\tint n,i;\n\tBinaryTree *root;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++)\n\tscanf(\"%d\",&pre[i]);\n\tfor(i=0;i<n;i++)\n\tscanf(\"%d\",&in[i]);\n\tpre_in_order(pre,0,n-1,in,0,n-1,&root);\n\tpostorder(root);\n\tfor(i=0;i<n;i++)\n\t{\n\t\tprintf(\"%d\",post[i]);\n\t\tif(i+1==n)\n\t\tprintf(\"\\n\");\n\t\telse\n\t\tprintf(\" \");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define NUL -1\nconst int N_MAX = 45;\nint root;\nstruct Node{\n    int parent, left, right;\n};\nNode tree[N_MAX];\nint pre[N_MAX], in[N_MAX];\n\nvoid reConstruct(int parent, int * preP, int * inP, int n, bool isLeft){\n    if(n==0) return;\n    int nowRoot = preP[0];\n    tree[nowRoot].parent = parent;\n    //getchar();\n    //cout<<\"-- nowRoot: \"<<nowRoot<<endl;\n    if(parent==NUL){\n        root=nowRoot;\n    }else if(isLeft){\n        tree[parent].left=nowRoot;\n    }else{\n        tree[parent].right=nowRoot;\n    }\n    if(n==1)return;\n    int flag = 0;\n    for(;flag<n;flag++){\n        if(inP[flag]==nowRoot) break;\n    }\n    //cout<<\"nowRoot: \"<<nowRoot<<\" flag: \"<<flag<<endl;\n    reConstruct(nowRoot, preP+1, inP, flag, true);\n    reConstruct(nowRoot, preP+1+flag, inP+1+flag, n-flag-1, false);\n}\n\nvoid post(int id){\n    if(id==NUL) return;\n    if(tree[id].left==NUL&&tree[id].right==NUL&&id!=root){\n        printf(\"%d \", id);\n        //cout<<id<<\" \";\n        return;\n    }\n    post(tree[id].left);\n    post(tree[id].right);\n    if(id==root){\n        printf(\"%d\", id);\n        //cout<<id<<endl;\n    }else{\n        printf(\"%d \", id);\n        //cout<<id<<\" \";\n    }\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    //cin>>n;\n    for(int i=0;i<n;i++){\n        scanf(\"%d\", &pre[i]);\n        //cin>>pre[i];\n        tree[i].parent=tree[i].left=tree[i].right=NUL;\n    }\n    tree[n].parent=tree[n].left=tree[n].right=NUL;\n    for(int i=0;i<n;i++){\n        scanf(\"%d\", &in[i]);\n        //cin>>in[i];\n    }\n    reConstruct(NUL, pre, in, n, true);\n    /*//Debugging/\n    for(int i=1;i<=n;i++){\n        cout<<\"node\"<<i<<\": p: \"<<tree[i].parent<<\"  l: \"<<tree[i].left<<\"  r: \"<<tree[i].right<<endl;\n    }\n    ///Debugging*/\n    post(root);\n    //cout<<\"root: \"<<root<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define OUTPUT__LENGTH (128)\nchar _out[OUTPUT__LENGTH];\nchar *_o = _out;\nvoid write_uint(int n) {\n    if(!n) {\n        *_o++ = '0';\n        return;\n    }\n    char buf[11];\n    int i = 0;\n    while(n) buf[i++] = (n % 10 + '0'), n /= 10;\n    while(i--) *_o++ = buf[i];\n}\nint get_uint() {\n    int n = 0;\n    int c = getchar_unlocked();\n    if(c < 48 || 57 < c) return c;\n    while(47 < c && c < 58) {\n        n = 10 * n + (c & 0xf);\n        c = getchar_unlocked();\n    }\n    return n;\n}\nint *find(int *first, int *last, const int value) {\n    for(;first!=last;++first)\n        if(*first == value) return first;\n    return last;\n}\n\ntypedef struct Node {\n    int parent, left, right, depth, height, sibling;\n} Node;\ntypedef struct BinaryTree {\n    Node nodes[40];\n    int root;\n} BinaryTree;\nvoid bt_init(BinaryTree *BT) {\n    for(int i = 0; i < 40; ++i) BT->nodes[i].parent = -1;\n}\nvoid bt_make(BinaryTree *BT) {\n    for(int i = 0; i < 40; ++i) {\n        if(BT->nodes[i].parent == -1) {\n            BT->root = i;\n            break;\n        }\n    }\n}\nvoid bt_add_node(BinaryTree *BT, int id, int l, int r) {\n    BT->nodes[id].left = l;\n    BT->nodes[id].right = r;\n    if(~l) BT->nodes[l].parent = id;\n    if(~r) BT->nodes[r].parent = id;\n}\nint bt_pre_in(BinaryTree *BT, int *pre, int *in, int l, int r) {\n    static int pos = 0;\n    if(l >= r) return -1;\n    int root = pre[pos++];\n    int mid = (int)(find(in, in+r, root) - in);\n    int ln = bt_pre_in(BT, pre, in, l, mid);\n    int rn = bt_pre_in(BT, pre, in, mid+1, r);\n    bt_add_node(BT, root, ln, rn);\n    return root;\n}\nvoid bt_pr_postorder(BinaryTree *BT, int id) {\n    if(id == -1) return;\n    bt_pr_postorder(BT, BT->nodes[id].left);\n    bt_pr_postorder(BT, BT->nodes[id].right);\n    *_o++ = ' ';\n    write_uint(id+1);\n}\nint main(int argc, char **argv) {\n    int n = get_uint();\n    int pre[n], in[n];\n    for(int i = 0; i < n; ++i) pre[i] = get_uint()-1;\n    for(int i = 0; i < n; ++i) in[i] = get_uint()-1;\n    BinaryTree BT;\n    bt_init(&BT);\n    bt_pre_in(&BT, pre, in, 0, n);\n    bt_make(&BT);\n    bt_pr_postorder(&BT, BT.root);\n    for(char *p = _out+1; p!=_o;++p) putchar_unlocked(*p);\n    putchar_unlocked('\\n');\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define MAX 100\n\n\nint n , c , d = 0;\nint pre[1000] , in[1000],post[1000];\n\nint find(int x)\n{\n\tint i ;\n\tfor( i = 0; i < n; i++)\n\t{\n\t\tif(x == in[i]) return i;\n\t}\n\treturn 0;\n}\n\nvoid rec(int l , int r)\n{\n\tint a , b;\n\tif(l >= r) return;\n\ta = pre[d++];\n\tb = find(a);\n\trec(l,b);\n\trec(b+1,r);\n\tpost[c++] = a;\n}\n\n\n\nint main(void)\n{\n\tint i;\n\tscanf(\"%d\",&n);\n\t\n\tfor( i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\",&pre[i]);\n\t}\n\t\n\tfor( i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\",&in[i]);\n\t}\n\t\n\trec(0,n);\n\t\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tif(i != n-1)printf(\"%d \",post[i]);\n\t\telse printf(\"%d\\n\",post[i]);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\n//============================================================================\n#define pred(x) ((x)-1)\n#define succ(x) ((x)+1)\n//============================================================================\nstruct Node{\n    short  id;\n    struct Node *parent;\n    struct Node *left, *right;\n};\ntypedef struct Node TNode;\n//============================================================================\nstruct Chain{\n    struct Chain *prev;\n    TNode *node;\n    struct Chain *next;\n};\ntypedef struct Chain TChain;\nTChain *RootChain;\n//============================================================================\n//============================================================================\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nTChain *ChainAlloc(void)\n{\n    TChain *ptr;\n    ptr=malloc(sizeof(TChain));\n    if (ptr==NULL)\n        exit(1);\n    memset(ptr, 0, sizeof(TChain));\n    return ptr;\n}\n//----------------------------------------------------------------------------\nvoid inschain(TChain *chn, TNode *node)\n{\n    while(chn->next!=NULL)\n        chn=chn->next;\n    chn->next=ChainAlloc();\n    chn->next->node=node;\n    chn->next->prev=chn;\n}\n//----------------------------------------------------------------------------\nvoid delchain(TChain *chn)\n{\n    if (chn->prev){\n        chn->prev->next=chn->next;\n    }\n    if (chn->next){\n        chn->next->prev=chn->prev;\n    }\n    free(chn);\n}\n//----------------------------------------------------------------------------\nTChain *searchchain(TChain *chn, short id)\n{\n    do{\n        if (chn->node->id==id)\n            return chn;\n        if (chn->node->left && chn->node->left->id==id)\n            return chn;\n        if (chn->node->right && chn->node->right->id==id)\n            return chn;\n        chn=chn->next;\n    }while(chn!=NULL);\n    return NULL;\n}\n//----------------------------------------------------------------------------\nvoid pushnode(TNode *node)\n{\n    if (RootChain==NULL){\n        RootChain=ChainAlloc();\n        RootChain->node=node;\n    }else{\n        inschain(RootChain, node);\n    }\n}\n//----------------------------------------------------------------------------\nTNode *popnode(short id)\n{\n    TChain *chn; TNode *node;\n\n    node=NULL;\n    chn=searchchain(RootChain, id);\n    if (chn){\n        if (chn->node->id==id)\n            node=chn->node;\n        else\n        if (chn->node->left && chn->node->left->id==id)\n            node=chn->node->left;\n        else\n        if (chn->node->right && chn->node->right->id==id)\n            node=chn->node->right;\n        if (node==chn->node)\n            delchain(chn);\n    }\n    return node;\n}\n//----------------------------------------------------------------------------\nTNode *nodealloc(void)\n{\n    TNode *node;\n    node=malloc(sizeof(TNode));\n    if (node==NULL){\n        fprintf(stderr, \"not enough memry\\n\");\n        exit(1);\n    }\n    memset(node, 0, sizeof(TNode));\n    return node;\n}\n//----------------------------------------------------------------------------\nTNode *existid(TNode *node, short id)\n{\n    TNode *nd;\n\n    if (node==NULL || node->id==id)\n        return node;\n    if ((nd=existid(node->left, id))!=NULL)\n        return nd;\n    nd=existid(node->right, id);\n    return nd;\n}\n//----------------------------------------------------------------------------\nvoid putnode(TNode **root, TNode **node, TNode *parent, short id)\n{\n    TNode *nd;\n\n    if ((nd=existid(*root, id))==NULL)\n        nd=popnode(id);\n    if (nd==NULL){\n        *node=nodealloc();\n    }else{\n        *node=nd;\n        //nd->parent=*node;\n        if (*root==nd){\n            *root=parent;\n            while((*root)->parent!=NULL)\n                *root=(*root)->parent;\n        }\n    }\n    (*node)->id=id;\n    (*node)->parent=parent;\n}\n//----------------------------------------------------------------------------\nTNode *rootnode(TNode *node)\n{\n    while(node->parent)\n        node=node->parent;\n    return node;\n}\n//----------------------------------------------------------------------------\nvoid getnode(FILE *file, TNode **node)\n{\n    long id,left,right; TNode *ser;\n\n    fscanf(file, \"%ld\", &id);\n    fscanf(file, \"%ld\", &left);\n    fscanf(file, \"%ld\", &right);\n    if (*node==NULL){\n        *node=nodealloc();\n        ser=*node;\n        pushnode(*node);\n    }else\n        ser=existid(*node, id);\n    if (ser==NULL){\n        ser=popnode(id);\n        if (ser==NULL)\n            ser=nodealloc();\n    }\n    if (*node!=rootnode(ser))\n    pushnode(ser);\n    ser->id=id;\n    if (0<=left)\n        putnode(node, &ser->left, ser, left);\n    if (0<=right)\n        putnode(node, &ser->right, ser, right);\n}\n//----------------------------------------------------------------------------\nshort depth(TNode *node)\n{\n    short n;\n\n    for (n=0; node->parent!=NULL; n++)\n        node=node->parent;\n    return n;\n}\n//----------------------------------------------------------------------------\nshort height(TNode *node)\n{\n    short l,r;\n\n    if (node==NULL)\n        return -1;\n    l=succ(height(node->left));\n    r=succ(height(node->right));\n    return (r<l)?l:r;\n}\n//----------------------------------------------------------------------------\nchar *root=\"root\";\nchar *internalroot=\"internal node\";\nchar *leaf=\"leaf\";\nchar *nodetype(TNode *node)\n{\n    if (node->parent==NULL)\n        return root;\n    if (node->left!=NULL || node->right!=NULL)\n        return internalroot;\n    return leaf;\n}\n//----------------------------------------------------------------------------\nvoid output(TNode *root, long n)\n{\n    short i,j,cnt,id,sib,deg; TNode *node;\n\n    for (i=cnt=0; cnt<n; i++){\n        node=existid(root, i);\n        if (node!=NULL){\n            cnt++;\n            sib=-1;\n            if (node->parent!=NULL && node->parent->left!=NULL && node->parent->right!=NULL){\n                if (node->parent->left==node)\n                    sib=node->parent->right->id;\n                else\n                    sib=node->parent->left->id;\n            }\n            deg=(node->left==NULL)?0:1;\n            deg+=(node->right==NULL)?0:1;\n            id=(node->parent==NULL)?-1:node->parent->id;\n            printf(\"node %d: \", node->id);\n            printf(\"parent = %d, \", id);\n            printf(\"sibling = %d, \", sib);\n            printf(\"degree = %d, \", deg);\n            printf(\"depth = %d, \", depth(node));\n            printf(\"height = %d, \", height(node));\n            printf(\"%s\\n\", nodetype(node));\n        }\n    }\n}\n//----------------------------------------------------------------------------\nvoid preorder(TNode *node)\n{\n    if (node==NULL)\n        return;\n    printf(\" %d\", node->id);\n    preorder(node->left);\n    preorder(node->right);\n}\n//----------------------------------------------------------------------------\nvoid inorder(TNode *node)\n{\n    if (node==NULL)\n        return;\n    inorder(node->left);\n    printf(\" %d\", node->id);\n    inorder(node->right);\n    //printf(\" %d\", node->id);\n}\n//----------------------------------------------------------------------------\nvoid postorder(TNode *node)\n{\n    static short space=0;\n\n    if (node==NULL)\n        return;\n    postorder(node->left);\n    postorder(node->right);\n    if (space)\n        printf(\" \");\n    printf(\"%d\", node->id);\n    space=1;\n}\n//----------------------------------------------------------------------------\nvoid treewalk(TNode *node, short n)\n{\n    printf(\"Preorder\\n\");\n    preorder(node);\n    printf(\"\\nInorder\\n\");\n    inorder(node);\n    printf(\"\\nPostorder\\n\");\n    postorder(node);\n    printf(\"\\n\");\n}\n//----------------------------------------------------------------------------\nvoid reconstruct(TNode *node, short *pre, short *ino, short n)\n{\n    short i;\n\n    node->id = *pre;\n    if (n==1)\n        return;\n    for (i=0; ino[i]!=*pre; i++);\n    if (i){\n        node->left=nodealloc();\n        node->left->parent=node;\n        reconstruct(node->left, succ(pre), ino, i);\n    }\n    i++;\n    if (i<n){\n        node->right=nodealloc();\n        node->right->parent=node;\n        reconstruct(node->right, &pre[i], &ino[i], n-i);\n    }\n}\n//----------------------------------------------------------------------------\nvoid inputorder(FILE *file)\n{\n    long i,n,m; TNode *root; char buffer[20];\n\n    RootChain=NULL;\n    fgets(buffer, sizeof(buffer)-1, file);\n    sscanf(buffer, \"%ld\", &n);\n    for (i=0, root=NULL; i<n; i++){\n        getnode(file, &root);\n        //printf(\"%08X\\n\", root);\n    }\n    while(root->parent)\n        root=root->parent;\n    //output(root, n);\n    treewalk(root, n);\n}\n//----------------------------------------------------------------------------\n#define MAX_N 40\nvoid input(FILE *file)\n{\n    long i,n; TNode *root; char buffer[20]; short preorder[MAX_N], inorder[MAX_N];\n\n    memset(preorder, 0, sizeof(preorder));\n    memset(inorder, 0, sizeof(inorder));\n    fgets(buffer, sizeof(buffer)-1, file);\n    sscanf(buffer, \"%ld\", &n);\n    root=nodealloc();\n    for (i=0; i<n; i++){\n        fscanf(file, \"%hd\", &preorder[i]);\n    }\n    for (i=0; i<n; i++){\n        fscanf(file, \"%hd\", &inorder[i]);\n    }\n    reconstruct(root, preorder, inorder, n);\n    postorder(root);\n    printf(\"\\n\");\n}\n//============================================================================\n#ifndef DESKTOP\nint main()\n{\n    input(stdin);\n    return 0;\n}\n#endif"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct {\n\tint parent;\n\tint left, right;\n}Node;\n\nint linear_search(int* xs, int size, int x)\n{\n\tint i;\n\tfor (i = 0; i < size; i++) {\n\t\tif (xs[i] == x) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nNode tree[50];\n\nint prewalked[50];\nint inwalked[50];\n\nint n;\n\nint reconstruction_tree(int from, int to, int root_pos, int parent)\n{\n\tint i;\n\tint v;\n\n\tfor (i = from; i < to; i++) {\n\t\tif ((v = inwalked[i]) == prewalked[root_pos]) {\n\t\t\ttree[v].parent = parent;\n\n\t\t\ttree[v].left = reconstruction_tree(from, i, root_pos + 1, v);\n\t\t\ttree[v].right = reconstruction_tree(i+1, to, root_pos +  (i - from) + 1, v);\n\n\t\t\treturn v;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nvoid postorder_walk(int p, int root)\n{\n\tif (p > n || p < 0) {\n\t\treturn;\n\t}\n\tpostorder_walk(tree[p].left, 0);\n\tpostorder_walk(tree[p].right, 0);\n\tif (root = 1) {\n\t\tprintf(\"%d\", p);\n\t}\n\telse {\n\t\tprintf(\" %d\", p);\n\t}\n}\n\nint main()\n{\n\tint i;\n\tint root;\n\n\tfor (i = 0; i < 50; i++) {\n\t\ttree[i].parent = -1;\n\t}\n\n\tscanf(\"%d\", &n);\n\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &(prewalked[i]));\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &(inwalked[i]));\n\t}\n\n\troot = reconstruction_tree(0, n, 0, -1);\n\n\tpostorder_walk(root, 1);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint *pre, *in, *post, pos, target, n;\n\nint Lsearch(int);\nvoid Rec(int, int);\n\nint main(void)\n{\n  int i;\n  scanf(\"%d\", &n);\n  pre = (int*)malloc(sizeof(int) * n);\n  in = (int*)malloc(sizeof(int) * n);\n  post = (int*)malloc(sizeof(int) * n);\n  for (i = 0; i < n; i++) scanf(\"%d\", &pre[i]);\n  for (i = 0; i < n; i++) scanf(\"%d\", &in[i]);\n  Rec(0, n - 1);\n  for (i = 0; i < n- 1; i++) printf(\"%d \", post[i]);\n  printf(\"%d\\n\",post[i]);\n  free(pre);\n  free(in);\n  free(post);\n}\n\nint Lsearch(int data)\n{\n  int i;\n  for (i = 0; i < n; i++) {\n    if (in[i] == data) return i;\n  }\n  return n;\n}\n\nvoid Rec(int left, int right)\n{\n  int root, dis;\n  if (left > right) return;\n  root = pre[pos++];\n  dis = Lsearch(root);\n  Rec(left, dis - 1);\n  Rec(dis + 1, right);\n  post[target++] = root;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX 40\n\nstruct node\n{\n\tint p;\n\tint l, r;\n} typedef node;\n\nint CreateTree(int, int, int, int);\nint Position(int, int, int[], int);\nvoid Postorder(int, int);\n\nint P[MAX];\nint I[MAX];\nnode N[MAX];\n\nint main()\n{\n\tint i;\n\tint n;\n\tint root;\n\t\n\tscanf(\"%d\", &n);\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &P[i]);\n\t}\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &I[i]);\n\t}\n\t\n\troot = CreateTree(-1, n, 0, 0);\n\t\n\tPostorder(root, n);\n\t\n\treturn 0;\n}\n\nint CreateTree(int parent, int n, int head_P, int head_I)\n{\n\tint root;\n\tint root_P, root_I;\n\tint n_l, n_r;\n\t\n\troot = P[head_P];\n\t\n\tif(n == 0) return -1;\n\n\troot_P = head_P;\n\troot_I = Position(n, head_I, I, root);\n\t\n\tn_l = root_I - head_I;\n\tn_r = n - n_l - 1;\n\t\n\tN[root].p = parent;\n\tN[root].l = CreateTree(root, n_l, root_P + 1, head_I);\n\tN[root].r = CreateTree(root, n_r, root_P + 1 + n_l, root_I + 1);\n\t\n\treturn root;\n}\n\nint Position(int n, int h, int A[], int s)\n{\n\tint i;\n\t\n\tfor(i = h; i < h + n; i++)\n\t{\n\t\tif(A[i] == s) return i;\n\t}\n\treturn -1;\n}\n\nvoid Postorder(int id, int n)\n{\n\tstatic int count = 0;\n\t\n\tif(id == -1) return;\n\t\n\tPostorder(N[id].l, n);\n\tPostorder(N[id].r, n);\n\t\n\tcount++;\n\tif(count != n) printf(\"%d \", id);\n\telse printf(\"%d\\n\", id);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define MAX 100\n\nint n, pos;\nint c = 0;\nint pre[1000], in[1000], post[1000];\n\nint find(int x)\n{\n\tfor(int i = 0; i < n; i++){\n\t\tif(x == in[i]){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid rec(int l, int r){\n\tif(l >= r){\n\t\treturn;\n\t}\n\tint root = pre[pos++];\n\tint m = find(root);\n\trec(l, m);\n\trec(m+1, r);\n\tpost[c++] = root;\n}\n\nvoid solve(){\n    pos = 0;\n   \trec(0, n);\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tif(i != n-1){\n\t\t\tprintf(\"%d \", post[i]);\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", post[i]);\n\t\t}\n\t}\n}\n\n\nint main(void){\n\tscanf(\"%d\", &n);\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &pre[i]);\n\t}\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &in[i]);\n\t}\n\t\n\tsolve();\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\n * FileName:     fix\n * CreatedDate:  2020-07-12 20:45:35 +0900\n * LastModified: 2020-07-12 21:22:36 +0900\n */\n\n#include <stdio.h>\n#include <stdlib.h>\nint c = 0;\nvoid reconstruct(int *preorder, int *inorder, int left, int right, int *pos, int *postorder){\n    if(left>=right)return;\n    int root, root_pos;\n    root = preorder[*pos];\n    *pos = *pos+1;\n    root_pos = left;\n    for(int i=left; i<right; i++){\n        if(inorder[i]==root){\n            root_pos = i;\n        }\n    }\n    reconstruct(preorder, inorder, left, root_pos, pos, postorder);\n    reconstruct(preorder, inorder, root_pos + 1, right, pos, postorder);\n    \n    postorder[c++] = root;\n\n}\nint main(void){\n    int n;scanf(\"%d\", &n);\n    int pos = 0;\n\n    int *preorder = malloc(n*sizeof(int));\n    int *inorder = malloc(n*sizeof(int));\n    int *postorder = malloc(n*sizeof(int));\n    for(int i=0; i<n; i++) scanf(\"%d\", preorder+i);\n    for(int i=0; i<n; i++) scanf(\"%d\", inorder+i);\n    reconstruct(preorder, inorder, 0, n, &pos, postorder);\n    for(int i=0; i<n; i++){\n        if(i==0){\n            printf(\"%d\", postorder[0]);\n            continue;\n        }\n        printf(\" %d\", postorder[i]);\n    }\n    printf(\"\\n\");\n    free(preorder);\n    free(inorder);\n    free(postorder);\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 100\n\nint cnt = 0;\nint post_cnt = 0;\nint n;\nint pre[MAX], in[MAX], post[MAX];\n\nint find(int u){\n    int i;\n    for(i = 0; i < n; i++){\n        if(u == in[i]){\n            return i;\n        }\n    }\n\n\n    return -1;\n}\n\nvoid reconstruct(int l, int r){\n    if (l >= r) return;\n    int root = pre[cnt++];\n    int mid = find(root);\n\n    reconstruct(l, mid);\n    reconstruct(mid + 1, r);\n    post[post_cnt++] = root;\n}\n\nint main(){\n    int i;\n    scanf(\"%d\", &n);\n\n    for(i = 0; i < n; i++) scanf(\"%d\", &pre[i]);\n    for(i = 0; i < n; i++) scanf(\"%d\", &in[i]);\n\n    reconstruct(0, n);\n    \n    for(i = 0; i < n; i++){\n        if(i) printf(\"%d\", post[i]);\n        else printf(\" %d\", post[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 40\n\nint n,pos;\nint a[M],b[M];\n\nvoid solve(int l, int r) {\n\tint x, i;\n\tx = a[pos];\n\tif (l > r) return;\n\tif (l == r) {\n\t\tif (b[l] == a[0]) printf(\"%d\", b[l]);\n\t\telse              printf(\"%d \", b[l]);\n\t\tpos++;\n\t\treturn;\n\t}\n\tpos++;\n\n\tfor (i = l; i <= r; i++)\n\t\tif (b[i] == x) break;\n\n\tsolve(l, i - 1);\n\tsolve(i + 1, r);\n\n\tif (x == a[0]) printf(\"%d\", x);\n\telse           printf(\"%d \", x);\n}\n\n\nint main(){\n\n  scanf(\"%d\", &n);\n  for(int  i=0 ; i<n ; i++)\n    scanf(\"%d\", &a[i]);\n\n  for(int  i=0 ; i<n ; i++)\n    scanf(\"%d\", &b[i]);\n  \n  pos = 0;\n  solve( 0, n-1);\n  printf(\"\\n\");\n\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 100\n\nint cnt = 0;\nint n;\nint pre[MAX], in[MAX], post[MAX];\n\nint find(int u){\n    int i;\n    for(i = 0; i < n; i++){\n        if(u == in[i]){\n            return i;\n        }\n    }\n\n\n    return -1;\n}\n\nvoid reconstruct(int l, int r){\n    if (l >= r) return;\n    int root = pre[cnt++];\n    int mid = find(root);\n\n    reconstruct(l, mid);\n    reconstruct(mid + 1, r);\n    printf(\"%d \", root);\n}\n\nint main(){\n    int i;\n    scanf(\"%d\", &n);\n\n    for(i = 0; i < n; i++) scanf(\"%d\", &pre[i]);\n    for(i = 0; i < n; i++) scanf(\"%d\", &in[i]);\n\n    reconstruct(0, n);\n    printf(\"\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint c =0;\n\nvoid func(int parr [] ,int iarr[], int len , int res[]){\n  if (len == 0 ){return;}\n  int root = parr[0];\n  if (len >= 1){\n    int i;\n    for ( i = 0; i < len; i++){\n      if (iarr[i] == root){break;}\n    }\n    int repre[i] , rein[i];\n    for ( int j = 0; j <= i; j++){\n      repre[j] = parr[ j +1];\n      rein[j] = iarr[j];\n    }\n  \n    func( repre,rein, i ,res);\n  \n    if (len - i - 1 > 0){\n      int k = len - i -1;\n      int rirepre[k] , rirein[k];\n      for ( int j = 0; j < k; j++){\n\trirepre[j ] = parr[i+ j +1];\n\trirein[j] = iarr[j +i+1];\n  \n      }\n      func( rirepre,rirein, k ,res);\n    }\n  }  \n  //printf(\"%d \" , root);\n  res[c] = root;\n  c++;\n  return;\n  \n};\n\n\n\nint main(){\n\n  int n ;\n  scanf (\"%d\\n\",&n);\n  int pre_arr[n];\n  int in_arr[n];\n  int resarr[n];\n  for (int i = 0; i < n; i++){\n    scanf(\"%d\",&pre_arr[i]);\n  }\n\n    for (int i = 0; i < n; i++){\n    scanf(\"%d\",&in_arr[i]);\n  }\n    \n    func(pre_arr , in_arr, n ,resarr);\n\n   for (int i = 0; i < n; i++){\n     printf(\"%d\",resarr[i]);\n     if (i != n-1){printf(\" \");}\n  }\n\n  printf(\"\\n\");\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 40\n\nint n,pos=0;\nint cout = 0;\nint Pre[MAX],In[MAX],Ans[MAX];\n\nint distance(int start,int key){\n  int i,count=1;\n  for(i=start;i<MAX;i++){\n    if(In[i]!=key)\n      count++;\n    else break;\n  }\n  return count;\n}\n  \n  \nint solve(int l,int r){\n  int root,d;\n  if(l-r>=0)return -1;\n  root=Pre[pos];\n  pos++;\n  d=distance(0,root);\n  if(d>n)return -1;\n  solve(l, d);\n  solve(d+1, r);\n  Ans[cout++]=root;\n  return 0;\n}\n\nint main(){\n  int m,i;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&m);\n    Pre[i]=m;\n  }\n  for(i=0;i<n;i++){\n      scanf(\"%d\",&m);\n      In[i]=m;\n  }\n  solve(0,n);\n\n  printf(\"%d\",Ans[0]);\n  for(i=1;i<n;i++)\n    printf(\" %d\",Ans[i]);\n  printf(\"\\n\");\n\t   \n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct {\n\tint parent;\n\tint left, right;\n}Node;\n\nint linear_search(int* xs, int size, int x)\n{\n\tint i;\n\tfor (i = 0; i < size; i++) {\n\t\tif (xs[i] == x) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nNode tree[50];\n\nint prewalked[50];\nint inwalked[50];\n\nint n;\n\nint reconstruction_tree(int from, int to, int root_pos, int parent)\n{\n\tint i;\n\tint v;\n\n\tfor (i = from; i < to; i++) {\n\t\tif ((v = inwalked[i]) == prewalked[root_pos]) {\n\t\t\ttree[v].parent = parent;\n\n\t\t\ttree[v].left = reconstruction_tree(from, i, root_pos + 1, v);\n\t\t\ttree[v].right = reconstruction_tree(i+1, to, root_pos +  (i - from) + 1, v);\n\n\t\t\treturn v;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint result[50];\nint resultcnt;\n\nvoid postorder_walk(int p)\n{\n\tif (p > n || p < 0) {\n\t\treturn;\n\t}\n\tpostorder_walk(tree[p].left);\n\tpostorder_walk(tree[p].right);\n\n\tresult[resultcnt++] = p;\n}\n\nint main()\n{\n\tint i;\n\tint root;\n\n\tfor (i = 0; i < 50; i++) {\n\t\ttree[i].parent = -1;\n\t}\n\n\tscanf(\"%d\", &n);\n\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &(prewalked[i]));\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &(inwalked[i]));\n\t}\n\n\troot = reconstruction_tree(0, n, 0, -1);\n\n\tpostorder_walk(root);\n\n\tfor (i = 0; i < resultcnt; i++) {\n\t\tif (i == 0) {\n\t\t\tprintf(\"%d\", result[i]);\n\t\t}\n\t\telse {\n\t\t\tprintf(\" %d\", result[i]);\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 100\n\n\n int n,pos,count=0;\n int pre[N],in[N],post[N];\n \n int find(int in[n],int root){\n     int i;\n     for(i=0;i<n;i++){\n            if(in[i]==root)return i;\n            }\n     return in[n-1];\n     }\n\n void rec(int l,int r){\n      int root,m;\n      if(l>=r)return;\n      root=pre[pos++];\n      m=find(in,root);\n      rec(l,m);\n      rec(m+l,r);\n      post[count++]=root;\n      }\n\n void solve(){\n      int i;\n      pos=0;\n      rec(0,n);\n      for(i=0;i<n;i++){\n              if(i)printf(\" \");\n              printf(\"%d\",post[i]);\n              }\n      printf(\"\\n\");\n      }\n\n int main(){\n      int i,k;\n      scanf(\"%d\",&n);\n\n      for(i=0;i<n;i++){\n              scanf(\"%d\",&k);\n              pre[i]=k;\n              }\n      for(i=0;i<n;i++){\n              scanf(\"%d\",&k);\n              in[i]=k;\n              }\n      solve();\n      return 0;\n      }\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nvoid Repair(int ,int );\nint Preorder[100],Inorder[100],Postorder[100],postnode=0,nownode=0,n;\nint main(void){\n  int i;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)\n    scanf(\"%d\",&Preorder[i]);\n  for(i=0;i<n;i++)\n    scanf(\"%d\",&Inorder[i]);\n\n  Repair(0,n);\n\n  for(i=0;i<n;i++){\n    printf(\"%d\",Postorder[i]);\n    if(i!=n-1)printf(\" \");\n  }\n  printf(\"\\n\");\n  return 0;\n}\nvoid Repair(int left,int right){\n  int rootnode,distance;\n  if(left<right){\n    rootnode=Preorder[nownode++];\n    distance=0;\n    while(distance<n){\n      if(Inorder[distance++]==rootnode)\n        break;\n    }\n    Repair(left,distance-1);\n    Repair(distance,right);\n    Postorder[postnode++]=rootnode;\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 40\n   \nint n,res,A[N],B[N];\n\nvoid solve(int l,int r){\n   \n  int p,i;\n \n  p=A[res];\n   \n  if(l>r)return;\n  if(l==r){\n    if(B[l]==A[0]) printf(\"%d\",B[l]);\n    else printf(\"%d \",B[l]);\n    res++;\n    return;\n  }\n   \n  res++;\n  for(i=l;i<=r;i++){\n    if(B[i]==p)break;\n  }\n  solve(l,i-1);\n  solve(i+1,r);\n     \n  if(p==A[0])printf(\"%d\",p);\n  else printf(\"%d \",p);\n}\n \nint main(){\n   \n  int i;\n \n  scanf(\"%d\",&n);\n \n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n  }\n \n  for(i=0;i<n;i++){\n    scanf(\"%d\",&B[i]);\n  }\n   \n  solve(0,n-1);\n  printf(\"\\n\");\n \n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "int preorder[40],inorder[40];\nvoid recover(int fp,int lp,int fi,int li){\n    int root=fi;\n    for(;root<li;root++)if(preorder[fp]==inorder[root])break;\n    if(fi<root)recover(fp+1,fp+(root-fi)+1,fi,root);\n    if(root<li-1)recover(fp+(root-fi)+1,lp,root+1,li);\n    printf(inorder[root]==preorder[0]?\"%d\\n\":\"%d \",inorder[root]);\n}\nmain(){\n    int n,i;\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)scanf(\"%d\",preorder+i);\n    for(i=0;i<n;i++)scanf(\"%d\",inorder+i);\n    recover(0,n,0,n);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define POINT 41\n\nint P[POINT], I[POINT], Po[POINT];\nint n, now = 0, s = 0;\n\nvoid Rec(int, int);\n\nvoid Rec(int l, int r) {\n    int c,m;\n    \n    if(l >= r) {\n        return;\n    }\n    c = P[now++];\n    m = Find(c);\n    Rec(l, m);\n    Rec(m + 1, r);\n    Po[s++] = c;\n}\n\nint Find(int c) {\n    int i;\n    \n    //接点番号が一致したIndexを返す\n    for(i = 0 ; i < n ; i++) {\n        if(c == I[i]) {\n            return i;\n        }\n    }\n    return 0;\n}\n\nint main(void){\n    int i;\n    \n    scanf(\"%d\",&n);\n    \n    //preoder include\n    for(i = 0 ; i < n ; i++) {\n        scanf(\"%d\",&P[i]);\n    }\n    \n    //inoder include\n    for(i = 0 ; i < n ; i++) {\n        scanf(\"%d\",&I[i]);\n    }\n    \n    Rec(0,n);\n    \n    for(i = 0 ; i < n-1 ; i++) {\n        printf(\"%d\",Po[i]);\n    }\n    printf(\"%d\\n\", Po[n-1]);\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 41\n\ntypedef struct node{\n  int l, r;\n}node;\n\nnode c[N];\nint a[N], b[N];\nint cnt=0;\n\nvoid postorder(int root,int n){\n\n        if(c[root].l != -1) postorder(c[root].l, n);\n        if(c[root].r != -1) postorder(c[root].r, n);\n        if(cnt < n - 1) printf(\"%d \", root);\n        else printf(\"%d\\n\", root);\n\n        cnt++;\n\n        return;\n\n}\n\nint reconst(int start,int last,int n){\n  int i, j;\n\n  if(start == last) return b[start];\n  else if(start > last) return -1;\n\n  else {\n    for(i = 1 ; i <= n ; i++){\n      for(j = start ; j <= last ; j++){\n        if(a[i] == b[j]){\n          c[a[i]].l = reconst(start, j - 1, n);\n          c[a[i]].r = reconst(j + 1, last, n);\n          return a[i];\n        }\n      }\n    }\n  }\n}\n\n\nint main(){\n  int n,i, root;\n\n  scanf(\"%d\",&n);\n\n  for(i = 1 ; i <= n ; i++) scanf(\"%d\",&a[i]);\n  for(i = 1 ; i <= n ; i++) scanf(\"%d\",&b[i]);\n  for(i = 1 ; i <= n ; i++){\n    c[i].l = -1;\n    c[i].r = -1;\n  }\n\n  root = reconst(1,n,n);\n\n  postorder(root,n);\n\n  return 0;\n\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\nint nn = 0 , pos;\n\nint find( int a[] , int n , int s ){\n\t\n\tint i;\n\tfor( i = 0; i < n; i++ ){\n\t\tif( a[i] == s ){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid rec( int l , int r , int n , int pre[] , int in[] , int post[] ){\n\t\n\tif( l >= r ){\n\t\treturn;\n\t}\n\tint root = pre[pos++];\n\tint m = find( in , n , root );\n\trec( l , m , n , pre , in , post );\n\trec( m+1 , r , n , pre , in , post );\n\tpost[nn++] = root;\n}\n\nvoid solve( int n , int pre[] , int in[] , int post[] ){\n\t\n\tpos = 0;\n\trec( 0 ,n , n , pre , in , post );\n\tprintf( \"%d\" , post[0] );\n\t\n\tfor( int i = 1; i < n; i++ ){\n\t\tprintf( \" %d\" , post[i] );\n\t}\n\tprintf( \"\\n\" );\n} \n\nint main( void ){\n\t\n\tint n;\n\t\n\tscanf( \"%d\" , &n );\n\t\n\tint *pre,*in,*post;\n\tpre = ( int* )malloc( sizeof(int)*n );\n\tin = ( int* )malloc( sizeof(int)*n );\n\tpost = ( int* )malloc( sizeof(int)*n );\n\t\n\tfor( int i = 0; i < n; i++ ){\n \t\tscanf( \"%d\" , &pre[i] );\n\t}\n\tfor( int i = 0; i < n; i++ ){\n\t\tscanf( \"%d\" , &in[i] );\n\t}\n\t\n\tsolve( n , pre , in , post );\n\t\n\treturn 0;\n}\n\t\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 40\n\nint pre[N],in[N],po[N];\nint n,mark=0;\nint j = 0;\n\nvoid rec(int l, int r) {\n\tint i;\n\tint c,m;\n\n\tif (l >= r) return;\n\tc = pre[mark++];\n\tfor (i = 0; i < n;i++) {\n\t\tif (in[i] == c) {\n\t\t\tm = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trec(l, m);\n\trec(m+1, r);\n\tpo[j++] = c;\n}\n\nint main() {\n\tint i;\n\n\tscanf(\"%d\",&n);\n\tfor (i = 0;i < n;i++) scanf(\"%d\",&pre[i]);\n\tfor (i = 0;i < n;i++) scanf(\"%d\",&in[i]);\n\n\trec(0,n);\n\tfor (i = 0;i < n;i++) {\n\t\tif (i) printf(\" \");\n\t\tprintf(\"%d\",po[i]);\n\t}\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint n,pos;\nint a[40],b[40];\n\nvoid solve(int k,int r){\n  if(k>r){\n      return;\n  }\n  if(k==r){\n    if(b[k]==a[0])printf(\"%d\",b[k]);\n    else printf(\"%d \",b[k]);\n    pos++;\n    return;\n  }\n\n  int x=a[pos],i;\n  pos++;\n  for(i=k;i<=r;i++){\n    if(b[i]==x)break;\n  }\n  solve(k,i-1);\n  solve(i+1,r);\n  \n  if(x==a[0])printf(\"%d\",x);\n  else printf(\"%d \",x);\n}\n\nint main(){\n  int i;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n      scanf(\"%d\",&a[i]);\n  }\n  for(i=0;i<n;i++){\n      scanf(\"%d\",&b[i]);\n  }\n  pos=0;\n  solve(0,n-1);\n  printf(\"\\n\");\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 100\n\nint cnt = 0;\nint post_cnt = 0;\nint n;\nint pre[MAX], in[MAX], post[MAX];\n\nint find(int u){\n    int i;\n    for(i = 0; i < n; i++){\n        if(u == in[i]){\n            return i;\n        }\n    }\n\n\n    return -1;\n}\n\nvoid reconstruct(int l, int r){\n    if (l >= r) return;\n    int root = pre[cnt++];\n    int mid = find(root);\n\n    reconstruct(l, mid);\n    reconstruct(mid + 1, r);\n    post[post_cnt++] = root;\n}\n\nint main(){\n    int i;\n    scanf(\"%d\", &n);\n\n    for(i = 0; i < n; i++) scanf(\"%d\", &pre[i]);\n    for(i = 0; i < n; i++) scanf(\"%d\", &in[i]);\n\n    reconstruct(0, n);\n    \n    for(i = 0; i < n; i++){\n       \n        printf(\" %d\", post[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 40\n\nint pre[N],in[N];\nint n,mark=0;\n\nvoid rec(int l, int r) {\n\tint i;\n\tint c,m;\n\n\tif (l >= r) return;\n\tc = pre[mark++];\n\tfor (i = 0; i < n;i++) {\n\t\tif (in[i] == c) {\n\t\t\tm = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trec(l, m);\n\trec(m+1, r);\n\n\tprintf(\"%d\",c);\n\tif (mark < n) printf(\" \");\n}\n\nint main() {\n\tint i;\n\n\tscanf(\"%d\",&n);\n\tfor (i = 0;i < n;i++) scanf(\"%d\",&pre[i]);\n\tfor (i = 0;i < n;i++) scanf(\"%d\",&in[i]);\n\n\trec(0,n);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 40\n\nint pre[N],in[N];\nint n,mark=0;\n\nvoid rec(int l, int r) {\n\tint i;\n\tint c,m;\n\n\tif (l >= r) return;\n\tc = pre[mark++];\n\tfor (i = 0; i < n;i++) {\n\t\tif (in[i] == c) {\n\t\t\tm = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trec(l, m);\n\trec(m+1, r);\n\n\tprintf(\" %d\",c);\n}\n\nint main() {\n\tint i;\n\n\tscanf(\"%d\",&n);\n\tfor (i = 0;i < n;i++) scanf(\"%d\",&pre[i]);\n\tfor (i = 0;i < n;i++) scanf(\"%d\",&in[i]);\n\n\trec(0,n);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n  \nint preOrder[40],inOrder[40];\n \nvoid solve(int ,int );\n  \nint main(){\n\n  int i,n;\n  \n  scanf(\"%d\",&n);\n\n  for(i = 0;i < n;i ++)\n    {\n      scanf(\"%d\",&preOrder[i]);\n    }\n  \n  for(i = 0;i < n;i ++)\n    {\n      scanf(\"%d\",&inOrder[i]);\n    }\n\n  solve(0,n-1);\n\n  printf(\"\\n\");\n\n  return 0;\n}\n\n\nvoid solve(int l,int r){\n\n  int i;\n  static int p=0;\n\n  if(l>r)return;\n\n  if(l == r){\n    \n    if(inOrder[l] == preOrder[0])\n      {\n\tprintf(\"%d\",inOrder[l]);\n      }else{\n      printf(\"%d \",inOrder[l]);\n    } \n\n    p++;\n    \n    return;\n  }\n\n  int x = preOrder[p];\n\n  p ++;\n\n  for(i = l;i <= r;i ++)\n    {\n      if(inOrder[i]==x) break;\n    }\n  \n  solve(l,i-1);\n  solve(i+1,r);\n    \n  if(x == preOrder[0])printf(\"%d\",x);\n\n  else printf(\"%d \",x);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct {\n\tint parent;\n\tint left, right;\n}Node;\n\nint linear_search(int* xs, int size, int x)\n{\n\tint i;\n\tfor (i = 0; i < size; i++) {\n\t\tif (xs[i] == x) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nNode tree[50];\n\nint prewalked[50];\nint inwalked[50];\n\nint n;\n\nint reconstruction_tree(int from, int to, int root_pos, int parent)\n{\n\tint i;\n\tint v;\n\n\tfor (i = from; i < to; i++) {\n\t\tif ((v = inwalked[i]) == prewalked[root_pos]) {\n\t\t\ttree[v].parent = parent;\n\n\t\t\ttree[v].left = reconstruction_tree(from, i, root_pos + 1, v);\n\t\t\ttree[v].right = reconstruction_tree(i+1, to, root_pos +  (i - from) + 1, v);\n\n\t\t\treturn v;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nvoid postorder_walk(int p, int root)\n{\n\tif (p > n || p < 0) {\n\t\treturn;\n\t}\n\tpostorder_walk(tree[p].left, 0);\n\tpostorder_walk(tree[p].right, 0);\n\tif (root == 1) {\n\t\tprintf(\"%d\", p);\n\t}\n\telse {\n\t\tprintf(\" %d\", p);\n\t}\n}\n\nint main()\n{\n\tint i;\n\tint root;\n\n\tfor (i = 0; i < 50; i++) {\n\t\ttree[i].parent = -1;\n\t}\n\n\tscanf(\"%d\", &n);\n\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &(prewalked[i]));\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &(inwalked[i]));\n\t}\n\n\troot = reconstruction_tree(0, n, 0, -1);\n\n\tpostorder_walk(root, 1);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct {\n\tint parent;\n\tint left, right;\n}Node;\n\nint linear_search(int* xs, int size, int x)\n{\n\tint i;\n\tfor (i = 0; i < size; i++) {\n\t\tif (xs[i] == x) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nNode tree[50];\n\nint prewalked[50];\nint inwalked[50];\n\nint n;\n\nint reconstruction_tree(int from, int to, int root_pos, int parent)\n{\n\tint i;\n\tint v;\n\n\tfor (i = from; i < to; i++) {\n\t\tif ((v = inwalked[i]) == prewalked[root_pos]) {\n\t\t\ttree[v].parent = parent;\n\n\t\t\ttree[v].left = reconstruction_tree(from, i, root_pos + 1, v);\n\t\t\ttree[v].right = reconstruction_tree(i+1, to, root_pos +  (i - from) + 1, v);\n\n\t\t\treturn v;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nvoid postorder_walk(int p, int root)\n{\n\tif (p > n || p < 0) {\n\t\treturn;\n\t}\n\tpostorder_walk(tree[p].left, 0);\n\tpostorder_walk(tree[p].right, 0);\n\tif (root = 1) {\n\t\tprintf(\"%d\", p);\n\t}\n\telse {\n\t\tprintf(\" %d\", p);\n\t}\n}\n\nint main()\n{\n\tint i;\n\tint root;\n\n\tfor (i = 0; i < 50; i++) {\n\t\ttree[i].parent = -1;\n\t}\n\n\tscanf(\"%d\", &n);\n\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &(prewalked[i]));\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &(inwalked[i]));\n\t}\n\n\troot = reconstruction_tree(0, n, 0, -1);\n\n\tpostorder_walk(root);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 100\n\n\n int n,pos,count=0;\n int pre[N],in[N],post[N];\n \n int find(int in[n],int root){\n     int i;\n     for(i=0;i<n;i++){\n            if(in[i]==root)return i;\n            }\n     return in[n-1];\n     }\n\n void rec(int l,int r){\n      int root,m;\n      if(l>=r)return;\n      root=pre[pos++];\n      m=find(in,root);\n      rec(l,m);\n      rec(m+l,r);\n      post[count++]=root;\n      }\n\n void solve(){\n      int i;\n      pos=0;\n      rec(0,n);\n      for(i=0;i<n;i++){\n              if(i)printf(\" \");\n              printf(\"%d\",post[i]);\n              }\n      printf(\"\\n\");\n      }\n\n int main(){\n      int i,k;\n      scanf(\"%d\",&n);\n\n      for(i=0;i<n;i++){\n              scanf(\"%d\",&k);\n              pre[i]=k;\n              }\n      for(i=0;i<n;i++){\n              scanf(\"%d\",&k);\n              in[i]=k;\n              }\n      solve();\n      return 0;\n      }\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 100\n\nint cnt = 0;\nint post_cnt = 0;\nint n;\nint pre[MAX], in[MAX], post[MAX];\n\nint find(int u){\n    int i;\n    for(i = 0; i < n; i++){\n        if(u == in[i]){\n            return i;\n        }\n    }\n\n\n    return -1;\n}\n\nvoid reconstruct(int l, int r){\n    if (l >= r) return;\n    int root = pre[cnt++];\n    int mid = find(root);\n\n    reconstruct(l, mid);\n    reconstruct(mid + 1, r);\n    post[post_cnt++] = root;\n}\n\nint main(){\n    int i;\n    scanf(\"%d\", &n);\n\n    for(i = 0; i < n; i++) scanf(\"%d\", &pre[i]);\n    for(i = 0; i < n; i++) scanf(\"%d\", &in[i]);\n\n    reconstruct(0, n);\n    \n    for(i = 0; i < n; i++){\n        if(i != n) printf(\"%d \", post[i]);\n        else printf(\"%d\", post[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 40\n  \nint n,pos;\nint a[N],b[N];\n\nvoid solve(int, int);\n\nint main(){\n  \n  int i;\n\n  scanf(\"%d\",&n);\n\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&a[i]);\n  }\n\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&b[i]);\n  }\n  \n  pos=0;\n\n  solve(0,n-1);\n\n  printf(\"\\n\");\n\n  return 0;\n}\n  \nvoid solve(int l,int r){\n  \n  int x,i;\n\n  x=a[pos];\n  \n  if(l>r)return;\n  if(l==r){\n    if(b[l]==a[0]) printf(\"%d\",b[l]);\n    else printf(\"%d \",b[l]);\n    pos++;\n    return;\n  }\n  \n  pos++;\n  for(i=l;i<=r;i++){\n    if(b[i]==x)break;\n  }\n  solve(l,i-1);\n  solve(i+1,r);\n    \n  if(x==a[0])printf(\"%d\",x);\n  else printf(\"%d \",x);\n}\n  "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint n,pos;\nint a[40],b[40];\n\nvoid solve(int l,int r){\n  if(l>r)return;\n  if(l==r){\n    if(b[l]==a[0])printf(\"%d\",b[l]);\n    else printf(\"%d \",b[l]);\n    pos++;\n    return;\n  }\n\n  int x=a[pos],i;\n  pos++;\n  for(i=l;i<=r;i++){\n    if(b[i]==x)break;\n  }\n  solve(l,i-1);\n  solve(i+1,r);\n  \n  if(x==a[0])printf(\"%d\",x);\n  else printf(\"%d \",x);\n}\n\nint main(){\n  int i;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)scanf(\"%d\",&a[i]);\n  for(i=0;i<n;i++)scanf(\"%d\",&b[i]);\n  pos=0;\n  solve(0,n-1);\n  printf(\"\\n\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 40\nint n,ptw;\nint a[N];\nint b[N];\n \nvoid solve(int,int);                \\\n \nint main(){\n   \n  int i;\n  scanf(\"%d\",&n);\n  for(i = 0;i < n;i++)  scanf(\"%d\",&a[i]);\n  for(i = 0;i < n;i++)  scanf(\"%d\",&b[i]);\n  ptw = 0;\n  solve(0,n-1);\n  printf(\"\\n\");\n  return 0;\n}\n \n \n \nvoid solve(int l,int r){\n  \n  int x = a[ptw],i;\n      \n  if(l > r)return;\n \n  if(l == r){\n    if(b[l] == a[0])printf(\"%d\",b[l]); \n    else printf(\"%d \",b[l]);\n    ptw++;\n    return;\n  } \n  ptw++;\n \n  for(i = l;i <= r;i++) if(b[i] == x)break; \n   \n  solve(l,i-1);\n  solve(i+1,r);\n    \n  if(x == a[0])   printf(\"%d\",x);\n \n  else printf(\"%d \",x);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 100\n\nint n, pos, count = 0;\nint pre[N], in[N], post[N];\n\nint find(int in[n], int root){\n  int i;\n  for(i = 0; i < n; i++){\n    if(in[i] ==  root) return i;\n  }\n  return in[n - 1];\n}\n\nvoid rec(int l, int r){\n  int root, m;\n  if(l >= r) return;\n  root = pre[pos++];\n  m = find(in, root);\n  rec(l, m);\n  rec(m + 1, r);\n  post[count++] = root;\n}\n\nvoid solve(){\n  int i;\n  pos = 0;\n  rec(0, n);\n  for(i = 0; i < n; i++){\n    if(i) printf(\" \");\n    printf(\"%d\", post[i]);\n  }\n  printf(\"\\n\");\n}\n\nint main(){\n  int i, k;\n  scanf(\"%d\", &n);\n\n  for(i = 0; i < n; i++){\n    scanf(\"%d\", &k);\n    pre[i] = k;\n  }\n\n  for(i = 0; i < n; i++){\n    scanf(\"%d\", &k);\n    in[i] = k;\n  }\n\n  solve();\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#define rad M_PI/3\n#define N 200001\n#define Max 10000\n#define NTL -1\n\nint m,n,point=0;\nint Pre[41],In[41],af[41];\nint seach(int p){\n    for(int i=0;i<n;i++){\n        if(p==In[i]) return i;\n    }\n    return 0;\n}\nvoid visit(int l,int r){\n    int p,q;\n    if(l>=r) return;\n    p=Pre[point++];\n    q=seach(p);\n    visit(l,q);\n    visit(q+1,r);\n    af[m++]=p;\n}\nint main()\n{\n    int i;\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&Pre[i]);\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&In[i]);\n    }\n    visit(0,n);\n    for(i=0;i<n-1;i++){\n        printf(\"%d \",af[i]);\n    }\n    printf(\"%d\\n\",af[i]);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint n;\nint a[50],b[50];\nint c=0;\nvoid p(int i){printf(c++?\" %d\":\"%d\",b[i]);}\n\nvoid f(int l,int r){\n\tif(l==r)return;\n\tif(l+1==r){\n\t\tp(l);\n\t\treturn;\n\t}\n\t//bの[l,r)に存在するもののうち、aの中で最も前にあるものを探す\n\tint idx=-1;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=l;j<r;j++)if(b[j]==a[i])idx=j;\n\t\tif(idx!=-1)break;\n\t}\n\tf(l,idx);\n\tf(idx+1,r);\n\tp(idx);\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)scanf(\"%d\",a+i);\n\tfor(int i=0;i<n;i++)scanf(\"%d\",b+i);\n\tf(0,n);\n\tputs(\"\");\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define OUTPUT__LENGTH (128)\nchar _out[OUTPUT__LENGTH];\nchar *_o = _out;\nvoid write_uint(int n) {\n    if(!n) {\n        *_o++ = '0';\n        return;\n    }\n    char buf[11];\n    int i = 0;\n    while(n) buf[i++] = (n % 10 + '0'), n /= 10;\n    while(i--) *_o++ = buf[i];\n}\nint get_uint() {\n    int n = 0;\n    int c = getchar_unlocked();\n    if(c < 48 || 57 < c) return c;\n    while(47 < c && c < 58) {\n        n = 10 * n + (c & 0xf);\n        c = getchar_unlocked();\n    }\n    return n;\n}\nint *find(int *first, int *last, const int value) {\n    for(;first!=last;++first)\n        if(*first == value) return first;\n    return last;\n}\n\ntypedef struct Node {\n    int parent, left, right, depth, height, sibling;\n} Node;\ntypedef struct BinaryTree {\n    Node nodes[40];\n    int root;\n} BinaryTree;\nvoid bt_init(BinaryTree *BT) {\n    for(int i = 0; i < 40; ++i) BT->nodes[i].parent = -1;\n}\nvoid bt_make(BinaryTree *BT) {\n    for(int i = 0; i < 40; ++i) {\n        if(BT->nodes[i].parent == -1) {\n            BT->root = i;\n            break;\n        }\n    }\n}\nvoid bt_add_node(BinaryTree *BT, int id, int l, int r) {\n    BT->nodes[id].left = l;\n    BT->nodes[id].right = r;\n    if(~l) BT->nodes[l].parent = id;\n    if(~r) BT->nodes[r].parent = id;\n}\nint bt_pre_in(BinaryTree *BT, int *pre, int *in, int l, int r) {\n    static int pos = 0;\n    if(l >= r) return -1;\n    int root = pre[pos++];\n    int mid = (int)(find(in, in+r, root) - in);\n    int ln = bt_pre_in(BT, pre, in, l, mid);\n    int rn = bt_pre_in(BT, pre, in, mid+1, r);\n    bt_add_node(BT, root, ln, rn);\n    return root;\n}\nvoid bt_pr_postorder(BinaryTree *BT, int id) {\n    if(id == -1) return;\n    bt_pr_postorder(BT, BT->nodes[id].left);\n    bt_pr_postorder(BT, BT->nodes[id].right);\n    *_o++ = ' ';\n    write_uint(id+1);\n}\nint main(int argc, char **argv) {\n    int n = get_uint();\n    int pre[n], in[n];\n    for(int i = 0; i < n; ++i) pre[i] = get_uint()-1;\n    for(int i = 0; i < n; ++i) in[i] = get_uint()-1;\n    BinaryTree BT;\n    bt_init(&BT);\n    bt_pre_in(&BT, pre, in, 0, n);\n    bt_make(&BT);\n    bt_pr_postorder(&BT, BT.root);\n    for(char *p = _out+1; p!=_o;++p) putchar_unlocked(*p);\n    putchar_unlocked('\\n');\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n  \nint preOrder[40],inOrder[40];\n \nvoid solve(int x,int y){\n  int i;\n  static int p=0;\n  if(x>y) return;\n  if(x==y){\n    if(inOrder[x]==preOrder[0]) printf(\"%d\",inOrder[x]);  \n    else printf(\"%d \",inOrder[x]);\n    p++;\n    return;\n  }\n  int a=preOrder[p];\n  p++;\n  for(i=x;i<=y;i++){\n    if(inOrder[i]==x) break;\n  }\n  solve(x,i-1);\n  solve(i+1,y);\n  if(a==preOrder[0]) printf(\"%d\",x);\n  else printf(\"%d \",x);\n}\n  \nint main(){\n  int i,n;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++) scanf(\"%d\",&preOrder[i]);\n  for(i=0;i<n;i++) scanf(\"%d\",&inOrder[i]);\n  solve(0,n-1);\n  printf(\"\\n\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "\n\nint preorder[40],inorder[40];\nvoid recover(int fp,int lp,int fi,int li){\n    int root=fi;\n    for(;root<li;root++)if(preorder[fp]==inorder[root])break;\n    if(fi<root)recover(fp+1,fp+(root-fi)+1,fi,root);\n    if(root<li-1)recover(fp+(root-fi)+1,lp,root+1,li);\n    printf(inorder[root]==preorder[0]?\"%d\\n\":\"%d \",inorder[root]);\n}\nmain(){\n    int n,i;\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)scanf(\"%d\",preorder+i);\n    for(i=0;i<n;i++)scanf(\"%d\",inorder+i);\n    recover(0,n,0,n);\n    return 0;\n}\n \n\n \nCompile Error Logs: \n\nYou are not authorized to see the message. \n \n \nStatus \nJudge: 20/20  C  CPU: 00.00 sec  Memory: 1828 KB  Length: 495 B  2017-12-01 14:59  2017-12-01 14:59  \nResults for testcases \nCase # Verdict CPU Time Memory In Out Case Name \n Case #1: : Accepted  00.00 sec 1664 KB    \n  "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 40\n\nint n,pos=0;\nint cout = 0;\nint Pre[MAX] ,In[MAX] ,final[MAX];\n\nint distance(int first,int key){\n  int i,count=0;\n\n  for(i = first; i < MAX;i++){\n    if(In[i] != key)\n      count++;\n    else break;\n  }\n\n  return count;\n}\n\n\nint solve(int l,int r){\n\n  int root,d;\n  if(l-r >= 0)return -1;\n\n  root=Pre[pos];\n  pos++;\n\n  d=distance(0,root);\n  if(d > n)return -1;\n\n  solve(l, d);\n  solve(d+1,r);\n\n  final[cout++]=root;\n  return 0;\n}\n\nint main(){\n  int m,i;\n  scanf(\"%d\",&n);\n\n  for(i = 0;i < n;i++){\n    scanf(\"%d\",&m);\n    Pre[i]=m;\n  }\n\n  for(i = 0;i < n;i++){\n      scanf(\"%d\",&m);\n      In[i]=m;\n  }\n  solve(0,n);\n\n  printf(\"%d\",final[0]);\n\n  for(i = 1;i < n;i++)\n    printf(\" %d\",final[i]);\n  printf(\"\\n\");\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\n#define MAX 11\n#define NIL -1\n\n/*\np: parent\nl: left-child\nr: right sibling\nk: vertex\n*/\nstruct Node{ int p, l, r, v; };\nstruct Node T[MAX]; // Tree\n\nmain(){\n\tint i, d, v, c, n, l;\n\tint PRE[MAX] = { NIL };\n\tint IN[MAX] = { NIL };\n\n\tscanf(\"%d\", &n);\n\n\tfor (i = 0; i <= n; i++) {\n\t\tT[i].p = T[i].l = T[i].r = NIL;\n\t}\n\n\tfor (i = 0; i <= n; i++){\n\t\tscanf(\"%d\",&v);\n\t\tT[i].l = i + 1;\n\t\tif (i == 0){ \n\t\t\tT[i].v = v;\n\t\t}\n\t\telse{\n\t\t\tT[i].v = v;\n\t\t\tT[i].p = i-1;\n\t\t}\n\t\tl = v;\n\t}\n\n\t//for (i = 1; i <= n; i++) print(i);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX 40\n\nvoid solve(int*,int*,int);\n\nint n, post[MAX], idx;\n\nint main(){\n  int pre[MAX], in[MAX], i;\n\n  scanf(\"%d\",&n);\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\",pre+i);\n  }\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\",in+i); \n  }\n\n  solve(pre, in, n);\n\n  for(i = 0 ; i < n ; i++){\n    printf(\"%d%c\",post[i],(i != n-1 ? ' ':'\\n'));\n  }\n\n  return 0;\n}\n\nvoid solve(int pre[], int in[], int N){\n  int i, par;\n\n  for(i = 0 ; i < N ; i++){\n    if(in[i] == pre[0]){\n      par = i;\n      break;\n    }\n  }\n\n  if(par != 0){\n    solve(pre+1, in, par);\n  }\n  if(par != N-1){\n    solve(pre+par+1, in+par+1, N-par-1);\n  }\n  post[idx++] = pre[0]; \n}"
  },
  {
    "language": "C",
    "code": "/* ALDS1_7_D:Reconstruction of a Tree */\n/* 20181125 AOJ */\n\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdlib.h>\n#define N 100\n#define NIL -1\n\ntypedef struct {\n\tint parent;\n\tint left;\n\tint right;\n} Tree;\n\nint preOrder[N];\nint inOrder[N];\nint postOrder[N];\nvoid TreeReconstruction(Tree *node, int left, int right);\n\nint pos1, order[N], pos2; \n\nint main(void) {\n\tTree *node = (Tree *)malloc(sizeof(Tree) * N);\n\tint i, n;\n\n\tscanf(\"%d\", &n);\n\tfor(i = 0; i < n; i++) scanf(\"%d\", preOrder + i);\n\tfor(i = 0; i < n; i++) scanf(\"%d\", inOrder + i);\n\t\n\tfor(i = 0; i < n; i++) order[inOrder[i]] = i;\n\tpos1 = 0;\n\tpos2 = 0;\n\tTreeReconstruction(node, 0, n);\n\n\tfor(i = 0; i < n; i++) {\n\t\tif(i) printf(\" \");\n\t\tprintf(\"%d\", postOrder[i]);\n\t}\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n\nvoid TreeReconstruction(Tree *node, int left, int right) {\n\tint root, temp;\n\n\tif(left >= right) return;\n\troot = preOrder[pos1++];\n\ttemp = order[root];\n\tTreeReconstruction(node, left, temp);\n\tTreeReconstruction(node, temp + 1, right);\n\tpostOrder[pos2++] = root;\n\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define MAX 100\n\nint n,c,d=0;\nint pre[1000],in[1000],post[1000];\n\nint find(int x){\n\tint i;\n\tfor(i=0; i<=n-1; i++){\n\t\tif(x == in[i]){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid rec(int l,int r){\n\tint a,b;\n\tif(l >= r) return;\n\ta = pre[d++];\n\tb = find(a);\n\trec(l,b);\n\trec(b+1,r);\n\tpost[c++] = a;\n}\n\nint main(void){\n\tint i;\n\tscanf(\"%d\",&n);\n\t\n\tfor(i = 0; i <= n-1; i++){\n\t\tscanf(\"%d\",&pre[i]);\n\t}\n\t\n\tfor(i = 0; i < n; i++){\n\t\tscanf(\"%d\",&in[i]);\n\t}\n\t\n\trec(0,n);\n\t\n\tfor(i = 0; i < n; i++){\n\t\tif(i != n-1){\n\t\t\tprintf(\"%d \",post[i]);\n\t\t}else {\n\t\t\tprintf(\"%d\\n\",post[i]);\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 40\n\nint pre[N],in[N];\nint n,mark=0;\n\nvoid rec(int l, int r) {\n\tint i;\n\tint c,m;\n\n\tif (l >= r) return;\n\tc = pre[mark++];\n\tfor (i = 0; i < n;i++) {\n\t\tif (in[i] == c) {\n\t\t\tm = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trec(l, m);\n\trec(m+1, r);\n\n\tprintf(\"%d\",c);\n\tif (mark <= n) printf(\" \");\n}\n\nint main() {\n\tint i;\n\n\tscanf(\"%d\",&n);\n\tfor (i = 0;i < n;i++) scanf(\"%d\",&pre[i]);\n\tfor (i = 0;i < n;i++) scanf(\"%d\",&in[i]);\n\n\trec(0,n);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define CHECK printf(\"check\\n\");\ntypedef struct node\n{\n  int id;\n  struct node *parent;\n  struct node *sibling;\n  struct node *child[2];\n  int degree;\n  int depth;\n  int height;\n  char *type;\n} *nodePointer;\nvoid init(nodePointer*,int);\nnodePointer make1node(void);\nvoid relationSet(nodePointer*,int,int*);\nvoid calcStatus(nodePointer*,int);\nint getDegree(nodePointer*,int);\nint getDepth(nodePointer*,int);\nint getHeight(nodePointer*,int);\nchar *getType(nodePointer*,int);\nvoid printNodeArray(nodePointer*,int);\nnodePointer getRoot(nodePointer*);\nvoid postorderWalk(nodePointer,nodePointer);\nvoid printWalk(int);\nvoid reconstructTree(nodePointer*,int*,int*,int);\nint main(void)\n{\n  int i;//counter\n  int n;//the number of nodes\n  int id;//node ID\n  int childID[2];//node ID of child\n  nodePointer *arr;//array of nodePointer\n  nodePointer root;//used for postorderWalk\n  int *pre;//preorderWalk\n  int *in;//inorderWalk\n  scanf(\"%d\",&n);\n  arr=(nodePointer*)malloc(sizeof(nodePointer)*n);\n  init(arr,n);\n  pre=(int*)malloc(sizeof(int)*n);\n  in=(int*)malloc(sizeof(int)*n);\n  for(i=0;i<n;i++) scanf(\"%d\",&pre[i]);\n  for(i=0;i<n;i++) scanf(\"%d\",&in[i]);\n  reconstructTree(arr,pre,in,n);\n  root=getRoot(arr);\n  postorderWalk(root,root);\n  return 0;\n}\nvoid init(nodePointer *arr,int n)\n{\n  int i;//counter\n  for(i=0;i<n;i++)\n    {\n      arr[i]=make1node();\n      arr[i]->id=i;\n      arr[i]->parent=NULL;\n      arr[i]->sibling=NULL;\n      arr[i]->child[0]=NULL;\n      arr[i]->child[1]=NULL;\n      arr[i]->degree=-1;\n      arr[i]->depth=-1;\n      arr[i]->height=-1;\n      arr[i]->type=\"\";\n    }\n}\nnodePointer make1node(void)\n{\n  nodePointer p=(nodePointer)malloc(sizeof(struct node));\n  return p;\n}\nvoid relationSet(nodePointer *arr,int id,int *childID)\n{\n  int i;//counter\n  for(i=0;i<2;i++)\n    {\n      if(childID[i]==-1) arr[id]->child[i]=NULL;\n      else\n\t{\n\t  arr[id]->child[i]=arr[childID[i]];\n\t  arr[childID[i]]->parent=arr[id];\n\t}\n    }\n  if(arr[id]->child[0]!=NULL&&arr[id]->child[1]!=NULL)\n    {\n      arr[childID[0]]->sibling=arr[childID[1]];\n      arr[childID[1]]->sibling=arr[childID[0]];\n    }\n}\nvoid calcStatus(nodePointer *arr,int n)\n{\n  int i;//counter\n  nodePointer p;\n  for(i=0;i<n;i++)\n    {\n      p=arr[i];\n      p->degree=getDegree(arr,i);\n      p->depth=getDepth(arr,i);\n      p->height=getHeight(arr,i);\n      p->type=getType(arr,i);\n    }\n}\nint getDegree(nodePointer *arr,int id)\n{\n  int i;//counter\n  int ret=0;//return number\n  for(i=0;i<2;i++)\n    {\n      if(arr[id]->child[i]!=NULL) ret++;\n    }\n  return ret;\n}\nint getDepth(nodePointer *arr,int id)\n{\n  int ret=0;//return value\n  nodePointer p;\n  for(p=arr[id];p->parent!=NULL;p=p->parent) ret++;\n  return ret;\n}\nint getHeight(nodePointer *arr,int id)\n{\n  int i;//counter\n  int ret[2];//return value(bigger one)\n  for(i=0;i<2;i++)\n    {\n      if(arr[id]->child[i]==NULL) ret[i]=0;\n      else ret[i]=1+getHeight(arr,arr[id]->child[i]->id);\n    }\n  if(ret[0]>ret[1]) return ret[0];\n  else return ret[1];\n}\nchar *getType(nodePointer *arr,int id)\n{\n  char *str[3]={\"root\",\"leaf\",\"internal node\"};\n  if(arr[id]->parent==NULL) return str[0];\n  if(arr[id]->child[0]==NULL&&arr[id]->child[1]==NULL) return str[1];\n  return str[2];\n}\nvoid printNodeArray(nodePointer *arr,int n)\n{\n  int i;//counter\n  for(i=0;i<n;i++)\n    {\n      printf(\"node %d: \",arr[i]->id);\n      if(arr[i]->parent==NULL) printf(\"parent = -1, \");\n      else printf(\"parent = %d, \",arr[i]->parent->id);\n      if(arr[i]->sibling==NULL) printf(\"sibling = -1, \");\n      else printf(\"sibling = %d, \",arr[i]->sibling->id);\n      printf(\"degree = %d, \",arr[i]->degree);\n      printf(\"depth = %d, \",arr[i]->depth);\n      printf(\"height = %d, \",arr[i]->height);\n      printf(\"%s\",arr[i]->type);\n      printf(\"\\n\");\n    }\n}\nnodePointer getRoot(nodePointer *arr)\n{\n  int i;\n  for(i=0;;i++)\n    {\n      if(arr[i]->parent==NULL) break;\n    }\n  return arr[i];\n}\nvoid postorderWalk(nodePointer p,nodePointer root)\n{\n  if(p!=NULL)\n    {\n      postorderWalk(p->child[0],root);\n      postorderWalk(p->child[1],root);\n      printWalk(p->id);\n      if(p->id==root->id)\n\t{\n\t  printf(\"\\n\");\n\t}\n    }\n}\nvoid printWalk(int id)\n{\n  printf(\" %d\",id);\n}\n\nvoid reconstructTree(nodePointer *arr,int *pre,int *in,int n)\n{\n  int preIndex;\n  if(n<=1) return;\n  for(preIndex=0;pre[preIndex]!=in[0];preIndex++)\n    {\n      printf(\"arr[%d]->arr[%d]\\n\",pre[preIndex],pre[preIndex+1]);\n      arr[pre[preIndex]]->child[0]=arr[pre[preIndex+1]];\n      arr[pre[preIndex+1]]->parent=arr[pre[preIndex]];\n    }\n  arr[in[1]]->child[1]=arr[pre[preIndex+1]];\n  arr[pre[preIndex+1]]->parent=arr[in[1]];\n  reconstructTree(arr,pre+preIndex+1,in+2,n-preIndex-1); \n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define NIL -1\n#define N 41\n\ntypedef struct {\n  int pid;\n  int leftc;\n  int rightc;  \n} Node;\n\nint findSubtreeRoot (Node*, int*, int*, int*, int, int);\nvoid traverse (Node*, int);\n\nint main () {\n  int n;\n  Node tree[N];\n  int preorder[N];\n  int inorderID[N];\n  int inorderInfo[N];\n  \n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    tree[i].pid = NIL;\n    tree[i].leftc = NIL;\n    tree[i].rightc = NIL;\n  }\n\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &preorder[i]);\n  }\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &inorderID[i]);\n    inorderInfo[inorderID[i]] = i;\n  }\n  \n  int pid = findSubtreeRoot(tree, preorder, inorderID, inorderInfo, 1, n + 1);\n\n  traverse(tree, pid);\n  \n  return 0;\n}\n\nint findSubtreeRoot (Node* tree, int* preorder, int* inorderID, int* inorderInfo, int left, int right) {\n  static int cnt = 1;\n  int length = right - left;\n\n  if (length < 1) {\n    return NIL;    \n  }\n\n  int pid    = preorder[cnt++];\n  int pivot  = inorderInfo[pid];\n  int leftc  = findSubtreeRoot(tree, preorder, inorderID, inorderInfo, left, pivot);\n  int rightc = findSubtreeRoot(tree, preorder, inorderID, inorderInfo, pivot + 1, right);\n\n  tree[pid].leftc  = leftc;\n  tree[pid].rightc = rightc;\n  tree[leftc].pid  = pid;\n  tree[rightc].pid = pid;\n  \n  return pid;\n}\n\nvoid traverse (Node* tree, int id) {\n  if (tree[id].leftc != NIL) {\n    traverse(tree, tree[id].leftc);\n  }\n  if (tree[id].rightc != NIL) {\n    traverse(tree, tree[id].rightc);\n  }\n  if (tree[id].pid != NIL) {\n    printf(\"%d \", id);\n  } else {\n    printf(\"%d\\n\", id);\n  }\n\n  return;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#define MAX 40\nint n, preorder[MAX],inorder[MAX],post[MAX],n_post,pos;\n\nvoid rec(int l, int r)\n{\n\tif (l >= r){return;}\n\tint root = preorder[pos++];\n\tint m = distance(root);\n\trec(l, m);\n\trec(m+1,r);\n\tpost[n_post++] = root;\n}\n\n\nint distance(int x)\n{\n\tint i;\n\tfor (i = 0; i < n; ++i){\n\t\tif (inorder[i] == x)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\n\nvoid solve()\n{\n\tint i;\n\trec(0, n);\n\tfor (i = 0; i < n_post; ++i)\n\t\tprintf(\"%d%c\", post[i], (i != n_post - 1) ? ' ' : '\\n');\n}\n\nint main(int argc, char** argv)\n{\n\tint i;\n\tn_post = 0;\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; ++i){scanf(\"%d\", &preorder[i]);}\n\tfor (i = 0; i < n; ++i){scanf(\"%d\", &inorder[i]);}\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n \n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\nint in()\n{\n    int n = 0, c = gc();\n    do n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n    return n;\n}\n \nint pre[45], ind[45];\nint post[45], sz, pos;\nint idx[45];\n \nvoid rebuild(int l, int r)\n{\n    int c, m;\n \n    if (l >= r) return;\n    c = pre[pos++];\n    m = idx[c];\n    rebuild(l, m);\n    rebuild(m+1, r);\n    post[sz++] = c;\n}\n \nint main()\n{\n    int n, i;\n \n    n = in();\n    for (i = 0; i < n; i++) pre[i] = in();\n    for (i = 0; i < n; i++) idx[in()] = i;\n \n    sz = 0, pos = 0;\n    rebuild(0, n);\n     \n    printf(\"%d\", post[0]);\n    for (i = 1; i < n; i++) {\n        putchar(' '), printf(\"%d\", post[i]);\n    }\n    putchar('\\n');\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 50\n\n\n\ntypedef struct cell{\n int id;\n struct cell *right;\n struct cell *left;\n struct cell *parent;\n}cell;\n\n\nvoid postorder(cell *root,cell N[]){\ncell *p=root;\nif(p->left!=NULL){postorder(p->left,N);}\nif(p->right!=NULL){postorder(p->right,N);}\nprintf(\"%d \",p->id);\n \nreturn;\n}\n\n\nint reconstruction(int A[],int B[],int start,int last,cell N[],int n){\nint i,j;\nint a,b;\nint x;\n\n\nif(start!=last){\n\n for(i=0;i<n;i++){\n  for(j=start;j<=last;j++){\n\n   if(B[j]==A[i]){x=A[i];\n    a=reconstruction(A,B,start,j-1,N,n);\n    if(a!=-1){\n\n     N[A[i]].left=&N[a];\n     N[a].parent=&N[A[i]];\n    }\n    else{\n     N[A[i]].left=NULL;\n    }\n\n    b=reconstruction(A,B,j+1,last,N,n);\n    if(b!=-1){\n     N[A[i]].right=&N[b];\n     N[b].parent=&N[A[i]];\n    }\n    else{\n     N[A[i]].right=NULL;\n    }\n\n    return x;\n   }\n\n  }/*for1st*/\n\n }\n\n}/*ifおわり*/\n\n\nif(start==last){\n N[B[start]].right=NULL;\n N[B[start]].left=NULL;\n return B[start];\n}\n\n}\n\n\n\n\nint main(){\nint n,i;\nint A[MAX];\nint B[MAX];\ncell N[MAX];\ncell *root;\nint x;\n\nscanf(\"%d\",&n);\nfor(i=0;i<n;i++)scanf(\"%d\",&A[i]);\nfor(i=0;i<n;i++)scanf(\"%d\",&B[i]);\n\nfor(i=0;i<=n;i++)N[i].id=i;\n\n\nx=reconstruction(A,B,0,n-1,N,n);\n\nroot=&N[x];\n\n\n\npostorder(root,N);\nprintf(\"\\a\");\nprintf(\"\\n\");\n\nreturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX 40\n\nstruct node\n{\n\tint p;\n\tint l, r;\n} typedef node;\n\nint CreateTree(int, int, int, int);\nint Position(int, int, int[], int);\nvoid Postorder(int, int);\n\nint P[MAX];\nint I[MAX];\nnode N[MAX];\n\nint main()\n{\n\tint i;\n\tint n;\n\tint root;\n\t\n\tscanf(\"%d\", &n);\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &P[i]);\n\t}\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &I[i]);\n\t}\n\t\n\troot = CreateTree(-1, n, 0, 0);\n\t\n\tPostorder(root, n);\n}\n\nint CreateTree(int parent, int n, int head_P, int head_I)\n{\n\tint root;\n\tint root_P, root_I;\n\tint n_l, n_r;\n\t\n\troot = P[head_P];\n\t\n\tif(n == 0) return -1;\n\n\troot_P = head_P;\n\troot_I = Position(n, head_I, I, root);\n\t\n\tn_l = root_I - head_I;\n\tn_r = n - n_l - 1;\n\t\n\tN[root].p = parent;\n\tN[root].l = CreateTree(root, n_l, root_P + 1, head_I);\n\tN[root].r = CreateTree(root, n_r, root_P + 1 + n_l, root_I + 1);\n\t\n\treturn root;\n}\n\nint Position(int n, int h, int A[], int s)\n{\n\tint i;\n\t\n\tfor(i = h; i < h + n; i++)\n\t{\n\t\tif(A[i] == s) return i;\n\t}\n\treturn -1;\n}\n\nvoid Postorder(int id, int n)\n{\n\tstatic int count = 0;\n\t\n\tif(id == -1) return;\n\t\n\tPostorder(N[id].l, n);\n\tPostorder(N[id].r, n);\n\t\n\tcount++;\n\tif(count != n) printf(\"%d \", id);\n\telse printf(\"%d\\n\", id);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint search(int arr[], int val, int n)\n{\n  int i;\n\n  for (i = 0; i < n; i++)\n    if (arr[i] == val)\n      return i;\n  return -1;\n}\n\nint postorder[45];\n\nvoid po(int inorder[], int preorder[], int n) {\n\n  int rootIndex = search(inorder, preorder[0], n);\n\n  if (rootIndex > 0)\n    po(inorder, preorder + 1, rootIndex);\n\n  if (rootIndex != n - 1)\n    po(inorder + rootIndex + 1, preorder + rootIndex + 1, n - rootIndex - 1);\n\n  printf(\"%d \", preorder[0]);\n}\n\nint main() {\n  int n, i;\n\n  scanf(\"%d\", &n);\n\n  int preorder[n];\n  int inorder[n];\n\n  for (i = 0; i < n; i++)\n    scanf(\"%d\", &preorder[i]);\n\n  for (i = 0; i < n; i++)\n    scanf(\"%d\", &inorder[i]);\n\n  po(inorder, preorder, n);\n  // printf(\"\\n\");\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nvoid Repair(int ,int );\nint Preorder[100],Inorder[100],Postorder[100],postnode=0,nownode=0;\nint main(void){\n  int i,n;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)\n    scanf(\"%d\",&Preorder[i]);\n  for(i=0;i<n;i++)\n    scanf(\"%d\",&Inorder[i]);\n\n  Repair(0,n);\n\n  for(i=0;i<n;i++){\n    printf(\"%d\",Postorder[i]);\n    if(i!=n-1)printf(\" \");\n  }\n  printf(\"\\n\");\n  return 0;\n}\nvoid Repair(int left,int right){\n  int rootnode,distance;\n  if(left<right){\n    rootnode=Preorder[nownode++];\n    distance=0;\n    while(distance<right){\n      //search for element of root\n      if(Inorder[distance]==rootnode)\n        break;\n      distance++;\n    }\n    Repair(left,distance);//left tree (include element of root)\n    Repair(distance+1,right);//right tree\n    Postorder[postnode++]=rootnode;\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint left[40];\nint right[40];\nint pre[40];\nint in[40];\nint post[40];\nint posthead;\n\nvoid push(int node){\n    post[posthead++] = node;\n}\n\nvoid postorder(int node){\n    if(node == -1) return;\n    postorder(left[node]);\n    postorder(right[node]);\n    push(node);\n}\n\nint find(int a[], int v, int b, int c){\n    for(int i=b; i<c; i++)\n        if(a[i] == v)\n            return i;\n    return -1;\n}\n\nint recon(int pa, int pb, int ia, int ib){\n    int root = pre[pa];\n    int i = find(in, root, ia, ib);\n    int nl = i - ia;\n    if(nl == 0)\n        left[root] = -1;\n    else\n        left[root] = recon(pa + 1, pa + nl + 1, ia, ia + nl);\n    int nr = ib - i - 1;\n    if(nr == 0)\n        right[root] = -1;\n    else\n        right[root] = recon(pa + nl + 1, pb, i + 1, ib);\n    return root;\n}\n\nint main(void){\n    int n;\n    scanf(\"%d\", &n);\n    for(int i=0; i<n; i++){\n        scanf(\"%d\", &pre[i]);\n        pre[i]--;\n    }\n    for(int i=0; i<n; i++){\n        scanf(\"%d\", &in[i]);\n        in[i]--;\n    }\n    int root = recon(0, n, 0, n);\n    postorder(root);\n    for(int i=0; i<n; i++){\n        printf(\"%d\", post[i]+1);\n        putchar(i<n-1?' ':'\\n');\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#define dbg(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#define dpri(x) dbg(#x \": %d\\n\", x)\n#define dprs(x) dbg(#x \": %s\\n\", x)\n#include <stdio.h>\n#include <string.h>\ntypedef long long ll;\nconst int MYINF = 1e9+7;\ntypedef int bool;\nconst bool true = 1;\nconst bool false = 0;\n\n#define MAX_N 64\n\ntypedef struct node_st {\n\tint left, right;\n\tint pre, in;\n} node_t;\n\nint n;\nint preorder[MAX_N];\nint inorder[MAX_N];\nnode_t nd[MAX_N];\n\nvoid recons(int id, int base , int n) {\n\tint pre, in, remain_left, remain_right;\n\tif (id == 0) return;\n\n\tpre = nd[id].pre;\n\tin = nd[id].in;\n\tremain_left = (in - base);\n\tremain_right = n - remain_left - 1;\n\n\tif (remain_left > 0) {\n\t\tnd[id].left = preorder[pre+1];\n\t\trecons(nd[id].left, base, remain_left);\n\t}\n\n\tif (remain_right > 0) {\n\t\tnd[id].right = preorder[pre+remain_left+1];\n\t\trecons(nd[id].right, in+1, remain_right);\n\t}\n}\n\nvoid postorder(int id) {\n\tstatic const char *sp = \"\";\n\tif (!id) return;\n\tif (nd[id].left) postorder(nd[id].left);\n\tif (nd[id].right) postorder(nd[id].right);\n\tprintf(\"%s%d\", sp, id);\n\tsp = \" \";\n}\n\nint main(int argc, char **argv)\n{\n\tint i;\n\n\tmemset(nd, 0, sizeof(node_t) * MAX_N);\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &preorder[i]);\n\t\tnd[preorder[i]].pre = i;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &inorder[i]);\n\t\tnd[inorder[i]].in = i;\n\t}\n\n\trecons(preorder[0], 0, n);\n\tpostorder(preorder[0]);\n\tputs(\"\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 41\n\ntypedef struct node{\n\tint L_id;\n\tint R_id;\n}node;\n\nnode c[N];\nint a[N];\nint b[N];\nint cnt=0;\n\nvoid postorder(int root,int n){\n\t\n\tif(c[root].L_id!=-1)\n\t\tpostorder(c[root].L_id,n);\n\t\n\tif(c[root].R_id!=-1)\n\t\tpostorder(c[root].R_id,n);\n\t\n\tif(cnt<n-1)\n\t\tprintf(\"%d \",root);\n\telse \n\t\tprintf(\"%d\\n\",root);\n\t\n\tcnt++;\n\n\treturn;\n\t\n}\n\nint reconst(int start,int last,int n){\n\t\n\tif(start==last)\n\t\treturn b[start];\n\t\t\n\telse if(start > last)\n\t\treturn -1;\n\t\n\telse {\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=start;j<=last;j++){\n\t\t\t\tif(a[i]==b[j]){\n\t\t\t\t\tc[a[i]].L_id=reconst(start,j-1,n);\n\t\t\t\t\tc[a[i]].R_id=reconst(j+1,last,n);\n\t\t\t\t\treturn a[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\n\n\n\nint main(){\n\tint n,i;\n\tint root;\n\t\n\tscanf(\"%d\",&n);\n\t\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\t\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%d\",&b[i]);\n\t\t\n\tfor(i=1;i<=n;i++){\n\t\tc[i].L_id=-1;\n\t\tc[i].R_id=-1;\n\t}\n\t\n\troot=reconst(1,n,n);\n\t\n\tpostorder(root,n);\n\t\n\treturn 0;\n\t\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n \nint n,pos;\nint a[40],b[40];\n \nvoid solve(int l,int r){\n  if(l>r)return;\n  if(l==r){\n    if(b[l]==a[0])printf(\"%d\",b[l]);\n    else printf(\"%d \",b[l]);\n    pos++;\n    return;\n  }\n \n  int x=a[pos],i;\n  pos++;\n  for(i=l;i<=r;i++){\n    if(b[i]==x)break;\n  }\n  solve(l,i-1);\n  solve(i+1,r);\n   \n  if(x==a[0])printf(\"%d\",x);\n  else printf(\"%d \",x);\n}\n \nint main(){\n  int i;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)scanf(\"%d\",&a[i]);\n  for(i=0;i<n;i++)scanf(\"%d\",&b[i]);\n  pos=0;\n  solve(0,n-1);\n  printf(\"\\n\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// 点数いらないです。\n\n#include <stdio.h>\n\n    int cnt=0;\n    int fir[100],mid[100];\n    int i,g;\n\nvoid solve(int m,int t){\n    \n    \n    \n    if (m==t){\n        if(mid[m]==fir[0]){\n            \n          printf(\"%d\",mid[m]);\n            \n        }else  {\n            \n            printf(\"%d \",mid[m]);\n            \n            cnt++;\n            \n            return;\n            \n        }\n    }\n    \n    \n    g=fir[cnt];\n    \n    cnt++;\n    \n    \n    for(i=m;i<t;i++){\n        if(mid[i]==g)break;\n    }\n    \n    solve(m,i-1);\n    solve(i+1,t);\n    \n    if(g==fir[0])printf(\"%d\",g);\n    else printf(\"%d \",g);\n    \n}\n\n\n\n\n\n\nint main(void){\n    \n    int n;\n\n    \n    scanf(\"%d\",&n);\n    \n    for(i=0;i<n;i++){\n        scanf(\"%d\",&fir[i]);\n       // scanf(\"%d\",&mid[i]);\n    }\n    \n    for(i=0;i<n;i++){\n        scanf(\"%d\",&mid[i]);\n    }\n    \n    \n    solve(0,n-1);\n    \n    printf(\"\\n\");\n    \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint parent[40];\nint left[40];\nint right[40];\nint pre[40];\nint in[40];\nint post[40];\nint posthead;\n\nvoid push(int node){\n    post[posthead++] = node;\n}\n\nvoid postorder(int node){\n    if(node == -1) return;\n    postorder(left[node]);\n    postorder(right[node]);\n    push(node);\n}\n\nint find(int a[], int v, int b, int c){\n    for(int i=b; i<c; i++)\n        if(a[i] == v)\n            return i;\n    return -1;\n}\n\nint recon(int parent, int pa, int pb, int ia, int ib){\n    int root = pre[pa];\n    int i = find(in, root, ia, ib);\n    int nl = i - ia;\n    if(nl == 0)\n        left[root] = -1;\n    else\n        left[root] = recon(root, pa + 1, pa + nl + 1, ia, ia + nl);\n    int nr = ib - i - 1;\n    if(nr == 0)\n        right[root] = -1;\n    else\n        right[root] = recon(root, pa + nl + 1, pb, i + 1, ib);\n    return root;\n}\n\nint main(void){\n    int n;\n    scanf(\"%d\", &n);\n    for(int i=0; i<n; i++)\n        scanf(\"%d\", &pre[i]);\n    for(int i=0; i<n; i++)\n        scanf(\"%d\", &in[i]);\n    int root = recon(-1, 0, n, 0, n);\n    postorder(root);\n    for(int i=0; i<n; i++){\n        printf(\"%d\", post[i]);\n        putchar(i<n-1?' ':'\\n');\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define POINT 41\n\nint P[POINT], I[POINT], Po[POINT];\nint n, now = 0, s = 0;\n\nvoid Rec(int, int);\n\nvoid Rec(int l, int r) {\n    int c,m;\n    \n//    printf(\"0\");\n    if(l >= r) {\n        return;\n    }\n    c = P[now++];\n    m = Find(c);\n    Rec(l, m);\n//    printf(\"1\");\n    Rec(m + 1, r);\n  //  printf(\"2\");\n    Po[s++] = c;\n}\n\nint Find(int c) {\n    int i;\n    \n    //接点番号が一致したIndexを返す\n    for(i = 0 ; i < n ; i++) {\n        if(c == I[i]) {\n            return i;\n        }\n    }\n    return 0;\n}\n\nint main(void){\n    int i;\n    \n    scanf(\"%d\",&n);\n    \n    //preoder include\n    for(i = 0 ; i < n ; i++) {\n        scanf(\"%d\",&P[i]);\n    }\n    \n    //inoder include\n    for(i = 0 ; i < n ; i++) {\n        scanf(\"%d\",&I[i]);\n    }\n    \n    Rec(0,n);\n    \n    for(i = 0 ; i < n-1 ; i++) {\n        printf(\"%d\",Po[i]);\n    }\n    printf(\"%d\\n\", Po[n-1]);\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX 40\n\nint n,Preorder[MAX],Inorder[MAX];\n\nvoid Tree(int,int);\n\nint main(){\n  int i;\n\n  scanf(\"%d\",&n);\n  for(i = 0 ; i < n ; i++){\n      scanf(\"%d\",&Preorder[i]);\n  }\n  for(i=0;i<n;i++){\n      scanf(\"%d\",&Inorder[i]);\n  }\n\n  Tree(0,n);\n\n  return 0;\n}\n\nvoid Tree(int Light,int Right){\n  static int i,k;\n  int c,m,j;\n\n  if(Light >= Right)return;\n\n  c = Preorder[i++];\n\n  for(j = Light ; j < Right ; j++){\n      if(c == Inorder[j])break;\n  }\n\n  Tree(Light,j);\n  Tree(j+1,Right);\n\n  if(k == n - 1) printf(\"%d\\n\",c);\n  else printf(\"%d \",c);\n  k++;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nstruct STRUCT00 {\n    struct STRUCT00 * MEMBER00 ;\n    struct STRUCT00 * MEMBER01 ;\n    struct STRUCT00 * MEMBER02 ;\n    int MEMBER03 ;\n} ;\n\nstatic struct STRUCT00 * FUNC00 ( int ARG00 ) {\n    struct STRUCT00 * VAR00 = malloc ( sizeof ( struct STRUCT00 ) ) ;\n\n    VAR00 -> MEMBER00 = VAR00 -> MEMBER01 = VAR00 -> MEMBER02 = NULL ;\n    VAR00 -> MEMBER03 = ARG00 ;\n\n    return VAR00 ;\n}\n\nstatic void FUNC01 ( struct STRUCT00 * ARG01 ) {\n    free ( ARG01 ) ;\n\n    return ;\n}\n\nstatic int FUNC02 ( const int ARG02 [ ] , int ARG03 , const int ARG04 [ ] , int ARG05 , int ARG06 ) {\n    int VAR01 , VAR02 ;\n\n    for ( VAR01 = 0 ; VAR01 < ARG03 ; VAR01 ++ ) {\n        for ( VAR02 = ARG05 ; VAR02 < ARG06 ; VAR02 ++ ) {\n            if ( ARG02 [ VAR01 ] == ARG04 [ VAR02 ] ) {\n                return ARG02 [ VAR01 ] ;\n            }\n        }\n    }\n\n    return -1 ;\n}\n\nstatic int FUNC03 ( int ARG07 , const int ARG08 [ ] , int ARG09 , int ARG10 ) {\n    int VAR03 ;\n\n    for ( VAR03 = ARG09 ; VAR03 < ARG10 ; VAR03 ++ ) {\n        if ( ARG08 [ VAR03 ] == ARG07 ) {\n            return VAR03 ;\n        }\n    }\n    assert ( 0 ) ;\n\n    return -1 ;\n}\n\nstatic struct STRUCT00 * FUNC04 ( struct STRUCT00 * ARG11 , const int ARG12 [ ] , int ARG13 , const int ARG14 [ ] , int ARG15 , int ARG16 ) {\n    int VAR04 ;\n    int VAR05 ;\n    struct STRUCT00 * VAR06 ;\n\n    if ( ARG15 >= ARG16 ) {\n        return NULL ;\n    }\n\n    VAR04 = FUNC02 ( ARG12 , ARG13 , ARG14 , ARG15 , ARG16 ) ;\n    VAR05 = FUNC03 ( VAR04 , ARG14 , ARG15 , ARG16 ) ;\n\n    VAR06 = FUNC00 ( VAR04 ) ;\n    VAR06 -> MEMBER00 = ARG11 ;\n\n    VAR06 -> MEMBER01 = FUNC04 ( VAR06 , ARG12 , ARG13 , ARG14 , ARG15 , VAR05 ) ;\n    VAR06 -> MEMBER02 = FUNC04 ( VAR06 , ARG12 , ARG13 , ARG14 , VAR05 + 1 , ARG16 ) ;\n\n    return VAR06 ;\n}\n\nstatic void FUNC05 ( const struct STRUCT00 * ARG17 ) {\n\n    if ( ARG17 == NULL ) {\n        return ;\n    }\n\n    FUNC05 ( ARG17 -> MEMBER01 ) ;\n    FUNC05 ( ARG17 -> MEMBER02 ) ;\n    printf ( \"%d\" , ARG17 -> MEMBER03 ) ;\n\n    if ( ARG17 -> MEMBER00 ) {\n        printf ( \" \" ) ;\n    }\n\n    return ;\n}\n\nstatic void FUNC06 ( struct STRUCT00 * ARG18 ) {\n    if ( ! ARG18 ) {\n        return ;\n    }\n\n    FUNC06 ( ARG18 -> MEMBER01 ) ;\n    FUNC06 ( ARG18 -> MEMBER02 ) ;\n    FUNC01 ( ARG18 ) ;\n\n    return ;\n}\n\nint main ( void ) {\n    int VAR07 ;\n    int VAR08 ;\n    int * VAR09 , * VAR10 ;\n    struct STRUCT00 * VAR11 ;\n\n    scanf ( \"%d\\n\" , & VAR07 ) ;\n    VAR09 = malloc ( sizeof ( int ) * VAR07 ) ;\n    VAR10 = malloc ( sizeof ( int ) * VAR07 ) ;\n\n    for ( VAR08 = 0 ; VAR08 < VAR07 ; VAR08 ++ ) {\n        int VAR12 ;\n        scanf ( \"%d\" , & VAR12 ) ;\n        VAR09 [ VAR08 ] = VAR12 ;\n    }\n    for ( VAR08 = 0 ; VAR08 < VAR07 ; VAR08 ++ ) {\n        int VAR13 ;\n        scanf ( \"%d\" , & VAR13 ) ;\n        VAR10 [ VAR08 ] = VAR13 ;\n    }\n\n    VAR11 = FUNC04 ( NULL , VAR09 , VAR07 , VAR10 , 0 , VAR07 ) ;\n\n    FUNC05 ( VAR11 ) ;\n    printf ( \"\\n\" ) ;\n\n    FUNC06 ( VAR11 ) ;\n    free ( VAR09 ) ;\n    free ( VAR10 ) ;\n\n    return 0 ;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint pos,postnum;\n\nint search(int a[],int n,int s){\n    int i;\n    for(i=0;i<n;i++){\n        if(a[i]==s){\n            return i;\n        }\n    }\n    return -1;\n}\n\nvoid rec(int l,int r,int n,int pre[],int in[],int post[]){\n    int root,k;\n    if(l>=r){return;}\n    root = pre[pos];pos++;\n    k = search(in,n,root);\n    rec(l,k,n,pre,in,post);rec(k+1,r,n,pre,in,post);\n    post[postnum]=root;postnum++;\n}\n\nvoid solve(int n,int pre[],int in[],int post[]){\n    int i;\n    pos=0;postnum=0;\n    rec(0,n,n,pre,in,post);\n    printf(\"%d\",post[0]);\n    for(i=1;i<n;i++){\n        printf(\" %d\",post[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main(void){\n    int n,i;\n    int *pre,*in,*post;\n    scanf(\"%d\",&n);\n    pre = (int*)malloc(sizeof(int)*n);\n    in = (int*)malloc(sizeof(int)*n);\n    post = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&pre[i]);\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&in[i]);\n    }\n    solve(n,pre,in,post);\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\n//============================================================================\n#define pred(x) ((x)-1)\n#define succ(x) ((x)+1)\n//============================================================================\nstruct Node{\n    short  id;\n    struct Node *parent;\n    struct Node *left, *right;\n};\ntypedef struct Node TNode;\n//============================================================================\nstruct Chain{\n    struct Chain *prev;\n    TNode *node;\n    struct Chain *next;\n};\ntypedef struct Chain TChain;\nTChain *RootChain;\n//============================================================================\n//============================================================================\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nTChain *ChainAlloc(void)\n{\n    TChain *ptr;\n    ptr=malloc(sizeof(TChain));\n    if (ptr==NULL)\n        exit(1);\n    memset(ptr, 0, sizeof(TChain));\n    return ptr;\n}\n//----------------------------------------------------------------------------\nvoid inschain(TChain *chn, TNode *node)\n{\n    while(chn->next!=NULL)\n        chn=chn->next;\n    chn->next=ChainAlloc();\n    chn->next->node=node;\n    chn->next->prev=chn;\n}\n//----------------------------------------------------------------------------\nvoid delchain(TChain *chn)\n{\n    if (chn->prev){\n        chn->prev->next=chn->next;\n    }\n    if (chn->next){\n        chn->next->prev=chn->prev;\n    }\n    free(chn);\n}\n//----------------------------------------------------------------------------\nTChain *searchchain(TChain *chn, short id)\n{\n    do{\n        if (chn->node->id==id)\n            return chn;\n        if (chn->node->left && chn->node->left->id==id)\n            return chn;\n        if (chn->node->right && chn->node->right->id==id)\n            return chn;\n        chn=chn->next;\n    }while(chn!=NULL);\n    return NULL;\n}\n//----------------------------------------------------------------------------\nvoid pushnode(TNode *node)\n{\n    if (RootChain==NULL){\n        RootChain=ChainAlloc();\n        RootChain->node=node;\n    }else{\n        inschain(RootChain, node);\n    }\n}\n//----------------------------------------------------------------------------\nTNode *popnode(short id)\n{\n    TChain *chn; TNode *node;\n\n    node=NULL;\n    chn=searchchain(RootChain, id);\n    if (chn){\n        if (chn->node->id==id)\n            node=chn->node;\n        else\n        if (chn->node->left && chn->node->left->id==id)\n            node=chn->node->left;\n        else\n        if (chn->node->right && chn->node->right->id==id)\n            node=chn->node->right;\n        if (node==chn->node)\n            delchain(chn);\n    }\n    return node;\n}\n//----------------------------------------------------------------------------\nTNode *nodealloc(void)\n{\n    TNode *node;\n    node=malloc(sizeof(TNode));\n    if (node==NULL){\n        fprintf(stderr, \"not enough memry\\n\");\n        exit(1);\n    }\n    memset(node, 0, sizeof(TNode));\n    return node;\n}\n//----------------------------------------------------------------------------\nTNode *existid(TNode *node, short id)\n{\n    TNode *nd;\n\n    if (node==NULL || node->id==id)\n        return node;\n    if ((nd=existid(node->left, id))!=NULL)\n        return nd;\n    nd=existid(node->right, id);\n    return nd;\n}\n//----------------------------------------------------------------------------\nvoid putnode(TNode **root, TNode **node, TNode *parent, short id)\n{\n    TNode *nd;\n\n    if ((nd=existid(*root, id))==NULL)\n        nd=popnode(id);\n    if (nd==NULL){\n        *node=nodealloc();\n    }else{\n        *node=nd;\n        //nd->parent=*node;\n        if (*root==nd){\n            *root=parent;\n            while((*root)->parent!=NULL)\n                *root=(*root)->parent;\n        }\n    }\n    (*node)->id=id;\n    (*node)->parent=parent;\n}\n//----------------------------------------------------------------------------\nTNode *rootnode(TNode *node)\n{\n    while(node->parent)\n        node=node->parent;\n    return node;\n}\n//----------------------------------------------------------------------------\nvoid getnode(FILE *file, TNode **node)\n{\n    long id,left,right; TNode *ser;\n\n    fscanf(file, \"%ld\", &id);\n    fscanf(file, \"%ld\", &left);\n    fscanf(file, \"%ld\", &right);\n    if (*node==NULL){\n        *node=nodealloc();\n        ser=*node;\n        pushnode(*node);\n    }else\n        ser=existid(*node, id);\n    if (ser==NULL){\n        ser=popnode(id);\n        if (ser==NULL)\n            ser=nodealloc();\n    }\n    if (*node!=rootnode(ser))\n    pushnode(ser);\n    ser->id=id;\n    if (0<=left)\n        putnode(node, &ser->left, ser, left);\n    if (0<=right)\n        putnode(node, &ser->right, ser, right);\n}\n//----------------------------------------------------------------------------\nshort depth(TNode *node)\n{\n    short n;\n\n    for (n=0; node->parent!=NULL; n++)\n        node=node->parent;\n    return n;\n}\n//----------------------------------------------------------------------------\nshort height(TNode *node)\n{\n    short l,r;\n\n    if (node==NULL)\n        return -1;\n    l=succ(height(node->left));\n    r=succ(height(node->right));\n    return (r<l)?l:r;\n}\n//----------------------------------------------------------------------------\nchar *root=\"root\";\nchar *internalroot=\"internal node\";\nchar *leaf=\"leaf\";\nchar *nodetype(TNode *node)\n{\n    if (node->parent==NULL)\n        return root;\n    if (node->left!=NULL || node->right!=NULL)\n        return internalroot;\n    return leaf;\n}\n//----------------------------------------------------------------------------\nvoid output(TNode *root, long n)\n{\n    short i,j,cnt,id,sib,deg; TNode *node;\n\n    for (i=cnt=0; cnt<n; i++){\n        node=existid(root, i);\n        if (node!=NULL){\n            cnt++;\n            sib=-1;\n            if (node->parent!=NULL && node->parent->left!=NULL && node->parent->right!=NULL){\n                if (node->parent->left==node)\n                    sib=node->parent->right->id;\n                else\n                    sib=node->parent->left->id;\n            }\n            deg=(node->left==NULL)?0:1;\n            deg+=(node->right==NULL)?0:1;\n            id=(node->parent==NULL)?-1:node->parent->id;\n            printf(\"node %d: \", node->id);\n            printf(\"parent = %d, \", id);\n            printf(\"sibling = %d, \", sib);\n            printf(\"degree = %d, \", deg);\n            printf(\"depth = %d, \", depth(node));\n            printf(\"height = %d, \", height(node));\n            printf(\"%s\\n\", nodetype(node));\n        }\n    }\n}\n//----------------------------------------------------------------------------\nvoid preorder(TNode *node)\n{\n    if (node==NULL)\n        return;\n    printf(\" %d\", node->id);\n    preorder(node->left);\n    preorder(node->right);\n}\n//----------------------------------------------------------------------------\nvoid inorder(TNode *node)\n{\n    if (node==NULL)\n        return;\n    inorder(node->left);\n    printf(\" %d\", node->id);\n    inorder(node->right);\n    //printf(\" %d\", node->id);\n}\n//----------------------------------------------------------------------------\nvoid postorder(TNode *node)\n{\n    if (node==NULL)\n        return;\n    postorder(node->left);\n    postorder(node->right);\n    printf(\" %d\", node->id);\n}\n//----------------------------------------------------------------------------\nvoid treewalk(TNode *node, short n)\n{\n    printf(\"Preorder\\n\");\n    preorder(node);\n    printf(\"\\nInorder\\n\");\n    inorder(node);\n    printf(\"\\nPostorder\\n\");\n    postorder(node);\n    printf(\"\\n\");\n}\n//----------------------------------------------------------------------------\nvoid reconstruct(TNode *node, short *pre, short *ino, short n)\n{\n    short i;\n\n    node->id = *pre;\n    if (n==1)\n        return;\n    for (i=0; ino[i]!=*pre; i++);\n    if (i){\n        node->left=nodealloc();\n        node->left->parent=node;\n        reconstruct(node->left, succ(pre), ino, i);\n    }\n    if (i<n){\n        node->right=nodealloc();\n        node->right->parent=node;\n        reconstruct(node->right, &pre[succ(i)], &ino[succ(i)], pred(n-i));\n    }\n}\n//----------------------------------------------------------------------------\nvoid inputorder(FILE *file)\n{\n    long i,n,m; TNode *root; char buffer[20];\n\n    RootChain=NULL;\n    fgets(buffer, sizeof(buffer)-1, file);\n    sscanf(buffer, \"%ld\", &n);\n    for (i=0, root=NULL; i<n; i++){\n        getnode(file, &root);\n        //printf(\"%08X\\n\", root);\n    }\n    while(root->parent)\n        root=root->parent;\n    //output(root, n);\n    treewalk(root, n);\n}\n//----------------------------------------------------------------------------\n#define MAX_N 40\nvoid input(FILE *file)\n{\n    long i,n; TNode *root; char buffer[20]; short preorder[MAX_N], inorder[MAX_N];\n\n    memset(preorder, 0, sizeof(preorder));\n    memset(inorder, 0, sizeof(inorder));\n    fgets(buffer, sizeof(buffer)-1, file);\n    sscanf(buffer, \"%ld\", &n);\n    root=nodealloc();\n    for (i=0; i<n; i++){\n        fscanf(file, \"%hd\", &preorder[i]);\n    }\n    for (i=0; i<n; i++){\n        fscanf(file, \"%hd\", &inorder[i]);\n    }\n    reconstruct(root, preorder, inorder, n);\n    postorder(root);\n    printf(\"\\n\");\n}\n//============================================================================\n#ifndef DESKTOP\nint main()\n{\n    input(stdin);\n    return 0;\n}\n#endif"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nstruct Node {\n    struct Node* parent;\n    struct Node* left;\n    struct Node* right;\n    int id;\n};\n\nstatic struct Node* CreateNode(int id) {\n    struct Node* p_node = malloc(sizeof(struct Node));\n\n    p_node->parent = p_node->left = p_node->right = NULL;\n    p_node->id = id;\n\n    return p_node;\n}\n\nstatic void DestroyNode(struct Node* p_node) {\n    free(p_node);\n\n    return;\n}\n\nstatic int FindRoot(const int pre[], int n, const int in[], int l, int r) {\n    int i, j;\n\n    for ( i = 0; i < n; i++ ) {\n        for ( j = l; j < r; j++ ) {\n            if ( pre[i] == in[j] ) {\n                return pre[i];\n            }\n        }\n    }\n    \n    return -1;\n}\n\nstatic int GetRootPos(int root, const int in[], int s, int e) {\n    int i;\n    \n    for ( i = s; i < e; i++ ) {\n        if ( in[i] == root ) {\n            return i;\n        }\n    }\n    assert( 0 );\n    \n    return -1;\n}\n\nstatic struct Node* Reconstruction(struct Node* p_parent, const int pre[], int n, const int in[], int l, int r) {\n    int root;\n    int in_index;\n    struct Node* p_root;\n    \n    if ( l >= r ) {\n        return NULL;\n    }\n\n    root = FindRoot(pre, n, in, l, r);\n    in_index = GetRootPos(root, in, l, r);\n    \n    p_root = CreateNode(root);\n    p_root->parent = p_parent;\n\n    p_root->left = Reconstruction(p_root, pre, n, in, l, in_index);\n    p_root->right = Reconstruction(p_root, pre, n, in, in_index + 1, r);\n\n    return p_root;\n}\n\nstatic void PrintPostorder(const struct Node* p_root) {\n\n    if ( p_root == NULL ){\n        return;\n    }\n\n    PrintPostorder(p_root->left);\n    PrintPostorder(p_root->right);\n    printf(\"%d\", p_root->id);\n\n    if ( p_root->parent ) {\n        printf(\" \");\n    }\n\n    return;\n}\n\nstatic void DestroyTree(struct Node *p_root) {\n    if ( !p_root ) {\n        return;\n    }\n\n    DestroyTree(p_root->left);\n    DestroyTree(p_root->right);\n    DestroyNode(p_root);\n\n    return;\n}\n\nint main(void) {\n    int n;\n    int i;\n    int *pre, *in;\n    struct Node* p_root;\n\n    scanf(\"%d\\n\", &n);\n    pre = malloc(sizeof(int) * n);\n    in  = malloc(sizeof(int) * n);\n\n    for ( i = 0; i < n; i++ ) {\n        int d;\n        scanf(\"%d\", &d);\n        pre[i] = d;\n    }\n    for ( i = 0; i < n; i++ ) {\n        int d;\n        scanf(\"%d\", &d);\n        in[i] = d;\n    }\n\n    p_root = Reconstruction(NULL, pre, n, in, 0, n);\n\n    PrintPostorder(p_root);\n    printf(\"\\n\");\n\n    DestroyTree(p_root);\n    free(pre);\n    free(in);    \n\n    return 0;\n}\n            \n        \n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 100\n\nint cnt = 0;\nint n;\nint pre[MAX], in[MAX], post[MAX];\n\nint find(int u){\n    int i;\n    for(i = 0; i < n; i++){\n        if(u == in[i]){\n            return i;\n        }\n    }\n\n\n    return -1;\n}\n\nvoid reconstruct(int l, int r){\n    if (l >= r) return;\n    int root = pre[cnt++];\n    int mid = find(root);\n\n    reconstruct(l, mid);\n    reconstruct(mid + 1, r);\n    if (cnt != n) printf(\"%d \", root);\n    else printf(\"%d\", root);\n}\n\nint main(){\n    int i;\n    scanf(\"%d\", &n);\n\n    for(i = 0; i < n; i++) scanf(\"%d\", &pre[i]);\n    for(i = 0; i < n; i++) scanf(\"%d\", &in[i]);\n\n    reconstruct(0, n);\n    printf(\"\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\ntypedef struct BinaryTree\n{\n\tint data;\n\tBinaryTree *lchild,*rchild;\n}BinaryTree;\nint post[40],i;\nvoid pre_in_order(int *pre,int l1,int r1,int *in,int l2,int r2,BinaryTree **root)\n{\n\tint m;\n\ti=0;\n\t*root=(BinaryTree *)malloc(sizeof(BinaryTree));\n\t(*root)->data=pre[l1];\n\tm=l2;\n\twhile(pre[l1]!=in[m])\n\tm++;\n\tif(m==l2)\n\t(*root)->lchild=NULL;\n\telse\n\tpre_in_order(pre,l1+1,m-l2+l1,in,l2,m-1,&(*root)->lchild);\n\tif(m==r2)\n\t(*root)->rchild=NULL;\n\telse\n\tpre_in_order(pre,m-l2+l1+1,r1,in,m+1,r2,&(*root)->rchild);\n}\nvoid postorder(BinaryTree *root)\n{\nif(root)\n{\npostorder(root->lchild);\npostorder(root->rchild);\npost[i]=root->data;\ni++;\n}\n}\nint main(int argc, char *argv[])\n{\n\tint pre[40];\n\tint in[40];\n\tint n,i;\n\tBinaryTree *root;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++)\n\tscanf(\"%d\",&pre[i]);\n\tfor(i=0;i<n;i++)\n\tscanf(\"%d\",&in[i]);\n\tpre_in_order(pre,0,n-1,in,0,n-1,&root);\n\tpostorder(root);\n\tfor(i=0;i<n;i++)\n\t{\n\t\tprintf(\"%d\",post[i]);\n\t\tif(i+1==n)\n\t\tprintf(\"\\n\");\n\t\telse\n\t\tprintf(\" \");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 41\n\ntypedef struct node{\n  int l, r;\n}node;\n\nnode c[N];\nint a[N], b[N];\nint cnt=0;\n\nvoid postorder(int root,int n){\n\n        if(c[root].l != -1) postorder(c[root].l, n);\n        if(c[root].r != -1) postorder(c[root].r, n);\n        if(cnt < n - 1) printf(\"%d \", root);\n        else printf(\"%d\\n\", root);\n\n        cnt++;\n\n        return;\n\n}\n\nint reconst(int start,int last,int n){\n  int i, j;\n\n  if(start == last) return b[start];\n  else if(start > last) return -1;\n\n  else {\n    for(i = 1 ; i <= n ; i++){\n      for(j = start ; j <= last ; j++){\n        if(a[i] == b[j]){\n          c[a[i]].l = reconst(start, j - 1, n);\n          c[a[i]].r = reconst(j + 1, last, n);\n          return a[i];\n        }\n      }\n    }\n  }\n}\n\n\nint main(){\n  int n,i, root;\n\n  scanf(\"%d\",&n);\n\n  for(i = 1 ; i <= n ; i++) scanf(\"%d\",&a[i]);\n  for(i = 1 ; i <= n ; i++) scanf(\"%d\",&b[i]);\n  for(i = 1 ; i <= n ; i++){\n    c[i].l = -1;\n    c[i].r = -1;\n  }\n\n  root = reconst(1,n,n);\n\n  postorder(root,n);\n\n  return 0;\n\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid Rec(int,int);\n\nint P[41],I[41],Po[41],n,now=0,s;\n\nint main()\n{\n  int i;\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&P[i]);\n  }\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&I[i]);\n  }\n  Rec(0,n);\n  for(i=0;i<n-1;i++){\n    printf(\"%d \",Po[i]);\n  }\n  printf(\"%d\\n\",Po[i]);\nreturn 0;\n}\n\nvoid Rec(int l,int r)\n{\n  int c,m;\n  if(l>=r)return;\n  c=P[now++];\n  m=Find(c);\n  Rec(l,m);\n  Rec(m+1,r);\n  //printf(\"%d \",c);\n  Po[s++]=c;\n  \n}\n\nint Find(int c)\n{\n  int i;\n  for(i=0;i<n;i++){\n    if(c==I[i])return i;\n  }\n  return 0;\n}\n  "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 40\n\nint pre[N],in[N];\nint n,mark=0;\n\nvoid rec(int l, int r) {\n\tint i;\n\tint c,m;\n\n\tif (l >= r) return;\n\tc = pre[mark++];\n\tfor (i = 0; i < n;i++) {\n\t\tif (in[i] == c) {\n\t\t\tm = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trec(l, m);\n\trec(m+1, r);\n\n\tprintf(\"%d\",c);\n\tif (mark <= n) printf(\" \");\n}\n\nint main() {\n\tint i;\n\n\tscanf(\"%d\",&n);\n\tfor (i = 0;i < n;i++) scanf(\"%d\",&pre[i]);\n\tfor (i = 0;i < n;i++) scanf(\"%d\",&in[i]);\n\n\trec(0,n);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdlib.h>\n#include <stdio.h>\n#define MAX_SIZE 40\n#define SENTINEL -1\ntypedef struct { int left, right; } node;\n\nstatic int build(node *nodes, int *pre, int *in, int left, int right) {\n  int i, m;\n\n  if (right - left == 1) return in[left];\n  if (left == right) return SENTINEL;\n  for (i = m = left; i < right; ++i) {\n    if (in[i] == *pre) {\n      m = i; break;\n    }\n  }\n  nodes[*pre].left = build(nodes, pre + 1, in, left, m);\n  nodes[*pre].right = build(nodes, pre + (m - left + 1), in, m + 1, right);\n  return *pre;\n}\n\nstatic int postorder(const node *nodes, int id, int is_first) {\n  if (id < 1 || id > 40) return is_first; // FIXME: WTF\n  is_first = postorder(nodes, nodes[id].left, is_first);\n  is_first = postorder(nodes, nodes[id].right, is_first);\n  if (!is_first) printf(\" \");\n  printf(\"%d\", id);\n  return 0;\n}\n\nint main(int argc, char **argv) {\n  int n, i, root, pre[MAX_SIZE], in[MAX_SIZE];\n  node nodes[MAX_SIZE];\n\n  scanf(\"%d\", &n);\n  for (i = 0; i < MAX_SIZE; ++i) pre[i] = in[i] = nodes[i].left = nodes[i].right = SENTINEL;\n  for (i = 0; i < n; ++i) scanf(\"%d\", &pre[i]);\n  for (i = 0; i < n; ++i) scanf(\"%d\", &in[i]);\n  root = build(nodes, pre, in, 0, n);\n  postorder(nodes, root, 1); printf(\"\\n\");\n  exit(0);\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 100\n\nint cnt = 0;\nint post_cnt = 0;\nint n;\nint pre[MAX], in[MAX], post[MAX];\n\nint find(int u){\n    int i;\n    for(i = 0; i < n; i++){\n        if(u == in[i]){\n            return i;\n        }\n    }\n\n\n    return -1;\n}\n\nvoid reconstruct(int l, int r){\n    if (l >= r) return;\n    int root = pre[cnt++];\n    int mid = find(root);\n\n    reconstruct(l, mid);\n    reconstruct(mid + 1, r);\n    post[post_cnt++] = root;\n}\n\nint main(){\n    int i;\n    scanf(\"%d\", &n);\n\n    for(i = 0; i < n; i++) scanf(\"%d\", &pre[i]);\n    for(i = 0; i < n; i++) scanf(\"%d\", &in[i]);\n\n    reconstruct(0, n);\n    \n    for(i = 0; i < n; i++){\n        if(!i) printf(\"%d\", post[i]);\n        else printf(\" %d\", post[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// 点数いらないです。\n\n#include <stdio.h>\n\n    int cnt=0;\n    int fir[100],mid[100];\n\n\nvoid solve(int m,int t){\n    int g,i;\n    \n    if(m>t)return;\n    if (m==t){\n        if(mid[m]==fir[0]){\n          printf(\"%d\",mid[m]);\n        }else {\n            printf(\"%d \",mid[m]);\n            cnt++;\n            return;\n        }\n    }\n    \n    \n    g=fir[cnt];\n    cnt++;\n    \n    \n    for(i=m;i<t;i++){\n        if(mid[i]==g)break;\n    }\n    \n    solve(m,i-1);\n    solve(i+1,t);\n    \n    if(g==fir[0])printf(\"%d\",g);\n    else printf(\"%d \",g);\n    \n}\n\n\n\n\n\n\nint main(void){\n    \n    int i;\n    int n;\n\n    \n    scanf(\"%d\",&n);\n    \n    for(i=0;i<n;i++){\n        scanf(\"%d\",&fir[i]);\n       // scanf(\n    }\n    \n    for(i=0;i<n;i++){\n        scanf(\"%d\",&mid[i]);\n    }\n    \n    \n    solve(0,n-1);\n    \n    printf(\"\\n\");\n    \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 50\n\n\n\ntypedef struct cell{\n int id;\n struct cell *right;\n struct cell *left;\n struct cell *parent;\n}cell;\n\n\nvoid postorder(cell *root,cell N[]){\ncell *p=root;\nif(p->left!=NULL){postorder(p->left,N);}\nif(p->right!=NULL){postorder(p->right,N);}\nprintf(\"%d \",p->id);\n \nreturn;\n}\n\n\nint reconstruction(int A[],int B[],int start,int last,cell N[],int n){\nint i,j;\nint a,b;\nint x;\n\n\nif(start!=last){\n\n for(i=0;i<n;i++){\n  for(j=start;j<=last;j++){\n\n   if(B[j]==A[i]){x=A[i];\n    a=reconstruction(A,B,start,j-1,N,n);\n    if(a!=-1){\n\n     N[A[i]].left=&N[a];\n     N[a].parent=&N[A[i]];\n    }\n    else{\n     N[A[i]].left=NULL;\n    }\n\n    b=reconstruction(A,B,j+1,last,N,n);\n    if(b!=-1){\n     N[A[i]].right=&N[b];\n     N[b].parent=&N[A[i]];\n    }\n    else{\n     N[A[i]].right=NULL;\n    }\n\n    return x;\n   }\n\n  }/*for1st*/\n\n }\n\n}/*ifおわり*/\n\n\nif(start==last){\n N[B[start]].right=NULL;\n N[B[start]].left=NULL;\n return B[start];\n}\n\n}\n\n\n\n\nint main(){\nint n,i;\nint A[MAX];\nint B[MAX];\ncell N[MAX];\ncell *root;\nint x;\n\nscanf(\"%d\",&n);\nfor(i=0;i<n;i++)scanf(\"%d\",&A[i]);\nfor(i=0;i<n;i++)scanf(\"%d\",&B[i]);\n\nfor(i=0;i<=n;i++)N[i].id=i;\n\n\nx=reconstruction(A,B,0,n-1,N,n);\n\nroot=&N[x];\n\n\n\npostorder(root,N);\nprintf(\"\\b\");\nprintf(\"\\n\");\n\nreturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct {\n\tint parent;\n\tint left, right;\n}Node;\n\nint linear_search(int* xs, int size, int x)\n{\n\tint i;\n\tfor (i = 0; i < size; i++) {\n\t\tif (xs[i] == x) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nNode tree[50];\n\nint prewalked[50];\nint inwalked[50];\n\nint n;\n\nint reconstruction_tree(int from, int to, int root_pos, int parent)\n{\n\tint i;\n\tint v;\n\n\tfor (i = from; i < to; i++) {\n\t\tif ((v = inwalked[i]) == prewalked[root_pos]) {\n\t\t\ttree[v].parent = parent;\n\n\t\t\ttree[v].left = reconstruction_tree(from, i, root_pos + 1, v);\n\t\t\ttree[v].right = reconstruction_tree(i+1, to, root_pos +  (i - from) + 1, v);\n\n\t\t\treturn v;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nvoid postorder_walk(int p, int root)\n{\n\tif (p > n || p < 0) {\n\t\treturn;\n\t}\n\tpostorder_walk(tree[p].left, 0);\n\tpostorder_walk(tree[p].right, 0);\n\tif (root == 1) {\n\t\tprintf(\"%d\", p);\n\t}\n\telse {\n\t\tprintf(\" %d\", p);\n\t}\n}\n\nint main()\n{\n\tint i;\n\tint root;\n\n\tfor (i = 0; i < 50; i++) {\n\t\ttree[i].parent = -1;\n\t}\n\n\tscanf(\"%d\", &n);\n\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &(prewalked[i]));\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &(inwalked[i]));\n\t}\n\n\troot = reconstruction_tree(0, n, 0, -1);\n\n\tpostorder_walk(root, 1);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 50\n\n\n\ntypedef struct cell{\n int id;\n struct cell *right;\n struct cell *left;\n struct cell *parent;\n}cell;\n\n\nvoid postorder(cell *root,cell N[]){\ncell *p=root;\nif(p->left!=NULL){postorder(p->left,N);}\nif(p->right!=NULL){postorder(p->right,N);}\nprintf(\"%d \",p->id);\n \nreturn;\n}\n\n\nint reconstruction(int A[],int B[],int start,int last,cell N[],int n){\nint i,j;\nint a,b;\nint x;\n\n\nif(start!=last){\n\n for(i=0;i<n;i++){\n  for(j=start;j<=last;j++){\n\n   if(B[j]==A[i]){x=A[i];\n    a=reconstruction(A,B,start,j-1,N,n);\n    if(a!=-1){\n\n     N[A[i]].left=&N[a];\n     N[a].parent=&N[A[i]];\n    }\n    else{\n     N[A[i]].left=NULL;\n    }\n\n    b=reconstruction(A,B,j+1,last,N,n);\n    if(b!=-1){\n     N[A[i]].right=&N[b];\n     N[b].parent=&N[A[i]];\n    }\n    else{\n     N[A[i]].right=NULL;\n    }\n\n    return x;\n   }\n\n  }/*for1st*/\n\n }\n\n}/*ifおわり*/\n\n\nif(start==last){\n N[B[start]].right=NULL;\n N[B[start]].left=NULL;\n return B[start];\n}\n\n}\n\n\n\n\nint main(){\nint n,i;\nint A[MAX];\nint B[MAX];\ncell N[MAX];\ncell *root;\nint x;\n\nscanf(\"%d\",&n);\nfor(i=0;i<n;i++)scanf(\"%d\",&A[i]);\nfor(i=0;i<n;i++)scanf(\"%d\",&B[i]);\n\nfor(i=0;i<=n;i++)N[i].id=i;\n\n\nx=reconstruction(A,B,0,n-1,N,n);\n\nroot=&N[x];\n\n\n\npostorder(root,N);\nprintf(\"\\n\");\n\nreturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 40\n\nint n,pos;\nint A[N],B[N];\n\nvoid solve(int, int);\n\nvoid solve(int l,int r){\n  int x,i;\n\n  x = A[pos];\n  if( l > r ) return;\n  if( l == r ){\n    if( B[l] == A[0] ) printf(\"%d\", B[l]);\n    else printf(\"%d \", B[l]);\n    pos++;\n\n    return;\n  }\n  pos++;\n\n  for( i = l ; i <= r ; i++){\n    if( B[i] == x ) break;\n  }\n  solve( l, i-1);\n  solve( i+1, r);\n\n  if( x == A[0]) printf(\"%d\", x);\n  else printf(\"%d \", x);\n}\n\n\nint main(){\n  int i;\n\n  scanf(\"%d\", &n);\n  for( i = 0 ; i < n ; i++){\n    scanf(\"%d\", &A[i]);\n  }\n  for( i = 0 ; i < n ; i++){\n    scanf(\"%d\", &B[i]);\n  }\n  pos = 0;\n  solve( 0, n-1);\n  printf(\"\\n\");\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 100\n\nint n, pos, c=0;\nint pre[MAX], in[MAX], post[MAX];\n\nvoid rec(int l, int r){\n    if(l>=r){\n        return;\n    }\n    int root=pre[pos++];\n    int m;\n    for(int i=0; i<n; i++){\n        if(root==in[i]){\n            m=i;\n            break;\n        }\n    }\n    rec(l,m);\n    rec(m+1, r);\n    post[c++]=root;\n}\n\n\nint main(void){\n    int i;\n    scanf(\"%d\", &n);\n    for(i=0; i<n; i++){\n        scanf(\"%d\", &pre[i]);\n    }\n    for(i=0; i<n; i++){\n        scanf(\"%d\", &in[i]);\n    }\n\n    rec(0,n);\n    for(i=0; i<n; i++){\n        scanf(\"%d\", &post[i]);\n    }\n    for(i=0; i<n-1; i++){\n        printf(\"%d \", post[i]);\n    }\n    printf(\"%d\\n\", post[i]);\n    \n    return 0;\n\n\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct node {\n  int id;\n  struct node *parent;\n  struct node *child[2];\n};\n\nstruct node *tree;\nint *pre, *in, *post, n;\n\nvoid reconstruction(int root, int l, int r);\nvoid postorder(struct node *p);\n\nint main(int argc, char *argv[])\n{\n  int i, j;\n\n  scanf(\"%d\", &n);\n\n  tree = (struct node *)malloc(sizeof(struct node) * (n + 1));\n  for (i = 0; i <= n; i++) {\n    tree[i].id = i;\n    tree[i].parent = NULL;\n    for (j = 0; j < 2; j++) tree[i].child[j] = NULL;\n  }\n  pre = (int *)malloc(sizeof(int) * n);\n  in = (int *)malloc(sizeof(int) * n);\n  post = (int *)malloc(sizeof(int) * n);\n\n  for (i = 0; i < n; i++) scanf(\"%d\", &pre[i]);\n  for (i = 0; i < n; i++) scanf(\"%d\", &in[i]);\n\n  for (i = 0; i < n; i++) {\n    if (in[i] == pre[0]) break;\n  }\n  reconstruction(i, 0, n - 1);\n\n  for (i = 1; i <= n; i++) {\n    if (tree[i].parent == NULL) break;\n  }\n  postorder(&tree[i]);\n  printf(\"\\n\");\n\n  return 0;\n}\n\nvoid reconstruction(int in_root, int l, int r)\n{\n  int i, j, pre_root, pre_left, pre_right, in_left, in_right;\n\n  if (l == r) return;\n\n  if (in_root != l) {\n    for (i = 0; i < n; i++) {\n      if (pre[i] == in[in_root]) break;\n    }\n    pre_left = i + 1;\n    for (i = 0; i < n; i++) {\n      if (in[i] == pre[pre_left]) break;\n    }\n    in_left = i;\n    tree[in[in_root]].child[0] = &tree[in[in_left]];\n    tree[in[in_left]].parent = &tree[in[in_root]];\n    reconstruction(in_left, l, in_root-1);\n  }\n\n  if (in_root != r) {\n    if (in_root == l) {\n      for (i = 0; i < n; i++) {\n\tif (pre[i] == in[in_root]) break;\n      }\n      pre_right = i + 1;\n      for (i = 0; i < n; i++) {\n\tif (in[i] == pre[pre_right]) break;\n      }\n      in_right = i;\n      tree[in[in_root]].child[1] = &tree[in[in_right]];\n      tree[in[in_right]].parent = &tree[in[in_root]];\n      reconstruction(in_right, in_root+1, r);\n    } else {\n      for (i = 0; i < n; i++) {\n\tif (pre[i] == in[in_root-1]) break;\n      }\n      pre_right= i + 1;\n      for (i = 0; i < n; i++) {\n\tif (in[i] == pre[pre_right]) break;\n      }\n      in_right = i;\n      tree[in[in_root]].child[1] = &tree[in[in_right]];\n      tree[in[in_right]].parent = &tree[in[in_root]];\n      reconstruction(in_right, in_root+1, r);\n    }\n  }  \n}\n\nvoid postorder(struct node *p)\n{\n  if (p->child[0] != NULL) postorder(p->child[0]);\n  if (p->child[1] != NULL) postorder(p->child[1]);\n  if (p->parent != NULL) printf(\"%d \", p->id);\n  else printf(\"%d\", p->id);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 41\nint recont(int,int,int);\nvoid postorder(int,int);\ntypedef struct node{\n\tint L_id;\n\tint R_id;\n}node;\n\nnode c[N];\nint a[N];\nint b[N];\nint cnt=0;\n\nint main(){\n  int n,i;\n  int root;\n\t\n  scanf(\"%d\",&n);\n\t\n  for(i=1;i<=n;i++){\n    scanf(\"%d\",&a[i]);\n  }\n  for(i=1;i<=n;i++){\n    scanf(\"%d\",&b[i]);\n  }\n  for(i=1;i<=n;i++){\n    c[i].L_id=-1;\n    c[i].R_id=-1;\n\t}\t\n  root=reconst(1,n,n);\t\n  postorder(root,n);\n\t\n  return 0;\t\n}\n\nint reconst(int start,int last,int n){\n\t\n  if(start==last)\n    return b[start];\n\t\t\n  else if(start > last)\n    return -1;\n\t\n  else {\n    for(int i=1;i<=n;i++){\n      for(int j=start;j<=last;j++){\n\tif(a[i]==b[j]){\n\t  c[a[i]].L_id=reconst(start,j-1,n);\n\t  c[a[i]].R_id=reconst(j+1,last,n);\n\t  return a[i];\n\t}\n      }\n    }\n  }\n  \n}\nvoid postorder(int root,int n){\n\t\n  if(c[root].L_id!=-1)\n    postorder(c[root].L_id,n);\n\t\n  if(c[root].R_id!=-1)\n    postorder(c[root].R_id,n);\n  \n  if(cnt<n-1)\n    printf(\"%d \",root);\n  else \n    printf(\"%d\\n\",root);\t\n  cnt++;\n  return;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 10000\n\nint n, pos, k;\nint pre[MAX], in[MAX], post[MAX];\n\nint find(int u){\n  int i;\n\n  for(i = 0; i < n; i++){\n    if(u == in[i])  return i;\n  }\n  return 0;\n}\n\nvoid rec(int l, int r){\n  int root;\n  if(l >= r)  return;\n  root = pre[pos++];\n  rec(l, find(root));\n  rec(find(root) + 1, r);\n  post[k++] = root;\n}\n\nvoid solve(){\n  int i;\n  pos = 0;\n  rec(0, n);\n\n  for(i = 0; i < n; i++){\n    if(i) printf(\" \");\n    printf(\"%d\", post[i]);\n  }\n  printf(\"\\n\");\n}\n\nint main(void){\n  int i;\n\n  scanf(\"%d\", &n);\n\n  for(i = 0; i < n; i++){\n    scanf(\"%d\", &pre[i]);\n  }\n\n  for(i = 0; i < n; i++){\n    scanf(\"%d\", &in[i]);\n  }\nsolve();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n  \nint preOrder[40],inOrder[40];\n \nvoid solve(int x,int y){\n  int i;\n  static int p=0;\n  if(x>y) return;\n  if(x==y){\n    if(inOrder[x]==preOrder[0]) printf(\"%d\",inOrder[x]);  \n    else printf(\"%d \",inOrder[x]);\n    p++;\n    return;\n  }\n  int x=preOrder[p];\n  p++;\n  for(i=x;i<=y;i++){\n    if(inOrder[i]==x) break;\n  }\n  solve(x,i-1);\n  solve(i+1,y);\n  if(x==preOrder[0]) printf(\"%d\",x);\n  else printf(\"%d \",x);\n}\n  \nint main(){\n  int i,n;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++) scanf(\"%d\",&preOrder[i]);\n  for(i=0;i<n;i++) scanf(\"%d\",&inOrder[i]);\n  solve(0,n-1);\n  printf(\"\\n\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define mymalloc(p,n) {p = malloc((n)*sizeof(*p));if ((p)==NULL) {printf(\"not enough memory?\\n\"); exit(1);};}\n\nint divide(int root,int *A,int *B,int p,int q,int flag){\n\tint i;\n\tif(q-p==0){\n\t\tprintf(\"%d \",B[q]);\n\t\treturn root;\n\t}\n\tfor(i=p;i<=q;i++){\n\t\tif(B[i]==A[root]){\n\t\t\tif(i>p){root=divide(root+1,A,B,p,i-1,1);}\n\t\t\tif(i<q){root=divide(root+1,A,B,i+1,q,1);}\n\t\t\tif(flag==0){\n\t\t\t\tprintf(\"%d\\n\",B[i]);\n\t\t\t}else{\n\t\t\t\tprintf(\"%d \",B[i]);\n\t\t\t}\n\t\t\treturn root;\n\t\t}\n\t}\n}\n\nmain(){\n\tint i,n;\n\tint *A,*B;\n\tscanf(\"%d\",&n);\n\tmymalloc(A,n);\n\tmymalloc(B,n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\" %d\",&A[i]);\n\t}\n\tfor(i=0;i<n;i++){\n\t\tscanf(\" %d\",&B[i]);\n\t}\n\tdivide(0,A,B,0,n-1,0);\n\tfree(A);free(B);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nstruct BinaryTree\n{\n\tint data;\n\tstruct BinaryTree *lchild,*rchild;\n};\nint post[40],i;\nvoid pre_in_order(int *pre,int l1,int r1,int *in,int l2,int r2,struct BinaryTree **root)\n{\n\tint m;\n\ti=0;\n\t*root=(struct BinaryTree *)malloc(sizeof(struct BinaryTree));\n\t(*root)->data=pre[l1];\n\tm=l2;\n\twhile(pre[l1]!=in[m])\n\tm++;\n\tif(m==l2)\n\t(*root)->lchild=NULL;\n\telse\n\tpre_in_order(pre,l1+1,m-l2+l1,in,l2,m-1,&(*root)->lchild);\n\tif(m==r2)\n\t(*root)->rchild=NULL;\n\telse\n\tpre_in_order(pre,m-l2+l1+1,r1,in,m+1,r2,&(*root)->rchild);\n}\nvoid postorder(struct BinaryTree *root)\n{\nif(root)\n{\npostorder(root->lchild);\npostorder(root->rchild);\npost[i]=root->data;\ni++;\n}\n}\nint main(int argc, char *argv[])\n{\n\tint pre[40];\n\tint in[40];\n\tint n,i;\n\tstruct BinaryTree *root;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++)\n\tscanf(\"%d\",&pre[i]);\n\tfor(i=0;i<n;i++)\n\tscanf(\"%d\",&in[i]);\n\tpre_in_order(pre,0,n-1,in,0,n-1,&root);\n\tpostorder(root);\n\tfor(i=0;i<n;i++)\n\t{\n\t\tprintf(\"%d\",post[i]);\n\t\tif(i+1==n)\n\t\tprintf(\"\\n\");\n\t\telse\n\t\tprintf(\" \");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n \nvoid Rec(int,int);\n \nint P[41],I[41],Po[41],n,now=0,s;\n \nint main()\n{\n  int i;\n \n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&P[i]);\n  }\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&I[i]);\n  }\n  Rec(0,n);\n  for(i=0;i<n-1;i++){\n    printf(\"%d \",Po[i]);\n  }\n  printf(\"%d\\n\",Po[i]);\nreturn 0;\n}\n \nvoid Rec(int l,int r)\n{\n  int c,m;\n  if(l>=r)return;\n  c=P[now++];\n  m=Find(c);\n  Rec(l,m);\n  Rec(m+1,r);\n  //printf(\"%d \",c);\n  Po[s++]=c;\n   \n}\n \nint Find(int c)\n{\n  int i;\n  for(i=0;i<n;i++){\n    if(c==I[i])return i;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 40\n\nint n,pos=0;\nint cout = 0;\nint Pre[MAX] ,In[MAX] ,final[MAX];\n\nint distance(int first,int key){\n  int i,count=0;\n\n  for(i = first; i < MAX;i++){\n    if(In[i] != key)\n      count++;\n    else break;\n  }\n\n  return count;\n}\n\n\nint solve(int l,int r){\n\n  int root,d;\n  if(l-r >= 0)return -1;\n\n  root=Pre[pos];\n  pos++;\n\n  d=distance(0,root);\n  if(d > n)return -1;\n\n  solve(l, d);\n  solve(d+1,r);\n\n  final[cout++]=root;\n  return 0;\n}\n\nint main(){\n  int m,i;\n  scanf(\"%d\",&n);\n\n  for(i = 0;i < n;i++){\n    scanf(\"%d\",&m);\n    Pre[i]=m;\n  }\n\n  for(i = 0;i < n;i++){\n      scanf(\"%d\",&m);\n      In[i]=m;\n  }\n  solve(0,n);\n\n  printf(\"%d\",final[0]);\n\n  for(i = 1;i < n;i++)\n    printf(\"%d\",final[i]);\n  printf(\"\\n\");\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 102\nint m=0,n,t=0;\nint pre[MAX],in[MAX];\nint find(int c,int n,int in[]){\n\tint i;\n\tfor(i=0;i<n;i++){\n\t\tif(in[i]==c)\n\t\treturn i;\n\t}\n}\nvoid reconstruction(int l,int r){\n\tif(l>=r)\n\treturn;\n\tint c=pre[m];\n\tm++;\n\tint mid=find(c,n,in);\n\treconstruction(l,mid);\n\treconstruction(mid+1,r);\n\tif(t)\n\tprintf(\" \");\n\tprintf(\"%d\",c);\n\tt++;\n}\nint main(){\n\tint i,j;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++)\n\tscanf(\"%d\",&pre[i]);\n\tfor(i=0;i<n;i++)\n\tscanf(\"%d\",&in[i]);//输入\n\treconstruction(0,n);\n\tprintf(\"\\n\");\n\treturn 0; \n} \n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 41\n \ntypedef struct node{\n  int l, r;\n}node;\n \nnode c[N];\nint a[N], b[N];\nint cnt=0;\n \nvoid postorder(int root,int n){\n \n        if(c[root].l != -1) postorder(c[root].l, n);\n        if(c[root].r != -1) postorder(c[root].r, n);\n        if(cnt < n - 1) printf(\"%d \", root);\n        else printf(\"%d\\n\", root);\n \n        cnt++;\n \n        return;\n \n}\n \nint reconst(int start,int last,int n){\n  int i, j;\n \n  if(start == last) return b[start];\n  else if(start > last) return -1;\n \n  else {\n    for(i = 1 ; i <= n ; i++){\n      for(j = start ; j <= last ; j++){\n        if(a[i] == b[j]){\n          c[a[i]].l = reconst(start, j - 1, n);\n          c[a[i]].r = reconst(j + 1, last, n);\n          return a[i];\n        }\n      }\n    }\n  }\n}\n \n \nint main(){\n  int n,i, root;\n \n  scanf(\"%d\",&n);\n \n  for(i = 1 ; i <= n ; i++) scanf(\"%d\",&a[i]);\n  for(i = 1 ; i <= n ; i++) scanf(\"%d\",&b[i]);\n  for(i = 1 ; i <= n ; i++){\n    c[i].l = -1;\n    c[i].r = -1;\n  }\n \n  root = reconst(1,n,n);\n \n  postorder(root,n);\n \n  return 0;\n \n}\n\n"
  },
  {
    "language": "C",
    "code": "int preorder[40],inorder[40];\nvoid recover(int fp,int lp,int fi,int li){\n    int root=fi;\n    for(;root<li;root++)if(preorder[fp]==inorder[root])break;\n    if(fi<root)recover(fp+1,fp+(root-fi)+1,fi,root);\n    if(root<li-1)recover(fp+(root-fi)+1,lp,root+1,li);\n    printf(inorder[root]==preorder[0]?\"%d\\n\":\"%d \",inorder[root]);\n}\nmain(){\n    int n,i;\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)scanf(\"%d\",preorder+i);\n    for(i=0;i<n;i++)scanf(\"%d\",inorder+i);\n    recover(0,n,0,n);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define MAX 100\n\n\nint n,c,d=0;\nint pre[1000],in[1000],post[1000];\n\nint find(int x);\nvoid rec(int l,int r);\n\nint main(void){\n\tint i;\n\tscanf(\"%d\",&n);\n\t\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&pre[i]);\n\t}\n\t\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&in[i]);\n\t}\n\t\n\trec(0,n);\n\t\n\tfor(i=0;i<n;i++){\n\t\tif(i!=n-1){\n\t\t\tprintf(\"%d \",post[i]);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%d\\n\",post[i]);\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint find(int x){\n\tint i;\n\tfor(i=0;i<n;i++){\n\t\tif(x==in[i]){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid rec(int l,int r){\n\tint x,y;\n\tif(l>=r){\n\t\treturn;\n\t}\n\t\n\tx=pre[d++];\n\ty=find(x);\n\trec(l,y);\n\trec(y+1,r);\n\tpost[c++]=x;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define POINT 41\n\nint P[POINT], I[POINT], Po[POINT];\nint n, now = 0, s = 0;\n\nvoid Rec(int, int);\n\nvoid Rec(int l, int r) {\n    int c,m;\n    \n    if(l >= r) {\n        return;\n    }\n    c = P[now++];\n    m = Find(c);\n    Rec(l, m);\n    Rec(m + 1, r);\n    Po[s++] = c;\n}\n\nint Find(int c) {\n    int i;\n    \n    //接点番号が一致したIndexを返す\n    for(i = 0 ; i < n ; i++) {\n        if(c == I[i]) {\n            return i;\n        }\n    }\n    return 0;\n}\n\nint main(void){\n    int i;\n    \n    scanf(\"%d\",&n);\n    \n    //preoder include\n    for(i = 0 ; i < n ; i++) {\n        scanf(\"%d\",&P[i]);\n    }\n    \n    //inoder include\n    for(i = 0 ; i < n ; i++) {\n        scanf(\"%d\",&I[i]);\n    }\n    \n    Rec(0,n);\n    \n    for(i = 0 ; i < n-1 ; i++) {\n        printf(\"%d \",Po[i]);\n    }\n    printf(\"%d\\n\", Po[n-1]);\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 10000\n#define NIL -1\n\ntypedef struct{\n  int parent,left,right;\n}Node;\n\nNode T[M];\nint n,D[M], H[M];\n\nvoid setDepth(int a,int b){\n  if(a == NIL)return;\n  D[a] = b;\n  setDepth(T[a].left,b+1);\n  setDepth(T[a].right,b+1);\n}\n\nint setHeight(int a){\n  int h1 = 0;\n  int h2 = 0;\n  if(T[a].left != NIL)\n    h1 = setHeight(T[a].left)+1;\n  if(T[a].right != NIL)\n    h2 = setHeight(T[a].right)+1;\n  if(h1>h2)\n    {\n      H[a]=h1;\n    }\n  else\n    {\n      H[a]= h2;\n    }\n  return H[a];\n}\nint gSibling(int s)\n{\n  if(T[s].parent == NIL)return 0;\n  if(T[T[s].parent].left != s && T[T[s].parent].left != NIL)\n    return T[T[s].parent].left;\n  if(T[T[s].parent].right != s && T[T[s].parent].right != NIL)\n    return T[T[s].parent].right;\n\n  return NIL;\n}\nint main()\n{\n  int i,j,v,l,r,deg,root = 0;\n\n  scanf(\"%d\",&n);\n\n  for(i=0;i<n;i++)\n    {\n      T[i].parent = NIL;\n    }\n  for(i = 0;i<n;i++)\n    {\n      scanf(\"%d %d %d\",&v,&l,&r);\n      T[v].left = l;\n      T[v].right = r;\n      if(l != NIL)T[l].parent = v;\n      if(r != NIL)T[r].parent = v;\n    }\n\n  for(i = 0;i<n;i++)\n    {\n      if(T[i].parent == NIL)root = i;\n    }\n\n  setDepth(root, 0);\n  setHeight(root);\n\n  for(i = 0;i<n;i++)\n    {\n      printf(\"node %d: \", i);\n      printf(\"parent = %d, \", T[i].parent);\n      printf(\"sibling = %d, \",gSibling(i));\n      deg = 0;\n      if(T[i].left != NIL)deg++;\n      if(T[i].right != NIL)deg++;\n      printf(\"degree = %d, \",deg);\n      printf(\"depth = %d, \",D[i]);\n      printf(\"height = %d, \",H[i]);\n\n      if(T[i].parent == NIL){\n\tprintf(\"root\\n\");\n      }\n      else if(T[i].left == NIL && T[i].right == NIL)\n\t{\n\t  printf(\"lesf\\n\");\n\t}\n      else \n\t{\n\t  printf(\"internal node\\n\");\n\t}\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 10000\n#define NIL -1\n\ntypedef struct{\n  int parent,left,right;\n}Node;\n\nNode T[M];\nint n,D[M], H[M];\n\nvoid setDepth(int a,int b){\n  if(a == NIL)return;\n  D[a] = b;\n  setDepth(T[a].left,b+1);\n  setDepth(T[a].right,b+1);\n}\n\nint setHeight(int a){\n  int h1 = 0;\n  int h2 = 0;\n  if(T[a].left != NIL)\n    h1 = setHeight(T[a].left)+1;\n  if(T[a].right != NIL)\n    h2 = setHeight(T[a].right)+1;\n  if(h1>h2)\n    {\n      H[a]=h1;\n    }\n  else\n    {\n      H[a]= h2;\n    }\n  return H[a];\n}\nint gSibling(int s)\n{\n  if(T[s].parent == NIL)return 0;\n  if(T[T[s].parent].left != s && T[T[s].parent].left != NIL)\n    return T[T[s].parent].left;\n  if(T[T[s].parent].right != s && T[T[s].parent].right != NIL)\n    return T[T[s].parent].right;\n\n  return NIL;\n}\nint main()\n{\n  int i,j,v,l,r,deg,root = 0;\n\n  scanf(\"%d\",&n);\n\n  for(i=0;i<n;i++)\n    {\n      T[i].parent = NIL;\n    }\n  for(i = 0;i<n;i++)\n    {\n      scanf(\"%d %d %d\",&v,&l,&r);\n      T[v].left = l;\n      T[v].right = r;\n      if(l != NIL)T[l].parent = v;\n      if(r != NIL)T[r].parent = v;\n    }\n\n  for(i = 0;i<n;i++)\n    {\n      if(T[i].parent == NIL)root = i;\n    }\n\n  setDepth(root, 0);\n  setHeight(root);\n\n  for(i = 0;i<n;i++)\n    {\n      printf(\"node %d\", i);\n      printf(\"parent = %d, \", T[i].parent);\n      printf(\"sibling = %d, \",gSibling(i));\n      deg = 0;\n      if(T[i].left != NIL)deg++;\n      if(T[i].right != NIL)deg++;\n      printf(\"degree = %d, \",deg);\n      printf(\"depth = %d, \",D[i]);\n      printf(\"height = %d, \",H[i]);\n\n      if(T[i].parent == NIL){\n\tprintf(\"root\\n\");\n      }\n      else if(T[i].left == NIL && T[i].right == NIL)\n\t{\n\t  printf(\"lesf\\n\");\n\t}\n      else \n\t{\n\t  printf(\"internal node\\n\");\n\t}\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\n//============================================================================\n#define pred(x) ((x)-1)\n#define succ(x) ((x)+1)\n//============================================================================\nstruct Node{\n    short  id;\n    struct Node *parent;\n    struct Node *left, *right;\n};\ntypedef struct Node TNode;\n//============================================================================\nstruct Chain{\n    struct Chain *prev;\n    TNode *node;\n    struct Chain *next;\n};\ntypedef struct Chain TChain;\nTChain *RootChain;\n//============================================================================\n//============================================================================\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nTChain *ChainAlloc(void)\n{\n    TChain *ptr;\n    ptr=malloc(sizeof(TChain));\n    if (ptr==NULL)\n        exit(1);\n    memset(ptr, 0, sizeof(TChain));\n    return ptr;\n}\n//----------------------------------------------------------------------------\nvoid inschain(TChain *chn, TNode *node)\n{\n    while(chn->next!=NULL)\n        chn=chn->next;\n    chn->next=ChainAlloc();\n    chn->next->node=node;\n    chn->next->prev=chn;\n}\n//----------------------------------------------------------------------------\nvoid delchain(TChain *chn)\n{\n    if (chn->prev){\n        chn->prev->next=chn->next;\n    }\n    if (chn->next){\n        chn->next->prev=chn->prev;\n    }\n    free(chn);\n}\n//----------------------------------------------------------------------------\nTChain *searchchain(TChain *chn, short id)\n{\n    do{\n        if (chn->node->id==id)\n            return chn;\n        if (chn->node->left && chn->node->left->id==id)\n            return chn;\n        if (chn->node->right && chn->node->right->id==id)\n            return chn;\n        chn=chn->next;\n    }while(chn!=NULL);\n    return NULL;\n}\n//----------------------------------------------------------------------------\nvoid pushnode(TNode *node)\n{\n    if (RootChain==NULL){\n        RootChain=ChainAlloc();\n        RootChain->node=node;\n    }else{\n        inschain(RootChain, node);\n    }\n}\n//----------------------------------------------------------------------------\nTNode *popnode(short id)\n{\n    TChain *chn; TNode *node;\n\n    node=NULL;\n    chn=searchchain(RootChain, id);\n    if (chn){\n        if (chn->node->id==id)\n            node=chn->node;\n        else\n        if (chn->node->left && chn->node->left->id==id)\n            node=chn->node->left;\n        else\n        if (chn->node->right && chn->node->right->id==id)\n            node=chn->node->right;\n        if (node==chn->node)\n            delchain(chn);\n    }\n    return node;\n}\n//----------------------------------------------------------------------------\nTNode *nodealloc(void)\n{\n    TNode *node;\n    node=malloc(sizeof(TNode));\n    if (node==NULL){\n        fprintf(stderr, \"not enough memry\\n\");\n        exit(1);\n    }\n    memset(node, 0, sizeof(TNode));\n    return node;\n}\n//----------------------------------------------------------------------------\nTNode *existid(TNode *node, short id)\n{\n    TNode *nd;\n\n    if (node==NULL || node->id==id)\n        return node;\n    if ((nd=existid(node->left, id))!=NULL)\n        return nd;\n    nd=existid(node->right, id);\n    return nd;\n}\n//----------------------------------------------------------------------------\nvoid putnode(TNode **root, TNode **node, TNode *parent, short id)\n{\n    TNode *nd;\n\n    if ((nd=existid(*root, id))==NULL)\n        nd=popnode(id);\n    if (nd==NULL){\n        *node=nodealloc();\n    }else{\n        *node=nd;\n        //nd->parent=*node;\n        if (*root==nd){\n            *root=parent;\n            while((*root)->parent!=NULL)\n                *root=(*root)->parent;\n        }\n    }\n    (*node)->id=id;\n    (*node)->parent=parent;\n}\n//----------------------------------------------------------------------------\nTNode *rootnode(TNode *node)\n{\n    while(node->parent)\n        node=node->parent;\n    return node;\n}\n//----------------------------------------------------------------------------\nvoid getnode(FILE *file, TNode **node)\n{\n    long id,left,right; TNode *ser;\n\n    fscanf(file, \"%ld\", &id);\n    fscanf(file, \"%ld\", &left);\n    fscanf(file, \"%ld\", &right);\n    if (*node==NULL){\n        *node=nodealloc();\n        ser=*node;\n        pushnode(*node);\n    }else\n        ser=existid(*node, id);\n    if (ser==NULL){\n        ser=popnode(id);\n        if (ser==NULL)\n            ser=nodealloc();\n    }\n    if (*node!=rootnode(ser))\n    pushnode(ser);\n    ser->id=id;\n    if (0<=left)\n        putnode(node, &ser->left, ser, left);\n    if (0<=right)\n        putnode(node, &ser->right, ser, right);\n}\n//----------------------------------------------------------------------------\nshort depth(TNode *node)\n{\n    short n;\n\n    for (n=0; node->parent!=NULL; n++)\n        node=node->parent;\n    return n;\n}\n//----------------------------------------------------------------------------\nshort height(TNode *node)\n{\n    short l,r;\n\n    if (node==NULL)\n        return -1;\n    l=succ(height(node->left));\n    r=succ(height(node->right));\n    return (r<l)?l:r;\n}\n//----------------------------------------------------------------------------\nchar *root=\"root\";\nchar *internalroot=\"internal node\";\nchar *leaf=\"leaf\";\nchar *nodetype(TNode *node)\n{\n    if (node->parent==NULL)\n        return root;\n    if (node->left!=NULL || node->right!=NULL)\n        return internalroot;\n    return leaf;\n}\n//----------------------------------------------------------------------------\nvoid output(TNode *root, long n)\n{\n    short i,j,cnt,id,sib,deg; TNode *node;\n\n    for (i=cnt=0; cnt<n; i++){\n        node=existid(root, i);\n        if (node!=NULL){\n            cnt++;\n            sib=-1;\n            if (node->parent!=NULL && node->parent->left!=NULL && node->parent->right!=NULL){\n                if (node->parent->left==node)\n                    sib=node->parent->right->id;\n                else\n                    sib=node->parent->left->id;\n            }\n            deg=(node->left==NULL)?0:1;\n            deg+=(node->right==NULL)?0:1;\n            id=(node->parent==NULL)?-1:node->parent->id;\n            printf(\"node %d: \", node->id);\n            printf(\"parent = %d, \", id);\n            printf(\"sibling = %d, \", sib);\n            printf(\"degree = %d, \", deg);\n            printf(\"depth = %d, \", depth(node));\n            printf(\"height = %d, \", height(node));\n            printf(\"%s\\n\", nodetype(node));\n        }\n    }\n}\n//----------------------------------------------------------------------------\nvoid preorder(TNode *node)\n{\n    if (node==NULL)\n        return;\n    printf(\" %d\", node->id);\n    preorder(node->left);\n    preorder(node->right);\n}\n//----------------------------------------------------------------------------\nvoid inorder(TNode *node)\n{\n    if (node==NULL)\n        return;\n    inorder(node->left);\n    printf(\" %d\", node->id);\n    inorder(node->right);\n    //printf(\" %d\", node->id);\n}\n//----------------------------------------------------------------------------\nvoid postorder(TNode *node)\n{\n    static short space=0;\n\n    if (node==NULL)\n        return;\n    postorder(node->left);\n    postorder(node->right);\n    if (space)\n        printf(\" \");\n    printf(\"%d\", node->id);\n    space=1;\n}\n//----------------------------------------------------------------------------\nvoid treewalk(TNode *node, short n)\n{\n    printf(\"Preorder\\n\");\n    preorder(node);\n    printf(\"\\nInorder\\n\");\n    inorder(node);\n    printf(\"\\nPostorder\\n\");\n    postorder(node);\n    printf(\"\\n\");\n}\n//----------------------------------------------------------------------------\nvoid reconstruct(TNode *node, short *pre, short *ino, short n)\n{\n    short i;\n\n    node->id = *pre;\n    if (n==1)\n        return;\n    for (i=0; ino[i]!=*pre; i++);\n    if (i){\n        node->left=nodealloc();\n        node->left->parent=node;\n        reconstruct(node->left, succ(pre), ino, i);\n    }\n    if (i<n){\n        node->right=nodealloc();\n        node->right->parent=node;\n        reconstruct(node->right, &pre[succ(i)], &ino[succ(i)], pred(n-i));\n    }\n}\n//----------------------------------------------------------------------------\nvoid inputorder(FILE *file)\n{\n    long i,n,m; TNode *root; char buffer[20];\n\n    RootChain=NULL;\n    fgets(buffer, sizeof(buffer)-1, file);\n    sscanf(buffer, \"%ld\", &n);\n    for (i=0, root=NULL; i<n; i++){\n        getnode(file, &root);\n        //printf(\"%08X\\n\", root);\n    }\n    while(root->parent)\n        root=root->parent;\n    //output(root, n);\n    treewalk(root, n);\n}\n//----------------------------------------------------------------------------\n#define MAX_N 40\nvoid input(FILE *file)\n{\n    long i,n; TNode *root; char buffer[20]; short preorder[MAX_N], inorder[MAX_N];\n\n    memset(preorder, 0, sizeof(preorder));\n    memset(inorder, 0, sizeof(inorder));\n    fgets(buffer, sizeof(buffer)-1, file);\n    sscanf(buffer, \"%ld\", &n);\n    root=nodealloc();\n    for (i=0; i<n; i++){\n        fscanf(file, \"%hd\", &preorder[i]);\n    }\n    for (i=0; i<n; i++){\n        fscanf(file, \"%hd\", &inorder[i]);\n    }\n    reconstruct(root, preorder, inorder, n);\n    postorder(root);\n    printf(\"\\n\");\n}\n//============================================================================\n#ifndef DESKTOP\nint main()\n{\n    input(stdin);\n    return 0;\n}\n#endif"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 100\n\nint cnt = 0;\nint post_cnt = 0;\nint n;\nint pre[MAX], in[MAX], post[MAX];\n\nint find(int u){\n    int i;\n    for(i = 0; i < n; i++){\n        if(u == in[i]){\n            return i;\n        }\n    }\n\n\n    return -1;\n}\n\nvoid reconstruct(int l, int r){\n    if (l >= r) return;\n    int root = pre[cnt++];\n    int mid = find(root);\n\n    reconstruct(l, mid);\n    reconstruct(mid + 1, r);\n    post[post_cnt++] = root;\n}\n\nint main(){\n    int i;\n    scanf(\"%d\", &n);\n\n    for(i = 0; i < n; i++) scanf(\"%d\", &pre[i]);\n    for(i = 0; i < n; i++) scanf(\"%d\", &in[i]);\n\n    reconstruct(0, n);\n    \n    for(i = 0; i < n; i++){\n        if(i != n) printf(\"%d \", &post[i]);\n        else printf(\"%d\", &post[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 40\nint distance(int start,int key);\nint solve(int l,int r);\n\nint n,pos=0,cout = 0;\nint P[MAX],I[MAX],A[MAX];\n \nint distance(int start,int key){\n  int i,count=0;\n  for(i=start;i<MAX;i++){\n    if(I[i]!=key)\n      count++;\n    else break;\n  }\n  return count;\n}\n   \nint solve(int l,int r){\n  int root,d;\n  if(l-r>=0)return -1;\n  root=P[pos];\n  pos++;\n  d=distance(0,root);\n  if(d>n)return -1;\n  solve(l, d);\n  solve(d+1, r);\n  A[cout++]=root;\n  return 0;\n}\n \nint main(){\n  int k,i;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&k);\n    P[i]=k;\n  }\n  for(i=0;i<n;i++){\n      scanf(\"%d\",&k);\n      I[i]=k;\n  }\n  solve(0,n);\n\n  for(i=0;i<n;i++){\n    if(i<n-1)printf(\"%d \",A[i]);\n    else printf(\"%d\\n\",A[i]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX 40\n \nstruct node\n{\n    int p;\n    int l, r;\n} typedef node;\n \nint P[MAX];\nint I[MAX];\nnode N[MAX];\n \nint CreateTree(int parent, int n, int head_P, int head_I){\n    int root;\n    int root_P, root_I;\n    int n_l, n_r;\n     \n    root = P[head_P];\n     \n    if(n == 0) return -1;\n \n    root_P = head_P;\n    root_I = Position(n, head_I, I, root);\n     \n    n_l = root_I - head_I;\n    n_r = n - n_l - 1;\n     \n    N[root].p = parent;\n    N[root].l = CreateTree(root, n_l, root_P + 1, head_I);\n    N[root].r = CreateTree(root, n_r, root_P + 1 + n_l, root_I + 1);\n     \n    return root;\n}\n \nint Position(int n, int h, int A[], int s){\n    int i;\n     \n    for(i = h; i < h + n; i++){\n        if(A[i] == s) return i;\n    }\n    return -1;\n}\n \nvoid Postorder(int id, int n){\n    static int count = 0;\n     \n    if(id==-1) return;\n     \n    Postorder(N[id].l, n);\n    Postorder(N[id].r, n);\n     \n    count++;\n    if(count != n) printf(\"%d \", id);\n    else printf(\"%d\\n\", id);\n}\n\nint main(){\n    int i;\n    int n;\n    int root;\n     \n    scanf(\"%d\", &n);\n    for(i = 0; i < n; i++){\n        scanf(\"%d\", &P[i]);\n    }\n    for(i = 0; i < n; i++){\n        scanf(\"%d\", &I[i]);\n    }\n     \n    root = CreateTree(-1, n, 0, 0);\n     \n    Postorder(root, n);\n     \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// 点数いらないです。\n\n#include <stdio.h>\n\n    int cnt=0;\n    int fir[100],mid[100];\n\n\nvoid solve(int m,int t){\n    int g,i;\n    \n    \n    if (m==t){\n        if(mid[m]==fir[0]){\n          printf(\"%d\",mid[m]);\n        }else {\n            printf(\"%d \",mid[m]);\n            cnt++;\n            return;\n        }\n    }\n    \n    \n    g=fir[cnt];\n    cnt++;\n    \n    \n    for(i=m;i<t;i++){\n        if(mid[i]==g)break;\n    }\n    \n    solve(m,i-1);\n    solve(i+1,t);\n    \n    if(g==fir[0])printf(\"%d\",g);\n    else printf(\"%d \",g);\n    \n}\n\n\n\n\n\n\nint main(void){\n    \n    int i;\n    int n;\n\n    \n    scanf(\"%d\",&n);\n    \n    for(i=0;i<n;i++){\n        scanf(\"%d\",&fir[i]);\n       // scanf(\n    }\n    \n    for(i=0;i<n;i++){\n        scanf(\"%d\",&mid[i]);\n    }\n    \n    \n    solve(0,n-1);\n    \n    printf(\"\\n\");\n    \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "int preorder[40],inorder[40];\nvoid recover(int fp,int lp,int fi,int li){\n\tint root=fi;\n\tfor(;root<li;root++)if(preorder[fp]==inorder[root])break;\n\tif(fi<root)recover(fp+1,fp+(root-fi)+1,fi,root);\n\tif(root<li-1)recover(fp+(root-fi)+1,lp,root+1,li);\n\tprintf(inorder[root]==preorder[0]?\"%d\\n\":\"%d \",inorder[root]);\n}\nmain(){\n\tint n,i;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++)scanf(\"%d\",preorder+i);\n\tfor(i=0;i<n;i++)scanf(\"%d\",inorder+i);\n\trecover(0,n,0,n);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 100\n\n\n int n,pos,coun=0;\n int pre[N],in[N],post[N];\n \n int find(int in[n],int root);{\n     int i;\n     for(i=0;i<n;i++){\n            if(in[i]==root)return i;\n            }\n     return in[n-1];\n     }\n\n void rec(int l,int r){\n      int root,m;\n      if(l>=r)return;\n      root=pre[pos++];\n      m=find(in,root);\n      rec(l,m);\n      rec(m+l,r);\n      post[count++]=root;\n      }\n\n void solve(){\n      int i;\n      post=0;\n      rec(0,n);\n      for(i=0;i<n;i++){\n              if(i)printf(\" \");\n              printf(\"%d\",post[i]);\n              }\n      printf(\"\\n\");\n      }\n\n int main(){\n      int i,k;\n      scanf(\"%d\",&n);\n\n      for(i=0;i<n;i++){\n              scanf(\"%d\",&k);\n              pre[i]=k;\n              }\n      for(i=0;i<n;i++){\n              scanf(\"%d\",&k);\n              in[i]=k;\n              }\n      solve();\n      return 0;\n      }\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX 40\nint n, post[MAX], idx;\n\nvoid solve(int pre[], int in[], int N){\n  int i, p;\n  for(i = 0 ; i < N ; i++){\n    if(in[i] == pre[0]){\n      p = i;\n      break;\n    }\n  }\n  if(p != 0){\n    solve(pre+1, in, p);\n  }\n  if(p != N-1){\n    solve(pre+p+1, in+p+1, N-p-1);\n  }\n  post[idx++] = pre[0]; \n}\n \nint main(){\n  int pre[MAX], in[MAX], i;\n  scanf(\"%d\",&n);\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\",pre+i);\n  }\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\",in+i); \n  }\n  solve(pre, in, n);\n  for(i = 0 ; i < n ; i++){\n    printf(\"%d%c\",post[i],(i != n-1 ? ' ':'\\n'));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint pre[100005],in[100005],post[100005];\nint n,x=0,y=0;\n\nint f(int a){\n  int i;\n  for(i=0;i<n;i++){\n    if(a==in[i])return i;\n  }\n  return 0;\n}\n\nvoid R(int l, int r){\n  int a,m;\n  if(l>=r) return;\n  a=pre[x];\n  x++;\n  m=f(a);\n  R(l,m);\n  R(m+1,r);\n  post[y]=a;\n  y++;\n}\n\nint main(){\n  int i;\n  scanf(\"%d\",&n);\n\n  for(i=0;i<n;i++) scanf(\"%d%\",&pre[i]);\n  for(i=0;i<n;i++) scanf(\"%d%\",&in[i]);\n  R(0,n);\n  for(i=0;i<n;i++){\n    if(i!=0)printf(\" \");\n    printf(\"%d\",post[i]);\n  }\n  printf(\"\\n\");\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n#define MAX_N 40\n\nint n;\nint preorder[MAX_N];\nint inorder[MAX_N];\nint post[MAX_N];\nint n_post;\nint pos;\n\nint\ndistance(int x)\n{\n\tint i;\n\n\tfor (i = 0; i < n; ++i)\n\t{\n\t\tif (inorder[i] == x)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}\n\nvoid\nrec(int l, int r)\n{\n\tif (l >= r)\n\t\treturn;\n\n\tint root = preorder[pos++];\n\tint m = distance(root);\n\trec(l, m);\n\trec(m + 1, r);\n\tpost[n_post++] = root;\n}\n\nvoid\nsolve()\n{\n\tint i;\n\n\tpos = 0;\n\trec(0, n);\n\tfor (i = 0; i < n_post; ++i)\n\t\tprintf(\"%d%c\", post[i], (i != n_post - 1) ? ' ' : '\\n');\n}\n\nint\nmain(int argc, char** argv)\n{\n\tint i;\n\n\tn_post = 0;\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; ++i)\n\t\tscanf(\"%d\", &preorder[i]);\n\n\tfor (i = 0; i < n; ++i)\n\t\tscanf(\"%d\", &inorder[i]);\n\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ ALDS1_7_D Reconstruction of a Tree\n// 2018.5.7 bal4u\n\n#include <stdio.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\nint pre[45], ind[45];\nint post[45], sz, pos;\nint idx[45];\n\nvoid rebuild(int l, int r)\n{\n\tint c, m;\n\n\tif (l >= r) return;\n\tc = pre[pos++];\n\tm = idx[c];\n\trebuild(l, m);\n\trebuild(m+1, r);\n\tpost[sz++] = c;\n}\n\nint main()\n{\n\tint n, i;\n\n\tn = in();\n\tfor (i = 0; i < n; i++) pre[i] = in();\n\tfor (i = 0; i < n; i++) idx[in()] = i;\n\n\tsz = 0, pos = 0;\n\trebuild(0, n);\n\t\n\tprintf(\"%d\", post[0]);\n\tfor (i = 1; i < n; i++) {\n\t\tputchar(' '), printf(\"%d\", post[i]);\n\t}\n\tputchar('\\n');\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n  \nint n,pos;\nint a[40],b[40];\n  \nvoid solve(int l,int r){\n  if(l>r)return;\n  if(l==r){\n    if(b[l]==a[0])printf(\"%d\",b[l]);\n    else printf(\"%d \",b[l]);\n    pos++;\n    return;\n  }\n  \n  int x=a[pos],i;\n  pos++;\n  for(i=l;i<=r;i++){\n    if(b[i]==x)break;\n  }\n  solve(l,i-1);\n  solve(i+1,r);\n    \n  if(x==a[0])printf(\"%d\",x);\n  else printf(\"%d \",x);\n}\n  \nint main(){\n  int i;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)scanf(\"%d\",&a[i]);\n  for(i=0;i<n;i++)scanf(\"%d\",&b[i]);\n  pos=0;\n  solve(0,n-1);\n  printf(\"\\n\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 100\n\nint cnt = 0;\nint n;\nint pre[MAX], in[MAX], post[MAX];\n\nint find(int u){\n    int i;\n    for(i = 0; i < n; i++){\n        if(u == in[i]){\n            return i;\n        }\n    }\n\n\n    return -1;\n}\n\nvoid reconstruct(int l, int r){\n    if (l >= r) return;\n    int root = pre[cnt++];\n    int mid = find(root);\n\n    reconstruct(l, mid);\n    reconstruct(mid + 1, r);\n    printf(\" %d\", root);\n}\n\nint main(){\n    int i;\n    scanf(\"%d\", &n);\n\n    for(i = 0; i < n; i++) scanf(\"%d\", &pre[i]);\n    for(i = 0; i < n; i++) scanf(\"%d\", &in[i]);\n\n    reconstruct(0, n);\n    printf(\"\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint Pre[40];\nint In[40];\n\nvoid walk(int begin, int end, int *pos) {\n\tint i;\n\tif (begin <= end){\n\t\ti = begin;\n\t\twhile (In[i] != Pre[*pos]) i++;\n\t\t(*pos)++;\n\t\twalk(begin, i - 1, pos);\n\t\t(*pos)++;\n\t\twalk(i + 1, end, pos);\n\t\tprintf(\"%d\", In[i]);\n\t\tif (In[i] != Pre[0]) printf(\" \");\n\t} else (*pos)--;\n}\n\nint main() {\n\tint i, n, pos;\n\n\tscanf(\"%d\", &n);\n\n\tfor (i = 0; i < n; i++) scanf(\"%d\", &Pre[i]);\n\tfor (i = 0; i < n; i++) scanf(\"%d\", &In[i]);\n\n\tpos = 0;\n\twalk(0, n - 1, &pos);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 10000\n\nint pre[MAX],in[MAX],post[MAX],pos=0,n,back=0;\nint find(int x){\n  int i;\n  for(i=0;i<n;i++)if(x==in[i])return i;\n}\n\nvoid rec(int l,int r){\n  int root,m;\n  if(l>=r)return;\n  root=pre[pos++];\n  m=find(root);//\n  rec(l,m);\n  rec(m+1,r);\n  post[back++]=root;\n}\nvoid solve(){\n  int i;\n  rec(0,n);\n  for(i=0;i<n;i++){\n    if(i)printf(\" \");\n    printf(\"%d\",post[i]);\n  }\n  printf(\"\\n\");\n}\n\nint main(){\n  int i;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)scanf(\"%d\",&pre[i]);\n   for(i=0;i<n;i++)scanf(\"%d\",&in[i]);\n   solve();\n   \n  return 0;\n  \n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define CHECK printf(\"check\\n\");\ntypedef struct node\n{\n  int id;\n  struct node *parent;\n  struct node *sibling;\n  struct node *child[2];\n  int degree;\n  int depth;\n  int height;\n  char *type;\n} *nodePointer;\nvoid init(nodePointer*,int);\nnodePointer make1node(void);\nvoid relationSet(nodePointer*,int,int*);\nvoid calcStatus(nodePointer*,int);\nint getDegree(nodePointer*,int);\nint getDepth(nodePointer*,int);\nint getHeight(nodePointer*,int);\nchar *getType(nodePointer*,int);\nvoid printNodeArray(nodePointer*,int);\nnodePointer getRoot(nodePointer*);\nvoid postorderWalkP1(nodePointer,nodePointer);\nvoid printWalk(int);\nint reconstructTree(nodePointer*,int*,int*,int);\nint main(void)\n{\n  int i;//counter\n  int n;//the number of nodes\n  nodePointer *arr;//array of nodePointer\n  nodePointer root;//used for postorderWalk\n  int *pre;//preorderWalk\n  int *in;//inorderWalk\n  scanf(\"%d\",&n);\n  arr=(nodePointer*)malloc(sizeof(nodePointer)*n);\n  init(arr,n);\n  pre=(int*)malloc(sizeof(int)*n);\n  in=(int*)malloc(sizeof(int)*n);\n  for(i=0;i<n;i++)\n    {\n      scanf(\"%d\",&pre[i]);\n      pre[i]--;\n    }\n  for(i=0;i<n;i++)\n    {\n      scanf(\"%d\",&in[i]);\n      in[i]--;\n    }\n  reconstructTree(arr,pre,in,n);\n  root=getRoot(arr);\n  postorderWalkP1(root,root);\n  return 0;\n}\nvoid init(nodePointer *arr,int n)\n{\n  int i;//counter\n  for(i=0;i<n;i++)\n    {\n      arr[i]=make1node();\n      arr[i]->id=i;\n      arr[i]->parent=NULL;\n      arr[i]->sibling=NULL;\n      arr[i]->child[0]=NULL;\n      arr[i]->child[1]=NULL;\n      arr[i]->degree=-1;\n      arr[i]->depth=-1;\n      arr[i]->height=-1;\n      arr[i]->type=\"\";\n    }\n}\nnodePointer make1node(void)\n{\n  nodePointer p=(nodePointer)malloc(sizeof(struct node));\n  return p;\n}\nvoid relationSet(nodePointer *arr,int id,int *childID)\n{\n  int i;//counter\n  for(i=0;i<2;i++)\n    {\n      if(childID[i]==-1) arr[id]->child[i]=NULL;\n      else\n\t{\n\t  arr[id]->child[i]=arr[childID[i]];\n\t  arr[childID[i]]->parent=arr[id];\n\t}\n    }\n  if(arr[id]->child[0]!=NULL&&arr[id]->child[1]!=NULL)\n    {\n      arr[childID[0]]->sibling=arr[childID[1]];\n      arr[childID[1]]->sibling=arr[childID[0]];\n    }\n}\nvoid calcStatus(nodePointer *arr,int n)\n{\n  int i;//counter\n  nodePointer p;\n  for(i=0;i<n;i++)\n    {\n      p=arr[i];\n      p->degree=getDegree(arr,i);\n      p->depth=getDepth(arr,i);\n      p->height=getHeight(arr,i);\n      p->type=getType(arr,i);\n    }\n}\nint getDegree(nodePointer *arr,int id)\n{\n  int i;//counter\n  int ret=0;//return number\n  for(i=0;i<2;i++)\n    {\n      if(arr[id]->child[i]!=NULL) ret++;\n    }\n  return ret;\n}\nint getDepth(nodePointer *arr,int id)\n{\n  int ret=0;//return value\n  nodePointer p;\n  for(p=arr[id];p->parent!=NULL;p=p->parent) ret++;\n  return ret;\n}\nint getHeight(nodePointer *arr,int id)\n{\n  int i;//counter\n  int ret[2];//return value(bigger one)\n  for(i=0;i<2;i++)\n    {\n      if(arr[id]->child[i]==NULL) ret[i]=0;\n      else ret[i]=1+getHeight(arr,arr[id]->child[i]->id);\n    }\n  if(ret[0]>ret[1]) return ret[0];\n  else return ret[1];\n}\nchar *getType(nodePointer *arr,int id)\n{\n  char *str[3]={\"root\",\"leaf\",\"internal node\"};\n  if(arr[id]->parent==NULL) return str[0];\n  if(arr[id]->child[0]==NULL&&arr[id]->child[1]==NULL) return str[1];\n  return str[2];\n}\nvoid printNodeArray(nodePointer *arr,int n)\n{\n  int i;//counter\n  for(i=0;i<n;i++)\n    {\n      printf(\"node %d: \",arr[i]->id);\n      if(arr[i]->parent==NULL) printf(\"parent = -1, \");\n      else printf(\"parent = %d, \",arr[i]->parent->id);\n      if(arr[i]->sibling==NULL) printf(\"sibling = -1, \");\n      else printf(\"sibling = %d, \",arr[i]->sibling->id);\n      printf(\"degree = %d, \",arr[i]->degree);\n      printf(\"depth = %d, \",arr[i]->depth);\n      printf(\"height = %d, \",arr[i]->height);\n      printf(\"%s\",arr[i]->type);\n      printf(\"\\n\");\n    }\n}\nnodePointer getRoot(nodePointer *arr)\n{\n  int i;\n  for(i=0;;i++)\n    {\n      if(arr[i]->parent==NULL) break;\n    }\n  return arr[i];\n}\nvoid postorderWalkP1(nodePointer p,nodePointer root)\n{\n  if(p!=NULL)\n    {\n      if(p->id==root->id) printWalk(-1);\n      postorderWalkP1(p->child[0],root);\n      postorderWalkP1(p->child[1],root);\n      printWalk((p->id)+1);\n      if(p->id==root->id) printf(\"\\n\");\n    }\n}\nvoid printWalk(int id)\n{\n  static int flag=0;\n  if(id==-1) flag=0;\n  else\n    {\n      if(flag==1) printf(\" \");\n      else flag=1;\n      printf(\"%d\",id);\n    }\n}\n\nint reconstructTree(nodePointer *arr,int *pre,int *in,int n)\n{\n  int preIndex,inIndex;\n  //printf(\"p:%d..., \",pre[0]+1);\n  //printf(\"i:%d..., n=%d\\n\",in[0]+1,n);\n  for(preIndex=0;pre[preIndex]!=in[0]&&preIndex<n-1;preIndex++)\n    {\n      //printf(\"%d->%d\\n\",pre[preIndex]+1,pre[preIndex+1]+1);\n      arr[pre[preIndex]]->child[0]=arr[pre[preIndex+1]];\n      arr[pre[preIndex+1]]->parent=arr[pre[preIndex]];\n    }\n  if(n<=2) return 1;\n  if(preIndex==n-1)\n    {\n      for(preIndex=0;pre[preIndex]!=in[0]&&preIndex<n-1;preIndex++)\n\t{\n\t  //printf(\"%d-/->%d\\n\",pre[preIndex]+1,pre[preIndex+1]+1);\n\t  arr[pre[preIndex]]->child[0]=NULL;\n\t  arr[pre[preIndex+1]]->parent=NULL;\n\t}\n      return 0;\n    }\n  for(inIndex=0;;inIndex++)\n    {\n      //printf(\"*%d->%d\\n\",in[inIndex]+1,pre[preIndex+1]+1);\n      arr[in[inIndex]]->child[1]=arr[pre[preIndex+1]];\n      arr[pre[preIndex+1]]->parent=arr[in[inIndex]];\n      if(reconstructTree(arr,pre+preIndex+1,in+inIndex+1,n-preIndex-1)==1) break;\n      else\n\t{\n\t  //printf(\"*%d-/->%d\\n\",in[inIndex]+1,pre[preIndex+1]+1);\n\t  arr[in[inIndex]]->child[1]=NULL;\n\t  arr[pre[preIndex+1]]->parent=NULL;\n\t}\n    }\n  return 1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint n,pos;\nint a[40],b[40];\n\nvoid solve(int l,int r){\n  if(l>r)return;\n  if(l==r){\n    printf(\"%d \",b[l]);\n    pos++;\n    return;\n  }\n\n  int x=a[pos],i;\n  pos++;\n  for(i=l;i<=r;i++){\n    if(b[i]==x)break;\n  }\n  solve(l,i-1);\n  solve(i+1,r);\n  \n  if(x==a[0])printf(\"%d\",x);\n  else printf(\"%d \",x);\n}\n\nint main(){\n  int i;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)scanf(\"%d\",&a[i]);\n  for(i=0;i<n;i++)scanf(\"%d\",&b[i]);\n  pos=0;\n  solve(0,n-1);\n  printf(\"\\n\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX 40\n\nvoid solve(int*,int*,int);\n\nint n, post[MAX], idx;\n\nint main(){\n  int pre[MAX], in[MAX], i;\n\n  scanf(\"%d\",&n);\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\",pre+i);\n  }\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\",in+i); \n  }\n\n  solve(pre, in, n);\n\n  for(i = 0 ; i < n ; i++){\n    printf(\"%d%c\",post[i],(i != n-1 ? ' ':'\\n'));\n  }\n\n  return 0;\n}\n\nvoid solve(int pre[], int in[], int N){\n  int i, p;\n\n  for(i = 0 ; i < N ; i++){\n    if(in[i] == pre[0]){\n      p = i;\n      break;\n    }\n  }\n\n  if(p != 0){\n    solve(pre+1, in, p);\n  }\n  if(p != N-1){\n    solve(pre+p+1, in+p+1, N-p-1);\n  }\n  post[idx++] = pre[0]; \n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 100\n\n\n int n,pos,count=0;\n int pre[N],in[N],post[N];\n \n int find(int in[n],int root){\n     int i;\n     for(i=0;i<n;i++){\n            if(in[i]==root)return i;\n            }\n     return in[n-1];\n     }\n\nvoid rec(int l, int r){\n  int root, m;\n  if(l >= r) return;\n  root = pre[pos++];\n  m = find(in, root);\n  rec(l, m);\n  rec(m + 1, r);\n  post[count++] = root;\n}\n \n\n void solve(){\n      int i;\n      pos=0;\n      rec(0,n);\n      for(i=0;i<n;i++){\n              if(i)printf(\" \");\n              printf(\"%d\",post[i]);\n              }\n      printf(\"\\n\");\n      }\n\n int main(){\n      int i,k;\n      scanf(\"%d\",&n);\n\n      for(i=0;i<n;i++){\n              scanf(\"%d\",&k);\n              pre[i]=k;\n              }\n      for(i=0;i<n;i++){\n              scanf(\"%d\",&k);\n              in[i]=k;\n              }\n      solve();\n      return 0;\n      }\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n \nint n,pos;\nint a[40];\nint b[40];\n\nvoid solve(int,int);\t\t\t\t\\\n\n\n \nint main(){\n  \n  int i;\n\n  scanf(\"%d\",&n);\n\n  for(i = 0;i < n;i++){\n    scanf(\"%d\",&a[i]);\n  }\n  for(i = 0;i < n;i++){\n    scanf(\"%d\",&b[i]);\n  }\n  pos = 0;\n\n  solve(0,n-1);\n  \n  printf(\"\\n\");\n\n  return 0;\n}\n\n\n\nvoid solve(int l,int r){\n  \n  if(l > r)return;\n\n  if(l == r){\n\n    if(b[l] == a[0]){\n      printf(\"%d\",b[l]);\n    }\n    \n    else printf(\"%d \",b[l]);\n\n    pos++;\n\n    return;\n  }\n \n  int x = a[pos];\n  int i;\n  \n  pos++;\n\n  for(i = l;i <= r;i++){\n    \n    if(b[i] == x)break;\n\n  }\n  \n  solve(l,i-1);\n  solve(i+1,r);\n   \n  if(x == a[0]){\n    \n    printf(\"%d\",x);\n\n  }\n  else printf(\"%d \",x);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 40\n\nint pre[N],in[N];\nint n,mark=0;\n\nvoid rec(int l, int r) {\n\tint i;\n\tint c,m;\n\n\tif (l >= r) return;\n\tc = pre[mark++];\n\tfor (i = 0; i < n;i++) {\n\t\tif (in[i] == c) {\n\t\t\tm = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trec(l, m);\n\trec(m+1, r);\n\n\tprintf(\"%d \",c);\n}\n\nint main() {\n\tint i;\n\n\tscanf(\"%d\",&n);\n\tfor (i = 0;i < n;i++) scanf(\"%d\",&pre[i]);\n\tfor (i = 0;i < n;i++) scanf(\"%d\",&in[i]);\n\n\trec(0,n);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct node{\n  int id;\n  struct node *parent;\n  struct node *left;\n  struct node *right;\n}Node;\n\nvoid print_tree(Node *x,int t) {\n  if(x->left != NULL) print_tree(x->left,1);\n  if(x->right != NULL) print_tree(x->right,1);\n  if(t == 1)printf(\"%d \", x->id);\n  if(t == 0)printf(\"%d\\n\", x->id);\n}\n\nNode *make_tree(int *pre, int * in, int i, int j, int n, Node *p) {\n  if(i >= n) return NULL;\n  Node *p1 = (Node*)malloc(sizeof(Node));\n  p1->id = pre[i];\n  p1->parent = p;\n  p1->left = NULL;\n  p1->right = NULL;\n  if(pre[i] != in[j]) {\n    p1->left = make_tree(pre,in,i+1,j,n,p1);\n  }else{\n    Node *tmp = p;\n    while(1) {\n      if(tmp == NULL) {\n\ttmp = p1;\n\tbreak;\n      }\n      if(tmp->id == in[j+1]) {\n\tj++;\n\tbreak;\n      }\n      tmp = tmp->parent;\n    }\n    tmp->right = make_tree(pre,in,i+1,j+1,n,tmp);\n  }\n  return p1;\n}\n\nint main()\n{\n  int i,n,*preorder,*inorder;\n  scanf(\"%d\",&n);\n  preorder = (int*)malloc(sizeof(int) * n);\n  inorder = (int*)malloc(sizeof(int) * n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\",preorder+i);\n  }\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\",inorder+i);\n  }\n  Node *root = make_tree(preorder,inorder,0,0,n,NULL);\n  print_tree(root,0);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n \nint preOrder[40],inOrder[40];\n\nvoid solve(int l,int r){\n  int p,i;\n  int x=preOrder[p];\n\n  if(l>r) return;\n  if(l==r){\n    if(inOrder[l]==preOrder[0]){\n      printf(\"%d\",inOrder[l]);\n    }\n    else{\n      printf(\"%d \",inOrder[l]);\n    } \n    p++;\n    return;\n  }\n \n\n  p++;\n  for(i=l;i<=r;i++){\n    if(inOrder[i]==x) break;\n  }\n  solve(l,i-1);\n  solve(i+1,r);\n   \n  if(x==preOrder[0]) printf(\"%d\",x);\n  else printf(\"%d \",x);\n}\n \nint main(){\n  int i,n;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++) scanf(\"%d\",&preOrder[i]);\n  for(i=0;i<n;i++) scanf(\"%d\",&inOrder[i]);\n  solve(0,n-1);\n  printf(\"\\n\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 41\n\ntypedef struct node{\n  int l, r;\n}node;\n\nnode c[N];\nint a[N], b[N];\nint cnt=0;\n\nvoid postorder(int root,int n){\n\n        if(c[root].l! = -1) postorder(c[root].l, n);\n        if(c[root].r != -1) postorder(c[root].r, n);\n        if(cnt < n - 1) printf(\"%d \", root);\n        else printf(\"%d\\n\", root);\n\n        cnt++;\n\n        return;\n\n}\n\nint reconst(int start,int last,int n){\n  int i, j;\n\n  if(start == last) return b[start];\n  else if(start > last) return -1;\n\n  else {\n    for(i = 1 ; i <= n ; i++){\n      for(j = start ; j <= last ; j++){\n        if(a[i] == b[j]){\n          c[a[i]].l = reconst(start, j - 1, n);\n          c[a[i]].r = reconst(j + 1, last, n);\n          return a[i];\n        }\n      }\n    }\n  }\n}\n\n\nint main(){\n  int n,i, root;\n\n  scanf(\"%d\",&n);\n\n  for(i = 1 ; i <= n ; i++) scanf(\"%d\",&a[i]);\n  for(i = 1 ; i <= n ; i++) scanf(\"%d\",&b[i]);\n  for(i = 1 ; i <= n ; i++){\n    c[i].l = -1;\n    c[i].r = -1;\n  }\n\n  root = reconst(1,n,n);\n\n  postorder(root,n);\n\n  return 0;\n\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX 40\n\nvoid solve(int*,int*,int);\n\nint n, post[MAX], idx;\n\nint main(){\n  int pre[MAX], in[MAX], i;\n\n  scanf(\"%d\",&n);\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\",pre+i);\n  }\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\",in+i); \n  }\n\n  solve(pre, in, n);\n\n  for(i = 0 ; i < n ; i++){\n    printf(\"%d%c\",post[i],(i != n-1 ? ' ':'\\n'));\n  }\n\n  return 0;\n}\n\nvoid solve(int pre[], int in[], int N){\n  int i, p;\n\n  for(i = 0 ; i < N ; i++){\n    if(in[i] == pre[0]){\n      p = i;\n      break;\n    }\n  }\n\n  if(p != 0){\n    solve(pre+1, in, p);\n  }\n  if(p != N-1){\n    solve(pre+p+1, in+p+1, N-p-1);\n  }\n  post[idx++] = pre[0]; \n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 40\n#define O 0\n#define I 1\n\nint n,p,a[N],b[N];\n\nvoid solve(int l,int r){\n  int i,x;\n\n  x=a[p];\n  if(l>r){\n    return;\n  }\n  if(l==r){\n    if(b[l]==a[O]){\n      printf(\"%d\",b[l]);\n    }\n    else{\n      printf(\"%d \",b[l]);\n    }\n    p++;\n    return;\n  }\n  p++;\n  for(i=l;i<=r;i++){\n    if(b[i]==x){\n      break;\n    }\n  }\n  solve(l,i-I);\n  solve(i+I,r);\n  if(x==a[O]){\n    printf(\"%d\",x);\n  }\n  else{\n    printf(\"%d \",x);\n  }\n}\n\n\nint main(){\n  int i;\n\n  scanf(\"%d\",&n);\n  for(i=O;i<n;i++){\n    scanf(\"%d\",&a[i]);\n  }\n  for(i=O;i<n;i++){\n    scanf(\"%d\",&b[i]);\n  }\n  p=O;\n  solve(O,n-I);\n  printf(\"\\n\");\n  return O;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 50\n\n\n\ntypedef struct cell{\n int id;\n struct cell *right;\n struct cell *left;\n struct cell *parent;\n}cell;\n\n\nvoid postorder(cell *root,cell N[],int x){\ncell *p=root;\nif(p->left!=NULL){postorder(p->left,N,x);}\nif(p->right!=NULL){postorder(p->right,N,x);}\n\nif(p->id!=x){printf(\"%d \",p->id);}\nelse{printf(\"%d\",p->id);}\n\nreturn;\n}\n\n\nint reconstruction(int A[],int B[],int start,int last,cell N[],int n){\nint i,j;\nint a,b;\nint x;\n\n\nif(start!=last){/*要素二つ以上*/\n\n for(i=0;i<n;i++){\n  for(j=start;j<=last;j++){\n\n   if(B[j]==A[i]){x=A[i];\n    a=reconstruction(A,B,start,j-1,N,n);\n    if(a!=-1){\n\n     N[A[i]].left=&N[a];\n     N[a].parent=&N[A[i]];\n    }\n    else{\n     N[A[i]].left=NULL;\n    }\n\n    b=reconstruction(A,B,j+1,last,N,n);\n    if(b!=-1){\n     N[A[i]].right=&N[b];\n     N[b].parent=&N[A[i]];\n    }\n    else{\n     N[A[i]].right=NULL;\n    }\n\n    return x;\n   }\n\n  }/*for j end*/\n\n }/*for i end*/\n\n}/*ifおわり*/\n\n\nif(start==last){/*要素一つ*/\n N[B[start]].right=NULL;\n N[B[start]].left=NULL;\n return B[start];\n}\n\nif(start>last){\n return -1;\n}\n\n\n\n\n}\n\n\n\n\nint main(){\nint n,i;\nint A[MAX];\nint B[MAX];\ncell N[MAX];\ncell *root;\nint x;\n\nscanf(\"%d\",&n);\nfor(i=0;i<n;i++)scanf(\"%d\",&A[i]);\nfor(i=0;i<n;i++)scanf(\"%d\",&B[i]);\n\nfor(i=0;i<=n;i++)N[i].id=i;\n\n\nx=reconstruction(A,B,0,n-1,N,n);\n\nroot=&N[x];\n\n\n\npostorder(root,N,x);\nprintf(\"\\n\");\n\nreturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint n;\nint pre[44], in[44];\nint idx;\nint flag;\n\nvoid dfs(int l, int r) {\n  int pos = -1;\n  int i;\n  if(idx == n) return;\n  if(l >= r) return;\n  for(i = l; i < r; i++) {\n    if(pre[idx] == in[i]) pos = i;\n  }\n  idx++;\n  dfs(l, pos);\n  dfs(pos+1, r);\n  if(flag) printf(\" \");\n  printf(\"%d\", in[pos]);\n  flag = 1;\n}\n\nint main() {\n  int i;\n  scanf(\"%d\", &n);\n  for(i = 0; i < n; i++) scanf(\"%d\", pre+i);\n  for(i = 0; i < n; i++) scanf(\"%d\", in+i);\n  idx = 0;\n  flag = 0;\n  dfs(0, n);\n  puts(\"\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 40\n\nint n,pos=0;\nint cout = 0;\nint Pre[MAX],In[MAX],Ans[MAX];\n\nint distance(int start,int key){\n  int i,count=0;\n  for(i=start;i<MAX;i++){\n    if(In[i]!=key)\n      count++;\n    else break;\n  }\n  return count;\n}\n  \n  \nint solve(int l,int r){\n  int root,d;\n  if(l-r>=0)return -1;\n  root=Pre[pos];\n  pos++;\n  d=distance(0,root);\n  if(d>n)return -1;\n  solve(l, d);\n  solve(d+1, r);\n  Ans[cout++]=root;\n  return 0;\n}\n\nint main(){\n  int m,i;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&m);\n    Pre[i]=m;\n  }\n  for(i=0;i<n;i++){\n      scanf(\"%d\",&m);\n      In[i]=m;\n  }\n  solve(0,n);\n\n  printf(\"%d\",Ans[0]);\n  for(i=1;i<n;i++)\n    printf(\" %d\",Ans[i]);\n  printf(\"\\n\");\n\t   \n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "#include <cstdio>\nint preorder[40],inorder[40];\nvoid recover(int fp,int lp,int fi,int li){\n\tint root=fi;\n\tfor(;root<li;root++)if(preorder[fp]==inorder[root])break;\n\tif(fi<root)recover(fp+1,fp+(root-fi)+1,fi,root);\n\tif(root<li-1)recover(fp+(root-fi)+1,lp,root+1,li);\n\tprintf(inorder[root]==preorder[0]?\"%d\\n\":\"%d \",inorder[root]);\n}\nmain(){\n\tint n,i;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++)scanf(\"%d\",preorder+i);\n\tfor(i=0;i<n;i++)scanf(\"%d\",inorder+i);\n\trecover(0,n,0,n);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint n,*pre,*in,*post,prenumber=-1,cnt=0;\n\nint infind(int number)//numberが格納されているinの要素番号を返す\n{\n\tint i;\n\tfor(i=0;i<n;i++) if(in[i]==number) return i;\n\tprintf(\"error\\n\");\n\treturn 100000;\n}\n\nvoid reconstraction(int l,int r)//後行順巡回を出力する関数\n{\n\tint c,m;\n\tif(l>=r) return;\n\tprenumber++;\n\tc=pre[prenumber];//探索する値をcに格納\n\tm=infind(c);//inの要素番号をmに格納\n\tif(m==100000) return;\n\treconstraction(l,m);//左部分木を探索\n\treconstraction(m+1,r);//右部分木を探索\n\t\n\tpost[cnt]=c;//葉まで行けば、出力条件を満たすため一度配列に巡回順を格納\n\tcnt++;\n}\n\nint main(void)\n{\n\tint i;\n\tscanf(\"%d\",&n);\n\tpre=(int*)malloc(sizeof(int)*n);\n\tin=(int*)malloc(sizeof(int)*n);\n\tpost=(int*)malloc(sizeof(int)*n);\n\tfor(i=0;i<n;i++) scanf(\"%d\",&pre[i]);\n\tfor(i=0;i<n;i++) scanf(\"%d\",&in[i]);\n\t\n\treconstraction(0,n);\n\tfor(i=0;i<n;i++){\n\t\tif(i!=0) printf(\" \");\n\t\tprintf(\"%d\",post[i]);\n\t}\n\tprintf(\"\\n\");\n\t\n\tfree(pre);\n\tfree(in);\n\tfree(post);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX 45\n\nint post[MAX], pre[MAX], in[MAX], id, n;\n\nvoid recon(int pre[], int in[], int N){\n  int i, pos;\n\n  for(i = 0 ; i < N ; i++){\n    if(in[i] == pre[0]){\n      pos = i;\n      break;\n    }\n  }\n\n  if(pos != 0)\n    recon(pre+1, in, pos);\n  \n  if(pos != N-1)\n    recon(pre+pos+1, in+pos+1, N-pos-1);\n  \n  post[id++] = pre[0]; \n}\n\n\nint main(){\n  int i;\n\n  scanf(\"%d\",&n);\n  for(i = 0 ; i < n ; i++)\n    scanf(\"%d\", &pre[i]);\n  \n  for(i = 0 ; i < n ; i++)\n    scanf(\"%d\", &in[i]); \n  \n  recon(pre, in, n);\n\n  for(i = 0 ; i < n-1 ; i++)\n    printf(\"%d \",post[i]);\n  printf(\"%d\\n\",post[i]);\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 40\nvoid A(int,int);\nint baby;\nint killme;\nint n,i,P[40],I[40],O[40];\nint main(){\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)scanf(\"%d\",&P[i]);\n  for(i=0;i<n;i++)scanf(\"%d\",&I[i]);\n  A(0,n-1);\n  printf(\"%d\",O[0]);\n  for(i=1;i<n;i++)printf(\" %d\",O[i]);\n  printf(\"\\n\");\n  return 0;\n}\nvoid A(int a,int b){\n  int i=killme++;\n  int t;\n  for(t=0;I[t]!=P[i];t++);\n  if(a<b){\n    if(a!=t)A(a,t-1);\n    if(b!=t)A(t+1,b);\n  }\n  O[baby++]=I[t];\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct {\n\tint parent;\n\tint left, right;\n}Node;\n\nint linear_search(int* xs, int size, int x)\n{\n\tint i;\n\tfor (i = 0; i < size; i++) {\n\t\tif (xs[i] == x) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nNode tree[50];\n\nint prewalked[50];\nint inwalked[50];\n\nint n;\n\nint reconstruction_tree(int from, int to, int root_pos, int parent)\n{\n\tint i;\n\tint v;\n\n\tfor (i = from; i < to; i++) {\n\t\tif ((v = inwalked[i]) == prewalked[root_pos]) {\n\t\t\ttree[v].parent = parent;\n\n\t\t\ttree[v].left = reconstruction_tree(from, i, root_pos + 1, v);\n\t\t\ttree[v].right = reconstruction_tree(i+1, to, root_pos +  (i - from) + 1, v);\n\n\t\t\treturn v;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint result[50];\nint resultcnt;\n\nvoid postorder_walk(int p)\n{\n\tif (p > n || p < 0) {\n\t\treturn;\n\t}\n\tpostorder_walk(tree[p].left, 0);\n\tpostorder_walk(tree[p].right, 0);\n\n\tresult[resultcnt++] = p;\n}\n\nint main()\n{\n\tint i;\n\tint root;\n\n\tfor (i = 0; i < 50; i++) {\n\t\ttree[i].parent = -1;\n\t}\n\n\tscanf(\"%d\", &n);\n\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &(prewalked[i]));\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &(inwalked[i]));\n\t}\n\n\troot = reconstruction_tree(0, n, 0, -1);\n\n\tfor (i = 0; i < resultcnt; i++) {\n\t\tif (i == 0) {\n\t\t\tprintf(\"%d\", result[i]);\n\t\t}\n\t\telse {\n\t\t\tprintf(\" %d\", result[i]);\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define CHECK printf(\"check\\n\");\ntypedef struct node\n{\n  int id;\n  struct node *parent;\n  struct node *sibling;\n  struct node *child[2];\n  int degree;\n  int depth;\n  int height;\n  char *type;\n} *nodePointer;\nvoid init(nodePointer*,int);\nnodePointer make1node(void);\nvoid relationSet(nodePointer*,int,int*);\nvoid calcStatus(nodePointer*,int);\nint getDegree(nodePointer*,int);\nint getDepth(nodePointer*,int);\nint getHeight(nodePointer*,int);\nchar *getType(nodePointer*,int);\nvoid printNodeArray(nodePointer*,int);\nnodePointer getRoot(nodePointer*);\nvoid postorderWalkP1(nodePointer,nodePointer);\nvoid printWalk(int);\nvoid reconstructTree(nodePointer*,int*,int*,int);\nint main(void)\n{\n  int i;//counter\n  int n;//the number of nodes\n  nodePointer *arr;//array of nodePointer\n  nodePointer root;//used for postorderWalk\n  int *pre;//preorderWalk\n  int *in;//inorderWalk\n  scanf(\"%d\",&n);\n  arr=(nodePointer*)malloc(sizeof(nodePointer)*n);\n  init(arr,n);\n  pre=(int*)malloc(sizeof(int)*n);\n  in=(int*)malloc(sizeof(int)*n);\n  for(i=0;i<n;i++)\n    {\n      scanf(\"%d\",&pre[i]);\n      pre[i]--;\n    }\n  for(i=0;i<n;i++)\n    {\n      scanf(\"%d\",&in[i]);\n      in[i]--;\n    }\n  reconstructTree(arr,pre,in,n);\n  root=getRoot(arr);\n  postorderWalkP1(root,root);\n  return 0;\n}\nvoid init(nodePointer *arr,int n)\n{\n  int i;//counter\n  for(i=0;i<n;i++)\n    {\n      arr[i]=make1node();\n      arr[i]->id=i;\n      arr[i]->parent=NULL;\n      arr[i]->sibling=NULL;\n      arr[i]->child[0]=NULL;\n      arr[i]->child[1]=NULL;\n      arr[i]->degree=-1;\n      arr[i]->depth=-1;\n      arr[i]->height=-1;\n      arr[i]->type=\"\";\n    }\n}\nnodePointer make1node(void)\n{\n  nodePointer p=(nodePointer)malloc(sizeof(struct node));\n  return p;\n}\nvoid relationSet(nodePointer *arr,int id,int *childID)\n{\n  int i;//counter\n  for(i=0;i<2;i++)\n    {\n      if(childID[i]==-1) arr[id]->child[i]=NULL;\n      else\n\t{\n\t  arr[id]->child[i]=arr[childID[i]];\n\t  arr[childID[i]]->parent=arr[id];\n\t}\n    }\n  if(arr[id]->child[0]!=NULL&&arr[id]->child[1]!=NULL)\n    {\n      arr[childID[0]]->sibling=arr[childID[1]];\n      arr[childID[1]]->sibling=arr[childID[0]];\n    }\n}\nvoid calcStatus(nodePointer *arr,int n)\n{\n  int i;//counter\n  nodePointer p;\n  for(i=0;i<n;i++)\n    {\n      p=arr[i];\n      p->degree=getDegree(arr,i);\n      p->depth=getDepth(arr,i);\n      p->height=getHeight(arr,i);\n      p->type=getType(arr,i);\n    }\n}\nint getDegree(nodePointer *arr,int id)\n{\n  int i;//counter\n  int ret=0;//return number\n  for(i=0;i<2;i++)\n    {\n      if(arr[id]->child[i]!=NULL) ret++;\n    }\n  return ret;\n}\nint getDepth(nodePointer *arr,int id)\n{\n  int ret=0;//return value\n  nodePointer p;\n  for(p=arr[id];p->parent!=NULL;p=p->parent) ret++;\n  return ret;\n}\nint getHeight(nodePointer *arr,int id)\n{\n  int i;//counter\n  int ret[2];//return value(bigger one)\n  for(i=0;i<2;i++)\n    {\n      if(arr[id]->child[i]==NULL) ret[i]=0;\n      else ret[i]=1+getHeight(arr,arr[id]->child[i]->id);\n    }\n  if(ret[0]>ret[1]) return ret[0];\n  else return ret[1];\n}\nchar *getType(nodePointer *arr,int id)\n{\n  char *str[3]={\"root\",\"leaf\",\"internal node\"};\n  if(arr[id]->parent==NULL) return str[0];\n  if(arr[id]->child[0]==NULL&&arr[id]->child[1]==NULL) return str[1];\n  return str[2];\n}\nvoid printNodeArray(nodePointer *arr,int n)\n{\n  int i;//counter\n  for(i=0;i<n;i++)\n    {\n      printf(\"node %d: \",arr[i]->id);\n      if(arr[i]->parent==NULL) printf(\"parent = -1, \");\n      else printf(\"parent = %d, \",arr[i]->parent->id);\n      if(arr[i]->sibling==NULL) printf(\"sibling = -1, \");\n      else printf(\"sibling = %d, \",arr[i]->sibling->id);\n      printf(\"degree = %d, \",arr[i]->degree);\n      printf(\"depth = %d, \",arr[i]->depth);\n      printf(\"height = %d, \",arr[i]->height);\n      printf(\"%s\",arr[i]->type);\n      printf(\"\\n\");\n    }\n}\nnodePointer getRoot(nodePointer *arr)\n{\n  int i;\n  for(i=0;;i++)\n    {\n      if(arr[i]->parent==NULL) break;\n    }\n  return arr[i];\n}\nvoid postorderWalkP1(nodePointer p,nodePointer root)\n{\n  if(p!=NULL)\n    {\n      if(p->id==root->id) printWalk(-1);\n      postorderWalkP1(p->child[0],root);\n      postorderWalkP1(p->child[1],root);\n      printWalk((p->id)+1);\n      if(p->id==root->id) printf(\"\\n\");\n    }\n}\nvoid printWalk(int id)\n{\n  static int flag=0;\n  if(id==-1) flag=0;\n  else\n    {\n      if(flag==1) printf(\" \");\n      else flag=1;\n      printf(\"%d\",id);\n    }\n}\n\nvoid reconstructTree(nodePointer *arr,int *pre,int *in,int n)\n{\n  int preIndex,inIndex;\n  if(n<=1) return;\n  for(preIndex=0;pre[preIndex]!=in[0];preIndex++)\n    {\n      arr[pre[preIndex]]->child[0]=arr[pre[preIndex+1]];\n      arr[pre[preIndex+1]]->parent=arr[pre[preIndex]];\n    }\n  if(pre[preIndex+1]==in[1]) inIndex=0;\n  else inIndex=1;\n  arr[in[inIndex]]->child[1]=arr[pre[preIndex+1]];\n  arr[pre[preIndex+1]]->parent=arr[in[inIndex]];\n  reconstructTree(arr,pre+preIndex+1,in+2,n-preIndex-1);\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define MAX 100\n\n\nint n,c,d=0;\nint pre[1000],in[1000],post[1000];\n\nint find(int x);\nvoid rec(int l,int r);\n\nint main(void){\n\tint i;\n\tscanf(\"%d\",&n);\n\t\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&pre[i]);\n\t}\n\t\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&in[i]);\n\t}\n\t\n\trec(0,n);\n\t\n\tfor(i=0;i<n;i++){\n\t\tif(i!=n-1){\n\t\t\tprintf(\"%d \",post[i]);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%d\\n\",post[i]);\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint find(int x){\n\tint i;\n\tfor(i=0;i<n;i++){\n\t\tif(x==in[i]){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid rec(int l,int r){\n\tint x,y;\n\tif(l>=r){\n\t\treturn;\n\t}\n\t\n\tx=pre[d++];\n\ty=find(x);\n\trec(l,y);\n\trec(y+1,r);\n\tpost[c++]=x;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,pos;\nvector<int> pre,in,post;\n\nvoid rec(int l, int r){\n  if(l>=r) return;\n  int root = pre[pos++];\n  int m = distance(in.begin(), find(in.begin(),in.end(),root));\n  rec(l,m);\n  rec(m+1,r);\n  post.push_back(root);\n}\n\nvoid solve(){\n  int i;\n  pos = 0;\n  rec(0,pre.size());\n  for(i=0;i<n;i++){\n    if(i) cout << \" \";\n    cout << post[i];;\n  }\n  cout << endl;\n}\n\nint main(){\n  int k;\n  cin >> n;\n\n  for(int i =0;i<n;i++){\n    cin >> k;\n    pre.push_back(k);\n  }\n\n  for(int i=0;i<n;i++){\n    cin >> k;\n    in.push_push(k);\n  }\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nvoid f_post(int *,int *,int,int,int,int*);\nvoid post(int *,int *,int,int,int,int*);\nint main(){\n  int i,n,count=0;\n  int *pre,*in;\n\n  scanf(\"%d\",&n);\n  pre = malloc(sizeof(int)*n);\n  in = malloc(sizeof(int)*n);\n  for(i=0;i<n;i++) scanf(\"%d\",&pre[i]);\n  for(i=0;i<n;i++) scanf(\"%d\",&in[i]);\n  f_post(pre,in,0,n,n,&count);\n  free(pre);\n  free(in);\n  return 0;\n}\nvoid f_post(int *pre,int *in,int l,int r,int n,int *count){\n  int i,j,m,num;\n  if(l>=r)return;\n  num = pre[(*count)++];\n  for(i=0;i<n;i++){\n    if(num == in[i])break;\n  }\n  post(pre,in,l,i,n,count);\n  post(pre,in,i+1,r,n,count);\n  printf(\"%d\\n\",num);\n}\nvoid post(int *pre,int *in,int l,int r,int n,int *count){\n  int i,j,m,num;\n  if(l>=r)return;\n  num = pre[(*count)++];\n  for(i=0;i<n;i++){\n    if(num == in[i])break;\n  }\n  post(pre,in,l,i,n,count);\n  post(pre,in,i+1,r,n,count);\n  printf(\"%d \",num);\n}\n       \n  \n  \n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define MAX 100\n\n\nint n , c , d;\n\td=0;\nint pre[1000] , in[1000],post[1000];\n\nint find(int x)\n{\n\tint i;\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tif(x == in[i]) \n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid rec(int l,int r)\n{\n\tint a,b;\n\tif(l >= r) return;\n\ta = pre[d++];\n\tb = find(a);\n\trec(l,b);\n\trec(b+1,r);\n\tpost[c++] = a;\n}\n\n\n\nint main(void)\n{\n\tint j;\n\tscanf(\"%d\",&n);\n\t\n\tfor(j = 0; j < n; j++)\n\t{\n\t\tscanf(\"%d\",&pre[j]);\n\t}\n\t\n\tfor(j = 0; j < n; j++)\n\t{\n\t\tscanf(\"%d\",&in[j]);\n\t}\n\t\n\trec(0,n);\n\t\n\tfor(j = 0; j < n; j++)\n\t{\n\t\tif(j != n-1)\n\t\t{\n\t\t\tprintf(\"%d \",post[j]);\n\t\t}\n\t\telse \n\t\t{\n\t\t\tprintf(\"%d\\n\",post[j]);\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define nMAX 41\n\nint NC = 0,lC = 0,n;\n\n//二分木再起関数で後順\nvoid BtreeRec(int left,int right,int Af[],int Am[],int Al[]){\n    int tmp,mid;\n    \n    //leftとright入れ替わりで終了\n    if(left >= right) {\n        return;\n    }\n    \n    tmp = Af[NC++];\n    mid = Find(tmp,Am);\n    //今の場所から左側の処理\n    BtreeRec(left, mid,Af,Am,Al);\n    //今の場所から右側の処理\n    BtreeRec(mid + 1, right,Af,Am,Al);\n    Al[lC++] = tmp;\n}\n\n//AfとAmで同じ数の物を返す\nint Find(int tmp,int Am[]) {\n    for(int i = 0 ; i < n ; i++) {\n        if(tmp == Am[i]) {\n            return i;\n        }\n    }\n    return 0;\n}\n\nint main(){\n    //枠の作成\n    int i;\n    scanf(\"%d\",&n);\n    int *Af = malloc(sizeof(int)*n);\n    int *Am = malloc(sizeof(int)*n);\n    int *Al = malloc(sizeof(int)*n);\n    \n    //読み込み\n    for( i = 0 ; i < n ; i++ ){\n        scanf(\"%d\",&Af[i]);\n    }\n    for( i = 0 ; i < n ; i++ ){\n        scanf(\"%d\",&Am[i]);\n    }\n    \n    //後行順巡回作成\n    BtreeRec(0,n,Af,Am,Al);\n    \n    //表示\n    for(i = 0 ; i < n-1 ; i++) {\n        printf(\"%d \",Al[i]);\n    }\n    printf(\"%d\\n\", Al[n-1]);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint pre[40],in[40];\nvoid post(int l1,int r1,int l2,int r2){\n\tint root;\n\tfor(root=l2;root<=r2;root++)\n\tif(in[root]==pre[l1])\n\tbreak;\n\tif(l2<root)\t\n\tpost(l1+1,l1+root-l2,l2,root-1);\n\tif(root<r2)\n\tpost(l1+root-l2+1,r1,root+1,r2);\n\tprintf(in[root]==pre[0]?\"%d\\n\":\"%d \",in[root]);\n}\nint main(int argc, char *argv[])\n{\n\tint n,i;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++)\n\tscanf(\"%d\",&pre[i]);\n\tfor(i=0;i<n;i++)\n\tscanf(\"%d\",&in[i]);\n\tpost(0,n-1,0,n-1);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "//2020.1.7\n//s1270188 xxxmk2\n//alds1_07d\n\n#include<stdio.h>\n#include<stdlib.h>\n\n//prototype\nvoid fix_post(int,int);\n\n//global\nint *pre, *in;\n\nint main(){\n  int i, num;\n\n  //input\n  scanf(\"%d\",&num);\n  pre=(int *)malloc(sizeof(int)*num);\n  in=(int *)malloc(sizeof(int)*num);\n  for(i=0;i<num;i++) scanf(\"%d\",&pre[i]);\n  for(i=0;i<num;i++) scanf(\"%d\",&in[i]);\n\n  //output\n  fix_post(0,num);\n  \n  free(pre);\n  free(in);\n  return 0;\n}\n\nvoid fix_post(int l,int r){\n  int c, m, i=0;\n  static int cnt=0;\n  \n  if(l>=r) return;\n\n  c=pre[cnt++];\n  while(in[i]!=c) i++;\n  m=i;\n  \n  fix_post(l,m);\n  fix_post(m+1,r);\n\n  if(c==pre[0]) printf(\"%d\\n\",c);\n  else printf(\"%d \",c);\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define OUTPUT__LENGTH (128)\nchar _out[OUTPUT__LENGTH];\nchar *_o = _out;\nvoid write_uint(int n) {\n    if(!n) {\n        *_o++ = '0';\n        return;\n    }\n    char buf[11];\n    int i = 0;\n    while(n) buf[i++] = (n % 10 + '0'), n /= 10;\n    while(i--) *_o++ = buf[i];\n}\nint get_uint() {\n    int n = 0;\n    int c = getchar_unlocked();\n    if(c < 48 || 57 < c) return c;\n    while(47 < c && c < 58) {\n        n = 10 * n + (c & 0xf);\n        c = getchar_unlocked();\n    }\n    return n;\n}\nint *find(int *first, int *last, const int value) {\n    for(;first!=last;++first)\n        if(*first == value) return first;\n    return last;\n}\n\ntypedef struct Node {\n    int parent, left, right, depth, height, sibling;\n} Node;\ntypedef struct BinaryTree {\n    Node nodes[25];\n    int root;\n} BinaryTree;\nvoid bt_init(BinaryTree *BT) {\n    for(int i = 0; i < 25; ++i) BT->nodes[i].parent = -1;\n}\nvoid bt_make(BinaryTree *BT) {\n    for(int i = 0; i < 25; ++i) {\n        if(BT->nodes[i].parent == -1) {\n            BT->root = i;\n            break;\n        }\n    }\n}\nvoid bt_add_node(BinaryTree *BT, int id, int l, int r) {\n    BT->nodes[id].left = l;\n    BT->nodes[id].right = r;\n    if(~l) BT->nodes[l].parent = id;\n    if(~r) BT->nodes[r].parent = id;\n}\nint bt_pre_in(BinaryTree *BT, int *pre, int *in, int l, int r) {\n    static int pos = 0;\n    if(l >= r) return -1;\n    int root = pre[pos++];\n    int mid = (int)(find(in, in+r, root) - in);\n    int ln = bt_pre_in(BT, pre, in, l, mid);\n    int rn = bt_pre_in(BT, pre, in, mid+1, r);\n    bt_add_node(BT, root, ln, rn);\n    return root;\n}\nvoid bt_pr_postorder(BinaryTree *BT, int id) {\n    if(id == -1) return;\n    bt_pr_postorder(BT, BT->nodes[id].left);\n    bt_pr_postorder(BT, BT->nodes[id].right);\n    *_o++ = ' ';\n    write_uint(id+1);\n}\nint main(int argc, char **argv) {\n    int n = get_uint();\n    int pre[n], in[n];\n    for(int i = 0; i < n; ++i) pre[i] = get_uint()-1;\n    for(int i = 0; i < n; ++i) in[i] = get_uint()-1;\n    BinaryTree BT;\n    bt_init(&BT);\n    bt_pre_in(&BT, pre, in, 0, n);\n    bt_make(&BT);\n    bt_pr_postorder(&BT, BT.root);\n    for(char *p = _out+1; p!=_o;++p) putchar_unlocked(*p);\n    putchar_unlocked('\\n');\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define CHECK printf(\"check\\n\");\ntypedef struct node\n{\n  int id;\n  struct node *parent;\n  struct node *sibling;\n  struct node *child[2];\n  int degree;\n  int depth;\n  int height;\n  char *type;\n} *nodePointer;\nvoid init(nodePointer*,int);\nnodePointer make1node(void);\nvoid relationSet(nodePointer*,int,int*);\nvoid calcStatus(nodePointer*,int);\nint getDegree(nodePointer*,int);\nint getDepth(nodePointer*,int);\nint getHeight(nodePointer*,int);\nchar *getType(nodePointer*,int);\nvoid printNodeArray(nodePointer*,int);\nnodePointer getRoot(nodePointer*);\nvoid postorderWalkP1(nodePointer,nodePointer);\nvoid printWalk(int);\nvoid reconstructTree(nodePointer*,int*,int*,int);\nint main(void)\n{\n  int i;//counter\n  int n;//the number of nodes\n  nodePointer *arr;//array of nodePointer\n  nodePointer root;//used for postorderWalk\n  int *pre;//preorderWalk\n  int *in;//inorderWalk\n  scanf(\"%d\",&n);\n  arr=(nodePointer*)malloc(sizeof(nodePointer)*n);\n  init(arr,n);\n  pre=(int*)malloc(sizeof(int)*n);\n  in=(int*)malloc(sizeof(int)*n);\n  for(i=0;i<n;i++)\n    {\n      scanf(\"%d\",&pre[i]);\n      pre[i]--;\n    }\n  for(i=0;i<n;i++)\n    {\n      scanf(\"%d\",&in[i]);\n      in[i]--;\n    }\n  reconstructTree(arr,pre,in,n);\n  root=getRoot(arr);\n  postorderWalkP1(root,root);\n  return 0;\n}\nvoid init(nodePointer *arr,int n)\n{\n  int i;//counter\n  for(i=0;i<n;i++)\n    {\n      arr[i]=make1node();\n      arr[i]->id=i;\n      arr[i]->parent=NULL;\n      arr[i]->sibling=NULL;\n      arr[i]->child[0]=NULL;\n      arr[i]->child[1]=NULL;\n      arr[i]->degree=-1;\n      arr[i]->depth=-1;\n      arr[i]->height=-1;\n      arr[i]->type=\"\";\n    }\n}\nnodePointer make1node(void)\n{\n  nodePointer p=(nodePointer)malloc(sizeof(struct node));\n  return p;\n}\nvoid relationSet(nodePointer *arr,int id,int *childID)\n{\n  int i;//counter\n  for(i=0;i<2;i++)\n    {\n      if(childID[i]==-1) arr[id]->child[i]=NULL;\n      else\n\t{\n\t  arr[id]->child[i]=arr[childID[i]];\n\t  arr[childID[i]]->parent=arr[id];\n\t}\n    }\n  if(arr[id]->child[0]!=NULL&&arr[id]->child[1]!=NULL)\n    {\n      arr[childID[0]]->sibling=arr[childID[1]];\n      arr[childID[1]]->sibling=arr[childID[0]];\n    }\n}\nvoid calcStatus(nodePointer *arr,int n)\n{\n  int i;//counter\n  nodePointer p;\n  for(i=0;i<n;i++)\n    {\n      p=arr[i];\n      p->degree=getDegree(arr,i);\n      p->depth=getDepth(arr,i);\n      p->height=getHeight(arr,i);\n      p->type=getType(arr,i);\n    }\n}\nint getDegree(nodePointer *arr,int id)\n{\n  int i;//counter\n  int ret=0;//return number\n  for(i=0;i<2;i++)\n    {\n      if(arr[id]->child[i]!=NULL) ret++;\n    }\n  return ret;\n}\nint getDepth(nodePointer *arr,int id)\n{\n  int ret=0;//return value\n  nodePointer p;\n  for(p=arr[id];p->parent!=NULL;p=p->parent) ret++;\n  return ret;\n}\nint getHeight(nodePointer *arr,int id)\n{\n  int i;//counter\n  int ret[2];//return value(bigger one)\n  for(i=0;i<2;i++)\n    {\n      if(arr[id]->child[i]==NULL) ret[i]=0;\n      else ret[i]=1+getHeight(arr,arr[id]->child[i]->id);\n    }\n  if(ret[0]>ret[1]) return ret[0];\n  else return ret[1];\n}\nchar *getType(nodePointer *arr,int id)\n{\n  char *str[3]={\"root\",\"leaf\",\"internal node\"};\n  if(arr[id]->parent==NULL) return str[0];\n  if(arr[id]->child[0]==NULL&&arr[id]->child[1]==NULL) return str[1];\n  return str[2];\n}\nvoid printNodeArray(nodePointer *arr,int n)\n{\n  int i;//counter\n  for(i=0;i<n;i++)\n    {\n      printf(\"node %d: \",arr[i]->id);\n      if(arr[i]->parent==NULL) printf(\"parent = -1, \");\n      else printf(\"parent = %d, \",arr[i]->parent->id);\n      if(arr[i]->sibling==NULL) printf(\"sibling = -1, \");\n      else printf(\"sibling = %d, \",arr[i]->sibling->id);\n      printf(\"degree = %d, \",arr[i]->degree);\n      printf(\"depth = %d, \",arr[i]->depth);\n      printf(\"height = %d, \",arr[i]->height);\n      printf(\"%s\",arr[i]->type);\n      printf(\"\\n\");\n    }\n}\nnodePointer getRoot(nodePointer *arr)\n{\n  int i;\n  for(i=0;;i++)\n    {\n      if(arr[i]->parent==NULL) break;\n    }\n  return arr[i];\n}\nvoid postorderWalkP1(nodePointer p,nodePointer root)\n{\n  if(p!=NULL)\n    {\n      if(p->id==root->id) printWalk(-1);\n      postorderWalkP1(p->child[0],root);\n      postorderWalkP1(p->child[1],root);\n      printWalk((p->id)+1);\n      if(p->id==root->id) printf(\"\\n\");\n    }\n}\nvoid printWalk(int id)\n{\n  static int flag=0;\n  if(id==-1) flag=0;\n  else\n    {\n      if(flag==1) printf(\" \");\n      else flag=1;\n      printf(\"%d\",id);\n    }\n}\n\nvoid reconstructTree(nodePointer *arr,int *pre,int *in,int n)\n{\n  int preIndex,inIndex;\n  if(n<=1) return;\n  for(preIndex=0;pre[preIndex]!=in[0];preIndex++)\n    {\n      //printf(\"%d->%d\\n\",pre[preIndex],pre[preIndex+1]);\n      arr[pre[preIndex]]->child[0]=arr[pre[preIndex+1]];\n      arr[pre[preIndex+1]]->parent=arr[pre[preIndex]];\n    }\n  if(preIndex==n-1) return;\n  if(pre[preIndex+1]==in[1]) inIndex=0;\n  else inIndex=1;\n  //printf(\"*%d->%d\\n\",in[inIndex],pre[preIndex+1]);\n  arr[in[inIndex]]->child[1]=arr[pre[preIndex+1]];\n  arr[pre[preIndex+1]]->parent=arr[in[inIndex]];\n  reconstructTree(arr,pre+preIndex+1,in+2,n-preIndex-1);\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nvoid re(int ,int);\nvoid solve(int,int);\nint pre[100],in[100],n,pos,post[100],k;\nint main(){\n  int i,root;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)scanf(\"%d\",&pre[i]);\n  for(i=0;i<n;i++)scanf(\"%d\",&in[i]);\n  solve(0,n);\n  printf(\"\\n\");\n  return 0;\n}\n\nvoid re(int l,int r){\n  int m,c,i;\n  if(l>=r)return;\n  c=pre[pos++];\n  for(i=0;i<n;i++){\n    if(c==in[i]){\n      m=i;\n    }\n  }\n  re(l,m);\n  re(m+1,r);\n  post[k++]=c;\n}\n\nvoid solve(int l,int r){\n  re(l,r);\n  int i;\n  for(i=0;i<n;i++){\n    if(i!=0)printf(\" \");\n    printf(\"%d\",post[i]);\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n    int cnt=0;\n    int fir[100],mid[100];\n    int i,g;\n\nvoid solve(int m,int t){\n    \n    \n    \n    if (m==t){\n        if(mid[m]==fir[0]){\n            \n          printf(\"%d\",mid[m]);\n            \n        }else  {\n            \n            printf(\"%d \",mid[m]);\n            \n            cnt++;\n            \n            return;\n            \n        }\n    }\n    \n    \n    g=fir[cnt];\n    \n    cnt++;\n    \n    \n    for(i=m;i<t;i++){\n        if(mid[i]==g)break;\n    }\n    \n    solve(m,i-1);\n    solve(i+1,t);\n    \n  \n}\n\n\n\n\n\n\nint main(void){\n    \n    int n;\n\n    \n    scanf(\"%d\",&n);\n    \n    for(i=0;i<n;i++){\n        scanf(\"%d\",&fir[i]);\n       // scanf(\"%d\",&mid[i]);\n    }\n    \n    for(i=0;i<n;i++){\n        scanf(\"%d\",&mid[i]);\n    }\n    \n    \n    solve(0,n-1);\n    \n    if(g==fir[0])printf(\"%d\",g);\n    else printf(\"%d \",g);\n    \n    \n    \n    printf(\"\\n\");\n    \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n \nint n,p;\nint a1[40],a2[40];\n \nvoid solve(int l,int r){\n  if(l>r)return;\n  if(l==r){\n    if(a2[l]==a1[0])printf(\"%d\",a2[l]);\n    else printf(\"%d \",a2[l]);\n    p++;\n    return;\n  }\n \n  int x=a1[p],i;\n  p++;\n  for(i=l;i<=r;i++){\n    if(a2[i]==x)break;\n  }\n  solve(l,i-1);\n  solve(i+1,r);\n   \n  if(x==a1[0])printf(\"%d\",x);\n  else printf(\"%d \",x);\n}\n \nint main(){\n  int i;\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)scanf(\"%d\",&a1[i]);\n  for(i=0;i<n;i++)scanf(\"%d\",&a2[i]);\n  p=0;\n  solve(0,n-1);\n  printf(\"\\n\");\n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tprivate class Node<T> {\n\t\tT value;\n\t\tNode<T> left;\n\t\tNode<T> right;\n\t\tint pos;\n\t\tpublic Node(T value) {\n\t\t\tthis.value = value;\n\t\t\tleft = right = null;\n\t\t\tpos = -1;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn value.toString();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\t\n\tprivate void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(reader.readLine());\n\t\tint[] pre = new int[n];\n\t\tint[] in = new int[n];\n\t\tStringTokenizer st1 = new StringTokenizer(reader.readLine());\n\t\tStringTokenizer st2 = new StringTokenizer(reader.readLine());\n\t\tint rootId = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpre[i] = Integer.parseInt(st1.nextToken());\n\t\t\tin[i] = Integer.parseInt(st2.nextToken());\n\t\t\tif (i == 0) {\n\t\t\t\trootId = pre[i];\n\t\t\t}\n\t\t}\n\t\treader.close();\n\t\t\n\t\tNode<Integer> rootNode = new Node<Integer>(rootId);\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tNode<Integer> current = new Node<Integer>(pre[i]);\n\t\t\taddNode(rootNode, current, in);\n\t\t}\n\t\tSystem.out.println(postOrder(rootNode));\n\t}\n\n\tprivate String postOrder(Node<Integer> rootNode) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tStack<Node<Integer>> stack = new Stack<Node<Integer>>();\n\t\tNode<Integer> current = rootNode;\n\t\tNode<Integer> lastVisited = null;\n\t\twhile (current != null || !stack.isEmpty()) {\n\t\t\tif (current != null) {\n\t\t\t\tstack.push(current);\n\t\t\t\tcurrent = current.left;\n\t\t\t} else {\n\t\t\t\tNode<Integer> peekNode = stack.peek();\n\t\t\t\tif (peekNode.right != null && peekNode.right != lastVisited) {\n\t\t\t\t\tcurrent = peekNode.right;\n\t\t\t\t} else {\n\t\t\t\t\tif (sb.length() != 0) {\n\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(peekNode);\n\t\t\t\t\tlastVisited = stack.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate void addNode(Node<Integer> rootNode, Node<Integer> newNode, int[] in) {\n\t\tnewNode.pos = findPos(in, newNode.value);\n\t\tStack<Node<Integer>> stack = new Stack<Node<Integer>>();\n\t\tstack.push(rootNode);\n\t\twhile (!stack.isEmpty()) {\t\t\t\n\t\t\tNode<Integer> current = stack.pop();\n\t\t\tif (current.pos == -1) {\n\t\t\t\tcurrent.pos = findPos(in, current.value);\n\t\t\t}\n\t\t\tif (newNode.pos < current.pos) {\n\t\t\t\tif (current.left == null) {\n\t\t\t\t\tcurrent.left = newNode;\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tstack.push(current.left);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (current.right == null) {\n\t\t\t\t\tcurrent.right = newNode;\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tstack.push(current.right);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int findPos(int[] in, int id) {\n\t\tfor (int i = 0; i < in.length; i++) {\n\t\t\tif (in[i] == id) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tprivate class Node {\n\t\tint id, pos;\n\t\tNode left, right;\n\t\tpublic Node(int id) {\n\t\t\tthis.id = id;\n\t\t\tpos = -1;\n\t\t\tleft = right = null;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\t\n\tprivate void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(reader.readLine());\n\t\tint[] pre = new int[n];\n\t\tint[] in = new int[n];\n\t\tStringTokenizer st1 = new StringTokenizer(reader.readLine());\n\t\tStringTokenizer st2 = new StringTokenizer(reader.readLine());\n\t\tint rootId = -1;\n\t\tint rootPos = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpre[i] = Integer.parseInt(st1.nextToken());\n\t\t\tin[i] = Integer.parseInt(st2.nextToken());\n\t\t\tif (i == 0) {\n\t\t\t\trootId = pre[i];\n\t\t\t}\n\t\t\tif (rootId == in[i]) {\n\t\t\t\trootPos = i;\n\t\t\t}\n\t\t}\n\t\tNode rootNode = new Node(pre[0]);\n\t\trootNode.pos = rootPos;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\taddNode(rootNode, new Node(pre[i]), in);\n\t\t}\n\t\tSystem.out.println(postOrder(rootNode));\n\t}\n\n\tprivate String postOrder(Node rootNode) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tStack<Node> stack = new Stack<Node>();\n\t\tNode lastVisited = null;\n\t\tNode current = rootNode;\n\t\twhile (current != null || !stack.isEmpty()) {\n\t\t\tif (current != null) {\n\t\t\t\tstack.push(current);\n\t\t\t\tcurrent = current.left;\n\t\t\t} else {\n\t\t\t\tNode peekNode = stack.peek();\n\t\t\t\tif (peekNode.right != null && peekNode.right != lastVisited) {\n\t\t\t\t\tcurrent = peekNode.right;\n\t\t\t\t} else {\n\t\t\t\t\tif (sb.length() != 0) {\n\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(peekNode.id);\n\t\t\t\t\tlastVisited = stack.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t\treturn sb.toString();\n\t}\n\n\tprivate void addNode(Node rootNode, Node newNode, int[] in) {\n\t\tnewNode.pos = findPos(newNode.id, in);\n\t\tStack<Node> stack = new Stack<Node>();\n\t\tstack.push(rootNode);\n\t\twhile (!stack.isEmpty()) {\n\t\t\tNode current = stack.pop();\n\t\t\tif (current.pos == -1) {\n\t\t\t\tcurrent.pos = findPos(current.id, in);\n\t\t\t}\n\t\t\tif (newNode.pos < current.pos) {\n\t\t\t\tif (current.left == null) {\n\t\t\t\t\tcurrent.left = newNode;\n\t\t\t\t} else {\n\t\t\t\t\tstack.push(current.left);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (current.right == null) {\n\t\t\t\t\tcurrent.right = newNode;\n\t\t\t\t} else {\n\t\t\t\t\tstack.push(current.right);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int findPos(int id, int[] in) {\n\t\tfor(int i = 0; i < in.length; i++) {\n\t\t\tif (in[i] == id) return i;\n \t\t}\n\t\treturn -1;\n\t}\t\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tstatic class Node {\n\t\tint id = 0;\n\t\tNode left = NIL;\n\t\tNode right = NIL;\n\t}\n\tstatic Node NIL = new Node();\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\n\t\tint n = scanner.nextInt();\n\t\t\n\t\tNode[] tree = new Node[n + 1];\n\t\ttree[0] = NIL;\n\t\tNIL.id = 0;\n\t\tfor (int i = 1; i < n + 1; i ++) {\n\t\t\ttree[i] = new Node();\n\t\t}\n\t\tint[] preorder = new int[n];\n\t\tint[] inorder = new int[n];\n\t\tint[] postorder = new int[n];\n\t\t\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tpreorder[i] = scanner.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tinorder[i] = scanner.nextInt();\n\t\t}\n\t\t\n\t\tscanner.close();\n\t\t\n\t\treci = 0;\n\t\treconstruct(preorder, inorder, 0, n - 1, tree);\n\t\t\n\t\tpostorder(tree[preorder[0]], postorder, 0);\n\t\tfor (int i = 0; i < n - 1; i ++) {\n\t\t\tSystem.out.print(postorder[i]);\n\t\t\tSystem.out.print(\" \");\n\t\t}\n\t\tSystem.out.println(postorder[n - 1]);\n\t}\n\t\n\tstatic int reci;\n\tstatic Node reconstruct(int[] preorder, int[] inorder, int left, int right, Node[] tree) {\n\t\tif (left > right) return NIL;\n\t\tNode root = tree[preorder[reci]];\n\t\troot.id = preorder[reci];\n\t\t\n\t\tint mid;\n\t\tfor (mid = left; tree[inorder[mid]] != root; mid ++);\n\t\treci ++;\n\t\t\n\t\troot.left = reconstruct(preorder, inorder, left, mid - 1, tree);\n\t\troot.right = reconstruct(preorder, inorder, mid + 1, right, tree);\n\t\t\n\t\treturn root;\n\t}\n\t\n\tstatic int postorder(Node u, int[] postorder, int posti) {\n\t\tif (u == NIL) return posti;\n\t\t\n\t\tposti = postorder(u.left, postorder, posti);\n\t\tposti = postorder(u.right, postorder, posti);\n\t\tpostorder[posti] = u.id;\n\t\t\n\t\treturn posti + 1;\n\t}\n} \n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tprivate class Node<T> {\n\t\tT value;\n\t\tNode<T> left;\n\t\tNode<T> right;\n\t\tint pos;\n\t\tpublic Node(T value) {\n\t\t\tthis.value = value;\n\t\t\tleft = right = null;\n\t\t\tpos = -1;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn value.toString();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\t\n\tprivate void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(reader.readLine());\n\t\tint[] pre = new int[n];\n\t\tint[] in = new int[n];\n\t\tStringTokenizer st1 = new StringTokenizer(reader.readLine());\n\t\tStringTokenizer st2 = new StringTokenizer(reader.readLine());\n\t\tint rootId = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpre[i] = Integer.parseInt(st1.nextToken());\n\t\t\tin[i] = Integer.parseInt(st2.nextToken());\n\t\t\tif (i == 0) {\n\t\t\t\trootId = pre[i];\n\t\t\t}\n\t\t}\n\t\treader.close();\n\t\t\n\t\tNode<Integer> rootNode = new Node<Integer>(rootId);\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tNode<Integer> current = new Node<Integer>(pre[i]);\n\t\t\taddNode(rootNode, current, in);\n\t\t}\n\t\tSystem.out.println(postOrder(rootNode));\n\t}\n\n\tprivate String postOrder(Node<Integer> rootNode) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tStack<Node<Integer>> stack = new Stack<Node<Integer>>();\n\t\tNode<Integer> current = rootNode;\n\t\tNode<Integer> lastVisited = null;\n\t\twhile (current != null || !stack.isEmpty()) {\n\t\t\tif (current != null) {\n\t\t\t\tstack.push(current);\n\t\t\t\tcurrent = current.left;\n\t\t\t} else {\n\t\t\t\tNode<Integer> peekNode = stack.peek();\n\t\t\t\tif (peekNode.right != null && peekNode.right != lastVisited) {\n\t\t\t\t\tcurrent = peekNode.right;\n\t\t\t\t} else {\n\t\t\t\t\tif (sb.length() != 0) {\n\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(peekNode);\n\t\t\t\t\tlastVisited = stack.pop();\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate void addNode(Node<Integer> rootNode, Node<Integer> newNode, int[] in) {\n\t\tnewNode.pos = findPos(in, newNode.value);\n\t\tStack<Node<Integer>> stack = new Stack<Node<Integer>>();\n\t\tstack.push(rootNode);\n\t\twhile (!stack.isEmpty()) {\t\t\t\n\t\t\tNode<Integer> current = stack.pop();\n\t\t\tif (current.pos == -1) {\n\t\t\t\tcurrent.pos = findPos(in, current.value);\n\t\t\t}\n\t\t\tif (newNode.pos < current.pos) {\n\t\t\t\tif (current.left == null) {\n\t\t\t\t\tcurrent.left = newNode;\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tstack.push(current.left);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (current.right == null) {\n\t\t\t\t\tcurrent.right = newNode;\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tstack.push(current.right);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int findPos(int[] in, int id) {\n\t\tfor (int i = 0; i < in.length; i++) {\n\t\t\tif (in[i] == id) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic int[][] list;\n\tstatic int[] check;\n    \n\tpublic static void main(String[] args){\n    \t Scanner sc= new Scanner(System.in);\n    \t int n =sc.nextInt();\n    \t list =new int[n][2];\n    \t check = new int[n];\n    \t for(int i=0;i<n;i++){\n    \t\t list[i][0]=sc.nextInt();\n    \t }\n    \t for(int i=0;i<n;i++){\n    \t\t check[i]=sc.nextInt();\n    \t\t for(int j=0;j<n;j++){\n    \t\t\t if(check[i]==list[j][0]){\n    \t\t\t\t list[j][1]=i;\n    \t\t\t }\n    \t\t }\n    \t }\n    \t mpost(0,n,list);\n    \t \n     }\n     \n     static int reg=0;\n     \n     static void mpost(int a,int b,int[][] list){\n    \tif(a>=b){\n    \t\treturn;\n    \t}else{\n    \t int num=list[reg][0];\n    \t int id=list[reg][1];\n    \t reg++;\n    \t mpost(a,id,list);\n    \t mpost(id+1,b,list);\n    \t System.out.print(num);\n    \t System.out.print(num==list[0][0]?\"\\n\":\" \");\n    \t}\n     }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic int n;\n\tstatic int[] preorder, inorder;\n\t//preorder(own, left, right)\n\t//inorder(left, own, right)\n\t//postorder(left, right, own)\n\t\n\tstatic void recover(int fp, int lp, int fi, int li) {\n\t\tint root=fi;\n\t\tfor(int i=fi; i<li; i++) {\n\t\t\tif(preorder[fp]==inorder[i]) {\n\t\t\t\troot=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(fi<root) {//左側存在するなら表示\n\t\t\trecover(fp+1, fp+(root-fi)+1, fi, root);\n\t\t}\n\t\tif(root<li-1) {//右側存在するなら表示\n\t\t\trecover(fp+(root-fi)+1, lp, root+1, li);\n\t\t}\n\t\tif(inorder[root]==preorder[0]) {\n\t\t\tSystem.out.println(inorder[root]);\n\t\t}\n\t\telse {\n\t\t\tSystem.out.print(inorder[root]+\" \");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tn=sc.nextInt();\n\t\t\tpreorder=new int[n];\n\t\t\tinorder=new int[n];\n\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\tpreorder[i]=sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\tinorder[i]=sc.nextInt();\n\t\t\t}\n\t\t\trecover(0, n, 0, n);\n\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new\n\t\t// File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\ALDS1_6_A-in9.txt\"));\n\n\t\tint n = scan.nextInt();\n\t\tTree t = new Tree(n + 1);\n\t\tint[] pre = new int[n];\n\t\tint[] in = new int[n];\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tpre[i] = scan.nextInt();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tin[i] = scan.nextInt();\n\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (in[j] == pre[i]) {\n\t\t\t\t\tt.setLeftChild(pre[i - 1], pre[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (in[j] == pre[i - 1])\n\t\t\t\t\tbreak;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (pre[j] == in[i]) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (pre[j] == in[i - 1]) {\n\t\t\t\t\tt.setRightChild(in[i - 1], in[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t// System.out.print(\"Preorder\\n\");\n\t\t// t.printPre(t.getRoot());\n\t\t// System.out.print(\"\\nInorder\\n\");\n\t\t// t.printIn(t.getRoot());\n\t\t// System.out.print(\"\\nPostorder\\n\");\n\t\tt.printPost(t.getRoot());\n\t\tSystem.out.print(\"\\n\");\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Tree {\n\tprivate class Node {\n\t\tint Parent = -1;\n\t\tint LeftChild = -1;\n\t\tint RightChild = -1;\n\n\t\tpublic int getDepth() {\n\t\t\tif (Parent == -1)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn (node[Parent].getDepth() + 1);\n\t\t}\n\n\t\tpublic String getType() {\n\t\t\tif (Parent == -1)\n\t\t\t\treturn \"root\";\n\t\t\telse if (LeftChild == -1 && RightChild == -1)\n\t\t\t\treturn \"leaf\";\n\t\t\telse\n\t\t\t\treturn \"internal node\";\n\t\t}\n\n\t\tpublic int getSib(int id) {\n\t\t\tif (Parent == -1)\n\t\t\t\treturn -1;\n\t\t\telse if (node[Parent].LeftChild == id)\n\t\t\t\treturn (node[Parent].RightChild);\n\t\t\telse\n\t\t\t\treturn (node[Parent].LeftChild);\n\t\t}\n\n\t\tpublic int getDegree() {\n\t\t\tint r = 2;\n\t\t\tif (LeftChild == -1)\n\t\t\t\tr--;\n\t\t\tif (RightChild == -1)\n\t\t\t\tr--;\n\t\t\treturn r;\n\t\t}\n\n\t\tpublic int getHeight() {\n\t\t\tif (getDegree() == 0)\n\t\t\t\treturn 0;\n\t\t\tint l = 0, r = 0;\n\t\t\tif (LeftChild != -1)\n\t\t\t\tl = node[LeftChild].getHeight();\n\t\t\tif (RightChild != -1)\n\t\t\t\tr = node[RightChild].getHeight();\n\t\t\treturn Math.max(l, r) + 1;\n\t\t}\n\t}\n\n\tprivate Node[] node;\n\n\tpublic Tree(int n) {\n\t\tnode = new Node[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnode[i] = new Node();\n\t\t}\n\t}\n\n\tpublic void printPost(int id) {\n\t\tif (id == -1)\n\t\t\treturn;\n\t\tprintPost(node[id].LeftChild);\n\t\tprintPost(node[id].RightChild);\n\t\tSystem.out.print(\" \" + id);\n\t}\n\n\tpublic void printIn(int id) {\n\t\tif (id == -1)\n\t\t\treturn;\n\t\tprintIn(node[id].LeftChild);\n\t\tSystem.out.print(\" \" + id);\n\t\tprintIn(node[id].RightChild);\n\t}\n\n\tpublic void printPre(int id) {\n\t\tif (id == -1)\n\t\t\treturn;\n\t\tSystem.out.print(\" \" + id);\n\t\tprintPre(node[id].LeftChild);\n\t\tprintPre(node[id].RightChild);\n\t}\n\n\tpublic int getRoot() {\n\t\treturn getRoot(1);\n\t}\n\n\tprivate int getRoot(int id) {\n\t\tif (node[id].Parent == -1)\n\t\t\treturn id;\n\t\telse\n\t\t\treturn getRoot(node[id].Parent);\n\t}\n\n\tpublic void setRightChild(int id, int c) {\n\t\tnode[id].RightChild = c;\n\t\tif (c != -1)\n\t\t\tnode[c].Parent = id;\n\t}\n\n\tpublic void setLeftChild(int id, int c) {\n\t\tnode[id].LeftChild = c;\n\t\tif (c != -1)\n\t\t\tnode[c].Parent = id;\n\t}\n\n\tpublic void printDetail(int id) {\n\t\tSystem.out.println(\"node \" + id + \": parent = \" + node[id].Parent + \", sibling = \" + node[id].getSib(id)\n\t\t\t\t+ \", degree = \" + node[id].getDegree() + \", depth = \" + node[id].getDepth() + \", height = \"\n\t\t\t\t+ node[id].getHeight() + \", \" + node[id].getType());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint[] pre = new int[n];\n    \tfor (int i = 0; i < n; i++) {\n    \t\tpre[i] = sc.nextInt();\n    \t}\n\t\tint[] in = new int[n];\n    \tfor (int i = 0; i < n; i++) {\n    \t\tin[i] = sc.nextInt();\n    \t}\n\n    \tint[] post = new int[n];\n    \tmakePost(post, n - 1, pre, 0, in, 0, n);\n\n    \tfor (int i = 0; i < n; i++) {\n    \t\tif (i != 0) {\n            \tSystem.out.print(\" \");\n    \t\t}\n        \tSystem.out.print(post[i]);\n    \t}\n    \tSystem.out.println(\"\");\n\n    \tsc.close();\n\t}\n\t\n\tprivate static void makePost(int[] post, int spost, int[] pre, int spre, int[] in, int sin, int n) {\n\t\tif (n < 1) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tpost[spost] = pre[spre];\n\n\t\tint i = sin;\n\t\tfor (; i < sin + n; i++) {\n\t\t\tif (in[i] == pre[spre]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tmakePost(post, spost - 1, pre, spre + 1 + (i - sin), in, sin + 1 + (i -sin), n - (i - sin) - 1);\n\t\tmakePost(post, spost - 1 - (n - (i - sin) - 1), pre, spre + 1, in, sin, i - sin);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.Arrays;\n\npublic class Main {\n    class Node {\n        int id;\n        int left = -1, right = -1;\n        String nodeType = null;\n        Node(int id, int left, int right) {\n            this.id = id;\n            this.left = left;\n            this.right = right;\n        }\n        void print() {\n            System.out.println(id + \", \" + left + \", \" + right);\n        }\n    }\n    int[] result;\n    int resultIndex;\n    void postorder(Node[] nodes, int x) {\n        if (nodes[x].left != -1)\n            postorder(nodes, nodes[x].left);\n        if (nodes[x].right != -1)\n            postorder(nodes, nodes[x].right);\n        result[resultIndex++] = x;\n    }\n\n    Node[] nodes;\n    int[] pre;\n    int[] in;\n    int ap = 0;\nint search(int b1p, int b2p) {\n        boolean debug = false;\n        int center = -1;\n        if (ap >= pre.length) {\n            return -1;\n        }\n        int top = pre[ap];\n        //if (top == 1) debug = true;\n        if (b1p + 1 == b2p) {\n            ap++;\n            nodes[top] = new Node(top, -1, -1);\n            return top;\n        } else if (b1p >= b2p) {\n            return -1;\n        }\n        for (int i = b1p; i < b2p; i++) {\n            if (top == in[i]) {\n                center = i;\n                break;\n            }\n        }\n        if (debug) {\n            System.out.println(\"top: \" + top);\n            System.out.println(\"ap:  \" + ap);\n            System.out.println(\"b1p: \" + b1p);\n            System.out.println(\"cen: \" + center + \", \" + in[center]);\n            System.out.println(\"b2p: \" + b2p);\n        }\n        ap++;\n        int left = search(b1p, center);\n        //if (left != -1) ap++;\n        if (debug) {\n            System.out.println(\"ap r:\" + ap + \", \" + pre[ap]);\n        }\n        int right = search(center+1, b2p);\n        nodes[top] = new Node(top, left, right);\n        return top;\n    }\nvoid printArray(int[] ary) {\n        System.out.print(ary[0]);\n        for (int i = 1; i < ary.length; i++) {\n            System.out.print(\" \" + ary[i]);\n        }\n        System.out.println();\n    }\n\n    void run() {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        nodes = new Node[n+1];\n        pre = new int[n];\n        in  = new int[n];\n        int root = 0;\n        for (int i = 0; i < n; i++) {\n            int id = sc.nextInt();\n            if (i == 0) root = id;\n            pre[i] = id;\n        }\n        for (int i = 0; i < n; i++) {\n            int id = sc.nextInt();\n            in[i] = id;\n        }\n        search(0, nodes.length);\n        result = new int[n];\n        resultIndex = 0;\n        postorder(nodes, root);\n        System.out.print(result[0]);\n        for (int i = 1; i < result.length; i++) {\n            System.out.print(\" \" + result[i]);\n        }\n        System.out.println();\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tprivate static FastScanner sc = new FastScanner();\n\tstatic int idx_preodr = 1;\n\n\tpublic static void main(String[] args) {\n\t\tint n = sc.nextInt();\n\n\t\tNode_BT[] nodes = new Node_BT[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tnodes[i] = new Node_BT();\n\t\t\tnodes[i].id = i;\n\t\t}\n\n\t\tint[] preodr = new int[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tpreodr[i] = sc.nextInt() - 1;\n\t\t}\n\n\t\tint[] inodr = new int[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tinodr[i] = sc.nextInt() - 1;\n\t\t}\n\n\t\tnodes[preodr[0]].reconstructTree(nodes, preodr, inodr, -1);\n\n\t\tnodes[preodr[0]].postOrder(nodes, preodr);\n\t\tSystem.out.println();\n\n\t}\n\n\tstatic class Node_BT {\n\t\tint id;\n\t\tint left = -1;\n\t\tint right = -1;\n\t\tint parent = -1;\n\t\tHashSet<Integer> l_subtree = new HashSet<>();\n\t\tHashSet<Integer> r_subtree = new HashSet<>();\n\n\t\tvoid reconstructTree(Node_BT[] nodes, int[] preodr, int[] inodr, int parent) {\n\t\t\tthis.parent = parent;\n\t\t\tleftSubTree(nodes, inodr);\n\t\t\trightSubTree(nodes, inodr);\n\n\t\t\tif(idx_preodr >= preodr.length) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(l_subtree.contains(preodr[idx_preodr])) {\n\t\t\t\tleft = preodr[idx_preodr];\n\t\t\t\tidx_preodr++;\n\t\t\t\tnodes[left].reconstructTree(nodes, preodr, inodr, id);\n\t\t\t}\n\n\t\t\tif(idx_preodr >= preodr.length) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(r_subtree.contains(preodr[idx_preodr])) {\n\t\t\t\tright = preodr[idx_preodr];\n\t\t\t\tidx_preodr++;\n\t\t\t\tnodes[right].reconstructTree(nodes, preodr, inodr, id);\n\t\t\t}\n\t\t}\n\n\t\tvoid leftSubTree(Node_BT[] nodes, int[] inodr) {\n\t\t\tint i = 0;\n\t\t\twhile(inodr[i] != id) {\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\ti--;\n\t\t\tif(parent == -1) {\n\t\t\t\twhile(i >= 0) {\n\t\t\t\t\tl_subtree.add(inodr[i]);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(nodes[parent].l_subtree.contains(id)) {\n\t\t\t\t\twhile(i >= 0 && nodes[parent].l_subtree.contains(inodr[i])) {\n\t\t\t\t\t\tl_subtree.add(inodr[i]);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile(i >= 0 && nodes[parent].r_subtree.contains(inodr[i])) {\n\t\t\t\t\t\tl_subtree.add(inodr[i]);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid rightSubTree(Node_BT[] nodes, int[] inodr) {\n\t\t\tint i = 0;\n\t\t\twhile(inodr[i] != id) {\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\ti++;\n\t\t\tif(parent == -1) {\n\t\t\t\twhile(i < inodr.length) {\n\t\t\t\t\tr_subtree.add(inodr[i]);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(nodes[parent].l_subtree.contains(id)) {\n\t\t\t\t\twhile(i < inodr.length && nodes[parent].l_subtree.contains(inodr[i])) {\n\t\t\t\t\t\tr_subtree.add(inodr[i]);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile(i < inodr.length && nodes[parent].r_subtree.contains(inodr[i])) {\n\t\t\t\t\t\tr_subtree.add(inodr[i]);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid postOrder(Node_BT[] nodes, int[] preodr) {\n\t\t\tif(left != -1) {\n\t\t\t\tnodes[left].postOrder(nodes, preodr);\n\t\t\t}\n\t\t\tif(right != -1) {\n\t\t\t\tnodes[right].postOrder(nodes, preodr);\n\t\t\t}\n\t\t\tSystem.out.print(id + 1);\n\t\t\tif(id != preodr[0]) {\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException  e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "public class Main {\n    public static int[] pre, in, post;\n    public static int position, count;\n \n    public static void reconstruct(int left, int right) {\n        if (left >= right) return;\n        int root = pre[position++];\n        int middle = 0;\n        while (in[middle] != root) middle++;\n        reconstruct(left, middle);\n        reconstruct(middle + 1, right);\n        post[count++] = root;\n    }\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        pre = new int[n];\n        in = new int[n];\n        post = new int[n];\n        for (int i = 0; i < n; i++) pre[i] = scanner.nextInt();\n        for (int i = 0; i < n; i++) in[i] = scanner.nextInt();\n        position = 0;\n        count = 0;\n        reconstruct(0, n);\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            sb.append(post[i]);\n            sb.append(i != n - 1 ? \" \" : \"\\n\");\n        }\n        System.out.print(sb);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tfinal boolean DEBUG = false;\n\tstatic class Node {\n\t\tprivate static boolean isFirstPrint = false;\n\n\t\tint id;\n\t\tNode l, r;\n\t\tNode(int id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\tvoid printPostOrder() {\n\t\t\tisFirstPrint = true;\n\t\t\tthis.postorder();\n\t\t}\n\t\tvoid postorder() {\n\t\t\tif (this.l != null)\n\t\t\t\tthis.l.postorder();\n\t\t\tif (this.r != null)\n\t\t\t\tthis.r.postorder();\n\t\t\tSystem.out.print((isFirstPrint ? \"\" : \" \") + this.id);\n\t\t\tisFirstPrint = false;\n\t\t}\n\t}\n\tNode[] nodes;\n\tint[] preIds, inIds;\n\tint preIndex, inIndex;\n\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tnodes = new Node[n + 1];\n\t\tpreIds = new int[n];\n\t\tinIds = new int[n];\n\t\tpreIndex = inIndex = 0;\n\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tnodes[i] = new Node(i);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tpreIds[i] = scan.nextInt();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tinIds[i] = scan.nextInt();\n\n\t\tint rootId = preIds[0];\n\t\tnodes[rootId] = makeTree(inIds);\n\n\t\tnodes[rootId].printPostOrder();\n\t\tSystem.out.println();\n\t}\n\n\tNode makeTree(int[] ids) {\n\t\tif (ids.length == 0)\n\t\t\treturn null;\n\t\tif (ids.length == 1) {\n\t\t\tpreIndex++;\n\t\t\treturn nodes[ids[0]];\n\t\t}\n\t\tint rootId = preIds[preIndex++];\n\t\tint[] lIds = null, rIds = null;\n\t\tint lidx = 0, ridx = 0;\n\t\tfor (int i = 0; i < ids.length; i++) {\n\t\t\tif (rootId != ids[i])\n\t\t\t\tcontinue;\n\t\t\tlidx = i;\n\t\t\tridx = ids.length - i - 1;\n\t\t\tif (DEBUG)\n\t\t\t\tSystem.out.println(\"\\nlidx, ridx:\" + lidx + \", \" + ridx);\n\t\t\tlIds = new int[lidx];\n\t\t\trIds = new int[ridx];\n\t\t\tfor (int j = 0; j < lidx; j++)\n\t\t\t\tlIds[j] = ids[j];\n\t\t\tfor (int j = 0; j < ridx; j++)\n\t\t\t\trIds[j] = ids[i + j + 1];\n\t\t}\n\t\tif (DEBUG) {\n\t\t\tSystem.out.print(\"ids: \");\n\t\t\tfor (int i = 0; i < ids.length; i++)\n\t\t\t\tSystem.out.print(ids[i] + \" \");\n\t\t\tSystem.out.println(\"\\nrootId: \" + rootId);\n\t\t\tSystem.out.print(\"lIds: \");\n\t\t\tfor (int i = 0; i < lIds.length; i++)\n\t\t\t\tSystem.out.print(lIds[i] + \" \");\n\t\t\tSystem.out.print(\"\\nrIds: \");\n\t\t\tfor (int i = 0; i < rIds.length; i++)\n\t\t\t\tSystem.out.print(rIds[i] + \" \");\n\t\t\tSystem.out.println();\n\t\t}\n\t\tnodes[rootId].l = makeTree(lIds);\n\t\tnodes[rootId].r = makeTree(rIds);\n\t\treturn nodes[rootId];\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\n class FS {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        return hasNextByte() ? buffer[ptr++] : -1;\n    }\n\n    private boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n        skipUnprintable();\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public int nextInt() {\n        return (int) nextLong();\n    }\n\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}\npublic class Main {\n    static int[] pre;\n    static int[] in;\nstatic StringBuilder sb=new StringBuilder();\n    public static void main(String[] args) {\n        FS sc = new FS();\n        int n = sc.nextInt();\n        pre = new int[n];\n        in = new int[n];\n        for (int i = 0; i < n; i++) {\n            pre[i] = sc.nextInt();\n        }\n        for (int i = 0; i < n; i++) {\n            in[i] = sc.nextInt();\n        }\n        separate(0,n-1,0,n-1);\n        sb.deleteCharAt(sb.length()-1);\n        System.out.println(sb);\n    }\n\n    private static void separate(int i, int j,int i1,int j1) {\n        if (i>j||i1>j1)return;\n        sb.insert(0,pre[i]+\" \");\n        if (i==j||i1==j1)return;\n        int start =i+1;\n        int m=i1;\n        while (in[m]!=pre[i]){\n            m++;\n        }\n        int prelength =  m-i1;\n        int postlength = j1 - m;\n        separate(i+prelength+1,j,m+1,j1);\n        separate(start,i+prelength,i1,m-1);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint[] pre = new int[n];\n    \tfor (int i = 0; i < n; i++) {\n    \t\tpre[i] = sc.nextInt();\n    \t}\n\t\tint[] in = new int[n];\n    \tfor (int i = 0; i < n; i++) {\n    \t\tin[i] = sc.nextInt();\n    \t}\n\n    \tint[] post = new int[n];\n    \tmakePost(post, n - 1, pre, 0, in, 0, n);\n\n    \tfor (int i = 0; i < n; i++) {\n        \tSystem.out.print(\" \" + post[i]);\n    \t}\n    \tSystem.out.println(\"\");\n\n    \tsc.close();\n\t}\n\t\n\tprivate static void makePost(int[] post, int spost, int[] pre, int spre, int[] in, int sin, int n) {\n\t\tif (n < 1) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tpost[spost] = pre[spre];\n\n\t\tint i = sin;\n\t\tfor (; i < n; i++) {\n\t\t\tif (in[i] == pre[spre]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tmakePost(post, spost - 1, pre, spre + 1 + (i - sin), in, sin + 1 + (i -sin), n - (i - sin) - 1);\n\t\tmakePost(post, spost - 1 - (n - (i - sin) - 1), pre, spre + 1, in, sin, i - sin);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    static int n;\n    static List<Integer> post,ord,pre;\n    static int pos;\n    \n    public static void main(String[] args) {\n\n        // TODO Auto-generated method stub\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        post = new ArrayList<>();\n        ord = new ArrayList<>();\n        pre = new ArrayList<>();\n        for(int i = 0; i< n; i++) post.add(sc.nextInt());\n        for(int i = 0; i< n; i++) ord.add(sc.nextInt());\n        solve();\n\n\n    }\n    static void rec(int l, int r){\n        if( l >= r) return;\n        \n        int root = post.get(pos++);\n        int m = ord.indexOf(root);\n        \n        rec(l,m);\n        rec(m+1,r);\n        \n        pre.add(root);\n        \n\n        \n    }\n    \n    static void solve(){\n        pos = 0;\n        rec(0,post.size());\n        String out = \"\";\n        for(int i: pre){\n            out += i + \" \";\n        }\n        System.out.println(out.trim());\n        \n    }\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n    static StringBuilder sb = new StringBuilder(\"\");\n    static int index = 0;\n\n    public static void main (String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] preorder = new int[n];\n        int[] inorder = new int[n];\n        for (int i = 0; i < n; i++) {\n            preorder[i] = sc.nextInt();\n        }\n        for (int i = 0; i < n; i++) {\n            inorder[i] = sc.nextInt();\n        }\n        Node[] nodes = new Node[n];\n        reconstruct(nodes, preorder, inorder, 0, n);\n        sb.deleteCharAt(0);\n        System.out.println(sb);\n    }\n\n    public static int reconstruct(Node[] nodes, int[] preorder, int[] inorder, int right, int left) {\n        if (left == right) return -1;\n\n        // find root\n        int root = 0;\n        outside: for (int i = 0; i < preorder.length; i++) {\n            for (int j = right; j < left; j++) {\n                if (preorder[i] == inorder[j]) {\n                    root = j;\n                    break outside;\n                }\n            }\n        }\n        System.out.println(index);\n\n        int tempIndex = index;\n        index++;\n\n        nodes[tempIndex] = new Node(inorder[root], -1, -1);\n        nodes[tempIndex].left = reconstruct(nodes, preorder, inorder, right, root);\n        nodes[tempIndex].right = reconstruct(nodes, preorder, inorder, root + 1, left);\n\n        sb.append(\" \").append(nodes[tempIndex].id);\n\n        return tempIndex;\n    }\n}\n\nclass Node {\n    public int id;\n    public int left;\n    public int right;\n\n    public Node(int id, int left, int right) {\n        this.id = id;\n        this.left = left;\n        this.right = right;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.InputMismatchException;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tstatic class Reconstruction {\n\t\t\n\t\tstatic int n;\n\t\tstatic List<Integer> preorder, inorder, postorder;\n\t\tstatic int pos;\n\t\t\n\t\tpublic void reconstruction (InputReader ir) {\n\t\t\t\n\t\t\tn = ir.nextInt();\n\t\t\t\n\t\t\tpreorder = new ArrayList<>();\n\t\t\tinorder = new ArrayList<>();\n\t\t\tpostorder = new ArrayList<>();\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tpreorder.add(ir.nextInt());\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tinorder.add(ir.nextInt());\n\t\t\t}\n\t\t\t\n\t\t\tpos = 0;\n\t\t\tPostorder (0, n);\n\t\t\t\n\t\t\tStringBuilder sb = new StringBuilder ();\n\t\t\tsb.append(postorder.get(0));\n\t\t\t\n\t\t\tfor (int i = 1; i < n; i++) sb.append(\" \").append(postorder.get(i));\n\t\t\t\n\t\t\tSystem.out.println(sb);\n\t\t\t\n\t\t}\n\t\t\n\t\tstatic void Postorder (int i, int n) {\n\t\t\t\n\t\t\tif (i >= n) return;\n\t\t\t\n\t\t\tint root = preorder.get(pos++);\n\t\t\tint m = inorder.indexOf(root);\n\t\t\t\n\t\t\tPostorder (i, m);\n\t\t\tPostorder (m + 1, n);\n\t\t\t\n\t\t\tpostorder.add(root);\n\t\t\t\n\t\t}\n\t}\n\t\n\tstatic class InputReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\t\n\t\tpublic String nextString() {\n\t\t\t\n\t\t\t while (!st.hasMoreTokens()) {\n\t                try {\n\t                    st = new StringTokenizer(br.readLine(), \" \");\n\t                } catch (IOException e) {\n\t                    throw new InputMismatchException();\n\t                }\n\t            }\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\t\t\t\t\t\n\t\tpublic InputReader (InputStream inputStream) {\n\t\t\tbr = new BufferedReader (new InputStreamReader (inputStream));\n\t\t\tst = new StringTokenizer (\"\");\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main (String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tInputReader in = new InputReader (inputStream);\n\t\tReconstruction obj = new Reconstruction();\n\t\tobj.reconstruction(in);\n\t}\n\t\n\t\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.DataInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException, InstantiationException, IllegalAccessException {\n\t\tnew Main().exec();\n\t}\n\t\n\tpublic void exec() throws IOException, InstantiationException, IllegalAccessException {\n\t\tInputUtil in = new InputUtil();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = in.nextInt();\n\t\tint[] preOrder = in.nextInt(new int[n]);\n\t\tint[] inOrder = in.nextInt(new int[n]);\n\t\tint[] inOrderId = new int[n];\n\t\tfor(int i=0; i<n; i++) inOrderId[inOrder[i]-1] = i;\n\t\toutputPostOrder(true,out,preOrder,0,n,inOrder,0,n,inOrderId);\n\t\tout.println(\"\");\n\t\tout.flush();\n\t}\n\t\n\tprivate boolean outputPostOrder(boolean isFirst, PrintWriter out, int[] pre, int preS, int preE, int[] in, int inS, int inE, int[] inOrderId){\n\t\tif(preS==preE) return isFirst;\n\t\t\n\t\tint inOrderRootId = inOrderId[pre[preS]-1];\n\t\tint leftTreeSize = inOrderRootId - inS;\n\n\t\tisFirst = outputPostOrder(isFirst,out,\n\t\t\t\tpre,preS+1,preS+leftTreeSize+1,\n\t\t\t\tin,inS,inOrderRootId,\n\t\t\t\tinOrderId);\n\t\tisFirst = outputPostOrder(isFirst,out,\n\t\t\t\tpre,preS+leftTreeSize+1,preE,\n\t\t\t\tin,inOrderRootId+1,inE,\n\t\t\t\tinOrderId);\n\t\tif(!isFirst) out.print(' ');\n\t\tout.print(pre[preS]);\n\t\treturn false;\n\t}\n}\n\n\nclass InputUtil {\n\t//Static Fields\n\tprivate static final int BUFSIZ = 100000;\n\t\n\t//Fields\n\tprotected InputStream in;\n\tprivate byte[] buf = null;\n\tprivate int ptr = 0;\n\tprivate int max = -1;\n\tprivate DataInputStream dis = null;\n\t//Constructors\n\tpublic InputUtil() {this(System.in,BUFSIZ);}\n\tpublic InputUtil(InputStream in, int bufsiz) {\n\t\tinitBuf(bufsiz);\n\t\tinitIn(in);\n\t}\n\t\n\t//Methods\n\t//Initializer\n\tprotected void initIn(InputStream in) {dis = new DataInputStream(this.in = in);}\n\tprotected void initBuf(int bufsiz) {buf = new byte[bufsiz];}\n\t\n\t//buffer operation\n\tprivate void next() throws IOException {ptr++; readBuf();}\n\tprivate void readBuf() throws IOException {\n\t\tif(ptr >= max && dis.available()>0) {\n\t\t\tif(max>0) Arrays.fill(buf,0,max,(byte)0);\n\t\t\tmax = dis.read(buf);\n\t\t\tptr = 0;\n\t\t}\n\t}\n\t\n\t//Number Input Reader/Parser\n\tprivate boolean isNum(byte b) {return '0' <= b && b <= '9'; }\n\tprivate boolean isMinus(byte b) {return b=='-'; }\n\n\tprivate int _nextInt() throws IOException {\n\t\tint sign = 1;\n\t\tint res = 0;\n\t\tbyte c;\n\t\twhile (!isNum(c=buf[ptr]) && !isMinus(c)) \n\t\t\tnext();\n\t\tif (isMinus(buf[ptr])) {\n\t\t\tsign = -1;\n\t\t\tnext();\n\t\t}\n\t\twhile (isNum(c=buf[ptr])) {\n\t\t\tres *= 10;\n\t\t\tres += c - '0' ;\n\t\t\tnext();\n\t\t}\n\t\tnext();\n\t\treturn sign * res;\n\t}\n\t\n\tpublic int nextInt() throws IOException {\n\t\treadBuf();\n\t\treturn _nextInt();\n\t}\n\n\tpublic int[] nextInt(int[] result) throws IOException {\n\t\treadBuf();\n\t\tfor(int i=0; i<result.length; i++) {\n\t\t\tresult[i] = _nextInt();\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t//Close \n\tpublic void close() throws IOException {\n\t\tif(!this.in.equals(System.in)) \n\t\t\tthis.in.close();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\n/**\n * @see <a href='http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?lang=jp&id='>??????</a>\n */\npublic class Main {\n    private static FastReader in = new FastReader();\n\n    public static void main(String[] args) throws Exception {\n        Main main = new Main();\n        main.run();\n    }\n\n    private int[] preOrder, inOrder, postOrder;\n    private int pos = 0, count = 0;\n\n    private void run() {\n        int n = in.nextInt();\n        preOrder = in.nextIntArray(n);\n        inOrder = in.nextIntArray(n);\n        postOrder = new int[n];\n\n        restore(0, n);\n        System.out.println(Stream.of(postOrder).map(String::valueOf)\n                        .collect(Collectors.joining(\" \")));\n    }\n\n    private void restore(int left, int right) {\n        if (left >= right) return;\n        int root = preOrder[pos++];\n        int middle = 0;\n        while (inOrder[middle] != root) {\n            middle++;\n        }\n        restore(left, middle);\n        restore(middle + 1, right);\n        postOrder[count++] = root;\n    }\n}\n\nclass FastReader {\n    private InputStream in = System.in;\n    private byte[] buf = new byte[1024];\n    private int charNum;\n    private int charLen;\n    private StringBuilder sb = new StringBuilder();\n\n    public int read() {\n        if (charLen == -1)\n            throw new InputMismatchException();\n        if (charNum >= charLen) {\n            charNum = 0;\n            try {\n                charLen = in.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (charLen <= 0)\n                return -1;\n        }\n        return buf[charNum++];\n    }\n\n    public String next() {\n        int c = read();\n        while (isWhitespace(c)) {\n            c = read();\n        }\n        sb.setLength(0);\n        do {\n            sb.appendCodePoint(c);\n            c = read();\n        } while (!isWhitespace(c));\n        return sb.toString();\n    }\n\n    public char[] nextCharArray() {\n        return next().toCharArray();\n    }\n\n    public int nextInt() {\n        return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n        int[] array = new int[n];\n        for (int i = 0; i < n; i++)\n            array[i] = nextInt();\n        return array;\n    }\n\n    public List<Integer> nextIntList(int n) {\n        Integer[] array = new Integer[n];\n        for (int i = 0; i < n; i++)\n            array[i] = nextInt();\n        return Arrays.asList(array);\n    }\n\n    public int[][] nextIntArray2D(int n, int m) {\n        int[][] array = new int[n][m];\n        for (int i = 0; i < n; i++)\n            array[i] = nextIntArray(m);\n        return array;\n    }\n\n    public List<int[]> nextIntsList(int n, int m) {\n        List<int[]> list = new ArrayList<int[]>(n);\n        for (int i = 0; i < n; i++)\n            list.add(nextIntArray(m));\n        return list;\n    }\n\n    public long nextLong() {\n        int c = read();\n        while (isWhitespace(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isWhitespace(c));\n        return res * sgn;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public double[] nextDoubleArray(int n) {\n        double[] array = new double[n];\n        for (int i = 0; i < n; i++)\n            array[i] = nextDouble();\n        return array;\n    }\n\n    public boolean isWhitespace(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static int reconstruction(final int n, final int pre_pos, final int in_start, final int in_end, int[] pre_order, int[] in_order, int[] n_left, int[] n_right){\n\t\tfinal int partition = pre_order[pre_pos];\n\t\t\n\t\t//System.out.println(pre_pos + \"[\" + pre_order[pre_pos] + \"] \" + in_start + \" \" + in_end + \" (\" + (partition + 1) + \")\");\n\t\t\n\t\tif(in_start + 1 >= in_end){\n\t\t\treturn partition;\n\t\t}\n\t\t\n\t\t//System.out.println(\"> \" + pre_pos + \" \" + in_start + \" \" + in_end + \" [\" + (partition + 1) + \"]\");\n\t\t\n\t\tfor(int in_pos = in_start; in_pos < in_end; in_pos++){\n\t\t\tif(in_order[in_pos] == partition){\n\t\t\t\tif(in_start < in_pos){\n\t\t\t\t\tn_left[partition] = reconstruction(n, pre_pos + 1, in_start, in_pos, pre_order, in_order, n_left, n_right);\n\t\t\t\t}else{\n\t\t\t\t\tn_left[partition] = -1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tn_right[partition] = reconstruction(n, pre_pos + (in_pos - in_start + 1), in_pos + 1, in_end, pre_order, in_order, n_left, n_right);\n\t\t\t\t//System.out.println(n_left[in_pos] + \"<-\" + partition + \"->\" + n_right[in_pos]);\n\t\t\t\treturn partition;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn partition;\n\t}\n\t\n\tpublic static void postorder(int node, int[] n_left, int[] n_right, LinkedList<Integer> list){\n\t\tif(n_left[node]  != -1){ postorder(n_left[node] , n_left, n_right, list); }\n\t\tif(n_right[node] != -1){ postorder(n_right[node], n_left, n_right, list); }\n\t\tlist.add(node);\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int n = sc.nextInt();\n\t\tint[] pre_order = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpre_order[i] = sc.nextInt() - 1;\n\t\t}\n\t\tint[] in_order = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tin_order[i] = sc.nextInt()  - 1;\n\t\t}\n\t\t\n\t\tint[] n_left = new int[n];\n\t\tint[] n_right = new int[n];\n\t\tArrays.fill(n_left, -1);\n\t\tArrays.fill(n_right, -1);\n\t\t\n\t\tfinal int root = reconstruction(n, 0, 0, n, pre_order, in_order, n_left, n_right);\n\t\t//System.out.println(root);\n\t\tLinkedList<Integer> list = new LinkedList<Integer>();\n\t\t//System.out.println(Arrays.toString(n_left));\n\t\t//System.out.println(Arrays.toString(n_right));\n\t\tpostorder(root, n_left, n_right, list);\n\t\tboolean first = true;\n\t\tfor(int num : list){\n\t\t\tif(first){ first = false; }\n\t\t\telse{ System.out.print(\" \"); }\n\t\t\tSystem.out.print(num + 1);\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tpublic static class Scanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n\tpublic static void main(String[] args){\n\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tNodes mynodes = new Nodes();\n\t\tNode[] nodes = new Node[n];\n\t\tmynodes.nodes = nodes;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tnodes[i] = new Node(i);\n\n\t\tint[] pre = new int[n];\n\t\tint[] in = new int[n];\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tpre[i] = scan.nextInt();\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tin[i] = scan.nextInt();\n\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(in[j] == pre[i-1]){\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(in[j] == pre[i]){\n\t\t\t\t\tmynodes.setLeft(pre[i-1], pre[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(pre[j] == in[i-1]){\n\t\t\t\t\tmynodes.setRight(in[i-1], mynodes.getRoot(in[i]));\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(pre[j] == in[i]){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint root = 0;\n\t\twhile(nodes[root].parent != -1)\n\t\t\troot = nodes[root].parent;\n\n\t\tmynodes.printPost(root);\n\t\tSystem.out.print(\"\\n\");\n\t}\n}\n\nclass Node{\n\tint id;\n\tint parent, left, right;\n\tpublic Node(int id){\n\t\tthis.id = id;\n\t\tthis.parent = -1;\n\t\tthis.left = -1;\n\t\tthis.right = -1;\n\t}\n}\n\nclass Nodes{\n\n\tNode[] nodes;\n\n\tpublic int getRoot(int id){\n\t\tif(nodes[id].parent == -1)\n\t\t\treturn id;\n\t\treturn getRoot(nodes[id].parent);\n\t}\n\n\tboolean first = true;\n\n\tpublic void printPost(int id){\n\t\tif(id == -1)\n\t\t\treturn;\n\t\tprintPost(nodes[id].left);\n\t\tprintPost(nodes[id].right);\n\t\tif(first){\n\t\t\tSystem.out.print(id);\n\t\t\tfirst = false;\n\t\t}else{\n\t\t\tSystem.out.print(\" \" + id);\n\t\t}\n\t}\n\n\tpublic void setLeft(int id, int left){\n\t\tnodes[id].left = left;\n\t\tnodes[left].parent = id;\n\t}\n\n\tpublic void setRight(int id, int right){\n\t\tnodes[id].right = right;\n\t\tnodes[right].parent = id;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tfinal boolean DEBUG = false;\n\tint[] preIds, inIds, posIds;\n\tint preIndex, inIndex, posIndex;\n\t\n\tint prev, pos;\n\tint location(int l, int r, int id) {\n\t\tfor (int i = l; i < r; i++)\n\t\t\tif (inIds[i] == id) return i;\n\t\treturn -1;\n\t}\n\n\tvoid tree(int l, int r) {\n\t\tif (l < r) {\n\t\t\tint root = preIds[preIndex++];\n\t\t\tint m = location(l, r, root);\n\t\t\ttree(l, m);\n\t\t\ttree(m + 1, r);\n\t\t\tposIds[posIndex++] = root;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tpreIds = new int[n];\n\t\tinIds =  new int[n];\n\t\tposIds = new int[n];\n\t\tpreIndex = inIndex = posIndex = 0;\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tpreIds[i] = scan.nextInt();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tinIds[i] = scan.nextInt();\n\t\ttree(0, n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tSystem.out.print(posIds[i] + (i == n - 1 ? \"\\n\" : \" \"));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new\n\t\t// File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\ALDS1_6_A-in9.txt\"));\n\n\t\tint n = scan.nextInt();\n\t\tTree t = new Tree(n + 1);\n\t\tint[] pre = new int[n];\n\t\tint[] in = new int[n];\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tpre[i] = scan.nextInt();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tin[i] = scan.nextInt();\n\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (in[j] == pre[i]) {\n\t\t\t\t\tt.setLeftChild(pre[i - 1], pre[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (in[j] == pre[i - 1])\n\t\t\t\t\tbreak;\n\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (pre[j] == in[i])\n\t\t\t\t\tbreak;\n\t\t\t\telse if (pre[j] == in[i - 1]) {\n\t\t\t\t\tt.setRightChild(in[i - 1], t.getRoot(in[i]));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t// System.out.print(\"Preorder\\n\");\n\t\t// t.printPre(t.getRoot());\n\t\t// System.out.print(\"\\nInorder\\n\");\n\t\t// t.printIn(t.getRoot());\n\t\t// System.out.print(\"\\nPostorder\\n\");\n\t\tt.printPost(t.getRoot());\n\t\tSystem.out.print(\"\\n\");\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Tree {\n\tprivate class Node {\n\t\tint Parent = -1;\n\t\tint LeftChild = -1;\n\t\tint RightChild = -1;\n\n\t\tpublic int getDepth() {\n\t\t\tif (Parent == -1)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn (node[Parent].getDepth() + 1);\n\t\t}\n\n\t\tpublic String getType() {\n\t\t\tif (Parent == -1)\n\t\t\t\treturn \"root\";\n\t\t\telse if (LeftChild == -1 && RightChild == -1)\n\t\t\t\treturn \"leaf\";\n\t\t\telse\n\t\t\t\treturn \"internal node\";\n\t\t}\n\n\t\tpublic int getSib(int id) {\n\t\t\tif (Parent == -1)\n\t\t\t\treturn -1;\n\t\t\telse if (node[Parent].LeftChild == id)\n\t\t\t\treturn (node[Parent].RightChild);\n\t\t\telse\n\t\t\t\treturn (node[Parent].LeftChild);\n\t\t}\n\n\t\tpublic int getDegree() {\n\t\t\tint r = 2;\n\t\t\tif (LeftChild == -1)\n\t\t\t\tr--;\n\t\t\tif (RightChild == -1)\n\t\t\t\tr--;\n\t\t\treturn r;\n\t\t}\n\n\t\tpublic int getHeight() {\n\t\t\tif (getDegree() == 0)\n\t\t\t\treturn 0;\n\t\t\tint l = 0, r = 0;\n\t\t\tif (LeftChild != -1)\n\t\t\t\tl = node[LeftChild].getHeight();\n\t\t\tif (RightChild != -1)\n\t\t\t\tr = node[RightChild].getHeight();\n\t\t\treturn Math.max(l, r) + 1;\n\t\t}\n\t}\n\n\tprivate Node[] node;\n\n\tpublic Tree(int n) {\n\t\tnode = new Node[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnode[i] = new Node();\n\t\t}\n\t}\n\n\tpublic int getParent(int id) {\n\t\treturn node[id].Parent;\n\t}\n\n\tboolean x = true;\n\n\tpublic void printPost(int id) {\n\t\tif (id == -1)\n\t\t\treturn;\n\t\tprintPost(node[id].LeftChild);\n\t\tprintPost(node[id].RightChild);\n\t\tif (x)\n\t\t\tSystem.out.print(id);\n\t\telse\n\t\t\tSystem.out.print(\" \" + id);\n\t\tx = false;\n\t}\n\n\tpublic void printIn(int id) {\n\t\tif (id == -1)\n\t\t\treturn;\n\t\tprintIn(node[id].LeftChild);\n\t\tSystem.out.print(\" \" + id);\n\t\tprintIn(node[id].RightChild);\n\t}\n\n\tpublic void printPre(int id) {\n\t\tif (id == -1)\n\t\t\treturn;\n\t\tSystem.out.print(\" \" + id);\n\t\tprintPre(node[id].LeftChild);\n\t\tprintPre(node[id].RightChild);\n\t}\n\n\tpublic int getRoot() {\n\t\treturn getRoot(1);\n\t}\n\n\tpublic int getRoot(int id) {\n\t\tif (node[id].Parent == -1)\n\t\t\treturn id;\n\t\telse\n\t\t\treturn getRoot(node[id].Parent);\n\t}\n\n\tpublic void setRightChild(int id, int c) {\n\t\tnode[id].RightChild = c;\n\t\tif (c != -1)\n\t\t\tnode[c].Parent = id;\n\t}\n\n\tpublic void setLeftChild(int id, int c) {\n\t\tnode[id].LeftChild = c;\n\t\tif (c != -1)\n\t\t\tnode[c].Parent = id;\n\t}\n\n\tpublic void printDetail(int id) {\n\t\tSystem.out.println(\"node \" + id + \": parent = \" + node[id].Parent + \", sibling = \" + node[id].getSib(id)\n\t\t\t\t+ \", degree = \" + node[id].getDegree() + \", depth = \" + node[id].getDepth() + \", height = \"\n\t\t\t\t+ node[id].getHeight() + \", \" + node[id].getType());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * @see <a href='http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?lang=jp&id='>??????</a>\n */\npublic class Main {\n    private static FastReader in = new FastReader();\n\n    public static void main(String[] args) throws Exception {\n        Main main = new Main();\n        main.run();\n    }\n\n    private int[] preOrder, inOrder, postOrder;\n    private int pos = 0, count = 0;\n\n    private void run() {\n        int n = in.nextInt();\n        preOrder = in.nextIntArray(n);\n        inOrder = in.nextIntArray(n);\n        postOrder = new int[n];\n\n        restore(0, n);\n        System.out.println(Arrays.stream(postOrder)\n                .mapToObj(String::valueOf)\n                .collect(Collectors.joining(\" \")));\n    }\n\n    private void restore(int left, int right) {\n        if (left >= right) return;\n        int root = preOrder[pos++];\n        int middle = 0;\n        while (inOrder[middle] != root) {\n            middle++;\n        }\n        restore(left, middle);\n        restore(middle + 1, right);\n        postOrder[count++] = root;\n    }\n}\n\nclass FastReader {\n    private InputStream in = System.in;\n    private byte[] buf = new byte[1024];\n    private int charNum;\n    private int charLen;\n    private StringBuilder sb = new StringBuilder();\n\n    public int read() {\n        if (charLen == -1)\n            throw new InputMismatchException();\n        if (charNum >= charLen) {\n            charNum = 0;\n            try {\n                charLen = in.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (charLen <= 0)\n                return -1;\n        }\n        return buf[charNum++];\n    }\n\n    public String next() {\n        int c = read();\n        while (isWhitespace(c)) {\n            c = read();\n        }\n        sb.setLength(0);\n        do {\n            sb.appendCodePoint(c);\n            c = read();\n        } while (!isWhitespace(c));\n        return sb.toString();\n    }\n\n    public char[] nextCharArray() {\n        return next().toCharArray();\n    }\n\n    public int nextInt() {\n        return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n        int[] array = new int[n];\n        for (int i = 0; i < n; i++)\n            array[i] = nextInt();\n        return array;\n    }\n\n    public List<Integer> nextIntList(int n) {\n        Integer[] array = new Integer[n];\n        for (int i = 0; i < n; i++)\n            array[i] = nextInt();\n        return Arrays.asList(array);\n    }\n\n    public int[][] nextIntArray2D(int n, int m) {\n        int[][] array = new int[n][m];\n        for (int i = 0; i < n; i++)\n            array[i] = nextIntArray(m);\n        return array;\n    }\n\n    public List<int[]> nextIntsList(int n, int m) {\n        List<int[]> list = new ArrayList<int[]>(n);\n        for (int i = 0; i < n; i++)\n            list.add(nextIntArray(m));\n        return list;\n    }\n\n    public long nextLong() {\n        int c = read();\n        while (isWhitespace(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isWhitespace(c));\n        return res * sgn;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public double[] nextDoubleArray(int n) {\n        double[] array = new double[n];\n        for (int i = 0; i < n; i++)\n            array[i] = nextDouble();\n        return array;\n    }\n\n    public boolean isWhitespace(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n\tpublic static void main(String[] args){\n\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tNodes mynodes = new Nodes();\n\t\tNode[] nodes = new Node[n];\n\t\tmynodes.nodes = nodes;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tnodes[i] = new Node(i);\n\n\t\tint[] pre = new int[n];\n\t\tint[] in = new int[n];\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tpre[i] = scan.nextInt();\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tin[i] = scan.nextInt();\n\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(in[j] == pre[i-1]){\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(in[j] == pre[i]){\n\t\t\t\t\tmynodes.setLeft(pre[i-1], pre[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(pre[j] == in[i-1]){\n\t\t\t\t\tmynodes.setRight(in[i-1], mynodes.getRoot(in[i]));\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(pre[j] == in[i]){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint root = 0;\n\t\twhile(nodes[root].parent != -1)\n\t\t\troot = nodes[root].parent;\n\n\t\tmynodes.printPost(root);\n\t\tSystem.out.println();\n\t}\n}\n\nclass Node{\n\tint id;\n\tint parent, left, right;\n\tpublic Node(int id){\n\t\tthis.id = id;\n\t\tthis.parent = -1;\n\t\tthis.left = -1;\n\t\tthis.right = -1;\n\t}\n}\n\nclass Nodes{\n\n\tNode[] nodes;\n\n\tpublic int getRoot(int id){\n\t\tif(nodes[id].parent == -1)\n\t\t\treturn id;\n\t\treturn getRoot(nodes[id].parent);\n\t}\n\n\tboolean first = true;\n\n\tpublic void printPost(int id){\n\t\tif(id == -1)\n\t\t\treturn;\n\t\tprintPost(nodes[id].left);\n\t\tprintPost(nodes[id].right);\n\t\tif(first){\n\t\t\tSystem.out.print(id);\n\t\t\tfirst = false;\n\t\t}else{\n\t\t\tSystem.out.print(\" \" + id);\n\t\t}\n\t}\n\n\tpublic void setLeft(int id, int left){\n\t\tnodes[id].left = left;\n\t\tnodes[left].parent = id;\n\t}\n\n\tpublic void setRight(int id, int right){\n\t\tnodes[id].right = right;\n\t\tnodes[right].parent = id;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.Arrays;\n\npublic class Main {\n    class Node {\n        int id;\n        int left = -1, right = -1;\n        String nodeType = null;\n        Node(int id, int left, int right) {\n            this.id = id;\n            this.left = left;\n            this.right = right;\n        }\n        void print() {\n            System.out.println(id + \", \" + left + \", \" + right);\n        }\n    }\n    int[] result;\n    int resultIndex;\n    void postorder(Node[] nodes, int x) {\n        if (nodes[x].left != -1)\n            postorder(nodes, nodes[x].left);\n        if (nodes[x].right != -1)\n            postorder(nodes, nodes[x].right);\n        result[resultIndex++] = x;\n    }\n\n    Node[] nodes;\n    int[] pre;\n    int[] in;\n    int ap;\nint search(int b1p, int b2p) {\n        int center = -1;\n        if (ap >= pre.length) {\n            return -1;\n        }\n        int top = pre[ap];\n        if (b1p + 1 == b2p) {\n            nodes[top] = new Node(top, -1, -1);\n            return top;\n        } else if (b1p >= b2p) {\n            return -1;\n        }\n        for (int i = b1p; i < b2p; i++) {\n            if (top == in[i]) {\n                center = i;\n                break;\n            }\n        }\n        ap++;\n        int left = search(b1p, center);\n        if (left != -1) ap++;\n        int right = search(center+1, b2p);\n        nodes[top] = new Node(top, left, right);\n        return top;\n    }\n void run() {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        nodes = new Node[n+1];\n        pre = new int[n];\n        in  = new int[n];\n        int root = 0;\n        for (int i = 0; i < n; i++) {\n            int id = sc.nextInt();\n            if (i == 0) root = id;\n            pre[i] = id;\n        }\n        for (int i = 0; i < n; i++) {\n            int id = sc.nextInt();\n            in[i] = id;\n        }\n        search(0, nodes.length);\n        result = new int[n];\n        resultIndex = 0;\n        postorder(nodes, root);\n        System.out.print(result[0]);\n        for (int i = 1; i < result.length; i++) {\n            System.out.print(\" \" + result[i]);\n        }\n        System.out.println();\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.ArrayList;\npublic class Main {\n    public static void main (String[] args) {\n\tScanner scan = new Scanner(System.in);\n\tint n = Integer.parseInt(scan.nextLine());\n\tint[] preorder = new int[n];\n\tint[] inorder = new int[n];\n\tString[] inputPre, inputIn;\n\tinputPre = scan.nextLine().split(\" \");\n\tinputIn = scan.nextLine().split(\" \");\n\tfor (int i = 0; i < n; i++) {\n\t    preorder[i] = Integer.parseInt(inputPre[i]);\n\t    inorder[i] = Integer.parseInt(inputIn[i]);\n\t}\n\tReconstructer recnst = new Reconstructer(preorder, inorder);\n\trecnst.runReconstruct();\n\trecnst.printPostorder();\n    }\n}\nclass Reconstructer {\n    int[] preorder;\n    int[] inorder;\n    int[] postorder;\n    int prePosition, postPosition;\n    Reconstructer (int[] preorder, int[] inorder) {\n\tthis.preorder = preorder;\n\tthis.inorder = inorder;\n\tpostorder = new int[preorder.length];\n    }\n    void runReconstruct () {\n\treconstruct(0, preorder.length);\n    }\n    void reconstruct (int left, int right) {\n\tif (left >= right) {\n\t    return;\n\t}\t\n\tint inPosition = 0;\n\tint node = preorder[prePosition++];\n\twhile (node != inorder[inPosition]) {\n\t    inPosition++;\n\t}\n\treconstruct(left, inPosition);\n\treconstruct(inPosition+1, right);\n\tpostorder[postPosition++] = node;\n    }\n    void printPostorder () {\n\tStringBuilder sb = new StringBuilder();\n\tint n = postorder.length;\n\tfor (int i = 0; i < n - 1; i++) {\n\t    sb.append(postorder[i] + \" \");\n\t}\n\tsb.append(postorder[n-1] + \"\\n\");\n\tSystem.out.print(sb);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n \npublic class Main {\n    public static int[] pre, in, post;\n    public static int position, count;\n \n    public static void reconstruct(int left, int right) {\n        if (left >= right) return;\n        int root = pre[position++];\n        int middle = 0;\n        while (in[middle] != root) middle++;\n        reconstruct(left, middle);\n        reconstruct(middle + 1, right);\n        post[count++] = root;\n    }\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        pre = new int[n];\n        in = new int[n];\n        post = new int[n];\n        for (int i = 0; i < n; i++) pre[i] = scanner.nextInt();\n        for (int i = 0; i < n; i++) in[i] = scanner.nextInt();\n        position = 0;\n        count = 0;\n        reconstruct(0, n);\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            sb.append(post[i]);\n            sb.append(i != n - 1 ? \" \" : \"\\n\");\n        }\n        System.out.print(sb);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tBufferedReader br =\n\t\t\t\tnew BufferedReader( new InputStreamReader(System.in) );\n\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tString[] prestr = br.readLine().split(\" \");\n\t\tString[] instr = br.readLine().split(\" \");\n\n\t\tint[] preorderTreeWalk = new int[n];\n\t\tint[] inorderTreeWalk = new int[n];\n\t\tfor (int i=0; i < n; i++) {\n\t\t\tpreorderTreeWalk[i] = Integer.parseInt(prestr[i]);\n\t\t\tinorderTreeWalk[i] = Integer.parseInt(instr[i]);\n\t\t}\n//\t\tprestr = instr = null;\n\t\tTree t = new Tree(preorderTreeWalk, inorderTreeWalk);\n\n\t\tString ans = postorder(t).trim();\n\t\tSystem.out.println(ans);\n\t}\n\n\tpublic static class Tree {\n\t\tint root;\n\n\t\tTree leftSubTree;\n\n\t\tTree rightSubTree;\n\n\t\tpublic Tree(int[] pre, int[] in) {\n\t\t\troot = pre[0];\n\n\t\t\tint index = 0; // InorderTreeWalk ?????¨?????????in??§????????? root ??§??????????´??????????????????????\n\t\t\tfor (int i=0; i < in.length; i++) {\n\t\t\t\tif (in[i] == root) {\n\t\t\t\t\tindex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (index != 0) {\n\t\t\t\tint[] leftSubTreeOfIn = Arrays.copyOfRange(in, 0, index);\n\t\t\t\tint[] leftSubTreeOfPre = Arrays.copyOfRange(pre, 1, index+1);\n\t\t\t\tleftSubTree = new Tree(leftSubTreeOfPre, leftSubTreeOfIn);\n\t\t\t}\n\n\t\t\tif (index != in.length-1) {\n\t\t\t\tint[] rightSubTreeOfPre = Arrays.copyOfRange(pre, index+1, pre.length);\n\t\t\t\tint[] rightSubTreeOfIn = Arrays.copyOfRange(in, index+1, in.length);\n\t\t\t\trightSubTree = new Tree(rightSubTreeOfPre, rightSubTreeOfIn);\n\t\t\t}\n//\t\t\tfor (int i=0; i < index; i++) {\n//\t\t\t\tleftsubTreeOfin[i] = in[i];\n//\t\t\t}\n//\t\t\tfor (int i=0; i < in.length-1-index; i++) {\n//\t\t\t\trightsubTreeOfin[i] = in[index+1+i];\n//\t\t\t}\n\t\t}\n\t}\n\n\tpublic static String postorder(Tree t) {\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tif (t.leftSubTree != null) {\n\t\t\tString s = postorder(t.leftSubTree);\n\t\t\tsb.append(s);\n\t\t}\n\n\t\tif (t.rightSubTree != null) {\n\t\t\tString s = postorder(t.rightSubTree);\n\t\t\tsb.append(s);\n\t\t}\n\n\t\treturn sb.append(t.root + \" \").toString();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\n\npublic class Main {\n\n    int n;\n    Integer[] pre;\n    Integer[] in;\n    int preCount;\n    List<Integer> postorderList = new ArrayList<>();\n\n    void run() {\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n\n        pre = new Integer[n];\n        in = new Integer[n];\n        \n        for (int i = 0; i < n; i++) {\n            pre[i] = sc.nextInt();\n        }\n\n        for (int i = 0; i < n; i++) {\n            in[i] = sc.nextInt();\n        }\n\n        preCount = 0;\n        reconstruction(0, n);\n        System.out.println(postorderList.stream().map(String::valueOf).collect(Collectors.joining(\" \")));\n    }\n\n\n\n    void reconstruction(int l, int r) {\n        if (l >= r) return;\n        int c = pre[preCount++];\n        int m = Arrays.asList(in).indexOf(c);\n//        System.out.println(c + \", \" + m);\n        reconstruction(l, m);\n        reconstruction(m + 1, r);\n        postorderList.add(c);\n    }\n\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t * @throws NumberFormatException \n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\t\n\t\tString[] tmpArray = br.readLine().split(\" \");\n\t\tNode[] nodes = new Node[n];\n\t\tint[] pre = new int[n];\n\t\tfor(int i = 0; i < n ; i++){\n\t\t\tpre[i] = Integer.parseInt(tmpArray[i]) - 1;\n\t\t\tnodes[i] = new Node(i, -1, -1);\n\t\t\tnodes[i].nodes = nodes;\n\t\t}\n\t\ttmpArray = br.readLine().split(\" \");\n\t\tint[] in = new int[n];\n\t\tfor(int i = 0; i < n ; i++){\n\t\t\tin[i] = Integer.parseInt(tmpArray[i]) - 1;\n\t\t}\n\t\t\n\t\treconstruct(nodes, pre, in);\n\t\t\n\t\t//root??¢???\n\t\tint rootIdx = -1;\n\t\tfor(int i = 0; i < nodes.length ;i++){\n\t\t\tif(nodes[i].parent == -1){\n\t\t\t\trootIdx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trootIndex = rootIdx;\n\t\t\n\t\tpostorder(nodes, rootIdx, 1);\n\t\tSystem.out.println();\n\n\t}\n\t\n\tstatic int reconstruct(Node[] nodes, int[] pre, int[] in){\n\t\tif(pre.length ==1 || in.length == 1){\n\t\t\treturn pre[0];\n\t\t}\n\t\t//???????????????pre[0]???????????????\n\t\tint rootIndex = pre[0];\n\t\tint subLen = 0;\n\t\tfor(int i = 0; i < in.length ; i++){\n\t\t\tif(in[i] == pre[0]){\n\t\t\t\tsubLen = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint leftIndex = -1;\n\t\tint rightIndex = -1;\n\t\t//?????´?????¨?????¨\n\t\tif(subLen >= 1){\n\t\t\tleftIndex = reconstruct(nodes, Arrays.copyOfRange(pre, 1, 1 + subLen), Arrays.copyOfRange(in, 0, subLen));\n\t\t}\n\t\t//?????´?????¨?????¨\n\t\tif(in.length - subLen - 1 >= 1){\n\t\t\trightIndex = reconstruct(nodes, Arrays.copyOfRange(pre, subLen + 1, pre.length), Arrays.copyOfRange(in, subLen + 1, pre.length));\n\t\t}\n\t\t\n\t\tnodes[rootIndex].left = leftIndex;\n\t\tnodes[rootIndex].right = rightIndex;\n\t\treturn rootIndex;\n\t}\n\t\n\tstatic int rootIndex = -1;\n\tstatic void postorder(Node[] nodes, int index){\n\t\tif(nodes[index].left != -1){\n\t\t\tpostorder(nodes, nodes[index].left);\n\t\t}\n\t\tif(nodes[index].right != -1){\n\t\t\tpostorder(nodes, nodes[index].right);\n\t\t}\t\t\n\t}\n\tstatic void postorder(Node[] nodes, int index, int fix){\n\t\tif(nodes[index].left != -1){\n\t\t\tpostorder(nodes, nodes[index].left, fix);\n\t\t}\n\t\tif(nodes[index].right != -1){\n\t\t\tpostorder(nodes, nodes[index].right, fix);\n\t\t}\t\t\n\t\tSystem.out.print((nodes[index].id+fix));\n\t\t\n\t\tif(index != rootIndex){\n\t\t\tSystem.out.print(\" \");\n\t\t}\n\t}\n}\n\nclass Node {\n\tint id;\n\tint left = -1;\n\tint right = -1;\n\tint parent = -1;\n\tint sibling = -1;\n\tint degree = 0;\n\tNode[] nodes;\n\t\n\tpublic Node (int id, int left, int right){\n\t\tthis.id =id;\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t}\n\t\n\tint getDepth (){\n\t\tif(parent == -1){\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1 + nodes[parent].getDepth();\n\t}\n\t\n\tint getHeight (){\n\t\tif(left == -1 && right == -1){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint heightL = 0;\n\t\tif(left != -1){\n\t\t\theightL = nodes[left].getHeight();\n\t\t}\n\t\t\n\t\tint heightR = 0;\n\t\tif(right != -1){\n\t\t\theightR = nodes[right].getHeight();\n\t\t}\n\t\t\n\t\treturn Math.max(heightL, heightR) + 1;\n\t}\n\t\n\tString getType (){\n\t\tif(parent == -1){\n\t\t\treturn \"root\";\n\t\t}\n\t\telse if(left == -1 && right == -1){\n\t\t\treturn \"leaf\";\n\t\t}\n\t\telse {\n\t\t\treturn \"internal node\";\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t * @throws NumberFormatException \n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\t\n\t\tString[] tmpArray = br.readLine().split(\" \");\n\t\tNode[] nodes = new Node[n];\n\t\tint[] pre = new int[n];\n\t\tfor(int i = 0; i < n ; i++){\n\t\t\tpre[i] = Integer.parseInt(tmpArray[i]) - 1;\n\t\t\tnodes[i] = new Node(i, -1, -1);\n\t\t\tnodes[i].nodes = nodes;\n\t\t}\n\t\ttmpArray = br.readLine().split(\" \");\n\t\tint[] in = new int[n];\n\t\tfor(int i = 0; i < n ; i++){\n\t\t\tin[i] = Integer.parseInt(tmpArray[i]) - 1;\n\t\t}\n\t\t\n\t\tint rootIdx = reconstruct(nodes, pre, in);\n\t\t\n\t\t//root??¢???\n\t\t/*\n\t\tint rootIdx = -1;\n\t\tfor(int i = 0; i < nodes.length ;i++){\n\t\t\tif(nodes[i].parent == -1){\n\t\t\t\trootIdx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t*/\n\t\trootIndex = rootIdx;\n\t\t\n\t\tpostorder(nodes, rootIdx, 1);\n\t\tSystem.out.println();\n\n\t}\n\t\n\tstatic int reconstruct(Node[] nodes, int[] pre, int[] in){\n\t\tSystem.out.print(\"pre \");\n\t\tfor(int i = 0; i < pre.length ; i++){\n\t\t\tSystem.out.print(pre[i] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tSystem.out.print(\"in \");\n\t\tfor(int i = 0; i < in.length ; i++){\n\t\t\tSystem.out.print(in[i] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tif(pre.length ==1 || in.length == 1){\n\t\t\treturn pre[0];\n\t\t}\n\t\t//???????????????pre[0]???????????????\n\t\tint rootIndex = pre[0];\n\t\tint subLen = 0;\n\t\tfor(int i = 0; i < in.length ; i++){\n\t\t\tif(in[i] == pre[0]){\n\t\t\t\tsubLen = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint leftIndex = -1;\n\t\tint rightIndex = -1;\n\t\t//?????´?????¨?????¨\n\t\tif(subLen >= 1){\n\t\t\tleftIndex = reconstruct(nodes, Arrays.copyOfRange(pre, 1, 1 + subLen), Arrays.copyOfRange(in, 0, subLen));\n\t\t}\n\t\t//?????´?????¨?????¨\n\t\tif(in.length - subLen - 1 >= 1){\n\t\t\trightIndex = reconstruct(nodes, Arrays.copyOfRange(pre, subLen + 1, pre.length), Arrays.copyOfRange(in, subLen + 1, pre.length));\n\t\t}\n\t\t\n\t\tnodes[rootIndex].left = leftIndex;\n\t\tnodes[rootIndex].right = rightIndex;\n\t\tSystem.out.println(\"left \"+leftIndex + \"right \"+ rightIndex);\n\t\treturn rootIndex;\n\t}\n\t\n\tstatic int rootIndex = -1;\n\tstatic void postorder(Node[] nodes, int index){\n\t\tif(nodes[index].left != -1){\n\t\t\tpostorder(nodes, nodes[index].left);\n\t\t}\n\t\tif(nodes[index].right != -1){\n\t\t\tpostorder(nodes, nodes[index].right);\n\t\t}\t\t\n\t}\n\tstatic void postorder(Node[] nodes, int index, int fix){\n\t\tif(nodes[index].left != -1){\n\t\t\tpostorder(nodes, nodes[index].left, fix);\n\t\t}\n\t\tif(nodes[index].right != -1){\n\t\t\tpostorder(nodes, nodes[index].right, fix);\n\t\t}\t\t\n\t\tSystem.out.print((nodes[index].id+fix));\n\t\t\n\t\tif(index != rootIndex){\n\t\t\tSystem.out.print(\" \");\n\t\t}\n\t}\n}\n\nclass Node {\n\tint id;\n\tint left = -1;\n\tint right = -1;\n\tint parent = -1;\n\tint sibling = -1;\n\tint degree = 0;\n\tNode[] nodes;\n\t\n\tpublic Node (int id, int left, int right){\n\t\tthis.id =id;\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t}\n\t\n\tint getDepth (){\n\t\tif(parent == -1){\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1 + nodes[parent].getDepth();\n\t}\n\t\n\tint getHeight (){\n\t\tif(left == -1 && right == -1){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint heightL = 0;\n\t\tif(left != -1){\n\t\t\theightL = nodes[left].getHeight();\n\t\t}\n\t\t\n\t\tint heightR = 0;\n\t\tif(right != -1){\n\t\t\theightR = nodes[right].getHeight();\n\t\t}\n\t\t\n\t\treturn Math.max(heightL, heightR) + 1;\n\t}\n\t\n\tString getType (){\n\t\tif(parent == -1){\n\t\t\treturn \"root\";\n\t\t}\n\t\telse if(left == -1 && right == -1){\n\t\t\treturn \"leaf\";\n\t\t}\n\t\telse {\n\t\t\treturn \"internal node\";\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    \n    static int n, pos;\n    static int[] pre, in;\n    static List<Integer> post;\n\n    public static void main(String[] args) {\n        \n        Scanner sc = new Scanner(System.in);\n        \n        n = Integer.parseInt(sc.next());\n        pre = new int[n];\n        in = new int[n];\n        post = new ArrayList<>();\n        for(int i = 0; i < n; i++){\n            pre[i] = Integer.parseInt(sc.next());\n        }\n        for(int i = 0; i < n; i++){\n            in[i] = Integer.parseInt(sc.next());\n        }\n        pos = 0;\n        reconstruction(0, n);\n        \n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i < n; i++){\n            sb.append(post.get(i)).append(\" \");\n        }\n        sb.deleteCharAt(sb.length()-1);\n        System.out.println(sb);\n    }\n    \n    static void reconstruction(int l, int r){\n        \n        if(l >= r) return;\n        int root = pre[pos++];\n        int m = 0;\n        for(int i = 0; i < n; i++){\n            if(in[i] == root){\n                m = i;\n                break;\n            }\n        }\n        reconstruction(l, m);\n        reconstruction(m+1, r);\n        post.add(root);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\n/**\n * Created by sotetsuk on 2016/07/11.\n */\npublic class ALDS_1_7_D {\n    static Scanner sc = new Scanner(System.in);\n    static int n, pos;\n    static ArrayList<Integer> preorder = new ArrayList<Integer>();\n    static ArrayList<Integer> inorder = new ArrayList<Integer>();\n\n    public static BinaryTree reconstruction(int l, int r) {\n        if (l >= r) {\n            return new BinaryTree();\n        }\n\n        int node = preorder.get(pos++);\n        int i = inorder.indexOf(node);\n\n        BinaryTree left = reconstruction(l, i);\n        BinaryTree right = reconstruction(i + 1, r);\n\n        return new BinaryTree(node, left, right);\n    }\n\n    public static void read() {\n        n = sc.nextInt();\n        for (int i = 0; i < n; i++) {\n            preorder.add(sc.nextInt());\n        }\n        for (int i = 0; i < n; i++) {\n            inorder.add(sc.nextInt());\n        }\n    }\n\n    public static void main(String[] args) {\n        read();\n        pos = 0;\n        BinaryTree bt = reconstruction(0, preorder.size());\n        bt.show();\n    }\n\n    public static class BinaryTree {\n        boolean isEmpty;\n        int node;\n        BinaryTree left;\n        BinaryTree right;\n\n        public BinaryTree(int node, BinaryTree left, BinaryTree right) {\n            this.isEmpty = false;\n            this.node = node;\n            this.left = left;\n            this.right = right;\n        }\n\n        public BinaryTree() {\n            this.isEmpty = true;\n        }\n\n        public void show() {\n            if (this.isEmpty) return;\n            this.left.show();\n            this.right.show();\n            System.out.print(this.node + \" \");\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    static int pos = 0;\n    static ArrayList<Integer> pre = new ArrayList<>();\n    static ArrayList<Integer> in = new ArrayList<>();\n    static ArrayList<Integer> post = new ArrayList<>();\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int n = input.nextInt();\n\n        for(int i = 0; i < n; i++) {\n            pre.add(input.nextInt());\n        }\n        for(int i = 0; i < n; i++) {\n            in.add(input.nextInt());\n        }\n        rec(0, pre.size()); // 用 in 的下标 left 和 right 表示 Preorder 当前访问的子树的范围（不包含 r）\n        for(int i = 0; i < post.size(); i++) {\n            System.out.print(post.get(i));\n            if (i != post.size() - 1) {\n                System.out.print(\" \");\n            } else {\n                System.out.println();\n            }\n        }\n    }\n\n    public static void rec(int left, int right) {\n        if(left >= right) {\n            return;\n        }\n        int root = pre.get(pos++);\n        int middle = getIndex(in, root);\n\n        rec(left, middle);\n        rec(middle+1, right);\n\n        post.add(root); // 左-右-根，此时访问的顺序相当于后序遍历\n    }\n\n    public static int getIndex(ArrayList<Integer> arr, int value) {\n        for (int i = 0; i < arr.size(); i++) {\n            if(arr.get(i) == value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n\tpublic static void main(String[] args){\n\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tNodes mynodes = new Nodes(n+1);\n\n\t\tint[] pre = new int[n];\n\t\tint[] in = new int[n];\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tpre[i] = scan.nextInt();\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tin[i] = scan.nextInt();\n\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(in[j] == pre[i-1]){\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(in[j] == pre[i]){\n\t\t\t\t\tmynodes.setLeft(pre[i-1], pre[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(pre[j] == in[i-1]){\n\t\t\t\t\tmynodes.setRight(in[i-1], mynodes.getRoot(in[i]));\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(pre[j] == in[i]){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint root = mynodes.getRoot(pre[0]);\n\t\tmynodes.printPost(root);\n\t\tSystem.out.println();\n\t}\n}\n\nclass Node{\n\tint parent = -1;\n\tint left = -1;\n\tint right = -1;\n}\n\nclass Nodes{\n\n\tNode[] nodes;\n\n\tpublic Nodes(int n){\n\t\tnodes = new Node[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tnodes[i] = new Node();\n\t\t}\n\t}\n\n\tpublic int getRoot(int id){\n\t\tif(nodes[id].parent == -1)\n\t\t\treturn id;\n\t\treturn getRoot(nodes[id].parent);\n\t}\n\n\tboolean first = true;\n\n\tpublic void printPost(int id){\n\t\tif(id == -1)\n\t\t\treturn;\n\t\tprintPost(nodes[id].left);\n\t\tprintPost(nodes[id].right);\n\t\tif(first){\n\t\t\tSystem.out.print(id);\n\t\t\tfirst = false;\n\t\t}else{\n\t\t\tSystem.out.print(\" \" + id);\n\t\t}\n\t}\n\n\tpublic void setLeft(int id, int left){\n\t\tnodes[id].left = left;\n\t\tnodes[left].parent = id;\n\t}\n\n\tpublic void setRight(int id, int right){\n\t\tnodes[id].right = right;\n\t\tnodes[right].parent = id;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\n/**\n * @see <a href='http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?lang=jp&id='>??????</a>\n */\npublic class Main {\n    private static FastReader in = new FastReader();\n\n    public static void main(String[] args) throws Exception {\n        Main main = new Main();\n        main.run();\n    }\n\n    private int[] preOrder, inOrder, postOrder;\n\n    private void run() {\n        int n = in.nextInt();\n        preOrder = in.nextIntArray(n);\n        inOrder = in.nextIntArray(n);\n        postOrder = new int[n];\n\n        restore(0, 0, 0, n);\n    }\n\n    private int restore(int pos, int count, int left, int right) {\n        if (left >= right) return count;\n        int root = preOrder[pos++];\n        int middle = 0;\n        while (inOrder[middle] != root) {\n            middle++;\n        }\n        count = restore(pos, count, left, middle);\n        count = restore(pos, count, middle + 1, right);\n        postOrder[count] = root;\n        return count + 1;\n    }\n}\n\nclass FastReader {\n    private InputStream in = System.in;\n    private byte[] buf = new byte[1024];\n    private int charNum;\n    private int charLen;\n    private StringBuilder sb = new StringBuilder();\n\n    public int read() {\n        if (charLen == -1)\n            throw new InputMismatchException();\n        if (charNum >= charLen) {\n            charNum = 0;\n            try {\n                charLen = in.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (charLen <= 0)\n                return -1;\n        }\n        return buf[charNum++];\n    }\n\n    public String next() {\n        int c = read();\n        while (isWhitespace(c)) {\n            c = read();\n        }\n        sb.setLength(0);\n        do {\n            sb.appendCodePoint(c);\n            c = read();\n        } while (!isWhitespace(c));\n        return sb.toString();\n    }\n\n    public char[] nextCharArray() {\n        return next().toCharArray();\n    }\n\n    public int nextInt() {\n        return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n        int[] array = new int[n];\n        for (int i = 0; i < n; i++)\n            array[i] = nextInt();\n        return array;\n    }\n\n    public List<Integer> nextIntList(int n) {\n        Integer[] array = new Integer[n];\n        for (int i = 0; i < n; i++)\n            array[i] = nextInt();\n        return Arrays.asList(array);\n    }\n\n    public int[][] nextIntArray2D(int n, int m) {\n        int[][] array = new int[n][m];\n        for (int i = 0; i < n; i++)\n            array[i] = nextIntArray(m);\n        return array;\n    }\n\n    public List<int[]> nextIntsList(int n, int m) {\n        List<int[]> list = new ArrayList<int[]>(n);\n        for (int i = 0; i < n; i++)\n            list.add(nextIntArray(m));\n        return list;\n    }\n\n    public long nextLong() {\n        int c = read();\n        while (isWhitespace(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isWhitespace(c));\n        return res * sgn;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public double[] nextDoubleArray(int n) {\n        double[] array = new double[n];\n        for (int i = 0; i < n; i++)\n            array[i] = nextDouble();\n        return array;\n    }\n\n    public boolean isWhitespace(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tfinal boolean DEBUG = false;\n\tstatic class Node {\n\t\tprivate static boolean isFirstPrint = false;\n\n\t\tint id;\n\t\tNode l, r;\n\t\tNode(int id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\tvoid printPostOrder() {\n\t\t\tisFirstPrint = true;\n\t\t\tthis.postorder();\n\t\t}\n\t\tvoid postorder() {\n\t\t\tif (this.l != null)\n\t\t\t\tthis.l.postorder();\n\t\t\tif (this.r != null)\n\t\t\t\tthis.r.postorder();\n\t\t\tSystem.out.print((isFirstPrint ? \"\" : \" \") + this.id);\n\t\t\tisFirstPrint = false;\n\t\t}\n\t}\n\tNode[] nodes;\n\tint[] preIds, inIds;\n\tint preIndex, inIndex;\n\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tnodes = new Node[n + 1];\n\t\tpreIds = new int[n];\n\t\tinIds = new int[n];\n\t\tpreIndex = inIndex = 0;\n\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tnodes[i] = new Node(i);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tpreIds[i] = scan.nextInt();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tinIds[i] = scan.nextInt();\n\n\t\tint rootId = preIds[0];\n\t\tnodes[rootId] = makeTree(preIds);\n\n\t\tnodes[rootId].printPostOrder();\n\t\tSystem.out.println();\n\t}\n\n\tNode makeTree(int[] ids) {\n\t\tif (ids.length == 0)\n\t\t\treturn null;\n\t\tif (ids.length == 1)\n\t\t\treturn nodes[ids[0]];\n\t\tint rootId = preIds[preIndex++];\n\t\tint[] lIds = null, rIds = null;\n\t\tint lidx = 0, ridx = 0;\n\t\tfor (int i = 0; i < ids.length; i++) {\n\t\t\tif (rootId != inIds[i])\n\t\t\t\tcontinue;\n\t\t\tlidx = i;\n\t\t\tridx = ids.length - i - 1;\n\t\t\tlIds = new int[lidx];\n\t\t\trIds = new int[ridx];\n\t\t\tfor (int j = 0; j < lidx; j++)\n\t\t\t\tlIds[j] = inIds[j];\n\t\t\tfor (int j = 0; j < ridx; j++)\n\t\t\t\trIds[j] = inIds[i + j + 1];\n\t\t}\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"rootId: \" + rootId);\n\t\t}\n\t\tnodes[rootId].l = makeTree(lIds);\n\t\tnodes[rootId].r = makeTree(rIds);\n\t\treturn nodes[rootId];\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tprivate class Node<T> {\n\t\tT value;\n\t\tNode<T> left;\n\t\tNode<T> right;\n\t\tint pos;\n\t\tpublic Node(T value) {\n\t\t\tthis.value = value;\n\t\t\tleft = right = null;\n\t\t\tpos = -1;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn value.toString();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\t\n\tprivate void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(reader.readLine());\n\t\tint[] pre = new int[n];\n\t\tint[] in = new int[n];\n\t\tStringTokenizer st1 = new StringTokenizer(reader.readLine());\n\t\tStringTokenizer st2 = new StringTokenizer(reader.readLine());\n\t\tint rootId = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpre[i] = Integer.parseInt(st1.nextToken());\n\t\t\tin[i] = Integer.parseInt(st2.nextToken());\n\t\t\tif (i == 0) {\n\t\t\t\trootId = pre[i];\n\t\t\t}\n\t\t}\n\t\treader.close();\n\t\t\n\t\tNode<Integer> rootNode = new Node<Integer>(rootId);\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tNode<Integer> current = new Node<Integer>(pre[i]);\n\t\t\taddNode(rootNode, current, in);\n\t\t}\n\t\tSystem.out.println(postOrder(rootNode));\n\t}\n\n\tprivate String postOrder(Node<Integer> rootNode) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tStack<Node<Integer>> stack = new Stack<Node<Integer>>();\n\t\tNode<Integer> current = rootNode;\n\t\tNode<Integer> lastVisited = null;\n\t\twhile (current != null || !stack.isEmpty()) {\n\t\t\tif (current != null) {\n\t\t\t\tstack.push(current);\n\t\t\t\tcurrent = current.left;\n\t\t\t} else {\n\t\t\t\tNode<Integer> peekNode = stack.peek();\n\t\t\t\tif (peekNode.right != null && peekNode.right != lastVisited) {\n\t\t\t\t\tcurrent = peekNode.right;\n\t\t\t\t} else {\n\t\t\t\t\tif (sb.length() != 0) {\n\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(peekNode);\n\t\t\t\t\tlastVisited = stack.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate void addNode(Node<Integer> rootNode, Node<Integer> newNode, int[] in) {\n\t\tnewNode.pos = findPos(in, newNode.value);\n\t\tStack<Node<Integer>> stack = new Stack<Node<Integer>>();\n\t\tstack.push(rootNode);\n\t\twhile (!stack.isEmpty()) {\t\t\t\n\t\t\tNode<Integer> current = stack.pop();\n\t\t\tif (current.pos == -1) {\n\t\t\t\tcurrent.pos = findPos(in, current.value);\n\t\t\t}\n\t\t\tif (newNode.pos < current.pos) {\n\t\t\t\tif (current.left == null) {\n\t\t\t\t\tcurrent.left = newNode;\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tstack.push(current.left);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (current.right == null) {\n\t\t\t\t\tcurrent.right = newNode;\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tstack.push(current.right);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int findPos(int[] in, int id) {\n\t\tfor (int i = 0; i < in.length; i++) {\n\t\t\tif (in[i] == id) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n    static StringBuilder sb = new StringBuilder(\"\");\n    static int index = 0;\n\n    public static void main (String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] preorder = new int[n];\n        int[] inorder = new int[n];\n        for (int i = 0; i < n; i++) {\n            preorder[i] = sc.nextInt();\n        }\n        for (int i = 0; i < n; i++) {\n            inorder[i] = sc.nextInt();\n        }\n        Node[] nodes = new Node[n];\n        reconstruct(nodes, preorder, inorder, 0, n);\n        System.out.println(sb);\n    }\n\n    public static int reconstruct(Node[] nodes, int[] preorder, int[] inorder, int right, int left) {\n        if (left == right) return -1;\n\n        // find root\n        int root = 0;\n        outside: for (int i = 0; i < preorder.length; i++) {\n            for (int j = right; j < left; j++) {\n                if (preorder[i] == inorder[j]) {\n                    root = j;\n                    break outside;\n                }\n            }\n        }\n        System.out.println(index);\n\n        int tempIndex = index;\n        index++;\n\n        nodes[tempIndex] = new Node(inorder[root], -1, -1);\n        nodes[tempIndex].left = reconstruct(nodes, preorder, inorder, right, root);\n        nodes[tempIndex].right = reconstruct(nodes, preorder, inorder, root + 1, left);\n\n        sb.append(\" \").append(nodes[tempIndex].id);\n\n        return tempIndex;\n    }\n}\n\nclass Node {\n    public int id;\n    public int left;\n    public int right;\n\n    public Node(int id, int left, int right) {\n        this.id = id;\n        this.left = left;\n        this.right = right;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\n//import java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// input\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\t\n\t\tint[] pre = new int[n];\n\t\tString[] str = br.readLine().split(\" \");\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t pre[i] = Integer.parseInt(str[i]);\n\t\t}\n\t\t\n\t\tint[] in = new int[n];\n\t\tstr = br.readLine().split(\" \");\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t in[i] = Integer.parseInt(str[i]);\n\t\t}\n\n\t\t// make post and print\n\t\tSystem.out.println(post(pre, in));\n\t}\n\tpublic static String post(int[] pre, int[] in) {\n\t\t// search centre\n\t\tint i = 0;\n\t\tint n = pre.length;\n\t\twhile(pre[0] != in[i]){\n\t\t\ti += 1;\n\t\t}\n\t\t\n\t\tString str = \"\";\n\t\t\n\t\t// left\n\t\t// num of left element = i\n\t\tif(i == 0){\n\t\t\tstr += \"\";\n\t\t}else if(i == 1){\n\t\t\tstr += String.valueOf(in[0]);\n\t\t}else{\n\t\t\tstr += post(Arrays.copyOfRange(pre, 1, i + 1), Arrays.copyOfRange(in, 0, i));\n\t\t}\n\t\t\n\t\t// right\n\t\tint nr = n - 1 - i;// num of right element == 1\n\t\tif(nr == 0){\n\t\t\tstr += \"\";\n\t\t}else if(nr == 1){ \n\t\t\tstr += \" \" + String.valueOf(in[n - 1]);\n\t\t}else{\n\t\t\tstr += post(Arrays.copyOfRange(pre, 1 + i, pre.length), Arrays.copyOfRange(in, i + 1, pre.length));\n\t\t}\n\t\t\n\t\t// centre\n\t\tstr += \" \" + String.valueOf(in[i]); // or pre[0]\n\t\t\n\t\treturn str;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n  int n, pPre,pPost;\n  int[] pre,in,post;\n\n  public static void main(String[] args) {\n    \n    new Main().run();\n  }\n\n  public void run() {\n    \n    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {\n\n      n = Integer.parseInt(br.readLine());\n      String[] linesPre =  br.readLine().split(\" \");\n      String[] linesIn  =  br.readLine().split(\" \");\n\n      pre  = new int[n];\n      in   = new int[n];\n      post = new int[n];\n  \n      for(int i=0; i<n; i++){\n        pre[i] = Integer.parseInt(linesPre[i]);\n        in[i]  = Integer.parseInt(linesIn[i] );\n      }\n\n      solve();\n\n    } catch ( IOException e ) {\n      System.out.println(\"IOException!\");\n    }\n  }\n  \n  void solve() {\n    pPre = pPost = 0;\n    StringBuilder buf = new StringBuilder();\n\n    rec(0,pre.length);\n\n    for (int var : post) {\n      buf.append(var).append(\" \");\n    }\n    buf.setLength(buf.length()-1);\n    System.out.println(buf);\n  }\n\n  void rec(int l, int r) {\n    if( l < r ) {\n      int root = pre[pPre++];\n      int m = arrayDistance(0, in.length, root);\n\n      rec(l,m);\n      rec(m+1,r);\n  \n      post[pPost++] = root;\n    }\n  }\n\n  int arrayDistance(int start, int end, int find) {\n    int d=start;\n\n    for( ; d<end; d++)\n      if( in[d] == find ) break;\n\n    return d;\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int cnt=0,pos=0;\n\tstatic int[] pre=new int[100];\n\tstatic int[] ino=new int[100];\n\tstatic int[] post=new int[100];\n\tpublic static void rec(int x,int y) {\n\t\tif (x>=y) return;\n\t\tint root=pre[cnt++],cur;\n\t\tfor (cur=x;cur<y;cur++) if (ino[cur]==root) break;\n\t\trec(x,cur);\n\t\trec(cur+1,y);\n\t\tpost[pos++]=root;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner in =new Scanner(System.in);\n\t\tint n=in.nextInt();\n\t\tfor (int i=0;i<n;i++) pre[i]=in.nextInt();\n\t\tfor (int i=0;i<n;i++) ino[i]=in.nextInt();\n\t\trec(0,n);\n\t\tfor (int i=0;i<n;i++) {\n\t\t\tSystem.out.print(post[i]);\n\t\t\tif (i!=n-1) System.out.print(\" \");\n\t\t\telse System.out.print(\"\\n\");\n\t\t}\n\t\tin.close();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\npublic class Main {\n\tpublic static int[] pre, in, post;\n\tpublic static int position, count;\n\n\tpublic static void reconstruct(int left, int right) {\n\t\tif (left >= right) return;\n\t\tint root = pre[position++];\n\t\tint middle = 0;\n\t\twhile (in[middle] != root) middle++;\n\t\treconstruct(left, middle);\n\t\treconstruct(middle + 1, right);\n\t\tpost[count++] = root;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tpre = new int[n];\n\t\tin = new int[n];\n\t\tpost = new int[n];\n\t\tfor (int i = 0; i < n; i++) pre[i] = scanner.nextInt();\n\t\tfor (int i = 0; i < n; i++) in[i] = scanner.nextInt();\n\t\tposition = 0;\n\t\tcount = 0;\n\t\treconstruct(0, n);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsb.append(post[i]);\n\t\t\tsb.append(i != n - 1 ? \" \" : \"\\n\");\n\t\t}\n\t\tSystem.out.print(sb);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package main;\n\nimport java.util.Scanner;\nimport java.util.StringJoiner;\n\nclass Main {\n\n\tstatic int n;\n\n\tstatic int[] inOrd;\n\tstatic int[] preOrd;\n\tstatic int[] postOrd;\n\n\tstatic int cIdx = 0;\n\tstatic int rIdx = 0;\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tn = sc.nextInt();\n\n\t\tinOrd = new int[n];\n\t\tfor (int i = 0; i < n; i++) inOrd[i] = sc.nextInt();\n\n\t\tpreOrd = new int[n];\n\t\tfor (int i = 0; i < n; i++) preOrd[i] = sc.nextInt();\n\n\t\tsc.close();\n\n\t\tpostOrd = new int[n];\n\t\tpostOrder(0, n);\n\n\t\tStringJoiner sj = new StringJoiner(\" \");\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsj.add(String.valueOf(postOrd[i]));\n\t\t}\n\t\tSystem.out.println(sj);\n\n\t}\n\n\tprivate static void postOrder(int l, int r) {\n\n\t\tif(l >= r) return;\n\n\t\tint next = inOrd[cIdx];\n\t\tcIdx++;\n\n\t\tint m = -1;\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tif (preOrd[i] == next) {\n\t\t\t\tm = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpostOrder(l, m);\n\t\tpostOrder(m+1, r);\n\n\t\tpostOrd[rIdx] = next;\n\t\trIdx++;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// input\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\t\n\t\tint[] pre = new int[n];\n\t\tString[] str = br.readLine().split(\" \");\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t pre[i] = Integer.parseInt(str[i]);\n\t\t}\n\t\t\n\t\tint[] in = new int[n];\n\t\tstr = br.readLine().split(\" \");\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t in[i] = Integer.parseInt(str[i]);\n\t\t}\n\n\t\t// make post and print\n\t\tSystem.out.println(post(pre, in));\n\t}\n\tpublic static String post(int[] pre, int[] in) {\n\t\t// search centre\n\t\tint i = 0;\n\t\tint n = pre.length;\n\t\twhile(pre[0] != in[i]){\n\t\t\ti += 1;\n\t\t}\n\t\t\n\t\tString str = \"\";\n\t\t\n\t\t// left\n\t\t// num of left element = i\n\t\tif(i == 0){\n\t\t}else if(i == 1){\n\t\t\tif(str != \"\") {\n\t\t\t\tstr += \" \";\n\t\t\t}\n\t\t\tstr += String.valueOf(in[0]);\n\t\t}else{\n\t\t\tif(str != \"\") {\n\t\t\t\tstr += \" \";\n\t\t\t}\n\t\t\tstr += post(Arrays.copyOfRange(pre, 1, i + 1), Arrays.copyOfRange(in, 0, i));\n\t\t}\n\t\t\n\t\t// right\n\t\tint nr = n - 1 - i;// num of right element == 1\n\t\tif(nr == 0){\n\t\t}else if(nr == 1){ \n\t\t\tif(str != \"\") {\n\t\t\t\tstr += \" \";\n\t\t\t}\n\t\t\tstr += String.valueOf(in[n - 1]);\n\t\t}else{\n\t\t\tif(str != \"\") {\n\t\t\t\tstr += \" \";\n\t\t\t}\n\t\t\tstr += post(Arrays.copyOfRange(pre, 1 + i, pre.length), Arrays.copyOfRange(in, i + 1, pre.length));\n\t\t}\n\t\t\n\t\t// centre\n\t\tif(str != \"\") {\n\t\t\tstr += \" \";\n\t\t}\n\t\tstr += String.valueOf(in[i]); // or pre[0]\n\t\t\n\t\treturn str;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint[] pre = new int[n];\n    \tfor (int i = 0; i < n; i++) {\n    \t\tpre[i] = sc.nextInt();\n    \t}\n\t\tint[] in = new int[n];\n    \tfor (int i = 0; i < n; i++) {\n    \t\tin[i] = sc.nextInt();\n    \t}\n\n    \tint[] post = new int[n];\n    \tmakePost(post, n - 1, pre, 0, in, 0, n);\n\n    \tfor (int i = 0; i < n; i++) {\n    \t\tif (i != 0) {\n            \tSystem.out.print(\" \");\n    \t\t}\n        \tSystem.out.print(post[i]);\n    \t}\n    \tSystem.out.println(\"\");\n\n    \tsc.close();\n\t}\n\t\n\tprivate static void makePost(int[] post, int spost, int[] pre, int spre, int[] in, int sin, int n) {\n\t\tif (n < 1) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tpost[spost] = pre[spre];\n\n\t\tint i = sin;\n\t\tfor (; i < n; i++) {\n\t\t\tif (in[i] == pre[spre]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tmakePost(post, spost - 1, pre, spre + 1 + (i - sin), in, sin + 1 + (i -sin), n - (i - sin) - 1);\n\t\tmakePost(post, spost - 1 - (n - (i - sin) - 1), pre, spre + 1, in, sin, i - sin);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    private static List<Integer> solve(int[] pre, int[] in, int preroot, int infirst, int inlast) {\n        List<Integer> res = new ArrayList<>();\n\n        int root = infirst;\n        for(int i = infirst; i < inlast; i++) {\n            if(pre[preroot] == in[i]) {\n                root = i;\n                break;\n            }\n        }\n\n        if(infirst < root) res.addAll(solve(pre, in, preroot + 1, infirst, root));\n        if(root < inlast - 1) res.addAll(solve(pre, in, preroot + (root - infirst + 1), root + 1, inlast));\n\n        res.add(in[root]);\n        return res;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n \n        int n = sc.nextInt();\n        int[] pre = new int[n];\n        for(int i = 0; i < n; i++) {\n            pre[i] = sc.nextInt();\n        }\n        int[] in = new int[n];\n        for(int i = 0; i < n; i++) {\n            in[i] = sc.nextInt();\n        }\n\n        List<Integer> ans = solve(pre, in, 0, 0, n);\n        \n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i < n; i++) {\n            if(i != 0) sb.append(\" \");\n            sb.append(ans.get(i));\n        }\n        System.out.println(sb);\n\n        sc.close();\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\n/**\n * Created by sotetsuk on 2016/07/11.\n */\npublic class Main {\n    static Scanner sc = new Scanner(System.in);\n    static int n, pos;\n    static ArrayList<Integer> preorder = new ArrayList<Integer>();\n    static ArrayList<Integer> inorder = new ArrayList<Integer>();\n\n    public static BinaryTree reconstruction(int l, int r) {\n        if (l >= r) {\n            return new BinaryTree();\n        }\n\n        int node = preorder.get(pos++);\n        int i = inorder.indexOf(node);\n\n        BinaryTree left = reconstruction(l, i);\n        BinaryTree right = reconstruction(i + 1, r);\n\n        return new BinaryTree(node, left, right);\n    }\n\n    public static void read() {\n        n = sc.nextInt();\n        for (int i = 0; i < n; i++) {\n            preorder.add(sc.nextInt());\n        }\n        for (int i = 0; i < n; i++) {\n            inorder.add(sc.nextInt());\n        }\n    }\n\n    public static void main(String[] args) {\n        read();\n        pos = 0;\n        BinaryTree bt = reconstruction(0, preorder.size());\n        bt.show();\n    }\n\n    public static class BinaryTree {\n        boolean isEmpty;\n        int node;\n        BinaryTree left;\n        BinaryTree right;\n\n        public BinaryTree(int node, BinaryTree left, BinaryTree right) {\n            this.isEmpty = false;\n            this.node = node;\n            this.left = left;\n            this.right = right;\n        }\n\n        public BinaryTree() {\n            this.isEmpty = true;\n        }\n\n        public void show() {\n            if (this.isEmpty) return;\n            this.left.show();\n            this.right.show();\n            System.out.print(this.node + \" \");\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Main {\n\tstatic StringBuilder sb = new StringBuilder(\"\");\n\tstatic int index = 0;\n\t\n\tpublic static void main(String args[]) {\n\t\trun();\n\t}\n\tpublic static void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint  num = scanner.nextInt();//要素数\n\t\tNode[] nodes = new Node[num];\n\t\tint[] preorder = new int[num];\n\t\tint[] inorder = new int[num];\n\t\t\n\t\t//入力ごとに配列\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tpreorder[i] = scanner.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tinorder[i] = scanner.nextInt();\n\t\t}\n\t\t\n\t\tReconstruction(nodes, preorder, inorder, 0, num);\n\t\t\n\t\toutput();//出力関数\n\t\t\n\t\tscanner.close();\n\t}\n\t\n\t//\n\tpublic static int Reconstruction(Node[] nodes, int[] preorder, int[] inorder, int right, int left) {\n\t\t if (left == right) {\n\t\t\t return -1;\n\t\t }\n\t\t\n\t\tint sub = index;\n\t\tindex ++;\n\t\t\n\t\t// root探し\n\t\tint root = 0;\n\t\toutside: for (int i = 0; i < preorder.length; i++) {\n\t\t\tfor (int j = right; j < left; j++) {\n\t\t\t\tif (preorder[i] == inorder[j]) {\n\t\t\t\t\troot = j;\n\t\t\t\t\tbreak outside;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t//左右に分けて処理\n\t\tnodes[sub] = new Node(inorder[root], -1, -1);\n\t\tnodes[sub].left = Reconstruction(nodes, preorder, inorder, right, root);\n\t\tnodes[sub].right = Reconstruction(nodes, preorder, inorder, root + 1, left);\n\t\t\n\t\tsb.append(\" \").append(nodes[sub].id);\n\t\t\n\t\treturn sub;\n\t}\n\t\n\t//出力\n\tpublic static void output(){\n\t\tsb.deleteCharAt(0);//重複してるroot消し\n\t\tSystem.out.println(sb);\n\t}\n}\nclass Node{\n\tpublic int id;\n\tpublic int left;\n\tpublic int right;\n\t\n\tpublic Node(int id, int left, int right) {\n\t\tthis.id = id;\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t}\n\t\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n\t\n\tstatic int[] preorder;\n\tstatic int[] inorder;\n\tstatic int[] postorder;\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\tfinal int n = sc.nextInt();\n\t\t\n\t\tpreorder = new int[n];\n\t\tinorder = new int[n];\n\t\tpostorder = new int[n];\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpreorder[i] = sc.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tinorder[i] = sc.nextInt();\n\t\t}\n\t\t\n\t\treconstruct(0,0,0,n);\n\t\tSystem.out.print(postorder[0]);\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tSystem.out.print(\" \"+postorder[i]);\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tstatic void reconstruct(int pre, int in, int post, int n){\n\t\tif(n<=0) return;\n\t\tfinal int q = preorder[pre];\n\t\tpostorder[post+n-1] = q;\n\t\tint x;\n\t\tfor(x = in; inorder[x]!=q; x++);\n\t\tfinal int l = n-(x-in)-1;\n\t\treconstruct(pre+1, in, post, x-in);\n\t\treconstruct(pre+1+x-in, x+1, post+x-in, l);\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tContestScanner scan = new ContestScanner();\n\n\t\tfinal int n = scan.nextInt();\n\t\tfinal int[] preOrders = scan.nextIntArray(n);\n\t\tfinal int[] inOrders = scan.nextIntArray(n);\n\n\t\t(new Solve(n, preOrders, inOrders)).solve();\n\t}\n}\nclass Solve {\n\tprivate final int n;\n\tprivate final int[] preOrders;\n\tprivate final int[] inOrders;\n\n\tpublic Solve(final int n, final int[] preOrders, final int[] inOrders)\n\t{\n\t\tthis.n = n;\n\t\tthis.preOrders = preOrders;\n\t\tthis.inOrders = inOrders;\n\t}\n\n\tpublic void solve()\n\t{\n\t\tint[] inOrderPositions = new int[n+1];\n\n\t\tfor(int i=0; i < n; i++)\n\t\t{\n\t\t\tinOrderPositions[inOrders[i]] = i;\n\t\t}\n\n\t\tArrayList<Integer> postOrders = new ArrayList<>();\n\n\t\trecursion(0, 0, n, preOrders, inOrders, inOrderPositions, postOrders);\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tfor(int node: postOrders)\n\t\t{\n\t\t\tsb.append(\" \" + node);\n\t\t}\n\t\tsb.deleteCharAt(0);\n\n\t\tSystem.out.println(sb.toString());\n\t}\n\n\tpublic int recursion(int pos, final int l, final int r,\n\t\t\t\t\t\t\tfinal int[] preOrders, final int[] inOrders,\n\t\t\t\t\t\t\tfinal int[] inOrderPositions, ArrayList<Integer> postOrders)\n\t{\n\t\tif(l >= r) return pos;\n\n\t\tfinal int root = preOrders[pos++];\n\n\t\tfinal int m = inOrderPositions[root];\n\n\t\tpos = recursion(pos, l, m, preOrders, inOrders, inOrderPositions, postOrders);\n\t\tpos = recursion(pos, m + 1, r, preOrders, inOrders, inOrderPositions, postOrders);\n\n\t\tpostOrders.add(root);\n\n\t\treturn pos;\n\t}\n}\nclass ContestScanner {\n\tBufferedReader reader;\n\tString[] line;\n\tint index;\n\tpublic ContestScanner() {\n\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\tpublic ContestScanner(String filename) throws FileNotFoundException {\n\t\treader = new BufferedReader(new InputStreamReader(new FileInputStream(filename)));\n\t}\n\n\tpublic static interface ICreator<T> {\n\t\tpublic T createFromToken(final ContestScanner scanner) throws IOException;\n\t}\n\n\tpublic static interface IArrayInitializer {\n\t\tpublic void initialize(final ContestScanner scanner, final int i) throws IOException;\n\t}\n\n\tpublic static interface IObjectInitializer<T> {\n\t\tpublic T initialValue(final ContestScanner scanner);\n\t}\n\n\tpublic static class ObjectArrayInitializer<T> implements IArrayInitializer {\n\t\tprotected T[] arr;\n\t\tprotected final IObjectInitializer<T> initializer;\n\n\t\tprivate ObjectArrayInitializer(T[] arr, final IObjectInitializer<T> initializer)\n\t\t{\n\t\t\tthis.arr = arr;\n\t\t\tthis.initializer = initializer;\n\t\t}\n\n\t\tpublic static <T> ObjectArrayInitializer<T> create(T[] arr, final IObjectInitializer<T> initializer)\n\t\t{\n\t\t\treturn new ObjectArrayInitializer<T>(arr, initializer);\n\t\t}\n\n\t\tpublic void initialize(final ContestScanner scanner, final int i) throws IOException {\n\t\t\tthis.arr[i] = initializer.initialValue(scanner);\n\t\t}\n\n\t\tpublic T[] getArray()\n\t\t{\n\t\t\treturn this.arr;\n\t\t}\n\t}\n\n\n\tpublic static class ByteArrayInitializer implements IArrayInitializer {\n\t\tprotected byte[] arr;\n\n\t\tprivate ByteArrayInitializer(final int n)\n\t\t{\n\t\t\tthis.arr = new byte[n];\n\t\t}\n\n\t\tpublic void initialize(final ContestScanner scanner, final int i) throws IOException {\n\t\t\tthis.arr[i] = scanner.nextByte();\n\t\t}\n\n\t\tpublic byte[] getArray()\n\t\t{\n\t\t\treturn this.arr;\n\t\t}\n\t}\n\n\tpublic static class ShortArrayInitializer implements IArrayInitializer {\n\t\tprotected short[] arr;\n\n\t\tprivate ShortArrayInitializer(final int n)\n\t\t{\n\t\t\tthis.arr = new short[n];\n\t\t}\n\n\t\tpublic void initialize(final ContestScanner scanner, final int i) throws IOException {\n\t\t\tthis.arr[i] = scanner.nextShort();\n\t\t}\n\n\t\tpublic short[] getArray()\n\t\t{\n\t\t\treturn this.arr;\n\t\t}\n\t}\n\n\tpublic static class IntArrayInitializer implements IArrayInitializer {\n\t\tprotected int[] arr;\n\n\t\tprivate IntArrayInitializer(final int n)\n\t\t{\n\t\t\tthis.arr = new int[n];\n\t\t}\n\n\t\tpublic void initialize(final ContestScanner scanner, final int i) throws IOException {\n\t\t\tthis.arr[i] = scanner.nextInt();\n\t\t}\n\n\t\tpublic int[] getArray()\n\t\t{\n\t\t\treturn this.arr;\n\t\t}\n\t}\n\n\tpublic static class LongArrayInitializer implements IArrayInitializer {\n\t\tprotected long[] arr;\n\n\t\tprivate LongArrayInitializer(final int n)\n\t\t{\n\t\t\tthis.arr = new long[n];\n\t\t}\n\n\t\tpublic void initialize(final ContestScanner scanner, final int i) throws IOException {\n\t\t\tthis.arr[i] = scanner.nextLong();\n\t\t}\n\n\t\tpublic long[] getArray()\n\t\t{\n\t\t\treturn this.arr;\n\t\t}\n\t}\n\n\tpublic static class FloatArrayInitializer implements IArrayInitializer {\n\t\tprotected float[] arr;\n\n\t\tprivate FloatArrayInitializer(final int n)\n\t\t{\n\t\t\tthis.arr = new float[n];\n\t\t}\n\n\t\tpublic void initialize(final ContestScanner scanner, final int i) throws IOException {\n\t\t\tthis.arr[i] = scanner.nextFloat();\n\t\t}\n\n\t\tpublic float[] getArray()\n\t\t{\n\t\t\treturn this.arr;\n\t\t}\n\t}\n\n\tpublic static class DoubleArrayInitializer implements IArrayInitializer {\n\t\tprotected double[] arr;\n\n\t\tprivate DoubleArrayInitializer(final int n)\n\t\t{\n\t\t\tthis.arr = new double[n];\n\t\t}\n\n\t\tpublic void initialize(final ContestScanner scanner, final int i) throws IOException {\n\t\t\tthis.arr[i] = scanner.nextDouble();\n\t\t}\n\n\t\tpublic double[] getArray()\n\t\t{\n\t\t\treturn this.arr;\n\t\t}\n\t}\n\n\tpublic String nextToken() throws IOException {\n\t\tif(line == null || index >= line.length)\n\t\t{\n\t\t\tline = reader.readLine().trim().split(\" \");\n\t\t\tindex = 0;\n\t\t}\n\n\t\treturn line[index++];\n\t}\n\n\tpublic String next() throws IOException {\n\t\treturn nextToken();\n\t}\n\n\tpublic String readLine() throws IOException {\n\t\tline = null;\n\t\tindex = 0;\n\n\t\treturn reader.readLine();\n\t}\n\n\tpublic byte nextByte() throws IOException, NumberFormatException {\n\t\treturn Byte.parseByte(nextToken());\n\t}\n\n\tpublic short nextShort() throws IOException, NumberFormatException {\n\t\treturn Short.parseShort(nextToken());\n\t}\n\n\tpublic int nextInt() throws IOException, NumberFormatException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic long nextLong() throws IOException, NumberFormatException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tpublic float nextFloat() throws IOException, NumberFormatException {\n\t\treturn Float.parseFloat(nextToken());\n\t}\n\n\tpublic double nextDouble() throws IOException, NumberFormatException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tpublic <T> T nextObject(final ICreator<T> creator) throws IOException, NumberFormatException {\n\t\treturn creator.createFromToken(this);\n\t}\n\n\tpublic int[] nextIntArray(final int N) throws IOException, NumberFormatException {\n\t\tint[] result = new int[N];\n\n\t\tfor(int i=0; i < N; i++) result[i] = nextInt();\n\n\t\treturn result;\n\t}\n\n\tpublic long[] nextLongArray(final int N) throws IOException, NumberFormatException {\n\t\tlong[] result = new long[N];\n\n\t\tfor(int i=0; i < N; i++) result[i] = nextLong();\n\n\t\treturn result;\n\t}\n\n\tpublic float[] nexFloatArray(final int N) throws IOException, NumberFormatException {\n\t\tfloat[] result = new float[N];\n\n\t\tfor(int i=0; i < N; i++) result[i] = nextFloat();\n\n\t\treturn result;\n\t}\n\n\tpublic double[] nexDoubleArray(final int N) throws IOException, NumberFormatException {\n\t\tdouble[] result = new double[N];\n\n\t\tfor(int i=0; i < N; i++) result[i] = nextDouble();\n\n\t\treturn result;\n\t}\n\n\tpublic <T> T[] nextObjectArray(T[] result, final ICreator<T> creator) throws IOException, NumberFormatException {\n\t\tfor(int i=0, N=result.length; i < N; i++) result[i] = nextObject(creator);\n\n\t\treturn result;\n\t}\n\n\tpublic <T> ArrayList<T> nextGenericObjectArrayList(final int N, final ICreator<T> creator) throws IOException, NumberFormatException {\n\t\tArrayList<T> result = new ArrayList<T>();\n\t\tfor(int i=0; i < N; i++) result.add(nextObject(creator));\n\n\t\treturn result;\n\t}\n\n\tpublic void nextTable(final int N, IArrayInitializer... arrayInitializers) throws IOException, NumberFormatException {\n\t\tfor(int i=0; i < N; i++) for(IArrayInitializer initializer: arrayInitializers)\n\t\t{\n\t\t\tinitializer.initialize(this, i);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new\n\t\t// File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\ALDS1_6_A-in9.txt\"));\n\n\t\tint n = scan.nextInt();\n\t\tTree t = new Tree(n + 1);\n\t\tint[] pre = new int[n];\n\t\tint[] in = new int[n];\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tpre[i] = scan.nextInt();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tin[i] = scan.nextInt();\n\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (in[j] == pre[i]) {\n\t\t\t\t\tt.setLeftChild(pre[i - 1], pre[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (in[j] == pre[i - 1])\n\t\t\t\t\tbreak;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (pre[j] == in[i]) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (pre[j] == in[i - 1]) {\n\t\t\t\t\tt.setRightChild(in[i - 1], in[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t// System.out.print(\"Preorder\\n\");\n\t\t// t.printPre(t.getRoot());\n\t\t// System.out.print(\"\\nInorder\\n\");\n\t\t// t.printIn(t.getRoot());\n\t\t// System.out.print(\"\\nPostorder\\n\");\n\t\tt.printPost(t.getRoot());\n\t\tSystem.out.print(\"\\n\");\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Tree {\n\tprivate class Node {\n\t\tint Parent = -1;\n\t\tint LeftChild = -1;\n\t\tint RightChild = -1;\n\n\t\tpublic int getDepth() {\n\t\t\tif (Parent == -1)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn (node[Parent].getDepth() + 1);\n\t\t}\n\n\t\tpublic String getType() {\n\t\t\tif (Parent == -1)\n\t\t\t\treturn \"root\";\n\t\t\telse if (LeftChild == -1 && RightChild == -1)\n\t\t\t\treturn \"leaf\";\n\t\t\telse\n\t\t\t\treturn \"internal node\";\n\t\t}\n\n\t\tpublic int getSib(int id) {\n\t\t\tif (Parent == -1)\n\t\t\t\treturn -1;\n\t\t\telse if (node[Parent].LeftChild == id)\n\t\t\t\treturn (node[Parent].RightChild);\n\t\t\telse\n\t\t\t\treturn (node[Parent].LeftChild);\n\t\t}\n\n\t\tpublic int getDegree() {\n\t\t\tint r = 2;\n\t\t\tif (LeftChild == -1)\n\t\t\t\tr--;\n\t\t\tif (RightChild == -1)\n\t\t\t\tr--;\n\t\t\treturn r;\n\t\t}\n\n\t\tpublic int getHeight() {\n\t\t\tif (getDegree() == 0)\n\t\t\t\treturn 0;\n\t\t\tint l = 0, r = 0;\n\t\t\tif (LeftChild != -1)\n\t\t\t\tl = node[LeftChild].getHeight();\n\t\t\tif (RightChild != -1)\n\t\t\t\tr = node[RightChild].getHeight();\n\t\t\treturn Math.max(l, r) + 1;\n\t\t}\n\t}\n\n\tprivate Node[] node;\n\n\tpublic Tree(int n) {\n\t\tnode = new Node[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnode[i] = new Node();\n\t\t}\n\t}\n\n\tboolean x = true;\n\n\tpublic void printPost(int id) {\n\t\tif (id == -1)\n\t\t\treturn;\n\t\tprintPost(node[id].LeftChild);\n\t\tprintPost(node[id].RightChild);\n\t\tif (x)\n\t\t\tSystem.out.print(id);\n\t\telse\n\t\t\tSystem.out.print(\" \" + id);\n\t\tx = false;\n\t}\n\n\tpublic void printIn(int id) {\n\t\tif (id == -1)\n\t\t\treturn;\n\t\tprintIn(node[id].LeftChild);\n\t\tSystem.out.print(\" \" + id);\n\t\tprintIn(node[id].RightChild);\n\t}\n\n\tpublic void printPre(int id) {\n\t\tif (id == -1)\n\t\t\treturn;\n\t\tSystem.out.print(\" \" + id);\n\t\tprintPre(node[id].LeftChild);\n\t\tprintPre(node[id].RightChild);\n\t}\n\n\tpublic int getRoot() {\n\t\treturn getRoot(1);\n\t}\n\n\tprivate int getRoot(int id) {\n\t\tif (node[id].Parent == -1)\n\t\t\treturn id;\n\t\telse\n\t\t\treturn getRoot(node[id].Parent);\n\t}\n\n\tpublic void setRightChild(int id, int c) {\n\t\tnode[id].RightChild = c;\n\t\tif (c != -1)\n\t\t\tnode[c].Parent = id;\n\t}\n\n\tpublic void setLeftChild(int id, int c) {\n\t\tnode[id].LeftChild = c;\n\t\tif (c != -1)\n\t\t\tnode[c].Parent = id;\n\t}\n\n\tpublic void printDetail(int id) {\n\t\tSystem.out.println(\"node \" + id + \": parent = \" + node[id].Parent + \", sibling = \" + node[id].getSib(id)\n\t\t\t\t+ \", degree = \" + node[id].getDegree() + \", depth = \" + node[id].getDepth() + \", height = \"\n\t\t\t\t+ node[id].getHeight() + \", \" + node[id].getType());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.Arrays;\n\npublic class Main {\n    class Node {\n        int id;\n        int left = -1, right = -1;\n        String nodeType = null;\n        Node(int id, int left, int right) {\n            this.id = id;\n            this.left = left;\n            this.right = right;\n        }\n        void print() {\n            System.out.println(id + \", \" + left + \", \" + right);\n        }\n    }\n    void postorder(Node[] nodes, int x) {\n        if (nodes[x].left != -1)\n            postorder(nodes, nodes[x].left);\n        if (nodes[x].right != -1)\n            postorder(nodes, nodes[x].right);\n        System.out.print(x + \" \");\n    }\n\n    Node[] nodes;\n    int[] pre;\n    int[] in;\n    int ap;\n\nint search(int b1p, int b2p) {\n        int center = -1;\n        if (ap >= pre.length) {\n            return -1;\n        }\n        int top = pre[ap];\n        if (b1p + 1 == b2p) {\n            nodes[top] = new Node(top, -1, -1);\n            return top;\n        } else if (b1p >= b2p) {\n            return -1;\n        }\n        for (int i = b1p; i < b2p; i++) {\n            if (top == in[i]) {\n                center = i;\n                break;\n            }\n        }\n        ap++;\n        int left = search(b1p, center);\n        if (left != -1) ap++;\n        int right = search(center+1, b2p);\n        nodes[top] = new Node(top, left, right);\n        return top;\n    }\n\nvoid run() {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        nodes = new Node[n+1];\n        pre = new int[n];\n        in  = new int[n];\n        int root = 0;\n        for (int i = 0; i < n; i++) {\n            int id = sc.nextInt();\n            if (i == 0) root = id;\n            pre[i] = id;\n        }\n        for (int i = 0; i < n; i++) {\n            int id = sc.nextInt();\n            in[i] = id;\n        }\n        search(0, nodes.length);\n        /*\n        for (int i = 1; i <= n; i++) {\n            nodes[i].print();\n        }*/\n        postorder(nodes, root);\n        System.out.println();\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static int reconstruction(final int n, final int pre_pos, final int in_start, final int in_end, int[] pre_order, int[] in_order, int[] n_left, int[] n_right){\n\t\tfinal int partition = pre_order[pre_pos];\n\t\t\n\t\t//System.out.println(\"> \" + pre_pos + \" \" + in_start + \" \" + in_end + \" [\" + (partition + 1) + \"]\");\n\t\t\n\t\tfor(int in_pos = in_start; in_pos < in_end; in_pos++){\n\t\t\tif(in_order[in_pos] == partition){\n\t\t\t\tif(in_start < in_pos){\n\t\t\t\t\tn_left[partition] = reconstruction(n, pre_pos + 1, in_start, in_pos, pre_order, in_order, n_left, n_right);\n\t\t\t\t}else{\n\t\t\t\t\tn_left[partition] = -1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(in_pos < in_end && pre_pos + (in_pos - in_start + 1) < n){\n\t\t\t\t\tn_right[partition] = reconstruction(n, pre_pos + (in_pos - in_start + 1), in_pos + 1, in_end, pre_order, in_order, n_left, n_right);\n\t\t\t\t}else{\n\t\t\t\t\tn_right[partition] = -1;\n\t\t\t\t}\n\t\t\t\t//System.out.println(n_left[in_pos] + \"<-\" + partition + \"->\" + n_right[in_pos]);\n\t\t\t\treturn partition;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\t\n\tpublic static void postorder(int node, int[] n_left, int[] n_right, LinkedList<Integer> list){\n\t\tif(n_left[node]  != -1){ postorder(n_left[node] , n_left, n_right, list); }\n\t\tif(n_right[node] != -1){ postorder(n_right[node], n_left, n_right, list); }\n\t\tlist.add(node);\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int n = sc.nextInt();\n\t\tint[] pre_order = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpre_order[i] = sc.nextInt() - 1;\n\t\t}\n\t\tint[] in_order = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tin_order[i] = sc.nextInt()  - 1;\n\t\t}\n\t\t\n\t\tint[] n_left = new int[n];\n\t\tint[] n_right = new int[n];\n\t\tArrays.fill(n_left, -1);\n\t\tArrays.fill(n_right, -1);\n\t\t\n\t\tfinal int root = reconstruction(n, 0, 0, n, pre_order, in_order, n_left, n_right);\n\t\t//System.out.println(root);\n\t\tLinkedList<Integer> list = new LinkedList<Integer>();\n\t\t//System.out.println(Arrays.toString(n_left));\n\t\t//System.out.println(Arrays.toString(n_right));\n\t\tpostorder(root, n_left, n_right, list);\n\t\tboolean first = true;\n\t\tfor(int num : list){\n\t\t\tif(first){ first = false; }\n\t\t\telse{ System.out.print(\" \"); }\n\t\t\tSystem.out.print(num + 1);\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tpublic static class Scanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tprivate static FastScanner sc = new FastScanner();\n\tstatic int idx_preodr = 1;\n\n\tpublic static void main(String[] args) {\n\t\tint n = sc.nextInt();\n\n\t\tNode_BT[] nodes = new Node_BT[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tnodes[i] = new Node_BT();\n\t\t\tnodes[i].id = i;\n\t\t}\n\n\t\tint[] preodr = new int[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tpreodr[i] = sc.nextInt() - 1;\n\t\t}\n\n\t\tint[] inodr = new int[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tinodr[i] = sc.nextInt() - 1;\n\t\t}\n\n\t\tnodes[preodr[0]].reconstructTree(nodes, preodr, inodr, -1);\n\n\t\tnodes[preodr[0]].postOrder(nodes, preodr);\n\t\tSystem.out.println();\n\n\t}\n\n\tstatic class Node_BT {\n\t\tint id;\n\t\tint left = -1;\n\t\tint right = -1;\n\t\tint parent = -1;\n\t\tHashSet<Integer> l_subtree = new HashSet<>();\n\t\tHashSet<Integer> r_subtree = new HashSet<>();\n\n\t\tvoid reconstructTree(Node_BT[] nodes, int[] preodr, int[] inodr, int parent) {\n\t\t\tthis.parent = parent;\n\t\t\tleftSubTree(nodes, inodr);\n\t\t\trightSubTree(nodes, inodr);\n\n\t\t\tif(idx_preodr >= preodr.length) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(l_subtree.contains(preodr[idx_preodr])) {\n\t\t\t\tleft = preodr[idx_preodr];\n\t\t\t\tidx_preodr++;\n\t\t\t\tnodes[left].reconstructTree(nodes, preodr, inodr, id);\n\t\t\t}\n\t\t\tif(r_subtree.contains(preodr[idx_preodr])) {\n\t\t\t\tright = preodr[idx_preodr];\n\t\t\t\tidx_preodr++;\n\t\t\t\tnodes[right].reconstructTree(nodes, preodr, inodr, id);\n\t\t\t}\n\t\t}\n\n\t\tvoid leftSubTree(Node_BT[] nodes, int[] inodr) {\n\t\t\tint i = 0;\n\t\t\twhile(inodr[i] != id) {\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\ti--;\n\t\t\tif(parent == -1) {\n\t\t\t\twhile(i >= 0) {\n\t\t\t\t\tl_subtree.add(inodr[i]);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(nodes[parent].l_subtree.contains(id)) {\n\t\t\t\t\twhile(i >= 0 && nodes[parent].l_subtree.contains(inodr[i])) {\n\t\t\t\t\t\tl_subtree.add(inodr[i]);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile(i >= 0 && nodes[parent].r_subtree.contains(inodr[i])) {\n\t\t\t\t\t\tl_subtree.add(inodr[i]);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid rightSubTree(Node_BT[] nodes, int[] inodr) {\n\t\t\tint i = 0;\n\t\t\twhile(inodr[i] != id) {\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\ti++;\n\t\t\tif(parent == -1) {\n\t\t\t\twhile(i < inodr.length) {\n\t\t\t\t\tr_subtree.add(inodr[i]);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(nodes[parent].l_subtree.contains(id)) {\n\t\t\t\t\twhile(i < inodr.length && nodes[parent].l_subtree.contains(inodr[i])) {\n\t\t\t\t\t\tr_subtree.add(inodr[i]);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile(i < inodr.length && nodes[parent].r_subtree.contains(inodr[i])) {\n\t\t\t\t\t\tr_subtree.add(inodr[i]);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid postOrder(Node_BT[] nodes, int[] preodr) {\n\t\t\tif(left != -1) {\n\t\t\t\tnodes[left].postOrder(nodes, preodr);\n\t\t\t}\n\t\t\tif(right != -1) {\n\t\t\t\tnodes[right].postOrder(nodes, preodr);\n\t\t\t}\n\t\t\tSystem.out.print(id + 1);\n\t\t\tif(id != preodr[0]) {\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException  e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tfinal boolean DEBUG = false;\n\tstatic class Node {\n\t\tprivate static boolean isFirstPrint = false;\n\n\t\tint id;\n\t\tNode l, r;\n\t\tNode(int id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\tvoid printPostOrder() {\n\t\t\tisFirstPrint = true;\n\t\t\tthis.postorder();\n\t\t}\n\t\tvoid postorder() {\n\t\t\tif (this.l != null)\n\t\t\t\tthis.l.postorder();\n\t\t\tif (this.r != null)\n\t\t\t\tthis.r.postorder();\n\t\t\tSystem.out.print((isFirstPrint ? \"\" : \" \") + this.id);\n\t\t\tisFirstPrint = false;\n\t\t}\n\t}\n\tNode[] nodes;\n\tint[] preIds, inIds;\n\tint preIndex, inIndex;\n\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tnodes = new Node[n + 1];\n\t\tpreIds = new int[n];\n\t\tinIds = new int[n];\n\t\tpreIndex = inIndex = 0;\n\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tnodes[i] = new Node(i);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tpreIds[i] = scan.nextInt();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tinIds[i] = scan.nextInt();\n\n\t\tint rootId = preIds[0];\n\t\tnodes[rootId] = makeTree(preIds);\n\n\t\tnodes[rootId].printPostOrder();\n\t\tSystem.out.println();\n\t}\n\n\tNode makeTree(int[] ids) {\n\t\tif (ids.length == 1)\n\t\t\treturn nodes[ids[0]];\n\t\tint rootId = preIds[preIndex++];\n\t\tint[] lIds = null, rIds = null;\n\t\tint lidx = 0, ridx = 0;\n\t\tfor (int i = 0; i < ids.length; i++) {\n\t\t\tif (rootId != inIds[i])\n\t\t\t\tcontinue;\n\t\t\tlidx = i;\n\t\t\tridx = ids.length - i - 1;\n\t\t\tlIds = new int[lidx];\n\t\t\trIds = new int[ridx];\n\t\t\tfor (int j = 0; j < lidx; j++)\n\t\t\t\tlIds[j] = inIds[j];\n\t\t\tfor (int j = 0; j < ridx; j++)\n\t\t\t\trIds[j] = inIds[i + j + 1];\n\t\t}\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"rootId: \" + rootId);\n\t\t}\n\t\tnodes[rootId].l = makeTree(lIds);\n\t\tnodes[rootId].r = makeTree(rIds);\n\t\treturn nodes[rootId];\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\nclass Main {\n    static int n, pos = 0;\n\n    static ArrayList<Integer> preorder = new ArrayList<>();\n    static ArrayList<Integer> inorder = new ArrayList<>();\n    static ArrayList<Integer> postorder = new ArrayList<>();\n\n    static void reconstruction(int l, int r){\n        if (l >= r) return;\n\n        int root = preorder.get(pos++);\n        int m = inorder.indexOf(root);\n\n        reconstruction(l,m);\n        reconstruction(m+1,r);\n\n        postorder.add(root);\n    }\n\n\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        n = sc.nextInt();\n\n        for (int i = 0; i < n; i++) preorder.add(i,sc.nextInt());\n        for (int i = 0; i < n; i++) inorder.add(i,sc.nextInt());\n\n        reconstruction(0,n);\n\n        StringBuilder sb = new StringBuilder().append(postorder.get(0));\n\n        for (int i = 1; i < n; i++) {\n            sb.append(\" \").append(postorder.get(i));\n        }\n        System.out.println(sb.toString());\n\n    }\n\n    static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() { return Integer.parseInt(next()); }\n        long nextLong() { return Long.parseLong(next()); }\n        double nextDouble() { return Double.parseDouble(next()); }\n\n        String nextLine(){\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tprivate static int rootNumber;\n\n\tpublic static void main(String[] args) {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\n\t\tint[] preorder = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpreorder[i] = sc.nextInt();\n\t\t}\n\n\t\tint[] inorder = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tinorder[i] = sc.nextInt();\n\t\t}\n\n\t\trootNumber = 0;\n\t\tpostorder(inorder,inorder,preorder[0],preorder);\n\t\tSystem.out.println();\n\n\t}\n\n\tpublic static void postorder(int[] inorder, int[] order, int root, int[] preorder){\n\t\tfor (int i = 0; i < order.length; i++) {\n\t\t\tif (order[i] == root) {\n\t\t\t\tif (i != 0) {\n\t\t\t\t\trootNumber++;\n\t\t\t\t\tint newRoot = preorder[rootNumber];\n\t\t\t\t\tint[] order1 = new int[i];\n\n\t\t\t\t\tfor (int j = 0; j < order1.length; j++) {\n\t\t\t\t\t\torder1[j] = inorder[j];\n\t\t\t\t\t}\n\n\t\t\t\t\tpostorder(inorder, order1, newRoot, preorder);\n\n\t\t\t\t}\n\n\t\t\t\tif (i != order.length - 1) {\n\t\t\t\t\trootNumber++;\n\t\t\t\t\tint newRoot = preorder[rootNumber];\n\t\t\t\t\tint[] order1 = new int[order.length -1 - i];\n\n\t\t\t\t\tfor (int j = 0; j < order1.length; j++) {\n\t\t\t\t\t\torder1[j] = inorder[i+1+j];\n\t\t\t\t\t}\n\n\t\t\t\t\tpostorder(inorder, order1, newRoot, preorder);\n\t\t\t\t}\n\n\t\t\t\tif (order[i] != preorder[0]) {\n\t\t\t\t\tSystem.out.print(order[i] + \" \");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.print(order[i]);\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int[] preorder = new int[n];\n        int[] inorder = new int[n];\n        for (int i = 0; i < n; i++) {\n            preorder[i] = in.nextInt();\n        }\n        for (int i = 0; i < n; i++) {\n            inorder[i] = in.nextInt();\n        }\n        Tree tree = Tree.reconstructTree(preorder, inorder, 0, 0, n-1);\n        System.out.println(tree.postorder().trim());\n    }\n}\n\nclass Tree {\n    int id;\n    Tree left;\n    Tree right;\n\n    public Tree(int id, Tree left, Tree right) {\n        this.id = id;\n        this.left = left;\n        this.right = right;\n    }\n\n    static Tree reconstructTree(int[] preorder, int[] inorder, int root, int left, int right) {\n        if (left == right) {\n            return new Tree(inorder[left], null, null);\n        }\n\n        int rootInorder = 0;\n        while (inorder[rootInorder] != preorder[root]) {\n            rootInorder++;\n        }\n\n        if (left == rootInorder) {\n            return new Tree(preorder[root],\n                    null,\n                    reconstructTree(preorder, inorder, root+(rootInorder-left)+1, rootInorder + 1, right));\n        } else if (right == rootInorder) {\n            return new Tree(preorder[root],\n                    reconstructTree(preorder, inorder, root+1, left, rootInorder - 1),\n                    null);\n        } else {\n            return new Tree(preorder[root],\n                    reconstructTree(preorder, inorder, root+1, left, rootInorder - 1),\n                    reconstructTree(preorder, inorder, root+(rootInorder-left)+1, rootInorder + 1, right));\n        }\n    }\n\n    boolean isLeaf() {\n        return left == null && right == null;\n    }\n\n    String postorder() {\n        if (isLeaf()) {\n            return \" \" + id;\n        } else if (left == null) {\n            return right.postorder() + \" \" + id;\n        } else if (right == null) {\n            return left.postorder() + \" \" + id;\n        } else {\n            return left.postorder() + right.postorder() + \" \" + id;\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tprivate static int rootNumber;\n\n\tpublic static void main(String[] args) {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\n\t\tint[] preorder = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpreorder[i] = sc.nextInt();\n\t\t}\n\n\t\tint[] inorder = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tinorder[i] = sc.nextInt();\n\t\t}\n\n\t\trootNumber = 0;\n\t\tpostorder(inorder,preorder[0],preorder);\n\t\tSystem.out.println();\n\n\t}\n\n\tpublic static void postorder(int[] order, int root, int[] preorder){\n\t\tfor (int i = 0; i < order.length; i++) {\n\t\t\tif (order[i] == root) {\n\t\t\t\tif (i != 0) {\n\t\t\t\t\trootNumber++;\n\t\t\t\t\tint newRoot = preorder[rootNumber];\n\t\t\t\t\tint[] order1 = new int[i];\n\n\t\t\t\t\tfor (int j = 0; j < order1.length; j++) {\n\t\t\t\t\t\torder1[j] = order[j];\n\t\t\t\t\t}\n\n\t\t\t\t\tpostorder(order1, newRoot, preorder);\n\n\t\t\t\t}\n\n\t\t\t\tif (i != order.length - 1) {\n\t\t\t\t\trootNumber++;\n\t\t\t\t\tint newRoot = preorder[rootNumber];\n\t\t\t\t\tint[] order1 = new int[order.length -1 - i];\n\n\t\t\t\t\tfor (int j = 0; j < order1.length; j++) {\n\t\t\t\t\t\torder1[j] = order[i+1+j];\n\t\t\t\t\t}\n\n\t\t\t\t\tpostorder(order1, newRoot, preorder);\n\t\t\t\t}\n\n\t\t\t\tif (order[i] != preorder[0]) {\n\t\t\t\t\tSystem.out.print(order[i] + \" \");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.print(order[i]);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic int pos=0;\n\tstatic int c=0;\n\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k;\n\t\tint[] pre = new int[n];\n\t\tint[] in = new int[n];\n\t\tint[] post = new int[n];\n\t\t\n\t\t\n\t\tfor (int i=0; i<n; i++){\n\t\t\tpre[i] = sc.nextInt();\n\t\t}\n\t\t\n\t\tfor (int i=0; i<n; i++){\n\t\t\tin[i] = sc.nextInt();\n\t\t}\n\t\tsolve(n, pre, in, post);\n\t}\n\t\n\tstatic void rec(int n, int l, int r, int[] pre, int[] in, int[] post) {\n\t\tif (l >= r) return;\n\t\tint cnt=n;\n\t\tint root = pre[pos];\n\t\tpos++;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(in[i]==root) cnt=i;\n\t\t}\n\t\trec(n, l, cnt, pre, in, post);\n\t\trec(n, cnt + 1, r, pre, in, post);\n\t\tpost[c] = root;\n\t\tc++;\n\t\t\n\t\t\n\t}\n\t\n\tstatic void solve(int n, int[] pre, int[] in, int[] post){\n\t\tpos = 0;\n\t\trec(n, 0, n, pre, in, post);\n\t\tfor (int i=0; i<n-1; i++){\n\t\t\tSystem.out.print(post[i] + \" \");\n\t\t}\n\t\tSystem.out.println(post[n-1]);\n\t\t\n\t\t\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*\npublic class Main{\n        static Scanner sc = new Scanner(System.in);\n        static int n, pos;\n        static ArrayList<Integer> preorder = new ArrayList<Integer>();\n        static ArrayList<Integer> inorder = new ArrayList<Integer>();\n        public static BinaryTree reconstruction(int l, int r) {\n            if (l >= r){\n                return new BinaryTree();\n            }\n            int node = preorder.get(pos++);\n            int i = inorder.indexOf(node);\n            BinaryTree left = reconstruction(l, i);\n            BinaryTree right = reconstruction(i + 1, r);\n            return new BinaryTree(node, left, right); }\n            public static void read() { \n            n = sc.nextInt();\n            for (int i = 0; i < n; i++){ \n                preorder.add(sc.nextInt());\n            } \n            for (int i = 0; i < n; i++) { \n                inorder.add(sc.nextInt()); \n            } \n        } \n        public static void main(String[] args){ \n            read(); \n            pos = 0; \n            BinaryTree bt = reconstruction(0, preorder.size()); \n            System.out.println(bt); \n        } \n        public static class BinaryTree { \n            boolean isEmpty; \n            int node; \n            BinaryTree left; \n            BinaryTree right; \n            public BinaryTree(int node, BinaryTree left, BinaryTree right) { \n                this.isEmpty = false; \n                this.node = node; \n                this.left = left; \n                this.right = right; \n            } \n            public BinaryTree() { \n                this.isEmpty = true; \n            } \n            public String toString() { \n                if (this.isEmpty) \n                    return \"\"; \n                String l = this.left.toString() + \" \"; \n                String r = this.right.toString() + \" \"; \n                if (l.trim().equals(\"\")) { \n                    l = \"\"; \n                } \n                if (r.trim().equals(\"\")) { \n                    r = \"\"; \n                } \n                return l + r + this.node; \n            } \n        } \n    }\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\n/**\n * Created by sotetsuk on 2016/07/11.\n */\npublic class Main {\n    static Scanner sc = new Scanner(System.in);\n    static int n, pos;\n    static ArrayList<Integer> preorder = new ArrayList<Integer>();\n    static ArrayList<Integer> inorder = new ArrayList<Integer>();\n\n    public static BinaryTree reconstruction(int l, int r) {\n        if (l >= r) {\n            return new BinaryTree();\n        }\n\n        int node = preorder.get(pos++);\n        int i = inorder.indexOf(node);\n\n        BinaryTree left = reconstruction(l, i);\n        BinaryTree right = reconstruction(i + 1, r);\n\n        return new BinaryTree(node, left, right);\n    }\n\n    public static void read() {\n        n = sc.nextInt();\n        for (int i = 0; i < n; i++) {\n            preorder.add(sc.nextInt());\n        }\n        for (int i = 0; i < n; i++) {\n            inorder.add(sc.nextInt());\n        }\n    }\n\n    public static void main(String[] args) {\n        read();\n        pos = 0;\n        BinaryTree bt = reconstruction(0, preorder.size());\n        System.out.println(bt);\n    }\n\n    public static class BinaryTree {\n        boolean isEmpty;\n        int node;\n        BinaryTree left;\n        BinaryTree right;\n\n        public BinaryTree(int node, BinaryTree left, BinaryTree right) {\n            this.isEmpty = false;\n            this.node = node;\n            this.left = left;\n            this.right = right;\n        }\n\n        public BinaryTree() {\n            this.isEmpty = true;\n        }\n\n        public String toString() {\n            if (this.isEmpty) return \"\";\n            String l = this.left.toString() + \" \";\n            String r = this.right.toString() + \" \";\n\n            if (l.trim().equals(\"\")) {\n                l = \"\";\n            }\n            if (r.trim().equals(\"\")) {\n                r = \"\";\n            }\n\n            return l + r + this.node;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static int reconstruction(final int n, final int pre_pos, final int in_start, final int in_end, int[] pre_order, int[] in_order, int[] n_left, int[] n_right){\n\t\tfinal int partition = pre_order[pre_pos];\n\t\t\n\t\t//System.out.println(pre_pos + \"[\" + pre_order[pre_pos] + \"] \" + in_start + \" \" + in_end + \" (\" + (partition + 1) + \")\");\n\t\t\n\t\tif(in_start + 1 >= in_end){\n\t\t\treturn partition;\n\t\t}\n\t\t\n\t\t//System.out.println(\"> \" + pre_pos + \" \" + in_start + \" \" + in_end + \" [\" + (partition + 1) + \"]\");\n\t\t\n\t\tfor(int in_pos = in_start; in_pos < in_end; in_pos++){\n\t\t\tif(in_order[in_pos] == partition){\n\t\t\t\tif(in_start < in_pos){\n\t\t\t\t\tn_left[partition] = reconstruction(n, pre_pos + 1, in_start, in_pos, pre_order, in_order, n_left, n_right);\n\t\t\t\t}else{\n\t\t\t\t\tn_left[partition] = -1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(in_pos < in_end && pre_pos + (in_pos - in_start + 1) < n){\n\t\t\t\t\tn_right[partition] = reconstruction(n, pre_pos + (in_pos - in_start + 1), in_pos + 1, in_end, pre_order, in_order, n_left, n_right);\n\t\t\t\t}else{\n\t\t\t\t\tn_right[partition] = -1;\n\t\t\t\t}\n\t\t\t\t//System.out.println(n_left[in_pos] + \"<-\" + partition + \"->\" + n_right[in_pos]);\n\t\t\t\treturn partition;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn partition;\n\t}\n\t\n\tpublic static void postorder(int node, int[] n_left, int[] n_right, LinkedList<Integer> list){\n\t\tif(n_left[node]  != -1){ postorder(n_left[node] , n_left, n_right, list); }\n\t\tif(n_right[node] != -1){ postorder(n_right[node], n_left, n_right, list); }\n\t\tlist.add(node);\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int n = sc.nextInt();\n\t\tint[] pre_order = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpre_order[i] = sc.nextInt() - 1;\n\t\t}\n\t\tint[] in_order = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tin_order[i] = sc.nextInt()  - 1;\n\t\t}\n\t\t\n\t\tint[] n_left = new int[n];\n\t\tint[] n_right = new int[n];\n\t\tArrays.fill(n_left, -1);\n\t\tArrays.fill(n_right, -1);\n\t\t\n\t\tfinal int root = reconstruction(n, 0, 0, n, pre_order, in_order, n_left, n_right);\n\t\t//System.out.println(root);\n\t\tLinkedList<Integer> list = new LinkedList<Integer>();\n\t\t//System.out.println(Arrays.toString(n_left));\n\t\t//System.out.println(Arrays.toString(n_right));\n\t\tpostorder(root, n_left, n_right, list);\n\t\tboolean first = true;\n\t\tfor(int num : list){\n\t\t\tif(first){ first = false; }\n\t\t\telse{ System.out.print(\" \"); }\n\t\t\tSystem.out.print(num + 1);\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tpublic static class Scanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tprivate class Node<T> {\n\t\tT value;\n\t\tNode<T> left;\n\t\tNode<T> right;\n\t\tpublic Node(T value) {\n\t\t\tthis.value = value;\n\t\t\tleft = right = null;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn value.toString();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\t\n\tprivate void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(reader.readLine());\n\t\tint[] pre = new int[n];\n\t\tint[] in = new int[n];\n\t\tStringTokenizer st1 = new StringTokenizer(reader.readLine());\n\t\tStringTokenizer st2 = new StringTokenizer(reader.readLine());\n\t\tint rootId = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpre[i] = Integer.parseInt(st1.nextToken());\n\t\t\tin[i] = Integer.parseInt(st2.nextToken());\n\t\t\tif (i == 0) {\n\t\t\t\trootId = pre[i];\n\t\t\t}\n\t\t}\n\t\treader.close();\n\t\t\n\t\tNode<Integer> rootNode = new Node<Integer>(rootId);\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tNode<Integer> current = new Node<Integer>(pre[i]);\n\t\t\taddNode(rootNode, current, in);\n\t\t}\n\t\tpostOrder(rootNode);\n\t}\n\n\tprivate void postOrder(Node<Integer> rootNode) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tStack<Node<Integer>> stack = new Stack<Node<Integer>>();\n\t\tNode<Integer> current = rootNode;\n\t\tNode<Integer> lastVisited = null;\n\t\twhile (current != null || !stack.isEmpty()) {\n\t\t\tif (current != null) {\n\t\t\t\tstack.push(current);\n\t\t\t\tcurrent = current.left;\n\t\t\t} else {\n\t\t\t\tNode<Integer> peekNode = stack.peek();\n\t\t\t\tif (peekNode.right != null && peekNode.right != lastVisited) {\n\t\t\t\t\tcurrent = peekNode.right;\n\t\t\t\t} else {\n\t\t\t\t\tif (sb.length() == 0) {\n\t\t\t\t\t\tsb.append(peekNode);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsb.append(\" \" + peekNode);\n\t\t\t\t\t}\n\t\t\t\t\tlastVisited = stack.pop();\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t\tSystem.out.println(sb.toString());\n\t}\n\n\tprivate void addNode(Node<Integer> rootNode, Node<Integer> newNode, int[] in) {\n\t\tint pos1 = findPos(in, newNode.value);\n\t\tStack<Node<Integer>> stack = new Stack<Node<Integer>>();\n\t\tstack.push(rootNode);\n\t\twhile (!stack.isEmpty()) {\t\t\t\n\t\t\tNode<Integer> current = stack.pop();\n\t\t\tint pos2 = findPos(in, current.value);\n\t\t\tif (pos1 < pos2) {\n\t\t\t\tif (current.left == null) {\n\t\t\t\t\tcurrent.left = newNode;\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tstack.push(current.left);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (current.right == null) {\n\t\t\t\t\tcurrent.right = newNode;\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tstack.push(current.right);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int findPos(int[] in, int id) {\n\t\tfor (int i = 0; i < in.length; i++) {\n\t\t\tif (in[i] == id) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\n/**\n * @see <a href='http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?lang=jp&id='>??????</a>\n */\npublic class Main {\n    private static FastReader in = new FastReader();\n\n    public static void main(String[] args) throws Exception {\n        Main main = new Main();\n        main.run();\n    }\n\n    private int[] preOrder, inOrder, postOrder;\n    private int pos = 0, count = 0;\n\n    private void run() {\n        int n = in.nextInt();\n        preOrder = in.nextIntArray(n);\n        inOrder = in.nextIntArray(n);\n        postOrder = new int[n];\n\n        restore(0, n);\n    }\n\n    private void restore(int left, int right) {\n        if (left >= right) return;\n        int root = preOrder[pos++];\n        int middle = 0;\n        while (inOrder[middle] != root) {\n            middle++;\n        }\n        restore(left, middle);\n        restore(middle + 1, right);\n        postOrder[count++] = root;\n    }\n}\n\nclass FastReader {\n    private InputStream in = System.in;\n    private byte[] buf = new byte[1024];\n    private int charNum;\n    private int charLen;\n    private StringBuilder sb = new StringBuilder();\n\n    public int read() {\n        if (charLen == -1)\n            throw new InputMismatchException();\n        if (charNum >= charLen) {\n            charNum = 0;\n            try {\n                charLen = in.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (charLen <= 0)\n                return -1;\n        }\n        return buf[charNum++];\n    }\n\n    public String next() {\n        int c = read();\n        while (isWhitespace(c)) {\n            c = read();\n        }\n        sb.setLength(0);\n        do {\n            sb.appendCodePoint(c);\n            c = read();\n        } while (!isWhitespace(c));\n        return sb.toString();\n    }\n\n    public char[] nextCharArray() {\n        return next().toCharArray();\n    }\n\n    public int nextInt() {\n        return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n        int[] array = new int[n];\n        for (int i = 0; i < n; i++)\n            array[i] = nextInt();\n        return array;\n    }\n\n    public List<Integer> nextIntList(int n) {\n        Integer[] array = new Integer[n];\n        for (int i = 0; i < n; i++)\n            array[i] = nextInt();\n        return Arrays.asList(array);\n    }\n\n    public int[][] nextIntArray2D(int n, int m) {\n        int[][] array = new int[n][m];\n        for (int i = 0; i < n; i++)\n            array[i] = nextIntArray(m);\n        return array;\n    }\n\n    public List<int[]> nextIntsList(int n, int m) {\n        List<int[]> list = new ArrayList<int[]>(n);\n        for (int i = 0; i < n; i++)\n            list.add(nextIntArray(m));\n        return list;\n    }\n\n    public long nextLong() {\n        int c = read();\n        while (isWhitespace(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isWhitespace(c));\n        return res * sgn;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public double[] nextDoubleArray(int n) {\n        double[] array = new double[n];\n        for (int i = 0; i < n; i++)\n            array[i] = nextDouble();\n        return array;\n    }\n\n    public boolean isWhitespace(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t * @throws NumberFormatException \n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\t\n\t\tString[] tmpArray = br.readLine().split(\" \");\n\t\tNode[] nodes = new Node[n];\n\t\tint[] pre = new int[n];\n\t\tfor(int i = 0; i < n ; i++){\n\t\t\tpre[i] = Integer.parseInt(tmpArray[i]) - 1;\n\t\t\tnodes[i] = new Node(i, -1, -1);\n\t\t\tnodes[i].nodes = nodes;\n\t\t}\n\t\ttmpArray = br.readLine().split(\" \");\n\t\tint[] in = new int[n];\n\t\tfor(int i = 0; i < n ; i++){\n\t\t\tin[i] = Integer.parseInt(tmpArray[i]) - 1;\n\t\t}\n\t\t\n\t\treconstruct(nodes, pre, in);\n\t\t\n\t\t//root??¢???\n\t\tint rootIdx = -1;\n\t\tfor(int i = 0; i < nodes.length ;i++){\n\t\t\tif(nodes[i].parent == -1){\n\t\t\t\trootIdx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpostorder(nodes, rootIdx, 1);\n\t\tSystem.out.println();\n\n\t}\n\t\n\tstatic int reconstruct(Node[] nodes, int[] pre, int[] in){\n\t\tif(pre.length ==1 || in.length == 1){\n\t\t\treturn pre[0];\n\t\t}\n\t\t//???????????????pre[0]???????????????\n\t\tint rootIndex = pre[0];\n\t\tint subLen = 0;\n\t\tfor(int i = 0; i < in.length ; i++){\n\t\t\tif(in[i] == pre[0]){\n\t\t\t\tsubLen = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint leftIndex = -1;\n\t\tint rightIndex = -1;\n\t\t//?????´?????¨?????¨\n\t\tif(subLen >= 1){\n\t\t\tleftIndex = reconstruct(nodes, Arrays.copyOfRange(pre, 1, 1 + subLen), Arrays.copyOfRange(in, 0, subLen));\n\t\t}\n\t\t//?????´?????¨?????¨\n\t\tif(in.length - subLen - 1 >= 1){\n\t\t\trightIndex = reconstruct(nodes, Arrays.copyOfRange(pre, subLen + 1, pre.length), Arrays.copyOfRange(in, subLen + 1, pre.length));\n\t\t}\n\t\t\n\t\tnodes[rootIndex].left = leftIndex;\n\t\tnodes[rootIndex].right = rightIndex;\n\t\treturn rootIndex;\n\t}\n\t\n\tstatic void postorder(Node[] nodes, int index){\n\t\tif(nodes[index].left != -1){\n\t\t\tpostorder(nodes, nodes[index].left);\n\t\t}\n\t\tif(nodes[index].right != -1){\n\t\t\tpostorder(nodes, nodes[index].right);\n\t\t}\t\t\n\t\tSystem.out.print(\" \"+nodes[index].id);\n\t}\n\tstatic void postorder(Node[] nodes, int index, int fix){\n\t\tif(nodes[index].left != -1){\n\t\t\tpostorder(nodes, nodes[index].left, fix);\n\t\t}\n\t\tif(nodes[index].right != -1){\n\t\t\tpostorder(nodes, nodes[index].right, fix);\n\t\t}\t\t\n\t\tSystem.out.print(\" \"+(nodes[index].id+fix));\n\t}\n}\n\nclass Node {\n\tint id;\n\tint left = -1;\n\tint right = -1;\n\tint parent = -1;\n\tint sibling = -1;\n\tint degree = 0;\n\tNode[] nodes;\n\t\n\tpublic Node (int id, int left, int right){\n\t\tthis.id =id;\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t}\n\t\n\tint getDepth (){\n\t\tif(parent == -1){\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1 + nodes[parent].getDepth();\n\t}\n\t\n\tint getHeight (){\n\t\tif(left == -1 && right == -1){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint heightL = 0;\n\t\tif(left != -1){\n\t\t\theightL = nodes[left].getHeight();\n\t\t}\n\t\t\n\t\tint heightR = 0;\n\t\tif(right != -1){\n\t\t\theightR = nodes[right].getHeight();\n\t\t}\n\t\t\n\t\treturn Math.max(heightL, heightR) + 1;\n\t}\n\t\n\tString getType (){\n\t\tif(parent == -1){\n\t\t\treturn \"root\";\n\t\t}\n\t\telse if(left == -1 && right == -1){\n\t\t\treturn \"leaf\";\n\t\t}\n\t\telse {\n\t\t\treturn \"internal node\";\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.StringJoiner;\n\nclass Main {\n\n\tstatic int n;\n\n\tstatic int[] inOrd;\n\tstatic int[] preOrd;\n\tstatic int[] postOrd;\n\n\tstatic int cIdx = 0;\n\tstatic int rIdx = 0;\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tn = sc.nextInt();\n\n\t\tinOrd = new int[n];\n\t\tfor (int i = 0; i < n; i++) inOrd[i] = sc.nextInt();\n\n\t\tpreOrd = new int[n];\n\t\tfor (int i = 0; i < n; i++) preOrd[i] = sc.nextInt();\n\n\t\tsc.close();\n\n\t\tpostOrd = new int[n];\n\t\tpostOrder(0, n);\n\n\t\tStringJoiner sj = new StringJoiner(\" \");\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsj.add(String.valueOf(postOrd[i]));\n\t\t}\n\t\tSystem.out.println(sj);\n\n\t}\n\n\tprivate static void postOrder(int l, int r) {\n\n\t\tif(l >= r) return;\n\n\t\tint next = inOrd[cIdx];\n\t\tcIdx++;\n\n\t\tint m = -1;\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tif (preOrd[i] == next) {\n\t\t\t\tm = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpostOrder(l, m);\n\t\tpostOrder(m+1, r);\n\n\t\tpostOrd[rIdx] = next;\n\t\trIdx++;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class ALDS1_7_D {\n    static Scanner sc = new Scanner(System.in);\n    static int n, pos;\n    static ArrayList<Integer> preorder = new ArrayList<Integer>();\n    static ArrayList<Integer> inorder = new ArrayList<Integer>();\n\n    public static BinaryTree reconstruction(int l, int r) {\n        if (l >= r) {\n            return new BinaryTree();\n        }\n\n        int node = preorder.get(pos++);\n        int i = inorder.indexOf(node);\n\n        BinaryTree left = reconstruction(l, i);\n        BinaryTree right = reconstruction(i + 1, r);\n\n        return new BinaryTree(node, left, right);\n    }\n\n    public static void read() {\n        n = sc.nextInt();\n        for (int i = 0; i < n; i++) {\n            preorder.add(sc.nextInt());\n        }\n        for (int i = 0; i < n; i++) {\n            inorder.add(sc.nextInt());\n        }\n    }\n\n    public static void main(String[] args) {\n        read();\n        pos = 0;\n        BinaryTree bt = reconstruction(0, preorder.size());\n        System.out.println(bt);\n    }\n\n    public static class BinaryTree {\n        boolean isEmpty;\n        int node;\n        BinaryTree left;\n        BinaryTree right;\n\n        public BinaryTree(int node, BinaryTree left, BinaryTree right) {\n            this.isEmpty = false;\n            this.node = node;\n            this.left = left;\n            this.right = right;\n        }\n\n        public BinaryTree() {\n            this.isEmpty = true;\n        }\n\n        public String toString() {\n            if (this.isEmpty) return \"\";\n            String l = this.left.toString() + \" \";\n            String r = this.right.toString() + \" \";\n\n            if (l.trim().equals(\"\")) {\n                l = \"\";\n            }\n            if (r.trim().equals(\"\")) {\n                r = \"\";\n            }\n\n            return l + r + this.node;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\nclass Main{\n    static int[] preorder;\n    static int[] inorder;\n    static int[] postorder;\n    public static void main(String[] Args) throws IOException{\n        final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        final int n = Integer.parseInt(br.readLine());\n        preorder = new int[n];\n        inorder = new int[n];\n        postorder = new int[n];\n        StringTokenizer st;\n        st = new StringTokenizer(br.readLine(), \" \");\n        for(int i = 0; i<n; i++)\n            preorder[i] = Integer.parseInt(st.nextToken());\n        st = new StringTokenizer(br.readLine(), \" \");\n        for(int i = 0; i<n; i++)\n            inorder[i] = Integer.parseInt(st.nextToken());\n        rec(0, 0, 0, n);\n        final StringBuilder sb = new StringBuilder();\n        sb.append(postorder[0]);\n        for(int i = 1; i<n; i++){\n            sb.append(' ').append(postorder[i]);\n        }\n        System.out.println(sb);\n    }\n    static void rec(int pre, int in, int post, int n){\n        if(n<=0) return;\n        final int p = preorder[pre];\n        postorder[post+n-1] = p;\n        int i;\n        for(i = in; inorder[i]!=p; i++);\n        final int rlen = n-(i-in)-1;\n        rec(pre+1, in, post, i-in);\n        rec(pre+1+i-in, i+1, post+i-in, rlen);\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t * @throws NumberFormatException \n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\t\n\t\tString[] tmpArray = br.readLine().split(\" \");\n\t\tNode[] nodes = new Node[n];\n\t\tint[] pre = new int[n];\n\t\tfor(int i = 0; i < n ; i++){\n\t\t\tpre[i] = Integer.parseInt(tmpArray[i]) - 1;\n\t\t\tnodes[i] = new Node(i, -1, -1);\n\t\t\tnodes[i].nodes = nodes;\n\t\t}\n\t\ttmpArray = br.readLine().split(\" \");\n\t\tint[] in = new int[n];\n\t\tfor(int i = 0; i < n ; i++){\n\t\t\tin[i] = Integer.parseInt(tmpArray[i]) - 1;\n\t\t}\n\t\t\n\t\tint rootIdx = reconstruct(nodes, pre, in);\n\t\t\n\t\t//root??¢???\n\t\t/*\n\t\tint rootIdx = -1;\n\t\tfor(int i = 0; i < nodes.length ;i++){\n\t\t\tif(nodes[i].parent == -1){\n\t\t\t\trootIdx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t*/\n\t\trootIndex = rootIdx;\n\t\t\n\t\tpostorder(nodes, rootIdx, 1);\n\t\tSystem.out.println();\n\n\t}\n\t\n\tstatic int reconstruct(Node[] nodes, int[] pre, int[] in){\n\t\t/*System.out.print(\"pre \");\n\t\tfor(int i = 0; i < pre.length ; i++){\n\t\t\tSystem.out.print(pre[i] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tSystem.out.print(\"in \");\n\t\tfor(int i = 0; i < in.length ; i++){\n\t\t\tSystem.out.print(in[i] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\t*/\n\t\tif(pre.length ==1 || in.length == 1){\n\t\t\treturn pre[0];\n\t\t}\n\t\t//???????????????pre[0]???????????????\n\t\tint rootIndex = pre[0];\n\t\tint subLen = 0;\n\t\tfor(int i = 0; i < in.length ; i++){\n\t\t\tif(in[i] == pre[0]){\n\t\t\t\tsubLen = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint leftIndex = -1;\n\t\tint rightIndex = -1;\n\t\t//?????´?????¨?????¨\n\t\tif(subLen >= 1){\n\t\t\tleftIndex = reconstruct(nodes, Arrays.copyOfRange(pre, 1, 1 + subLen), Arrays.copyOfRange(in, 0, subLen));\n\t\t}\n\t\t//?????´?????¨?????¨\n\t\tif(in.length - subLen - 1 >= 1){\n\t\t\trightIndex = reconstruct(nodes, Arrays.copyOfRange(pre, subLen + 1, pre.length), Arrays.copyOfRange(in, subLen + 1, pre.length));\n\t\t}\n\t\t\n\t\tnodes[rootIndex].left = leftIndex;\n\t\tnodes[rootIndex].right = rightIndex;\n\t\t//System.out.println(\"left \"+leftIndex + \"right \"+ rightIndex);\n\t\treturn rootIndex;\n\t}\n\t\n\tstatic int rootIndex = -1;\n\tstatic void postorder(Node[] nodes, int index){\n\t\tif(nodes[index].left != -1){\n\t\t\tpostorder(nodes, nodes[index].left);\n\t\t}\n\t\tif(nodes[index].right != -1){\n\t\t\tpostorder(nodes, nodes[index].right);\n\t\t}\t\t\n\t}\n\tstatic void postorder(Node[] nodes, int index, int fix){\n\t\tif(nodes[index].left != -1){\n\t\t\tpostorder(nodes, nodes[index].left, fix);\n\t\t}\n\t\tif(nodes[index].right != -1){\n\t\t\tpostorder(nodes, nodes[index].right, fix);\n\t\t}\t\t\n\t\tSystem.out.print((nodes[index].id+fix));\n\t\t\n\t\tif(index != rootIndex){\n\t\t\tSystem.out.print(\" \");\n\t\t}\n\t}\n}\n\nclass Node {\n\tint id;\n\tint left = -1;\n\tint right = -1;\n\tint parent = -1;\n\tint sibling = -1;\n\tint degree = 0;\n\tNode[] nodes;\n\t\n\tpublic Node (int id, int left, int right){\n\t\tthis.id =id;\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t}\n\t\n\tint getDepth (){\n\t\tif(parent == -1){\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1 + nodes[parent].getDepth();\n\t}\n\t\n\tint getHeight (){\n\t\tif(left == -1 && right == -1){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint heightL = 0;\n\t\tif(left != -1){\n\t\t\theightL = nodes[left].getHeight();\n\t\t}\n\t\t\n\t\tint heightR = 0;\n\t\tif(right != -1){\n\t\t\theightR = nodes[right].getHeight();\n\t\t}\n\t\t\n\t\treturn Math.max(heightL, heightR) + 1;\n\t}\n\t\n\tString getType (){\n\t\tif(parent == -1){\n\t\t\treturn \"root\";\n\t\t}\n\t\telse if(left == -1 && right == -1){\n\t\t\treturn \"leaf\";\n\t\t}\n\t\telse {\n\t\t\treturn \"internal node\";\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n    private static int cnt = 0;\n    public static void main(String [] args){\n        Scanner sc = new Scanner(System.in);\n        int n  = sc.nextInt();\n        int [] pt = new int[n];\n        int [] it = new int[n];\n        for(int i=0;i<n;i++) pt[i] = sc.nextInt();\n        for(int i=0;i<n;i++) it[i] = sc.nextInt();\n        reconstruction(0,n,0,pt,it);\n        System.out.println();\n    }\n    public static int getindex(int [] L,int  value){\n        for(int i=0;i<L.length;i++) if(L[i] == value) return i;\n        return -1;\n    }\n    public static int  reconstruction(int l,int r,int pre_id,int [] pt,int [] it){\n        if(l<r){\n            int next_value = pt[pre_id++];\n            int it_id = getindex(it,next_value);\n            pre_id = reconstruction(l,it_id,pre_id,pt,it);\n            pre_id = reconstruction(it_id+1,r,pre_id,pt,it);\n            if(cnt==pt.length-1) System.out.print(next_value);\n            else{\n                System.out.print(next_value+\" \");\n                cnt++;\n            }\n        }\n        return pre_id;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n  static int []pre, in , post;\n  static int n, pos,count;\n  public static void main(String args[]){\n    Scanner sc = new Scanner(System.in);\n\n    n = sc.nextInt();\n    int k;\n    pre = new int[n];\n    in = new int[n];\n    post = new int[n];\n    for(int i =0; i<n; i++){\n      k = sc.nextInt();\n      pre[i] = k;\n    }\n\n    for(int i = 0; i<n; i++){\n      k = sc.nextInt();\n      in[i] = k;\n    }\n    solve();\n  }\n\n  static void rec( int l, int r){\n    if( l >= r)return;\n    int root = pre[pos++];\n    int m=0;\n    while(in[m] != root)m++;\n    rec(l,m);\n    rec(m+1,r);\n    post[count++] = root;\n  }\n\n  static void solve(){\n    pos = 0;\n    rec(0, n);\n    StringBuilder bl = new StringBuilder();\n    for (int i = 0; i < n-1; i++) {\n      bl.append(post[i]);\n      bl.append(\" \");\n    }\n    bl.append(post[n-1]);\n    bl.append(\"\\n\");\n    System.out.print(bl);\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws NumberFormatException,\n\t\t\tIOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws NumberFormatException, IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tint[][] pre = new int[n][2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpre[i][0] = scanner.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = scanner.nextInt();\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (pre[j][0] == t) {\n\t\t\t\t\tpre[j][1] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trec(0, n, pre);\n\n\t}\n\n\tint pos = 0;\n\n\tprivate void rec(int l, int r, int[][] pre) {\n\t\tif (l >= r)\n\t\t\treturn;\n\t\tint root = pre[pos][0];\n\t\tint m = pre[pos][1];\n\t\tpos++;\n\t\trec(l, m, pre);\n\t\trec(m + 1, r, pre);\n\t\tSystem.out.print(root);\n\t\tSystem.out.print(root == pre[0][0] ? '\\n' : ' ');\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class Main {\n    static void reconstruction(\n            Iterator<Integer> preItr, List<Integer> inWalked, List<Integer> postWalked, int l, int r) {\n        if (l >= r) return;\n\n        int curr = preItr.next();\n        int m = inWalked.indexOf(curr);\n\n        reconstruction(preItr, inWalked, postWalked, l, m);\n        reconstruction(preItr, inWalked, postWalked, m + 1, r);\n\n        postWalked.add(curr);\n    }\n\n    public static void main(String[] args) {\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(System.in))) {\n            final int n = Integer.parseInt(in.readLine());\n            List<Integer> preWalked = Stream.of(in.readLine().split(\" \"))\n                    .map(Integer::valueOf)\n                    .collect(Collectors.toList());\n            List<Integer> inWalked = Stream.of(in.readLine().split(\" \"))\n                    .map(Integer::valueOf)\n                    .collect(Collectors.toList());\n\n            List<Integer> postWalked = new ArrayList<>(n);\n\n            reconstruction(preWalked.iterator(), inWalked, postWalked, 0, n);\n\n            System.out.println(postWalked.stream().map(String::valueOf).collect(Collectors.joining(\" \")));\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n\tpublic static void main(String[] args){\n\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tNodes mynodes = new Nodes();\n\t\tNode[] nodes = new Node[n];\n\t\tmynodes.nodes = nodes;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tnodes[i] = new Node(i);\n\n\t\tint[] pre = new int[n];\n\t\tint[] in = new int[n];\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tpre[i] = scan.nextInt();\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tin[i] = scan.nextInt();\n\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(in[j] == pre[i-1]){\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(in[j] == pre[i]){\n\t\t\t\t\tmynodes.setLeft(pre[i-1], pre[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(pre[j] == in[i-1]){\n\t\t\t\t\tmynodes.setRight(in[i-1], mynodes.getRoot(in[i]));\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(pre[j] == in[i]){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint root = 1;\n\t\twhile(nodes[root].parent != -1)\n\t\t\troot = nodes[root].parent;\n\n\t\tmynodes.printPost(root);\n\t\tSystem.out.print(\"\\n\");\n\t}\n}\n\nclass Node{\n\tint id;\n\tint parent, left, right;\n\tpublic Node(int id){\n\t\tthis.id = id;\n\t\tthis.parent = -1;\n\t\tthis.left = -1;\n\t\tthis.right = -1;\n\t}\n}\n\nclass Nodes{\n\n\tNode[] nodes;\n\n\tpublic int getRoot(int id){\n\t\tif(nodes[id].parent == -1)\n\t\t\treturn id;\n\t\treturn getRoot(nodes[id].parent);\n\t}\n\n\tboolean first = true;\n\n\tpublic void printPost(int id){\n\t\tif(id == -1)\n\t\t\treturn;\n\t\tprintPost(nodes[id].left);\n\t\tprintPost(nodes[id].right);\n\t\tif(first){\n\t\t\tSystem.out.print(id);\n\t\t\tfirst = false;\n\t\t}else{\n\t\t\tSystem.out.print(\" \" + id);\n\t\t}\n\t}\n\n\tpublic void setLeft(int id, int left){\n\t\tnodes[id].left = left;\n\t\tnodes[left].parent = id;\n\t}\n\n\tpublic void setRight(int id, int right){\n\t\tnodes[id].right = right;\n\t\tnodes[right].parent = id;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\t\n\tint n, pos;\n\tArrayList<Integer> Pre = new ArrayList<>();\n\tArrayList<Integer> In = new ArrayList<>();\n\tArrayList<Integer> Post = new ArrayList<>();\n\t\n\t//入力\n\tpublic void input() {\n\t\tint k;\n\t\tn = sc.nextInt();\n\t\t//先行順巡回\n\t\tfor(int i=0; i<n; i++) { k = sc.nextInt(); Pre.add(k); }\n\t\t//中間順巡回\n\t\tfor(int i=0; i<n; i++) { k = sc.nextInt(); In.add(k); }\n\t}\n\t\n\t//後行順に出力\n\tpublic void solve() {\n\t\tpos = 0;\n\t\trec( 0, Pre.size() );\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tif(i==0) System.out.print( Post.get(i) );\n\t\t\telse System.out.print(\" \"+Post.get(i));\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\t//木の修復\n\tpublic void rec(int l, int r) {\n\t\tif(l >= r) return;\n\t\tint root = Pre.get(pos++);\n\t\tint m = In.indexOf(root);\n\t\trec(l, m);\n\t\trec(m+1, r);\n\t\tPost.add(root);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.input();\n\t\tobj.solve();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.stream.*;\nimport java.io.*;\n\npublic class Main {\n\n  static int n, pos, ansInp;\n  static int[] pre, inp, post;\n\n  static void reconstruction(int l, int r){\n    if(l >= r) return;\n\n    int c = pre[pos++], m = 0;\n    for(; m < n; m++){\n      if(inp[m] == c) break;\n    }\n\n    reconstruction(l, m);\n    reconstruction(m+1, r);\n\n    post[ansInp++] = c;\n    return;\n  }\n  \n  public static void main(String[] args) throws Exception {\n    \n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    \n    String[] in = br.readLine().split(\" \");\n    n = Integer.parseInt(in[0]);\n    in = br.readLine().split(\" \");\n    pre = Stream.of(in).mapToInt(Integer::parseInt).toArray();\n    in = br.readLine().split(\" \");\n    inp = Stream.of(in).mapToInt(Integer::parseInt).toArray();\n    post = new int[n];\n\n    br.close();\n\n    pos = 0;\n    ansInp = 0;\n    reconstruction(0, n);\n\n    for(int i = 0; i < n; i++){\n      if(i > 0) System.out.print(\" \");\n      System.out.print(post[i]);\n    }\n\n    System.out.println();\n\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nclass Main {\n    public static void main(String args[]) {\n        java.util.Scanner sc = new java.util.Scanner(System.in);\n        int n = Integer.parseInt(sc.next());\n        int[] pre = new int[n];\n        for(int i=0; i<n; i++)  pre[i] = Integer.parseInt(sc.next());\n        int[] ino = new int[n];\n        for(int i=0; i<n; i++)  ino[i] = Integer.parseInt(sc.next());\n\n        Tree tree = new Tree(pre, ino);\n        tree.rebuild(0, n);\n        tree.showAns();\n    }\n\n    static class Tree{\n        private final int[] pre;\n        private final int[] ino;\n        private int rootIdPre = 0;\n        private int[] post;\n        private int numAns = 0;\n\n        public Tree(int[] pre, int[] ino){\n            this.pre = pre;\n            this.ino = ino;\n            this.post = new int[pre.length];\n        }\n\n        private void rebuild(int left, int right){\n            if(left >= right)   return;\n            int rootNum = pre[this.rootIdPre++];\n            int rootIdIno = searchRootInorder(rootNum, left, right);\n            \n            rebuild(left, rootIdIno);\n            rebuild(rootIdIno+1, right);\n            this.post[this.numAns++] = rootNum;\n        }\n\n        private int searchRootInorder( int rootValue, int left, int right){\n            for(int i=left; i<right; i++){\n                if(this.ino[i] == rootValue) return i;\n            }\n            return -1;\n        }\n        public void showAns(){\n            for(int i=0; i<this.post.length; i++){\n                if(i == this.post.length-1){\n                    System.out.println(this.post[i]);\n                } else {\n                    System.out.print(this.post[i]+\" \");\n                }\n            }\n        }\n\n\n    }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int pos=0;\n\tstatic int cnt=0;\n\tstatic int[] post,pre,in;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\tScanner scan=new Scanner(System.in);\n\t\tint n=scan.nextInt();\n\t\t\n\t\tpre=new int[n];\n\t\tin=new int[n];\n\t\tpost=new int[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tpre[i]=scan.nextInt();\n\t\tfor(int i=0;i<n;i++)\n\t\t\tin[i]=scan.nextInt();\n\t\trec(0,n);\n\t\t\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tSystem.out.print(post[i]+\" \");\n\t\t}\n\t\tSystem.out.println(post[n-1]);\n\t}\n\n\tprivate static void rec(int l, int r) {\n\t\t// TODO Auto-generated method stub\n\t\tif(l>=r)\n\t\t\treturn;\n\t\tint c=pre[pos++];\n\t\tint m=0;\n\t    \n\t    \n\t\twhile(c!=in[m]){\n\t\t\t\tm++;\n\t\t}\n\t\trec(l, m);\n\t\trec(m+1, r);\n\t\tpost[cnt++]=c;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Node {\n\tint id;\n\tNode left, right;\n\n\tpublic Node(int id) {\n\t\tsuper();\n\t\tthis.id = id;\n\t}\n\n}\n\npublic class Main {\n\n\tstatic Node[] preorder, inorder;\n\tstatic int pre;\n\tstatic StringBuilder sb;\n\n\tpublic static int nextPre() {\n\t\treturn preorder[pre++].id;\n\t}\n\n\tpublic static int find(int c, Node[] inorder, int l, int r) {\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tif (c == inorder[i].id) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic static void reconstruction(int l, int r, Node[] inorder) {\n\t\tif (l >= r) {\n\t\t\treturn;\n\t\t}\n\n\t\tint c = nextPre();\n\t\tint m = find(c, inorder, l, r);\n\n\t\treconstruction(l, m, inorder);\n\t\treconstruction(m + 1, r, inorder);\n\n\t\tsb.append(c + \" \");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\n\t\tpreorder = new Node[n]; inorder = new Node[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpreorder[i] = new Node(sc.nextInt());\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tinorder[i] = new Node(sc.nextInt());\n\t\t}\n\n\t\tsb = new StringBuilder();\n\t\treconstruction(0, n, inorder);\n\t\tsb.deleteCharAt(sb.length() - 1);\n\t\tSystem.out.println(sb.toString());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n  int n, pPre,pPost;\n  int[] pre,in,post;\n\n  public static void main(String[] args) {\n    \n    new Main().run();\n  }\n\n  public void run() {\n    \n    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {\n\n      n = Integer.parseInt(br.readLine());\n      String[] linesPre =  br.readLine().split(\" \");\n      String[] linesIn  =  br.readLine().split(\" \");\n\n      pre  = new int[n];\n      in   = new int[n];\n      post = new int[n];\n  \n      for(int i=0; i<n; i++){\n        pre[i] = Integer.parseInt(linesPre[i]);\n        in[i]  = Integer.parseInt(linesIn[i] );\n      }\n\n      solve();\n\n    } catch ( IOException e ) {\n      System.out.println(\"IOException!\");\n    }\n  }\n  \n  void solve() {\n    pPre = pPost = 0;\n    StringBuilder buf = new StringBuilder();\n\n    rec(0,pre.length);\n\n    for (int var : post) {\n      buf.append(var).append(\" \");\n    }\n    buf.setLength(buf.length()-1);\n    System.out.println(buf);\n  }\n\n  void rec(int l, int r) {\n    if( l < r ) {\n      int root = pre[pPre++];\n      int m = arrayDistance(0, in.length, root);\n\n      rec(l,m);\n      rec(m+1,r);\n  \n      post[pPost++] = root;\n    }\n  }\n\n  int arrayDistance(int start, int end, int find) {\n    int d=start;\n\n    for( ; d<end; d++)\n      if( in[d] == find ) break;\n\n    return d;\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int cnt, pos;\n\tstatic int[] pre, in, post;\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tpre = new int[n];\n\t\tin = new int[n];\n\t\tpost = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpre[i] = scan.nextInt();\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tin[i] = scan.nextInt();\n\t\t}\n\t\tscan.close();\n\t\tcnt = 0;\n\t\tpos = 0;\n\t\trec(0, n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(i == n - 1) {\n\t\t\t\tSystem.out.println(post[i]);\n\t\t\t}else {\n\t\t\t\tSystem.out.print(post[i] +\" \");\n\t\t\t}\n\t\t}\n\t}\n\t// 二分木の復元\n\tstatic void rec(int l, int r) {\n\t\tif(l >= r) return;\n\t\tint root = pre[pos++];\n\t\tint mid = 0;\n\t\twhile(in[mid] != root) {\n\t\t\tmid++;\n\t\t}\n\t\trec(l, mid);\n\t\trec(mid + 1, r);\n\t\tpost[cnt++] = root;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n        static Scanner sc = new Scanner(System.in);\n        static int n, pos;\n        static ArrayList<Integer> preorder = new ArrayList<Integer>();\n        static ArrayList<Integer> inorder = new ArrayList<Integer>();\n        public static BinaryTree reconstruction(int l, int r) {\n            if (l >= r){\n                return new BinaryTree();\n            }\n            int node = preorder.get(pos++);\n            int i = inorder.indexOf(node);\n            BinaryTree left = reconstruction(l, i);\n            BinaryTree right = reconstruction(i + 1, r);\n            return new BinaryTree(node, left, right); }\n            public static void read() { \n            n = sc.nextInt();\n            for (int i = 0; i < n; i++){ \n                preorder.add(sc.nextInt());\n            } \n            for (int i = 0; i < n; i++) { \n                inorder.add(sc.nextInt()); \n            } \n        } \n        public static void main(String[] args){ \n            read(); \n            pos = 0; \n            BinaryTree bt = reconstruction(0, preorder.size()); \n            System.out.println(bt); \n        } \n        public static class BinaryTree { \n            boolean isEmpty; \n            int node; \n            BinaryTree left; \n            BinaryTree right; \n            public BinaryTree(int node, BinaryTree left, BinaryTree right) { \n                this.isEmpty = false; \n                this.node = node; \n                this.left = left; \n                this.right = right; \n            } \n            public BinaryTree() { \n                this.isEmpty = true; \n            } \n            public String toString() { \n                if (this.isEmpty) \n                    return \"\"; \n                String l = this.left.toString() + \" \"; \n                String r = this.right.toString() + \" \"; \n                if (l.trim().equals(\"\")) { \n                    l = \"\"; \n                } \n                if (r.trim().equals(\"\")) { \n                    r = \"\"; \n                } \n                return l + r + this.node; \n            } \n        } \n    }\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n    static StringBuilder sb = new StringBuilder(\"\");\n    static int index = 0;\n\n    public static void main (String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] preorder = new int[n];\n        int[] inorder = new int[n];\n        for (int i = 0; i < n; i++) {\n            preorder[i] = sc.nextInt();\n        }\n        for (int i = 0; i < n; i++) {\n            inorder[i] = sc.nextInt();\n        }\n        Node[] nodes = new Node[n];\n        reconstruct(nodes, preorder, inorder, 0, n);\n        sb.deleteCharAt(0);\n        System.out.println(sb);\n    }\n\n    public static int reconstruct(Node[] nodes, int[] preorder, int[] inorder, int right, int left) {\n        if (left == right) return -1;\n\n        // find root\n        int root = 0;\n        outside: for (int i = 0; i < preorder.length; i++) {\n            for (int j = right; j < left; j++) {\n                if (preorder[i] == inorder[j]) {\n                    root = j;\n                    break outside;\n                }\n            }\n        }\n\n        int tempIndex = index;\n        index++;\n\n        nodes[tempIndex] = new Node(inorder[root], -1, -1);\n        nodes[tempIndex].left = reconstruct(nodes, preorder, inorder, right, root);\n        nodes[tempIndex].right = reconstruct(nodes, preorder, inorder, root + 1, left);\n\n        sb.append(\" \").append(nodes[tempIndex].id);\n\n        return tempIndex;\n    }\n}\n\nclass Node {\n    public int id;\n    public int left;\n    public int right;\n\n    public Node(int id, int left, int right) {\n        this.id = id;\n        this.left = left;\n        this.right = right;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.StringJoiner;\n\nclass Main {\n\n\tstatic int n;\n\n\tstatic int[] inOrd;\n\tstatic int[] preOrd;\n\tstatic int[] postOrd;\n\n\tstatic int cIdx = 0;\n\tstatic int rIdx = 0;\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tn = sc.nextInt();\n\n\t\tinOrd = new int[n];\n\t\tfor (int i = 0; i < n; i++) inOrd[i] = sc.nextInt();\n\n\t\tpreOrd = new int[n];\n\t\tfor (int i = 0; i < n; i++) preOrd[i] = sc.nextInt();\n\n\t\tsc.close();\n\n\t\tpostOrd = new int[n];\n\t\tpostOrder(0, n);\n\n\t\tStringJoiner sj = new StringJoiner(\" \");\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsj.add(String.valueOf(postOrd[i]));\n\t\t}\n\t\tSystem.out.println(sj);\n\n\t}\n\n\tprivate static void postOrder(int l, int r) {\n\n\t\tif(l >= r) return;\n\n\t\tint next = inOrd[cIdx];\n\t\tcIdx++;\n\n\t\tint m = -1;\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tif (preOrd[i] == next) {\n\t\t\t\tm = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpostOrder(l, m);\n\t\tpostOrder(m+1, r);\n\n\t\tpostOrd[rIdx] = next;\n\t\trIdx++;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\n//import java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// input\n\t\t//System.setIn(new FileInputStream(\"./input.txt\"));\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\t\n\t\tint[] pre = new int[n];\n\t\tString[] str = br.readLine().split(\" \");\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t pre[i] = Integer.parseInt(str[i]);\n\t\t}\n\t\t\n\t\tint[] in = new int[n];\n\t\tstr = br.readLine().split(\" \");\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t in[i] = Integer.parseInt(str[i]);\n\t\t}\n\n\t\t// make post and print\n\t\tSystem.out.println(post(pre, in));\n\t}\n\tpublic static String post(int[] pre, int[] in) {\n\t\t// search centre\n\t\tint i = 0;\n\t\twhile(pre[0] != in[i]){\n\t\t\ti += 1;\n\t\t}\n\t\t\n\t\tString str = \"\";\n\t\t\n\t\t// left\n\t\tif(i == 1){\n\t\t\tstr += String.valueOf(in[0]);\n\t\t}else{\n\t\t\tstr += post(Arrays.copyOfRange(pre, 1, i + 1), Arrays.copyOfRange(in, 0, i));\n\t\t}\n\t\t\n\t\t// right\n\t\tif(in.length - 1 - i == 1){ // num of right element == 1\n\t\t\tstr += \" \" + String.valueOf(in[in.length - 1]);\n\t\t}else{\n\t\t\tstr += post(Arrays.copyOfRange(pre, 1 + i, pre.length), Arrays.copyOfRange(in, i + 1, pre.length));\n\t\t}\n\t\t\n\t\t// centre\n\t\tstr += \" \" + String.valueOf(in[i]); // or pre[0]\n\t\t\n\t\treturn str;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\n// ALDS1_7_D\npublic class Main {\n\tNode root = null;\n\tint key = 0;\n\tvoid preParse(Node node) {\n\t\tif (node == null) return;\n\t\tSystem.out.print(\" \" + node.number);\n\t\tpreParse(node.left);\n\t\tpreParse(node.right);\n\t}\n\t\n\tvoid inParse(Node node) {\n\t\tif (node == null) return;\n\t\tinParse(node.left);\n\t\tSystem.out.print(\" \" + node.number);\n\t\tinParse(node.right);\n\t}\n\t\n\tvoid postParse(Node node, StringBuilder build) {\n\t\tif (node == null) return;\n\t\tpostParse(node.left, build);\n\t\tpostParse(node.right, build);\n\t\tbuild.append(\" \" + node.number);\n\t}\n\t\n\tvoid reTree(Node parent, int[] pre, int[] in, int pinindex, int left, int right) {\n\t\t// System.out.println(\"key:\"+key + \", left:\" + left + \", right:\" + right);\n\t\tif (key > pre.length-1) return;\n\t\tif (left > right) return;\n\t\tint inkey = -1;\n\t\tfor (int i = left; i <= right; i++) {\n\t\t\tif (pre[key] == in[i]) {\n\t\t\t\tinkey = i;\n\t\t\t}\n\t\t}\n\t\tif (inkey == -1) {\n\t\t\treturn;\n\t\t}\n\t\tNode node = new Node(pre[key]);\n\t\tif (parent == null) {\n\t\t\troot = node;\n\t\t} else if (pinindex > inkey) {\n\t\t\tparent.left = node;\n\t\t} else {\n\t\t\tparent.right = node;\n\t\t}\n\t\tkey++;\n\t\treTree(node, pre, in, inkey, left, inkey-1);\n\t\treTree(node, pre, in,  inkey, inkey+1, right);\n\t}\n\t\n\tvoid run() throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] pre = new int[n];\n\t\tint[] in = new int[n];\n\t\t// preorder\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpre[i] = sc.nextInt();\n\t\t\t\n\t\t}\n\t\t// inorder\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tin[i] = sc.nextInt();\n\t\t}\n\t\treTree(null, pre, in, -1, 0, pre.length-1);\n\t\tStringBuilder build = new StringBuilder();\n\t\tpostParse(root, build);\n\t\tbuild.deleteCharAt(0);\n\t\tSystem.out.println(build);\n\t\tsc.close();\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n}\n\nclass Node {\n\tint number;\n\tNode parent = null;\n\tNode left = null;\n\tNode right = null;\n\tNode(int number) {\n\t\tthis.number = number;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.ArrayList;\npublic class Main {\n    public static void main (String[] args) {\n\tScanner scan = new Scanner(System.in);\n\tint n = Integer.parseInt(scan.nextLine());\n\tint[] preorder = new int[n];\n\tint[] inorder = new int[n];\n\tString[] inputPre, inputIn;\n\tinputPre = scan.nextLine().split(\" \");\n\tinputIn = scan.nextLine().split(\" \");\n\tfor (int i = 0; i < n; i++) {\n\t    preorder[i] = Integer.parseInt(inputPre[i]);\n\t    inorder[i] = Integer.parseInt(inputIn[i]);\n\t}\n\tReconstructer recnst = new Reconstructer(preorder, inorder);\n\trecnst.runReconstruct();\n\trecnst.printPostorder();\n    }\n}\nclass Reconstructer {\n    int[] preorder;\n    int[] inorder;\n    int[] postorder;\n    int prePosition, postPosition;\n    Reconstructer (int[] preorder, int[] inorder) {\n\tthis.preorder = preorder;\n\tthis.inorder = inorder;\n\tpostorder = new int[preorder.length];\n    }\n    void runReconstruct () {\n\treconstruct(0, preorder.length);\n    }\n    void reconstruct (int left, int right) {\n\tif (left >= right) {\n\t    return;\n\t}\t\n\tint inPosition = 0;\n\tint node = preorder[prePosition++];\n\twhile (node != inorder[inPosition]) {\n\t    inPosition++;\n\t}\n\treconstruct(left, inPosition);\n\treconstruct(inPosition+1, right);\n\tpostorder[postPosition++] = node;\n    }\n    void printPostorder () {\n\tStringBuilder sb = new StringBuilder();\n\tint n = postorder.length;\n\tfor (int i = 0; i < n - 1; i++) {\n\t    sb.append(postorder[i] + \" \");\n\t}\n\tsb.append(postorder[n-1] + \"\\n\");\n\tSystem.out.print(sb);\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tprivate class Node<T> {\n\t\tT value;\n\t\tNode<T> left;\n\t\tNode<T> right;\n\t\tpublic Node(T value) {\n\t\t\tthis.value = value;\n\t\t\tleft = right = null;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn value.toString();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\t\n\tprivate void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(reader.readLine());\n\t\tint[] pre = new int[n];\n\t\tint[] in = new int[n];\n\t\tStringTokenizer st1 = new StringTokenizer(reader.readLine());\n\t\tStringTokenizer st2 = new StringTokenizer(reader.readLine());\n\t\tint rootId = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpre[i] = Integer.parseInt(st1.nextToken());\n\t\t\tin[i] = Integer.parseInt(st2.nextToken());\n\t\t\tif (i == 0) {\n\t\t\t\trootId = pre[i];\n\t\t\t}\n\t\t}\n\t\treader.close();\n\t\t\n\t\tNode<Integer> rootNode = new Node<Integer>(rootId);\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tNode<Integer> current = new Node<Integer>(pre[i]);\n\t\t\taddNode(rootNode, current, in);\n\t\t}\n\t\t\n\t\tpostOrder(rootNode);\n\t}\n\n\tprivate void postOrder(Node<Integer> rootNode) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tStack<Node<Integer>> stack = new Stack<Node<Integer>>();\n\t\tNode<Integer> current = rootNode;\n\t\tNode<Integer> lastVisited = null;\n\t\twhile (current != null || !stack.isEmpty()) {\n\t\t\tif (current != null) {\n\t\t\t\tstack.push(current);\n\t\t\t\tcurrent = current.left;\n\t\t\t} else {\n\t\t\t\tNode<Integer> peekNode = stack.peek();\n\t\t\t\tif (peekNode.right != null && peekNode.right != lastVisited) {\n\t\t\t\t\tcurrent = peekNode.right;\n\t\t\t\t} else {\n\t\t\t\t\tif (sb.length() == 0) {\n\t\t\t\t\t\tsb.append(peekNode);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsb.append(\" \" + peekNode);\n\t\t\t\t\t}\n\t\t\t\t\tlastVisited = stack.pop();\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t\tSystem.out.println(sb.toString());\n\t}\n\n\tprivate void addNode(Node<Integer> rootNode, Node<Integer> newNode, int[] in) {\n\t\tint pos1 = findPos(in, newNode.value);\n\t\tStack<Node<Integer>> stack = new Stack<Node<Integer>>();\n\t\tstack.push(rootNode);\n\t\twhile (!stack.isEmpty()) {\t\t\t\n\t\t\tNode<Integer> current = stack.pop();\n\t\t\tint pos2 = findPos(in, current.value);\n\t\t\tif (pos1 < pos2) {\n\t\t\t\tif (current.left == null) {\n\t\t\t\t\tcurrent.left = newNode;\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tstack.push(current.left);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (current.right == null) {\n\t\t\t\t\tcurrent.right = newNode;\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tstack.push(current.right);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int findPos(int[] in, int id) {\n\t\tfor (int i = 0; i < in.length; i++) {\n\t\t\tif (in[i] == id) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.Arrays;\n\npublic class Main {\n    class Node {\n        int id;\n        int left = -1, right = -1;\n        String nodeType = null;\n        Node(int id, int left, int right) {\n            this.id = id;\n            this.left = left;\n            this.right = right;\n        }\n        void print() {\n            System.out.println(id + \", \" + left + \", \" + right);\n        }\n    }\n    int[] result;\n    int resultIndex;\n    void postorder(Node[] nodes, int x) {\n        if (nodes[x].left != -1)\n            postorder(nodes, nodes[x].left);\n        if (nodes[x].right != -1)\n            postorder(nodes, nodes[x].right);\n        result[resultIndex++] = x;\n    }\n\n    Node[] nodes;\n    int[] pre;\n    int[] in;\n    int ap;\nint search(int b1p, int b2p) {\n        int center = -1;\n        if (ap >= pre.length) {\n            return -1;\n        }\n        int top = pre[ap];\n        if (b1p + 1 == b2p) {\n            nodes[top] = new Node(top, -1, -1);\n            return top;\n        } else if (b1p >= b2p) {\n            return -1;\n        }\n        for (int i = b1p; i < b2p; i++) {\n            if (top == in[i]) {\n                center = i;\n                break;\n            }\n        }\n        ap++;\n        int left = search(b1p, center);\n        if (left != -1) ap++;\n        int right = search(center+1, b2p);\n        nodes[top] = new Node(top, left, right);\n        return top;\n    }\nvoid run() {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        nodes = new Node[n+1];\n        pre = new int[n];\n        in  = new int[n];\n        int root = 0;\n        for (int i = 0; i < n; i++) {\n            int id = sc.nextInt();\n            if (i == 0) root = id;\n            pre[i] = id;\n        }\n        for (int i = 0; i < n; i++) {\n            int id = sc.nextInt();\n            in[i] = id;\n        }\n        search(0, nodes.length);\n        result = new int[n];\n        resultIndex = 0;\n        postorder(nodes, root);\n        System.out.print(result[0]);\n        for (int i = 1; i < result.length; i++) {\n            System.out.print(\" \" + result[i]);\n        }\n        System.out.println();\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    static Scanner sc = new Scanner(System.in);\n    static int n, pos;\n    static ArrayList<Integer> preorder = new ArrayList<Integer>();\n    static ArrayList<Integer> inorder = new ArrayList<Integer>();\n\n    public static BinaryTree reconstruction(int l, int r) {\n        if (l >= r) {\n            return new BinaryTree();\n        }\n\n        int node = preorder.get(pos++);\n        int i = inorder.indexOf(node);\n\n        BinaryTree left = reconstruction(l, i);\n        BinaryTree right = reconstruction(i + 1, r);\n\n        return new BinaryTree(node, left, right);\n    }\n\n    public static void read() {\n        n = sc.nextInt();\n        for (int i = 0; i < n; i++) {\n            preorder.add(sc.nextInt());\n        }\n        for (int i = 0; i < n; i++) {\n            inorder.add(sc.nextInt());\n        }\n    }\n\n    public static void main(String[] args) {\n        read();\n        pos = 0;\n        BinaryTree bt = reconstruction(0, preorder.size());\n        System.out.println(bt);\n    }\n\n    public static class BinaryTree {\n        boolean isEmpty;\n        int node;\n        BinaryTree left;\n        BinaryTree right;\n\n        public BinaryTree(int node, BinaryTree left, BinaryTree right) {\n            this.isEmpty = false;\n            this.node = node;\n            this.left = left;\n            this.right = right;\n        }\n\n        public BinaryTree() {\n            this.isEmpty = true;\n        }\n\n        public String toString() {\n            if (this.isEmpty) return \"\";\n            String l = this.left.toString() + \" \";\n            String r = this.right.toString() + \" \";\n\n            return (l + r + this.node).trim();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tprivate static int rootNumber;\n\n\tpublic static void main(String[] args) {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\n\t\tint[] preorder = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpreorder[i] = sc.nextInt();\n\t\t}\n\n\t\tint[] inorder = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tinorder[i] = sc.nextInt();\n\t\t}\n\n\t\trootNumber = 0;\n\t\tpostorder(inorder,inorder,preorder[0],preorder);\n\t\tSystem.out.println();\n\n\t}\n\n\tpublic static void postorder(int[] inorder, int[] order, int root, int[] preorder){\n\t\tfor (int i = 0; i < order.length; i++) {\n\t\t\tif (order[i] == root) {\n\t\t\t\tif (i != 0) {\n\t\t\t\t\trootNumber++;\n\t\t\t\t\tint newRoot = preorder[rootNumber];\n\t\t\t\t\tint[] order1 = new int[i];\n\n\t\t\t\t\tfor (int j = 0; j < order1.length; j++) {\n\t\t\t\t\t\torder1[j] = inorder[j];\n\t\t\t\t\t}\n\n\t\t\t\t\tpostorder(inorder, order1, newRoot, preorder);\n\n\t\t\t\t}\n\n\t\t\t\tif (i != order.length - 1) {\n\t\t\t\t\trootNumber++;\n\t\t\t\t\tint newRoot = preorder[rootNumber];\n\t\t\t\t\tint[] order1 = new int[order.length -1 - i];\n\n\t\t\t\t\tfor (int j = 0; j < order1.length; j++) {\n\t\t\t\t\t\torder1[j] = inorder[i+1+j];\n\t\t\t\t\t}\n\n\t\t\t\t\tpostorder(inorder, order1, newRoot, preorder);\n\t\t\t\t}\n\n\t\t\t\tSystem.out.print(order[i] + \" \");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\n/**\n * @see <a href='http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?lang=jp&id='>??????</a>\n */\npublic class Main {\n    private static FastReader in = new FastReader();\n\n    public static void main(String[] args) throws Exception {\n        Main main = new Main();\n        main.run();\n    }\n\n    private int[] preOrder, inOrder, postOrder;\n\n    private void run() {\n        int n = in.nextInt();\n        preOrder = in.nextIntArray(n);\n        inOrder = in.nextIntArray(n);\n        postOrder = new int[n];\n\n        restore(0, 0, 0, n);\n    }\n\n    private int restore(int pos, int count, int left, int right) {\n        if (left >= right) return count;\n        int root = preOrder[pos++];\n        int middle = 0;\n        while (inOrder[middle] != root) {\n            middle++;\n        }\n        count = restore(pos, count, left, middle);\n        count = restore(pos, count, middle + 1, right);\n        postOrder[count] = root;\n        return count + 1;\n    }\n}\n\nclass FastReader {\n    private InputStream in = System.in;\n    private byte[] buf = new byte[1024];\n    private int charNum;\n    private int charLen;\n    private StringBuilder sb = new StringBuilder();\n\n    public int read() {\n        if (charLen == -1)\n            throw new InputMismatchException();\n        if (charNum >= charLen) {\n            charNum = 0;\n            try {\n                charLen = in.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (charLen <= 0)\n                return -1;\n        }\n        return buf[charNum++];\n    }\n\n    public String next() {\n        int c = read();\n        while (isWhitespace(c)) {\n            c = read();\n        }\n        sb.setLength(0);\n        do {\n            sb.appendCodePoint(c);\n            c = read();\n        } while (!isWhitespace(c));\n        return sb.toString();\n    }\n\n    public char[] nextCharArray() {\n        return next().toCharArray();\n    }\n\n    public int nextInt() {\n        return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n        int[] array = new int[n];\n        for (int i = 0; i < n; i++)\n            array[i] = nextInt();\n        return array;\n    }\n\n    public List<Integer> nextIntList(int n) {\n        Integer[] array = new Integer[n];\n        for (int i = 0; i < n; i++)\n            array[i] = nextInt();\n        return Arrays.asList(array);\n    }\n\n    public int[][] nextIntArray2D(int n, int m) {\n        int[][] array = new int[n][m];\n        for (int i = 0; i < n; i++)\n            array[i] = nextIntArray(m);\n        return array;\n    }\n\n    public List<int[]> nextIntsList(int n, int m) {\n        List<int[]> list = new ArrayList<int[]>(n);\n        for (int i = 0; i < n; i++)\n            list.add(nextIntArray(m));\n        return list;\n    }\n\n    public long nextLong() {\n        int c = read();\n        while (isWhitespace(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isWhitespace(c));\n        return res * sgn;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public double[] nextDoubleArray(int n) {\n        double[] array = new double[n];\n        for (int i = 0; i < n; i++)\n            array[i] = nextDouble();\n        return array;\n    }\n\n    public boolean isWhitespace(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "// optional\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Runtime.Serialization.Formatters.Binary;\n\npublic static class Program {\n    class Node {\n        public int Parent { get; set; }\n        public int Left { get; set; }\n        public int Right { get; set; }\n    }\n\n    static Node[] nodes;\n    static List<int> preorder = new List<int>();\n    static List<int> inorder = new List<int>();\n    static List<int> postorder = new List<int>();\n\n    public static void Main() {\n        #region SetAutoFlushIsFalse\n#if !DEBUG\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        Console.SetOut(sw);\n#endif\n        #endregion\n\n        var n = ReadLib.ReadAsInt();\n        nodes = new Node[n];\n\n        for (int i = 0; i < n; i++) {\n            nodes[i] = new Node() { Left = -1, Parent = -1, Right = -1 };\n        }\n\n        preorder = ReadLib.ReadAsIntArray().ToList();\n        inorder = ReadLib.ReadAsIntArray().ToList();\n\n        var root = SetNode(0, 0, n);\n        SetPost(root);\n\n        Console.WriteLine(string.Join(\" \", postorder));\n\n        #region Flush\n#if !DEBUG\n        Console.Out.Flush();\n        sw.Close();\n#endif\n        #endregion\n    }\n\n    static int SetNode(int pl, int il, int len) {\n        if (len == 1) {\n            return preorder[pl];\n        }\n\n        var rootId = preorder[pl];\n        var inRootIdx = inorder.FindIndex(i => i == rootId);\n\n        var leftLen = inRootIdx - il;\n        if (leftLen > 0) {\n            var leftId = SetNode(pl + 1, il, leftLen);\n            nodes[rootId - 1].Left = leftId;\n            nodes[leftId - 1].Parent = rootId;\n        }\n\n        var rightLen = len - leftLen - 1;\n        if (rightLen > 0) {\n            var rightId = SetNode(pl + leftLen + 1, inRootIdx + 1, rightLen);\n            nodes[rootId - 1].Right = rightId;\n            nodes[rightId - 1].Parent = rootId;\n        }\n        \n        return rootId;\n    }\n\n    static void SetPost(int id) {\n        if (nodes[id - 1].Left != -1) {\n            SetPost(nodes[id - 1].Left);\n        }\n\n        if (nodes[id - 1].Right != -1) {\n            SetPost(nodes[id - 1].Right);\n        }\n\n        postorder.Add(id);\n    }\n}\n\nstatic class ReadLib {\n    public static long ReadAsLong() {\n        return long.Parse(Console.ReadLine());\n    }\n\n    public static int ReadAsInt() {\n        return int.Parse(Console.ReadLine());\n    }\n\n    public static int[] ReadAsIntArray(int step = 0) {\n        return Console.ReadLine().Split(' ').Select(s => int.Parse(s) + step).ToArray();\n    }\n\n    public static long[] ReadAsLongArray(int step = 0) {\n        return Console.ReadLine().Split(' ').Select(s => long.Parse(s) + step).ToArray();\n    }\n\n    public static ulong[] ReadAsULongArray() {\n        return Console.ReadLine().Split(' ').Select(s => ulong.Parse(s)).ToArray();\n    }\n\n    public static string[] ReadAsStringArray() {\n        return Console.ReadLine().Split(' ');\n    }\n\n    public static int[] ReadNTimesAsInt(int n, int step = 0) {\n        return Enumerable.Range(1, n).Select(s => int.Parse(Console.ReadLine()) + step).ToArray();\n    }\n\n    public static char[][] ReadNTimesAsCharArray(int n) {\n        return Enumerable.Range(1, n).Select(i => Console.ReadLine().ToArray()).ToArray();\n    }\n\n    public static long[] ReadNTimesAsLong(int n, int step = 0) {\n        return Enumerable.Range(1, n).Select(s => long.Parse(Console.ReadLine()) + step).ToArray();\n    }\n\n    public static int[][] ReadNTimesAsIntArray(int n, int step = 0) {\n        return Enumerable.Range(1, n).Select(s => ReadAsIntArray(step)).ToArray();\n    }\n\n    public static string[] ReadNTimesAsString(int n) {\n        return Enumerable.Range(1, n).Select(s => Console.ReadLine()).ToArray();\n    }\n\n    public static char[,] ReadMapAsChar(int hSize, int wSize) {\n        var map = new char[hSize, wSize];\n        for (int h = 0; h < hSize; h++) {\n            var a = Console.ReadLine();\n            for (int w = 0; w < wSize; w++) {\n                map[h, w] = a[w];\n            }\n        }\n        return map;\n    }\n}\n\nnamespace Heaps {\n    /// <summary>優先度付きキュー</summary>\n    public class PriorityQueue<T> : IEnumerable<T>, IReadOnlyCollection<T> where T : IComparable<T> {\n        public List<T> HeapArray { get; }\n        public T NIL { get; }\n        public bool IsMax { get; }\n\n        public int Count => HeapArray.Count;\n\n        /// <param name=\"heapArray\">ヒープ</param>\n        /// <param name=\"NIL\">NILの値</param>\n        /// <param name=\"IsMax\">True時：大きい方から取り出す、False時：小さい方から取り出す</param>\n        public PriorityQueue(T NIL, IEnumerable<T> heapArray = null, bool IsMax = true) {\n            this.HeapArray = heapArray == null ? new List<T>() : heapArray.ToList();\n            this.NIL = NIL;\n            this.IsMax = IsMax;\n            Update();\n        }\n\n        /// <summary>KeyのValueを取得</summary>\n        public T this[int id] {\n            get {\n                if (id <= 0 || id > HeapArray.Count) {\n                    return NIL;\n                }\n\n                return HeapArray[id - 1];\n            }\n        }\n\n        class Node {\n            public int Key { get; }\n            public T Value => outer[Key];\n            readonly PriorityQueue<T> outer;\n\n            public Node(int key, PriorityQueue<T> outer) {\n                Key = key;\n                this.outer = outer;\n            }\n\n            public Node Left {\n                get {\n                    var leftKey = 2 * Key;\n                    return new Node(leftKey, outer);\n                }\n            }\n\n            public Node Right {\n                get {\n                    var rightkey = 2 * Key + 1;\n                    return new Node(rightkey, outer);\n                }\n            }\n\n            public Node Parent {\n                get {\n                    var parentKey = Key / 2;\n                    return new Node(parentKey, outer);\n                }\n            }\n        }\n\n        private Node GetNode(int key) {\n            return new Node(key, this);\n        }\n\n        /// <summary>max Heap木とする O(N)</summary>\n        public void Update() {\n            var n = HeapArray.Count() / 2;\n            /// <summary>葉から順に処理を行う</summary>\n            for (int i = n; i >= 1; i--) {\n                Heapify(i);\n            }\n        }\n\n        /// <summary>idを根とする部分木について、Heap木を維持したまま、idを下降させる</summary>\n        private void Heapify(int key) {\n            var current = GetNode(key);\n\n            var left = current.Left;\n            var right = current.Right;\n\n            var largest = current;\n            var sign = IsMax ? 1 : -1;\n            if (left.Value.CompareTo(NIL) != 0 && left.Value.CompareTo(current.Value) * sign > 0) {\n                largest = left;\n            }\n\n            if (right.Value.CompareTo(NIL) != 0 && right.Value.CompareTo(largest.Value) * sign > 0) {\n                largest = right;\n            }\n\n            if (largest.Key != key) {\n                HeapArray.Swap(key - 1, largest.Key - 1);   // 元と異なるときはSwapする\n                Heapify(largest.Key); // largest.Key は元のkeyの場所。葉で更にMaxHeaptyを行う。\n            }\n        }\n\n        /// <summary>keyの値を挿入する</summary>\n        public void Enqueue(T value) {\n            HeapArray.Add(value);\n\n            var inserted = GetNode(HeapArray.Count);    // 末尾に挿入\n            var parent = inserted.Parent;\n            var sign = IsMax ? 1 : -1;\n\n            // 挿入Nodeが根になる or 親 > 子になるまで親とNodeを交換\n            while (inserted.Key > 1 && value.CompareTo(parent.Value) * sign > 0) {\n                HeapArray.Swap(inserted.Key - 1, parent.Key - 1);\n                inserted = parent;\n                parent = inserted.Parent;\n            }\n        }\n\n        public T Dequeue() {\n            if (HeapArray.Count == 0) {\n                return NIL;\n            }\n\n            var popVal = HeapArray.First();\n            var newRootVal = HeapArray.Last();  // 新しい根となる。\n\n            HeapArray.RemoveAt(HeapArray.Count - 1);    // del last\n\n            if (HeapArray.Count > 0) {\n                HeapArray[0] = newRootVal;\n                Heapify(1);\n            }\n\n            return popVal;\n        }\n\n        public T Peek() {\n            return HeapArray.First();\n        }\n\n        public IEnumerator<T> GetEnumerator() {\n            while (HeapArray.Count > 0) {\n                yield return Dequeue();\n            }\n        }\n\n        IEnumerator IEnumerable.GetEnumerator() {\n            return GetEnumerator();\n        }\n\n        public void Clear() {\n            HeapArray.Clear();\n        }\n\n        public bool Contains(T val) {\n            return HeapArray.Contains(val);\n        }\n\n        public PriorityQueue<T> Clone() {\n            return new PriorityQueue<T>(NIL, HeapArray.DeepCopy());\n        }\n    }\n}\n\n/// <summary>拡張メソッドs</summary>\nstatic class MyExtention {\n    /// <summary>iとjを入れ替える</summary>\n    public static void Swap<T>(this T[] arr, int i, int j) {\n        var buf = arr[i];\n        arr[i] = arr[j];\n        arr[j] = buf;\n    }\n\n    public static void Swap<T>(this List<T> list, int i, int j) {\n        var buf = list[i];\n        list[i] = list[j];\n        list[j] = buf;\n    }\n\n    /// <summary>\n    /// partition。末尾sArr[r]を基準として、左に基準より小さい数、右に基準より大きい数が存在するように配列を並び替える。\n    /// </summary>\n    /// <param name=\"sArr\"></param>\n    /// <param name=\"p\">partitionの先頭の添字</param>\n    /// <param name=\"r\">partitionの末尾の添字</param>\n    /// <returns>partitionの基準が存在する添字</returns>\n    public static int Partition(this int[] sArr, int p, int r) {\n        var x = sArr[r];\n        var i = p - 1;\n        for (int j = p; j < r; j++) {\n            if (sArr[j] <= x) {\n                i++;\n                sArr.Swap(i, j);\n            }\n        }\n        sArr.Swap(i + 1, r);\n        return i + 1;\n    }\n\n    /// <summary>深いコピーをする</summary>\n    public static T DeepCopy<T>(this T obj) {\n        T result;\n        var b = new BinaryFormatter();\n        using (var mem = new MemoryStream()) {\n            b.Serialize(mem, obj); //  binaryFormatterによりobjをmemにserial化して書き出す\n            mem.Position = 0; // memのpotisionを先頭に戻す\n            result = (T)b.Deserialize(mem); // memの内容を読み取る。\n        }\n        return result;\n    }\n\n    public static string Left(this string str, int length) {\n        return str.Substring(0, length);\n    }\n\n    public static string Right(this string str, int length) {\n        return str.Substring(str.Length - length, length);\n    }\n\n    public static int Find<T>(this T[] array, T obj) {\n        return Array.IndexOf(array, obj);\n    }\n\n    public static int LastFind<T>(this T[] array, T obj) {\n        return Array.LastIndexOf(array, obj);\n    }\n\n    /// <summary>同一の値で埋める</summary>\n    public static void Initialize<T>(this T[,] array, T value) {\n        for (int i = 0; i < array.GetLength(0); i++) {\n            for (int j = 0; j < array.GetLength(1); j++) {\n                array[i, j] = value;\n            }\n        }\n    }\n}\n\nstatic class MyMath {\n    /// <summary>階乗</summary>\n    public static long Factorial(int n) {\n        if (n == 0) {\n            return 1;\n        }\n\n        return Permutation(n, 0);\n    }\n\n    public static long Permutation(int n, int k) {\n        return Enumerable.Range(0, n - k).Select(i => n - i).Aggregate(1, (b, i) => b * i);\n    }\n\n    #region FullPower\n    /// <summary>総乗、π</summary>\n    public static long FullPower(IEnumerable<long> vs) {\n        return vs.Aggregate(1L, (a, b) => a * b);\n    }\n\n    public static long FullPower(IEnumerable<int> vs) {\n        return vs.Aggregate(1L, (a, b) => a * b);\n    }\n    #endregion\n\n    /// <summary>最大公約数</summary>\n    public static long Gcd(long item1, long item2) {\n        var a = Math.Max(item1, item2);\n        var b = Math.Min(item1, item2);\n\n        while (true) {\n            long mod;\n            Math.DivRem(a, b, out mod);\n            if (mod == 0) {\n                break;\n            }\n\n            a = b;\n            b = mod;\n        }\n        return b;\n    }\n\n    /// <summary>約分。最大公約数で割ったものを返す。</summary>\n    public static Tuple<long, long> DeviedByGcd(long item1, long item2) {\n        var gcd = Gcd(item1, item2);\n        return new Tuple<long, long>(item1 / gcd, item2 / gcd);\n    }\n\n    public static long Lcm(int item1, int item2) {\n        return Math.BigMul(item1, item2) / Gcd(item1, item2);\n    }\n\n    public static ModCombination ModCombination(int maxN, int mod = 1000000007) {\n        return new ModCombination(maxN, mod);\n    }\n\n    /// <summary>a^n mod</summary>\n    public static int ModPow(long a, long n, int mod = 1000000007) {\n        long res = 1;\n        long pow = a;\n\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                res = (pow * res) % mod;    // resにaをかける\n            }\n\n            pow = (pow * pow) % mod;    // 次のaはa^2\n            n >>= 1;\n        }\n\n        return (int)res;\n    }\n\n    /// <summary>約数を列挙</summary>\n    public static long[] Divisors(long n) {\n        var ret = new List<long>();\n        var sqrt = Math.Ceiling(Math.Sqrt(n));\n        for (long i = 1; i <= sqrt; i++) {\n            if (i * i > n) {\n                continue;\n            }\n\n            if (n % i != 0) {\n                continue;\n            }\n\n            ret.Add(i);\n\n            if (n / i == i) {\n                continue;\n            }\n\n            ret.Add(n / i);\n        }\n\n        return ret.ToArray();\n    }\n}\n\nstatic class MyMethod {\n    /// <summary>数え上げて、key, 出現回数に変換</summary>\n    public static Dictionary<T, int> CountUp<T>(IEnumerable<T> str) {\n        return\n            str\n            .GroupBy(c => c)\n            .Select(g => new KeyValuePair<T, int>(g.Key, g.Count()))\n            .ToDictionary(e => e.Key, e => e.Value);\n    }\n\n    /// <summary>ある要素を持つindexをすべて返す</summary>\n    public static int[] InducesOfValue<T>(this T[] arr, T searchValue) {\n        return arr\n            .Select((v, i) => new { v, i })\n            .Where(o => searchValue.Equals(o.v))\n            .Select(o => o.i)\n            .ToArray();\n    }\n\n    /// <summary>ある要素を持つindexをすべて返す</summary>\n    public static int[] Induces<T>(this IEnumerable<T> arr, T searchValue) {\n        return arr.ToArray().InducesOfValue(searchValue);\n    }\n}\n\n/// <summary>組み合わせ</summary>\nclass ModCombination {\n    private int mod;\n    private int[] fac;\n    private int[] finv;\n    private int[] inv;\n\n    public ModCombination(int max, int mod = 1000000007) {\n        this.mod = mod;\n        fac = new int[max]; // modが法のn!の列\n\n        inv = new int[max]; // indexの逆元の列\n        finv = new int[max]; // modを法とした、invの累積の累積\n\n        fac[0] = 1; fac[1] = 1;\n        finv[0] = 1; finv[1] = 1;\n        inv[1] = 1;\n\n        for (int i = 2; i < max; i++) {\n            fac[i] = (int)(Math.BigMul(fac[i - 1], i) % mod);  // factorを求める\n            var s = Math.BigMul(inv[mod % i], mod / i) % mod;\n            inv[i] = (int)(mod - s);　 // iに対する逆元を求める\n            finv[i] = (int)(Math.BigMul(finv[i - 1], inv[i]) % mod);\n        }\n    }\n    /// <summary>nCk</summary>\n    public int Calculation(int n, int k) {\n        if (n < k) return 0;\n        if (n < 0 || k < 0) return 0;\n\n        return (int)(Math.BigMul(fac[n], (int)(Math.BigMul(finv[k], finv[n - k]) % mod)) % mod);\n    }\n}\n\n/// <summary>あまりを計算するためのintのラッパー</summary>\nstruct ModInt {\n    int Value { get; }\n    int Mod { get; }\n\n    public override string ToString() {\n        return Value.ToString();\n    }\n\n    public static explicit operator ModInt(long value) {\n        return new ModInt(value);\n    }\n\n    public ModInt(long value, int mod = 1000000007) {\n        this.Value = (int)(value % mod);\n        this.Mod = mod;\n    }\n\n    public static explicit operator int(ModInt modInt) {\n        return modInt.Value;\n    }\n\n    private static void CheckNotEqualMod(ModInt item1, ModInt item2) {\n        if (item1.Mod != item2.Mod) {\n            throw new Exception(\"mod not equal\");\n        }\n    }\n\n    public static ModInt operator +(ModInt item1, ModInt item2) {\n        CheckNotEqualMod(item1, item2);\n        long value = item1.Value + item2.Value;\n        return new ModInt(value, item1.Mod);\n    }\n\n    public static ModInt operator *(ModInt item1, ModInt item2) {\n        CheckNotEqualMod(item1, item2);\n        long value = Math.BigMul(item1.Value, item2.Value);\n        return new ModInt(value, item1.Mod);\n    }\n\n    public static ModInt operator -(ModInt item1, ModInt item2) {\n        CheckNotEqualMod(item1, item2);\n        long value = item1.Value - item2.Value;\n        if (value < 0) {\n            value += item1.Mod;\n        }\n        return new ModInt(value, item1.Mod);\n    }\n\n    public static ModInt operator +(ModInt item1, int item2) {\n        return item1 + new ModInt(item2, item1.Mod);\n    }\n\n    public static ModInt operator *(ModInt item1, int item2) {\n        return item1 * new ModInt(item2, item1.Mod);\n    }\n\n    public static ModInt operator -(ModInt item1, int item2) {\n        return item1 - new ModInt(item2, item1.Mod);\n    }\n\n\n    public override int GetHashCode() {\n        return this.Value;\n    }\n\n    public override bool Equals(object obj) {\n        if (obj == null || this.GetType() != obj.GetType()) {\n            return false;\n        }\n\n        var modIntObj = (ModInt)obj;\n        return modIntObj.Value == this.Value;\n    }\n\n    public static bool operator ==(ModInt item1, ModInt item2) {\n        return item1.Value == item2.Value;\n    }\n\n    public static bool operator !=(ModInt item1, ModInt item2) {\n        return !(item1 == item2);\n    }\n\n    public static bool operator ==(ModInt item1, int item2) {\n        return item1.Value == item2;\n    }\n\n    public static bool operator !=(ModInt item1, int item2) {\n        return !(item1.Value == item2);\n    }\n\n    public static bool operator >=(ModInt item1, ModInt item2) {\n        return item1.Value >= item2.Value;\n    }\n\n    public static bool operator <=(ModInt item1, ModInt item2) {\n        return item1.Value <= item2.Value;\n    }\n\n    public static bool operator >=(ModInt item1, int item2) {\n        return item1.Value >= item2;\n    }\n\n    public static bool operator <=(ModInt item1, int item2) {\n        return item1.Value <= item2;\n    }\n\n    public static bool operator >(ModInt item1, ModInt item2) {\n        return item1.Value > item2.Value;\n    }\n\n    public static bool operator <(ModInt item1, ModInt item2) {\n        return item1.Value < item2.Value;\n    }\n\n    public static bool operator >(ModInt item1, int item2) {\n        return item1.Value >= item2;\n    }\n\n    public static bool operator <(ModInt item1, int item2) {\n        return item1.Value <= item2;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass Program\n{\n\n    public void Proc()\n    {\n        int nodeCount = int.Parse(Console.ReadLine());\n        this.PreOrderText = Console.ReadLine();\n        this.InOrderText = Console.ReadLine();\n        // testcode\n        //this.PreOrderText = \"1 2 3 4\";\n        //this.InOrderText = \"1 2 3 4\";\n        string[] prestr = this.PreOrderText.Split(' ');\n        string[] instr = this.InOrderText.Split(' ');\n\n        this.PreOrder = new int[nodeCount];\n       \n        for(int i=0; i<nodeCount; i++) {\n             this.PreOrder[i] = int.Parse(prestr[i]);\n             this.InOrder.Add(int.Parse(instr[i]));\n        }\n\n        TreeNd root = new TreeNd(this.PreOrder[0]);\n        TreeNd ansData = this.SetTree(1, root);\n        string ansText = GetPostorderText(ansData);\n        Console.WriteLine(ansText);\n    }\n\n    public string GetPostorderText(TreeNd dat)\n    {\n        if (dat == null)\n        {\n            return string.Empty;\n        }\n        StringBuilder sb = new StringBuilder();\n        if (dat.LeftChild != null)\n        {\n            string tmp = this.GetPostorderText(dat.LeftChild);\n            if (!string.IsNullOrEmpty(tmp))\n            {\n                sb.Append(tmp);\n            }\n        }\n        if (dat.RightChild != null)\n        {\n            string tmp = this.GetPostorderText(dat.RightChild);\n            if (!string.IsNullOrEmpty(tmp))\n            {\n                if (sb.Length > 0)\n                {\n                    sb.Append(\" \");\n                }\n                sb.Append(tmp);\n            }\n        }\n        if (sb.Length > 0)\n        {\n            sb.Append(\" \");\n        }\n        sb.Append(dat.NodeId);\n        return sb.ToString();\n    }\n\n    private int[] PreOrder;\n    private List<int> InOrder = new List<int>();\n\n    private String PreOrderText = string.Empty;\n    private string InOrderText = string.Empty;\n\n    private string GetInorderText(TreeNd dat)\n    {\n        StringBuilder sb = new StringBuilder();\n        string left = string.Empty;\n        if (dat.LeftChild != null)\n        {\n            left = this.GetInorderText(dat.LeftChild);\n        }\n        if (!string.IsNullOrEmpty(left))\n        {\n            sb.Append(left);\n        }\n        if (sb.Length > 0)\n        {\n            sb.Append(\" \");\n        }\n        sb.Append(dat.NodeId);\n        string right = string.Empty;\n        if (dat.RightChild != null)\n        {\n            right = this.GetInorderText(dat.RightChild);\n        }\n        if (!string.IsNullOrEmpty(right))\n        {\n            sb.Append(\" \");\n            sb.Append(right);\n        }\n        return sb.ToString();\n    }\n    private TreeNd SetTree(int idx, TreeNd root){\n        if (idx >= PreOrder.Length)\n        {\n            // ???????????????\n            string tmpAns = this.GetInorderText(root);\n            if (tmpAns.Equals(this.InOrderText))\n            {\n                return root;\n            }\n            else\n            {\n                return null;\n            }\n            \n        }\n        TreeNd ans = null;\n        TreeNd cop = (TreeNd)root.Clone();\n        TreeNd parent = cop.SearchById(this.PreOrder[idx - 1]);\n\n        while (parent != null)\n        {\n            TreeNd tmp = new TreeNd(this.PreOrder[idx]);\n\n            if (parent.LeftChild == null)\n            {\n                // ???????????´???(??????????????´??????\n                int idx1 = this.InOrder.IndexOf(this.PreOrder[idx - 1]);\n                int idx2 = this.InOrder.IndexOf(this.PreOrder[idx]);\n                if (idx2 < idx1)\n                {\n                    tmp.Parent = parent;\n                    parent.LeftChild = tmp;\n\n                    ans = SetTree(idx + 1, cop);\n                    if (ans != null)\n                    {\n                        return ans;\n                    }\n                    parent.LeftChild = null;\n                }\n            }\n            if (parent.RightChild == null)\n            {\n                // ???????????´???(??????????????´??????\n                int idx1 = this.InOrder.IndexOf(this.PreOrder[idx - 1]);\n                int idx2 = this.InOrder.IndexOf(this.PreOrder[idx]);\n                if (idx1 < idx2)\n                {\n                    tmp.Parent = parent;\n                    parent.RightChild = tmp;\n\n                    ans = SetTree(idx + 1, cop);\n                    if (ans != null)\n                    {\n                        return ans;\n                    }\n                    parent.RightChild = null;\n                }\n            }\n            parent = parent.Parent;\n        }\n\n        return ans;\n    }\n\n    public class TreeNd:ICloneable\n    {\n        public TreeNd Parent;\n        public int NodeId;\n        public TreeNd LeftChild;\n        public TreeNd RightChild;\n\n\n        public TreeNd(int nodeid)\n        {\n            this.NodeId = nodeid;\n        }\n\n        public TreeNd SearchById(int id)\n        {\n            TreeNd ret = null;\n            if (id == this.NodeId)\n            {\n                ret = this;\n            }\n            else if(this.LeftChild != null)\n            {\n                ret = this.LeftChild.SearchById(id);\n            }\n            if (ret == null && this.RightChild != null)\n            {\n                ret = this.RightChild.SearchById(id);\n            }\n            return ret;\n        }\n\n        public object Clone()\n        {\n            TreeNd tn = new TreeNd(this.NodeId);\n            if (this.LeftChild != null)\n            {\n                tn.LeftChild = (TreeNd)this.LeftChild.Clone();\n                tn.LeftChild.Parent = tn;\n            }\n            if (this.RightChild != null)\n            {\n                tn.RightChild = (TreeNd)this.RightChild.Clone();\n                tn.RightChild.Parent = tn;\n            }\n\n            return tn;\n        }\n    }\n\n\n    static void Main(string[] args)\n    {\n        Program prg = new Program();\n        prg.Proc();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass Program\n{\n    static void Main()\n    {\n        int n = int.Parse(Console.ReadLine());\n        List<int> preorder = Console.ReadLine().Split(' ')\n                                    .Select(val => int.Parse(val))\n                                    .ToList();\n        int[] inorder = Console.ReadLine().Split(' ')\n                                    .Select(val => int.Parse(val))\n                                    .ToArray();\n        BinaryTree btree = new BinaryTree(n);\n        btree.Rebuild(ref preorder, inorder);\n        btree.PostorderDisplay();\n    }\n}\n\nclass BinaryTree\n{\n    internal class Node\n    {\n        internal int Value {get; set;}\n        internal Node parent, left, right;\n\n        internal Node() : this(0) {}\n        internal Node(int val) : this(val, null, \"\") {}\n        internal Node(int val, Node parent, string direction)\n        {\n            this.Value = val;\n            this.parent = parent;\n            switch (direction)\n            {\n                case \"right\": this.parent.right = this; break;\n                case \"left\": this.parent.left = this; break;\n            }\n        }\n\n        public override string ToString()\n        {\n            return this.Value.ToString();\n        }\n    }\n\n\n    private Node[] nodes;\n    private Node this[int i]\n    {\n        get\n        {\n            return nodes[i];\n        }\n        set\n        {\n            this[i] = value;\n        }\n    }\n    private Node root;\n\n    public BinaryTree(int n)\n    {\n        nodes = new Node[n + 1];\n        nodes[0] = new Node();\n    }\n\n    public Node Rebuild(ref List<int> preorder, int[] inorder)\n    {\n        if(preorder.Count <= 0 || inorder.Length <= 0) return null;\n        int center = preorder[0];\n        preorder.RemoveAt(0);\n        nodes[center] = new Node(center);\n        if(this.root == null) this.root = nodes[center];\n        int splitPoint = Array.IndexOf(inorder, center);\n        if(splitPoint == -1) return null;\n        if(splitPoint > 0)\n        {\n            int[] leftTree = new int[splitPoint];\n            Array.Copy(inorder, 0, leftTree, 0, splitPoint);\n            this[center].left = Rebuild(ref preorder, leftTree);\n        }\n        if(inorder.Length > splitPoint + 1)\n        {\n            int[] rightTree = new int[inorder.Length - splitPoint - 1];\n            Array.Copy(inorder, splitPoint + 1, rightTree, 0, inorder.Length - splitPoint - 1);\n            this[center].right = Rebuild(ref preorder, rightTree);\n        }\n        return this[center];\n    }\n\n    public void PostorderDisplay()\n    {\n        string str = \"\";\n        Console.WriteLine(PostorderString(ref str, this.root).Trim());\n    }\n    private string PostorderString(ref string result, Node node)\n    {\n        if(node.left != null) PostorderString(ref result, node.left);\n        if(node.right != null) PostorderString(ref result, node.right);\n        result += \" \" + node.ToString();\n        return result;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace COJ1_7\n{\n    struct Node\n    {\n        public int value;\n        public int left;\n        public int right;\n    }\n    class Program\n    {\n\n        static void Main(string[] args)\n        {\n            int cnt = int.Parse(Console.ReadLine());\n            Node[] nodes = new Node[cnt];\n            for (int i = 0; i < cnt; i++)\n            {\n                nodes[i].left = -1;\n                nodes[i].right = -1;\n            }\n            var preorder = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            var inorder = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n            GetTree(nodes, preorder, inorder, 0, cnt, 0);\n            StringBuilder builder = new StringBuilder();\n            PostOrder(builder, nodes, 0);\n            Console.WriteLine(builder.ToString());\n        }\n\n        public static void GetTree(Node[] nodes, int[] preorder, int[] inorder, int from, int to, int index)\n        {\n            int value = preorder[index];\n            nodes[index].value = value;\n            int sep = from;\n            for (int i = from; i < to; i++)\n            {\n                if (inorder[i] == value) sep = i;\n            }\n            if (sep != from)\n            {\n                nodes[index].left = index + 1;\n                GetTree(nodes, preorder, inorder, from, sep, index + 1);\n            }\n            if (sep < to-1)\n            {\n                int gap = sep - from;\n                nodes[index].right = index + 1 + gap;\n                GetTree(nodes, preorder, inorder, sep + 1, to, index + gap + 1);\n            }\n            return;\n        }\n        public static void PostOrder(StringBuilder builder, Node[] nodes, int index)\n        {\n            if (nodes[index].left != -1)\n                PostOrder(builder, nodes, nodes[index].left);\n            if (nodes[index].right != -1)\n                PostOrder(builder, nodes, nodes[index].right);\n            if (index == 0)\n                builder.Append(nodes[index].value).Append(\"\\n\");\n            else builder.Append(nodes[index].value).Append(\" \");\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace D\n{\n    public struct Node\n    {\n        public int left;\n        public int right;\n        public Tree tree;\n    }\n\n    public class Tree\n    {\n        internal Node[] nodes;\n\n        public Tree(int nodes)\n        {\n            this.nodes = new Node[nodes + 1];\n            for (int i = 1; i < nodes + 1; i++)\n            {\n                this.nodes[i].left = -1;\n                this.nodes[i].right = -1;\n                this.nodes[i].tree = this;\n            }\n        }\n\n        public void AddChilden(int id, int left, int right)\n        {\n            nodes[id].left = left;\n            nodes[id].right = right;\n        }\n\n        public void Postorder(int node,ref List<int> list)\n        {\n            if (nodes[node].left != -1) Postorder(nodes[node].left,ref list);\n            if (nodes[node].right != -1) Postorder(nodes[node].right,ref list);\n            list.Add(node);\n        }\n\n        public int Analyze(IEnumerable<int> preList, IEnumerable<int> inList)\n        {\n            if (preList.Count() == 0) return -1;\n            var node = preList.First();\n            var index = inList.ToList().IndexOf(node);\n            var left = Analyze(preList.Skip(1).Take(index), inList.Take(index));\n            var right = Analyze(preList.Skip(1 + index), inList.Skip(1 + index));\n            AddChilden(node, left, right);\n            return node;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var n = int.Parse(Console.ReadLine());\n            var preList = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            var inList = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            var tree = new Tree(n);\n            var list = new List<int>();\n            tree.Postorder(tree.Analyze(preList, inList),ref list);\n            Console.WriteLine(string.Join(\" \",Array.ConvertAll(list.ToArray(),(s)=>s.ToString())));\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ALDS1_7_D {\n    class Problem {\n        private int _pos;\n        private List<int> _pre, _in, _post;\n\n        public void Run() {\n            Read();\n            Rec(0, _pre.Count);\n\n            StringBuilder sb = new StringBuilder();\n            foreach (int n in _post)\n                sb.Append(\" \" + n);\n            Console.WriteLine(sb.ToString().TrimStart());\n        }\n\n        private void Read() {\n            Console.ReadLine();\n            _pre = Console.ReadLine().Split(' ').Select(int.Parse).ToList();\n            _in = Console.ReadLine().Split(' ').Select(int.Parse).ToList();\n            _post = new List<int>();\n        }\n\n        private void Rec(int left, int right) {\n            if (left >= right)\n                return;\n            int cur = _pre[_pos++];\n            int mid = _in.IndexOf(cur);\n            Rec(left, mid);\n            Rec(mid + 1, right);\n            _post.Add(cur);\n        }\n    }\n\n    class Program {\n        static void Main(string[] args) {\n            Problem p = new Problem();\n            p.Run();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace COJ1_7\n{\n    struct Node\n    {\n        public int value;\n        public int left;\n        public int right;\n    }\n    class Program\n    {\n\n        static void Main(string[] args)\n        {\n            int cnt = int.Parse(Console.ReadLine());\n            Node[] nodes = new Node[cnt];\n            for (int i = 0; i < cnt; i++)\n            {\n                nodes[i].left = -1;\n                nodes[i].right = -1;\n            }\n            var preorder = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            var inorder = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n            GetTree(nodes, preorder, inorder, 0, cnt, 0);\n            StringBuilder builder = new StringBuilder();\n            PostOrder(builder, nodes, 0);\n            Console.WriteLine(builder.ToString());\n        }\n\n        public static void GetTree(Node[] nodes, int[] preorder, int[] inorder, int from, int to, int index)\n        {\n            int value = preorder[index];\n            nodes[index].value = value;\n            int sep = from;\n            for (int i = from; i < to; i++)\n            {\n                if (inorder[i] == value) sep = i;\n            }\n            if (sep != from)\n            {\n                nodes[index].left = index + 1;\n                GetTree(nodes, preorder, inorder, from, sep, index + 1);\n            }\n            if (sep < to-1)\n            {\n                int gap = sep - from;\n                nodes[index].right = index + 1 + gap;\n                GetTree(nodes, preorder, inorder, sep + 1, to, index + gap + 1);\n            }\n            return;\n        }\n        public static void PostOrder(StringBuilder builder, Node[] nodes, int index)\n        {\n            if (nodes[index].left != -1)\n                PostOrder(builder, nodes, nodes[index].left);\n            if (nodes[index].right != -1)\n                PostOrder(builder, nodes, nodes[index].right);\n            if (index == 0)\n                builder.Append(nodes[index].value);\n            else builder.Append(nodes[index].value).Append(\" \");\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static int[] preorder;\n        static int[] inorder;\n\n        static List<int> postorder = new List<int>();\n        static int pos = 0;\n\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            preorder = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            inorder = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n            Reconstruct(0, n);\n\n            Console.WriteLine(string.Join(\" \", postorder.ConvertAll(p => p.ToString())));\n        }\n\n        static void Reconstruct(int left, int right)\n        {\n            if (left >= right) return;\n\n            int root = preorder[pos++];\n            int m = Array.IndexOf(inorder, root);\n\n            Reconstruct(left, m);\n            Reconstruct(m + 1, right);\n\n            postorder.Add(root);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass Program\n{\n\n    public void Proc()\n    {\n        int nodeCount = int.Parse(Console.ReadLine());\n        this.PreOrderText = Console.ReadLine();\n        this.InOrderText = Console.ReadLine();\n        // testcode\n        this.PreOrderText = \"1 2 3 4\";\n        this.InOrderText = \"1 2 3 4\";\n        string[] prestr = this.PreOrderText.Split(' ');\n        string[] instr = this.InOrderText.Split(' ');\n\n        this.PreOrder = new int[nodeCount];\n       \n        for(int i=0; i<nodeCount; i++) {\n             this.PreOrder[i] = int.Parse(prestr[i]);\n             this.InOrder.Add(int.Parse(instr[i]));\n        }\n\n        TreeNd root = new TreeNd(this.PreOrder[0]);\n        TreeNd ansData = this.SetTree(1, root);\n        string ansText = GetPostorderText(ansData);\n        Console.WriteLine(ansText);\n    }\n\n    public string GetPostorderText(TreeNd dat)\n    {\n        if (dat == null)\n        {\n            return string.Empty;\n        }\n        StringBuilder sb = new StringBuilder();\n        if (dat.LeftChild != null)\n        {\n            string tmp = this.GetPostorderText(dat.LeftChild);\n            if (!string.IsNullOrEmpty(tmp))\n            {\n                sb.Append(tmp);\n            }\n        }\n        if (dat.RightChild != null)\n        {\n            string tmp = this.GetPostorderText(dat.RightChild);\n            if (!string.IsNullOrEmpty(tmp))\n            {\n                if (sb.Length > 0)\n                {\n                    sb.Append(\" \");\n                }\n                sb.Append(tmp);\n            }\n        }\n        if (sb.Length > 0)\n        {\n            sb.Append(\" \");\n        }\n        sb.Append(dat.NodeId);\n        return sb.ToString();\n    }\n\n    private int[] PreOrder;\n    private List<int> InOrder = new List<int>();\n\n    private String PreOrderText = string.Empty;\n    private string InOrderText = string.Empty;\n\n    private string GetInorderText(TreeNd dat)\n    {\n        StringBuilder sb = new StringBuilder();\n        string left = string.Empty;\n        if (dat.LeftChild != null)\n        {\n            left = this.GetInorderText(dat.LeftChild);\n        }\n        if (!string.IsNullOrEmpty(left))\n        {\n            sb.Append(left);\n        }\n        if (sb.Length > 0)\n        {\n            sb.Append(\" \");\n        }\n        sb.Append(dat.NodeId);\n        string right = string.Empty;\n        if (dat.RightChild != null)\n        {\n            right = this.GetInorderText(dat.RightChild);\n        }\n        if (!string.IsNullOrEmpty(right))\n        {\n            sb.Append(\" \");\n            sb.Append(right);\n        }\n        return sb.ToString();\n    }\n    private TreeNd SetTree(int idx, TreeNd root){\n        if (idx >= PreOrder.Length)\n        {\n            // ???????????????\n            string tmpAns = this.GetInorderText(root);\n            if (tmpAns.Equals(this.InOrderText))\n            {\n                return root;\n            }\n            else\n            {\n                return null;\n            }\n            \n        }\n        TreeNd ans = null;\n        TreeNd cop = (TreeNd)root.Clone();\n        TreeNd parent = cop.SearchById(this.PreOrder[idx - 1]);\n\n        while (parent != null)\n        {\n            TreeNd tmp = new TreeNd(this.PreOrder[idx]);\n\n            if (parent.LeftChild == null)\n            {\n                // ???????????´???(??????????????´??????\n                tmp.Parent = parent;\n                parent.LeftChild = tmp;\n\n                ans = SetTree(idx + 1, cop);\n                if (ans != null)\n                {\n                    return ans;\n                }\n                parent.LeftChild = null;\n            }\n            if (parent.RightChild == null)\n            {\n                // ???????????´???(??????????????´??????\n                tmp.Parent = parent;\n                parent.RightChild = tmp;\n\n                ans = SetTree(idx + 1, cop);\n                if (ans != null)\n                {\n                    return ans;\n                }\n                parent.RightChild = null;\n            }\n            parent = parent.Parent;\n        }\n\n        return ans;\n    }\n\n    public class TreeNd:ICloneable\n    {\n        public TreeNd Parent;\n        public int NodeId;\n        public TreeNd LeftChild;\n        public TreeNd RightChild;\n\n\n        public TreeNd(int nodeid)\n        {\n            this.NodeId = nodeid;\n        }\n\n        public TreeNd SearchById(int id)\n        {\n            TreeNd ret = null;\n            if (id == this.NodeId)\n            {\n                ret = this;\n            }\n            else if(this.LeftChild != null)\n            {\n                ret = this.LeftChild.SearchById(id);\n            }\n            if (ret == null && this.RightChild != null)\n            {\n                ret = this.RightChild.SearchById(id);\n            }\n            return ret;\n        }\n\n        public object Clone()\n        {\n            TreeNd tn = new TreeNd(this.NodeId);\n            if (this.LeftChild != null)\n            {\n                tn.LeftChild = (TreeNd)this.LeftChild.Clone();\n                tn.LeftChild.Parent = tn;\n            }\n            if (this.RightChild != null)\n            {\n                tn.RightChild = (TreeNd)this.RightChild.Clone();\n                tn.RightChild.Parent = tn;\n            }\n\n            return tn;\n        }\n    }\n\n\n    static void Main(string[] args)\n    {\n        Program prg = new Program();\n        prg.Proc();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass Program\n{\n\n    public void Proc()\n    {\n        int nodeCount = int.Parse(Console.ReadLine());\n        string[] inpt = Console.ReadLine().Split(' ');\n        List<int> preOrder = new List<int>();\n        List<int> inOrder = new List<int>();\n        for(int i=0; i<nodeCount; i++) {\n            preOrder.Add(int.Parse(inpt[i]));\n        }\n        inpt = Console.ReadLine().Split(' ');\n        for(int i=0; i<nodeCount; i++) {\n            inOrder.Add(int.Parse(inpt[i]));\n        }\n        Dictionary<int, TreeNd> dic = new Dictionary<int, TreeNd>();\n        List<TreeNd> list = new List<TreeNd>();\n        TreeNd root = new TreeNd(preOrder[0]);\n        dic.Add(root.NodeId, root);\n        list.Add(root);\n        for (int i = 1; i < nodeCount; i++)\n        {\n            int nodeId = preOrder[i];\n            int prevId = preOrder[i - 1];\n            TreeNd prevNd = dic[prevId];\n            TreeNd newNd = null;\n            if (dic.ContainsKey(nodeId))\n            {\n                newNd = dic[nodeId];\n            }\n            else\n            {\n                newNd = new TreeNd(nodeId);\n                dic.Add(nodeId, newNd);\n                list.Add(newNd);\n            }\n            while (prevNd != null)\n            {\n                if (prevNd.Parent != null && ( prevNd.Parent.SubLeft == null || prevNd.Parent.SubRight == null))\n                {\n                    // ????????¢????????????????????????\n                    int idx = inOrder.IndexOf(nodeId);\n                    int idxSib = inOrder.IndexOf(prevId);\n                    int idxPare = inOrder.IndexOf(prevNd.Parent.NodeId);\n                    if (idxSib < idxPare && idxPare < idx)\n                    {\n                        // ????????§??????\n                        prevNd.Parent.SubLeft = prevNd;\n                        prevNd.Parent.SubRight = newNd;\n                        newNd.Parent = prevNd.Parent;\n                    }\n                }\n                if (newNd.Parent == null)\n                {\n                    int idx = inOrder.IndexOf(nodeId);\n                    int idxPare = inOrder.IndexOf(prevNd.NodeId);\n                    if (prevNd.SubLeft == null && prevNd.SubRight == null)\n                    {\n                        // ?????´????????§??????????????§\n                        if (idx < idxPare)\n                        {\n                            // ?????????\n                            newNd.Parent = prevNd;\n                            prevNd.SubLeft = newNd;\n                        }\n                    }\n                    if (newNd.Parent == null && prevNd.SubRight == null)\n                    {\n                        // ???????????§??????????????§\n                        if (idxPare < idx)\n                        {\n                            newNd.Parent = prevNd;\n                            prevNd.SubRight = newNd;\n                        }\n\n                    }\n                }\n                if (newNd.Parent == null)\n                {\n                    prevNd = prevNd.Parent;\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n        this.Output(root);\n        Console.WriteLine(this.PostOrder.ToString().Substring(1));\n    }\n\n    private StringBuilder PostOrder = new StringBuilder();\n    private void Output(TreeNd parent)\n    {\n        if (parent.SubLeft != null)\n        {\n            this.Output(parent.SubLeft);\n        }\n        if (parent.SubRight != null)\n        {\n            this.Output(parent.SubRight);\n        }\n        PostOrder.Append(\" \" + parent.NodeId);\n    }\n\n    public class TreeNd\n    {\n        public int NodeId = -1;\n        public TreeNd Parent = null;\n\n        public TreeNd(int id)\n        {\n            this.NodeId = id;\n        }\n\n        public TreeNd SubLeft = null;\n        public TreeNd SubRight = null;\n\n    }\n\n    static void Main(string[] args)\n    {\n        Program prg = new Program();\n        prg.Proc();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ALDS1_7_D\n{\n    class Program\n    {\n        static int pos;\n        static int[] pre, ino;\n        static List<int> post = new List<int>();\n\n        static void rec(int l, int r)\n        {\n            if (l >= r) return;\n            int root = pre[pos++];\n            int m = ino.TakeWhile(s => s != root).Count();\n            rec(l, m);\n            rec(m + 1, r);\n            post.Add(root);\n        }\n        static void Main(string[] args)\n        {\n            int n = scan[0];\n            pre = scan;\n            ino = scan;\n\n            rec(0, n);\n\n            var sb = new StringBuilder();\n            foreach (var item in post)\n            {\n                sb.Append(item + \" \");\n            }\n            var ans = sb.ToString().Trim();\n            Console.WriteLine(ans);\n        }\n\n        static int[] scan\n        {\n            get { return Console.ReadLine().Split().Select(int.Parse).ToArray(); }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing static System.Math;\n\nnamespace CSharpSpiral {\n\tclass Program {\n\t\tstatic void Main(string[] args) {\n\t\t\tvar sw = new StreamWriter(Console.OpenStandardOutput()) {\n\t\t\t\tAutoFlush =\n#if DEBUG\n\t\t\ttrue\n#else\n\t\t\tfalse\n#endif\n\t\t\t};\n\t\t\tConsole.SetOut(sw);\n\t\t\tnew Program().Solve(new ConsoleInput(\n#if DEBUG\n\t\t\tnew StreamReader(\"../../../inputData.txt\")\n#else\n\t\t\tConsole.In\n#endif\n\t\t\t, ' '));\n\t\t\tConsole.Out.Flush();\n\t\t}\n\t\tpublic void Solve(ConsoleInput cin) {\n\t\t\tvar N = cin.ReadInt;\n\t\t\tvar Nodes = new BinaryNode<List<int>>[N];\n\t\t\tvar Reveal = new BinaryNode<int>[N];\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tNodes[i] = new BinaryNode<List<int>> { Id = i };\n\t\t\t\tReveal[i] = new BinaryNode<int> { Id = i };\n\t\t\t}\n\t\t\tvar PreOrder = cin.ReadIntArray(N).Select(x => x - 1).ToArray();\n\t\t\tvar InOrder = cin.ReadIntArray(N).Select(x => x - 1).ToArray();\n\t\t\tReconstruct(Reveal, PreOrder, InOrder, 0, 0, N);\n\t\t\tConsole.WriteLine(Reveal[PreOrder[0]].PostOrder().Select(x => x + 1).Join());\n\t\t}\n\n\t\tvoid Reconstruct(BinaryNode<int>[] Reveal, int[] PreOrder, int[] InOrder, int preStart, int inStart, int Length) {\n\t\t\tif(Length <= 1) return;\n\t\t\tvar root = PreOrder[preStart];\n\t\t\tvar partition = Array.FindIndex(InOrder, inStart, Length, s => s == root);\n\t\t\tvar leftLength = partition - inStart;\n\t\t\tvar rightLength = (Length - 1) - leftLength;\n\t\t\tvar leftChildId = leftLength == 0 ? -1 : PreOrder[preStart + 1];\n\t\t\tvar rightChildId = rightLength == 0 ? -1 : PreOrder[preStart + 1 + leftLength];\n\t\t\tReveal[root].Adopt(\n\t\t\t\tleftLength == 0 ? null : Reveal[leftChildId], rightLength == 0 ? null : Reveal[rightChildId]);\n\t\t\tReconstruct(Reveal, PreOrder, InOrder, preStart + 1, inStart, leftLength);\n\t\t\tReconstruct(Reveal, PreOrder, InOrder, preStart + 1 + leftLength, partition + 1, rightLength);\n\t\t}\n\n\t\tclass TreeNode<T> {\n\t\t\tpublic virtual TreeNode<T> Parent { get; set; }\n\t\t\tpublic T Value { get; set; }\n\t\t\tpublic int Id { get; set; }\n\t\t\tpublic int Order { get; set; }\n\t\t\tpublic virtual List<TreeNode<T>> Children { get; set; } = new List<TreeNode<T>>();\n\t\t\tpublic virtual bool isRoot { get { return Parent == null; } }\n\t\t\tpublic virtual bool isLeaf { get { return !Children.Any(); } }\n\t\t\tpublic bool isInternal { get { return !isRoot && !isLeaf; } }\n\t\t\tpublic virtual int Depth {\n\t\t\t\tget {\n\t\t\t\t\tvar count = 0;\n\t\t\t\t\tvar P = this;\n\t\t\t\t\twhile(!P.isRoot) {\n\t\t\t\t\t\tP = P.Parent;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\treturn count;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpublic int Height {\n\t\t\t\tget {\n\t\t\t\t\tif(isLeaf) return 0;\n\t\t\t\t\treturn Children.Select(X => X.Height).Max() + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpublic virtual int Degree { get { return Children.Count(); } }\n\n\t\t\tpublic void AdoptMany(List<TreeNode<T>> children) {\n\t\t\t\tChildren = children;\n\t\t\t\tforeach(var node in children)\n\t\t\t\t\tnode.Parent = this;\n\t\t\t}\n\t\t\tpublic void AdoptMany(TreeNode<T>[] Base, IEnumerable<int> call) {\n\t\t\t\tvar children = call.Select(k => Base[k]).ToList();\n\t\t\t\tAdoptMany(children);\n\t\t\t}\n\t\t\tpublic void Adopt(TreeNode<T> child) {\n\t\t\t\tChildren.Add(child);\n\t\t\t\tchild.Parent = this;\n\t\t\t}\n\t\t}\n\t\tclass BinaryNode<T>: TreeNode<T> {\n\t\t\tpublic new BinaryNode<T> Parent { get; set; }\n\t\t\tpublic BinaryNode<T> Left { get; set; }\n\t\t\tpublic BinaryNode<T> Right { get; set; }\n\t\t\tpublic new List<BinaryNode<T>> Children {\n\t\t\t\tget { return new BinaryNode<T>[] { Left, Right }.Where(x => x != null).ToList(); }\n\t\t\t}\n\t\t\tpublic override int Depth {\n\t\t\t\tget {\n\t\t\t\t\tvar count = 0;\n\t\t\t\t\tvar P = this;\n\t\t\t\t\twhile(!P.isRoot) {\n\t\t\t\t\t\tP = P.Parent;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\treturn count;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpublic new bool isRoot { get { return Parent == null; } }\n\t\t\tpublic override bool isLeaf { get { return Left == null && Right == null; } }\n\t\t\tpublic override int Degree {\n\t\t\t\tget { return (Left != null ? 1 : 0) + (Right != null ? 1 : 0); }\n\t\t\t}\n\t\t\tpublic void Adopt(BinaryNode<T> left, BinaryNode<T> right) {\n\t\t\t\tLeft = left; Right = right;\n\t\t\t\tif(left != null) left.Parent = this; if(right != null) right.Parent = this;\n\t\t\t}\n\t\t\tpublic BinaryNode<T> Sibling {\n\t\t\t\tget { return isRoot ? null : Equals(Parent.Left) ? Parent.Right : Parent.Left; }\n\t\t\t}\n\t\t\tpublic static void GetHeight(BinaryNode<T>[] Nodes, out int[] Res) {\n\t\t\t\tRes = new int[Nodes.Length];\n\t\t\t\tforeach(var root in Nodes.Where(n => n.isRoot)) {\n\t\t\t\t\tGetHeight(root, Res);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprivate static void GetHeight(BinaryNode<T> now, int[] Res) {\n\t\t\t\tif(now.isLeaf || !now.Children.Any()) { Res[now.Id] = 0; return; }\n\t\t\t\tforeach(var child in now.Children) {\n\t\t\t\t\tGetHeight(child, Res);\n\t\t\t\t}\n\t\t\t\tRes[now.Id] = now.Children.Max(c => Res[c.Id]) + 1;\n\t\t\t}\n\t\t\tprivate static void DFS(BinaryNode<T> now,\n\t\t\t\tAction<BinaryNode<T>> OnEnter,\n\t\t\t\tAction<BinaryNode<T>> OnMiddle,\n\t\t\t\tAction<BinaryNode<T>> OnLeave\n\t\t\t) {\n\t\t\t\tif(now == null) return;\n\t\t\t\tOnEnter?.Invoke(now);\n\t\t\t\tDFS(now.Left, OnEnter, OnMiddle, OnLeave);\n\t\t\t\tOnMiddle?.Invoke(now);\n\t\t\t\tDFS(now.Right, OnEnter, OnMiddle, OnLeave);\n\t\t\t\tOnLeave?.Invoke(now);\n\t\t\t}\n\t\t\tpublic void PreLabel() {\n\t\t\t\tvar count = 0;\n\t\t\t\tDFS(this, b => b.Order = count++, null, null);\n\t\t\t}\n\t\t\tpublic void InLabel() {\n\t\t\t\tvar count = 0;\n\t\t\t\tDFS(this, null, b => b.Order = count++, null);\n\t\t\t}\n\t\t\tpublic void PostLabel() {\n\t\t\t\tvar count = 0;\n\t\t\t\tDFS(this, null, null, b => b.Order = count++);\n\t\t\t}\n\t\t\tpublic List<int> PreOrder() {\n\t\t\t\tvar order = new List<int>();\n\t\t\t\tDFS(this, b => order.Add(b.Id), null, null);\n\t\t\t\treturn order;\n\t\t\t}\n\t\t\tpublic List<int> InOrder() {\n\t\t\t\tvar order = new List<int>();\n\t\t\t\tDFS(this, null, b => order.Add(b.Id), null);\n\t\t\t\treturn order;\n\t\t\t}\n\t\t\tpublic List<int> PostOrder() {\n\t\t\t\tvar order = new List<int>();\n\t\t\t\tDFS(this, null, null, b => order.Add(b.Id));\n\t\t\t\treturn order;\n\t\t\t}\n\t\t}\n\t}\n\tstatic class ExtendClass {\n\t\tpublic static void Swap<T>(this T[] A, int x, int y) {\n\t\t\tvar tmp = A[x];\n\t\t\tA[x] = A[y];\n\t\t\tA[y] = tmp;\n\t\t}\n\t\tpublic static string Join<T>(this IEnumerable<T> X, string separator = \" \") => string.Join(separator, X);\n\t}\n\tclass ConsoleInput {\n\t\tprivate readonly TextReader _stream;\n\t\tprivate readonly char _separator = ' ';\n\t\tprivate readonly Queue<string> inputStream;\n\t\tpublic ConsoleInput(TextReader stream, char separator = ' ') {\n\t\t\tthis._separator = separator;\n\t\t\tthis._stream = stream;\n\t\t\tinputStream = new Queue<string>();\n\t\t}\n\t\tpublic string Read {\n\t\t\tget {\n\t\t\t\tif(inputStream.Count != 0) return inputStream.Dequeue();\n\t\t\t\tstring[] tmp = _stream.ReadLine().Split(_separator);\n\t\t\t\tfor(int i = 0; i < tmp.Length; ++i)\n\t\t\t\t\tinputStream.Enqueue(tmp[i]);\n\t\t\t\treturn inputStream.Dequeue();\n\t\t\t}\n\t\t}\n\t\tpublic string ReadLine { get { return _stream.ReadLine(); } }\n\t\tpublic int ReadInt { get { return int.Parse(Read); } }\n\t\tpublic long ReadLong { get { return long.Parse(Read); } }\n\t\tpublic double ReadDouble { get { return double.Parse(Read); } }\n\t\tpublic string[] ReadStrArray(long N) {\n\t\t\tvar ret = new string[N];\n\t\t\tfor(long i = 0; i < N; ++i)\n\t\t\t\tret[i] = Read;\n\t\t\treturn ret;\n\t\t}\n\t\tpublic int[] ReadIntArray(long N) { var ret = new int[N]; for(long i = 0; i < N; ++i) ret[i] = ReadInt; return ret; }\n\t\tpublic long[] ReadLongArray(long N) { var ret = new long[N]; for(long i = 0; i < N; ++i) ret[i] = ReadLong; return ret; }\n\t\tpublic double[] ReadDoubleArray(long N) { var ret = new double[N]; for(long i = 0; i < N; ++i) ret[i] = ReadDouble; return ret; }\n\t\tpublic bool isEOF {\n\t\t\tget { return _stream.Peek() == -1; }\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_7_D\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string line;\n\n            //入力\n            line = Console.ReadLine().Trim();\n            var nodeCount = int.Parse(line);\n            line = Console.ReadLine().Trim();\n            var preorders = line.Split(\" \".ToCharArray(), StringSplitOptions.RemoveEmptyEntries).Select(e => int.Parse(e)).ToArray();\n            line = Console.ReadLine().Trim();\n            var inorders = line.Split(\" \".ToCharArray(), StringSplitOptions.RemoveEmptyEntries).Select(e => int.Parse(e)).ToArray();\n\n            //再構成\n            var nodes = new Nodes<int>();\n            ReConstruct(nodes, preorders, inorders);\n            Console.WriteLine(String.Join(\" \", nodes.Postorder().Select(x => x.Value).ToArray()));\n        }\n\n        static void ReConstruct(Nodes<int> nodes, int[] preorders, int[] inorders)\n        {\n            var root = nodes.GetNode(preorders[0]);\n\n            var inordersIdx = inorders.Select((val, idx) => new { val, idx }).Where(x => x.val == root.Value).Select(x => x.idx).First();\n\n            var inorderLeft = inorders.Take(inordersIdx).ToArray();\n            var inorderRight = inorders.Skip(inordersIdx + 1).ToArray();\n            var preordersLeft = preorders.Skip(1).Take(inordersIdx).ToArray();\n            var preordersRight = preorders.Skip(inordersIdx + 1).ToArray();\n\n            if (preordersLeft.Length > 0)\n            {\n                nodes.SetLeft(root, preordersLeft[0]);\n                ReConstruct(nodes, preordersLeft, inorderLeft);\n            }\n            if (inorderRight.Length > 0)\n            {\n                nodes.SetRight(root, preordersRight[0]);\n                ReConstruct(nodes, preordersRight, inorderRight);\n            }\n        }\n    }\n\n    public class Nodes<T>\n    {\n        private readonly Dictionary<T, Node> nodes = new Dictionary<T, Node>();\n\n        public Node GetNode(T val)\n        {\n            Node node;\n            if (!nodes.TryGetValue(val, out node))\n            {\n                node = new Node() { Value = val };\n                nodes.Add(val, node);\n            }\n            return node;\n        }\n\n        public void SetLeft(Node node, T val)\n        {\n            var left = GetNode(val);\n            left.Parent = node;\n            node.Left = left;\n        }\n\n        public void SetRight(Node node, T val)\n        {\n            var right = GetNode(val);\n            right.Parent = node;\n            node.Right = right;\n        }\n\n        public Node GetRoot()\n        {\n            return nodes.Values.FirstOrDefault(x => x.Parent == null);\n        }\n\n        public IEnumerable<Node> Preorder(Node node = null)\n        {\n            if (node == null)\n                node = GetRoot();\n\n            yield return node;\n            foreach (var child in node.Children())\n            {\n                foreach (var grandChild in Preorder(child))\n                    yield return grandChild;\n            }\n        }\n\n        public IEnumerable<Node> Inorder(Node node = null)\n        {\n            if (node == null)\n                node = GetRoot();\n\n            if (node.Left != null)\n            {\n                foreach (var grandChild in Inorder(node.Left))\n                    yield return grandChild;\n            }\n            yield return node;\n            if (node.Right != null)\n            {\n                foreach (var grandChild in Inorder(node.Right))\n                    yield return grandChild;\n            }\n        }\n\n        public IEnumerable<Node> Postorder(Node node = null)\n        {\n            if (node == null)\n                node = GetRoot();\n\n            foreach (var child in node.Children())\n            {\n                foreach (var grandChild in Postorder(child))\n                    yield return grandChild;\n            }\n            yield return node;\n        }\n\n        public IEnumerable<Node> GetList()\n        {\n            return nodes.OrderBy(x => x.Key).Select(x => x.Value);\n        }\n\n        public class Node\n        {\n            public T Value { get; set; }\n            public Node Parent { get; set; }\n            public Node Left { get; set; }\n            public Node Right { get; set; }\n\n            public string NodeType\n            {\n                get\n                {\n                    if (Parent == null)\n                    {\n                        return \"root\";\n                    }\n                    if (Left != null || Right != null)\n                    {\n                        return \"internal node\";\n                    }\n                    return \"leaf\";\n                }\n            }\n\n            public int GetDepth()\n            {\n                if (Parent == null)\n                {\n                    return 0;\n                }\n                return Parent.GetDepth() + 1;\n            }\n\n            public IEnumerable<Node> Children()\n            {\n                if (Left != null) yield return Left;\n                if (Right != null) yield return Right;\n            }\n\n            public override string ToString()\n            {\n                return $\"node {Value}: parent = {(Parent != null ? Parent.Value.ToString() : \"-1\")}, {NodeType}\";\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _20170410_AOJ_ALDS1_7D\n{\n    class ALDS1_7D\n    {\n        static void Main(string[] args)\n        {\n            for (;;)\n            {\n                string line = Console.ReadLine();\n                if (string.IsNullOrEmpty(line))\n                {\n                    break;\n                }\n\n                int n = int.Parse(line);\n\n                TreeNode[] arr = new TreeNode[n + 1];\n                TreeNode parent = null;\n                int[] ns = Console.ReadLine().Split(' ').Select(x => int.Parse(x)).ToArray();\n\n                for (int i = 0; i < n; i++)\n                {\n                    TreeNode tn = new TreeNode();\n                    tn.Id = ns[i];\n                    arr[tn.Id] = tn;\n                    if (parent != null)\n                    {\n                        parent.Left = tn;\n                        tn.Parent = parent;\n                    }\n                    parent = tn;\n                }\n\n                ns = Console.ReadLine().Split(' ').Select(x => int.Parse(x)).ToArray();\n                TreeNode restRoot = arr[1].GetRoot();\n                for (int i = 0; i < n; i++)\n                {\n                    if(restRoot==null)\n                    {\n                        break;\n                    }\n\n                    TreeNode tn = arr[ns[i]];\n                    if (restRoot == tn)\n                    {\n                        restRoot = tn.Left;\n                        tn.Left = null;\n                        tn.Right = restRoot;\n                    }\n                    else if (restRoot.Contains(tn))\n                    {\n                        restRoot = tn.Left;\n                        if (restRoot != null)\n                        {\n                            tn.Left = null;\n                            restRoot.Parent = null;\n                        }\n                    }\n                    else\n                    {\n                        if(restRoot.Parent!=null)\n                        {\n                            restRoot.Parent.Right = null;\n                        }\n                        restRoot.Parent = tn;\n                        tn.Right = restRoot;\n                    }\n                }\n\n                TreeNode root = arr[1].GetRoot();\n                WriteOrder(root);\n            }\n        }\n\n        static void WriteOrder(TreeNode tn)\n        {\n            List<TreeNode> list = new List<TreeNode>();\n            PostOrder(list, tn);\n            Console.WriteLine(string.Join(\" \", list.Select(x => x.Id.ToString()).ToArray()));\n        }\n\n        static void PostOrder(List<TreeNode> list, TreeNode tn)\n        {\n            if (tn.Left != null)\n            {\n                PostOrder(list, tn.Left);\n            }\n\n            if (tn.Right != null)\n            {\n                PostOrder(list, tn.Right);\n            }\n\n            list.Add(tn);\n        }\n    }\n\n    class TreeNode\n    {\n        public int Id { get; set; }\n        public TreeNode Parent { get; set; }\n        public TreeNode Left { get; set; }\n        public TreeNode Right { get; set; }\n        public int Depth { get; internal set; }\n        public int Height { get; internal set; }\n        public TreeNode()\n        {\n        }\n\n        public TreeNode GetRoot()\n        {\n            TreeNode temp = this;\n            while (temp.Parent != null)\n            {\n                temp = temp.Parent;\n            }\n\n            return temp;\n        }\n\n        public bool Contains(TreeNode tn)\n        {\n            bool rv = false;\n            rv = (\n                this == tn ||\n                (Left != null && Left.Contains(tn)) ||\n                (Right != null && Right.Contains(tn)));\n            return rv;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace ALDS1_7_D\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            int[] preOrder = Console.ReadLine()\n                                    .Split(' ')\n                                    .Select(i => int.Parse(i))\n                                    .ToArray();\n\n            int[] inOrder = Console.ReadLine()\n                                    .Split(' ')\n                                    .Select(i => int.Parse(i))\n                                    .ToArray();\n\n            Node root = Node.FormTreeFromOrder(null, preOrder, inOrder);\n            StringBuilder stringBuilder = new StringBuilder();\n            root.BuildPostOrder(stringBuilder);\n            Console.WriteLine(stringBuilder.ToString().Trim(' '));\n        }\n    }\n\n    class Node\n    {\n        public int val;\n        public Node parent = null;\n        public Node left = null;\n        public Node right = null;\n\n        public static Node FormTreeFromOrder(Node parent, int[] preOrder, int[] inOrder)\n        {\n            Node node = new Node();\n            node.parent = parent;\n            node.val = preOrder[0];\n\n            int[] inOrderLeft = inOrder.TakeWhile(i => i != node.val)\n                                       .ToArray();\n\n            int[] inOrderRight = inOrder.SkipWhile(i => i != node.val)\n                                        .Skip(1)\n                                        .ToArray();\n\n            int[] preOrderLeft = preOrder.Skip(1)\n                                         .Take(inOrderLeft.Length)\n                                         .ToArray();\n\n            int[] preOrderRight = preOrder.Skip(1)\n                                          .Skip(inOrderLeft.Length)\n                                          .ToArray();\n            if (inOrderLeft.Length > 0)\n            {\n                node.left = Node.FormTreeFromOrder(node, preOrderLeft, inOrderLeft);\n            }\n\n            if (inOrderRight.Length > 0)\n            {\n                node.right = Node.FormTreeFromOrder(node, preOrderRight, inOrderRight);\n            }\n\n            return node;\n        }\n\n        public void BuildPostOrder(StringBuilder stringBuilder)\n        {\n            if (this.left != null)\n            {\n                this.left.BuildPostOrder(stringBuilder);\n            }\n\n            if (this.right != null)\n            {\n                this.right.BuildPostOrder(stringBuilder);\n            }\n\n            stringBuilder.Append(string.Format(\" {0}\", this.val));\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _20170410_AOJ_ALDS1_7D\n{\n    class ALDS1_7D\n    {\n        static void Main(string[] args)\n        {\n            for (;;)\n            {\n                string line = Console.ReadLine();\n                if (string.IsNullOrEmpty(line))\n                {\n                    break;\n                }\n\n                int n = int.Parse(line);\n\n                TreeNode[] arr = new TreeNode[n + 1];\n                TreeNode parent = null;\n                int[] ns = Console.ReadLine().Split(' ').Select(x => int.Parse(x)).ToArray();\n\n                for (int i = 0; i < n; i++)\n                {\n                    TreeNode tn = new TreeNode();\n                    tn.Id = ns[i];\n                    arr[tn.Id] = tn;\n                    if (parent != null)\n                    {\n                        parent.Left = tn;\n                        tn.Parent = parent;\n                    }\n                    parent = tn;\n                }\n\n                ns = Console.ReadLine().Split(' ').Select(x => int.Parse(x)).ToArray();\n                TreeNode restRoot = arr[1].GetRoot();\n                for (int i = 0; i < n; i++)\n                {\n                    if(restRoot==null)\n                    {\n                        break;\n                    }\n\n                    TreeNode tn = arr[ns[i]];\n                    if (restRoot == tn)\n                    {\n                        restRoot = tn.Left;\n                        tn.Left = null;\n                        tn.Right = restRoot;\n                    }\n                    else if (restRoot.Contains(tn))\n                    {\n                        restRoot = tn.Left;\n                        if (restRoot != null)\n                        {\n                            tn.Left = null;\n                            tn.Right = restRoot;\n                        }\n                    }\n                    else\n                    {\n                        if(restRoot.Parent!=null)\n                        {\n                            restRoot.Parent.Right = null;\n                        }\n                        restRoot.Parent = tn;\n                        tn.Right = restRoot;\n                    }\n                }\n\n                TreeNode root = arr[1].GetRoot();\n                WriteOrder(root);\n            }\n        }\n\n        static void WriteOrder(TreeNode tn)\n        {\n            List<TreeNode> list = new List<TreeNode>();\n            PostOrder(list, tn);\n            Console.WriteLine(string.Join(\" \", list.Select(x => x.Id.ToString()).ToArray()));\n        }\n\n        static void PostOrder(List<TreeNode> list, TreeNode tn)\n        {\n            if (tn.Left != null)\n            {\n                PostOrder(list, tn.Left);\n            }\n\n            if (tn.Right != null)\n            {\n                PostOrder(list, tn.Right);\n            }\n\n            list.Add(tn);\n        }\n    }\n\n    class TreeNode\n    {\n        public int Id { get; set; }\n        public TreeNode Parent { get; set; }\n        public TreeNode Left { get; set; }\n        public TreeNode Right { get; set; }\n        public int Depth { get; internal set; }\n        public int Height { get; internal set; }\n        public TreeNode()\n        {\n        }\n\n        public TreeNode GetRoot()\n        {\n            TreeNode temp = this;\n            while (temp.Parent != null)\n            {\n                temp = temp.Parent;\n            }\n\n            return temp;\n        }\n\n        public bool Contains(TreeNode tn)\n        {\n            bool rv = false;\n            rv = (\n                this == tn ||\n                (Left != null && Left.Contains(tn)) ||\n                (Right != null && Right.Contains(tn)));\n            return rv;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace D\n{\n    public struct Node\n    {\n        public int left;\n        public int right;\n        public Tree tree;\n    }\n\n    public class Tree\n    {\n        internal Node[] nodes;\n\n        public Tree(int nodes)\n        {\n            this.nodes = new Node[nodes + 1];\n            for (int i = 1; i < nodes + 1; i++)\n            {\n                this.nodes[i].left = -1;\n                this.nodes[i].right = -1;\n                this.nodes[i].tree = this;\n            }\n        }\n\n        public void AddChilden(int id, int left, int right)\n        {\n            nodes[id].left = left;\n            nodes[id].right = right;\n        }\n\n        public void Postorder(int node)\n        {\n            if (nodes[node].left != -1) Postorder(nodes[node].left);\n            if (nodes[node].right != -1) Postorder(nodes[node].right);\n            Console.Write(node + \" \");\n        }\n\n        public int Analyze(IEnumerable<int> preList, IEnumerable<int> inList)\n        {\n            if (preList.Count() == 0) return -1;\n            var node = preList.First();\n            var index = inList.ToList().IndexOf(node);\n            var left = Analyze(preList.Skip(1).Take(index), inList.Take(index));\n            var right = Analyze(preList.Skip(1 + index), inList.Skip(1 + index));\n            AddChilden(node, left, right);\n            return node;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var n = int.Parse(Console.ReadLine());\n            var preList = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            var inList = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            var tree = new Tree(n);\n            tree.Postorder(tree.Analyze(preList, inList));\n            Console.WriteLine();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "//Reconstruction of a tree\n//木の再現\n//2分木にのみ\n//参考：https://onlinejudge.u-aizu.ac.jp/solutions/problem/ALDS1_7_D/review/1911401/emine/C%23\n//preとinの差異でどこがinternal nodeかわかる\nusing System;\nusing System.Collections.Generic;\n\nnamespace tst\n{\n    class Program\n    {\n        public static int n = 0;\n        public static int[] P;\n        public static int[] I;\n        public static int pos=0;\n        public static void Recon(int left, int right, List<int>A)\n        {\n            if (left >= right) return;\n            int root = P[pos++];\n            int m = 0;\n            //mはinternal node\n            for(int i=0; i<n; i++)\n            {\n                if (root == I[i]) m= i;\n            }\n            Recon(left, m, A);\n            Recon(m+1, right,A);\n            A.Add(root);\n        }\n        public static void Main()\n        {\n            n = int.Parse(Console.ReadLine());\n            string[] In1 = Console.ReadLine().Split(' ');\n            string[] In2 = Console.ReadLine().Split(' ');\n            P = new int[n];\n            I = new int[n];\n            for(int i=0; i<n; i++)\n            {\n                P[i] = int.Parse(In1[i]);\n                I[i] = int.Parse(In2[i]);\n            }\n            List<int> A = new List<int>();\n            Recon(0, n, A);\n            Console.Write(A[0]);\n            if (A.Count > 1)\n            {\n                for (int i = 1; i < A.Count; i++)\n                {\n                    Console.Write(\" \"+A[i]);\n                }\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass Program\n{\n\n    public void Proc()\n    {\n        int nodeCount = int.Parse(Console.ReadLine());\n        this.PreOrderText = Console.ReadLine();\n        this.InOrderText = Console.ReadLine();\n        // testcode\n        //this.PreOrderText = \"1 2 3 4\";\n        //this.InOrderText = \"1 2 3 4\";\n        string[] prestr = this.PreOrderText.Split(' ');\n        string[] instr = this.InOrderText.Split(' ');\n\n        this.PreOrder = new int[nodeCount];\n       \n        for(int i=0; i<nodeCount; i++) {\n             this.PreOrder[i] = int.Parse(prestr[i]);\n             this.InOrder.Add(int.Parse(instr[i]));\n        }\n\n        TreeNd root = new TreeNd(this.PreOrder[0]);\n        TreeNd ansData = this.SetTree(1, root);\n        string ansText = GetPostorderText(ansData);\n        Console.WriteLine(ansText);\n    }\n\n    public string GetPostorderText(TreeNd dat)\n    {\n        if (dat == null)\n        {\n            return string.Empty;\n        }\n        StringBuilder sb = new StringBuilder();\n        if (dat.LeftChild != null)\n        {\n            string tmp = this.GetPostorderText(dat.LeftChild);\n            if (!string.IsNullOrEmpty(tmp))\n            {\n                sb.Append(tmp);\n            }\n        }\n        if (dat.RightChild != null)\n        {\n            string tmp = this.GetPostorderText(dat.RightChild);\n            if (!string.IsNullOrEmpty(tmp))\n            {\n                if (sb.Length > 0)\n                {\n                    sb.Append(\" \");\n                }\n                sb.Append(tmp);\n            }\n        }\n        if (sb.Length > 0)\n        {\n            sb.Append(\" \");\n        }\n        sb.Append(dat.NodeId);\n        return sb.ToString();\n    }\n\n    private int[] PreOrder;\n    private List<int> InOrder = new List<int>();\n\n    private String PreOrderText = string.Empty;\n    private string InOrderText = string.Empty;\n\n    private string GetInorderText(TreeNd dat)\n    {\n        StringBuilder sb = new StringBuilder();\n        string left = string.Empty;\n        if (dat.LeftChild != null)\n        {\n            left = this.GetInorderText(dat.LeftChild);\n        }\n        if (!string.IsNullOrEmpty(left))\n        {\n            sb.Append(left);\n        }\n        if (sb.Length > 0)\n        {\n            sb.Append(\" \");\n        }\n        sb.Append(dat.NodeId);\n        string right = string.Empty;\n        if (dat.RightChild != null)\n        {\n            right = this.GetInorderText(dat.RightChild);\n        }\n        if (!string.IsNullOrEmpty(right))\n        {\n            sb.Append(\" \");\n            sb.Append(right);\n        }\n        return sb.ToString();\n    }\n    private TreeNd SetTree(int idx, TreeNd root){\n        if (idx >= PreOrder.Length)\n        {\n            // ???????????????\n            string tmpAns = this.GetInorderText(root);\n            if (tmpAns.Equals(this.InOrderText))\n            {\n                return root;\n            }\n            else\n            {\n                return null;\n            }\n            \n        }\n        TreeNd ans = null;\n        TreeNd cop = (TreeNd)root.Clone();\n        TreeNd parent = cop.SearchById(this.PreOrder[idx - 1]);\n\n        while (parent != null)\n        {\n            TreeNd tmp = new TreeNd(this.PreOrder[idx]);\n\n            if (parent.LeftChild == null)\n            {\n                // ???????????´???(??????????????´??????\n                tmp.Parent = parent;\n                parent.LeftChild = tmp;\n\n                ans = SetTree(idx + 1, cop);\n                if (ans != null)\n                {\n                    return ans;\n                }\n                parent.LeftChild = null;\n            }\n            if (parent.RightChild == null)\n            {\n                // ???????????´???(??????????????´??????\n                tmp.Parent = parent;\n                parent.RightChild = tmp;\n\n                ans = SetTree(idx + 1, cop);\n                if (ans != null)\n                {\n                    return ans;\n                }\n                parent.RightChild = null;\n            }\n            parent = parent.Parent;\n        }\n\n        return ans;\n    }\n\n    public class TreeNd:ICloneable\n    {\n        public TreeNd Parent;\n        public int NodeId;\n        public TreeNd LeftChild;\n        public TreeNd RightChild;\n\n\n        public TreeNd(int nodeid)\n        {\n            this.NodeId = nodeid;\n        }\n\n        public TreeNd SearchById(int id)\n        {\n            TreeNd ret = null;\n            if (id == this.NodeId)\n            {\n                ret = this;\n            }\n            else if(this.LeftChild != null)\n            {\n                ret = this.LeftChild.SearchById(id);\n            }\n            if (ret == null && this.RightChild != null)\n            {\n                ret = this.RightChild.SearchById(id);\n            }\n            return ret;\n        }\n\n        public object Clone()\n        {\n            TreeNd tn = new TreeNd(this.NodeId);\n            if (this.LeftChild != null)\n            {\n                tn.LeftChild = (TreeNd)this.LeftChild.Clone();\n                tn.LeftChild.Parent = tn;\n            }\n            if (this.RightChild != null)\n            {\n                tn.RightChild = (TreeNd)this.RightChild.Clone();\n                tn.RightChild.Parent = tn;\n            }\n\n            return tn;\n        }\n    }\n\n\n    static void Main(string[] args)\n    {\n        Program prg = new Program();\n        prg.Proc();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass Program\n{\n\n    public void Proc()\n    {\n        int nodeCount = int.Parse(Console.ReadLine());\n        this.PreOrderText = Console.ReadLine();\n        this.InOrderText = Console.ReadLine();\n        // testcode\n        //this.PreOrderText = \"1 2 3 4\";\n        //this.InOrderText = \"1 2 3 4\";\n        string[] prestr = this.PreOrderText.Split(' ');\n        string[] instr = this.InOrderText.Split(' ');\n\n        this.PreOrder = new int[nodeCount];\n       \n        for(int i=0; i<nodeCount; i++) {\n             this.PreOrder[i] = int.Parse(prestr[i]);\n             this.InOrder.Add(int.Parse(instr[i]));\n        }\n\n        TreeNd root = new TreeNd(this.PreOrder[0]);\n        TreeNd ansData = this.SetTree(1, root);\n        string ansText = GetPostorderText(ansData);\n        Console.WriteLine(ansText);\n    }\n\n    public string GetPostorderText(TreeNd dat)\n    {\n        if (dat == null)\n        {\n            return string.Empty;\n        }\n        StringBuilder sb = new StringBuilder();\n        if (dat.LeftChild != null)\n        {\n            string tmp = this.GetPostorderText(dat.LeftChild);\n            if (!string.IsNullOrEmpty(tmp))\n            {\n                sb.Append(tmp);\n            }\n        }\n        if (dat.RightChild != null)\n        {\n            string tmp = this.GetPostorderText(dat.RightChild);\n            if (!string.IsNullOrEmpty(tmp))\n            {\n                if (sb.Length > 0)\n                {\n                    sb.Append(\" \");\n                }\n                sb.Append(tmp);\n            }\n        }\n        if (sb.Length > 0)\n        {\n            sb.Append(\" \");\n        }\n        sb.Append(dat.NodeId);\n        return sb.ToString();\n    }\n\n    private int[] PreOrder;\n    private List<int> InOrder = new List<int>();\n\n    private String PreOrderText = string.Empty;\n    private string InOrderText = string.Empty;\n\n    private string GetInorderText(TreeNd dat)\n    {\n        StringBuilder sb = new StringBuilder();\n        string left = string.Empty;\n        if (dat.LeftChild != null)\n        {\n            left = this.GetInorderText(dat.LeftChild);\n        }\n        if (!string.IsNullOrEmpty(left))\n        {\n            sb.Append(left);\n        }\n        if (sb.Length > 0)\n        {\n            sb.Append(\" \");\n        }\n        sb.Append(dat.NodeId);\n        string right = string.Empty;\n        if (dat.RightChild != null)\n        {\n            right = this.GetInorderText(dat.RightChild);\n        }\n        if (!string.IsNullOrEmpty(right))\n        {\n            sb.Append(\" \");\n            sb.Append(right);\n        }\n        return sb.ToString();\n    }\n    private TreeNd SetTree(int idx, TreeNd root){\n        if (idx >= PreOrder.Length)\n        {\n            // ???????????????\n            string tmpAns = this.GetInorderText(root);\n            if (tmpAns.Equals(this.InOrderText))\n            {\n                return root;\n            }\n            else\n            {\n                return null;\n            }\n            \n        }\n        TreeNd ans = null;\n        TreeNd cop = (TreeNd)root.Clone();\n        TreeNd parent = cop.SearchById(this.PreOrder[idx - 1]);\n\n        Nullable<int> idx1 = null;\n        Nullable<int> idx2 = null;\n\n        while (parent != null)\n        {\n            TreeNd tmp = new TreeNd(this.PreOrder[idx]);\n\n            if (parent.LeftChild == null)\n            {\n                // ???????????´???(??????????????´??????\n                if (idx2 == null)\n                {\n                    idx2 = this.InOrder.IndexOf(this.PreOrder[idx]);\n                }\n                if (idx1 == null)\n                {\n                    idx1 = this.InOrder.IndexOf(parent.NodeId);\n                }\n                if (idx2 < idx1)\n                {\n                    tmp.Parent = parent;\n                    parent.LeftChild = tmp;\n\n                    ans = SetTree(idx + 1, cop);\n                    if (ans != null)\n                    {\n                        return ans;\n                    }\n                    parent.LeftChild = null;\n                }\n            }\n            if (parent.RightChild == null)\n            {\n                // ???????????´???(??????????????´??????\n                if (idx2 == null)\n                {\n                    idx2 = this.InOrder.IndexOf(this.PreOrder[idx]);\n                }\n                if (idx1 == null)\n                {\n                    idx1 = this.InOrder.IndexOf(parent.NodeId);\n                }\n                if (idx1 < idx2)\n                {\n                    tmp.Parent = parent;\n                    parent.RightChild = tmp;\n\n                    ans = SetTree(idx + 1, cop);\n                    if (ans != null)\n                    {\n                        return ans;\n                    }\n                    parent.RightChild = null;\n                }\n            }\n            parent = parent.Parent;\n        }\n\n        return ans;\n    }\n\n    public class TreeNd:ICloneable\n    {\n        public TreeNd Parent;\n        public int NodeId;\n        public TreeNd LeftChild;\n        public TreeNd RightChild;\n\n\n        public TreeNd(int nodeid)\n        {\n            this.NodeId = nodeid;\n        }\n\n        public TreeNd SearchById(int id)\n        {\n            TreeNd ret = null;\n            if (id == this.NodeId)\n            {\n                ret = this;\n            }\n            else if(this.LeftChild != null)\n            {\n                ret = this.LeftChild.SearchById(id);\n            }\n            if (ret == null && this.RightChild != null)\n            {\n                ret = this.RightChild.SearchById(id);\n            }\n            return ret;\n        }\n\n        public object Clone()\n        {\n            TreeNd tn = new TreeNd(this.NodeId);\n            if (this.LeftChild != null)\n            {\n                tn.LeftChild = (TreeNd)this.LeftChild.Clone();\n                tn.LeftChild.Parent = tn;\n            }\n            if (this.RightChild != null)\n            {\n                tn.RightChild = (TreeNd)this.RightChild.Clone();\n                tn.RightChild.Parent = tn;\n            }\n\n            return tn;\n        }\n    }\n\n\n    static void Main(string[] args)\n    {\n        Program prg = new Program();\n        prg.Proc();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace D\n{\n    public struct Node\n    {\n        public int left;\n        public int right;\n        public Tree tree;\n    }\n\n    public class Tree\n    {\n        internal Node[] nodes;\n\n        public Tree(int nodes)\n        {\n            this.nodes = new Node[nodes + 1];\n            for (int i = 1; i < nodes + 1; i++)\n            {\n                this.nodes[i].left = -1;\n                this.nodes[i].right = -1;\n                this.nodes[i].tree = this;\n            }\n        }\n\n        public void AddChilden(int id, int left, int right)\n        {\n            nodes[id].left = left;\n            nodes[id].right = right;\n        }\n\n        public void Postorder(int node,ref List<int> list)\n        {\n            if (nodes[node].left != -1) Postorder(nodes[node].left,ref list);\n            if (nodes[node].right != -1) Postorder(nodes[node].right,ref list);\n            list.Add(node);\n        }\n\n        public int Analyze(IEnumerable<int> preList, IEnumerable<int> inList)\n        {\n            if (preList.Count() == 0) return -1;\n            var node = preList.First();\n            var index = inList.ToList().IndexOf(node);\n            var left = Analyze(preList.Skip(1).Take(index), inList.Take(index));\n            var right = Analyze(preList.Skip(1 + index), inList.Skip(1 + index));\n            AddChilden(node, left, right);\n            return node;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var n = int.Parse(Console.ReadLine());\n            var preList = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            var inList = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            var tree = new Tree(n);\n            var list = new List<int>();\n            tree.Postorder(tree.Analyze(preList, inList),ref list);\n            Console.WriteLine(string.Join(\" \",list.ToArray()));\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ALDS1_7_D\n{\n    public class Program\n\n    {\n        public static void Main(string[] args)\n        {\n            int n = ReadInt();\n            int[] preOrder = ReadIntAr();\n            int[] inOrder = ReadIntAr();\n\n            BinaryTreeNodeList<int> nodes = new BinaryTreeNodeList<int>(n);\n            BinaryTree<int> bt = new BinaryTree<int>();\n\n            for (int i = 0 ; i < n ; i++) { nodes[i] = new BinaryTreeNode<int>(inOrder[i]); }\n\n            int index = 0;\n            bt.Root = Reconstruct(nodes, preOrder, inOrder, ref index);\n            List<int> res = new List<int>();\n            bt.PostorderTraversal(bt.Root, res);\n\n            Console.WriteLine(String.Join(\" \", res.Select(x => x.ToString()).ToArray()));\n        }\n\n        static BinaryTreeNode<int> Reconstruct(BinaryTreeNodeList<int> nodes, int[] preoder, int[] inorder, ref int i)\n        {\n            var root = preoder[i];\n            var index = Array.IndexOf(inorder, root);\n            \n\n            if (index == 0)\n                nodes.FindByValue(root).Left = null;\n            else\n            {\n                i++;\n                BinaryTreeNode<int> left = Reconstruct(nodes, preoder, inorder.Take(index).ToArray(), ref i);\n                nodes.FindByValue(root).Left = left;\n            }\n\n            if (index == inorder.Length - 1)\n                nodes.FindByValue(root).Right = null;\n            else\n            {\n                i++;\n                BinaryTreeNode<int> right = Reconstruct(nodes, preoder, inorder.Skip(index + 1).Take(inorder.Length - index - 1).ToArray(), ref i);\n                nodes.FindByValue(root).Right = right;\n            }\n            return nodes.FindByValue(root);\n        }\n\n\n        static string ReadSt() { return Console.ReadLine(); }\n        static int ReadInt() { return int.Parse(Console.ReadLine()); }\n        static long ReadLong() { return long.Parse(Console.ReadLine()); }\n        static double ReadDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] ReadStAr(char sep = ' ') { return Console.ReadLine().Split(sep); }\n        static int[] ReadIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => int.Parse(e)); }\n        static long[] ReadLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => long.Parse(e)); }\n        static double[] ReadDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => double.Parse(e)); }\n\n    }\n    \n    public class BinaryTreeNode<T> : Node<T>\n    {\n        public BinaryTreeNode() : base() { }\n        public BinaryTreeNode(T data) : base(data, null) { }\n        public BinaryTreeNode(T data, BinaryTreeNode<T> left, BinaryTreeNode<T> right)\n        {\n            Value = data;\n            Neighbors = new NodeList<T> { left, right };\n        }\n\n        public BinaryTreeNode<T> Left\n        {\n            get\n            {\n                if (base.Neighbors == null) return null;\n                else return (BinaryTreeNode<T>)Neighbors[0];\n            }\n            set\n            {\n                if (base.Neighbors == null) base.Neighbors = new NodeList<T>(2);\n                base.Neighbors[0] = value;\n                if ( value != null) value.Parent = Neighbors[0];\n            }\n        }\n\n        public BinaryTreeNode<T> Right\n        {\n            get\n            {\n                if (base.Neighbors == null) return null;\n                else return (BinaryTreeNode<T>)base.Neighbors[1];\n            }\n            set\n            {\n                if (base.Neighbors == null) base.Neighbors = new NodeList<T>(2);\n                base.Neighbors[1] = value;\n                if (value != null)  value.Parent = Neighbors[1];\n            }\n        }\n    }\n\n    public class BinaryTreeNodeList<T> :NodeList<T>\n    {\n        public BinaryTreeNodeList() : base() { }\n        public BinaryTreeNodeList(int initialSize)\n        { for (int i = 0 ; i < initialSize ; i++) Add(default(BinaryTreeNode<T>)); }\n\n        public new BinaryTreeNode<T> FindByValue(T value)\n        {\n            foreach (BinaryTreeNode<T> node in this) if (node.Value.Equals(value)) return node;\n            return null;\n        }\n    }\n\n    public class BinaryTree<T>\n    {\n\n        public BinaryTreeNode<T> Root { get; set; }\n\n        public BinaryTree() { Root = null; }\n        public virtual void Clear() { Root = null; }\n\n        public void PreorderTraversal(BinaryTreeNode<T> current,List<T> res)\n        {\n            if (current != null)\n            {\n                res.Add(current.Value);\n                PreorderTraversal(current.Left, res);\n                PreorderTraversal(current.Right,res);\n            }\n        }\n\n        public void InorderTraversal(BinaryTreeNode<T> current, List<T> res)\n        {\n            if (current != null)\n            {\n                InorderTraversal(current.Left, res);\n                res.Add(current.Value);\n                InorderTraversal(current.Right, res);\n            }\n        }\n\n        public void PostorderTraversal(BinaryTreeNode<T> current, List<T> res)\n        {\n            if (current != null)\n            {\n                PostorderTraversal(current.Left, res);\n                PostorderTraversal(current.Right, res);\n                res.Add(current.Value);\n            }\n        }\n\n    }\n\n public class Node<T>\n    {\n        public T Value { get; set; }\n        public Node<T> Parent { get; set; }\n        protected NodeList<T> Neighbors { get; set; }\n\n        public Node() { }\n        public Node(T data) : this(data, null) { }\n        public Node(T data, NodeList<T> neighbors)\n        {\n            Value = data;\n            Neighbors = neighbors;\n        }\n    }\n\n    public class NodeList<T> : List<Node<T>>\n    {\n        public NodeList() : base() { }\n        public NodeList(int initialSize)\n        { for (int i = 0 ; i < initialSize ; i++) Add(default(Node<T>)); }\n\n        public Node<T> FindByValue(T value)\n        {\n            foreach (Node<T> node in this) if (node.Value.Equals(value)) return node;\n            return null;\n        }\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\nclass Program{\n    static int[] preorder, inorder, positions;\n\n    static void Reconstruct(int leftLimPre, int rightLimPre,\n            int leftLimIn, int rightLimIn, bool isPrintSpace){\n        int root=preorder[leftLimPre];\n        int rootPos=positions[root-1];\n        int numLeft=rootPos-leftLimIn;\n        int numRight=rightLimIn-rootPos;\n        if(numLeft>0){\n            Reconstruct(leftLimPre+1, leftLimPre+numLeft,\n                    leftLimIn, rootPos-1, isPrintSpace);\n            isPrintSpace=true;\n        }\n        if(numRight>0){\n            Reconstruct(rightLimPre-numRight+1, rightLimPre,\n                    rootPos+1, rightLimIn, isPrintSpace);\n            isPrintSpace=true;\n        }\n        if(isPrintSpace){\n            Console.Write(\" \");\n        }\n        Console.Write(root);\n    }\n\n    public static void Main(){\n        var n=int.Parse(Console.ReadLine());\n        preorder=new int[n];\n        inorder=new int[n];\n        positions=new int[n];\n        var s=Console.ReadLine().Split(' ');\n        for(var i=0; i<n; i++){\n            preorder[i]=int.Parse(s[i]);\n        }\n        s=Console.ReadLine().Split(' ');\n        for(var i=0; i<n; i++){\n            inorder[i]=int.Parse(s[i]);\n            positions[inorder[i]-1]=i;\n        }\n\n        Reconstruct(0, n-1, 0, n-1, false);\n        Console.WriteLine();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace ConsoleApp1\n{\n\n    class Program\n    {\n        public static int[] preOrder, inOrder;\n        public static List<int> postOrder= new List<int>();\n        public static int pos = 0;\n        static void Main()\n        {\n            int n = int.Parse(Console.ReadLine());\n            preOrder = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            inOrder = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            Reconstruct(0, n);\n            for (int i = 0; i < n - 1; i++) Console.Write(postOrder[i] + \" \");\n            Console.WriteLine(postOrder[n - 1]);\n        }\n        private static void Reconstruct(int left, int right) \n        {\n            if (left >= right) return;\n            int root = preOrder[pos++];\n            int m = Array.IndexOf(inOrder, root);\n            Reconstruct(left, m);\n            Reconstruct(m + 1, right);\n            postOrder.Add(root);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_7D{\n    public class Program{\n        public static void Main(string[] args){\n            var sr = new StreamReader();\n            //---------------------------------\n            var N = sr.Next<int>();\n            var preOrder = sr.Next<int>(N);\n            var inOrder = sr.Next<int>(N);\n\n            var cnt = 0;\n            var res = new List<int>();\n\n            Action<int, int> reconstruct = null;\n            reconstruct = (l, r) =>{\n                if(cnt >= N || l >= r) return;\n                var cp = preOrder[cnt++];\n                var m = Array.IndexOf(inOrder, cp);\n\n                reconstruct(l, m);\n                reconstruct(m + 1, r);\n                res.Add(cp);\n            };\n            reconstruct(0, N);\n\n            Console.WriteLine(string.Join(\" \", res.Select(x => x.ToString()).ToArray()));\n            //---------------------------------\n        }\n    }\n\n    public class StreamReader{\n        private readonly char[] _c = {' '};\n        private int _index = -1;\n        private string[] _input = new string[0];\n\n        public T Next<T>(){\n            if(_index == _input.Length - 1){\n                _index = -1;\n                while(true){\n                    string rl = Console.ReadLine();\n                    if(rl == null){\n                        if(typeof(T).IsClass) return default(T);\n                        return (T)typeof(T).GetField(\"MinValue\").GetValue(null);\n                    }\n                    if(rl != \"\"){\n                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);\n                        break;\n                    }\n                }\n            }\n            return (T)Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);\n        }\n\n        public T[] Next<T>(int x){\n            var ret = new T[x];\n            for(var i = 0; i < x; ++i) ret[i] = Next<T>();\n            return ret;\n        }\n\n        public T[][] Next<T>(int y, int x){\n            var ret = new T[y][];\n            for(var i = 0; i < y; ++i) ret[i] = Next<T>(x);\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_7_D\n{\n    class Program\n    {\n        static int pos;\n        static int[] pre, ino;\n        static List<int> post = new List<int>();\n\n        static void rec(int l, int r)\n        {\n            if (l >= r) return;\n            int root = pre[pos++];\n            int m = ino.TakeWhile(s => s != root).Count();\n            rec(l, m);\n            rec(m + 1, r);\n            post.Add(root);\n        }\n        static void Main(string[] args)\n        {\n            int n = scan[0];\n            pre = scan;\n            ino = scan;\n\n            rec(0, n);\n\n            Console.WriteLine(String.Join(\" \",post));\n        }\n\n        static int[] scan\n        {\n            get { return Console.ReadLine().Split().Select(int.Parse).ToArray(); }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass Program\n{\n\n    public void Proc()\n    {\n        int nodeCount = int.Parse(Console.ReadLine());\n        this.PreOrderText = Console.ReadLine();\n        this.InOrderText = Console.ReadLine();\n        // testcode\n        //this.PreOrderText = \"1 2 3 4\";\n        //this.InOrderText = \"1 2 3 4\";\n        string[] prestr = this.PreOrderText.Split(' ');\n        string[] instr = this.InOrderText.Split(' ');\n\n        this.PreOrder = new int[nodeCount];\n       \n        for(int i=0; i<nodeCount; i++) {\n             this.PreOrder[i] = int.Parse(prestr[i]);\n             this.PreOrderDic.Add(this.PreOrder[i], i);\n             this.InOrder.Add(int.Parse(instr[i]));\n        }\n\n        TreeNd ansData = this.SetTree(this.InOrder);\n        string ansText = GetPostorderText(ansData);\n        Console.WriteLine(ansText);\n    }\n\n    public string GetPostorderText(TreeNd dat)\n    {\n        if (dat == null)\n        {\n            return string.Empty;\n        }\n        StringBuilder sb = new StringBuilder();\n        if (dat.LeftChild != null)\n        {\n            string tmp = this.GetPostorderText(dat.LeftChild);\n            if (!string.IsNullOrEmpty(tmp))\n            {\n                sb.Append(tmp);\n            }\n        }\n        if (dat.RightChild != null)\n        {\n            string tmp = this.GetPostorderText(dat.RightChild);\n            if (!string.IsNullOrEmpty(tmp))\n            {\n                if (sb.Length > 0)\n                {\n                    sb.Append(\" \");\n                }\n                sb.Append(tmp);\n            }\n        }\n        if (sb.Length > 0)\n        {\n            sb.Append(\" \");\n        }\n        sb.Append(dat.NodeId);\n        return sb.ToString();\n    }\n\n    private int[] PreOrder;\n    private List<int> InOrder = new List<int>();\n    private Dictionary<int, int> PreOrderDic = new Dictionary<int, int>();\n\n    private String PreOrderText = string.Empty;\n    private string InOrderText = string.Empty;\n\n    private string GetInorderText(TreeNd dat)\n    {\n        StringBuilder sb = new StringBuilder();\n        string left = string.Empty;\n        if (dat.LeftChild != null)\n        {\n            left = this.GetInorderText(dat.LeftChild);\n        }\n        if (!string.IsNullOrEmpty(left))\n        {\n            sb.Append(left);\n        }\n        if (sb.Length > 0)\n        {\n            sb.Append(\" \");\n        }\n        sb.Append(dat.NodeId);\n        string right = string.Empty;\n        if (dat.RightChild != null)\n        {\n            right = this.GetInorderText(dat.RightChild);\n        }\n        if (!string.IsNullOrEmpty(right))\n        {\n            sb.Append(\" \");\n            sb.Append(right);\n        }\n        return sb.ToString();\n    }\n\n    private int GetRootTreeId(List<int> list)\n    {\n        int minId = -1;\n        int minIdx = int.MaxValue;\n        foreach (int num in list)\n        {\n            if (this.PreOrderDic[num] < minIdx)\n            {\n                minIdx = this.PreOrderDic[num];\n                minId = num;\n            }\n        }\n        return minId;\n    }\n\n    private TreeNd SetTree(List<int> list){\n        if (list == null || list.Count <= 0)\n        {\n            return null;\n        }\n        if (list.Count == 1)\n        {\n            return new TreeNd(list[0]);\n        }\n        int rootId = this.GetRootTreeId(list);\n        int rootIndex = list.IndexOf(rootId);\n        TreeNd rootNode = new TreeNd(rootId);\n\n        List<int> left = new List<int>();\n        List<int> right = new List<int>();\n        for (int i = 0; i < rootIndex; i++)\n        {\n            left.Add(list[i]);\n        }\n        for (int i = rootIndex + 1; i < list.Count; i++)\n        {\n            right.Add(list[i]);\n        }\n        rootNode.LeftChild = this.SetTree(left);\n        rootNode.RightChild = this.SetTree(right);\n        if (rootNode.LeftChild != null)\n        {\n            rootNode.LeftChild.Parent = rootNode;\n        }\n        if (rootNode.RightChild != null)\n        {\n            rootNode.RightChild.Parent = rootNode;\n        }\n        return rootNode;\n    }\n\n    public class TreeNd:ICloneable\n    {\n        public TreeNd Parent;\n        public int NodeId;\n        public TreeNd LeftChild;\n        public TreeNd RightChild;\n\n\n        public TreeNd(int nodeid)\n        {\n            this.NodeId = nodeid;\n        }\n\n        public TreeNd SearchById(int id)\n        {\n            TreeNd ret = null;\n            if (id == this.NodeId)\n            {\n                ret = this;\n            }\n            else if(this.LeftChild != null)\n            {\n                ret = this.LeftChild.SearchById(id);\n            }\n            if (ret == null && this.RightChild != null)\n            {\n                ret = this.RightChild.SearchById(id);\n            }\n            return ret;\n        }\n\n        public object Clone()\n        {\n            TreeNd tn = new TreeNd(this.NodeId);\n            if (this.LeftChild != null)\n            {\n                tn.LeftChild = (TreeNd)this.LeftChild.Clone();\n                tn.LeftChild.Parent = tn;\n            }\n            if (this.RightChild != null)\n            {\n                tn.RightChild = (TreeNd)this.RightChild.Clone();\n                tn.RightChild.Parent = tn;\n            }\n\n            return tn;\n        }\n    }\n\n\n    static void Main(string[] args)\n    {\n        Program prg = new Program();\n        prg.Proc();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass Program\n{\n\n    public void Proc()\n    {\n        int nodeCount = int.Parse(Console.ReadLine());\n        this.PreOrderText = Console.ReadLine();\n        this.InOrderText = Console.ReadLine();\n        // testcode\n        this.PreOrderText = \"1 2 3 4\";\n        this.InOrderText = \"1 2 3 4\";\n        string[] prestr = this.PreOrderText.Split(' ');\n        string[] instr = this.InOrderText.Split(' ');\n\n        this.PreOrder = new int[nodeCount];\n       \n        for(int i=0; i<nodeCount; i++) {\n             this.PreOrder[i] = int.Parse(prestr[i]);\n             this.InOrder.Add(int.Parse(instr[i]));\n        }\n\n        TreeNd root = new TreeNd(this.PreOrder[0]);\n        TreeNd ansData = this.SetTree(1, root);\n        string ansText = GetPostorderText(ansData);\n        Console.WriteLine(ansText);\n    }\n\n    public string GetPostorderText(TreeNd dat)\n    {\n        if (dat == null)\n        {\n            return string.Empty;\n        }\n        StringBuilder sb = new StringBuilder();\n        if (dat.LeftChild != null)\n        {\n            string tmp = this.GetPostorderText(dat.LeftChild);\n            if (!string.IsNullOrEmpty(tmp))\n            {\n                sb.Append(tmp);\n            }\n        }\n        if (dat.RightChild != null)\n        {\n            string tmp = this.GetPostorderText(dat.RightChild);\n            if (!string.IsNullOrEmpty(tmp))\n            {\n                if (sb.Length > 0)\n                {\n                    sb.Append(\" \");\n                }\n                sb.Append(tmp);\n            }\n        }\n        if (sb.Length > 0)\n        {\n            sb.Append(\" \");\n        }\n        sb.Append(dat.NodeId);\n        return sb.ToString();\n    }\n\n    private int[] PreOrder;\n    private List<int> InOrder = new List<int>();\n\n    private String PreOrderText = string.Empty;\n    private string InOrderText = string.Empty;\n\n    private string GetInorderText(TreeNd dat)\n    {\n        StringBuilder sb = new StringBuilder();\n        string left = string.Empty;\n        if (dat.LeftChild != null)\n        {\n            left = this.GetInorderText(dat.LeftChild);\n        }\n        if (!string.IsNullOrEmpty(left))\n        {\n            sb.Append(left);\n        }\n        if (sb.Length > 0)\n        {\n            sb.Append(\" \");\n        }\n        sb.Append(dat.NodeId);\n        string right = string.Empty;\n        if (dat.RightChild != null)\n        {\n            right = this.GetInorderText(dat.RightChild);\n        }\n        if (!string.IsNullOrEmpty(right))\n        {\n            sb.Append(\" \");\n            sb.Append(right);\n        }\n        return sb.ToString();\n    }\n    private TreeNd SetTree(int idx, TreeNd root){\n        if (idx >= PreOrder.Length)\n        {\n            // ???????????????\n            StringBuilder tmpInOrder = new StringBuilder();\n            string tmpAns = this.GetInorderText(root);\n            if (tmpAns.Equals(this.InOrderText))\n            {\n                return root;\n            }\n            else\n            {\n                return null;\n            }\n            \n        }\n        TreeNd ans = null;\n        TreeNd cop = (TreeNd)root.Clone();\n        TreeNd parent = cop.SearchById(this.PreOrder[idx - 1]);\n\n        while (parent != null)\n        {\n            TreeNd tmp = new TreeNd(this.PreOrder[idx]);\n\n            if (parent.LeftChild == null)\n            {\n                // ???????????´???(??????????????´??????\n                tmp.Parent = parent;\n                parent.LeftChild = tmp;\n\n                ans = SetTree(idx + 1, cop);\n                if (ans != null)\n                {\n                    return ans;\n                }\n                parent.LeftChild = null;\n            }\n            if (parent.RightChild == null)\n            {\n                // ???????????´???(??????????????´??????\n                tmp.Parent = parent;\n                parent.RightChild = tmp;\n\n                ans = SetTree(idx + 1, cop);\n                if (ans != null)\n                {\n                    return ans;\n                }\n                parent.RightChild = null;\n            }\n            parent = parent.Parent;\n        }\n\n        return ans;\n    }\n\n    public class TreeNd:ICloneable\n    {\n        public TreeNd Parent;\n        public int NodeId;\n        public TreeNd LeftChild;\n        public TreeNd RightChild;\n\n\n        public TreeNd(int nodeid)\n        {\n            this.NodeId = nodeid;\n        }\n\n        public TreeNd SearchById(int id)\n        {\n            TreeNd ret = null;\n            if (id == this.NodeId)\n            {\n                ret = this;\n            }\n            else if(this.LeftChild != null)\n            {\n                ret = this.LeftChild.SearchById(id);\n            }\n            if (ret == null && this.RightChild != null)\n            {\n                ret = this.RightChild.SearchById(id);\n            }\n            return ret;\n        }\n\n        public object Clone()\n        {\n            TreeNd tn = new TreeNd(this.NodeId);\n            if (this.LeftChild != null)\n            {\n                tn.LeftChild = (TreeNd)this.LeftChild.Clone();\n                tn.LeftChild.Parent = tn;\n            }\n            if (this.RightChild != null)\n            {\n                tn.RightChild = (TreeNd)this.RightChild.Clone();\n                tn.RightChild.Parent = tn;\n            }\n\n            return tn;\n        }\n    }\n\n\n    static void Main(string[] args)\n    {\n        Program prg = new Program();\n        prg.Proc();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing static System.Console;\nusing System.Text;\nusing System.IO;\n\nnamespace AOJ\n{\n    class Program\n    {\n        static public long[] Sarray() { return ReadLine().Split().Select(long.Parse).ToArray(); }\n        static public List<long> Slist() { return ReadLine().Split().Select(long.Parse).ToList(); }\n\n        class node\n        {\n            public List<long> ko = new List<long>();\n            public long oya = -1;\n        }\n        static void Main(string[] args)\n        {\n            var N = Sarray()[0];\n            var preorder = Sarray();\n            var inorder = Sarray();\n            var nodes = new node[N];\n            var ans = new List<long>();\n\n            Action<long, long, long, long> recon = null;\n            recon = (prel, prer, inl, inr) =>\n              {\n                  //WriteLine($\"({prel},{prer}),({inl},{inr})\");\n                  if (prer <= prel)\n                      return;\n                  if (inr <= inl)\n                      return;\n                  /*for (var i = prel; i < prer; ++i)\n                  {\n                      Write($\"{preorder[i]},\");\n                  }\n                  WriteLine();\n                  for (var i = inl; i< inr; ++i)\n                  {\n                      Write($\"{inorder[i]},\");\n                  }\n                  WriteLine(\"\\n\");*/\n                  //preでルート(preroot)を見つける\n                  var preroot = prel;\n                  //inでprerootに対応するもの(inroot)を見つける\n                  var inroot = -1L;\n                  for (var i = inl; i < inr; ++i)\n                      if (preorder[preroot] == inorder[i])\n                          inroot = i;\n                  //preでinroot+1に対応するもの(preright)を見つける\n                  var preright = preroot + (inroot - inl) + 1;\n                  //(preroot,preright)がleft、残りがright\n                  recon(preroot + 1, preright, inl, inroot);\n                  //inの[,inroot)と(preroot,preright)で同じことを繰り返す\n                  recon(preright, prer, inroot + 1, inr);\n                  //WriteLine(preorder[preroot]);\n                  ans.Add(preorder[preroot]);\n              };\n            recon(0, N, 0, N);\n            WriteLine(string.Join(\" \", ans));\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass Program\n{\n\n    public void Proc()\n    {\n        int nodeCount = int.Parse(Console.ReadLine());\n        this.PreOrderText = Console.ReadLine();\n        this.InOrderText = Console.ReadLine();\n        // testcode\n        //this.PreOrderText = \"1 2 3 4\";\n        //this.InOrderText = \"1 2 3 4\";\n        string[] prestr = this.PreOrderText.Split(' ');\n        string[] instr = this.InOrderText.Split(' ');\n\n        this.PreOrder = new int[nodeCount];\n       \n        for(int i=0; i<nodeCount; i++) {\n             this.PreOrder[i] = int.Parse(prestr[i]);\n             this.InOrder.Add(int.Parse(instr[i]));\n        }\n\n        TreeNd root = new TreeNd(this.PreOrder[0]);\n        TreeNd ansData = this.SetTree(1, root);\n        string ansText = GetPostorderText(ansData);\n        Console.WriteLine(ansText);\n    }\n\n    public string GetPostorderText(TreeNd dat)\n    {\n        if (dat == null)\n        {\n            return string.Empty;\n        }\n        StringBuilder sb = new StringBuilder();\n        if (dat.LeftChild != null)\n        {\n            string tmp = this.GetPostorderText(dat.LeftChild);\n            if (!string.IsNullOrEmpty(tmp))\n            {\n                sb.Append(tmp);\n            }\n        }\n        if (dat.RightChild != null)\n        {\n            string tmp = this.GetPostorderText(dat.RightChild);\n            if (!string.IsNullOrEmpty(tmp))\n            {\n                if (sb.Length > 0)\n                {\n                    sb.Append(\" \");\n                }\n                sb.Append(tmp);\n            }\n        }\n        if (sb.Length > 0)\n        {\n            sb.Append(\" \");\n        }\n        sb.Append(dat.NodeId);\n        return sb.ToString();\n    }\n\n    private int[] PreOrder;\n    private List<int> InOrder = new List<int>();\n\n    private String PreOrderText = string.Empty;\n    private string InOrderText = string.Empty;\n\n    private string GetInorderText(TreeNd dat)\n    {\n        StringBuilder sb = new StringBuilder();\n        string left = string.Empty;\n        if (dat.LeftChild != null)\n        {\n            left = this.GetInorderText(dat.LeftChild);\n        }\n        if (!string.IsNullOrEmpty(left))\n        {\n            sb.Append(left);\n        }\n        if (sb.Length > 0)\n        {\n            sb.Append(\" \");\n        }\n        sb.Append(dat.NodeId);\n        string right = string.Empty;\n        if (dat.RightChild != null)\n        {\n            right = this.GetInorderText(dat.RightChild);\n        }\n        if (!string.IsNullOrEmpty(right))\n        {\n            sb.Append(\" \");\n            sb.Append(right);\n        }\n        return sb.ToString();\n    }\n    private TreeNd SetTree(int idx, TreeNd root){\n        if (idx >= PreOrder.Length)\n        {\n            // ???????????????\n            string tmpAns = this.GetInorderText(root);\n            if (tmpAns.Equals(this.InOrderText))\n            {\n                return root;\n            }\n            else\n            {\n                return null;\n            }\n            \n        }\n        TreeNd ans = null;\n        TreeNd cop = (TreeNd)root.Clone();\n        TreeNd parent = cop.SearchById(this.PreOrder[idx - 1]);\n\n        while (parent != null)\n        {\n            TreeNd tmp = new TreeNd(this.PreOrder[idx]);\n\n            if (parent.LeftChild == null)\n            {\n                // ???????????´???(??????????????´??????\n                int idx1 = this.InOrder.IndexOf(this.PreOrder[idx - 1]);\n                int idx2 = this.InOrder.IndexOf(this.PreOrder[idx]);\n                if (idx2 < idx1)\n                {\n                    tmp.Parent = parent;\n                    parent.LeftChild = tmp;\n\n                    ans = SetTree(idx + 1, cop);\n                    if (ans != null)\n                    {\n                        return ans;\n                    }\n                    parent.LeftChild = null;\n                }\n            }\n            if (parent.RightChild == null)\n            {\n                // ???????????´???(??????????????´??????\n                int idx1 = this.InOrder.IndexOf(this.PreOrder[idx - 1]);\n                int idx2 = this.InOrder.IndexOf(this.PreOrder[idx]);\n                if (idx1 > idx2)\n                {\n                    tmp.Parent = parent;\n                    parent.RightChild = tmp;\n\n                    ans = SetTree(idx + 1, cop);\n                    if (ans != null)\n                    {\n                        return ans;\n                    }\n                    parent.RightChild = null;\n                }\n            }\n            parent = parent.Parent;\n        }\n\n        return ans;\n    }\n\n    public class TreeNd:ICloneable\n    {\n        public TreeNd Parent;\n        public int NodeId;\n        public TreeNd LeftChild;\n        public TreeNd RightChild;\n\n\n        public TreeNd(int nodeid)\n        {\n            this.NodeId = nodeid;\n        }\n\n        public TreeNd SearchById(int id)\n        {\n            TreeNd ret = null;\n            if (id == this.NodeId)\n            {\n                ret = this;\n            }\n            else if(this.LeftChild != null)\n            {\n                ret = this.LeftChild.SearchById(id);\n            }\n            if (ret == null && this.RightChild != null)\n            {\n                ret = this.RightChild.SearchById(id);\n            }\n            return ret;\n        }\n\n        public object Clone()\n        {\n            TreeNd tn = new TreeNd(this.NodeId);\n            if (this.LeftChild != null)\n            {\n                tn.LeftChild = (TreeNd)this.LeftChild.Clone();\n                tn.LeftChild.Parent = tn;\n            }\n            if (this.RightChild != null)\n            {\n                tn.RightChild = (TreeNd)this.RightChild.Clone();\n                tn.RightChild.Parent = tn;\n            }\n\n            return tn;\n        }\n    }\n\n\n    static void Main(string[] args)\n    {\n        Program prg = new Program();\n        prg.Proc();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Tree\n{\n    class Reconstruction_of_a_Tree\n    {\n        struct Node\n        {\n            public int id;\n            public int parent;\n            public int left, right;\n        }\n\n        static void Main(string[] args)\n        {\n            var n = int.Parse(Console.ReadLine());\n            var preorder = Console.ReadLine().Split(' ').Select(s => int.Parse(s)).ToList();\n            var inorder = Console.ReadLine().Split(' ').Select(s => int.Parse(s)).ToList();\n            var nodes = new Node[n + 1];\n\n            var root = Reconstruct(nodes, preorder, inorder);\n            Postorder(nodes, root, root);\n            Console.WriteLine();\n\n        }\n\n        static int Reconstruct(Node[] nodes, List<int> preoder, List<int> inorder)\n        {\n            var root = preoder[0];\n            nodes[root].id = root;\n            preoder.Remove(root);\n            var index = inorder.IndexOf(root);\n\n            if (index == 0)\n                nodes[root].left = -1;\n            else\n            {\n                var left = Reconstruct(nodes, preoder, inorder.GetRange(0, index));\n                nodes[root].left = left;\n                nodes[left].parent = root;\n            }\n\n            if (index == inorder.Count - 1)\n                nodes[root].right = -1;\n            else\n            {\n                var right = Reconstruct(nodes, preoder, inorder.GetRange(index + 1, inorder.Count - index - 1));\n                nodes[root].right = right;\n                nodes[right].parent = root;\n            }\n            return root;\n        }\n\n        static void Postorder(Node[] nodes, int id, int root)\n        {\n            if (id == -1) return;\n            Postorder(nodes, nodes[id].left, root);\n            Postorder(nodes, nodes[id].right, root);\n            if (id == root) Console.Write(nodes[id].id);\n            else Console.Write(nodes[id].id+\" \");\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass Program\n{\n\n    public void Proc()\n    {\n        int nodeCount = int.Parse(Console.ReadLine());\n        this.PreOrderText = Console.ReadLine();\n        this.InOrderText = Console.ReadLine();\n        // testcode\n        this.PreOrderText = \"1 2 3 4\";\n        this.InOrderText = \"1 2 3 4\";\n        string[] prestr = this.PreOrderText.Split(' ');\n        string[] instr = this.InOrderText.Split(' ');\n\n        this.PreOrder = new int[nodeCount];\n       \n        for(int i=0; i<nodeCount; i++) {\n             this.PreOrder[i] = int.Parse(prestr[i]);\n             this.InOrder.Add(int.Parse(instr[i]));\n        }\n\n        TreeNd root = new TreeNd(this.PreOrder[0]);\n        TreeNd ansData = this.SetTree(1, root);\n        string ansText = GetPostorderText(ansData);\n        Console.WriteLine(ansText);\n    }\n\n    public string GetPostorderText(TreeNd dat)\n    {\n        if (dat == null)\n        {\n            return string.Empty;\n        }\n        StringBuilder sb = new StringBuilder();\n        if (dat.LeftChild != null)\n        {\n            string tmp = this.GetPostorderText(dat.LeftChild);\n            if (!string.IsNullOrEmpty(tmp))\n            {\n                sb.Append(tmp);\n            }\n        }\n        if (dat.RightChild != null)\n        {\n            string tmp = this.GetPostorderText(dat.RightChild);\n            if (!string.IsNullOrEmpty(tmp))\n            {\n                if (sb.Length > 0)\n                {\n                    sb.Append(\" \");\n                }\n                sb.Append(tmp);\n            }\n        }\n        if (sb.Length > 0)\n        {\n            sb.Append(\" \");\n        }\n        sb.Append(dat.NodeId);\n        return sb.ToString();\n    }\n\n    private int[] PreOrder;\n    private List<int> InOrder = new List<int>();\n\n    private String PreOrderText = string.Empty;\n    private string InOrderText = string.Empty;\n\n    private string GetInorderText(TreeNd dat)\n    {\n        StringBuilder sb = new StringBuilder();\n        string left = string.Empty;\n        if (dat.LeftChild != null)\n        {\n            left = this.GetInorderText(dat.LeftChild);\n        }\n        if (!string.IsNullOrEmpty(left))\n        {\n            sb.Append(left);\n        }\n        if (sb.Length > 0)\n        {\n            sb.Append(\" \");\n        }\n        sb.Append(dat.NodeId);\n        string right = string.Empty;\n        if (dat.RightChild != null)\n        {\n            right = this.GetInorderText(dat.RightChild);\n        }\n        if (!string.IsNullOrEmpty(right))\n        {\n            sb.Append(\" \");\n            sb.Append(right);\n        }\n        return sb.ToString();\n    }\n    private TreeNd SetTree(int idx, TreeNd root){\n        if (idx >= PreOrder.Length)\n        {\n            // ???????????????\n            string tmpAns = this.GetInorderText(root);\n            if (tmpAns.Equals(this.InOrderText))\n            {\n                return root;\n            }\n            else\n            {\n                return null;\n            }\n            \n        }\n        TreeNd ans = null;\n        TreeNd cop = (TreeNd)root.Clone();\n        TreeNd parent = cop.SearchById(this.PreOrder[idx - 1]);\n\n        while (parent != null)\n        {\n            TreeNd tmp = new TreeNd(this.PreOrder[idx]);\n\n            if (parent.LeftChild == null)\n            {\n                // ???????????´???(??????????????´??????\n                tmp.Parent = parent;\n                parent.LeftChild = tmp;\n\n                ans = SetTree(idx + 1, cop);\n                if (ans != null)\n                {\n                    return ans;\n                }\n                parent.LeftChild = null;\n            }\n            if (parent.RightChild == null)\n            {\n                // ???????????´???(??????????????´??????\n                tmp.Parent = parent;\n                parent.RightChild = tmp;\n\n                ans = SetTree(idx + 1, cop);\n                if (ans != null)\n                {\n                    return ans;\n                }\n                parent.RightChild = null;\n            }\n            parent = parent.Parent;\n        }\n\n        return ans;\n    }\n\n    public class TreeNd:ICloneable\n    {\n        public TreeNd Parent;\n        public int NodeId;\n        public TreeNd LeftChild;\n        public TreeNd RightChild;\n\n\n        public TreeNd(int nodeid)\n        {\n            this.NodeId = nodeid;\n        }\n\n        public TreeNd SearchById(int id)\n        {\n            TreeNd ret = null;\n            if (id == this.NodeId)\n            {\n                ret = this;\n            }\n            else if(this.LeftChild != null)\n            {\n                ret = this.LeftChild.SearchById(id);\n            }\n            if (ret == null && this.RightChild != null)\n            {\n                ret = this.RightChild.SearchById(id);\n            }\n            return ret;\n        }\n\n        public object Clone()\n        {\n            TreeNd tn = new TreeNd(this.NodeId);\n            if (this.LeftChild != null)\n            {\n                tn.LeftChild = (TreeNd)this.LeftChild.Clone();\n                tn.LeftChild.Parent = tn;\n            }\n            if (this.RightChild != null)\n            {\n                tn.RightChild = (TreeNd)this.RightChild.Clone();\n                tn.RightChild.Parent = tn;\n            }\n\n            return tn;\n        }\n    }\n\n\n    static void Main(string[] args)\n    {\n        Program prg = new Program();\n        prg.Proc();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _20170410_AOJ_ALDS1_7D\n{\n    class ALDS1_7D\n    {\n        static void Main(string[] args)\n        {\n            for (;;)\n            {\n                string line = Console.ReadLine();\n                if (string.IsNullOrEmpty(line))\n                {\n                    break;\n                }\n\n                int n = int.Parse(line);\n\n                TreeNode[] arr = new TreeNode[n + 1];\n                TreeNode parent = null;\n                int[] ns = Console.ReadLine().Split(' ').Select(x => int.Parse(x)).ToArray();\n\n                for (int i = 0; i < n; i++)\n                {\n                    TreeNode tn = new TreeNode();\n                    tn.Id = ns[i];\n                    arr[i + 1] = tn;\n                    if (parent != null)\n                    {\n                        parent.Left = tn;\n                        tn.Parent = parent;\n                    }\n                    parent = tn;\n                }\n\n                ns = Console.ReadLine().Split(' ').Select(x => int.Parse(x)).ToArray();\n                for (int i = 1; i < n; i++)\n                {\n                    int i1 = ns[i - 1];\n                    int i2 = ns[i];\n                    TreeNode tn1 = arr[i1];\n                    TreeNode tn2 = arr[i2];\n                    if(tn2.Parent != null &&\n                        tn2.Parent != tn1 &&\n                        tn2.Left != tn1)\n                    {\n                        tn2.Parent.Left = null;\n                        tn2.Parent = tn1;\n                        tn1.Right = tn2;\n                    }\n                }\n\n                TreeNode root = arr[1].GetRoot();\n                WriteOrder(root);\n            }\n        }\n\n        static void WriteOrder(TreeNode tn)\n        {\n            List<TreeNode> list = new List<TreeNode>();\n            PostOrder(list, tn);\n            Console.WriteLine(string.Join(\" \", list.Select(x => x.Id.ToString()).ToArray()));\n        }\n\n        static void PostOrder(List<TreeNode> list, TreeNode tn)\n        {\n            if (tn.Left != null)\n            {\n                PostOrder(list, tn.Left);\n            }\n\n            if (tn.Right != null)\n            {\n                PostOrder(list, tn.Right);\n            }\n\n            list.Add(tn);\n        }\n    }\n\n    class TreeNode\n    {\n        public int Id { get; set; }\n        public TreeNode Parent { get; set; }\n        public TreeNode Left { get; set; }\n        public TreeNode Right { get; set; }\n        public int Depth { get; internal set; }\n        public int Height { get; internal set; }\n        public TreeNode()\n        {\n        }\n\n        public TreeNode GetRoot()\n        {\n            TreeNode temp = this;\n            while (temp.Parent != null)\n            {\n                temp = temp.Parent;\n            }\n\n            return temp;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace ConsoleApplication1\n{ \n    class Program\n    {\n        static int[] pre;\n        static int[] ino;\n        static int pos;\n        static List<int> pro;  //Pro\n\n        static void Solve(int l, int r)\n        {\n            if(l >= r)\n            {\n                return;\n            }           \n\n            int root = pre[pos++];         \n\n            int m = Array.IndexOf(ino, root);            \n            \n            Solve(l, m);           \n            Solve(m + 1, r);            \n            pro.Add(root);\n\n        }\n                  \n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            pre = new int[n];\n            ino = new int[n];\n\n            string[] input1 = Console.ReadLine().Split(' ');  //Pre\n            string[] input2 = Console.ReadLine().Split(' ');  //In\n\n            for(int i = 0; i < n; i++)\n            {\n                pre[i] = int.Parse(input1[i]);\n                ino[i] = int.Parse(input2[i]);\n            }\n\n            pos = 0;\n            pro = new List<int>();\n\n            Solve(0, pre.Length);\n\n            Console.WriteLine(String.Join(\" \", pro));\n\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_7_D\n{\n    class Program\n    {\n        static int pos;\n        static int[] pre, ino;\n        static List<int> post = new List<int>();\n\n        static void rec(int l, int r)\n        {\n            if (l >= r) return;\n            int root = pre[pos++];\n            int m = ino.TakeWhile(s => s != root).Count();\n            rec(l, m);\n            rec(m + 1, r);\n            post.Add(root);\n        }\n        static void Main(string[] args)\n        {\n            int n = scan[0];\n            pre = scan;\n            ino = scan;\n\n            rec(0, n);\n\n            Console.WriteLine(string.Join(\" \",post));\n        }\n\n        static int[] scan\n        {\n            get { return Console.ReadLine().Split().Select(int.Parse).ToArray(); }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace D\n{\n    public struct Node\n    {\n        public int left;\n        public int right;\n        public Tree tree;\n    }\n\n    public class Tree\n    {\n        internal Node[] nodes;\n\n        public Tree(int nodes)\n        {\n            this.nodes = new Node[nodes + 1];\n            for (int i = 1; i < nodes + 1; i++)\n            {\n                this.nodes[i].left = -1;\n                this.nodes[i].right = -1;\n                this.nodes[i].tree = this;\n            }\n        }\n\n        public void AddChilden(int id, int left, int right)\n        {\n            nodes[id].left = left;\n            nodes[id].right = right;\n        }\n\n        public void Postorder(int node,ref List<int> list)\n        {\n            if (nodes[node].left != -1) Postorder(nodes[node].left,ref list);\n            if (nodes[node].right != -1) Postorder(nodes[node].right,ref list);\n            list.Add(node);\n        }\n\n        public int Analyze(IEnumerable<int> preList, IEnumerable<int> inList)\n        {\n            if (preList.Count() == 0) return -1;\n            var node = preList.First();\n            var index = inList.ToList().IndexOf(node);\n            var left = Analyze(preList.Skip(1).Take(index), inList.Take(index));\n            var right = Analyze(preList.Skip(1 + index), inList.Skip(1 + index));\n            AddChilden(node, left, right);\n            return node;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var n = int.Parse(Console.ReadLine());\n            var preList = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            var inList = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            var tree = new Tree(n);\n            var list = new List<int>();\n            tree.Postorder(tree.Analyze(preList, inList),ref list);\n            Console.WriteLine(string.Join(\" \",list));\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_7D{\n    public class Program{\n        public static void Main(string[] args){\n            var sr = new StreamReader();\n            //---------------------------------\n            var N = sr.Next<int>();\n            var preOrder = sr.Next<int>(N);\n            var inOrder = sr.Next<int>(N);\n\n            var cnt = 0;\n            var res = new List<int>();\n\n            Action<int, int> reconstruct = null;\n            reconstruct = (l, r) =>{\n                if(cnt >= N || l >= r) return;\n                var cp = preOrder[cnt++];\n                var m = Array.FindIndex(inOrder, x => x == cp);\n\n                reconstruct(l, m);\n                reconstruct(m + 1, r);\n                res.Add(cp);\n            };\n            reconstruct(0, N);\n\n            Console.WriteLine(string.Join(\" \", res.Select(x => x.ToString()).ToArray()));\n            //---------------------------------\n        }\n    }\n\n    public class StreamReader{\n        private readonly char[] _c = {' '};\n        private int _index = -1;\n        private string[] _input = new string[0];\n\n        public T Next<T>(){\n            if(_index == _input.Length - 1){\n                _index = -1;\n                while(true){\n                    string rl = Console.ReadLine();\n                    if(rl == null){\n                        if(typeof(T).IsClass) return default(T);\n                        return (T)typeof(T).GetField(\"MinValue\").GetValue(null);\n                    }\n                    if(rl != \"\"){\n                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);\n                        break;\n                    }\n                }\n            }\n            return (T)Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);\n        }\n\n        public T[] Next<T>(int x){\n            var ret = new T[x];\n            for(var i = 0; i < x; ++i) ret[i] = Next<T>();\n            return ret;\n        }\n\n        public T[][] Next<T>(int y, int x){\n            var ret = new T[y][];\n            for(var i = 0; i < y; ++i) ret[i] = Next<T>(x);\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass Program\n{\n\n    public void Proc()\n    {\n        int nodeCount = int.Parse(Console.ReadLine());\n        string[] inpt = Console.ReadLine().Split(' ');\n        List<int> preOrder = new List<int>();\n        List<int> inOrder = new List<int>();\n        for(int i=0; i<nodeCount; i++) {\n            preOrder.Add(int.Parse(inpt[i]));\n        }\n        inpt = Console.ReadLine().Split(' ');\n        for(int i=0; i<nodeCount; i++) {\n            inOrder.Add(int.Parse(inpt[i]));\n        }\n        Dictionary<int, TreeNd> dic = new Dictionary<int, TreeNd>();\n        List<TreeNd> list = new List<TreeNd>();\n        TreeNd root = new TreeNd(preOrder[0]);\n        dic.Add(root.NodeId, root);\n        list.Add(root);\n        for (int i = 1; i < nodeCount; i++)\n        {\n            int nodeId = preOrder[i];\n            int prevId = preOrder[i - 1];\n            TreeNd prevNd = dic[prevId];\n            TreeNd newNd = null;\n            if (dic.ContainsKey(nodeId))\n            {\n                newNd = dic[nodeId];\n            }\n            else\n            {\n                newNd = new TreeNd(nodeId);\n                dic.Add(nodeId, newNd);\n                list.Add(newNd);\n            }\n            while (prevNd != null)\n            {\n                if (prevNd.Parent != null && ( prevNd.Parent.SubLeft == null || prevNd.Parent.SubRight == null))\n                {\n                    // ????????¢????????????????????????\n                    int idx = inOrder.IndexOf(nodeId);\n                    int idxSib = inOrder.IndexOf(prevId);\n                    int idxPare = inOrder.IndexOf(prevNd.Parent.NodeId);\n                    if (idxSib < idxPare && idxPare < idx)\n                    {\n                        // ????????§??????\n                        prevNd.Parent.SubLeft = prevNd;\n                        prevNd.Parent.SubRight = newNd;\n                        newNd.Parent = prevNd.Parent;\n                    }\n                }\n                if (newNd.Parent == null)\n                {\n                    int idx = inOrder.IndexOf(nodeId);\n                    int idxPare = inOrder.IndexOf(prevNd.NodeId);\n                    if (prevNd.SubLeft == null && prevNd.SubRight == null)\n                    {\n                        // ?????´????????§??????????????§\n                        if (idx < idxPare)\n                        {\n                            // ?????????\n                            newNd.Parent = prevNd;\n                            prevNd.SubLeft = newNd;\n                        }\n                    }\n                    if (newNd == null && prevNd.SubRight == null)\n                    {\n                        // ???????????§??????????????§\n                        if (idxPare < idx)\n                        {\n                            newNd.Parent = prevNd;\n                            prevNd.SubRight = newNd;\n                        }\n\n                    }\n                }\n                if (newNd.Parent == null)\n                {\n                    prevNd = prevNd.Parent;\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n        this.Output(root);\n        Console.WriteLine(this.PostOrder.ToString());\n    }\n\n    private StringBuilder PostOrder = new StringBuilder();\n    private void Output(TreeNd parent)\n    {\n        if (parent.SubLeft != null)\n        {\n            this.Output(parent.SubLeft);\n        }\n        if (parent.SubRight != null)\n        {\n            this.Output(parent.SubRight);\n        }\n        PostOrder.Append(\" \" + parent.NodeId);\n    }\n\n    public class TreeNd\n    {\n        public int NodeId = -1;\n        public TreeNd Parent = null;\n\n        public TreeNd(int id)\n        {\n            this.NodeId = id;\n        }\n\n        public TreeNd SubLeft = null;\n        public TreeNd SubRight = null;\n\n    }\n\n    static void Main(string[] args)\n    {\n        Program prg = new Program();\n        prg.Proc();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass Program\n{\n\n    public void Proc()\n    {\n        int nodeCount = int.Parse(Console.ReadLine());\n        string[] inpt = Console.ReadLine().Split(' ');\n        List<int> preOrder = new List<int>();\n        List<int> inOrder = new List<int>();\n        for(int i=0; i<nodeCount; i++) {\n            preOrder.Add(int.Parse(inpt[i]));\n        }\n        inpt = Console.ReadLine().Split(' ');\n        for(int i=0; i<nodeCount; i++) {\n            inOrder.Add(int.Parse(inpt[i]));\n        }\n        Dictionary<int, TreeNd> dic = new Dictionary<int, TreeNd>();\n        List<TreeNd> list = new List<TreeNd>();\n        TreeNd root = new TreeNd(preOrder[0]);\n        dic.Add(root.NodeId, root);\n        list.Add(root);\n        for (int i = 1; i < nodeCount; i++)\n        {\n            int nodeId = preOrder[i];\n            int prevId = preOrder[i - 1];\n            TreeNd prevNd = dic[prevId];\n            TreeNd newNd = null;\n            if (dic.ContainsKey(nodeId))\n            {\n                newNd = dic[nodeId];\n            }\n            else\n            {\n                newNd = new TreeNd(nodeId);\n                dic.Add(nodeId, newNd);\n                list.Add(newNd);\n            }\n            while (prevNd != null)\n            {\n                if (prevNd.Parent != null && ( prevNd.Parent.SubLeft == null || prevNd.Parent.SubRight == null))\n                {\n                    // ????????¢????????????????????????\n                    int idx = inOrder.IndexOf(nodeId);\n                    int idxSib = inOrder.IndexOf(prevId);\n                    int idxPare = inOrder.IndexOf(prevNd.Parent.NodeId);\n                    if (idxSib < idxPare && idxPare < idx)\n                    {\n                        // ????????§??????\n                        prevNd.Parent.SubLeft = prevNd;\n                        prevNd.Parent.SubRight = newNd;\n                        newNd.Parent = prevNd.Parent;\n                    }\n                }\n                if (newNd.Parent == null)\n                {\n                    int idx = inOrder.IndexOf(nodeId);\n                    int idxPare = inOrder.IndexOf(prevNd.NodeId);\n                    if (prevNd.SubLeft == null && prevNd.SubRight == null)\n                    {\n                        // ?????´????????§??????????????§\n                        if (idx < idxPare)\n                        {\n                            // ?????????\n                            newNd.Parent = prevNd;\n                            prevNd.SubLeft = newNd;\n                        }\n                    }\n                    if (newNd == null && prevNd.SubRight == null)\n                    {\n                        // ???????????§??????????????§\n                        if (idxPare < idx)\n                        {\n                            newNd.Parent = prevNd;\n                            prevNd.SubRight = newNd;\n                        }\n\n                    }\n                }\n                if (newNd.Parent == null)\n                {\n                    prevNd = prevNd.Parent;\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n        this.Output(root);\n        Console.WriteLine(this.PostOrder.ToString().Substring(1));\n    }\n\n    private StringBuilder PostOrder = new StringBuilder();\n    private void Output(TreeNd parent)\n    {\n        if (parent.SubLeft != null)\n        {\n            this.Output(parent.SubLeft);\n        }\n        if (parent.SubRight != null)\n        {\n            this.Output(parent.SubRight);\n        }\n        PostOrder.Append(\" \" + parent.NodeId);\n    }\n\n    public class TreeNd\n    {\n        public int NodeId = -1;\n        public TreeNd Parent = null;\n\n        public TreeNd(int id)\n        {\n            this.NodeId = id;\n        }\n\n        public TreeNd SubLeft = null;\n        public TreeNd SubRight = null;\n\n    }\n\n    static void Main(string[] args)\n    {\n        Program prg = new Program();\n        prg.Proc();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing static System.Math;\npublic static class P\n{\n    public static void Main()\n    {\n        int n = int.Parse(Console.ReadLine());\n        var preOrder = Console.ReadLine().Split().Select(int.Parse).ToArray();\n        var inOrder = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\n        Console.WriteLine(string.Join(\" \", Reproduce(preOrder, inOrder)));\n    }\n\n    static IEnumerable<int> Reproduce(int[] preOrder, int[] inOrder)\n    {\n        if (preOrder.Length == 0) return Enumerable.Empty<int>();\n        var root = preOrder[0];\n        var lCount = Array.IndexOf(inOrder, root);\n        var l = Reproduce(\n                preOrder.Skip(1).Take(lCount).ToArray(),\n                inOrder.Take(lCount).ToArray()\n            ).ToArray();\n        var r = Reproduce(\n                preOrder.Skip(1 + lCount).ToArray(),\n                inOrder.Skip(lCount + 1).ToArray()\n            ).ToArray();\n        return l.Concat(r).Concat(new int[] { root });\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static int[] preorder;\n        static int[] inorder;\n\n        static List<int> postorder = new List<int>();\n        static int pos = 0;\n\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            preorder = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            inorder = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n            Reconstruct(0, n);\n\n            Console.WriteLine(string.Join(\" \", Array.ConvertAll(postorder.ToArray(), p => p.ToString())));\n        }\n\n        static void Reconstruct(int left, int right)\n        {\n            if (left >= right) return;\n\n            int root = preorder[pos++];\n            int m = Array.IndexOf(inorder, root);\n\n            Reconstruct(left, m);\n            Reconstruct(m + 1, right);\n\n            postorder.Add(root);\n        }\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "class BinaryTree {\n  constructor(n) {\n    this.nodes = [];\n    for (let i = 0; i < n; i++) this.nodes[i] = {id: i + 1, parentId: -1, leftId: -1, rightId: -1}\n  }\n\n  get root() { return this.nodes.find(n => n.parentId === -1); }\n\n  find(id) { return this.nodes[id - 1] || {}; }\n\n  getByPostorder() {\n    let res = [];\n    const postorder = (id) => {\n      if (id === -1) return;\n      let n = this.find(id);\n      postorder(n.leftId);\n      postorder(n.rightId);\n      res.push(id);\n    };\n    postorder(this.root.id);\n    return res;\n  }\n}\n\n(function main(){\n  const lines = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n  const n = Number(lines.shift());\n  const preOrder = lines.shift().split(' ').map(Number);\n  const inOrder = lines.shift().split(' ').map(Number);\n\n  let tree = makeTree(preOrder, inOrder);\n  console.log(tree.getByPostorder().join(' '));\n})();\n\nfunction makeTree(preOrder, inOrder) {\n  let tree = new BinaryTree(preOrder.length);\n  const innerMakeTree = (p, i) => {\n    let midId = p[0];\n    let midIdx = i.indexOf(midId);\n    if (midIdx === -1) return;\n    if (midIdx > 0) {\n      tree.find(midId).leftId = p[1];\n      tree.find(p[1]).parentId = midId;\n      innerMakeTree(p.slice(1, midIdx + 1), i.slice(0, midIdx))\n    }\n    if (midIdx < i.length - 1) {\n      tree.find(midId).rightId = p[midIdx + 1];\n      tree.find(p[midIdx + 1]).parentId = midId;\n      innerMakeTree(p.slice(midIdx + 1), i.slice(midIdx + 1))\n    }\n  }\n  innerMakeTree(preOrder, inOrder);\n  return tree;\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "\n"
  },
  {
    "language": "JavaScript",
    "code": "class BinaryTree {\n  constructor(n) {\n    this.nodes = [];\n    for (let i = 0; i < n; i++) this.nodes[i] = {id: i + 1, parentId: -1, leftId: -1, rightId: -1}\n  }\n\n  get root() { return this.nodes.find(n => n.parentId === -1); }\n\n  find(id) { return this.nodes[id - 1]; }\n\n  getByPostorder() {\n    let res = [];\n    const postorder = (id) => {\n      if (id === -1) return;\n      let n = this.find(id);\n      postorder(n.leftId);\n      postorder(n.rightId);\n      res.push(id);\n    };\n    postorder(this.root.id);\n    return res;\n  }\n}\n\n(function main(){\n  const lines = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n  const n = Number(lines.shift());\n  const preOrder = lines.shift().split(' ').map(Number);\n  const inOrder = lines.shift().split(' ').map(Number);\n\n  let tree = makeTree(preOrder, inOrder);\n  console.log(tree.getByPostorder().join(' '));\n})();\n\nfunction makeTree(preOrder, inOrder) {\n  let tree = new BinaryTree(preOrder.length);\n  const innerMakeTree = (p, i) => {\n    let midId = p[0];\n    let midIdx = i.indexOf(midId);\n    if (midIdx > 0) {\n      tree.find(midId).leftId = p[1];\n      tree.find(p[1]).parentId = midId;\n      innerMakeTree(p.slice(1, midIdx + 1), i.slice(0, midIdx))\n    }\n    if (midIdx < i.length - 1) {\n      tree.find(midId).rightId = p[midIdx + 1];\n      tree.find(p[midIdx + 1]).parentId = midId;\n      innerMakeTree(p.slice(midIdx + 1), i.slice(midIdx + 1))\n    }\n  }\n  innerMakeTree(preOrder, inOrder);\n  return tree;\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class ALDS1_7_D {\n    static Scanner sc = new Scanner(System.in);\n    static int n, pos;\n    static ArrayList<Integer> preorder = new ArrayList<Integer>();\n    static ArrayList<Integer> inorder = new ArrayList<Integer>();\n\n    public static BinaryTree reconstruction(int l, int r) {\n        if (l >= r) {\n            return new BinaryTree();\n        }\n\n        int node = preorder.get(pos++);\n        int i = inorder.indexOf(node);\n\n        BinaryTree left = reconstruction(l, i);\n        BinaryTree right = reconstruction(i + 1, r);\n\n        return new BinaryTree(node, left, right);\n    }\n\n    public static void read() {\n        n = sc.nextInt();\n        for (int i = 0; i < n; i++) {\n            preorder.add(sc.nextInt());\n        }\n        for (int i = 0; i < n; i++) {\n            inorder.add(sc.nextInt());\n        }\n    }\n\n    public static void main(String[] args) {\n        read();\n        pos = 0;\n        BinaryTree bt = reconstruction(0, preorder.size());\n        System.out.println(bt);\n    }\n\n    public static class BinaryTree {\n        boolean isEmpty;\n        int node;\n        BinaryTree left;\n        BinaryTree right;\n\n        public BinaryTree(int node, BinaryTree left, BinaryTree right) {\n            this.isEmpty = false;\n            this.node = node;\n            this.left = left;\n            this.right = right;\n        }\n\n        public BinaryTree() {\n            this.isEmpty = true;\n        }\n\n        public String toString() {\n            if (this.isEmpty) return \"\";\n            String l = this.left.toString() + \" \";\n            String r = this.right.toString() + \" \";\n\n            if (l.trim().equals(\"\")) {\n                l = \"\";\n            }\n            if (r.trim().equals(\"\")) {\n                r = \"\";\n            }\n\n            return l + r + this.node;\n        }\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "class BinaryTree {\n  constructor(n) {\n    this.nodes = [];\n    for (let i = 0; i < n; i++) this.nodes[i] = {id: i + 1, parentId: -1, leftId: -1, rightId: -1}\n  }\n\n  get root() { return this.nodes.find(n => n.parentId === -1); }\n\n  add(id, leftId, rightId) {\n    let n = this.find(id);\n    [n.leftId, n.rightId] = [leftId, rightId];\n    if (leftId !== -1) this.find(leftId).parentId = id;\n    if (rightId !== -1) this.find(rightId).parentId = id;\n  }\n\n  find(id) { return this.nodes[id - 1]; }\n\n  getByPostorder() {\n    let res = [];\n    const postorder = (id) => {\n      if (id === -1) return;\n      let n = this.find(id);\n      postorder(n.leftId);\n      postorder(n.rightId);\n      res.push(id);\n    };\n    postorder(this.root.id);\n    return res;\n  }\n}\n\n(function main(){\n  const lines = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n  const n = Number(lines.shift());\n  const preOrder = lines.shift().split(' ').map(Number);\n  const inOrder = lines.shift().split(' ').map(Number);\n\n  let tree = makeTree(preOrder, inOrder);\n  console.log(tree.getByPostorder().join(' '));\n})();\n\nfunction makeTree(preOrder, inOrder) {\n  let tree = new BinaryTree(preOrder.length);\n  const f = (p, i) => {\n    let rootId = p[0];\n    let rootIdx = i.indexOf(rootId);\n    if (rootIdx === -1) return i[0] || -1;\n    tree.add(rootId, f(p.slice(1), i.slice(0, rootIdx)), f(p.slice(1), i.slice(rootIdx + 1)));\n    return rootId;\n  }\n  f(preOrder, inOrder);\n  return tree;\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "function main(_stdin){\n    const stdin = _stdin.split('\\n');\n    const len = parseInt(stdin.shift(), 10);\n    const proRes = stdin.shift().split(' ').map(e => parseInt(e, 10));\n    const inoRes = stdin.shift().split(' ').map(e => parseInt(e, 10));\n\n    const data = [];\n    const walked = [];\n    for(let i=0;i<len+1;i++){\n        if(i === 0) data[i] = 0;\n        data[i] = [i, -1, -1];\n    }\n\n    setData(0, proRes, inoRes, data);\n    const rootidx = proRes[0];\n\n    outParse(data, rootidx, walked);\n    console.log(walked.join(' '));\n}\n\nfunction setData(proInd, prores, targets, data){\n    const nodeId = prores[proInd];\n    const d = data[nodeId];\n    if(targets.length === 1){\n        d[1] = -1;\n        d[2] = -1;\n        return;\n    }\n    let splita;\n    for(let i=0,l=targets.length;i<l;i++){\n        if(targets[i] === nodeId) splita = i;\n    }\n    const left = targets.slice(0, splita);\n    const right = targets.slice(splita+1);\n\n    if(left.length){\n        const leftPro = prores.filter(e => left.indexOf(e) > -1);\n        d[1] = leftPro[0];\n        const index = prores.indexOf(d[1]);\n        setData(index, prores, left, data);\n    } else {\n        d[1] = -1;\n    }\n\n    if(right.length){\n        const rightPro = prores.filter(e => right.indexOf(e) > -1);\n        d[2] = rightPro[0];\n        const index = prores.indexOf(d[2]);\n        setData(index, prores, right, data);\n    } else {\n        d[2] = -1;\n    }\n}\n\nfunction outParse(inputs, idx, walked) {\n    if(idx === -1){\n        return;\n    }\n    outParse(inputs, inputs[idx][1], walked);\n    outParse(inputs, inputs[idx][2], walked);\n\n    walked.push(inputs[idx][0]);\n}\n\n\nmain(require('fs').readFileSync('/dev/stdin', 'utf8'));\n\n"
  },
  {
    "language": "JavaScript",
    "code": "class BinaryTree {\n  constructor(n) {\n    this.nodes = [];\n    for (let i = 0; i < n; i++) this.nodes[i] = {id: i + 1, parentId: -1, leftId: -1, rightId: -1}\n  }\n\n  get root() { return this.nodes.find(n => n.parentId === -1); }\n\n  add(id, leftId, rightId) {\n    let n = this.find(id);\n    [n.leftId, n.rightId] = [leftId, rightId];\n    if (leftId !== -1) this.find(leftId).parentId = id;\n    if (rightId !== -1) this.find(rightId).parentId = id;\n  }\n\n  find(id) { return this.nodes[id - 1]; }\n\n  getByPostorder() {\n    let res = [];\n    const postorder = (id) => {\n      if (id === -1) return;\n      let n = this.find(id);\n      postorder(n.leftId);\n      postorder(n.rightId);\n      res.push(id);\n    };\n    postorder(this.root.id);\n    return res;\n  }\n}\n\n(function main(){\n  const lines = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n  const n = Number(lines.shift());\n  const preOrder = lines.shift().split(' ').map(Number);\n  const inOrder = lines.shift().split(' ').map(Number);\n\n  let tree = makeTree(preOrder, inOrder);\n  console.log(tree.getByPostorder().join(' '));\n})();\n\nfunction makeTree(preOrder, inOrder) {\n  let tree = new BinaryTree(preOrder.length);\n  const func = (p, i) => {\n    let rootId = p[0];\n    let idx, rootIdx;\n    for (idx = 0; idx < p.length; idx++) if ((rootIdx = i.indexOf(rootId)) !== -1) break;\n    if (rootIdx === -1 || i.length <= 1) return i[0] || -1;\n    let leftIds = i.slice(0, rootIdx);\n    let rightIds = i.slice(rootIdx + 1);\n    // console.log(p, i, leftIds, rightIds);\n    tree.add(rootId, func(p.slice(1), leftIds), func(p.slice(1), rightIds));\n    return rootId;\n  }\n  func(preOrder, inOrder);\n  return tree;\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "class BinaryTree {\n  constructor(n) {\n    this.nodes = [];\n    for (let i = 0; i < n; i++) this.nodes[i] = {id: i + 1, parentId: -1, leftId: -1, rightId: -1}\n  }\n\n  get root() { return this.nodes.find(n => n.parentId === -1); }\n\n  find(id) { return this.nodes[id - 1] || {}; }\n\n  getByPostorder() {\n    let res = [];\n    const postorder = (id) => {\n      if (id === -1) return;\n      let n = this.find(id);\n      postorder(n.leftId);\n      postorder(n.rightId);\n      res.push(id);\n    };\n    postorder(this.root.id);\n    return res;\n  }\n}\n\n(function main(){\n  const lines = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n  const n = Number(lines.shift());\n  const preOrder = lines.shift().split(' ').map(Number);\n  const inOrder = lines.shift().split(' ').map(Number);\n\n  let tree = makeTree(preOrder, inOrder);\n  console.log(tree.getByPostorder().join(' '));\n})();\n\nfunction makeTree(preOrder, inOrder) {\n  let tree = new BinaryTree(preOrder.length);\n  const innerMakeTree = (p, i) => {\n    let midId = p[0];\n    let midIdx = i.indexOf(midId);\n    if (midIdx === -1) return;\n    if (midIdx > 0) {\n      tree.find(midId).leftId = p[1];\n      tree.find(p[1]).parentId = midId;\n      innerMakeTree(p.slice(1, midIdx + 1), i.slice(0, midIdx))\n    }\n    if (midIdx < i.length - 1) {\n      tree.find(midId).rightId = p[midIdx + 1];\n      tree.find(p[midIdx + 1]).parentId = midId;\n      innerMakeTree(p.slice(midIdx + 1), i.slice(midIdx + 1))\n    }\n  }\n  innerMakeTree(preOrder, inOrder);\n  return tree;\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "class BinaryTree {\n  constructor(n) {\n    this.nodes = [];\n    for (let i = 0; i < n; i++) this.nodes[i] = {id: i + 1, parentId: -1, leftId: -1, rightId: -1}\n  }\n\n  get root() { return this.nodes.find(n => n.parentId === -1); }\n\n  find(id) { return this.nodes[id - 1] || {}; }\n\n  getByPostorder() {\n    let res = [];\n    const postorder = (id) => {\n      if (id === -1) return;\n      let n = this.find(id);\n      postorder(n.leftId);\n      postorder(n.rightId);\n      res.push(id);\n    };\n    postorder(this.root.id);\n    return res;\n  }\n}\n\n(function main(){\n  const lines = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n  const n = Number(lines.shift());\n  const preOrder = lines.shift().split(' ').map(Number);\n  const inOrder = lines.shift().split(' ').map(Number);\n\n  let tree = makeTree(preOrder, inOrder);\n  console.log(tree.getByPostorder().join(' '));\n})();\n\nfunction makeTree(preOrder, inOrder) {\n  let tree = new BinaryTree(preOrder.length);\n  const innerMakeTree = (p, i) => {\n    let midId = p[0];\n    let midIdx = i.indexOf(midId);\n    if (midIdx === -1) return;\n    if (midIdx > 0) {\n      tree.find(midId).leftId = p[1];\n      tree.find(p[1]).parentId = midId;\n      innerMakeTree(p.slice(1, midIdx + 1), i.slice(0, midIdx))\n    }\n    if (midIdx < i.length - 1) {\n      tree.find(midId).rightId = p[midIdx + 1];\n      tree.find(p[midIdx + 1]).parentId = midId;\n      innerMakeTree(p.slice(midIdx + 1), i.slice(midIdx + 1))\n    }\n  }\n  innerMakeTree(preOrder, inOrder);\n  return tree;\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "class BinaryTree {\n  constructor(n) {\n    this.nodes = [];\n    for (let i = 0; i < n; i++) this.nodes[i] = {id: i + 1, parentId: -1, leftId: -1, rightId: -1}\n  }\n\n  get root() { return this.nodes.find(n => n.parentId === -1); }\n\n  add(id, leftId, rightId) {\n    let n = this.find(id);\n    [n.leftId, n.rightId] = [leftId, rightId];\n    if (leftId !== -1) this.find(leftId).parentId = id;\n    if (rightId !== -1) this.find(rightId).parentId = id;\n  }\n\n  find(id) { return this.nodes[id - 1]; }\n\n  getByPostorder() {\n    let res = [];\n    const postorder = (id) => {\n      if (id === -1) return;\n      let n = this.find(id);\n      this.postorder(n.leftId);\n      this.postorder(n.rightId);\n      res.push(id);\n    };\n    postorder(this.root.id);\n    return res;\n  }\n}\n\n(function main(){\n  const lines = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n  const n = Number(lines.shift());\n  const preOrder = lines.shift().split(' ').map(Number);\n  const inOrder = lines.shift().split(' ').map(Number);\n\n  let tree = makeTree(preOrder, inOrder);\n  console.log(tree.getByPostorder().join(' '));\n})();\n\nfunction makeTree(preOrder, inOrder) {\n  let tree = new BinaryTree(preOrder.length);\n  const f = (p, i) => {\n    let rootId = p[0];\n    let rootIdx = i.indexOf(rootId);\n    if (rootIdx === -1) return i[0] || -1;\n    tree.add(rootId, f(p.slice(1), i.slice(0, rootIdx)), f(p.slice(1), i.slice(rootIdx + 1)));\n    return rootId;\n  }\n  f(preOrder, inOrder);\n  return tree;\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "class BinaryTree {\n  constructor(n) {\n    this.nodes = [];\n    for (let i = 0; i < n; i++) this.nodes[i] = {id: i + 1, parentId: -1, leftId: -1, rightId: -1}\n  }\n\n  get root() { return this.nodes.find(n => n.parentId === -1); }\n\n  add(id, leftId, rightId) {\n    let n = this.find(id);\n    [n.leftId, n.rightId] = [leftId, rightId];\n    if (leftId !== -1) this.find(leftId).parentId = id;\n    if (rightId !== -1) this.find(rightId).parentId = id;\n  }\n\n  find(id) { return this.nodes[id - 1]; }\n\n  getByPostorder() {\n    let res = [];\n    const postorder = (id) => {\n      if (id === -1) return;\n      let n = this.find(id);\n      postorder(n.leftId);\n      postorder(n.rightId);\n      res.push(id);\n    };\n    postorder(this.root.id);\n    return res;\n  }\n}\n\n(function main(){\n  const lines = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n  const n = Number(lines.shift());\n  const preOrder = lines.shift().split(' ').map(Number);\n  const inOrder = lines.shift().split(' ').map(Number);\n\n  let tree = makeTree(preOrder, inOrder);\n  console.log(tree.getByPostorder().join(' '));\n})();\n\nfunction makeTree(preOrder, inOrder) {\n  let tree = new BinaryTree(preOrder.length);\n  const func = (p, i) => {\n    let rootId = p[0];\n    let idx, rootIdx;\n    for (idx = 0; idx < p.length; idx++) if ((rootIdx = i.indexOf(rootId)) !== -1) break;\n    if (rootIdx === -1 && i.length <= 1) return i[0] || -1;\n    let leftIds = i.slice(0, rootIdx);\n    let rightIds = i.slice(rootIdx + 1);\n    // console.log(p, i, leftIds, rightIds);\n    tree.add(rootId, func(p.slice(1), leftIds), func(p.slice(1), rightIds));\n    return rootId;\n  }\n  func(preOrder, inOrder);\n  return tree;\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "//config = { input: 'tmp', newline: '\\r\\n' }; // win\nconfig = { input: '/dev/stdin', newline: '\\n' }; // linux\n\nline = require('fs').readFileSync(config.input, 'ascii')\n  .split(config.newline, 3);\n\npreorder = line[1].split(' ');\ninorder = line[2].split(' ');\n\ntree = {};\n\nfunction decode(preorder, inorder) {\n  var id, idx_in, in_left, in_right, pre_left, pre_right, left, right;\n  id = preorder[0];\n  idx_in = inorder.indexOf(id);\n  in_left = inorder.slice(0, idx_in + 1);\n  in_right = inorder.slice(idx_in + 1);\n  pre_left = preorder.slice(1, idx_in + 1);\n  pre_right = preorder.slice(idx_in + 1);\n  if (pre_left.length === 0) left = null;\n  else left = decode(pre_left, in_left);\n  if (pre_right.length === 0) right = null;\n  else right = decode(pre_right, in_right);\n  tree[id] = {'left': left, 'right': right};\n  return id;\n}\n\ndecode(preorder, inorder);\nroot_id = preorder[0];\n\nfunction postorder(id) {\n  var node = tree[id], res = [];\n  if (node.left !== null) res = res.concat(postorder(node.left));\n  if (node.right !== null) res = res.concat(postorder(node.right));\n  res.push(id);\n  return res;\n}\n\nconsole.log(postorder(root_id).join(' '));"
  },
  {
    "language": "JavaScript",
    "code": "class BinaryTree {\n  constructor(n) {\n    this.nodes = [];\n    for (let i = 0; i < n; i++) this.nodes[i] = {id: i + 1, parentId: -1, leftId: -1, rightId: -1}\n  }\n\n  get root() { return this.nodes.find(n => n.parentId === -1); }\n\n  add(id, leftId, rightId) {\n    let n = this.find(id);\n    [n.leftId, n.rightId] = [leftId, rightId];\n    if (leftId !== -1) this.find(leftId).parentId = id;\n    if (rightId !== -1) this.find(rightId).parentId = id;\n  }\n\n  find(id) { return this.nodes[id - 1]; }\n\n  getByPostorder() {\n    let res = [];\n    const postorder = (id) => {\n      if (id === -1) return;\n      let n = this.find(id);\n      postorder(n.leftId);\n      postorder(n.rightId);\n      res.push(id);\n    };\n    postorder(this.root.id);\n    return res;\n  }\n}\n\n(function main(){\n  const lines = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n  const n = Number(lines.shift());\n  const preOrder = lines.shift().split(' ').map(Number);\n  const inOrder = lines.shift().split(' ').map(Number);\n\n  let tree = makeTree(preOrder, inOrder);\n \n  console.log(tree.getByPostorder().join(' '));\n})();\n\nfunction makeTree(preOrder, inOrder) {\n  let tree = new BinaryTree(preOrder.length);\n  const func = (p, i) => {\n    let rootId = p.shift();\n    let idx, rootIdx = i.indexOf(rootId);\n    if (rootIdx === -1 || i.length <= 1) return i[0] || -1;\n    let leftIds = i.slice(0, rootIdx);\n    let rightIds = i.slice(rootIdx + 1);\n    tree.add(rootId, func(p, leftIds), func(p, rightIds));\n    return rootId;\n  }\n  func(preOrder, inOrder);\n  return tree;\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "class BinaryTree {\n  constructor(n) {\n    this.nodes = [];\n    for (let i = 0; i < n; i++) this.nodes[i] = {id: i + 1, parentId: -1, leftId: -1, rightId: -1}\n  }\n\n  get root() { return this.nodes.find(n => n.parentId === -1); }\n\n  find(id) { return this.nodes[id - 1] || {}; }\n\n  getByPostorder() {\n    let res = [];\n    const postorder = (id) => {\n      if (id === -1) return;\n      let n = this.find(id);\n      postorder(n.leftId);\n      postorder(n.rightId);\n      res.push(id);\n    };\n    postorder(this.root.id);\n    return res;\n  }\n}\n\n(function main(){\n  const lines = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n  const n = Number(lines.shift());\n  const preOrder = lines.shift().split(' ').map(Number);\n  const inOrder = lines.shift().split(' ').map(Number);\n\n  let tree = makeTree(preOrder, inOrder);\n  console.log(tree.getByPostorder().join(' '));\n})();\n\nfunction makeTree(preOrder, inOrder) {\n  let tree = new BinaryTree(preOrder.length);\n  const func = (const p, const i) => {\n    let midId = p[0];\n    let midIdx = i.indexOf(midId);\n    if (midIdx === -1) return;\n    if (midIdx > 0) {\n      tree.find(midId).leftId = p[1];\n      tree.find(p[1]).parentId = midId;\n      func(p.slice(1, midIdx + 1), i.slice(0, midIdx))\n    }\n    if (midIdx < i.length - 1) {\n      tree.find(midId).rightId = p[midIdx + 1];\n      tree.find(p[midIdx + 1]).parentId = midId;\n      func(p.slice(midIdx + 1), i.slice(midIdx + 1))\n    }\n  }\n  func(preOrder, inOrder);\n  return tree;\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "class BinaryTree {\n  constructor(n) {\n    this.nodes = [];\n    for (let i = 0; i < n; i++) this.nodes[i] = {id: i + 1, parentId: -1, leftId: -1, rightId: -1}\n  }\n\n  get root() { return this.nodes.find(n => n.parentId === -1); }\n\n  find(id) { return this.nodes[id - 1] || {}; }\n\n  printByPostorder() {\n    let str = '';\n    const postorder = (id) => {\n      if (id === -1) return;\n      let n = this.find(id);\n      postorder(n.leftId);\n      postorder(n.rightId);\n      str += `${id} `;\n    };\n    postorder(this.root.id);\n    console.log(str.substr(0, str.length - 1));\n  }\n}\n\n(function main(){\n  const lines = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n  const n = Number(lines.shift());\n  const preOrder = lines.shift().split(' ').map(Number);\n  const inOrder = lines.shift().split(' ').map(Number);\n\n  let tree = makeTree(preOrder, inOrder);\n  tree.printByPostorder();\n})();\n\nfunction makeTree(preOrder, inOrder) {\n  let tree = new BinaryTree(preOrder.length);\n  const innerMakeTree = (p, i) => {\n    let midId = p[0];\n    let midIdx = i.indexOf(midId);\n    if (midIdx === -1) return;\n    if (midIdx > 0) {\n      tree.find(midId).leftId = p[1];\n      tree.find(p[1]).parentId = midId;\n      innerMakeTree(p.slice(1, midIdx + 1), i.slice(0, midIdx))\n    }\n    if (midIdx < i.length - 1) {\n      tree.find(midId).rightId = p[midIdx + 1];\n      tree.find(p[midIdx + 1]).parentId = midId;\n      innerMakeTree(p.slice(midIdx + 1), i.slice(midIdx + 1))\n    }\n  }\n  innerMakeTree(preOrder, inOrder);\n  return tree;\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "class BinaryTree {\n  constructor(n) {\n    this.nodes = [];\n    for (let i = 0; i < n; i++) this.nodes[i] = {id: i + 1, parentId: -1, leftId: -1, rightId: -1}\n  }\n\n  get root() { return this.nodes.find(n => n.parentId === -1); }\n\n  add(id, leftId, rightId) {\n    let n = this.find(id);\n    [n.leftId, n.rightId] = [leftId, rightId];\n    if (leftId !== -1) this.find(leftId).parentId = id;\n    if (rightId !== -1) this.find(rightId).parentId = id;\n  }\n\n  find(id) { return this.nodes[id - 1] || {}; }\n\n  getByPostorder() {\n    let res = [];\n    const postorder = (id) => {\n      if (id === -1) return;\n      let n = this.find(id);\n      postorder(n.leftId);\n      postorder(n.rightId);\n      res.push(id);\n    };\n    postorder(this.root.id);\n    return res;\n  }\n}\n\n(function main(){\n  const lines = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n  const n = Number(lines.shift());\n  const preOrder = lines.shift().split(' ').map(Number);\n  const inOrder = lines.shift().split(' ').map(Number);\n\n  let tree = makeTree(preOrder, inOrder);\n  console.log(tree.getByPostorder().join(' '));\n})();\n\nfunction makeTree(preOrder, inOrder) {\n  let tree = new BinaryTree(preOrder.length);\n  const func = (p, i) => {\n    let midId = p[0];\n    let midIdx = i.indexOf(midId);\n    if (midIdx === -1) return;\n    if (midIdx > 0) {\n      tree.find(midId).leftId = p[1];\n      tree.find(p[1]).parentId = midId;\n      func(p.slice(1, midIdx + 1), i.slice(0, midIdx))\n    }\n    if (midIdx < i.length - 1) {\n      tree.find(midId).rightId = p[midIdx + 1];\n      tree.find(p[midIdx + 1]).parentId = midId;\n      func(p.slice(midIdx + 1), i.slice(midIdx + 1))\n    }\n  }\n\n  func(preOrder, inOrder);\n  return tree;\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "class BinaryTree {\n  constructor(n) {\n    this.nodes = [];\n    for (let i = 0; i < n; i++) this.nodes[i] = {id: i + 1, parentId: -1, leftId: -1, rightId: -1}\n  }\n\n  get root() { return this.nodes.find(n => n.parentId === -1); }\n\n  find(id) { return this.nodes[id - 1]; }\n\n  getByPostorder() {\n    let res = [];\n    const postorder = (id) => {\n      if (id === -1) return;\n      let n = this.find(id);\n      postorder(n.leftId);\n      postorder(n.rightId);\n      res.push(id);\n    };\n    postorder(this.root.id);\n    return res;\n  }\n}\n\n(function main(){\n  const lines = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n  const n = Number(lines.shift());\n  const preOrder = lines.shift().split(' ').map(Number);\n  const inOrder = lines.shift().split(' ').map(Number);\n\n  let tree = makeTree(preOrder, inOrder);\n  console.log(tree.getByPostorder().join(' '));\n})();\n\nfunction makeTree(preOrder, inOrder) {\n  let tree = new BinaryTree(preOrder.length);\n  const innerMakeTree = (p, i) => {\n    let midId = p[0];\n    let midIdx = i.indexOf(midId);\n    if (midIdx > 0) {\n      tree.find(midId).leftId = p[1];\n      tree.find(p[1]).parentId = midId;\n      innerMakeTree(p.slice(1, midIdx + 1), i.slice(0, midIdx))\n    }\n    if (midIdx < i.length - 1) {\n      tree.find(midId).rightId = p[midIdx + 1];\n      tree.find(p[midIdx + 1]).parentId = midId;\n      innerMakeTree(p.slice(midIdx + 1), i.slice(midIdx + 1))\n    }\n  }\n  innerMakeTree(preOrder, inOrder);\n  return tree;\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "class BinaryTree {\n  constructor(n) {\n    this.nodes = [];\n    for (let i = 0; i < n; i++) this.nodes[i] = {id: i + 1, parentId: -1, leftId: -1, rightId: -1}\n  }\n\n  get root() { return this.nodes.find(n => n.parentId === -1); }\n\n  add(id, leftId, rightId) {\n    let n = this.find(id);\n    [n.leftId, n.rightId] = [leftId, rightId];\n    if (leftId !== -1) this.find(leftId).parentId = id;\n    if (rightId !== -1) this.find(rightId).parentId = id;\n  }\n\n  find(id) { return this.nodes[id - 1]; }\n\n  getByPostorder() {\n    let res = [];\n    const postorder = (id) => {\n      if (id === -1) return;\n      let n = this.find(id);\n      postorder(n.leftId);\n      postorder(n.rightId);\n      res.push(id);\n    };\n    postorder(this.root.id);\n    return res;\n  }\n}\n\n(function main(){\n  const lines = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n  const n = Number(lines.shift());\n  const preOrder = lines.shift().split(' ').map(Number);\n  const inOrder = lines.shift().split(' ').map(Number);\n\n  let tree = makeTree(preOrder, inOrder);\n  console.log(tree.getByPostorder().join(' '));\n})();\n\nfunction makeTree(preOrder, inOrder) {\n  let tree = new BinaryTree(preOrder.length);\n  const func = (p, i) => {\n    let rootId = p.shift();\n    let idx, rootIdx = i.indexOf(rootId);\n    if (rootIdx === -1 || i.length <= 1) return i[0] || -1;\n    let leftIds = i.slice(0, rootIdx);\n    let rightIds = i.slice(rootIdx + 1);\n    tree.add(rootId, func(p, leftIds), func(p, rightIds));\n    return rootId;\n  }\n  func(preOrder, inOrder);\n  return tree;\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "class BinaryTree {\n  constructor(n) {\n    this.nodes = [];\n    for (let i = 0; i < n; i++) this.nodes[i] = {id: i + 1, parentId: -1, leftId: -1, rightId: -1}\n  }\n\n  get root() { return this.nodes.find(n => n.parentId === -1); }\n\n  find(id) { return this.nodes[id - 1] || {}; }\n\n  getByPostorder() {\n    let res = [];\n    const postorder = (id) => {\n      if (id === -1) return;\n      let n = this.find(id);\n      postorder(n.leftId);\n      postorder(n.rightId);\n      res.push(id);\n    };\n    postorder(this.root.id);\n    return res;\n  }\n}\n\n(function main(){\n  const lines = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n  const n = Number(lines.shift());\n  const preOrder = lines.shift().split(' ').map(Number);\n  const inOrder = lines.shift().split(' ').map(Number);\n\n  let tree = makeTree(preOrder, inOrder);\n  console.log(tree.getByPostorder().join(' '));\n})();\n\nfunction makeTree(preOrder, inOrder) {\n  let tree = new BinaryTree(preOrder.length);\n  const innerMakeTree = (p, i) => {\n    let midId = p[0];\n    let midIdx = i.indexOf(midId);\n    if (midIdx === -1) return;\n    if (midIdx > 0) {\n      tree.find(midId).leftId = p[1];\n      tree.find(p[1]).parentId = midId;\n      innerMakeTree(p.slice(1, midIdx + 1), i.slice(0, midIdx))\n    }\n    if (midIdx < i.length - 1) {\n      tree.find(midId).rightId = p[midIdx + 1];\n      tree.find(p[midIdx + 1]).parentId = midId;\n      innerMakeTree(p.slice(midIdx + 1), i.slice(midIdx + 1))\n    }\n  }\n  innerMakeTree(preOrder, inOrder);\n  return tree;\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "class Node\n  def initialize(id)\n    @id = id\n    @left = nil \n    @right = nil\n  end\n\n  attr_accessor :id, :left, :right\nend\n\ndef reconstruct_visit(node, index, lefts, rights)\n  direct_left = compare_by_preorder(lefts)\n  direct_right = compare_by_preorder(rights)\n  if direct_left >= 0 then\n    node.left = Node.new(direct_left)\n    left_index = lefts.index(direct_left)\n    reconstruct_visit(node.left, \n          direct_left,\n          lefts[0...left_index], \n          lefts[left_index+1..-1])\n  end\n  if direct_right >= 0 then\n    node.right = Node.new(direct_right)\n    right_index = rights.index(direct_right)\n    reconstruct_visit(node.right, \n          direct_right,\n          rights[0...right_index], \n          rights[right_index+1..-1])\n  end\nend\n\ndef compare_by_preorder(array)\n  return -1 if array.size == 0\n  ordered_array = array.map do |item|\n    [item, $preorder.index(item)]\n  end\n  ordered_array.sort! {|x, y| x[1] <=> y[1]}\n  return ordered_array[0][0]\nend\n\ndef postorder(node, array)\n  if (node.left != nil) then\n    postorder(node.left, array)\n  end\n  if (node.right != nil) then\n    postorder(node.right, array)\n  end\n  array << node.id\nend\n\n\nn = gets.chomp.to_i\n$preorder = gets.chomp.split.map(&:to_i)\n$inorder = gets.chomp.split.map(&:to_i)\n\nroot_node = Node.new($preorder[0])\nroot_index = $inorder.index($preorder[0])\nreconstruct_visit(root_node, \n      root_index, \n      $inorder[0...root_index], \n      $inorder[root_index+1..-1])\n\npostorder_array = []\npostorder(root_node, postorder_array)\nputs postorder_array.join(' ')"
  },
  {
    "language": "Ruby",
    "code": "class Walker\n  attr_reader :post\n  def initialize(preorder, inorder)\n    @pre  = preorder\n    @in   = inorder\n    @post = []\n    @pre_pos = 0\n  end\n\n  def reconstruct(left, right)\n    return if right <= left\n    root = @pre[ @pre_pos ]\n    @pre_pos += 1\n    in_pos = @in.index root\n    reconstruct(left, in_pos)\n    reconstruct(in_pos + 1, right)\n    @post << root\n  end\nend\n\nn_nodes  = gets.to_i\npreorder = gets.split.map &:to_i\ninorder  = gets.split.map &:to_i\n\nwalker = Walker.new(preorder, inorder)\nwalker.reconstruct 0, n_nodes\n\nputs walker.post.join(' ')"
  },
  {
    "language": "Ruby",
    "code": "def solve(left, right)\n  return if left > right\n  x = $preorder[$cur]\n  y = $inorder.index(x)\n  $cur += 1\n  solve(left, y-1)\n  solve(y+1, right)\n  $postorder << x\nend\nn = gets.to_i\n$preorder = gets.split.map(&:to_i)\n$inorder = gets.split.map(&:to_i)\n$postorder = []\n$cur = 0\nsolve(0, n-1)\nputs $postorder.join(\" \")"
  },
  {
    "language": "Ruby",
    "code": "def reconstruct preorder, inorder\n  root = preorder.shift\n  unless root_idx = inorder.index(root)\n    reconstruct(preorder,inorder)\n    return\n  end\n\n  reconstruct(preorder,inorder[0...root_idx]) unless root_idx==0\n  reconstruct(preorder,inorder[root_idx+1..-1]) unless root_idx==inorder.size-1\n  $postorder << root\nend\n\ngets\nPre=gets.split.map &:to_i\nIn=gets.split.map &:to_i\n$postorder=[]\nreconstruct(Pre,In)\nputs $postorder.join \" \""
  },
  {
    "language": "Ruby",
    "code": "def reconstruct preorder, inorder\n  no=inorder.size-1\n  root = preorder.shift\n  unless root_idx = inorder.index(root)#???\n    $right_preorder << root\n    return\n  end\n  if root_idx==0\n  elsif root_idx==1\n    $postorder << inorder[0]\n  else\n    reconstruct(preorder,inorder[0...root_idx])#???\n  end\n\n  if root_idx==no\n  elsif root_idx==no-1\n    $postorder << inorder[-1]\n  else\n    reconstruct($right_preorder.concat(preorder),inorder[root_idx+1..-1])#???\n  end\n  $postorder << root\nend\n\ngets\nPre=gets.split.map &:to_i\nIn=gets.split.map &:to_i\n$postorder=[]\n$right_preorder=[]\nreconstruct(Pre,In)\nputs $postorder.join \" \""
  },
  {
    "language": "Ruby",
    "code": "def reconstruction(l, r)\n  if l >= r\n    return\n  end\n  c = $preorders.shift\n  m = $inorders.index(c)\n\n  reconstruction(l, m)\n  reconstruction(m + 1, r)\n\n  $postorders << c\nend\n\nn = gets.to_i\n$preorders = gets.split.map(&:to_i)\n$inorders = gets.split.map(&:to_i)\n$postorders = []\n\nreconstruction(0, n)\n\nputs $postorders.join(\" \")\n"
  },
  {
    "language": "Ruby",
    "code": "def solve(left, right)\n  return if left > right\n  x = $preorder[$cur]\n  $cur += 1\n  solve(left, $postorder[x]-1)\n  solve($postorder[x]+1, right)\n  if $cur == 0 then print x, \"\\n\"\n  else print x, \" \"\n  end\nend\nn = gets.to_i\n$preorder = gets.split.map(&:to_i)\n$inorder = gets.split.map(&:to_i)\n$postorder = []\n$cur = 0\nn.times{ |i| $postorder[$inorder[i]] = i }\nsolve(0, n-1)"
  },
  {
    "language": "Ruby",
    "code": "def reconstruct(preorder_values, inorder_values, postorder_values, left, right)\n  return unless left < right\n\n  root = preorder_values.shift\n\n  mid = inorder_values.find_index(root)\n\n  reconstruct(preorder_values, inorder_values, postorder_values, left, mid)\n  reconstruct(preorder_values, inorder_values, postorder_values, mid + 1, right)\n\n  postorder_values << root\nend\n\nif $PROGRAM_NAME == __FILE__\n  n = gets.to_i\n\n  preorder_values = gets.chomp.split.map(&:to_i)\n  inorder_values = gets.chomp.split.map(&:to_i)\n  postorder_values = []\n\n  reconstruct(preorder_values, inorder_values, postorder_values, 0, n)\n\n  puts postorder_values.join(' ')\nend"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\npreo, ino = 2.times.map{gets.split(' ').map(&:to_i)}\n\nTree = Hash.new([])\n\nbuild = -> (i, t) do\n  j = t.index i\n  if j.nil?\n    preo.unshift i\n    return nil\n  end\n  Tree[i] = []\n  Tree[i][0] = build.(preo.shift, t[0...j])\n  Tree[i][1] = build.(preo.shift, t[j+1...t.size])\n  i\nend\n\npostorder = -> (a, i) do\n  l = Tree[i][0]\n  r = Tree[i][1]\n  postorder.(a, l) if !l.nil?\n  postorder.(a, r) if !r.nil?\n  a << i\nend\n\nroot = preo.first\nbuild.(preo.shift, ino)\nputs postorder.([], root).join(' ')\n"
  },
  {
    "language": "Ruby",
    "code": "class Graph\n  include Comparable\n  attr_reader :id, :depth\n  @@nodes = Array.new\n  def initialize(id, left = nil, right = nil)\n    @id = id\n    @left = left == -1? nil: left\n    @right = right == -1? nil: right\n    @depth = -1\n    @parent = -1\n    @sibling = -1\n    @@nodes[id] = self\n  end\n  \n  def to_i\n    return @id\n  end\n  \n  def degree\n    deg = 0\n    deg += 1 if @left\n    deg += 1 if @right\n    return deg\n  end\n  \n  def set_num(other)\n    if @parent != -1\n      if @left == other\n        @parent.set_num(self) * 2\n      elsif @right == other\n        @parent.set_num(self) * 2 + 1\n      end\n    else\n      1\n    end\n  end\n  \n  def num\n    if @parent != -1\n      @parent.set_num(self)\n    else\n      return 1\n    end\n  end\n  \n  def set_left(other)\n    @left = other\n  end\n  \n  def set_right(other)\n    @right = other\n  end\n  \n  def set_parent(other)\n    @parent = other\n  end\n  \n  def set_child\n    @@nodes[@left].set_parent(self) if @left\n    @@nodes[@right].set_parent(self) if @right\n    if @left and @right\n      @@nodes[@left].set_sib(@@nodes[@right])\n      @@nodes[@right].set_sib(@@nodes[@left])\n    end\n  end\n  \n  def set_children\n    set_child\n    @@nodes[@left].set_children if @left\n    @@nodes[@right].set_children if @right\n  end\n  \n  def set_sib(other)\n    @sibling = other\n  end\n  \n  def depth\n    if @parent != -1\n      @parent.depth + 1\n    else\n      0\n    end\n  end\n  \n  def height\n    left = @left? @@nodes[@left].height: -1\n    right = @right? @@nodes[@right].height: -1\n    if left < right\n      right + 1\n    else\n      left + 1\n    end\n  end\n  \n  def <=>(other)\n    if Graph === other\n      @id <=> other.id\n    else\n      @id <=> other\n    end\n  end\n  \n  def type\n    if @parent == -1\n      return \"root\"\n    elsif @degree == 0\n      return \"leaf\"\n    else\n      return \"internal node\"\n    end\n  end\n  \n  def order(n)\n    arr = []\n    if n == 0\n      preorder(arr)\n      return [\"Preorder\", \" \" + arr.join(\" \")]\n    elsif n == 1\n      inorder(arr)\n      return [\"Inorder\", \" \" + arr.join(\" \")]\n    else\n      postorder(arr)\n      return [\"Postorder\", \" \" + arr.join(\" \")]\n    end\n  end\n  \n  def preorder(arr)\n    arr << @id\n    @@nodes[@left].preorder(arr) if @left\n    @@nodes[@right].preorder(arr) if @right\n  end\n  \n  def inorder(arr)\n    @@nodes[@left].inorder(arr) if @left\n    arr << @id\n    @@nodes[@right].inorder(arr) if @right\n  end\n  \n  def postorder(arr)\n    @@nodes[@left].postorder(arr) if @left\n    @@nodes[@right].postorder(arr) if @right\n    arr << @id\n  end\n  \n  def inspect\n    return [@id, num, @left, @right]\n  end\n  \n  def to_s\n    \"node #{@id}: parent = #{@parent.id}, sibling = #{@sibling.id}, degree = #{degree}, depth = #{depth}, height = #{height}, #{type}\"\n  end\nend\ndef f(preorder, inorder)\n  root = preorder[0]\n  idx = inorder.index(root)\n  root.set_left(f(preorder & inorder[0...idx], inorder[0...idx])) if idx > 0\n  root.set_right(f(preorder & inorder[idx + 1..-1], inorder[idx + 1 ..-1])) if idx < inorder.length - 1\n  return root.to_i\nend\ndef main\n  arr = []\n  gets.to_i.times do |n|\n    arr << Graph.new(n + 1)\n  end\n  preorder = gets.split(\" \").map{|item|arr[item.to_i - 1]}\n  inorder = gets.split(\" \").map{|item|arr[item.to_i - 1]}\n  f(preorder, inorder)\n  preorder[0].set_children\n  arr = []\n  puts preorder[0].postorder(arr).join(\" \")\nend\nmain"
  },
  {
    "language": "Ruby",
    "code": "def reconstruct preorder, inorder\n  no=inorder.size-1\n  root = preorder.shift\n  unless root_idx = inorder.index(root)#???\n    reconstruct(preorder,inorder)\n    return\n  end\n  if root_idx==0\n  else\n    reconstruct(preorder,inorder[0...root_idx])#???\n  end\n\n  if root_idx==no\n  else\n    reconstruct(preorder,inorder[root_idx+1..-1])#???\n  end\n  $postorder << root\nend\n\ngets\nPre=gets.split.map &:to_i\nIn=gets.split.map &:to_i\n$postorder=[]\nreconstruct(Pre,In)\nputs $postorder.join \" \""
  },
  {
    "language": "Ruby",
    "code": "N = gets.to_i\nclass Node\n    attr_accessor :index, :children, :parent, :sibling\n\n    def initialize()\n        @children = []\n        @parent = nil\n        @sibling = nil\n    end\n\n    def depth\n        parent == nil ? 0 : parent.depth + 1\n    end\n\n    def degree\n        children.length\n    end\n\n    def height\n        if children.empty?\n            0\n        else\n            children.map {|e| e.height }.max + 1\n        end\n    end\n\n    def preorder_array\n        left_array = children[0] == nil ? [] : children[0].preorder_array\n        right_array = children[1] == nil ? [] : children[1].preorder_array\n        [[self], [left_array], [right_array]].flatten\n    end\n\n    def inorder_array\n        left_array = children[0] == nil ? [] : children[0].inorder_array\n        right_array = children[1] == nil ? [] : children[1].inorder_array\n        [[left_array], [self], [right_array]].flatten\n    end\n\n    def postorder_array\n        left_array = children[0] == nil ? [] : children[0].postorder_array\n        right_array = children[1] == nil ? [] : children[1].postorder_array\n        [[left_array], [right_array], [self]].flatten\n    end\nend\npreorders = gets.chomp.split(\" \").map(&:to_i)\ninorders = gets.chomp.split(\" \").map(&:to_i)\n\ndef setNode(preorders, inorders, parent=nil)\n    node = Node.new\n    node.index = preorders[0]\n    node.parent = parent\n    left_num = inorders.index(node.index)\n    right_num = preorders.length - left_num - 1\n    left_node = (left_num == 0) ? nil : setNode(preorders[1..left_num], inorders[0..(left_num-1)], node)\n    right_node = (right_num == 0) ? nil : setNode(preorders[(-right_num)..(-1)], inorders[(-right_num)..(-1)], node)\n    node.children = [left_node, right_node]\n    node\nend\n\nroot_node = setNode(preorders, inorders)\n\nputs root_node.postorder_array.map {|e|e.index}.join(\" \")\n"
  },
  {
    "language": "Ruby",
    "code": "def reconstruct preorder, inorder\n  no=inorder.size-1\n  root = preorder.shift\n  unless root_idx = inorder.index(root)#???\n    reconstruct(preorder,inorder)\n    return\n  end\n  if root_idx==0\n  elsif root_idx==1\n    $postorder << inorder[0]\n  else\n    reconstruct(preorder,inorder[0...root_idx])#???\n  end\n\n  if root_idx==no\n  elsif root_idx==no-1\n    $postorder << inorder[-1]\n  else\n    reconstruct(preorder,inorder[root_idx+1..-1])#???\n  end\n  $postorder << root\nend\n\ngets\nPre=gets.split.map &:to_i\nIn=gets.split.map &:to_i\n$postorder=[]\nreconstruct(Pre,In)\nputs $postorder.join \" \""
  },
  {
    "language": "Ruby",
    "code": "class Node\n  attr_accessor :id, :left, :right\n\n  def initialize(id)\n    @id = id\n    @left = nil\n    @right = nil\n  end\nend\n\ndef reconstruct_visit(node, index, lefts, rights)\n  direct_left = compare_preorder(lefts)\n  direct_right = compare_preorder(rights)\n  if direct_left >= 0 then\n    node.left = Node.new(direct_left)\n    left_index = lefts.index(direct_left)\n    reconstruct_visit(node.left,\n          direct_left,\n          lefts[0...left_index],\n          lefts[left_index+1..-1])\n  end\n  if direct_right >= 0 then\n    node.right = Node.new(direct_right)\n    right_index = rights.index(direct_right)\n    reconstruct_visit(node.right,\n          direct_right,\n          rights[0...right_index],\n          rights[right_index+1..-1])\n  end\nend\n\ndef compare_preorder(array)\n  return -1 if array.size == 0\n  ordered_array = array.map do |item|\n    [item, @preorder.index(item)]\n  end\n  ordered_array.sort! {|x, y| x[1] <=> y[1]}\n  return ordered_array[0][0]\nend\n\ndef postorder(node, array)\n  if (node.left != nil) then\n    postorder(node.left, array)\n  end\n  if (node.right != nil) then\n    postorder(node.right, array)\n  end\n  array.push(node.id)\nend\n\n\nn = gets.chomp.to_i\n@preorder = gets.chomp.split.map(&:to_i)\n@inorder = gets.chomp.split.map(&:to_i)\n\nroot_node = Node.new(@preorder[0])\nroot_index = @inorder.index(@preorder[0])\nreconstruct_visit(root_node, root_index, @inorder[0...root_index], @inorder[root_index+1..-1])\n\npostorder_array = Array.new\npostorder(root_node, postorder_array)\nputs postorder_array.join(' ')"
  },
  {
    "language": "Ruby",
    "code": "class BinTree\n  attr_accessor :node\n  def initialize(n)\n    @node = Array.new(n){Node.new()}\n  end\n  def preorder(n=root())\n    str = \"\"\n    return str if n < 0\n    #root\n    str << sprintf(\" %s\", n)\n    #left\n    str << preorder(node[n].left)\n    #right\n    str << preorder(node[n].right)\n    return str\n  end\n  def inorder(n=root())\n    str = \"\"\n    return str if n < 0\n    #left\n    str << inorder(node[n].left)\n    #root\n    str << sprintf(\" %s\", n)\n    #right\n    str << inorder(node[n].right)\n    return str\n  end\n  def postorder(n=root())\n    arr = []\n    return [] if n < 0\n    #left\n    arr += postorder(node[n].left)\n    #right\n    arr += postorder(node[n].right)\n    arr += [n]\n  end\n  def root\n    #find root\n    r = 0\n    node.size.times {|i|\n      if node[i].parent == -1 then\n        r = i\n        break\n      end\n    }\n    return r\n  end\n  def add(i, l, r)\n    node[i].left = l\n    node[i].right = r\n    node[l].parent = i unless l == -1\n    node[r].parent = i unless r == -1\n  end\n  def order_to_tree(preorder, inorder)\n    n = preorder.size\n    i = preorder[0]\n    idx_root = inorder.index(i)\n    if idx_root == 0 then\n      inorder_left = []\n    else\n      inorder_left = inorder[0..idx_root-1]\n    end\n    inorder_right = inorder[idx_root+1..n-1]\n    idx = preorder.index(inorder_right[0])\n    preorder_left = preorder[1..idx-1]\n    preorder_right = preorder[idx..n-1]\n#    p inorder_right.size, preorder_right.size\n\n    if inorder_left.size == 1 then\n      node[i].left = inorder_left[0]\n      node[inorder_left[0]].parent = i\n    end\n    if inorder_right.size == 1 then\n      node[i].right = inorder_right[0]\n      node[inorder_right[0]].parent = i\n    end\n    if inorder_left.size > 1 then\n      node[i].left = self.order_to_tree(preorder_left, inorder_left)\n      node[node[i].left].parent = i\n    end    \n    if inorder_right.size > 1 then\n      node[i].right = self.order_to_tree(preorder_right, inorder_right)\n      node[node[i].right].parent = i\n    end\n    return i\n  end\nend\n\nclass Node\n  attr_accessor :parent, :left, :right\n  def initialize\n    @parent = -1\n    @left = -1\n    @right = -1\n  end\nend\n\nn = gets.to_i\ntree = BinTree.new(n)\n\npreorder = gets.split.map(&:to_i).map{|i| i -= 1}\ninorder = gets.split.map(&:to_i).map{|i| i -= 1}\n\ntree.order_to_tree(preorder, inorder)\n\nputs tree.postorder().map{|i| i += 1}.join(\" \")"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\n$pre = gets.split.map(&:to_i)\n$in = gets.split.map(&:to_i)\n$post = []\n\n$pos = 0\n\nclass Node\n  attr_accessor :id, :left, :right\n  def initialize\n    @id = nil\n    @left = nil\n    @right = nil\n  end\nend\n\ndef reconstruction(l, r)\n  if l >= r\n    return\n  end\n\n  c = $pre[$pos]\n  $pos += 1\n\n  m = $in.index(c)\n\n  reconstruction(l, m)\n  reconstruction(m+1, r)\n\n  $post << c\nend\n\nreconstruction(0, n)\n\nputs $post.join(\" \")\n"
  },
  {
    "language": "Ruby",
    "code": "def solve(left, right)\n  return if left > right\n  x = $inorder.index($preorder[$cur])\n  $cur += 1\n  solve(left, x-1)\n  solve(x+1, right)\n  $postorder << x\nend\nn = gets.to_i\n$preorder = gets.split.map(&:to_i)\n$inorder = gets.split.map(&:to_i)\n$postorder = []\n$cur = 0\nsolve(0, n-1)\nputs $postorder.join(\" \")"
  },
  {
    "language": "Ruby",
    "code": "gets\npreorder = gets.chomp.split.map(&:to_i)\ninorder = gets.chomp.split.map(&:to_i)\n@postorder = []\n\ndef rec(n, inorder, preorder)\n    if inorder != []\n        c = preorder[n]; n += 1\n        x = inorder.index(c)\n        left = inorder[0...x]\n        right = inorder[(x+1)..-1]\n        n = rec(n, left, preorder)\n        n = rec(n, right, preorder)\n        @postorder << c\n    end\n    n\nend\n\nrec(0, inorder, preorder)\nputs @postorder.join(' ')\n"
  },
  {
    "language": "Ruby",
    "code": "n = gets.chomp.to_i\npreorderd = gets.chomp.split.map(&:to_i)\ninorderd  = gets.chomp.split.map(&:to_i)\n\n\n \nclass Node\n  attr_accessor :left, :right, :parent\n  def initialize(parent, left, right)\n    @parent = parent\n    @left = left\n    @right = right\n  end\nend\n\ndef postorder(u, tree, res)\n  return if u == -1\n  postorder(tree[u].left, tree, res)\n  postorder(tree[u].right, tree, res)\n  res << u\n  res\nend\n \ntree = []\nn.times do |i|\n  tree[i] = Node.new(-1, -1, -1)\nend\n\n# solve it \ndef make_tree(inorderd, preorderd)\n  return [] if !preorderd or preorderd.empty?\n  return [] if !inorderd or inorderd.empty?\n\n  focus = preorderd.shift\n  split = inorderd.index(focus)\n  \n  l = inorderd.shift(split)\n  inorderd.shift\n\n  res = []\n  res.concat(make_tree(preorderd, l))\n  res.concat(make_tree(preorderd, inorderd))\n  res << focus\nend\n\n\n\nputs make_tree(inorderd, preorderd).join(' ')"
  },
  {
    "language": "Ruby",
    "code": "def recon(l, r)\n  return if l > r\n  c = @pre.shift\n  m = @in.index(c)\n  recon(l, m-1)\n  recon(m+1, r)\n  @out << c\nend\n\nn = gets.to_i\n@pre = gets.split.map { |i| i.to_i }\n@in = gets.split.map { |i| i.to_i }\n@out = []\nrecon(0, n-1)\nputs @out*' '"
  },
  {
    "language": "Ruby",
    "code": "# ALDS1_7_D: Reconstruction of the Tree\n\nclass Walker\n  attr_reader :post\n  def initialize(preorder, inorder)\n    @pre  = preorder\n    @in   = inorder\n    @post = []\n    @pre_pos = 0\n  end\n\n  def reconstruct(left, right)\n    return if right <= left\n    root = @pre[ @pre_pos ]\n    @pre_pos += 1\n    in_pos = @in.index root\n    reconstruct(left, in_pos)\n    reconstruct(in_pos + 1, right)\n    @post << root\n  end\nend\n\nn_nodes  = gets.to_i\npreorder = gets.split.map &:to_i\ninorder  = gets.split.map &:to_i\n\nwalker = Walker.new(preorder, inorder)\nwalker.reconstruct 0, n_nodes\n\nputs walker.post.join(' ')"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\n$pre = gets.split.map(&:to_i)\n$in = gets.split.map(&:to_i)\n$post = []\n\n$pos = 0\n\ndef reconstruction(l, r)\n  if l >= r\n    return\n  end\n\n  c = $pre[$pos]\n  $pos += 1\n\n  m = $in.index(c)\n\n  reconstruction(l, m)\n  reconstruction(m+1, r)\n\n  $post << c\nend\n\nreconstruction(0, n)\n\nputs $post.join(\" \")\n"
  },
  {
    "language": "Ruby",
    "code": "def solve(left, right)\n  return if left > right\n  x = $preorder[$cur]\n  $cur += 1\n  solve(left, $postorder[x]-1)\n  solve($postorder[x]+1, right)\n  if $cur == 0 then print x\n  else print x, \" \"\n  end\nend\nn = gets.to_i\n$preorder = gets.split.map(&:to_i)\n$inorder = gets.split.map(&:to_i)\n$postorder = []\n$cur = 0\nn.times{ |i| $postorder[$inorder[i]] = i }\nsolve(0, n-1)\nputs"
  },
  {
    "language": "Ruby",
    "code": "class BinTree\n  attr_accessor :node\n  def initialize(n)\n    @node = Array.new(n){Node.new()}\n  end\n  def preorder(n=root())\n    str = \"\"\n    return str if n < 0\n    #root\n    str << sprintf(\" %s\", n)\n    #left\n    str << preorder(node[n].left)\n    #right\n    str << preorder(node[n].right)\n    return str\n  end\n  def inorder(n=root())\n    str = \"\"\n    return str if n < 0\n    #left\n    str << inorder(node[n].left)\n    #root\n    str << sprintf(\" %s\", n)\n    #right\n    str << inorder(node[n].right)\n    return str\n  end\n  def postorder(n=root())\n    arr = []\n    return [] if n < 0\n    #left\n    arr += postorder(node[n].left)\n    #right\n    arr += postorder(node[n].right)\n    arr += [n]\n  end\n  def root\n    #find root\n    r = 0\n    node.size.times {|i|\n      if node[i].parent == -1 then\n        r = i\n        break\n      end\n    }\n    return r\n  end\n  def add(i, l, r)\n    node[i].left = l\n    node[i].right = r\n    node[l].parent = i unless l == -1\n    node[r].parent = i unless r == -1\n  end\n  def order_to_tree(preorder, inorder)\n    n = preorder.size\n    i = preorder[0]\n    idx_root = inorder.index(i)\n    if idx_root == 0 then\n      inorder_left = []\n    else\n      inorder_left = inorder[0..idx_root-1]\n    end\n    inorder_right = inorder[idx_root+1..n-1]\n     idx = preorder.index(inorder_right[0])\n    if idx == nil then\n      preorder_left = preorder[1..n-1]\n      preorder_right = []\n    else\n      preorder_left = preorder[1..idx-1]\n      preorder_right = preorder[idx..n-1]\n    end\n\n    if inorder_left.size == 1 then\n      node[i].left = inorder_left[0]\n      node[inorder_left[0]].parent = i\n    end\n    if inorder_right.size == 1 then\n      node[i].right = inorder_right[0]\n      node[inorder_right[0]].parent = i\n    end\n    if inorder_left.size > 1 then\n      node[i].left = self.order_to_tree(preorder_left, inorder_left)\n      node[node[i].left].parent = i\n    end    \n    if inorder_right.size > 1 then\n      node[i].right = self.order_to_tree(preorder_right, inorder_right)\n      node[node[i].right].parent = i\n    end\n    return i\n  end\nend\n\nclass Node\n  attr_accessor :parent, :left, :right\n  def initialize\n    @parent = -1\n    @left = -1\n    @right = -1\n  end\nend\n\nn = gets.to_i\ntree = BinTree.new(n)\n\npreorder = gets.split.map(&:to_i).map{|i| i -= 1}\ninorder = gets.split.map(&:to_i).map{|i| i -= 1}\n\ntree.order_to_tree(preorder, inorder)\n\nputs tree.postorder().map{|i| i += 1}.join(\" \")"
  },
  {
    "language": "Ruby",
    "code": "def reconstruct preorder, inorder\n  no=inorder.size-1\n  root = preorder.shift\n  unless root_idx = inorder.index(root)#???\n    $right_preorder << root\n    reconstruct(preorder,inorder)\n    return\n  end\n  if root_idx==0\n  elsif root_idx==1\n    $postorder << inorder[0]\n  else\n    reconstruct(preorder,inorder[0...root_idx])#???\n  end\n\n  if root_idx==no\n  elsif root_idx==no-1\n    $postorder << inorder[-1]\n  else\n    reconstruct(preorder,inorder[root_idx+1..-1])#???\n  end\n  $postorder << root\nend\n\ngets\nPre=gets.split.map &:to_i\nIn=gets.split.map &:to_i\n$postorder=[]\n$right_preorder=[]\nreconstruct(Pre,In)\nputs $postorder.join \" \""
  },
  {
    "language": "Ruby",
    "code": "class BinTree\n  attr_accessor :node\n  def initialize(n)\n    @node = Array.new(n){Node.new()}\n  end\n  def preorder(n=root())\n    str = \"\"\n    return str if n < 0\n    #root\n    str << sprintf(\" %s\", n)\n    #left\n    str << preorder(node[n].left)\n    #right\n    str << preorder(node[n].right)\n    return str\n  end\n  def inorder(n=root())\n    str = \"\"\n    return str if n < 0\n    #left\n    str << inorder(node[n].left)\n    #root\n    str << sprintf(\" %s\", n)\n    #right\n    str << inorder(node[n].right)\n    return str\n  end\n  def postorder(n=root())\n    arr = []\n    return [] if n < 0\n    #left\n    arr += postorder(node[n].left)\n    #right\n    arr += postorder(node[n].right)\n    arr += [n]\n  end\n  def root\n    #find root\n    r = 0\n    node.size.times {|i|\n      if node[i].parent == -1 then\n        r = i\n        break\n      end\n    }\n    return r\n  end\n  def add(i, l, r)\n    node[i].left = l\n    node[i].right = r\n    node[l].parent = i unless l == -1\n    node[r].parent = i unless r == -1\n  end\n  def order_to_tree(preorder, inorder)\n    n = preorder.size\n    i = preorder[0]\n    idx_root = inorder.index(i)\n    if idx_root == 0 then\n      inorder_left = []\n    else\n      inorder_left = inorder[0..idx_root-1]\n    end\n    inorder_right = inorder[idx_root+1..n-1]\n     idx = preorder.index(inorder_right[0])\n    if idx == nil then\n      preorder_left = preorder[1..n-1]\n      preorder_right = []\n    else\n      preorder_left = preorder[1..idx-1]\n      preorder_right = preorder[idx..n-1]\n    end\n\n    if inorder_left.size == 1 then\n      node[i].left = inorder_left[0]\n      node[inorder_left[0]].parent = i\n    end\n    if inorder_right.size == 1 then\n      node[i].right = inorder_right[0]\n      node[inorder_right[0]].parent = i\n    end\n    if inorder_left.size > 1 then\n      node[i].left = self.order_to_tree(preorder_left, inorder_left)\n      node[node[i].left].parent = i\n    end    \n    if inorder_right.size > 1 then\n      node[i].right = self.order_to_tree(preorder_right, inorder_right)\n      node[node[i].right].parent = i\n    end\n    return i\n  end\nend\n\nclass Node\n  attr_accessor :parent, :left, :right\n  def initialize\n    @parent = -1\n    @left = -1\n    @right = -1\n  end\nend\n\nn = gets.to_i\ntree = BinTree.new(n)\n\npreorder = gets.split.map(&:to_i).map{|i| i -= 1}\ninorder = gets.split.map(&:to_i).map{|i| i -= 1}\n\ntree.order_to_tree(preorder, inorder)\n\nputs tree.postorder().map{|i| i += 1}.join(\" \")"
  },
  {
    "language": "Ruby",
    "code": "def reconstruct(preorder, inorder)\n\treturn [] if !preorder || preorder.empty?\n\treturn [] if !inorder || inorder.empty?\n\n\troot = preorder.shift\n\tseparate_point = inorder.index(root)\n\tunless separate_point\n\t\traise \"Unexpected state #{preorder}, #{inorder}\"\n\tend\n\n\tleft = inorder.shift(separate_point) # 副作用でinorderは右部分木になる\n\tinorder.shift # separate_pointを取り除く\n\n\tresult = []\n\tresult.concat(reconstruct(preorder, left))\n\tresult.concat(reconstruct(preorder, inorder))\n\tresult << root\nend\n\nn = STDIN.gets.to_i\npreorder = STDIN.gets.split[0...n].map(&:to_i)\ninorder  = STDIN.gets.split[0...n].map(&:to_i)\nputs reconstruct(preorder, inorder).join(\" \")"
  },
  {
    "language": "Ruby",
    "code": "def solve(left, right)\n  return if left > right\n  x = $preorder[$cur]\n  $cur += 1\n  solve(left, $inorder.index(x)-1)\n  solve($inorder.index(x)+1, right)\n  $postorder << x\nend\nn = gets.to_i\n$preorder = gets.split.map(&:to_i)\n$inorder = gets.split.map(&:to_i)\n$postorder = []\n$cur = 0\nsolve(0, n-1)\nputs $postorder.join(\" \")"
  },
  {
    "language": "Ruby",
    "code": "class NilClass\n  def postorder\n    nil\n  end\nend\n\nclass Node\n  attr_accessor :id, :left_child, :right_child\n\n  def initialize(id)\n    @id = id\n    @left_child = nil\n    @right_child = nil\n  end\n\n  def postorder\n    [@left_child.postorder, @right_child.postorder, @id].flatten.compact\n  end\n\n  def print_postorder\n    puts postorder.join(\" \")\n  end\nend\n\nclass TreeConstructor\n  attr_accessor :root\n\n  def initialize(preorder, inorder)\n    if !preorder[0]\n      return\n    end\n\n    @root = Node.new(preorder[0])\n\n    inorder_right = inorder[(inorder.index(@root.id) + 1)..-1]\n    inorder_left = inorder - [@root.id] - inorder_right\n    preorder_right = preorder.reject { |item| [@root.id, *inorder_left].include? item }\n    preorder_left = preorder - [@root.id] - preorder_right\n\n    @root.left_child = TreeConstructor.new(preorder_left, inorder_left).root\n    @root.right_child = TreeConstructor.new(preorder_right, inorder_right).root\n  end\nend\n\nn = gets.to_i\npreorder = gets.split(\" \").map(&:to_i)\ninorder = gets.split(\" \").map(&:to_i)\n\ntree_constructor = TreeConstructor.new(preorder, inorder)\nroot = tree_constructor.root\nroot.print_postorder\n"
  },
  {
    "language": "Ruby",
    "code": "gets.chomp\npreorderd = gets.chomp.split.map(&:to_i)\ninorderd  = gets.chomp.split.map(&:to_i)\n\n\n\ndef make_tree(inorderd, preorderd)\n  return [] if inorderd.nil? or inorderd.empty? \n  return [] if preorderd.nil? or preorderd.empty? \n\n  focus = preorderd.shift\n  split = inorderd.index(focus)\n\n  l = inorderd.shift(split)\n  inorderd.shift\n\n  [make_tree(l, preorderd), make_tree(inorderd, preorderd)].flatten << focus\nend\n\nputs make_tree(inorderd, preorderd).join(' ')"
  },
  {
    "language": "Ruby",
    "code": "_,a,b,*c=$<.map{|l|l.split.map &:to_i}\nm,i,*o=-1,-2\nb.map{|v|c[v]=i+=1}\ns=->f,l,r{l<=r&&(f[f,l,d=c[x=a[m+=1]]]\nf[f,d+2,r]\no<<x)}\ns[s,0,i+1]\nputs o*\" \""
  },
  {
    "language": "Ruby",
    "code": "def solve(left, right)\n  return if left > right\n  x = $preorder[$cur]\n  $cur += 1\n  solve(left, $arr[x]-1)\n  solve($arr[x]+1, right)\n  $postorder << x\nend\nn = gets.to_i\n$preorder = gets.split.map(&:to_i)\n$inorder = gets.split.map(&:to_i)\n$postorder = []\n$arr = Array.new(n)\n$cur = 0\nn.times{ |i| $arr[$inorder[i]] = i }\nsolve(0, n-1)\nputs $postorder.join(\" \")"
  },
  {
    "language": "Ruby",
    "code": "gets\npreorder = gets.chomp.split.map(&:to_i)\ninorder = gets.chomp.split.map(&:to_i)\n\ndef rec(n, inorder, preorder)\n    if inorder != []\n        c = preorder[n]; n += 1\n        x = inorder.index(c)\n        left = inorder[0...x]\n        right = inorder[(x+1)..-1]\n        n = rec(n, left, preorder)\n        n = rec(n, right, preorder)\n        print \"#{c} \"\n    end\n    n\nend\n\nrec(0, inorder, preorder)\nputs\n"
  },
  {
    "language": "Ruby",
    "code": "N = gets.to_i\n$pre, $in = 2.times.map{gets.split.map(&:to_i)}\n\n$post = []\n\ndef rec(l, r)\n  return if l >= r\n  return if $pos == N\n\n  root = $pre[$pos]\n  $pos += 1\n  m = $in.index(root)\n\n  rec(l, m)\n  rec(m + 1, r)\n  $post.push(root)\nend\n\ndef solve\n  $pos = 0\n  rec(0, $pre.size)\nend\n\nputs solve.join(' ')\n"
  },
  {
    "language": "Ruby",
    "code": "#binary_tree_restore\nclass Node\n  attr_accessor :myname,:parent,:left,:right\n\n  def initialize(n)\n    @myname = n\n    @parent = nil\n    @left   = nil\n    @right  = nil\n  end\n\n  def add_left(child)\n      self.left    = child\n      child.parent = self\n  end\n\n  def add_right(child)\n      self.right    = child\n      child.parent = self\n  end\n\n  def postorder(flag)\n    if(left != nil && left != -1)\n      left.postorder(0)\n    end\n    if(right!= nil && left != -1)\n      right.postorder(0)\n    end\n    printf(\"%d\",self.myname)\n    printf(\" \") if flag == 0\n  end\n\nend\n\n\nn = STDIN.gets.split[0].to_i\n$tree=Array.new(n+1){|i| Node.new(i)}\n$pre =Array.new(n)\n$in_ =Array.new(n)\n\n\ns = STDIN.gets.split\n0.upto(n-1){|i|\n  $pre[i] = s[i].to_i\n}\n\ns = STDIN.gets.split\n0.upto(n-1){|i|\n  $in_[i]  = s[i].to_i\n}\n\n$pre_cnt=0\ndef get_pre_order\n  ret=$pre[$pre_cnt]\n  $pre_cnt += 1\n  ret\nend\n\ndef make_tree(array)\n  root = get_pre_order\n\n=begin\n  printf(\"root=%d|\",root)\n  for n in array\n    printf(\"%d \",n)\n  end\n  printf(\"[%d]\\n\",array.length)\n=end\n\n  if(array.length == 1)\n    $tree[root].left = -1\n    $tree[root].right= -1\n  else\n    pos=array.index(root)\n    if(pos==0)\n      $tree[root].left = nil\n    else\n      left_node = make_tree(array[0...pos])\n      left_node.parent = $tree[root]\n      $tree[root].left = left_node\n    end\n    if(pos == array.length-1)\n      $tree[root].right= nil\n    else\n      right_node = make_tree(array[pos+1...$tree.length])\n      right_node.parent = $tree[root]\n      $tree[root].right  = right_node\n    end\n  end\n  $tree[root]\nend\n\nmake_tree($in_)\n$tree[$pre[0]].postorder(1)\nprintf(\"\\n\")"
  },
  {
    "language": "Ruby",
    "code": "def solve(left, right)\n  return if left > right\n  x = $preorder[$cur]\n  $cur += 1\n  solve(left, $postorder[x]-1)\n  solve($postorder[x]+1, right)\n  if $cur == 0 then print x, \"?\\n\"\n  else print x, \" \"\n  end\nend\nn = gets.to_i\n$preorder = gets.split.map(&:to_i)\n$inorder = gets.split.map(&:to_i)\n$postorder = []\n$cur = 0\nn.times{ |i| $postorder[$inorder[i]] = i }\nsolve(0, n-1)"
  },
  {
    "language": "Ruby",
    "code": "def make_postorders pre_nodes, in_nodes, post_nodes\n  m = pre_nodes.shift\n  i = in_nodes.index(m)\n  l_ins = (0 <= i - 1) ? in_nodes.slice(0..(i - 1)) : []\n  r_ins = (i + 1 <= in_nodes.length - 1) ? in_nodes.slice((i + 1)..(in_nodes.length - 1)) : []\n\n  make_postorders pre_nodes, l_ins, post_nodes unless l_ins.empty?\n  make_postorders pre_nodes, r_ins, post_nodes unless r_ins.empty?\n  post_nodes << m\n\n  return post_nodes\nend\n\nn = gets.chomp.to_i\npreorders = gets.chomp.split(' ').map(&:to_i)\ninorders = gets.chomp.split(' ').map(&:to_i)\nnodes = make_postorders preorders, inorders, []\nputs nodes.join(' ')\n"
  },
  {
    "language": "Ruby",
    "code": "def reconstruct preorder, inorder\n  $postorder,preorder, inorder\n  no=inorder.size-1\n  root = preorder.shift\n  unless root_idx = inorder.index(root)#???\n    $right_preorder << root\n    return\n  end\n  if root_idx==0\n  elsif root_idx==1\n    $postorder << inorder[0]\n  else\n    reconstruct(preorder,inorder[0...root_idx])#???\n  end\n\n  if root_idx==no\n  elsif root_idx==no-1\n    $postorder << inorder[-1]\n  else\n    reconstruct($right_preorder.concat(preorder),inorder[root_idx+1..-1])#???\n  end\n  $postorder << root\nend\n\ngets\nPre=gets.split.map &:to_i\nIn=gets.split.map &:to_i\n$postorder=[]\n$right_preorder=[]\nreconstruct(Pre,In)\nputs $postorder.join \" \""
  },
  {
    "language": "Ruby",
    "code": "class BinTree\n  attr_accessor :node\n  def initialize(n)\n    @node = Array.new(n){Node.new()}\n  end\n  def preorder(n=root())\n    str = \"\"\n    return str if n < 0\n    #root\n    str << sprintf(\" %s\", n)\n    #left\n    str << preorder(node[n].left)\n    #right\n    str << preorder(node[n].right)\n    return str\n  end\n  def inorder(n=root())\n    str = \"\"\n    return str if n < 0\n    #left\n    str << inorder(node[n].left)\n    #root\n    str << sprintf(\" %s\", n)\n    #right\n    str << inorder(node[n].right)\n    return str\n  end\n  def postorder(n=root())\n    arr = []\n    return [] if n < 0\n    #left\n    arr += postorder(node[n].left)\n    #right\n    arr += postorder(node[n].right)\n    arr += [n]\n  end\n  def root\n    #find root\n    r = 0\n    node.size.times {|i|\n      if node[i].parent == -1 then\n        r = i\n        break\n      end\n    }\n    return r\n  end\n  def add(i, l, r)\n    node[i].left = l\n    node[i].right = r\n    node[l].parent = i unless l == -1\n    node[r].parent = i unless r == -1\n  end\n  def order_to_tree(preorder, inorder)\n    i = preorder[0]\n    idx_root = inorder.index(i)\n    if idx_root == 0 then\n      inorder_left = []\n    else\n      inorder_left = inorder[0..idx_root-1]\n    end\n\n    inorder_right = inorder - [i] - inorder_left\n    preorder_right = preorder - [i] - inorder_left\n    preorder_left = preorder - [i] - preorder_right\n\n    if inorder_left.size == 1 then\n      node[i].left = inorder_left[0]\n      node[inorder_left[0]].parent = i\n    end\n    if inorder_right.size == 1 then\n      node[i].right = inorder_right[0]\n      node[inorder_right[0]].parent = i\n    end\n    if inorder_left.size > 1 then\n      node[i].left = self.order_to_tree(preorder_left, inorder_left)\n      node[node[i].left].parent = i\n    end    \n    if inorder_right.size > 1 then\n      node[i].right = self.order_to_tree(preorder_right, inorder_right)\n      node[node[i].right].parent = i\n    end\n    return i\n  end\nend\n\nclass Node\n  attr_accessor :parent, :left, :right\n  def initialize\n    @parent = -1\n    @left = -1\n    @right = -1\n  end\nend\n\nn = gets.to_i\ntree = BinTree.new(n)\n\npreorder = gets.split.map(&:to_i).map{|i| i -= 1}\ninorder = gets.split.map(&:to_i).map{|i| i -= 1}\n\ntree.order_to_tree(preorder, inorder)\n\nputs tree.postorder().map{|i| i += 1}.join(\" \")"
  },
  {
    "language": "Ruby",
    "code": "class Node\n  attr_reader :id\n  attr_accessor :left, :right\n\n  def initialize(id)\n    @id = id\n  end\nend\n\ndef tree(pre_ids, in_ids)\n  return nil if pre_ids.none?\n\n  root_id = pre_ids.first\n  root = Node.new(root_id)\n  return root if pre_ids.one?\n\n  inorder_root_position = in_ids.find_index(root_id)\n  left_in_ids = in_ids[0 .. inorder_root_position - 1]\n  right_in_ids = in_ids[inorder_root_position + 1 .. -1]\n\n  left_ids_count = inorder_root_position\n  inorder_right_begin_position = left_ids_count + 1\n  left_pre_ids = pre_ids[1, left_ids_count]\n  right_pre_ids = pre_ids[inorder_right_begin_position .. -1]\n\n  root.left = tree(left_pre_ids, left_in_ids)\n  root.right = tree(right_pre_ids, right_in_ids)\n  root\nend\n\nclass TreeWalker\n  def self.enum_node_postorder(node, &block)\n    enum_node_postorder(node.left, &block) if node.left\n    enum_node_postorder(node.right, &block) if node.right\n    yield node\n  end\n\n  def initialize(root)\n    @root = root\n  end\n\n  def enum_postorder(&block)\n    self.class.enum_node_postorder(@root, &block)\n  end\nend\n\n_ = gets.to_i\npre_ids = gets.chomp.split(' ').map(&:to_i)\nin_ids = gets.chomp.split(' ').map(&:to_i)\n\nroot = tree(pre_ids, in_ids)\nwalker = TreeWalker.new(root)\nputs walker.to_enum(:enum_postorder).map(&:id).join(' ')\n\n"
  },
  {
    "language": "Ruby",
    "code": "def recon(l, r)\n  return if l > r\n  c = @pre.shift\n  m = @in.index(c)\n  recon(l, m-1)\n  recon(m+1, r)\n  print \"#{c} \"\nend\n\nn = gets.to_i\n@pre = gets.split.map { |i| i.to_i }\n@in = gets.split.map { |i| i.to_i }\nrecon(0, n-1)"
  },
  {
    "language": "Ruby",
    "code": "class Node\n  def initialize(id)\n    @id = id\n    @left = nil \n    @right = nil\n  end\n\n  attr_accessor :id, :left, :right\nend\n\ndef reconstruct_visit(node, index, lefts, rights)\n  direct_left = compare_by_preorder(lefts)\n  direct_right = compare_by_preorder(rights)\n  if direct_left >= 0 then\n    node.left = Node.new(direct_left)\n    left_index = lefts.index(direct_left)\n    reconstruct_visit(node.left, \n          direct_left,\n          lefts[0...left_index], \n          lefts[left_index+1...index])\n  end\n  if direct_right >= 0 then\n    node.right = Node.new(direct_right)\n    right_index = rights.index(direct_right)\n    reconstruct_visit(node.right, \n          direct_right,\n          rights[0...right_index], \n          rights[right_index+1...index])\n  end\nend\n\ndef compare_by_preorder(array)\n  return -1 if array.size == 0\n  ordered_array = array.map do |item|\n    [item, $preorder.index(item)]\n  end\n  ordered_array.sort! {|x, y| x[1] <=> y[1]}\n  return ordered_array[0][0]\nend\n\ndef postorder(node, array)\n  if (node.left != nil) then\n    postorder(node.left, array)\n  end\n  if (node.right != nil) then\n    postorder(node.right, array)\n  end\n  array << node.id\nend\n\n\nn = gets.chomp.to_i\n$preorder = gets.chomp.split.map(&:to_i)\n$inorder = gets.chomp.split.map(&:to_i)\n\nroot_node = Node.new($preorder[0])\nroot_index = $inorder.index($preorder[0])\nreconstruct_visit(root_node, \n      root_index, \n      $inorder[0...root_index], \n      $inorder[root_index+1..-1])\n\npostorder_array = []\npostorder(root_node, postorder_array)\nputs postorder_array.join(' ')"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype node struct {\n\tnum    int\n\tparent *node\n\tleft   *node\n\tright  *node\n}\n\nfunc printPreOrder(sep *string, n *node) {\n\tif n == nil {\n\t\treturn\n\t}\n\tfmt.Printf(\"%s%d\", *sep, n.num)\n\t*sep = \" \"\n\tprintPreOrder(sep, n.left)\n\tprintPreOrder(sep, n.right)\n}\nfunc printInOrder(sep *string, n *node) {\n\tif n == nil {\n\t\treturn\n\t}\n\tprintInOrder(sep, n.left)\n\tfmt.Printf(\"%s%d\", *sep, n.num)\n\t*sep = \" \"\n\tprintInOrder(sep, n.right)\n}\nfunc printPostOrder(sep *string, n *node) {\n\tif n == nil {\n\t\treturn\n\t}\n\tprintPostOrder(sep, n.left)\n\tprintPostOrder(sep, n.right)\n\tfmt.Printf(\"%s%d\", *sep, n.num)\n\t*sep = \" \"\n}\n\nfunc partition(delim int, order []int) ([]int, []int) {\n\tfor i, e := range order {\n\t\tif e == delim {\n\t\t\treturn order[0:i], order[i+1 : len(order)]\n\t\t}\n\t}\n\treturn nil, nil\n}\n\nfunc recoverTree(parent *node, preIdx *int, preorder, inorder []int, tree []node) *node {\n\t// fmt.Printf(\"parent[%v] preIdx[%v] inorder[%v] tree[%v]\\n\", parent, *preIdx, inorder, tree)\n\t// 今訪れている先行巡回のnode\n\tme := &tree[*preIdx]\n\t// 親を設定\n\tme.parent = parent\n\n\t// 中間巡回から自分をみつけて左右のnodeにわける.\n\tleft, right := partition(me.num, inorder)\n\n\t// 左を復元\n\tif left != nil && len(left) > 0 {\n\t\t*preIdx++\n\t\tme.left = recoverTree(me, preIdx, preorder, left, tree)\n\t} else {\n\t\tme.left = nil\n\t}\n\n\t// 右を復元\n\tif right != nil && len(right) > 0 {\n\t\t*preIdx++\n\t\tme.right = recoverTree(me, preIdx, preorder, right, tree)\n\t} else {\n\t\tme.right = nil\n\t}\n\treturn me\n}\n\nfunc main() {\n\treader := bufio.NewReader(os.Stdin)\n\tnodeCount := eGetInt(reader)\n\tnodes := make([]node, nodeCount)\n\tpreorder := eAtoisMany(strings.Fields(eGetline(reader)))\n\tinorder := eAtoisMany(strings.Fields(eGetline(reader)))\n\tfor i := 0; i < nodeCount; i++ {\n\t\tnodes[i].num = preorder[i]\n\t}\n\n\tpreIdx := 0\n\trecoverTree(nil, &preIdx, preorder, inorder, nodes)\n\n\tfor i := range nodes {\n\t\tsep := \"\"\n\t\tif nodes[i].num == preorder[0] {\n\t\t\t// sep = \"\"\n\t\t\t// printPreOrder(&sep, &nodes[i])\n\t\t\t// fmt.Println()\n\t\t\t//\n\t\t\t// sep = \"\"\n\t\t\t// printInOrder(&sep, &nodes[i])\n\t\t\t// fmt.Println()\n\n\t\t\tsep = \"\"\n\t\t\tprintPostOrder(&sep, &nodes[i])\n\t\t\tfmt.Println()\n\t\t\tbreak\n\t\t}\n\t}\n}\nfunc eGetInt(reader *bufio.Reader) int {\n\treturn eAtoi(eGetline(reader))\n}\n\nfunc eGetline(o *bufio.Reader) string {\n\ts, err := o.ReadString(byte('\\n'))\n\tif err != nil {\n\t\tif err == io.EOF {\n\t\t\treturn s\n\t\t}\n\t\tlog.Fatal(err.Error())\n\t}\n\treturn s[:len(s)-1]\n}\n\nfunc eAtoisMany(s []string) []int {\n\tresult := make([]int, len(s))\n\tfor i := 0; i < len(s); i++ {\n\t\tresult[i] = eAtoi(s[i])\n\t}\n\treturn result\n}\n\nfunc eAtoi(s string) int {\n\tv, err := strconv.Atoi(s)\n\tif err != nil {\n\t\tlog.Fatal(err.Error())\n\t}\n\treturn v\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype Node struct {\n\tid    int\n\tleft  *Node\n\tright *Node\n}\n\nfunc main() {\n\tsc := bufio.NewScanner(os.Stdin)\n\tsc.Split(bufio.ScanWords)\n\tn, err := nextInt(sc)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tpre, err := nextInts(n, sc)\n\tin, err := nextInts(n, sc)\n\tresult := f(pre, in, pre[0])\n\tprintResult(result)\n}\n\nfunc find(x int, arr []int) int {\n\tfor i := 0; i < len(arr); i++ {\n\t\tif arr[i] == x {\n\t\t\treturn i\n\t\t}\n\t}\n\tpanic(fmt.Errorf(\"not found: %d\", x))\n}\n\nfunc f(pre []int, in []int, target int) []int {\n\tif len(in) == 1 {\n\t\treturn in\n\t}\n\n\ttargetIn := find(target, in)\n\n\tleft := in[0:targetIn]\n\tshortestLeft := len(pre)\n\tfor i := 0; i < targetIn; i++ {\n\t\tfor j := 0; j < len(pre); j++ {\n\t\t\tif pre[j] == left[i] && j < shortestLeft {\n\t\t\t\tshortestLeft = j\n\t\t\t}\n\t\t}\n\t}\n\tvar processedLeft []int\n\tif shortestLeft < len(pre) {\n\t\tprocessedLeft = f(pre, left, pre[shortestLeft])\n\t} else {\n\t\tprocessedLeft = make([]int, 0)\n\t}\n\n\tright := in[targetIn+1:]\n\tshortestRight := len(pre)\n\tfor i := 0; i < len(right); i++ {\n\t\tfor j := targetIn + 1; j < len(pre); j++ {\n\t\t\tif pre[j] == right[i] && j < shortestRight {\n\t\t\t\tshortestRight = j\n\t\t\t}\n\t\t}\n\t}\n\tvar processedRight []int\n\tif shortestRight < len(pre) {\n\t\tprocessedRight = f(pre, right, pre[shortestRight])\n\t} else {\n\t\tprocessedRight = make([]int, 0)\n\t}\n\n\treturn append(processedLeft, append(processedRight, target)...)\n}\n\nfunc nextInt(sc *bufio.Scanner) (int, error) {\n\tsc.Scan()\n\treturn strconv.Atoi(sc.Text())\n}\n\nfunc nextInts(n int, sc *bufio.Scanner) ([]int, error) {\n\trs := make([]int, n)\n\tfor i, _ := range rs {\n\t\tx, err := nextInt(sc)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\trs[i] = x\n\t}\n\treturn rs, nil\n}\n\nfunc printResult(result []int) {\n\tresultStr := make([]string, len(result))\n\tfor i := 0; i < len(resultStr); i++ {\n\t\tresultStr[i] = strconv.Itoa(result[i])\n\t}\n\tfmt.Println(strings.Join(resultStr, \" \"))\n}\n\n"
  },
  {
    "language": "Go",
    "code": "// AOJ ALDS1_7_D: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_7_D\n\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"strconv\"\n\t\"bufio\"\n\t\"os\"\n)\n\nvar sc = bufio.NewScanner(os.Stdin)\nvar pos int\nvar post []int\n\nfunc nextInt() int {\n\tsc.Scan()\n\tv, _ := strconv.Atoi(sc.Text())\n\treturn v\n}\n\nfunc index(a []int, key int) int {\n\tfor i, v := range a {\n\t\tif v == key {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc recursion(pre, in []int, l, r int) {\n\tif (l >= r) {\n\t\treturn\n\t}\n\n\t// 今見てるNode\n\troot := pre[pos]\n\tpos++\n\n\t// 今見てるNodeのinOrder順での位置\n\tm := index(in, root)\n\n\t// inOrderをmで左部分木と右部分木に分ける\n\trecursion(pre, in, l, m)\n\trecursion(pre, in, m+1, r)\n\tpost = append(post, root)\n}\n\nfunc reConstruct(pre, in []int) {\n\tpos = 0\n\trecursion(pre, in, 0, len(pre))\n\tpostOrder := make([]string, len(pre))\n\tfor i := 0; i < len(pre); i++ {\n\t\tpostOrder[i] = strconv.Itoa(post[i])\n\t}\n\tfmt.Println(strings.Join(postOrder, \" \"))\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\tn := nextInt()\n\n\tpreOrder := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tpreOrder[i] = nextInt()\n\t}\n\n\tinOrder := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tinOrder[i] = nextInt()\n\t}\n\n\treConstruct(preOrder, inOrder)\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\"strings\"\n)\n\nfunc getScanner(fp *os.File) *bufio.Scanner {\n\tscanner := bufio.NewScanner(fp)\n\tscanner.Split(bufio.ScanWords)\n\tscanner.Buffer(make([]byte, 500001), 500000)\n\treturn scanner\n}\n\nfunc getNextString(scanner *bufio.Scanner) string {\n\tscanner.Scan()\n\treturn scanner.Text()\n}\n\nfunc getNextInt(scanner *bufio.Scanner) int {\n\ti, _ := strconv.Atoi(getNextString(scanner))\n\treturn i\n}\n\nfunc main() {\n\tfp := os.Stdin\n\tif len(os.Args) > 1 {\n\t\tfp, _ = os.Open(os.Args[1])\n\t}\n\n\tscanner := getScanner(fp)\n\twriter := bufio.NewWriter(os.Stdout)\n\n\tvar chokudai Chokudai\n\tn := getNextInt(scanner)\n\tchokudai.preorders = make([]int, n)\n\tchokudai.inorders = make([]int, n)\n\tchokudai.postorders = make([]int, n)\n\tchokudai.pos = 0\n\tchokudai.n = n\n\tchokudai.i = 0\n\n\tfor i := 0; i < n; i++ {\n\t\tchokudai.preorders[i] = getNextInt(scanner)\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tchokudai.inorders[i] = getNextInt(scanner)\n\t}\n\n\tchokudai.rec(0, n)\n\n\tfmt.Fprintln(writer, joinint(chokudai.postorders, \" \"))\n\n\twriter.Flush()\n}\n\n// Chokudai solver\ntype Chokudai struct {\n\tpreorders  []int\n\tinorders   []int\n\tpostorders []int\n\tpos        int\n\tn          int\n\ti          int\n}\n\nfunc (c *Chokudai) rec(l, r int) {\n\tif l >= r {\n\t\treturn\n\t}\n\troot := c.preorders[c.pos]\n\tc.pos++\n\tfor i := l; i < r; i++ {\n\t\tif root != c.inorders[i] {\n\t\t\tcontinue\n\t\t}\n\t\tc.rec(l, i)\n\t\tc.rec(i+1, r)\n\t\tbreak\n\t}\n\tc.postorders[c.i] = root\n\tc.i++\n}\nfunc joinint(a []int, sep string) string {\n\tn := len(a)\n\tss := make([]string, n)\n\tfor i := 0; i < n; i++ {\n\t\tss[i] = fmt.Sprintf(\"%d\", a[i])\n\t}\n\treturn strings.Join(ss, sep)\n}\n\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nfunc nextString() string {\n\tscanner.Scan()\n\treturn scanner.Text()\n}\n\nfunc nextInt() int {\n\tn, err := strconv.Atoi(nextString())\n\tif err != nil {\n\t\tfmt.Printf(\"strconv.Atoi failed: %v\\n\", err)\n\t}\n\treturn n\n}\n\nfunc stringifyArray(arr []int) string {\n\treturn strings.TrimRight(fmt.Sprintf(\"%+v\", arr)[1:], \"]\")\n}\n\nfunc searchIdx(array []int, value int) int {\n\tfor i := range array {\n\t\tif array[i] == value {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc reconstruct(preorder []int, inorder []int) string {\n\tif len(preorder) == 0 {\n\t\treturn \"\"\n\t}\n\n\t// fmt.Println(preorder, inorder)\n\n\tmid := preorder[0]\n\tidxSplitAt := searchIdx(inorder, mid)\n\n\tl := inorder[:idxSplitAt]\n\tresult := []string{}\n\tleftResult := reconstruct(preorder[1:(len(l)+1)], l)\n\tif leftResult != \"\" {\n\t\tresult = append(result, leftResult)\n\t}\n\trightResult := reconstruct(preorder[(len(l)+1):], inorder[(idxSplitAt+1):])\n\tif rightResult != \"\" {\n\t\tresult = append(result, rightResult)\n\n\t}\n\tresult = append(result, strconv.Itoa(mid))\n\n\treturn strings.Join(result, \" \")\n}\n\nfunc main() {\n\tscanner.Split(bufio.ScanWords)\n\n\tnNodes := nextInt()\n\tpreorder := make([]int, nNodes)\n\tfor iNode := 0; iNode < nNodes; iNode++ {\n\t\tpreorder[iNode] = nextInt()\n\t}\n\tinorder := make([]int, nNodes)\n\tfor iNode := 0; iNode < nNodes; iNode++ {\n\t\tinorder[iNode] = nextInt()\n\t}\n\t// fmt.Println(preorder)\n\t// fmt.Println(inorder)\n\tfmt.Println(reconstruct(preorder, inorder))\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n)\n\n/*********** I/O ***********/\n\nvar (\n\t// ReadString returns a WORD string.\n\tReadString func() string\n\tstdout     *bufio.Writer\n)\n\nfunc init() {\n\tReadString = newReadString(os.Stdin)\n\tstdout = bufio.NewWriter(os.Stdout)\n}\n\nfunc newReadString(ior io.Reader) func() string {\n\tr := bufio.NewScanner(ior)\n\t// r.Buffer(make([]byte, 1024), int(1e+11)) // for AtCoder\n\tr.Buffer(make([]byte, 1024), int(1e+9)) // for Codeforces\n\t// Split sets the split function for the Scanner. The default split function is ScanLines.\n\t// Split panics if it is called after scanning has started.\n\tr.Split(bufio.ScanWords)\n\n\treturn func() string {\n\t\tif !r.Scan() {\n\t\t\tpanic(\"Scan failed\")\n\t\t}\n\t\treturn r.Text()\n\t}\n}\n\n// ReadInt returns an integer.\nfunc ReadInt() int {\n\treturn int(readInt64())\n}\nfunc ReadInt2() (int, int) {\n\treturn int(readInt64()), int(readInt64())\n}\nfunc ReadInt3() (int, int, int) {\n\treturn int(readInt64()), int(readInt64()), int(readInt64())\n}\nfunc ReadInt4() (int, int, int, int) {\n\treturn int(readInt64()), int(readInt64()), int(readInt64()), int(readInt64())\n}\n\n// ReadInt64 returns as integer as int64.\nfunc ReadInt64() int64 {\n\treturn readInt64()\n}\nfunc ReadInt64_2() (int64, int64) {\n\treturn readInt64(), readInt64()\n}\nfunc ReadInt64_3() (int64, int64, int64) {\n\treturn readInt64(), readInt64(), readInt64()\n}\nfunc ReadInt64_4() (int64, int64, int64, int64) {\n\treturn readInt64(), readInt64(), readInt64(), readInt64()\n}\n\nfunc readInt64() int64 {\n\ti, err := strconv.ParseInt(ReadString(), 0, 64)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn i\n}\n\n// ReadIntSlice returns an integer slice that has n integers.\nfunc ReadIntSlice(n int) []int {\n\tb := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = ReadInt()\n\t}\n\treturn b\n}\n\n// ReadInt64Slice returns as int64 slice that has n integers.\nfunc ReadInt64Slice(n int) []int64 {\n\tb := make([]int64, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = ReadInt64()\n\t}\n\treturn b\n}\n\n// ReadFloat64 returns an float64.\nfunc ReadFloat64() float64 {\n\treturn float64(readFloat64())\n}\n\nfunc readFloat64() float64 {\n\tf, err := strconv.ParseFloat(ReadString(), 64)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn f\n}\n\n// ReadFloatSlice returns an float64 slice that has n float64.\nfunc ReadFloat64Slice(n int) []float64 {\n\tb := make([]float64, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = ReadFloat64()\n\t}\n\treturn b\n}\n\n// ReadRuneSlice returns a rune slice.\nfunc ReadRuneSlice() []rune {\n\treturn []rune(ReadString())\n}\n\n/*********** Debugging ***********/\n\n// ZeroPaddingRuneSlice returns binary expressions of integer n with zero padding.\n// For debugging use.\nfunc ZeroPaddingRuneSlice(n, digitsNum int) []rune {\n\tsn := fmt.Sprintf(\"%b\", n)\n\n\tresidualLength := digitsNum - len(sn)\n\tif residualLength <= 0 {\n\t\treturn []rune(sn)\n\t}\n\n\tzeros := make([]rune, residualLength)\n\tfor i := 0; i < len(zeros); i++ {\n\t\tzeros[i] = '0'\n\t}\n\n\tres := []rune{}\n\tres = append(res, zeros...)\n\tres = append(res, []rune(sn)...)\n\n\treturn res\n}\n\n/*********** DP sub-functions ***********/\n\n// ChMin accepts a pointer of integer and a target value.\n// If target value is SMALLER than the first argument,\n//\tthen the first argument will be updated by the second argument.\nfunc ChMin(updatedValue *int, target int) bool {\n\tif *updatedValue > target {\n\t\t*updatedValue = target\n\t\treturn true\n\t}\n\treturn false\n}\n\n// ChMax accepts a pointer of integer and a target value.\n// If target value is LARGER than the first argument,\n//\tthen the first argument will be updated by the second argument.\nfunc ChMax(updatedValue *int, target int) bool {\n\tif *updatedValue < target {\n\t\t*updatedValue = target\n\t\treturn true\n\t}\n\treturn false\n}\n\n// NthBit returns nth bit value of an argument.\n// n starts from 0.\nfunc NthBit(num, nth int) int {\n\treturn num >> uint(nth) & 1\n}\n\n// OnBit returns the integer that has nth ON bit.\n// If an argument has nth ON bit, OnBit returns the argument.\nfunc OnBit(num, nth int) int {\n\treturn num | (1 << uint(nth))\n}\n\n// OffBit returns the integer that has nth OFF bit.\n// If an argument has nth OFF bit, OffBit returns the argument.\nfunc OffBit(num, nth int) int {\n\treturn num & ^(1 << uint(nth))\n}\n\n// PopCount returns the number of ON bit of an argument.\nfunc PopCount(num int) int {\n\tres := 0\n\n\tfor i := 0; i < 70; i++ {\n\t\tif ((num >> uint(i)) & 1) == 1 {\n\t\t\tres++\n\t\t}\n\t}\n\n\treturn res\n}\n\n/*********** Arithmetic ***********/\n\n// Max returns the max integer among input set.\n// This function needs at least 1 argument (no argument causes panic).\nfunc Max(integers ...int) int {\n\tm := integers[0]\n\tfor i, integer := range integers {\n\t\tif i == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif m < integer {\n\t\t\tm = integer\n\t\t}\n\t}\n\treturn m\n}\n\n// Min returns the min integer among input set.\n// This function needs at least 1 argument (no argument causes panic).\nfunc Min(integers ...int) int {\n\tm := integers[0]\n\tfor i, integer := range integers {\n\t\tif i == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif m > integer {\n\t\t\tm = integer\n\t\t}\n\t}\n\treturn m\n}\n\n// Sum returns multiple integers sum.\nfunc Sum(integers ...int) int {\n\ts := 0\n\n\tfor _, i := range integers {\n\t\ts += i\n\t}\n\n\treturn s\n}\n\n// PowInt is integer version of math.Pow\n// PowInt calculate a power by Binary Power (二分累乗法(O(log e))).\nfunc PowInt(a, e int) int {\n\tif a < 0 || e < 0 {\n\t\tpanic(errors.New(\"[argument error]: PowInt does not accept negative integers\"))\n\t}\n\n\tif e == 0 {\n\t\treturn 1\n\t}\n\n\tif e%2 == 0 {\n\t\thalfE := e / 2\n\t\thalf := PowInt(a, halfE)\n\t\treturn half * half\n\t}\n\n\treturn a * PowInt(a, e-1)\n}\n\n// AbsInt is integer version of math.Abs\nfunc AbsInt(a int) int {\n\tif a < 0 {\n\t\treturn -a\n\t}\n\treturn a\n}\n\n// Gcd returns the Greatest Common Divisor of two natural numbers.\n// Gcd only accepts two natural numbers (a, b >= 1).\n// 0 or negative number causes panic.\n// Gcd uses the Euclidean Algorithm.\nfunc Gcd(a, b int) int {\n\tif a <= 0 || b <= 0 {\n\t\tpanic(errors.New(\"[argument error]: Gcd only accepts two NATURAL numbers\"))\n\t}\n\tif a < b {\n\t\ta, b = b, a\n\t}\n\n\t// Euclidean Algorithm\n\tfor b > 0 {\n\t\tdiv := a % b\n\t\ta, b = b, div\n\t}\n\n\treturn a\n}\n\n// Lcm returns the Least Common Multiple of two natural numbers.\n// Lcd only accepts two natural numbers (a, b >= 1).\n// 0 or negative number causes panic.\n// Lcd uses the Euclidean Algorithm indirectly.\nfunc Lcm(a, b int) int {\n\tif a <= 0 || b <= 0 {\n\t\tpanic(errors.New(\"[argument error]: Gcd only accepts two NATURAL numbers\"))\n\t}\n\n\t// a = a'*gcd, b = b'*gcd, a*b = a'*b'*gcd^2\n\t// a' and b' are relatively prime numbers\n\t// gcd consists of prime numbers, that are included in a and b\n\tgcd := Gcd(a, b)\n\n\t// not (a * b / gcd), because of reducing a probability of overflow\n\treturn (a / gcd) * b\n}\n\n// Strtoi is a wrapper of strconv.Atoi().\n// If strconv.Atoi() returns an error, Strtoi calls panic.\nfunc Strtoi(s string) int {\n\tif i, err := strconv.Atoi(s); err != nil {\n\t\tpanic(errors.New(\"[argument error]: Strtoi only accepts integer string\"))\n\t} else {\n\t\treturn i\n\t}\n}\n\n// PrintIntsLine returns integers string delimited by a space.\nfunc PrintIntsLine(A ...int) string {\n\tres := []rune{}\n\n\tfor i := 0; i < len(A); i++ {\n\t\tstr := strconv.Itoa(A[i])\n\t\t// str := strconv.FormatInt(A[i], 10)  // 64bit int version\n\t\tres = append(res, []rune(str)...)\n\n\t\tif i != len(A)-1 {\n\t\t\tres = append(res, ' ')\n\t\t}\n\t}\n\n\treturn string(res)\n}\n\n/********** FAU standard libraries **********/\n\n//fmt.Sprintf(\"%b\\n\", 255) \t// binary expression\n\n/********** I/O usage **********/\n\n//str := ReadString()\n//i := ReadInt()\n//X := ReadIntSlice(n)\n//S := ReadRuneSlice()\n//a := ReadFloat64()\n//A := ReadFloat64Slice(n)\n\n//str := ZeroPaddingRuneSlice(num, 32)\n//str := PrintIntsLine(X...)\n\n/*******************************************************************/\n\nconst MOD = 1000000000 + 7\nconst ALPHABET_NUM = 26\nconst INF_INT64 = math.MaxInt64\nconst INF_BIT60 = 1 << 60\n\nfunc main() {\n\tn = ReadInt()\n\tpre, in = ReadIntSlice(n), ReadIntSlice(n)\n\n\tsolve()\n}\n\nvar n, pos int\nvar pre, in, post []int\n\nfunc Reconstruction(l, r int) {\n\tif l >= r {\n\t\treturn\n\t}\n\n\troot := pre[pos]\n\tpos++\n\t// 線形探索\n\tm := -1\n\tfor i := 0; i < n; i++ {\n\t\tif in[i] == root {\n\t\t\tm = i\n\t\t\tbreak\n\t\t}\n\t}\n\tReconstruction(l, m)\n\tReconstruction(m+1, r)\n\tpost = append(post, root)\n}\n\nfunc solve() {\n\tpos = 0\n\n\tReconstruction(0, len(pre))\n\tfmt.Println(PrintIntsLine(post...))\n}\n\n// MODはとったか？\n// 遷移だけじゃなくて最後の最後でちゃんと取れよ？\n\n/*******************************************************************/\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nconst MAX = 40\n\nvar IN [MAX]int\nvar PRE [MAX]int\nvar index int\n\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc scanInt() int {\n\tnum, _ := strconv.Atoi(scanString())\n\treturn num\n}\n\nfunc scanString() string {\n\tsc.Scan()\n\treturn sc.Text()\n}\n\nfunc init() {\n\tsc.Split(bufio.ScanWords)\n}\nfunc findIndex(n int) int {\n\tfor i, e := range IN {\n\t\tif e == n {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc setTree(left, right int, ans *[]int) {\n\tif left >= right {\n\t\treturn\n\t}\n\tc := PRE[index]\n\tm := findIndex(c)\n\tindex++\n\tsetTree(left, m, ans)\n\tsetTree(m+1, right, ans)\n\t*ans = append(*ans, c)\n}\n\nfunc main() {\n\tn := scanInt()\n\tfor i := 0; i < n; i++ {\n\t\tPRE[i] = scanInt()\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tIN[i] = scanInt()\n\t}\n\tans := make([]int, 0)\n\tsetTree(0, n, &ans)\n\tfmt.Println(strings.Trim(fmt.Sprint(ans), \"[]\"))\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n)\n\ntype Node struct {\n\tId int\n\tLeft *Node\n\tRight *Node\n}\n\nfunc main() {\n\tvar n int\n\tfmt.Scan(&n)\n\n\tpre := make([]int, n)\n\tin := make([]int, n)\n\n\tfor i := 0; i < n ; i++ {\n\t\tfmt.Scan(&pre[i])\n\t}\n\tfor i := 0; i < n ; i++ {\n\t\tfmt.Scan(&in[i])\n\t}\n\n\troot := createTree(pre, in)\n\tqueue := []int{}\n\tqueuePostorder(&root, &queue)\n\tfmt.Print(queue[0])\n\tfor i := 1; i < n; i++ {\n\t\tfmt.Printf(\" %d\", queue[i])\n\t}\n\tfmt.Println()\n}\n\nfunc createTree(pre []int, in []int) Node {\n\troot := Node{pre[0], nil, nil}\n\t\n\ti := 0\n\tleftPre := []int{}\n\tleftIn  := []int{}\n\tfor ; i < len(in); i++ {\n\t\tif in[i] == root.Id {\n\t\t\tbreak\n\t\t}\n\t\tleftPre = append(leftPre, pre[i+1])\n\t\tleftIn = append(leftIn, in[i])\n\t}\n\tif len(leftPre) > 0 {\n\t\tleft := createTree(leftPre, leftIn)\n\t\troot.Left = &left\n\t}\n\n\ti += 1\n\trightPre := []int{}\n\trightIn  := []int{}\n\tfor ; i < len(in); i++ {\n\t\trightPre = append(rightPre, pre[i])\n\t\trightIn = append(rightIn, in[i])\n\t}\n\tif len(rightPre) > 0 {\n\t\tright := createTree(rightPre, rightIn)\n\t\troot.Right = &right\n\t}\n\n\treturn root\n}\n\nfunc queuePostorder(node *Node, queue *[]int) {\n\tif node == nil {\n\t\treturn\n\t}\n\tqueuePostorder((*node).Left, queue)\n\tqueuePostorder((*node).Right, queue)\n\t*queue = append(*queue, (*node).Id)\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc scanInput() (n int, pre []int, in []int) {\n    fmt.Scanf(\"%d\", &n)\n    pre = make([]int, n)\n    in = make([]int, n)\n    for i := 0; i < n; i++ {\n        fmt.Scanf(\"%d\", &pre[i])\n    }\n    for i := 0; i < n; i++ {\n        fmt.Scanf(\"%d\", &in[i])\n    }\n    return\n}\n\nfunc printSlice(slice []int) {\n    fmt.Println(strings.Trim(strings.Join(strings.Fields(fmt.Sprint(slice)), \" \"), \"[]\"))\n}\n\nfunc main() {\n    n, pre, in := scanInput()\n    post := make([]int, 0, n)\n    parent := 0\n\n    walk(0, len(pre)-1, &parent, pre, in, &post)\n\n    printSlice(post)\n}\n\nfunc walk(left, right int, parent *int, pre, in []int, post *[]int) {\n    if left > right {\n        return\n    }\n\n    dlm := pre[*parent]\n    *parent++\n\n    var idx int\n    for i, v := range in {\n        if v == dlm {\n            idx = i\n            break\n        }\n    }\n\n    walk(left, idx-1, parent, pre, in, post)\n    walk(idx+1, right, parent, pre, in, post)\n\n    *post = append(*post, dlm)\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nvar pos int\n\ntype Order struct {\n\tpre, in, post []int\n}\n\nfunc (o *Order) rec(l, r int) {\n\tif l >= r {\n\t\treturn\n\t}\n\troot := o.pre[pos]\n\tpos++\n\n\tvar m int\n\tfor i, elem := range o.in {\n\t\tif elem == root {\n\t\t\tm = i\n\t\t\tbreak\n\t\t}\n\t}\n\n\to.rec(l, m)\n\to.rec(m+1, r)\n\to.post = append(o.post, root)\n}\n\nfunc (o *Order) solve() string {\n\tvar out bytes.Buffer\n\n\to.rec(0, len(o.pre))\n\tfor i := 0; i < len(o.pre); i++ {\n\t\tout.WriteString(fmt.Sprintf(\"%d \", o.post[i]))\n\t}\n\n\treturn strings.TrimRight(out.String(), \" \")\n}\n\nfunc answer(reader io.Reader) string {\n\tsc := bufio.NewScanner(reader)\n\tsc.Split(bufio.ScanWords)\n\n\tsc.Scan()\n\tn, _ := strconv.Atoi(sc.Text())\n\n\tvar order Order\n\tfor i := 0; i < n; i++ {\n\t\tsc.Scan()\n\t\tk, _ := strconv.Atoi(sc.Text())\n\t\torder.pre = append(order.pre, k)\n\t}\n\n\tfor i := 0; i < n; i++ {\n\t\tsc.Scan()\n\t\tk, _ := strconv.Atoi(sc.Text())\n\t\torder.in = append(order.in, k)\n\t}\n\n\treturn order.solve()\n}\n\nfunc main() {\n\tfmt.Println(answer(os.Stdin))\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc nextInt(scanner *bufio.Scanner) int {\n\tscanner.Scan()\n\tnum, _ := strconv.Atoi(scanner.Text())\n\treturn num\n}\n\nfunc scanIntArray() []int {\n\tsc := bufio.NewScanner(os.Stdin)\n\tsc.Split(bufio.ScanWords)\n\tn := nextInt(sc)\n\tresult := []int{}\n\tfor i := 0; i < n; i++ {\n\t\tresult = append(result, nextInt(sc))\n\t}\n\n\treturn result\n}\n\nvar pre []int\nvar in []int\n\nfunc main() {\n\tsc := bufio.NewScanner(os.Stdin)\n\tsc.Split(bufio.ScanWords)\n\tn := nextInt(sc)\n\n\tfor i := 0; i < n; i++ {\n\t\tpre = append(pre, nextInt(sc))\n\t}\n\n\tfor i := 0; i < n; i++ {\n\t\tin = append(in, nextInt(sc))\n\t}\n\n\tidx = 0\n\n\t// fmt.Println(n)\n\t// fmt.Println(pre)\n\t// fmt.Println(in)\n\n\trec(0, n)\n\n\tfor i, v := range result {\n\t\tif i != 0 {\n\t\t\tfmt.Print(\" \")\n\t\t}\n\t\tfmt.Print(v)\n\t}\n\tfmt.Println()\n}\n\nvar result []int\n\nfunc rec(l int, r int) {\n\tif l >= r {\n\t\treturn\n\t}\n\n\tc := next(pre)\n\tm := find(in, c)\n\trec(l, m)\n\trec(m+1, r)\n\tresult = append(result, c)\n}\n\nvar idx int\n\nfunc next(pre []int) int {\n\tresult := pre[idx]\n\tidx++\n\treturn result\n}\n\nfunc find(in []int, c int) int {\n\tfor i, v := range in {\n\t\tif c == v {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n//input\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc nextStr() string {\n\tsc.Scan()\n\treturn sc.Text()\n}\n\nfunc nextInt() int {\n\tsc.Scan()\n\ti, e := strconv.Atoi(sc.Text())\n\tif e != nil {\n\t\tpanic(e)\n\t}\n\treturn i\n}\n\n//solve\ntype Node struct {\n\tid int\n\tp  int\n\tl  int\n\tr  int\n}\n\nconst MAX = 10000\nconst NIL = -1\n\nvar T [MAX]Node\nvar n int\nvar pos int\nvar post []int\n\nfunc preParse(u int) {\n\tif u == NIL {\n\t\treturn\n\t}\n\tfmt.Printf(\" %d\", u)\n\tpreParse(T[u].l)\n\tpreParse(T[u].r)\n}\n\nfunc inParse(u int) {\n\tif u == NIL {\n\t\treturn\n\t}\n\tinParse(T[u].l)\n\tfmt.Printf(\" %d\", u)\n\tinParse(T[u].r)\n}\n\nfunc postParse(u int) {\n\tif u == NIL {\n\t\treturn\n\t}\n\tpostParse(T[u].l)\n\tpostParse(T[u].r)\n\tfmt.Printf(\" %d\", u)\n\n}\n\nfunc solve(pre []int, in []int, l int, r int) {\n\tif l >= r {\n\t\treturn\n\t}\n\n\t//posは、現在訪問中の節\n\troot := pre[pos]\n\tpos++\n\n\tm := index(in, root)\n\n\t//左側の部分木\n\tsolve(pre, in, l, m)\n\t//右側の部分木\n\tsolve(pre, in, m+1, r)\n\tpost = append(post, root)\n}\n\nfunc index(l []int, t int) int {\n\tfor i, v := range l {\n\t\tif v == t {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc rec(pre, in []int) {\n\tpos = 0\n\t//preの両端を\n\tsolve(pre, in, 0, len(pre))\n\tpostOrder := make([]string, len(pre))\n\tfor i := 0; i < len(pre); i++ {\n\t\tpostOrder[i] = strconv.Itoa(post[i])\n\t}\n\tfmt.Println(strings.Join(postOrder, \" \"))\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\tn = nextInt()\n\n\tpre := make([]int, n)\n\tin := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tpre[i] = nextInt()\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tin[i] = nextInt()\n\t}\n\n\trec(pre, in)\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\ntype Node struct {\n\tid    int\n\tleft  *Node\n\tright *Node\n}\n\nfunc main() {\n\tsc := bufio.NewScanner(os.Stdin)\n\tsc.Split(bufio.ScanWords)\n\tn, err := nextInt(sc)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tpre, err := nextInts(n, sc)\n\tin, err := nextInts(n, sc)\n\tfmt.Println(f(pre, in, pre[0]))\n}\n\nfunc find(x int, arr []int) int {\n\tfor i := 0; i < len(arr); i++ {\n\t\tif arr[i] == x {\n\t\t\treturn i\n\t\t}\n\t}\n\tpanic(fmt.Errorf(\"not found: %d\", x))\n}\n\nfunc f(pre []int, in []int, target int) []int {\n\tif len(in) == 1 {\n\t\treturn in\n\t}\n\n\ttargetIn := find(target, in)\n\n\tleft := in[0:targetIn]\n\tshortestLeft := len(pre)\n\tfor i := 0; i < targetIn; i++ {\n\t\tfor j := 0; j < len(pre); j++ {\n\t\t\tif pre[j] == left[i] && j < shortestLeft {\n\t\t\t\tshortestLeft = j\n\t\t\t}\n\t\t}\n\t}\n\tvar processedLeft []int\n\tif shortestLeft < len(pre) {\n\t\tprocessedLeft = f(pre, left, pre[shortestLeft])\n\t} else {\n\t\tprocessedLeft = make([]int, 0)\n\t}\n\n\tright := in[targetIn+1:]\n\tshortestRight := len(pre)\n\tfor i := 0; i < len(right); i++ {\n\t\tfor j := targetIn + 1; j < len(pre); j++ {\n\t\t\tif pre[j] == right[i] && j < shortestRight {\n\t\t\t\tshortestRight = j\n\t\t\t}\n\t\t}\n\t}\n\tvar processedRight []int\n\tif shortestRight < len(pre) {\n\t\tprocessedRight = f(pre, right, pre[shortestRight])\n\t} else {\n\t\tprocessedRight = make([]int, 0)\n\t}\n\n\treturn append(processedLeft, append(processedRight, target)...)\n}\n\nfunc nextInt(sc *bufio.Scanner) (int, error) {\n\tsc.Scan()\n\treturn strconv.Atoi(sc.Text())\n}\n\nfunc nextInts(n int, sc *bufio.Scanner) ([]int, error) {\n\trs := make([]int, n)\n\tfor i, _ := range rs {\n\t\tx, err := nextInt(sc)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\trs[i] = x\n\t}\n\treturn rs, nil\n}\n\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nsolve1();\n// walk();\n\n// 自力解\nfunction solve1(){\n\t$n = (int)trim(fgets(STDIN));\n\n\t$list = [];\n\tfor ($i=0; $i < $n; $i++) { \n\t\t$node = new BTreeNode($i+1);\n\t\t$list[$node->getId()] = $node;\n\t}\n\t$preorder = [];\n\t$input = explode(' ', trim(fgets(STDIN)));\n\tfor ($i=0; $i < $n; $i++) { \n\t\t$preorder[] = (int)$input[$i];\n\t}\n\t$inorder = [];\n\t$input = explode(' ', trim(fgets(STDIN)));\n\tfor ($i=0; $i < $n; $i++) { \n\t\t$inorder[] = (int)$input[$i];\n\t}\n\t$end = $n;\n\tdfs($preorder, $inorder, $list, $preorder[0]);\n\t$res = [];\n\t$res = postorderWalk($list, $preorder[0], $res);\n\techo implode(' ', $res) . PHP_EOL;\n}\n\nfunction dfs($preorder, $inorder, $list, $p){\n\t$children = getChildren($inorder, $p);\n\tif (count($children['left']) === 1) {\n\t\t$list[$p]->setLeft($children['left'][0]);\n\t\t$list[$children['left'][0]]->setParentId($p);\n\t}elseif(count($children['left']) > 1){\n\t\t$p_left = null;\n\t\tforeach ($preorder as $pre) {\n\t\t\tif (in_array($pre, $children['left'])) {\n\t\t\t\t$p_left = $pre;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t$list[$p]->setLeft($p_left);\n\t\t$list[$p_left]->setParentId($p);\n\t\tdfs($preorder, $children['left'], $list, $p_left);\n\t}\n\n\tif (count($children['right']) === 1) {\n\t\t$list[$p]->setRight($children['right'][0]);\n\t\t$list[$children['right'][0]]->setParentId($p);\n\t}elseif(count($children['right']) > 1){\n\t\t$p_right = null;\n\t\tforeach ($preorder as $pre) {\n\t\t\tif (in_array($pre, $children['right'])) {\n\t\t\t\t$p_right = $pre;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t$list[$p]->setRight($p_right);\n\t\t$list[$p_right]->setParentId($p);\n\t\tdfs($preorder, $children['right'], $list, $p_right);\n\t}\n}\n\nfunction getChildren($inorder, $p){\n\t$n = count($inorder);\n\t$left = [];\n\t$right = [];\n\t$r_flg = false;\n\tfor ($i=0; $i < $n; $i++) { \n\t\tif ($inorder[$i] === $p) {\n\t\t\t$r_flg = true;\n\t\t}else{\n\t\t\tif ($r_flg) {\n\t\t\t\t$right[] = $inorder[$i];\n\t\t\t}else{\n\t\t\t\t$left[] = $inorder[$i];\n\t\t\t}\n\t\t}\n\t}\n\treturn [\n\t\t'left' => $left,\n\t\t'right' => $right,\n\t];\n}\n// function dfs($list, $id, $depth){\n// \t$list[$id]->setDepth($depth);\n// \t++$depth;\n// \t$height = 0;\n// \tif($list[$id]->hasChild()){\n// \t\t$children = $list[$id]->getChildren();\n// \t\tforeach ($children as $c) {\n// \t\t\t$h = dfs($list, $c, $depth);\n// \t\t\t$height = max($height, $h);\n// \t\t}\n// \t}\n// \t$list[$id]->setHeight($height);\n// \treturn ++$height;\n// }\n\n// function walk(){\n// \t$n = (int)trim(fgets(STDIN));\n\n// \t$list = [];\n// \tfor ($i=0; $i < $n; $i++) { \n// \t\t$node = new BTreeNode($i);\n// \t\t$list[$node->getId()] = $node;\n// \t}\n// \tfor ($i=0; $i < $n; $i++) { \n// \t\t$input = explode(' ', trim(fgets(STDIN)));\n// \t\t$id = (int)$input[0];\n// \t\t$list[$id]->setLeft((int)$input[1]);\n// \t\tif (isset($list[(int)$input[1]])) {\n// \t\t\t$list[(int)$input[1]]->setParentId($id);\n// \t\t}\n// \t\t$list[$id]->setRight((int)$input[2]);\n// \t\tif (isset($list[(int)$input[2]])) {\n// \t\t\t$list[(int)$input[2]]->setParentId($id);\n// \t\t}\n// \t}\n// \tfor ($i=0; $i < $n; $i++) { \n// \t\tif ($list[$i]->getParentId() === -1) {\n// \t\t\t// root\n// \t\t\t$curId = $i;\n// \t\t\tbreak;\n// \t\t}\n// \t}\n// \techo 'Preorder' . PHP_EOL;\n// \tpreorderWalk($list, $curId);\n// \techo PHP_EOL;\n\n// \techo 'Inorder' . PHP_EOL;\n// \tinorderWalk($list, $curId);\n// \techo PHP_EOL;\n\n// \techo 'Postorder' . PHP_EOL;\n// \tpostorderWalk($list, $curId);\n// \techo PHP_EOL;\n\n// }\n\n\nfunction preorderWalk($list, $id){\n\techo ' ' . $id;\n\tif ($list[$id]->hasLeft()) {\n\t\tpreorderWalk($list, $list[$id]->getLeft());\n\t}\n\tif ($list[$id]->hasRight()) {\n\t\tpreorderWalk($list, $list[$id]->getRight());\n\t}\n}\n\nfunction inorderWalk($list, $id){\n\tif ($list[$id]->hasLeft()) {\n\t\tinorderWalk($list, $list[$id]->getLeft());\n\t}\n\techo ' ' . $id;\n\tif ($list[$id]->hasRight()) {\n\t\tinorderWalk($list, $list[$id]->getRight());\n\t}\n}\nfunction postorderWalk($list, $id, $result){\n\tif ($list[$id]->hasLeft()) {\n\t\t$result = postorderWalk($list, $list[$id]->getLeft(), $result);\n\t}\n\tif ($list[$id]->hasRight()) {\n\t\t$result = postorderWalk($list, $list[$id]->getRight(), $result);\n\t}\n\t$result[] = $id;\n\treturn $result;\n}\n\nclass BTreeNode\n{\n\tprivate $id;\n\tprivate $depth = 0;\n\tprivate $height = 0;\n\tprivate $parent_id = -1;\n\tprivate $left = -1;\n\tprivate $right = -1;\n\n\tfunction __construct($id)\n\t{\n\t\t$this->id = $id;\n\t}\n\tfunction setParentId($p_id){\n\t\t$this->parent_id = $p_id;\n\t}\n\tfunction setLeft($l_id){\n\t\t$this->left = $l_id;\n\t}\n\tfunction setRight($r_id){\n\t\t$this->right = $r_id;\n\t}\n\tfunction getId(){\n\t\treturn $this->id;\n\t}\n\tfunction getParentId(){\n\t\treturn $this->parent_id;\n\t}\n\tfunction getLeft(){\n\t\treturn $this->left;\n\t}\n\tfunction getRight(){\n\t\treturn $this->right;\n\t}\n\tfunction hasChild(){\n\t\treturn ($this->left !== -1) || ($this->right !== -1);\n\t}\n\tfunction getChildren(){\n\t\t$children = [];\n\t\tif ($this->hasLeft()) {\n\t\t\t$children[] = $this->left;\n\t\t}\n\t\tif ($this->hasRight()) {\n\t\t\t$children[] = $this->right;\n\t\t}\n\t\treturn $children;\n\t}\n\tfunction getAnotherChild($c_id){\n\t\t$c = -1;\n\t\tif ($this->getLeft() === $c_id) {\n\t\t\t$c = $this->getRight();\n\t\t}elseif ($this->getRight() === $c_id) {\n\t\t\t$c = $this->getLeft();\n\t\t}\n\t\treturn $c;\n\t}\n\tfunction hasLeft(){\n\t\treturn $this->left !== -1;\n\t}\n\tfunction hasRight(){\n\t\treturn $this->right !== -1;\n\t}\n\tfunction setDepth($d){\n\t\t$this->depth = $d;\n\t}\n\tfunction addDepth(){\n\t\t$this->depth += 1;\n\t}\n\tfunction getDepth(){\n\t\treturn $this->depth;\n\t}\n\tfunction setHeight($h){\n\t\t$this->height = $h;\n\t}\n\tfunction getHeight(){\n\t\treturn $this->height;\n\t}\n}\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$nl=(int)trim(fgets(STDIN));\n$prtw=explode(' ',trim(fgets(STDIN)));\n$intw=explode(' ',trim(fgets(STDIN)));\n \n$pstw=array();\nfor($i=0;$i<$nl;$i++){$pstw[]=0;}\n \nfunction to_pstw($pri,$ini,$psi,$nl){\n    global $prtw,$intw,$pstw;\n \n    $a=$prtw[$pri];\n    $pstw[$psi+$nl-1]=$a;\n \n    if($nl<=1){return;}\n \n    $i=0;\n    while($intw[$ini+$i]!=$a){++$i;}\n \n    if($i>0){to_pstw($pri+1,$ini,$psi,$i);}\n    if($nl-$i-1>0){to_pstw($pri+$i+1,$ini+$i+1,$psi+$i,$nl-$i-1);}\n}\n \nto_pstw(0,0,0,$nl);\nprintf($pstw[0]);\nfor($i=1;$i<$nl;$i++){printf(\" %d\",$pstw[$i]);}\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n$nl=(int)trim(fgets(STDIN));\n$prtw=explode(' ',trim(fgets(STDIN)));\n$intw=explode(' ',trim(fgets(STDIN)));\n\n$pstw=array($nl);\nfor($i=0;$i<$nl;$i++){$pstw[$i]=0;}\n\nfunction to_pstw($pri,$ini,$psi,$nl){\n\tglobal $prtw,$intw,$pstw;\n\n\t$a=$prtw[$pri];\n\t$pstw[$psi+$nl-1]=$a;\n\n\tif($nl<=1){return;}\n\n\t$i=0;\n\twhile($intw[$ini+$i]!=$a){++$i;}\n\n\tif($i>0){to_pstw($pri+1,$ini,$psi,$i);}\n\tif($nl-$i-1>0){to_pstw($pri+$i+1,$ini+$i+1,$psi+$i,$nl-$i-1);}\n}\n\nto_pstw(0,0,0,$nl);\nprintf($pstw[0]);\nfor($i=1;$i<$nl;$i++){printf(\" %d\",$pstw[1]);}\nprintf(\"\\n\");"
  },
  {
    "language": "PHP",
    "code": "<?php\n$nl=(int)trim(fgets(STDIN));\n$prtw=explode(' ',trim(fgets(STDIN)));\n$intw=explode(' ',trim(fgets(STDIN)));\n \n$pstw=array($nl);\nfor($i=0;$i<$nl;$i++){$pstw[$i]=0;}\n \nfunction to_pstw($pri,$ini,$psi,$nl){\n    global $prtw,$intw,$pstw;\n \n    $a=$prtw[$pri];\n    $pstw[$psi+$nl-1]=$a;\n \n    if($nl<=1){return;}\n \n    $i=0;\n    while($intw[$ini+$i]!=$a){++$i;}\n \n    if($i>0){to_pstw($pri+1,$ini,$psi,$i);}\n    if($nl-$i-1>0){to_pstw($pri+$i+1,$ini+$i+1,$psi+$i,$nl-$i-1);}\n}\n \nto_pstw(0,0,0,$nl);\nprintf($pstw[0]);\nfor($i=1;$i<$nl;$i++){printf(\" %d\",$pstw[$i]);}\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n$nl=(int)trim(fgets(STDIN));\n$prtw=explode(' ',trim(fgets(STDIN)));\n$intw=explode(' ',trim(fgets(STDIN)));\n\n$pstw=array($nl);\nfor($i=0;$i<$nl;$i++){$pstw[$i]=0;}\n\nfunction to_pstw($pri,$ini,$psi,$nl){\n\tglobal $prtw,$intw,$pstw;\n\n\t$a=$prtw[$pri];\n\t$pstw[$psi+$nl-1]=$a;\n\n\tif($nl<=1){return;}\n\n\t$i=0;\n\twhile($intw[$ini+$i]!=$a){++$i;}\n\n\tif($i>0){to_pstw($pri+1,$ini,$psi,$i);}\n\tif($nl-$i-1>0){to_pstw($pri+$i+1,$ini+$i+1,$psi+$i,$nl-$i-1);}\n}\n\nto_pstw(0,0,0,$nl);\nprintf($pstw[0]);\nfor($i=1;$i<$nl;$i++){printf(\" %d\",$pstw[$i]);}\nprintf(\"\\n\");"
  },
  {
    "language": "PHP",
    "code": "<?php\nsolve1();\n// walk();\n\n// 自力解\nfunction solve1(){\n\t$n = (int)trim(fgets(STDIN));\n\n\t$list = [];\n\tfor ($i=0; $i < $n; $i++) { \n\t\t$node = new BTreeNode($i+1);\n\t\t$list[$node->getId()] = $node;\n\t}\n\t$preorder = [];\n\t$input = explode(' ', trim(fgets(STDIN)));\n\tfor ($i=0; $i < $n; $i++) { \n\t\t$preorder[] = (int)$input[$i];\n\t}\n\t$inorder = [];\n\t$input = explode(' ', trim(fgets(STDIN)));\n\tfor ($i=0; $i < $n; $i++) { \n\t\t$inorder[] = (int)$input[$i];\n\t}\n\t$end = $n;\n\tdfs($preorder, $inorder, $list, $preorder[0]);\n\t$res = [];\n\t$res = postorderWalk($list, $preorder[0], $res);\n\techo implode(' ', $res) . PHP_EOL;\n}\n\nfunction dfs($preorder, $inorder, $list, $p){\n\t$children = getChildren($inorder, $p);\n\tif (count($children['left']) === 1) {\n\t\t$list[$p]->setLeft($children['left'][0]);\n\t\t$list[$children['left'][0]]->setParentId($p);\n\t}elseif(count($children['left']) > 1){\n\t\t$p_left = null;\n\t\tforeach ($preorder as $pre) {\n\t\t\tif (in_array($pre, $children['left'])) {\n\t\t\t\t$p_left = $pre;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t$list[$p]->setLeft($p_left);\n\t\t$list[$p_left]->setParentId($p);\n\t\tdfs($preorder, $children['left'], $list, $p_left);\n\t}\n\n\tif (count($children['right']) === 1) {\n\t\t$list[$p]->setRight($children['right'][0]);\n\t\t$list[$children['right'][0]]->setParentId($p);\n\t}elseif(count($children['right']) > 1){\n\t\t$p_right = null;\n\t\tforeach ($preorder as $pre) {\n\t\t\tif (in_array($pre, $children['right'])) {\n\t\t\t\t$p_right = $pre;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t$list[$p]->setRight($p_right);\n\t\t$list[$p_right]->setParentId($p);\n\t\tdfs($preorder, $children['right'], $list, $p_right);\n\t}\n}\n\nfunction getChildren($inorder, $p){\n\t$n = count($inorder);\n\t$left = [];\n\t$right = [];\n\t$r_flg = false;\n\tfor ($i=0; $i < $n; $i++) { \n\t\tif ($inorder[$i] === $p) {\n\t\t\t$r_flg = true;\n\t\t}else{\n\t\t\tif ($r_flg) {\n\t\t\t\t$right[] = $inorder[$i];\n\t\t\t}else{\n\t\t\t\t$left[] = $inorder[$i];\n\t\t\t}\n\t\t}\n\t}\n\treturn [\n\t\t'left' => $left,\n\t\t'right' => $right,\n\t];\n}\n// function dfs($list, $id, $depth){\n// \t$list[$id]->setDepth($depth);\n// \t++$depth;\n// \t$height = 0;\n// \tif($list[$id]->hasChild()){\n// \t\t$children = $list[$id]->getChildren();\n// \t\tforeach ($children as $c) {\n// \t\t\t$h = dfs($list, $c, $depth);\n// \t\t\t$height = max($height, $h);\n// \t\t}\n// \t}\n// \t$list[$id]->setHeight($height);\n// \treturn ++$height;\n// }\n\n// function walk(){\n// \t$n = (int)trim(fgets(STDIN));\n\n// \t$list = [];\n// \tfor ($i=0; $i < $n; $i++) { \n// \t\t$node = new BTreeNode($i);\n// \t\t$list[$node->getId()] = $node;\n// \t}\n// \tfor ($i=0; $i < $n; $i++) { \n// \t\t$input = explode(' ', trim(fgets(STDIN)));\n// \t\t$id = (int)$input[0];\n// \t\t$list[$id]->setLeft((int)$input[1]);\n// \t\tif (isset($list[(int)$input[1]])) {\n// \t\t\t$list[(int)$input[1]]->setParentId($id);\n// \t\t}\n// \t\t$list[$id]->setRight((int)$input[2]);\n// \t\tif (isset($list[(int)$input[2]])) {\n// \t\t\t$list[(int)$input[2]]->setParentId($id);\n// \t\t}\n// \t}\n// \tfor ($i=0; $i < $n; $i++) { \n// \t\tif ($list[$i]->getParentId() === -1) {\n// \t\t\t// root\n// \t\t\t$curId = $i;\n// \t\t\tbreak;\n// \t\t}\n// \t}\n// \techo 'Preorder' . PHP_EOL;\n// \tpreorderWalk($list, $curId);\n// \techo PHP_EOL;\n\n// \techo 'Inorder' . PHP_EOL;\n// \tinorderWalk($list, $curId);\n// \techo PHP_EOL;\n\n// \techo 'Postorder' . PHP_EOL;\n// \tpostorderWalk($list, $curId);\n// \techo PHP_EOL;\n\n// }\n\n\nfunction preorderWalk($list, $id){\n\techo ' ' . $id;\n\tif ($list[$id]->hasLeft()) {\n\t\tpreorderWalk($list, $list[$id]->getLeft());\n\t}\n\tif ($list[$id]->hasRight()) {\n\t\tpreorderWalk($list, $list[$id]->getRight());\n\t}\n}\n\nfunction inorderWalk($list, $id){\n\tif ($list[$id]->hasLeft()) {\n\t\tinorderWalk($list, $list[$id]->getLeft());\n\t}\n\techo ' ' . $id;\n\tif ($list[$id]->hasRight()) {\n\t\tinorderWalk($list, $list[$id]->getRight());\n\t}\n}\nfunction postorderWalk($list, $id, $result){\n\tif ($list[$id]->hasLeft()) {\n\t\t$result = postorderWalk($list, $list[$id]->getLeft(), $result);\n\t}\n\tif ($list[$id]->hasRight()) {\n\t\t$result = postorderWalk($list, $list[$id]->getRight(), $result);\n\t}\n\t$result[] = $id;\n\treturn $result;\n}\n\nclass BTreeNode\n{\n\tprivate $id;\n\tprivate $depth = 0;\n\tprivate $height = 0;\n\tprivate $parent_id = -1;\n\tprivate $left = -1;\n\tprivate $right = -1;\n\n\tfunction __construct($id)\n\t{\n\t\t$this->id = $id;\n\t}\n\tfunction setParentId($p_id){\n\t\t$this->parent_id = $p_id;\n\t}\n\tfunction setLeft($l_id){\n\t\t$this->left = $l_id;\n\t}\n\tfunction setRight($r_id){\n\t\t$this->right = $r_id;\n\t}\n\tfunction getId(){\n\t\treturn $this->id;\n\t}\n\tfunction getParentId(){\n\t\treturn $this->parent_id;\n\t}\n\tfunction getLeft(){\n\t\treturn $this->left;\n\t}\n\tfunction getRight(){\n\t\treturn $this->right;\n\t}\n\tfunction hasChild(){\n\t\treturn ($this->left !== -1) || ($this->right !== -1);\n\t}\n\tfunction getChildren(){\n\t\t$children = [];\n\t\tif ($this->hasLeft()) {\n\t\t\t$children[] = $this->left;\n\t\t}\n\t\tif ($this->hasRight()) {\n\t\t\t$children[] = $this->right;\n\t\t}\n\t\treturn $children;\n\t}\n\tfunction getAnotherChild($c_id){\n\t\t$c = -1;\n\t\tif ($this->getLeft() === $c_id) {\n\t\t\t$c = $this->getRight();\n\t\t}elseif ($this->getRight() === $c_id) {\n\t\t\t$c = $this->getLeft();\n\t\t}\n\t\treturn $c;\n\t}\n\tfunction hasLeft(){\n\t\treturn $this->left !== -1;\n\t}\n\tfunction hasRight(){\n\t\treturn $this->right !== -1;\n\t}\n\tfunction setDepth($d){\n\t\t$this->depth = $d;\n\t}\n\tfunction addDepth(){\n\t\t$this->depth += 1;\n\t}\n\tfunction getDepth(){\n\t\treturn $this->depth;\n\t}\n\tfunction setHeight($h){\n\t\t$this->height = $h;\n\t}\n\tfunction getHeight(){\n\t\treturn $this->height;\n\t}\n}\n"
  },
  {
    "language": "OCaml",
    "code": "open Str\n\nmodule L =\n  struct\n    include List\n  \n    let rec take n = function\n        [] -> []\n      | h :: t when n > 0 -> h :: take (n - 1) t\n      | _ -> []\n\n    let rec drop n = function\n        [] -> []\n      | h :: t when n > 0 -> drop (n - 1) t\n      | l -> l\n\n    let rec break f = function\n        [] -> ([],[])\n      | h :: t as l when f h -> ([],l)\n      | h :: t -> let (xs, ys) = break f t in (h::xs, ys)\n  end\n\nlet read_list f =\n  split (regexp \" +\") (read_line ()) |> List.map f\n                                                 \nlet rec postorder pl il rl =\n  match pl with\n    [] -> rl\n  | x :: xs -> let (lil, ril) = L.break (fun a -> a = x) il in\n               let lpl = L.take (L.length lil) xs in\n               let rpl = L.drop (L.length lil) xs in\n               let rl' = postorder rpl (L.tl ril) (x::rl) in\n               postorder lpl lil rl'\nlet () =\n  let _ = read_line () in\n  let pl = read_list int_of_string in\n  let il = read_list int_of_string in\n  postorder pl il [] |> L.map string_of_int |> String.concat \" \" |> print_endline"
  },
  {
    "language": "OCaml",
    "code": "let find x a n =\n  let rec doit i =\n    if i = n then exit 1\n    else if a.(i) = x then i\n    else doit (i + 1)\n  in doit 0\n\nlet () =\n  let open Queue in\n  let n = read_int () in\n  let preorder = create () in\n  let rec read i =\n    if i < n then (add (Scanf.scanf \"%d \" (fun i -> i)) preorder; read (i + 1))\n  in read 0;\n  let inorder = Array.init n (fun _ -> Scanf.scanf \"%d \" (fun i -> i)) in\n  let postorder = create () in\n  let rec doit l r =\n    if l < r then begin\n      let root = take preorder in\n      let m = find root inorder n in\n      doit l m;\n      doit (m + 1) r;\n      add root postorder\n    end in\n  doit 0 n;\n  print_int (take postorder);\n  iter (fun e -> Printf.printf \" %d\" e) postorder;\n  print_newline ()"
  },
  {
    "language": "OCaml",
    "code": "let () =\n  let open Queue in\n  let n = read_int () in\n  let preorder = create () in\n  for _ = 0 to n - 1 do\n    add (Scanf.scanf \"%d \" (fun i -> i)) preorder;\n  done;\n  let inorder = Array.init n (fun _ -> Scanf.scanf \"%d \" (fun i -> i)) in\n  let t = Array.make (40 + 1) 0 in\n  Array.iteri (fun i e -> t.(e) <- i) inorder;\n  let postorder = create () in\n  let rec doit l r =\n    if l >= r then ()\n    else begin\n      let root = take preorder in\n      let m = t.(root) in\n      doit l m;\n      doit (m + 1) r;\n      add root postorder\n    end in\n  doit 0 n;\n  print_int (take postorder);\n  iter (fun e -> print_string \" \"; print_int e) postorder;\n  print_newline ()"
  },
  {
    "language": "OCaml",
    "code": "let find x a =\n  let n = Array.length a in\n  let rec doit i =\n    if i = n then exit 1\n    else if a.(i) = x then i\n    else doit (i + 1)\n  in\n  doit 0\n\nlet () =\n  let n = read_int () in\n  let preorder = Queue.create () in\n  let rec read i =\n    if i < n then begin\n      Queue.add (Scanf.scanf \"%d \" (fun i -> i)) preorder;\n      read (i + 1)\n    end\n  in\n  read 0;\n  let inorder = Array.init n (fun _ -> Scanf.scanf \"%d \" (fun i -> i)) in\n  let postorder = Queue.create () in\n  let rec doit l r =\n    if l < r then begin\n      let root = Queue.take preorder in\n      let m = find root inorder in\n      doit l m;\n      doit (m + 1) r;\n      Queue.add root postorder\n    end\n  in\n  doit 0 n;\n  print_int (Queue.take postorder);\n  Queue.iter (fun e -> Printf.printf \" %d\" e) postorder;\n  print_newline ()"
  },
  {
    "language": "OCaml",
    "code": "let break p lst =\n  let rec doit acc = function\n    | [] -> (List.rev acc, [])\n    | x :: xs as l ->\n      if p x then (List.rev acc, l)\n      else doit (x :: acc) xs in\n  doit [] lst\n\nlet split_n n lst =\n  let rec doit n acc l =\n    if n = 0 then (List.rev acc, l)\n    else\n      match l with\n      | [] -> assert false\n      | hd :: tl -> doit (n - 1) (hd :: acc) tl in\n  doit n [] lst\n\nlet make_postorder preorder inorder =\n  let rec doit = function\n    | ([], []) -> []\n    | ([], _) -> assert false\n    | (x :: xs, ys) ->\n        begin match break (fun e -> e = x) ys with\n        | (_, []) -> assert false\n        | (yl, _ :: yr) ->\n          let (xl, xr) = split_n (List.length yl) xs in\n          doit (xl, yl) @ doit (xr, yr) @ [x]\n        end in\n  doit (preorder, inorder)\n\nlet () =\n  let n = read_int () in\n  let rec read_tree i acc =\n    if i = n then List.rev acc\n    else read_tree (i + 1) ((Scanf.scanf \"%d \" (fun i -> i)) :: acc) in\n  let read_tree i = read_tree i [] in\n  let preorder = read_tree 0 in\n  let inorder = read_tree 0 in\n  make_postorder preorder inorder\n  |> List.iteri (fun i e -> if i <> 0 then print_string \" \"; print_int e);\n  print_newline ()"
  },
  {
    "language": "OCaml",
    "code": "let break p lst =\n  let rec doit acc = function\n    | [] -> (List.rev acc, [])\n    | x :: xs as l ->\n      if p x then (List.rev acc, l)\n      else doit (x :: acc) xs in\n  doit [] lst\n\nlet split_n n lst =\n  let rec doit n acc l =\n    if n = 0 then (List.rev acc, l)\n    else\n      match l with\n      | [] -> assert false\n      | hd :: tl -> doit (n - 1) (hd :: acc) tl in\n  doit n [] lst\n\nlet make_postorder preorder inorder =\n  let rec doit = function\n    | ([], []) -> []\n    | (xs, ys) ->\n      begin match xs with\n      | [] -> assert false\n      | x :: xs ->\n        begin match break (fun e -> e = x) ys with\n        | (yl, yr) ->\n          begin match yr with\n          | [] -> assert false\n          | _ :: yr ->\n            let (xl, xr) = split_n (List.length yl) xs in\n            doit (xl, yl) @ doit (xr, yr) @ [x]\n          end\n        end\n      end in\n  doit (preorder, inorder)\n\nlet () =\n  let n = read_int () in\n  let rec read_tree i acc =\n    if i = n then List.rev acc\n    else read_tree (i + 1) ((Scanf.scanf \"%d \" (fun i -> i)) :: acc) in\n  let read_tree i = read_tree i [] in\n  let preorder = read_tree 0 in\n  let inorder = read_tree 0 in\n  make_postorder preorder inorder\n  |> List.iteri (fun i e -> if i <> 0 then print_string \" \"; print_int e)"
  },
  {
    "language": "OCaml",
    "code": "let break p lst =\n  let rec doit acc = function\n    | [] -> (List.rev acc, [])\n    | x :: xs as l ->\n      if p x then (List.rev acc, l)\n      else doit (x :: acc) xs in\n  doit [] lst\n\nlet split_n n lst =\n  let rec doit n acc l =\n    if n = 0 then (List.rev acc, l)\n    else\n      match l with\n      | [] -> assert false\n      | hd :: tl -> doit (n - 1) (hd :: acc) tl in\n  doit n [] lst\n\nlet make_postorder preorder inorder =\n  let rec doit = function\n    | ([], []) -> []\n    | (xs, ys) ->\n      begin match xs with\n      | [] -> assert false\n      | x :: xs ->\n        begin match break (fun e -> e = x) ys with\n        | (yl, yr) ->\n          begin match yr with\n          | [] -> assert false\n          | _ :: yr ->\n            let (xl, xr) = split_n (List.length yl) xs in\n            doit (xl, yl) @ doit (xr, yr) @ [x]\n          end\n        end\n      end in\n  doit (preorder, inorder)\n\nlet () =\n  let n = read_int () in\n  let rec read_tree i acc =\n    if i = n then List.rev acc\n    else read_tree (i + 1) ((Scanf.scanf \"%d \" (fun i -> i)) :: acc) in\n  let read_tree i = read_tree i [] in\n  let preorder = read_tree 0 in\n  let inorder = read_tree 0 in\n  make_postorder preorder inorder\n  |> List.iteri (fun i e -> if i <> 0 then print_string \" \"; print_int e);\n  print_newline ()"
  },
  {
    "language": "D",
    "code": "import std.algorithm, std.conv, std.range, std.stdio, std.string;\n\nvoid main()\n{\n  auto n = readln.chomp.to!size_t;\n  auto nodes = new BiNode[](n);\n\n  auto prN = readln.split.to!(int[]); prN[] -= 1;\n  auto inN = readln.split.to!(int[]); inN[] -= 1;\n\n  auto root = createNodes(nodes, prN, inN);\n  auto poN = postorderWalk(nodes, nodes[root]); poN[] += 1;\n\n  writeln(poN.to!(string[]).join(\" \"));\n}\n\nint createNodes(ref BiNode[] nodes, ref int[] prN, ref int[] inN)\n{\n  if (inN.empty) return -1;\n\n  auto cr = prN.front;\n  prN.popFront;\n\n  auto sp = inN.findSplit([cr]);\n  auto l = createNodes(nodes, prN, sp[0]);\n  auto r = createNodes(nodes, prN, sp[2]);\n\n  nodes[cr] = new BiNode(cr, l, r);\n  return cr;\n}\n\nint[] postorderWalk(BiNode[] nodes, BiNode node)\n{\n  int[] r;\n  if (node.l != -1) r ~= postorderWalk(nodes, nodes[node.l]);\n  if (node.r != -1) r ~= postorderWalk(nodes, nodes[node.r]);\n  r ~= [node.id];\n  return r;\n}\n\nclass BiNode\n{\n  int id;\n  int parent;\n  int l, r;\n\n  this(int id, int l, int r)\n  {\n    this.id = id;\n    this.parent = -1;\n    this.l = l;\n    this.r = r;\n  }\n\n  bool isRoot()\n  {\n    return parent == -1;\n  }\n}"
  },
  {
    "language": "Python",
    "code": "# coding=utf-8\ndef reconstruction(left, right):\n    global pre_order\n    global in_order\n    global post_order\n    global n\n\n    if left > right:\n        return None\n    elif left == right:\n        root = pre_order.pop(0)\n        post_order.append(root)\n        return None\n    else:\n        root = pre_order.pop(0)\n\n    root_pos = in_order.index(root)\n    reconstruction(left, root_pos-1)\n    reconstruction(root_pos+1, right)\n    post_order.append(root)\n\nn = int(input())\npre_order = list(map(int, input().split()))\nin_order = list(map(int, input().split()))\npost_order = []\n\nreconstruction(0, n-1)\nprint(*post_order)"
  },
  {
    "language": "Python",
    "code": "def post_from_pre_in(preorder_elements, inorder_elements):\n    if preorder_elements:\n        global cnt\n        root = preorder_elements[0]\n        root_index = inorder_elements.index(root)\n        preorder_left = preorder_elements[1:root_index+1]\n        inorder_left = inorder_elements[:root_index]\n        preorder_right = preorder_elements[root_index+1:]\n        inorder_right = inorder_elements[root_index+1:]\n        post_from_pre_in(preorder_left, inorder_left)\n        post_from_pre_in(preorder_right, inorder_right)\n        if cnt:\n            print(root, end = ' ')\n            cnt -= 1\n        else:\n            print(root)\n\n\ncnt = int(input()) - 1\n\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\npost_from_pre_in(a, b)"
  },
  {
    "language": "Python",
    "code": "class Tree:\n    __slots__ = ['id', 'p', 'left', 'right']\n    def __init__(self, id):\n        self.id = id\n        self.left = -1\n        self.right = -1\n    def setc(self, c):\n        if self.left == -1:\n            self.left = c\n        else:\n            self.right = c\n    def __str__(self):\n        return f\"node {self.id}: left = {self.left}, right = {self.right}\"\nn = int(input())\ntree = tuple(Tree(i) for i in range(n + 1))\npretree = list(map(int, input().split()))\ninotree = list(map(int, input().split()))\nroot = pretree[0]\nroot_index = inotree.index(root)\nSET = set(pretree) - {root}\ndef treeSet(A, i):\n    if len(A) == 0:\n        return\n    global SET\n    c = root\n    r = pretree.index(A[0])\n    for a in pretree[i: r + 1]:\n        if c != a:\n            SET -= {a}\n            tree[c].setc(a)\n            c = a\n    for b in A[1:]:\n        if b not in SET:\n            c = b\n            continue\n        SET.add(b)\n        tree[c].setc(b)\n        c = b\ntreeSet(inotree[:root_index], 0)\ntreeSet(inotree[root_index + 1:], root_index + 1)\ndef postorder_tree_walk(id):\n    if tree[id].left != -1:\n        postorder_tree_walk(tree[id].left)\n    if tree[id].right != -1:\n        postorder_tree_walk(tree[id].right)\n    print(f\" {tree[id].id}\", end=\"\")\npostorder_tree_walk(root)\n"
  },
  {
    "language": "Python",
    "code": "# coding=utf-8\nfrom collections import deque\n\ndef reconstruction(left, right):\n    global pre_order\n    global in_order\n    global post_order\n    global n\n\n    if left > right:\n        return None\n    elif left == right:\n        root = pre_order.popleft()\n        post_order.append(root)\n        return None\n    else:\n        root = pre_order.popleft()\n\n    root_pos = in_order.index(root)\n    reconstruction(left, root_pos-1)\n    reconstruction(root_pos+1, right)\n    post_order.append(root)\n\nn = int(input())\npre_order = deque(map(int, input().split()))\nin_order = deque(map(int, input().split()))\npost_order = []\n\nreconstruction(0, n-1)\nprint(*post_order)"
  },
  {
    "language": "Python",
    "code": "class Node():\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef postorder(root, out):\n    if root == None:\n        pass\n    else:\n        postorder(root.left, out)\n        postorder(root.right, out)\n        out.append(root.value)\n\ndef build_tree(pres, ins):\n    if len(pres) < 1:\n        return None\n    else:\n        node = Node(pres[0])\n        index = 0\n        for i in range(len(ins)):\n            if ins[i] == pres[0]:\n                index = i\n                break\n        \n        node.left = build_tree(pres[1:1+index], ins[0:index])\n        node.right = build_tree(pres[1+index:], ins[1+index:])\n        return node\n\n\nif __name__ == '__main__':\n    n = int(input())\n    pres = [int(num) for num in input().split(' ')]\n    ins = [int(num) for num in input().split(' ')]\n    root = build_tree(pres, ins)\n    out = []\n    postorder(root, out)\n    print(str(out).replace(',', '').replace('[', '').replace(']', ''))\n\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n\tdef __init__(self):\n\t\tself.parent = None\n\t\tself.left = None\n\t\tself.right = None\n\ndef restoreTree(preList, inList):\n\troot = preList[0]\n\tindex = inList.index(root)\n\tleftin = inList[:index]\n\t# print(leftin)\n\trightin = inList[index + 1:]\n\t# print(rightin)\n\tnum_left = len(leftin)\n\tnum_right = len(rightin)\n\tif num_left != 0:\n\t\tleftpre = preList[1:1 + num_left]\n\t\t# print(leftpre)\n\t\tleft_root = leftpre[0]\n\t\tT[root].left = left_root\n\t\tT[left_root].parent = root\n\t\trestoreTree(leftpre, leftin)\n\tif num_right != 0:\n\t\trightpre = preList[1 + num_left:]\n\t\t# print(rightpre)\n\t\tright_root = rightpre[0]\n\t\tT[root].right = right_root\n\t\tT[right_root].parent = root\n\t\trestoreTree(rightpre, rightin)\n\n\ndef postOrder(root):\n\tif T[root].left is not None:\n\t\tpostOrder(T[root].left)\n\tif T[root].right is not None:\n\t\tpostOrder(T[root].right)\n\tL.append(str(root))\n\nif __name__ == \"__main__\":\n\tn = int(input())\n\tT = []\n\tfor _ in range(n + 1):\n\t\tT.append(Node())\n\tpreList = list(map(int, input().split()))\n\tinList = list(map(int, input().split()))\n\troot = preList[0]\n\trestoreTree(preList, inList)\n\tL = []\n\tpostOrder(root)\n\tprint(\" \".join(L))\n"
  },
  {
    "language": "Python",
    "code": "class Node():\n    def __init__(self, parent = -1, left = -1, right = -1):\n        self.parent = parent\n        self.left = left\n        self.right = right\n\ndef postorder(ns, i, post):\n    if ns[i].left != -1:\n        postorder(ns, ns[i].left, post)\n    if ns[i].right != -1:\n        postorder(ns, ns[i].right, post)\n    post.append(str(i + 1))\n\ndef poio_node(ns, po, io):\n    p = po[0]\n    i = io.index(p)\n    if i != 0:\n        ns[p].left = po[1]\n        ns[po[1]].parent = p\n        poio_node(ns, po[1:i + 1], io[:i])\n    if i != len(io) -1:\n        ns[p].right = po[i + 1]\n        ns[po[1 + i]].parent = p\n        poio_node(ns, po[i + 1:], io[i + 1:])\n\ndef min1(n):\n    return n - 1\n    \nn = int(input())\npo = list(map(int, input().split()))\nio = list(map(int, input().split()))\npo = list(map(min1, po))\nio = list(map(min1, io))\nns = [Node() for i in range(n)]\n\npoio_node(ns, po, io)\n\npost = []\npostorder(ns, po[0], post)\nprint(\" \".join(post))\n"
  },
  {
    "language": "Python",
    "code": "j,a=0,[]\ndef f(l,r):\n if l<r:\n  global j,a;c=p[j];j+=1;m=i.index(c)\n  f(l,m);f(m+1,r);a+=[c]\nn,p,i=int(input()),input().split(),input().split()\nf(0,n);print(*a)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input().rstrip())\npre_map = input().rstrip().split(\" \")\npre_map = map(int, pre_map)\nin_list = input().rstrip().split(\" \")\nin_list = list(map(int, in_list))\n\nresult = []\n\ndef reconst(left, right):\n    if left >= right:\n        return 0\n    c_of_pre = next(pre_map)\n    c_of_in = in_list.index(c_of_pre)\n    reconst(left, c_of_in)\n    reconst(c_of_in+1, right)\n    result.append(str(c_of_pre))\n    \nreconst(0, n)\nprint(\" \".join(result))\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\npreorder = list(map(lambda s: int(s) - 1, input().split()))\ninorder = list(map(lambda s: int(s) - 1, input().split()))\npostorder = []\n\n\ndef f(n, left, right):\n    num = preorder[n]\n    # print(n, left, right, num)\n    if right - left == 1:\n        postorder.append(num)\n        return\n    idxin = inorder.index(num)\n    n += 1\n    if idxin - left >= 1:\n        f(n, left, idxin)\n    n += idxin - left\n    if right - idxin - 1 >= 1:\n        f(n, idxin+1, right)\n    postorder.append(num)\n\n\nf(0, 0, N)\nprint(' '.join(map(lambda x: str(x+1), postorder)))\n"
  },
  {
    "language": "Python",
    "code": "\nclass Node:\n\tdef __init__(self, v):\n\t\tself.v = v\n\t\tself.l = self.r = None\n\t\tself.p = -1\n\tdef __str__(self):\n\t\treturn str(self.v)\n\ndef find_pos(a, v):\n\tfor i in range(len(a)):\n\t\tif a[i] == v:\n\t\t\treturn i\n\treturn -1\n\ndef add_node(root, cur, ino):\n\tidx = find_pos(ino, cur.v)\n\tst = []\n\tst.append(root)\n\twhile len(st) != 0:\n\t\tnode = st.pop()\n\t\tif node.p == -1:\n\t\t\tnode.p = find_pos(ino, node.v)\n\t\tif idx < node.p:\n\t\t\tif node.l == None:\n\t\t\t\tnode.l = cur\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\tst.append(node.l)\n\t\telse:\n\t\t\tif node.r == None:\n\t\t\t\tnode.r = cur\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\tst.append(node.r)\t\t\n\ndef post_order(root):\n\tst = []\n\tcur = root\n\tlast = None\n\tret = ''\n\twhile cur != None or len(st) != 0:\n\t\tif cur != None:\n\t\t\tst.append(cur)\n\t\t\tcur = cur.l\n\t\telse:\n\t\t\tpeek = st[len(st)-1]\n\t\t\tif peek.r != None and peek.r != last:\n\t\t\t\tcur = peek.r\n\t\t\telse:\n\t\t\t\tif len(ret) != 0:\n\t\t\t\t\tret += ' '\n\t\t\t\tret += str(peek)\n\t\t\t\tlast = st.pop()\n\treturn ret\n\nn = int(input())\npreo = list(map(int, input().split()))\nino = list(map(int, input().split()))\n\nr = preo[0]\nroot = Node(r)\nfor i in range(1, n):\n\tcur = Node(preo[i])\n\tadd_node(root, cur, ino)\n\nprint(post_order(root))\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\npre = list(map(int,input().split()))\nino = list(map(int,input().split()))\n\npost=[]\ni = -1\ndef reconstruction(l, r):\n    global i\n    if l >= r:\n        return\n    i += 1\n    c = pre[i]\n    m = ino.index(c)\n    reconstruction(l, m)\n    reconstruction(m+1, r)\n    post.append(c)\nreconstruction(0, n)\nprint(\" \".join(map(str,post)))"
  },
  {
    "language": "Python",
    "code": "n = int(input())\ntree = [None for i in range(n +1)]\nlist_pre = list(map(int, input().split()))\nlist_in = list(map(int, input().split()))\n \n \ndef reconstruct(tree_pre, tree_in):\n    if not tree_pre:\n        return -1\n    root = tree_pre[0]\n    idx = tree_in.index(root)\n    tree[root] = (reconstruct(tree_pre[1:i + 1], tree_in[:i]), \n                  reconstruct(tree_pre[i + 1:],  tree_in[i + 1:]))\n    return root\n\n\ndef post_order_search(i):\n    if i == -1:\n        return\n    l, r = tree[i]\n    for j in post_order_search(l):\n        yield j\n    for j in post_order_search(r):\n        yield j\n    yield i\n\n\nsolve(list_pre, list_in)\n\nprint(*postorder(list_pre[0]))"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self, id):\n        self.id = id\n        self.left = None\n        self.right = None\n        self.sibling = None\n        self.parent = None\n\ndef postorder_tree_walk(root):\n    result = []\n    if root.left != None:\n        result.extend(postorder_tree_walk(root.left))\n    if root.right != None:\n        result.extend(postorder_tree_walk(root.right))\n    result.append(root.id)\n    return result\n\ndef make_tree(root, left_ids, right_ids, tree, pre):\n    if len(left_ids) == 1:\n        root.left = tree[left_ids[0]]\n    elif len(left_ids) > 1:\n        root_id = 0\n        for x in pre:\n            if x in left_ids:\n                root_id = x\n                break\n        index = left_ids.index(root_id)\n        root.left = tree[root_id]\n        make_tree(tree[root_id], left_ids[:index], left_ids[index + 1:], tree, pre)\n\n    if len(right_ids) == 1:\n        root.right = tree[right_ids[0]]\n    elif len(right_ids) > 1:\n        root_id = 0\n        for x in pre:\n            if x in right_ids:\n                root_id = x\n                break\n        index = right_ids.index(root_id)\n        root.right = tree[root_id]\n        make_tree(tree[root_id], right_ids[:index], right_ids[index + 1:], tree, pre)\n\nn = int(raw_input())\ntree = [Node(i) for i in xrange(n+1)]\ntree[0] = None\npre = map(int, raw_input().split())\ninoder = map(int, raw_input().split())\nroot = tree[pre[0]]\nindex = inoder.index(root.id)\nmake_tree(root, inoder[:index], inoder[index + 1:], tree, pre)\nresult = postorder_tree_walk(root)\nprint ' '.join(map(str, result))"
  },
  {
    "language": "Python",
    "code": "class Tree:\n    def __init__(self, *args):\n        self.value, self.left, self.right = args\n\n    def postorder(self):\n        left = [] if self.left is None else self.left.postorder()\n        right = [] if self.right is None else self.right.postorder()\n        return left + right + [self.value]\n\n\ndef recover(pre, ino):\n    preord = dict(map(lambda t: (t[1], t[0]), enumerate(pre)))\n\n    def make_tree(tree):\n        if len(tree) == 0:\n            return None\n        root_idx, root_value = min(enumerate(tree), key=lambda t: preord[t[1]])\n        return Tree(\n            root_value,\n            make_tree(tree[:root_idx]),\n            make_tree(tree[root_idx + 1:])\n        )\n\n    return make_tree(ino).postorder()\n\n\nif __name__ == '__main__':\n    _ = input()\n    pre = list(map(int, input().split()))\n    ino = list(map(int, input().split()))\n    print(' '.join([str(t) for t in recover(pre, ino)]))\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\npretree = list(map(int, input().split()))\ninotree = list(map(int, input().split()))\ndef get_postorder(pre, ino):\n    if not pre:\n        return []\n    root = pre[0]\n    root_index = ino.index(root)\n    result = []\n    result.extend(get_postorder(pre[1:root_index + 1], ino[:root_index]))\n    result.extend(get_postorder(pre[root_index + 1:], ino[root_index + 1:]))\n    result.append(root)\n    return result\nprint(*get_postorder(pretree, inotree))\n\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self, id):\n        self.id = id\n        self.left = -1\n        self.right = -1\ndef walk_postorder(node, order_list):\n    if node == None:\n        return 0\n    walk_postorder(nodes.get(node.left), order_list)\n    walk_postorder(nodes.get(node.right), order_list)\n    order_list.append(node.id)\ndef build_tree(nodes, preorder, inorder, start_idx, end_idx):\n    node = Node(preorder[build_tree.pre_idx])\n    nodes[preorder[build_tree.pre_idx]] = node\n    build_tree.pre_idx += 1\n    \n    if start_idx == end_idx:\n        return node\n    \n    root_idx = inorder.index(node.id)\n    if start_idx != root_idx:\n        left = build_tree(nodes, preorder, inorder, start_idx, root_idx-1)\n        nodes[node.id].left = left.id\n    if end_idx != root_idx:\n        right = build_tree(nodes, preorder, inorder, root_idx+1, end_idx)\n        nodes[node.id].right = right.id\n    \n    return node\n\nn = int(input())\npreorder = list(map(int, input().split(' ')))\ninorder = list(map(int, input().split(' ')))\nnodes = {}\nbuild_tree.pre_idx = 0\nbuild_tree(nodes, preorder, inorder, 0, n-1)\npostorder_list = []\nwalk_postorder(nodes[preorder[0]], postorder_list)\nprint(' '.join(map(str, postorder_list)))\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nsys.setrecursionlimit(10 ** 9)\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\n\nN = INT()\npreo = LIST()\nino = LIST()\nposto = []\n\ndef rec(l):\n    if len(l) == 0:\n        return\n    # preorderから次の値を取り出す\n    x = preo.pop(0)\n    for i in range(len(l)):\n        if l[i] == x:\n            # preorderの値と一致したら、そこから左右に分割\n            rec(l[:i])\n            rec(l[i+1:])\n    posto.append(x)\n    return\n\nrec(ino)\nprint(*posto)\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\npreorder = list(map(int, input().split(' ')))\ninorder = list(map(int, input().split(' ')))\npostorder = []\npos = 0\n\ndef solve():\n    global pos\n    pos = 0\n    reconstruction(0, len(preorder))\n    for i in range(n):\n        if i: print(' ', end='')\n        print(postorder[i], end='')\n    print()\n\ndef reconstruction(left, right):\n    global inorder, preorder, postorder, pos\n    if left >= right: return None\n    root = preorder[pos]\n    pos += 1\n    mid = inorder.index(root)\n    reconstruction(left, mid)\n    reconstruction(1 + mid, right)\n    postorder.append(root)\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "def postorder(preorder,inorder):\n    if len(preorder) > 1:\n        left_inorder = []\n        right_inorder = []\n        flag = False\n        for i in range(len(inorder)):\n            if flag == False:\n                if n == inorder[i]:\n                    flag = True\n                else:\n                    left_inorder.append(inorder[i])\n            else:\n                right_inorder.append(inorder[i])\n        left_preorder = []\n        right_preorder = []\n        flag = False\n        for i in range(1,len(preorder)):\n            if flag == False:\n                left_preorder.append(preorder[i])\n                if len(left_preorder) == len(left_inorder):\n                    flag = True\n            else:\n                right_preorder.append(preorder[i])\n        postorder(left_preorder,left_inorder)\n        postorder(right_preorder,right_inorder)\n    if len(preorder) > 0:\n        print preorder[0],\n\nn = int(raw_input())\npreorder = map(int,raw_input().split(' '))\ninorder = map(int,raw_input().split(' '))\n\npostorder(preorder,inorder)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\npreorder & inorder\n\n5\n1 2 3 4 5\n3 2 4 1 5\n\n9\n1 2 3 4 5 6 7 8 9\n3 2 5 4 6 1 8 7 9\n\noutput:\npostorder\n3 4 2 5 1\n\"\"\"\n\nimport sys\n\n\n# recursively defines a binary tree\n# node.left or node.right may also be a binary tree\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\n\ndef reconstruction(_pre_order, _in_order):\n    # write your code here\n    if not _pre_order:\n        return None\n    root = TreeNode(_pre_order[0])\n    root_position = _in_order.index(_pre_order[0])\n    root.left = reconstruction(_pre_order=_pre_order[1:1 + root_position], _in_order=_in_order[:root_position])\n    root.right = reconstruction(_pre_order=_pre_order[root_position + 1:], _in_order=_in_order[root_position + 1:])\n    print(root.val, end=' ')\n    # post_order.append(root.val)\n    return root.val\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    array_length = int(_input[0])\n    pre_order = list(map(int, _input[1].split()))\n    in_order = list(map(int, _input[2].split()))\n    # assert len(pre_order) == len(in_order) == array_length\n\n    # post_order = []\n    reconstruction(_pre_order=pre_order, _in_order=in_order)\n    print('')\n    # print(*post_order)"
  },
  {
    "language": "Python",
    "code": "\n\nclass Node:\n    def __init__(self,name):\n        self.name=name\n        self.left=-1\n        self.right=-1\n        self.parent=-1\n\n\n\ndef mk_tree(Tree,p_order,in_order):\n    tmp_p_order=[]\n    tmp_in_order=[]\n    root=p_order[0]#p_orderの先頭要素が、rootになる\n\n    root_ind=0    \n    while(in_order[root_ind] != root):\n        root_ind+=1#in_orderでのrootのindexを返す \n\n\n\n    if(root_ind!=0):\n        Tree[root].left=p_order[1]\n        Tree[p_order[1]].parent=root\n        tmp_in_order=in_order[0:root_ind]\n        tmp_p_order=p_order[1:root_ind+1]\n        mk_tree(Tree,tmp_p_order,tmp_in_order)\n\n    if(root_ind!=len(p_order)-1):\n        Tree[root].right=p_order[root_ind+1]\n        Tree[p_order[root_ind+1]].parent=root\n        tmp_in_order=in_order[root_ind+1:]\n        tmp_p_order=p_order[root_ind+1:]\n        mk_tree(Tree,tmp_p_order,tmp_in_order)\n    \n\n\ndef Postorder(Tree,root,order):\n    if(Tree[root].left!=-1):\n        Postorder(Tree,Tree[root].left,order)\n    if(Tree[root].right!=-1):\n        Postorder(Tree,Tree[root].right,order)\n    order.append(root)\n       \n\n\n\n\n\n\nn=int(input())\np_order=list(map(int,input().split()))\nroot=p_order[0]\nin_order=list(map(int,input().split()))\nTree=[None]\nfor i in range(n):\n   Tree.append(Node(i+1))\n\nmk_tree(Tree,p_order,in_order)\n\n#for i in range(1,n+1):\n #  print(f\"id {i}: left = {Tree[i].left}, right = {Tree[i].right}, parent = {Tree[i].parent}\")\n\n\n\npost_order=[]\nPostorder(Tree,root,post_order)\nprint(\" \".join(list(map(str,post_order))))\n"
  },
  {
    "language": "Python",
    "code": "# coding=utf-8\nfrom collections import deque\n\ndef reconstruction(left, right):\n    global pre_order\n    global in_order\n    global post_order\n    global n\n\n    if left > right:\n        return None\n    elif left == right:\n        root = pre_order.popleft()\n        post_order.append(root)\n        return None\n    else:\n        root = pre_order.popleft()\n\n    root_pos = in_order.index(root)\n    reconstruction(left, root_pos-1)\n    reconstruction(root_pos+1, right)\n    post_order.append(root)\n\nn = int(input())\npre_order = deque(map(int, input().split()))\nin_order = deque(map(int, input().split()))\npost_order = []\n\nreconstruction(0, n-1)\nprint(*post_order)"
  },
  {
    "language": "Python",
    "code": "# Reconstruction of the Tree\n\n# Tree walk\n\nimport sys\nsys.setrecursionlimit(10**9)  # 再帰回数上限の向上 かなり多くしないとREになる\n\n\ndef rec(l, r, post_ls):\n    if (l >= r):\n        return\n    global pos\n    root = pre_ls[pos]\n    pos +=1\n    m = in_ls.index(root)\n    rec(l, m, post_ls)\n    rec(m + 1, r, post_ls)\n    post_ls.append(root)\n\n# データの読み込み\nn = int(input())\npre_ls = list(map(int, input().split()))\nin_ls = list(map(int, input().split()))\npost_ls = []\n\npos = 0\nrec(0, len(pre_ls), post_ls)\n\nprint(*post_ls)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\ntree = [None for i in range(n +1)]\nlist_pre = list(map(int, input().split()))\nlist_in = list(map(int, input().split()))\n \n \ndef solve(tree_pre, tree_in):\n    if not tree_pre:\n        return -1\n    root = tree_pre[0]\n    idx = tree_in.index(root)\n    tree[root] = (solve(tree_pre[1:idx + 1], tree_in[:idx]), \n                  solve(tree_pre[idx + 1:],  tree_in[idx + 1:]))\n    return root\n\n\ndef post_order_search(i):\n    if i == -1:\n        return\n    l, r = tree[i]\n    for j in post_order_search(l):\n        yield j\n    for j in post_order_search(r):\n        yield j\n    yield i\n\n\nsolve(list_pre, list_in)\n\nprint(*post_order_search(list_pre[0]))"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nPre = list(map(int, input().split()))\nIn = list(map(int, input().split()))\n\ndef gao(Pre, l, r, In: list, L, R):\n    if l > r:\n        return []\n    offset = In.index(Pre[l]) - L\n    return gao(Pre, l + 1, l  + offset, In, L, L + offset - 1) + gao(Pre, l + offset + 1, r, In, L + offset + 1, R) + [Pre[l]]\n\nprint(*gao(Pre, 0, n - 1, In, 0, n - 1))\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\n\nclass Node:\n    def __init__(self, parent=-1, left=-1, right=-1):\n        self.parent = parent\n        self.left = left\n        self.right = right\n\n\nn = int(input())\npre_lst = deque(map(int, input().split()))\nin_lst = list(map(int, input().split()))\npost_lst = []\n\n\ndef reconstruction(l, r):\n    if l >= r:\n        return\n\n    c = pre_lst.popleft()\n    m = in_lst.index(c)\n\n    reconstruction(l, m)\n    reconstruction(m+1, r)\n\n    post_lst.append(c)\n    return\n\n\ndef main():\n    reconstruction(0, n)\n    print(\" \".join([str(i) for i in post_lst]))\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "# Tree Walk\n\n\nN = int(input())\n*A, = map(int, input().split())\n*B, = map(int, input().split())\nidx = 0\nans = []\n\n\ndef rec(l=0, r=N):\n    global idx\n    if l >= r:\n        return\n\n    c = A[idx]\n    idx += 1\n    m = B.index(c)\n\n    rec(l, m)\n    rec(m+1, r)\n\n    ans.append(c)\n\n\nrec()\nprint(*ans)\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\npreorder & inorder\n\n5\n1 2 3 4 5\n3 2 4 1 5\n\n9\n1 2 3 4 5 6 7 8 9\n3 2 5 4 6 1 8 7 9\n\noutput:\npostorder\n3 4 2 5 1\n\"\"\"\n\nimport sys\n\n\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\n\ndef reconstruction(_pre_order, _in_order):\n    # write your code here\n    if not _pre_order:\n        return None\n    root = TreeNode(_pre_order[0])\n    root_position = _in_order.index(_pre_order[0])\n    root.left = reconstruction(_pre_order=_pre_order[1:1 + root_position], _in_order=_in_order[:root_position])\n    root.right = reconstruction(_pre_order=_pre_order[root_position + 1:], _in_order=_in_order[root_position + 1:])\n    post_order.append(root.val)\n    return root.val\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    array_length = int(_input[0])\n    pre_order = list(map(int, _input[1].split()))\n    in_order = list(map(int, _input[2].split()))\n    # assert len(pre_order) == len(in_order) == array_length\n\n    post_order = []\n    reconstruction(_pre_order=pre_order, _in_order=in_order)\n    print(*post_order)"
  },
  {
    "language": "Python",
    "code": "\nclass Node:\n\tdef __init__(self, v):\n\t\tself.v = v\n\t\tself.l = self.r = None\n\t\tself.p = -1\n\tdef __str__(self):\n\t\treturn str(self.v)\n\ndef find_pos(a, v):\n\tfor i in range(len(a)):\n\t\tif a[i] == v:\n\t\t\treturn i\n\treturn -1\n\ndef add_node(root, cur, ino):\n\tidx = find_pos(ino, cur.v)\n\tst = []\n\tst.append(root)\n\twhile len(st) != 0:\n\t\tnode = st.pop()\n\t\tif node.p == -1:\n\t\t\tnode.p = find_pos(ino, node.v)\n\t\tif idx < node.p:\n\t\t\tif node.l == None:\n\t\t\t\tnode.l = cur\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\tst.append(node.l)\n\t\telse:\n\t\t\tif node.r == None:\n\t\t\t\tnode.r = cur\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\tst.append(node.r)\t\t\n\ndef post_order(root):\n\tst = []\n\tcur = root\n\tlast = None\n\tret = ''\n\twhile cur != None or len(st) != 0:\n\t\tif cur != None:\n\t\t\tst.append(cur)\n\t\t\tcur = cur.l\n\t\telse:\n\t\t\tpeek = st[len(st)-1]\n\t\t\tif peek.r != None and peek.r != last:\n\t\t\t\tcur = peek.r\n\t\t\telse:\n\t\t\t\tif len(ret) != 0:\n\t\t\t\t\tret += ' '\n\t\t\t\tret += str(peek.v)\n\t\t\t\tlast = st.pop()\n\tprint(ret)\n\nn = int(input())\npreo = list(map(int, input().split()))\nino = list(map(int, input().split()))\n\nr = preo[0]\nroot = Node(r)\nfor i in range(1, n):\n\tcur = Node(preo[i])\n\tadd_node(root, cur, ino)\n\npost_order(root)\n\n"
  },
  {
    "language": "Python",
    "code": "def postorder(preorder,inorder):\n    if len(preorder) > 1:\n        n = preorder[0]\n        left_inorder = []\n        right_inorder = []\n        flag = False\n        for i in range(len(inorder)):\n            if flag == False:\n                if n == inorder[i]:\n                    flag = True\n                else:\n                    left_inorder.append(inorder[i])\n            else:\n                right_inorder.append(inorder[i])\n        left_preorder = []\n        right_preorder = []\n        flag = False\n        for i in range(1,len(preorder)):\n            if flag == False:\n                left_preorder.append(preorder[i])\n                if len(left_preorder) == len(left_inorder):\n                    flag = True\n            else:\n                right_preorder.append(preorder[i])\n        postorder(left_preorder,left_inorder)\n        postorder(right_preorder,right_inorder)\n    if len(preorder) > 0:\n        print preorder[0],\n\nn = int(raw_input())\npreorder = map(int,raw_input().split(' '))\ninorder = map(int,raw_input().split(' '))\n\npostorder(preorder,inorder)"
  },
  {
    "language": "Python",
    "code": "pos = 0\n\ndef reconstruction(pre_order, in_order, post_order, left, right):\n    if left >= right:\n        return\n    global pos\n    root = pre_order[pos]\n    pos += 1\n    mid = in_order.index(root)\n    reconstruction(pre_order, in_order, post_order, left, mid)\n    reconstruction(pre_order, in_order, post_order, mid + 1, right)\n    post_order.append(root)\n\n\ndef solve(pre_order, in_order):\n    post_order = []\n    reconstruction(pre_order, in_order, post_order, 0, len(pre_order))\n    print(' '.join([str(v) for v in post_order]))\n\n\nn = int(input())\npre_order = [int(v) for v in input().split()]\nin_order = [int(v) for v in input().split()]\n\nsolve(pre_order, in_order)\n"
  },
  {
    "language": "Python",
    "code": "n = int(raw_input())\nPre = map(int,raw_input().split())\nIn = map(int,raw_input().split())\n\nidx = 0\n\ndef reconstruction(l,r):\n    global idx\n    if l >= r:\n        return\n    c = Pre[idx]\n    idx += 1\n    m = In.index(c)\n    reconstruction(l,m)\n    reconstruction(m+1,r)\n\n    print c,\n\ndef main():\n    reconstruction(0,n)\n    print \n    return 0\n\nmain()"
  },
  {
    "language": "Python",
    "code": "n = int(input())\ntree = [None] * (n + 1)\npreot = list(map(int, input().split()))\ninot = list(map(int, input().split()))\n\n\ndef reconstruct(pretree, intree):\n    if not pretree:\n        return -1\n    root = pretree[0]\n    i = intree.index(root)\n    tree[root] = (reconstruct(pretree[1:i + 1], intree[:i]), reconstruct(pretree[i + 1:], intree[i + 1:]))\n    return root\n\n\ndef postorder(i):\n    if i == -1: return\n    l, r = tree[i]\n    for v in postorder(l): yield v\n    for v in postorder(r): yield v\n    yield i\n\n\nreconstruct(preot, inot)\n\nprint(*postorder(preot[0]))"
  },
  {
    "language": "Python",
    "code": "class Node():\n    def __init__(self, parent = -1, left = -1, right = -1):\n        self.parent = parent\n        self.left = left\n        self.right = right\n\ndef postorder(ns, i, post):\n    if ns[i].left != -1:\n        postorder(ns, ns[i].left, post)\n    if ns[i].right != -1:\n        postorder(ns, ns[i].right, post)\n    post.append(str(i + 1))\n\ndef poio_node(ns, po, io):\n    p = po[0]\n    i = io.index(p)\n    if i != 0:\n        ns[p].left = po[1]\n        ns[po[1]].parent = p\n        poio_node(ns, po[1:i + 1], io[:i])\n    if i != len(io) -1:\n        ns[p].right = po[i + 1]\n        ns[po[1 + i]].parent = p\n        poio_node(ns, po[i + 1:], io[i + 1:])\n\ndef min1(n):\n    return n - 1\n    \nn = int(input())\npo = list(map(int, input().split()))\nio = list(map(int, input().split()))\npo = list(map(min1, po))\nio = list(map(min1, io))\nns = [Node() for i in range(n)]\n\npoio_node(ns, po, io)\n\npost = []\npostorder(ns, po[0], post)\nprint(\" \".join(post))\n"
  },
  {
    "language": "Python",
    "code": "INF = 10**3\n\n\ndef reconstruction(o_ary, p_ary, i_ary, l, r):\n    if l >= r:\n        return\n\n    c = INF\n    for i in i_ary[l:r]:\n        ind = p_ary.index(i)\n        if ind < c:\n            c = i\n    m = i_ary.index(c)\n\n    reconstruction(o_ary, p_ary, i_ary, l, m)\n    reconstruction(o_ary, p_ary, i_ary, m + 1, r)\n\n    o_ary.append(c)\n\n\nn = int(input())\np_ary = [int(_) for _ in input().split()]\ni_ary = [int(_) for _ in input().split()]\no_ary = []\nreconstruction(o_ary, p_ary, i_ary, 0, n)\nprint(*o_ary)\n"
  },
  {
    "language": "Python",
    "code": "I = 0\nL = 1\nR = 2\nP = 3\nB = 4\nD = 5\nH = 6\n\ndef search(N, A, B, num):\n    \"\"\" N ??? Nodes A???Preorder?????? B???Inorder??????\n        ??????????????????????????§??? root ??? index ????????? \"\"\"\n#    print(A)\n#    print(B)\n    root = A[0]\n    ld = num\n    for i in range(num):\n        if B[i] == root:\n            ld = i\n            break\n    if ld > 0:\n        N[root][L] = search(N,A[1:ld+1],B[:ld],ld)\n    rt = ld + 1\n    if rt < num:\n        N[root][R] = search(N,A[rt:],B[rt:],num - rt)\n    return root\n\ndef getroot(A, id):\n    if A[id][P] > -1:\n        return getroot(A,A[id][P])\n    return A[id][I]\n\ndef preorder(N,id,A):\n    if id < 0:\n        return\n    A.append(id)\n    preorder(N,N[id][L],A)\n    preorder(N,N[id][R],A)\n\ndef inorder(N,id,A):\n    if id < 0:\n        return\n    inorder(N,N[id][L],A)\n    A.append(id)\n    inorder(N,N[id][R],A)\n\ndef postorder(N,id,A):\n    if id < 0:\n        return\n    postorder(N,N[id][L],A)\n    postorder(N,N[id][R],A)\n    A.append(id)\n\n\ndef main():\n\n    \"\"\" ????????? \"\"\"\n    num = int(input().strip())\n    plist = list(map(int,input().split()))\n    ilist = list(map(int,input().split()))\n    pos = []\n    \n    nodes = [[i, -1, -1, -1, -1, 0, 0] for i in range(num)]\n\n    search(nodes,plist,ilist,num)\n#    pre = [\"\"]\n#    ino = [\"\"]\n    pos = []\n\n#    preorder(nodes,plist[0],pre)\n#    inorder(nodes,plist[0],ino)\n    postorder(nodes,plist[0],pos)\n\n#    print(\"Preorder\")\n#    print(\" \".join(map(str,pre)))\n#    print(\"Inorder\")\n#    print(\" \".join(map(str,ino)))\n#    print(\"Postorder\")\n    print(\" \".join(map(str,pos)))\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "def reconsruction(pre, ino):\n    if 0 == len(pre):\n        return []\n    else:\n        root = pre[0]\n\n        partition = ino.index(root)\n        l_ino = ino[0:partition]\n        r_ino = ino[partition+1:]\n\n        pre_partition = len(l_ino)+1\n        l_pre = pre[1:pre_partition]\n        r_pre = pre[pre_partition:]\n\n        return reconsruction(l_pre, l_ino) + reconsruction(r_pre, r_ino) + [root]\n\nn = int(input())\n\nt = [None] * n\npre = list(map(int, input().split()))\nino = list(map(int, input().split()))\n\nprint(*reconsruction(pre, ino))"
  },
  {
    "language": "Python",
    "code": "N = int(input())\n\npre_list = list(map(lambda s: int(s) - 1, input().split()))\nin_list = list(map(lambda s: int(s) - 1, input().split()))\npost_list = []\n\n\ndef f(n, left, right):\n    num = pre_list[n]\n\n    if right - left == 1:\n        post_list.append(num)\n        return\n        \n    idx = in_list.index(num)\n    n += 1\n    if idx - left >= 1:\n        f(n, left, idx)\n    n += idx - left\n    if right - idx - 1 >= 1:\n        f(n, idx+1, right)\n    post_list.append(num)\n\n\nf(0, 0, N)\nprint(' '.join(map(lambda x: str(x+1), post_list)))\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n\tdef __init__(self, v):\n\t\tself.v = v\n\t\tself.l = self.r = None\n\t\tself.p = -1\n\tdef __str__(self):\n\t\treturn str(self.v)\n\ndef find_pos(a, v):\n\tfor i in range(len(a)):\n\t\tif a[i] == v:\n\t\t\treturn i\n\treturn -1\n\ndef add_node(root, cur, ino):\n\tcur.p = find_pos(ino, cur.v)\n\tst = []\n\tst.append(root)\n\twhile len(st) != 0:\n\t\tnode = st.pop()\n\t\tif node.p == -1:\n\t\t\tnode.p = find_pos(ino, node.v)\n\t\tif cur.p < node.p:\n\t\t\tif node.l == None:\n\t\t\t\tnode.l = cur\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\tst.append(node.l)\n\t\telse:\n\t\t\tif node.r == None:\n\t\t\t\tnode.r = cur\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\tst.append(node.r)\t\t\n\ndef post_order(root):\n\tst = []\n\tcur = root\n\tlast = None\n\tret = ''\n\twhile cur != None or len(st) != 0:\n\t\tif cur != None:\n\t\t\tst.append(cur)\n\t\t\tcur = cur.l\n\t\telse:\n\t\t\tpeek = st[len(st)-1]\n\t\t\tif peek.r != None and peek.r != last:\n\t\t\t\tcur = peek.r\n\t\t\telse:\n\t\t\t\tif len(ret) != 0:\n\t\t\t\t\tret += ' '\n\t\t\t\tret += str(peek)\n\t\t\t\tlast = st.pop()\n\treturn ret\n\nn = int(input())\npreo = list(map(int, input().split()))\nino = list(map(int, input().split()))\nroot = Node(preo[0])\nfor i in range(1, n):\n\tadd_node(root, Node(preo[i]), ino)\nprint(post_order(root))\n"
  },
  {
    "language": "Python",
    "code": "def postorder(pre,inor):\n    if len(pre) <= 1:\n        return pre\n    else:\n        root = pre[0]\n        i = inor.index(root)\n        leftin = inor[:i]\n        leftpre = pre[1:i+1]\n        rightin = inor[i+1:]\n        rightpre = pre[i+1:]\n        left = postorder(leftpre,leftin)\n        right = postorder(rightpre,rightin)\n        return left+right+[root]\nn = str(input())\npre = list(map(str,input().split()))\ninor = list(map(str,input().split()))\nprint(\" \".join(postorder(pre,inor)))\n"
  },
  {
    "language": "Python",
    "code": "def reconstruct(pre_tree,in_tree):\n    if not pre_tree:\n        return -1\n    root = pre_tree[0]\n    idx = in_tree.index(root)\n    tree[root] = (\n        reconstruct(pre_tree[1:idx+1],in_tree[:idx]),\n        reconstruct(pre_tree[idx+1:],in_tree[idx+1:])\n    )\n    return root\n\ndef post_walk(idx):\n    if idx == -1:\n        return \n    l_idx,r_idx = tree[idx]\n    yield from post_walk(l_idx)\n    yield from post_walk(r_idx)\n    yield idx\n\nn = int(input())\ntree = [None]*(n+1)\npre_lst = list(map(int,input().split()))\nin_lst = list(map(int,input().split()))\n\nreconstruct(pre_lst,in_lst)\nprint(' '.join(map(str,post_walk(pre_lst[0]))))\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\npre = list(map(int, input().split()))\nino = list(map(int, input().split()))\n\nd = []\nroot = pre[0]\npre = iter(pre).__next__\n\ndef dfs(l, r):\n    global d\n    if l >= r:\n        return\n    c = pre()\n    m = ino.index(c)\n    dfs(l, m)\n    dfs(m+1, r)\n    d += [c]\n    \ndfs(0, len(ino))\nprint(*d)\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\nreadline = sys.stdin.readline\nwrite= sys.stdout.write\n\nN = int(readline())\ns0 = map(int, readline().split())\ns1 = map(int, readline().split())\nst0 = []; st1 = []\nque = deque()\nq = next(s1, None)\nj = -1\nans = []\nfor v in s0:\n    while st1 and st1[-1] != j:\n        ans.append(st1.pop())\n    st1.append(v)\n\n    st0.append(v)\n    j = v\n    while st0 and st0[-1] == q:\n        j = st0.pop()\n        q = next(s1, None)\nwhile st1:\n    ans.append(st1.pop())\nprint(*ans)\n\n\n"
  },
  {
    "language": "Python",
    "code": "class Tree:\n    __slots__ = ['id', 'p', 'left', 'right']\n    def __init__(self, id):\n        self.id = id\n        self.left = -1\n        self.right = -1\n    def setc(self, c):\n        if self.left == -1:\n            self.left = c\n        else:\n            self.right = c\n    def __str__(self):\n        return f\"node {self.id}: left = {self.left}, right = {self.right}\"\nn = int(input())\ntree = tuple(Tree(i) for i in range(n + 1))\npretree = list(map(int, input().split()))\ninotree = list(map(int, input().split()))\nroot = pretree[0]\nroot_index = inotree.index(root)\nSET = set(pretree) - {root}\ndef treeSet(A, i):\n    if len(A) == 0:\n        return\n    global SET\n    c = root\n    r = pretree.index(A[0])\n    for a in pretree[i: r + 1]:\n        if c != a:\n            SET -= {a}\n            tree[c].setc(a)\n            c = a\n    for b in A[1:]:\n        if b not in SET:\n            c = b\n            continue\n        SET.add(b)\n        tree[c].setc(b)\n        c = b\ntreeSet(inotree[:root_index], 0)\ntreeSet(inotree[root_index + 1:], root_index + 1)\ndef postorder_tree_walk(id):\n    if tree[id].left != -1:\n        postorder_tree_walk(tree[id].left)\n    if tree[id].right != -1:\n        postorder_tree_walk(tree[id].right)\n    print(f\" {tree[id].id}\", end=\"\")\npostorder_tree_walk(root)\nprint()\n\n"
  },
  {
    "language": "Python",
    "code": "def reconstruct(pre, in_):\n    if not pre:\n        return -1\n    root = pre[0]\n    i = in_.index(root)\n    tree[root] = (reconstruct(pre[1 : i+1], in_[:i]), reconstruct(pre[i+1:], in_[i+1:]))\n    return root\n\ndef postorder(i):\n    if i == -1:\n        return\n    l, r = tree[i]\n    for v in postorder(l):\n        yield v\n    for v in postorder(r):\n        yield v\n    yield i\n\nn = int(input())\ntree = [None for i in range(n+1)]\npre_tree = list(map(int, input().split()))\nin_tree = list(map(int, input().split()))\nreconstruct(pre_tree, in_tree)\nprint(tree)\nprint(*postorder(pre_tree[0]))\n"
  },
  {
    "language": "Python",
    "code": "def reconstruct(preorder, inorder, postorder):\n    if len(preorder) == 0:\n        return\n    node_no = preorder[0]\n    node_div = inorder.index(node_no)\n\n    reconstruct(preorder[1:node_div+1], inorder[:node_div], postorder)\n    reconstruct(preorder[node_div+1:], inorder[node_div+1:], postorder)\n\n    postorder.append(node_no)\n    return\n\ndef main():\n    input()\n    preorder = [int(x) for x in input().split()]\n    inorder = [int(x) for x in input().split()]\n\n    postorder = []\n    reconstruct(preorder, inorder, postorder)\n    print(\" \".join(map(str, postorder)))\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\npreorder = list(map(int, input().split()))\ninorder   = list(map(int, input().split()))\n\nroot_used = []\n\ndef find(c, branch):\n    for i, x in enumerate(branch):\n        if x==c:\n            return i\n    return None\n    \ni = 0\nans = []\n    \ndef reconstruction(branch):\n    global i\n    \n    if len(branch)==0:\n        return\n        \n    if i>=len(preorder):\n        return\n    \n    c = preorder[i]\n    i += 1\n    m = find(c, branch)\n    \n    if m is None:\n        return \n    \n    left_branch = branch[:m]\n    right_branch = branch[m+1:]\n    \n    reconstruction(left_branch)\n    reconstruction(right_branch)\n    \n    ans.append(c)\n    \nreconstruction(inorder)\n\nprint(*ans)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\npostorder = list()\n\ndef reconstruction(preorder, inorder, l, r):\n    if l >= r:\n        return\n\n    c = preorder.popleft()\n    m = inorder.index(c)\n    reconstruction(preorder, inorder, l, m)\n    reconstruction(preorder, inorder, m + 1, r)\n    postorder.append(str(c))\n\ndef Main():\n    N = int(input())\n    preorder = deque(map(int, input().split()))\n    inorder = deque(map(int, input().split()))\n    reconstruction(preorder, inorder, 0, N)\n    print(*postorder)\n\nMain()\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\n*preorder, = map(int, input().split())\n*inorder, = map(int, input().split())\n\n\ndef reconstruction(l, r):\n    global preorder\n    global inorder\n\n    if l >= r:\n        return \"\"\n    a = \"\"\n    c = preorder.pop(0)\n    i = inorder.index(c)\n    a += reconstruction(l, i)\n    a += reconstruction(i+1, r)\n    a += f\"{c} \"\n    return a\n\n\nprint(reconstruction(0, n).strip())\n\n"
  },
  {
    "language": "Python",
    "code": "\nnil = -1\n\nclass Node:\n    def __init__(self):\n        self.parent = nil\n        self.left = nil\n        self.right = nil\n\ndef post_tw(node, ans):\n    if tree[node].left != nil:\n        post_tw(tree[node].left, ans)\n\n    if tree[node].right != nil:\n        post_tw(tree[node].right, ans)\n\n    ans.append(node + 1)\n\ndef reconst_tree(node, pretw_itr, subt):\n    n_i = subt.index(node)\n\n    left_subt = subt[:n_i]\n    right_subt = subt[n_i + 1:]\n\n    if left_subt:\n        left = next(pretw_itr)\n        tree[node].left = left\n        reconst_tree(left, pretw_itr, left_subt)\n\n    if right_subt:\n        right = next(pretw_itr)\n        tree[node].right = right\n        reconst_tree(right, pretw_itr, right_subt)\n\n\nn = int(input())\ntree = [Node() for i in range(n)]\n\npretw = [int(i) - 1 for i in input().split()]\nintw = [int(i) - 1 for i in input().split()]\n\npretw_itr = iter(pretw)\n\nroot = next(pretw_itr)\n\nreconst_tree(root, pretw_itr, intw)\n\nans = []\n\npost_tw(root, ans)\n\nprint(*ans)"
  },
  {
    "language": "Python",
    "code": "import copy\nclass node:\n    def __init__(self,nodeid):\n        self.parent = None\n        self.parentid = -1\n        self.c_leftid = -1\n        self.c_left = None\n        self.c_rightid = -1\n        self.c_right = None\n        self.nodeid = nodeid\n        self.type = \"root\"\n    def setLeftChild(self,cn):\n        self.c_left = cn\n        self.c_leftid = cn.nodeid\n        cn.parent = self\n        cn.parentid = self.nodeid\n        cn.setNodeType()\n        self.setNodeType()\n        return\n    def setRightChild(self,cn):\n        self.c_right = cn\n        self.c_rightid = cn.nodeid\n        cn.parent = self\n        cn.parentid = self.nodeid\n        cn.setNodeType()\n        self.setNodeType()\n        return\n    def getDepth(self):\n        cnt = 0\n        t = self\n        while True:\n            if (t.parentid == -1 ):\n                break\n            t = t.parent\n            cnt = cnt + 1\n        return cnt\n    def setNodeType(self):\n        if (self.getDepth() == 0):\n            self.type = \"root\"\n        else:\n            if ( self.c_rightid == -1 and self.c_leftid == -1 ):\n                self.type = \"leaf\"\n            else:\n                self.type = \"internal node\" \n    def getNodeType(self):\n        return self.type\n    def getSibling(self):\n        if ( self.parentid == -1):\n            return -1\n        i = self.parent\n        if ( i.c_rightid == self.nodeid ):\n            return i.c_leftid\n        elif ( i.c_leftid == self.nodeid):\n            return i.c_rightid\n    def getHeight(self):\n        lcnt = 0\n        rcnt = 0\n        if (self.c_leftid == -1  and self.c_rightid == -1 ):\n            return 0\n        elif (self.c_rightid  == -1):\n            lcnt = lcnt + self.c_left.getHeight() + 1\n        elif (self.c_leftid  == -1):\n            rcnt = rcnt + self.c_right.getHeight() + 1\n        else:\n            lcnt = lcnt + self.c_left.getHeight() + 1\n            rcnt = rcnt + self.c_right.getHeight() + 1\n        if (lcnt >= rcnt):\n            return lcnt\n        else:\n            return rcnt\n    def getDegree(self):\n        cnt = 0\n        if (self.c_leftid != -1):\n            cnt += 1\n        if (self.c_rightid != -1):\n            cnt += 1\n        return cnt\n    def getPreorder(self,r1):\n        r1.append(self.nodeid)\n        if (self.c_leftid != -1):\n            r1 = self.c_left.getPreorder(r1)\n        if (self.c_rightid != -1):\n            r1 = self.c_right.getPreorder(r1)\n        return r1       \n    def getInorder(self,r1):\n        if (self.c_leftid != -1):\n            r1 = self.c_left.getInorder(r1)\n        r1.append(self.nodeid)\n        if (self.c_rightid != -1):\n            r1 = self.c_right.getInorder(r1)\n        return r1       \n    def getPostorder(self,r1):\n        if (self.c_leftid != -1):\n            r1 = self.c_left.getPostorder(r1)\n        if (self.c_rightid != -1):\n            r1 = self.c_right.getPostorder(r1)\n        r1.append(self.nodeid)\n        return r1       \n    def getRoot(self):\n        if (self.parentid == -1):\n            return self\n        return self.parent.getRoot()\n\n\n    def showNode(self):\n        i1 = self.nodeid\n        i2 = self.parentid\n        i3 = self.getSibling()\n        i4 = self.getDegree()\n        i5 = self.getDepth()\n        i6 = self.getHeight()\n        i7 = self.getNodeType()\n        print ('node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, {}'.format(i1,i2,i3,i4,i5,i6,i7))\n        return\n\n\n\n#analysis\nn = int(input())\nl1 = list(map(int,input().split()))\nl2 = list(map(int,input().split()))\nl1.insert(0,-1)\nl1.append(-1)\nl2.insert(0,-1)\nl2.append(-1)\nl3 = copy.deepcopy(l2)\n\n#print (l1)\n#print (l2)\n\nilist = []\nfor i in range(1,n+1):\n    tmp = []\n    for j in range(1,n+1):\n        if (l1[i] == l2[j]):\n            l3[j] = -1\n#            t1 = list(filter(lambda a : a != -1,l3[j:]))\n            t1 = []\n            for v in range(j+1,n+1):\n                if (l3[v] == -1 ):\n                    break\n                t1.append(v)\n#            t2 = list(filter(lambda a : a != -1,l3[:j]))\n            t2 = []\n            for v in range(j-1,0,-1):\n                if (l3[v] == -1 ):\n                    break\n                t2.append(v)\n#            print (l1[i],i,j,t1,t2)\n            tmp.append(l1[i])\n            if (len(t2) > 0):\n                tmp.append(l1[i+1])\n                for k in range(1,n + 1):\n                    if (l3[k] == l1[i+1]):\n                        l3[k] = -1\n            else:\n                tmp.append(-1)\n            if (len(t1) > 0):\n                tmp.append(l1[i+len(t2)+1])\n                for k in range(1,n + 1):\n                    if (l3[k] == l1[i+len(t2)+1]):\n                        l3[k] = -1\n            else:\n                tmp.append(-1)\n            ilist.append(tmp)\n\n\n#make node\nnl = []\nfor i in range(0,n+1):\n    nl.append(node(i))\n\nfor t in ilist:\n    (a,b,c) = map(int,t)\n    if (b != -1):\n        nl[a].setLeftChild(nl[b])\n    if (c != -1):\n        nl[a].setRightChild(nl[c])\n#    print(a,b,c)\n\nroot = nl[1].getRoot()\nr1 = []\nr2 = []\nr3 = []\nr1 = root.getPreorder(r1)\nr2 = root.getInorder(r2)\nr3 = root.getPostorder(r3)\n\n#print (\"Preorder\")\n#print ('',' '.join(map(str,r1)))\n#print (\"Inorder\")\n#print ('',' '.join(map(str,r2)))\n#print (\"Postorder\")\nprint (' '.join(map(str,r3)))\n\n\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nA=list(map(int,input().split()))\nB=list(map(int,input().split()))\npreorder=(x for x in A)\npostorder=[]\n\ndef recontruction(l,r):\n    if l>=r:\n        return None\n    c=next(preorder)\n    m=B.index(c)\n    recontruction(l,m)\n    recontruction(m+1,r)\n    postorder.append(c)\n    \n\nrecontruction(0,n)\nprint(*postorder)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\npre = list(map(int, input().split()))\nino = list(map(int, input().split()))\n\nd = []\nroot = pre[1]\npre = iter(pre).__next__\n\ndef dfs(l, r):\n    global d\n    if l >= r:\n        return\n    c = pre()\n    m = ino.index(c)\n    dfs(l, m)\n    dfs(m+1, r)\n    d += [c]\n    \ndfs(0, len(ino))\nprint(*d)\n\n"
  },
  {
    "language": "Python",
    "code": "INF = 10**3\n\n\ndef reconstruction(p_ary, i_ary, l, r):\n    if l >= r:\n        return\n\n    c = INF\n    for i in i_ary[l:r]:\n        ind = p_ary.index(i)\n        if ind < c:\n            c = i\n    m = i_ary.index(c)\n\n    reconstruction(p_ary, i_ary, l, m)\n    reconstruction(p_ary, i_ary, m + 1, r)\n\n    print(c, end=' ')\n\n\nn = int(input())\np_ary = [int(_) for _ in input().split()]\ni_ary = [int(_) for _ in input().split()]\nreconstruction(p_ary, i_ary, 0, n)\n\n"
  },
  {
    "language": "Python",
    "code": "#coding:utf-8\nN = int(input())\npreList = list(input().split())\ninList = list(input().split())\n\ndef recon(l,r):\n    if l >= r:\n        return\n    global pos\n    c = preList[pos]\n    index = inList.index(c)\n    pos += 1\n    recon(l,index)\n    recon(index+1,r)\n    \n    global answer\n    answer.append(c)\n\nanswer = []\npos = 0\nrecon(0,N)\n\nanswer = \" \".join(answer)\nprint(answer)\n\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self, num, left, right):\n        self.value = num\n        self.left = left\n        self.right = right\n\nEmptyTree = None\n\ndef make_node(num, left, right):\n    return Node(num, left, right)\n\ndef value(tree):\n    return tree.value\n\ndef left(tree):\n    return tree.left\n\ndef right(tree):\n    return tree.right\n\ndef is_empty(tree):\n    return tree == EmptyTree\n\ndef make_leaf(num):\n    return make_node(num, EmptyTree, EmptyTree)\n\n# ????????¢?´¢??¨??¨??????????????????tree???x?????????????????°????????¨?????????\ndef add_node(tree, x):\n    if is_empty(tree):\n        return make_leaf(x)\n    elif x < value(tree):\n        return make_node(value(tree), add_node(left(tree), x), right(tree))\n    else:\n        return make_node(value(tree), left(tree), add_node(right(tree), x) )\n\ndef make_binary_search_tree(a):\n    tree = EmptyTree\n    # ????????????????????¶:\n    # ????????????i???????????£?????¨????????¨????¬????????????????????????§??????\n    # a?????????i???????????§???????´????????????¢?´¢??¨tree????????????????????????\n    for num in a:\n        tree = add_node(tree, num)\n    return tree\n\ndef inorder(tree):\n    if is_empty(tree):\n        return []\n    return inorder(left(tree)) + [value(tree)] + inorder(right(tree))\n\ndef preorder(tree):\n    if is_empty(tree):\n        return []\n    return [value(tree)] + preorder(left(tree)) + preorder(right(tree))\n\ndef postorder(tree):\n    if is_empty(tree):\n        return []\n    return postorder(left(tree)) + postorder(right(tree)) + [value(tree)]\n\n# ?????????????????¨????§??????¨???????????¨?????????????¨???????????????????\ndef calc(tree):\n    if is_empty(right(tree)) or is_empty(left(tree)):\n        return value(tree)\n\n    if value(tree) == \"+\":\n        return calc(right(tree)) + calc(left(tree))\n    elif value(tree) == \"-\":\n        return calc(right(tree)) - calc(left(tree))\n    elif value(tree) == \"*\":\n        return calc(right(tree)) * calc(left(tree))\n    elif value(tree) == \"/\":\n        return calc(right(tree)) / calc(left(tree))\n\ndef recover(preorder, inorder):\n    # preorder??????????????????root\n    # root???inorder??????????????¢???\n    # inorder??????root????¢??????????\n    # ?????????????????????Node??????????????£???????????????????????£?????????\n    if len(inorder) == 0:\n        return EmptyTree\n    root_val = preorder[0]\n    idx = inorder.index(root_val)\n    left = inorder[:idx]\n    right = inorder[idx+1:]\n    return make_node(root_val, recover(preorder[1:], left),  recover(preorder[1+len(left):],right) )\n\nn = input()\npre = list(map(int, input().split()))\nino = list(map(int, input().split()))\nt = recover(pre, ino)\nt = map(str, postorder(t))\nprint(' '.join(t))"
  },
  {
    "language": "Python",
    "code": "def reconstruction(l, r, pre, _in, result):\n    if l >= r:\n        return\n    c = pre[0]\n    del pre[0]\n    m = _in.index(c)\n    reconstruction(l, m, pre, _in, result)\n    reconstruction(m+1, r, pre, _in, result)\n    result.append(str(c))\n\n\ndef main():\n    n = int(input())\n    pre_order = list(map(int, input().split(' ')))\n    in_order = list(map(int, input().split(' ')))\n    ans = []\n    reconstruction(0, n, pre_order, in_order, ans)\n    print(' '.join(ans))\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\ndef post_order(id, list):\n    if id > -1:\n        post_order(node_dic[id].left, list)\n        post_order(node_dic[id].right, list)\n        list.append(id)\n\ndef gen_tree(root):\n    i = iol.index(root)\n    iol[i] = 0\n    if iol[i-1] != 0:\n        glt(root)\n    if iol[i+1] != 0:\n        grt(root)\n\ndef glt(root): #generate_left_tree\n    global p\n    p += 1\n    tmp = p\n    i = iol.index(pol[p])\n    gen_tree(pol[p])\n    node_dic[root].left = pol[tmp]\n\ndef grt(root): #generate_right_tree\n    global p\n    p += 1\n    tmp = p\n    i = iol.index(pol[p])\n    gen_tree(pol[p])\n    node_dic[root].right = pol[tmp]\n\nclass Node_Class():\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n\nn = int(raw_input())\nnode_dic = {}\nfor i in range(1, n+1):\n    node_dic[i] = Node_Class(-1, -1)\npol = map(int, raw_input().split()) #pre_order_list\niol = map(int, raw_input().split()) #in_order_list\niol.insert(n, 0)\niol.insert(0, 0)\np = 0\ngen_tree(pol[p])\nroot = 0\nfor i in range(1, n+1):\n    root += i\nfor i in range(1, n+1):\n    left = node_dic[i].left\n    right = node_dic[i].right\n    if left > -1:\n        root -= left\n    if right > -1:\n        root -= right\nA = []\npost_order(root, A)\nprint  \" \".join(map(str, A))"
  },
  {
    "language": "Python",
    "code": "from typing import List\n\n\ndef reconstruct_trees(preordered_list: List[int],\n                      inordered_list: List[int], node: int) -> None:\n    global trees\n    in_node_index = inordered_list.index(node)\n    in_left_list = inordered_list[:in_node_index]\n    in_right_list = inordered_list[in_node_index + 1:]\n    _ = preordered_list.index(node)\n    pr_left_list = preordered_list[1: 1 + len(in_left_list)]\n    pr_right_list = preordered_list[1 + len(in_left_list):]\n\n    if 0 == len(in_left_list):\n        pass\n    else:\n        next_node = pr_left_list[0]\n        trees[next_node]['parent'] = node\n        trees[node]['left-child'] = next_node\n        if 1 < len(in_left_list):\n            reconstruct_trees(pr_left_list, in_left_list, next_node)\n    if 0 == len(in_right_list):\n        pass\n    else:\n        next_node = pr_right_list[0]\n        trees[next_node]['parent'] = node\n        trees[node]['right-child'] = next_node\n        if 1 < len(in_right_list):\n            reconstruct_trees(pr_right_list, in_right_list, next_node)\n\n\ndef create_postorder(node: int) -> None:\n    global trees\n    global postordered_list\n    left_child = trees[node]['left-child']\n    right_child = trees[node]['right-child']\n    if -1 != left_child:\n        create_postorder(left_child)\n    if -1 != right_child:\n        create_postorder(right_child)\n    postordered_list.append(node)\n\n\nif __name__ == \"__main__\":\n    node_num = int(input())\n    trees = {idx + 1:\n             {\"parent\": -1, \"left-child\": -1, \"right-child\": -1}\n             for idx in range(node_num)}\n    preordered_list = list(map(lambda x: int(x), input().split()))\n    inordered_list = list(map(lambda x: int(x), input().split()))\n    postordered_list = []  # type: ignore\n\n    root_node = preordered_list[0]\n\n    reconstruct_trees(preordered_list, inordered_list, root_node)\n    create_postorder(root_node)\n\n    print(\" \".join([str(elem) for elem in postordered_list]))\n\n"
  },
  {
    "language": "Python",
    "code": "#coding:UTF-8\n\ndef RoT(A,B,ans):\n    if A:\n        root=A[0]\n        rindex=B.index(root)\n        Aleft=A[1:rindex+1]\n        Aright=A[rindex+1:]\n        Bleft=B[:rindex]\n        Bright=B[rindex+1:]\n        RoT(Aleft,Bleft,ans)\n        RoT(Aright,Bright,ans)\n        ans.append(root)\n        \n        \n\n\nif __name__==\"__main__\":\n    n=int(input())\n    A=input().split(\" \")\n    B=input().split(\" \")\n    ans=[]\n    RoT(A,B,ans)\n    print(\" \".join(ans))"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self, no):\n        self.no = no\n        self.parent = -1\n        self.left = self.right = -1\n    def postorder(self):\n        global t\n        L = []\n        if self.left >= 0: L += t[self.left].postorder()\n        if self.right >= 0: L += t[self.right].postorder()\n        L.append(self.no)\n        return L\n\ndef makeTree(parent, preList, inList):\n    global t\n    if preList == []:\n        return -1\n    root = preList[0]\n    t[root].parent = parent\n    index = inList.index(root)\n    t[root].left = makeTree(root, preList[1:index+1], inList[:index])\n    t[root].right = makeTree(root, preList[index+1:], inList[index+1:])\n    return root\n\nn = int(input())\nt = [ Node(i) for i in range(n+1) ]\npreList = list(map(int, input().split()))\ninList = list(map(int, input().split()))\nroot = makeTree(-1, preList, inList)\nprint(*t[root].postorder())\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\npre = list(map(int,input().split()))\nino = list(map(int,input().split()))\npos = []\n\ndef reconstruction(l, r):\n    if l >= r :\n        return\n    c = pre.pop(0)\n    m = ino.index(c)\n#     print(\"c\", c, l, r, m)\n    reconstruction(l, m)\n    reconstruction(m+1, r)\n    \n    global pos\n    pos += [c]\n\nreconstruction(0, len(ino))\nprint(\" \".join([str(ss) for ss in pos]))\n"
  },
  {
    "language": "Python",
    "code": "class BinaryTree:\n    class Node:\n        def __init__(self, nid, left, right):\n            self.id = nid\n            self.left = left\n            self.right = right\n\n        def has_left(self):\n            return self.left is not None\n\n        def has_right(self):\n            return self.right is not None\n\n        def __str__(self):\n            return str(self.id)\n\n    @classmethod\n    def create(cls, ids):\n        nodes = {}\n        def find(n, li):\n            for e1, e2, e3 in li:\n                if e1 == n:\n                    return (e2, e3)\n            raise ValueError()\n\n        def _create(nid):\n            if nid in nodes:\n                return nodes[nid]\n            if nid == -1:\n                return None\n\n            lid, rid = find(nid, ids)\n            if lid == -1 and rid == -1:\n                right = None\n                left = None\n            elif lid == -1:\n                right = _create(rid)\n                left = None\n            elif lid == -1:\n                right = None\n                left = _create(lid)\n            else:\n                right = _create(rid)\n                left = _create(lid)\n            nodes[nid] = cls.Node(nid, left, right)\n            return nodes[nid]\n\n        def _root(nodeids):\n            for nid in [n[0] for n in nodeids]:\n                if all([lid != nid and rid != nid for _, lid, rid in nodeids]):\n                    return nid\n\n        root = _create(_root(ids))\n        return cls(root)\n\n    def __init__(self, root):\n        self.root = root\n\n    def preorder(self):\n        def _preorder(node):\n            yield node\n            if node.has_left():\n                yield from _preorder(node.left)\n            if node.has_right():\n                yield from _preorder(node.right)\n        yield from _preorder(self.root)\n\n    def inorder(self):\n        def _inorder(node):\n            if node.has_left():\n                yield from _inorder(node.left)\n            yield node\n            if node.has_right():\n                yield from _inorder(node.right)\n        yield from _inorder(self.root)\n\n    def postorder(self):\n        def _postorder(node):\n            if node.has_left():\n                yield from _postorder(node.left)\n            if node.has_right():\n                yield from _postorder(node.right)\n            yield node\n        yield from _postorder(self.root)\n\ndef reconstruct(preorder, inorder):\n    \"\"\"Reconstruct a binary tree from preorder list\n    and inorder list of the tree.\n\n    >>> tree = reconstruct([1, 2, 3, 4, 5], [3, 2, 4, 1, 5])\n    >>> print(\" \".join([str(node) for node in tree.postorder()]))\n    3 4 2 5 1\n    \"\"\"\n    def _first(li):\n        if len(li) > 0:\n            return li[0]\n        else:\n            return -1\n\n    def _reconstruct(_pre, _in):\n        assert(len(_pre) == len(_in))\n        if len(_pre) == 0:\n            return []\n        if len(_pre) == 1:\n            return [[_pre[0], -1, -1]]\n        root, *pre = _pre\n        i = _in.index(root)\n        in1, in2 = _in[:i], _in[i+1:]\n        pre1, pre2 = _pre[1:i+1], _pre[i+1:]\n        return ([[root, _first(pre1), _first(pre2)]] +\n                _reconstruct(pre1, in1) +\n                _reconstruct(pre2, in2))\n\n    return BinaryTree.create(_reconstruct(preorder, inorder))\n\n\ndef run():\n    _ = int(input())\n    preorder = [int(i) for i in input().split()]\n    inorder = [int(i) for i in input().split()]\n\n    tree = reconstruct(preorder, inorder)\n    print(\" \".join([str(n) for n in tree.postorder()]))\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "def reconstruct(l, r):\n    if l >= r:\n        return\n    root = pre_list.pop(0)\n    center = in_list.index(root)\n    reconstruct(l, center) # 左部分木\n    reconstruct(center+1, r) #右部分木\n    ans_list.append(str(root))\n    \nN = int(input())\npre_list = list(map(int, input().split()))\nin_list = list(map(int, input().split()))\n\n#answer_output\nans_list = []\nreconstruct(0, N)\nprint(\" \".join(ans_list))\n\n"
  },
  {
    "language": "Python",
    "code": "def postorder(preo,ino):\n    if preo:\n        root = preo[0]\n        inroot = ino.index(root)\n        leftpre = preo[1:inroot+1]\n        leftin = ino[:inroot]\n        rightpre = preo[inroot+1:]\n        rightin = ino[inroot+1:]\n        postorder(leftpre,leftin)\n        postorder(rightpre,rightin)\n        post.append(root)\n\nindex = int(input())\npreorder = [int(n) for n in input().split(' ')]\ninorder = [int(n) for n in input().split(' ')]\npost = []\npostorder(preorder,inorder)\nfor p in range(index):\n    print(post[p],end=\" \")"
  },
  {
    "language": "Python",
    "code": "\nclass Node:\n    left = -1\n    right = -1\n\n\ndef get_root_index(first: int, end: int) -> int:\n    \"\"\"inorder[first:end]の根のインデックスを取得する。\n    根： inorder[first:end]を左部分木と右部分木に分割するノード\n    \"\"\"\n\n    # inorder[first:end]の要素でpreorderの一番手前にあるものが、\n    # inorder[first:end]を左部分木と右部分木に分割するノード。\n    # そのインデックスを返す。\n    for pre in preorder:\n        for j in range(first, end):\n            if pre == inorder[j]:\n                return j\n\n\ndef get_root(first, end) -> int:\n    \"\"\"inorder[first:end]の根のノードを返す。\n    \"\"\"\n\n    root_ix = get_root_index(first, end)\n    if root_ix is not None:\n        return inorder[root_ix]\n    else:\n        return -1\n\n\ndef set_nodes(first: int, end: int):\n    root_ix = get_root_index(first, end)\n    if first + 1 < root_ix:\n        set_nodes(first, root_ix)\n    if root_ix + 1 < end - 1:\n        set_nodes(root_ix + 1, end)\n    nodes[inorder[root_ix]].left = get_root(first, root_ix)\n    nodes[inorder[root_ix]].right = get_root(root_ix + 1, end)\n\n\ndef set_postorder(node_id: int) -> None:\n    \"\"\"後行順巡回で得られる節の番号を保存する。\n\n    Args:\n        node_id (int): [description]\n    \"\"\"\n\n    left = nodes[node_id].left\n    if left != -1:\n        set_postorder(left)\n\n    right = nodes[node_id].right\n    if right != -1:\n        set_postorder(right)\n\n    postorder.append(node_id)\n\n\nN = int(input())\nnodes = [Node() for i in range(N + 1)]\npreorder = [int(i) for i in input().split()]\ninorder = [int(i) for i in input().split()]\n\nset_nodes(0, N)\n\npostorder = []\nset_postorder(get_root(0, N))\nprint(' '.join(map(str, postorder)))\n"
  },
  {
    "language": "Python",
    "code": "#coding:UTF-8\n\ndef RoT(A,B,ans):\n    if A:\n        root=A[0]\n        rindex=B.index(root)\n        Aleft=A[1:rindex+1]\n        Aright=A[rindex+1:]\n        Bleft=B[:rindex]\n        Bright=B[rindex:]\n        RoT(Aleft,Bleft,ans)\n        RoT(Aright,Bright,ans)\n        ans.append(root)\n        \n        \n\n\nif __name__==\"__main__\":\n    n=int(input())\n    A=input().split(\" \")\n    B=input().split(\" \")\n    ans=[]\n    RoT(A,B,ans)\n    print(\" \".join(ans))"
  },
  {
    "language": "Python",
    "code": "def reconstruct(pre_list, in_list):\n    if len(pre_list) <= 1:\n        return pre_list\n    now = pre_list[0]\n    split_place = in_list.index(now)\n    pre_left = pre_list[1:split_place + 1]\n    in_left = in_list[0:split_place]\n    pre_right = pre_list[split_place + 1:]\n    in_right = in_list[split_place + 1:]\n    return reconstruct(pre_left, in_left) + reconstruct(pre_right, in_right) + [now]\n\ndef print_list_split_whitespace(a):\n    for x in a[:-1]:\n        print(x, end=\" \")\n    print(a[-1])\n\n\nn = int(input())\npre_list = [int(x) for x in input().split()]\nin_list = [int(x) for x in input().split()]\n\npost_list = reconstruct(pre_list, in_list)\nprint_list_split_whitespace(post_list)\n"
  },
  {
    "language": "Python",
    "code": "def postorder(preorder,inorder):\n    if len(preorder) > 1:\n        n = preorder[0]\n        left_inorder = []\n        right_inorder = []\n        flag = False\n        for i in range(len(inorder)):\n            if flag == False:\n                if n == inorder[i]:\n                    flag = True\n                else:\n                    left_inorder.append(inorder[i])\n            else:\n                right_inorder.append(inorder[i])\n        left_preorder = []\n        right_preorder = []\n        flag = False\n        for i in range(1,len(preorder)):\n            if flag == False:\n                if len(left_preorder) == len(left_inorder):\n                    flag = True\n                else:\n                    left_preorder.append(preorder[i])\n            if flag == True:\n                right_preorder.append(preorder[i])\n        #print left_preorder,left_inorder\n        #print right_preorder,right_inorder\n        #print\n        postorder(left_preorder,left_inorder)\n        postorder(right_preorder,right_inorder)\n    if len(preorder) > 0:\n        print preorder[0],\n\nn = int(raw_input())\npreorder = map(int,raw_input().split(' '))\ninorder = map(int,raw_input().split(' '))\n\npostorder(preorder,inorder)"
  },
  {
    "language": "Python",
    "code": "class Tree:\n    __slots__ = ['id', 'p', 'left', 'right']\n    def __init__(self, id):\n        self.id = id\n        self.left = -1\n        self.right = -1\n    def setc(self, c):\n        if self.left == -1:\n            self.left = c\n        else:\n            self.right = c\n    def __str__(self):\n        return f\"node {self.id}: left = {self.left}, right = {self.right}\"\nn = int(input())\ntree = tuple(Tree(i) for i in range(n + 1))\npretree = list(map(int, input().split()))\ninotree = list(map(int, input().split()))\nroot = pretree[0]\nroot_index = inotree.index(root)\nSET = set(pretree) - {root}\nans = []\ndef treeSet(A, i):\n    if len(A) == 0:\n        return\n    global SET\n    c = root\n    r = pretree.index(A[0])\n    for a in pretree[i: r + 1]:\n        if c != a:\n            SET -= {a}\n            tree[c].setc(a)\n            c = a\n    for b in A[1:]:\n        if b not in SET:\n            c = b\n            continue\n        SET.add(b)\n        tree[c].setc(b)\n        c = b\ntreeSet(inotree[:root_index], 0)\ntreeSet(inotree[root_index + 1:], root_index + 1)\ndef postorder_tree_walk(id):\n    if tree[id].left != -1:\n        postorder_tree_walk(tree[id].left)\n    if tree[id].right != -1:\n        postorder_tree_walk(tree[id].right)\n    global ans\n    ans.append(id)\npostorder_tree_walk(root)\nprint(*ans)\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding:utf-8 -*-\n\n\ndef reconstruction(n, preorder, inorder):\n    result = []\n\n    def rec(preorder, inorder):\n        if preorder == [] or inorder == []:\n            pass\n        else:\n            index = inorder.index(preorder[0]) + 1\n            rec(preorder[1:index], inorder[0:index-1])\n            rec(preorder[index:], inorder[index:])\n            result.append(str(preorder[0]))\n\n    rec(preorder, inorder)\n    print(\" \".join(result))\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    preorder = [int(x) for x in input().split()]\n    inorder = [int(x) for x in input().split()]\n    reconstruction(n, preorder, inorder)"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\nreadline = sys.stdin.readline\nwrite= sys.stdout.write\n\nN = int(readline())\ns0 = map(int, readline().split())\ns1 = map(int, readline().split())\nst0 = []; st1 = []\nque = deque()\nq = next(s1, None)\nj = -1\nans = []\nfor v in s0:\n    while st1 and st1[-1] != j:\n        ans.append(st1.pop())\n    st1.append(v)\n\n    st0.append(v)\n    j = v\n    while st0 and st0[-1] == q:\n        j = st0.pop()\n        q = next(s1, None)\nwhile st1:\n    ans.append(st1.pop())\nprint(*ans)\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nP = list(map(int,input().split()))\nI = list(map(int,input().split()))\n\npost = 0\nans = []\ndef reconstruction(l,r):\n    global post\n    if l >= r:\n        return None\n    c = P[post]\n    post += 1\n    for i in range(n):\n        if c == I[i]:\n            reconstruction(l,i)\n            reconstruction(i+1,r)\n    ans.append(c)\n\nreconstruction(0,n)\n\nfor i,a in enumerate(ans):\n    if i != n-1:\n        print(a,end=\" \")\n    else:\n        print(a)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nn = int(input())\nPre = iter([int(x) for x in input().split()])\nIn = [int(x) for x in input().split()]\nC = []\n\ndef Reconstruction(l, r):\n    if l >= r:\n        return\n    c = next(Pre)\n    m = In.index(c)\n    Reconstruction(l, m)\n    Reconstruction(m+1, r)\n    C.append(c)\n\nReconstruction(0, n)\nprint(*C)\n"
  },
  {
    "language": "Python",
    "code": "class Tree:\n    __slots__ = ['id', 'p', 'left', 'right']\n    def __init__(self, id):\n        self.id = id\n        self.left = -1\n        self.right = -1\n    def setc(self, c):\n        if self.left == -1:\n            self.left = c\n        else:\n            self.right = c\n    def __str__(self):\n        return f\"node {self.id}: left = {self.left}, right = {self.right}\"\nn = int(input())\ntree = tuple(Tree(i) for i in range(n + 1))\npretree = list(map(int, input().split()))\nm = {a:i for i, a in enumerate(pretree)}\ninotree = list(map(int, input().split()))\nroot = pretree[0]\ndef treeSet(A, id):\n    if A == []:\n        return -1\n    elif len(A) == 1:\n        return A[0]\n    min_A_index = A.index(id)\n    global tree\n    if 0 < min_A_index:\n        min_A = min(A[:min_A_index], key=lambda x: m[x])\n        left = treeSet(A[:min_A_index], min_A)\n        tree[id].left = left\n    if 0 < len(A) - min_A_index - 1:\n        min_A = min(A[min_A_index + 1:], key=lambda x: m[x])\n        right = treeSet(A[min_A_index + 1:], min_A)\n        tree[id].right = right\n    return id\ntreeSet(inotree, root)\nans = []\ndef postorder_tree_walk(id):\n    if tree[id].left != -1:\n        postorder_tree_walk(tree[id].left)\n    if tree[id].right != -1:\n        postorder_tree_walk(tree[id].right)\n    global ans\n    ans.append(id)\npostorder_tree_walk(root)\nprint(*ans)\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\npre = list(map(int, input().split()))\nino = list(map(int, input().split()))\n\nd = []\nroot = pre[1]\npre = iter(pre).__next__\n\ndef dfs(l, r):\n    if l >= r:\n        return\n    c = pre()\n    m = ino.index(c)\n    dfs(l, m)\n    dfs(m+1, r)\n    d += [c]\n    \ndfs(0, len(ino))\nprint(*c)\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n5\n1 2 3 4 5\n3 2 4 1 5\n\noutput:\n3 4 2 5 1\n\"\"\"\n\nimport sys\n\n\n# recursively defines a binary tree\n# node.left or node.right may also be a binary tree\nclass TreeNode:\n    __slots__ = ('val', 'left', 'right')\n\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\n\ndef rec(pre_order, in_order, post_order):\n    if not pre_order:\n        return None, list()\n    else:\n        rt = TreeNode(pre_order[0])\n        rt_pos = in_order.index(pre_order[0])\n        rt.left = rec(pre_order[1:1 + rt_pos], in_order[:rt_pos], post_order)\n        rt.right = rec(pre_order[rt_pos + 1:], in_order[rt_pos + 1:], post_order)\n\n        # append rt.val at last to implement post_order node scan\n        post_order.append(rt.val)\n        return rt, post_order\n\n\ndef solve():\n    _input = sys.stdin.readlines()\n    array_length = int(_input[0])\n    pre_order = list(map(int, _input[1].split()))\n    in_order = list(map(int, _input[2].split()))\n    # assert len(pre_order) == len(in_order) == array_length\n    \n    post_order = list()\n    ans = rec(pre_order=pre_order, in_order=in_order, post_order=post_order)\n    print(*ans[1])\n    return None\n\n\nif __name__ == '__main__':\n    solve()"
  },
  {
    "language": "Python",
    "code": "N=int(input())\npreorder=list(map(int,input().split()))\ninorder=list(map(int,input().split()))\npre_iter=iter(preorder)\nbisect_tree = [[None,None] for i in range(N+1)]\n\ndef reconst(l,r):\n    global pre_iter\n    if r-l <= 0:\n        return\n    if r-l == 1:\n        next(pre_iter)\n        return inorder[l]\n    partial_root = next(pre_iter)\n    partial_root_position = inorder.index(partial_root)\n    left_child = reconst(l,partial_root_position)\n    right_child = reconst(partial_root_position+1,r)\n    bisect_tree[partial_root][0]=left_child\n    bisect_tree[partial_root][1]=right_child\n    return partial_root\nans=[]\ndef postorder(node):\n    if bisect_tree[node] == [None,None]:\n        ans.append(node)\n    else:\n        if bisect_tree[node][0] != None:\n            postorder(bisect_tree[node][0])\n        if bisect_tree[node][1] != None:\n            postorder(bisect_tree[node][1])\n        ans.append(node)\n\ndef root_search():\n    parent=[-1]*(N+1)\n    for i in range(1,N+1):\n        if bisect_tree[i][0] != None:\n            parent[bisect_tree[i][0]]=i\n        if bisect_tree[i][1] != None:\n            parent[bisect_tree[i][1]]=i\n    for i in range(1,N+1):\n        if parent[i] == -1:\n            break\n    return i\n\nreconst(0,N)\nroot = root_search()\npostorder(root)\nprint(*ans)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\npre = list(map(int, input().split()))\nino = list(map(int, input().split()))\n\n\nroot = pre[1]\npre = iter(pre).__next__\n\ndef dfs(l, r):\n    if l >= r:\n        return\n    c = pre()\n    m = ino.index(c)\n    dfs(l, m)\n    dfs(m+1, r)\n    print(c)\n    \ndfs(0, len(ino))\n\n\n"
  },
  {
    "language": "Python",
    "code": "def postorder(preo,ino):\n    if preo:\n        root = preo[0]\n        inroot = ino.index(root)\n        leftpre = preo[1:inroot+1]\n        leftin = ino[:inroot]\n        rightpre = preo[inroot+1:]\n        rightin = ino[inroot+1:]\n        postorder(leftpre,leftin)\n        postorder(rightpre,rightin)\n        post.append(root)\n\nindex = int(input())\npreorder = [int(n) for n in input().split(' ')]\ninorder = [int(n) for n in input().split(' ')]\npost = []\npostorder(preorder,inorder)\nprint(*post)"
  },
  {
    "language": "Python",
    "code": "#coding:utf-8\nN = int(input())\npreList = \"\".join(list(input().split()))\ninList = \"\".join(list(input().split()))\n\ndef recon(l,r):\n    if l >= r:\n        return\n    global pos\n    c = preList[pos]\n    index = inList.find(c)\n    pos += 1\n    recon(l,index)\n    recon(index+1,r)\n    \n    global answer\n    answer.append(c)\n\nanswer = []\npos = 0\nrecon(0,N)\n\nanswer = \" \".join(answer)\nprint(answer)\n\n\n"
  },
  {
    "language": "Python",
    "code": "#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_7_D\n\ndef postorder(binary_tree, target_index, result):\n    \n    left = binary_tree[target_index][\"left\"]\n    right = binary_tree[target_index][\"right\"]\n    \n    if not left == -1:\n        postorder(binary_tree, left, result)\n    if not right == -1:\n        postorder(binary_tree, right, result)\n\n    result.append(target_index)\n\ndef solve(preorder_list, inorder_list, result):\n    #print(preorder_list, inorder_list)\n    if len(inorder_list) == 1:\n        return inorder_list[0]\n    \n    parent = preorder_list[0]\n    left_trees = inorder_list[:inorder_list.index(parent)]\n    right_tree_index = 1\n    if left_trees:\n        result[parent][\"left\"] = solve(preorder_list[1:], left_trees, result)\n        right_tree_index = preorder_list.index(left_trees[-1]) + 1\n        \n    right_trees = inorder_list[inorder_list.index(parent) + 1:]\n    if right_trees:\n        result[parent][\"right\"] = solve(preorder_list[right_tree_index:], right_trees, result)\n\n    return parent\n\ndef reconstruction(preorder_list, inorder_list, node_num):\n    result = [{\"left\":-1,\"right\":-1} for i in range(node_num + 1)]\n    solve(preorder_list, inorder_list, result)\n    return result\n\ndef main():\n    node_num = int(input())\n    preorder_list = [int(a) for a in input().split()]\n    inorder_list = [int(a) for a in input().split()]\n    binary_tree = reconstruction(preorder_list, inorder_list, node_num)\n    postorder_list = []\n    postorder(binary_tree, preorder_list[0], postorder_list)\n    print(*postorder_list)\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "#Reconstruction of the Tree\nn = int(input())\npre = list(map(int,input().split()))\nino = list(map(int,input().split()))\n\npost=[]\ni = -1\ndef recaonstruction(l, r):\n    global i\n    if l >= r:\n        return\n    i += 1\n    c = pre[i]\n    m = ino.index(c)\n    reconstruction(l, m)\n    reconstruction(m+1, r)\n    post.append(c)\nreconstruction(0, n)\nprint(\" \".join(map(str,post)))"
  },
  {
    "language": "Python",
    "code": "postorder = []\n\ndef printpostorder(inorder, preorder, n): \n    if preorder[0] in inorder: \n        root = inorder.index(preorder[0]) \n          \n    if root != 0: # left subtree exists \n        printpostorder(inorder[:root],  \n                       preorder[1:root + 1],  \n                       len(inorder[:root])) \n      \n    if root != n - 1: # right subtree exists \n        printpostorder(inorder[root + 1:],   \n                       preorder[root + 1:],  \n                       len(inorder[root + 1:])) \n    \n    postorder.append(preorder[0])\n          \n\nn = int(input())\npreorder = list(map(int, input().split()))\ninorder = list(map(int, input().split()))\nprintpostorder(inorder, preorder, n)\n\nprint( \" \".join( [ str(i) for i in postorder ]))\n"
  },
  {
    "language": "Python",
    "code": "postorder_elements = []\n\ndef post_from_pre_in(preorder_elements, inorder_elements):\n    if preorder_elements:\n        root = preorder_elements[0]\n        root_index = inorder_elements.index(root)\n        preorder_left = preorder_elements[1:root_index+1]\n        inorder_left = inorder_elements[:root_index]\n        preorder_right = preorder_elements[root_index+1:]\n        inorder_right = inorder_elements[root_index+1:]\n        post_from_pre_in(preorder_left, inorder_left)\n        post_from_pre_in(preorder_right, inorder_right)\n        postorder_elements.append(root)\n\n\n\nn = int(input())\n\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\npost_from_pre_in(a, b)\n\nprint(*postorder_elements)"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(2**25)\n\nn = int(input())\npre_ls = list(map(int, input().split()))\nin_ls = list(map(int, input().split()))\n\npos = 0\npost_ls = []\n\ndef rec(left: int, right: int):\n    global pos\n    if left >= right:\n        return\n    tmp_root = pre_ls[pos]\n    pos += 1\n    mid = in_ls.index(tmp_root)\n    # 右部分木->左部分木->根の後方順巡回になっている\n    rec(left, mid)\n    rec(mid+1, right)\n    post_ls.append(tmp_root)\n\n\ndef solve():\n    pos = 0\n    rec(0, len(pre_ls))\n    print(*post_ls)\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "from collections import namedtuple\nNode = namedtuple('Node', ['parent', 'children'])\n   \nclass my_binary_tree:\n    def __init__(self, preorderList, inorderList):\n        self.T = {}\n        self.reconstruction(preorderList,inorderList)\n   \n    def reconstruction(self, preorderList, inorderList, parent=-1):\n        i = preorderList[0]\n        p = parent\n        j = inorderList.index(i) \n        llen = len(inorderList[:j])\n        rlen = len(inorderList[j+1:])\n        if llen > 0: c0 = self.reconstruction(preorderList[1:llen+1],inorderList[:llen],i)\n        else       : c0 = -1\n        if rlen > 0: c1 = self.reconstruction(preorderList[llen+1:],inorderList[llen+1:],i)\n        else       : c1 = -1\n        self.T[i] = Node(p,[c0,c1])\n        return i\n   \n    def getPostorderList(self, i):\n        c0 = self.T[i].children[0]\n        c1 = self.T[i].children[1]\n        if c0 != -1: yield from self.getPostorderList(c0)\n        if c1 != -1: yield from self.getPostorderList(c1)\n        yield i\n   \n    \nif __name__=='__main__':\n    n = int(input())\n    preorderList = list(map(int,input().split()))\n    inorderList  = list(map(int,input().split()))\n    tree = my_binary_tree(preorderList,inorderList)\n        \n    print(*tree.getPostorderList(preorderList[0]))"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef postordered_tree_walk(preordered, inordered, route):\n    def work(pos, l_in, r_in):\n        if (l_in >= r_in): return\n\n        root_id = preordered[pos]\n        split_point = inordered.index(root_id, l_in, r_in)\n\n        work(pos + 1, l_in, split_point)\n        work(pos + (split_point - l_in) + 1, split_point + 1, r_in)\n        route.append(root_id)\n\n    work(0, 0, len(inordered))\n\nn = int(input())\npreordered_route = list(map(int, sys.stdin.readline().split()))\ninordered_route = list(map(int, sys.stdin.readline().split()))\n\npostordered = []\npostordered_tree_walk(preordered_route, inordered_route, postordered)\n\nprint(*postordered)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\npreorderList = [int(i) for i in input().split()]\ninorderList = [int(i) for i in input().split()]\n\nclass Node:\n    def __init__(self, idn):\n        self.id = idn\n        self.left = -1\n        self.right = -1\nT = [Node(i+1) for i in range(n)]\n\ndef splitTree(P, I):\n    b = I.index(P[0])\n    if P[0] != I[0]:\n        T[P[0]-1].left = P[1]\n    if P[0] != I[-1]:\n        T[P[0]-1].right = P[b+1]\n    if b > 1:\n        splitTree(P[1:b+1], I[:b])\n    if b < len(I)-2:\n        splitTree(P[b+1:], I[b+1:])\n\nsplitTree(preorderList, inorderList)\nroot = preorderList[0]\n\npostorderList = []\ndef setPostorderList(p):\n    if T[p-1].left != -1:\n        setPostorderList(T[p-1].left)\n    if T[p-1].right != -1:\n        setPostorderList(T[p-1].right)\n    postorderList.append(T[p-1].id)\n\nsetPostorderList(root)\nprint(*postorderList)\n\n"
  },
  {
    "language": "Python",
    "code": "def reconstract(l, r):\n    if l >= r:\n        return None\n\n    c = next(root)\n    m = in_hoge.index(c)\n    \n    reconstract(l, m)\n    reconstract(m+1, r)\n    \n    post_hoge.append(c)\n\nif __name__ == '__main__':\n    _ = int(input())\n    pre_hoge = [int(x) for x in input().split()]\n    root = (x for x in pre_hoge)\n    in_hoge = [int(x) for x in input().split()]\n    post_hoge = list()\n    \n    reconstract(0, len(pre_hoge))\n    \n    print(' '.join([str(x) for x in post_hoge]))\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\npreorder = list(map(int,input().split()))\ninorder = list(map(int,input().split()))\npostorder = []\n\ndef rec(l):\n    if len(l) == 0:\n        return\n    # preorderから次の値を取り出す\n    x = preorder.pop(0)\n    for i in range(len(l)):\n        if l[i] == x:\n            # preorderの値と一致したら、そこから左右に分割\n            rec(l[:i])\n            rec(l[i+1:])\n    postorder.append(x)\n    return\n\nrec(inorder)\nprint(*postorder)\n\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\n\nclass Node:\n    def __init__(self):\n        self.children = [-1, -1]\n\n###\n\ndef initNode(t_pre, t_in):\n    global nodes\n    if len(t_in) == 1:\n        nodes[t_in[0]].children = [-1, -1]\n        return t_in[0]\n    else:\n        r = t_in.index(t_pre[0])\n        if r == 0: # 左部分木はなし\n            rr = initNode(t_pre[1:], t_in[1:])\n            nodes[t_in[r]].children = [-1, rr]\n        elif r == len(t_in)-1: # 右部分木はなし\n            lr = initNode(t_pre[1:r+1], t_in[:r])\n            nodes[t_in[r]].children = [lr, -1]\n        else:\n            lr = initNode(t_pre[1:r+1], t_in[:r])\n            rr = initNode(t_pre[r+1:], t_in[r+1:])\n            nodes[t_in[r]].children = [lr, rr]\n\n        return t_in[r]\n\ndef postorder(i):\n    global nodes, res\n    if i != -1:\n        c = nodes[i].children\n        postorder(c[0])\n        postorder(c[1])\n        res.append(i)\n\nn = int(stdin.readline().rstrip())\nt_pre = [int(x) for x in stdin.readline().rstrip().split()]\nt_in = [int(x) for x in stdin.readline().rstrip().split()]\n\nnodes = [Node() for _ in range(n+1)]\ninitNode(t_pre, t_in)\n\nres = []\npostorder(t_pre[0])\nprint(*res)\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nimport queue\n\nclass Node:\n    def __init__(self, myNum, left, right):\n        self.myNum = myNum\n        self.left = left\n        self.right = right\n        self.parent = -1\n        self.bs = -1\n        self.nodeType = \"\"\n        self.degree = -1\n        self.depth = -1\n        self.height = -1\n\n\nn = int(input().rstrip())\npreorder = [int(i)-1 for i in input().rstrip().split()]\ninorder = [int(i)-1 for i in input().rstrip().split()]\nnodes = []\n\n# reconstruct the origin\ndef createTree(preorder, inorder):\n    if not preorder:\n        return -1\n    if not inorder:\n        return -1\n    parent = preorder[0]\n    pidx = inorder.index(parent)\n    leftInorder = inorder[:pidx]\n    rightInorder = inorder[pidx+1:]\n    leftPreorder = []\n    rightPreorder = []\n    for item in preorder:\n        if item in leftInorder:\n            leftPreorder.append(item)\n        if item in rightInorder:\n            rightPreorder.append(item)\n    left = createTree(leftPreorder,leftInorder)\n    right = createTree(rightPreorder,rightInorder)\n    nodes.append(Node(parent, left, right))\n    return parent\n\ncreateTree(preorder, inorder)\nnodes = sorted(nodes, key = lambda x: x.myNum)\n\n# 親ノード、degreeを設定する\nfor node in nodes:\n    dg = 0\n    if node.left != -1:\n        nodes[node.left].parent = node.myNum\n        dg += 1\n    if node.right != -1:\n        nodes[node.right].parent = node.myNum\n        dg += 1\n    node.degree = dg\n \n# 兄弟ノードを設定する\nfor node in nodes:\n    if node.left != -1 and node.right != -1:\n        nodes[node.left].bs = nodes[node.right].myNum\n        nodes[node.right].bs = nodes[node.left].myNum\n \n# nodeTypeを設定する\nfor node in nodes:\n    if node.parent == -1:\n        node.nodeType = \"root\"\n        node.depth = 0\n        rootNum = node.myNum\n    elif node.left == -1 and node.right == -1:\n        node.nodeType = \"leaf\"\n    else:\n        node.nodeType = \"internal node\"\n \n# depthを設定する\nq = queue.Queue()\nq.put(nodes[rootNum])\nwhile not q.empty():\n    nd = q.get()\n    if nd.left != -1:\n        nodes[nd.left].depth = nd.depth + 1\n        q.put(nodes[nd.left])\n    if nd.right != -1:\n        nodes[nd.right].depth = nd.depth + 1\n        q.put(nodes[nd.right])\n \n# heightを設定する\nfor node in nodes:\n    if node.parent == -1 or node.nodeType == \"leaf\":\n        node.height = 0\n        q.put(node)\nwhile not q.empty():\n    nd = q.get()\n    if nd.parent != -1:\n        nodes[nd.parent].height = max(nodes[nd.parent].height, nd.height + 1)\n        q.put(nodes[nd.parent])\n\nans = []\n\n# Preorder\ndef dfsPreorder(x):\n    if nodes[x].height == 0:\n        ans.append(x)\n        return\n    \n    ans.append(nodes[x].myNum)\n    if nodes[x].left != -1:\n        dfsPreorder(nodes[x].left)\n    if nodes[x].right != -1:\n        dfsPreorder(nodes[x].right)\n\n# Inorder\ndef dfsInorder(x):\n    if nodes[x].height == 0:\n        ans.append(x)\n        return\n    \n    if nodes[x].left != -1:\n        dfsInorder(nodes[x].left)\n    ans.append(nodes[x].myNum)\n    if nodes[x].right != -1:\n        dfsInorder(nodes[x].right)\n    \n# Postorder\ndef dfsPostorder(x):\n    if nodes[x].height == 0:\n        ans.append(x+1)\n        return\n    \n    if nodes[x].left != -1:\n        dfsPostorder(nodes[x].left)\n    if nodes[x].right != -1:\n        dfsPostorder(nodes[x].right)\n    ans.append(nodes[x].myNum+1)\n\ndfsPostorder(rootNum)\nprint(\" \".join(str(i) for i in ans))\n"
  },
  {
    "language": "Python",
    "code": "I = 0\nL = 1\nR = 2\nP = 3\nB = 4\nD = 5\nH = 6\n\ndef getidx(Tree,value):\n    idx = -1\n    for i in range(len(Tree)):\n        if Tree[i][I] == value:\n            idx = i\n            break\n    return idx\n\ndef search(Tree, A, B, num):\n    root = A[0]\n    rootidx = getidx(Tree,root)\n    ld = num\n    for i in range(num):\n        if B[i] == root:\n            ld = i\n            break\n    if ld > 0:\n        left,lidx = search(Tree,A[1:ld+1],B[:ld],ld)\n        Tree[rootidx][L] = lidx\n    rt = ld + 1\n    if rt < num:\n        right,ridx = search(Tree,A[rt:],B[rt:],num - rt)\n        Tree[rootidx][R] = ridx\n    return (root,rootidx)\n\ndef postorder(Tree, nidx, A):\n    if nidx < 0:\n        return\n    postorder(Tree,Tree[nidx][L],A)\n    postorder(Tree,Tree[nidx][R],A)\n    A.append(Tree[nidx][I])\n\n\ndef main():\n\n    \"\"\" ????????? \"\"\"\n    num = int(input().strip())\n    plist = list(map(int,input().split()))\n    ilist = list(map(int,input().split()))\n    tree = []\n    for i in plist:\n        tree.append([i, -1, -1, -1, -1, 0, 0])\n\n    root,ridx = search(tree, plist, ilist, num)\n\n    pos = []\n\n    postorder(tree, ridx, pos)\n    print(\" \".join(map(str,pos)))\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "def reconstruct(pre, in_):\n    if not pre:\n        return -1\n    root = pre[0]\n    i = in_.index(root)\n    tree[root] = (reconstruct(pre[1 : i+1], in_[:i]), reconstruct(pre[i+1:], in_[i+1:]))\n    return root\n\ndef postorder(i):\n    if i == -1:\n        return\n    l, r = tree[i]\n    for v in postorder(l):\n        yield v\n    for v in postorder(r):\n        yield v\n    yield i\n\nn = int(input())\ntree = [None for i in range(n+1)]\npre_tree = list(map(int, input().split()))\nin_tree = list(map(int, input().split()))\nreconstruct(pre_tree, in_tree)\nprint(*postorder(pre_tree[0]))\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\npreorder & inorder\n\n5\n1 2 3 4 5\n3 2 4 1 5\n\n9\n1 2 3 4 5 6 7 8 9\n3 2 5 4 6 1 8 7 9\n\noutput:\npostorder\n3 4 2 5 1\n\"\"\"\n\nimport sys\n\n\n# recursively defines a binary tree\n# node.left or node.right may also be a binary tree\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\n\ndef reconstruction(_pre_order, _in_order):\n    # write your code here\n    if not _pre_order:\n        return None\n    root = TreeNode(_pre_order[0])\n    root_position = _in_order.index(_pre_order[0])\n    root.left = reconstruction(_pre_order=_pre_order[1:1 + root_position], _in_order=_in_order[:root_position])\n    root.right = reconstruction(_pre_order=_pre_order[root_position + 1:], _in_order=_in_order[root_position + 1:])\n    print(root.val, end=' ')\n    # post_order.append(root.val)\n    return root.val\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    array_length = int(_input[0])\n    pre_order = list(map(int, _input[1].split()))\n    in_order = list(map(int, _input[2].split()))\n    # assert len(pre_order) == len(in_order) == array_length\n\n    # post_order = []\n    reconstruction(_pre_order=pre_order, _in_order=in_order)\n    # print('')\n    # print(*post_order)"
  },
  {
    "language": "Python",
    "code": "pos = 0\npostorder = []\ndef reconstruction(l, r):\n    global pos\n    global postorder\n    if l >= r:\n        return\n    # print(pos)\n    c = preorder[pos]\n    m = inorder.index(c)\n    pos += 1\n   \n    # 左側を復元\n    reconstruction(l, m)\n    # 右側を復元\n    reconstruction(m + 1, r)\n    postorder.append(c)\n\nn = int(input())\npreorder = list(map(int, input().split()))\ninorder = list(map(int, input().split()))\n\nreconstruction(0, n)\nprint(\" \".join(map(str, postorder)))\n"
  },
  {
    "language": "Python",
    "code": "def post(P, I):\n    if len(I)==0:\n        return \"\"\n    elif len(I)==1:\n        return I[0]\n    else:\n        root = I.index(P[0])\n        right = len(P)\n        for i in I[root+1:]:\n            if P.index(i) < right:\n                right = P.index(i)\n        return post(P[1:right],I[:root]) + \" \" + post(P[right:], I[root+1:]) + \" \" + I[root]\n    \nn = int(input())\nP = input().split()\nI = input().split()\nans = \"\"\nfor i in post(P,I).split():\n    ans+=i + \" \"\nprint(ans[:-1])\n"
  },
  {
    "language": "Python",
    "code": "#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_7_D\n\ndef postorder(binary_tree, target_index, result):\n    \n    left = binary_tree[target_index][\"left\"]\n    right = binary_tree[target_index][\"right\"]\n    \n    if not left == -1:\n        postorder(binary_tree, left, result)\n    if not right == -1:\n        postorder(binary_tree, right, result)\n\n    result.append(target_index)\n\ndef solve(preorder_list, inorder_list, result):\n    if len(inorder_list) == 1:\n        return inorder_list[0]\n    #print(result)\n    parent = preorder_list[0]\n\n    left_trees = inorder_list[:inorder_list.index(parent)]\n    right_tree_index = 1\n    if left_trees:\n        result[parent][\"left\"] = solve(preorder_list[1:], left_trees, result)\n        right_tree_index = preorder_list.index(left_trees[-1])\n        \n    right_trees = inorder_list[inorder_list.index(parent) + 1:]\n    if right_trees:\n        result[parent][\"right\"] = solve(preorder_list[right_tree_index:], right_trees, result)\n\n    return parent\n\ndef reconstruction(preorder_list, inorder_list, node_num):\n    result = [{\"left\":-1,\"right\":-1} for i in range(node_num + 1)]\n    solve(preorder_list, inorder_list, result)\n    return result\n\ndef main():\n    node_num = int(input())\n    preorder_list = [int(a) for a in input().split()]\n    inorder_list = [int(a) for a in input().split()]\n    binary_tree = reconstruction(preorder_list, inorder_list, node_num)\n    postorder_list = []\n    postorder(binary_tree, preorder_list[0], postorder_list)\n    print(*postorder_list)\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "class Node():\n    def __init__(self):\n        self.parent = -1\n        self.left = -1\n        self.right = -1\n\n\ndef reconstruction(preo, ino):\n    root = preo[0]\n\n    ileft = ino[0:ino.index(root)]\n    iright = ino[ino.index(root)+1:]\n\n    pleft = preo[1:]\n    pright = preo[1:]\n\n    for item in iright:\n        pleft.remove(item)\n\n    for item in ileft:\n        pright.remove(item)\n\n    if len(pleft) == 0:\n        pass\n    elif len(pleft) == 1:\n        Nodes[root-1].left = pleft[0]\n    else:\n        Nodes[root-1].left = reconstruction(pleft, ileft)\n\n    if len(pright) == 0:\n        pass\n    elif len(pright) == 1:\n        Nodes[root-1].right = pright[0]\n    else:\n        Nodes[root-1].right = reconstruction(pright, iright)\n\n    return root\n\n\ndef postorder(id):\n    if Nodes[id-1].left != -1:\n        postorder(Nodes[id-1].left)\n\n    if Nodes[id-1].right != -1:\n        postorder(Nodes[id-1].right)\n\n    ans.append(id)\n\n\ndef main():\n    n = int(input())\n    global Nodes\n    Nodes = [Node() for i in range(n)]\n\n    preorder = list(map(int, input().split()))\n    inorder = list(map(int, input().split()))\n\n    rootid = reconstruction(preorder, inorder)\n\n    global ans\n    ans = []\n    postorder(rootid)\n    print(*ans)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\npreorder & inorder\n\n5\n1 2 3 4 5\n3 2 4 1 5\n\n9\n1 2 3 4 5 6 7 8 9\n3 2 5 4 6 1 8 7 9\n\noutput:\npostorder\n3 4 2 5 1\n\"\"\"\n\nimport sys\n\n\n# recursively defines a binary tree\n# node.left or node.right may also be a binary tree\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\n\ndef reconstruction(_pre_order, _in_order):\n    # write your code here\n    if not _pre_order:\n        return None\n    root = TreeNode(_pre_order[0])\n    root_position = _in_order.index(_pre_order[0])\n    root.left = reconstruction(_pre_order=_pre_order[1:1 + root_position], _in_order=_in_order[:root_position])\n    root.right = reconstruction(_pre_order=_pre_order[root_position + 1:], _in_order=_in_order[root_position + 1:])\n    post_order.append(root.val)\n    return root.val\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    array_length = int(_input[0])\n    pre_order = list(map(int, _input[1].split()))\n    in_order = list(map(int, _input[2].split()))\n    # assert len(pre_order) == len(in_order) == array_length\n\n    post_order = []\n    reconstruction(_pre_order=pre_order, _in_order=in_order)\n    print(*post_order)"
  },
  {
    "language": "Python",
    "code": "class Tree():\n    def __init__(self):\n        self.nodes = {}\n        self.nodes[-1] = None\n    def add_node(self, id):\n        if id not in self.nodes:\n            self.nodes[id] = Node(id)        \n    def add_child(self, parent_id, left_id, right_id):\n        self.add_node(parent_id)\n        self.add_node(left_id)\n        self.add_node(right_id)\n        self.nodes[parent_id].add_child(self.nodes[left_id], self.nodes[right_id])\n    def root(self):\n        for node in self.nodes.values():\n            if node and node.nodetype() == 'root':\n                return node\n    \nclass Node():\n    def __init__(self, id):\n        self.id = id\n        self.parent = self.left = self.right = None\n        self.depth = self.height = 0\n\n    def add_child(self, left, right):\n        self.left = left\n        self.right = right\n        \n        self.update_height()\n        \n        for child in self.children():\n            child.parent = self\n            child.update_depth()\n    def update_height(self):\n        if self.degree():\n            self.height = max([child.height + 1 for child in self.children()])\n            if self.parent:\n                self.parent.update_height()\n            \n    def update_depth(self):\n        self.depth = self.parent.depth + 1\n        for child in self.children():\n            child.update_depth()\n                \n    def nodetype(self):\n        if self.parent:\n            if self.degree():\n                return 'internal node'\n            else:\n                return 'leaf'\n        else:\n            return 'root'\n    def degree(self):\n        return len(self.children())\n    \n    def children(self):\n        return [child for child in [self.left, self.right] if child]\n    \n    def sibling(self):\n        if self.parent and self.parent.degree() == 2:\n            if self.parent.left == self:\n                return self.parent.right.id\n            else:\n                return self.parent.left.id\n        else:\n            return -1\n\n    def __str__(self):\n        return 'node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, {}'.format(\n            self.id,\n            self.parent.id if self.parent else - 1,\n            self.sibling(),\n            self.degree(),\n            self.depth,\n            self.height,\n            self.nodetype())\n    def walk(self, order):\n        orders = {'Preorder':[self, self.left, self.right], 'Inorder':[self.left, self, self.right], 'Postorder':[self.left, self.right, self]}\n        \n        for node in orders[order]:\n            if node == self:\n                yield node\n            elif node:\n                for childnode in node.walk(order):\n                    yield childnode\n\ndef make_tree(tree, preorder, inorder):\n    if len(preorder) == 0:\n        return -1\n    root_id = preorder[0]    \n    root_index = inorder.index(root_id)\n    left_id = make_tree(tree, preorder[1:root_index + 1], inorder[:root_index])\n    right_id = make_tree(tree, preorder[root_index + 1:], inorder[root_index + 1:])\n    tree.add_child(root_id, left_id, right_id)\n    return root_id\n    \nn = int(input())\npreorder = list(map(int, input().split()))\ninorder = list(map(int, input().split()))\n\ntree = Tree()\nroot_id = make_tree(tree, preorder, inorder)\n\nprint(*[node.id for node in tree.nodes[root_id].walk('Postorder')])"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import defaultdict\n\nNIL = -1\nn = int(input())\npre = list(map(int, sys.stdin.readline().split()))\nino = list(map(int, sys.stdin.readline().split()))\npost = []\n\npos = 0\n\ndef rec(l, r,):\n    global pos # posはglobal変数だと明示する\n    if l >= r:\n        return\n    root = pre[pos]\n    pos += 1\n    m = ino.index(root)\n    rec(l, m)\n    rec(m+1, r)\n    post.append(str(root))\n\npos = 0\n\nrec(0, n)\nprint(' '.join(post))\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\npre = list(map(int, input().split()))\nino = list(map(int, input().split()))\n\nd = []\nroot = pre[1]\npre = iter(pre).__next__\n\ndef dfs(l, r):\n    if l >= r:\n        return\n    c = pre()\n    m = ino.index(c)\n    dfs(l, m)\n    dfs(m+1, r)\n    d += [c]\n    \ndfs(0, len(ino))\nprint(*d)\n\n"
  },
  {
    "language": "Python",
    "code": "INF = 10**3\n\n\ndef reconstruction(o_ary, p_ary, i_ary, l, r):\n    if l >= r:\n        return\n\n    ind = INF\n    for i in i_ary[l:r]:\n        tmp_ind = p_ary.index(i)\n        if ind > tmp_ind:\n            ind = tmp_ind\n    c = p_ary[ind]\n    m = i_ary.index(c)\n\n    reconstruction(o_ary, p_ary, i_ary, l, m)\n    reconstruction(o_ary, p_ary, i_ary, m + 1, r)\n    o_ary.append(c)\n\n\nn = int(input())\np_ary = [int(_) for _ in input().split()]\ni_ary = [int(_) for _ in input().split()]\no_ary = []\nreconstruction(o_ary, p_ary, i_ary, 0, n)\nprint(*o_ary)\n\n"
  },
  {
    "language": "Python",
    "code": "def toPostorder(prelist, inlist):\n    parent = prelist[0]\n    split_index = inlist.index(parent)\n    if split_index != 0:\n        yield from toPostorder(prelist[1:split_index + 1],inlist[0:split_index])\n    if split_index != len(inlist)-1:\n        yield from toPostorder(prelist[split_index + 1:],inlist[split_index + 1:])\n\n    yield parent\n\nnodes = dict()\nn = int(input())\npreorder = list(map(int, input().split()))\ninorder = list(map(int, input().split()))\nprint(*toPostorder(preorder, inorder))\n"
  },
  {
    "language": "Python",
    "code": "I = 0\nL = 1\nR = 2\nP = 3\nB = 4\nD = 5\nH = 6\n\ndef getidx(Tree,value):\n    idx = -1\n    for i in range(len(Tree)):\n        if Tree[i][I] == value:\n            idx = i\n            break\n    return idx\n\ndef search(Tree, A, B, num):\n    \"\"\" Tree ??? Tree A???Preorder?????? B???Inorder??????\n        ??????????????????????????§??? root ??? index ????????? \"\"\"\n    root = A[0]\n    rootidx = getidx(Tree,root)\n    ld = num\n    for i in range(num):\n        if B[i] == root:\n            ld = i\n            break\n    if ld > 0:\n        left,lidx = search(Tree,A[1:ld+1],B[:ld],ld)\n        Tree[rootidx][L] = lidx\n    rt = ld + 1\n    if rt < num:\n        right,ridx = search(Tree,A[rt:],B[rt:],num - rt)\n        Tree[rootidx][R] = ridx\n    return (root,rootidx)\n\ndef getroot(Tree, nidx):\n    pidx = Tree[nidx][P]\n    if pidx < 0:\n        return nidx\n    return getroot(Tree,pidx)\n\nef postorder(Tree, nidx, A):\n    if nidx < 0:\n        return\n    postorder(Tree,Tree[nidx][L],A)\n    postorder(Tree,Tree[nidx][R],A)\n    A.append(Tree[nidx][I])\n\n\ndef main():\n\n    \"\"\" ????????? \"\"\"\n    num = int(input().strip())\n    plist = list(map(int,input().split()))\n    ilist = list(map(int,input().split()))\n    tree = []\n    for i in plist:\n        tree.append([i, -1, -1, -1, -1, 0, 0])\n\n    root,ridx = search(tree, plist, ilist, num)\n\n    pos = []\n\n    postorder(tree, ridx, pos)\n    print(\" \".join(map(str,pos)))\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "def getPostorder(preorder, inorder):\n    if not preorder:\n        return []\n    postorder = []\n    root = preorder[0]\n    rootIndex = inorder.index(root)\n\n    postorder.extend(getPostorder(preorder[1:rootIndex + 1], inorder[:rootIndex]))\n    postorder.extend(getPostorder(preorder[rootIndex + 1:], inorder[rootIndex + 1:]))\n    postorder.append(root)\n\n    return postorder \n\nif __name__ == '__main__':\n    n = int(input())\n    preorder = list(map(int, input().split()))\n    inorder = list(map(int, input().split()))\n    print(*getPostorder(preorder, inorder))"
  },
  {
    "language": "Python",
    "code": "# Tree - Reconstruction of a Tree\nclass Node:\n    none = 0\n    right = 1\n    left = -1\n    def is_leaf(self):\n        d = 1 if self.right else 0\n        d += 1 if self.left else 0\n        return self.depth > 0 and d == 0\n    def num_child(self):\n        d = 1 if self.right else 0\n        d += 1 if self.left else 0\n        return d\n    \n    def __init__(self, id):\n        self.id = id\n        self.parent = None\n        self.sibling = None\n        # ?????¨?????¨????????¨?????¨????????¨\n        self.right,self.left = None,None\n        self.depth = 0\n        self.height = 0\n        self.position = Node.none\n    def __str__(self):\n        p = self.parent.id if self.parent else -1\n        s = self.sibling.id if self.sibling else -1\n        d = 1 if self.right else 0\n        d += 1 if self.left else 0\n        typ = 'root'\n        if self.depth > 0: typ = 'internal node'\n        if d == 0 and self.depth > 0: typ = 'leaf'\n        h = self.height\n        return 'node {0}: parent = {1}, sibling = {2}, degree = {3}, depth = {4}, height = {5}, {6}'.format(self.id, p, s, d, self.depth, h, typ)\n\ndef calc_cld_depth(nd):\n    \"\"\"?????????????????±???????¨??????????\"\"\"\n    if nd.left:\n        nd.left.depth = nd.depth + 1\n        calc_cld_depth(nd.left)\n    if nd.right:\n        nd.right.depth = nd.depth + 1\n        calc_cld_depth(nd.right)\n\ndef rec(preo, ino):\n    idx = -1\n    proot = None # ??¨?????¨????????????\n    for p in preo:\n        if p in ino:\n            idx = ino.index(p)\n            proot = p\n            break\n    else:\n        raise # unexpected error\n    # ??????idx???????????\\??£??????\n    pleft = ino[:idx]\n    pright = ino[idx+1:]\n    prlen = len(pright)\n    pllen = len(pleft)\n    if prlen == 1:\n        # ????????????pright??????????????????proot??????\n        pright[0].parent = proot\n        pright[0].depth = proot.depth + 1\n        proot.right = pright[0]\n    if pllen == 1:\n        # ????????????pleft??????????????????proot??????\n        pleft[0].parent = proot\n        pleft[0].depth = proot.depth + 1\n        proot.left = pleft[0]\n    # ??°??????ino???????????????????????§????????????preo???????????£?????????\n    if prlen > 1:\n        for r in pright:\n            r.parent = proot\n            r.depth = proot.depth + 1\n        pprt = rec(preo[1+pllen:], pright)\n        proot.right = pprt\n    if pllen > 1:\n        for l in pleft:\n            l.parent = proot\n            l.depth = proot.depth + 1\n        pprt = rec(preo[1:1+pllen], pleft)\n        proot.left = pprt\n\n    if prlen == 0: proot.right = None\n    if pllen == 0: proot.left = None\n    return proot\n\nn = int(input())\nnds = [Node(i+1) for i in range(n)] # id??????????????§??????(????????????)????????????id???1\npreo = [nds[int(i)-1] for i in input().split()]\nino = [nds[int(i)-1] for i in input().split()]\n# ????????°??¨??????????????\\????????????????????°???????????±???????????????\nroot = rec(preo, ino)\nfrom collections import deque\ndq = deque()\n# Postorder\nvisited = [None]*n\ncnt = 0\ndq.append(root)\nwhile len(dq) > 0:\n    pp = dq.pop()\n    dl = pp.num_child()\n    if dl == 0:\n        visited[cnt] = pp\n        cnt += 1\n        continue\n    if dl > 0:\n        l,r = pp.left, pp.right\n        if (l and l not in visited) or (r and r not in visited):\n            if pp: dq.append(pp)\n            if r: dq.append(r)\n            if l: dq.append(l)\n        else:\n            visited[cnt] = pp\n            cnt += 1\n            continue\n\nss = ''\nfor v in visited: ss += ' '+str(v.id)\nprint(ss[1:])\n"
  },
  {
    "language": "Python",
    "code": "def getPostorder(preorder, inorder):\n    if not preorder:\n        return []\n    postorder = []\n    root = preorder[0]\n    rootIndex = inorder.index(root)\n\n    postorder.extend(getPostorder(preorder[1:rootIndex + 1], inorder[:rootIndex]))\n    postorder.extend(getPostorder(preorder[rootIndex + 1:], inorder[rootIndex + 1:]))\n    postorder.append(root)\n\n    return postorder \n\nif __name__ == '__main__':\n    n = int(input())\n    preorder = list(map(int, input().split()))\n    inorder = list(map(int, input().split()))\n    print(getPostorder(preorder, inorder))"
  },
  {
    "language": "Python",
    "code": "\n\nn=int(input())\npreorder=[int(i)for i in input().split()]\ninorder=[int(i)for i in input().split()]\npost=[]\npos=0\ndef recon(left,right):\n    global inorder\n    global pos\n    if left>=right:\n        return\n    root=preorder[pos]\n    pos+=1\n    mid=inorder.index(root)\n    recon(left,mid)\n    recon(mid+1,right)\n    post.append(str(root))\n\nrecon(0,n)\nprint(\" \".join(post))\n"
  },
  {
    "language": "Python",
    "code": "def postorder(preo,ino):\n    if preo:\n        root = preo[0]\n        inroot = ino.index(root)\n        leftpre = preo[1:inroot+1]\n        leftin = ino[:inroot]\n        rightpre = preo[inroot+1:]\n        rightin = ino[inroot+1:]\n        postorder(leftpre,leftin)\n        postorder(rightpre,rightin)\n        post.append(root)\n\nindex = int(input())\npreorder = [int(n) for n in input().split(' ')]\ninorder = [int(n) for n in input().split(' ')]\npost = []\npostorder(preorder,inorder)\nfor p in range(index):\n    print(post[p],end=\" \")"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self, x):\n        self.x = x\n        self.left = None\n        self.right = None\n\n\ndef reconstruct(x, y):\n    top = x[0]\n    root = Node(top)\n    # print(\"root:\", top)\n\n    mid = y.index(top)\n    left = y[:mid]\n    right = y[mid+1:]\n    if len(left) > 0:\n        root.left = reconstruct(x[1:mid+1], left)\n    if len(right) > 0:\n        root.right = reconstruct(x[mid+1:], right)\n\n    return root\n\n\ndef postorder(L, node):\n    if node is None:\n        return\n    postorder(L, node.left)\n    postorder(L, node.right)\n    L.append(node.x)\n\n\nif __name__ == \"__main__\":\n    input()\n    preorder = input().split()\n    inorder = input().split()\n    root = reconstruct(preorder, inorder)\n    L = []\n    postorder(L, root)\n    print(' '.join(L))"
  },
  {
    "language": "Python",
    "code": "\n\ndef reconstruction(left, right):\n    global pos\n    if left >= right:\n        return\n    c = preorder[pos]\n    pos += 1\n    m = inorder.index(c)\n    reconstruction(left, m)\n    reconstruction(m + 1, right)\n    postorder.append(str(c))\n\npos = 0\npostorder = []\n\nn=int(input())\npreorder=list(map(int,input().split()))\ninorder=list(map(int,input().split()))\nreconstruction(0, n)\nprint(' '.join(postorder))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef reconst(pre, ino):\n    if len(pre) == 0:\n        return\n    elif len(pre) == 1:\n        print pre[0],\n        return\n\n    root = ino.index(pre[0])\n    preLeft, preRight = pre[1:root + 1], pre[root + 1:]\n    inLeft, inRight = ino[:root], ino[root + 1:]\n\n    reconst(preLeft, inLeft)\n    reconst(preRight, inRight)\n    print pre[0],\n\nif __name__ == \"__main__\":\n    lines = sys.stdin.readlines()\n    pre = map(int, lines[1].split())\n    ino = map(int, lines[2].split())\n    reconst(pre, ino)"
  },
  {
    "language": "Python",
    "code": "\ndef reconstruction(left, right):\n    if left >= right:\n        return\n\n    global position, pre, ino, post\n    root = pre[position]\n    position += 1\n\n    mid = ino.index(root)  # inoでのrootのポジション\n    reconstruction(left, mid)\n    reconstruction(mid + 1, right)\n\n    post.append(root)\n\n\nn = int(input())\n\npre = list(map(int, input().split()))\nino = list(map(int, input().split()))\npost = []\n\nposition = 0\nreconstruction(0, n)\n\nprint(' '.join(map(str, post)))\n\n"
  },
  {
    "language": "Python",
    "code": "def set_children(inorder_list):\n    global p\n    rn = preorder[p]\n    i = inorder_list.index(rn)\n    left_side = inorder_list[:i]\n    right_side = inorder_list[i:]\n    right_side.remove(rn)\n    if left_side:\n        p += 1\n        set_children(left_side)\n    if right_side:\n        p += 1\n        set_children(right_side)\n    postorder.append(rn)\n\nif __name__ == \"__main__\":\n    p = 0\n    n = int(input())\n    preorder = input().split()\n    inorder = input().split()\n    postorder = []\n    set_children(inorder[:])\n    print(\" \".join(postorder))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\n\ndef main():\n    def find_chi(l, r):\n        if l == r:\n            return l\n        min_pre_i = n + 1\n        pui = -1\n        for ino_i in range(l, r + 1):\n            if pre_i[ino_i] < min_pre_i:\n                min_pre_i = pre_i[ino_i]\n                pui = ino_i\n        if pui - l > 0:\n            chi[ino[pui]][0] = ino[find_chi(l, pui - 1)]\n        if r - pui > 0:\n            chi[ino[pui]][1] = ino[find_chi(pui + 1, r)]\n        return pui\n\n    def dfs(u):\n        l, r = chi[u]\n        if l != -1: dfs(l)\n        if r != -1: dfs(r)\n        pos.append(u)\n\n    n = int(input())\n    pre = list(map(int, input().split()))\n    ino = list(map(int, input().split()))\n    chi = {}\n    for u in pre:\n        chi[u] = [-1, -1]\n    utoi = {u: i for i, u in enumerate(pre)}\n    pre_i = []\n    for u in ino:\n        pre_i.append(utoi[u])\n    root = ino[find_chi(0, n - 1)]\n    pos = []\n    dfs(root)\n    print(*pos)\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\n\nPr = list(map(int, input().split()))\nI = list(map(int, input().split()))\nPo = []\n\ndef Rec(Pr,I):\n  a = I.index(Pr[0])\n  if a >= 1:\n    Rec(Pr[1:a+1],I[0:a])\n    if a < len(Pr)-1:\n      Rec(Pr[a+1:],I[a+1:])\n    Po.append(Pr[0])\n  else:\n    A = []\n    A.append(Pr[0])\n    if len(Pr) > 1:\n      Rec(Pr[1:],I[1:])\n    while A != []:\n      Po.append(A.pop())\n\nRec(Pr, I)\n\nprint(\" \".join(map(str, Po)))\n"
  },
  {
    "language": "Python",
    "code": "#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_7_D\n\ndef postorder(binary_tree, target_index, result):\n    \n    left = binary_tree[target_index][\"left\"]\n    right = binary_tree[target_index][\"right\"]\n    \n    if not left == -1:\n        postorder(binary_tree, left, result)\n    if not right == -1:\n        postorder(binary_tree, right, result)\n\n    result.append(target_index)\n\ndef solve(preorder_list, inorder_list, result):\n    #print(preorder_list, inorder_list)\n    if len(inorder_list) == 1:\n        return inorder_list[0]\n    \n    parent = preorder_list[0]\n    left_trees = inorder_list[:inorder_list.index(parent)]\n    right_tree_index = 1\n    if left_trees:\n        result[parent][\"left\"] = solve(preorder_list[1:], left_trees, result)\n        right_tree_index = len(left_trees) + 1\n        \n    right_trees = inorder_list[inorder_list.index(parent) + 1:]\n    if right_trees:\n        result[parent][\"right\"] = solve(preorder_list[right_tree_index:], right_trees, result)\n\n    return parent\n\ndef reconstruction(preorder_list, inorder_list, node_num):\n    result = [{\"left\":-1,\"right\":-1} for i in range(node_num + 1)]\n    solve(preorder_list, inorder_list, result)\n    return result\n\ndef main():\n    node_num = int(input())\n    preorder_list = [int(a) for a in input().split()]\n    inorder_list = [int(a) for a in input().split()]\n    binary_tree = reconstruction(preorder_list, inorder_list, node_num)\n    postorder_list = []\n    postorder(binary_tree, preorder_list[0], postorder_list)\n    print(*postorder_list)\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "import sys\n\nN = int(sys.stdin.readline().rstrip())  # 節点数\n_Pre = [int(x) for x in sys.stdin.readline().rstrip().split()]\n_In = [int(x) for x in sys.stdin.readline().rstrip().split()]\n\n\ndef narabekae(pre_lists, in_lists):\n\n    # 入ってきた順列から、（根／）左側／右側を作る\n    rt = pre_lists[0]\n\n    # print(rt, pre_lists, in_lists)\n\n    rt_idx = in_lists.index(rt)\n\n    left = pl_lf = pre_lists[1:rt_idx + 1]\n    il_lf = in_lists[:rt_idx]\n    right = pl_rg = pre_lists[rt_idx + 1:]\n    il_rg = in_lists[rt_idx + 1:]\n\n    if len(left) > 1:\n        left = narabekae(pl_lf, il_lf)\n\n    if len(right) > 1:\n        right = narabekae(pl_rg, il_rg)\n\n    new_list = []\n    new_list.extend(left)\n    new_list.extend(right)\n    new_list.extend([rt])\n\n    # print(rt, left, right)\n\n    return new_list\n\n\ndef main():\n\n    lst = narabekae(_Pre, _In)\n\n    print(*lst)\n\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "# https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/7/ALDS1_7_D\n# 難しい 解き方は図を参照\nimport sys\nsys.setrecursionlimit(2**20)  # 再帰回数上限の向上 かなり多くしないとREになる\n\n\nclass Node:\n    def __init__(self,\n                 parent=None,\n                 left=None,\n                 right=None):\n        self.parent = parent\n        self.left = left  # 左の子ノード\n        self.right = right  # 右の**子**\n\n\n# 答えの列を作るときに必要\ndef post_parse(T, u, post_ls):\n    if u == None:\n        return\n    post_parse(T, T[u].left, post_ls)\n    post_parse(T, T[u].right, post_ls)\n    post_ls.append(u)\n\n\n# データの読み込み\nN = int(input())\npre_ls = list(map(int, input().split()))\nin_ls = list(map(int, input().split()))\nroot_pos = 0\nROOT = pre_ls[root_pos]\nT = {key+1: Node() for key in range(N)}\n\n# 再帰関数で復元する\n\n\ndef rec(l: int, r: int, root_pos: int):\n    '''\n    l,rはin_lsに対して範囲を指定するidx\n    l:rであり、半開区間\n    root_posはpre_lsにおけるrootのidx。本では木の左下から復元するのを前提に実装していたが、\n    ここではどういう順番で復元しても大丈夫なように実装する。\n    '''\n    # 即時終了条件\n    if r-l <= 1:  # 指定区間が1ノード以下になったらおかしいので終了\n        return\n    root = pre_ls[root_pos]\n    mid = in_ls.index(root)  # rootを持つ要素のidxを返す\n\n    # 木の復元\n    # 左部分木がある場合\n    if mid != l:\n        root_pos_left = root_pos+1  # preorderにおいては左部分木のroot_posは必ず現在の位置の隣になる\n        T[pre_ls[root_pos]].left = pre_ls[root_pos_left]\n        T[pre_ls[root_pos_left]].parent = pre_ls[root_pos]\n        # 次の探索へ\n        rec(l, mid, root_pos_left)\n    # 右部分木がある場合\n    if mid != r-1:  # rは一つ先を指定していることに注意すると気付ける\n        root_pos_right = root_pos+1+mid-l  # 右部分木のrootは、左部分木がおわった直後にある\n        T[pre_ls[root_pos]].right = pre_ls[root_pos_right]\n        T[pre_ls[root_pos_right]].parent = pre_ls[root_pos]\n        rec(mid+1, r, root_pos_right)\n\n\n# 木の復元\nrec(0, N, root_pos)\n\n# # print(T)\n# for i in range(N):\n#     print(T[i+1].parent, T[i+1].left, T[i+1].right)\n# post orderの作成\npost_ls = []\npost_parse(T, ROOT, post_ls)\n\nprint(*post_ls)\n\n"
  },
  {
    "language": "Python",
    "code": "index = 0\nanswer = []\n\n\ndef postorder_treewalk(left, right):\n    if left >= right:\n        return\n\n    global index, answer\n\n    node_mid = preorder[index]\n    index += 1\n    mid = inorder.index(node_mid)\n\n    postorder_treewalk(left, mid)\n    postorder_treewalk(mid + 1, right)\n    answer += [node_mid]\n\n\n\nn = int(input())\npreorder = list(map(int, input().split()))\ninorder = list(map(int, input().split()))\n\n\npostorder_treewalk(0, n)\nprint(*answer)\n\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nPRE = [int(i) for i in input().split()]\nIN = [int(i) for i in input().split()]\nPOST = []\n\npos = 0\n\ndef rec(left, right):\n    global pos\n    if right <= left:\n        return\n    root = PRE[pos]\n    pos += 1\n    mid = IN.index(root)\n    rec(left, mid)\n    rec(mid + 1, right)\n    POST.append(root)\n\nrec(0, N)\nprint(*POST)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\npreorder & inorder\n\n5\n1 2 3 4 5\n3 2 4 1 5\n\n9\n1 2 3 4 5 6 7 8 9\n3 2 5 4 6 1 8 7 9\n\noutput:\npostorder\n3 4 2 5 1\n\"\"\"\n\nimport sys\n\n\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\n\ndef reconstruction(_pre_order, _in_order):\n    # write your code here\n    if not _pre_order:\n        return None\n    root = TreeNode(_pre_order[0])\n    root_position = _in_order.index(_pre_order[0])\n    root.left = reconstruction(_pre_order=_pre_order[1:1 + root_position], _in_order=_in_order[:root_position])\n    root.right = reconstruction(_pre_order=_pre_order[root_position + 1:], _in_order=_in_order[root_position + 1:])\n    post_order.append(root.val)\n    return root.val\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    array_length = int(_input[0])\n    pre_order = list(map(int, _input[1].split()))\n    in_order = list(map(int, _input[2].split()))\n    # assert len(pre_order) == len(in_order) == array_length\n\n    post_order = []\n    reconstruction(_pre_order=pre_order, _in_order=in_order)\n    print(*post_order)"
  },
  {
    "language": "Python",
    "code": "def reconstruction(left, right, pre_order, in_order, traversal):\n    if left >= right:\n        return traversal\n    else:\n        next_pre_node = pre_order.pop(0)\n        pos_in_order = in_order.index(next_pre_node)\n\n        traversal = reconstruction(left, pos_in_order, pre_order, in_order, traversal)\n        traversal = reconstruction(pos_in_order + 1, right, pre_order, in_order, traversal)\n        traversal.append(next_pre_node)\n        return traversal\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    pre_order = list(map(int, input().split()))\n    in_order = list(map(int, input().split()))\n    traversal = reconstruction(0, n, pre_order, in_order, [])\n    print(*traversal)\n"
  },
  {
    "language": "Python",
    "code": "from collections import namedtuple\nNode = namedtuple('Node', ['parent', 'children'])\n   \nclass my_binary_tree:\n    def __init__(self, preorderList, inorderList):\n        self.T = {}\n        self.reconstruction(preorderList,inorderList)\n   \n    def reconstruction(self, preorderList, inorderList, parent=-1):\n        i = preorderList[0]\n        p = parent\n        j = inorderList.index(i) \n        llen = len(inorderList[:j])\n        rlen = len(inorderList[j+1:])\n        if llen > 0: c0 = self.reconstruction(preorderList[1:llen+1],inorderList[:llen],i)\n        else       : c0 = -1\n        if rlen > 0: c1 = self.reconstruction(preorderList[llen+1:],inorderList[llen+1:],i)\n        else       : c1 = -1\n        self.T[i] = Node(p,[c0,c1])\n        return i\n   \n    def getRoot(self, i=1):\n        p = self.T[i].parent\n        if p == -1: return i \n        return self.getRoot(p)\n   \n    def getPostorderList(self, i, L=[]):\n        c0 = self.T[i].children[0]\n        c1 = self.T[i].children[1]\n        if c0 != -1: self.getPostorderList(c0, L)\n        if c1 != -1: self.getPostorderList(c1, L)\n        L.append(i)\n        return L\n   \n    \nif __name__=='__main__':\n    n = int(input())\n    preorderList = list(map(int,input().split()))\n    inorderList  = list(map(int,input().split()))\n    tree = my_binary_tree(preorderList,inorderList)\n        \n    r = tree.getRoot()\n    print(*tree.getPostorderList(r))"
  },
  {
    "language": "Python",
    "code": "def postorder(n,preorder,inorder):\n    if len(preorder) > 1:\n        left_inorder = []\n        right_inorder = []\n        flag = False\n        for i in range(len(inorder)):\n            if flag == False:\n                if n == inorder[i]:\n                    flag = True\n                else:\n                    left_inorder.append(inorder[i])\n            else:\n                right_inorder.append(inorder[i])\n        left_preorder = []\n        right_preorder = []\n        flag = False\n        for i in range(1,len(preorder)):\n            if flag == False:\n                left_preorder.append(preorder[i])\n                if len(left_preorder) == len(left_inorder):\n                    flag = True\n            else:\n                right_preorder.append(preorder[i])\n        postorder(left_preorder[0],left_preorder,left_inorder)\n        postorder(right_preorder[0],right_preorder,right_inorder)\n    if len(preorder) >= 0:\n        print n,\n\nn = int(raw_input())\npreorder = map(int,raw_input().split(' '))\ninorder = map(int,raw_input().split(' '))\n\npostorder(preorder[0],preorder,inorder)"
  },
  {
    "language": "Python",
    "code": "if __name__ == '__main__':\n    import sys\n    input = sys.stdin.readline\n\n    from collections import defaultdict\n\n    NIL = -1\n\n    n = int(input())\n\n    pre = list(map(int, input().split()))\n    in_ = list(map(int, input().split())) # pythonではinは予約語\n    post = []\n\n    pos = 0\n\n    def rec(l, r,):\n        global pos # posはglobal変数だと明示する\n        if l >= r:\n            return\n        root = pre[pos]\n        pos += 1\n        m = in_.index(root)\n        rec(l, m)\n        rec(m+1, r)\n        post.append(str(root))\n\n    rec(0, n)\n    print(' '.join(post))\n"
  },
  {
    "language": "Python",
    "code": "j, a = 0, []\ndef f(l, r):\n    if l < r:\n        global j, a\n        c = P[j]\n        j += 1\n        m = I.index(c)\n        f(l, m)\n        f(m + 1, r)\n        a += [c]\n\n\nN = int(input())\nP = input().split()\nI = input().split()\nf(0, N)\nprint(*a)\n"
  },
  {
    "language": "Python",
    "code": "def get_postorder(PRE, IN):\n  if not PRE: return []\n\n  result = []\n  root = PRE[0]\n  ri = IN.index(PRE[0])\n  result.extend(get_postorder(PRE[1:ri+1], IN[:ri]))\n  result.extend(get_postorder(PRE[ri+1:],  IN[ri+1:]))\n  result.append(root)\n  return result\n\n\nN = int(input())\nPRE = list(map(int, input().split()))\nIN  = list(map(int, input().split()))\nprint(*get_postorder(PRE, IN))"
  },
  {
    "language": "Python",
    "code": "def reconstruction(l, r):\n    global P, I, post\n    if l >= r:\n        return\n    c = P.pop(0)\n    m = I.index(c)\n    reconstruction(l, m)\n    reconstruction(m + 1, r)\n    post.append(c)\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    P = list(map(int, input().split()))\n    I = list(map(int, input().split()))\n    post = []\n\n    reconstruction(0, n)\n    print(*post)"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef reconst(pre, ino):\n    if len(pre) == 0:\n        return\n    elif len(pre) == 1:\n        print pre[0],\n        return\n\n    root = ino.index(pre[0])\n    preLeft, preRight = pre[1:root + 1], pre[root + 1:]\n    inLeft, inRight = ino[:root], ino[root + 1:]\n\n    reconst(preLeft, inLeft)\n    reconst(preRight, inRight)\n    print pre[0],\n\nif __name__ == \"__main__\":\n    lines = sys.stdin.readlines()\n    pre = map(int, lines[1].split())\n    ino = map(int, lines[2].split())\n    reconst(pre, ino)"
  },
  {
    "language": "Python",
    "code": "def search(l):\n    global i\n    if len(l) == 0:\n        return\n    v = p[i]\n    i += 1\n    for j in range(len(l)):\n            if l[j] == v:\n                id = j\n                break\n    if len(l) != 1:\n        search(l[:id])\n        search(l[id+1:])\n        ans.append(v)\n    else:\n        ans.append(v)\n\nn = int(input())\np = [int(_) for _ in input().split()]\nm = [int(_) for _ in input().split()]\ni = 0\nans = []\nsearch(m)\nprint(\" \".join(map(str, ans)))\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nPRE = list(map(int,input().split()))\nIN =  list(map(int,input().split()))\npost =[]\npos = 0\n\ndef rec(l,r):\n    global pos\n    if l >= r : return\n    root = PRE[pos]\n    pos += 1\n    m = IN.index(root)\n    rec(l,m)\n    rec(m+1,r)\n    post.append(root)\n\ndef solve():\n    rec(0,len(PRE))\n    for i in range(n):\n        if i == n-1:\n            print(post[i])\n        else:\n            print(post[i],\"\",end = \"\")\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "class Node():\n    def __init__(self, parent = -1, left = -1, right = -1):\n        self.parent = parent\n        self.left = left\n        self.right = right\n\ndef postorder(ns, i):\n    if ns[i].left != -1:\n        postorder(ns, ns[i].left)\n    if ns[i].right != -1:\n        postorder(ns, ns[i].right)\n    print(\" \" + str(i + 1), end =\"\")\n\ndef poio_node(ns, po, io):\n    p = po[0]\n    i = io.index(p)\n    if i != 0:\n        ns[p].left = po[1]\n        ns[po[1]].parent = p\n        poio_node(ns, po[1:i + 1], io[:i])\n    if i != len(io) -1:\n        ns[p].right = po[i + 1]\n        ns[po[1 + i]].parent = p\n        poio_node(ns, po[i + 1:], io[i + 1:])\n\ndef min1(n):\n    return n - 1\n    \nn = int(input())\npo = list(map(int, input().split()))\nio = list(map(int, input().split()))\npo = list(map(min1, po))\nio = list(map(min1, io))\nns = [Node() for i in range(n)]\n\npoio_node(ns, po, io)\n\npostorder(ns, po[0])\nprint()\n"
  },
  {
    "language": "Python",
    "code": "def reconsruction(pre, ino):\n    if 0 == len(pre):\n        return []\n    else:\n        root = pre[0]\n\n        partition = ino.index(root)\n        l_ino = ino[0:partition]\n        r_ino = ino[partition+1:]\n\n        pre_partition = len(l_ino)+1\n        l_pre = pre[1:pre_partition]\n        r_pre = pre[pre_partition:]\n\n        return reconsruction(l_pre, l_ino) + reconsruction(r_pre, r_ino) + [root]\n\nn = int(input())\n\npre = list(map(int, input().split()))\nino = list(map(int, input().split()))\n\nprint(*reconsruction(pre, ino))"
  },
  {
    "language": "Python",
    "code": "class BinaryNode():\n    def __init__(self, parent=-1, left=-1, right=-1, depth=-1, height=-1):\n        self.parent = parent\n        self.left = left\n        self.right = right\n        self.depth = depth\n        self.height = height\n\n\nclass BinaryTree(list):\n    def __init__(self, obj):\n        if isinstance(obj, int):\n            super().__init__([BinaryNode() for _ in range(obj)])\n            self.len = obj\n        elif isinstance(obj, list):\n            super().__init__(obj)\n            self.len = len(obj)\n        else:\n            raise TypeError(\"arg should be int or list of binarynodes\")\n        self.root = None\n\n    # def __getitem__(self, idxs):\n    #     if isinstance(idxs, tuple):\n    #         return BinaryTree(list(self)[idxs])\n    #     return super().__getitem__(idxs)\n\n    def set_node(self, id, left, right):\n        self[id].left = left\n        self[id].right = right\n        if left > -1:\n            self[left].parent = id\n        if right > -1:\n            self[right].parent = id\n\n    def __set_depth(self, id, depth):\n        self[id].depth = depth\n        if self[id].left > -1:\n            self.__set_depth(self[id].left, depth + 1)\n        if self[id].right > -1:\n            self.__set_depth(self[id].right, depth + 1)\n\n    def set_depth(self):\n        self.__set_depth(self.root, 0)\n\n    def __set_height(self, id):\n        if id == -1:\n            return -1\n        height = 1 + max(self.__set_height(self[id].left), self.__set_height(self[id].right))\n        self[id].height = height\n        return height\n\n    def set_height(self):\n        self.__set_height(self.root)\n\n    def set_root(self):\n        for i in range(self.len):\n            if self[i].parent == -1:\n                self.root = i\n                break\n\n    def get_nodetype(self, i):\n        if self[i].parent == -1:\n            return \"root\"\n        elif self[i].left == -1 and self[i].right == -1:\n            return \"leaf\"\n        else:\n            return \"internal node\"\n\n    def get_sibling(self, i):\n        parent = self[i].parent\n        if parent == -1:\n            return -1\n        if self[parent].left == i:\n            return self[parent].right\n        else:\n            return self[parent].left\n\n    def get_degree(self, i):\n        return (self[i].left > -1) * 1 + (self[i].right > -1) * 1\n\n    def set_all(self):\n        self.set_root()\n        self.set_depth()\n        self.set_height()\n\n    def print(self):\n        for i in range(self.len):\n            print(\"node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, {}\".format(\n                i, self[i].parent, self.get_sibling(i), self.get_degree(i),\n                self[i].depth, self[i].height, self.get_nodetype(i)))\n\n    def __preorder(self, id):\n        if id == -1:\n            return []\n        return [id] + self.__preorder(self[id].left) + self.__preorder(self[id].right)\n\n    def order_list(self, order_type):\n        if order_type == 0:\n            return self.__preorder(self.root)\n        elif order_type == 1:\n            return self.__inorder(self.root)\n        else:\n            return self.__postorder(self.root)\n\n    def order_str(self, order_type):\n        return \" \".join(map(str, self.order_list(order_type)))\n\n    def __inorder(self, id):\n        if id == -1:\n            return []\n        return self.__inorder(self[id].left) + [id] + self.__inorder(self[id].right)\n\n    def __postorder(self, id):\n        if id == -1:\n            return []\n        return self.__postorder(self[id].left) + self.__postorder(self[id].right) + [id]\n\n\ndef get_root(preorder, inorder, num, tree):\n    root = preorder[0]\n    if num == 1:\n        return root\n    root_idx = inorder.index(root)\n    left_inorder = inorder[:root_idx]\n    left_preorder = preorder[1:1 + root_idx]\n    left_num = root_idx\n    right_inorder = inorder[root_idx + 1:]\n    right_preorder = preorder[1 + root_idx:]\n    right_num = num - root_idx - 1\n    if left_num > 0:\n        left = get_root(left_preorder, left_inorder, left_num, tree)\n        if left > -1:\n            tree[root].left = left\n            tree[left].parent = root\n    if right_num > 0:\n        right = get_root(right_preorder, right_inorder, right_num, tree)\n        if right > -1:\n            tree[root].right = right\n            tree[right].parent = root\n    return root\n\n\ndef main():\n    n = int(input())\n    preorder = input().split(\" \")\n    preorder = list(map(lambda x: int(x) - 1, preorder))\n    inorder = input().split(\" \")\n    inorder = list(map(lambda x: int(x) - 1, inorder))\n    tree = BinaryTree(n)\n    tree.root = get_root(preorder, inorder, n, tree)\n    print(\" \".join(map(lambda x: str(x + 1), tree.order_list(2))))\n\n\nif __name__ == \"__main__\":\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef print_postorder(A, B, n):\n    C = []\n    def reconstruction(l, r):\n        if l >= r:\n            return\n        c = A.popleft()\n        m = B.index(c)\n        reconstruction(l, m)\n        reconstruction(m + 1, r)\n        C.append(c)\n\n    reconstruction(0, n)\n    print(*C, sep=\" \")\n\nn = int(input())\nA = deque([int(i) for i in input().split()])\nB = [int(i) for i in input().split()]\nprint_postorder(A, B, n)\n"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/env python3\n# # -*- coding: utf-8 -*-\n\n\nclass Node:\n    def __init__(self, val, left, right):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    def __iter__(self):\n        yield from self.postorder()\n\n    def postorder(self):\n        yield from self.left\n        yield from self.right\n        yield self\n\n\ndef reconstruct(preorder, inorder):\n    if len(preorder) == 0:\n        return []\n\n    root_val = preorder[0]\n    root_index = inorder.index(root_val)\n    inorder_left = inorder[:root_index]\n    inorder_right = inorder[root_index + 1 :]\n    preorder_left = [x for x in preorder if x in inorder_left]\n    preorder_right = [x for x in preorder if x in inorder_right]\n\n    return Node(\n        root_val,\n        reconstruct(preorder_left, inorder_left),\n        reconstruct(preorder_right, inorder_right),\n    )\n\n\ndef main():\n    n = int(input())\n    preorder = [int(x) for x in input().split()]\n    inorder = [int(x) for x in input().split()]\n\n    print(*[node.val for node in reconstruct(preorder, inorder).postorder()])\n\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10000000)\nMOD = 10 ** 9 + 7\nINF = 10 ** 15\n\nN = int(input())\nleft = list(map(int,input().split()))\nmiddle = list(map(int,input().split()))\n\nans = []\ndef dfs(p,end,L,R):\n    #print(\"p: {},end: {},L: {},R: {}\".format(p,end,L,R))\n    if end == p + 1:\n        ans.append(left[p])\n        return\n    for i in range(L,R):\n        if middle[i] == left[p]:\n            idx = i\n            break\n    if idx != L:\n        dfs(p + 1,p + idx - L + 1,L,idx)\n    if idx != R - 1:\n        dfs(p + idx - L + 1,end,idx + 1,R)\n    ans.append(left[p])\ndfs(0,N,0,N)\nprint(' '.join(map(str,ans)))\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\npreorder_list = list(map(int,input().split()))\ninorder_list = list(map(int,input().split()))\npostorder_list = []\ncnt = 0\ndef make_postorder_list(arg_postorder_list, arg_tmp_lst):\n    global cnt\n    tmp_cnt = cnt\n    root = arg_tmp_lst.index(preorder_list[cnt])\n    left_lst = arg_tmp_lst[:root]\n    right_lst = arg_tmp_lst[root+1:]\n    if cnt+1<=n-1:\n        if preorder_list[cnt+1] in left_lst:\n            cnt+=1\n            make_postorder_list(arg_postorder_list, left_lst)\n    if cnt+1<=n-1:\n        if preorder_list[cnt+1] in right_lst:\n            cnt+=1\n            make_postorder_list(arg_postorder_list, right_lst)\n    arg_postorder_list.append(preorder_list[tmp_cnt])\n    \n\nmake_postorder_list(postorder_list, inorder_list)\n\nprint(*postorder_list)\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n\n    def __init__(self, n):\n        self.id = n\n        self.left = None\n        self.right = None\n\nclass BTree:\n\n    def __init__(self, n):\n        self.n = n\n        self.nodes = [Node(i) for i in range(n + 1)]\n\n    def make_tree(self, preorder, inorder):\n        if preorder:\n            root = preorder[0]\n            i_root = inorder.index(root)\n            inorder_left = inorder[:i_root]\n            inorder_right = inorder[i_root + 1:]\n            leftn = len(inorder_left)\n            preorder_left = preorder[1:leftn + 1]\n            preorder_right = preorder[leftn + 1:]\n\n            self.nodes[root].left = self.make_tree(preorder_left, inorder_left)\n            self.nodes[root].right = self.make_tree(preorder_right, inorder_right)\n\n            return root\n\n        else:\n            return -1\n\n    def disp_postorder(self, root, result):\n        node = self.nodes[root]\n        if node.left != -1:\n            self.disp_postorder(node.left, result)\n        if node.right != -1:\n            self.disp_postorder(node.right, result)\n        result.append(root)\n        return result\n\nif __name__ == '__main__':\n\n    n = int(input())\n    btree = BTree(n)\n\n    preorder = [int(x) for x in input().split()]\n    inorder = [int(x) for x in input().split()]\n\n    btree.make_tree(preorder, inorder)\n\n    result = btree.disp_postorder(preorder[0], [])\n    print(\" \".join([str(x) for x in result]))\n"
  },
  {
    "language": "Python",
    "code": "class Node():\n    def __init__(self, parent=-1, left=-1, right=-1):\n        self.parent = parent\n        self.left = left\n        self.right = right\ndef postorder(ns,i, post):\n    if ns[i].left != -1:\n        postorder(ns,ns[i].left ,post)\n    if ns[i].right != -1:\n        postorder(ns,ns[i].right ,post)\n    post.append(str(i+1))\ndef poio_node(ns,po,io):\n    root = po[0]\n    i = io.index(root)\n    if i!=0: # root의 왼쪽노드가 존재한다면 왼쪽으로 재귀\n        ns[po[0]].left = po[1]\n        ns[po[1]].parent = po[0]\n        poio_node(ns,po[1:i+1],io[:i]) # po, io 안의 왼쪽 노드들로만 재귀\n    if i!=len(io)-1: # root의 오른쪽 노드가 존재한다면 오른쪽으로 재귀\n        ns[po[0]].right = po[i+1]\n        ns[po[i+1]].parent = po[0]\n        poio_node(ns, po[i+1:], io[i+1:]) # po, io 안의 오른쪽 노드들로만 재귀\ndef min1(n):\n    return (n-1)\nn = int(input())\npo = list(map(int,input().split()))\nio = list(map(int,input().split()))\npo = list(map(min1,po))   ##0~(n-1)로 변환\nio = list(map(min1,io))\nns =  [Node()for i in range(n)]\n\npoio_node(ns, po, io)\n\npost = []\npostorder(ns, po[0], post)\nprint(\" \".join(post))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.parent = None\n        self.left = None\n        self.right = None\n        self.depth = 0\n    \n    def get_depth(self):\n        if not self.parent:\n            return 0\n        else:\n            return self.parent.get_depth()+1\n    \n    def get_sibling(self):\n        if not self.parent:\n            return - 1\n        else:\n            if self.parent.right and self.parent.right.val == self.val:\n                if self.parent.left:\n                    return self.parent.left.val\n                else:\n                    return - 1\n            elif self.parent.left and self.parent.left.val == self.val:\n                if self.parent.right:\n                    return self.parent.right.val\n                else:\n                    return - 1\n    \n    def get_parent(self):\n        if not self.parent:\n            return -1\n        return self.parent.val\n    \n    def get_degree(self):\n        degree = 0\n        if self.left:\n            degree += 1\n        if self.right:\n            degree += 1\n        return degree\n    \n    def get_type(self):\n        if not self.parent:\n            return \"root\"\n        elif self.left or self.right:\n            return \"internal node\"\n        else:\n            return \"leaf\"\n    \n    def get_height(self):\n        if not self.left and not self.right:\n            return 0\n        l,r = 0,0\n        if self.left:\n            l = self.left.get_height()\n        if self.right:\n            r = self.right.get_height()\n        return max(l + 1, r + 1)\n\ndef main():\n    n = int(input().strip())\n    nodes = [Node(i) for i in range(n)]\n\n    ## get order\n    preorder = [int(i)-1 for i in input().strip().split()] ## convert to 0-based index\n    inorder = [int(i)-1 for i in input().strip().split()] ## convert to 0-based index\n\n    def make_tree(preorder, inorder):\n        if not preorder or not inorder:\n            return None\n\n        ## get root of tree\n        root = nodes[preorder[0]]\n        ## find divide point in inorder table\n        idx = inorder.index(root.val)\n\n        left_inorder = inorder[:idx]\n        left_preorder = preorder[1:len(left_inorder)+1]\n        right_inorder = inorder[idx + 1:]\n        right_preorder = preorder[len(left_inorder) + 1:]\n\n        ## create left and right tree\n        root.left = make_tree(left_preorder,left_inorder)\n        root.right = make_tree(right_preorder,right_inorder)\n\n        return root\n\n    make_tree(preorder, inorder)\n    \n    postorder = []\n\n    def postorder_walk(node):\n        if node.left:\n            postorder_walk(node.left)\n        if node.right:\n            postorder_walk(node.right)\n        postorder.append(str(node.val+1)) ## fix to 1-based index\n    root = nodes[preorder[0]]\n    postorder_walk(root)\n    print(\" \".join(postorder))\n\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "def get_postorder(preorder, inorder):\n    if not preorder:\n        return []\n\n    root = preorder[0]\n    root_index = inorder.index(root)\n    result = []\n\n    result.extend(get_postorder(preorder[1:root_index+1], inorder[:root_index]))\n    result.extend(get_postorder(preorder[root_index+1:], inorder[root_index+1:]))\n    result.append(root)\n\n    return result\n\n\nif __name__ == '__main__':\n    n = int(input())\n    preorder = list(map(int, input().split()))\n    inorder = list(map(int, input().split()))\n\n    print(*get_postorder(preorder, inorder))"
  },
  {
    "language": "Python",
    "code": "def reconstruction(l, r, p):\n    if l >= r:\n        return\n    c = next(pre)\n    m = ino.index(c)\n    reconstruction(l, m, p)\n    reconstruction(m + 1, r, p)\n    p += [c]\nn = int(input())\npre = iter(list(map(int, input().split())))\nino = list(map(int, input().split()))\npostorder = []\nreconstruction(0, n, postorder)\nprint(' '.join(map(str, postorder)))\n"
  },
  {
    "language": "Python",
    "code": "I = 0\nL = 1\nR = 2\nP = 3\nB = 4\nD = 5\nH = 6\n\ndef search(N, A, B, num):\n    root = A[0]\n    ld = num\n    for i in range(num):\n        if B[i] == root:\n            ld = i\n            break\n    if ld > 0:\n        N[root][L] = search(N,A[1:ld+1],B[:ld],ld)\n    rt = ld + 1\n    if rt < num:\n        N[root][R] = search(N,A[rt:],B[rt:],num - rt)\n    return root\n\ndef postorder(N,id,A):\n    if id < 0:\n        return\n    postorder(N,N[id][L],A)\n    postorder(N,N[id][R],A)\n    A.append(id)\n\n\ndef main():\n\n    \"\"\" ????????? \"\"\"\n    num = int(input().strip())\n    plist = list(map(int,input().split()))\n    ilist = list(map(int,input().split()))\n    pos = []\n    \n    nodes = [[i, -1, -1, -1, -1, 0, 0] for i in range(num)]\n\n    search(nodes,plist,ilist,num)\n    pos = []\n\n    print(\" \".join(map(str,pos)))\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n# Your code here!\n\nclass Node:\n    def __init__(self, id):\n        self.id = id\n        self.parent = -1\n        self.left = -1\n        self.right = -1\n        \nN = int(input())\nnodes = [Node(i+1) for i in range(N)]\n\npreorders = [int(i)-1 for i in input().split()]\ninorders = [int(i)-1 for i in input().split()]\n\n\ndef dfs(nodes, preo, ino):\n    if not preo:\n        return\n\n    root = preo[0]\n    i = ino.index(root)\n    \n    if i != 0:\n        nodes[root].left = preo[1]\n        nodes[preo[1]].parent = root\n        dfs(nodes, preo[1:i+1], ino[:i])\n    \n    if i != len(ino)-1:\n        nodes[root].right = preo[i+1]\n        nodes[preo[i+1]].parent = root\n        dfs(nodes, preo[i+1:], ino[i+1:])\n    \n\ndef postorder(nodes, root, result):\n    node = nodes[root]\n    if node.left != -1:\n        postorder(nodes, node.left, result)\n    if node.right != -1:\n        postorder(nodes, node.right, result)\n    result.append(root+1)\n\n\ndfs(nodes, preorders, inorders)\n\nresult = []\npostorder(nodes, preorders[0], result)\n\nprint(*result)\n"
  },
  {
    "language": "Python",
    "code": "def reconstruction(l, r):\n    global i\n    if l >= r:\n        return\n    c = PRE[i]\n    i += 1\n    m = IN.index(c)\n    reconstruction(l, m)\n    reconstruction(m + 1, r)\n    POST.append(c)\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    PRE = list(map(int, input().split()))\n    IN = list(map(int, input().split()))\n    POST = []\n    i = 0\n    reconstruction(0, n)\n    print(\" \".join(map(str, POST)))"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sat Mar  2 15:32:11 2019\n\n@author: Yamazaki Kenichi\n\"\"\"\n\nN = int(input())\npre = list(map(int,input().split()))\nino = list(map(int,input().split()))\n\ntree = [[-1,-1,-1] for i in range(N+1)]\ndef make_tree(pre,ino):\n    if len(pre)==0:\n        return\n    indx = ino.index(pre[0])\n    if indx > 0:\n        tree[pre[0]][1] = pre[1]\n        tree[pre[1]][0] = pre[0]\n        make_tree(pre[1:indx+1],ino[:indx])\n    if indx != len(ino)-1:\n        tree[pre[0]][2] = pre[indx+1]\n        tree[pre[indx+1]][0] = pre[0]\n        make_tree(pre[indx+1:],ino[indx+1:])\nmake_tree(pre,ino)\n\ndef pos(u,tree):\n    res = []\n    if tree[u][1] != -1:\n        res += pos(tree[u][1],tree)\n    if tree[u][2] != -1:\n        res += pos(tree[u][2],tree)\n    res += [str(u)]\n    return res\nans = pos(pre[0],tree)\nprint(' '.join(ans))\n\n"
  },
  {
    "language": "Python",
    "code": "class Node():\n    def __init__(self,parent=-1,left=-1,right=-1):\n        self.parent = parent\n        self.left = left\n        self.right = right\n    \ndef postorder(ns,i,post):\n    if ns[i].left != -1:\n        postorder(ns,ns[i].left,post)\n    if ns[i].right != -1:\n        postorder(ns,ns[i].right,post)\n    post.append(str(i+1))\n\ndef poio_node(ns,po,io):\n    p = po[0]\n    i = io.index(p)\n    if i != 0:\n        ns[p].left = po[1]\n        ns[po[1]].parent = p\n        poio_node(ns,po[1:i+1],io[:i])\n    if i != len(io)-1:\n        ns[p].right = po[i+1]\n        ns[po[i+1]].parent = p\n        poio_node(ns,po[i+1:],io[i+1:])\n\ndef min1(n):\n    return n-1\n\nn = int(input())\npo = list(map(int,input().split()))\nio = list(map(int,input().split()))\npo = list(map(min1,po))\nio = list(map(min1,io))\nns =[Node() for _ in range(n)]\n\npoio_node(ns,po,io)\npost=[]\npostorder(ns,po[0],post)\nprint(\" \".join(post))\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nfrom collections import deque\nimport sys\nsys.setrecursionlimit(100000)\n\n\nif __name__ == '__main__':\n\n    n = int(input())\n    pre = deque([int(i) for i in input().split(\" \")])\n    ino = deque([int(i) for i in input().split(\" \")])\n\n    post = []\n    def reconstruction(l, r):\n        if l >= r:\n            return\n        c = pre.popleft()\n        m = ino.index(c)\n        reconstruction(l, m)\n        reconstruction(m+1, r)\n        \n        post.append(c)\n\n    reconstruction(0, n)\n    print(\" \".join(map(str, post)))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef flatten(data):\n    for item in data:\n        if hasattr(item, '__iter__'):\n            for element in flatten(item):\n                yield element\n        else:\n            yield item\n\nn = int(sys.stdin.readline())\npreorder = list(map(int, sys.stdin.readline().split()))\ninorder = list(map(int, sys.stdin.readline().split()))\n\ndef eq(a, b):\n    if type(a)!=type(b):  return False   \n    if type(a)==list:     return set(flatten(a))== set(flatten(b)) \n    return a==b   \n\nwhile len(preorder)>1:\n    for i in range(len(preorder)-3,-2,-1):\n        seq = preorder[i:i+3]\n        for j in range(len(inorder)-3,-2,-1):\n            if type(preorder[i+1])==int:\n                if eq(preorder[i+1], inorder[j+1]) and eq(preorder[i+2], inorder[j+2]):\n                    \n                    preorder[i+1:i+3] = [[preorder[i+1], 0, preorder[i+2]]]\n                    inorder[j+1:j+3]  = [[0, inorder[j+1], inorder[j+2]]]\n                    break\n                if eq(preorder[i+1], inorder[j+2]) and eq(preorder[i+2], inorder[j+1]):\n                    \n                    preorder[i+1:i+3] = [[preorder[i+1], preorder[i+2], 0]]\n                    inorder[j+1:j+3]  = [[inorder[j+1], inorder[j+2], 0]]\n                    break\n            if i>=0 and j>=0 and type(preorder[i])==int and eq(preorder[i], inorder[j+1]) and eq(preorder[i+1], inorder[j]) and  eq(preorder[i+2], inorder[j+2]): \n                preorder[i:i+3]=[seq]\n                inorder[j:j+3]=[inorder[j:j+3]]\n                break\n        else:  continue\n        break\n\n\npostorder=[]\ndef create_postorder(a):\n    if type(a)==list:\n        for i in [1, 2, 0]: \n            if type(a[i])==list:  create_postorder(a[i])\n            elif a[i]>0:          postorder.append(a[i])\n    else:  postorder.append(a)\ncreate_postorder(preorder[0])\nprint(' '.join(map(str, postorder)))\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::Read;\nuse std::cmp::min;\n\nfn main() {\n    let mut buf = String::new();\n    std::io::stdin().read_to_string(&mut buf).unwrap();\n\n    let answer = solve(&buf);\n\n    println!(\"{}\", answer);\n}\n\nfn solve(input: &str) -> String {\n    let mut iterator = input.split_whitespace();\n\n    let n: usize = iterator.next().unwrap().parse().unwrap();\n\n    let mut tree: Vec<Node> = vec![Node { parent: -1, left: -1, right: -1 }; n];\n\n    let mut pre_order: Vec<usize> = Vec::with_capacity(n);\n    for _ in 0..n {\n        pre_order.push(iterator.next().unwrap().parse().unwrap());\n    }\n\n    let mut in_order: Vec<usize> = Vec::with_capacity(n);\n    for _ in 0..n {\n        in_order.push(iterator.next().unwrap().parse().unwrap());\n    }\n\n    construct_tree(&mut tree, &pre_order, &in_order);\n\n    let root_id = pre_order[0];\n\n    let mut ans = String::new();\n    post_order(&tree, root_id, &mut ans);\n\n    return ans.trim().to_string();\n}\n\nfn construct_tree(tree: &mut Vec<Node>, pre_order: &[usize], in_order: &[usize]) -> isize {\n    if in_order.is_empty() {\n        return -1;\n    }\n    if in_order.len() == 1 {\n        return in_order[0] as isize;\n    }\n\n    let mut min_index = std::usize::MAX;\n    for id in in_order {\n        let index = pre_order.iter().position(|i| i == id).unwrap();\n        min_index = min(min_index, index);\n    }\n\n    let current = pre_order[min_index];\n    let position = in_order.iter().position(|i| i == &current).unwrap();\n\n    let (left_tree, right_tree) = in_order.split_at(position);\n    let right_tree = &right_tree[1..];\n\n    let left_child = construct_tree(tree, pre_order, left_tree);\n    if left_child != -1 {\n        tree[current - 1].left = left_child;\n        tree[left_child as usize - 1].parent = current as isize;\n    }\n\n    let right_child = construct_tree(tree, pre_order, right_tree);\n    if right_child != -1 {\n        tree[current - 1].right = right_child;\n        tree[right_child as usize - 1].parent = current as isize;\n    }\n\n    current as isize\n}\n\nfn post_order(tree: &Vec<Node>, id: usize, result: &mut String) {\n    let node = &tree[id - 1];\n    if node.left != -1 {\n        post_order(tree, node.left as usize, result);\n    }\n    if node.right != -1 {\n        post_order(tree, node.right as usize, result);\n    }\n    result.push_str(&format!(\"{} \", id));\n}\n\n#[derive(Clone, Debug)]\nstruct Node {\n    parent: isize,\n    left: isize,\n    right: isize,\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\n\ntype NodeId = usize;\n\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\nfn reconstruction(\n    l: NodeId,\n    r: NodeId,\n    preorder: &Vec<NodeId>,\n    inorder: &Vec<NodeId>,\n    postorder: &mut Vec<NodeId>,\n    position: &mut isize,\n) {\n    if l >= r {\n        return;\n    }\n    *position += 1;\n    let root: NodeId = preorder[*position as usize];\n    let m: NodeId = inorder.iter().position(|&x| x == root).unwrap();\n    reconstruction(l, m, preorder, inorder, postorder, position);\n    reconstruction(m + 1, r, preorder, inorder, postorder, position);\n    postorder.push(root);\n}\n\nfn main() {\n    let n: usize = read();\n\n    let preorder: Vec<NodeId> = (0..n)\n        .map(|_| {\n            let number: NodeId = read();\n            return number - 1;\n        })\n        .collect();\n    let inorder: Vec<NodeId> = (0..n)\n        .map(|_| {\n            let number: NodeId = read();\n            return number - 1;\n        })\n        .collect();\n\n    let mut postorder: Vec<NodeId> = vec![];\n\n    let mut position: isize = -1;\n\n    reconstruction(0, n, &preorder, &inorder, &mut postorder, &mut position);\n\n    for (index, number) in postorder.iter().enumerate() {\n        if index != n - 1 {\n            print!(\"{} \", number + 1);\n        } else {\n            println!(\"{}\", number + 1);\n        }\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "// ALDS1_7_D: Reconstruction of the Tree\n\nuse std::str::FromStr;\n\nfn scan<T: FromStr>() -> T {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).unwrap();\n    s.trim().parse().ok().unwrap()\n}\n\nfn scan_vec<T: FromStr>() -> Vec<T> {\n    let s: String = scan();\n    s.split_whitespace().map(|a| T::from_str(a).ok().unwrap()).collect()\n}\n\nfn rec(\n    preorder: &Vec<usize>,\n    inorder: &Vec<usize>,\n    postorder: &mut Vec<usize>,\n    pos: &mut usize,\n    l: usize, \n    r: usize, \n) {\n    if l >= r {\n        return;\n    }\n    let c = preorder[*pos];\n    let m = inorder.iter().position(|&x| x == c).unwrap();\n    *pos += 1;\n    rec(preorder, inorder, postorder, pos,  l, m);\n    rec(preorder, inorder, postorder, pos,  m + 1, r);\n    postorder.push(c);\n}\n\nfn solve(\n    preorder: &Vec<usize>,\n    inorder: &Vec<usize>,\n) {\n    let mut pos: usize = 0;\n    let mut postorder: Vec<usize> = Vec::new();\n    rec(preorder, inorder, &mut postorder, &mut pos, 0, preorder.len());\n    let ans = postorder.iter().map(|a| a.to_string()).collect::<Vec<String>>().join(\" \");\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    let _: usize = scan();\n    let preorder: Vec<usize> = scan_vec();\n    let inorder: Vec<usize> = scan_vec();\n    solve(&preorder, &inorder);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::{max, min};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, Read, Write};\nuse std::str::FromStr;\n\n#[derive(Default)]\nstruct Scanner<R: Read> {\n    reader: R,\n}\n\nimpl<R: Read> Scanner<R> {\n    fn new(reader: R) -> Scanner<R> {\n        Scanner {\n            reader,\n        }\n    }\n\n    fn scan<T: FromStr>(&mut self) -> Option<T> {\n        let s = self.reader.by_ref().bytes().map(|c| c.unwrap() as char)\n            .skip_while(|c| c.is_whitespace())\n            .take_while(|c| !c.is_whitespace())\n            .collect::<String>();\n        s.parse::<T>().ok()\n    }\n\n    fn next<T: FromStr>(&mut self) -> T {\n        if let Some(s) = self.scan() {\n            s\n        } else {\n            std::process::exit(1);\n        }\n    }\n}\n\nfn dfs(pre_order: &[usize], in_order: &[usize]) -> Vec<usize> {\n    assert_eq!(pre_order.len(), in_order.len());\n    if pre_order.len() == 0 {\n        return Vec::new();\n    }\n    let r = pre_order[0];\n    let i = in_order.iter().position(|&x| x == r).unwrap();\n    let mut v = Vec::<usize>::new();\n    if i > 0 {\n        let mut ret = dfs(&pre_order[1..i+1], &in_order[0..i]);\n        v.append(&mut ret);\n    }\n    if i < pre_order.len() {\n        let mut ret = dfs(&pre_order[i+1..], &in_order[i+1..]);\n        v.append(&mut ret);\n    }\n    v.push(r);\n    v\n}\n\nfn main() {\n    let cin = stdin();\n    let cin = cin.lock();\n    let mut sc = Scanner::new(cin);\n    let out = stdout();\n    let mut out = out.lock();\n\n    let n = sc.next();\n    let pre_order = (0..n).map(|_| sc.next()).collect::<Vec<usize>>();\n    let in_order = (0..n).map(|_| sc.next()).collect::<Vec<usize>>();\n\n    let v = dfs(&pre_order[..], &in_order[..]);\n    writeln!(out, \"{}\", v.iter().map(ToString::to_string).collect::<Vec<String>>().join(\" \")).ok();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(dead_code)]\nuse std::io::{self,Read};\nuse std::str::FromStr;\n\npub struct Scanner<R: Read> {\n    reader: R,\n}\nimpl<R: Read> Scanner<R> {\n    pub fn new(reader: R) -> Scanner<R> {\n        Scanner { reader: reader }\n    }\n    pub fn read<T: FromStr>(&mut self) -> T {\n        let s = self\n            .reader\n            .by_ref()\n            .bytes()\n            .map(|c| c.expect(\"failed to read char\") as char)\n            .skip_while(|c| c.is_whitespace())\n            .take_while(|c| !c.is_whitespace())\n            .collect::<String>();\n        s.parse::<T>().ok().expect(\"failed to parse token\")\n    }\n}\n\n#[derive(Debug)]\nstruct Node {\n    left: Option<usize>,\n    right: Option<usize>,\n    parent: Option<usize>,\n}\n\nfn rec_find_root(pre_idx: &[usize], in_idx: &[usize], nodes: &mut Vec<Node>, parent: Option<usize>) -> Option<usize> {\n    // rootの探索\n    let l = pre_idx.len();\n    assert_eq!(l, in_idx.len());\n    if l == 0 {\n        return None;\n    } else if l == 1 {\n        let r = pre_idx[0];\n        nodes[r].parent = parent;\n        return Some(r);\n    } else {\n        // Preorder: root, left, right\n        // Inorder: left, root, right\n\n        // rootはpre[0]で確定\n        // in におけるrootより左、右で木を分割して再度探索\n        let r = pre_idx[0];\n        let r_idx = in_idx.iter().position(|x| *x == r).unwrap();\n\n        let nxt_in_left = &in_idx[0..r_idx];\n        let nxt_in_right = &in_idx[r_idx+1..l];\n        let nxt_pre_left = &pre_idx[1..r_idx+1];\n        let nxt_pre_right = &pre_idx[r_idx+1..l];\n\n        nodes[r].parent = parent;\n        nodes[r].left = rec_find_root(nxt_pre_left, nxt_in_left, nodes, Some(r));\n        nodes[r].right = rec_find_root(nxt_pre_right, nxt_in_right, nodes, Some(r));\n        return Some(r)\n    }\n}\n\n/// Preorder: root, left, right\nfn get_pre(nodes: &Vec<Node>, idx: usize, ids: &mut Vec<usize>){\n    ids.push(idx+1);   // 添え字対応のため番号は1減少させている\n    if let Some(l) = nodes[idx].left {\n        get_pre(nodes, l, ids);\n    }\n    if let Some(r) = nodes[idx].right {\n        get_pre(nodes, r, ids);\n    }\n}\n\n/// Inorder: left, root, right\nfn get_in(nodes: &Vec<Node>, idx: usize, ids: &mut Vec<usize>){\n    if let Some(l) = nodes[idx].left {\n        get_in(nodes, l, ids);\n    }\n    ids.push(idx+1);   // 添え字対応のため番号は1減少させている\n    if let Some(r) = nodes[idx].right {\n        get_in(nodes, r, ids);\n    }\n}\n\n/// Postorder: left, right, root\nfn get_post(nodes: &Vec<Node>, idx: usize, ids: &mut Vec<usize>){\n    if let Some(l) = nodes[idx].left {\n        get_post(nodes, l, ids);\n    }\n    if let Some(r) = nodes[idx].right {\n        get_post(nodes, r, ids);\n    }\n    ids.push(idx+1);   // 添え字対応のため番号は1減少させている\n}\n\nfn main() {\n    let sin = io::stdin();\n    let sin = sin.lock();\n    let mut sc = Scanner::new(sin);\n\n    let n: usize = sc.read();\n    \n    // id=1,..,Nなので-1して添え字と一致させておく\n\n    // Preorder: root, left, right\n    let pre_idx: Vec<usize> = (0..n).map(|_| sc.read::<usize>()-1).collect();\n\n    // Inorder: left, root, right\n    let in_idx: Vec<usize> = (0..n).map(|_| sc.read::<usize>()-1).collect();\n\n    // Tree\n    let mut nodes: Vec<Node> = (0..n).map(|_| Node {left: None, right: None, parent: None}).collect();\n\n    let root = rec_find_root(&pre_idx[..], &in_idx[..], &mut nodes, None).unwrap();\n\n    // let mut v: Vec<usize> = vec![];\n    // get_pre(&nodes, root, &mut v);\n    // println!(\"{}\", v.iter().map(|d| d.to_string()).collect::<Vec<String>>().join(\" \"));\n\n    // let mut v: Vec<usize> = vec![];\n    // get_in(&nodes, root, &mut v);\n    // println!(\"{}\", v.iter().map(|d| d.to_string()).collect::<Vec<String>>().join(\" \"));\n    \n    let mut v: Vec<usize> = vec![];\n    get_post(&nodes, root, &mut v);\n    println!(\"{}\", v.iter().map(|d| d.to_string()).collect::<Vec<String>>().join(\" \"));\n}\n\n"
  }
]