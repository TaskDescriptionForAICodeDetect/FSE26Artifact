[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 100005\n\nlong long tree[4*MAX_N];\nlong long lazy[4*MAX_N];\n\nvoid propagate(int node, int start, int end) {\n    if (lazy[node] != 0) {\n        tree[node] += (end - start + 1) * lazy[node];\n        \n        if (start != end) {\n            lazy[node*2] += lazy[node];\n            lazy[node*2+1] += lazy[node];\n        }\n        \n        lazy[node] = 0;\n    }\n}\n\nvoid update(int node, int start, int end, int l, int r, long long val) {\n    propagate(node, start, end);\n    \n    if (start > end || start > r || end < l)\n        return;\n    \n    if (l <= start && end <= r) {\n        lazy[node] += val;\n        propagate(node, start, end);\n        return;\n    }\n    \n    int mid = (start + end) / 2;\n    update(node*2, start, mid, l, r, val);\n    update(node*2+1, mid+1, end, l, r, val);\n    \n    tree[node] = tree[node*2] + tree[node*2+1];\n}\n\nlong long query(int node, int start, int end, int l, int r) {\n    if (start > end || start > r || end < l)\n        return 0;\n    \n    propagate(node, start, end);\n    \n    if (l <= start && end <= r)\n        return tree[node];\n    \n    int mid = (start + end) / 2;\n    long long left = query(node*2, start, mid, l, r);\n    long long right = query(node*2+1, mid+1, end, l, r);\n    \n    return left + right;\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    \n    for (int i = 0; i < q; i++) {\n        int op, s, t, x;\n        scanf(\"%d\", &op);\n        \n        if (op == 1) {\n            scanf(\"%d %d %d\", &s, &t, &x);\n            update(1, 1, n, s, t, x);\n        } else {\n            scanf(\"%d %d\", &s, &t);\n            printf(\"%lld\\n\", query(1, 1, n, s, t));\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:19:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef long long ll;\n\ntypedef struct {\n    ll *tree;\n    ll *lazy;\n    int size;\n} SegmentTree;\n\nSegmentTree* createSegmentTree(int n) {\n    SegmentTree* st = (SegmentTree*)malloc(sizeof(SegmentTree));\n    st->size = 1;\n    while (st->size < n) st->size <<= 1;\n    st->tree = (ll*)calloc(2 * st->size, sizeof(ll));\n    st->lazy = (ll*)calloc(2 * st->size, sizeof(ll));\n    return st;\n}\n\nvoid updateLazy(SegmentTree* st, int node, int nodeLeft, int nodeRight) {\n    if (st->lazy[node] != 0) {\n        st->tree[node] += st->lazy[node] * (nodeRight - nodeLeft + 1);\n        if (nodeLeft != nodeRight) {\n            st->lazy[node * 2] += st->lazy[node];\n            st->lazy[node * 2 + 1] += st->lazy[node];\n        }\n        st->lazy[node] = 0;\n    }\n}\n\nvoid rangeAdd(SegmentTree* st, int left, int right, ll value, int node, int nodeLeft, int nodeRight) {\n    updateLazy(st, node, nodeLeft, nodeRight);\n    if (right < nodeLeft || nodeRight < left) return;\n    if (left <= nodeLeft && nodeRight <= right) {\n        st->tree[node] += value * (nodeRight - nodeLeft + 1);\n        if (nodeLeft != nodeRight) {\n            st->lazy[node * 2] += value;\n            st->lazy[node * 2 + 1] += value;\n        }\n        return;\n    }\n    int mid = (nodeLeft + nodeRight) / 2;\n    rangeAdd(st, left, right, value, node * 2, nodeLeft, mid);\n    rangeAdd(st, left, right, value, node * 2 + 1, mid + 1, nodeRight);\n    st->tree[node] = st->tree[node * 2] + st->tree[node * 2 + 1];\n}\n\nll rangeSum(SegmentTree* st, int left, int right, int node, int nodeLeft, int nodeRight) {\n    updateLazy(st, node, nodeLeft, nodeRight);\n    if (right < nodeLeft || nodeRight < left) return 0;\n    if (left <= nodeLeft && nodeRight <= right) return st->tree[node];\n    int mid = (nodeLeft + nodeRight) / 2;\n    return rangeSum(st, left, right, node * 2, nodeLeft, mid) + \n           rangeSum(st, left, right, node * 2 + 1, mid + 1, nodeRight);\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    SegmentTree* st = createSegmentTree(n);\n    \n    while (q--) {\n        int type, s, t;\n        scanf(\"%d %d %d\", &type, &s, &t);\n        if (type == 0) {\n            ll x;\n            scanf(\"%lld\", &x);\n            rangeAdd(st, s, t, x, 1, 1, st->size);\n        } else {\n            ll sum = rangeSum(st, s, t, 1, 1, st->size);\n            printf(\"%lld\\n\", sum);\n        }\n    }\n    \n    free(st->tree);\n    free(st->lazy);\n    free(st);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:19:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass FenwickTree {\nprivate:\n    vector<long long> tree1, tree2;\n    int n;\n\n    void update(vector<long long>& tree, int idx, long long val) {\n        while (idx <= n) {\n            tree[idx] += val;\n            idx += idx & -idx;\n        }\n    }\n\n    long long query(const vector<long long>& tree, int idx) {\n        long long res = 0;\n        while (idx > 0) {\n            res += tree[idx];\n            idx -= idx & -idx;\n        }\n        return res;\n    }\n\npublic:\n    FenwickTree(int size) : n(size), tree1(size + 2), tree2(size + 2) {}\n\n    void rangeAdd(int l, int r, long long val) {\n        update(tree1, l, val);\n        update(tree1, r + 1, -val);\n        update(tree2, l, val * (l - 1));\n        update(tree2, r + 1, -val * r);\n    }\n\n    long long rangeSum(int l, int r) {\n        return query(tree1, r) * r - query(tree2, r) - (query(tree1, l - 1) * (l - 1) - query(tree2, l - 1));\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, q;\n    cin >> n >> q;\n\n    FenwickTree ft(n);\n\n    while (q--) {\n        int type, s, t;\n        cin >> type >> s >> t;\n        if (type == 0) {\n            long long x;\n            cin >> x;\n            ft.rangeAdd(s, t, x);\n        } else {\n            cout << ft.rangeSum(s, t) << '\\n';\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:20:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main {\n    static class SegmentTree {\n        long[] sum;\n        long[] lazy;\n        int n;\n\n        SegmentTree(int size) {\n            n = size;\n            sum = new long[4 * n];\n            lazy = new long[4 * n];\n        }\n\n        void push(int node, int left, int right) {\n            if (lazy[node] != 0) {\n                sum[node] += lazy[node] * (right - left + 1);\n                if (left != right) {\n                    lazy[2 * node] += lazy[node];\n                    lazy[2 * node + 1] += lazy[node];\n                }\n                lazy[node] = 0;\n            }\n        }\n\n        void updateRange(int node, int left, int right, int l, int r, long val) {\n            push(node, left, right);\n            if (left > r || right < l) return;\n            if (l <= left && right <= r) {\n                lazy[node] += val;\n                push(node, left, right);\n                return;\n            }\n            int mid = (left + right) / 2;\n            updateRange(2 * node, left, mid, l, r, val);\n            updateRange(2 * node + 1, mid + 1, right, l, r, val);\n            sum[node] = sum[2 * node] + sum[2 * node + 1];\n        }\n\n        long queryRange(int node, int left, int right, int l, int r) {\n            push(node, left, right);\n            if (left > r || right < l) return 0;\n            if (l <= left && right <= r) return sum[node];\n            int mid = (left + right) / 2;\n            return queryRange(2 * node, left, mid, l, r) + queryRange(2 * node + 1, mid + 1, right, l, r);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        String[] parts = br.readLine().split(\" \");\n        int n = Integer.parseInt(parts[0]);\n        int q = Integer.parseInt(parts[1]);\n\n        SegmentTree st = new SegmentTree(n);\n\n        for (int i = 0; i < q; i++) {\n            parts = br.readLine().split(\" \");\n            int type = Integer.parseInt(parts[0]);\n            int s = Integer.parseInt(parts[1]);\n            int t = Integer.parseInt(parts[2]);\n\n            if (type == 0) {\n                long x = Long.parseLong(parts[3]);\n                st.updateRange(1, 1, n, s, t, x);\n            } else {\n                long sum = st.queryRange(1, 1, n, s, t);\n                bw.write(sum + \"\\n\");\n            }\n        }\n        bw.flush();\n    }\n}",
    "timestamp": "2025-08-05 22:20:33"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class SequenceManipulation {\n    static class FenwickTree {\n        long[] tree;\n        int n;\n\n        FenwickTree(int size) {\n            n = size;\n            tree = new long[size + 1];\n        }\n\n        void update(int idx, long val) {\n            while (idx <= n) {\n                tree[idx] += val;\n                idx += idx & (-idx);\n            }\n        }\n\n        long query(int idx) {\n            long sum = 0;\n            while (idx > 0) {\n                sum += tree[idx];\n                idx -= idx & (-idx);\n            }\n            return sum;\n        }\n\n        void rangeUpdate(int l, int r, long val) {\n            update(l, val);\n            update(r + 1, -val);\n        }\n\n        long rangeQuery(int l, int r) {\n            return query(r) - query(l - 1);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n\n        int n = Integer.parseInt(st.nextToken());\n        int q = Integer.parseInt(st.nextToken());\n\n        FenwickTree ft = new FenwickTree(n);\n\n        for (int i = 0; i < q; i++) {\n            st = new StringTokenizer(br.readLine());\n            int type = Integer.parseInt(st.nextToken());\n            \n            if (type == 1) {\n                int s = Integer.parseInt(st.nextToken());\n                int t = Integer.parseInt(st.nextToken());\n                long x = Long.parseLong(st.nextToken());\n                ft.rangeUpdate(s, t, x);\n            } else {\n                int s = Integer.parseInt(st.nextToken());\n                int t = Integer.parseInt(st.nextToken());\n                bw.write(ft.rangeQuery(s, t) + \"\\n\");\n            }\n        }\n\n        bw.flush();\n        bw.close();\n        br.close();\n    }\n}",
    "timestamp": "2025-08-05 22:20:40"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nclass SegmentTree {\nprivate:\n    std::vector<long long> tree;\n    std::vector<long long> lazy;\n    int n;\n\n    void propagate(int node, int start, int end) {\n        if (lazy[node] != 0) {\n            tree[node] += (end - start + 1) * lazy[node];\n            \n            if (start != end) {\n                lazy[node * 2] += lazy[node];\n                lazy[node * 2 + 1] += lazy[node];\n            }\n            \n            lazy[node] = 0;\n        }\n    }\n\n    void update(int node, int start, int end, int left, int right, long long val) {\n        propagate(node, start, end);\n        \n        if (start > end || start > right || end < left) \n            return;\n        \n        if (left <= start && end <= right) {\n            lazy[node] += val;\n            propagate(node, start, end);\n            return;\n        }\n        \n        int mid = (start + end) / 2;\n        update(node * 2, start, mid, left, right, val);\n        update(node * 2 + 1, mid + 1, end, left, right, val);\n        \n        tree[node] = tree[node * 2] + tree[node * 2 + 1];\n    }\n\n    long long query(int node, int start, int end, int left, int right) {\n        propagate(node, start, end);\n        \n        if (start > end || start > right || end < left)\n            return 0;\n        \n        if (left <= start && end <= right)\n            return tree[node];\n        \n        int mid = (start + end) / 2;\n        long long left_sum = query(node * 2, start, mid, left, right);\n        long long right_sum = query(node * 2 + 1, mid + 1, end, left, right);\n        \n        return left_sum + right_sum;\n    }\n\npublic:\n    SegmentTree(int size) {\n        n = size;\n        tree.resize(4 * n, 0);\n        lazy.resize(4 * n, 0);\n    }\n\n    void addRange(int left, int right, long long val) {\n        update(1, 1, n, left, right, val);\n    }\n\n    long long getSum(int left, int right) {\n        return query(1, 1, n, left, right);\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    int N, Q;\n    std::cin >> N >> Q;\n\n    SegmentTree segTree(N);\n\n    while (Q--) {\n        int type, s, t;\n        std::cin >> type >> s >> t;\n\n        if (type == 1) {\n            long long x;\n            std::cin >> x;\n            segTree.addRange(s, t, x);\n        } else {\n            std::cout << segTree.getSum(s, t) << \"\\n\";\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:20:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class SegmentTree:\n    def __init__(self, size):\n        self.n = size\n        self.tree = [0] * (4 * size)\n        self.lazy = [0] * (4 * size)\n\n    def _apply(self, v, tl, tr, addend):\n        self.tree[v] += (tr - tl + 1) * addend\n        if tl != tr:\n            self.lazy[v * 2] += addend\n            self.lazy[v * 2 + 1] += addend\n\n    def _push(self, v, tl, tr):\n        if self.lazy[v] != 0:\n            mid = (tl + tr) // 2\n            self._apply(v * 2, tl, mid, self.lazy[v])\n            self._apply(v * 2 + 1, mid + 1, tr, self.lazy[v])\n            self.lazy[v] = 0\n\n    def _update(self, v, tl, tr, l, r, addend):\n        if l > r:\n            return\n        if l == tl and r == tr:\n            self._apply(v, tl, tr, addend)\n        else:\n            self._push(v, tl, tr)\n            mid = (tl + tr) // 2\n            self._update(v*2, tl, mid, l, min(r, mid), addend)\n            self._update(v*2+1, mid+1, tr, max(l, mid+1), r, addend)\n            self.tree[v] = self.tree[v*2] + self.tree[v*2+1]\n\n    def _query_sum(self, v, tl, tr, l, r):\n        if l > r:\n            return 0\n        if l <= tl and tr <= r:\n            return self.tree[v]\n        self._push(v, tl, tr)\n        mid = (tl + tr) // 2\n        return (self._query_sum(v*2, tl, mid, l, min(r, mid)) +\n                self._query_sum(v*2+1, mid+1, tr, max(l, mid+1), r))\n\n    def add(self, l, r, addend):\n        self._update(1, 0, self.n - 1, l, r, addend)\n\n    def get_sum(self, l, r):\n        return self._query_sum(1, 0, self.n - 1, l, r)\n\n\ndef process_queries(n, queries):\n    seg_tree = SegmentTree(n)\n    results = []\n    for query in queries:\n        if query[0] == 'add':\n            s, t, x = query[1], query[2], query[3]\n            seg_tree.add(s - 1, t - 1, x)\n        elif query[0] == 'getSum':\n            s, t = query[1], query[2]\n            result = seg_tree.get_sum(s - 1, t - 1)\n            results.append(result)\n    return results\n\n# Example usage:\nn = 5\nqueries = [\n    ('add', 1, 3, 5),\n    ('getSum', 1, 3),\n    ('add', 2, 5, 10),\n    ('getSum', 1, 5)\n]\n\nresults = process_queries(n, queries)\nfor result in results:\n    print(result)",
    "timestamp": "2025-08-13 10:01:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class SequenceManipulation {\n\n    static class FenwickTree {\n        private long[] tree;\n        private int n;\n\n        public FenwickTree(int n) {\n            this.n = n;\n            this.tree = new long[n + 1];\n        }\n\n        private void add(int index, long value) {\n            for (; index <= n; index += index & -index) {\n                tree[index] += value;\n            }\n        }\n\n        public void rangeAdd(int left, int right, long value) {\n            add(left, value);\n            add(right + 1, -value);\n        }\n\n        private long prefixSum(int index) {\n            long sum = 0;\n            for (; index > 0; index -= index & -index) {\n                sum += tree[index];\n            }\n            return sum;\n        }\n\n        public long get(int index) {\n            return prefixSum(index);\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int queries = scanner.nextInt();\n        FenwickTree fenwickTree = new FenwickTree(n);\n\n        for (int i = 0; i < queries; i++) {\n            String operation = scanner.next();\n            if (\"add\".equals(operation)) {\n                int s = scanner.nextInt();\n                int t = scanner.nextInt();\n                int x = scanner.nextInt();\n                fenwickTree.rangeAdd(s, t, x);\n            } else if (\"getSum\".equals(operation)) {\n                int s = scanner.nextInt();\n                int t = scanner.nextInt();\n                long sum = 0;\n                for (int j = s; j <= t; j++) {\n                    sum += fenwickTree.get(j);\n                }\n                System.out.println(sum);\n            }\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 10:01:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 100000\n\nlong long array[MAX_N + 1];\nlong long lazy[MAX_N + 1];\n\nvoid add(int s, int t, int x, int n) {\n    for (int i = 0; i < MAX_N; i++) {\n        if (i >= s && i <= t) {\n            lazy[i] += x;\n        }\n    }\n}\n\nlong long getSum(int s, int t) {\n    long long sum = 0;\n    for (int i = s; i <= t; i++) {\n        sum += array[i] + lazy[i];\n    }\n    return sum;\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    \n    // Initialize the arrays\n    for (int i = 0; i <= n; i++) {\n        array[i] = 0;\n        lazy[i] = 0;\n    }\n    \n    char operation[10];\n    int s, t, x;\n    \n    for (int i = 0; i < q; i++) {\n        scanf(\"%s\", operation);\n        if (operation[0] == 'a') {\n            // add operation\n            scanf(\"%d %d %d\", &s, &t, &x);\n            add(s, t, x, n);\n        } else if (operation[0] == 'g') {\n            // getSum operation\n            scanf(\"%d %d\", &s, &t);\n            printf(\"%lld\\n\", getSum(s, t));\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 10:02:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class SegmentTree:\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (4 * n)\n        self.lazy = [0] * (4 * n)\n\n    def propagate(self, node, start, end):\n        if self.lazy[node] != 0:\n            self.tree[node] += (end - start + 1) * self.lazy[node]\n            if start != end:\n                self.lazy[node * 2] += self.lazy[node]\n                self.lazy[node * 2 + 1] += self.lazy[node]\n            self.lazy[node] = 0\n\n    def update(self, node, start, end, l, r, val):\n        self.propagate(node, start, end)\n        \n        if start > end or start > r or end < l:\n            return\n        \n        if l <= start and end <= r:\n            self.lazy[node] += val\n            self.propagate(node, start, end)\n            return\n        \n        mid = (start + end) // 2\n        self.update(node * 2, start, mid, l, r, val)\n        self.update(node * 2 + 1, mid + 1, end, l, r, val)\n        \n        self.tree[node] = self.tree[node * 2] + self.tree[node * 2 + 1]\n\n    def query(self, node, start, end, l, r):\n        if start > end or start > r or end < l:\n            return 0\n        \n        self.propagate(node, start, end)\n        \n        if l <= start and end <= r:\n            return self.tree[node]\n        \n        mid = (start + end) // 2\n        left_sum = self.query(node * 2, start, mid, l, r)\n        right_sum = self.query(node * 2 + 1, mid + 1, end, l, r)\n        \n        return left_sum + right_sum\n\ndef solve(n, queries):\n    st = SegmentTree(n)\n    results = []\n\n    for query in queries:\n        if query[0] == 'add':\n            st.update(1, 1, n, query[1], query[2], query[3])\n        else:  # getSum\n            results.append(st.query(1, 1, n, query[1], query[2]))\n\n    return results\n\n# Example usage\nn = 10\nqueries = [\n    ['add', 1, 5, 3],\n    ['getSum', 1, 5],\n    ['add', 3, 7, 2],\n    ['getSum', 3, 7]\n]\n\nprint(solve(n, queries))",
    "timestamp": "2025-08-13 10:02:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\nclass SegmentTree:\n    def __init__(self, size):\n        self.n = 1\n        while self.n < size:\n            self.n <<= 1\n        self.size = size\n        self.data = [0] * (2 * self.n - 1)\n        self.lazy = [0] * (2 * self.n - 1)\n    \n    def push(self, k, l, r):\n        if self.lazy[k] != 0:\n            self.data[k] += self.lazy[k] * (r - l)\n            if r - l > 1:\n                self.lazy[2*k+1] += self.lazy[k]\n                self.lazy[2*k+2] += self.lazy[k]\n            self.lazy[k] = 0\n    \n    def add(self, a, b, x, k=0, l=0, r=None):\n        if r is None:\n            r = self.n\n        self.push(k, l, r)\n        if b <= l or r <= a:\n            return\n        if a <= l and r <= b:\n            self.lazy[k] += x\n            self.push(k, l, r)\n            return\n        self.add(a, b, x, 2*k+1, l, (l+r)//2)\n        self.add(a, b, x, 2*k+2, (l+r)//2, r)\n        self.data[k] = self.data[2*k+1] + self.data[2*k+2]\n    \n    def getSum(self, a, b, k=0, l=0, r=None):\n        if r is None:\n            r = self.n\n        self.push(k, l, r)\n        if b <= l or r <= a:\n            return 0\n        if a <= l and r <= b:\n            return self.data[k]\n        vl = self.getSum(a, b, 2*k+1, l, (l+r)//2)\n        vr = self.getSum(a, b, 2*k+2, (l+r)//2, r)\n        return vl + vr\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    q = int(input[ptr])\n    ptr += 1\n    \n    st = SegmentTree(n)\n    \n    for _ in range(q):\n        query = input[ptr]\n        ptr += 1\n        if query == 'add':\n            s = int(input[ptr]) - 1\n            ptr += 1\n            t = int(input[ptr]) - 1\n            ptr += 1\n            x = int(input[ptr])\n            ptr += 1\n            st.add(s, t+1, x)\n        elif query == 'getSum':\n            s = int(input[ptr]) - 1\n            ptr += 1\n            t = int(input[ptr]) - 1\n            ptr += 1\n            res = st.getSum(s, t+1)\n            print(res)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 10:02:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass SequenceManipulator {\nprivate:\n    vector<long long> sequence;\n    vector<long long> fenwickTree;\n    int n;\n    \n    void updateFenwickTree(int index, long long value) {\n        for (; index <= n; index += index & (-index)) {\n            fenwickTree[index] += value;\n        }\n    }\n    \n    long long getPrefixSumFenwickTree(int index) {\n        long long sum = 0;\n        for (; index > 0; index -= index & (-index)) {\n            sum += fenwickTree[index];\n        }\n        return sum;\n    }\n\npublic:\n    SequenceManipulator(int size) : n(size), sequence(size + 1, 0), fenwickTree(size + 1, 0) {}\n\n    void add(int s, int t, int x) {\n        updateFenwickTree(s, x);\n        updateFenwickTree(t + 1, -x);\n    }\n\n    long long getSum(int s, int t) {\n        return getPrefixSumFenwickTree(t) - getPrefixSumFenwickTree(s - 1);\n    }\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    SequenceManipulator sm(n);\n    \n    for(int i = 0; i < q; ++i) {\n        string command;\n        cin >> command;\n        if (command == \"add\") {\n            int s, t, x;\n            cin >> s >> t >> x;\n            sm.add(s, t, x);\n        } else if (command == \"getSum\") {\n            int s, t;\n            cin >> s >> t;\n            cout << sm.getSum(s, t) << endl;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:56:44"
  }
]