[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 100000\n#define MAX_M 200000\n#define MAX_K 200000\n\ntypedef struct {\n    int to;\n    int cost;\n} Edge;\n\ntypedef struct {\n    int city;\n    long long cost;\n} Node;\n\nEdge edges[MAX_M * 2];\nint nextEdge[MAX_M * 2];\nint head[MAX_N + 1];\nint edgeCount = 0;\n\nvoid addEdge(int from, int to, int cost) {\n    edges[edgeCount] = (Edge){to, cost};\n    nextEdge[edgeCount] = head[from];\n    head[from] = edgeCount++;\n}\n\nlong long dist[MAX_N + 1];\nint heapSize;\nNode heap[MAX_N * 2];\n\nvoid heapPush(Node node) {\n    int i = heapSize++;\n    while (i > 0) {\n        int p = (i - 1) / 2;\n        if (heap[p].cost <= node.cost) break;\n        heap[i] = heap[p];\n        i = p;\n    }\n    heap[i] = node;\n}\n\nNode heapPop() {\n    Node ret = heap[0];\n    Node x = heap[--heapSize];\n    int i = 0;\n    while (i * 2 + 1 < heapSize) {\n        int a = i * 2 + 1, b = i * 2 + 2;\n        if (b < heapSize && heap[b].cost < heap[a].cost) a = b;\n        if (heap[a].cost >= x.cost) break;\n        heap[i] = heap[a];\n        i = a;\n    }\n    heap[i] = x;\n    return ret;\n}\n\nvoid dijkstra(int start, int N) {\n    for (int i = 1; i <= N; i++) dist[i] = LLONG_MAX;\n    dist[start] = 0;\n    heapSize = 0;\n    heapPush((Node){start, 0});\n\n    while (heapSize > 0) {\n        Node node = heapPop();\n        int u = node.city;\n        if (dist[u] < node.cost) continue;\n        for (int i = head[u]; i != -1; i = nextEdge[i]) {\n            Edge e = edges[i];\n            if (dist[e.to] > dist[u] + e.cost) {\n                dist[e.to] = dist[u] + e.cost;\n                heapPush((Node){e.to, dist[e.to]});\n            }\n        }\n    }\n}\n\nint main() {\n    int N, M, K, S;\n    scanf(\"%d %d %d %d\", &N, &M, &K, &S);\n    for (int i = 1; i <= N; i++) head[i] = -1;\n    edgeCount = 0;\n\n    for (int i = 0; i < M; i++) {\n        int A, B, L;\n        scanf(\"%d %d %d\", &A, &B, &L);\n        addEdge(A, B, L);\n        addEdge(B, A, L);\n    }\n\n    dijkstra(S, N);\n\n    int count = 0;\n    for (int i = 0; i < K; i++) {\n        int X, T;\n        scanf(\"%d %d\", &X, &T);\n        if (dist[X] <= T) continue;\n        count++;\n    }\n\n    printf(\"%d\\n\", count);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:52:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RailwayCompanySatisfaction {\n    static final int MAX_CITIES = 100001;\n    static List<List<Integer>> graph;\n    static int[] fares;\n    static boolean[] visited;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int N = scanner.nextInt(); // Number of cities\n        int M = scanner.nextInt(); // Number of railway routes\n        int K = scanner.nextInt(); // Number of cities with fare increase plans\n        int Q = scanner.nextInt(); // Number of queries\n\n        graph = new ArrayList<>(N + 1);\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        fares = new int[N + 1];\n        for (int i = 1; i <= N; i++) {\n            fares[i] = scanner.nextInt();\n        }\n\n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n\n        int[] farePlans = new int[K];\n        for (int i = 0; i < K; i++) {\n            farePlans[i] = scanner.nextInt();\n        }\n\n        int dissatisfiedCities = 0;\n        for (int i = 1; i <= N; i++) {\n            if (isCityDissatisfied(i, farePlans)) {\n                dissatisfiedCities++;\n            }\n        }\n\n        System.out.println(dissatisfiedCities);\n        scanner.close();\n    }\n\n    static boolean isCityDissatisfied(int city, int[] farePlans) {\n        visited = new boolean[MAX_CITIES];\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(city);\n        visited[city] = true;\n\n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n\n            for (int neighbor : graph.get(current)) {\n                if (!visited[neighbor]) {\n                    boolean isNeighborIncrease = false;\n                    for (int plan : farePlans) {\n                        if (plan == neighbor) {\n                            isNeighborIncrease = true;\n                            break;\n                        }\n                    }\n\n                    if (!isNeighborIncrease) {\n                        queue.offer(neighbor);\n                        visited[neighbor] = true;\n                    }\n                }\n            }\n        }\n\n        for (int plan : farePlans) {\n            if (visited[plan]) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}",
    "timestamp": "2025-08-05 18:52:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nstruct Edge {\n    int to, cost;\n    Edge(int t, int c) : to(t), cost(c) {}\n};\n\nstruct City {\n    int id, cost;\n    City(int i, int c) : id(i), cost(c) {}\n    bool operator>(const City& other) const {\n        return cost > other.cost;\n    }\n};\n\nint main() {\n    int N, M, K, S;\n    cin >> N >> M >> K >> S;\n    int P, Q;\n    cin >> P >> Q;\n    \n    vector<int> C(K);\n    for (int i = 0; i < K; ++i) {\n        cin >> C[i];\n        C[i]--;\n    }\n    \n    vector<vector<Edge>> adj(N);\n    for (int i = 0; i < M; ++i) {\n        int A, B;\n        cin >> A >> B;\n        A--; B--;\n        adj[A].emplace_back(B, 0);\n        adj[B].emplace_back(A, 0);\n    }\n    \n    vector<int> danger(N, INT_MAX);\n    queue<int> q;\n    for (int c : C) {\n        danger[c] = 0;\n        q.push(c);\n    }\n    \n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (Edge& e : adj[u]) {\n            if (danger[e.to] > danger[u] + 1) {\n                danger[e.to] = danger[u] + 1;\n                q.push(e.to);\n            }\n        }\n    }\n    \n    for (int i = 0; i < N; ++i) {\n        for (Edge& e : adj[i]) {\n            int v = e.to;\n            if (v == N - 1) {\n                e.cost = 0;\n            } else if (danger[v] == 0) {\n                e.cost = INT_MAX;\n            } else if (danger[v] <= S) {\n                e.cost = Q;\n            } else {\n                e.cost = P;\n            }\n        }\n    }\n    \n    vector<int> dist(N, INT_MAX);\n    dist[0] = 0;\n    priority_queue<City, vector<City>, greater<City>> pq;\n    pq.emplace(0, 0);\n    \n    while (!pq.empty()) {\n        City current = pq.top();\n        pq.pop();\n        if (current.id == N - 1) break;\n        if (current.cost > dist[current.id]) continue;\n        \n        for (Edge& e : adj[current.id]) {\n            if (e.cost == INT_MAX) continue;\n            int new_cost = dist[current.id] + e.cost;\n            if (new_cost < dist[e.to]) {\n                dist[e.to] = new_cost;\n                pq.emplace(e.to, new_cost);\n            }\n        }\n    }\n    \n    cout << dist[N - 1] << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:52:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_CITIES 100000\n#define MAX_ROUTES 200000\n\ntypedef struct {\n    int to;\n    int next;\n} Edge;\n\nEdge edges[MAX_ROUTES * 2];\nint head[MAX_CITIES + 1];\nint edgeCount = 0;\n\nint parent[MAX_CITIES + 1];\nint rank[MAX_CITIES + 1];\nint fareIncrease[MAX_CITIES + 1];\n\nvoid initDisjointSet(int n) {\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n}\n\nint findSet(int x) {\n    if (parent[x] != x)\n        parent[x] = findSet(parent[x]);\n    return parent[x];\n}\n\nvoid unionSet(int x, int y) {\n    int px = findSet(x);\n    int py = findSet(y);\n    \n    if (px == py) return;\n    \n    if (rank[px] < rank[py])\n        parent[px] = py;\n    else if (rank[px] > rank[py])\n        parent[py] = px;\n    else {\n        parent[py] = px;\n        rank[px]++;\n    }\n}\n\nvoid addEdge(int u, int v) {\n    edges[edgeCount].to = v;\n    edges[edgeCount].next = head[u];\n    head[u] = edgeCount++;\n    \n    edges[edgeCount].to = u;\n    edges[edgeCount].next = head[v];\n    head[v] = edgeCount++;\n}\n\nint main() {\n    int N, M, K;\n    scanf(\"%d %d %d\", &N, &M, &K);\n    \n    initDisjointSet(N);\n    memset(head, -1, sizeof(head));\n    memset(fareIncrease, 0, sizeof(fareIncrease));\n    \n    for (int i = 0; i < M; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        addEdge(u, v);\n    }\n    \n    for (int i = 0; i < K; i++) {\n        int city;\n        scanf(\"%d\", &city);\n        fareIncrease[city]++;\n    }\n    \n    for (int i = 1; i <= N; i++) {\n        for (int j = head[i]; j != -1; j = edges[j].next) {\n            int neighbor = edges[j].to;\n            if (fareIncrease[i] > 0 && fareIncrease[neighbor] > 0) {\n                unionSet(i, neighbor);\n            }\n        }\n    }\n    \n    int dissatisfiedCities = 0;\n    int counted[MAX_CITIES + 1] = {0};\n    \n    for (int i = 1; i <= N; i++) {\n        if (fareIncrease[i] > 0) {\n            int root = findSet(i);\n            if (!counted[root]) {\n                dissatisfiedCities++;\n                counted[root] = 1;\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", dissatisfiedCities);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:54:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int N, M, K;\n    cin >> N >> M >> K;\n\n    vector<int> population(N);\n    for (int i = 0; i < N; i++) {\n        cin >> population[i];\n    }\n\n    vector<vector<int>> routes(N, vector<int>(N, 0));\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        cin >> a >> b;\n        routes[a-1][b-1] = routes[b-1][a-1] = 1;\n    }\n\n    vector<int> fare_increases(N, 0);\n    for (int i = 0; i < K; i++) {\n        int p, x;\n        cin >> p >> x;\n        fare_increases[p-1] += x;\n    }\n\n    int dissatisfied_cities = 0;\n    for (int city = 0; city < N; city++) {\n        int total_increase = 0;\n        for (int connected_city = 0; connected_city < N; connected_city++) {\n            if (routes[city][connected_city]) {\n                total_increase += fare_increases[connected_city];\n            }\n        }\n        \n        if (total_increase > population[city]) {\n            dissatisfied_cities++;\n        }\n    }\n\n    cout << dissatisfied_cities << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:55:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to, year;\n        Edge(int to, int year) {\n            this.to = to;\n            this.year = year;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        int K = sc.nextInt();\n        int Q = sc.nextInt();\n\n        List<List<Edge>> adj = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            adj.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < M; i++) {\n            int A = sc.nextInt();\n            int B = sc.nextInt();\n            int L = sc.nextInt();\n            int C = sc.nextInt();\n            adj.get(A).add(new Edge(B, C));\n            adj.get(B).add(new Edge(A, C));\n        }\n\n        int[] P = new int[K + 1];\n        int[] Y = new int[K + 1];\n        for (int i = 1; i <= K; i++) {\n            P[i] = sc.nextInt();\n            Y[i] = sc.nextInt();\n        }\n\n        int[] minYear = new int[N + 1];\n        Arrays.fill(minYear, Integer.MAX_VALUE);\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n\n        for (int i = 1; i <= K; i++) {\n            int city = P[i];\n            int year = Y[i];\n            if (year < minYear[city]) {\n                minYear[city] = year;\n                pq.offer(new int[]{city, year});\n            }\n        }\n\n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int city = current[0];\n            int currentYear = current[1];\n            if (currentYear > minYear[city]) continue;\n\n            for (Edge edge : adj.get(city)) {\n                int nextCity = edge.to;\n                int nextYear = Math.max(currentYear, edge.year);\n                if (nextYear < minYear[nextCity]) {\n                    minYear[nextCity] = nextYear;\n                    pq.offer(new int[]{nextCity, nextYear});\n                }\n            }\n        }\n\n        int count = 0;\n        for (int i = 0; i < Q; i++) {\n            int S = sc.nextInt();\n            int T = sc.nextInt();\n            if (minYear[S] <= T) {\n                count++;\n            }\n        }\n\n        System.out.println(count);\n    }\n}",
    "timestamp": "2025-08-05 18:55:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def dissatisfied_cities(n, m, k, city_fares, routes, fare_increase_plans):\n    # Function to calculate dissatisfied cities\n    dissatisfied = set()\n\n    # Apply fare increase plans\n    for plan in fare_increase_plans:\n        for i in range(plan[0] - 1, plan[1]):\n            city_fares[i] = plan[2]\n\n    # Calculate dissatisfaction\n    for route in routes:\n        if city_fares[route[0] - 1] > city_fares[route[1] - 1] or city_fares[route[1] - 1] > city_fares[route[0] - 1]:\n            dissatisfied.add(route[0])\n            dissatisfied.add(route[1])\n\n    return len(dissatisfied)\n\n# Sample Input\nn = 3  # Number of cities\nm = 3  # Number of routes\nk = 2  # Number of fare increase plans\ncity_fares = [2, 2, 1]\nroutes = [(1, 2), (2, 3), (3, 1)]\nfare_increase_plans = [(1, 2, 3), (3, 3, 4)]\n\n# Function call to get the number of dissatisfied cities\nresult = dissatisfied_cities(n, m, k, city_fares, routes, fare_increase_plans)\nprint(result)  # Output: number of dissatisfied cities",
    "timestamp": "2025-08-13 01:18:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class RailwayDissatisfaction {\n    static class Edge {\n        int from, to, cost;\n        Edge(int from, int to, int cost) {\n            this.from = from;\n            this.to = to;\n            this.cost = cost;\n        }\n    }\n\n    static class UnionFind {\n        int[] parent, rank;\n\n        UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n        }\n\n        int find(int u) {\n            if (parent[u] != u) {\n                parent[u] = find(parent[u]);\n            }\n            return parent[u];\n        }\n\n        boolean union(int u, int v) {\n            int rootU = find(u);\n            int rootV = find(v);\n            if (rootU != rootV) {\n                if (rank[rootU] > rank[rootV]) {\n                    parent[rootV] = rootU;\n                } else if (rank[rootU] < rank[rootV]) {\n                    parent[rootU] = rootV;\n                } else {\n                    parent[rootV] = rootU;\n                    rank[rootU]++;\n                }\n                return true;\n            }\n            return false;\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] params = br.readLine().split(\" \");\n        int n = Integer.parseInt(params[0]);\n        int m = Integer.parseInt(params[1]);\n        int q = Integer.parseInt(params[2]);\n\n        Edge[] edges = new Edge[m];\n        for (int i = 0; i < m; i++) {\n            String[] edgeData = br.readLine().split(\" \");\n            int u = Integer.parseInt(edgeData[0]) - 1;\n            int v = Integer.parseInt(edgeData[1]) - 1;\n            int c = Integer.parseInt(edgeData[2]);\n            edges[i] = new Edge(u, v, c);\n        }\n\n        Arrays.sort(edges, (e1, e2) -> Integer.compare(e1.cost, e2.cost));\n\n        int[] dissatisfaction = new int[n];\n        for (int i = 0; i < q; i++) {\n            String[] planData = br.readLine().split(\" \");\n            int year = Integer.parseInt(planData[0]);\n            int increase = Integer.parseInt(planData[1]);\n\n            UnionFind uf = new UnionFind(n);\n            int totalCost = 0;\n\n            for (Edge edge : edges) {\n                if (edge.cost <= increase) {\n                    uf.union(edge.from, edge.to);\n                    totalCost += edge.cost;\n                }\n            }\n\n            boolean[] visited = new boolean[n];\n            for (int city = 0; city < n; city++) {\n                if (!visited[uf.find(city)]) {\n                    dissatisfaction[uf.find(city)]++;\n                    visited[uf.find(city)] = true;\n                }\n            }\n        }\n\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (dissatisfaction[i] == 1) {\n                result++;\n            }\n        }\n\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-13 01:18:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_CITIES 1000\n#define MAX_ROUTES 10000\n\ntypedef struct {\n    int city1;\n    int city2;\n    int current_fare;\n} Route;\n\nint num_cities, num_routes, num_years;\nint fare_increases[MAX_CITIES];\nRoute routes[MAX_ROUTES];\nint dissatisfied_cities[MAX_CITIES];\n\nvoid read_input() {\n    scanf(\"%d %d %d\", &num_cities, &num_routes, &num_years);\n    for (int i = 0; i < num_routes; i++) {\n        scanf(\"%d %d %d\", &routes[i].city1, &routes[i].city2, &routes[i].current_fare);\n    }\n    for (int i = 0; i < num_cities; i++) {\n        fare_increases[i] = 0;\n    }\n    for (int year = 0; year < num_years; year++) {\n        for (int i = 0; i < num_cities; i++) {\n            int increase;\n            scanf(\"%d\", &increase);\n            fare_increases[i] += increase;\n        }\n    }\n}\n\nvoid calculate_dissatisfaction() {\n    memset(dissatisfied_cities, 0, sizeof(dissatisfied_cities));\n\n    for (int i = 0; i < num_routes; i++) {\n        int fare_increase_1 = fare_increases[routes[i].city1 - 1];\n        int fare_increase_2 = fare_increases[routes[i].city2 - 1];\n        int max_initial_fare = routes[i].current_fare > routes[i].current_fare ? routes[i].current_fare : routes[i].current_fare;\n        if (fare_increase_1 > max_initial_fare || fare_increase_2 > max_initial_fare) {\n            dissatisfied_cities[routes[i].city1 - 1] = 1;\n            dissatisfied_cities[routes[i].city2 - 1] = 1;\n        }\n    }\n}\n\nvoid print_dissatisfied_count() {\n    int count = 0;\n    for (int i = 0; i < num_cities; i++) {\n        if (dissatisfied_cities[i]) {\n            count++;\n        }\n    }\n    printf(\"%d\\n\", count);\n}\n\nint main() {\n    read_input();\n    calculate_dissatisfaction();\n    print_dissatisfied_count();\n    return 0;\n}",
    "timestamp": "2025-08-13 01:18:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_railway_dissatisfaction(N, M, R, routes, fare_increases):\n    # Track the fare for each city\n    fares = [0] * (N + 1)\n    \n    # Process fare increases for each city\n    for r in range(R):\n        for city in range(1, N + 1):\n            fares[city] += fare_increases[r][city - 1]\n    \n    # Count dissatisfied cities\n    dissatisfied_cities = 0\n    \n    # Check satisfaction for each city\n    for city in range(1, N + 1):\n        # Check connections to other cities\n        is_dissatisfied = False\n        for route in routes:\n            city1, city2, max_acceptable_diff = route\n            \n            # Compare fare differences\n            if abs(fares[city1] - fares[city2]) > max_acceptable_diff:\n                is_dissatisfied = True\n                break\n        \n        # Increment dissatisfied cities count\n        if is_dissatisfied:\n            dissatisfied_cities += 1\n    \n    return dissatisfied_cities\n\n# Input parsing\nN, M, R = map(int, input().split())\nroutes = []\nfor _ in range(M):\n    city1, city2, max_diff = map(int, input().split())\n    routes.append((city1, city2, max_diff))\n\nfare_increases = []\nfor _ in range(R):\n    increases = list(map(int, input().split()))\n    fare_increases.append(increases)\n\n# Solve and print result\nresult = solve_railway_dissatisfaction(N, M, R, routes, fare_increases)\nprint(result)",
    "timestamp": "2025-08-13 01:18:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    M = int(input[ptr])\n    ptr += 1\n    K = int(input[ptr])\n    ptr += 1\n    S = int(input[ptr]) - 1\n    ptr += 1\n    T = int(input[ptr]) - 1\n    ptr += 1\n    X = int(input[ptr]) - 1\n    ptr += 1\n\n    adj = [[] for _ in range(N)]\n    for _ in range(M):\n        u = int(input[ptr]) - 1\n        ptr += 1\n        v = int(input[ptr]) - 1\n        ptr += 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    P = []\n    Q = []\n    for _ in range(K):\n        p = int(input[ptr])\n        ptr += 1\n        q = int(input[ptr])\n        ptr += 1\n        P.append(p)\n        Q.append(q)\n\n    # Initialize DP table\n    # dp[t][v][parity]: min cost to reach v at year t with parity of visits to X\n    INF = float('inf')\n    dp = [[[INF, INF] for _ in range(N)] for _ in range(K+1)]\n    dp[0][S][0] = 0\n\n    for t in range(K):\n        for v in range(N):\n            for parity in [0, 1]:\n                if dp[t][v][parity] == INF:\n                    continue\n                current_cost = dp[t][v][parity]\n                for neighbor in adj[v]:\n                    new_parity = parity\n                    if neighbor == X:\n                        new_parity = 1 - parity\n                    new_cost = current_cost + (P[t] if new_parity == 0 else Q[t])\n                    if new_cost < dp[t+1][neighbor][new_parity]:\n                        dp[t+1][neighbor][new_parity] = new_cost\n\n    min_cost = min(dp[K][T][0], dp[K][T][1])\n    if min_cost == INF:\n        print(-1)\n    else:\n        print(min_cost)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 01:19:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nstruct Edge {\n    int to, cost;\n};\n\nconst int INF = numeric_limits<int>::max();\n\nvector<vector<Edge>> graph;\nvector<int> dissatisfactionYears, initialFare;\nvector<bool> dissatisfied;\n\nvoid bfs(int startCity, int fareIncrease, int years) {\n    vector<int> minCost(graph.size(), INF);\n    queue<int> q;\n    q.push(startCity);\n    minCost[startCity] = 0;\n\n    while (!q.empty()) {\n        int city = q.front();\n        q.pop();\n\n        for (const Edge& edge : graph[city]) {\n            if (minCost[edge.to] > minCost[city] + edge.cost) {\n                minCost[edge.to] = minCost[city] + edge.cost;\n                q.push(edge.to);\n            }\n        }\n    }\n\n    for (int i = 0; i < graph.size(); ++i) {\n        if (minCost[i] != INF && initialFare[i] < minCost[i] + fareIncrease * years) {\n            dissatisfied[i] = true;\n        }\n    }\n}\n\nint main() {\n    int cities, edges, years;\n    cin >> cities >> edges >> years;\n\n    graph.resize(cities);\n    initialFare.resize(cities);\n    dissatisfactionYears.resize(cities, INF);\n    dissatisfied.resize(cities, false);\n\n    for (int i = 0; i < cities; ++i) {\n        cin >> initialFare[i];\n    }\n\n    for (int i = 0; i < edges; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        graph[u].push_back({v, w});\n        graph[v].push_back({u, w});\n    }\n\n    for (int i = 0; i < years; ++i) {\n        int startCity, fareIncrease;\n        cin >> startCity >> fareIncrease;\n        --startCity;\n\n        bfs(startCity, fareIncrease, i + 1);\n    }\n\n    int dissatisfiedCount = 0;\n    for (bool d : dissatisfied) {\n        if (d) ++dissatisfiedCount;\n    }\n\n    cout << dissatisfiedCount << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:59:35"
  }
]